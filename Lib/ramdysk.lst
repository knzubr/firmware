   1               		.file	"ramdysk.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__RAMPY__ = 0x3a
   7               	__RAMPX__ = 0x39
   8               	__RAMPD__ = 0x38
   9               	__CCP__ = 0x34
  10               	__tmp_reg__ = 0
  11               	__zero_reg__ = 1
  14               		.text
  15               	.Ltext0:
 599               	uaktualnijRozmiarPliku:
 600               		.stabd	46,0,0
   1:../../Lib/ramdysk.c **** #include "ramdysk.h"
   2:../../Lib/ramdysk.c **** #include <string.h>
   3:../../Lib/ramdysk.c **** 
   4:../../Lib/ramdysk.c **** #define systemTime() 0; //Dodać w pliku hardware.h funkcje do odczytu czasu systemowego
   5:../../Lib/ramdysk.c **** 
   6:../../Lib/ramdysk.c **** static uint8_t         znajdzWolnyKlaster(void);
   7:../../Lib/ramdysk.c **** static uint8_t         nastepnyKlaster(uint8_t nrKlastra);
   8:../../Lib/ramdysk.c **** static uint8_t         znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow);
   9:../../Lib/ramdysk.c **** #if ( USUNKLASTER == 1)
  10:../../Lib/ramdysk.c **** static uint8_t         usunKlaster(uint8_t nrKlastra);
  11:../../Lib/ramdysk.c **** #endif
  12:../../Lib/ramdysk.c **** static uint8_t         wObrebiePliku(struct ramPlikFd *fd);
  13:../../Lib/ramdysk.c **** static void            uaktualnijRozmiarPliku(struct ramPlikFd *fd);
  14:../../Lib/ramdysk.c **** static struct ramPlik* znajdzPlik(const char *nazwa);
  15:../../Lib/ramdysk.c **** static struct ramPlik* znajdzMiejsceNaWpis(void);
  16:../../Lib/ramdysk.c **** static void            czyscKlaster(uint8_t nrKlastra);
  17:../../Lib/ramdysk.c **** 
  18:../../Lib/ramdysk.c **** static void            czyscKlaster(uint8_t nrKlastra)
  19:../../Lib/ramdysk.c **** {
  20:../../Lib/ramdysk.c ****   uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  21:../../Lib/ramdysk.c ****   memset (tmpPtr, 0, 256);
  22:../../Lib/ramdysk.c **** }
  23:../../Lib/ramdysk.c **** 
  24:../../Lib/ramdysk.c **** static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
  25:../../Lib/ramdysk.c **** {
  26:../../Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi > fd->IndHi)
  27:../../Lib/ramdysk.c ****     return 0;
  28:../../Lib/ramdysk.c ****   
  29:../../Lib/ramdysk.c ****   if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
  30:../../Lib/ramdysk.c ****     return 0;
  31:../../Lib/ramdysk.c **** 
  32:../../Lib/ramdysk.c ****   return 1;
  33:../../Lib/ramdysk.c **** }
  34:../../Lib/ramdysk.c **** 
  35:../../Lib/ramdysk.c **** static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
  36:../../Lib/ramdysk.c **** {
 602               	.LM0:
 603               	.LFBB1:
 604               	/* prologue: function */
 605               	/* frame size = 0 */
 606               	/* stack size = 0 */
 607               	.L__stack_usage = 0
 608 0000 FC01      		movw r30,r24
  37:../../Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi == fd->IndHi)
 610               	.LM1:
 611 0002 A481      		ldd r26,Z+4
 612 0004 B581      		ldd r27,Z+5
 613 0006 1296      		adiw r26,2
 614 0008 9C91      		ld r25,X
 615 000a 1297      		sbiw r26,2
 616 000c 8381      		ldd r24,Z+3
 617 000e 9813      		cpse r25,r24
 618 0010 00C0      		rjmp .L2
  38:../../Lib/ramdysk.c ****   {
  39:../../Lib/ramdysk.c ****     if (fd->wpis->rozmiarLo < fd->IndLo)
 620               	.LM2:
 621 0012 8281      		ldd r24,Z+2
 622 0014 1196      		adiw r26,1
 623 0016 9C91      		ld r25,X
 624 0018 1197      		sbiw r26,1
 625 001a 9817      		cp r25,r24
 626 001c 00F4      		brsh .L2
  40:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = fd->IndLo;
 628               	.LM3:
 629 001e 1196      		adiw r26,1
 630 0020 8C93      		st X,r24
 631               	.L2:
  41:../../Lib/ramdysk.c ****   }
  42:../../Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi < fd->IndHi)
 633               	.LM4:
 634 0022 A481      		ldd r26,Z+4
 635 0024 B581      		ldd r27,Z+5
 636 0026 1296      		adiw r26,2
 637 0028 9C91      		ld r25,X
 638 002a 1297      		sbiw r26,2
 639 002c 8381      		ldd r24,Z+3
 640 002e 9817      		cp r25,r24
 641 0030 00F4      		brsh .L1
  43:../../Lib/ramdysk.c ****   {
  44:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = fd->IndLo;    
 643               	.LM5:
 644 0032 8281      		ldd r24,Z+2
 645 0034 1196      		adiw r26,1
 646 0036 8C93      		st X,r24
  45:../../Lib/ramdysk.c ****       fd->wpis->rozmiarHi = fd->IndHi;    
 648               	.LM6:
 649 0038 A481      		ldd r26,Z+4
 650 003a B581      		ldd r27,Z+5
 651 003c 8381      		ldd r24,Z+3
 652 003e 1296      		adiw r26,2
 653 0040 8C93      		st X,r24
 654               	.L1:
 655 0042 0895      		ret
 657               	.Lscope1:
 659               		.stabd	78,0,0
 663               	nastepnyKlaster:
 664               		.stabd	46,0,0
  46:../../Lib/ramdysk.c ****   }
  47:../../Lib/ramdysk.c **** }
  48:../../Lib/ramdysk.c **** 
  49:../../Lib/ramdysk.c **** static uint8_t znajdzWolnyKlaster(void)
  50:../../Lib/ramdysk.c **** {
  51:../../Lib/ramdysk.c ****   uint8_t i;
  52:../../Lib/ramdysk.c ****   for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli m
  53:../../Lib/ramdysk.c ****   {                                        //Może być rozszerzony na inne klastry.
  54:../../Lib/ramdysk.c ****     if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
  55:../../Lib/ramdysk.c ****     {
  56:../../Lib/ramdysk.c ****       klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
  57:../../Lib/ramdysk.c ****       czyscKlaster(i);                     //Czyszczenie zawartości klastra.
  58:../../Lib/ramdysk.c ****       return i;
  59:../../Lib/ramdysk.c ****     }
  60:../../Lib/ramdysk.c ****   }
  61:../../Lib/ramdysk.c ****   return 0;
  62:../../Lib/ramdysk.c **** }
  63:../../Lib/ramdysk.c **** 
  64:../../Lib/ramdysk.c **** static uint8_t nastepnyKlaster(uint8_t nrKlastra)
  65:../../Lib/ramdysk.c **** {
 666               	.LM7:
 667               	.LFBB2:
 668               	/* prologue: function */
 669               	/* frame size = 0 */
 670               	/* stack size = 0 */
 671               	.L__stack_usage = 0
 672 0044 982F      		mov r25,r24
  66:../../Lib/ramdysk.c ****   uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
 674               	.LM8:
 675 0046 E82F      		mov r30,r24
 676 0048 F0E0      		ldi r31,0
 677 004a E050      		subi r30,lo8(-(klastry))
 678 004c F040      		sbci r31,hi8(-(klastry))
 679 004e 8081      		ld r24,Z
  67:../../Lib/ramdysk.c ****   if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, 
 681               	.LM9:
 682 0050 8913      		cpse r24,r25
 683 0052 00C0      		rjmp .L6
 684 0054 A0E0      		ldi r26,lo8(klastry+1)
 685 0056 B0E0      		ldi r27,hi8(klastry+1)
 686 0058 81E0      		ldi r24,lo8(1)
 687               	.L7:
  68:../../Lib/ramdysk.c ****   {                                        //Należy znaleźć jakiś wolny klaster i go dodać do 
  69:../../Lib/ramdysk.c ****     for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 
  70:../../Lib/ramdysk.c ****     {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma woln
  71:../../Lib/ramdysk.c ****       if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, ż
 689               	.LM10:
 690 005a 9D91      		ld r25,X+
 691 005c 9111      		cpse r25,__zero_reg__
 692 005e 00C0      		rjmp .L8
 693               	.L10:
  72:../../Lib/ramdysk.c ****         break;                             //Wtedy można przerwać szukanie kolejnych klastrów dl
  73:../../Lib/ramdysk.c ****     }                                      //Taka implementacja z założenia powoduje defragmentac
  74:../../Lib/ramdysk.c ****     
  75:../../Lib/ramdysk.c ****     if (temp != 0)                         //Znaleziono jakiś wolny klaster
  76:../../Lib/ramdysk.c ****     {
  77:../../Lib/ramdysk.c ****       klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku ko
 695               	.LM11:
 696 0060 8083      		st Z,r24
  78:../../Lib/ramdysk.c ****       klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym 
 698               	.LM12:
 699 0062 282F      		mov r18,r24
 700 0064 30E0      		ldi r19,0
 701 0066 F901      		movw r30,r18
 702 0068 E050      		subi r30,lo8(-(klastry))
 703 006a F040      		sbci r31,hi8(-(klastry))
 704 006c 8083      		st Z,r24
 705               	.LBB4:
 706               	.LBB5:
  21:../../Lib/ramdysk.c ****   memset (tmpPtr, 0, 256);
 708               	.LM13:
 709 006e E0E0      		ldi r30,0
 710 0070 F0E8      		ldi r31,lo8(-128)
 711 0072 F80F      		add r31,r24
 712 0074 20E0      		ldi r18,0
 713 0076 31E0      		ldi r19,lo8(1)
 714 0078 DF01      		movw r26,r30
 715 007a A901      		movw r20,r18
 716               		0:
 717 007c 1D92      		st X+,__zero_reg__
 718 007e 4150      		subi r20,1
 719 0080 5040      		sbci r21,0
 720 0082 01F4      		brne 0b
 721 0084 0895      		ret
 722               	.L8:
 723               	.LBE5:
 724               	.LBE4:
  69:../../Lib/ramdysk.c ****     for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 
 726               	.LM14:
 727 0086 8F5F      		subi r24,lo8(-(1))
 728 0088 8038      		cpi r24,lo8(-128)
 729 008a 01F4      		brne .L7
 730 008c 00C0      		rjmp .L10
 731               	.L6:
  79:../../Lib/ramdysk.c ****       czyscKlaster(temp);                  //Czyszczenie klastra
  80:../../Lib/ramdysk.c ****     }
  81:../../Lib/ramdysk.c ****   }
  82:../../Lib/ramdysk.c ****   return temp;
  83:../../Lib/ramdysk.c **** }
 733               	.LM15:
 734 008e 0895      		ret
 739               	.Lscope2:
 741               		.stabd	78,0,0
 746               	znajdzKlasterN:
 747               		.stabd	46,0,0
  84:../../Lib/ramdysk.c **** 
  85:../../Lib/ramdysk.c **** static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
  86:../../Lib/ramdysk.c **** {
 749               	.LM16:
 750               	.LFBB3:
 751 0090 1F93      		push r17
 752 0092 CF93      		push r28
 753 0094 DF93      		push r29
 754 0096 1F92      		push __zero_reg__
 755 0098 CDB7      		in r28,__SP_L__
 756 009a DEB7      		in r29,__SP_H__
 757               	/* prologue: function */
 758               	/* frame size = 1 */
 759               	/* stack size = 4 */
 760               	.L__stack_usage = 4
  87:../../Lib/ramdysk.c ****   uint8_t ind;                             //PIerwszy klaster ma indeks 0
  88:../../Lib/ramdysk.c ****   uint8_t wynik = nrPierwszegoKlastra;
  89:../../Lib/ramdysk.c ****   for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klast
 762               	.LM17:
 763 009c 10E0      		ldi r17,0
 764               	.L12:
 766               	.LM18:
 767 009e 1617      		cp r17,r22
 768 00a0 01F0      		breq .L13
  90:../../Lib/ramdysk.c ****   {
  91:../../Lib/ramdysk.c ****     wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatyc
 770               	.LM19:
 771 00a2 6983      		std Y+1,r22
 772 00a4 0E94 0000 		call nastepnyKlaster
  92:../../Lib/ramdysk.c ****     if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
 774               	.LM20:
 775 00a8 6981      		ldd r22,Y+1
 776 00aa 8823      		tst r24
 777 00ac 01F0      		breq .L13
  89:../../Lib/ramdysk.c ****   for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klast
 779               	.LM21:
 780 00ae 1F5F      		subi r17,lo8(-(1))
 781 00b0 00C0      		rjmp .L12
 782               	.L13:
 783               	/* epilogue start */
  93:../../Lib/ramdysk.c ****       break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany n
  94:../../Lib/ramdysk.c ****   }
  95:../../Lib/ramdysk.c ****   return wynik;
  96:../../Lib/ramdysk.c **** }
 785               	.LM22:
 786 00b2 0F90      		pop __tmp_reg__
 787 00b4 DF91      		pop r29
 788 00b6 CF91      		pop r28
 789 00b8 1F91      		pop r17
 790 00ba 0895      		ret
 795               	.Lscope3:
 797               		.stabd	78,0,0
 801               	znajdzPlik:
 802               		.stabd	46,0,0
  97:../../Lib/ramdysk.c **** 
  98:../../Lib/ramdysk.c **** #if ( USUNKLASTER == 1)
  99:../../Lib/ramdysk.c **** static uint8_t usunKlaster(uint8_t nrKlastra)
 100:../../Lib/ramdysk.c **** {
 101:../../Lib/ramdysk.c ****   if (klastry[nrKlastra] == 0)
 102:../../Lib/ramdysk.c ****     return 1;                              //Klaster nie był zajęty                     
 103:../../Lib/ramdysk.c ****   uint8_t temp;
 104:../../Lib/ramdysk.c ****   for (temp = 0; temp <128; temp++)
 105:../../Lib/ramdysk.c ****     if (klastry[temp] == nrKlastra)        //Znaleziono klaster, który wskazuje na ten usuwany
 106:../../Lib/ramdysk.c ****     {
 107:../../Lib/ramdysk.c ****       if (klastry[nrKlastra] == nrKlastra) //Sprawdzanie, czy usuwany klaster nie jest ostatni.
 108:../../Lib/ramdysk.c **** 	klastry[temp] = temp;              //Jeśli tak, to klaster poprzedni musi być ustawiony jako kla
 109:../../Lib/ramdysk.c ****       else
 110:../../Lib/ramdysk.c **** 	klastry[temp] = klastry[nrKlastra];//Klaster poprzedni wskazuje na klaster następny za tym usuwan
 111:../../Lib/ramdysk.c ****     }
 112:../../Lib/ramdysk.c ****   klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
 113:../../Lib/ramdysk.c ****   return 0;
 114:../../Lib/ramdysk.c **** }
 115:../../Lib/ramdysk.c **** #endif
 116:../../Lib/ramdysk.c **** 
 117:../../Lib/ramdysk.c **** static struct ramPlik* znajdzPlik(const char *nazwa)
 118:../../Lib/ramdysk.c **** {
 804               	.LM23:
 805               	.LFBB4:
 806 00bc 9F92      		push r9
 807 00be AF92      		push r10
 808 00c0 BF92      		push r11
 809 00c2 CF92      		push r12
 810 00c4 DF92      		push r13
 811 00c6 EF92      		push r14
 812 00c8 FF92      		push r15
 813 00ca 0F93      		push r16
 814 00cc 1F93      		push r17
 815 00ce CF93      		push r28
 816 00d0 DF93      		push r29
 817               	/* prologue: function */
 818               	/* frame size = 0 */
 819               	/* stack size = 11 */
 820               	.L__stack_usage = 11
 821 00d2 8C01      		movw r16,r24
 119:../../Lib/ramdysk.c ****   uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
 823               	.LM24:
 824 00d4 FC01      		movw r30,r24
 825               		0:
 826 00d6 0190      		ld __tmp_reg__,Z+
 827 00d8 0020      		tst __tmp_reg__
 828 00da 01F4      		brne 0b
 829 00dc 3197      		sbiw r30,1
 830 00de 8E2F      		mov r24,r30
 831 00e0 801B      		sub r24,r16
 832 00e2 8930      		cpi r24,lo8(9)
 833 00e4 00F0      		brlo .L19
 834 00e6 88E0      		ldi r24,lo8(8)
 835               	.L19:
 120:../../Lib/ramdysk.c ****   if (dlNazwy > 8)
 121:../../Lib/ramdysk.c ****     dlNazwy = 8;
 122:../../Lib/ramdysk.c ****   
 123:../../Lib/ramdysk.c ****   
 124:../../Lib/ramdysk.c ****   if (nazwa[dlNazwy-1] == 0)
 837               	.LM25:
 838 00e8 F801      		movw r30,r16
 839 00ea E80F      		add r30,r24
 840 00ec F11D      		adc r31,__zero_reg__
 841 00ee 3197      		sbiw r30,1
 842 00f0 9081      		ld r25,Z
 843 00f2 9111      		cpse r25,__zero_reg__
 844 00f4 00C0      		rjmp .L20
 125:../../Lib/ramdysk.c ****     dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
 846               	.LM26:
 847 00f6 8150      		subi r24,lo8(-(-1))
 848               	.L20:
 849 00f8 D801      		movw r26,r16
 850 00fa 1196      		adiw r26,1
 126:../../Lib/ramdysk.c ****   struct ramPlik *plik;
 127:../../Lib/ramdysk.c ****   uint8_t temp;
 128:../../Lib/ramdysk.c ****   uint8_t tempKlaster=0;
 129:../../Lib/ramdysk.c ****   uint8_t tempKlaster2;
 130:../../Lib/ramdysk.c **** 
 131:../../Lib/ramdysk.c ****   for (temp=1; temp < dlNazwy; temp ++)
 852               	.LM27:
 853 00fc 91E0      		ldi r25,lo8(1)
 854               	.L21:
 856               	.LM28:
 857 00fe 9817      		cp r25,r24
 858 0100 00F4      		brsh .L32
 132:../../Lib/ramdysk.c ****   {
 133:../../Lib/ramdysk.c ****     if (nazwa[temp] == ' ')               //Pozbycie sie spacji
 860               	.LM29:
 861 0102 2D91      		ld r18,X+
 862 0104 2032      		cpi r18,lo8(32)
 863 0106 01F0      		breq .L28
 131:../../Lib/ramdysk.c ****   for (temp=1; temp < dlNazwy; temp ++)
 865               	.LM30:
 866 0108 9F5F      		subi r25,lo8(-(1))
 867 010a 00C0      		rjmp .L21
 868               	.L32:
 134:../../Lib/ramdysk.c ****     {
 135:../../Lib/ramdysk.c ****       dlNazwy = temp;
 136:../../Lib/ramdysk.c ****       break; 
 137:../../Lib/ramdysk.c ****     }
 138:../../Lib/ramdysk.c ****   }
 139:../../Lib/ramdysk.c ****   if (dlNazwy == 0)
 870               	.LM31:
 871 010c 8111      		cpse r24,__zero_reg__
 872 010e 00C0      		rjmp .L22
 873 0110 00C0      		rjmp .L31
 874               	.L28:
 875 0112 892F      		mov r24,r25
 876               	.L22:
 877 0114 912C      		mov r9,__zero_reg__
 140:../../Lib/ramdysk.c ****     return NULL;
 141:../../Lib/ramdysk.c ****   
 142:../../Lib/ramdysk.c ****   do
 143:../../Lib/ramdysk.c ****   {
 144:../../Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 145:../../Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 146:../../Lib/ramdysk.c ****     {
 147:../../Lib/ramdysk.c ****       if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
 879               	.LM32:
 880 0116 C82E      		mov r12,r24
 881 0118 D12C      		mov r13,__zero_reg__
 882               	.L27:
 144:../../Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 884               	.LM33:
 885 011a E92C      		mov r14,r9
 886 011c F12C      		mov r15,__zero_reg__
 887 011e E701      		movw r28,r14
 888 0120 C058      		subi r28,-128
 889 0122 DF4F      		sbci r29,-1
 890 0124 DC2F      		mov r29,r28
 891 0126 CC27      		clr r28
 892 0128 5E01      		movw r10,r28
 893 012a B394      		inc r11
 894               	.L26:
 896               	.LM34:
 897 012c A601      		movw r20,r12
 898 012e BE01      		movw r22,r28
 899 0130 6C5F      		subi r22,-4
 900 0132 7F4F      		sbci r23,-1
 901 0134 C801      		movw r24,r16
 902 0136 0E94 0000 		call strncmp
 903 013a 892B      		or r24,r25
 904 013c 01F0      		breq .L30
 148:../../Lib/ramdysk.c **** 	return plik;
 149:../../Lib/ramdysk.c ****       plik++;                                            //Przejście do kolejnego wpisu (w tym sam
 906               	.LM35:
 907 013e 6096      		adiw r28,16
 145:../../Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 909               	.LM36:
 910 0140 CA15      		cp r28,r10
 911 0142 DB05      		cpc r29,r11
 912 0144 01F4      		brne .L26
 150:../../Lib/ramdysk.c ****     }   
 151:../../Lib/ramdysk.c ****     tempKlaster2 = tempKlaster;
 152:../../Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 914               	.LM37:
 915 0146 F701      		movw r30,r14
 916 0148 E050      		subi r30,lo8(-(klastry))
 917 014a F040      		sbci r31,hi8(-(klastry))
 918 014c 8081      		ld r24,Z
 153:../../Lib/ramdysk.c ****   }
 154:../../Lib/ramdysk.c ****   while (tempKlaster2 != tempKlaster);
 920               	.LM38:
 921 014e 9816      		cp r9,r24
 922 0150 01F0      		breq .L31
 152:../../Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 924               	.LM39:
 925 0152 982E      		mov r9,r24
 926 0154 00C0      		rjmp .L27
 927               	.L30:
 928 0156 CE01      		movw r24,r28
 929 0158 00C0      		rjmp .L24
 930               	.L31:
 140:../../Lib/ramdysk.c ****     return NULL;
 932               	.LM40:
 933 015a 80E0      		ldi r24,0
 934 015c 90E0      		ldi r25,0
 935               	.L24:
 936               	/* epilogue start */
 155:../../Lib/ramdysk.c ****   return NULL;
 156:../../Lib/ramdysk.c **** }
 938               	.LM41:
 939 015e DF91      		pop r29
 940 0160 CF91      		pop r28
 941 0162 1F91      		pop r17
 942 0164 0F91      		pop r16
 943 0166 FF90      		pop r15
 944 0168 EF90      		pop r14
 945 016a DF90      		pop r13
 946 016c CF90      		pop r12
 947 016e BF90      		pop r11
 948 0170 AF90      		pop r10
 949 0172 9F90      		pop r9
 950 0174 0895      		ret
 955               	.Lscope4:
 957               		.stabd	78,0,0
 960               	znajdzWolnyKlaster:
 961               		.stabd	46,0,0
  50:../../Lib/ramdysk.c **** {
 963               	.LM42:
 964               	.LFBB5:
 965               	/* prologue: function */
 966               	/* frame size = 0 */
 967               	/* stack size = 0 */
 968               	.L__stack_usage = 0
 969 0176 E0E0      		ldi r30,lo8(klastry+1)
 970 0178 F0E0      		ldi r31,hi8(klastry+1)
  52:../../Lib/ramdysk.c ****   for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli m
 972               	.LM43:
 973 017a 21E0      		ldi r18,lo8(1)
 974 017c 30E0      		ldi r19,0
 975               	.L34:
 976 017e 822F      		mov r24,r18
  52:../../Lib/ramdysk.c ****   for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli m
 978               	.LM44:
 979 0180 2038      		cpi r18,-128
 980 0182 3105      		cpc r19,__zero_reg__
 981 0184 01F0      		breq .L38
  54:../../Lib/ramdysk.c ****     if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
 983               	.LM45:
 984 0186 A901      		movw r20,r18
 985 0188 9191      		ld r25,Z+
 986 018a 2F5F      		subi r18,-1
 987 018c 3F4F      		sbci r19,-1
 988 018e 9111      		cpse r25,__zero_reg__
 989 0190 00C0      		rjmp .L34
  56:../../Lib/ramdysk.c ****       klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
 991               	.LM46:
 992 0192 FA01      		movw r30,r20
 993 0194 E050      		subi r30,lo8(-(klastry))
 994 0196 F040      		sbci r31,hi8(-(klastry))
 995 0198 8083      		st Z,r24
 996               	.LBB8:
 997               	.LBB9:
  21:../../Lib/ramdysk.c ****   memset (tmpPtr, 0, 256);
 999               	.LM47:
 1000 019a E0E0      		ldi r30,0
 1001 019c F0E8      		ldi r31,lo8(-128)
 1002 019e F40F      		add r31,r20
 1003 01a0 20E0      		ldi r18,0
 1004 01a2 31E0      		ldi r19,lo8(1)
 1005 01a4 DF01      		movw r26,r30
 1006 01a6 A901      		movw r20,r18
 1007               		0:
 1008 01a8 1D92      		st X+,__zero_reg__
 1009 01aa 4150      		subi r20,1
 1010 01ac 5040      		sbci r21,0
 1011 01ae 01F4      		brne 0b
 1012 01b0 0895      		ret
 1013               	.L38:
 1014               	.LBE9:
 1015               	.LBE8:
  61:../../Lib/ramdysk.c ****   return 0;
 1017               	.LM48:
 1018 01b2 80E0      		ldi r24,0
  62:../../Lib/ramdysk.c **** }
 1020               	.LM49:
 1021 01b4 0895      		ret
 1023               	.Lscope5:
 1025               		.stabd	78,0,0
 1027               	.global	ramDyskInit
 1029               	ramDyskInit:
 1030               		.stabd	46,0,0
 157:../../Lib/ramdysk.c **** 
 158:../../Lib/ramdysk.c **** static struct ramPlik* znajdzMiejsceNaWpis(void)
 159:../../Lib/ramdysk.c **** {
 160:../../Lib/ramdysk.c ****   struct ramPlik *plik;
 161:../../Lib/ramdysk.c ****   uint8_t temp;
 162:../../Lib/ramdysk.c ****   uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogo
 163:../../Lib/ramdysk.c ****   uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogo
 164:../../Lib/ramdysk.c ****   do
 165:../../Lib/ramdysk.c ****   {
 166:../../Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 167:../../Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 168:../../Lib/ramdysk.c ****     {
 169:../../Lib/ramdysk.c ****       if (plik->nazwa[0] == 0)
 170:../../Lib/ramdysk.c **** 	return plik;
 171:../../Lib/ramdysk.c ****       plik++;                                            //Przejście do kolejnego wpisu (w tym sam
 172:../../Lib/ramdysk.c ****     }   
 173:../../Lib/ramdysk.c ****     tempKlaster2 = tempKlaster;
 174:../../Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 175:../../Lib/ramdysk.c ****   }
 176:../../Lib/ramdysk.c ****   while (tempKlaster2 != tempKlaster);
 177:../../Lib/ramdysk.c ****   
 178:../../Lib/ramdysk.c ****   klastry[tempKlaster] = znajdzWolnyKlaster();
 179:../../Lib/ramdysk.c ****   plik = NULL;
 180:../../Lib/ramdysk.c ****   if (klastry[tempKlaster] != 0)
 181:../../Lib/ramdysk.c ****     plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
 182:../../Lib/ramdysk.c **** 
 183:../../Lib/ramdysk.c ****   return plik;
 184:../../Lib/ramdysk.c **** }
 185:../../Lib/ramdysk.c **** 
 186:../../Lib/ramdysk.c **** 
 187:../../Lib/ramdysk.c **** void ramDyskInit(void)
 188:../../Lib/ramdysk.c **** {
 1032               	.LM50:
 1033               	.LFBB6:
 1034               	/* prologue: function */
 1035               	/* frame size = 0 */
 1036               	/* stack size = 0 */
 1037               	.L__stack_usage = 0
 189:../../Lib/ramdysk.c ****   memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
 1039               	.LM51:
 1040 01b6 80E8      		ldi r24,lo8(-128)
 1041 01b8 E0E0      		ldi r30,lo8(klastry)
 1042 01ba F0E0      		ldi r31,hi8(klastry)
 1043 01bc DF01      		movw r26,r30
 1044               		0:
 1045 01be 1D92      		st X+,__zero_reg__
 1046 01c0 8A95      		dec r24
 1047 01c2 01F4      		brne 0b
 190:../../Lib/ramdysk.c ****   memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
 1049               	.LM52:
 1050 01c4 80E0      		ldi r24,0
 1051 01c6 91E0      		ldi r25,lo8(1)
 1052 01c8 E0E0      		ldi r30,0
 1053 01ca F0E8      		ldi r31,lo8(-128)
 1054 01cc DF01      		movw r26,r30
 1055 01ce 9C01      		movw r18,r24
 1056               		0:
 1057 01d0 1D92      		st X+,__zero_reg__
 1058 01d2 2150      		subi r18,1
 1059 01d4 3040      		sbci r19,0
 1060 01d6 01F4      		brne 0b
 1061 01d8 0895      		ret
 1063               	.Lscope6:
 1065               		.stabd	78,0,0
 1068               	.global	ramDyskUtworzPlik
 1070               	ramDyskUtworzPlik:
 1071               		.stabd	46,0,0
 191:../../Lib/ramdysk.c **** }
 192:../../Lib/ramdysk.c **** uint8_t ramDyskUtworzPlik(const char *nazwa)
 193:../../Lib/ramdysk.c **** {                                        //Nowo utworzony plik nie zajmuje żadnego klastra
 1073               	.LM53:
 1074               	.LFBB7:
 1075 01da FF92      		push r15
 1076 01dc 0F93      		push r16
 1077 01de 1F93      		push r17
 1078 01e0 CF93      		push r28
 1079 01e2 DF93      		push r29
 1080               	/* prologue: function */
 1081               	/* frame size = 0 */
 1082               	/* stack size = 5 */
 1083               	.L__stack_usage = 5
 1084 01e4 8C01      		movw r16,r24
 194:../../Lib/ramdysk.c ****   uint8_t dlNazwy = strlen(nazwa);
 1086               	.LM54:
 1087 01e6 FC01      		movw r30,r24
 1088               		0:
 1089 01e8 0190      		ld __tmp_reg__,Z+
 1090 01ea 0020      		tst __tmp_reg__
 1091 01ec 01F4      		brne 0b
 1092 01ee 3197      		sbiw r30,1
 1093 01f0 FE2E      		mov r15,r30
 1094 01f2 F81A      		sub r15,r24
 1095 01f4 88E0      		ldi r24,lo8(8)
 1096 01f6 8F15      		cp r24,r15
 1097 01f8 00F4      		brsh .L41
 1098 01fa 38E0      		ldi r19,lo8(8)
 1099 01fc F32E      		mov r15,r19
 1100               	.L41:
 1101 01fe 902F      		mov r25,r16
 195:../../Lib/ramdysk.c ****   uint8_t i;
 196:../../Lib/ramdysk.c ****   if (dlNazwy > 8)
 197:../../Lib/ramdysk.c ****     dlNazwy = 8;
 198:../../Lib/ramdysk.c ****   
 199:../../Lib/ramdysk.c ****   for (i=0; i<dlNazwy; i++)
 1103               	.LM55:
 1104 0200 F801      		movw r30,r16
 1105               	.L42:
 1106 0202 8E2F      		mov r24,r30
 1107 0204 891B      		sub r24,r25
 1109               	.LM56:
 1110 0206 8F15      		cp r24,r15
 1111 0208 00F4      		brsh .L43
 200:../../Lib/ramdysk.c ****   {  if (nazwa[i] == ' ')
 1113               	.LM57:
 1114 020a 2191      		ld r18,Z+
 1115 020c 2032      		cpi r18,lo8(32)
 1116 020e 01F4      		brne .L42
 1117 0210 F82E      		mov r15,r24
 1118               	.L43:
 201:../../Lib/ramdysk.c ****      {
 202:../../Lib/ramdysk.c ****        dlNazwy = i;
 203:../../Lib/ramdysk.c ****        break;
 204:../../Lib/ramdysk.c ****      }
 205:../../Lib/ramdysk.c ****   }
 206:../../Lib/ramdysk.c ****   if (dlNazwy == 0)
 1120               	.LM58:
 1121 0212 FF20      		tst r15
 1122 0214 01F0      		breq .L55
 207:../../Lib/ramdysk.c ****     return 0;
 208:../../Lib/ramdysk.c ****   
 209:../../Lib/ramdysk.c ****   struct ramPlik *plik;
 210:../../Lib/ramdysk.c ****   if ((plik = znajdzPlik(nazwa)) != NULL)
 1124               	.LM59:
 1125 0216 C801      		movw r24,r16
 1126 0218 0E94 0000 		call znajdzPlik
 1127 021c 892B      		or r24,r25
 1128 021e 01F4      		brne .L55
 1129 0220 40E0      		ldi r20,0
 1130               	.L50:
 1131               	.LBB12:
 1132               	.LBB13:
 166:../../Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 1134               	.LM60:
 1135 0222 842F      		mov r24,r20
 1136 0224 90E0      		ldi r25,0
 1137 0226 EC01      		movw r28,r24
 1138 0228 C058      		subi r28,-128
 1139 022a DF4F      		sbci r29,-1
 1140 022c DC2F      		mov r29,r28
 1141 022e CC27      		clr r28
 1142 0230 9E01      		movw r18,r28
 1143 0232 3395      		inc r19
 1144               	.L48:
 169:../../Lib/ramdysk.c ****       if (plik->nazwa[0] == 0)
 1146               	.LM61:
 1147 0234 5C81      		ldd r21,Y+4
 1148 0236 5523      		tst r21
 1149 0238 01F0      		breq .L46
 171:../../Lib/ramdysk.c ****       plik++;                                            //Przejście do kolejnego wpisu (w tym sam
 1151               	.LM62:
 1152 023a 6096      		adiw r28,16
 167:../../Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 1154               	.LM63:
 1155 023c C217      		cp r28,r18
 1156 023e D307      		cpc r29,r19
 1157 0240 01F4      		brne .L48
 174:../../Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 1159               	.LM64:
 1160 0242 EC01      		movw r28,r24
 1161 0244 C050      		subi r28,lo8(-(klastry))
 1162 0246 D040      		sbci r29,hi8(-(klastry))
 1163 0248 8881      		ld r24,Y
 176:../../Lib/ramdysk.c ****   while (tempKlaster2 != tempKlaster);
 1165               	.LM65:
 1166 024a 4817      		cp r20,r24
 1167 024c 01F0      		breq .L49
 174:../../Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 1169               	.LM66:
 1170 024e 482F      		mov r20,r24
 1171 0250 00C0      		rjmp .L50
 1172               	.L49:
 178:../../Lib/ramdysk.c ****   klastry[tempKlaster] = znajdzWolnyKlaster();
 1174               	.LM67:
 1175 0252 0E94 0000 		call znajdzWolnyKlaster
 1176 0256 8883      		st Y,r24
 180:../../Lib/ramdysk.c ****   if (klastry[tempKlaster] != 0)
 1178               	.LM68:
 1179 0258 8111      		cpse r24,__zero_reg__
 1180 025a 00C0      		rjmp .L51
 1181               	.L52:
 1182               	.LBE13:
 1183               	.LBE12:
 211:../../Lib/ramdysk.c ****   {
 212:../../Lib/ramdysk.c ****     return 0;
 213:../../Lib/ramdysk.c ****   }
 214:../../Lib/ramdysk.c ****   
 215:../../Lib/ramdysk.c ****   if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym p
 216:../../Lib/ramdysk.c ****   {
 217:../../Lib/ramdysk.c ****     memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo
 218:../../Lib/ramdysk.c ****     strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
 219:../../Lib/ramdysk.c ****     plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
 220:../../Lib/ramdysk.c ****     return 0;                            
 221:../../Lib/ramdysk.c ****   }
 222:../../Lib/ramdysk.c ****   return 1;
 1185               	.LM69:
 1186 025c 81E0      		ldi r24,lo8(1)
 1187 025e 00C0      		rjmp .L45
 1188               	.L51:
 1189               	.LBB15:
 1190               	.LBB14:
 181:../../Lib/ramdysk.c ****     plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
 1192               	.LM70:
 1193 0260 90E0      		ldi r25,0
 1194 0262 C92F      		mov r28,r25
 1195 0264 D0E8      		ldi r29,lo8(-128)
 1196 0266 D80F      		add r29,r24
 1197               	.L46:
 1198               	.LBE14:
 1199               	.LBE15:
 215:../../Lib/ramdysk.c ****   if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym p
 1201               	.LM71:
 1202 0268 2097      		sbiw r28,0
 1203 026a 01F0      		breq .L52
 217:../../Lib/ramdysk.c ****     memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo
 1205               	.LM72:
 1206 026c 8CE0      		ldi r24,lo8(12)
 1207 026e FE01      		movw r30,r28
 1208               		0:
 1209 0270 1192      		st Z+,__zero_reg__
 1210 0272 8A95      		dec r24
 1211 0274 01F4      		brne 0b
 218:../../Lib/ramdysk.c ****     strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
 1213               	.LM73:
 1214 0276 4F2D      		mov r20,r15
 1215 0278 50E0      		ldi r21,0
 1216 027a B801      		movw r22,r16
 1217 027c CE01      		movw r24,r28
 1218 027e 0496      		adiw r24,4
 1219 0280 0E94 0000 		call strncpy
 219:../../Lib/ramdysk.c ****     plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
 1221               	.LM74:
 1222 0284 1C86      		std Y+12,__zero_reg__
 1223 0286 1D86      		std Y+13,__zero_reg__
 1224 0288 1E86      		std Y+14,__zero_reg__
 1225 028a 1F86      		std Y+15,__zero_reg__
 1226               	.L55:
 207:../../Lib/ramdysk.c ****     return 0;
 1228               	.LM75:
 1229 028c 80E0      		ldi r24,0
 1230               	.L45:
 1231               	/* epilogue start */
 223:../../Lib/ramdysk.c **** }
 1233               	.LM76:
 1234 028e DF91      		pop r29
 1235 0290 CF91      		pop r28
 1236 0292 1F91      		pop r17
 1237 0294 0F91      		pop r16
 1238 0296 FF90      		pop r15
 1239 0298 0895      		ret
 1241               	.Lscope7:
 1243               		.stabd	78,0,0
 1247               	.global	ramDyskOtworzPlik
 1249               	ramDyskOtworzPlik:
 1250               		.stabd	46,0,0
 224:../../Lib/ramdysk.c **** 
 225:../../Lib/ramdysk.c **** uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
 226:../../Lib/ramdysk.c **** {
 1252               	.LM77:
 1253               	.LFBB8:
 1254 029a CF93      		push r28
 1255 029c DF93      		push r29
 1256               	/* prologue: function */
 1257               	/* frame size = 0 */
 1258               	/* stack size = 2 */
 1259               	.L__stack_usage = 2
 1260 029e EB01      		movw r28,r22
 227:../../Lib/ramdysk.c ****   uint8_t wynik = 1;
 228:../../Lib/ramdysk.c ****   struct ramPlik *plik;
 229:../../Lib/ramdysk.c ****   if ((plik = znajdzPlik(nazwa)) != NULL)
 1262               	.LM78:
 1263 02a0 0E94 0000 		call znajdzPlik
 1264 02a4 0097      		sbiw r24,0
 1265 02a6 01F0      		breq .L62
 230:../../Lib/ramdysk.c ****   {
 231:../../Lib/ramdysk.c ****     memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
 1267               	.LM79:
 1268 02a8 1882      		st Y,__zero_reg__
 1269 02aa 1982      		std Y+1,__zero_reg__
 1270 02ac 1A82      		std Y+2,__zero_reg__
 232:../../Lib/ramdysk.c ****     fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika n
 1272               	.LM80:
 1273 02ae 8C83      		std Y+4,r24
 1274 02b0 9D83      		std Y+5,r25
 233:../../Lib/ramdysk.c ****     plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
 1276               	.LM81:
 1277 02b2 FC01      		movw r30,r24
 1278 02b4 2381      		ldd r18,Z+3
 1279 02b6 2F5F      		subi r18,lo8(-(1))
 1280 02b8 2383      		std Z+3,r18
 234:../../Lib/ramdysk.c ****     wynik = 0;
 1282               	.LM82:
 1283 02ba 80E0      		ldi r24,0
 1284 02bc 00C0      		rjmp .L61
 1285               	.L62:
 227:../../Lib/ramdysk.c ****   uint8_t wynik = 1;
 1287               	.LM83:
 1288 02be 81E0      		ldi r24,lo8(1)
 1289               	.L61:
 1290               	/* epilogue start */
 235:../../Lib/ramdysk.c ****   }
 236:../../Lib/ramdysk.c ****   return wynik;
 237:../../Lib/ramdysk.c **** }
 1292               	.LM84:
 1293 02c0 DF91      		pop r29
 1294 02c2 CF91      		pop r28
 1295 02c4 0895      		ret
 1301               	.Lscope8:
 1303               		.stabd	78,0,0
 1306               	.global	ramDyskUsunPlik
 1308               	ramDyskUsunPlik:
 1309               		.stabd	46,0,0
 238:../../Lib/ramdysk.c **** 
 239:../../Lib/ramdysk.c **** uint8_t ramDyskUsunPlik(const char *nazwa)
 240:../../Lib/ramdysk.c **** {
 1311               	.LM85:
 1312               	.LFBB9:
 1313               	/* prologue: function */
 1314               	/* frame size = 0 */
 1315               	/* stack size = 0 */
 1316               	.L__stack_usage = 0
 241:../../Lib/ramdysk.c ****   struct ramPlik *plik;
 242:../../Lib/ramdysk.c ****   if ((plik = znajdzPlik(nazwa)) == NULL)
 1318               	.LM86:
 1319 02c6 0E94 0000 		call znajdzPlik
 1320 02ca FC01      		movw r30,r24
 1321 02cc 0097      		sbiw r24,0
 1322 02ce 01F0      		breq .L69
 243:../../Lib/ramdysk.c ****     return 1;                                              //Nie znaleziono pliku
 244:../../Lib/ramdysk.c ****   if (plik->lAktOtw != 0)
 1324               	.LM87:
 1325 02d0 8381      		ldd r24,Z+3
 1326 02d2 8111      		cpse r24,__zero_reg__
 1327 02d4 00C0      		rjmp .L70
 1328               	.L65:
 245:../../Lib/ramdysk.c ****     return 2;                                              //Plik jest otwarty
 246:../../Lib/ramdysk.c ****   
 247:../../Lib/ramdysk.c ****   uint8_t usuwanyKlaster;
 248:../../Lib/ramdysk.c ****   while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się oka
 1330               	.LM88:
 1331 02d6 8081      		ld r24,Z
 1332 02d8 8823      		tst r24
 1333 02da 01F0      		breq .L71
 249:../../Lib/ramdysk.c ****   {
 250:../../Lib/ramdysk.c ****     usuwanyKlaster = plik->pierwszyKlaster;
 251:../../Lib/ramdysk.c ****     if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatnieg
 1335               	.LM89:
 1336 02dc A82F      		mov r26,r24
 1337 02de B0E0      		ldi r27,0
 1338 02e0 A050      		subi r26,lo8(-(klastry))
 1339 02e2 B040      		sbci r27,hi8(-(klastry))
 1340 02e4 9C91      		ld r25,X
 1341 02e6 9813      		cpse r25,r24
 1342 02e8 00C0      		rjmp .L66
 252:../../Lib/ramdysk.c ****       plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pl
 1344               	.LM90:
 1345 02ea 1082      		st Z,__zero_reg__
 1346 02ec 00C0      		rjmp .L67
 1347               	.L66:
 253:../../Lib/ramdysk.c ****     else
 254:../../Lib/ramdysk.c ****       plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
 1349               	.LM91:
 1350 02ee 9083      		st Z,r25
 1351               	.L67:
 255:../../Lib/ramdysk.c ****     klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
 1353               	.LM92:
 1354 02f0 1C92      		st X,__zero_reg__
 1355 02f2 00C0      		rjmp .L65
 1356               	.L71:
 256:../../Lib/ramdysk.c ****   }
 257:../../Lib/ramdysk.c ****   
 258:../../Lib/ramdysk.c ****   memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. I
 1358               	.LM93:
 1359 02f4 80E1      		ldi r24,lo8(16)
 1360 02f6 DF01      		movw r26,r30
 1361               		0:
 1362 02f8 1D92      		st X+,__zero_reg__
 1363 02fa 8A95      		dec r24
 1364 02fc 01F4      		brne 0b
 259:../../Lib/ramdysk.c **** //relokacjaTablicyWpisow()
 260:../../Lib/ramdysk.c ****   return 0;
 1366               	.LM94:
 1367 02fe 80E0      		ldi r24,0
 1368 0300 0895      		ret
 1369               	.L69:
 243:../../Lib/ramdysk.c ****     return 1;                                              //Nie znaleziono pliku
 1371               	.LM95:
 1372 0302 81E0      		ldi r24,lo8(1)
 1373 0304 0895      		ret
 1374               	.L70:
 245:../../Lib/ramdysk.c ****     return 2;                                              //Plik jest otwarty
 1376               	.LM96:
 1377 0306 82E0      		ldi r24,lo8(2)
 261:../../Lib/ramdysk.c **** }
 1379               	.LM97:
 1380 0308 0895      		ret
 1385               	.Lscope9:
 1387               		.stabd	78,0,0
 1390               	.global	ramDyskZamknijPlik
 1392               	ramDyskZamknijPlik:
 1393               		.stabd	46,0,0
 262:../../Lib/ramdysk.c **** 
 263:../../Lib/ramdysk.c **** void ramDyskZamknijPlik(struct ramPlikFd *fd)
 264:../../Lib/ramdysk.c **** {
 1395               	.LM98:
 1396               	.LFBB10:
 1397               	/* prologue: function */
 1398               	/* frame size = 0 */
 1399               	/* stack size = 0 */
 1400               	.L__stack_usage = 0
 265:../../Lib/ramdysk.c ****   if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest 
 1402               	.LM99:
 1403 030a DC01      		movw r26,r24
 1404 030c 1496      		adiw r26,4
 1405 030e ED91      		ld r30,X+
 1406 0310 FC91      		ld r31,X
 1407 0312 1597      		sbiw r26,4+1
 1408 0314 2381      		ldd r18,Z+3
 1409 0316 2223      		tst r18
 1410 0318 01F0      		breq .L72
 266:../../Lib/ramdysk.c ****   {
 267:../../Lib/ramdysk.c ****     fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
 1412               	.LM100:
 1413 031a 2150      		subi r18,lo8(-(-1))
 1414 031c 2383      		std Z+3,r18
 268:../../Lib/ramdysk.c ****     memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plik
 1416               	.LM101:
 1417 031e 26E0      		ldi r18,lo8(6)
 1418 0320 FC01      		movw r30,r24
 1419               		0:
 1420 0322 1192      		st Z+,__zero_reg__
 1421 0324 2A95      		dec r18
 1422 0326 01F4      		brne 0b
 1423               	.L72:
 1424 0328 0895      		ret
 1426               	.Lscope10:
 1428               		.stabd	78,0,0
 1431               	.global	ramDyskCzyscPlik
 1433               	ramDyskCzyscPlik:
 1434               		.stabd	46,0,0
 269:../../Lib/ramdysk.c ****   }
 270:../../Lib/ramdysk.c **** }
 271:../../Lib/ramdysk.c **** 
 272:../../Lib/ramdysk.c **** uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
 273:../../Lib/ramdysk.c **** {
 1436               	.LM102:
 1437               	.LFBB11:
 1438 032a CF93      		push r28
 1439 032c DF93      		push r29
 1440               	/* prologue: function */
 1441               	/* frame size = 0 */
 1442               	/* stack size = 2 */
 1443               	.L__stack_usage = 2
 1444 032e FC01      		movw r30,r24
 1445               	.L78:
 274:../../Lib/ramdysk.c ****   uint8_t usuwanyKlaster;
 275:../../Lib/ramdysk.c ****   while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się
 1447               	.LM103:
 1448 0330 A481      		ldd r26,Z+4
 1449 0332 B581      		ldd r27,Z+5
 1450 0334 8C91      		ld r24,X
 1451 0336 8823      		tst r24
 1452 0338 01F0      		breq .L82
 276:../../Lib/ramdysk.c ****   {
 277:../../Lib/ramdysk.c ****     usuwanyKlaster = fd->wpis->pierwszyKlaster;
 278:../../Lib/ramdysk.c ****     if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostat
 1454               	.LM104:
 1455 033a C82F      		mov r28,r24
 1456 033c D0E0      		ldi r29,0
 1457 033e C050      		subi r28,lo8(-(klastry))
 1458 0340 D040      		sbci r29,hi8(-(klastry))
 1459 0342 9881      		ld r25,Y
 1460 0344 9813      		cpse r25,r24
 1461 0346 00C0      		rjmp .L79
 279:../../Lib/ramdysk.c ****       fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwani
 1463               	.LM105:
 1464 0348 1C92      		st X,__zero_reg__
 1465 034a 00C0      		rjmp .L80
 1466               	.L79:
 280:../../Lib/ramdysk.c ****     else
 281:../../Lib/ramdysk.c ****       fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
 1468               	.LM106:
 1469 034c 9C93      		st X,r25
 1470               	.L80:
 282:../../Lib/ramdysk.c ****     klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
 1472               	.LM107:
 1473 034e 1882      		st Y,__zero_reg__
 1474 0350 00C0      		rjmp .L78
 1475               	.L82:
 283:../../Lib/ramdysk.c ****   }
 284:../../Lib/ramdysk.c ****   fd->wpis->rozmiarLo       = 0;
 1477               	.LM108:
 1478 0352 1196      		adiw r26,1
 1479 0354 1C92      		st X,__zero_reg__
 285:../../Lib/ramdysk.c ****   fd->wpis->rozmiarHi       = 0;
 1481               	.LM109:
 1482 0356 A481      		ldd r26,Z+4
 1483 0358 B581      		ldd r27,Z+5
 1484 035a 1296      		adiw r26,2
 1485 035c 1C92      		st X,__zero_reg__
 286:../../Lib/ramdysk.c ****   fd->wpis->dataMod         = systemTime();
 1487               	.LM110:
 1488 035e A481      		ldd r26,Z+4
 1489 0360 B581      		ldd r27,Z+5
 1490 0362 1C96      		adiw r26,12
 1491 0364 1D92      		st X+,__zero_reg__
 1492 0366 1D92      		st X+,__zero_reg__
 1493 0368 1D92      		st X+,__zero_reg__
 1494 036a 1C92      		st X,__zero_reg__
 1495 036c 1F97      		sbiw r26,12+3
 287:../../Lib/ramdysk.c ****   memset (fd, 0, 4);
 1497               	.LM111:
 1498 036e 1082      		st Z,__zero_reg__
 1499 0370 1182      		std Z+1,__zero_reg__
 1500 0372 1282      		std Z+2,__zero_reg__
 1501 0374 1382      		std Z+3,__zero_reg__
 1502               	/* epilogue start */
 288:../../Lib/ramdysk.c ****   return 0;
 289:../../Lib/ramdysk.c **** }
 1504               	.LM112:
 1505 0376 DF91      		pop r29
 1506 0378 CF91      		pop r28
 1507 037a 0895      		ret
 1509               	.Lscope11:
 1511               		.stabd	78,0,0
 1515               	.global	ramDyskZapiszBajtDoPliku
 1517               	ramDyskZapiszBajtDoPliku:
 1518               		.stabd	46,0,0
 290:../../Lib/ramdysk.c **** 
 291:../../Lib/ramdysk.c **** uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
 292:../../Lib/ramdysk.c **** {
 1520               	.LM113:
 1521               	.LFBB12:
 1522 037c 1F93      		push r17
 1523 037e CF93      		push r28
 1524 0380 DF93      		push r29
 1525               	/* prologue: function */
 1526               	/* frame size = 0 */
 1527               	/* stack size = 3 */
 1528               	.L__stack_usage = 3
 1529 0382 EC01      		movw r28,r24
 1530 0384 162F      		mov r17,r22
 293:../../Lib/ramdysk.c ****   uint8_t tmpKlaster;
 294:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 1532               	.LM114:
 1533 0386 EC81      		ldd r30,Y+4
 1534 0388 FD81      		ldd r31,Y+5
 1535 038a 8081      		ld r24,Z
 1536 038c 8111      		cpse r24,__zero_reg__
 1537 038e 00C0      		rjmp .L84
 295:../../Lib/ramdysk.c ****   {
 296:../../Lib/ramdysk.c ****     if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
 1539               	.LM115:
 1540 0390 0E94 0000 		call znajdzWolnyKlaster
 1541 0394 8823      		tst r24
 1542 0396 01F0      		breq .L89
 297:../../Lib/ramdysk.c ****       return 1;                                         //Nie można było przydzielić pierwszego 
 298:../../Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = tmpKlaster;
 1544               	.LM116:
 1545 0398 EC81      		ldd r30,Y+4
 1546 039a FD81      		ldd r31,Y+5
 1547 039c 8083      		st Z,r24
 1548               	.L84:
 299:../../Lib/ramdysk.c ****   }
 300:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)
 1550               	.LM117:
 1551 039e 8A81      		ldd r24,Y+2
 1552 03a0 8111      		cpse r24,__zero_reg__
 1553 03a2 00C0      		rjmp .L86
 301:../../Lib/ramdysk.c ****   {
 302:../../Lib/ramdysk.c ****     tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie nas
 1555               	.LM118:
 1556 03a4 EC81      		ldd r30,Y+4
 1557 03a6 FD81      		ldd r31,Y+5
 1558 03a8 6B81      		ldd r22,Y+3
 1559 03aa 8081      		ld r24,Z
 1560 03ac 0E94 0000 		call znajdzKlasterN
 303:../../Lib/ramdysk.c ****     if (tmpKlaster == 0)
 1562               	.LM119:
 1563 03b0 8823      		tst r24
 1564 03b2 01F0      		breq .L90
 304:../../Lib/ramdysk.c ****     {
 305:../../Lib/ramdysk.c ****       return 2;                                       //Nie można było przydzielić kolejnego kla
 306:../../Lib/ramdysk.c ****     }
 307:../../Lib/ramdysk.c ****     fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego k
 1566               	.LM120:
 1567 03b4 90E0      		ldi r25,0
 1568 03b6 8058      		subi r24,-128
 1569 03b8 9F4F      		sbci r25,-1
 1570 03ba 1882      		st Y,__zero_reg__
 1571 03bc 8983      		std Y+1,r24
 1572               	.L86:
 308:../../Lib/ramdysk.c ****   }
 309:../../Lib/ramdysk.c ****   
 310:../../Lib/ramdysk.c ****   *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
 1574               	.LM121:
 1575 03be E881      		ld r30,Y
 1576 03c0 F981      		ldd r31,Y+1
 1577 03c2 1083      		st Z,r17
 311:../../Lib/ramdysk.c **** 
 312:../../Lib/ramdysk.c ****   fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
 1579               	.LM122:
 1580 03c4 8A81      		ldd r24,Y+2
 1581 03c6 8F5F      		subi r24,lo8(-(1))
 1582 03c8 8A83      		std Y+2,r24
 313:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, ż
 1584               	.LM123:
 1585 03ca 8111      		cpse r24,__zero_reg__
 1586 03cc 00C0      		rjmp .L87
 314:../../Lib/ramdysk.c ****     fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt
 1588               	.LM124:
 1589 03ce 8B81      		ldd r24,Y+3
 1590 03d0 8F5F      		subi r24,lo8(-(1))
 1591 03d2 8B83      		std Y+3,r24
 1592 03d4 00C0      		rjmp .L88
 1593               	.L87:
 315:../../Lib/ramdysk.c ****   else                                                //Wziąż działamy na tym samym klastrze.
 316:../../Lib/ramdysk.c ****     fd->Wsk++;                                        //Można uaktualnić wskaźnik
 1595               	.LM125:
 1596 03d6 8881      		ld r24,Y
 1597 03d8 9981      		ldd r25,Y+1
 1598 03da 0196      		adiw r24,1
 1599 03dc 8883      		st Y,r24
 1600 03de 9983      		std Y+1,r25
 1601               	.L88:
 317:../../Lib/ramdysk.c ****     
 318:../../Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
 1603               	.LM126:
 1604 03e0 CE01      		movw r24,r28
 1605 03e2 0E94 0000 		call uaktualnijRozmiarPliku
 319:../../Lib/ramdysk.c ****   return 0;
 1607               	.LM127:
 1608 03e6 80E0      		ldi r24,0
 1609 03e8 00C0      		rjmp .L85
 1610               	.L89:
 297:../../Lib/ramdysk.c ****       return 1;                                         //Nie można było przydzielić pierwszego 
 1612               	.LM128:
 1613 03ea 81E0      		ldi r24,lo8(1)
 1614 03ec 00C0      		rjmp .L85
 1615               	.L90:
 305:../../Lib/ramdysk.c ****       return 2;                                       //Nie można było przydzielić kolejnego kla
 1617               	.LM129:
 1618 03ee 82E0      		ldi r24,lo8(2)
 1619               	.L85:
 1620               	/* epilogue start */
 320:../../Lib/ramdysk.c **** }
 1622               	.LM130:
 1623 03f0 DF91      		pop r29
 1624 03f2 CF91      		pop r28
 1625 03f4 1F91      		pop r17
 1626 03f6 0895      		ret
 1628               	.Lscope12:
 1630               		.stabd	78,0,0
 1635               	putSTD:
 1636               		.stabd	46,0,0
 321:../../Lib/ramdysk.c **** 
 322:../../Lib/ramdysk.c **** uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
 323:../../Lib/ramdysk.c **** {
 324:../../Lib/ramdysk.c ****   if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
 325:../../Lib/ramdysk.c ****     return 1;                                         //1 - eof
 326:../../Lib/ramdysk.c **** 
 327:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku now
 328:../../Lib/ramdysk.c ****   {
 329:../../Lib/ramdysk.c ****     uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
 330:../../Lib/ramdysk.c ****     fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego k
 331:../../Lib/ramdysk.c ****   }
 332:../../Lib/ramdysk.c ****   
 333:../../Lib/ramdysk.c ****   *bajt = *(fd->Wsk);                                 //Odczyt z pliku
 334:../../Lib/ramdysk.c ****   fd->IndLo++;                                        //Zwiększenie indeksu o 1
 335:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klas
 336:../../Lib/ramdysk.c ****     fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół wzgl
 337:../../Lib/ramdysk.c ****   else                                                //Działamy na tym samym klastrze
 338:../../Lib/ramdysk.c ****     fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
 339:../../Lib/ramdysk.c ****   return 0;
 340:../../Lib/ramdysk.c **** }
 341:../../Lib/ramdysk.c **** 
 342:../../Lib/ramdysk.c **** uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
 343:../../Lib/ramdysk.c **** {
 344:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 345:../../Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 346:../../Lib/ramdysk.c ****   
 347:../../Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisa
 348:../../Lib/ramdysk.c ****   uint16_t doZapisu = *dlugosc;
 349:../../Lib/ramdysk.c ****   *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
 350:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 351:../../Lib/ramdysk.c ****   while (doZapisu > 0)
 352:../../Lib/ramdysk.c ****   {
 353:../../Lib/ramdysk.c ****     if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to
 354:../../Lib/ramdysk.c ****     {
 355:../../Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze
 356:../../Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra 
 357:../../Lib/ramdysk.c ****       else                                        //Znamy poprzedni klaster
 358:../../Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
 359:../../Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
 360:../../Lib/ramdysk.c ****         return 1;                                 //1 - Brak wolnego klastra
 361:../../Lib/ramdysk.c **** 
 362:../../Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Ter
 363:../../Lib/ramdysk.c ****     }
 364:../../Lib/ramdysk.c ****     if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w b
 365:../../Lib/ramdysk.c ****     {                                             //Nie uda się, teraz zapiszemy cały klastr do k
 366:../../Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
 367:../../Lib/ramdysk.c ****       znaki +=dlBloku;                      
 368:../../Lib/ramdysk.c ****       fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na począ
 369:../../Lib/ramdysk.c ****       doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka
 370:../../Lib/ramdysk.c ****       *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych d
 371:../../Lib/ramdysk.c ****       fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. 
 372:../../Lib/ramdysk.c ****       dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 
 373:../../Lib/ramdysk.c ****     }
 374:../../Lib/ramdysk.c ****     else                                          //Jest to ostatni zapis. Całe dane zostaną skop
 375:../../Lib/ramdysk.c ****     {
 376:../../Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
 377:../../Lib/ramdysk.c ****       fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mn
 378:../../Lib/ramdysk.c ****       *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych d
 379:../../Lib/ramdysk.c ****       doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
 380:../../Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce kla
 381:../../Lib/ramdysk.c ****     }
 382:../../Lib/ramdysk.c ****   }
 383:../../Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
 384:../../Lib/ramdysk.c ****   return 0;
 385:../../Lib/ramdysk.c **** }
 386:../../Lib/ramdysk.c **** 
 387:../../Lib/ramdysk.c **** uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
 388:../../Lib/ramdysk.c **** {
 389:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 390:../../Lib/ramdysk.c ****   {
 391:../../Lib/ramdysk.c ****     *dlugosc = 0;
 392:../../Lib/ramdysk.c ****     return 1;                         //1 - Plik jest pusty
 393:../../Lib/ramdysk.c ****   }
 394:../../Lib/ramdysk.c ****   if (wObrebiePliku(fd) != 0)
 395:../../Lib/ramdysk.c ****   {
 396:../../Lib/ramdysk.c ****     *dlugosc = 0;
 397:../../Lib/ramdysk.c ****     return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pli
 398:../../Lib/ramdysk.c ****   }
 399:../../Lib/ramdysk.c ****   
 400:../../Lib/ramdysk.c ****   uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
 401:../../Lib/ramdysk.c ****   lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze z
 402:../../Lib/ramdysk.c ****   lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zaws
 403:../../Lib/ramdysk.c ****   
 404:../../Lib/ramdysk.c ****   uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i
 405:../../Lib/ramdysk.c ****     lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczyta
 406:../../Lib/ramdysk.c ****     *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
 407:../../Lib/ramdysk.c ****   *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
 408:../../Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktua
 409:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 410:../../Lib/ramdysk.c ****   while (doOdczytania > 0)
 411:../../Lib/ramdysk.c ****   {
 412:../../Lib/ramdysk.c ****     if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, 
 413:../../Lib/ramdysk.c ****     {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (
 414:../../Lib/ramdysk.c ****       if (tmpKlaster == 0)
 415:../../Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
 416:../../Lib/ramdysk.c ****       else
 417:../../Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster);
 418:../../Lib/ramdysk.c ****       if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
 419:../../Lib/ramdysk.c ****         fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
 420:../../Lib/ramdysk.c ****       else
 421:../../Lib/ramdysk.c ****         return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
 422:../../Lib/ramdysk.c ****     }
 423:../../Lib/ramdysk.c ****     
 424:../../Lib/ramdysk.c ****     if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
 425:../../Lib/ramdysk.c ****     {                                  //dlBloku określa ile zostało jeszcze bajtów do końca kl
 426:../../Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
 427:../../Lib/ramdysk.c ****       znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy 
 428:../../Lib/ramdysk.c ****       fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
 429:../../Lib/ramdysk.c ****       fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz ni
 430:../../Lib/ramdysk.c ****       doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
 431:../../Lib/ramdysk.c ****       *dlugosc += dlBloku;             //Uaktualnienie 
 432:../../Lib/ramdysk.c ****       dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całeg
 433:../../Lib/ramdysk.c ****     }
 434:../../Lib/ramdysk.c ****     else                               //Ostatnia operacja odczytu
 435:../../Lib/ramdysk.c ****     {
 436:../../Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, doOdczytania);
 437:../../Lib/ramdysk.c ****       fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym sam
 438:../../Lib/ramdysk.c ****       fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zat
 439:../../Lib/ramdysk.c ****       *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                  
 440:../../Lib/ramdysk.c ****       doOdczytania = 0;                //Tutaj równie dobrze może być brake
 441:../../Lib/ramdysk.c ****     }
 442:../../Lib/ramdysk.c ****   }
 443:../../Lib/ramdysk.c ****   return 0;
 444:../../Lib/ramdysk.c **** }
 445:../../Lib/ramdysk.c **** 
 446:../../Lib/ramdysk.c **** uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
 447:../../Lib/ramdysk.c **** {
 448:../../Lib/ramdysk.c ****   if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje
 449:../../Lib/ramdysk.c ****   {                                                       //Jeśli tak, to nie ma potzeby tworzenia
 450:../../Lib/ramdysk.c ****     fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bard
 451:../../Lib/ramdysk.c ****     fd->IndHi = 0;
 452:../../Lib/ramdysk.c ****     return 0;
 453:../../Lib/ramdysk.c ****   }
 454:../../Lib/ramdysk.c ****   indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio 
 455:../../Lib/ramdysk.c ****                                                           //Jeśli indeks jest większy niż rozmia
 456:../../Lib/ramdysk.c ****   
 457:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydziel
 458:../../Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pl
 459:../../Lib/ramdysk.c **** 
 460:../../Lib/ramdysk.c ****   uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką nale
 461:../../Lib/ramdysk.c **** 
 462:../../Lib/ramdysk.c ****   fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mn
 463:../../Lib/ramdysk.c ****   fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu
 464:../../Lib/ramdysk.c ****   
 465:../../Lib/ramdysk.c ****   uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
 466:../../Lib/ramdysk.c ****   if (nrKlastra == 0)
 467:../../Lib/ramdysk.c ****     return 1;                                             //Brak klastrów
 468:../../Lib/ramdysk.c **** 
 469:../../Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
 470:../../Lib/ramdysk.c **** 
 471:../../Lib/ramdysk.c ****   fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
 472:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, 
 473:../../Lib/ramdysk.c ****     fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący b
 474:../../Lib/ramdysk.c ****   else                                                    //Jesteśmy w obszarze utworzonego klastr
 475:../../Lib/ramdysk.c ****     fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejs
 476:../../Lib/ramdysk.c **** 
 477:../../Lib/ramdysk.c ****   return 0; 
 478:../../Lib/ramdysk.c **** }
 479:../../Lib/ramdysk.c **** 
 480:../../Lib/ramdysk.c **** uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
 481:../../Lib/ramdysk.c **** {
 482:../../Lib/ramdysk.c ****   if (fd == NULL)
 483:../../Lib/ramdysk.c ****     return 1;
 484:../../Lib/ramdysk.c ****   fd->IndLo = fd->wpis->rozmiarLo;
 485:../../Lib/ramdysk.c ****   fd->IndHi = fd->wpis->rozmiarHi;
 486:../../Lib/ramdysk.c **** //  fd->IndLo++;
 487:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 488:../../Lib/ramdysk.c ****   if (fd->IndLo != 0)
 489:../../Lib/ramdysk.c ****   {
 490:../../Lib/ramdysk.c ****     tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
 491:../../Lib/ramdysk.c ****     fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
 492:../../Lib/ramdysk.c ****   }  
 493:../../Lib/ramdysk.c ****   return 0;
 494:../../Lib/ramdysk.c **** }
 495:../../Lib/ramdysk.c **** 
 496:../../Lib/ramdysk.c **** uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
 497:../../Lib/ramdysk.c **** {
 498:../../Lib/ramdysk.c ****   if (nrBloku == 0)
 499:../../Lib/ramdysk.c ****     return NULL;
 500:../../Lib/ramdysk.c ****   nrBloku --;
 501:../../Lib/ramdysk.c ****   
 502:../../Lib/ramdysk.c ****   uint8_t indHi = (uint8_t)(nrBloku / 2);
 503:../../Lib/ramdysk.c ****   uint8_t indLo = 0;
 504:../../Lib/ramdysk.c ****   uint8_t *wynik;
 505:../../Lib/ramdysk.c ****   
 506:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 507:../../Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 508:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 509:../../Lib/ramdysk.c ****     return NULL;
 510:../../Lib/ramdysk.c ****   
 511:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
 512:../../Lib/ramdysk.c ****   if (tmpKlaster == 0)
 513:../../Lib/ramdysk.c ****     return NULL;
 514:../../Lib/ramdysk.c ****   if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
 515:../../Lib/ramdysk.c ****   {
 516:../../Lib/ramdysk.c ****     indLo = 128;
 517:../../Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi <= indHi)
 518:../../Lib/ramdysk.c ****     {
 519:../../Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi+1;
 520:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 0;
 521:../../Lib/ramdysk.c ****     }
 522:../../Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 128);
 523:../../Lib/ramdysk.c ****   }
 524:../../Lib/ramdysk.c ****   else
 525:../../Lib/ramdysk.c ****   {
 526:../../Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi < indHi)
 527:../../Lib/ramdysk.c ****     {
 528:../../Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi;
 529:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 530:../../Lib/ramdysk.c ****     }
 531:../../Lib/ramdysk.c ****     else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
 532:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 533:../../Lib/ramdysk.c ****     
 534:../../Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 0);
 535:../../Lib/ramdysk.c ****   }
 536:../../Lib/ramdysk.c ****   return wynik;
 537:../../Lib/ramdysk.c **** }
 538:../../Lib/ramdysk.c **** 
 539:../../Lib/ramdysk.c **** void ramDyskDir(FILE *ostream)
 540:../../Lib/ramdysk.c **** {
 541:../../Lib/ramdysk.c ****   fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
 542:../../Lib/ramdysk.c ****   struct ramPlik *plik;
 543:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 544:../../Lib/ramdysk.c ****   uint8_t tmpKlaster2;
 545:../../Lib/ramdysk.c ****   uint8_t tmp, tmp2, tmp3;
 546:../../Lib/ramdysk.c ****   do 
 547:../../Lib/ramdysk.c ****   {
 548:../../Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
 549:../../Lib/ramdysk.c ****     for (tmp=0; tmp<16; tmp++)
 550:../../Lib/ramdysk.c ****     {
 551:../../Lib/ramdysk.c ****       tmp3=plik->nazwa[0];
 552:../../Lib/ramdysk.c ****       if (tmp3 == 0)
 553:../../Lib/ramdysk.c ****         break;                                            //Ten wpis jest pusty.
 554:../../Lib/ramdysk.c ****       fputc(tmp3         , ostream);
 555:../../Lib/ramdysk.c ****       for (tmp2=1; tmp2<8; tmp2++)
 556:../../Lib/ramdysk.c ****       {
 557:../../Lib/ramdysk.c ****         if (tmp3 != 0)
 558:../../Lib/ramdysk.c ****           tmp3=plik->nazwa[tmp2];
 559:../../Lib/ramdysk.c **** 
 560:../../Lib/ramdysk.c ****         if (tmp3 != 0)
 561:../../Lib/ramdysk.c ****           fputc(tmp3     , ostream);
 562:../../Lib/ramdysk.c ****         else
 563:../../Lib/ramdysk.c ****           fputc(' '      , ostream);
 564:../../Lib/ramdysk.c ****       }
 565:../../Lib/ramdysk.c ****       fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
 566:../../Lib/ramdysk.c ****       plik++;
 567:../../Lib/ramdysk.c ****     }
 568:../../Lib/ramdysk.c ****     tmpKlaster2 = tmpKlaster;
 569:../../Lib/ramdysk.c ****     tmpKlaster = klastry[tmpKlaster];
 570:../../Lib/ramdysk.c ****   }
 571:../../Lib/ramdysk.c ****   while (tmpKlaster != tmpKlaster2);
 572:../../Lib/ramdysk.c **** }
 573:../../Lib/ramdysk.c **** 
 574:../../Lib/ramdysk.c **** uint8_t ramDyskLiczbaWolnychKlastrow(void)
 575:../../Lib/ramdysk.c **** {
 576:../../Lib/ramdysk.c ****   uint8_t wynik=0;
 577:../../Lib/ramdysk.c ****   uint8_t temp;
 578:../../Lib/ramdysk.c ****   for (temp = L_KLASTROW-1; temp > 0; temp--)
 579:../../Lib/ramdysk.c ****     if (klastry[temp] == 0)
 580:../../Lib/ramdysk.c ****       wynik++;
 581:../../Lib/ramdysk.c ****   return wynik;
 582:../../Lib/ramdysk.c **** }
 583:../../Lib/ramdysk.c **** 
 584:../../Lib/ramdysk.c **** 
 585:../../Lib/ramdysk.c **** static int getSTD(FILE *stream)
 586:../../Lib/ramdysk.c **** {
 587:../../Lib/ramdysk.c ****   uint8_t wynik;
 588:../../Lib/ramdysk.c ****   struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
 589:../../Lib/ramdysk.c ****   
 590:../../Lib/ramdysk.c ****   if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
 591:../../Lib/ramdysk.c ****     return wynik;
 592:../../Lib/ramdysk.c ****   return EOF;
 593:../../Lib/ramdysk.c **** }
 594:../../Lib/ramdysk.c **** 
 595:../../Lib/ramdysk.c **** static int putSTD(char c, FILE *stream)
 596:../../Lib/ramdysk.c **** {
 1638               	.LM131:
 1639               	.LFBB13:
 1640               	/* prologue: function */
 1641               	/* frame size = 0 */
 1642               	/* stack size = 0 */
 1643               	.L__stack_usage = 0
 1644 03f8 FB01      		movw r30,r22
 597:../../Lib/ramdysk.c ****   struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
 598:../../Lib/ramdysk.c ****   return ramDyskZapiszBajtDoPliku(fd, c);  
 1646               	.LM132:
 1647 03fa 682F      		mov r22,r24
 1648 03fc 8485      		ldd r24,Z+12
 1649 03fe 9585      		ldd r25,Z+13
 1650 0400 0E94 0000 		call ramDyskZapiszBajtDoPliku
 599:../../Lib/ramdysk.c **** }
 1652               	.LM133:
 1653 0404 90E0      		ldi r25,0
 1654 0406 0895      		ret
 1656               	.Lscope13:
 1658               		.stabd	78,0,0
 1662               	.global	ramDyskCzytajBajtZPliku
 1664               	ramDyskCzytajBajtZPliku:
 1665               		.stabd	46,0,0
 323:../../Lib/ramdysk.c **** {
 1667               	.LM134:
 1668               	.LFBB14:
 1669 0408 0F93      		push r16
 1670 040a 1F93      		push r17
 1671 040c CF93      		push r28
 1672 040e DF93      		push r29
 1673               	/* prologue: function */
 1674               	/* frame size = 0 */
 1675               	/* stack size = 4 */
 1676               	.L__stack_usage = 4
 1677 0410 EC01      		movw r28,r24
 1678 0412 8B01      		movw r16,r22
 1679               	.LBB19:
 1680               	.LBB20:
  26:../../Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi > fd->IndHi)
 1682               	.LM135:
 1683 0414 EC81      		ldd r30,Y+4
 1684 0416 FD81      		ldd r31,Y+5
 1685 0418 8281      		ldd r24,Z+2
 1686 041a 6B81      		ldd r22,Y+3
 1687 041c 6817      		cp r22,r24
 1688 041e 00F0      		brlo .L93
  29:../../Lib/ramdysk.c ****   if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
 1690               	.LM136:
 1691 0420 8613      		cpse r24,r22
 1692 0422 00C0      		rjmp .L98
 1693 0424 9181      		ldd r25,Z+1
 1694 0426 8A81      		ldd r24,Y+2
 1695 0428 9817      		cp r25,r24
 1696 042a 00F4      		brsh .L93
 1697               	.L98:
 1698               	.LBE20:
 1699               	.LBE19:
 325:../../Lib/ramdysk.c ****     return 1;                                         //1 - eof
 1701               	.LM137:
 1702 042c 81E0      		ldi r24,lo8(1)
 1703 042e 00C0      		rjmp .L99
 1704               	.L93:
 327:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku now
 1706               	.LM138:
 1707 0430 8A81      		ldd r24,Y+2
 1708 0432 8111      		cpse r24,__zero_reg__
 1709 0434 00C0      		rjmp .L97
 1710               	.LBB21:
 329:../../Lib/ramdysk.c ****     uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
 1712               	.LM139:
 1713 0436 8081      		ld r24,Z
 1714 0438 0E94 0000 		call znajdzKlasterN
 330:../../Lib/ramdysk.c ****     fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego k
 1716               	.LM140:
 1717 043c 90E0      		ldi r25,0
 1718 043e 8058      		subi r24,-128
 1719 0440 9F4F      		sbci r25,-1
 1720 0442 1882      		st Y,__zero_reg__
 1721 0444 8983      		std Y+1,r24
 1722               	.L97:
 1723               	.LBE21:
 333:../../Lib/ramdysk.c ****   *bajt = *(fd->Wsk);                                 //Odczyt z pliku
 1725               	.LM141:
 1726 0446 E881      		ld r30,Y
 1727 0448 F981      		ldd r31,Y+1
 1728 044a 8081      		ld r24,Z
 1729 044c F801      		movw r30,r16
 1730 044e 8083      		st Z,r24
 334:../../Lib/ramdysk.c ****   fd->IndLo++;                                        //Zwiększenie indeksu o 1
 1732               	.LM142:
 1733 0450 8A81      		ldd r24,Y+2
 1734 0452 8F5F      		subi r24,lo8(-(1))
 1735 0454 8A83      		std Y+2,r24
 335:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klas
 1737               	.LM143:
 1738 0456 8111      		cpse r24,__zero_reg__
 1739 0458 00C0      		rjmp .L95
 336:../../Lib/ramdysk.c ****     fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół wzgl
 1741               	.LM144:
 1742 045a 8B81      		ldd r24,Y+3
 1743 045c 8F5F      		subi r24,lo8(-(1))
 1744 045e 8B83      		std Y+3,r24
 1745 0460 00C0      		rjmp .L100
 1746               	.L95:
 338:../../Lib/ramdysk.c ****     fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
 1748               	.LM145:
 1749 0462 8881      		ld r24,Y
 1750 0464 9981      		ldd r25,Y+1
 1751 0466 0196      		adiw r24,1
 1752 0468 8883      		st Y,r24
 1753 046a 9983      		std Y+1,r25
 1754               	.L100:
 339:../../Lib/ramdysk.c ****   return 0;
 1756               	.LM146:
 1757 046c 80E0      		ldi r24,0
 1758               	.L99:
 1759               	/* epilogue start */
 340:../../Lib/ramdysk.c **** }
 1761               	.LM147:
 1762 046e DF91      		pop r29
 1763 0470 CF91      		pop r28
 1764 0472 1F91      		pop r17
 1765 0474 0F91      		pop r16
 1766 0476 0895      		ret
 1771               	.Lscope14:
 1773               		.stabd	78,0,0
 1777               	getSTD:
 1778               		.stabd	46,0,0
 586:../../Lib/ramdysk.c **** {
 1780               	.LM148:
 1781               	.LFBB15:
 1782 0478 CF93      		push r28
 1783 047a DF93      		push r29
 1784 047c 1F92      		push __zero_reg__
 1785 047e CDB7      		in r28,__SP_L__
 1786 0480 DEB7      		in r29,__SP_H__
 1787               	/* prologue: function */
 1788               	/* frame size = 1 */
 1789               	/* stack size = 3 */
 1790               	.L__stack_usage = 3
 590:../../Lib/ramdysk.c ****   if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
 1792               	.LM149:
 1793 0482 BE01      		movw r22,r28
 1794 0484 6F5F      		subi r22,-1
 1795 0486 7F4F      		sbci r23,-1
 1796 0488 FC01      		movw r30,r24
 1797 048a 8485      		ldd r24,Z+12
 1798 048c 9585      		ldd r25,Z+13
 1799 048e 0E94 0000 		call ramDyskCzytajBajtZPliku
 1800 0492 8111      		cpse r24,__zero_reg__
 1801 0494 00C0      		rjmp .L103
 591:../../Lib/ramdysk.c ****     return wynik;
 1803               	.LM150:
 1804 0496 8981      		ldd r24,Y+1
 1805 0498 90E0      		ldi r25,0
 1806 049a 00C0      		rjmp .L102
 1807               	.L103:
 592:../../Lib/ramdysk.c ****   return EOF;
 1809               	.LM151:
 1810 049c 8FEF      		ldi r24,lo8(-1)
 1811 049e 9FEF      		ldi r25,lo8(-1)
 1812               	.L102:
 1813               	/* epilogue start */
 593:../../Lib/ramdysk.c **** }
 1815               	.LM152:
 1816 04a0 0F90      		pop __tmp_reg__
 1817 04a2 DF91      		pop r29
 1818 04a4 CF91      		pop r28
 1819 04a6 0895      		ret
 1824               	.Lscope15:
 1826               		.stabd	78,0,0
 1831               	.global	ramDyskZapiszBlokDoPliku
 1833               	ramDyskZapiszBlokDoPliku:
 1834               		.stabd	46,0,0
 343:../../Lib/ramdysk.c **** {
 1836               	.LM153:
 1837               	.LFBB16:
 1838 04a8 9F92      		push r9
 1839 04aa AF92      		push r10
 1840 04ac BF92      		push r11
 1841 04ae CF92      		push r12
 1842 04b0 DF92      		push r13
 1843 04b2 EF92      		push r14
 1844 04b4 FF92      		push r15
 1845 04b6 0F93      		push r16
 1846 04b8 1F93      		push r17
 1847 04ba CF93      		push r28
 1848 04bc DF93      		push r29
 1849               	/* prologue: function */
 1850               	/* frame size = 0 */
 1851               	/* stack size = 11 */
 1852               	.L__stack_usage = 11
 1853 04be EC01      		movw r28,r24
 1854 04c0 5B01      		movw r10,r22
 1855 04c2 6A01      		movw r12,r20
 344:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 1857               	.LM154:
 1858 04c4 0C81      		ldd r16,Y+4
 1859 04c6 1D81      		ldd r17,Y+5
 1860 04c8 F801      		movw r30,r16
 1861 04ca 8081      		ld r24,Z
 1862 04cc 8111      		cpse r24,__zero_reg__
 1863 04ce 00C0      		rjmp .L105
 345:../../Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 1865               	.LM155:
 1866 04d0 0E94 0000 		call znajdzWolnyKlaster
 1867 04d4 F801      		movw r30,r16
 1868 04d6 8083      		st Z,r24
 1869               	.L105:
 347:../../Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisa
 1871               	.LM156:
 1872 04d8 8A81      		ldd r24,Y+2
 1873 04da E12C      		mov r14,__zero_reg__
 1874 04dc FF24      		clr r15
 1875 04de F394      		inc r15
 1876 04e0 E81A      		sub r14,r24
 1877 04e2 F108      		sbc r15,__zero_reg__
 348:../../Lib/ramdysk.c ****   uint16_t doZapisu = *dlugosc;
 1879               	.LM157:
 1880 04e4 F601      		movw r30,r12
 1881 04e6 0081      		ld r16,Z
 1882 04e8 1181      		ldd r17,Z+1
 349:../../Lib/ramdysk.c ****   *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
 1884               	.LM158:
 1885 04ea 1082      		st Z,__zero_reg__
 1886 04ec 1182      		std Z+1,__zero_reg__
 350:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 1888               	.LM159:
 1889 04ee 912C      		mov r9,__zero_reg__
 1890               	.L106:
 351:../../Lib/ramdysk.c ****   while (doZapisu > 0)
 1892               	.LM160:
 1893 04f0 0115      		cp r16,__zero_reg__
 1894 04f2 1105      		cpc r17,__zero_reg__
 1895 04f4 01F4      		brne .+2
 1896 04f6 00C0      		rjmp .L116
 353:../../Lib/ramdysk.c ****     if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to
 1898               	.LM161:
 1899 04f8 8A81      		ldd r24,Y+2
 1900 04fa 8111      		cpse r24,__zero_reg__
 1901 04fc 00C0      		rjmp .L107
 355:../../Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze
 1903               	.LM162:
 1904 04fe 9110      		cpse r9,__zero_reg__
 1905 0500 00C0      		rjmp .L108
 356:../../Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra 
 1907               	.LM163:
 1908 0502 EC81      		ldd r30,Y+4
 1909 0504 FD81      		ldd r31,Y+5
 1910 0506 6B81      		ldd r22,Y+3
 1911 0508 8081      		ld r24,Z
 1912 050a 0E94 0000 		call znajdzKlasterN
 1913 050e 00C0      		rjmp .L115
 1914               	.L108:
 358:../../Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
 1916               	.LM164:
 1917 0510 892D      		mov r24,r9
 1918 0512 0E94 0000 		call nastepnyKlaster
 1919               	.L115:
 1920 0516 982E      		mov r9,r24
 359:../../Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
 1922               	.LM165:
 1923 0518 8823      		tst r24
 1924 051a 01F4      		brne .+2
 1925 051c 00C0      		rjmp .L114
 362:../../Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Ter
 1927               	.LM166:
 1928 051e 90E0      		ldi r25,0
 1929 0520 8058      		subi r24,-128
 1930 0522 9F4F      		sbci r25,-1
 1931 0524 1882      		st Y,__zero_reg__
 1932 0526 8983      		std Y+1,r24
 1933               	.L107:
 1934 0528 8881      		ld r24,Y
 1935 052a 9981      		ldd r25,Y+1
 364:../../Lib/ramdysk.c ****     if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w b
 1937               	.LM167:
 1938 052c E016      		cp r14,r16
 1939 052e F106      		cpc r15,r17
 1940 0530 00F4      		brsh .L111
 366:../../Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
 1942               	.LM168:
 1943 0532 A701      		movw r20,r14
 1944 0534 B501      		movw r22,r10
 1945 0536 0E94 0000 		call memcpy
 367:../../Lib/ramdysk.c ****       znaki +=dlBloku;                      
 1947               	.LM169:
 1948 053a AE0C      		add r10,r14
 1949 053c BF1C      		adc r11,r15
 368:../../Lib/ramdysk.c ****       fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na począ
 1951               	.LM170:
 1952 053e 1A82      		std Y+2,__zero_reg__
 369:../../Lib/ramdysk.c ****       doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka
 1954               	.LM171:
 1955 0540 0E19      		sub r16,r14
 1956 0542 1F09      		sbc r17,r15
 370:../../Lib/ramdysk.c ****       *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych d
 1958               	.LM172:
 1959 0544 F601      		movw r30,r12
 1960 0546 2081      		ld r18,Z
 1961 0548 3181      		ldd r19,Z+1
 1962 054a 2E0D      		add r18,r14
 1963 054c 3F1D      		adc r19,r15
 1964 054e 2083      		st Z,r18
 1965 0550 3183      		std Z+1,r19
 371:../../Lib/ramdysk.c ****       fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. 
 1967               	.LM173:
 1968 0552 8B81      		ldd r24,Y+3
 1969 0554 8F5F      		subi r24,lo8(-(1))
 1970 0556 8B83      		std Y+3,r24
 372:../../Lib/ramdysk.c ****       dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 
 1972               	.LM174:
 1973 0558 E12C      		mov r14,__zero_reg__
 1974 055a FF24      		clr r15
 1975 055c F394      		inc r15
 1976 055e 00C0      		rjmp .L106
 1977               	.L111:
 376:../../Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
 1979               	.LM175:
 1980 0560 A801      		movw r20,r16
 1981 0562 B501      		movw r22,r10
 1982 0564 0E94 0000 		call memcpy
 377:../../Lib/ramdysk.c ****       fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mn
 1984               	.LM176:
 1985 0568 8A81      		ldd r24,Y+2
 1986 056a 800F      		add r24,r16
 1987 056c 8A83      		std Y+2,r24
 378:../../Lib/ramdysk.c ****       *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych d
 1989               	.LM177:
 1990 056e F601      		movw r30,r12
 1991 0570 2081      		ld r18,Z
 1992 0572 3181      		ldd r19,Z+1
 1993 0574 200F      		add r18,r16
 1994 0576 311F      		adc r19,r17
 1995 0578 2083      		st Z,r18
 1996 057a 3183      		std Z+1,r19
 380:../../Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce kla
 1998               	.LM178:
 1999 057c 292D      		mov r18,r9
 2000 057e 30E0      		ldi r19,0
 2001 0580 2058      		subi r18,-128
 2002 0582 3F4F      		sbci r19,-1
 2003 0584 322F      		mov r19,r18
 2004 0586 2227      		clr r18
 2005 0588 8A81      		ldd r24,Y+2
 2006 058a 280F      		add r18,r24
 2007 058c 311D      		adc r19,__zero_reg__
 2008 058e 2883      		st Y,r18
 2009 0590 3983      		std Y+1,r19
 379:../../Lib/ramdysk.c ****       doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
 2011               	.LM179:
 2012 0592 00E0      		ldi r16,0
 2013 0594 10E0      		ldi r17,0
 2014 0596 00C0      		rjmp .L106
 2015               	.L116:
 383:../../Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
 2017               	.LM180:
 2018 0598 CE01      		movw r24,r28
 2019 059a 0E94 0000 		call uaktualnijRozmiarPliku
 384:../../Lib/ramdysk.c ****   return 0;
 2021               	.LM181:
 2022 059e 80E0      		ldi r24,0
 2023 05a0 00C0      		rjmp .L110
 2024               	.L114:
 360:../../Lib/ramdysk.c ****         return 1;                                 //1 - Brak wolnego klastra
 2026               	.LM182:
 2027 05a2 81E0      		ldi r24,lo8(1)
 2028               	.L110:
 2029               	/* epilogue start */
 385:../../Lib/ramdysk.c **** }
 2031               	.LM183:
 2032 05a4 DF91      		pop r29
 2033 05a6 CF91      		pop r28
 2034 05a8 1F91      		pop r17
 2035 05aa 0F91      		pop r16
 2036 05ac FF90      		pop r15
 2037 05ae EF90      		pop r14
 2038 05b0 DF90      		pop r13
 2039 05b2 CF90      		pop r12
 2040 05b4 BF90      		pop r11
 2041 05b6 AF90      		pop r10
 2042 05b8 9F90      		pop r9
 2043 05ba 0895      		ret
 2050               	.Lscope16:
 2052               		.stabd	78,0,0
 2057               	.global	ramDyskCzytajBlokZPliku
 2059               	ramDyskCzytajBlokZPliku:
 2060               		.stabd	46,0,0
 388:../../Lib/ramdysk.c **** {
 2062               	.LM184:
 2063               	.LFBB17:
 2064 05bc 9F92      		push r9
 2065 05be AF92      		push r10
 2066 05c0 BF92      		push r11
 2067 05c2 CF92      		push r12
 2068 05c4 DF92      		push r13
 2069 05c6 EF92      		push r14
 2070 05c8 FF92      		push r15
 2071 05ca 0F93      		push r16
 2072 05cc 1F93      		push r17
 2073 05ce CF93      		push r28
 2074 05d0 DF93      		push r29
 2075               	/* prologue: function */
 2076               	/* frame size = 0 */
 2077               	/* stack size = 11 */
 2078               	.L__stack_usage = 11
 2079 05d2 EC01      		movw r28,r24
 2080 05d4 5B01      		movw r10,r22
 2081 05d6 7A01      		movw r14,r20
 389:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 2083               	.LM185:
 2084 05d8 EC81      		ldd r30,Y+4
 2085 05da FD81      		ldd r31,Y+5
 2086 05dc 8081      		ld r24,Z
 2087 05de 8111      		cpse r24,__zero_reg__
 2088 05e0 00C0      		rjmp .L118
 391:../../Lib/ramdysk.c ****     *dlugosc = 0;
 2090               	.LM186:
 2091 05e2 FA01      		movw r30,r20
 2092 05e4 1082      		st Z,__zero_reg__
 2093 05e6 1182      		std Z+1,__zero_reg__
 392:../../Lib/ramdysk.c ****     return 1;                         //1 - Plik jest pusty
 2095               	.LM187:
 2096 05e8 81E0      		ldi r24,lo8(1)
 2097 05ea 00C0      		rjmp .L131
 2098               	.L118:
 2099               	.LBB24:
 2100               	.LBB25:
  26:../../Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi > fd->IndHi)
 2102               	.LM188:
 2103 05ec 8281      		ldd r24,Z+2
 2104 05ee 2B81      		ldd r18,Y+3
 2105 05f0 2817      		cp r18,r24
 2106 05f2 00F0      		brlo .L120
  29:../../Lib/ramdysk.c ****   if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
 2108               	.LM189:
 2109 05f4 8213      		cpse r24,r18
 2110 05f6 00C0      		rjmp .L121
 2111 05f8 3181      		ldd r19,Z+1
 2112 05fa 9A81      		ldd r25,Y+2
 2113 05fc 3917      		cp r19,r25
 2114 05fe 00F4      		brsh .L120
 2115               	.L121:
 2116               	.LBE25:
 2117               	.LBE24:
 396:../../Lib/ramdysk.c ****     *dlugosc = 0;
 2119               	.LM190:
 2120 0600 F701      		movw r30,r14
 2121 0602 1082      		st Z,__zero_reg__
 2122 0604 1182      		std Z+1,__zero_reg__
 397:../../Lib/ramdysk.c ****     return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pli
 2124               	.LM191:
 2125 0606 82E0      		ldi r24,lo8(2)
 2126 0608 00C0      		rjmp .L131
 2127               	.L120:
 400:../../Lib/ramdysk.c ****   uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
 2129               	.LM192:
 2130 060a 90E0      		ldi r25,0
 2131 060c 821B      		sub r24,r18
 2132 060e 9109      		sbc r25,__zero_reg__
 401:../../Lib/ramdysk.c ****   lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze z
 2134               	.LM193:
 2135 0610 2181      		ldd r18,Z+1
 2136 0612 30E0      		ldi r19,0
 402:../../Lib/ramdysk.c ****   lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zaws
 2138               	.LM194:
 2139 0614 4A81      		ldd r20,Y+2
 401:../../Lib/ramdysk.c ****   lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze z
 2141               	.LM195:
 2142 0616 241B      		sub r18,r20
 2143 0618 3109      		sbc r19,__zero_reg__
 402:../../Lib/ramdysk.c ****   lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zaws
 2145               	.LM196:
 2146 061a 280F      		add r18,r24
 2147 061c 391F      		adc r19,r25
 404:../../Lib/ramdysk.c ****   uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i
 2149               	.LM197:
 2150 061e F701      		movw r30,r14
 2151 0620 0081      		ld r16,Z
 2152 0622 1181      		ldd r17,Z+1
 2153 0624 2017      		cp r18,r16
 2154 0626 3107      		cpc r19,r17
 2155 0628 00F4      		brsh .L128
 2156 062a 8901      		movw r16,r18
 2157               	.L128:
 407:../../Lib/ramdysk.c ****   *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
 2159               	.LM198:
 2160 062c F701      		movw r30,r14
 2161 062e 1082      		st Z,__zero_reg__
 2162 0630 1182      		std Z+1,__zero_reg__
 408:../../Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktua
 2164               	.LM199:
 2165 0632 8A81      		ldd r24,Y+2
 2166 0634 C12C      		mov r12,__zero_reg__
 2167 0636 DD24      		clr r13
 2168 0638 D394      		inc r13
 2169 063a C81A      		sub r12,r24
 2170 063c D108      		sbc r13,__zero_reg__
 409:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 2172               	.LM200:
 2173 063e 912C      		mov r9,__zero_reg__
 2174               	.L129:
 410:../../Lib/ramdysk.c ****   while (doOdczytania > 0)
 2176               	.LM201:
 2177 0640 0115      		cp r16,__zero_reg__
 2178 0642 1105      		cpc r17,__zero_reg__
 2179 0644 01F4      		brne .+2
 2180 0646 00C0      		rjmp .L133
 412:../../Lib/ramdysk.c ****     if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, 
 2182               	.LM202:
 2183 0648 8A81      		ldd r24,Y+2
 2184 064a 8111      		cpse r24,__zero_reg__
 2185 064c 00C0      		rjmp .L122
 414:../../Lib/ramdysk.c ****       if (tmpKlaster == 0)
 2187               	.LM203:
 2188 064e 9110      		cpse r9,__zero_reg__
 2189 0650 00C0      		rjmp .L123
 415:../../Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
 2191               	.LM204:
 2192 0652 EC81      		ldd r30,Y+4
 2193 0654 FD81      		ldd r31,Y+5
 2194 0656 6B81      		ldd r22,Y+3
 2195 0658 8081      		ld r24,Z
 2196 065a 0E94 0000 		call znajdzKlasterN
 2197 065e 00C0      		rjmp .L132
 2198               	.L123:
 417:../../Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster);
 2200               	.LM205:
 2201 0660 892D      		mov r24,r9
 2202 0662 0E94 0000 		call nastepnyKlaster
 2203               	.L132:
 2204 0666 982E      		mov r9,r24
 418:../../Lib/ramdysk.c ****       if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
 2206               	.LM206:
 2207 0668 8823      		tst r24
 2208 066a 01F0      		breq .L130
 419:../../Lib/ramdysk.c ****         fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
 2210               	.LM207:
 2211 066c 90E0      		ldi r25,0
 2212 066e 8058      		subi r24,-128
 2213 0670 9F4F      		sbci r25,-1
 2214 0672 1882      		st Y,__zero_reg__
 2215 0674 8983      		std Y+1,r24
 2216               	.L122:
 2217 0676 6881      		ld r22,Y
 2218 0678 7981      		ldd r23,Y+1
 424:../../Lib/ramdysk.c ****     if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
 2220               	.LM208:
 2221 067a C016      		cp r12,r16
 2222 067c D106      		cpc r13,r17
 2223 067e 00F4      		brsh .L125
 426:../../Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
 2225               	.LM209:
 2226 0680 A601      		movw r20,r12
 2227 0682 C501      		movw r24,r10
 2228 0684 0E94 0000 		call memcpy
 427:../../Lib/ramdysk.c ****       znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy 
 2230               	.LM210:
 2231 0688 AC0C      		add r10,r12
 2232 068a BD1C      		adc r11,r13
 428:../../Lib/ramdysk.c ****       fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
 2234               	.LM211:
 2235 068c 1A82      		std Y+2,__zero_reg__
 429:../../Lib/ramdysk.c ****       fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz ni
 2237               	.LM212:
 2238 068e 8B81      		ldd r24,Y+3
 2239 0690 8F5F      		subi r24,lo8(-(1))
 2240 0692 8B83      		std Y+3,r24
 430:../../Lib/ramdysk.c ****       doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
 2242               	.LM213:
 2243 0694 0C19      		sub r16,r12
 2244 0696 1D09      		sbc r17,r13
 431:../../Lib/ramdysk.c ****       *dlugosc += dlBloku;             //Uaktualnienie 
 2246               	.LM214:
 2247 0698 F701      		movw r30,r14
 2248 069a 2081      		ld r18,Z
 2249 069c 3181      		ldd r19,Z+1
 2250 069e 2C0D      		add r18,r12
 2251 06a0 3D1D      		adc r19,r13
 2252 06a2 2083      		st Z,r18
 2253 06a4 3183      		std Z+1,r19
 432:../../Lib/ramdysk.c ****       dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całeg
 2255               	.LM215:
 2256 06a6 C12C      		mov r12,__zero_reg__
 2257 06a8 DD24      		clr r13
 2258 06aa D394      		inc r13
 2259 06ac 00C0      		rjmp .L129
 2260               	.L125:
 436:../../Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, doOdczytania);
 2262               	.LM216:
 2263 06ae A801      		movw r20,r16
 2264 06b0 C501      		movw r24,r10
 2265 06b2 0E94 0000 		call memcpy
 437:../../Lib/ramdysk.c ****       fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym sam
 2267               	.LM217:
 2268 06b6 2881      		ld r18,Y
 2269 06b8 3981      		ldd r19,Y+1
 2270 06ba 200F      		add r18,r16
 2271 06bc 311F      		adc r19,r17
 2272 06be 2883      		st Y,r18
 2273 06c0 3983      		std Y+1,r19
 438:../../Lib/ramdysk.c ****       fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zat
 2275               	.LM218:
 2276 06c2 8A81      		ldd r24,Y+2
 2277 06c4 800F      		add r24,r16
 2278 06c6 8A83      		std Y+2,r24
 439:../../Lib/ramdysk.c ****       *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                  
 2280               	.LM219:
 2281 06c8 F701      		movw r30,r14
 2282 06ca 2081      		ld r18,Z
 2283 06cc 3181      		ldd r19,Z+1
 2284 06ce 200F      		add r18,r16
 2285 06d0 311F      		adc r19,r17
 2286 06d2 2083      		st Z,r18
 2287 06d4 3183      		std Z+1,r19
 440:../../Lib/ramdysk.c ****       doOdczytania = 0;                //Tutaj równie dobrze może być brake
 2289               	.LM220:
 2290 06d6 00E0      		ldi r16,0
 2291 06d8 10E0      		ldi r17,0
 2292 06da 00C0      		rjmp .L129
 2293               	.L133:
 443:../../Lib/ramdysk.c ****   return 0;
 2295               	.LM221:
 2296 06dc 80E0      		ldi r24,0
 2297 06de 00C0      		rjmp .L131
 2298               	.L130:
 421:../../Lib/ramdysk.c ****         return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
 2300               	.LM222:
 2301 06e0 83E0      		ldi r24,lo8(3)
 2302               	.L131:
 2303               	/* epilogue start */
 444:../../Lib/ramdysk.c **** }
 2305               	.LM223:
 2306 06e2 DF91      		pop r29
 2307 06e4 CF91      		pop r28
 2308 06e6 1F91      		pop r17
 2309 06e8 0F91      		pop r16
 2310 06ea FF90      		pop r15
 2311 06ec EF90      		pop r14
 2312 06ee DF90      		pop r13
 2313 06f0 CF90      		pop r12
 2314 06f2 BF90      		pop r11
 2315 06f4 AF90      		pop r10
 2316 06f6 9F90      		pop r9
 2317 06f8 0895      		ret
 2324               	.Lscope17:
 2326               		.stabd	78,0,0
 2330               	.global	ramDyskUstawWskaznik
 2332               	ramDyskUstawWskaznik:
 2333               		.stabd	46,0,0
 447:../../Lib/ramdysk.c **** {
 2335               	.LM224:
 2336               	.LFBB18:
 2337 06fa EF92      		push r14
 2338 06fc FF92      		push r15
 2339 06fe 0F93      		push r16
 2340 0700 1F93      		push r17
 2341 0702 CF93      		push r28
 2342 0704 DF93      		push r29
 2343               	/* prologue: function */
 2344               	/* frame size = 0 */
 2345               	/* stack size = 6 */
 2346               	.L__stack_usage = 6
 2347 0706 EC01      		movw r28,r24
 448:../../Lib/ramdysk.c ****   if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje
 2349               	.LM225:
 2350 0708 6115      		cp r22,__zero_reg__
 2351 070a 7105      		cpc r23,__zero_reg__
 2352 070c 01F4      		brne .L135
 450:../../Lib/ramdysk.c ****     fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bard
 2354               	.LM226:
 2355 070e 1A82      		std Y+2,__zero_reg__
 451:../../Lib/ramdysk.c ****     fd->IndHi = 0;
 2357               	.LM227:
 2358 0710 1B82      		std Y+3,__zero_reg__
 2359 0712 00C0      		rjmp .L140
 2360               	.L135:
 454:../../Lib/ramdysk.c ****   indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio 
 2362               	.LM228:
 2363 0714 8B01      		movw r16,r22
 2364 0716 0150      		subi r16,1
 2365 0718 1109      		sbc r17,__zero_reg__
 457:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydziel
 2367               	.LM229:
 2368 071a EC80      		ldd r14,Y+4
 2369 071c FD80      		ldd r15,Y+5
 2370 071e F701      		movw r30,r14
 2371 0720 8081      		ld r24,Z
 2372 0722 8111      		cpse r24,__zero_reg__
 2373 0724 00C0      		rjmp .L137
 458:../../Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pl
 2375               	.LM230:
 2376 0726 0E94 0000 		call znajdzWolnyKlaster
 2377 072a F701      		movw r30,r14
 2378 072c 8083      		st Z,r24
 2379               	.L137:
 462:../../Lib/ramdysk.c ****   fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mn
 2381               	.LM231:
 2382 072e 0A83      		std Y+2,r16
 463:../../Lib/ramdysk.c ****   fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu
 2384               	.LM232:
 2385 0730 1B83      		std Y+3,r17
 465:../../Lib/ramdysk.c ****   uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
 2387               	.LM233:
 2388 0732 EC81      		ldd r30,Y+4
 2389 0734 FD81      		ldd r31,Y+5
 2390 0736 612F      		mov r22,r17
 2391 0738 8081      		ld r24,Z
 2392 073a 0E94 0000 		call znajdzKlasterN
 2393 073e 182F      		mov r17,r24
 466:../../Lib/ramdysk.c ****   if (nrKlastra == 0)
 2395               	.LM234:
 2396 0740 8823      		tst r24
 2397 0742 01F0      		breq .L139
 469:../../Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
 2399               	.LM235:
 2400 0744 CE01      		movw r24,r28
 2401 0746 0E94 0000 		call uaktualnijRozmiarPliku
 471:../../Lib/ramdysk.c ****   fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
 2403               	.LM236:
 2404 074a 2A81      		ldd r18,Y+2
 2405 074c 2F5F      		subi r18,lo8(-(1))
 2406 074e 2A83      		std Y+2,r18
 472:../../Lib/ramdysk.c ****   if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, 
 2408               	.LM237:
 2409 0750 2111      		cpse r18,__zero_reg__
 2410 0752 00C0      		rjmp .L138
 473:../../Lib/ramdysk.c ****     fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący b
 2412               	.LM238:
 2413 0754 8B81      		ldd r24,Y+3
 2414 0756 8F5F      		subi r24,lo8(-(1))
 2415 0758 8B83      		std Y+3,r24
 2416 075a 00C0      		rjmp .L140
 2417               	.L138:
 475:../../Lib/ramdysk.c ****     fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejs
 2419               	.LM239:
 2420 075c 812F      		mov r24,r17
 2421 075e 90E0      		ldi r25,0
 2422 0760 8058      		subi r24,-128
 2423 0762 9F4F      		sbci r25,-1
 2424 0764 982F      		mov r25,r24
 2425 0766 8827      		clr r24
 2426 0768 820F      		add r24,r18
 2427 076a 911D      		adc r25,__zero_reg__
 2428 076c 8883      		st Y,r24
 2429 076e 9983      		std Y+1,r25
 2430               	.L140:
 477:../../Lib/ramdysk.c ****   return 0; 
 2432               	.LM240:
 2433 0770 80E0      		ldi r24,0
 2434 0772 00C0      		rjmp .L136
 2435               	.L139:
 467:../../Lib/ramdysk.c ****     return 1;                                             //Brak klastrów
 2437               	.LM241:
 2438 0774 81E0      		ldi r24,lo8(1)
 2439               	.L136:
 2440               	/* epilogue start */
 478:../../Lib/ramdysk.c **** }
 2442               	.LM242:
 2443 0776 DF91      		pop r29
 2444 0778 CF91      		pop r28
 2445 077a 1F91      		pop r17
 2446 077c 0F91      		pop r16
 2447 077e FF90      		pop r15
 2448 0780 EF90      		pop r14
 2449 0782 0895      		ret
 2454               	.Lscope18:
 2456               		.stabd	78,0,0
 2459               	.global	ramDyskUstawWskaznikNaKoniec
 2461               	ramDyskUstawWskaznikNaKoniec:
 2462               		.stabd	46,0,0
 481:../../Lib/ramdysk.c **** {
 2464               	.LM243:
 2465               	.LFBB19:
 2466 0784 CF93      		push r28
 2467 0786 DF93      		push r29
 2468               	/* prologue: function */
 2469               	/* frame size = 0 */
 2470               	/* stack size = 2 */
 2471               	.L__stack_usage = 2
 2472 0788 EC01      		movw r28,r24
 482:../../Lib/ramdysk.c ****   if (fd == NULL)
 2474               	.LM244:
 2475 078a 0097      		sbiw r24,0
 2476 078c 01F0      		breq .L143
 484:../../Lib/ramdysk.c ****   fd->IndLo = fd->wpis->rozmiarLo;
 2478               	.LM245:
 2479 078e EC81      		ldd r30,Y+4
 2480 0790 FD81      		ldd r31,Y+5
 2481 0792 8181      		ldd r24,Z+1
 2482 0794 8A83      		std Y+2,r24
 485:../../Lib/ramdysk.c ****   fd->IndHi = fd->wpis->rozmiarHi;
 2484               	.LM246:
 2485 0796 9281      		ldd r25,Z+2
 2486 0798 9B83      		std Y+3,r25
 488:../../Lib/ramdysk.c ****   if (fd->IndLo != 0)
 2488               	.LM247:
 2489 079a 8823      		tst r24
 2490 079c 01F0      		breq .L144
 490:../../Lib/ramdysk.c ****     tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
 2492               	.LM248:
 2493 079e 6281      		ldd r22,Z+2
 2494 07a0 8081      		ld r24,Z
 2495 07a2 0E94 0000 		call znajdzKlasterN
 491:../../Lib/ramdysk.c ****     fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
 2497               	.LM249:
 2498 07a6 90E0      		ldi r25,0
 2499 07a8 8058      		subi r24,-128
 2500 07aa 9F4F      		sbci r25,-1
 2501 07ac 982F      		mov r25,r24
 2502 07ae 8827      		clr r24
 2503 07b0 2A81      		ldd r18,Y+2
 2504 07b2 820F      		add r24,r18
 2505 07b4 911D      		adc r25,__zero_reg__
 2506 07b6 8883      		st Y,r24
 2507 07b8 9983      		std Y+1,r25
 2508 07ba 00C0      		rjmp .L144
 2509               	.L143:
 483:../../Lib/ramdysk.c ****     return 1;
 2511               	.LM250:
 2512 07bc 81E0      		ldi r24,lo8(1)
 2513 07be 00C0      		rjmp .L142
 2514               	.L144:
 493:../../Lib/ramdysk.c ****   return 0;
 2516               	.LM251:
 2517 07c0 80E0      		ldi r24,0
 2518               	.L142:
 2519               	/* epilogue start */
 494:../../Lib/ramdysk.c **** }
 2521               	.LM252:
 2522 07c2 DF91      		pop r29
 2523 07c4 CF91      		pop r28
 2524 07c6 0895      		ret
 2529               	.Lscope19:
 2531               		.stabd	78,0,0
 2535               	.global	ramDyskDodajBlokXmodem
 2537               	ramDyskDodajBlokXmodem:
 2538               		.stabd	46,0,0
 497:../../Lib/ramdysk.c **** {
 2540               	.LM253:
 2541               	.LFBB20:
 2542 07c8 BF92      		push r11
 2543 07ca CF92      		push r12
 2544 07cc DF92      		push r13
 2545 07ce EF92      		push r14
 2546 07d0 FF92      		push r15
 2547 07d2 0F93      		push r16
 2548 07d4 1F93      		push r17
 2549 07d6 CF93      		push r28
 2550 07d8 DF93      		push r29
 2551               	/* prologue: function */
 2552               	/* frame size = 0 */
 2553               	/* stack size = 9 */
 2554               	.L__stack_usage = 9
 2555 07da EC01      		movw r28,r24
 498:../../Lib/ramdysk.c ****   if (nrBloku == 0)
 2557               	.LM254:
 2558 07dc 6115      		cp r22,__zero_reg__
 2559 07de 7105      		cpc r23,__zero_reg__
 2560 07e0 01F4      		brne .L146
 2561               	.L149:
 499:../../Lib/ramdysk.c ****     return NULL;
 2563               	.LM255:
 2564 07e2 80E0      		ldi r24,0
 2565 07e4 90E0      		ldi r25,0
 2566 07e6 00C0      		rjmp .L147
 2567               	.L146:
 500:../../Lib/ramdysk.c ****   nrBloku --;
 2569               	.LM256:
 2570 07e8 7B01      		movw r14,r22
 2571 07ea 81E0      		ldi r24,1
 2572 07ec E81A      		sub r14,r24
 2573 07ee F108      		sbc r15,__zero_reg__
 502:../../Lib/ramdysk.c ****   uint8_t indHi = (uint8_t)(nrBloku / 2);
 2575               	.LM257:
 2576 07f0 8701      		movw r16,r14
 2577 07f2 1695      		lsr r17
 2578 07f4 0795      		ror r16
 2579 07f6 B02E      		mov r11,r16
 506:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 2581               	.LM258:
 2582 07f8 CC80      		ldd r12,Y+4
 2583 07fa DD80      		ldd r13,Y+5
 2584 07fc F601      		movw r30,r12
 2585 07fe 8081      		ld r24,Z
 2586 0800 8111      		cpse r24,__zero_reg__
 2587 0802 00C0      		rjmp .L148
 507:../../Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 2589               	.LM259:
 2590 0804 0E94 0000 		call znajdzWolnyKlaster
 2591 0808 F601      		movw r30,r12
 2592 080a 8083      		st Z,r24
 2593               	.L148:
 508:../../Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 2595               	.LM260:
 2596 080c EC81      		ldd r30,Y+4
 2597 080e FD81      		ldd r31,Y+5
 2598 0810 8081      		ld r24,Z
 2599 0812 8823      		tst r24
 2600 0814 01F0      		breq .L149
 511:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
 2602               	.LM261:
 2603 0816 602F      		mov r22,r16
 2604 0818 0E94 0000 		call znajdzKlasterN
 512:../../Lib/ramdysk.c ****   if (tmpKlaster == 0)
 2606               	.LM262:
 2607 081c 8823      		tst r24
 2608 081e 01F0      		breq .L149
 2609 0820 EC81      		ldd r30,Y+4
 2610 0822 FD81      		ldd r31,Y+5
 2611 0824 282F      		mov r18,r24
 2612 0826 30E0      		ldi r19,0
 517:../../Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi <= indHi)
 2614               	.LM263:
 2615 0828 8281      		ldd r24,Z+2
 514:../../Lib/ramdysk.c ****   if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
 2617               	.LM264:
 2618 082a E0FE      		sbrs r14,0
 2619 082c 00C0      		rjmp .L150
 517:../../Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi <= indHi)
 2621               	.LM265:
 2622 082e B816      		cp r11,r24
 2623 0830 00F0      		brlo .L151
 519:../../Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi+1;
 2625               	.LM266:
 2626 0832 0F5F      		subi r16,lo8(-(1))
 2627 0834 0283      		std Z+2,r16
 520:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 0;
 2629               	.LM267:
 2630 0836 EC81      		ldd r30,Y+4
 2631 0838 FD81      		ldd r31,Y+5
 2632 083a 1182      		std Z+1,__zero_reg__
 2633               	.L151:
 522:../../Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 128);
 2635               	.LM268:
 2636 083c 322F      		mov r19,r18
 2637 083e 2227      		clr r18
 2638 0840 2058      		subi r18,-128
 2639 0842 3F47      		sbci r19,127
 2640 0844 C901      		movw r24,r18
 2641 0846 00C0      		rjmp .L147
 2642               	.L150:
 526:../../Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi < indHi)
 2644               	.LM269:
 2645 0848 8B15      		cp r24,r11
 2646 084a 00F4      		brsh .L152
 528:../../Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi;
 2648               	.LM270:
 2649 084c 0283      		std Z+2,r16
 529:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 2651               	.LM271:
 2652 084e EC81      		ldd r30,Y+4
 2653 0850 FD81      		ldd r31,Y+5
 2654 0852 00C0      		rjmp .L160
 2655               	.L152:
 531:../../Lib/ramdysk.c ****     else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
 2657               	.LM272:
 2658 0854 8B11      		cpse r24,r11
 2659 0856 00C0      		rjmp .L153
 531:../../Lib/ramdysk.c ****     else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
 2661               	.LM273:
 2662 0858 8181      		ldd r24,Z+1
 2663 085a 87FD      		sbrc r24,7
 2664 085c 00C0      		rjmp .L153
 2665               	.L160:
 532:../../Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 2667               	.LM274:
 2668 085e 80E8      		ldi r24,lo8(-128)
 2669 0860 8183      		std Z+1,r24
 2670               	.L153:
 534:../../Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 0);
 2672               	.LM275:
 2673 0862 80E0      		ldi r24,0
 2674 0864 90E8      		ldi r25,lo8(-128)
 2675 0866 920F      		add r25,r18
 2676               	.L147:
 2677               	/* epilogue start */
 537:../../Lib/ramdysk.c **** }
 2679               	.LM276:
 2680 0868 DF91      		pop r29
 2681 086a CF91      		pop r28
 2682 086c 1F91      		pop r17
 2683 086e 0F91      		pop r16
 2684 0870 FF90      		pop r15
 2685 0872 EF90      		pop r14
 2686 0874 DF90      		pop r13
 2687 0876 CF90      		pop r12
 2688 0878 BF90      		pop r11
 2689 087a 0895      		ret
 2695               	.Lscope20:
 2697               		.stabd	78,0,0
 2698               		.section	.rodata.str1.1,"aMS",@progbits,1
 2699               	.LC0:
 2700 0000 6E61 7A77 		.string	"nazwa\t\trozmiar\totwarty\r\n"
 2700      6109 0972 
 2700      6F7A 6D69 
 2700      6172 096F 
 2700      7477 6172 
 2701               	.LC1:
 2702 0019 0925 6409 		.string	"\t%d\t%d\r\n"
 2702      2564 0D0A 
 2702      00
 2703               		.text
 2705               	.global	ramDyskDir
 2707               	ramDyskDir:
 2708               		.stabd	46,0,0
 540:../../Lib/ramdysk.c **** {
 2710               	.LM277:
 2711               	.LFBB21:
 2712 087c 4F92      		push r4
 2713 087e 5F92      		push r5
 2714 0880 6F92      		push r6
 2715 0882 7F92      		push r7
 2716 0884 8F92      		push r8
 2717 0886 9F92      		push r9
 2718 0888 AF92      		push r10
 2719 088a BF92      		push r11
 2720 088c CF92      		push r12
 2721 088e DF92      		push r13
 2722 0890 EF92      		push r14
 2723 0892 FF92      		push r15
 2724 0894 0F93      		push r16
 2725 0896 1F93      		push r17
 2726 0898 CF93      		push r28
 2727 089a DF93      		push r29
 2728               	/* prologue: function */
 2729               	/* frame size = 0 */
 2730               	/* stack size = 16 */
 2731               	.L__stack_usage = 16
 2732 089c 782E      		mov r7,r24
 2733 089e 692E      		mov r6,r25
 541:../../Lib/ramdysk.c ****   fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
 2735               	.LM278:
 2736 08a0 682F      		mov r22,r24
 2737 08a2 792F      		mov r23,r25
 2738 08a4 80E0      		ldi r24,lo8(.LC0)
 2739 08a6 90E0      		ldi r25,hi8(.LC0)
 2740 08a8 0E94 0000 		call fputs
 543:../../Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 2742               	.LM279:
 2743 08ac 512C      		mov r5,__zero_reg__
 565:../../Lib/ramdysk.c ****       fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
 2745               	.LM280:
 2746 08ae 30E0      		ldi r19,lo8(.LC1)
 2747 08b0 E32E      		mov r14,r19
 2748 08b2 30E0      		ldi r19,hi8(.LC1)
 2749 08b4 F32E      		mov r15,r19
 2750               	.L171:
 548:../../Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
 2752               	.LM281:
 2753 08b6 C52C      		mov r12,r5
 2754 08b8 D12C      		mov r13,__zero_reg__
 2755 08ba 5601      		movw r10,r12
 2756 08bc 80E8      		ldi r24,-128
 2757 08be A80E      		add r10,r24
 2758 08c0 B11C      		adc r11,__zero_reg__
 2759 08c2 BA2C      		mov r11,r10
 2760 08c4 AA24      		clr r10
 2761 08c6 E501      		movw r28,r10
 2762 08c8 6096      		adiw r28,16
 2763 08ca 90EF      		ldi r25,-16
 2764 08cc A91A      		sub r10,r25
 2765 08ce 9EEF      		ldi r25,-2
 2766 08d0 B90A      		sbc r11,r25
 2767               	.L170:
 2768 08d2 4E01      		movw r8,r28
 2769 08d4 80E1      		ldi r24,16
 2770 08d6 881A      		sub r8,r24
 2771 08d8 9108      		sbc r9,__zero_reg__
 2772 08da FE01      		movw r30,r28
 2773 08dc 3C97      		sbiw r30,12
 551:../../Lib/ramdysk.c ****       tmp3=plik->nazwa[0];
 2775               	.LM282:
 2776 08de 4080      		ld r4,Z
 552:../../Lib/ramdysk.c ****       if (tmp3 == 0)
 2778               	.LM283:
 2779 08e0 4110      		cpse r4,__zero_reg__
 2780 08e2 00C0      		rjmp .L162
 2781               	.L169:
 569:../../Lib/ramdysk.c ****     tmpKlaster = klastry[tmpKlaster];
 2783               	.LM284:
 2784 08e4 F601      		movw r30,r12
 2785 08e6 E050      		subi r30,lo8(-(klastry))
 2786 08e8 F040      		sbci r31,hi8(-(klastry))
 2787 08ea 8081      		ld r24,Z
 571:../../Lib/ramdysk.c ****   while (tmpKlaster != tmpKlaster2);
 2789               	.LM285:
 2790 08ec 8515      		cp r24,r5
 2791 08ee 01F4      		brne .+2
 2792 08f0 00C0      		rjmp .L179
 569:../../Lib/ramdysk.c ****     tmpKlaster = klastry[tmpKlaster];
 2794               	.LM286:
 2795 08f2 582E      		mov r5,r24
 2796 08f4 00C0      		rjmp .L171
 2797               	.L162:
 554:../../Lib/ramdysk.c ****       fputc(tmp3         , ostream);
 2799               	.LM287:
 2800 08f6 672D      		mov r22,r7
 2801 08f8 762D      		mov r23,r6
 2802 08fa 842D      		mov r24,r4
 2803 08fc 90E0      		ldi r25,0
 2804 08fe 0E94 0000 		call fputc
 2805 0902 00E0      		ldi r16,0
 2806 0904 10E0      		ldi r17,0
 2807               	.L168:
 561:../../Lib/ramdysk.c ****           fputc(tmp3     , ostream);
 2809               	.LM288:
 2810 0906 672D      		mov r22,r7
 2811 0908 762D      		mov r23,r6
 557:../../Lib/ramdysk.c ****         if (tmp3 != 0)
 2813               	.LM289:
 2814 090a 4420      		tst r4
 2815 090c 01F0      		breq .L165
 2816 090e F401      		movw r30,r8
 2817 0910 E00F      		add r30,r16
 2818 0912 F11F      		adc r31,r17
 558:../../Lib/ramdysk.c ****           tmp3=plik->nazwa[tmp2];
 2820               	.LM290:
 2821 0914 4580      		ldd r4,Z+5
 560:../../Lib/ramdysk.c ****         if (tmp3 != 0)
 2823               	.LM291:
 2824 0916 4420      		tst r4
 2825 0918 01F0      		breq .L165
 561:../../Lib/ramdysk.c ****           fputc(tmp3     , ostream);
 2827               	.LM292:
 2828 091a 842D      		mov r24,r4
 2829 091c 90E0      		ldi r25,0
 2830 091e 0E94 0000 		call fputc
 2831 0922 00C0      		rjmp .L166
 2832               	.L165:
 563:../../Lib/ramdysk.c ****           fputc(' '      , ostream);
 2834               	.LM293:
 2835 0924 80E2      		ldi r24,lo8(32)
 2836 0926 90E0      		ldi r25,0
 2837 0928 0E94 0000 		call fputc
 2838 092c 412C      		mov r4,__zero_reg__
 2839               	.L166:
 2840 092e 0F5F      		subi r16,-1
 2841 0930 1F4F      		sbci r17,-1
 555:../../Lib/ramdysk.c ****       for (tmp2=1; tmp2<8; tmp2++)
 2843               	.LM294:
 2844 0932 0730      		cpi r16,7
 2845 0934 1105      		cpc r17,__zero_reg__
 2846 0936 01F4      		brne .L168
 2847 0938 FE01      		movw r30,r28
 2848 093a 3D97      		sbiw r30,13
 565:../../Lib/ramdysk.c ****       fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
 2850               	.LM295:
 2851 093c 8081      		ld r24,Z
 2852 093e 1F92      		push __zero_reg__
 2853 0940 8F93      		push r24
 2854 0942 FE01      		movw r30,r28
 2855 0944 3E97      		sbiw r30,14
 2856 0946 2081      		ld r18,Z
 2857 0948 30E0      		ldi r19,0
 2858 094a 322F      		mov r19,r18
 2859 094c 2227      		clr r18
 2860 094e FE01      		movw r30,r28
 2861 0950 3F97      		sbiw r30,15
 2862 0952 8081      		ld r24,Z
 2863 0954 280F      		add r18,r24
 2864 0956 311D      		adc r19,__zero_reg__
 2865 0958 3F93      		push r19
 2866 095a 2F93      		push r18
 2867 095c FF92      		push r15
 2868 095e EF92      		push r14
 2869 0960 6F92      		push r6
 2870 0962 7F92      		push r7
 2871 0964 0E94 0000 		call fprintf
 2872 0968 6096      		adiw r28,16
 549:../../Lib/ramdysk.c ****     for (tmp=0; tmp<16; tmp++)
 2874               	.LM296:
 2875 096a 8DB7      		in r24,__SP_L__
 2876 096c 9EB7      		in r25,__SP_H__
 2877 096e 0896      		adiw r24,8
 2878 0970 8DBF      		out __SP_L__,r24
 2879 0972 9EBF      		out __SP_H__,r25
 2880 0974 CA15      		cp r28,r10
 2881 0976 DB05      		cpc r29,r11
 2882 0978 01F0      		breq .+2
 2883 097a 00C0      		rjmp .L170
 2884 097c 00C0      		rjmp .L169
 2885               	.L179:
 2886               	/* epilogue start */
 572:../../Lib/ramdysk.c **** }
 2888               	.LM297:
 2889 097e DF91      		pop r29
 2890 0980 CF91      		pop r28
 2891 0982 1F91      		pop r17
 2892 0984 0F91      		pop r16
 2893 0986 FF90      		pop r15
 2894 0988 EF90      		pop r14
 2895 098a DF90      		pop r13
 2896 098c CF90      		pop r12
 2897 098e BF90      		pop r11
 2898 0990 AF90      		pop r10
 2899 0992 9F90      		pop r9
 2900 0994 8F90      		pop r8
 2901 0996 7F90      		pop r7
 2902 0998 6F90      		pop r6
 2903 099a 5F90      		pop r5
 2904 099c 4F90      		pop r4
 2905 099e 0895      		ret
 2910               	.Lscope21:
 2912               		.stabd	78,0,0
 2914               	.global	ramDyskLiczbaWolnychKlastrow
 2916               	ramDyskLiczbaWolnychKlastrow:
 2917               		.stabd	46,0,0
 575:../../Lib/ramdysk.c **** {
 2919               	.LM298:
 2920               	.LFBB22:
 2921               	/* prologue: function */
 2922               	/* frame size = 0 */
 2923               	/* stack size = 0 */
 2924               	.L__stack_usage = 0
 2925 09a0 E0E0      		ldi r30,lo8(klastry+128)
 2926 09a2 F0E0      		ldi r31,hi8(klastry+128)
 576:../../Lib/ramdysk.c ****   uint8_t wynik=0;
 2928               	.LM299:
 2929 09a4 80E0      		ldi r24,0
 2930               	.L183:
 579:../../Lib/ramdysk.c ****     if (klastry[temp] == 0)
 2932               	.LM300:
 2933 09a6 9291      		ld r25,-Z
 2934 09a8 9111      		cpse r25,__zero_reg__
 2935 09aa 00C0      		rjmp .L181
 580:../../Lib/ramdysk.c ****       wynik++;
 2937               	.LM301:
 2938 09ac 8F5F      		subi r24,lo8(-(1))
 2939               	.L181:
 578:../../Lib/ramdysk.c ****   for (temp = L_KLASTROW-1; temp > 0; temp--)
 2941               	.LM302:
 2942 09ae 90E0      		ldi r25,hi8(klastry+1)
 2943 09b0 E030      		cpi r30,lo8(klastry+1)
 2944 09b2 F907      		cpc r31,r25
 2945 09b4 01F4      		brne .L183
 2946               	/* epilogue start */
 582:../../Lib/ramdysk.c **** }
 2948               	.LM303:
 2949 09b6 0895      		ret
 2954               	.Lscope22:
 2956               		.stabd	78,0,0
 2962               	.global	ramDyskOtworzPlikStdIo
 2964               	ramDyskOtworzPlikStdIo:
 2965               		.stabd	46,0,0
 600:../../Lib/ramdysk.c **** 
 601:../../Lib/ramdysk.c **** uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags
 602:../../Lib/ramdysk.c **** {
 2967               	.LM304:
 2968               	.LFBB23:
 2969 09b8 EF92      		push r14
 2970 09ba FF92      		push r15
 2971 09bc 0F93      		push r16
 2972 09be 1F93      		push r17
 2973 09c0 CF93      		push r28
 2974 09c2 DF93      		push r29
 2975 09c4 1F92      		push __zero_reg__
 2976 09c6 CDB7      		in r28,__SP_L__
 2977 09c8 DEB7      		in r29,__SP_H__
 2978               	/* prologue: function */
 2979               	/* frame size = 1 */
 2980               	/* stack size = 7 */
 2981               	.L__stack_usage = 7
 2982 09ca 8B01      		movw r16,r22
 2983 09cc 7A01      		movw r14,r20
 603:../../Lib/ramdysk.c ****   uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
 2985               	.LM305:
 2986 09ce 2983      		std Y+1,r18
 2987 09d0 0E94 0000 		call ramDyskOtworzPlik
 604:../../Lib/ramdysk.c ****   if (wynik != 0)
 2989               	.LM306:
 2990 09d4 2981      		ldd r18,Y+1
 2991 09d6 8111      		cpse r24,__zero_reg__
 2992 09d8 00C0      		rjmp .L185
 605:../../Lib/ramdysk.c ****     return wynik;
 606:../../Lib/ramdysk.c ****   
 607:../../Lib/ramdysk.c ****   fdev_setup_stream(stream, putSTD, getSTD, flags);
 2994               	.LM307:
 2995 09da 40E0      		ldi r20,lo8(gs(putSTD))
 2996 09dc 50E0      		ldi r21,hi8(gs(putSTD))
 2997 09de F701      		movw r30,r14
 2998 09e0 4087      		std Z+8,r20
 2999 09e2 5187      		std Z+9,r21
 3000 09e4 40E0      		ldi r20,lo8(gs(getSTD))
 3001 09e6 50E0      		ldi r21,hi8(gs(getSTD))
 3002 09e8 4287      		std Z+10,r20
 3003 09ea 5387      		std Z+11,r21
 3004 09ec 2383      		std Z+3,r18
 608:../../Lib/ramdysk.c ****   fdev_set_udata(stream, fd);
 3006               	.LM308:
 3007 09ee 0487      		std Z+12,r16
 3008 09f0 1587      		std Z+13,r17
 3009               	.L185:
 3010               	/* epilogue start */
 609:../../Lib/ramdysk.c ****   return 0;
 610:../../Lib/ramdysk.c **** }
 3012               	.LM309:
 3013 09f2 0F90      		pop __tmp_reg__
 3014 09f4 DF91      		pop r29
 3015 09f6 CF91      		pop r28
 3016 09f8 1F91      		pop r17
 3017 09fa 0F91      		pop r16
 3018 09fc FF90      		pop r15
 3019 09fe EF90      		pop r14
 3020 0a00 0895      		ret
 3025               	.Lscope23:
 3027               		.stabd	78,0,0
 3030               	.global	ramDyskZamknijPlikStdIo
 3032               	ramDyskZamknijPlikStdIo:
 3033               		.stabd	46,0,0
 611:../../Lib/ramdysk.c **** 
 612:../../Lib/ramdysk.c **** uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
 613:../../Lib/ramdysk.c **** {
 3035               	.LM310:
 3036               	.LFBB24:
 3037 0a02 0F93      		push r16
 3038 0a04 1F93      		push r17
 3039 0a06 CF93      		push r28
 3040 0a08 DF93      		push r29
 3041               	/* prologue: function */
 3042               	/* frame size = 0 */
 3043               	/* stack size = 4 */
 3044               	.L__stack_usage = 4
 3045 0a0a 8C01      		movw r16,r24
 614:../../Lib/ramdysk.c ****   struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
 3047               	.LM311:
 3048 0a0c FC01      		movw r30,r24
 3049 0a0e C485      		ldd r28,Z+12
 3050 0a10 D585      		ldd r29,Z+13
 615:../../Lib/ramdysk.c ****   ramDyskZamknijPlik(fd);
 3052               	.LM312:
 3053 0a12 CE01      		movw r24,r28
 3054 0a14 0E94 0000 		call ramDyskZamknijPlik
 616:../../Lib/ramdysk.c ****   fclose(stream);
 3056               	.LM313:
 3057 0a18 C801      		movw r24,r16
 3058 0a1a 0E94 0000 		call fclose
 617:../../Lib/ramdysk.c ****   return fd->wpis->lAktOtw;
 3060               	.LM314:
 3061 0a1e EC81      		ldd r30,Y+4
 3062 0a20 FD81      		ldd r31,Y+5
 618:../../Lib/ramdysk.c **** }
 3064               	.LM315:
 3065 0a22 8381      		ldd r24,Z+3
 3066               	/* epilogue start */
 3067 0a24 DF91      		pop r29
 3068 0a26 CF91      		pop r28
 3069 0a28 1F91      		pop r17
 3070 0a2a 0F91      		pop r16
 3071 0a2c 0895      		ret
 3076               	.Lscope24:
 3078               		.stabd	78,0,0
 3079               		.comm	klastry,128,1
 3080               		.comm	czasRtc,7,1
 3081               		.comm	rollers,2,1
 3082               		.comm	sockets,2,1
 3083               		.comm	tcpDebugLevel,1,1
 3084               		.comm	tcpDebugStream,2,1
 3085               		.comm	IpMyConfig,15,1
 3086               		.comm	udpDbgLevel,1,1
 3087               		.comm	udpDbgStream,2,1
 3088               		.comm	udpSocket,2,1
 3089               		.comm	icmpDebugLevel,1,1
 3090               		.comm	icmpDebug,2,1
 3091               		.comm	arpDebugLevel,1,1
 3092               		.comm	arpDebug,2,1
 3093               		.comm	plen,2,1
 3094               		.comm	nicState,14,1
 3095               		.comm	xSemaphoreRs485,2,1
 3096               		.comm	lockSensors,2,1
 3097               		.comm	portB,1,1
 3098               		.comm	portA,1,1
 3099               		.comm	xSemaphoreSpiSS,2,1
 3100               		.comm	wwwport,1,1
 3124               	.Letext0:
 3125               		.ident	"GCC: (GNU) 4.8.2"
 3126               	.global __do_copy_data
 3127               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ramdysk.c
     /tmp/cc9u7ZDc.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc9u7ZDc.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc9u7ZDc.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc9u7ZDc.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc9u7ZDc.s:6      *ABS*:000000000000003a __RAMPY__
     /tmp/cc9u7ZDc.s:7      *ABS*:0000000000000039 __RAMPX__
     /tmp/cc9u7ZDc.s:8      *ABS*:0000000000000038 __RAMPD__
     /tmp/cc9u7ZDc.s:9      *ABS*:0000000000000034 __CCP__
     /tmp/cc9u7ZDc.s:10     *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9u7ZDc.s:11     *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9u7ZDc.s:599    .text:0000000000000000 uaktualnijRozmiarPliku
     /tmp/cc9u7ZDc.s:663    .text:0000000000000044 nastepnyKlaster
                            *COM*:0000000000000080 klastry
     /tmp/cc9u7ZDc.s:746    .text:0000000000000090 znajdzKlasterN
     /tmp/cc9u7ZDc.s:801    .text:00000000000000bc znajdzPlik
     /tmp/cc9u7ZDc.s:960    .text:0000000000000176 znajdzWolnyKlaster
     /tmp/cc9u7ZDc.s:1029   .text:00000000000001b6 ramDyskInit
     /tmp/cc9u7ZDc.s:1070   .text:00000000000001da ramDyskUtworzPlik
     /tmp/cc9u7ZDc.s:1249   .text:000000000000029a ramDyskOtworzPlik
     /tmp/cc9u7ZDc.s:1308   .text:00000000000002c6 ramDyskUsunPlik
     /tmp/cc9u7ZDc.s:1392   .text:000000000000030a ramDyskZamknijPlik
     /tmp/cc9u7ZDc.s:1433   .text:000000000000032a ramDyskCzyscPlik
     /tmp/cc9u7ZDc.s:1517   .text:000000000000037c ramDyskZapiszBajtDoPliku
     /tmp/cc9u7ZDc.s:1635   .text:00000000000003f8 putSTD
     /tmp/cc9u7ZDc.s:1664   .text:0000000000000408 ramDyskCzytajBajtZPliku
     /tmp/cc9u7ZDc.s:1777   .text:0000000000000478 getSTD
     /tmp/cc9u7ZDc.s:1833   .text:00000000000004a8 ramDyskZapiszBlokDoPliku
     /tmp/cc9u7ZDc.s:2059   .text:00000000000005bc ramDyskCzytajBlokZPliku
     /tmp/cc9u7ZDc.s:2332   .text:00000000000006fa ramDyskUstawWskaznik
     /tmp/cc9u7ZDc.s:2461   .text:0000000000000784 ramDyskUstawWskaznikNaKoniec
     /tmp/cc9u7ZDc.s:2537   .text:00000000000007c8 ramDyskDodajBlokXmodem
     /tmp/cc9u7ZDc.s:2707   .text:000000000000087c ramDyskDir
     /tmp/cc9u7ZDc.s:2916   .text:00000000000009a0 ramDyskLiczbaWolnychKlastrow
     /tmp/cc9u7ZDc.s:2964   .text:00000000000009b8 ramDyskOtworzPlikStdIo
     /tmp/cc9u7ZDc.s:3032   .text:0000000000000a02 ramDyskZamknijPlikStdIo
                            *COM*:0000000000000007 czasRtc
                            *COM*:0000000000000002 rollers
                            *COM*:0000000000000002 sockets
                            *COM*:0000000000000001 tcpDebugLevel
                            *COM*:0000000000000002 tcpDebugStream
                            *COM*:000000000000000f IpMyConfig
                            *COM*:0000000000000001 udpDbgLevel
                            *COM*:0000000000000002 udpDbgStream
                            *COM*:0000000000000002 udpSocket
                            *COM*:0000000000000001 icmpDebugLevel
                            *COM*:0000000000000002 icmpDebug
                            *COM*:0000000000000001 arpDebugLevel
                            *COM*:0000000000000002 arpDebug
                            *COM*:0000000000000002 plen
                            *COM*:000000000000000e nicState
                            *COM*:0000000000000002 xSemaphoreRs485
                            *COM*:0000000000000002 lockSensors
                            *COM*:0000000000000001 portB
                            *COM*:0000000000000001 portA
                            *COM*:0000000000000002 xSemaphoreSpiSS
                            *COM*:0000000000000001 wwwport

UNDEFINED SYMBOLS
strncmp
strncpy
memcpy
fputs
fputc
fprintf
fclose
__do_copy_data
__do_clear_bss
