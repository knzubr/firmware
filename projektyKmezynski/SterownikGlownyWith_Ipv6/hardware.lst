   1               		.file	"hardware.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 278               		.weak	spiSendSpinBlock
 280               	spiSendSpinBlock:
 281               		.stabd	46,0,0
   1:hardware.c    **** #include "hardware.h"
   2:hardware.c    **** 
   3:hardware.c    **** #if LANG_EN
   4:hardware.c    **** #include "hardware_en.h"
   5:hardware.c    **** #endif
   6:hardware.c    **** 
   7:hardware.c    **** #if LANG_PL
   8:hardware.c    **** #include "hardware_pl.h"
   9:hardware.c    **** #endif
  10:hardware.c    **** 
  11:hardware.c    **** xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisjÄ™ d
  12:hardware.c    **** 
  13:hardware.c    **** void hardwareInit(void)
  14:hardware.c    **** {
  15:hardware.c    ****   //DDRA = 0x00;  //External Memory
  16:hardware.c    ****   portENTER_CRITICAL();
  17:hardware.c    ****   xSpiRx          = xQueueCreate(1, 1);
  18:hardware.c    ****   portEXIT_CRITICAL();
  19:hardware.c    **** 
  20:hardware.c    ****   DDRB = 0xF7;
  21:hardware.c    ****   PORTB = 0xD1;
  22:hardware.c    ****   /*
  23:hardware.c    ****    0 - Sl_RST
  24:hardware.c    ****    1 - SCK
  25:hardware.c    ****    2 - MOSI
  26:hardware.c    ****    3 - MISO
  27:hardware.c    ****    4 - External SPI ASR 4
  28:hardware.c    ****    5 - External SPI ASR 5 (DS1305)     0 - off; 1 - on 
  29:hardware.c    ****    6 - External SPI ASR 6 (MCP3008)    0 - on;  1 - off
  30:hardware.c    ****    7 - External SPI ASR 7 (MPC23S17)   0 - on;  1 - off
  31:hardware.c    ****   */
  32:hardware.c    ****   
  33:hardware.c    ****   //DDRC = 0x00;  //External Memory
  34:hardware.c    **** 
  35:hardware.c    ****   DDRD = 0x00;
  36:hardware.c    ****   /*
  37:hardware.c    ****    0 - SCL
  38:hardware.c    ****    1 - SDA
  39:hardware.c    ****    2 - RxD USB
  40:hardware.c    ****    3 - TxD USB
  41:hardware.c    ****    4 - External SPI ASR 0
  42:hardware.c    ****    5 - External SPI ASR 1
  43:hardware.c    ****    6 - External SPI ASR 2
  44:hardware.c    ****    7 - External SPI ASR 3
  45:hardware.c    ****    */
  46:hardware.c    **** 
  47:hardware.c    ****   DDRE  = 0x0E;
  48:hardware.c    ****   PORTE = 0x0C;
  49:hardware.c    ****   /*
  50:hardware.c    ****    0 - RxD Rs485
  51:hardware.c    ****    1 - TxD Rs485
  52:hardware.c    ****    2 - ENC RST
  53:hardware.c    ****    3 - ENC CS
  54:hardware.c    ****    4 - INT 4
  55:hardware.c    ****    5 - INT 5
  56:hardware.c    ****    6 - INT 6
  57:hardware.c    ****    7 - INT Enc28j60
  58:hardware.c    ****   */
  59:hardware.c    ****   DDRF = 0x00;    //JTAG and A/C
  60:hardware.c    ****   DDRG = 0x1F;
  61:hardware.c    ****   /*
  62:hardware.c    ****    0 - WR
  63:hardware.c    ****    1 - RD
  64:hardware.c    ****    2 - ALE
  65:hardware.c    ****    3 - SD CS
  66:hardware.c    ****    4 - RS485 TxEn
  67:hardware.c    ****    5 - 
  68:hardware.c    ****    6 - 
  69:hardware.c    ****    7 - 
  70:hardware.c    ****    */
  71:hardware.c    **** }
  72:hardware.c    **** 
  73:hardware.c    **** void LockersMemInit(void)
  74:hardware.c    **** {
  75:hardware.c    ****   lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
  76:hardware.c    **** }
  77:hardware.c    **** 
  78:hardware.c    **** uint8_t printLockers(FILE *stream)
  79:hardware.c    **** {
  80:hardware.c    ****   uint8_t i;
  81:hardware.c    ****   uint8_t result = 0;
  82:hardware.c    ****   struct lockerSensor *tmpLock = lockSensors;
  83:hardware.c    ****   for (i=1; i<=4; i++)
  84:hardware.c    ****   {
  85:hardware.c    ****     if (tmpLock->enabled)
  86:hardware.c    ****     {
  87:hardware.c    ****       fprintf_P(stream, statusLockerSensDescStr, i);
  88:hardware.c    ****       if (tmpLock->threshold > tmpLock->acVal)
  89:hardware.c    ****         fprintf_P(stream, statusLockerOpenStr);
  90:hardware.c    ****       else
  91:hardware.c    ****         fprintf_P(stream, statusLockerCloseStr);
  92:hardware.c    ****       fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
  93:hardware.c    ****       result++;
  94:hardware.c    ****     }
  95:hardware.c    ****     tmpLock++;
  96:hardware.c    ****   }
  97:hardware.c    ****   return result;
  98:hardware.c    **** }
  99:hardware.c    **** 
 100:hardware.c    **** void checkLockerSensors(void)
 101:hardware.c    **** {
 102:hardware.c    ****   if (lockSensors[0].enabled)
 103:hardware.c    ****   {
 104:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
 105:hardware.c    ****     vTaskDelay(30);
 106:hardware.c    ****     lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
 107:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
 108:hardware.c    ****     lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
 109:hardware.c    ****     vTaskDelay(10);
 110:hardware.c    ****   }
 111:hardware.c    ****   
 112:hardware.c    ****   if (lockSensors[1].enabled)
 113:hardware.c    ****   {
 114:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
 115:hardware.c    ****     vTaskDelay(30);
 116:hardware.c    ****     lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
 117:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
 118:hardware.c    ****     lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
 119:hardware.c    ****     vTaskDelay(10);
 120:hardware.c    ****   }
 121:hardware.c    ****   
 122:hardware.c    ****   if (lockSensors[2].enabled)
 123:hardware.c    ****   {
 124:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
 125:hardware.c    ****     vTaskDelay(30);
 126:hardware.c    ****     lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
 127:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
 128:hardware.c    ****     lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
 129:hardware.c    ****     vTaskDelay(10);
 130:hardware.c    ****   }
 131:hardware.c    ****   
 132:hardware.c    ****   if (lockSensors[3].enabled)
 133:hardware.c    ****   {
 134:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
 135:hardware.c    ****     vTaskDelay(30);
 136:hardware.c    ****     lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
 137:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
 138:hardware.c    ****     lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
 139:hardware.c    ****     vTaskDelay(10);
 140:hardware.c    ****   }
 141:hardware.c    **** }
 142:hardware.c    **** 
 143:hardware.c    **** 
 144:hardware.c    **** uint8_t spiSend(uint8_t data)
 145:hardware.c    **** {
 146:hardware.c    ****   uint8_t result;
 147:hardware.c    ****   SPDR = data;
 148:hardware.c    ****   xQueueReceive(xSpiRx, &result, 10); 
 149:hardware.c    ****   return result;
 150:hardware.c    **** }
 151:hardware.c    **** 
 152:hardware.c    **** uint8_t spiSendSpinBlock(uint8_t data)
 153:hardware.c    **** {
 283               	.LM0:
 284               	.LFBB1:
 285               	/* prologue: function */
 286               	/* frame size = 0 */
 154:hardware.c    ****   SPDR = data;
 288               	.LM1:
 289 0000 8FB9      		out 47-32,r24
 155:hardware.c    ****   SPCR &= ~(1<<SPIE);                //Disable SPI interrupt
 291               	.LM2:
 292 0002 6F98      		cbi 45-32,7
 293               	.L2:
 156:hardware.c    ****   while(!(SPSR&(1<<SPIF)));
 295               	.LM3:
 296 0004 779B      		sbis 46-32,7
 297 0006 00C0      		rjmp .L2
 157:hardware.c    ****   data = SPSR;                       //Clearing interrupt flag
 299               	.LM4:
 300 0008 8EB1      		in r24,46-32
 158:hardware.c    ****   data = SPDR;                       //Resfing DPI buffer register
 302               	.LM5:
 303 000a 8FB1      		in r24,47-32
 159:hardware.c    ****   SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
 305               	.LM6:
 306 000c 6F9A      		sbi 45-32,7
 307               	/* epilogue start */
 160:hardware.c    ****   return data;                     
 161:hardware.c    **** }
 309               	.LM7:
 310 000e 0895      		ret
 312               	.Lscope1:
 314               		.stabd	78,0,0
 316               	.global	disableAllSpiDevices
 318               	disableAllSpiDevices:
 319               		.stabd	46,0,0
 162:hardware.c    **** 
 163:hardware.c    **** void disableAllSpiDevices(void)
 164:hardware.c    **** { 
 321               	.LM8:
 322               	.LFBB2:
 323               	/* prologue: function */
 324               	/* frame size = 0 */
 165:hardware.c    **** #if disableSpiPORTA_OR != 0
 166:hardware.c    **** #error Port A is memory bus
 167:hardware.c    ****   PORTA |= disableSpiPORTA_OR;
 168:hardware.c    **** #endif
 169:hardware.c    **** #if disableSpiPORTA_AND != 0xFF
 170:hardware.c    **** #error Port A is memory bus
 171:hardware.c    ****   PORTA &= disableSpiPORTA_AND;
 172:hardware.c    **** #endif
 173:hardware.c    **** 
 174:hardware.c    **** #if disableSpiPORTB_OR != 0
 175:hardware.c    ****   PORTB |= disableSpiPORTB_OR;
 326               	.LM9:
 327 0010 88B3      		in r24,56-32
 328 0012 806C      		ori r24,lo8(-64)
 329 0014 88BB      		out 56-32,r24
 176:hardware.c    **** #endif
 177:hardware.c    **** #if disableSpiPORTB_AND != 0xFF
 178:hardware.c    ****   PORTB &= disableSpiPORTB_AND;
 331               	.LM10:
 332 0016 C598      		cbi 56-32,5
 179:hardware.c    **** #endif
 180:hardware.c    **** 
 181:hardware.c    **** #if disableSpiPORTC_OR != 0
 182:hardware.c    **** #error Port C is memory bus
 183:hardware.c    ****   PORTC |= disableSpiPORTC_OR;
 184:hardware.c    **** #endif
 185:hardware.c    **** #if disableSpiPORTC_AND != 0xFF
 186:hardware.c    **** #error Port C is memory bus
 187:hardware.c    ****   PORTC &= disableSpiPORTC_AND;
 188:hardware.c    **** #endif
 189:hardware.c    **** 
 190:hardware.c    **** #if disableSpiPORTD_OR != 0
 191:hardware.c    ****   PORTD |= disableSpiPORTD_OR;
 192:hardware.c    **** #endif
 193:hardware.c    **** #if disableSpiPORTD_AND != 0xFF
 194:hardware.c    ****   PORTD &= disableSpiPORTD_AND;
 195:hardware.c    **** #endif
 196:hardware.c    **** #if disableSpiPORTE_OR != 0
 197:hardware.c    ****   PORTE |= disableSpiPORTE_OR;
 334               	.LM11:
 335 0018 1B9A      		sbi 35-32,3
 198:hardware.c    **** #endif
 199:hardware.c    **** #if disableSpiPORTE_AND != 0xFF
 200:hardware.c    ****   PORTE &= disableSpiPORTE_AND;
 201:hardware.c    **** #endif
 202:hardware.c    **** 
 203:hardware.c    **** #if disableSpiPORTF_OR != 0
 204:hardware.c    ****   PORTF |= disableSpiPORTF_OR;
 205:hardware.c    **** #endif
 206:hardware.c    **** #if disableSpiPORTF_AND != 0xFF
 207:hardware.c    ****   PORTF &= disableSpiPORTF_AND;
 208:hardware.c    **** #endif
 209:hardware.c    **** 
 210:hardware.c    **** #if disableSpiPORTG_OR != 0
 211:hardware.c    ****   PORTG |= disableSpiPORTG_OR;
 337               	.LM12:
 338 001a E5E6      		ldi r30,lo8(101)
 339 001c F0E0      		ldi r31,hi8(101)
 340 001e 8081      		ld r24,Z
 341 0020 8860      		ori r24,lo8(8)
 342 0022 8083      		st Z,r24
 343               	/* epilogue start */
 212:hardware.c    **** #endif
 213:hardware.c    **** #if disableSpiPORTG_AND != 0xFF
 214:hardware.c    ****   PORTG &= disableSpiPORTG_AND;
 215:hardware.c    **** #endif
 216:hardware.c    **** }
 345               	.LM13:
 346 0024 0895      		ret
 348               	.Lscope2:
 350               		.stabd	78,0,0
 352               		.weak	spiEnableEnc28j60
 354               	spiEnableEnc28j60:
 355               		.stabd	46,0,0
 217:hardware.c    **** 
 218:hardware.c    **** void spiEnableEnc28j60(void)
 219:hardware.c    **** {
 357               	.LM14:
 358               	.LFBB3:
 359               	/* prologue: function */
 360               	/* frame size = 0 */
 220:hardware.c    **** #if ENC_SPI_CS_EN_MASK_OR != 0
 221:hardware.c    ****   ENC_SPI_CS_PORT |= ENC_SPI_CS_EN_MASK_OR;
 222:hardware.c    **** #endif
 223:hardware.c    **** #if ENC_SPI_CS_EN_MASK_AND != 0xFF
 224:hardware.c    ****   ENC_SPI_CS_PORT &= ENC_SPI_CS_EN_MASK_AND;
 362               	.LM15:
 363 0026 1B98      		cbi 35-32,3
 364               	/* epilogue start */
 225:hardware.c    **** #endif
 226:hardware.c    **** }
 366               	.LM16:
 367 0028 0895      		ret
 369               	.Lscope3:
 371               		.stabd	78,0,0
 373               		.weak	spiDisableEnc28j60
 375               	spiDisableEnc28j60:
 376               		.stabd	46,0,0
 227:hardware.c    **** 
 228:hardware.c    **** void spiDisableEnc28j60(void)
 229:hardware.c    **** {
 378               	.LM17:
 379               	.LFBB4:
 380               	/* prologue: function */
 381               	/* frame size = 0 */
 230:hardware.c    **** #if ENC_SPI_CS_EN_MASK_OR != 0
 231:hardware.c    ****   ENC_SPI_CS_PORT &= (~ENC_SPI_CS_EN_MASK_OR);
 232:hardware.c    **** #endif
 233:hardware.c    **** #if ENC_SPI_CS_EN_MASK_AND != 0xFF
 234:hardware.c    ****   ENC_SPI_CS_PORT |= (~ENC_SPI_CS_EN_MASK_AND);
 383               	.LM18:
 384 002a 1B9A      		sbi 35-32,3
 385               	/* epilogue start */
 235:hardware.c    **** #endif
 236:hardware.c    **** }
 387               	.LM19:
 388 002c 0895      		ret
 390               	.Lscope4:
 392               		.stabd	78,0,0
 394               	.global	enableSpiSd
 396               	enableSpiSd:
 397               		.stabd	46,0,0
 237:hardware.c    **** 
 238:hardware.c    **** void enableSpiSd(void)
 239:hardware.c    **** {
 399               	.LM20:
 400               	.LFBB5:
 401               	/* prologue: function */
 402               	/* frame size = 0 */
 240:hardware.c    **** #if SD_SPI_CS_EN_MASK_OR != 0
 241:hardware.c    ****   SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
 242:hardware.c    **** #endif
 243:hardware.c    **** #if SD_SPI_CS_EN_MASK_AND != 0xFF
 244:hardware.c    ****   SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
 404               	.LM21:
 405 002e E5E6      		ldi r30,lo8(101)
 406 0030 F0E0      		ldi r31,hi8(101)
 407 0032 8081      		ld r24,Z
 408 0034 877F      		andi r24,lo8(-9)
 409 0036 8083      		st Z,r24
 410               	/* epilogue start */
 245:hardware.c    **** #endif   
 246:hardware.c    **** }
 412               	.LM22:
 413 0038 0895      		ret
 415               	.Lscope5:
 417               		.stabd	78,0,0
 419               	.global	disableSpiSd
 421               	disableSpiSd:
 422               		.stabd	46,0,0
 247:hardware.c    **** 
 248:hardware.c    **** void disableSpiSd(void)
 249:hardware.c    **** {
 424               	.LM23:
 425               	.LFBB6:
 426               	/* prologue: function */
 427               	/* frame size = 0 */
 250:hardware.c    **** #if SD_SPI_CS_EN_MASK_OR != 0
 251:hardware.c    ****   SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
 252:hardware.c    **** #endif
 253:hardware.c    **** #if SD_SPI_CS_EN_MASK_AND != 0xFF
 254:hardware.c    ****   SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
 429               	.LM24:
 430 003a E5E6      		ldi r30,lo8(101)
 431 003c F0E0      		ldi r31,hi8(101)
 432 003e 8081      		ld r24,Z
 433 0040 8860      		ori r24,lo8(8)
 434 0042 8083      		st Z,r24
 435               	/* epilogue start */
 255:hardware.c    **** #endif  
 256:hardware.c    **** }
 437               	.LM25:
 438 0044 0895      		ret
 440               	.Lscope6:
 442               		.stabd	78,0,0
 444               		.weak	enableSpiMPC23S17
 446               	enableSpiMPC23S17:
 447               		.stabd	46,0,0
 257:hardware.c    **** 
 258:hardware.c    **** void enableSpiMPC23S17(void)
 259:hardware.c    **** {
 449               	.LM26:
 450               	.LFBB7:
 451               	/* prologue: function */
 452               	/* frame size = 0 */
 260:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_OR != 0
 261:hardware.c    ****   MCP23S17_SPI_CS_PORT |= MCP23S17_SPI_CS_EN_MASK_OR;
 262:hardware.c    **** #endif
 263:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_AND != 0xFF
 264:hardware.c    ****   MPC23S17_SPI_CS_PORT &= MPC23S17_SPI_CS_EN_MASK_AND;
 454               	.LM27:
 455 0046 C798      		cbi 56-32,7
 456               	/* epilogue start */
 265:hardware.c    **** #endif
 266:hardware.c    **** }
 458               	.LM28:
 459 0048 0895      		ret
 461               	.Lscope7:
 463               		.stabd	78,0,0
 465               		.weak	disableSpiMPC23S17
 467               	disableSpiMPC23S17:
 468               		.stabd	46,0,0
 267:hardware.c    **** 
 268:hardware.c    **** void disableSpiMPC23S17(void)
 269:hardware.c    **** {
 470               	.LM29:
 471               	.LFBB8:
 472               	/* prologue: function */
 473               	/* frame size = 0 */
 270:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_OR != 0
 271:hardware.c    ****   MCP23S17_SPI_CS_PORT &= (~MCP23S17_SPI_CS_EN_MASK_OR);
 272:hardware.c    **** #endif
 273:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_AND != 0xFF
 274:hardware.c    ****   MPC23S17_SPI_CS_PORT |= (~MPC23S17_SPI_CS_EN_MASK_AND);
 475               	.LM30:
 476 004a C79A      		sbi 56-32,7
 477               	/* epilogue start */
 275:hardware.c    **** #endif
 276:hardware.c    **** }
 479               	.LM31:
 480 004c 0895      		ret
 482               	.Lscope8:
 484               		.stabd	78,0,0
 486               		.weak	enableSpiMCP3008
 488               	enableSpiMCP3008:
 489               		.stabd	46,0,0
 277:hardware.c    **** 
 278:hardware.c    **** #define MCP3008_SPCR_OR_MASK ((1<<SPR1)|(1<<SPR0))
 279:hardware.c    **** void enableSpiMCP3008(void)
 280:hardware.c    **** {
 491               	.LM32:
 492               	.LFBB9:
 493               	/* prologue: function */
 494               	/* frame size = 0 */
 281:hardware.c    ****   SPCR |= MCP3008_SPCR_OR_MASK;
 496               	.LM33:
 497 004e 8DB1      		in r24,45-32
 498 0050 8360      		ori r24,lo8(3)
 499 0052 8DB9      		out 45-32,r24
 282:hardware.c    **** #if MCP3008_SPI_CS_EN_MASK_OR != 0
 283:hardware.c    ****   MCP3008_SPI_CS_PORT |= MCP3008_SPI_CS_EN_MASK_OR;
 284:hardware.c    **** #endif
 285:hardware.c    **** #if MCP3008_SPI_CS_EN_MASK_AND != 0xFF
 286:hardware.c    ****   MCP3008_SPI_CS_PORT &= MCP3008_SPI_CS_EN_MASK_AND;
 501               	.LM34:
 502 0054 C698      		cbi 56-32,6
 503               	/* epilogue start */
 287:hardware.c    **** #endif  
 288:hardware.c    **** 
 289:hardware.c    **** }
 505               	.LM35:
 506 0056 0895      		ret
 508               	.Lscope9:
 510               		.stabd	78,0,0
 512               		.weak	disableSpiMCP3008
 514               	disableSpiMCP3008:
 515               		.stabd	46,0,0
 290:hardware.c    **** 
 291:hardware.c    **** void disableSpiMCP3008(void)
 292:hardware.c    **** {
 517               	.LM36:
 518               	.LFBB10:
 519               	/* prologue: function */
 520               	/* frame size = 0 */
 293:hardware.c    ****   SPCR &= ~MCP3008_SPCR_OR_MASK;
 522               	.LM37:
 523 0058 8DB1      		in r24,45-32
 524 005a 8C7F      		andi r24,lo8(-4)
 525 005c 8DB9      		out 45-32,r24
 294:hardware.c    ****   #if MCP3008_SPI_CS_EN_MASK_OR != 0
 295:hardware.c    ****   MCP3008_SPI_CS_PORT &= (~MCP3008_SPI_CS_EN_MASK_OR);
 296:hardware.c    **** #endif
 297:hardware.c    **** #if MCP3008_SPI_CS_EN_MASK_AND != 0xFF
 298:hardware.c    ****   MCP3008_SPI_CS_PORT |= (~MCP3008_SPI_CS_EN_MASK_AND);
 527               	.LM38:
 528 005e C69A      		sbi 56-32,6
 529               	/* epilogue start */
 299:hardware.c    **** #endif
 300:hardware.c    **** }
 531               	.LM39:
 532 0060 0895      		ret
 534               	.Lscope10:
 536               		.stabd	78,0,0
 538               	.global	enableSpiMCP4150
 540               	enableSpiMCP4150:
 541               		.stabd	46,0,0
 301:hardware.c    **** 
 302:hardware.c    **** 
 303:hardware.c    **** #define MCP4150_SPCR_OR_MASK ((1<<SPR1)|(1<<SPR0))
 304:hardware.c    **** void enableSpiMCP4150(void)
 305:hardware.c    **** {
 543               	.LM40:
 544               	.LFBB11:
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 306:hardware.c    ****   SPCR |= MCP4150_SPCR_OR_MASK;
 548               	.LM41:
 549 0062 8DB1      		in r24,45-32
 550 0064 8360      		ori r24,lo8(3)
 551 0066 8DB9      		out 45-32,r24
 307:hardware.c    **** #if MCP4150_SPI_CS_EN_MASK_OR != 0
 308:hardware.c    ****   MCP4150_SPI_CS_PORT |= MCP4150_SPI_CS_EN_MASK_OR;
 309:hardware.c    **** #endif
 310:hardware.c    **** #if MCP4150_SPI_CS_EN_MASK_AND != 0xFF
 311:hardware.c    ****   MCP4150_SPI_CS_PORT &= MCP4150_SPI_CS_EN_MASK_AND;
 553               	.LM42:
 554 0068 C698      		cbi 56-32,6
 555               	/* epilogue start */
 312:hardware.c    **** #endif  
 313:hardware.c    **** }
 557               	.LM43:
 558 006a 0895      		ret
 560               	.Lscope11:
 562               		.stabd	78,0,0
 564               	.global	disableSpiMCP4150
 566               	disableSpiMCP4150:
 567               		.stabd	46,0,0
 314:hardware.c    **** void disableSpiMCP4150(void) 
 315:hardware.c    **** {
 569               	.LM44:
 570               	.LFBB12:
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 316:hardware.c    ****   SPCR &= ~MCP4150_SPCR_OR_MASK;
 574               	.LM45:
 575 006c 8DB1      		in r24,45-32
 576 006e 8C7F      		andi r24,lo8(-4)
 577 0070 8DB9      		out 45-32,r24
 317:hardware.c    ****   #if MCP4150_SPI_CS_EN_MASK_OR != 0
 318:hardware.c    ****   MCP4150_SPI_CS_PORT &= (~MCP4150_SPI_CS_EN_MASK_OR);
 319:hardware.c    **** #endif
 320:hardware.c    **** #if MCP4150_SPI_CS_EN_MASK_AND != 0xFF
 321:hardware.c    ****   MCP4150_SPI_CS_PORT |= (~MCP4150_SPI_CS_EN_MASK_AND);
 579               	.LM46:
 580 0072 C69A      		sbi 56-32,6
 581               	/* epilogue start */
 322:hardware.c    **** #endif  
 323:hardware.c    **** }
 583               	.LM47:
 584 0074 0895      		ret
 586               	.Lscope12:
 588               		.stabd	78,0,0
 590               		.weak	spiEnableDS1305
 592               	spiEnableDS1305:
 593               		.stabd	46,0,0
 324:hardware.c    **** 
 325:hardware.c    **** #define DS_SPCR_OR_MASK ((1<<CPHA)|(1<<SPR0))
 326:hardware.c    **** 
 327:hardware.c    **** void spiEnableDS1305(void)
 328:hardware.c    **** {
 595               	.LM48:
 596               	.LFBB13:
 597               	/* prologue: function */
 598               	/* frame size = 0 */
 329:hardware.c    ****   SPCR |= DS_SPCR_OR_MASK;
 600               	.LM49:
 601 0076 8DB1      		in r24,45-32
 602 0078 8560      		ori r24,lo8(5)
 603 007a 8DB9      		out 45-32,r24
 330:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_OR != 0
 331:hardware.c    ****   DS1305_SPI_CS_PORT |= DS1305_SPI_CS_EN_MASK_OR;
 605               	.LM50:
 606 007c C59A      		sbi 56-32,5
 607               	/* epilogue start */
 332:hardware.c    **** #endif
 333:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_AND != 0xFF
 334:hardware.c    ****   DS1305_SPI_CS_PORT &= DS1305_SPI_CS_EN_MASK_AND;
 335:hardware.c    **** #endif
 336:hardware.c    **** }
 609               	.LM51:
 610 007e 0895      		ret
 612               	.Lscope13:
 614               		.stabd	78,0,0
 616               		.weak	spiDisableDS1305
 618               	spiDisableDS1305:
 619               		.stabd	46,0,0
 337:hardware.c    **** 
 338:hardware.c    **** void spiDisableDS1305(void)
 339:hardware.c    **** {
 621               	.LM52:
 622               	.LFBB14:
 623               	/* prologue: function */
 624               	/* frame size = 0 */
 340:hardware.c    ****   SPCR &= (~(DS_SPCR_OR_MASK));
 626               	.LM53:
 627 0080 8DB1      		in r24,45-32
 628 0082 8A7F      		andi r24,lo8(-6)
 629 0084 8DB9      		out 45-32,r24
 341:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_OR != 0
 342:hardware.c    ****   DS1305_SPI_CS_PORT &= (~(DS1305_SPI_CS_EN_MASK_OR));
 631               	.LM54:
 632 0086 C598      		cbi 56-32,5
 633               	/* epilogue start */
 343:hardware.c    **** #endif
 344:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_AND != 0xFF
 345:hardware.c    ****   DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
 346:hardware.c    **** #endif  
 347:hardware.c    **** }
 635               	.LM55:
 636 0088 0895      		ret
 638               	.Lscope14:
 640               		.stabd	78,0,0
 642               	.global	__vector_17
 644               	__vector_17:
 645               		.stabd	46,0,0
 348:hardware.c    **** 
 349:hardware.c    **** ISR(SPI_STC_vect)
 350:hardware.c    **** {
 647               	.LM56:
 648               	.LFBB15:
 649 008a 1F92      		push __zero_reg__
 650 008c 0F92      		push r0
 651 008e 0FB6      		in r0,__SREG__
 652 0090 0F92      		push r0
 653 0092 0BB6      		in r0,91-32
 654 0094 0F92      		push r0
 655 0096 1124      		clr __zero_reg__
 656 0098 2F93      		push r18
 657 009a 3F93      		push r19
 658 009c 4F93      		push r20
 659 009e 5F93      		push r21
 660 00a0 6F93      		push r22
 661 00a2 7F93      		push r23
 662 00a4 8F93      		push r24
 663 00a6 9F93      		push r25
 664 00a8 AF93      		push r26
 665 00aa BF93      		push r27
 666 00ac EF93      		push r30
 667 00ae FF93      		push r31
 668               	/* prologue: Signal */
 669               	/* frame size = 0 */
 351:hardware.c    ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
 352:hardware.c    **** 
 353:hardware.c    ****   static uint8_t data;
 354:hardware.c    ****   data = SPDR;
 671               	.LM57:
 672 00b0 8FB1      		in r24,47-32
 673 00b2 8093 0000 		sts data.3312,r24
 355:hardware.c    ****   
 356:hardware.c    ****   xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
 675               	.LM58:
 676 00b6 8091 0000 		lds r24,xSpiRx
 677 00ba 9091 0000 		lds r25,(xSpiRx)+1
 678 00be 60E0      		ldi r22,lo8(data.3312)
 679 00c0 70E0      		ldi r23,hi8(data.3312)
 680 00c2 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3311)
 681 00c4 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3311)
 682 00c6 20E0      		ldi r18,lo8(0)
 683 00c8 0E94 0000 		call xQueueGenericSendFromISR
 357:hardware.c    **** 
 358:hardware.c    ****   if( xHigherPriorityTaskWoken )
 685               	.LM59:
 686 00cc 8091 0000 		lds r24,xHigherPriorityTaskWoken.3311
 687 00d0 8823      		tst r24
 688 00d2 01F0      		breq .L33
 359:hardware.c    ****   {
 360:hardware.c    ****     taskYIELD();
 690               	.LM60:
 691 00d4 0E94 0000 		call vPortYield
 692               	.L33:
 693               	/* epilogue start */
 361:hardware.c    ****   }
 362:hardware.c    ****   
 363:hardware.c    ****   //clear SPI interrupt SPI |= 1;
 364:hardware.c    **** }
 695               	.LM61:
 696 00d8 FF91      		pop r31
 697 00da EF91      		pop r30
 698 00dc BF91      		pop r27
 699 00de AF91      		pop r26
 700 00e0 9F91      		pop r25
 701 00e2 8F91      		pop r24
 702 00e4 7F91      		pop r23
 703 00e6 6F91      		pop r22
 704 00e8 5F91      		pop r21
 705 00ea 4F91      		pop r20
 706 00ec 3F91      		pop r19
 707 00ee 2F91      		pop r18
 708 00f0 0F90      		pop r0
 709 00f2 0BBE      		out 91-32,r0
 710 00f4 0F90      		pop r0
 711 00f6 0FBE      		out __SREG__,r0
 712 00f8 0F90      		pop r0
 713 00fa 1F90      		pop __zero_reg__
 714 00fc 1895      		reti
 720               	.Lscope15:
 722               		.stabd	78,0,0
 725               		.weak	spiSend
 727               	spiSend:
 728               		.stabd	46,0,0
 145:hardware.c    **** {
 730               	.LM62:
 731               	.LFBB16:
 732 00fe DF93      		push r29
 733 0100 CF93      		push r28
 734 0102 0F92      		push __tmp_reg__
 735 0104 CDB7      		in r28,__SP_L__
 736 0106 DEB7      		in r29,__SP_H__
 737               	/* prologue: function */
 738               	/* frame size = 1 */
 147:hardware.c    ****   SPDR = data;
 740               	.LM63:
 741 0108 8FB9      		out 47-32,r24
 148:hardware.c    ****   xQueueReceive(xSpiRx, &result, 10); 
 743               	.LM64:
 744 010a 8091 0000 		lds r24,xSpiRx
 745 010e 9091 0000 		lds r25,(xSpiRx)+1
 746 0112 BE01      		movw r22,r28
 747 0114 6F5F      		subi r22,lo8(-(1))
 748 0116 7F4F      		sbci r23,hi8(-(1))
 749 0118 4AE0      		ldi r20,lo8(10)
 750 011a 50E0      		ldi r21,hi8(10)
 751 011c 20E0      		ldi r18,lo8(0)
 752 011e 0E94 0000 		call xQueueGenericReceive
 150:hardware.c    **** }
 754               	.LM65:
 755 0122 8981      		ldd r24,Y+1
 756               	/* epilogue start */
 757 0124 0F90      		pop __tmp_reg__
 758 0126 CF91      		pop r28
 759 0128 DF91      		pop r29
 760 012a 0895      		ret
 765               	.Lscope16:
 767               		.stabd	78,0,0
 769               	.global	checkLockerSensors
 771               	checkLockerSensors:
 772               		.stabd	46,0,0
 101:hardware.c    **** {
 774               	.LM66:
 775               	.LFBB17:
 776 012c 0F93      		push r16
 777 012e 1F93      		push r17
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 102:hardware.c    ****   if (lockSensors[0].enabled)
 781               	.LM67:
 782 0130 E091 0000 		lds r30,lockSensors
 783 0134 F091 0000 		lds r31,(lockSensors)+1
 784 0138 8081      		ld r24,Z
 785 013a 8823      		tst r24
 786 013c 01F0      		breq .L37
 104:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
 788               	.LM68:
 789 013e 80E4      		ldi r24,lo8(64)
 790 0140 60E0      		ldi r22,lo8(0)
 791 0142 0E94 0000 		call MPC23s17SetBitsOnPortA
 105:hardware.c    ****     vTaskDelay(30);
 793               	.LM69:
 794 0146 8EE1      		ldi r24,lo8(30)
 795 0148 90E0      		ldi r25,hi8(30)
 796 014a 0E94 0000 		call vTaskDelay
 106:hardware.c    ****     lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
 798               	.LM70:
 799 014e 0091 0000 		lds r16,lockSensors
 800 0152 1091 0000 		lds r17,(lockSensors)+1
 801 0156 84E0      		ldi r24,lo8(4)
 802 0158 0E94 0000 		call MCP3008_getSampleSingle
 803 015c F801      		movw r30,r16
 804 015e 9483      		std Z+4,r25
 805 0160 8383      		std Z+3,r24
 107:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
 807               	.LM71:
 808 0162 80E4      		ldi r24,lo8(64)
 809 0164 60E0      		ldi r22,lo8(0)
 810 0166 0E94 0000 		call MPC23s17ClearBitsOnPortA
 108:hardware.c    ****     lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
 812               	.LM72:
 813 016a E091 0000 		lds r30,lockSensors
 814 016e F091 0000 		lds r31,(lockSensors)+1
 815 0172 40E0      		ldi r20,lo8(0)
 816 0174 2381      		ldd r18,Z+3
 817 0176 3481      		ldd r19,Z+4
 818 0178 8181      		ldd r24,Z+1
 819 017a 9281      		ldd r25,Z+2
 820 017c 8217      		cp r24,r18
 821 017e 9307      		cpc r25,r19
 822 0180 00F4      		brsh .L38
 823 0182 41E0      		ldi r20,lo8(1)
 824               	.L38:
 825 0184 4583      		std Z+5,r20
 109:hardware.c    ****     vTaskDelay(10);
 827               	.LM73:
 828 0186 8AE0      		ldi r24,lo8(10)
 829 0188 90E0      		ldi r25,hi8(10)
 830 018a 0E94 0000 		call vTaskDelay
 831               	.L37:
 112:hardware.c    ****   if (lockSensors[1].enabled)
 833               	.LM74:
 834 018e E091 0000 		lds r30,lockSensors
 835 0192 F091 0000 		lds r31,(lockSensors)+1
 836 0196 8681      		ldd r24,Z+6
 837 0198 8823      		tst r24
 838 019a 01F0      		breq .L39
 114:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
 840               	.LM75:
 841 019c 80E2      		ldi r24,lo8(32)
 842 019e 60E0      		ldi r22,lo8(0)
 843 01a0 0E94 0000 		call MPC23s17SetBitsOnPortA
 115:hardware.c    ****     vTaskDelay(30);
 845               	.LM76:
 846 01a4 8EE1      		ldi r24,lo8(30)
 847 01a6 90E0      		ldi r25,hi8(30)
 848 01a8 0E94 0000 		call vTaskDelay
 116:hardware.c    ****     lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
 850               	.LM77:
 851 01ac 0091 0000 		lds r16,lockSensors
 852 01b0 1091 0000 		lds r17,(lockSensors)+1
 853 01b4 0A5F      		subi r16,lo8(-(6))
 854 01b6 1F4F      		sbci r17,hi8(-(6))
 855 01b8 85E0      		ldi r24,lo8(5)
 856 01ba 0E94 0000 		call MCP3008_getSampleSingle
 857 01be F801      		movw r30,r16
 858 01c0 9483      		std Z+4,r25
 859 01c2 8383      		std Z+3,r24
 117:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
 861               	.LM78:
 862 01c4 80E2      		ldi r24,lo8(32)
 863 01c6 60E0      		ldi r22,lo8(0)
 864 01c8 0E94 0000 		call MPC23s17ClearBitsOnPortA
 118:hardware.c    ****     lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
 866               	.LM79:
 867 01cc E091 0000 		lds r30,lockSensors
 868 01d0 F091 0000 		lds r31,(lockSensors)+1
 869 01d4 3696      		adiw r30,6
 870 01d6 40E0      		ldi r20,lo8(0)
 871 01d8 2381      		ldd r18,Z+3
 872 01da 3481      		ldd r19,Z+4
 873 01dc 8181      		ldd r24,Z+1
 874 01de 9281      		ldd r25,Z+2
 875 01e0 8217      		cp r24,r18
 876 01e2 9307      		cpc r25,r19
 877 01e4 00F4      		brsh .L40
 878 01e6 41E0      		ldi r20,lo8(1)
 879               	.L40:
 880 01e8 4583      		std Z+5,r20
 119:hardware.c    ****     vTaskDelay(10);
 882               	.LM80:
 883 01ea 8AE0      		ldi r24,lo8(10)
 884 01ec 90E0      		ldi r25,hi8(10)
 885 01ee 0E94 0000 		call vTaskDelay
 886               	.L39:
 122:hardware.c    ****   if (lockSensors[2].enabled)
 888               	.LM81:
 889 01f2 E091 0000 		lds r30,lockSensors
 890 01f6 F091 0000 		lds r31,(lockSensors)+1
 891 01fa 8485      		ldd r24,Z+12
 892 01fc 8823      		tst r24
 893 01fe 01F0      		breq .L41
 124:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
 895               	.LM82:
 896 0200 80E1      		ldi r24,lo8(16)
 897 0202 60E0      		ldi r22,lo8(0)
 898 0204 0E94 0000 		call MPC23s17SetBitsOnPortA
 125:hardware.c    ****     vTaskDelay(30);
 900               	.LM83:
 901 0208 8EE1      		ldi r24,lo8(30)
 902 020a 90E0      		ldi r25,hi8(30)
 903 020c 0E94 0000 		call vTaskDelay
 126:hardware.c    ****     lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
 905               	.LM84:
 906 0210 0091 0000 		lds r16,lockSensors
 907 0214 1091 0000 		lds r17,(lockSensors)+1
 908 0218 045F      		subi r16,lo8(-(12))
 909 021a 1F4F      		sbci r17,hi8(-(12))
 910 021c 86E0      		ldi r24,lo8(6)
 911 021e 0E94 0000 		call MCP3008_getSampleSingle
 912 0222 F801      		movw r30,r16
 913 0224 9483      		std Z+4,r25
 914 0226 8383      		std Z+3,r24
 127:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
 916               	.LM85:
 917 0228 80E1      		ldi r24,lo8(16)
 918 022a 60E0      		ldi r22,lo8(0)
 919 022c 0E94 0000 		call MPC23s17ClearBitsOnPortA
 128:hardware.c    ****     lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
 921               	.LM86:
 922 0230 E091 0000 		lds r30,lockSensors
 923 0234 F091 0000 		lds r31,(lockSensors)+1
 924 0238 3C96      		adiw r30,12
 925 023a 40E0      		ldi r20,lo8(0)
 926 023c 2381      		ldd r18,Z+3
 927 023e 3481      		ldd r19,Z+4
 928 0240 8181      		ldd r24,Z+1
 929 0242 9281      		ldd r25,Z+2
 930 0244 8217      		cp r24,r18
 931 0246 9307      		cpc r25,r19
 932 0248 00F4      		brsh .L42
 933 024a 41E0      		ldi r20,lo8(1)
 934               	.L42:
 935 024c 4583      		std Z+5,r20
 129:hardware.c    ****     vTaskDelay(10);
 937               	.LM87:
 938 024e 8AE0      		ldi r24,lo8(10)
 939 0250 90E0      		ldi r25,hi8(10)
 940 0252 0E94 0000 		call vTaskDelay
 941               	.L41:
 132:hardware.c    ****   if (lockSensors[3].enabled)
 943               	.LM88:
 944 0256 E091 0000 		lds r30,lockSensors
 945 025a F091 0000 		lds r31,(lockSensors)+1
 946 025e 8289      		ldd r24,Z+18
 947 0260 8823      		tst r24
 948 0262 01F0      		breq .L45
 134:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
 950               	.LM89:
 951 0264 88E0      		ldi r24,lo8(8)
 952 0266 60E0      		ldi r22,lo8(0)
 953 0268 0E94 0000 		call MPC23s17SetBitsOnPortA
 135:hardware.c    ****     vTaskDelay(30);
 955               	.LM90:
 956 026c 8EE1      		ldi r24,lo8(30)
 957 026e 90E0      		ldi r25,hi8(30)
 958 0270 0E94 0000 		call vTaskDelay
 136:hardware.c    ****     lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
 960               	.LM91:
 961 0274 0091 0000 		lds r16,lockSensors
 962 0278 1091 0000 		lds r17,(lockSensors)+1
 963 027c 0E5E      		subi r16,lo8(-(18))
 964 027e 1F4F      		sbci r17,hi8(-(18))
 965 0280 87E0      		ldi r24,lo8(7)
 966 0282 0E94 0000 		call MCP3008_getSampleSingle
 967 0286 F801      		movw r30,r16
 968 0288 9483      		std Z+4,r25
 969 028a 8383      		std Z+3,r24
 137:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
 971               	.LM92:
 972 028c 88E0      		ldi r24,lo8(8)
 973 028e 60E0      		ldi r22,lo8(0)
 974 0290 0E94 0000 		call MPC23s17ClearBitsOnPortA
 138:hardware.c    ****     lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
 976               	.LM93:
 977 0294 E091 0000 		lds r30,lockSensors
 978 0298 F091 0000 		lds r31,(lockSensors)+1
 979 029c 7296      		adiw r30,18
 980 029e 40E0      		ldi r20,lo8(0)
 981 02a0 2381      		ldd r18,Z+3
 982 02a2 3481      		ldd r19,Z+4
 983 02a4 8181      		ldd r24,Z+1
 984 02a6 9281      		ldd r25,Z+2
 985 02a8 8217      		cp r24,r18
 986 02aa 9307      		cpc r25,r19
 987 02ac 00F4      		brsh .L44
 988 02ae 41E0      		ldi r20,lo8(1)
 989               	.L44:
 990 02b0 4583      		std Z+5,r20
 139:hardware.c    ****     vTaskDelay(10);
 992               	.LM94:
 993 02b2 8AE0      		ldi r24,lo8(10)
 994 02b4 90E0      		ldi r25,hi8(10)
 995 02b6 0E94 0000 		call vTaskDelay
 996               	.L45:
 997               	/* epilogue start */
 141:hardware.c    **** }
 999               	.LM95:
 1000 02ba 1F91      		pop r17
 1001 02bc 0F91      		pop r16
 1002 02be 0895      		ret
 1004               	.Lscope17:
 1006               		.stabd	78,0,0
 1009               	.global	printLockers
 1011               	printLockers:
 1012               		.stabd	46,0,0
  79:hardware.c    **** {
 1014               	.LM96:
 1015               	.LFBB18:
 1016 02c0 4F92      		push r4
 1017 02c2 5F92      		push r5
 1018 02c4 6F92      		push r6
 1019 02c6 7F92      		push r7
 1020 02c8 8F92      		push r8
 1021 02ca 9F92      		push r9
 1022 02cc AF92      		push r10
 1023 02ce BF92      		push r11
 1024 02d0 DF92      		push r13
 1025 02d2 EF92      		push r14
 1026 02d4 FF92      		push r15
 1027 02d6 0F93      		push r16
 1028 02d8 1F93      		push r17
 1029 02da CF93      		push r28
 1030 02dc DF93      		push r29
 1031               	/* prologue: function */
 1032               	/* frame size = 0 */
 1033 02de 7C01      		movw r14,r24
  82:hardware.c    ****   struct lockerSensor *tmpLock = lockSensors;
 1035               	.LM97:
 1036 02e0 0091 0000 		lds r16,lockSensors
 1037 02e4 1091 0000 		lds r17,(lockSensors)+1
 1038 02e8 DD24      		clr r13
 1039 02ea C0E0      		ldi r28,lo8(0)
 1040 02ec D0E0      		ldi r29,hi8(0)
  87:hardware.c    ****       fprintf_P(stream, statusLockerSensDescStr, i);
 1042               	.LM98:
 1043 02ee 30E0      		ldi r19,lo8(statusLockerSensDescStr)
 1044 02f0 432E      		mov r4,r19
 1045 02f2 30E0      		ldi r19,hi8(statusLockerSensDescStr)
 1046 02f4 532E      		mov r5,r19
  92:hardware.c    ****       fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
 1048               	.LM99:
 1049 02f6 20E0      		ldi r18,lo8(statusLockerSensAdditionalDescStr)
 1050 02f8 622E      		mov r6,r18
 1051 02fa 20E0      		ldi r18,hi8(statusLockerSensAdditionalDescStr)
 1052 02fc 722E      		mov r7,r18
  91:hardware.c    ****         fprintf_P(stream, statusLockerCloseStr);
 1054               	.LM100:
 1055 02fe 90E0      		ldi r25,lo8(statusLockerCloseStr)
 1056 0300 892E      		mov r8,r25
 1057 0302 90E0      		ldi r25,hi8(statusLockerCloseStr)
 1058 0304 992E      		mov r9,r25
  89:hardware.c    ****         fprintf_P(stream, statusLockerOpenStr);
 1060               	.LM101:
 1061 0306 80E0      		ldi r24,lo8(statusLockerOpenStr)
 1062 0308 A82E      		mov r10,r24
 1063 030a 80E0      		ldi r24,hi8(statusLockerOpenStr)
 1064 030c B82E      		mov r11,r24
 1065               	.L51:
  85:hardware.c    ****     if (tmpLock->enabled)
 1067               	.LM102:
 1068 030e D801      		movw r26,r16
 1069 0310 8C91      		ld r24,X
 1070 0312 8823      		tst r24
 1071 0314 01F4      		brne .+2
 1072 0316 00C0      		rjmp .L47
  87:hardware.c    ****       fprintf_P(stream, statusLockerSensDescStr, i);
 1074               	.LM103:
 1075 0318 00D0      		rcall .
 1076 031a 00D0      		rcall .
 1077 031c 00D0      		rcall .
 1078 031e EDB7      		in r30,__SP_L__
 1079 0320 FEB7      		in r31,__SP_H__
 1080 0322 3196      		adiw r30,1
 1081 0324 ADB7      		in r26,__SP_L__
 1082 0326 BEB7      		in r27,__SP_H__
 1083 0328 1296      		adiw r26,1+1
 1084 032a FC92      		st X,r15
 1085 032c EE92      		st -X,r14
 1086 032e 1197      		sbiw r26,1
 1087 0330 5382      		std Z+3,r5
 1088 0332 4282      		std Z+2,r4
 1089 0334 2196      		adiw r28,1
 1090 0336 D583      		std Z+5,r29
 1091 0338 C483      		std Z+4,r28
 1092 033a 2197      		sbiw r28,1
 1093 033c 0E94 0000 		call fprintf_P
  88:hardware.c    ****       if (tmpLock->threshold > tmpLock->acVal)
 1095               	.LM104:
 1096 0340 EDB7      		in r30,__SP_L__
 1097 0342 FEB7      		in r31,__SP_H__
 1098 0344 3696      		adiw r30,6
 1099 0346 0FB6      		in __tmp_reg__,__SREG__
 1100 0348 F894      		cli
 1101 034a FEBF      		out __SP_H__,r31
 1102 034c 0FBE      		out __SREG__,__tmp_reg__
 1103 034e EDBF      		out __SP_L__,r30
 1104 0350 D801      		movw r26,r16
 1105 0352 1196      		adiw r26,1
 1106 0354 2D91      		ld r18,X+
 1107 0356 3C91      		ld r19,X
 1108 0358 1297      		sbiw r26,1+1
 1109 035a 1396      		adiw r26,3
 1110 035c 8D91      		ld r24,X+
 1111 035e 9C91      		ld r25,X
 1112 0360 1497      		sbiw r26,3+1
 1113 0362 8217      		cp r24,r18
 1114 0364 9307      		cpc r25,r19
 1115 0366 00F4      		brsh .L48
  89:hardware.c    ****         fprintf_P(stream, statusLockerOpenStr);
 1117               	.LM105:
 1118 0368 00D0      		rcall .
 1119 036a 00D0      		rcall .
 1120 036c EDB7      		in r30,__SP_L__
 1121 036e FEB7      		in r31,__SP_H__
 1122 0370 F282      		std Z+2,r15
 1123 0372 E182      		std Z+1,r14
 1124 0374 B482      		std Z+4,r11
 1125 0376 A382      		std Z+3,r10
 1126 0378 00C0      		rjmp .L53
 1127               	.L48:
  91:hardware.c    ****         fprintf_P(stream, statusLockerCloseStr);
 1129               	.LM106:
 1130 037a 00D0      		rcall .
 1131 037c 00D0      		rcall .
 1132 037e ADB7      		in r26,__SP_L__
 1133 0380 BEB7      		in r27,__SP_H__
 1134 0382 1296      		adiw r26,1+1
 1135 0384 FC92      		st X,r15
 1136 0386 EE92      		st -X,r14
 1137 0388 1197      		sbiw r26,1
 1138 038a 1496      		adiw r26,3+1
 1139 038c 9C92      		st X,r9
 1140 038e 8E92      		st -X,r8
 1141 0390 1397      		sbiw r26,3
 1142               	.L53:
 1143 0392 0E94 0000 		call fprintf_P
 1144 0396 0F90      		pop __tmp_reg__
 1145 0398 0F90      		pop __tmp_reg__
 1146 039a 0F90      		pop __tmp_reg__
 1147 039c 0F90      		pop __tmp_reg__
  92:hardware.c    ****       fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
 1149               	.LM107:
 1150 039e EDB7      		in r30,__SP_L__
 1151 03a0 FEB7      		in r31,__SP_H__
 1152 03a2 3897      		sbiw r30,8
 1153 03a4 0FB6      		in __tmp_reg__,__SREG__
 1154 03a6 F894      		cli
 1155 03a8 FEBF      		out __SP_H__,r31
 1156 03aa 0FBE      		out __SREG__,__tmp_reg__
 1157 03ac EDBF      		out __SP_L__,r30
 1158 03ae 3196      		adiw r30,1
 1159 03b0 ADB7      		in r26,__SP_L__
 1160 03b2 BEB7      		in r27,__SP_H__
 1161 03b4 1296      		adiw r26,1+1
 1162 03b6 FC92      		st X,r15
 1163 03b8 EE92      		st -X,r14
 1164 03ba 1197      		sbiw r26,1
 1165 03bc 7382      		std Z+3,r7
 1166 03be 6282      		std Z+2,r6
 1167 03c0 D801      		movw r26,r16
 1168 03c2 1196      		adiw r26,1
 1169 03c4 8D91      		ld r24,X+
 1170 03c6 9C91      		ld r25,X
 1171 03c8 1297      		sbiw r26,1+1
 1172 03ca 9583      		std Z+5,r25
 1173 03cc 8483      		std Z+4,r24
 1174 03ce 1396      		adiw r26,3
 1175 03d0 8D91      		ld r24,X+
 1176 03d2 9C91      		ld r25,X
 1177 03d4 1497      		sbiw r26,3+1
 1178 03d6 9783      		std Z+7,r25
 1179 03d8 8683      		std Z+6,r24
 1180 03da 0E94 0000 		call fprintf_P
  93:hardware.c    ****       result++;
 1182               	.LM108:
 1183 03de D394      		inc r13
 1184 03e0 EDB7      		in r30,__SP_L__
 1185 03e2 FEB7      		in r31,__SP_H__
 1186 03e4 3896      		adiw r30,8
 1187 03e6 0FB6      		in __tmp_reg__,__SREG__
 1188 03e8 F894      		cli
 1189 03ea FEBF      		out __SP_H__,r31
 1190 03ec 0FBE      		out __SREG__,__tmp_reg__
 1191 03ee EDBF      		out __SP_L__,r30
 1192               	.L47:
 1193 03f0 2196      		adiw r28,1
  83:hardware.c    ****   for (i=1; i<=4; i++)
 1195               	.LM109:
 1196 03f2 C430      		cpi r28,4
 1197 03f4 D105      		cpc r29,__zero_reg__
 1198 03f6 01F0      		breq .L50
  95:hardware.c    ****     tmpLock++;
 1200               	.LM110:
 1201 03f8 0A5F      		subi r16,lo8(-(6))
 1202 03fa 1F4F      		sbci r17,hi8(-(6))
 1203 03fc 00C0      		rjmp .L51
 1204               	.L50:
  98:hardware.c    **** }
 1206               	.LM111:
 1207 03fe 8D2D      		mov r24,r13
 1208               	/* epilogue start */
 1209 0400 DF91      		pop r29
 1210 0402 CF91      		pop r28
 1211 0404 1F91      		pop r17
 1212 0406 0F91      		pop r16
 1213 0408 FF90      		pop r15
 1214 040a EF90      		pop r14
 1215 040c DF90      		pop r13
 1216 040e BF90      		pop r11
 1217 0410 AF90      		pop r10
 1218 0412 9F90      		pop r9
 1219 0414 8F90      		pop r8
 1220 0416 7F90      		pop r7
 1221 0418 6F90      		pop r6
 1222 041a 5F90      		pop r5
 1223 041c 4F90      		pop r4
 1224 041e 0895      		ret
 1230               	.Lscope18:
 1232               		.stabd	78,0,0
 1234               	.global	LockersMemInit
 1236               	LockersMemInit:
 1237               		.stabd	46,0,0
  74:hardware.c    **** {
 1239               	.LM112:
 1240               	.LFBB19:
 1241               	/* prologue: function */
 1242               	/* frame size = 0 */
  75:hardware.c    ****   lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
 1244               	.LM113:
 1245 0420 88E1      		ldi r24,lo8(24)
 1246 0422 90E0      		ldi r25,hi8(24)
 1247 0424 0E94 0000 		call xmalloc
 1248 0428 9093 0000 		sts (lockSensors)+1,r25
 1249 042c 8093 0000 		sts lockSensors,r24
 1250               	/* epilogue start */
  76:hardware.c    **** }
 1252               	.LM114:
 1253 0430 0895      		ret
 1255               	.Lscope19:
 1257               		.stabd	78,0,0
 1259               	.global	hardwareInit
 1261               	hardwareInit:
 1262               		.stabd	46,0,0
  14:hardware.c    **** {
 1264               	.LM115:
 1265               	.LFBB20:
 1266               	/* prologue: function */
 1267               	/* frame size = 0 */
  16:hardware.c    ****   portENTER_CRITICAL();
 1269               	.LM116:
 1270               	/* #APP */
 1271               	 ;  16 "hardware.c" 1
 1272 0432 0FB6      		in		__tmp_reg__, __SREG__
 1273               	 ;  0 "" 2
 1274               	 ;  16 "hardware.c" 1
 1275 0434 F894      		cli
 1276               	 ;  0 "" 2
 1277               	 ;  16 "hardware.c" 1
 1278 0436 0F92      		push	__tmp_reg__
 1279               	 ;  0 "" 2
  17:hardware.c    ****   xSpiRx          = xQueueCreate(1, 1);
 1281               	.LM117:
 1282               	/* #NOAPP */
 1283 0438 81E0      		ldi r24,lo8(1)
 1284 043a 61E0      		ldi r22,lo8(1)
 1285 043c 0E94 0000 		call xQueueCreate
 1286 0440 9093 0000 		sts (xSpiRx)+1,r25
 1287 0444 8093 0000 		sts xSpiRx,r24
  18:hardware.c    ****   portEXIT_CRITICAL();
 1289               	.LM118:
 1290               	/* #APP */
 1291               	 ;  18 "hardware.c" 1
 1292 0448 0F90      		pop		__tmp_reg__
 1293               	 ;  0 "" 2
 1294               	 ;  18 "hardware.c" 1
 1295 044a 0FBE      		out		__SREG__, __tmp_reg__
 1296               	 ;  0 "" 2
  20:hardware.c    ****   DDRB = 0xF7;
 1298               	.LM119:
 1299               	/* #NOAPP */
 1300 044c 87EF      		ldi r24,lo8(-9)
 1301 044e 87BB      		out 55-32,r24
  21:hardware.c    ****   PORTB = 0xD1;
 1303               	.LM120:
 1304 0450 81ED      		ldi r24,lo8(-47)
 1305 0452 88BB      		out 56-32,r24
  35:hardware.c    ****   DDRD = 0x00;
 1307               	.LM121:
 1308 0454 11BA      		out 49-32,__zero_reg__
  47:hardware.c    ****   DDRE  = 0x0E;
 1310               	.LM122:
 1311 0456 8EE0      		ldi r24,lo8(14)
 1312 0458 82B9      		out 34-32,r24
  48:hardware.c    ****   PORTE = 0x0C;
 1314               	.LM123:
 1315 045a 8CE0      		ldi r24,lo8(12)
 1316 045c 83B9      		out 35-32,r24
  59:hardware.c    ****   DDRF = 0x00;    //JTAG and A/C
 1318               	.LM124:
 1319 045e 1092 6100 		sts 97,__zero_reg__
  60:hardware.c    ****   DDRG = 0x1F;
 1321               	.LM125:
 1322 0462 8FE1      		ldi r24,lo8(31)
 1323 0464 8093 6400 		sts 100,r24
 1324               	/* epilogue start */
  71:hardware.c    **** }
 1326               	.LM126:
 1327 0468 0895      		ret
 1329               	.Lscope20:
 1331               		.stabd	78,0,0
 1332               	.global	statusLockerSensDescStr
 1333               		.section	.progmem.data,"a",@progbits
 1336               	statusLockerSensDescStr:
 1337 0000 206C 6F63 		.string	" locker %d"
 1337      6B65 7220 
 1337      2564 00
 1338               	.global	statusLockerOpenStr
 1341               	statusLockerOpenStr:
 1342 000b 206F 7065 		.string	" open   "
 1342      6E20 2020 
 1342      00
 1343               	.global	statusLockerCloseStr
 1346               	statusLockerCloseStr:
 1347 0014 206C 6F63 		.string	" locked "
 1347      6B65 6420 
 1347      00
 1348               	.global	statusLockerSensAdditionalDescStr
 1351               	statusLockerSensAdditionalDescStr:
 1352 001d 2028 7468 		.string	" (threshold %d, AC value %d)\r\n"
 1352      7265 7368 
 1352      6F6C 6420 
 1352      2564 2C20 
 1352      4143 2076 
 1353               		.lcomm data.3312,1
 1354               		.lcomm xHigherPriorityTaskWoken.3311,1
 1355               		.comm wwwport,1,1
 1356               		.comm klastry,128,1
 1357               		.comm rollers,2,1
 1358               		.comm xSemaphoreRs485,2,1
 1359               		.comm xSemaphoreSpiSS,2,1
 1360               		.comm nicState,14,1
 1361               		.comm plen,2,1
 1362               		.comm IpMyConfig,15,1
 1363               		.comm arpDebug,2,1
 1364               		.comm arpDebugLevel,1,1
 1365               		.comm icmpDebug,2,1
 1366               		.comm icmpDebugLevel,1,1
 1367               		.comm udpSocket,2,1
 1368               		.comm udpDbgStream,2,1
 1369               		.comm udpDbgLevel,1,1
 1370               		.comm tcpDebugStream,2,1
 1371               		.comm tcpDebugLevel,1,1
 1372               		.comm sockets,2,1
 1373               		.comm entries,2,1
 1374               		.comm debugStream,2,1
 1375               		.comm uip_netif_physical_if,2,1
 1376               		.comm uip_ext_len,1,1
 1377               		.comm uip_ext_opt_offset,1,1
 1378               		.comm lockSensors,2,1
 1379               		.comm czasRtc,7,1
 1380               		.comm portA,1,1
 1381               		.comm portB,1,1
 1382               		.comm xSpiRx,2,1
 1417               		.text
 1419               	.Letext0:
 1420               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 hardware.c
     /tmp/ccge0LTS.s:2      *ABS*:0000003f __SREG__
     /tmp/ccge0LTS.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccge0LTS.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccge0LTS.s:5      *ABS*:00000034 __CCP__
     /tmp/ccge0LTS.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccge0LTS.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccge0LTS.s:280    .text:00000000 spiSendSpinBlock
     /tmp/ccge0LTS.s:318    .text:00000010 disableAllSpiDevices
     /tmp/ccge0LTS.s:354    .text:00000026 spiEnableEnc28j60
     /tmp/ccge0LTS.s:375    .text:0000002a spiDisableEnc28j60
     /tmp/ccge0LTS.s:396    .text:0000002e enableSpiSd
     /tmp/ccge0LTS.s:421    .text:0000003a disableSpiSd
     /tmp/ccge0LTS.s:446    .text:00000046 enableSpiMPC23S17
     /tmp/ccge0LTS.s:467    .text:0000004a disableSpiMPC23S17
     /tmp/ccge0LTS.s:488    .text:0000004e enableSpiMCP3008
     /tmp/ccge0LTS.s:514    .text:00000058 disableSpiMCP3008
     /tmp/ccge0LTS.s:540    .text:00000062 enableSpiMCP4150
     /tmp/ccge0LTS.s:566    .text:0000006c disableSpiMCP4150
     /tmp/ccge0LTS.s:592    .text:00000076 spiEnableDS1305
     /tmp/ccge0LTS.s:618    .text:00000080 spiDisableDS1305
     /tmp/ccge0LTS.s:644    .text:0000008a __vector_17
                             .bss:00000000 data.3312
                            *COM*:00000002 xSpiRx
     /tmp/ccge0LTS.s:1353   .bss:00000001 xHigherPriorityTaskWoken.3311
     /tmp/ccge0LTS.s:727    .text:000000fe spiSend
     /tmp/ccge0LTS.s:771    .text:0000012c checkLockerSensors
                            *COM*:00000002 lockSensors
     /tmp/ccge0LTS.s:1011   .text:000002c0 printLockers
     /tmp/ccge0LTS.s:1336   .progmem.data:00000000 statusLockerSensDescStr
     /tmp/ccge0LTS.s:1351   .progmem.data:0000001d statusLockerSensAdditionalDescStr
     /tmp/ccge0LTS.s:1346   .progmem.data:00000014 statusLockerCloseStr
     /tmp/ccge0LTS.s:1341   .progmem.data:0000000b statusLockerOpenStr
     /tmp/ccge0LTS.s:1236   .text:00000420 LockersMemInit
     /tmp/ccge0LTS.s:1261   .text:00000432 hardwareInit
                            *COM*:00000001 wwwport
                            *COM*:00000080 klastry
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:0000000e nicState
                            *COM*:00000002 plen
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpSocket
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000002 entries
                            *COM*:00000002 debugStream
                            *COM*:00000002 uip_netif_physical_if
                            *COM*:00000001 uip_ext_len
                            *COM*:00000001 uip_ext_opt_offset
                            *COM*:00000007 czasRtc
                            *COM*:00000001 portA
                            *COM*:00000001 portB

UNDEFINED SYMBOLS
xQueueGenericSendFromISR
vPortYield
xQueueGenericReceive
MPC23s17SetBitsOnPortA
vTaskDelay
MCP3008_getSampleSingle
MPC23s17ClearBitsOnPortA
fprintf_P
xmalloc
xQueueCreate
__do_clear_bss
