
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000088  00800100  0000c190  0000c244  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000c190  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000e61  00800188  00800188  0000c2cc  2**0
                  ALLOC
  3 .eeprom       00000032  00810000  00810000  0000c2cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         0001bedc  00000000  00000000  0000c300  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000e492  00000000  00000000  000281dc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__ctors_end>
       4:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
       8:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
       c:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      10:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      14:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      18:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      1c:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      20:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      24:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      28:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      2c:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      30:	0c 94 07 59 	jmp	0xb20e	; 0xb20e <__vector_12>
      34:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      38:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      3c:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      40:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      44:	0c 94 c5 0d 	jmp	0x1b8a	; 0x1b8a <__vector_17>
      48:	0c 94 9a 0c 	jmp	0x1934	; 0x1934 <__vector_18>
      4c:	0c 94 ce 0b 	jmp	0x179c	; 0x179c <__vector_19>
      50:	0c 94 71 0b 	jmp	0x16e2	; 0x16e2 <__vector_20>
      54:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      58:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      5c:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      60:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      64:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      68:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      6c:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      70:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      74:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      78:	0c 94 55 0c 	jmp	0x18aa	; 0x18aa <__vector_30>
      7c:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__vector_31>
      80:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      84:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>
      88:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__bad_interrupt>

0000008c <statusLockerSensDescStr>:
      8c:	20 6c 6f 63 6b 65 72 20 25 64 00                     locker %d.

00000097 <statusLockerOpenStr>:
      97:	20 6f 70 65 6e 20 20 20 00                           open   .

000000a0 <statusLockerCloseStr>:
      a0:	20 6c 6f 63 6b 65 64 20 00                           locked .

000000a9 <statusLockerSensAdditionalDescStr>:
      a9:	20 28 74 68 72 65 73 68 6f 6c 64 20 25 64 2c 20      (threshold %d, 
      b9:	41 43 20 76 61 6c 75 65 20 25 64 29 0d 0a 00        AC value %d)...

000000c8 <errorOK>:
      c8:	41 6c 6c 20 4f 4b 0d 0a 00                          All OK...

000000d1 <errorNoFile>:
      d1:	4e 6f 20 46 69 6c 65 0d 0a 00                       No File...

000000db <errorxModemFrameStartTimeout>:
      db:	0d 0a 00                                            ...

000000de <errorxModemByteSendTimeout>:
      de:	0d 0a 00                                            ...

000000e1 <errorxModemWrongFrameNo>:
      e1:	0d 0a 00                                            ...

000000e4 <errorxModemFrameFrameNoCorrectionNotMatch>:
      e4:	0d 0a 00                                            ...

000000e7 <errorxModemFrameCrc>:
      e7:	78 4d 6f 64 65 6d 20 43 52 43 20 65 72 72 6f 72     xModem CRC error
      f7:	0d 0a 00                                            ...

000000fa <errorxModemRemoteSideCan>:
      fa:	52 65 6d 6f 74 65 20 73 69 64 65 20 63 61 6e 63     Remote side canc
     10a:	65 6c 6c 65 64 20 61 74 20 66 72 61 6d 65 20 6e     elled at frame n
     11a:	6f 20 25 64 0d 0a 00                                o %d...

00000121 <errorxModemUnknownResponse>:
     121:	78 4d 6f 64 65 6d 20 75 6e 6b 6e 6f 77 6e 20 72     xModem unknown r
     131:	65 73 70 6f 6e 73 65 20 30 78 25 78 0d 0a 00        esponse 0x%x...

00000140 <errorNoRemoteDevice>:
     140:	44 65 76 69 63 65 20 25 64 20 69 73 20 6e 6f 74     Device %d is not
     150:	20 72 65 73 70 6f 6e 64 69 6e 67 20 28 25 64 29      responding (%d)
     160:	0d 0a 00                                            ...

00000163 <errorBootloaderNotResponding>:
     163:	42 6f 6f 74 6c 6f 61 64 65 72 20 69 73 20 6e 6f     Bootloader is no
     173:	74 20 72 65 73 70 6f 6e 64 69 6e 67 0d 0a 00        t responding...

00000182 <errorOpenFile>:
     182:	43 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 20     Can't open file 
     192:	25 73 0d 0a 00                                      %s...

00000197 <systemStateStr>:
     197:	53 79 73 74 65 6d 20 73 74 61 74 65 3a 0d 0a 00     System state:...

000001a7 <statusNumberOfTasksStr>:
     1a7:	20 20 4e 75 6d 62 65 72 20 6f 66 20 74 61 73 6b       Number of task
     1b7:	73 20 3a 20 25 64 0d 0a 00                          s : %d...

000001c0 <statusStaticHeapStateStr>:
     1c0:	20 20 46 72 65 65 52 74 6f 73 20 68 65 61 70 20       FreeRtos heap 
     1d0:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     1e0:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

000001ea <statusDynamicHeapStateStr>:
     1ea:	20 20 4d 61 6c 6c 6f 63 20 68 65 61 70 20 20 20       Malloc heap   
     1fa:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     20a:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000214 <statusRamDiskStateStr>:
     214:	20 20 52 61 6d 20 64 69 73 63 20 73 70 61 63 65       Ram disc space
     224:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     234:	64 20 63 6c 75 73 74 65 72 73 0d 0a 00              d clusters...

00000241 <statusTemperatureStr>:
     241:	20 20 54 65 6d 70 65 72 61 74 75 72 65 20 20 20       Temperature   
     251:	20 20 3a 20 25 64 20 43 0d 0a 00                      : %d C...

0000025c <statusVoltageStr>:
     25c:	20 20 56 6f 6c 74 61 67 65 20 20 20 20 20 20 20       Voltage       
     26c:	20 20 3a 20 25 64 20 56 0d 0a 00                      : %d V...

00000277 <systemRamConfigStr>:
     277:	53 79 73 74 65 6d 20 73 65 74 74 69 6e 67 73 3a     System settings:
     287:	0d 0a 00                                            ...

0000028a <statusMacStr>:
     28a:	20 20 4d 61 63 20 61 64 64 72 65 73 73 20 20 20       Mac address   
     29a:	20 20 3a 20 00                                        : .

0000029f <statusIpStr>:
     29f:	20 20 49 50 20 61 64 64 72 65 73 73 20 20 20 20       IP address    
     2af:	20 20 3a 20 00                                        : .

000002b4 <statusIpMaskStr>:
     2b4:	20 20 6d 61 73 6b 20 20 20 20 20 20 20 20 20 20       mask          
     2c4:	20 20 3a 20 00                                        : .

000002c9 <statusIpGwStr>:
     2c9:	20 20 67 61 74 65 77 61 79 20 20 20 20 20 20 20       gateway       
     2d9:	20 20 3a 20 00                                        : .

000002de <statusRs485listStr>:
     2de:	44 65 74 65 63 74 65 64 20 52 53 20 34 38 35 20     Detected RS 485 
     2ee:	64 65 76 69 63 65 73 3a 0d 0a 00                    devices:...

000002f9 <statusNoRs485Dev>:
     2f9:	20 20 43 61 6e 27 74 20 66 69 6e 64 20 61 6e 79       Can't find any
     309:	20 64 65 76 69 63 65 0d 0a 00                        device...

00000313 <statusLockerSensorsStr>:
     313:	4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73 20 73     Locker sensors s
     323:	74 61 74 65 73 3a 0d 0a 00                          tates:...

0000032c <statusLockerSensorsDisStr>:
     32c:	20 20 4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73       Locker sensors
     33c:	20 64 69 73 61 62 6c 65 64 0d 0a 00                  disabled...

00000348 <editRamFileIntroStr>:
     348:	57 72 69 74 69 6e 67 20 74 6f 20 66 69 6c 65 2e     Writing to file.
     358:	20 50 72 65 73 73 20 43 54 52 4c 2b 43 20 74 6f      Press CTRL+C to
     368:	20 71 75 69 74 0d 0a 00                              quit...

00000370 <readRamFIleLenStr>:
     370:	46 69 6c 65 20 6c 65 6e 67 74 68 3a 20 25 64 0d     File length: %d.
     380:	0a 00                                               ..

00000382 <xwyslijStartStr>:
     382:	58 6d 6f 64 65 6d 3a 20 54 72 61 6e 73 6d 69 73     Xmodem: Transmis
     392:	73 69 6f 6e 20 73 74 61 72 74 0d 0a 00              sion start...

0000039f <movingCurtainUpStr>:
     39f:	50 6f 64 6e 6f 73 7a 65 6e 69 65 20 72 6f 6c 65     Podnoszenie role
     3af:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     3bf:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     3cf:	0d 0a 00                                            ...

000003d2 <movingCurtainDownStr>:
     3d2:	4f 70 75 73 7a 63 7a 61 6e 69 65 20 72 6f 6c 65     Opuszczanie role
     3e2:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     3f2:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     402:	0d 0a 00                                            ...

00000405 <movingCurtainPosStr>:
     405:	09 70 6f 7a 79 63 6a 61 20 20 20 25 64 0d 0a 00     .pozycja   %d...

00000415 <debugEnabledInfoStr>:
     415:	45 6e 61 62 6c 65 64 20 25 73 20 64 65 62 75 67     Enabled %s debug
     425:	0d 0a 00                                            ...

00000428 <debugDisabledInfoStr>:
     428:	44 69 73 61 62 6c 65 64 20 25 73 20 64 65 62 75     Disabled %s debu
     438:	67 0d 0a 00                                         g...

0000043c <cmd_help>:
     43c:	68 65 6c 70 00                                      help.

00000441 <cmd_help_help>:
     441:	50 72 69 6e 74 20 68 65 6c 70 20 73 74 72 69 6e     Print help strin
     451:	67 00                                               g.

00000453 <cmd_status>:
     453:	73 74 61 74 75 73 00                                status.

0000045a <cmd_help_status>:
     45a:	7b 66 69 6c 65 6e 61 6d 65 7d 20 50 72 69 6e 74     {filename} Print
     46a:	20 64 65 76 69 63 65 20 73 74 61 74 75 73 20 6f      device status o
     47a:	6e 20 56 54 59 20 6f 72 20 77 72 69 74 65 20 74     n VTY or write t
     48a:	6f 20 66 69 6c 65 00                                o file.

00000491 <cmd_enc_stat>:
     491:	65 6e 63 73 74 61 74 00                             encstat.

00000499 <cmd_help_enc_stat>:
     499:	50 72 69 6e 74 20 45 6e 63 20 32 38 6a 36 30 20     Print Enc 28j60 
     4a9:	72 65 67 69 73 74 65 72 73 00                       registers.

000004b3 <cmd_time>:
     4b3:	74 69 6d 65 00                                      time.

000004b8 <cmd_help_time>:
     4b8:	50 72 69 6e 74 20 74 69 6d 65 00                    Print time.

000004c3 <cmd_net_dbg>:
     4c3:	64 65 62 75 67 00                                   debug.

000004c9 <cmd_help_net_dbg>:
     4c9:	5b 61 72 70 7c 69 63 6d 70 7c 69 70 7c 74 63 70     [arp|icmp|ip|tcp
     4d9:	7c 75 64 70 5d 20 5b 6c 65 76 65 6c 5d 20 77 72     |udp] [level] wr
     4e9:	69 74 65 20 64 65 62 75 67 20 69 6e 66 6f 2e 20     ite debug info. 
     4f9:	4c 65 76 65 6c 20 30 20 64 69 73 61 62 6c 65 20     Level 0 disable 
     509:	64 65 62 75 67 69 6e 67 00                          debuging.

00000512 <cmd_rping>:
     512:	72 70 69 6e 67 00                                   rping.

00000518 <cmd_help_rping>:
     518:	5b 44 65 76 69 63 65 20 6e 6f 5d 20 53 65 6e 64     [Device no] Send
     528:	20 70 69 6e 67 20 74 6f 20 52 73 34 38 35 20 64      ping to Rs485 d
     538:	65 76 69 63 65 00                                   evice.

0000053e <cmd_ping>:
     53e:	70 69 6e 67 00                                      ping.

00000543 <cmd_help_ping>:
     543:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     553:	41 34 5d 20 53 65 6e 64 73 20 70 69 6e 67 20 74     A4] Sends ping t
     563:	68 72 6f 75 67 68 74 20 65 74 68 65 72 6e 65 74     hrought ethernet
	...

00000574 <cmd_xRec>:
     574:	78 72 65 63 00                                      xrec.

00000579 <cmd_help_xRec>:
     579:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 63 65     [file name] rece
     589:	69 76 65 20 66 69 6c 65 20 75 73 69 6e 67 20 78     ive file using x
     599:	4d 6f 64 65 6d 00                                   Modem.

0000059f <cmd_xSend>:
     59f:	78 73 65 6e 64 00                                   xsend.

000005a5 <cmd_help_xSend>:
     5a5:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 73 65 6e 64     [file name] send
     5b5:	20 66 69 6c 65 20 75 73 69 6e 67 20 78 4d 6f 64      file using xMod
     5c5:	65 6d 00                                            em.

000005c8 <cmd_xflash>:
     5c8:	78 66 6c 61 73 68 00                                xflash.

000005cf <cmd_help_xflash>:
     5cf:	5b 64 65 76 69 63 65 20 6e 6f 5d 20 5b 66 69 6c     [device no] [fil
     5df:	65 20 6e 61 6d 65 5d 20 66 6c 61 73 68 20 64 65     e name] flash de
     5ef:	76 69 63 65 20 63 6f 6e 6e 65 63 74 65 64 20 74     vice connected t
     5ff:	6f 20 52 73 34 38 35 00                             o Rs485.

00000607 <cmd_dir_rf>:
     607:	64 69 72 72 66 00                                   dirrf.

0000060d <cmd_help_dir_rf>:
     60d:	50 72 69 6e 74 20 72 61 6d 64 69 73 6b 20 66 69     Print ramdisk fi
     61d:	6c 65 73 00                                         les.

00000621 <cmd_create_rf>:
     621:	63 72 66 00                                         crf.

00000625 <cmd_help_create_rf>:
     625:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 63 72 65 61     [file name] crea
     635:	74 65 20 72 61 6d 20 66 69 6c 65 00                 te ram file.

00000641 <cmd_erase_rf>:
     641:	65 72 61 73 65 72 66 00                             eraserf.

00000649 <cmd_help_erase_rf>:
     649:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 72 61 73     [file name] eras
     659:	65 20 66 69 6c 65 20 66 72 6f 6d 20 72 61 6d 20     e file from ram 
     669:	64 69 73 6b 00                                      disk.

0000066e <cmd_edit_rf>:
     66e:	65 64 69 74 72 66 00                                editrf.

00000675 <cmd_help_edit_rf>:
     675:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 64 69 74     [file name] edit
     685:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     695:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

0000069f <cmd_read_rf>:
     69f:	72 65 61 64 72 66 00                                readrf.

000006a6 <cmd_help_read_rf>:
     6a6:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 61 64     [file name] read
     6b6:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     6c6:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

000006d0 <cmd_up>:
     6d0:	75 70 00                                            up.

000006d3 <cmd_help_up>:
     6d3:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     6e3:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     6f3:	76 65 20 75 70 00                                   ve up.

000006f9 <cmd_down>:
     6f9:	64 6f 77 6e 00                                      down.

000006fe <cmd_help_down>:
     6fe:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     70e:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     71e:	76 65 20 64 6f 77 6e 00                             ve down.

00000726 <cmd_spa>:
     726:	73 70 61 00                                         spa.

0000072a <cmd_help_spa>:
     72a:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     73a:	20 41 00                                             A.

0000073d <cmd_spb>:
     73d:	73 70 62 00                                         spb.

00000741 <cmd_help_spb>:
     741:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     751:	20 42 00                                             B.

00000754 <cmd_settime>:
     754:	73 65 74 74 69 6d 65 00                             settime.

0000075c <cmd_help_settime>:
     75c:	5b 68 5d 20 5b 6d 5d 20 5b 73 5d 20 73 65 74 20     [h] [m] [s] set 
     76c:	74 69 6d 65 20 28 32 34 68 20 66 6f 72 6d 61 74     time (24h format
     77c:	29 00                                               ).

0000077e <cmd_ac>:
     77e:	61 63 00                                            ac.

00000781 <cmd_help_ac>:
     781:	5b 63 68 61 6e 6e 65 6c 20 30 2d 37 5d 20 72 65     [channel 0-7] re
     791:	61 64 20 61 6e 61 6c 6f 67 20 76 61 6c 75 65 00     ad analog value.

000007a1 <cmd_enable>:
     7a1:	65 6e 61 62 6c 65 00                                enable.

000007a8 <cmd_help_enable>:
     7a8:	45 6e 61 62 6c 65 20 6d 6f 64 65 00                 Enable mode.

000007b4 <cmd_disable>:
     7b4:	64 69 73 61 62 6c 65 00                             disable.

000007bc <cmd_help_disable>:
     7bc:	56 69 65 77 20 6d 6f 64 65 00                       View mode.

000007c6 <cmd_configure>:
     7c6:	63 6f 6e 66 69 67 00                                config.

000007cd <cmd_help_configure>:
     7cd:	43 6f 6e 66 69 67 75 72 65 20 6d 6f 64 65 00        Configure mode.

000007dc <cmd_conf_ip>:
     7dc:	69 70 00                                            ip.

000007df <cmd_help_conf_ip>:
     7df:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     7ef:	41 34 5d 20 73 65 74 20 49 50 20 61 64 64 72 65     A4] set IP addre
     7ff:	73 73 00                                            ss.

00000802 <cmd_conf_udp>:
     802:	75 64 70 00                                         udp.

00000806 <cmd_help_conf_udp>:
     806:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     816:	41 34 5d 20 5b 73 72 63 20 70 6f 72 74 5d 20 7b     A4] [src port] {
     826:	64 73 74 20 70 6f 72 74 7d 20 73 65 74 20 75 64     dst port} set ud
     836:	70 20 63 6c 69 65 6e 74 20 49 50 20 61 64 64 72     p client IP addr
     846:	65 73 73 20 61 6e 64 20 70 6f 72 74 73 00           ess and ports.

00000854 <cmd_conf_ip_mask>:
     854:	6d 61 73 6b 00                                      mask.

00000859 <cmd_conf_ip_mask_help>:
     859:	5b 6d 61 73 6b 5d 20 73 65 74 20 6d 61 73 6b 00     [mask] set mask.

00000869 <cmd_conf_ip_gw>:
     869:	67 77 00                                            gw.

0000086c <cmd_conf_ip_gw_help>:
     86c:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     87c:	41 34 5d 20 73 65 74 20 64 65 66 61 75 6c 74 20     A4] set default 
     88c:	67 61 74 65 77 61 79 00                             gateway.

00000894 <cmd_conf_mac>:
     894:	6d 61 63 00                                         mac.

00000898 <cmd_help_conf_mac>:
     898:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     8a8:	41 34 5d 20 5b 41 35 5d 20 5b 41 36 5d 20 73 65     A4] [A5] [A6] se
     8b8:	74 20 4d 41 43 20 61 64 64 72 65 73 73 00           t MAC address.

000008c6 <cmd_conf_save>:
     8c6:	73 61 76 65 00                                      save.

000008cb <cmd_help_conf_save>:
     8cb:	53 61 76 65 20 63 6f 6e 66 69 67 75 72 61 74 69     Save configurati
     8db:	6f 6e 00                                            on.

000008de <cmd_ustawR>:
     8de:	73 65 74 72 00                                      setr.

000008e3 <cmd_help_ustawR>:
     8e3:	5b 76 61 6c 75 65 5d 20 73 65 74 20 72 65 73 69     [value] set resi
     8f3:	73 74 61 6e 63 65 20 76 61 6c 75 65 00              stance value.

00000900 <okStr>:
     900:	4f 4b 0d 0a 00                                      OK...

00000905 <nlStr>:
     905:	0d 0a 00                                            ...

00000908 <BladBuforaPozostaloBajtowStr>:
     908:	21 21 21 20 57 20 62 75 64 6f 72 7a 65 20 52 73     !!! W budorze Rs
     918:	34 38 35 20 70 6f 7a 6f 73 74 61 6c 6f 20 25 64     485 pozostalo %d
     928:	20 62 61 6a 74 6f 77 0d 0a 00                        bajtow...

00000932 <errorStrings>:
     932:	c8 00 d1 00 db 00 de 00 e1 00 e4 00 e7 00 fa 00     ................
     942:	21 01 40 01 63 01 82 01                             !.@.c...

0000094a <cmdListNormal>:
     94a:	3c 04 41 04 66 19 53 04 5a 04 43 1b b3 04 b8 04     <.A.f.S.Z.C.....
     95a:	f1 18 12 05 18 05 de 14 3e 05 43 05 60 10 07 06     ........>.C.`...
     96a:	0d 06 e9 18 9f 06 a6 06 46 18 a1 07 a8 07 f6 0f     ........F.......
     97a:	00 00 00 00 00 00                                   ......

00000980 <cmdListEnable>:
     980:	3c 04 41 04 66 19 53 04 5a 04 43 1b 91 04 99 04     <.A.f.S.Z.C.....
     990:	3e 18 b3 04 b8 04 f1 18 c3 04 c9 04 59 17 12 05     >...........Y...
     9a0:	18 05 de 14 3e 05 43 05 60 10 74 05 79 05 65 15     ....>.C.`.t.y.e.
     9b0:	9f 05 a5 05 d8 13 c8 05 cf 05 04 15 07 06 0d 06     ................
     9c0:	e9 18 21 06 25 06 c1 14 41 06 49 06 aa 14 6e 06     ..!.%...A.I...n.
     9d0:	75 06 2a 14 9f 06 a6 06 46 18 d0 06 d3 06 56 13     u.*.....F.....V.
     9e0:	f9 06 fe 06 e0 12 26 07 2a 07 ce 12 3d 07 41 07     ......&.*...=.A.
     9f0:	bc 12 de 08 e3 08 aa 12 54 07 5c 07 43 12 7e 07     ........T.\.C.~.
     a00:	81 07 cc 11 b4 07 bc 07 07 10 c6 07 cd 07 13 10     ................
     a10:	00 00 00 00 00 00                                   ......

00000a16 <cmdListConfigure>:
     a16:	3c 04 41 04 66 19 53 04 5a 04 43 1b b3 04 b8 04     <.A.f.S.Z.C.....
     a26:	f1 18 54 07 5c 07 43 12 dc 07 df 07 74 11 54 08     ..T.\.C.....t.T.
     a36:	59 08 54 11 69 08 6c 08 fc 10 02 08 06 08 7f 10     Y.T.i.l.........
     a46:	94 08 98 08 29 10 c6 08 cb 08 24 10 a1 07 a8 07     ....).....$.....
     a56:	f6 0f b4 07 bc 07 07 10 00 00 00 00 00 00           ..............

00000a64 <__c.3459>:
     a64:	57 61 72 74 6f 73 63 20 70 72 6f 62 6b 69 20 6e     Wartosc probki n
     a74:	61 20 77 65 6a 73 63 69 75 20 25 64 3a 20 25 64     a wejsciu %d: %d
     a84:	0d 0a 00                                            ...

00000a87 <__c.3577>:
     a87:	58 6d 6f 64 65 6d 3a 20 72 6f 7a 70 6f 63 7a 79     Xmodem: rozpoczy
     a97:	6e 61 6e 69 65 20 6f 64 62 69 6f 72 75 0d 0a 00     nanie odbioru...

00000aa7 <__c.3329>:
     aa7:	75 64 70 00                                         udp.

00000aab <__c.3327>:
     aab:	74 63 70 00                                         tcp.

00000aaf <__c.3325>:
     aaf:	69 63 6d 70 00                                      icmp.

00000ab4 <__c.3323>:
     ab4:	69 70 00                                            ip.

00000ab7 <__c.3321>:
     ab7:	61 72 70 00                                         arp.

00000abb <__c.3319>:
     abb:	75 64 70 00                                         udp.

00000abf <__c.3317>:
     abf:	74 63 70 00                                         tcp.

00000ac3 <__c.3315>:
     ac3:	69 63 6d 70 00                                      icmp.

00000ac8 <__c.3313>:
     ac8:	69 70 00                                            ip.

00000acb <__c.3311>:
     acb:	61 72 70 00                                         arp.

00000acf <__c.3281>:
     acf:	41 6b 74 75 61 6c 6e 79 20 63 7a 61 73 20 25 64     Aktualny czas %d
     adf:	3a 25 64 3a 25 64 0d 0a 00                          :%d:%d...

00000ae8 <__c.3240>:
     ae8:	0d 0a 00                                            ...

00000aeb <__c.3238>:
     aeb:	0d 0a 00                                            ...

00000aee <__c.3236>:
     aee:	0d 0a 00                                            ...

00000af1 <__c.3234>:
     af1:	0d 0a 00                                            ...

00000af4 <__c.3231>:
     af4:	46 72 65 65 52 74 6f 73 2b 20 76 65 72 20 30 2e     FreeRtos+ ver 0.
     b04:	33 31 20 62 75 69 6c 64 3a 20 41 75 67 20 31 39     31 build: Aug 19
     b14:	20 32 30 31 31 2c 20 31 35 3a 30 33 3a 31 36 0d      2011, 15:03:16.
     b24:	0a 00                                               ..

00000b26 <__c.3031>:
     b26:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ================
     b36:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d 0a     ==============..
	...

00000b47 <__c.3029>:
     b47:	55 6e 6b 6e 6f 77 6e 20 70 61 63 6b 65 74 0d 0a     Unknown packet..
	...

00000b58 <__c.3026>:
     b58:	49 50 20 73 74 61 63 6b 20 72 65 61 64 79 20 0d     IP stack ready .
     b68:	0a 00                                               ..

00000b6a <__c.1665>:
     b6a:	52 65 73 74 61 72 74 0d 0a 00                       Restart...

00000b74 <CmdlinePromptNormal>:
     b74:	44 6f 6d 4f 73 3e 00                                DomOs>.

00000b7b <CmdlinePromptEnable>:
     b7b:	44 6f 6d 4f 73 23 00                                DomOs#.

00000b82 <CmdlinePromptConfigure>:
     b82:	44 6f 6d 4f 73 40 00                                DomOs@.

00000b89 <CmdlineNotice>:
     b89:	63 6d 64 6c 69 6e 65 3a 20 00                       cmdline: .

00000b93 <CmdlineCmdNotFound>:
     b93:	23 20 6e 6b 00                                      # nk.

00000b98 <__c.3375>:
     b98:	0d 0a 00                                            ...

00000b9b <__c.3373>:
     b9b:	09 00                                               ..

00000b9d <__c.3257>:
     b9d:	4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 61 6c     Operation not al
     bad:	6c 6f 77 65 64 0d 0a 00                             lowed...

00000bb5 <__c.3254>:
     bb5:	4f 70 65 72 61 74 69 6f 6e 20 66 61 69 6c 65 64     Operation failed
     bc5:	0d 0a 00                                            ...

00000bc8 <__c.3251>:
     bc8:	0d 0a 00                                            ...

00000bcb <__c.3249>:
     bcb:	20 00                                                .

00000bcd <__c.3247>:
     bcd:	53 79 6e 74 61 78 20 45 72 72 6f 72 2e 20 55 73     Syntax Error. Us
     bdd:	65 3a 20 00                                         e: .

00000be1 <__c.3243>:
     be1:	4f 4b 0d 0a 00                                      OK...

00000be6 <__c.3272>:
     be6:	09 4d 41 41 44 52 35 20 30 78 25 78 0d 0a 00        .MAADR5 0x%x...

00000bf5 <__c.3270>:
     bf5:	09 4d 41 41 44 52 34 20 30 78 25 78 0d 0a 00        .MAADR4 0x%x...

00000c04 <__c.3268>:
     c04:	09 4d 41 41 44 52 33 20 30 78 25 78 0d 0a 00        .MAADR3 0x%x...

00000c13 <__c.3266>:
     c13:	09 4d 41 41 44 52 32 20 30 78 25 78 0d 0a 00        .MAADR2 0x%x...

00000c22 <__c.3264>:
     c22:	09 4d 41 41 44 52 31 20 30 78 25 78 0d 0a 00        .MAADR1 0x%x...

00000c31 <__c.3262>:
     c31:	09 4d 41 41 44 52 30 20 30 78 25 78 0d 0a 00        .MAADR0 0x%x...

00000c40 <__c.3260>:
     c40:	45 4e 43 32 38 6a 36 30 20 73 74 61 6e 20 72 65     ENC28j60 stan re
     c50:	6a 65 73 74 72 6f 77 3a 0d 0a 00                    jestrow:...

00000c5b <__c.1814>:
     c5b:	4e 49 43 20 72 65 67 20 64 75 6d 70 20 6e 6f 74     NIC reg dump not
     c6b:	20 69 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00         implemented...

00000c7a <__c.1725>:
     c7a:	0d 0a 00                                            ...

00000c7d <__c.1723>:
     c7d:	55 52 47 20 00                                      URG .

00000c82 <__c.1721>:
     c82:	41 43 4b 20 00                                      ACK .

00000c87 <__c.1719>:
     c87:	50 53 48 20 00                                      PSH .

00000c8c <__c.1717>:
     c8c:	52 53 54 20 00                                      RST .

00000c91 <__c.1715>:
     c91:	53 59 4e 20 00                                      SYN .

00000c96 <__c.1713>:
     c96:	46 49 4e 20 00                                      FIN .

00000c9b <__c.1711>:
     c9b:	46 6c 61 67 73 20 20 20 3a 20 00                    Flags   : .

00000ca6 <__c.1709>:
     ca6:	41 63 6b 20 4e 75 6d 20 3a 20 30 78 25 78 0d 0a     Ack Num : 0x%x..
	...

00000cb7 <__c.1707>:
     cb7:	53 65 71 20 4e 75 6d 20 3a 20 30 78 25 78 00        Seq Num : 0x%x.

00000cc6 <__c.1705>:
     cc6:	44 73 74 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Dst Port: %d...

00000cd5 <__c.1703>:
     cd5:	53 72 63 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Src Port: %d...

00000ce4 <__c.1701>:
     ce4:	54 43 50 20 48 65 61 64 65 72 0d 0a 00              TCP Header...

00000cf1 <__c.1684>:
     cf1:	0d 0a 00                                            ...

00000cf4 <__c.1682>:
     cf4:	44 65 73 74 20 20 49 50 3a 20 00                    Dest  IP: .

00000cff <__c.1680>:
     cff:	0d 0a 00                                            ...

00000d02 <__c.1678>:
     d02:	53 6f 75 72 63 65 49 50 3a 20 00                    SourceIP: .

00000d0d <__c.1676>:
     d0d:	50 72 6f 74 6f 63 6f 6c 3a 20 25 64 0d 0a 00        Protocol: %d...

00000d1c <__c.1674>:
     d1c:	50 72 6f 74 6f 63 6f 6c 3a 20 55 44 50 0d 0a 00     Protocol: UDP...

00000d2c <__c.1672>:
     d2c:	50 72 6f 74 6f 63 6f 6c 3a 20 54 43 50 0d 0a 00     Protocol: TCP...

00000d3c <__c.1670>:
     d3c:	50 72 6f 74 6f 63 6f 6c 3a 20 49 43 4d 50 0d 0a     Protocol: ICMP..
	...

00000d4d <__c.1668>:
     d4d:	4c 65 6e 67 74 68 20 20 3a 20 25 64 0d 0a 00        Length  : %d...

00000d5c <__c.1666>:
     d5c:	56 65 72 20 20 20 20 20 3a 20 25 64 0d 0a 00        Ver     : %d...

00000d6b <__c.1664>:
     d6b:	49 50 20 48 65 61 64 65 72 0d 0a 00                 IP Header...

00000d77 <__c.1655>:
     d77:	2d 3e 44 53 54 3a 00                                ->DST:.

00000d7e <__c.1653>:
     d7e:	20 53 52 43 3a 00                                    SRC:.

00000d84 <__c.1651>:
     d84:	45 74 68 20 50 61 63 6b 65 74 20 54 79 70 65 3a     Eth Packet Type:
     d94:	20 30 78 25 78 00                                    0x%x.

00000d9a <__c.1633>:
     d9a:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

00000da6 <__c.1615>:
     da6:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
     db6:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

00000dc4 <__c.2378>:
     dc4:	0d 0a 00                                            ...

00000dc7 <__c.2376>:
     dc7:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00000dd2 <__c.2374>:
     dd2:	0d 0a 00                                            ...

00000dd5 <__c.2372>:
     dd5:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00000de0 <__c.2370>:
     de0:	0d 0a 00                                            ...

00000de3 <__c.2368>:
     de3:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00000dee <__c.2351>:
     dee:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     dfe:	6c 65 28 6c 65 6e 2d 45 54 48 5f 48 45 41 44 45     le(len-ETH_HEADE
     e0e:	52 5f 4c 45 4e 2c 20 26 64 61 74 61 5b 45 54 48     R_LEN, &data[ETH
     e1e:	5f 48 45 41 44 45 52 5f 4c 45 4e 5d 29 3b 00        _HEADER_LEN]);.

00000e2d <__c.2349>:
     e2d:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     e3d:	6c 65 28 45 54 48 5f 48 45 41 44 45 52 5f 4c 45     le(ETH_HEADER_LE
     e4d:	4e 2c 20 26 64 61 74 61 5b 30 5d 29 3b 00           N, &data[0]);.

00000e5b <__c.2347>:
     e5b:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     e6b:	74 20 74 6f 20 67 61 74 65 77 61 79 0d 0a 00        t to gateway...

00000e7a <__c.2345>:
     e7a:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     e8a:	74 20 6f 6e 20 6c 6f 63 61 6c 20 6e 65 74 0d 0a     t on local net..
	...

00000e9b <__c.2303>:
     e9b:	4e 45 54 20 52 78 3a 20 55 6e 6b 6e 6f 77 6e 20     NET Rx: Unknown 
     eab:	49 50 20 70 61 63 6b 65 74 0d 0a 00                 IP packet...

00000eb7 <__c.2301>:
     eb7:	4e 45 54 20 52 78 3a 20 54 43 50 2f 49 50 20 70     NET Rx: TCP/IP p
     ec7:	61 63 6b 65 74 0d 0a 00                             acket...

00000ecf <__c.2299>:
     ecf:	4e 45 54 20 52 78 3a 20 55 44 50 2f 49 50 20 70     NET Rx: UDP/IP p
     edf:	61 63 6b 65 74 0d 0a 00                             acket...

00000ee7 <__c.2297>:
     ee7:	4e 45 54 20 52 78 3a 20 49 43 4d 50 2f 49 50 20     NET Rx: ICMP/IP 
     ef7:	70 61 63 6b 65 74 0d 0a 00                          packet...

00000f00 <__c.2346>:
     f00:	43 6f 64 65 20 20 20 3a 20 30 78 25 78 0d 0a 00     Code   : 0x%x...

00000f10 <__c.2344>:
     f10:	0d 0a 00                                            ...

00000f13 <__c.2341>:
     f13:	45 43 48 4f 20 52 45 50 4c 59 00                    ECHO REPLY.

00000f1e <__c.2337>:
     f1e:	45 43 48 4f 20 52 45 51 55 45 53 54 00              ECHO REQUEST.

00000f2b <__c.2334>:
     f2b:	54 79 70 65 20 20 20 3a 20 00                       Type   : .

00000f35 <__c.2332>:
     f35:	0d 0a 00                                            ...

00000f38 <__c.2330>:
     f38:	44 73 74 49 70 41 64 64 72 3a 20 00                 DstIpAddr: .

00000f44 <__c.2328>:
     f44:	0d 0a 00                                            ...

00000f47 <__c.2326>:
     f47:	53 72 63 49 70 41 64 64 72 3a 20 00                 SrcIpAddr: .

00000f53 <__c.2324>:
     f53:	49 43 4d 50 20 50 61 63 6b 65 74 3a 0d 0a 00        ICMP Packet:...

00000f62 <__c.2301>:
     f62:	53 65 6e 64 69 6e 67 20 49 43 4d 50 20 50 4f 4e     Sending ICMP PON
     f72:	47 0d 0a 00                                         G...

00000f76 <__c.2298>:
     f76:	52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72 65     Received ICMP re
     f86:	71 75 65 73 74 3a 20 00                             quest: .

00000f8e <__c.2288>:
     f8e:	55 6e 6b 6e 6f 77 6e 20 49 43 4d 50 20 74 79 70     Unknown ICMP typ
     f9e:	65 52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72     eReceived ICMP r
     fae:	65 71 75 65 73 74 3a 20 00                          equest: .

00000fb7 <__c.2418>:
     fb7:	0d 0a 00                                            ...

00000fba <__c.2416>:
     fba:	20 20 00                                              .

00000fbd <__c.2414>:
     fbd:	25 33 64 20 20 00                                   %3d  .

00000fc3 <__c.2411>:
     fc3:	0d 0a 00                                            ...

00000fc6 <__c.2409>:
     fc6:	20 20 00                                              .

00000fc9 <__c.2407>:
     fc9:	20 4d 59 20 20 00                                    MY  .

00000fcf <__c.2405>:
     fcf:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fdf:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fef:	2d 2d 2d 0d 0a 00                                   ---...

00000ff5 <__c.2403>:
     ff5:	54 69 6d 65 20 45 74 68 20 41 64 64 72 65 73 73     Time Eth Address
    1005:	20 20 20 20 20 20 20 20 49 50 20 41 64 64 72 65             IP Addre
    1015:	73 73 0d 0a 00                                      ss...

0000101a <__c.2390>:
    101a:	0d 0a 00                                            ...

0000101d <__c.2388>:
    101d:	44 73 74 50 72 6f 74 6f 41 64 64 72 3a 20 00        DstProtoAddr: .

0000102c <__c.2386>:
    102c:	0d 0a 00                                            ...

0000102f <__c.2384>:
    102f:	44 73 74 48 77 41 64 64 72 20 20 20 3a 20 00        DstHwAddr   : .

0000103e <__c.2382>:
    103e:	0d 0a 00                                            ...

00001041 <__c.2380>:
    1041:	53 72 63 50 72 6f 74 6f 41 64 64 72 3a 20 00        SrcProtoAddr: .

00001050 <__c.2378>:
    1050:	0d 0a 00                                            ...

00001053 <__c.2376>:
    1053:	53 72 63 48 77 41 64 64 72 20 20 20 3a 20 00        SrcHwAddr   : .

00001062 <__c.2374>:
    1062:	0d 0a 00                                            ...

00001065 <__c.2372>:
    1065:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

0000106d <__c.2370>:
    106d:	52 45 50 4c 59 00                                   REPLY.

00001073 <__c.2368>:
    1073:	52 45 51 55 45 53 54 00                             REQUEST.

0000107b <__c.2366>:
    107b:	4f 70 65 72 61 74 69 6f 6e 20 20 20 3a 20 00        Operation   : .

0000108a <__c.2364>:
    108a:	41 52 50 20 50 61 63 6b 65 74 3a 0d 0a 00           ARP Packet:...

00001098 <__c.2314>:
    1098:	0d 0a 00                                            ...

0000109b <__c.2312>:
    109b:	20 49 50 3a 20 00                                    IP: .

000010a1 <__c.2310>:
    10a1:	41 52 50 20 49 50 20 69 6e 20 4d 41 43 3a 20 00     ARP IP in MAC: .

000010b1 <__c.2295>:
    10b1:	53 65 6e 64 69 6e 67 20 41 52 50 20 52 65 70 6c     Sending ARP Repl
    10c1:	79 0d 0a 00                                         y...

000010c5 <__c.2293>:
    10c5:	52 65 63 65 69 76 65 64 20 41 52 50 20 52 65 71     Received ARP Req
    10d5:	75 65 73 74 0d 0a 00                                uest...

000010dc <__c.2402>:
    10dc:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
    10ec:	6e 74 65 64 0d 0a 00                                nted...

000010f3 <__c.2352>:
    10f3:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1103:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
    1113:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
    1123:	74 0d 0a 00                                         t...

00001127 <__c.2350>:
    1127:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1137:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    1147:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
    1157:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
    1167:	49 53 48 45 44 0d 0a 00                             ISHED...

0000116f <__c.2348>:
    116f:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    117f:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
    118f:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
    119f:	74 0d 0a 00                                         t...

000011a3 <__c.2346>:
    11a3:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    11b3:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    11c3:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
    11d3:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
    11e3:	0a 00                                               ..

000011e5 <__c.2315>:
    11e5:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
    11f5:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
    1205:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

0000120f <__c.2310>:
    120f:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    121f:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
    122f:	54 45 4e 0d 0a 00                                   TEN...

00001235 <__c.2305>:
    1235:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    1245:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

00001251 <__c.2383>:
    1251:	25 64 0d 0a 00                                      %d...

00001256 <__c.2381>:
    1256:	41 4e 59 0d 0a 00                                   ANY...

0000125c <__c.2379>:
    125c:	0d 0a 20 20 73 72 63 20 70 6f 72 74 20 20 20 20     ..  src port    
    126c:	3a 20 25 64 0d 0a 20 20 64 73 74 20 70 6f 72 74     : %d..  dst port
    127c:	20 20 20 20 3a 20 00                                    : .

00001283 <__c.2377>:
    1283:	0d 0a 20 20 49 50 20 20 20 20 20 20 20 20 20 20     ..  IP          
    1293:	3a 20 00                                            : .

00001296 <__c.2375>:
    1296:	55 44 50 20 63 6f 6e 66 69 67 3a 00                 UDP config:.

000012a2 <__c.2329>:
    12a2:	0d 0a 00                                            ...

000012a5 <__c.2324>:
    12a5:	55 44 50 20 54 58 20 62 75 66 66 65 72 20 62 75     UDP TX buffer bu
    12b5:	73 79 0d 0a 00                                      sy...

000012ba <__c.2322>:
    12ba:	30 78 25 32 78 0d 0a 00                             0x%2x...

000012c2 <__c.2320>:
    12c2:	52 65 63 65 69 76 65 64 20 64 61 74 61 3a 20 00     Received data: .

000012d2 <__c.2317>:
    12d2:	50 72 6f 63 2e 20 55 44 50 20 70 61 63 6b 65 74     Proc. UDP packet
    12e2:	20 28 64 61 74 61 20 6c 65 6e 67 74 68 20 25 64      (data length %d
    12f2:	29 0d 0a 00                                         )...

000012f6 <__c.2300>:
    12f6:	53 65 6e 64 69 6e 67 20 55 44 50 20 70 61 63 6b     Sending UDP pack
    1306:	65 74 20 28 64 61 74 61 20 6c 65 6e 67 74 68 20     et (data length 
    1316:	25 64 29 0d 0a 00                                   %d)...

0000131c <__c.1972>:
    131c:	49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78 25     IPv6 addr: %02x%
    132c:	30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30 32     02x:%02x%02x:%02
    133c:	78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25     x%02x:%02x%02x:%
    134c:	30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78     02x%02x:%02x%02x
    135c:	3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30     :%02x%02x:%02x%0
    136c:	32 78 20 0d 0a 00                                   2x ...

00001372 <__c.1970>:
    1372:	44 65 73 74 69 6e 61 74 69 6f 6e 20 61 64 64 72     Destination addr
    1382:	65 73 73 3a 20 09 00                                ess: ..

00001389 <__c.1968>:
    1389:	49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78 25     IPv6 addr: %02x%
    1399:	30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30 32     02x:%02x%02x:%02
    13a9:	78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25     x%02x:%02x%02x:%
    13b9:	30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78     02x%02x:%02x%02x
    13c9:	3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30     :%02x%02x:%02x%0
    13d9:	32 78 20 0d 0a 00                                   2x ...

000013df <__c.1966>:
    13df:	53 6f 75 72 63 65 20 61 64 64 72 65 73 73 3a 20     Source address: 
    13ef:	09 00                                               ..

000013f1 <__c.1964>:
    13f1:	25 64 20 0a 0d 00                                   %d ...

000013f7 <__c.1962>:
    13f7:	50 61 79 6c 6f 61 64 20 4c 65 6e 67 74 68 3a 20     Payload Length: 
    1407:	09 00                                               ..

00001409 <__c.1960>:
    1409:	25 64 20 0a 0d 00                                   %d ...

0000140f <__c.1958>:
    140f:	46 6c 6f 77 20 4c 61 62 65 6c 3a 20 09 09 00        Flow Label: ...

0000141e <__c.1956>:
    141e:	25 64 20 0a 0d 00                                   %d ...

00001424 <__c.1954>:
    1424:	54 72 61 66 66 69 63 20 43 6c 61 73 73 3a 20 09     Traffic Class: .
    1434:	09 00                                               ..

00001436 <__c.1952>:
    1436:	25 64 20 0a 0d 00                                   %d ...

0000143c <__c.1950>:
    143c:	56 65 72 73 69 6f 6e 3a 20 09 09 00                 Version: ...

00001448 <__c.1938>:
    1448:	0d 0a 00                                            ...

0000144b <__c.1933>:
    144b:	25 30 32 78 3a 00                                   %02x:.

00001451 <__c.1931>:
    1451:	0d 0a 00                                            ...

00001454 <__c.1928>:
    1454:	49 50 76 36 20 48 65 61 64 65 72 0d 0a 00           IPv6 Header...

00001462 <__c.1919>:
    1462:	49 50 76 36 20 70 61 63 6b 65 74 20 69 6e 2e 0d     IPv6 packet in..
    1472:	0a 00                                               ..

00001474 <statusRollerDescStr>:
    1474:	20 25 64 20 72 6f 6c 6c 65 72 20 64 72 69 76 65      %d roller drive
    1484:	72 3a 20 72 6f 6c 6c 65 72 20 31 20 70 6f 73 69     r: roller 1 posi
    1494:	74 69 6f 6e 20 25 64 2c 20 72 6f 6c 6c 65 72 20     tion %d, roller 
    14a4:	32 20 70 6f 73 69 74 69 6f 6e 20 25 64 00           2 position %d.

000014b2 <statusRollerDescStr2>:
    14b2:	2c 20 66 69 72 6d 77 61 72 65 20 25 73 0d 0a 00     , firmware %s...

000014c2 <__c.3234>:
    14c2:	0d 0a 4f 4b 0d 0a 00                                ..OK...

000014c9 <__c.3225>:
    14c9:	62 6f 6f 74 6c 6f 61 64 65 72 20 6e 69 65 20 72     bootloader nie r
    14d9:	6f 7a 70 6f 63 7a 61 6c 20 6f 64 62 69 6f 72 75     ozpoczal odbioru
    14e9:	20 64 61 6e 79 63 68 0d 0a 00                        danych...

000014f3 <__c.3223>:
    14f3:	6e 61 20 75 72 7a 61 64 7a 65 6e 69 75 20 77 67     na urzadzeniu wg
    1503:	72 61 6e 79 20 6a 65 73 74 20 74 79 6c 6b 6f 20     rany jest tylko 
    1513:	62 6f 6f 74 6c 6f 61 64 65 72 0d 0a 00              bootloader...

00001520 <__c.3221>:
    1520:	72 46 4c 41 53 48 20 74 69 6d 65 6f 75 74 0d 0a     rFLASH timeout..
	...

00001532 <__ctors_end>:
    1532:	11 24       	eor	r1, r1
    1534:	1f be       	out	0x3f, r1	; 63
    1536:	cf ef       	ldi	r28, 0xFF	; 255
    1538:	d0 e1       	ldi	r29, 0x10	; 16
    153a:	de bf       	out	0x3e, r29	; 62
    153c:	cd bf       	out	0x3d, r28	; 61

0000153e <__do_copy_data>:
    153e:	11 e0       	ldi	r17, 0x01	; 1
    1540:	a0 e0       	ldi	r26, 0x00	; 0
    1542:	b1 e0       	ldi	r27, 0x01	; 1
    1544:	e0 e9       	ldi	r30, 0x90	; 144
    1546:	f1 ec       	ldi	r31, 0xC1	; 193
    1548:	00 e0       	ldi	r16, 0x00	; 0
    154a:	0b bf       	out	0x3b, r16	; 59
    154c:	02 c0       	rjmp	.+4      	; 0x1552 <__do_copy_data+0x14>
    154e:	07 90       	elpm	r0, Z+
    1550:	0d 92       	st	X+, r0
    1552:	a8 38       	cpi	r26, 0x88	; 136
    1554:	b1 07       	cpc	r27, r17
    1556:	d9 f7       	brne	.-10     	; 0x154e <__do_copy_data+0x10>

00001558 <initExternalMem>:
    1558:	85 b7       	in	r24, 0x35	; 53
    155a:	80 68       	ori	r24, 0x80	; 128
    155c:	85 bf       	out	0x35, r24	; 53
    155e:	85 b7       	in	r24, 0x35	; 53
    1560:	8e 60       	ori	r24, 0x0E	; 14
    1562:	85 bf       	out	0x35, r24	; 53

00001564 <__do_clear_bss>:
    1564:	1f e0       	ldi	r17, 0x0F	; 15
    1566:	a8 e8       	ldi	r26, 0x88	; 136
    1568:	b1 e0       	ldi	r27, 0x01	; 1
    156a:	01 c0       	rjmp	.+2      	; 0x156e <.do_clear_bss_start>

0000156c <.do_clear_bss_loop>:
    156c:	1d 92       	st	X+, r1

0000156e <.do_clear_bss_start>:
    156e:	a9 3e       	cpi	r26, 0xE9	; 233
    1570:	b1 07       	cpc	r27, r17
    1572:	e1 f7       	brne	.-8      	; 0x156c <.do_clear_bss_loop>
    1574:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <main>
    1578:	0c 94 c6 60 	jmp	0xc18c	; 0xc18c <_exit>

0000157c <__bad_interrupt>:
    157c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001580 <vApplicationTickHook>:
}

void vApplicationTickHook( void )
{
  static uint8_t tickCntr = configTICK_RATE_HZ;
  if (--tickCntr == 0)
    1580:	80 91 00 01 	lds	r24, 0x0100
    1584:	81 50       	subi	r24, 0x01	; 1
    1586:	80 93 00 01 	sts	0x0100, r24
    158a:	88 23       	and	r24, r24
    158c:	29 f4       	brne	.+10     	; 0x1598 <vApplicationTickHook+0x18>
  {
    tickCntr = configTICK_RATE_HZ;
    158e:	84 e6       	ldi	r24, 0x64	; 100
    1590:	80 93 00 01 	sts	0x0100, r24
    arpTimer();    
    1594:	0e 94 df 36 	call	0x6dbe	; 0x6dbe <arpTimer>
    1598:	08 95       	ret

0000159a <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
    159a:	0e 94 c0 56 	call	0xad80	; 0xad80 <vCoRoutineSchedule>
    159e:	fd cf       	rjmp	.-6      	; 0x159a <vApplicationIdleHook>

000015a0 <main>:
FILE udpStream;

streamBuffers_t udpBuffers;

portSHORT main( void )
{
    15a0:	af 92       	push	r10
    15a2:	bf 92       	push	r11
    15a4:	cf 92       	push	r12
    15a6:	df 92       	push	r13
    15a8:	ef 92       	push	r14
    15aa:	ff 92       	push	r15
    15ac:	0f 93       	push	r16
    15ae:	1f 93       	push	r17
  ramDyskInit();              //Inicjalizacja Ram dysku
    15b0:	0e 94 cc 1f 	call	0x3f98	; 0x3f98 <ramDyskInit>
  hardwareInit();
    15b4:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <hardwareInit>
  spiInit(disableAllSpiDevices);
    15b8:	88 e8       	ldi	r24, 0x88	; 136
    15ba:	9d e0       	ldi	r25, 0x0D	; 13
    15bc:	0e 94 b2 1c 	call	0x3964	; 0x3964 <spiInit>

// VTY on serial  
  xSerialPortInitMinimal(); 
    15c0:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <xSerialPortInitMinimal>
  CLIStateSerialUsb  = xmalloc(sizeof(cmdState_t));
    15c4:	83 e2       	ldi	r24, 0x23	; 35
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    15cc:	90 93 9f 0e 	sts	0x0E9F, r25
    15d0:	80 93 9e 0e 	sts	0x0E9E, r24
  CLIStateSerialUdp  = xmalloc(sizeof(cmdState_t));
    15d4:	83 e2       	ldi	r24, 0x23	; 35
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    15dc:	90 93 66 0f 	sts	0x0F66, r25
    15e0:	80 93 65 0f 	sts	0x0F65, r24


//  cmdStateClear(newCmdState);
  
  sensorsTaskInit();
    15e4:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <sensorsTaskInit>
  loadConfiguration();
    15e8:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <loadConfiguration>

  initQueueStreamUSB(&usbStream);
    15ec:	0b e6       	ldi	r16, 0x6B	; 107
    15ee:	1e e0       	ldi	r17, 0x0E	; 14
    15f0:	c8 01       	movw	r24, r16
    15f2:	0e 94 63 0b 	call	0x16c6	; 0x16c6 <initQueueStreamUSB>
  VtyInit(CLIStateSerialUsb, &usbStream);
    15f6:	80 91 9e 0e 	lds	r24, 0x0E9E
    15fa:	90 91 9f 0e 	lds	r25, 0x0E9F
    15fe:	b8 01       	movw	r22, r16
    1600:	0e 94 aa 1b 	call	0x3754	; 0x3754 <VtyInit>

  udpInit();
    1604:	0e 94 30 40 	call	0x8060	; 0x8060 <udpInit>
  socketInit();
    1608:	0e 94 96 3d 	call	0x7b2c	; 0x7b2c <socketInit>
  initQueueStream(&udpStream, &udpBuffers, udpSocket->Rx, udpSocket->Tx);
    160c:	e0 91 a2 0e 	lds	r30, 0x0EA2
    1610:	f0 91 a3 0e 	lds	r31, 0x0EA3
    1614:	0e e8       	ldi	r16, 0x8E	; 142
    1616:	1e e0       	ldi	r17, 0x0E	; 14
    1618:	42 85       	ldd	r20, Z+10	; 0x0a
    161a:	53 85       	ldd	r21, Z+11	; 0x0b
    161c:	24 85       	ldd	r18, Z+12	; 0x0c
    161e:	35 85       	ldd	r19, Z+13	; 0x0d
    1620:	c8 01       	movw	r24, r16
    1622:	6a ec       	ldi	r22, 0xCA	; 202
    1624:	7e e0       	ldi	r23, 0x0E	; 14
    1626:	0e 94 e2 2d 	call	0x5bc4	; 0x5bc4 <initQueueStream>
  VtyInit(CLIStateSerialUdp, &udpStream);
    162a:	80 91 65 0f 	lds	r24, 0x0F65
    162e:	90 91 66 0f 	lds	r25, 0x0F66
    1632:	b8 01       	movw	r22, r16
    1634:	0e 94 aa 1b 	call	0x3754	; 0x3754 <VtyInit>
  
  xTaskCreate(encTask,        NULL /*"ENC"    */, STACK_SIZE_ENC,       (void *)CLIStateSerialUsb->myStdInOut, 0, &xHandleEnc);
    1638:	e0 91 9e 0e 	lds	r30, 0x0E9E
    163c:	f0 91 9f 0e 	lds	r31, 0x0E9F
    1640:	22 8d       	ldd	r18, Z+26	; 0x1a
    1642:	33 8d       	ldd	r19, Z+27	; 0x1b
    1644:	8b eb       	ldi	r24, 0xBB	; 187
    1646:	9b e1       	ldi	r25, 0x1B	; 27
    1648:	60 e0       	ldi	r22, 0x00	; 0
    164a:	70 e0       	ldi	r23, 0x00	; 0
    164c:	44 ef       	ldi	r20, 0xF4	; 244
    164e:	51 e0       	ldi	r21, 0x01	; 1
    1650:	00 e0       	ldi	r16, 0x00	; 0
    1652:	fe e4       	ldi	r31, 0x4E	; 78
    1654:	ef 2e       	mov	r14, r31
    1656:	ff e0       	ldi	r31, 0x0F	; 15
    1658:	ff 2e       	mov	r15, r31
    165a:	cc 24       	eor	r12, r12
    165c:	dd 24       	eor	r13, r13
    165e:	aa 24       	eor	r10, r10
    1660:	bb 24       	eor	r11, r11
    1662:	0e 94 7a 51 	call	0xa2f4	; 0xa2f4 <xTaskGenericCreate>
  xTaskCreate(vTaskVTYusb,    NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUsb),            1, &xHandleVTY_USB);
    1666:	20 91 9e 0e 	lds	r18, 0x0E9E
    166a:	30 91 9f 0e 	lds	r19, 0x0E9F
    166e:	85 e5       	ldi	r24, 0x55	; 85
    1670:	9c e1       	ldi	r25, 0x1C	; 28
    1672:	60 e0       	ldi	r22, 0x00	; 0
    1674:	70 e0       	ldi	r23, 0x00	; 0
    1676:	4c eb       	ldi	r20, 0xBC	; 188
    1678:	52 e0       	ldi	r21, 0x02	; 2
    167a:	01 e0       	ldi	r16, 0x01	; 1
    167c:	ea eb       	ldi	r30, 0xBA	; 186
    167e:	ee 2e       	mov	r14, r30
    1680:	ee e0       	ldi	r30, 0x0E	; 14
    1682:	fe 2e       	mov	r15, r30
    1684:	0e 94 7a 51 	call	0xa2f4	; 0xa2f4 <xTaskGenericCreate>
  //xTaskCreate(vTaskVTYsocket, NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUdp),            1, &xHandleVTY_UDP);
  //xTaskCreate(sensorsTask,    NULL /*"Sensors"*/, STACK_SIZE_SENSORS,   NULL,                                   1, &xHandleSensors);
  vTaskStartScheduler();
    1688:	0e 94 97 52 	call	0xa52e	; 0xa52e <vTaskStartScheduler>
  return 0;
}
    168c:	80 e0       	ldi	r24, 0x00	; 0
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	1f 91       	pop	r17
    1692:	0f 91       	pop	r16
    1694:	ff 90       	pop	r15
    1696:	ef 90       	pop	r14
    1698:	df 90       	pop	r13
    169a:	cf 90       	pop	r12
    169c:	bf 90       	pop	r11
    169e:	af 90       	pop	r10
    16a0:	08 95       	ret

000016a2 <saveConfiguration>:
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
}

void saveConfiguration(void)
{
  saveNic();
    16a2:	0e 94 7e 2e 	call	0x5cfc	; 0x5cfc <saveNic>
  ipSaveConfig();
    16a6:	0e 94 f0 34 	call	0x69e0	; 0x69e0 <ipSaveConfig>
  udpSaveConfig();
    16aa:	0e 94 7c 3e 	call	0x7cf8	; 0x7cf8 <udpSaveConfig>
}
    16ae:	08 95       	ret

000016b0 <loadConfiguration>:
                                                                                       {LOCK_SENS_3_ENA, LOCK_SENS_3_THR, 0, 0},
                                                                                       {LOCK_SENS_4_ENA, LOCK_SENS_4_THR, 0, 0}};

void loadConfiguration(void)
{
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
    16b0:	80 91 a0 0e 	lds	r24, 0x0EA0
    16b4:	90 91 a1 0e 	lds	r25, 0x0EA1
    16b8:	60 e0       	ldi	r22, 0x00	; 0
    16ba:	70 e0       	ldi	r23, 0x00	; 0
    16bc:	48 e1       	ldi	r20, 0x18	; 24
    16be:	50 e0       	ldi	r21, 0x00	; 0
    16c0:	0e 94 bf 5f 	call	0xbf7e	; 0xbf7e <__eerd_block_m128>
}
    16c4:	08 95       	ret

000016c6 <initQueueStreamUSB>:
#define debug 1

/*-----------------------------------------------------------*/

void initQueueStreamUSB(FILE *stream)
{
    16c6:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
    16c8:	8d e2       	ldi	r24, 0x2D	; 45
    16ca:	9c e0       	ldi	r25, 0x0C	; 12
    16cc:	91 87       	std	Z+9, r25	; 0x09
    16ce:	80 87       	std	Z+8, r24	; 0x08
    16d0:	89 e1       	ldi	r24, 0x19	; 25
    16d2:	9d e0       	ldi	r25, 0x0D	; 13
    16d4:	93 87       	std	Z+11, r25	; 0x0b
    16d6:	82 87       	std	Z+10, r24	; 0x0a
    16d8:	83 e0       	ldi	r24, 0x03	; 3
    16da:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, NULL);
    16dc:	15 86       	std	Z+13, r1	; 0x0d
    16de:	14 86       	std	Z+12, r1	; 0x0c
  return;
}
    16e0:	08 95       	ret

000016e2 <__vector_20>:
    taskYIELD();
  }
}

ISR(USART0_TX_vect)
{
    16e2:	1f 92       	push	r1
    16e4:	0f 92       	push	r0
    16e6:	0f b6       	in	r0, 0x3f	; 63
    16e8:	0f 92       	push	r0
    16ea:	11 24       	eor	r1, r1
    16ec:	8f 93       	push	r24
  if (!vIsInterruptRs485On())
    16ee:	55 99       	sbic	0x0a, 5	; 10
    16f0:	05 c0       	rjmp	.+10     	; 0x16fc <__vector_20+0x1a>
    Rs485TxStop();
    16f2:	80 91 65 00 	lds	r24, 0x0065
    16f6:	8f 7e       	andi	r24, 0xEF	; 239
    16f8:	80 93 65 00 	sts	0x0065, r24
}
    16fc:	8f 91       	pop	r24
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63
    1702:	0f 90       	pop	r0
    1704:	1f 90       	pop	r1
    1706:	18 95       	reti

00001708 <InterruptVtyOn>:
}

void InterruptVtyOn(void)
{                                  
  unsigned portCHAR ucByte;                                       
  ucByte = UCSR1B;                 
    1708:	ea e9       	ldi	r30, 0x9A	; 154
    170a:	f0 e0       	ldi	r31, 0x00	; 0
    170c:	80 81       	ld	r24, Z
  ucByte |= serDATA_INT_ENABLE;    
    170e:	80 62       	ori	r24, 0x20	; 32
  UCSR1B = ucByte;                 
    1710:	80 83       	st	Z, r24
}
    1712:	08 95       	ret

00001714 <__vector_31>:
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
  vInterruptVtyOn();
}

ISR(USART1_UDRE_vect)
{
    1714:	1f 92       	push	r1
    1716:	0f 92       	push	r0
    1718:	0f b6       	in	r0, 0x3f	; 63
    171a:	0f 92       	push	r0
    171c:	0b b6       	in	r0, 0x3b	; 59
    171e:	0f 92       	push	r0
    1720:	11 24       	eor	r1, r1
    1722:	2f 93       	push	r18
    1724:	3f 93       	push	r19
    1726:	4f 93       	push	r20
    1728:	5f 93       	push	r21
    172a:	6f 93       	push	r22
    172c:	7f 93       	push	r23
    172e:	8f 93       	push	r24
    1730:	9f 93       	push	r25
    1732:	af 93       	push	r26
    1734:	bf 93       	push	r27
    1736:	ef 93       	push	r30
    1738:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
    173a:	80 91 7b 0e 	lds	r24, 0x0E7B
    173e:	90 91 7c 0e 	lds	r25, 0x0E7C
    1742:	69 e8       	ldi	r22, 0x89	; 137
    1744:	71 e0       	ldi	r23, 0x01	; 1
    1746:	4a e8       	ldi	r20, 0x8A	; 138
    1748:	51 e0       	ldi	r21, 0x01	; 1
    174a:	0e 94 ec 52 	call	0xa5d8	; 0xa5d8 <xQueueReceiveFromISR>
    174e:	81 30       	cpi	r24, 0x01	; 1
    1750:	29 f4       	brne	.+10     	; 0x175c <__vector_31+0x48>
  {
    UDR1 = data; 
    1752:	80 91 89 01 	lds	r24, 0x0189
    1756:	80 93 9c 00 	sts	0x009C, r24
    175a:	07 c0       	rjmp	.+14     	; 0x176a <__vector_31+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    175c:	10 92 8a 01 	sts	0x018A, r1
    vInterruptVtyOff();
    1760:	80 91 9a 00 	lds	r24, 0x009A
    1764:	8f 7d       	andi	r24, 0xDF	; 223
    1766:	80 93 9a 00 	sts	0x009A, r24
  }
  if( xHigherPriorityTaskWoken )
    176a:	80 91 8a 01 	lds	r24, 0x018A
    176e:	88 23       	and	r24, r24
    1770:	11 f0       	breq	.+4      	; 0x1776 <__vector_31+0x62>
  {
    taskYIELD();
    1772:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
  }
}
    1776:	ff 91       	pop	r31
    1778:	ef 91       	pop	r30
    177a:	bf 91       	pop	r27
    177c:	af 91       	pop	r26
    177e:	9f 91       	pop	r25
    1780:	8f 91       	pop	r24
    1782:	7f 91       	pop	r23
    1784:	6f 91       	pop	r22
    1786:	5f 91       	pop	r21
    1788:	4f 91       	pop	r20
    178a:	3f 91       	pop	r19
    178c:	2f 91       	pop	r18
    178e:	0f 90       	pop	r0
    1790:	0b be       	out	0x3b, r0	; 59
    1792:	0f 90       	pop	r0
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	0f 90       	pop	r0
    1798:	1f 90       	pop	r1
    179a:	18 95       	reti

0000179c <__vector_19>:
{
  return xQueueReceive(xRs485Rec, c, timeout);
}

ISR(USART0_UDRE_vect)
{
    179c:	1f 92       	push	r1
    179e:	0f 92       	push	r0
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	0f 92       	push	r0
    17a4:	0b b6       	in	r0, 0x3b	; 59
    17a6:	0f 92       	push	r0
    17a8:	11 24       	eor	r1, r1
    17aa:	2f 93       	push	r18
    17ac:	3f 93       	push	r19
    17ae:	4f 93       	push	r20
    17b0:	5f 93       	push	r21
    17b2:	6f 93       	push	r22
    17b4:	7f 93       	push	r23
    17b6:	8f 93       	push	r24
    17b8:	9f 93       	push	r25
    17ba:	af 93       	push	r26
    17bc:	bf 93       	push	r27
    17be:	ef 93       	push	r30
    17c0:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
    17c2:	80 91 c8 0e 	lds	r24, 0x0EC8
    17c6:	90 91 c9 0e 	lds	r25, 0x0EC9
    17ca:	6c e8       	ldi	r22, 0x8C	; 140
    17cc:	71 e0       	ldi	r23, 0x01	; 1
    17ce:	4d e8       	ldi	r20, 0x8D	; 141
    17d0:	51 e0       	ldi	r21, 0x01	; 1
    17d2:	0e 94 ec 52 	call	0xa5d8	; 0xa5d8 <xQueueReceiveFromISR>
    17d6:	81 30       	cpi	r24, 0x01	; 1
    17d8:	49 f4       	brne	.+18     	; 0x17ec <__vector_19+0x50>
  {
    Rs485TxStart();
    17da:	80 91 65 00 	lds	r24, 0x0065
    17de:	80 61       	ori	r24, 0x10	; 16
    17e0:	80 93 65 00 	sts	0x0065, r24
    UDR0 = data; 
    17e4:	80 91 8c 01 	lds	r24, 0x018C
    17e8:	8c b9       	out	0x0c, r24	; 12
    17ea:	03 c0       	rjmp	.+6      	; 0x17f2 <__vector_19+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    17ec:	10 92 8d 01 	sts	0x018D, r1
    vInterruptRs485Off();
    17f0:	55 98       	cbi	0x0a, 5	; 10
  }
  if( xHigherPriorityTaskWoken )
    17f2:	80 91 8d 01 	lds	r24, 0x018D
    17f6:	88 23       	and	r24, r24
    17f8:	11 f0       	breq	.+4      	; 0x17fe <__vector_19+0x62>
  {
    taskYIELD();
    17fa:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
  }
}
    17fe:	ff 91       	pop	r31
    1800:	ef 91       	pop	r30
    1802:	bf 91       	pop	r27
    1804:	af 91       	pop	r26
    1806:	9f 91       	pop	r25
    1808:	8f 91       	pop	r24
    180a:	7f 91       	pop	r23
    180c:	6f 91       	pop	r22
    180e:	5f 91       	pop	r21
    1810:	4f 91       	pop	r20
    1812:	3f 91       	pop	r19
    1814:	2f 91       	pop	r18
    1816:	0f 90       	pop	r0
    1818:	0b be       	out	0x3b, r0	; 59
    181a:	0f 90       	pop	r0
    181c:	0f be       	out	0x3f, r0	; 63
    181e:	0f 90       	pop	r0
    1820:	1f 90       	pop	r1
    1822:	18 95       	reti

00001824 <uartVtySendByte>:
    taskYIELD();
  }
}

void uartVtySendByte(uint8_t data)
{
    1824:	df 93       	push	r29
    1826:	cf 93       	push	r28
    1828:	0f 92       	push	r0
    182a:	cd b7       	in	r28, 0x3d	; 61
    182c:	de b7       	in	r29, 0x3e	; 62
    182e:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
    1830:	80 91 7b 0e 	lds	r24, 0x0E7B
    1834:	90 91 7c 0e 	lds	r25, 0x0E7C
    1838:	be 01       	movw	r22, r28
    183a:	6f 5f       	subi	r22, 0xFF	; 255
    183c:	7f 4f       	sbci	r23, 0xFF	; 255
    183e:	4f ef       	ldi	r20, 0xFF	; 255
    1840:	5f ef       	ldi	r21, 0xFF	; 255
    1842:	20 e0       	ldi	r18, 0x00	; 0
    1844:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>
  vInterruptVtyOn();
    1848:	ea e9       	ldi	r30, 0x9A	; 154
    184a:	f0 e0       	ldi	r31, 0x00	; 0
    184c:	80 81       	ld	r24, Z
    184e:	80 62       	ori	r24, 0x20	; 32
    1850:	80 83       	st	Z, r24
}
    1852:	0f 90       	pop	r0
    1854:	cf 91       	pop	r28
    1856:	df 91       	pop	r29
    1858:	08 95       	ret

0000185a <VtyPutChar>:
}

int VtyPutChar(char c, FILE *stream)
{
  stream = NULL;
  uartVtySendByte(c);
    185a:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
  return 0;
}
    185e:	80 e0       	ldi	r24, 0x00	; 0
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	08 95       	ret

00001864 <releaseRs485>:
    1864:	80 91 af 0e 	lds	r24, 0x0EAF
    1868:	90 91 b0 0e 	lds	r25, 0x0EB0
    186c:	60 e0       	ldi	r22, 0x00	; 0
    186e:	70 e0       	ldi	r23, 0x00	; 0
    1870:	40 e0       	ldi	r20, 0x00	; 0
    1872:	50 e0       	ldi	r21, 0x00	; 0
    1874:	20 e0       	ldi	r18, 0x00	; 0
    1876:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>
    187a:	08 95       	ret

0000187c <uartRs485SendByte>:
    187c:	df 93       	push	r29
    187e:	cf 93       	push	r28
    1880:	0f 92       	push	r0
    1882:	cd b7       	in	r28, 0x3d	; 61
    1884:	de b7       	in	r29, 0x3e	; 62
    1886:	89 83       	std	Y+1, r24	; 0x01
    1888:	80 91 c8 0e 	lds	r24, 0x0EC8
    188c:	90 91 c9 0e 	lds	r25, 0x0EC9
    1890:	be 01       	movw	r22, r28
    1892:	6f 5f       	subi	r22, 0xFF	; 255
    1894:	7f 4f       	sbci	r23, 0xFF	; 255
    1896:	4f ef       	ldi	r20, 0xFF	; 255
    1898:	5f ef       	ldi	r21, 0xFF	; 255
    189a:	20 e0       	ldi	r18, 0x00	; 0
    189c:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>
    18a0:	55 9a       	sbi	0x0a, 5	; 10
    18a2:	0f 90       	pop	r0
    18a4:	cf 91       	pop	r28
    18a6:	df 91       	pop	r29
    18a8:	08 95       	ret

000018aa <__vector_30>:
  UCSR1B = ucByte;                 
}

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    18aa:	1f 92       	push	r1
    18ac:	0f 92       	push	r0
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	0f 92       	push	r0
    18b2:	0b b6       	in	r0, 0x3b	; 59
    18b4:	0f 92       	push	r0
    18b6:	11 24       	eor	r1, r1
    18b8:	2f 93       	push	r18
    18ba:	3f 93       	push	r19
    18bc:	4f 93       	push	r20
    18be:	5f 93       	push	r21
    18c0:	6f 93       	push	r22
    18c2:	7f 93       	push	r23
    18c4:	8f 93       	push	r24
    18c6:	9f 93       	push	r25
    18c8:	af 93       	push	r26
    18ca:	bf 93       	push	r27
    18cc:	ef 93       	push	r30
    18ce:	ff 93       	push	r31
    18d0:	df 93       	push	r29
    18d2:	cf 93       	push	r28
    18d4:	0f 92       	push	r0
    18d6:	cd b7       	in	r28, 0x3d	; 61
    18d8:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  signed portCHAR cChar;

  cChar = UDR1;
    18da:	80 91 9c 00 	lds	r24, 0x009C
    18de:	89 83       	std	Y+1, r24	; 0x01
//  xQueueSendFromISR(xVtyRec, &cChar, NULL);

  xHigherPriorityTaskWoken = pdFALSE;
    18e0:	10 92 8b 01 	sts	0x018B, r1
  xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
    18e4:	80 91 ad 0e 	lds	r24, 0x0EAD
    18e8:	90 91 ae 0e 	lds	r25, 0x0EAE
    18ec:	be 01       	movw	r22, r28
    18ee:	6f 5f       	subi	r22, 0xFF	; 255
    18f0:	7f 4f       	sbci	r23, 0xFF	; 255
    18f2:	4b e8       	ldi	r20, 0x8B	; 139
    18f4:	51 e0       	ldi	r21, 0x01	; 1
    18f6:	20 e0       	ldi	r18, 0x00	; 0
    18f8:	0e 94 6c 53 	call	0xa6d8	; 0xa6d8 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    18fc:	80 91 8b 01 	lds	r24, 0x018B
    1900:	88 23       	and	r24, r24
    1902:	11 f0       	breq	.+4      	; 0x1908 <__vector_30+0x5e>
  {
    taskYIELD();
    1904:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
  }
}
    1908:	0f 90       	pop	r0
    190a:	cf 91       	pop	r28
    190c:	df 91       	pop	r29
    190e:	ff 91       	pop	r31
    1910:	ef 91       	pop	r30
    1912:	bf 91       	pop	r27
    1914:	af 91       	pop	r26
    1916:	9f 91       	pop	r25
    1918:	8f 91       	pop	r24
    191a:	7f 91       	pop	r23
    191c:	6f 91       	pop	r22
    191e:	5f 91       	pop	r21
    1920:	4f 91       	pop	r20
    1922:	3f 91       	pop	r19
    1924:	2f 91       	pop	r18
    1926:	0f 90       	pop	r0
    1928:	0b be       	out	0x3b, r0	; 59
    192a:	0f 90       	pop	r0
    192c:	0f be       	out	0x3f, r0	; 63
    192e:	0f 90       	pop	r0
    1930:	1f 90       	pop	r1
    1932:	18 95       	reti

00001934 <__vector_18>:
  return;
}

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    1934:	1f 92       	push	r1
    1936:	0f 92       	push	r0
    1938:	0f b6       	in	r0, 0x3f	; 63
    193a:	0f 92       	push	r0
    193c:	0b b6       	in	r0, 0x3b	; 59
    193e:	0f 92       	push	r0
    1940:	11 24       	eor	r1, r1
    1942:	2f 93       	push	r18
    1944:	3f 93       	push	r19
    1946:	4f 93       	push	r20
    1948:	5f 93       	push	r21
    194a:	6f 93       	push	r22
    194c:	7f 93       	push	r23
    194e:	8f 93       	push	r24
    1950:	9f 93       	push	r25
    1952:	af 93       	push	r26
    1954:	bf 93       	push	r27
    1956:	ef 93       	push	r30
    1958:	ff 93       	push	r31
    195a:	df 93       	push	r29
    195c:	cf 93       	push	r28
    195e:	0f 92       	push	r0
    1960:	cd b7       	in	r28, 0x3d	; 61
    1962:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  signed portCHAR cChar;

  cChar = UDR0;
    1964:	8c b1       	in	r24, 0x0c	; 12
    1966:	89 83       	std	Y+1, r24	; 0x01

  xHigherPriorityTaskWoken = pdFALSE;
    1968:	10 92 01 01 	sts	0x0101, r1

//  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
    196c:	80 91 9c 0e 	lds	r24, 0x0E9C
    1970:	90 91 9d 0e 	lds	r25, 0x0E9D
    1974:	be 01       	movw	r22, r28
    1976:	6f 5f       	subi	r22, 0xFF	; 255
    1978:	7f 4f       	sbci	r23, 0xFF	; 255
    197a:	41 e0       	ldi	r20, 0x01	; 1
    197c:	51 e0       	ldi	r21, 0x01	; 1
    197e:	20 e0       	ldi	r18, 0x00	; 0
    1980:	0e 94 6c 53 	call	0xa6d8	; 0xa6d8 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    1984:	80 91 01 01 	lds	r24, 0x0101
    1988:	88 23       	and	r24, r24
    198a:	11 f0       	breq	.+4      	; 0x1990 <__vector_18+0x5c>
  {
    taskYIELD();
    198c:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
  }
}
    1990:	0f 90       	pop	r0
    1992:	cf 91       	pop	r28
    1994:	df 91       	pop	r29
    1996:	ff 91       	pop	r31
    1998:	ef 91       	pop	r30
    199a:	bf 91       	pop	r27
    199c:	af 91       	pop	r26
    199e:	9f 91       	pop	r25
    19a0:	8f 91       	pop	r24
    19a2:	7f 91       	pop	r23
    19a4:	6f 91       	pop	r22
    19a6:	5f 91       	pop	r21
    19a8:	4f 91       	pop	r20
    19aa:	3f 91       	pop	r19
    19ac:	2f 91       	pop	r18
    19ae:	0f 90       	pop	r0
    19b0:	0b be       	out	0x3b, r0	; 59
    19b2:	0f 90       	pop	r0
    19b4:	0f be       	out	0x3f, r0	; 63
    19b6:	0f 90       	pop	r0
    19b8:	1f 90       	pop	r1
    19ba:	18 95       	reti

000019bc <takeRs485>:
    19bc:	80 91 af 0e 	lds	r24, 0x0EAF
    19c0:	90 91 b0 0e 	lds	r25, 0x0EB0
    19c4:	60 e0       	ldi	r22, 0x00	; 0
    19c6:	70 e0       	ldi	r23, 0x00	; 0
    19c8:	4f ef       	ldi	r20, 0xFF	; 255
    19ca:	5f ef       	ldi	r21, 0xFF	; 255
    19cc:	20 e0       	ldi	r18, 0x00	; 0
    19ce:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    19d2:	08 95       	ret

000019d4 <flushRs485RecBuffer>:
    19d4:	ef 92       	push	r14
    19d6:	ff 92       	push	r15
    19d8:	1f 93       	push	r17
    19da:	df 93       	push	r29
    19dc:	cf 93       	push	r28
    19de:	0f 92       	push	r0
    19e0:	cd b7       	in	r28, 0x3d	; 61
    19e2:	de b7       	in	r29, 0x3e	; 62
    19e4:	10 e0       	ldi	r17, 0x00	; 0
    19e6:	7e 01       	movw	r14, r28
    19e8:	08 94       	sec
    19ea:	e1 1c       	adc	r14, r1
    19ec:	f1 1c       	adc	r15, r1
    19ee:	01 c0       	rjmp	.+2      	; 0x19f2 <flushRs485RecBuffer+0x1e>
    19f0:	1f 5f       	subi	r17, 0xFF	; 255
    19f2:	80 91 9c 0e 	lds	r24, 0x0E9C
    19f6:	90 91 9d 0e 	lds	r25, 0x0E9D
    19fa:	b7 01       	movw	r22, r14
    19fc:	4a e0       	ldi	r20, 0x0A	; 10
    19fe:	50 e0       	ldi	r21, 0x00	; 0
    1a00:	20 e0       	ldi	r18, 0x00	; 0
    1a02:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    1a06:	81 30       	cpi	r24, 0x01	; 1
    1a08:	99 f3       	breq	.-26     	; 0x19f0 <flushRs485RecBuffer+0x1c>
    1a0a:	81 2f       	mov	r24, r17
    1a0c:	0f 90       	pop	r0
    1a0e:	cf 91       	pop	r28
    1a10:	df 91       	pop	r29
    1a12:	1f 91       	pop	r17
    1a14:	ff 90       	pop	r15
    1a16:	ef 90       	pop	r14
    1a18:	08 95       	ret

00001a1a <rs485Receive>:
    1a1a:	9c 01       	movw	r18, r24
    1a1c:	46 2f       	mov	r20, r22
    1a1e:	80 91 9c 0e 	lds	r24, 0x0E9C
    1a22:	90 91 9d 0e 	lds	r25, 0x0E9D
    1a26:	b9 01       	movw	r22, r18
    1a28:	50 e0       	ldi	r21, 0x00	; 0
    1a2a:	20 e0       	ldi	r18, 0x00	; 0
    1a2c:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    1a30:	08 95       	ret

00001a32 <VtyGetChar>:
  fdev_set_udata(stream, NULL);
  return;
}

int VtyGetChar(FILE *stream)
{
    1a32:	df 93       	push	r29
    1a34:	cf 93       	push	r28
    1a36:	0f 92       	push	r0
    1a38:	cd b7       	in	r28, 0x3d	; 61
    1a3a:	de b7       	in	r29, 0x3e	; 62
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    1a3c:	80 91 ad 0e 	lds	r24, 0x0EAD
    1a40:	90 91 ae 0e 	lds	r25, 0x0EAE
    1a44:	be 01       	movw	r22, r28
    1a46:	6f 5f       	subi	r22, 0xFF	; 255
    1a48:	7f 4f       	sbci	r23, 0xFF	; 255
    1a4a:	4f ef       	ldi	r20, 0xFF	; 255
    1a4c:	5f ef       	ldi	r21, 0xFF	; 255
    1a4e:	20 e0       	ldi	r18, 0x00	; 0
    1a50:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    1a54:	88 23       	and	r24, r24
    1a56:	19 f4       	brne	.+6      	; 0x1a5e <VtyGetChar+0x2c>
    1a58:	2f ef       	ldi	r18, 0xFF	; 255
    1a5a:	3f ef       	ldi	r19, 0xFF	; 255
    1a5c:	03 c0       	rjmp	.+6      	; 0x1a64 <VtyGetChar+0x32>
    return EOF;
  return c;
    1a5e:	89 81       	ldd	r24, Y+1	; 0x01
    1a60:	28 2f       	mov	r18, r24
    1a62:	30 e0       	ldi	r19, 0x00	; 0
}
    1a64:	c9 01       	movw	r24, r18
    1a66:	0f 90       	pop	r0
    1a68:	cf 91       	pop	r28
    1a6a:	df 91       	pop	r29
    1a6c:	08 95       	ret

00001a6e <xSerialPortInitMinimal>:
  return 0;
}

void xSerialPortInitMinimal(void)
{
  portENTER_CRITICAL();
    1a6e:	0f b6       	in	r0, 0x3f	; 63
    1a70:	f8 94       	cli
    1a72:	0f 92       	push	r0
  {
    xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1a74:	80 e4       	ldi	r24, 0x40	; 64
    1a76:	61 e0       	ldi	r22, 0x01	; 1
    1a78:	0e 94 98 55 	call	0xab30	; 0xab30 <xQueueCreate>
    1a7c:	90 93 ae 0e 	sts	0x0EAE, r25
    1a80:	80 93 ad 0e 	sts	0x0EAD, r24
    xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1a84:	80 e2       	ldi	r24, 0x20	; 32
    1a86:	61 e0       	ldi	r22, 0x01	; 1
    1a88:	0e 94 98 55 	call	0xab30	; 0xab30 <xQueueCreate>
    1a8c:	90 93 7c 0e 	sts	0x0E7C, r25
    1a90:	80 93 7b 0e 	sts	0x0E7B, r24
    xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1a94:	80 e1       	ldi	r24, 0x10	; 16
    1a96:	61 e0       	ldi	r22, 0x01	; 1
    1a98:	0e 94 98 55 	call	0xab30	; 0xab30 <xQueueCreate>
    1a9c:	90 93 9d 0e 	sts	0x0E9D, r25
    1aa0:	80 93 9c 0e 	sts	0x0E9C, r24
    xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1aa4:	84 e0       	ldi	r24, 0x04	; 4
    1aa6:	61 e0       	ldi	r22, 0x01	; 1
    1aa8:	0e 94 98 55 	call	0xab30	; 0xab30 <xQueueCreate>
    1aac:	90 93 c9 0e 	sts	0x0EC9, r25
    1ab0:	80 93 c8 0e 	sts	0x0EC8, r24
    
    vSemaphoreCreateBinary(xSemaphoreRs485); 
    1ab4:	81 e0       	ldi	r24, 0x01	; 1
    1ab6:	60 e0       	ldi	r22, 0x00	; 0
    1ab8:	0e 94 98 55 	call	0xab30	; 0xab30 <xQueueCreate>
    1abc:	90 93 b0 0e 	sts	0x0EB0, r25
    1ac0:	80 93 af 0e 	sts	0x0EAF, r24
    1ac4:	00 97       	sbiw	r24, 0x00	; 0
    1ac6:	39 f0       	breq	.+14     	; 0x1ad6 <xSerialPortInitMinimal+0x68>
    1ac8:	60 e0       	ldi	r22, 0x00	; 0
    1aca:	70 e0       	ldi	r23, 0x00	; 0
    1acc:	40 e0       	ldi	r20, 0x00	; 0
    1ace:	50 e0       	ldi	r21, 0x00	; 0
    1ad0:	20 e0       	ldi	r18, 0x00	; 0
    1ad2:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
    1ad6:	0f 90       	pop	r0
    1ad8:	0f be       	out	0x3f, r0	; 63
  
  UBRR0L = 7;
    1ada:	87 e0       	ldi	r24, 0x07	; 7
    1adc:	89 b9       	out	0x09, r24	; 9
  UBRR0H = 0;
    1ade:	10 92 90 00 	sts	0x0090, r1

  UBRR1L = 7;
    1ae2:	80 93 99 00 	sts	0x0099, r24
  UBRR1H = 0;
    1ae6:	10 92 98 00 	sts	0x0098, r1

  UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
    1aea:	88 ed       	ldi	r24, 0xD8	; 216
    1aec:	8a b9       	out	0x0a, r24	; 10
  UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    1aee:	96 e8       	ldi	r25, 0x86	; 134
    1af0:	90 93 95 00 	sts	0x0095, r25
  UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
    1af4:	88 e9       	ldi	r24, 0x98	; 152
    1af6:	80 93 9a 00 	sts	0x009A, r24
  UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    1afa:	90 93 9d 00 	sts	0x009D, r25
  return;
}
    1afe:	08 95       	ret

00001b00 <spiSendSpinBlock>:
    1b00:	8f b9       	out	0x0f, r24	; 15
    1b02:	6f 98       	cbi	0x0d, 7	; 13
    1b04:	77 9b       	sbis	0x0e, 7	; 14
    1b06:	fe cf       	rjmp	.-4      	; 0x1b04 <spiSendSpinBlock+0x4>
    1b08:	8e b1       	in	r24, 0x0e	; 14
    1b0a:	8f b1       	in	r24, 0x0f	; 15
    1b0c:	6f 9a       	sbi	0x0d, 7	; 13
    1b0e:	08 95       	ret

00001b10 <disableAllSpiDevices>:
#error Port A is memory bus
  PORTA &= disableSpiPORTA_AND;
#endif

#if disableSpiPORTB_OR != 0
  PORTB |= disableSpiPORTB_OR;
    1b10:	88 b3       	in	r24, 0x18	; 24
    1b12:	80 6c       	ori	r24, 0xC0	; 192
    1b14:	88 bb       	out	0x18, r24	; 24
#endif
#if disableSpiPORTB_AND != 0xFF
  PORTB &= disableSpiPORTB_AND;
    1b16:	c5 98       	cbi	0x18, 5	; 24
#endif
#if disableSpiPORTD_AND != 0xFF
  PORTD &= disableSpiPORTD_AND;
#endif
#if disableSpiPORTE_OR != 0
  PORTE |= disableSpiPORTE_OR;
    1b18:	1b 9a       	sbi	0x03, 3	; 3
#if disableSpiPORTF_AND != 0xFF
  PORTF &= disableSpiPORTF_AND;
#endif

#if disableSpiPORTG_OR != 0
  PORTG |= disableSpiPORTG_OR;
    1b1a:	e5 e6       	ldi	r30, 0x65	; 101
    1b1c:	f0 e0       	ldi	r31, 0x00	; 0
    1b1e:	80 81       	ld	r24, Z
    1b20:	88 60       	ori	r24, 0x08	; 8
    1b22:	80 83       	st	Z, r24
#endif
#if disableSpiPORTG_AND != 0xFF
  PORTG &= disableSpiPORTG_AND;
#endif
}
    1b24:	08 95       	ret

00001b26 <spiEnableEnc28j60>:
    1b26:	1b 98       	cbi	0x03, 3	; 3
    1b28:	08 95       	ret

00001b2a <spiDisableEnc28j60>:
    1b2a:	1b 9a       	sbi	0x03, 3	; 3
    1b2c:	08 95       	ret

00001b2e <enableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
    1b2e:	e5 e6       	ldi	r30, 0x65	; 101
    1b30:	f0 e0       	ldi	r31, 0x00	; 0
    1b32:	80 81       	ld	r24, Z
    1b34:	87 7f       	andi	r24, 0xF7	; 247
    1b36:	80 83       	st	Z, r24
#endif   
}
    1b38:	08 95       	ret

00001b3a <disableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
    1b3a:	e5 e6       	ldi	r30, 0x65	; 101
    1b3c:	f0 e0       	ldi	r31, 0x00	; 0
    1b3e:	80 81       	ld	r24, Z
    1b40:	88 60       	ori	r24, 0x08	; 8
    1b42:	80 83       	st	Z, r24
#endif  
}
    1b44:	08 95       	ret

00001b46 <enableSpiMPC23S17>:
    1b46:	c7 98       	cbi	0x18, 7	; 24
    1b48:	08 95       	ret

00001b4a <disableSpiMPC23S17>:
    1b4a:	c7 9a       	sbi	0x18, 7	; 24
    1b4c:	08 95       	ret

00001b4e <enableSpiMCP3008>:
    1b4e:	8d b1       	in	r24, 0x0d	; 13
    1b50:	83 60       	ori	r24, 0x03	; 3
    1b52:	8d b9       	out	0x0d, r24	; 13
    1b54:	c6 98       	cbi	0x18, 6	; 24
    1b56:	08 95       	ret

00001b58 <disableSpiMCP3008>:
    1b58:	8d b1       	in	r24, 0x0d	; 13
    1b5a:	8c 7f       	andi	r24, 0xFC	; 252
    1b5c:	8d b9       	out	0x0d, r24	; 13
    1b5e:	c6 9a       	sbi	0x18, 6	; 24
    1b60:	08 95       	ret

00001b62 <enableSpiMCP4150>:
    1b62:	8d b1       	in	r24, 0x0d	; 13
    1b64:	83 60       	ori	r24, 0x03	; 3
    1b66:	8d b9       	out	0x0d, r24	; 13
    1b68:	c6 98       	cbi	0x18, 6	; 24
    1b6a:	08 95       	ret

00001b6c <disableSpiMCP4150>:
    1b6c:	8d b1       	in	r24, 0x0d	; 13
    1b6e:	8c 7f       	andi	r24, 0xFC	; 252
    1b70:	8d b9       	out	0x0d, r24	; 13
    1b72:	c6 9a       	sbi	0x18, 6	; 24
    1b74:	08 95       	ret

00001b76 <spiEnableDS1305>:
    1b76:	8d b1       	in	r24, 0x0d	; 13
    1b78:	85 60       	ori	r24, 0x05	; 5
    1b7a:	8d b9       	out	0x0d, r24	; 13
    1b7c:	c5 9a       	sbi	0x18, 5	; 24
    1b7e:	08 95       	ret

00001b80 <spiDisableDS1305>:
    1b80:	8d b1       	in	r24, 0x0d	; 13
    1b82:	8a 7f       	andi	r24, 0xFA	; 250
    1b84:	8d b9       	out	0x0d, r24	; 13
    1b86:	c5 98       	cbi	0x18, 5	; 24
    1b88:	08 95       	ret

00001b8a <__vector_17>:
  DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
#endif  
}

ISR(SPI_STC_vect)
{
    1b8a:	1f 92       	push	r1
    1b8c:	0f 92       	push	r0
    1b8e:	0f b6       	in	r0, 0x3f	; 63
    1b90:	0f 92       	push	r0
    1b92:	0b b6       	in	r0, 0x3b	; 59
    1b94:	0f 92       	push	r0
    1b96:	11 24       	eor	r1, r1
    1b98:	2f 93       	push	r18
    1b9a:	3f 93       	push	r19
    1b9c:	4f 93       	push	r20
    1b9e:	5f 93       	push	r21
    1ba0:	6f 93       	push	r22
    1ba2:	7f 93       	push	r23
    1ba4:	8f 93       	push	r24
    1ba6:	9f 93       	push	r25
    1ba8:	af 93       	push	r26
    1baa:	bf 93       	push	r27
    1bac:	ef 93       	push	r30
    1bae:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 

  static uint8_t data;
  data = SPDR;
    1bb0:	8f b1       	in	r24, 0x0f	; 15
    1bb2:	80 93 8e 01 	sts	0x018E, r24
  
  xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
    1bb6:	80 91 67 0f 	lds	r24, 0x0F67
    1bba:	90 91 68 0f 	lds	r25, 0x0F68
    1bbe:	6e e8       	ldi	r22, 0x8E	; 142
    1bc0:	71 e0       	ldi	r23, 0x01	; 1
    1bc2:	4f e8       	ldi	r20, 0x8F	; 143
    1bc4:	51 e0       	ldi	r21, 0x01	; 1
    1bc6:	20 e0       	ldi	r18, 0x00	; 0
    1bc8:	0e 94 6c 53 	call	0xa6d8	; 0xa6d8 <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    1bcc:	80 91 8f 01 	lds	r24, 0x018F
    1bd0:	88 23       	and	r24, r24
    1bd2:	11 f0       	breq	.+4      	; 0x1bd8 <__vector_17+0x4e>
  {
    taskYIELD();
    1bd4:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
  }
  
  //clear SPI interrupt SPI |= 1;
}
    1bd8:	ff 91       	pop	r31
    1bda:	ef 91       	pop	r30
    1bdc:	bf 91       	pop	r27
    1bde:	af 91       	pop	r26
    1be0:	9f 91       	pop	r25
    1be2:	8f 91       	pop	r24
    1be4:	7f 91       	pop	r23
    1be6:	6f 91       	pop	r22
    1be8:	5f 91       	pop	r21
    1bea:	4f 91       	pop	r20
    1bec:	3f 91       	pop	r19
    1bee:	2f 91       	pop	r18
    1bf0:	0f 90       	pop	r0
    1bf2:	0b be       	out	0x3b, r0	; 59
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	0f 90       	pop	r0
    1bfa:	1f 90       	pop	r1
    1bfc:	18 95       	reti

00001bfe <spiSend>:
    1bfe:	df 93       	push	r29
    1c00:	cf 93       	push	r28
    1c02:	0f 92       	push	r0
    1c04:	cd b7       	in	r28, 0x3d	; 61
    1c06:	de b7       	in	r29, 0x3e	; 62
    1c08:	8f b9       	out	0x0f, r24	; 15
    1c0a:	80 91 67 0f 	lds	r24, 0x0F67
    1c0e:	90 91 68 0f 	lds	r25, 0x0F68
    1c12:	be 01       	movw	r22, r28
    1c14:	6f 5f       	subi	r22, 0xFF	; 255
    1c16:	7f 4f       	sbci	r23, 0xFF	; 255
    1c18:	4a e0       	ldi	r20, 0x0A	; 10
    1c1a:	50 e0       	ldi	r21, 0x00	; 0
    1c1c:	20 e0       	ldi	r18, 0x00	; 0
    1c1e:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    1c22:	89 81       	ldd	r24, Y+1	; 0x01
    1c24:	0f 90       	pop	r0
    1c26:	cf 91       	pop	r28
    1c28:	df 91       	pop	r29
    1c2a:	08 95       	ret

00001c2c <checkLockerSensors>:
  }
  return result;
}

void checkLockerSensors(void)
{
    1c2c:	0f 93       	push	r16
    1c2e:	1f 93       	push	r17
  if (lockSensors[0].enabled)
    1c30:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c34:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1c38:	80 81       	ld	r24, Z
    1c3a:	88 23       	and	r24, r24
    1c3c:	41 f1       	breq	.+80     	; 0x1c8e <checkLockerSensors+0x62>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1c3e:	80 e4       	ldi	r24, 0x40	; 64
    1c40:	60 e0       	ldi	r22, 0x00	; 0
    1c42:	0e 94 98 29 	call	0x5330	; 0x5330 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1c46:	8e e1       	ldi	r24, 0x1E	; 30
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
    1c4e:	00 91 a0 0e 	lds	r16, 0x0EA0
    1c52:	10 91 a1 0e 	lds	r17, 0x0EA1
    1c56:	84 e0       	ldi	r24, 0x04	; 4
    1c58:	0e 94 0c 2a 	call	0x5418	; 0x5418 <MCP3008_getSampleSingle>
    1c5c:	f8 01       	movw	r30, r16
    1c5e:	94 83       	std	Z+4, r25	; 0x04
    1c60:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1c62:	80 e4       	ldi	r24, 0x40	; 64
    1c64:	60 e0       	ldi	r22, 0x00	; 0
    1c66:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MPC23s17ClearBitsOnPortA>
    lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
    1c6a:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c6e:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1c72:	40 e0       	ldi	r20, 0x00	; 0
    1c74:	23 81       	ldd	r18, Z+3	; 0x03
    1c76:	34 81       	ldd	r19, Z+4	; 0x04
    1c78:	81 81       	ldd	r24, Z+1	; 0x01
    1c7a:	92 81       	ldd	r25, Z+2	; 0x02
    1c7c:	82 17       	cp	r24, r18
    1c7e:	93 07       	cpc	r25, r19
    1c80:	08 f4       	brcc	.+2      	; 0x1c84 <checkLockerSensors+0x58>
    1c82:	41 e0       	ldi	r20, 0x01	; 1
    1c84:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1c86:	8a e0       	ldi	r24, 0x0A	; 10
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
  }
  
  if (lockSensors[1].enabled)
    1c8e:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c92:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1c96:	86 81       	ldd	r24, Z+6	; 0x06
    1c98:	88 23       	and	r24, r24
    1c9a:	59 f1       	breq	.+86     	; 0x1cf2 <checkLockerSensors+0xc6>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1c9c:	80 e2       	ldi	r24, 0x20	; 32
    1c9e:	60 e0       	ldi	r22, 0x00	; 0
    1ca0:	0e 94 98 29 	call	0x5330	; 0x5330 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1ca4:	8e e1       	ldi	r24, 0x1E	; 30
    1ca6:	90 e0       	ldi	r25, 0x00	; 0
    1ca8:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
    1cac:	00 91 a0 0e 	lds	r16, 0x0EA0
    1cb0:	10 91 a1 0e 	lds	r17, 0x0EA1
    1cb4:	0a 5f       	subi	r16, 0xFA	; 250
    1cb6:	1f 4f       	sbci	r17, 0xFF	; 255
    1cb8:	85 e0       	ldi	r24, 0x05	; 5
    1cba:	0e 94 0c 2a 	call	0x5418	; 0x5418 <MCP3008_getSampleSingle>
    1cbe:	f8 01       	movw	r30, r16
    1cc0:	94 83       	std	Z+4, r25	; 0x04
    1cc2:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1cc4:	80 e2       	ldi	r24, 0x20	; 32
    1cc6:	60 e0       	ldi	r22, 0x00	; 0
    1cc8:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MPC23s17ClearBitsOnPortA>
    lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
    1ccc:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1cd0:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1cd4:	36 96       	adiw	r30, 0x06	; 6
    1cd6:	40 e0       	ldi	r20, 0x00	; 0
    1cd8:	23 81       	ldd	r18, Z+3	; 0x03
    1cda:	34 81       	ldd	r19, Z+4	; 0x04
    1cdc:	81 81       	ldd	r24, Z+1	; 0x01
    1cde:	92 81       	ldd	r25, Z+2	; 0x02
    1ce0:	82 17       	cp	r24, r18
    1ce2:	93 07       	cpc	r25, r19
    1ce4:	08 f4       	brcc	.+2      	; 0x1ce8 <checkLockerSensors+0xbc>
    1ce6:	41 e0       	ldi	r20, 0x01	; 1
    1ce8:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1cea:	8a e0       	ldi	r24, 0x0A	; 10
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
  }
  
  if (lockSensors[2].enabled)
    1cf2:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1cf6:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1cfa:	84 85       	ldd	r24, Z+12	; 0x0c
    1cfc:	88 23       	and	r24, r24
    1cfe:	59 f1       	breq	.+86     	; 0x1d56 <checkLockerSensors+0x12a>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1d00:	80 e1       	ldi	r24, 0x10	; 16
    1d02:	60 e0       	ldi	r22, 0x00	; 0
    1d04:	0e 94 98 29 	call	0x5330	; 0x5330 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1d08:	8e e1       	ldi	r24, 0x1E	; 30
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
    1d0c:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
    1d10:	00 91 a0 0e 	lds	r16, 0x0EA0
    1d14:	10 91 a1 0e 	lds	r17, 0x0EA1
    1d18:	04 5f       	subi	r16, 0xF4	; 244
    1d1a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d1c:	86 e0       	ldi	r24, 0x06	; 6
    1d1e:	0e 94 0c 2a 	call	0x5418	; 0x5418 <MCP3008_getSampleSingle>
    1d22:	f8 01       	movw	r30, r16
    1d24:	94 83       	std	Z+4, r25	; 0x04
    1d26:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1d28:	80 e1       	ldi	r24, 0x10	; 16
    1d2a:	60 e0       	ldi	r22, 0x00	; 0
    1d2c:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MPC23s17ClearBitsOnPortA>
    lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
    1d30:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1d34:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1d38:	3c 96       	adiw	r30, 0x0c	; 12
    1d3a:	40 e0       	ldi	r20, 0x00	; 0
    1d3c:	23 81       	ldd	r18, Z+3	; 0x03
    1d3e:	34 81       	ldd	r19, Z+4	; 0x04
    1d40:	81 81       	ldd	r24, Z+1	; 0x01
    1d42:	92 81       	ldd	r25, Z+2	; 0x02
    1d44:	82 17       	cp	r24, r18
    1d46:	93 07       	cpc	r25, r19
    1d48:	08 f4       	brcc	.+2      	; 0x1d4c <checkLockerSensors+0x120>
    1d4a:	41 e0       	ldi	r20, 0x01	; 1
    1d4c:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1d4e:	8a e0       	ldi	r24, 0x0A	; 10
    1d50:	90 e0       	ldi	r25, 0x00	; 0
    1d52:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
  }
  
  if (lockSensors[3].enabled)
    1d56:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1d5a:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1d5e:	82 89       	ldd	r24, Z+18	; 0x12
    1d60:	88 23       	and	r24, r24
    1d62:	59 f1       	breq	.+86     	; 0x1dba <checkLockerSensors+0x18e>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1d64:	88 e0       	ldi	r24, 0x08	; 8
    1d66:	60 e0       	ldi	r22, 0x00	; 0
    1d68:	0e 94 98 29 	call	0x5330	; 0x5330 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1d6c:	8e e1       	ldi	r24, 0x1E	; 30
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    1d74:	00 91 a0 0e 	lds	r16, 0x0EA0
    1d78:	10 91 a1 0e 	lds	r17, 0x0EA1
    1d7c:	0e 5e       	subi	r16, 0xEE	; 238
    1d7e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d80:	87 e0       	ldi	r24, 0x07	; 7
    1d82:	0e 94 0c 2a 	call	0x5418	; 0x5418 <MCP3008_getSampleSingle>
    1d86:	f8 01       	movw	r30, r16
    1d88:	94 83       	std	Z+4, r25	; 0x04
    1d8a:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1d8c:	88 e0       	ldi	r24, 0x08	; 8
    1d8e:	60 e0       	ldi	r22, 0x00	; 0
    1d90:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MPC23s17ClearBitsOnPortA>
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    1d94:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1d98:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1d9c:	72 96       	adiw	r30, 0x12	; 18
    1d9e:	40 e0       	ldi	r20, 0x00	; 0
    1da0:	23 81       	ldd	r18, Z+3	; 0x03
    1da2:	34 81       	ldd	r19, Z+4	; 0x04
    1da4:	81 81       	ldd	r24, Z+1	; 0x01
    1da6:	92 81       	ldd	r25, Z+2	; 0x02
    1da8:	82 17       	cp	r24, r18
    1daa:	93 07       	cpc	r25, r19
    1dac:	08 f4       	brcc	.+2      	; 0x1db0 <checkLockerSensors+0x184>
    1dae:	41 e0       	ldi	r20, 0x01	; 1
    1db0:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1db2:	8a e0       	ldi	r24, 0x0A	; 10
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
  }
}
    1dba:	1f 91       	pop	r17
    1dbc:	0f 91       	pop	r16
    1dbe:	08 95       	ret

00001dc0 <printLockers>:
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
}

uint8_t printLockers(FILE *stream)
{
    1dc0:	4f 92       	push	r4
    1dc2:	5f 92       	push	r5
    1dc4:	6f 92       	push	r6
    1dc6:	7f 92       	push	r7
    1dc8:	8f 92       	push	r8
    1dca:	9f 92       	push	r9
    1dcc:	af 92       	push	r10
    1dce:	bf 92       	push	r11
    1dd0:	df 92       	push	r13
    1dd2:	ef 92       	push	r14
    1dd4:	ff 92       	push	r15
    1dd6:	0f 93       	push	r16
    1dd8:	1f 93       	push	r17
    1dda:	cf 93       	push	r28
    1ddc:	df 93       	push	r29
    1dde:	7c 01       	movw	r14, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
    1de0:	00 91 a0 0e 	lds	r16, 0x0EA0
    1de4:	10 91 a1 0e 	lds	r17, 0x0EA1
    1de8:	dd 24       	eor	r13, r13
    1dea:	c0 e0       	ldi	r28, 0x00	; 0
    1dec:	d0 e0       	ldi	r29, 0x00	; 0
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1dee:	3c e8       	ldi	r19, 0x8C	; 140
    1df0:	43 2e       	mov	r4, r19
    1df2:	30 e0       	ldi	r19, 0x00	; 0
    1df4:	53 2e       	mov	r5, r19
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1df6:	29 ea       	ldi	r18, 0xA9	; 169
    1df8:	62 2e       	mov	r6, r18
    1dfa:	20 e0       	ldi	r18, 0x00	; 0
    1dfc:	72 2e       	mov	r7, r18
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
    1dfe:	90 ea       	ldi	r25, 0xA0	; 160
    1e00:	89 2e       	mov	r8, r25
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	99 2e       	mov	r9, r25
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
    1e06:	87 e9       	ldi	r24, 0x97	; 151
    1e08:	a8 2e       	mov	r10, r24
    1e0a:	80 e0       	ldi	r24, 0x00	; 0
    1e0c:	b8 2e       	mov	r11, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    1e0e:	d8 01       	movw	r26, r16
    1e10:	8c 91       	ld	r24, X
    1e12:	88 23       	and	r24, r24
    1e14:	09 f4       	brne	.+2      	; 0x1e18 <printLockers+0x58>
    1e16:	6c c0       	rjmp	.+216    	; 0x1ef0 <printLockers+0x130>
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1e18:	00 d0       	rcall	.+0      	; 0x1e1a <printLockers+0x5a>
    1e1a:	00 d0       	rcall	.+0      	; 0x1e1c <printLockers+0x5c>
    1e1c:	00 d0       	rcall	.+0      	; 0x1e1e <printLockers+0x5e>
    1e1e:	ed b7       	in	r30, 0x3d	; 61
    1e20:	fe b7       	in	r31, 0x3e	; 62
    1e22:	31 96       	adiw	r30, 0x01	; 1
    1e24:	ad b7       	in	r26, 0x3d	; 61
    1e26:	be b7       	in	r27, 0x3e	; 62
    1e28:	12 96       	adiw	r26, 0x02	; 2
    1e2a:	fc 92       	st	X, r15
    1e2c:	ee 92       	st	-X, r14
    1e2e:	11 97       	sbiw	r26, 0x01	; 1
    1e30:	53 82       	std	Z+3, r5	; 0x03
    1e32:	42 82       	std	Z+2, r4	; 0x02
    1e34:	21 96       	adiw	r28, 0x01	; 1
    1e36:	d5 83       	std	Z+5, r29	; 0x05
    1e38:	c4 83       	std	Z+4, r28	; 0x04
    1e3a:	21 97       	sbiw	r28, 0x01	; 1
    1e3c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      if (tmpLock->threshold > tmpLock->acVal)
    1e40:	ed b7       	in	r30, 0x3d	; 61
    1e42:	fe b7       	in	r31, 0x3e	; 62
    1e44:	36 96       	adiw	r30, 0x06	; 6
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	fe bf       	out	0x3e, r31	; 62
    1e4c:	0f be       	out	0x3f, r0	; 63
    1e4e:	ed bf       	out	0x3d, r30	; 61
    1e50:	d8 01       	movw	r26, r16
    1e52:	11 96       	adiw	r26, 0x01	; 1
    1e54:	2d 91       	ld	r18, X+
    1e56:	3c 91       	ld	r19, X
    1e58:	12 97       	sbiw	r26, 0x02	; 2
    1e5a:	13 96       	adiw	r26, 0x03	; 3
    1e5c:	8d 91       	ld	r24, X+
    1e5e:	9c 91       	ld	r25, X
    1e60:	14 97       	sbiw	r26, 0x04	; 4
    1e62:	82 17       	cp	r24, r18
    1e64:	93 07       	cpc	r25, r19
    1e66:	48 f4       	brcc	.+18     	; 0x1e7a <printLockers+0xba>
        fprintf_P(stream, statusLockerOpenStr);
    1e68:	00 d0       	rcall	.+0      	; 0x1e6a <printLockers+0xaa>
    1e6a:	00 d0       	rcall	.+0      	; 0x1e6c <printLockers+0xac>
    1e6c:	ed b7       	in	r30, 0x3d	; 61
    1e6e:	fe b7       	in	r31, 0x3e	; 62
    1e70:	f2 82       	std	Z+2, r15	; 0x02
    1e72:	e1 82       	std	Z+1, r14	; 0x01
    1e74:	b4 82       	std	Z+4, r11	; 0x04
    1e76:	a3 82       	std	Z+3, r10	; 0x03
    1e78:	0c c0       	rjmp	.+24     	; 0x1e92 <printLockers+0xd2>
      else
        fprintf_P(stream, statusLockerCloseStr);
    1e7a:	00 d0       	rcall	.+0      	; 0x1e7c <printLockers+0xbc>
    1e7c:	00 d0       	rcall	.+0      	; 0x1e7e <printLockers+0xbe>
    1e7e:	ad b7       	in	r26, 0x3d	; 61
    1e80:	be b7       	in	r27, 0x3e	; 62
    1e82:	12 96       	adiw	r26, 0x02	; 2
    1e84:	fc 92       	st	X, r15
    1e86:	ee 92       	st	-X, r14
    1e88:	11 97       	sbiw	r26, 0x01	; 1
    1e8a:	14 96       	adiw	r26, 0x04	; 4
    1e8c:	9c 92       	st	X, r9
    1e8e:	8e 92       	st	-X, r8
    1e90:	13 97       	sbiw	r26, 0x03	; 3
    1e92:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    1e96:	0f 90       	pop	r0
    1e98:	0f 90       	pop	r0
    1e9a:	0f 90       	pop	r0
    1e9c:	0f 90       	pop	r0
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1e9e:	ed b7       	in	r30, 0x3d	; 61
    1ea0:	fe b7       	in	r31, 0x3e	; 62
    1ea2:	38 97       	sbiw	r30, 0x08	; 8
    1ea4:	0f b6       	in	r0, 0x3f	; 63
    1ea6:	f8 94       	cli
    1ea8:	fe bf       	out	0x3e, r31	; 62
    1eaa:	0f be       	out	0x3f, r0	; 63
    1eac:	ed bf       	out	0x3d, r30	; 61
    1eae:	31 96       	adiw	r30, 0x01	; 1
    1eb0:	ad b7       	in	r26, 0x3d	; 61
    1eb2:	be b7       	in	r27, 0x3e	; 62
    1eb4:	12 96       	adiw	r26, 0x02	; 2
    1eb6:	fc 92       	st	X, r15
    1eb8:	ee 92       	st	-X, r14
    1eba:	11 97       	sbiw	r26, 0x01	; 1
    1ebc:	73 82       	std	Z+3, r7	; 0x03
    1ebe:	62 82       	std	Z+2, r6	; 0x02
    1ec0:	d8 01       	movw	r26, r16
    1ec2:	11 96       	adiw	r26, 0x01	; 1
    1ec4:	8d 91       	ld	r24, X+
    1ec6:	9c 91       	ld	r25, X
    1ec8:	12 97       	sbiw	r26, 0x02	; 2
    1eca:	95 83       	std	Z+5, r25	; 0x05
    1ecc:	84 83       	std	Z+4, r24	; 0x04
    1ece:	13 96       	adiw	r26, 0x03	; 3
    1ed0:	8d 91       	ld	r24, X+
    1ed2:	9c 91       	ld	r25, X
    1ed4:	14 97       	sbiw	r26, 0x04	; 4
    1ed6:	97 83       	std	Z+7, r25	; 0x07
    1ed8:	86 83       	std	Z+6, r24	; 0x06
    1eda:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      result++;
    1ede:	d3 94       	inc	r13
    1ee0:	ed b7       	in	r30, 0x3d	; 61
    1ee2:	fe b7       	in	r31, 0x3e	; 62
    1ee4:	38 96       	adiw	r30, 0x08	; 8
    1ee6:	0f b6       	in	r0, 0x3f	; 63
    1ee8:	f8 94       	cli
    1eea:	fe bf       	out	0x3e, r31	; 62
    1eec:	0f be       	out	0x3f, r0	; 63
    1eee:	ed bf       	out	0x3d, r30	; 61
    1ef0:	21 96       	adiw	r28, 0x01	; 1
uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
    1ef2:	c4 30       	cpi	r28, 0x04	; 4
    1ef4:	d1 05       	cpc	r29, r1
    1ef6:	19 f0       	breq	.+6      	; 0x1efe <printLockers+0x13e>
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
      result++;
    }
    tmpLock++;
    1ef8:	0a 5f       	subi	r16, 0xFA	; 250
    1efa:	1f 4f       	sbci	r17, 0xFF	; 255
    1efc:	88 cf       	rjmp	.-240    	; 0x1e0e <printLockers+0x4e>
  }
  return result;
}
    1efe:	8d 2d       	mov	r24, r13
    1f00:	df 91       	pop	r29
    1f02:	cf 91       	pop	r28
    1f04:	1f 91       	pop	r17
    1f06:	0f 91       	pop	r16
    1f08:	ff 90       	pop	r15
    1f0a:	ef 90       	pop	r14
    1f0c:	df 90       	pop	r13
    1f0e:	bf 90       	pop	r11
    1f10:	af 90       	pop	r10
    1f12:	9f 90       	pop	r9
    1f14:	8f 90       	pop	r8
    1f16:	7f 90       	pop	r7
    1f18:	6f 90       	pop	r6
    1f1a:	5f 90       	pop	r5
    1f1c:	4f 90       	pop	r4
    1f1e:	08 95       	ret

00001f20 <LockersMemInit>:
   */
}

void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
    1f20:	88 e1       	ldi	r24, 0x18	; 24
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    1f28:	90 93 a1 0e 	sts	0x0EA1, r25
    1f2c:	80 93 a0 0e 	sts	0x0EA0, r24
}
    1f30:	08 95       	ret

00001f32 <hardwareInit>:
xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisję do czasu zakończenia wysyłania poprzedniego bajtu

void hardwareInit(void)
{
  //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    1f32:	0f b6       	in	r0, 0x3f	; 63
    1f34:	f8 94       	cli
    1f36:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    1f38:	81 e0       	ldi	r24, 0x01	; 1
    1f3a:	61 e0       	ldi	r22, 0x01	; 1
    1f3c:	0e 94 98 55 	call	0xab30	; 0xab30 <xQueueCreate>
    1f40:	90 93 68 0f 	sts	0x0F68, r25
    1f44:	80 93 67 0f 	sts	0x0F67, r24
  portEXIT_CRITICAL();
    1f48:	0f 90       	pop	r0
    1f4a:	0f be       	out	0x3f, r0	; 63

  DDRB = 0xF7;
    1f4c:	87 ef       	ldi	r24, 0xF7	; 247
    1f4e:	87 bb       	out	0x17, r24	; 23
  PORTB = 0xD1;
    1f50:	81 ed       	ldi	r24, 0xD1	; 209
    1f52:	88 bb       	out	0x18, r24	; 24
   7 - External SPI ASR 7 (MPC23S17)   0 - on;  1 - off
  */
  
  //DDRC = 0x00;  //External Memory

  DDRD = 0x00;
    1f54:	11 ba       	out	0x11, r1	; 17
   5 - External SPI ASR 1
   6 - External SPI ASR 2
   7 - External SPI ASR 3
   */

  DDRE  = 0x0E;
    1f56:	8e e0       	ldi	r24, 0x0E	; 14
    1f58:	82 b9       	out	0x02, r24	; 2
  PORTE = 0x0C;
    1f5a:	8c e0       	ldi	r24, 0x0C	; 12
    1f5c:	83 b9       	out	0x03, r24	; 3
   4 - INT 4
   5 - INT 5
   6 - INT 6
   7 - INT Enc28j60
  */
  DDRF = 0x00;    //JTAG and A/C
    1f5e:	10 92 61 00 	sts	0x0061, r1
  DDRG = 0x1F;
    1f62:	8f e1       	ldi	r24, 0x1F	; 31
    1f64:	80 93 64 00 	sts	0x0064, r24
   4 - RS485 TxEn
   5 - 
   6 - 
   7 - 
   */
}
    1f68:	08 95       	ret

00001f6a <sensorsTask>:
  LockersMemInit();
  rollersMemInit();
}

void sensorsTask(void* pvParameters)
{
    1f6a:	1f 93       	push	r17
  pvParameters = NULL;
  uint8_t addr = 255;
//  uint8_t i;

  MPC23s17SetDirA(0x00, 0);
    1f6c:	80 e0       	ldi	r24, 0x00	; 0
    1f6e:	60 e0       	ldi	r22, 0x00	; 0
    1f70:	0e 94 ef 29 	call	0x53de	; 0x53de <MPC23s17SetDirA>
  
  MPC23s17SetDirB(0x00, 0);
    1f74:	80 e0       	ldi	r24, 0x00	; 0
    1f76:	60 e0       	ldi	r22, 0x00	; 0
    1f78:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <MPC23s17SetDirB>

  for( ; ; )
  {
    uint16_t tmp;
    //Read power suply voltage
    tmp = MCP3008_getSampleSingle(0);
    1f7c:	80 e0       	ldi	r24, 0x00	; 0
    1f7e:	0e 94 0c 2a 	call	0x5418	; 0x5418 <MCP3008_getSampleSingle>
    voltage = (uint8_t)(tmp>>5);
    1f82:	65 e0       	ldi	r22, 0x05	; 5
    1f84:	96 95       	lsr	r25
    1f86:	87 95       	ror	r24
    1f88:	6a 95       	dec	r22
    1f8a:	e1 f7       	brne	.-8      	; 0x1f84 <sensorsTask+0x1a>
    1f8c:	80 93 ac 0e 	sts	0x0EAC, r24
    vTaskDelay(10);
    1f90:	8a e0       	ldi	r24, 0x0A	; 10
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    1f98:	81 e0       	ldi	r24, 0x01	; 1
    1f9a:	0e 94 0c 2a 	call	0x5418	; 0x5418 <MCP3008_getSampleSingle>
    tmp *=10;
    temperature = (uint8_t)(tmp / 24);
    1f9e:	9c 01       	movw	r18, r24
    1fa0:	53 e0       	ldi	r21, 0x03	; 3
    1fa2:	88 0f       	add	r24, r24
    1fa4:	99 1f       	adc	r25, r25
    1fa6:	5a 95       	dec	r21
    1fa8:	e1 f7       	brne	.-8      	; 0x1fa2 <sensorsTask+0x38>
    1faa:	22 0f       	add	r18, r18
    1fac:	33 1f       	adc	r19, r19
    1fae:	82 0f       	add	r24, r18
    1fb0:	93 1f       	adc	r25, r19
    1fb2:	68 e1       	ldi	r22, 0x18	; 24
    1fb4:	70 e0       	ldi	r23, 0x00	; 0
    1fb6:	0e 94 ef 59 	call	0xb3de	; 0xb3de <__udivmodhi4>
    1fba:	60 93 a4 0e 	sts	0x0EA4, r22
    vTaskDelay(10);
    1fbe:	8a e0       	ldi	r24, 0x0A	; 10
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
      
    //read lock
    checkLockerSensors();
    1fc6:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <checkLockerSensors>
    1fca:	11 e0       	ldi	r17, 0x01	; 1

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    {
      rs485rollerHello(addr);
    1fcc:	81 2f       	mov	r24, r17
    1fce:	0e 94 ea 49 	call	0x93d4	; 0x93d4 <rs485rollerHello>
      vTaskDelay(10);
    1fd2:	8a e0       	ldi	r24, 0x0A	; 10
    1fd4:	90 e0       	ldi	r25, 0x00	; 0
    1fd6:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    vTaskDelay(10);
      
    //read lock
    checkLockerSensors();

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1fda:	1f 5f       	subi	r17, 0xFF	; 255
    1fdc:	10 32       	cpi	r17, 0x20	; 32
    1fde:	b1 f7       	brne	.-20     	; 0x1fcc <sensorsTask+0x62>
    1fe0:	cd cf       	rjmp	.-102    	; 0x1f7c <sensorsTask+0x12>

00001fe2 <sensorsTaskInit>:



void sensorsTaskInit(void)
{
  LockersMemInit();
    1fe2:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <LockersMemInit>
  rollersMemInit();
    1fe6:	0e 94 c0 4b 	call	0x9780	; 0x9780 <rollersMemInit>
}
    1fea:	08 95       	ret

00001fec <enableFunction>:
  state->err1 = 0;
  state->err2 = 0;
}

static cliExRes_t enableFunction(cmdState_t *state)
{
    1fec:	fc 01       	movw	r30, r24
  if (state->cliMode != RESTRICTED_NORMAL)
    1fee:	80 a1       	ldd	r24, Z+32	; 0x20
    1ff0:	83 30       	cpi	r24, 0x03	; 3
    1ff2:	19 f4       	brne	.+6      	; 0x1ffa <enableFunction+0xe>
    1ff4:	25 e0       	ldi	r18, 0x05	; 5
    1ff6:	30 e0       	ldi	r19, 0x00	; 0
    1ff8:	08 c0       	rjmp	.+16     	; 0x200a <enableFunction+0x1e>
  {
    state->cmdList = cmdListEnable;
    1ffa:	80 e8       	ldi	r24, 0x80	; 128
    1ffc:	99 e0       	ldi	r25, 0x09	; 9
    1ffe:	92 a3       	std	Z+34, r25	; 0x22
    2000:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_ENABLE;
    2002:	81 e0       	ldi	r24, 0x01	; 1
    2004:	80 a3       	std	Z+32, r24	; 0x20
    2006:	20 e0       	ldi	r18, 0x00	; 0
    2008:	30 e0       	ldi	r19, 0x00	; 0
    return OK_SILENT;
  }
  return ERROR_OPERATION_NOT_ALLOWED;
}
    200a:	c9 01       	movw	r24, r18
    200c:	08 95       	ret

0000200e <disableFunction>:
static cliExRes_t disableFunction(cmdState_t *state)
{
    200e:	fc 01       	movw	r30, r24
  state->cmdList = cmdListNormal;
    2010:	8a e4       	ldi	r24, 0x4A	; 74
    2012:	99 e0       	ldi	r25, 0x09	; 9
    2014:	92 a3       	std	Z+34, r25	; 0x22
    2016:	81 a3       	std	Z+33, r24	; 0x21
  if (state->cliMode != RESTRICTED_NORMAL)
    2018:	80 a1       	ldd	r24, Z+32	; 0x20
    201a:	83 30       	cpi	r24, 0x03	; 3
    201c:	09 f0       	breq	.+2      	; 0x2020 <disableFunction+0x12>
  {
    state->cliMode = NR_NORMAL;
    201e:	10 a2       	std	Z+32, r1	; 0x20
  }
  return OK_SILENT;
}
    2020:	80 e0       	ldi	r24, 0x00	; 0
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	08 95       	ret

00002026 <configureModeFunction>:
static cliExRes_t configureModeFunction(cmdState_t *state)
{
    2026:	fc 01       	movw	r30, r24
  if (state->cliMode == NR_ENABLE)
    2028:	80 a1       	ldd	r24, Z+32	; 0x20
    202a:	81 30       	cpi	r24, 0x01	; 1
    202c:	19 f0       	breq	.+6      	; 0x2034 <configureModeFunction+0xe>
    202e:	25 e0       	ldi	r18, 0x05	; 5
    2030:	30 e0       	ldi	r19, 0x00	; 0
    2032:	08 c0       	rjmp	.+16     	; 0x2044 <configureModeFunction+0x1e>
  {
    state->cmdList = cmdListConfigure;
    2034:	86 e1       	ldi	r24, 0x16	; 22
    2036:	9a e0       	ldi	r25, 0x0A	; 10
    2038:	92 a3       	std	Z+34, r25	; 0x22
    203a:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_CONFIGURE;
    203c:	82 e0       	ldi	r24, 0x02	; 2
    203e:	80 a3       	std	Z+32, r24	; 0x20
    2040:	20 e0       	ldi	r18, 0x00	; 0
    2042:	30 e0       	ldi	r19, 0x00	; 0
    return OK_SILENT;
  }
  return ERROR_OPERATION_NOT_ALLOWED;
}
    2044:	c9 01       	movw	r24, r18
    2046:	08 95       	ret

00002048 <saveConfigFunction>:
}

static cliExRes_t saveConfigFunction(cmdState_t *state)
{
  state = NULL;
  saveConfiguration();
    2048:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <saveConfiguration>
  return OK_SILENT;
}
    204c:	80 e0       	ldi	r24, 0x00	; 0
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	08 95       	ret

00002052 <setMacAddrFunction>:
  ipSetConfigGw(gw);
  return OK_SILENT;
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
    2052:	cf 93       	push	r28
    2054:	df 93       	push	r29
    2056:	ec 01       	movw	r28, r24
  if (state->argc < 6)
    2058:	89 8d       	ldd	r24, Y+25	; 0x19
    205a:	86 30       	cpi	r24, 0x06	; 6
    205c:	18 f4       	brcc	.+6      	; 0x2064 <setMacAddrFunction+0x12>
    205e:	22 e0       	ldi	r18, 0x02	; 2
    2060:	30 e0       	ldi	r19, 0x00	; 0
    2062:	2a c0       	rjmp	.+84     	; 0x20b8 <setMacAddrFunction+0x66>
    return SYNTAX_ERROR;  
  
  nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	be 01       	movw	r22, r28
    2068:	0e 94 02 23 	call	0x4604	; 0x4604 <cmdlineGetArgHex>
    206c:	60 93 80 0e 	sts	0x0E80, r22
  nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
    2070:	82 e0       	ldi	r24, 0x02	; 2
    2072:	be 01       	movw	r22, r28
    2074:	0e 94 02 23 	call	0x4604	; 0x4604 <cmdlineGetArgHex>
    2078:	60 93 81 0e 	sts	0x0E81, r22
  nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
    207c:	83 e0       	ldi	r24, 0x03	; 3
    207e:	be 01       	movw	r22, r28
    2080:	0e 94 02 23 	call	0x4604	; 0x4604 <cmdlineGetArgHex>
    2084:	60 93 82 0e 	sts	0x0E82, r22
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
    2088:	84 e0       	ldi	r24, 0x04	; 4
    208a:	be 01       	movw	r22, r28
    208c:	0e 94 02 23 	call	0x4604	; 0x4604 <cmdlineGetArgHex>
    2090:	60 93 83 0e 	sts	0x0E83, r22
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
    2094:	85 e0       	ldi	r24, 0x05	; 5
    2096:	be 01       	movw	r22, r28
    2098:	0e 94 02 23 	call	0x4604	; 0x4604 <cmdlineGetArgHex>
    209c:	60 93 84 0e 	sts	0x0E84, r22
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
    20a0:	86 e0       	ldi	r24, 0x06	; 6
    20a2:	be 01       	movw	r22, r28
    20a4:	0e 94 02 23 	call	0x4604	; 0x4604 <cmdlineGetArgHex>
    20a8:	60 93 85 0e 	sts	0x0E85, r22
  nicSetMacAddress(nicState.mac.addr);
    20ac:	80 e8       	ldi	r24, 0x80	; 128
    20ae:	9e e0       	ldi	r25, 0x0E	; 14
    20b0:	0e 94 b8 2a 	call	0x5570	; 0x5570 <nicSetMacAddress>
    20b4:	20 e0       	ldi	r18, 0x00	; 0
    20b6:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    20b8:	c9 01       	movw	r24, r18
    20ba:	df 91       	pop	r29
    20bc:	cf 91       	pop	r28
    20be:	08 95       	ret

000020c0 <pingFunction>:
  printErrorInfo(state);
  return OK_SILENT;
}

static cliExRes_t pingFunction(cmdState_t *state)
{
    20c0:	cf 93       	push	r28
    20c2:	df 93       	push	r29
    20c4:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    20c6:	89 8d       	ldd	r24, Y+25	; 0x19
    20c8:	84 30       	cpi	r24, 0x04	; 4
    20ca:	18 f4       	brcc	.+6      	; 0x20d2 <pingFunction+0x12>
    20cc:	22 e0       	ldi	r18, 0x02	; 2
    20ce:	30 e0       	ldi	r19, 0x00	; 0
    20d0:	12 c0       	rjmp	.+36     	; 0x20f6 <pingFunction+0x36>
    return SYNTAX_ERROR;
  
  uint8_t ip[4];
  ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
    20d2:	81 e0       	ldi	r24, 0x01	; 1
    20d4:	be 01       	movw	r22, r28
    20d6:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
  ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
    20da:	82 e0       	ldi	r24, 0x02	; 2
    20dc:	be 01       	movw	r22, r28
    20de:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
  ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
    20e2:	83 e0       	ldi	r24, 0x03	; 3
    20e4:	be 01       	movw	r22, r28
    20e6:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
    20ea:	84 e0       	ldi	r24, 0x04	; 4
    20ec:	be 01       	movw	r22, r28
    20ee:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    20f2:	20 e0       	ldi	r18, 0x00	; 0
    20f4:	30 e0       	ldi	r19, 0x00	; 0

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
}
    20f6:	c9 01       	movw	r24, r18
    20f8:	df 91       	pop	r29
    20fa:	cf 91       	pop	r28
    20fc:	08 95       	ret

000020fe <setUdpFunction>:
  ipSetConfigIp(ip);
  return OK_SILENT;
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
    20fe:	6f 92       	push	r6
    2100:	7f 92       	push	r7
    2102:	8f 92       	push	r8
    2104:	9f 92       	push	r9
    2106:	af 92       	push	r10
    2108:	bf 92       	push	r11
    210a:	cf 92       	push	r12
    210c:	df 92       	push	r13
    210e:	ef 92       	push	r14
    2110:	ff 92       	push	r15
    2112:	0f 93       	push	r16
    2114:	1f 93       	push	r17
    2116:	cf 93       	push	r28
    2118:	df 93       	push	r29
    211a:	ec 01       	movw	r28, r24
  if (state->argc < 5)
    211c:	89 8d       	ldd	r24, Y+25	; 0x19
    211e:	85 30       	cpi	r24, 0x05	; 5
    2120:	18 f4       	brcc	.+6      	; 0x2128 <setUdpFunction+0x2a>
    2122:	22 e0       	ldi	r18, 0x02	; 2
    2124:	30 e0       	ldi	r19, 0x00	; 0
    2126:	58 c0       	rjmp	.+176    	; 0x21d8 <setUdpFunction+0xda>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2128:	81 e0       	ldi	r24, 0x01	; 1
    212a:	be 01       	movw	r22, r28
    212c:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2130:	3b 01       	movw	r6, r22
    2132:	4c 01       	movw	r8, r24
    2134:	82 e0       	ldi	r24, 0x02	; 2
    2136:	be 01       	movw	r22, r28
    2138:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    213c:	7b 01       	movw	r14, r22
    213e:	8c 01       	movw	r16, r24
    2140:	83 e0       	ldi	r24, 0x03	; 3
    2142:	be 01       	movw	r22, r28
    2144:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2148:	5b 01       	movw	r10, r22
    214a:	6c 01       	movw	r12, r24
    214c:	84 e0       	ldi	r24, 0x04	; 4
    214e:	be 01       	movw	r22, r28
    2150:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
  udpSocket->dstIp = ip;
    2154:	e0 91 a2 0e 	lds	r30, 0x0EA2
    2158:	f0 91 a3 0e 	lds	r31, 0x0EA3
    215c:	10 2f       	mov	r17, r16
    215e:	0f 2d       	mov	r16, r15
    2160:	fe 2c       	mov	r15, r14
    2162:	ee 24       	eor	r14, r14
    2164:	65 01       	movw	r12, r10
    2166:	bb 24       	eor	r11, r11
    2168:	aa 24       	eor	r10, r10
    216a:	ea 0c       	add	r14, r10
    216c:	fb 1c       	adc	r15, r11
    216e:	0c 1d       	adc	r16, r12
    2170:	1d 1d       	adc	r17, r13
    2172:	e6 0c       	add	r14, r6
    2174:	f7 1c       	adc	r15, r7
    2176:	08 1d       	adc	r16, r8
    2178:	19 1d       	adc	r17, r9
    217a:	96 2f       	mov	r25, r22
    217c:	88 27       	eor	r24, r24
    217e:	77 27       	eor	r23, r23
    2180:	66 27       	eor	r22, r22
    2182:	e6 0e       	add	r14, r22
    2184:	f7 1e       	adc	r15, r23
    2186:	08 1f       	adc	r16, r24
    2188:	19 1f       	adc	r17, r25
    218a:	e6 82       	std	Z+6, r14	; 0x06
    218c:	f7 82       	std	Z+7, r15	; 0x07
    218e:	00 87       	std	Z+8, r16	; 0x08
    2190:	11 87       	std	Z+9, r17	; 0x09
  
  uint16_t port = cmdlineGetArgInt(5, state);
    2192:	85 e0       	ldi	r24, 0x05	; 5
    2194:	be 01       	movw	r22, r28
    2196:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    219a:	dc 01       	movw	r26, r24
    219c:	cb 01       	movw	r24, r22
  udpSocket->srcPort = htons(port);
    219e:	00 91 a2 0e 	lds	r16, 0x0EA2
    21a2:	10 91 a3 0e 	lds	r17, 0x0EA3
    21a6:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    21aa:	f8 01       	movw	r30, r16
    21ac:	95 83       	std	Z+5, r25	; 0x05
    21ae:	84 83       	std	Z+4, r24	; 0x04
  
  if (state->argc > 5)
    21b0:	89 8d       	ldd	r24, Y+25	; 0x19
    21b2:	86 30       	cpi	r24, 0x06	; 6
    21b4:	78 f0       	brcs	.+30     	; 0x21d4 <setUdpFunction+0xd6>
  {
    port = cmdlineGetArgInt(6, state);
    21b6:	86 e0       	ldi	r24, 0x06	; 6
    21b8:	be 01       	movw	r22, r28
    21ba:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    21be:	dc 01       	movw	r26, r24
    21c0:	cb 01       	movw	r24, r22
    udpSocket->dstPort = htons(port);    
    21c2:	00 91 a2 0e 	lds	r16, 0x0EA2
    21c6:	10 91 a3 0e 	lds	r17, 0x0EA3
    21ca:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    21ce:	f8 01       	movw	r30, r16
    21d0:	93 83       	std	Z+3, r25	; 0x03
    21d2:	82 83       	std	Z+2, r24	; 0x02
    21d4:	20 e0       	ldi	r18, 0x00	; 0
    21d6:	30 e0       	ldi	r19, 0x00	; 0
  }
  return OK_SILENT;
}
    21d8:	c9 01       	movw	r24, r18
    21da:	df 91       	pop	r29
    21dc:	cf 91       	pop	r28
    21de:	1f 91       	pop	r17
    21e0:	0f 91       	pop	r16
    21e2:	ff 90       	pop	r15
    21e4:	ef 90       	pop	r14
    21e6:	df 90       	pop	r13
    21e8:	cf 90       	pop	r12
    21ea:	bf 90       	pop	r11
    21ec:	af 90       	pop	r10
    21ee:	9f 90       	pop	r9
    21f0:	8f 90       	pop	r8
    21f2:	7f 90       	pop	r7
    21f4:	6f 90       	pop	r6
    21f6:	08 95       	ret

000021f8 <setIpGwFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
    21f8:	6f 92       	push	r6
    21fa:	7f 92       	push	r7
    21fc:	8f 92       	push	r8
    21fe:	9f 92       	push	r9
    2200:	af 92       	push	r10
    2202:	bf 92       	push	r11
    2204:	cf 92       	push	r12
    2206:	df 92       	push	r13
    2208:	ef 92       	push	r14
    220a:	ff 92       	push	r15
    220c:	0f 93       	push	r16
    220e:	1f 93       	push	r17
    2210:	cf 93       	push	r28
    2212:	df 93       	push	r29
    2214:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    2216:	89 8d       	ldd	r24, Y+25	; 0x19
    2218:	84 30       	cpi	r24, 0x04	; 4
    221a:	18 f4       	brcc	.+6      	; 0x2222 <setIpGwFunction+0x2a>
    221c:	22 e0       	ldi	r18, 0x02	; 2
    221e:	30 e0       	ldi	r19, 0x00	; 0
    2220:	33 c0       	rjmp	.+102    	; 0x2288 <setIpGwFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2222:	81 e0       	ldi	r24, 0x01	; 1
    2224:	be 01       	movw	r22, r28
    2226:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    222a:	3b 01       	movw	r6, r22
    222c:	4c 01       	movw	r8, r24
    222e:	82 e0       	ldi	r24, 0x02	; 2
    2230:	be 01       	movw	r22, r28
    2232:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2236:	7b 01       	movw	r14, r22
    2238:	8c 01       	movw	r16, r24
    223a:	83 e0       	ldi	r24, 0x03	; 3
    223c:	be 01       	movw	r22, r28
    223e:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2242:	5b 01       	movw	r10, r22
    2244:	6c 01       	movw	r12, r24
    2246:	84 e0       	ldi	r24, 0x04	; 4
    2248:	be 01       	movw	r22, r28
    224a:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
  ipSetConfigGw(gw);
    224e:	10 2f       	mov	r17, r16
    2250:	0f 2d       	mov	r16, r15
    2252:	fe 2c       	mov	r15, r14
    2254:	ee 24       	eor	r14, r14
    2256:	65 01       	movw	r12, r10
    2258:	bb 24       	eor	r11, r11
    225a:	aa 24       	eor	r10, r10
    225c:	ea 0c       	add	r14, r10
    225e:	fb 1c       	adc	r15, r11
    2260:	0c 1d       	adc	r16, r12
    2262:	1d 1d       	adc	r17, r13
    2264:	e6 0c       	add	r14, r6
    2266:	f7 1c       	adc	r15, r7
    2268:	08 1d       	adc	r16, r8
    226a:	19 1d       	adc	r17, r9
    226c:	96 2f       	mov	r25, r22
    226e:	88 27       	eor	r24, r24
    2270:	77 27       	eor	r23, r23
    2272:	66 27       	eor	r22, r22
    2274:	e6 0e       	add	r14, r22
    2276:	f7 1e       	adc	r15, r23
    2278:	08 1f       	adc	r16, r24
    227a:	19 1f       	adc	r17, r25
    227c:	c8 01       	movw	r24, r16
    227e:	b7 01       	movw	r22, r14
    2280:	0e 94 b6 32 	call	0x656c	; 0x656c <ipSetConfigGw>
    2284:	20 e0       	ldi	r18, 0x00	; 0
    2286:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2288:	c9 01       	movw	r24, r18
    228a:	df 91       	pop	r29
    228c:	cf 91       	pop	r28
    228e:	1f 91       	pop	r17
    2290:	0f 91       	pop	r16
    2292:	ff 90       	pop	r15
    2294:	ef 90       	pop	r14
    2296:	df 90       	pop	r13
    2298:	cf 90       	pop	r12
    229a:	bf 90       	pop	r11
    229c:	af 90       	pop	r10
    229e:	9f 90       	pop	r9
    22a0:	8f 90       	pop	r8
    22a2:	7f 90       	pop	r7
    22a4:	6f 90       	pop	r6
    22a6:	08 95       	ret

000022a8 <setIpMaskFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
    22a8:	fc 01       	movw	r30, r24
  if (state->argc < 1)
    22aa:	81 8d       	ldd	r24, Z+25	; 0x19
    22ac:	88 23       	and	r24, r24
    22ae:	19 f4       	brne	.+6      	; 0x22b6 <setIpMaskFunction+0xe>
    22b0:	22 e0       	ldi	r18, 0x02	; 2
    22b2:	30 e0       	ldi	r19, 0x00	; 0
    22b4:	17 c0       	rjmp	.+46     	; 0x22e4 <setIpMaskFunction+0x3c>
    return SYNTAX_ERROR;
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
    22b6:	81 e0       	ldi	r24, 0x01	; 1
    22b8:	bf 01       	movw	r22, r30
    22ba:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
  
  ipSetConfigMask(mask);
    22be:	20 e2       	ldi	r18, 0x20	; 32
    22c0:	30 e0       	ldi	r19, 0x00	; 0
    22c2:	26 1b       	sub	r18, r22
    22c4:	37 0b       	sbc	r19, r23
    22c6:	6f ef       	ldi	r22, 0xFF	; 255
    22c8:	7f ef       	ldi	r23, 0xFF	; 255
    22ca:	8f ef       	ldi	r24, 0xFF	; 255
    22cc:	9f ef       	ldi	r25, 0xFF	; 255
    22ce:	04 c0       	rjmp	.+8      	; 0x22d8 <setIpMaskFunction+0x30>
    22d0:	96 95       	lsr	r25
    22d2:	87 95       	ror	r24
    22d4:	77 95       	ror	r23
    22d6:	67 95       	ror	r22
    22d8:	2a 95       	dec	r18
    22da:	d2 f7       	brpl	.-12     	; 0x22d0 <setIpMaskFunction+0x28>
    22dc:	0e 94 ad 32 	call	0x655a	; 0x655a <ipSetConfigMask>
    22e0:	20 e0       	ldi	r18, 0x00	; 0
    22e2:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    22e4:	c9 01       	movw	r24, r18
    22e6:	08 95       	ret

000022e8 <setIpFunction>:
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
  return OK_SILENT;
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
    22e8:	6f 92       	push	r6
    22ea:	7f 92       	push	r7
    22ec:	8f 92       	push	r8
    22ee:	9f 92       	push	r9
    22f0:	af 92       	push	r10
    22f2:	bf 92       	push	r11
    22f4:	cf 92       	push	r12
    22f6:	df 92       	push	r13
    22f8:	ef 92       	push	r14
    22fa:	ff 92       	push	r15
    22fc:	0f 93       	push	r16
    22fe:	1f 93       	push	r17
    2300:	cf 93       	push	r28
    2302:	df 93       	push	r29
    2304:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    2306:	89 8d       	ldd	r24, Y+25	; 0x19
    2308:	84 30       	cpi	r24, 0x04	; 4
    230a:	18 f4       	brcc	.+6      	; 0x2312 <setIpFunction+0x2a>
    230c:	22 e0       	ldi	r18, 0x02	; 2
    230e:	30 e0       	ldi	r19, 0x00	; 0
    2310:	33 c0       	rjmp	.+102    	; 0x2378 <setIpFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2312:	81 e0       	ldi	r24, 0x01	; 1
    2314:	be 01       	movw	r22, r28
    2316:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    231a:	3b 01       	movw	r6, r22
    231c:	4c 01       	movw	r8, r24
    231e:	82 e0       	ldi	r24, 0x02	; 2
    2320:	be 01       	movw	r22, r28
    2322:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2326:	7b 01       	movw	r14, r22
    2328:	8c 01       	movw	r16, r24
    232a:	83 e0       	ldi	r24, 0x03	; 3
    232c:	be 01       	movw	r22, r28
    232e:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2332:	5b 01       	movw	r10, r22
    2334:	6c 01       	movw	r12, r24
    2336:	84 e0       	ldi	r24, 0x04	; 4
    2338:	be 01       	movw	r22, r28
    233a:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
  
  ipSetConfigIp(ip);
    233e:	10 2f       	mov	r17, r16
    2340:	0f 2d       	mov	r16, r15
    2342:	fe 2c       	mov	r15, r14
    2344:	ee 24       	eor	r14, r14
    2346:	65 01       	movw	r12, r10
    2348:	bb 24       	eor	r11, r11
    234a:	aa 24       	eor	r10, r10
    234c:	ea 0c       	add	r14, r10
    234e:	fb 1c       	adc	r15, r11
    2350:	0c 1d       	adc	r16, r12
    2352:	1d 1d       	adc	r17, r13
    2354:	e6 0c       	add	r14, r6
    2356:	f7 1c       	adc	r15, r7
    2358:	08 1d       	adc	r16, r8
    235a:	19 1d       	adc	r17, r9
    235c:	96 2f       	mov	r25, r22
    235e:	88 27       	eor	r24, r24
    2360:	77 27       	eor	r23, r23
    2362:	66 27       	eor	r22, r22
    2364:	e6 0e       	add	r14, r22
    2366:	f7 1e       	adc	r15, r23
    2368:	08 1f       	adc	r16, r24
    236a:	19 1f       	adc	r17, r25
    236c:	c8 01       	movw	r24, r16
    236e:	b7 01       	movw	r22, r14
    2370:	0e 94 a4 32 	call	0x6548	; 0x6548 <ipSetConfigIp>
    2374:	20 e0       	ldi	r18, 0x00	; 0
    2376:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2378:	c9 01       	movw	r24, r18
    237a:	df 91       	pop	r29
    237c:	cf 91       	pop	r28
    237e:	1f 91       	pop	r17
    2380:	0f 91       	pop	r16
    2382:	ff 90       	pop	r15
    2384:	ef 90       	pop	r14
    2386:	df 90       	pop	r13
    2388:	cf 90       	pop	r12
    238a:	bf 90       	pop	r11
    238c:	af 90       	pop	r10
    238e:	9f 90       	pop	r9
    2390:	8f 90       	pop	r8
    2392:	7f 90       	pop	r7
    2394:	6f 90       	pop	r6
    2396:	08 95       	ret

00002398 <czytajAC_Function>:
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}

static cliExRes_t czytajAC_Function(cmdState_t *state)
{
    2398:	ff 92       	push	r15
    239a:	0f 93       	push	r16
    239c:	1f 93       	push	r17
    239e:	8c 01       	movw	r16, r24
  uint8_t nrWejscia = cmdlineGetArgInt(1, state);
    23a0:	81 e0       	ldi	r24, 0x01	; 1
    23a2:	b8 01       	movw	r22, r16
    23a4:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    23a8:	f6 2e       	mov	r15, r22
  uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
    23aa:	86 2f       	mov	r24, r22
    23ac:	0e 94 0c 2a 	call	0x5418	; 0x5418 <MCP3008_getSampleSingle>
  fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
    23b0:	2d b7       	in	r18, 0x3d	; 61
    23b2:	3e b7       	in	r19, 0x3e	; 62
    23b4:	28 50       	subi	r18, 0x08	; 8
    23b6:	30 40       	sbci	r19, 0x00	; 0
    23b8:	0f b6       	in	r0, 0x3f	; 63
    23ba:	f8 94       	cli
    23bc:	3e bf       	out	0x3e, r19	; 62
    23be:	0f be       	out	0x3f, r0	; 63
    23c0:	2d bf       	out	0x3d, r18	; 61
    23c2:	ed b7       	in	r30, 0x3d	; 61
    23c4:	fe b7       	in	r31, 0x3e	; 62
    23c6:	31 96       	adiw	r30, 0x01	; 1
    23c8:	d8 01       	movw	r26, r16
    23ca:	5a 96       	adiw	r26, 0x1a	; 26
    23cc:	2d 91       	ld	r18, X+
    23ce:	3c 91       	ld	r19, X
    23d0:	5b 97       	sbiw	r26, 0x1b	; 27
    23d2:	ad b7       	in	r26, 0x3d	; 61
    23d4:	be b7       	in	r27, 0x3e	; 62
    23d6:	12 96       	adiw	r26, 0x02	; 2
    23d8:	3c 93       	st	X, r19
    23da:	2e 93       	st	-X, r18
    23dc:	11 97       	sbiw	r26, 0x01	; 1
    23de:	24 e6       	ldi	r18, 0x64	; 100
    23e0:	3a e0       	ldi	r19, 0x0A	; 10
    23e2:	33 83       	std	Z+3, r19	; 0x03
    23e4:	22 83       	std	Z+2, r18	; 0x02
    23e6:	f4 82       	std	Z+4, r15	; 0x04
    23e8:	15 82       	std	Z+5, r1	; 0x05
    23ea:	97 83       	std	Z+7, r25	; 0x07
    23ec:	86 83       	std	Z+6, r24	; 0x06
    23ee:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    23f2:	2d b7       	in	r18, 0x3d	; 61
    23f4:	3e b7       	in	r19, 0x3e	; 62
    23f6:	28 5f       	subi	r18, 0xF8	; 248
    23f8:	3f 4f       	sbci	r19, 0xFF	; 255
    23fa:	0f b6       	in	r0, 0x3f	; 63
    23fc:	f8 94       	cli
    23fe:	3e bf       	out	0x3e, r19	; 62
    2400:	0f be       	out	0x3f, r0	; 63
    2402:	2d bf       	out	0x3d, r18	; 61
  return OK_SILENT;
}
    2404:	80 e0       	ldi	r24, 0x00	; 0
    2406:	90 e0       	ldi	r25, 0x00	; 0
    2408:	1f 91       	pop	r17
    240a:	0f 91       	pop	r16
    240c:	ff 90       	pop	r15
    240e:	08 95       	ret

00002410 <printErrorInfo>:
{
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
}

void printErrorInfo(cmdState_t *state)
{
    2410:	cf 93       	push	r28
    2412:	df 93       	push	r29
    2414:	ec 01       	movw	r28, r24
  if (state->errno != 0)
    2416:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2418:	88 23       	and	r24, r24
    241a:	71 f1       	breq	.+92     	; 0x2478 <printErrorInfo+0x68>
  {
    fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->err1, state->err2);
    241c:	e8 2f       	mov	r30, r24
    241e:	f0 e0       	ldi	r31, 0x00	; 0
    2420:	ee 0f       	add	r30, r30
    2422:	ff 1f       	adc	r31, r31
    2424:	ee 5c       	subi	r30, 0xCE	; 206
    2426:	f6 4f       	sbci	r31, 0xF6	; 246
    2428:	25 91       	lpm	r18, Z+
    242a:	34 91       	lpm	r19, Z+
    242c:	8d b7       	in	r24, 0x3d	; 61
    242e:	9e b7       	in	r25, 0x3e	; 62
    2430:	08 97       	sbiw	r24, 0x08	; 8
    2432:	0f b6       	in	r0, 0x3f	; 63
    2434:	f8 94       	cli
    2436:	9e bf       	out	0x3e, r25	; 62
    2438:	0f be       	out	0x3f, r0	; 63
    243a:	8d bf       	out	0x3d, r24	; 61
    243c:	ed b7       	in	r30, 0x3d	; 61
    243e:	fe b7       	in	r31, 0x3e	; 62
    2440:	31 96       	adiw	r30, 0x01	; 1
    2442:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2444:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2446:	ad b7       	in	r26, 0x3d	; 61
    2448:	be b7       	in	r27, 0x3e	; 62
    244a:	12 96       	adiw	r26, 0x02	; 2
    244c:	9c 93       	st	X, r25
    244e:	8e 93       	st	-X, r24
    2450:	11 97       	sbiw	r26, 0x01	; 1
    2452:	33 83       	std	Z+3, r19	; 0x03
    2454:	22 83       	std	Z+2, r18	; 0x02
    2456:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2458:	9e 8d       	ldd	r25, Y+30	; 0x1e
    245a:	95 83       	std	Z+5, r25	; 0x05
    245c:	84 83       	std	Z+4, r24	; 0x04
    245e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2460:	86 83       	std	Z+6, r24	; 0x06
    2462:	17 82       	std	Z+7, r1	; 0x07
    2464:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    2468:	8d b7       	in	r24, 0x3d	; 61
    246a:	9e b7       	in	r25, 0x3e	; 62
    246c:	08 96       	adiw	r24, 0x08	; 8
    246e:	0f b6       	in	r0, 0x3f	; 63
    2470:	f8 94       	cli
    2472:	9e bf       	out	0x3e, r25	; 62
    2474:	0f be       	out	0x3f, r0	; 63
    2476:	8d bf       	out	0x3d, r24	; 61
  }
  state->errno = 0;
    2478:	1c 8e       	std	Y+28, r1	; 0x1c
  state->err1 = 0;
    247a:	1e 8e       	std	Y+30, r1	; 0x1e
    247c:	1d 8e       	std	Y+29, r1	; 0x1d
  state->err2 = 0;
    247e:	1f 8e       	std	Y+31, r1	; 0x1f
}
    2480:	df 91       	pop	r29
    2482:	cf 91       	pop	r28
    2484:	08 95       	ret

00002486 <setTimeFunction>:
  return SYNTAX_ERROR;
}


static cliExRes_t setTimeFunction(cmdState_t *state)
{
    2486:	ef 92       	push	r14
    2488:	ff 92       	push	r15
    248a:	0f 93       	push	r16
    248c:	1f 93       	push	r17
    248e:	8c 01       	movw	r16, r24
  uint8_t godzina =  cmdlineGetArgInt(1, state);
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	b8 01       	movw	r22, r16
    2494:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2498:	f6 2e       	mov	r15, r22
  uint8_t minuta  =  cmdlineGetArgInt(2, state);
    249a:	82 e0       	ldi	r24, 0x02	; 2
    249c:	b8 01       	movw	r22, r16
    249e:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    24a2:	e6 2e       	mov	r14, r22
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
    24a4:	83 e0       	ldi	r24, 0x03	; 3
    24a6:	b8 01       	movw	r22, r16
    24a8:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    24ac:	16 2f       	mov	r17, r22
  
  ds1305start();
    24ae:	0e 94 8d 28 	call	0x511a	; 0x511a <ds1305start>

  uint8_t cDzies = godzina/10;
    24b2:	8f 2d       	mov	r24, r15
    24b4:	6a e0       	ldi	r22, 0x0A	; 10
    24b6:	0e 94 e3 59 	call	0xb3c6	; 0xb3c6 <__udivmodqi4>
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
    24ba:	28 2f       	mov	r18, r24
    24bc:	23 70       	andi	r18, 0x03	; 3
    24be:	a5 eb       	ldi	r26, 0xB5	; 181
    24c0:	be e0       	ldi	r27, 0x0E	; 14
    24c2:	22 95       	swap	r18
    24c4:	20 7f       	andi	r18, 0xF0	; 240
    24c6:	90 91 b5 0e 	lds	r25, 0x0EB5
    24ca:	9f 7c       	andi	r25, 0xCF	; 207
    24cc:	92 2b       	or	r25, r18
    24ce:	90 93 b5 0e 	sts	0x0EB5, r25
  czasRtc.hours.syst24.cJedn  = cJedn;
    24d2:	46 ef       	ldi	r20, 0xF6	; 246
    24d4:	5f ef       	ldi	r21, 0xFF	; 255
    24d6:	84 9f       	mul	r24, r20
    24d8:	80 2d       	mov	r24, r0
    24da:	11 24       	eor	r1, r1
    24dc:	8f 0d       	add	r24, r15
    24de:	8f 70       	andi	r24, 0x0F	; 15
    24e0:	90 91 b5 0e 	lds	r25, 0x0EB5
    24e4:	90 7f       	andi	r25, 0xF0	; 240
    24e6:	98 2b       	or	r25, r24
    24e8:	90 93 b5 0e 	sts	0x0EB5, r25
  
  cDzies = minuta/10;
    24ec:	8e 2d       	mov	r24, r14
    24ee:	0e 94 e3 59 	call	0xb3c6	; 0xb3c6 <__udivmodqi4>
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
    24f2:	28 2f       	mov	r18, r24
    24f4:	27 70       	andi	r18, 0x07	; 7
    24f6:	fd 01       	movw	r30, r26
    24f8:	22 95       	swap	r18
    24fa:	20 7f       	andi	r18, 0xF0	; 240
    24fc:	92 91       	ld	r25, -Z
    24fe:	9f 78       	andi	r25, 0x8F	; 143
    2500:	92 2b       	or	r25, r18
    2502:	90 83       	st	Z, r25
  czasRtc.minutes.cJedn  = cJedn;
    2504:	84 9f       	mul	r24, r20
    2506:	80 2d       	mov	r24, r0
    2508:	11 24       	eor	r1, r1
    250a:	8e 0d       	add	r24, r14
    250c:	8f 70       	andi	r24, 0x0F	; 15
    250e:	90 81       	ld	r25, Z
    2510:	90 7f       	andi	r25, 0xF0	; 240
    2512:	98 2b       	or	r25, r24
    2514:	90 83       	st	Z, r25
  
  cDzies = sekunda/10;
    2516:	81 2f       	mov	r24, r17
    2518:	0e 94 e3 59 	call	0xb3c6	; 0xb3c6 <__udivmodqi4>
  cJedn  = sekunda - cDzies * 10;
  czasRtc.seconds.cDzies = cDzies;
    251c:	28 2f       	mov	r18, r24
    251e:	27 70       	andi	r18, 0x07	; 7
    2520:	12 97       	sbiw	r26, 0x02	; 2
    2522:	22 95       	swap	r18
    2524:	20 7f       	andi	r18, 0xF0	; 240
    2526:	9c 91       	ld	r25, X
    2528:	9f 78       	andi	r25, 0x8F	; 143
    252a:	92 2b       	or	r25, r18
    252c:	9c 93       	st	X, r25
  czasRtc.seconds.cJedn  = cJedn;
    252e:	84 9f       	mul	r24, r20
    2530:	80 2d       	mov	r24, r0
    2532:	11 24       	eor	r1, r1
    2534:	81 0f       	add	r24, r17
    2536:	8f 70       	andi	r24, 0x0F	; 15
    2538:	9c 91       	ld	r25, X
    253a:	90 7f       	andi	r25, 0xF0	; 240
    253c:	98 2b       	or	r25, r24
    253e:	9c 93       	st	X, r25
  
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
    2540:	cd 01       	movw	r24, r26
    2542:	0e 94 c0 28 	call	0x5180	; 0x5180 <setTimeDecoded>
  return OK_SILENT;
}
    2546:	80 e0       	ldi	r24, 0x00	; 0
    2548:	90 e0       	ldi	r25, 0x00	; 0
    254a:	1f 91       	pop	r17
    254c:	0f 91       	pop	r16
    254e:	ff 90       	pop	r15
    2550:	ef 90       	pop	r14
    2552:	08 95       	ret

00002554 <ustawPortRezystor>:
  MPC23s17SetPortB(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
    2554:	fc 01       	movw	r30, r24
  if (state->argc < 1)
    2556:	81 8d       	ldd	r24, Z+25	; 0x19
    2558:	88 23       	and	r24, r24
    255a:	19 f4       	brne	.+6      	; 0x2562 <ustawPortRezystor+0xe>
    255c:	22 e0       	ldi	r18, 0x02	; 2
    255e:	30 e0       	ldi	r19, 0x00	; 0
    2560:	09 c0       	rjmp	.+18     	; 0x2574 <ustawPortRezystor+0x20>
    return SYNTAX_ERROR;

  uint8_t wartosc = cmdlineGetArgInt(1, state);
    2562:	81 e0       	ldi	r24, 0x01	; 1
    2564:	bf 01       	movw	r22, r30
    2566:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    256a:	86 2f       	mov	r24, r22
  
  MCP4150_setValue(wartosc);
    256c:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <MCP4150_setValue>
    2570:	20 e0       	ldi	r18, 0x00	; 0
    2572:	30 e0       	ldi	r19, 0x00	; 0
  
  return OK_SILENT;
}
    2574:	c9 01       	movw	r24, r18
    2576:	08 95       	ret

00002578 <ustawPortExtBFunction>:
  MPC23s17SetPortA(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
{
    2578:	1f 93       	push	r17
    257a:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2582:	16 2f       	mov	r17, r22
  MPC23s17SetDirB(0x00, 0);
    2584:	80 e0       	ldi	r24, 0x00	; 0
    2586:	60 e0       	ldi	r22, 0x00	; 0
    2588:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <MPC23s17SetDirB>
  MPC23s17SetPortB(wyjscie, 0);
    258c:	81 2f       	mov	r24, r17
    258e:	60 e0       	ldi	r22, 0x00	; 0
    2590:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MPC23s17SetPortB>
  return OK_SILENT;
}
    2594:	80 e0       	ldi	r24, 0x00	; 0
    2596:	90 e0       	ldi	r25, 0x00	; 0
    2598:	1f 91       	pop	r17
    259a:	08 95       	ret

0000259c <ustawPortExtAFunction>:
  
  return ERROR_SILENT;
}

static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
{
    259c:	1f 93       	push	r17
    259e:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    25a0:	81 e0       	ldi	r24, 0x01	; 1
    25a2:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    25a6:	16 2f       	mov	r17, r22
  MPC23s17SetDirA(0x00, 0);
    25a8:	80 e0       	ldi	r24, 0x00	; 0
    25aa:	60 e0       	ldi	r22, 0x00	; 0
    25ac:	0e 94 ef 29 	call	0x53de	; 0x53de <MPC23s17SetDirA>
  MPC23s17SetPortA(wyjscie, 0);
    25b0:	81 2f       	mov	r24, r17
    25b2:	60 e0       	ldi	r22, 0x00	; 0
    25b4:	0e 94 b6 29 	call	0x536c	; 0x536c <MPC23s17SetPortA>
  return OK_SILENT;
}
    25b8:	80 e0       	ldi	r24, 0x00	; 0
    25ba:	90 e0       	ldi	r25, 0x00	; 0
    25bc:	1f 91       	pop	r17
    25be:	08 95       	ret

000025c0 <curtainDownFunction>:
  cmdPrintHelp(state);
  return OK_SILENT;
}

static cliExRes_t curtainDownFunction(cmdState_t *state)
{
    25c0:	ff 92       	push	r15
    25c2:	0f 93       	push	r16
    25c4:	1f 93       	push	r17
    25c6:	cf 93       	push	r28
    25c8:	df 93       	push	r29
    25ca:	ec 01       	movw	r28, r24
  uint8_t nrRolety;
  uint8_t nrSterownika;
  uint8_t wartosc;
  
  nrSterownika = cmdlineGetArgInt(1, state);
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	be 01       	movw	r22, r28
    25d0:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    25d4:	f6 2e       	mov	r15, r22
  nrRolety = cmdlineGetArgInt(2, state);
    25d6:	82 e0       	ldi	r24, 0x02	; 2
    25d8:	be 01       	movw	r22, r28
    25da:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    25de:	16 2f       	mov	r17, r22
  nrRolety &= 0x01;
    25e0:	11 70       	andi	r17, 0x01	; 1
  wartosc = cmdlineGetArgInt(3, state);
    25e2:	83 e0       	ldi	r24, 0x03	; 3
    25e4:	be 01       	movw	r22, r28
    25e6:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    25ea:	06 2f       	mov	r16, r22

  fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
    25ec:	2d b7       	in	r18, 0x3d	; 61
    25ee:	3e b7       	in	r19, 0x3e	; 62
    25f0:	28 50       	subi	r18, 0x08	; 8
    25f2:	30 40       	sbci	r19, 0x00	; 0
    25f4:	0f b6       	in	r0, 0x3f	; 63
    25f6:	f8 94       	cli
    25f8:	3e bf       	out	0x3e, r19	; 62
    25fa:	0f be       	out	0x3f, r0	; 63
    25fc:	2d bf       	out	0x3d, r18	; 61
    25fe:	ed b7       	in	r30, 0x3d	; 61
    2600:	fe b7       	in	r31, 0x3e	; 62
    2602:	31 96       	adiw	r30, 0x01	; 1
    2604:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2606:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2608:	ad b7       	in	r26, 0x3d	; 61
    260a:	be b7       	in	r27, 0x3e	; 62
    260c:	12 96       	adiw	r26, 0x02	; 2
    260e:	9c 93       	st	X, r25
    2610:	8e 93       	st	-X, r24
    2612:	11 97       	sbiw	r26, 0x01	; 1
    2614:	82 ed       	ldi	r24, 0xD2	; 210
    2616:	93 e0       	ldi	r25, 0x03	; 3
    2618:	93 83       	std	Z+3, r25	; 0x03
    261a:	82 83       	std	Z+2, r24	; 0x02
    261c:	f4 82       	std	Z+4, r15	; 0x04
    261e:	15 82       	std	Z+5, r1	; 0x05
    2620:	81 2f       	mov	r24, r17
    2622:	90 e0       	ldi	r25, 0x00	; 0
    2624:	01 96       	adiw	r24, 0x01	; 1
    2626:	97 83       	std	Z+7, r25	; 0x07
    2628:	86 83       	std	Z+6, r24	; 0x06
    262a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>

  if ((wartosc > 0) && (wartosc <=100))
    262e:	80 2f       	mov	r24, r16
    2630:	81 50       	subi	r24, 0x01	; 1
    2632:	2d b7       	in	r18, 0x3d	; 61
    2634:	3e b7       	in	r19, 0x3e	; 62
    2636:	28 5f       	subi	r18, 0xF8	; 248
    2638:	3f 4f       	sbci	r19, 0xFF	; 255
    263a:	0f b6       	in	r0, 0x3f	; 63
    263c:	f8 94       	cli
    263e:	3e bf       	out	0x3e, r19	; 62
    2640:	0f be       	out	0x3f, r0	; 63
    2642:	2d bf       	out	0x3d, r18	; 61
    2644:	84 36       	cpi	r24, 0x64	; 100
    2646:	f8 f4       	brcc	.+62     	; 0x2686 <curtainDownFunction+0xc6>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    2648:	00 d0       	rcall	.+0      	; 0x264a <curtainDownFunction+0x8a>
    264a:	00 d0       	rcall	.+0      	; 0x264c <curtainDownFunction+0x8c>
    264c:	00 d0       	rcall	.+0      	; 0x264e <curtainDownFunction+0x8e>
    264e:	ed b7       	in	r30, 0x3d	; 61
    2650:	fe b7       	in	r31, 0x3e	; 62
    2652:	31 96       	adiw	r30, 0x01	; 1
    2654:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2656:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2658:	ad b7       	in	r26, 0x3d	; 61
    265a:	be b7       	in	r27, 0x3e	; 62
    265c:	12 96       	adiw	r26, 0x02	; 2
    265e:	9c 93       	st	X, r25
    2660:	8e 93       	st	-X, r24
    2662:	11 97       	sbiw	r26, 0x01	; 1
    2664:	85 e0       	ldi	r24, 0x05	; 5
    2666:	94 e0       	ldi	r25, 0x04	; 4
    2668:	93 83       	std	Z+3, r25	; 0x03
    266a:	82 83       	std	Z+2, r24	; 0x02
    266c:	04 83       	std	Z+4, r16	; 0x04
    266e:	15 82       	std	Z+5, r1	; 0x05
    2670:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    2674:	2d b7       	in	r18, 0x3d	; 61
    2676:	3e b7       	in	r19, 0x3e	; 62
    2678:	2a 5f       	subi	r18, 0xFA	; 250
    267a:	3f 4f       	sbci	r19, 0xFF	; 255
    267c:	0f b6       	in	r0, 0x3f	; 63
    267e:	f8 94       	cli
    2680:	3e bf       	out	0x3e, r19	; 62
    2682:	0f be       	out	0x3f, r0	; 63
    2684:	2d bf       	out	0x3d, r18	; 61

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
    2686:	8f 2d       	mov	r24, r15
    2688:	61 2f       	mov	r22, r17
    268a:	40 2f       	mov	r20, r16
    268c:	0e 94 9f 43 	call	0x873e	; 0x873e <rs485curtainDown>
  
  if (result == 0)
    2690:	88 23       	and	r24, r24
    2692:	19 f0       	breq	.+6      	; 0x269a <curtainDownFunction+0xda>
    2694:	23 e0       	ldi	r18, 0x03	; 3
    2696:	30 e0       	ldi	r19, 0x00	; 0
    2698:	02 c0       	rjmp	.+4      	; 0x269e <curtainDownFunction+0xde>
    269a:	21 e0       	ldi	r18, 0x01	; 1
    269c:	30 e0       	ldi	r19, 0x00	; 0
    return OK_INFORM;
  
  return ERROR_SILENT;
}
    269e:	c9 01       	movw	r24, r18
    26a0:	df 91       	pop	r29
    26a2:	cf 91       	pop	r28
    26a4:	1f 91       	pop	r17
    26a6:	0f 91       	pop	r16
    26a8:	ff 90       	pop	r15
    26aa:	08 95       	ret

000026ac <curtainUpFunction>:

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
    26ac:	ff 92       	push	r15
    26ae:	0f 93       	push	r16
    26b0:	1f 93       	push	r17
    26b2:	cf 93       	push	r28
    26b4:	df 93       	push	r29
    26b6:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    26b8:	89 8d       	ldd	r24, Y+25	; 0x19
    26ba:	82 30       	cpi	r24, 0x02	; 2
    26bc:	18 f4       	brcc	.+6      	; 0x26c4 <curtainUpFunction+0x18>
    26be:	22 e0       	ldi	r18, 0x02	; 2
    26c0:	30 e0       	ldi	r19, 0x00	; 0
    26c2:	6f c0       	rjmp	.+222    	; 0x27a2 <curtainUpFunction+0xf6>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	be 01       	movw	r22, r28
    26c8:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    26cc:	f6 2e       	mov	r15, r22
    26ce:	2f e3       	ldi	r18, 0x3F	; 63
    26d0:	f2 22       	and	r15, r18
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
    26d2:	82 e0       	ldi	r24, 0x02	; 2
    26d4:	be 01       	movw	r22, r28
    26d6:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    26da:	06 2f       	mov	r16, r22
    26dc:	01 70       	andi	r16, 0x01	; 1
  uint8_t wartosc = 255;
  if (state->argc > 2)
    26de:	89 8d       	ldd	r24, Y+25	; 0x19
    26e0:	83 30       	cpi	r24, 0x03	; 3
    26e2:	10 f4       	brcc	.+4      	; 0x26e8 <curtainUpFunction+0x3c>
    26e4:	1f ef       	ldi	r17, 0xFF	; 255
    26e6:	05 c0       	rjmp	.+10     	; 0x26f2 <curtainUpFunction+0x46>
    wartosc = cmdlineGetArgInt(3, state);
    26e8:	83 e0       	ldi	r24, 0x03	; 3
    26ea:	be 01       	movw	r22, r28
    26ec:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    26f0:	16 2f       	mov	r17, r22

  fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
    26f2:	8d b7       	in	r24, 0x3d	; 61
    26f4:	9e b7       	in	r25, 0x3e	; 62
    26f6:	08 97       	sbiw	r24, 0x08	; 8
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	9e bf       	out	0x3e, r25	; 62
    26fe:	0f be       	out	0x3f, r0	; 63
    2700:	8d bf       	out	0x3d, r24	; 61
    2702:	ed b7       	in	r30, 0x3d	; 61
    2704:	fe b7       	in	r31, 0x3e	; 62
    2706:	31 96       	adiw	r30, 0x01	; 1
    2708:	8a 8d       	ldd	r24, Y+26	; 0x1a
    270a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    270c:	ad b7       	in	r26, 0x3d	; 61
    270e:	be b7       	in	r27, 0x3e	; 62
    2710:	12 96       	adiw	r26, 0x02	; 2
    2712:	9c 93       	st	X, r25
    2714:	8e 93       	st	-X, r24
    2716:	11 97       	sbiw	r26, 0x01	; 1
    2718:	8f e9       	ldi	r24, 0x9F	; 159
    271a:	93 e0       	ldi	r25, 0x03	; 3
    271c:	93 83       	std	Z+3, r25	; 0x03
    271e:	82 83       	std	Z+2, r24	; 0x02
    2720:	f4 82       	std	Z+4, r15	; 0x04
    2722:	15 82       	std	Z+5, r1	; 0x05
    2724:	80 2f       	mov	r24, r16
    2726:	90 e0       	ldi	r25, 0x00	; 0
    2728:	01 96       	adiw	r24, 0x01	; 1
    272a:	97 83       	std	Z+7, r25	; 0x07
    272c:	86 83       	std	Z+6, r24	; 0x06
    272e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  if ((wartosc > 0) && (wartosc <=100))
    2732:	81 2f       	mov	r24, r17
    2734:	81 50       	subi	r24, 0x01	; 1
    2736:	2d b7       	in	r18, 0x3d	; 61
    2738:	3e b7       	in	r19, 0x3e	; 62
    273a:	28 5f       	subi	r18, 0xF8	; 248
    273c:	3f 4f       	sbci	r19, 0xFF	; 255
    273e:	0f b6       	in	r0, 0x3f	; 63
    2740:	f8 94       	cli
    2742:	3e bf       	out	0x3e, r19	; 62
    2744:	0f be       	out	0x3f, r0	; 63
    2746:	2d bf       	out	0x3d, r18	; 61
    2748:	84 36       	cpi	r24, 0x64	; 100
    274a:	f8 f4       	brcc	.+62     	; 0x278a <curtainUpFunction+0xde>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    274c:	00 d0       	rcall	.+0      	; 0x274e <curtainUpFunction+0xa2>
    274e:	00 d0       	rcall	.+0      	; 0x2750 <curtainUpFunction+0xa4>
    2750:	00 d0       	rcall	.+0      	; 0x2752 <curtainUpFunction+0xa6>
    2752:	ed b7       	in	r30, 0x3d	; 61
    2754:	fe b7       	in	r31, 0x3e	; 62
    2756:	31 96       	adiw	r30, 0x01	; 1
    2758:	8a 8d       	ldd	r24, Y+26	; 0x1a
    275a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    275c:	ad b7       	in	r26, 0x3d	; 61
    275e:	be b7       	in	r27, 0x3e	; 62
    2760:	12 96       	adiw	r26, 0x02	; 2
    2762:	9c 93       	st	X, r25
    2764:	8e 93       	st	-X, r24
    2766:	11 97       	sbiw	r26, 0x01	; 1
    2768:	85 e0       	ldi	r24, 0x05	; 5
    276a:	94 e0       	ldi	r25, 0x04	; 4
    276c:	93 83       	std	Z+3, r25	; 0x03
    276e:	82 83       	std	Z+2, r24	; 0x02
    2770:	14 83       	std	Z+4, r17	; 0x04
    2772:	15 82       	std	Z+5, r1	; 0x05
    2774:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    2778:	2d b7       	in	r18, 0x3d	; 61
    277a:	3e b7       	in	r19, 0x3e	; 62
    277c:	2a 5f       	subi	r18, 0xFA	; 250
    277e:	3f 4f       	sbci	r19, 0xFF	; 255
    2780:	0f b6       	in	r0, 0x3f	; 63
    2782:	f8 94       	cli
    2784:	3e bf       	out	0x3e, r19	; 62
    2786:	0f be       	out	0x3f, r0	; 63
    2788:	2d bf       	out	0x3d, r18	; 61

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
    278a:	8f 2d       	mov	r24, r15
    278c:	60 2f       	mov	r22, r16
    278e:	41 2f       	mov	r20, r17
    2790:	0e 94 db 42 	call	0x85b6	; 0x85b6 <rs485curtainUp>
  
  if (result == 0)
    2794:	88 23       	and	r24, r24
    2796:	19 f0       	breq	.+6      	; 0x279e <curtainUpFunction+0xf2>
    2798:	23 e0       	ldi	r18, 0x03	; 3
    279a:	30 e0       	ldi	r19, 0x00	; 0
    279c:	02 c0       	rjmp	.+4      	; 0x27a2 <curtainUpFunction+0xf6>
    279e:	21 e0       	ldi	r18, 0x01	; 1
    27a0:	30 e0       	ldi	r19, 0x00	; 0
    return OK_INFORM;
  
  return ERROR_SILENT;
}
    27a2:	c9 01       	movw	r24, r18
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	1f 91       	pop	r17
    27aa:	0f 91       	pop	r16
    27ac:	ff 90       	pop	r15
    27ae:	08 95       	ret

000027b0 <goXmodemWyslijFunction>:

  return OK_SILENT;
}

static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
{
    27b0:	0f 93       	push	r16
    27b2:	1f 93       	push	r17
    27b4:	cf 93       	push	r28
    27b6:	df 93       	push	r29
    27b8:	ec 01       	movw	r28, r24
  fprintf_P(state->myStdInOut, xwyslijStartStr);
    27ba:	00 d0       	rcall	.+0      	; 0x27bc <goXmodemWyslijFunction+0xc>
    27bc:	00 d0       	rcall	.+0      	; 0x27be <goXmodemWyslijFunction+0xe>
    27be:	8a 8d       	ldd	r24, Y+26	; 0x1a
    27c0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    27c2:	ad b7       	in	r26, 0x3d	; 61
    27c4:	be b7       	in	r27, 0x3e	; 62
    27c6:	12 96       	adiw	r26, 0x02	; 2
    27c8:	9c 93       	st	X, r25
    27ca:	8e 93       	st	-X, r24
    27cc:	11 97       	sbiw	r26, 0x01	; 1
    27ce:	82 e8       	ldi	r24, 0x82	; 130
    27d0:	93 e0       	ldi	r25, 0x03	; 3
    27d2:	14 96       	adiw	r26, 0x04	; 4
    27d4:	9c 93       	st	X, r25
    27d6:	8e 93       	st	-X, r24
    27d8:	13 97       	sbiw	r26, 0x03	; 3
    27da:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    27de:	0f 90       	pop	r0
    27e0:	0f 90       	pop	r0
    27e2:	0f 90       	pop	r0
    27e4:	0f 90       	pop	r0
    27e6:	81 e0       	ldi	r24, 0x01	; 1
    27e8:	be 01       	movw	r22, r28
    27ea:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    27ee:	69 e6       	ldi	r22, 0x69	; 105
    27f0:	7f e0       	ldi	r23, 0x0F	; 15
    27f2:	0e 94 a0 21 	call	0x4340	; 0x4340 <ramDyskOtworzPlik>
    27f6:	88 23       	and	r24, r24
    27f8:	19 f4       	brne	.+6      	; 0x2800 <goXmodemWyslijFunction+0x50>
    27fa:	20 e0       	ldi	r18, 0x00	; 0
    27fc:	30 e0       	ldi	r19, 0x00	; 0
    27fe:	24 c0       	rjmp	.+72     	; 0x2848 <goXmodemWyslijFunction+0x98>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2800:	0a 8d       	ldd	r16, Y+26	; 0x1a
    2802:	1b 8d       	ldd	r17, Y+27	; 0x1b
    2804:	81 e0       	ldi	r24, 0x01	; 1
    2806:	be 01       	movw	r22, r28
    2808:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    280c:	00 d0       	rcall	.+0      	; 0x280e <goXmodemWyslijFunction+0x5e>
    280e:	00 d0       	rcall	.+0      	; 0x2810 <goXmodemWyslijFunction+0x60>
    2810:	00 d0       	rcall	.+0      	; 0x2812 <goXmodemWyslijFunction+0x62>
    2812:	ed b7       	in	r30, 0x3d	; 61
    2814:	fe b7       	in	r31, 0x3e	; 62
    2816:	31 96       	adiw	r30, 0x01	; 1
    2818:	ad b7       	in	r26, 0x3d	; 61
    281a:	be b7       	in	r27, 0x3e	; 62
    281c:	12 96       	adiw	r26, 0x02	; 2
    281e:	1c 93       	st	X, r17
    2820:	0e 93       	st	-X, r16
    2822:	11 97       	sbiw	r26, 0x01	; 1
    2824:	22 e8       	ldi	r18, 0x82	; 130
    2826:	31 e0       	ldi	r19, 0x01	; 1
    2828:	33 83       	std	Z+3, r19	; 0x03
    282a:	22 83       	std	Z+2, r18	; 0x02
    282c:	95 83       	std	Z+5, r25	; 0x05
    282e:	84 83       	std	Z+4, r24	; 0x04
    2830:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    2834:	24 e0       	ldi	r18, 0x04	; 4
    2836:	30 e0       	ldi	r19, 0x00	; 0
    2838:	ed b7       	in	r30, 0x3d	; 61
    283a:	fe b7       	in	r31, 0x3e	; 62
    283c:	36 96       	adiw	r30, 0x06	; 6
    283e:	0f b6       	in	r0, 0x3f	; 63
    2840:	f8 94       	cli
    2842:	fe bf       	out	0x3e, r31	; 62
    2844:	0f be       	out	0x3f, r0	; 63
    2846:	ed bf       	out	0x3d, r30	; 61
    return ERROR_INFORM;
  }
  return OK_SILENT;
}
    2848:	c9 01       	movw	r24, r18
    284a:	df 91       	pop	r29
    284c:	cf 91       	pop	r28
    284e:	1f 91       	pop	r17
    2850:	0f 91       	pop	r16
    2852:	08 95       	ret

00002854 <editRamFileFunction>:
  ramDyskDir(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t editRamFileFunction(cmdState_t *state)
{
    2854:	ef 92       	push	r14
    2856:	ff 92       	push	r15
    2858:	0f 93       	push	r16
    285a:	1f 93       	push	r17
    285c:	df 93       	push	r29
    285e:	cf 93       	push	r28
    2860:	0f 92       	push	r0
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
    2866:	7c 01       	movw	r14, r24
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    2868:	81 e0       	ldi	r24, 0x01	; 1
    286a:	b7 01       	movw	r22, r14
    286c:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    2870:	69 e6       	ldi	r22, 0x69	; 105
    2872:	7f e0       	ldi	r23, 0x0F	; 15
    2874:	0e 94 a0 21 	call	0x4340	; 0x4340 <ramDyskOtworzPlik>
    2878:	88 23       	and	r24, r24
    287a:	41 f1       	breq	.+80     	; 0x28cc <editRamFileFunction+0x78>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    287c:	d7 01       	movw	r26, r14
    287e:	5a 96       	adiw	r26, 0x1a	; 26
    2880:	0d 91       	ld	r16, X+
    2882:	1c 91       	ld	r17, X
    2884:	5b 97       	sbiw	r26, 0x1b	; 27
    2886:	81 e0       	ldi	r24, 0x01	; 1
    2888:	b7 01       	movw	r22, r14
    288a:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    288e:	00 d0       	rcall	.+0      	; 0x2890 <editRamFileFunction+0x3c>
    2890:	00 d0       	rcall	.+0      	; 0x2892 <editRamFileFunction+0x3e>
    2892:	00 d0       	rcall	.+0      	; 0x2894 <editRamFileFunction+0x40>
    2894:	ed b7       	in	r30, 0x3d	; 61
    2896:	fe b7       	in	r31, 0x3e	; 62
    2898:	31 96       	adiw	r30, 0x01	; 1
    289a:	ad b7       	in	r26, 0x3d	; 61
    289c:	be b7       	in	r27, 0x3e	; 62
    289e:	12 96       	adiw	r26, 0x02	; 2
    28a0:	1c 93       	st	X, r17
    28a2:	0e 93       	st	-X, r16
    28a4:	11 97       	sbiw	r26, 0x01	; 1
    28a6:	22 e8       	ldi	r18, 0x82	; 130
    28a8:	31 e0       	ldi	r19, 0x01	; 1
    28aa:	33 83       	std	Z+3, r19	; 0x03
    28ac:	22 83       	std	Z+2, r18	; 0x02
    28ae:	95 83       	std	Z+5, r25	; 0x05
    28b0:	84 83       	std	Z+4, r24	; 0x04
    28b2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    28b6:	24 e0       	ldi	r18, 0x04	; 4
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	ed b7       	in	r30, 0x3d	; 61
    28bc:	fe b7       	in	r31, 0x3e	; 62
    28be:	36 96       	adiw	r30, 0x06	; 6
    28c0:	0f b6       	in	r0, 0x3f	; 63
    28c2:	f8 94       	cli
    28c4:	fe bf       	out	0x3e, r31	; 62
    28c6:	0f be       	out	0x3f, r0	; 63
    28c8:	ed bf       	out	0x3d, r30	; 61
    28ca:	3b c0       	rjmp	.+118    	; 0x2942 <editRamFileFunction+0xee>
    return ERROR_INFORM;
  }
  ramDyskUstawWskaznikNaKoniec(&fdVty);
    28cc:	89 e6       	ldi	r24, 0x69	; 105
    28ce:	9f e0       	ldi	r25, 0x0F	; 15
    28d0:	0e 94 4a 1e 	call	0x3c94	; 0x3c94 <ramDyskUstawWskaznikNaKoniec>
  uint8_t znak = 0;
    28d4:	19 82       	std	Y+1, r1	; 0x01
  fprintf_P(state->myStdInOut, editRamFileIntroStr);
    28d6:	00 d0       	rcall	.+0      	; 0x28d8 <editRamFileFunction+0x84>
    28d8:	00 d0       	rcall	.+0      	; 0x28da <editRamFileFunction+0x86>
    28da:	d7 01       	movw	r26, r14
    28dc:	5a 96       	adiw	r26, 0x1a	; 26
    28de:	8d 91       	ld	r24, X+
    28e0:	9c 91       	ld	r25, X
    28e2:	5b 97       	sbiw	r26, 0x1b	; 27
    28e4:	ed b7       	in	r30, 0x3d	; 61
    28e6:	fe b7       	in	r31, 0x3e	; 62
    28e8:	92 83       	std	Z+2, r25	; 0x02
    28ea:	81 83       	std	Z+1, r24	; 0x01
    28ec:	88 e4       	ldi	r24, 0x48	; 72
    28ee:	93 e0       	ldi	r25, 0x03	; 3
    28f0:	94 83       	std	Z+4, r25	; 0x04
    28f2:	83 83       	std	Z+3, r24	; 0x03
    28f4:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    28f8:	0f 90       	pop	r0
    28fa:	0f 90       	pop	r0
    28fc:	0f 90       	pop	r0
    28fe:	0f 90       	pop	r0
  while(1)
  {
    if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
    2900:	7e 01       	movw	r14, r28
    2902:	08 94       	sec
    2904:	e1 1c       	adc	r14, r1
    2906:	f1 1c       	adc	r15, r1
    2908:	80 91 ad 0e 	lds	r24, 0x0EAD
    290c:	90 91 ae 0e 	lds	r25, 0x0EAE
    2910:	b7 01       	movw	r22, r14
    2912:	4f ef       	ldi	r20, 0xFF	; 255
    2914:	5f ef       	ldi	r21, 0xFF	; 255
    2916:	20 e0       	ldi	r18, 0x00	; 0
    2918:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    291c:	88 23       	and	r24, r24
    291e:	a1 f3       	breq	.-24     	; 0x2908 <editRamFileFunction+0xb4>
      continue;

    if (znak == 0x03)                                       // ^C
    2920:	89 81       	ldd	r24, Y+1	; 0x01
    2922:	83 30       	cpi	r24, 0x03	; 3
    2924:	41 f0       	breq	.+16     	; 0x2936 <editRamFileFunction+0xe2>
      break;

    uartVtySendByte(znak);                                  //Echo
    2926:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
    ramDyskZapiszBajtDoPliku(&fdVty, znak);
    292a:	89 e6       	ldi	r24, 0x69	; 105
    292c:	9f e0       	ldi	r25, 0x0F	; 15
    292e:	69 81       	ldd	r22, Y+1	; 0x01
    2930:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <ramDyskZapiszBajtDoPliku>
    2934:	e9 cf       	rjmp	.-46     	; 0x2908 <editRamFileFunction+0xb4>
  }
  ramDyskZamknijPlik(&fdVty);
    2936:	89 e6       	ldi	r24, 0x69	; 105
    2938:	9f e0       	ldi	r25, 0x0F	; 15
    293a:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <ramDyskZamknijPlik>
    293e:	20 e0       	ldi	r18, 0x00	; 0
    2940:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2942:	c9 01       	movw	r24, r18
    2944:	0f 90       	pop	r0
    2946:	cf 91       	pop	r28
    2948:	df 91       	pop	r29
    294a:	1f 91       	pop	r17
    294c:	0f 91       	pop	r16
    294e:	ff 90       	pop	r15
    2950:	ef 90       	pop	r14
    2952:	08 95       	ret

00002954 <eraseRamFileFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
    2954:	cf 93       	push	r28
    2956:	df 93       	push	r29
    2958:	ec 01       	movw	r28, r24
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    295a:	81 e0       	ldi	r24, 0x01	; 1
    295c:	be 01       	movw	r22, r28
    295e:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    2962:	0e 94 78 21 	call	0x42f0	; 0x42f0 <ramDyskUsunPlik>
    2966:	88 23       	and	r24, r24
    2968:	19 f4       	brne	.+6      	; 0x2970 <eraseRamFileFunction+0x1c>
    296a:	21 e0       	ldi	r18, 0x01	; 1
    296c:	30 e0       	ldi	r19, 0x00	; 0
    296e:	05 c0       	rjmp	.+10     	; 0x297a <eraseRamFileFunction+0x26>
    return OK_INFORM;

  printErrorInfo(state);
    2970:	ce 01       	movw	r24, r28
    2972:	0e 94 08 12 	call	0x2410	; 0x2410 <printErrorInfo>
    2976:	24 e0       	ldi	r18, 0x04	; 4
    2978:	30 e0       	ldi	r19, 0x00	; 0
  return ERROR_INFORM;
}
    297a:	c9 01       	movw	r24, r18
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	08 95       	ret

00002982 <dodajRamPlikFunction>:

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
    2982:	cf 93       	push	r28
    2984:	df 93       	push	r29
    2986:	ec 01       	movw	r28, r24
  if (state->argc != 1)
    2988:	89 8d       	ldd	r24, Y+25	; 0x19
    298a:	81 30       	cpi	r24, 0x01	; 1
    298c:	19 f0       	breq	.+6      	; 0x2994 <dodajRamPlikFunction+0x12>
    298e:	22 e0       	ldi	r18, 0x02	; 2
    2990:	30 e0       	ldi	r19, 0x00	; 0
    2992:	10 c0       	rjmp	.+32     	; 0x29b4 <dodajRamPlikFunction+0x32>
    return SYNTAX_ERROR;

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
    2994:	81 e0       	ldi	r24, 0x01	; 1
    2996:	be 01       	movw	r22, r28
    2998:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    299c:	0e 94 d7 21 	call	0x43ae	; 0x43ae <ramDyskUtworzPlik>
    29a0:	88 23       	and	r24, r24
    29a2:	19 f4       	brne	.+6      	; 0x29aa <dodajRamPlikFunction+0x28>
    29a4:	21 e0       	ldi	r18, 0x01	; 1
    29a6:	30 e0       	ldi	r19, 0x00	; 0
    29a8:	05 c0       	rjmp	.+10     	; 0x29b4 <dodajRamPlikFunction+0x32>
  {
    return OK_INFORM;
  }
  printErrorInfo(state);
    29aa:	ce 01       	movw	r24, r28
    29ac:	0e 94 08 12 	call	0x2410	; 0x2410 <printErrorInfo>
    29b0:	24 e0       	ldi	r18, 0x04	; 4
    29b2:	30 e0       	ldi	r19, 0x00	; 0
  return ERROR_INFORM;
}
    29b4:	c9 01       	movw	r24, r18
    29b6:	df 91       	pop	r29
    29b8:	cf 91       	pop	r28
    29ba:	08 95       	ret

000029bc <rpingFunction>:
  
  return OK_SILENT;
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
    29bc:	1f 93       	push	r17
    29be:	cf 93       	push	r28
    29c0:	df 93       	push	r29
    29c2:	ec 01       	movw	r28, r24
  if (state->argc < 1)
    29c4:	89 8d       	ldd	r24, Y+25	; 0x19
    29c6:	88 23       	and	r24, r24
    29c8:	19 f4       	brne	.+6      	; 0x29d0 <rpingFunction+0x14>
    29ca:	22 e0       	ldi	r18, 0x02	; 2
    29cc:	30 e0       	ldi	r19, 0x00	; 0
    29ce:	17 c0       	rjmp	.+46     	; 0x29fe <rpingFunction+0x42>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
    29d0:	81 e0       	ldi	r24, 0x01	; 1
    29d2:	be 01       	movw	r22, r28
    29d4:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    29d8:	16 2f       	mov	r17, r22
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    29da:	86 2f       	mov	r24, r22
    29dc:	0e 94 28 48 	call	0x9050	; 0x9050 <rs485ping>
    29e0:	8f 8f       	std	Y+31, r24	; 0x1f
    29e2:	88 23       	and	r24, r24
    29e4:	19 f4       	brne	.+6      	; 0x29ec <rpingFunction+0x30>
    29e6:	21 e0       	ldi	r18, 0x01	; 1
    29e8:	30 e0       	ldi	r19, 0x00	; 0
    29ea:	09 c0       	rjmp	.+18     	; 0x29fe <rpingFunction+0x42>
    return OK_INFORM;

  state->errno = noRemoteDevice;
    29ec:	89 e0       	ldi	r24, 0x09	; 9
    29ee:	8c 8f       	std	Y+28, r24	; 0x1c
  state->err1 = nrSterownika;
    29f0:	1d 8f       	std	Y+29, r17	; 0x1d
    29f2:	1e 8e       	std	Y+30, r1	; 0x1e
  printErrorInfo(state);
    29f4:	ce 01       	movw	r24, r28
    29f6:	0e 94 08 12 	call	0x2410	; 0x2410 <printErrorInfo>
    29fa:	20 e0       	ldi	r18, 0x00	; 0
    29fc:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    29fe:	c9 01       	movw	r24, r18
    2a00:	df 91       	pop	r29
    2a02:	cf 91       	pop	r28
    2a04:	1f 91       	pop	r17
    2a06:	08 95       	ret

00002a08 <flashExModuleFunction>:
  return OK_SILENT;
}


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
    2a08:	ff 92       	push	r15
    2a0a:	0f 93       	push	r16
    2a0c:	1f 93       	push	r17
    2a0e:	cf 93       	push	r28
    2a10:	df 93       	push	r29
    2a12:	ec 01       	movw	r28, r24
  if (state->argc != 2)
    2a14:	89 8d       	ldd	r24, Y+25	; 0x19
    2a16:	82 30       	cpi	r24, 0x02	; 2
    2a18:	19 f0       	breq	.+6      	; 0x2a20 <flashExModuleFunction+0x18>
    2a1a:	22 e0       	ldi	r18, 0x02	; 2
    2a1c:	30 e0       	ldi	r19, 0x00	; 0
    2a1e:	4e c0       	rjmp	.+156    	; 0x2abc <flashExModuleFunction+0xb4>
    return SYNTAX_ERROR;
  
  uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
    2a20:	81 e0       	ldi	r24, 0x01	; 1
    2a22:	be 01       	movw	r22, r28
    2a24:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2a28:	f6 2e       	mov	r15, r22
  char *nazwaPliku      = cmdlineGetArgStr(2, state);
    2a2a:	82 e0       	ldi	r24, 0x02	; 2
    2a2c:	be 01       	movw	r22, r28
    2a2e:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    2a32:	8c 01       	movw	r16, r24
  uint8_t  blad;
  
  // Sprawdzanie, czy moduł wykonawczy odpowiada
  if (rs485ping(nrUrzadzenia) != 0)
    2a34:	8f 2d       	mov	r24, r15
    2a36:	0e 94 28 48 	call	0x9050	; 0x9050 <rs485ping>
    2a3a:	88 23       	and	r24, r24
    2a3c:	31 f0       	breq	.+12     	; 0x2a4a <flashExModuleFunction+0x42>
  {
    state->errno = noRemoteDevice;
    2a3e:	89 e0       	ldi	r24, 0x09	; 9
    2a40:	8c 8f       	std	Y+28, r24	; 0x1c
    printErrorInfo(state);
    2a42:	ce 01       	movw	r24, r28
    2a44:	0e 94 08 12 	call	0x2410	; 0x2410 <printErrorInfo>
    2a48:	37 c0       	rjmp	.+110    	; 0x2ab8 <flashExModuleFunction+0xb0>
    return ERROR_INFORM;
  }
  
  //Sprawdzanie, czy istnieje odpowiedni plik z firmware
  if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
    2a4a:	c8 01       	movw	r24, r16
    2a4c:	69 e6       	ldi	r22, 0x69	; 105
    2a4e:	7f e0       	ldi	r23, 0x0F	; 15
    2a50:	0e 94 a0 21 	call	0x4340	; 0x4340 <ramDyskOtworzPlik>
    2a54:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2a56:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2a58:	88 23       	and	r24, r24
    2a5a:	f9 f0       	breq	.+62     	; 0x2a9a <flashExModuleFunction+0x92>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
    2a5c:	00 d0       	rcall	.+0      	; 0x2a5e <flashExModuleFunction+0x56>
    2a5e:	00 d0       	rcall	.+0      	; 0x2a60 <flashExModuleFunction+0x58>
    2a60:	00 d0       	rcall	.+0      	; 0x2a62 <flashExModuleFunction+0x5a>
    2a62:	ed b7       	in	r30, 0x3d	; 61
    2a64:	fe b7       	in	r31, 0x3e	; 62
    2a66:	31 96       	adiw	r30, 0x01	; 1
    2a68:	ad b7       	in	r26, 0x3d	; 61
    2a6a:	be b7       	in	r27, 0x3e	; 62
    2a6c:	12 96       	adiw	r26, 0x02	; 2
    2a6e:	5c 93       	st	X, r21
    2a70:	4e 93       	st	-X, r20
    2a72:	11 97       	sbiw	r26, 0x01	; 1
    2a74:	82 e8       	ldi	r24, 0x82	; 130
    2a76:	91 e0       	ldi	r25, 0x01	; 1
    2a78:	93 83       	std	Z+3, r25	; 0x03
    2a7a:	82 83       	std	Z+2, r24	; 0x02
    2a7c:	15 83       	std	Z+5, r17	; 0x05
    2a7e:	04 83       	std	Z+4, r16	; 0x04
    2a80:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    2a84:	24 e0       	ldi	r18, 0x04	; 4
    2a86:	30 e0       	ldi	r19, 0x00	; 0
    2a88:	8d b7       	in	r24, 0x3d	; 61
    2a8a:	9e b7       	in	r25, 0x3e	; 62
    2a8c:	06 96       	adiw	r24, 0x06	; 6
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	9e bf       	out	0x3e, r25	; 62
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	8d bf       	out	0x3d, r24	; 61
    2a98:	11 c0       	rjmp	.+34     	; 0x2abc <flashExModuleFunction+0xb4>
    return ERROR_INFORM;
  }
  
  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
    2a9a:	89 e6       	ldi	r24, 0x69	; 105
    2a9c:	9f e0       	ldi	r25, 0x0F	; 15
    2a9e:	6f 2d       	mov	r22, r15
    2aa0:	0e 94 d4 44 	call	0x89a8	; 0x89a8 <rs485xModemFlash>
    2aa4:	18 2f       	mov	r17, r24

  ramDyskZamknijPlik(&fdVty);
    2aa6:	89 e6       	ldi	r24, 0x69	; 105
    2aa8:	9f e0       	ldi	r25, 0x0F	; 15
    2aaa:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <ramDyskZamknijPlik>
  
  if (blad != 0)
    2aae:	11 23       	and	r17, r17
    2ab0:	19 f4       	brne	.+6      	; 0x2ab8 <flashExModuleFunction+0xb0>
    2ab2:	20 e0       	ldi	r18, 0x00	; 0
    2ab4:	30 e0       	ldi	r19, 0x00	; 0
    2ab6:	02 c0       	rjmp	.+4      	; 0x2abc <flashExModuleFunction+0xb4>
    2ab8:	24 e0       	ldi	r18, 0x04	; 4
    2aba:	30 e0       	ldi	r19, 0x00	; 0
    return ERROR_INFORM;

  return OK_SILENT;
}
    2abc:	c9 01       	movw	r24, r18
    2abe:	df 91       	pop	r29
    2ac0:	cf 91       	pop	r28
    2ac2:	1f 91       	pop	r17
    2ac4:	0f 91       	pop	r16
    2ac6:	ff 90       	pop	r15
    2ac8:	08 95       	ret

00002aca <goXmodemOdbierzFunction>:
  }
  return OK_SILENT;
}

static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
{
    2aca:	2f 92       	push	r2
    2acc:	3f 92       	push	r3
    2ace:	4f 92       	push	r4
    2ad0:	5f 92       	push	r5
    2ad2:	6f 92       	push	r6
    2ad4:	7f 92       	push	r7
    2ad6:	8f 92       	push	r8
    2ad8:	9f 92       	push	r9
    2ada:	af 92       	push	r10
    2adc:	bf 92       	push	r11
    2ade:	cf 92       	push	r12
    2ae0:	df 92       	push	r13
    2ae2:	ef 92       	push	r14
    2ae4:	ff 92       	push	r15
    2ae6:	0f 93       	push	r16
    2ae8:	1f 93       	push	r17
    2aea:	df 93       	push	r29
    2aec:	cf 93       	push	r28
    2aee:	00 d0       	rcall	.+0      	; 0x2af0 <goXmodemOdbierzFunction+0x26>
    2af0:	00 d0       	rcall	.+0      	; 0x2af2 <goXmodemOdbierzFunction+0x28>
    2af2:	00 d0       	rcall	.+0      	; 0x2af4 <goXmodemOdbierzFunction+0x2a>
    2af4:	cd b7       	in	r28, 0x3d	; 61
    2af6:	de b7       	in	r29, 0x3e	; 62
    2af8:	7c 01       	movw	r14, r24
  fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
    2afa:	00 d0       	rcall	.+0      	; 0x2afc <goXmodemOdbierzFunction+0x32>
    2afc:	00 d0       	rcall	.+0      	; 0x2afe <goXmodemOdbierzFunction+0x34>
    2afe:	dc 01       	movw	r26, r24
    2b00:	5a 96       	adiw	r26, 0x1a	; 26
    2b02:	8d 91       	ld	r24, X+
    2b04:	9c 91       	ld	r25, X
    2b06:	5b 97       	sbiw	r26, 0x1b	; 27
    2b08:	ed b7       	in	r30, 0x3d	; 61
    2b0a:	fe b7       	in	r31, 0x3e	; 62
    2b0c:	92 83       	std	Z+2, r25	; 0x02
    2b0e:	81 83       	std	Z+1, r24	; 0x01
    2b10:	87 e8       	ldi	r24, 0x87	; 135
    2b12:	9a e0       	ldi	r25, 0x0A	; 10
    2b14:	94 83       	std	Z+4, r25	; 0x04
    2b16:	83 83       	std	Z+3, r24	; 0x03
    2b18:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    2b1c:	0f 90       	pop	r0
    2b1e:	0f 90       	pop	r0
    2b20:	0f 90       	pop	r0
    2b22:	0f 90       	pop	r0
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	b7 01       	movw	r22, r14
    2b28:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    2b2c:	69 e6       	ldi	r22, 0x69	; 105
    2b2e:	7f e0       	ldi	r23, 0x0F	; 15
    2b30:	0e 94 a0 21 	call	0x4340	; 0x4340 <ramDyskOtworzPlik>
    2b34:	88 23       	and	r24, r24
    2b36:	41 f1       	breq	.+80     	; 0x2b88 <goXmodemOdbierzFunction+0xbe>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2b38:	d7 01       	movw	r26, r14
    2b3a:	5a 96       	adiw	r26, 0x1a	; 26
    2b3c:	0d 91       	ld	r16, X+
    2b3e:	1c 91       	ld	r17, X
    2b40:	5b 97       	sbiw	r26, 0x1b	; 27
    2b42:	81 e0       	ldi	r24, 0x01	; 1
    2b44:	b7 01       	movw	r22, r14
    2b46:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    2b4a:	00 d0       	rcall	.+0      	; 0x2b4c <goXmodemOdbierzFunction+0x82>
    2b4c:	00 d0       	rcall	.+0      	; 0x2b4e <goXmodemOdbierzFunction+0x84>
    2b4e:	00 d0       	rcall	.+0      	; 0x2b50 <goXmodemOdbierzFunction+0x86>
    2b50:	ed b7       	in	r30, 0x3d	; 61
    2b52:	fe b7       	in	r31, 0x3e	; 62
    2b54:	31 96       	adiw	r30, 0x01	; 1
    2b56:	ad b7       	in	r26, 0x3d	; 61
    2b58:	be b7       	in	r27, 0x3e	; 62
    2b5a:	12 96       	adiw	r26, 0x02	; 2
    2b5c:	1c 93       	st	X, r17
    2b5e:	0e 93       	st	-X, r16
    2b60:	11 97       	sbiw	r26, 0x01	; 1
    2b62:	22 e8       	ldi	r18, 0x82	; 130
    2b64:	31 e0       	ldi	r19, 0x01	; 1
    2b66:	33 83       	std	Z+3, r19	; 0x03
    2b68:	22 83       	std	Z+2, r18	; 0x02
    2b6a:	95 83       	std	Z+5, r25	; 0x05
    2b6c:	84 83       	std	Z+4, r24	; 0x04
    2b6e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    2b72:	24 e0       	ldi	r18, 0x04	; 4
    2b74:	30 e0       	ldi	r19, 0x00	; 0
    2b76:	ed b7       	in	r30, 0x3d	; 61
    2b78:	fe b7       	in	r31, 0x3e	; 62
    2b7a:	36 96       	adiw	r30, 0x06	; 6
    2b7c:	0f b6       	in	r0, 0x3f	; 63
    2b7e:	f8 94       	cli
    2b80:	fe bf       	out	0x3e, r31	; 62
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	ed bf       	out	0x3d, r30	; 61
    2b86:	7b c1       	rjmp	.+758    	; 0x2e7e <goXmodemOdbierzFunction+0x3b4>
  uint8_t nrBlokuZdalnyNeg;

  uint8_t crcHi;
  uint8_t crcLo;

  state->err1=0;
    2b88:	d7 01       	movw	r26, r14
    2b8a:	5e 96       	adiw	r26, 0x1e	; 30
    2b8c:	1c 92       	st	X, r1
    2b8e:	1e 92       	st	-X, r1
    2b90:	5d 97       	sbiw	r26, 0x1d	; 29
  state->err2=0;
    2b92:	5f 96       	adiw	r26, 0x1f	; 31
    2b94:	1c 92       	st	X, r1
    2b96:	04 e1       	ldi	r16, 0x14	; 20
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora

    if(xQueueReceive(xVtyRec, &c, 100))
    2b98:	b2 e0       	ldi	r27, 0x02	; 2
    2b9a:	cb 2e       	mov	r12, r27
    2b9c:	d1 2c       	mov	r13, r1
    2b9e:	cc 0e       	add	r12, r28
    2ba0:	dd 1e       	adc	r13, r29
  state->err1=0;
  state->err2=0;
  liczbaProb = 20;
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    2ba2:	f7 01       	movw	r30, r14
    2ba4:	62 8d       	ldd	r22, Z+26	; 0x1a
    2ba6:	73 8d       	ldd	r23, Z+27	; 0x1b
    2ba8:	83 e4       	ldi	r24, 0x43	; 67
    2baa:	90 e0       	ldi	r25, 0x00	; 0
    2bac:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
    2bb0:	80 91 9b 00 	lds	r24, 0x009B
    2bb4:	86 ff       	sbrs	r24, 6
    2bb6:	fc cf       	rjmp	.-8      	; 0x2bb0 <goXmodemOdbierzFunction+0xe6>

    if(xQueueReceive(xVtyRec, &c, 100))
    2bb8:	80 91 ad 0e 	lds	r24, 0x0EAD
    2bbc:	90 91 ae 0e 	lds	r25, 0x0EAE
    2bc0:	b6 01       	movw	r22, r12
    2bc2:	44 e6       	ldi	r20, 0x64	; 100
    2bc4:	50 e0       	ldi	r21, 0x00	; 0
    2bc6:	20 e0       	ldi	r18, 0x00	; 0
    2bc8:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2bcc:	88 23       	and	r24, r24
    2bce:	19 f0       	breq	.+6      	; 0x2bd6 <goXmodemOdbierzFunction+0x10c>
      if (c == SOH)
    2bd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2bd2:	81 30       	cpi	r24, 0x01	; 1
    2bd4:	61 f0       	breq	.+24     	; 0x2bee <goXmodemOdbierzFunction+0x124>
        break;                                                   //Rozpoczynamy transmisje

    liczbaProb--;
    2bd6:	01 50       	subi	r16, 0x01	; 1
    if (liczbaProb == 0)
    2bd8:	21 f7       	brne	.-56     	; 0x2ba2 <goXmodemOdbierzFunction+0xd8>
    {
      ramDyskZamknijPlik(&fdVty);
    2bda:	89 e6       	ldi	r24, 0x69	; 105
    2bdc:	9f e0       	ldi	r25, 0x0F	; 15
    2bde:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <ramDyskZamknijPlik>
      state->errno = (uint8_t)(AllOK);
    2be2:	d7 01       	movw	r26, r14
    2be4:	5c 96       	adiw	r26, 0x1c	; 28
    2be6:	1c 92       	st	X, r1
    2be8:	24 e0       	ldi	r18, 0x04	; 4
    2bea:	30 e0       	ldi	r19, 0x00	; 0
    2bec:	48 c1       	rjmp	.+656    	; 0x2e7e <goXmodemOdbierzFunction+0x3b4>
  }
  
  nrBloku = 1;
  liczbaProb = 10;

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2bee:	89 e6       	ldi	r24, 0x69	; 105
    2bf0:	9f e0       	ldi	r25, 0x0F	; 15
    2bf2:	61 e0       	ldi	r22, 0x01	; 1
    2bf4:	70 e0       	ldi	r23, 0x00	; 0
    2bf6:	0e 94 e4 1d 	call	0x3bc8	; 0x3bc8 <ramDyskDodajBlokXmodem>
    2bfa:	6c 01       	movw	r12, r24
    2bfc:	5c 01       	movw	r10, r24
    2bfe:	aa e0       	ldi	r26, 0x0A	; 10
    2c00:	9a 2e       	mov	r9, r26
    2c02:	11 e0       	ldi	r17, 0x01	; 1
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2c04:	f3 e0       	ldi	r31, 0x03	; 3
    2c06:	8f 2e       	mov	r8, r31
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    2c08:	e5 e0       	ldi	r30, 0x05	; 5
    2c0a:	2e 2e       	mov	r2, r30
    2c0c:	31 2c       	mov	r3, r1
    2c0e:	2c 0e       	add	r2, r28
    2c10:	3d 1e       	adc	r3, r29
    {
        state->errno = (uint8_t)(xModemFrameCrc);
        state->err1 = 2;
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    2c12:	76 e0       	ldi	r23, 0x06	; 6
    2c14:	47 2e       	mov	r4, r23
    2c16:	51 2c       	mov	r5, r1
    2c18:	4c 0e       	add	r4, r28
    2c1a:	5d 1e       	adc	r5, r29
      state->err2 = nrBloku;
      state->errno = (uint8_t)(xModemWrongFrameNo);
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    2c1c:	3e 01       	movw	r6, r28
    2c1e:	08 94       	sec
    2c20:	61 1c       	adc	r6, r1
    2c22:	71 1c       	adc	r7, r1

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    2c24:	80 91 ad 0e 	lds	r24, 0x0EAD
    2c28:	90 91 ae 0e 	lds	r25, 0x0EAE
    2c2c:	be 01       	movw	r22, r28
    2c2e:	6d 5f       	subi	r22, 0xFD	; 253
    2c30:	7f 4f       	sbci	r23, 0xFF	; 255
    2c32:	44 e6       	ldi	r20, 0x64	; 100
    2c34:	50 e0       	ldi	r21, 0x00	; 0
    2c36:	20 e0       	ldi	r18, 0x00	; 0
    2c38:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2c3c:	88 23       	and	r24, r24
    2c3e:	09 f4       	brne	.+2      	; 0x2c42 <goXmodemOdbierzFunction+0x178>
    2c40:	dd c0       	rjmp	.+442    	; 0x2dfc <goXmodemOdbierzFunction+0x332>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    2c42:	80 91 ad 0e 	lds	r24, 0x0EAD
    2c46:	90 91 ae 0e 	lds	r25, 0x0EAE
    2c4a:	be 01       	movw	r22, r28
    2c4c:	6c 5f       	subi	r22, 0xFC	; 252
    2c4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2c50:	41 e0       	ldi	r20, 0x01	; 1
    2c52:	50 e0       	ldi	r21, 0x00	; 0
    2c54:	20 e0       	ldi	r18, 0x00	; 0
    2c56:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2c5a:	88 23       	and	r24, r24
    2c5c:	19 f4       	brne	.+6      	; 0x2c64 <goXmodemOdbierzFunction+0x19a>
    {
      state->errno = (uint8_t)(xModemByteSendTimeout);
    2c5e:	83 e0       	ldi	r24, 0x03	; 3
    2c60:	d7 01       	movw	r26, r14
    2c62:	bd c0       	rjmp	.+378    	; 0x2dde <goXmodemOdbierzFunction+0x314>
      break; 
    }
  
    //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
    c = 255-nrBlokuZdalnyNeg;
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	89 2f       	mov	r24, r25
    2c68:	80 95       	com	r24
    2c6a:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny != c)
    2c6c:	0b 81       	ldd	r16, Y+3	; 0x03
    2c6e:	08 17       	cp	r16, r24
    2c70:	39 f0       	breq	.+14     	; 0x2c80 <goXmodemOdbierzFunction+0x1b6>
    {
      state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
    2c72:	85 e0       	ldi	r24, 0x05	; 5
    2c74:	f7 01       	movw	r30, r14
    2c76:	84 8f       	std	Z+28, r24	; 0x1c
      state->err1 = nrBlokuZdalny;
    2c78:	05 8f       	std	Z+29, r16	; 0x1d
    2c7a:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBlokuZdalnyNeg;
    2c7c:	97 8f       	std	Z+31, r25	; 0x1f
    2c7e:	f9 c0       	rjmp	.+498    	; 0x2e72 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    
    //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od bloku 0
    c = nrBloku-1;
    2c80:	81 2f       	mov	r24, r17
    2c82:	81 50       	subi	r24, 0x01	; 1
    2c84:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny == c)
    2c86:	08 17       	cp	r16, r24
    2c88:	11 f0       	breq	.+4      	; 0x2c8e <goXmodemOdbierzFunction+0x1c4>
    2c8a:	01 2f       	mov	r16, r17
    2c8c:	08 c0       	rjmp	.+16     	; 0x2c9e <goXmodemOdbierzFunction+0x1d4>
    {
      nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2c8e:	89 e6       	ldi	r24, 0x69	; 105
    2c90:	9f e0       	ldi	r25, 0x0F	; 15
    2c92:	60 2f       	mov	r22, r16
    2c94:	70 e0       	ldi	r23, 0x00	; 0
    2c96:	0e 94 e4 1d 	call	0x3bc8	; 0x3bc8 <ramDyskDodajBlokXmodem>
    2c9a:	6c 01       	movw	r12, r24
    2c9c:	5c 01       	movw	r10, r24
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    2c9e:	1b 81       	ldd	r17, Y+3	; 0x03
    2ca0:	10 17       	cp	r17, r16
    2ca2:	79 f0       	breq	.+30     	; 0x2cc2 <goXmodemOdbierzFunction+0x1f8>
    {
      state->errno = (uint8_t)(xModemWrongFrameNo);
    2ca4:	84 e0       	ldi	r24, 0x04	; 4
    2ca6:	d7 01       	movw	r26, r14
    2ca8:	5c 96       	adiw	r26, 0x1c	; 28
    2caa:	8c 93       	st	X, r24
    2cac:	5c 97       	sbiw	r26, 0x1c	; 28
      state->err1 = nrBlokuZdalnyNeg;
    2cae:	8c 81       	ldd	r24, Y+4	; 0x04
    2cb0:	5d 96       	adiw	r26, 0x1d	; 29
    2cb2:	8c 93       	st	X, r24
    2cb4:	5d 97       	sbiw	r26, 0x1d	; 29
    2cb6:	5e 96       	adiw	r26, 0x1e	; 30
    2cb8:	1c 92       	st	X, r1
    2cba:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    2cbc:	5f 96       	adiw	r26, 0x1f	; 31
    2cbe:	0c 93       	st	X, r16
    2cc0:	d8 c0       	rjmp	.+432    	; 0x2e72 <goXmodemOdbierzFunction+0x3a8>
      break;
    2cc2:	00 e0       	ldi	r16, 0x00	; 0
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    {
      if(xQueueReceive(xVtyRec, &c, 10))
    2cc4:	80 91 ad 0e 	lds	r24, 0x0EAD
    2cc8:	90 91 ae 0e 	lds	r25, 0x0EAE
    2ccc:	be 01       	movw	r22, r28
    2cce:	6e 5f       	subi	r22, 0xFE	; 254
    2cd0:	7f 4f       	sbci	r23, 0xFF	; 255
    2cd2:	4a e0       	ldi	r20, 0x0A	; 10
    2cd4:	50 e0       	ldi	r21, 0x00	; 0
    2cd6:	20 e0       	ldi	r18, 0x00	; 0
    2cd8:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2cdc:	88 23       	and	r24, r24
    2cde:	41 f0       	breq	.+16     	; 0x2cf0 <goXmodemOdbierzFunction+0x226>
        *(zapPtr++) = c;
    2ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ce2:	f6 01       	movw	r30, r12
    2ce4:	81 93       	st	Z+, r24
    2ce6:	6f 01       	movw	r12, r30
      state->err1 = nrBlokuZdalnyNeg;
      state->err2 = nrBloku;
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    2ce8:	0f 5f       	subi	r16, 0xFF	; 255
    2cea:	00 38       	cpi	r16, 0x80	; 128
    2cec:	59 f7       	brne	.-42     	; 0x2cc4 <goXmodemOdbierzFunction+0x1fa>
    2cee:	03 c0       	rjmp	.+6      	; 0x2cf6 <goXmodemOdbierzFunction+0x22c>
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2cf0:	d7 01       	movw	r26, r14
    2cf2:	5c 96       	adiw	r26, 0x1c	; 28
    2cf4:	8c 92       	st	X, r8
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    2cf6:	80 91 ad 0e 	lds	r24, 0x0EAD
    2cfa:	90 91 ae 0e 	lds	r25, 0x0EAE
    2cfe:	b1 01       	movw	r22, r2
    2d00:	4a e0       	ldi	r20, 0x0A	; 10
    2d02:	50 e0       	ldi	r21, 0x00	; 0
    2d04:	20 e0       	ldi	r18, 0x00	; 0
    2d06:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2d0a:	88 23       	and	r24, r24
    2d0c:	41 f4       	brne	.+16     	; 0x2d1e <goXmodemOdbierzFunction+0x254>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2d0e:	86 e0       	ldi	r24, 0x06	; 6
    2d10:	f7 01       	movw	r30, r14
    2d12:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 2;
    2d14:	82 e0       	ldi	r24, 0x02	; 2
    2d16:	90 e0       	ldi	r25, 0x00	; 0
    2d18:	96 8f       	std	Z+30, r25	; 0x1e
    2d1a:	85 8f       	std	Z+29, r24	; 0x1d
    2d1c:	aa c0       	rjmp	.+340    	; 0x2e72 <goXmodemOdbierzFunction+0x3a8>
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    2d1e:	80 91 ad 0e 	lds	r24, 0x0EAD
    2d22:	90 91 ae 0e 	lds	r25, 0x0EAE
    2d26:	b2 01       	movw	r22, r4
    2d28:	4a e0       	ldi	r20, 0x0A	; 10
    2d2a:	50 e0       	ldi	r21, 0x00	; 0
    2d2c:	20 e0       	ldi	r18, 0x00	; 0
    2d2e:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2d32:	88 23       	and	r24, r24
    2d34:	61 f4       	brne	.+24     	; 0x2d4e <goXmodemOdbierzFunction+0x284>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2d36:	86 e0       	ldi	r24, 0x06	; 6
    2d38:	d7 01       	movw	r26, r14
    2d3a:	5c 96       	adiw	r26, 0x1c	; 28
    2d3c:	8c 93       	st	X, r24
    2d3e:	5c 97       	sbiw	r26, 0x1c	; 28
        state->err1 = 1;
    2d40:	81 e0       	ldi	r24, 0x01	; 1
    2d42:	90 e0       	ldi	r25, 0x00	; 0
    2d44:	5e 96       	adiw	r26, 0x1e	; 30
    2d46:	9c 93       	st	X, r25
    2d48:	8e 93       	st	-X, r24
    2d4a:	5d 97       	sbiw	r26, 0x1d	; 29
    2d4c:	92 c0       	rjmp	.+292    	; 0x2e72 <goXmodemOdbierzFunction+0x3a8>
        break;      
    2d4e:	90 e0       	ldi	r25, 0x00	; 0
    2d50:	40 e0       	ldi	r20, 0x00	; 0
    2d52:	50 e0       	ldi	r21, 0x00	; 0
    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
    2d54:	f5 01       	movw	r30, r10
    2d56:	81 91       	ld	r24, Z+
    2d58:	5f 01       	movw	r10, r30
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    2d5a:	58 27       	eor	r21, r24
    2d5c:	05 2e       	mov	r0, r21
    2d5e:	02 94       	swap	r0
    2d60:	80 2d       	mov	r24, r0
    2d62:	8f 70       	andi	r24, 0x0F	; 15
    2d64:	85 27       	eor	r24, r21
    2d66:	25 2f       	mov	r18, r21
    2d68:	20 25       	eor	r18, r0
    2d6a:	22 0f       	add	r18, r18
    2d6c:	20 7e       	andi	r18, 0xE0	; 224
    2d6e:	82 27       	eor	r24, r18
    2d70:	20 2d       	mov	r18, r0
    2d72:	25 27       	eor	r18, r21
    2d74:	20 7f       	andi	r18, 0xF0	; 240
    2d76:	26 95       	lsr	r18
    2d78:	05 2e       	mov	r0, r21
    2d7a:	00 0c       	add	r0, r0
    2d7c:	22 1f       	adc	r18, r18
    2d7e:	56 95       	lsr	r21
    2d80:	56 95       	lsr	r21
    2d82:	56 95       	lsr	r21
    2d84:	5f 71       	andi	r21, 0x1F	; 31
    2d86:	52 27       	eor	r21, r18
    2d88:	54 27       	eor	r21, r20
    2d8a:	48 2f       	mov	r20, r24

    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    2d8c:	9f 5f       	subi	r25, 0xFF	; 255
    2d8e:	90 38       	cpi	r25, 0x80	; 128
    2d90:	09 f7       	brne	.-62     	; 0x2d54 <goXmodemOdbierzFunction+0x28a>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    2d92:	8d 81       	ldd	r24, Y+5	; 0x05
    2d94:	90 e0       	ldi	r25, 0x00	; 0
    2d96:	25 2f       	mov	r18, r21
    2d98:	33 27       	eor	r19, r19
    2d9a:	82 17       	cp	r24, r18
    2d9c:	93 07       	cpc	r25, r19
    2d9e:	61 f4       	brne	.+24     	; 0x2db8 <goXmodemOdbierzFunction+0x2ee>
    2da0:	8e 81       	ldd	r24, Y+6	; 0x06
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	50 70       	andi	r21, 0x00	; 0
    2da6:	84 17       	cp	r24, r20
    2da8:	95 07       	cpc	r25, r21
    2daa:	31 f4       	brne	.+12     	; 0x2db8 <goXmodemOdbierzFunction+0x2ee>
    {
      liczbaProb = 10;
      uartVtySendByte(ACK);      
    2dac:	86 e0       	ldi	r24, 0x06	; 6
    2dae:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
    2db2:	4a e0       	ldi	r20, 0x0A	; 10
    2db4:	94 2e       	mov	r9, r20
    2db6:	16 c0       	rjmp	.+44     	; 0x2de4 <goXmodemOdbierzFunction+0x31a>
    }
    else
    {
      liczbaProb--;
    2db8:	9a 94       	dec	r9
      nrBloku--;
    2dba:	11 50       	subi	r17, 0x01	; 1
      uartVtySendByte(NAK);   
    2dbc:	85 e1       	ldi	r24, 0x15	; 21
    2dbe:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
    }
    
    if (liczbaProb == 0)
    2dc2:	99 20       	and	r9, r9
    2dc4:	79 f4       	brne	.+30     	; 0x2de4 <goXmodemOdbierzFunction+0x31a>
    {
      state->err1 = nrBlokuZdalny;
    2dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc8:	d7 01       	movw	r26, r14
    2dca:	5d 96       	adiw	r26, 0x1d	; 29
    2dcc:	8c 93       	st	X, r24
    2dce:	5d 97       	sbiw	r26, 0x1d	; 29
    2dd0:	5e 96       	adiw	r26, 0x1e	; 30
    2dd2:	1c 92       	st	X, r1
    2dd4:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    2dd6:	5f 96       	adiw	r26, 0x1f	; 31
    2dd8:	1c 93       	st	X, r17
    2dda:	5f 97       	sbiw	r26, 0x1f	; 31
      state->errno = (uint8_t)(xModemWrongFrameNo);
    2ddc:	84 e0       	ldi	r24, 0x04	; 4
    2dde:	5c 96       	adiw	r26, 0x1c	; 28
    2de0:	8c 93       	st	X, r24
    2de2:	47 c0       	rjmp	.+142    	; 0x2e72 <goXmodemOdbierzFunction+0x3a8>
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    2de4:	80 91 ad 0e 	lds	r24, 0x0EAD
    2de8:	90 91 ae 0e 	lds	r25, 0x0EAE
    2dec:	b3 01       	movw	r22, r6
    2dee:	44 e6       	ldi	r20, 0x64	; 100
    2df0:	50 e0       	ldi	r21, 0x00	; 0
    2df2:	20 e0       	ldi	r18, 0x00	; 0
    2df4:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2df8:	88 23       	and	r24, r24
    2dfa:	19 f4       	brne	.+6      	; 0x2e02 <goXmodemOdbierzFunction+0x338>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    2dfc:	82 e0       	ldi	r24, 0x02	; 2
    2dfe:	f7 01       	movw	r30, r14
    2e00:	16 c0       	rjmp	.+44     	; 0x2e2e <goXmodemOdbierzFunction+0x364>
      break;
    }
    
    if (temp1 == SOH)
    2e02:	99 81       	ldd	r25, Y+1	; 0x01
    2e04:	91 30       	cpi	r25, 0x01	; 1
    2e06:	69 f4       	brne	.+26     	; 0x2e22 <goXmodemOdbierzFunction+0x358>
    {
      nrBloku++;
    2e08:	1f 5f       	subi	r17, 0xFF	; 255
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2e0a:	89 e6       	ldi	r24, 0x69	; 105
    2e0c:	9f e0       	ldi	r25, 0x0F	; 15
    2e0e:	61 2f       	mov	r22, r17
    2e10:	70 e0       	ldi	r23, 0x00	; 0
    2e12:	0e 94 e4 1d 	call	0x3bc8	; 0x3bc8 <ramDyskDodajBlokXmodem>
    2e16:	6c 01       	movw	r12, r24
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
    2e18:	d7 01       	movw	r26, r14
    2e1a:	5c 96       	adiw	r26, 0x1c	; 28
    2e1c:	1c 92       	st	X, r1
    2e1e:	5c 01       	movw	r10, r24
    2e20:	01 cf       	rjmp	.-510    	; 0x2c24 <goXmodemOdbierzFunction+0x15a>
      continue;
    }

    if (temp1 == CAN)
    2e22:	98 31       	cpi	r25, 0x18	; 24
    2e24:	31 f4       	brne	.+12     	; 0x2e32 <goXmodemOdbierzFunction+0x368>
    {
      state->err1 = nrBloku;
    2e26:	f7 01       	movw	r30, r14
    2e28:	15 8f       	std	Z+29, r17	; 0x1d
    2e2a:	16 8e       	std	Z+30, r1	; 0x1e
      state->errno = (uint8_t)(xModemRemoteSideCan);
    2e2c:	87 e0       	ldi	r24, 0x07	; 7
    2e2e:	84 8f       	std	Z+28, r24	; 0x1c
    2e30:	20 c0       	rjmp	.+64     	; 0x2e72 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    if (temp1 == EOT)
    2e32:	94 30       	cpi	r25, 0x04	; 4
    2e34:	c9 f4       	brne	.+50     	; 0x2e68 <goXmodemOdbierzFunction+0x39e>
    {
      uartVtySendByte(NAK);
    2e36:	85 e1       	ldi	r24, 0x15	; 21
    2e38:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
      if (xQueueReceive(xVtyRec, &temp1, 10))
    2e3c:	80 91 ad 0e 	lds	r24, 0x0EAD
    2e40:	90 91 ae 0e 	lds	r25, 0x0EAE
    2e44:	b3 01       	movw	r22, r6
    2e46:	4a e0       	ldi	r20, 0x0A	; 10
    2e48:	50 e0       	ldi	r21, 0x00	; 0
    2e4a:	20 e0       	ldi	r18, 0x00	; 0
    2e4c:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    2e50:	88 23       	and	r24, r24
    2e52:	31 f0       	breq	.+12     	; 0x2e60 <goXmodemOdbierzFunction+0x396>
      {
        if (temp1 == EOT)
    2e54:	89 81       	ldd	r24, Y+1	; 0x01
    2e56:	84 30       	cpi	r24, 0x04	; 4
    2e58:	19 f4       	brne	.+6      	; 0x2e60 <goXmodemOdbierzFunction+0x396>
          uartVtySendByte(ACK);  
    2e5a:	86 e0       	ldi	r24, 0x06	; 6
    2e5c:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
      }
      state->errno = (uint8_t)(AllOK);
    2e60:	d7 01       	movw	r26, r14
    2e62:	5c 96       	adiw	r26, 0x1c	; 28
    2e64:	1c 92       	st	X, r1
    2e66:	05 c0       	rjmp	.+10     	; 0x2e72 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    2e68:	88 e0       	ldi	r24, 0x08	; 8
    2e6a:	f7 01       	movw	r30, r14
    2e6c:	84 8f       	std	Z+28, r24	; 0x1c
    state->err1 = temp1;
    2e6e:	95 8f       	std	Z+29, r25	; 0x1d
    2e70:	16 8e       	std	Z+30, r1	; 0x1e
    break;
  }
  ramDyskZamknijPlik(&fdVty);
    2e72:	89 e6       	ldi	r24, 0x69	; 105
    2e74:	9f e0       	ldi	r25, 0x0F	; 15
    2e76:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <ramDyskZamknijPlik>
    2e7a:	20 e0       	ldi	r18, 0x00	; 0
    2e7c:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2e7e:	c9 01       	movw	r24, r18
    2e80:	26 96       	adiw	r28, 0x06	; 6
    2e82:	0f b6       	in	r0, 0x3f	; 63
    2e84:	f8 94       	cli
    2e86:	de bf       	out	0x3e, r29	; 62
    2e88:	0f be       	out	0x3f, r0	; 63
    2e8a:	cd bf       	out	0x3d, r28	; 61
    2e8c:	cf 91       	pop	r28
    2e8e:	df 91       	pop	r29
    2e90:	1f 91       	pop	r17
    2e92:	0f 91       	pop	r16
    2e94:	ff 90       	pop	r15
    2e96:	ef 90       	pop	r14
    2e98:	df 90       	pop	r13
    2e9a:	cf 90       	pop	r12
    2e9c:	bf 90       	pop	r11
    2e9e:	af 90       	pop	r10
    2ea0:	9f 90       	pop	r9
    2ea2:	8f 90       	pop	r8
    2ea4:	7f 90       	pop	r7
    2ea6:	6f 90       	pop	r6
    2ea8:	5f 90       	pop	r5
    2eaa:	4f 90       	pop	r4
    2eac:	3f 90       	pop	r3
    2eae:	2f 90       	pop	r2
    2eb0:	08 95       	ret

00002eb2 <debugFunction>:
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
  return OK_SILENT;
}

static cliExRes_t debugFunction          (cmdState_t *state)
{
    2eb2:	ff 92       	push	r15
    2eb4:	0f 93       	push	r16
    2eb6:	1f 93       	push	r17
    2eb8:	cf 93       	push	r28
    2eba:	df 93       	push	r29
    2ebc:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    2ebe:	89 8d       	ldd	r24, Y+25	; 0x19
    2ec0:	82 30       	cpi	r24, 0x02	; 2
    2ec2:	08 f4       	brcc	.+2      	; 0x2ec6 <debugFunction+0x14>
    2ec4:	d2 c0       	rjmp	.+420    	; 0x306a <debugFunction+0x1b8>
    return SYNTAX_ERROR;

  uint8_t level = cmdlineGetArgInt(2, state);
    2ec6:	82 e0       	ldi	r24, 0x02	; 2
    2ec8:	be 01       	movw	r22, r28
    2eca:	0e 94 15 23 	call	0x462a	; 0x462a <cmdlineGetArgInt>
    2ece:	f6 2e       	mov	r15, r22
  const char *str = (const char*)cmdlineGetArgStr(1, state);
    2ed0:	81 e0       	ldi	r24, 0x01	; 1
    2ed2:	be 01       	movw	r22, r28
    2ed4:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    2ed8:	8c 01       	movw	r16, r24
  if (level == 0)
    2eda:	ff 20       	and	r15, r15
    2edc:	09 f0       	breq	.+2      	; 0x2ee0 <debugFunction+0x2e>
    2ede:	5b c0       	rjmp	.+182    	; 0x2f96 <debugFunction+0xe4>
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2ee0:	6b ec       	ldi	r22, 0xCB	; 203
    2ee2:	7a e0       	ldi	r23, 0x0A	; 10
    2ee4:	43 e0       	ldi	r20, 0x03	; 3
    2ee6:	50 e0       	ldi	r21, 0x00	; 0
    2ee8:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2eec:	89 2b       	or	r24, r25
    2eee:	31 f4       	brne	.+12     	; 0x2efc <debugFunction+0x4a>
    {
      setArpDebug(NULL, 0);
    2ef0:	80 e0       	ldi	r24, 0x00	; 0
    2ef2:	90 e0       	ldi	r25, 0x00	; 0
    2ef4:	60 e0       	ldi	r22, 0x00	; 0
    2ef6:	0e 94 d2 36 	call	0x6da4	; 0x6da4 <setArpDebug>
    2efa:	2c c0       	rjmp	.+88     	; 0x2f54 <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2efc:	c8 01       	movw	r24, r16
    2efe:	68 ec       	ldi	r22, 0xC8	; 200
    2f00:	7a e0       	ldi	r23, 0x0A	; 10
    2f02:	42 e0       	ldi	r20, 0x02	; 2
    2f04:	50 e0       	ldi	r21, 0x00	; 0
    2f06:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2f0a:	89 2b       	or	r24, r25
    2f0c:	31 f4       	brne	.+12     	; 0x2f1a <debugFunction+0x68>
    {
      setIpDebug(NULL, 0);
    2f0e:	80 e0       	ldi	r24, 0x00	; 0
    2f10:	90 e0       	ldi	r25, 0x00	; 0
    2f12:	60 e0       	ldi	r22, 0x00	; 0
    2f14:	0e 94 76 32 	call	0x64ec	; 0x64ec <setIpDebug>
    2f18:	1d c0       	rjmp	.+58     	; 0x2f54 <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2f1a:	c8 01       	movw	r24, r16
    2f1c:	63 ec       	ldi	r22, 0xC3	; 195
    2f1e:	7a e0       	ldi	r23, 0x0A	; 10
    2f20:	42 e0       	ldi	r20, 0x02	; 2
    2f22:	50 e0       	ldi	r21, 0x00	; 0
    2f24:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2f28:	89 2b       	or	r24, r25
    2f2a:	31 f4       	brne	.+12     	; 0x2f38 <debugFunction+0x86>
    {
      setIcmpDebug(NULL, 0);
    2f2c:	80 e0       	ldi	r24, 0x00	; 0
    2f2e:	90 e0       	ldi	r25, 0x00	; 0
    2f30:	60 e0       	ldi	r22, 0x00	; 0
    2f32:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <setIcmpDebug>
    2f36:	0e c0       	rjmp	.+28     	; 0x2f54 <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2f38:	c8 01       	movw	r24, r16
    2f3a:	6f eb       	ldi	r22, 0xBF	; 191
    2f3c:	7a e0       	ldi	r23, 0x0A	; 10
    2f3e:	42 e0       	ldi	r20, 0x02	; 2
    2f40:	50 e0       	ldi	r21, 0x00	; 0
    2f42:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2f46:	89 2b       	or	r24, r25
    2f48:	b1 f4       	brne	.+44     	; 0x2f76 <debugFunction+0xc4>
    {
      setTcpDebug(NULL, 0);
    2f4a:	80 e0       	ldi	r24, 0x00	; 0
    2f4c:	90 e0       	ldi	r25, 0x00	; 0
    2f4e:	60 e0       	ldi	r22, 0x00	; 0
    2f50:	0e 94 25 3b 	call	0x764a	; 0x764a <setTcpDebug>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
    2f54:	00 d0       	rcall	.+0      	; 0x2f56 <debugFunction+0xa4>
    2f56:	00 d0       	rcall	.+0      	; 0x2f58 <debugFunction+0xa6>
    2f58:	00 d0       	rcall	.+0      	; 0x2f5a <debugFunction+0xa8>
    2f5a:	ed b7       	in	r30, 0x3d	; 61
    2f5c:	fe b7       	in	r31, 0x3e	; 62
    2f5e:	31 96       	adiw	r30, 0x01	; 1
    2f60:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f62:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2f64:	ad b7       	in	r26, 0x3d	; 61
    2f66:	be b7       	in	r27, 0x3e	; 62
    2f68:	12 96       	adiw	r26, 0x02	; 2
    2f6a:	9c 93       	st	X, r25
    2f6c:	8e 93       	st	-X, r24
    2f6e:	11 97       	sbiw	r26, 0x01	; 1
    2f70:	88 e2       	ldi	r24, 0x28	; 40
    2f72:	94 e0       	ldi	r25, 0x04	; 4
    2f74:	5a c0       	rjmp	.+180    	; 0x302a <debugFunction+0x178>
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2f76:	c8 01       	movw	r24, r16
    2f78:	6b eb       	ldi	r22, 0xBB	; 187
    2f7a:	7a e0       	ldi	r23, 0x0A	; 10
    2f7c:	42 e0       	ldi	r20, 0x02	; 2
    2f7e:	50 e0       	ldi	r21, 0x00	; 0
    2f80:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2f84:	89 2b       	or	r24, r25
    2f86:	09 f0       	breq	.+2      	; 0x2f8a <debugFunction+0xd8>
    2f88:	70 c0       	rjmp	.+224    	; 0x306a <debugFunction+0x1b8>
    {
      setUdpDebug(NULL, 0);
    2f8a:	80 e0       	ldi	r24, 0x00	; 0
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	60 e0       	ldi	r22, 0x00	; 0
    2f90:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <setUdpDebug>
    2f94:	df cf       	rjmp	.-66     	; 0x2f54 <debugFunction+0xa2>


  }
  else                   //level > 0
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2f96:	67 eb       	ldi	r22, 0xB7	; 183
    2f98:	7a e0       	ldi	r23, 0x0A	; 10
    2f9a:	43 e0       	ldi	r20, 0x03	; 3
    2f9c:	50 e0       	ldi	r21, 0x00	; 0
    2f9e:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2fa2:	89 2b       	or	r24, r25
    2fa4:	31 f4       	brne	.+12     	; 0x2fb2 <debugFunction+0x100>
    {
      setArpDebug(state->myStdInOut, level);
    2fa6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2fa8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2faa:	6f 2d       	mov	r22, r15
    2fac:	0e 94 d2 36 	call	0x6da4	; 0x6da4 <setArpDebug>
    2fb0:	2c c0       	rjmp	.+88     	; 0x300a <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }   
    
    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2fb2:	c8 01       	movw	r24, r16
    2fb4:	64 eb       	ldi	r22, 0xB4	; 180
    2fb6:	7a e0       	ldi	r23, 0x0A	; 10
    2fb8:	42 e0       	ldi	r20, 0x02	; 2
    2fba:	50 e0       	ldi	r21, 0x00	; 0
    2fbc:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2fc0:	89 2b       	or	r24, r25
    2fc2:	31 f4       	brne	.+12     	; 0x2fd0 <debugFunction+0x11e>
    {
      setIpDebug(state->myStdInOut, level);
    2fc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2fc6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2fc8:	6f 2d       	mov	r22, r15
    2fca:	0e 94 76 32 	call	0x64ec	; 0x64ec <setIpDebug>
    2fce:	1d c0       	rjmp	.+58     	; 0x300a <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2fd0:	c8 01       	movw	r24, r16
    2fd2:	6f ea       	ldi	r22, 0xAF	; 175
    2fd4:	7a e0       	ldi	r23, 0x0A	; 10
    2fd6:	42 e0       	ldi	r20, 0x02	; 2
    2fd8:	50 e0       	ldi	r21, 0x00	; 0
    2fda:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2fde:	89 2b       	or	r24, r25
    2fe0:	31 f4       	brne	.+12     	; 0x2fee <debugFunction+0x13c>
    {
      setIcmpDebug(state->myStdInOut, level);
    2fe2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2fe4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2fe6:	6f 2d       	mov	r22, r15
    2fe8:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <setIcmpDebug>
    2fec:	0e c0       	rjmp	.+28     	; 0x300a <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2fee:	c8 01       	movw	r24, r16
    2ff0:	6b ea       	ldi	r22, 0xAB	; 171
    2ff2:	7a e0       	ldi	r23, 0x0A	; 10
    2ff4:	42 e0       	ldi	r20, 0x02	; 2
    2ff6:	50 e0       	ldi	r21, 0x00	; 0
    2ff8:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    2ffc:	89 2b       	or	r24, r25
    2ffe:	31 f5       	brne	.+76     	; 0x304c <debugFunction+0x19a>
    {
      setTcpDebug(state->myStdInOut, level);
    3000:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3002:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3004:	6f 2d       	mov	r22, r15
    3006:	0e 94 25 3b 	call	0x764a	; 0x764a <setTcpDebug>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
    300a:	00 d0       	rcall	.+0      	; 0x300c <debugFunction+0x15a>
    300c:	00 d0       	rcall	.+0      	; 0x300e <debugFunction+0x15c>
    300e:	00 d0       	rcall	.+0      	; 0x3010 <debugFunction+0x15e>
    3010:	ed b7       	in	r30, 0x3d	; 61
    3012:	fe b7       	in	r31, 0x3e	; 62
    3014:	31 96       	adiw	r30, 0x01	; 1
    3016:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3018:	9b 8d       	ldd	r25, Y+27	; 0x1b
    301a:	ad b7       	in	r26, 0x3d	; 61
    301c:	be b7       	in	r27, 0x3e	; 62
    301e:	12 96       	adiw	r26, 0x02	; 2
    3020:	9c 93       	st	X, r25
    3022:	8e 93       	st	-X, r24
    3024:	11 97       	sbiw	r26, 0x01	; 1
    3026:	85 e1       	ldi	r24, 0x15	; 21
    3028:	94 e0       	ldi	r25, 0x04	; 4
    302a:	93 83       	std	Z+3, r25	; 0x03
    302c:	82 83       	std	Z+2, r24	; 0x02
    302e:	15 83       	std	Z+5, r17	; 0x05
    3030:	04 83       	std	Z+4, r16	; 0x04
    3032:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    3036:	20 e0       	ldi	r18, 0x00	; 0
    3038:	30 e0       	ldi	r19, 0x00	; 0
    303a:	8d b7       	in	r24, 0x3d	; 61
    303c:	9e b7       	in	r25, 0x3e	; 62
    303e:	06 96       	adiw	r24, 0x06	; 6
    3040:	0f b6       	in	r0, 0x3f	; 63
    3042:	f8 94       	cli
    3044:	9e bf       	out	0x3e, r25	; 62
    3046:	0f be       	out	0x3f, r0	; 63
    3048:	8d bf       	out	0x3d, r24	; 61
    304a:	11 c0       	rjmp	.+34     	; 0x306e <debugFunction+0x1bc>
      return OK_SILENT;  
    }
    
    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    304c:	c8 01       	movw	r24, r16
    304e:	67 ea       	ldi	r22, 0xA7	; 167
    3050:	7a e0       	ldi	r23, 0x0A	; 10
    3052:	42 e0       	ldi	r20, 0x02	; 2
    3054:	50 e0       	ldi	r21, 0x00	; 0
    3056:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    305a:	89 2b       	or	r24, r25
    305c:	31 f4       	brne	.+12     	; 0x306a <debugFunction+0x1b8>
    {
      setUdpDebug(state->myStdInOut, level);
    305e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3060:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3062:	6f 2d       	mov	r22, r15
    3064:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <setUdpDebug>
    3068:	d0 cf       	rjmp	.-96     	; 0x300a <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    306a:	22 e0       	ldi	r18, 0x02	; 2
    306c:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  
  return SYNTAX_ERROR;
}
    306e:	c9 01       	movw	r24, r18
    3070:	df 91       	pop	r29
    3072:	cf 91       	pop	r28
    3074:	1f 91       	pop	r17
    3076:	0f 91       	pop	r16
    3078:	ff 90       	pop	r15
    307a:	08 95       	ret

0000307c <statusEncFunction>:
  return OK_SILENT; 
}

static cliExRes_t statusEncFunction(cmdState_t *state)
{
  nicRegDump(state->myStdInOut);
    307c:	fc 01       	movw	r30, r24
    307e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3080:	93 8d       	ldd	r25, Z+27	; 0x1b
    3082:	0e 94 05 2b 	call	0x560a	; 0x560a <nicRegDump>
  return OK_SILENT;
}
    3086:	80 e0       	ldi	r24, 0x00	; 0
    3088:	90 e0       	ldi	r25, 0x00	; 0
    308a:	08 95       	ret

0000308c <readRamFIleFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
{
    308c:	cf 92       	push	r12
    308e:	df 92       	push	r13
    3090:	ef 92       	push	r14
    3092:	ff 92       	push	r15
    3094:	0f 93       	push	r16
    3096:	1f 93       	push	r17
    3098:	df 93       	push	r29
    309a:	cf 93       	push	r28
    309c:	0f 92       	push	r0
    309e:	cd b7       	in	r28, 0x3d	; 61
    30a0:	de b7       	in	r29, 0x3e	; 62
    30a2:	8c 01       	movw	r16, r24
  uint8_t rezultat;
  uint8_t znak = ' ';
    30a4:	80 e2       	ldi	r24, 0x20	; 32
    30a6:	89 83       	std	Y+1, r24	; 0x01
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	b8 01       	movw	r22, r16
    30ac:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    30b0:	69 e6       	ldi	r22, 0x69	; 105
    30b2:	7f e0       	ldi	r23, 0x0F	; 15
    30b4:	0e 94 a0 21 	call	0x4340	; 0x4340 <ramDyskOtworzPlik>
    30b8:	d8 01       	movw	r26, r16
    30ba:	5a 96       	adiw	r26, 0x1a	; 26
    30bc:	ed 90       	ld	r14, X+
    30be:	fc 90       	ld	r15, X
    30c0:	5b 97       	sbiw	r26, 0x1b	; 27
    30c2:	88 23       	and	r24, r24
    30c4:	19 f1       	breq	.+70     	; 0x310c <readRamFIleFunction+0x80>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    30c6:	81 e0       	ldi	r24, 0x01	; 1
    30c8:	b8 01       	movw	r22, r16
    30ca:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    30ce:	00 d0       	rcall	.+0      	; 0x30d0 <readRamFIleFunction+0x44>
    30d0:	00 d0       	rcall	.+0      	; 0x30d2 <readRamFIleFunction+0x46>
    30d2:	00 d0       	rcall	.+0      	; 0x30d4 <readRamFIleFunction+0x48>
    30d4:	ed b7       	in	r30, 0x3d	; 61
    30d6:	fe b7       	in	r31, 0x3e	; 62
    30d8:	31 96       	adiw	r30, 0x01	; 1
    30da:	ad b7       	in	r26, 0x3d	; 61
    30dc:	be b7       	in	r27, 0x3e	; 62
    30de:	12 96       	adiw	r26, 0x02	; 2
    30e0:	fc 92       	st	X, r15
    30e2:	ee 92       	st	-X, r14
    30e4:	11 97       	sbiw	r26, 0x01	; 1
    30e6:	22 e8       	ldi	r18, 0x82	; 130
    30e8:	31 e0       	ldi	r19, 0x01	; 1
    30ea:	33 83       	std	Z+3, r19	; 0x03
    30ec:	22 83       	std	Z+2, r18	; 0x02
    30ee:	95 83       	std	Z+5, r25	; 0x05
    30f0:	84 83       	std	Z+4, r24	; 0x04
    30f2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    30f6:	24 e0       	ldi	r18, 0x04	; 4
    30f8:	30 e0       	ldi	r19, 0x00	; 0
    30fa:	ed b7       	in	r30, 0x3d	; 61
    30fc:	fe b7       	in	r31, 0x3e	; 62
    30fe:	36 96       	adiw	r30, 0x06	; 6
    3100:	0f b6       	in	r0, 0x3f	; 63
    3102:	f8 94       	cli
    3104:	fe bf       	out	0x3e, r31	; 62
    3106:	0f be       	out	0x3f, r0	; 63
    3108:	ed bf       	out	0x3d, r30	; 61
    310a:	58 c0       	rjmp	.+176    	; 0x31bc <readRamFIleFunction+0x130>
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    310c:	20 91 6d 0f 	lds	r18, 0x0F6D
    3110:	30 91 6e 0f 	lds	r19, 0x0F6E
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    3114:	00 d0       	rcall	.+0      	; 0x3116 <readRamFIleFunction+0x8a>
    3116:	00 d0       	rcall	.+0      	; 0x3118 <readRamFIleFunction+0x8c>
    3118:	00 d0       	rcall	.+0      	; 0x311a <readRamFIleFunction+0x8e>
    311a:	ad b7       	in	r26, 0x3d	; 61
    311c:	be b7       	in	r27, 0x3e	; 62
    311e:	11 96       	adiw	r26, 0x01	; 1
    3120:	ed b7       	in	r30, 0x3d	; 61
    3122:	fe b7       	in	r31, 0x3e	; 62
    3124:	f2 82       	std	Z+2, r15	; 0x02
    3126:	e1 82       	std	Z+1, r14	; 0x01
    3128:	80 e7       	ldi	r24, 0x70	; 112
    312a:	93 e0       	ldi	r25, 0x03	; 3
    312c:	13 96       	adiw	r26, 0x03	; 3
    312e:	9c 93       	st	X, r25
    3130:	8e 93       	st	-X, r24
    3132:	12 97       	sbiw	r26, 0x02	; 2
    3134:	f9 01       	movw	r30, r18
    3136:	92 81       	ldd	r25, Z+2	; 0x02
    3138:	80 e0       	ldi	r24, 0x00	; 0
    313a:	21 81       	ldd	r18, Z+1	; 0x01
    313c:	82 0f       	add	r24, r18
    313e:	91 1d       	adc	r25, r1
    3140:	15 96       	adiw	r26, 0x05	; 5
    3142:	9c 93       	st	X, r25
    3144:	8e 93       	st	-X, r24
    3146:	14 97       	sbiw	r26, 0x04	; 4
    3148:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    314c:	8d b7       	in	r24, 0x3d	; 61
    314e:	9e b7       	in	r25, 0x3e	; 62
    3150:	06 96       	adiw	r24, 0x06	; 6
    3152:	0f b6       	in	r0, 0x3f	; 63
    3154:	f8 94       	cli
    3156:	9e bf       	out	0x3e, r25	; 62
    3158:	0f be       	out	0x3f, r0	; 63
    315a:	8d bf       	out	0x3d, r24	; 61
  while (rezultat == 0)
  {
    rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
    315c:	6e 01       	movw	r12, r28
    315e:	08 94       	sec
    3160:	c1 1c       	adc	r12, r1
    3162:	d1 1c       	adc	r13, r1
    3164:	89 e6       	ldi	r24, 0x69	; 105
    3166:	9f e0       	ldi	r25, 0x0F	; 15
    3168:	b6 01       	movw	r22, r12
    316a:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <ramDyskCzytajBajtZPliku>
    316e:	f8 2e       	mov	r15, r24
    
    uartVtySendByte(znak);
    3170:	89 81       	ldd	r24, Y+1	; 0x01
    3172:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
    if (znak == '\r')
    3176:	89 81       	ldd	r24, Y+1	; 0x01
    3178:	8d 30       	cpi	r24, 0x0D	; 13
    317a:	19 f4       	brne	.+6      	; 0x3182 <readRamFIleFunction+0xf6>
      uartVtySendByte('\n');
    317c:	8a e0       	ldi	r24, 0x0A	; 10
    317e:	0e 94 12 0c 	call	0x1824	; 0x1824 <uartVtySendByte>
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
  while (rezultat == 0)
    3182:	ff 20       	and	r15, r15
    3184:	79 f3       	breq	.-34     	; 0x3164 <readRamFIleFunction+0xd8>
    
    uartVtySendByte(znak);
    if (znak == '\r')
      uartVtySendByte('\n');
  }
  fprintf_P(state->myStdInOut, nlStr);
    3186:	00 d0       	rcall	.+0      	; 0x3188 <readRamFIleFunction+0xfc>
    3188:	00 d0       	rcall	.+0      	; 0x318a <readRamFIleFunction+0xfe>
    318a:	d8 01       	movw	r26, r16
    318c:	5a 96       	adiw	r26, 0x1a	; 26
    318e:	8d 91       	ld	r24, X+
    3190:	9c 91       	ld	r25, X
    3192:	5b 97       	sbiw	r26, 0x1b	; 27
    3194:	ed b7       	in	r30, 0x3d	; 61
    3196:	fe b7       	in	r31, 0x3e	; 62
    3198:	92 83       	std	Z+2, r25	; 0x02
    319a:	81 83       	std	Z+1, r24	; 0x01
    319c:	85 e0       	ldi	r24, 0x05	; 5
    319e:	99 e0       	ldi	r25, 0x09	; 9
    31a0:	94 83       	std	Z+4, r25	; 0x04
    31a2:	83 83       	std	Z+3, r24	; 0x03
    31a4:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  ramDyskZamknijPlik(&fdVty);
    31a8:	0f 90       	pop	r0
    31aa:	0f 90       	pop	r0
    31ac:	0f 90       	pop	r0
    31ae:	0f 90       	pop	r0
    31b0:	89 e6       	ldi	r24, 0x69	; 105
    31b2:	9f e0       	ldi	r25, 0x0F	; 15
    31b4:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <ramDyskZamknijPlik>
    31b8:	20 e0       	ldi	r18, 0x00	; 0
    31ba:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    31bc:	c9 01       	movw	r24, r18
    31be:	0f 90       	pop	r0
    31c0:	cf 91       	pop	r28
    31c2:	df 91       	pop	r29
    31c4:	1f 91       	pop	r17
    31c6:	0f 91       	pop	r16
    31c8:	ff 90       	pop	r15
    31ca:	ef 90       	pop	r14
    31cc:	df 90       	pop	r13
    31ce:	cf 90       	pop	r12
    31d0:	08 95       	ret

000031d2 <writeRamFileFunction>:
  return ERROR_INFORM;
}

static cliExRes_t writeRamFileFunction(cmdState_t *state)
{
  ramDyskDir(state->myStdInOut);
    31d2:	fc 01       	movw	r30, r24
    31d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    31d6:	93 8d       	ldd	r25, Z+27	; 0x1b
    31d8:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <ramDyskDir>
  return OK_SILENT;
}
    31dc:	80 e0       	ldi	r24, 0x00	; 0
    31de:	90 e0       	ldi	r25, 0x00	; 0
    31e0:	08 95       	ret

000031e2 <pokazCzasFunction>:
  nicRegDump(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
    31e2:	0f 93       	push	r16
    31e4:	1f 93       	push	r17
    31e6:	cf 93       	push	r28
    31e8:	df 93       	push	r29
    31ea:	8c 01       	movw	r16, r24
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
    31ec:	83 eb       	ldi	r24, 0xB3	; 179
    31ee:	9e e0       	ldi	r25, 0x0E	; 14
    31f0:	0e 94 e8 28 	call	0x51d0	; 0x51d0 <readTimeDecoded>
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    31f4:	20 91 b5 0e 	lds	r18, 0x0EB5
    31f8:	22 95       	swap	r18
    31fa:	2f 70       	andi	r18, 0x0F	; 15
    31fc:	40 91 b5 0e 	lds	r20, 0x0EB5
    3200:	4f 70       	andi	r20, 0x0F	; 15
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    3202:	70 91 b4 0e 	lds	r23, 0x0EB4
    3206:	72 95       	swap	r23
    3208:	7f 70       	andi	r23, 0x0F	; 15
    320a:	50 91 b4 0e 	lds	r21, 0x0EB4
    320e:	5f 70       	andi	r21, 0x0F	; 15
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    3210:	a0 91 b3 0e 	lds	r26, 0x0EB3
    3214:	a2 95       	swap	r26
    3216:	af 70       	andi	r26, 0x0F	; 15
    3218:	60 91 b3 0e 	lds	r22, 0x0EB3
    321c:	6f 70       	andi	r22, 0x0F	; 15
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    321e:	8d b7       	in	r24, 0x3d	; 61
    3220:	9e b7       	in	r25, 0x3e	; 62
    3222:	0a 97       	sbiw	r24, 0x0a	; 10
    3224:	0f b6       	in	r0, 0x3f	; 63
    3226:	f8 94       	cli
    3228:	9e bf       	out	0x3e, r25	; 62
    322a:	0f be       	out	0x3f, r0	; 63
    322c:	8d bf       	out	0x3d, r24	; 61
    322e:	ed b7       	in	r30, 0x3d	; 61
    3230:	fe b7       	in	r31, 0x3e	; 62
    3232:	31 96       	adiw	r30, 0x01	; 1
    3234:	e8 01       	movw	r28, r16
    3236:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3238:	9b 8d       	ldd	r25, Y+27	; 0x1b
    323a:	cd b7       	in	r28, 0x3d	; 61
    323c:	de b7       	in	r29, 0x3e	; 62
    323e:	9a 83       	std	Y+2, r25	; 0x02
    3240:	89 83       	std	Y+1, r24	; 0x01
    3242:	8f ec       	ldi	r24, 0xCF	; 207
    3244:	9a e0       	ldi	r25, 0x0A	; 10
    3246:	93 83       	std	Z+3, r25	; 0x03
    3248:	82 83       	std	Z+2, r24	; 0x02
    324a:	82 2f       	mov	r24, r18
    324c:	83 70       	andi	r24, 0x03	; 3
    324e:	90 e0       	ldi	r25, 0x00	; 0
    3250:	9c 01       	movw	r18, r24
    3252:	13 e0       	ldi	r17, 0x03	; 3
    3254:	22 0f       	add	r18, r18
    3256:	33 1f       	adc	r19, r19
    3258:	1a 95       	dec	r17
    325a:	e1 f7       	brne	.-8      	; 0x3254 <pokazCzasFunction+0x72>
    325c:	88 0f       	add	r24, r24
    325e:	99 1f       	adc	r25, r25
    3260:	28 0f       	add	r18, r24
    3262:	39 1f       	adc	r19, r25
    3264:	42 0f       	add	r20, r18
    3266:	44 83       	std	Z+4, r20	; 0x04
    3268:	15 82       	std	Z+5, r1	; 0x05
    326a:	87 2f       	mov	r24, r23
    326c:	87 70       	andi	r24, 0x07	; 7
    326e:	90 e0       	ldi	r25, 0x00	; 0
    3270:	9c 01       	movw	r18, r24
    3272:	73 e0       	ldi	r23, 0x03	; 3
    3274:	22 0f       	add	r18, r18
    3276:	33 1f       	adc	r19, r19
    3278:	7a 95       	dec	r23
    327a:	e1 f7       	brne	.-8      	; 0x3274 <pokazCzasFunction+0x92>
    327c:	88 0f       	add	r24, r24
    327e:	99 1f       	adc	r25, r25
    3280:	28 0f       	add	r18, r24
    3282:	39 1f       	adc	r19, r25
    3284:	52 0f       	add	r21, r18
    3286:	56 83       	std	Z+6, r21	; 0x06
    3288:	17 82       	std	Z+7, r1	; 0x07
    328a:	8a 2f       	mov	r24, r26
    328c:	87 70       	andi	r24, 0x07	; 7
    328e:	90 e0       	ldi	r25, 0x00	; 0
    3290:	9c 01       	movw	r18, r24
    3292:	03 e0       	ldi	r16, 0x03	; 3
    3294:	22 0f       	add	r18, r18
    3296:	33 1f       	adc	r19, r19
    3298:	0a 95       	dec	r16
    329a:	e1 f7       	brne	.-8      	; 0x3294 <pokazCzasFunction+0xb2>
    329c:	88 0f       	add	r24, r24
    329e:	99 1f       	adc	r25, r25
    32a0:	28 0f       	add	r18, r24
    32a2:	39 1f       	adc	r19, r25
    32a4:	62 0f       	add	r22, r18
    32a6:	60 87       	std	Z+8, r22	; 0x08
    32a8:	11 86       	std	Z+9, r1	; 0x09
    32aa:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    32ae:	8d b7       	in	r24, 0x3d	; 61
    32b0:	9e b7       	in	r25, 0x3e	; 62
    32b2:	0a 96       	adiw	r24, 0x0a	; 10
    32b4:	0f b6       	in	r0, 0x3f	; 63
    32b6:	f8 94       	cli
    32b8:	9e bf       	out	0x3e, r25	; 62
    32ba:	0f be       	out	0x3f, r0	; 63
    32bc:	8d bf       	out	0x3d, r24	; 61
  return OK_SILENT;
}
    32be:	80 e0       	ldi	r24, 0x00	; 0
    32c0:	90 e0       	ldi	r25, 0x00	; 0
    32c2:	df 91       	pop	r29
    32c4:	cf 91       	pop	r28
    32c6:	1f 91       	pop	r17
    32c8:	0f 91       	pop	r16
    32ca:	08 95       	ret

000032cc <helpFunction>:
  return OK_SILENT;
}

static cliExRes_t helpFunction(cmdState_t *state)
{
  cmdPrintHelp(state);
    32cc:	0e 94 7f 22 	call	0x44fe	; 0x44fe <cmdPrintHelp>
  return OK_SILENT;
}
    32d0:	80 e0       	ldi	r24, 0x00	; 0
    32d2:	90 e0       	ldi	r25, 0x00	; 0
    32d4:	08 95       	ret

000032d6 <printStatus>:
  return ERROR_OPERATION_NOT_ALLOWED;
}

// ************************** VTY API ***************************************************************************************
void printStatus(FILE *stream)
{
    32d6:	cf 93       	push	r28
    32d8:	df 93       	push	r29
    32da:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
    32dc:	00 d0       	rcall	.+0      	; 0x32de <printStatus+0x8>
    32de:	00 d0       	rcall	.+0      	; 0x32e0 <printStatus+0xa>
    32e0:	ad b7       	in	r26, 0x3d	; 61
    32e2:	be b7       	in	r27, 0x3e	; 62
    32e4:	12 96       	adiw	r26, 0x02	; 2
    32e6:	9c 93       	st	X, r25
    32e8:	8e 93       	st	-X, r24
    32ea:	11 97       	sbiw	r26, 0x01	; 1
    32ec:	84 ef       	ldi	r24, 0xF4	; 244
    32ee:	9a e0       	ldi	r25, 0x0A	; 10
    32f0:	14 96       	adiw	r26, 0x04	; 4
    32f2:	9c 93       	st	X, r25
    32f4:	8e 93       	st	-X, r24
    32f6:	13 97       	sbiw	r26, 0x03	; 3
    32f8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  //Print system state
  fprintf_P(stream, systemStateStr);
    32fc:	ed b7       	in	r30, 0x3d	; 61
    32fe:	fe b7       	in	r31, 0x3e	; 62
    3300:	d2 83       	std	Z+2, r29	; 0x02
    3302:	c1 83       	std	Z+1, r28	; 0x01
    3304:	87 e9       	ldi	r24, 0x97	; 151
    3306:	91 e0       	ldi	r25, 0x01	; 1
    3308:	94 83       	std	Z+4, r25	; 0x04
    330a:	83 83       	std	Z+3, r24	; 0x03
    330c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
    3310:	0f 90       	pop	r0
    3312:	0f 90       	pop	r0
    3314:	0f 90       	pop	r0
    3316:	0f 90       	pop	r0
    3318:	0e 94 03 4c 	call	0x9806	; 0x9806 <uxTaskGetNumberOfTasks>
    331c:	00 d0       	rcall	.+0      	; 0x331e <printStatus+0x48>
    331e:	00 d0       	rcall	.+0      	; 0x3320 <printStatus+0x4a>
    3320:	00 d0       	rcall	.+0      	; 0x3322 <printStatus+0x4c>
    3322:	ed b7       	in	r30, 0x3d	; 61
    3324:	fe b7       	in	r31, 0x3e	; 62
    3326:	31 96       	adiw	r30, 0x01	; 1
    3328:	ad b7       	in	r26, 0x3d	; 61
    332a:	be b7       	in	r27, 0x3e	; 62
    332c:	12 96       	adiw	r26, 0x02	; 2
    332e:	dc 93       	st	X, r29
    3330:	ce 93       	st	-X, r28
    3332:	11 97       	sbiw	r26, 0x01	; 1
    3334:	27 ea       	ldi	r18, 0xA7	; 167
    3336:	31 e0       	ldi	r19, 0x01	; 1
    3338:	33 83       	std	Z+3, r19	; 0x03
    333a:	22 83       	std	Z+2, r18	; 0x02
    333c:	84 83       	std	Z+4, r24	; 0x04
    333e:	15 82       	std	Z+5, r1	; 0x05
    3340:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
    3344:	ed b7       	in	r30, 0x3d	; 61
    3346:	fe b7       	in	r31, 0x3e	; 62
    3348:	36 96       	adiw	r30, 0x06	; 6
    334a:	0f b6       	in	r0, 0x3f	; 63
    334c:	f8 94       	cli
    334e:	fe bf       	out	0x3e, r31	; 62
    3350:	0f be       	out	0x3f, r0	; 63
    3352:	ed bf       	out	0x3d, r30	; 61
    3354:	0e 94 57 58 	call	0xb0ae	; 0xb0ae <xPortGetFreeHeapSize>
    3358:	2d b7       	in	r18, 0x3d	; 61
    335a:	3e b7       	in	r19, 0x3e	; 62
    335c:	28 50       	subi	r18, 0x08	; 8
    335e:	30 40       	sbci	r19, 0x00	; 0
    3360:	0f b6       	in	r0, 0x3f	; 63
    3362:	f8 94       	cli
    3364:	3e bf       	out	0x3e, r19	; 62
    3366:	0f be       	out	0x3f, r0	; 63
    3368:	2d bf       	out	0x3d, r18	; 61
    336a:	ed b7       	in	r30, 0x3d	; 61
    336c:	fe b7       	in	r31, 0x3e	; 62
    336e:	31 96       	adiw	r30, 0x01	; 1
    3370:	ad b7       	in	r26, 0x3d	; 61
    3372:	be b7       	in	r27, 0x3e	; 62
    3374:	12 96       	adiw	r26, 0x02	; 2
    3376:	dc 93       	st	X, r29
    3378:	ce 93       	st	-X, r28
    337a:	11 97       	sbiw	r26, 0x01	; 1
    337c:	20 ec       	ldi	r18, 0xC0	; 192
    337e:	31 e0       	ldi	r19, 0x01	; 1
    3380:	33 83       	std	Z+3, r19	; 0x03
    3382:	22 83       	std	Z+2, r18	; 0x02
    3384:	95 83       	std	Z+5, r25	; 0x05
    3386:	84 83       	std	Z+4, r24	; 0x04
    3388:	8c e1       	ldi	r24, 0x1C	; 28
    338a:	9c e0       	ldi	r25, 0x0C	; 12
    338c:	97 83       	std	Z+7, r25	; 0x07
    338e:	86 83       	std	Z+6, r24	; 0x06
    3390:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
    3394:	ed b7       	in	r30, 0x3d	; 61
    3396:	fe b7       	in	r31, 0x3e	; 62
    3398:	38 96       	adiw	r30, 0x08	; 8
    339a:	0f b6       	in	r0, 0x3f	; 63
    339c:	f8 94       	cli
    339e:	fe bf       	out	0x3e, r31	; 62
    33a0:	0f be       	out	0x3f, r0	; 63
    33a2:	ed bf       	out	0x3d, r30	; 61
    33a4:	0e 94 ce 1c 	call	0x399c	; 0x399c <xmallocAvailable>
    33a8:	2d b7       	in	r18, 0x3d	; 61
    33aa:	3e b7       	in	r19, 0x3e	; 62
    33ac:	28 50       	subi	r18, 0x08	; 8
    33ae:	30 40       	sbci	r19, 0x00	; 0
    33b0:	0f b6       	in	r0, 0x3f	; 63
    33b2:	f8 94       	cli
    33b4:	3e bf       	out	0x3e, r19	; 62
    33b6:	0f be       	out	0x3f, r0	; 63
    33b8:	2d bf       	out	0x3d, r18	; 61
    33ba:	ed b7       	in	r30, 0x3d	; 61
    33bc:	fe b7       	in	r31, 0x3e	; 62
    33be:	31 96       	adiw	r30, 0x01	; 1
    33c0:	ad b7       	in	r26, 0x3d	; 61
    33c2:	be b7       	in	r27, 0x3e	; 62
    33c4:	12 96       	adiw	r26, 0x02	; 2
    33c6:	dc 93       	st	X, r29
    33c8:	ce 93       	st	-X, r28
    33ca:	11 97       	sbiw	r26, 0x01	; 1
    33cc:	2a ee       	ldi	r18, 0xEA	; 234
    33ce:	31 e0       	ldi	r19, 0x01	; 1
    33d0:	33 83       	std	Z+3, r19	; 0x03
    33d2:	22 83       	std	Z+2, r18	; 0x02
    33d4:	95 83       	std	Z+5, r25	; 0x05
    33d6:	84 83       	std	Z+4, r24	; 0x04
    33d8:	80 e0       	ldi	r24, 0x00	; 0
    33da:	97 e1       	ldi	r25, 0x17	; 23
    33dc:	97 83       	std	Z+7, r25	; 0x07
    33de:	86 83       	std	Z+6, r24	; 0x06
    33e0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, statusTemperatureStr, temperature); 
    33e4:	20 91 a4 0e 	lds	r18, 0x0EA4
    33e8:	0f 90       	pop	r0
    33ea:	0f 90       	pop	r0
    33ec:	ed b7       	in	r30, 0x3d	; 61
    33ee:	fe b7       	in	r31, 0x3e	; 62
    33f0:	31 96       	adiw	r30, 0x01	; 1
    33f2:	ad b7       	in	r26, 0x3d	; 61
    33f4:	be b7       	in	r27, 0x3e	; 62
    33f6:	12 96       	adiw	r26, 0x02	; 2
    33f8:	dc 93       	st	X, r29
    33fa:	ce 93       	st	-X, r28
    33fc:	11 97       	sbiw	r26, 0x01	; 1
    33fe:	81 e4       	ldi	r24, 0x41	; 65
    3400:	92 e0       	ldi	r25, 0x02	; 2
    3402:	93 83       	std	Z+3, r25	; 0x03
    3404:	82 83       	std	Z+2, r24	; 0x02
    3406:	24 83       	std	Z+4, r18	; 0x04
    3408:	15 82       	std	Z+5, r1	; 0x05
    340a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, statusVoltageStr, voltage); 
    340e:	20 91 ac 0e 	lds	r18, 0x0EAC
    3412:	ed b7       	in	r30, 0x3d	; 61
    3414:	fe b7       	in	r31, 0x3e	; 62
    3416:	31 96       	adiw	r30, 0x01	; 1
    3418:	ad b7       	in	r26, 0x3d	; 61
    341a:	be b7       	in	r27, 0x3e	; 62
    341c:	12 96       	adiw	r26, 0x02	; 2
    341e:	dc 93       	st	X, r29
    3420:	ce 93       	st	-X, r28
    3422:	11 97       	sbiw	r26, 0x01	; 1
    3424:	8c e5       	ldi	r24, 0x5C	; 92
    3426:	92 e0       	ldi	r25, 0x02	; 2
    3428:	93 83       	std	Z+3, r25	; 0x03
    342a:	82 83       	std	Z+2, r24	; 0x02
    342c:	24 83       	std	Z+4, r18	; 0x04
    342e:	15 82       	std	Z+5, r1	; 0x05
    3430:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>

  uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
    3434:	ed b7       	in	r30, 0x3d	; 61
    3436:	fe b7       	in	r31, 0x3e	; 62
    3438:	36 96       	adiw	r30, 0x06	; 6
    343a:	0f b6       	in	r0, 0x3f	; 63
    343c:	f8 94       	cli
    343e:	fe bf       	out	0x3e, r31	; 62
    3440:	0f be       	out	0x3f, r0	; 63
    3442:	ed bf       	out	0x3d, r30	; 61
    3444:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <ramDyskLiczbaWolnychKlastrow>
  fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
    3448:	2d b7       	in	r18, 0x3d	; 61
    344a:	3e b7       	in	r19, 0x3e	; 62
    344c:	28 50       	subi	r18, 0x08	; 8
    344e:	30 40       	sbci	r19, 0x00	; 0
    3450:	0f b6       	in	r0, 0x3f	; 63
    3452:	f8 94       	cli
    3454:	3e bf       	out	0x3e, r19	; 62
    3456:	0f be       	out	0x3f, r0	; 63
    3458:	2d bf       	out	0x3d, r18	; 61
    345a:	ed b7       	in	r30, 0x3d	; 61
    345c:	fe b7       	in	r31, 0x3e	; 62
    345e:	31 96       	adiw	r30, 0x01	; 1
    3460:	ad b7       	in	r26, 0x3d	; 61
    3462:	be b7       	in	r27, 0x3e	; 62
    3464:	12 96       	adiw	r26, 0x02	; 2
    3466:	dc 93       	st	X, r29
    3468:	ce 93       	st	-X, r28
    346a:	11 97       	sbiw	r26, 0x01	; 1
    346c:	24 e1       	ldi	r18, 0x14	; 20
    346e:	32 e0       	ldi	r19, 0x02	; 2
    3470:	33 83       	std	Z+3, r19	; 0x03
    3472:	22 83       	std	Z+2, r18	; 0x02
    3474:	84 83       	std	Z+4, r24	; 0x04
    3476:	15 82       	std	Z+5, r1	; 0x05
    3478:	80 e8       	ldi	r24, 0x80	; 128
    347a:	90 e0       	ldi	r25, 0x00	; 0
    347c:	97 83       	std	Z+7, r25	; 0x07
    347e:	86 83       	std	Z+6, r24	; 0x06
    3480:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
//  printErrorInfo(state); //TODO fix and uncomment
  
  //Print system configuration
  fprintf_P(stream, systemRamConfigStr);
    3484:	0f 90       	pop	r0
    3486:	0f 90       	pop	r0
    3488:	0f 90       	pop	r0
    348a:	0f 90       	pop	r0
    348c:	ed b7       	in	r30, 0x3d	; 61
    348e:	fe b7       	in	r31, 0x3e	; 62
    3490:	d2 83       	std	Z+2, r29	; 0x02
    3492:	c1 83       	std	Z+1, r28	; 0x01
    3494:	87 e7       	ldi	r24, 0x77	; 119
    3496:	92 e0       	ldi	r25, 0x02	; 2
    3498:	94 83       	std	Z+4, r25	; 0x04
    349a:	83 83       	std	Z+3, r24	; 0x03
    349c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>

  fprintf_P(stream, statusMacStr);
    34a0:	ad b7       	in	r26, 0x3d	; 61
    34a2:	be b7       	in	r27, 0x3e	; 62
    34a4:	12 96       	adiw	r26, 0x02	; 2
    34a6:	dc 93       	st	X, r29
    34a8:	ce 93       	st	-X, r28
    34aa:	11 97       	sbiw	r26, 0x01	; 1
    34ac:	8a e8       	ldi	r24, 0x8A	; 138
    34ae:	92 e0       	ldi	r25, 0x02	; 2
    34b0:	14 96       	adiw	r26, 0x04	; 4
    34b2:	9c 93       	st	X, r25
    34b4:	8e 93       	st	-X, r24
    34b6:	13 97       	sbiw	r26, 0x03	; 3
    34b8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    34bc:	0f 90       	pop	r0
    34be:	0f 90       	pop	r0
    34c0:	0f 90       	pop	r0
    34c2:	0f 90       	pop	r0
    34c4:	ce 01       	movw	r24, r28
    34c6:	60 e8       	ldi	r22, 0x80	; 128
    34c8:	7e e0       	ldi	r23, 0x0E	; 14
    34ca:	0e 94 82 31 	call	0x6304	; 0x6304 <netPrintEthAddr>
  fprintf_P(stream, PSTR("\r\n"));
    34ce:	00 d0       	rcall	.+0      	; 0x34d0 <printStatus+0x1fa>
    34d0:	00 d0       	rcall	.+0      	; 0x34d2 <printStatus+0x1fc>
    34d2:	ed b7       	in	r30, 0x3d	; 61
    34d4:	fe b7       	in	r31, 0x3e	; 62
    34d6:	d2 83       	std	Z+2, r29	; 0x02
    34d8:	c1 83       	std	Z+1, r28	; 0x01
    34da:	81 ef       	ldi	r24, 0xF1	; 241
    34dc:	9a e0       	ldi	r25, 0x0A	; 10
    34de:	94 83       	std	Z+4, r25	; 0x04
    34e0:	83 83       	std	Z+3, r24	; 0x03
    34e2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  
  fprintf_P(stream, statusIpStr);
    34e6:	ad b7       	in	r26, 0x3d	; 61
    34e8:	be b7       	in	r27, 0x3e	; 62
    34ea:	12 96       	adiw	r26, 0x02	; 2
    34ec:	dc 93       	st	X, r29
    34ee:	ce 93       	st	-X, r28
    34f0:	11 97       	sbiw	r26, 0x01	; 1
    34f2:	8f e9       	ldi	r24, 0x9F	; 159
    34f4:	92 e0       	ldi	r25, 0x02	; 2
    34f6:	14 96       	adiw	r26, 0x04	; 4
    34f8:	9c 93       	st	X, r25
    34fa:	8e 93       	st	-X, r24
    34fc:	13 97       	sbiw	r26, 0x03	; 3
    34fe:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->ip);
    3502:	0f 90       	pop	r0
    3504:	0f 90       	pop	r0
    3506:	0f 90       	pop	r0
    3508:	0f 90       	pop	r0
    350a:	0e 94 bf 32 	call	0x657e	; 0x657e <ipGetConfig>
    350e:	fc 01       	movw	r30, r24
    3510:	40 81       	ld	r20, Z
    3512:	51 81       	ldd	r21, Z+1	; 0x01
    3514:	62 81       	ldd	r22, Z+2	; 0x02
    3516:	73 81       	ldd	r23, Z+3	; 0x03
    3518:	ce 01       	movw	r24, r28
    351a:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    351e:	00 d0       	rcall	.+0      	; 0x3520 <printStatus+0x24a>
    3520:	00 d0       	rcall	.+0      	; 0x3522 <printStatus+0x24c>
    3522:	ed b7       	in	r30, 0x3d	; 61
    3524:	fe b7       	in	r31, 0x3e	; 62
    3526:	d2 83       	std	Z+2, r29	; 0x02
    3528:	c1 83       	std	Z+1, r28	; 0x01
    352a:	8e ee       	ldi	r24, 0xEE	; 238
    352c:	9a e0       	ldi	r25, 0x0A	; 10
    352e:	94 83       	std	Z+4, r25	; 0x04
    3530:	83 83       	std	Z+3, r24	; 0x03
    3532:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>

  fprintf_P(stream, statusIpMaskStr);
    3536:	ad b7       	in	r26, 0x3d	; 61
    3538:	be b7       	in	r27, 0x3e	; 62
    353a:	12 96       	adiw	r26, 0x02	; 2
    353c:	dc 93       	st	X, r29
    353e:	ce 93       	st	-X, r28
    3540:	11 97       	sbiw	r26, 0x01	; 1
    3542:	84 eb       	ldi	r24, 0xB4	; 180
    3544:	92 e0       	ldi	r25, 0x02	; 2
    3546:	14 96       	adiw	r26, 0x04	; 4
    3548:	9c 93       	st	X, r25
    354a:	8e 93       	st	-X, r24
    354c:	13 97       	sbiw	r26, 0x03	; 3
    354e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->netmask);
    3552:	0f 90       	pop	r0
    3554:	0f 90       	pop	r0
    3556:	0f 90       	pop	r0
    3558:	0f 90       	pop	r0
    355a:	0e 94 bf 32 	call	0x657e	; 0x657e <ipGetConfig>
    355e:	fc 01       	movw	r30, r24
    3560:	44 81       	ldd	r20, Z+4	; 0x04
    3562:	55 81       	ldd	r21, Z+5	; 0x05
    3564:	66 81       	ldd	r22, Z+6	; 0x06
    3566:	77 81       	ldd	r23, Z+7	; 0x07
    3568:	ce 01       	movw	r24, r28
    356a:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    356e:	00 d0       	rcall	.+0      	; 0x3570 <printStatus+0x29a>
    3570:	00 d0       	rcall	.+0      	; 0x3572 <printStatus+0x29c>
    3572:	ad b7       	in	r26, 0x3d	; 61
    3574:	be b7       	in	r27, 0x3e	; 62
    3576:	12 96       	adiw	r26, 0x02	; 2
    3578:	dc 93       	st	X, r29
    357a:	ce 93       	st	-X, r28
    357c:	11 97       	sbiw	r26, 0x01	; 1
    357e:	8b ee       	ldi	r24, 0xEB	; 235
    3580:	9a e0       	ldi	r25, 0x0A	; 10
    3582:	14 96       	adiw	r26, 0x04	; 4
    3584:	9c 93       	st	X, r25
    3586:	8e 93       	st	-X, r24
    3588:	13 97       	sbiw	r26, 0x03	; 3
    358a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  
  fprintf_P(stream, statusIpGwStr);
    358e:	ed b7       	in	r30, 0x3d	; 61
    3590:	fe b7       	in	r31, 0x3e	; 62
    3592:	d2 83       	std	Z+2, r29	; 0x02
    3594:	c1 83       	std	Z+1, r28	; 0x01
    3596:	89 ec       	ldi	r24, 0xC9	; 201
    3598:	92 e0       	ldi	r25, 0x02	; 2
    359a:	94 83       	std	Z+4, r25	; 0x04
    359c:	83 83       	std	Z+3, r24	; 0x03
    359e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->gateway);
    35a2:	0f 90       	pop	r0
    35a4:	0f 90       	pop	r0
    35a6:	0f 90       	pop	r0
    35a8:	0f 90       	pop	r0
    35aa:	0e 94 bf 32 	call	0x657e	; 0x657e <ipGetConfig>
    35ae:	dc 01       	movw	r26, r24
    35b0:	18 96       	adiw	r26, 0x08	; 8
    35b2:	4d 91       	ld	r20, X+
    35b4:	5d 91       	ld	r21, X+
    35b6:	6d 91       	ld	r22, X+
    35b8:	7c 91       	ld	r23, X
    35ba:	1b 97       	sbiw	r26, 0x0b	; 11
    35bc:	ce 01       	movw	r24, r28
    35be:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    35c2:	00 d0       	rcall	.+0      	; 0x35c4 <printStatus+0x2ee>
    35c4:	00 d0       	rcall	.+0      	; 0x35c6 <printStatus+0x2f0>
    35c6:	ed b7       	in	r30, 0x3d	; 61
    35c8:	fe b7       	in	r31, 0x3e	; 62
    35ca:	d2 83       	std	Z+2, r29	; 0x02
    35cc:	c1 83       	std	Z+1, r28	; 0x01
    35ce:	88 ee       	ldi	r24, 0xE8	; 232
    35d0:	9a e0       	ldi	r25, 0x0A	; 10
    35d2:	94 83       	std	Z+4, r25	; 0x04
    35d4:	83 83       	std	Z+3, r24	; 0x03
    35d6:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  
  //Print Rs485 Execitive modules
  fprintf_P(stream, statusRs485listStr);
    35da:	ad b7       	in	r26, 0x3d	; 61
    35dc:	be b7       	in	r27, 0x3e	; 62
    35de:	12 96       	adiw	r26, 0x02	; 2
    35e0:	dc 93       	st	X, r29
    35e2:	ce 93       	st	-X, r28
    35e4:	11 97       	sbiw	r26, 0x01	; 1
    35e6:	8e ed       	ldi	r24, 0xDE	; 222
    35e8:	92 e0       	ldi	r25, 0x02	; 2
    35ea:	14 96       	adiw	r26, 0x04	; 4
    35ec:	9c 93       	st	X, r25
    35ee:	8e 93       	st	-X, r24
    35f0:	13 97       	sbiw	r26, 0x03	; 3
    35f2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  tmp = printRs485devices(stream);
    35f6:	0f 90       	pop	r0
    35f8:	0f 90       	pop	r0
    35fa:	0f 90       	pop	r0
    35fc:	0f 90       	pop	r0
    35fe:	ce 01       	movw	r24, r28
    3600:	0e 94 63 44 	call	0x88c6	; 0x88c6 <printRs485devices>
  if (tmp == 0)
    3604:	88 23       	and	r24, r24
    3606:	81 f4       	brne	.+32     	; 0x3628 <printStatus+0x352>
    fprintf_P(stream, statusNoRs485Dev);  
    3608:	00 d0       	rcall	.+0      	; 0x360a <printStatus+0x334>
    360a:	00 d0       	rcall	.+0      	; 0x360c <printStatus+0x336>
    360c:	ed b7       	in	r30, 0x3d	; 61
    360e:	fe b7       	in	r31, 0x3e	; 62
    3610:	d2 83       	std	Z+2, r29	; 0x02
    3612:	c1 83       	std	Z+1, r28	; 0x01
    3614:	89 ef       	ldi	r24, 0xF9	; 249
    3616:	92 e0       	ldi	r25, 0x02	; 2
    3618:	94 83       	std	Z+4, r25	; 0x04
    361a:	83 83       	std	Z+3, r24	; 0x03
    361c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    3620:	0f 90       	pop	r0
    3622:	0f 90       	pop	r0
    3624:	0f 90       	pop	r0
    3626:	0f 90       	pop	r0
  
  //Print locker sensors
  fprintf_P(stream, statusLockerSensorsStr);
    3628:	00 d0       	rcall	.+0      	; 0x362a <printStatus+0x354>
    362a:	00 d0       	rcall	.+0      	; 0x362c <printStatus+0x356>
    362c:	ad b7       	in	r26, 0x3d	; 61
    362e:	be b7       	in	r27, 0x3e	; 62
    3630:	12 96       	adiw	r26, 0x02	; 2
    3632:	dc 93       	st	X, r29
    3634:	ce 93       	st	-X, r28
    3636:	11 97       	sbiw	r26, 0x01	; 1
    3638:	83 e1       	ldi	r24, 0x13	; 19
    363a:	93 e0       	ldi	r25, 0x03	; 3
    363c:	14 96       	adiw	r26, 0x04	; 4
    363e:	9c 93       	st	X, r25
    3640:	8e 93       	st	-X, r24
    3642:	13 97       	sbiw	r26, 0x03	; 3
    3644:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  tmp = printLockers(stream);
    3648:	0f 90       	pop	r0
    364a:	0f 90       	pop	r0
    364c:	0f 90       	pop	r0
    364e:	0f 90       	pop	r0
    3650:	ce 01       	movw	r24, r28
    3652:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <printLockers>
  if (tmp == 0)
    3656:	88 23       	and	r24, r24
    3658:	81 f4       	brne	.+32     	; 0x367a <printStatus+0x3a4>
    fprintf_P(stream, statusLockerSensorsDisStr);
    365a:	00 d0       	rcall	.+0      	; 0x365c <printStatus+0x386>
    365c:	00 d0       	rcall	.+0      	; 0x365e <printStatus+0x388>
    365e:	ed b7       	in	r30, 0x3d	; 61
    3660:	fe b7       	in	r31, 0x3e	; 62
    3662:	d2 83       	std	Z+2, r29	; 0x02
    3664:	c1 83       	std	Z+1, r28	; 0x01
    3666:	8c e2       	ldi	r24, 0x2C	; 44
    3668:	93 e0       	ldi	r25, 0x03	; 3
    366a:	94 83       	std	Z+4, r25	; 0x04
    366c:	83 83       	std	Z+3, r24	; 0x03
    366e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    3672:	0f 90       	pop	r0
    3674:	0f 90       	pop	r0
    3676:	0f 90       	pop	r0
    3678:	0f 90       	pop	r0
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    367a:	ce 01       	movw	r24, r28
    367c:	0e 94 ee 3d 	call	0x7bdc	; 0x7bdc <udpPrintStatus>
//  arpPrintTable(stream);
}
    3680:	df 91       	pop	r29
    3682:	cf 91       	pop	r28
    3684:	08 95       	ret

00003686 <statusFunction>:


// ************************** CLI Functions *********************************************************************************

static cliExRes_t statusFunction(cmdState_t *state)
{
    3686:	ef 92       	push	r14
    3688:	ff 92       	push	r15
    368a:	0f 93       	push	r16
    368c:	1f 93       	push	r17
    368e:	df 93       	push	r29
    3690:	cf 93       	push	r28
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
    3696:	2e 97       	sbiw	r28, 0x0e	; 14
    3698:	0f b6       	in	r0, 0x3f	; 63
    369a:	f8 94       	cli
    369c:	de bf       	out	0x3e, r29	; 62
    369e:	0f be       	out	0x3f, r0	; 63
    36a0:	cd bf       	out	0x3d, r28	; 61
    36a2:	7c 01       	movw	r14, r24
  if (state->argc < 1)
    36a4:	dc 01       	movw	r26, r24
    36a6:	59 96       	adiw	r26, 0x19	; 25
    36a8:	8c 91       	ld	r24, X
    36aa:	59 97       	sbiw	r26, 0x19	; 25
    36ac:	88 23       	and	r24, r24
    36ae:	39 f4       	brne	.+14     	; 0x36be <statusFunction+0x38>
  {
    printStatus(state->myStdInOut);
    36b0:	5a 96       	adiw	r26, 0x1a	; 26
    36b2:	8d 91       	ld	r24, X+
    36b4:	9c 91       	ld	r25, X
    36b6:	5b 97       	sbiw	r26, 0x1b	; 27
    36b8:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <printStatus>
    36bc:	3b c0       	rjmp	.+118    	; 0x3734 <statusFunction+0xae>
    return OK_SILENT; 
  }
  
  FILE stream;
  if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
    36be:	81 e0       	ldi	r24, 0x01	; 1
    36c0:	b7 01       	movw	r22, r14
    36c2:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    36c6:	69 e6       	ldi	r22, 0x69	; 105
    36c8:	7f e0       	ldi	r23, 0x0F	; 15
    36ca:	8e 01       	movw	r16, r28
    36cc:	0f 5f       	subi	r16, 0xFF	; 255
    36ce:	1f 4f       	sbci	r17, 0xFF	; 255
    36d0:	a8 01       	movw	r20, r16
    36d2:	23 e0       	ldi	r18, 0x03	; 3
    36d4:	0e 94 b8 21 	call	0x4370	; 0x4370 <ramDyskOtworzPlikStdIo>
    36d8:	88 23       	and	r24, r24
    36da:	31 f1       	breq	.+76     	; 0x3728 <statusFunction+0xa2>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    36dc:	f7 01       	movw	r30, r14
    36de:	02 8d       	ldd	r16, Z+26	; 0x1a
    36e0:	13 8d       	ldd	r17, Z+27	; 0x1b
    36e2:	81 e0       	ldi	r24, 0x01	; 1
    36e4:	b7 01       	movw	r22, r14
    36e6:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    36ea:	00 d0       	rcall	.+0      	; 0x36ec <statusFunction+0x66>
    36ec:	00 d0       	rcall	.+0      	; 0x36ee <statusFunction+0x68>
    36ee:	00 d0       	rcall	.+0      	; 0x36f0 <statusFunction+0x6a>
    36f0:	ed b7       	in	r30, 0x3d	; 61
    36f2:	fe b7       	in	r31, 0x3e	; 62
    36f4:	31 96       	adiw	r30, 0x01	; 1
    36f6:	ad b7       	in	r26, 0x3d	; 61
    36f8:	be b7       	in	r27, 0x3e	; 62
    36fa:	12 96       	adiw	r26, 0x02	; 2
    36fc:	1c 93       	st	X, r17
    36fe:	0e 93       	st	-X, r16
    3700:	11 97       	sbiw	r26, 0x01	; 1
    3702:	22 e8       	ldi	r18, 0x82	; 130
    3704:	31 e0       	ldi	r19, 0x01	; 1
    3706:	33 83       	std	Z+3, r19	; 0x03
    3708:	22 83       	std	Z+2, r18	; 0x02
    370a:	95 83       	std	Z+5, r25	; 0x05
    370c:	84 83       	std	Z+4, r24	; 0x04
    370e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    3712:	24 e0       	ldi	r18, 0x04	; 4
    3714:	30 e0       	ldi	r19, 0x00	; 0
    3716:	ed b7       	in	r30, 0x3d	; 61
    3718:	fe b7       	in	r31, 0x3e	; 62
    371a:	36 96       	adiw	r30, 0x06	; 6
    371c:	0f b6       	in	r0, 0x3f	; 63
    371e:	f8 94       	cli
    3720:	fe bf       	out	0x3e, r31	; 62
    3722:	0f be       	out	0x3f, r0	; 63
    3724:	ed bf       	out	0x3d, r30	; 61
    3726:	08 c0       	rjmp	.+16     	; 0x3738 <statusFunction+0xb2>
    return ERROR_INFORM;
  }

  printStatus(&stream);
    3728:	c8 01       	movw	r24, r16
    372a:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <printStatus>
  ramDyskZamknijPlikStdIo(&stream);
    372e:	c8 01       	movw	r24, r16
    3730:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <ramDyskZamknijPlikStdIo>
    3734:	20 e0       	ldi	r18, 0x00	; 0
    3736:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT; 
}
    3738:	c9 01       	movw	r24, r18
    373a:	2e 96       	adiw	r28, 0x0e	; 14
    373c:	0f b6       	in	r0, 0x3f	; 63
    373e:	f8 94       	cli
    3740:	de bf       	out	0x3e, r29	; 62
    3742:	0f be       	out	0x3f, r0	; 63
    3744:	cd bf       	out	0x3d, r28	; 61
    3746:	cf 91       	pop	r28
    3748:	df 91       	pop	r29
    374a:	1f 91       	pop	r17
    374c:	0f 91       	pop	r16
    374e:	ff 90       	pop	r15
    3750:	ef 90       	pop	r14
    3752:	08 95       	ret

00003754 <VtyInit>:
  {cmd_disable,      cmd_help_disable,      disableFunction},
  {NULL, NULL, NULL}
};

void VtyInit(cmdState_t* state, FILE *stream)
{
    3754:	ef 92       	push	r14
    3756:	0f 93       	push	r16
    3758:	1f 93       	push	r17
    375a:	9b 01       	movw	r18, r22
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
    375c:	60 e0       	ldi	r22, 0x00	; 0
    375e:	78 e2       	ldi	r23, 0x28	; 40
    3760:	40 e0       	ldi	r20, 0x00	; 0
    3762:	51 e0       	ldi	r21, 0x01	; 1
    3764:	0a e4       	ldi	r16, 0x4A	; 74
    3766:	19 e0       	ldi	r17, 0x09	; 9
    3768:	ee 24       	eor	r14, r14
    376a:	0e 94 8c 24 	call	0x4918	; 0x4918 <cmdStateConfigure>
}
    376e:	1f 91       	pop	r17
    3770:	0f 91       	pop	r16
    3772:	ef 90       	pop	r14
    3774:	08 95       	ret

00003776 <encTask>:
//   return 0;
// }


void encTask ( void *pvParameters )
{
    3776:	cf 92       	push	r12
    3778:	df 92       	push	r13
    377a:	ef 92       	push	r14
    377c:	ff 92       	push	r15
    377e:	0f 93       	push	r16
    3780:	1f 93       	push	r17
    3782:	cf 93       	push	r28
    3784:	df 93       	push	r29
  FILE *netstackDebug = (FILE *) pvParameters;
    3786:	ec 01       	movw	r28, r24
  uint16_t plen;
  #ifdef DEBUG_PRINT_NET_PACKET
  uint16_t packetNo = 0;
  #endif /*DEBUG_PRINT_NET_PACKET*/

  nicInit();
    3788:	0e 94 56 2e 	call	0x5cac	; 0x5cac <nicInit>
  ipInit();
    378c:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <ipInit>
  arpInit();
    3790:	0e 94 4b 3a 	call	0x7496	; 0x7496 <arpInit>
  icmpInit();
    3794:	0e 94 40 35 	call	0x6a80	; 0x6a80 <icmpInit>
  #ifdef IP_DEBUG
    #if IPV6_SUPPORT
    ipv6DebugInit(netstackDebug);
    3798:	ce 01       	movw	r24, r28
    379a:	0e 94 71 40 	call	0x80e2	; 0x80e2 <ipv6DebugInit>
    #endif /*IPV6_SUPPORT*/
  fprintf_P(netstackDebug, PSTR("IP stack ready \r\n"));
    379e:	00 d0       	rcall	.+0      	; 0x37a0 <encTask+0x2a>
    37a0:	00 d0       	rcall	.+0      	; 0x37a2 <encTask+0x2c>
    37a2:	ed b7       	in	r30, 0x3d	; 61
    37a4:	fe b7       	in	r31, 0x3e	; 62
    37a6:	d2 83       	std	Z+2, r29	; 0x02
    37a8:	c1 83       	std	Z+1, r28	; 0x01
    37aa:	88 e5       	ldi	r24, 0x58	; 88
    37ac:	9b e0       	ldi	r25, 0x0B	; 11
    37ae:	94 83       	std	Z+4, r25	; 0x04
    37b0:	83 83       	std	Z+3, r24	; 0x03
    37b2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  #endif /*IP_DEBUG*/
  #if IPV6_SUPPORT
  ipv6Init();
    37b6:	0f 90       	pop	r0
    37b8:	0f 90       	pop	r0
    37ba:	0f 90       	pop	r0
    37bc:	0f 90       	pop	r0
    37be:	0e 94 c0 42 	call	0x8580	; 0x8580 <ipv6Init>
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
      }
    }
    
    #ifdef IP_DEBUG
    fprintf_P(netstackDebug, PSTR("==============================\r\n"));
    37c2:	96 e2       	ldi	r25, 0x26	; 38
    37c4:	c9 2e       	mov	r12, r25
    37c6:	9b e0       	ldi	r25, 0x0B	; 11
    37c8:	d9 2e       	mov	r13, r25
    #endif /*IPV6_SUPPORT*/
    else
    {
      if (netstackDebug != NULL)
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    37ca:	87 e4       	ldi	r24, 0x47	; 71
    37cc:	e8 2e       	mov	r14, r24
    37ce:	8b e0       	ldi	r24, 0x0B	; 11
    37d0:	f8 2e       	mov	r15, r24
  //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);
  
  
  for ( ; ; )
  {
    vTaskDelay ( 0 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwolniony po odebrzeniu przerwania od ENC
    37d2:	80 e0       	ldi	r24, 0x00	; 0
    37d4:	90 e0       	ldi	r25, 0x00	; 0
    37d6:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
        
    // get the next new packet:
    plen = nicPoll();
    37da:	0e 94 07 2c 	call	0x580e	; 0x580e <nicPoll>
    /*plen will ne unequal to zero if there is a valid
    * packet (without crc error) */
    if ( plen==0 )
    37de:	89 2b       	or	r24, r25
    37e0:	29 f4       	brne	.+10     	; 0x37ec <encTask+0x76>
    {
      flushUdpQueues();
    37e2:	0e 94 01 40 	call	0x8002	; 0x8002 <flushUdpQueues>
      flushTcpQueues();
    37e6:	0e 94 2c 3b 	call	0x7658	; 0x7658 <flushTcpQueues>
    37ea:	f3 cf       	rjmp	.-26     	; 0x37d2 <encTask+0x5c>
      fprintf_P(netstackDebug, PSTR("%02x:"), nicState.layer2.buf[i]);
    }
    fprintf_P(netstackDebug, PSTR("\r\n"));    
    #endif /*DEBUG_PRINT_NET_PACKET*/
    
    if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
    37ec:	e0 91 86 0e 	lds	r30, 0x0E86
    37f0:	f0 91 87 0e 	lds	r31, 0x0E87
    37f4:	04 85       	ldd	r16, Z+12	; 0x0c
    37f6:	15 85       	ldd	r17, Z+13	; 0x0d
    37f8:	80 e0       	ldi	r24, 0x00	; 0
    37fa:	98 e0       	ldi	r25, 0x08	; 8
    37fc:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    3800:	08 17       	cp	r16, r24
    3802:	19 07       	cpc	r17, r25
    3804:	29 f4       	brne	.+10     	; 0x3810 <encTask+0x9a>
    {
      arpIpIn();
    3806:	0e 94 00 38 	call	0x7000	; 0x7000 <arpIpIn>
      netstackIPv4Process();
    380a:	0e 94 29 34 	call	0x6852	; 0x6852 <netstackIPv4Process>
    380e:	30 c0       	rjmp	.+96     	; 0x3870 <encTask+0xfa>
    }
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
    3810:	e0 91 86 0e 	lds	r30, 0x0E86
    3814:	f0 91 87 0e 	lds	r31, 0x0E87
    3818:	04 85       	ldd	r16, Z+12	; 0x0c
    381a:	15 85       	ldd	r17, Z+13	; 0x0d
    381c:	86 e0       	ldi	r24, 0x06	; 6
    381e:	98 e0       	ldi	r25, 0x08	; 8
    3820:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    3824:	08 17       	cp	r16, r24
    3826:	19 07       	cpc	r17, r25
    3828:	19 f4       	brne	.+6      	; 0x3830 <encTask+0xba>
    {
      arpArpIn();
    382a:	0e 94 57 3a 	call	0x74ae	; 0x74ae <arpArpIn>
    382e:	20 c0       	rjmp	.+64     	; 0x3870 <encTask+0xfa>
    }
    #if IPV6_SUPPORT
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP6))       // process an ARP packet
    3830:	e0 91 86 0e 	lds	r30, 0x0E86
    3834:	f0 91 87 0e 	lds	r31, 0x0E87
    3838:	04 85       	ldd	r16, Z+12	; 0x0c
    383a:	15 85       	ldd	r17, Z+13	; 0x0d
    383c:	8d ed       	ldi	r24, 0xDD	; 221
    383e:	96 e8       	ldi	r25, 0x86	; 134
    3840:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    3844:	08 17       	cp	r16, r24
    3846:	19 07       	cpc	r17, r25
    3848:	19 f4       	brne	.+6      	; 0x3850 <encTask+0xda>
    {
      netstackIPv6Process();
    384a:	0e 94 a5 42 	call	0x854a	; 0x854a <netstackIPv6Process>
    384e:	10 c0       	rjmp	.+32     	; 0x3870 <encTask+0xfa>
    }
    #endif /*IPV6_SUPPORT*/
    else
    {
      if (netstackDebug != NULL)
    3850:	20 97       	sbiw	r28, 0x00	; 0
    3852:	71 f0       	breq	.+28     	; 0x3870 <encTask+0xfa>
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    3854:	00 d0       	rcall	.+0      	; 0x3856 <encTask+0xe0>
    3856:	00 d0       	rcall	.+0      	; 0x3858 <encTask+0xe2>
    3858:	ed b7       	in	r30, 0x3d	; 61
    385a:	fe b7       	in	r31, 0x3e	; 62
    385c:	d2 83       	std	Z+2, r29	; 0x02
    385e:	c1 83       	std	Z+1, r28	; 0x01
    3860:	f4 82       	std	Z+4, r15	; 0x04
    3862:	e3 82       	std	Z+3, r14	; 0x03
    3864:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    3868:	0f 90       	pop	r0
    386a:	0f 90       	pop	r0
    386c:	0f 90       	pop	r0
    386e:	0f 90       	pop	r0
      }
    }
    
    #ifdef IP_DEBUG
    fprintf_P(netstackDebug, PSTR("==============================\r\n"));
    3870:	00 d0       	rcall	.+0      	; 0x3872 <encTask+0xfc>
    3872:	00 d0       	rcall	.+0      	; 0x3874 <encTask+0xfe>
    3874:	ed b7       	in	r30, 0x3d	; 61
    3876:	fe b7       	in	r31, 0x3e	; 62
    3878:	d2 83       	std	Z+2, r29	; 0x02
    387a:	c1 83       	std	Z+1, r28	; 0x01
    387c:	d4 82       	std	Z+4, r13	; 0x04
    387e:	c3 82       	std	Z+3, r12	; 0x03
    3880:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    3884:	0f 90       	pop	r0
    3886:	0f 90       	pop	r0
    3888:	0f 90       	pop	r0
    388a:	0f 90       	pop	r0
    388c:	a2 cf       	rjmp	.-188    	; 0x37d2 <encTask+0x5c>

0000388e <vTaskVTYsocket>:
    }  
  }
}

void vTaskVTYsocket(void *cliStatePtr)
{
    388e:	cf 93       	push	r28
    3890:	df 93       	push	r29
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    3892:	ec 01       	movw	r28, r24
  
  char znak;
  for( ;; )
  {
    znak = 0;
    znak = fgetc(state->myStdInOut);
    3894:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3896:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3898:	0e 94 c0 5c 	call	0xb980	; 0xb980 <fgetc>
    cmdlineInputFunc((char)znak, state);
    389c:	be 01       	movw	r22, r28
    389e:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <cmdlineInputFunc>
    cmdlineMainLoop(state);
    38a2:	ce 01       	movw	r24, r28
    38a4:	0e 94 50 23 	call	0x46a0	; 0x46a0 <cmdlineMainLoop>
    38a8:	f5 cf       	rjmp	.-22     	; 0x3894 <vTaskVTYsocket+0x6>

000038aa <vTaskVTYusb>:
#include "cli_task.h"

void vTaskVTYusb(void *cliStatePtr)
{
    38aa:	ef 92       	push	r14
    38ac:	ff 92       	push	r15
    38ae:	0f 93       	push	r16
    38b0:	1f 93       	push	r17
    38b2:	df 93       	push	r29
    38b4:	cf 93       	push	r28
    38b6:	0f 92       	push	r0
    38b8:	cd b7       	in	r28, 0x3d	; 61
    38ba:	de b7       	in	r29, 0x3e	; 62
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    38bc:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Restart\r\n"));
    38be:	00 d0       	rcall	.+0      	; 0x38c0 <vTaskVTYusb+0x16>
    38c0:	00 d0       	rcall	.+0      	; 0x38c2 <vTaskVTYusb+0x18>
    38c2:	fc 01       	movw	r30, r24
    38c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    38c6:	93 8d       	ldd	r25, Z+27	; 0x1b
    38c8:	ed b7       	in	r30, 0x3d	; 61
    38ca:	fe b7       	in	r31, 0x3e	; 62
    38cc:	92 83       	std	Z+2, r25	; 0x02
    38ce:	81 83       	std	Z+1, r24	; 0x01
    38d0:	8a e6       	ldi	r24, 0x6A	; 106
    38d2:	9b e0       	ldi	r25, 0x0B	; 11
    38d4:	94 83       	std	Z+4, r25	; 0x04
    38d6:	83 83       	std	Z+3, r24	; 0x03
    38d8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  cmdlineInputFunc('\r', state);
    38dc:	0f 90       	pop	r0
    38de:	0f 90       	pop	r0
    38e0:	0f 90       	pop	r0
    38e2:	0f 90       	pop	r0
    38e4:	8d e0       	ldi	r24, 0x0D	; 13
    38e6:	b8 01       	movw	r22, r16
    38e8:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <cmdlineInputFunc>
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    38ec:	7e 01       	movw	r14, r28
    38ee:	08 94       	sec
    38f0:	e1 1c       	adc	r14, r1
    38f2:	f1 1c       	adc	r15, r1
    38f4:	80 91 ad 0e 	lds	r24, 0x0EAD
    38f8:	90 91 ae 0e 	lds	r25, 0x0EAE
    38fc:	b7 01       	movw	r22, r14
    38fe:	4f ef       	ldi	r20, 0xFF	; 255
    3900:	5f ef       	ldi	r21, 0xFF	; 255
    3902:	20 e0       	ldi	r18, 0x00	; 0
    3904:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    3908:	88 23       	and	r24, r24
    390a:	a1 f3       	breq	.-24     	; 0x38f4 <vTaskVTYusb+0x4a>
    {
      cmdlineInputFunc((char)znak, state);
    390c:	89 81       	ldd	r24, Y+1	; 0x01
    390e:	b8 01       	movw	r22, r16
    3910:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <cmdlineInputFunc>
      cmdlineMainLoop(state);
    3914:	c8 01       	movw	r24, r16
    3916:	0e 94 50 23 	call	0x46a0	; 0x46a0 <cmdlineMainLoop>
    391a:	ec cf       	rjmp	.-40     	; 0x38f4 <vTaskVTYusb+0x4a>

0000391c <spiSetCPHA>:
  //mode 0,0
}

void spiSetCPHA(void)
{
  SPCR |= (1<<CPHA);
    391c:	6a 9a       	sbi	0x0d, 2	; 13
}
    391e:	08 95       	ret

00003920 <spiClearCPHA>:

void spiClearCPHA(void)
{
  SPCR &= ~(1<<CPHA);
    3920:	6a 98       	cbi	0x0d, 2	; 13
}
    3922:	08 95       	ret

00003924 <spiSetCPOL>:

void spiSetCPOL(void)
{
  SPCR |= (1<<CPOL);
    3924:	6b 9a       	sbi	0x0d, 3	; 13
}
    3926:	08 95       	ret

00003928 <spiClearCPOL>:

void spiClearCPOL(void)
{
  SPCR &= ~(1<<CPOL);
    3928:	6b 98       	cbi	0x0d, 3	; 13
}
    392a:	08 95       	ret
    392c:	80 e0       	ldi	r24, 0x00	; 0
    392e:	08 95       	ret
    3930:	80 e0       	ldi	r24, 0x00	; 0
    3932:	08 95       	ret

00003934 <spiGive>:
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
}

void spiGive(void)
{
  xSemaphoreGive(xSemaphoreSpiSS);
    3934:	80 91 c3 0e 	lds	r24, 0x0EC3
    3938:	90 91 c4 0e 	lds	r25, 0x0EC4
    393c:	60 e0       	ldi	r22, 0x00	; 0
    393e:	70 e0       	ldi	r23, 0x00	; 0
    3940:	40 e0       	ldi	r20, 0x00	; 0
    3942:	50 e0       	ldi	r21, 0x00	; 0
    3944:	20 e0       	ldi	r18, 0x00	; 0
    3946:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>
}
    394a:	08 95       	ret

0000394c <spiTake>:
  SPCR &= ~(1<<CPOL);
}

void spiTake(void)
{
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
    394c:	80 91 c3 0e 	lds	r24, 0x0EC3
    3950:	90 91 c4 0e 	lds	r25, 0x0EC4
    3954:	60 e0       	ldi	r22, 0x00	; 0
    3956:	70 e0       	ldi	r23, 0x00	; 0
    3958:	4f ef       	ldi	r20, 0xFF	; 255
    395a:	5f ef       	ldi	r21, 0xFF	; 255
    395c:	20 e0       	ldi	r18, 0x00	; 0
    395e:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
}
    3962:	08 95       	ret

00003964 <spiInit>:
#include "semphr.h"


void spiInit(void (*disableAllSpiDevicesFun)(void))
{
  disableAllSpiDevicesFun();
    3964:	fc 01       	movw	r30, r24
    3966:	09 95       	icall
  portENTER_CRITICAL();
    3968:	0f b6       	in	r0, 0x3f	; 63
    396a:	f8 94       	cli
    396c:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    396e:	81 e0       	ldi	r24, 0x01	; 1
    3970:	60 e0       	ldi	r22, 0x00	; 0
    3972:	0e 94 98 55 	call	0xab30	; 0xab30 <xQueueCreate>
    3976:	90 93 c4 0e 	sts	0x0EC4, r25
    397a:	80 93 c3 0e 	sts	0x0EC3, r24
    397e:	00 97       	sbiw	r24, 0x00	; 0
    3980:	39 f0       	breq	.+14     	; 0x3990 <spiInit+0x2c>
    3982:	60 e0       	ldi	r22, 0x00	; 0
    3984:	70 e0       	ldi	r23, 0x00	; 0
    3986:	40 e0       	ldi	r20, 0x00	; 0
    3988:	50 e0       	ldi	r21, 0x00	; 0
    398a:	20 e0       	ldi	r18, 0x00	; 0
    398c:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>

  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPIE);
    3990:	80 ed       	ldi	r24, 0xD0	; 208
    3992:	8d b9       	out	0x0d, r24	; 13
  //SPCR = (1<<SPE)|(1<<MSTR);
  SPSR |= (1<<SPI2X);
    3994:	70 9a       	sbi	0x0e, 0	; 14
  portEXIT_CRITICAL();
    3996:	0f 90       	pop	r0
    3998:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    399a:	08 95       	ret

0000399c <xmallocAvailable>:
  
  return result;
}

size_t xmallocAvailable(void)
{
    399c:	20 91 86 01 	lds	r18, 0x0186
    39a0:	30 91 87 01 	lds	r19, 0x0187
    39a4:	2f 5f       	subi	r18, 0xFF	; 255
    39a6:	3f 4f       	sbci	r19, 0xFF	; 255
    39a8:	80 91 02 01 	lds	r24, 0x0102
    39ac:	90 91 03 01 	lds	r25, 0x0103
    39b0:	28 1b       	sub	r18, r24
    39b2:	39 0b       	sbc	r19, r25
  return __malloc_heap_end - heapEnd + 1;
    39b4:	c9 01       	movw	r24, r18
    39b6:	08 95       	ret

000039b8 <xmalloc>:
#include "hardwareConfig.h"

char *heapEnd = HEAP_BEGIN;

void *xmalloc(size_t size)
{
    39b8:	0f 93       	push	r16
    39ba:	1f 93       	push	r17
    39bc:	8c 01       	movw	r16, r24
  void *result = malloc(size);
    39be:	0e 94 03 5a 	call	0xb406	; 0xb406 <malloc>
  
  heapEnd = (char *)(result);
  heapEnd += size;
    39c2:	08 0f       	add	r16, r24
    39c4:	19 1f       	adc	r17, r25
    39c6:	10 93 03 01 	sts	0x0103, r17
    39ca:	00 93 02 01 	sts	0x0102, r16
  
  return result;
}
    39ce:	1f 91       	pop	r17
    39d0:	0f 91       	pop	r16
    39d2:	08 95       	ret

000039d4 <ramDyskLiczbaWolnychKlastrow>:
  }
  while (tmpKlaster != tmpKlaster2);
}

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
    39d4:	ed e4       	ldi	r30, 0x4D	; 77
    39d6:	ff e0       	ldi	r31, 0x0F	; 15
    39d8:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    if (klastry[temp] == 0)
    39da:	80 81       	ld	r24, Z
    39dc:	88 23       	and	r24, r24
    39de:	09 f4       	brne	.+2      	; 0x39e2 <ramDyskLiczbaWolnychKlastrow+0xe>
      wynik++;
    39e0:	9f 5f       	subi	r25, 0xFF	; 255
    39e2:	31 97       	sbiw	r30, 0x01	; 1

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    39e4:	8e e0       	ldi	r24, 0x0E	; 14
    39e6:	ee 3c       	cpi	r30, 0xCE	; 206
    39e8:	f8 07       	cpc	r31, r24
    39ea:	b9 f7       	brne	.-18     	; 0x39da <ramDyskLiczbaWolnychKlastrow+0x6>
    if (klastry[temp] == 0)
      wynik++;
  return wynik;
}
    39ec:	89 2f       	mov	r24, r25
    39ee:	08 95       	ret

000039f0 <ramDyskDir>:
  }
  return wynik;
}

void ramDyskDir(FILE *ostream)
{
    39f0:	2f 92       	push	r2
    39f2:	3f 92       	push	r3
    39f4:	4f 92       	push	r4
    39f6:	5f 92       	push	r5
    39f8:	7f 92       	push	r7
    39fa:	8f 92       	push	r8
    39fc:	9f 92       	push	r9
    39fe:	af 92       	push	r10
    3a00:	bf 92       	push	r11
    3a02:	cf 92       	push	r12
    3a04:	df 92       	push	r13
    3a06:	ef 92       	push	r14
    3a08:	ff 92       	push	r15
    3a0a:	0f 93       	push	r16
    3a0c:	1f 93       	push	r17
    3a0e:	cf 93       	push	r28
    3a10:	df 93       	push	r29
    3a12:	4c 01       	movw	r8, r24
  fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
    3a14:	84 e0       	ldi	r24, 0x04	; 4
    3a16:	91 e0       	ldi	r25, 0x01	; 1
    3a18:	b4 01       	movw	r22, r8
    3a1a:	0e 94 5d 5d 	call	0xbaba	; 0xbaba <fputs>
    3a1e:	77 24       	eor	r7, r7
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    3a20:	2d e1       	ldi	r18, 0x1D	; 29
    3a22:	22 2e       	mov	r2, r18
    3a24:	21 e0       	ldi	r18, 0x01	; 1
    3a26:	32 2e       	mov	r3, r18
  uint8_t tmpKlaster = 0;
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    3a28:	e7 2c       	mov	r14, r7
    3a2a:	ff 24       	eor	r15, r15
    3a2c:	20 e8       	ldi	r18, 0x80	; 128
    3a2e:	30 e0       	ldi	r19, 0x00	; 0
    3a30:	e2 0e       	add	r14, r18
    3a32:	f3 1e       	adc	r15, r19
    3a34:	de 2d       	mov	r29, r14
    3a36:	cc 27       	eor	r28, r28
    3a38:	80 e8       	ldi	r24, 0x80	; 128
    3a3a:	9f ef       	ldi	r25, 0xFF	; 255
    3a3c:	e8 0e       	add	r14, r24
    3a3e:	f9 1e       	adc	r15, r25
    for (tmp=0; tmp<16; tmp++)
    3a40:	80 ef       	ldi	r24, 0xF0	; 240
    3a42:	48 2e       	mov	r4, r24
    3a44:	51 2c       	mov	r5, r1
    3a46:	4c 0e       	add	r4, r28
    3a48:	5d 1e       	adc	r5, r29
    {
      tmp3=plik->nazwa[0];
    3a4a:	1c 81       	ldd	r17, Y+4	; 0x04
      if (tmp3 == 0)
    3a4c:	11 23       	and	r17, r17
    3a4e:	09 f4       	brne	.+2      	; 0x3a52 <ramDyskDir+0x62>
    3a50:	4b c0       	rjmp	.+150    	; 0x3ae8 <ramDyskDir+0xf8>
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
    3a52:	81 2f       	mov	r24, r17
    3a54:	90 e0       	ldi	r25, 0x00	; 0
    3a56:	b4 01       	movw	r22, r8
    3a58:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    3a5c:	6e 01       	movw	r12, r28
    3a5e:	01 e0       	ldi	r16, 0x01	; 1
      for (tmp2=1; tmp2<8; tmp2++)
      {
        if (tmp3 != 0)
    3a60:	11 23       	and	r17, r17
    3a62:	59 f0       	breq	.+22     	; 0x3a7a <ramDyskDir+0x8a>
          tmp3=plik->nazwa[tmp2];
    3a64:	d6 01       	movw	r26, r12
    3a66:	15 96       	adiw	r26, 0x05	; 5
    3a68:	1c 91       	ld	r17, X

        if (tmp3 != 0)
    3a6a:	11 23       	and	r17, r17
    3a6c:	31 f0       	breq	.+12     	; 0x3a7a <ramDyskDir+0x8a>
          fputc(tmp3     , ostream);
    3a6e:	81 2f       	mov	r24, r17
    3a70:	90 e0       	ldi	r25, 0x00	; 0
    3a72:	b4 01       	movw	r22, r8
    3a74:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    3a78:	06 c0       	rjmp	.+12     	; 0x3a86 <ramDyskDir+0x96>
        else
          fputc(' '      , ostream);
    3a7a:	80 e2       	ldi	r24, 0x20	; 32
    3a7c:	90 e0       	ldi	r25, 0x00	; 0
    3a7e:	b4 01       	movw	r22, r8
    3a80:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    3a84:	10 e0       	ldi	r17, 0x00	; 0
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
    3a86:	0f 5f       	subi	r16, 0xFF	; 255
    3a88:	08 94       	sec
    3a8a:	c1 1c       	adc	r12, r1
    3a8c:	d1 1c       	adc	r13, r1
    3a8e:	08 30       	cpi	r16, 0x08	; 8
    3a90:	39 f7       	brne	.-50     	; 0x3a60 <ramDyskDir+0x70>
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    3a92:	ed b7       	in	r30, 0x3d	; 61
    3a94:	fe b7       	in	r31, 0x3e	; 62
    3a96:	38 97       	sbiw	r30, 0x08	; 8
    3a98:	0f b6       	in	r0, 0x3f	; 63
    3a9a:	f8 94       	cli
    3a9c:	fe bf       	out	0x3e, r31	; 62
    3a9e:	0f be       	out	0x3f, r0	; 63
    3aa0:	ed bf       	out	0x3d, r30	; 61
    3aa2:	31 96       	adiw	r30, 0x01	; 1
    3aa4:	ad b7       	in	r26, 0x3d	; 61
    3aa6:	be b7       	in	r27, 0x3e	; 62
    3aa8:	12 96       	adiw	r26, 0x02	; 2
    3aaa:	9c 92       	st	X, r9
    3aac:	8e 92       	st	-X, r8
    3aae:	11 97       	sbiw	r26, 0x01	; 1
    3ab0:	33 82       	std	Z+3, r3	; 0x03
    3ab2:	22 82       	std	Z+2, r2	; 0x02
    3ab4:	ba 80       	ldd	r11, Y+2	; 0x02
    3ab6:	aa 24       	eor	r10, r10
    3ab8:	89 81       	ldd	r24, Y+1	; 0x01
    3aba:	95 01       	movw	r18, r10
    3abc:	28 0f       	add	r18, r24
    3abe:	31 1d       	adc	r19, r1
    3ac0:	35 83       	std	Z+5, r19	; 0x05
    3ac2:	24 83       	std	Z+4, r18	; 0x04
    3ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac6:	86 83       	std	Z+6, r24	; 0x06
    3ac8:	17 82       	std	Z+7, r1	; 0x07
    3aca:	0e 94 02 5d 	call	0xba04	; 0xba04 <fprintf>
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    3ace:	8d b7       	in	r24, 0x3d	; 61
    3ad0:	9e b7       	in	r25, 0x3e	; 62
    3ad2:	08 96       	adiw	r24, 0x08	; 8
    3ad4:	0f b6       	in	r0, 0x3f	; 63
    3ad6:	f8 94       	cli
    3ad8:	9e bf       	out	0x3e, r25	; 62
    3ada:	0f be       	out	0x3f, r0	; 63
    3adc:	8d bf       	out	0x3d, r24	; 61
    3ade:	c4 15       	cp	r28, r4
    3ae0:	d5 05       	cpc	r29, r5
    3ae2:	11 f0       	breq	.+4      	; 0x3ae8 <ramDyskDir+0xf8>
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
      plik++;
    3ae4:	60 96       	adiw	r28, 0x10	; 16
    3ae6:	b1 cf       	rjmp	.-158    	; 0x3a4a <ramDyskDir+0x5a>
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    3ae8:	ae ec       	ldi	r26, 0xCE	; 206
    3aea:	be e0       	ldi	r27, 0x0E	; 14
    3aec:	ea 0e       	add	r14, r26
    3aee:	fb 1e       	adc	r15, r27
    3af0:	f7 01       	movw	r30, r14
    3af2:	80 81       	ld	r24, Z
  }
  while (tmpKlaster != tmpKlaster2);
    3af4:	87 15       	cp	r24, r7
    3af6:	11 f0       	breq	.+4      	; 0x3afc <ramDyskDir+0x10c>
    3af8:	78 2e       	mov	r7, r24
    3afa:	96 cf       	rjmp	.-212    	; 0x3a28 <ramDyskDir+0x38>
}
    3afc:	df 91       	pop	r29
    3afe:	cf 91       	pop	r28
    3b00:	1f 91       	pop	r17
    3b02:	0f 91       	pop	r16
    3b04:	ff 90       	pop	r15
    3b06:	ef 90       	pop	r14
    3b08:	df 90       	pop	r13
    3b0a:	cf 90       	pop	r12
    3b0c:	bf 90       	pop	r11
    3b0e:	af 90       	pop	r10
    3b10:	9f 90       	pop	r9
    3b12:	8f 90       	pop	r8
    3b14:	7f 90       	pop	r7
    3b16:	5f 90       	pop	r5
    3b18:	4f 90       	pop	r4
    3b1a:	3f 90       	pop	r3
    3b1c:	2f 90       	pop	r2
    3b1e:	08 95       	ret

00003b20 <znajdzWolnyKlaster>:
      fd->wpis->rozmiarHi = fd->IndHi;    
  }
}

static uint8_t znajdzWolnyKlaster(void)
{
    3b20:	21 e0       	ldi	r18, 0x01	; 1
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
  {                                        //Może być rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    3b22:	42 2f       	mov	r20, r18
    3b24:	50 e0       	ldi	r21, 0x00	; 0
    3b26:	fa 01       	movw	r30, r20
    3b28:	e2 53       	subi	r30, 0x32	; 50
    3b2a:	f1 4f       	sbci	r31, 0xF1	; 241
    3b2c:	80 81       	ld	r24, Z
    3b2e:	88 23       	and	r24, r24
    3b30:	69 f4       	brne	.+26     	; 0x3b4c <znajdzWolnyKlaster+0x2c>
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
    3b32:	20 83       	st	Z, r18
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    3b34:	e0 e0       	ldi	r30, 0x00	; 0
    3b36:	f2 2f       	mov	r31, r18
    3b38:	f0 58       	subi	r31, 0x80	; 128
    3b3a:	80 e0       	ldi	r24, 0x00	; 0
    3b3c:	91 e0       	ldi	r25, 0x01	; 1
    3b3e:	df 01       	movw	r26, r30
    3b40:	ac 01       	movw	r20, r24
    3b42:	1d 92       	st	X+, r1
    3b44:	41 50       	subi	r20, 0x01	; 1
    3b46:	50 40       	sbci	r21, 0x00	; 0
    3b48:	e1 f7       	brne	.-8      	; 0x3b42 <znajdzWolnyKlaster+0x22>
    3b4a:	04 c0       	rjmp	.+8      	; 0x3b54 <znajdzWolnyKlaster+0x34>
}

static uint8_t znajdzWolnyKlaster(void)
{
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    3b4c:	2f 5f       	subi	r18, 0xFF	; 255
    3b4e:	20 38       	cpi	r18, 0x80	; 128
    3b50:	41 f7       	brne	.-48     	; 0x3b22 <znajdzWolnyKlaster+0x2>
    3b52:	20 e0       	ldi	r18, 0x00	; 0
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
      return i;
    }
  }
  return 0;
}
    3b54:	82 2f       	mov	r24, r18
    3b56:	08 95       	ret

00003b58 <nastepnyKlaster>:

static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
    3b58:	a8 2f       	mov	r26, r24
    3b5a:	b0 e0       	ldi	r27, 0x00	; 0
    3b5c:	fd 01       	movw	r30, r26
    3b5e:	e2 53       	subi	r30, 0x32	; 50
    3b60:	f1 4f       	sbci	r31, 0xF1	; 241
    3b62:	20 81       	ld	r18, Z
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
    3b64:	28 17       	cp	r18, r24
    3b66:	f9 f4       	brne	.+62     	; 0x3ba6 <nastepnyKlaster+0x4e>
    3b68:	21 e0       	ldi	r18, 0x01	; 1
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma wolnego klastra
      if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, że jest on pusty
    3b6a:	e2 2f       	mov	r30, r18
    3b6c:	f0 e0       	ldi	r31, 0x00	; 0
    3b6e:	e2 53       	subi	r30, 0x32	; 50
    3b70:	f1 4f       	sbci	r31, 0xF1	; 241
    3b72:	80 81       	ld	r24, Z
    3b74:	88 23       	and	r24, r24
    3b76:	19 f0       	breq	.+6      	; 0x3b7e <nastepnyKlaster+0x26>
static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    3b78:	2f 5f       	subi	r18, 0xFF	; 255
    3b7a:	20 38       	cpi	r18, 0x80	; 128
    3b7c:	b1 f7       	brne	.-20     	; 0x3b6a <nastepnyKlaster+0x12>
        break;                             //Wtedy można przerwać szukanie kolejnych klastrów dla klastra
    }                                      //Taka implementacja z założenia powoduje defragmentację.
    
    if (temp != 0)                         //Znaleziono jakiś wolny klaster
    {
      klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku kolejnego klastra
    3b7e:	a2 53       	subi	r26, 0x32	; 50
    3b80:	b1 4f       	sbci	r27, 0xF1	; 241
    3b82:	2c 93       	st	X, r18
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
    3b84:	82 2f       	mov	r24, r18
    3b86:	90 e0       	ldi	r25, 0x00	; 0
    3b88:	fc 01       	movw	r30, r24
    3b8a:	e2 53       	subi	r30, 0x32	; 50
    3b8c:	f1 4f       	sbci	r31, 0xF1	; 241
    3b8e:	20 83       	st	Z, r18
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    3b90:	e0 e0       	ldi	r30, 0x00	; 0
    3b92:	f2 2f       	mov	r31, r18
    3b94:	f0 58       	subi	r31, 0x80	; 128
    3b96:	80 e0       	ldi	r24, 0x00	; 0
    3b98:	91 e0       	ldi	r25, 0x01	; 1
    3b9a:	df 01       	movw	r26, r30
    3b9c:	ac 01       	movw	r20, r24
    3b9e:	1d 92       	st	X+, r1
    3ba0:	41 50       	subi	r20, 0x01	; 1
    3ba2:	50 40       	sbci	r21, 0x00	; 0
    3ba4:	e1 f7       	brne	.-8      	; 0x3b9e <nastepnyKlaster+0x46>
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
      czyscKlaster(temp);                  //Czyszczenie klastra
    }
  }
  return temp;
}
    3ba6:	82 2f       	mov	r24, r18
    3ba8:	08 95       	ret

00003baa <znajdzKlasterN>:

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
    3baa:	0f 93       	push	r16
    3bac:	1f 93       	push	r17
    3bae:	06 2f       	mov	r16, r22
    3bb0:	10 e0       	ldi	r17, 0x00	; 0
    3bb2:	05 c0       	rjmp	.+10     	; 0x3bbe <znajdzKlasterN+0x14>
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
  {
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    3bb4:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <nastepnyKlaster>
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
    3bb8:	88 23       	and	r24, r24
    3bba:	19 f0       	breq	.+6      	; 0x3bc2 <znajdzKlasterN+0x18>

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3bbc:	1f 5f       	subi	r17, 0xFF	; 255
    3bbe:	10 17       	cp	r17, r16
    3bc0:	c8 f3       	brcs	.-14     	; 0x3bb4 <znajdzKlasterN+0xa>
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
      break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany na początek tablicy plików
  }
  return wynik;
}
    3bc2:	1f 91       	pop	r17
    3bc4:	0f 91       	pop	r16
    3bc6:	08 95       	ret

00003bc8 <ramDyskDodajBlokXmodem>:
  }  
  return 0;
}

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
    3bc8:	cf 92       	push	r12
    3bca:	df 92       	push	r13
    3bcc:	ef 92       	push	r14
    3bce:	ff 92       	push	r15
    3bd0:	1f 93       	push	r17
    3bd2:	cf 93       	push	r28
    3bd4:	df 93       	push	r29
    3bd6:	7c 01       	movw	r14, r24
    3bd8:	6b 01       	movw	r12, r22
  if (nrBloku == 0)
    3bda:	61 15       	cp	r22, r1
    3bdc:	71 05       	cpc	r23, r1
    3bde:	09 f4       	brne	.+2      	; 0x3be2 <ramDyskDodajBlokXmodem+0x1a>
    3be0:	4e c0       	rjmp	.+156    	; 0x3c7e <ramDyskDodajBlokXmodem+0xb6>
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
  uint8_t indLo = 0;
  uint8_t *wynik;
  
  if (fd->wpis->pierwszyKlaster == 0)
    3be2:	dc 01       	movw	r26, r24
    3be4:	14 96       	adiw	r26, 0x04	; 4
    3be6:	cd 91       	ld	r28, X+
    3be8:	dc 91       	ld	r29, X
    3bea:	15 97       	sbiw	r26, 0x05	; 5
    3bec:	88 81       	ld	r24, Y
    3bee:	88 23       	and	r24, r24
    3bf0:	19 f4       	brne	.+6      	; 0x3bf8 <ramDyskDodajBlokXmodem+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    3bf2:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <znajdzWolnyKlaster>
    3bf6:	88 83       	st	Y, r24
  if (fd->wpis->pierwszyKlaster == 0)
    3bf8:	d7 01       	movw	r26, r14
    3bfa:	14 96       	adiw	r26, 0x04	; 4
    3bfc:	ed 91       	ld	r30, X+
    3bfe:	fc 91       	ld	r31, X
    3c00:	15 97       	sbiw	r26, 0x05	; 5
    3c02:	80 81       	ld	r24, Z
    3c04:	88 23       	and	r24, r24
    3c06:	d9 f1       	breq	.+118    	; 0x3c7e <ramDyskDodajBlokXmodem+0xb6>

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
  if (nrBloku == 0)
    return NULL;
  nrBloku --;
    3c08:	08 94       	sec
    3c0a:	c1 08       	sbc	r12, r1
    3c0c:	d1 08       	sbc	r13, r1
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
    3c0e:	e6 01       	movw	r28, r12
    3c10:	d6 95       	lsr	r29
    3c12:	c7 95       	ror	r28
    3c14:	1c 2f       	mov	r17, r28
  if (fd->wpis->pierwszyKlaster == 0)
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
    3c16:	6c 2f       	mov	r22, r28
    3c18:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <znajdzKlasterN>
    3c1c:	98 2f       	mov	r25, r24
  if (tmpKlaster == 0)
    3c1e:	88 23       	and	r24, r24
    3c20:	71 f1       	breq	.+92     	; 0x3c7e <ramDyskDodajBlokXmodem+0xb6>
    3c22:	d7 01       	movw	r26, r14
    3c24:	14 96       	adiw	r26, 0x04	; 4
    3c26:	ed 91       	ld	r30, X+
    3c28:	fc 91       	ld	r31, X
    3c2a:	15 97       	sbiw	r26, 0x05	; 5
    return NULL;
  if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
    3c2c:	c0 fe       	sbrs	r12, 0
    3c2e:	0f c0       	rjmp	.+30     	; 0x3c4e <ramDyskDodajBlokXmodem+0x86>
  {
    indLo = 128;
    if (fd->wpis->rozmiarHi <= indHi)
    3c30:	82 81       	ldd	r24, Z+2	; 0x02
    3c32:	c8 17       	cp	r28, r24
    3c34:	38 f0       	brcs	.+14     	; 0x3c44 <ramDyskDodajBlokXmodem+0x7c>
    {
      fd->wpis->rozmiarHi = indHi+1;
    3c36:	1f 5f       	subi	r17, 0xFF	; 255
    3c38:	12 83       	std	Z+2, r17	; 0x02
      fd->wpis->rozmiarLo = 0;
    3c3a:	14 96       	adiw	r26, 0x04	; 4
    3c3c:	ed 91       	ld	r30, X+
    3c3e:	fc 91       	ld	r31, X
    3c40:	15 97       	sbiw	r26, 0x05	; 5
    3c42:	11 82       	std	Z+1, r1	; 0x01
    }
    wynik=dataPtr(tmpKlaster, 128);
    3c44:	39 2f       	mov	r19, r25
    3c46:	20 e0       	ldi	r18, 0x00	; 0
    3c48:	20 58       	subi	r18, 0x80	; 128
    3c4a:	3f 47       	sbci	r19, 0x7F	; 127
    3c4c:	1a c0       	rjmp	.+52     	; 0x3c82 <ramDyskDodajBlokXmodem+0xba>
  }
  else
  {
    if (fd->wpis->rozmiarHi < indHi)
    3c4e:	82 81       	ldd	r24, Z+2	; 0x02
    3c50:	8c 17       	cp	r24, r28
    3c52:	38 f4       	brcc	.+14     	; 0x3c62 <ramDyskDodajBlokXmodem+0x9a>
    {
      fd->wpis->rozmiarHi = indHi;
    3c54:	c2 83       	std	Z+2, r28	; 0x02
      fd->wpis->rozmiarLo = 128;
    3c56:	d7 01       	movw	r26, r14
    3c58:	14 96       	adiw	r26, 0x04	; 4
    3c5a:	ed 91       	ld	r30, X+
    3c5c:	fc 91       	ld	r31, X
    3c5e:	15 97       	sbiw	r26, 0x05	; 5
    3c60:	05 c0       	rjmp	.+10     	; 0x3c6c <ramDyskDodajBlokXmodem+0xa4>
    }
    else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
    3c62:	8c 17       	cp	r24, r28
    3c64:	29 f4       	brne	.+10     	; 0x3c70 <ramDyskDodajBlokXmodem+0xa8>
    3c66:	81 81       	ldd	r24, Z+1	; 0x01
    3c68:	87 fd       	sbrc	r24, 7
    3c6a:	02 c0       	rjmp	.+4      	; 0x3c70 <ramDyskDodajBlokXmodem+0xa8>
      fd->wpis->rozmiarLo = 128;
    3c6c:	80 e8       	ldi	r24, 0x80	; 128
    3c6e:	81 83       	std	Z+1, r24	; 0x01
    
    wynik=dataPtr(tmpKlaster, 0);
    3c70:	89 2f       	mov	r24, r25
    3c72:	90 e0       	ldi	r25, 0x00	; 0
    3c74:	80 58       	subi	r24, 0x80	; 128
    3c76:	9f 4f       	sbci	r25, 0xFF	; 255
    3c78:	38 2f       	mov	r19, r24
    3c7a:	22 27       	eor	r18, r18
    3c7c:	02 c0       	rjmp	.+4      	; 0x3c82 <ramDyskDodajBlokXmodem+0xba>
    3c7e:	20 e0       	ldi	r18, 0x00	; 0
    3c80:	30 e0       	ldi	r19, 0x00	; 0
  }
  return wynik;
}
    3c82:	c9 01       	movw	r24, r18
    3c84:	df 91       	pop	r29
    3c86:	cf 91       	pop	r28
    3c88:	1f 91       	pop	r17
    3c8a:	ff 90       	pop	r15
    3c8c:	ef 90       	pop	r14
    3c8e:	df 90       	pop	r13
    3c90:	cf 90       	pop	r12
    3c92:	08 95       	ret

00003c94 <ramDyskUstawWskaznikNaKoniec>:

  return 0; 
}

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
    3c94:	cf 93       	push	r28
    3c96:	df 93       	push	r29
    3c98:	ec 01       	movw	r28, r24
  if (fd == NULL)
    3c9a:	00 97       	sbiw	r24, 0x00	; 0
    3c9c:	11 f4       	brne	.+4      	; 0x3ca2 <ramDyskUstawWskaznikNaKoniec+0xe>
    3c9e:	81 e0       	ldi	r24, 0x01	; 1
    3ca0:	17 c0       	rjmp	.+46     	; 0x3cd0 <ramDyskUstawWskaznikNaKoniec+0x3c>
    return 1;
  fd->IndLo = fd->wpis->rozmiarLo;
    3ca2:	ec 81       	ldd	r30, Y+4	; 0x04
    3ca4:	fd 81       	ldd	r31, Y+5	; 0x05
    3ca6:	91 81       	ldd	r25, Z+1	; 0x01
    3ca8:	9a 83       	std	Y+2, r25	; 0x02
  fd->IndHi = fd->wpis->rozmiarHi;
    3caa:	82 81       	ldd	r24, Z+2	; 0x02
    3cac:	8b 83       	std	Y+3, r24	; 0x03
//  fd->IndLo++;
  uint8_t tmpKlaster = 0;
  if (fd->IndLo != 0)
    3cae:	99 23       	and	r25, r25
    3cb0:	71 f0       	breq	.+28     	; 0x3cce <ramDyskUstawWskaznikNaKoniec+0x3a>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    3cb2:	80 81       	ld	r24, Z
    3cb4:	62 81       	ldd	r22, Z+2	; 0x02
    3cb6:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <znajdzKlasterN>
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
    3cba:	90 e0       	ldi	r25, 0x00	; 0
    3cbc:	80 58       	subi	r24, 0x80	; 128
    3cbe:	9f 4f       	sbci	r25, 0xFF	; 255
    3cc0:	98 2f       	mov	r25, r24
    3cc2:	88 27       	eor	r24, r24
    3cc4:	2a 81       	ldd	r18, Y+2	; 0x02
    3cc6:	82 0f       	add	r24, r18
    3cc8:	91 1d       	adc	r25, r1
    3cca:	99 83       	std	Y+1, r25	; 0x01
    3ccc:	88 83       	st	Y, r24
    3cce:	80 e0       	ldi	r24, 0x00	; 0
  }  
  return 0;
}
    3cd0:	df 91       	pop	r29
    3cd2:	cf 91       	pop	r28
    3cd4:	08 95       	ret

00003cd6 <ramDyskUstawWskaznik>:
  }
  return 0;
}

uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
{
    3cd6:	ef 92       	push	r14
    3cd8:	ff 92       	push	r15
    3cda:	0f 93       	push	r16
    3cdc:	1f 93       	push	r17
    3cde:	cf 93       	push	r28
    3ce0:	df 93       	push	r29
    3ce2:	ec 01       	movw	r28, r24
  if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje na początek pliku.
    3ce4:	61 15       	cp	r22, r1
    3ce6:	71 05       	cpc	r23, r1
    3ce8:	19 f4       	brne	.+6      	; 0x3cf0 <ramDyskUstawWskaznik+0x1a>
  {                                                       //Jeśli tak, to nie ma potzeby tworzenia klastrów. Plik może nadal nei mieć żadnego klastra.
    fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bardziej znaczącego bajtu)
    3cea:	1a 82       	std	Y+2, r1	; 0x02
    fd->IndHi = 0;
    3cec:	1b 82       	std	Y+3, r1	; 0x03
    3cee:	44 c0       	rjmp	.+136    	; 0x3d78 <ramDyskUstawWskaznik+0xa2>
    return 0;
  }
  indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio ustawić rozmair pliku.
    3cf0:	8b 01       	movw	r16, r22
    3cf2:	01 50       	subi	r16, 0x01	; 1
    3cf4:	10 40       	sbci	r17, 0x00	; 0
                                                          //Jeśli indeks jest większy niż rozmiar pliku, to plik zostanie rozciągnięty do zadanej wartości indeksu -1
  
  if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydzielony pierwszy klaster
    3cf6:	ec 80       	ldd	r14, Y+4	; 0x04
    3cf8:	fd 80       	ldd	r15, Y+5	; 0x05
    3cfa:	f7 01       	movw	r30, r14
    3cfc:	80 81       	ld	r24, Z
    3cfe:	88 23       	and	r24, r24
    3d00:	21 f4       	brne	.+8      	; 0x3d0a <ramDyskUstawWskaznik+0x34>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pliku. Jest to konieczne, ponieważ klaster ma wartość niezerową
    3d02:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <znajdzWolnyKlaster>
    3d06:	f7 01       	movw	r30, r14
    3d08:	80 83       	st	Z, r24

  uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką należy dodać do pierwszego klastra`

  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
    3d0a:	0a 83       	std	Y+2, r16	; 0x02
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
    3d0c:	1b 83       	std	Y+3, r17	; 0x03
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
    3d0e:	ec 81       	ldd	r30, Y+4	; 0x04
    3d10:	fd 81       	ldd	r31, Y+5	; 0x05
    3d12:	80 81       	ld	r24, Z
    3d14:	61 2f       	mov	r22, r17
    3d16:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <znajdzKlasterN>
    3d1a:	38 2f       	mov	r19, r24
  if (nrKlastra == 0)
    3d1c:	88 23       	and	r24, r24
    3d1e:	11 f4       	brne	.+4      	; 0x3d24 <ramDyskUstawWskaznik+0x4e>
    3d20:	81 e0       	ldi	r24, 0x01	; 1
    3d22:	2b c0       	rjmp	.+86     	; 0x3d7a <ramDyskUstawWskaznik+0xa4>
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    3d24:	ec 81       	ldd	r30, Y+4	; 0x04
    3d26:	fd 81       	ldd	r31, Y+5	; 0x05
    3d28:	92 81       	ldd	r25, Z+2	; 0x02
    3d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d2c:	98 17       	cp	r25, r24
    3d2e:	29 f4       	brne	.+10     	; 0x3d3a <ramDyskUstawWskaznik+0x64>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    3d30:	9a 81       	ldd	r25, Y+2	; 0x02
    3d32:	81 81       	ldd	r24, Z+1	; 0x01
    3d34:	89 17       	cp	r24, r25
    3d36:	08 f4       	brcc	.+2      	; 0x3d3a <ramDyskUstawWskaznik+0x64>
      fd->wpis->rozmiarLo = fd->IndLo;
    3d38:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    3d3a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d3c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d3e:	92 81       	ldd	r25, Z+2	; 0x02
    3d40:	8b 81       	ldd	r24, Y+3	; 0x03
    3d42:	98 17       	cp	r25, r24
    3d44:	30 f4       	brcc	.+12     	; 0x3d52 <ramDyskUstawWskaznik+0x7c>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    3d46:	8a 81       	ldd	r24, Y+2	; 0x02
    3d48:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    3d4a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d4c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d50:	82 83       	std	Z+2, r24	; 0x02
  if (nrKlastra == 0)
    return 1;                                             //Brak klastrów

  uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku

  fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
    3d52:	2a 81       	ldd	r18, Y+2	; 0x02
    3d54:	2f 5f       	subi	r18, 0xFF	; 255
    3d56:	2a 83       	std	Y+2, r18	; 0x02
  if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, to jeszcze on nie iestnieje
    3d58:	22 23       	and	r18, r18
    3d5a:	21 f4       	brne	.+8      	; 0x3d64 <ramDyskUstawWskaznik+0x8e>
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
    3d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5e:	8f 5f       	subi	r24, 0xFF	; 255
    3d60:	8b 83       	std	Y+3, r24	; 0x03
    3d62:	0a c0       	rjmp	.+20     	; 0x3d78 <ramDyskUstawWskaznik+0xa2>
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra
    3d64:	83 2f       	mov	r24, r19
    3d66:	90 e0       	ldi	r25, 0x00	; 0
    3d68:	80 58       	subi	r24, 0x80	; 128
    3d6a:	9f 4f       	sbci	r25, 0xFF	; 255
    3d6c:	98 2f       	mov	r25, r24
    3d6e:	88 27       	eor	r24, r24
    3d70:	82 0f       	add	r24, r18
    3d72:	91 1d       	adc	r25, r1
    3d74:	99 83       	std	Y+1, r25	; 0x01
    3d76:	88 83       	st	Y, r24
    3d78:	80 e0       	ldi	r24, 0x00	; 0

  return 0; 
}
    3d7a:	df 91       	pop	r29
    3d7c:	cf 91       	pop	r28
    3d7e:	1f 91       	pop	r17
    3d80:	0f 91       	pop	r16
    3d82:	ff 90       	pop	r15
    3d84:	ef 90       	pop	r14
    3d86:	08 95       	ret

00003d88 <ramDyskCzytajBajtZPliku>:
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
    3d88:	0f 93       	push	r16
    3d8a:	1f 93       	push	r17
    3d8c:	cf 93       	push	r28
    3d8e:	df 93       	push	r29
    3d90:	ec 01       	movw	r28, r24
    3d92:	8b 01       	movw	r16, r22
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3d94:	ec 81       	ldd	r30, Y+4	; 0x04
    3d96:	fd 81       	ldd	r31, Y+5	; 0x05
    3d98:	82 81       	ldd	r24, Z+2	; 0x02
    3d9a:	6b 81       	ldd	r22, Y+3	; 0x03
    3d9c:	68 17       	cp	r22, r24
    3d9e:	30 f0       	brcs	.+12     	; 0x3dac <ramDyskCzytajBajtZPliku+0x24>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3da0:	86 17       	cp	r24, r22
    3da2:	21 f5       	brne	.+72     	; 0x3dec <ramDyskCzytajBajtZPliku+0x64>
    3da4:	91 81       	ldd	r25, Z+1	; 0x01
    3da6:	8a 81       	ldd	r24, Y+2	; 0x02
    3da8:	98 17       	cp	r25, r24
    3daa:	00 f1       	brcs	.+64     	; 0x3dec <ramDyskCzytajBajtZPliku+0x64>
uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof

  if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku nowego klastra
    3dac:	8a 81       	ldd	r24, Y+2	; 0x02
    3dae:	88 23       	and	r24, r24
    3db0:	41 f4       	brne	.+16     	; 0x3dc2 <ramDyskCzytajBajtZPliku+0x3a>
  {
    uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    3db2:	80 81       	ld	r24, Z
    3db4:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <znajdzKlasterN>
    fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego klastra
    3db8:	90 e0       	ldi	r25, 0x00	; 0
    3dba:	80 58       	subi	r24, 0x80	; 128
    3dbc:	9f 4f       	sbci	r25, 0xFF	; 255
    3dbe:	18 82       	st	Y, r1
    3dc0:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *bajt = *(fd->Wsk);                                 //Odczyt z pliku
    3dc2:	e8 81       	ld	r30, Y
    3dc4:	f9 81       	ldd	r31, Y+1	; 0x01
    3dc6:	80 81       	ld	r24, Z
    3dc8:	f8 01       	movw	r30, r16
    3dca:	80 83       	st	Z, r24
  fd->IndLo++;                                        //Zwiększenie indeksu o 1
    3dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dce:	8f 5f       	subi	r24, 0xFF	; 255
    3dd0:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    3dd2:	88 23       	and	r24, r24
    3dd4:	21 f4       	brne	.+8      	; 0x3dde <ramDyskCzytajBajtZPliku+0x56>
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
    3dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3dd8:	8f 5f       	subi	r24, 0xFF	; 255
    3dda:	8b 83       	std	Y+3, r24	; 0x03
    3ddc:	05 c0       	rjmp	.+10     	; 0x3de8 <ramDyskCzytajBajtZPliku+0x60>
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
    3dde:	88 81       	ld	r24, Y
    3de0:	99 81       	ldd	r25, Y+1	; 0x01
    3de2:	01 96       	adiw	r24, 0x01	; 1
    3de4:	99 83       	std	Y+1, r25	; 0x01
    3de6:	88 83       	st	Y, r24
    3de8:	80 e0       	ldi	r24, 0x00	; 0
    3dea:	01 c0       	rjmp	.+2      	; 0x3dee <ramDyskCzytajBajtZPliku+0x66>
    3dec:	81 e0       	ldi	r24, 0x01	; 1
  return 0;
}
    3dee:	df 91       	pop	r29
    3df0:	cf 91       	pop	r28
    3df2:	1f 91       	pop	r17
    3df4:	0f 91       	pop	r16
    3df6:	08 95       	ret

00003df8 <getSTD>:
  return wynik;
}


static int getSTD(FILE *stream)
{
    3df8:	df 93       	push	r29
    3dfa:	cf 93       	push	r28
    3dfc:	0f 92       	push	r0
    3dfe:	cd b7       	in	r28, 0x3d	; 61
    3e00:	de b7       	in	r29, 0x3e	; 62
  uint8_t wynik;
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  
  if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
    3e02:	fc 01       	movw	r30, r24
    3e04:	84 85       	ldd	r24, Z+12	; 0x0c
    3e06:	95 85       	ldd	r25, Z+13	; 0x0d
    3e08:	be 01       	movw	r22, r28
    3e0a:	6f 5f       	subi	r22, 0xFF	; 255
    3e0c:	7f 4f       	sbci	r23, 0xFF	; 255
    3e0e:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <ramDyskCzytajBajtZPliku>
    3e12:	88 23       	and	r24, r24
    3e14:	19 f0       	breq	.+6      	; 0x3e1c <getSTD+0x24>
    3e16:	2f ef       	ldi	r18, 0xFF	; 255
    3e18:	3f ef       	ldi	r19, 0xFF	; 255
    3e1a:	03 c0       	rjmp	.+6      	; 0x3e22 <getSTD+0x2a>
    return wynik;
    3e1c:	89 81       	ldd	r24, Y+1	; 0x01
    3e1e:	28 2f       	mov	r18, r24
    3e20:	30 e0       	ldi	r19, 0x00	; 0
  return EOF;
}
    3e22:	c9 01       	movw	r24, r18
    3e24:	0f 90       	pop	r0
    3e26:	cf 91       	pop	r28
    3e28:	df 91       	pop	r29
    3e2a:	08 95       	ret

00003e2c <ramDyskZapiszBajtDoPliku>:
  memset (fd, 0, 4);
  return 0;
}

uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
{
    3e2c:	1f 93       	push	r17
    3e2e:	cf 93       	push	r28
    3e30:	df 93       	push	r29
    3e32:	ec 01       	movw	r28, r24
    3e34:	16 2f       	mov	r17, r22
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
    3e36:	ec 81       	ldd	r30, Y+4	; 0x04
    3e38:	fd 81       	ldd	r31, Y+5	; 0x05
    3e3a:	80 81       	ld	r24, Z
    3e3c:	88 23       	and	r24, r24
    3e3e:	49 f4       	brne	.+18     	; 0x3e52 <ramDyskZapiszBajtDoPliku+0x26>
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
    3e40:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <znajdzWolnyKlaster>
    3e44:	88 23       	and	r24, r24
    3e46:	11 f4       	brne	.+4      	; 0x3e4c <ramDyskZapiszBajtDoPliku+0x20>
    3e48:	81 e0       	ldi	r24, 0x01	; 1
    3e4a:	3e c0       	rjmp	.+124    	; 0x3ec8 <ramDyskZapiszBajtDoPliku+0x9c>
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    fd->wpis->pierwszyKlaster = tmpKlaster;
    3e4c:	ec 81       	ldd	r30, Y+4	; 0x04
    3e4e:	fd 81       	ldd	r31, Y+5	; 0x05
    3e50:	80 83       	st	Z, r24
  }
  if (fd->IndLo == 0)
    3e52:	8a 81       	ldd	r24, Y+2	; 0x02
    3e54:	88 23       	and	r24, r24
    3e56:	79 f4       	brne	.+30     	; 0x3e76 <ramDyskZapiszBajtDoPliku+0x4a>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    3e58:	ec 81       	ldd	r30, Y+4	; 0x04
    3e5a:	fd 81       	ldd	r31, Y+5	; 0x05
    3e5c:	80 81       	ld	r24, Z
    3e5e:	6b 81       	ldd	r22, Y+3	; 0x03
    3e60:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <znajdzKlasterN>
    if (tmpKlaster == 0)
    3e64:	88 23       	and	r24, r24
    3e66:	11 f4       	brne	.+4      	; 0x3e6c <ramDyskZapiszBajtDoPliku+0x40>
    3e68:	82 e0       	ldi	r24, 0x02	; 2
    3e6a:	2e c0       	rjmp	.+92     	; 0x3ec8 <ramDyskZapiszBajtDoPliku+0x9c>
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    }
    fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego klastra
    3e6c:	90 e0       	ldi	r25, 0x00	; 0
    3e6e:	80 58       	subi	r24, 0x80	; 128
    3e70:	9f 4f       	sbci	r25, 0xFF	; 255
    3e72:	18 82       	st	Y, r1
    3e74:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
    3e76:	e8 81       	ld	r30, Y
    3e78:	f9 81       	ldd	r31, Y+1	; 0x01
    3e7a:	10 83       	st	Z, r17

  fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
    3e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e7e:	8f 5f       	subi	r24, 0xFF	; 255
    3e80:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, że czły klaster jest zapisany
    3e82:	88 23       	and	r24, r24
    3e84:	21 f4       	brne	.+8      	; 0x3e8e <ramDyskZapiszBajtDoPliku+0x62>
    fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt indeksu. Nie utworzono nowego klastra, zatem nie uaktualniamy wskaźnika
    3e86:	8b 81       	ldd	r24, Y+3	; 0x03
    3e88:	8f 5f       	subi	r24, 0xFF	; 255
    3e8a:	8b 83       	std	Y+3, r24	; 0x03
    3e8c:	05 c0       	rjmp	.+10     	; 0x3e98 <ramDyskZapiszBajtDoPliku+0x6c>
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    3e8e:	88 81       	ld	r24, Y
    3e90:	99 81       	ldd	r25, Y+1	; 0x01
    3e92:	01 96       	adiw	r24, 0x01	; 1
    3e94:	99 83       	std	Y+1, r25	; 0x01
    3e96:	88 83       	st	Y, r24
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    3e98:	ec 81       	ldd	r30, Y+4	; 0x04
    3e9a:	fd 81       	ldd	r31, Y+5	; 0x05
    3e9c:	92 81       	ldd	r25, Z+2	; 0x02
    3e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea0:	98 17       	cp	r25, r24
    3ea2:	29 f4       	brne	.+10     	; 0x3eae <ramDyskZapiszBajtDoPliku+0x82>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    3ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea6:	81 81       	ldd	r24, Z+1	; 0x01
    3ea8:	89 17       	cp	r24, r25
    3eaa:	08 f4       	brcc	.+2      	; 0x3eae <ramDyskZapiszBajtDoPliku+0x82>
      fd->wpis->rozmiarLo = fd->IndLo;
    3eac:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    3eae:	ec 81       	ldd	r30, Y+4	; 0x04
    3eb0:	fd 81       	ldd	r31, Y+5	; 0x05
    3eb2:	92 81       	ldd	r25, Z+2	; 0x02
    3eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb6:	98 17       	cp	r25, r24
    3eb8:	30 f4       	brcc	.+12     	; 0x3ec6 <ramDyskZapiszBajtDoPliku+0x9a>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    3eba:	8a 81       	ldd	r24, Y+2	; 0x02
    3ebc:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    3ebe:	ec 81       	ldd	r30, Y+4	; 0x04
    3ec0:	fd 81       	ldd	r31, Y+5	; 0x05
    3ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec4:	82 83       	std	Z+2, r24	; 0x02
    3ec6:	80 e0       	ldi	r24, 0x00	; 0
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}
    3ec8:	df 91       	pop	r29
    3eca:	cf 91       	pop	r28
    3ecc:	1f 91       	pop	r17
    3ece:	08 95       	ret

00003ed0 <putSTD>:
    return wynik;
  return EOF;
}

static int putSTD(char c, FILE *stream)
{
    3ed0:	28 2f       	mov	r18, r24
    3ed2:	fb 01       	movw	r30, r22
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
    3ed4:	84 85       	ldd	r24, Z+12	; 0x0c
    3ed6:	95 85       	ldd	r25, Z+13	; 0x0d
    3ed8:	62 2f       	mov	r22, r18
    3eda:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <ramDyskZapiszBajtDoPliku>
}
    3ede:	90 e0       	ldi	r25, 0x00	; 0
    3ee0:	08 95       	ret

00003ee2 <ramDyskCzyscPlik>:
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
  }
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
    3ee2:	cf 93       	push	r28
    3ee4:	df 93       	push	r29
    3ee6:	9c 01       	movw	r18, r24
    3ee8:	0e c0       	rjmp	.+28     	; 0x3f06 <ramDyskCzyscPlik+0x24>
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
  {
    usuwanyKlaster = fd->wpis->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3eea:	a8 2f       	mov	r26, r24
    3eec:	b0 e0       	ldi	r27, 0x00	; 0
    3eee:	fd 01       	movw	r30, r26
    3ef0:	e2 53       	subi	r30, 0x32	; 50
    3ef2:	f1 4f       	sbci	r31, 0xF1	; 241
    3ef4:	e0 81       	ld	r30, Z
    3ef6:	e8 17       	cp	r30, r24
    3ef8:	11 f4       	brne	.+4      	; 0x3efe <ramDyskCzyscPlik+0x1c>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3efa:	18 82       	st	Y, r1
    3efc:	01 c0       	rjmp	.+2      	; 0x3f00 <ramDyskCzyscPlik+0x1e>
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3efe:	e8 83       	st	Y, r30
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
    3f00:	a2 53       	subi	r26, 0x32	; 50
    3f02:	b1 4f       	sbci	r27, 0xF1	; 241
    3f04:	1c 92       	st	X, r1
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3f06:	d9 01       	movw	r26, r18
    3f08:	14 96       	adiw	r26, 0x04	; 4
    3f0a:	cd 91       	ld	r28, X+
    3f0c:	dc 91       	ld	r29, X
    3f0e:	15 97       	sbiw	r26, 0x05	; 5
    3f10:	88 81       	ld	r24, Y
    3f12:	88 23       	and	r24, r24
    3f14:	51 f7       	brne	.-44     	; 0x3eea <ramDyskCzyscPlik+0x8>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
  }
  fd->wpis->rozmiarLo       = 0;
    3f16:	19 82       	std	Y+1, r1	; 0x01
  fd->wpis->rozmiarHi       = 0;
    3f18:	14 96       	adiw	r26, 0x04	; 4
    3f1a:	ed 91       	ld	r30, X+
    3f1c:	fc 91       	ld	r31, X
    3f1e:	15 97       	sbiw	r26, 0x05	; 5
    3f20:	12 82       	std	Z+2, r1	; 0x02
  fd->wpis->dataMod         = systemTime();
    3f22:	14 96       	adiw	r26, 0x04	; 4
    3f24:	ed 91       	ld	r30, X+
    3f26:	fc 91       	ld	r31, X
    3f28:	15 97       	sbiw	r26, 0x05	; 5
    3f2a:	14 86       	std	Z+12, r1	; 0x0c
    3f2c:	15 86       	std	Z+13, r1	; 0x0d
    3f2e:	16 86       	std	Z+14, r1	; 0x0e
    3f30:	17 86       	std	Z+15, r1	; 0x0f
  memset (fd, 0, 4);
    3f32:	f9 01       	movw	r30, r18
    3f34:	10 82       	st	Z, r1
    3f36:	11 82       	std	Z+1, r1	; 0x01
    3f38:	12 82       	std	Z+2, r1	; 0x02
    3f3a:	13 82       	std	Z+3, r1	; 0x03
  return 0;
}
    3f3c:	df 91       	pop	r29
    3f3e:	cf 91       	pop	r28
    3f40:	08 95       	ret

00003f42 <ramDyskZamknijPlik>:
//relokacjaTablicyWpisow()
  return 0;
}

void ramDyskZamknijPlik(struct ramPlikFd *fd)
{
    3f42:	dc 01       	movw	r26, r24
  if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest poprawny
    3f44:	14 96       	adiw	r26, 0x04	; 4
    3f46:	ed 91       	ld	r30, X+
    3f48:	fc 91       	ld	r31, X
    3f4a:	15 97       	sbiw	r26, 0x05	; 5
    3f4c:	83 81       	ldd	r24, Z+3	; 0x03
    3f4e:	88 23       	and	r24, r24
    3f50:	39 f0       	breq	.+14     	; 0x3f60 <ramDyskZamknijPlik+0x1e>
  {
    fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
    3f52:	81 50       	subi	r24, 0x01	; 1
    3f54:	83 83       	std	Z+3, r24	; 0x03
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
    3f56:	86 e0       	ldi	r24, 0x06	; 6
    3f58:	fd 01       	movw	r30, r26
    3f5a:	11 92       	st	Z+, r1
    3f5c:	8a 95       	dec	r24
    3f5e:	e9 f7       	brne	.-6      	; 0x3f5a <ramDyskZamknijPlik+0x18>
    3f60:	08 95       	ret

00003f62 <ramDyskZamknijPlikStdIo>:
  fdev_set_udata(stream, fd);
  return 0;
}

uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
{
    3f62:	ef 92       	push	r14
    3f64:	ff 92       	push	r15
    3f66:	0f 93       	push	r16
    3f68:	1f 93       	push	r17
    3f6a:	8c 01       	movw	r16, r24
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
    3f6c:	dc 01       	movw	r26, r24
    3f6e:	1c 96       	adiw	r26, 0x0c	; 12
    3f70:	ed 90       	ld	r14, X+
    3f72:	fc 90       	ld	r15, X
    3f74:	1d 97       	sbiw	r26, 0x0d	; 13
  ramDyskZamknijPlik(fd);
    3f76:	c7 01       	movw	r24, r14
    3f78:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <ramDyskZamknijPlik>
  fclose(stream);
    3f7c:	c8 01       	movw	r24, r16
    3f7e:	0e 94 95 5c 	call	0xb92a	; 0xb92a <fclose>
    3f82:	d7 01       	movw	r26, r14
    3f84:	14 96       	adiw	r26, 0x04	; 4
    3f86:	ed 91       	ld	r30, X+
    3f88:	fc 91       	ld	r31, X
    3f8a:	15 97       	sbiw	r26, 0x05	; 5
  return fd->wpis->lAktOtw;
}
    3f8c:	83 81       	ldd	r24, Z+3	; 0x03
    3f8e:	1f 91       	pop	r17
    3f90:	0f 91       	pop	r16
    3f92:	ff 90       	pop	r15
    3f94:	ef 90       	pop	r14
    3f96:	08 95       	ret

00003f98 <ramDyskInit>:
}


void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
    3f98:	80 e8       	ldi	r24, 0x80	; 128
    3f9a:	ee ec       	ldi	r30, 0xCE	; 206
    3f9c:	fe e0       	ldi	r31, 0x0E	; 14
    3f9e:	df 01       	movw	r26, r30
    3fa0:	1d 92       	st	X+, r1
    3fa2:	8a 95       	dec	r24
    3fa4:	e9 f7       	brne	.-6      	; 0x3fa0 <ramDyskInit+0x8>
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
    3fa6:	80 e0       	ldi	r24, 0x00	; 0
    3fa8:	91 e0       	ldi	r25, 0x01	; 1
    3faa:	e0 e0       	ldi	r30, 0x00	; 0
    3fac:	f0 e8       	ldi	r31, 0x80	; 128
    3fae:	df 01       	movw	r26, r30
    3fb0:	9c 01       	movw	r18, r24
    3fb2:	1d 92       	st	X+, r1
    3fb4:	21 50       	subi	r18, 0x01	; 1
    3fb6:	30 40       	sbci	r19, 0x00	; 0
    3fb8:	e1 f7       	brne	.-8      	; 0x3fb2 <ramDyskInit+0x1a>
}
    3fba:	08 95       	ret

00003fbc <ramDyskCzytajBlokZPliku>:
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}

uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3fbc:	9f 92       	push	r9
    3fbe:	af 92       	push	r10
    3fc0:	bf 92       	push	r11
    3fc2:	cf 92       	push	r12
    3fc4:	df 92       	push	r13
    3fc6:	ef 92       	push	r14
    3fc8:	ff 92       	push	r15
    3fca:	0f 93       	push	r16
    3fcc:	1f 93       	push	r17
    3fce:	cf 93       	push	r28
    3fd0:	df 93       	push	r29
    3fd2:	ec 01       	movw	r28, r24
    3fd4:	5b 01       	movw	r10, r22
    3fd6:	6a 01       	movw	r12, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3fd8:	ec 81       	ldd	r30, Y+4	; 0x04
    3fda:	fd 81       	ldd	r31, Y+5	; 0x05
    3fdc:	80 81       	ld	r24, Z
    3fde:	88 23       	and	r24, r24
    3fe0:	29 f4       	brne	.+10     	; 0x3fec <ramDyskCzytajBlokZPliku+0x30>
  {
    *dlugosc = 0;
    3fe2:	fa 01       	movw	r30, r20
    3fe4:	11 82       	std	Z+1, r1	; 0x01
    3fe6:	10 82       	st	Z, r1
    3fe8:	81 e0       	ldi	r24, 0x01	; 1
    3fea:	77 c0       	rjmp	.+238    	; 0x40da <ramDyskCzytajBlokZPliku+0x11e>
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3fec:	22 81       	ldd	r18, Z+2	; 0x02
    3fee:	3b 81       	ldd	r19, Y+3	; 0x03
    3ff0:	32 17       	cp	r19, r18
    3ff2:	40 f0       	brcs	.+16     	; 0x4004 <ramDyskCzytajBlokZPliku+0x48>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3ff4:	23 17       	cp	r18, r19
    3ff6:	09 f0       	breq	.+2      	; 0x3ffa <ramDyskCzytajBlokZPliku+0x3e>
    3ff8:	7c c0       	rjmp	.+248    	; 0x40f2 <ramDyskCzytajBlokZPliku+0x136>
    3ffa:	91 81       	ldd	r25, Z+1	; 0x01
    3ffc:	8a 81       	ldd	r24, Y+2	; 0x02
    3ffe:	98 17       	cp	r25, r24
    4000:	08 f4       	brcc	.+2      	; 0x4004 <ramDyskCzytajBlokZPliku+0x48>
    4002:	77 c0       	rjmp	.+238    	; 0x40f2 <ramDyskCzytajBlokZPliku+0x136>
  {
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
    4004:	82 2f       	mov	r24, r18
    4006:	90 e0       	ldi	r25, 0x00	; 0
    4008:	83 1b       	sub	r24, r19
    400a:	91 09       	sbc	r25, r1
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    400c:	21 81       	ldd	r18, Z+1	; 0x01
    400e:	42 2f       	mov	r20, r18
    4010:	50 e0       	ldi	r21, 0x00	; 0
    4012:	2a 81       	ldd	r18, Y+2	; 0x02
    4014:	42 1b       	sub	r20, r18
    4016:	51 09       	sbc	r21, r1
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
  
  uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i określenie ile bajtów zdoła się odczytać
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
    4018:	48 0f       	add	r20, r24
    401a:	59 1f       	adc	r21, r25
    401c:	f6 01       	movw	r30, r12
    401e:	e0 80       	ld	r14, Z
    4020:	f1 80       	ldd	r15, Z+1	; 0x01
    4022:	4e 15       	cp	r20, r14
    4024:	5f 05       	cpc	r21, r15
    4026:	08 f4       	brcc	.+2      	; 0x402a <ramDyskCzytajBlokZPliku+0x6e>
    4028:	7a 01       	movw	r14, r20
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
    402a:	f6 01       	movw	r30, r12
    402c:	11 82       	std	Z+1, r1	; 0x01
    402e:	10 82       	st	Z, r1
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
    4030:	8a 81       	ldd	r24, Y+2	; 0x02
    4032:	00 e0       	ldi	r16, 0x00	; 0
    4034:	11 e0       	ldi	r17, 0x01	; 1
    4036:	08 1b       	sub	r16, r24
    4038:	11 09       	sbc	r17, r1
    403a:	99 24       	eor	r9, r9
    403c:	49 c0       	rjmp	.+146    	; 0x40d0 <ramDyskCzytajBlokZPliku+0x114>
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
  {
    if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, że wskaźnik nie jest jeszcze ustawiony
    403e:	8a 81       	ldd	r24, Y+2	; 0x02
    4040:	88 23       	and	r24, r24
    4042:	b1 f4       	brne	.+44     	; 0x4070 <ramDyskCzytajBlokZPliku+0xb4>
    {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (od początkowego) należy się przesunąć do przodu
      if (tmpKlaster == 0)
    4044:	99 20       	and	r9, r9
    4046:	39 f4       	brne	.+14     	; 0x4056 <ramDyskCzytajBlokZPliku+0x9a>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
    4048:	ec 81       	ldd	r30, Y+4	; 0x04
    404a:	fd 81       	ldd	r31, Y+5	; 0x05
    404c:	80 81       	ld	r24, Z
    404e:	6b 81       	ldd	r22, Y+3	; 0x03
    4050:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <znajdzKlasterN>
    4054:	03 c0       	rjmp	.+6      	; 0x405c <ramDyskCzytajBlokZPliku+0xa0>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
    4056:	89 2d       	mov	r24, r9
    4058:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <nastepnyKlaster>
    405c:	98 2e       	mov	r9, r24
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
    405e:	88 23       	and	r24, r24
    4060:	11 f4       	brne	.+4      	; 0x4066 <ramDyskCzytajBlokZPliku+0xaa>
    4062:	83 e0       	ldi	r24, 0x03	; 3
    4064:	3a c0       	rjmp	.+116    	; 0x40da <ramDyskCzytajBlokZPliku+0x11e>
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
    4066:	90 e0       	ldi	r25, 0x00	; 0
    4068:	80 58       	subi	r24, 0x80	; 128
    406a:	9f 4f       	sbci	r25, 0xFF	; 255
    406c:	18 82       	st	Y, r1
    406e:	89 83       	std	Y+1, r24	; 0x01
    4070:	68 81       	ld	r22, Y
    4072:	79 81       	ldd	r23, Y+1	; 0x01
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    }
    
    if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
    4074:	0e 15       	cp	r16, r14
    4076:	1f 05       	cpc	r17, r15
    4078:	b0 f4       	brcc	.+44     	; 0x40a6 <ramDyskCzytajBlokZPliku+0xea>
    {                                  //dlBloku określa ile zostało jeszcze bajtów do końca klasrta
      memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
    407a:	c5 01       	movw	r24, r10
    407c:	a8 01       	movw	r20, r16
    407e:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
      znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy odczytane bajty
    4082:	a0 0e       	add	r10, r16
    4084:	b1 1e       	adc	r11, r17
      fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
    4086:	1a 82       	std	Y+2, r1	; 0x02
      fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz nie ma potrzeby ustawienia wskaźnika odczytu na jego początek
    4088:	8b 81       	ldd	r24, Y+3	; 0x03
    408a:	8f 5f       	subi	r24, 0xFF	; 255
    408c:	8b 83       	std	Y+3, r24	; 0x03
      doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
    408e:	e0 1a       	sub	r14, r16
    4090:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;             //Uaktualnienie 
    4092:	f6 01       	movw	r30, r12
    4094:	80 81       	ld	r24, Z
    4096:	91 81       	ldd	r25, Z+1	; 0x01
    4098:	80 0f       	add	r24, r16
    409a:	91 1f       	adc	r25, r17
    409c:	91 83       	std	Z+1, r25	; 0x01
    409e:	80 83       	st	Z, r24
    40a0:	00 e0       	ldi	r16, 0x00	; 0
    40a2:	11 e0       	ldi	r17, 0x01	; 1
    40a4:	15 c0       	rjmp	.+42     	; 0x40d0 <ramDyskCzytajBlokZPliku+0x114>
      dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całego klastra.
    }
    else                               //Ostatnia operacja odczytu
    {
      memcpy(znaki, fd->Wsk, doOdczytania);
    40a6:	c5 01       	movw	r24, r10
    40a8:	a7 01       	movw	r20, r14
    40aa:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
      fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym samym klastrze, zatem trzeba teraz uaktualnić wzkaźnik
    40ae:	88 81       	ld	r24, Y
    40b0:	99 81       	ldd	r25, Y+1	; 0x01
    40b2:	8e 0d       	add	r24, r14
    40b4:	9f 1d       	adc	r25, r15
    40b6:	99 83       	std	Y+1, r25	; 0x01
    40b8:	88 83       	st	Y, r24
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
    40ba:	8a 81       	ldd	r24, Y+2	; 0x02
    40bc:	8e 0d       	add	r24, r14
    40be:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
    40c0:	f6 01       	movw	r30, r12
    40c2:	80 81       	ld	r24, Z
    40c4:	91 81       	ldd	r25, Z+1	; 0x01
    40c6:	8e 0d       	add	r24, r14
    40c8:	9f 1d       	adc	r25, r15
    40ca:	91 83       	std	Z+1, r25	; 0x01
    40cc:	80 83       	st	Z, r24
    40ce:	04 c0       	rjmp	.+8      	; 0x40d8 <ramDyskCzytajBlokZPliku+0x11c>
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
    40d0:	e1 14       	cp	r14, r1
    40d2:	f1 04       	cpc	r15, r1
    40d4:	09 f0       	breq	.+2      	; 0x40d8 <ramDyskCzytajBlokZPliku+0x11c>
    40d6:	b3 cf       	rjmp	.-154    	; 0x403e <ramDyskCzytajBlokZPliku+0x82>
    40d8:	80 e0       	ldi	r24, 0x00	; 0
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
}
    40da:	df 91       	pop	r29
    40dc:	cf 91       	pop	r28
    40de:	1f 91       	pop	r17
    40e0:	0f 91       	pop	r16
    40e2:	ff 90       	pop	r15
    40e4:	ef 90       	pop	r14
    40e6:	df 90       	pop	r13
    40e8:	cf 90       	pop	r12
    40ea:	bf 90       	pop	r11
    40ec:	af 90       	pop	r10
    40ee:	9f 90       	pop	r9
    40f0:	08 95       	ret
    *dlugosc = 0;
    return 1;                         //1 - Plik jest pusty
  }
  if (wObrebiePliku(fd) != 0)
  {
    *dlugosc = 0;
    40f2:	f6 01       	movw	r30, r12
    40f4:	11 82       	std	Z+1, r1	; 0x01
    40f6:	10 82       	st	Z, r1
    40f8:	82 e0       	ldi	r24, 0x02	; 2
    40fa:	ef cf       	rjmp	.-34     	; 0x40da <ramDyskCzytajBlokZPliku+0x11e>

000040fc <ramDyskZapiszBlokDoPliku>:
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}

uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    40fc:	8f 92       	push	r8
    40fe:	9f 92       	push	r9
    4100:	bf 92       	push	r11
    4102:	cf 92       	push	r12
    4104:	df 92       	push	r13
    4106:	ef 92       	push	r14
    4108:	ff 92       	push	r15
    410a:	0f 93       	push	r16
    410c:	1f 93       	push	r17
    410e:	cf 93       	push	r28
    4110:	df 93       	push	r29
    4112:	ec 01       	movw	r28, r24
    4114:	6b 01       	movw	r12, r22
    4116:	4a 01       	movw	r8, r20
  if (fd->wpis->pierwszyKlaster == 0)
    4118:	0c 81       	ldd	r16, Y+4	; 0x04
    411a:	1d 81       	ldd	r17, Y+5	; 0x05
    411c:	f8 01       	movw	r30, r16
    411e:	80 81       	ld	r24, Z
    4120:	88 23       	and	r24, r24
    4122:	21 f4       	brne	.+8      	; 0x412c <ramDyskZapiszBlokDoPliku+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    4124:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <znajdzWolnyKlaster>
    4128:	f8 01       	movw	r30, r16
    412a:	80 83       	st	Z, r24
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
    412c:	8a 81       	ldd	r24, Y+2	; 0x02
    412e:	00 e0       	ldi	r16, 0x00	; 0
    4130:	11 e0       	ldi	r17, 0x01	; 1
    4132:	08 1b       	sub	r16, r24
    4134:	11 09       	sbc	r17, r1
  uint16_t doZapisu = *dlugosc;
    4136:	f4 01       	movw	r30, r8
    4138:	e0 80       	ld	r14, Z
    413a:	f1 80       	ldd	r15, Z+1	; 0x01
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
    413c:	11 82       	std	Z+1, r1	; 0x01
    413e:	10 82       	st	Z, r1
    4140:	bb 24       	eor	r11, r11
    4142:	4e c0       	rjmp	.+156    	; 0x41e0 <ramDyskZapiszBlokDoPliku+0xe4>
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
  {
    if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to należy odczytać jego numer oraz ustawić na niego wskaźnik
    4144:	8a 81       	ldd	r24, Y+2	; 0x02
    4146:	88 23       	and	r24, r24
    4148:	b1 f4       	brne	.+44     	; 0x4176 <ramDyskZapiszBlokDoPliku+0x7a>
    {
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
    414a:	bb 20       	and	r11, r11
    414c:	39 f4       	brne	.+14     	; 0x415c <ramDyskZapiszBlokDoPliku+0x60>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
    414e:	ec 81       	ldd	r30, Y+4	; 0x04
    4150:	fd 81       	ldd	r31, Y+5	; 0x05
    4152:	80 81       	ld	r24, Z
    4154:	6b 81       	ldd	r22, Y+3	; 0x03
    4156:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <znajdzKlasterN>
    415a:	03 c0       	rjmp	.+6      	; 0x4162 <ramDyskZapiszBlokDoPliku+0x66>
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
    415c:	8b 2d       	mov	r24, r11
    415e:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <nastepnyKlaster>
    4162:	b8 2e       	mov	r11, r24
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
    4164:	88 23       	and	r24, r24
    4166:	11 f4       	brne	.+4      	; 0x416c <ramDyskZapiszBlokDoPliku+0x70>
    4168:	81 e0       	ldi	r24, 0x01	; 1
    416a:	56 c0       	rjmp	.+172    	; 0x4218 <ramDyskZapiszBlokDoPliku+0x11c>
        return 1;                                 //1 - Brak wolnego klastra

      fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Teraz można do niego już pisać
    416c:	90 e0       	ldi	r25, 0x00	; 0
    416e:	80 58       	subi	r24, 0x80	; 128
    4170:	9f 4f       	sbci	r25, 0xFF	; 255
    4172:	18 82       	st	Y, r1
    4174:	89 83       	std	Y+1, r24	; 0x01
    4176:	88 81       	ld	r24, Y
    4178:	99 81       	ldd	r25, Y+1	; 0x01
    }
    if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w bieżącym klastrze
    417a:	0e 15       	cp	r16, r14
    417c:	1f 05       	cpc	r17, r15
    417e:	b0 f4       	brcc	.+44     	; 0x41ac <ramDyskZapiszBlokDoPliku+0xb0>
    {                                             //Nie uda się, teraz zapiszemy cały klastr do końca
      memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
    4180:	b6 01       	movw	r22, r12
    4182:	a8 01       	movw	r20, r16
    4184:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
      znaki +=dlBloku;                      
    4188:	c0 0e       	add	r12, r16
    418a:	d1 1e       	adc	r13, r17
      fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na początek nowego klastra. Kolejna iteracja go utworzy
    418c:	1a 82       	std	Y+2, r1	; 0x02
      doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka pozostałą do zapisujemy
    418e:	e0 1a       	sub	r14, r16
    4190:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych danych
    4192:	f4 01       	movw	r30, r8
    4194:	80 81       	ld	r24, Z
    4196:	91 81       	ldd	r25, Z+1	; 0x01
    4198:	80 0f       	add	r24, r16
    419a:	91 1f       	adc	r25, r17
    419c:	91 83       	std	Z+1, r25	; 0x01
    419e:	80 83       	st	Z, r24
      fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. Oznacza to przejście do kolejnego klastra
    41a0:	8b 81       	ldd	r24, Y+3	; 0x03
    41a2:	8f 5f       	subi	r24, 0xFF	; 255
    41a4:	8b 83       	std	Y+3, r24	; 0x03
    41a6:	00 e0       	ldi	r16, 0x00	; 0
    41a8:	11 e0       	ldi	r17, 0x01	; 1
    41aa:	1a c0       	rjmp	.+52     	; 0x41e0 <ramDyskZapiszBlokDoPliku+0xe4>
      dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 bajtów
    }
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
    41ac:	b6 01       	movw	r22, r12
    41ae:	a7 01       	movw	r20, r14
    41b0:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
    41b4:	8a 81       	ldd	r24, Y+2	; 0x02
    41b6:	8e 0d       	add	r24, r14
    41b8:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
    41ba:	f4 01       	movw	r30, r8
    41bc:	80 81       	ld	r24, Z
    41be:	91 81       	ldd	r25, Z+1	; 0x01
    41c0:	8e 0d       	add	r24, r14
    41c2:	9f 1d       	adc	r25, r15
    41c4:	91 83       	std	Z+1, r25	; 0x01
    41c6:	80 83       	st	Z, r24
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    41c8:	8b 2d       	mov	r24, r11
    41ca:	90 e0       	ldi	r25, 0x00	; 0
    41cc:	80 58       	subi	r24, 0x80	; 128
    41ce:	9f 4f       	sbci	r25, 0xFF	; 255
    41d0:	98 2f       	mov	r25, r24
    41d2:	88 27       	eor	r24, r24
    41d4:	2a 81       	ldd	r18, Y+2	; 0x02
    41d6:	82 0f       	add	r24, r18
    41d8:	91 1d       	adc	r25, r1
    41da:	99 83       	std	Y+1, r25	; 0x01
    41dc:	88 83       	st	Y, r24
    41de:	04 c0       	rjmp	.+8      	; 0x41e8 <ramDyskZapiszBlokDoPliku+0xec>
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
  uint16_t doZapisu = *dlugosc;
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
    41e0:	e1 14       	cp	r14, r1
    41e2:	f1 04       	cpc	r15, r1
    41e4:	09 f0       	breq	.+2      	; 0x41e8 <ramDyskZapiszBlokDoPliku+0xec>
    41e6:	ae cf       	rjmp	.-164    	; 0x4144 <ramDyskZapiszBlokDoPliku+0x48>
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    41e8:	ec 81       	ldd	r30, Y+4	; 0x04
    41ea:	fd 81       	ldd	r31, Y+5	; 0x05
    41ec:	92 81       	ldd	r25, Z+2	; 0x02
    41ee:	8b 81       	ldd	r24, Y+3	; 0x03
    41f0:	98 17       	cp	r25, r24
    41f2:	29 f4       	brne	.+10     	; 0x41fe <ramDyskZapiszBlokDoPliku+0x102>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    41f4:	9a 81       	ldd	r25, Y+2	; 0x02
    41f6:	81 81       	ldd	r24, Z+1	; 0x01
    41f8:	89 17       	cp	r24, r25
    41fa:	08 f4       	brcc	.+2      	; 0x41fe <ramDyskZapiszBlokDoPliku+0x102>
      fd->wpis->rozmiarLo = fd->IndLo;
    41fc:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    41fe:	ec 81       	ldd	r30, Y+4	; 0x04
    4200:	fd 81       	ldd	r31, Y+5	; 0x05
    4202:	92 81       	ldd	r25, Z+2	; 0x02
    4204:	8b 81       	ldd	r24, Y+3	; 0x03
    4206:	98 17       	cp	r25, r24
    4208:	30 f4       	brcc	.+12     	; 0x4216 <ramDyskZapiszBlokDoPliku+0x11a>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    420a:	8a 81       	ldd	r24, Y+2	; 0x02
    420c:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    420e:	ec 81       	ldd	r30, Y+4	; 0x04
    4210:	fd 81       	ldd	r31, Y+5	; 0x05
    4212:	8b 81       	ldd	r24, Y+3	; 0x03
    4214:	82 83       	std	Z+2, r24	; 0x02
    4216:	80 e0       	ldi	r24, 0x00	; 0
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}
    4218:	df 91       	pop	r29
    421a:	cf 91       	pop	r28
    421c:	1f 91       	pop	r17
    421e:	0f 91       	pop	r16
    4220:	ff 90       	pop	r15
    4222:	ef 90       	pop	r14
    4224:	df 90       	pop	r13
    4226:	cf 90       	pop	r12
    4228:	bf 90       	pop	r11
    422a:	9f 90       	pop	r9
    422c:	8f 90       	pop	r8
    422e:	08 95       	ret

00004230 <znajdzPlik>:
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
{
    4230:	af 92       	push	r10
    4232:	bf 92       	push	r11
    4234:	cf 92       	push	r12
    4236:	df 92       	push	r13
    4238:	ef 92       	push	r14
    423a:	ff 92       	push	r15
    423c:	0f 93       	push	r16
    423e:	1f 93       	push	r17
    4240:	cf 93       	push	r28
    4242:	df 93       	push	r29
    4244:	6c 01       	movw	r12, r24
  uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
    4246:	fc 01       	movw	r30, r24
    4248:	01 90       	ld	r0, Z+
    424a:	00 20       	and	r0, r0
    424c:	e9 f7       	brne	.-6      	; 0x4248 <znajdzPlik+0x18>
    424e:	31 97       	sbiw	r30, 0x01	; 1
    4250:	fe 2e       	mov	r15, r30
    4252:	f8 1a       	sub	r15, r24
    4254:	88 e0       	ldi	r24, 0x08	; 8
    4256:	8f 15       	cp	r24, r15
    4258:	10 f4       	brcc	.+4      	; 0x425e <znajdzPlik+0x2e>
    425a:	a8 e0       	ldi	r26, 0x08	; 8
    425c:	fa 2e       	mov	r15, r26
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  
  if (nazwa[dlNazwy-1] == 0)
    425e:	f6 01       	movw	r30, r12
    4260:	ef 0d       	add	r30, r15
    4262:	f1 1d       	adc	r31, r1
    4264:	31 97       	sbiw	r30, 0x01	; 1
    4266:	80 81       	ld	r24, Z
    4268:	88 23       	and	r24, r24
    426a:	09 f4       	brne	.+2      	; 0x426e <znajdzPlik+0x3e>
    dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
    426c:	fa 94       	dec	r15
    426e:	f6 01       	movw	r30, r12
    4270:	91 e0       	ldi	r25, 0x01	; 1
    4272:	07 c0       	rjmp	.+14     	; 0x4282 <znajdzPlik+0x52>
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    4274:	81 81       	ldd	r24, Z+1	; 0x01
    4276:	31 96       	adiw	r30, 0x01	; 1
    4278:	80 32       	cpi	r24, 0x20	; 32
    427a:	11 f4       	brne	.+4      	; 0x4280 <znajdzPlik+0x50>
    427c:	f9 2e       	mov	r15, r25
    427e:	05 c0       	rjmp	.+10     	; 0x428a <znajdzPlik+0x5a>
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    4280:	9f 5f       	subi	r25, 0xFF	; 255
    4282:	9f 15       	cp	r25, r15
    4284:	b8 f3       	brcs	.-18     	; 0x4274 <znajdzPlik+0x44>
    {
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    4286:	ff 20       	and	r15, r15
    4288:	29 f1       	breq	.+74     	; 0x42d4 <znajdzPlik+0xa4>
    428a:	ee 24       	eor	r14, r14
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    428c:	0e 2d       	mov	r16, r14
    428e:	10 e0       	ldi	r17, 0x00	; 0
    4290:	00 58       	subi	r16, 0x80	; 128
    4292:	1f 4f       	sbci	r17, 0xFF	; 255
    4294:	d0 2f       	mov	r29, r16
    4296:	cc 27       	eor	r28, r28
    4298:	00 58       	subi	r16, 0x80	; 128
    429a:	10 40       	sbci	r17, 0x00	; 0
    for (temp=0; temp <16; temp++)
    429c:	e0 ef       	ldi	r30, 0xF0	; 240
    429e:	ae 2e       	mov	r10, r30
    42a0:	b1 2c       	mov	r11, r1
    42a2:	ac 0e       	add	r10, r28
    42a4:	bd 1e       	adc	r11, r29
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    42a6:	be 01       	movw	r22, r28
    42a8:	6c 5f       	subi	r22, 0xFC	; 252
    42aa:	7f 4f       	sbci	r23, 0xFF	; 255
    42ac:	c6 01       	movw	r24, r12
    42ae:	4f 2d       	mov	r20, r15
    42b0:	50 e0       	ldi	r21, 0x00	; 0
    42b2:	0e 94 78 5c 	call	0xb8f0	; 0xb8f0 <strncmp>
    42b6:	00 97       	sbiw	r24, 0x00	; 0
    42b8:	79 f0       	breq	.+30     	; 0x42d8 <znajdzPlik+0xa8>
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    42ba:	ca 15       	cp	r28, r10
    42bc:	db 05       	cpc	r29, r11
    42be:	11 f0       	breq	.+4      	; 0x42c4 <znajdzPlik+0x94>
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    42c0:	60 96       	adiw	r28, 0x10	; 16
    42c2:	f1 cf       	rjmp	.-30     	; 0x42a6 <znajdzPlik+0x76>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    42c4:	02 53       	subi	r16, 0x32	; 50
    42c6:	11 4f       	sbci	r17, 0xF1	; 241
    42c8:	f8 01       	movw	r30, r16
    42ca:	80 81       	ld	r24, Z
  }
  while (tempKlaster2 != tempKlaster);
    42cc:	e8 16       	cp	r14, r24
    42ce:	11 f0       	breq	.+4      	; 0x42d4 <znajdzPlik+0xa4>
    42d0:	e8 2e       	mov	r14, r24
    42d2:	dc cf       	rjmp	.-72     	; 0x428c <znajdzPlik+0x5c>
    42d4:	c0 e0       	ldi	r28, 0x00	; 0
    42d6:	d0 e0       	ldi	r29, 0x00	; 0
  return NULL;
}
    42d8:	ce 01       	movw	r24, r28
    42da:	df 91       	pop	r29
    42dc:	cf 91       	pop	r28
    42de:	1f 91       	pop	r17
    42e0:	0f 91       	pop	r16
    42e2:	ff 90       	pop	r15
    42e4:	ef 90       	pop	r14
    42e6:	df 90       	pop	r13
    42e8:	cf 90       	pop	r12
    42ea:	bf 90       	pop	r11
    42ec:	af 90       	pop	r10
    42ee:	08 95       	ret

000042f0 <ramDyskUsunPlik>:
  }
  return wynik;
}

uint8_t ramDyskUsunPlik(const char *nazwa)
{
    42f0:	cf 93       	push	r28
    42f2:	df 93       	push	r29
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    42f4:	0e 94 18 21 	call	0x4230	; 0x4230 <znajdzPlik>
    42f8:	ec 01       	movw	r28, r24
    42fa:	00 97       	sbiw	r24, 0x00	; 0
    42fc:	11 f4       	brne	.+4      	; 0x4302 <ramDyskUsunPlik+0x12>
    42fe:	81 e0       	ldi	r24, 0x01	; 1
    4300:	1c c0       	rjmp	.+56     	; 0x433a <ramDyskUsunPlik+0x4a>
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    4302:	8b 81       	ldd	r24, Y+3	; 0x03
    4304:	88 23       	and	r24, r24
    4306:	81 f0       	breq	.+32     	; 0x4328 <ramDyskUsunPlik+0x38>
    4308:	82 e0       	ldi	r24, 0x02	; 2
    430a:	17 c0       	rjmp	.+46     	; 0x433a <ramDyskUsunPlik+0x4a>
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
  {
    usuwanyKlaster = plik->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatniego klastra
    430c:	a8 2f       	mov	r26, r24
    430e:	b0 e0       	ldi	r27, 0x00	; 0
    4310:	fd 01       	movw	r30, r26
    4312:	e2 53       	subi	r30, 0x32	; 50
    4314:	f1 4f       	sbci	r31, 0xF1	; 241
    4316:	e0 81       	ld	r30, Z
    4318:	e8 17       	cp	r30, r24
    431a:	11 f4       	brne	.+4      	; 0x4320 <ramDyskUsunPlik+0x30>
      plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    431c:	18 82       	st	Y, r1
    431e:	01 c0       	rjmp	.+2      	; 0x4322 <ramDyskUsunPlik+0x32>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    4320:	e8 83       	st	Y, r30
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
    4322:	a2 53       	subi	r26, 0x32	; 50
    4324:	b1 4f       	sbci	r27, 0xF1	; 241
    4326:	1c 92       	st	X, r1
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    4328:	88 81       	ld	r24, Y
    432a:	88 23       	and	r24, r24
    432c:	79 f7       	brne	.-34     	; 0x430c <ramDyskUsunPlik+0x1c>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
    432e:	80 e1       	ldi	r24, 0x10	; 16
    4330:	fe 01       	movw	r30, r28
    4332:	11 92       	st	Z+, r1
    4334:	8a 95       	dec	r24
    4336:	e9 f7       	brne	.-6      	; 0x4332 <ramDyskUsunPlik+0x42>
    4338:	80 e0       	ldi	r24, 0x00	; 0
//relokacjaTablicyWpisow()
  return 0;
}
    433a:	df 91       	pop	r29
    433c:	cf 91       	pop	r28
    433e:	08 95       	ret

00004340 <ramDyskOtworzPlik>:
  }
  return 1;
}

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
    4340:	cf 93       	push	r28
    4342:	df 93       	push	r29
    4344:	eb 01       	movw	r28, r22
  uint8_t wynik = 1;
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    4346:	0e 94 18 21 	call	0x4230	; 0x4230 <znajdzPlik>
    434a:	fc 01       	movw	r30, r24
    434c:	00 97       	sbiw	r24, 0x00	; 0
    434e:	11 f4       	brne	.+4      	; 0x4354 <ramDyskOtworzPlik+0x14>
    4350:	81 e0       	ldi	r24, 0x01	; 1
    4352:	0b c0       	rjmp	.+22     	; 0x436a <ramDyskOtworzPlik+0x2a>
  {
    memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
    4354:	83 e0       	ldi	r24, 0x03	; 3
    4356:	de 01       	movw	r26, r28
    4358:	1d 92       	st	X+, r1
    435a:	8a 95       	dec	r24
    435c:	e9 f7       	brne	.-6      	; 0x4358 <ramDyskOtworzPlik+0x18>
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    435e:	fd 83       	std	Y+5, r31	; 0x05
    4360:	ec 83       	std	Y+4, r30	; 0x04
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    4362:	83 81       	ldd	r24, Z+3	; 0x03
    4364:	8f 5f       	subi	r24, 0xFF	; 255
    4366:	83 83       	std	Z+3, r24	; 0x03
    4368:	80 e0       	ldi	r24, 0x00	; 0
    wynik = 0;
  }
  return wynik;
}
    436a:	df 91       	pop	r29
    436c:	cf 91       	pop	r28
    436e:	08 95       	ret

00004370 <ramDyskOtworzPlikStdIo>:
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
}

uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags)
{
    4370:	ff 92       	push	r15
    4372:	0f 93       	push	r16
    4374:	1f 93       	push	r17
    4376:	cf 93       	push	r28
    4378:	df 93       	push	r29
    437a:	8b 01       	movw	r16, r22
    437c:	ea 01       	movw	r28, r20
    437e:	f2 2e       	mov	r15, r18
  uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
    4380:	0e 94 a0 21 	call	0x4340	; 0x4340 <ramDyskOtworzPlik>
    4384:	28 2f       	mov	r18, r24
  if (wynik != 0)
    4386:	88 23       	and	r24, r24
    4388:	59 f4       	brne	.+22     	; 0x43a0 <ramDyskOtworzPlikStdIo+0x30>
    return wynik;
  
  fdev_setup_stream(stream, putSTD, getSTD, flags);
    438a:	88 e6       	ldi	r24, 0x68	; 104
    438c:	9f e1       	ldi	r25, 0x1F	; 31
    438e:	99 87       	std	Y+9, r25	; 0x09
    4390:	88 87       	std	Y+8, r24	; 0x08
    4392:	8c ef       	ldi	r24, 0xFC	; 252
    4394:	9e e1       	ldi	r25, 0x1E	; 30
    4396:	9b 87       	std	Y+11, r25	; 0x0b
    4398:	8a 87       	std	Y+10, r24	; 0x0a
    439a:	fb 82       	std	Y+3, r15	; 0x03
  fdev_set_udata(stream, fd);
    439c:	1d 87       	std	Y+13, r17	; 0x0d
    439e:	0c 87       	std	Y+12, r16	; 0x0c
  return 0;
}
    43a0:	82 2f       	mov	r24, r18
    43a2:	df 91       	pop	r29
    43a4:	cf 91       	pop	r28
    43a6:	1f 91       	pop	r17
    43a8:	0f 91       	pop	r16
    43aa:	ff 90       	pop	r15
    43ac:	08 95       	ret

000043ae <ramDyskUtworzPlik>:
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
}
uint8_t ramDyskUtworzPlik(const char *nazwa)
{                                        //Nowo utworzony plik nie zajmuje żadnego klastra
    43ae:	ff 92       	push	r15
    43b0:	0f 93       	push	r16
    43b2:	1f 93       	push	r17
    43b4:	cf 93       	push	r28
    43b6:	df 93       	push	r29
    43b8:	08 2f       	mov	r16, r24
    43ba:	f9 2e       	mov	r15, r25
  uint8_t dlNazwy = strlen(nazwa);
    43bc:	a8 2f       	mov	r26, r24
    43be:	b9 2f       	mov	r27, r25
    43c0:	fd 01       	movw	r30, r26
    43c2:	01 90       	ld	r0, Z+
    43c4:	00 20       	and	r0, r0
    43c6:	e9 f7       	brne	.-6      	; 0x43c2 <ramDyskUtworzPlik+0x14>
    43c8:	31 97       	sbiw	r30, 0x01	; 1
    43ca:	1e 2f       	mov	r17, r30
    43cc:	18 1b       	sub	r17, r24
    43ce:	19 30       	cpi	r17, 0x09	; 9
    43d0:	08 f0       	brcs	.+2      	; 0x43d4 <ramDyskUtworzPlik+0x26>
    43d2:	18 e0       	ldi	r17, 0x08	; 8
    43d4:	80 2f       	mov	r24, r16
    43d6:	9f 2d       	mov	r25, r15
    43d8:	9c 01       	movw	r18, r24
    43da:	f9 01       	movw	r30, r18
    43dc:	90 e0       	ldi	r25, 0x00	; 0
    43de:	06 c0       	rjmp	.+12     	; 0x43ec <ramDyskUtworzPlik+0x3e>
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
  {  if (nazwa[i] == ' ')
    43e0:	81 91       	ld	r24, Z+
    43e2:	80 32       	cpi	r24, 0x20	; 32
    43e4:	11 f4       	brne	.+4      	; 0x43ea <ramDyskUtworzPlik+0x3c>
    43e6:	19 2f       	mov	r17, r25
    43e8:	03 c0       	rjmp	.+6      	; 0x43f0 <ramDyskUtworzPlik+0x42>
  uint8_t dlNazwy = strlen(nazwa);
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    43ea:	9f 5f       	subi	r25, 0xFF	; 255
    43ec:	91 17       	cp	r25, r17
    43ee:	c0 f3       	brcs	.-16     	; 0x43e0 <ramDyskUtworzPlik+0x32>
     {
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    43f0:	11 23       	and	r17, r17
    43f2:	09 f4       	brne	.+2      	; 0x43f6 <ramDyskUtworzPlik+0x48>
    43f4:	3f c0       	rjmp	.+126    	; 0x4474 <ramDyskUtworzPlik+0xc6>
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    43f6:	80 2f       	mov	r24, r16
    43f8:	9f 2d       	mov	r25, r15
    43fa:	0e 94 18 21 	call	0x4230	; 0x4230 <znajdzPlik>
    43fe:	89 2b       	or	r24, r25
    4400:	c9 f5       	brne	.+114    	; 0x4474 <ramDyskUtworzPlik+0xc6>
    4402:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t temp;
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    4404:	29 2f       	mov	r18, r25
    4406:	30 e0       	ldi	r19, 0x00	; 0
    4408:	20 58       	subi	r18, 0x80	; 128
    440a:	3f 4f       	sbci	r19, 0xFF	; 255
    440c:	d2 2f       	mov	r29, r18
    440e:	cc 27       	eor	r28, r28
    4410:	20 58       	subi	r18, 0x80	; 128
    4412:	30 40       	sbci	r19, 0x00	; 0
    for (temp=0; temp <16; temp++)
    4414:	ae 01       	movw	r20, r28
    4416:	40 51       	subi	r20, 0x10	; 16
    4418:	5f 4f       	sbci	r21, 0xFF	; 255
    {
      if (plik->nazwa[0] == 0)
    441a:	8c 81       	ldd	r24, Y+4	; 0x04
    441c:	88 23       	and	r24, r24
    441e:	b9 f0       	breq	.+46     	; 0x444e <ramDyskUtworzPlik+0xa0>
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    4420:	c4 17       	cp	r28, r20
    4422:	d5 07       	cpc	r29, r21
    4424:	11 f0       	breq	.+4      	; 0x442a <ramDyskUtworzPlik+0x7c>
    {
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    4426:	60 96       	adiw	r28, 0x10	; 16
    4428:	f8 cf       	rjmp	.-16     	; 0x441a <ramDyskUtworzPlik+0x6c>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    442a:	e9 01       	movw	r28, r18
    442c:	c2 53       	subi	r28, 0x32	; 50
    442e:	d1 4f       	sbci	r29, 0xF1	; 241
    4430:	88 81       	ld	r24, Y
  }
  while (tempKlaster2 != tempKlaster);
    4432:	98 17       	cp	r25, r24
    4434:	11 f0       	breq	.+4      	; 0x443a <ramDyskUtworzPlik+0x8c>
    4436:	98 2f       	mov	r25, r24
    4438:	e5 cf       	rjmp	.-54     	; 0x4404 <ramDyskUtworzPlik+0x56>
  
  klastry[tempKlaster] = znajdzWolnyKlaster();
    443a:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <znajdzWolnyKlaster>
    443e:	88 83       	st	Y, r24
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    4440:	88 23       	and	r24, r24
    4442:	d1 f0       	breq	.+52     	; 0x4478 <ramDyskUtworzPlik+0xca>
    plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
    4444:	90 e0       	ldi	r25, 0x00	; 0
    4446:	80 58       	subi	r24, 0x80	; 128
    4448:	9f 4f       	sbci	r25, 0xFF	; 255
    444a:	d8 2f       	mov	r29, r24
    444c:	cc 27       	eor	r28, r28
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
  }
  
  if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym pliku
    444e:	20 97       	sbiw	r28, 0x00	; 0
    4450:	99 f0       	breq	.+38     	; 0x4478 <ramDyskUtworzPlik+0xca>
  {
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    4452:	8c e0       	ldi	r24, 0x0C	; 12
    4454:	fe 01       	movw	r30, r28
    4456:	11 92       	st	Z+, r1
    4458:	8a 95       	dec	r24
    445a:	e9 f7       	brne	.-6      	; 0x4456 <ramDyskUtworzPlik+0xa8>
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    445c:	ce 01       	movw	r24, r28
    445e:	04 96       	adiw	r24, 0x04	; 4
    4460:	60 2f       	mov	r22, r16
    4462:	7f 2d       	mov	r23, r15
    4464:	41 2f       	mov	r20, r17
    4466:	50 e0       	ldi	r21, 0x00	; 0
    4468:	0e 94 86 5c 	call	0xb90c	; 0xb90c <strncpy>
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    446c:	1c 86       	std	Y+12, r1	; 0x0c
    446e:	1d 86       	std	Y+13, r1	; 0x0d
    4470:	1e 86       	std	Y+14, r1	; 0x0e
    4472:	1f 86       	std	Y+15, r1	; 0x0f
    return 0;                            
    4474:	80 e0       	ldi	r24, 0x00	; 0
    4476:	01 c0       	rjmp	.+2      	; 0x447a <ramDyskUtworzPlik+0xcc>
    4478:	81 e0       	ldi	r24, 0x01	; 1
  }
  return 1;
}
    447a:	df 91       	pop	r29
    447c:	cf 91       	pop	r28
    447e:	1f 91       	pop	r17
    4480:	0f 91       	pop	r16
    4482:	ff 90       	pop	r15
    4484:	08 95       	ret

00004486 <cmdLineGetLastArgIdx>:

uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
    4486:	dc 01       	movw	r26, r24
    4488:	12 96       	adiw	r26, 0x02	; 2
    448a:	ed 91       	ld	r30, X+
    448c:	fc 91       	ld	r31, X
    448e:	13 97       	sbiw	r26, 0x03	; 3
    4490:	80 e0       	ldi	r24, 0x00	; 0
    4492:	21 e0       	ldi	r18, 0x01	; 1
    4494:	09 c0       	rjmp	.+18     	; 0x44a8 <cmdLineGetLastArgIdx+0x22>
  while(*str != 0)
  {
    if (*str == ' ')
    4496:	90 32       	cpi	r25, 0x20	; 32
    4498:	11 f0       	breq	.+4      	; 0x449e <cmdLineGetLastArgIdx+0x18>
    449a:	20 e0       	ldi	r18, 0x00	; 0
    449c:	04 c0       	rjmp	.+8      	; 0x44a6 <cmdLineGetLastArgIdx+0x20>
    {
      if (lastWhite == 0)
    449e:	22 23       	and	r18, r18
    44a0:	09 f4       	brne	.+2      	; 0x44a4 <cmdLineGetLastArgIdx+0x1e>
        result++;
    44a2:	8f 5f       	subi	r24, 0xFF	; 255
    44a4:	21 e0       	ldi	r18, 0x01	; 1
      lastWhite = 1;
    }
    else
      lastWhite = 0;
    str++;
    44a6:	31 96       	adiw	r30, 0x01	; 1
uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    44a8:	90 81       	ld	r25, Z
    44aa:	99 23       	and	r25, r25
    44ac:	a1 f7       	brne	.-24     	; 0x4496 <cmdLineGetLastArgIdx+0x10>
    else
      lastWhite = 0;
    str++;
  }
  return result;
}
    44ae:	08 95       	ret

000044b0 <cmdlineGetArgStr>:

char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
{
    44b0:	58 2f       	mov	r21, r24
    44b2:	fb 01       	movw	r30, r22
  // find the offset of argument number [argnum]
  uint8_t idx=0;
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    44b4:	22 81       	ldd	r18, Z+2	; 0x02
    44b6:	33 81       	ldd	r19, Z+3	; 0x03
    44b8:	90 e0       	ldi	r25, 0x00	; 0
    44ba:	01 c0       	rjmp	.+2      	; 0x44be <cmdlineGetArgStr+0xe>
    44bc:	9f 5f       	subi	r25, 0xFF	; 255
    44be:	f9 01       	movw	r30, r18
    44c0:	e9 0f       	add	r30, r25
    44c2:	f1 1d       	adc	r31, r1
    44c4:	80 81       	ld	r24, Z
    44c6:	80 32       	cpi	r24, 0x20	; 32
    44c8:	c9 f3       	breq	.-14     	; 0x44bc <cmdlineGetArgStr+0xc>
    44ca:	40 e0       	ldi	r20, 0x00	; 0
    44cc:	12 c0       	rjmp	.+36     	; 0x44f2 <cmdlineGetArgStr+0x42>
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
  {
    // find the next whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    44ce:	9f 5f       	subi	r25, 0xFF	; 255
    44d0:	f9 01       	movw	r30, r18
    44d2:	e9 0f       	add	r30, r25
    44d4:	f1 1d       	adc	r31, r1
    44d6:	e0 81       	ld	r30, Z
    44d8:	ee 23       	and	r30, r30
    44da:	21 f0       	breq	.+8      	; 0x44e4 <cmdlineGetArgStr+0x34>
    44dc:	e0 32       	cpi	r30, 0x20	; 32
    44de:	b9 f7       	brne	.-18     	; 0x44ce <cmdlineGetArgStr+0x1e>
    44e0:	01 c0       	rjmp	.+2      	; 0x44e4 <cmdlineGetArgStr+0x34>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    44e2:	9f 5f       	subi	r25, 0xFF	; 255
    44e4:	f9 01       	movw	r30, r18
    44e6:	e9 0f       	add	r30, r25
    44e8:	f1 1d       	adc	r31, r1
    44ea:	80 81       	ld	r24, Z
    44ec:	80 32       	cpi	r24, 0x20	; 32
    44ee:	c9 f3       	breq	.-14     	; 0x44e2 <cmdlineGetArgStr+0x32>
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    44f0:	4f 5f       	subi	r20, 0xFF	; 255
    44f2:	45 17       	cp	r20, r21
    44f4:	68 f3       	brcs	.-38     	; 0x44d0 <cmdlineGetArgStr+0x20>
    44f6:	29 0f       	add	r18, r25
    44f8:	31 1d       	adc	r19, r1
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  }
  // we are at the requested argument or the end of the buffer
  return &state->CmdlineExcBuffer[idx];
}
    44fa:	c9 01       	movw	r24, r18
    44fc:	08 95       	ret

000044fe <cmdPrintHelp>:
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
}

void cmdPrintHelp(cmdState_t *state)
{
    44fe:	6f 92       	push	r6
    4500:	7f 92       	push	r7
    4502:	8f 92       	push	r8
    4504:	9f 92       	push	r9
    4506:	bf 92       	push	r11
    4508:	cf 92       	push	r12
    450a:	df 92       	push	r13
    450c:	ef 92       	push	r14
    450e:	ff 92       	push	r15
    4510:	0f 93       	push	r16
    4512:	1f 93       	push	r17
    4514:	df 93       	push	r29
    4516:	cf 93       	push	r28
    4518:	00 d0       	rcall	.+0      	; 0x451a <cmdPrintHelp+0x1c>
    451a:	00 d0       	rcall	.+0      	; 0x451c <cmdPrintHelp+0x1e>
    451c:	00 d0       	rcall	.+0      	; 0x451e <cmdPrintHelp+0x20>
    451e:	cd b7       	in	r28, 0x3d	; 61
    4520:	de b7       	in	r29, 0x3e	; 62
    4522:	7c 01       	movw	r14, r24
  command_t  tmp;
  const command_t *tmpPtr = state->cmdList;
    4524:	fc 01       	movw	r30, r24
    4526:	c1 a0       	ldd	r12, Z+33	; 0x21
    4528:	d2 a0       	ldd	r13, Z+34	; 0x22
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    452a:	8e 01       	movw	r16, r28
    452c:	0f 5f       	subi	r16, 0xFF	; 255
    452e:	1f 4f       	sbci	r17, 0xFF	; 255
    4530:	c8 01       	movw	r24, r16
    4532:	b6 01       	movw	r22, r12
    4534:	46 e0       	ldi	r20, 0x06	; 6
    4536:	50 e0       	ldi	r21, 0x00	; 0
    4538:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <memcpy_P>
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    fprintf_P(state->myStdInOut, PSTR("\t"));
    453c:	9b e9       	ldi	r25, 0x9B	; 155
    453e:	69 2e       	mov	r6, r25
    4540:	9b e0       	ldi	r25, 0x0B	; 11
    4542:	79 2e       	mov	r7, r25
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4544:	88 e9       	ldi	r24, 0x98	; 152
    4546:	88 2e       	mov	r8, r24
    4548:	8b e0       	ldi	r24, 0x0B	; 11
    454a:	98 2e       	mov	r9, r24

    tmpPtr++;
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    454c:	b0 2e       	mov	r11, r16
    454e:	01 2f       	mov	r16, r17
  const command_t *tmpPtr = state->cmdList;
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    4550:	00 d0       	rcall	.+0      	; 0x4552 <cmdPrintHelp+0x54>
    4552:	00 d0       	rcall	.+0      	; 0x4554 <cmdPrintHelp+0x56>
    4554:	f7 01       	movw	r30, r14
    4556:	82 8d       	ldd	r24, Z+26	; 0x1a
    4558:	93 8d       	ldd	r25, Z+27	; 0x1b
    455a:	ed b7       	in	r30, 0x3d	; 61
    455c:	fe b7       	in	r31, 0x3e	; 62
    455e:	92 83       	std	Z+2, r25	; 0x02
    4560:	81 83       	std	Z+1, r24	; 0x01
    4562:	89 81       	ldd	r24, Y+1	; 0x01
    4564:	9a 81       	ldd	r25, Y+2	; 0x02
    4566:	94 83       	std	Z+4, r25	; 0x04
    4568:	83 83       	std	Z+3, r24	; 0x03
    456a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\t"));
    456e:	f7 01       	movw	r30, r14
    4570:	82 8d       	ldd	r24, Z+26	; 0x1a
    4572:	93 8d       	ldd	r25, Z+27	; 0x1b
    4574:	ed b7       	in	r30, 0x3d	; 61
    4576:	fe b7       	in	r31, 0x3e	; 62
    4578:	92 83       	std	Z+2, r25	; 0x02
    457a:	81 83       	std	Z+1, r24	; 0x01
    457c:	74 82       	std	Z+4, r7	; 0x04
    457e:	63 82       	std	Z+3, r6	; 0x03
    4580:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    4584:	f7 01       	movw	r30, r14
    4586:	82 8d       	ldd	r24, Z+26	; 0x1a
    4588:	93 8d       	ldd	r25, Z+27	; 0x1b
    458a:	ed b7       	in	r30, 0x3d	; 61
    458c:	fe b7       	in	r31, 0x3e	; 62
    458e:	92 83       	std	Z+2, r25	; 0x02
    4590:	81 83       	std	Z+1, r24	; 0x01
    4592:	8b 81       	ldd	r24, Y+3	; 0x03
    4594:	9c 81       	ldd	r25, Y+4	; 0x04
    4596:	94 83       	std	Z+4, r25	; 0x04
    4598:	83 83       	std	Z+3, r24	; 0x03
    459a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    459e:	f7 01       	movw	r30, r14
    45a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    45a2:	93 8d       	ldd	r25, Z+27	; 0x1b
    45a4:	ed b7       	in	r30, 0x3d	; 61
    45a6:	fe b7       	in	r31, 0x3e	; 62
    45a8:	92 83       	std	Z+2, r25	; 0x02
    45aa:	81 83       	std	Z+1, r24	; 0x01
    45ac:	94 82       	std	Z+4, r9	; 0x04
    45ae:	83 82       	std	Z+3, r8	; 0x03
    45b0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>

    tmpPtr++;
    45b4:	86 e0       	ldi	r24, 0x06	; 6
    45b6:	90 e0       	ldi	r25, 0x00	; 0
    45b8:	c8 0e       	add	r12, r24
    45ba:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    45bc:	0f 90       	pop	r0
    45be:	0f 90       	pop	r0
    45c0:	0f 90       	pop	r0
    45c2:	0f 90       	pop	r0
    45c4:	8b 2d       	mov	r24, r11
    45c6:	90 2f       	mov	r25, r16
    45c8:	b6 01       	movw	r22, r12
    45ca:	46 e0       	ldi	r20, 0x06	; 6
    45cc:	50 e0       	ldi	r21, 0x00	; 0
    45ce:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <memcpy_P>
  }
  while (tmp.commandFun != NULL);
    45d2:	8d 81       	ldd	r24, Y+5	; 0x05
    45d4:	9e 81       	ldd	r25, Y+6	; 0x06
    45d6:	89 2b       	or	r24, r25
    45d8:	09 f0       	breq	.+2      	; 0x45dc <cmdPrintHelp+0xde>
    45da:	ba cf       	rjmp	.-140    	; 0x4550 <cmdPrintHelp+0x52>
}
    45dc:	26 96       	adiw	r28, 0x06	; 6
    45de:	0f b6       	in	r0, 0x3f	; 63
    45e0:	f8 94       	cli
    45e2:	de bf       	out	0x3e, r29	; 62
    45e4:	0f be       	out	0x3f, r0	; 63
    45e6:	cd bf       	out	0x3d, r28	; 61
    45e8:	cf 91       	pop	r28
    45ea:	df 91       	pop	r29
    45ec:	1f 91       	pop	r17
    45ee:	0f 91       	pop	r16
    45f0:	ff 90       	pop	r15
    45f2:	ef 90       	pop	r14
    45f4:	df 90       	pop	r13
    45f6:	cf 90       	pop	r12
    45f8:	bf 90       	pop	r11
    45fa:	9f 90       	pop	r9
    45fc:	8f 90       	pop	r8
    45fe:	7f 90       	pop	r7
    4600:	6f 90       	pop	r6
    4602:	08 95       	ret

00004604 <cmdlineGetArgHex>:
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
}

// return argument [argnum] interpreted as a hex integer
long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
{
    4604:	df 93       	push	r29
    4606:	cf 93       	push	r28
    4608:	00 d0       	rcall	.+0      	; 0x460a <cmdlineGetArgHex+0x6>
    460a:	cd b7       	in	r28, 0x3d	; 61
    460c:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
    460e:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    4612:	be 01       	movw	r22, r28
    4614:	6f 5f       	subi	r22, 0xFF	; 255
    4616:	7f 4f       	sbci	r23, 0xFF	; 255
    4618:	40 e1       	ldi	r20, 0x10	; 16
    461a:	50 e0       	ldi	r21, 0x00	; 0
    461c:	0e 94 08 5b 	call	0xb610	; 0xb610 <strtol>
}
    4620:	0f 90       	pop	r0
    4622:	0f 90       	pop	r0
    4624:	cf 91       	pop	r28
    4626:	df 91       	pop	r29
    4628:	08 95       	ret

0000462a <cmdlineGetArgInt>:
  return &state->CmdlineExcBuffer[idx];
}

// return argument [argnum] interpreted as a decimal integer
long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
{
    462a:	df 93       	push	r29
    462c:	cf 93       	push	r28
    462e:	00 d0       	rcall	.+0      	; 0x4630 <cmdlineGetArgInt+0x6>
    4630:	cd b7       	in	r28, 0x3d	; 61
    4632:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
    4634:	0e 94 58 22 	call	0x44b0	; 0x44b0 <cmdlineGetArgStr>
    4638:	be 01       	movw	r22, r28
    463a:	6f 5f       	subi	r22, 0xFF	; 255
    463c:	7f 4f       	sbci	r23, 0xFF	; 255
    463e:	4a e0       	ldi	r20, 0x0A	; 10
    4640:	50 e0       	ldi	r21, 0x00	; 0
    4642:	0e 94 08 5b 	call	0xb610	; 0xb610 <strtol>
}
    4646:	0f 90       	pop	r0
    4648:	0f 90       	pop	r0
    464a:	cf 91       	pop	r28
    464c:	df 91       	pop	r29
    464e:	08 95       	ret

00004650 <cmdlinePrintPrompt>:
    cmdlinePrintPrompt(state);                  // output new prompt
  }
}

void cmdlinePrintPrompt(cmdState_t *state)
{
    4650:	0f 93       	push	r16
    4652:	1f 93       	push	r17
    4654:	cf 93       	push	r28
    4656:	df 93       	push	r29
    4658:	8c 01       	movw	r16, r24
  const char* ptr;
  // print a new command prompt
  switch (state->cliMode)
    465a:	fc 01       	movw	r30, r24
    465c:	80 a1       	ldd	r24, Z+32	; 0x20
    465e:	81 30       	cpi	r24, 0x01	; 1
    4660:	19 f0       	breq	.+6      	; 0x4668 <cmdlinePrintPrompt+0x18>
    4662:	82 30       	cpi	r24, 0x02	; 2
    4664:	21 f4       	brne	.+8      	; 0x466e <cmdlinePrintPrompt+0x1e>
    4666:	06 c0       	rjmp	.+12     	; 0x4674 <cmdlinePrintPrompt+0x24>
    4668:	cb e7       	ldi	r28, 0x7B	; 123
    466a:	db e0       	ldi	r29, 0x0B	; 11
    466c:	0f c0       	rjmp	.+30     	; 0x468c <cmdlinePrintPrompt+0x3c>
    466e:	c4 e7       	ldi	r28, 0x74	; 116
    4670:	db e0       	ldi	r29, 0x0B	; 11
    4672:	0c c0       	rjmp	.+24     	; 0x468c <cmdlinePrintPrompt+0x3c>
    4674:	c2 e8       	ldi	r28, 0x82	; 130
    4676:	db e0       	ldi	r29, 0x0B	; 11
    4678:	09 c0       	rjmp	.+18     	; 0x468c <cmdlinePrintPrompt+0x3c>
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    467a:	21 96       	adiw	r28, 0x01	; 1
    467c:	f9 01       	movw	r30, r18
    467e:	84 91       	lpm	r24, Z+
    4680:	f8 01       	movw	r30, r16
    4682:	62 8d       	ldd	r22, Z+26	; 0x1a
    4684:	73 8d       	ldd	r23, Z+27	; 0x1b
    4686:	90 e0       	ldi	r25, 0x00	; 0
    4688:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    468c:	9e 01       	movw	r18, r28
      break;
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    468e:	fe 01       	movw	r30, r28
    4690:	84 91       	lpm	r24, Z+
    4692:	88 23       	and	r24, r24
    4694:	91 f7       	brne	.-28     	; 0x467a <cmdlinePrintPrompt+0x2a>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
}
    4696:	df 91       	pop	r29
    4698:	cf 91       	pop	r28
    469a:	1f 91       	pop	r17
    469c:	0f 91       	pop	r16
    469e:	08 95       	ret

000046a0 <cmdlineMainLoop>:
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
}

void cmdlineMainLoop(cmdState_t *state)
{
    46a0:	cf 93       	push	r28
    46a2:	df 93       	push	r29
    46a4:	ec 01       	movw	r28, r24
  cliExRes_t result;
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
    46a6:	8f 89       	ldd	r24, Y+23	; 0x17
    46a8:	98 8d       	ldd	r25, Y+24	; 0x18
    46aa:	89 2b       	or	r24, r25
    46ac:	09 f4       	brne	.+2      	; 0x46b0 <cmdlineMainLoop+0x10>
    46ae:	86 c0       	rjmp	.+268    	; 0x47bc <cmdlineMainLoop+0x11c>
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    46b0:	ce 01       	movw	r24, r28
    46b2:	0e 94 43 22 	call	0x4486	; 0x4486 <cmdLineGetLastArgIdx>
    46b6:	89 8f       	std	Y+25, r24	; 0x19
    result = state->CmdlineExecFunction(state); // run it
    46b8:	ef 89       	ldd	r30, Y+23	; 0x17
    46ba:	f8 8d       	ldd	r31, Y+24	; 0x18
    46bc:	ce 01       	movw	r24, r28
    46be:	09 95       	icall
    
    switch(result)
    46c0:	82 30       	cpi	r24, 0x02	; 2
    46c2:	91 05       	cpc	r25, r1
    46c4:	d1 f0       	breq	.+52     	; 0x46fa <cmdlineMainLoop+0x5a>
    46c6:	83 30       	cpi	r24, 0x03	; 3
    46c8:	91 05       	cpc	r25, r1
    46ca:	20 f4       	brcc	.+8      	; 0x46d4 <cmdlineMainLoop+0x34>
    46cc:	01 97       	sbiw	r24, 0x01	; 1
    46ce:	09 f0       	breq	.+2      	; 0x46d2 <cmdlineMainLoop+0x32>
    46d0:	6c c0       	rjmp	.+216    	; 0x47aa <cmdlineMainLoop+0x10a>
    46d2:	08 c0       	rjmp	.+16     	; 0x46e4 <cmdlineMainLoop+0x44>
    46d4:	84 30       	cpi	r24, 0x04	; 4
    46d6:	91 05       	cpc	r25, r1
    46d8:	09 f4       	brne	.+2      	; 0x46dc <cmdlineMainLoop+0x3c>
    46da:	4a c0       	rjmp	.+148    	; 0x4770 <cmdlineMainLoop+0xd0>
    46dc:	05 97       	sbiw	r24, 0x05	; 5
    46de:	09 f0       	breq	.+2      	; 0x46e2 <cmdlineMainLoop+0x42>
    46e0:	64 c0       	rjmp	.+200    	; 0x47aa <cmdlineMainLoop+0x10a>
    46e2:	51 c0       	rjmp	.+162    	; 0x4786 <cmdlineMainLoop+0xe6>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
    46e4:	00 d0       	rcall	.+0      	; 0x46e6 <cmdlineMainLoop+0x46>
    46e6:	00 d0       	rcall	.+0      	; 0x46e8 <cmdlineMainLoop+0x48>
    46e8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    46ea:	9b 8d       	ldd	r25, Y+27	; 0x1b
    46ec:	ed b7       	in	r30, 0x3d	; 61
    46ee:	fe b7       	in	r31, 0x3e	; 62
    46f0:	92 83       	std	Z+2, r25	; 0x02
    46f2:	81 83       	std	Z+1, r24	; 0x01
    46f4:	81 ee       	ldi	r24, 0xE1	; 225
    46f6:	9b e0       	ldi	r25, 0x0B	; 11
    46f8:	50 c0       	rjmp	.+160    	; 0x479a <cmdlineMainLoop+0xfa>
        break;
      case SYNTAX_ERROR:
        fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
    46fa:	00 d0       	rcall	.+0      	; 0x46fc <cmdlineMainLoop+0x5c>
    46fc:	00 d0       	rcall	.+0      	; 0x46fe <cmdlineMainLoop+0x5e>
    46fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4700:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4702:	ed b7       	in	r30, 0x3d	; 61
    4704:	fe b7       	in	r31, 0x3e	; 62
    4706:	92 83       	std	Z+2, r25	; 0x02
    4708:	81 83       	std	Z+1, r24	; 0x01
    470a:	8d ec       	ldi	r24, 0xCD	; 205
    470c:	9b e0       	ldi	r25, 0x0B	; 11
    470e:	94 83       	std	Z+4, r25	; 0x04
    4710:	83 83       	std	Z+3, r24	; 0x03
    4712:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_str);
    4716:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4718:	9b 8d       	ldd	r25, Y+27	; 0x1b
    471a:	ed b7       	in	r30, 0x3d	; 61
    471c:	fe b7       	in	r31, 0x3e	; 62
    471e:	92 83       	std	Z+2, r25	; 0x02
    4720:	81 83       	std	Z+1, r24	; 0x01
    4722:	8b 89       	ldd	r24, Y+19	; 0x13
    4724:	9c 89       	ldd	r25, Y+20	; 0x14
    4726:	94 83       	std	Z+4, r25	; 0x04
    4728:	83 83       	std	Z+3, r24	; 0x03
    472a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR(" "));
    472e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4730:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4732:	ed b7       	in	r30, 0x3d	; 61
    4734:	fe b7       	in	r31, 0x3e	; 62
    4736:	92 83       	std	Z+2, r25	; 0x02
    4738:	81 83       	std	Z+1, r24	; 0x01
    473a:	8b ec       	ldi	r24, 0xCB	; 203
    473c:	9b e0       	ldi	r25, 0x0B	; 11
    473e:	94 83       	std	Z+4, r25	; 0x04
    4740:	83 83       	std	Z+3, r24	; 0x03
    4742:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_help_str);
    4746:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4748:	9b 8d       	ldd	r25, Y+27	; 0x1b
    474a:	ed b7       	in	r30, 0x3d	; 61
    474c:	fe b7       	in	r31, 0x3e	; 62
    474e:	92 83       	std	Z+2, r25	; 0x02
    4750:	81 83       	std	Z+1, r24	; 0x01
    4752:	8d 89       	ldd	r24, Y+21	; 0x15
    4754:	9e 89       	ldd	r25, Y+22	; 0x16
    4756:	94 83       	std	Z+4, r25	; 0x04
    4758:	83 83       	std	Z+3, r24	; 0x03
    475a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR("\r\n"));
    475e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4760:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4762:	ed b7       	in	r30, 0x3d	; 61
    4764:	fe b7       	in	r31, 0x3e	; 62
    4766:	92 83       	std	Z+2, r25	; 0x02
    4768:	81 83       	std	Z+1, r24	; 0x01
    476a:	88 ec       	ldi	r24, 0xC8	; 200
    476c:	9b e0       	ldi	r25, 0x0B	; 11
    476e:	15 c0       	rjmp	.+42     	; 0x479a <cmdlineMainLoop+0xfa>
        break;
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
    4770:	00 d0       	rcall	.+0      	; 0x4772 <cmdlineMainLoop+0xd2>
    4772:	00 d0       	rcall	.+0      	; 0x4774 <cmdlineMainLoop+0xd4>
    4774:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4776:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4778:	ed b7       	in	r30, 0x3d	; 61
    477a:	fe b7       	in	r31, 0x3e	; 62
    477c:	92 83       	std	Z+2, r25	; 0x02
    477e:	81 83       	std	Z+1, r24	; 0x01
    4780:	85 eb       	ldi	r24, 0xB5	; 181
    4782:	9b e0       	ldi	r25, 0x0B	; 11
    4784:	0a c0       	rjmp	.+20     	; 0x479a <cmdlineMainLoop+0xfa>
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    4786:	00 d0       	rcall	.+0      	; 0x4788 <cmdlineMainLoop+0xe8>
    4788:	00 d0       	rcall	.+0      	; 0x478a <cmdlineMainLoop+0xea>
    478a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    478c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    478e:	ed b7       	in	r30, 0x3d	; 61
    4790:	fe b7       	in	r31, 0x3e	; 62
    4792:	92 83       	std	Z+2, r25	; 0x02
    4794:	81 83       	std	Z+1, r24	; 0x01
    4796:	8d e9       	ldi	r24, 0x9D	; 157
    4798:	9b e0       	ldi	r25, 0x0B	; 11
    479a:	94 83       	std	Z+4, r25	; 0x04
    479c:	83 83       	std	Z+3, r24	; 0x03
    479e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    47a2:	0f 90       	pop	r0
    47a4:	0f 90       	pop	r0
    47a6:	0f 90       	pop	r0
    47a8:	0f 90       	pop	r0
        break;
      default:
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    47aa:	18 8e       	std	Y+24, r1	; 0x18
    47ac:	1f 8a       	std	Y+23, r1	; 0x17
    state->command_str         = NULL;
    47ae:	1c 8a       	std	Y+20, r1	; 0x14
    47b0:	1b 8a       	std	Y+19, r1	; 0x13
    state->command_help_str    = NULL;
    47b2:	1e 8a       	std	Y+22, r1	; 0x16
    47b4:	1d 8a       	std	Y+21, r1	; 0x15
    cmdlinePrintPrompt(state);                  // output new prompt
    47b6:	ce 01       	movw	r24, r28
    47b8:	0e 94 28 23 	call	0x4650	; 0x4650 <cmdlinePrintPrompt>
  }
}
    47bc:	df 91       	pop	r29
    47be:	cf 91       	pop	r28
    47c0:	08 95       	ret

000047c2 <cmdlineRepaint>:
    state->CmdlineInputVT100State = 1;
  }
}

void cmdlineRepaint(cmdState_t *state, char *buf)
{
    47c2:	ef 92       	push	r14
    47c4:	ff 92       	push	r15
    47c6:	1f 93       	push	r17
    47c8:	cf 93       	push	r28
    47ca:	df 93       	push	r29
    47cc:	ec 01       	movw	r28, r24
    47ce:	7b 01       	movw	r14, r22
  uint8_t i;

  // carriage return
  fputc(ASCII_CR         , state->myStdInOut);
    47d0:	6a 8d       	ldd	r22, Y+26	; 0x1a
    47d2:	7b 8d       	ldd	r23, Y+27	; 0x1b
    47d4:	8d e0       	ldi	r24, 0x0D	; 13
    47d6:	90 e0       	ldi	r25, 0x00	; 0
    47d8:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
  // print fresh prompt
  cmdlinePrintPrompt(state);
    47dc:	ce 01       	movw	r24, r28
    47de:	0e 94 28 23 	call	0x4650	; 0x4650 <cmdlinePrintPrompt>
  // print the new command line buffer
  i = state->CmdlineBufferLength;
    47e2:	1d 85       	ldd	r17, Y+13	; 0x0d
    47e4:	0b c0       	rjmp	.+22     	; 0x47fc <cmdlineRepaint+0x3a>
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
    47e6:	f7 01       	movw	r30, r14
    47e8:	81 91       	ld	r24, Z+
    47ea:	7f 01       	movw	r14, r30
    47ec:	6a 8d       	ldd	r22, Y+26	; 0x1a
    47ee:	7b 8d       	ldd	r23, Y+27	; 0x1b
    47f0:	99 27       	eor	r25, r25
    47f2:	87 fd       	sbrc	r24, 7
    47f4:	90 95       	com	r25
    47f6:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    47fa:	11 50       	subi	r17, 0x01	; 1
  fputc(ASCII_CR         , state->myStdInOut);
  // print fresh prompt
  cmdlinePrintPrompt(state);
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    47fc:	11 23       	and	r17, r17
    47fe:	99 f7       	brne	.-26     	; 0x47e6 <cmdlineRepaint+0x24>
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    4800:	1c 85       	ldd	r17, Y+12	; 0x0c
    4802:	8d 85       	ldd	r24, Y+13	; 0x0d
    4804:	18 1b       	sub	r17, r24
    4806:	07 c0       	rjmp	.+14     	; 0x4816 <cmdlineRepaint+0x54>
  while (i--)
    fputc(' ', state->myStdInOut);
    4808:	6a 8d       	ldd	r22, Y+26	; 0x1a
    480a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    480c:	80 e2       	ldi	r24, 0x20	; 32
    480e:	90 e0       	ldi	r25, 0x00	; 0
    4810:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    4814:	11 50       	subi	r17, 0x01	; 1
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    4816:	11 23       	and	r17, r17
    4818:	b9 f7       	brne	.-18     	; 0x4808 <cmdlineRepaint+0x46>
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    481a:	1c 85       	ldd	r17, Y+12	; 0x0c
    481c:	8d 85       	ldd	r24, Y+13	; 0x0d
    481e:	18 1b       	sub	r17, r24
    4820:	07 c0       	rjmp	.+14     	; 0x4830 <cmdlineRepaint+0x6e>
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
    4822:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4824:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4826:	88 e0       	ldi	r24, 0x08	; 8
    4828:	90 e0       	ldi	r25, 0x00	; 0
    482a:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    482e:	11 50       	subi	r17, 0x01	; 1
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    4830:	11 23       	and	r17, r17
    4832:	b9 f7       	brne	.-18     	; 0x4822 <cmdlineRepaint+0x60>
    fputc(ASCII_BS,  state->myStdInOut);
}
    4834:	df 91       	pop	r29
    4836:	cf 91       	pop	r28
    4838:	1f 91       	pop	r17
    483a:	ff 90       	pop	r15
    483c:	ef 90       	pop	r14
    483e:	08 95       	ret

00004840 <cmdlineDoHistory>:
  state->historyDepthIdx = 0;
  state->bufferHistoryState = COPIED;
}

void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
{
    4840:	cf 93       	push	r28
    4842:	df 93       	push	r29
    4844:	eb 01       	movw	r28, r22
  uint8_t historyReadIdx;
  switch(action)
    4846:	81 30       	cpi	r24, 0x01	; 1
    4848:	f1 f0       	breq	.+60     	; 0x4886 <cmdlineDoHistory+0x46>
    484a:	81 30       	cpi	r24, 0x01	; 1
    484c:	20 f0       	brcs	.+8      	; 0x4856 <cmdlineDoHistory+0x16>
    484e:	82 30       	cpi	r24, 0x02	; 2
    4850:	09 f0       	breq	.+2      	; 0x4854 <cmdlineDoHistory+0x14>
    4852:	5f c0       	rjmp	.+190    	; 0x4912 <cmdlineDoHistory+0xd2>
    4854:	3f c0       	rjmp	.+126    	; 0x48d4 <cmdlineDoHistory+0x94>
  {
  case CMDLINE_HISTORY_SAVE:
    // copy CmdlineBuffer to history if not null string
    state->CmdlineBufferLength  = 0;
    4856:	1d 86       	std	Y+13, r1	; 0x0d
    state->CmdlineBufferEditPos = 0;     
    4858:	1e 86       	std	Y+14, r1	; 0x0e
    state->bufferHistoryState   = NOT_COPIED;
    485a:	19 8a       	std	Y+17, r1	; 0x11

    if( strlen(state->CmdlineBuffer) )
    485c:	e8 81       	ld	r30, Y
    485e:	f9 81       	ldd	r31, Y+1	; 0x01
    4860:	80 81       	ld	r24, Z
    4862:	88 23       	and	r24, r24
    4864:	09 f4       	brne	.+2      	; 0x4868 <cmdlineDoHistory+0x28>
    4866:	55 c0       	rjmp	.+170    	; 0x4912 <cmdlineDoHistory+0xd2>
    {
      state->historyWrIdx++;
      state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
    4868:	ef 85       	ldd	r30, Y+15	; 0x0f
    486a:	ef 5f       	subi	r30, 0xFF	; 255
    486c:	e3 70       	andi	r30, 0x03	; 3
    486e:	ef 87       	std	Y+15, r30	; 0x0f
      
      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    4870:	f0 e0       	ldi	r31, 0x00	; 0
    4872:	32 96       	adiw	r30, 0x02	; 2
    4874:	ee 0f       	add	r30, r30
    4876:	ff 1f       	adc	r31, r31
    4878:	e6 0f       	add	r30, r22
    487a:	f7 1f       	adc	r31, r23
    487c:	80 81       	ld	r24, Z
    487e:	91 81       	ldd	r25, Z+1	; 0x01
    4880:	99 83       	std	Y+1, r25	; 0x01
    4882:	88 83       	st	Y, r24
    4884:	46 c0       	rjmp	.+140    	; 0x4912 <cmdlineDoHistory+0xd2>
    }
    break;
  case CMDLINE_HISTORY_PREV:
    if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
    4886:	98 89       	ldd	r25, Y+16	; 0x10
    4888:	93 30       	cpi	r25, 0x03	; 3
    488a:	09 f4       	brne	.+2      	; 0x488e <cmdlineDoHistory+0x4e>
    488c:	42 c0       	rjmp	.+132    	; 0x4912 <cmdlineDoHistory+0xd2>
      break;                                               //We are on the end of the history list
    
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
    
    if (state->CmdlineHistory[historyReadIdx][0] == 0)
    488e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4890:	81 50       	subi	r24, 0x01	; 1
    4892:	89 1b       	sub	r24, r25
    4894:	83 70       	andi	r24, 0x03	; 3
    4896:	e8 2f       	mov	r30, r24
    4898:	f0 e0       	ldi	r31, 0x00	; 0
    489a:	32 96       	adiw	r30, 0x02	; 2
    489c:	ee 0f       	add	r30, r30
    489e:	ff 1f       	adc	r31, r31
    48a0:	e6 0f       	add	r30, r22
    48a2:	f7 1f       	adc	r31, r23
    48a4:	20 81       	ld	r18, Z
    48a6:	31 81       	ldd	r19, Z+1	; 0x01
    48a8:	d9 01       	movw	r26, r18
    48aa:	8c 91       	ld	r24, X
    48ac:	88 23       	and	r24, r24
    48ae:	89 f1       	breq	.+98     	; 0x4912 <cmdlineDoHistory+0xd2>
      break;
    
    state->historyDepthIdx++;
    state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
    48b0:	9f 5f       	subi	r25, 0xFF	; 255
    48b2:	93 70       	andi	r25, 0x03	; 3
    48b4:	98 8b       	std	Y+16, r25	; 0x10
    
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    48b6:	a0 81       	ld	r26, Z
    48b8:	b1 81       	ldd	r27, Z+1	; 0x01
    48ba:	fd 01       	movw	r30, r26
    48bc:	01 90       	ld	r0, Z+
    48be:	00 20       	and	r0, r0
    48c0:	e9 f7       	brne	.-6      	; 0x48bc <cmdlineDoHistory+0x7c>
    48c2:	31 97       	sbiw	r30, 0x01	; 1
    48c4:	ea 1b       	sub	r30, r26
    48c6:	fb 0b       	sbc	r31, r27
    48c8:	ed 87       	std	Y+13, r30	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    48ca:	ee 87       	std	Y+14, r30	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    48cc:	19 8a       	std	Y+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    48ce:	cb 01       	movw	r24, r22
    48d0:	b9 01       	movw	r22, r18
    48d2:	1d c0       	rjmp	.+58     	; 0x490e <cmdlineDoHistory+0xce>
    
    break;
  case CMDLINE_HISTORY_NEXT:      
    if (state->historyDepthIdx == 0)
    48d4:	88 89       	ldd	r24, Y+16	; 0x10
    48d6:	88 23       	and	r24, r24
    48d8:	e1 f0       	breq	.+56     	; 0x4912 <cmdlineDoHistory+0xd2>
      break;                                               //We are on the begining of the history list

    state->historyDepthIdx --;
    48da:	81 50       	subi	r24, 0x01	; 1
    48dc:	88 8b       	std	Y+16, r24	; 0x10
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
   
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    48de:	ef 85       	ldd	r30, Y+15	; 0x0f
    48e0:	e8 1b       	sub	r30, r24
    48e2:	e3 70       	andi	r30, 0x03	; 3
    48e4:	f0 e0       	ldi	r31, 0x00	; 0
    48e6:	32 96       	adiw	r30, 0x02	; 2
    48e8:	ee 0f       	add	r30, r30
    48ea:	ff 1f       	adc	r31, r31
    48ec:	e6 0f       	add	r30, r22
    48ee:	f7 1f       	adc	r31, r23
    48f0:	80 81       	ld	r24, Z
    48f2:	91 81       	ldd	r25, Z+1	; 0x01
    48f4:	dc 01       	movw	r26, r24
    48f6:	0d 90       	ld	r0, X+
    48f8:	00 20       	and	r0, r0
    48fa:	e9 f7       	brne	.-6      	; 0x48f6 <cmdlineDoHistory+0xb6>
    48fc:	11 97       	sbiw	r26, 0x01	; 1
    48fe:	a8 1b       	sub	r26, r24
    4900:	b9 0b       	sbc	r27, r25
    4902:	ad 87       	std	Y+13, r26	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    4904:	ae 87       	std	Y+14, r26	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    4906:	19 8a       	std	Y+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    4908:	60 81       	ld	r22, Z
    490a:	71 81       	ldd	r23, Z+1	; 0x01
    490c:	ce 01       	movw	r24, r28
    490e:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineRepaint>
    break;
  }
}
    4912:	df 91       	pop	r29
    4914:	cf 91       	pop	r28
    4916:	08 95       	ret

00004918 <cmdStateConfigure>:
static void cmdHistoryCopy            (cmdState_t *state);
static void cmdHistoryMove            (cmdState_t *state);


void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, const command_t *commands, enum cliModeState mode)
{
    4918:	8f 92       	push	r8
    491a:	9f 92       	push	r9
    491c:	bf 92       	push	r11
    491e:	cf 92       	push	r12
    4920:	df 92       	push	r13
    4922:	ef 92       	push	r14
    4924:	ff 92       	push	r15
    4926:	0f 93       	push	r16
    4928:	1f 93       	push	r17
    492a:	cf 93       	push	r28
    492c:	df 93       	push	r29
    492e:	ec 01       	movw	r28, r24
    4930:	f6 2e       	mov	r15, r22
    4932:	b7 2e       	mov	r11, r23
    4934:	6a 01       	movw	r12, r20
    4936:	49 01       	movw	r8, r18
  memset(state, 0, sizeof(cmdState_t));
    4938:	83 e2       	ldi	r24, 0x23	; 35
    493a:	fe 01       	movw	r30, r28
    493c:	11 92       	st	Z+, r1
    493e:	8a 95       	dec	r24
    4940:	e9 f7       	brne	.-6      	; 0x493c <cmdStateConfigure+0x24>
  memset(buffPtr, 0, bufferTotalSize);
    4942:	86 2f       	mov	r24, r22
    4944:	97 2f       	mov	r25, r23
    4946:	60 e0       	ldi	r22, 0x00	; 0
    4948:	70 e0       	ldi	r23, 0x00	; 0
    494a:	0e 94 5f 5c 	call	0xb8be	; 0xb8be <memset>
    
  state->CmdlineBuffer = buffPtr;
    494e:	f8 82       	st	Y, r15
    4950:	b9 82       	std	Y+1, r11	; 0x01
  state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
    4952:	d6 94       	lsr	r13
    4954:	c7 94       	ror	r12
    4956:	d6 94       	lsr	r13
    4958:	c7 94       	ror	r12
    495a:	cc 86       	std	Y+12, r12	; 0x0c

  state->cliMode = mode;
    495c:	e8 a2       	std	Y+32, r14	; 0x20
  state->cmdList = commands;
    495e:	1a a3       	std	Y+34, r17	; 0x22
    4960:	09 a3       	std	Y+33, r16	; 0x21
    4962:	fe 01       	movw	r30, r28
    4964:	2f 2d       	mov	r18, r15
    4966:	3b 2d       	mov	r19, r11
    4968:	c9 01       	movw	r24, r18
    496a:	9c 01       	movw	r18, r24
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
    496c:	ae 01       	movw	r20, r28
    496e:	48 5f       	subi	r20, 0xF8	; 248
    4970:	5f 4f       	sbci	r21, 0xFF	; 255
  {
    state->CmdlineHistory[i] = tmpPtr;
    4972:	35 83       	std	Z+5, r19	; 0x05
    4974:	24 83       	std	Z+4, r18	; 0x04
    tmpPtr += state->bufferMaxSize;
    4976:	8c 85       	ldd	r24, Y+12	; 0x0c
    4978:	28 0f       	add	r18, r24
    497a:	31 1d       	adc	r19, r1
    497c:	32 96       	adiw	r30, 0x02	; 2
  state->cliMode = mode;
  state->cmdList = commands;
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
    497e:	e4 17       	cp	r30, r20
    4980:	f5 07       	cpc	r31, r21
    4982:	b9 f7       	brne	.-18     	; 0x4972 <cmdStateConfigure+0x5a>
  {
    state->CmdlineHistory[i] = tmpPtr;
    tmpPtr += state->bufferMaxSize;
  }
  state->myStdInOut = stream;
    4984:	9b 8e       	std	Y+27, r9	; 0x1b
    4986:	8a 8e       	std	Y+26, r8	; 0x1a
}
    4988:	df 91       	pop	r29
    498a:	cf 91       	pop	r28
    498c:	1f 91       	pop	r17
    498e:	0f 91       	pop	r16
    4990:	ff 90       	pop	r15
    4992:	ef 90       	pop	r14
    4994:	df 90       	pop	r13
    4996:	cf 90       	pop	r12
    4998:	bf 90       	pop	r11
    499a:	9f 90       	pop	r9
    499c:	8f 90       	pop	r8
    499e:	08 95       	ret

000049a0 <cmdHistoryCopy>:
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
}

void cmdHistoryCopy(cmdState_t *state)
{
    49a0:	0f 93       	push	r16
    49a2:	1f 93       	push	r17
    49a4:	cf 93       	push	r28
    49a6:	df 93       	push	r29
    49a8:	ec 01       	movw	r28, r24
  if (state->historyDepthIdx != 0)
    49aa:	88 89       	ldd	r24, Y+16	; 0x10
    49ac:	88 23       	and	r24, r24
    49ae:	c9 f0       	breq	.+50     	; 0x49e2 <cmdHistoryCopy+0x42>
  {
    uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    49b0:	0f 85       	ldd	r16, Y+15	; 0x0f
    49b2:	08 1b       	sub	r16, r24
    49b4:	03 70       	andi	r16, 0x03	; 3
    memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
    49b6:	4c 85       	ldd	r20, Y+12	; 0x0c
    49b8:	88 81       	ld	r24, Y
    49ba:	99 81       	ldd	r25, Y+1	; 0x01
    49bc:	60 e0       	ldi	r22, 0x00	; 0
    49be:	70 e0       	ldi	r23, 0x00	; 0
    49c0:	50 e0       	ldi	r21, 0x00	; 0
    49c2:	0e 94 5f 5c 	call	0xb8be	; 0xb8be <memset>
    strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
    49c6:	10 e0       	ldi	r17, 0x00	; 0
    49c8:	0e 5f       	subi	r16, 0xFE	; 254
    49ca:	1f 4f       	sbci	r17, 0xFF	; 255
    49cc:	00 0f       	add	r16, r16
    49ce:	11 1f       	adc	r17, r17
    49d0:	0c 0f       	add	r16, r28
    49d2:	1d 1f       	adc	r17, r29
    49d4:	f8 01       	movw	r30, r16
    49d6:	60 81       	ld	r22, Z
    49d8:	71 81       	ldd	r23, Z+1	; 0x01
    49da:	88 81       	ld	r24, Y
    49dc:	99 81       	ldd	r25, Y+1	; 0x01
    49de:	0e 94 71 5c 	call	0xb8e2	; 0xb8e2 <strcpy>
  }
  
  state->historyDepthIdx = 0;
    49e2:	18 8a       	std	Y+16, r1	; 0x10
  state->bufferHistoryState = COPIED;
    49e4:	81 e0       	ldi	r24, 0x01	; 1
    49e6:	89 8b       	std	Y+17, r24	; 0x11
}
    49e8:	df 91       	pop	r29
    49ea:	cf 91       	pop	r28
    49ec:	1f 91       	pop	r17
    49ee:	0f 91       	pop	r16
    49f0:	08 95       	ret

000049f2 <cmdlineInputFunc>:
  // initialize executing function
  state->CmdlineExecFunction = 0;
}

void cmdlineInputFunc(char c, cmdState_t *state)
{
    49f2:	9f 92       	push	r9
    49f4:	af 92       	push	r10
    49f6:	bf 92       	push	r11
    49f8:	cf 92       	push	r12
    49fa:	df 92       	push	r13
    49fc:	ef 92       	push	r14
    49fe:	ff 92       	push	r15
    4a00:	0f 93       	push	r16
    4a02:	1f 93       	push	r17
    4a04:	df 93       	push	r29
    4a06:	cf 93       	push	r28
    4a08:	00 d0       	rcall	.+0      	; 0x4a0a <cmdlineInputFunc+0x18>
    4a0a:	00 d0       	rcall	.+0      	; 0x4a0c <cmdlineInputFunc+0x1a>
    4a0c:	00 d0       	rcall	.+0      	; 0x4a0e <cmdlineInputFunc+0x1c>
    4a0e:	cd b7       	in	r28, 0x3d	; 61
    4a10:	de b7       	in	r29, 0x3e	; 62
    4a12:	18 2f       	mov	r17, r24
    4a14:	7b 01       	movw	r14, r22
  uint8_t i;
  // process the received character

  // VT100 handling
  // are we processing a VT100 command?
  if(state->CmdlineInputVT100State == 2)
    4a16:	db 01       	movw	r26, r22
    4a18:	52 96       	adiw	r26, 0x12	; 18
    4a1a:	8c 91       	ld	r24, X
    4a1c:	82 30       	cpi	r24, 0x02	; 2
    4a1e:	09 f0       	breq	.+2      	; 0x4a22 <cmdlineInputFunc+0x30>
    4a20:	5d c0       	rjmp	.+186    	; 0x4adc <cmdlineInputFunc+0xea>
  {
    // we have already received ESC and [
    // now process the vt100 codeCmdlineExcBuffer
    switch(c)
    4a22:	12 34       	cpi	r17, 0x42	; 66
    4a24:	71 f0       	breq	.+28     	; 0x4a42 <cmdlineInputFunc+0x50>
    4a26:	13 34       	cpi	r17, 0x43	; 67
    4a28:	24 f4       	brge	.+8      	; 0x4a32 <cmdlineInputFunc+0x40>
    4a2a:	11 34       	cpi	r17, 0x41	; 65
    4a2c:	09 f0       	breq	.+2      	; 0x4a30 <cmdlineInputFunc+0x3e>
    4a2e:	53 c0       	rjmp	.+166    	; 0x4ad6 <cmdlineInputFunc+0xe4>
    4a30:	06 c0       	rjmp	.+12     	; 0x4a3e <cmdlineInputFunc+0x4c>
    4a32:	13 34       	cpi	r17, 0x43	; 67
    4a34:	59 f0       	breq	.+22     	; 0x4a4c <cmdlineInputFunc+0x5a>
    4a36:	14 34       	cpi	r17, 0x44	; 68
    4a38:	09 f0       	breq	.+2      	; 0x4a3c <cmdlineInputFunc+0x4a>
    4a3a:	4d c0       	rjmp	.+154    	; 0x4ad6 <cmdlineInputFunc+0xe4>
    4a3c:	31 c0       	rjmp	.+98     	; 0x4aa0 <cmdlineInputFunc+0xae>
    {
    case VT100_ARROWUP:
      cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
    4a3e:	81 e0       	ldi	r24, 0x01	; 1
    4a40:	01 c0       	rjmp	.+2      	; 0x4a44 <cmdlineInputFunc+0x52>
      break;
    case VT100_ARROWDOWN:
      cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
    4a42:	82 e0       	ldi	r24, 0x02	; 2
    4a44:	b7 01       	movw	r22, r14
    4a46:	0e 94 20 24 	call	0x4840	; 0x4840 <cmdlineDoHistory>
    4a4a:	45 c0       	rjmp	.+138    	; 0x4ad6 <cmdlineInputFunc+0xe4>
      break;
    case VT100_ARROWRIGHT:
      if (state->bufferHistoryState == NOT_COPIED)
    4a4c:	fb 01       	movw	r30, r22
    4a4e:	81 89       	ldd	r24, Z+17	; 0x11
    4a50:	88 23       	and	r24, r24
    4a52:	19 f4       	brne	.+6      	; 0x4a5a <cmdlineInputFunc+0x68>
        cmdHistoryCopy(state);
    4a54:	cb 01       	movw	r24, r22
    4a56:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <cmdHistoryCopy>
      // if the edit position less than current string length
      if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
    4a5a:	d7 01       	movw	r26, r14
    4a5c:	1e 96       	adiw	r26, 0x0e	; 14
    4a5e:	9c 91       	ld	r25, X
    4a60:	1e 97       	sbiw	r26, 0x0e	; 14
    4a62:	1d 96       	adiw	r26, 0x0d	; 13
    4a64:	8c 91       	ld	r24, X
    4a66:	1d 97       	sbiw	r26, 0x0d	; 13
    4a68:	5a 96       	adiw	r26, 0x1a	; 26
    4a6a:	6d 91       	ld	r22, X+
    4a6c:	7c 91       	ld	r23, X
    4a6e:	5b 97       	sbiw	r26, 0x1b	; 27
    4a70:	98 17       	cp	r25, r24
    4a72:	68 f5       	brcc	.+90     	; 0x4ace <cmdlineInputFunc+0xdc>
      {
        // increment the edit position
        state->CmdlineBufferEditPos++;
    4a74:	9f 5f       	subi	r25, 0xFF	; 255
    4a76:	1e 96       	adiw	r26, 0x0e	; 14
    4a78:	9c 93       	st	X, r25
        // move cursor forward one space (no erase)
        fputc(ASCII_ESC        , state->myStdInOut);
    4a7a:	8b e1       	ldi	r24, 0x1B	; 27
    4a7c:	90 e0       	ldi	r25, 0x00	; 0
    4a7e:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
        fputc('['              , state->myStdInOut);
    4a82:	f7 01       	movw	r30, r14
    4a84:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a86:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a88:	8b e5       	ldi	r24, 0x5B	; 91
    4a8a:	90 e0       	ldi	r25, 0x00	; 0
    4a8c:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
        fputc(VT100_ARROWRIGHT , state->myStdInOut);
    4a90:	d7 01       	movw	r26, r14
    4a92:	5a 96       	adiw	r26, 0x1a	; 26
    4a94:	6d 91       	ld	r22, X+
    4a96:	7c 91       	ld	r23, X
    4a98:	5b 97       	sbiw	r26, 0x1b	; 27
    4a9a:	83 e4       	ldi	r24, 0x43	; 67
    4a9c:	90 e0       	ldi	r25, 0x00	; 0
    4a9e:	19 c0       	rjmp	.+50     	; 0x4ad2 <cmdlineInputFunc+0xe0>
        fputc(ASCII_BEL        , state->myStdInOut);
      }
      break;
    case VT100_ARROWLEFT:
      // if the edit position is non-zero
      if (state->bufferHistoryState == NOT_COPIED)
    4aa0:	fb 01       	movw	r30, r22
    4aa2:	81 89       	ldd	r24, Z+17	; 0x11
    4aa4:	88 23       	and	r24, r24
    4aa6:	19 f4       	brne	.+6      	; 0x4aae <cmdlineInputFunc+0xbc>
        cmdHistoryCopy(state);
    4aa8:	cb 01       	movw	r24, r22
    4aaa:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <cmdHistoryCopy>
      
      if(state->CmdlineBufferEditPos)
    4aae:	d7 01       	movw	r26, r14
    4ab0:	1e 96       	adiw	r26, 0x0e	; 14
    4ab2:	8c 91       	ld	r24, X
    4ab4:	1e 97       	sbiw	r26, 0x0e	; 14
    4ab6:	5a 96       	adiw	r26, 0x1a	; 26
    4ab8:	6d 91       	ld	r22, X+
    4aba:	7c 91       	ld	r23, X
    4abc:	5b 97       	sbiw	r26, 0x1b	; 27
    4abe:	88 23       	and	r24, r24
    4ac0:	31 f0       	breq	.+12     	; 0x4ace <cmdlineInputFunc+0xdc>
      {
        // decrement the edit position
        state->CmdlineBufferEditPos--;
    4ac2:	81 50       	subi	r24, 0x01	; 1
    4ac4:	1e 96       	adiw	r26, 0x0e	; 14
    4ac6:	8c 93       	st	X, r24
        // move cursor back one space (no erase)
        fputc(ASCII_BS         , state->myStdInOut);
    4ac8:	88 e0       	ldi	r24, 0x08	; 8
    4aca:	90 e0       	ldi	r25, 0x00	; 0
    4acc:	02 c0       	rjmp	.+4      	; 0x4ad2 <cmdlineInputFunc+0xe0>
      }
      else
      {
        // else, ring the bell
        fputc(ASCII_BEL        , state->myStdInOut);
    4ace:	87 e0       	ldi	r24, 0x07	; 7
    4ad0:	90 e0       	ldi	r25, 0x00	; 0
    4ad2:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
      break;
    default:
      break;
    }
    // done, reset state
    state->CmdlineInputVT100State = 0;
    4ad6:	f7 01       	movw	r30, r14
    4ad8:	12 8a       	std	Z+18, r1	; 0x12
    4ada:	1e c2       	rjmp	.+1084   	; 0x4f18 <cmdlineInputFunc+0x526>
    return;
  }
  else if(state->CmdlineInputVT100State == 1)
    4adc:	81 30       	cpi	r24, 0x01	; 1
    4ade:	39 f4       	brne	.+14     	; 0x4aee <cmdlineInputFunc+0xfc>
  {
    // we last received [ESC]
    if(c == '[')
    4ae0:	1b 35       	cpi	r17, 0x5B	; 91
    4ae2:	11 f4       	brne	.+4      	; 0x4ae8 <cmdlineInputFunc+0xf6>
    {
      state->CmdlineInputVT100State = 2;
    4ae4:	82 e0       	ldi	r24, 0x02	; 2
    4ae6:	15 c2       	rjmp	.+1066   	; 0x4f12 <cmdlineInputFunc+0x520>
      return;
    }
    else
      state->CmdlineInputVT100State = 0;
    4ae8:	fb 01       	movw	r30, r22
    4aea:	12 8a       	std	Z+18, r1	; 0x12
    4aec:	03 c0       	rjmp	.+6      	; 0x4af4 <cmdlineInputFunc+0x102>
  }
  else
  {
    // anything else, reset state
    state->CmdlineInputVT100State = 0;
    4aee:	db 01       	movw	r26, r22
    4af0:	52 96       	adiw	r26, 0x12	; 18
    4af2:	1c 92       	st	X, r1
  }

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
    4af4:	f7 01       	movw	r30, r14
    4af6:	95 85       	ldd	r25, Z+13	; 0x0d
    4af8:	84 85       	ldd	r24, Z+12	; 0x0c
    4afa:	98 17       	cp	r25, r24
    4afc:	89 f4       	brne	.+34     	; 0x4b20 <cmdlineInputFunc+0x12e>
  {
    state->CmdlineBufferLength--;
    4afe:	91 50       	subi	r25, 0x01	; 1
    4b00:	95 87       	std	Z+13, r25	; 0x0d
    4b02:	91 e0       	ldi	r25, 0x01	; 1
    4b04:	09 c0       	rjmp	.+18     	; 0x4b18 <cmdlineInputFunc+0x126>
    for (i=1; i < state->bufferMaxSize; i++)
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    4b06:	d7 01       	movw	r26, r14
    4b08:	ed 91       	ld	r30, X+
    4b0a:	fc 91       	ld	r31, X
    4b0c:	e9 0f       	add	r30, r25
    4b0e:	f1 1d       	adc	r31, r1
    4b10:	80 81       	ld	r24, Z
    4b12:	31 97       	sbiw	r30, 0x01	; 1
    4b14:	80 83       	st	Z, r24
  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    for (i=1; i < state->bufferMaxSize; i++)
    4b16:	9f 5f       	subi	r25, 0xFF	; 255
    4b18:	f7 01       	movw	r30, r14
    4b1a:	84 85       	ldd	r24, Z+12	; 0x0c
    4b1c:	98 17       	cp	r25, r24
    4b1e:	98 f3       	brcs	.-26     	; 0x4b06 <cmdlineInputFunc+0x114>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    }
  }
  
  if( (c >= 0x20) && (c < 0x7F) )
    4b20:	81 2f       	mov	r24, r17
    4b22:	80 52       	subi	r24, 0x20	; 32
    4b24:	8f 35       	cpi	r24, 0x5F	; 95
    4b26:	08 f0       	brcs	.+2      	; 0x4b2a <cmdlineInputFunc+0x138>
    4b28:	5b c0       	rjmp	.+182    	; 0x4be0 <cmdlineInputFunc+0x1ee>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    4b2a:	d7 01       	movw	r26, r14
    4b2c:	51 96       	adiw	r26, 0x11	; 17
    4b2e:	8c 91       	ld	r24, X
    4b30:	88 23       	and	r24, r24
    4b32:	19 f4       	brne	.+6      	; 0x4b3a <cmdlineInputFunc+0x148>
      cmdHistoryCopy(state);
    4b34:	c7 01       	movw	r24, r14
    4b36:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <cmdHistoryCopy>
    // character is printable
    // is this a simple append
    if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    4b3a:	f7 01       	movw	r30, r14
    4b3c:	95 85       	ldd	r25, Z+13	; 0x0d
    4b3e:	86 85       	ldd	r24, Z+14	; 0x0e
    4b40:	89 17       	cp	r24, r25
    4b42:	e9 f4       	brne	.+58     	; 0x4b7e <cmdlineInputFunc+0x18c>
    {
      // echo character to the output
      fputc(c                , state->myStdInOut);
    4b44:	62 8d       	ldd	r22, Z+26	; 0x1a
    4b46:	73 8d       	ldd	r23, Z+27	; 0x1b
    4b48:	81 2f       	mov	r24, r17
    4b4a:	99 27       	eor	r25, r25
    4b4c:	87 fd       	sbrc	r24, 7
    4b4e:	90 95       	com	r25
    4b50:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
      // add it to the command line buffer
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4b54:	d7 01       	movw	r26, r14
    4b56:	1e 96       	adiw	r26, 0x0e	; 14
    4b58:	8c 91       	ld	r24, X
    4b5a:	1e 97       	sbiw	r26, 0x0e	; 14
    4b5c:	ed 91       	ld	r30, X+
    4b5e:	fc 91       	ld	r31, X
    4b60:	11 97       	sbiw	r26, 0x01	; 1
    4b62:	e8 0f       	add	r30, r24
    4b64:	f1 1d       	adc	r31, r1
    4b66:	10 83       	st	Z, r17
    4b68:	8f 5f       	subi	r24, 0xFF	; 255
    4b6a:	1e 96       	adiw	r26, 0x0e	; 14
    4b6c:	8c 93       	st	X, r24
    4b6e:	1e 97       	sbiw	r26, 0x0e	; 14
      // update buffer length
      state->CmdlineBufferLength++;
    4b70:	1d 96       	adiw	r26, 0x0d	; 13
    4b72:	8c 91       	ld	r24, X
    4b74:	1d 97       	sbiw	r26, 0x0d	; 13
    4b76:	8f 5f       	subi	r24, 0xFF	; 255
    4b78:	1d 96       	adiw	r26, 0x0d	; 13
    4b7a:	8c 93       	st	X, r24
    4b7c:	cd c1       	rjmp	.+922    	; 0x4f18 <cmdlineInputFunc+0x526>
    else
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
    4b7e:	9f 5f       	subi	r25, 0xFF	; 255
    4b80:	f7 01       	movw	r30, r14
    4b82:	95 87       	std	Z+13, r25	; 0x0d
    4b84:	06 c0       	rjmp	.+12     	; 0x4b92 <cmdlineInputFunc+0x1a0>
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
    4b86:	e9 0f       	add	r30, r25
    4b88:	f1 1d       	adc	r31, r1
    4b8a:	82 91       	ld	r24, -Z
    4b8c:	31 96       	adiw	r30, 0x01	; 1
    4b8e:	80 83       	st	Z, r24
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    4b90:	91 50       	subi	r25, 0x01	; 1
    4b92:	d7 01       	movw	r26, r14
    4b94:	1e 96       	adiw	r26, 0x0e	; 14
    4b96:	8c 91       	ld	r24, X
    4b98:	1e 97       	sbiw	r26, 0x0e	; 14
    4b9a:	ed 91       	ld	r30, X+
    4b9c:	fc 91       	ld	r31, X
    4b9e:	11 97       	sbiw	r26, 0x01	; 1
    4ba0:	89 17       	cp	r24, r25
    4ba2:	88 f3       	brcs	.-30     	; 0x4b86 <cmdlineInputFunc+0x194>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4ba4:	e8 0f       	add	r30, r24
    4ba6:	f1 1d       	adc	r31, r1
    4ba8:	10 83       	st	Z, r17
    4baa:	8f 5f       	subi	r24, 0xFF	; 255
    4bac:	1e 96       	adiw	r26, 0x0e	; 14
    4bae:	8c 93       	st	X, r24
    4bb0:	1e 97       	sbiw	r26, 0x0e	; 14
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
    4bb2:	6d 91       	ld	r22, X+
    4bb4:	7c 91       	ld	r23, X
    4bb6:	c7 01       	movw	r24, r14
    4bb8:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineRepaint>
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4bbc:	f7 01       	movw	r30, r14
    4bbe:	16 85       	ldd	r17, Z+14	; 0x0e
    4bc0:	0a c0       	rjmp	.+20     	; 0x4bd6 <cmdlineInputFunc+0x1e4>
        fputc(ASCII_BS         , state->myStdInOut);
    4bc2:	d7 01       	movw	r26, r14
    4bc4:	5a 96       	adiw	r26, 0x1a	; 26
    4bc6:	6d 91       	ld	r22, X+
    4bc8:	7c 91       	ld	r23, X
    4bca:	5b 97       	sbiw	r26, 0x1b	; 27
    4bcc:	88 e0       	ldi	r24, 0x08	; 8
    4bce:	90 e0       	ldi	r25, 0x00	; 0
    4bd0:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4bd4:	1f 5f       	subi	r17, 0xFF	; 255
    4bd6:	f7 01       	movw	r30, r14
    4bd8:	85 85       	ldd	r24, Z+13	; 0x0d
    4bda:	18 17       	cp	r17, r24
    4bdc:	90 f3       	brcs	.-28     	; 0x4bc2 <cmdlineInputFunc+0x1d0>
    4bde:	9c c1       	rjmp	.+824    	; 0x4f18 <cmdlineInputFunc+0x526>
        fputc(ASCII_BS         , state->myStdInOut);
    }
  }
  // handle special characters
  else if(c == ASCII_CR)
    4be0:	1d 30       	cpi	r17, 0x0D	; 13
    4be2:	09 f0       	breq	.+2      	; 0x4be6 <cmdlineInputFunc+0x1f4>
    4be4:	25 c1       	rjmp	.+586    	; 0x4e30 <cmdlineInputFunc+0x43e>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    4be6:	d7 01       	movw	r26, r14
    4be8:	51 96       	adiw	r26, 0x11	; 17
    4bea:	8c 91       	ld	r24, X
    4bec:	51 97       	sbiw	r26, 0x11	; 17
    4bee:	88 23       	and	r24, r24
    4bf0:	09 f0       	breq	.+2      	; 0x4bf4 <cmdlineInputFunc+0x202>
    4bf2:	49 c0       	rjmp	.+146    	; 0x4c86 <cmdlineInputFunc+0x294>
  state->bufferHistoryState = COPIED;
}

void cmdHistoryMove(cmdState_t *state)
{
  uint8_t i=state->historyDepthIdx;
    4bf4:	50 96       	adiw	r26, 0x10	; 16
    4bf6:	2c 91       	ld	r18, X
    4bf8:	50 97       	sbiw	r26, 0x10	; 16

  if (state->historyDepthIdx != 0)
    4bfa:	22 23       	and	r18, r18
    4bfc:	79 f1       	breq	.+94     	; 0x4c5c <cmdlineInputFunc+0x26a>
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    4bfe:	1f 96       	adiw	r26, 0x0f	; 15
    4c00:	ec 91       	ld	r30, X
    4c02:	1f 97       	sbiw	r26, 0x0f	; 15
    4c04:	f0 e0       	ldi	r31, 0x00	; 0
    4c06:	e2 1b       	sub	r30, r18
    4c08:	f1 09       	sbc	r31, r1
    4c0a:	e3 70       	andi	r30, 0x03	; 3
    4c0c:	f0 70       	andi	r31, 0x00	; 0
    4c0e:	32 96       	adiw	r30, 0x02	; 2
    4c10:	ee 0f       	add	r30, r30
    4c12:	ff 1f       	adc	r31, r31
    4c14:	ee 0d       	add	r30, r14
    4c16:	ff 1d       	adc	r31, r15
    4c18:	80 81       	ld	r24, Z
    4c1a:	91 81       	ldd	r25, Z+1	; 0x01
    4c1c:	8d 93       	st	X+, r24
    4c1e:	9c 93       	st	X, r25
    4c20:	1b c0       	rjmp	.+54     	; 0x4c58 <cmdlineInputFunc+0x266>
    for ( ; i<CMD_STATE_HISTORY; i++)
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    4c22:	d7 01       	movw	r26, r14
    4c24:	1f 96       	adiw	r26, 0x0f	; 15
    4c26:	ec 91       	ld	r30, X
    4c28:	f0 e0       	ldi	r31, 0x00	; 0
    4c2a:	e2 1b       	sub	r30, r18
    4c2c:	f1 09       	sbc	r31, r1
    4c2e:	df 01       	movw	r26, r30
    4c30:	a3 70       	andi	r26, 0x03	; 3
    4c32:	b0 70       	andi	r27, 0x00	; 0
    4c34:	12 96       	adiw	r26, 0x02	; 2
    4c36:	aa 0f       	add	r26, r26
    4c38:	bb 1f       	adc	r27, r27
    4c3a:	ae 0d       	add	r26, r14
    4c3c:	bf 1d       	adc	r27, r15
    4c3e:	31 97       	sbiw	r30, 0x01	; 1
    4c40:	e3 70       	andi	r30, 0x03	; 3
    4c42:	f0 70       	andi	r31, 0x00	; 0
    4c44:	32 96       	adiw	r30, 0x02	; 2
    4c46:	ee 0f       	add	r30, r30
    4c48:	ff 1f       	adc	r31, r31
    4c4a:	ee 0d       	add	r30, r14
    4c4c:	ff 1d       	adc	r31, r15
    4c4e:	80 81       	ld	r24, Z
    4c50:	91 81       	ldd	r25, Z+1	; 0x01
    4c52:	8d 93       	st	X+, r24
    4c54:	9c 93       	st	X, r25
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    for ( ; i<CMD_STATE_HISTORY; i++)
    4c56:	2f 5f       	subi	r18, 0xFF	; 255
    4c58:	24 30       	cpi	r18, 0x04	; 4
    4c5a:	18 f3       	brcs	.-58     	; 0x4c22 <cmdlineInputFunc+0x230>
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    }
  }
  state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
    4c5c:	d7 01       	movw	r26, r14
    4c5e:	1f 96       	adiw	r26, 0x0f	; 15
    4c60:	ec 91       	ld	r30, X
    4c62:	1f 97       	sbiw	r26, 0x0f	; 15
    4c64:	f0 e0       	ldi	r31, 0x00	; 0
    4c66:	32 96       	adiw	r30, 0x02	; 2
    4c68:	ee 0f       	add	r30, r30
    4c6a:	ff 1f       	adc	r31, r31
    4c6c:	ee 0d       	add	r30, r14
    4c6e:	ff 1d       	adc	r31, r15
    4c70:	8d 91       	ld	r24, X+
    4c72:	9c 91       	ld	r25, X
    4c74:	11 97       	sbiw	r26, 0x01	; 1
    4c76:	91 83       	std	Z+1, r25	; 0x01
    4c78:	80 83       	st	Z, r24

  state->historyDepthIdx = 0;
    4c7a:	50 96       	adiw	r26, 0x10	; 16
    4c7c:	1c 92       	st	X, r1
    4c7e:	50 97       	sbiw	r26, 0x10	; 16
  state->bufferHistoryState = COPIED;
    4c80:	81 e0       	ldi	r24, 0x01	; 1
    4c82:	51 96       	adiw	r26, 0x11	; 17
    4c84:	8c 93       	st	X, r24
    if (state->bufferHistoryState == NOT_COPIED)
      cmdHistoryMove(state);
    
    // user pressed [ENTER]
    // echo CR and LF to terminal
    fputc(ASCII_CR         , state->myStdInOut);
    4c86:	f7 01       	movw	r30, r14
    4c88:	62 8d       	ldd	r22, Z+26	; 0x1a
    4c8a:	73 8d       	ldd	r23, Z+27	; 0x1b
    4c8c:	8d e0       	ldi	r24, 0x0D	; 13
    4c8e:	90 e0       	ldi	r25, 0x00	; 0
    4c90:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    fputc(ASCII_LF         , state->myStdInOut);
    4c94:	d7 01       	movw	r26, r14
    4c96:	5a 96       	adiw	r26, 0x1a	; 26
    4c98:	6d 91       	ld	r22, X+
    4c9a:	7c 91       	ld	r23, X
    4c9c:	5b 97       	sbiw	r26, 0x1b	; 27
    4c9e:	8a e0       	ldi	r24, 0x0A	; 10
    4ca0:	90 e0       	ldi	r25, 0x00	; 0
    4ca2:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    // add null termination to command
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    4ca6:	f7 01       	movw	r30, r14
    4ca8:	85 85       	ldd	r24, Z+13	; 0x0d
    4caa:	01 90       	ld	r0, Z+
    4cac:	f0 81       	ld	r31, Z
    4cae:	e0 2d       	mov	r30, r0
    4cb0:	e8 0f       	add	r30, r24
    4cb2:	f1 1d       	adc	r31, r1
    4cb4:	10 82       	st	Z, r1
    4cb6:	8f 5f       	subi	r24, 0xFF	; 255
    4cb8:	d7 01       	movw	r26, r14
    4cba:	1d 96       	adiw	r26, 0x0d	; 13
    4cbc:	8c 93       	st	X, r24
    4cbe:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos++;
    4cc0:	1e 96       	adiw	r26, 0x0e	; 14
    4cc2:	8c 91       	ld	r24, X
    4cc4:	1e 97       	sbiw	r26, 0x0e	; 14
    4cc6:	8f 5f       	subi	r24, 0xFF	; 255
    4cc8:	1e 96       	adiw	r26, 0x0e	; 14
    4cca:	8c 93       	st	X, r24
    4ccc:	1e 97       	sbiw	r26, 0x0e	; 14
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments
    4cce:	8d 91       	ld	r24, X+
    4cd0:	9c 91       	ld	r25, X
    4cd2:	11 97       	sbiw	r26, 0x01	; 1
    4cd4:	13 96       	adiw	r26, 0x03	; 3
    4cd6:	9c 93       	st	X, r25
    4cd8:	8e 93       	st	-X, r24
    4cda:	12 97       	sbiw	r26, 0x02	; 2
    4cdc:	bb 24       	eor	r11, r11
    4cde:	01 c0       	rjmp	.+2      	; 0x4ce2 <cmdlineInputFunc+0x2f0>

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length
    4ce0:	b3 94       	inc	r11
void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    4ce2:	fc 01       	movw	r30, r24
    4ce4:	eb 0d       	add	r30, r11
    4ce6:	f1 1d       	adc	r31, r1
    4ce8:	e0 81       	ld	r30, Z
    4cea:	e0 32       	cpi	r30, 0x20	; 32
    4cec:	11 f0       	breq	.+4      	; 0x4cf2 <cmdlineInputFunc+0x300>
    4cee:	ee 23       	and	r30, r30
    4cf0:	b9 f7       	brne	.-18     	; 0x4ce0 <cmdlineInputFunc+0x2ee>
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length

  if(!i)                                                              // command was null or empty
    4cf2:	bb 20       	and	r11, r11
    4cf4:	09 f4       	brne	.+2      	; 0x4cf8 <cmdlineInputFunc+0x306>
    4cf6:	92 c0       	rjmp	.+292    	; 0x4e1c <cmdlineInputFunc+0x42a>
  {
    cmdlinePrintPrompt(state);                                        // output a new prompt
    return;
  }

  const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The list depends of the cli mode
    4cf8:	f7 01       	movw	r30, r14
    4cfa:	c1 a0       	ldd	r12, Z+33	; 0x21
    4cfc:	d2 a0       	ldd	r13, Z+34	; 0x22
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.
    4cfe:	8e 01       	movw	r16, r28
    4d00:	0f 5f       	subi	r16, 0xFF	; 255
    4d02:	1f 4f       	sbci	r17, 0xFF	; 255
    4d04:	c8 01       	movw	r24, r16
    4d06:	b6 01       	movw	r22, r12
    4d08:	46 e0       	ldi	r20, 0x06	; 6
    4d0a:	50 e0       	ldi	r21, 0x00	; 0
    4d0c:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <memcpy_P>
      state->command_help_str    = tmp.commandHelpStr;
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
      return;
    }
    tmpPtr++;                                                         // Next command
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    4d10:	90 2e       	mov	r9, r16
    4d12:	a1 2e       	mov	r10, r17
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.

  do                                                                  // search command list for match with entered command
  {
    if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command matched a command in the list
    4d14:	09 81       	ldd	r16, Y+1	; 0x01
    4d16:	1a 81       	ldd	r17, Y+2	; 0x02
    4d18:	d7 01       	movw	r26, r14
    4d1a:	12 96       	adiw	r26, 0x02	; 2
    4d1c:	8d 91       	ld	r24, X+
    4d1e:	9c 91       	ld	r25, X
    4d20:	13 97       	sbiw	r26, 0x03	; 3
    4d22:	b8 01       	movw	r22, r16
    4d24:	4b 2d       	mov	r20, r11
    4d26:	50 e0       	ldi	r21, 0x00	; 0
    4d28:	0e 94 48 5c 	call	0xb890	; 0xb890 <strncmp_P>
    4d2c:	89 2b       	or	r24, r25
    4d2e:	81 f4       	brne	.+32     	; 0x4d50 <cmdlineInputFunc+0x35e>
    {                                                                 // 
      state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
    4d30:	8d 81       	ldd	r24, Y+5	; 0x05
    4d32:	9e 81       	ldd	r25, Y+6	; 0x06
    4d34:	f7 01       	movw	r30, r14
    4d36:	90 8f       	std	Z+24, r25	; 0x18
    4d38:	87 8b       	std	Z+23, r24	; 0x17
      state->command_str         = tmp.commandStr;
    4d3a:	14 8b       	std	Z+20, r17	; 0x14
    4d3c:	03 8b       	std	Z+19, r16	; 0x13
      state->command_help_str    = tmp.commandHelpStr;
    4d3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4d40:	9c 81       	ldd	r25, Y+4	; 0x04
    4d42:	96 8b       	std	Z+22, r25	; 0x16
    4d44:	85 8b       	std	Z+21, r24	; 0x15
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
    4d46:	80 e0       	ldi	r24, 0x00	; 0
    4d48:	b7 01       	movw	r22, r14
    4d4a:	0e 94 20 24 	call	0x4840	; 0x4840 <cmdlineDoHistory>
    4d4e:	69 c0       	rjmp	.+210    	; 0x4e22 <cmdlineInputFunc+0x430>
      return;
    }
    tmpPtr++;                                                         // Next command
    4d50:	86 e0       	ldi	r24, 0x06	; 6
    4d52:	90 e0       	ldi	r25, 0x00	; 0
    4d54:	c8 0e       	add	r12, r24
    4d56:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    4d58:	89 2d       	mov	r24, r9
    4d5a:	9a 2d       	mov	r25, r10
    4d5c:	b6 01       	movw	r22, r12
    4d5e:	46 e0       	ldi	r20, 0x06	; 6
    4d60:	50 e0       	ldi	r21, 0x00	; 0
    4d62:	0e 94 3f 5c 	call	0xb87e	; 0xb87e <memcpy_P>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
    4d66:	89 81       	ldd	r24, Y+1	; 0x01
    4d68:	9a 81       	ldd	r25, Y+2	; 0x02
    4d6a:	89 2b       	or	r24, r25
    4d6c:	99 f6       	brne	.-90     	; 0x4d14 <cmdlineInputFunc+0x322>
    4d6e:	09 e8       	ldi	r16, 0x89	; 137
    4d70:	1b e0       	ldi	r17, 0x0B	; 11
    4d72:	0c c0       	rjmp	.+24     	; 0x4d8c <cmdlineInputFunc+0x39a>

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4d74:	0f 5f       	subi	r16, 0xFF	; 255
    4d76:	1f 4f       	sbci	r17, 0xFF	; 255
    4d78:	f9 01       	movw	r30, r18
    4d7a:	84 91       	lpm	r24, Z+
    4d7c:	d7 01       	movw	r26, r14
    4d7e:	5a 96       	adiw	r26, 0x1a	; 26
    4d80:	6d 91       	ld	r22, X+
    4d82:	7c 91       	ld	r23, X
    4d84:	5b 97       	sbiw	r26, 0x1b	; 27
    4d86:	90 e0       	ldi	r25, 0x00	; 0
    4d88:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    4d8c:	98 01       	movw	r18, r16
  char * ptr;

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    4d8e:	f8 01       	movw	r30, r16
    4d90:	84 91       	lpm	r24, Z+
    4d92:	88 23       	and	r24, r24
    4d94:	79 f7       	brne	.-34     	; 0x4d74 <cmdlineInputFunc+0x382>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
    4d96:	d7 01       	movw	r26, r14
    4d98:	0d 91       	ld	r16, X+
    4d9a:	1c 91       	ld	r17, X
    4d9c:	0a c0       	rjmp	.+20     	; 0x4db2 <cmdlineInputFunc+0x3c0>
  while((*ptr) && (*ptr != ' '))
    fputc(*ptr++    , state->myStdInOut);
    4d9e:	0f 5f       	subi	r16, 0xFF	; 255
    4da0:	1f 4f       	sbci	r17, 0xFF	; 255
    4da2:	f7 01       	movw	r30, r14
    4da4:	62 8d       	ldd	r22, Z+26	; 0x1a
    4da6:	73 8d       	ldd	r23, Z+27	; 0x1b
    4da8:	99 27       	eor	r25, r25
    4daa:	87 fd       	sbrc	r24, 7
    4dac:	90 95       	com	r25
    4dae:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    4db2:	d8 01       	movw	r26, r16
    4db4:	8c 91       	ld	r24, X
    4db6:	88 23       	and	r24, r24
    4db8:	11 f0       	breq	.+4      	; 0x4dbe <cmdlineInputFunc+0x3cc>
    4dba:	80 32       	cpi	r24, 0x20	; 32
    4dbc:	81 f7       	brne	.-32     	; 0x4d9e <cmdlineInputFunc+0x3ac>
    fputc(*ptr++    , state->myStdInOut);

  fputc(':'         , state->myStdInOut);
    4dbe:	f7 01       	movw	r30, r14
    4dc0:	62 8d       	ldd	r22, Z+26	; 0x1a
    4dc2:	73 8d       	ldd	r23, Z+27	; 0x1b
    4dc4:	8a e3       	ldi	r24, 0x3A	; 58
    4dc6:	90 e0       	ldi	r25, 0x00	; 0
    4dc8:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
  fputc(' '         , state->myStdInOut);
    4dcc:	d7 01       	movw	r26, r14
    4dce:	5a 96       	adiw	r26, 0x1a	; 26
    4dd0:	6d 91       	ld	r22, X+
    4dd2:	7c 91       	ld	r23, X
    4dd4:	5b 97       	sbiw	r26, 0x1b	; 27
    4dd6:	80 e2       	ldi	r24, 0x20	; 32
    4dd8:	90 e0       	ldi	r25, 0x00	; 0
    4dda:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    4dde:	03 e9       	ldi	r16, 0x93	; 147
    4de0:	1b e0       	ldi	r17, 0x0B	; 11
    4de2:	07 c0       	rjmp	.+14     	; 0x4df2 <cmdlineInputFunc+0x400>

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4de4:	0f 5f       	subi	r16, 0xFF	; 255
    4de6:	1f 4f       	sbci	r17, 0xFF	; 255
    4de8:	f9 01       	movw	r30, r18
    4dea:	84 91       	lpm	r24, Z+
    4dec:	90 e0       	ldi	r25, 0x00	; 0
    4dee:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    4df2:	98 01       	movw	r18, r16
  fputc(' '         , state->myStdInOut);

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    4df4:	f8 01       	movw	r30, r16
    4df6:	84 91       	lpm	r24, Z+
    4df8:	d7 01       	movw	r26, r14
    4dfa:	5a 96       	adiw	r26, 0x1a	; 26
    4dfc:	6d 91       	ld	r22, X+
    4dfe:	7c 91       	ld	r23, X
    4e00:	5b 97       	sbiw	r26, 0x1b	; 27
    4e02:	88 23       	and	r24, r24
    4e04:	79 f7       	brne	.-34     	; 0x4de4 <cmdlineInputFunc+0x3f2>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);

  fputc('\r'        , state->myStdInOut);
    4e06:	8d e0       	ldi	r24, 0x0D	; 13
    4e08:	90 e0       	ldi	r25, 0x00	; 0
    4e0a:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
  fputc('\n'        , state->myStdInOut);
    4e0e:	f7 01       	movw	r30, r14
    4e10:	62 8d       	ldd	r22, Z+26	; 0x1a
    4e12:	73 8d       	ldd	r23, Z+27	; 0x1b
    4e14:	8a e0       	ldi	r24, 0x0A	; 10
    4e16:	90 e0       	ldi	r25, 0x00	; 0
    4e18:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
  
  // if we did not get a match
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
    4e1c:	c7 01       	movw	r24, r14
    4e1e:	0e 94 28 23 	call	0x4650	; 0x4650 <cmdlinePrintPrompt>
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    state->CmdlineBufferEditPos++;
    // command is complete, process it
    cmdlineProcessInputString(state);
    // reset buffer
    state->CmdlineBufferLength = 0;
    4e22:	d7 01       	movw	r26, r14
    4e24:	1d 96       	adiw	r26, 0x0d	; 13
    4e26:	1c 92       	st	X, r1
    4e28:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = 0;
    4e2a:	1e 96       	adiw	r26, 0x0e	; 14
    4e2c:	1c 92       	st	X, r1
    4e2e:	74 c0       	rjmp	.+232    	; 0x4f18 <cmdlineInputFunc+0x526>
  }
  else if(c == ASCII_BS)
    4e30:	18 30       	cpi	r17, 0x08	; 8
    4e32:	09 f0       	breq	.+2      	; 0x4e36 <cmdlineInputFunc+0x444>
    4e34:	69 c0       	rjmp	.+210    	; 0x4f08 <cmdlineInputFunc+0x516>
  {
    if(state->CmdlineBufferEditPos)
    4e36:	f7 01       	movw	r30, r14
    4e38:	96 85       	ldd	r25, Z+14	; 0x0e
    4e3a:	99 23       	and	r25, r25
    4e3c:	09 f4       	brne	.+2      	; 0x4e40 <cmdlineInputFunc+0x44e>
    4e3e:	5c c0       	rjmp	.+184    	; 0x4ef8 <cmdlineInputFunc+0x506>
    {
      // is this a simple delete (off the end of the line)
      if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    4e40:	85 85       	ldd	r24, Z+13	; 0x0d
    4e42:	98 17       	cp	r25, r24
    4e44:	29 f5       	brne	.+74     	; 0x4e90 <cmdlineInputFunc+0x49e>
      {
        // destructive backspace
        // echo backspace-space-backspace
        fputc(ASCII_BS         , state->myStdInOut);
    4e46:	62 8d       	ldd	r22, Z+26	; 0x1a
    4e48:	73 8d       	ldd	r23, Z+27	; 0x1b
    4e4a:	88 e0       	ldi	r24, 0x08	; 8
    4e4c:	90 e0       	ldi	r25, 0x00	; 0
    4e4e:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
        fputc(' '              , state->myStdInOut);
    4e52:	d7 01       	movw	r26, r14
    4e54:	5a 96       	adiw	r26, 0x1a	; 26
    4e56:	6d 91       	ld	r22, X+
    4e58:	7c 91       	ld	r23, X
    4e5a:	5b 97       	sbiw	r26, 0x1b	; 27
    4e5c:	80 e2       	ldi	r24, 0x20	; 32
    4e5e:	90 e0       	ldi	r25, 0x00	; 0
    4e60:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
        fputc(ASCII_BS         , state->myStdInOut);
    4e64:	f7 01       	movw	r30, r14
    4e66:	62 8d       	ldd	r22, Z+26	; 0x1a
    4e68:	73 8d       	ldd	r23, Z+27	; 0x1b
    4e6a:	88 e0       	ldi	r24, 0x08	; 8
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
        // decrement our buffer length and edit position
        state->CmdlineBufferLength--;
    4e72:	d7 01       	movw	r26, r14
    4e74:	1d 96       	adiw	r26, 0x0d	; 13
    4e76:	8c 91       	ld	r24, X
    4e78:	1d 97       	sbiw	r26, 0x0d	; 13
    4e7a:	81 50       	subi	r24, 0x01	; 1
    4e7c:	1d 96       	adiw	r26, 0x0d	; 13
    4e7e:	8c 93       	st	X, r24
    4e80:	1d 97       	sbiw	r26, 0x0d	; 13
        state->CmdlineBufferEditPos--;
    4e82:	1e 96       	adiw	r26, 0x0e	; 14
    4e84:	8c 91       	ld	r24, X
    4e86:	1e 97       	sbiw	r26, 0x0e	; 14
    4e88:	81 50       	subi	r24, 0x01	; 1
    4e8a:	1e 96       	adiw	r26, 0x0e	; 14
    4e8c:	8c 93       	st	X, r24
    4e8e:	44 c0       	rjmp	.+136    	; 0x4f18 <cmdlineInputFunc+0x526>
      else
      {
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
    4e90:	81 50       	subi	r24, 0x01	; 1
    4e92:	f7 01       	movw	r30, r14
    4e94:	85 87       	std	Z+13, r24	; 0x0d
        state->CmdlineBufferEditPos--;
    4e96:	91 50       	subi	r25, 0x01	; 1
    4e98:	96 87       	std	Z+14, r25	; 0x0e
    4e9a:	05 c0       	rjmp	.+10     	; 0x4ea6 <cmdlineInputFunc+0x4b4>
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
    4e9c:	e9 0f       	add	r30, r25
    4e9e:	f1 1d       	adc	r31, r1
    4ea0:	81 81       	ldd	r24, Z+1	; 0x01
    4ea2:	80 83       	st	Z, r24
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
        state->CmdlineBufferEditPos--;
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4ea4:	9f 5f       	subi	r25, 0xFF	; 255
    4ea6:	d7 01       	movw	r26, r14
    4ea8:	1d 96       	adiw	r26, 0x0d	; 13
    4eaa:	8c 91       	ld	r24, X
    4eac:	1d 97       	sbiw	r26, 0x0d	; 13
    4eae:	ed 91       	ld	r30, X+
    4eb0:	fc 91       	ld	r31, X
    4eb2:	98 17       	cp	r25, r24
    4eb4:	98 f3       	brcs	.-26     	; 0x4e9c <cmdlineInputFunc+0x4aa>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
    4eb6:	c7 01       	movw	r24, r14
    4eb8:	bf 01       	movw	r22, r30
    4eba:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineRepaint>
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
    4ebe:	f7 01       	movw	r30, r14
    4ec0:	62 8d       	ldd	r22, Z+26	; 0x1a
    4ec2:	73 8d       	ldd	r23, Z+27	; 0x1b
    4ec4:	80 e2       	ldi	r24, 0x20	; 32
    4ec6:	90 e0       	ldi	r25, 0x00	; 0
    4ec8:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4ecc:	d7 01       	movw	r26, r14
    4ece:	1e 96       	adiw	r26, 0x0e	; 14
    4ed0:	1c 91       	ld	r17, X
    4ed2:	08 c0       	rjmp	.+16     	; 0x4ee4 <cmdlineInputFunc+0x4f2>
          fputc(ASCII_BS       , state->myStdInOut);
    4ed4:	f7 01       	movw	r30, r14
    4ed6:	62 8d       	ldd	r22, Z+26	; 0x1a
    4ed8:	73 8d       	ldd	r23, Z+27	; 0x1b
    4eda:	88 e0       	ldi	r24, 0x08	; 8
    4edc:	90 e0       	ldi	r25, 0x00	; 0
    4ede:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4ee2:	1f 5f       	subi	r17, 0xFF	; 255
    4ee4:	d7 01       	movw	r26, r14
    4ee6:	1d 96       	adiw	r26, 0x0d	; 13
    4ee8:	8c 91       	ld	r24, X
    4eea:	90 e0       	ldi	r25, 0x00	; 0
    4eec:	21 2f       	mov	r18, r17
    4eee:	30 e0       	ldi	r19, 0x00	; 0
    4ef0:	82 17       	cp	r24, r18
    4ef2:	93 07       	cpc	r25, r19
    4ef4:	7c f7       	brge	.-34     	; 0x4ed4 <cmdlineInputFunc+0x4e2>
    4ef6:	10 c0       	rjmp	.+32     	; 0x4f18 <cmdlineInputFunc+0x526>
      }
    }
    else
    {
      // else, ring the bell
      fputc(ASCII_BEL          , state->myStdInOut);
    4ef8:	f7 01       	movw	r30, r14
    4efa:	62 8d       	ldd	r22, Z+26	; 0x1a
    4efc:	73 8d       	ldd	r23, Z+27	; 0x1b
    4efe:	87 e0       	ldi	r24, 0x07	; 7
    4f00:	90 e0       	ldi	r25, 0x00	; 0
    4f02:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    4f06:	08 c0       	rjmp	.+16     	; 0x4f18 <cmdlineInputFunc+0x526>
    }
  }
  else if(c == ASCII_DEL)
    4f08:	1f 37       	cpi	r17, 0x7F	; 127
    4f0a:	31 f0       	breq	.+12     	; 0x4f18 <cmdlineInputFunc+0x526>
  {
    // not yet handled
  }
  else if(c == ASCII_ESC)
    4f0c:	1b 31       	cpi	r17, 0x1B	; 27
    4f0e:	21 f4       	brne	.+8      	; 0x4f18 <cmdlineInputFunc+0x526>
  {
    state->CmdlineInputVT100State = 1;
    4f10:	81 e0       	ldi	r24, 0x01	; 1
    4f12:	d7 01       	movw	r26, r14
    4f14:	52 96       	adiw	r26, 0x12	; 18
    4f16:	8c 93       	st	X, r24
  }
}
    4f18:	26 96       	adiw	r28, 0x06	; 6
    4f1a:	0f b6       	in	r0, 0x3f	; 63
    4f1c:	f8 94       	cli
    4f1e:	de bf       	out	0x3e, r29	; 62
    4f20:	0f be       	out	0x3f, r0	; 63
    4f22:	cd bf       	out	0x3d, r28	; 61
    4f24:	cf 91       	pop	r28
    4f26:	df 91       	pop	r29
    4f28:	1f 91       	pop	r17
    4f2a:	0f 91       	pop	r16
    4f2c:	ff 90       	pop	r15
    4f2e:	ef 90       	pop	r14
    4f30:	df 90       	pop	r13
    4f32:	cf 90       	pop	r12
    4f34:	bf 90       	pop	r11
    4f36:	af 90       	pop	r10
    4f38:	9f 90       	pop	r9
    4f3a:	08 95       	ret

00004f3c <vt100SetCursorPos>:
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
}

void vt100SetCursorPos(uint8_t line, uint8_t col, cmdState_t *state)
{
    4f3c:	da 01       	movw	r26, r20
  // ESC [ Pl ; Pc H
  fprintf_P(state->myStdInOut, "\x1B[%d;%dH",line,col);
    4f3e:	2d b7       	in	r18, 0x3d	; 61
    4f40:	3e b7       	in	r19, 0x3e	; 62
    4f42:	28 50       	subi	r18, 0x08	; 8
    4f44:	30 40       	sbci	r19, 0x00	; 0
    4f46:	0f b6       	in	r0, 0x3f	; 63
    4f48:	f8 94       	cli
    4f4a:	3e bf       	out	0x3e, r19	; 62
    4f4c:	0f be       	out	0x3f, r0	; 63
    4f4e:	2d bf       	out	0x3d, r18	; 61
    4f50:	ed b7       	in	r30, 0x3d	; 61
    4f52:	fe b7       	in	r31, 0x3e	; 62
    4f54:	31 96       	adiw	r30, 0x01	; 1
    4f56:	5a 96       	adiw	r26, 0x1a	; 26
    4f58:	2d 91       	ld	r18, X+
    4f5a:	3c 91       	ld	r19, X
    4f5c:	5b 97       	sbiw	r26, 0x1b	; 27
    4f5e:	ad b7       	in	r26, 0x3d	; 61
    4f60:	be b7       	in	r27, 0x3e	; 62
    4f62:	12 96       	adiw	r26, 0x02	; 2
    4f64:	3c 93       	st	X, r19
    4f66:	2e 93       	st	-X, r18
    4f68:	11 97       	sbiw	r26, 0x01	; 1
    4f6a:	26 e2       	ldi	r18, 0x26	; 38
    4f6c:	31 e0       	ldi	r19, 0x01	; 1
    4f6e:	33 83       	std	Z+3, r19	; 0x03
    4f70:	22 83       	std	Z+2, r18	; 0x02
    4f72:	84 83       	std	Z+4, r24	; 0x04
    4f74:	15 82       	std	Z+5, r1	; 0x05
    4f76:	66 83       	std	Z+6, r22	; 0x06
    4f78:	17 82       	std	Z+7, r1	; 0x07
    4f7a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    4f7e:	2d b7       	in	r18, 0x3d	; 61
    4f80:	3e b7       	in	r19, 0x3e	; 62
    4f82:	28 5f       	subi	r18, 0xF8	; 248
    4f84:	3f 4f       	sbci	r19, 0xFF	; 255
    4f86:	0f b6       	in	r0, 0x3f	; 63
    4f88:	f8 94       	cli
    4f8a:	3e bf       	out	0x3e, r19	; 62
    4f8c:	0f be       	out	0x3f, r0	; 63
    4f8e:	2d bf       	out	0x3d, r18	; 61
}
    4f90:	08 95       	ret

00004f92 <vt100SetCursorMode>:
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
}

void vt100SetCursorMode(uint8_t visible, cmdState_t *state)
{
    4f92:	fb 01       	movw	r30, r22
    4f94:	22 8d       	ldd	r18, Z+26	; 0x1a
    4f96:	33 8d       	ldd	r19, Z+27	; 0x1b
  if(visible)
    4f98:	88 23       	and	r24, r24
    4f9a:	49 f0       	breq	.+18     	; 0x4fae <vt100SetCursorMode+0x1c>
  // ESC [ ? 25 h
    fprintf_P(state->myStdInOut, "\x1B[?25h");
    4f9c:	00 d0       	rcall	.+0      	; 0x4f9e <vt100SetCursorMode+0xc>
    4f9e:	00 d0       	rcall	.+0      	; 0x4fa0 <vt100SetCursorMode+0xe>
    4fa0:	ed b7       	in	r30, 0x3d	; 61
    4fa2:	fe b7       	in	r31, 0x3e	; 62
    4fa4:	32 83       	std	Z+2, r19	; 0x02
    4fa6:	21 83       	std	Z+1, r18	; 0x01
    4fa8:	8f e2       	ldi	r24, 0x2F	; 47
    4faa:	91 e0       	ldi	r25, 0x01	; 1
    4fac:	08 c0       	rjmp	.+16     	; 0x4fbe <vt100SetCursorMode+0x2c>
  else
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
    4fae:	00 d0       	rcall	.+0      	; 0x4fb0 <vt100SetCursorMode+0x1e>
    4fb0:	00 d0       	rcall	.+0      	; 0x4fb2 <vt100SetCursorMode+0x20>
    4fb2:	ed b7       	in	r30, 0x3d	; 61
    4fb4:	fe b7       	in	r31, 0x3e	; 62
    4fb6:	32 83       	std	Z+2, r19	; 0x02
    4fb8:	21 83       	std	Z+1, r18	; 0x01
    4fba:	86 e3       	ldi	r24, 0x36	; 54
    4fbc:	91 e0       	ldi	r25, 0x01	; 1
    4fbe:	94 83       	std	Z+4, r25	; 0x04
    4fc0:	83 83       	std	Z+3, r24	; 0x03
    4fc2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    4fc6:	0f 90       	pop	r0
    4fc8:	0f 90       	pop	r0
    4fca:	0f 90       	pop	r0
    4fcc:	0f 90       	pop	r0
    4fce:	08 95       	ret

00004fd0 <vt100SetAttr>:
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
}

void vt100SetAttr(uint8_t attr, cmdState_t *state)
{
    4fd0:	db 01       	movw	r26, r22
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
    4fd2:	00 d0       	rcall	.+0      	; 0x4fd4 <vt100SetAttr+0x4>
    4fd4:	00 d0       	rcall	.+0      	; 0x4fd6 <vt100SetAttr+0x6>
    4fd6:	00 d0       	rcall	.+0      	; 0x4fd8 <vt100SetAttr+0x8>
    4fd8:	ed b7       	in	r30, 0x3d	; 61
    4fda:	fe b7       	in	r31, 0x3e	; 62
    4fdc:	31 96       	adiw	r30, 0x01	; 1
    4fde:	5a 96       	adiw	r26, 0x1a	; 26
    4fe0:	2d 91       	ld	r18, X+
    4fe2:	3c 91       	ld	r19, X
    4fe4:	5b 97       	sbiw	r26, 0x1b	; 27
    4fe6:	ad b7       	in	r26, 0x3d	; 61
    4fe8:	be b7       	in	r27, 0x3e	; 62
    4fea:	12 96       	adiw	r26, 0x02	; 2
    4fec:	3c 93       	st	X, r19
    4fee:	2e 93       	st	-X, r18
    4ff0:	11 97       	sbiw	r26, 0x01	; 1
    4ff2:	2d e3       	ldi	r18, 0x3D	; 61
    4ff4:	31 e0       	ldi	r19, 0x01	; 1
    4ff6:	33 83       	std	Z+3, r19	; 0x03
    4ff8:	22 83       	std	Z+2, r18	; 0x02
    4ffa:	84 83       	std	Z+4, r24	; 0x04
    4ffc:	15 82       	std	Z+5, r1	; 0x05
    4ffe:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5002:	8d b7       	in	r24, 0x3d	; 61
    5004:	9e b7       	in	r25, 0x3e	; 62
    5006:	06 96       	adiw	r24, 0x06	; 6
    5008:	0f b6       	in	r0, 0x3f	; 63
    500a:	f8 94       	cli
    500c:	9e bf       	out	0x3e, r25	; 62
    500e:	0f be       	out	0x3f, r0	; 63
    5010:	8d bf       	out	0x3d, r24	; 61
}
    5012:	08 95       	ret

00005014 <vt100ClearScreen>:
}

void vt100ClearScreen(cmdState_t *state)
{
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
    5014:	00 d0       	rcall	.+0      	; 0x5016 <vt100ClearScreen+0x2>
    5016:	00 d0       	rcall	.+0      	; 0x5018 <vt100ClearScreen+0x4>
    5018:	fc 01       	movw	r30, r24
    501a:	82 8d       	ldd	r24, Z+26	; 0x1a
    501c:	93 8d       	ldd	r25, Z+27	; 0x1b
    501e:	ed b7       	in	r30, 0x3d	; 61
    5020:	fe b7       	in	r31, 0x3e	; 62
    5022:	92 83       	std	Z+2, r25	; 0x02
    5024:	81 83       	std	Z+1, r24	; 0x01
    5026:	83 e4       	ldi	r24, 0x43	; 67
    5028:	91 e0       	ldi	r25, 0x01	; 1
    502a:	94 83       	std	Z+4, r25	; 0x04
    502c:	83 83       	std	Z+3, r24	; 0x03
    502e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5032:	0f 90       	pop	r0
    5034:	0f 90       	pop	r0
    5036:	0f 90       	pop	r0
    5038:	0f 90       	pop	r0
}
    503a:	08 95       	ret

0000503c <vt100Init>:
void vt100Init(cmdState_t *state)
{
  // initializes terminal to "power-on" settings
  // ESC c

 fprintf_P(state->myStdInOut, "\x1B\x63");
    503c:	00 d0       	rcall	.+0      	; 0x503e <vt100Init+0x2>
    503e:	00 d0       	rcall	.+0      	; 0x5040 <vt100Init+0x4>
    5040:	fc 01       	movw	r30, r24
    5042:	82 8d       	ldd	r24, Z+26	; 0x1a
    5044:	93 8d       	ldd	r25, Z+27	; 0x1b
    5046:	ed b7       	in	r30, 0x3d	; 61
    5048:	fe b7       	in	r31, 0x3e	; 62
    504a:	92 83       	std	Z+2, r25	; 0x02
    504c:	81 83       	std	Z+1, r24	; 0x01
    504e:	88 e4       	ldi	r24, 0x48	; 72
    5050:	91 e0       	ldi	r25, 0x01	; 1
    5052:	94 83       	std	Z+4, r25	; 0x04
    5054:	83 83       	std	Z+3, r24	; 0x03
    5056:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    505a:	0f 90       	pop	r0
    505c:	0f 90       	pop	r0
    505e:	0f 90       	pop	r0
    5060:	0f 90       	pop	r0
}
    5062:	08 95       	ret
    5064:	08 95       	ret
    5066:	08 95       	ret

00005068 <ds1305readMem>:
  spiDisableDS1305();  
  spiGive();
  return 0;
}
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
    5068:	0f 93       	push	r16
    506a:	1f 93       	push	r17
    506c:	cf 93       	push	r28
    506e:	df 93       	push	r29
    5070:	18 2f       	mov	r17, r24
    5072:	06 2f       	mov	r16, r22
    5074:	ea 01       	movw	r28, r20
  if (addr >95)
    5076:	80 36       	cpi	r24, 0x60	; 96
    5078:	10 f0       	brcs	.+4      	; 0x507e <ds1305readMem+0x16>
    507a:	81 e0       	ldi	r24, 0x01	; 1
    507c:	1d c0       	rjmp	.+58     	; 0x50b8 <ds1305readMem+0x50>
    return 1;
  if (addr + length > 95)
    507e:	90 e0       	ldi	r25, 0x00	; 0
    5080:	86 0f       	add	r24, r22
    5082:	91 1d       	adc	r25, r1
    5084:	80 36       	cpi	r24, 0x60	; 96
    5086:	91 05       	cpc	r25, r1
    5088:	14 f0       	brlt	.+4      	; 0x508e <ds1305readMem+0x26>
    508a:	82 e0       	ldi	r24, 0x02	; 2
    508c:	15 c0       	rjmp	.+42     	; 0x50b8 <ds1305readMem+0x50>
    return 2;
  
  addr += 0x20;
  
  spiTake();
    508e:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  spiEnableDS1305();
    5092:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <spiEnableDS1305>

  spiSend(addr);
    5096:	81 2f       	mov	r24, r17
    5098:	80 5e       	subi	r24, 0xE0	; 224
    509a:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    509e:	05 c0       	rjmp	.+10     	; 0x50aa <ds1305readMem+0x42>
  while (length > 0)
  {
    *data = spiSend(0);
    50a0:	80 e0       	ldi	r24, 0x00	; 0
    50a2:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    50a6:	89 93       	st	Y+, r24
    data++;
    length--;
    50a8:	01 50       	subi	r16, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    50aa:	00 23       	and	r16, r16
    50ac:	c9 f7       	brne	.-14     	; 0x50a0 <ds1305readMem+0x38>
    *data = spiSend(0);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    50ae:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <spiDisableDS1305>
  spiGive();
    50b2:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
    50b6:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    50b8:	df 91       	pop	r29
    50ba:	cf 91       	pop	r28
    50bc:	1f 91       	pop	r17
    50be:	0f 91       	pop	r16
    50c0:	08 95       	ret

000050c2 <ds1305writeMem>:
  return;
}


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
    50c2:	0f 93       	push	r16
    50c4:	1f 93       	push	r17
    50c6:	cf 93       	push	r28
    50c8:	df 93       	push	r29
    50ca:	18 2f       	mov	r17, r24
    50cc:	06 2f       	mov	r16, r22
    50ce:	ea 01       	movw	r28, r20
  if (addr > 95)
    50d0:	80 36       	cpi	r24, 0x60	; 96
    50d2:	10 f0       	brcs	.+4      	; 0x50d8 <ds1305writeMem+0x16>
    50d4:	81 e0       	ldi	r24, 0x01	; 1
    50d6:	1c c0       	rjmp	.+56     	; 0x5110 <ds1305writeMem+0x4e>
    return 1;
  if (addr + length > 95)
    50d8:	90 e0       	ldi	r25, 0x00	; 0
    50da:	86 0f       	add	r24, r22
    50dc:	91 1d       	adc	r25, r1
    50de:	80 36       	cpi	r24, 0x60	; 96
    50e0:	91 05       	cpc	r25, r1
    50e2:	14 f0       	brlt	.+4      	; 0x50e8 <ds1305writeMem+0x26>
    50e4:	82 e0       	ldi	r24, 0x02	; 2
    50e6:	14 c0       	rjmp	.+40     	; 0x5110 <ds1305writeMem+0x4e>
    return 2;

  addr += 0xA0;
  
  spiTake();
    50e8:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  spiEnableDS1305();
    50ec:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <spiEnableDS1305>

  spiSend(addr);
    50f0:	81 2f       	mov	r24, r17
    50f2:	80 56       	subi	r24, 0x60	; 96
    50f4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    50f8:	04 c0       	rjmp	.+8      	; 0x5102 <ds1305writeMem+0x40>
  while (length > 0)
  {
    spiSend(*data);
    50fa:	89 91       	ld	r24, Y+
    50fc:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    data++;
    length--;
    5100:	01 50       	subi	r16, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    5102:	00 23       	and	r16, r16
    5104:	d1 f7       	brne	.-12     	; 0x50fa <ds1305writeMem+0x38>
    spiSend(*data);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    5106:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <spiDisableDS1305>
  spiGive();
    510a:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
    510e:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    5110:	df 91       	pop	r29
    5112:	cf 91       	pop	r28
    5114:	1f 91       	pop	r17
    5116:	0f 91       	pop	r16
    5118:	08 95       	ret

0000511a <ds1305start>:
}
#endif /* USE_DECODED_TIME_STRUCT */

void ds1305start(void)
{  
  spiTake();
    511a:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  spiEnableDS1305();
    511e:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <spiEnableDS1305>

  spiSend(0x8F);
    5122:	8f e8       	ldi	r24, 0x8F	; 143
    5124:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(0x00);
    5128:	80 e0       	ldi	r24, 0x00	; 0
    512a:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  
  spiDisableDS1305();  
    512e:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <spiDisableDS1305>
  spiGive();
    5132:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>

  return;
}
    5136:	08 95       	ret

00005138 <setTimeBCD>:
}
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
{
    5138:	0f 93       	push	r16
    513a:	1f 93       	push	r17
    513c:	cf 93       	push	r28
    513e:	df 93       	push	r29
    5140:	18 2f       	mov	r17, r24
    5142:	09 2f       	mov	r16, r25
  spiTake();
    5144:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  spiEnableDS1305();
    5148:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    514c:	21 2f       	mov	r18, r17
    514e:	30 2f       	mov	r19, r16
    5150:	c9 01       	movw	r24, r18
    5152:	ec 01       	movw	r28, r24
  uint8_t i;
  spiSend(0x80);
    5154:	80 e8       	ldi	r24, 0x80	; 128
    5156:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    515a:	10 e0       	ldi	r17, 0x00	; 0
  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    spiSend(*ptr);
    515c:	89 91       	ld	r24, Y+
    515e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiEnableDS1305();
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
    5162:	1f 5f       	subi	r17, 0xFF	; 255
    5164:	17 30       	cpi	r17, 0x07	; 7
    5166:	d1 f7       	brne	.-12     	; 0x515c <setTimeBCD+0x24>
  {
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
    5168:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <spiDisableDS1305>
  spiGive();
    516c:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    5170:	df 91       	pop	r29
    5172:	cf 91       	pop	r28
    5174:	1f 91       	pop	r17
    5176:	0f 91       	pop	r16
    5178:	08 95       	ret

0000517a <setTime>:
{
  setTimeBCD((timeBCD_t *)(time));
}
void setTime(time_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    517a:	0e 94 9c 28 	call	0x5138	; 0x5138 <setTimeBCD>
}
    517e:	08 95       	ret

00005180 <setTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void setTimeDecoded(timeDecoded_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    5180:	0e 94 9c 28 	call	0x5138	; 0x5138 <setTimeBCD>
}
    5184:	08 95       	ret

00005186 <readTimeBCD>:
void spiEnableDS1305(void)  {};
void spiDisableDS1305(void) {};


void readTimeBCD(timeBCD_t *time)
{
    5186:	0f 93       	push	r16
    5188:	1f 93       	push	r17
    518a:	cf 93       	push	r28
    518c:	df 93       	push	r29
    518e:	18 2f       	mov	r17, r24
    5190:	09 2f       	mov	r16, r25
  spiTake();
    5192:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  spiEnableDS1305();
    5196:	0e 94 bb 0d 	call	0x1b76	; 0x1b76 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    519a:	21 2f       	mov	r18, r17
    519c:	30 2f       	mov	r19, r16
    519e:	c9 01       	movw	r24, r18
    51a0:	ec 01       	movw	r28, r24
  uint8_t i;
  
  spiSend(0x00);
    51a2:	80 e0       	ldi	r24, 0x00	; 0
    51a4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    51a8:	10 e0       	ldi	r17, 0x00	; 0

  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    *ptr = spiSend(i);
    51aa:	81 2f       	mov	r24, r17
    51ac:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    51b0:	89 93       	st	Y+, r24
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);

  for (i=0; i<sizeof(timeBCD_t); i++)
    51b2:	1f 5f       	subi	r17, 0xFF	; 255
    51b4:	17 30       	cpi	r17, 0x07	; 7
    51b6:	c9 f7       	brne	.-14     	; 0x51aa <readTimeBCD+0x24>
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
    51b8:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <spiDisableDS1305>
  spiGive();
    51bc:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    51c0:	df 91       	pop	r29
    51c2:	cf 91       	pop	r28
    51c4:	1f 91       	pop	r17
    51c6:	0f 91       	pop	r16
    51c8:	08 95       	ret

000051ca <readTime>:
{
  readTimeBCD((timeBCD_t *)(time));
}
void readTime (time_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    51ca:	0e 94 c3 28 	call	0x5186	; 0x5186 <readTimeBCD>
}
    51ce:	08 95       	ret

000051d0 <readTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void readTimeDecoded(timeDecoded_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    51d0:	0e 94 c3 28 	call	0x5186	; 0x5186 <readTimeBCD>
}
    51d4:	08 95       	ret
    51d6:	08 95       	ret
    51d8:	08 95       	ret

000051da <MPC23s17ReadPortB>:

  return result; 
}

uint8_t MPC23s17ReadPortB(uint8_t addr)
{
    51da:	1f 93       	push	r17
  addr = addr<<1;
    51dc:	18 2f       	mov	r17, r24
    51de:	11 0f       	add	r17, r17
  addr &= 0x0E;
    51e0:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    51e2:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    51e4:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    51e8:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>

  spiSend(addr);
    51ec:	81 2f       	mov	r24, r17
    51ee:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_GPIOB);
    51f2:	83 e1       	ldi	r24, 0x13	; 19
    51f4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  uint8_t result = spiSend(addr);  
    51f8:	81 2f       	mov	r24, r17
    51fa:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    51fe:	18 2f       	mov	r17, r24

  disableSpiMPC23S17();
    5200:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    5204:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>

  return result; 
}
    5208:	81 2f       	mov	r24, r17
    520a:	1f 91       	pop	r17
    520c:	08 95       	ret

0000520e <MPC23s17ReadPortA>:
  disableSpiMPC23S17();
  spiGive();
}

uint8_t MPC23s17ReadPortA(uint8_t addr)
{
    520e:	1f 93       	push	r17
  addr = addr<<1;
    5210:	18 2f       	mov	r17, r24
    5212:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5214:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    5216:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    5218:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    521c:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>

  spiSend(addr);
    5220:	81 2f       	mov	r24, r17
    5222:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_GPIOA);
    5226:	82 e1       	ldi	r24, 0x12	; 18
    5228:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  uint8_t result = spiSend(addr);  
    522c:	81 2f       	mov	r24, r17
    522e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    5232:	18 2f       	mov	r17, r24

  disableSpiMPC23S17();
    5234:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    5238:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>

  return result; 
}
    523c:	81 2f       	mov	r24, r17
    523e:	1f 91       	pop	r17
    5240:	08 95       	ret

00005242 <MPC23s17ClearBitsOnPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17ClearBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5242:	1f 93       	push	r17
    5244:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5246:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5248:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB &= (~portBout);
    524a:	90 91 79 0e 	lds	r25, 0x0E79
    524e:	80 95       	com	r24
    5250:	98 23       	and	r25, r24
    5252:	90 93 79 0e 	sts	0x0E79, r25

  spiTake();
    5256:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    525a:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  spiSend(addr);
    525e:	81 2f       	mov	r24, r17
    5260:	80 64       	ori	r24, 0x40	; 64
    5262:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_OLATB);
    5266:	85 e1       	ldi	r24, 0x15	; 21
    5268:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portB);  
    526c:	80 91 79 0e 	lds	r24, 0x0E79
    5270:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>

  disableSpiMPC23S17();
    5274:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    5278:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    527c:	1f 91       	pop	r17
    527e:	08 95       	ret

00005280 <MPC23s17SetBitsOnPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5280:	1f 93       	push	r17
    5282:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5284:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5286:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB |= portBout;
    5288:	90 91 79 0e 	lds	r25, 0x0E79
    528c:	98 2b       	or	r25, r24
    528e:	90 93 79 0e 	sts	0x0E79, r25

  spiTake();
    5292:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    5296:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  spiSend(addr);
    529a:	81 2f       	mov	r24, r17
    529c:	80 64       	ori	r24, 0x40	; 64
    529e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_OLATB);
    52a2:	85 e1       	ldi	r24, 0x15	; 21
    52a4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portB);  
    52a8:	80 91 79 0e 	lds	r24, 0x0E79
    52ac:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  disableSpiMPC23S17();
    52b0:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    52b4:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    52b8:	1f 91       	pop	r17
    52ba:	08 95       	ret

000052bc <MPC23s17SetPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetPortB(uint8_t portBout, uint8_t addr)
{
    52bc:	1f 93       	push	r17
    52be:	16 2f       	mov	r17, r22
  addr = addr<<1;
    52c0:	11 0f       	add	r17, r17
  addr &= 0x0E;
    52c2:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB = portBout;
    52c4:	80 93 79 0e 	sts	0x0E79, r24

  spiTake();
    52c8:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    52cc:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  spiSend(addr);
    52d0:	81 2f       	mov	r24, r17
    52d2:	80 64       	ori	r24, 0x40	; 64
    52d4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_OLATB);
    52d8:	85 e1       	ldi	r24, 0x15	; 21
    52da:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portB);  
    52de:	80 91 79 0e 	lds	r24, 0x0E79
    52e2:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  disableSpiMPC23S17();
    52e6:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    52ea:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    52ee:	1f 91       	pop	r17
    52f0:	08 95       	ret

000052f2 <MPC23s17ClearBitsOnPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17ClearBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    52f2:	1f 93       	push	r17
    52f4:	16 2f       	mov	r17, r22
  addr = addr<<1;
    52f6:	11 0f       	add	r17, r17
  addr &= 0x0E;
    52f8:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA &= (~portAout);
    52fa:	90 91 c7 0e 	lds	r25, 0x0EC7
    52fe:	80 95       	com	r24
    5300:	98 23       	and	r25, r24
    5302:	90 93 c7 0e 	sts	0x0EC7, r25

  spiTake();
    5306:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    530a:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  spiSend(addr);
    530e:	81 2f       	mov	r24, r17
    5310:	80 64       	ori	r24, 0x40	; 64
    5312:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_OLATA);
    5316:	84 e1       	ldi	r24, 0x14	; 20
    5318:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portA);  
    531c:	80 91 c7 0e 	lds	r24, 0x0EC7
    5320:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  disableSpiMPC23S17();
    5324:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    5328:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    532c:	1f 91       	pop	r17
    532e:	08 95       	ret

00005330 <MPC23s17SetBitsOnPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    5330:	1f 93       	push	r17
    5332:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5334:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5336:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA |= portAout;  
    5338:	90 91 c7 0e 	lds	r25, 0x0EC7
    533c:	98 2b       	or	r25, r24
    533e:	90 93 c7 0e 	sts	0x0EC7, r25

  spiTake();
    5342:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    5346:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  spiSend(addr);
    534a:	81 2f       	mov	r24, r17
    534c:	80 64       	ori	r24, 0x40	; 64
    534e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_OLATA);
    5352:	84 e1       	ldi	r24, 0x14	; 20
    5354:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portA);  
    5358:	80 91 c7 0e 	lds	r24, 0x0EC7
    535c:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  disableSpiMPC23S17();
    5360:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    5364:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    5368:	1f 91       	pop	r17
    536a:	08 95       	ret

0000536c <MPC23s17SetPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetPortA(uint8_t portAout, uint8_t addr)
{
    536c:	0f 93       	push	r16
    536e:	1f 93       	push	r17
    5370:	18 2f       	mov	r17, r24
    5372:	06 2f       	mov	r16, r22
  addr = addr<<1;
    5374:	00 0f       	add	r16, r16
  addr &= 0x0E;
    5376:	0e 70       	andi	r16, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    5378:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    537c:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  portA = portAout;  
    5380:	10 93 c7 0e 	sts	0x0EC7, r17
  spiSend(addr);
    5384:	80 2f       	mov	r24, r16
    5386:	80 64       	ori	r24, 0x40	; 64
    5388:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_OLATA);
    538c:	84 e1       	ldi	r24, 0x14	; 20
    538e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portA);  
    5392:	80 91 c7 0e 	lds	r24, 0x0EC7
    5396:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>

  disableSpiMPC23S17();
    539a:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    539e:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    53a2:	1f 91       	pop	r17
    53a4:	0f 91       	pop	r16
    53a6:	08 95       	ret

000053a8 <MPC23s17SetDirB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetDirB(uint8_t portBdir, uint8_t addr)
{
    53a8:	0f 93       	push	r16
    53aa:	1f 93       	push	r17
    53ac:	08 2f       	mov	r16, r24
    53ae:	16 2f       	mov	r17, r22
  addr = addr<<1;
    53b0:	11 0f       	add	r17, r17
  addr &= 0x0E;
    53b2:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    53b4:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17();
    53b8:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  
  spiSend(addr);
    53bc:	81 2f       	mov	r24, r17
    53be:	80 64       	ori	r24, 0x40	; 64
    53c0:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_IODIRB);
    53c4:	81 e0       	ldi	r24, 0x01	; 1
    53c6:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portBdir);  
    53ca:	80 2f       	mov	r24, r16
    53cc:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  
  disableSpiMPC23S17();
    53d0:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    53d4:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    53d8:	1f 91       	pop	r17
    53da:	0f 91       	pop	r16
    53dc:	08 95       	ret

000053de <MPC23s17SetDirA>:
void enableSpiMPC23S17(void)  {}
void disableSpiMPC23S17(void) {}


void MPC23s17SetDirA(uint8_t portAdir, uint8_t addr)
{
    53de:	0f 93       	push	r16
    53e0:	1f 93       	push	r17
    53e2:	08 2f       	mov	r16, r24
    53e4:	16 2f       	mov	r17, r22
  addr = addr<<1;
    53e6:	11 0f       	add	r17, r17
  addr &= 0x0E;
    53e8:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    53ea:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMPC23S17(); 
    53ee:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <enableSpiMPC23S17>
  spiSend(addr);
    53f2:	81 2f       	mov	r24, r17
    53f4:	80 64       	ori	r24, 0x40	; 64
    53f6:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(B0_IODIRA);
    53fa:	80 e0       	ldi	r24, 0x00	; 0
    53fc:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(portAdir);  
    5400:	80 2f       	mov	r24, r16
    5402:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  
  disableSpiMPC23S17();
    5406:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <disableSpiMPC23S17>
  spiGive();
    540a:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    540e:	1f 91       	pop	r17
    5410:	0f 91       	pop	r16
    5412:	08 95       	ret
    5414:	08 95       	ret
    5416:	08 95       	ret

00005418 <MCP3008_getSampleSingle>:
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}

uint16_t MCP3008_getSampleSingle(uint8_t inputNo)
{
    5418:	ff 92       	push	r15
    541a:	0f 93       	push	r16
    541c:	1f 93       	push	r17
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    541e:	18 2f       	mov	r17, r24
    5420:	12 95       	swap	r17
  inputNo &= 0x70;
    5422:	10 77       	andi	r17, 0x70	; 112
  inputNo |= 0x80;
  
  spiTake();
    5424:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMCP3008();
    5428:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <enableSpiMCP3008>
  
  spiSend(0x01);                //Start
    542c:	81 e0       	ldi	r24, 0x01	; 1
    542e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    5432:	81 2f       	mov	r24, r17
    5434:	80 68       	ori	r24, 0x80	; 128
    5436:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    543a:	f8 2e       	mov	r15, r24
  resultLo = spiSend(0);        //X X X X X X X X
    543c:	80 e0       	ldi	r24, 0x00	; 0
    543e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    5442:	08 2f       	mov	r16, r24
  
  disableSpiMCP3008(); 
    5444:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <disableSpiMCP3008>
  spiGive();
    5448:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
    544c:	9f 2d       	mov	r25, r15
    544e:	93 70       	andi	r25, 0x03	; 3
    5450:	80 e0       	ldi	r24, 0x00	; 0
    5452:	10 e0       	ldi	r17, 0x00	; 0
    5454:	08 2b       	or	r16, r24
    5456:	19 2b       	or	r17, r25
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}
    5458:	c8 01       	movw	r24, r16
    545a:	1f 91       	pop	r17
    545c:	0f 91       	pop	r16
    545e:	ff 90       	pop	r15
    5460:	08 95       	ret

00005462 <MCP3008_getSampleDiff>:
void enableSpiMCP3008(void)   {};
void disableSpiMCP3008(void)  {};


uint16_t MCP3008_getSampleDiff(uint8_t inputNo)
{
    5462:	ff 92       	push	r15
    5464:	0f 93       	push	r16
    5466:	1f 93       	push	r17
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    5468:	18 2f       	mov	r17, r24
    546a:	12 95       	swap	r17
    546c:	10 7f       	andi	r17, 0xF0	; 240
  inputNo &= 0x70;
  
  spiTake();
    546e:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMCP3008();
    5472:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <enableSpiMCP3008>
  
  spiSend(0x01);                               //Start
    5476:	81 e0       	ldi	r24, 0x01	; 1
    5478:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    547c:	81 2f       	mov	r24, r17
    547e:	80 77       	andi	r24, 0x70	; 112
    5480:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    5484:	f8 2e       	mov	r15, r24
  resultLo = spiSend(0);        //X X X X X X X X
    5486:	80 e0       	ldi	r24, 0x00	; 0
    5488:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    548c:	08 2f       	mov	r16, r24
  
  disableSpiMCP3008(); 
    548e:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <disableSpiMCP3008>
  spiGive();
    5492:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
    5496:	9f 2d       	mov	r25, r15
    5498:	93 70       	andi	r25, 0x03	; 3
    549a:	80 e0       	ldi	r24, 0x00	; 0
    549c:	10 e0       	ldi	r17, 0x00	; 0
    549e:	08 2b       	or	r16, r24
    54a0:	19 2b       	or	r17, r25
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}
    54a2:	c8 01       	movw	r24, r16
    54a4:	1f 91       	pop	r17
    54a6:	0f 91       	pop	r16
    54a8:	ff 90       	pop	r15
    54aa:	08 95       	ret
    54ac:	08 95       	ret
    54ae:	08 95       	ret

000054b0 <MCP4150_setValue>:
/**
 * Ustawia wartość rezystancji
 * @param inputNo - WARTOŚĆ OD 0 DO 255.
 */
void MCP4150_setValue(uint8_t value)
{  
    54b0:	1f 93       	push	r17
    54b2:	18 2f       	mov	r17, r24
  spiTake();
    54b4:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  enableSpiMCP4150();
    54b8:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <enableSpiMCP4150>
  
  spiSend(0x11);  
    54bc:	81 e1       	ldi	r24, 0x11	; 17
    54be:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(value);
    54c2:	81 2f       	mov	r24, r17
    54c4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  
  disableSpiMCP4150(); 
    54c8:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <disableSpiMCP4150>
  spiGive();
    54cc:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    54d0:	1f 91       	pop	r17
    54d2:	08 95       	ret
    54d4:	08 95       	ret
    54d6:	08 95       	ret

000054d8 <enc28j60WriteOp>:
  spiGive();
  return result; 
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
    54d8:	ff 92       	push	r15
    54da:	0f 93       	push	r16
    54dc:	1f 93       	push	r17
    54de:	18 2f       	mov	r17, r24
    54e0:	06 2f       	mov	r16, r22
    54e2:	f4 2e       	mov	r15, r20
  spiTake();
    54e4:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  spiEnableEnc28j60();
    54e8:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <spiEnableEnc28j60>
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSend(op | (address & ADDR_MASK));
    54ec:	0f 71       	andi	r16, 0x1F	; 31
    54ee:	80 2f       	mov	r24, r16
    54f0:	81 2b       	or	r24, r17
    54f2:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiSend(data);
    54f6:	8f 2d       	mov	r24, r15
    54f8:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
  spiDisableEnc28j60();
    54fc:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <spiDisableEnc28j60>
  spiGive();
    5500:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
}
    5504:	1f 91       	pop	r17
    5506:	0f 91       	pop	r16
    5508:	ff 90       	pop	r15
    550a:	08 95       	ret

0000550c <enc28j60SetBank>:
//   spiGive();
// }


void enc28j60SetBank(uint8_t address)
{
    550c:	1f 93       	push	r17
    550e:	cf 93       	push	r28
    5510:	df 93       	push	r29
    5512:	18 2f       	mov	r17, r24
  // set the bank (if needed)
  if((address & BANK_MASK) != Enc28j60Bank)
    5514:	c8 2f       	mov	r28, r24
    5516:	d0 e0       	ldi	r29, 0x00	; 0
    5518:	c0 76       	andi	r28, 0x60	; 96
    551a:	d0 70       	andi	r29, 0x00	; 0
    551c:	80 91 90 01 	lds	r24, 0x0190
    5520:	90 e0       	ldi	r25, 0x00	; 0
    5522:	c8 17       	cp	r28, r24
    5524:	d9 07       	cpc	r29, r25
    5526:	91 f0       	breq	.+36     	; 0x554c <enc28j60SetBank+0x40>
  {
    // set the bank
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    5528:	80 ea       	ldi	r24, 0xA0	; 160
    552a:	6f e1       	ldi	r22, 0x1F	; 31
    552c:	43 e0       	ldi	r20, 0x03	; 3
    552e:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    5532:	85 e0       	ldi	r24, 0x05	; 5
    5534:	d5 95       	asr	r29
    5536:	c7 95       	ror	r28
    5538:	8a 95       	dec	r24
    553a:	e1 f7       	brne	.-8      	; 0x5534 <enc28j60SetBank+0x28>
    553c:	80 e8       	ldi	r24, 0x80	; 128
    553e:	6f e1       	ldi	r22, 0x1F	; 31
    5540:	4c 2f       	mov	r20, r28
    5542:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    Enc28j60Bank = (address & BANK_MASK);
    5546:	10 76       	andi	r17, 0x60	; 96
    5548:	10 93 90 01 	sts	0x0190, r17
  }
}
    554c:	df 91       	pop	r29
    554e:	cf 91       	pop	r28
    5550:	1f 91       	pop	r17
    5552:	08 95       	ret

00005554 <enc28j60Write>:

  return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    5554:	0f 93       	push	r16
    5556:	1f 93       	push	r17
    5558:	18 2f       	mov	r17, r24
    555a:	06 2f       	mov	r16, r22
  // set the bank
  enc28j60SetBank(address);
    555c:	0e 94 86 2a 	call	0x550c	; 0x550c <enc28j60SetBank>
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    5560:	80 e4       	ldi	r24, 0x40	; 64
    5562:	61 2f       	mov	r22, r17
    5564:	40 2f       	mov	r20, r16
    5566:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
}
    556a:	1f 91       	pop	r17
    556c:	0f 91       	pop	r16
    556e:	08 95       	ret

00005570 <nicSetMacAddress>:
    5570:	0f 93       	push	r16
    5572:	1f 93       	push	r17
    5574:	8c 01       	movw	r16, r24
    5576:	84 ee       	ldi	r24, 0xE4	; 228
    5578:	f8 01       	movw	r30, r16
    557a:	60 81       	ld	r22, Z
    557c:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5580:	85 ee       	ldi	r24, 0xE5	; 229
    5582:	f8 01       	movw	r30, r16
    5584:	61 81       	ldd	r22, Z+1	; 0x01
    5586:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    558a:	82 ee       	ldi	r24, 0xE2	; 226
    558c:	f8 01       	movw	r30, r16
    558e:	62 81       	ldd	r22, Z+2	; 0x02
    5590:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5594:	83 ee       	ldi	r24, 0xE3	; 227
    5596:	f8 01       	movw	r30, r16
    5598:	63 81       	ldd	r22, Z+3	; 0x03
    559a:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    559e:	80 ee       	ldi	r24, 0xE0	; 224
    55a0:	f8 01       	movw	r30, r16
    55a2:	64 81       	ldd	r22, Z+4	; 0x04
    55a4:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    55a8:	81 ee       	ldi	r24, 0xE1	; 225
    55aa:	f8 01       	movw	r30, r16
    55ac:	65 81       	ldd	r22, Z+5	; 0x05
    55ae:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    55b2:	1f 91       	pop	r17
    55b4:	0f 91       	pop	r16
    55b6:	08 95       	ret

000055b8 <enc28j60ReadOp>:
    enc28j60PhyWrite    (PHLCON, 0x476);
    vTaskDelay          (2);
}

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
    55b8:	0f 93       	push	r16
    55ba:	1f 93       	push	r17
    55bc:	18 2f       	mov	r17, r24
    55be:	06 2f       	mov	r16, r22
  uint8_t result;
  spiTake();
    55c0:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
  spiEnableEnc28j60();
    55c4:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <spiEnableEnc28j60>
  
  // issue read command
  spiSend(op | (address & ADDR_MASK));
    55c8:	80 2f       	mov	r24, r16
    55ca:	8f 71       	andi	r24, 0x1F	; 31
    55cc:	81 2b       	or	r24, r17
    55ce:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>

  // read data
  result = spiSend(0x00);
    55d2:	80 e0       	ldi	r24, 0x00	; 0
    55d4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    55d8:	18 2f       	mov	r17, r24

  // do dummy read if needed (for mac and mii, see datasheet page 29)
  if(address & 0x80)
    55da:	07 ff       	sbrs	r16, 7
    55dc:	04 c0       	rjmp	.+8      	; 0x55e6 <enc28j60ReadOp+0x2e>
  {
    result = spiSend(0x00);
    55de:	80 e0       	ldi	r24, 0x00	; 0
    55e0:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    55e4:	18 2f       	mov	r17, r24
  }

  spiDisableEnc28j60();
    55e6:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <spiDisableEnc28j60>
  spiGive();
    55ea:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
  return result; 
}
    55ee:	81 2f       	mov	r24, r17
    55f0:	1f 91       	pop	r17
    55f2:	0f 91       	pop	r16
    55f4:	08 95       	ret

000055f6 <enc28j60Read>:
    Enc28j60Bank = (address & BANK_MASK);
  }
}

uint8_t enc28j60Read(uint8_t address)
{
    55f6:	1f 93       	push	r17
    55f8:	18 2f       	mov	r17, r24
  // set the bank
  enc28j60SetBank(address);
    55fa:	0e 94 86 2a 	call	0x550c	; 0x550c <enc28j60SetBank>
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    55fe:	80 e0       	ldi	r24, 0x00	; 0
    5600:	61 2f       	mov	r22, r17
    5602:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
  return result;
}
    5606:	1f 91       	pop	r17
    5608:	08 95       	ret

0000560a <nicRegDump>:
    560a:	0f 93       	push	r16
    560c:	1f 93       	push	r17
    560e:	8c 01       	movw	r16, r24
    5610:	00 d0       	rcall	.+0      	; 0x5612 <nicRegDump+0x8>
    5612:	00 d0       	rcall	.+0      	; 0x5614 <nicRegDump+0xa>
    5614:	ad b7       	in	r26, 0x3d	; 61
    5616:	be b7       	in	r27, 0x3e	; 62
    5618:	12 96       	adiw	r26, 0x02	; 2
    561a:	9c 93       	st	X, r25
    561c:	8e 93       	st	-X, r24
    561e:	11 97       	sbiw	r26, 0x01	; 1
    5620:	80 e4       	ldi	r24, 0x40	; 64
    5622:	9c e0       	ldi	r25, 0x0C	; 12
    5624:	14 96       	adiw	r26, 0x04	; 4
    5626:	9c 93       	st	X, r25
    5628:	8e 93       	st	-X, r24
    562a:	13 97       	sbiw	r26, 0x03	; 3
    562c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5630:	0f 90       	pop	r0
    5632:	0f 90       	pop	r0
    5634:	0f 90       	pop	r0
    5636:	0f 90       	pop	r0
    5638:	81 ee       	ldi	r24, 0xE1	; 225
    563a:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    563e:	00 d0       	rcall	.+0      	; 0x5640 <nicRegDump+0x36>
    5640:	00 d0       	rcall	.+0      	; 0x5642 <nicRegDump+0x38>
    5642:	00 d0       	rcall	.+0      	; 0x5644 <nicRegDump+0x3a>
    5644:	ed b7       	in	r30, 0x3d	; 61
    5646:	fe b7       	in	r31, 0x3e	; 62
    5648:	31 96       	adiw	r30, 0x01	; 1
    564a:	ad b7       	in	r26, 0x3d	; 61
    564c:	be b7       	in	r27, 0x3e	; 62
    564e:	12 96       	adiw	r26, 0x02	; 2
    5650:	1c 93       	st	X, r17
    5652:	0e 93       	st	-X, r16
    5654:	11 97       	sbiw	r26, 0x01	; 1
    5656:	21 e3       	ldi	r18, 0x31	; 49
    5658:	3c e0       	ldi	r19, 0x0C	; 12
    565a:	33 83       	std	Z+3, r19	; 0x03
    565c:	22 83       	std	Z+2, r18	; 0x02
    565e:	84 83       	std	Z+4, r24	; 0x04
    5660:	15 82       	std	Z+5, r1	; 0x05
    5662:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5666:	ed b7       	in	r30, 0x3d	; 61
    5668:	fe b7       	in	r31, 0x3e	; 62
    566a:	36 96       	adiw	r30, 0x06	; 6
    566c:	0f b6       	in	r0, 0x3f	; 63
    566e:	f8 94       	cli
    5670:	fe bf       	out	0x3e, r31	; 62
    5672:	0f be       	out	0x3f, r0	; 63
    5674:	ed bf       	out	0x3d, r30	; 61
    5676:	80 ee       	ldi	r24, 0xE0	; 224
    5678:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    567c:	00 d0       	rcall	.+0      	; 0x567e <nicRegDump+0x74>
    567e:	00 d0       	rcall	.+0      	; 0x5680 <nicRegDump+0x76>
    5680:	00 d0       	rcall	.+0      	; 0x5682 <nicRegDump+0x78>
    5682:	ed b7       	in	r30, 0x3d	; 61
    5684:	fe b7       	in	r31, 0x3e	; 62
    5686:	31 96       	adiw	r30, 0x01	; 1
    5688:	ad b7       	in	r26, 0x3d	; 61
    568a:	be b7       	in	r27, 0x3e	; 62
    568c:	12 96       	adiw	r26, 0x02	; 2
    568e:	1c 93       	st	X, r17
    5690:	0e 93       	st	-X, r16
    5692:	11 97       	sbiw	r26, 0x01	; 1
    5694:	22 e2       	ldi	r18, 0x22	; 34
    5696:	3c e0       	ldi	r19, 0x0C	; 12
    5698:	33 83       	std	Z+3, r19	; 0x03
    569a:	22 83       	std	Z+2, r18	; 0x02
    569c:	84 83       	std	Z+4, r24	; 0x04
    569e:	15 82       	std	Z+5, r1	; 0x05
    56a0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    56a4:	ed b7       	in	r30, 0x3d	; 61
    56a6:	fe b7       	in	r31, 0x3e	; 62
    56a8:	36 96       	adiw	r30, 0x06	; 6
    56aa:	0f b6       	in	r0, 0x3f	; 63
    56ac:	f8 94       	cli
    56ae:	fe bf       	out	0x3e, r31	; 62
    56b0:	0f be       	out	0x3f, r0	; 63
    56b2:	ed bf       	out	0x3d, r30	; 61
    56b4:	83 ee       	ldi	r24, 0xE3	; 227
    56b6:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    56ba:	00 d0       	rcall	.+0      	; 0x56bc <nicRegDump+0xb2>
    56bc:	00 d0       	rcall	.+0      	; 0x56be <nicRegDump+0xb4>
    56be:	00 d0       	rcall	.+0      	; 0x56c0 <nicRegDump+0xb6>
    56c0:	ed b7       	in	r30, 0x3d	; 61
    56c2:	fe b7       	in	r31, 0x3e	; 62
    56c4:	31 96       	adiw	r30, 0x01	; 1
    56c6:	ad b7       	in	r26, 0x3d	; 61
    56c8:	be b7       	in	r27, 0x3e	; 62
    56ca:	12 96       	adiw	r26, 0x02	; 2
    56cc:	1c 93       	st	X, r17
    56ce:	0e 93       	st	-X, r16
    56d0:	11 97       	sbiw	r26, 0x01	; 1
    56d2:	23 e1       	ldi	r18, 0x13	; 19
    56d4:	3c e0       	ldi	r19, 0x0C	; 12
    56d6:	33 83       	std	Z+3, r19	; 0x03
    56d8:	22 83       	std	Z+2, r18	; 0x02
    56da:	84 83       	std	Z+4, r24	; 0x04
    56dc:	15 82       	std	Z+5, r1	; 0x05
    56de:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    56e2:	ed b7       	in	r30, 0x3d	; 61
    56e4:	fe b7       	in	r31, 0x3e	; 62
    56e6:	36 96       	adiw	r30, 0x06	; 6
    56e8:	0f b6       	in	r0, 0x3f	; 63
    56ea:	f8 94       	cli
    56ec:	fe bf       	out	0x3e, r31	; 62
    56ee:	0f be       	out	0x3f, r0	; 63
    56f0:	ed bf       	out	0x3d, r30	; 61
    56f2:	82 ee       	ldi	r24, 0xE2	; 226
    56f4:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    56f8:	00 d0       	rcall	.+0      	; 0x56fa <nicRegDump+0xf0>
    56fa:	00 d0       	rcall	.+0      	; 0x56fc <nicRegDump+0xf2>
    56fc:	00 d0       	rcall	.+0      	; 0x56fe <nicRegDump+0xf4>
    56fe:	ed b7       	in	r30, 0x3d	; 61
    5700:	fe b7       	in	r31, 0x3e	; 62
    5702:	31 96       	adiw	r30, 0x01	; 1
    5704:	ad b7       	in	r26, 0x3d	; 61
    5706:	be b7       	in	r27, 0x3e	; 62
    5708:	12 96       	adiw	r26, 0x02	; 2
    570a:	1c 93       	st	X, r17
    570c:	0e 93       	st	-X, r16
    570e:	11 97       	sbiw	r26, 0x01	; 1
    5710:	24 e0       	ldi	r18, 0x04	; 4
    5712:	3c e0       	ldi	r19, 0x0C	; 12
    5714:	33 83       	std	Z+3, r19	; 0x03
    5716:	22 83       	std	Z+2, r18	; 0x02
    5718:	84 83       	std	Z+4, r24	; 0x04
    571a:	15 82       	std	Z+5, r1	; 0x05
    571c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5720:	ed b7       	in	r30, 0x3d	; 61
    5722:	fe b7       	in	r31, 0x3e	; 62
    5724:	36 96       	adiw	r30, 0x06	; 6
    5726:	0f b6       	in	r0, 0x3f	; 63
    5728:	f8 94       	cli
    572a:	fe bf       	out	0x3e, r31	; 62
    572c:	0f be       	out	0x3f, r0	; 63
    572e:	ed bf       	out	0x3d, r30	; 61
    5730:	85 ee       	ldi	r24, 0xE5	; 229
    5732:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    5736:	00 d0       	rcall	.+0      	; 0x5738 <nicRegDump+0x12e>
    5738:	00 d0       	rcall	.+0      	; 0x573a <nicRegDump+0x130>
    573a:	00 d0       	rcall	.+0      	; 0x573c <nicRegDump+0x132>
    573c:	ed b7       	in	r30, 0x3d	; 61
    573e:	fe b7       	in	r31, 0x3e	; 62
    5740:	31 96       	adiw	r30, 0x01	; 1
    5742:	ad b7       	in	r26, 0x3d	; 61
    5744:	be b7       	in	r27, 0x3e	; 62
    5746:	12 96       	adiw	r26, 0x02	; 2
    5748:	1c 93       	st	X, r17
    574a:	0e 93       	st	-X, r16
    574c:	11 97       	sbiw	r26, 0x01	; 1
    574e:	25 ef       	ldi	r18, 0xF5	; 245
    5750:	3b e0       	ldi	r19, 0x0B	; 11
    5752:	33 83       	std	Z+3, r19	; 0x03
    5754:	22 83       	std	Z+2, r18	; 0x02
    5756:	84 83       	std	Z+4, r24	; 0x04
    5758:	15 82       	std	Z+5, r1	; 0x05
    575a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    575e:	ed b7       	in	r30, 0x3d	; 61
    5760:	fe b7       	in	r31, 0x3e	; 62
    5762:	36 96       	adiw	r30, 0x06	; 6
    5764:	0f b6       	in	r0, 0x3f	; 63
    5766:	f8 94       	cli
    5768:	fe bf       	out	0x3e, r31	; 62
    576a:	0f be       	out	0x3f, r0	; 63
    576c:	ed bf       	out	0x3d, r30	; 61
    576e:	84 ee       	ldi	r24, 0xE4	; 228
    5770:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    5774:	00 d0       	rcall	.+0      	; 0x5776 <nicRegDump+0x16c>
    5776:	00 d0       	rcall	.+0      	; 0x5778 <nicRegDump+0x16e>
    5778:	00 d0       	rcall	.+0      	; 0x577a <nicRegDump+0x170>
    577a:	ed b7       	in	r30, 0x3d	; 61
    577c:	fe b7       	in	r31, 0x3e	; 62
    577e:	31 96       	adiw	r30, 0x01	; 1
    5780:	ad b7       	in	r26, 0x3d	; 61
    5782:	be b7       	in	r27, 0x3e	; 62
    5784:	12 96       	adiw	r26, 0x02	; 2
    5786:	1c 93       	st	X, r17
    5788:	0e 93       	st	-X, r16
    578a:	11 97       	sbiw	r26, 0x01	; 1
    578c:	26 ee       	ldi	r18, 0xE6	; 230
    578e:	3b e0       	ldi	r19, 0x0B	; 11
    5790:	33 83       	std	Z+3, r19	; 0x03
    5792:	22 83       	std	Z+2, r18	; 0x02
    5794:	84 83       	std	Z+4, r24	; 0x04
    5796:	15 82       	std	Z+5, r1	; 0x05
    5798:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    579c:	ed b7       	in	r30, 0x3d	; 61
    579e:	fe b7       	in	r31, 0x3e	; 62
    57a0:	36 96       	adiw	r30, 0x06	; 6
    57a2:	0f b6       	in	r0, 0x3f	; 63
    57a4:	f8 94       	cli
    57a6:	fe bf       	out	0x3e, r31	; 62
    57a8:	0f be       	out	0x3f, r0	; 63
    57aa:	ed bf       	out	0x3d, r30	; 61
    57ac:	1f 91       	pop	r17
    57ae:	0f 91       	pop	r16
    57b0:	08 95       	ret

000057b2 <nicGetMacAddress>:
    57b2:	0f 93       	push	r16
    57b4:	1f 93       	push	r17
    57b6:	8c 01       	movw	r16, r24
    57b8:	81 ee       	ldi	r24, 0xE1	; 225
    57ba:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    57be:	f8 01       	movw	r30, r16
    57c0:	85 83       	std	Z+5, r24	; 0x05
    57c2:	80 ee       	ldi	r24, 0xE0	; 224
    57c4:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    57c8:	f8 01       	movw	r30, r16
    57ca:	84 83       	std	Z+4, r24	; 0x04
    57cc:	83 ee       	ldi	r24, 0xE3	; 227
    57ce:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    57d2:	f8 01       	movw	r30, r16
    57d4:	83 83       	std	Z+3, r24	; 0x03
    57d6:	82 ee       	ldi	r24, 0xE2	; 226
    57d8:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    57dc:	f8 01       	movw	r30, r16
    57de:	82 83       	std	Z+2, r24	; 0x02
    57e0:	85 ee       	ldi	r24, 0xE5	; 229
    57e2:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    57e6:	f8 01       	movw	r30, r16
    57e8:	81 83       	std	Z+1, r24	; 0x01
    57ea:	84 ee       	ldi	r24, 0xE4	; 228
    57ec:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    57f0:	f8 01       	movw	r30, r16
    57f2:	80 83       	st	Z, r24
    57f4:	1f 91       	pop	r17
    57f6:	0f 91       	pop	r16
    57f8:	08 95       	ret

000057fa <enc28j60hasRxPkt>:
}

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
  if( enc28j60Read(EPKTCNT) ==0 )
    57fa:	89 e3       	ldi	r24, 0x39	; 57
    57fc:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    5800:	81 11       	cpse	r24, r1
    5802:	81 e0       	ldi	r24, 0x01	; 1
  {
    return(0);
  }
  return(1);
}
    5804:	08 95       	ret

00005806 <enc28j60getrev>:
}

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
  return(enc28j60Read(EREVID));
    5806:	82 e7       	ldi	r24, 0x72	; 114
    5808:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
}
    580c:	08 95       	ret

0000580e <nicPoll>:
    580e:	cf 92       	push	r12
    5810:	df 92       	push	r13
    5812:	ef 92       	push	r14
    5814:	ff 92       	push	r15
    5816:	0f 93       	push	r16
    5818:	1f 93       	push	r17
    581a:	cf 93       	push	r28
    581c:	df 93       	push	r29
    581e:	89 e3       	ldi	r24, 0x39	; 57
    5820:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    5824:	88 23       	and	r24, r24
    5826:	19 f4       	brne	.+6      	; 0x582e <nicPoll+0x20>
    5828:	ee 24       	eor	r14, r14
    582a:	ff 24       	eor	r15, r15
    582c:	9d c0       	rjmp	.+314    	; 0x5968 <nicPoll+0x15a>
    582e:	80 e0       	ldi	r24, 0x00	; 0
    5830:	60 91 91 01 	lds	r22, 0x0191
    5834:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5838:	60 91 92 01 	lds	r22, 0x0192
    583c:	81 e0       	ldi	r24, 0x01	; 1
    583e:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5842:	8a e3       	ldi	r24, 0x3A	; 58
    5844:	60 e0       	ldi	r22, 0x00	; 0
    5846:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
    584a:	08 2f       	mov	r16, r24
    584c:	10 e0       	ldi	r17, 0x00	; 0
    584e:	10 93 92 01 	sts	0x0192, r17
    5852:	00 93 91 01 	sts	0x0191, r16
    5856:	8a e3       	ldi	r24, 0x3A	; 58
    5858:	60 e0       	ldi	r22, 0x00	; 0
    585a:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
    585e:	38 2f       	mov	r19, r24
    5860:	20 e0       	ldi	r18, 0x00	; 0
    5862:	20 2b       	or	r18, r16
    5864:	31 2b       	or	r19, r17
    5866:	30 93 92 01 	sts	0x0192, r19
    586a:	20 93 91 01 	sts	0x0191, r18
    586e:	8a e3       	ldi	r24, 0x3A	; 58
    5870:	60 e0       	ldi	r22, 0x00	; 0
    5872:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
    5876:	f8 2e       	mov	r15, r24
    5878:	8a e3       	ldi	r24, 0x3A	; 58
    587a:	60 e0       	ldi	r22, 0x00	; 0
    587c:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
    5880:	d8 2e       	mov	r13, r24
    5882:	8a e3       	ldi	r24, 0x3A	; 58
    5884:	60 e0       	ldi	r22, 0x00	; 0
    5886:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
    588a:	08 2f       	mov	r16, r24
    588c:	10 e0       	ldi	r17, 0x00	; 0
    588e:	8a e3       	ldi	r24, 0x3A	; 58
    5890:	60 e0       	ldi	r22, 0x00	; 0
    5892:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
    5896:	40 91 7e 0e 	lds	r20, 0x0E7E
    589a:	50 91 7f 0e 	lds	r21, 0x0E7F
    589e:	38 2f       	mov	r19, r24
    58a0:	20 e0       	ldi	r18, 0x00	; 0
    58a2:	20 2b       	or	r18, r16
    58a4:	31 2b       	or	r19, r17
    58a6:	27 fd       	sbrc	r18, 7
    58a8:	03 c0       	rjmp	.+6      	; 0x58b0 <nicPoll+0xa2>
    58aa:	ee 24       	eor	r14, r14
    58ac:	ff 24       	eor	r15, r15
    58ae:	2f c0       	rjmp	.+94     	; 0x590e <nicPoll+0x100>
    58b0:	ef 2c       	mov	r14, r15
    58b2:	ff 24       	eor	r15, r15
    58b4:	9d 2d       	mov	r25, r13
    58b6:	80 e0       	ldi	r24, 0x00	; 0
    58b8:	e8 2a       	or	r14, r24
    58ba:	f9 2a       	or	r15, r25
    58bc:	ca 01       	movw	r24, r20
    58be:	01 97       	sbiw	r24, 0x01	; 1
    58c0:	2c ef       	ldi	r18, 0xFC	; 252
    58c2:	3f ef       	ldi	r19, 0xFF	; 255
    58c4:	e2 0e       	add	r14, r18
    58c6:	f3 1e       	adc	r15, r19
    58c8:	8e 15       	cp	r24, r14
    58ca:	9f 05       	cpc	r25, r15
    58cc:	08 f4       	brcc	.+2      	; 0x58d0 <nicPoll+0xc2>
    58ce:	7c 01       	movw	r14, r24
    58d0:	00 91 86 0e 	lds	r16, 0x0E86
    58d4:	10 91 87 0e 	lds	r17, 0x0E87
    58d8:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
    58dc:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <spiEnableEnc28j60>
    58e0:	8a e3       	ldi	r24, 0x3A	; 58
    58e2:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    58e6:	68 01       	movw	r12, r16
    58e8:	e7 01       	movw	r28, r14
    58ea:	07 c0       	rjmp	.+14     	; 0x58fa <nicPoll+0xec>
    58ec:	21 97       	sbiw	r28, 0x01	; 1
    58ee:	80 e0       	ldi	r24, 0x00	; 0
    58f0:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    58f4:	f6 01       	movw	r30, r12
    58f6:	81 93       	st	Z+, r24
    58f8:	6f 01       	movw	r12, r30
    58fa:	20 97       	sbiw	r28, 0x00	; 0
    58fc:	b9 f7       	brne	.-18     	; 0x58ec <nicPoll+0xde>
    58fe:	0e 0d       	add	r16, r14
    5900:	1f 1d       	adc	r17, r15
    5902:	f8 01       	movw	r30, r16
    5904:	10 82       	st	Z, r1
    5906:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <spiDisableEnc28j60>
    590a:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
    590e:	8c e0       	ldi	r24, 0x0C	; 12
    5910:	60 91 91 01 	lds	r22, 0x0191
    5914:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5918:	60 91 92 01 	lds	r22, 0x0192
    591c:	8d e0       	ldi	r24, 0x0D	; 13
    591e:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5922:	60 91 91 01 	lds	r22, 0x0191
    5926:	70 91 92 01 	lds	r23, 0x0192
    592a:	cb 01       	movw	r24, r22
    592c:	01 97       	sbiw	r24, 0x01	; 1
    592e:	8f 5f       	subi	r24, 0xFF	; 255
    5930:	99 41       	sbci	r25, 0x19	; 25
    5932:	38 f0       	brcs	.+14     	; 0x5942 <nicPoll+0x134>
    5934:	8c e0       	ldi	r24, 0x0C	; 12
    5936:	6e ef       	ldi	r22, 0xFE	; 254
    5938:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    593c:	8d e0       	ldi	r24, 0x0D	; 13
    593e:	69 e1       	ldi	r22, 0x19	; 25
    5940:	0c c0       	rjmp	.+24     	; 0x595a <nicPoll+0x14c>
    5942:	61 50       	subi	r22, 0x01	; 1
    5944:	8c e0       	ldi	r24, 0x0C	; 12
    5946:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    594a:	20 91 91 01 	lds	r18, 0x0191
    594e:	30 91 92 01 	lds	r19, 0x0192
    5952:	21 50       	subi	r18, 0x01	; 1
    5954:	30 40       	sbci	r19, 0x00	; 0
    5956:	8d e0       	ldi	r24, 0x0D	; 13
    5958:	63 2f       	mov	r22, r19
    595a:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    595e:	80 e8       	ldi	r24, 0x80	; 128
    5960:	6e e1       	ldi	r22, 0x1E	; 30
    5962:	40 e4       	ldi	r20, 0x40	; 64
    5964:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    5968:	c7 01       	movw	r24, r14
    596a:	df 91       	pop	r29
    596c:	cf 91       	pop	r28
    596e:	1f 91       	pop	r17
    5970:	0f 91       	pop	r16
    5972:	ff 90       	pop	r15
    5974:	ef 90       	pop	r14
    5976:	df 90       	pop	r13
    5978:	cf 90       	pop	r12
    597a:	08 95       	ret

0000597c <nicSend>:
    597c:	0f 93       	push	r16
    597e:	1f 93       	push	r17
    5980:	cf 93       	push	r28
    5982:	df 93       	push	r29
    5984:	8c 01       	movw	r16, r24
    5986:	13 c0       	rjmp	.+38     	; 0x59ae <nicSend+0x32>
    5988:	8c e1       	ldi	r24, 0x1C	; 28
    598a:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    598e:	81 ff       	sbrs	r24, 1
    5990:	0a c0       	rjmp	.+20     	; 0x59a6 <nicSend+0x2a>
    5992:	80 e8       	ldi	r24, 0x80	; 128
    5994:	6f e1       	ldi	r22, 0x1F	; 31
    5996:	40 e8       	ldi	r20, 0x80	; 128
    5998:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    599c:	80 ea       	ldi	r24, 0xA0	; 160
    599e:	6f e1       	ldi	r22, 0x1F	; 31
    59a0:	40 e8       	ldi	r20, 0x80	; 128
    59a2:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    59a6:	80 e0       	ldi	r24, 0x00	; 0
    59a8:	90 e0       	ldi	r25, 0x00	; 0
    59aa:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    59ae:	80 e0       	ldi	r24, 0x00	; 0
    59b0:	6f e1       	ldi	r22, 0x1F	; 31
    59b2:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <enc28j60ReadOp>
    59b6:	83 fd       	sbrc	r24, 3
    59b8:	e7 cf       	rjmp	.-50     	; 0x5988 <nicSend+0xc>
    59ba:	82 e0       	ldi	r24, 0x02	; 2
    59bc:	6f ef       	ldi	r22, 0xFF	; 255
    59be:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    59c2:	83 e0       	ldi	r24, 0x03	; 3
    59c4:	69 e1       	ldi	r22, 0x19	; 25
    59c6:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    59ca:	60 2f       	mov	r22, r16
    59cc:	61 50       	subi	r22, 0x01	; 1
    59ce:	86 e0       	ldi	r24, 0x06	; 6
    59d0:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    59d4:	98 01       	movw	r18, r16
    59d6:	21 50       	subi	r18, 0x01	; 1
    59d8:	36 4e       	sbci	r19, 0xE6	; 230
    59da:	87 e0       	ldi	r24, 0x07	; 7
    59dc:	63 2f       	mov	r22, r19
    59de:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    59e2:	8a e7       	ldi	r24, 0x7A	; 122
    59e4:	60 e0       	ldi	r22, 0x00	; 0
    59e6:	40 e0       	ldi	r20, 0x00	; 0
    59e8:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    59ec:	c0 91 86 0e 	lds	r28, 0x0E86
    59f0:	d0 91 87 0e 	lds	r29, 0x0E87
    59f4:	0e 94 a6 1c 	call	0x394c	; 0x394c <spiTake>
    59f8:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <spiEnableEnc28j60>
    59fc:	8a e7       	ldi	r24, 0x7A	; 122
    59fe:	03 c0       	rjmp	.+6      	; 0x5a06 <nicSend+0x8a>
    5a00:	01 50       	subi	r16, 0x01	; 1
    5a02:	10 40       	sbci	r17, 0x00	; 0
    5a04:	89 91       	ld	r24, Y+
    5a06:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <spiSend>
    5a0a:	01 15       	cp	r16, r1
    5a0c:	11 05       	cpc	r17, r1
    5a0e:	c1 f7       	brne	.-16     	; 0x5a00 <nicSend+0x84>
    5a10:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <spiDisableEnc28j60>
    5a14:	0e 94 9a 1c 	call	0x3934	; 0x3934 <spiGive>
    5a18:	80 e8       	ldi	r24, 0x80	; 128
    5a1a:	6f e1       	ldi	r22, 0x1F	; 31
    5a1c:	48 e0       	ldi	r20, 0x08	; 8
    5a1e:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    5a22:	df 91       	pop	r29
    5a24:	cf 91       	pop	r28
    5a26:	1f 91       	pop	r17
    5a28:	0f 91       	pop	r16
    5a2a:	08 95       	ret

00005a2c <enc28j60linkup>:

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
  // Set the right address and start the register read operation
  enc28j60Write(MIREGADR, address);
    5a2c:	84 ed       	ldi	r24, 0xD4	; 212
    5a2e:	61 e1       	ldi	r22, 0x11	; 17
    5a30:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
  enc28j60Write(MICMD, MICMD_MIIRD);
    5a34:	82 ed       	ldi	r24, 0xD2	; 210
    5a36:	61 e0       	ldi	r22, 0x01	; 1
    5a38:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie
    5a3c:	80 e0       	ldi	r24, 0x00	; 0
    5a3e:	90 e0       	ldi	r25, 0x00	; 0
    5a40:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
  enc28j60Write(MICMD, MICMD_MIIRD);
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    5a44:	8a ee       	ldi	r24, 0xEA	; 234
    5a46:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    5a4a:	80 fd       	sbrc	r24, 0
    5a4c:	f7 cf       	rjmp	.-18     	; 0x5a3c <enc28j60linkup+0x10>
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie

  // reset reading bit
  enc28j60Write(MICMD, 0x00);
    5a4e:	82 ed       	ldi	r24, 0xD2	; 210
    5a50:	60 e0       	ldi	r22, 0x00	; 0
    5a52:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>

  return (enc28j60Read(MIRDH));
    5a56:	89 ed       	ldi	r24, 0xD9	; 217
    5a58:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    5a5c:	81 11       	cpse	r24, r1
    5a5e:	81 e0       	ldi	r24, 0x01	; 1
// link status
uint8_t enc28j60linkup(void)
{
  // bit 10 (= bit 3 in upper reg)
  return(enc28j60PhyReadH(PHSTAT2) && 4);
}
    5a60:	08 95       	ret

00005a62 <enc28j60PhyWrite>:
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    5a62:	0f 93       	push	r16
    5a64:	1f 93       	push	r17
    5a66:	98 2f       	mov	r25, r24
    5a68:	16 2f       	mov	r17, r22
    5a6a:	07 2f       	mov	r16, r23
  // set the PHY register address
  enc28j60Write(MIREGADR, address);
    5a6c:	84 ed       	ldi	r24, 0xD4	; 212
    5a6e:	69 2f       	mov	r22, r25
    5a70:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
  // write the PHY data
  enc28j60Write(MIWRL, data);
    5a74:	86 ed       	ldi	r24, 0xD6	; 214
    5a76:	61 2f       	mov	r22, r17
    5a78:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
  enc28j60Write(MIWRH, data>>8);
    5a7c:	87 ed       	ldi	r24, 0xD7	; 215
    5a7e:	60 2f       	mov	r22, r16
    5a80:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5a84:	04 c0       	rjmp	.+8      	; 0x5a8e <enc28j60PhyWrite+0x2c>
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
    5a86:	80 e0       	ldi	r24, 0x00	; 0
    5a88:	90 e0       	ldi	r25, 0x00	; 0
    5a8a:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
  // write the PHY data
  enc28j60Write(MIWRL, data);
  enc28j60Write(MIWRH, data>>8);
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    5a8e:	8a ee       	ldi	r24, 0xEA	; 234
    5a90:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <enc28j60Read>
    5a94:	80 fd       	sbrc	r24, 0
    5a96:	f7 cf       	rjmp	.-18     	; 0x5a86 <enc28j60PhyWrite+0x24>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
  }
}
    5a98:	1f 91       	pop	r17
    5a9a:	0f 91       	pop	r16
    5a9c:	08 95       	ret

00005a9e <nicMacInit>:
    5a9e:	85 e0       	ldi	r24, 0x05	; 5
    5aa0:	90 e0       	ldi	r25, 0x00	; 0
    5aa2:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    5aa6:	1a 98       	cbi	0x03, 2	; 3
    5aa8:	85 e0       	ldi	r24, 0x05	; 5
    5aaa:	90 e0       	ldi	r25, 0x00	; 0
    5aac:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    5ab0:	1a 9a       	sbi	0x03, 2	; 3
    5ab2:	85 e0       	ldi	r24, 0x05	; 5
    5ab4:	90 e0       	ldi	r25, 0x00	; 0
    5ab6:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    5aba:	10 92 92 01 	sts	0x0192, r1
    5abe:	10 92 91 01 	sts	0x0191, r1
    5ac2:	88 e0       	ldi	r24, 0x08	; 8
    5ac4:	60 e0       	ldi	r22, 0x00	; 0
    5ac6:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5aca:	89 e0       	ldi	r24, 0x09	; 9
    5acc:	60 e0       	ldi	r22, 0x00	; 0
    5ace:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5ad2:	8c e0       	ldi	r24, 0x0C	; 12
    5ad4:	60 e0       	ldi	r22, 0x00	; 0
    5ad6:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5ada:	8d e0       	ldi	r24, 0x0D	; 13
    5adc:	60 e0       	ldi	r22, 0x00	; 0
    5ade:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5ae2:	8a e0       	ldi	r24, 0x0A	; 10
    5ae4:	6e ef       	ldi	r22, 0xFE	; 254
    5ae6:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5aea:	8b e0       	ldi	r24, 0x0B	; 11
    5aec:	69 e1       	ldi	r22, 0x19	; 25
    5aee:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5af2:	84 e0       	ldi	r24, 0x04	; 4
    5af4:	6f ef       	ldi	r22, 0xFF	; 255
    5af6:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5afa:	85 e0       	ldi	r24, 0x05	; 5
    5afc:	69 e1       	ldi	r22, 0x19	; 25
    5afe:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b02:	86 e0       	ldi	r24, 0x06	; 6
    5b04:	6f ef       	ldi	r22, 0xFF	; 255
    5b06:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b0a:	87 e0       	ldi	r24, 0x07	; 7
    5b0c:	6f e1       	ldi	r22, 0x1F	; 31
    5b0e:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b12:	88 e3       	ldi	r24, 0x38	; 56
    5b14:	62 eb       	ldi	r22, 0xB2	; 178
    5b16:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b1a:	88 e2       	ldi	r24, 0x28	; 40
    5b1c:	6f e3       	ldi	r22, 0x3F	; 63
    5b1e:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b22:	89 e2       	ldi	r24, 0x29	; 41
    5b24:	60 e3       	ldi	r22, 0x30	; 48
    5b26:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b2a:	80 e3       	ldi	r24, 0x30	; 48
    5b2c:	69 ef       	ldi	r22, 0xF9	; 249
    5b2e:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b32:	81 e3       	ldi	r24, 0x31	; 49
    5b34:	67 ef       	ldi	r22, 0xF7	; 247
    5b36:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b3a:	80 ec       	ldi	r24, 0xC0	; 192
    5b3c:	6d e0       	ldi	r22, 0x0D	; 13
    5b3e:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b42:	81 ec       	ldi	r24, 0xC1	; 193
    5b44:	60 e0       	ldi	r22, 0x00	; 0
    5b46:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b4a:	80 e8       	ldi	r24, 0x80	; 128
    5b4c:	62 ec       	ldi	r22, 0xC2	; 194
    5b4e:	42 e3       	ldi	r20, 0x32	; 50
    5b50:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    5b54:	86 ec       	ldi	r24, 0xC6	; 198
    5b56:	62 e1       	ldi	r22, 0x12	; 18
    5b58:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b5c:	87 ec       	ldi	r24, 0xC7	; 199
    5b5e:	6c e0       	ldi	r22, 0x0C	; 12
    5b60:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b64:	84 ec       	ldi	r24, 0xC4	; 196
    5b66:	62 e1       	ldi	r22, 0x12	; 18
    5b68:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b6c:	8a ec       	ldi	r24, 0xCA	; 202
    5b6e:	6c ed       	ldi	r22, 0xDC	; 220
    5b70:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b74:	8b ec       	ldi	r24, 0xCB	; 203
    5b76:	65 e0       	ldi	r22, 0x05	; 5
    5b78:	0e 94 aa 2a 	call	0x5554	; 0x5554 <enc28j60Write>
    5b7c:	80 e8       	ldi	r24, 0x80	; 128
    5b7e:	9e e0       	ldi	r25, 0x0E	; 14
    5b80:	0e 94 b8 2a 	call	0x5570	; 0x5570 <nicSetMacAddress>
    5b84:	80 e1       	ldi	r24, 0x10	; 16
    5b86:	60 e0       	ldi	r22, 0x00	; 0
    5b88:	71 e0       	ldi	r23, 0x01	; 1
    5b8a:	0e 94 31 2d 	call	0x5a62	; 0x5a62 <enc28j60PhyWrite>
    5b8e:	8f e1       	ldi	r24, 0x1F	; 31
    5b90:	0e 94 86 2a 	call	0x550c	; 0x550c <enc28j60SetBank>
    5b94:	80 e8       	ldi	r24, 0x80	; 128
    5b96:	6b e1       	ldi	r22, 0x1B	; 27
    5b98:	40 ec       	ldi	r20, 0xC0	; 192
    5b9a:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    5b9e:	80 e8       	ldi	r24, 0x80	; 128
    5ba0:	6f e1       	ldi	r22, 0x1F	; 31
    5ba2:	44 e0       	ldi	r20, 0x04	; 4
    5ba4:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <enc28j60WriteOp>
    5ba8:	85 e0       	ldi	r24, 0x05	; 5
    5baa:	90 e0       	ldi	r25, 0x00	; 0
    5bac:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    5bb0:	84 e1       	ldi	r24, 0x14	; 20
    5bb2:	66 e7       	ldi	r22, 0x76	; 118
    5bb4:	74 e0       	ldi	r23, 0x04	; 4
    5bb6:	0e 94 31 2d 	call	0x5a62	; 0x5a62 <enc28j60PhyWrite>
    5bba:	82 e0       	ldi	r24, 0x02	; 2
    5bbc:	90 e0       	ldi	r25, 0x00	; 0
    5bbe:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    5bc2:	08 95       	ret

00005bc4 <initQueueStream>:

static int streamQueueOutputFun(char c, FILE *ostream);
static int streamQueueInputFun(FILE *istream);

void initQueueStream(FILE *stream, streamBuffers_t *buffer, xQueueHandle Rx, xQueueHandle Tx)
{
    5bc4:	fc 01       	movw	r30, r24
    5bc6:	db 01       	movw	r26, r22
  fdev_setup_stream(stream, streamQueueOutputFun, streamQueueInputFun, _FDEV_SETUP_RW);
    5bc8:	85 e1       	ldi	r24, 0x15	; 21
    5bca:	9e e2       	ldi	r25, 0x2E	; 46
    5bcc:	91 87       	std	Z+9, r25	; 0x09
    5bce:	80 87       	std	Z+8, r24	; 0x08
    5bd0:	88 ef       	ldi	r24, 0xF8	; 248
    5bd2:	9d e2       	ldi	r25, 0x2D	; 45
    5bd4:	93 87       	std	Z+11, r25	; 0x0b
    5bd6:	82 87       	std	Z+10, r24	; 0x0a
    5bd8:	83 e0       	ldi	r24, 0x03	; 3
    5bda:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, (void *)buffer);
    5bdc:	75 87       	std	Z+13, r23	; 0x0d
    5bde:	64 87       	std	Z+12, r22	; 0x0c
  buffer->Rx = Rx;
    5be0:	11 96       	adiw	r26, 0x01	; 1
    5be2:	5c 93       	st	X, r21
    5be4:	4e 93       	st	-X, r20
  buffer->Tx = Tx;
    5be6:	13 96       	adiw	r26, 0x03	; 3
    5be8:	3c 93       	st	X, r19
    5bea:	2e 93       	st	-X, r18
    5bec:	12 97       	sbiw	r26, 0x02	; 2
  return;
}
    5bee:	08 95       	ret

00005bf0 <streamQueueInputFun>:
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
  return 0;
}

static int streamQueueInputFun(FILE *istream)
{
    5bf0:	df 93       	push	r29
    5bf2:	cf 93       	push	r28
    5bf4:	0f 92       	push	r0
    5bf6:	cd b7       	in	r28, 0x3d	; 61
    5bf8:	de b7       	in	r29, 0x3e	; 62
  char c;
  streamBuffers_t *strBuf = (streamBuffers_t *) istream->udata;
  xQueueReceive(strBuf->Rx, &c, portMAX_DELAY);
    5bfa:	dc 01       	movw	r26, r24
    5bfc:	1c 96       	adiw	r26, 0x0c	; 12
    5bfe:	ed 91       	ld	r30, X+
    5c00:	fc 91       	ld	r31, X
    5c02:	1d 97       	sbiw	r26, 0x0d	; 13
    5c04:	80 81       	ld	r24, Z
    5c06:	91 81       	ldd	r25, Z+1	; 0x01
    5c08:	be 01       	movw	r22, r28
    5c0a:	6f 5f       	subi	r22, 0xFF	; 255
    5c0c:	7f 4f       	sbci	r23, 0xFF	; 255
    5c0e:	4f ef       	ldi	r20, 0xFF	; 255
    5c10:	5f ef       	ldi	r21, 0xFF	; 255
    5c12:	20 e0       	ldi	r18, 0x00	; 0
    5c14:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    5c18:	29 81       	ldd	r18, Y+1	; 0x01
    5c1a:	33 27       	eor	r19, r19
    5c1c:	27 fd       	sbrc	r18, 7
    5c1e:	30 95       	com	r19
  return c;
}
    5c20:	c9 01       	movw	r24, r18
    5c22:	0f 90       	pop	r0
    5c24:	cf 91       	pop	r28
    5c26:	df 91       	pop	r29
    5c28:	08 95       	ret

00005c2a <streamQueueOutputFun>:
  buffer->Tx = Tx;
  return;
}

static int streamQueueOutputFun(char c, FILE *ostream)
{
    5c2a:	df 93       	push	r29
    5c2c:	cf 93       	push	r28
    5c2e:	0f 92       	push	r0
    5c30:	cd b7       	in	r28, 0x3d	; 61
    5c32:	de b7       	in	r29, 0x3e	; 62
    5c34:	89 83       	std	Y+1, r24	; 0x01
    5c36:	fb 01       	movw	r30, r22
/*  if (xQueueSend( strBuf->Tx, &c, strBuf->tx_timeout))
  {
    return EOF;
  }
  else*/
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
    5c38:	04 84       	ldd	r0, Z+12	; 0x0c
    5c3a:	f5 85       	ldd	r31, Z+13	; 0x0d
    5c3c:	e0 2d       	mov	r30, r0
    5c3e:	82 81       	ldd	r24, Z+2	; 0x02
    5c40:	93 81       	ldd	r25, Z+3	; 0x03
    5c42:	be 01       	movw	r22, r28
    5c44:	6f 5f       	subi	r22, 0xFF	; 255
    5c46:	7f 4f       	sbci	r23, 0xFF	; 255
    5c48:	4f ef       	ldi	r20, 0xFF	; 255
    5c4a:	5f ef       	ldi	r21, 0xFF	; 255
    5c4c:	20 e0       	ldi	r18, 0x00	; 0
    5c4e:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>
  return 0;
}
    5c52:	80 e0       	ldi	r24, 0x00	; 0
    5c54:	90 e0       	ldi	r25, 0x00	; 0
    5c56:	0f 90       	pop	r0
    5c58:	cf 91       	pop	r28
    5c5a:	df 91       	pop	r29
    5c5c:	08 95       	ret
    5c5e:	08 95       	ret
    5c60:	08 95       	ret
    5c62:	80 e0       	ldi	r24, 0x00	; 0
    5c64:	90 e0       	ldi	r25, 0x00	; 0
    5c66:	08 95       	ret
    5c68:	00 d0       	rcall	.+0      	; 0x5c6a <streamQueueOutputFun+0x40>
    5c6a:	00 d0       	rcall	.+0      	; 0x5c6c <streamQueueOutputFun+0x42>
    5c6c:	ed b7       	in	r30, 0x3d	; 61
    5c6e:	fe b7       	in	r31, 0x3e	; 62
    5c70:	92 83       	std	Z+2, r25	; 0x02
    5c72:	81 83       	std	Z+1, r24	; 0x01
    5c74:	8b e5       	ldi	r24, 0x5B	; 91
    5c76:	9c e0       	ldi	r25, 0x0C	; 12
    5c78:	94 83       	std	Z+4, r25	; 0x04
    5c7a:	83 83       	std	Z+3, r24	; 0x03
    5c7c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5c80:	0f 90       	pop	r0
    5c82:	0f 90       	pop	r0
    5c84:	0f 90       	pop	r0
    5c86:	0f 90       	pop	r0
    5c88:	08 95       	ret
    5c8a:	bc 01       	movw	r22, r24
    5c8c:	80 e8       	ldi	r24, 0x80	; 128
    5c8e:	9e e0       	ldi	r25, 0x0E	; 14
    5c90:	46 e0       	ldi	r20, 0x06	; 6
    5c92:	50 e0       	ldi	r21, 0x00	; 0
    5c94:	0e 94 86 5c 	call	0xb90c	; 0xb90c <strncpy>
    5c98:	0e 94 4f 2d 	call	0x5a9e	; 0x5a9e <nicMacInit>
    5c9c:	08 95       	ret
    5c9e:	60 e8       	ldi	r22, 0x80	; 128
    5ca0:	7e e0       	ldi	r23, 0x0E	; 14
    5ca2:	46 e0       	ldi	r20, 0x06	; 6
    5ca4:	50 e0       	ldi	r21, 0x00	; 0
    5ca6:	0e 94 86 5c 	call	0xb90c	; 0xb90c <strncpy>
    5caa:	08 95       	ret

00005cac <nicInit>:
unsigned int nicPoll(void)                                       { return 0; }


static void nicBufferInit(void)
{
  nicState.bufferSize  = NETWORK_STACK_BUF_SIZE;
    5cac:	20 e0       	ldi	r18, 0x00	; 0
    5cae:	36 e0       	ldi	r19, 0x06	; 6
    5cb0:	30 93 7f 0e 	sts	0x0E7F, r19
    5cb4:	20 93 7e 0e 	sts	0x0E7E, r18
  nicState.layer2.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR);
    5cb8:	e0 e0       	ldi	r30, 0x00	; 0
    5cba:	fa e7       	ldi	r31, 0x7A	; 122
    5cbc:	f0 93 87 0e 	sts	0x0E87, r31
    5cc0:	e0 93 86 0e 	sts	0x0E86, r30
  nicState.layer3.ip   = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  nicState.layer4.icmp = (struct  netIcmpHeader *)(NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN + IP_HEADER_LEN);
    5cc4:	82 e2       	ldi	r24, 0x22	; 34
    5cc6:	9a e7       	ldi	r25, 0x7A	; 122
    5cc8:	90 93 8b 0e 	sts	0x0E8B, r25
    5ccc:	80 93 8a 0e 	sts	0x0E8A, r24
  #if IPV6_SUPPORT
  nicState.layer3.ipv6 = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  nicState.layer3.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
    5cd0:	8e e0       	ldi	r24, 0x0E	; 14
    5cd2:	9a e7       	ldi	r25, 0x7A	; 122
    5cd4:	90 93 89 0e 	sts	0x0E89, r25
    5cd8:	80 93 88 0e 	sts	0x0E88, r24
  //nicState.layer4.icmpv6  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  #endif /*IPV6_SUPPORT*/
  memset(nicState.layer2.buf, 0, nicState.bufferSize);
    5cdc:	df 01       	movw	r26, r30
    5cde:	c9 01       	movw	r24, r18
    5ce0:	1d 92       	st	X+, r1
    5ce2:	01 97       	sbiw	r24, 0x01	; 1
    5ce4:	e9 f7       	brne	.-6      	; 0x5ce0 <nicInit+0x34>
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
    5ce6:	80 e8       	ldi	r24, 0x80	; 128
    5ce8:	9e e0       	ldi	r25, 0x0E	; 14
    5cea:	68 e1       	ldi	r22, 0x18	; 24
    5cec:	70 e0       	ldi	r23, 0x00	; 0
    5cee:	46 e0       	ldi	r20, 0x06	; 6
    5cf0:	50 e0       	ldi	r21, 0x00	; 0
    5cf2:	0e 94 bf 5f 	call	0xbf7e	; 0xbf7e <__eerd_block_m128>
}

void nicInit()
{
  nicBufferInit();
  nicMacInit();
    5cf6:	0e 94 4f 2d 	call	0x5a9e	; 0x5a9e <nicMacInit>
}
    5cfa:	08 95       	ret

00005cfc <saveNic>:
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
}

void saveNic(void)
{
  eeprom_update_block(&nicState.mac.addr, mymac_eep, 6);
    5cfc:	80 e8       	ldi	r24, 0x80	; 128
    5cfe:	9e e0       	ldi	r25, 0x0E	; 14
    5d00:	68 e1       	ldi	r22, 0x18	; 24
    5d02:	70 e0       	ldi	r23, 0x00	; 0
    5d04:	46 e0       	ldi	r20, 0x06	; 6
    5d06:	50 e0       	ldi	r21, 0x00	; 0
    5d08:	0e 94 db 5f 	call	0xbfb6	; 0xbfb6 <__eeupd_block_m128>
}
    5d0c:	08 95       	ret

00005d0e <htons>:

#include "net.h"


uint16_t htons(uint16_t val)
{
    5d0e:	28 2f       	mov	r18, r24
  return (val<<8) | (val>>8);
}
    5d10:	89 2f       	mov	r24, r25
    5d12:	92 2f       	mov	r25, r18
    5d14:	08 95       	ret

00005d16 <htonl>:

uint32_t htonl(uint32_t val)
{
    5d16:	ef 92       	push	r14
    5d18:	ff 92       	push	r15
    5d1a:	0f 93       	push	r16
    5d1c:	1f 93       	push	r17
    5d1e:	f6 2e       	mov	r15, r22
    5d20:	e7 2e       	mov	r14, r23
    5d22:	00 e0       	ldi	r16, 0x00	; 0
    5d24:	10 e0       	ldi	r17, 0x00	; 0
    5d26:	87 01       	movw	r16, r14
    5d28:	ff 24       	eor	r15, r15
    5d2a:	ee 24       	eor	r14, r14
    5d2c:	bc 01       	movw	r22, r24
    5d2e:	88 27       	eor	r24, r24
    5d30:	99 27       	eor	r25, r25
    5d32:	36 2f       	mov	r19, r22
    5d34:	27 2f       	mov	r18, r23
    5d36:	40 e0       	ldi	r20, 0x00	; 0
    5d38:	50 e0       	ldi	r21, 0x00	; 0
    5d3a:	e2 2a       	or	r14, r18
    5d3c:	f3 2a       	or	r15, r19
    5d3e:	04 2b       	or	r16, r20
    5d40:	15 2b       	or	r17, r21
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
}
    5d42:	b7 01       	movw	r22, r14
    5d44:	c8 01       	movw	r24, r16
    5d46:	1f 91       	pop	r17
    5d48:	0f 91       	pop	r16
    5d4a:	ff 90       	pop	r15
    5d4c:	ef 90       	pop	r14
    5d4e:	08 95       	ret

00005d50 <netChecksum>:


uint16_t netChecksum(uint8_t *data, uint16_t len)
{
    5d50:	0f 93       	push	r16
    5d52:	1f 93       	push	r17
    5d54:	cf 93       	push	r28
    5d56:	df 93       	push	r29
    5d58:	8c 01       	movw	r16, r24
    5d5a:	ec 01       	movw	r28, r24
    5d5c:	fb 01       	movw	r30, r22
    5d5e:	20 e0       	ldi	r18, 0x00	; 0
    5d60:	30 e0       	ldi	r19, 0x00	; 0
    5d62:	40 e0       	ldi	r20, 0x00	; 0
    5d64:	50 e0       	ldi	r21, 0x00	; 0
  register uint32_t sum = 0;

  for (;;) 
  {
    if (len < 2)
    5d66:	e2 30       	cpi	r30, 0x02	; 2
    5d68:	f1 05       	cpc	r31, r1
    5d6a:	50 f0       	brcs	.+20     	; 0x5d80 <netChecksum+0x30>
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    5d6c:	89 91       	ld	r24, Y+
    5d6e:	99 91       	ld	r25, Y+
    5d70:	a0 e0       	ldi	r26, 0x00	; 0
    5d72:	b0 e0       	ldi	r27, 0x00	; 0
    5d74:	28 0f       	add	r18, r24
    5d76:	39 1f       	adc	r19, r25
    5d78:	4a 1f       	adc	r20, r26
    5d7a:	5b 1f       	adc	r21, r27
    data+=2;
    len -= 2;
    5d7c:	32 97       	sbiw	r30, 0x02	; 2
    5d7e:	f3 cf       	rjmp	.-26     	; 0x5d66 <netChecksum+0x16>
  }
    5d80:	fb 01       	movw	r30, r22
    5d82:	ee 7f       	andi	r30, 0xFE	; 254
    5d84:	e0 0f       	add	r30, r16
    5d86:	f1 1f       	adc	r31, r17
  if (len)
    5d88:	60 ff       	sbrs	r22, 0
    5d8a:	0b c0       	rjmp	.+22     	; 0x5da2 <netChecksum+0x52>
    sum += *(uint8_t *) data;
    5d8c:	80 81       	ld	r24, Z
    5d8e:	28 0f       	add	r18, r24
    5d90:	31 1d       	adc	r19, r1
    5d92:	41 1d       	adc	r20, r1
    5d94:	51 1d       	adc	r21, r1
    5d96:	05 c0       	rjmp	.+10     	; 0x5da2 <netChecksum+0x52>

  while ((len = (uint16_t) (sum >> 16)) != 0)
    sum = (uint16_t) sum + len;
    5d98:	62 0f       	add	r22, r18
    5d9a:	73 1f       	adc	r23, r19
    5d9c:	9b 01       	movw	r18, r22
    5d9e:	40 e0       	ldi	r20, 0x00	; 0
    5da0:	50 e0       	ldi	r21, 0x00	; 0
    len -= 2;
  }
  if (len)
    sum += *(uint8_t *) data;

  while ((len = (uint16_t) (sum >> 16)) != 0)
    5da2:	ca 01       	movw	r24, r20
    5da4:	aa 27       	eor	r26, r26
    5da6:	bb 27       	eor	r27, r27
    5da8:	bc 01       	movw	r22, r24
    5daa:	89 2b       	or	r24, r25
    5dac:	a9 f7       	brne	.-22     	; 0x5d98 <netChecksum+0x48>
    5dae:	20 95       	com	r18
    5db0:	30 95       	com	r19
    sum = (uint16_t) sum + len;

  return (uint16_t) sum ^ 0xFFFF;
}
    5db2:	c9 01       	movw	r24, r18
    5db4:	df 91       	pop	r29
    5db6:	cf 91       	pop	r28
    5db8:	1f 91       	pop	r17
    5dba:	0f 91       	pop	r16
    5dbc:	08 95       	ret

00005dbe <netPrintTcpHeader>:
  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
}

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
    5dbe:	cf 92       	push	r12
    5dc0:	df 92       	push	r13
    5dc2:	ef 92       	push	r14
    5dc4:	ff 92       	push	r15
    5dc6:	0f 93       	push	r16
    5dc8:	1f 93       	push	r17
    5dca:	cf 93       	push	r28
    5dcc:	df 93       	push	r29
    5dce:	6c 01       	movw	r12, r24
    5dd0:	eb 01       	movw	r28, r22
  fprintf_P(stream, PSTR("TCP Header\r\n"));
    5dd2:	00 d0       	rcall	.+0      	; 0x5dd4 <netPrintTcpHeader+0x16>
    5dd4:	00 d0       	rcall	.+0      	; 0x5dd6 <netPrintTcpHeader+0x18>
    5dd6:	ad b7       	in	r26, 0x3d	; 61
    5dd8:	be b7       	in	r27, 0x3e	; 62
    5dda:	12 96       	adiw	r26, 0x02	; 2
    5ddc:	9c 93       	st	X, r25
    5dde:	8e 93       	st	-X, r24
    5de0:	11 97       	sbiw	r26, 0x01	; 1
    5de2:	84 ee       	ldi	r24, 0xE4	; 228
    5de4:	9c e0       	ldi	r25, 0x0C	; 12
    5de6:	14 96       	adiw	r26, 0x04	; 4
    5de8:	9c 93       	st	X, r25
    5dea:	8e 93       	st	-X, r24
    5dec:	13 97       	sbiw	r26, 0x03	; 3
    5dee:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    5df2:	00 d0       	rcall	.+0      	; 0x5df4 <netPrintTcpHeader+0x36>
    5df4:	ed b7       	in	r30, 0x3d	; 61
    5df6:	fe b7       	in	r31, 0x3e	; 62
    5df8:	31 96       	adiw	r30, 0x01	; 1
    5dfa:	ad b7       	in	r26, 0x3d	; 61
    5dfc:	be b7       	in	r27, 0x3e	; 62
    5dfe:	12 96       	adiw	r26, 0x02	; 2
    5e00:	dc 92       	st	X, r13
    5e02:	ce 92       	st	-X, r12
    5e04:	11 97       	sbiw	r26, 0x01	; 1
    5e06:	85 ed       	ldi	r24, 0xD5	; 213
    5e08:	9c e0       	ldi	r25, 0x0C	; 12
    5e0a:	93 83       	std	Z+3, r25	; 0x03
    5e0c:	82 83       	std	Z+2, r24	; 0x02
    5e0e:	98 81       	ld	r25, Y
    5e10:	89 81       	ldd	r24, Y+1	; 0x01
    5e12:	84 83       	std	Z+4, r24	; 0x04
    5e14:	95 83       	std	Z+5, r25	; 0x05
    5e16:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    5e1a:	ed b7       	in	r30, 0x3d	; 61
    5e1c:	fe b7       	in	r31, 0x3e	; 62
    5e1e:	31 96       	adiw	r30, 0x01	; 1
    5e20:	ad b7       	in	r26, 0x3d	; 61
    5e22:	be b7       	in	r27, 0x3e	; 62
    5e24:	12 96       	adiw	r26, 0x02	; 2
    5e26:	dc 92       	st	X, r13
    5e28:	ce 92       	st	-X, r12
    5e2a:	11 97       	sbiw	r26, 0x01	; 1
    5e2c:	86 ec       	ldi	r24, 0xC6	; 198
    5e2e:	9c e0       	ldi	r25, 0x0C	; 12
    5e30:	93 83       	std	Z+3, r25	; 0x03
    5e32:	82 83       	std	Z+2, r24	; 0x02
    5e34:	9a 81       	ldd	r25, Y+2	; 0x02
    5e36:	8b 81       	ldd	r24, Y+3	; 0x03
    5e38:	84 83       	std	Z+4, r24	; 0x04
    5e3a:	95 83       	std	Z+5, r25	; 0x05
    5e3c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Seq Num : 0x%x"), htonl(tcpheader->seqno));
    5e40:	ec 80       	ldd	r14, Y+4	; 0x04
    5e42:	fd 80       	ldd	r15, Y+5	; 0x05
    5e44:	0e 81       	ldd	r16, Y+6	; 0x06
    5e46:	1f 81       	ldd	r17, Y+7	; 0x07
    5e48:	00 d0       	rcall	.+0      	; 0x5e4a <netPrintTcpHeader+0x8c>
    5e4a:	ed b7       	in	r30, 0x3d	; 61
    5e4c:	fe b7       	in	r31, 0x3e	; 62
    5e4e:	31 96       	adiw	r30, 0x01	; 1
    5e50:	ad b7       	in	r26, 0x3d	; 61
    5e52:	be b7       	in	r27, 0x3e	; 62
    5e54:	12 96       	adiw	r26, 0x02	; 2
    5e56:	dc 92       	st	X, r13
    5e58:	ce 92       	st	-X, r12
    5e5a:	11 97       	sbiw	r26, 0x01	; 1
    5e5c:	87 eb       	ldi	r24, 0xB7	; 183
    5e5e:	9c e0       	ldi	r25, 0x0C	; 12
    5e60:	93 83       	std	Z+3, r25	; 0x03
    5e62:	82 83       	std	Z+2, r24	; 0x02
    5e64:	3e 2d       	mov	r19, r14
    5e66:	2f 2d       	mov	r18, r15
    5e68:	40 e0       	ldi	r20, 0x00	; 0
    5e6a:	50 e0       	ldi	r21, 0x00	; 0
    5e6c:	a9 01       	movw	r20, r18
    5e6e:	33 27       	eor	r19, r19
    5e70:	22 27       	eor	r18, r18
    5e72:	78 01       	movw	r14, r16
    5e74:	00 27       	eor	r16, r16
    5e76:	11 27       	eor	r17, r17
    5e78:	9e 2d       	mov	r25, r14
    5e7a:	8f 2d       	mov	r24, r15
    5e7c:	a0 e0       	ldi	r26, 0x00	; 0
    5e7e:	b0 e0       	ldi	r27, 0x00	; 0
    5e80:	28 2b       	or	r18, r24
    5e82:	39 2b       	or	r19, r25
    5e84:	4a 2b       	or	r20, r26
    5e86:	5b 2b       	or	r21, r27
    5e88:	24 83       	std	Z+4, r18	; 0x04
    5e8a:	35 83       	std	Z+5, r19	; 0x05
    5e8c:	46 83       	std	Z+6, r20	; 0x06
    5e8e:	57 83       	std	Z+7, r21	; 0x07
    5e90:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Ack Num : 0x%x\r\n"), htonl(tcpheader->ackno));
    5e94:	e8 84       	ldd	r14, Y+8	; 0x08
    5e96:	f9 84       	ldd	r15, Y+9	; 0x09
    5e98:	0a 85       	ldd	r16, Y+10	; 0x0a
    5e9a:	1b 85       	ldd	r17, Y+11	; 0x0b
    5e9c:	ed b7       	in	r30, 0x3d	; 61
    5e9e:	fe b7       	in	r31, 0x3e	; 62
    5ea0:	31 96       	adiw	r30, 0x01	; 1
    5ea2:	ad b7       	in	r26, 0x3d	; 61
    5ea4:	be b7       	in	r27, 0x3e	; 62
    5ea6:	12 96       	adiw	r26, 0x02	; 2
    5ea8:	dc 92       	st	X, r13
    5eaa:	ce 92       	st	-X, r12
    5eac:	11 97       	sbiw	r26, 0x01	; 1
    5eae:	86 ea       	ldi	r24, 0xA6	; 166
    5eb0:	9c e0       	ldi	r25, 0x0C	; 12
    5eb2:	93 83       	std	Z+3, r25	; 0x03
    5eb4:	82 83       	std	Z+2, r24	; 0x02
    5eb6:	3e 2d       	mov	r19, r14
    5eb8:	2f 2d       	mov	r18, r15
    5eba:	40 e0       	ldi	r20, 0x00	; 0
    5ebc:	50 e0       	ldi	r21, 0x00	; 0
    5ebe:	a9 01       	movw	r20, r18
    5ec0:	33 27       	eor	r19, r19
    5ec2:	22 27       	eor	r18, r18
    5ec4:	78 01       	movw	r14, r16
    5ec6:	00 27       	eor	r16, r16
    5ec8:	11 27       	eor	r17, r17
    5eca:	9e 2d       	mov	r25, r14
    5ecc:	8f 2d       	mov	r24, r15
    5ece:	a0 e0       	ldi	r26, 0x00	; 0
    5ed0:	b0 e0       	ldi	r27, 0x00	; 0
    5ed2:	28 2b       	or	r18, r24
    5ed4:	39 2b       	or	r19, r25
    5ed6:	4a 2b       	or	r20, r26
    5ed8:	5b 2b       	or	r21, r27
    5eda:	24 83       	std	Z+4, r18	; 0x04
    5edc:	35 83       	std	Z+5, r19	; 0x05
    5ede:	46 83       	std	Z+6, r20	; 0x06
    5ee0:	57 83       	std	Z+7, r21	; 0x07
    5ee2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Flags   : "));
    5ee6:	0f 90       	pop	r0
    5ee8:	0f 90       	pop	r0
    5eea:	0f 90       	pop	r0
    5eec:	0f 90       	pop	r0
    5eee:	ed b7       	in	r30, 0x3d	; 61
    5ef0:	fe b7       	in	r31, 0x3e	; 62
    5ef2:	d2 82       	std	Z+2, r13	; 0x02
    5ef4:	c1 82       	std	Z+1, r12	; 0x01
    5ef6:	8b e9       	ldi	r24, 0x9B	; 155
    5ef8:	9c e0       	ldi	r25, 0x0C	; 12
    5efa:	94 83       	std	Z+4, r25	; 0x04
    5efc:	83 83       	std	Z+3, r24	; 0x03
    5efe:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  if(tcpheader->flags & TCP_FLAGS_FIN)
    5f02:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f04:	0f 90       	pop	r0
    5f06:	0f 90       	pop	r0
    5f08:	0f 90       	pop	r0
    5f0a:	0f 90       	pop	r0
    5f0c:	80 ff       	sbrs	r24, 0
    5f0e:	14 c0       	rjmp	.+40     	; 0x5f38 <netPrintTcpHeader+0x17a>
    fprintf_P(stream, PSTR("FIN "));
    5f10:	00 d0       	rcall	.+0      	; 0x5f12 <netPrintTcpHeader+0x154>
    5f12:	00 d0       	rcall	.+0      	; 0x5f14 <netPrintTcpHeader+0x156>
    5f14:	ad b7       	in	r26, 0x3d	; 61
    5f16:	be b7       	in	r27, 0x3e	; 62
    5f18:	12 96       	adiw	r26, 0x02	; 2
    5f1a:	dc 92       	st	X, r13
    5f1c:	ce 92       	st	-X, r12
    5f1e:	11 97       	sbiw	r26, 0x01	; 1
    5f20:	86 e9       	ldi	r24, 0x96	; 150
    5f22:	9c e0       	ldi	r25, 0x0C	; 12
    5f24:	14 96       	adiw	r26, 0x04	; 4
    5f26:	9c 93       	st	X, r25
    5f28:	8e 93       	st	-X, r24
    5f2a:	13 97       	sbiw	r26, 0x03	; 3
    5f2c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5f30:	0f 90       	pop	r0
    5f32:	0f 90       	pop	r0
    5f34:	0f 90       	pop	r0
    5f36:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_SYN)
    5f38:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f3a:	81 ff       	sbrs	r24, 1
    5f3c:	10 c0       	rjmp	.+32     	; 0x5f5e <netPrintTcpHeader+0x1a0>
    fprintf_P(stream, PSTR("SYN "));
    5f3e:	00 d0       	rcall	.+0      	; 0x5f40 <netPrintTcpHeader+0x182>
    5f40:	00 d0       	rcall	.+0      	; 0x5f42 <netPrintTcpHeader+0x184>
    5f42:	ed b7       	in	r30, 0x3d	; 61
    5f44:	fe b7       	in	r31, 0x3e	; 62
    5f46:	d2 82       	std	Z+2, r13	; 0x02
    5f48:	c1 82       	std	Z+1, r12	; 0x01
    5f4a:	81 e9       	ldi	r24, 0x91	; 145
    5f4c:	9c e0       	ldi	r25, 0x0C	; 12
    5f4e:	94 83       	std	Z+4, r25	; 0x04
    5f50:	83 83       	std	Z+3, r24	; 0x03
    5f52:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5f56:	0f 90       	pop	r0
    5f58:	0f 90       	pop	r0
    5f5a:	0f 90       	pop	r0
    5f5c:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_RST)
    5f5e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f60:	82 ff       	sbrs	r24, 2
    5f62:	14 c0       	rjmp	.+40     	; 0x5f8c <netPrintTcpHeader+0x1ce>
    fprintf_P(stream, PSTR("RST "));
    5f64:	00 d0       	rcall	.+0      	; 0x5f66 <netPrintTcpHeader+0x1a8>
    5f66:	00 d0       	rcall	.+0      	; 0x5f68 <netPrintTcpHeader+0x1aa>
    5f68:	ad b7       	in	r26, 0x3d	; 61
    5f6a:	be b7       	in	r27, 0x3e	; 62
    5f6c:	12 96       	adiw	r26, 0x02	; 2
    5f6e:	dc 92       	st	X, r13
    5f70:	ce 92       	st	-X, r12
    5f72:	11 97       	sbiw	r26, 0x01	; 1
    5f74:	8c e8       	ldi	r24, 0x8C	; 140
    5f76:	9c e0       	ldi	r25, 0x0C	; 12
    5f78:	14 96       	adiw	r26, 0x04	; 4
    5f7a:	9c 93       	st	X, r25
    5f7c:	8e 93       	st	-X, r24
    5f7e:	13 97       	sbiw	r26, 0x03	; 3
    5f80:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5f84:	0f 90       	pop	r0
    5f86:	0f 90       	pop	r0
    5f88:	0f 90       	pop	r0
    5f8a:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_PSH)
    5f8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f8e:	83 ff       	sbrs	r24, 3
    5f90:	10 c0       	rjmp	.+32     	; 0x5fb2 <netPrintTcpHeader+0x1f4>
    fprintf_P(stream, PSTR("PSH "));
    5f92:	00 d0       	rcall	.+0      	; 0x5f94 <netPrintTcpHeader+0x1d6>
    5f94:	00 d0       	rcall	.+0      	; 0x5f96 <netPrintTcpHeader+0x1d8>
    5f96:	ed b7       	in	r30, 0x3d	; 61
    5f98:	fe b7       	in	r31, 0x3e	; 62
    5f9a:	d2 82       	std	Z+2, r13	; 0x02
    5f9c:	c1 82       	std	Z+1, r12	; 0x01
    5f9e:	87 e8       	ldi	r24, 0x87	; 135
    5fa0:	9c e0       	ldi	r25, 0x0C	; 12
    5fa2:	94 83       	std	Z+4, r25	; 0x04
    5fa4:	83 83       	std	Z+3, r24	; 0x03
    5fa6:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5faa:	0f 90       	pop	r0
    5fac:	0f 90       	pop	r0
    5fae:	0f 90       	pop	r0
    5fb0:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_ACK)
    5fb2:	8d 85       	ldd	r24, Y+13	; 0x0d
    5fb4:	84 ff       	sbrs	r24, 4
    5fb6:	14 c0       	rjmp	.+40     	; 0x5fe0 <netPrintTcpHeader+0x222>
    fprintf_P(stream, PSTR("ACK "));
    5fb8:	00 d0       	rcall	.+0      	; 0x5fba <netPrintTcpHeader+0x1fc>
    5fba:	00 d0       	rcall	.+0      	; 0x5fbc <netPrintTcpHeader+0x1fe>
    5fbc:	ad b7       	in	r26, 0x3d	; 61
    5fbe:	be b7       	in	r27, 0x3e	; 62
    5fc0:	12 96       	adiw	r26, 0x02	; 2
    5fc2:	dc 92       	st	X, r13
    5fc4:	ce 92       	st	-X, r12
    5fc6:	11 97       	sbiw	r26, 0x01	; 1
    5fc8:	82 e8       	ldi	r24, 0x82	; 130
    5fca:	9c e0       	ldi	r25, 0x0C	; 12
    5fcc:	14 96       	adiw	r26, 0x04	; 4
    5fce:	9c 93       	st	X, r25
    5fd0:	8e 93       	st	-X, r24
    5fd2:	13 97       	sbiw	r26, 0x03	; 3
    5fd4:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5fd8:	0f 90       	pop	r0
    5fda:	0f 90       	pop	r0
    5fdc:	0f 90       	pop	r0
    5fde:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_URG)
    5fe0:	8d 85       	ldd	r24, Y+13	; 0x0d
    5fe2:	85 ff       	sbrs	r24, 5
    5fe4:	10 c0       	rjmp	.+32     	; 0x6006 <netPrintTcpHeader+0x248>
    fprintf_P(stream, PSTR("URG "));
    5fe6:	00 d0       	rcall	.+0      	; 0x5fe8 <netPrintTcpHeader+0x22a>
    5fe8:	00 d0       	rcall	.+0      	; 0x5fea <netPrintTcpHeader+0x22c>
    5fea:	ed b7       	in	r30, 0x3d	; 61
    5fec:	fe b7       	in	r31, 0x3e	; 62
    5fee:	d2 82       	std	Z+2, r13	; 0x02
    5ff0:	c1 82       	std	Z+1, r12	; 0x01
    5ff2:	8d e7       	ldi	r24, 0x7D	; 125
    5ff4:	9c e0       	ldi	r25, 0x0C	; 12
    5ff6:	94 83       	std	Z+4, r25	; 0x04
    5ff8:	83 83       	std	Z+3, r24	; 0x03
    5ffa:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    5ffe:	0f 90       	pop	r0
    6000:	0f 90       	pop	r0
    6002:	0f 90       	pop	r0
    6004:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    6006:	00 d0       	rcall	.+0      	; 0x6008 <netPrintTcpHeader+0x24a>
    6008:	00 d0       	rcall	.+0      	; 0x600a <netPrintTcpHeader+0x24c>
    600a:	ad b7       	in	r26, 0x3d	; 61
    600c:	be b7       	in	r27, 0x3e	; 62
    600e:	12 96       	adiw	r26, 0x02	; 2
    6010:	dc 92       	st	X, r13
    6012:	ce 92       	st	-X, r12
    6014:	11 97       	sbiw	r26, 0x01	; 1
    6016:	8a e7       	ldi	r24, 0x7A	; 122
    6018:	9c e0       	ldi	r25, 0x0C	; 12
    601a:	14 96       	adiw	r26, 0x04	; 4
    601c:	9c 93       	st	X, r25
    601e:	8e 93       	st	-X, r24
    6020:	13 97       	sbiw	r26, 0x03	; 3
    6022:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6026:	0f 90       	pop	r0
    6028:	0f 90       	pop	r0
    602a:	0f 90       	pop	r0
    602c:	0f 90       	pop	r0
}
    602e:	df 91       	pop	r29
    6030:	cf 91       	pop	r28
    6032:	1f 91       	pop	r17
    6034:	0f 91       	pop	r16
    6036:	ff 90       	pop	r15
    6038:	ef 90       	pop	r14
    603a:	df 90       	pop	r13
    603c:	cf 90       	pop	r12
    603e:	08 95       	ret

00006040 <netPrintIPAddr>:
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
}

void netPrintIPAddr(FILE *stream, uint32_t ipaddr)
{
    6040:	df 93       	push	r29
    6042:	cf 93       	push	r28
    6044:	00 d0       	rcall	.+0      	; 0x6046 <netPrintIPAddr+0x6>
    6046:	00 d0       	rcall	.+0      	; 0x6048 <netPrintIPAddr+0x8>
    6048:	cd b7       	in	r28, 0x3d	; 61
    604a:	de b7       	in	r29, 0x3e	; 62
    604c:	49 83       	std	Y+1, r20	; 0x01
    604e:	5a 83       	std	Y+2, r21	; 0x02
    6050:	6b 83       	std	Y+3, r22	; 0x03
    6052:	7c 83       	std	Y+4, r23	; 0x04
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
    6054:	ae 01       	movw	r20, r28
    6056:	4f 5f       	subi	r20, 0xFF	; 255
    6058:	5f 4f       	sbci	r21, 0xFF	; 255
    605a:	2d b7       	in	r18, 0x3d	; 61
    605c:	3e b7       	in	r19, 0x3e	; 62
    605e:	2c 50       	subi	r18, 0x0C	; 12
    6060:	30 40       	sbci	r19, 0x00	; 0
    6062:	0f b6       	in	r0, 0x3f	; 63
    6064:	f8 94       	cli
    6066:	3e bf       	out	0x3e, r19	; 62
    6068:	0f be       	out	0x3f, r0	; 63
    606a:	2d bf       	out	0x3d, r18	; 61
    606c:	ed b7       	in	r30, 0x3d	; 61
    606e:	fe b7       	in	r31, 0x3e	; 62
    6070:	31 96       	adiw	r30, 0x01	; 1
    6072:	ad b7       	in	r26, 0x3d	; 61
    6074:	be b7       	in	r27, 0x3e	; 62
    6076:	12 96       	adiw	r26, 0x02	; 2
    6078:	9c 93       	st	X, r25
    607a:	8e 93       	st	-X, r24
    607c:	11 97       	sbiw	r26, 0x01	; 1
    607e:	8a e9       	ldi	r24, 0x9A	; 154
    6080:	9d e0       	ldi	r25, 0x0D	; 13
    6082:	93 83       	std	Z+3, r25	; 0x03
    6084:	82 83       	std	Z+2, r24	; 0x02
    6086:	89 81       	ldd	r24, Y+1	; 0x01
    6088:	84 83       	std	Z+4, r24	; 0x04
    608a:	15 82       	std	Z+5, r1	; 0x05
    608c:	da 01       	movw	r26, r20
    608e:	11 96       	adiw	r26, 0x01	; 1
    6090:	8c 91       	ld	r24, X
    6092:	11 97       	sbiw	r26, 0x01	; 1
    6094:	86 83       	std	Z+6, r24	; 0x06
    6096:	17 82       	std	Z+7, r1	; 0x07
    6098:	12 96       	adiw	r26, 0x02	; 2
    609a:	8c 91       	ld	r24, X
    609c:	12 97       	sbiw	r26, 0x02	; 2
    609e:	80 87       	std	Z+8, r24	; 0x08
    60a0:	11 86       	std	Z+9, r1	; 0x09
    60a2:	13 96       	adiw	r26, 0x03	; 3
    60a4:	8c 91       	ld	r24, X
    60a6:	82 87       	std	Z+10, r24	; 0x0a
    60a8:	13 86       	std	Z+11, r1	; 0x0b
    60aa:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    60ae:	2d b7       	in	r18, 0x3d	; 61
    60b0:	3e b7       	in	r19, 0x3e	; 62
    60b2:	24 5f       	subi	r18, 0xF4	; 244
    60b4:	3f 4f       	sbci	r19, 0xFF	; 255
    60b6:	0f b6       	in	r0, 0x3f	; 63
    60b8:	f8 94       	cli
    60ba:	3e bf       	out	0x3e, r19	; 62
    60bc:	0f be       	out	0x3f, r0	; 63
    60be:	2d bf       	out	0x3d, r18	; 61
}
    60c0:	0f 90       	pop	r0
    60c2:	0f 90       	pop	r0
    60c4:	0f 90       	pop	r0
    60c6:	0f 90       	pop	r0
    60c8:	cf 91       	pop	r28
    60ca:	df 91       	pop	r29
    60cc:	08 95       	ret

000060ce <netPrintIpHeader>:
  fprintf_P(stream, PSTR("->DST:"));
  netPrintEthAddr(stream, &eth_hdr->dest);
}

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
    60ce:	ef 92       	push	r14
    60d0:	ff 92       	push	r15
    60d2:	0f 93       	push	r16
    60d4:	1f 93       	push	r17
    60d6:	cf 93       	push	r28
    60d8:	df 93       	push	r29
    60da:	ec 01       	movw	r28, r24
    60dc:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("IP Header\r\n"));
    60de:	00 d0       	rcall	.+0      	; 0x60e0 <netPrintIpHeader+0x12>
    60e0:	00 d0       	rcall	.+0      	; 0x60e2 <netPrintIpHeader+0x14>
    60e2:	ad b7       	in	r26, 0x3d	; 61
    60e4:	be b7       	in	r27, 0x3e	; 62
    60e6:	12 96       	adiw	r26, 0x02	; 2
    60e8:	9c 93       	st	X, r25
    60ea:	8e 93       	st	-X, r24
    60ec:	11 97       	sbiw	r26, 0x01	; 1
    60ee:	8b e6       	ldi	r24, 0x6B	; 107
    60f0:	9d e0       	ldi	r25, 0x0D	; 13
    60f2:	14 96       	adiw	r26, 0x04	; 4
    60f4:	9c 93       	st	X, r25
    60f6:	8e 93       	st	-X, r24
    60f8:	13 97       	sbiw	r26, 0x03	; 3
    60fa:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
    60fe:	00 d0       	rcall	.+0      	; 0x6100 <netPrintIpHeader+0x32>
    6100:	ed b7       	in	r30, 0x3d	; 61
    6102:	fe b7       	in	r31, 0x3e	; 62
    6104:	31 96       	adiw	r30, 0x01	; 1
    6106:	ad b7       	in	r26, 0x3d	; 61
    6108:	be b7       	in	r27, 0x3e	; 62
    610a:	12 96       	adiw	r26, 0x02	; 2
    610c:	dc 93       	st	X, r29
    610e:	ce 93       	st	-X, r28
    6110:	11 97       	sbiw	r26, 0x01	; 1
    6112:	8c e5       	ldi	r24, 0x5C	; 92
    6114:	9d e0       	ldi	r25, 0x0D	; 13
    6116:	93 83       	std	Z+3, r25	; 0x03
    6118:	82 83       	std	Z+2, r24	; 0x02
    611a:	d7 01       	movw	r26, r14
    611c:	8c 91       	ld	r24, X
    611e:	82 95       	swap	r24
    6120:	8f 70       	andi	r24, 0x0F	; 15
    6122:	84 83       	std	Z+4, r24	; 0x04
    6124:	15 82       	std	Z+5, r1	; 0x05
    6126:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    612a:	ed b7       	in	r30, 0x3d	; 61
    612c:	fe b7       	in	r31, 0x3e	; 62
    612e:	31 96       	adiw	r30, 0x01	; 1
    6130:	ad b7       	in	r26, 0x3d	; 61
    6132:	be b7       	in	r27, 0x3e	; 62
    6134:	12 96       	adiw	r26, 0x02	; 2
    6136:	dc 93       	st	X, r29
    6138:	ce 93       	st	-X, r28
    613a:	11 97       	sbiw	r26, 0x01	; 1
    613c:	8d e4       	ldi	r24, 0x4D	; 77
    613e:	9d e0       	ldi	r25, 0x0D	; 13
    6140:	93 83       	std	Z+3, r25	; 0x03
    6142:	82 83       	std	Z+2, r24	; 0x02
    6144:	d7 01       	movw	r26, r14
    6146:	12 96       	adiw	r26, 0x02	; 2
    6148:	9c 91       	ld	r25, X
    614a:	12 97       	sbiw	r26, 0x02	; 2
    614c:	13 96       	adiw	r26, 0x03	; 3
    614e:	8c 91       	ld	r24, X
    6150:	84 83       	std	Z+4, r24	; 0x04
    6152:	95 83       	std	Z+5, r25	; 0x05
    6154:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  if(ipheader->proto == IP_PROTO_ICMP)
    6158:	f7 01       	movw	r30, r14
    615a:	21 85       	ldd	r18, Z+9	; 0x09
    615c:	8d b7       	in	r24, 0x3d	; 61
    615e:	9e b7       	in	r25, 0x3e	; 62
    6160:	06 96       	adiw	r24, 0x06	; 6
    6162:	0f b6       	in	r0, 0x3f	; 63
    6164:	f8 94       	cli
    6166:	9e bf       	out	0x3e, r25	; 62
    6168:	0f be       	out	0x3f, r0	; 63
    616a:	8d bf       	out	0x3d, r24	; 61
    616c:	21 30       	cpi	r18, 0x01	; 1
    616e:	59 f4       	brne	.+22     	; 0x6186 <netPrintIpHeader+0xb8>
    fprintf_P(stream, PSTR("Protocol: ICMP\r\n"));
    6170:	00 d0       	rcall	.+0      	; 0x6172 <netPrintIpHeader+0xa4>
    6172:	00 d0       	rcall	.+0      	; 0x6174 <netPrintIpHeader+0xa6>
    6174:	ad b7       	in	r26, 0x3d	; 61
    6176:	be b7       	in	r27, 0x3e	; 62
    6178:	12 96       	adiw	r26, 0x02	; 2
    617a:	dc 93       	st	X, r29
    617c:	ce 93       	st	-X, r28
    617e:	11 97       	sbiw	r26, 0x01	; 1
    6180:	8c e3       	ldi	r24, 0x3C	; 60
    6182:	9d e0       	ldi	r25, 0x0D	; 13
    6184:	1f c0       	rjmp	.+62     	; 0x61c4 <netPrintIpHeader+0xf6>
  else if(ipheader->proto == IP_PROTO_TCP)
    6186:	26 30       	cpi	r18, 0x06	; 6
    6188:	89 f4       	brne	.+34     	; 0x61ac <netPrintIpHeader+0xde>
    fprintf_P(stream, PSTR("Protocol: TCP\r\n"));
    618a:	00 d0       	rcall	.+0      	; 0x618c <netPrintIpHeader+0xbe>
    618c:	00 d0       	rcall	.+0      	; 0x618e <netPrintIpHeader+0xc0>
    618e:	ed b7       	in	r30, 0x3d	; 61
    6190:	fe b7       	in	r31, 0x3e	; 62
    6192:	d2 83       	std	Z+2, r29	; 0x02
    6194:	c1 83       	std	Z+1, r28	; 0x01
    6196:	8c e2       	ldi	r24, 0x2C	; 44
    6198:	9d e0       	ldi	r25, 0x0D	; 13
    619a:	94 83       	std	Z+4, r25	; 0x04
    619c:	83 83       	std	Z+3, r24	; 0x03
    619e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    61a2:	0f 90       	pop	r0
    61a4:	0f 90       	pop	r0
    61a6:	0f 90       	pop	r0
    61a8:	0f 90       	pop	r0
    61aa:	2d c0       	rjmp	.+90     	; 0x6206 <netPrintIpHeader+0x138>
  else if(ipheader->proto == IP_PROTO_UDP)
    61ac:	21 31       	cpi	r18, 0x11	; 17
    61ae:	79 f4       	brne	.+30     	; 0x61ce <netPrintIpHeader+0x100>
    fprintf_P(stream, PSTR("Protocol: UDP\r\n"));
    61b0:	00 d0       	rcall	.+0      	; 0x61b2 <netPrintIpHeader+0xe4>
    61b2:	00 d0       	rcall	.+0      	; 0x61b4 <netPrintIpHeader+0xe6>
    61b4:	ad b7       	in	r26, 0x3d	; 61
    61b6:	be b7       	in	r27, 0x3e	; 62
    61b8:	12 96       	adiw	r26, 0x02	; 2
    61ba:	dc 93       	st	X, r29
    61bc:	ce 93       	st	-X, r28
    61be:	11 97       	sbiw	r26, 0x01	; 1
    61c0:	8c e1       	ldi	r24, 0x1C	; 28
    61c2:	9d e0       	ldi	r25, 0x0D	; 13
    61c4:	14 96       	adiw	r26, 0x04	; 4
    61c6:	9c 93       	st	X, r25
    61c8:	8e 93       	st	-X, r24
    61ca:	13 97       	sbiw	r26, 0x03	; 3
    61cc:	e8 cf       	rjmp	.-48     	; 0x619e <netPrintIpHeader+0xd0>
  else
    fprintf_P(stream, PSTR("Protocol: %d\r\n"), ipheader->proto);
    61ce:	00 d0       	rcall	.+0      	; 0x61d0 <netPrintIpHeader+0x102>
    61d0:	00 d0       	rcall	.+0      	; 0x61d2 <netPrintIpHeader+0x104>
    61d2:	00 d0       	rcall	.+0      	; 0x61d4 <netPrintIpHeader+0x106>
    61d4:	ed b7       	in	r30, 0x3d	; 61
    61d6:	fe b7       	in	r31, 0x3e	; 62
    61d8:	31 96       	adiw	r30, 0x01	; 1
    61da:	ad b7       	in	r26, 0x3d	; 61
    61dc:	be b7       	in	r27, 0x3e	; 62
    61de:	12 96       	adiw	r26, 0x02	; 2
    61e0:	dc 93       	st	X, r29
    61e2:	ce 93       	st	-X, r28
    61e4:	11 97       	sbiw	r26, 0x01	; 1
    61e6:	8d e0       	ldi	r24, 0x0D	; 13
    61e8:	9d e0       	ldi	r25, 0x0D	; 13
    61ea:	93 83       	std	Z+3, r25	; 0x03
    61ec:	82 83       	std	Z+2, r24	; 0x02
    61ee:	24 83       	std	Z+4, r18	; 0x04
    61f0:	15 82       	std	Z+5, r1	; 0x05
    61f2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    61f6:	ed b7       	in	r30, 0x3d	; 61
    61f8:	fe b7       	in	r31, 0x3e	; 62
    61fa:	36 96       	adiw	r30, 0x06	; 6
    61fc:	0f b6       	in	r0, 0x3f	; 63
    61fe:	f8 94       	cli
    6200:	fe bf       	out	0x3e, r31	; 62
    6202:	0f be       	out	0x3f, r0	; 63
    6204:	ed bf       	out	0x3d, r30	; 61

  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
    6206:	00 d0       	rcall	.+0      	; 0x6208 <netPrintIpHeader+0x13a>
    6208:	00 d0       	rcall	.+0      	; 0x620a <netPrintIpHeader+0x13c>
    620a:	ad b7       	in	r26, 0x3d	; 61
    620c:	be b7       	in	r27, 0x3e	; 62
    620e:	12 96       	adiw	r26, 0x02	; 2
    6210:	dc 93       	st	X, r29
    6212:	ce 93       	st	-X, r28
    6214:	11 97       	sbiw	r26, 0x01	; 1
    6216:	82 e0       	ldi	r24, 0x02	; 2
    6218:	9d e0       	ldi	r25, 0x0D	; 13
    621a:	14 96       	adiw	r26, 0x04	; 4
    621c:	9c 93       	st	X, r25
    621e:	8e 93       	st	-X, r24
    6220:	13 97       	sbiw	r26, 0x03	; 3
    6222:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6226:	f7 01       	movw	r30, r14
    6228:	04 85       	ldd	r16, Z+12	; 0x0c
    622a:	15 85       	ldd	r17, Z+13	; 0x0d
    622c:	26 85       	ldd	r18, Z+14	; 0x0e
    622e:	37 85       	ldd	r19, Z+15	; 0x0f
    6230:	0f 90       	pop	r0
    6232:	0f 90       	pop	r0
    6234:	0f 90       	pop	r0
    6236:	0f 90       	pop	r0
    6238:	50 2f       	mov	r21, r16
    623a:	41 2f       	mov	r20, r17
    623c:	60 e0       	ldi	r22, 0x00	; 0
    623e:	70 e0       	ldi	r23, 0x00	; 0
    6240:	ba 01       	movw	r22, r20
    6242:	55 27       	eor	r21, r21
    6244:	44 27       	eor	r20, r20
    6246:	89 01       	movw	r16, r18
    6248:	22 27       	eor	r18, r18
    624a:	33 27       	eor	r19, r19
    624c:	90 2f       	mov	r25, r16
    624e:	81 2f       	mov	r24, r17
    6250:	a0 e0       	ldi	r26, 0x00	; 0
    6252:	b0 e0       	ldi	r27, 0x00	; 0
    6254:	48 2b       	or	r20, r24
    6256:	59 2b       	or	r21, r25
    6258:	6a 2b       	or	r22, r26
    625a:	7b 2b       	or	r23, r27
    625c:	ce 01       	movw	r24, r28
    625e:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    6262:	00 d0       	rcall	.+0      	; 0x6264 <netPrintIpHeader+0x196>
    6264:	00 d0       	rcall	.+0      	; 0x6266 <netPrintIpHeader+0x198>
    6266:	ad b7       	in	r26, 0x3d	; 61
    6268:	be b7       	in	r27, 0x3e	; 62
    626a:	12 96       	adiw	r26, 0x02	; 2
    626c:	dc 93       	st	X, r29
    626e:	ce 93       	st	-X, r28
    6270:	11 97       	sbiw	r26, 0x01	; 1
    6272:	8f ef       	ldi	r24, 0xFF	; 255
    6274:	9c e0       	ldi	r25, 0x0C	; 12
    6276:	14 96       	adiw	r26, 0x04	; 4
    6278:	9c 93       	st	X, r25
    627a:	8e 93       	st	-X, r24
    627c:	13 97       	sbiw	r26, 0x03	; 3
    627e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
    6282:	ed b7       	in	r30, 0x3d	; 61
    6284:	fe b7       	in	r31, 0x3e	; 62
    6286:	d2 83       	std	Z+2, r29	; 0x02
    6288:	c1 83       	std	Z+1, r28	; 0x01
    628a:	84 ef       	ldi	r24, 0xF4	; 244
    628c:	9c e0       	ldi	r25, 0x0C	; 12
    628e:	94 83       	std	Z+4, r25	; 0x04
    6290:	83 83       	std	Z+3, r24	; 0x03
    6292:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6296:	d7 01       	movw	r26, r14
    6298:	50 96       	adiw	r26, 0x10	; 16
    629a:	0d 91       	ld	r16, X+
    629c:	1d 91       	ld	r17, X+
    629e:	2d 91       	ld	r18, X+
    62a0:	3c 91       	ld	r19, X
    62a2:	53 97       	sbiw	r26, 0x13	; 19
    62a4:	0f 90       	pop	r0
    62a6:	0f 90       	pop	r0
    62a8:	0f 90       	pop	r0
    62aa:	0f 90       	pop	r0
    62ac:	50 2f       	mov	r21, r16
    62ae:	41 2f       	mov	r20, r17
    62b0:	60 e0       	ldi	r22, 0x00	; 0
    62b2:	70 e0       	ldi	r23, 0x00	; 0
    62b4:	ba 01       	movw	r22, r20
    62b6:	55 27       	eor	r21, r21
    62b8:	44 27       	eor	r20, r20
    62ba:	89 01       	movw	r16, r18
    62bc:	22 27       	eor	r18, r18
    62be:	33 27       	eor	r19, r19
    62c0:	90 2f       	mov	r25, r16
    62c2:	81 2f       	mov	r24, r17
    62c4:	a0 e0       	ldi	r26, 0x00	; 0
    62c6:	b0 e0       	ldi	r27, 0x00	; 0
    62c8:	48 2b       	or	r20, r24
    62ca:	59 2b       	or	r21, r25
    62cc:	6a 2b       	or	r22, r26
    62ce:	7b 2b       	or	r23, r27
    62d0:	ce 01       	movw	r24, r28
    62d2:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    62d6:	00 d0       	rcall	.+0      	; 0x62d8 <netPrintIpHeader+0x20a>
    62d8:	00 d0       	rcall	.+0      	; 0x62da <netPrintIpHeader+0x20c>
    62da:	ed b7       	in	r30, 0x3d	; 61
    62dc:	fe b7       	in	r31, 0x3e	; 62
    62de:	d2 83       	std	Z+2, r29	; 0x02
    62e0:	c1 83       	std	Z+1, r28	; 0x01
    62e2:	81 ef       	ldi	r24, 0xF1	; 241
    62e4:	9c e0       	ldi	r25, 0x0C	; 12
    62e6:	94 83       	std	Z+4, r25	; 0x04
    62e8:	83 83       	std	Z+3, r24	; 0x03
    62ea:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    62ee:	0f 90       	pop	r0
    62f0:	0f 90       	pop	r0
    62f2:	0f 90       	pop	r0
    62f4:	0f 90       	pop	r0
}
    62f6:	df 91       	pop	r29
    62f8:	cf 91       	pop	r28
    62fa:	1f 91       	pop	r17
    62fc:	0f 91       	pop	r16
    62fe:	ff 90       	pop	r15
    6300:	ef 90       	pop	r14
    6302:	08 95       	ret

00006304 <netPrintEthAddr>:

  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
    6304:	cf 93       	push	r28
    6306:	df 93       	push	r29
    6308:	db 01       	movw	r26, r22
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    630a:	2d b7       	in	r18, 0x3d	; 61
    630c:	3e b7       	in	r19, 0x3e	; 62
    630e:	20 51       	subi	r18, 0x10	; 16
    6310:	30 40       	sbci	r19, 0x00	; 0
    6312:	0f b6       	in	r0, 0x3f	; 63
    6314:	f8 94       	cli
    6316:	3e bf       	out	0x3e, r19	; 62
    6318:	0f be       	out	0x3f, r0	; 63
    631a:	2d bf       	out	0x3d, r18	; 61
    631c:	ed b7       	in	r30, 0x3d	; 61
    631e:	fe b7       	in	r31, 0x3e	; 62
    6320:	31 96       	adiw	r30, 0x01	; 1
    6322:	cd b7       	in	r28, 0x3d	; 61
    6324:	de b7       	in	r29, 0x3e	; 62
    6326:	9a 83       	std	Y+2, r25	; 0x02
    6328:	89 83       	std	Y+1, r24	; 0x01
    632a:	86 ea       	ldi	r24, 0xA6	; 166
    632c:	9d e0       	ldi	r25, 0x0D	; 13
    632e:	93 83       	std	Z+3, r25	; 0x03
    6330:	82 83       	std	Z+2, r24	; 0x02
    6332:	8c 91       	ld	r24, X
    6334:	84 83       	std	Z+4, r24	; 0x04
    6336:	15 82       	std	Z+5, r1	; 0x05
    6338:	11 96       	adiw	r26, 0x01	; 1
    633a:	8c 91       	ld	r24, X
    633c:	11 97       	sbiw	r26, 0x01	; 1
    633e:	86 83       	std	Z+6, r24	; 0x06
    6340:	17 82       	std	Z+7, r1	; 0x07
    6342:	12 96       	adiw	r26, 0x02	; 2
    6344:	8c 91       	ld	r24, X
    6346:	12 97       	sbiw	r26, 0x02	; 2
    6348:	80 87       	std	Z+8, r24	; 0x08
    634a:	11 86       	std	Z+9, r1	; 0x09
    634c:	13 96       	adiw	r26, 0x03	; 3
    634e:	8c 91       	ld	r24, X
    6350:	13 97       	sbiw	r26, 0x03	; 3
    6352:	82 87       	std	Z+10, r24	; 0x0a
    6354:	13 86       	std	Z+11, r1	; 0x0b
    6356:	14 96       	adiw	r26, 0x04	; 4
    6358:	8c 91       	ld	r24, X
    635a:	14 97       	sbiw	r26, 0x04	; 4
    635c:	84 87       	std	Z+12, r24	; 0x0c
    635e:	15 86       	std	Z+13, r1	; 0x0d
    6360:	15 96       	adiw	r26, 0x05	; 5
    6362:	8c 91       	ld	r24, X
    6364:	86 87       	std	Z+14, r24	; 0x0e
    6366:	17 86       	std	Z+15, r1	; 0x0f
    6368:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    636c:	2d b7       	in	r18, 0x3d	; 61
    636e:	3e b7       	in	r19, 0x3e	; 62
    6370:	20 5f       	subi	r18, 0xF0	; 240
    6372:	3f 4f       	sbci	r19, 0xFF	; 255
    6374:	0f b6       	in	r0, 0x3f	; 63
    6376:	f8 94       	cli
    6378:	3e bf       	out	0x3e, r19	; 62
    637a:	0f be       	out	0x3f, r0	; 63
    637c:	2d bf       	out	0x3d, r18	; 61
}
    637e:	df 91       	pop	r29
    6380:	cf 91       	pop	r28
    6382:	08 95       	ret

00006384 <netPrintEthHeader>:
{
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
}

void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
    6384:	cf 92       	push	r12
    6386:	df 92       	push	r13
    6388:	ef 92       	push	r14
    638a:	ff 92       	push	r15
    638c:	0f 93       	push	r16
    638e:	1f 93       	push	r17
    6390:	7c 01       	movw	r14, r24
    6392:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
    6394:	00 d0       	rcall	.+0      	; 0x6396 <netPrintEthHeader+0x12>
    6396:	00 d0       	rcall	.+0      	; 0x6398 <netPrintEthHeader+0x14>
    6398:	00 d0       	rcall	.+0      	; 0x639a <netPrintEthHeader+0x16>
    639a:	ed b7       	in	r30, 0x3d	; 61
    639c:	fe b7       	in	r31, 0x3e	; 62
    639e:	31 96       	adiw	r30, 0x01	; 1
    63a0:	ad b7       	in	r26, 0x3d	; 61
    63a2:	be b7       	in	r27, 0x3e	; 62
    63a4:	12 96       	adiw	r26, 0x02	; 2
    63a6:	9c 93       	st	X, r25
    63a8:	8e 93       	st	-X, r24
    63aa:	11 97       	sbiw	r26, 0x01	; 1
    63ac:	84 e8       	ldi	r24, 0x84	; 132
    63ae:	9d e0       	ldi	r25, 0x0D	; 13
    63b0:	93 83       	std	Z+3, r25	; 0x03
    63b2:	82 83       	std	Z+2, r24	; 0x02
    63b4:	db 01       	movw	r26, r22
    63b6:	1c 96       	adiw	r26, 0x0c	; 12
    63b8:	8d 91       	ld	r24, X+
    63ba:	9c 91       	ld	r25, X
    63bc:	1d 97       	sbiw	r26, 0x0d	; 13
    63be:	95 83       	std	Z+5, r25	; 0x05
    63c0:	84 83       	std	Z+4, r24	; 0x04
    63c2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR(" SRC:"));
    63c6:	0f 90       	pop	r0
    63c8:	0f 90       	pop	r0
    63ca:	ed b7       	in	r30, 0x3d	; 61
    63cc:	fe b7       	in	r31, 0x3e	; 62
    63ce:	f2 82       	std	Z+2, r15	; 0x02
    63d0:	e1 82       	std	Z+1, r14	; 0x01
    63d2:	8e e7       	ldi	r24, 0x7E	; 126
    63d4:	9d e0       	ldi	r25, 0x0D	; 13
    63d6:	94 83       	std	Z+4, r25	; 0x04
    63d8:	83 83       	std	Z+3, r24	; 0x03
    63da:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    63de:	8d b7       	in	r24, 0x3d	; 61
    63e0:	9e b7       	in	r25, 0x3e	; 62
    63e2:	0c 97       	sbiw	r24, 0x0c	; 12
    63e4:	0f b6       	in	r0, 0x3f	; 63
    63e6:	f8 94       	cli
    63e8:	9e bf       	out	0x3e, r25	; 62
    63ea:	0f be       	out	0x3f, r0	; 63
    63ec:	8d bf       	out	0x3d, r24	; 61
    63ee:	ed b7       	in	r30, 0x3d	; 61
    63f0:	fe b7       	in	r31, 0x3e	; 62
    63f2:	31 96       	adiw	r30, 0x01	; 1
    63f4:	ad b7       	in	r26, 0x3d	; 61
    63f6:	be b7       	in	r27, 0x3e	; 62
    63f8:	12 96       	adiw	r26, 0x02	; 2
    63fa:	fc 92       	st	X, r15
    63fc:	ee 92       	st	-X, r14
    63fe:	11 97       	sbiw	r26, 0x01	; 1
    6400:	b6 ea       	ldi	r27, 0xA6	; 166
    6402:	cb 2e       	mov	r12, r27
    6404:	bd e0       	ldi	r27, 0x0D	; 13
    6406:	db 2e       	mov	r13, r27
    6408:	d3 82       	std	Z+3, r13	; 0x03
    640a:	c2 82       	std	Z+2, r12	; 0x02
    640c:	d8 01       	movw	r26, r16
    640e:	16 96       	adiw	r26, 0x06	; 6
    6410:	8c 91       	ld	r24, X
    6412:	16 97       	sbiw	r26, 0x06	; 6
    6414:	84 83       	std	Z+4, r24	; 0x04
    6416:	15 82       	std	Z+5, r1	; 0x05
    6418:	17 96       	adiw	r26, 0x07	; 7
    641a:	8c 91       	ld	r24, X
    641c:	17 97       	sbiw	r26, 0x07	; 7
    641e:	86 83       	std	Z+6, r24	; 0x06
    6420:	17 82       	std	Z+7, r1	; 0x07
    6422:	18 96       	adiw	r26, 0x08	; 8
    6424:	8c 91       	ld	r24, X
    6426:	18 97       	sbiw	r26, 0x08	; 8
    6428:	80 87       	std	Z+8, r24	; 0x08
    642a:	11 86       	std	Z+9, r1	; 0x09
    642c:	19 96       	adiw	r26, 0x09	; 9
    642e:	8c 91       	ld	r24, X
    6430:	19 97       	sbiw	r26, 0x09	; 9
    6432:	82 87       	std	Z+10, r24	; 0x0a
    6434:	13 86       	std	Z+11, r1	; 0x0b
    6436:	1a 96       	adiw	r26, 0x0a	; 10
    6438:	8c 91       	ld	r24, X
    643a:	1a 97       	sbiw	r26, 0x0a	; 10
    643c:	84 87       	std	Z+12, r24	; 0x0c
    643e:	15 86       	std	Z+13, r1	; 0x0d
    6440:	1b 96       	adiw	r26, 0x0b	; 11
    6442:	8c 91       	ld	r24, X
    6444:	86 87       	std	Z+14, r24	; 0x0e
    6446:	17 86       	std	Z+15, r1	; 0x0f
    6448:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
  fprintf_P(stream, PSTR(" SRC:"));
  netPrintEthAddr(stream, &eth_hdr->src);
  fprintf_P(stream, PSTR("->DST:"));
    644c:	ed b7       	in	r30, 0x3d	; 61
    644e:	fe b7       	in	r31, 0x3e	; 62
    6450:	3c 96       	adiw	r30, 0x0c	; 12
    6452:	0f b6       	in	r0, 0x3f	; 63
    6454:	f8 94       	cli
    6456:	fe bf       	out	0x3e, r31	; 62
    6458:	0f be       	out	0x3f, r0	; 63
    645a:	ed bf       	out	0x3d, r30	; 61
    645c:	f2 82       	std	Z+2, r15	; 0x02
    645e:	e1 82       	std	Z+1, r14	; 0x01
    6460:	87 e7       	ldi	r24, 0x77	; 119
    6462:	9d e0       	ldi	r25, 0x0D	; 13
    6464:	94 83       	std	Z+4, r25	; 0x04
    6466:	83 83       	std	Z+3, r24	; 0x03
    6468:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    646c:	8d b7       	in	r24, 0x3d	; 61
    646e:	9e b7       	in	r25, 0x3e	; 62
    6470:	0c 97       	sbiw	r24, 0x0c	; 12
    6472:	0f b6       	in	r0, 0x3f	; 63
    6474:	f8 94       	cli
    6476:	9e bf       	out	0x3e, r25	; 62
    6478:	0f be       	out	0x3f, r0	; 63
    647a:	8d bf       	out	0x3d, r24	; 61
    647c:	ed b7       	in	r30, 0x3d	; 61
    647e:	fe b7       	in	r31, 0x3e	; 62
    6480:	31 96       	adiw	r30, 0x01	; 1
    6482:	ad b7       	in	r26, 0x3d	; 61
    6484:	be b7       	in	r27, 0x3e	; 62
    6486:	12 96       	adiw	r26, 0x02	; 2
    6488:	fc 92       	st	X, r15
    648a:	ee 92       	st	-X, r14
    648c:	11 97       	sbiw	r26, 0x01	; 1
    648e:	d3 82       	std	Z+3, r13	; 0x03
    6490:	c2 82       	std	Z+2, r12	; 0x02
    6492:	d8 01       	movw	r26, r16
    6494:	8c 91       	ld	r24, X
    6496:	84 83       	std	Z+4, r24	; 0x04
    6498:	15 82       	std	Z+5, r1	; 0x05
    649a:	11 96       	adiw	r26, 0x01	; 1
    649c:	8c 91       	ld	r24, X
    649e:	11 97       	sbiw	r26, 0x01	; 1
    64a0:	86 83       	std	Z+6, r24	; 0x06
    64a2:	17 82       	std	Z+7, r1	; 0x07
    64a4:	12 96       	adiw	r26, 0x02	; 2
    64a6:	8c 91       	ld	r24, X
    64a8:	12 97       	sbiw	r26, 0x02	; 2
    64aa:	80 87       	std	Z+8, r24	; 0x08
    64ac:	11 86       	std	Z+9, r1	; 0x09
    64ae:	13 96       	adiw	r26, 0x03	; 3
    64b0:	8c 91       	ld	r24, X
    64b2:	13 97       	sbiw	r26, 0x03	; 3
    64b4:	82 87       	std	Z+10, r24	; 0x0a
    64b6:	13 86       	std	Z+11, r1	; 0x0b
    64b8:	14 96       	adiw	r26, 0x04	; 4
    64ba:	8c 91       	ld	r24, X
    64bc:	14 97       	sbiw	r26, 0x04	; 4
    64be:	84 87       	std	Z+12, r24	; 0x0c
    64c0:	15 86       	std	Z+13, r1	; 0x0d
    64c2:	15 96       	adiw	r26, 0x05	; 5
    64c4:	8c 91       	ld	r24, X
    64c6:	86 87       	std	Z+14, r24	; 0x0e
    64c8:	17 86       	std	Z+15, r1	; 0x0f
    64ca:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    64ce:	ed b7       	in	r30, 0x3d	; 61
    64d0:	fe b7       	in	r31, 0x3e	; 62
    64d2:	70 96       	adiw	r30, 0x10	; 16
    64d4:	0f b6       	in	r0, 0x3f	; 63
    64d6:	f8 94       	cli
    64d8:	fe bf       	out	0x3e, r31	; 62
    64da:	0f be       	out	0x3f, r0	; 63
    64dc:	ed bf       	out	0x3d, r30	; 61
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
  fprintf_P(stream, PSTR(" SRC:"));
  netPrintEthAddr(stream, &eth_hdr->src);
  fprintf_P(stream, PSTR("->DST:"));
  netPrintEthAddr(stream, &eth_hdr->dest);
}
    64de:	1f 91       	pop	r17
    64e0:	0f 91       	pop	r16
    64e2:	ff 90       	pop	r15
    64e4:	ef 90       	pop	r14
    64e6:	df 90       	pop	r13
    64e8:	cf 90       	pop	r12
    64ea:	08 95       	ret

000064ec <setIpDebug>:
}

#if IP_DEBUG
void setIpDebug(FILE *stream, uint8_t level)
{
  IpMyConfig.dbgStream = stream;
    64ec:	90 93 62 0f 	sts	0x0F62, r25
    64f0:	80 93 61 0f 	sts	0x0F61, r24
  IpMyConfig.dbgLevel = level;
    64f4:	60 93 63 0f 	sts	0x0F63, r22
  if (level == 0)
    64f8:	66 23       	and	r22, r22
    64fa:	21 f4       	brne	.+8      	; 0x6504 <setIpDebug+0x18>
    IpMyConfig.dbgStream = NULL;
    64fc:	10 92 62 0f 	sts	0x0F62, r1
    6500:	10 92 61 0f 	sts	0x0F61, r1
    6504:	08 95       	ret

00006506 <ipSetConfig>:
}
#endif

void ipSetConfig(uint32_t myIp, uint32_t netmask, uint32_t gatewayIp)
{
    6506:	ef 92       	push	r14
    6508:	ff 92       	push	r15
    650a:	0f 93       	push	r16
    650c:	1f 93       	push	r17
  // set local addressing
  IpMyConfig.ip = myIp;
    650e:	60 93 55 0f 	sts	0x0F55, r22
    6512:	70 93 56 0f 	sts	0x0F56, r23
    6516:	80 93 57 0f 	sts	0x0F57, r24
    651a:	90 93 58 0f 	sts	0x0F58, r25
  IpMyConfig.netmask = netmask;
    651e:	20 93 59 0f 	sts	0x0F59, r18
    6522:	30 93 5a 0f 	sts	0x0F5A, r19
    6526:	40 93 5b 0f 	sts	0x0F5B, r20
    652a:	50 93 5c 0f 	sts	0x0F5C, r21
  IpMyConfig.gateway = gatewayIp;
    652e:	e0 92 5d 0f 	sts	0x0F5D, r14
    6532:	f0 92 5e 0f 	sts	0x0F5E, r15
    6536:	00 93 5f 0f 	sts	0x0F5F, r16
    653a:	10 93 60 0f 	sts	0x0F60, r17
}
    653e:	1f 91       	pop	r17
    6540:	0f 91       	pop	r16
    6542:	ff 90       	pop	r15
    6544:	ef 90       	pop	r14
    6546:	08 95       	ret

00006548 <ipSetConfigIp>:

void ipSetConfigIp(uint32_t myIp)
{
  // set local addressing
  IpMyConfig.ip = myIp; 
    6548:	60 93 55 0f 	sts	0x0F55, r22
    654c:	70 93 56 0f 	sts	0x0F56, r23
    6550:	80 93 57 0f 	sts	0x0F57, r24
    6554:	90 93 58 0f 	sts	0x0F58, r25
}
    6558:	08 95       	ret

0000655a <ipSetConfigMask>:

void ipSetConfigMask(uint32_t netmask)
{
  IpMyConfig.netmask = netmask;
    655a:	60 93 59 0f 	sts	0x0F59, r22
    655e:	70 93 5a 0f 	sts	0x0F5A, r23
    6562:	80 93 5b 0f 	sts	0x0F5B, r24
    6566:	90 93 5c 0f 	sts	0x0F5C, r25
}
    656a:	08 95       	ret

0000656c <ipSetConfigGw>:

void ipSetConfigGw(uint32_t gatewayIp)
{
  IpMyConfig.gateway = gatewayIp;
    656c:	60 93 5d 0f 	sts	0x0F5D, r22
    6570:	70 93 5e 0f 	sts	0x0F5E, r23
    6574:	80 93 5f 0f 	sts	0x0F5F, r24
    6578:	90 93 60 0f 	sts	0x0F60, r25
}
    657c:	08 95       	ret

0000657e <ipGetConfig>:


struct ipConfig* ipGetConfig(void)
{
  return &IpMyConfig;
}
    657e:	85 e5       	ldi	r24, 0x55	; 85
    6580:	9f e0       	ldi	r25, 0x0F	; 15
    6582:	08 95       	ret

00006584 <ipPrintConfig>:
// send it
  nicSend(len);
}

void ipPrintConfig(FILE *stream, struct ipConfig* config)
{
    6584:	ef 92       	push	r14
    6586:	ff 92       	push	r15
    6588:	0f 93       	push	r16
    658a:	1f 93       	push	r17
    658c:	8c 01       	movw	r16, r24
    658e:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("IP Addr : ")); netPrintIPAddr(stream, config->ip);        fprintf_P(stream, PSTR("\r\n"));
    6590:	00 d0       	rcall	.+0      	; 0x6592 <ipPrintConfig+0xe>
    6592:	00 d0       	rcall	.+0      	; 0x6594 <ipPrintConfig+0x10>
    6594:	ed b7       	in	r30, 0x3d	; 61
    6596:	fe b7       	in	r31, 0x3e	; 62
    6598:	92 83       	std	Z+2, r25	; 0x02
    659a:	81 83       	std	Z+1, r24	; 0x01
    659c:	83 ee       	ldi	r24, 0xE3	; 227
    659e:	9d e0       	ldi	r25, 0x0D	; 13
    65a0:	94 83       	std	Z+4, r25	; 0x04
    65a2:	83 83       	std	Z+3, r24	; 0x03
    65a4:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    65a8:	0f 90       	pop	r0
    65aa:	0f 90       	pop	r0
    65ac:	0f 90       	pop	r0
    65ae:	0f 90       	pop	r0
    65b0:	f7 01       	movw	r30, r14
    65b2:	40 81       	ld	r20, Z
    65b4:	51 81       	ldd	r21, Z+1	; 0x01
    65b6:	62 81       	ldd	r22, Z+2	; 0x02
    65b8:	73 81       	ldd	r23, Z+3	; 0x03
    65ba:	c8 01       	movw	r24, r16
    65bc:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    65c0:	00 d0       	rcall	.+0      	; 0x65c2 <ipPrintConfig+0x3e>
    65c2:	00 d0       	rcall	.+0      	; 0x65c4 <ipPrintConfig+0x40>
    65c4:	ed b7       	in	r30, 0x3d	; 61
    65c6:	fe b7       	in	r31, 0x3e	; 62
    65c8:	12 83       	std	Z+2, r17	; 0x02
    65ca:	01 83       	std	Z+1, r16	; 0x01
    65cc:	80 ee       	ldi	r24, 0xE0	; 224
    65ce:	9d e0       	ldi	r25, 0x0D	; 13
    65d0:	94 83       	std	Z+4, r25	; 0x04
    65d2:	83 83       	std	Z+3, r24	; 0x03
    65d4:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Netmask : ")); netPrintIPAddr(stream, config->netmask);   fprintf_P(stream, PSTR("\r\n"));
    65d8:	ed b7       	in	r30, 0x3d	; 61
    65da:	fe b7       	in	r31, 0x3e	; 62
    65dc:	12 83       	std	Z+2, r17	; 0x02
    65de:	01 83       	std	Z+1, r16	; 0x01
    65e0:	85 ed       	ldi	r24, 0xD5	; 213
    65e2:	9d e0       	ldi	r25, 0x0D	; 13
    65e4:	94 83       	std	Z+4, r25	; 0x04
    65e6:	83 83       	std	Z+3, r24	; 0x03
    65e8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    65ec:	0f 90       	pop	r0
    65ee:	0f 90       	pop	r0
    65f0:	0f 90       	pop	r0
    65f2:	0f 90       	pop	r0
    65f4:	f7 01       	movw	r30, r14
    65f6:	44 81       	ldd	r20, Z+4	; 0x04
    65f8:	55 81       	ldd	r21, Z+5	; 0x05
    65fa:	66 81       	ldd	r22, Z+6	; 0x06
    65fc:	77 81       	ldd	r23, Z+7	; 0x07
    65fe:	c8 01       	movw	r24, r16
    6600:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    6604:	00 d0       	rcall	.+0      	; 0x6606 <ipPrintConfig+0x82>
    6606:	00 d0       	rcall	.+0      	; 0x6608 <ipPrintConfig+0x84>
    6608:	ed b7       	in	r30, 0x3d	; 61
    660a:	fe b7       	in	r31, 0x3e	; 62
    660c:	12 83       	std	Z+2, r17	; 0x02
    660e:	01 83       	std	Z+1, r16	; 0x01
    6610:	82 ed       	ldi	r24, 0xD2	; 210
    6612:	9d e0       	ldi	r25, 0x0D	; 13
    6614:	94 83       	std	Z+4, r25	; 0x04
    6616:	83 83       	std	Z+3, r24	; 0x03
    6618:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("Gateway : ")); netPrintIPAddr(stream, config->gateway);   fprintf_P(stream, PSTR("\r\n"));
    661c:	ed b7       	in	r30, 0x3d	; 61
    661e:	fe b7       	in	r31, 0x3e	; 62
    6620:	12 83       	std	Z+2, r17	; 0x02
    6622:	01 83       	std	Z+1, r16	; 0x01
    6624:	87 ec       	ldi	r24, 0xC7	; 199
    6626:	9d e0       	ldi	r25, 0x0D	; 13
    6628:	94 83       	std	Z+4, r25	; 0x04
    662a:	83 83       	std	Z+3, r24	; 0x03
    662c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6630:	0f 90       	pop	r0
    6632:	0f 90       	pop	r0
    6634:	0f 90       	pop	r0
    6636:	0f 90       	pop	r0
    6638:	f7 01       	movw	r30, r14
    663a:	40 85       	ldd	r20, Z+8	; 0x08
    663c:	51 85       	ldd	r21, Z+9	; 0x09
    663e:	62 85       	ldd	r22, Z+10	; 0x0a
    6640:	73 85       	ldd	r23, Z+11	; 0x0b
    6642:	c8 01       	movw	r24, r16
    6644:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    6648:	00 d0       	rcall	.+0      	; 0x664a <ipPrintConfig+0xc6>
    664a:	00 d0       	rcall	.+0      	; 0x664c <ipPrintConfig+0xc8>
    664c:	ed b7       	in	r30, 0x3d	; 61
    664e:	fe b7       	in	r31, 0x3e	; 62
    6650:	12 83       	std	Z+2, r17	; 0x02
    6652:	01 83       	std	Z+1, r16	; 0x01
    6654:	84 ec       	ldi	r24, 0xC4	; 196
    6656:	9d e0       	ldi	r25, 0x0D	; 13
    6658:	94 83       	std	Z+4, r25	; 0x04
    665a:	83 83       	std	Z+3, r24	; 0x03
    665c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6660:	0f 90       	pop	r0
    6662:	0f 90       	pop	r0
    6664:	0f 90       	pop	r0
    6666:	0f 90       	pop	r0
}
    6668:	1f 91       	pop	r17
    666a:	0f 91       	pop	r16
    666c:	ff 90       	pop	r15
    666e:	ef 90       	pop	r14
    6670:	08 95       	ret

00006672 <ipSend>:
{
  return &IpMyConfig;
}

void ipSend(uint32_t dstIp, uint8_t protocol, uint16_t len)
{
    6672:	bf 92       	push	r11
    6674:	cf 92       	push	r12
    6676:	df 92       	push	r13
    6678:	ef 92       	push	r14
    667a:	ff 92       	push	r15
    667c:	0f 93       	push	r16
    667e:	1f 93       	push	r17
    6680:	cf 93       	push	r28
    6682:	df 93       	push	r29
    6684:	6b 01       	movw	r12, r22
    6686:	7c 01       	movw	r14, r24
    6688:	b4 2e       	mov	r11, r20
    668a:	e9 01       	movw	r28, r18
// make pointer to ethernet/IP header
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    668c:	20 91 61 0f 	lds	r18, 0x0F61
    6690:	30 91 62 0f 	lds	r19, 0x0F62
    6694:	21 15       	cp	r18, r1
    6696:	31 05       	cpc	r19, r1
    6698:	a1 f0       	breq	.+40     	; 0x66c2 <ipSend+0x50>
  {  
    if (IpMyConfig.dbgLevel > 2)
    669a:	80 91 63 0f 	lds	r24, 0x0F63
    669e:	83 30       	cpi	r24, 0x03	; 3
    66a0:	80 f0       	brcs	.+32     	; 0x66c2 <ipSend+0x50>
      fprintf_P(IpMyConfig.dbgStream, "Sending Ip packet\r\n");
    66a2:	00 d0       	rcall	.+0      	; 0x66a4 <ipSend+0x32>
    66a4:	00 d0       	rcall	.+0      	; 0x66a6 <ipSend+0x34>
    66a6:	ed b7       	in	r30, 0x3d	; 61
    66a8:	fe b7       	in	r31, 0x3e	; 62
    66aa:	32 83       	std	Z+2, r19	; 0x02
    66ac:	21 83       	std	Z+1, r18	; 0x01
    66ae:	8b e4       	ldi	r24, 0x4B	; 75
    66b0:	91 e0       	ldi	r25, 0x01	; 1
    66b2:	94 83       	std	Z+4, r25	; 0x04
    66b4:	83 83       	std	Z+3, r24	; 0x03
    66b6:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    66ba:	0f 90       	pop	r0
    66bc:	0f 90       	pop	r0
    66be:	0f 90       	pop	r0
    66c0:	0f 90       	pop	r0
  }
#endif

// adjust length to add IP header
  len += IP_HEADER_LEN;
    66c2:	64 96       	adiw	r28, 0x14	; 20

// fill IP header
  nicState.layer3.ip->destipaddr = dstIp;
    66c4:	00 91 88 0e 	lds	r16, 0x0E88
    66c8:	10 91 89 0e 	lds	r17, 0x0E89
    66cc:	f8 01       	movw	r30, r16
    66ce:	c0 8a       	std	Z+16, r12	; 0x10
    66d0:	d1 8a       	std	Z+17, r13	; 0x11
    66d2:	e2 8a       	std	Z+18, r14	; 0x12
    66d4:	f3 8a       	std	Z+19, r15	; 0x13
  nicState.layer3.ip->srcipaddr  = IpMyConfig.ip;
    66d6:	80 91 55 0f 	lds	r24, 0x0F55
    66da:	90 91 56 0f 	lds	r25, 0x0F56
    66de:	a0 91 57 0f 	lds	r26, 0x0F57
    66e2:	b0 91 58 0f 	lds	r27, 0x0F58
    66e6:	84 87       	std	Z+12, r24	; 0x0c
    66e8:	95 87       	std	Z+13, r25	; 0x0d
    66ea:	a6 87       	std	Z+14, r26	; 0x0e
    66ec:	b7 87       	std	Z+15, r27	; 0x0f
  nicState.layer3.ip->proto      = protocol;
    66ee:	b1 86       	std	Z+9, r11	; 0x09
  nicState.layer3.ip->len        = htons(len);
    66f0:	ce 01       	movw	r24, r28
    66f2:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    66f6:	f8 01       	movw	r30, r16
    66f8:	93 83       	std	Z+3, r25	; 0x03
    66fa:	82 83       	std	Z+2, r24	; 0x02
  nicState.layer3.ip->vhl        = 0x45;
    66fc:	e0 91 88 0e 	lds	r30, 0x0E88
    6700:	f0 91 89 0e 	lds	r31, 0x0E89
    6704:	85 e4       	ldi	r24, 0x45	; 69
    6706:	80 83       	st	Z, r24
  nicState.layer3.ip->tos        = 0;
    6708:	e0 91 88 0e 	lds	r30, 0x0E88
    670c:	f0 91 89 0e 	lds	r31, 0x0E89
    6710:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ip->ipid       = 0;
    6712:	e0 91 88 0e 	lds	r30, 0x0E88
    6716:	f0 91 89 0e 	lds	r31, 0x0E89
    671a:	15 82       	std	Z+5, r1	; 0x05
    671c:	14 82       	std	Z+4, r1	; 0x04
  nicState.layer3.ip->ipoffset   = 0;
    671e:	17 82       	std	Z+7, r1	; 0x07
    6720:	16 82       	std	Z+6, r1	; 0x06
  nicState.layer3.ip->ttl        = IP_TIME_TO_LIVE;
    6722:	80 e8       	ldi	r24, 0x80	; 128
    6724:	80 87       	std	Z+8, r24	; 0x08
  nicState.layer3.ip->ipchksum   = 0;
    6726:	13 86       	std	Z+11, r1	; 0x0b
    6728:	12 86       	std	Z+10, r1	; 0x0a

// calculate and apply IP checksum
// DO THIS ONLY AFTER ALL CHANGES HAVE BEEN MADE TO IP HEADER
  nicState.layer3.ip->ipchksum   = netChecksum((uint8_t *)(nicState.layer3.ip), IP_HEADER_LEN);
    672a:	00 91 88 0e 	lds	r16, 0x0E88
    672e:	10 91 89 0e 	lds	r17, 0x0E89
    6732:	c8 01       	movw	r24, r16
    6734:	64 e1       	ldi	r22, 0x14	; 20
    6736:	70 e0       	ldi	r23, 0x00	; 0
    6738:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <netChecksum>
    673c:	f8 01       	movw	r30, r16
    673e:	93 87       	std	Z+11, r25	; 0x0b
    6740:	82 87       	std	Z+10, r24	; 0x0a

// add ethernet routing
// check if we need to send to gateway
  if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    6742:	20 91 55 0f 	lds	r18, 0x0F55
    6746:	30 91 56 0f 	lds	r19, 0x0F56
    674a:	40 91 57 0f 	lds	r20, 0x0F57
    674e:	50 91 58 0f 	lds	r21, 0x0F58
    6752:	2c 25       	eor	r18, r12
    6754:	3d 25       	eor	r19, r13
    6756:	4e 25       	eor	r20, r14
    6758:	5f 25       	eor	r21, r15
    675a:	80 91 59 0f 	lds	r24, 0x0F59
    675e:	90 91 5a 0f 	lds	r25, 0x0F5A
    6762:	a0 91 5b 0f 	lds	r26, 0x0F5B
    6766:	b0 91 5c 0f 	lds	r27, 0x0F5C
    676a:	82 23       	and	r24, r18
    676c:	93 23       	and	r25, r19
    676e:	a4 23       	and	r26, r20
    6770:	b5 23       	and	r27, r21
    6772:	00 97       	sbiw	r24, 0x00	; 0
    6774:	a1 05       	cpc	r26, r1
    6776:	b1 05       	cpc	r27, r1
    6778:	a9 f4       	brne	.+42     	; 0x67a4 <ipSend+0x132>
  {
    arpIpOut(0);  // local send
    677a:	60 e0       	ldi	r22, 0x00	; 0
    677c:	70 e0       	ldi	r23, 0x00	; 0
    677e:	80 e0       	ldi	r24, 0x00	; 0
    6780:	90 e0       	ldi	r25, 0x00	; 0
    6782:	0e 94 cd 39 	call	0x739a	; 0x739a <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6786:	80 91 61 0f 	lds	r24, 0x0F61
    678a:	90 91 62 0f 	lds	r25, 0x0F62
    678e:	00 97       	sbiw	r24, 0x00	; 0
    6790:	49 f1       	breq	.+82     	; 0x67e4 <ipSend+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet on local net\r\n"));
    6792:	00 d0       	rcall	.+0      	; 0x6794 <ipSend+0x122>
    6794:	00 d0       	rcall	.+0      	; 0x6796 <ipSend+0x124>
    6796:	ed b7       	in	r30, 0x3d	; 61
    6798:	fe b7       	in	r31, 0x3e	; 62
    679a:	92 83       	std	Z+2, r25	; 0x02
    679c:	81 83       	std	Z+1, r24	; 0x01
    679e:	8a e7       	ldi	r24, 0x7A	; 122
    67a0:	9e e0       	ldi	r25, 0x0E	; 14
    67a2:	18 c0       	rjmp	.+48     	; 0x67d4 <ipSend+0x162>
#endif
  }
  else
  {
    arpIpOut(IpMyConfig.gateway);  // gateway send
    67a4:	60 91 5d 0f 	lds	r22, 0x0F5D
    67a8:	70 91 5e 0f 	lds	r23, 0x0F5E
    67ac:	80 91 5f 0f 	lds	r24, 0x0F5F
    67b0:	90 91 60 0f 	lds	r25, 0x0F60
    67b4:	0e 94 cd 39 	call	0x739a	; 0x739a <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    67b8:	80 91 61 0f 	lds	r24, 0x0F61
    67bc:	90 91 62 0f 	lds	r25, 0x0F62
    67c0:	00 97       	sbiw	r24, 0x00	; 0
    67c2:	81 f0       	breq	.+32     	; 0x67e4 <ipSend+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet to gateway\r\n"));
    67c4:	00 d0       	rcall	.+0      	; 0x67c6 <ipSend+0x154>
    67c6:	00 d0       	rcall	.+0      	; 0x67c8 <ipSend+0x156>
    67c8:	ed b7       	in	r30, 0x3d	; 61
    67ca:	fe b7       	in	r31, 0x3e	; 62
    67cc:	92 83       	std	Z+2, r25	; 0x02
    67ce:	81 83       	std	Z+1, r24	; 0x01
    67d0:	8b e5       	ldi	r24, 0x5B	; 91
    67d2:	9e e0       	ldi	r25, 0x0E	; 14
    67d4:	94 83       	std	Z+4, r25	; 0x04
    67d6:	83 83       	std	Z+3, r24	; 0x03
    67d8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    67dc:	0f 90       	pop	r0
    67de:	0f 90       	pop	r0
    67e0:	0f 90       	pop	r0
    67e2:	0f 90       	pop	r0

// adjust length to add ethernet header
  len += ETH_HEADER_LEN;

#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    67e4:	20 91 61 0f 	lds	r18, 0x0F61
    67e8:	30 91 62 0f 	lds	r19, 0x0F62
    67ec:	21 15       	cp	r18, r1
    67ee:	31 05       	cpc	r19, r1
    67f0:	11 f1       	breq	.+68     	; 0x6836 <ipSend+0x1c4>
  {
    if (IpMyConfig.dbgLevel > 3)
    67f2:	80 91 63 0f 	lds	r24, 0x0F63
    67f6:	84 30       	cpi	r24, 0x04	; 4
    67f8:	f0 f0       	brcs	.+60     	; 0x6836 <ipSend+0x1c4>
    {
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(ETH_HEADER_LEN, &data[0]);"));
    67fa:	00 d0       	rcall	.+0      	; 0x67fc <ipSend+0x18a>
    67fc:	00 d0       	rcall	.+0      	; 0x67fe <ipSend+0x18c>
    67fe:	ed b7       	in	r30, 0x3d	; 61
    6800:	fe b7       	in	r31, 0x3e	; 62
    6802:	32 83       	std	Z+2, r19	; 0x02
    6804:	21 83       	std	Z+1, r18	; 0x01
    6806:	8d e2       	ldi	r24, 0x2D	; 45
    6808:	9e e0       	ldi	r25, 0x0E	; 14
    680a:	94 83       	std	Z+4, r25	; 0x04
    680c:	83 83       	std	Z+3, r24	; 0x03
    680e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    6812:	80 91 61 0f 	lds	r24, 0x0F61
    6816:	90 91 62 0f 	lds	r25, 0x0F62
    681a:	ed b7       	in	r30, 0x3d	; 61
    681c:	fe b7       	in	r31, 0x3e	; 62
    681e:	92 83       	std	Z+2, r25	; 0x02
    6820:	81 83       	std	Z+1, r24	; 0x01
    6822:	8e ee       	ldi	r24, 0xEE	; 238
    6824:	9d e0       	ldi	r25, 0x0D	; 13
    6826:	94 83       	std	Z+4, r25	; 0x04
    6828:	83 83       	std	Z+3, r24	; 0x03
    682a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    682e:	0f 90       	pop	r0
    6830:	0f 90       	pop	r0
    6832:	0f 90       	pop	r0
    6834:	0f 90       	pop	r0
    }
  }
#endif
// send it
  nicSend(len);
    6836:	ce 01       	movw	r24, r28
    6838:	0e 96       	adiw	r24, 0x0e	; 14
    683a:	0e 94 be 2c 	call	0x597c	; 0x597c <nicSend>
}
    683e:	df 91       	pop	r29
    6840:	cf 91       	pop	r28
    6842:	1f 91       	pop	r17
    6844:	0f 91       	pop	r16
    6846:	ff 90       	pop	r15
    6848:	ef 90       	pop	r14
    684a:	df 90       	pop	r13
    684c:	cf 90       	pop	r12
    684e:	bf 90       	pop	r11
    6850:	08 95       	ret

00006852 <netstackIPv4Process>:
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
}

inline void netstackIPv4Process(void)
{
    6852:	ef 92       	push	r14
    6854:	ff 92       	push	r15
    6856:	0f 93       	push	r16
    6858:	1f 93       	push	r17
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    685a:	e0 91 88 0e 	lds	r30, 0x0E88
    685e:	f0 91 89 0e 	lds	r31, 0x0E89
    6862:	e0 88       	ldd	r14, Z+16	; 0x10
    6864:	f1 88       	ldd	r15, Z+17	; 0x11
    6866:	02 89       	ldd	r16, Z+18	; 0x12
    6868:	13 89       	ldd	r17, Z+19	; 0x13
    686a:	20 91 55 0f 	lds	r18, 0x0F55
    686e:	30 91 56 0f 	lds	r19, 0x0F56
    6872:	40 91 57 0f 	lds	r20, 0x0F57
    6876:	50 91 58 0f 	lds	r21, 0x0F58
    687a:	e2 16       	cp	r14, r18
    687c:	f3 06       	cpc	r15, r19
    687e:	04 07       	cpc	r16, r20
    6880:	15 07       	cpc	r17, r21
    6882:	d9 f0       	breq	.+54     	; 0x68ba <netstackIPv4Process+0x68>
    6884:	80 91 59 0f 	lds	r24, 0x0F59
    6888:	90 91 5a 0f 	lds	r25, 0x0F5A
    688c:	a0 91 5b 0f 	lds	r26, 0x0F5B
    6890:	b0 91 5c 0f 	lds	r27, 0x0F5C
    6894:	28 2b       	or	r18, r24
    6896:	39 2b       	or	r19, r25
    6898:	4a 2b       	or	r20, r26
    689a:	5b 2b       	or	r21, r27
    689c:	e2 16       	cp	r14, r18
    689e:	f3 06       	cpc	r15, r19
    68a0:	04 07       	cpc	r16, r20
    68a2:	15 07       	cpc	r17, r21
    68a4:	51 f0       	breq	.+20     	; 0x68ba <netstackIPv4Process+0x68>
    68a6:	8f ef       	ldi	r24, 0xFF	; 255
    68a8:	e8 16       	cp	r14, r24
    68aa:	8f ef       	ldi	r24, 0xFF	; 255
    68ac:	f8 06       	cpc	r15, r24
    68ae:	8f ef       	ldi	r24, 0xFF	; 255
    68b0:	08 07       	cpc	r16, r24
    68b2:	8f ef       	ldi	r24, 0xFF	; 255
    68b4:	18 07       	cpc	r17, r24
    68b6:	09 f0       	breq	.+2      	; 0x68ba <netstackIPv4Process+0x68>
    68b8:	8e c0       	rjmp	.+284    	; 0x69d6 <netstackIPv4Process+0x184>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
      (nicState.layer3.ip->destipaddr != 0xFFFFFFFF)) 
    return;

// handle ICMP packet
  if(nicState.layer3.ip->proto == IP_PROTO_ICMP)
    68ba:	81 85       	ldd	r24, Z+9	; 0x09
    68bc:	81 30       	cpi	r24, 0x01	; 1
    68be:	81 f5       	brne	.+96     	; 0x6920 <netstackIPv4Process+0xce>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    68c0:	20 91 61 0f 	lds	r18, 0x0F61
    68c4:	30 91 62 0f 	lds	r19, 0x0F62
    68c8:	21 15       	cp	r18, r1
    68ca:	31 05       	cpc	r19, r1
    68cc:	31 f1       	breq	.+76     	; 0x691a <netstackIPv4Process+0xc8>
    {
      if (IpMyConfig.dbgLevel > 0)
    68ce:	80 91 63 0f 	lds	r24, 0x0F63
    68d2:	88 23       	and	r24, r24
    68d4:	81 f0       	breq	.+32     	; 0x68f6 <netstackIPv4Process+0xa4>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
    68d6:	00 d0       	rcall	.+0      	; 0x68d8 <netstackIPv4Process+0x86>
    68d8:	00 d0       	rcall	.+0      	; 0x68da <netstackIPv4Process+0x88>
    68da:	ed b7       	in	r30, 0x3d	; 61
    68dc:	fe b7       	in	r31, 0x3e	; 62
    68de:	32 83       	std	Z+2, r19	; 0x02
    68e0:	21 83       	std	Z+1, r18	; 0x01
    68e2:	87 ee       	ldi	r24, 0xE7	; 231
    68e4:	9e e0       	ldi	r25, 0x0E	; 14
    68e6:	94 83       	std	Z+4, r25	; 0x04
    68e8:	83 83       	std	Z+3, r24	; 0x03
    68ea:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    68ee:	0f 90       	pop	r0
    68f0:	0f 90       	pop	r0
    68f2:	0f 90       	pop	r0
    68f4:	0f 90       	pop	r0
      if (IpMyConfig.dbgLevel > 2)
    68f6:	80 91 63 0f 	lds	r24, 0x0F63
    68fa:	83 30       	cpi	r24, 0x03	; 3
    68fc:	70 f0       	brcs	.+28     	; 0x691a <netstackIPv4Process+0xc8>
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    68fe:	60 91 88 0e 	lds	r22, 0x0E88
    6902:	70 91 89 0e 	lds	r23, 0x0E89
    6906:	40 91 8a 0e 	lds	r20, 0x0E8A
    690a:	50 91 8b 0e 	lds	r21, 0x0E8B
    690e:	80 91 61 0f 	lds	r24, 0x0F61
    6912:	90 91 62 0f 	lds	r25, 0x0F62
    6916:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <icmpPrintHeader>
    }
#endif /*IP_DEBUG*/
    icmpIpIn();
    691a:	0e 94 ac 36 	call	0x6d58	; 0x6d58 <icmpIpIn>
    691e:	5b c0       	rjmp	.+182    	; 0x69d6 <netstackIPv4Process+0x184>
    return;
  }
  if( nicState.layer3.ip->proto == IP_PROTO_UDP )
    6920:	81 31       	cpi	r24, 0x11	; 17
    6922:	f1 f4       	brne	.+60     	; 0x6960 <netstackIPv4Process+0x10e>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6924:	20 91 61 0f 	lds	r18, 0x0F61
    6928:	30 91 62 0f 	lds	r19, 0x0F62
    692c:	21 15       	cp	r18, r1
    692e:	31 05       	cpc	r19, r1
    6930:	a1 f0       	breq	.+40     	; 0x695a <netstackIPv4Process+0x108>
    {
      if (IpMyConfig.dbgLevel > 0)
    6932:	80 91 63 0f 	lds	r24, 0x0F63
    6936:	88 23       	and	r24, r24
    6938:	81 f0       	breq	.+32     	; 0x695a <netstackIPv4Process+0x108>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    693a:	00 d0       	rcall	.+0      	; 0x693c <netstackIPv4Process+0xea>
    693c:	00 d0       	rcall	.+0      	; 0x693e <netstackIPv4Process+0xec>
    693e:	ed b7       	in	r30, 0x3d	; 61
    6940:	fe b7       	in	r31, 0x3e	; 62
    6942:	32 83       	std	Z+2, r19	; 0x02
    6944:	21 83       	std	Z+1, r18	; 0x01
    6946:	8f ec       	ldi	r24, 0xCF	; 207
    6948:	9e e0       	ldi	r25, 0x0E	; 14
    694a:	94 83       	std	Z+4, r25	; 0x04
    694c:	83 83       	std	Z+3, r24	; 0x03
    694e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6952:	0f 90       	pop	r0
    6954:	0f 90       	pop	r0
    6956:	0f 90       	pop	r0
    6958:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackUDPIPProcess();
    695a:	0e 94 9d 3e 	call	0x7d3a	; 0x7d3a <netstackUDPIPProcess>
    695e:	3b c0       	rjmp	.+118    	; 0x69d6 <netstackIPv4Process+0x184>
    return;
  }
  if( nicState.layer3.ip->proto == IP_PROTO_TCP )
    6960:	86 30       	cpi	r24, 0x06	; 6
    6962:	f1 f4       	brne	.+60     	; 0x69a0 <netstackIPv4Process+0x14e>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6964:	20 91 61 0f 	lds	r18, 0x0F61
    6968:	30 91 62 0f 	lds	r19, 0x0F62
    696c:	21 15       	cp	r18, r1
    696e:	31 05       	cpc	r19, r1
    6970:	a1 f0       	breq	.+40     	; 0x699a <netstackIPv4Process+0x148>
    {
      if (IpMyConfig.dbgLevel > 0)
    6972:	80 91 63 0f 	lds	r24, 0x0F63
    6976:	88 23       	and	r24, r24
    6978:	81 f0       	breq	.+32     	; 0x699a <netstackIPv4Process+0x148>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: TCP/IP packet\r\n"));
    697a:	00 d0       	rcall	.+0      	; 0x697c <netstackIPv4Process+0x12a>
    697c:	00 d0       	rcall	.+0      	; 0x697e <netstackIPv4Process+0x12c>
    697e:	ed b7       	in	r30, 0x3d	; 61
    6980:	fe b7       	in	r31, 0x3e	; 62
    6982:	32 83       	std	Z+2, r19	; 0x02
    6984:	21 83       	std	Z+1, r18	; 0x01
    6986:	87 eb       	ldi	r24, 0xB7	; 183
    6988:	9e e0       	ldi	r25, 0x0E	; 14
    698a:	94 83       	std	Z+4, r25	; 0x04
    698c:	83 83       	std	Z+3, r24	; 0x03
    698e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6992:	0f 90       	pop	r0
    6994:	0f 90       	pop	r0
    6996:	0f 90       	pop	r0
    6998:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackTCPIPProcess();
    699a:	0e 94 6b 3d 	call	0x7ad6	; 0x7ad6 <netstackTCPIPProcess>
    699e:	1b c0       	rjmp	.+54     	; 0x69d6 <netstackIPv4Process+0x184>
    return;
  }
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    69a0:	20 91 61 0f 	lds	r18, 0x0F61
    69a4:	30 91 62 0f 	lds	r19, 0x0F62
    69a8:	21 15       	cp	r18, r1
    69aa:	31 05       	cpc	r19, r1
    69ac:	a1 f0       	breq	.+40     	; 0x69d6 <netstackIPv4Process+0x184>
  {
    if (IpMyConfig.dbgLevel > 0)
    69ae:	80 91 63 0f 	lds	r24, 0x0F63
    69b2:	88 23       	and	r24, r24
    69b4:	81 f0       	breq	.+32     	; 0x69d6 <netstackIPv4Process+0x184>
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
    69b6:	00 d0       	rcall	.+0      	; 0x69b8 <netstackIPv4Process+0x166>
    69b8:	00 d0       	rcall	.+0      	; 0x69ba <netstackIPv4Process+0x168>
    69ba:	ed b7       	in	r30, 0x3d	; 61
    69bc:	fe b7       	in	r31, 0x3e	; 62
    69be:	32 83       	std	Z+2, r19	; 0x02
    69c0:	21 83       	std	Z+1, r18	; 0x01
    69c2:	8b e9       	ldi	r24, 0x9B	; 155
    69c4:	9e e0       	ldi	r25, 0x0E	; 14
    69c6:	94 83       	std	Z+4, r25	; 0x04
    69c8:	83 83       	std	Z+3, r24	; 0x03
    69ca:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    69ce:	0f 90       	pop	r0
    69d0:	0f 90       	pop	r0
    69d2:	0f 90       	pop	r0
    69d4:	0f 90       	pop	r0
  }
#endif /*IP_DEBUG*/
}
    69d6:	1f 91       	pop	r17
    69d8:	0f 91       	pop	r16
    69da:	ff 90       	pop	r15
    69dc:	ef 90       	pop	r14
    69de:	08 95       	ret

000069e0 <ipSaveConfig>:
#endif
}

void ipSaveConfig(void)
{
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
    69e0:	40 91 55 0f 	lds	r20, 0x0F55
    69e4:	50 91 56 0f 	lds	r21, 0x0F56
    69e8:	60 91 57 0f 	lds	r22, 0x0F57
    69ec:	70 91 58 0f 	lds	r23, 0x0F58
    69f0:	8e e1       	ldi	r24, 0x1E	; 30
    69f2:	90 e0       	ldi	r25, 0x00	; 0
    69f4:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <__eeupd_dword_m128>
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
    69f8:	40 91 59 0f 	lds	r20, 0x0F59
    69fc:	50 91 5a 0f 	lds	r21, 0x0F5A
    6a00:	60 91 5b 0f 	lds	r22, 0x0F5B
    6a04:	70 91 5c 0f 	lds	r23, 0x0F5C
    6a08:	82 e2       	ldi	r24, 0x22	; 34
    6a0a:	90 e0       	ldi	r25, 0x00	; 0
    6a0c:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <__eeupd_dword_m128>
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    6a10:	40 91 5d 0f 	lds	r20, 0x0F5D
    6a14:	50 91 5e 0f 	lds	r21, 0x0F5E
    6a18:	60 91 5f 0f 	lds	r22, 0x0F5F
    6a1c:	70 91 60 0f 	lds	r23, 0x0F60
    6a20:	86 e2       	ldi	r24, 0x26	; 38
    6a22:	90 e0       	ldi	r25, 0x00	; 0
    6a24:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <__eeupd_dword_m128>
}
    6a28:	08 95       	ret

00006a2a <ipInit>:
static uint32_t mask_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_MASK4 << 24) + ((uint32_t)MY_MASK3 <<16) + ((uint32_t)MY_MASK2 <<8) + MY_MASK1;
static uint32_t defGw_eep   __attribute__((section (".eeprom"))) = ((uint32_t)MY_GW4   << 24) + ((uint32_t)MY_GW3   <<16) + ((uint32_t)MY_GW2   <<8) + MY_GW1;

void ipInit(void)
{
  IpMyConfig.ip      = eeprom_read_dword(&myip_eep);
    6a2a:	8e e1       	ldi	r24, 0x1E	; 30
    6a2c:	90 e0       	ldi	r25, 0x00	; 0
    6a2e:	0e 94 cf 5f 	call	0xbf9e	; 0xbf9e <__eerd_dword_m128>
    6a32:	60 93 55 0f 	sts	0x0F55, r22
    6a36:	70 93 56 0f 	sts	0x0F56, r23
    6a3a:	80 93 57 0f 	sts	0x0F57, r24
    6a3e:	90 93 58 0f 	sts	0x0F58, r25
  IpMyConfig.netmask = eeprom_read_dword(&mask_eep);
    6a42:	82 e2       	ldi	r24, 0x22	; 34
    6a44:	90 e0       	ldi	r25, 0x00	; 0
    6a46:	0e 94 cf 5f 	call	0xbf9e	; 0xbf9e <__eerd_dword_m128>
    6a4a:	60 93 59 0f 	sts	0x0F59, r22
    6a4e:	70 93 5a 0f 	sts	0x0F5A, r23
    6a52:	80 93 5b 0f 	sts	0x0F5B, r24
    6a56:	90 93 5c 0f 	sts	0x0F5C, r25
  IpMyConfig.gateway = eeprom_read_dword(&defGw_eep);
    6a5a:	86 e2       	ldi	r24, 0x26	; 38
    6a5c:	90 e0       	ldi	r25, 0x00	; 0
    6a5e:	0e 94 cf 5f 	call	0xbf9e	; 0xbf9e <__eerd_dword_m128>
    6a62:	60 93 5d 0f 	sts	0x0F5D, r22
    6a66:	70 93 5e 0f 	sts	0x0F5E, r23
    6a6a:	80 93 5f 0f 	sts	0x0F5F, r24
    6a6e:	90 93 60 0f 	sts	0x0F60, r25
#if IP_DEBUG
  IpMyConfig.dbgLevel = 0;
    6a72:	10 92 63 0f 	sts	0x0F63, r1
  IpMyConfig.dbgStream = NULL;
    6a76:	10 92 62 0f 	sts	0x0F62, r1
    6a7a:	10 92 61 0f 	sts	0x0F61, r1
#endif
}
    6a7e:	08 95       	ret

00006a80 <icmpInit>:


// functions
void icmpInit(void)
{
  icmpDebug = NULL;
    6a80:	10 92 ab 0e 	sts	0x0EAB, r1
    6a84:	10 92 aa 0e 	sts	0x0EAA, r1
  icmpDebugLevel = 0;
    6a88:	10 92 52 0f 	sts	0x0F52, r1
}
    6a8c:	08 95       	ret

00006a8e <setIcmpDebug>:
}

#if ICMP_DEBUG
void setIcmpDebug(FILE *stream, uint8_t level)
{
  icmpDebug = stream;
    6a8e:	90 93 ab 0e 	sts	0x0EAB, r25
    6a92:	80 93 aa 0e 	sts	0x0EAA, r24
  icmpDebugLevel = level;
    6a96:	60 93 52 0f 	sts	0x0F52, r22
}
    6a9a:	08 95       	ret

00006a9c <icmpPrintHeader>:
#endif

void icmpPrintHeader(FILE *stream, struct netIpHeader *ipPacket, struct netIcmpHeader *icmpPacket)
{
    6a9c:	ef 92       	push	r14
    6a9e:	ff 92       	push	r15
    6aa0:	0f 93       	push	r16
    6aa2:	1f 93       	push	r17
    6aa4:	cf 93       	push	r28
    6aa6:	df 93       	push	r29
    6aa8:	ec 01       	movw	r28, r24
    6aaa:	8b 01       	movw	r16, r22
    6aac:	7a 01       	movw	r14, r20
  fprintf_P(stream, PSTR("ICMP Packet:\r\n"));
    6aae:	00 d0       	rcall	.+0      	; 0x6ab0 <icmpPrintHeader+0x14>
    6ab0:	00 d0       	rcall	.+0      	; 0x6ab2 <icmpPrintHeader+0x16>
    6ab2:	ad b7       	in	r26, 0x3d	; 61
    6ab4:	be b7       	in	r27, 0x3e	; 62
    6ab6:	12 96       	adiw	r26, 0x02	; 2
    6ab8:	9c 93       	st	X, r25
    6aba:	8e 93       	st	-X, r24
    6abc:	11 97       	sbiw	r26, 0x01	; 1
    6abe:	83 e5       	ldi	r24, 0x53	; 83
    6ac0:	9f e0       	ldi	r25, 0x0F	; 15
    6ac2:	14 96       	adiw	r26, 0x04	; 4
    6ac4:	9c 93       	st	X, r25
    6ac6:	8e 93       	st	-X, r24
    6ac8:	13 97       	sbiw	r26, 0x03	; 3
    6aca:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print source IP address
  fprintf_P(stream, PSTR("SrcIpAddr: "));  netPrintIPAddr(stream, ipPacket->srcipaddr);  fprintf_P(stream, PSTR("\r\n"));
    6ace:	ed b7       	in	r30, 0x3d	; 61
    6ad0:	fe b7       	in	r31, 0x3e	; 62
    6ad2:	d2 83       	std	Z+2, r29	; 0x02
    6ad4:	c1 83       	std	Z+1, r28	; 0x01
    6ad6:	87 e4       	ldi	r24, 0x47	; 71
    6ad8:	9f e0       	ldi	r25, 0x0F	; 15
    6ada:	94 83       	std	Z+4, r25	; 0x04
    6adc:	83 83       	std	Z+3, r24	; 0x03
    6ade:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6ae2:	0f 90       	pop	r0
    6ae4:	0f 90       	pop	r0
    6ae6:	0f 90       	pop	r0
    6ae8:	0f 90       	pop	r0
    6aea:	d8 01       	movw	r26, r16
    6aec:	1c 96       	adiw	r26, 0x0c	; 12
    6aee:	4d 91       	ld	r20, X+
    6af0:	5d 91       	ld	r21, X+
    6af2:	6d 91       	ld	r22, X+
    6af4:	7c 91       	ld	r23, X
    6af6:	1f 97       	sbiw	r26, 0x0f	; 15
    6af8:	ce 01       	movw	r24, r28
    6afa:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    6afe:	00 d0       	rcall	.+0      	; 0x6b00 <icmpPrintHeader+0x64>
    6b00:	00 d0       	rcall	.+0      	; 0x6b02 <icmpPrintHeader+0x66>
    6b02:	ed b7       	in	r30, 0x3d	; 61
    6b04:	fe b7       	in	r31, 0x3e	; 62
    6b06:	d2 83       	std	Z+2, r29	; 0x02
    6b08:	c1 83       	std	Z+1, r28	; 0x01
    6b0a:	84 e4       	ldi	r24, 0x44	; 68
    6b0c:	9f e0       	ldi	r25, 0x0F	; 15
    6b0e:	94 83       	std	Z+4, r25	; 0x04
    6b10:	83 83       	std	Z+3, r24	; 0x03
    6b12:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print dest IP address
  fprintf_P(stream, PSTR("DstIpAddr: "));  netPrintIPAddr(stream, ipPacket->destipaddr); fprintf_P(stream, PSTR("\r\n"));
    6b16:	ad b7       	in	r26, 0x3d	; 61
    6b18:	be b7       	in	r27, 0x3e	; 62
    6b1a:	12 96       	adiw	r26, 0x02	; 2
    6b1c:	dc 93       	st	X, r29
    6b1e:	ce 93       	st	-X, r28
    6b20:	11 97       	sbiw	r26, 0x01	; 1
    6b22:	88 e3       	ldi	r24, 0x38	; 56
    6b24:	9f e0       	ldi	r25, 0x0F	; 15
    6b26:	14 96       	adiw	r26, 0x04	; 4
    6b28:	9c 93       	st	X, r25
    6b2a:	8e 93       	st	-X, r24
    6b2c:	13 97       	sbiw	r26, 0x03	; 3
    6b2e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6b32:	0f 90       	pop	r0
    6b34:	0f 90       	pop	r0
    6b36:	0f 90       	pop	r0
    6b38:	0f 90       	pop	r0
    6b3a:	f8 01       	movw	r30, r16
    6b3c:	40 89       	ldd	r20, Z+16	; 0x10
    6b3e:	51 89       	ldd	r21, Z+17	; 0x11
    6b40:	62 89       	ldd	r22, Z+18	; 0x12
    6b42:	73 89       	ldd	r23, Z+19	; 0x13
    6b44:	ce 01       	movw	r24, r28
    6b46:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    6b4a:	00 d0       	rcall	.+0      	; 0x6b4c <icmpPrintHeader+0xb0>
    6b4c:	00 d0       	rcall	.+0      	; 0x6b4e <icmpPrintHeader+0xb2>
    6b4e:	ad b7       	in	r26, 0x3d	; 61
    6b50:	be b7       	in	r27, 0x3e	; 62
    6b52:	12 96       	adiw	r26, 0x02	; 2
    6b54:	dc 93       	st	X, r29
    6b56:	ce 93       	st	-X, r28
    6b58:	11 97       	sbiw	r26, 0x01	; 1
    6b5a:	85 e3       	ldi	r24, 0x35	; 53
    6b5c:	9f e0       	ldi	r25, 0x0F	; 15
    6b5e:	14 96       	adiw	r26, 0x04	; 4
    6b60:	9c 93       	st	X, r25
    6b62:	8e 93       	st	-X, r24
    6b64:	13 97       	sbiw	r26, 0x03	; 3
    6b66:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print type
  fprintf_P(stream, PSTR("Type   : "));
    6b6a:	ed b7       	in	r30, 0x3d	; 61
    6b6c:	fe b7       	in	r31, 0x3e	; 62
    6b6e:	d2 83       	std	Z+2, r29	; 0x02
    6b70:	c1 83       	std	Z+1, r28	; 0x01
    6b72:	8b e2       	ldi	r24, 0x2B	; 43
    6b74:	9f e0       	ldi	r25, 0x0F	; 15
    6b76:	94 83       	std	Z+4, r25	; 0x04
    6b78:	83 83       	std	Z+3, r24	; 0x03
    6b7a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  switch(icmpPacket->type)
    6b7e:	0f 90       	pop	r0
    6b80:	0f 90       	pop	r0
    6b82:	0f 90       	pop	r0
    6b84:	0f 90       	pop	r0
    6b86:	d7 01       	movw	r26, r14
    6b88:	8c 91       	ld	r24, X
    6b8a:	88 23       	and	r24, r24
    6b8c:	59 f0       	breq	.+22     	; 0x6ba4 <icmpPrintHeader+0x108>
    6b8e:	88 30       	cpi	r24, 0x08	; 8
    6b90:	c1 f4       	brne	.+48     	; 0x6bc2 <icmpPrintHeader+0x126>
  {
    case ICMP_TYPE_ECHOREQUEST:
      fprintf_P(stream, PSTR("ECHO REQUEST"));
    6b92:	00 d0       	rcall	.+0      	; 0x6b94 <icmpPrintHeader+0xf8>
    6b94:	00 d0       	rcall	.+0      	; 0x6b96 <icmpPrintHeader+0xfa>
    6b96:	ed b7       	in	r30, 0x3d	; 61
    6b98:	fe b7       	in	r31, 0x3e	; 62
    6b9a:	d2 83       	std	Z+2, r29	; 0x02
    6b9c:	c1 83       	std	Z+1, r28	; 0x01
    6b9e:	8e e1       	ldi	r24, 0x1E	; 30
    6ba0:	9f e0       	ldi	r25, 0x0F	; 15
    6ba2:	17 c0       	rjmp	.+46     	; 0x6bd2 <icmpPrintHeader+0x136>
      break;
    case ICMP_TYPE_ECHOREPLY:
      fprintf_P(stream, PSTR("ECHO REPLY"));
    6ba4:	00 d0       	rcall	.+0      	; 0x6ba6 <icmpPrintHeader+0x10a>
    6ba6:	00 d0       	rcall	.+0      	; 0x6ba8 <icmpPrintHeader+0x10c>
    6ba8:	ad b7       	in	r26, 0x3d	; 61
    6baa:	be b7       	in	r27, 0x3e	; 62
    6bac:	12 96       	adiw	r26, 0x02	; 2
    6bae:	dc 93       	st	X, r29
    6bb0:	ce 93       	st	-X, r28
    6bb2:	11 97       	sbiw	r26, 0x01	; 1
    6bb4:	83 e1       	ldi	r24, 0x13	; 19
    6bb6:	9f e0       	ldi	r25, 0x0F	; 15
    6bb8:	14 96       	adiw	r26, 0x04	; 4
    6bba:	9c 93       	st	X, r25
    6bbc:	8e 93       	st	-X, r24
    6bbe:	13 97       	sbiw	r26, 0x03	; 3
    6bc0:	0a c0       	rjmp	.+20     	; 0x6bd6 <icmpPrintHeader+0x13a>
      break;
    default:
      fprintf_P(stream, ("UNKNOWN"));
    6bc2:	00 d0       	rcall	.+0      	; 0x6bc4 <icmpPrintHeader+0x128>
    6bc4:	00 d0       	rcall	.+0      	; 0x6bc6 <icmpPrintHeader+0x12a>
    6bc6:	ed b7       	in	r30, 0x3d	; 61
    6bc8:	fe b7       	in	r31, 0x3e	; 62
    6bca:	d2 83       	std	Z+2, r29	; 0x02
    6bcc:	c1 83       	std	Z+1, r28	; 0x01
    6bce:	8f e5       	ldi	r24, 0x5F	; 95
    6bd0:	91 e0       	ldi	r25, 0x01	; 1
    6bd2:	94 83       	std	Z+4, r25	; 0x04
    6bd4:	83 83       	std	Z+3, r24	; 0x03
    6bd6:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      break;
  }
  fprintf_P(stream, PSTR("\r\n"));
    6bda:	ad b7       	in	r26, 0x3d	; 61
    6bdc:	be b7       	in	r27, 0x3e	; 62
    6bde:	12 96       	adiw	r26, 0x02	; 2
    6be0:	dc 93       	st	X, r29
    6be2:	ce 93       	st	-X, r28
    6be4:	11 97       	sbiw	r26, 0x01	; 1
    6be6:	80 e1       	ldi	r24, 0x10	; 16
    6be8:	9f e0       	ldi	r25, 0x0F	; 15
    6bea:	14 96       	adiw	r26, 0x04	; 4
    6bec:	9c 93       	st	X, r25
    6bee:	8e 93       	st	-X, r24
    6bf0:	13 97       	sbiw	r26, 0x03	; 3
    6bf2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print code
  fprintf_P(stream, PSTR("Code   : 0x%x\r\n"), icmpPacket->icode);
    6bf6:	00 d0       	rcall	.+0      	; 0x6bf8 <icmpPrintHeader+0x15c>
    6bf8:	ed b7       	in	r30, 0x3d	; 61
    6bfa:	fe b7       	in	r31, 0x3e	; 62
    6bfc:	31 96       	adiw	r30, 0x01	; 1
    6bfe:	ad b7       	in	r26, 0x3d	; 61
    6c00:	be b7       	in	r27, 0x3e	; 62
    6c02:	12 96       	adiw	r26, 0x02	; 2
    6c04:	dc 93       	st	X, r29
    6c06:	ce 93       	st	-X, r28
    6c08:	11 97       	sbiw	r26, 0x01	; 1
    6c0a:	80 e0       	ldi	r24, 0x00	; 0
    6c0c:	9f e0       	ldi	r25, 0x0F	; 15
    6c0e:	93 83       	std	Z+3, r25	; 0x03
    6c10:	82 83       	std	Z+2, r24	; 0x02
    6c12:	d7 01       	movw	r26, r14
    6c14:	11 96       	adiw	r26, 0x01	; 1
    6c16:	8c 91       	ld	r24, X
    6c18:	84 83       	std	Z+4, r24	; 0x04
    6c1a:	15 82       	std	Z+5, r1	; 0x05
    6c1c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6c20:	ed b7       	in	r30, 0x3d	; 61
    6c22:	fe b7       	in	r31, 0x3e	; 62
    6c24:	36 96       	adiw	r30, 0x06	; 6
    6c26:	0f b6       	in	r0, 0x3f	; 63
    6c28:	f8 94       	cli
    6c2a:	fe bf       	out	0x3e, r31	; 62
    6c2c:	0f be       	out	0x3f, r0	; 63
    6c2e:	ed bf       	out	0x3d, r30	; 61
}
    6c30:	df 91       	pop	r29
    6c32:	cf 91       	pop	r28
    6c34:	1f 91       	pop	r17
    6c36:	0f 91       	pop	r16
    6c38:	ff 90       	pop	r15
    6c3a:	ef 90       	pop	r14
    6c3c:	08 95       	ret

00006c3e <icmpEchoRequest>:
      break;
  }
}

void icmpEchoRequest(void)
{
    6c3e:	0f 93       	push	r16
    6c40:	1f 93       	push	r17
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6c42:	20 91 aa 0e 	lds	r18, 0x0EAA
    6c46:	30 91 ab 0e 	lds	r19, 0x0EAB
    6c4a:	21 15       	cp	r18, r1
    6c4c:	31 05       	cpc	r19, r1
    6c4e:	a1 f0       	breq	.+40     	; 0x6c78 <icmpEchoRequest+0x3a>
  {
    if (icmpDebugLevel > 1)
    6c50:	80 91 52 0f 	lds	r24, 0x0F52
    6c54:	82 30       	cpi	r24, 0x02	; 2
    6c56:	80 f0       	brcs	.+32     	; 0x6c78 <icmpEchoRequest+0x3a>
      fprintf_P(icmpDebug, PSTR("Received ICMP request: "));
    6c58:	00 d0       	rcall	.+0      	; 0x6c5a <icmpEchoRequest+0x1c>
    6c5a:	00 d0       	rcall	.+0      	; 0x6c5c <icmpEchoRequest+0x1e>
    6c5c:	ed b7       	in	r30, 0x3d	; 61
    6c5e:	fe b7       	in	r31, 0x3e	; 62
    6c60:	32 83       	std	Z+2, r19	; 0x02
    6c62:	21 83       	std	Z+1, r18	; 0x01
    6c64:	86 e7       	ldi	r24, 0x76	; 118
    6c66:	9f e0       	ldi	r25, 0x0F	; 15
    6c68:	94 83       	std	Z+4, r25	; 0x04
    6c6a:	83 83       	std	Z+3, r24	; 0x03
    6c6c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6c70:	0f 90       	pop	r0
    6c72:	0f 90       	pop	r0
    6c74:	0f 90       	pop	r0
    6c76:	0f 90       	pop	r0
  }
#endif
  uint32_t tempIp;

  // change type to reply
  nicState.layer4.icmp->type = ICMP_TYPE_ECHOREPLY;
    6c78:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6c7c:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6c80:	10 82       	st	Z, r1
  // recalculate checksum
  nicState.layer4.icmp->icmpchksum = 0;
    6c82:	00 91 8a 0e 	lds	r16, 0x0E8A
    6c86:	10 91 8b 0e 	lds	r17, 0x0E8B
    6c8a:	f8 01       	movw	r30, r16
    6c8c:	13 82       	std	Z+3, r1	; 0x03
    6c8e:	12 82       	std	Z+2, r1	; 0x02
  nicState.layer4.icmp->icmpchksum = netChecksum((uint8_t*)(nicState.layer4.icmp), htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
    6c90:	e0 91 88 0e 	lds	r30, 0x0E88
    6c94:	f0 91 89 0e 	lds	r31, 0x0E89
    6c98:	82 81       	ldd	r24, Z+2	; 0x02
    6c9a:	93 81       	ldd	r25, Z+3	; 0x03
    6c9c:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    6ca0:	bc 01       	movw	r22, r24
    6ca2:	64 51       	subi	r22, 0x14	; 20
    6ca4:	70 40       	sbci	r23, 0x00	; 0
    6ca6:	c8 01       	movw	r24, r16
    6ca8:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <netChecksum>
    6cac:	f8 01       	movw	r30, r16
    6cae:	93 83       	std	Z+3, r25	; 0x03
    6cb0:	82 83       	std	Z+2, r24	; 0x02
  // return to sender
  tempIp = nicState.layer3.ip->destipaddr;
    6cb2:	e0 91 88 0e 	lds	r30, 0x0E88
    6cb6:	f0 91 89 0e 	lds	r31, 0x0E89
    6cba:	20 89       	ldd	r18, Z+16	; 0x10
    6cbc:	31 89       	ldd	r19, Z+17	; 0x11
    6cbe:	42 89       	ldd	r20, Z+18	; 0x12
    6cc0:	53 89       	ldd	r21, Z+19	; 0x13
  nicState.layer3.ip->destipaddr = nicState.layer3.ip->srcipaddr;
    6cc2:	84 85       	ldd	r24, Z+12	; 0x0c
    6cc4:	95 85       	ldd	r25, Z+13	; 0x0d
    6cc6:	a6 85       	ldd	r26, Z+14	; 0x0e
    6cc8:	b7 85       	ldd	r27, Z+15	; 0x0f
    6cca:	80 8b       	std	Z+16, r24	; 0x10
    6ccc:	91 8b       	std	Z+17, r25	; 0x11
    6cce:	a2 8b       	std	Z+18, r26	; 0x12
    6cd0:	b3 8b       	std	Z+19, r27	; 0x13
  nicState.layer3.ip->srcipaddr = tempIp;
    6cd2:	24 87       	std	Z+12, r18	; 0x0c
    6cd4:	35 87       	std	Z+13, r19	; 0x0d
    6cd6:	46 87       	std	Z+14, r20	; 0x0e
    6cd8:	57 87       	std	Z+15, r21	; 0x0f
  // add ethernet routing
  arpIpOut(0);
    6cda:	60 e0       	ldi	r22, 0x00	; 0
    6cdc:	70 e0       	ldi	r23, 0x00	; 0
    6cde:	80 e0       	ldi	r24, 0x00	; 0
    6ce0:	90 e0       	ldi	r25, 0x00	; 0
    6ce2:	0e 94 cd 39 	call	0x739a	; 0x739a <arpIpOut>

  // debugging
  if (icmpDebug != NULL)
    6ce6:	80 91 aa 0e 	lds	r24, 0x0EAA
    6cea:	90 91 ab 0e 	lds	r25, 0x0EAB
    6cee:	00 97       	sbiw	r24, 0x00	; 0
    6cf0:	51 f0       	breq	.+20     	; 0x6d06 <icmpEchoRequest+0xc8>
    icmpPrintHeader(icmpDebug, nicState.layer3.ip, nicState.layer4.icmp);
    6cf2:	60 91 88 0e 	lds	r22, 0x0E88
    6cf6:	70 91 89 0e 	lds	r23, 0x0E89
    6cfa:	40 91 8a 0e 	lds	r20, 0x0E8A
    6cfe:	50 91 8b 0e 	lds	r21, 0x0E8B
    6d02:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <icmpPrintHeader>
  //debugPrintHexTable(htons(packet->ip.len), (uint8_t*)packet);

  // send it (packet->ip.len+ETH_HEADER_LEN
  nicSend(htons(nicState.layer3.ip->len) + ETH_HEADER_LEN);
    6d06:	e0 91 88 0e 	lds	r30, 0x0E88
    6d0a:	f0 91 89 0e 	lds	r31, 0x0E89
    6d0e:	82 81       	ldd	r24, Z+2	; 0x02
    6d10:	93 81       	ldd	r25, Z+3	; 0x03
    6d12:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    6d16:	0e 96       	adiw	r24, 0x0e	; 14
    6d18:	0e 94 be 2c 	call	0x597c	; 0x597c <nicSend>
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6d1c:	20 91 aa 0e 	lds	r18, 0x0EAA
    6d20:	30 91 ab 0e 	lds	r19, 0x0EAB
    6d24:	21 15       	cp	r18, r1
    6d26:	31 05       	cpc	r19, r1
    6d28:	a1 f0       	breq	.+40     	; 0x6d52 <icmpEchoRequest+0x114>
  {
    if (icmpDebugLevel > 1)
    6d2a:	80 91 52 0f 	lds	r24, 0x0F52
    6d2e:	82 30       	cpi	r24, 0x02	; 2
    6d30:	80 f0       	brcs	.+32     	; 0x6d52 <icmpEchoRequest+0x114>
      fprintf_P(icmpDebug, PSTR("Sending ICMP PONG\r\n"));
    6d32:	00 d0       	rcall	.+0      	; 0x6d34 <icmpEchoRequest+0xf6>
    6d34:	00 d0       	rcall	.+0      	; 0x6d36 <icmpEchoRequest+0xf8>
    6d36:	ed b7       	in	r30, 0x3d	; 61
    6d38:	fe b7       	in	r31, 0x3e	; 62
    6d3a:	32 83       	std	Z+2, r19	; 0x02
    6d3c:	21 83       	std	Z+1, r18	; 0x01
    6d3e:	82 e6       	ldi	r24, 0x62	; 98
    6d40:	9f e0       	ldi	r25, 0x0F	; 15
    6d42:	94 83       	std	Z+4, r25	; 0x04
    6d44:	83 83       	std	Z+3, r24	; 0x03
    6d46:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6d4a:	0f 90       	pop	r0
    6d4c:	0f 90       	pop	r0
    6d4e:	0f 90       	pop	r0
    6d50:	0f 90       	pop	r0
  }
#endif
}
    6d52:	1f 91       	pop	r17
    6d54:	0f 91       	pop	r16
    6d56:	08 95       	ret

00006d58 <icmpIpIn>:
}

void icmpIpIn(void)
{
  // check ICMP type
  switch(nicState.layer4.icmp->type)
    6d58:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6d5c:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6d60:	80 81       	ld	r24, Z
    6d62:	88 30       	cpi	r24, 0x08	; 8
    6d64:	19 f4       	brne	.+6      	; 0x6d6c <icmpIpIn+0x14>
  {
    case ICMP_TYPE_ECHOREQUEST:
      icmpEchoRequest();       // echo request
    6d66:	0e 94 1f 36 	call	0x6c3e	; 0x6c3e <icmpEchoRequest>
    6d6a:	08 95       	ret
      break;
    default:
#if ICMP_DEBUG
      if (icmpDebug != NULL)
    6d6c:	20 91 aa 0e 	lds	r18, 0x0EAA
    6d70:	30 91 ab 0e 	lds	r19, 0x0EAB
    6d74:	21 15       	cp	r18, r1
    6d76:	31 05       	cpc	r19, r1
    6d78:	a1 f0       	breq	.+40     	; 0x6da2 <icmpIpIn+0x4a>
      {
        if (icmpDebugLevel > 0)
    6d7a:	80 91 52 0f 	lds	r24, 0x0F52
    6d7e:	88 23       	and	r24, r24
    6d80:	81 f0       	breq	.+32     	; 0x6da2 <icmpIpIn+0x4a>
          fprintf_P(icmpDebug, PSTR("Unknown ICMP typeReceived ICMP request: "));
    6d82:	00 d0       	rcall	.+0      	; 0x6d84 <icmpIpIn+0x2c>
    6d84:	00 d0       	rcall	.+0      	; 0x6d86 <icmpIpIn+0x2e>
    6d86:	ed b7       	in	r30, 0x3d	; 61
    6d88:	fe b7       	in	r31, 0x3e	; 62
    6d8a:	32 83       	std	Z+2, r19	; 0x02
    6d8c:	21 83       	std	Z+1, r18	; 0x01
    6d8e:	8e e8       	ldi	r24, 0x8E	; 142
    6d90:	9f e0       	ldi	r25, 0x0F	; 15
    6d92:	94 83       	std	Z+4, r25	; 0x04
    6d94:	83 83       	std	Z+3, r24	; 0x03
    6d96:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6d9a:	0f 90       	pop	r0
    6d9c:	0f 90       	pop	r0
    6d9e:	0f 90       	pop	r0
    6da0:	0f 90       	pop	r0
    6da2:	08 95       	ret

00006da4 <setArpDebug>:

#ifdef ARP_DEBUG

void setArpDebug(FILE *stream, uint8_t level)
{
  arpDebug = stream;
    6da4:	90 93 8d 0e 	sts	0x0E8D, r25
    6da8:	80 93 8c 0e 	sts	0x0E8C, r24
  arpDebugLevel = level;
    6dac:	60 93 64 0f 	sts	0x0F64, r22
  if (level == 0)
    6db0:	66 23       	and	r22, r22
    6db2:	21 f4       	brne	.+8      	; 0x6dbc <setArpDebug+0x18>
    arpDebug = NULL;
    6db4:	10 92 8d 0e 	sts	0x0E8D, r1
    6db8:	10 92 8c 0e 	sts	0x0E8C, r1
    6dbc:	08 95       	ret

00006dbe <arpTimer>:
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}

void arpTimer(void)
{
    6dbe:	e9 e7       	ldi	r30, 0x79	; 121
    6dc0:	ff e0       	ldi	r31, 0x0F	; 15
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time)
    6dc2:	80 81       	ld	r24, Z
    6dc4:	88 23       	and	r24, r24
    6dc6:	11 f0       	breq	.+4      	; 0x6dcc <arpTimer+0xe>
      ArpTable[index].time--;
    6dc8:	81 50       	subi	r24, 0x01	; 1
    6dca:	80 83       	st	Z, r24
    6dcc:	3b 96       	adiw	r30, 0x0b	; 11
{
  int index;
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6dce:	8f e0       	ldi	r24, 0x0F	; 15
    6dd0:	e7 3e       	cpi	r30, 0xE7	; 231
    6dd2:	f8 07       	cpc	r31, r24
    6dd4:	b1 f7       	brne	.-20     	; 0x6dc2 <arpTimer+0x4>
  {
    if(ArpTable[index].time)
      ArpTable[index].time--;
  }
}
    6dd6:	08 95       	ret

00006dd8 <arpMatchIp>:

int arpMatchIp(uint32_t ipaddr)
{
    6dd8:	ab 01       	movw	r20, r22
    6dda:	bc 01       	movw	r22, r24
    6ddc:	ef e6       	ldi	r30, 0x6F	; 111
    6dde:	ff e0       	ldi	r31, 0x0F	; 15
    6de0:	80 e0       	ldi	r24, 0x00	; 0
    6de2:	90 e0       	ldi	r25, 0x00	; 0
    6de4:	9c 01       	movw	r18, r24
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    6de6:	80 81       	ld	r24, Z
    6de8:	91 81       	ldd	r25, Z+1	; 0x01
    6dea:	a2 81       	ldd	r26, Z+2	; 0x02
    6dec:	b3 81       	ldd	r27, Z+3	; 0x03
    6dee:	84 17       	cp	r24, r20
    6df0:	95 07       	cpc	r25, r21
    6df2:	a6 07       	cpc	r26, r22
    6df4:	b7 07       	cpc	r27, r23
    6df6:	41 f0       	breq	.+16     	; 0x6e08 <arpMatchIp+0x30>
    6df8:	c9 01       	movw	r24, r18
    6dfa:	01 96       	adiw	r24, 0x01	; 1
    6dfc:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    6dfe:	8a 30       	cpi	r24, 0x0A	; 10
    6e00:	91 05       	cpc	r25, r1
    6e02:	81 f7       	brne	.-32     	; 0x6de4 <arpMatchIp+0xc>
    6e04:	2f ef       	ldi	r18, 0xFF	; 255
    6e06:	3f ef       	ldi	r19, 0xFF	; 255
    }
  }

// no match
  return -1;
}
    6e08:	c9 01       	movw	r24, r18
    6e0a:	08 95       	ret

00006e0c <arpPrintTable>:
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
}
#endif /*ARP_DEBUG*/

void arpPrintTable(FILE *stream)
{
    6e0c:	6f 92       	push	r6
    6e0e:	7f 92       	push	r7
    6e10:	8f 92       	push	r8
    6e12:	9f 92       	push	r9
    6e14:	af 92       	push	r10
    6e16:	bf 92       	push	r11
    6e18:	cf 92       	push	r12
    6e1a:	df 92       	push	r13
    6e1c:	ef 92       	push	r14
    6e1e:	ff 92       	push	r15
    6e20:	0f 93       	push	r16
    6e22:	1f 93       	push	r17
    6e24:	cf 93       	push	r28
    6e26:	df 93       	push	r29
    6e28:	ec 01       	movw	r28, r24
  uint8_t i;

  // print ARP table
  fprintf_P(stream, PSTR("Time Eth Address        IP Address\r\n"));
    6e2a:	00 d0       	rcall	.+0      	; 0x6e2c <arpPrintTable+0x20>
    6e2c:	00 d0       	rcall	.+0      	; 0x6e2e <arpPrintTable+0x22>
    6e2e:	ad b7       	in	r26, 0x3d	; 61
    6e30:	be b7       	in	r27, 0x3e	; 62
    6e32:	12 96       	adiw	r26, 0x02	; 2
    6e34:	9c 93       	st	X, r25
    6e36:	8e 93       	st	-X, r24
    6e38:	11 97       	sbiw	r26, 0x01	; 1
    6e3a:	85 ef       	ldi	r24, 0xF5	; 245
    6e3c:	9f e0       	ldi	r25, 0x0F	; 15
    6e3e:	14 96       	adiw	r26, 0x04	; 4
    6e40:	9c 93       	st	X, r25
    6e42:	8e 93       	st	-X, r24
    6e44:	13 97       	sbiw	r26, 0x03	; 3
    6e46:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("-----------------------------------\r\n"));
    6e4a:	ed b7       	in	r30, 0x3d	; 61
    6e4c:	fe b7       	in	r31, 0x3e	; 62
    6e4e:	d2 83       	std	Z+2, r29	; 0x02
    6e50:	c1 83       	std	Z+1, r28	; 0x01
    6e52:	8f ec       	ldi	r24, 0xCF	; 207
    6e54:	9f e0       	ldi	r25, 0x0F	; 15
    6e56:	94 83       	std	Z+4, r25	; 0x04
    6e58:	83 83       	std	Z+3, r24	; 0x03
    6e5a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR(" MY  "));
    6e5e:	ad b7       	in	r26, 0x3d	; 61
    6e60:	be b7       	in	r27, 0x3e	; 62
    6e62:	12 96       	adiw	r26, 0x02	; 2
    6e64:	dc 93       	st	X, r29
    6e66:	ce 93       	st	-X, r28
    6e68:	11 97       	sbiw	r26, 0x01	; 1
    6e6a:	89 ec       	ldi	r24, 0xC9	; 201
    6e6c:	9f e0       	ldi	r25, 0x0F	; 15
    6e6e:	14 96       	adiw	r26, 0x04	; 4
    6e70:	9c 93       	st	X, r25
    6e72:	8e 93       	st	-X, r24
    6e74:	13 97       	sbiw	r26, 0x03	; 3
    6e76:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    6e7a:	0f 90       	pop	r0
    6e7c:	0f 90       	pop	r0
    6e7e:	0f 90       	pop	r0
    6e80:	0f 90       	pop	r0
    6e82:	ce 01       	movw	r24, r28
    6e84:	60 e8       	ldi	r22, 0x80	; 128
    6e86:	7e e0       	ldi	r23, 0x0E	; 14
    6e88:	0e 94 82 31 	call	0x6304	; 0x6304 <netPrintEthAddr>
  fprintf_P(stream, PSTR("  "));
    6e8c:	00 d0       	rcall	.+0      	; 0x6e8e <arpPrintTable+0x82>
    6e8e:	00 d0       	rcall	.+0      	; 0x6e90 <arpPrintTable+0x84>
    6e90:	ed b7       	in	r30, 0x3d	; 61
    6e92:	fe b7       	in	r31, 0x3e	; 62
    6e94:	d2 83       	std	Z+2, r29	; 0x02
    6e96:	c1 83       	std	Z+1, r28	; 0x01
    6e98:	86 ec       	ldi	r24, 0xC6	; 198
    6e9a:	9f e0       	ldi	r25, 0x0F	; 15
    6e9c:	94 83       	std	Z+4, r25	; 0x04
    6e9e:	83 83       	std	Z+3, r24	; 0x03
    6ea0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  netPrintIPAddr(stream, IpMyConfig.ip);
    6ea4:	0f 90       	pop	r0
    6ea6:	0f 90       	pop	r0
    6ea8:	0f 90       	pop	r0
    6eaa:	0f 90       	pop	r0
    6eac:	40 91 55 0f 	lds	r20, 0x0F55
    6eb0:	50 91 56 0f 	lds	r21, 0x0F56
    6eb4:	60 91 57 0f 	lds	r22, 0x0F57
    6eb8:	70 91 58 0f 	lds	r23, 0x0F58
    6ebc:	ce 01       	movw	r24, r28
    6ebe:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    6ec2:	00 d0       	rcall	.+0      	; 0x6ec4 <arpPrintTable+0xb8>
    6ec4:	00 d0       	rcall	.+0      	; 0x6ec6 <arpPrintTable+0xba>
    6ec6:	ad b7       	in	r26, 0x3d	; 61
    6ec8:	be b7       	in	r27, 0x3e	; 62
    6eca:	12 96       	adiw	r26, 0x02	; 2
    6ecc:	dc 93       	st	X, r29
    6ece:	ce 93       	st	-X, r28
    6ed0:	11 97       	sbiw	r26, 0x01	; 1
    6ed2:	83 ec       	ldi	r24, 0xC3	; 195
    6ed4:	9f e0       	ldi	r25, 0x0F	; 15
    6ed6:	14 96       	adiw	r26, 0x04	; 4
    6ed8:	9c 93       	st	X, r25
    6eda:	8e 93       	st	-X, r24
    6edc:	13 97       	sbiw	r26, 0x03	; 3
    6ede:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6ee2:	0f e6       	ldi	r16, 0x6F	; 111
    6ee4:	1f e0       	ldi	r17, 0x0F	; 15
    6ee6:	ee 24       	eor	r14, r14
    6ee8:	ff 24       	eor	r15, r15
    6eea:	0f 90       	pop	r0
    6eec:	0f 90       	pop	r0
    6eee:	0f 90       	pop	r0
    6ef0:	0f 90       	pop	r0

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    6ef2:	3d eb       	ldi	r19, 0xBD	; 189
    6ef4:	63 2e       	mov	r6, r19
    6ef6:	3f e0       	ldi	r19, 0x0F	; 15
    6ef8:	73 2e       	mov	r7, r19
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    6efa:	2b e0       	ldi	r18, 0x0B	; 11
    6efc:	82 2e       	mov	r8, r18
    6efe:	91 2c       	mov	r9, r1
    fprintf_P(stream, PSTR("  "));
    6f00:	9a eb       	ldi	r25, 0xBA	; 186
    6f02:	a9 2e       	mov	r10, r25
    6f04:	9f e0       	ldi	r25, 0x0F	; 15
    6f06:	b9 2e       	mov	r11, r25
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
    6f08:	87 eb       	ldi	r24, 0xB7	; 183
    6f0a:	c8 2e       	mov	r12, r24
    6f0c:	8f e0       	ldi	r24, 0x0F	; 15
    6f0e:	d8 2e       	mov	r13, r24
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
    6f10:	f8 01       	movw	r30, r16
    6f12:	80 81       	ld	r24, Z
    6f14:	91 81       	ldd	r25, Z+1	; 0x01
    6f16:	a2 81       	ldd	r26, Z+2	; 0x02
    6f18:	b3 81       	ldd	r27, Z+3	; 0x03
    6f1a:	00 97       	sbiw	r24, 0x00	; 0
    6f1c:	a1 05       	cpc	r26, r1
    6f1e:	b1 05       	cpc	r27, r1
    6f20:	09 f4       	brne	.+2      	; 0x6f24 <arpPrintTable+0x118>
    6f22:	55 c0       	rjmp	.+170    	; 0x6fce <arpPrintTable+0x1c2>
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    6f24:	00 d0       	rcall	.+0      	; 0x6f26 <arpPrintTable+0x11a>
    6f26:	00 d0       	rcall	.+0      	; 0x6f28 <arpPrintTable+0x11c>
    6f28:	00 d0       	rcall	.+0      	; 0x6f2a <arpPrintTable+0x11e>
    6f2a:	ed b7       	in	r30, 0x3d	; 61
    6f2c:	fe b7       	in	r31, 0x3e	; 62
    6f2e:	31 96       	adiw	r30, 0x01	; 1
    6f30:	ad b7       	in	r26, 0x3d	; 61
    6f32:	be b7       	in	r27, 0x3e	; 62
    6f34:	12 96       	adiw	r26, 0x02	; 2
    6f36:	dc 93       	st	X, r29
    6f38:	ce 93       	st	-X, r28
    6f3a:	11 97       	sbiw	r26, 0x01	; 1
    6f3c:	73 82       	std	Z+3, r7	; 0x03
    6f3e:	62 82       	std	Z+2, r6	; 0x02
    6f40:	d8 01       	movw	r26, r16
    6f42:	1a 96       	adiw	r26, 0x0a	; 10
    6f44:	8c 91       	ld	r24, X
    6f46:	84 83       	std	Z+4, r24	; 0x04
    6f48:	15 82       	std	Z+5, r1	; 0x05
    6f4a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    6f4e:	ed b7       	in	r30, 0x3d	; 61
    6f50:	fe b7       	in	r31, 0x3e	; 62
    6f52:	36 96       	adiw	r30, 0x06	; 6
    6f54:	0f b6       	in	r0, 0x3f	; 63
    6f56:	f8 94       	cli
    6f58:	fe bf       	out	0x3e, r31	; 62
    6f5a:	0f be       	out	0x3f, r0	; 63
    6f5c:	ed bf       	out	0x3d, r30	; 61
    6f5e:	e8 9c       	mul	r14, r8
    6f60:	b0 01       	movw	r22, r0
    6f62:	e9 9c       	mul	r14, r9
    6f64:	70 0d       	add	r23, r0
    6f66:	f8 9c       	mul	r15, r8
    6f68:	70 0d       	add	r23, r0
    6f6a:	11 24       	eor	r1, r1
    6f6c:	6d 58       	subi	r22, 0x8D	; 141
    6f6e:	70 4f       	sbci	r23, 0xF0	; 240
    6f70:	ce 01       	movw	r24, r28
    6f72:	0e 94 82 31 	call	0x6304	; 0x6304 <netPrintEthAddr>
    fprintf_P(stream, PSTR("  "));
    6f76:	00 d0       	rcall	.+0      	; 0x6f78 <arpPrintTable+0x16c>
    6f78:	00 d0       	rcall	.+0      	; 0x6f7a <arpPrintTable+0x16e>
    6f7a:	ad b7       	in	r26, 0x3d	; 61
    6f7c:	be b7       	in	r27, 0x3e	; 62
    6f7e:	12 96       	adiw	r26, 0x02	; 2
    6f80:	dc 93       	st	X, r29
    6f82:	ce 93       	st	-X, r28
    6f84:	11 97       	sbiw	r26, 0x01	; 1
    6f86:	14 96       	adiw	r26, 0x04	; 4
    6f88:	bc 92       	st	X, r11
    6f8a:	ae 92       	st	-X, r10
    6f8c:	13 97       	sbiw	r26, 0x03	; 3
    6f8e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    6f92:	0f 90       	pop	r0
    6f94:	0f 90       	pop	r0
    6f96:	0f 90       	pop	r0
    6f98:	0f 90       	pop	r0
    6f9a:	f8 01       	movw	r30, r16
    6f9c:	40 81       	ld	r20, Z
    6f9e:	51 81       	ldd	r21, Z+1	; 0x01
    6fa0:	62 81       	ldd	r22, Z+2	; 0x02
    6fa2:	73 81       	ldd	r23, Z+3	; 0x03
    6fa4:	ce 01       	movw	r24, r28
    6fa6:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    fprintf_P(stream, PSTR("\r\n"));
    6faa:	00 d0       	rcall	.+0      	; 0x6fac <arpPrintTable+0x1a0>
    6fac:	00 d0       	rcall	.+0      	; 0x6fae <arpPrintTable+0x1a2>
    6fae:	ad b7       	in	r26, 0x3d	; 61
    6fb0:	be b7       	in	r27, 0x3e	; 62
    6fb2:	12 96       	adiw	r26, 0x02	; 2
    6fb4:	dc 93       	st	X, r29
    6fb6:	ce 93       	st	-X, r28
    6fb8:	11 97       	sbiw	r26, 0x01	; 1
    6fba:	14 96       	adiw	r26, 0x04	; 4
    6fbc:	dc 92       	st	X, r13
    6fbe:	ce 92       	st	-X, r12
    6fc0:	13 97       	sbiw	r26, 0x03	; 3
    6fc2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    6fc6:	0f 90       	pop	r0
    6fc8:	0f 90       	pop	r0
    6fca:	0f 90       	pop	r0
    6fcc:	0f 90       	pop	r0
    6fce:	08 94       	sec
    6fd0:	e1 1c       	adc	r14, r1
    6fd2:	f1 1c       	adc	r15, r1
    6fd4:	05 5f       	subi	r16, 0xF5	; 245
    6fd6:	1f 4f       	sbci	r17, 0xFF	; 255
  netPrintEthAddr(stream, &nicState.mac);
  fprintf_P(stream, PSTR("  "));
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
    6fd8:	ba e0       	ldi	r27, 0x0A	; 10
    6fda:	eb 16       	cp	r14, r27
    6fdc:	f1 04       	cpc	r15, r1
    6fde:	09 f0       	breq	.+2      	; 0x6fe2 <arpPrintTable+0x1d6>
    6fe0:	97 cf       	rjmp	.-210    	; 0x6f10 <arpPrintTable+0x104>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
  }
}
    6fe2:	df 91       	pop	r29
    6fe4:	cf 91       	pop	r28
    6fe6:	1f 91       	pop	r17
    6fe8:	0f 91       	pop	r16
    6fea:	ff 90       	pop	r15
    6fec:	ef 90       	pop	r14
    6fee:	df 90       	pop	r13
    6ff0:	cf 90       	pop	r12
    6ff2:	bf 90       	pop	r11
    6ff4:	af 90       	pop	r10
    6ff6:	9f 90       	pop	r9
    6ff8:	8f 90       	pop	r8
    6ffa:	7f 90       	pop	r7
    6ffc:	6f 90       	pop	r6
    6ffe:	08 95       	ret

00007000 <arpIpIn>:
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
  }
}

void arpIpIn(void)
{
    7000:	cf 93       	push	r28
    7002:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    7004:	20 91 8c 0e 	lds	r18, 0x0E8C
    7008:	30 91 8d 0e 	lds	r19, 0x0E8D
    700c:	21 15       	cp	r18, r1
    700e:	31 05       	cpc	r19, r1
    7010:	09 f4       	brne	.+2      	; 0x7014 <arpIpIn+0x14>
    7012:	57 c0       	rjmp	.+174    	; 0x70c2 <arpIpIn+0xc2>
  {
    if (arpDebugLevel > 0)
    7014:	80 91 64 0f 	lds	r24, 0x0F64
    7018:	88 23       	and	r24, r24
    701a:	09 f4       	brne	.+2      	; 0x701e <arpIpIn+0x1e>
    701c:	52 c0       	rjmp	.+164    	; 0x70c2 <arpIpIn+0xc2>
    {
      fprintf_P(arpDebug, PSTR("ARP IP in MAC: "));
    701e:	00 d0       	rcall	.+0      	; 0x7020 <arpIpIn+0x20>
    7020:	00 d0       	rcall	.+0      	; 0x7022 <arpIpIn+0x22>
    7022:	ed b7       	in	r30, 0x3d	; 61
    7024:	fe b7       	in	r31, 0x3e	; 62
    7026:	32 83       	std	Z+2, r19	; 0x02
    7028:	21 83       	std	Z+1, r18	; 0x01
    702a:	81 ea       	ldi	r24, 0xA1	; 161
    702c:	90 e1       	ldi	r25, 0x10	; 16
    702e:	94 83       	std	Z+4, r25	; 0x04
    7030:	83 83       	std	Z+3, r24	; 0x03
    7032:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      netPrintEthAddr(arpDebug, &nicState.layer2.ethHeader->src);
    7036:	0f 90       	pop	r0
    7038:	0f 90       	pop	r0
    703a:	0f 90       	pop	r0
    703c:	0f 90       	pop	r0
    703e:	60 91 86 0e 	lds	r22, 0x0E86
    7042:	70 91 87 0e 	lds	r23, 0x0E87
    7046:	6a 5f       	subi	r22, 0xFA	; 250
    7048:	7f 4f       	sbci	r23, 0xFF	; 255
    704a:	80 91 8c 0e 	lds	r24, 0x0E8C
    704e:	90 91 8d 0e 	lds	r25, 0x0E8D
    7052:	0e 94 82 31 	call	0x6304	; 0x6304 <netPrintEthAddr>
      fprintf_P(arpDebug, PSTR(" IP: "));
    7056:	00 d0       	rcall	.+0      	; 0x7058 <arpIpIn+0x58>
    7058:	00 d0       	rcall	.+0      	; 0x705a <arpIpIn+0x5a>
    705a:	80 91 8c 0e 	lds	r24, 0x0E8C
    705e:	90 91 8d 0e 	lds	r25, 0x0E8D
    7062:	ed b7       	in	r30, 0x3d	; 61
    7064:	fe b7       	in	r31, 0x3e	; 62
    7066:	92 83       	std	Z+2, r25	; 0x02
    7068:	81 83       	std	Z+1, r24	; 0x01
    706a:	8b e9       	ldi	r24, 0x9B	; 155
    706c:	90 e1       	ldi	r25, 0x10	; 16
    706e:	94 83       	std	Z+4, r25	; 0x04
    7070:	83 83       	std	Z+3, r24	; 0x03
    7072:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      netPrintIPAddr(arpDebug, nicState.layer3.ip->srcipaddr);
    7076:	0f 90       	pop	r0
    7078:	0f 90       	pop	r0
    707a:	0f 90       	pop	r0
    707c:	0f 90       	pop	r0
    707e:	e0 91 88 0e 	lds	r30, 0x0E88
    7082:	f0 91 89 0e 	lds	r31, 0x0E89
    7086:	44 85       	ldd	r20, Z+12	; 0x0c
    7088:	55 85       	ldd	r21, Z+13	; 0x0d
    708a:	66 85       	ldd	r22, Z+14	; 0x0e
    708c:	77 85       	ldd	r23, Z+15	; 0x0f
    708e:	80 91 8c 0e 	lds	r24, 0x0E8C
    7092:	90 91 8d 0e 	lds	r25, 0x0E8D
    7096:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
      fprintf_P(arpDebug, PSTR("\r\n"));
    709a:	00 d0       	rcall	.+0      	; 0x709c <arpIpIn+0x9c>
    709c:	00 d0       	rcall	.+0      	; 0x709e <arpIpIn+0x9e>
    709e:	80 91 8c 0e 	lds	r24, 0x0E8C
    70a2:	90 91 8d 0e 	lds	r25, 0x0E8D
    70a6:	ed b7       	in	r30, 0x3d	; 61
    70a8:	fe b7       	in	r31, 0x3e	; 62
    70aa:	92 83       	std	Z+2, r25	; 0x02
    70ac:	81 83       	std	Z+1, r24	; 0x01
    70ae:	88 e9       	ldi	r24, 0x98	; 152
    70b0:	90 e1       	ldi	r25, 0x10	; 16
    70b2:	94 83       	std	Z+4, r25	; 0x04
    70b4:	83 83       	std	Z+3, r24	; 0x03
    70b6:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    70ba:	0f 90       	pop	r0
    70bc:	0f 90       	pop	r0
    70be:	0f 90       	pop	r0
    70c0:	0f 90       	pop	r0
  }
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
    70c2:	c0 91 88 0e 	lds	r28, 0x0E88
    70c6:	d0 91 89 0e 	lds	r29, 0x0E89
    70ca:	4c 85       	ldd	r20, Y+12	; 0x0c
    70cc:	5d 85       	ldd	r21, Y+13	; 0x0d
    70ce:	6e 85       	ldd	r22, Y+14	; 0x0e
    70d0:	7f 85       	ldd	r23, Y+15	; 0x0f
    70d2:	ef e6       	ldi	r30, 0x6F	; 111
    70d4:	ff e0       	ldi	r31, 0x0F	; 15
    70d6:	80 e0       	ldi	r24, 0x00	; 0
    70d8:	90 e0       	ldi	r25, 0x00	; 0
    70da:	9c 01       	movw	r18, r24
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    70dc:	80 81       	ld	r24, Z
    70de:	91 81       	ldd	r25, Z+1	; 0x01
    70e0:	a2 81       	ldd	r26, Z+2	; 0x02
    70e2:	b3 81       	ldd	r27, Z+3	; 0x03
    70e4:	84 17       	cp	r24, r20
    70e6:	95 07       	cpc	r25, r21
    70e8:	a6 07       	cpc	r26, r22
    70ea:	b7 07       	cpc	r27, r23
    70ec:	41 f0       	breq	.+16     	; 0x70fe <arpIpIn+0xfe>
    70ee:	c9 01       	movw	r24, r18
    70f0:	01 96       	adiw	r24, 0x01	; 1
    70f2:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    70f4:	8a 30       	cpi	r24, 0x0A	; 10
    70f6:	91 05       	cpc	r25, r1
    70f8:	81 f7       	brne	.-32     	; 0x70da <arpIpIn+0xda>
    70fa:	2f ef       	ldi	r18, 0xFF	; 255
    70fc:	3f ef       	ldi	r19, 0xFF	; 255
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
  if(index != -1)
    70fe:	2f 3f       	cpi	r18, 0xFF	; 255
    7100:	21 f1       	breq	.+72     	; 0x714a <arpIpIn+0x14a>
  {
// sender's IP address found, update ARP entry
    ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    7102:	33 27       	eor	r19, r19
    7104:	27 fd       	sbrc	r18, 7
    7106:	30 95       	com	r19
    7108:	8b e0       	ldi	r24, 0x0B	; 11
    710a:	90 e0       	ldi	r25, 0x00	; 0
    710c:	28 9f       	mul	r18, r24
    710e:	d0 01       	movw	r26, r0
    7110:	29 9f       	mul	r18, r25
    7112:	b0 0d       	add	r27, r0
    7114:	38 9f       	mul	r19, r24
    7116:	b0 0d       	add	r27, r0
    7118:	11 24       	eor	r1, r1
    711a:	e0 91 86 0e 	lds	r30, 0x0E86
    711e:	f0 91 87 0e 	lds	r31, 0x0E87
    7122:	ad 58       	subi	r26, 0x8D	; 141
    7124:	b0 4f       	sbci	r27, 0xF0	; 240
    7126:	36 96       	adiw	r30, 0x06	; 6
    7128:	86 e0       	ldi	r24, 0x06	; 6
    712a:	01 90       	ld	r0, Z+
    712c:	0d 92       	st	X+, r0
    712e:	81 50       	subi	r24, 0x01	; 1
    7130:	e1 f7       	brne	.-8      	; 0x712a <arpIpIn+0x12a>
    ArpTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    7132:	8b e0       	ldi	r24, 0x0B	; 11
    7134:	90 e0       	ldi	r25, 0x00	; 0
    7136:	28 9f       	mul	r18, r24
    7138:	f0 01       	movw	r30, r0
    713a:	29 9f       	mul	r18, r25
    713c:	f0 0d       	add	r31, r0
    713e:	38 9f       	mul	r19, r24
    7140:	f0 0d       	add	r31, r0
    7142:	11 24       	eor	r1, r1
    7144:	e1 59       	subi	r30, 0x91	; 145
    7146:	f0 4f       	sbci	r31, 0xF0	; 240
    7148:	2f c0       	rjmp	.+94     	; 0x71a8 <arpIpIn+0x1a8>
// and we're done
    return;
    714a:	e9 e7       	ldi	r30, 0x79	; 121
    714c:	ff e0       	ldi	r31, 0x0F	; 15
    714e:	20 e0       	ldi	r18, 0x00	; 0
    7150:	30 e0       	ldi	r19, 0x00	; 0

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time == 0)
    7152:	80 81       	ld	r24, Z
    7154:	88 23       	and	r24, r24
    7156:	59 f5       	brne	.+86     	; 0x71ae <arpIpIn+0x1ae>
    {
// write entry
      ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    7158:	8b e0       	ldi	r24, 0x0B	; 11
    715a:	90 e0       	ldi	r25, 0x00	; 0
    715c:	28 9f       	mul	r18, r24
    715e:	d0 01       	movw	r26, r0
    7160:	29 9f       	mul	r18, r25
    7162:	b0 0d       	add	r27, r0
    7164:	38 9f       	mul	r19, r24
    7166:	b0 0d       	add	r27, r0
    7168:	11 24       	eor	r1, r1
    716a:	e0 91 86 0e 	lds	r30, 0x0E86
    716e:	f0 91 87 0e 	lds	r31, 0x0E87
    7172:	ad 58       	subi	r26, 0x8D	; 141
    7174:	b0 4f       	sbci	r27, 0xF0	; 240
    7176:	36 96       	adiw	r30, 0x06	; 6
    7178:	86 e0       	ldi	r24, 0x06	; 6
    717a:	01 90       	ld	r0, Z+
    717c:	0d 92       	st	X+, r0
    717e:	81 50       	subi	r24, 0x01	; 1
    7180:	e1 f7       	brne	.-8      	; 0x717a <arpIpIn+0x17a>
      ArpTable[index].ipaddr  = nicState.layer3.ip->srcipaddr;
    7182:	8b e0       	ldi	r24, 0x0B	; 11
    7184:	90 e0       	ldi	r25, 0x00	; 0
    7186:	28 9f       	mul	r18, r24
    7188:	f0 01       	movw	r30, r0
    718a:	29 9f       	mul	r18, r25
    718c:	f0 0d       	add	r31, r0
    718e:	38 9f       	mul	r19, r24
    7190:	f0 0d       	add	r31, r0
    7192:	11 24       	eor	r1, r1
    7194:	e1 59       	subi	r30, 0x91	; 145
    7196:	f0 4f       	sbci	r31, 0xF0	; 240
    7198:	8c 85       	ldd	r24, Y+12	; 0x0c
    719a:	9d 85       	ldd	r25, Y+13	; 0x0d
    719c:	ae 85       	ldd	r26, Y+14	; 0x0e
    719e:	bf 85       	ldd	r27, Y+15	; 0x0f
    71a0:	80 83       	st	Z, r24
    71a2:	91 83       	std	Z+1, r25	; 0x01
    71a4:	a2 83       	std	Z+2, r26	; 0x02
    71a6:	b3 83       	std	Z+3, r27	; 0x03
      ArpTable[index].time    = ARP_CACHE_TIME_TO_LIVE;
    71a8:	80 e8       	ldi	r24, 0x80	; 128
    71aa:	82 87       	std	Z+10, r24	; 0x0a
    71ac:	06 c0       	rjmp	.+12     	; 0x71ba <arpIpIn+0x1ba>
// and we're done
      return;
    71ae:	2f 5f       	subi	r18, 0xFF	; 255
    71b0:	3f 4f       	sbci	r19, 0xFF	; 255
    71b2:	3b 96       	adiw	r30, 0x0b	; 11
    return;
  }

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
    71b4:	2a 30       	cpi	r18, 0x0A	; 10
    71b6:	31 05       	cpc	r19, r1
    71b8:	61 f6       	brne	.-104    	; 0x7152 <arpIpIn+0x152>
// and we're done
      return;
    }
  }
// no space in table, we give up
}
    71ba:	df 91       	pop	r29
    71bc:	cf 91       	pop	r28
    71be:	08 95       	ret

000071c0 <arpPrintHeader>:
  return -1;
}

#if ARP_DEBUG
void arpPrintHeader(FILE *stream, struct netArpHeader* packet)
{
    71c0:	ef 92       	push	r14
    71c2:	ff 92       	push	r15
    71c4:	0f 93       	push	r16
    71c6:	1f 93       	push	r17
    71c8:	cf 93       	push	r28
    71ca:	df 93       	push	r29
    71cc:	ec 01       	movw	r28, r24
    71ce:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("ARP Packet:\r\n"));
    71d0:	00 d0       	rcall	.+0      	; 0x71d2 <arpPrintHeader+0x12>
    71d2:	00 d0       	rcall	.+0      	; 0x71d4 <arpPrintHeader+0x14>
    71d4:	ed b7       	in	r30, 0x3d	; 61
    71d6:	fe b7       	in	r31, 0x3e	; 62
    71d8:	92 83       	std	Z+2, r25	; 0x02
    71da:	81 83       	std	Z+1, r24	; 0x01
    71dc:	8a e8       	ldi	r24, 0x8A	; 138
    71de:	90 e1       	ldi	r25, 0x10	; 16
    71e0:	94 83       	std	Z+4, r25	; 0x04
    71e2:	83 83       	std	Z+3, r24	; 0x03
    71e4:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  //debugPrintHexTable(60, (unsigned char*)&packet);
  // print operation type
  fprintf_P(stream, PSTR("Operation   : "));
    71e8:	ed b7       	in	r30, 0x3d	; 61
    71ea:	fe b7       	in	r31, 0x3e	; 62
    71ec:	d2 83       	std	Z+2, r29	; 0x02
    71ee:	c1 83       	std	Z+1, r28	; 0x01
    71f0:	8b e7       	ldi	r24, 0x7B	; 123
    71f2:	90 e1       	ldi	r25, 0x10	; 16
    71f4:	94 83       	std	Z+4, r25	; 0x04
    71f6:	83 83       	std	Z+3, r24	; 0x03
    71f8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  if(packet->opcode == htons(ARP_OPCODE_REQUEST))
    71fc:	f7 01       	movw	r30, r14
    71fe:	06 81       	ldd	r16, Z+6	; 0x06
    7200:	17 81       	ldd	r17, Z+7	; 0x07
    7202:	0f 90       	pop	r0
    7204:	0f 90       	pop	r0
    7206:	0f 90       	pop	r0
    7208:	0f 90       	pop	r0
    720a:	81 e0       	ldi	r24, 0x01	; 1
    720c:	90 e0       	ldi	r25, 0x00	; 0
    720e:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7212:	08 17       	cp	r16, r24
    7214:	19 07       	cpc	r17, r25
    7216:	49 f4       	brne	.+18     	; 0x722a <arpPrintHeader+0x6a>
    fprintf_P(stream, PSTR("REQUEST"));
    7218:	00 d0       	rcall	.+0      	; 0x721a <arpPrintHeader+0x5a>
    721a:	00 d0       	rcall	.+0      	; 0x721c <arpPrintHeader+0x5c>
    721c:	ed b7       	in	r30, 0x3d	; 61
    721e:	fe b7       	in	r31, 0x3e	; 62
    7220:	d2 83       	std	Z+2, r29	; 0x02
    7222:	c1 83       	std	Z+1, r28	; 0x01
    7224:	83 e7       	ldi	r24, 0x73	; 115
    7226:	90 e1       	ldi	r25, 0x10	; 16
    7228:	1b c0       	rjmp	.+54     	; 0x7260 <arpPrintHeader+0xa0>
  else if(packet->opcode == htons(ARP_OPCODE_REPLY))
    722a:	f7 01       	movw	r30, r14
    722c:	06 81       	ldd	r16, Z+6	; 0x06
    722e:	17 81       	ldd	r17, Z+7	; 0x07
    7230:	82 e0       	ldi	r24, 0x02	; 2
    7232:	90 e0       	ldi	r25, 0x00	; 0
    7234:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7238:	08 17       	cp	r16, r24
    723a:	19 07       	cpc	r17, r25
    723c:	49 f4       	brne	.+18     	; 0x7250 <arpPrintHeader+0x90>
    fprintf_P(stream, PSTR("REPLY"));
    723e:	00 d0       	rcall	.+0      	; 0x7240 <arpPrintHeader+0x80>
    7240:	00 d0       	rcall	.+0      	; 0x7242 <arpPrintHeader+0x82>
    7242:	ed b7       	in	r30, 0x3d	; 61
    7244:	fe b7       	in	r31, 0x3e	; 62
    7246:	d2 83       	std	Z+2, r29	; 0x02
    7248:	c1 83       	std	Z+1, r28	; 0x01
    724a:	8d e6       	ldi	r24, 0x6D	; 109
    724c:	90 e1       	ldi	r25, 0x10	; 16
    724e:	08 c0       	rjmp	.+16     	; 0x7260 <arpPrintHeader+0xa0>
  else
    fprintf_P(stream, PSTR("UNKNOWN"));
    7250:	00 d0       	rcall	.+0      	; 0x7252 <arpPrintHeader+0x92>
    7252:	00 d0       	rcall	.+0      	; 0x7254 <arpPrintHeader+0x94>
    7254:	ed b7       	in	r30, 0x3d	; 61
    7256:	fe b7       	in	r31, 0x3e	; 62
    7258:	d2 83       	std	Z+2, r29	; 0x02
    725a:	c1 83       	std	Z+1, r28	; 0x01
    725c:	85 e6       	ldi	r24, 0x65	; 101
    725e:	90 e1       	ldi	r25, 0x10	; 16
    7260:	94 83       	std	Z+4, r25	; 0x04
    7262:	83 83       	std	Z+3, r24	; 0x03
    7264:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n"));
    7268:	ed b7       	in	r30, 0x3d	; 61
    726a:	fe b7       	in	r31, 0x3e	; 62
    726c:	d2 83       	std	Z+2, r29	; 0x02
    726e:	c1 83       	std	Z+1, r28	; 0x01
    7270:	82 e6       	ldi	r24, 0x62	; 98
    7272:	90 e1       	ldi	r25, 0x10	; 16
    7274:	94 83       	std	Z+4, r25	; 0x04
    7276:	83 83       	std	Z+3, r24	; 0x03
    7278:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print source hardware address
  fprintf_P(stream, PSTR("SrcHwAddr   : "));  netPrintEthAddr(stream, &packet->shwaddr);   fprintf_P(stream, PSTR("\r\n"));
    727c:	ed b7       	in	r30, 0x3d	; 61
    727e:	fe b7       	in	r31, 0x3e	; 62
    7280:	d2 83       	std	Z+2, r29	; 0x02
    7282:	c1 83       	std	Z+1, r28	; 0x01
    7284:	83 e5       	ldi	r24, 0x53	; 83
    7286:	90 e1       	ldi	r25, 0x10	; 16
    7288:	94 83       	std	Z+4, r25	; 0x04
    728a:	83 83       	std	Z+3, r24	; 0x03
    728c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7290:	0f 90       	pop	r0
    7292:	0f 90       	pop	r0
    7294:	0f 90       	pop	r0
    7296:	0f 90       	pop	r0
    7298:	b7 01       	movw	r22, r14
    729a:	68 5f       	subi	r22, 0xF8	; 248
    729c:	7f 4f       	sbci	r23, 0xFF	; 255
    729e:	ce 01       	movw	r24, r28
    72a0:	0e 94 82 31 	call	0x6304	; 0x6304 <netPrintEthAddr>
    72a4:	00 d0       	rcall	.+0      	; 0x72a6 <arpPrintHeader+0xe6>
    72a6:	00 d0       	rcall	.+0      	; 0x72a8 <arpPrintHeader+0xe8>
    72a8:	ed b7       	in	r30, 0x3d	; 61
    72aa:	fe b7       	in	r31, 0x3e	; 62
    72ac:	d2 83       	std	Z+2, r29	; 0x02
    72ae:	c1 83       	std	Z+1, r28	; 0x01
    72b0:	80 e5       	ldi	r24, 0x50	; 80
    72b2:	90 e1       	ldi	r25, 0x10	; 16
    72b4:	94 83       	std	Z+4, r25	; 0x04
    72b6:	83 83       	std	Z+3, r24	; 0x03
    72b8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print source protocol address
  fprintf_P(stream, PSTR("SrcProtoAddr: "));  netPrintIPAddr(stream, packet->sipaddr);     fprintf_P(stream, PSTR("\r\n"));
    72bc:	ed b7       	in	r30, 0x3d	; 61
    72be:	fe b7       	in	r31, 0x3e	; 62
    72c0:	d2 83       	std	Z+2, r29	; 0x02
    72c2:	c1 83       	std	Z+1, r28	; 0x01
    72c4:	81 e4       	ldi	r24, 0x41	; 65
    72c6:	90 e1       	ldi	r25, 0x10	; 16
    72c8:	94 83       	std	Z+4, r25	; 0x04
    72ca:	83 83       	std	Z+3, r24	; 0x03
    72cc:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    72d0:	0f 90       	pop	r0
    72d2:	0f 90       	pop	r0
    72d4:	0f 90       	pop	r0
    72d6:	0f 90       	pop	r0
    72d8:	f7 01       	movw	r30, r14
    72da:	46 85       	ldd	r20, Z+14	; 0x0e
    72dc:	57 85       	ldd	r21, Z+15	; 0x0f
    72de:	60 89       	ldd	r22, Z+16	; 0x10
    72e0:	71 89       	ldd	r23, Z+17	; 0x11
    72e2:	ce 01       	movw	r24, r28
    72e4:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    72e8:	00 d0       	rcall	.+0      	; 0x72ea <arpPrintHeader+0x12a>
    72ea:	00 d0       	rcall	.+0      	; 0x72ec <arpPrintHeader+0x12c>
    72ec:	ed b7       	in	r30, 0x3d	; 61
    72ee:	fe b7       	in	r31, 0x3e	; 62
    72f0:	d2 83       	std	Z+2, r29	; 0x02
    72f2:	c1 83       	std	Z+1, r28	; 0x01
    72f4:	8e e3       	ldi	r24, 0x3E	; 62
    72f6:	90 e1       	ldi	r25, 0x10	; 16
    72f8:	94 83       	std	Z+4, r25	; 0x04
    72fa:	83 83       	std	Z+3, r24	; 0x03
    72fc:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print target hardware address
  fprintf_P(stream, PSTR("DstHwAddr   : "));  netPrintEthAddr(stream, &packet->dhwaddr);   fprintf_P(stream, PSTR("\r\n"));
    7300:	ed b7       	in	r30, 0x3d	; 61
    7302:	fe b7       	in	r31, 0x3e	; 62
    7304:	d2 83       	std	Z+2, r29	; 0x02
    7306:	c1 83       	std	Z+1, r28	; 0x01
    7308:	8f e2       	ldi	r24, 0x2F	; 47
    730a:	90 e1       	ldi	r25, 0x10	; 16
    730c:	94 83       	std	Z+4, r25	; 0x04
    730e:	83 83       	std	Z+3, r24	; 0x03
    7310:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7314:	0f 90       	pop	r0
    7316:	0f 90       	pop	r0
    7318:	0f 90       	pop	r0
    731a:	0f 90       	pop	r0
    731c:	b7 01       	movw	r22, r14
    731e:	6e 5e       	subi	r22, 0xEE	; 238
    7320:	7f 4f       	sbci	r23, 0xFF	; 255
    7322:	ce 01       	movw	r24, r28
    7324:	0e 94 82 31 	call	0x6304	; 0x6304 <netPrintEthAddr>
    7328:	00 d0       	rcall	.+0      	; 0x732a <arpPrintHeader+0x16a>
    732a:	00 d0       	rcall	.+0      	; 0x732c <arpPrintHeader+0x16c>
    732c:	ed b7       	in	r30, 0x3d	; 61
    732e:	fe b7       	in	r31, 0x3e	; 62
    7330:	d2 83       	std	Z+2, r29	; 0x02
    7332:	c1 83       	std	Z+1, r28	; 0x01
    7334:	8c e2       	ldi	r24, 0x2C	; 44
    7336:	90 e1       	ldi	r25, 0x10	; 16
    7338:	94 83       	std	Z+4, r25	; 0x04
    733a:	83 83       	std	Z+3, r24	; 0x03
    733c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
// print target protocol address
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
    7340:	ed b7       	in	r30, 0x3d	; 61
    7342:	fe b7       	in	r31, 0x3e	; 62
    7344:	d2 83       	std	Z+2, r29	; 0x02
    7346:	c1 83       	std	Z+1, r28	; 0x01
    7348:	8d e1       	ldi	r24, 0x1D	; 29
    734a:	90 e1       	ldi	r25, 0x10	; 16
    734c:	94 83       	std	Z+4, r25	; 0x04
    734e:	83 83       	std	Z+3, r24	; 0x03
    7350:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7354:	0f 90       	pop	r0
    7356:	0f 90       	pop	r0
    7358:	0f 90       	pop	r0
    735a:	0f 90       	pop	r0
    735c:	f7 01       	movw	r30, r14
    735e:	40 8d       	ldd	r20, Z+24	; 0x18
    7360:	51 8d       	ldd	r21, Z+25	; 0x19
    7362:	62 8d       	ldd	r22, Z+26	; 0x1a
    7364:	73 8d       	ldd	r23, Z+27	; 0x1b
    7366:	ce 01       	movw	r24, r28
    7368:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
    736c:	00 d0       	rcall	.+0      	; 0x736e <arpPrintHeader+0x1ae>
    736e:	00 d0       	rcall	.+0      	; 0x7370 <arpPrintHeader+0x1b0>
    7370:	ed b7       	in	r30, 0x3d	; 61
    7372:	fe b7       	in	r31, 0x3e	; 62
    7374:	d2 83       	std	Z+2, r29	; 0x02
    7376:	c1 83       	std	Z+1, r28	; 0x01
    7378:	8a e1       	ldi	r24, 0x1A	; 26
    737a:	90 e1       	ldi	r25, 0x10	; 16
    737c:	94 83       	std	Z+4, r25	; 0x04
    737e:	83 83       	std	Z+3, r24	; 0x03
    7380:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7384:	0f 90       	pop	r0
    7386:	0f 90       	pop	r0
    7388:	0f 90       	pop	r0
    738a:	0f 90       	pop	r0
}
    738c:	df 91       	pop	r29
    738e:	cf 91       	pop	r28
    7390:	1f 91       	pop	r17
    7392:	0f 91       	pop	r16
    7394:	ff 90       	pop	r15
    7396:	ef 90       	pop	r14
    7398:	08 95       	ret

0000739a <arpIpOut>:
  }
// no space in table, we give up
}

void arpIpOut(uint32_t phyDstIp)
{
    739a:	cf 93       	push	r28
    739c:	df 93       	push	r29
    739e:	ab 01       	movw	r20, r22
    73a0:	bc 01       	movw	r22, r24
  int index;
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    73a2:	41 15       	cp	r20, r1
    73a4:	51 05       	cpc	r21, r1
    73a6:	61 05       	cpc	r22, r1
    73a8:	71 05       	cpc	r23, r1
    73aa:	a9 f0       	breq	.+42     	; 0x73d6 <arpIpOut+0x3c>
    73ac:	ef e6       	ldi	r30, 0x6F	; 111
    73ae:	ff e0       	ldi	r31, 0x0F	; 15
    73b0:	20 e0       	ldi	r18, 0x00	; 0
    73b2:	30 e0       	ldi	r19, 0x00	; 0
    73b4:	e9 01       	movw	r28, r18
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    73b6:	80 81       	ld	r24, Z
    73b8:	91 81       	ldd	r25, Z+1	; 0x01
    73ba:	a2 81       	ldd	r26, Z+2	; 0x02
    73bc:	b3 81       	ldd	r27, Z+3	; 0x03
    73be:	84 17       	cp	r24, r20
    73c0:	95 07       	cpc	r25, r21
    73c2:	a6 07       	cpc	r26, r22
    73c4:	b7 07       	cpc	r27, r23
    73c6:	d1 f1       	breq	.+116    	; 0x743c <arpIpOut+0xa2>
    73c8:	2f 5f       	subi	r18, 0xFF	; 255
    73ca:	3f 4f       	sbci	r19, 0xFF	; 255
    73cc:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    73ce:	2a 30       	cpi	r18, 0x0A	; 10
    73d0:	31 05       	cpc	r19, r1
    73d2:	81 f7       	brne	.-32     	; 0x73b4 <arpIpOut+0x1a>
    73d4:	1c c0       	rjmp	.+56     	; 0x740e <arpIpOut+0x74>
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    index = arpMatchIp(phyDstIp);
  else
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
    73d6:	e0 91 88 0e 	lds	r30, 0x0E88
    73da:	f0 91 89 0e 	lds	r31, 0x0E89
    73de:	40 89       	ldd	r20, Z+16	; 0x10
    73e0:	51 89       	ldd	r21, Z+17	; 0x11
    73e2:	62 89       	ldd	r22, Z+18	; 0x12
    73e4:	73 89       	ldd	r23, Z+19	; 0x13
    73e6:	ef e6       	ldi	r30, 0x6F	; 111
    73e8:	ff e0       	ldi	r31, 0x0F	; 15
    73ea:	20 e0       	ldi	r18, 0x00	; 0
    73ec:	30 e0       	ldi	r19, 0x00	; 0
    73ee:	e9 01       	movw	r28, r18
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    73f0:	80 81       	ld	r24, Z
    73f2:	91 81       	ldd	r25, Z+1	; 0x01
    73f4:	a2 81       	ldd	r26, Z+2	; 0x02
    73f6:	b3 81       	ldd	r27, Z+3	; 0x03
    73f8:	84 17       	cp	r24, r20
    73fa:	95 07       	cpc	r25, r21
    73fc:	a6 07       	cpc	r26, r22
    73fe:	b7 07       	cpc	r27, r23
    7400:	e9 f0       	breq	.+58     	; 0x743c <arpIpOut+0xa2>
    7402:	2f 5f       	subi	r18, 0xFF	; 255
    7404:	3f 4f       	sbci	r19, 0xFF	; 255
    7406:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    7408:	2a 30       	cpi	r18, 0x0A	; 10
    740a:	31 05       	cpc	r19, r1
    740c:	81 f7       	brne	.-32     	; 0x73ee <arpIpOut+0x54>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
  }
  else
  {
// not in table, must send ARP request
    nicState.layer2.ethHeader->src      = nicState.mac;
    740e:	e0 91 86 0e 	lds	r30, 0x0E86
    7412:	f0 91 87 0e 	lds	r31, 0x0E87
    7416:	36 96       	adiw	r30, 0x06	; 6
    7418:	a0 e8       	ldi	r26, 0x80	; 128
    741a:	be e0       	ldi	r27, 0x0E	; 14
    741c:	86 e0       	ldi	r24, 0x06	; 6
    741e:	0d 90       	ld	r0, X+
    7420:	01 92       	st	Z+, r0
    7422:	81 50       	subi	r24, 0x01	; 1
    7424:	e1 f7       	brne	.-8      	; 0x741e <arpIpOut+0x84>
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    7426:	80 91 86 0e 	lds	r24, 0x0E86
    742a:	90 91 87 0e 	lds	r25, 0x0E87
    742e:	6f ef       	ldi	r22, 0xFF	; 255
    7430:	70 e0       	ldi	r23, 0x00	; 0
    7432:	46 e0       	ldi	r20, 0x06	; 6
    7434:	50 e0       	ldi	r21, 0x00	; 0
    7436:	0e 94 5f 5c 	call	0xb8be	; 0xb8be <memset>
    743a:	22 c0       	rjmp	.+68     	; 0x7480 <arpIpOut+0xe6>
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
// fill in ethernet info
  if(index != -1)
  {
// ARP entry present, fill eth address(es)
    nicState.layer2.ethHeader->src      = nicState.mac;
    743c:	e0 91 86 0e 	lds	r30, 0x0E86
    7440:	f0 91 87 0e 	lds	r31, 0x0E87
    7444:	36 96       	adiw	r30, 0x06	; 6
    7446:	a0 e8       	ldi	r26, 0x80	; 128
    7448:	be e0       	ldi	r27, 0x0E	; 14
    744a:	86 e0       	ldi	r24, 0x06	; 6
    744c:	0d 90       	ld	r0, X+
    744e:	01 92       	st	Z+, r0
    7450:	81 50       	subi	r24, 0x01	; 1
    7452:	e1 f7       	brne	.-8      	; 0x744c <arpIpOut+0xb2>
    nicState.layer2.ethHeader->dest     = ArpTable[index].ethaddr;
    7454:	8b e0       	ldi	r24, 0x0B	; 11
    7456:	90 e0       	ldi	r25, 0x00	; 0
    7458:	c8 9f       	mul	r28, r24
    745a:	f0 01       	movw	r30, r0
    745c:	c9 9f       	mul	r28, r25
    745e:	f0 0d       	add	r31, r0
    7460:	d8 9f       	mul	r29, r24
    7462:	f0 0d       	add	r31, r0
    7464:	11 24       	eor	r1, r1
    7466:	20 91 86 0e 	lds	r18, 0x0E86
    746a:	30 91 87 0e 	lds	r19, 0x0E87
    746e:	c9 01       	movw	r24, r18
    7470:	dc 01       	movw	r26, r24
    7472:	ed 58       	subi	r30, 0x8D	; 141
    7474:	f0 4f       	sbci	r31, 0xF0	; 240
    7476:	86 e0       	ldi	r24, 0x06	; 6
    7478:	01 90       	ld	r0, Z+
    747a:	0d 92       	st	X+, r0
    747c:	81 50       	subi	r24, 0x01	; 1
    747e:	e1 f7       	brne	.-8      	; 0x7478 <arpIpOut+0xde>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
    7480:	e0 91 86 0e 	lds	r30, 0x0E86
    7484:	f0 91 87 0e 	lds	r31, 0x0E87
    7488:	88 e0       	ldi	r24, 0x08	; 8
    748a:	90 e0       	ldi	r25, 0x00	; 0
    748c:	95 87       	std	Z+13, r25	; 0x0d
    748e:	84 87       	std	Z+12, r24	; 0x0c
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}
    7490:	df 91       	pop	r29
    7492:	cf 91       	pop	r28
    7494:	08 95       	ret

00007496 <arpInit>:
#endif /*ARP_DEBUG*/

void arpInit()
{

  memset(ArpTable, 0, sizeof(ArpTable));
    7496:	8e e6       	ldi	r24, 0x6E	; 110
    7498:	ef e6       	ldi	r30, 0x6F	; 111
    749a:	ff e0       	ldi	r31, 0x0F	; 15
    749c:	df 01       	movw	r26, r30
    749e:	1d 92       	st	X+, r1
    74a0:	8a 95       	dec	r24
    74a2:	e9 f7       	brne	.-6      	; 0x749e <arpInit+0x8>
  arpDebug = NULL;
    74a4:	10 92 8d 0e 	sts	0x0E8D, r1
    74a8:	10 92 8c 0e 	sts	0x0E8C, r1
}
    74ac:	08 95       	ret

000074ae <arpArpIn>:

void arpArpIn(void)
{
    74ae:	0f 93       	push	r16
    74b0:	1f 93       	push	r17
    74b2:	cf 93       	push	r28
    74b4:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    74b6:	20 91 8c 0e 	lds	r18, 0x0E8C
    74ba:	30 91 8d 0e 	lds	r19, 0x0E8D
    74be:	21 15       	cp	r18, r1
    74c0:	31 05       	cpc	r19, r1
    74c2:	11 f1       	breq	.+68     	; 0x7508 <arpArpIn+0x5a>
  {
    if (arpDebugLevel > 1)
    74c4:	80 91 64 0f 	lds	r24, 0x0F64
    74c8:	82 30       	cpi	r24, 0x02	; 2
    74ca:	80 f0       	brcs	.+32     	; 0x74ec <arpArpIn+0x3e>
      fprintf_P(arpDebug, PSTR("Received ARP Request\r\n"));
    74cc:	00 d0       	rcall	.+0      	; 0x74ce <arpArpIn+0x20>
    74ce:	00 d0       	rcall	.+0      	; 0x74d0 <arpArpIn+0x22>
    74d0:	ed b7       	in	r30, 0x3d	; 61
    74d2:	fe b7       	in	r31, 0x3e	; 62
    74d4:	32 83       	std	Z+2, r19	; 0x02
    74d6:	21 83       	std	Z+1, r18	; 0x01
    74d8:	85 ec       	ldi	r24, 0xC5	; 197
    74da:	90 e1       	ldi	r25, 0x10	; 16
    74dc:	94 83       	std	Z+4, r25	; 0x04
    74de:	83 83       	std	Z+3, r24	; 0x03
    74e0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    74e4:	0f 90       	pop	r0
    74e6:	0f 90       	pop	r0
    74e8:	0f 90       	pop	r0
    74ea:	0f 90       	pop	r0
    if (arpDebugLevel > 2)
    74ec:	80 91 64 0f 	lds	r24, 0x0F64
    74f0:	83 30       	cpi	r24, 0x03	; 3
    74f2:	50 f0       	brcs	.+20     	; 0x7508 <arpArpIn+0x5a>
      arpPrintHeader(arpDebug, nicState.layer3.arp);   
    74f4:	60 91 88 0e 	lds	r22, 0x0E88
    74f8:	70 91 89 0e 	lds	r23, 0x0E89
    74fc:	80 91 8c 0e 	lds	r24, 0x0E8C
    7500:	90 91 8d 0e 	lds	r25, 0x0E8D
    7504:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <arpPrintHeader>
  }
#endif

// for now, we just reply to requests
// need to add ARP cache
  if((nicState.layer3.arp->dipaddr == IpMyConfig.ip) && (nicState.layer3.arp->opcode == htons(ARP_OPCODE_REQUEST)) )
    7508:	e0 91 88 0e 	lds	r30, 0x0E88
    750c:	f0 91 89 0e 	lds	r31, 0x0E89
    7510:	20 8d       	ldd	r18, Z+24	; 0x18
    7512:	31 8d       	ldd	r19, Z+25	; 0x19
    7514:	42 8d       	ldd	r20, Z+26	; 0x1a
    7516:	53 8d       	ldd	r21, Z+27	; 0x1b
    7518:	80 91 55 0f 	lds	r24, 0x0F55
    751c:	90 91 56 0f 	lds	r25, 0x0F56
    7520:	a0 91 57 0f 	lds	r26, 0x0F57
    7524:	b0 91 58 0f 	lds	r27, 0x0F58
    7528:	28 17       	cp	r18, r24
    752a:	39 07       	cpc	r19, r25
    752c:	4a 07       	cpc	r20, r26
    752e:	5b 07       	cpc	r21, r27
    7530:	09 f0       	breq	.+2      	; 0x7534 <arpArpIn+0x86>
    7532:	84 c0       	rjmp	.+264    	; 0x763c <arpArpIn+0x18e>
    7534:	06 81       	ldd	r16, Z+6	; 0x06
    7536:	17 81       	ldd	r17, Z+7	; 0x07
    7538:	81 e0       	ldi	r24, 0x01	; 1
    753a:	90 e0       	ldi	r25, 0x00	; 0
    753c:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7540:	08 17       	cp	r16, r24
    7542:	19 07       	cpc	r17, r25
    7544:	09 f0       	breq	.+2      	; 0x7548 <arpArpIn+0x9a>
    7546:	7a c0       	rjmp	.+244    	; 0x763c <arpArpIn+0x18e>
  {
// in ARP header
// copy sender's address info to dest. fields
    nicState.layer3.arp->dhwaddr = nicState.layer3.arp->shwaddr;
    7548:	e0 91 88 0e 	lds	r30, 0x0E88
    754c:	f0 91 89 0e 	lds	r31, 0x0E89
    7550:	ef 01       	movw	r28, r30
    7552:	62 96       	adiw	r28, 0x12	; 18
    7554:	df 01       	movw	r26, r30
    7556:	18 96       	adiw	r26, 0x08	; 8
    7558:	86 e0       	ldi	r24, 0x06	; 6
    755a:	0d 90       	ld	r0, X+
    755c:	09 92       	st	Y+, r0
    755e:	81 50       	subi	r24, 0x01	; 1
    7560:	e1 f7       	brne	.-8      	; 0x755a <arpArpIn+0xac>
    nicState.layer3.arp->dipaddr = nicState.layer3.arp->sipaddr;
    7562:	86 85       	ldd	r24, Z+14	; 0x0e
    7564:	97 85       	ldd	r25, Z+15	; 0x0f
    7566:	a0 89       	ldd	r26, Z+16	; 0x10
    7568:	b1 89       	ldd	r27, Z+17	; 0x11
    756a:	80 8f       	std	Z+24, r24	; 0x18
    756c:	91 8f       	std	Z+25, r25	; 0x19
    756e:	a2 8f       	std	Z+26, r26	; 0x1a
    7570:	b3 8f       	std	Z+27, r27	; 0x1b
// fill in our information
    nicState.layer3.arp->shwaddr =  nicState.mac;
    7572:	df 01       	movw	r26, r30
    7574:	18 96       	adiw	r26, 0x08	; 8
    7576:	e0 e8       	ldi	r30, 0x80	; 128
    7578:	fe e0       	ldi	r31, 0x0E	; 14
    757a:	86 e0       	ldi	r24, 0x06	; 6
    757c:	01 90       	ld	r0, Z+
    757e:	0d 92       	st	X+, r0
    7580:	81 50       	subi	r24, 0x01	; 1
    7582:	e1 f7       	brne	.-8      	; 0x757c <arpArpIn+0xce>
    nicState.layer3.arp->sipaddr =  IpMyConfig.ip;
    7584:	00 91 88 0e 	lds	r16, 0x0E88
    7588:	10 91 89 0e 	lds	r17, 0x0E89
    758c:	80 91 55 0f 	lds	r24, 0x0F55
    7590:	90 91 56 0f 	lds	r25, 0x0F56
    7594:	a0 91 57 0f 	lds	r26, 0x0F57
    7598:	b0 91 58 0f 	lds	r27, 0x0F58
    759c:	f8 01       	movw	r30, r16
    759e:	86 87       	std	Z+14, r24	; 0x0e
    75a0:	97 87       	std	Z+15, r25	; 0x0f
    75a2:	a0 8b       	std	Z+16, r26	; 0x10
    75a4:	b1 8b       	std	Z+17, r27	; 0x11
// change op to reply
    nicState.layer3.arp->opcode = htons(ARP_OPCODE_REPLY);
    75a6:	82 e0       	ldi	r24, 0x02	; 2
    75a8:	90 e0       	ldi	r25, 0x00	; 0
    75aa:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    75ae:	f8 01       	movw	r30, r16
    75b0:	97 83       	std	Z+7, r25	; 0x07
    75b2:	86 83       	std	Z+6, r24	; 0x06

// in ethernet header
    nicState.layer2.ethHeader->dest = nicState.layer2.ethHeader->src;
    75b4:	e0 91 86 0e 	lds	r30, 0x0E86
    75b8:	f0 91 87 0e 	lds	r31, 0x0E87
    75bc:	df 01       	movw	r26, r30
    75be:	16 96       	adiw	r26, 0x06	; 6
    75c0:	86 e0       	ldi	r24, 0x06	; 6
    75c2:	0d 90       	ld	r0, X+
    75c4:	01 92       	st	Z+, r0
    75c6:	81 50       	subi	r24, 0x01	; 1
    75c8:	e1 f7       	brne	.-8      	; 0x75c2 <arpArpIn+0x114>
    nicState.layer2.ethHeader->src  = nicState.mac;
    75ca:	e0 91 86 0e 	lds	r30, 0x0E86
    75ce:	f0 91 87 0e 	lds	r31, 0x0E87
    75d2:	36 96       	adiw	r30, 0x06	; 6
    75d4:	a0 e8       	ldi	r26, 0x80	; 128
    75d6:	be e0       	ldi	r27, 0x0E	; 14
    75d8:	86 e0       	ldi	r24, 0x06	; 6
    75da:	0d 90       	ld	r0, X+
    75dc:	01 92       	st	Z+, r0
    75de:	81 50       	subi	r24, 0x01	; 1
    75e0:	e1 f7       	brne	.-8      	; 0x75da <arpArpIn+0x12c>

#ifdef ARP_DEBUG
    if (arpDebug != NULL)
    75e2:	20 91 8c 0e 	lds	r18, 0x0E8C
    75e6:	30 91 8d 0e 	lds	r19, 0x0E8D
    75ea:	21 15       	cp	r18, r1
    75ec:	31 05       	cpc	r19, r1
    75ee:	11 f1       	breq	.+68     	; 0x7634 <arpArpIn+0x186>
    {
      if (arpDebugLevel > 0)
    75f0:	80 91 64 0f 	lds	r24, 0x0F64
    75f4:	88 23       	and	r24, r24
    75f6:	81 f0       	breq	.+32     	; 0x7618 <arpArpIn+0x16a>
        fprintf_P(arpDebug, PSTR("Sending ARP Reply\r\n"));
    75f8:	00 d0       	rcall	.+0      	; 0x75fa <arpArpIn+0x14c>
    75fa:	00 d0       	rcall	.+0      	; 0x75fc <arpArpIn+0x14e>
    75fc:	ed b7       	in	r30, 0x3d	; 61
    75fe:	fe b7       	in	r31, 0x3e	; 62
    7600:	32 83       	std	Z+2, r19	; 0x02
    7602:	21 83       	std	Z+1, r18	; 0x01
    7604:	81 eb       	ldi	r24, 0xB1	; 177
    7606:	90 e1       	ldi	r25, 0x10	; 16
    7608:	94 83       	std	Z+4, r25	; 0x04
    760a:	83 83       	std	Z+3, r24	; 0x03
    760c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7610:	0f 90       	pop	r0
    7612:	0f 90       	pop	r0
    7614:	0f 90       	pop	r0
    7616:	0f 90       	pop	r0
      if (arpDebugLevel > 2)
    7618:	80 91 64 0f 	lds	r24, 0x0F64
    761c:	83 30       	cpi	r24, 0x03	; 3
    761e:	50 f0       	brcs	.+20     	; 0x7634 <arpArpIn+0x186>
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    7620:	60 91 88 0e 	lds	r22, 0x0E88
    7624:	70 91 89 0e 	lds	r23, 0x0E89
    7628:	80 91 8c 0e 	lds	r24, 0x0E8C
    762c:	90 91 8d 0e 	lds	r25, 0x0E8D
    7630:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <arpPrintHeader>
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    7634:	8a e2       	ldi	r24, 0x2A	; 42
    7636:	90 e0       	ldi	r25, 0x00	; 0
    7638:	0e 94 be 2c 	call	0x597c	; 0x597c <nicSend>
  }
}
    763c:	df 91       	pop	r29
    763e:	cf 91       	pop	r28
    7640:	1f 91       	pop	r17
    7642:	0f 91       	pop	r16
    7644:	08 95       	ret

00007646 <sendTcBuffer>:

uint8_t sendTcBuffer(uint8_t socketNo)
{
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    7646:	80 e0       	ldi	r24, 0x00	; 0
    7648:	08 95       	ret

0000764a <setTcpDebug>:
}

#if TCP_DEBUG
void setTcpDebug(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    764a:	90 93 54 0f 	sts	0x0F54, r25
    764e:	80 93 53 0f 	sts	0x0F53, r24
  tcpDebugLevel = level;
    7652:	60 93 a5 0e 	sts	0x0EA5, r22
}
    7656:	08 95       	ret

00007658 <flushTcpQueues>:
  for (sckNo = 0; sckNo < NUMBER_OF_SOCKETS; sckNo++)
  {
    
    sck++;
  }
}
    7658:	08 95       	ret

0000765a <httpProcess>:
          continue;  
        }
      }

#endif
    765a:	08 95       	ret

0000765c <calculateTcpChecksun>:
  
  return 0;
}

void calculateTcpChecksun(uint16_t tcpLen)
{
    765c:	0f 93       	push	r16
    765e:	1f 93       	push	r17
    7660:	bc 01       	movw	r22, r24
  nicState.layer4.tcp->tcpchksum = 0;
    7662:	00 91 8a 0e 	lds	r16, 0x0E8A
    7666:	10 91 8b 0e 	lds	r17, 0x0E8B
    766a:	f8 01       	movw	r30, r16
    766c:	11 8a       	std	Z+17, r1	; 0x11
    766e:	10 8a       	std	Z+16, r1	; 0x10
  nicState.layer4.tcp->tcpchksum = netChecksum(nicState.layer4.tcp, tcpLen); //TODO finish it
    7670:	c8 01       	movw	r24, r16
    7672:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <netChecksum>
    7676:	f8 01       	movw	r30, r16
    7678:	91 8b       	std	Z+17, r25	; 0x11
    767a:	80 8b       	std	Z+16, r24	; 0x10
}
    767c:	1f 91       	pop	r17
    767e:	0f 91       	pop	r16
    7680:	08 95       	ret

00007682 <processTcpPacket>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket(void)
{
    7682:	af 92       	push	r10
    7684:	bf 92       	push	r11
    7686:	cf 92       	push	r12
    7688:	df 92       	push	r13
    768a:	ef 92       	push	r14
    768c:	ff 92       	push	r15
    768e:	0f 93       	push	r16
    7690:	1f 93       	push	r17
    7692:	cf 93       	push	r28
    7694:	df 93       	push	r29
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    7696:	e0 91 c1 0e 	lds	r30, 0x0EC1
    769a:	f0 91 c2 0e 	lds	r31, 0x0EC2
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
    769e:	e0 90 88 0e 	lds	r14, 0x0E88
    76a2:	f0 90 89 0e 	lds	r15, 0x0E89
    76a6:	60 91 8a 0e 	lds	r22, 0x0E8A
    76aa:	70 91 8b 0e 	lds	r23, 0x0E8B
    76ae:	ef 01       	movw	r28, r30
    76b0:	00 e0       	ldi	r16, 0x00	; 0
    76b2:	18 81       	ld	r17, Y
    76b4:	12 30       	cpi	r17, 0x02	; 2
    76b6:	08 f4       	brcc	.+2      	; 0x76ba <processTcpPacket+0x38>
    76b8:	4b c0       	rjmp	.+150    	; 0x7750 <processTcpPacket+0xce>
    76ba:	29 81       	ldd	r18, Y+1	; 0x01
    76bc:	3a 81       	ldd	r19, Y+2	; 0x02
    76be:	4b 81       	ldd	r20, Y+3	; 0x03
    76c0:	5c 81       	ldd	r21, Y+4	; 0x04
    76c2:	d7 01       	movw	r26, r14
    76c4:	1c 96       	adiw	r26, 0x0c	; 12
    76c6:	ad 90       	ld	r10, X+
    76c8:	bd 90       	ld	r11, X+
    76ca:	cd 90       	ld	r12, X+
    76cc:	dc 90       	ld	r13, X
    76ce:	1f 97       	sbiw	r26, 0x0f	; 15
    76d0:	2a 15       	cp	r18, r10
    76d2:	3b 05       	cpc	r19, r11
    76d4:	4c 05       	cpc	r20, r12
    76d6:	5d 05       	cpc	r21, r13
    76d8:	d9 f5       	brne	.+118    	; 0x7750 <processTcpPacket+0xce>
    76da:	2d 81       	ldd	r18, Y+5	; 0x05
    76dc:	3e 81       	ldd	r19, Y+6	; 0x06
    76de:	db 01       	movw	r26, r22
    76e0:	12 96       	adiw	r26, 0x02	; 2
    76e2:	8d 91       	ld	r24, X+
    76e4:	9c 91       	ld	r25, X
    76e6:	13 97       	sbiw	r26, 0x03	; 3
    76e8:	28 17       	cp	r18, r24
    76ea:	39 07       	cpc	r19, r25
    76ec:	89 f5       	brne	.+98     	; 0x7750 <processTcpPacket+0xce>
    76ee:	2f 81       	ldd	r18, Y+7	; 0x07
    76f0:	38 85       	ldd	r19, Y+8	; 0x08
    76f2:	8d 91       	ld	r24, X+
    76f4:	9c 91       	ld	r25, X
    76f6:	28 17       	cp	r18, r24
    76f8:	39 07       	cpc	r19, r25
    76fa:	51 f5       	brne	.+84     	; 0x7750 <processTcpPacket+0xce>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    76fc:	20 91 53 0f 	lds	r18, 0x0F53
    7700:	30 91 54 0f 	lds	r19, 0x0F54
    7704:	21 15       	cp	r18, r1
    7706:	31 05       	cpc	r19, r1
    7708:	09 f4       	brne	.+2      	; 0x770c <processTcpPacket+0x8a>
    770a:	9d c0       	rjmp	.+314    	; 0x7846 <processTcpPacket+0x1c4>
        if (tcpDebugLevel > 2)
    770c:	80 91 a5 0e 	lds	r24, 0x0EA5
    7710:	83 30       	cpi	r24, 0x03	; 3
    7712:	08 f4       	brcc	.+2      	; 0x7716 <processTcpPacket+0x94>
    7714:	98 c0       	rjmp	.+304    	; 0x7846 <processTcpPacket+0x1c4>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    7716:	00 d0       	rcall	.+0      	; 0x7718 <processTcpPacket+0x96>
    7718:	00 d0       	rcall	.+0      	; 0x771a <processTcpPacket+0x98>
    771a:	00 d0       	rcall	.+0      	; 0x771c <processTcpPacket+0x9a>
    771c:	ed b7       	in	r30, 0x3d	; 61
    771e:	fe b7       	in	r31, 0x3e	; 62
    7720:	31 96       	adiw	r30, 0x01	; 1
    7722:	ad b7       	in	r26, 0x3d	; 61
    7724:	be b7       	in	r27, 0x3e	; 62
    7726:	12 96       	adiw	r26, 0x02	; 2
    7728:	3c 93       	st	X, r19
    772a:	2e 93       	st	-X, r18
    772c:	11 97       	sbiw	r26, 0x01	; 1
    772e:	85 e3       	ldi	r24, 0x35	; 53
    7730:	92 e1       	ldi	r25, 0x12	; 18
    7732:	93 83       	std	Z+3, r25	; 0x03
    7734:	82 83       	std	Z+2, r24	; 0x02
    7736:	14 83       	std	Z+4, r17	; 0x04
    7738:	15 82       	std	Z+5, r1	; 0x05
    773a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    773e:	ed b7       	in	r30, 0x3d	; 61
    7740:	fe b7       	in	r31, 0x3e	; 62
    7742:	36 96       	adiw	r30, 0x06	; 6
    7744:	0f b6       	in	r0, 0x3f	; 63
    7746:	f8 94       	cli
    7748:	fe bf       	out	0x3e, r31	; 62
    774a:	0f be       	out	0x3f, r0	; 63
    774c:	ed bf       	out	0x3d, r30	; 61
    774e:	7b c0       	rjmp	.+246    	; 0x7846 <processTcpPacket+0x1c4>

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    7750:	0f 5f       	subi	r16, 0xFF	; 255
    7752:	04 31       	cpi	r16, 0x14	; 20
    7754:	11 f0       	breq	.+4      	; 0x775a <processTcpPacket+0xd8>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
#endif      
      return result;
    }
    result++;
    7756:	6c 96       	adiw	r28, 0x1c	; 28
    7758:	ac cf       	rjmp	.-168    	; 0x76b2 <processTcpPacket+0x30>
    775a:	00 e0       	ldi	r16, 0x00	; 0
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    775c:	80 81       	ld	r24, Z
    775e:	81 30       	cpi	r24, 0x01	; 1
    7760:	e1 f5       	brne	.+120    	; 0x77da <processTcpPacket+0x158>
    7762:	25 81       	ldd	r18, Z+5	; 0x05
    7764:	36 81       	ldd	r19, Z+6	; 0x06
    7766:	db 01       	movw	r26, r22
    7768:	12 96       	adiw	r26, 0x02	; 2
    776a:	8d 91       	ld	r24, X+
    776c:	9c 91       	ld	r25, X
    776e:	13 97       	sbiw	r26, 0x03	; 3
    7770:	28 17       	cp	r18, r24
    7772:	39 07       	cpc	r19, r25
    7774:	91 f5       	brne	.+100    	; 0x77da <processTcpPacket+0x158>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    7776:	20 91 53 0f 	lds	r18, 0x0F53
    777a:	30 91 54 0f 	lds	r19, 0x0F54
    777e:	21 15       	cp	r18, r1
    7780:	31 05       	cpc	r19, r1
    7782:	01 f1       	breq	.+64     	; 0x77c4 <processTcpPacket+0x142>
        if (tcpDebugLevel > 2)
    7784:	80 91 a5 0e 	lds	r24, 0x0EA5
    7788:	83 30       	cpi	r24, 0x03	; 3
    778a:	e0 f0       	brcs	.+56     	; 0x77c4 <processTcpPacket+0x142>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    778c:	00 d0       	rcall	.+0      	; 0x778e <processTcpPacket+0x10c>
    778e:	00 d0       	rcall	.+0      	; 0x7790 <processTcpPacket+0x10e>
    7790:	00 d0       	rcall	.+0      	; 0x7792 <processTcpPacket+0x110>
    7792:	ed b7       	in	r30, 0x3d	; 61
    7794:	fe b7       	in	r31, 0x3e	; 62
    7796:	31 96       	adiw	r30, 0x01	; 1
    7798:	ad b7       	in	r26, 0x3d	; 61
    779a:	be b7       	in	r27, 0x3e	; 62
    779c:	12 96       	adiw	r26, 0x02	; 2
    779e:	3c 93       	st	X, r19
    77a0:	2e 93       	st	-X, r18
    77a2:	11 97       	sbiw	r26, 0x01	; 1
    77a4:	8f e0       	ldi	r24, 0x0F	; 15
    77a6:	92 e1       	ldi	r25, 0x12	; 18
    77a8:	93 83       	std	Z+3, r25	; 0x03
    77aa:	82 83       	std	Z+2, r24	; 0x02
    77ac:	04 83       	std	Z+4, r16	; 0x04
    77ae:	15 82       	std	Z+5, r1	; 0x05
    77b0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    77b4:	ed b7       	in	r30, 0x3d	; 61
    77b6:	fe b7       	in	r31, 0x3e	; 62
    77b8:	36 96       	adiw	r30, 0x06	; 6
    77ba:	0f b6       	in	r0, 0x3f	; 63
    77bc:	f8 94       	cli
    77be:	fe bf       	out	0x3e, r31	; 62
    77c0:	0f be       	out	0x3f, r0	; 63
    77c2:	ed bf       	out	0x3d, r30	; 61
#endif      
      return &sockets[i];
    77c4:	8c e1       	ldi	r24, 0x1C	; 28
    77c6:	08 9f       	mul	r16, r24
    77c8:	c0 01       	movw	r24, r0
    77ca:	11 24       	eor	r1, r1
    77cc:	c0 91 c1 0e 	lds	r28, 0x0EC1
    77d0:	d0 91 c2 0e 	lds	r29, 0x0EC2
    77d4:	c8 0f       	add	r28, r24
    77d6:	d9 1f       	adc	r29, r25
    77d8:	36 c0       	rjmp	.+108    	; 0x7846 <processTcpPacket+0x1c4>
    }
    result++;
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    77da:	0f 5f       	subi	r16, 0xFF	; 255
    77dc:	04 31       	cpi	r16, 0x14	; 20
    77de:	11 f0       	breq	.+4      	; 0x77e4 <processTcpPacket+0x162>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
#endif      
      return &sockets[i];
    }
    result++;
    77e0:	7c 96       	adiw	r30, 0x1c	; 28
    77e2:	bc cf       	rjmp	.-136    	; 0x775c <processTcpPacket+0xda>
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    77e4:	c0 91 53 0f 	lds	r28, 0x0F53
    77e8:	d0 91 54 0f 	lds	r29, 0x0F54
    77ec:	20 97       	sbiw	r28, 0x00	; 0
    77ee:	09 f4       	brne	.+2      	; 0x77f2 <processTcpPacket+0x170>
    77f0:	64 c1       	rjmp	.+712    	; 0x7aba <processTcpPacket+0x438>
    if (tcpDebugLevel > 2)
    77f2:	80 91 a5 0e 	lds	r24, 0x0EA5
    77f6:	83 30       	cpi	r24, 0x03	; 3
    77f8:	08 f4       	brcc	.+2      	; 0x77fc <processTcpPacket+0x17a>
    77fa:	5f c1       	rjmp	.+702    	; 0x7aba <processTcpPacket+0x438>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    77fc:	db 01       	movw	r26, r22
    77fe:	12 96       	adiw	r26, 0x02	; 2
    7800:	8d 91       	ld	r24, X+
    7802:	9c 91       	ld	r25, X
    7804:	13 97       	sbiw	r26, 0x03	; 3
    7806:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    780a:	00 d0       	rcall	.+0      	; 0x780c <processTcpPacket+0x18a>
    780c:	00 d0       	rcall	.+0      	; 0x780e <processTcpPacket+0x18c>
    780e:	00 d0       	rcall	.+0      	; 0x7810 <processTcpPacket+0x18e>
    7810:	ed b7       	in	r30, 0x3d	; 61
    7812:	fe b7       	in	r31, 0x3e	; 62
    7814:	31 96       	adiw	r30, 0x01	; 1
    7816:	ad b7       	in	r26, 0x3d	; 61
    7818:	be b7       	in	r27, 0x3e	; 62
    781a:	12 96       	adiw	r26, 0x02	; 2
    781c:	dc 93       	st	X, r29
    781e:	ce 93       	st	-X, r28
    7820:	11 97       	sbiw	r26, 0x01	; 1
    7822:	25 ee       	ldi	r18, 0xE5	; 229
    7824:	31 e1       	ldi	r19, 0x11	; 17
    7826:	33 83       	std	Z+3, r19	; 0x03
    7828:	22 83       	std	Z+2, r18	; 0x02
    782a:	95 83       	std	Z+5, r25	; 0x05
    782c:	84 83       	std	Z+4, r24	; 0x04
    782e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7832:	81 e0       	ldi	r24, 0x01	; 1
    7834:	ed b7       	in	r30, 0x3d	; 61
    7836:	fe b7       	in	r31, 0x3e	; 62
    7838:	36 96       	adiw	r30, 0x06	; 6
    783a:	0f b6       	in	r0, 0x3f	; 63
    783c:	f8 94       	cli
    783e:	fe bf       	out	0x3e, r31	; 62
    7840:	0f be       	out	0x3f, r0	; 63
    7842:	ed bf       	out	0x3d, r30	; 61
    7844:	3d c1       	rjmp	.+634    	; 0x7ac0 <processTcpPacket+0x43e>

inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    7846:	20 97       	sbiw	r28, 0x00	; 0
    7848:	09 f4       	brne	.+2      	; 0x784c <processTcpPacket+0x1ca>
    784a:	37 c1       	rjmp	.+622    	; 0x7aba <processTcpPacket+0x438>
    return 1;
  
  
  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    784c:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7850:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7854:	64 81       	ldd	r22, Z+4	; 0x04
    7856:	75 81       	ldd	r23, Z+5	; 0x05
    7858:	86 81       	ldd	r24, Z+6	; 0x06
    785a:	97 81       	ldd	r25, Z+7	; 0x07
    785c:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <htonl>
    7860:	69 87       	std	Y+9, r22	; 0x09
    7862:	7a 87       	std	Y+10, r23	; 0x0a
    7864:	8b 87       	std	Y+11, r24	; 0x0b
    7866:	9c 87       	std	Y+12, r25	; 0x0c
  
  if (socket->state == LISTEN)
    7868:	88 81       	ld	r24, Y
    786a:	81 30       	cpi	r24, 0x01	; 1
    786c:	09 f0       	breq	.+2      	; 0x7870 <processTcpPacket+0x1ee>
    786e:	b5 c0       	rjmp	.+362    	; 0x79da <processTcpPacket+0x358>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    7870:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7874:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7878:	85 85       	ldd	r24, Z+13	; 0x0d
    787a:	20 91 53 0f 	lds	r18, 0x0F53
    787e:	30 91 54 0f 	lds	r19, 0x0F54
    7882:	81 ff       	sbrs	r24, 1
    7884:	96 c0       	rjmp	.+300    	; 0x79b2 <processTcpPacket+0x330>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    7886:	21 15       	cp	r18, r1
    7888:	31 05       	cpc	r19, r1
    788a:	c1 f0       	breq	.+48     	; 0x78bc <processTcpPacket+0x23a>
        if (tcpDebugLevel > 2)
    788c:	80 91 a5 0e 	lds	r24, 0x0EA5
    7890:	83 30       	cpi	r24, 0x03	; 3
    7892:	a0 f0       	brcs	.+40     	; 0x78bc <processTcpPacket+0x23a>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    7894:	00 d0       	rcall	.+0      	; 0x7896 <processTcpPacket+0x214>
    7896:	00 d0       	rcall	.+0      	; 0x7898 <processTcpPacket+0x216>
    7898:	ad b7       	in	r26, 0x3d	; 61
    789a:	be b7       	in	r27, 0x3e	; 62
    789c:	12 96       	adiw	r26, 0x02	; 2
    789e:	3c 93       	st	X, r19
    78a0:	2e 93       	st	-X, r18
    78a2:	11 97       	sbiw	r26, 0x01	; 1
    78a4:	83 ea       	ldi	r24, 0xA3	; 163
    78a6:	91 e1       	ldi	r25, 0x11	; 17
    78a8:	14 96       	adiw	r26, 0x04	; 4
    78aa:	9c 93       	st	X, r25
    78ac:	8e 93       	st	-X, r24
    78ae:	13 97       	sbiw	r26, 0x03	; 3
    78b0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    78b4:	0f 90       	pop	r0
    78b6:	0f 90       	pop	r0
    78b8:	0f 90       	pop	r0
    78ba:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    78bc:	82 e0       	ldi	r24, 0x02	; 2
    78be:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    78c0:	e0 91 8a 0e 	lds	r30, 0x0E8A
    78c4:	f0 91 8b 0e 	lds	r31, 0x0E8B
    78c8:	80 81       	ld	r24, Z
    78ca:	91 81       	ldd	r25, Z+1	; 0x01
    78cc:	98 87       	std	Y+8, r25	; 0x08
    78ce:	8f 83       	std	Y+7, r24	; 0x07
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    78d0:	e0 91 88 0e 	lds	r30, 0x0E88
    78d4:	f0 91 89 0e 	lds	r31, 0x0E89
    78d8:	84 85       	ldd	r24, Z+12	; 0x0c
    78da:	95 85       	ldd	r25, Z+13	; 0x0d
    78dc:	a6 85       	ldd	r26, Z+14	; 0x0e
    78de:	b7 85       	ldd	r27, Z+15	; 0x0f
    78e0:	89 83       	std	Y+1, r24	; 0x01
    78e2:	9a 83       	std	Y+2, r25	; 0x02
    78e4:	ab 83       	std	Y+3, r26	; 0x03
    78e6:	bc 83       	std	Y+4, r27	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    78e8:	e0 91 8a 0e 	lds	r30, 0x0E8A
    78ec:	f0 91 8b 0e 	lds	r31, 0x0E8B
    78f0:	8d 81       	ldd	r24, Y+5	; 0x05
    78f2:	9e 81       	ldd	r25, Y+6	; 0x06
    78f4:	91 83       	std	Z+1, r25	; 0x01
    78f6:	80 83       	st	Z, r24
      nicState.layer4.tcp->destport  = socket->remotePort;
    78f8:	00 91 8a 0e 	lds	r16, 0x0E8A
    78fc:	10 91 8b 0e 	lds	r17, 0x0E8B
    7900:	8f 81       	ldd	r24, Y+7	; 0x07
    7902:	98 85       	ldd	r25, Y+8	; 0x08
    7904:	f8 01       	movw	r30, r16
    7906:	93 83       	std	Z+3, r25	; 0x03
    7908:	82 83       	std	Z+2, r24	; 0x02
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    790a:	6d 85       	ldd	r22, Y+13	; 0x0d
    790c:	7e 85       	ldd	r23, Y+14	; 0x0e
    790e:	8f 85       	ldd	r24, Y+15	; 0x0f
    7910:	98 89       	ldd	r25, Y+16	; 0x10
    7912:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <htonl>
    7916:	d8 01       	movw	r26, r16
    7918:	14 96       	adiw	r26, 0x04	; 4
    791a:	6d 93       	st	X+, r22
    791c:	7d 93       	st	X+, r23
    791e:	8d 93       	st	X+, r24
    7920:	9c 93       	st	X, r25
    7922:	17 97       	sbiw	r26, 0x07	; 7
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    7924:	00 91 8a 0e 	lds	r16, 0x0E8A
    7928:	10 91 8b 0e 	lds	r17, 0x0E8B
    792c:	69 85       	ldd	r22, Y+9	; 0x09
    792e:	7a 85       	ldd	r23, Y+10	; 0x0a
    7930:	8b 85       	ldd	r24, Y+11	; 0x0b
    7932:	9c 85       	ldd	r25, Y+12	; 0x0c
    7934:	6f 5f       	subi	r22, 0xFF	; 255
    7936:	7f 4f       	sbci	r23, 0xFF	; 255
    7938:	8f 4f       	sbci	r24, 0xFF	; 255
    793a:	9f 4f       	sbci	r25, 0xFF	; 255
    793c:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <htonl>
    7940:	f8 01       	movw	r30, r16
    7942:	60 87       	std	Z+8, r22	; 0x08
    7944:	71 87       	std	Z+9, r23	; 0x09
    7946:	82 87       	std	Z+10, r24	; 0x0a
    7948:	93 87       	std	Z+11, r25	; 0x0b
      nicState.layer4.tcp->tcpoffset = 5<<4;
    794a:	00 91 8a 0e 	lds	r16, 0x0E8A
    794e:	10 91 8b 0e 	lds	r17, 0x0E8B
    7952:	80 e5       	ldi	r24, 0x50	; 80
    7954:	d8 01       	movw	r26, r16
    7956:	1c 96       	adiw	r26, 0x0c	; 12
    7958:	8c 93       	st	X, r24
    795a:	1c 97       	sbiw	r26, 0x0c	; 12
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    795c:	82 e1       	ldi	r24, 0x12	; 18
    795e:	1d 96       	adiw	r26, 0x0d	; 13
    7960:	8c 93       	st	X, r24
      nicState.layer4.tcp->wnd       = htons(100);
    7962:	84 e6       	ldi	r24, 0x64	; 100
    7964:	90 e0       	ldi	r25, 0x00	; 0
    7966:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    796a:	f8 01       	movw	r30, r16
    796c:	97 87       	std	Z+15, r25	; 0x0f
    796e:	86 87       	std	Z+14, r24	; 0x0e
      nicState.layer4.tcp->tcpchksum = 0;
    7970:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7974:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7978:	11 8a       	std	Z+17, r1	; 0x11
    797a:	10 8a       	std	Z+16, r1	; 0x10
      nicState.layer4.tcp->urgp      = 0;
    797c:	13 8a       	std	Z+19, r1	; 0x13
    797e:	12 8a       	std	Z+18, r1	; 0x12
      calculateTcpChecksun(TCP_HEADER_LEN);
    7980:	84 e1       	ldi	r24, 0x14	; 20
    7982:	90 e0       	ldi	r25, 0x00	; 0
    7984:	0e 94 2e 3b 	call	0x765c	; 0x765c <calculateTcpChecksun>

      socket->seqNoLastSent++;
    7988:	8d 85       	ldd	r24, Y+13	; 0x0d
    798a:	9e 85       	ldd	r25, Y+14	; 0x0e
    798c:	af 85       	ldd	r26, Y+15	; 0x0f
    798e:	b8 89       	ldd	r27, Y+16	; 0x10
    7990:	01 96       	adiw	r24, 0x01	; 1
    7992:	a1 1d       	adc	r26, r1
    7994:	b1 1d       	adc	r27, r1
    7996:	8d 87       	std	Y+13, r24	; 0x0d
    7998:	9e 87       	std	Y+14, r25	; 0x0e
    799a:	af 87       	std	Y+15, r26	; 0x0f
    799c:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    799e:	69 81       	ldd	r22, Y+1	; 0x01
    79a0:	7a 81       	ldd	r23, Y+2	; 0x02
    79a2:	8b 81       	ldd	r24, Y+3	; 0x03
    79a4:	9c 81       	ldd	r25, Y+4	; 0x04
    79a6:	46 e0       	ldi	r20, 0x06	; 6
    79a8:	24 e1       	ldi	r18, 0x14	; 20
    79aa:	30 e0       	ldi	r19, 0x00	; 0
    79ac:	0e 94 39 33 	call	0x6672	; 0x6672 <ipSend>
    79b0:	86 c0       	rjmp	.+268    	; 0x7abe <processTcpPacket+0x43c>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    79b2:	21 15       	cp	r18, r1
    79b4:	31 05       	cpc	r19, r1
    79b6:	09 f4       	brne	.+2      	; 0x79ba <processTcpPacket+0x338>
    79b8:	82 c0       	rjmp	.+260    	; 0x7abe <processTcpPacket+0x43c>
        if (tcpDebugLevel > 1)
    79ba:	80 91 a5 0e 	lds	r24, 0x0EA5
    79be:	82 30       	cpi	r24, 0x02	; 2
    79c0:	08 f4       	brcc	.+2      	; 0x79c4 <processTcpPacket+0x342>
    79c2:	7d c0       	rjmp	.+250    	; 0x7abe <processTcpPacket+0x43c>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    79c4:	00 d0       	rcall	.+0      	; 0x79c6 <processTcpPacket+0x344>
    79c6:	00 d0       	rcall	.+0      	; 0x79c8 <processTcpPacket+0x346>
    79c8:	ad b7       	in	r26, 0x3d	; 61
    79ca:	be b7       	in	r27, 0x3e	; 62
    79cc:	12 96       	adiw	r26, 0x02	; 2
    79ce:	3c 93       	st	X, r19
    79d0:	2e 93       	st	-X, r18
    79d2:	11 97       	sbiw	r26, 0x01	; 1
    79d4:	8f e6       	ldi	r24, 0x6F	; 111
    79d6:	91 e1       	ldi	r25, 0x11	; 17
    79d8:	39 c0       	rjmp	.+114    	; 0x7a4c <processTcpPacket+0x3ca>
    }
#endif    
    return 0;
  }
  
  if (socket->state == SYN_RECEIVED)
    79da:	82 30       	cpi	r24, 0x02	; 2
    79dc:	09 f0       	breq	.+2      	; 0x79e0 <processTcpPacket+0x35e>
    79de:	42 c0       	rjmp	.+132    	; 0x7a64 <processTcpPacket+0x3e2>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    79e0:	e0 91 8a 0e 	lds	r30, 0x0E8A
    79e4:	f0 91 8b 0e 	lds	r31, 0x0E8B
    79e8:	85 85       	ldd	r24, Z+13	; 0x0d
    79ea:	20 91 53 0f 	lds	r18, 0x0F53
    79ee:	30 91 54 0f 	lds	r19, 0x0F54
    79f2:	84 ff       	sbrs	r24, 4
    79f4:	16 c0       	rjmp	.+44     	; 0x7a22 <processTcpPacket+0x3a0>
    {
      socket->state    = ESTABILISHED;
    79f6:	83 e0       	ldi	r24, 0x03	; 3
    79f8:	88 83       	st	Y, r24
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    79fa:	21 15       	cp	r18, r1
    79fc:	31 05       	cpc	r19, r1
    79fe:	09 f4       	brne	.+2      	; 0x7a02 <processTcpPacket+0x380>
    7a00:	5e c0       	rjmp	.+188    	; 0x7abe <processTcpPacket+0x43c>
      if (tcpDebugLevel > 2)
    7a02:	80 91 a5 0e 	lds	r24, 0x0EA5
    7a06:	83 30       	cpi	r24, 0x03	; 3
    7a08:	08 f4       	brcc	.+2      	; 0x7a0c <processTcpPacket+0x38a>
    7a0a:	59 c0       	rjmp	.+178    	; 0x7abe <processTcpPacket+0x43c>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    7a0c:	00 d0       	rcall	.+0      	; 0x7a0e <processTcpPacket+0x38c>
    7a0e:	00 d0       	rcall	.+0      	; 0x7a10 <processTcpPacket+0x38e>
    7a10:	ed b7       	in	r30, 0x3d	; 61
    7a12:	fe b7       	in	r31, 0x3e	; 62
    7a14:	32 83       	std	Z+2, r19	; 0x02
    7a16:	21 83       	std	Z+1, r18	; 0x01
    7a18:	87 e2       	ldi	r24, 0x27	; 39
    7a1a:	91 e1       	ldi	r25, 0x11	; 17
    7a1c:	94 83       	std	Z+4, r25	; 0x04
    7a1e:	83 83       	std	Z+3, r24	; 0x03
    7a20:	19 c0       	rjmp	.+50     	; 0x7a54 <processTcpPacket+0x3d2>
#endif        

    }
    else
    {
      socket->state = LISTEN;
    7a22:	81 e0       	ldi	r24, 0x01	; 1
    7a24:	88 83       	st	Y, r24
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    7a26:	21 15       	cp	r18, r1
    7a28:	31 05       	cpc	r19, r1
    7a2a:	09 f4       	brne	.+2      	; 0x7a2e <processTcpPacket+0x3ac>
    7a2c:	48 c0       	rjmp	.+144    	; 0x7abe <processTcpPacket+0x43c>
        if (tcpDebugLevel > 1)
    7a2e:	80 91 a5 0e 	lds	r24, 0x0EA5
    7a32:	82 30       	cpi	r24, 0x02	; 2
    7a34:	08 f4       	brcc	.+2      	; 0x7a38 <processTcpPacket+0x3b6>
    7a36:	43 c0       	rjmp	.+134    	; 0x7abe <processTcpPacket+0x43c>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    7a38:	00 d0       	rcall	.+0      	; 0x7a3a <processTcpPacket+0x3b8>
    7a3a:	00 d0       	rcall	.+0      	; 0x7a3c <processTcpPacket+0x3ba>
    7a3c:	ad b7       	in	r26, 0x3d	; 61
    7a3e:	be b7       	in	r27, 0x3e	; 62
    7a40:	12 96       	adiw	r26, 0x02	; 2
    7a42:	3c 93       	st	X, r19
    7a44:	2e 93       	st	-X, r18
    7a46:	11 97       	sbiw	r26, 0x01	; 1
    7a48:	83 ef       	ldi	r24, 0xF3	; 243
    7a4a:	90 e1       	ldi	r25, 0x10	; 16
    7a4c:	14 96       	adiw	r26, 0x04	; 4
    7a4e:	9c 93       	st	X, r25
    7a50:	8e 93       	st	-X, r24
    7a52:	13 97       	sbiw	r26, 0x03	; 3
    7a54:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7a58:	80 e0       	ldi	r24, 0x00	; 0
    7a5a:	0f 90       	pop	r0
    7a5c:	0f 90       	pop	r0
    7a5e:	0f 90       	pop	r0
    7a60:	0f 90       	pop	r0
    7a62:	2e c0       	rjmp	.+92     	; 0x7ac0 <processTcpPacket+0x43e>
    }
    return 0;
  }
  
  
  if (socket->state == ESTABILISHED)
    7a64:	83 30       	cpi	r24, 0x03	; 3
    7a66:	59 f5       	brne	.+86     	; 0x7abe <processTcpPacket+0x43c>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    7a68:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7a6c:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7a70:	85 85       	ldd	r24, Z+13	; 0x0d
    7a72:	80 ff       	sbrs	r24, 0
    7a74:	24 c0       	rjmp	.+72     	; 0x7abe <processTcpPacket+0x43c>
    {
      socket->timer              = timer100Hz;
    7a76:	80 91 88 01 	lds	r24, 0x0188
    7a7a:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    7a7c:	80 e1       	ldi	r24, 0x10	; 16
    7a7e:	85 87       	std	Z+13, r24	; 0x0d
//      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
//      {
//        dataFromBufLen++;
//        dataPtr++;
//      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    7a80:	69 81       	ldd	r22, Y+1	; 0x01
    7a82:	7a 81       	ldd	r23, Y+2	; 0x02
    7a84:	8b 81       	ldd	r24, Y+3	; 0x03
    7a86:	9c 81       	ldd	r25, Y+4	; 0x04
    7a88:	46 e0       	ldi	r20, 0x06	; 6
    7a8a:	24 e1       	ldi	r18, 0x14	; 20
    7a8c:	30 e0       	ldi	r19, 0x00	; 0
    7a8e:	0e 94 39 33 	call	0x6672	; 0x6672 <ipSend>
      socket->state    = CLOSE_WAIT;
    7a92:	84 e0       	ldi	r24, 0x04	; 4
    7a94:	88 83       	st	Y, r24
      
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    7a96:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7a9a:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7a9e:	81 e0       	ldi	r24, 0x01	; 1
    7aa0:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    7aa2:	69 81       	ldd	r22, Y+1	; 0x01
    7aa4:	7a 81       	ldd	r23, Y+2	; 0x02
    7aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    7aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    7aaa:	46 e0       	ldi	r20, 0x06	; 6
    7aac:	24 e1       	ldi	r18, 0x14	; 20
    7aae:	30 e0       	ldi	r19, 0x00	; 0
    7ab0:	0e 94 39 33 	call	0x6672	; 0x6672 <ipSend>
      socket->state    = LAST_ACK;
    7ab4:	85 e0       	ldi	r24, 0x05	; 5
    7ab6:	88 83       	st	Y, r24
    7ab8:	02 c0       	rjmp	.+4      	; 0x7abe <processTcpPacket+0x43c>
    7aba:	81 e0       	ldi	r24, 0x01	; 1
    7abc:	01 c0       	rjmp	.+2      	; 0x7ac0 <processTcpPacket+0x43e>
    7abe:	80 e0       	ldi	r24, 0x00	; 0
  }

  //Read data and put into the queue
  
  return 0;
}
    7ac0:	df 91       	pop	r29
    7ac2:	cf 91       	pop	r28
    7ac4:	1f 91       	pop	r17
    7ac6:	0f 91       	pop	r16
    7ac8:	ff 90       	pop	r15
    7aca:	ef 90       	pop	r14
    7acc:	df 90       	pop	r13
    7ace:	cf 90       	pop	r12
    7ad0:	bf 90       	pop	r11
    7ad2:	af 90       	pop	r10
    7ad4:	08 95       	ret

00007ad6 <netstackTCPIPProcess>:
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}

void netstackTCPIPProcess(void)
{
    7ad6:	0f 93       	push	r16
    7ad8:	1f 93       	push	r17
  if (nicState.layer4.tcp->destport == htons(80))
    7ada:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7ade:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7ae2:	02 81       	ldd	r16, Z+2	; 0x02
    7ae4:	13 81       	ldd	r17, Z+3	; 0x03
    7ae6:	80 e5       	ldi	r24, 0x50	; 80
    7ae8:	90 e0       	ldi	r25, 0x00	; 0
    7aea:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7aee:	08 17       	cp	r16, r24
    7af0:	19 07       	cpc	r17, r25
    7af2:	b9 f4       	brne	.+46     	; 0x7b22 <netstackTCPIPProcess+0x4c>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    7af4:	80 91 53 0f 	lds	r24, 0x0F53
    7af8:	90 91 54 0f 	lds	r25, 0x0F54
    7afc:	00 97       	sbiw	r24, 0x00	; 0
    7afe:	99 f0       	breq	.+38     	; 0x7b26 <netstackTCPIPProcess+0x50>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    7b00:	00 d0       	rcall	.+0      	; 0x7b02 <netstackTCPIPProcess+0x2c>
    7b02:	00 d0       	rcall	.+0      	; 0x7b04 <netstackTCPIPProcess+0x2e>
    7b04:	ed b7       	in	r30, 0x3d	; 61
    7b06:	fe b7       	in	r31, 0x3e	; 62
    7b08:	92 83       	std	Z+2, r25	; 0x02
    7b0a:	81 83       	std	Z+1, r24	; 0x01
    7b0c:	8c ed       	ldi	r24, 0xDC	; 220
    7b0e:	90 e1       	ldi	r25, 0x10	; 16
    7b10:	94 83       	std	Z+4, r25	; 0x04
    7b12:	83 83       	std	Z+3, r24	; 0x03
    7b14:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7b18:	0f 90       	pop	r0
    7b1a:	0f 90       	pop	r0
    7b1c:	0f 90       	pop	r0
    7b1e:	0f 90       	pop	r0
    7b20:	02 c0       	rjmp	.+4      	; 0x7b26 <netstackTCPIPProcess+0x50>
#endif
    ;
  }
  else
  {
    processTcpPacket();
    7b22:	0e 94 41 3b 	call	0x7682	; 0x7682 <processTcpPacket>
  }
}
    7b26:	1f 91       	pop	r17
    7b28:	0f 91       	pop	r16
    7b2a:	08 95       	ret

00007b2c <socketInit>:
 * @param *sck socket
 */
static inline void tcpAcceptConn(struct TcpIpSocket *sck);

inline void socketInit(void)
{
    7b2c:	bf 92       	push	r11
    7b2e:	cf 92       	push	r12
    7b30:	df 92       	push	r13
    7b32:	ef 92       	push	r14
    7b34:	ff 92       	push	r15
    7b36:	0f 93       	push	r16
    7b38:	1f 93       	push	r17
    7b3a:	cf 93       	push	r28
    7b3c:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    7b3e:	80 e3       	ldi	r24, 0x30	; 48
    7b40:	92 e0       	ldi	r25, 0x02	; 2
    7b42:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    7b46:	80 93 c1 0e 	sts	0x0EC1, r24
    7b4a:	90 93 c2 0e 	sts	0x0EC2, r25
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    7b4e:	fc 01       	movw	r30, r24
    7b50:	80 e3       	ldi	r24, 0x30	; 48
    7b52:	92 e0       	ldi	r25, 0x02	; 2
    7b54:	df 01       	movw	r26, r30
    7b56:	9c 01       	movw	r18, r24
    7b58:	1d 92       	st	X+, r1
    7b5a:	21 50       	subi	r18, 0x01	; 1
    7b5c:	30 40       	sbci	r19, 0x00	; 0
    7b5e:	e1 f7       	brne	.-8      	; 0x7b58 <socketInit+0x2c>
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    7b60:	00 91 c1 0e 	lds	r16, 0x0EC1
    7b64:	10 91 c2 0e 	lds	r17, 0x0EC2
    7b68:	c8 ea       	ldi	r28, 0xA8	; 168
    7b6a:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7b6c:	8f ef       	ldi	r24, 0xFF	; 255
    7b6e:	c8 2e       	mov	r12, r24
    7b70:	81 e1       	ldi	r24, 0x11	; 17
    7b72:	d8 2e       	mov	r13, r24
    7b74:	82 e2       	ldi	r24, 0x22	; 34
    7b76:	e8 2e       	mov	r14, r24
    7b78:	83 e3       	ldi	r24, 0x33	; 51
    7b7a:	f8 2e       	mov	r15, r24
    sck->state         = LISTEN;   
    7b7c:	bb 24       	eor	r11, r11
    7b7e:	b3 94       	inc	r11
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    7b80:	de 01       	movw	r26, r28
    7b82:	a8 5a       	subi	r26, 0xA8	; 168
    7b84:	a0 31       	cpi	r26, 0x10	; 16
    7b86:	18 f0       	brcs	.+6      	; 0x7b8e <socketInit+0x62>
    7b88:	88 eb       	ldi	r24, 0xB8	; 184
    7b8a:	91 e6       	ldi	r25, 0x61	; 97
    7b8c:	03 c0       	rjmp	.+6      	; 0x7b94 <socketInit+0x68>
    7b8e:	ce 01       	movw	r24, r28
    7b90:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7b94:	f8 01       	movw	r30, r16
    7b96:	96 83       	std	Z+6, r25	; 0x06
    7b98:	85 83       	std	Z+5, r24	; 0x05
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7b9a:	d8 01       	movw	r26, r16
    7b9c:	1d 96       	adiw	r26, 0x0d	; 13
    7b9e:	cd 92       	st	X+, r12
    7ba0:	dd 92       	st	X+, r13
    7ba2:	ed 92       	st	X+, r14
    7ba4:	fc 92       	st	X, r15
    7ba6:	50 97       	sbiw	r26, 0x10	; 16
    sck->state         = LISTEN;   
    7ba8:	bc 92       	st	X, r11
    7baa:	21 96       	adiw	r28, 0x01	; 1
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    7bac:	b1 e6       	ldi	r27, 0x61	; 97
    7bae:	cc 3b       	cpi	r28, 0xBC	; 188
    7bb0:	db 07       	cpc	r29, r27
    7bb2:	19 f0       	breq	.+6      	; 0x7bba <socketInit+0x8e>
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    sck->state         = LISTEN;   
    sck++;
    7bb4:	04 5e       	subi	r16, 0xE4	; 228
    7bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    7bb8:	e3 cf       	rjmp	.-58     	; 0x7b80 <socketInit+0x54>
  }
}
    7bba:	df 91       	pop	r29
    7bbc:	cf 91       	pop	r28
    7bbe:	1f 91       	pop	r17
    7bc0:	0f 91       	pop	r16
    7bc2:	ff 90       	pop	r15
    7bc4:	ef 90       	pop	r14
    7bc6:	df 90       	pop	r13
    7bc8:	cf 90       	pop	r12
    7bca:	bf 90       	pop	r11
    7bcc:	08 95       	ret

00007bce <setUdpDebug>:
}

#if UDP_DEBUG
void setUdpDebug(FILE *stream, uint8_t level)
{
  udpDbgStream = stream;
    7bce:	90 93 c6 0e 	sts	0x0EC6, r25
    7bd2:	80 93 c5 0e 	sts	0x0EC5, r24
  udpDbgLevel = level;
    7bd6:	60 93 7d 0e 	sts	0x0E7D, r22
}
    7bda:	08 95       	ret

00007bdc <udpPrintStatus>:
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
}

void udpPrintStatus(FILE *stream)
{
    7bdc:	cf 93       	push	r28
    7bde:	df 93       	push	r29
    7be0:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR("UDP config:"));
    7be2:	00 d0       	rcall	.+0      	; 0x7be4 <udpPrintStatus+0x8>
    7be4:	00 d0       	rcall	.+0      	; 0x7be6 <udpPrintStatus+0xa>
    7be6:	ad b7       	in	r26, 0x3d	; 61
    7be8:	be b7       	in	r27, 0x3e	; 62
    7bea:	12 96       	adiw	r26, 0x02	; 2
    7bec:	9c 93       	st	X, r25
    7bee:	8e 93       	st	-X, r24
    7bf0:	11 97       	sbiw	r26, 0x01	; 1
    7bf2:	86 e9       	ldi	r24, 0x96	; 150
    7bf4:	92 e1       	ldi	r25, 0x12	; 18
    7bf6:	14 96       	adiw	r26, 0x04	; 4
    7bf8:	9c 93       	st	X, r25
    7bfa:	8e 93       	st	-X, r24
    7bfc:	13 97       	sbiw	r26, 0x03	; 3
    7bfe:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n  IP          : ")); netPrintIPAddr(stream, udpSocket->dstIp);
    7c02:	ed b7       	in	r30, 0x3d	; 61
    7c04:	fe b7       	in	r31, 0x3e	; 62
    7c06:	d2 83       	std	Z+2, r29	; 0x02
    7c08:	c1 83       	std	Z+1, r28	; 0x01
    7c0a:	83 e8       	ldi	r24, 0x83	; 131
    7c0c:	92 e1       	ldi	r25, 0x12	; 18
    7c0e:	94 83       	std	Z+4, r25	; 0x04
    7c10:	83 83       	std	Z+3, r24	; 0x03
    7c12:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7c16:	0f 90       	pop	r0
    7c18:	0f 90       	pop	r0
    7c1a:	0f 90       	pop	r0
    7c1c:	0f 90       	pop	r0
    7c1e:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7c22:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7c26:	46 81       	ldd	r20, Z+6	; 0x06
    7c28:	57 81       	ldd	r21, Z+7	; 0x07
    7c2a:	60 85       	ldd	r22, Z+8	; 0x08
    7c2c:	71 85       	ldd	r23, Z+9	; 0x09
    7c2e:	ce 01       	movw	r24, r28
    7c30:	0e 94 20 30 	call	0x6040	; 0x6040 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n  src port    : %d\r\n  dst port    : "), htons(udpSocket->srcPort));
    7c34:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7c38:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7c3c:	84 81       	ldd	r24, Z+4	; 0x04
    7c3e:	95 81       	ldd	r25, Z+5	; 0x05
    7c40:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7c44:	00 d0       	rcall	.+0      	; 0x7c46 <udpPrintStatus+0x6a>
    7c46:	00 d0       	rcall	.+0      	; 0x7c48 <udpPrintStatus+0x6c>
    7c48:	00 d0       	rcall	.+0      	; 0x7c4a <udpPrintStatus+0x6e>
    7c4a:	ed b7       	in	r30, 0x3d	; 61
    7c4c:	fe b7       	in	r31, 0x3e	; 62
    7c4e:	31 96       	adiw	r30, 0x01	; 1
    7c50:	ad b7       	in	r26, 0x3d	; 61
    7c52:	be b7       	in	r27, 0x3e	; 62
    7c54:	12 96       	adiw	r26, 0x02	; 2
    7c56:	dc 93       	st	X, r29
    7c58:	ce 93       	st	-X, r28
    7c5a:	11 97       	sbiw	r26, 0x01	; 1
    7c5c:	2c e5       	ldi	r18, 0x5C	; 92
    7c5e:	32 e1       	ldi	r19, 0x12	; 18
    7c60:	33 83       	std	Z+3, r19	; 0x03
    7c62:	22 83       	std	Z+2, r18	; 0x02
    7c64:	95 83       	std	Z+5, r25	; 0x05
    7c66:	84 83       	std	Z+4, r24	; 0x04
    7c68:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
  if (udpSocket->dstPortDef == HTONS(0))
    7c6c:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7c70:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7c74:	80 81       	ld	r24, Z
    7c76:	91 81       	ldd	r25, Z+1	; 0x01
    7c78:	ed b7       	in	r30, 0x3d	; 61
    7c7a:	fe b7       	in	r31, 0x3e	; 62
    7c7c:	36 96       	adiw	r30, 0x06	; 6
    7c7e:	0f b6       	in	r0, 0x3f	; 63
    7c80:	f8 94       	cli
    7c82:	fe bf       	out	0x3e, r31	; 62
    7c84:	0f be       	out	0x3f, r0	; 63
    7c86:	ed bf       	out	0x3d, r30	; 61
    7c88:	00 97       	sbiw	r24, 0x00	; 0
    7c8a:	a9 f4       	brne	.+42     	; 0x7cb6 <udpPrintStatus+0xda>
    fprintf_P(stream, PSTR("ANY\r\n"));
    7c8c:	00 d0       	rcall	.+0      	; 0x7c8e <udpPrintStatus+0xb2>
    7c8e:	00 d0       	rcall	.+0      	; 0x7c90 <udpPrintStatus+0xb4>
    7c90:	ad b7       	in	r26, 0x3d	; 61
    7c92:	be b7       	in	r27, 0x3e	; 62
    7c94:	12 96       	adiw	r26, 0x02	; 2
    7c96:	dc 93       	st	X, r29
    7c98:	ce 93       	st	-X, r28
    7c9a:	11 97       	sbiw	r26, 0x01	; 1
    7c9c:	86 e5       	ldi	r24, 0x56	; 86
    7c9e:	92 e1       	ldi	r25, 0x12	; 18
    7ca0:	14 96       	adiw	r26, 0x04	; 4
    7ca2:	9c 93       	st	X, r25
    7ca4:	8e 93       	st	-X, r24
    7ca6:	13 97       	sbiw	r26, 0x03	; 3
    7ca8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7cac:	0f 90       	pop	r0
    7cae:	0f 90       	pop	r0
    7cb0:	0f 90       	pop	r0
    7cb2:	0f 90       	pop	r0
    7cb4:	1e c0       	rjmp	.+60     	; 0x7cf2 <udpPrintStatus+0x116>
  else
    fprintf_P(stream, PSTR("%d\r\n"), htons(udpSocket->dstPortDef));    
    7cb6:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7cba:	00 d0       	rcall	.+0      	; 0x7cbc <udpPrintStatus+0xe0>
    7cbc:	00 d0       	rcall	.+0      	; 0x7cbe <udpPrintStatus+0xe2>
    7cbe:	00 d0       	rcall	.+0      	; 0x7cc0 <udpPrintStatus+0xe4>
    7cc0:	ed b7       	in	r30, 0x3d	; 61
    7cc2:	fe b7       	in	r31, 0x3e	; 62
    7cc4:	31 96       	adiw	r30, 0x01	; 1
    7cc6:	ad b7       	in	r26, 0x3d	; 61
    7cc8:	be b7       	in	r27, 0x3e	; 62
    7cca:	12 96       	adiw	r26, 0x02	; 2
    7ccc:	dc 93       	st	X, r29
    7cce:	ce 93       	st	-X, r28
    7cd0:	11 97       	sbiw	r26, 0x01	; 1
    7cd2:	21 e5       	ldi	r18, 0x51	; 81
    7cd4:	32 e1       	ldi	r19, 0x12	; 18
    7cd6:	33 83       	std	Z+3, r19	; 0x03
    7cd8:	22 83       	std	Z+2, r18	; 0x02
    7cda:	95 83       	std	Z+5, r25	; 0x05
    7cdc:	84 83       	std	Z+4, r24	; 0x04
    7cde:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7ce2:	ed b7       	in	r30, 0x3d	; 61
    7ce4:	fe b7       	in	r31, 0x3e	; 62
    7ce6:	36 96       	adiw	r30, 0x06	; 6
    7ce8:	0f b6       	in	r0, 0x3f	; 63
    7cea:	f8 94       	cli
    7cec:	fe bf       	out	0x3e, r31	; 62
    7cee:	0f be       	out	0x3f, r0	; 63
    7cf0:	ed bf       	out	0x3d, r30	; 61
}
    7cf2:	df 91       	pop	r29
    7cf4:	cf 91       	pop	r28
    7cf6:	08 95       	ret

00007cf8 <udpSaveConfig>:
  }
}

void udpSaveConfig(void)
{
  eeprom_update_dword(&udpIpDst_eep, udpSocket->dstIp);
    7cf8:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7cfc:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7d00:	46 81       	ldd	r20, Z+6	; 0x06
    7d02:	57 81       	ldd	r21, Z+7	; 0x07
    7d04:	60 85       	ldd	r22, Z+8	; 0x08
    7d06:	71 85       	ldd	r23, Z+9	; 0x09
    7d08:	8a e2       	ldi	r24, 0x2A	; 42
    7d0a:	90 e0       	ldi	r25, 0x00	; 0
    7d0c:	0e 94 fc 5f 	call	0xbff8	; 0xbff8 <__eeupd_dword_m128>
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
    7d10:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7d14:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7d18:	60 81       	ld	r22, Z
    7d1a:	71 81       	ldd	r23, Z+1	; 0x01
    7d1c:	8e e2       	ldi	r24, 0x2E	; 46
    7d1e:	90 e0       	ldi	r25, 0x00	; 0
    7d20:	0e 94 08 60 	call	0xc010	; 0xc010 <__eeupd_word_m128>
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
    7d24:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7d28:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7d2c:	64 81       	ldd	r22, Z+4	; 0x04
    7d2e:	75 81       	ldd	r23, Z+5	; 0x05
    7d30:	80 e3       	ldi	r24, 0x30	; 48
    7d32:	90 e0       	ldi	r25, 0x00	; 0
    7d34:	0e 94 08 60 	call	0xc010	; 0xc010 <__eeupd_word_m128>
}
    7d38:	08 95       	ret

00007d3a <netstackUDPIPProcess>:
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
}

inline void netstackUDPIPProcess(void)
{
    7d3a:	af 92       	push	r10
    7d3c:	bf 92       	push	r11
    7d3e:	cf 92       	push	r12
    7d40:	df 92       	push	r13
    7d42:	ff 92       	push	r15
    7d44:	0f 93       	push	r16
    7d46:	1f 93       	push	r17
    7d48:	cf 93       	push	r28
    7d4a:	df 93       	push	r29
  uint16_t len = (uint16_t) htons(nicState.layer4.udp->udplen);
    7d4c:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7d50:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7d54:	84 81       	ldd	r24, Z+4	; 0x04
    7d56:	95 81       	ldd	r25, Z+5	; 0x05
    7d58:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7d5c:	8c 01       	movw	r16, r24
  uint8_t i;

  #if UDP_DEBUG
  if(udpDbgStream != NULL)
    7d5e:	20 91 c5 0e 	lds	r18, 0x0EC5
    7d62:	30 91 c6 0e 	lds	r19, 0x0EC6
    7d66:	21 15       	cp	r18, r1
    7d68:	31 05       	cpc	r19, r1
    7d6a:	21 f1       	breq	.+72     	; 0x7db4 <netstackUDPIPProcess+0x7a>
    if (udpDbgLevel > 3)
    7d6c:	80 91 7d 0e 	lds	r24, 0x0E7D
    7d70:	84 30       	cpi	r24, 0x04	; 4
    7d72:	00 f1       	brcs	.+64     	; 0x7db4 <netstackUDPIPProcess+0x7a>
      fprintf_P(udpDbgStream, PSTR("Proc. UDP packet (data length %d)\r\n"), len-UDP_HEADER_LEN);
    7d74:	00 d0       	rcall	.+0      	; 0x7d76 <netstackUDPIPProcess+0x3c>
    7d76:	00 d0       	rcall	.+0      	; 0x7d78 <netstackUDPIPProcess+0x3e>
    7d78:	00 d0       	rcall	.+0      	; 0x7d7a <netstackUDPIPProcess+0x40>
    7d7a:	ed b7       	in	r30, 0x3d	; 61
    7d7c:	fe b7       	in	r31, 0x3e	; 62
    7d7e:	31 96       	adiw	r30, 0x01	; 1
    7d80:	ad b7       	in	r26, 0x3d	; 61
    7d82:	be b7       	in	r27, 0x3e	; 62
    7d84:	12 96       	adiw	r26, 0x02	; 2
    7d86:	3c 93       	st	X, r19
    7d88:	2e 93       	st	-X, r18
    7d8a:	11 97       	sbiw	r26, 0x01	; 1
    7d8c:	82 ed       	ldi	r24, 0xD2	; 210
    7d8e:	92 e1       	ldi	r25, 0x12	; 18
    7d90:	93 83       	std	Z+3, r25	; 0x03
    7d92:	82 83       	std	Z+2, r24	; 0x02
    7d94:	08 50       	subi	r16, 0x08	; 8
    7d96:	10 40       	sbci	r17, 0x00	; 0
    7d98:	15 83       	std	Z+5, r17	; 0x05
    7d9a:	04 83       	std	Z+4, r16	; 0x04
    7d9c:	08 5f       	subi	r16, 0xF8	; 248
    7d9e:	1f 4f       	sbci	r17, 0xFF	; 255
    7da0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7da4:	ed b7       	in	r30, 0x3d	; 61
    7da6:	fe b7       	in	r31, 0x3e	; 62
    7da8:	36 96       	adiw	r30, 0x06	; 6
    7daa:	0f b6       	in	r0, 0x3f	; 63
    7dac:	f8 94       	cli
    7dae:	fe bf       	out	0x3e, r31	; 62
    7db0:	0f be       	out	0x3f, r0	; 63
    7db2:	ed bf       	out	0x3d, r30	; 61
#endif

  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    7db4:	c0 91 8a 0e 	lds	r28, 0x0E8A
    7db8:	d0 91 8b 0e 	lds	r29, 0x0E8B
    7dbc:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7dc0:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7dc4:	2a 81       	ldd	r18, Y+2	; 0x02
    7dc6:	3b 81       	ldd	r19, Y+3	; 0x03
    7dc8:	84 81       	ldd	r24, Z+4	; 0x04
    7dca:	95 81       	ldd	r25, Z+5	; 0x05
    7dcc:	28 17       	cp	r18, r24
    7dce:	39 07       	cpc	r19, r25
    7dd0:	09 f0       	breq	.+2      	; 0x7dd4 <netstackUDPIPProcess+0x9a>
    7dd2:	aa c0       	rjmp	.+340    	; 0x7f28 <netstackUDPIPProcess+0x1ee>
    7dd4:	80 81       	ld	r24, Z
    7dd6:	91 81       	ldd	r25, Z+1	; 0x01
    7dd8:	28 81       	ld	r18, Y
    7dda:	39 81       	ldd	r19, Y+1	; 0x01
    7ddc:	89 2b       	or	r24, r25
    7dde:	39 f0       	breq	.+14     	; 0x7dee <netstackUDPIPProcess+0xb4>
    7de0:	82 81       	ldd	r24, Z+2	; 0x02
    7de2:	93 81       	ldd	r25, Z+3	; 0x03
    7de4:	82 17       	cp	r24, r18
    7de6:	93 07       	cpc	r25, r19
    7de8:	09 f0       	breq	.+2      	; 0x7dec <netstackUDPIPProcess+0xb2>
    7dea:	9e c0       	rjmp	.+316    	; 0x7f28 <netstackUDPIPProcess+0x1ee>
    7dec:	02 c0       	rjmp	.+4      	; 0x7df2 <netstackUDPIPProcess+0xb8>
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    7dee:	33 83       	std	Z+3, r19	; 0x03
    7df0:	22 83       	std	Z+2, r18	; 0x02
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7df2:	20 91 c5 0e 	lds	r18, 0x0EC5
    7df6:	30 91 c6 0e 	lds	r19, 0x0EC6
    7dfa:	21 15       	cp	r18, r1
    7dfc:	31 05       	cpc	r19, r1
    7dfe:	c1 f0       	breq	.+48     	; 0x7e30 <netstackUDPIPProcess+0xf6>
        if (udpDbgLevel > 4)
    7e00:	80 91 7d 0e 	lds	r24, 0x0E7D
    7e04:	85 30       	cpi	r24, 0x05	; 5
    7e06:	a0 f0       	brcs	.+40     	; 0x7e30 <netstackUDPIPProcess+0xf6>
          fprintf_P(udpDbgStream, PSTR("Received data: "));
    7e08:	00 d0       	rcall	.+0      	; 0x7e0a <netstackUDPIPProcess+0xd0>
    7e0a:	00 d0       	rcall	.+0      	; 0x7e0c <netstackUDPIPProcess+0xd2>
    7e0c:	ad b7       	in	r26, 0x3d	; 61
    7e0e:	be b7       	in	r27, 0x3e	; 62
    7e10:	12 96       	adiw	r26, 0x02	; 2
    7e12:	3c 93       	st	X, r19
    7e14:	2e 93       	st	-X, r18
    7e16:	11 97       	sbiw	r26, 0x01	; 1
    7e18:	82 ec       	ldi	r24, 0xC2	; 194
    7e1a:	92 e1       	ldi	r25, 0x12	; 18
    7e1c:	14 96       	adiw	r26, 0x04	; 4
    7e1e:	9c 93       	st	X, r25
    7e20:	8e 93       	st	-X, r24
    7e22:	13 97       	sbiw	r26, 0x03	; 3
    7e24:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7e28:	0f 90       	pop	r0
    7e2a:	0f 90       	pop	r0
    7e2c:	0f 90       	pop	r0
    7e2e:	0f 90       	pop	r0
  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7e30:	28 96       	adiw	r28, 0x08	; 8
    7e32:	28 e0       	ldi	r18, 0x08	; 8
    7e34:	f2 2e       	mov	r15, r18
    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7e36:	9a eb       	ldi	r25, 0xBA	; 186
    7e38:	a9 2e       	mov	r10, r25
    7e3a:	92 e1       	ldi	r25, 0x12	; 18
    7e3c:	b9 2e       	mov	r11, r25
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
        if(udpDbgStream != NULL)
          if (udpDbgLevel > 0)
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7e3e:	85 ea       	ldi	r24, 0xA5	; 165
    7e40:	c8 2e       	mov	r12, r24
    7e42:	82 e1       	ldi	r24, 0x12	; 18
    7e44:	d8 2e       	mov	r13, r24
    7e46:	4f c0       	rjmp	.+158    	; 0x7ee6 <netstackUDPIPProcess+0x1ac>
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7e48:	21 15       	cp	r18, r1
    7e4a:	31 05       	cpc	r19, r1
    7e4c:	f9 f0       	breq	.+62     	; 0x7e8c <netstackUDPIPProcess+0x152>
        if (udpDbgLevel > 4)
    7e4e:	80 91 7d 0e 	lds	r24, 0x0E7D
    7e52:	85 30       	cpi	r24, 0x05	; 5
    7e54:	d8 f0       	brcs	.+54     	; 0x7e8c <netstackUDPIPProcess+0x152>
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7e56:	00 d0       	rcall	.+0      	; 0x7e58 <netstackUDPIPProcess+0x11e>
    7e58:	00 d0       	rcall	.+0      	; 0x7e5a <netstackUDPIPProcess+0x120>
    7e5a:	00 d0       	rcall	.+0      	; 0x7e5c <netstackUDPIPProcess+0x122>
    7e5c:	ed b7       	in	r30, 0x3d	; 61
    7e5e:	fe b7       	in	r31, 0x3e	; 62
    7e60:	31 96       	adiw	r30, 0x01	; 1
    7e62:	ad b7       	in	r26, 0x3d	; 61
    7e64:	be b7       	in	r27, 0x3e	; 62
    7e66:	12 96       	adiw	r26, 0x02	; 2
    7e68:	3c 93       	st	X, r19
    7e6a:	2e 93       	st	-X, r18
    7e6c:	11 97       	sbiw	r26, 0x01	; 1
    7e6e:	b3 82       	std	Z+3, r11	; 0x03
    7e70:	a2 82       	std	Z+2, r10	; 0x02
    7e72:	88 81       	ld	r24, Y
    7e74:	84 83       	std	Z+4, r24	; 0x04
    7e76:	15 82       	std	Z+5, r1	; 0x05
    7e78:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7e7c:	ed b7       	in	r30, 0x3d	; 61
    7e7e:	fe b7       	in	r31, 0x3e	; 62
    7e80:	36 96       	adiw	r30, 0x06	; 6
    7e82:	0f b6       	in	r0, 0x3f	; 63
    7e84:	f8 94       	cli
    7e86:	fe bf       	out	0x3e, r31	; 62
    7e88:	0f be       	out	0x3f, r0	; 63
    7e8a:	ed bf       	out	0x3d, r30	; 61
#endif
#if UDB_DEBUG
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
    7e8c:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7e90:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7e94:	82 85       	ldd	r24, Z+10	; 0x0a
    7e96:	93 85       	ldd	r25, Z+11	; 0x0b
    7e98:	be 01       	movw	r22, r28
    7e9a:	4a e0       	ldi	r20, 0x0A	; 10
    7e9c:	50 e0       	ldi	r21, 0x00	; 0
    7e9e:	20 e0       	ldi	r18, 0x00	; 0
    7ea0:	0e 94 a0 54 	call	0xa940	; 0xa940 <xQueueGenericSend>
    7ea4:	88 23       	and	r24, r24
    7ea6:	e9 f4       	brne	.+58     	; 0x7ee2 <netstackUDPIPProcess+0x1a8>
        if(udpDbgStream != NULL)
    7ea8:	20 91 c5 0e 	lds	r18, 0x0EC5
    7eac:	30 91 c6 0e 	lds	r19, 0x0EC6
    7eb0:	21 15       	cp	r18, r1
    7eb2:	31 05       	cpc	r19, r1
    7eb4:	b1 f0       	breq	.+44     	; 0x7ee2 <netstackUDPIPProcess+0x1a8>
          if (udpDbgLevel > 0)
    7eb6:	80 91 7d 0e 	lds	r24, 0x0E7D
    7eba:	88 23       	and	r24, r24
    7ebc:	91 f0       	breq	.+36     	; 0x7ee2 <netstackUDPIPProcess+0x1a8>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7ebe:	00 d0       	rcall	.+0      	; 0x7ec0 <netstackUDPIPProcess+0x186>
    7ec0:	00 d0       	rcall	.+0      	; 0x7ec2 <netstackUDPIPProcess+0x188>
    7ec2:	ad b7       	in	r26, 0x3d	; 61
    7ec4:	be b7       	in	r27, 0x3e	; 62
    7ec6:	12 96       	adiw	r26, 0x02	; 2
    7ec8:	3c 93       	st	X, r19
    7eca:	2e 93       	st	-X, r18
    7ecc:	11 97       	sbiw	r26, 0x01	; 1
    7ece:	14 96       	adiw	r26, 0x04	; 4
    7ed0:	dc 92       	st	X, r13
    7ed2:	ce 92       	st	-X, r12
    7ed4:	13 97       	sbiw	r26, 0x03	; 3
    7ed6:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7eda:	0f 90       	pop	r0
    7edc:	0f 90       	pop	r0
    7ede:	0f 90       	pop	r0
    7ee0:	0f 90       	pop	r0
#endif
      tmp++;
    7ee2:	21 96       	adiw	r28, 0x01	; 1
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received data: "));
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    7ee4:	f3 94       	inc	r15
    7ee6:	8f 2d       	mov	r24, r15
    7ee8:	90 e0       	ldi	r25, 0x00	; 0
    7eea:	20 91 c5 0e 	lds	r18, 0x0EC5
    7eee:	30 91 c6 0e 	lds	r19, 0x0EC6
    7ef2:	80 17       	cp	r24, r16
    7ef4:	91 07       	cpc	r25, r17
    7ef6:	08 f4       	brcc	.+2      	; 0x7efa <netstackUDPIPProcess+0x1c0>
    7ef8:	a7 cf       	rjmp	.-178    	; 0x7e48 <netstackUDPIPProcess+0x10e>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
#endif
      tmp++;
    }
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    7efa:	21 15       	cp	r18, r1
    7efc:	31 05       	cpc	r19, r1
    7efe:	a1 f0       	breq	.+40     	; 0x7f28 <netstackUDPIPProcess+0x1ee>
      if (udpDbgLevel > 4)
    7f00:	80 91 7d 0e 	lds	r24, 0x0E7D
    7f04:	85 30       	cpi	r24, 0x05	; 5
    7f06:	80 f0       	brcs	.+32     	; 0x7f28 <netstackUDPIPProcess+0x1ee>
        fprintf_P(udpDbgStream, PSTR("\r\n"));
    7f08:	00 d0       	rcall	.+0      	; 0x7f0a <netstackUDPIPProcess+0x1d0>
    7f0a:	00 d0       	rcall	.+0      	; 0x7f0c <netstackUDPIPProcess+0x1d2>
    7f0c:	ed b7       	in	r30, 0x3d	; 61
    7f0e:	fe b7       	in	r31, 0x3e	; 62
    7f10:	32 83       	std	Z+2, r19	; 0x02
    7f12:	21 83       	std	Z+1, r18	; 0x01
    7f14:	82 ea       	ldi	r24, 0xA2	; 162
    7f16:	92 e1       	ldi	r25, 0x12	; 18
    7f18:	94 83       	std	Z+4, r25	; 0x04
    7f1a:	83 83       	std	Z+3, r24	; 0x03
    7f1c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7f20:	0f 90       	pop	r0
    7f22:	0f 90       	pop	r0
    7f24:	0f 90       	pop	r0
    7f26:	0f 90       	pop	r0
#endif

  }
}
    7f28:	df 91       	pop	r29
    7f2a:	cf 91       	pop	r28
    7f2c:	1f 91       	pop	r17
    7f2e:	0f 91       	pop	r16
    7f30:	ff 90       	pop	r15
    7f32:	df 90       	pop	r13
    7f34:	cf 90       	pop	r12
    7f36:	bf 90       	pop	r11
    7f38:	af 90       	pop	r10
    7f3a:	08 95       	ret

00007f3c <udpSend>:
  udpDbgLevel = level;
}
#endif

inline void udpSend(uint16_t len)
{
    7f3c:	ef 92       	push	r14
    7f3e:	ff 92       	push	r15
    7f40:	0f 93       	push	r16
    7f42:	1f 93       	push	r17
    7f44:	cf 93       	push	r28
    7f46:	df 93       	push	r29
    7f48:	7c 01       	movw	r14, r24
// make pointer to UDP header
  nicState.layer4.udp->srcport  = udpSocket->srcPort;
    7f4a:	c0 91 8a 0e 	lds	r28, 0x0E8A
    7f4e:	d0 91 8b 0e 	lds	r29, 0x0E8B
    7f52:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7f56:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7f5a:	84 81       	ldd	r24, Z+4	; 0x04
    7f5c:	95 81       	ldd	r25, Z+5	; 0x05
    7f5e:	99 83       	std	Y+1, r25	; 0x01
    7f60:	88 83       	st	Y, r24
  nicState.layer4.udp->destport = (udpSocket->dstPortDef == 0)? udpSocket->dstPort : udpSocket->dstPortDef;          //data in udpSocket are stored in network order
    7f62:	80 81       	ld	r24, Z
    7f64:	91 81       	ldd	r25, Z+1	; 0x01
    7f66:	00 97       	sbiw	r24, 0x00	; 0
    7f68:	11 f4       	brne	.+4      	; 0x7f6e <udpSend+0x32>
    7f6a:	82 81       	ldd	r24, Z+2	; 0x02
    7f6c:	93 81       	ldd	r25, Z+3	; 0x03
    7f6e:	9b 83       	std	Y+3, r25	; 0x03
    7f70:	8a 83       	std	Y+2, r24	; 0x02
  
  nicState.layer4.udp->udplen = htons(len + UDP_HEADER_LEN);
    7f72:	87 01       	movw	r16, r14
    7f74:	08 5f       	subi	r16, 0xF8	; 248
    7f76:	1f 4f       	sbci	r17, 0xFF	; 255
    7f78:	c8 01       	movw	r24, r16
    7f7a:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <htons>
    7f7e:	9d 83       	std	Y+5, r25	; 0x05
    7f80:	8c 83       	std	Y+4, r24	; 0x04
  nicState.layer4.udp->udpchksum = 0;
    7f82:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7f86:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7f8a:	17 82       	std	Z+7, r1	; 0x07
    7f8c:	16 82       	std	Z+6, r1	; 0x06

#if UDP_DEBUG
  if (udpDbgStream != NULL)
    7f8e:	20 91 c5 0e 	lds	r18, 0x0EC5
    7f92:	30 91 c6 0e 	lds	r19, 0x0EC6
    7f96:	21 15       	cp	r18, r1
    7f98:	31 05       	cpc	r19, r1
    7f9a:	01 f1       	breq	.+64     	; 0x7fdc <udpSend+0xa0>
    if (udpDbgLevel > 1)
    7f9c:	80 91 7d 0e 	lds	r24, 0x0E7D
    7fa0:	82 30       	cpi	r24, 0x02	; 2
    7fa2:	e0 f0       	brcs	.+56     	; 0x7fdc <udpSend+0xa0>
      fprintf_P(udpDbgStream, PSTR("Sending UDP packet (data length %d)\r\n"), len);
    7fa4:	00 d0       	rcall	.+0      	; 0x7fa6 <udpSend+0x6a>
    7fa6:	00 d0       	rcall	.+0      	; 0x7fa8 <udpSend+0x6c>
    7fa8:	00 d0       	rcall	.+0      	; 0x7faa <udpSend+0x6e>
    7faa:	ed b7       	in	r30, 0x3d	; 61
    7fac:	fe b7       	in	r31, 0x3e	; 62
    7fae:	31 96       	adiw	r30, 0x01	; 1
    7fb0:	ad b7       	in	r26, 0x3d	; 61
    7fb2:	be b7       	in	r27, 0x3e	; 62
    7fb4:	12 96       	adiw	r26, 0x02	; 2
    7fb6:	3c 93       	st	X, r19
    7fb8:	2e 93       	st	-X, r18
    7fba:	11 97       	sbiw	r26, 0x01	; 1
    7fbc:	86 ef       	ldi	r24, 0xF6	; 246
    7fbe:	92 e1       	ldi	r25, 0x12	; 18
    7fc0:	93 83       	std	Z+3, r25	; 0x03
    7fc2:	82 83       	std	Z+2, r24	; 0x02
    7fc4:	f5 82       	std	Z+5, r15	; 0x05
    7fc6:	e4 82       	std	Z+4, r14	; 0x04
    7fc8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    7fcc:	8d b7       	in	r24, 0x3d	; 61
    7fce:	9e b7       	in	r25, 0x3e	; 62
    7fd0:	06 96       	adiw	r24, 0x06	; 6
    7fd2:	0f b6       	in	r0, 0x3f	; 63
    7fd4:	f8 94       	cli
    7fd6:	9e bf       	out	0x3e, r25	; 62
    7fd8:	0f be       	out	0x3f, r0	; 63
    7fda:	8d bf       	out	0x3d, r24	; 61
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
    7fdc:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7fe0:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7fe4:	66 81       	ldd	r22, Z+6	; 0x06
    7fe6:	77 81       	ldd	r23, Z+7	; 0x07
    7fe8:	80 85       	ldd	r24, Z+8	; 0x08
    7fea:	91 85       	ldd	r25, Z+9	; 0x09
    7fec:	41 e1       	ldi	r20, 0x11	; 17
    7fee:	98 01       	movw	r18, r16
    7ff0:	0e 94 39 33 	call	0x6672	; 0x6672 <ipSend>
}
    7ff4:	df 91       	pop	r29
    7ff6:	cf 91       	pop	r28
    7ff8:	1f 91       	pop	r17
    7ffa:	0f 91       	pop	r16
    7ffc:	ff 90       	pop	r15
    7ffe:	ef 90       	pop	r14
    8000:	08 95       	ret

00008002 <flushUdpQueues>:

  }
}

inline void flushUdpQueues(void)
{
    8002:	0f 93       	push	r16
    8004:	1f 93       	push	r17
    8006:	cf 93       	push	r28
    8008:	df 93       	push	r29
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
    800a:	e0 91 a2 0e 	lds	r30, 0x0EA2
    800e:	f0 91 a3 0e 	lds	r31, 0x0EA3
    8012:	84 85       	ldd	r24, Z+12	; 0x0c
    8014:	95 85       	ldd	r25, Z+13	; 0x0d
    8016:	0e 94 c2 52 	call	0xa584	; 0xa584 <uxQueueMessagesWaiting>
    801a:	88 23       	and	r24, r24
    801c:	e1 f0       	breq	.+56     	; 0x8056 <flushUdpQueues+0x54>
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    801e:	c0 91 8a 0e 	lds	r28, 0x0E8A
    8022:	d0 91 8b 0e 	lds	r29, 0x0E8B
    8026:	28 96       	adiw	r28, 0x08	; 8
    8028:	00 e0       	ldi	r16, 0x00	; 0
    802a:	10 e0       	ldi	r17, 0x00	; 0
    802c:	03 c0       	rjmp	.+6      	; 0x8034 <flushUdpQueues+0x32>
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    {
      data++;
    802e:	21 96       	adiw	r28, 0x01	; 1
      len++;
    8030:	0f 5f       	subi	r16, 0xFF	; 255
    8032:	1f 4f       	sbci	r17, 0xFF	; 255
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    8034:	e0 91 a2 0e 	lds	r30, 0x0EA2
    8038:	f0 91 a3 0e 	lds	r31, 0x0EA3
    803c:	84 85       	ldd	r24, Z+12	; 0x0c
    803e:	95 85       	ldd	r25, Z+13	; 0x0d
    8040:	be 01       	movw	r22, r28
    8042:	40 e0       	ldi	r20, 0x00	; 0
    8044:	50 e0       	ldi	r21, 0x00	; 0
    8046:	20 e0       	ldi	r18, 0x00	; 0
    8048:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    804c:	81 30       	cpi	r24, 0x01	; 1
    804e:	79 f3       	breq	.-34     	; 0x802e <flushUdpQueues+0x2c>
    {
      data++;
      len++;
    }
    udpSend(len);
    8050:	c8 01       	movw	r24, r16
    8052:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <udpSend>
  }
}
    8056:	df 91       	pop	r29
    8058:	cf 91       	pop	r28
    805a:	1f 91       	pop	r17
    805c:	0f 91       	pop	r16
    805e:	08 95       	ret

00008060 <udpInit>:
static uint32_t udpIpDst_eep   __attribute__((section (".eeprom"))) = ((uint32_t)UDP_DST_IP4   << 24) + ((uint32_t)UDP_DST_IP3   <<16) + ((uint32_t)UDP_DST_IP2   <<8) + UDP_DST_IP1;
static uint16_t udpPortDstEep  __attribute__((section (".eeprom"))) = HTONS(UDP_DST_PORT);
static uint16_t udpPortSrcEep  __attribute__((section (".eeprom"))) = HTONS(UDP_SRC_PORT);

void udpInit(void)
{
    8060:	0f 93       	push	r16
    8062:	1f 93       	push	r17
#if UDP_DEBUG
  udpDbgStream         = NULL;
    8064:	10 92 c6 0e 	sts	0x0EC6, r1
    8068:	10 92 c5 0e 	sts	0x0EC5, r1
  udpDbgLevel          = 0;
    806c:	10 92 7d 0e 	sts	0x0E7D, r1
#endif
  udpSocket = xmalloc(sizeof(UdpSocket_t));
    8070:	8e e0       	ldi	r24, 0x0E	; 14
    8072:	90 e0       	ldi	r25, 0x00	; 0
    8074:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    8078:	8c 01       	movw	r16, r24
    807a:	90 93 a3 0e 	sts	0x0EA3, r25
    807e:	80 93 a2 0e 	sts	0x0EA2, r24

  udpSocket->dstIp      = eeprom_read_dword(&udpIpDst_eep);
    8082:	8a e2       	ldi	r24, 0x2A	; 42
    8084:	90 e0       	ldi	r25, 0x00	; 0
    8086:	0e 94 cf 5f 	call	0xbf9e	; 0xbf9e <__eerd_dword_m128>
    808a:	f8 01       	movw	r30, r16
    808c:	66 83       	std	Z+6, r22	; 0x06
    808e:	77 83       	std	Z+7, r23	; 0x07
    8090:	80 87       	std	Z+8, r24	; 0x08
    8092:	91 87       	std	Z+9, r25	; 0x09
  udpSocket->dstPortDef = eeprom_read_word(&udpPortDstEep);;
    8094:	8e e2       	ldi	r24, 0x2E	; 46
    8096:	90 e0       	ldi	r25, 0x00	; 0
    8098:	0e 94 d5 5f 	call	0xbfaa	; 0xbfaa <__eerd_word_m128>
    809c:	f8 01       	movw	r30, r16
    809e:	91 83       	std	Z+1, r25	; 0x01
    80a0:	80 83       	st	Z, r24
  udpSocket->srcPort    = eeprom_read_word(&udpPortSrcEep);
    80a2:	80 e3       	ldi	r24, 0x30	; 48
    80a4:	90 e0       	ldi	r25, 0x00	; 0
    80a6:	0e 94 d5 5f 	call	0xbfaa	; 0xbfaa <__eerd_word_m128>
    80aa:	f8 01       	movw	r30, r16
    80ac:	95 83       	std	Z+5, r25	; 0x05
    80ae:	84 83       	std	Z+4, r24	; 0x04
  
  udpSocket->Rx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_RX_BUF_ADDR));
    80b0:	8f ef       	ldi	r24, 0xFF	; 255
    80b2:	61 e0       	ldi	r22, 0x01	; 1
    80b4:	40 e0       	ldi	r20, 0x00	; 0
    80b6:	59 e7       	ldi	r21, 0x79	; 121
    80b8:	0e 94 44 55 	call	0xaa88	; 0xaa88 <xQueueCreateExternal>
    80bc:	f8 01       	movw	r30, r16
    80be:	93 87       	std	Z+11, r25	; 0x0b
    80c0:	82 87       	std	Z+10, r24	; 0x0a
  udpSocket->Tx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_TX_BUF_ADDR));
    80c2:	00 91 a2 0e 	lds	r16, 0x0EA2
    80c6:	10 91 a3 0e 	lds	r17, 0x0EA3
    80ca:	8f ef       	ldi	r24, 0xFF	; 255
    80cc:	61 e0       	ldi	r22, 0x01	; 1
    80ce:	40 e0       	ldi	r20, 0x00	; 0
    80d0:	58 e7       	ldi	r21, 0x78	; 120
    80d2:	0e 94 44 55 	call	0xaa88	; 0xaa88 <xQueueCreateExternal>
    80d6:	f8 01       	movw	r30, r16
    80d8:	95 87       	std	Z+13, r25	; 0x0d
    80da:	84 87       	std	Z+12, r24	; 0x0c
}
    80dc:	1f 91       	pop	r17
    80de:	0f 91       	pop	r16
    80e0:	08 95       	ret

000080e2 <ipv6DebugInit>:
  
}

void ipv6DebugInit(FILE* inDebugStream)
{
  debugStream = inDebugStream;
    80e2:	90 93 51 0f 	sts	0x0F51, r25
    80e6:	80 93 50 0f 	sts	0x0F50, r24
}
    80ea:	08 95       	ret

000080ec <netPrintIpv6Header>:
  }
  fprintf_P(stream, PSTR("\r\n")); 
}

void netPrintIpv6Header(FILE *stream)
{
    80ec:	0f 93       	push	r16
    80ee:	1f 93       	push	r17
    80f0:	cf 93       	push	r28
    80f2:	df 93       	push	r29
    80f4:	8c 01       	movw	r16, r24
    fprintf_P(stream, PSTR("Version: \t\t"));
    80f6:	00 d0       	rcall	.+0      	; 0x80f8 <netPrintIpv6Header+0xc>
    80f8:	00 d0       	rcall	.+0      	; 0x80fa <netPrintIpv6Header+0xe>
    80fa:	cd b7       	in	r28, 0x3d	; 61
    80fc:	de b7       	in	r29, 0x3e	; 62
    80fe:	9a 83       	std	Y+2, r25	; 0x02
    8100:	89 83       	std	Y+1, r24	; 0x01
    8102:	8c e3       	ldi	r24, 0x3C	; 60
    8104:	94 e1       	ldi	r25, 0x14	; 20
    8106:	9c 83       	std	Y+4, r25	; 0x04
    8108:	8b 83       	std	Y+3, r24	; 0x03
    810a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("%d \n\r"), nicState.layer3.ipv6->vtc >> 4);
    810e:	00 d0       	rcall	.+0      	; 0x8110 <netPrintIpv6Header+0x24>
    8110:	ad b7       	in	r26, 0x3d	; 61
    8112:	be b7       	in	r27, 0x3e	; 62
    8114:	11 96       	adiw	r26, 0x01	; 1
    8116:	ed b7       	in	r30, 0x3d	; 61
    8118:	fe b7       	in	r31, 0x3e	; 62
    811a:	12 83       	std	Z+2, r17	; 0x02
    811c:	01 83       	std	Z+1, r16	; 0x01
    811e:	86 e3       	ldi	r24, 0x36	; 54
    8120:	94 e1       	ldi	r25, 0x14	; 20
    8122:	13 96       	adiw	r26, 0x03	; 3
    8124:	9c 93       	st	X, r25
    8126:	8e 93       	st	-X, r24
    8128:	12 97       	sbiw	r26, 0x02	; 2
    812a:	e0 91 88 0e 	lds	r30, 0x0E88
    812e:	f0 91 89 0e 	lds	r31, 0x0E89
    8132:	80 81       	ld	r24, Z
    8134:	82 95       	swap	r24
    8136:	8f 70       	andi	r24, 0x0F	; 15
    8138:	14 96       	adiw	r26, 0x04	; 4
    813a:	8c 93       	st	X, r24
    813c:	14 97       	sbiw	r26, 0x04	; 4
    813e:	15 96       	adiw	r26, 0x05	; 5
    8140:	1c 92       	st	X, r1
    8142:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("Traffic Class: \t\t"));
    8146:	0f 90       	pop	r0
    8148:	0f 90       	pop	r0
    814a:	cd b7       	in	r28, 0x3d	; 61
    814c:	de b7       	in	r29, 0x3e	; 62
    814e:	1a 83       	std	Y+2, r17	; 0x02
    8150:	09 83       	std	Y+1, r16	; 0x01
    8152:	84 e2       	ldi	r24, 0x24	; 36
    8154:	94 e1       	ldi	r25, 0x14	; 20
    8156:	9c 83       	std	Y+4, r25	; 0x04
    8158:	8b 83       	std	Y+3, r24	; 0x03
    815a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("%d \n\r"), nicState.layer3.ipv6->vtc & 0x0F + nicState.layer3.ipv6->tcflow >> 4);
    815e:	e0 91 88 0e 	lds	r30, 0x0E88
    8162:	f0 91 89 0e 	lds	r31, 0x0E89
    8166:	00 d0       	rcall	.+0      	; 0x8168 <netPrintIpv6Header+0x7c>
    8168:	ad b7       	in	r26, 0x3d	; 61
    816a:	be b7       	in	r27, 0x3e	; 62
    816c:	11 96       	adiw	r26, 0x01	; 1
    816e:	cd b7       	in	r28, 0x3d	; 61
    8170:	de b7       	in	r29, 0x3e	; 62
    8172:	1a 83       	std	Y+2, r17	; 0x02
    8174:	09 83       	std	Y+1, r16	; 0x01
    8176:	8e e1       	ldi	r24, 0x1E	; 30
    8178:	94 e1       	ldi	r25, 0x14	; 20
    817a:	13 96       	adiw	r26, 0x03	; 3
    817c:	9c 93       	st	X, r25
    817e:	8e 93       	st	-X, r24
    8180:	12 97       	sbiw	r26, 0x02	; 2
    8182:	81 81       	ldd	r24, Z+1	; 0x01
    8184:	90 e0       	ldi	r25, 0x00	; 0
    8186:	0f 96       	adiw	r24, 0x0f	; 15
    8188:	34 e0       	ldi	r19, 0x04	; 4
    818a:	95 95       	asr	r25
    818c:	87 95       	ror	r24
    818e:	3a 95       	dec	r19
    8190:	e1 f7       	brne	.-8      	; 0x818a <netPrintIpv6Header+0x9e>
    8192:	20 81       	ld	r18, Z
    8194:	30 e0       	ldi	r19, 0x00	; 0
    8196:	82 23       	and	r24, r18
    8198:	93 23       	and	r25, r19
    819a:	15 96       	adiw	r26, 0x05	; 5
    819c:	9c 93       	st	X, r25
    819e:	8e 93       	st	-X, r24
    81a0:	14 97       	sbiw	r26, 0x04	; 4
    81a2:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("Flow Label: \t\t"));
    81a6:	0f 90       	pop	r0
    81a8:	0f 90       	pop	r0
    81aa:	ed b7       	in	r30, 0x3d	; 61
    81ac:	fe b7       	in	r31, 0x3e	; 62
    81ae:	12 83       	std	Z+2, r17	; 0x02
    81b0:	01 83       	std	Z+1, r16	; 0x01
    81b2:	8f e0       	ldi	r24, 0x0F	; 15
    81b4:	94 e1       	ldi	r25, 0x14	; 20
    81b6:	94 83       	std	Z+4, r25	; 0x04
    81b8:	83 83       	std	Z+3, r24	; 0x03
    81ba:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("%d \n\r"), nicState.layer3.ipv6->tcflow & 0x0F + nicState.layer3.ipv6->flow << 4);
    81be:	e0 91 88 0e 	lds	r30, 0x0E88
    81c2:	f0 91 89 0e 	lds	r31, 0x0E89
    81c6:	00 d0       	rcall	.+0      	; 0x81c8 <netPrintIpv6Header+0xdc>
    81c8:	ad b7       	in	r26, 0x3d	; 61
    81ca:	be b7       	in	r27, 0x3e	; 62
    81cc:	11 96       	adiw	r26, 0x01	; 1
    81ce:	cd b7       	in	r28, 0x3d	; 61
    81d0:	de b7       	in	r29, 0x3e	; 62
    81d2:	1a 83       	std	Y+2, r17	; 0x02
    81d4:	09 83       	std	Y+1, r16	; 0x01
    81d6:	89 e0       	ldi	r24, 0x09	; 9
    81d8:	94 e1       	ldi	r25, 0x14	; 20
    81da:	13 96       	adiw	r26, 0x03	; 3
    81dc:	9c 93       	st	X, r25
    81de:	8e 93       	st	-X, r24
    81e0:	12 97       	sbiw	r26, 0x02	; 2
    81e2:	82 81       	ldd	r24, Z+2	; 0x02
    81e4:	93 81       	ldd	r25, Z+3	; 0x03
    81e6:	0f 96       	adiw	r24, 0x0f	; 15
    81e8:	24 e0       	ldi	r18, 0x04	; 4
    81ea:	88 0f       	add	r24, r24
    81ec:	99 1f       	adc	r25, r25
    81ee:	2a 95       	dec	r18
    81f0:	e1 f7       	brne	.-8      	; 0x81ea <netPrintIpv6Header+0xfe>
    81f2:	21 81       	ldd	r18, Z+1	; 0x01
    81f4:	30 e0       	ldi	r19, 0x00	; 0
    81f6:	82 23       	and	r24, r18
    81f8:	93 23       	and	r25, r19
    81fa:	15 96       	adiw	r26, 0x05	; 5
    81fc:	9c 93       	st	X, r25
    81fe:	8e 93       	st	-X, r24
    8200:	14 97       	sbiw	r26, 0x04	; 4
    8202:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("Payload Length: \t"));
    8206:	0f 90       	pop	r0
    8208:	0f 90       	pop	r0
    820a:	ed b7       	in	r30, 0x3d	; 61
    820c:	fe b7       	in	r31, 0x3e	; 62
    820e:	12 83       	std	Z+2, r17	; 0x02
    8210:	01 83       	std	Z+1, r16	; 0x01
    8212:	87 ef       	ldi	r24, 0xF7	; 247
    8214:	93 e1       	ldi	r25, 0x13	; 19
    8216:	94 83       	std	Z+4, r25	; 0x04
    8218:	83 83       	std	Z+3, r24	; 0x03
    821a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("%d \n\r"), nicState.layer3.ipv6->len[1] + nicState.layer3.ipv6->len[0]);
    821e:	e0 91 88 0e 	lds	r30, 0x0E88
    8222:	f0 91 89 0e 	lds	r31, 0x0E89
    8226:	00 d0       	rcall	.+0      	; 0x8228 <netPrintIpv6Header+0x13c>
    8228:	ad b7       	in	r26, 0x3d	; 61
    822a:	be b7       	in	r27, 0x3e	; 62
    822c:	11 96       	adiw	r26, 0x01	; 1
    822e:	cd b7       	in	r28, 0x3d	; 61
    8230:	de b7       	in	r29, 0x3e	; 62
    8232:	1a 83       	std	Y+2, r17	; 0x02
    8234:	09 83       	std	Y+1, r16	; 0x01
    8236:	81 ef       	ldi	r24, 0xF1	; 241
    8238:	93 e1       	ldi	r25, 0x13	; 19
    823a:	13 96       	adiw	r26, 0x03	; 3
    823c:	9c 93       	st	X, r25
    823e:	8e 93       	st	-X, r24
    8240:	12 97       	sbiw	r26, 0x02	; 2
    8242:	24 81       	ldd	r18, Z+4	; 0x04
    8244:	85 81       	ldd	r24, Z+5	; 0x05
    8246:	90 e0       	ldi	r25, 0x00	; 0
    8248:	82 0f       	add	r24, r18
    824a:	91 1d       	adc	r25, r1
    824c:	15 96       	adiw	r26, 0x05	; 5
    824e:	9c 93       	st	X, r25
    8250:	8e 93       	st	-X, r24
    8252:	14 97       	sbiw	r26, 0x04	; 4
    8254:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("Source address: \t"));
    8258:	0f 90       	pop	r0
    825a:	0f 90       	pop	r0
    825c:	ed b7       	in	r30, 0x3d	; 61
    825e:	fe b7       	in	r31, 0x3e	; 62
    8260:	12 83       	std	Z+2, r17	; 0x02
    8262:	01 83       	std	Z+1, r16	; 0x01
    8264:	8f ed       	ldi	r24, 0xDF	; 223
    8266:	93 e1       	ldi	r25, 0x13	; 19
    8268:	94 83       	std	Z+4, r25	; 0x04
    826a:	83 83       	std	Z+3, r24	; 0x03
    826c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    PRINT6ADDR(stream, &nicState.layer3.ipv6->srcipaddr);
    8270:	a0 91 88 0e 	lds	r26, 0x0E88
    8274:	b0 91 89 0e 	lds	r27, 0x0E89
    8278:	8d b7       	in	r24, 0x3d	; 61
    827a:	9e b7       	in	r25, 0x3e	; 62
    827c:	80 97       	sbiw	r24, 0x20	; 32
    827e:	0f b6       	in	r0, 0x3f	; 63
    8280:	f8 94       	cli
    8282:	9e bf       	out	0x3e, r25	; 62
    8284:	0f be       	out	0x3f, r0	; 63
    8286:	8d bf       	out	0x3d, r24	; 61
    8288:	ed b7       	in	r30, 0x3d	; 61
    828a:	fe b7       	in	r31, 0x3e	; 62
    828c:	31 96       	adiw	r30, 0x01	; 1
    828e:	cd b7       	in	r28, 0x3d	; 61
    8290:	de b7       	in	r29, 0x3e	; 62
    8292:	1a 83       	std	Y+2, r17	; 0x02
    8294:	09 83       	std	Y+1, r16	; 0x01
    8296:	89 e8       	ldi	r24, 0x89	; 137
    8298:	93 e1       	ldi	r25, 0x13	; 19
    829a:	93 83       	std	Z+3, r25	; 0x03
    829c:	82 83       	std	Z+2, r24	; 0x02
    829e:	18 96       	adiw	r26, 0x08	; 8
    82a0:	8c 91       	ld	r24, X
    82a2:	18 97       	sbiw	r26, 0x08	; 8
    82a4:	84 83       	std	Z+4, r24	; 0x04
    82a6:	15 82       	std	Z+5, r1	; 0x05
    82a8:	19 96       	adiw	r26, 0x09	; 9
    82aa:	8c 91       	ld	r24, X
    82ac:	19 97       	sbiw	r26, 0x09	; 9
    82ae:	86 83       	std	Z+6, r24	; 0x06
    82b0:	17 82       	std	Z+7, r1	; 0x07
    82b2:	1a 96       	adiw	r26, 0x0a	; 10
    82b4:	8c 91       	ld	r24, X
    82b6:	1a 97       	sbiw	r26, 0x0a	; 10
    82b8:	80 87       	std	Z+8, r24	; 0x08
    82ba:	11 86       	std	Z+9, r1	; 0x09
    82bc:	1b 96       	adiw	r26, 0x0b	; 11
    82be:	8c 91       	ld	r24, X
    82c0:	1b 97       	sbiw	r26, 0x0b	; 11
    82c2:	82 87       	std	Z+10, r24	; 0x0a
    82c4:	13 86       	std	Z+11, r1	; 0x0b
    82c6:	1c 96       	adiw	r26, 0x0c	; 12
    82c8:	8c 91       	ld	r24, X
    82ca:	1c 97       	sbiw	r26, 0x0c	; 12
    82cc:	84 87       	std	Z+12, r24	; 0x0c
    82ce:	15 86       	std	Z+13, r1	; 0x0d
    82d0:	1d 96       	adiw	r26, 0x0d	; 13
    82d2:	8c 91       	ld	r24, X
    82d4:	1d 97       	sbiw	r26, 0x0d	; 13
    82d6:	86 87       	std	Z+14, r24	; 0x0e
    82d8:	17 86       	std	Z+15, r1	; 0x0f
    82da:	1e 96       	adiw	r26, 0x0e	; 14
    82dc:	8c 91       	ld	r24, X
    82de:	1e 97       	sbiw	r26, 0x0e	; 14
    82e0:	80 8b       	std	Z+16, r24	; 0x10
    82e2:	11 8a       	std	Z+17, r1	; 0x11
    82e4:	1f 96       	adiw	r26, 0x0f	; 15
    82e6:	8c 91       	ld	r24, X
    82e8:	1f 97       	sbiw	r26, 0x0f	; 15
    82ea:	82 8b       	std	Z+18, r24	; 0x12
    82ec:	13 8a       	std	Z+19, r1	; 0x13
    82ee:	50 96       	adiw	r26, 0x10	; 16
    82f0:	8c 91       	ld	r24, X
    82f2:	50 97       	sbiw	r26, 0x10	; 16
    82f4:	84 8b       	std	Z+20, r24	; 0x14
    82f6:	15 8a       	std	Z+21, r1	; 0x15
    82f8:	51 96       	adiw	r26, 0x11	; 17
    82fa:	8c 91       	ld	r24, X
    82fc:	51 97       	sbiw	r26, 0x11	; 17
    82fe:	86 8b       	std	Z+22, r24	; 0x16
    8300:	17 8a       	std	Z+23, r1	; 0x17
    8302:	52 96       	adiw	r26, 0x12	; 18
    8304:	8c 91       	ld	r24, X
    8306:	52 97       	sbiw	r26, 0x12	; 18
    8308:	80 8f       	std	Z+24, r24	; 0x18
    830a:	11 8e       	std	Z+25, r1	; 0x19
    830c:	53 96       	adiw	r26, 0x13	; 19
    830e:	8c 91       	ld	r24, X
    8310:	53 97       	sbiw	r26, 0x13	; 19
    8312:	82 8f       	std	Z+26, r24	; 0x1a
    8314:	13 8e       	std	Z+27, r1	; 0x1b
    8316:	54 96       	adiw	r26, 0x14	; 20
    8318:	8c 91       	ld	r24, X
    831a:	54 97       	sbiw	r26, 0x14	; 20
    831c:	84 8f       	std	Z+28, r24	; 0x1c
    831e:	15 8e       	std	Z+29, r1	; 0x1d
    8320:	55 96       	adiw	r26, 0x15	; 21
    8322:	8c 91       	ld	r24, X
    8324:	55 97       	sbiw	r26, 0x15	; 21
    8326:	86 8f       	std	Z+30, r24	; 0x1e
    8328:	17 8e       	std	Z+31, r1	; 0x1f
    832a:	56 96       	adiw	r26, 0x16	; 22
    832c:	8c 91       	ld	r24, X
    832e:	56 97       	sbiw	r26, 0x16	; 22
    8330:	80 a3       	std	Z+32, r24	; 0x20
    8332:	11 a2       	std	Z+33, r1	; 0x21
    8334:	57 96       	adiw	r26, 0x17	; 23
    8336:	8c 91       	ld	r24, X
    8338:	82 a3       	std	Z+34, r24	; 0x22
    833a:	13 a2       	std	Z+35, r1	; 0x23
    833c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    fprintf_P(stream, PSTR("Destination address: \t"));
    8340:	ed b7       	in	r30, 0x3d	; 61
    8342:	fe b7       	in	r31, 0x3e	; 62
    8344:	b4 96       	adiw	r30, 0x24	; 36
    8346:	0f b6       	in	r0, 0x3f	; 63
    8348:	f8 94       	cli
    834a:	fe bf       	out	0x3e, r31	; 62
    834c:	0f be       	out	0x3f, r0	; 63
    834e:	ed bf       	out	0x3d, r30	; 61
    8350:	00 d0       	rcall	.+0      	; 0x8352 <netPrintIpv6Header+0x266>
    8352:	00 d0       	rcall	.+0      	; 0x8354 <netPrintIpv6Header+0x268>
    8354:	cd b7       	in	r28, 0x3d	; 61
    8356:	de b7       	in	r29, 0x3e	; 62
    8358:	1a 83       	std	Y+2, r17	; 0x02
    835a:	09 83       	std	Y+1, r16	; 0x01
    835c:	82 e7       	ldi	r24, 0x72	; 114
    835e:	93 e1       	ldi	r25, 0x13	; 19
    8360:	9c 83       	std	Y+4, r25	; 0x04
    8362:	8b 83       	std	Y+3, r24	; 0x03
    8364:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    PRINT6ADDR(stream, &nicState.layer3.ipv6->srcipaddr);
    8368:	a0 91 88 0e 	lds	r26, 0x0E88
    836c:	b0 91 89 0e 	lds	r27, 0x0E89
    8370:	ed b7       	in	r30, 0x3d	; 61
    8372:	fe b7       	in	r31, 0x3e	; 62
    8374:	b0 97       	sbiw	r30, 0x20	; 32
    8376:	0f b6       	in	r0, 0x3f	; 63
    8378:	f8 94       	cli
    837a:	fe bf       	out	0x3e, r31	; 62
    837c:	0f be       	out	0x3f, r0	; 63
    837e:	ed bf       	out	0x3d, r30	; 61
    8380:	31 96       	adiw	r30, 0x01	; 1
    8382:	cd b7       	in	r28, 0x3d	; 61
    8384:	de b7       	in	r29, 0x3e	; 62
    8386:	1a 83       	std	Y+2, r17	; 0x02
    8388:	09 83       	std	Y+1, r16	; 0x01
    838a:	8c e1       	ldi	r24, 0x1C	; 28
    838c:	93 e1       	ldi	r25, 0x13	; 19
    838e:	93 83       	std	Z+3, r25	; 0x03
    8390:	82 83       	std	Z+2, r24	; 0x02
    8392:	18 96       	adiw	r26, 0x08	; 8
    8394:	8c 91       	ld	r24, X
    8396:	18 97       	sbiw	r26, 0x08	; 8
    8398:	84 83       	std	Z+4, r24	; 0x04
    839a:	15 82       	std	Z+5, r1	; 0x05
    839c:	19 96       	adiw	r26, 0x09	; 9
    839e:	8c 91       	ld	r24, X
    83a0:	19 97       	sbiw	r26, 0x09	; 9
    83a2:	86 83       	std	Z+6, r24	; 0x06
    83a4:	17 82       	std	Z+7, r1	; 0x07
    83a6:	1a 96       	adiw	r26, 0x0a	; 10
    83a8:	8c 91       	ld	r24, X
    83aa:	1a 97       	sbiw	r26, 0x0a	; 10
    83ac:	80 87       	std	Z+8, r24	; 0x08
    83ae:	11 86       	std	Z+9, r1	; 0x09
    83b0:	1b 96       	adiw	r26, 0x0b	; 11
    83b2:	8c 91       	ld	r24, X
    83b4:	1b 97       	sbiw	r26, 0x0b	; 11
    83b6:	82 87       	std	Z+10, r24	; 0x0a
    83b8:	13 86       	std	Z+11, r1	; 0x0b
    83ba:	1c 96       	adiw	r26, 0x0c	; 12
    83bc:	8c 91       	ld	r24, X
    83be:	1c 97       	sbiw	r26, 0x0c	; 12
    83c0:	84 87       	std	Z+12, r24	; 0x0c
    83c2:	15 86       	std	Z+13, r1	; 0x0d
    83c4:	1d 96       	adiw	r26, 0x0d	; 13
    83c6:	8c 91       	ld	r24, X
    83c8:	1d 97       	sbiw	r26, 0x0d	; 13
    83ca:	86 87       	std	Z+14, r24	; 0x0e
    83cc:	17 86       	std	Z+15, r1	; 0x0f
    83ce:	1e 96       	adiw	r26, 0x0e	; 14
    83d0:	8c 91       	ld	r24, X
    83d2:	1e 97       	sbiw	r26, 0x0e	; 14
    83d4:	80 8b       	std	Z+16, r24	; 0x10
    83d6:	11 8a       	std	Z+17, r1	; 0x11
    83d8:	1f 96       	adiw	r26, 0x0f	; 15
    83da:	8c 91       	ld	r24, X
    83dc:	1f 97       	sbiw	r26, 0x0f	; 15
    83de:	82 8b       	std	Z+18, r24	; 0x12
    83e0:	13 8a       	std	Z+19, r1	; 0x13
    83e2:	50 96       	adiw	r26, 0x10	; 16
    83e4:	8c 91       	ld	r24, X
    83e6:	50 97       	sbiw	r26, 0x10	; 16
    83e8:	84 8b       	std	Z+20, r24	; 0x14
    83ea:	15 8a       	std	Z+21, r1	; 0x15
    83ec:	51 96       	adiw	r26, 0x11	; 17
    83ee:	8c 91       	ld	r24, X
    83f0:	51 97       	sbiw	r26, 0x11	; 17
    83f2:	86 8b       	std	Z+22, r24	; 0x16
    83f4:	17 8a       	std	Z+23, r1	; 0x17
    83f6:	52 96       	adiw	r26, 0x12	; 18
    83f8:	8c 91       	ld	r24, X
    83fa:	52 97       	sbiw	r26, 0x12	; 18
    83fc:	80 8f       	std	Z+24, r24	; 0x18
    83fe:	11 8e       	std	Z+25, r1	; 0x19
    8400:	53 96       	adiw	r26, 0x13	; 19
    8402:	8c 91       	ld	r24, X
    8404:	53 97       	sbiw	r26, 0x13	; 19
    8406:	82 8f       	std	Z+26, r24	; 0x1a
    8408:	13 8e       	std	Z+27, r1	; 0x1b
    840a:	54 96       	adiw	r26, 0x14	; 20
    840c:	8c 91       	ld	r24, X
    840e:	54 97       	sbiw	r26, 0x14	; 20
    8410:	84 8f       	std	Z+28, r24	; 0x1c
    8412:	15 8e       	std	Z+29, r1	; 0x1d
    8414:	55 96       	adiw	r26, 0x15	; 21
    8416:	8c 91       	ld	r24, X
    8418:	55 97       	sbiw	r26, 0x15	; 21
    841a:	86 8f       	std	Z+30, r24	; 0x1e
    841c:	17 8e       	std	Z+31, r1	; 0x1f
    841e:	56 96       	adiw	r26, 0x16	; 22
    8420:	8c 91       	ld	r24, X
    8422:	56 97       	sbiw	r26, 0x16	; 22
    8424:	80 a3       	std	Z+32, r24	; 0x20
    8426:	11 a2       	std	Z+33, r1	; 0x21
    8428:	57 96       	adiw	r26, 0x17	; 23
    842a:	8c 91       	ld	r24, X
    842c:	82 a3       	std	Z+34, r24	; 0x22
    842e:	13 a2       	std	Z+35, r1	; 0x23
    8430:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    8434:	ed b7       	in	r30, 0x3d	; 61
    8436:	fe b7       	in	r31, 0x3e	; 62
    8438:	b4 96       	adiw	r30, 0x24	; 36
    843a:	0f b6       	in	r0, 0x3f	; 63
    843c:	f8 94       	cli
    843e:	fe bf       	out	0x3e, r31	; 62
    8440:	0f be       	out	0x3f, r0	; 63
    8442:	ed bf       	out	0x3d, r30	; 61
}
    8444:	df 91       	pop	r29
    8446:	cf 91       	pop	r28
    8448:	1f 91       	pop	r17
    844a:	0f 91       	pop	r16
    844c:	08 95       	ret

0000844e <netPrintIpv6HeaderRAW>:
  debugStream = inDebugStream;
}


void netPrintIpv6HeaderRAW(FILE *stream)
{
    844e:	cf 92       	push	r12
    8450:	df 92       	push	r13
    8452:	ef 92       	push	r14
    8454:	ff 92       	push	r15
    8456:	0f 93       	push	r16
    8458:	1f 93       	push	r17
    845a:	cf 93       	push	r28
    845c:	df 93       	push	r29
    845e:	8c 01       	movw	r16, r24
  fprintf_P(stream, PSTR("IPv6 Header\r\n"));    
    8460:	00 d0       	rcall	.+0      	; 0x8462 <netPrintIpv6HeaderRAW+0x14>
    8462:	00 d0       	rcall	.+0      	; 0x8464 <netPrintIpv6HeaderRAW+0x16>
    8464:	ad b7       	in	r26, 0x3d	; 61
    8466:	be b7       	in	r27, 0x3e	; 62
    8468:	12 96       	adiw	r26, 0x02	; 2
    846a:	9c 93       	st	X, r25
    846c:	8e 93       	st	-X, r24
    846e:	11 97       	sbiw	r26, 0x01	; 1
    8470:	84 e5       	ldi	r24, 0x54	; 84
    8472:	94 e1       	ldi	r25, 0x14	; 20
    8474:	14 96       	adiw	r26, 0x04	; 4
    8476:	9c 93       	st	X, r25
    8478:	8e 93       	st	-X, r24
    847a:	13 97       	sbiw	r26, 0x03	; 3
    847c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    8480:	c1 e0       	ldi	r28, 0x01	; 1
    8482:	d0 e0       	ldi	r29, 0x00	; 0
    8484:	0f 90       	pop	r0
    8486:	0f 90       	pop	r0
    8488:	0f 90       	pop	r0
    848a:	0f 90       	pop	r0
  for (uint8_t i=0; i < UIP_IPv6H_LEN; i++)
  {
    if (i!=0 && i%16==0) fprintf_P(stream, PSTR("\r\n"));
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i]);
    848c:	5b e4       	ldi	r21, 0x4B	; 75
    848e:	c5 2e       	mov	r12, r21
    8490:	54 e1       	ldi	r21, 0x14	; 20
    8492:	d5 2e       	mov	r13, r21
void netPrintIpv6HeaderRAW(FILE *stream)
{
  fprintf_P(stream, PSTR("IPv6 Header\r\n"));    
  for (uint8_t i=0; i < UIP_IPv6H_LEN; i++)
  {
    if (i!=0 && i%16==0) fprintf_P(stream, PSTR("\r\n"));
    8494:	41 e5       	ldi	r20, 0x51	; 81
    8496:	e4 2e       	mov	r14, r20
    8498:	44 e1       	ldi	r20, 0x14	; 20
    849a:	f4 2e       	mov	r15, r20
    849c:	14 c0       	rjmp	.+40     	; 0x84c6 <netPrintIpv6HeaderRAW+0x78>
    849e:	ce 01       	movw	r24, r28
    84a0:	8f 70       	andi	r24, 0x0F	; 15
    84a2:	90 70       	andi	r25, 0x00	; 0
    84a4:	89 2b       	or	r24, r25
    84a6:	71 f4       	brne	.+28     	; 0x84c4 <netPrintIpv6HeaderRAW+0x76>
    84a8:	00 d0       	rcall	.+0      	; 0x84aa <netPrintIpv6HeaderRAW+0x5c>
    84aa:	00 d0       	rcall	.+0      	; 0x84ac <netPrintIpv6HeaderRAW+0x5e>
    84ac:	ed b7       	in	r30, 0x3d	; 61
    84ae:	fe b7       	in	r31, 0x3e	; 62
    84b0:	12 83       	std	Z+2, r17	; 0x02
    84b2:	01 83       	std	Z+1, r16	; 0x01
    84b4:	f4 82       	std	Z+4, r15	; 0x04
    84b6:	e3 82       	std	Z+3, r14	; 0x03
    84b8:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    84bc:	0f 90       	pop	r0
    84be:	0f 90       	pop	r0
    84c0:	0f 90       	pop	r0
    84c2:	0f 90       	pop	r0
    84c4:	21 96       	adiw	r28, 0x01	; 1
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i]);
    84c6:	00 d0       	rcall	.+0      	; 0x84c8 <netPrintIpv6HeaderRAW+0x7a>
    84c8:	00 d0       	rcall	.+0      	; 0x84ca <netPrintIpv6HeaderRAW+0x7c>
    84ca:	00 d0       	rcall	.+0      	; 0x84cc <netPrintIpv6HeaderRAW+0x7e>
    84cc:	ed b7       	in	r30, 0x3d	; 61
    84ce:	fe b7       	in	r31, 0x3e	; 62
    84d0:	31 96       	adiw	r30, 0x01	; 1
    84d2:	ad b7       	in	r26, 0x3d	; 61
    84d4:	be b7       	in	r27, 0x3e	; 62
    84d6:	12 96       	adiw	r26, 0x02	; 2
    84d8:	1c 93       	st	X, r17
    84da:	0e 93       	st	-X, r16
    84dc:	11 97       	sbiw	r26, 0x01	; 1
    84de:	d3 82       	std	Z+3, r13	; 0x03
    84e0:	c2 82       	std	Z+2, r12	; 0x02
    84e2:	a0 91 88 0e 	lds	r26, 0x0E88
    84e6:	b0 91 89 0e 	lds	r27, 0x0E89
    84ea:	ac 0f       	add	r26, r28
    84ec:	bd 1f       	adc	r27, r29
    84ee:	11 97       	sbiw	r26, 0x01	; 1
    84f0:	8c 91       	ld	r24, X
    84f2:	84 83       	std	Z+4, r24	; 0x04
    84f4:	15 82       	std	Z+5, r1	; 0x05
    84f6:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>


void netPrintIpv6HeaderRAW(FILE *stream)
{
  fprintf_P(stream, PSTR("IPv6 Header\r\n"));    
  for (uint8_t i=0; i < UIP_IPv6H_LEN; i++)
    84fa:	ed b7       	in	r30, 0x3d	; 61
    84fc:	fe b7       	in	r31, 0x3e	; 62
    84fe:	36 96       	adiw	r30, 0x06	; 6
    8500:	0f b6       	in	r0, 0x3f	; 63
    8502:	f8 94       	cli
    8504:	fe bf       	out	0x3e, r31	; 62
    8506:	0f be       	out	0x3f, r0	; 63
    8508:	ed bf       	out	0x3d, r30	; 61
    850a:	c8 32       	cpi	r28, 0x28	; 40
    850c:	d1 05       	cpc	r29, r1
    850e:	39 f6       	brne	.-114    	; 0x849e <netPrintIpv6HeaderRAW+0x50>
  {
    if (i!=0 && i%16==0) fprintf_P(stream, PSTR("\r\n"));
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i]);
  }
  fprintf_P(stream, PSTR("\r\n")); 
    8510:	00 d0       	rcall	.+0      	; 0x8512 <netPrintIpv6HeaderRAW+0xc4>
    8512:	00 d0       	rcall	.+0      	; 0x8514 <netPrintIpv6HeaderRAW+0xc6>
    8514:	ad b7       	in	r26, 0x3d	; 61
    8516:	be b7       	in	r27, 0x3e	; 62
    8518:	12 96       	adiw	r26, 0x02	; 2
    851a:	1c 93       	st	X, r17
    851c:	0e 93       	st	-X, r16
    851e:	11 97       	sbiw	r26, 0x01	; 1
    8520:	88 e4       	ldi	r24, 0x48	; 72
    8522:	94 e1       	ldi	r25, 0x14	; 20
    8524:	14 96       	adiw	r26, 0x04	; 4
    8526:	9c 93       	st	X, r25
    8528:	8e 93       	st	-X, r24
    852a:	13 97       	sbiw	r26, 0x03	; 3
    852c:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    8530:	0f 90       	pop	r0
    8532:	0f 90       	pop	r0
    8534:	0f 90       	pop	r0
    8536:	0f 90       	pop	r0
}
    8538:	df 91       	pop	r29
    853a:	cf 91       	pop	r28
    853c:	1f 91       	pop	r17
    853e:	0f 91       	pop	r16
    8540:	ff 90       	pop	r15
    8542:	ef 90       	pop	r14
    8544:	df 90       	pop	r13
    8546:	cf 90       	pop	r12
    8548:	08 95       	ret

0000854a <netstackIPv6Process>:
}

void netstackIPv6Process(void)
{
  //uip_ip6addr_t *ipv6addr;
  fprintf_P(debugStream, PSTR("IPv6 packet in.\r\n"));
    854a:	00 d0       	rcall	.+0      	; 0x854c <netstackIPv6Process+0x2>
    854c:	00 d0       	rcall	.+0      	; 0x854e <netstackIPv6Process+0x4>
    854e:	80 91 50 0f 	lds	r24, 0x0F50
    8552:	90 91 51 0f 	lds	r25, 0x0F51
    8556:	ed b7       	in	r30, 0x3d	; 61
    8558:	fe b7       	in	r31, 0x3e	; 62
    855a:	92 83       	std	Z+2, r25	; 0x02
    855c:	81 83       	std	Z+1, r24	; 0x01
    855e:	82 e6       	ldi	r24, 0x62	; 98
    8560:	94 e1       	ldi	r25, 0x14	; 20
    8562:	94 83       	std	Z+4, r25	; 0x04
    8564:	83 83       	std	Z+3, r24	; 0x03
    8566:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    

  netPrintIpv6Header(debugStream);
    856a:	0f 90       	pop	r0
    856c:	0f 90       	pop	r0
    856e:	0f 90       	pop	r0
    8570:	0f 90       	pop	r0
    8572:	80 91 50 0f 	lds	r24, 0x0F50
    8576:	90 91 51 0f 	lds	r25, 0x0F51
    857a:	0e 94 76 40 	call	0x80ec	; 0x80ec <netPrintIpv6Header>
  
}
    857e:	08 95       	ret

00008580 <ipv6Init>:
#include "ipv6.h"
#include "../../freeRtos/Lib/net/include/ipv6.h"

void ipv6Init(void)
{
  Ipv6MyConfig.ip = xmalloc(sizeof(uip_ip6addr_t));
    8580:	80 e1       	ldi	r24, 0x10	; 16
    8582:	90 e0       	ldi	r25, 0x00	; 0
    8584:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    8588:	90 93 bd 0e 	sts	0x0EBD, r25
    858c:	80 93 bc 0e 	sts	0x0EBC, r24
  Ipv6MyConfig.prefix= 64;
    8590:	80 e4       	ldi	r24, 0x40	; 64
    8592:	80 93 be 0e 	sts	0x0EBE, r24
  Ipv6MyConfig.gateway = xmalloc(sizeof(uip_ip6addr_t));
    8596:	80 e1       	ldi	r24, 0x10	; 16
    8598:	90 e0       	ldi	r25, 0x00	; 0
    859a:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    859e:	90 93 c0 0e 	sts	0x0EC0, r25
    85a2:	80 93 bf 0e 	sts	0x0EBF, r24
}
    85a6:	08 95       	ret
    85a8:	08 95       	ret
    85aa:	08 95       	ret
    85ac:	08 95       	ret
    85ae:	81 e0       	ldi	r24, 0x01	; 1
    85b0:	08 95       	ret
    85b2:	81 e0       	ldi	r24, 0x01	; 1
    85b4:	08 95       	ret

000085b6 <rs485curtainUp>:
  releaseRs485();
  return 0;
}

uint8_t rs485curtainUp(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    85b6:	ff 92       	push	r15
    85b8:	0f 93       	push	r16
    85ba:	1f 93       	push	r17
    85bc:	cf 93       	push	r28
    85be:	df 93       	push	r29
    85c0:	18 2f       	mov	r17, r24
    85c2:	06 2f       	mov	r16, r22
    85c4:	f4 2e       	mov	r15, r20
    85c6:	c0 e0       	ldi	r28, 0x00	; 0
    85c8:	d0 e0       	ldi	r29, 0x00	; 0
    85ca:	8a e5       	ldi	r24, 0x5A	; 90
    85cc:	d8 27       	eor	r29, r24
    85ce:	0d 2e       	mov	r0, r29
    85d0:	02 94       	swap	r0
    85d2:	80 2d       	mov	r24, r0
    85d4:	8f 70       	andi	r24, 0x0F	; 15
    85d6:	8d 27       	eor	r24, r29
    85d8:	9d 2f       	mov	r25, r29
    85da:	90 25       	eor	r25, r0
    85dc:	99 0f       	add	r25, r25
    85de:	90 7e       	andi	r25, 0xE0	; 224
    85e0:	89 27       	eor	r24, r25
    85e2:	90 2d       	mov	r25, r0
    85e4:	9d 27       	eor	r25, r29
    85e6:	90 7f       	andi	r25, 0xF0	; 240
    85e8:	96 95       	lsr	r25
    85ea:	0d 2e       	mov	r0, r29
    85ec:	00 0c       	add	r0, r0
    85ee:	99 1f       	adc	r25, r25
    85f0:	d6 95       	lsr	r29
    85f2:	d6 95       	lsr	r29
    85f4:	d6 95       	lsr	r29
    85f6:	df 71       	andi	r29, 0x1F	; 31
    85f8:	d9 27       	eor	r29, r25
    85fa:	dc 27       	eor	r29, r28
    85fc:	c8 2f       	mov	r28, r24
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
  uartRs485SendByte(SYNC);
    85fe:	8a e5       	ldi	r24, 0x5A	; 90
    8600:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8604:	d1 27       	eor	r29, r17
    8606:	0d 2e       	mov	r0, r29
    8608:	02 94       	swap	r0
    860a:	80 2d       	mov	r24, r0
    860c:	8f 70       	andi	r24, 0x0F	; 15
    860e:	8d 27       	eor	r24, r29
    8610:	9d 2f       	mov	r25, r29
    8612:	90 25       	eor	r25, r0
    8614:	99 0f       	add	r25, r25
    8616:	90 7e       	andi	r25, 0xE0	; 224
    8618:	89 27       	eor	r24, r25
    861a:	90 2d       	mov	r25, r0
    861c:	9d 27       	eor	r25, r29
    861e:	90 7f       	andi	r25, 0xF0	; 240
    8620:	96 95       	lsr	r25
    8622:	0d 2e       	mov	r0, r29
    8624:	00 0c       	add	r0, r0
    8626:	99 1f       	adc	r25, r25
    8628:	d6 95       	lsr	r29
    862a:	d6 95       	lsr	r29
    862c:	d6 95       	lsr	r29
    862e:	df 71       	andi	r29, 0x1F	; 31
    8630:	d9 27       	eor	r29, r25
    8632:	dc 27       	eor	r29, r28
    8634:	c8 2f       	mov	r28, r24

  crc = _crc_xmodem_update(crc, deviceAddr);
  uartRs485SendByte(deviceAddr);
    8636:	81 2f       	mov	r24, r17
    8638:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  if (curtainNo == 0)
    863c:	00 23       	and	r16, r16
    863e:	e1 f4       	brne	.+56     	; 0x8678 <rs485curtainUp+0xc2>
    8640:	80 e2       	ldi	r24, 0x20	; 32
    8642:	d8 27       	eor	r29, r24
    8644:	0d 2e       	mov	r0, r29
    8646:	02 94       	swap	r0
    8648:	80 2d       	mov	r24, r0
    864a:	8f 70       	andi	r24, 0x0F	; 15
    864c:	8d 27       	eor	r24, r29
    864e:	9d 2f       	mov	r25, r29
    8650:	90 25       	eor	r25, r0
    8652:	99 0f       	add	r25, r25
    8654:	90 7e       	andi	r25, 0xE0	; 224
    8656:	89 27       	eor	r24, r25
    8658:	90 2d       	mov	r25, r0
    865a:	9d 27       	eor	r25, r29
    865c:	90 7f       	andi	r25, 0xF0	; 240
    865e:	96 95       	lsr	r25
    8660:	0d 2e       	mov	r0, r29
    8662:	00 0c       	add	r0, r0
    8664:	99 1f       	adc	r25, r25
    8666:	d6 95       	lsr	r29
    8668:	d6 95       	lsr	r29
    866a:	d6 95       	lsr	r29
    866c:	df 71       	andi	r29, 0x1F	; 31
    866e:	d9 27       	eor	r29, r25
    8670:	dc 27       	eor	r29, r28
    8672:	c8 2f       	mov	r28, r24
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete1);
    uartRs485SendByte(rPodniesRolete1);
    8674:	80 e2       	ldi	r24, 0x20	; 32
    8676:	1b c0       	rjmp	.+54     	; 0x86ae <rs485curtainUp+0xf8>
    8678:	81 e2       	ldi	r24, 0x21	; 33
    867a:	d8 27       	eor	r29, r24
    867c:	0d 2e       	mov	r0, r29
    867e:	02 94       	swap	r0
    8680:	80 2d       	mov	r24, r0
    8682:	8f 70       	andi	r24, 0x0F	; 15
    8684:	8d 27       	eor	r24, r29
    8686:	9d 2f       	mov	r25, r29
    8688:	90 25       	eor	r25, r0
    868a:	99 0f       	add	r25, r25
    868c:	90 7e       	andi	r25, 0xE0	; 224
    868e:	89 27       	eor	r24, r25
    8690:	90 2d       	mov	r25, r0
    8692:	9d 27       	eor	r25, r29
    8694:	90 7f       	andi	r25, 0xF0	; 240
    8696:	96 95       	lsr	r25
    8698:	0d 2e       	mov	r0, r29
    869a:	00 0c       	add	r0, r0
    869c:	99 1f       	adc	r25, r25
    869e:	d6 95       	lsr	r29
    86a0:	d6 95       	lsr	r29
    86a2:	d6 95       	lsr	r29
    86a4:	df 71       	andi	r29, 0x1F	; 31
    86a6:	d9 27       	eor	r29, r25
    86a8:	dc 27       	eor	r29, r28
    86aa:	c8 2f       	mov	r28, r24
  }
  else
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete2);
    uartRs485SendByte(rPodniesRolete2); 
    86ac:	81 e2       	ldi	r24, 0x21	; 33
    86ae:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    86b2:	81 e0       	ldi	r24, 0x01	; 1
    86b4:	d8 27       	eor	r29, r24
    86b6:	0d 2e       	mov	r0, r29
    86b8:	02 94       	swap	r0
    86ba:	80 2d       	mov	r24, r0
    86bc:	8f 70       	andi	r24, 0x0F	; 15
    86be:	8d 27       	eor	r24, r29
    86c0:	9d 2f       	mov	r25, r29
    86c2:	90 25       	eor	r25, r0
    86c4:	99 0f       	add	r25, r25
    86c6:	90 7e       	andi	r25, 0xE0	; 224
    86c8:	89 27       	eor	r24, r25
    86ca:	90 2d       	mov	r25, r0
    86cc:	9d 27       	eor	r25, r29
    86ce:	90 7f       	andi	r25, 0xF0	; 240
    86d0:	96 95       	lsr	r25
    86d2:	0d 2e       	mov	r0, r29
    86d4:	00 0c       	add	r0, r0
    86d6:	99 1f       	adc	r25, r25
    86d8:	d6 95       	lsr	r29
    86da:	d6 95       	lsr	r29
    86dc:	d6 95       	lsr	r29
    86de:	df 71       	andi	r29, 0x1F	; 31
    86e0:	d9 27       	eor	r29, r25
    86e2:	dc 27       	eor	r29, r28
    86e4:	c8 2f       	mov	r28, r24
  }
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    86e6:	81 e0       	ldi	r24, 0x01	; 1
    86e8:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    86ec:	df 25       	eor	r29, r15
    86ee:	0d 2e       	mov	r0, r29
    86f0:	02 94       	swap	r0
    86f2:	80 2d       	mov	r24, r0
    86f4:	8f 70       	andi	r24, 0x0F	; 15
    86f6:	8d 27       	eor	r24, r29
    86f8:	9d 2f       	mov	r25, r29
    86fa:	90 25       	eor	r25, r0
    86fc:	99 0f       	add	r25, r25
    86fe:	90 7e       	andi	r25, 0xE0	; 224
    8700:	89 27       	eor	r24, r25
    8702:	90 2d       	mov	r25, r0
    8704:	9d 27       	eor	r25, r29
    8706:	90 7f       	andi	r25, 0xF0	; 240
    8708:	96 95       	lsr	r25
    870a:	0d 2e       	mov	r0, r29
    870c:	00 0c       	add	r0, r0
    870e:	99 1f       	adc	r25, r25
    8710:	d6 95       	lsr	r29
    8712:	d6 95       	lsr	r29
    8714:	d6 95       	lsr	r29
    8716:	df 71       	andi	r29, 0x1F	; 31
    8718:	d9 27       	eor	r29, r25
    871a:	dc 27       	eor	r29, r28
    871c:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, pos);  uartRs485SendByte(pos);
    871e:	8f 2d       	mov	r24, r15
    8720:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8724:	8d 2f       	mov	r24, r29
    8726:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    872a:	8c 2f       	mov	r24, r28
    872c:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  
  return 0;
}
    8730:	80 e0       	ldi	r24, 0x00	; 0
    8732:	df 91       	pop	r29
    8734:	cf 91       	pop	r28
    8736:	1f 91       	pop	r17
    8738:	0f 91       	pop	r16
    873a:	ff 90       	pop	r15
    873c:	08 95       	ret

0000873e <rs485curtainDown>:

uint8_t rs485curtainDown(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    873e:	ff 92       	push	r15
    8740:	0f 93       	push	r16
    8742:	1f 93       	push	r17
    8744:	cf 93       	push	r28
    8746:	df 93       	push	r29
    8748:	18 2f       	mov	r17, r24
    874a:	06 2f       	mov	r16, r22
    874c:	f4 2e       	mov	r15, r20
    874e:	c0 e0       	ldi	r28, 0x00	; 0
    8750:	d0 e0       	ldi	r29, 0x00	; 0
    8752:	8a e5       	ldi	r24, 0x5A	; 90
    8754:	d8 27       	eor	r29, r24
    8756:	0d 2e       	mov	r0, r29
    8758:	02 94       	swap	r0
    875a:	80 2d       	mov	r24, r0
    875c:	8f 70       	andi	r24, 0x0F	; 15
    875e:	8d 27       	eor	r24, r29
    8760:	9d 2f       	mov	r25, r29
    8762:	90 25       	eor	r25, r0
    8764:	99 0f       	add	r25, r25
    8766:	90 7e       	andi	r25, 0xE0	; 224
    8768:	89 27       	eor	r24, r25
    876a:	90 2d       	mov	r25, r0
    876c:	9d 27       	eor	r25, r29
    876e:	90 7f       	andi	r25, 0xF0	; 240
    8770:	96 95       	lsr	r25
    8772:	0d 2e       	mov	r0, r29
    8774:	00 0c       	add	r0, r0
    8776:	99 1f       	adc	r25, r25
    8778:	d6 95       	lsr	r29
    877a:	d6 95       	lsr	r29
    877c:	d6 95       	lsr	r29
    877e:	df 71       	andi	r29, 0x1F	; 31
    8780:	d9 27       	eor	r29, r25
    8782:	dc 27       	eor	r29, r28
    8784:	c8 2f       	mov	r28, r24
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);            uartRs485SendByte(SYNC);
    8786:	8a e5       	ldi	r24, 0x5A	; 90
    8788:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    878c:	d1 27       	eor	r29, r17
    878e:	0d 2e       	mov	r0, r29
    8790:	02 94       	swap	r0
    8792:	80 2d       	mov	r24, r0
    8794:	8f 70       	andi	r24, 0x0F	; 15
    8796:	8d 27       	eor	r24, r29
    8798:	9d 2f       	mov	r25, r29
    879a:	90 25       	eor	r25, r0
    879c:	99 0f       	add	r25, r25
    879e:	90 7e       	andi	r25, 0xE0	; 224
    87a0:	89 27       	eor	r24, r25
    87a2:	90 2d       	mov	r25, r0
    87a4:	9d 27       	eor	r25, r29
    87a6:	90 7f       	andi	r25, 0xF0	; 240
    87a8:	96 95       	lsr	r25
    87aa:	0d 2e       	mov	r0, r29
    87ac:	00 0c       	add	r0, r0
    87ae:	99 1f       	adc	r25, r25
    87b0:	d6 95       	lsr	r29
    87b2:	d6 95       	lsr	r29
    87b4:	d6 95       	lsr	r29
    87b6:	df 71       	andi	r29, 0x1F	; 31
    87b8:	d9 27       	eor	r29, r25
    87ba:	dc 27       	eor	r29, r28
    87bc:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, deviceAddr);    uartRs485SendByte(deviceAddr);
    87be:	81 2f       	mov	r24, r17
    87c0:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  if (curtainNo == 0)
    87c4:	00 23       	and	r16, r16
    87c6:	e1 f4       	brne	.+56     	; 0x8800 <rs485curtainDown+0xc2>
    87c8:	80 e1       	ldi	r24, 0x10	; 16
    87ca:	d8 27       	eor	r29, r24
    87cc:	0d 2e       	mov	r0, r29
    87ce:	02 94       	swap	r0
    87d0:	80 2d       	mov	r24, r0
    87d2:	8f 70       	andi	r24, 0x0F	; 15
    87d4:	8d 27       	eor	r24, r29
    87d6:	9d 2f       	mov	r25, r29
    87d8:	90 25       	eor	r25, r0
    87da:	99 0f       	add	r25, r25
    87dc:	90 7e       	andi	r25, 0xE0	; 224
    87de:	89 27       	eor	r24, r25
    87e0:	90 2d       	mov	r25, r0
    87e2:	9d 27       	eor	r25, r29
    87e4:	90 7f       	andi	r25, 0xF0	; 240
    87e6:	96 95       	lsr	r25
    87e8:	0d 2e       	mov	r0, r29
    87ea:	00 0c       	add	r0, r0
    87ec:	99 1f       	adc	r25, r25
    87ee:	d6 95       	lsr	r29
    87f0:	d6 95       	lsr	r29
    87f2:	d6 95       	lsr	r29
    87f4:	df 71       	andi	r29, 0x1F	; 31
    87f6:	d9 27       	eor	r29, r25
    87f8:	dc 27       	eor	r29, r28
    87fa:	c8 2f       	mov	r28, r24
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete1); uartRs485SendByte(rOpuscRolete1);
    87fc:	80 e1       	ldi	r24, 0x10	; 16
    87fe:	1b c0       	rjmp	.+54     	; 0x8836 <rs485curtainDown+0xf8>
    8800:	81 e1       	ldi	r24, 0x11	; 17
    8802:	d8 27       	eor	r29, r24
    8804:	0d 2e       	mov	r0, r29
    8806:	02 94       	swap	r0
    8808:	80 2d       	mov	r24, r0
    880a:	8f 70       	andi	r24, 0x0F	; 15
    880c:	8d 27       	eor	r24, r29
    880e:	9d 2f       	mov	r25, r29
    8810:	90 25       	eor	r25, r0
    8812:	99 0f       	add	r25, r25
    8814:	90 7e       	andi	r25, 0xE0	; 224
    8816:	89 27       	eor	r24, r25
    8818:	90 2d       	mov	r25, r0
    881a:	9d 27       	eor	r25, r29
    881c:	90 7f       	andi	r25, 0xF0	; 240
    881e:	96 95       	lsr	r25
    8820:	0d 2e       	mov	r0, r29
    8822:	00 0c       	add	r0, r0
    8824:	99 1f       	adc	r25, r25
    8826:	d6 95       	lsr	r29
    8828:	d6 95       	lsr	r29
    882a:	d6 95       	lsr	r29
    882c:	df 71       	andi	r29, 0x1F	; 31
    882e:	d9 27       	eor	r29, r25
    8830:	dc 27       	eor	r29, r28
    8832:	c8 2f       	mov	r28, r24
  }
  else
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete2); uartRs485SendByte(rOpuscRolete2); 
    8834:	81 e1       	ldi	r24, 0x11	; 17
    8836:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    883a:	81 e0       	ldi	r24, 0x01	; 1
    883c:	d8 27       	eor	r29, r24
    883e:	0d 2e       	mov	r0, r29
    8840:	02 94       	swap	r0
    8842:	80 2d       	mov	r24, r0
    8844:	8f 70       	andi	r24, 0x0F	; 15
    8846:	8d 27       	eor	r24, r29
    8848:	9d 2f       	mov	r25, r29
    884a:	90 25       	eor	r25, r0
    884c:	99 0f       	add	r25, r25
    884e:	90 7e       	andi	r25, 0xE0	; 224
    8850:	89 27       	eor	r24, r25
    8852:	90 2d       	mov	r25, r0
    8854:	9d 27       	eor	r25, r29
    8856:	90 7f       	andi	r25, 0xF0	; 240
    8858:	96 95       	lsr	r25
    885a:	0d 2e       	mov	r0, r29
    885c:	00 0c       	add	r0, r0
    885e:	99 1f       	adc	r25, r25
    8860:	d6 95       	lsr	r29
    8862:	d6 95       	lsr	r29
    8864:	d6 95       	lsr	r29
    8866:	df 71       	andi	r29, 0x1F	; 31
    8868:	d9 27       	eor	r29, r25
    886a:	dc 27       	eor	r29, r28
    886c:	c8 2f       	mov	r28, r24
  }

  crc = _crc_xmodem_update(crc, 1);               uartRs485SendByte(1);
    886e:	81 e0       	ldi	r24, 0x01	; 1
    8870:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8874:	df 25       	eor	r29, r15
    8876:	0d 2e       	mov	r0, r29
    8878:	02 94       	swap	r0
    887a:	80 2d       	mov	r24, r0
    887c:	8f 70       	andi	r24, 0x0F	; 15
    887e:	8d 27       	eor	r24, r29
    8880:	9d 2f       	mov	r25, r29
    8882:	90 25       	eor	r25, r0
    8884:	99 0f       	add	r25, r25
    8886:	90 7e       	andi	r25, 0xE0	; 224
    8888:	89 27       	eor	r24, r25
    888a:	90 2d       	mov	r25, r0
    888c:	9d 27       	eor	r25, r29
    888e:	90 7f       	andi	r25, 0xF0	; 240
    8890:	96 95       	lsr	r25
    8892:	0d 2e       	mov	r0, r29
    8894:	00 0c       	add	r0, r0
    8896:	99 1f       	adc	r25, r25
    8898:	d6 95       	lsr	r29
    889a:	d6 95       	lsr	r29
    889c:	d6 95       	lsr	r29
    889e:	df 71       	andi	r29, 0x1F	; 31
    88a0:	d9 27       	eor	r29, r25
    88a2:	dc 27       	eor	r29, r28
    88a4:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, pos);         uartRs485SendByte(pos);
    88a6:	8f 2d       	mov	r24, r15
    88a8:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    88ac:	8d 2f       	mov	r24, r29
    88ae:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    88b2:	8c 2f       	mov	r24, r28
    88b4:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>

  return 0;
}
    88b8:	80 e0       	ldi	r24, 0x00	; 0
    88ba:	df 91       	pop	r29
    88bc:	cf 91       	pop	r28
    88be:	1f 91       	pop	r17
    88c0:	0f 91       	pop	r16
    88c2:	ff 90       	pop	r15
    88c4:	08 95       	ret

000088c6 <printRs485devices>:
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
}

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
    88c6:	af 92       	push	r10
    88c8:	bf 92       	push	r11
    88ca:	cf 92       	push	r12
    88cc:	df 92       	push	r13
    88ce:	ef 92       	push	r14
    88d0:	ff 92       	push	r15
    88d2:	0f 93       	push	r16
    88d4:	1f 93       	push	r17
    88d6:	cf 93       	push	r28
    88d8:	df 93       	push	r29
    88da:	7c 01       	movw	r14, r24
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
    88dc:	c0 91 a8 0e 	lds	r28, 0x0EA8
    88e0:	d0 91 a9 0e 	lds	r29, 0x0EA9
    88e4:	10 e0       	ldi	r17, 0x00	; 0
    88e6:	00 e0       	ldi	r16, 0x00	; 0
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    88e8:	94 e7       	ldi	r25, 0x74	; 116
    88ea:	a9 2e       	mov	r10, r25
    88ec:	94 e1       	ldi	r25, 0x14	; 20
    88ee:	b9 2e       	mov	r11, r25
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    88f0:	82 eb       	ldi	r24, 0xB2	; 178
    88f2:	c8 2e       	mov	r12, r24
    88f4:	84 e1       	ldi	r24, 0x14	; 20
    88f6:	d8 2e       	mov	r13, r24
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    88f8:	89 81       	ldd	r24, Y+1	; 0x01
    88fa:	88 23       	and	r24, r24
    88fc:	09 f4       	brne	.+2      	; 0x8900 <printRs485devices+0x3a>
    88fe:	43 c0       	rjmp	.+134    	; 0x8986 <printRs485devices+0xc0>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    8900:	2d b7       	in	r18, 0x3d	; 61
    8902:	3e b7       	in	r19, 0x3e	; 62
    8904:	2a 50       	subi	r18, 0x0A	; 10
    8906:	30 40       	sbci	r19, 0x00	; 0
    8908:	0f b6       	in	r0, 0x3f	; 63
    890a:	f8 94       	cli
    890c:	3e bf       	out	0x3e, r19	; 62
    890e:	0f be       	out	0x3f, r0	; 63
    8910:	2d bf       	out	0x3d, r18	; 61
    8912:	ed b7       	in	r30, 0x3d	; 61
    8914:	fe b7       	in	r31, 0x3e	; 62
    8916:	31 96       	adiw	r30, 0x01	; 1
    8918:	ad b7       	in	r26, 0x3d	; 61
    891a:	be b7       	in	r27, 0x3e	; 62
    891c:	12 96       	adiw	r26, 0x02	; 2
    891e:	fc 92       	st	X, r15
    8920:	ee 92       	st	-X, r14
    8922:	11 97       	sbiw	r26, 0x01	; 1
    8924:	b3 82       	std	Z+3, r11	; 0x03
    8926:	a2 82       	std	Z+2, r10	; 0x02
    8928:	84 83       	std	Z+4, r24	; 0x04
    892a:	15 82       	std	Z+5, r1	; 0x05
    892c:	8a 81       	ldd	r24, Y+2	; 0x02
    892e:	90 e0       	ldi	r25, 0x00	; 0
    8930:	8f 73       	andi	r24, 0x3F	; 63
    8932:	90 70       	andi	r25, 0x00	; 0
    8934:	97 83       	std	Z+7, r25	; 0x07
    8936:	86 83       	std	Z+6, r24	; 0x06
    8938:	8b 81       	ldd	r24, Y+3	; 0x03
    893a:	90 e0       	ldi	r25, 0x00	; 0
    893c:	8f 73       	andi	r24, 0x3F	; 63
    893e:	90 70       	andi	r25, 0x00	; 0
    8940:	91 87       	std	Z+9, r25	; 0x09
    8942:	80 87       	std	Z+8, r24	; 0x08
    8944:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    8948:	0f 90       	pop	r0
    894a:	0f 90       	pop	r0
    894c:	0f 90       	pop	r0
    894e:	0f 90       	pop	r0
    8950:	ed b7       	in	r30, 0x3d	; 61
    8952:	fe b7       	in	r31, 0x3e	; 62
    8954:	31 96       	adiw	r30, 0x01	; 1
    8956:	ad b7       	in	r26, 0x3d	; 61
    8958:	be b7       	in	r27, 0x3e	; 62
    895a:	12 96       	adiw	r26, 0x02	; 2
    895c:	fc 92       	st	X, r15
    895e:	ee 92       	st	-X, r14
    8960:	11 97       	sbiw	r26, 0x01	; 1
    8962:	d3 82       	std	Z+3, r13	; 0x03
    8964:	c2 82       	std	Z+2, r12	; 0x02
    8966:	24 96       	adiw	r28, 0x04	; 4
    8968:	d5 83       	std	Z+5, r29	; 0x05
    896a:	c4 83       	std	Z+4, r28	; 0x04
    896c:	24 97       	sbiw	r28, 0x04	; 4
    896e:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
      result++;
    8972:	0f 5f       	subi	r16, 0xFF	; 255
    8974:	2d b7       	in	r18, 0x3d	; 61
    8976:	3e b7       	in	r19, 0x3e	; 62
    8978:	2a 5f       	subi	r18, 0xFA	; 250
    897a:	3f 4f       	sbci	r19, 0xFF	; 255
    897c:	0f b6       	in	r0, 0x3f	; 63
    897e:	f8 94       	cli
    8980:	3e bf       	out	0x3e, r19	; 62
    8982:	0f be       	out	0x3f, r0	; 63
    8984:	2d bf       	out	0x3d, r18	; 61
{
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    8986:	1f 5f       	subi	r17, 0xFF	; 255
    8988:	1a 30       	cpi	r17, 0x0A	; 10
    898a:	11 f0       	breq	.+4      	; 0x8990 <printRs485devices+0xca>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
      result++;
    }
    rolTmp++;
    898c:	2a 96       	adiw	r28, 0x0a	; 10
    898e:	b4 cf       	rjmp	.-152    	; 0x88f8 <printRs485devices+0x32>
  }
  
  
  return result;
}
    8990:	80 2f       	mov	r24, r16
    8992:	df 91       	pop	r29
    8994:	cf 91       	pop	r28
    8996:	1f 91       	pop	r17
    8998:	0f 91       	pop	r16
    899a:	ff 90       	pop	r15
    899c:	ef 90       	pop	r14
    899e:	df 90       	pop	r13
    89a0:	cf 90       	pop	r12
    89a2:	bf 90       	pop	r11
    89a4:	af 90       	pop	r10
    89a6:	08 95       	ret

000089a8 <rs485xModemFlash>:
  return result;
}


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
    89a8:	6f 92       	push	r6
    89aa:	7f 92       	push	r7
    89ac:	8f 92       	push	r8
    89ae:	9f 92       	push	r9
    89b0:	af 92       	push	r10
    89b2:	bf 92       	push	r11
    89b4:	cf 92       	push	r12
    89b6:	df 92       	push	r13
    89b8:	ef 92       	push	r14
    89ba:	ff 92       	push	r15
    89bc:	0f 93       	push	r16
    89be:	1f 93       	push	r17
    89c0:	df 93       	push	r29
    89c2:	cf 93       	push	r28
    89c4:	00 d0       	rcall	.+0      	; 0x89c6 <rs485xModemFlash+0x1e>
    89c6:	cd b7       	in	r28, 0x3d	; 61
    89c8:	de b7       	in	r29, 0x3e	; 62
    89ca:	3c 01       	movw	r6, r24
    89cc:	b6 2e       	mov	r11, r22
    89ce:	6a 01       	movw	r12, r20
  uint8_t  blad = 0;
  uint8_t  data;
  uint8_t  nrBloku;
  uint8_t  lRetransmisji;
  
  takeRs485();                                  // Zajmowanie magistrali Rs485
    89d0:	0e 94 de 0c 	call	0x19bc	; 0x19bc <takeRs485>
    89d4:	00 e0       	ldi	r16, 0x00	; 0
    89d6:	10 e0       	ldi	r17, 0x00	; 0
    89d8:	8a e5       	ldi	r24, 0x5A	; 90
    89da:	18 27       	eor	r17, r24
    89dc:	01 2e       	mov	r0, r17
    89de:	02 94       	swap	r0
    89e0:	80 2d       	mov	r24, r0
    89e2:	8f 70       	andi	r24, 0x0F	; 15
    89e4:	81 27       	eor	r24, r17
    89e6:	91 2f       	mov	r25, r17
    89e8:	90 25       	eor	r25, r0
    89ea:	99 0f       	add	r25, r25
    89ec:	90 7e       	andi	r25, 0xE0	; 224
    89ee:	89 27       	eor	r24, r25
    89f0:	90 2d       	mov	r25, r0
    89f2:	91 27       	eor	r25, r17
    89f4:	90 7f       	andi	r25, 0xF0	; 240
    89f6:	96 95       	lsr	r25
    89f8:	01 2e       	mov	r0, r17
    89fa:	00 0c       	add	r0, r0
    89fc:	99 1f       	adc	r25, r25
    89fe:	16 95       	lsr	r17
    8a00:	16 95       	lsr	r17
    8a02:	16 95       	lsr	r17
    8a04:	1f 71       	andi	r17, 0x1F	; 31
    8a06:	19 27       	eor	r17, r25
    8a08:	10 27       	eor	r17, r16
    8a0a:	08 2f       	mov	r16, r24

  // Wysyłanie polecenia restartu
  crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    8a0c:	8a e5       	ldi	r24, 0x5A	; 90
    8a0e:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8a12:	1b 25       	eor	r17, r11
    8a14:	01 2e       	mov	r0, r17
    8a16:	02 94       	swap	r0
    8a18:	80 2d       	mov	r24, r0
    8a1a:	8f 70       	andi	r24, 0x0F	; 15
    8a1c:	81 27       	eor	r24, r17
    8a1e:	91 2f       	mov	r25, r17
    8a20:	90 25       	eor	r25, r0
    8a22:	99 0f       	add	r25, r25
    8a24:	90 7e       	andi	r25, 0xE0	; 224
    8a26:	89 27       	eor	r24, r25
    8a28:	90 2d       	mov	r25, r0
    8a2a:	91 27       	eor	r25, r17
    8a2c:	90 7f       	andi	r25, 0xF0	; 240
    8a2e:	96 95       	lsr	r25
    8a30:	01 2e       	mov	r0, r17
    8a32:	00 0c       	add	r0, r0
    8a34:	99 1f       	adc	r25, r25
    8a36:	16 95       	lsr	r17
    8a38:	16 95       	lsr	r17
    8a3a:	16 95       	lsr	r17
    8a3c:	1f 71       	andi	r17, 0x1F	; 31
    8a3e:	19 27       	eor	r17, r25
    8a40:	10 27       	eor	r17, r16
    8a42:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8a44:	8b 2d       	mov	r24, r11
    8a46:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8a4a:	81 e8       	ldi	r24, 0x81	; 129
    8a4c:	18 27       	eor	r17, r24
    8a4e:	01 2e       	mov	r0, r17
    8a50:	02 94       	swap	r0
    8a52:	80 2d       	mov	r24, r0
    8a54:	8f 70       	andi	r24, 0x0F	; 15
    8a56:	81 27       	eor	r24, r17
    8a58:	91 2f       	mov	r25, r17
    8a5a:	90 25       	eor	r25, r0
    8a5c:	99 0f       	add	r25, r25
    8a5e:	90 7e       	andi	r25, 0xE0	; 224
    8a60:	89 27       	eor	r24, r25
    8a62:	90 2d       	mov	r25, r0
    8a64:	91 27       	eor	r25, r17
    8a66:	90 7f       	andi	r25, 0xF0	; 240
    8a68:	96 95       	lsr	r25
    8a6a:	01 2e       	mov	r0, r17
    8a6c:	00 0c       	add	r0, r0
    8a6e:	99 1f       	adc	r25, r25
    8a70:	16 95       	lsr	r17
    8a72:	16 95       	lsr	r17
    8a74:	16 95       	lsr	r17
    8a76:	1f 71       	andi	r17, 0x1F	; 31
    8a78:	19 27       	eor	r17, r25
    8a7a:	10 27       	eor	r17, r16
    8a7c:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    8a7e:	81 e8       	ldi	r24, 0x81	; 129
    8a80:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8a84:	81 e0       	ldi	r24, 0x01	; 1
    8a86:	18 27       	eor	r17, r24
    8a88:	01 2e       	mov	r0, r17
    8a8a:	02 94       	swap	r0
    8a8c:	80 2d       	mov	r24, r0
    8a8e:	8f 70       	andi	r24, 0x0F	; 15
    8a90:	81 27       	eor	r24, r17
    8a92:	91 2f       	mov	r25, r17
    8a94:	90 25       	eor	r25, r0
    8a96:	99 0f       	add	r25, r25
    8a98:	90 7e       	andi	r25, 0xE0	; 224
    8a9a:	89 27       	eor	r24, r25
    8a9c:	90 2d       	mov	r25, r0
    8a9e:	91 27       	eor	r25, r17
    8aa0:	90 7f       	andi	r25, 0xF0	; 240
    8aa2:	96 95       	lsr	r25
    8aa4:	01 2e       	mov	r0, r17
    8aa6:	00 0c       	add	r0, r0
    8aa8:	99 1f       	adc	r25, r25
    8aaa:	16 95       	lsr	r17
    8aac:	16 95       	lsr	r17
    8aae:	16 95       	lsr	r17
    8ab0:	1f 71       	andi	r17, 0x1F	; 31
    8ab2:	19 27       	eor	r17, r25
    8ab4:	10 27       	eor	r17, r16
    8ab6:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    8ab8:	81 e0       	ldi	r24, 0x01	; 1
    8aba:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8abe:	1b 25       	eor	r17, r11
    8ac0:	01 2e       	mov	r0, r17
    8ac2:	02 94       	swap	r0
    8ac4:	80 2d       	mov	r24, r0
    8ac6:	8f 70       	andi	r24, 0x0F	; 15
    8ac8:	81 27       	eor	r24, r17
    8aca:	91 2f       	mov	r25, r17
    8acc:	90 25       	eor	r25, r0
    8ace:	99 0f       	add	r25, r25
    8ad0:	90 7e       	andi	r25, 0xE0	; 224
    8ad2:	89 27       	eor	r24, r25
    8ad4:	90 2d       	mov	r25, r0
    8ad6:	91 27       	eor	r25, r17
    8ad8:	90 7f       	andi	r25, 0xF0	; 240
    8ada:	96 95       	lsr	r25
    8adc:	01 2e       	mov	r0, r17
    8ade:	00 0c       	add	r0, r0
    8ae0:	99 1f       	adc	r25, r25
    8ae2:	16 95       	lsr	r17
    8ae4:	16 95       	lsr	r17
    8ae6:	16 95       	lsr	r17
    8ae8:	1f 71       	andi	r17, 0x1F	; 31
    8aea:	19 27       	eor	r17, r25
    8aec:	10 27       	eor	r17, r16
    8aee:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8af0:	8b 2d       	mov	r24, r11
    8af2:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc>>8));
    8af6:	81 2f       	mov	r24, r17
    8af8:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8afc:	80 2f       	mov	r24, r16
    8afe:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
 

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
    8b02:	ce 01       	movw	r24, r28
    8b04:	01 96       	adiw	r24, 0x01	; 1
    8b06:	64 e6       	ldi	r22, 0x64	; 100
    8b08:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8b0c:	81 30       	cpi	r24, 0x01	; 1
    8b0e:	11 f4       	brne	.+4      	; 0x8b14 <rs485xModemFlash+0x16c>
    8b10:	10 e0       	ldi	r17, 0x00	; 0
    8b12:	1a c0       	rjmp	.+52     	; 0x8b48 <rs485xModemFlash+0x1a0>
  {
    blad = 1;                                  // Timeout
    if (debugStr != NULL)
    8b14:	c1 14       	cp	r12, r1
    8b16:	d1 04       	cpc	r13, r1
    8b18:	11 f4       	brne	.+4      	; 0x8b1e <rs485xModemFlash+0x176>
    8b1a:	11 e0       	ldi	r17, 0x01	; 1
    8b1c:	15 c0       	rjmp	.+42     	; 0x8b48 <rs485xModemFlash+0x1a0>
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
    8b1e:	00 d0       	rcall	.+0      	; 0x8b20 <rs485xModemFlash+0x178>
    8b20:	00 d0       	rcall	.+0      	; 0x8b22 <rs485xModemFlash+0x17a>
    8b22:	ad b7       	in	r26, 0x3d	; 61
    8b24:	be b7       	in	r27, 0x3e	; 62
    8b26:	12 96       	adiw	r26, 0x02	; 2
    8b28:	dc 92       	st	X, r13
    8b2a:	ce 92       	st	-X, r12
    8b2c:	11 97       	sbiw	r26, 0x01	; 1
    8b2e:	80 e2       	ldi	r24, 0x20	; 32
    8b30:	95 e1       	ldi	r25, 0x15	; 21
    8b32:	14 96       	adiw	r26, 0x04	; 4
    8b34:	9c 93       	st	X, r25
    8b36:	8e 93       	st	-X, r24
    8b38:	13 97       	sbiw	r26, 0x03	; 3
    8b3a:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    8b3e:	11 e0       	ldi	r17, 0x01	; 1
    8b40:	0f 90       	pop	r0
    8b42:	0f 90       	pop	r0
    8b44:	0f 90       	pop	r0
    8b46:	0f 90       	pop	r0
  }
  crc = _crc_xmodem_update(0, data);
    8b48:	89 81       	ldd	r24, Y+1	; 0x01
    8b4a:	ee 24       	eor	r14, r14
    8b4c:	ff 24       	eor	r15, r15
    8b4e:	f7 01       	movw	r30, r14
    8b50:	f8 27       	eor	r31, r24
    8b52:	0f 2e       	mov	r0, r31
    8b54:	02 94       	swap	r0
    8b56:	90 2d       	mov	r25, r0
    8b58:	9f 70       	andi	r25, 0x0F	; 15
    8b5a:	9f 27       	eor	r25, r31
    8b5c:	2f 2f       	mov	r18, r31
    8b5e:	20 25       	eor	r18, r0
    8b60:	22 0f       	add	r18, r18
    8b62:	20 7e       	andi	r18, 0xE0	; 224
    8b64:	92 27       	eor	r25, r18
    8b66:	20 2d       	mov	r18, r0
    8b68:	2f 27       	eor	r18, r31
    8b6a:	20 7f       	andi	r18, 0xF0	; 240
    8b6c:	26 95       	lsr	r18
    8b6e:	0f 2e       	mov	r0, r31
    8b70:	00 0c       	add	r0, r0
    8b72:	22 1f       	adc	r18, r18
    8b74:	f6 95       	lsr	r31
    8b76:	f6 95       	lsr	r31
    8b78:	f6 95       	lsr	r31
    8b7a:	ff 71       	andi	r31, 0x1F	; 31
    8b7c:	f2 27       	eor	r31, r18
    8b7e:	fe 27       	eor	r31, r30
    8b80:	e9 2f       	mov	r30, r25
    8b82:	7f 01       	movw	r14, r30
 
  if ((blad == 0) && (data == 'C'))
    8b84:	11 23       	and	r17, r17
    8b86:	d9 f4       	brne	.+54     	; 0x8bbe <rs485xModemFlash+0x216>
    8b88:	83 34       	cpi	r24, 0x43	; 67
    8b8a:	c9 f4       	brne	.+50     	; 0x8bbe <rs485xModemFlash+0x216>
  {
    blad = 253;                                //Na urządzeniu jest wgrany tylko bootloader
    if (debugStr != NULL)
    8b8c:	c1 14       	cp	r12, r1
    8b8e:	d1 04       	cpc	r13, r1
    8b90:	09 f4       	brne	.+2      	; 0x8b94 <rs485xModemFlash+0x1ec>
    8b92:	87 c1       	rjmp	.+782    	; 0x8ea2 <rs485xModemFlash+0x4fa>
      fprintf_P(debugStr, PSTR("na urzadzeniu wgrany jest tylko bootloader\r\n"));    
    8b94:	00 d0       	rcall	.+0      	; 0x8b96 <rs485xModemFlash+0x1ee>
    8b96:	00 d0       	rcall	.+0      	; 0x8b98 <rs485xModemFlash+0x1f0>
    8b98:	ad b7       	in	r26, 0x3d	; 61
    8b9a:	be b7       	in	r27, 0x3e	; 62
    8b9c:	12 96       	adiw	r26, 0x02	; 2
    8b9e:	dc 92       	st	X, r13
    8ba0:	ce 92       	st	-X, r12
    8ba2:	11 97       	sbiw	r26, 0x01	; 1
    8ba4:	83 ef       	ldi	r24, 0xF3	; 243
    8ba6:	94 e1       	ldi	r25, 0x14	; 20
    8ba8:	14 96       	adiw	r26, 0x04	; 4
    8baa:	9c 93       	st	X, r25
    8bac:	8e 93       	st	-X, r24
    8bae:	13 97       	sbiw	r26, 0x03	; 3
    8bb0:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    8bb4:	0f 90       	pop	r0
    8bb6:	0f 90       	pop	r0
    8bb8:	0f 90       	pop	r0
    8bba:	0f 90       	pop	r0
    8bbc:	72 c1       	rjmp	.+740    	; 0x8ea2 <rs485xModemFlash+0x4fa>
  }
  else
  {
    if (data != SYNC)
    8bbe:	8a 35       	cpi	r24, 0x5A	; 90
    8bc0:	09 f0       	breq	.+2      	; 0x8bc4 <rs485xModemFlash+0x21c>
    8bc2:	c7 c0       	rjmp	.+398    	; 0x8d52 <rs485xModemFlash+0x3aa>
      blad = 2;
  }
 
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
    8bc4:	11 23       	and	r17, r17
    8bc6:	09 f0       	breq	.+2      	; 0x8bca <rs485xModemFlash+0x222>
    8bc8:	c4 c0       	rjmp	.+392    	; 0x8d52 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8bca:	ce 01       	movw	r24, r28
    8bcc:	01 96       	adiw	r24, 0x01	; 1
    8bce:	61 e0       	ldi	r22, 0x01	; 1
    8bd0:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8bd4:	81 30       	cpi	r24, 0x01	; 1
    8bd6:	11 f0       	breq	.+4      	; 0x8bdc <rs485xModemFlash+0x234>
    8bd8:	13 e0       	ldi	r17, 0x03	; 3
    8bda:	03 c0       	rjmp	.+6      	; 0x8be2 <rs485xModemFlash+0x23a>
      blad = 3;
    else
    {
      if (data != 0)
    8bdc:	89 81       	ldd	r24, Y+1	; 0x01
    8bde:	81 11       	cpse	r24, r1
    8be0:	14 e0       	ldi	r17, 0x04	; 4
    8be2:	89 81       	ldd	r24, Y+1	; 0x01
    8be4:	f7 01       	movw	r30, r14
    8be6:	f8 27       	eor	r31, r24
    8be8:	0f 2e       	mov	r0, r31
    8bea:	02 94       	swap	r0
    8bec:	80 2d       	mov	r24, r0
    8bee:	8f 70       	andi	r24, 0x0F	; 15
    8bf0:	8f 27       	eor	r24, r31
    8bf2:	9f 2f       	mov	r25, r31
    8bf4:	90 25       	eor	r25, r0
    8bf6:	99 0f       	add	r25, r25
    8bf8:	90 7e       	andi	r25, 0xE0	; 224
    8bfa:	89 27       	eor	r24, r25
    8bfc:	90 2d       	mov	r25, r0
    8bfe:	9f 27       	eor	r25, r31
    8c00:	90 7f       	andi	r25, 0xF0	; 240
    8c02:	96 95       	lsr	r25
    8c04:	0f 2e       	mov	r0, r31
    8c06:	00 0c       	add	r0, r0
    8c08:	99 1f       	adc	r25, r25
    8c0a:	f6 95       	lsr	r31
    8c0c:	f6 95       	lsr	r31
    8c0e:	f6 95       	lsr	r31
    8c10:	ff 71       	andi	r31, 0x1F	; 31
    8c12:	f9 27       	eor	r31, r25
    8c14:	fe 27       	eor	r31, r30
    8c16:	e8 2f       	mov	r30, r24
    8c18:	7f 01       	movw	r14, r30
    }
    crc = _crc_xmodem_update(crc, data);
  }
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
    8c1a:	11 23       	and	r17, r17
    8c1c:	09 f0       	breq	.+2      	; 0x8c20 <rs485xModemFlash+0x278>
    8c1e:	99 c0       	rjmp	.+306    	; 0x8d52 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8c20:	ce 01       	movw	r24, r28
    8c22:	01 96       	adiw	r24, 0x01	; 1
    8c24:	61 e0       	ldi	r22, 0x01	; 1
    8c26:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8c2a:	81 30       	cpi	r24, 0x01	; 1
    8c2c:	11 f0       	breq	.+4      	; 0x8c32 <rs485xModemFlash+0x28a>
    8c2e:	15 e0       	ldi	r17, 0x05	; 5
    8c30:	04 c0       	rjmp	.+8      	; 0x8c3a <rs485xModemFlash+0x292>
      blad = 5;
    else
    {
      if (data != rFLASH)
    8c32:	89 81       	ldd	r24, Y+1	; 0x01
    8c34:	81 38       	cpi	r24, 0x81	; 129
    8c36:	09 f0       	breq	.+2      	; 0x8c3a <rs485xModemFlash+0x292>
    8c38:	16 e0       	ldi	r17, 0x06	; 6
    8c3a:	89 81       	ldd	r24, Y+1	; 0x01
    8c3c:	97 01       	movw	r18, r14
    8c3e:	38 27       	eor	r19, r24
    8c40:	03 2e       	mov	r0, r19
    8c42:	02 94       	swap	r0
    8c44:	80 2d       	mov	r24, r0
    8c46:	8f 70       	andi	r24, 0x0F	; 15
    8c48:	83 27       	eor	r24, r19
    8c4a:	93 2f       	mov	r25, r19
    8c4c:	90 25       	eor	r25, r0
    8c4e:	99 0f       	add	r25, r25
    8c50:	90 7e       	andi	r25, 0xE0	; 224
    8c52:	89 27       	eor	r24, r25
    8c54:	90 2d       	mov	r25, r0
    8c56:	93 27       	eor	r25, r19
    8c58:	90 7f       	andi	r25, 0xF0	; 240
    8c5a:	96 95       	lsr	r25
    8c5c:	03 2e       	mov	r0, r19
    8c5e:	00 0c       	add	r0, r0
    8c60:	99 1f       	adc	r25, r25
    8c62:	36 95       	lsr	r19
    8c64:	36 95       	lsr	r19
    8c66:	36 95       	lsr	r19
    8c68:	3f 71       	andi	r19, 0x1F	; 31
    8c6a:	39 27       	eor	r19, r25
    8c6c:	32 27       	eor	r19, r18
    8c6e:	28 2f       	mov	r18, r24
    8c70:	79 01       	movw	r14, r18
    }
    crc = _crc_xmodem_update(crc, data);
  }
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
    8c72:	11 23       	and	r17, r17
    8c74:	09 f0       	breq	.+2      	; 0x8c78 <rs485xModemFlash+0x2d0>
    8c76:	6d c0       	rjmp	.+218    	; 0x8d52 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8c78:	ce 01       	movw	r24, r28
    8c7a:	01 96       	adiw	r24, 0x01	; 1
    8c7c:	61 e0       	ldi	r22, 0x01	; 1
    8c7e:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8c82:	81 30       	cpi	r24, 0x01	; 1
    8c84:	11 f0       	breq	.+4      	; 0x8c8a <rs485xModemFlash+0x2e2>
    8c86:	17 e0       	ldi	r17, 0x07	; 7
    8c88:	04 c0       	rjmp	.+8      	; 0x8c92 <rs485xModemFlash+0x2ea>
      blad = 7;
    else
    {
      if (data != 1)
    8c8a:	89 81       	ldd	r24, Y+1	; 0x01
    8c8c:	81 30       	cpi	r24, 0x01	; 1
    8c8e:	09 f0       	breq	.+2      	; 0x8c92 <rs485xModemFlash+0x2ea>
    8c90:	18 e0       	ldi	r17, 0x08	; 8
    8c92:	89 81       	ldd	r24, Y+1	; 0x01
    8c94:	a7 01       	movw	r20, r14
    8c96:	58 27       	eor	r21, r24
    8c98:	05 2e       	mov	r0, r21
    8c9a:	02 94       	swap	r0
    8c9c:	80 2d       	mov	r24, r0
    8c9e:	8f 70       	andi	r24, 0x0F	; 15
    8ca0:	85 27       	eor	r24, r21
    8ca2:	95 2f       	mov	r25, r21
    8ca4:	90 25       	eor	r25, r0
    8ca6:	99 0f       	add	r25, r25
    8ca8:	90 7e       	andi	r25, 0xE0	; 224
    8caa:	89 27       	eor	r24, r25
    8cac:	90 2d       	mov	r25, r0
    8cae:	95 27       	eor	r25, r21
    8cb0:	90 7f       	andi	r25, 0xF0	; 240
    8cb2:	96 95       	lsr	r25
    8cb4:	05 2e       	mov	r0, r21
    8cb6:	00 0c       	add	r0, r0
    8cb8:	99 1f       	adc	r25, r25
    8cba:	56 95       	lsr	r21
    8cbc:	56 95       	lsr	r21
    8cbe:	56 95       	lsr	r21
    8cc0:	5f 71       	andi	r21, 0x1F	; 31
    8cc2:	59 27       	eor	r21, r25
    8cc4:	54 27       	eor	r21, r20
    8cc6:	48 2f       	mov	r20, r24
    8cc8:	7a 01       	movw	r14, r20
    }
    crc = _crc_xmodem_update(crc, data);
  }
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
    8cca:	11 23       	and	r17, r17
    8ccc:	09 f0       	breq	.+2      	; 0x8cd0 <rs485xModemFlash+0x328>
    8cce:	41 c0       	rjmp	.+130    	; 0x8d52 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8cd0:	ce 01       	movw	r24, r28
    8cd2:	01 96       	adiw	r24, 0x01	; 1
    8cd4:	61 e0       	ldi	r22, 0x01	; 1
    8cd6:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8cda:	81 30       	cpi	r24, 0x01	; 1
    8cdc:	11 f0       	breq	.+4      	; 0x8ce2 <rs485xModemFlash+0x33a>
    8cde:	19 e0       	ldi	r17, 0x09	; 9
    8ce0:	03 c0       	rjmp	.+6      	; 0x8ce8 <rs485xModemFlash+0x340>
      blad = 9;
    else
    {
      if (data != devAddr)
    8ce2:	89 81       	ldd	r24, Y+1	; 0x01
    8ce4:	8b 11       	cpse	r24, r11
    8ce6:	1a e0       	ldi	r17, 0x0A	; 10
    8ce8:	89 81       	ldd	r24, Y+1	; 0x01
    8cea:	d7 01       	movw	r26, r14
    8cec:	b8 27       	eor	r27, r24
    8cee:	0b 2e       	mov	r0, r27
    8cf0:	02 94       	swap	r0
    8cf2:	80 2d       	mov	r24, r0
    8cf4:	8f 70       	andi	r24, 0x0F	; 15
    8cf6:	8b 27       	eor	r24, r27
    8cf8:	9b 2f       	mov	r25, r27
    8cfa:	90 25       	eor	r25, r0
    8cfc:	99 0f       	add	r25, r25
    8cfe:	90 7e       	andi	r25, 0xE0	; 224
    8d00:	89 27       	eor	r24, r25
    8d02:	90 2d       	mov	r25, r0
    8d04:	9b 27       	eor	r25, r27
    8d06:	90 7f       	andi	r25, 0xF0	; 240
    8d08:	96 95       	lsr	r25
    8d0a:	0b 2e       	mov	r0, r27
    8d0c:	00 0c       	add	r0, r0
    8d0e:	99 1f       	adc	r25, r25
    8d10:	b6 95       	lsr	r27
    8d12:	b6 95       	lsr	r27
    8d14:	b6 95       	lsr	r27
    8d16:	bf 71       	andi	r27, 0x1F	; 31
    8d18:	b9 27       	eor	r27, r25
    8d1a:	ba 27       	eor	r27, r26
    8d1c:	a8 2f       	mov	r26, r24
    8d1e:	7d 01       	movw	r14, r26
    }
    crc = _crc_xmodem_update(crc, data);
  }
   
  //Odbieranie CRC Hi
  if (blad == 0)
    8d20:	11 23       	and	r17, r17
    8d22:	b9 f4       	brne	.+46     	; 0x8d52 <rs485xModemFlash+0x3aa>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    8d24:	8e 01       	movw	r16, r28
    8d26:	0e 5f       	subi	r16, 0xFE	; 254
    8d28:	1f 4f       	sbci	r17, 0xFF	; 255
    8d2a:	c8 01       	movw	r24, r16
    8d2c:	61 e0       	ldi	r22, 0x01	; 1
    8d2e:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8d32:	81 30       	cpi	r24, 0x01	; 1
    8d34:	71 f4       	brne	.+28     	; 0x8d52 <rs485xModemFlash+0x3aa>
      blad = 11;
    else
    {
      if ((uint8_t)(crc>>8) != nrBloku)
    8d36:	8a 81       	ldd	r24, Y+2	; 0x02
    8d38:	8f 15       	cp	r24, r15
    8d3a:	59 f4       	brne	.+22     	; 0x8d52 <rs485xModemFlash+0x3aa>
  }
   
  //Odbieranie CRC Lo
  if (blad == 0)
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    8d3c:	c8 01       	movw	r24, r16
    8d3e:	61 e0       	ldi	r22, 0x01	; 1
    8d40:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8d44:	a8 2e       	mov	r10, r24
    8d46:	b1 e0       	ldi	r27, 0x01	; 1
    8d48:	8b 17       	cp	r24, r27
    8d4a:	19 f4       	brne	.+6      	; 0x8d52 <rs485xModemFlash+0x3aa>
      blad = 13;
    else
    {
      if ((uint8_t)(crc & 0xFF) != nrBloku)
    8d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    8d4e:	8e 15       	cp	r24, r14
    8d50:	29 f0       	breq	.+10     	; 0x8d5c <rs485xModemFlash+0x3b4>
    }    
  }
   
  if ((blad != 0) && (blad != 253))
  {
    releaseRs485();
    8d52:	0e 94 32 0c 	call	0x1864	; 0x1864 <releaseRs485>
    flushRs485RecBuffer();  
    8d56:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <flushRs485RecBuffer>
    8d5a:	78 c1       	rjmp	.+752    	; 0x904c <rs485xModemFlash+0x6a4>
  }

// Wysyłanie polecenia do bootloadera
  if (blad == 0)
  {
    vTaskDelay(100);
    8d5c:	84 e6       	ldi	r24, 0x64	; 100
    8d5e:	90 e0       	ldi	r25, 0x00	; 0
    8d60:	0e 94 df 50 	call	0xa1be	; 0xa1be <vTaskDelay>
    8d64:	00 e0       	ldi	r16, 0x00	; 0
    8d66:	10 e0       	ldi	r17, 0x00	; 0
    8d68:	8a e5       	ldi	r24, 0x5A	; 90
    8d6a:	18 27       	eor	r17, r24
    8d6c:	01 2e       	mov	r0, r17
    8d6e:	02 94       	swap	r0
    8d70:	80 2d       	mov	r24, r0
    8d72:	8f 70       	andi	r24, 0x0F	; 15
    8d74:	81 27       	eor	r24, r17
    8d76:	91 2f       	mov	r25, r17
    8d78:	90 25       	eor	r25, r0
    8d7a:	99 0f       	add	r25, r25
    8d7c:	90 7e       	andi	r25, 0xE0	; 224
    8d7e:	89 27       	eor	r24, r25
    8d80:	90 2d       	mov	r25, r0
    8d82:	91 27       	eor	r25, r17
    8d84:	90 7f       	andi	r25, 0xF0	; 240
    8d86:	96 95       	lsr	r25
    8d88:	01 2e       	mov	r0, r17
    8d8a:	00 0c       	add	r0, r0
    8d8c:	99 1f       	adc	r25, r25
    8d8e:	16 95       	lsr	r17
    8d90:	16 95       	lsr	r17
    8d92:	16 95       	lsr	r17
    8d94:	1f 71       	andi	r17, 0x1F	; 31
    8d96:	19 27       	eor	r17, r25
    8d98:	10 27       	eor	r17, r16
    8d9a:	08 2f       	mov	r16, r24
     
    crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    8d9c:	8a e5       	ldi	r24, 0x5A	; 90
    8d9e:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8da2:	1b 25       	eor	r17, r11
    8da4:	01 2e       	mov	r0, r17
    8da6:	02 94       	swap	r0
    8da8:	80 2d       	mov	r24, r0
    8daa:	8f 70       	andi	r24, 0x0F	; 15
    8dac:	81 27       	eor	r24, r17
    8dae:	91 2f       	mov	r25, r17
    8db0:	90 25       	eor	r25, r0
    8db2:	99 0f       	add	r25, r25
    8db4:	90 7e       	andi	r25, 0xE0	; 224
    8db6:	89 27       	eor	r24, r25
    8db8:	90 2d       	mov	r25, r0
    8dba:	91 27       	eor	r25, r17
    8dbc:	90 7f       	andi	r25, 0xF0	; 240
    8dbe:	96 95       	lsr	r25
    8dc0:	01 2e       	mov	r0, r17
    8dc2:	00 0c       	add	r0, r0
    8dc4:	99 1f       	adc	r25, r25
    8dc6:	16 95       	lsr	r17
    8dc8:	16 95       	lsr	r17
    8dca:	16 95       	lsr	r17
    8dcc:	1f 71       	andi	r17, 0x1F	; 31
    8dce:	19 27       	eor	r17, r25
    8dd0:	10 27       	eor	r17, r16
    8dd2:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8dd4:	8b 2d       	mov	r24, r11
    8dd6:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8dda:	81 e8       	ldi	r24, 0x81	; 129
    8ddc:	18 27       	eor	r17, r24
    8dde:	01 2e       	mov	r0, r17
    8de0:	02 94       	swap	r0
    8de2:	80 2d       	mov	r24, r0
    8de4:	8f 70       	andi	r24, 0x0F	; 15
    8de6:	81 27       	eor	r24, r17
    8de8:	91 2f       	mov	r25, r17
    8dea:	90 25       	eor	r25, r0
    8dec:	99 0f       	add	r25, r25
    8dee:	90 7e       	andi	r25, 0xE0	; 224
    8df0:	89 27       	eor	r24, r25
    8df2:	90 2d       	mov	r25, r0
    8df4:	91 27       	eor	r25, r17
    8df6:	90 7f       	andi	r25, 0xF0	; 240
    8df8:	96 95       	lsr	r25
    8dfa:	01 2e       	mov	r0, r17
    8dfc:	00 0c       	add	r0, r0
    8dfe:	99 1f       	adc	r25, r25
    8e00:	16 95       	lsr	r17
    8e02:	16 95       	lsr	r17
    8e04:	16 95       	lsr	r17
    8e06:	1f 71       	andi	r17, 0x1F	; 31
    8e08:	19 27       	eor	r17, r25
    8e0a:	10 27       	eor	r17, r16
    8e0c:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    8e0e:	81 e8       	ldi	r24, 0x81	; 129
    8e10:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8e14:	1a 25       	eor	r17, r10
    8e16:	01 2e       	mov	r0, r17
    8e18:	02 94       	swap	r0
    8e1a:	80 2d       	mov	r24, r0
    8e1c:	8f 70       	andi	r24, 0x0F	; 15
    8e1e:	81 27       	eor	r24, r17
    8e20:	91 2f       	mov	r25, r17
    8e22:	90 25       	eor	r25, r0
    8e24:	99 0f       	add	r25, r25
    8e26:	90 7e       	andi	r25, 0xE0	; 224
    8e28:	89 27       	eor	r24, r25
    8e2a:	90 2d       	mov	r25, r0
    8e2c:	91 27       	eor	r25, r17
    8e2e:	90 7f       	andi	r25, 0xF0	; 240
    8e30:	96 95       	lsr	r25
    8e32:	01 2e       	mov	r0, r17
    8e34:	00 0c       	add	r0, r0
    8e36:	99 1f       	adc	r25, r25
    8e38:	16 95       	lsr	r17
    8e3a:	16 95       	lsr	r17
    8e3c:	16 95       	lsr	r17
    8e3e:	1f 71       	andi	r17, 0x1F	; 31
    8e40:	19 27       	eor	r17, r25
    8e42:	10 27       	eor	r17, r16
    8e44:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    8e46:	81 e0       	ldi	r24, 0x01	; 1
    8e48:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8e4c:	1b 25       	eor	r17, r11
    8e4e:	01 2e       	mov	r0, r17
    8e50:	02 94       	swap	r0
    8e52:	80 2d       	mov	r24, r0
    8e54:	8f 70       	andi	r24, 0x0F	; 15
    8e56:	81 27       	eor	r24, r17
    8e58:	91 2f       	mov	r25, r17
    8e5a:	90 25       	eor	r25, r0
    8e5c:	99 0f       	add	r25, r25
    8e5e:	90 7e       	andi	r25, 0xE0	; 224
    8e60:	89 27       	eor	r24, r25
    8e62:	90 2d       	mov	r25, r0
    8e64:	91 27       	eor	r25, r17
    8e66:	90 7f       	andi	r25, 0xF0	; 240
    8e68:	96 95       	lsr	r25
    8e6a:	01 2e       	mov	r0, r17
    8e6c:	00 0c       	add	r0, r0
    8e6e:	99 1f       	adc	r25, r25
    8e70:	16 95       	lsr	r17
    8e72:	16 95       	lsr	r17
    8e74:	16 95       	lsr	r17
    8e76:	1f 71       	andi	r17, 0x1F	; 31
    8e78:	19 27       	eor	r17, r25
    8e7a:	10 27       	eor	r17, r16
    8e7c:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8e7e:	8b 2d       	mov	r24, r11
    8e80:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc>>8));
    8e84:	81 2f       	mov	r24, r17
    8e86:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    8e8a:	80 2f       	mov	r24, r16
    8e8c:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
 
    //Odbieranie odpowiedzi od Bootloadera
    if(rs485Receive(&data, 150) != pdTRUE)
    8e90:	ce 01       	movw	r24, r28
    8e92:	01 96       	adiw	r24, 0x01	; 1
    8e94:	66 e9       	ldi	r22, 0x96	; 150
    8e96:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
      blad = 15;

    if (data != 'C')
    8e9a:	89 81       	ldd	r24, Y+1	; 0x01
    8e9c:	83 34       	cpi	r24, 0x43	; 67
    8e9e:	09 f0       	breq	.+2      	; 0x8ea2 <rs485xModemFlash+0x4fa>
    8ea0:	cd c0       	rjmp	.+410    	; 0x903c <rs485xModemFlash+0x694>
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
    8ea2:	d3 01       	movw	r26, r6
    8ea4:	14 96       	adiw	r26, 0x04	; 4
    8ea6:	ed 91       	ld	r30, X+
    8ea8:	fc 91       	ld	r31, X
    8eaa:	15 97       	sbiw	r26, 0x05	; 5
    8eac:	b2 80       	ldd	r11, Z+2	; 0x02
    8eae:	bb 0c       	add	r11, r11
  if (file->wpis->rozmiarLo == 128)
    8eb0:	81 81       	ldd	r24, Z+1	; 0x01
    8eb2:	80 38       	cpi	r24, 0x80	; 128
    8eb4:	a1 f4       	brne	.+40     	; 0x8ede <rs485xModemFlash+0x536>
    8eb6:	12 c0       	rjmp	.+36     	; 0x8edc <rs485xModemFlash+0x534>
  if (blad != 0)
  {
    releaseRs485();
    flushRs485RecBuffer();  
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    8eb8:	00 d0       	rcall	.+0      	; 0x8eba <rs485xModemFlash+0x512>
    8eba:	00 d0       	rcall	.+0      	; 0x8ebc <rs485xModemFlash+0x514>
    8ebc:	ed b7       	in	r30, 0x3d	; 61
    8ebe:	fe b7       	in	r31, 0x3e	; 62
    8ec0:	d2 82       	std	Z+2, r13	; 0x02
    8ec2:	c1 82       	std	Z+1, r12	; 0x01
    8ec4:	89 ec       	ldi	r24, 0xC9	; 201
    8ec6:	94 e1       	ldi	r25, 0x14	; 20
    8ec8:	94 83       	std	Z+4, r25	; 0x04
    8eca:	83 83       	std	Z+3, r24	; 0x03
    8ecc:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    8ed0:	81 e0       	ldi	r24, 0x01	; 1
    8ed2:	0f 90       	pop	r0
    8ed4:	0f 90       	pop	r0
    8ed6:	0f 90       	pop	r0
    8ed8:	0f 90       	pop	r0
    8eda:	9f c0       	rjmp	.+318    	; 0x901a <rs485xModemFlash+0x672>
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
  if (file->wpis->rozmiarLo == 128)
    liczbaBlokow++;
    8edc:	b3 94       	inc	r11
   
  nrBloku = 1;
    8ede:	81 e0       	ldi	r24, 0x01	; 1
    8ee0:	8a 83       	std	Y+2, r24	; 0x02
    8ee2:	ff 24       	eor	r15, r15
    8ee4:	ee 24       	eor	r14, r14
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    8ee6:	4e 01       	movw	r8, r28
    8ee8:	08 94       	sec
    8eea:	81 1c       	adc	r8, r1
    8eec:	91 1c       	adc	r9, r1
    8eee:	5d c0       	rjmp	.+186    	; 0x8faa <rs485xModemFlash+0x602>
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
  {
    if (debugStr != NULL)
    8ef0:	c1 14       	cp	r12, r1
    8ef2:	d1 04       	cpc	r13, r1
    8ef4:	29 f0       	breq	.+10     	; 0x8f00 <rs485xModemFlash+0x558>
      fputc('#', debugStr);
    8ef6:	83 e2       	ldi	r24, 0x23	; 35
    8ef8:	90 e0       	ldi	r25, 0x00	; 0
    8efa:	b6 01       	movw	r22, r12
    8efc:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    crc = 0;
    uartRs485SendByte(SOH);
    8f00:	81 e0       	ldi	r24, 0x01	; 1
    8f02:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    uartRs485SendByte(nrBloku);
    8f06:	8a 81       	ldd	r24, Y+2	; 0x02
    8f08:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    data = (uint8_t)(~nrBloku);
    8f0c:	8a 81       	ldd	r24, Y+2	; 0x02
    8f0e:	80 95       	com	r24
    8f10:	89 83       	std	Y+1, r24	; 0x01
    uartRs485SendByte(data);
    8f12:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    8f16:	00 e0       	ldi	r16, 0x00	; 0
    8f18:	10 e0       	ldi	r17, 0x00	; 0
    8f1a:	ff 24       	eor	r15, r15
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    8f1c:	c3 01       	movw	r24, r6
    8f1e:	b4 01       	movw	r22, r8
    8f20:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <ramDyskCzytajBajtZPliku>
    8f24:	81 11       	cpse	r24, r1
        data = 0;
    8f26:	19 82       	std	Y+1, r1	; 0x01
      crc = _crc_xmodem_update(crc, data);
    8f28:	89 81       	ldd	r24, Y+1	; 0x01
    8f2a:	18 27       	eor	r17, r24
    8f2c:	01 2e       	mov	r0, r17
    8f2e:	02 94       	swap	r0
    8f30:	90 2d       	mov	r25, r0
    8f32:	9f 70       	andi	r25, 0x0F	; 15
    8f34:	91 27       	eor	r25, r17
    8f36:	21 2f       	mov	r18, r17
    8f38:	20 25       	eor	r18, r0
    8f3a:	22 0f       	add	r18, r18
    8f3c:	20 7e       	andi	r18, 0xE0	; 224
    8f3e:	92 27       	eor	r25, r18
    8f40:	20 2d       	mov	r18, r0
    8f42:	21 27       	eor	r18, r17
    8f44:	20 7f       	andi	r18, 0xF0	; 240
    8f46:	26 95       	lsr	r18
    8f48:	01 2e       	mov	r0, r17
    8f4a:	00 0c       	add	r0, r0
    8f4c:	22 1f       	adc	r18, r18
    8f4e:	16 95       	lsr	r17
    8f50:	16 95       	lsr	r17
    8f52:	16 95       	lsr	r17
    8f54:	1f 71       	andi	r17, 0x1F	; 31
    8f56:	12 27       	eor	r17, r18
    8f58:	10 27       	eor	r17, r16
    8f5a:	09 2f       	mov	r16, r25
      uartRs485SendByte(data);
    8f5c:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    uartRs485SendByte(SOH);
    uartRs485SendByte(nrBloku);
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    8f60:	f3 94       	inc	r15
    8f62:	f0 e8       	ldi	r31, 0x80	; 128
    8f64:	ff 16       	cp	r15, r31
    8f66:	09 f0       	breq	.+2      	; 0x8f6a <rs485xModemFlash+0x5c2>
    8f68:	d9 cf       	rjmp	.-78     	; 0x8f1c <rs485xModemFlash+0x574>
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
        data = 0;
      crc = _crc_xmodem_update(crc, data);
      uartRs485SendByte(data);
    }
    uartRs485SendByte((uint8_t)(crc>>8));
    8f6a:	81 2f       	mov	r24, r17
    8f6c:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    8f70:	80 2f       	mov	r24, r16
    8f72:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
 
    if(rs485Receive(&data, 100) != pdTRUE)
    8f76:	c4 01       	movw	r24, r8
    8f78:	64 e6       	ldi	r22, 0x64	; 100
    8f7a:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8f7e:	81 30       	cpi	r24, 0x01	; 1
    8f80:	11 f0       	breq	.+4      	; 0x8f86 <rs485xModemFlash+0x5de>
    8f82:	3a ef       	ldi	r19, 0xFA	; 250
    8f84:	f3 2e       	mov	r15, r19
    {
      blad = 250;
    }
     
    flushRs485RecBuffer();
    8f86:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <flushRs485RecBuffer>

    if (data == ACK)
    8f8a:	89 81       	ldd	r24, Y+1	; 0x01
    8f8c:	86 30       	cpi	r24, 0x06	; 6
    8f8e:	29 f4       	brne	.+10     	; 0x8f9a <rs485xModemFlash+0x5f2>
    {
      nrBloku ++;
    8f90:	8a 81       	ldd	r24, Y+2	; 0x02
    8f92:	8f 5f       	subi	r24, 0xFF	; 255
    8f94:	8a 83       	std	Y+2, r24	; 0x02
    8f96:	ee 24       	eor	r14, r14
    8f98:	08 c0       	rjmp	.+16     	; 0x8faa <rs485xModemFlash+0x602>
      lRetransmisji = 0;
      continue;
    }
 
    if (data == CAN)
    8f9a:	88 31       	cpi	r24, 0x18	; 24
    8f9c:	11 f4       	brne	.+4      	; 0x8fa2 <rs485xModemFlash+0x5fa>
    8f9e:	29 ef       	ldi	r18, 0xF9	; 249
    8fa0:	f2 2e       	mov	r15, r18
      blad = 249;
 
    lRetransmisji ++;
    8fa2:	e3 94       	inc	r14
     
    if (lRetransmisji == 3)
    8fa4:	23 e0       	ldi	r18, 0x03	; 3
    8fa6:	e2 16       	cp	r14, r18
    8fa8:	e1 f0       	breq	.+56     	; 0x8fe2 <rs485xModemFlash+0x63a>
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    8faa:	8a 81       	ldd	r24, Y+2	; 0x02
    8fac:	b8 16       	cp	r11, r24
    8fae:	08 f0       	brcs	.+2      	; 0x8fb2 <rs485xModemFlash+0x60a>
    8fb0:	9f cf       	rjmp	.-194    	; 0x8ef0 <rs485xModemFlash+0x548>
      blad = 249;
      break;
    }
  }
 
  if (blad == 0)
    8fb2:	ff 20       	and	r15, r15
    8fb4:	b1 f4       	brne	.+44     	; 0x8fe2 <rs485xModemFlash+0x63a>
  {
    uartRs485SendByte(EOT); 
    8fb6:	84 e0       	ldi	r24, 0x04	; 4
    8fb8:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    if(rs485Receive(&data, 25) == pdTRUE)
    8fbc:	8e 01       	movw	r16, r28
    8fbe:	0f 5f       	subi	r16, 0xFF	; 255
    8fc0:	1f 4f       	sbci	r17, 0xFF	; 255
    8fc2:	c8 01       	movw	r24, r16
    8fc4:	69 e1       	ldi	r22, 0x19	; 25
    8fc6:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    8fca:	81 30       	cpi	r24, 0x01	; 1
    8fcc:	51 f4       	brne	.+20     	; 0x8fe2 <rs485xModemFlash+0x63a>
    {
      if (data == ACK)
    8fce:	89 81       	ldd	r24, Y+1	; 0x01
    8fd0:	86 30       	cpi	r24, 0x06	; 6
    8fd2:	39 f4       	brne	.+14     	; 0x8fe2 <rs485xModemFlash+0x63a>
      {
        uartRs485SendByte(EOT);
    8fd4:	84 e0       	ldi	r24, 0x04	; 4
    8fd6:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
        rs485Receive(&data, 25);
    8fda:	c8 01       	movw	r24, r16
    8fdc:	69 e1       	ldi	r22, 0x19	; 25
    8fde:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
      }
    }
  }
  if (debugStr != NULL)
    8fe2:	c1 14       	cp	r12, r1
    8fe4:	d1 04       	cpc	r13, r1
    8fe6:	a1 f0       	breq	.+40     	; 0x9010 <rs485xModemFlash+0x668>
    fprintf_P(debugStr, PSTR("\r\nOK\r\n"));
    8fe8:	00 d0       	rcall	.+0      	; 0x8fea <rs485xModemFlash+0x642>
    8fea:	00 d0       	rcall	.+0      	; 0x8fec <rs485xModemFlash+0x644>
    8fec:	ad b7       	in	r26, 0x3d	; 61
    8fee:	be b7       	in	r27, 0x3e	; 62
    8ff0:	12 96       	adiw	r26, 0x02	; 2
    8ff2:	dc 92       	st	X, r13
    8ff4:	ce 92       	st	-X, r12
    8ff6:	11 97       	sbiw	r26, 0x01	; 1
    8ff8:	82 ec       	ldi	r24, 0xC2	; 194
    8ffa:	94 e1       	ldi	r25, 0x14	; 20
    8ffc:	14 96       	adiw	r26, 0x04	; 4
    8ffe:	9c 93       	st	X, r25
    9000:	8e 93       	st	-X, r24
    9002:	13 97       	sbiw	r26, 0x03	; 3
    9004:	0e 94 13 5d 	call	0xba26	; 0xba26 <fprintf_P>
    9008:	0f 90       	pop	r0
    900a:	0f 90       	pop	r0
    900c:	0f 90       	pop	r0
    900e:	0f 90       	pop	r0

  flushRs485RecBuffer();  
    9010:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <flushRs485RecBuffer>
  releaseRs485();
    9014:	0e 94 32 0c 	call	0x1864	; 0x1864 <releaseRs485>
    9018:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    901a:	0f 90       	pop	r0
    901c:	0f 90       	pop	r0
    901e:	cf 91       	pop	r28
    9020:	df 91       	pop	r29
    9022:	1f 91       	pop	r17
    9024:	0f 91       	pop	r16
    9026:	ff 90       	pop	r15
    9028:	ef 90       	pop	r14
    902a:	df 90       	pop	r13
    902c:	cf 90       	pop	r12
    902e:	bf 90       	pop	r11
    9030:	af 90       	pop	r10
    9032:	9f 90       	pop	r9
    9034:	8f 90       	pop	r8
    9036:	7f 90       	pop	r7
    9038:	6f 90       	pop	r6
    903a:	08 95       	ret
    blad = 0;
  
   
  if (blad != 0)
  {
    releaseRs485();
    903c:	0e 94 32 0c 	call	0x1864	; 0x1864 <releaseRs485>
    flushRs485RecBuffer();  
    9040:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <flushRs485RecBuffer>
    if (debugStr != NULL)
    9044:	c1 14       	cp	r12, r1
    9046:	d1 04       	cpc	r13, r1
    9048:	09 f0       	breq	.+2      	; 0x904c <rs485xModemFlash+0x6a4>
    904a:	36 cf       	rjmp	.-404    	; 0x8eb8 <rs485xModemFlash+0x510>
    904c:	81 e0       	ldi	r24, 0x01	; 1
    904e:	e5 cf       	rjmp	.-54     	; 0x901a <rs485xModemFlash+0x672>

00009050 <rs485ping>:
  return result;
}
#endif /*PRINT_RS485_DEVICE*/

uint8_t rs485ping(uint8_t devAddr)
{
    9050:	bf 92       	push	r11
    9052:	cf 92       	push	r12
    9054:	df 92       	push	r13
    9056:	ef 92       	push	r14
    9058:	ff 92       	push	r15
    905a:	0f 93       	push	r16
    905c:	1f 93       	push	r17
    905e:	df 93       	push	r29
    9060:	cf 93       	push	r28
    9062:	00 d0       	rcall	.+0      	; 0x9064 <rs485ping+0x14>
    9064:	0f 92       	push	r0
    9066:	cd b7       	in	r28, 0x3d	; 61
    9068:	de b7       	in	r29, 0x3e	; 62
    906a:	18 2f       	mov	r17, r24
  takeRs485();
    906c:	0e 94 de 0c 	call	0x19bc	; 0x19bc <takeRs485>
    9070:	ee 24       	eor	r14, r14
    9072:	ff 24       	eor	r15, r15
    9074:	8a e5       	ldi	r24, 0x5A	; 90
    9076:	97 01       	movw	r18, r14
    9078:	38 27       	eor	r19, r24
    907a:	03 2e       	mov	r0, r19
    907c:	02 94       	swap	r0
    907e:	90 2d       	mov	r25, r0
    9080:	9f 70       	andi	r25, 0x0F	; 15
    9082:	93 27       	eor	r25, r19
    9084:	83 2f       	mov	r24, r19
    9086:	80 25       	eor	r24, r0
    9088:	88 0f       	add	r24, r24
    908a:	80 7e       	andi	r24, 0xE0	; 224
    908c:	98 27       	eor	r25, r24
    908e:	80 2d       	mov	r24, r0
    9090:	83 27       	eor	r24, r19
    9092:	80 7f       	andi	r24, 0xF0	; 240
    9094:	86 95       	lsr	r24
    9096:	03 2e       	mov	r0, r19
    9098:	00 0c       	add	r0, r0
    909a:	88 1f       	adc	r24, r24
    909c:	36 95       	lsr	r19
    909e:	36 95       	lsr	r19
    90a0:	36 95       	lsr	r19
    90a2:	3f 71       	andi	r19, 0x1F	; 31
    90a4:	38 27       	eor	r19, r24
    90a6:	32 27       	eor	r19, r18
    90a8:	29 2f       	mov	r18, r25
    90aa:	79 01       	movw	r14, r18

// ********************* Hiden Functions ***************************************************
void sendPing(uint8_t addr, uint8_t pingLen)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
  uartRs485SendByte(SYNC);
    90ac:	8a e5       	ldi	r24, 0x5A	; 90
    90ae:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    90b2:	97 01       	movw	r18, r14
    90b4:	31 27       	eor	r19, r17
    90b6:	03 2e       	mov	r0, r19
    90b8:	02 94       	swap	r0
    90ba:	90 2d       	mov	r25, r0
    90bc:	9f 70       	andi	r25, 0x0F	; 15
    90be:	93 27       	eor	r25, r19
    90c0:	83 2f       	mov	r24, r19
    90c2:	80 25       	eor	r24, r0
    90c4:	88 0f       	add	r24, r24
    90c6:	80 7e       	andi	r24, 0xE0	; 224
    90c8:	98 27       	eor	r25, r24
    90ca:	80 2d       	mov	r24, r0
    90cc:	83 27       	eor	r24, r19
    90ce:	80 7f       	andi	r24, 0xF0	; 240
    90d0:	86 95       	lsr	r24
    90d2:	03 2e       	mov	r0, r19
    90d4:	00 0c       	add	r0, r0
    90d6:	88 1f       	adc	r24, r24
    90d8:	36 95       	lsr	r19
    90da:	36 95       	lsr	r19
    90dc:	36 95       	lsr	r19
    90de:	3f 71       	andi	r19, 0x1F	; 31
    90e0:	38 27       	eor	r19, r24
    90e2:	32 27       	eor	r19, r18
    90e4:	29 2f       	mov	r18, r25
    90e6:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, addr);
  uartRs485SendByte(addr);
    90e8:	81 2f       	mov	r24, r17
    90ea:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    90ee:	80 e8       	ldi	r24, 0x80	; 128
    90f0:	97 01       	movw	r18, r14
    90f2:	38 27       	eor	r19, r24
    90f4:	03 2e       	mov	r0, r19
    90f6:	02 94       	swap	r0
    90f8:	90 2d       	mov	r25, r0
    90fa:	9f 70       	andi	r25, 0x0F	; 15
    90fc:	93 27       	eor	r25, r19
    90fe:	83 2f       	mov	r24, r19
    9100:	80 25       	eor	r24, r0
    9102:	88 0f       	add	r24, r24
    9104:	80 7e       	andi	r24, 0xE0	; 224
    9106:	98 27       	eor	r25, r24
    9108:	80 2d       	mov	r24, r0
    910a:	83 27       	eor	r24, r19
    910c:	80 7f       	andi	r24, 0xF0	; 240
    910e:	86 95       	lsr	r24
    9110:	03 2e       	mov	r0, r19
    9112:	00 0c       	add	r0, r0
    9114:	88 1f       	adc	r24, r24
    9116:	36 95       	lsr	r19
    9118:	36 95       	lsr	r19
    911a:	36 95       	lsr	r19
    911c:	3f 71       	andi	r19, 0x1F	; 31
    911e:	38 27       	eor	r19, r24
    9120:	32 27       	eor	r19, r18
    9122:	29 2f       	mov	r18, r25
    9124:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, rPING);
  uartRs485SendByte(rPING);
    9126:	80 e8       	ldi	r24, 0x80	; 128
    9128:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    912c:	88 e0       	ldi	r24, 0x08	; 8
    912e:	97 01       	movw	r18, r14
    9130:	38 27       	eor	r19, r24
    9132:	03 2e       	mov	r0, r19
    9134:	02 94       	swap	r0
    9136:	90 2d       	mov	r25, r0
    9138:	9f 70       	andi	r25, 0x0F	; 15
    913a:	93 27       	eor	r25, r19
    913c:	83 2f       	mov	r24, r19
    913e:	80 25       	eor	r24, r0
    9140:	88 0f       	add	r24, r24
    9142:	80 7e       	andi	r24, 0xE0	; 224
    9144:	98 27       	eor	r25, r24
    9146:	80 2d       	mov	r24, r0
    9148:	83 27       	eor	r24, r19
    914a:	80 7f       	andi	r24, 0xF0	; 240
    914c:	86 95       	lsr	r24
    914e:	03 2e       	mov	r0, r19
    9150:	00 0c       	add	r0, r0
    9152:	88 1f       	adc	r24, r24
    9154:	36 95       	lsr	r19
    9156:	36 95       	lsr	r19
    9158:	36 95       	lsr	r19
    915a:	3f 71       	andi	r19, 0x1F	; 31
    915c:	38 27       	eor	r19, r24
    915e:	32 27       	eor	r19, r18
    9160:	29 2f       	mov	r18, r25
    9162:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
    9164:	88 e0       	ldi	r24, 0x08	; 8
    9166:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    916a:	bb 24       	eor	r11, r11
    916c:	97 01       	movw	r18, r14
    916e:	3b 25       	eor	r19, r11
    9170:	03 2e       	mov	r0, r19
    9172:	02 94       	swap	r0
    9174:	90 2d       	mov	r25, r0
    9176:	9f 70       	andi	r25, 0x0F	; 15
    9178:	93 27       	eor	r25, r19
    917a:	83 2f       	mov	r24, r19
    917c:	80 25       	eor	r24, r0
    917e:	88 0f       	add	r24, r24
    9180:	80 7e       	andi	r24, 0xE0	; 224
    9182:	98 27       	eor	r25, r24
    9184:	80 2d       	mov	r24, r0
    9186:	83 27       	eor	r24, r19
    9188:	80 7f       	andi	r24, 0xF0	; 240
    918a:	86 95       	lsr	r24
    918c:	03 2e       	mov	r0, r19
    918e:	00 0c       	add	r0, r0
    9190:	88 1f       	adc	r24, r24
    9192:	36 95       	lsr	r19
    9194:	36 95       	lsr	r19
    9196:	36 95       	lsr	r19
    9198:	3f 71       	andi	r19, 0x1F	; 31
    919a:	38 27       	eor	r19, r24
    919c:	32 27       	eor	r19, r18
    919e:	29 2f       	mov	r18, r25
    91a0:	79 01       	movw	r14, r18
  
  for (uint8_t i=0; i < pingLen; i++)
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
    91a2:	8b 2d       	mov	r24, r11
    91a4:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  uartRs485SendByte(rPING);

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
  
  for (uint8_t i=0; i < pingLen; i++)
    91a8:	b3 94       	inc	r11
    91aa:	38 e0       	ldi	r19, 0x08	; 8
    91ac:	b3 16       	cp	r11, r19
    91ae:	f1 f6       	brne	.-68     	; 0x916c <rs485ping+0x11c>
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
  }
  uartRs485SendByte((uint8_t)(crc >> 8));
    91b0:	8f 2d       	mov	r24, r15
    91b2:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    91b6:	8e 2d       	mov	r24, r14
    91b8:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  addr = 0;
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    91bc:	6e 01       	movw	r12, r28
    91be:	08 94       	sec
    91c0:	c1 1c       	adc	r12, r1
    91c2:	d1 1c       	adc	r13, r1
    91c4:	c6 01       	movw	r24, r12
    91c6:	64 e1       	ldi	r22, 0x14	; 20
    91c8:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    91cc:	88 23       	and	r24, r24
    91ce:	11 f4       	brne	.+4      	; 0x91d4 <rs485ping+0x184>
    91d0:	11 e0       	ldi	r17, 0x01	; 1
    91d2:	ee c0       	rjmp	.+476    	; 0x93b0 <rs485ping+0x360>
    return 1;
  
  if (data != SYNC)
    91d4:	89 81       	ldd	r24, Y+1	; 0x01
    91d6:	8a 35       	cpi	r24, 0x5A	; 90
    91d8:	11 f0       	breq	.+4      	; 0x91de <rs485ping+0x18e>
    91da:	12 e0       	ldi	r17, 0x02	; 2
    91dc:	e9 c0       	rjmp	.+466    	; 0x93b0 <rs485ping+0x360>
    91de:	00 e0       	ldi	r16, 0x00	; 0
    91e0:	10 e0       	ldi	r17, 0x00	; 0
    91e2:	18 27       	eor	r17, r24
    91e4:	01 2e       	mov	r0, r17
    91e6:	02 94       	swap	r0
    91e8:	90 2d       	mov	r25, r0
    91ea:	9f 70       	andi	r25, 0x0F	; 15
    91ec:	91 27       	eor	r25, r17
    91ee:	81 2f       	mov	r24, r17
    91f0:	80 25       	eor	r24, r0
    91f2:	88 0f       	add	r24, r24
    91f4:	80 7e       	andi	r24, 0xE0	; 224
    91f6:	98 27       	eor	r25, r24
    91f8:	80 2d       	mov	r24, r0
    91fa:	81 27       	eor	r24, r17
    91fc:	80 7f       	andi	r24, 0xF0	; 240
    91fe:	86 95       	lsr	r24
    9200:	01 2e       	mov	r0, r17
    9202:	00 0c       	add	r0, r0
    9204:	88 1f       	adc	r24, r24
    9206:	16 95       	lsr	r17
    9208:	16 95       	lsr	r17
    920a:	16 95       	lsr	r17
    920c:	1f 71       	andi	r17, 0x1F	; 31
    920e:	18 27       	eor	r17, r24
    9210:	10 27       	eor	r17, r16
    9212:	09 2f       	mov	r16, r25
    return 2;
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    9214:	c6 01       	movw	r24, r12
    9216:	61 e0       	ldi	r22, 0x01	; 1
    9218:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    921c:	88 23       	and	r24, r24
    921e:	11 f4       	brne	.+4      	; 0x9224 <rs485ping+0x1d4>
    9220:	13 e0       	ldi	r17, 0x03	; 3
    9222:	c6 c0       	rjmp	.+396    	; 0x93b0 <rs485ping+0x360>
    return 3;

  if (data != 0)
    9224:	89 81       	ldd	r24, Y+1	; 0x01
    9226:	88 23       	and	r24, r24
    9228:	11 f0       	breq	.+4      	; 0x922e <rs485ping+0x1de>
    922a:	14 e0       	ldi	r17, 0x04	; 4
    922c:	c1 c0       	rjmp	.+386    	; 0x93b0 <rs485ping+0x360>
    922e:	18 27       	eor	r17, r24
    9230:	01 2e       	mov	r0, r17
    9232:	02 94       	swap	r0
    9234:	90 2d       	mov	r25, r0
    9236:	9f 70       	andi	r25, 0x0F	; 15
    9238:	91 27       	eor	r25, r17
    923a:	81 2f       	mov	r24, r17
    923c:	80 25       	eor	r24, r0
    923e:	88 0f       	add	r24, r24
    9240:	80 7e       	andi	r24, 0xE0	; 224
    9242:	98 27       	eor	r25, r24
    9244:	80 2d       	mov	r24, r0
    9246:	81 27       	eor	r24, r17
    9248:	80 7f       	andi	r24, 0xF0	; 240
    924a:	86 95       	lsr	r24
    924c:	01 2e       	mov	r0, r17
    924e:	00 0c       	add	r0, r0
    9250:	88 1f       	adc	r24, r24
    9252:	16 95       	lsr	r17
    9254:	16 95       	lsr	r17
    9256:	16 95       	lsr	r17
    9258:	1f 71       	andi	r17, 0x1F	; 31
    925a:	18 27       	eor	r17, r24
    925c:	10 27       	eor	r17, r16
    925e:	09 2f       	mov	r16, r25
    return 4;
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    9260:	c6 01       	movw	r24, r12
    9262:	61 e0       	ldi	r22, 0x01	; 1
    9264:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    9268:	88 23       	and	r24, r24
    926a:	11 f4       	brne	.+4      	; 0x9270 <rs485ping+0x220>
    926c:	15 e0       	ldi	r17, 0x05	; 5
    926e:	a0 c0       	rjmp	.+320    	; 0x93b0 <rs485ping+0x360>
    return 5;
  if (data != rPING)
    9270:	89 81       	ldd	r24, Y+1	; 0x01
    9272:	80 38       	cpi	r24, 0x80	; 128
    9274:	11 f0       	breq	.+4      	; 0x927a <rs485ping+0x22a>
    9276:	16 e0       	ldi	r17, 0x06	; 6
    9278:	9b c0       	rjmp	.+310    	; 0x93b0 <rs485ping+0x360>
    927a:	18 27       	eor	r17, r24
    927c:	01 2e       	mov	r0, r17
    927e:	02 94       	swap	r0
    9280:	90 2d       	mov	r25, r0
    9282:	9f 70       	andi	r25, 0x0F	; 15
    9284:	91 27       	eor	r25, r17
    9286:	81 2f       	mov	r24, r17
    9288:	80 25       	eor	r24, r0
    928a:	88 0f       	add	r24, r24
    928c:	80 7e       	andi	r24, 0xE0	; 224
    928e:	98 27       	eor	r25, r24
    9290:	80 2d       	mov	r24, r0
    9292:	81 27       	eor	r24, r17
    9294:	80 7f       	andi	r24, 0xF0	; 240
    9296:	86 95       	lsr	r24
    9298:	01 2e       	mov	r0, r17
    929a:	00 0c       	add	r0, r0
    929c:	88 1f       	adc	r24, r24
    929e:	16 95       	lsr	r17
    92a0:	16 95       	lsr	r17
    92a2:	16 95       	lsr	r17
    92a4:	1f 71       	andi	r17, 0x1F	; 31
    92a6:	18 27       	eor	r17, r24
    92a8:	10 27       	eor	r17, r16
    92aa:	09 2f       	mov	r16, r25
    return 6;
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    92ac:	c6 01       	movw	r24, r12
    92ae:	61 e0       	ldi	r22, 0x01	; 1
    92b0:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    92b4:	88 23       	and	r24, r24
    92b6:	11 f4       	brne	.+4      	; 0x92bc <rs485ping+0x26c>
    92b8:	17 e0       	ldi	r17, 0x07	; 7
    92ba:	7a c0       	rjmp	.+244    	; 0x93b0 <rs485ping+0x360>
    return 7;
  if (data != dataLen)
    92bc:	89 81       	ldd	r24, Y+1	; 0x01
    92be:	88 30       	cpi	r24, 0x08	; 8
    92c0:	11 f0       	breq	.+4      	; 0x92c6 <rs485ping+0x276>
    92c2:	18 e0       	ldi	r17, 0x08	; 8
    92c4:	75 c0       	rjmp	.+234    	; 0x93b0 <rs485ping+0x360>
    92c6:	1b 25       	eor	r17, r11
    92c8:	01 2e       	mov	r0, r17
    92ca:	02 94       	swap	r0
    92cc:	90 2d       	mov	r25, r0
    92ce:	9f 70       	andi	r25, 0x0F	; 15
    92d0:	91 27       	eor	r25, r17
    92d2:	81 2f       	mov	r24, r17
    92d4:	80 25       	eor	r24, r0
    92d6:	88 0f       	add	r24, r24
    92d8:	80 7e       	andi	r24, 0xE0	; 224
    92da:	98 27       	eor	r25, r24
    92dc:	80 2d       	mov	r24, r0
    92de:	81 27       	eor	r24, r17
    92e0:	80 7f       	andi	r24, 0xF0	; 240
    92e2:	86 95       	lsr	r24
    92e4:	01 2e       	mov	r0, r17
    92e6:	00 0c       	add	r0, r0
    92e8:	88 1f       	adc	r24, r24
    92ea:	16 95       	lsr	r17
    92ec:	16 95       	lsr	r17
    92ee:	16 95       	lsr	r17
    92f0:	1f 71       	andi	r17, 0x1F	; 31
    92f2:	18 27       	eor	r17, r24
    92f4:	10 27       	eor	r17, r16
    92f6:	09 2f       	mov	r16, r25
    92f8:	ff 24       	eor	r15, r15

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
  {
    if(rs485Receive(&data, 5) == pdFALSE)
    92fa:	c6 01       	movw	r24, r12
    92fc:	dc 2c       	mov	r13, r12
    92fe:	e9 2e       	mov	r14, r25
    9300:	8d 2d       	mov	r24, r13
    9302:	9e 2d       	mov	r25, r14
    9304:	65 e0       	ldi	r22, 0x05	; 5
    9306:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    930a:	88 23       	and	r24, r24
    930c:	21 f4       	brne	.+8      	; 0x9316 <rs485ping+0x2c6>
      return 2*temp+9;
    930e:	1f 2d       	mov	r17, r15
    9310:	11 0f       	add	r17, r17
    9312:	17 5f       	subi	r17, 0xF7	; 247
    9314:	4d c0       	rjmp	.+154    	; 0x93b0 <rs485ping+0x360>
    crc = _crc_xmodem_update(crc, data);
    9316:	89 81       	ldd	r24, Y+1	; 0x01
    9318:	18 27       	eor	r17, r24
    931a:	01 2e       	mov	r0, r17
    931c:	02 94       	swap	r0
    931e:	20 2d       	mov	r18, r0
    9320:	2f 70       	andi	r18, 0x0F	; 15
    9322:	21 27       	eor	r18, r17
    9324:	91 2f       	mov	r25, r17
    9326:	90 25       	eor	r25, r0
    9328:	99 0f       	add	r25, r25
    932a:	90 7e       	andi	r25, 0xE0	; 224
    932c:	29 27       	eor	r18, r25
    932e:	90 2d       	mov	r25, r0
    9330:	91 27       	eor	r25, r17
    9332:	90 7f       	andi	r25, 0xF0	; 240
    9334:	96 95       	lsr	r25
    9336:	01 2e       	mov	r0, r17
    9338:	00 0c       	add	r0, r0
    933a:	99 1f       	adc	r25, r25
    933c:	16 95       	lsr	r17
    933e:	16 95       	lsr	r17
    9340:	16 95       	lsr	r17
    9342:	1f 71       	andi	r17, 0x1F	; 31
    9344:	19 27       	eor	r17, r25
    9346:	10 27       	eor	r17, r16
    9348:	02 2f       	mov	r16, r18
    if (data != temp)
    934a:	8f 15       	cp	r24, r15
    934c:	21 f0       	breq	.+8      	; 0x9356 <rs485ping+0x306>
      return 2*temp+10; 
    934e:	1f 2d       	mov	r17, r15
    9350:	11 0f       	add	r17, r17
    9352:	16 5f       	subi	r17, 0xF6	; 246
    9354:	2d c0       	rjmp	.+90     	; 0x93b0 <rs485ping+0x360>
    return 8;
  crc = _crc_xmodem_update(crc, data);

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    9356:	f3 94       	inc	r15
    9358:	87 e0       	ldi	r24, 0x07	; 7
    935a:	8f 15       	cp	r24, r15
    935c:	08 f0       	brcs	.+2      	; 0x9360 <rs485ping+0x310>
    935e:	d0 cf       	rjmp	.-96     	; 0x9300 <rs485ping+0x2b0>
      return 2*temp+10; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    9360:	ce 01       	movw	r24, r28
    9362:	02 96       	adiw	r24, 0x02	; 2
    9364:	61 e0       	ldi	r22, 0x01	; 1
    9366:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    936a:	81 30       	cpi	r24, 0x01	; 1
    936c:	21 f0       	breq	.+8      	; 0x9376 <rs485ping+0x326>
    return 2*temp+11;
    936e:	1f 2d       	mov	r17, r15
    9370:	11 0f       	add	r17, r17
    9372:	15 5f       	subi	r17, 0xF5	; 245
    9374:	1d c0       	rjmp	.+58     	; 0x93b0 <rs485ping+0x360>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    9376:	80 91 9c 0e 	lds	r24, 0x0E9C
    937a:	90 91 9d 0e 	lds	r25, 0x0E9D
    937e:	be 01       	movw	r22, r28
    9380:	6d 5f       	subi	r22, 0xFD	; 253
    9382:	7f 4f       	sbci	r23, 0xFF	; 255
    9384:	41 e0       	ldi	r20, 0x01	; 1
    9386:	50 e0       	ldi	r21, 0x00	; 0
    9388:	20 e0       	ldi	r18, 0x00	; 0
    938a:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    938e:	81 30       	cpi	r24, 0x01	; 1
    9390:	21 f0       	breq	.+8      	; 0x939a <rs485ping+0x34a>
    return 2*temp+12;
    9392:	1f 2d       	mov	r17, r15
    9394:	11 0f       	add	r17, r17
    9396:	14 5f       	subi	r17, 0xF4	; 244
    9398:	0b c0       	rjmp	.+22     	; 0x93b0 <rs485ping+0x360>

  if (crcHi != (uint8_t)(crc>>8))
    939a:	8a 81       	ldd	r24, Y+2	; 0x02
    939c:	81 17       	cp	r24, r17
    939e:	11 f0       	breq	.+4      	; 0x93a4 <rs485ping+0x354>
    93a0:	1e ef       	ldi	r17, 0xFE	; 254
    93a2:	06 c0       	rjmp	.+12     	; 0x93b0 <rs485ping+0x360>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    93a4:	8b 81       	ldd	r24, Y+3	; 0x03
    93a6:	80 17       	cp	r24, r16
    93a8:	11 f4       	brne	.+4      	; 0x93ae <rs485ping+0x35e>
    93aa:	10 e0       	ldi	r17, 0x00	; 0
    93ac:	01 c0       	rjmp	.+2      	; 0x93b0 <rs485ping+0x360>
    93ae:	1f ef       	ldi	r17, 0xFF	; 255
{
  takeRs485();
  const int len = 8;    
  sendPing(devAddr, len);
  uint8_t result = receivePong(devAddr, len);
  flushRs485RecBuffer();
    93b0:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <flushRs485RecBuffer>

  releaseRs485();
    93b4:	0e 94 32 0c 	call	0x1864	; 0x1864 <releaseRs485>
  return result;
}
    93b8:	81 2f       	mov	r24, r17
    93ba:	0f 90       	pop	r0
    93bc:	0f 90       	pop	r0
    93be:	0f 90       	pop	r0
    93c0:	cf 91       	pop	r28
    93c2:	df 91       	pop	r29
    93c4:	1f 91       	pop	r17
    93c6:	0f 91       	pop	r16
    93c8:	ff 90       	pop	r15
    93ca:	ef 90       	pop	r14
    93cc:	df 90       	pop	r13
    93ce:	cf 90       	pop	r12
    93d0:	bf 90       	pop	r11
    93d2:	08 95       	ret

000093d4 <rs485rollerHello>:

uint8_t rs485rollerHello(uint8_t devAddr)
{
    93d4:	af 92       	push	r10
    93d6:	bf 92       	push	r11
    93d8:	cf 92       	push	r12
    93da:	df 92       	push	r13
    93dc:	ef 92       	push	r14
    93de:	ff 92       	push	r15
    93e0:	0f 93       	push	r16
    93e2:	1f 93       	push	r17
    93e4:	df 93       	push	r29
    93e6:	cf 93       	push	r28
    93e8:	00 d0       	rcall	.+0      	; 0x93ea <rs485rollerHello+0x16>
    93ea:	0f 92       	push	r0
    93ec:	cd b7       	in	r28, 0x3d	; 61
    93ee:	de b7       	in	r29, 0x3e	; 62
    93f0:	d8 2e       	mov	r13, r24
    93f2:	e0 91 a8 0e 	lds	r30, 0x0EA8
    93f6:	f0 91 a9 0e 	lds	r31, 0x0EA9
    93fa:	ee 24       	eor	r14, r14
    93fc:	ff 24       	eor	r15, r15
    93fe:	40 e0       	ldi	r20, 0x00	; 0
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    9400:	81 81       	ldd	r24, Z+1	; 0x01
    9402:	8d 15       	cp	r24, r13
    9404:	09 f4       	brne	.+2      	; 0x9408 <rs485rollerHello+0x34>
    9406:	7f 01       	movw	r14, r30

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    9408:	4f 5f       	subi	r20, 0xFF	; 255
    940a:	3a 96       	adiw	r30, 0x0a	; 10
    940c:	4a 30       	cpi	r20, 0x0A	; 10
    940e:	c1 f7       	brne	.-16     	; 0x9400 <rs485rollerHello+0x2c>
    if (rollers[i].address == devAddr)
      tmp = &rollers[i];
    
  if (rs485ping(devAddr)==0)
    9410:	8d 2d       	mov	r24, r13
    9412:	0e 94 28 48 	call	0x9050	; 0x9050 <rs485ping>
    9416:	88 23       	and	r24, r24
    9418:	e9 f4       	brne	.+58     	; 0x9454 <rs485rollerHello+0x80>
  {
    if (tmp == NULL)
    941a:	e1 14       	cp	r14, r1
    941c:	f1 04       	cpc	r15, r1
    941e:	81 f4       	brne	.+32     	; 0x9440 <rs485rollerHello+0x6c>
    9420:	e0 91 a8 0e 	lds	r30, 0x0EA8
    9424:	f0 91 a9 0e 	lds	r31, 0x0EA9
    9428:	90 e0       	ldi	r25, 0x00	; 0
    942a:	7f 01       	movw	r14, r30
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
      {
        if (rollers[i].address == 0)
    942c:	81 81       	ldd	r24, Z+1	; 0x01
    942e:	88 23       	and	r24, r24
    9430:	11 f4       	brne	.+4      	; 0x9436 <rs485rollerHello+0x62>
        {
          tmp = &rollers[i];
          tmp->address = devAddr;
    9432:	d1 82       	std	Z+1, r13	; 0x01
    9434:	05 c0       	rjmp	.+10     	; 0x9440 <rs485rollerHello+0x6c>
    
  if (rs485ping(devAddr)==0)
  {
    if (tmp == NULL)
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    9436:	9f 5f       	subi	r25, 0xFF	; 255
    9438:	3a 96       	adiw	r30, 0x0a	; 10
    943a:	9a 30       	cpi	r25, 0x0A	; 10
    943c:	b1 f7       	brne	.-20     	; 0x942a <rs485rollerHello+0x56>
    943e:	90 c1       	rjmp	.+800    	; 0x9760 <rs485rollerHello+0x38c>
          tmp->address = devAddr;
          break;
        }
      }
    }
    if (tmp != NULL)
    9440:	e1 14       	cp	r14, r1
    9442:	f1 04       	cpc	r15, r1
    9444:	09 f4       	brne	.+2      	; 0x9448 <rs485rollerHello+0x74>
    9446:	8c c1       	rjmp	.+792    	; 0x9760 <rs485rollerHello+0x38c>
    {
      tmp->state &= (~NOT_DETECTED);
    9448:	f7 01       	movw	r30, r14
    944a:	80 81       	ld	r24, Z
    944c:	8e 7f       	andi	r24, 0xFE	; 254
    944e:	80 83       	st	Z, r24
      tmp->address = devAddr;
    9450:	d1 82       	std	Z+1, r13	; 0x01
    9452:	0d c0       	rjmp	.+26     	; 0x946e <rs485rollerHello+0x9a>
    else
      return 1;
  }
  else
  {
    if (tmp != NULL)
    9454:	e1 14       	cp	r14, r1
    9456:	f1 04       	cpc	r15, r1
    9458:	51 f0       	breq	.+20     	; 0x946e <rs485rollerHello+0x9a>
    {
      if (tmp->state & NOT_DETECTED)
    945a:	f7 01       	movw	r30, r14
    945c:	80 81       	ld	r24, Z
    945e:	80 fd       	sbrc	r24, 0
      {
        tmp->address = 0;
    9460:	11 82       	std	Z+1, r1	; 0x01
      }
      tmp->state |= NOT_DETECTED;
    9462:	f7 01       	movw	r30, r14
    9464:	80 81       	ld	r24, Z
    9466:	81 60       	ori	r24, 0x01	; 1
    9468:	80 83       	st	Z, r24
    946a:	02 e0       	ldi	r16, 0x02	; 2
    946c:	7a c1       	rjmp	.+756    	; 0x9762 <rs485rollerHello+0x38e>
      return 2;
    }
  }
  
  takeRs485();
    946e:	0e 94 de 0c 	call	0x19bc	; 0x19bc <takeRs485>
    9472:	aa 24       	eor	r10, r10
    9474:	bb 24       	eor	r11, r11
    9476:	85 01       	movw	r16, r10
    9478:	8a e5       	ldi	r24, 0x5A	; 90
    947a:	18 27       	eor	r17, r24
    947c:	01 2e       	mov	r0, r17
    947e:	02 94       	swap	r0
    9480:	90 2d       	mov	r25, r0
    9482:	9f 70       	andi	r25, 0x0F	; 15
    9484:	91 27       	eor	r25, r17
    9486:	81 2f       	mov	r24, r17
    9488:	80 25       	eor	r24, r0
    948a:	88 0f       	add	r24, r24
    948c:	80 7e       	andi	r24, 0xE0	; 224
    948e:	98 27       	eor	r25, r24
    9490:	80 2d       	mov	r24, r0
    9492:	81 27       	eor	r24, r17
    9494:	80 7f       	andi	r24, 0xF0	; 240
    9496:	86 95       	lsr	r24
    9498:	01 2e       	mov	r0, r17
    949a:	00 0c       	add	r0, r0
    949c:	88 1f       	adc	r24, r24
    949e:	16 95       	lsr	r17
    94a0:	16 95       	lsr	r17
    94a2:	16 95       	lsr	r17
    94a4:	1f 71       	andi	r17, 0x1F	; 31
    94a6:	18 27       	eor	r17, r24
    94a8:	10 27       	eor	r17, r16
    94aa:	09 2f       	mov	r16, r25
}

static void    sendHello(uint8_t addr)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
  uartRs485SendByte(SYNC);
    94ac:	8a e5       	ldi	r24, 0x5A	; 90
    94ae:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    94b2:	1d 25       	eor	r17, r13
    94b4:	01 2e       	mov	r0, r17
    94b6:	02 94       	swap	r0
    94b8:	90 2d       	mov	r25, r0
    94ba:	9f 70       	andi	r25, 0x0F	; 15
    94bc:	91 27       	eor	r25, r17
    94be:	81 2f       	mov	r24, r17
    94c0:	80 25       	eor	r24, r0
    94c2:	88 0f       	add	r24, r24
    94c4:	80 7e       	andi	r24, 0xE0	; 224
    94c6:	98 27       	eor	r25, r24
    94c8:	80 2d       	mov	r24, r0
    94ca:	81 27       	eor	r24, r17
    94cc:	80 7f       	andi	r24, 0xF0	; 240
    94ce:	86 95       	lsr	r24
    94d0:	01 2e       	mov	r0, r17
    94d2:	00 0c       	add	r0, r0
    94d4:	88 1f       	adc	r24, r24
    94d6:	16 95       	lsr	r17
    94d8:	16 95       	lsr	r17
    94da:	16 95       	lsr	r17
    94dc:	1f 71       	andi	r17, 0x1F	; 31
    94de:	18 27       	eor	r17, r24
    94e0:	10 27       	eor	r17, r16
    94e2:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, addr);
  uartRs485SendByte(addr);
    94e4:	8d 2d       	mov	r24, r13
    94e6:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    94ea:	82 e8       	ldi	r24, 0x82	; 130
    94ec:	18 27       	eor	r17, r24
    94ee:	01 2e       	mov	r0, r17
    94f0:	02 94       	swap	r0
    94f2:	90 2d       	mov	r25, r0
    94f4:	9f 70       	andi	r25, 0x0F	; 15
    94f6:	91 27       	eor	r25, r17
    94f8:	81 2f       	mov	r24, r17
    94fa:	80 25       	eor	r24, r0
    94fc:	88 0f       	add	r24, r24
    94fe:	80 7e       	andi	r24, 0xE0	; 224
    9500:	98 27       	eor	r25, r24
    9502:	80 2d       	mov	r24, r0
    9504:	81 27       	eor	r24, r17
    9506:	80 7f       	andi	r24, 0xF0	; 240
    9508:	86 95       	lsr	r24
    950a:	01 2e       	mov	r0, r17
    950c:	00 0c       	add	r0, r0
    950e:	88 1f       	adc	r24, r24
    9510:	16 95       	lsr	r17
    9512:	16 95       	lsr	r17
    9514:	16 95       	lsr	r17
    9516:	1f 71       	andi	r17, 0x1F	; 31
    9518:	18 27       	eor	r17, r24
    951a:	10 27       	eor	r17, r16
    951c:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, rHELLO);
  uartRs485SendByte(rHELLO);
    951e:	82 e8       	ldi	r24, 0x82	; 130
    9520:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
    9524:	80 e0       	ldi	r24, 0x00	; 0
    9526:	18 27       	eor	r17, r24
    9528:	01 2e       	mov	r0, r17
    952a:	02 94       	swap	r0
    952c:	90 2d       	mov	r25, r0
    952e:	9f 70       	andi	r25, 0x0F	; 15
    9530:	91 27       	eor	r25, r17
    9532:	81 2f       	mov	r24, r17
    9534:	80 25       	eor	r24, r0
    9536:	88 0f       	add	r24, r24
    9538:	80 7e       	andi	r24, 0xE0	; 224
    953a:	98 27       	eor	r25, r24
    953c:	80 2d       	mov	r24, r0
    953e:	81 27       	eor	r24, r17
    9540:	80 7f       	andi	r24, 0xF0	; 240
    9542:	86 95       	lsr	r24
    9544:	01 2e       	mov	r0, r17
    9546:	00 0c       	add	r0, r0
    9548:	88 1f       	adc	r24, r24
    954a:	16 95       	lsr	r17
    954c:	16 95       	lsr	r17
    954e:	16 95       	lsr	r17
    9550:	1f 71       	andi	r17, 0x1F	; 31
    9552:	18 27       	eor	r17, r24
    9554:	10 27       	eor	r17, r16
    9556:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, 0);
  uartRs485SendByte(0);
    9558:	80 e0       	ldi	r24, 0x00	; 0
    955a:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc >> 8));
    955e:	81 2f       	mov	r24, r17
    9560:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    9564:	80 2f       	mov	r24, r16
    9566:	0e 94 3e 0c 	call	0x187c	; 0x187c <uartRs485SendByte>
static uint8_t receiveHello(uint8_t* response, uint8_t maxSize)
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    956a:	6e 01       	movw	r12, r28
    956c:	08 94       	sec
    956e:	c1 1c       	adc	r12, r1
    9570:	d1 1c       	adc	r13, r1
    9572:	c6 01       	movw	r24, r12
    9574:	64 e1       	ldi	r22, 0x14	; 20
    9576:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    957a:	88 23       	and	r24, r24
    957c:	11 f4       	brne	.+4      	; 0x9582 <rs485rollerHello+0x1ae>
    957e:	08 e0       	ldi	r16, 0x08	; 8
    9580:	ec c0       	rjmp	.+472    	; 0x975a <rs485rollerHello+0x386>
    return 8;
  
  if (data != SYNC)
    9582:	89 81       	ldd	r24, Y+1	; 0x01
    9584:	8a 35       	cpi	r24, 0x5A	; 90
    9586:	11 f0       	breq	.+4      	; 0x958c <rs485rollerHello+0x1b8>
    9588:	02 e0       	ldi	r16, 0x02	; 2
    958a:	e7 c0       	rjmp	.+462    	; 0x975a <rs485rollerHello+0x386>
    958c:	85 01       	movw	r16, r10
    958e:	18 27       	eor	r17, r24
    9590:	01 2e       	mov	r0, r17
    9592:	02 94       	swap	r0
    9594:	90 2d       	mov	r25, r0
    9596:	9f 70       	andi	r25, 0x0F	; 15
    9598:	91 27       	eor	r25, r17
    959a:	81 2f       	mov	r24, r17
    959c:	80 25       	eor	r24, r0
    959e:	88 0f       	add	r24, r24
    95a0:	80 7e       	andi	r24, 0xE0	; 224
    95a2:	98 27       	eor	r25, r24
    95a4:	80 2d       	mov	r24, r0
    95a6:	81 27       	eor	r24, r17
    95a8:	80 7f       	andi	r24, 0xF0	; 240
    95aa:	86 95       	lsr	r24
    95ac:	01 2e       	mov	r0, r17
    95ae:	00 0c       	add	r0, r0
    95b0:	88 1f       	adc	r24, r24
    95b2:	16 95       	lsr	r17
    95b4:	16 95       	lsr	r17
    95b6:	16 95       	lsr	r17
    95b8:	1f 71       	andi	r17, 0x1F	; 31
    95ba:	18 27       	eor	r17, r24
    95bc:	10 27       	eor	r17, r16
    95be:	09 2f       	mov	r16, r25
    return 2;
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    95c0:	c6 01       	movw	r24, r12
    95c2:	61 e0       	ldi	r22, 0x01	; 1
    95c4:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    95c8:	88 23       	and	r24, r24
    95ca:	11 f4       	brne	.+4      	; 0x95d0 <rs485rollerHello+0x1fc>
    95cc:	03 e0       	ldi	r16, 0x03	; 3
    95ce:	c5 c0       	rjmp	.+394    	; 0x975a <rs485rollerHello+0x386>
    return 3;

  if (data != 0)
    95d0:	89 81       	ldd	r24, Y+1	; 0x01
    95d2:	88 23       	and	r24, r24
    95d4:	11 f0       	breq	.+4      	; 0x95da <rs485rollerHello+0x206>
    95d6:	04 e0       	ldi	r16, 0x04	; 4
    95d8:	c0 c0       	rjmp	.+384    	; 0x975a <rs485rollerHello+0x386>
    95da:	18 27       	eor	r17, r24
    95dc:	01 2e       	mov	r0, r17
    95de:	02 94       	swap	r0
    95e0:	90 2d       	mov	r25, r0
    95e2:	9f 70       	andi	r25, 0x0F	; 15
    95e4:	91 27       	eor	r25, r17
    95e6:	81 2f       	mov	r24, r17
    95e8:	80 25       	eor	r24, r0
    95ea:	88 0f       	add	r24, r24
    95ec:	80 7e       	andi	r24, 0xE0	; 224
    95ee:	98 27       	eor	r25, r24
    95f0:	80 2d       	mov	r24, r0
    95f2:	81 27       	eor	r24, r17
    95f4:	80 7f       	andi	r24, 0xF0	; 240
    95f6:	86 95       	lsr	r24
    95f8:	01 2e       	mov	r0, r17
    95fa:	00 0c       	add	r0, r0
    95fc:	88 1f       	adc	r24, r24
    95fe:	16 95       	lsr	r17
    9600:	16 95       	lsr	r17
    9602:	16 95       	lsr	r17
    9604:	1f 71       	andi	r17, 0x1F	; 31
    9606:	18 27       	eor	r17, r24
    9608:	10 27       	eor	r17, r16
    960a:	09 2f       	mov	r16, r25
    return 4;
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    960c:	c6 01       	movw	r24, r12
    960e:	61 e0       	ldi	r22, 0x01	; 1
    9610:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    9614:	88 23       	and	r24, r24
    9616:	11 f4       	brne	.+4      	; 0x961c <rs485rollerHello+0x248>
    9618:	05 e0       	ldi	r16, 0x05	; 5
    961a:	9f c0       	rjmp	.+318    	; 0x975a <rs485rollerHello+0x386>
    return 5;
  if (data != rHELLO)
    961c:	89 81       	ldd	r24, Y+1	; 0x01
    961e:	82 38       	cpi	r24, 0x82	; 130
    9620:	11 f0       	breq	.+4      	; 0x9626 <rs485rollerHello+0x252>
    9622:	06 e0       	ldi	r16, 0x06	; 6
    9624:	9a c0       	rjmp	.+308    	; 0x975a <rs485rollerHello+0x386>
    9626:	18 27       	eor	r17, r24
    9628:	01 2e       	mov	r0, r17
    962a:	02 94       	swap	r0
    962c:	90 2d       	mov	r25, r0
    962e:	9f 70       	andi	r25, 0x0F	; 15
    9630:	91 27       	eor	r25, r17
    9632:	81 2f       	mov	r24, r17
    9634:	80 25       	eor	r24, r0
    9636:	88 0f       	add	r24, r24
    9638:	80 7e       	andi	r24, 0xE0	; 224
    963a:	98 27       	eor	r25, r24
    963c:	80 2d       	mov	r24, r0
    963e:	81 27       	eor	r24, r17
    9640:	80 7f       	andi	r24, 0xF0	; 240
    9642:	86 95       	lsr	r24
    9644:	01 2e       	mov	r0, r17
    9646:	00 0c       	add	r0, r0
    9648:	88 1f       	adc	r24, r24
    964a:	16 95       	lsr	r17
    964c:	16 95       	lsr	r17
    964e:	16 95       	lsr	r17
    9650:	1f 71       	andi	r17, 0x1F	; 31
    9652:	18 27       	eor	r17, r24
    9654:	10 27       	eor	r17, r16
    9656:	09 2f       	mov	r16, r25
    return 6;
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    9658:	c6 01       	movw	r24, r12
    965a:	61 e0       	ldi	r22, 0x01	; 1
    965c:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    9660:	88 23       	and	r24, r24
    9662:	11 f4       	brne	.+4      	; 0x9668 <rs485rollerHello+0x294>
    9664:	07 e0       	ldi	r16, 0x07	; 7
    9666:	79 c0       	rjmp	.+242    	; 0x975a <rs485rollerHello+0x386>
    return 7;
  if (data > maxSize)
    9668:	89 81       	ldd	r24, Y+1	; 0x01
    966a:	88 30       	cpi	r24, 0x08	; 8
    966c:	10 f0       	brcs	.+4      	; 0x9672 <rs485rollerHello+0x29e>
    966e:	01 e0       	ldi	r16, 0x01	; 1
    9670:	74 c0       	rjmp	.+232    	; 0x975a <rs485rollerHello+0x386>
    }
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
    9672:	22 e0       	ldi	r18, 0x02	; 2
    9674:	30 e0       	ldi	r19, 0x00	; 0
    9676:	e2 0e       	add	r14, r18
    9678:	f3 1e       	adc	r15, r19
    967a:	18 27       	eor	r17, r24
    967c:	01 2e       	mov	r0, r17
    967e:	02 94       	swap	r0
    9680:	90 2d       	mov	r25, r0
    9682:	9f 70       	andi	r25, 0x0F	; 15
    9684:	91 27       	eor	r25, r17
    9686:	81 2f       	mov	r24, r17
    9688:	80 25       	eor	r24, r0
    968a:	88 0f       	add	r24, r24
    968c:	80 7e       	andi	r24, 0xE0	; 224
    968e:	98 27       	eor	r25, r24
    9690:	80 2d       	mov	r24, r0
    9692:	81 27       	eor	r24, r17
    9694:	80 7f       	andi	r24, 0xF0	; 240
    9696:	86 95       	lsr	r24
    9698:	01 2e       	mov	r0, r17
    969a:	00 0c       	add	r0, r0
    969c:	88 1f       	adc	r24, r24
    969e:	16 95       	lsr	r17
    96a0:	16 95       	lsr	r17
    96a2:	16 95       	lsr	r17
    96a4:	1f 71       	andi	r17, 0x1F	; 31
    96a6:	18 27       	eor	r17, r24
    96a8:	10 27       	eor	r17, r16
    96aa:	09 2f       	mov	r16, r25
    return 7;
  if (data > maxSize)
    return 1;
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
    96ac:	87 e0       	ldi	r24, 0x07	; 7
    96ae:	f7 01       	movw	r30, r14
    96b0:	11 92       	st	Z+, r1
    96b2:	8a 95       	dec	r24
    96b4:	e9 f7       	brne	.-6      	; 0x96b0 <rs485rollerHello+0x2dc>
  maxSize = data;
    96b6:	d9 80       	ldd	r13, Y+1	; 0x01
  
  for (data=0; data < maxSize; data++)
    96b8:	19 82       	std	Y+1, r1	; 0x01
    96ba:	27 c0       	rjmp	.+78     	; 0x970a <rs485rollerHello+0x336>
  {
    if(rs485Receive(response, 5) == pdFALSE)
    96bc:	c7 01       	movw	r24, r14
    96be:	65 e0       	ldi	r22, 0x05	; 5
    96c0:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    96c4:	88 23       	and	r24, r24
    96c6:	11 f4       	brne	.+4      	; 0x96cc <rs485rollerHello+0x2f8>
    96c8:	04 e1       	ldi	r16, 0x14	; 20
    96ca:	47 c0       	rjmp	.+142    	; 0x975a <rs485rollerHello+0x386>
    96cc:	f7 01       	movw	r30, r14
    96ce:	81 91       	ld	r24, Z+
    96d0:	7f 01       	movw	r14, r30
    96d2:	18 27       	eor	r17, r24
    96d4:	01 2e       	mov	r0, r17
    96d6:	02 94       	swap	r0
    96d8:	90 2d       	mov	r25, r0
    96da:	9f 70       	andi	r25, 0x0F	; 15
    96dc:	91 27       	eor	r25, r17
    96de:	81 2f       	mov	r24, r17
    96e0:	80 25       	eor	r24, r0
    96e2:	88 0f       	add	r24, r24
    96e4:	80 7e       	andi	r24, 0xE0	; 224
    96e6:	98 27       	eor	r25, r24
    96e8:	80 2d       	mov	r24, r0
    96ea:	81 27       	eor	r24, r17
    96ec:	80 7f       	andi	r24, 0xF0	; 240
    96ee:	86 95       	lsr	r24
    96f0:	01 2e       	mov	r0, r17
    96f2:	00 0c       	add	r0, r0
    96f4:	88 1f       	adc	r24, r24
    96f6:	16 95       	lsr	r17
    96f8:	16 95       	lsr	r17
    96fa:	16 95       	lsr	r17
    96fc:	1f 71       	andi	r17, 0x1F	; 31
    96fe:	18 27       	eor	r17, r24
    9700:	10 27       	eor	r17, r16
    9702:	09 2f       	mov	r16, r25
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
    9704:	89 81       	ldd	r24, Y+1	; 0x01
    9706:	8f 5f       	subi	r24, 0xFF	; 255
    9708:	89 83       	std	Y+1, r24	; 0x01
    970a:	89 81       	ldd	r24, Y+1	; 0x01
    970c:	8d 15       	cp	r24, r13
    970e:	08 f4       	brcc	.+2      	; 0x9712 <rs485rollerHello+0x33e>
    9710:	d5 cf       	rjmp	.-86     	; 0x96bc <rs485rollerHello+0x2e8>
    response++; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    9712:	ce 01       	movw	r24, r28
    9714:	02 96       	adiw	r24, 0x02	; 2
    9716:	61 e0       	ldi	r22, 0x01	; 1
    9718:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <rs485Receive>
    971c:	81 30       	cpi	r24, 0x01	; 1
    971e:	11 f0       	breq	.+4      	; 0x9724 <rs485rollerHello+0x350>
    9720:	05 e1       	ldi	r16, 0x15	; 21
    9722:	1b c0       	rjmp	.+54     	; 0x975a <rs485rollerHello+0x386>
    return 21;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    9724:	80 91 9c 0e 	lds	r24, 0x0E9C
    9728:	90 91 9d 0e 	lds	r25, 0x0E9D
    972c:	be 01       	movw	r22, r28
    972e:	6d 5f       	subi	r22, 0xFD	; 253
    9730:	7f 4f       	sbci	r23, 0xFF	; 255
    9732:	41 e0       	ldi	r20, 0x01	; 1
    9734:	50 e0       	ldi	r21, 0x00	; 0
    9736:	20 e0       	ldi	r18, 0x00	; 0
    9738:	0e 94 d4 53 	call	0xa7a8	; 0xa7a8 <xQueueGenericReceive>
    973c:	81 30       	cpi	r24, 0x01	; 1
    973e:	11 f0       	breq	.+4      	; 0x9744 <rs485rollerHello+0x370>
    9740:	06 e1       	ldi	r16, 0x16	; 22
    9742:	0b c0       	rjmp	.+22     	; 0x975a <rs485rollerHello+0x386>
    return 22;

  if (crcHi != (uint8_t)(crc>>8))
    9744:	8a 81       	ldd	r24, Y+2	; 0x02
    9746:	81 17       	cp	r24, r17
    9748:	11 f0       	breq	.+4      	; 0x974e <rs485rollerHello+0x37a>
    974a:	0e ef       	ldi	r16, 0xFE	; 254
    974c:	06 c0       	rjmp	.+12     	; 0x975a <rs485rollerHello+0x386>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    974e:	8b 81       	ldd	r24, Y+3	; 0x03
    9750:	80 17       	cp	r24, r16
    9752:	11 f4       	brne	.+4      	; 0x9758 <rs485rollerHello+0x384>
    9754:	00 e0       	ldi	r16, 0x00	; 0
    9756:	01 c0       	rjmp	.+2      	; 0x975a <rs485rollerHello+0x386>
    9758:	0f ef       	ldi	r16, 0xFF	; 255
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
    975a:	0e 94 32 0c 	call	0x1864	; 0x1864 <releaseRs485>
    975e:	01 c0       	rjmp	.+2      	; 0x9762 <rs485rollerHello+0x38e>
  return result;
    9760:	01 e0       	ldi	r16, 0x01	; 1
}
    9762:	80 2f       	mov	r24, r16
    9764:	0f 90       	pop	r0
    9766:	0f 90       	pop	r0
    9768:	0f 90       	pop	r0
    976a:	cf 91       	pop	r28
    976c:	df 91       	pop	r29
    976e:	1f 91       	pop	r17
    9770:	0f 91       	pop	r16
    9772:	ff 90       	pop	r15
    9774:	ef 90       	pop	r14
    9776:	df 90       	pop	r13
    9778:	cf 90       	pop	r12
    977a:	bf 90       	pop	r11
    977c:	af 90       	pop	r10
    977e:	08 95       	ret

00009780 <rollersMemInit>:

// ************************ Rs485 API ************************************

void rollersMemInit(void)
{
  rollers = xmalloc(MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    9780:	84 e6       	ldi	r24, 0x64	; 100
    9782:	90 e0       	ldi	r25, 0x00	; 0
    9784:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <xmalloc>
    9788:	80 93 a8 0e 	sts	0x0EA8, r24
    978c:	90 93 a9 0e 	sts	0x0EA9, r25
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    9790:	fc 01       	movw	r30, r24
    9792:	84 e6       	ldi	r24, 0x64	; 100
    9794:	df 01       	movw	r26, r30
    9796:	1d 92       	st	X+, r1
    9798:	8a 95       	dec	r24
    979a:	e9 f7       	brne	.-6      	; 0x9796 <rollersMemInit+0x16>
}
    979c:	08 95       	ret

0000979e <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		portENTER_CRITICAL();
    979e:	0f b6       	in	r0, 0x3f	; 63
    97a0:	f8 94       	cli
    97a2:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    97a4:	00 97       	sbiw	r24, 0x00	; 0
    97a6:	29 f4       	brne	.+10     	; 0x97b2 <uxTaskPriorityGet+0x14>
    97a8:	e0 91 93 01 	lds	r30, 0x0193
    97ac:	f0 91 94 01 	lds	r31, 0x0194
    97b0:	01 c0       	rjmp	.+2      	; 0x97b4 <uxTaskPriorityGet+0x16>
    97b2:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portEXIT_CRITICAL();
    97b4:	0f 90       	pop	r0
    97b6:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    97b8:	86 89       	ldd	r24, Z+22	; 0x16
    97ba:	08 95       	ret

000097bc <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    97bc:	fc 01       	movw	r30, r24

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    97be:	82 85       	ldd	r24, Z+10	; 0x0a
    97c0:	93 85       	ldd	r25, Z+11	; 0x0b
    97c2:	8b 5d       	subi	r24, 0xDB	; 219
    97c4:	91 40       	sbci	r25, 0x01	; 1
    97c6:	59 f4       	brne	.+22     	; 0x97de <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    97c8:	84 89       	ldd	r24, Z+20	; 0x14
    97ca:	95 89       	ldd	r25, Z+21	; 0x15
    97cc:	21 e0       	ldi	r18, 0x01	; 1
    97ce:	82 3d       	cpi	r24, 0xD2	; 210
    97d0:	92 07       	cpc	r25, r18
    97d2:	29 f0       	breq	.+10     	; 0x97de <xTaskIsTaskSuspended+0x22>
    97d4:	20 e0       	ldi	r18, 0x00	; 0
    97d6:	89 2b       	or	r24, r25
    97d8:	19 f4       	brne	.+6      	; 0x97e0 <xTaskIsTaskSuspended+0x24>
    97da:	21 e0       	ldi	r18, 0x01	; 1
    97dc:	01 c0       	rjmp	.+2      	; 0x97e0 <xTaskIsTaskSuspended+0x24>
    97de:	20 e0       	ldi	r18, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    97e0:	82 2f       	mov	r24, r18
    97e2:	08 95       	ret

000097e4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    97e4:	80 91 99 01 	lds	r24, 0x0199
    97e8:	8f 5f       	subi	r24, 0xFF	; 255
    97ea:	80 93 99 01 	sts	0x0199, r24
}
    97ee:	08 95       	ret

000097f0 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    97f0:	0f b6       	in	r0, 0x3f	; 63
    97f2:	f8 94       	cli
    97f4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    97f6:	20 91 97 01 	lds	r18, 0x0197
    97fa:	30 91 98 01 	lds	r19, 0x0198
	}
	portEXIT_CRITICAL();
    97fe:	0f 90       	pop	r0
    9800:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    9802:	c9 01       	movw	r24, r18
    9804:	08 95       	ret

00009806 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    9806:	80 91 9e 01 	lds	r24, 0x019E
}
    980a:	08 95       	ret

0000980c <vTaskStartTrace>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
	{
		portENTER_CRITICAL();
    980c:	0f b6       	in	r0, 0x3f	; 63
    980e:	f8 94       	cli
    9810:	0f 92       	push	r0
		{
			pcTraceBuffer = ( signed char * )pcBuffer;
    9812:	90 93 e5 01 	sts	0x01E5, r25
    9816:	80 93 e4 01 	sts	0x01E4, r24
			pcTraceBufferStart = pcBuffer;
    981a:	90 93 e7 01 	sts	0x01E7, r25
    981e:	80 93 e6 01 	sts	0x01E6, r24
			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
    9822:	48 50       	subi	r20, 0x08	; 8
    9824:	50 40       	sbci	r21, 0x00	; 0
    9826:	48 0f       	add	r20, r24
    9828:	59 1f       	adc	r21, r25
    982a:	50 93 e9 01 	sts	0x01E9, r21
    982e:	40 93 e8 01 	sts	0x01E8, r20
			xTracing = pdTRUE;
    9832:	81 e0       	ldi	r24, 0x01	; 1
    9834:	80 93 9b 01 	sts	0x019B, r24
		}
		portEXIT_CRITICAL();
    9838:	0f 90       	pop	r0
    983a:	0f be       	out	0x3f, r0	; 63
	}
    983c:	08 95       	ret

0000983e <ulTaskEndTrace>:

	unsigned long ulTaskEndTrace( void )
	{
	unsigned long ulBufferLength;

		portENTER_CRITICAL();
    983e:	0f b6       	in	r0, 0x3f	; 63
    9840:	f8 94       	cli
    9842:	0f 92       	push	r0
			xTracing = pdFALSE;
    9844:	10 92 9b 01 	sts	0x019B, r1
		portEXIT_CRITICAL();
    9848:	0f 90       	pop	r0
    984a:	0f be       	out	0x3f, r0	; 63

		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
    984c:	20 91 e4 01 	lds	r18, 0x01E4
    9850:	30 91 e5 01 	lds	r19, 0x01E5
    9854:	80 91 e6 01 	lds	r24, 0x01E6
    9858:	90 91 e7 01 	lds	r25, 0x01E7
    985c:	28 1b       	sub	r18, r24
    985e:	39 0b       	sbc	r19, r25
    9860:	44 27       	eor	r20, r20
    9862:	37 fd       	sbrc	r19, 7
    9864:	40 95       	com	r20
    9866:	54 2f       	mov	r21, r20

		return ulBufferLength;
	}
    9868:	b9 01       	movw	r22, r18
    986a:	ca 01       	movw	r24, r20
    986c:	08 95       	ret

0000986e <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    986e:	80 91 99 01 	lds	r24, 0x0199
    9872:	88 23       	and	r24, r24
    9874:	51 f0       	breq	.+20     	; 0x988a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    9876:	81 e0       	ldi	r24, 0x01	; 1
    9878:	80 93 95 01 	sts	0x0195, r24
    987c:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    987e:	80 91 9a 01 	lds	r24, 0x019A
    9882:	81 50       	subi	r24, 0x01	; 1
    9884:	80 93 9a 01 	sts	0x019A, r24
    9888:	01 c0       	rjmp	.+2      	; 0x988c <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    988a:	99 e0       	ldi	r25, 0x09	; 9
    988c:	e0 91 9a 01 	lds	r30, 0x019A
    9890:	e9 9f       	mul	r30, r25
    9892:	f0 01       	movw	r30, r0
    9894:	11 24       	eor	r1, r1
    9896:	ef 55       	subi	r30, 0x5F	; 95
    9898:	fe 4f       	sbci	r31, 0xFE	; 254
    989a:	80 81       	ld	r24, Z
    989c:	88 23       	and	r24, r24
    989e:	79 f3       	breq	.-34     	; 0x987e <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    98a0:	90 91 9a 01 	lds	r25, 0x019A
    98a4:	89 e0       	ldi	r24, 0x09	; 9
    98a6:	98 9f       	mul	r25, r24
    98a8:	d0 01       	movw	r26, r0
    98aa:	11 24       	eor	r1, r1
    98ac:	af 55       	subi	r26, 0x5F	; 95
    98ae:	be 4f       	sbci	r27, 0xFE	; 254
    98b0:	11 96       	adiw	r26, 0x01	; 1
    98b2:	ed 91       	ld	r30, X+
    98b4:	fc 91       	ld	r31, X
    98b6:	12 97       	sbiw	r26, 0x02	; 2
    98b8:	02 80       	ldd	r0, Z+2	; 0x02
    98ba:	f3 81       	ldd	r31, Z+3	; 0x03
    98bc:	e0 2d       	mov	r30, r0
    98be:	12 96       	adiw	r26, 0x02	; 2
    98c0:	fc 93       	st	X, r31
    98c2:	ee 93       	st	-X, r30
    98c4:	11 97       	sbiw	r26, 0x01	; 1
    98c6:	cd 01       	movw	r24, r26
    98c8:	03 96       	adiw	r24, 0x03	; 3
    98ca:	e8 17       	cp	r30, r24
    98cc:	f9 07       	cpc	r31, r25
    98ce:	31 f4       	brne	.+12     	; 0x98dc <vTaskSwitchContext+0x6e>
    98d0:	82 81       	ldd	r24, Z+2	; 0x02
    98d2:	93 81       	ldd	r25, Z+3	; 0x03
    98d4:	12 96       	adiw	r26, 0x02	; 2
    98d6:	9c 93       	st	X, r25
    98d8:	8e 93       	st	-X, r24
    98da:	11 97       	sbiw	r26, 0x01	; 1
    98dc:	11 96       	adiw	r26, 0x01	; 1
    98de:	ed 91       	ld	r30, X+
    98e0:	fc 91       	ld	r31, X
    98e2:	12 97       	sbiw	r26, 0x02	; 2
    98e4:	86 81       	ldd	r24, Z+6	; 0x06
    98e6:	97 81       	ldd	r25, Z+7	; 0x07
    98e8:	90 93 94 01 	sts	0x0194, r25
    98ec:	80 93 93 01 	sts	0x0193, r24

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
    98f0:	80 91 9b 01 	lds	r24, 0x019B
    98f4:	88 23       	and	r24, r24
    98f6:	09 f4       	brne	.+2      	; 0x98fa <vTaskSwitchContext+0x8c>
    98f8:	4b c0       	rjmp	.+150    	; 0x9990 <vTaskSwitchContext+0x122>
    98fa:	e0 91 93 01 	lds	r30, 0x0193
    98fe:	f0 91 94 01 	lds	r31, 0x0194
    9902:	90 91 81 01 	lds	r25, 0x0181
    9906:	83 a1       	ldd	r24, Z+35	; 0x23
    9908:	98 17       	cp	r25, r24
    990a:	09 f4       	brne	.+2      	; 0x990e <vTaskSwitchContext+0xa0>
    990c:	41 c0       	rjmp	.+130    	; 0x9990 <vTaskSwitchContext+0x122>
    990e:	80 91 e4 01 	lds	r24, 0x01E4
    9912:	90 91 e5 01 	lds	r25, 0x01E5
    9916:	08 96       	adiw	r24, 0x08	; 8
    9918:	20 91 e8 01 	lds	r18, 0x01E8
    991c:	30 91 e9 01 	lds	r19, 0x01E9
    9920:	82 17       	cp	r24, r18
    9922:	93 07       	cpc	r25, r19
    9924:	98 f5       	brcc	.+102    	; 0x998c <vTaskSwitchContext+0x11e>
    9926:	e0 91 93 01 	lds	r30, 0x0193
    992a:	f0 91 94 01 	lds	r31, 0x0194
    992e:	23 a1       	ldd	r18, Z+35	; 0x23
    9930:	20 93 81 01 	sts	0x0181, r18
    9934:	e0 91 e4 01 	lds	r30, 0x01E4
    9938:	f0 91 e5 01 	lds	r31, 0x01E5
    993c:	80 91 97 01 	lds	r24, 0x0197
    9940:	90 91 98 01 	lds	r25, 0x0198
    9944:	a0 e0       	ldi	r26, 0x00	; 0
    9946:	b0 e0       	ldi	r27, 0x00	; 0
    9948:	80 83       	st	Z, r24
    994a:	91 83       	std	Z+1, r25	; 0x01
    994c:	a2 83       	std	Z+2, r26	; 0x02
    994e:	b3 83       	std	Z+3, r27	; 0x03
    9950:	80 91 e4 01 	lds	r24, 0x01E4
    9954:	90 91 e5 01 	lds	r25, 0x01E5
    9958:	04 96       	adiw	r24, 0x04	; 4
    995a:	90 93 e5 01 	sts	0x01E5, r25
    995e:	80 93 e4 01 	sts	0x01E4, r24
    9962:	e0 91 e4 01 	lds	r30, 0x01E4
    9966:	f0 91 e5 01 	lds	r31, 0x01E5
    996a:	30 e0       	ldi	r19, 0x00	; 0
    996c:	40 e0       	ldi	r20, 0x00	; 0
    996e:	50 e0       	ldi	r21, 0x00	; 0
    9970:	20 83       	st	Z, r18
    9972:	31 83       	std	Z+1, r19	; 0x01
    9974:	42 83       	std	Z+2, r20	; 0x02
    9976:	53 83       	std	Z+3, r21	; 0x03
    9978:	80 91 e4 01 	lds	r24, 0x01E4
    997c:	90 91 e5 01 	lds	r25, 0x01E5
    9980:	04 96       	adiw	r24, 0x04	; 4
    9982:	90 93 e5 01 	sts	0x01E5, r25
    9986:	80 93 e4 01 	sts	0x01E4, r24
    998a:	08 95       	ret
    998c:	10 92 9b 01 	sts	0x019B, r1
    9990:	08 95       	ret

00009992 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    9992:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    9994:	80 91 96 01 	lds	r24, 0x0196
    9998:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    999a:	80 91 97 01 	lds	r24, 0x0197
    999e:	90 91 98 01 	lds	r25, 0x0198
    99a2:	92 83       	std	Z+2, r25	; 0x02
    99a4:	81 83       	std	Z+1, r24	; 0x01
}
    99a6:	08 95       	ret

000099a8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    99a8:	fc 01       	movw	r30, r24
    99aa:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    99ac:	0f b6       	in	r0, 0x3f	; 63
    99ae:	f8 94       	cli
    99b0:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    99b2:	4d 91       	ld	r20, X+
    99b4:	5c 91       	ld	r21, X
    99b6:	11 97       	sbiw	r26, 0x01	; 1
    99b8:	8f ef       	ldi	r24, 0xFF	; 255
    99ba:	4f 3f       	cpi	r20, 0xFF	; 255
    99bc:	58 07       	cpc	r21, r24
    99be:	61 f1       	breq	.+88     	; 0x9a18 <xTaskCheckForTimeOut+0x70>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    99c0:	90 91 96 01 	lds	r25, 0x0196
    99c4:	80 81       	ld	r24, Z
    99c6:	98 17       	cp	r25, r24
    99c8:	49 f0       	breq	.+18     	; 0x99dc <xTaskCheckForTimeOut+0x34>
    99ca:	20 91 97 01 	lds	r18, 0x0197
    99ce:	30 91 98 01 	lds	r19, 0x0198
    99d2:	81 81       	ldd	r24, Z+1	; 0x01
    99d4:	92 81       	ldd	r25, Z+2	; 0x02
    99d6:	28 17       	cp	r18, r24
    99d8:	39 07       	cpc	r19, r25
    99da:	00 f5       	brcc	.+64     	; 0x9a1c <xTaskCheckForTimeOut+0x74>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    99dc:	80 91 97 01 	lds	r24, 0x0197
    99e0:	90 91 98 01 	lds	r25, 0x0198
    99e4:	21 81       	ldd	r18, Z+1	; 0x01
    99e6:	32 81       	ldd	r19, Z+2	; 0x02
    99e8:	82 1b       	sub	r24, r18
    99ea:	93 0b       	sbc	r25, r19
    99ec:	84 17       	cp	r24, r20
    99ee:	95 07       	cpc	r25, r21
    99f0:	a8 f4       	brcc	.+42     	; 0x9a1c <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    99f2:	80 91 97 01 	lds	r24, 0x0197
    99f6:	90 91 98 01 	lds	r25, 0x0198
    99fa:	28 1b       	sub	r18, r24
    99fc:	39 0b       	sbc	r19, r25
    99fe:	24 0f       	add	r18, r20
    9a00:	35 1f       	adc	r19, r21
    9a02:	2d 93       	st	X+, r18
    9a04:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    9a06:	80 91 96 01 	lds	r24, 0x0196
    9a0a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    9a0c:	80 91 97 01 	lds	r24, 0x0197
    9a10:	90 91 98 01 	lds	r25, 0x0198
    9a14:	92 83       	std	Z+2, r25	; 0x02
    9a16:	81 83       	std	Z+1, r24	; 0x01
    9a18:	80 e0       	ldi	r24, 0x00	; 0
    9a1a:	01 c0       	rjmp	.+2      	; 0x9a1e <xTaskCheckForTimeOut+0x76>
    9a1c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    9a1e:	0f 90       	pop	r0
    9a20:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    9a22:	08 95       	ret

00009a24 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    9a24:	81 e0       	ldi	r24, 0x01	; 1
    9a26:	80 93 95 01 	sts	0x0195, r24
}
    9a2a:	08 95       	ret

00009a2c <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    9a2c:	0f 93       	push	r16
    9a2e:	1f 93       	push	r17
    9a30:	cf 93       	push	r28
    9a32:	df 93       	push	r29
    9a34:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    9a36:	80 81       	ld	r24, Z
    9a38:	88 23       	and	r24, r24
    9a3a:	19 f4       	brne	.+6      	; 0x9a42 <xTaskRemoveFromEventList+0x16>
    9a3c:	c0 e0       	ldi	r28, 0x00	; 0
    9a3e:	d0 e0       	ldi	r29, 0x00	; 0
    9a40:	05 c0       	rjmp	.+10     	; 0x9a4c <xTaskRemoveFromEventList+0x20>
    9a42:	05 80       	ldd	r0, Z+5	; 0x05
    9a44:	f6 81       	ldd	r31, Z+6	; 0x06
    9a46:	e0 2d       	mov	r30, r0
    9a48:	c6 81       	ldd	r28, Z+6	; 0x06
    9a4a:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    9a4c:	8e 01       	movw	r16, r28
    9a4e:	04 5f       	subi	r16, 0xF4	; 244
    9a50:	1f 4f       	sbci	r17, 0xFF	; 255
    9a52:	c8 01       	movw	r24, r16
    9a54:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9a58:	80 91 99 01 	lds	r24, 0x0199
    9a5c:	88 23       	and	r24, r24
    9a5e:	a1 f4       	brne	.+40     	; 0x9a88 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    9a60:	8e 01       	movw	r16, r28
    9a62:	0e 5f       	subi	r16, 0xFE	; 254
    9a64:	1f 4f       	sbci	r17, 0xFF	; 255
    9a66:	c8 01       	movw	r24, r16
    9a68:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    9a6c:	9e 89       	ldd	r25, Y+22	; 0x16
    9a6e:	80 91 9a 01 	lds	r24, 0x019A
    9a72:	89 17       	cp	r24, r25
    9a74:	10 f4       	brcc	.+4      	; 0x9a7a <xTaskRemoveFromEventList+0x4e>
    9a76:	90 93 9a 01 	sts	0x019A, r25
    9a7a:	89 e0       	ldi	r24, 0x09	; 9
    9a7c:	98 9f       	mul	r25, r24
    9a7e:	c0 01       	movw	r24, r0
    9a80:	11 24       	eor	r1, r1
    9a82:	8f 55       	subi	r24, 0x5F	; 95
    9a84:	9e 4f       	sbci	r25, 0xFE	; 254
    9a86:	02 c0       	rjmp	.+4      	; 0x9a8c <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    9a88:	82 ed       	ldi	r24, 0xD2	; 210
    9a8a:	91 e0       	ldi	r25, 0x01	; 1
    9a8c:	b8 01       	movw	r22, r16
    9a8e:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9a92:	e0 91 93 01 	lds	r30, 0x0193
    9a96:	f0 91 94 01 	lds	r31, 0x0194
    9a9a:	20 e0       	ldi	r18, 0x00	; 0
    9a9c:	9e 89       	ldd	r25, Y+22	; 0x16
    9a9e:	86 89       	ldd	r24, Z+22	; 0x16
    9aa0:	98 17       	cp	r25, r24
    9aa2:	08 f0       	brcs	.+2      	; 0x9aa6 <xTaskRemoveFromEventList+0x7a>
    9aa4:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    9aa6:	82 2f       	mov	r24, r18
    9aa8:	df 91       	pop	r29
    9aaa:	cf 91       	pop	r28
    9aac:	1f 91       	pop	r17
    9aae:	0f 91       	pop	r16
    9ab0:	08 95       	ret

00009ab2 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    9ab2:	df 92       	push	r13
    9ab4:	ef 92       	push	r14
    9ab6:	ff 92       	push	r15
    9ab8:	0f 93       	push	r16
    9aba:	1f 93       	push	r17
    9abc:	cf 93       	push	r28
    9abe:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
    9ac0:	ec 01       	movw	r28, r24
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    9ac2:	8a 85       	ldd	r24, Y+10	; 0x0a
    9ac4:	9b 85       	ldd	r25, Y+11	; 0x0b
    9ac6:	8b 5d       	subi	r24, 0xDB	; 219
    9ac8:	91 40       	sbci	r25, 0x01	; 1
    9aca:	91 f5       	brne	.+100    	; 0x9b30 <xTaskResumeFromISR+0x7e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    9acc:	8c 89       	ldd	r24, Y+20	; 0x14
    9ace:	9d 89       	ldd	r25, Y+21	; 0x15
    9ad0:	21 e0       	ldi	r18, 0x01	; 1
    9ad2:	82 3d       	cpi	r24, 0xD2	; 210
    9ad4:	92 07       	cpc	r25, r18
    9ad6:	61 f1       	breq	.+88     	; 0x9b30 <xTaskResumeFromISR+0x7e>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    9ad8:	89 2b       	or	r24, r25
    9ada:	51 f5       	brne	.+84     	; 0x9b30 <xTaskResumeFromISR+0x7e>
    9adc:	33 c0       	rjmp	.+102    	; 0x9b44 <xTaskResumeFromISR+0x92>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    9ade:	de 88       	ldd	r13, Y+22	; 0x16
    9ae0:	e0 91 93 01 	lds	r30, 0x0193
    9ae4:	f0 91 94 01 	lds	r31, 0x0194
    9ae8:	06 89       	ldd	r16, Z+22	; 0x16
				vListRemove(  &( pxTCB->xGenericListItem ) );
    9aea:	82 e0       	ldi	r24, 0x02	; 2
    9aec:	e8 2e       	mov	r14, r24
    9aee:	f1 2c       	mov	r15, r1
    9af0:	ec 0e       	add	r14, r28
    9af2:	fd 1e       	adc	r15, r29
    9af4:	c7 01       	movw	r24, r14
    9af6:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    9afa:	6e 89       	ldd	r22, Y+22	; 0x16
    9afc:	80 91 9a 01 	lds	r24, 0x019A
    9b00:	86 17       	cp	r24, r22
    9b02:	10 f4       	brcc	.+4      	; 0x9b08 <xTaskResumeFromISR+0x56>
    9b04:	60 93 9a 01 	sts	0x019A, r22
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    9b08:	10 e0       	ldi	r17, 0x00	; 0
    9b0a:	d0 16       	cp	r13, r16
    9b0c:	08 f0       	brcs	.+2      	; 0x9b10 <xTaskResumeFromISR+0x5e>
    9b0e:	11 e0       	ldi	r17, 0x01	; 1
				vListRemove(  &( pxTCB->xGenericListItem ) );
				prvAddTaskToReadyQueue( pxTCB );
    9b10:	89 e0       	ldi	r24, 0x09	; 9
    9b12:	68 9f       	mul	r22, r24
    9b14:	c0 01       	movw	r24, r0
    9b16:	11 24       	eor	r1, r1
    9b18:	8f 55       	subi	r24, 0x5F	; 95
    9b1a:	9e 4f       	sbci	r25, 0xFE	; 254
    9b1c:	b7 01       	movw	r22, r14
    9b1e:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
    9b22:	07 c0       	rjmp	.+14     	; 0x9b32 <xTaskResumeFromISR+0x80>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    9b24:	2c 96       	adiw	r28, 0x0c	; 12
    9b26:	82 ed       	ldi	r24, 0xD2	; 210
    9b28:	91 e0       	ldi	r25, 0x01	; 1
    9b2a:	be 01       	movw	r22, r28
    9b2c:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
    9b30:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		return xYieldRequired;
	}
    9b32:	81 2f       	mov	r24, r17
    9b34:	df 91       	pop	r29
    9b36:	cf 91       	pop	r28
    9b38:	1f 91       	pop	r17
    9b3a:	0f 91       	pop	r16
    9b3c:	ff 90       	pop	r15
    9b3e:	ef 90       	pop	r14
    9b40:	df 90       	pop	r13
    9b42:	08 95       	ret

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9b44:	80 91 99 01 	lds	r24, 0x0199
    9b48:	88 23       	and	r24, r24
    9b4a:	49 f2       	breq	.-110    	; 0x9ade <xTaskResumeFromISR+0x2c>
    9b4c:	eb cf       	rjmp	.-42     	; 0x9b24 <xTaskResumeFromISR+0x72>

00009b4e <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    9b4e:	cf 93       	push	r28
    9b50:	df 93       	push	r29
    9b52:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    9b54:	60 91 93 01 	lds	r22, 0x0193
    9b58:	70 91 94 01 	lds	r23, 0x0194
    9b5c:	64 5f       	subi	r22, 0xF4	; 244
    9b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    9b60:	0e 94 38 56 	call	0xac70	; 0xac70 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9b64:	80 91 93 01 	lds	r24, 0x0193
    9b68:	90 91 94 01 	lds	r25, 0x0194
    9b6c:	02 96       	adiw	r24, 0x02	; 2
    9b6e:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    9b72:	8f ef       	ldi	r24, 0xFF	; 255
    9b74:	cf 3f       	cpi	r28, 0xFF	; 255
    9b76:	d8 07       	cpc	r29, r24
    9b78:	59 f4       	brne	.+22     	; 0x9b90 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9b7a:	60 91 93 01 	lds	r22, 0x0193
    9b7e:	70 91 94 01 	lds	r23, 0x0194
    9b82:	6e 5f       	subi	r22, 0xFE	; 254
    9b84:	7f 4f       	sbci	r23, 0xFF	; 255
    9b86:	8b ed       	ldi	r24, 0xDB	; 219
    9b88:	91 e0       	ldi	r25, 0x01	; 1
    9b8a:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
    9b8e:	24 c0       	rjmp	.+72     	; 0x9bd8 <vTaskPlaceOnEventList+0x8a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    9b90:	80 91 97 01 	lds	r24, 0x0197
    9b94:	90 91 98 01 	lds	r25, 0x0198
    9b98:	8c 0f       	add	r24, r28
    9b9a:	9d 1f       	adc	r25, r29

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    9b9c:	e0 91 93 01 	lds	r30, 0x0193
    9ba0:	f0 91 94 01 	lds	r31, 0x0194
    9ba4:	93 83       	std	Z+3, r25	; 0x03
    9ba6:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    9ba8:	20 91 97 01 	lds	r18, 0x0197
    9bac:	30 91 98 01 	lds	r19, 0x0198
    9bb0:	82 17       	cp	r24, r18
    9bb2:	93 07       	cpc	r25, r19
    9bb4:	28 f4       	brcc	.+10     	; 0x9bc0 <vTaskPlaceOnEventList+0x72>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9bb6:	80 91 d0 01 	lds	r24, 0x01D0
    9bba:	90 91 d1 01 	lds	r25, 0x01D1
    9bbe:	04 c0       	rjmp	.+8      	; 0x9bc8 <vTaskPlaceOnEventList+0x7a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9bc0:	80 91 ce 01 	lds	r24, 0x01CE
    9bc4:	90 91 cf 01 	lds	r25, 0x01CF
    9bc8:	60 91 93 01 	lds	r22, 0x0193
    9bcc:	70 91 94 01 	lds	r23, 0x0194
    9bd0:	6e 5f       	subi	r22, 0xFE	; 254
    9bd2:	7f 4f       	sbci	r23, 0xFF	; 255
    9bd4:	0e 94 38 56 	call	0xac70	; 0xac70 <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    9bd8:	df 91       	pop	r29
    9bda:	cf 91       	pop	r28
    9bdc:	08 95       	ret

00009bde <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    9bde:	ff 92       	push	r15
    9be0:	0f 93       	push	r16
    9be2:	1f 93       	push	r17
    9be4:	cf 93       	push	r28
    9be6:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9be8:	80 91 99 01 	lds	r24, 0x0199
    9bec:	88 23       	and	r24, r24
    9bee:	09 f0       	breq	.+2      	; 0x9bf2 <vTaskIncrementTick+0x14>
    9bf0:	61 c0       	rjmp	.+194    	; 0x9cb4 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    9bf2:	80 91 97 01 	lds	r24, 0x0197
    9bf6:	90 91 98 01 	lds	r25, 0x0198
    9bfa:	01 96       	adiw	r24, 0x01	; 1
    9bfc:	90 93 98 01 	sts	0x0198, r25
    9c00:	80 93 97 01 	sts	0x0197, r24
		if( xTickCount == ( portTickType ) 0 )
    9c04:	80 91 97 01 	lds	r24, 0x0197
    9c08:	90 91 98 01 	lds	r25, 0x0198
    9c0c:	89 2b       	or	r24, r25
    9c0e:	e9 f5       	brne	.+122    	; 0x9c8a <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    9c10:	80 91 ce 01 	lds	r24, 0x01CE
    9c14:	90 91 cf 01 	lds	r25, 0x01CF
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    9c18:	20 91 d0 01 	lds	r18, 0x01D0
    9c1c:	30 91 d1 01 	lds	r19, 0x01D1
    9c20:	30 93 cf 01 	sts	0x01CF, r19
    9c24:	20 93 ce 01 	sts	0x01CE, r18
			pxOverflowDelayedTaskList = pxTemp;
    9c28:	90 93 d1 01 	sts	0x01D1, r25
    9c2c:	80 93 d0 01 	sts	0x01D0, r24
			xNumOfOverflows++;
    9c30:	80 91 96 01 	lds	r24, 0x0196
    9c34:	8f 5f       	subi	r24, 0xFF	; 255
    9c36:	80 93 96 01 	sts	0x0196, r24
    9c3a:	27 c0       	rjmp	.+78     	; 0x9c8a <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    9c3c:	20 91 97 01 	lds	r18, 0x0197
    9c40:	30 91 98 01 	lds	r19, 0x0198
    9c44:	8a 81       	ldd	r24, Y+2	; 0x02
    9c46:	9b 81       	ldd	r25, Y+3	; 0x03
    9c48:	28 17       	cp	r18, r24
    9c4a:	39 07       	cpc	r19, r25
    9c4c:	d0 f1       	brcs	.+116    	; 0x9cc2 <vTaskIncrementTick+0xe4>
    9c4e:	8e 01       	movw	r16, r28
    9c50:	0e 5f       	subi	r16, 0xFE	; 254
    9c52:	1f 4f       	sbci	r17, 0xFF	; 255
    9c54:	c8 01       	movw	r24, r16
    9c56:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
    9c5a:	8c 89       	ldd	r24, Y+20	; 0x14
    9c5c:	9d 89       	ldd	r25, Y+21	; 0x15
    9c5e:	89 2b       	or	r24, r25
    9c60:	21 f0       	breq	.+8      	; 0x9c6a <vTaskIncrementTick+0x8c>
    9c62:	ce 01       	movw	r24, r28
    9c64:	0c 96       	adiw	r24, 0x0c	; 12
    9c66:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
    9c6a:	9e 89       	ldd	r25, Y+22	; 0x16
    9c6c:	80 91 9a 01 	lds	r24, 0x019A
    9c70:	89 17       	cp	r24, r25
    9c72:	10 f4       	brcc	.+4      	; 0x9c78 <vTaskIncrementTick+0x9a>
    9c74:	90 93 9a 01 	sts	0x019A, r25
    9c78:	9f 9d       	mul	r25, r15
    9c7a:	c0 01       	movw	r24, r0
    9c7c:	11 24       	eor	r1, r1
    9c7e:	8f 55       	subi	r24, 0x5F	; 95
    9c80:	9e 4f       	sbci	r25, 0xFE	; 254
    9c82:	b8 01       	movw	r22, r16
    9c84:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
    9c88:	02 c0       	rjmp	.+4      	; 0x9c8e <vTaskIncrementTick+0xb0>
    9c8a:	99 e0       	ldi	r25, 0x09	; 9
    9c8c:	f9 2e       	mov	r15, r25
    9c8e:	e0 91 ce 01 	lds	r30, 0x01CE
    9c92:	f0 91 cf 01 	lds	r31, 0x01CF
    9c96:	80 81       	ld	r24, Z
    9c98:	88 23       	and	r24, r24
    9c9a:	99 f0       	breq	.+38     	; 0x9cc2 <vTaskIncrementTick+0xe4>
    9c9c:	e0 91 ce 01 	lds	r30, 0x01CE
    9ca0:	f0 91 cf 01 	lds	r31, 0x01CF
    9ca4:	05 80       	ldd	r0, Z+5	; 0x05
    9ca6:	f6 81       	ldd	r31, Z+6	; 0x06
    9ca8:	e0 2d       	mov	r30, r0
    9caa:	c6 81       	ldd	r28, Z+6	; 0x06
    9cac:	d7 81       	ldd	r29, Z+7	; 0x07
    9cae:	20 97       	sbiw	r28, 0x00	; 0
    9cb0:	29 f6       	brne	.-118    	; 0x9c3c <vTaskIncrementTick+0x5e>
    9cb2:	07 c0       	rjmp	.+14     	; 0x9cc2 <vTaskIncrementTick+0xe4>
	}
	else
	{
		++uxMissedTicks;
    9cb4:	80 91 9c 01 	lds	r24, 0x019C
    9cb8:	8f 5f       	subi	r24, 0xFF	; 255
    9cba:	80 93 9c 01 	sts	0x019C, r24
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
    9cbe:	0e 94 c0 0a 	call	0x1580	; 0x1580 <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
    9cc2:	80 91 9c 01 	lds	r24, 0x019C
    9cc6:	88 23       	and	r24, r24
    9cc8:	11 f4       	brne	.+4      	; 0x9cce <vTaskIncrementTick+0xf0>
		{
			vApplicationTickHook();
    9cca:	0e 94 c0 0a 	call	0x1580	; 0x1580 <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    9cce:	df 91       	pop	r29
    9cd0:	cf 91       	pop	r28
    9cd2:	1f 91       	pop	r17
    9cd4:	0f 91       	pop	r16
    9cd6:	ff 90       	pop	r15
    9cd8:	08 95       	ret

00009cda <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
    9cda:	4f 92       	push	r4
    9cdc:	5f 92       	push	r5
    9cde:	6f 92       	push	r6
    9ce0:	7f 92       	push	r7
    9ce2:	8f 92       	push	r8
    9ce4:	9f 92       	push	r9
    9ce6:	af 92       	push	r10
    9ce8:	bf 92       	push	r11
    9cea:	cf 92       	push	r12
    9cec:	df 92       	push	r13
    9cee:	ef 92       	push	r14
    9cf0:	ff 92       	push	r15
    9cf2:	0f 93       	push	r16
    9cf4:	1f 93       	push	r17
    9cf6:	cf 93       	push	r28
    9cf8:	df 93       	push	r29
    9cfa:	4c 01       	movw	r8, r24
    9cfc:	8b 01       	movw	r16, r22
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    9cfe:	db 01       	movw	r26, r22
    9d00:	11 96       	adiw	r26, 0x01	; 1
    9d02:	ed 91       	ld	r30, X+
    9d04:	fc 91       	ld	r31, X
    9d06:	12 97       	sbiw	r26, 0x02	; 2
    9d08:	02 80       	ldd	r0, Z+2	; 0x02
    9d0a:	f3 81       	ldd	r31, Z+3	; 0x03
    9d0c:	e0 2d       	mov	r30, r0
    9d0e:	12 96       	adiw	r26, 0x02	; 2
    9d10:	fc 93       	st	X, r31
    9d12:	ee 93       	st	-X, r30
    9d14:	11 97       	sbiw	r26, 0x01	; 1
    9d16:	cb 01       	movw	r24, r22
    9d18:	03 96       	adiw	r24, 0x03	; 3
    9d1a:	e8 17       	cp	r30, r24
    9d1c:	f9 07       	cpc	r31, r25
    9d1e:	31 f4       	brne	.+12     	; 0x9d2c <prvListTaskWithinSingleList+0x52>
    9d20:	82 81       	ldd	r24, Z+2	; 0x02
    9d22:	93 81       	ldd	r25, Z+3	; 0x03
    9d24:	12 96       	adiw	r26, 0x02	; 2
    9d26:	9c 93       	st	X, r25
    9d28:	8e 93       	st	-X, r24
    9d2a:	11 97       	sbiw	r26, 0x01	; 1
    9d2c:	d8 01       	movw	r26, r16
    9d2e:	11 96       	adiw	r26, 0x01	; 1
    9d30:	ed 91       	ld	r30, X+
    9d32:	fc 91       	ld	r31, X
    9d34:	12 97       	sbiw	r26, 0x02	; 2
    9d36:	a6 80       	ldd	r10, Z+6	; 0x06
    9d38:	b7 80       	ldd	r11, Z+7	; 0x07
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    9d3a:	53 e0       	ldi	r21, 0x03	; 3
    9d3c:	e5 2e       	mov	r14, r21
    9d3e:	f1 2c       	mov	r15, r1
    9d40:	e0 0e       	add	r14, r16
    9d42:	f1 1e       	adc	r15, r17
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    9d44:	3a ee       	ldi	r19, 0xEA	; 234
    9d46:	63 2e       	mov	r6, r19
    9d48:	31 e0       	ldi	r19, 0x01	; 1
    9d4a:	73 2e       	mov	r7, r19
    9d4c:	27 e6       	ldi	r18, 0x67	; 103
    9d4e:	42 2e       	mov	r4, r18
    9d50:	21 e0       	ldi	r18, 0x01	; 1
    9d52:	52 2e       	mov	r5, r18
    9d54:	c4 2e       	mov	r12, r20
    9d56:	dd 24       	eor	r13, r13
    9d58:	c7 fc       	sbrc	r12, 7
    9d5a:	d0 94       	com	r13

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    9d5c:	d8 01       	movw	r26, r16
    9d5e:	11 96       	adiw	r26, 0x01	; 1
    9d60:	ed 91       	ld	r30, X+
    9d62:	fc 91       	ld	r31, X
    9d64:	12 97       	sbiw	r26, 0x02	; 2
    9d66:	82 81       	ldd	r24, Z+2	; 0x02
    9d68:	93 81       	ldd	r25, Z+3	; 0x03
    9d6a:	12 96       	adiw	r26, 0x02	; 2
    9d6c:	9c 93       	st	X, r25
    9d6e:	8e 93       	st	-X, r24
    9d70:	11 97       	sbiw	r26, 0x01	; 1
    9d72:	8e 15       	cp	r24, r14
    9d74:	9f 05       	cpc	r25, r15
    9d76:	39 f4       	brne	.+14     	; 0x9d86 <prvListTaskWithinSingleList+0xac>
    9d78:	f7 01       	movw	r30, r14
    9d7a:	82 81       	ldd	r24, Z+2	; 0x02
    9d7c:	93 81       	ldd	r25, Z+3	; 0x03
    9d7e:	12 96       	adiw	r26, 0x02	; 2
    9d80:	9c 93       	st	X, r25
    9d82:	8e 93       	st	-X, r24
    9d84:	11 97       	sbiw	r26, 0x01	; 1
    9d86:	d8 01       	movw	r26, r16
    9d88:	11 96       	adiw	r26, 0x01	; 1
    9d8a:	ed 91       	ld	r30, X+
    9d8c:	fc 91       	ld	r31, X
    9d8e:	12 97       	sbiw	r26, 0x02	; 2
    9d90:	c6 81       	ldd	r28, Z+6	; 0x06
    9d92:	d7 81       	ldd	r29, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
    9d94:	ef 89       	ldd	r30, Y+23	; 0x17
    9d96:	f8 8d       	ldd	r31, Y+24	; 0x18
    9d98:	20 e0       	ldi	r18, 0x00	; 0
    9d9a:	30 e0       	ldi	r19, 0x00	; 0
    9d9c:	03 c0       	rjmp	.+6      	; 0x9da4 <prvListTaskWithinSingleList+0xca>
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
    9d9e:	31 96       	adiw	r30, 0x01	; 1
			usCount++;
    9da0:	2f 5f       	subi	r18, 0xFF	; 255
    9da2:	3f 4f       	sbci	r19, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    9da4:	80 81       	ld	r24, Z
    9da6:	85 3a       	cpi	r24, 0xA5	; 165
    9da8:	d1 f3       	breq	.-12     	; 0x9d9e <prvListTaskWithinSingleList+0xc4>
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    9daa:	8e 89       	ldd	r24, Y+22	; 0x16
    9dac:	9b a1       	ldd	r25, Y+35	; 0x23
    9dae:	ed b7       	in	r30, 0x3d	; 61
    9db0:	fe b7       	in	r31, 0x3e	; 62
    9db2:	3e 97       	sbiw	r30, 0x0e	; 14
    9db4:	0f b6       	in	r0, 0x3f	; 63
    9db6:	f8 94       	cli
    9db8:	fe bf       	out	0x3e, r31	; 62
    9dba:	0f be       	out	0x3f, r0	; 63
    9dbc:	ed bf       	out	0x3d, r30	; 61
    9dbe:	31 96       	adiw	r30, 0x01	; 1
    9dc0:	ad b7       	in	r26, 0x3d	; 61
    9dc2:	be b7       	in	r27, 0x3e	; 62
    9dc4:	12 96       	adiw	r26, 0x02	; 2
    9dc6:	7c 92       	st	X, r7
    9dc8:	6e 92       	st	-X, r6
    9dca:	11 97       	sbiw	r26, 0x01	; 1
    9dcc:	53 82       	std	Z+3, r5	; 0x03
    9dce:	42 82       	std	Z+2, r4	; 0x02
    9dd0:	69 96       	adiw	r28, 0x19	; 25
    9dd2:	d5 83       	std	Z+5, r29	; 0x05
    9dd4:	c4 83       	std	Z+4, r28	; 0x04
    9dd6:	69 97       	sbiw	r28, 0x19	; 25
    9dd8:	d7 82       	std	Z+7, r13	; 0x07
    9dda:	c6 82       	std	Z+6, r12	; 0x06
    9ddc:	80 87       	std	Z+8, r24	; 0x08
    9dde:	11 86       	std	Z+9, r1	; 0x09
    9de0:	33 87       	std	Z+11, r19	; 0x0b
    9de2:	22 87       	std	Z+10, r18	; 0x0a
    9de4:	94 87       	std	Z+12, r25	; 0x0c
    9de6:	15 86       	std	Z+13, r1	; 0x0d
    9de8:	0e 94 88 5d 	call	0xbb10	; 0xbb10 <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
    9dec:	ed b7       	in	r30, 0x3d	; 61
    9dee:	fe b7       	in	r31, 0x3e	; 62
    9df0:	3e 96       	adiw	r30, 0x0e	; 14
    9df2:	0f b6       	in	r0, 0x3f	; 63
    9df4:	f8 94       	cli
    9df6:	fe bf       	out	0x3e, r31	; 62
    9df8:	0f be       	out	0x3f, r0	; 63
    9dfa:	ed bf       	out	0x3d, r30	; 61
    9dfc:	c4 01       	movw	r24, r8
    9dfe:	b3 01       	movw	r22, r6
    9e00:	0e 94 66 5c 	call	0xb8cc	; 0xb8cc <strcat>

		} while( pxNextTCB != pxFirstTCB );
    9e04:	ca 15       	cp	r28, r10
    9e06:	db 05       	cpc	r29, r11
    9e08:	09 f0       	breq	.+2      	; 0x9e0c <prvListTaskWithinSingleList+0x132>
    9e0a:	a8 cf       	rjmp	.-176    	; 0x9d5c <prvListTaskWithinSingleList+0x82>
	}
    9e0c:	df 91       	pop	r29
    9e0e:	cf 91       	pop	r28
    9e10:	1f 91       	pop	r17
    9e12:	0f 91       	pop	r16
    9e14:	ff 90       	pop	r15
    9e16:	ef 90       	pop	r14
    9e18:	df 90       	pop	r13
    9e1a:	cf 90       	pop	r12
    9e1c:	bf 90       	pop	r11
    9e1e:	af 90       	pop	r10
    9e20:	9f 90       	pop	r9
    9e22:	8f 90       	pop	r8
    9e24:	7f 90       	pop	r7
    9e26:	6f 90       	pop	r6
    9e28:	5f 90       	pop	r5
    9e2a:	4f 90       	pop	r4
    9e2c:	08 95       	ret

00009e2e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    9e2e:	cf 92       	push	r12
    9e30:	df 92       	push	r13
    9e32:	ff 92       	push	r15
    9e34:	0f 93       	push	r16
    9e36:	1f 93       	push	r17
    9e38:	df 93       	push	r29
    9e3a:	cf 93       	push	r28
    9e3c:	0f 92       	push	r0
    9e3e:	cd b7       	in	r28, 0x3d	; 61
    9e40:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    9e42:	0f b6       	in	r0, 0x3f	; 63
    9e44:	f8 94       	cli
    9e46:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    9e48:	80 91 99 01 	lds	r24, 0x0199
    9e4c:	81 50       	subi	r24, 0x01	; 1
    9e4e:	80 93 99 01 	sts	0x0199, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9e52:	80 91 99 01 	lds	r24, 0x0199
    9e56:	88 23       	and	r24, r24
    9e58:	09 f0       	breq	.+2      	; 0x9e5c <xTaskResumeAll+0x2e>
    9e5a:	5a c0       	rjmp	.+180    	; 0x9f10 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    9e5c:	80 91 9e 01 	lds	r24, 0x019E
    9e60:	88 23       	and	r24, r24
    9e62:	09 f4       	brne	.+2      	; 0x9e66 <xTaskResumeAll+0x38>
    9e64:	55 c0       	rjmp	.+170    	; 0x9f10 <xTaskResumeAll+0xe2>
    9e66:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    9e68:	69 e0       	ldi	r22, 0x09	; 9
    9e6a:	f6 2e       	mov	r15, r22
    9e6c:	27 c0       	rjmp	.+78     	; 0x9ebc <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    9e6e:	c6 01       	movw	r24, r12
    9e70:	0c 96       	adiw	r24, 0x0c	; 12
    9e72:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    9e76:	86 01       	movw	r16, r12
    9e78:	0e 5f       	subi	r16, 0xFE	; 254
    9e7a:	1f 4f       	sbci	r17, 0xFF	; 255
    9e7c:	c8 01       	movw	r24, r16
    9e7e:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    9e82:	d6 01       	movw	r26, r12
    9e84:	56 96       	adiw	r26, 0x16	; 22
    9e86:	9c 91       	ld	r25, X
    9e88:	80 91 9a 01 	lds	r24, 0x019A
    9e8c:	89 17       	cp	r24, r25
    9e8e:	10 f4       	brcc	.+4      	; 0x9e94 <xTaskResumeAll+0x66>
    9e90:	90 93 9a 01 	sts	0x019A, r25
    9e94:	9f 9d       	mul	r25, r15
    9e96:	c0 01       	movw	r24, r0
    9e98:	11 24       	eor	r1, r1
    9e9a:	8f 55       	subi	r24, 0x5F	; 95
    9e9c:	9e 4f       	sbci	r25, 0xFE	; 254
    9e9e:	b8 01       	movw	r22, r16
    9ea0:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9ea4:	e0 91 93 01 	lds	r30, 0x0193
    9ea8:	f0 91 94 01 	lds	r31, 0x0194
    9eac:	d6 01       	movw	r26, r12
    9eae:	56 96       	adiw	r26, 0x16	; 22
    9eb0:	9c 91       	ld	r25, X
    9eb2:	86 89       	ldd	r24, Z+22	; 0x16
    9eb4:	98 17       	cp	r25, r24
    9eb6:	10 f0       	brcs	.+4      	; 0x9ebc <xTaskResumeAll+0x8e>
    9eb8:	b1 e0       	ldi	r27, 0x01	; 1
    9eba:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    9ebc:	80 91 d2 01 	lds	r24, 0x01D2
    9ec0:	88 23       	and	r24, r24
    9ec2:	49 f0       	breq	.+18     	; 0x9ed6 <xTaskResumeAll+0xa8>
    9ec4:	e0 91 d7 01 	lds	r30, 0x01D7
    9ec8:	f0 91 d8 01 	lds	r31, 0x01D8
    9ecc:	c6 80       	ldd	r12, Z+6	; 0x06
    9ece:	d7 80       	ldd	r13, Z+7	; 0x07
    9ed0:	c1 14       	cp	r12, r1
    9ed2:	d1 04       	cpc	r13, r1
    9ed4:	61 f6       	brne	.-104    	; 0x9e6e <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    9ed6:	80 91 9c 01 	lds	r24, 0x019C
    9eda:	88 23       	and	r24, r24
    9edc:	41 f4       	brne	.+16     	; 0x9eee <xTaskResumeAll+0xc0>
    9ede:	0b c0       	rjmp	.+22     	; 0x9ef6 <xTaskResumeAll+0xc8>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    9ee0:	0e 94 ef 4d 	call	0x9bde	; 0x9bde <vTaskIncrementTick>
						--uxMissedTicks;
    9ee4:	80 91 9c 01 	lds	r24, 0x019C
    9ee8:	81 50       	subi	r24, 0x01	; 1
    9eea:	80 93 9c 01 	sts	0x019C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    9eee:	80 91 9c 01 	lds	r24, 0x019C
    9ef2:	88 23       	and	r24, r24
    9ef4:	a9 f7       	brne	.-22     	; 0x9ee0 <xTaskResumeAll+0xb2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    9ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    9ef8:	e1 30       	cpi	r30, 0x01	; 1
    9efa:	21 f0       	breq	.+8      	; 0x9f04 <xTaskResumeAll+0xd6>
    9efc:	80 91 95 01 	lds	r24, 0x0195
    9f00:	81 30       	cpi	r24, 0x01	; 1
    9f02:	31 f4       	brne	.+12     	; 0x9f10 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    9f04:	10 92 95 01 	sts	0x0195, r1
					portYIELD_WITHIN_API();
    9f08:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
    9f0c:	81 e0       	ldi	r24, 0x01	; 1
    9f0e:	01 c0       	rjmp	.+2      	; 0x9f12 <xTaskResumeAll+0xe4>
    9f10:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    9f12:	0f 90       	pop	r0
    9f14:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    9f16:	0f 90       	pop	r0
    9f18:	cf 91       	pop	r28
    9f1a:	df 91       	pop	r29
    9f1c:	1f 91       	pop	r17
    9f1e:	0f 91       	pop	r16
    9f20:	ff 90       	pop	r15
    9f22:	df 90       	pop	r13
    9f24:	cf 90       	pop	r12
    9f26:	08 95       	ret

00009f28 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
    9f28:	0f 93       	push	r16
    9f2a:	1f 93       	push	r17
    9f2c:	cf 93       	push	r28
    9f2e:	df 93       	push	r29
    9f30:	ec 01       	movw	r28, r24

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    9f32:	80 91 99 01 	lds	r24, 0x0199
    9f36:	8f 5f       	subi	r24, 0xFF	; 255
    9f38:	80 93 99 01 	sts	0x0199, r24
		vTaskSuspendAll();
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
    9f3c:	18 82       	st	Y, r1
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
    9f3e:	ce 01       	movw	r24, r28
    9f40:	69 e7       	ldi	r22, 0x79	; 121
    9f42:	71 e0       	ldi	r23, 0x01	; 1
    9f44:	0e 94 66 5c 	call	0xb8cc	; 0xb8cc <strcat>

			uxQueue = uxTopUsedPriority + 1;
    9f48:	10 91 9d 01 	lds	r17, 0x019D
    9f4c:	1f 5f       	subi	r17, 0xFF	; 255

			do
			{
				uxQueue--;

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    9f4e:	09 e0       	ldi	r16, 0x09	; 9

			uxQueue = uxTopUsedPriority + 1;

			do
			{
				uxQueue--;
    9f50:	11 50       	subi	r17, 0x01	; 1

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    9f52:	10 9f       	mul	r17, r16
    9f54:	f0 01       	movw	r30, r0
    9f56:	11 24       	eor	r1, r1
    9f58:	ef 55       	subi	r30, 0x5F	; 95
    9f5a:	fe 4f       	sbci	r31, 0xFE	; 254
    9f5c:	80 81       	ld	r24, Z
    9f5e:	88 23       	and	r24, r24
    9f60:	29 f0       	breq	.+10     	; 0x9f6c <vTaskList+0x44>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
    9f62:	ce 01       	movw	r24, r28
    9f64:	bf 01       	movw	r22, r30
    9f66:	42 e5       	ldi	r20, 0x52	; 82
    9f68:	0e 94 6d 4e 	call	0x9cda	; 0x9cda <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
    9f6c:	11 23       	and	r17, r17
    9f6e:	81 f7       	brne	.-32     	; 0x9f50 <vTaskList+0x28>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
    9f70:	e0 91 ce 01 	lds	r30, 0x01CE
    9f74:	f0 91 cf 01 	lds	r31, 0x01CF
    9f78:	80 81       	ld	r24, Z
    9f7a:	88 23       	and	r24, r24
    9f7c:	41 f0       	breq	.+16     	; 0x9f8e <vTaskList+0x66>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
    9f7e:	60 91 ce 01 	lds	r22, 0x01CE
    9f82:	70 91 cf 01 	lds	r23, 0x01CF
    9f86:	ce 01       	movw	r24, r28
    9f88:	42 e4       	ldi	r20, 0x42	; 66
    9f8a:	0e 94 6d 4e 	call	0x9cda	; 0x9cda <prvListTaskWithinSingleList>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
    9f8e:	e0 91 d0 01 	lds	r30, 0x01D0
    9f92:	f0 91 d1 01 	lds	r31, 0x01D1
    9f96:	80 81       	ld	r24, Z
    9f98:	88 23       	and	r24, r24
    9f9a:	41 f0       	breq	.+16     	; 0x9fac <vTaskList+0x84>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
    9f9c:	60 91 d0 01 	lds	r22, 0x01D0
    9fa0:	70 91 d1 01 	lds	r23, 0x01D1
    9fa4:	ce 01       	movw	r24, r28
    9fa6:	42 e4       	ldi	r20, 0x42	; 66
    9fa8:	0e 94 6d 4e 	call	0x9cda	; 0x9cda <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
    9fac:	80 91 db 01 	lds	r24, 0x01DB
    9fb0:	88 23       	and	r24, r24
    9fb2:	31 f0       	breq	.+12     	; 0x9fc0 <vTaskList+0x98>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
    9fb4:	ce 01       	movw	r24, r28
    9fb6:	6b ed       	ldi	r22, 0xDB	; 219
    9fb8:	71 e0       	ldi	r23, 0x01	; 1
    9fba:	43 e5       	ldi	r20, 0x53	; 83
    9fbc:	0e 94 6d 4e 	call	0x9cda	; 0x9cda <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
    9fc0:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
	}
    9fc4:	df 91       	pop	r29
    9fc6:	cf 91       	pop	r28
    9fc8:	1f 91       	pop	r17
    9fca:	0f 91       	pop	r16
    9fcc:	08 95       	ret

00009fce <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    9fce:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
    9fd2:	fd cf       	rjmp	.-6      	; 0x9fce <prvIdleTask>

00009fd4 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    9fd4:	0f 93       	push	r16
    9fd6:	1f 93       	push	r17
    9fd8:	cf 93       	push	r28
    9fda:	df 93       	push	r29
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    9fdc:	ec 01       	movw	r28, r24

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    9fde:	00 97       	sbiw	r24, 0x00	; 0
    9fe0:	09 f4       	brne	.+2      	; 0x9fe4 <vTaskResume+0x10>
    9fe2:	3c c0       	rjmp	.+120    	; 0xa05c <vTaskResume+0x88>
    9fe4:	80 91 93 01 	lds	r24, 0x0193
    9fe8:	90 91 94 01 	lds	r25, 0x0194
    9fec:	c8 17       	cp	r28, r24
    9fee:	d9 07       	cpc	r29, r25
    9ff0:	a9 f1       	breq	.+106    	; 0xa05c <vTaskResume+0x88>
		{
			portENTER_CRITICAL();
    9ff2:	0f b6       	in	r0, 0x3f	; 63
    9ff4:	f8 94       	cli
    9ff6:	0f 92       	push	r0
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    9ff8:	8a 85       	ldd	r24, Y+10	; 0x0a
    9ffa:	9b 85       	ldd	r25, Y+11	; 0x0b
    9ffc:	8b 5d       	subi	r24, 0xDB	; 219
    9ffe:	91 40       	sbci	r25, 0x01	; 1
    a000:	f1 f4       	brne	.+60     	; 0xa03e <vTaskResume+0x6a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    a002:	8c 89       	ldd	r24, Y+20	; 0x14
    a004:	9d 89       	ldd	r25, Y+21	; 0x15
    a006:	21 e0       	ldi	r18, 0x01	; 1
    a008:	82 3d       	cpi	r24, 0xD2	; 210
    a00a:	92 07       	cpc	r25, r18
    a00c:	c1 f0       	breq	.+48     	; 0xa03e <vTaskResume+0x6a>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    a00e:	89 2b       	or	r24, r25
    a010:	b1 f4       	brne	.+44     	; 0xa03e <vTaskResume+0x6a>
    a012:	18 c0       	rjmp	.+48     	; 0xa044 <vTaskResume+0x70>
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    a014:	90 93 9a 01 	sts	0x019A, r25
    a018:	89 e0       	ldi	r24, 0x09	; 9
    a01a:	98 9f       	mul	r25, r24
    a01c:	c0 01       	movw	r24, r0
    a01e:	11 24       	eor	r1, r1
    a020:	8f 55       	subi	r24, 0x5F	; 95
    a022:	9e 4f       	sbci	r25, 0xFE	; 254
    a024:	b8 01       	movw	r22, r16
    a026:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    a02a:	e0 91 93 01 	lds	r30, 0x0193
    a02e:	f0 91 94 01 	lds	r31, 0x0194
    a032:	9e 89       	ldd	r25, Y+22	; 0x16
    a034:	86 89       	ldd	r24, Z+22	; 0x16
    a036:	98 17       	cp	r25, r24
    a038:	10 f0       	brcs	.+4      	; 0xa03e <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    a03a:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    a03e:	0f 90       	pop	r0
    a040:	0f be       	out	0x3f, r0	; 63
    a042:	0c c0       	rjmp	.+24     	; 0xa05c <vTaskResume+0x88>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    a044:	8e 01       	movw	r16, r28
    a046:	0e 5f       	subi	r16, 0xFE	; 254
    a048:	1f 4f       	sbci	r17, 0xFF	; 255
    a04a:	c8 01       	movw	r24, r16
    a04c:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    a050:	9e 89       	ldd	r25, Y+22	; 0x16
    a052:	80 91 9a 01 	lds	r24, 0x019A
    a056:	89 17       	cp	r24, r25
    a058:	e8 f2       	brcs	.-70     	; 0xa014 <vTaskResume+0x40>
    a05a:	de cf       	rjmp	.-68     	; 0xa018 <vTaskResume+0x44>
					}
				}
			}
			portEXIT_CRITICAL();
		}
	}
    a05c:	df 91       	pop	r29
    a05e:	cf 91       	pop	r28
    a060:	1f 91       	pop	r17
    a062:	0f 91       	pop	r16
    a064:	08 95       	ret

0000a066 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    a066:	ef 92       	push	r14
    a068:	ff 92       	push	r15
    a06a:	0f 93       	push	r16
    a06c:	1f 93       	push	r17
    a06e:	cf 93       	push	r28
    a070:	df 93       	push	r29
    a072:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    a074:	0f b6       	in	r0, 0x3f	; 63
    a076:	f8 94       	cli
    a078:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    a07a:	80 91 93 01 	lds	r24, 0x0193
    a07e:	90 91 94 01 	lds	r25, 0x0194
    a082:	08 17       	cp	r16, r24
    a084:	19 07       	cpc	r17, r25
    a086:	19 f4       	brne	.+6      	; 0xa08e <vTaskSuspend+0x28>
    a088:	00 e0       	ldi	r16, 0x00	; 0
    a08a:	10 e0       	ldi	r17, 0x00	; 0
    a08c:	03 c0       	rjmp	.+6      	; 0xa094 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    a08e:	01 15       	cp	r16, r1
    a090:	11 05       	cpc	r17, r1
    a092:	29 f4       	brne	.+10     	; 0xa09e <vTaskSuspend+0x38>
    a094:	c0 91 93 01 	lds	r28, 0x0193
    a098:	d0 91 94 01 	lds	r29, 0x0194
    a09c:	01 c0       	rjmp	.+2      	; 0xa0a0 <vTaskSuspend+0x3a>
    a09e:	e8 01       	movw	r28, r16

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    a0a0:	72 e0       	ldi	r23, 0x02	; 2
    a0a2:	e7 2e       	mov	r14, r23
    a0a4:	f1 2c       	mov	r15, r1
    a0a6:	ec 0e       	add	r14, r28
    a0a8:	fd 1e       	adc	r15, r29
    a0aa:	c7 01       	movw	r24, r14
    a0ac:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    a0b0:	8c 89       	ldd	r24, Y+20	; 0x14
    a0b2:	9d 89       	ldd	r25, Y+21	; 0x15
    a0b4:	89 2b       	or	r24, r25
    a0b6:	21 f0       	breq	.+8      	; 0xa0c0 <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    a0b8:	ce 01       	movw	r24, r28
    a0ba:	0c 96       	adiw	r24, 0x0c	; 12
    a0bc:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    a0c0:	8b ed       	ldi	r24, 0xDB	; 219
    a0c2:	91 e0       	ldi	r25, 0x01	; 1
    a0c4:	b7 01       	movw	r22, r14
    a0c6:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    a0ca:	0f 90       	pop	r0
    a0cc:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    a0ce:	01 2b       	or	r16, r17
    a0d0:	11 f4       	brne	.+4      	; 0xa0d6 <vTaskSuspend+0x70>
		{
			portYIELD_WITHIN_API();
    a0d2:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
		}
	}
    a0d6:	df 91       	pop	r29
    a0d8:	cf 91       	pop	r28
    a0da:	1f 91       	pop	r17
    a0dc:	0f 91       	pop	r16
    a0de:	ff 90       	pop	r15
    a0e0:	ef 90       	pop	r14
    a0e2:	08 95       	ret

0000a0e4 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    a0e4:	ef 92       	push	r14
    a0e6:	ff 92       	push	r15
    a0e8:	0f 93       	push	r16
    a0ea:	1f 93       	push	r17
    a0ec:	df 93       	push	r29
    a0ee:	cf 93       	push	r28
    a0f0:	0f 92       	push	r0
    a0f2:	cd b7       	in	r28, 0x3d	; 61
    a0f4:	de b7       	in	r29, 0x3e	; 62
    a0f6:	9c 01       	movw	r18, r24
    a0f8:	63 30       	cpi	r22, 0x03	; 3
    a0fa:	08 f0       	brcs	.+2      	; 0xa0fe <vTaskPrioritySet+0x1a>
    a0fc:	62 e0       	ldi	r22, 0x02	; 2
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		portENTER_CRITICAL();
    a0fe:	0f b6       	in	r0, 0x3f	; 63
    a100:	f8 94       	cli
    a102:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    a104:	80 91 93 01 	lds	r24, 0x0193
    a108:	90 91 94 01 	lds	r25, 0x0194
    a10c:	28 17       	cp	r18, r24
    a10e:	39 07       	cpc	r19, r25
    a110:	19 f4       	brne	.+6      	; 0xa118 <vTaskPrioritySet+0x34>
    a112:	20 e0       	ldi	r18, 0x00	; 0
    a114:	30 e0       	ldi	r19, 0x00	; 0
    a116:	03 c0       	rjmp	.+6      	; 0xa11e <vTaskPrioritySet+0x3a>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    a118:	21 15       	cp	r18, r1
    a11a:	31 05       	cpc	r19, r1
    a11c:	29 f4       	brne	.+10     	; 0xa128 <vTaskPrioritySet+0x44>
    a11e:	e0 90 93 01 	lds	r14, 0x0193
    a122:	f0 90 94 01 	lds	r15, 0x0194
    a126:	01 c0       	rjmp	.+2      	; 0xa12a <vTaskPrioritySet+0x46>
    a128:	79 01       	movw	r14, r18
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    a12a:	f7 01       	movw	r30, r14
    a12c:	46 89       	ldd	r20, Z+22	; 0x16
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    a12e:	46 17       	cp	r20, r22
    a130:	e1 f1       	breq	.+120    	; 0xa1aa <vTaskPrioritySet+0xc6>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    a132:	46 17       	cp	r20, r22
    a134:	30 f4       	brcc	.+12     	; 0xa142 <vTaskPrioritySet+0x5e>
    a136:	19 82       	std	Y+1, r1	; 0x01
    a138:	23 2b       	or	r18, r19
    a13a:	41 f0       	breq	.+16     	; 0xa14c <vTaskPrioritySet+0x68>
    a13c:	f1 e0       	ldi	r31, 0x01	; 1
    a13e:	f9 83       	std	Y+1, r31	; 0x01
    a140:	05 c0       	rjmp	.+10     	; 0xa14c <vTaskPrioritySet+0x68>
    a142:	19 82       	std	Y+1, r1	; 0x01
    a144:	23 2b       	or	r18, r19
    a146:	11 f4       	brne	.+4      	; 0xa14c <vTaskPrioritySet+0x68>
    a148:	81 e0       	ldi	r24, 0x01	; 1
    a14a:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    a14c:	f7 01       	movw	r30, r14
    a14e:	66 8b       	std	Z+22, r22	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    a150:	83 e0       	ldi	r24, 0x03	; 3
    a152:	90 e0       	ldi	r25, 0x00	; 0
    a154:	86 1b       	sub	r24, r22
    a156:	91 09       	sbc	r25, r1
    a158:	95 87       	std	Z+13, r25	; 0x0d
    a15a:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    a15c:	89 e0       	ldi	r24, 0x09	; 9
    a15e:	48 9f       	mul	r20, r24
    a160:	c0 01       	movw	r24, r0
    a162:	11 24       	eor	r1, r1
    a164:	8f 55       	subi	r24, 0x5F	; 95
    a166:	9e 4f       	sbci	r25, 0xFE	; 254
    a168:	22 85       	ldd	r18, Z+10	; 0x0a
    a16a:	33 85       	ldd	r19, Z+11	; 0x0b
    a16c:	28 17       	cp	r18, r24
    a16e:	39 07       	cpc	r19, r25
    a170:	b9 f4       	brne	.+46     	; 0xa1a0 <vTaskPrioritySet+0xbc>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    a172:	87 01       	movw	r16, r14
    a174:	0e 5f       	subi	r16, 0xFE	; 254
    a176:	1f 4f       	sbci	r17, 0xFF	; 255
    a178:	c8 01       	movw	r24, r16
    a17a:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    a17e:	f7 01       	movw	r30, r14
    a180:	96 89       	ldd	r25, Z+22	; 0x16
    a182:	80 91 9a 01 	lds	r24, 0x019A
    a186:	89 17       	cp	r24, r25
    a188:	10 f4       	brcc	.+4      	; 0xa18e <vTaskPrioritySet+0xaa>
    a18a:	90 93 9a 01 	sts	0x019A, r25
    a18e:	89 e0       	ldi	r24, 0x09	; 9
    a190:	98 9f       	mul	r25, r24
    a192:	c0 01       	movw	r24, r0
    a194:	11 24       	eor	r1, r1
    a196:	8f 55       	subi	r24, 0x5F	; 95
    a198:	9e 4f       	sbci	r25, 0xFE	; 254
    a19a:	b8 01       	movw	r22, r16
    a19c:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    a1a0:	f9 81       	ldd	r31, Y+1	; 0x01
    a1a2:	f1 30       	cpi	r31, 0x01	; 1
    a1a4:	11 f4       	brne	.+4      	; 0xa1aa <vTaskPrioritySet+0xc6>
				{
					portYIELD_WITHIN_API();
    a1a6:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
				}
			}
		}
		portEXIT_CRITICAL();
    a1aa:	0f 90       	pop	r0
    a1ac:	0f be       	out	0x3f, r0	; 63
	}
    a1ae:	0f 90       	pop	r0
    a1b0:	cf 91       	pop	r28
    a1b2:	df 91       	pop	r29
    a1b4:	1f 91       	pop	r17
    a1b6:	0f 91       	pop	r16
    a1b8:	ff 90       	pop	r15
    a1ba:	ef 90       	pop	r14
    a1bc:	08 95       	ret

0000a1be <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    a1be:	0f 93       	push	r16
    a1c0:	1f 93       	push	r17
    a1c2:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    a1c4:	00 97       	sbiw	r24, 0x00	; 0
    a1c6:	a1 f1       	breq	.+104    	; 0xa230 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    a1c8:	80 91 99 01 	lds	r24, 0x0199
    a1cc:	8f 5f       	subi	r24, 0xFF	; 255
    a1ce:	80 93 99 01 	sts	0x0199, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    a1d2:	00 91 97 01 	lds	r16, 0x0197
    a1d6:	10 91 98 01 	lds	r17, 0x0198
    a1da:	02 0f       	add	r16, r18
    a1dc:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    a1de:	80 91 93 01 	lds	r24, 0x0193
    a1e2:	90 91 94 01 	lds	r25, 0x0194
    a1e6:	02 96       	adiw	r24, 0x02	; 2
    a1e8:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    a1ec:	e0 91 93 01 	lds	r30, 0x0193
    a1f0:	f0 91 94 01 	lds	r31, 0x0194
    a1f4:	13 83       	std	Z+3, r17	; 0x03
    a1f6:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    a1f8:	80 91 97 01 	lds	r24, 0x0197
    a1fc:	90 91 98 01 	lds	r25, 0x0198
    a200:	08 17       	cp	r16, r24
    a202:	19 07       	cpc	r17, r25
    a204:	28 f4       	brcc	.+10     	; 0xa210 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    a206:	80 91 d0 01 	lds	r24, 0x01D0
    a20a:	90 91 d1 01 	lds	r25, 0x01D1
    a20e:	04 c0       	rjmp	.+8      	; 0xa218 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    a210:	80 91 ce 01 	lds	r24, 0x01CE
    a214:	90 91 cf 01 	lds	r25, 0x01CF
    a218:	60 91 93 01 	lds	r22, 0x0193
    a21c:	70 91 94 01 	lds	r23, 0x0194
    a220:	6e 5f       	subi	r22, 0xFE	; 254
    a222:	7f 4f       	sbci	r23, 0xFF	; 255
    a224:	0e 94 38 56 	call	0xac70	; 0xac70 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    a228:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    a22c:	88 23       	and	r24, r24
    a22e:	11 f4       	brne	.+4      	; 0xa234 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    a230:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
		}
	}
    a234:	1f 91       	pop	r17
    a236:	0f 91       	pop	r16
    a238:	08 95       	ret

0000a23a <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    a23a:	cf 93       	push	r28
    a23c:	df 93       	push	r29
    a23e:	fc 01       	movw	r30, r24
    a240:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    a242:	80 91 99 01 	lds	r24, 0x0199
    a246:	8f 5f       	subi	r24, 0xFF	; 255
    a248:	80 93 99 01 	sts	0x0199, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    a24c:	20 81       	ld	r18, Z
    a24e:	31 81       	ldd	r19, Z+1	; 0x01
    a250:	c2 0f       	add	r28, r18
    a252:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    a254:	80 91 97 01 	lds	r24, 0x0197
    a258:	90 91 98 01 	lds	r25, 0x0198
    a25c:	82 17       	cp	r24, r18
    a25e:	93 07       	cpc	r25, r19
    a260:	28 f4       	brcc	.+10     	; 0xa26c <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    a262:	c2 17       	cp	r28, r18
    a264:	d3 07       	cpc	r29, r19
    a266:	28 f0       	brcs	.+10     	; 0xa272 <vTaskDelayUntil+0x38>
    a268:	20 e0       	ldi	r18, 0x00	; 0
    a26a:	0c c0       	rjmp	.+24     	; 0xa284 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    a26c:	c2 17       	cp	r28, r18
    a26e:	d3 07       	cpc	r29, r19
    a270:	40 f0       	brcs	.+16     	; 0xa282 <vTaskDelayUntil+0x48>
    a272:	80 91 97 01 	lds	r24, 0x0197
    a276:	90 91 98 01 	lds	r25, 0x0198
    a27a:	20 e0       	ldi	r18, 0x00	; 0
    a27c:	8c 17       	cp	r24, r28
    a27e:	9d 07       	cpc	r25, r29
    a280:	08 f4       	brcc	.+2      	; 0xa284 <vTaskDelayUntil+0x4a>
    a282:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    a284:	d1 83       	std	Z+1, r29	; 0x01
    a286:	c0 83       	st	Z, r28

			if( xShouldDelay )
    a288:	22 23       	and	r18, r18
    a28a:	29 f1       	breq	.+74     	; 0xa2d6 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    a28c:	80 91 93 01 	lds	r24, 0x0193
    a290:	90 91 94 01 	lds	r25, 0x0194
    a294:	02 96       	adiw	r24, 0x02	; 2
    a296:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    a29a:	e0 91 93 01 	lds	r30, 0x0193
    a29e:	f0 91 94 01 	lds	r31, 0x0194
    a2a2:	d3 83       	std	Z+3, r29	; 0x03
    a2a4:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    a2a6:	80 91 97 01 	lds	r24, 0x0197
    a2aa:	90 91 98 01 	lds	r25, 0x0198
    a2ae:	c8 17       	cp	r28, r24
    a2b0:	d9 07       	cpc	r29, r25
    a2b2:	28 f4       	brcc	.+10     	; 0xa2be <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    a2b4:	80 91 d0 01 	lds	r24, 0x01D0
    a2b8:	90 91 d1 01 	lds	r25, 0x01D1
    a2bc:	04 c0       	rjmp	.+8      	; 0xa2c6 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    a2be:	80 91 ce 01 	lds	r24, 0x01CE
    a2c2:	90 91 cf 01 	lds	r25, 0x01CF
    a2c6:	60 91 93 01 	lds	r22, 0x0193
    a2ca:	70 91 94 01 	lds	r23, 0x0194
    a2ce:	6e 5f       	subi	r22, 0xFE	; 254
    a2d0:	7f 4f       	sbci	r23, 0xFF	; 255
    a2d2:	0e 94 38 56 	call	0xac70	; 0xac70 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    a2d6:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    a2da:	88 23       	and	r24, r24
    a2dc:	11 f4       	brne	.+4      	; 0xa2e2 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    a2de:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
		}
	}
    a2e2:	df 91       	pop	r29
    a2e4:	cf 91       	pop	r28
    a2e6:	08 95       	ret

0000a2e8 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    a2e8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    a2ea:	10 92 9f 01 	sts	0x019F, r1
	vPortEndScheduler();
    a2ee:	0e 94 06 59 	call	0xb20c	; 0xb20c <vPortEndScheduler>
}
    a2f2:	08 95       	ret

0000a2f4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    a2f4:	2f 92       	push	r2
    a2f6:	3f 92       	push	r3
    a2f8:	4f 92       	push	r4
    a2fa:	5f 92       	push	r5
    a2fc:	7f 92       	push	r7
    a2fe:	8f 92       	push	r8
    a300:	9f 92       	push	r9
    a302:	af 92       	push	r10
    a304:	bf 92       	push	r11
    a306:	cf 92       	push	r12
    a308:	df 92       	push	r13
    a30a:	ef 92       	push	r14
    a30c:	ff 92       	push	r15
    a30e:	0f 93       	push	r16
    a310:	1f 93       	push	r17
    a312:	df 93       	push	r29
    a314:	cf 93       	push	r28
    a316:	00 d0       	rcall	.+0      	; 0xa318 <xTaskGenericCreate+0x24>
    a318:	00 d0       	rcall	.+0      	; 0xa31a <xTaskGenericCreate+0x26>
    a31a:	cd b7       	in	r28, 0x3d	; 61
    a31c:	de b7       	in	r29, 0x3e	; 62
    a31e:	1c 01       	movw	r2, r24
    a320:	4b 01       	movw	r8, r22
    a322:	5a 01       	movw	r10, r20
    a324:	29 01       	movw	r4, r18
    a326:	70 2e       	mov	r7, r16
    a328:	fa 82       	std	Y+2, r15	; 0x02
    a32a:	e9 82       	std	Y+1, r14	; 0x01
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    a32c:	84 e2       	ldi	r24, 0x24	; 36
    a32e:	90 e0       	ldi	r25, 0x00	; 0
    a330:	0e 94 61 58 	call	0xb0c2	; 0xb0c2 <pvPortMalloc>
    a334:	8b 83       	std	Y+3, r24	; 0x03
    a336:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    a338:	8b 81       	ldd	r24, Y+3	; 0x03
    a33a:	9c 81       	ldd	r25, Y+4	; 0x04
    a33c:	89 2b       	or	r24, r25
    a33e:	89 f0       	breq	.+34     	; 0xa362 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    a340:	c1 14       	cp	r12, r1
    a342:	d1 04       	cpc	r13, r1
    a344:	21 f4       	brne	.+8      	; 0xa34e <xTaskGenericCreate+0x5a>
    a346:	c5 01       	movw	r24, r10
    a348:	0e 94 61 58 	call	0xb0c2	; 0xb0c2 <pvPortMalloc>
    a34c:	6c 01       	movw	r12, r24
    a34e:	eb 81       	ldd	r30, Y+3	; 0x03
    a350:	fc 81       	ldd	r31, Y+4	; 0x04
    a352:	d0 8e       	std	Z+24, r13	; 0x18
    a354:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    a356:	c1 14       	cp	r12, r1
    a358:	d1 04       	cpc	r13, r1
    a35a:	29 f4       	brne	.+10     	; 0xa366 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    a35c:	cf 01       	movw	r24, r30
    a35e:	0e 94 51 58 	call	0xb0a2	; 0xb0a2 <vPortFree>
    a362:	8f ef       	ldi	r24, 0xFF	; 255
    a364:	ce c0       	rjmp	.+412    	; 0xa502 <xTaskGenericCreate+0x20e>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    a366:	c6 01       	movw	r24, r12
    a368:	65 ea       	ldi	r22, 0xA5	; 165
    a36a:	70 e0       	ldi	r23, 0x00	; 0
    a36c:	a5 01       	movw	r20, r10
    a36e:	0e 94 5f 5c 	call	0xb8be	; 0xb8be <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    a372:	08 94       	sec
    a374:	a1 08       	sbc	r10, r1
    a376:	b1 08       	sbc	r11, r1
    a378:	eb 81       	ldd	r30, Y+3	; 0x03
    a37a:	fc 81       	ldd	r31, Y+4	; 0x04
    a37c:	e7 88       	ldd	r14, Z+23	; 0x17
    a37e:	f0 8c       	ldd	r15, Z+24	; 0x18
    a380:	ea 0c       	add	r14, r10
    a382:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    a384:	cf 01       	movw	r24, r30
    a386:	49 96       	adiw	r24, 0x19	; 25
    a388:	b4 01       	movw	r22, r8
    a38a:	4a e0       	ldi	r20, 0x0A	; 10
    a38c:	50 e0       	ldi	r21, 0x00	; 0
    a38e:	0e 94 86 5c 	call	0xb90c	; 0xb90c <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    a392:	eb 81       	ldd	r30, Y+3	; 0x03
    a394:	fc 81       	ldd	r31, Y+4	; 0x04
    a396:	12 a2       	std	Z+34, r1	; 0x22
    a398:	07 2d       	mov	r16, r7
    a39a:	f2 e0       	ldi	r31, 0x02	; 2
    a39c:	f7 15       	cp	r31, r7
    a39e:	08 f4       	brcc	.+2      	; 0xa3a2 <xTaskGenericCreate+0xae>
    a3a0:	02 e0       	ldi	r16, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    a3a2:	eb 81       	ldd	r30, Y+3	; 0x03
    a3a4:	fc 81       	ldd	r31, Y+4	; 0x04
    a3a6:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    a3a8:	a2 e0       	ldi	r26, 0x02	; 2
    a3aa:	ca 2e       	mov	r12, r26
    a3ac:	d1 2c       	mov	r13, r1
    a3ae:	ce 0e       	add	r12, r30
    a3b0:	df 1e       	adc	r13, r31
    a3b2:	c6 01       	movw	r24, r12
    a3b4:	0e 94 0b 56 	call	0xac16	; 0xac16 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    a3b8:	8b 81       	ldd	r24, Y+3	; 0x03
    a3ba:	9c 81       	ldd	r25, Y+4	; 0x04
    a3bc:	0c 96       	adiw	r24, 0x0c	; 12
    a3be:	0e 94 0b 56 	call	0xac16	; 0xac16 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    a3c2:	8b 81       	ldd	r24, Y+3	; 0x03
    a3c4:	9c 81       	ldd	r25, Y+4	; 0x04
    a3c6:	fc 01       	movw	r30, r24
    a3c8:	91 87       	std	Z+9, r25	; 0x09
    a3ca:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    a3cc:	83 e0       	ldi	r24, 0x03	; 3
    a3ce:	90 e0       	ldi	r25, 0x00	; 0
    a3d0:	80 1b       	sub	r24, r16
    a3d2:	91 09       	sbc	r25, r1
    a3d4:	95 87       	std	Z+13, r25	; 0x0d
    a3d6:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    a3d8:	f3 8b       	std	Z+19, r31	; 0x13
    a3da:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    a3dc:	c7 01       	movw	r24, r14
    a3de:	b1 01       	movw	r22, r2
    a3e0:	a2 01       	movw	r20, r4
    a3e2:	0e 94 88 58 	call	0xb110	; 0xb110 <pxPortInitialiseStack>
    a3e6:	eb 81       	ldd	r30, Y+3	; 0x03
    a3e8:	fc 81       	ldd	r31, Y+4	; 0x04
    a3ea:	91 83       	std	Z+1, r25	; 0x01
    a3ec:	80 83       	st	Z, r24
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    a3ee:	0f b6       	in	r0, 0x3f	; 63
    a3f0:	f8 94       	cli
    a3f2:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    a3f4:	80 91 9e 01 	lds	r24, 0x019E
    a3f8:	8f 5f       	subi	r24, 0xFF	; 255
    a3fa:	80 93 9e 01 	sts	0x019E, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    a3fe:	80 91 9e 01 	lds	r24, 0x019E
    a402:	81 30       	cpi	r24, 0x01	; 1
    a404:	69 f5       	brne	.+90     	; 0xa460 <xTaskGenericCreate+0x16c>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    a406:	f0 93 94 01 	sts	0x0194, r31
    a40a:	e0 93 93 01 	sts	0x0193, r30
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    a40e:	81 ea       	ldi	r24, 0xA1	; 161
    a410:	91 e0       	ldi	r25, 0x01	; 1
    a412:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
    a416:	8a ea       	ldi	r24, 0xAA	; 170
    a418:	91 e0       	ldi	r25, 0x01	; 1
    a41a:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
    a41e:	83 eb       	ldi	r24, 0xB3	; 179
    a420:	91 e0       	ldi	r25, 0x01	; 1
    a422:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    a426:	ec eb       	ldi	r30, 0xBC	; 188
    a428:	ee 2e       	mov	r14, r30
    a42a:	e1 e0       	ldi	r30, 0x01	; 1
    a42c:	fe 2e       	mov	r15, r30
    a42e:	c7 01       	movw	r24, r14
    a430:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    a434:	05 ec       	ldi	r16, 0xC5	; 197
    a436:	11 e0       	ldi	r17, 0x01	; 1
    a438:	c8 01       	movw	r24, r16
    a43a:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    a43e:	82 ed       	ldi	r24, 0xD2	; 210
    a440:	91 e0       	ldi	r25, 0x01	; 1
    a442:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    a446:	8b ed       	ldi	r24, 0xDB	; 219
    a448:	91 e0       	ldi	r25, 0x01	; 1
    a44a:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    a44e:	f0 92 cf 01 	sts	0x01CF, r15
    a452:	e0 92 ce 01 	sts	0x01CE, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    a456:	10 93 d1 01 	sts	0x01D1, r17
    a45a:	00 93 d0 01 	sts	0x01D0, r16
    a45e:	11 c0       	rjmp	.+34     	; 0xa482 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    a460:	80 91 9f 01 	lds	r24, 0x019F
    a464:	88 23       	and	r24, r24
    a466:	69 f4       	brne	.+26     	; 0xa482 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    a468:	e0 91 93 01 	lds	r30, 0x0193
    a46c:	f0 91 94 01 	lds	r31, 0x0194
    a470:	86 89       	ldd	r24, Z+22	; 0x16
    a472:	78 16       	cp	r7, r24
    a474:	30 f0       	brcs	.+12     	; 0xa482 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    a476:	8b 81       	ldd	r24, Y+3	; 0x03
    a478:	9c 81       	ldd	r25, Y+4	; 0x04
    a47a:	90 93 94 01 	sts	0x0194, r25
    a47e:	80 93 93 01 	sts	0x0193, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    a482:	eb 81       	ldd	r30, Y+3	; 0x03
    a484:	fc 81       	ldd	r31, Y+4	; 0x04
    a486:	96 89       	ldd	r25, Z+22	; 0x16
    a488:	80 91 9d 01 	lds	r24, 0x019D
    a48c:	89 17       	cp	r24, r25
    a48e:	10 f4       	brcc	.+4      	; 0xa494 <xTaskGenericCreate+0x1a0>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    a490:	90 93 9d 01 	sts	0x019D, r25
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    a494:	80 91 a0 01 	lds	r24, 0x01A0
    a498:	eb 81       	ldd	r30, Y+3	; 0x03
    a49a:	fc 81       	ldd	r31, Y+4	; 0x04
    a49c:	83 a3       	std	Z+35, r24	; 0x23
			}
			#endif
			uxTaskNumber++;
    a49e:	80 91 a0 01 	lds	r24, 0x01A0
    a4a2:	8f 5f       	subi	r24, 0xFF	; 255
    a4a4:	80 93 a0 01 	sts	0x01A0, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    a4a8:	96 89       	ldd	r25, Z+22	; 0x16
    a4aa:	80 91 9a 01 	lds	r24, 0x019A
    a4ae:	89 17       	cp	r24, r25
    a4b0:	10 f4       	brcc	.+4      	; 0xa4b6 <xTaskGenericCreate+0x1c2>
    a4b2:	90 93 9a 01 	sts	0x019A, r25
    a4b6:	eb 81       	ldd	r30, Y+3	; 0x03
    a4b8:	fc 81       	ldd	r31, Y+4	; 0x04
    a4ba:	86 89       	ldd	r24, Z+22	; 0x16
    a4bc:	29 e0       	ldi	r18, 0x09	; 9
    a4be:	82 9f       	mul	r24, r18
    a4c0:	c0 01       	movw	r24, r0
    a4c2:	11 24       	eor	r1, r1
    a4c4:	8f 55       	subi	r24, 0x5F	; 95
    a4c6:	9e 4f       	sbci	r25, 0xFE	; 254
    a4c8:	b6 01       	movw	r22, r12
    a4ca:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    a4ce:	0f 90       	pop	r0
    a4d0:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    a4d2:	89 81       	ldd	r24, Y+1	; 0x01
    a4d4:	9a 81       	ldd	r25, Y+2	; 0x02
    a4d6:	89 2b       	or	r24, r25
    a4d8:	31 f0       	breq	.+12     	; 0xa4e6 <xTaskGenericCreate+0x1f2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    a4da:	8b 81       	ldd	r24, Y+3	; 0x03
    a4dc:	9c 81       	ldd	r25, Y+4	; 0x04
    a4de:	e9 81       	ldd	r30, Y+1	; 0x01
    a4e0:	fa 81       	ldd	r31, Y+2	; 0x02
    a4e2:	91 83       	std	Z+1, r25	; 0x01
    a4e4:	80 83       	st	Z, r24
		}

		if( xSchedulerRunning != pdFALSE )
    a4e6:	80 91 9f 01 	lds	r24, 0x019F
    a4ea:	88 23       	and	r24, r24
    a4ec:	49 f0       	breq	.+18     	; 0xa500 <xTaskGenericCreate+0x20c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    a4ee:	e0 91 93 01 	lds	r30, 0x0193
    a4f2:	f0 91 94 01 	lds	r31, 0x0194
    a4f6:	86 89       	ldd	r24, Z+22	; 0x16
    a4f8:	87 15       	cp	r24, r7
    a4fa:	10 f4       	brcc	.+4      	; 0xa500 <xTaskGenericCreate+0x20c>
			{
				portYIELD_WITHIN_API();
    a4fc:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
    a500:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    a502:	0f 90       	pop	r0
    a504:	0f 90       	pop	r0
    a506:	0f 90       	pop	r0
    a508:	0f 90       	pop	r0
    a50a:	cf 91       	pop	r28
    a50c:	df 91       	pop	r29
    a50e:	1f 91       	pop	r17
    a510:	0f 91       	pop	r16
    a512:	ff 90       	pop	r15
    a514:	ef 90       	pop	r14
    a516:	df 90       	pop	r13
    a518:	cf 90       	pop	r12
    a51a:	bf 90       	pop	r11
    a51c:	af 90       	pop	r10
    a51e:	9f 90       	pop	r9
    a520:	8f 90       	pop	r8
    a522:	7f 90       	pop	r7
    a524:	5f 90       	pop	r5
    a526:	4f 90       	pop	r4
    a528:	3f 90       	pop	r3
    a52a:	2f 90       	pop	r2
    a52c:	08 95       	ret

0000a52e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    a52e:	af 92       	push	r10
    a530:	bf 92       	push	r11
    a532:	cf 92       	push	r12
    a534:	df 92       	push	r13
    a536:	ef 92       	push	r14
    a538:	ff 92       	push	r15
    a53a:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    a53c:	87 ee       	ldi	r24, 0xE7	; 231
    a53e:	9f e4       	ldi	r25, 0x4F	; 79
    a540:	6c e7       	ldi	r22, 0x7C	; 124
    a542:	71 e0       	ldi	r23, 0x01	; 1
    a544:	44 e6       	ldi	r20, 0x64	; 100
    a546:	50 e0       	ldi	r21, 0x00	; 0
    a548:	20 e0       	ldi	r18, 0x00	; 0
    a54a:	30 e0       	ldi	r19, 0x00	; 0
    a54c:	00 e0       	ldi	r16, 0x00	; 0
    a54e:	ee 24       	eor	r14, r14
    a550:	ff 24       	eor	r15, r15
    a552:	cc 24       	eor	r12, r12
    a554:	dd 24       	eor	r13, r13
    a556:	aa 24       	eor	r10, r10
    a558:	bb 24       	eor	r11, r11
    a55a:	0e 94 7a 51 	call	0xa2f4	; 0xa2f4 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    a55e:	81 30       	cpi	r24, 0x01	; 1
    a560:	49 f4       	brne	.+18     	; 0xa574 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    a562:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    a564:	80 93 9f 01 	sts	0x019F, r24
		xTickCount = ( portTickType ) 0;
    a568:	10 92 98 01 	sts	0x0198, r1
    a56c:	10 92 97 01 	sts	0x0197, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    a570:	0e 94 d0 58 	call	0xb1a0	; 0xb1a0 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    a574:	0f 91       	pop	r16
    a576:	ff 90       	pop	r15
    a578:	ef 90       	pop	r14
    a57a:	df 90       	pop	r13
    a57c:	cf 90       	pop	r12
    a57e:	bf 90       	pop	r11
    a580:	af 90       	pop	r10
    a582:	08 95       	ret

0000a584 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    a584:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    a586:	0f b6       	in	r0, 0x3f	; 63
    a588:	f8 94       	cli
    a58a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    a58c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    a58e:	0f 90       	pop	r0
    a590:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    a592:	08 95       	ret

0000a594 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    a594:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    a596:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    a598:	08 95       	ret

0000a59a <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    a59a:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    a59c:	82 8d       	ldd	r24, Z+26	; 0x1a
    a59e:	90 e0       	ldi	r25, 0x00	; 0
    a5a0:	88 23       	and	r24, r24
    a5a2:	09 f4       	brne	.+2      	; 0xa5a6 <xQueueIsQueueEmptyFromISR+0xc>
    a5a4:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    a5a6:	89 2f       	mov	r24, r25
    a5a8:	08 95       	ret

0000a5aa <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    a5aa:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    a5ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    a5ae:	20 e0       	ldi	r18, 0x00	; 0
    a5b0:	83 8d       	ldd	r24, Z+27	; 0x1b
    a5b2:	98 17       	cp	r25, r24
    a5b4:	09 f4       	brne	.+2      	; 0xa5b8 <xQueueIsQueueFullFromISR+0xe>
    a5b6:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    a5b8:	82 2f       	mov	r24, r18
    a5ba:	08 95       	ret

0000a5bc <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    a5bc:	0f 93       	push	r16
    a5be:	1f 93       	push	r17
    a5c0:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    a5c2:	fc 01       	movw	r30, r24
    a5c4:	80 81       	ld	r24, Z
    a5c6:	91 81       	ldd	r25, Z+1	; 0x01
    a5c8:	0e 94 51 58 	call	0xb0a2	; 0xb0a2 <vPortFree>
	vPortFree( pxQueue );
    a5cc:	c8 01       	movw	r24, r16
    a5ce:	0e 94 51 58 	call	0xb0a2	; 0xb0a2 <vPortFree>
}
    a5d2:	1f 91       	pop	r17
    a5d4:	0f 91       	pop	r16
    a5d6:	08 95       	ret

0000a5d8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    a5d8:	0f 93       	push	r16
    a5da:	1f 93       	push	r17
    a5dc:	cf 93       	push	r28
    a5de:	df 93       	push	r29
    a5e0:	ec 01       	movw	r28, r24
    a5e2:	fb 01       	movw	r30, r22
    a5e4:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    a5e6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    a5e8:	88 23       	and	r24, r24
    a5ea:	81 f1       	breq	.+96     	; 0xa64c <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    a5ec:	48 81       	ld	r20, Y
    a5ee:	59 81       	ldd	r21, Y+1	; 0x01
    a5f0:	41 15       	cp	r20, r1
    a5f2:	51 05       	cpc	r21, r1
    a5f4:	a9 f0       	breq	.+42     	; 0xa620 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    a5f6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    a5f8:	2e 81       	ldd	r18, Y+6	; 0x06
    a5fa:	3f 81       	ldd	r19, Y+7	; 0x07
    a5fc:	28 0f       	add	r18, r24
    a5fe:	31 1d       	adc	r19, r1
    a600:	3f 83       	std	Y+7, r19	; 0x07
    a602:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    a604:	8a 81       	ldd	r24, Y+2	; 0x02
    a606:	9b 81       	ldd	r25, Y+3	; 0x03
    a608:	28 17       	cp	r18, r24
    a60a:	39 07       	cpc	r19, r25
    a60c:	10 f0       	brcs	.+4      	; 0xa612 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    a60e:	5f 83       	std	Y+7, r21	; 0x07
    a610:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    a612:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a614:	6e 81       	ldd	r22, Y+6	; 0x06
    a616:	7f 81       	ldd	r23, Y+7	; 0x07
    a618:	cf 01       	movw	r24, r30
    a61a:	50 e0       	ldi	r21, 0x00	; 0
    a61c:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    a620:	8a 8d       	ldd	r24, Y+26	; 0x1a
    a622:	81 50       	subi	r24, 0x01	; 1
    a624:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    a626:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a628:	8f 3f       	cpi	r24, 0xFF	; 255
    a62a:	69 f4       	brne	.+26     	; 0xa646 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    a62c:	88 85       	ldd	r24, Y+8	; 0x08
    a62e:	88 23       	and	r24, r24
    a630:	61 f0       	breq	.+24     	; 0xa64a <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    a632:	ce 01       	movw	r24, r28
    a634:	08 96       	adiw	r24, 0x08	; 8
    a636:	0e 94 16 4d 	call	0x9a2c	; 0x9a2c <xTaskRemoveFromEventList>
    a63a:	88 23       	and	r24, r24
    a63c:	31 f0       	breq	.+12     	; 0xa64a <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    a63e:	81 e0       	ldi	r24, 0x01	; 1
    a640:	f8 01       	movw	r30, r16
    a642:	80 83       	st	Z, r24
    a644:	03 c0       	rjmp	.+6      	; 0xa64c <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    a646:	8f 5f       	subi	r24, 0xFF	; 255
    a648:	8d 8f       	std	Y+29, r24	; 0x1d
    a64a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    a64c:	df 91       	pop	r29
    a64e:	cf 91       	pop	r28
    a650:	1f 91       	pop	r17
    a652:	0f 91       	pop	r16
    a654:	08 95       	ret

0000a656 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    a656:	cf 93       	push	r28
    a658:	df 93       	push	r29
    a65a:	ec 01       	movw	r28, r24
    a65c:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    a65e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a660:	44 23       	and	r20, r20
    a662:	a1 f1       	breq	.+104    	; 0xa6cc <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    a664:	88 23       	and	r24, r24
    a666:	b1 f4       	brne	.+44     	; 0xa694 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    a668:	8c 81       	ldd	r24, Y+4	; 0x04
    a66a:	9d 81       	ldd	r25, Y+5	; 0x05
    a66c:	50 e0       	ldi	r21, 0x00	; 0
    a66e:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    a672:	8c 8d       	ldd	r24, Y+28	; 0x1c
    a674:	2c 81       	ldd	r18, Y+4	; 0x04
    a676:	3d 81       	ldd	r19, Y+5	; 0x05
    a678:	28 0f       	add	r18, r24
    a67a:	31 1d       	adc	r19, r1
    a67c:	3d 83       	std	Y+5, r19	; 0x05
    a67e:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    a680:	8a 81       	ldd	r24, Y+2	; 0x02
    a682:	9b 81       	ldd	r25, Y+3	; 0x03
    a684:	28 17       	cp	r18, r24
    a686:	39 07       	cpc	r19, r25
    a688:	08 f1       	brcs	.+66     	; 0xa6cc <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    a68a:	88 81       	ld	r24, Y
    a68c:	99 81       	ldd	r25, Y+1	; 0x01
    a68e:	9d 83       	std	Y+5, r25	; 0x05
    a690:	8c 83       	std	Y+4, r24	; 0x04
    a692:	1c c0       	rjmp	.+56     	; 0xa6cc <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    a694:	8e 81       	ldd	r24, Y+6	; 0x06
    a696:	9f 81       	ldd	r25, Y+7	; 0x07
    a698:	50 e0       	ldi	r21, 0x00	; 0
    a69a:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    a69e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    a6a0:	90 e0       	ldi	r25, 0x00	; 0
    a6a2:	44 27       	eor	r20, r20
    a6a4:	55 27       	eor	r21, r21
    a6a6:	48 1b       	sub	r20, r24
    a6a8:	59 0b       	sbc	r21, r25
    a6aa:	8e 81       	ldd	r24, Y+6	; 0x06
    a6ac:	9f 81       	ldd	r25, Y+7	; 0x07
    a6ae:	84 0f       	add	r24, r20
    a6b0:	95 1f       	adc	r25, r21
    a6b2:	9f 83       	std	Y+7, r25	; 0x07
    a6b4:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    a6b6:	28 81       	ld	r18, Y
    a6b8:	39 81       	ldd	r19, Y+1	; 0x01
    a6ba:	82 17       	cp	r24, r18
    a6bc:	93 07       	cpc	r25, r19
    a6be:	30 f4       	brcc	.+12     	; 0xa6cc <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    a6c0:	8a 81       	ldd	r24, Y+2	; 0x02
    a6c2:	9b 81       	ldd	r25, Y+3	; 0x03
    a6c4:	84 0f       	add	r24, r20
    a6c6:	95 1f       	adc	r25, r21
    a6c8:	9f 83       	std	Y+7, r25	; 0x07
    a6ca:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    a6cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    a6ce:	8f 5f       	subi	r24, 0xFF	; 255
    a6d0:	8a 8f       	std	Y+26, r24	; 0x1a
}
    a6d2:	df 91       	pop	r29
    a6d4:	cf 91       	pop	r28
    a6d6:	08 95       	ret

0000a6d8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    a6d8:	0f 93       	push	r16
    a6da:	1f 93       	push	r17
    a6dc:	cf 93       	push	r28
    a6de:	df 93       	push	r29
    a6e0:	ec 01       	movw	r28, r24
    a6e2:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    a6e4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a6e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    a6e8:	98 17       	cp	r25, r24
    a6ea:	10 f0       	brcs	.+4      	; 0xa6f0 <xQueueGenericSendFromISR+0x18>
    a6ec:	80 e0       	ldi	r24, 0x00	; 0
    a6ee:	17 c0       	rjmp	.+46     	; 0xa71e <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    a6f0:	ce 01       	movw	r24, r28
    a6f2:	42 2f       	mov	r20, r18
    a6f4:	0e 94 2b 53 	call	0xa656	; 0xa656 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    a6f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    a6fa:	8f 3f       	cpi	r24, 0xFF	; 255
    a6fc:	69 f4       	brne	.+26     	; 0xa718 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    a6fe:	89 89       	ldd	r24, Y+17	; 0x11
    a700:	88 23       	and	r24, r24
    a702:	61 f0       	breq	.+24     	; 0xa71c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a704:	ce 01       	movw	r24, r28
    a706:	41 96       	adiw	r24, 0x11	; 17
    a708:	0e 94 16 4d 	call	0x9a2c	; 0x9a2c <xTaskRemoveFromEventList>
    a70c:	88 23       	and	r24, r24
    a70e:	31 f0       	breq	.+12     	; 0xa71c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    a710:	81 e0       	ldi	r24, 0x01	; 1
    a712:	f8 01       	movw	r30, r16
    a714:	80 83       	st	Z, r24
    a716:	03 c0       	rjmp	.+6      	; 0xa71e <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    a718:	8f 5f       	subi	r24, 0xFF	; 255
    a71a:	8e 8f       	std	Y+30, r24	; 0x1e
    a71c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    a71e:	df 91       	pop	r29
    a720:	cf 91       	pop	r28
    a722:	1f 91       	pop	r17
    a724:	0f 91       	pop	r16
    a726:	08 95       	ret

0000a728 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    a728:	0f 93       	push	r16
    a72a:	1f 93       	push	r17
    a72c:	cf 93       	push	r28
    a72e:	df 93       	push	r29
    a730:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    a732:	0f b6       	in	r0, 0x3f	; 63
    a734:	f8 94       	cli
    a736:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a738:	8c 01       	movw	r16, r24
    a73a:	0f 5e       	subi	r16, 0xEF	; 239
    a73c:	1f 4f       	sbci	r17, 0xFF	; 255
    a73e:	0d c0       	rjmp	.+26     	; 0xa75a <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    a740:	89 89       	ldd	r24, Y+17	; 0x11
    a742:	88 23       	and	r24, r24
    a744:	69 f0       	breq	.+26     	; 0xa760 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a746:	c8 01       	movw	r24, r16
    a748:	0e 94 16 4d 	call	0x9a2c	; 0x9a2c <xTaskRemoveFromEventList>
    a74c:	88 23       	and	r24, r24
    a74e:	11 f0       	breq	.+4      	; 0xa754 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    a750:	0e 94 12 4d 	call	0x9a24	; 0x9a24 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    a754:	8e 8d       	ldd	r24, Y+30	; 0x1e
    a756:	81 50       	subi	r24, 0x01	; 1
    a758:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    a75a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    a75c:	18 16       	cp	r1, r24
    a75e:	84 f3       	brlt	.-32     	; 0xa740 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    a760:	8f ef       	ldi	r24, 0xFF	; 255
    a762:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    a764:	0f 90       	pop	r0
    a766:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    a768:	0f b6       	in	r0, 0x3f	; 63
    a76a:	f8 94       	cli
    a76c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    a76e:	8e 01       	movw	r16, r28
    a770:	08 5f       	subi	r16, 0xF8	; 248
    a772:	1f 4f       	sbci	r17, 0xFF	; 255
    a774:	0d c0       	rjmp	.+26     	; 0xa790 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    a776:	88 85       	ldd	r24, Y+8	; 0x08
    a778:	88 23       	and	r24, r24
    a77a:	69 f0       	breq	.+26     	; 0xa796 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    a77c:	c8 01       	movw	r24, r16
    a77e:	0e 94 16 4d 	call	0x9a2c	; 0x9a2c <xTaskRemoveFromEventList>
    a782:	88 23       	and	r24, r24
    a784:	11 f0       	breq	.+4      	; 0xa78a <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    a786:	0e 94 12 4d 	call	0x9a24	; 0x9a24 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    a78a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a78c:	81 50       	subi	r24, 0x01	; 1
    a78e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    a790:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a792:	18 16       	cp	r1, r24
    a794:	84 f3       	brlt	.-32     	; 0xa776 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    a796:	8f ef       	ldi	r24, 0xFF	; 255
    a798:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    a79a:	0f 90       	pop	r0
    a79c:	0f be       	out	0x3f, r0	; 63
}
    a79e:	df 91       	pop	r29
    a7a0:	cf 91       	pop	r28
    a7a2:	1f 91       	pop	r17
    a7a4:	0f 91       	pop	r16
    a7a6:	08 95       	ret

0000a7a8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    a7a8:	7f 92       	push	r7
    a7aa:	8f 92       	push	r8
    a7ac:	9f 92       	push	r9
    a7ae:	af 92       	push	r10
    a7b0:	bf 92       	push	r11
    a7b2:	cf 92       	push	r12
    a7b4:	df 92       	push	r13
    a7b6:	ef 92       	push	r14
    a7b8:	ff 92       	push	r15
    a7ba:	0f 93       	push	r16
    a7bc:	1f 93       	push	r17
    a7be:	df 93       	push	r29
    a7c0:	cf 93       	push	r28
    a7c2:	00 d0       	rcall	.+0      	; 0xa7c4 <xQueueGenericReceive+0x1c>
    a7c4:	00 d0       	rcall	.+0      	; 0xa7c6 <xQueueGenericReceive+0x1e>
    a7c6:	0f 92       	push	r0
    a7c8:	cd b7       	in	r28, 0x3d	; 61
    a7ca:	de b7       	in	r29, 0x3e	; 62
    a7cc:	8c 01       	movw	r16, r24
    a7ce:	96 2e       	mov	r9, r22
    a7d0:	87 2e       	mov	r8, r23
    a7d2:	5d 83       	std	Y+5, r21	; 0x05
    a7d4:	4c 83       	std	Y+4, r20	; 0x04
    a7d6:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    a7d8:	91 e1       	ldi	r25, 0x11	; 17
    a7da:	c9 2e       	mov	r12, r25
    a7dc:	d1 2c       	mov	r13, r1
    a7de:	c0 0e       	add	r12, r16
    a7e0:	d1 1e       	adc	r13, r17
    a7e2:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a7e4:	7e 01       	movw	r14, r28
    a7e6:	08 94       	sec
    a7e8:	e1 1c       	adc	r14, r1
    a7ea:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    a7ec:	84 e0       	ldi	r24, 0x04	; 4
    a7ee:	a8 2e       	mov	r10, r24
    a7f0:	b1 2c       	mov	r11, r1
    a7f2:	ac 0e       	add	r10, r28
    a7f4:	bd 1e       	adc	r11, r29
    a7f6:	01 c0       	rjmp	.+2      	; 0xa7fa <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    a7f8:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    a7fa:	0f b6       	in	r0, 0x3f	; 63
    a7fc:	f8 94       	cli
    a7fe:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    a800:	f8 01       	movw	r30, r16
    a802:	82 8d       	ldd	r24, Z+26	; 0x1a
    a804:	88 23       	and	r24, r24
    a806:	09 f4       	brne	.+2      	; 0xa80a <xQueueGenericReceive+0x62>
    a808:	3e c0       	rjmp	.+124    	; 0xa886 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    a80a:	e6 80       	ldd	r14, Z+6	; 0x06
    a80c:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    a80e:	40 81       	ld	r20, Z
    a810:	51 81       	ldd	r21, Z+1	; 0x01
    a812:	41 15       	cp	r20, r1
    a814:	51 05       	cpc	r21, r1
    a816:	b1 f0       	breq	.+44     	; 0xa844 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    a818:	84 8d       	ldd	r24, Z+28	; 0x1c
    a81a:	97 01       	movw	r18, r14
    a81c:	28 0f       	add	r18, r24
    a81e:	31 1d       	adc	r19, r1
    a820:	37 83       	std	Z+7, r19	; 0x07
    a822:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    a824:	82 81       	ldd	r24, Z+2	; 0x02
    a826:	93 81       	ldd	r25, Z+3	; 0x03
    a828:	28 17       	cp	r18, r24
    a82a:	39 07       	cpc	r19, r25
    a82c:	10 f0       	brcs	.+4      	; 0xa832 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    a82e:	57 83       	std	Z+7, r21	; 0x07
    a830:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    a832:	f8 01       	movw	r30, r16
    a834:	44 8d       	ldd	r20, Z+28	; 0x1c
    a836:	66 81       	ldd	r22, Z+6	; 0x06
    a838:	77 81       	ldd	r23, Z+7	; 0x07
    a83a:	89 2d       	mov	r24, r9
    a83c:	98 2d       	mov	r25, r8
    a83e:	50 e0       	ldi	r21, 0x00	; 0
    a840:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    a844:	77 20       	and	r7, r7
    a846:	71 f4       	brne	.+28     	; 0xa864 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    a848:	f8 01       	movw	r30, r16
    a84a:	82 8d       	ldd	r24, Z+26	; 0x1a
    a84c:	81 50       	subi	r24, 0x01	; 1
    a84e:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    a850:	80 85       	ldd	r24, Z+8	; 0x08
    a852:	88 23       	and	r24, r24
    a854:	a1 f0       	breq	.+40     	; 0xa87e <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    a856:	c8 01       	movw	r24, r16
    a858:	08 96       	adiw	r24, 0x08	; 8
    a85a:	0e 94 16 4d 	call	0x9a2c	; 0x9a2c <xTaskRemoveFromEventList>
    a85e:	81 30       	cpi	r24, 0x01	; 1
    a860:	71 f4       	brne	.+28     	; 0xa87e <xQueueGenericReceive+0xd6>
    a862:	0b c0       	rjmp	.+22     	; 0xa87a <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    a864:	f8 01       	movw	r30, r16
    a866:	f7 82       	std	Z+7, r15	; 0x07
    a868:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    a86a:	81 89       	ldd	r24, Z+17	; 0x11
    a86c:	88 23       	and	r24, r24
    a86e:	39 f0       	breq	.+14     	; 0xa87e <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a870:	c6 01       	movw	r24, r12
    a872:	0e 94 16 4d 	call	0x9a2c	; 0x9a2c <xTaskRemoveFromEventList>
    a876:	88 23       	and	r24, r24
    a878:	11 f0       	breq	.+4      	; 0xa87e <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    a87a:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    a87e:	0f 90       	pop	r0
    a880:	0f be       	out	0x3f, r0	; 63
    a882:	81 e0       	ldi	r24, 0x01	; 1
    a884:	4a c0       	rjmp	.+148    	; 0xa91a <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    a886:	8c 81       	ldd	r24, Y+4	; 0x04
    a888:	9d 81       	ldd	r25, Y+5	; 0x05
    a88a:	89 2b       	or	r24, r25
    a88c:	19 f4       	brne	.+6      	; 0xa894 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    a88e:	0f 90       	pop	r0
    a890:	0f be       	out	0x3f, r0	; 63
    a892:	42 c0       	rjmp	.+132    	; 0xa918 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    a894:	22 23       	and	r18, r18
    a896:	19 f4       	brne	.+6      	; 0xa89e <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a898:	c7 01       	movw	r24, r14
    a89a:	0e 94 c9 4c 	call	0x9992	; 0x9992 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    a89e:	0f 90       	pop	r0
    a8a0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    a8a2:	0e 94 f2 4b 	call	0x97e4	; 0x97e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    a8a6:	0f b6       	in	r0, 0x3f	; 63
    a8a8:	f8 94       	cli
    a8aa:	0f 92       	push	r0
    a8ac:	f8 01       	movw	r30, r16
    a8ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    a8b0:	8f 3f       	cpi	r24, 0xFF	; 255
    a8b2:	09 f4       	brne	.+2      	; 0xa8b6 <xQueueGenericReceive+0x10e>
    a8b4:	15 8e       	std	Z+29, r1	; 0x1d
    a8b6:	f8 01       	movw	r30, r16
    a8b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    a8ba:	8f 3f       	cpi	r24, 0xFF	; 255
    a8bc:	09 f4       	brne	.+2      	; 0xa8c0 <xQueueGenericReceive+0x118>
    a8be:	16 8e       	std	Z+30, r1	; 0x1e
    a8c0:	0f 90       	pop	r0
    a8c2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    a8c4:	c7 01       	movw	r24, r14
    a8c6:	b5 01       	movw	r22, r10
    a8c8:	0e 94 d4 4c 	call	0x99a8	; 0x99a8 <xTaskCheckForTimeOut>
    a8cc:	88 23       	and	r24, r24
    a8ce:	f9 f4       	brne	.+62     	; 0xa90e <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    a8d0:	0f b6       	in	r0, 0x3f	; 63
    a8d2:	f8 94       	cli
    a8d4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    a8d6:	f8 01       	movw	r30, r16
    a8d8:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    a8da:	0f 90       	pop	r0
    a8dc:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    a8de:	88 23       	and	r24, r24
    a8e0:	81 f4       	brne	.+32     	; 0xa902 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    a8e2:	6c 81       	ldd	r22, Y+4	; 0x04
    a8e4:	7d 81       	ldd	r23, Y+5	; 0x05
    a8e6:	c6 01       	movw	r24, r12
    a8e8:	0e 94 a7 4d 	call	0x9b4e	; 0x9b4e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    a8ec:	c8 01       	movw	r24, r16
    a8ee:	0e 94 94 53 	call	0xa728	; 0xa728 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    a8f2:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
    a8f6:	88 23       	and	r24, r24
    a8f8:	09 f0       	breq	.+2      	; 0xa8fc <xQueueGenericReceive+0x154>
    a8fa:	7e cf       	rjmp	.-260    	; 0xa7f8 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    a8fc:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
    a900:	7b cf       	rjmp	.-266    	; 0xa7f8 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    a902:	c8 01       	movw	r24, r16
    a904:	0e 94 94 53 	call	0xa728	; 0xa728 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    a908:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
    a90c:	75 cf       	rjmp	.-278    	; 0xa7f8 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    a90e:	c8 01       	movw	r24, r16
    a910:	0e 94 94 53 	call	0xa728	; 0xa728 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    a914:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
    a918:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    a91a:	0f 90       	pop	r0
    a91c:	0f 90       	pop	r0
    a91e:	0f 90       	pop	r0
    a920:	0f 90       	pop	r0
    a922:	0f 90       	pop	r0
    a924:	cf 91       	pop	r28
    a926:	df 91       	pop	r29
    a928:	1f 91       	pop	r17
    a92a:	0f 91       	pop	r16
    a92c:	ff 90       	pop	r15
    a92e:	ef 90       	pop	r14
    a930:	df 90       	pop	r13
    a932:	cf 90       	pop	r12
    a934:	bf 90       	pop	r11
    a936:	af 90       	pop	r10
    a938:	9f 90       	pop	r9
    a93a:	8f 90       	pop	r8
    a93c:	7f 90       	pop	r7
    a93e:	08 95       	ret

0000a940 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    a940:	7f 92       	push	r7
    a942:	8f 92       	push	r8
    a944:	9f 92       	push	r9
    a946:	af 92       	push	r10
    a948:	bf 92       	push	r11
    a94a:	cf 92       	push	r12
    a94c:	df 92       	push	r13
    a94e:	ef 92       	push	r14
    a950:	ff 92       	push	r15
    a952:	0f 93       	push	r16
    a954:	1f 93       	push	r17
    a956:	df 93       	push	r29
    a958:	cf 93       	push	r28
    a95a:	00 d0       	rcall	.+0      	; 0xa95c <xQueueGenericSend+0x1c>
    a95c:	00 d0       	rcall	.+0      	; 0xa95e <xQueueGenericSend+0x1e>
    a95e:	0f 92       	push	r0
    a960:	cd b7       	in	r28, 0x3d	; 61
    a962:	de b7       	in	r29, 0x3e	; 62
    a964:	8c 01       	movw	r16, r24
    a966:	6b 01       	movw	r12, r22
    a968:	5d 83       	std	Y+5, r21	; 0x05
    a96a:	4c 83       	std	Y+4, r20	; 0x04
    a96c:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    a96e:	48 e0       	ldi	r20, 0x08	; 8
    a970:	e4 2e       	mov	r14, r20
    a972:	f1 2c       	mov	r15, r1
    a974:	e8 0e       	add	r14, r24
    a976:	f9 1e       	adc	r15, r25
    a978:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a97a:	5e 01       	movw	r10, r28
    a97c:	08 94       	sec
    a97e:	a1 1c       	adc	r10, r1
    a980:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    a982:	34 e0       	ldi	r19, 0x04	; 4
    a984:	83 2e       	mov	r8, r19
    a986:	91 2c       	mov	r9, r1
    a988:	8c 0e       	add	r8, r28
    a98a:	9d 1e       	adc	r9, r29
    a98c:	01 c0       	rjmp	.+2      	; 0xa990 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    a98e:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    a990:	0f b6       	in	r0, 0x3f	; 63
    a992:	f8 94       	cli
    a994:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    a996:	f8 01       	movw	r30, r16
    a998:	92 8d       	ldd	r25, Z+26	; 0x1a
    a99a:	83 8d       	ldd	r24, Z+27	; 0x1b
    a99c:	98 17       	cp	r25, r24
    a99e:	a8 f4       	brcc	.+42     	; 0xa9ca <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    a9a0:	c8 01       	movw	r24, r16
    a9a2:	b6 01       	movw	r22, r12
    a9a4:	47 2d       	mov	r20, r7
    a9a6:	0e 94 2b 53 	call	0xa656	; 0xa656 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    a9aa:	f8 01       	movw	r30, r16
    a9ac:	81 89       	ldd	r24, Z+17	; 0x11
    a9ae:	88 23       	and	r24, r24
    a9b0:	41 f0       	breq	.+16     	; 0xa9c2 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    a9b2:	c8 01       	movw	r24, r16
    a9b4:	41 96       	adiw	r24, 0x11	; 17
    a9b6:	0e 94 16 4d 	call	0x9a2c	; 0x9a2c <xTaskRemoveFromEventList>
    a9ba:	81 30       	cpi	r24, 0x01	; 1
    a9bc:	11 f4       	brne	.+4      	; 0xa9c2 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    a9be:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    a9c2:	0f 90       	pop	r0
    a9c4:	0f be       	out	0x3f, r0	; 63
    a9c6:	81 e0       	ldi	r24, 0x01	; 1
    a9c8:	4c c0       	rjmp	.+152    	; 0xaa62 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    a9ca:	8c 81       	ldd	r24, Y+4	; 0x04
    a9cc:	9d 81       	ldd	r25, Y+5	; 0x05
    a9ce:	89 2b       	or	r24, r25
    a9d0:	19 f4       	brne	.+6      	; 0xa9d8 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    a9d2:	0f 90       	pop	r0
    a9d4:	0f be       	out	0x3f, r0	; 63
    a9d6:	44 c0       	rjmp	.+136    	; 0xaa60 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    a9d8:	22 23       	and	r18, r18
    a9da:	19 f4       	brne	.+6      	; 0xa9e2 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a9dc:	c5 01       	movw	r24, r10
    a9de:	0e 94 c9 4c 	call	0x9992	; 0x9992 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    a9e2:	0f 90       	pop	r0
    a9e4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    a9e6:	0e 94 f2 4b 	call	0x97e4	; 0x97e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    a9ea:	0f b6       	in	r0, 0x3f	; 63
    a9ec:	f8 94       	cli
    a9ee:	0f 92       	push	r0
    a9f0:	f8 01       	movw	r30, r16
    a9f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    a9f4:	8f 3f       	cpi	r24, 0xFF	; 255
    a9f6:	09 f4       	brne	.+2      	; 0xa9fa <xQueueGenericSend+0xba>
    a9f8:	15 8e       	std	Z+29, r1	; 0x1d
    a9fa:	f8 01       	movw	r30, r16
    a9fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    a9fe:	8f 3f       	cpi	r24, 0xFF	; 255
    aa00:	09 f4       	brne	.+2      	; 0xaa04 <xQueueGenericSend+0xc4>
    aa02:	16 8e       	std	Z+30, r1	; 0x1e
    aa04:	0f 90       	pop	r0
    aa06:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    aa08:	c5 01       	movw	r24, r10
    aa0a:	b4 01       	movw	r22, r8
    aa0c:	0e 94 d4 4c 	call	0x99a8	; 0x99a8 <xTaskCheckForTimeOut>
    aa10:	88 23       	and	r24, r24
    aa12:	09 f5       	brne	.+66     	; 0xaa56 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    aa14:	0f b6       	in	r0, 0x3f	; 63
    aa16:	f8 94       	cli
    aa18:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    aa1a:	f8 01       	movw	r30, r16
    aa1c:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    aa1e:	0f 90       	pop	r0
    aa20:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    aa22:	f8 01       	movw	r30, r16
    aa24:	83 8d       	ldd	r24, Z+27	; 0x1b
    aa26:	98 17       	cp	r25, r24
    aa28:	81 f4       	brne	.+32     	; 0xaa4a <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    aa2a:	6c 81       	ldd	r22, Y+4	; 0x04
    aa2c:	7d 81       	ldd	r23, Y+5	; 0x05
    aa2e:	c7 01       	movw	r24, r14
    aa30:	0e 94 a7 4d 	call	0x9b4e	; 0x9b4e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    aa34:	c8 01       	movw	r24, r16
    aa36:	0e 94 94 53 	call	0xa728	; 0xa728 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    aa3a:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
    aa3e:	88 23       	and	r24, r24
    aa40:	09 f0       	breq	.+2      	; 0xaa44 <xQueueGenericSend+0x104>
    aa42:	a5 cf       	rjmp	.-182    	; 0xa98e <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    aa44:	0e 94 8a 59 	call	0xb314	; 0xb314 <vPortYield>
    aa48:	a2 cf       	rjmp	.-188    	; 0xa98e <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    aa4a:	c8 01       	movw	r24, r16
    aa4c:	0e 94 94 53 	call	0xa728	; 0xa728 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    aa50:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
    aa54:	9c cf       	rjmp	.-200    	; 0xa98e <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    aa56:	c8 01       	movw	r24, r16
    aa58:	0e 94 94 53 	call	0xa728	; 0xa728 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    aa5c:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
    aa60:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    aa62:	0f 90       	pop	r0
    aa64:	0f 90       	pop	r0
    aa66:	0f 90       	pop	r0
    aa68:	0f 90       	pop	r0
    aa6a:	0f 90       	pop	r0
    aa6c:	cf 91       	pop	r28
    aa6e:	df 91       	pop	r29
    aa70:	1f 91       	pop	r17
    aa72:	0f 91       	pop	r16
    aa74:	ff 90       	pop	r15
    aa76:	ef 90       	pop	r14
    aa78:	df 90       	pop	r13
    aa7a:	cf 90       	pop	r12
    aa7c:	bf 90       	pop	r11
    aa7e:	af 90       	pop	r10
    aa80:	9f 90       	pop	r9
    aa82:	8f 90       	pop	r8
    aa84:	7f 90       	pop	r7
    aa86:	08 95       	ret

0000aa88 <xQueueCreateExternal>:
	was required. */
	return NULL;
}

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    aa88:	ef 92       	push	r14
    aa8a:	ff 92       	push	r15
    aa8c:	0f 93       	push	r16
    aa8e:	1f 93       	push	r17
    aa90:	cf 93       	push	r28
    aa92:	df 93       	push	r29
    aa94:	18 2f       	mov	r17, r24
    aa96:	e6 2e       	mov	r14, r22
    aa98:	04 2f       	mov	r16, r20
    aa9a:	f5 2e       	mov	r15, r21
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    aa9c:	88 23       	and	r24, r24
    aa9e:	f1 f1       	breq	.+124    	; 0xab1c <xQueueCreateExternal+0x94>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    aaa0:	8f e1       	ldi	r24, 0x1F	; 31
    aaa2:	90 e0       	ldi	r25, 0x00	; 0
    aaa4:	0e 94 61 58 	call	0xb0c2	; 0xb0c2 <pvPortMalloc>
    aaa8:	fc 01       	movw	r30, r24
    aaaa:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    aaac:	00 97       	sbiw	r24, 0x00	; 0
    aaae:	c1 f1       	breq	.+112    	; 0xab20 <xQueueCreateExternal+0x98>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    aab0:	60 2f       	mov	r22, r16
    aab2:	7f 2d       	mov	r23, r15
    aab4:	71 83       	std	Z+1, r23	; 0x01
    aab6:	60 83       	st	Z, r22
			if( pxNewQueue->pcHead != NULL )
    aab8:	61 15       	cp	r22, r1
    aaba:	71 05       	cpc	r23, r1
    aabc:	69 f1       	breq	.+90     	; 0xab18 <xQueueCreateExternal+0x90>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    aabe:	21 2f       	mov	r18, r17
    aac0:	30 e0       	ldi	r19, 0x00	; 0
    aac2:	4e 2d       	mov	r20, r14
    aac4:	50 e0       	ldi	r21, 0x00	; 0
    aac6:	42 9f       	mul	r20, r18
    aac8:	c0 01       	movw	r24, r0
    aaca:	43 9f       	mul	r20, r19
    aacc:	90 0d       	add	r25, r0
    aace:	52 9f       	mul	r21, r18
    aad0:	90 0d       	add	r25, r0
    aad2:	11 24       	eor	r1, r1
    aad4:	86 0f       	add	r24, r22
    aad6:	97 1f       	adc	r25, r23
    aad8:	93 83       	std	Z+3, r25	; 0x03
    aada:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    aadc:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    aade:	75 83       	std	Z+5, r23	; 0x05
    aae0:	64 83       	std	Z+4, r22	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    aae2:	21 50       	subi	r18, 0x01	; 1
    aae4:	30 40       	sbci	r19, 0x00	; 0
    aae6:	24 9f       	mul	r18, r20
    aae8:	c0 01       	movw	r24, r0
    aaea:	25 9f       	mul	r18, r21
    aaec:	90 0d       	add	r25, r0
    aaee:	34 9f       	mul	r19, r20
    aaf0:	90 0d       	add	r25, r0
    aaf2:	11 24       	eor	r1, r1
    aaf4:	68 0f       	add	r22, r24
    aaf6:	79 1f       	adc	r23, r25
    aaf8:	77 83       	std	Z+7, r23	; 0x07
    aafa:	66 83       	std	Z+6, r22	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    aafc:	13 8f       	std	Z+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    aafe:	e4 8e       	std	Z+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    ab00:	8f ef       	ldi	r24, 0xFF	; 255
    ab02:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    ab04:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    ab06:	cf 01       	movw	r24, r30
    ab08:	08 96       	adiw	r24, 0x08	; 8
    ab0a:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    ab0e:	ce 01       	movw	r24, r28
    ab10:	41 96       	adiw	r24, 0x11	; 17
    ab12:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
    ab16:	04 c0       	rjmp	.+8      	; 0xab20 <xQueueCreateExternal+0x98>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    ab18:	0e 94 51 58 	call	0xb0a2	; 0xb0a2 <vPortFree>
    ab1c:	c0 e0       	ldi	r28, 0x00	; 0
    ab1e:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    ab20:	ce 01       	movw	r24, r28
    ab22:	df 91       	pop	r29
    ab24:	cf 91       	pop	r28
    ab26:	1f 91       	pop	r17
    ab28:	0f 91       	pop	r16
    ab2a:	ff 90       	pop	r15
    ab2c:	ef 90       	pop	r14
    ab2e:	08 95       	ret

0000ab30 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    ab30:	8f 92       	push	r8
    ab32:	9f 92       	push	r9
    ab34:	af 92       	push	r10
    ab36:	bf 92       	push	r11
    ab38:	cf 92       	push	r12
    ab3a:	df 92       	push	r13
    ab3c:	ef 92       	push	r14
    ab3e:	ff 92       	push	r15
    ab40:	0f 93       	push	r16
    ab42:	1f 93       	push	r17
    ab44:	cf 93       	push	r28
    ab46:	df 93       	push	r29
    ab48:	98 2e       	mov	r9, r24
    ab4a:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    ab4c:	88 23       	and	r24, r24
    ab4e:	09 f4       	brne	.+2      	; 0xab52 <xQueueCreate+0x22>
    ab50:	42 c0       	rjmp	.+132    	; 0xabd6 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    ab52:	8f e1       	ldi	r24, 0x1F	; 31
    ab54:	90 e0       	ldi	r25, 0x00	; 0
    ab56:	0e 94 61 58 	call	0xb0c2	; 0xb0c2 <pvPortMalloc>
    ab5a:	8c 01       	movw	r16, r24
    ab5c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    ab5e:	00 97       	sbiw	r24, 0x00	; 0
    ab60:	e1 f1       	breq	.+120    	; 0xabda <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    ab62:	c9 2c       	mov	r12, r9
    ab64:	dd 24       	eor	r13, r13
    ab66:	a8 2c       	mov	r10, r8
    ab68:	bb 24       	eor	r11, r11
    ab6a:	ac 9c       	mul	r10, r12
    ab6c:	70 01       	movw	r14, r0
    ab6e:	ad 9c       	mul	r10, r13
    ab70:	f0 0c       	add	r15, r0
    ab72:	bc 9c       	mul	r11, r12
    ab74:	f0 0c       	add	r15, r0
    ab76:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    ab78:	c7 01       	movw	r24, r14
    ab7a:	01 96       	adiw	r24, 0x01	; 1
    ab7c:	0e 94 61 58 	call	0xb0c2	; 0xb0c2 <pvPortMalloc>
    ab80:	9c 01       	movw	r18, r24
    ab82:	99 83       	std	Y+1, r25	; 0x01
    ab84:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    ab86:	00 97       	sbiw	r24, 0x00	; 0
    ab88:	19 f1       	breq	.+70     	; 0xabd0 <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    ab8a:	e8 0e       	add	r14, r24
    ab8c:	f9 1e       	adc	r15, r25
    ab8e:	fb 82       	std	Y+3, r15	; 0x03
    ab90:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    ab92:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    ab94:	9d 83       	std	Y+5, r25	; 0x05
    ab96:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    ab98:	08 94       	sec
    ab9a:	c1 08       	sbc	r12, r1
    ab9c:	d1 08       	sbc	r13, r1
    ab9e:	ca 9c       	mul	r12, r10
    aba0:	c0 01       	movw	r24, r0
    aba2:	cb 9c       	mul	r12, r11
    aba4:	90 0d       	add	r25, r0
    aba6:	da 9c       	mul	r13, r10
    aba8:	90 0d       	add	r25, r0
    abaa:	11 24       	eor	r1, r1
    abac:	28 0f       	add	r18, r24
    abae:	39 1f       	adc	r19, r25
    abb0:	3f 83       	std	Y+7, r19	; 0x07
    abb2:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    abb4:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    abb6:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    abb8:	8f ef       	ldi	r24, 0xFF	; 255
    abba:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    abbc:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    abbe:	c8 01       	movw	r24, r16
    abc0:	08 96       	adiw	r24, 0x08	; 8
    abc2:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    abc6:	c8 01       	movw	r24, r16
    abc8:	41 96       	adiw	r24, 0x11	; 17
    abca:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
    abce:	05 c0       	rjmp	.+10     	; 0xabda <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    abd0:	c8 01       	movw	r24, r16
    abd2:	0e 94 51 58 	call	0xb0a2	; 0xb0a2 <vPortFree>
    abd6:	c0 e0       	ldi	r28, 0x00	; 0
    abd8:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    abda:	ce 01       	movw	r24, r28
    abdc:	df 91       	pop	r29
    abde:	cf 91       	pop	r28
    abe0:	1f 91       	pop	r17
    abe2:	0f 91       	pop	r16
    abe4:	ff 90       	pop	r15
    abe6:	ef 90       	pop	r14
    abe8:	df 90       	pop	r13
    abea:	cf 90       	pop	r12
    abec:	bf 90       	pop	r11
    abee:	af 90       	pop	r10
    abf0:	9f 90       	pop	r9
    abf2:	8f 90       	pop	r8
    abf4:	08 95       	ret

0000abf6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    abf6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    abf8:	9c 01       	movw	r18, r24
    abfa:	2d 5f       	subi	r18, 0xFD	; 253
    abfc:	3f 4f       	sbci	r19, 0xFF	; 255
    abfe:	32 83       	std	Z+2, r19	; 0x02
    ac00:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    ac02:	8f ef       	ldi	r24, 0xFF	; 255
    ac04:	9f ef       	ldi	r25, 0xFF	; 255
    ac06:	94 83       	std	Z+4, r25	; 0x04
    ac08:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    ac0a:	36 83       	std	Z+6, r19	; 0x06
    ac0c:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    ac0e:	30 87       	std	Z+8, r19	; 0x08
    ac10:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    ac12:	10 82       	st	Z, r1
}
    ac14:	08 95       	ret

0000ac16 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    ac16:	fc 01       	movw	r30, r24
    ac18:	11 86       	std	Z+9, r1	; 0x09
    ac1a:	10 86       	std	Z+8, r1	; 0x08
}
    ac1c:	08 95       	ret

0000ac1e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    ac1e:	cf 93       	push	r28
    ac20:	df 93       	push	r29
    ac22:	ac 01       	movw	r20, r24
    ac24:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    ac26:	ec 01       	movw	r28, r24
    ac28:	29 81       	ldd	r18, Y+1	; 0x01
    ac2a:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    ac2c:	f9 01       	movw	r30, r18
    ac2e:	82 81       	ldd	r24, Z+2	; 0x02
    ac30:	93 81       	ldd	r25, Z+3	; 0x03
    ac32:	13 96       	adiw	r26, 0x03	; 3
    ac34:	9c 93       	st	X, r25
    ac36:	8e 93       	st	-X, r24
    ac38:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    ac3a:	89 81       	ldd	r24, Y+1	; 0x01
    ac3c:	9a 81       	ldd	r25, Y+2	; 0x02
    ac3e:	15 96       	adiw	r26, 0x05	; 5
    ac40:	9c 93       	st	X, r25
    ac42:	8e 93       	st	-X, r24
    ac44:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    ac46:	02 80       	ldd	r0, Z+2	; 0x02
    ac48:	f3 81       	ldd	r31, Z+3	; 0x03
    ac4a:	e0 2d       	mov	r30, r0
    ac4c:	75 83       	std	Z+5, r23	; 0x05
    ac4e:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    ac50:	e9 01       	movw	r28, r18
    ac52:	7b 83       	std	Y+3, r23	; 0x03
    ac54:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    ac56:	fa 01       	movw	r30, r20
    ac58:	72 83       	std	Z+2, r23	; 0x02
    ac5a:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    ac5c:	19 96       	adiw	r26, 0x09	; 9
    ac5e:	5c 93       	st	X, r21
    ac60:	4e 93       	st	-X, r20
    ac62:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    ac64:	80 81       	ld	r24, Z
    ac66:	8f 5f       	subi	r24, 0xFF	; 255
    ac68:	80 83       	st	Z, r24
}
    ac6a:	df 91       	pop	r29
    ac6c:	cf 91       	pop	r28
    ac6e:	08 95       	ret

0000ac70 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    ac70:	cf 93       	push	r28
    ac72:	df 93       	push	r29
    ac74:	9c 01       	movw	r18, r24
    ac76:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    ac78:	48 81       	ld	r20, Y
    ac7a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    ac7c:	8f ef       	ldi	r24, 0xFF	; 255
    ac7e:	4f 3f       	cpi	r20, 0xFF	; 255
    ac80:	58 07       	cpc	r21, r24
    ac82:	21 f4       	brne	.+8      	; 0xac8c <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    ac84:	f9 01       	movw	r30, r18
    ac86:	a7 81       	ldd	r26, Z+7	; 0x07
    ac88:	b0 85       	ldd	r27, Z+8	; 0x08
    ac8a:	10 c0       	rjmp	.+32     	; 0xacac <vListInsert+0x3c>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    ac8c:	d9 01       	movw	r26, r18
    ac8e:	13 96       	adiw	r26, 0x03	; 3
    ac90:	04 c0       	rjmp	.+8      	; 0xac9a <vListInsert+0x2a>
    ac92:	12 96       	adiw	r26, 0x02	; 2
    ac94:	0d 90       	ld	r0, X+
    ac96:	bc 91       	ld	r27, X
    ac98:	a0 2d       	mov	r26, r0
    ac9a:	12 96       	adiw	r26, 0x02	; 2
    ac9c:	ed 91       	ld	r30, X+
    ac9e:	fc 91       	ld	r31, X
    aca0:	13 97       	sbiw	r26, 0x03	; 3
    aca2:	80 81       	ld	r24, Z
    aca4:	91 81       	ldd	r25, Z+1	; 0x01
    aca6:	48 17       	cp	r20, r24
    aca8:	59 07       	cpc	r21, r25
    acaa:	98 f7       	brcc	.-26     	; 0xac92 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    acac:	12 96       	adiw	r26, 0x02	; 2
    acae:	ed 91       	ld	r30, X+
    acb0:	fc 91       	ld	r31, X
    acb2:	13 97       	sbiw	r26, 0x03	; 3
    acb4:	fb 83       	std	Y+3, r31	; 0x03
    acb6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    acb8:	d5 83       	std	Z+5, r29	; 0x05
    acba:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    acbc:	bd 83       	std	Y+5, r27	; 0x05
    acbe:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    acc0:	13 96       	adiw	r26, 0x03	; 3
    acc2:	dc 93       	st	X, r29
    acc4:	ce 93       	st	-X, r28
    acc6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    acc8:	39 87       	std	Y+9, r19	; 0x09
    acca:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    accc:	f9 01       	movw	r30, r18
    acce:	80 81       	ld	r24, Z
    acd0:	8f 5f       	subi	r24, 0xFF	; 255
    acd2:	80 83       	st	Z, r24
}
    acd4:	df 91       	pop	r29
    acd6:	cf 91       	pop	r28
    acd8:	08 95       	ret

0000acda <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    acda:	cf 93       	push	r28
    acdc:	df 93       	push	r29
    acde:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    ace0:	12 96       	adiw	r26, 0x02	; 2
    ace2:	ed 91       	ld	r30, X+
    ace4:	fc 91       	ld	r31, X
    ace6:	13 97       	sbiw	r26, 0x03	; 3
    ace8:	14 96       	adiw	r26, 0x04	; 4
    acea:	8d 91       	ld	r24, X+
    acec:	9c 91       	ld	r25, X
    acee:	15 97       	sbiw	r26, 0x05	; 5
    acf0:	95 83       	std	Z+5, r25	; 0x05
    acf2:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    acf4:	14 96       	adiw	r26, 0x04	; 4
    acf6:	cd 91       	ld	r28, X+
    acf8:	dc 91       	ld	r29, X
    acfa:	15 97       	sbiw	r26, 0x05	; 5
    acfc:	fb 83       	std	Y+3, r31	; 0x03
    acfe:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    ad00:	18 96       	adiw	r26, 0x08	; 8
    ad02:	ed 91       	ld	r30, X+
    ad04:	fc 91       	ld	r31, X
    ad06:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    ad08:	81 81       	ldd	r24, Z+1	; 0x01
    ad0a:	92 81       	ldd	r25, Z+2	; 0x02
    ad0c:	8a 17       	cp	r24, r26
    ad0e:	9b 07       	cpc	r25, r27
    ad10:	11 f4       	brne	.+4      	; 0xad16 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    ad12:	d2 83       	std	Z+2, r29	; 0x02
    ad14:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    ad16:	19 96       	adiw	r26, 0x09	; 9
    ad18:	1c 92       	st	X, r1
    ad1a:	1e 92       	st	-X, r1
    ad1c:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    ad1e:	80 81       	ld	r24, Z
    ad20:	81 50       	subi	r24, 0x01	; 1
    ad22:	80 83       	st	Z, r24
}
    ad24:	df 91       	pop	r29
    ad26:	cf 91       	pop	r28
    ad28:	08 95       	ret

0000ad2a <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    ad2a:	0f 93       	push	r16
    ad2c:	1f 93       	push	r17
    ad2e:	cf 93       	push	r28
    ad30:	df 93       	push	r29
    ad32:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    ad34:	80 81       	ld	r24, Z
    ad36:	88 23       	and	r24, r24
    ad38:	19 f4       	brne	.+6      	; 0xad40 <xCoRoutineRemoveFromEventList+0x16>
    ad3a:	c0 e0       	ldi	r28, 0x00	; 0
    ad3c:	d0 e0       	ldi	r29, 0x00	; 0
    ad3e:	05 c0       	rjmp	.+10     	; 0xad4a <xCoRoutineRemoveFromEventList+0x20>
    ad40:	05 80       	ldd	r0, Z+5	; 0x05
    ad42:	f6 81       	ldd	r31, Z+6	; 0x06
    ad44:	e0 2d       	mov	r30, r0
    ad46:	c6 81       	ldd	r28, Z+6	; 0x06
    ad48:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    ad4a:	8e 01       	movw	r16, r28
    ad4c:	04 5f       	subi	r16, 0xF4	; 244
    ad4e:	1f 4f       	sbci	r17, 0xFF	; 255
    ad50:	c8 01       	movw	r24, r16
    ad52:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    ad56:	84 e4       	ldi	r24, 0x44	; 68
    ad58:	92 e0       	ldi	r25, 0x02	; 2
    ad5a:	b8 01       	movw	r22, r16
    ad5c:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
    ad60:	20 e0       	ldi	r18, 0x00	; 0
    ad62:	e0 91 1c 02 	lds	r30, 0x021C
    ad66:	f0 91 1d 02 	lds	r31, 0x021D
    ad6a:	9e 89       	ldd	r25, Y+22	; 0x16
    ad6c:	86 89       	ldd	r24, Z+22	; 0x16
    ad6e:	98 17       	cp	r25, r24
    ad70:	08 f0       	brcs	.+2      	; 0xad74 <xCoRoutineRemoveFromEventList+0x4a>
    ad72:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    ad74:	82 2f       	mov	r24, r18
    ad76:	df 91       	pop	r29
    ad78:	cf 91       	pop	r28
    ad7a:	1f 91       	pop	r17
    ad7c:	0f 91       	pop	r16
    ad7e:	08 95       	ret

0000ad80 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    ad80:	ff 92       	push	r15
    ad82:	0f 93       	push	r16
    ad84:	1f 93       	push	r17
    ad86:	cf 93       	push	r28
    ad88:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    ad8a:	99 e0       	ldi	r25, 0x09	; 9
    ad8c:	f9 2e       	mov	r15, r25
    ad8e:	28 c0       	rjmp	.+80     	; 0xade0 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    ad90:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    ad92:	80 91 44 02 	lds	r24, 0x0244
    ad96:	88 23       	and	r24, r24
    ad98:	19 f4       	brne	.+6      	; 0xada0 <vCoRoutineSchedule+0x20>
    ad9a:	c0 e0       	ldi	r28, 0x00	; 0
    ad9c:	d0 e0       	ldi	r29, 0x00	; 0
    ad9e:	06 c0       	rjmp	.+12     	; 0xadac <vCoRoutineSchedule+0x2c>
    ada0:	e0 91 49 02 	lds	r30, 0x0249
    ada4:	f0 91 4a 02 	lds	r31, 0x024A
    ada8:	c6 81       	ldd	r28, Z+6	; 0x06
    adaa:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    adac:	ce 01       	movw	r24, r28
    adae:	0c 96       	adiw	r24, 0x0c	; 12
    adb0:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
		}
		portENABLE_INTERRUPTS();
    adb4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    adb6:	8e 01       	movw	r16, r28
    adb8:	0e 5f       	subi	r16, 0xFE	; 254
    adba:	1f 4f       	sbci	r17, 0xFF	; 255
    adbc:	c8 01       	movw	r24, r16
    adbe:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    adc2:	9e 89       	ldd	r25, Y+22	; 0x16
    adc4:	80 91 1e 02 	lds	r24, 0x021E
    adc8:	89 17       	cp	r24, r25
    adca:	10 f4       	brcc	.+4      	; 0xadd0 <vCoRoutineSchedule+0x50>
    adcc:	90 93 1e 02 	sts	0x021E, r25
    add0:	9f 9d       	mul	r25, r15
    add2:	c0 01       	movw	r24, r0
    add4:	11 24       	eor	r1, r1
    add6:	8b 5d       	subi	r24, 0xDB	; 219
    add8:	9d 4f       	sbci	r25, 0xFD	; 253
    adda:	b8 01       	movw	r22, r16
    addc:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    ade0:	80 91 44 02 	lds	r24, 0x0244
    ade4:	88 23       	and	r24, r24
    ade6:	a1 f6       	brne	.-88     	; 0xad90 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    ade8:	0e 94 f8 4b 	call	0x97f0	; 0x97f0 <xTaskGetTickCount>
    adec:	20 91 1f 02 	lds	r18, 0x021F
    adf0:	30 91 20 02 	lds	r19, 0x0220
    adf4:	82 1b       	sub	r24, r18
    adf6:	93 0b       	sbc	r25, r19
    adf8:	90 93 22 02 	sts	0x0222, r25
    adfc:	80 93 21 02 	sts	0x0221, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    ae00:	89 e0       	ldi	r24, 0x09	; 9
    ae02:	f8 2e       	mov	r15, r24
    ae04:	54 c0       	rjmp	.+168    	; 0xaeae <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    ae06:	01 96       	adiw	r24, 0x01	; 1
    ae08:	90 93 24 02 	sts	0x0224, r25
    ae0c:	80 93 23 02 	sts	0x0223, r24
		xPassedTicks--;
    ae10:	21 50       	subi	r18, 0x01	; 1
    ae12:	30 40       	sbci	r19, 0x00	; 0
    ae14:	30 93 22 02 	sts	0x0222, r19
    ae18:	20 93 21 02 	sts	0x0221, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    ae1c:	89 2b       	or	r24, r25
    ae1e:	c9 f5       	brne	.+114    	; 0xae92 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    ae20:	20 91 40 02 	lds	r18, 0x0240
    ae24:	30 91 41 02 	lds	r19, 0x0241
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    ae28:	80 91 42 02 	lds	r24, 0x0242
    ae2c:	90 91 43 02 	lds	r25, 0x0243
    ae30:	90 93 41 02 	sts	0x0241, r25
    ae34:	80 93 40 02 	sts	0x0240, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    ae38:	30 93 43 02 	sts	0x0243, r19
    ae3c:	20 93 42 02 	sts	0x0242, r18
    ae40:	28 c0       	rjmp	.+80     	; 0xae92 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    ae42:	20 91 23 02 	lds	r18, 0x0223
    ae46:	30 91 24 02 	lds	r19, 0x0224
    ae4a:	8a 81       	ldd	r24, Y+2	; 0x02
    ae4c:	9b 81       	ldd	r25, Y+3	; 0x03
    ae4e:	28 17       	cp	r18, r24
    ae50:	39 07       	cpc	r19, r25
    ae52:	68 f1       	brcs	.+90     	; 0xaeae <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    ae54:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    ae56:	8e 01       	movw	r16, r28
    ae58:	0e 5f       	subi	r16, 0xFE	; 254
    ae5a:	1f 4f       	sbci	r17, 0xFF	; 255
    ae5c:	c8 01       	movw	r24, r16
    ae5e:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    ae62:	8c 89       	ldd	r24, Y+20	; 0x14
    ae64:	9d 89       	ldd	r25, Y+21	; 0x15
    ae66:	89 2b       	or	r24, r25
    ae68:	21 f0       	breq	.+8      	; 0xae72 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    ae6a:	ce 01       	movw	r24, r28
    ae6c:	0c 96       	adiw	r24, 0x0c	; 12
    ae6e:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    ae72:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    ae74:	9e 89       	ldd	r25, Y+22	; 0x16
    ae76:	80 91 1e 02 	lds	r24, 0x021E
    ae7a:	89 17       	cp	r24, r25
    ae7c:	10 f4       	brcc	.+4      	; 0xae82 <vCoRoutineSchedule+0x102>
    ae7e:	90 93 1e 02 	sts	0x021E, r25
    ae82:	9f 9d       	mul	r25, r15
    ae84:	c0 01       	movw	r24, r0
    ae86:	11 24       	eor	r1, r1
    ae88:	8b 5d       	subi	r24, 0xDB	; 219
    ae8a:	9d 4f       	sbci	r25, 0xFD	; 253
    ae8c:	b8 01       	movw	r22, r16
    ae8e:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    ae92:	e0 91 40 02 	lds	r30, 0x0240
    ae96:	f0 91 41 02 	lds	r31, 0x0241
    ae9a:	80 81       	ld	r24, Z
    ae9c:	88 23       	and	r24, r24
    ae9e:	39 f0       	breq	.+14     	; 0xaeae <vCoRoutineSchedule+0x12e>
    aea0:	05 80       	ldd	r0, Z+5	; 0x05
    aea2:	f6 81       	ldd	r31, Z+6	; 0x06
    aea4:	e0 2d       	mov	r30, r0
    aea6:	c6 81       	ldd	r28, Z+6	; 0x06
    aea8:	d7 81       	ldd	r29, Z+7	; 0x07
    aeaa:	20 97       	sbiw	r28, 0x00	; 0
    aeac:	51 f6       	brne	.-108    	; 0xae42 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    aeae:	20 91 21 02 	lds	r18, 0x0221
    aeb2:	30 91 22 02 	lds	r19, 0x0222
    aeb6:	80 91 23 02 	lds	r24, 0x0223
    aeba:	90 91 24 02 	lds	r25, 0x0224
    aebe:	21 15       	cp	r18, r1
    aec0:	31 05       	cpc	r19, r1
    aec2:	09 f0       	breq	.+2      	; 0xaec6 <vCoRoutineSchedule+0x146>
    aec4:	a0 cf       	rjmp	.-192    	; 0xae06 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    aec6:	90 93 20 02 	sts	0x0220, r25
    aeca:	80 93 1f 02 	sts	0x021F, r24
    aece:	90 91 1e 02 	lds	r25, 0x021E

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    aed2:	29 e0       	ldi	r18, 0x09	; 9
    aed4:	06 c0       	rjmp	.+12     	; 0xaee2 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    aed6:	99 23       	and	r25, r25
    aed8:	19 f4       	brne	.+6      	; 0xaee0 <vCoRoutineSchedule+0x160>
    aeda:	10 92 1e 02 	sts	0x021E, r1
    aede:	32 c0       	rjmp	.+100    	; 0xaf44 <vCoRoutineSchedule+0x1c4>
    aee0:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    aee2:	92 9f       	mul	r25, r18
    aee4:	d0 01       	movw	r26, r0
    aee6:	11 24       	eor	r1, r1
    aee8:	ab 5d       	subi	r26, 0xDB	; 219
    aeea:	bd 4f       	sbci	r27, 0xFD	; 253
    aeec:	8c 91       	ld	r24, X
    aeee:	88 23       	and	r24, r24
    aef0:	91 f3       	breq	.-28     	; 0xaed6 <vCoRoutineSchedule+0x156>
    aef2:	90 93 1e 02 	sts	0x021E, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    aef6:	11 96       	adiw	r26, 0x01	; 1
    aef8:	ed 91       	ld	r30, X+
    aefa:	fc 91       	ld	r31, X
    aefc:	12 97       	sbiw	r26, 0x02	; 2
    aefe:	02 80       	ldd	r0, Z+2	; 0x02
    af00:	f3 81       	ldd	r31, Z+3	; 0x03
    af02:	e0 2d       	mov	r30, r0
    af04:	12 96       	adiw	r26, 0x02	; 2
    af06:	fc 93       	st	X, r31
    af08:	ee 93       	st	-X, r30
    af0a:	11 97       	sbiw	r26, 0x01	; 1
    af0c:	cd 01       	movw	r24, r26
    af0e:	03 96       	adiw	r24, 0x03	; 3
    af10:	e8 17       	cp	r30, r24
    af12:	f9 07       	cpc	r31, r25
    af14:	31 f4       	brne	.+12     	; 0xaf22 <vCoRoutineSchedule+0x1a2>
    af16:	82 81       	ldd	r24, Z+2	; 0x02
    af18:	93 81       	ldd	r25, Z+3	; 0x03
    af1a:	12 96       	adiw	r26, 0x02	; 2
    af1c:	9c 93       	st	X, r25
    af1e:	8e 93       	st	-X, r24
    af20:	11 97       	sbiw	r26, 0x01	; 1
    af22:	11 96       	adiw	r26, 0x01	; 1
    af24:	ed 91       	ld	r30, X+
    af26:	fc 91       	ld	r31, X
    af28:	12 97       	sbiw	r26, 0x02	; 2
    af2a:	06 80       	ldd	r0, Z+6	; 0x06
    af2c:	f7 81       	ldd	r31, Z+7	; 0x07
    af2e:	e0 2d       	mov	r30, r0
    af30:	f0 93 1d 02 	sts	0x021D, r31
    af34:	e0 93 1c 02 	sts	0x021C, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    af38:	20 81       	ld	r18, Z
    af3a:	31 81       	ldd	r19, Z+1	; 0x01
    af3c:	cf 01       	movw	r24, r30
    af3e:	67 89       	ldd	r22, Z+23	; 0x17
    af40:	f9 01       	movw	r30, r18
    af42:	09 95       	icall

	return;
}
    af44:	df 91       	pop	r29
    af46:	cf 91       	pop	r28
    af48:	1f 91       	pop	r17
    af4a:	0f 91       	pop	r16
    af4c:	ff 90       	pop	r15
    af4e:	08 95       	ret

0000af50 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    af50:	0f 93       	push	r16
    af52:	1f 93       	push	r17
    af54:	cf 93       	push	r28
    af56:	df 93       	push	r29
    af58:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    af5a:	00 91 23 02 	lds	r16, 0x0223
    af5e:	10 91 24 02 	lds	r17, 0x0224
    af62:	08 0f       	add	r16, r24
    af64:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    af66:	80 91 1c 02 	lds	r24, 0x021C
    af6a:	90 91 1d 02 	lds	r25, 0x021D
    af6e:	02 96       	adiw	r24, 0x02	; 2
    af70:	0e 94 6d 56 	call	0xacda	; 0xacda <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    af74:	e0 91 1c 02 	lds	r30, 0x021C
    af78:	f0 91 1d 02 	lds	r31, 0x021D
    af7c:	13 83       	std	Z+3, r17	; 0x03
    af7e:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    af80:	80 91 23 02 	lds	r24, 0x0223
    af84:	90 91 24 02 	lds	r25, 0x0224
    af88:	bf 01       	movw	r22, r30
    af8a:	6e 5f       	subi	r22, 0xFE	; 254
    af8c:	7f 4f       	sbci	r23, 0xFF	; 255
    af8e:	08 17       	cp	r16, r24
    af90:	19 07       	cpc	r17, r25
    af92:	28 f4       	brcc	.+10     	; 0xaf9e <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    af94:	80 91 42 02 	lds	r24, 0x0242
    af98:	90 91 43 02 	lds	r25, 0x0243
    af9c:	04 c0       	rjmp	.+8      	; 0xafa6 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    af9e:	80 91 40 02 	lds	r24, 0x0240
    afa2:	90 91 41 02 	lds	r25, 0x0241
    afa6:	0e 94 38 56 	call	0xac70	; 0xac70 <vListInsert>
	}

	if( pxEventList )
    afaa:	20 97       	sbiw	r28, 0x00	; 0
    afac:	49 f0       	breq	.+18     	; 0xafc0 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    afae:	60 91 1c 02 	lds	r22, 0x021C
    afb2:	70 91 1d 02 	lds	r23, 0x021D
    afb6:	64 5f       	subi	r22, 0xF4	; 244
    afb8:	7f 4f       	sbci	r23, 0xFF	; 255
    afba:	ce 01       	movw	r24, r28
    afbc:	0e 94 38 56 	call	0xac70	; 0xac70 <vListInsert>
	}
}
    afc0:	df 91       	pop	r29
    afc2:	cf 91       	pop	r28
    afc4:	1f 91       	pop	r17
    afc6:	0f 91       	pop	r16
    afc8:	08 95       	ret

0000afca <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    afca:	bf 92       	push	r11
    afcc:	cf 92       	push	r12
    afce:	df 92       	push	r13
    afd0:	ef 92       	push	r14
    afd2:	ff 92       	push	r15
    afd4:	0f 93       	push	r16
    afd6:	1f 93       	push	r17
    afd8:	cf 93       	push	r28
    afda:	df 93       	push	r29
    afdc:	6c 01       	movw	r12, r24
    afde:	b4 2e       	mov	r11, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    afe0:	8a e1       	ldi	r24, 0x1A	; 26
    afe2:	90 e0       	ldi	r25, 0x00	; 0
    afe4:	0e 94 61 58 	call	0xb0c2	; 0xb0c2 <pvPortMalloc>
    afe8:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    afea:	00 97       	sbiw	r24, 0x00	; 0
    afec:	11 f4       	brne	.+4      	; 0xaff2 <xCoRoutineCreate+0x28>
    afee:	8f ef       	ldi	r24, 0xFF	; 255
    aff0:	4e c0       	rjmp	.+156    	; 0xb08e <xCoRoutineCreate+0xc4>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    aff2:	80 91 1c 02 	lds	r24, 0x021C
    aff6:	90 91 1d 02 	lds	r25, 0x021D
    affa:	89 2b       	or	r24, r25
    affc:	01 f5       	brne	.+64     	; 0xb03e <xCoRoutineCreate+0x74>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    affe:	d0 93 1d 02 	sts	0x021D, r29
    b002:	c0 93 1c 02 	sts	0x021C, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    b006:	85 e2       	ldi	r24, 0x25	; 37
    b008:	92 e0       	ldi	r25, 0x02	; 2
    b00a:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    b00e:	2e e2       	ldi	r18, 0x2E	; 46
    b010:	e2 2e       	mov	r14, r18
    b012:	22 e0       	ldi	r18, 0x02	; 2
    b014:	f2 2e       	mov	r15, r18
    b016:	c7 01       	movw	r24, r14
    b018:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    b01c:	07 e3       	ldi	r16, 0x37	; 55
    b01e:	12 e0       	ldi	r17, 0x02	; 2
    b020:	c8 01       	movw	r24, r16
    b022:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    b026:	84 e4       	ldi	r24, 0x44	; 68
    b028:	92 e0       	ldi	r25, 0x02	; 2
    b02a:	0e 94 fb 55 	call	0xabf6	; 0xabf6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    b02e:	f0 92 41 02 	sts	0x0241, r15
    b032:	e0 92 40 02 	sts	0x0240, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    b036:	10 93 43 02 	sts	0x0243, r17
    b03a:	00 93 42 02 	sts	0x0242, r16
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    b03e:	19 8e       	std	Y+25, r1	; 0x19
    b040:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    b042:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    b044:	bf 8a       	std	Y+23, r11	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    b046:	fe 01       	movw	r30, r28
    b048:	c1 92       	st	Z+, r12
    b04a:	d1 92       	st	Z+, r13
    b04c:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    b04e:	cf 01       	movw	r24, r30
    b050:	0e 94 0b 56 	call	0xac16	; 0xac16 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    b054:	ce 01       	movw	r24, r28
    b056:	0c 96       	adiw	r24, 0x0c	; 12
    b058:	0e 94 0b 56 	call	0xac16	; 0xac16 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    b05c:	d9 87       	std	Y+9, r29	; 0x09
    b05e:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    b060:	db 8b       	std	Y+19, r29	; 0x13
    b062:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    b064:	83 e0       	ldi	r24, 0x03	; 3
    b066:	90 e0       	ldi	r25, 0x00	; 0
    b068:	9d 87       	std	Y+13, r25	; 0x0d
    b06a:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    b06c:	9e 89       	ldd	r25, Y+22	; 0x16
    b06e:	80 91 1e 02 	lds	r24, 0x021E
    b072:	89 17       	cp	r24, r25
    b074:	10 f4       	brcc	.+4      	; 0xb07a <xCoRoutineCreate+0xb0>
    b076:	90 93 1e 02 	sts	0x021E, r25
    b07a:	89 e0       	ldi	r24, 0x09	; 9
    b07c:	98 9f       	mul	r25, r24
    b07e:	c0 01       	movw	r24, r0
    b080:	11 24       	eor	r1, r1
    b082:	8b 5d       	subi	r24, 0xDB	; 219
    b084:	9d 4f       	sbci	r25, 0xFD	; 253
    b086:	b8 01       	movw	r22, r16
    b088:	0e 94 0f 56 	call	0xac1e	; 0xac1e <vListInsertEnd>
    b08c:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    b08e:	df 91       	pop	r29
    b090:	cf 91       	pop	r28
    b092:	1f 91       	pop	r17
    b094:	0f 91       	pop	r16
    b096:	ff 90       	pop	r15
    b098:	ef 90       	pop	r14
    b09a:	df 90       	pop	r13
    b09c:	cf 90       	pop	r12
    b09e:	bf 90       	pop	r11
    b0a0:	08 95       	ret

0000b0a2 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    b0a2:	08 95       	ret

0000b0a4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    b0a4:	10 92 4e 02 	sts	0x024E, r1
    b0a8:	10 92 4d 02 	sts	0x024D, r1
}
    b0ac:	08 95       	ret

0000b0ae <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    b0ae:	2c e1       	ldi	r18, 0x1C	; 28
    b0b0:	3c e0       	ldi	r19, 0x0C	; 12
    b0b2:	80 91 4d 02 	lds	r24, 0x024D
    b0b6:	90 91 4e 02 	lds	r25, 0x024E
    b0ba:	28 1b       	sub	r18, r24
    b0bc:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    b0be:	c9 01       	movw	r24, r18
    b0c0:	08 95       	ret

0000b0c2 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    b0c2:	0f 93       	push	r16
    b0c4:	1f 93       	push	r17
    b0c6:	cf 93       	push	r28
    b0c8:	df 93       	push	r29
    b0ca:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    b0cc:	0e 94 f2 4b 	call	0x97e4	; 0x97e4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    b0d0:	80 91 4d 02 	lds	r24, 0x024D
    b0d4:	90 91 4e 02 	lds	r25, 0x024E
    b0d8:	98 01       	movw	r18, r16
    b0da:	28 0f       	add	r18, r24
    b0dc:	39 1f       	adc	r19, r25
    b0de:	4c e0       	ldi	r20, 0x0C	; 12
    b0e0:	2c 31       	cpi	r18, 0x1C	; 28
    b0e2:	34 07       	cpc	r19, r20
    b0e4:	58 f4       	brcc	.+22     	; 0xb0fc <pvPortMalloc+0x3a>
    b0e6:	82 17       	cp	r24, r18
    b0e8:	93 07       	cpc	r25, r19
    b0ea:	40 f4       	brcc	.+16     	; 0xb0fc <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    b0ec:	ec 01       	movw	r28, r24
    b0ee:	c1 5b       	subi	r28, 0xB1	; 177
    b0f0:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    b0f2:	30 93 4e 02 	sts	0x024E, r19
    b0f6:	20 93 4d 02 	sts	0x024D, r18
    b0fa:	02 c0       	rjmp	.+4      	; 0xb100 <pvPortMalloc+0x3e>
    b0fc:	c0 e0       	ldi	r28, 0x00	; 0
    b0fe:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    b100:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    b104:	ce 01       	movw	r24, r28
    b106:	df 91       	pop	r29
    b108:	cf 91       	pop	r28
    b10a:	1f 91       	pop	r17
    b10c:	0f 91       	pop	r16
    b10e:	08 95       	ret

0000b110 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    b110:	fc 01       	movw	r30, r24
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    b112:	91 e1       	ldi	r25, 0x11	; 17
    b114:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    b116:	22 e2       	ldi	r18, 0x22	; 34
    b118:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    b11a:	83 e3       	ldi	r24, 0x33	; 51
    b11c:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    b11e:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    b120:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    b122:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    b124:	80 e8       	ldi	r24, 0x80	; 128
    b126:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    b128:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    b12a:	82 e0       	ldi	r24, 0x02	; 2
    b12c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    b12e:	83 e0       	ldi	r24, 0x03	; 3
    b130:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    b132:	84 e0       	ldi	r24, 0x04	; 4
    b134:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    b136:	85 e0       	ldi	r24, 0x05	; 5
    b138:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    b13a:	86 e0       	ldi	r24, 0x06	; 6
    b13c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    b13e:	87 e0       	ldi	r24, 0x07	; 7
    b140:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    b142:	88 e0       	ldi	r24, 0x08	; 8
    b144:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    b146:	89 e0       	ldi	r24, 0x09	; 9
    b148:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    b14a:	80 e1       	ldi	r24, 0x10	; 16
    b14c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    b14e:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    b150:	82 e1       	ldi	r24, 0x12	; 18
    b152:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    b154:	83 e1       	ldi	r24, 0x13	; 19
    b156:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    b158:	84 e1       	ldi	r24, 0x14	; 20
    b15a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    b15c:	85 e1       	ldi	r24, 0x15	; 21
    b15e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    b160:	86 e1       	ldi	r24, 0x16	; 22
    b162:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    b164:	87 e1       	ldi	r24, 0x17	; 23
    b166:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    b168:	88 e1       	ldi	r24, 0x18	; 24
    b16a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    b16c:	89 e1       	ldi	r24, 0x19	; 25
    b16e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    b170:	80 e2       	ldi	r24, 0x20	; 32
    b172:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    b174:	81 e2       	ldi	r24, 0x21	; 33
    b176:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    b178:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    b17a:	83 e2       	ldi	r24, 0x23	; 35
    b17c:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    b17e:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    b180:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    b182:	86 e2       	ldi	r24, 0x26	; 38
    b184:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    b186:	87 e2       	ldi	r24, 0x27	; 39
    b188:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    b18a:	88 e2       	ldi	r24, 0x28	; 40
    b18c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    b18e:	89 e2       	ldi	r24, 0x29	; 41
    b190:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    b192:	80 e3       	ldi	r24, 0x30	; 48
    b194:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    b196:	81 e3       	ldi	r24, 0x31	; 49
    b198:	82 93       	st	-Z, r24
    b19a:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    b19c:	cf 01       	movw	r24, r30
    b19e:	08 95       	ret

0000b1a0 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	OCR1AH = ucHighByte;
    b1a0:	88 e0       	ldi	r24, 0x08	; 8
    b1a2:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
    b1a4:	8f ef       	ldi	r24, 0xFF	; 255
    b1a6:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    b1a8:	8b e0       	ldi	r24, 0x0B	; 11
    b1aa:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    b1ac:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    b1ae:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    b1b0:	87 bf       	out	0x37, r24	; 55
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    b1b2:	a0 91 93 01 	lds	r26, 0x0193
    b1b6:	b0 91 94 01 	lds	r27, 0x0194
    b1ba:	cd 91       	ld	r28, X+
    b1bc:	cd bf       	out	0x3d, r28	; 61
    b1be:	dd 91       	ld	r29, X+
    b1c0:	de bf       	out	0x3e, r29	; 62
    b1c2:	ff 91       	pop	r31
    b1c4:	ef 91       	pop	r30
    b1c6:	df 91       	pop	r29
    b1c8:	cf 91       	pop	r28
    b1ca:	bf 91       	pop	r27
    b1cc:	af 91       	pop	r26
    b1ce:	9f 91       	pop	r25
    b1d0:	8f 91       	pop	r24
    b1d2:	7f 91       	pop	r23
    b1d4:	6f 91       	pop	r22
    b1d6:	5f 91       	pop	r21
    b1d8:	4f 91       	pop	r20
    b1da:	3f 91       	pop	r19
    b1dc:	2f 91       	pop	r18
    b1de:	1f 91       	pop	r17
    b1e0:	0f 91       	pop	r16
    b1e2:	ff 90       	pop	r15
    b1e4:	ef 90       	pop	r14
    b1e6:	df 90       	pop	r13
    b1e8:	cf 90       	pop	r12
    b1ea:	bf 90       	pop	r11
    b1ec:	af 90       	pop	r10
    b1ee:	9f 90       	pop	r9
    b1f0:	8f 90       	pop	r8
    b1f2:	7f 90       	pop	r7
    b1f4:	6f 90       	pop	r6
    b1f6:	5f 90       	pop	r5
    b1f8:	4f 90       	pop	r4
    b1fa:	3f 90       	pop	r3
    b1fc:	2f 90       	pop	r2
    b1fe:	1f 90       	pop	r1
    b200:	0f 90       	pop	r0
    b202:	0f be       	out	0x3f, r0	; 63
    b204:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    b206:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    b208:	81 e0       	ldi	r24, 0x01	; 1
    b20a:	08 95       	ret

0000b20c <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    b20c:	08 95       	ret

0000b20e <__vector_12>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    b20e:	1f 92       	push	r1
    b210:	0f 92       	push	r0
    b212:	0f b6       	in	r0, 0x3f	; 63
    b214:	0f 92       	push	r0
    b216:	0b b6       	in	r0, 0x3b	; 59
    b218:	0f 92       	push	r0
    b21a:	11 24       	eor	r1, r1
    b21c:	2f 93       	push	r18
    b21e:	3f 93       	push	r19
    b220:	4f 93       	push	r20
    b222:	5f 93       	push	r21
    b224:	6f 93       	push	r22
    b226:	7f 93       	push	r23
    b228:	8f 93       	push	r24
    b22a:	9f 93       	push	r25
    b22c:	af 93       	push	r26
    b22e:	bf 93       	push	r27
    b230:	ef 93       	push	r30
    b232:	ff 93       	push	r31
		vTaskIncrementTick();
    b234:	0e 94 ef 4d 	call	0x9bde	; 0x9bde <vTaskIncrementTick>
	}
    b238:	ff 91       	pop	r31
    b23a:	ef 91       	pop	r30
    b23c:	bf 91       	pop	r27
    b23e:	af 91       	pop	r26
    b240:	9f 91       	pop	r25
    b242:	8f 91       	pop	r24
    b244:	7f 91       	pop	r23
    b246:	6f 91       	pop	r22
    b248:	5f 91       	pop	r21
    b24a:	4f 91       	pop	r20
    b24c:	3f 91       	pop	r19
    b24e:	2f 91       	pop	r18
    b250:	0f 90       	pop	r0
    b252:	0b be       	out	0x3b, r0	; 59
    b254:	0f 90       	pop	r0
    b256:	0f be       	out	0x3f, r0	; 63
    b258:	0f 90       	pop	r0
    b25a:	1f 90       	pop	r1
    b25c:	18 95       	reti

0000b25e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    b25e:	0f 92       	push	r0
    b260:	0f b6       	in	r0, 0x3f	; 63
    b262:	f8 94       	cli
    b264:	0f 92       	push	r0
    b266:	1f 92       	push	r1
    b268:	11 24       	eor	r1, r1
    b26a:	2f 92       	push	r2
    b26c:	3f 92       	push	r3
    b26e:	4f 92       	push	r4
    b270:	5f 92       	push	r5
    b272:	6f 92       	push	r6
    b274:	7f 92       	push	r7
    b276:	8f 92       	push	r8
    b278:	9f 92       	push	r9
    b27a:	af 92       	push	r10
    b27c:	bf 92       	push	r11
    b27e:	cf 92       	push	r12
    b280:	df 92       	push	r13
    b282:	ef 92       	push	r14
    b284:	ff 92       	push	r15
    b286:	0f 93       	push	r16
    b288:	1f 93       	push	r17
    b28a:	2f 93       	push	r18
    b28c:	3f 93       	push	r19
    b28e:	4f 93       	push	r20
    b290:	5f 93       	push	r21
    b292:	6f 93       	push	r22
    b294:	7f 93       	push	r23
    b296:	8f 93       	push	r24
    b298:	9f 93       	push	r25
    b29a:	af 93       	push	r26
    b29c:	bf 93       	push	r27
    b29e:	cf 93       	push	r28
    b2a0:	df 93       	push	r29
    b2a2:	ef 93       	push	r30
    b2a4:	ff 93       	push	r31
    b2a6:	a0 91 93 01 	lds	r26, 0x0193
    b2aa:	b0 91 94 01 	lds	r27, 0x0194
    b2ae:	0d b6       	in	r0, 0x3d	; 61
    b2b0:	0d 92       	st	X+, r0
    b2b2:	0e b6       	in	r0, 0x3e	; 62
    b2b4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    b2b6:	0e 94 ef 4d 	call	0x9bde	; 0x9bde <vTaskIncrementTick>
	vTaskSwitchContext();
    b2ba:	0e 94 37 4c 	call	0x986e	; 0x986e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    b2be:	a0 91 93 01 	lds	r26, 0x0193
    b2c2:	b0 91 94 01 	lds	r27, 0x0194
    b2c6:	cd 91       	ld	r28, X+
    b2c8:	cd bf       	out	0x3d, r28	; 61
    b2ca:	dd 91       	ld	r29, X+
    b2cc:	de bf       	out	0x3e, r29	; 62
    b2ce:	ff 91       	pop	r31
    b2d0:	ef 91       	pop	r30
    b2d2:	df 91       	pop	r29
    b2d4:	cf 91       	pop	r28
    b2d6:	bf 91       	pop	r27
    b2d8:	af 91       	pop	r26
    b2da:	9f 91       	pop	r25
    b2dc:	8f 91       	pop	r24
    b2de:	7f 91       	pop	r23
    b2e0:	6f 91       	pop	r22
    b2e2:	5f 91       	pop	r21
    b2e4:	4f 91       	pop	r20
    b2e6:	3f 91       	pop	r19
    b2e8:	2f 91       	pop	r18
    b2ea:	1f 91       	pop	r17
    b2ec:	0f 91       	pop	r16
    b2ee:	ff 90       	pop	r15
    b2f0:	ef 90       	pop	r14
    b2f2:	df 90       	pop	r13
    b2f4:	cf 90       	pop	r12
    b2f6:	bf 90       	pop	r11
    b2f8:	af 90       	pop	r10
    b2fa:	9f 90       	pop	r9
    b2fc:	8f 90       	pop	r8
    b2fe:	7f 90       	pop	r7
    b300:	6f 90       	pop	r6
    b302:	5f 90       	pop	r5
    b304:	4f 90       	pop	r4
    b306:	3f 90       	pop	r3
    b308:	2f 90       	pop	r2
    b30a:	1f 90       	pop	r1
    b30c:	0f 90       	pop	r0
    b30e:	0f be       	out	0x3f, r0	; 63
    b310:	0f 90       	pop	r0

	asm volatile ( "ret" );
    b312:	08 95       	ret

0000b314 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    b314:	0f 92       	push	r0
    b316:	0f b6       	in	r0, 0x3f	; 63
    b318:	f8 94       	cli
    b31a:	0f 92       	push	r0
    b31c:	1f 92       	push	r1
    b31e:	11 24       	eor	r1, r1
    b320:	2f 92       	push	r2
    b322:	3f 92       	push	r3
    b324:	4f 92       	push	r4
    b326:	5f 92       	push	r5
    b328:	6f 92       	push	r6
    b32a:	7f 92       	push	r7
    b32c:	8f 92       	push	r8
    b32e:	9f 92       	push	r9
    b330:	af 92       	push	r10
    b332:	bf 92       	push	r11
    b334:	cf 92       	push	r12
    b336:	df 92       	push	r13
    b338:	ef 92       	push	r14
    b33a:	ff 92       	push	r15
    b33c:	0f 93       	push	r16
    b33e:	1f 93       	push	r17
    b340:	2f 93       	push	r18
    b342:	3f 93       	push	r19
    b344:	4f 93       	push	r20
    b346:	5f 93       	push	r21
    b348:	6f 93       	push	r22
    b34a:	7f 93       	push	r23
    b34c:	8f 93       	push	r24
    b34e:	9f 93       	push	r25
    b350:	af 93       	push	r26
    b352:	bf 93       	push	r27
    b354:	cf 93       	push	r28
    b356:	df 93       	push	r29
    b358:	ef 93       	push	r30
    b35a:	ff 93       	push	r31
    b35c:	a0 91 93 01 	lds	r26, 0x0193
    b360:	b0 91 94 01 	lds	r27, 0x0194
    b364:	0d b6       	in	r0, 0x3d	; 61
    b366:	0d 92       	st	X+, r0
    b368:	0e b6       	in	r0, 0x3e	; 62
    b36a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    b36c:	0e 94 37 4c 	call	0x986e	; 0x986e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    b370:	a0 91 93 01 	lds	r26, 0x0193
    b374:	b0 91 94 01 	lds	r27, 0x0194
    b378:	cd 91       	ld	r28, X+
    b37a:	cd bf       	out	0x3d, r28	; 61
    b37c:	dd 91       	ld	r29, X+
    b37e:	de bf       	out	0x3e, r29	; 62
    b380:	ff 91       	pop	r31
    b382:	ef 91       	pop	r30
    b384:	df 91       	pop	r29
    b386:	cf 91       	pop	r28
    b388:	bf 91       	pop	r27
    b38a:	af 91       	pop	r26
    b38c:	9f 91       	pop	r25
    b38e:	8f 91       	pop	r24
    b390:	7f 91       	pop	r23
    b392:	6f 91       	pop	r22
    b394:	5f 91       	pop	r21
    b396:	4f 91       	pop	r20
    b398:	3f 91       	pop	r19
    b39a:	2f 91       	pop	r18
    b39c:	1f 91       	pop	r17
    b39e:	0f 91       	pop	r16
    b3a0:	ff 90       	pop	r15
    b3a2:	ef 90       	pop	r14
    b3a4:	df 90       	pop	r13
    b3a6:	cf 90       	pop	r12
    b3a8:	bf 90       	pop	r11
    b3aa:	af 90       	pop	r10
    b3ac:	9f 90       	pop	r9
    b3ae:	8f 90       	pop	r8
    b3b0:	7f 90       	pop	r7
    b3b2:	6f 90       	pop	r6
    b3b4:	5f 90       	pop	r5
    b3b6:	4f 90       	pop	r4
    b3b8:	3f 90       	pop	r3
    b3ba:	2f 90       	pop	r2
    b3bc:	1f 90       	pop	r1
    b3be:	0f 90       	pop	r0
    b3c0:	0f be       	out	0x3f, r0	; 63
    b3c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    b3c4:	08 95       	ret

0000b3c6 <__udivmodqi4>:
    b3c6:	99 1b       	sub	r25, r25
    b3c8:	79 e0       	ldi	r23, 0x09	; 9
    b3ca:	04 c0       	rjmp	.+8      	; 0xb3d4 <__udivmodqi4_ep>

0000b3cc <__udivmodqi4_loop>:
    b3cc:	99 1f       	adc	r25, r25
    b3ce:	96 17       	cp	r25, r22
    b3d0:	08 f0       	brcs	.+2      	; 0xb3d4 <__udivmodqi4_ep>
    b3d2:	96 1b       	sub	r25, r22

0000b3d4 <__udivmodqi4_ep>:
    b3d4:	88 1f       	adc	r24, r24
    b3d6:	7a 95       	dec	r23
    b3d8:	c9 f7       	brne	.-14     	; 0xb3cc <__udivmodqi4_loop>
    b3da:	80 95       	com	r24
    b3dc:	08 95       	ret

0000b3de <__udivmodhi4>:
    b3de:	aa 1b       	sub	r26, r26
    b3e0:	bb 1b       	sub	r27, r27
    b3e2:	51 e1       	ldi	r21, 0x11	; 17
    b3e4:	07 c0       	rjmp	.+14     	; 0xb3f4 <__udivmodhi4_ep>

0000b3e6 <__udivmodhi4_loop>:
    b3e6:	aa 1f       	adc	r26, r26
    b3e8:	bb 1f       	adc	r27, r27
    b3ea:	a6 17       	cp	r26, r22
    b3ec:	b7 07       	cpc	r27, r23
    b3ee:	10 f0       	brcs	.+4      	; 0xb3f4 <__udivmodhi4_ep>
    b3f0:	a6 1b       	sub	r26, r22
    b3f2:	b7 0b       	sbc	r27, r23

0000b3f4 <__udivmodhi4_ep>:
    b3f4:	88 1f       	adc	r24, r24
    b3f6:	99 1f       	adc	r25, r25
    b3f8:	5a 95       	dec	r21
    b3fa:	a9 f7       	brne	.-22     	; 0xb3e6 <__udivmodhi4_loop>
    b3fc:	80 95       	com	r24
    b3fe:	90 95       	com	r25
    b400:	bc 01       	movw	r22, r24
    b402:	cd 01       	movw	r24, r26
    b404:	08 95       	ret

0000b406 <malloc>:
    b406:	cf 93       	push	r28
    b408:	df 93       	push	r29
    b40a:	bc 01       	movw	r22, r24
    b40c:	82 30       	cpi	r24, 0x02	; 2
    b40e:	91 05       	cpc	r25, r1
    b410:	10 f4       	brcc	.+4      	; 0xb416 <malloc+0x10>
    b412:	62 e0       	ldi	r22, 0x02	; 2
    b414:	70 e0       	ldi	r23, 0x00	; 0
    b416:	a0 91 df 0f 	lds	r26, 0x0FDF
    b41a:	b0 91 e0 0f 	lds	r27, 0x0FE0
    b41e:	ed 01       	movw	r28, r26
    b420:	e0 e0       	ldi	r30, 0x00	; 0
    b422:	f0 e0       	ldi	r31, 0x00	; 0
    b424:	40 e0       	ldi	r20, 0x00	; 0
    b426:	50 e0       	ldi	r21, 0x00	; 0
    b428:	21 c0       	rjmp	.+66     	; 0xb46c <malloc+0x66>
    b42a:	88 81       	ld	r24, Y
    b42c:	99 81       	ldd	r25, Y+1	; 0x01
    b42e:	86 17       	cp	r24, r22
    b430:	97 07       	cpc	r25, r23
    b432:	69 f4       	brne	.+26     	; 0xb44e <malloc+0x48>
    b434:	8a 81       	ldd	r24, Y+2	; 0x02
    b436:	9b 81       	ldd	r25, Y+3	; 0x03
    b438:	30 97       	sbiw	r30, 0x00	; 0
    b43a:	19 f0       	breq	.+6      	; 0xb442 <malloc+0x3c>
    b43c:	93 83       	std	Z+3, r25	; 0x03
    b43e:	82 83       	std	Z+2, r24	; 0x02
    b440:	04 c0       	rjmp	.+8      	; 0xb44a <malloc+0x44>
    b442:	90 93 e0 0f 	sts	0x0FE0, r25
    b446:	80 93 df 0f 	sts	0x0FDF, r24
    b44a:	fe 01       	movw	r30, r28
    b44c:	34 c0       	rjmp	.+104    	; 0xb4b6 <malloc+0xb0>
    b44e:	68 17       	cp	r22, r24
    b450:	79 07       	cpc	r23, r25
    b452:	38 f4       	brcc	.+14     	; 0xb462 <malloc+0x5c>
    b454:	41 15       	cp	r20, r1
    b456:	51 05       	cpc	r21, r1
    b458:	19 f0       	breq	.+6      	; 0xb460 <malloc+0x5a>
    b45a:	84 17       	cp	r24, r20
    b45c:	95 07       	cpc	r25, r21
    b45e:	08 f4       	brcc	.+2      	; 0xb462 <malloc+0x5c>
    b460:	ac 01       	movw	r20, r24
    b462:	fe 01       	movw	r30, r28
    b464:	8a 81       	ldd	r24, Y+2	; 0x02
    b466:	9b 81       	ldd	r25, Y+3	; 0x03
    b468:	9c 01       	movw	r18, r24
    b46a:	e9 01       	movw	r28, r18
    b46c:	20 97       	sbiw	r28, 0x00	; 0
    b46e:	e9 f6       	brne	.-70     	; 0xb42a <malloc+0x24>
    b470:	41 15       	cp	r20, r1
    b472:	51 05       	cpc	r21, r1
    b474:	a9 f1       	breq	.+106    	; 0xb4e0 <malloc+0xda>
    b476:	ca 01       	movw	r24, r20
    b478:	86 1b       	sub	r24, r22
    b47a:	97 0b       	sbc	r25, r23
    b47c:	04 97       	sbiw	r24, 0x04	; 4
    b47e:	08 f4       	brcc	.+2      	; 0xb482 <malloc+0x7c>
    b480:	ba 01       	movw	r22, r20
    b482:	e0 e0       	ldi	r30, 0x00	; 0
    b484:	f0 e0       	ldi	r31, 0x00	; 0
    b486:	2a c0       	rjmp	.+84     	; 0xb4dc <malloc+0xd6>
    b488:	8d 91       	ld	r24, X+
    b48a:	9c 91       	ld	r25, X
    b48c:	11 97       	sbiw	r26, 0x01	; 1
    b48e:	84 17       	cp	r24, r20
    b490:	95 07       	cpc	r25, r21
    b492:	f9 f4       	brne	.+62     	; 0xb4d2 <malloc+0xcc>
    b494:	64 17       	cp	r22, r20
    b496:	75 07       	cpc	r23, r21
    b498:	81 f4       	brne	.+32     	; 0xb4ba <malloc+0xb4>
    b49a:	12 96       	adiw	r26, 0x02	; 2
    b49c:	8d 91       	ld	r24, X+
    b49e:	9c 91       	ld	r25, X
    b4a0:	13 97       	sbiw	r26, 0x03	; 3
    b4a2:	30 97       	sbiw	r30, 0x00	; 0
    b4a4:	19 f0       	breq	.+6      	; 0xb4ac <malloc+0xa6>
    b4a6:	93 83       	std	Z+3, r25	; 0x03
    b4a8:	82 83       	std	Z+2, r24	; 0x02
    b4aa:	04 c0       	rjmp	.+8      	; 0xb4b4 <malloc+0xae>
    b4ac:	90 93 e0 0f 	sts	0x0FE0, r25
    b4b0:	80 93 df 0f 	sts	0x0FDF, r24
    b4b4:	fd 01       	movw	r30, r26
    b4b6:	32 96       	adiw	r30, 0x02	; 2
    b4b8:	4f c0       	rjmp	.+158    	; 0xb558 <malloc+0x152>
    b4ba:	ca 01       	movw	r24, r20
    b4bc:	86 1b       	sub	r24, r22
    b4be:	97 0b       	sbc	r25, r23
    b4c0:	fd 01       	movw	r30, r26
    b4c2:	e8 0f       	add	r30, r24
    b4c4:	f9 1f       	adc	r31, r25
    b4c6:	61 93       	st	Z+, r22
    b4c8:	71 93       	st	Z+, r23
    b4ca:	02 97       	sbiw	r24, 0x02	; 2
    b4cc:	8d 93       	st	X+, r24
    b4ce:	9c 93       	st	X, r25
    b4d0:	43 c0       	rjmp	.+134    	; 0xb558 <malloc+0x152>
    b4d2:	fd 01       	movw	r30, r26
    b4d4:	82 81       	ldd	r24, Z+2	; 0x02
    b4d6:	93 81       	ldd	r25, Z+3	; 0x03
    b4d8:	9c 01       	movw	r18, r24
    b4da:	d9 01       	movw	r26, r18
    b4dc:	10 97       	sbiw	r26, 0x00	; 0
    b4de:	a1 f6       	brne	.-88     	; 0xb488 <malloc+0x82>
    b4e0:	80 91 dd 0f 	lds	r24, 0x0FDD
    b4e4:	90 91 de 0f 	lds	r25, 0x0FDE
    b4e8:	89 2b       	or	r24, r25
    b4ea:	41 f4       	brne	.+16     	; 0xb4fc <malloc+0xf6>
    b4ec:	80 91 84 01 	lds	r24, 0x0184
    b4f0:	90 91 85 01 	lds	r25, 0x0185
    b4f4:	90 93 de 0f 	sts	0x0FDE, r25
    b4f8:	80 93 dd 0f 	sts	0x0FDD, r24
    b4fc:	40 91 86 01 	lds	r20, 0x0186
    b500:	50 91 87 01 	lds	r21, 0x0187
    b504:	41 15       	cp	r20, r1
    b506:	51 05       	cpc	r21, r1
    b508:	41 f4       	brne	.+16     	; 0xb51a <malloc+0x114>
    b50a:	4d b7       	in	r20, 0x3d	; 61
    b50c:	5e b7       	in	r21, 0x3e	; 62
    b50e:	80 91 82 01 	lds	r24, 0x0182
    b512:	90 91 83 01 	lds	r25, 0x0183
    b516:	48 1b       	sub	r20, r24
    b518:	59 0b       	sbc	r21, r25
    b51a:	20 91 dd 0f 	lds	r18, 0x0FDD
    b51e:	30 91 de 0f 	lds	r19, 0x0FDE
    b522:	24 17       	cp	r18, r20
    b524:	35 07       	cpc	r19, r21
    b526:	b0 f4       	brcc	.+44     	; 0xb554 <malloc+0x14e>
    b528:	ca 01       	movw	r24, r20
    b52a:	82 1b       	sub	r24, r18
    b52c:	93 0b       	sbc	r25, r19
    b52e:	86 17       	cp	r24, r22
    b530:	97 07       	cpc	r25, r23
    b532:	80 f0       	brcs	.+32     	; 0xb554 <malloc+0x14e>
    b534:	ab 01       	movw	r20, r22
    b536:	4e 5f       	subi	r20, 0xFE	; 254
    b538:	5f 4f       	sbci	r21, 0xFF	; 255
    b53a:	84 17       	cp	r24, r20
    b53c:	95 07       	cpc	r25, r21
    b53e:	50 f0       	brcs	.+20     	; 0xb554 <malloc+0x14e>
    b540:	42 0f       	add	r20, r18
    b542:	53 1f       	adc	r21, r19
    b544:	50 93 de 0f 	sts	0x0FDE, r21
    b548:	40 93 dd 0f 	sts	0x0FDD, r20
    b54c:	f9 01       	movw	r30, r18
    b54e:	61 93       	st	Z+, r22
    b550:	71 93       	st	Z+, r23
    b552:	02 c0       	rjmp	.+4      	; 0xb558 <malloc+0x152>
    b554:	e0 e0       	ldi	r30, 0x00	; 0
    b556:	f0 e0       	ldi	r31, 0x00	; 0
    b558:	cf 01       	movw	r24, r30
    b55a:	df 91       	pop	r29
    b55c:	cf 91       	pop	r28
    b55e:	08 95       	ret

0000b560 <free>:
    b560:	cf 93       	push	r28
    b562:	df 93       	push	r29
    b564:	00 97       	sbiw	r24, 0x00	; 0
    b566:	09 f4       	brne	.+2      	; 0xb56a <free+0xa>
    b568:	50 c0       	rjmp	.+160    	; 0xb60a <free+0xaa>
    b56a:	ec 01       	movw	r28, r24
    b56c:	22 97       	sbiw	r28, 0x02	; 2
    b56e:	1b 82       	std	Y+3, r1	; 0x03
    b570:	1a 82       	std	Y+2, r1	; 0x02
    b572:	a0 91 df 0f 	lds	r26, 0x0FDF
    b576:	b0 91 e0 0f 	lds	r27, 0x0FE0
    b57a:	10 97       	sbiw	r26, 0x00	; 0
    b57c:	09 f1       	breq	.+66     	; 0xb5c0 <free+0x60>
    b57e:	40 e0       	ldi	r20, 0x00	; 0
    b580:	50 e0       	ldi	r21, 0x00	; 0
    b582:	ac 17       	cp	r26, r28
    b584:	bd 07       	cpc	r27, r29
    b586:	08 f1       	brcs	.+66     	; 0xb5ca <free+0x6a>
    b588:	bb 83       	std	Y+3, r27	; 0x03
    b58a:	aa 83       	std	Y+2, r26	; 0x02
    b58c:	fe 01       	movw	r30, r28
    b58e:	21 91       	ld	r18, Z+
    b590:	31 91       	ld	r19, Z+
    b592:	e2 0f       	add	r30, r18
    b594:	f3 1f       	adc	r31, r19
    b596:	ae 17       	cp	r26, r30
    b598:	bf 07       	cpc	r27, r31
    b59a:	79 f4       	brne	.+30     	; 0xb5ba <free+0x5a>
    b59c:	8d 91       	ld	r24, X+
    b59e:	9c 91       	ld	r25, X
    b5a0:	11 97       	sbiw	r26, 0x01	; 1
    b5a2:	28 0f       	add	r18, r24
    b5a4:	39 1f       	adc	r19, r25
    b5a6:	2e 5f       	subi	r18, 0xFE	; 254
    b5a8:	3f 4f       	sbci	r19, 0xFF	; 255
    b5aa:	39 83       	std	Y+1, r19	; 0x01
    b5ac:	28 83       	st	Y, r18
    b5ae:	12 96       	adiw	r26, 0x02	; 2
    b5b0:	8d 91       	ld	r24, X+
    b5b2:	9c 91       	ld	r25, X
    b5b4:	13 97       	sbiw	r26, 0x03	; 3
    b5b6:	9b 83       	std	Y+3, r25	; 0x03
    b5b8:	8a 83       	std	Y+2, r24	; 0x02
    b5ba:	41 15       	cp	r20, r1
    b5bc:	51 05       	cpc	r21, r1
    b5be:	71 f4       	brne	.+28     	; 0xb5dc <free+0x7c>
    b5c0:	d0 93 e0 0f 	sts	0x0FE0, r29
    b5c4:	c0 93 df 0f 	sts	0x0FDF, r28
    b5c8:	20 c0       	rjmp	.+64     	; 0xb60a <free+0xaa>
    b5ca:	12 96       	adiw	r26, 0x02	; 2
    b5cc:	8d 91       	ld	r24, X+
    b5ce:	9c 91       	ld	r25, X
    b5d0:	13 97       	sbiw	r26, 0x03	; 3
    b5d2:	ad 01       	movw	r20, r26
    b5d4:	00 97       	sbiw	r24, 0x00	; 0
    b5d6:	11 f0       	breq	.+4      	; 0xb5dc <free+0x7c>
    b5d8:	dc 01       	movw	r26, r24
    b5da:	d3 cf       	rjmp	.-90     	; 0xb582 <free+0x22>
    b5dc:	fa 01       	movw	r30, r20
    b5de:	d3 83       	std	Z+3, r29	; 0x03
    b5e0:	c2 83       	std	Z+2, r28	; 0x02
    b5e2:	21 91       	ld	r18, Z+
    b5e4:	31 91       	ld	r19, Z+
    b5e6:	e2 0f       	add	r30, r18
    b5e8:	f3 1f       	adc	r31, r19
    b5ea:	ce 17       	cp	r28, r30
    b5ec:	df 07       	cpc	r29, r31
    b5ee:	69 f4       	brne	.+26     	; 0xb60a <free+0xaa>
    b5f0:	88 81       	ld	r24, Y
    b5f2:	99 81       	ldd	r25, Y+1	; 0x01
    b5f4:	28 0f       	add	r18, r24
    b5f6:	39 1f       	adc	r19, r25
    b5f8:	2e 5f       	subi	r18, 0xFE	; 254
    b5fa:	3f 4f       	sbci	r19, 0xFF	; 255
    b5fc:	fa 01       	movw	r30, r20
    b5fe:	31 83       	std	Z+1, r19	; 0x01
    b600:	20 83       	st	Z, r18
    b602:	8a 81       	ldd	r24, Y+2	; 0x02
    b604:	9b 81       	ldd	r25, Y+3	; 0x03
    b606:	93 83       	std	Z+3, r25	; 0x03
    b608:	82 83       	std	Z+2, r24	; 0x02
    b60a:	df 91       	pop	r29
    b60c:	cf 91       	pop	r28
    b60e:	08 95       	ret

0000b610 <strtol>:
    b610:	2f 92       	push	r2
    b612:	3f 92       	push	r3
    b614:	5f 92       	push	r5
    b616:	6f 92       	push	r6
    b618:	7f 92       	push	r7
    b61a:	8f 92       	push	r8
    b61c:	9f 92       	push	r9
    b61e:	af 92       	push	r10
    b620:	bf 92       	push	r11
    b622:	cf 92       	push	r12
    b624:	df 92       	push	r13
    b626:	ef 92       	push	r14
    b628:	ff 92       	push	r15
    b62a:	0f 93       	push	r16
    b62c:	1f 93       	push	r17
    b62e:	cf 93       	push	r28
    b630:	df 93       	push	r29
    b632:	8c 01       	movw	r16, r24
    b634:	1b 01       	movw	r2, r22
    b636:	ea 01       	movw	r28, r20
    b638:	61 15       	cp	r22, r1
    b63a:	71 05       	cpc	r23, r1
    b63c:	19 f0       	breq	.+6      	; 0xb644 <strtol+0x34>
    b63e:	fb 01       	movw	r30, r22
    b640:	91 83       	std	Z+1, r25	; 0x01
    b642:	80 83       	st	Z, r24
    b644:	20 97       	sbiw	r28, 0x00	; 0
    b646:	49 f0       	breq	.+18     	; 0xb65a <strtol+0x4a>
    b648:	ce 01       	movw	r24, r28
    b64a:	02 97       	sbiw	r24, 0x02	; 2
    b64c:	83 97       	sbiw	r24, 0x23	; 35
    b64e:	28 f0       	brcs	.+10     	; 0xb65a <strtol+0x4a>
    b650:	20 e0       	ldi	r18, 0x00	; 0
    b652:	30 e0       	ldi	r19, 0x00	; 0
    b654:	40 e0       	ldi	r20, 0x00	; 0
    b656:	50 e0       	ldi	r21, 0x00	; 0
    b658:	f6 c0       	rjmp	.+492    	; 0xb846 <strtol+0x236>
    b65a:	f8 01       	movw	r30, r16
    b65c:	a1 90       	ld	r10, Z+
    b65e:	8f 01       	movw	r16, r30
    b660:	8a 2d       	mov	r24, r10
    b662:	90 e0       	ldi	r25, 0x00	; 0
    b664:	0e 94 37 5c 	call	0xb86e	; 0xb86e <isspace>
    b668:	89 2b       	or	r24, r25
    b66a:	b9 f7       	brne	.-18     	; 0xb65a <strtol+0x4a>
    b66c:	fd e2       	ldi	r31, 0x2D	; 45
    b66e:	af 16       	cp	r10, r31
    b670:	31 f4       	brne	.+12     	; 0xb67e <strtol+0x6e>
    b672:	f8 01       	movw	r30, r16
    b674:	a1 90       	ld	r10, Z+
    b676:	8f 01       	movw	r16, r30
    b678:	55 24       	eor	r5, r5
    b67a:	53 94       	inc	r5
    b67c:	07 c0       	rjmp	.+14     	; 0xb68c <strtol+0x7c>
    b67e:	fb e2       	ldi	r31, 0x2B	; 43
    b680:	af 16       	cp	r10, r31
    b682:	19 f4       	brne	.+6      	; 0xb68a <strtol+0x7a>
    b684:	f8 01       	movw	r30, r16
    b686:	a1 90       	ld	r10, Z+
    b688:	8f 01       	movw	r16, r30
    b68a:	55 24       	eor	r5, r5
    b68c:	20 97       	sbiw	r28, 0x00	; 0
    b68e:	19 f0       	breq	.+6      	; 0xb696 <strtol+0x86>
    b690:	c0 31       	cpi	r28, 0x10	; 16
    b692:	d1 05       	cpc	r29, r1
    b694:	c1 f4       	brne	.+48     	; 0xb6c6 <strtol+0xb6>
    b696:	f0 e3       	ldi	r31, 0x30	; 48
    b698:	af 16       	cp	r10, r31
    b69a:	79 f4       	brne	.+30     	; 0xb6ba <strtol+0xaa>
    b69c:	f8 01       	movw	r30, r16
    b69e:	80 81       	ld	r24, Z
    b6a0:	88 37       	cpi	r24, 0x78	; 120
    b6a2:	11 f0       	breq	.+4      	; 0xb6a8 <strtol+0x98>
    b6a4:	88 35       	cpi	r24, 0x58	; 88
    b6a6:	49 f4       	brne	.+18     	; 0xb6ba <strtol+0xaa>
    b6a8:	f8 01       	movw	r30, r16
    b6aa:	a1 80       	ldd	r10, Z+1	; 0x01
    b6ac:	0e 5f       	subi	r16, 0xFE	; 254
    b6ae:	1f 4f       	sbci	r17, 0xFF	; 255
    b6b0:	f2 e0       	ldi	r31, 0x02	; 2
    b6b2:	5f 2a       	or	r5, r31
    b6b4:	c0 e1       	ldi	r28, 0x10	; 16
    b6b6:	d0 e0       	ldi	r29, 0x00	; 0
    b6b8:	06 c0       	rjmp	.+12     	; 0xb6c6 <strtol+0xb6>
    b6ba:	20 97       	sbiw	r28, 0x00	; 0
    b6bc:	21 f4       	brne	.+8      	; 0xb6c6 <strtol+0xb6>
    b6be:	80 e3       	ldi	r24, 0x30	; 48
    b6c0:	a8 16       	cp	r10, r24
    b6c2:	e9 f4       	brne	.+58     	; 0xb6fe <strtol+0xee>
    b6c4:	27 c0       	rjmp	.+78     	; 0xb714 <strtol+0x104>
    b6c6:	c8 30       	cpi	r28, 0x08	; 8
    b6c8:	d1 05       	cpc	r29, r1
    b6ca:	31 f1       	breq	.+76     	; 0xb718 <strtol+0x108>
    b6cc:	c9 30       	cpi	r28, 0x09	; 9
    b6ce:	d1 05       	cpc	r29, r1
    b6d0:	24 f4       	brge	.+8      	; 0xb6da <strtol+0xca>
    b6d2:	c2 30       	cpi	r28, 0x02	; 2
    b6d4:	d1 05       	cpc	r29, r1
    b6d6:	31 f5       	brne	.+76     	; 0xb724 <strtol+0x114>
    b6d8:	0c c0       	rjmp	.+24     	; 0xb6f2 <strtol+0xe2>
    b6da:	ca 30       	cpi	r28, 0x0A	; 10
    b6dc:	d1 05       	cpc	r29, r1
    b6de:	89 f0       	breq	.+34     	; 0xb702 <strtol+0xf2>
    b6e0:	c0 31       	cpi	r28, 0x10	; 16
    b6e2:	d1 05       	cpc	r29, r1
    b6e4:	f9 f4       	brne	.+62     	; 0xb724 <strtol+0x114>
    b6e6:	c1 2c       	mov	r12, r1
    b6e8:	d1 2c       	mov	r13, r1
    b6ea:	e1 2c       	mov	r14, r1
    b6ec:	b8 e0       	ldi	r27, 0x08	; 8
    b6ee:	fb 2e       	mov	r15, r27
    b6f0:	28 c0       	rjmp	.+80     	; 0xb742 <strtol+0x132>
    b6f2:	c1 2c       	mov	r12, r1
    b6f4:	d1 2c       	mov	r13, r1
    b6f6:	e1 2c       	mov	r14, r1
    b6f8:	a0 e4       	ldi	r26, 0x40	; 64
    b6fa:	fa 2e       	mov	r15, r26
    b6fc:	22 c0       	rjmp	.+68     	; 0xb742 <strtol+0x132>
    b6fe:	ca e0       	ldi	r28, 0x0A	; 10
    b700:	d0 e0       	ldi	r29, 0x00	; 0
    b702:	fc ec       	ldi	r31, 0xCC	; 204
    b704:	cf 2e       	mov	r12, r31
    b706:	fc ec       	ldi	r31, 0xCC	; 204
    b708:	df 2e       	mov	r13, r31
    b70a:	fc ec       	ldi	r31, 0xCC	; 204
    b70c:	ef 2e       	mov	r14, r31
    b70e:	fc e0       	ldi	r31, 0x0C	; 12
    b710:	ff 2e       	mov	r15, r31
    b712:	17 c0       	rjmp	.+46     	; 0xb742 <strtol+0x132>
    b714:	c8 e0       	ldi	r28, 0x08	; 8
    b716:	d0 e0       	ldi	r29, 0x00	; 0
    b718:	c1 2c       	mov	r12, r1
    b71a:	d1 2c       	mov	r13, r1
    b71c:	e1 2c       	mov	r14, r1
    b71e:	e0 e1       	ldi	r30, 0x10	; 16
    b720:	fe 2e       	mov	r15, r30
    b722:	0f c0       	rjmp	.+30     	; 0xb742 <strtol+0x132>
    b724:	9e 01       	movw	r18, r28
    b726:	44 27       	eor	r20, r20
    b728:	37 fd       	sbrc	r19, 7
    b72a:	40 95       	com	r20
    b72c:	54 2f       	mov	r21, r20
    b72e:	60 e0       	ldi	r22, 0x00	; 0
    b730:	70 e0       	ldi	r23, 0x00	; 0
    b732:	80 e0       	ldi	r24, 0x00	; 0
    b734:	90 e8       	ldi	r25, 0x80	; 128
    b736:	0e 94 a4 60 	call	0xc148	; 0xc148 <__udivmodsi4>
    b73a:	c9 01       	movw	r24, r18
    b73c:	da 01       	movw	r26, r20
    b73e:	6c 01       	movw	r12, r24
    b740:	7d 01       	movw	r14, r26
    b742:	20 e0       	ldi	r18, 0x00	; 0
    b744:	30 e0       	ldi	r19, 0x00	; 0
    b746:	40 e0       	ldi	r20, 0x00	; 0
    b748:	50 e0       	ldi	r21, 0x00	; 0
    b74a:	60 e0       	ldi	r22, 0x00	; 0
    b74c:	3e 01       	movw	r6, r28
    b74e:	88 24       	eor	r8, r8
    b750:	77 fc       	sbrc	r7, 7
    b752:	80 94       	com	r8
    b754:	98 2c       	mov	r9, r8
    b756:	70 ed       	ldi	r23, 0xD0	; 208
    b758:	b7 2e       	mov	r11, r23
    b75a:	ba 0c       	add	r11, r10
    b75c:	e9 e0       	ldi	r30, 0x09	; 9
    b75e:	eb 15       	cp	r30, r11
    b760:	70 f4       	brcc	.+28     	; 0xb77e <strtol+0x16e>
    b762:	8a 2d       	mov	r24, r10
    b764:	81 54       	subi	r24, 0x41	; 65
    b766:	8a 31       	cpi	r24, 0x1A	; 26
    b768:	18 f4       	brcc	.+6      	; 0xb770 <strtol+0x160>
    b76a:	99 ec       	ldi	r25, 0xC9	; 201
    b76c:	b9 2e       	mov	r11, r25
    b76e:	06 c0       	rjmp	.+12     	; 0xb77c <strtol+0x16c>
    b770:	8a 2d       	mov	r24, r10
    b772:	81 56       	subi	r24, 0x61	; 97
    b774:	8a 31       	cpi	r24, 0x1A	; 26
    b776:	50 f5       	brcc	.+84     	; 0xb7cc <strtol+0x1bc>
    b778:	89 ea       	ldi	r24, 0xA9	; 169
    b77a:	b8 2e       	mov	r11, r24
    b77c:	ba 0c       	add	r11, r10
    b77e:	8b 2d       	mov	r24, r11
    b780:	90 e0       	ldi	r25, 0x00	; 0
    b782:	8c 17       	cp	r24, r28
    b784:	9d 07       	cpc	r25, r29
    b786:	14 f5       	brge	.+68     	; 0xb7cc <strtol+0x1bc>
    b788:	6f 3f       	cpi	r22, 0xFF	; 255
    b78a:	e1 f0       	breq	.+56     	; 0xb7c4 <strtol+0x1b4>
    b78c:	c2 16       	cp	r12, r18
    b78e:	d3 06       	cpc	r13, r19
    b790:	e4 06       	cpc	r14, r20
    b792:	f5 06       	cpc	r15, r21
    b794:	b0 f0       	brcs	.+44     	; 0xb7c2 <strtol+0x1b2>
    b796:	ca 01       	movw	r24, r20
    b798:	b9 01       	movw	r22, r18
    b79a:	a4 01       	movw	r20, r8
    b79c:	93 01       	movw	r18, r6
    b79e:	0e 94 85 60 	call	0xc10a	; 0xc10a <__mulsi3>
    b7a2:	9b 01       	movw	r18, r22
    b7a4:	ac 01       	movw	r20, r24
    b7a6:	2b 0d       	add	r18, r11
    b7a8:	31 1d       	adc	r19, r1
    b7aa:	41 1d       	adc	r20, r1
    b7ac:	51 1d       	adc	r21, r1
    b7ae:	21 30       	cpi	r18, 0x01	; 1
    b7b0:	f0 e0       	ldi	r31, 0x00	; 0
    b7b2:	3f 07       	cpc	r19, r31
    b7b4:	f0 e0       	ldi	r31, 0x00	; 0
    b7b6:	4f 07       	cpc	r20, r31
    b7b8:	f0 e8       	ldi	r31, 0x80	; 128
    b7ba:	5f 07       	cpc	r21, r31
    b7bc:	10 f4       	brcc	.+4      	; 0xb7c2 <strtol+0x1b2>
    b7be:	61 e0       	ldi	r22, 0x01	; 1
    b7c0:	01 c0       	rjmp	.+2      	; 0xb7c4 <strtol+0x1b4>
    b7c2:	6f ef       	ldi	r22, 0xFF	; 255
    b7c4:	f8 01       	movw	r30, r16
    b7c6:	a1 90       	ld	r10, Z+
    b7c8:	8f 01       	movw	r16, r30
    b7ca:	c5 cf       	rjmp	.-118    	; 0xb756 <strtol+0x146>
    b7cc:	21 14       	cp	r2, r1
    b7ce:	31 04       	cpc	r3, r1
    b7d0:	81 f0       	breq	.+32     	; 0xb7f2 <strtol+0x1e2>
    b7d2:	66 23       	and	r22, r22
    b7d4:	31 f0       	breq	.+12     	; 0xb7e2 <strtol+0x1d2>
    b7d6:	01 50       	subi	r16, 0x01	; 1
    b7d8:	10 40       	sbci	r17, 0x00	; 0
    b7da:	f1 01       	movw	r30, r2
    b7dc:	11 83       	std	Z+1, r17	; 0x01
    b7de:	00 83       	st	Z, r16
    b7e0:	08 c0       	rjmp	.+16     	; 0xb7f2 <strtol+0x1e2>
    b7e2:	51 fe       	sbrs	r5, 1
    b7e4:	1a c0       	rjmp	.+52     	; 0xb81a <strtol+0x20a>
    b7e6:	02 50       	subi	r16, 0x02	; 2
    b7e8:	10 40       	sbci	r17, 0x00	; 0
    b7ea:	f1 01       	movw	r30, r2
    b7ec:	11 83       	std	Z+1, r17	; 0x01
    b7ee:	00 83       	st	Z, r16
    b7f0:	14 c0       	rjmp	.+40     	; 0xb81a <strtol+0x20a>
    b7f2:	67 ff       	sbrs	r22, 7
    b7f4:	12 c0       	rjmp	.+36     	; 0xb81a <strtol+0x20a>
    b7f6:	50 fc       	sbrc	r5, 0
    b7f8:	05 c0       	rjmp	.+10     	; 0xb804 <strtol+0x1f4>
    b7fa:	2f ef       	ldi	r18, 0xFF	; 255
    b7fc:	3f ef       	ldi	r19, 0xFF	; 255
    b7fe:	4f ef       	ldi	r20, 0xFF	; 255
    b800:	5f e7       	ldi	r21, 0x7F	; 127
    b802:	04 c0       	rjmp	.+8      	; 0xb80c <strtol+0x1fc>
    b804:	20 e0       	ldi	r18, 0x00	; 0
    b806:	30 e0       	ldi	r19, 0x00	; 0
    b808:	40 e0       	ldi	r20, 0x00	; 0
    b80a:	50 e8       	ldi	r21, 0x80	; 128
    b80c:	82 e2       	ldi	r24, 0x22	; 34
    b80e:	90 e0       	ldi	r25, 0x00	; 0
    b810:	90 93 e8 0f 	sts	0x0FE8, r25
    b814:	80 93 e7 0f 	sts	0x0FE7, r24
    b818:	16 c0       	rjmp	.+44     	; 0xb846 <strtol+0x236>
    b81a:	50 fe       	sbrs	r5, 0
    b81c:	08 c0       	rjmp	.+16     	; 0xb82e <strtol+0x21e>
    b81e:	50 95       	com	r21
    b820:	40 95       	com	r20
    b822:	30 95       	com	r19
    b824:	21 95       	neg	r18
    b826:	3f 4f       	sbci	r19, 0xFF	; 255
    b828:	4f 4f       	sbci	r20, 0xFF	; 255
    b82a:	5f 4f       	sbci	r21, 0xFF	; 255
    b82c:	0c c0       	rjmp	.+24     	; 0xb846 <strtol+0x236>
    b82e:	57 ff       	sbrs	r21, 7
    b830:	0a c0       	rjmp	.+20     	; 0xb846 <strtol+0x236>
    b832:	82 e2       	ldi	r24, 0x22	; 34
    b834:	90 e0       	ldi	r25, 0x00	; 0
    b836:	90 93 e8 0f 	sts	0x0FE8, r25
    b83a:	80 93 e7 0f 	sts	0x0FE7, r24
    b83e:	2f ef       	ldi	r18, 0xFF	; 255
    b840:	3f ef       	ldi	r19, 0xFF	; 255
    b842:	4f ef       	ldi	r20, 0xFF	; 255
    b844:	5f e7       	ldi	r21, 0x7F	; 127
    b846:	b9 01       	movw	r22, r18
    b848:	ca 01       	movw	r24, r20
    b84a:	df 91       	pop	r29
    b84c:	cf 91       	pop	r28
    b84e:	1f 91       	pop	r17
    b850:	0f 91       	pop	r16
    b852:	ff 90       	pop	r15
    b854:	ef 90       	pop	r14
    b856:	df 90       	pop	r13
    b858:	cf 90       	pop	r12
    b85a:	bf 90       	pop	r11
    b85c:	af 90       	pop	r10
    b85e:	9f 90       	pop	r9
    b860:	8f 90       	pop	r8
    b862:	7f 90       	pop	r7
    b864:	6f 90       	pop	r6
    b866:	5f 90       	pop	r5
    b868:	3f 90       	pop	r3
    b86a:	2f 90       	pop	r2
    b86c:	08 95       	ret

0000b86e <isspace>:
    b86e:	91 11       	cpse	r25, r1
    b870:	d5 c3       	rjmp	.+1962   	; 0xc01c <__ctype_isfalse>
    b872:	80 32       	cpi	r24, 0x20	; 32
    b874:	19 f0       	breq	.+6      	; 0xb87c <isspace+0xe>
    b876:	89 50       	subi	r24, 0x09	; 9
    b878:	85 50       	subi	r24, 0x05	; 5
    b87a:	d0 f7       	brcc	.-12     	; 0xb870 <isspace+0x2>
    b87c:	08 95       	ret

0000b87e <memcpy_P>:
    b87e:	fb 01       	movw	r30, r22
    b880:	dc 01       	movw	r26, r24
    b882:	02 c0       	rjmp	.+4      	; 0xb888 <memcpy_P+0xa>
    b884:	05 90       	lpm	r0, Z+
    b886:	0d 92       	st	X+, r0
    b888:	41 50       	subi	r20, 0x01	; 1
    b88a:	50 40       	sbci	r21, 0x00	; 0
    b88c:	d8 f7       	brcc	.-10     	; 0xb884 <memcpy_P+0x6>
    b88e:	08 95       	ret

0000b890 <strncmp_P>:
    b890:	fb 01       	movw	r30, r22
    b892:	dc 01       	movw	r26, r24
    b894:	41 50       	subi	r20, 0x01	; 1
    b896:	50 40       	sbci	r21, 0x00	; 0
    b898:	30 f0       	brcs	.+12     	; 0xb8a6 <strncmp_P+0x16>
    b89a:	8d 91       	ld	r24, X+
    b89c:	05 90       	lpm	r0, Z+
    b89e:	80 19       	sub	r24, r0
    b8a0:	19 f4       	brne	.+6      	; 0xb8a8 <strncmp_P+0x18>
    b8a2:	00 20       	and	r0, r0
    b8a4:	b9 f7       	brne	.-18     	; 0xb894 <strncmp_P+0x4>
    b8a6:	88 1b       	sub	r24, r24
    b8a8:	99 0b       	sbc	r25, r25
    b8aa:	08 95       	ret

0000b8ac <memcpy>:
    b8ac:	fb 01       	movw	r30, r22
    b8ae:	dc 01       	movw	r26, r24
    b8b0:	02 c0       	rjmp	.+4      	; 0xb8b6 <memcpy+0xa>
    b8b2:	01 90       	ld	r0, Z+
    b8b4:	0d 92       	st	X+, r0
    b8b6:	41 50       	subi	r20, 0x01	; 1
    b8b8:	50 40       	sbci	r21, 0x00	; 0
    b8ba:	d8 f7       	brcc	.-10     	; 0xb8b2 <memcpy+0x6>
    b8bc:	08 95       	ret

0000b8be <memset>:
    b8be:	dc 01       	movw	r26, r24
    b8c0:	01 c0       	rjmp	.+2      	; 0xb8c4 <memset+0x6>
    b8c2:	6d 93       	st	X+, r22
    b8c4:	41 50       	subi	r20, 0x01	; 1
    b8c6:	50 40       	sbci	r21, 0x00	; 0
    b8c8:	e0 f7       	brcc	.-8      	; 0xb8c2 <memset+0x4>
    b8ca:	08 95       	ret

0000b8cc <strcat>:
    b8cc:	fb 01       	movw	r30, r22
    b8ce:	dc 01       	movw	r26, r24
    b8d0:	0d 90       	ld	r0, X+
    b8d2:	00 20       	and	r0, r0
    b8d4:	e9 f7       	brne	.-6      	; 0xb8d0 <strcat+0x4>
    b8d6:	11 97       	sbiw	r26, 0x01	; 1
    b8d8:	01 90       	ld	r0, Z+
    b8da:	0d 92       	st	X+, r0
    b8dc:	00 20       	and	r0, r0
    b8de:	e1 f7       	brne	.-8      	; 0xb8d8 <strcat+0xc>
    b8e0:	08 95       	ret

0000b8e2 <strcpy>:
    b8e2:	fb 01       	movw	r30, r22
    b8e4:	dc 01       	movw	r26, r24
    b8e6:	01 90       	ld	r0, Z+
    b8e8:	0d 92       	st	X+, r0
    b8ea:	00 20       	and	r0, r0
    b8ec:	e1 f7       	brne	.-8      	; 0xb8e6 <strcpy+0x4>
    b8ee:	08 95       	ret

0000b8f0 <strncmp>:
    b8f0:	fb 01       	movw	r30, r22
    b8f2:	dc 01       	movw	r26, r24
    b8f4:	41 50       	subi	r20, 0x01	; 1
    b8f6:	50 40       	sbci	r21, 0x00	; 0
    b8f8:	30 f0       	brcs	.+12     	; 0xb906 <strncmp+0x16>
    b8fa:	8d 91       	ld	r24, X+
    b8fc:	01 90       	ld	r0, Z+
    b8fe:	80 19       	sub	r24, r0
    b900:	19 f4       	brne	.+6      	; 0xb908 <strncmp+0x18>
    b902:	00 20       	and	r0, r0
    b904:	b9 f7       	brne	.-18     	; 0xb8f4 <strncmp+0x4>
    b906:	88 1b       	sub	r24, r24
    b908:	99 0b       	sbc	r25, r25
    b90a:	08 95       	ret

0000b90c <strncpy>:
    b90c:	fb 01       	movw	r30, r22
    b90e:	dc 01       	movw	r26, r24
    b910:	41 50       	subi	r20, 0x01	; 1
    b912:	50 40       	sbci	r21, 0x00	; 0
    b914:	48 f0       	brcs	.+18     	; 0xb928 <strncpy+0x1c>
    b916:	01 90       	ld	r0, Z+
    b918:	0d 92       	st	X+, r0
    b91a:	00 20       	and	r0, r0
    b91c:	c9 f7       	brne	.-14     	; 0xb910 <strncpy+0x4>
    b91e:	01 c0       	rjmp	.+2      	; 0xb922 <strncpy+0x16>
    b920:	1d 92       	st	X+, r1
    b922:	41 50       	subi	r20, 0x01	; 1
    b924:	50 40       	sbci	r21, 0x00	; 0
    b926:	e0 f7       	brcc	.-8      	; 0xb920 <strncpy+0x14>
    b928:	08 95       	ret

0000b92a <fclose>:
    b92a:	fc 01       	movw	r30, r24
    b92c:	83 81       	ldd	r24, Z+3	; 0x03
    b92e:	87 ff       	sbrs	r24, 7
    b930:	24 c0       	rjmp	.+72     	; 0xb97a <fclose+0x50>
    b932:	80 91 e1 0f 	lds	r24, 0x0FE1
    b936:	90 91 e2 0f 	lds	r25, 0x0FE2
    b93a:	8e 17       	cp	r24, r30
    b93c:	9f 07       	cpc	r25, r31
    b93e:	21 f4       	brne	.+8      	; 0xb948 <fclose+0x1e>
    b940:	10 92 e2 0f 	sts	0x0FE2, r1
    b944:	10 92 e1 0f 	sts	0x0FE1, r1
    b948:	80 91 e3 0f 	lds	r24, 0x0FE3
    b94c:	90 91 e4 0f 	lds	r25, 0x0FE4
    b950:	8e 17       	cp	r24, r30
    b952:	9f 07       	cpc	r25, r31
    b954:	21 f4       	brne	.+8      	; 0xb95e <fclose+0x34>
    b956:	10 92 e4 0f 	sts	0x0FE4, r1
    b95a:	10 92 e3 0f 	sts	0x0FE3, r1
    b95e:	80 91 e5 0f 	lds	r24, 0x0FE5
    b962:	90 91 e6 0f 	lds	r25, 0x0FE6
    b966:	8e 17       	cp	r24, r30
    b968:	9f 07       	cpc	r25, r31
    b96a:	21 f4       	brne	.+8      	; 0xb974 <fclose+0x4a>
    b96c:	10 92 e6 0f 	sts	0x0FE6, r1
    b970:	10 92 e5 0f 	sts	0x0FE5, r1
    b974:	cf 01       	movw	r24, r30
    b976:	0e 94 b0 5a 	call	0xb560	; 0xb560 <free>
    b97a:	80 e0       	ldi	r24, 0x00	; 0
    b97c:	90 e0       	ldi	r25, 0x00	; 0
    b97e:	08 95       	ret

0000b980 <fgetc>:
    b980:	cf 93       	push	r28
    b982:	df 93       	push	r29
    b984:	ec 01       	movw	r28, r24
    b986:	4b 81       	ldd	r20, Y+3	; 0x03
    b988:	40 ff       	sbrs	r20, 0
    b98a:	1a c0       	rjmp	.+52     	; 0xb9c0 <fgetc+0x40>
    b98c:	46 ff       	sbrs	r20, 6
    b98e:	0a c0       	rjmp	.+20     	; 0xb9a4 <fgetc+0x24>
    b990:	4f 7b       	andi	r20, 0xBF	; 191
    b992:	4b 83       	std	Y+3, r20	; 0x03
    b994:	8e 81       	ldd	r24, Y+6	; 0x06
    b996:	9f 81       	ldd	r25, Y+7	; 0x07
    b998:	01 96       	adiw	r24, 0x01	; 1
    b99a:	9f 83       	std	Y+7, r25	; 0x07
    b99c:	8e 83       	std	Y+6, r24	; 0x06
    b99e:	8a 81       	ldd	r24, Y+2	; 0x02
    b9a0:	28 2f       	mov	r18, r24
    b9a2:	2b c0       	rjmp	.+86     	; 0xb9fa <fgetc+0x7a>
    b9a4:	42 ff       	sbrs	r20, 2
    b9a6:	13 c0       	rjmp	.+38     	; 0xb9ce <fgetc+0x4e>
    b9a8:	e8 81       	ld	r30, Y
    b9aa:	f9 81       	ldd	r31, Y+1	; 0x01
    b9ac:	80 81       	ld	r24, Z
    b9ae:	28 2f       	mov	r18, r24
    b9b0:	33 27       	eor	r19, r19
    b9b2:	27 fd       	sbrc	r18, 7
    b9b4:	30 95       	com	r19
    b9b6:	21 15       	cp	r18, r1
    b9b8:	31 05       	cpc	r19, r1
    b9ba:	29 f4       	brne	.+10     	; 0xb9c6 <fgetc+0x46>
    b9bc:	40 62       	ori	r20, 0x20	; 32
    b9be:	4b 83       	std	Y+3, r20	; 0x03
    b9c0:	2f ef       	ldi	r18, 0xFF	; 255
    b9c2:	3f ef       	ldi	r19, 0xFF	; 255
    b9c4:	1b c0       	rjmp	.+54     	; 0xb9fc <fgetc+0x7c>
    b9c6:	31 96       	adiw	r30, 0x01	; 1
    b9c8:	f9 83       	std	Y+1, r31	; 0x01
    b9ca:	e8 83       	st	Y, r30
    b9cc:	11 c0       	rjmp	.+34     	; 0xb9f0 <fgetc+0x70>
    b9ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    b9d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    b9d2:	ce 01       	movw	r24, r28
    b9d4:	09 95       	icall
    b9d6:	9c 01       	movw	r18, r24
    b9d8:	97 ff       	sbrs	r25, 7
    b9da:	0a c0       	rjmp	.+20     	; 0xb9f0 <fgetc+0x70>
    b9dc:	9b 81       	ldd	r25, Y+3	; 0x03
    b9de:	2f 5f       	subi	r18, 0xFF	; 255
    b9e0:	3f 4f       	sbci	r19, 0xFF	; 255
    b9e2:	11 f0       	breq	.+4      	; 0xb9e8 <fgetc+0x68>
    b9e4:	80 e2       	ldi	r24, 0x20	; 32
    b9e6:	01 c0       	rjmp	.+2      	; 0xb9ea <fgetc+0x6a>
    b9e8:	80 e1       	ldi	r24, 0x10	; 16
    b9ea:	89 2b       	or	r24, r25
    b9ec:	8b 83       	std	Y+3, r24	; 0x03
    b9ee:	e8 cf       	rjmp	.-48     	; 0xb9c0 <fgetc+0x40>
    b9f0:	8e 81       	ldd	r24, Y+6	; 0x06
    b9f2:	9f 81       	ldd	r25, Y+7	; 0x07
    b9f4:	01 96       	adiw	r24, 0x01	; 1
    b9f6:	9f 83       	std	Y+7, r25	; 0x07
    b9f8:	8e 83       	std	Y+6, r24	; 0x06
    b9fa:	30 e0       	ldi	r19, 0x00	; 0
    b9fc:	c9 01       	movw	r24, r18
    b9fe:	df 91       	pop	r29
    ba00:	cf 91       	pop	r28
    ba02:	08 95       	ret

0000ba04 <fprintf>:
    ba04:	df 93       	push	r29
    ba06:	cf 93       	push	r28
    ba08:	cd b7       	in	r28, 0x3d	; 61
    ba0a:	de b7       	in	r29, 0x3e	; 62
    ba0c:	9e 01       	movw	r18, r28
    ba0e:	27 5f       	subi	r18, 0xF7	; 247
    ba10:	3f 4f       	sbci	r19, 0xFF	; 255
    ba12:	8d 81       	ldd	r24, Y+5	; 0x05
    ba14:	9e 81       	ldd	r25, Y+6	; 0x06
    ba16:	6f 81       	ldd	r22, Y+7	; 0x07
    ba18:	78 85       	ldd	r23, Y+8	; 0x08
    ba1a:	a9 01       	movw	r20, r18
    ba1c:	0e 94 b9 5d 	call	0xbb72	; 0xbb72 <vfprintf>
    ba20:	cf 91       	pop	r28
    ba22:	df 91       	pop	r29
    ba24:	08 95       	ret

0000ba26 <fprintf_P>:
    ba26:	0f 93       	push	r16
    ba28:	1f 93       	push	r17
    ba2a:	df 93       	push	r29
    ba2c:	cf 93       	push	r28
    ba2e:	cd b7       	in	r28, 0x3d	; 61
    ba30:	de b7       	in	r29, 0x3e	; 62
    ba32:	0f 81       	ldd	r16, Y+7	; 0x07
    ba34:	18 85       	ldd	r17, Y+8	; 0x08
    ba36:	9e 01       	movw	r18, r28
    ba38:	25 5f       	subi	r18, 0xF5	; 245
    ba3a:	3f 4f       	sbci	r19, 0xFF	; 255
    ba3c:	f8 01       	movw	r30, r16
    ba3e:	83 81       	ldd	r24, Z+3	; 0x03
    ba40:	88 60       	ori	r24, 0x08	; 8
    ba42:	83 83       	std	Z+3, r24	; 0x03
    ba44:	c8 01       	movw	r24, r16
    ba46:	69 85       	ldd	r22, Y+9	; 0x09
    ba48:	7a 85       	ldd	r23, Y+10	; 0x0a
    ba4a:	a9 01       	movw	r20, r18
    ba4c:	0e 94 b9 5d 	call	0xbb72	; 0xbb72 <vfprintf>
    ba50:	f8 01       	movw	r30, r16
    ba52:	23 81       	ldd	r18, Z+3	; 0x03
    ba54:	27 7f       	andi	r18, 0xF7	; 247
    ba56:	23 83       	std	Z+3, r18	; 0x03
    ba58:	cf 91       	pop	r28
    ba5a:	df 91       	pop	r29
    ba5c:	1f 91       	pop	r17
    ba5e:	0f 91       	pop	r16
    ba60:	08 95       	ret

0000ba62 <fputc>:
    ba62:	0f 93       	push	r16
    ba64:	1f 93       	push	r17
    ba66:	cf 93       	push	r28
    ba68:	df 93       	push	r29
    ba6a:	8c 01       	movw	r16, r24
    ba6c:	eb 01       	movw	r28, r22
    ba6e:	8b 81       	ldd	r24, Y+3	; 0x03
    ba70:	81 ff       	sbrs	r24, 1
    ba72:	1b c0       	rjmp	.+54     	; 0xbaaa <fputc+0x48>
    ba74:	82 ff       	sbrs	r24, 2
    ba76:	0d c0       	rjmp	.+26     	; 0xba92 <fputc+0x30>
    ba78:	2e 81       	ldd	r18, Y+6	; 0x06
    ba7a:	3f 81       	ldd	r19, Y+7	; 0x07
    ba7c:	8c 81       	ldd	r24, Y+4	; 0x04
    ba7e:	9d 81       	ldd	r25, Y+5	; 0x05
    ba80:	28 17       	cp	r18, r24
    ba82:	39 07       	cpc	r19, r25
    ba84:	64 f4       	brge	.+24     	; 0xba9e <fputc+0x3c>
    ba86:	e8 81       	ld	r30, Y
    ba88:	f9 81       	ldd	r31, Y+1	; 0x01
    ba8a:	01 93       	st	Z+, r16
    ba8c:	f9 83       	std	Y+1, r31	; 0x01
    ba8e:	e8 83       	st	Y, r30
    ba90:	06 c0       	rjmp	.+12     	; 0xba9e <fputc+0x3c>
    ba92:	e8 85       	ldd	r30, Y+8	; 0x08
    ba94:	f9 85       	ldd	r31, Y+9	; 0x09
    ba96:	80 2f       	mov	r24, r16
    ba98:	09 95       	icall
    ba9a:	89 2b       	or	r24, r25
    ba9c:	31 f4       	brne	.+12     	; 0xbaaa <fputc+0x48>
    ba9e:	8e 81       	ldd	r24, Y+6	; 0x06
    baa0:	9f 81       	ldd	r25, Y+7	; 0x07
    baa2:	01 96       	adiw	r24, 0x01	; 1
    baa4:	9f 83       	std	Y+7, r25	; 0x07
    baa6:	8e 83       	std	Y+6, r24	; 0x06
    baa8:	02 c0       	rjmp	.+4      	; 0xbaae <fputc+0x4c>
    baaa:	0f ef       	ldi	r16, 0xFF	; 255
    baac:	1f ef       	ldi	r17, 0xFF	; 255
    baae:	c8 01       	movw	r24, r16
    bab0:	df 91       	pop	r29
    bab2:	cf 91       	pop	r28
    bab4:	1f 91       	pop	r17
    bab6:	0f 91       	pop	r16
    bab8:	08 95       	ret

0000baba <fputs>:
    baba:	ef 92       	push	r14
    babc:	ff 92       	push	r15
    babe:	0f 93       	push	r16
    bac0:	1f 93       	push	r17
    bac2:	cf 93       	push	r28
    bac4:	df 93       	push	r29
    bac6:	7c 01       	movw	r14, r24
    bac8:	8b 01       	movw	r16, r22
    baca:	db 01       	movw	r26, r22
    bacc:	13 96       	adiw	r26, 0x03	; 3
    bace:	8c 91       	ld	r24, X
    bad0:	81 fd       	sbrc	r24, 1
    bad2:	03 c0       	rjmp	.+6      	; 0xbada <fputs+0x20>
    bad4:	cf ef       	ldi	r28, 0xFF	; 255
    bad6:	df ef       	ldi	r29, 0xFF	; 255
    bad8:	13 c0       	rjmp	.+38     	; 0xbb00 <fputs+0x46>
    bada:	c0 e0       	ldi	r28, 0x00	; 0
    badc:	d0 e0       	ldi	r29, 0x00	; 0
    bade:	0b c0       	rjmp	.+22     	; 0xbaf6 <fputs+0x3c>
    bae0:	d8 01       	movw	r26, r16
    bae2:	18 96       	adiw	r26, 0x08	; 8
    bae4:	ed 91       	ld	r30, X+
    bae6:	fc 91       	ld	r31, X
    bae8:	19 97       	sbiw	r26, 0x09	; 9
    baea:	b8 01       	movw	r22, r16
    baec:	09 95       	icall
    baee:	89 2b       	or	r24, r25
    baf0:	11 f0       	breq	.+4      	; 0xbaf6 <fputs+0x3c>
    baf2:	cf ef       	ldi	r28, 0xFF	; 255
    baf4:	df ef       	ldi	r29, 0xFF	; 255
    baf6:	f7 01       	movw	r30, r14
    baf8:	81 91       	ld	r24, Z+
    bafa:	7f 01       	movw	r14, r30
    bafc:	88 23       	and	r24, r24
    bafe:	81 f7       	brne	.-32     	; 0xbae0 <fputs+0x26>
    bb00:	ce 01       	movw	r24, r28
    bb02:	df 91       	pop	r29
    bb04:	cf 91       	pop	r28
    bb06:	1f 91       	pop	r17
    bb08:	0f 91       	pop	r16
    bb0a:	ff 90       	pop	r15
    bb0c:	ef 90       	pop	r14
    bb0e:	08 95       	ret

0000bb10 <sprintf>:
    bb10:	0f 93       	push	r16
    bb12:	1f 93       	push	r17
    bb14:	df 93       	push	r29
    bb16:	cf 93       	push	r28
    bb18:	cd b7       	in	r28, 0x3d	; 61
    bb1a:	de b7       	in	r29, 0x3e	; 62
    bb1c:	2e 97       	sbiw	r28, 0x0e	; 14
    bb1e:	0f b6       	in	r0, 0x3f	; 63
    bb20:	f8 94       	cli
    bb22:	de bf       	out	0x3e, r29	; 62
    bb24:	0f be       	out	0x3f, r0	; 63
    bb26:	cd bf       	out	0x3d, r28	; 61
    bb28:	0d 89       	ldd	r16, Y+21	; 0x15
    bb2a:	1e 89       	ldd	r17, Y+22	; 0x16
    bb2c:	86 e0       	ldi	r24, 0x06	; 6
    bb2e:	8c 83       	std	Y+4, r24	; 0x04
    bb30:	1a 83       	std	Y+2, r17	; 0x02
    bb32:	09 83       	std	Y+1, r16	; 0x01
    bb34:	8f ef       	ldi	r24, 0xFF	; 255
    bb36:	9f e7       	ldi	r25, 0x7F	; 127
    bb38:	9e 83       	std	Y+6, r25	; 0x06
    bb3a:	8d 83       	std	Y+5, r24	; 0x05
    bb3c:	9e 01       	movw	r18, r28
    bb3e:	27 5e       	subi	r18, 0xE7	; 231
    bb40:	3f 4f       	sbci	r19, 0xFF	; 255
    bb42:	ce 01       	movw	r24, r28
    bb44:	01 96       	adiw	r24, 0x01	; 1
    bb46:	6f 89       	ldd	r22, Y+23	; 0x17
    bb48:	78 8d       	ldd	r23, Y+24	; 0x18
    bb4a:	a9 01       	movw	r20, r18
    bb4c:	0e 94 b9 5d 	call	0xbb72	; 0xbb72 <vfprintf>
    bb50:	2f 81       	ldd	r18, Y+7	; 0x07
    bb52:	38 85       	ldd	r19, Y+8	; 0x08
    bb54:	02 0f       	add	r16, r18
    bb56:	13 1f       	adc	r17, r19
    bb58:	f8 01       	movw	r30, r16
    bb5a:	10 82       	st	Z, r1
    bb5c:	2e 96       	adiw	r28, 0x0e	; 14
    bb5e:	0f b6       	in	r0, 0x3f	; 63
    bb60:	f8 94       	cli
    bb62:	de bf       	out	0x3e, r29	; 62
    bb64:	0f be       	out	0x3f, r0	; 63
    bb66:	cd bf       	out	0x3d, r28	; 61
    bb68:	cf 91       	pop	r28
    bb6a:	df 91       	pop	r29
    bb6c:	1f 91       	pop	r17
    bb6e:	0f 91       	pop	r16
    bb70:	08 95       	ret

0000bb72 <vfprintf>:
    bb72:	2f 92       	push	r2
    bb74:	3f 92       	push	r3
    bb76:	4f 92       	push	r4
    bb78:	5f 92       	push	r5
    bb7a:	6f 92       	push	r6
    bb7c:	7f 92       	push	r7
    bb7e:	8f 92       	push	r8
    bb80:	9f 92       	push	r9
    bb82:	af 92       	push	r10
    bb84:	bf 92       	push	r11
    bb86:	cf 92       	push	r12
    bb88:	df 92       	push	r13
    bb8a:	ef 92       	push	r14
    bb8c:	ff 92       	push	r15
    bb8e:	0f 93       	push	r16
    bb90:	1f 93       	push	r17
    bb92:	df 93       	push	r29
    bb94:	cf 93       	push	r28
    bb96:	cd b7       	in	r28, 0x3d	; 61
    bb98:	de b7       	in	r29, 0x3e	; 62
    bb9a:	2b 97       	sbiw	r28, 0x0b	; 11
    bb9c:	0f b6       	in	r0, 0x3f	; 63
    bb9e:	f8 94       	cli
    bba0:	de bf       	out	0x3e, r29	; 62
    bba2:	0f be       	out	0x3f, r0	; 63
    bba4:	cd bf       	out	0x3d, r28	; 61
    bba6:	3c 01       	movw	r6, r24
    bba8:	2b 01       	movw	r4, r22
    bbaa:	5a 01       	movw	r10, r20
    bbac:	fc 01       	movw	r30, r24
    bbae:	17 82       	std	Z+7, r1	; 0x07
    bbb0:	16 82       	std	Z+6, r1	; 0x06
    bbb2:	83 81       	ldd	r24, Z+3	; 0x03
    bbb4:	81 fd       	sbrc	r24, 1
    bbb6:	03 c0       	rjmp	.+6      	; 0xbbbe <vfprintf+0x4c>
    bbb8:	6f ef       	ldi	r22, 0xFF	; 255
    bbba:	7f ef       	ldi	r23, 0xFF	; 255
    bbbc:	c6 c1       	rjmp	.+908    	; 0xbf4a <vfprintf+0x3d8>
    bbbe:	9a e0       	ldi	r25, 0x0A	; 10
    bbc0:	89 2e       	mov	r8, r25
    bbc2:	1e 01       	movw	r2, r28
    bbc4:	08 94       	sec
    bbc6:	21 1c       	adc	r2, r1
    bbc8:	31 1c       	adc	r3, r1
    bbca:	f3 01       	movw	r30, r6
    bbcc:	23 81       	ldd	r18, Z+3	; 0x03
    bbce:	f2 01       	movw	r30, r4
    bbd0:	23 fd       	sbrc	r18, 3
    bbd2:	85 91       	lpm	r24, Z+
    bbd4:	23 ff       	sbrs	r18, 3
    bbd6:	81 91       	ld	r24, Z+
    bbd8:	2f 01       	movw	r4, r30
    bbda:	88 23       	and	r24, r24
    bbdc:	09 f4       	brne	.+2      	; 0xbbe0 <vfprintf+0x6e>
    bbde:	b2 c1       	rjmp	.+868    	; 0xbf44 <vfprintf+0x3d2>
    bbe0:	85 32       	cpi	r24, 0x25	; 37
    bbe2:	39 f4       	brne	.+14     	; 0xbbf2 <vfprintf+0x80>
    bbe4:	23 fd       	sbrc	r18, 3
    bbe6:	85 91       	lpm	r24, Z+
    bbe8:	23 ff       	sbrs	r18, 3
    bbea:	81 91       	ld	r24, Z+
    bbec:	2f 01       	movw	r4, r30
    bbee:	85 32       	cpi	r24, 0x25	; 37
    bbf0:	29 f4       	brne	.+10     	; 0xbbfc <vfprintf+0x8a>
    bbf2:	90 e0       	ldi	r25, 0x00	; 0
    bbf4:	b3 01       	movw	r22, r6
    bbf6:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bbfa:	e7 cf       	rjmp	.-50     	; 0xbbca <vfprintf+0x58>
    bbfc:	98 2f       	mov	r25, r24
    bbfe:	ff 24       	eor	r15, r15
    bc00:	ee 24       	eor	r14, r14
    bc02:	99 24       	eor	r9, r9
    bc04:	ff e1       	ldi	r31, 0x1F	; 31
    bc06:	ff 15       	cp	r31, r15
    bc08:	d0 f0       	brcs	.+52     	; 0xbc3e <vfprintf+0xcc>
    bc0a:	9b 32       	cpi	r25, 0x2B	; 43
    bc0c:	69 f0       	breq	.+26     	; 0xbc28 <vfprintf+0xb6>
    bc0e:	9c 32       	cpi	r25, 0x2C	; 44
    bc10:	28 f4       	brcc	.+10     	; 0xbc1c <vfprintf+0xaa>
    bc12:	90 32       	cpi	r25, 0x20	; 32
    bc14:	59 f0       	breq	.+22     	; 0xbc2c <vfprintf+0xba>
    bc16:	93 32       	cpi	r25, 0x23	; 35
    bc18:	91 f4       	brne	.+36     	; 0xbc3e <vfprintf+0xcc>
    bc1a:	0e c0       	rjmp	.+28     	; 0xbc38 <vfprintf+0xc6>
    bc1c:	9d 32       	cpi	r25, 0x2D	; 45
    bc1e:	49 f0       	breq	.+18     	; 0xbc32 <vfprintf+0xc0>
    bc20:	90 33       	cpi	r25, 0x30	; 48
    bc22:	69 f4       	brne	.+26     	; 0xbc3e <vfprintf+0xcc>
    bc24:	41 e0       	ldi	r20, 0x01	; 1
    bc26:	24 c0       	rjmp	.+72     	; 0xbc70 <vfprintf+0xfe>
    bc28:	52 e0       	ldi	r21, 0x02	; 2
    bc2a:	f5 2a       	or	r15, r21
    bc2c:	84 e0       	ldi	r24, 0x04	; 4
    bc2e:	f8 2a       	or	r15, r24
    bc30:	28 c0       	rjmp	.+80     	; 0xbc82 <vfprintf+0x110>
    bc32:	98 e0       	ldi	r25, 0x08	; 8
    bc34:	f9 2a       	or	r15, r25
    bc36:	25 c0       	rjmp	.+74     	; 0xbc82 <vfprintf+0x110>
    bc38:	e0 e1       	ldi	r30, 0x10	; 16
    bc3a:	fe 2a       	or	r15, r30
    bc3c:	22 c0       	rjmp	.+68     	; 0xbc82 <vfprintf+0x110>
    bc3e:	f7 fc       	sbrc	r15, 7
    bc40:	29 c0       	rjmp	.+82     	; 0xbc94 <vfprintf+0x122>
    bc42:	89 2f       	mov	r24, r25
    bc44:	80 53       	subi	r24, 0x30	; 48
    bc46:	8a 30       	cpi	r24, 0x0A	; 10
    bc48:	70 f4       	brcc	.+28     	; 0xbc66 <vfprintf+0xf4>
    bc4a:	f6 fe       	sbrs	r15, 6
    bc4c:	05 c0       	rjmp	.+10     	; 0xbc58 <vfprintf+0xe6>
    bc4e:	98 9c       	mul	r9, r8
    bc50:	90 2c       	mov	r9, r0
    bc52:	11 24       	eor	r1, r1
    bc54:	98 0e       	add	r9, r24
    bc56:	15 c0       	rjmp	.+42     	; 0xbc82 <vfprintf+0x110>
    bc58:	e8 9c       	mul	r14, r8
    bc5a:	e0 2c       	mov	r14, r0
    bc5c:	11 24       	eor	r1, r1
    bc5e:	e8 0e       	add	r14, r24
    bc60:	f0 e2       	ldi	r31, 0x20	; 32
    bc62:	ff 2a       	or	r15, r31
    bc64:	0e c0       	rjmp	.+28     	; 0xbc82 <vfprintf+0x110>
    bc66:	9e 32       	cpi	r25, 0x2E	; 46
    bc68:	29 f4       	brne	.+10     	; 0xbc74 <vfprintf+0x102>
    bc6a:	f6 fc       	sbrc	r15, 6
    bc6c:	6b c1       	rjmp	.+726    	; 0xbf44 <vfprintf+0x3d2>
    bc6e:	40 e4       	ldi	r20, 0x40	; 64
    bc70:	f4 2a       	or	r15, r20
    bc72:	07 c0       	rjmp	.+14     	; 0xbc82 <vfprintf+0x110>
    bc74:	9c 36       	cpi	r25, 0x6C	; 108
    bc76:	19 f4       	brne	.+6      	; 0xbc7e <vfprintf+0x10c>
    bc78:	50 e8       	ldi	r21, 0x80	; 128
    bc7a:	f5 2a       	or	r15, r21
    bc7c:	02 c0       	rjmp	.+4      	; 0xbc82 <vfprintf+0x110>
    bc7e:	98 36       	cpi	r25, 0x68	; 104
    bc80:	49 f4       	brne	.+18     	; 0xbc94 <vfprintf+0x122>
    bc82:	f2 01       	movw	r30, r4
    bc84:	23 fd       	sbrc	r18, 3
    bc86:	95 91       	lpm	r25, Z+
    bc88:	23 ff       	sbrs	r18, 3
    bc8a:	91 91       	ld	r25, Z+
    bc8c:	2f 01       	movw	r4, r30
    bc8e:	99 23       	and	r25, r25
    bc90:	09 f0       	breq	.+2      	; 0xbc94 <vfprintf+0x122>
    bc92:	b8 cf       	rjmp	.-144    	; 0xbc04 <vfprintf+0x92>
    bc94:	89 2f       	mov	r24, r25
    bc96:	85 54       	subi	r24, 0x45	; 69
    bc98:	83 30       	cpi	r24, 0x03	; 3
    bc9a:	18 f0       	brcs	.+6      	; 0xbca2 <vfprintf+0x130>
    bc9c:	80 52       	subi	r24, 0x20	; 32
    bc9e:	83 30       	cpi	r24, 0x03	; 3
    bca0:	38 f4       	brcc	.+14     	; 0xbcb0 <vfprintf+0x13e>
    bca2:	44 e0       	ldi	r20, 0x04	; 4
    bca4:	50 e0       	ldi	r21, 0x00	; 0
    bca6:	a4 0e       	add	r10, r20
    bca8:	b5 1e       	adc	r11, r21
    bcaa:	5f e3       	ldi	r21, 0x3F	; 63
    bcac:	59 83       	std	Y+1, r21	; 0x01
    bcae:	0f c0       	rjmp	.+30     	; 0xbcce <vfprintf+0x15c>
    bcb0:	93 36       	cpi	r25, 0x63	; 99
    bcb2:	31 f0       	breq	.+12     	; 0xbcc0 <vfprintf+0x14e>
    bcb4:	93 37       	cpi	r25, 0x73	; 115
    bcb6:	79 f0       	breq	.+30     	; 0xbcd6 <vfprintf+0x164>
    bcb8:	93 35       	cpi	r25, 0x53	; 83
    bcba:	09 f0       	breq	.+2      	; 0xbcbe <vfprintf+0x14c>
    bcbc:	56 c0       	rjmp	.+172    	; 0xbd6a <vfprintf+0x1f8>
    bcbe:	20 c0       	rjmp	.+64     	; 0xbd00 <vfprintf+0x18e>
    bcc0:	f5 01       	movw	r30, r10
    bcc2:	80 81       	ld	r24, Z
    bcc4:	89 83       	std	Y+1, r24	; 0x01
    bcc6:	42 e0       	ldi	r20, 0x02	; 2
    bcc8:	50 e0       	ldi	r21, 0x00	; 0
    bcca:	a4 0e       	add	r10, r20
    bccc:	b5 1e       	adc	r11, r21
    bcce:	61 01       	movw	r12, r2
    bcd0:	01 e0       	ldi	r16, 0x01	; 1
    bcd2:	10 e0       	ldi	r17, 0x00	; 0
    bcd4:	12 c0       	rjmp	.+36     	; 0xbcfa <vfprintf+0x188>
    bcd6:	f5 01       	movw	r30, r10
    bcd8:	c0 80       	ld	r12, Z
    bcda:	d1 80       	ldd	r13, Z+1	; 0x01
    bcdc:	f6 fc       	sbrc	r15, 6
    bcde:	03 c0       	rjmp	.+6      	; 0xbce6 <vfprintf+0x174>
    bce0:	6f ef       	ldi	r22, 0xFF	; 255
    bce2:	7f ef       	ldi	r23, 0xFF	; 255
    bce4:	02 c0       	rjmp	.+4      	; 0xbcea <vfprintf+0x178>
    bce6:	69 2d       	mov	r22, r9
    bce8:	70 e0       	ldi	r23, 0x00	; 0
    bcea:	42 e0       	ldi	r20, 0x02	; 2
    bcec:	50 e0       	ldi	r21, 0x00	; 0
    bcee:	a4 0e       	add	r10, r20
    bcf0:	b5 1e       	adc	r11, r21
    bcf2:	c6 01       	movw	r24, r12
    bcf4:	0e 94 1c 60 	call	0xc038	; 0xc038 <strnlen>
    bcf8:	8c 01       	movw	r16, r24
    bcfa:	5f e7       	ldi	r21, 0x7F	; 127
    bcfc:	f5 22       	and	r15, r21
    bcfe:	14 c0       	rjmp	.+40     	; 0xbd28 <vfprintf+0x1b6>
    bd00:	f5 01       	movw	r30, r10
    bd02:	c0 80       	ld	r12, Z
    bd04:	d1 80       	ldd	r13, Z+1	; 0x01
    bd06:	f6 fc       	sbrc	r15, 6
    bd08:	03 c0       	rjmp	.+6      	; 0xbd10 <vfprintf+0x19e>
    bd0a:	6f ef       	ldi	r22, 0xFF	; 255
    bd0c:	7f ef       	ldi	r23, 0xFF	; 255
    bd0e:	02 c0       	rjmp	.+4      	; 0xbd14 <vfprintf+0x1a2>
    bd10:	69 2d       	mov	r22, r9
    bd12:	70 e0       	ldi	r23, 0x00	; 0
    bd14:	42 e0       	ldi	r20, 0x02	; 2
    bd16:	50 e0       	ldi	r21, 0x00	; 0
    bd18:	a4 0e       	add	r10, r20
    bd1a:	b5 1e       	adc	r11, r21
    bd1c:	c6 01       	movw	r24, r12
    bd1e:	0e 94 11 60 	call	0xc022	; 0xc022 <strnlen_P>
    bd22:	8c 01       	movw	r16, r24
    bd24:	50 e8       	ldi	r21, 0x80	; 128
    bd26:	f5 2a       	or	r15, r21
    bd28:	f3 fe       	sbrs	r15, 3
    bd2a:	07 c0       	rjmp	.+14     	; 0xbd3a <vfprintf+0x1c8>
    bd2c:	1a c0       	rjmp	.+52     	; 0xbd62 <vfprintf+0x1f0>
    bd2e:	80 e2       	ldi	r24, 0x20	; 32
    bd30:	90 e0       	ldi	r25, 0x00	; 0
    bd32:	b3 01       	movw	r22, r6
    bd34:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bd38:	ea 94       	dec	r14
    bd3a:	8e 2d       	mov	r24, r14
    bd3c:	90 e0       	ldi	r25, 0x00	; 0
    bd3e:	08 17       	cp	r16, r24
    bd40:	19 07       	cpc	r17, r25
    bd42:	a8 f3       	brcs	.-22     	; 0xbd2e <vfprintf+0x1bc>
    bd44:	0e c0       	rjmp	.+28     	; 0xbd62 <vfprintf+0x1f0>
    bd46:	f6 01       	movw	r30, r12
    bd48:	f7 fc       	sbrc	r15, 7
    bd4a:	85 91       	lpm	r24, Z+
    bd4c:	f7 fe       	sbrs	r15, 7
    bd4e:	81 91       	ld	r24, Z+
    bd50:	6f 01       	movw	r12, r30
    bd52:	90 e0       	ldi	r25, 0x00	; 0
    bd54:	b3 01       	movw	r22, r6
    bd56:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bd5a:	e1 10       	cpse	r14, r1
    bd5c:	ea 94       	dec	r14
    bd5e:	01 50       	subi	r16, 0x01	; 1
    bd60:	10 40       	sbci	r17, 0x00	; 0
    bd62:	01 15       	cp	r16, r1
    bd64:	11 05       	cpc	r17, r1
    bd66:	79 f7       	brne	.-34     	; 0xbd46 <vfprintf+0x1d4>
    bd68:	ea c0       	rjmp	.+468    	; 0xbf3e <vfprintf+0x3cc>
    bd6a:	94 36       	cpi	r25, 0x64	; 100
    bd6c:	11 f0       	breq	.+4      	; 0xbd72 <vfprintf+0x200>
    bd6e:	99 36       	cpi	r25, 0x69	; 105
    bd70:	69 f5       	brne	.+90     	; 0xbdcc <vfprintf+0x25a>
    bd72:	f7 fe       	sbrs	r15, 7
    bd74:	08 c0       	rjmp	.+16     	; 0xbd86 <vfprintf+0x214>
    bd76:	f5 01       	movw	r30, r10
    bd78:	20 81       	ld	r18, Z
    bd7a:	31 81       	ldd	r19, Z+1	; 0x01
    bd7c:	42 81       	ldd	r20, Z+2	; 0x02
    bd7e:	53 81       	ldd	r21, Z+3	; 0x03
    bd80:	84 e0       	ldi	r24, 0x04	; 4
    bd82:	90 e0       	ldi	r25, 0x00	; 0
    bd84:	0a c0       	rjmp	.+20     	; 0xbd9a <vfprintf+0x228>
    bd86:	f5 01       	movw	r30, r10
    bd88:	80 81       	ld	r24, Z
    bd8a:	91 81       	ldd	r25, Z+1	; 0x01
    bd8c:	9c 01       	movw	r18, r24
    bd8e:	44 27       	eor	r20, r20
    bd90:	37 fd       	sbrc	r19, 7
    bd92:	40 95       	com	r20
    bd94:	54 2f       	mov	r21, r20
    bd96:	82 e0       	ldi	r24, 0x02	; 2
    bd98:	90 e0       	ldi	r25, 0x00	; 0
    bd9a:	a8 0e       	add	r10, r24
    bd9c:	b9 1e       	adc	r11, r25
    bd9e:	9f e6       	ldi	r25, 0x6F	; 111
    bda0:	f9 22       	and	r15, r25
    bda2:	57 ff       	sbrs	r21, 7
    bda4:	09 c0       	rjmp	.+18     	; 0xbdb8 <vfprintf+0x246>
    bda6:	50 95       	com	r21
    bda8:	40 95       	com	r20
    bdaa:	30 95       	com	r19
    bdac:	21 95       	neg	r18
    bdae:	3f 4f       	sbci	r19, 0xFF	; 255
    bdb0:	4f 4f       	sbci	r20, 0xFF	; 255
    bdb2:	5f 4f       	sbci	r21, 0xFF	; 255
    bdb4:	e0 e8       	ldi	r30, 0x80	; 128
    bdb6:	fe 2a       	or	r15, r30
    bdb8:	ca 01       	movw	r24, r20
    bdba:	b9 01       	movw	r22, r18
    bdbc:	a1 01       	movw	r20, r2
    bdbe:	2a e0       	ldi	r18, 0x0A	; 10
    bdc0:	30 e0       	ldi	r19, 0x00	; 0
    bdc2:	0e 94 27 60 	call	0xc04e	; 0xc04e <__ultoa_invert>
    bdc6:	d8 2e       	mov	r13, r24
    bdc8:	d2 18       	sub	r13, r2
    bdca:	40 c0       	rjmp	.+128    	; 0xbe4c <vfprintf+0x2da>
    bdcc:	95 37       	cpi	r25, 0x75	; 117
    bdce:	29 f4       	brne	.+10     	; 0xbdda <vfprintf+0x268>
    bdd0:	1f 2d       	mov	r17, r15
    bdd2:	1f 7e       	andi	r17, 0xEF	; 239
    bdd4:	2a e0       	ldi	r18, 0x0A	; 10
    bdd6:	30 e0       	ldi	r19, 0x00	; 0
    bdd8:	1d c0       	rjmp	.+58     	; 0xbe14 <vfprintf+0x2a2>
    bdda:	1f 2d       	mov	r17, r15
    bddc:	19 7f       	andi	r17, 0xF9	; 249
    bdde:	9f 36       	cpi	r25, 0x6F	; 111
    bde0:	61 f0       	breq	.+24     	; 0xbdfa <vfprintf+0x288>
    bde2:	90 37       	cpi	r25, 0x70	; 112
    bde4:	20 f4       	brcc	.+8      	; 0xbdee <vfprintf+0x27c>
    bde6:	98 35       	cpi	r25, 0x58	; 88
    bde8:	09 f0       	breq	.+2      	; 0xbdec <vfprintf+0x27a>
    bdea:	ac c0       	rjmp	.+344    	; 0xbf44 <vfprintf+0x3d2>
    bdec:	0f c0       	rjmp	.+30     	; 0xbe0c <vfprintf+0x29a>
    bdee:	90 37       	cpi	r25, 0x70	; 112
    bdf0:	39 f0       	breq	.+14     	; 0xbe00 <vfprintf+0x28e>
    bdf2:	98 37       	cpi	r25, 0x78	; 120
    bdf4:	09 f0       	breq	.+2      	; 0xbdf8 <vfprintf+0x286>
    bdf6:	a6 c0       	rjmp	.+332    	; 0xbf44 <vfprintf+0x3d2>
    bdf8:	04 c0       	rjmp	.+8      	; 0xbe02 <vfprintf+0x290>
    bdfa:	28 e0       	ldi	r18, 0x08	; 8
    bdfc:	30 e0       	ldi	r19, 0x00	; 0
    bdfe:	0a c0       	rjmp	.+20     	; 0xbe14 <vfprintf+0x2a2>
    be00:	10 61       	ori	r17, 0x10	; 16
    be02:	14 fd       	sbrc	r17, 4
    be04:	14 60       	ori	r17, 0x04	; 4
    be06:	20 e1       	ldi	r18, 0x10	; 16
    be08:	30 e0       	ldi	r19, 0x00	; 0
    be0a:	04 c0       	rjmp	.+8      	; 0xbe14 <vfprintf+0x2a2>
    be0c:	14 fd       	sbrc	r17, 4
    be0e:	16 60       	ori	r17, 0x06	; 6
    be10:	20 e1       	ldi	r18, 0x10	; 16
    be12:	32 e0       	ldi	r19, 0x02	; 2
    be14:	17 ff       	sbrs	r17, 7
    be16:	08 c0       	rjmp	.+16     	; 0xbe28 <vfprintf+0x2b6>
    be18:	f5 01       	movw	r30, r10
    be1a:	60 81       	ld	r22, Z
    be1c:	71 81       	ldd	r23, Z+1	; 0x01
    be1e:	82 81       	ldd	r24, Z+2	; 0x02
    be20:	93 81       	ldd	r25, Z+3	; 0x03
    be22:	44 e0       	ldi	r20, 0x04	; 4
    be24:	50 e0       	ldi	r21, 0x00	; 0
    be26:	08 c0       	rjmp	.+16     	; 0xbe38 <vfprintf+0x2c6>
    be28:	f5 01       	movw	r30, r10
    be2a:	80 81       	ld	r24, Z
    be2c:	91 81       	ldd	r25, Z+1	; 0x01
    be2e:	bc 01       	movw	r22, r24
    be30:	80 e0       	ldi	r24, 0x00	; 0
    be32:	90 e0       	ldi	r25, 0x00	; 0
    be34:	42 e0       	ldi	r20, 0x02	; 2
    be36:	50 e0       	ldi	r21, 0x00	; 0
    be38:	a4 0e       	add	r10, r20
    be3a:	b5 1e       	adc	r11, r21
    be3c:	a1 01       	movw	r20, r2
    be3e:	0e 94 27 60 	call	0xc04e	; 0xc04e <__ultoa_invert>
    be42:	d8 2e       	mov	r13, r24
    be44:	d2 18       	sub	r13, r2
    be46:	8f e7       	ldi	r24, 0x7F	; 127
    be48:	f8 2e       	mov	r15, r24
    be4a:	f1 22       	and	r15, r17
    be4c:	f6 fe       	sbrs	r15, 6
    be4e:	0b c0       	rjmp	.+22     	; 0xbe66 <vfprintf+0x2f4>
    be50:	5e ef       	ldi	r21, 0xFE	; 254
    be52:	f5 22       	and	r15, r21
    be54:	d9 14       	cp	r13, r9
    be56:	38 f4       	brcc	.+14     	; 0xbe66 <vfprintf+0x2f4>
    be58:	f4 fe       	sbrs	r15, 4
    be5a:	07 c0       	rjmp	.+14     	; 0xbe6a <vfprintf+0x2f8>
    be5c:	f2 fc       	sbrc	r15, 2
    be5e:	05 c0       	rjmp	.+10     	; 0xbe6a <vfprintf+0x2f8>
    be60:	8f ee       	ldi	r24, 0xEF	; 239
    be62:	f8 22       	and	r15, r24
    be64:	02 c0       	rjmp	.+4      	; 0xbe6a <vfprintf+0x2f8>
    be66:	1d 2d       	mov	r17, r13
    be68:	01 c0       	rjmp	.+2      	; 0xbe6c <vfprintf+0x2fa>
    be6a:	19 2d       	mov	r17, r9
    be6c:	f4 fe       	sbrs	r15, 4
    be6e:	0d c0       	rjmp	.+26     	; 0xbe8a <vfprintf+0x318>
    be70:	fe 01       	movw	r30, r28
    be72:	ed 0d       	add	r30, r13
    be74:	f1 1d       	adc	r31, r1
    be76:	80 81       	ld	r24, Z
    be78:	80 33       	cpi	r24, 0x30	; 48
    be7a:	19 f4       	brne	.+6      	; 0xbe82 <vfprintf+0x310>
    be7c:	99 ee       	ldi	r25, 0xE9	; 233
    be7e:	f9 22       	and	r15, r25
    be80:	08 c0       	rjmp	.+16     	; 0xbe92 <vfprintf+0x320>
    be82:	1f 5f       	subi	r17, 0xFF	; 255
    be84:	f2 fe       	sbrs	r15, 2
    be86:	05 c0       	rjmp	.+10     	; 0xbe92 <vfprintf+0x320>
    be88:	03 c0       	rjmp	.+6      	; 0xbe90 <vfprintf+0x31e>
    be8a:	8f 2d       	mov	r24, r15
    be8c:	86 78       	andi	r24, 0x86	; 134
    be8e:	09 f0       	breq	.+2      	; 0xbe92 <vfprintf+0x320>
    be90:	1f 5f       	subi	r17, 0xFF	; 255
    be92:	0f 2d       	mov	r16, r15
    be94:	f3 fc       	sbrc	r15, 3
    be96:	14 c0       	rjmp	.+40     	; 0xbec0 <vfprintf+0x34e>
    be98:	f0 fe       	sbrs	r15, 0
    be9a:	0f c0       	rjmp	.+30     	; 0xbeba <vfprintf+0x348>
    be9c:	1e 15       	cp	r17, r14
    be9e:	10 f0       	brcs	.+4      	; 0xbea4 <vfprintf+0x332>
    bea0:	9d 2c       	mov	r9, r13
    bea2:	0b c0       	rjmp	.+22     	; 0xbeba <vfprintf+0x348>
    bea4:	9d 2c       	mov	r9, r13
    bea6:	9e 0c       	add	r9, r14
    bea8:	91 1a       	sub	r9, r17
    beaa:	1e 2d       	mov	r17, r14
    beac:	06 c0       	rjmp	.+12     	; 0xbeba <vfprintf+0x348>
    beae:	80 e2       	ldi	r24, 0x20	; 32
    beb0:	90 e0       	ldi	r25, 0x00	; 0
    beb2:	b3 01       	movw	r22, r6
    beb4:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    beb8:	1f 5f       	subi	r17, 0xFF	; 255
    beba:	1e 15       	cp	r17, r14
    bebc:	c0 f3       	brcs	.-16     	; 0xbeae <vfprintf+0x33c>
    bebe:	04 c0       	rjmp	.+8      	; 0xbec8 <vfprintf+0x356>
    bec0:	1e 15       	cp	r17, r14
    bec2:	10 f4       	brcc	.+4      	; 0xbec8 <vfprintf+0x356>
    bec4:	e1 1a       	sub	r14, r17
    bec6:	01 c0       	rjmp	.+2      	; 0xbeca <vfprintf+0x358>
    bec8:	ee 24       	eor	r14, r14
    beca:	04 ff       	sbrs	r16, 4
    becc:	0f c0       	rjmp	.+30     	; 0xbeec <vfprintf+0x37a>
    bece:	80 e3       	ldi	r24, 0x30	; 48
    bed0:	90 e0       	ldi	r25, 0x00	; 0
    bed2:	b3 01       	movw	r22, r6
    bed4:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bed8:	02 ff       	sbrs	r16, 2
    beda:	1d c0       	rjmp	.+58     	; 0xbf16 <vfprintf+0x3a4>
    bedc:	01 fd       	sbrc	r16, 1
    bede:	03 c0       	rjmp	.+6      	; 0xbee6 <vfprintf+0x374>
    bee0:	88 e7       	ldi	r24, 0x78	; 120
    bee2:	90 e0       	ldi	r25, 0x00	; 0
    bee4:	0e c0       	rjmp	.+28     	; 0xbf02 <vfprintf+0x390>
    bee6:	88 e5       	ldi	r24, 0x58	; 88
    bee8:	90 e0       	ldi	r25, 0x00	; 0
    beea:	0b c0       	rjmp	.+22     	; 0xbf02 <vfprintf+0x390>
    beec:	80 2f       	mov	r24, r16
    beee:	86 78       	andi	r24, 0x86	; 134
    bef0:	91 f0       	breq	.+36     	; 0xbf16 <vfprintf+0x3a4>
    bef2:	01 ff       	sbrs	r16, 1
    bef4:	02 c0       	rjmp	.+4      	; 0xbefa <vfprintf+0x388>
    bef6:	8b e2       	ldi	r24, 0x2B	; 43
    bef8:	01 c0       	rjmp	.+2      	; 0xbefc <vfprintf+0x38a>
    befa:	80 e2       	ldi	r24, 0x20	; 32
    befc:	f7 fc       	sbrc	r15, 7
    befe:	8d e2       	ldi	r24, 0x2D	; 45
    bf00:	90 e0       	ldi	r25, 0x00	; 0
    bf02:	b3 01       	movw	r22, r6
    bf04:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bf08:	06 c0       	rjmp	.+12     	; 0xbf16 <vfprintf+0x3a4>
    bf0a:	80 e3       	ldi	r24, 0x30	; 48
    bf0c:	90 e0       	ldi	r25, 0x00	; 0
    bf0e:	b3 01       	movw	r22, r6
    bf10:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bf14:	9a 94       	dec	r9
    bf16:	d9 14       	cp	r13, r9
    bf18:	c0 f3       	brcs	.-16     	; 0xbf0a <vfprintf+0x398>
    bf1a:	da 94       	dec	r13
    bf1c:	f1 01       	movw	r30, r2
    bf1e:	ed 0d       	add	r30, r13
    bf20:	f1 1d       	adc	r31, r1
    bf22:	80 81       	ld	r24, Z
    bf24:	90 e0       	ldi	r25, 0x00	; 0
    bf26:	b3 01       	movw	r22, r6
    bf28:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bf2c:	dd 20       	and	r13, r13
    bf2e:	a9 f7       	brne	.-22     	; 0xbf1a <vfprintf+0x3a8>
    bf30:	06 c0       	rjmp	.+12     	; 0xbf3e <vfprintf+0x3cc>
    bf32:	80 e2       	ldi	r24, 0x20	; 32
    bf34:	90 e0       	ldi	r25, 0x00	; 0
    bf36:	b3 01       	movw	r22, r6
    bf38:	0e 94 31 5d 	call	0xba62	; 0xba62 <fputc>
    bf3c:	ea 94       	dec	r14
    bf3e:	ee 20       	and	r14, r14
    bf40:	c1 f7       	brne	.-16     	; 0xbf32 <vfprintf+0x3c0>
    bf42:	43 ce       	rjmp	.-890    	; 0xbbca <vfprintf+0x58>
    bf44:	f3 01       	movw	r30, r6
    bf46:	66 81       	ldd	r22, Z+6	; 0x06
    bf48:	77 81       	ldd	r23, Z+7	; 0x07
    bf4a:	cb 01       	movw	r24, r22
    bf4c:	2b 96       	adiw	r28, 0x0b	; 11
    bf4e:	0f b6       	in	r0, 0x3f	; 63
    bf50:	f8 94       	cli
    bf52:	de bf       	out	0x3e, r29	; 62
    bf54:	0f be       	out	0x3f, r0	; 63
    bf56:	cd bf       	out	0x3d, r28	; 61
    bf58:	cf 91       	pop	r28
    bf5a:	df 91       	pop	r29
    bf5c:	1f 91       	pop	r17
    bf5e:	0f 91       	pop	r16
    bf60:	ff 90       	pop	r15
    bf62:	ef 90       	pop	r14
    bf64:	df 90       	pop	r13
    bf66:	cf 90       	pop	r12
    bf68:	bf 90       	pop	r11
    bf6a:	af 90       	pop	r10
    bf6c:	9f 90       	pop	r9
    bf6e:	8f 90       	pop	r8
    bf70:	7f 90       	pop	r7
    bf72:	6f 90       	pop	r6
    bf74:	5f 90       	pop	r5
    bf76:	4f 90       	pop	r4
    bf78:	3f 90       	pop	r3
    bf7a:	2f 90       	pop	r2
    bf7c:	08 95       	ret

0000bf7e <__eerd_block_m128>:
    bf7e:	dc 01       	movw	r26, r24
    bf80:	cb 01       	movw	r24, r22

0000bf82 <__eerd_blraw_m128>:
    bf82:	fc 01       	movw	r30, r24
    bf84:	e1 99       	sbic	0x1c, 1	; 28
    bf86:	fe cf       	rjmp	.-4      	; 0xbf84 <__eerd_blraw_m128+0x2>
    bf88:	06 c0       	rjmp	.+12     	; 0xbf96 <__eerd_blraw_m128+0x14>
    bf8a:	ff bb       	out	0x1f, r31	; 31
    bf8c:	ee bb       	out	0x1e, r30	; 30
    bf8e:	e0 9a       	sbi	0x1c, 0	; 28
    bf90:	31 96       	adiw	r30, 0x01	; 1
    bf92:	0d b2       	in	r0, 0x1d	; 29
    bf94:	0d 92       	st	X+, r0
    bf96:	41 50       	subi	r20, 0x01	; 1
    bf98:	50 40       	sbci	r21, 0x00	; 0
    bf9a:	b8 f7       	brcc	.-18     	; 0xbf8a <__eerd_blraw_m128+0x8>
    bf9c:	08 95       	ret

0000bf9e <__eerd_dword_m128>:
    bf9e:	a6 e1       	ldi	r26, 0x16	; 22
    bfa0:	b0 e0       	ldi	r27, 0x00	; 0
    bfa2:	44 e0       	ldi	r20, 0x04	; 4
    bfa4:	50 e0       	ldi	r21, 0x00	; 0
    bfa6:	0c 94 c1 5f 	jmp	0xbf82	; 0xbf82 <__eerd_blraw_m128>

0000bfaa <__eerd_word_m128>:
    bfaa:	a8 e1       	ldi	r26, 0x18	; 24
    bfac:	b0 e0       	ldi	r27, 0x00	; 0
    bfae:	42 e0       	ldi	r20, 0x02	; 2
    bfb0:	50 e0       	ldi	r21, 0x00	; 0
    bfb2:	0c 94 c1 5f 	jmp	0xbf82	; 0xbf82 <__eerd_blraw_m128>

0000bfb6 <__eeupd_block_m128>:
    bfb6:	dc 01       	movw	r26, r24
    bfb8:	a4 0f       	add	r26, r20
    bfba:	b5 1f       	adc	r27, r21
    bfbc:	41 50       	subi	r20, 0x01	; 1
    bfbe:	50 40       	sbci	r21, 0x00	; 0
    bfc0:	48 f0       	brcs	.+18     	; 0xbfd4 <__eeupd_block_m128+0x1e>
    bfc2:	cb 01       	movw	r24, r22
    bfc4:	84 0f       	add	r24, r20
    bfc6:	95 1f       	adc	r25, r21
    bfc8:	2e 91       	ld	r18, -X
    bfca:	0e 94 ec 5f 	call	0xbfd8	; 0xbfd8 <__eeupd_r18_m128>
    bfce:	41 50       	subi	r20, 0x01	; 1
    bfd0:	50 40       	sbci	r21, 0x00	; 0
    bfd2:	d0 f7       	brcc	.-12     	; 0xbfc8 <__eeupd_block_m128+0x12>
    bfd4:	08 95       	ret

0000bfd6 <__eeupd_byte_m128>:
    bfd6:	26 2f       	mov	r18, r22

0000bfd8 <__eeupd_r18_m128>:
    bfd8:	e1 99       	sbic	0x1c, 1	; 28
    bfda:	fe cf       	rjmp	.-4      	; 0xbfd8 <__eeupd_r18_m128>
    bfdc:	9f bb       	out	0x1f, r25	; 31
    bfde:	8e bb       	out	0x1e, r24	; 30
    bfe0:	e0 9a       	sbi	0x1c, 0	; 28
    bfe2:	01 97       	sbiw	r24, 0x01	; 1
    bfe4:	0d b2       	in	r0, 0x1d	; 29
    bfe6:	02 16       	cp	r0, r18
    bfe8:	31 f0       	breq	.+12     	; 0xbff6 <__eeupd_r18_m128+0x1e>
    bfea:	2d bb       	out	0x1d, r18	; 29
    bfec:	0f b6       	in	r0, 0x3f	; 63
    bfee:	f8 94       	cli
    bff0:	e2 9a       	sbi	0x1c, 2	; 28
    bff2:	e1 9a       	sbi	0x1c, 1	; 28
    bff4:	0f be       	out	0x3f, r0	; 63
    bff6:	08 95       	ret

0000bff8 <__eeupd_dword_m128>:
    bff8:	03 96       	adiw	r24, 0x03	; 3
    bffa:	27 2f       	mov	r18, r23
    bffc:	0e 94 ec 5f 	call	0xbfd8	; 0xbfd8 <__eeupd_r18_m128>
    c000:	0e 94 eb 5f 	call	0xbfd6	; 0xbfd6 <__eeupd_byte_m128>
    c004:	25 2f       	mov	r18, r21
    c006:	0e 94 ec 5f 	call	0xbfd8	; 0xbfd8 <__eeupd_r18_m128>
    c00a:	24 2f       	mov	r18, r20
    c00c:	0c 94 ec 5f 	jmp	0xbfd8	; 0xbfd8 <__eeupd_r18_m128>

0000c010 <__eeupd_word_m128>:
    c010:	01 96       	adiw	r24, 0x01	; 1
    c012:	27 2f       	mov	r18, r23
    c014:	0e 94 ec 5f 	call	0xbfd8	; 0xbfd8 <__eeupd_r18_m128>
    c018:	0c 94 eb 5f 	jmp	0xbfd6	; 0xbfd6 <__eeupd_byte_m128>

0000c01c <__ctype_isfalse>:
    c01c:	99 27       	eor	r25, r25
    c01e:	88 27       	eor	r24, r24

0000c020 <__ctype_istrue>:
    c020:	08 95       	ret

0000c022 <strnlen_P>:
    c022:	fc 01       	movw	r30, r24
    c024:	05 90       	lpm	r0, Z+
    c026:	61 50       	subi	r22, 0x01	; 1
    c028:	70 40       	sbci	r23, 0x00	; 0
    c02a:	01 10       	cpse	r0, r1
    c02c:	d8 f7       	brcc	.-10     	; 0xc024 <strnlen_P+0x2>
    c02e:	80 95       	com	r24
    c030:	90 95       	com	r25
    c032:	8e 0f       	add	r24, r30
    c034:	9f 1f       	adc	r25, r31
    c036:	08 95       	ret

0000c038 <strnlen>:
    c038:	fc 01       	movw	r30, r24
    c03a:	61 50       	subi	r22, 0x01	; 1
    c03c:	70 40       	sbci	r23, 0x00	; 0
    c03e:	01 90       	ld	r0, Z+
    c040:	01 10       	cpse	r0, r1
    c042:	d8 f7       	brcc	.-10     	; 0xc03a <strnlen+0x2>
    c044:	80 95       	com	r24
    c046:	90 95       	com	r25
    c048:	8e 0f       	add	r24, r30
    c04a:	9f 1f       	adc	r25, r31
    c04c:	08 95       	ret

0000c04e <__ultoa_invert>:
    c04e:	fa 01       	movw	r30, r20
    c050:	aa 27       	eor	r26, r26
    c052:	28 30       	cpi	r18, 0x08	; 8
    c054:	51 f1       	breq	.+84     	; 0xc0aa <__ultoa_invert+0x5c>
    c056:	20 31       	cpi	r18, 0x10	; 16
    c058:	81 f1       	breq	.+96     	; 0xc0ba <__ultoa_invert+0x6c>
    c05a:	e8 94       	clt
    c05c:	6f 93       	push	r22
    c05e:	6e 7f       	andi	r22, 0xFE	; 254
    c060:	6e 5f       	subi	r22, 0xFE	; 254
    c062:	7f 4f       	sbci	r23, 0xFF	; 255
    c064:	8f 4f       	sbci	r24, 0xFF	; 255
    c066:	9f 4f       	sbci	r25, 0xFF	; 255
    c068:	af 4f       	sbci	r26, 0xFF	; 255
    c06a:	b1 e0       	ldi	r27, 0x01	; 1
    c06c:	3e d0       	rcall	.+124    	; 0xc0ea <__ultoa_invert+0x9c>
    c06e:	b4 e0       	ldi	r27, 0x04	; 4
    c070:	3c d0       	rcall	.+120    	; 0xc0ea <__ultoa_invert+0x9c>
    c072:	67 0f       	add	r22, r23
    c074:	78 1f       	adc	r23, r24
    c076:	89 1f       	adc	r24, r25
    c078:	9a 1f       	adc	r25, r26
    c07a:	a1 1d       	adc	r26, r1
    c07c:	68 0f       	add	r22, r24
    c07e:	79 1f       	adc	r23, r25
    c080:	8a 1f       	adc	r24, r26
    c082:	91 1d       	adc	r25, r1
    c084:	a1 1d       	adc	r26, r1
    c086:	6a 0f       	add	r22, r26
    c088:	71 1d       	adc	r23, r1
    c08a:	81 1d       	adc	r24, r1
    c08c:	91 1d       	adc	r25, r1
    c08e:	a1 1d       	adc	r26, r1
    c090:	20 d0       	rcall	.+64     	; 0xc0d2 <__ultoa_invert+0x84>
    c092:	09 f4       	brne	.+2      	; 0xc096 <__ultoa_invert+0x48>
    c094:	68 94       	set
    c096:	3f 91       	pop	r19
    c098:	2a e0       	ldi	r18, 0x0A	; 10
    c09a:	26 9f       	mul	r18, r22
    c09c:	11 24       	eor	r1, r1
    c09e:	30 19       	sub	r19, r0
    c0a0:	30 5d       	subi	r19, 0xD0	; 208
    c0a2:	31 93       	st	Z+, r19
    c0a4:	de f6       	brtc	.-74     	; 0xc05c <__ultoa_invert+0xe>
    c0a6:	cf 01       	movw	r24, r30
    c0a8:	08 95       	ret
    c0aa:	46 2f       	mov	r20, r22
    c0ac:	47 70       	andi	r20, 0x07	; 7
    c0ae:	40 5d       	subi	r20, 0xD0	; 208
    c0b0:	41 93       	st	Z+, r20
    c0b2:	b3 e0       	ldi	r27, 0x03	; 3
    c0b4:	0f d0       	rcall	.+30     	; 0xc0d4 <__ultoa_invert+0x86>
    c0b6:	c9 f7       	brne	.-14     	; 0xc0aa <__ultoa_invert+0x5c>
    c0b8:	f6 cf       	rjmp	.-20     	; 0xc0a6 <__ultoa_invert+0x58>
    c0ba:	46 2f       	mov	r20, r22
    c0bc:	4f 70       	andi	r20, 0x0F	; 15
    c0be:	40 5d       	subi	r20, 0xD0	; 208
    c0c0:	4a 33       	cpi	r20, 0x3A	; 58
    c0c2:	18 f0       	brcs	.+6      	; 0xc0ca <__ultoa_invert+0x7c>
    c0c4:	49 5d       	subi	r20, 0xD9	; 217
    c0c6:	31 fd       	sbrc	r19, 1
    c0c8:	40 52       	subi	r20, 0x20	; 32
    c0ca:	41 93       	st	Z+, r20
    c0cc:	02 d0       	rcall	.+4      	; 0xc0d2 <__ultoa_invert+0x84>
    c0ce:	a9 f7       	brne	.-22     	; 0xc0ba <__ultoa_invert+0x6c>
    c0d0:	ea cf       	rjmp	.-44     	; 0xc0a6 <__ultoa_invert+0x58>
    c0d2:	b4 e0       	ldi	r27, 0x04	; 4
    c0d4:	a6 95       	lsr	r26
    c0d6:	97 95       	ror	r25
    c0d8:	87 95       	ror	r24
    c0da:	77 95       	ror	r23
    c0dc:	67 95       	ror	r22
    c0de:	ba 95       	dec	r27
    c0e0:	c9 f7       	brne	.-14     	; 0xc0d4 <__ultoa_invert+0x86>
    c0e2:	00 97       	sbiw	r24, 0x00	; 0
    c0e4:	61 05       	cpc	r22, r1
    c0e6:	71 05       	cpc	r23, r1
    c0e8:	08 95       	ret
    c0ea:	9b 01       	movw	r18, r22
    c0ec:	ac 01       	movw	r20, r24
    c0ee:	0a 2e       	mov	r0, r26
    c0f0:	06 94       	lsr	r0
    c0f2:	57 95       	ror	r21
    c0f4:	47 95       	ror	r20
    c0f6:	37 95       	ror	r19
    c0f8:	27 95       	ror	r18
    c0fa:	ba 95       	dec	r27
    c0fc:	c9 f7       	brne	.-14     	; 0xc0f0 <__ultoa_invert+0xa2>
    c0fe:	62 0f       	add	r22, r18
    c100:	73 1f       	adc	r23, r19
    c102:	84 1f       	adc	r24, r20
    c104:	95 1f       	adc	r25, r21
    c106:	a0 1d       	adc	r26, r0
    c108:	08 95       	ret

0000c10a <__mulsi3>:
    c10a:	62 9f       	mul	r22, r18
    c10c:	d0 01       	movw	r26, r0
    c10e:	73 9f       	mul	r23, r19
    c110:	f0 01       	movw	r30, r0
    c112:	82 9f       	mul	r24, r18
    c114:	e0 0d       	add	r30, r0
    c116:	f1 1d       	adc	r31, r1
    c118:	64 9f       	mul	r22, r20
    c11a:	e0 0d       	add	r30, r0
    c11c:	f1 1d       	adc	r31, r1
    c11e:	92 9f       	mul	r25, r18
    c120:	f0 0d       	add	r31, r0
    c122:	83 9f       	mul	r24, r19
    c124:	f0 0d       	add	r31, r0
    c126:	74 9f       	mul	r23, r20
    c128:	f0 0d       	add	r31, r0
    c12a:	65 9f       	mul	r22, r21
    c12c:	f0 0d       	add	r31, r0
    c12e:	99 27       	eor	r25, r25
    c130:	72 9f       	mul	r23, r18
    c132:	b0 0d       	add	r27, r0
    c134:	e1 1d       	adc	r30, r1
    c136:	f9 1f       	adc	r31, r25
    c138:	63 9f       	mul	r22, r19
    c13a:	b0 0d       	add	r27, r0
    c13c:	e1 1d       	adc	r30, r1
    c13e:	f9 1f       	adc	r31, r25
    c140:	bd 01       	movw	r22, r26
    c142:	cf 01       	movw	r24, r30
    c144:	11 24       	eor	r1, r1
    c146:	08 95       	ret

0000c148 <__udivmodsi4>:
    c148:	a1 e2       	ldi	r26, 0x21	; 33
    c14a:	1a 2e       	mov	r1, r26
    c14c:	aa 1b       	sub	r26, r26
    c14e:	bb 1b       	sub	r27, r27
    c150:	fd 01       	movw	r30, r26
    c152:	0d c0       	rjmp	.+26     	; 0xc16e <__udivmodsi4_ep>

0000c154 <__udivmodsi4_loop>:
    c154:	aa 1f       	adc	r26, r26
    c156:	bb 1f       	adc	r27, r27
    c158:	ee 1f       	adc	r30, r30
    c15a:	ff 1f       	adc	r31, r31
    c15c:	a2 17       	cp	r26, r18
    c15e:	b3 07       	cpc	r27, r19
    c160:	e4 07       	cpc	r30, r20
    c162:	f5 07       	cpc	r31, r21
    c164:	20 f0       	brcs	.+8      	; 0xc16e <__udivmodsi4_ep>
    c166:	a2 1b       	sub	r26, r18
    c168:	b3 0b       	sbc	r27, r19
    c16a:	e4 0b       	sbc	r30, r20
    c16c:	f5 0b       	sbc	r31, r21

0000c16e <__udivmodsi4_ep>:
    c16e:	66 1f       	adc	r22, r22
    c170:	77 1f       	adc	r23, r23
    c172:	88 1f       	adc	r24, r24
    c174:	99 1f       	adc	r25, r25
    c176:	1a 94       	dec	r1
    c178:	69 f7       	brne	.-38     	; 0xc154 <__udivmodsi4_loop>
    c17a:	60 95       	com	r22
    c17c:	70 95       	com	r23
    c17e:	80 95       	com	r24
    c180:	90 95       	com	r25
    c182:	9b 01       	movw	r18, r22
    c184:	ac 01       	movw	r20, r24
    c186:	bd 01       	movw	r22, r26
    c188:	cf 01       	movw	r24, r30
    c18a:	08 95       	ret

0000c18c <_exit>:
    c18c:	f8 94       	cli

0000c18e <__stop_program>:
    c18e:	ff cf       	rjmp	.-2      	; 0xc18e <__stop_program>
