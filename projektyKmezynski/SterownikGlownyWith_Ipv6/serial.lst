   1               		.file	"serial.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 263               	.global	initQueueStreamUSB
 265               	initQueueStreamUSB:
 266               		.stabd	46,0,0
   1:serial.c      **** #include <stdlib.h>
   2:serial.c      **** #include <avr/interrupt.h>
   3:serial.c      **** #include "FreeRTOS.h"
   4:serial.c      **** #include "queue.h"
   5:serial.c      **** #include "task.h"
   6:serial.c      **** #include "serial.h"
   7:serial.c      **** #include "hardware.h"
   8:serial.c      **** 
   9:serial.c      **** #define debug 1
  10:serial.c      **** 
  11:serial.c      **** /*-----------------------------------------------------------*/
  12:serial.c      **** 
  13:serial.c      **** void initQueueStreamUSB(FILE *stream)
  14:serial.c      **** {
 268               	.LM0:
 269               	.LFBB1:
 270               	/* prologue: function */
 271               	/* frame size = 0 */
 272 0000 FC01      		movw r30,r24
  15:serial.c      ****   fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
 274               	.LM1:
 275 0002 80E0      		ldi r24,lo8(gs(VtyPutChar))
 276 0004 90E0      		ldi r25,hi8(gs(VtyPutChar))
 277 0006 9187      		std Z+9,r25
 278 0008 8087      		std Z+8,r24
 279 000a 80E0      		ldi r24,lo8(gs(VtyGetChar))
 280 000c 90E0      		ldi r25,hi8(gs(VtyGetChar))
 281 000e 9387      		std Z+11,r25
 282 0010 8287      		std Z+10,r24
 283 0012 83E0      		ldi r24,lo8(3)
 284 0014 8383      		std Z+3,r24
  16:serial.c      ****   fdev_set_udata(stream, NULL);
 286               	.LM2:
 287 0016 1586      		std Z+13,__zero_reg__
 288 0018 1486      		std Z+12,__zero_reg__
 289               	/* epilogue start */
  17:serial.c      ****   return;
  18:serial.c      **** }
 291               	.LM3:
 292 001a 0895      		ret
 294               	.Lscope1:
 296               		.stabd	78,0,0
 298               	.global	__vector_20
 300               	__vector_20:
 301               		.stabd	46,0,0
  19:serial.c      **** 
  20:serial.c      **** int VtyGetChar(FILE *stream)
  21:serial.c      **** {
  22:serial.c      ****   stream = NULL;
  23:serial.c      ****   uint8_t c;
  24:serial.c      ****   if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
  25:serial.c      ****     return EOF;
  26:serial.c      ****   return c;
  27:serial.c      **** }
  28:serial.c      **** 
  29:serial.c      **** int VtyPutChar(char c, FILE *stream)
  30:serial.c      **** {
  31:serial.c      ****   stream = NULL;
  32:serial.c      ****   uartVtySendByte(c);
  33:serial.c      ****   return 0;
  34:serial.c      **** }
  35:serial.c      **** 
  36:serial.c      **** void xSerialPortInitMinimal(void)
  37:serial.c      **** {
  38:serial.c      ****   portENTER_CRITICAL();
  39:serial.c      ****   {
  40:serial.c      ****     xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
  41:serial.c      ****     xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
  42:serial.c      ****     xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
  43:serial.c      ****     xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
  44:serial.c      ****     
  45:serial.c      ****     vSemaphoreCreateBinary(xSemaphoreRs485); 
  46:serial.c      ****   }
  47:serial.c      ****   portEXIT_CRITICAL();
  48:serial.c      ****   
  49:serial.c      ****   UBRR0L = 7;
  50:serial.c      ****   UBRR0H = 0;
  51:serial.c      **** 
  52:serial.c      ****   UBRR1L = 7;
  53:serial.c      ****   UBRR1H = 0;
  54:serial.c      **** 
  55:serial.c      ****   UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
  56:serial.c      ****   UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
  57:serial.c      ****   UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
  58:serial.c      ****   UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
  59:serial.c      ****   return;
  60:serial.c      **** }
  61:serial.c      **** 
  62:serial.c      **** /*-----------------------------------------------------------*/
  63:serial.c      **** ISR(USART0_RX_vect)
  64:serial.c      **** {
  65:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  66:serial.c      ****   signed portCHAR cChar;
  67:serial.c      **** 
  68:serial.c      ****   cChar = UDR0;
  69:serial.c      **** 
  70:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
  71:serial.c      **** 
  72:serial.c      **** //  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  73:serial.c      ****   xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
  74:serial.c      ****   if( xHigherPriorityTaskWoken )
  75:serial.c      ****   {
  76:serial.c      ****     taskYIELD();
  77:serial.c      ****   }
  78:serial.c      **** }
  79:serial.c      **** 
  80:serial.c      **** void uartRs485SendByte(uint8_t data)
  81:serial.c      **** {
  82:serial.c      ****   xQueueSend(xRs485Tx, &data, portMAX_DELAY);
  83:serial.c      ****   vInterruptRs485On();
  84:serial.c      **** }
  85:serial.c      **** 
  86:serial.c      **** uint8_t rs485Receive(uint8_t *c, uint8_t timeout)
  87:serial.c      **** {
  88:serial.c      ****   return xQueueReceive(xRs485Rec, c, timeout);
  89:serial.c      **** }
  90:serial.c      **** 
  91:serial.c      **** ISR(USART0_UDRE_vect)
  92:serial.c      **** {
  93:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  94:serial.c      ****   static char data;
  95:serial.c      ****   if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
  96:serial.c      ****   {
  97:serial.c      ****     Rs485TxStart();
  98:serial.c      ****     UDR0 = data; 
  99:serial.c      ****   }
 100:serial.c      ****   else
 101:serial.c      ****   {
 102:serial.c      ****     xHigherPriorityTaskWoken = pdFALSE;
 103:serial.c      ****     vInterruptRs485Off();
 104:serial.c      ****   }
 105:serial.c      ****   if( xHigherPriorityTaskWoken )
 106:serial.c      ****   {
 107:serial.c      ****     taskYIELD();
 108:serial.c      ****   }
 109:serial.c      **** }
 110:serial.c      **** 
 111:serial.c      **** ISR(USART0_TX_vect)
 112:serial.c      **** {
 303               	.LM4:
 304               	.LFBB2:
 305 001c 1F92      		push __zero_reg__
 306 001e 0F92      		push r0
 307 0020 0FB6      		in r0,__SREG__
 308 0022 0F92      		push r0
 309 0024 1124      		clr __zero_reg__
 310 0026 8F93      		push r24
 311               	/* prologue: Signal */
 312               	/* frame size = 0 */
 113:serial.c      ****   if (!vIsInterruptRs485On())
 314               	.LM5:
 315 0028 5599      		sbic 42-32,5
 316 002a 00C0      		rjmp .L5
 114:serial.c      ****     Rs485TxStop();
 318               	.LM6:
 319 002c 8091 6500 		lds r24,101
 320 0030 8F7E      		andi r24,lo8(-17)
 321 0032 8093 6500 		sts 101,r24
 322               	.L5:
 323               	/* epilogue start */
 115:serial.c      **** }
 325               	.LM7:
 326 0036 8F91      		pop r24
 327 0038 0F90      		pop r0
 328 003a 0FBE      		out __SREG__,r0
 329 003c 0F90      		pop r0
 330 003e 1F90      		pop __zero_reg__
 331 0040 1895      		reti
 333               	.Lscope2:
 335               		.stabd	78,0,0
 337               	.global	InterruptVtyOn
 339               	InterruptVtyOn:
 340               		.stabd	46,0,0
 116:serial.c      **** 
 117:serial.c      **** uint8_t flushRs485RecBuffer(void)
 118:serial.c      **** {
 119:serial.c      ****   uint8_t temp;
 120:serial.c      ****   uint8_t wynik = 0;
 121:serial.c      ****   while(xQueueReceive(xRs485Rec, &temp, 10) == pdTRUE)
 122:serial.c      ****     wynik++;
 123:serial.c      ****     
 124:serial.c      ****   return wynik;
 125:serial.c      **** }
 126:serial.c      **** 
 127:serial.c      **** void    takeRs485(void)
 128:serial.c      **** {
 129:serial.c      ****   xSemaphoreTake(xSemaphoreRs485, portMAX_DELAY);
 130:serial.c      **** }
 131:serial.c      **** 
 132:serial.c      **** void    releaseRs485(void)
 133:serial.c      **** {
 134:serial.c      ****   xSemaphoreGive(xSemaphoreRs485);
 135:serial.c      **** }
 136:serial.c      **** 
 137:serial.c      **** void InterruptVtyOn(void)
 138:serial.c      **** {                                  
 342               	.LM8:
 343               	.LFBB3:
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 139:serial.c      ****   unsigned portCHAR ucByte;                                       
 140:serial.c      ****   ucByte = UCSR1B;                 
 347               	.LM9:
 348 0042 EAE9      		ldi r30,lo8(154)
 349 0044 F0E0      		ldi r31,hi8(154)
 350 0046 8081      		ld r24,Z
 141:serial.c      ****   ucByte |= serDATA_INT_ENABLE;    
 352               	.LM10:
 353 0048 8062      		ori r24,lo8(32)
 142:serial.c      ****   UCSR1B = ucByte;                 
 355               	.LM11:
 356 004a 8083      		st Z,r24
 357               	/* epilogue start */
 143:serial.c      **** }
 359               	.LM12:
 360 004c 0895      		ret
 365               	.Lscope3:
 367               		.stabd	78,0,0
 369               	.global	__vector_31
 371               	__vector_31:
 372               		.stabd	46,0,0
 144:serial.c      **** 
 145:serial.c      **** /*-----------------------------------------------------------*/
 146:serial.c      **** ISR(USART1_RX_vect)
 147:serial.c      **** {
 148:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
 149:serial.c      ****   signed portCHAR cChar;
 150:serial.c      **** 
 151:serial.c      ****   cChar = UDR1;
 152:serial.c      **** //  xQueueSendFromISR(xVtyRec, &cChar, NULL);
 153:serial.c      **** 
 154:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
 155:serial.c      ****   xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
 156:serial.c      ****   if( xHigherPriorityTaskWoken )
 157:serial.c      ****   {
 158:serial.c      ****     taskYIELD();
 159:serial.c      ****   }
 160:serial.c      **** }
 161:serial.c      **** 
 162:serial.c      **** void uartVtySendByte(uint8_t data)
 163:serial.c      **** {
 164:serial.c      ****   xQueueSend(xVtyTx, &data, portMAX_DELAY);
 165:serial.c      ****   vInterruptVtyOn();
 166:serial.c      **** }
 167:serial.c      **** 
 168:serial.c      **** ISR(USART1_UDRE_vect)
 169:serial.c      **** {
 374               	.LM13:
 375               	.LFBB4:
 376 004e 1F92      		push __zero_reg__
 377 0050 0F92      		push r0
 378 0052 0FB6      		in r0,__SREG__
 379 0054 0F92      		push r0
 380 0056 0BB6      		in r0,91-32
 381 0058 0F92      		push r0
 382 005a 1124      		clr __zero_reg__
 383 005c 2F93      		push r18
 384 005e 3F93      		push r19
 385 0060 4F93      		push r20
 386 0062 5F93      		push r21
 387 0064 6F93      		push r22
 388 0066 7F93      		push r23
 389 0068 8F93      		push r24
 390 006a 9F93      		push r25
 391 006c AF93      		push r26
 392 006e BF93      		push r27
 393 0070 EF93      		push r30
 394 0072 FF93      		push r31
 395               	/* prologue: Signal */
 396               	/* frame size = 0 */
 170:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
 171:serial.c      ****   static char data;
 172:serial.c      ****   if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
 398               	.LM14:
 399 0074 8091 0000 		lds r24,xVtyTx
 400 0078 9091 0000 		lds r25,(xVtyTx)+1
 401 007c 60E0      		ldi r22,lo8(data.3158)
 402 007e 70E0      		ldi r23,hi8(data.3158)
 403 0080 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3157)
 404 0082 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3157)
 405 0084 0E94 0000 		call xQueueReceiveFromISR
 406 0088 8130      		cpi r24,lo8(1)
 407 008a 01F4      		brne .L9
 173:serial.c      ****   {
 174:serial.c      ****     UDR1 = data; 
 409               	.LM15:
 410 008c 8091 0000 		lds r24,data.3158
 411 0090 8093 9C00 		sts 156,r24
 412 0094 00C0      		rjmp .L10
 413               	.L9:
 175:serial.c      ****   }
 176:serial.c      ****   else
 177:serial.c      ****   {
 178:serial.c      ****     xHigherPriorityTaskWoken = pdFALSE;
 415               	.LM16:
 416 0096 1092 0000 		sts xHigherPriorityTaskWoken.3157,__zero_reg__
 417               	.LBB2:
 179:serial.c      ****     vInterruptVtyOff();
 419               	.LM17:
 420 009a 8091 9A00 		lds r24,154
 421 009e 8F7D      		andi r24,lo8(-33)
 422 00a0 8093 9A00 		sts 154,r24
 423               	.L10:
 424               	.LBE2:
 180:serial.c      ****   }
 181:serial.c      ****   if( xHigherPriorityTaskWoken )
 426               	.LM18:
 427 00a4 8091 0000 		lds r24,xHigherPriorityTaskWoken.3157
 428 00a8 8823      		tst r24
 429 00aa 01F0      		breq .L12
 182:serial.c      ****   {
 183:serial.c      ****     taskYIELD();
 431               	.LM19:
 432 00ac 0E94 0000 		call vPortYield
 433               	.L12:
 434               	/* epilogue start */
 184:serial.c      ****   }
 185:serial.c      **** }
 436               	.LM20:
 437 00b0 FF91      		pop r31
 438 00b2 EF91      		pop r30
 439 00b4 BF91      		pop r27
 440 00b6 AF91      		pop r26
 441 00b8 9F91      		pop r25
 442 00ba 8F91      		pop r24
 443 00bc 7F91      		pop r23
 444 00be 6F91      		pop r22
 445 00c0 5F91      		pop r21
 446 00c2 4F91      		pop r20
 447 00c4 3F91      		pop r19
 448 00c6 2F91      		pop r18
 449 00c8 0F90      		pop r0
 450 00ca 0BBE      		out 91-32,r0
 451 00cc 0F90      		pop r0
 452 00ce 0FBE      		out __SREG__,r0
 453 00d0 0F90      		pop r0
 454 00d2 1F90      		pop __zero_reg__
 455 00d4 1895      		reti
 464               	.Lscope4:
 466               		.stabd	78,0,0
 468               	.global	__vector_19
 470               	__vector_19:
 471               		.stabd	46,0,0
  92:serial.c      **** {
 473               	.LM21:
 474               	.LFBB5:
 475 00d6 1F92      		push __zero_reg__
 476 00d8 0F92      		push r0
 477 00da 0FB6      		in r0,__SREG__
 478 00dc 0F92      		push r0
 479 00de 0BB6      		in r0,91-32
 480 00e0 0F92      		push r0
 481 00e2 1124      		clr __zero_reg__
 482 00e4 2F93      		push r18
 483 00e6 3F93      		push r19
 484 00e8 4F93      		push r20
 485 00ea 5F93      		push r21
 486 00ec 6F93      		push r22
 487 00ee 7F93      		push r23
 488 00f0 8F93      		push r24
 489 00f2 9F93      		push r25
 490 00f4 AF93      		push r26
 491 00f6 BF93      		push r27
 492 00f8 EF93      		push r30
 493 00fa FF93      		push r31
 494               	/* prologue: Signal */
 495               	/* frame size = 0 */
  95:serial.c      ****   if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
 497               	.LM22:
 498 00fc 8091 0000 		lds r24,xRs485Tx
 499 0100 9091 0000 		lds r25,(xRs485Tx)+1
 500 0104 60E0      		ldi r22,lo8(data.3086)
 501 0106 70E0      		ldi r23,hi8(data.3086)
 502 0108 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3085)
 503 010a 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3085)
 504 010c 0E94 0000 		call xQueueReceiveFromISR
 505 0110 8130      		cpi r24,lo8(1)
 506 0112 01F4      		brne .L14
  97:serial.c      ****     Rs485TxStart();
 508               	.LM23:
 509 0114 8091 6500 		lds r24,101
 510 0118 8061      		ori r24,lo8(16)
 511 011a 8093 6500 		sts 101,r24
  98:serial.c      ****     UDR0 = data; 
 513               	.LM24:
 514 011e 8091 0000 		lds r24,data.3086
 515 0122 8CB9      		out 44-32,r24
 516 0124 00C0      		rjmp .L15
 517               	.L14:
 102:serial.c      ****     xHigherPriorityTaskWoken = pdFALSE;
 519               	.LM25:
 520 0126 1092 0000 		sts xHigherPriorityTaskWoken.3085,__zero_reg__
 521               	.LBB3:
 103:serial.c      ****     vInterruptRs485Off();
 523               	.LM26:
 524 012a 5598      		cbi 42-32,5
 525               	.L15:
 526               	.LBE3:
 105:serial.c      ****   if( xHigherPriorityTaskWoken )
 528               	.LM27:
 529 012c 8091 0000 		lds r24,xHigherPriorityTaskWoken.3085
 530 0130 8823      		tst r24
 531 0132 01F0      		breq .L17
 107:serial.c      ****     taskYIELD();
 533               	.LM28:
 534 0134 0E94 0000 		call vPortYield
 535               	.L17:
 536               	/* epilogue start */
 109:serial.c      **** }
 538               	.LM29:
 539 0138 FF91      		pop r31
 540 013a EF91      		pop r30
 541 013c BF91      		pop r27
 542 013e AF91      		pop r26
 543 0140 9F91      		pop r25
 544 0142 8F91      		pop r24
 545 0144 7F91      		pop r23
 546 0146 6F91      		pop r22
 547 0148 5F91      		pop r21
 548 014a 4F91      		pop r20
 549 014c 3F91      		pop r19
 550 014e 2F91      		pop r18
 551 0150 0F90      		pop r0
 552 0152 0BBE      		out 91-32,r0
 553 0154 0F90      		pop r0
 554 0156 0FBE      		out __SREG__,r0
 555 0158 0F90      		pop r0
 556 015a 1F90      		pop __zero_reg__
 557 015c 1895      		reti
 563               	.Lscope5:
 565               		.stabd	78,0,0
 568               	.global	uartVtySendByte
 570               	uartVtySendByte:
 571               		.stabd	46,0,0
 163:serial.c      **** {
 573               	.LM30:
 574               	.LFBB6:
 575 015e DF93      		push r29
 576 0160 CF93      		push r28
 577 0162 0F92      		push __tmp_reg__
 578 0164 CDB7      		in r28,__SP_L__
 579 0166 DEB7      		in r29,__SP_H__
 580               	/* prologue: function */
 581               	/* frame size = 1 */
 582 0168 8983      		std Y+1,r24
 164:serial.c      ****   xQueueSend(xVtyTx, &data, portMAX_DELAY);
 584               	.LM31:
 585 016a 8091 0000 		lds r24,xVtyTx
 586 016e 9091 0000 		lds r25,(xVtyTx)+1
 587 0172 BE01      		movw r22,r28
 588 0174 6F5F      		subi r22,lo8(-(1))
 589 0176 7F4F      		sbci r23,hi8(-(1))
 590 0178 4FEF      		ldi r20,lo8(-1)
 591 017a 5FEF      		ldi r21,hi8(-1)
 592 017c 20E0      		ldi r18,lo8(0)
 593 017e 0E94 0000 		call xQueueGenericSend
 594               	.LBB4:
 165:serial.c      ****   vInterruptVtyOn();
 596               	.LM32:
 597 0182 EAE9      		ldi r30,lo8(154)
 598 0184 F0E0      		ldi r31,hi8(154)
 599 0186 8081      		ld r24,Z
 600 0188 8062      		ori r24,lo8(32)
 601 018a 8083      		st Z,r24
 602               	/* epilogue start */
 603               	.LBE4:
 166:serial.c      **** }
 605               	.LM33:
 606 018c 0F90      		pop __tmp_reg__
 607 018e CF91      		pop r28
 608 0190 DF91      		pop r29
 609 0192 0895      		ret
 614               	.Lscope6:
 616               		.stabd	78,0,0
 620               	.global	VtyPutChar
 622               	VtyPutChar:
 623               		.stabd	46,0,0
  30:serial.c      **** {
 625               	.LM34:
 626               	.LFBB7:
 627               	/* prologue: function */
 628               	/* frame size = 0 */
  32:serial.c      ****   uartVtySendByte(c);
 630               	.LM35:
 631 0194 0E94 0000 		call uartVtySendByte
  34:serial.c      **** }
 633               	.LM36:
 634 0198 80E0      		ldi r24,lo8(0)
 635 019a 90E0      		ldi r25,hi8(0)
 636               	/* epilogue start */
 637 019c 0895      		ret
 639               	.Lscope7:
 641               		.stabd	78,0,0
 643               		.weak	releaseRs485
 645               	releaseRs485:
 646               		.stabd	46,0,0
 133:serial.c      **** {
 648               	.LM37:
 649               	.LFBB8:
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 134:serial.c      ****   xSemaphoreGive(xSemaphoreRs485);
 653               	.LM38:
 654 019e 8091 0000 		lds r24,xSemaphoreRs485
 655 01a2 9091 0000 		lds r25,(xSemaphoreRs485)+1
 656 01a6 60E0      		ldi r22,lo8(0)
 657 01a8 70E0      		ldi r23,hi8(0)
 658 01aa 40E0      		ldi r20,lo8(0)
 659 01ac 50E0      		ldi r21,hi8(0)
 660 01ae 20E0      		ldi r18,lo8(0)
 661 01b0 0E94 0000 		call xQueueGenericSend
 662               	/* epilogue start */
 135:serial.c      **** }
 664               	.LM39:
 665 01b4 0895      		ret
 667               	.Lscope8:
 669               		.stabd	78,0,0
 672               		.weak	uartRs485SendByte
 674               	uartRs485SendByte:
 675               		.stabd	46,0,0
  81:serial.c      **** {
 677               	.LM40:
 678               	.LFBB9:
 679 01b6 DF93      		push r29
 680 01b8 CF93      		push r28
 681 01ba 0F92      		push __tmp_reg__
 682 01bc CDB7      		in r28,__SP_L__
 683 01be DEB7      		in r29,__SP_H__
 684               	/* prologue: function */
 685               	/* frame size = 1 */
 686 01c0 8983      		std Y+1,r24
  82:serial.c      ****   xQueueSend(xRs485Tx, &data, portMAX_DELAY);
 688               	.LM41:
 689 01c2 8091 0000 		lds r24,xRs485Tx
 690 01c6 9091 0000 		lds r25,(xRs485Tx)+1
 691 01ca BE01      		movw r22,r28
 692 01cc 6F5F      		subi r22,lo8(-(1))
 693 01ce 7F4F      		sbci r23,hi8(-(1))
 694 01d0 4FEF      		ldi r20,lo8(-1)
 695 01d2 5FEF      		ldi r21,hi8(-1)
 696 01d4 20E0      		ldi r18,lo8(0)
 697 01d6 0E94 0000 		call xQueueGenericSend
 698               	.LBB5:
  83:serial.c      ****   vInterruptRs485On();
 700               	.LM42:
 701 01da 559A      		sbi 42-32,5
 702               	/* epilogue start */
 703               	.LBE5:
  84:serial.c      **** }
 705               	.LM43:
 706 01dc 0F90      		pop __tmp_reg__
 707 01de CF91      		pop r28
 708 01e0 DF91      		pop r29
 709 01e2 0895      		ret
 711               	.Lscope9:
 713               		.stabd	78,0,0
 715               	.global	__vector_30
 717               	__vector_30:
 718               		.stabd	46,0,0
 147:serial.c      **** {
 720               	.LM44:
 721               	.LFBB10:
 722 01e4 1F92      		push __zero_reg__
 723 01e6 0F92      		push r0
 724 01e8 0FB6      		in r0,__SREG__
 725 01ea 0F92      		push r0
 726 01ec 0BB6      		in r0,91-32
 727 01ee 0F92      		push r0
 728 01f0 1124      		clr __zero_reg__
 729 01f2 2F93      		push r18
 730 01f4 3F93      		push r19
 731 01f6 4F93      		push r20
 732 01f8 5F93      		push r21
 733 01fa 6F93      		push r22
 734 01fc 7F93      		push r23
 735 01fe 8F93      		push r24
 736 0200 9F93      		push r25
 737 0202 AF93      		push r26
 738 0204 BF93      		push r27
 739 0206 EF93      		push r30
 740 0208 FF93      		push r31
 741 020a DF93      		push r29
 742 020c CF93      		push r28
 743 020e 0F92      		push __tmp_reg__
 744 0210 CDB7      		in r28,__SP_L__
 745 0212 DEB7      		in r29,__SP_H__
 746               	/* prologue: Signal */
 747               	/* frame size = 1 */
 151:serial.c      ****   cChar = UDR1;
 749               	.LM45:
 750 0214 8091 9C00 		lds r24,156
 751 0218 8983      		std Y+1,r24
 154:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
 753               	.LM46:
 754 021a 1092 0000 		sts xHigherPriorityTaskWoken.3139,__zero_reg__
 155:serial.c      ****   xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
 756               	.LM47:
 757 021e 8091 0000 		lds r24,xVtyRec
 758 0222 9091 0000 		lds r25,(xVtyRec)+1
 759 0226 BE01      		movw r22,r28
 760 0228 6F5F      		subi r22,lo8(-(1))
 761 022a 7F4F      		sbci r23,hi8(-(1))
 762 022c 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3139)
 763 022e 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3139)
 764 0230 20E0      		ldi r18,lo8(0)
 765 0232 0E94 0000 		call xQueueGenericSendFromISR
 156:serial.c      ****   if( xHigherPriorityTaskWoken )
 767               	.LM48:
 768 0236 8091 0000 		lds r24,xHigherPriorityTaskWoken.3139
 769 023a 8823      		tst r24
 770 023c 01F0      		breq .L28
 158:serial.c      ****     taskYIELD();
 772               	.LM49:
 773 023e 0E94 0000 		call vPortYield
 774               	.L28:
 775               	/* epilogue start */
 160:serial.c      **** }
 777               	.LM50:
 778 0242 0F90      		pop __tmp_reg__
 779 0244 CF91      		pop r28
 780 0246 DF91      		pop r29
 781 0248 FF91      		pop r31
 782 024a EF91      		pop r30
 783 024c BF91      		pop r27
 784 024e AF91      		pop r26
 785 0250 9F91      		pop r25
 786 0252 8F91      		pop r24
 787 0254 7F91      		pop r23
 788 0256 6F91      		pop r22
 789 0258 5F91      		pop r21
 790 025a 4F91      		pop r20
 791 025c 3F91      		pop r19
 792 025e 2F91      		pop r18
 793 0260 0F90      		pop r0
 794 0262 0BBE      		out 91-32,r0
 795 0264 0F90      		pop r0
 796 0266 0FBE      		out __SREG__,r0
 797 0268 0F90      		pop r0
 798 026a 1F90      		pop __zero_reg__
 799 026c 1895      		reti
 805               	.Lscope10:
 807               		.stabd	78,0,0
 809               	.global	__vector_18
 811               	__vector_18:
 812               		.stabd	46,0,0
  64:serial.c      **** {
 814               	.LM51:
 815               	.LFBB11:
 816 026e 1F92      		push __zero_reg__
 817 0270 0F92      		push r0
 818 0272 0FB6      		in r0,__SREG__
 819 0274 0F92      		push r0
 820 0276 0BB6      		in r0,91-32
 821 0278 0F92      		push r0
 822 027a 1124      		clr __zero_reg__
 823 027c 2F93      		push r18
 824 027e 3F93      		push r19
 825 0280 4F93      		push r20
 826 0282 5F93      		push r21
 827 0284 6F93      		push r22
 828 0286 7F93      		push r23
 829 0288 8F93      		push r24
 830 028a 9F93      		push r25
 831 028c AF93      		push r26
 832 028e BF93      		push r27
 833 0290 EF93      		push r30
 834 0292 FF93      		push r31
 835 0294 DF93      		push r29
 836 0296 CF93      		push r28
 837 0298 0F92      		push __tmp_reg__
 838 029a CDB7      		in r28,__SP_L__
 839 029c DEB7      		in r29,__SP_H__
 840               	/* prologue: Signal */
 841               	/* frame size = 1 */
  68:serial.c      ****   cChar = UDR0;
 843               	.LM52:
 844 029e 8CB1      		in r24,44-32
 845 02a0 8983      		std Y+1,r24
  70:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
 847               	.LM53:
 848 02a2 1092 0000 		sts xHigherPriorityTaskWoken.3059,__zero_reg__
  73:serial.c      ****   xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
 850               	.LM54:
 851 02a6 8091 0000 		lds r24,xRs485Rec
 852 02aa 9091 0000 		lds r25,(xRs485Rec)+1
 853 02ae BE01      		movw r22,r28
 854 02b0 6F5F      		subi r22,lo8(-(1))
 855 02b2 7F4F      		sbci r23,hi8(-(1))
 856 02b4 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3059)
 857 02b6 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3059)
 858 02b8 20E0      		ldi r18,lo8(0)
 859 02ba 0E94 0000 		call xQueueGenericSendFromISR
  74:serial.c      ****   if( xHigherPriorityTaskWoken )
 861               	.LM55:
 862 02be 8091 0000 		lds r24,xHigherPriorityTaskWoken.3059
 863 02c2 8823      		tst r24
 864 02c4 01F0      		breq .L31
  76:serial.c      ****     taskYIELD();
 866               	.LM56:
 867 02c6 0E94 0000 		call vPortYield
 868               	.L31:
 869               	/* epilogue start */
  78:serial.c      **** }
 871               	.LM57:
 872 02ca 0F90      		pop __tmp_reg__
 873 02cc CF91      		pop r28
 874 02ce DF91      		pop r29
 875 02d0 FF91      		pop r31
 876 02d2 EF91      		pop r30
 877 02d4 BF91      		pop r27
 878 02d6 AF91      		pop r26
 879 02d8 9F91      		pop r25
 880 02da 8F91      		pop r24
 881 02dc 7F91      		pop r23
 882 02de 6F91      		pop r22
 883 02e0 5F91      		pop r21
 884 02e2 4F91      		pop r20
 885 02e4 3F91      		pop r19
 886 02e6 2F91      		pop r18
 887 02e8 0F90      		pop r0
 888 02ea 0BBE      		out 91-32,r0
 889 02ec 0F90      		pop r0
 890 02ee 0FBE      		out __SREG__,r0
 891 02f0 0F90      		pop r0
 892 02f2 1F90      		pop __zero_reg__
 893 02f4 1895      		reti
 899               	.Lscope11:
 901               		.stabd	78,0,0
 903               		.weak	takeRs485
 905               	takeRs485:
 906               		.stabd	46,0,0
 128:serial.c      **** {
 908               	.LM58:
 909               	.LFBB12:
 910               	/* prologue: function */
 911               	/* frame size = 0 */
 129:serial.c      ****   xSemaphoreTake(xSemaphoreRs485, portMAX_DELAY);
 913               	.LM59:
 914 02f6 8091 0000 		lds r24,xSemaphoreRs485
 915 02fa 9091 0000 		lds r25,(xSemaphoreRs485)+1
 916 02fe 60E0      		ldi r22,lo8(0)
 917 0300 70E0      		ldi r23,hi8(0)
 918 0302 4FEF      		ldi r20,lo8(-1)
 919 0304 5FEF      		ldi r21,hi8(-1)
 920 0306 20E0      		ldi r18,lo8(0)
 921 0308 0E94 0000 		call xQueueGenericReceive
 922               	/* epilogue start */
 130:serial.c      **** }
 924               	.LM60:
 925 030c 0895      		ret
 927               	.Lscope12:
 929               		.stabd	78,0,0
 931               		.weak	flushRs485RecBuffer
 933               	flushRs485RecBuffer:
 934               		.stabd	46,0,0
 118:serial.c      **** {
 936               	.LM61:
 937               	.LFBB13:
 938 030e EF92      		push r14
 939 0310 FF92      		push r15
 940 0312 1F93      		push r17
 941 0314 DF93      		push r29
 942 0316 CF93      		push r28
 943 0318 0F92      		push __tmp_reg__
 944 031a CDB7      		in r28,__SP_L__
 945 031c DEB7      		in r29,__SP_H__
 946               	/* prologue: function */
 947               	/* frame size = 1 */
 118:serial.c      **** {
 949               	.LM62:
 950 031e 10E0      		ldi r17,lo8(0)
 121:serial.c      ****   while(xQueueReceive(xRs485Rec, &temp, 10) == pdTRUE)
 952               	.LM63:
 953 0320 7E01      		movw r14,r28
 954 0322 0894      		sec
 955 0324 E11C      		adc r14,__zero_reg__
 956 0326 F11C      		adc r15,__zero_reg__
 957 0328 00C0      		rjmp .L35
 958               	.L36:
 122:serial.c      ****     wynik++;
 960               	.LM64:
 961 032a 1F5F      		subi r17,lo8(-(1))
 962               	.L35:
 121:serial.c      ****   while(xQueueReceive(xRs485Rec, &temp, 10) == pdTRUE)
 964               	.LM65:
 965 032c 8091 0000 		lds r24,xRs485Rec
 966 0330 9091 0000 		lds r25,(xRs485Rec)+1
 967 0334 B701      		movw r22,r14
 968 0336 4AE0      		ldi r20,lo8(10)
 969 0338 50E0      		ldi r21,hi8(10)
 970 033a 20E0      		ldi r18,lo8(0)
 971 033c 0E94 0000 		call xQueueGenericReceive
 972 0340 8130      		cpi r24,lo8(1)
 973 0342 01F0      		breq .L36
 125:serial.c      **** }
 975               	.LM66:
 976 0344 812F      		mov r24,r17
 977               	/* epilogue start */
 978 0346 0F90      		pop __tmp_reg__
 979 0348 CF91      		pop r28
 980 034a DF91      		pop r29
 981 034c 1F91      		pop r17
 982 034e FF90      		pop r15
 983 0350 EF90      		pop r14
 984 0352 0895      		ret
 990               	.Lscope13:
 992               		.stabd	78,0,0
 996               		.weak	rs485Receive
 998               	rs485Receive:
 999               		.stabd	46,0,0
  87:serial.c      **** {
 1001               	.LM67:
 1002               	.LFBB14:
 1003               	/* prologue: function */
 1004               	/* frame size = 0 */
 1005 0354 9C01      		movw r18,r24
 1006 0356 462F      		mov r20,r22
  88:serial.c      ****   return xQueueReceive(xRs485Rec, c, timeout);
 1008               	.LM68:
 1009 0358 8091 0000 		lds r24,xRs485Rec
 1010 035c 9091 0000 		lds r25,(xRs485Rec)+1
 1011 0360 B901      		movw r22,r18
 1012 0362 50E0      		ldi r21,lo8(0)
 1013 0364 20E0      		ldi r18,lo8(0)
 1014 0366 0E94 0000 		call xQueueGenericReceive
 1015               	/* epilogue start */
  89:serial.c      **** }
 1017               	.LM69:
 1018 036a 0895      		ret
 1020               	.Lscope14:
 1022               		.stabd	78,0,0
 1025               	.global	VtyGetChar
 1027               	VtyGetChar:
 1028               		.stabd	46,0,0
  21:serial.c      **** {
 1030               	.LM70:
 1031               	.LFBB15:
 1032 036c DF93      		push r29
 1033 036e CF93      		push r28
 1034 0370 0F92      		push __tmp_reg__
 1035 0372 CDB7      		in r28,__SP_L__
 1036 0374 DEB7      		in r29,__SP_H__
 1037               	/* prologue: function */
 1038               	/* frame size = 1 */
  24:serial.c      ****   if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
 1040               	.LM71:
 1041 0376 8091 0000 		lds r24,xVtyRec
 1042 037a 9091 0000 		lds r25,(xVtyRec)+1
 1043 037e BE01      		movw r22,r28
 1044 0380 6F5F      		subi r22,lo8(-(1))
 1045 0382 7F4F      		sbci r23,hi8(-(1))
 1046 0384 4FEF      		ldi r20,lo8(-1)
 1047 0386 5FEF      		ldi r21,hi8(-1)
 1048 0388 20E0      		ldi r18,lo8(0)
 1049 038a 0E94 0000 		call xQueueGenericReceive
 1050 038e 8823      		tst r24
 1051 0390 01F4      		brne .L41
 1052 0392 2FEF      		ldi r18,lo8(-1)
 1053 0394 3FEF      		ldi r19,hi8(-1)
 1054 0396 00C0      		rjmp .L42
 1055               	.L41:
  26:serial.c      ****   return c;
 1057               	.LM72:
 1058 0398 8981      		ldd r24,Y+1
 1059 039a 282F      		mov r18,r24
 1060 039c 30E0      		ldi r19,lo8(0)
 1061               	.L42:
  27:serial.c      **** }
 1063               	.LM73:
 1064 039e C901      		movw r24,r18
 1065               	/* epilogue start */
 1066 03a0 0F90      		pop __tmp_reg__
 1067 03a2 CF91      		pop r28
 1068 03a4 DF91      		pop r29
 1069 03a6 0895      		ret
 1074               	.Lscope15:
 1076               		.stabd	78,0,0
 1078               	.global	xSerialPortInitMinimal
 1080               	xSerialPortInitMinimal:
 1081               		.stabd	46,0,0
  37:serial.c      **** {
 1083               	.LM74:
 1084               	.LFBB16:
 1085               	/* prologue: function */
 1086               	/* frame size = 0 */
  38:serial.c      ****   portENTER_CRITICAL();
 1088               	.LM75:
 1089               	/* #APP */
 1090               	 ;  38 "serial.c" 1
 1091 03a8 0FB6      		in		__tmp_reg__, __SREG__
 1092               	 ;  0 "" 2
 1093               	 ;  38 "serial.c" 1
 1094 03aa F894      		cli
 1095               	 ;  0 "" 2
 1096               	 ;  38 "serial.c" 1
 1097 03ac 0F92      		push	__tmp_reg__
 1098               	 ;  0 "" 2
  40:serial.c      ****     xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
 1100               	.LM76:
 1101               	/* #NOAPP */
 1102 03ae 80E4      		ldi r24,lo8(64)
 1103 03b0 61E0      		ldi r22,lo8(1)
 1104 03b2 0E94 0000 		call xQueueCreate
 1105 03b6 9093 0000 		sts (xVtyRec)+1,r25
 1106 03ba 8093 0000 		sts xVtyRec,r24
  41:serial.c      ****     xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
 1108               	.LM77:
 1109 03be 80E2      		ldi r24,lo8(32)
 1110 03c0 61E0      		ldi r22,lo8(1)
 1111 03c2 0E94 0000 		call xQueueCreate
 1112 03c6 9093 0000 		sts (xVtyTx)+1,r25
 1113 03ca 8093 0000 		sts xVtyTx,r24
  42:serial.c      ****     xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
 1115               	.LM78:
 1116 03ce 80E1      		ldi r24,lo8(16)
 1117 03d0 61E0      		ldi r22,lo8(1)
 1118 03d2 0E94 0000 		call xQueueCreate
 1119 03d6 9093 0000 		sts (xRs485Rec)+1,r25
 1120 03da 8093 0000 		sts xRs485Rec,r24
  43:serial.c      ****     xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
 1122               	.LM79:
 1123 03de 84E0      		ldi r24,lo8(4)
 1124 03e0 61E0      		ldi r22,lo8(1)
 1125 03e2 0E94 0000 		call xQueueCreate
 1126 03e6 9093 0000 		sts (xRs485Tx)+1,r25
 1127 03ea 8093 0000 		sts xRs485Tx,r24
  45:serial.c      ****     vSemaphoreCreateBinary(xSemaphoreRs485); 
 1129               	.LM80:
 1130 03ee 81E0      		ldi r24,lo8(1)
 1131 03f0 60E0      		ldi r22,lo8(0)
 1132 03f2 0E94 0000 		call xQueueCreate
 1133 03f6 9093 0000 		sts (xSemaphoreRs485)+1,r25
 1134 03fa 8093 0000 		sts xSemaphoreRs485,r24
 1135 03fe 0097      		sbiw r24,0
 1136 0400 01F0      		breq .L45
 1137 0402 60E0      		ldi r22,lo8(0)
 1138 0404 70E0      		ldi r23,hi8(0)
 1139 0406 40E0      		ldi r20,lo8(0)
 1140 0408 50E0      		ldi r21,hi8(0)
 1141 040a 20E0      		ldi r18,lo8(0)
 1142 040c 0E94 0000 		call xQueueGenericSend
 1143               	.L45:
  47:serial.c      ****   portEXIT_CRITICAL();
 1145               	.LM81:
 1146               	/* #APP */
 1147               	 ;  47 "serial.c" 1
 1148 0410 0F90      		pop		__tmp_reg__
 1149               	 ;  0 "" 2
 1150               	 ;  47 "serial.c" 1
 1151 0412 0FBE      		out		__SREG__, __tmp_reg__
 1152               	 ;  0 "" 2
  49:serial.c      ****   UBRR0L = 7;
 1154               	.LM82:
 1155               	/* #NOAPP */
 1156 0414 87E0      		ldi r24,lo8(7)
 1157 0416 89B9      		out 41-32,r24
  50:serial.c      ****   UBRR0H = 0;
 1159               	.LM83:
 1160 0418 1092 9000 		sts 144,__zero_reg__
  52:serial.c      ****   UBRR1L = 7;
 1162               	.LM84:
 1163 041c 8093 9900 		sts 153,r24
  53:serial.c      ****   UBRR1H = 0;
 1165               	.LM85:
 1166 0420 1092 9800 		sts 152,__zero_reg__
  55:serial.c      ****   UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
 1168               	.LM86:
 1169 0424 88ED      		ldi r24,lo8(-40)
 1170 0426 8AB9      		out 42-32,r24
  56:serial.c      ****   UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
 1172               	.LM87:
 1173 0428 96E8      		ldi r25,lo8(-122)
 1174 042a 9093 9500 		sts 149,r25
  57:serial.c      ****   UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
 1176               	.LM88:
 1177 042e 88E9      		ldi r24,lo8(-104)
 1178 0430 8093 9A00 		sts 154,r24
  58:serial.c      ****   UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
 1180               	.LM89:
 1181 0434 9093 9D00 		sts 157,r25
 1182               	/* epilogue start */
  60:serial.c      **** }
 1184               	.LM90:
 1185 0438 0895      		ret
 1187               	.Lscope16:
 1189               		.stabd	78,0,0
 1190               		.lcomm data.3158,1
 1191               		.lcomm xHigherPriorityTaskWoken.3157,1
 1192               		.lcomm xHigherPriorityTaskWoken.3139,1
 1193               		.lcomm data.3086,1
 1194               		.lcomm xHigherPriorityTaskWoken.3085,1
 1195               		.data
 1198               	xHigherPriorityTaskWoken.3059:
 1199 0000 01        		.byte	1
 1200               		.comm klastry,128,1
 1201               		.comm wwwport,1,1
 1202               		.comm rollers,2,1
 1203               		.comm xSemaphoreSpiSS,2,1
 1204               		.comm portA,1,1
 1205               		.comm portB,1,1
 1206               		.comm lockSensors,2,1
 1207               		.comm nicState,14,1
 1208               		.comm IpMyConfig,15,1
 1209               		.comm arpDebug,2,1
 1210               		.comm arpDebugLevel,1,1
 1211               		.comm icmpDebug,2,1
 1212               		.comm icmpDebugLevel,1,1
 1213               		.comm udpSocket,2,1
 1214               		.comm udpDbgStream,2,1
 1215               		.comm udpDbgLevel,1,1
 1216               		.comm tcpDebugStream,2,1
 1217               		.comm tcpDebugLevel,1,1
 1218               		.comm sockets,2,1
 1219               		.comm Ipv6MyConfig,5,1
 1220               		.comm debugStream,2,1
 1221               		.comm czasRtc,7,1
 1222               		.comm xSemaphoreRs485,2,1
 1252               		.text
 1254               	.Letext0:
 1255               	.global __do_copy_data
 1256               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 serial.c
     /tmp/cc8hz7qJ.s:2      *ABS*:0000003f __SREG__
     /tmp/cc8hz7qJ.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc8hz7qJ.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc8hz7qJ.s:5      *ABS*:00000034 __CCP__
     /tmp/cc8hz7qJ.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc8hz7qJ.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc8hz7qJ.s:265    .text:00000000 initQueueStreamUSB
     /tmp/cc8hz7qJ.s:622    .text:00000194 VtyPutChar
     /tmp/cc8hz7qJ.s:1027   .text:0000036c VtyGetChar
     /tmp/cc8hz7qJ.s:300    .text:0000001c __vector_20
     /tmp/cc8hz7qJ.s:339    .text:00000042 InterruptVtyOn
     /tmp/cc8hz7qJ.s:371    .text:0000004e __vector_31
                             .bss:00000000 data.3158
     /tmp/cc8hz7qJ.s:1190   .bss:00000001 xHigherPriorityTaskWoken.3157
     /tmp/cc8hz7qJ.s:470    .text:000000d6 __vector_19
     /tmp/cc8hz7qJ.s:1192   .bss:00000003 data.3086
     /tmp/cc8hz7qJ.s:1193   .bss:00000004 xHigherPriorityTaskWoken.3085
     /tmp/cc8hz7qJ.s:570    .text:0000015e uartVtySendByte
     /tmp/cc8hz7qJ.s:645    .text:0000019e releaseRs485
                            *COM*:00000002 xSemaphoreRs485
     /tmp/cc8hz7qJ.s:674    .text:000001b6 uartRs485SendByte
     /tmp/cc8hz7qJ.s:717    .text:000001e4 __vector_30
     /tmp/cc8hz7qJ.s:1191   .bss:00000002 xHigherPriorityTaskWoken.3139
     /tmp/cc8hz7qJ.s:811    .text:0000026e __vector_18
     /tmp/cc8hz7qJ.s:1198   .data:00000000 xHigherPriorityTaskWoken.3059
     /tmp/cc8hz7qJ.s:905    .text:000002f6 takeRs485
     /tmp/cc8hz7qJ.s:933    .text:0000030e flushRs485RecBuffer
     /tmp/cc8hz7qJ.s:998    .text:00000354 rs485Receive
     /tmp/cc8hz7qJ.s:1080   .text:000003a8 xSerialPortInitMinimal
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:0000000e nicState
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpSocket
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000005 Ipv6MyConfig
                            *COM*:00000002 debugStream
                            *COM*:00000007 czasRtc

UNDEFINED SYMBOLS
xVtyTx
xQueueReceiveFromISR
vPortYield
xRs485Tx
xQueueGenericSend
xVtyRec
xQueueGenericSendFromISR
xRs485Rec
xQueueGenericReceive
xQueueCreate
__do_copy_data
__do_clear_bss
