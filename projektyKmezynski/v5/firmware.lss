
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000088  00800100  0000bb6e  0000bc22  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000bb6e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000e5c  00800188  00800188  0000bcaa  2**0
                  ALLOC
  3 .eeprom       00000032  00810000  00810000  0000bcaa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         0001b6cc  00000000  00000000  0000bcdc  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000d790  00000000  00000000  000273a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d3 09 	jmp	0x13a6	; 0x13a6 <__ctors_end>
       4:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
       8:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
       c:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      10:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      14:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      18:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      1c:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      20:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      24:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      28:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      2c:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      30:	0c 94 f6 55 	jmp	0xabec	; 0xabec <__vector_12>
      34:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      38:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      3c:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      40:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      44:	0c 94 47 0d 	jmp	0x1a8e	; 0x1a8e <__vector_17>
      48:	0c 94 1c 0c 	jmp	0x1838	; 0x1838 <__vector_18>
      4c:	0c 94 50 0b 	jmp	0x16a0	; 0x16a0 <__vector_19>
      50:	0c 94 f3 0a 	jmp	0x15e6	; 0x15e6 <__vector_20>
      54:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      58:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      5c:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      60:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      64:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      68:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      6c:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      70:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      74:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      78:	0c 94 d7 0b 	jmp	0x17ae	; 0x17ae <__vector_30>
      7c:	0c 94 0c 0b 	jmp	0x1618	; 0x1618 <__vector_31>
      80:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      84:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>
      88:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__bad_interrupt>

0000008c <statusLockerSensDescStr>:
      8c:	20 6c 6f 63 6b 65 72 20 25 64 00                     locker %d.

00000097 <statusLockerOpenStr>:
      97:	20 6f 70 65 6e 20 20 20 00                           open   .

000000a0 <statusLockerCloseStr>:
      a0:	20 6c 6f 63 6b 65 64 20 00                           locked .

000000a9 <statusLockerSensAdditionalDescStr>:
      a9:	20 28 74 68 72 65 73 68 6f 6c 64 20 25 64 2c 20      (threshold %d, 
      b9:	41 43 20 76 61 6c 75 65 20 25 64 29 0d 0a 00        AC value %d)...

000000c8 <errorOK>:
      c8:	41 6c 6c 20 4f 4b 0d 0a 00                          All OK...

000000d1 <errorNoFile>:
      d1:	4e 6f 20 46 69 6c 65 0d 0a 00                       No File...

000000db <errorxModemFrameStartTimeout>:
      db:	0d 0a 00                                            ...

000000de <errorxModemByteSendTimeout>:
      de:	0d 0a 00                                            ...

000000e1 <errorxModemWrongFrameNo>:
      e1:	0d 0a 00                                            ...

000000e4 <errorxModemFrameFrameNoCorrectionNotMatch>:
      e4:	0d 0a 00                                            ...

000000e7 <errorxModemFrameCrc>:
      e7:	78 4d 6f 64 65 6d 20 43 52 43 20 65 72 72 6f 72     xModem CRC error
      f7:	0d 0a 00                                            ...

000000fa <errorxModemRemoteSideCan>:
      fa:	52 65 6d 6f 74 65 20 73 69 64 65 20 63 61 6e 63     Remote side canc
     10a:	65 6c 6c 65 64 20 61 74 20 66 72 61 6d 65 20 6e     elled at frame n
     11a:	6f 20 25 64 0d 0a 00                                o %d...

00000121 <errorxModemUnknownResponse>:
     121:	78 4d 6f 64 65 6d 20 75 6e 6b 6e 6f 77 6e 20 72     xModem unknown r
     131:	65 73 70 6f 6e 73 65 20 30 78 25 78 0d 0a 00        esponse 0x%x...

00000140 <errorNoRemoteDevice>:
     140:	44 65 76 69 63 65 20 25 64 20 69 73 20 6e 6f 74     Device %d is not
     150:	20 72 65 73 70 6f 6e 64 69 6e 67 20 28 25 64 29      responding (%d)
     160:	0d 0a 00                                            ...

00000163 <errorBootloaderNotResponding>:
     163:	42 6f 6f 74 6c 6f 61 64 65 72 20 69 73 20 6e 6f     Bootloader is no
     173:	74 20 72 65 73 70 6f 6e 64 69 6e 67 0d 0a 00        t responding...

00000182 <errorOpenFile>:
     182:	43 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 20     Can't open file 
     192:	25 73 0d 0a 00                                      %s...

00000197 <systemStateStr>:
     197:	53 79 73 74 65 6d 20 73 74 61 74 65 3a 0d 0a 00     System state:...

000001a7 <statusNumberOfTasksStr>:
     1a7:	20 20 4e 75 6d 62 65 72 20 6f 66 20 74 61 73 6b       Number of task
     1b7:	73 20 3a 20 25 64 0d 0a 00                          s : %d...

000001c0 <statusStaticHeapStateStr>:
     1c0:	20 20 46 72 65 65 52 74 6f 73 20 68 65 61 70 20       FreeRtos heap 
     1d0:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     1e0:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

000001ea <statusDynamicHeapStateStr>:
     1ea:	20 20 4d 61 6c 6c 6f 63 20 68 65 61 70 20 20 20       Malloc heap   
     1fa:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     20a:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000214 <statusRamDiskStateStr>:
     214:	20 20 52 61 6d 20 64 69 73 63 20 73 70 61 63 65       Ram disc space
     224:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     234:	64 20 63 6c 75 73 74 65 72 73 0d 0a 00              d clusters...

00000241 <statusTemperatureStr>:
     241:	20 20 54 65 6d 70 65 72 61 74 75 72 65 20 20 20       Temperature   
     251:	20 20 3a 20 25 64 20 43 0d 0a 00                      : %d C...

0000025c <statusVoltageStr>:
     25c:	20 20 56 6f 6c 74 61 67 65 20 20 20 20 20 20 20       Voltage       
     26c:	20 20 3a 20 25 64 20 56 0d 0a 00                      : %d V...

00000277 <systemRamConfigStr>:
     277:	53 79 73 74 65 6d 20 73 65 74 74 69 6e 67 73 3a     System settings:
     287:	0d 0a 00                                            ...

0000028a <statusMacStr>:
     28a:	20 20 4d 61 63 20 61 64 64 72 65 73 73 20 20 20       Mac address   
     29a:	20 20 3a 20 00                                        : .

0000029f <statusIpStr>:
     29f:	20 20 49 50 20 61 64 64 72 65 73 73 20 20 20 20       IP address    
     2af:	20 20 3a 20 00                                        : .

000002b4 <statusIpMaskStr>:
     2b4:	20 20 6d 61 73 6b 20 20 20 20 20 20 20 20 20 20       mask          
     2c4:	20 20 3a 20 00                                        : .

000002c9 <statusIpGwStr>:
     2c9:	20 20 67 61 74 65 77 61 79 20 20 20 20 20 20 20       gateway       
     2d9:	20 20 3a 20 00                                        : .

000002de <statusRs485listStr>:
     2de:	44 65 74 65 63 74 65 64 20 52 53 20 34 38 35 20     Detected RS 485 
     2ee:	64 65 76 69 63 65 73 3a 0d 0a 00                    devices:...

000002f9 <statusNoRs485Dev>:
     2f9:	20 20 43 61 6e 27 74 20 66 69 6e 64 20 61 6e 79       Can't find any
     309:	20 64 65 76 69 63 65 0d 0a 00                        device...

00000313 <statusLockerSensorsStr>:
     313:	4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73 20 73     Locker sensors s
     323:	74 61 74 65 73 3a 0d 0a 00                          tates:...

0000032c <statusLockerSensorsDisStr>:
     32c:	20 20 4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73       Locker sensors
     33c:	20 64 69 73 61 62 6c 65 64 0d 0a 00                  disabled...

00000348 <editRamFileIntroStr>:
     348:	57 72 69 74 69 6e 67 20 74 6f 20 66 69 6c 65 2e     Writing to file.
     358:	20 50 72 65 73 73 20 43 54 52 4c 2b 43 20 74 6f      Press CTRL+C to
     368:	20 71 75 69 74 0d 0a 00                              quit...

00000370 <readRamFIleLenStr>:
     370:	46 69 6c 65 20 6c 65 6e 67 74 68 3a 20 25 64 0d     File length: %d.
     380:	0a 00                                               ..

00000382 <xwyslijStartStr>:
     382:	58 6d 6f 64 65 6d 3a 20 54 72 61 6e 73 6d 69 73     Xmodem: Transmis
     392:	73 69 6f 6e 20 73 74 61 72 74 0d 0a 00              sion start...

0000039f <movingCurtainUpStr>:
     39f:	50 6f 64 6e 6f 73 7a 65 6e 69 65 20 72 6f 6c 65     Podnoszenie role
     3af:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     3bf:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     3cf:	0d 0a 00                                            ...

000003d2 <movingCurtainDownStr>:
     3d2:	4f 70 75 73 7a 63 7a 61 6e 69 65 20 72 6f 6c 65     Opuszczanie role
     3e2:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     3f2:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     402:	0d 0a 00                                            ...

00000405 <movingCurtainPosStr>:
     405:	09 70 6f 7a 79 63 6a 61 20 20 20 25 64 0d 0a 00     .pozycja   %d...

00000415 <debugEnabledInfoStr>:
     415:	45 6e 61 62 6c 65 64 20 25 73 20 64 65 62 75 67     Enabled %s debug
     425:	0d 0a 00                                            ...

00000428 <debugDisabledInfoStr>:
     428:	44 69 73 61 62 6c 65 64 20 25 73 20 64 65 62 75     Disabled %s debu
     438:	67 0d 0a 00                                         g...

0000043c <cmd_help>:
     43c:	68 65 6c 70 00                                      help.

00000441 <cmd_help_help>:
     441:	50 72 69 6e 74 20 68 65 6c 70 20 73 74 72 69 6e     Print help strin
     451:	67 00                                               g.

00000453 <cmd_status>:
     453:	73 74 61 74 75 73 00                                status.

0000045a <cmd_help_status>:
     45a:	7b 66 69 6c 65 6e 61 6d 65 7d 20 50 72 69 6e 74     {filename} Print
     46a:	20 64 65 76 69 63 65 20 73 74 61 74 75 73 20 6f      device status o
     47a:	6e 20 56 54 59 20 6f 72 20 77 72 69 74 65 20 74     n VTY or write t
     48a:	6f 20 66 69 6c 65 00                                o file.

00000491 <cmd_enc_stat>:
     491:	65 6e 63 73 74 61 74 00                             encstat.

00000499 <cmd_help_enc_stat>:
     499:	50 72 69 6e 74 20 45 6e 63 20 32 38 6a 36 30 20     Print Enc 28j60 
     4a9:	72 65 67 69 73 74 65 72 73 00                       registers.

000004b3 <cmd_time>:
     4b3:	74 69 6d 65 00                                      time.

000004b8 <cmd_help_time>:
     4b8:	50 72 69 6e 74 20 74 69 6d 65 00                    Print time.

000004c3 <cmd_net_dbg>:
     4c3:	64 65 62 75 67 00                                   debug.

000004c9 <cmd_help_net_dbg>:
     4c9:	5b 61 72 70 7c 69 63 6d 70 7c 69 70 7c 74 63 70     [arp|icmp|ip|tcp
     4d9:	7c 75 64 70 5d 20 5b 6c 65 76 65 6c 5d 20 77 72     |udp] [level] wr
     4e9:	69 74 65 20 64 65 62 75 67 20 69 6e 66 6f 2e 20     ite debug info. 
     4f9:	4c 65 76 65 6c 20 30 20 64 69 73 61 62 6c 65 20     Level 0 disable 
     509:	64 65 62 75 67 69 6e 67 00                          debuging.

00000512 <cmd_rping>:
     512:	72 70 69 6e 67 00                                   rping.

00000518 <cmd_help_rping>:
     518:	5b 44 65 76 69 63 65 20 6e 6f 5d 20 53 65 6e 64     [Device no] Send
     528:	20 70 69 6e 67 20 74 6f 20 52 73 34 38 35 20 64      ping to Rs485 d
     538:	65 76 69 63 65 00                                   evice.

0000053e <cmd_ping>:
     53e:	70 69 6e 67 00                                      ping.

00000543 <cmd_help_ping>:
     543:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     553:	41 34 5d 20 53 65 6e 64 73 20 70 69 6e 67 20 74     A4] Sends ping t
     563:	68 72 6f 75 67 68 74 20 65 74 68 65 72 6e 65 74     hrought ethernet
	...

00000574 <cmd_xRec>:
     574:	78 72 65 63 00                                      xrec.

00000579 <cmd_help_xRec>:
     579:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 63 65     [file name] rece
     589:	69 76 65 20 66 69 6c 65 20 75 73 69 6e 67 20 78     ive file using x
     599:	4d 6f 64 65 6d 00                                   Modem.

0000059f <cmd_xSend>:
     59f:	78 73 65 6e 64 00                                   xsend.

000005a5 <cmd_help_xSend>:
     5a5:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 73 65 6e 64     [file name] send
     5b5:	20 66 69 6c 65 20 75 73 69 6e 67 20 78 4d 6f 64      file using xMod
     5c5:	65 6d 00                                            em.

000005c8 <cmd_xflash>:
     5c8:	78 66 6c 61 73 68 00                                xflash.

000005cf <cmd_help_xflash>:
     5cf:	5b 64 65 76 69 63 65 20 6e 6f 5d 20 5b 66 69 6c     [device no] [fil
     5df:	65 20 6e 61 6d 65 5d 20 66 6c 61 73 68 20 64 65     e name] flash de
     5ef:	76 69 63 65 20 63 6f 6e 6e 65 63 74 65 64 20 74     vice connected t
     5ff:	6f 20 52 73 34 38 35 00                             o Rs485.

00000607 <cmd_dir_rf>:
     607:	64 69 72 72 66 00                                   dirrf.

0000060d <cmd_help_dir_rf>:
     60d:	50 72 69 6e 74 20 72 61 6d 64 69 73 6b 20 66 69     Print ramdisk fi
     61d:	6c 65 73 00                                         les.

00000621 <cmd_create_rf>:
     621:	63 72 66 00                                         crf.

00000625 <cmd_help_create_rf>:
     625:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 63 72 65 61     [file name] crea
     635:	74 65 20 72 61 6d 20 66 69 6c 65 00                 te ram file.

00000641 <cmd_erase_rf>:
     641:	65 72 61 73 65 72 66 00                             eraserf.

00000649 <cmd_help_erase_rf>:
     649:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 72 61 73     [file name] eras
     659:	65 20 66 69 6c 65 20 66 72 6f 6d 20 72 61 6d 20     e file from ram 
     669:	64 69 73 6b 00                                      disk.

0000066e <cmd_edit_rf>:
     66e:	65 64 69 74 72 66 00                                editrf.

00000675 <cmd_help_edit_rf>:
     675:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 64 69 74     [file name] edit
     685:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     695:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

0000069f <cmd_read_rf>:
     69f:	72 65 61 64 72 66 00                                readrf.

000006a6 <cmd_help_read_rf>:
     6a6:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 61 64     [file name] read
     6b6:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     6c6:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

000006d0 <cmd_up>:
     6d0:	75 70 00                                            up.

000006d3 <cmd_help_up>:
     6d3:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     6e3:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     6f3:	76 65 20 75 70 00                                   ve up.

000006f9 <cmd_down>:
     6f9:	64 6f 77 6e 00                                      down.

000006fe <cmd_help_down>:
     6fe:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     70e:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     71e:	76 65 20 64 6f 77 6e 00                             ve down.

00000726 <cmd_spa>:
     726:	73 70 61 00                                         spa.

0000072a <cmd_help_spa>:
     72a:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     73a:	20 41 00                                             A.

0000073d <cmd_spb>:
     73d:	73 70 62 00                                         spb.

00000741 <cmd_help_spb>:
     741:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     751:	20 42 00                                             B.

00000754 <cmd_settime>:
     754:	73 65 74 74 69 6d 65 00                             settime.

0000075c <cmd_help_settime>:
     75c:	5b 68 5d 20 5b 6d 5d 20 5b 73 5d 20 73 65 74 20     [h] [m] [s] set 
     76c:	74 69 6d 65 20 28 32 34 68 20 66 6f 72 6d 61 74     time (24h format
     77c:	29 00                                               ).

0000077e <cmd_ac>:
     77e:	61 63 00                                            ac.

00000781 <cmd_help_ac>:
     781:	5b 63 68 61 6e 6e 65 6c 20 30 2d 37 5d 20 72 65     [channel 0-7] re
     791:	61 64 20 61 6e 61 6c 6f 67 20 76 61 6c 75 65 00     ad analog value.

000007a1 <cmd_enable>:
     7a1:	65 6e 61 62 6c 65 00                                enable.

000007a8 <cmd_help_enable>:
     7a8:	45 6e 61 62 6c 65 20 6d 6f 64 65 00                 Enable mode.

000007b4 <cmd_disable>:
     7b4:	64 69 73 61 62 6c 65 00                             disable.

000007bc <cmd_help_disable>:
     7bc:	56 69 65 77 20 6d 6f 64 65 00                       View mode.

000007c6 <cmd_configure>:
     7c6:	63 6f 6e 66 69 67 00                                config.

000007cd <cmd_help_configure>:
     7cd:	43 6f 6e 66 69 67 75 72 65 20 6d 6f 64 65 00        Configure mode.

000007dc <cmd_conf_ip>:
     7dc:	69 70 00                                            ip.

000007df <cmd_help_conf_ip>:
     7df:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     7ef:	41 34 5d 20 73 65 74 20 49 50 20 61 64 64 72 65     A4] set IP addre
     7ff:	73 73 00                                            ss.

00000802 <cmd_conf_udp>:
     802:	75 64 70 00                                         udp.

00000806 <cmd_help_conf_udp>:
     806:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     816:	41 34 5d 20 5b 73 72 63 20 70 6f 72 74 5d 20 7b     A4] [src port] {
     826:	64 73 74 20 70 6f 72 74 7d 20 73 65 74 20 75 64     dst port} set ud
     836:	70 20 63 6c 69 65 6e 74 20 49 50 20 61 64 64 72     p client IP addr
     846:	65 73 73 20 61 6e 64 20 70 6f 72 74 73 00           ess and ports.

00000854 <cmd_conf_ip_mask>:
     854:	6d 61 73 6b 00                                      mask.

00000859 <cmd_conf_ip_mask_help>:
     859:	5b 6d 61 73 6b 5d 20 73 65 74 20 6d 61 73 6b 00     [mask] set mask.

00000869 <cmd_conf_ip_gw>:
     869:	67 77 00                                            gw.

0000086c <cmd_conf_ip_gw_help>:
     86c:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     87c:	41 34 5d 20 73 65 74 20 64 65 66 61 75 6c 74 20     A4] set default 
     88c:	67 61 74 65 77 61 79 00                             gateway.

00000894 <cmd_conf_mac>:
     894:	6d 61 63 00                                         mac.

00000898 <cmd_help_conf_mac>:
     898:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     8a8:	41 34 5d 20 5b 41 35 5d 20 5b 41 36 5d 20 73 65     A4] [A5] [A6] se
     8b8:	74 20 4d 41 43 20 61 64 64 72 65 73 73 00           t MAC address.

000008c6 <cmd_conf_save>:
     8c6:	73 61 76 65 00                                      save.

000008cb <cmd_help_conf_save>:
     8cb:	53 61 76 65 20 63 6f 6e 66 69 67 75 72 61 74 69     Save configurati
     8db:	6f 6e 00                                            on.

000008de <cmd_ustawR>:
     8de:	73 65 74 72 00                                      setr.

000008e3 <cmd_help_ustawR>:
     8e3:	5b 76 61 6c 75 65 5d 20 73 65 74 20 72 65 73 69     [value] set resi
     8f3:	73 74 61 6e 63 65 20 76 61 6c 75 65 00              stance value.

00000900 <okStr>:
     900:	4f 4b 0d 0a 00                                      OK...

00000905 <nlStr>:
     905:	0d 0a 00                                            ...

00000908 <BladBuforaPozostaloBajtowStr>:
     908:	21 21 21 20 57 20 62 75 64 6f 72 7a 65 20 52 73     !!! W budorze Rs
     918:	34 38 35 20 70 6f 7a 6f 73 74 61 6c 6f 20 25 64     485 pozostalo %d
     928:	20 62 61 6a 74 6f 77 0d 0a 00                        bajtow...

00000932 <errorStrings>:
     932:	c8 00 d1 00 db 00 de 00 e1 00 e4 00 e7 00 fa 00     ................
     942:	21 01 40 01 63 01 82 01                             !.@.c...

0000094a <cmdListNormal>:
     94a:	3c 04 41 04 e9 18 53 04 5a 04 c6 1a b3 04 b8 04     <.A...S.Z.......
     95a:	74 18 12 05 18 05 61 14 3e 05 43 05 e3 0f 07 06     t.....a.>.C.....
     96a:	0d 06 6c 18 9f 06 a6 06 c9 17 a1 07 a8 07 79 0f     ..l...........y.
     97a:	00 00 00 00 00 00                                   ......

00000980 <cmdListEnable>:
     980:	3c 04 41 04 e9 18 53 04 5a 04 c6 1a 91 04 99 04     <.A...S.Z.......
     990:	c1 17 b3 04 b8 04 74 18 c3 04 c9 04 dc 16 12 05     ......t.........
     9a0:	18 05 61 14 3e 05 43 05 e3 0f 74 05 79 05 e8 14     ..a.>.C...t.y...
     9b0:	9f 05 a5 05 5b 13 c8 05 cf 05 87 14 07 06 0d 06     ....[...........
     9c0:	6c 18 21 06 25 06 44 14 41 06 49 06 2d 14 6e 06     l.!.%.D.A.I.-.n.
     9d0:	75 06 ad 13 9f 06 a6 06 c9 17 d0 06 d3 06 d9 12     u...............
     9e0:	f9 06 fe 06 63 12 26 07 2a 07 51 12 3d 07 41 07     ....c.&.*.Q.=.A.
     9f0:	3f 12 de 08 e3 08 2d 12 54 07 5c 07 c6 11 7e 07     ?.....-.T.\...~.
     a00:	81 07 4f 11 b4 07 bc 07 8a 0f c6 07 cd 07 96 0f     ..O.............
     a10:	00 00 00 00 00 00                                   ......

00000a16 <cmdListConfigure>:
     a16:	3c 04 41 04 e9 18 53 04 5a 04 c6 1a b3 04 b8 04     <.A...S.Z.......
     a26:	74 18 54 07 5c 07 c6 11 dc 07 df 07 f7 10 54 08     t.T.\.........T.
     a36:	59 08 d7 10 69 08 6c 08 7f 10 02 08 06 08 02 10     Y...i.l.........
     a46:	94 08 98 08 ac 0f c6 08 cb 08 a7 0f a1 07 a8 07     ................
     a56:	79 0f b4 07 bc 07 8a 0f 00 00 00 00 00 00           y.............

00000a64 <__c.3417>:
     a64:	57 61 72 74 6f 73 63 20 70 72 6f 62 6b 69 20 6e     Wartosc probki n
     a74:	61 20 77 65 6a 73 63 69 75 20 25 64 3a 20 25 64     a wejsciu %d: %d
     a84:	0d 0a 00                                            ...

00000a87 <__c.3535>:
     a87:	58 6d 6f 64 65 6d 3a 20 72 6f 7a 70 6f 63 7a 79     Xmodem: rozpoczy
     a97:	6e 61 6e 69 65 20 6f 64 62 69 6f 72 75 0d 0a 00     nanie odbioru...

00000aa7 <__c.3287>:
     aa7:	75 64 70 00                                         udp.

00000aab <__c.3285>:
     aab:	74 63 70 00                                         tcp.

00000aaf <__c.3283>:
     aaf:	69 63 6d 70 00                                      icmp.

00000ab4 <__c.3281>:
     ab4:	69 70 00                                            ip.

00000ab7 <__c.3279>:
     ab7:	61 72 70 00                                         arp.

00000abb <__c.3277>:
     abb:	75 64 70 00                                         udp.

00000abf <__c.3275>:
     abf:	74 63 70 00                                         tcp.

00000ac3 <__c.3273>:
     ac3:	69 63 6d 70 00                                      icmp.

00000ac8 <__c.3271>:
     ac8:	69 70 00                                            ip.

00000acb <__c.3269>:
     acb:	61 72 70 00                                         arp.

00000acf <__c.3239>:
     acf:	41 6b 74 75 61 6c 6e 79 20 63 7a 61 73 20 25 64     Aktualny czas %d
     adf:	3a 25 64 3a 25 64 0d 0a 00                          :%d:%d...

00000ae8 <__c.3198>:
     ae8:	0d 0a 00                                            ...

00000aeb <__c.3196>:
     aeb:	0d 0a 00                                            ...

00000aee <__c.3194>:
     aee:	0d 0a 00                                            ...

00000af1 <__c.3192>:
     af1:	0d 0a 00                                            ...

00000af4 <__c.3189>:
     af4:	46 72 65 65 52 74 6f 73 2b 20 76 65 72 20 30 2e     FreeRtos+ ver 0.
     b04:	33 31 20 62 75 69 6c 64 3a 20 4a 75 6c 20 31 37     31 build: Jul 17
     b14:	20 32 30 31 31 2c 20 31 38 3a 33 37 3a 34 39 0d      2011, 18:37:49.
     b24:	0a 00                                               ..

00000b26 <__c.2984>:
     b26:	55 6e 6b 6e 6f 77 6e 20 70 61 63 6b 65 74 0d 0a     Unknown packet..
	...

00000b37 <__c.1665>:
     b37:	52 65 73 74 61 72 74 0d 0a 00                       Restart...

00000b41 <CmdlinePromptNormal>:
     b41:	44 6f 6d 4f 73 3e 00                                DomOs>.

00000b48 <CmdlinePromptEnable>:
     b48:	44 6f 6d 4f 73 23 00                                DomOs#.

00000b4f <CmdlinePromptConfigure>:
     b4f:	44 6f 6d 4f 73 40 00                                DomOs@.

00000b56 <CmdlineNotice>:
     b56:	63 6d 64 6c 69 6e 65 3a 20 00                       cmdline: .

00000b60 <CmdlineCmdNotFound>:
     b60:	23 20 6e 6b 00                                      # nk.

00000b65 <__c.3333>:
     b65:	0d 0a 00                                            ...

00000b68 <__c.3331>:
     b68:	09 00                                               ..

00000b6a <__c.3215>:
     b6a:	4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 61 6c     Operation not al
     b7a:	6c 6f 77 65 64 0d 0a 00                             lowed...

00000b82 <__c.3212>:
     b82:	4f 70 65 72 61 74 69 6f 6e 20 66 61 69 6c 65 64     Operation failed
     b92:	0d 0a 00                                            ...

00000b95 <__c.3209>:
     b95:	0d 0a 00                                            ...

00000b98 <__c.3207>:
     b98:	20 00                                                .

00000b9a <__c.3205>:
     b9a:	53 79 6e 74 61 78 20 45 72 72 6f 72 2e 20 55 73     Syntax Error. Us
     baa:	65 3a 20 00                                         e: .

00000bae <__c.3201>:
     bae:	4f 4b 0d 0a 00                                      OK...

00000bb3 <__c.3230>:
     bb3:	09 4d 41 41 44 52 35 20 30 78 25 78 0d 0a 00        .MAADR5 0x%x...

00000bc2 <__c.3228>:
     bc2:	09 4d 41 41 44 52 34 20 30 78 25 78 0d 0a 00        .MAADR4 0x%x...

00000bd1 <__c.3226>:
     bd1:	09 4d 41 41 44 52 33 20 30 78 25 78 0d 0a 00        .MAADR3 0x%x...

00000be0 <__c.3224>:
     be0:	09 4d 41 41 44 52 32 20 30 78 25 78 0d 0a 00        .MAADR2 0x%x...

00000bef <__c.3222>:
     bef:	09 4d 41 41 44 52 31 20 30 78 25 78 0d 0a 00        .MAADR1 0x%x...

00000bfe <__c.3220>:
     bfe:	09 4d 41 41 44 52 30 20 30 78 25 78 0d 0a 00        .MAADR0 0x%x...

00000c0d <__c.3218>:
     c0d:	45 4e 43 32 38 6a 36 30 20 73 74 61 6e 20 72 65     ENC28j60 stan re
     c1d:	6a 65 73 74 72 6f 77 3a 0d 0a 00                    jestrow:...

00000c28 <__c.1794>:
     c28:	4e 49 43 20 72 65 67 20 64 75 6d 70 20 6e 6f 74     NIC reg dump not
     c38:	20 69 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00         implemented...

00000c47 <__c.1706>:
     c47:	0d 0a 00                                            ...

00000c4a <__c.1704>:
     c4a:	55 52 47 20 00                                      URG .

00000c4f <__c.1702>:
     c4f:	41 43 4b 20 00                                      ACK .

00000c54 <__c.1700>:
     c54:	50 53 48 20 00                                      PSH .

00000c59 <__c.1698>:
     c59:	52 53 54 20 00                                      RST .

00000c5e <__c.1696>:
     c5e:	53 59 4e 20 00                                      SYN .

00000c63 <__c.1694>:
     c63:	46 49 4e 20 00                                      FIN .

00000c68 <__c.1692>:
     c68:	46 6c 61 67 73 20 20 20 3a 20 00                    Flags   : .

00000c73 <__c.1690>:
     c73:	41 63 6b 20 4e 75 6d 20 3a 20 30 78 25 78 0d 0a     Ack Num : 0x%x..
	...

00000c84 <__c.1688>:
     c84:	53 65 71 20 4e 75 6d 20 3a 20 30 78 25 78 00        Seq Num : 0x%x.

00000c93 <__c.1686>:
     c93:	44 73 74 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Dst Port: %d...

00000ca2 <__c.1684>:
     ca2:	53 72 63 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Src Port: %d...

00000cb1 <__c.1682>:
     cb1:	54 43 50 20 48 65 61 64 65 72 0d 0a 00              TCP Header...

00000cbe <__c.1665>:
     cbe:	0d 0a 00                                            ...

00000cc1 <__c.1663>:
     cc1:	44 65 73 74 20 20 49 50 3a 20 00                    Dest  IP: .

00000ccc <__c.1661>:
     ccc:	0d 0a 00                                            ...

00000ccf <__c.1659>:
     ccf:	53 6f 75 72 63 65 49 50 3a 20 00                    SourceIP: .

00000cda <__c.1657>:
     cda:	50 72 6f 74 6f 63 6f 6c 3a 20 25 64 0d 0a 00        Protocol: %d...

00000ce9 <__c.1655>:
     ce9:	50 72 6f 74 6f 63 6f 6c 3a 20 55 44 50 0d 0a 00     Protocol: UDP...

00000cf9 <__c.1653>:
     cf9:	50 72 6f 74 6f 63 6f 6c 3a 20 54 43 50 0d 0a 00     Protocol: TCP...

00000d09 <__c.1651>:
     d09:	50 72 6f 74 6f 63 6f 6c 3a 20 49 43 4d 50 0d 0a     Protocol: ICMP..
	...

00000d1a <__c.1649>:
     d1a:	4c 65 6e 67 74 68 20 20 3a 20 25 64 0d 0a 00        Length  : %d...

00000d29 <__c.1647>:
     d29:	56 65 72 20 20 20 20 20 3a 20 25 64 0d 0a 00        Ver     : %d...

00000d38 <__c.1645>:
     d38:	49 50 20 48 65 61 64 65 72 0d 0a 00                 IP Header...

00000d44 <__c.1636>:
     d44:	2d 3e 44 53 54 3a 00                                ->DST:.

00000d4b <__c.1634>:
     d4b:	20 53 52 43 3a 00                                    SRC:.

00000d51 <__c.1632>:
     d51:	45 74 68 20 50 61 63 6b 65 74 20 54 79 70 65 3a     Eth Packet Type:
     d61:	20 30 78 25 78 00                                    0x%x.

00000d67 <__c.1614>:
     d67:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

00000d73 <__c.1596>:
     d73:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
     d83:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

00000d91 <__c.2358>:
     d91:	0d 0a 00                                            ...

00000d94 <__c.2356>:
     d94:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00000d9f <__c.2354>:
     d9f:	0d 0a 00                                            ...

00000da2 <__c.2352>:
     da2:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00000dad <__c.2350>:
     dad:	0d 0a 00                                            ...

00000db0 <__c.2348>:
     db0:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00000dbb <__c.2331>:
     dbb:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     dcb:	6c 65 28 6c 65 6e 2d 45 54 48 5f 48 45 41 44 45     le(len-ETH_HEADE
     ddb:	52 5f 4c 45 4e 2c 20 26 64 61 74 61 5b 45 54 48     R_LEN, &data[ETH
     deb:	5f 48 45 41 44 45 52 5f 4c 45 4e 5d 29 3b 00        _HEADER_LEN]);.

00000dfa <__c.2329>:
     dfa:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     e0a:	6c 65 28 45 54 48 5f 48 45 41 44 45 52 5f 4c 45     le(ETH_HEADER_LE
     e1a:	4e 2c 20 26 64 61 74 61 5b 30 5d 29 3b 00           N, &data[0]);.

00000e28 <__c.2327>:
     e28:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     e38:	74 20 74 6f 20 67 61 74 65 77 61 79 0d 0a 00        t to gateway...

00000e47 <__c.2325>:
     e47:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     e57:	74 20 6f 6e 20 6c 6f 63 61 6c 20 6e 65 74 0d 0a     t on local net..
	...

00000e68 <__c.2283>:
     e68:	4e 45 54 20 52 78 3a 20 55 6e 6b 6e 6f 77 6e 20     NET Rx: Unknown 
     e78:	49 50 20 70 61 63 6b 65 74 0d 0a 00                 IP packet...

00000e84 <__c.2281>:
     e84:	4e 45 54 20 52 78 3a 20 54 43 50 2f 49 50 20 70     NET Rx: TCP/IP p
     e94:	61 63 6b 65 74 0d 0a 00                             acket...

00000e9c <__c.2279>:
     e9c:	4e 45 54 20 52 78 3a 20 55 44 50 2f 49 50 20 70     NET Rx: UDP/IP p
     eac:	61 63 6b 65 74 0d 0a 00                             acket...

00000eb4 <__c.2277>:
     eb4:	4e 45 54 20 52 78 3a 20 49 43 4d 50 2f 49 50 20     NET Rx: ICMP/IP 
     ec4:	70 61 63 6b 65 74 0d 0a 00                          packet...

00000ecd <__c.2326>:
     ecd:	43 6f 64 65 20 20 20 3a 20 30 78 25 78 0d 0a 00     Code   : 0x%x...

00000edd <__c.2324>:
     edd:	0d 0a 00                                            ...

00000ee0 <__c.2321>:
     ee0:	45 43 48 4f 20 52 45 50 4c 59 00                    ECHO REPLY.

00000eeb <__c.2317>:
     eeb:	45 43 48 4f 20 52 45 51 55 45 53 54 00              ECHO REQUEST.

00000ef8 <__c.2314>:
     ef8:	54 79 70 65 20 20 20 3a 20 00                       Type   : .

00000f02 <__c.2312>:
     f02:	0d 0a 00                                            ...

00000f05 <__c.2310>:
     f05:	44 73 74 49 70 41 64 64 72 3a 20 00                 DstIpAddr: .

00000f11 <__c.2308>:
     f11:	0d 0a 00                                            ...

00000f14 <__c.2306>:
     f14:	53 72 63 49 70 41 64 64 72 3a 20 00                 SrcIpAddr: .

00000f20 <__c.2304>:
     f20:	49 43 4d 50 20 50 61 63 6b 65 74 3a 0d 0a 00        ICMP Packet:...

00000f2f <__c.2281>:
     f2f:	53 65 6e 64 69 6e 67 20 49 43 4d 50 20 50 4f 4e     Sending ICMP PON
     f3f:	47 0d 0a 00                                         G...

00000f43 <__c.2278>:
     f43:	52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72 65     Received ICMP re
     f53:	71 75 65 73 74 3a 20 00                             quest: .

00000f5b <__c.2268>:
     f5b:	55 6e 6b 6e 6f 77 6e 20 49 43 4d 50 20 74 79 70     Unknown ICMP typ
     f6b:	65 52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72     eReceived ICMP r
     f7b:	65 71 75 65 73 74 3a 20 00                          equest: .

00000f84 <__c.2398>:
     f84:	0d 0a 00                                            ...

00000f87 <__c.2396>:
     f87:	20 20 00                                              .

00000f8a <__c.2394>:
     f8a:	25 33 64 20 20 00                                   %3d  .

00000f90 <__c.2391>:
     f90:	0d 0a 00                                            ...

00000f93 <__c.2389>:
     f93:	20 20 00                                              .

00000f96 <__c.2387>:
     f96:	20 4d 59 20 20 00                                    MY  .

00000f9c <__c.2385>:
     f9c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fac:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fbc:	2d 2d 2d 0d 0a 00                                   ---...

00000fc2 <__c.2383>:
     fc2:	54 69 6d 65 20 45 74 68 20 41 64 64 72 65 73 73     Time Eth Address
     fd2:	20 20 20 20 20 20 20 20 49 50 20 41 64 64 72 65             IP Addre
     fe2:	73 73 0d 0a 00                                      ss...

00000fe7 <__c.2370>:
     fe7:	0d 0a 00                                            ...

00000fea <__c.2368>:
     fea:	44 73 74 50 72 6f 74 6f 41 64 64 72 3a 20 00        DstProtoAddr: .

00000ff9 <__c.2366>:
     ff9:	0d 0a 00                                            ...

00000ffc <__c.2364>:
     ffc:	44 73 74 48 77 41 64 64 72 20 20 20 3a 20 00        DstHwAddr   : .

0000100b <__c.2362>:
    100b:	0d 0a 00                                            ...

0000100e <__c.2360>:
    100e:	53 72 63 50 72 6f 74 6f 41 64 64 72 3a 20 00        SrcProtoAddr: .

0000101d <__c.2358>:
    101d:	0d 0a 00                                            ...

00001020 <__c.2356>:
    1020:	53 72 63 48 77 41 64 64 72 20 20 20 3a 20 00        SrcHwAddr   : .

0000102f <__c.2354>:
    102f:	0d 0a 00                                            ...

00001032 <__c.2352>:
    1032:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

0000103a <__c.2350>:
    103a:	52 45 50 4c 59 00                                   REPLY.

00001040 <__c.2348>:
    1040:	52 45 51 55 45 53 54 00                             REQUEST.

00001048 <__c.2346>:
    1048:	4f 70 65 72 61 74 69 6f 6e 20 20 20 3a 20 00        Operation   : .

00001057 <__c.2344>:
    1057:	41 52 50 20 50 61 63 6b 65 74 3a 0d 0a 00           ARP Packet:...

00001065 <__c.2294>:
    1065:	0d 0a 00                                            ...

00001068 <__c.2292>:
    1068:	20 49 50 3a 20 00                                    IP: .

0000106e <__c.2290>:
    106e:	41 52 50 20 49 50 20 69 6e 20 4d 41 43 3a 20 00     ARP IP in MAC: .

0000107e <__c.2275>:
    107e:	53 65 6e 64 69 6e 67 20 41 52 50 20 52 65 70 6c     Sending ARP Repl
    108e:	79 0d 0a 00                                         y...

00001092 <__c.2273>:
    1092:	52 65 63 65 69 76 65 64 20 41 52 50 20 52 65 71     Received ARP Req
    10a2:	75 65 73 74 0d 0a 00                                uest...

000010a9 <__c.2382>:
    10a9:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
    10b9:	6e 74 65 64 0d 0a 00                                nted...

000010c0 <__c.2332>:
    10c0:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    10d0:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
    10e0:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
    10f0:	74 0d 0a 00                                         t...

000010f4 <__c.2330>:
    10f4:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1104:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    1114:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
    1124:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
    1134:	49 53 48 45 44 0d 0a 00                             ISHED...

0000113c <__c.2328>:
    113c:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    114c:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
    115c:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
    116c:	74 0d 0a 00                                         t...

00001170 <__c.2326>:
    1170:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1180:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    1190:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
    11a0:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
    11b0:	0a 00                                               ..

000011b2 <__c.2295>:
    11b2:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
    11c2:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
    11d2:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

000011dc <__c.2290>:
    11dc:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    11ec:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
    11fc:	54 45 4e 0d 0a 00                                   TEN...

00001202 <__c.2285>:
    1202:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    1212:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

0000121e <__c.2363>:
    121e:	25 64 0d 0a 00                                      %d...

00001223 <__c.2361>:
    1223:	41 4e 59 0d 0a 00                                   ANY...

00001229 <__c.2359>:
    1229:	0d 0a 20 20 73 72 63 20 70 6f 72 74 20 20 20 20     ..  src port    
    1239:	3a 20 25 64 0d 0a 20 20 64 73 74 20 70 6f 72 74     : %d..  dst port
    1249:	20 20 20 20 3a 20 00                                    : .

00001250 <__c.2357>:
    1250:	0d 0a 20 20 49 50 20 20 20 20 20 20 20 20 20 20     ..  IP          
    1260:	3a 20 00                                            : .

00001263 <__c.2355>:
    1263:	55 44 50 20 63 6f 6e 66 69 67 3a 00                 UDP config:.

0000126f <__c.2309>:
    126f:	0d 0a 00                                            ...

00001272 <__c.2304>:
    1272:	55 44 50 20 54 58 20 62 75 66 66 65 72 20 62 75     UDP TX buffer bu
    1282:	73 79 0d 0a 00                                      sy...

00001287 <__c.2302>:
    1287:	30 78 25 32 78 0d 0a 00                             0x%2x...

0000128f <__c.2300>:
    128f:	52 65 63 65 69 76 65 64 20 64 61 74 61 3a 20 00     Received data: .

0000129f <__c.2297>:
    129f:	50 72 6f 63 2e 20 55 44 50 20 70 61 63 6b 65 74     Proc. UDP packet
    12af:	20 28 64 61 74 61 20 6c 65 6e 67 74 68 20 25 64      (data length %d
    12bf:	29 0d 0a 00                                         )...

000012c3 <__c.2280>:
    12c3:	53 65 6e 64 69 6e 67 20 55 44 50 20 70 61 63 6b     Sending UDP pack
    12d3:	65 74 20 28 64 61 74 61 20 6c 65 6e 67 74 68 20     et (data length 
    12e3:	25 64 29 0d 0a 00                                   %d)...

000012e9 <statusRollerDescStr>:
    12e9:	20 25 64 20 72 6f 6c 6c 65 72 20 64 72 69 76 65      %d roller drive
    12f9:	72 3a 20 72 6f 6c 6c 65 72 20 31 20 70 6f 73 69     r: roller 1 posi
    1309:	74 69 6f 6e 20 25 64 2c 20 72 6f 6c 6c 65 72 20     tion %d, roller 
    1319:	32 20 70 6f 73 69 74 69 6f 6e 20 25 64 00           2 position %d.

00001327 <statusRollerDescStr2>:
    1327:	2c 20 66 69 72 6d 77 61 72 65 20 25 73 0d 0a 00     , firmware %s...

00001337 <__c.3192>:
    1337:	0d 0a 4f 4b 0d 0a 00                                ..OK...

0000133e <__c.3183>:
    133e:	62 6f 6f 74 6c 6f 61 64 65 72 20 6e 69 65 20 72     bootloader nie r
    134e:	6f 7a 70 6f 63 7a 61 6c 20 6f 64 62 69 6f 72 75     ozpoczal odbioru
    135e:	20 64 61 6e 79 63 68 0d 0a 00                        danych...

00001368 <__c.3181>:
    1368:	6e 61 20 75 72 7a 61 64 7a 65 6e 69 75 20 77 67     na urzadzeniu wg
    1378:	72 61 6e 79 20 6a 65 73 74 20 74 79 6c 6b 6f 20     rany jest tylko 
    1388:	62 6f 6f 74 6c 6f 61 64 65 72 0d 0a 00              bootloader...

00001395 <__c.3179>:
    1395:	72 46 4c 41 53 48 20 74 69 6d 65 6f 75 74 0d 0a     rFLASH timeout..
	...

000013a6 <__ctors_end>:
    13a6:	11 24       	eor	r1, r1
    13a8:	1f be       	out	0x3f, r1	; 63
    13aa:	cf ef       	ldi	r28, 0xFF	; 255
    13ac:	d0 e1       	ldi	r29, 0x10	; 16
    13ae:	de bf       	out	0x3e, r29	; 62
    13b0:	cd bf       	out	0x3d, r28	; 61

000013b2 <__do_copy_data>:
    13b2:	11 e0       	ldi	r17, 0x01	; 1
    13b4:	a0 e0       	ldi	r26, 0x00	; 0
    13b6:	b1 e0       	ldi	r27, 0x01	; 1
    13b8:	ee e6       	ldi	r30, 0x6E	; 110
    13ba:	fb eb       	ldi	r31, 0xBB	; 187
    13bc:	00 e0       	ldi	r16, 0x00	; 0
    13be:	0b bf       	out	0x3b, r16	; 59
    13c0:	02 c0       	rjmp	.+4      	; 0x13c6 <__do_copy_data+0x14>
    13c2:	07 90       	elpm	r0, Z+
    13c4:	0d 92       	st	X+, r0
    13c6:	a8 38       	cpi	r26, 0x88	; 136
    13c8:	b1 07       	cpc	r27, r17
    13ca:	d9 f7       	brne	.-10     	; 0x13c2 <__do_copy_data+0x10>

000013cc <initExternalMem>:
    13cc:	85 b7       	in	r24, 0x35	; 53
    13ce:	80 68       	ori	r24, 0x80	; 128
    13d0:	85 bf       	out	0x35, r24	; 53
    13d2:	85 b7       	in	r24, 0x35	; 53
    13d4:	8e 60       	ori	r24, 0x0E	; 14
    13d6:	85 bf       	out	0x35, r24	; 53

000013d8 <__do_clear_bss>:
    13d8:	1f e0       	ldi	r17, 0x0F	; 15
    13da:	a8 e8       	ldi	r26, 0x88	; 136
    13dc:	b1 e0       	ldi	r27, 0x01	; 1
    13de:	01 c0       	rjmp	.+2      	; 0x13e2 <.do_clear_bss_start>

000013e0 <.do_clear_bss_loop>:
    13e0:	1d 92       	st	X+, r1

000013e2 <.do_clear_bss_start>:
    13e2:	a4 3e       	cpi	r26, 0xE4	; 228
    13e4:	b1 07       	cpc	r27, r17
    13e6:	e1 f7       	brne	.-8      	; 0x13e0 <.do_clear_bss_loop>
    13e8:	0e 94 26 0a 	call	0x144c	; 0x144c <main>
    13ec:	0c 94 b5 5d 	jmp	0xbb6a	; 0xbb6a <_exit>

000013f0 <__bad_interrupt>:
    13f0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000013f4 <vApplicationTickHook>:
}

void vApplicationTickHook( void )
{
  static uint8_t tickCntr = configTICK_RATE_HZ;
  if (--tickCntr == 0)
    13f4:	80 91 00 01 	lds	r24, 0x0100
    13f8:	81 50       	subi	r24, 0x01	; 1
    13fa:	80 93 00 01 	sts	0x0100, r24
    13fe:	88 23       	and	r24, r24
    1400:	29 f4       	brne	.+10     	; 0x140c <vApplicationTickHook+0x18>
  {
    tickCntr = configTICK_RATE_HZ;
    1402:	84 e6       	ldi	r24, 0x64	; 100
    1404:	80 93 00 01 	sts	0x0100, r24
    arpTimer();    
    1408:	0e 94 31 36 	call	0x6c62	; 0x6c62 <arpTimer>
    140c:	08 95       	ret

0000140e <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
    140e:	0e 94 af 53 	call	0xa75e	; 0xa75e <vCoRoutineSchedule>
    1412:	fd cf       	rjmp	.-6      	; 0x140e <vApplicationIdleHook>

00001414 <vBlinkLed>:
  return 0;
}
/*-----------------------------------------------------------*/

void vBlinkLed( void )
{
    1414:	ff 92       	push	r15
    1416:	0f 93       	push	r16
    1418:	1f 93       	push	r17
    141a:	df 93       	push	r29
    141c:	cf 93       	push	r28
    141e:	00 d0       	rcall	.+0      	; 0x1420 <vBlinkLed+0xc>
    1420:	cd b7       	in	r28, 0x3d	; 61
    1422:	de b7       	in	r29, 0x3e	; 62
  portTickType xLastWakeTime;
  const portTickType xFrequency = 100;
  // Initialise the xLastWakeTime variable with the current time.
  xLastWakeTime = xTaskGetTickCount ();
    1424:	0e 94 e7 48 	call	0x91ce	; 0x91ce <xTaskGetTickCount>
    1428:	9a 83       	std	Y+2, r25	; 0x02
    142a:	89 83       	std	Y+1, r24	; 0x01
	 
  for(;;)
  {
      // Wait for the next cycle.
      vTaskDelayUntil( &xLastWakeTime, xFrequency );
    142c:	8e 01       	movw	r16, r28
    142e:	0f 5f       	subi	r16, 0xFF	; 255
    1430:	1f 4f       	sbci	r17, 0xFF	; 255
      //portTickType xDelay = 100 / portTICK_RATE_MS;
      //vTaskDelay(xDelay);
      PORTF ^= 0x04; 
    1432:	84 e0       	ldi	r24, 0x04	; 4
    1434:	f8 2e       	mov	r15, r24
  xLastWakeTime = xTaskGetTickCount ();
	 
  for(;;)
  {
      // Wait for the next cycle.
      vTaskDelayUntil( &xLastWakeTime, xFrequency );
    1436:	c8 01       	movw	r24, r16
    1438:	64 e6       	ldi	r22, 0x64	; 100
    143a:	70 e0       	ldi	r23, 0x00	; 0
    143c:	0e 94 0c 4e 	call	0x9c18	; 0x9c18 <vTaskDelayUntil>
      //portTickType xDelay = 100 / portTICK_RATE_MS;
      //vTaskDelay(xDelay);
      PORTF ^= 0x04; 
    1440:	80 91 62 00 	lds	r24, 0x0062
    1444:	8f 25       	eor	r24, r15
    1446:	80 93 62 00 	sts	0x0062, r24
    144a:	f5 cf       	rjmp	.-22     	; 0x1436 <vBlinkLed+0x22>

0000144c <main>:
FILE udpStream;

streamBuffers_t udpBuffers;

portSHORT main( void )
{
    144c:	af 92       	push	r10
    144e:	bf 92       	push	r11
    1450:	cf 92       	push	r12
    1452:	df 92       	push	r13
    1454:	ef 92       	push	r14
    1456:	ff 92       	push	r15
    1458:	0f 93       	push	r16
    145a:	1f 93       	push	r17
  ramDyskInit();              //Inicjalizacja Ram dysku
    145c:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <ramDyskInit>
  hardwareInit();
    1460:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <hardwareInit>
  spiInit(disableAllSpiDevices);
    1464:	8a e0       	ldi	r24, 0x0A	; 10
    1466:	9d e0       	ldi	r25, 0x0D	; 13
    1468:	0e 94 04 1c 	call	0x3808	; 0x3808 <spiInit>

// VTY on serial  
  xSerialPortInitMinimal(); 
    146c:	0e 94 b9 0c 	call	0x1972	; 0x1972 <xSerialPortInitMinimal>
  CLIStateSerialUsb  = xmalloc(sizeof(cmdState_t));
    1470:	83 e2       	ldi	r24, 0x23	; 35
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	0e 94 2e 1c 	call	0x385c	; 0x385c <xmalloc>
    1478:	90 93 9f 0e 	sts	0x0E9F, r25
    147c:	80 93 9e 0e 	sts	0x0E9E, r24
  CLIStateSerialUdp  = xmalloc(sizeof(cmdState_t));
    1480:	83 e2       	ldi	r24, 0x23	; 35
    1482:	90 e0       	ldi	r25, 0x00	; 0
    1484:	0e 94 2e 1c 	call	0x385c	; 0x385c <xmalloc>
    1488:	90 93 61 0f 	sts	0x0F61, r25
    148c:	80 93 60 0f 	sts	0x0F60, r24


//  cmdStateClear(newCmdState);
  
  sensorsTaskInit();
    1490:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <sensorsTaskInit>
  loadConfiguration();
    1494:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <loadConfiguration>

  initQueueStreamUSB(&usbStream);
    1498:	0b e6       	ldi	r16, 0x6B	; 107
    149a:	1e e0       	ldi	r17, 0x0E	; 14
    149c:	c8 01       	movw	r24, r16
    149e:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <initQueueStreamUSB>
  VtyInit(CLIStateSerialUsb, &usbStream);
    14a2:	80 91 9e 0e 	lds	r24, 0x0E9E
    14a6:	90 91 9f 0e 	lds	r25, 0x0E9F
    14aa:	b8 01       	movw	r22, r16
    14ac:	0e 94 2d 1b 	call	0x365a	; 0x365a <VtyInit>

  udpInit();
    14b0:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <udpInit>
  socketInit();
    14b4:	0e 94 e8 3c 	call	0x79d0	; 0x79d0 <socketInit>
  initQueueStream(&udpStream, &udpBuffers, udpSocket->Rx, udpSocket->Tx);
    14b8:	e0 91 a2 0e 	lds	r30, 0x0EA2
    14bc:	f0 91 a3 0e 	lds	r31, 0x0EA3
    14c0:	0e e8       	ldi	r16, 0x8E	; 142
    14c2:	1e e0       	ldi	r17, 0x0E	; 14
    14c4:	42 85       	ldd	r20, Z+10	; 0x0a
    14c6:	53 85       	ldd	r21, Z+11	; 0x0b
    14c8:	24 85       	ldd	r18, Z+12	; 0x0c
    14ca:	35 85       	ldd	r19, Z+13	; 0x0d
    14cc:	c8 01       	movw	r24, r16
    14ce:	65 ec       	ldi	r22, 0xC5	; 197
    14d0:	7e e0       	ldi	r23, 0x0E	; 14
    14d2:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <initQueueStream>
  VtyInit(CLIStateSerialUdp, &udpStream);
    14d6:	80 91 60 0f 	lds	r24, 0x0F60
    14da:	90 91 61 0f 	lds	r25, 0x0F61
    14de:	b8 01       	movw	r22, r16
    14e0:	0e 94 2d 1b 	call	0x365a	; 0x365a <VtyInit>
  
  xTaskCreate(encTask,        NULL /*"ENC"    */, STACK_SIZE_ENC,       (void *)&CLIStateSerialUsb->myStdInOut, 1, &xHandleEnc);
    14e4:	20 91 9e 0e 	lds	r18, 0x0E9E
    14e8:	30 91 9f 0e 	lds	r19, 0x0E9F
    14ec:	26 5e       	subi	r18, 0xE6	; 230
    14ee:	3f 4f       	sbci	r19, 0xFF	; 255
    14f0:	8e e3       	ldi	r24, 0x3E	; 62
    14f2:	9b e1       	ldi	r25, 0x1B	; 27
    14f4:	60 e0       	ldi	r22, 0x00	; 0
    14f6:	70 e0       	ldi	r23, 0x00	; 0
    14f8:	44 ef       	ldi	r20, 0xF4	; 244
    14fa:	51 e0       	ldi	r21, 0x01	; 1
    14fc:	01 e0       	ldi	r16, 0x01	; 1
    14fe:	1b e4       	ldi	r17, 0x4B	; 75
    1500:	e1 2e       	mov	r14, r17
    1502:	1f e0       	ldi	r17, 0x0F	; 15
    1504:	f1 2e       	mov	r15, r17
    1506:	cc 24       	eor	r12, r12
    1508:	dd 24       	eor	r13, r13
    150a:	aa 24       	eor	r10, r10
    150c:	bb 24       	eor	r11, r11
    150e:	0e 94 69 4e 	call	0x9cd2	; 0x9cd2 <xTaskGenericCreate>
  xTaskCreate(vTaskVTYusb,    NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUsb),            1, &xHandleVTY_USB);
    1512:	20 91 9e 0e 	lds	r18, 0x0E9E
    1516:	30 91 9f 0e 	lds	r19, 0x0E9F
    151a:	8f e9       	ldi	r24, 0x9F	; 159
    151c:	9b e1       	ldi	r25, 0x1B	; 27
    151e:	60 e0       	ldi	r22, 0x00	; 0
    1520:	70 e0       	ldi	r23, 0x00	; 0
    1522:	4c eb       	ldi	r20, 0xBC	; 188
    1524:	52 e0       	ldi	r21, 0x02	; 2
    1526:	ba eb       	ldi	r27, 0xBA	; 186
    1528:	eb 2e       	mov	r14, r27
    152a:	be e0       	ldi	r27, 0x0E	; 14
    152c:	fb 2e       	mov	r15, r27
    152e:	0e 94 69 4e 	call	0x9cd2	; 0x9cd2 <xTaskGenericCreate>
  xTaskCreate(vTaskVTYsocket, NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUdp),            1, &xHandleVTY_UDP);
    1532:	20 91 60 0f 	lds	r18, 0x0F60
    1536:	30 91 61 0f 	lds	r19, 0x0F61
    153a:	81 e9       	ldi	r24, 0x91	; 145
    153c:	9b e1       	ldi	r25, 0x1B	; 27
    153e:	60 e0       	ldi	r22, 0x00	; 0
    1540:	70 e0       	ldi	r23, 0x00	; 0
    1542:	4c eb       	ldi	r20, 0xBC	; 188
    1544:	52 e0       	ldi	r21, 0x02	; 2
    1546:	a1 eb       	ldi	r26, 0xB1	; 177
    1548:	ea 2e       	mov	r14, r26
    154a:	ae e0       	ldi	r26, 0x0E	; 14
    154c:	fa 2e       	mov	r15, r26
    154e:	0e 94 69 4e 	call	0x9cd2	; 0x9cd2 <xTaskGenericCreate>
  xTaskCreate(sensorsTask,    NULL /*"Sensors"*/, STACK_SIZE_SENSORS,   NULL,                                   1, &xHandleSensors);
    1552:	88 e3       	ldi	r24, 0x38	; 56
    1554:	9f e0       	ldi	r25, 0x0F	; 15
    1556:	60 e0       	ldi	r22, 0x00	; 0
    1558:	70 e0       	ldi	r23, 0x00	; 0
    155a:	44 ef       	ldi	r20, 0xF4	; 244
    155c:	51 e0       	ldi	r21, 0x01	; 1
    155e:	20 e0       	ldi	r18, 0x00	; 0
    1560:	30 e0       	ldi	r19, 0x00	; 0
    1562:	f6 ea       	ldi	r31, 0xA6	; 166
    1564:	ef 2e       	mov	r14, r31
    1566:	fe e0       	ldi	r31, 0x0E	; 14
    1568:	ff 2e       	mov	r15, r31
    156a:	0e 94 69 4e 	call	0x9cd2	; 0x9cd2 <xTaskGenericCreate>
  xTaskCreate(vBlinkLed,      NULL /*"ENC"*/,     100, 			NULL, 					0, &xHandleBlinkLed);
    156e:	8a e0       	ldi	r24, 0x0A	; 10
    1570:	9a e0       	ldi	r25, 0x0A	; 10
    1572:	60 e0       	ldi	r22, 0x00	; 0
    1574:	70 e0       	ldi	r23, 0x00	; 0
    1576:	44 e6       	ldi	r20, 0x64	; 100
    1578:	50 e0       	ldi	r21, 0x00	; 0
    157a:	20 e0       	ldi	r18, 0x00	; 0
    157c:	30 e0       	ldi	r19, 0x00	; 0
    157e:	00 e0       	ldi	r16, 0x00	; 0
    1580:	e9 ec       	ldi	r30, 0xC9	; 201
    1582:	ee 2e       	mov	r14, r30
    1584:	ee e0       	ldi	r30, 0x0E	; 14
    1586:	fe 2e       	mov	r15, r30
    1588:	0e 94 69 4e 	call	0x9cd2	; 0x9cd2 <xTaskGenericCreate>
  
  vTaskStartScheduler();
    158c:	0e 94 86 4f 	call	0x9f0c	; 0x9f0c <vTaskStartScheduler>
  return 0;
}
    1590:	80 e0       	ldi	r24, 0x00	; 0
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	1f 91       	pop	r17
    1596:	0f 91       	pop	r16
    1598:	ff 90       	pop	r15
    159a:	ef 90       	pop	r14
    159c:	df 90       	pop	r13
    159e:	cf 90       	pop	r12
    15a0:	bf 90       	pop	r11
    15a2:	af 90       	pop	r10
    15a4:	08 95       	ret

000015a6 <saveConfiguration>:
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
}

void saveConfiguration(void)
{
  saveNic();
    15a6:	0e 94 d0 2d 	call	0x5ba0	; 0x5ba0 <saveNic>
  ipSaveConfig();
    15aa:	0e 94 42 34 	call	0x6884	; 0x6884 <ipSaveConfig>
  udpSaveConfig();
    15ae:	0e 94 ce 3d 	call	0x7b9c	; 0x7b9c <udpSaveConfig>
}
    15b2:	08 95       	ret

000015b4 <loadConfiguration>:
                                                                                       {LOCK_SENS_3_ENA, LOCK_SENS_3_THR, 0, 0},
                                                                                       {LOCK_SENS_4_ENA, LOCK_SENS_4_THR, 0, 0}};

void loadConfiguration(void)
{
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
    15b4:	80 91 a0 0e 	lds	r24, 0x0EA0
    15b8:	90 91 a1 0e 	lds	r25, 0x0EA1
    15bc:	60 e0       	ldi	r22, 0x00	; 0
    15be:	70 e0       	ldi	r23, 0x00	; 0
    15c0:	48 e1       	ldi	r20, 0x18	; 24
    15c2:	50 e0       	ldi	r21, 0x00	; 0
    15c4:	0e 94 ae 5c 	call	0xb95c	; 0xb95c <__eerd_block_m128>
}
    15c8:	08 95       	ret

000015ca <initQueueStreamUSB>:
#define debug 1

/*-----------------------------------------------------------*/

void initQueueStreamUSB(FILE *stream)
{
    15ca:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
    15cc:	8f ea       	ldi	r24, 0xAF	; 175
    15ce:	9b e0       	ldi	r25, 0x0B	; 11
    15d0:	91 87       	std	Z+9, r25	; 0x09
    15d2:	80 87       	std	Z+8, r24	; 0x08
    15d4:	8b e9       	ldi	r24, 0x9B	; 155
    15d6:	9c e0       	ldi	r25, 0x0C	; 12
    15d8:	93 87       	std	Z+11, r25	; 0x0b
    15da:	82 87       	std	Z+10, r24	; 0x0a
    15dc:	83 e0       	ldi	r24, 0x03	; 3
    15de:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, NULL);
    15e0:	15 86       	std	Z+13, r1	; 0x0d
    15e2:	14 86       	std	Z+12, r1	; 0x0c
  return;
}
    15e4:	08 95       	ret

000015e6 <__vector_20>:
    taskYIELD();
  }
}

ISR(USART0_TX_vect)
{
    15e6:	1f 92       	push	r1
    15e8:	0f 92       	push	r0
    15ea:	0f b6       	in	r0, 0x3f	; 63
    15ec:	0f 92       	push	r0
    15ee:	11 24       	eor	r1, r1
    15f0:	8f 93       	push	r24
  if (!vIsInterruptRs485On())
    15f2:	55 99       	sbic	0x0a, 5	; 10
    15f4:	05 c0       	rjmp	.+10     	; 0x1600 <__vector_20+0x1a>
    Rs485TxStop();
    15f6:	80 91 65 00 	lds	r24, 0x0065
    15fa:	8f 7e       	andi	r24, 0xEF	; 239
    15fc:	80 93 65 00 	sts	0x0065, r24
}
    1600:	8f 91       	pop	r24
    1602:	0f 90       	pop	r0
    1604:	0f be       	out	0x3f, r0	; 63
    1606:	0f 90       	pop	r0
    1608:	1f 90       	pop	r1
    160a:	18 95       	reti

0000160c <InterruptVtyOn>:
}

void InterruptVtyOn(void)
{                                  
  unsigned portCHAR ucByte;                                       
  ucByte = UCSR1B;                 
    160c:	ea e9       	ldi	r30, 0x9A	; 154
    160e:	f0 e0       	ldi	r31, 0x00	; 0
    1610:	80 81       	ld	r24, Z
  ucByte |= serDATA_INT_ENABLE;    
    1612:	80 62       	ori	r24, 0x20	; 32
  UCSR1B = ucByte;                 
    1614:	80 83       	st	Z, r24
}
    1616:	08 95       	ret

00001618 <__vector_31>:
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
  vInterruptVtyOn();
}

ISR(USART1_UDRE_vect)
{
    1618:	1f 92       	push	r1
    161a:	0f 92       	push	r0
    161c:	0f b6       	in	r0, 0x3f	; 63
    161e:	0f 92       	push	r0
    1620:	0b b6       	in	r0, 0x3b	; 59
    1622:	0f 92       	push	r0
    1624:	11 24       	eor	r1, r1
    1626:	2f 93       	push	r18
    1628:	3f 93       	push	r19
    162a:	4f 93       	push	r20
    162c:	5f 93       	push	r21
    162e:	6f 93       	push	r22
    1630:	7f 93       	push	r23
    1632:	8f 93       	push	r24
    1634:	9f 93       	push	r25
    1636:	af 93       	push	r26
    1638:	bf 93       	push	r27
    163a:	ef 93       	push	r30
    163c:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
    163e:	80 91 7b 0e 	lds	r24, 0x0E7B
    1642:	90 91 7c 0e 	lds	r25, 0x0E7C
    1646:	69 e8       	ldi	r22, 0x89	; 137
    1648:	71 e0       	ldi	r23, 0x01	; 1
    164a:	4a e8       	ldi	r20, 0x8A	; 138
    164c:	51 e0       	ldi	r21, 0x01	; 1
    164e:	0e 94 db 4f 	call	0x9fb6	; 0x9fb6 <xQueueReceiveFromISR>
    1652:	81 30       	cpi	r24, 0x01	; 1
    1654:	29 f4       	brne	.+10     	; 0x1660 <__vector_31+0x48>
  {
    UDR1 = data; 
    1656:	80 91 89 01 	lds	r24, 0x0189
    165a:	80 93 9c 00 	sts	0x009C, r24
    165e:	07 c0       	rjmp	.+14     	; 0x166e <__vector_31+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    1660:	10 92 8a 01 	sts	0x018A, r1
    vInterruptVtyOff();
    1664:	80 91 9a 00 	lds	r24, 0x009A
    1668:	8f 7d       	andi	r24, 0xDF	; 223
    166a:	80 93 9a 00 	sts	0x009A, r24
  }
  if( xHigherPriorityTaskWoken )
    166e:	80 91 8a 01 	lds	r24, 0x018A
    1672:	88 23       	and	r24, r24
    1674:	11 f0       	breq	.+4      	; 0x167a <__vector_31+0x62>
  {
    taskYIELD();
    1676:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
  }
}
    167a:	ff 91       	pop	r31
    167c:	ef 91       	pop	r30
    167e:	bf 91       	pop	r27
    1680:	af 91       	pop	r26
    1682:	9f 91       	pop	r25
    1684:	8f 91       	pop	r24
    1686:	7f 91       	pop	r23
    1688:	6f 91       	pop	r22
    168a:	5f 91       	pop	r21
    168c:	4f 91       	pop	r20
    168e:	3f 91       	pop	r19
    1690:	2f 91       	pop	r18
    1692:	0f 90       	pop	r0
    1694:	0b be       	out	0x3b, r0	; 59
    1696:	0f 90       	pop	r0
    1698:	0f be       	out	0x3f, r0	; 63
    169a:	0f 90       	pop	r0
    169c:	1f 90       	pop	r1
    169e:	18 95       	reti

000016a0 <__vector_19>:
{
  return xQueueReceive(xRs485Rec, c, timeout);
}

ISR(USART0_UDRE_vect)
{
    16a0:	1f 92       	push	r1
    16a2:	0f 92       	push	r0
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	0f 92       	push	r0
    16a8:	0b b6       	in	r0, 0x3b	; 59
    16aa:	0f 92       	push	r0
    16ac:	11 24       	eor	r1, r1
    16ae:	2f 93       	push	r18
    16b0:	3f 93       	push	r19
    16b2:	4f 93       	push	r20
    16b4:	5f 93       	push	r21
    16b6:	6f 93       	push	r22
    16b8:	7f 93       	push	r23
    16ba:	8f 93       	push	r24
    16bc:	9f 93       	push	r25
    16be:	af 93       	push	r26
    16c0:	bf 93       	push	r27
    16c2:	ef 93       	push	r30
    16c4:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
    16c6:	80 91 c3 0e 	lds	r24, 0x0EC3
    16ca:	90 91 c4 0e 	lds	r25, 0x0EC4
    16ce:	6c e8       	ldi	r22, 0x8C	; 140
    16d0:	71 e0       	ldi	r23, 0x01	; 1
    16d2:	4d e8       	ldi	r20, 0x8D	; 141
    16d4:	51 e0       	ldi	r21, 0x01	; 1
    16d6:	0e 94 db 4f 	call	0x9fb6	; 0x9fb6 <xQueueReceiveFromISR>
    16da:	81 30       	cpi	r24, 0x01	; 1
    16dc:	49 f4       	brne	.+18     	; 0x16f0 <__vector_19+0x50>
  {
    Rs485TxStart();
    16de:	80 91 65 00 	lds	r24, 0x0065
    16e2:	80 61       	ori	r24, 0x10	; 16
    16e4:	80 93 65 00 	sts	0x0065, r24
    UDR0 = data; 
    16e8:	80 91 8c 01 	lds	r24, 0x018C
    16ec:	8c b9       	out	0x0c, r24	; 12
    16ee:	03 c0       	rjmp	.+6      	; 0x16f6 <__vector_19+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    16f0:	10 92 8d 01 	sts	0x018D, r1
    vInterruptRs485Off();
    16f4:	55 98       	cbi	0x0a, 5	; 10
  }
  if( xHigherPriorityTaskWoken )
    16f6:	80 91 8d 01 	lds	r24, 0x018D
    16fa:	88 23       	and	r24, r24
    16fc:	11 f0       	breq	.+4      	; 0x1702 <__vector_19+0x62>
  {
    taskYIELD();
    16fe:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
  }
}
    1702:	ff 91       	pop	r31
    1704:	ef 91       	pop	r30
    1706:	bf 91       	pop	r27
    1708:	af 91       	pop	r26
    170a:	9f 91       	pop	r25
    170c:	8f 91       	pop	r24
    170e:	7f 91       	pop	r23
    1710:	6f 91       	pop	r22
    1712:	5f 91       	pop	r21
    1714:	4f 91       	pop	r20
    1716:	3f 91       	pop	r19
    1718:	2f 91       	pop	r18
    171a:	0f 90       	pop	r0
    171c:	0b be       	out	0x3b, r0	; 59
    171e:	0f 90       	pop	r0
    1720:	0f be       	out	0x3f, r0	; 63
    1722:	0f 90       	pop	r0
    1724:	1f 90       	pop	r1
    1726:	18 95       	reti

00001728 <uartVtySendByte>:
    taskYIELD();
  }
}

void uartVtySendByte(uint8_t data)
{
    1728:	df 93       	push	r29
    172a:	cf 93       	push	r28
    172c:	0f 92       	push	r0
    172e:	cd b7       	in	r28, 0x3d	; 61
    1730:	de b7       	in	r29, 0x3e	; 62
    1732:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
    1734:	80 91 7b 0e 	lds	r24, 0x0E7B
    1738:	90 91 7c 0e 	lds	r25, 0x0E7C
    173c:	be 01       	movw	r22, r28
    173e:	6f 5f       	subi	r22, 0xFF	; 255
    1740:	7f 4f       	sbci	r23, 0xFF	; 255
    1742:	4f ef       	ldi	r20, 0xFF	; 255
    1744:	5f ef       	ldi	r21, 0xFF	; 255
    1746:	20 e0       	ldi	r18, 0x00	; 0
    1748:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>
  vInterruptVtyOn();
    174c:	ea e9       	ldi	r30, 0x9A	; 154
    174e:	f0 e0       	ldi	r31, 0x00	; 0
    1750:	80 81       	ld	r24, Z
    1752:	80 62       	ori	r24, 0x20	; 32
    1754:	80 83       	st	Z, r24
}
    1756:	0f 90       	pop	r0
    1758:	cf 91       	pop	r28
    175a:	df 91       	pop	r29
    175c:	08 95       	ret

0000175e <VtyPutChar>:
}

int VtyPutChar(char c, FILE *stream)
{
  stream = NULL;
  uartVtySendByte(c);
    175e:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
  return 0;
}
    1762:	80 e0       	ldi	r24, 0x00	; 0
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	08 95       	ret

00001768 <releaseRs485>:
    1768:	80 91 af 0e 	lds	r24, 0x0EAF
    176c:	90 91 b0 0e 	lds	r25, 0x0EB0
    1770:	60 e0       	ldi	r22, 0x00	; 0
    1772:	70 e0       	ldi	r23, 0x00	; 0
    1774:	40 e0       	ldi	r20, 0x00	; 0
    1776:	50 e0       	ldi	r21, 0x00	; 0
    1778:	20 e0       	ldi	r18, 0x00	; 0
    177a:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>
    177e:	08 95       	ret

00001780 <uartRs485SendByte>:
    1780:	df 93       	push	r29
    1782:	cf 93       	push	r28
    1784:	0f 92       	push	r0
    1786:	cd b7       	in	r28, 0x3d	; 61
    1788:	de b7       	in	r29, 0x3e	; 62
    178a:	89 83       	std	Y+1, r24	; 0x01
    178c:	80 91 c3 0e 	lds	r24, 0x0EC3
    1790:	90 91 c4 0e 	lds	r25, 0x0EC4
    1794:	be 01       	movw	r22, r28
    1796:	6f 5f       	subi	r22, 0xFF	; 255
    1798:	7f 4f       	sbci	r23, 0xFF	; 255
    179a:	4f ef       	ldi	r20, 0xFF	; 255
    179c:	5f ef       	ldi	r21, 0xFF	; 255
    179e:	20 e0       	ldi	r18, 0x00	; 0
    17a0:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>
    17a4:	55 9a       	sbi	0x0a, 5	; 10
    17a6:	0f 90       	pop	r0
    17a8:	cf 91       	pop	r28
    17aa:	df 91       	pop	r29
    17ac:	08 95       	ret

000017ae <__vector_30>:
  UCSR1B = ucByte;                 
}

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    17ae:	1f 92       	push	r1
    17b0:	0f 92       	push	r0
    17b2:	0f b6       	in	r0, 0x3f	; 63
    17b4:	0f 92       	push	r0
    17b6:	0b b6       	in	r0, 0x3b	; 59
    17b8:	0f 92       	push	r0
    17ba:	11 24       	eor	r1, r1
    17bc:	2f 93       	push	r18
    17be:	3f 93       	push	r19
    17c0:	4f 93       	push	r20
    17c2:	5f 93       	push	r21
    17c4:	6f 93       	push	r22
    17c6:	7f 93       	push	r23
    17c8:	8f 93       	push	r24
    17ca:	9f 93       	push	r25
    17cc:	af 93       	push	r26
    17ce:	bf 93       	push	r27
    17d0:	ef 93       	push	r30
    17d2:	ff 93       	push	r31
    17d4:	df 93       	push	r29
    17d6:	cf 93       	push	r28
    17d8:	0f 92       	push	r0
    17da:	cd b7       	in	r28, 0x3d	; 61
    17dc:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  signed portCHAR cChar;

  cChar = UDR1;
    17de:	80 91 9c 00 	lds	r24, 0x009C
    17e2:	89 83       	std	Y+1, r24	; 0x01
//  xQueueSendFromISR(xVtyRec, &cChar, NULL);

  xHigherPriorityTaskWoken = pdFALSE;
    17e4:	10 92 8b 01 	sts	0x018B, r1
  xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
    17e8:	80 91 ad 0e 	lds	r24, 0x0EAD
    17ec:	90 91 ae 0e 	lds	r25, 0x0EAE
    17f0:	be 01       	movw	r22, r28
    17f2:	6f 5f       	subi	r22, 0xFF	; 255
    17f4:	7f 4f       	sbci	r23, 0xFF	; 255
    17f6:	4b e8       	ldi	r20, 0x8B	; 139
    17f8:	51 e0       	ldi	r21, 0x01	; 1
    17fa:	20 e0       	ldi	r18, 0x00	; 0
    17fc:	0e 94 5b 50 	call	0xa0b6	; 0xa0b6 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    1800:	80 91 8b 01 	lds	r24, 0x018B
    1804:	88 23       	and	r24, r24
    1806:	11 f0       	breq	.+4      	; 0x180c <__vector_30+0x5e>
  {
    taskYIELD();
    1808:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
  }
}
    180c:	0f 90       	pop	r0
    180e:	cf 91       	pop	r28
    1810:	df 91       	pop	r29
    1812:	ff 91       	pop	r31
    1814:	ef 91       	pop	r30
    1816:	bf 91       	pop	r27
    1818:	af 91       	pop	r26
    181a:	9f 91       	pop	r25
    181c:	8f 91       	pop	r24
    181e:	7f 91       	pop	r23
    1820:	6f 91       	pop	r22
    1822:	5f 91       	pop	r21
    1824:	4f 91       	pop	r20
    1826:	3f 91       	pop	r19
    1828:	2f 91       	pop	r18
    182a:	0f 90       	pop	r0
    182c:	0b be       	out	0x3b, r0	; 59
    182e:	0f 90       	pop	r0
    1830:	0f be       	out	0x3f, r0	; 63
    1832:	0f 90       	pop	r0
    1834:	1f 90       	pop	r1
    1836:	18 95       	reti

00001838 <__vector_18>:
  return;
}

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    1838:	1f 92       	push	r1
    183a:	0f 92       	push	r0
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	0f 92       	push	r0
    1840:	0b b6       	in	r0, 0x3b	; 59
    1842:	0f 92       	push	r0
    1844:	11 24       	eor	r1, r1
    1846:	2f 93       	push	r18
    1848:	3f 93       	push	r19
    184a:	4f 93       	push	r20
    184c:	5f 93       	push	r21
    184e:	6f 93       	push	r22
    1850:	7f 93       	push	r23
    1852:	8f 93       	push	r24
    1854:	9f 93       	push	r25
    1856:	af 93       	push	r26
    1858:	bf 93       	push	r27
    185a:	ef 93       	push	r30
    185c:	ff 93       	push	r31
    185e:	df 93       	push	r29
    1860:	cf 93       	push	r28
    1862:	0f 92       	push	r0
    1864:	cd b7       	in	r28, 0x3d	; 61
    1866:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  signed portCHAR cChar;

  cChar = UDR0;
    1868:	8c b1       	in	r24, 0x0c	; 12
    186a:	89 83       	std	Y+1, r24	; 0x01

  xHigherPriorityTaskWoken = pdFALSE;
    186c:	10 92 01 01 	sts	0x0101, r1

//  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
    1870:	80 91 9c 0e 	lds	r24, 0x0E9C
    1874:	90 91 9d 0e 	lds	r25, 0x0E9D
    1878:	be 01       	movw	r22, r28
    187a:	6f 5f       	subi	r22, 0xFF	; 255
    187c:	7f 4f       	sbci	r23, 0xFF	; 255
    187e:	41 e0       	ldi	r20, 0x01	; 1
    1880:	51 e0       	ldi	r21, 0x01	; 1
    1882:	20 e0       	ldi	r18, 0x00	; 0
    1884:	0e 94 5b 50 	call	0xa0b6	; 0xa0b6 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    1888:	80 91 01 01 	lds	r24, 0x0101
    188c:	88 23       	and	r24, r24
    188e:	11 f0       	breq	.+4      	; 0x1894 <__vector_18+0x5c>
  {
    taskYIELD();
    1890:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
  }
}
    1894:	0f 90       	pop	r0
    1896:	cf 91       	pop	r28
    1898:	df 91       	pop	r29
    189a:	ff 91       	pop	r31
    189c:	ef 91       	pop	r30
    189e:	bf 91       	pop	r27
    18a0:	af 91       	pop	r26
    18a2:	9f 91       	pop	r25
    18a4:	8f 91       	pop	r24
    18a6:	7f 91       	pop	r23
    18a8:	6f 91       	pop	r22
    18aa:	5f 91       	pop	r21
    18ac:	4f 91       	pop	r20
    18ae:	3f 91       	pop	r19
    18b0:	2f 91       	pop	r18
    18b2:	0f 90       	pop	r0
    18b4:	0b be       	out	0x3b, r0	; 59
    18b6:	0f 90       	pop	r0
    18b8:	0f be       	out	0x3f, r0	; 63
    18ba:	0f 90       	pop	r0
    18bc:	1f 90       	pop	r1
    18be:	18 95       	reti

000018c0 <takeRs485>:
    18c0:	80 91 af 0e 	lds	r24, 0x0EAF
    18c4:	90 91 b0 0e 	lds	r25, 0x0EB0
    18c8:	60 e0       	ldi	r22, 0x00	; 0
    18ca:	70 e0       	ldi	r23, 0x00	; 0
    18cc:	4f ef       	ldi	r20, 0xFF	; 255
    18ce:	5f ef       	ldi	r21, 0xFF	; 255
    18d0:	20 e0       	ldi	r18, 0x00	; 0
    18d2:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    18d6:	08 95       	ret

000018d8 <flushRs485RecBuffer>:
    18d8:	ef 92       	push	r14
    18da:	ff 92       	push	r15
    18dc:	1f 93       	push	r17
    18de:	df 93       	push	r29
    18e0:	cf 93       	push	r28
    18e2:	0f 92       	push	r0
    18e4:	cd b7       	in	r28, 0x3d	; 61
    18e6:	de b7       	in	r29, 0x3e	; 62
    18e8:	10 e0       	ldi	r17, 0x00	; 0
    18ea:	7e 01       	movw	r14, r28
    18ec:	08 94       	sec
    18ee:	e1 1c       	adc	r14, r1
    18f0:	f1 1c       	adc	r15, r1
    18f2:	01 c0       	rjmp	.+2      	; 0x18f6 <flushRs485RecBuffer+0x1e>
    18f4:	1f 5f       	subi	r17, 0xFF	; 255
    18f6:	80 91 9c 0e 	lds	r24, 0x0E9C
    18fa:	90 91 9d 0e 	lds	r25, 0x0E9D
    18fe:	b7 01       	movw	r22, r14
    1900:	4a e0       	ldi	r20, 0x0A	; 10
    1902:	50 e0       	ldi	r21, 0x00	; 0
    1904:	20 e0       	ldi	r18, 0x00	; 0
    1906:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    190a:	81 30       	cpi	r24, 0x01	; 1
    190c:	99 f3       	breq	.-26     	; 0x18f4 <flushRs485RecBuffer+0x1c>
    190e:	81 2f       	mov	r24, r17
    1910:	0f 90       	pop	r0
    1912:	cf 91       	pop	r28
    1914:	df 91       	pop	r29
    1916:	1f 91       	pop	r17
    1918:	ff 90       	pop	r15
    191a:	ef 90       	pop	r14
    191c:	08 95       	ret

0000191e <rs485Receive>:
    191e:	9c 01       	movw	r18, r24
    1920:	46 2f       	mov	r20, r22
    1922:	80 91 9c 0e 	lds	r24, 0x0E9C
    1926:	90 91 9d 0e 	lds	r25, 0x0E9D
    192a:	b9 01       	movw	r22, r18
    192c:	50 e0       	ldi	r21, 0x00	; 0
    192e:	20 e0       	ldi	r18, 0x00	; 0
    1930:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    1934:	08 95       	ret

00001936 <VtyGetChar>:
  fdev_set_udata(stream, NULL);
  return;
}

int VtyGetChar(FILE *stream)
{
    1936:	df 93       	push	r29
    1938:	cf 93       	push	r28
    193a:	0f 92       	push	r0
    193c:	cd b7       	in	r28, 0x3d	; 61
    193e:	de b7       	in	r29, 0x3e	; 62
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    1940:	80 91 ad 0e 	lds	r24, 0x0EAD
    1944:	90 91 ae 0e 	lds	r25, 0x0EAE
    1948:	be 01       	movw	r22, r28
    194a:	6f 5f       	subi	r22, 0xFF	; 255
    194c:	7f 4f       	sbci	r23, 0xFF	; 255
    194e:	4f ef       	ldi	r20, 0xFF	; 255
    1950:	5f ef       	ldi	r21, 0xFF	; 255
    1952:	20 e0       	ldi	r18, 0x00	; 0
    1954:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    1958:	88 23       	and	r24, r24
    195a:	19 f4       	brne	.+6      	; 0x1962 <VtyGetChar+0x2c>
    195c:	2f ef       	ldi	r18, 0xFF	; 255
    195e:	3f ef       	ldi	r19, 0xFF	; 255
    1960:	03 c0       	rjmp	.+6      	; 0x1968 <VtyGetChar+0x32>
    return EOF;
  return c;
    1962:	89 81       	ldd	r24, Y+1	; 0x01
    1964:	28 2f       	mov	r18, r24
    1966:	30 e0       	ldi	r19, 0x00	; 0
}
    1968:	c9 01       	movw	r24, r18
    196a:	0f 90       	pop	r0
    196c:	cf 91       	pop	r28
    196e:	df 91       	pop	r29
    1970:	08 95       	ret

00001972 <xSerialPortInitMinimal>:
  return 0;
}

void xSerialPortInitMinimal(void)
{
  portENTER_CRITICAL();
    1972:	0f b6       	in	r0, 0x3f	; 63
    1974:	f8 94       	cli
    1976:	0f 92       	push	r0
  {
    xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1978:	80 e4       	ldi	r24, 0x40	; 64
    197a:	61 e0       	ldi	r22, 0x01	; 1
    197c:	0e 94 87 52 	call	0xa50e	; 0xa50e <xQueueCreate>
    1980:	90 93 ae 0e 	sts	0x0EAE, r25
    1984:	80 93 ad 0e 	sts	0x0EAD, r24
    xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1988:	80 e2       	ldi	r24, 0x20	; 32
    198a:	61 e0       	ldi	r22, 0x01	; 1
    198c:	0e 94 87 52 	call	0xa50e	; 0xa50e <xQueueCreate>
    1990:	90 93 7c 0e 	sts	0x0E7C, r25
    1994:	80 93 7b 0e 	sts	0x0E7B, r24
    xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1998:	80 e1       	ldi	r24, 0x10	; 16
    199a:	61 e0       	ldi	r22, 0x01	; 1
    199c:	0e 94 87 52 	call	0xa50e	; 0xa50e <xQueueCreate>
    19a0:	90 93 9d 0e 	sts	0x0E9D, r25
    19a4:	80 93 9c 0e 	sts	0x0E9C, r24
    xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    19a8:	84 e0       	ldi	r24, 0x04	; 4
    19aa:	61 e0       	ldi	r22, 0x01	; 1
    19ac:	0e 94 87 52 	call	0xa50e	; 0xa50e <xQueueCreate>
    19b0:	90 93 c4 0e 	sts	0x0EC4, r25
    19b4:	80 93 c3 0e 	sts	0x0EC3, r24
    
    vSemaphoreCreateBinary(xSemaphoreRs485); 
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	60 e0       	ldi	r22, 0x00	; 0
    19bc:	0e 94 87 52 	call	0xa50e	; 0xa50e <xQueueCreate>
    19c0:	90 93 b0 0e 	sts	0x0EB0, r25
    19c4:	80 93 af 0e 	sts	0x0EAF, r24
    19c8:	00 97       	sbiw	r24, 0x00	; 0
    19ca:	39 f0       	breq	.+14     	; 0x19da <xSerialPortInitMinimal+0x68>
    19cc:	60 e0       	ldi	r22, 0x00	; 0
    19ce:	70 e0       	ldi	r23, 0x00	; 0
    19d0:	40 e0       	ldi	r20, 0x00	; 0
    19d2:	50 e0       	ldi	r21, 0x00	; 0
    19d4:	20 e0       	ldi	r18, 0x00	; 0
    19d6:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
    19da:	0f 90       	pop	r0
    19dc:	0f be       	out	0x3f, r0	; 63
  
  UBRR0L = 7;
    19de:	87 e0       	ldi	r24, 0x07	; 7
    19e0:	89 b9       	out	0x09, r24	; 9
  UBRR0H = 0;
    19e2:	10 92 90 00 	sts	0x0090, r1

  UBRR1L = 7;
    19e6:	80 93 99 00 	sts	0x0099, r24
  UBRR1H = 0;
    19ea:	10 92 98 00 	sts	0x0098, r1

  UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
    19ee:	88 ed       	ldi	r24, 0xD8	; 216
    19f0:	8a b9       	out	0x0a, r24	; 10
  UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    19f2:	96 e8       	ldi	r25, 0x86	; 134
    19f4:	90 93 95 00 	sts	0x0095, r25
  UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
    19f8:	88 e9       	ldi	r24, 0x98	; 152
    19fa:	80 93 9a 00 	sts	0x009A, r24
  UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    19fe:	90 93 9d 00 	sts	0x009D, r25
  return;
}
    1a02:	08 95       	ret

00001a04 <spiSendSpinBlock>:
    1a04:	8f b9       	out	0x0f, r24	; 15
    1a06:	6f 98       	cbi	0x0d, 7	; 13
    1a08:	77 9b       	sbis	0x0e, 7	; 14
    1a0a:	fe cf       	rjmp	.-4      	; 0x1a08 <spiSendSpinBlock+0x4>
    1a0c:	8e b1       	in	r24, 0x0e	; 14
    1a0e:	8f b1       	in	r24, 0x0f	; 15
    1a10:	6f 9a       	sbi	0x0d, 7	; 13
    1a12:	08 95       	ret

00001a14 <disableAllSpiDevices>:
#error Port A is memory bus
  PORTA &= disableSpiPORTA_AND;
#endif

#if disableSpiPORTB_OR != 0
  PORTB |= disableSpiPORTB_OR;
    1a14:	88 b3       	in	r24, 0x18	; 24
    1a16:	80 6c       	ori	r24, 0xC0	; 192
    1a18:	88 bb       	out	0x18, r24	; 24
#endif
#if disableSpiPORTB_AND != 0xFF
  PORTB &= disableSpiPORTB_AND;
    1a1a:	c5 98       	cbi	0x18, 5	; 24
#endif
#if disableSpiPORTD_AND != 0xFF
  PORTD &= disableSpiPORTD_AND;
#endif
#if disableSpiPORTE_OR != 0
  PORTE |= disableSpiPORTE_OR;
    1a1c:	1b 9a       	sbi	0x03, 3	; 3
#if disableSpiPORTF_AND != 0xFF
  PORTF &= disableSpiPORTF_AND;
#endif

#if disableSpiPORTG_OR != 0
  PORTG |= disableSpiPORTG_OR;
    1a1e:	e5 e6       	ldi	r30, 0x65	; 101
    1a20:	f0 e0       	ldi	r31, 0x00	; 0
    1a22:	80 81       	ld	r24, Z
    1a24:	88 60       	ori	r24, 0x08	; 8
    1a26:	80 83       	st	Z, r24
#endif
#if disableSpiPORTG_AND != 0xFF
  PORTG &= disableSpiPORTG_AND;
#endif
}
    1a28:	08 95       	ret

00001a2a <spiEnableEnc28j60>:
    1a2a:	1b 98       	cbi	0x03, 3	; 3
    1a2c:	08 95       	ret

00001a2e <spiDisableEnc28j60>:
    1a2e:	1b 9a       	sbi	0x03, 3	; 3
    1a30:	08 95       	ret

00001a32 <enableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
    1a32:	e5 e6       	ldi	r30, 0x65	; 101
    1a34:	f0 e0       	ldi	r31, 0x00	; 0
    1a36:	80 81       	ld	r24, Z
    1a38:	87 7f       	andi	r24, 0xF7	; 247
    1a3a:	80 83       	st	Z, r24
#endif   
}
    1a3c:	08 95       	ret

00001a3e <disableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
    1a3e:	e5 e6       	ldi	r30, 0x65	; 101
    1a40:	f0 e0       	ldi	r31, 0x00	; 0
    1a42:	80 81       	ld	r24, Z
    1a44:	88 60       	ori	r24, 0x08	; 8
    1a46:	80 83       	st	Z, r24
#endif  
}
    1a48:	08 95       	ret

00001a4a <enableSpiMPC23S17>:
    1a4a:	c7 98       	cbi	0x18, 7	; 24
    1a4c:	08 95       	ret

00001a4e <disableSpiMPC23S17>:
    1a4e:	c7 9a       	sbi	0x18, 7	; 24
    1a50:	08 95       	ret

00001a52 <enableSpiMCP3008>:
    1a52:	8d b1       	in	r24, 0x0d	; 13
    1a54:	83 60       	ori	r24, 0x03	; 3
    1a56:	8d b9       	out	0x0d, r24	; 13
    1a58:	c6 98       	cbi	0x18, 6	; 24
    1a5a:	08 95       	ret

00001a5c <disableSpiMCP3008>:
    1a5c:	8d b1       	in	r24, 0x0d	; 13
    1a5e:	8c 7f       	andi	r24, 0xFC	; 252
    1a60:	8d b9       	out	0x0d, r24	; 13
    1a62:	c6 9a       	sbi	0x18, 6	; 24
    1a64:	08 95       	ret

00001a66 <enableSpiMCP4150>:
    1a66:	8d b1       	in	r24, 0x0d	; 13
    1a68:	83 60       	ori	r24, 0x03	; 3
    1a6a:	8d b9       	out	0x0d, r24	; 13
    1a6c:	c6 98       	cbi	0x18, 6	; 24
    1a6e:	08 95       	ret

00001a70 <disableSpiMCP4150>:
    1a70:	8d b1       	in	r24, 0x0d	; 13
    1a72:	8c 7f       	andi	r24, 0xFC	; 252
    1a74:	8d b9       	out	0x0d, r24	; 13
    1a76:	c6 9a       	sbi	0x18, 6	; 24
    1a78:	08 95       	ret

00001a7a <spiEnableDS1305>:
    1a7a:	8d b1       	in	r24, 0x0d	; 13
    1a7c:	85 60       	ori	r24, 0x05	; 5
    1a7e:	8d b9       	out	0x0d, r24	; 13
    1a80:	c5 9a       	sbi	0x18, 5	; 24
    1a82:	08 95       	ret

00001a84 <spiDisableDS1305>:
    1a84:	8d b1       	in	r24, 0x0d	; 13
    1a86:	8a 7f       	andi	r24, 0xFA	; 250
    1a88:	8d b9       	out	0x0d, r24	; 13
    1a8a:	c5 98       	cbi	0x18, 5	; 24
    1a8c:	08 95       	ret

00001a8e <__vector_17>:
  DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
#endif  
}

ISR(SPI_STC_vect)
{
    1a8e:	1f 92       	push	r1
    1a90:	0f 92       	push	r0
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	0f 92       	push	r0
    1a96:	0b b6       	in	r0, 0x3b	; 59
    1a98:	0f 92       	push	r0
    1a9a:	11 24       	eor	r1, r1
    1a9c:	2f 93       	push	r18
    1a9e:	3f 93       	push	r19
    1aa0:	4f 93       	push	r20
    1aa2:	5f 93       	push	r21
    1aa4:	6f 93       	push	r22
    1aa6:	7f 93       	push	r23
    1aa8:	8f 93       	push	r24
    1aaa:	9f 93       	push	r25
    1aac:	af 93       	push	r26
    1aae:	bf 93       	push	r27
    1ab0:	ef 93       	push	r30
    1ab2:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 

  static uint8_t data;
  data = SPDR;
    1ab4:	8f b1       	in	r24, 0x0f	; 15
    1ab6:	80 93 8e 01 	sts	0x018E, r24
  
  xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
    1aba:	80 91 62 0f 	lds	r24, 0x0F62
    1abe:	90 91 63 0f 	lds	r25, 0x0F63
    1ac2:	6e e8       	ldi	r22, 0x8E	; 142
    1ac4:	71 e0       	ldi	r23, 0x01	; 1
    1ac6:	4f e8       	ldi	r20, 0x8F	; 143
    1ac8:	51 e0       	ldi	r21, 0x01	; 1
    1aca:	20 e0       	ldi	r18, 0x00	; 0
    1acc:	0e 94 5b 50 	call	0xa0b6	; 0xa0b6 <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    1ad0:	80 91 8f 01 	lds	r24, 0x018F
    1ad4:	88 23       	and	r24, r24
    1ad6:	11 f0       	breq	.+4      	; 0x1adc <__vector_17+0x4e>
  {
    taskYIELD();
    1ad8:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
  }
  
  //clear SPI interrupt SPI |= 1;
}
    1adc:	ff 91       	pop	r31
    1ade:	ef 91       	pop	r30
    1ae0:	bf 91       	pop	r27
    1ae2:	af 91       	pop	r26
    1ae4:	9f 91       	pop	r25
    1ae6:	8f 91       	pop	r24
    1ae8:	7f 91       	pop	r23
    1aea:	6f 91       	pop	r22
    1aec:	5f 91       	pop	r21
    1aee:	4f 91       	pop	r20
    1af0:	3f 91       	pop	r19
    1af2:	2f 91       	pop	r18
    1af4:	0f 90       	pop	r0
    1af6:	0b be       	out	0x3b, r0	; 59
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63
    1afc:	0f 90       	pop	r0
    1afe:	1f 90       	pop	r1
    1b00:	18 95       	reti

00001b02 <spiSend>:
    1b02:	df 93       	push	r29
    1b04:	cf 93       	push	r28
    1b06:	0f 92       	push	r0
    1b08:	cd b7       	in	r28, 0x3d	; 61
    1b0a:	de b7       	in	r29, 0x3e	; 62
    1b0c:	8f b9       	out	0x0f, r24	; 15
    1b0e:	80 91 62 0f 	lds	r24, 0x0F62
    1b12:	90 91 63 0f 	lds	r25, 0x0F63
    1b16:	be 01       	movw	r22, r28
    1b18:	6f 5f       	subi	r22, 0xFF	; 255
    1b1a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b1c:	4a e0       	ldi	r20, 0x0A	; 10
    1b1e:	50 e0       	ldi	r21, 0x00	; 0
    1b20:	20 e0       	ldi	r18, 0x00	; 0
    1b22:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    1b26:	89 81       	ldd	r24, Y+1	; 0x01
    1b28:	0f 90       	pop	r0
    1b2a:	cf 91       	pop	r28
    1b2c:	df 91       	pop	r29
    1b2e:	08 95       	ret

00001b30 <checkLockerSensors>:
  }
  return result;
}

void checkLockerSensors(void)
{
    1b30:	0f 93       	push	r16
    1b32:	1f 93       	push	r17
  if (lockSensors[0].enabled)
    1b34:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1b38:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1b3c:	80 81       	ld	r24, Z
    1b3e:	88 23       	and	r24, r24
    1b40:	41 f1       	breq	.+80     	; 0x1b92 <checkLockerSensors+0x62>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1b42:	80 e4       	ldi	r24, 0x40	; 64
    1b44:	60 e0       	ldi	r22, 0x00	; 0
    1b46:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1b4a:	8e e1       	ldi	r24, 0x1E	; 30
    1b4c:	90 e0       	ldi	r25, 0x00	; 0
    1b4e:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
    1b52:	00 91 a0 0e 	lds	r16, 0x0EA0
    1b56:	10 91 a1 0e 	lds	r17, 0x0EA1
    1b5a:	84 e0       	ldi	r24, 0x04	; 4
    1b5c:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MCP3008_getSampleSingle>
    1b60:	f8 01       	movw	r30, r16
    1b62:	94 83       	std	Z+4, r25	; 0x04
    1b64:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1b66:	80 e4       	ldi	r24, 0x40	; 64
    1b68:	60 e0       	ldi	r22, 0x00	; 0
    1b6a:	0e 94 cb 28 	call	0x5196	; 0x5196 <MPC23s17ClearBitsOnPortA>
    lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
    1b6e:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1b72:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1b76:	40 e0       	ldi	r20, 0x00	; 0
    1b78:	23 81       	ldd	r18, Z+3	; 0x03
    1b7a:	34 81       	ldd	r19, Z+4	; 0x04
    1b7c:	81 81       	ldd	r24, Z+1	; 0x01
    1b7e:	92 81       	ldd	r25, Z+2	; 0x02
    1b80:	82 17       	cp	r24, r18
    1b82:	93 07       	cpc	r25, r19
    1b84:	08 f4       	brcc	.+2      	; 0x1b88 <checkLockerSensors+0x58>
    1b86:	41 e0       	ldi	r20, 0x01	; 1
    1b88:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1b8a:	8a e0       	ldi	r24, 0x0A	; 10
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
  }
  
  if (lockSensors[1].enabled)
    1b92:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1b96:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1b9a:	86 81       	ldd	r24, Z+6	; 0x06
    1b9c:	88 23       	and	r24, r24
    1b9e:	59 f1       	breq	.+86     	; 0x1bf6 <checkLockerSensors+0xc6>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1ba0:	80 e2       	ldi	r24, 0x20	; 32
    1ba2:	60 e0       	ldi	r22, 0x00	; 0
    1ba4:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1ba8:	8e e1       	ldi	r24, 0x1E	; 30
    1baa:	90 e0       	ldi	r25, 0x00	; 0
    1bac:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
    1bb0:	00 91 a0 0e 	lds	r16, 0x0EA0
    1bb4:	10 91 a1 0e 	lds	r17, 0x0EA1
    1bb8:	0a 5f       	subi	r16, 0xFA	; 250
    1bba:	1f 4f       	sbci	r17, 0xFF	; 255
    1bbc:	85 e0       	ldi	r24, 0x05	; 5
    1bbe:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MCP3008_getSampleSingle>
    1bc2:	f8 01       	movw	r30, r16
    1bc4:	94 83       	std	Z+4, r25	; 0x04
    1bc6:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1bc8:	80 e2       	ldi	r24, 0x20	; 32
    1bca:	60 e0       	ldi	r22, 0x00	; 0
    1bcc:	0e 94 cb 28 	call	0x5196	; 0x5196 <MPC23s17ClearBitsOnPortA>
    lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
    1bd0:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1bd4:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1bd8:	36 96       	adiw	r30, 0x06	; 6
    1bda:	40 e0       	ldi	r20, 0x00	; 0
    1bdc:	23 81       	ldd	r18, Z+3	; 0x03
    1bde:	34 81       	ldd	r19, Z+4	; 0x04
    1be0:	81 81       	ldd	r24, Z+1	; 0x01
    1be2:	92 81       	ldd	r25, Z+2	; 0x02
    1be4:	82 17       	cp	r24, r18
    1be6:	93 07       	cpc	r25, r19
    1be8:	08 f4       	brcc	.+2      	; 0x1bec <checkLockerSensors+0xbc>
    1bea:	41 e0       	ldi	r20, 0x01	; 1
    1bec:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1bee:	8a e0       	ldi	r24, 0x0A	; 10
    1bf0:	90 e0       	ldi	r25, 0x00	; 0
    1bf2:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
  }
  
  if (lockSensors[2].enabled)
    1bf6:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1bfa:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1bfe:	84 85       	ldd	r24, Z+12	; 0x0c
    1c00:	88 23       	and	r24, r24
    1c02:	59 f1       	breq	.+86     	; 0x1c5a <checkLockerSensors+0x12a>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1c04:	80 e1       	ldi	r24, 0x10	; 16
    1c06:	60 e0       	ldi	r22, 0x00	; 0
    1c08:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1c0c:	8e e1       	ldi	r24, 0x1E	; 30
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
    1c14:	00 91 a0 0e 	lds	r16, 0x0EA0
    1c18:	10 91 a1 0e 	lds	r17, 0x0EA1
    1c1c:	04 5f       	subi	r16, 0xF4	; 244
    1c1e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c20:	86 e0       	ldi	r24, 0x06	; 6
    1c22:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MCP3008_getSampleSingle>
    1c26:	f8 01       	movw	r30, r16
    1c28:	94 83       	std	Z+4, r25	; 0x04
    1c2a:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1c2c:	80 e1       	ldi	r24, 0x10	; 16
    1c2e:	60 e0       	ldi	r22, 0x00	; 0
    1c30:	0e 94 cb 28 	call	0x5196	; 0x5196 <MPC23s17ClearBitsOnPortA>
    lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
    1c34:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c38:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1c3c:	3c 96       	adiw	r30, 0x0c	; 12
    1c3e:	40 e0       	ldi	r20, 0x00	; 0
    1c40:	23 81       	ldd	r18, Z+3	; 0x03
    1c42:	34 81       	ldd	r19, Z+4	; 0x04
    1c44:	81 81       	ldd	r24, Z+1	; 0x01
    1c46:	92 81       	ldd	r25, Z+2	; 0x02
    1c48:	82 17       	cp	r24, r18
    1c4a:	93 07       	cpc	r25, r19
    1c4c:	08 f4       	brcc	.+2      	; 0x1c50 <checkLockerSensors+0x120>
    1c4e:	41 e0       	ldi	r20, 0x01	; 1
    1c50:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1c52:	8a e0       	ldi	r24, 0x0A	; 10
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
  }
  
  if (lockSensors[3].enabled)
    1c5a:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c5e:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1c62:	82 89       	ldd	r24, Z+18	; 0x12
    1c64:	88 23       	and	r24, r24
    1c66:	59 f1       	breq	.+86     	; 0x1cbe <checkLockerSensors+0x18e>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1c68:	88 e0       	ldi	r24, 0x08	; 8
    1c6a:	60 e0       	ldi	r22, 0x00	; 0
    1c6c:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1c70:	8e e1       	ldi	r24, 0x1E	; 30
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    1c78:	00 91 a0 0e 	lds	r16, 0x0EA0
    1c7c:	10 91 a1 0e 	lds	r17, 0x0EA1
    1c80:	0e 5e       	subi	r16, 0xEE	; 238
    1c82:	1f 4f       	sbci	r17, 0xFF	; 255
    1c84:	87 e0       	ldi	r24, 0x07	; 7
    1c86:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MCP3008_getSampleSingle>
    1c8a:	f8 01       	movw	r30, r16
    1c8c:	94 83       	std	Z+4, r25	; 0x04
    1c8e:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1c90:	88 e0       	ldi	r24, 0x08	; 8
    1c92:	60 e0       	ldi	r22, 0x00	; 0
    1c94:	0e 94 cb 28 	call	0x5196	; 0x5196 <MPC23s17ClearBitsOnPortA>
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    1c98:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c9c:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1ca0:	72 96       	adiw	r30, 0x12	; 18
    1ca2:	40 e0       	ldi	r20, 0x00	; 0
    1ca4:	23 81       	ldd	r18, Z+3	; 0x03
    1ca6:	34 81       	ldd	r19, Z+4	; 0x04
    1ca8:	81 81       	ldd	r24, Z+1	; 0x01
    1caa:	92 81       	ldd	r25, Z+2	; 0x02
    1cac:	82 17       	cp	r24, r18
    1cae:	93 07       	cpc	r25, r19
    1cb0:	08 f4       	brcc	.+2      	; 0x1cb4 <checkLockerSensors+0x184>
    1cb2:	41 e0       	ldi	r20, 0x01	; 1
    1cb4:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    1cb6:	8a e0       	ldi	r24, 0x0A	; 10
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
  }
}
    1cbe:	1f 91       	pop	r17
    1cc0:	0f 91       	pop	r16
    1cc2:	08 95       	ret

00001cc4 <printLockers>:
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
}

uint8_t printLockers(FILE *stream)
{
    1cc4:	4f 92       	push	r4
    1cc6:	5f 92       	push	r5
    1cc8:	6f 92       	push	r6
    1cca:	7f 92       	push	r7
    1ccc:	8f 92       	push	r8
    1cce:	9f 92       	push	r9
    1cd0:	af 92       	push	r10
    1cd2:	bf 92       	push	r11
    1cd4:	df 92       	push	r13
    1cd6:	ef 92       	push	r14
    1cd8:	ff 92       	push	r15
    1cda:	0f 93       	push	r16
    1cdc:	1f 93       	push	r17
    1cde:	cf 93       	push	r28
    1ce0:	df 93       	push	r29
    1ce2:	7c 01       	movw	r14, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
    1ce4:	00 91 a0 0e 	lds	r16, 0x0EA0
    1ce8:	10 91 a1 0e 	lds	r17, 0x0EA1
    1cec:	dd 24       	eor	r13, r13
    1cee:	c0 e0       	ldi	r28, 0x00	; 0
    1cf0:	d0 e0       	ldi	r29, 0x00	; 0
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1cf2:	3c e8       	ldi	r19, 0x8C	; 140
    1cf4:	43 2e       	mov	r4, r19
    1cf6:	30 e0       	ldi	r19, 0x00	; 0
    1cf8:	53 2e       	mov	r5, r19
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1cfa:	29 ea       	ldi	r18, 0xA9	; 169
    1cfc:	62 2e       	mov	r6, r18
    1cfe:	20 e0       	ldi	r18, 0x00	; 0
    1d00:	72 2e       	mov	r7, r18
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
    1d02:	90 ea       	ldi	r25, 0xA0	; 160
    1d04:	89 2e       	mov	r8, r25
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	99 2e       	mov	r9, r25
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
    1d0a:	87 e9       	ldi	r24, 0x97	; 151
    1d0c:	a8 2e       	mov	r10, r24
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	b8 2e       	mov	r11, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    1d12:	d8 01       	movw	r26, r16
    1d14:	8c 91       	ld	r24, X
    1d16:	88 23       	and	r24, r24
    1d18:	09 f4       	brne	.+2      	; 0x1d1c <printLockers+0x58>
    1d1a:	6c c0       	rjmp	.+216    	; 0x1df4 <printLockers+0x130>
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1d1c:	00 d0       	rcall	.+0      	; 0x1d1e <printLockers+0x5a>
    1d1e:	00 d0       	rcall	.+0      	; 0x1d20 <printLockers+0x5c>
    1d20:	00 d0       	rcall	.+0      	; 0x1d22 <printLockers+0x5e>
    1d22:	ed b7       	in	r30, 0x3d	; 61
    1d24:	fe b7       	in	r31, 0x3e	; 62
    1d26:	31 96       	adiw	r30, 0x01	; 1
    1d28:	ad b7       	in	r26, 0x3d	; 61
    1d2a:	be b7       	in	r27, 0x3e	; 62
    1d2c:	12 96       	adiw	r26, 0x02	; 2
    1d2e:	fc 92       	st	X, r15
    1d30:	ee 92       	st	-X, r14
    1d32:	11 97       	sbiw	r26, 0x01	; 1
    1d34:	53 82       	std	Z+3, r5	; 0x03
    1d36:	42 82       	std	Z+2, r4	; 0x02
    1d38:	21 96       	adiw	r28, 0x01	; 1
    1d3a:	d5 83       	std	Z+5, r29	; 0x05
    1d3c:	c4 83       	std	Z+4, r28	; 0x04
    1d3e:	21 97       	sbiw	r28, 0x01	; 1
    1d40:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      if (tmpLock->threshold > tmpLock->acVal)
    1d44:	ed b7       	in	r30, 0x3d	; 61
    1d46:	fe b7       	in	r31, 0x3e	; 62
    1d48:	36 96       	adiw	r30, 0x06	; 6
    1d4a:	0f b6       	in	r0, 0x3f	; 63
    1d4c:	f8 94       	cli
    1d4e:	fe bf       	out	0x3e, r31	; 62
    1d50:	0f be       	out	0x3f, r0	; 63
    1d52:	ed bf       	out	0x3d, r30	; 61
    1d54:	d8 01       	movw	r26, r16
    1d56:	11 96       	adiw	r26, 0x01	; 1
    1d58:	2d 91       	ld	r18, X+
    1d5a:	3c 91       	ld	r19, X
    1d5c:	12 97       	sbiw	r26, 0x02	; 2
    1d5e:	13 96       	adiw	r26, 0x03	; 3
    1d60:	8d 91       	ld	r24, X+
    1d62:	9c 91       	ld	r25, X
    1d64:	14 97       	sbiw	r26, 0x04	; 4
    1d66:	82 17       	cp	r24, r18
    1d68:	93 07       	cpc	r25, r19
    1d6a:	48 f4       	brcc	.+18     	; 0x1d7e <printLockers+0xba>
        fprintf_P(stream, statusLockerOpenStr);
    1d6c:	00 d0       	rcall	.+0      	; 0x1d6e <printLockers+0xaa>
    1d6e:	00 d0       	rcall	.+0      	; 0x1d70 <printLockers+0xac>
    1d70:	ed b7       	in	r30, 0x3d	; 61
    1d72:	fe b7       	in	r31, 0x3e	; 62
    1d74:	f2 82       	std	Z+2, r15	; 0x02
    1d76:	e1 82       	std	Z+1, r14	; 0x01
    1d78:	b4 82       	std	Z+4, r11	; 0x04
    1d7a:	a3 82       	std	Z+3, r10	; 0x03
    1d7c:	0c c0       	rjmp	.+24     	; 0x1d96 <printLockers+0xd2>
      else
        fprintf_P(stream, statusLockerCloseStr);
    1d7e:	00 d0       	rcall	.+0      	; 0x1d80 <printLockers+0xbc>
    1d80:	00 d0       	rcall	.+0      	; 0x1d82 <printLockers+0xbe>
    1d82:	ad b7       	in	r26, 0x3d	; 61
    1d84:	be b7       	in	r27, 0x3e	; 62
    1d86:	12 96       	adiw	r26, 0x02	; 2
    1d88:	fc 92       	st	X, r15
    1d8a:	ee 92       	st	-X, r14
    1d8c:	11 97       	sbiw	r26, 0x01	; 1
    1d8e:	14 96       	adiw	r26, 0x04	; 4
    1d90:	9c 92       	st	X, r9
    1d92:	8e 92       	st	-X, r8
    1d94:	13 97       	sbiw	r26, 0x03	; 3
    1d96:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    1d9a:	0f 90       	pop	r0
    1d9c:	0f 90       	pop	r0
    1d9e:	0f 90       	pop	r0
    1da0:	0f 90       	pop	r0
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1da2:	ed b7       	in	r30, 0x3d	; 61
    1da4:	fe b7       	in	r31, 0x3e	; 62
    1da6:	38 97       	sbiw	r30, 0x08	; 8
    1da8:	0f b6       	in	r0, 0x3f	; 63
    1daa:	f8 94       	cli
    1dac:	fe bf       	out	0x3e, r31	; 62
    1dae:	0f be       	out	0x3f, r0	; 63
    1db0:	ed bf       	out	0x3d, r30	; 61
    1db2:	31 96       	adiw	r30, 0x01	; 1
    1db4:	ad b7       	in	r26, 0x3d	; 61
    1db6:	be b7       	in	r27, 0x3e	; 62
    1db8:	12 96       	adiw	r26, 0x02	; 2
    1dba:	fc 92       	st	X, r15
    1dbc:	ee 92       	st	-X, r14
    1dbe:	11 97       	sbiw	r26, 0x01	; 1
    1dc0:	73 82       	std	Z+3, r7	; 0x03
    1dc2:	62 82       	std	Z+2, r6	; 0x02
    1dc4:	d8 01       	movw	r26, r16
    1dc6:	11 96       	adiw	r26, 0x01	; 1
    1dc8:	8d 91       	ld	r24, X+
    1dca:	9c 91       	ld	r25, X
    1dcc:	12 97       	sbiw	r26, 0x02	; 2
    1dce:	95 83       	std	Z+5, r25	; 0x05
    1dd0:	84 83       	std	Z+4, r24	; 0x04
    1dd2:	13 96       	adiw	r26, 0x03	; 3
    1dd4:	8d 91       	ld	r24, X+
    1dd6:	9c 91       	ld	r25, X
    1dd8:	14 97       	sbiw	r26, 0x04	; 4
    1dda:	97 83       	std	Z+7, r25	; 0x07
    1ddc:	86 83       	std	Z+6, r24	; 0x06
    1dde:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      result++;
    1de2:	d3 94       	inc	r13
    1de4:	ed b7       	in	r30, 0x3d	; 61
    1de6:	fe b7       	in	r31, 0x3e	; 62
    1de8:	38 96       	adiw	r30, 0x08	; 8
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	f8 94       	cli
    1dee:	fe bf       	out	0x3e, r31	; 62
    1df0:	0f be       	out	0x3f, r0	; 63
    1df2:	ed bf       	out	0x3d, r30	; 61
    1df4:	21 96       	adiw	r28, 0x01	; 1
uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
    1df6:	c4 30       	cpi	r28, 0x04	; 4
    1df8:	d1 05       	cpc	r29, r1
    1dfa:	19 f0       	breq	.+6      	; 0x1e02 <printLockers+0x13e>
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
      result++;
    }
    tmpLock++;
    1dfc:	0a 5f       	subi	r16, 0xFA	; 250
    1dfe:	1f 4f       	sbci	r17, 0xFF	; 255
    1e00:	88 cf       	rjmp	.-240    	; 0x1d12 <printLockers+0x4e>
  }
  return result;
}
    1e02:	8d 2d       	mov	r24, r13
    1e04:	df 91       	pop	r29
    1e06:	cf 91       	pop	r28
    1e08:	1f 91       	pop	r17
    1e0a:	0f 91       	pop	r16
    1e0c:	ff 90       	pop	r15
    1e0e:	ef 90       	pop	r14
    1e10:	df 90       	pop	r13
    1e12:	bf 90       	pop	r11
    1e14:	af 90       	pop	r10
    1e16:	9f 90       	pop	r9
    1e18:	8f 90       	pop	r8
    1e1a:	7f 90       	pop	r7
    1e1c:	6f 90       	pop	r6
    1e1e:	5f 90       	pop	r5
    1e20:	4f 90       	pop	r4
    1e22:	08 95       	ret

00001e24 <LockersMemInit>:
   */
}

void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
    1e24:	88 e1       	ldi	r24, 0x18	; 24
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	0e 94 2e 1c 	call	0x385c	; 0x385c <xmalloc>
    1e2c:	90 93 a1 0e 	sts	0x0EA1, r25
    1e30:	80 93 a0 0e 	sts	0x0EA0, r24
}
    1e34:	08 95       	ret

00001e36 <hardwareInit>:
xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisję do czasu zakończenia wysyłania poprzedniego bajtu

void hardwareInit(void)
{
  //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    1e36:	0f b6       	in	r0, 0x3f	; 63
    1e38:	f8 94       	cli
    1e3a:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	61 e0       	ldi	r22, 0x01	; 1
    1e40:	0e 94 87 52 	call	0xa50e	; 0xa50e <xQueueCreate>
    1e44:	90 93 63 0f 	sts	0x0F63, r25
    1e48:	80 93 62 0f 	sts	0x0F62, r24
  portEXIT_CRITICAL();
    1e4c:	0f 90       	pop	r0
    1e4e:	0f be       	out	0x3f, r0	; 63

  DDRB = 0xF7;
    1e50:	87 ef       	ldi	r24, 0xF7	; 247
    1e52:	87 bb       	out	0x17, r24	; 23
  PORTB = 0xD1;
    1e54:	81 ed       	ldi	r24, 0xD1	; 209
    1e56:	88 bb       	out	0x18, r24	; 24
   7 - External SPI ASR 7 (MPC23S17)   0 - on;  1 - off
  */
  
  //DDRC = 0x00;  //External Memory

  DDRD = 0x00;
    1e58:	11 ba       	out	0x11, r1	; 17
   5 - External SPI ASR 1
   6 - External SPI ASR 2
   7 - External SPI ASR 3
   */

  DDRE  = 0x0E;
    1e5a:	8e e0       	ldi	r24, 0x0E	; 14
    1e5c:	82 b9       	out	0x02, r24	; 2
  PORTE = 0x0C;
    1e5e:	8c e0       	ldi	r24, 0x0C	; 12
    1e60:	83 b9       	out	0x03, r24	; 3
   4 - INT 4
   5 - INT 5
   6 - INT 6
   7 - INT Enc28j60
  */
  DDRF = 0x0F;    //JTAG and A/C
    1e62:	8f e0       	ldi	r24, 0x0F	; 15
    1e64:	80 93 61 00 	sts	0x0061, r24
  DDRG = 0x1F;
    1e68:	8f e1       	ldi	r24, 0x1F	; 31
    1e6a:	80 93 64 00 	sts	0x0064, r24
   4 - RS485 TxEn
   5 - 
   6 - 
   7 - 
   */
}
    1e6e:	08 95       	ret

00001e70 <sensorsTask>:
  LockersMemInit();
  rollersMemInit();
}

void sensorsTask(void* pvParameters)
{
    1e70:	1f 93       	push	r17
  pvParameters = NULL;
  uint8_t addr = 255;
//  uint8_t i;

  MPC23s17SetDirA(0x00, 0);
    1e72:	80 e0       	ldi	r24, 0x00	; 0
    1e74:	60 e0       	ldi	r22, 0x00	; 0
    1e76:	0e 94 41 29 	call	0x5282	; 0x5282 <MPC23s17SetDirA>
  
  MPC23s17SetDirB(0x00, 0);
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	60 e0       	ldi	r22, 0x00	; 0
    1e7e:	0e 94 26 29 	call	0x524c	; 0x524c <MPC23s17SetDirB>

  for( ; ; )
  {
    uint16_t tmp;
    //Read power suply voltage
    tmp = MCP3008_getSampleSingle(0);
    1e82:	80 e0       	ldi	r24, 0x00	; 0
    1e84:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MCP3008_getSampleSingle>
    voltage = (uint8_t)(tmp>>5);
    1e88:	65 e0       	ldi	r22, 0x05	; 5
    1e8a:	96 95       	lsr	r25
    1e8c:	87 95       	ror	r24
    1e8e:	6a 95       	dec	r22
    1e90:	e1 f7       	brne	.-8      	; 0x1e8a <sensorsTask+0x1a>
    1e92:	80 93 ac 0e 	sts	0x0EAC, r24
    vTaskDelay(10);
    1e96:	8a e0       	ldi	r24, 0x0A	; 10
    1e98:	90 e0       	ldi	r25, 0x00	; 0
    1e9a:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MCP3008_getSampleSingle>
    tmp *=10;
    temperature = (uint8_t)(tmp / 24);
    1ea4:	9c 01       	movw	r18, r24
    1ea6:	53 e0       	ldi	r21, 0x03	; 3
    1ea8:	88 0f       	add	r24, r24
    1eaa:	99 1f       	adc	r25, r25
    1eac:	5a 95       	dec	r21
    1eae:	e1 f7       	brne	.-8      	; 0x1ea8 <sensorsTask+0x38>
    1eb0:	22 0f       	add	r18, r18
    1eb2:	33 1f       	adc	r19, r19
    1eb4:	82 0f       	add	r24, r18
    1eb6:	93 1f       	adc	r25, r19
    1eb8:	68 e1       	ldi	r22, 0x18	; 24
    1eba:	70 e0       	ldi	r23, 0x00	; 0
    1ebc:	0e 94 de 56 	call	0xadbc	; 0xadbc <__udivmodhi4>
    1ec0:	60 93 a4 0e 	sts	0x0EA4, r22
    vTaskDelay(10);
    1ec4:	8a e0       	ldi	r24, 0x0A	; 10
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
      
    //read lock
    checkLockerSensors();
    1ecc:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <checkLockerSensors>
    1ed0:	11 e0       	ldi	r17, 0x01	; 1

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    {
      rs485rollerHello(addr);
    1ed2:	81 2f       	mov	r24, r17
    1ed4:	0e 94 d9 46 	call	0x8db2	; 0x8db2 <rs485rollerHello>
      vTaskDelay(10);
    1ed8:	8a e0       	ldi	r24, 0x0A	; 10
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    vTaskDelay(10);
      
    //read lock
    checkLockerSensors();

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1ee0:	1f 5f       	subi	r17, 0xFF	; 255
    1ee2:	10 32       	cpi	r17, 0x20	; 32
    1ee4:	b1 f7       	brne	.-20     	; 0x1ed2 <sensorsTask+0x62>
    1ee6:	cd cf       	rjmp	.-102    	; 0x1e82 <sensorsTask+0x12>

00001ee8 <sensorsTaskInit>:



void sensorsTaskInit(void)
{
  LockersMemInit();
    1ee8:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <LockersMemInit>
  rollersMemInit();
    1eec:	0e 94 af 48 	call	0x915e	; 0x915e <rollersMemInit>
}
    1ef0:	08 95       	ret

00001ef2 <enableFunction>:
  state->err1 = 0;
  state->err2 = 0;
}

static cliExRes_t enableFunction(cmdState_t *state)
{
    1ef2:	fc 01       	movw	r30, r24
  if (state->cliMode != RESTRICTED_NORMAL)
    1ef4:	80 a1       	ldd	r24, Z+32	; 0x20
    1ef6:	83 30       	cpi	r24, 0x03	; 3
    1ef8:	19 f4       	brne	.+6      	; 0x1f00 <enableFunction+0xe>
    1efa:	25 e0       	ldi	r18, 0x05	; 5
    1efc:	30 e0       	ldi	r19, 0x00	; 0
    1efe:	08 c0       	rjmp	.+16     	; 0x1f10 <enableFunction+0x1e>
  {
    state->cmdList = cmdListEnable;
    1f00:	80 e8       	ldi	r24, 0x80	; 128
    1f02:	99 e0       	ldi	r25, 0x09	; 9
    1f04:	92 a3       	std	Z+34, r25	; 0x22
    1f06:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_ENABLE;
    1f08:	81 e0       	ldi	r24, 0x01	; 1
    1f0a:	80 a3       	std	Z+32, r24	; 0x20
    1f0c:	20 e0       	ldi	r18, 0x00	; 0
    1f0e:	30 e0       	ldi	r19, 0x00	; 0
    return OK_SILENT;
  }
  return ERROR_OPERATION_NOT_ALLOWED;
}
    1f10:	c9 01       	movw	r24, r18
    1f12:	08 95       	ret

00001f14 <disableFunction>:
static cliExRes_t disableFunction(cmdState_t *state)
{
    1f14:	fc 01       	movw	r30, r24
  state->cmdList = cmdListNormal;
    1f16:	8a e4       	ldi	r24, 0x4A	; 74
    1f18:	99 e0       	ldi	r25, 0x09	; 9
    1f1a:	92 a3       	std	Z+34, r25	; 0x22
    1f1c:	81 a3       	std	Z+33, r24	; 0x21
  if (state->cliMode != RESTRICTED_NORMAL)
    1f1e:	80 a1       	ldd	r24, Z+32	; 0x20
    1f20:	83 30       	cpi	r24, 0x03	; 3
    1f22:	09 f0       	breq	.+2      	; 0x1f26 <disableFunction+0x12>
  {
    state->cliMode = NR_NORMAL;
    1f24:	10 a2       	std	Z+32, r1	; 0x20
  }
  return OK_SILENT;
}
    1f26:	80 e0       	ldi	r24, 0x00	; 0
    1f28:	90 e0       	ldi	r25, 0x00	; 0
    1f2a:	08 95       	ret

00001f2c <configureModeFunction>:
static cliExRes_t configureModeFunction(cmdState_t *state)
{
    1f2c:	fc 01       	movw	r30, r24
  if (state->cliMode == NR_ENABLE)
    1f2e:	80 a1       	ldd	r24, Z+32	; 0x20
    1f30:	81 30       	cpi	r24, 0x01	; 1
    1f32:	19 f0       	breq	.+6      	; 0x1f3a <configureModeFunction+0xe>
    1f34:	25 e0       	ldi	r18, 0x05	; 5
    1f36:	30 e0       	ldi	r19, 0x00	; 0
    1f38:	08 c0       	rjmp	.+16     	; 0x1f4a <configureModeFunction+0x1e>
  {
    state->cmdList = cmdListConfigure;
    1f3a:	86 e1       	ldi	r24, 0x16	; 22
    1f3c:	9a e0       	ldi	r25, 0x0A	; 10
    1f3e:	92 a3       	std	Z+34, r25	; 0x22
    1f40:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_CONFIGURE;
    1f42:	82 e0       	ldi	r24, 0x02	; 2
    1f44:	80 a3       	std	Z+32, r24	; 0x20
    1f46:	20 e0       	ldi	r18, 0x00	; 0
    1f48:	30 e0       	ldi	r19, 0x00	; 0
    return OK_SILENT;
  }
  return ERROR_OPERATION_NOT_ALLOWED;
}
    1f4a:	c9 01       	movw	r24, r18
    1f4c:	08 95       	ret

00001f4e <saveConfigFunction>:
}

static cliExRes_t saveConfigFunction(cmdState_t *state)
{
  state = NULL;
  saveConfiguration();
    1f4e:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <saveConfiguration>
  return OK_SILENT;
}
    1f52:	80 e0       	ldi	r24, 0x00	; 0
    1f54:	90 e0       	ldi	r25, 0x00	; 0
    1f56:	08 95       	ret

00001f58 <setMacAddrFunction>:
  ipSetConfigGw(gw);
  return OK_SILENT;
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
    1f58:	cf 93       	push	r28
    1f5a:	df 93       	push	r29
    1f5c:	ec 01       	movw	r28, r24
  if (state->argc < 6)
    1f5e:	89 8d       	ldd	r24, Y+25	; 0x19
    1f60:	86 30       	cpi	r24, 0x06	; 6
    1f62:	18 f4       	brcc	.+6      	; 0x1f6a <setMacAddrFunction+0x12>
    1f64:	22 e0       	ldi	r18, 0x02	; 2
    1f66:	30 e0       	ldi	r19, 0x00	; 0
    1f68:	2a c0       	rjmp	.+84     	; 0x1fbe <setMacAddrFunction+0x66>
    return SYNTAX_ERROR;  
  
  nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
    1f6a:	81 e0       	ldi	r24, 0x01	; 1
    1f6c:	be 01       	movw	r22, r28
    1f6e:	0e 94 54 22 	call	0x44a8	; 0x44a8 <cmdlineGetArgHex>
    1f72:	60 93 80 0e 	sts	0x0E80, r22
  nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
    1f76:	82 e0       	ldi	r24, 0x02	; 2
    1f78:	be 01       	movw	r22, r28
    1f7a:	0e 94 54 22 	call	0x44a8	; 0x44a8 <cmdlineGetArgHex>
    1f7e:	60 93 81 0e 	sts	0x0E81, r22
  nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
    1f82:	83 e0       	ldi	r24, 0x03	; 3
    1f84:	be 01       	movw	r22, r28
    1f86:	0e 94 54 22 	call	0x44a8	; 0x44a8 <cmdlineGetArgHex>
    1f8a:	60 93 82 0e 	sts	0x0E82, r22
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
    1f8e:	84 e0       	ldi	r24, 0x04	; 4
    1f90:	be 01       	movw	r22, r28
    1f92:	0e 94 54 22 	call	0x44a8	; 0x44a8 <cmdlineGetArgHex>
    1f96:	60 93 83 0e 	sts	0x0E83, r22
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
    1f9a:	85 e0       	ldi	r24, 0x05	; 5
    1f9c:	be 01       	movw	r22, r28
    1f9e:	0e 94 54 22 	call	0x44a8	; 0x44a8 <cmdlineGetArgHex>
    1fa2:	60 93 84 0e 	sts	0x0E84, r22
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
    1fa6:	86 e0       	ldi	r24, 0x06	; 6
    1fa8:	be 01       	movw	r22, r28
    1faa:	0e 94 54 22 	call	0x44a8	; 0x44a8 <cmdlineGetArgHex>
    1fae:	60 93 85 0e 	sts	0x0E85, r22
  nicSetMacAddress(nicState.mac.addr);
    1fb2:	80 e8       	ldi	r24, 0x80	; 128
    1fb4:	9e e0       	ldi	r25, 0x0E	; 14
    1fb6:	0e 94 0a 2a 	call	0x5414	; 0x5414 <nicSetMacAddress>
    1fba:	20 e0       	ldi	r18, 0x00	; 0
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    1fbe:	c9 01       	movw	r24, r18
    1fc0:	df 91       	pop	r29
    1fc2:	cf 91       	pop	r28
    1fc4:	08 95       	ret

00001fc6 <pingFunction>:
  printErrorInfo(state);
  return OK_SILENT;
}

static cliExRes_t pingFunction(cmdState_t *state)
{
    1fc6:	cf 93       	push	r28
    1fc8:	df 93       	push	r29
    1fca:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1fcc:	89 8d       	ldd	r24, Y+25	; 0x19
    1fce:	84 30       	cpi	r24, 0x04	; 4
    1fd0:	18 f4       	brcc	.+6      	; 0x1fd8 <pingFunction+0x12>
    1fd2:	22 e0       	ldi	r18, 0x02	; 2
    1fd4:	30 e0       	ldi	r19, 0x00	; 0
    1fd6:	12 c0       	rjmp	.+36     	; 0x1ffc <pingFunction+0x36>
    return SYNTAX_ERROR;
  
  uint8_t ip[4];
  ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	be 01       	movw	r22, r28
    1fdc:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
  ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
    1fe0:	82 e0       	ldi	r24, 0x02	; 2
    1fe2:	be 01       	movw	r22, r28
    1fe4:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
  ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
    1fe8:	83 e0       	ldi	r24, 0x03	; 3
    1fea:	be 01       	movw	r22, r28
    1fec:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
    1ff0:	84 e0       	ldi	r24, 0x04	; 4
    1ff2:	be 01       	movw	r22, r28
    1ff4:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    1ff8:	20 e0       	ldi	r18, 0x00	; 0
    1ffa:	30 e0       	ldi	r19, 0x00	; 0

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
}
    1ffc:	c9 01       	movw	r24, r18
    1ffe:	df 91       	pop	r29
    2000:	cf 91       	pop	r28
    2002:	08 95       	ret

00002004 <setUdpFunction>:
  ipSetConfigIp(ip);
  return OK_SILENT;
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
    2004:	6f 92       	push	r6
    2006:	7f 92       	push	r7
    2008:	8f 92       	push	r8
    200a:	9f 92       	push	r9
    200c:	af 92       	push	r10
    200e:	bf 92       	push	r11
    2010:	cf 92       	push	r12
    2012:	df 92       	push	r13
    2014:	ef 92       	push	r14
    2016:	ff 92       	push	r15
    2018:	0f 93       	push	r16
    201a:	1f 93       	push	r17
    201c:	cf 93       	push	r28
    201e:	df 93       	push	r29
    2020:	ec 01       	movw	r28, r24
  if (state->argc < 5)
    2022:	89 8d       	ldd	r24, Y+25	; 0x19
    2024:	85 30       	cpi	r24, 0x05	; 5
    2026:	18 f4       	brcc	.+6      	; 0x202e <setUdpFunction+0x2a>
    2028:	22 e0       	ldi	r18, 0x02	; 2
    202a:	30 e0       	ldi	r19, 0x00	; 0
    202c:	58 c0       	rjmp	.+176    	; 0x20de <setUdpFunction+0xda>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	be 01       	movw	r22, r28
    2032:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2036:	3b 01       	movw	r6, r22
    2038:	4c 01       	movw	r8, r24
    203a:	82 e0       	ldi	r24, 0x02	; 2
    203c:	be 01       	movw	r22, r28
    203e:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2042:	7b 01       	movw	r14, r22
    2044:	8c 01       	movw	r16, r24
    2046:	83 e0       	ldi	r24, 0x03	; 3
    2048:	be 01       	movw	r22, r28
    204a:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    204e:	5b 01       	movw	r10, r22
    2050:	6c 01       	movw	r12, r24
    2052:	84 e0       	ldi	r24, 0x04	; 4
    2054:	be 01       	movw	r22, r28
    2056:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
  udpSocket->dstIp = ip;
    205a:	e0 91 a2 0e 	lds	r30, 0x0EA2
    205e:	f0 91 a3 0e 	lds	r31, 0x0EA3
    2062:	10 2f       	mov	r17, r16
    2064:	0f 2d       	mov	r16, r15
    2066:	fe 2c       	mov	r15, r14
    2068:	ee 24       	eor	r14, r14
    206a:	65 01       	movw	r12, r10
    206c:	bb 24       	eor	r11, r11
    206e:	aa 24       	eor	r10, r10
    2070:	ea 0c       	add	r14, r10
    2072:	fb 1c       	adc	r15, r11
    2074:	0c 1d       	adc	r16, r12
    2076:	1d 1d       	adc	r17, r13
    2078:	e6 0c       	add	r14, r6
    207a:	f7 1c       	adc	r15, r7
    207c:	08 1d       	adc	r16, r8
    207e:	19 1d       	adc	r17, r9
    2080:	96 2f       	mov	r25, r22
    2082:	88 27       	eor	r24, r24
    2084:	77 27       	eor	r23, r23
    2086:	66 27       	eor	r22, r22
    2088:	e6 0e       	add	r14, r22
    208a:	f7 1e       	adc	r15, r23
    208c:	08 1f       	adc	r16, r24
    208e:	19 1f       	adc	r17, r25
    2090:	e6 82       	std	Z+6, r14	; 0x06
    2092:	f7 82       	std	Z+7, r15	; 0x07
    2094:	00 87       	std	Z+8, r16	; 0x08
    2096:	11 87       	std	Z+9, r17	; 0x09
  
  uint16_t port = cmdlineGetArgInt(5, state);
    2098:	85 e0       	ldi	r24, 0x05	; 5
    209a:	be 01       	movw	r22, r28
    209c:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    20a0:	dc 01       	movw	r26, r24
    20a2:	cb 01       	movw	r24, r22
  udpSocket->srcPort = htons(port);
    20a4:	00 91 a2 0e 	lds	r16, 0x0EA2
    20a8:	10 91 a3 0e 	lds	r17, 0x0EA3
    20ac:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    20b0:	f8 01       	movw	r30, r16
    20b2:	95 83       	std	Z+5, r25	; 0x05
    20b4:	84 83       	std	Z+4, r24	; 0x04
  
  if (state->argc > 5)
    20b6:	89 8d       	ldd	r24, Y+25	; 0x19
    20b8:	86 30       	cpi	r24, 0x06	; 6
    20ba:	78 f0       	brcs	.+30     	; 0x20da <setUdpFunction+0xd6>
  {
    port = cmdlineGetArgInt(6, state);
    20bc:	86 e0       	ldi	r24, 0x06	; 6
    20be:	be 01       	movw	r22, r28
    20c0:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    20c4:	dc 01       	movw	r26, r24
    20c6:	cb 01       	movw	r24, r22
    udpSocket->dstPort = htons(port);    
    20c8:	00 91 a2 0e 	lds	r16, 0x0EA2
    20cc:	10 91 a3 0e 	lds	r17, 0x0EA3
    20d0:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    20d4:	f8 01       	movw	r30, r16
    20d6:	93 83       	std	Z+3, r25	; 0x03
    20d8:	82 83       	std	Z+2, r24	; 0x02
    20da:	20 e0       	ldi	r18, 0x00	; 0
    20dc:	30 e0       	ldi	r19, 0x00	; 0
  }
  return OK_SILENT;
}
    20de:	c9 01       	movw	r24, r18
    20e0:	df 91       	pop	r29
    20e2:	cf 91       	pop	r28
    20e4:	1f 91       	pop	r17
    20e6:	0f 91       	pop	r16
    20e8:	ff 90       	pop	r15
    20ea:	ef 90       	pop	r14
    20ec:	df 90       	pop	r13
    20ee:	cf 90       	pop	r12
    20f0:	bf 90       	pop	r11
    20f2:	af 90       	pop	r10
    20f4:	9f 90       	pop	r9
    20f6:	8f 90       	pop	r8
    20f8:	7f 90       	pop	r7
    20fa:	6f 90       	pop	r6
    20fc:	08 95       	ret

000020fe <setIpGwFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
    20fe:	6f 92       	push	r6
    2100:	7f 92       	push	r7
    2102:	8f 92       	push	r8
    2104:	9f 92       	push	r9
    2106:	af 92       	push	r10
    2108:	bf 92       	push	r11
    210a:	cf 92       	push	r12
    210c:	df 92       	push	r13
    210e:	ef 92       	push	r14
    2110:	ff 92       	push	r15
    2112:	0f 93       	push	r16
    2114:	1f 93       	push	r17
    2116:	cf 93       	push	r28
    2118:	df 93       	push	r29
    211a:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    211c:	89 8d       	ldd	r24, Y+25	; 0x19
    211e:	84 30       	cpi	r24, 0x04	; 4
    2120:	18 f4       	brcc	.+6      	; 0x2128 <setIpGwFunction+0x2a>
    2122:	22 e0       	ldi	r18, 0x02	; 2
    2124:	30 e0       	ldi	r19, 0x00	; 0
    2126:	33 c0       	rjmp	.+102    	; 0x218e <setIpGwFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2128:	81 e0       	ldi	r24, 0x01	; 1
    212a:	be 01       	movw	r22, r28
    212c:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2130:	3b 01       	movw	r6, r22
    2132:	4c 01       	movw	r8, r24
    2134:	82 e0       	ldi	r24, 0x02	; 2
    2136:	be 01       	movw	r22, r28
    2138:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    213c:	7b 01       	movw	r14, r22
    213e:	8c 01       	movw	r16, r24
    2140:	83 e0       	ldi	r24, 0x03	; 3
    2142:	be 01       	movw	r22, r28
    2144:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2148:	5b 01       	movw	r10, r22
    214a:	6c 01       	movw	r12, r24
    214c:	84 e0       	ldi	r24, 0x04	; 4
    214e:	be 01       	movw	r22, r28
    2150:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
  ipSetConfigGw(gw);
    2154:	10 2f       	mov	r17, r16
    2156:	0f 2d       	mov	r16, r15
    2158:	fe 2c       	mov	r15, r14
    215a:	ee 24       	eor	r14, r14
    215c:	65 01       	movw	r12, r10
    215e:	bb 24       	eor	r11, r11
    2160:	aa 24       	eor	r10, r10
    2162:	ea 0c       	add	r14, r10
    2164:	fb 1c       	adc	r15, r11
    2166:	0c 1d       	adc	r16, r12
    2168:	1d 1d       	adc	r17, r13
    216a:	e6 0c       	add	r14, r6
    216c:	f7 1c       	adc	r15, r7
    216e:	08 1d       	adc	r16, r8
    2170:	19 1d       	adc	r17, r9
    2172:	96 2f       	mov	r25, r22
    2174:	88 27       	eor	r24, r24
    2176:	77 27       	eor	r23, r23
    2178:	66 27       	eor	r22, r22
    217a:	e6 0e       	add	r14, r22
    217c:	f7 1e       	adc	r15, r23
    217e:	08 1f       	adc	r16, r24
    2180:	19 1f       	adc	r17, r25
    2182:	c8 01       	movw	r24, r16
    2184:	b7 01       	movw	r22, r14
    2186:	0e 94 08 32 	call	0x6410	; 0x6410 <ipSetConfigGw>
    218a:	20 e0       	ldi	r18, 0x00	; 0
    218c:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    218e:	c9 01       	movw	r24, r18
    2190:	df 91       	pop	r29
    2192:	cf 91       	pop	r28
    2194:	1f 91       	pop	r17
    2196:	0f 91       	pop	r16
    2198:	ff 90       	pop	r15
    219a:	ef 90       	pop	r14
    219c:	df 90       	pop	r13
    219e:	cf 90       	pop	r12
    21a0:	bf 90       	pop	r11
    21a2:	af 90       	pop	r10
    21a4:	9f 90       	pop	r9
    21a6:	8f 90       	pop	r8
    21a8:	7f 90       	pop	r7
    21aa:	6f 90       	pop	r6
    21ac:	08 95       	ret

000021ae <setIpMaskFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
    21ae:	fc 01       	movw	r30, r24
  if (state->argc < 1)
    21b0:	81 8d       	ldd	r24, Z+25	; 0x19
    21b2:	88 23       	and	r24, r24
    21b4:	19 f4       	brne	.+6      	; 0x21bc <setIpMaskFunction+0xe>
    21b6:	22 e0       	ldi	r18, 0x02	; 2
    21b8:	30 e0       	ldi	r19, 0x00	; 0
    21ba:	17 c0       	rjmp	.+46     	; 0x21ea <setIpMaskFunction+0x3c>
    return SYNTAX_ERROR;
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
    21bc:	81 e0       	ldi	r24, 0x01	; 1
    21be:	bf 01       	movw	r22, r30
    21c0:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
  
  ipSetConfigMask(mask);
    21c4:	20 e2       	ldi	r18, 0x20	; 32
    21c6:	30 e0       	ldi	r19, 0x00	; 0
    21c8:	26 1b       	sub	r18, r22
    21ca:	37 0b       	sbc	r19, r23
    21cc:	6f ef       	ldi	r22, 0xFF	; 255
    21ce:	7f ef       	ldi	r23, 0xFF	; 255
    21d0:	8f ef       	ldi	r24, 0xFF	; 255
    21d2:	9f ef       	ldi	r25, 0xFF	; 255
    21d4:	04 c0       	rjmp	.+8      	; 0x21de <setIpMaskFunction+0x30>
    21d6:	96 95       	lsr	r25
    21d8:	87 95       	ror	r24
    21da:	77 95       	ror	r23
    21dc:	67 95       	ror	r22
    21de:	2a 95       	dec	r18
    21e0:	d2 f7       	brpl	.-12     	; 0x21d6 <setIpMaskFunction+0x28>
    21e2:	0e 94 ff 31 	call	0x63fe	; 0x63fe <ipSetConfigMask>
    21e6:	20 e0       	ldi	r18, 0x00	; 0
    21e8:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    21ea:	c9 01       	movw	r24, r18
    21ec:	08 95       	ret

000021ee <setIpFunction>:
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
  return OK_SILENT;
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
    21ee:	6f 92       	push	r6
    21f0:	7f 92       	push	r7
    21f2:	8f 92       	push	r8
    21f4:	9f 92       	push	r9
    21f6:	af 92       	push	r10
    21f8:	bf 92       	push	r11
    21fa:	cf 92       	push	r12
    21fc:	df 92       	push	r13
    21fe:	ef 92       	push	r14
    2200:	ff 92       	push	r15
    2202:	0f 93       	push	r16
    2204:	1f 93       	push	r17
    2206:	cf 93       	push	r28
    2208:	df 93       	push	r29
    220a:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    220c:	89 8d       	ldd	r24, Y+25	; 0x19
    220e:	84 30       	cpi	r24, 0x04	; 4
    2210:	18 f4       	brcc	.+6      	; 0x2218 <setIpFunction+0x2a>
    2212:	22 e0       	ldi	r18, 0x02	; 2
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	33 c0       	rjmp	.+102    	; 0x227e <setIpFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2218:	81 e0       	ldi	r24, 0x01	; 1
    221a:	be 01       	movw	r22, r28
    221c:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2220:	3b 01       	movw	r6, r22
    2222:	4c 01       	movw	r8, r24
    2224:	82 e0       	ldi	r24, 0x02	; 2
    2226:	be 01       	movw	r22, r28
    2228:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    222c:	7b 01       	movw	r14, r22
    222e:	8c 01       	movw	r16, r24
    2230:	83 e0       	ldi	r24, 0x03	; 3
    2232:	be 01       	movw	r22, r28
    2234:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2238:	5b 01       	movw	r10, r22
    223a:	6c 01       	movw	r12, r24
    223c:	84 e0       	ldi	r24, 0x04	; 4
    223e:	be 01       	movw	r22, r28
    2240:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
  
  ipSetConfigIp(ip);
    2244:	10 2f       	mov	r17, r16
    2246:	0f 2d       	mov	r16, r15
    2248:	fe 2c       	mov	r15, r14
    224a:	ee 24       	eor	r14, r14
    224c:	65 01       	movw	r12, r10
    224e:	bb 24       	eor	r11, r11
    2250:	aa 24       	eor	r10, r10
    2252:	ea 0c       	add	r14, r10
    2254:	fb 1c       	adc	r15, r11
    2256:	0c 1d       	adc	r16, r12
    2258:	1d 1d       	adc	r17, r13
    225a:	e6 0c       	add	r14, r6
    225c:	f7 1c       	adc	r15, r7
    225e:	08 1d       	adc	r16, r8
    2260:	19 1d       	adc	r17, r9
    2262:	96 2f       	mov	r25, r22
    2264:	88 27       	eor	r24, r24
    2266:	77 27       	eor	r23, r23
    2268:	66 27       	eor	r22, r22
    226a:	e6 0e       	add	r14, r22
    226c:	f7 1e       	adc	r15, r23
    226e:	08 1f       	adc	r16, r24
    2270:	19 1f       	adc	r17, r25
    2272:	c8 01       	movw	r24, r16
    2274:	b7 01       	movw	r22, r14
    2276:	0e 94 f6 31 	call	0x63ec	; 0x63ec <ipSetConfigIp>
    227a:	20 e0       	ldi	r18, 0x00	; 0
    227c:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    227e:	c9 01       	movw	r24, r18
    2280:	df 91       	pop	r29
    2282:	cf 91       	pop	r28
    2284:	1f 91       	pop	r17
    2286:	0f 91       	pop	r16
    2288:	ff 90       	pop	r15
    228a:	ef 90       	pop	r14
    228c:	df 90       	pop	r13
    228e:	cf 90       	pop	r12
    2290:	bf 90       	pop	r11
    2292:	af 90       	pop	r10
    2294:	9f 90       	pop	r9
    2296:	8f 90       	pop	r8
    2298:	7f 90       	pop	r7
    229a:	6f 90       	pop	r6
    229c:	08 95       	ret

0000229e <czytajAC_Function>:
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}

static cliExRes_t czytajAC_Function(cmdState_t *state)
{
    229e:	ff 92       	push	r15
    22a0:	0f 93       	push	r16
    22a2:	1f 93       	push	r17
    22a4:	8c 01       	movw	r16, r24
  uint8_t nrWejscia = cmdlineGetArgInt(1, state);
    22a6:	81 e0       	ldi	r24, 0x01	; 1
    22a8:	b8 01       	movw	r22, r16
    22aa:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    22ae:	f6 2e       	mov	r15, r22
  uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
    22b0:	86 2f       	mov	r24, r22
    22b2:	0e 94 5e 29 	call	0x52bc	; 0x52bc <MCP3008_getSampleSingle>
  fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
    22b6:	2d b7       	in	r18, 0x3d	; 61
    22b8:	3e b7       	in	r19, 0x3e	; 62
    22ba:	28 50       	subi	r18, 0x08	; 8
    22bc:	30 40       	sbci	r19, 0x00	; 0
    22be:	0f b6       	in	r0, 0x3f	; 63
    22c0:	f8 94       	cli
    22c2:	3e bf       	out	0x3e, r19	; 62
    22c4:	0f be       	out	0x3f, r0	; 63
    22c6:	2d bf       	out	0x3d, r18	; 61
    22c8:	ed b7       	in	r30, 0x3d	; 61
    22ca:	fe b7       	in	r31, 0x3e	; 62
    22cc:	31 96       	adiw	r30, 0x01	; 1
    22ce:	d8 01       	movw	r26, r16
    22d0:	5a 96       	adiw	r26, 0x1a	; 26
    22d2:	2d 91       	ld	r18, X+
    22d4:	3c 91       	ld	r19, X
    22d6:	5b 97       	sbiw	r26, 0x1b	; 27
    22d8:	ad b7       	in	r26, 0x3d	; 61
    22da:	be b7       	in	r27, 0x3e	; 62
    22dc:	12 96       	adiw	r26, 0x02	; 2
    22de:	3c 93       	st	X, r19
    22e0:	2e 93       	st	-X, r18
    22e2:	11 97       	sbiw	r26, 0x01	; 1
    22e4:	24 e6       	ldi	r18, 0x64	; 100
    22e6:	3a e0       	ldi	r19, 0x0A	; 10
    22e8:	33 83       	std	Z+3, r19	; 0x03
    22ea:	22 83       	std	Z+2, r18	; 0x02
    22ec:	f4 82       	std	Z+4, r15	; 0x04
    22ee:	15 82       	std	Z+5, r1	; 0x05
    22f0:	97 83       	std	Z+7, r25	; 0x07
    22f2:	86 83       	std	Z+6, r24	; 0x06
    22f4:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    22f8:	2d b7       	in	r18, 0x3d	; 61
    22fa:	3e b7       	in	r19, 0x3e	; 62
    22fc:	28 5f       	subi	r18, 0xF8	; 248
    22fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2300:	0f b6       	in	r0, 0x3f	; 63
    2302:	f8 94       	cli
    2304:	3e bf       	out	0x3e, r19	; 62
    2306:	0f be       	out	0x3f, r0	; 63
    2308:	2d bf       	out	0x3d, r18	; 61
  return OK_SILENT;
}
    230a:	80 e0       	ldi	r24, 0x00	; 0
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	1f 91       	pop	r17
    2310:	0f 91       	pop	r16
    2312:	ff 90       	pop	r15
    2314:	08 95       	ret

00002316 <printErrorInfo>:
{
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
}

void printErrorInfo(cmdState_t *state)
{
    2316:	cf 93       	push	r28
    2318:	df 93       	push	r29
    231a:	ec 01       	movw	r28, r24
  if (state->errno != 0)
    231c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    231e:	88 23       	and	r24, r24
    2320:	71 f1       	breq	.+92     	; 0x237e <printErrorInfo+0x68>
  {
    fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->err1, state->err2);
    2322:	e8 2f       	mov	r30, r24
    2324:	f0 e0       	ldi	r31, 0x00	; 0
    2326:	ee 0f       	add	r30, r30
    2328:	ff 1f       	adc	r31, r31
    232a:	ee 5c       	subi	r30, 0xCE	; 206
    232c:	f6 4f       	sbci	r31, 0xF6	; 246
    232e:	25 91       	lpm	r18, Z+
    2330:	34 91       	lpm	r19, Z+
    2332:	8d b7       	in	r24, 0x3d	; 61
    2334:	9e b7       	in	r25, 0x3e	; 62
    2336:	08 97       	sbiw	r24, 0x08	; 8
    2338:	0f b6       	in	r0, 0x3f	; 63
    233a:	f8 94       	cli
    233c:	9e bf       	out	0x3e, r25	; 62
    233e:	0f be       	out	0x3f, r0	; 63
    2340:	8d bf       	out	0x3d, r24	; 61
    2342:	ed b7       	in	r30, 0x3d	; 61
    2344:	fe b7       	in	r31, 0x3e	; 62
    2346:	31 96       	adiw	r30, 0x01	; 1
    2348:	8a 8d       	ldd	r24, Y+26	; 0x1a
    234a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    234c:	ad b7       	in	r26, 0x3d	; 61
    234e:	be b7       	in	r27, 0x3e	; 62
    2350:	12 96       	adiw	r26, 0x02	; 2
    2352:	9c 93       	st	X, r25
    2354:	8e 93       	st	-X, r24
    2356:	11 97       	sbiw	r26, 0x01	; 1
    2358:	33 83       	std	Z+3, r19	; 0x03
    235a:	22 83       	std	Z+2, r18	; 0x02
    235c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    235e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2360:	95 83       	std	Z+5, r25	; 0x05
    2362:	84 83       	std	Z+4, r24	; 0x04
    2364:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2366:	86 83       	std	Z+6, r24	; 0x06
    2368:	17 82       	std	Z+7, r1	; 0x07
    236a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    236e:	8d b7       	in	r24, 0x3d	; 61
    2370:	9e b7       	in	r25, 0x3e	; 62
    2372:	08 96       	adiw	r24, 0x08	; 8
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	f8 94       	cli
    2378:	9e bf       	out	0x3e, r25	; 62
    237a:	0f be       	out	0x3f, r0	; 63
    237c:	8d bf       	out	0x3d, r24	; 61
  }
  state->errno = 0;
    237e:	1c 8e       	std	Y+28, r1	; 0x1c
  state->err1 = 0;
    2380:	1e 8e       	std	Y+30, r1	; 0x1e
    2382:	1d 8e       	std	Y+29, r1	; 0x1d
  state->err2 = 0;
    2384:	1f 8e       	std	Y+31, r1	; 0x1f
}
    2386:	df 91       	pop	r29
    2388:	cf 91       	pop	r28
    238a:	08 95       	ret

0000238c <setTimeFunction>:
  return SYNTAX_ERROR;
}


static cliExRes_t setTimeFunction(cmdState_t *state)
{
    238c:	ef 92       	push	r14
    238e:	ff 92       	push	r15
    2390:	0f 93       	push	r16
    2392:	1f 93       	push	r17
    2394:	8c 01       	movw	r16, r24
  uint8_t godzina =  cmdlineGetArgInt(1, state);
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	b8 01       	movw	r22, r16
    239a:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    239e:	f6 2e       	mov	r15, r22
  uint8_t minuta  =  cmdlineGetArgInt(2, state);
    23a0:	82 e0       	ldi	r24, 0x02	; 2
    23a2:	b8 01       	movw	r22, r16
    23a4:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    23a8:	e6 2e       	mov	r14, r22
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
    23aa:	83 e0       	ldi	r24, 0x03	; 3
    23ac:	b8 01       	movw	r22, r16
    23ae:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    23b2:	16 2f       	mov	r17, r22
  
  ds1305start();
    23b4:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <ds1305start>

  uint8_t cDzies = godzina/10;
    23b8:	8f 2d       	mov	r24, r15
    23ba:	6a e0       	ldi	r22, 0x0A	; 10
    23bc:	0e 94 d2 56 	call	0xada4	; 0xada4 <__udivmodqi4>
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
    23c0:	28 2f       	mov	r18, r24
    23c2:	23 70       	andi	r18, 0x03	; 3
    23c4:	a5 eb       	ldi	r26, 0xB5	; 181
    23c6:	be e0       	ldi	r27, 0x0E	; 14
    23c8:	22 95       	swap	r18
    23ca:	20 7f       	andi	r18, 0xF0	; 240
    23cc:	90 91 b5 0e 	lds	r25, 0x0EB5
    23d0:	9f 7c       	andi	r25, 0xCF	; 207
    23d2:	92 2b       	or	r25, r18
    23d4:	90 93 b5 0e 	sts	0x0EB5, r25
  czasRtc.hours.syst24.cJedn  = cJedn;
    23d8:	46 ef       	ldi	r20, 0xF6	; 246
    23da:	5f ef       	ldi	r21, 0xFF	; 255
    23dc:	84 9f       	mul	r24, r20
    23de:	80 2d       	mov	r24, r0
    23e0:	11 24       	eor	r1, r1
    23e2:	8f 0d       	add	r24, r15
    23e4:	8f 70       	andi	r24, 0x0F	; 15
    23e6:	90 91 b5 0e 	lds	r25, 0x0EB5
    23ea:	90 7f       	andi	r25, 0xF0	; 240
    23ec:	98 2b       	or	r25, r24
    23ee:	90 93 b5 0e 	sts	0x0EB5, r25
  
  cDzies = minuta/10;
    23f2:	8e 2d       	mov	r24, r14
    23f4:	0e 94 d2 56 	call	0xada4	; 0xada4 <__udivmodqi4>
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
    23f8:	28 2f       	mov	r18, r24
    23fa:	27 70       	andi	r18, 0x07	; 7
    23fc:	fd 01       	movw	r30, r26
    23fe:	22 95       	swap	r18
    2400:	20 7f       	andi	r18, 0xF0	; 240
    2402:	92 91       	ld	r25, -Z
    2404:	9f 78       	andi	r25, 0x8F	; 143
    2406:	92 2b       	or	r25, r18
    2408:	90 83       	st	Z, r25
  czasRtc.minutes.cJedn  = cJedn;
    240a:	84 9f       	mul	r24, r20
    240c:	80 2d       	mov	r24, r0
    240e:	11 24       	eor	r1, r1
    2410:	8e 0d       	add	r24, r14
    2412:	8f 70       	andi	r24, 0x0F	; 15
    2414:	90 81       	ld	r25, Z
    2416:	90 7f       	andi	r25, 0xF0	; 240
    2418:	98 2b       	or	r25, r24
    241a:	90 83       	st	Z, r25
  
  cDzies = sekunda/10;
    241c:	81 2f       	mov	r24, r17
    241e:	0e 94 d2 56 	call	0xada4	; 0xada4 <__udivmodqi4>
  cJedn  = sekunda - cDzies * 10;
  czasRtc.seconds.cDzies = cDzies;
    2422:	28 2f       	mov	r18, r24
    2424:	27 70       	andi	r18, 0x07	; 7
    2426:	12 97       	sbiw	r26, 0x02	; 2
    2428:	22 95       	swap	r18
    242a:	20 7f       	andi	r18, 0xF0	; 240
    242c:	9c 91       	ld	r25, X
    242e:	9f 78       	andi	r25, 0x8F	; 143
    2430:	92 2b       	or	r25, r18
    2432:	9c 93       	st	X, r25
  czasRtc.seconds.cJedn  = cJedn;
    2434:	84 9f       	mul	r24, r20
    2436:	80 2d       	mov	r24, r0
    2438:	11 24       	eor	r1, r1
    243a:	81 0f       	add	r24, r17
    243c:	8f 70       	andi	r24, 0x0F	; 15
    243e:	9c 91       	ld	r25, X
    2440:	90 7f       	andi	r25, 0xF0	; 240
    2442:	98 2b       	or	r25, r24
    2444:	9c 93       	st	X, r25
  
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
    2446:	cd 01       	movw	r24, r26
    2448:	0e 94 12 28 	call	0x5024	; 0x5024 <setTimeDecoded>
  return OK_SILENT;
}
    244c:	80 e0       	ldi	r24, 0x00	; 0
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	1f 91       	pop	r17
    2452:	0f 91       	pop	r16
    2454:	ff 90       	pop	r15
    2456:	ef 90       	pop	r14
    2458:	08 95       	ret

0000245a <ustawPortRezystor>:
  MPC23s17SetPortB(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
    245a:	fc 01       	movw	r30, r24
  if (state->argc < 1)
    245c:	81 8d       	ldd	r24, Z+25	; 0x19
    245e:	88 23       	and	r24, r24
    2460:	19 f4       	brne	.+6      	; 0x2468 <ustawPortRezystor+0xe>
    2462:	22 e0       	ldi	r18, 0x02	; 2
    2464:	30 e0       	ldi	r19, 0x00	; 0
    2466:	09 c0       	rjmp	.+18     	; 0x247a <ustawPortRezystor+0x20>
    return SYNTAX_ERROR;

  uint8_t wartosc = cmdlineGetArgInt(1, state);
    2468:	81 e0       	ldi	r24, 0x01	; 1
    246a:	bf 01       	movw	r22, r30
    246c:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2470:	86 2f       	mov	r24, r22
  
  MCP4150_setValue(wartosc);
    2472:	0e 94 aa 29 	call	0x5354	; 0x5354 <MCP4150_setValue>
    2476:	20 e0       	ldi	r18, 0x00	; 0
    2478:	30 e0       	ldi	r19, 0x00	; 0
  
  return OK_SILENT;
}
    247a:	c9 01       	movw	r24, r18
    247c:	08 95       	ret

0000247e <ustawPortExtBFunction>:
  MPC23s17SetPortA(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
{
    247e:	1f 93       	push	r17
    2480:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    2482:	81 e0       	ldi	r24, 0x01	; 1
    2484:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2488:	16 2f       	mov	r17, r22
  MPC23s17SetDirB(0x00, 0);
    248a:	80 e0       	ldi	r24, 0x00	; 0
    248c:	60 e0       	ldi	r22, 0x00	; 0
    248e:	0e 94 26 29 	call	0x524c	; 0x524c <MPC23s17SetDirB>
  MPC23s17SetPortB(wyjscie, 0);
    2492:	81 2f       	mov	r24, r17
    2494:	60 e0       	ldi	r22, 0x00	; 0
    2496:	0e 94 b0 28 	call	0x5160	; 0x5160 <MPC23s17SetPortB>
  return OK_SILENT;
}
    249a:	80 e0       	ldi	r24, 0x00	; 0
    249c:	90 e0       	ldi	r25, 0x00	; 0
    249e:	1f 91       	pop	r17
    24a0:	08 95       	ret

000024a2 <ustawPortExtAFunction>:
  
  return ERROR_SILENT;
}

static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
{
    24a2:	1f 93       	push	r17
    24a4:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    24a6:	81 e0       	ldi	r24, 0x01	; 1
    24a8:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    24ac:	16 2f       	mov	r17, r22
  MPC23s17SetDirA(0x00, 0);
    24ae:	80 e0       	ldi	r24, 0x00	; 0
    24b0:	60 e0       	ldi	r22, 0x00	; 0
    24b2:	0e 94 41 29 	call	0x5282	; 0x5282 <MPC23s17SetDirA>
  MPC23s17SetPortA(wyjscie, 0);
    24b6:	81 2f       	mov	r24, r17
    24b8:	60 e0       	ldi	r22, 0x00	; 0
    24ba:	0e 94 08 29 	call	0x5210	; 0x5210 <MPC23s17SetPortA>
  return OK_SILENT;
}
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	1f 91       	pop	r17
    24c4:	08 95       	ret

000024c6 <curtainDownFunction>:
  cmdPrintHelp(state);
  return OK_SILENT;
}

static cliExRes_t curtainDownFunction(cmdState_t *state)
{
    24c6:	ff 92       	push	r15
    24c8:	0f 93       	push	r16
    24ca:	1f 93       	push	r17
    24cc:	cf 93       	push	r28
    24ce:	df 93       	push	r29
    24d0:	ec 01       	movw	r28, r24
  uint8_t nrRolety;
  uint8_t nrSterownika;
  uint8_t wartosc;
  
  nrSterownika = cmdlineGetArgInt(1, state);
    24d2:	81 e0       	ldi	r24, 0x01	; 1
    24d4:	be 01       	movw	r22, r28
    24d6:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    24da:	f6 2e       	mov	r15, r22
  nrRolety = cmdlineGetArgInt(2, state);
    24dc:	82 e0       	ldi	r24, 0x02	; 2
    24de:	be 01       	movw	r22, r28
    24e0:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    24e4:	16 2f       	mov	r17, r22
  nrRolety &= 0x01;
    24e6:	11 70       	andi	r17, 0x01	; 1
  wartosc = cmdlineGetArgInt(3, state);
    24e8:	83 e0       	ldi	r24, 0x03	; 3
    24ea:	be 01       	movw	r22, r28
    24ec:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    24f0:	06 2f       	mov	r16, r22

  fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
    24f2:	2d b7       	in	r18, 0x3d	; 61
    24f4:	3e b7       	in	r19, 0x3e	; 62
    24f6:	28 50       	subi	r18, 0x08	; 8
    24f8:	30 40       	sbci	r19, 0x00	; 0
    24fa:	0f b6       	in	r0, 0x3f	; 63
    24fc:	f8 94       	cli
    24fe:	3e bf       	out	0x3e, r19	; 62
    2500:	0f be       	out	0x3f, r0	; 63
    2502:	2d bf       	out	0x3d, r18	; 61
    2504:	ed b7       	in	r30, 0x3d	; 61
    2506:	fe b7       	in	r31, 0x3e	; 62
    2508:	31 96       	adiw	r30, 0x01	; 1
    250a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    250c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    250e:	ad b7       	in	r26, 0x3d	; 61
    2510:	be b7       	in	r27, 0x3e	; 62
    2512:	12 96       	adiw	r26, 0x02	; 2
    2514:	9c 93       	st	X, r25
    2516:	8e 93       	st	-X, r24
    2518:	11 97       	sbiw	r26, 0x01	; 1
    251a:	82 ed       	ldi	r24, 0xD2	; 210
    251c:	93 e0       	ldi	r25, 0x03	; 3
    251e:	93 83       	std	Z+3, r25	; 0x03
    2520:	82 83       	std	Z+2, r24	; 0x02
    2522:	f4 82       	std	Z+4, r15	; 0x04
    2524:	15 82       	std	Z+5, r1	; 0x05
    2526:	81 2f       	mov	r24, r17
    2528:	90 e0       	ldi	r25, 0x00	; 0
    252a:	01 96       	adiw	r24, 0x01	; 1
    252c:	97 83       	std	Z+7, r25	; 0x07
    252e:	86 83       	std	Z+6, r24	; 0x06
    2530:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>

  if ((wartosc > 0) && (wartosc <=100))
    2534:	80 2f       	mov	r24, r16
    2536:	81 50       	subi	r24, 0x01	; 1
    2538:	2d b7       	in	r18, 0x3d	; 61
    253a:	3e b7       	in	r19, 0x3e	; 62
    253c:	28 5f       	subi	r18, 0xF8	; 248
    253e:	3f 4f       	sbci	r19, 0xFF	; 255
    2540:	0f b6       	in	r0, 0x3f	; 63
    2542:	f8 94       	cli
    2544:	3e bf       	out	0x3e, r19	; 62
    2546:	0f be       	out	0x3f, r0	; 63
    2548:	2d bf       	out	0x3d, r18	; 61
    254a:	84 36       	cpi	r24, 0x64	; 100
    254c:	f8 f4       	brcc	.+62     	; 0x258c <curtainDownFunction+0xc6>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    254e:	00 d0       	rcall	.+0      	; 0x2550 <curtainDownFunction+0x8a>
    2550:	00 d0       	rcall	.+0      	; 0x2552 <curtainDownFunction+0x8c>
    2552:	00 d0       	rcall	.+0      	; 0x2554 <curtainDownFunction+0x8e>
    2554:	ed b7       	in	r30, 0x3d	; 61
    2556:	fe b7       	in	r31, 0x3e	; 62
    2558:	31 96       	adiw	r30, 0x01	; 1
    255a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    255c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    255e:	ad b7       	in	r26, 0x3d	; 61
    2560:	be b7       	in	r27, 0x3e	; 62
    2562:	12 96       	adiw	r26, 0x02	; 2
    2564:	9c 93       	st	X, r25
    2566:	8e 93       	st	-X, r24
    2568:	11 97       	sbiw	r26, 0x01	; 1
    256a:	85 e0       	ldi	r24, 0x05	; 5
    256c:	94 e0       	ldi	r25, 0x04	; 4
    256e:	93 83       	std	Z+3, r25	; 0x03
    2570:	82 83       	std	Z+2, r24	; 0x02
    2572:	04 83       	std	Z+4, r16	; 0x04
    2574:	15 82       	std	Z+5, r1	; 0x05
    2576:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    257a:	2d b7       	in	r18, 0x3d	; 61
    257c:	3e b7       	in	r19, 0x3e	; 62
    257e:	2a 5f       	subi	r18, 0xFA	; 250
    2580:	3f 4f       	sbci	r19, 0xFF	; 255
    2582:	0f b6       	in	r0, 0x3f	; 63
    2584:	f8 94       	cli
    2586:	3e bf       	out	0x3e, r19	; 62
    2588:	0f be       	out	0x3f, r0	; 63
    258a:	2d bf       	out	0x3d, r18	; 61

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
    258c:	8f 2d       	mov	r24, r15
    258e:	61 2f       	mov	r22, r17
    2590:	40 2f       	mov	r20, r16
    2592:	0e 94 8e 40 	call	0x811c	; 0x811c <rs485curtainDown>
  
  if (result == 0)
    2596:	88 23       	and	r24, r24
    2598:	19 f0       	breq	.+6      	; 0x25a0 <curtainDownFunction+0xda>
    259a:	23 e0       	ldi	r18, 0x03	; 3
    259c:	30 e0       	ldi	r19, 0x00	; 0
    259e:	02 c0       	rjmp	.+4      	; 0x25a4 <curtainDownFunction+0xde>
    25a0:	21 e0       	ldi	r18, 0x01	; 1
    25a2:	30 e0       	ldi	r19, 0x00	; 0
    return OK_INFORM;
  
  return ERROR_SILENT;
}
    25a4:	c9 01       	movw	r24, r18
    25a6:	df 91       	pop	r29
    25a8:	cf 91       	pop	r28
    25aa:	1f 91       	pop	r17
    25ac:	0f 91       	pop	r16
    25ae:	ff 90       	pop	r15
    25b0:	08 95       	ret

000025b2 <curtainUpFunction>:

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
    25b2:	ff 92       	push	r15
    25b4:	0f 93       	push	r16
    25b6:	1f 93       	push	r17
    25b8:	cf 93       	push	r28
    25ba:	df 93       	push	r29
    25bc:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    25be:	89 8d       	ldd	r24, Y+25	; 0x19
    25c0:	82 30       	cpi	r24, 0x02	; 2
    25c2:	18 f4       	brcc	.+6      	; 0x25ca <curtainUpFunction+0x18>
    25c4:	22 e0       	ldi	r18, 0x02	; 2
    25c6:	30 e0       	ldi	r19, 0x00	; 0
    25c8:	6f c0       	rjmp	.+222    	; 0x26a8 <curtainUpFunction+0xf6>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
    25ca:	81 e0       	ldi	r24, 0x01	; 1
    25cc:	be 01       	movw	r22, r28
    25ce:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    25d2:	f6 2e       	mov	r15, r22
    25d4:	2f e3       	ldi	r18, 0x3F	; 63
    25d6:	f2 22       	and	r15, r18
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
    25d8:	82 e0       	ldi	r24, 0x02	; 2
    25da:	be 01       	movw	r22, r28
    25dc:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    25e0:	06 2f       	mov	r16, r22
    25e2:	01 70       	andi	r16, 0x01	; 1
  uint8_t wartosc = 255;
  if (state->argc > 2)
    25e4:	89 8d       	ldd	r24, Y+25	; 0x19
    25e6:	83 30       	cpi	r24, 0x03	; 3
    25e8:	10 f4       	brcc	.+4      	; 0x25ee <curtainUpFunction+0x3c>
    25ea:	1f ef       	ldi	r17, 0xFF	; 255
    25ec:	05 c0       	rjmp	.+10     	; 0x25f8 <curtainUpFunction+0x46>
    wartosc = cmdlineGetArgInt(3, state);
    25ee:	83 e0       	ldi	r24, 0x03	; 3
    25f0:	be 01       	movw	r22, r28
    25f2:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    25f6:	16 2f       	mov	r17, r22

  fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
    25f8:	8d b7       	in	r24, 0x3d	; 61
    25fa:	9e b7       	in	r25, 0x3e	; 62
    25fc:	08 97       	sbiw	r24, 0x08	; 8
    25fe:	0f b6       	in	r0, 0x3f	; 63
    2600:	f8 94       	cli
    2602:	9e bf       	out	0x3e, r25	; 62
    2604:	0f be       	out	0x3f, r0	; 63
    2606:	8d bf       	out	0x3d, r24	; 61
    2608:	ed b7       	in	r30, 0x3d	; 61
    260a:	fe b7       	in	r31, 0x3e	; 62
    260c:	31 96       	adiw	r30, 0x01	; 1
    260e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2610:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2612:	ad b7       	in	r26, 0x3d	; 61
    2614:	be b7       	in	r27, 0x3e	; 62
    2616:	12 96       	adiw	r26, 0x02	; 2
    2618:	9c 93       	st	X, r25
    261a:	8e 93       	st	-X, r24
    261c:	11 97       	sbiw	r26, 0x01	; 1
    261e:	8f e9       	ldi	r24, 0x9F	; 159
    2620:	93 e0       	ldi	r25, 0x03	; 3
    2622:	93 83       	std	Z+3, r25	; 0x03
    2624:	82 83       	std	Z+2, r24	; 0x02
    2626:	f4 82       	std	Z+4, r15	; 0x04
    2628:	15 82       	std	Z+5, r1	; 0x05
    262a:	80 2f       	mov	r24, r16
    262c:	90 e0       	ldi	r25, 0x00	; 0
    262e:	01 96       	adiw	r24, 0x01	; 1
    2630:	97 83       	std	Z+7, r25	; 0x07
    2632:	86 83       	std	Z+6, r24	; 0x06
    2634:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  if ((wartosc > 0) && (wartosc <=100))
    2638:	81 2f       	mov	r24, r17
    263a:	81 50       	subi	r24, 0x01	; 1
    263c:	2d b7       	in	r18, 0x3d	; 61
    263e:	3e b7       	in	r19, 0x3e	; 62
    2640:	28 5f       	subi	r18, 0xF8	; 248
    2642:	3f 4f       	sbci	r19, 0xFF	; 255
    2644:	0f b6       	in	r0, 0x3f	; 63
    2646:	f8 94       	cli
    2648:	3e bf       	out	0x3e, r19	; 62
    264a:	0f be       	out	0x3f, r0	; 63
    264c:	2d bf       	out	0x3d, r18	; 61
    264e:	84 36       	cpi	r24, 0x64	; 100
    2650:	f8 f4       	brcc	.+62     	; 0x2690 <curtainUpFunction+0xde>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    2652:	00 d0       	rcall	.+0      	; 0x2654 <curtainUpFunction+0xa2>
    2654:	00 d0       	rcall	.+0      	; 0x2656 <curtainUpFunction+0xa4>
    2656:	00 d0       	rcall	.+0      	; 0x2658 <curtainUpFunction+0xa6>
    2658:	ed b7       	in	r30, 0x3d	; 61
    265a:	fe b7       	in	r31, 0x3e	; 62
    265c:	31 96       	adiw	r30, 0x01	; 1
    265e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2660:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2662:	ad b7       	in	r26, 0x3d	; 61
    2664:	be b7       	in	r27, 0x3e	; 62
    2666:	12 96       	adiw	r26, 0x02	; 2
    2668:	9c 93       	st	X, r25
    266a:	8e 93       	st	-X, r24
    266c:	11 97       	sbiw	r26, 0x01	; 1
    266e:	85 e0       	ldi	r24, 0x05	; 5
    2670:	94 e0       	ldi	r25, 0x04	; 4
    2672:	93 83       	std	Z+3, r25	; 0x03
    2674:	82 83       	std	Z+2, r24	; 0x02
    2676:	14 83       	std	Z+4, r17	; 0x04
    2678:	15 82       	std	Z+5, r1	; 0x05
    267a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    267e:	2d b7       	in	r18, 0x3d	; 61
    2680:	3e b7       	in	r19, 0x3e	; 62
    2682:	2a 5f       	subi	r18, 0xFA	; 250
    2684:	3f 4f       	sbci	r19, 0xFF	; 255
    2686:	0f b6       	in	r0, 0x3f	; 63
    2688:	f8 94       	cli
    268a:	3e bf       	out	0x3e, r19	; 62
    268c:	0f be       	out	0x3f, r0	; 63
    268e:	2d bf       	out	0x3d, r18	; 61

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
    2690:	8f 2d       	mov	r24, r15
    2692:	60 2f       	mov	r22, r16
    2694:	41 2f       	mov	r20, r17
    2696:	0e 94 ca 3f 	call	0x7f94	; 0x7f94 <rs485curtainUp>
  
  if (result == 0)
    269a:	88 23       	and	r24, r24
    269c:	19 f0       	breq	.+6      	; 0x26a4 <curtainUpFunction+0xf2>
    269e:	23 e0       	ldi	r18, 0x03	; 3
    26a0:	30 e0       	ldi	r19, 0x00	; 0
    26a2:	02 c0       	rjmp	.+4      	; 0x26a8 <curtainUpFunction+0xf6>
    26a4:	21 e0       	ldi	r18, 0x01	; 1
    26a6:	30 e0       	ldi	r19, 0x00	; 0
    return OK_INFORM;
  
  return ERROR_SILENT;
}
    26a8:	c9 01       	movw	r24, r18
    26aa:	df 91       	pop	r29
    26ac:	cf 91       	pop	r28
    26ae:	1f 91       	pop	r17
    26b0:	0f 91       	pop	r16
    26b2:	ff 90       	pop	r15
    26b4:	08 95       	ret

000026b6 <goXmodemWyslijFunction>:

  return OK_SILENT;
}

static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
{
    26b6:	0f 93       	push	r16
    26b8:	1f 93       	push	r17
    26ba:	cf 93       	push	r28
    26bc:	df 93       	push	r29
    26be:	ec 01       	movw	r28, r24
  fprintf_P(state->myStdInOut, xwyslijStartStr);
    26c0:	00 d0       	rcall	.+0      	; 0x26c2 <goXmodemWyslijFunction+0xc>
    26c2:	00 d0       	rcall	.+0      	; 0x26c4 <goXmodemWyslijFunction+0xe>
    26c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    26c6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    26c8:	ad b7       	in	r26, 0x3d	; 61
    26ca:	be b7       	in	r27, 0x3e	; 62
    26cc:	12 96       	adiw	r26, 0x02	; 2
    26ce:	9c 93       	st	X, r25
    26d0:	8e 93       	st	-X, r24
    26d2:	11 97       	sbiw	r26, 0x01	; 1
    26d4:	82 e8       	ldi	r24, 0x82	; 130
    26d6:	93 e0       	ldi	r25, 0x03	; 3
    26d8:	14 96       	adiw	r26, 0x04	; 4
    26da:	9c 93       	st	X, r25
    26dc:	8e 93       	st	-X, r24
    26de:	13 97       	sbiw	r26, 0x03	; 3
    26e0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    26e4:	0f 90       	pop	r0
    26e6:	0f 90       	pop	r0
    26e8:	0f 90       	pop	r0
    26ea:	0f 90       	pop	r0
    26ec:	81 e0       	ldi	r24, 0x01	; 1
    26ee:	be 01       	movw	r22, r28
    26f0:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    26f4:	64 e6       	ldi	r22, 0x64	; 100
    26f6:	7f e0       	ldi	r23, 0x0F	; 15
    26f8:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <ramDyskOtworzPlik>
    26fc:	88 23       	and	r24, r24
    26fe:	19 f4       	brne	.+6      	; 0x2706 <goXmodemWyslijFunction+0x50>
    2700:	20 e0       	ldi	r18, 0x00	; 0
    2702:	30 e0       	ldi	r19, 0x00	; 0
    2704:	24 c0       	rjmp	.+72     	; 0x274e <goXmodemWyslijFunction+0x98>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2706:	0a 8d       	ldd	r16, Y+26	; 0x1a
    2708:	1b 8d       	ldd	r17, Y+27	; 0x1b
    270a:	81 e0       	ldi	r24, 0x01	; 1
    270c:	be 01       	movw	r22, r28
    270e:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2712:	00 d0       	rcall	.+0      	; 0x2714 <goXmodemWyslijFunction+0x5e>
    2714:	00 d0       	rcall	.+0      	; 0x2716 <goXmodemWyslijFunction+0x60>
    2716:	00 d0       	rcall	.+0      	; 0x2718 <goXmodemWyslijFunction+0x62>
    2718:	ed b7       	in	r30, 0x3d	; 61
    271a:	fe b7       	in	r31, 0x3e	; 62
    271c:	31 96       	adiw	r30, 0x01	; 1
    271e:	ad b7       	in	r26, 0x3d	; 61
    2720:	be b7       	in	r27, 0x3e	; 62
    2722:	12 96       	adiw	r26, 0x02	; 2
    2724:	1c 93       	st	X, r17
    2726:	0e 93       	st	-X, r16
    2728:	11 97       	sbiw	r26, 0x01	; 1
    272a:	22 e8       	ldi	r18, 0x82	; 130
    272c:	31 e0       	ldi	r19, 0x01	; 1
    272e:	33 83       	std	Z+3, r19	; 0x03
    2730:	22 83       	std	Z+2, r18	; 0x02
    2732:	95 83       	std	Z+5, r25	; 0x05
    2734:	84 83       	std	Z+4, r24	; 0x04
    2736:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    273a:	24 e0       	ldi	r18, 0x04	; 4
    273c:	30 e0       	ldi	r19, 0x00	; 0
    273e:	ed b7       	in	r30, 0x3d	; 61
    2740:	fe b7       	in	r31, 0x3e	; 62
    2742:	36 96       	adiw	r30, 0x06	; 6
    2744:	0f b6       	in	r0, 0x3f	; 63
    2746:	f8 94       	cli
    2748:	fe bf       	out	0x3e, r31	; 62
    274a:	0f be       	out	0x3f, r0	; 63
    274c:	ed bf       	out	0x3d, r30	; 61
    return ERROR_INFORM;
  }
  return OK_SILENT;
}
    274e:	c9 01       	movw	r24, r18
    2750:	df 91       	pop	r29
    2752:	cf 91       	pop	r28
    2754:	1f 91       	pop	r17
    2756:	0f 91       	pop	r16
    2758:	08 95       	ret

0000275a <editRamFileFunction>:
  ramDyskDir(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t editRamFileFunction(cmdState_t *state)
{
    275a:	ef 92       	push	r14
    275c:	ff 92       	push	r15
    275e:	0f 93       	push	r16
    2760:	1f 93       	push	r17
    2762:	df 93       	push	r29
    2764:	cf 93       	push	r28
    2766:	0f 92       	push	r0
    2768:	cd b7       	in	r28, 0x3d	; 61
    276a:	de b7       	in	r29, 0x3e	; 62
    276c:	7c 01       	movw	r14, r24
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	b7 01       	movw	r22, r14
    2772:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2776:	64 e6       	ldi	r22, 0x64	; 100
    2778:	7f e0       	ldi	r23, 0x0F	; 15
    277a:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <ramDyskOtworzPlik>
    277e:	88 23       	and	r24, r24
    2780:	41 f1       	breq	.+80     	; 0x27d2 <editRamFileFunction+0x78>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2782:	d7 01       	movw	r26, r14
    2784:	5a 96       	adiw	r26, 0x1a	; 26
    2786:	0d 91       	ld	r16, X+
    2788:	1c 91       	ld	r17, X
    278a:	5b 97       	sbiw	r26, 0x1b	; 27
    278c:	81 e0       	ldi	r24, 0x01	; 1
    278e:	b7 01       	movw	r22, r14
    2790:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2794:	00 d0       	rcall	.+0      	; 0x2796 <editRamFileFunction+0x3c>
    2796:	00 d0       	rcall	.+0      	; 0x2798 <editRamFileFunction+0x3e>
    2798:	00 d0       	rcall	.+0      	; 0x279a <editRamFileFunction+0x40>
    279a:	ed b7       	in	r30, 0x3d	; 61
    279c:	fe b7       	in	r31, 0x3e	; 62
    279e:	31 96       	adiw	r30, 0x01	; 1
    27a0:	ad b7       	in	r26, 0x3d	; 61
    27a2:	be b7       	in	r27, 0x3e	; 62
    27a4:	12 96       	adiw	r26, 0x02	; 2
    27a6:	1c 93       	st	X, r17
    27a8:	0e 93       	st	-X, r16
    27aa:	11 97       	sbiw	r26, 0x01	; 1
    27ac:	22 e8       	ldi	r18, 0x82	; 130
    27ae:	31 e0       	ldi	r19, 0x01	; 1
    27b0:	33 83       	std	Z+3, r19	; 0x03
    27b2:	22 83       	std	Z+2, r18	; 0x02
    27b4:	95 83       	std	Z+5, r25	; 0x05
    27b6:	84 83       	std	Z+4, r24	; 0x04
    27b8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    27bc:	24 e0       	ldi	r18, 0x04	; 4
    27be:	30 e0       	ldi	r19, 0x00	; 0
    27c0:	ed b7       	in	r30, 0x3d	; 61
    27c2:	fe b7       	in	r31, 0x3e	; 62
    27c4:	36 96       	adiw	r30, 0x06	; 6
    27c6:	0f b6       	in	r0, 0x3f	; 63
    27c8:	f8 94       	cli
    27ca:	fe bf       	out	0x3e, r31	; 62
    27cc:	0f be       	out	0x3f, r0	; 63
    27ce:	ed bf       	out	0x3d, r30	; 61
    27d0:	3b c0       	rjmp	.+118    	; 0x2848 <editRamFileFunction+0xee>
    return ERROR_INFORM;
  }
  ramDyskUstawWskaznikNaKoniec(&fdVty);
    27d2:	84 e6       	ldi	r24, 0x64	; 100
    27d4:	9f e0       	ldi	r25, 0x0F	; 15
    27d6:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <ramDyskUstawWskaznikNaKoniec>
  uint8_t znak = 0;
    27da:	19 82       	std	Y+1, r1	; 0x01
  fprintf_P(state->myStdInOut, editRamFileIntroStr);
    27dc:	00 d0       	rcall	.+0      	; 0x27de <editRamFileFunction+0x84>
    27de:	00 d0       	rcall	.+0      	; 0x27e0 <editRamFileFunction+0x86>
    27e0:	d7 01       	movw	r26, r14
    27e2:	5a 96       	adiw	r26, 0x1a	; 26
    27e4:	8d 91       	ld	r24, X+
    27e6:	9c 91       	ld	r25, X
    27e8:	5b 97       	sbiw	r26, 0x1b	; 27
    27ea:	ed b7       	in	r30, 0x3d	; 61
    27ec:	fe b7       	in	r31, 0x3e	; 62
    27ee:	92 83       	std	Z+2, r25	; 0x02
    27f0:	81 83       	std	Z+1, r24	; 0x01
    27f2:	88 e4       	ldi	r24, 0x48	; 72
    27f4:	93 e0       	ldi	r25, 0x03	; 3
    27f6:	94 83       	std	Z+4, r25	; 0x04
    27f8:	83 83       	std	Z+3, r24	; 0x03
    27fa:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    27fe:	0f 90       	pop	r0
    2800:	0f 90       	pop	r0
    2802:	0f 90       	pop	r0
    2804:	0f 90       	pop	r0
  while(1)
  {
    if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
    2806:	7e 01       	movw	r14, r28
    2808:	08 94       	sec
    280a:	e1 1c       	adc	r14, r1
    280c:	f1 1c       	adc	r15, r1
    280e:	80 91 ad 0e 	lds	r24, 0x0EAD
    2812:	90 91 ae 0e 	lds	r25, 0x0EAE
    2816:	b7 01       	movw	r22, r14
    2818:	4f ef       	ldi	r20, 0xFF	; 255
    281a:	5f ef       	ldi	r21, 0xFF	; 255
    281c:	20 e0       	ldi	r18, 0x00	; 0
    281e:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2822:	88 23       	and	r24, r24
    2824:	a1 f3       	breq	.-24     	; 0x280e <editRamFileFunction+0xb4>
      continue;

    if (znak == 0x03)                                       // ^C
    2826:	89 81       	ldd	r24, Y+1	; 0x01
    2828:	83 30       	cpi	r24, 0x03	; 3
    282a:	41 f0       	breq	.+16     	; 0x283c <editRamFileFunction+0xe2>
      break;

    uartVtySendByte(znak);                                  //Echo
    282c:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
    ramDyskZapiszBajtDoPliku(&fdVty, znak);
    2830:	84 e6       	ldi	r24, 0x64	; 100
    2832:	9f e0       	ldi	r25, 0x0F	; 15
    2834:	69 81       	ldd	r22, Y+1	; 0x01
    2836:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <ramDyskZapiszBajtDoPliku>
    283a:	e9 cf       	rjmp	.-46     	; 0x280e <editRamFileFunction+0xb4>
  }
  ramDyskZamknijPlik(&fdVty);
    283c:	84 e6       	ldi	r24, 0x64	; 100
    283e:	9f e0       	ldi	r25, 0x0F	; 15
    2840:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <ramDyskZamknijPlik>
    2844:	20 e0       	ldi	r18, 0x00	; 0
    2846:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2848:	c9 01       	movw	r24, r18
    284a:	0f 90       	pop	r0
    284c:	cf 91       	pop	r28
    284e:	df 91       	pop	r29
    2850:	1f 91       	pop	r17
    2852:	0f 91       	pop	r16
    2854:	ff 90       	pop	r15
    2856:	ef 90       	pop	r14
    2858:	08 95       	ret

0000285a <eraseRamFileFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
    285a:	cf 93       	push	r28
    285c:	df 93       	push	r29
    285e:	ec 01       	movw	r28, r24
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    2860:	81 e0       	ldi	r24, 0x01	; 1
    2862:	be 01       	movw	r22, r28
    2864:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2868:	0e 94 ca 20 	call	0x4194	; 0x4194 <ramDyskUsunPlik>
    286c:	88 23       	and	r24, r24
    286e:	19 f4       	brne	.+6      	; 0x2876 <eraseRamFileFunction+0x1c>
    2870:	21 e0       	ldi	r18, 0x01	; 1
    2872:	30 e0       	ldi	r19, 0x00	; 0
    2874:	05 c0       	rjmp	.+10     	; 0x2880 <eraseRamFileFunction+0x26>
    return OK_INFORM;

  printErrorInfo(state);
    2876:	ce 01       	movw	r24, r28
    2878:	0e 94 8b 11 	call	0x2316	; 0x2316 <printErrorInfo>
    287c:	24 e0       	ldi	r18, 0x04	; 4
    287e:	30 e0       	ldi	r19, 0x00	; 0
  return ERROR_INFORM;
}
    2880:	c9 01       	movw	r24, r18
    2882:	df 91       	pop	r29
    2884:	cf 91       	pop	r28
    2886:	08 95       	ret

00002888 <dodajRamPlikFunction>:

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
    2888:	cf 93       	push	r28
    288a:	df 93       	push	r29
    288c:	ec 01       	movw	r28, r24
  if (state->argc != 1)
    288e:	89 8d       	ldd	r24, Y+25	; 0x19
    2890:	81 30       	cpi	r24, 0x01	; 1
    2892:	19 f0       	breq	.+6      	; 0x289a <dodajRamPlikFunction+0x12>
    2894:	22 e0       	ldi	r18, 0x02	; 2
    2896:	30 e0       	ldi	r19, 0x00	; 0
    2898:	10 c0       	rjmp	.+32     	; 0x28ba <dodajRamPlikFunction+0x32>
    return SYNTAX_ERROR;

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
    289a:	81 e0       	ldi	r24, 0x01	; 1
    289c:	be 01       	movw	r22, r28
    289e:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    28a2:	0e 94 29 21 	call	0x4252	; 0x4252 <ramDyskUtworzPlik>
    28a6:	88 23       	and	r24, r24
    28a8:	19 f4       	brne	.+6      	; 0x28b0 <dodajRamPlikFunction+0x28>
    28aa:	21 e0       	ldi	r18, 0x01	; 1
    28ac:	30 e0       	ldi	r19, 0x00	; 0
    28ae:	05 c0       	rjmp	.+10     	; 0x28ba <dodajRamPlikFunction+0x32>
  {
    return OK_INFORM;
  }
  printErrorInfo(state);
    28b0:	ce 01       	movw	r24, r28
    28b2:	0e 94 8b 11 	call	0x2316	; 0x2316 <printErrorInfo>
    28b6:	24 e0       	ldi	r18, 0x04	; 4
    28b8:	30 e0       	ldi	r19, 0x00	; 0
  return ERROR_INFORM;
}
    28ba:	c9 01       	movw	r24, r18
    28bc:	df 91       	pop	r29
    28be:	cf 91       	pop	r28
    28c0:	08 95       	ret

000028c2 <rpingFunction>:
  
  return OK_SILENT;
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
    28c2:	1f 93       	push	r17
    28c4:	cf 93       	push	r28
    28c6:	df 93       	push	r29
    28c8:	ec 01       	movw	r28, r24
  if (state->argc < 1)
    28ca:	89 8d       	ldd	r24, Y+25	; 0x19
    28cc:	88 23       	and	r24, r24
    28ce:	19 f4       	brne	.+6      	; 0x28d6 <rpingFunction+0x14>
    28d0:	22 e0       	ldi	r18, 0x02	; 2
    28d2:	30 e0       	ldi	r19, 0x00	; 0
    28d4:	17 c0       	rjmp	.+46     	; 0x2904 <rpingFunction+0x42>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
    28d6:	81 e0       	ldi	r24, 0x01	; 1
    28d8:	be 01       	movw	r22, r28
    28da:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    28de:	16 2f       	mov	r17, r22
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    28e0:	86 2f       	mov	r24, r22
    28e2:	0e 94 17 45 	call	0x8a2e	; 0x8a2e <rs485ping>
    28e6:	8f 8f       	std	Y+31, r24	; 0x1f
    28e8:	88 23       	and	r24, r24
    28ea:	19 f4       	brne	.+6      	; 0x28f2 <rpingFunction+0x30>
    28ec:	21 e0       	ldi	r18, 0x01	; 1
    28ee:	30 e0       	ldi	r19, 0x00	; 0
    28f0:	09 c0       	rjmp	.+18     	; 0x2904 <rpingFunction+0x42>
    return OK_INFORM;

  state->errno = noRemoteDevice;
    28f2:	89 e0       	ldi	r24, 0x09	; 9
    28f4:	8c 8f       	std	Y+28, r24	; 0x1c
  state->err1 = nrSterownika;
    28f6:	1d 8f       	std	Y+29, r17	; 0x1d
    28f8:	1e 8e       	std	Y+30, r1	; 0x1e
  printErrorInfo(state);
    28fa:	ce 01       	movw	r24, r28
    28fc:	0e 94 8b 11 	call	0x2316	; 0x2316 <printErrorInfo>
    2900:	20 e0       	ldi	r18, 0x00	; 0
    2902:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2904:	c9 01       	movw	r24, r18
    2906:	df 91       	pop	r29
    2908:	cf 91       	pop	r28
    290a:	1f 91       	pop	r17
    290c:	08 95       	ret

0000290e <flashExModuleFunction>:
  return OK_SILENT;
}


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
    290e:	ff 92       	push	r15
    2910:	0f 93       	push	r16
    2912:	1f 93       	push	r17
    2914:	cf 93       	push	r28
    2916:	df 93       	push	r29
    2918:	ec 01       	movw	r28, r24
  if (state->argc != 2)
    291a:	89 8d       	ldd	r24, Y+25	; 0x19
    291c:	82 30       	cpi	r24, 0x02	; 2
    291e:	19 f0       	breq	.+6      	; 0x2926 <flashExModuleFunction+0x18>
    2920:	22 e0       	ldi	r18, 0x02	; 2
    2922:	30 e0       	ldi	r19, 0x00	; 0
    2924:	4e c0       	rjmp	.+156    	; 0x29c2 <flashExModuleFunction+0xb4>
    return SYNTAX_ERROR;
  
  uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
    2926:	81 e0       	ldi	r24, 0x01	; 1
    2928:	be 01       	movw	r22, r28
    292a:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    292e:	f6 2e       	mov	r15, r22
  char *nazwaPliku      = cmdlineGetArgStr(2, state);
    2930:	82 e0       	ldi	r24, 0x02	; 2
    2932:	be 01       	movw	r22, r28
    2934:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2938:	8c 01       	movw	r16, r24
  uint8_t  blad;
  
  // Sprawdzanie, czy moduł wykonawczy odpowiada
  if (rs485ping(nrUrzadzenia) != 0)
    293a:	8f 2d       	mov	r24, r15
    293c:	0e 94 17 45 	call	0x8a2e	; 0x8a2e <rs485ping>
    2940:	88 23       	and	r24, r24
    2942:	31 f0       	breq	.+12     	; 0x2950 <flashExModuleFunction+0x42>
  {
    state->errno = noRemoteDevice;
    2944:	89 e0       	ldi	r24, 0x09	; 9
    2946:	8c 8f       	std	Y+28, r24	; 0x1c
    printErrorInfo(state);
    2948:	ce 01       	movw	r24, r28
    294a:	0e 94 8b 11 	call	0x2316	; 0x2316 <printErrorInfo>
    294e:	37 c0       	rjmp	.+110    	; 0x29be <flashExModuleFunction+0xb0>
    return ERROR_INFORM;
  }
  
  //Sprawdzanie, czy istnieje odpowiedni plik z firmware
  if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
    2950:	c8 01       	movw	r24, r16
    2952:	64 e6       	ldi	r22, 0x64	; 100
    2954:	7f e0       	ldi	r23, 0x0F	; 15
    2956:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <ramDyskOtworzPlik>
    295a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    295c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    295e:	88 23       	and	r24, r24
    2960:	f9 f0       	breq	.+62     	; 0x29a0 <flashExModuleFunction+0x92>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
    2962:	00 d0       	rcall	.+0      	; 0x2964 <flashExModuleFunction+0x56>
    2964:	00 d0       	rcall	.+0      	; 0x2966 <flashExModuleFunction+0x58>
    2966:	00 d0       	rcall	.+0      	; 0x2968 <flashExModuleFunction+0x5a>
    2968:	ed b7       	in	r30, 0x3d	; 61
    296a:	fe b7       	in	r31, 0x3e	; 62
    296c:	31 96       	adiw	r30, 0x01	; 1
    296e:	ad b7       	in	r26, 0x3d	; 61
    2970:	be b7       	in	r27, 0x3e	; 62
    2972:	12 96       	adiw	r26, 0x02	; 2
    2974:	5c 93       	st	X, r21
    2976:	4e 93       	st	-X, r20
    2978:	11 97       	sbiw	r26, 0x01	; 1
    297a:	82 e8       	ldi	r24, 0x82	; 130
    297c:	91 e0       	ldi	r25, 0x01	; 1
    297e:	93 83       	std	Z+3, r25	; 0x03
    2980:	82 83       	std	Z+2, r24	; 0x02
    2982:	15 83       	std	Z+5, r17	; 0x05
    2984:	04 83       	std	Z+4, r16	; 0x04
    2986:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    298a:	24 e0       	ldi	r18, 0x04	; 4
    298c:	30 e0       	ldi	r19, 0x00	; 0
    298e:	8d b7       	in	r24, 0x3d	; 61
    2990:	9e b7       	in	r25, 0x3e	; 62
    2992:	06 96       	adiw	r24, 0x06	; 6
    2994:	0f b6       	in	r0, 0x3f	; 63
    2996:	f8 94       	cli
    2998:	9e bf       	out	0x3e, r25	; 62
    299a:	0f be       	out	0x3f, r0	; 63
    299c:	8d bf       	out	0x3d, r24	; 61
    299e:	11 c0       	rjmp	.+34     	; 0x29c2 <flashExModuleFunction+0xb4>
    return ERROR_INFORM;
  }
  
  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
    29a0:	84 e6       	ldi	r24, 0x64	; 100
    29a2:	9f e0       	ldi	r25, 0x0F	; 15
    29a4:	6f 2d       	mov	r22, r15
    29a6:	0e 94 c3 41 	call	0x8386	; 0x8386 <rs485xModemFlash>
    29aa:	18 2f       	mov	r17, r24

  ramDyskZamknijPlik(&fdVty);
    29ac:	84 e6       	ldi	r24, 0x64	; 100
    29ae:	9f e0       	ldi	r25, 0x0F	; 15
    29b0:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <ramDyskZamknijPlik>
  
  if (blad != 0)
    29b4:	11 23       	and	r17, r17
    29b6:	19 f4       	brne	.+6      	; 0x29be <flashExModuleFunction+0xb0>
    29b8:	20 e0       	ldi	r18, 0x00	; 0
    29ba:	30 e0       	ldi	r19, 0x00	; 0
    29bc:	02 c0       	rjmp	.+4      	; 0x29c2 <flashExModuleFunction+0xb4>
    29be:	24 e0       	ldi	r18, 0x04	; 4
    29c0:	30 e0       	ldi	r19, 0x00	; 0
    return ERROR_INFORM;

  return OK_SILENT;
}
    29c2:	c9 01       	movw	r24, r18
    29c4:	df 91       	pop	r29
    29c6:	cf 91       	pop	r28
    29c8:	1f 91       	pop	r17
    29ca:	0f 91       	pop	r16
    29cc:	ff 90       	pop	r15
    29ce:	08 95       	ret

000029d0 <goXmodemOdbierzFunction>:
  }
  return OK_SILENT;
}

static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
{
    29d0:	2f 92       	push	r2
    29d2:	3f 92       	push	r3
    29d4:	4f 92       	push	r4
    29d6:	5f 92       	push	r5
    29d8:	6f 92       	push	r6
    29da:	7f 92       	push	r7
    29dc:	8f 92       	push	r8
    29de:	9f 92       	push	r9
    29e0:	af 92       	push	r10
    29e2:	bf 92       	push	r11
    29e4:	cf 92       	push	r12
    29e6:	df 92       	push	r13
    29e8:	ef 92       	push	r14
    29ea:	ff 92       	push	r15
    29ec:	0f 93       	push	r16
    29ee:	1f 93       	push	r17
    29f0:	df 93       	push	r29
    29f2:	cf 93       	push	r28
    29f4:	00 d0       	rcall	.+0      	; 0x29f6 <goXmodemOdbierzFunction+0x26>
    29f6:	00 d0       	rcall	.+0      	; 0x29f8 <goXmodemOdbierzFunction+0x28>
    29f8:	00 d0       	rcall	.+0      	; 0x29fa <goXmodemOdbierzFunction+0x2a>
    29fa:	cd b7       	in	r28, 0x3d	; 61
    29fc:	de b7       	in	r29, 0x3e	; 62
    29fe:	7c 01       	movw	r14, r24
  fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
    2a00:	00 d0       	rcall	.+0      	; 0x2a02 <goXmodemOdbierzFunction+0x32>
    2a02:	00 d0       	rcall	.+0      	; 0x2a04 <goXmodemOdbierzFunction+0x34>
    2a04:	dc 01       	movw	r26, r24
    2a06:	5a 96       	adiw	r26, 0x1a	; 26
    2a08:	8d 91       	ld	r24, X+
    2a0a:	9c 91       	ld	r25, X
    2a0c:	5b 97       	sbiw	r26, 0x1b	; 27
    2a0e:	ed b7       	in	r30, 0x3d	; 61
    2a10:	fe b7       	in	r31, 0x3e	; 62
    2a12:	92 83       	std	Z+2, r25	; 0x02
    2a14:	81 83       	std	Z+1, r24	; 0x01
    2a16:	87 e8       	ldi	r24, 0x87	; 135
    2a18:	9a e0       	ldi	r25, 0x0A	; 10
    2a1a:	94 83       	std	Z+4, r25	; 0x04
    2a1c:	83 83       	std	Z+3, r24	; 0x03
    2a1e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    2a22:	0f 90       	pop	r0
    2a24:	0f 90       	pop	r0
    2a26:	0f 90       	pop	r0
    2a28:	0f 90       	pop	r0
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
    2a2c:	b7 01       	movw	r22, r14
    2a2e:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2a32:	64 e6       	ldi	r22, 0x64	; 100
    2a34:	7f e0       	ldi	r23, 0x0F	; 15
    2a36:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <ramDyskOtworzPlik>
    2a3a:	88 23       	and	r24, r24
    2a3c:	41 f1       	breq	.+80     	; 0x2a8e <goXmodemOdbierzFunction+0xbe>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2a3e:	d7 01       	movw	r26, r14
    2a40:	5a 96       	adiw	r26, 0x1a	; 26
    2a42:	0d 91       	ld	r16, X+
    2a44:	1c 91       	ld	r17, X
    2a46:	5b 97       	sbiw	r26, 0x1b	; 27
    2a48:	81 e0       	ldi	r24, 0x01	; 1
    2a4a:	b7 01       	movw	r22, r14
    2a4c:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2a50:	00 d0       	rcall	.+0      	; 0x2a52 <goXmodemOdbierzFunction+0x82>
    2a52:	00 d0       	rcall	.+0      	; 0x2a54 <goXmodemOdbierzFunction+0x84>
    2a54:	00 d0       	rcall	.+0      	; 0x2a56 <goXmodemOdbierzFunction+0x86>
    2a56:	ed b7       	in	r30, 0x3d	; 61
    2a58:	fe b7       	in	r31, 0x3e	; 62
    2a5a:	31 96       	adiw	r30, 0x01	; 1
    2a5c:	ad b7       	in	r26, 0x3d	; 61
    2a5e:	be b7       	in	r27, 0x3e	; 62
    2a60:	12 96       	adiw	r26, 0x02	; 2
    2a62:	1c 93       	st	X, r17
    2a64:	0e 93       	st	-X, r16
    2a66:	11 97       	sbiw	r26, 0x01	; 1
    2a68:	22 e8       	ldi	r18, 0x82	; 130
    2a6a:	31 e0       	ldi	r19, 0x01	; 1
    2a6c:	33 83       	std	Z+3, r19	; 0x03
    2a6e:	22 83       	std	Z+2, r18	; 0x02
    2a70:	95 83       	std	Z+5, r25	; 0x05
    2a72:	84 83       	std	Z+4, r24	; 0x04
    2a74:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    2a78:	24 e0       	ldi	r18, 0x04	; 4
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	ed b7       	in	r30, 0x3d	; 61
    2a7e:	fe b7       	in	r31, 0x3e	; 62
    2a80:	36 96       	adiw	r30, 0x06	; 6
    2a82:	0f b6       	in	r0, 0x3f	; 63
    2a84:	f8 94       	cli
    2a86:	fe bf       	out	0x3e, r31	; 62
    2a88:	0f be       	out	0x3f, r0	; 63
    2a8a:	ed bf       	out	0x3d, r30	; 61
    2a8c:	7b c1       	rjmp	.+758    	; 0x2d84 <goXmodemOdbierzFunction+0x3b4>
  uint8_t nrBlokuZdalnyNeg;

  uint8_t crcHi;
  uint8_t crcLo;

  state->err1=0;
    2a8e:	d7 01       	movw	r26, r14
    2a90:	5e 96       	adiw	r26, 0x1e	; 30
    2a92:	1c 92       	st	X, r1
    2a94:	1e 92       	st	-X, r1
    2a96:	5d 97       	sbiw	r26, 0x1d	; 29
  state->err2=0;
    2a98:	5f 96       	adiw	r26, 0x1f	; 31
    2a9a:	1c 92       	st	X, r1
    2a9c:	04 e1       	ldi	r16, 0x14	; 20
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora

    if(xQueueReceive(xVtyRec, &c, 100))
    2a9e:	b2 e0       	ldi	r27, 0x02	; 2
    2aa0:	cb 2e       	mov	r12, r27
    2aa2:	d1 2c       	mov	r13, r1
    2aa4:	cc 0e       	add	r12, r28
    2aa6:	dd 1e       	adc	r13, r29
  state->err1=0;
  state->err2=0;
  liczbaProb = 20;
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    2aa8:	f7 01       	movw	r30, r14
    2aaa:	62 8d       	ldd	r22, Z+26	; 0x1a
    2aac:	73 8d       	ldd	r23, Z+27	; 0x1b
    2aae:	83 e4       	ldi	r24, 0x43	; 67
    2ab0:	90 e0       	ldi	r25, 0x00	; 0
    2ab2:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
    2ab6:	80 91 9b 00 	lds	r24, 0x009B
    2aba:	86 ff       	sbrs	r24, 6
    2abc:	fc cf       	rjmp	.-8      	; 0x2ab6 <goXmodemOdbierzFunction+0xe6>

    if(xQueueReceive(xVtyRec, &c, 100))
    2abe:	80 91 ad 0e 	lds	r24, 0x0EAD
    2ac2:	90 91 ae 0e 	lds	r25, 0x0EAE
    2ac6:	b6 01       	movw	r22, r12
    2ac8:	44 e6       	ldi	r20, 0x64	; 100
    2aca:	50 e0       	ldi	r21, 0x00	; 0
    2acc:	20 e0       	ldi	r18, 0x00	; 0
    2ace:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2ad2:	88 23       	and	r24, r24
    2ad4:	19 f0       	breq	.+6      	; 0x2adc <goXmodemOdbierzFunction+0x10c>
      if (c == SOH)
    2ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad8:	81 30       	cpi	r24, 0x01	; 1
    2ada:	61 f0       	breq	.+24     	; 0x2af4 <goXmodemOdbierzFunction+0x124>
        break;                                                   //Rozpoczynamy transmisje

    liczbaProb--;
    2adc:	01 50       	subi	r16, 0x01	; 1
    if (liczbaProb == 0)
    2ade:	21 f7       	brne	.-56     	; 0x2aa8 <goXmodemOdbierzFunction+0xd8>
    {
      ramDyskZamknijPlik(&fdVty);
    2ae0:	84 e6       	ldi	r24, 0x64	; 100
    2ae2:	9f e0       	ldi	r25, 0x0F	; 15
    2ae4:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <ramDyskZamknijPlik>
      state->errno = (uint8_t)(AllOK);
    2ae8:	d7 01       	movw	r26, r14
    2aea:	5c 96       	adiw	r26, 0x1c	; 28
    2aec:	1c 92       	st	X, r1
    2aee:	24 e0       	ldi	r18, 0x04	; 4
    2af0:	30 e0       	ldi	r19, 0x00	; 0
    2af2:	48 c1       	rjmp	.+656    	; 0x2d84 <goXmodemOdbierzFunction+0x3b4>
  }
  
  nrBloku = 1;
  liczbaProb = 10;

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2af4:	84 e6       	ldi	r24, 0x64	; 100
    2af6:	9f e0       	ldi	r25, 0x0F	; 15
    2af8:	61 e0       	ldi	r22, 0x01	; 1
    2afa:	70 e0       	ldi	r23, 0x00	; 0
    2afc:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <ramDyskDodajBlokXmodem>
    2b00:	6c 01       	movw	r12, r24
    2b02:	5c 01       	movw	r10, r24
    2b04:	aa e0       	ldi	r26, 0x0A	; 10
    2b06:	9a 2e       	mov	r9, r26
    2b08:	11 e0       	ldi	r17, 0x01	; 1
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2b0a:	f3 e0       	ldi	r31, 0x03	; 3
    2b0c:	8f 2e       	mov	r8, r31
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    2b0e:	e5 e0       	ldi	r30, 0x05	; 5
    2b10:	2e 2e       	mov	r2, r30
    2b12:	31 2c       	mov	r3, r1
    2b14:	2c 0e       	add	r2, r28
    2b16:	3d 1e       	adc	r3, r29
    {
        state->errno = (uint8_t)(xModemFrameCrc);
        state->err1 = 2;
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    2b18:	76 e0       	ldi	r23, 0x06	; 6
    2b1a:	47 2e       	mov	r4, r23
    2b1c:	51 2c       	mov	r5, r1
    2b1e:	4c 0e       	add	r4, r28
    2b20:	5d 1e       	adc	r5, r29
      state->err2 = nrBloku;
      state->errno = (uint8_t)(xModemWrongFrameNo);
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    2b22:	3e 01       	movw	r6, r28
    2b24:	08 94       	sec
    2b26:	61 1c       	adc	r6, r1
    2b28:	71 1c       	adc	r7, r1

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    2b2a:	80 91 ad 0e 	lds	r24, 0x0EAD
    2b2e:	90 91 ae 0e 	lds	r25, 0x0EAE
    2b32:	be 01       	movw	r22, r28
    2b34:	6d 5f       	subi	r22, 0xFD	; 253
    2b36:	7f 4f       	sbci	r23, 0xFF	; 255
    2b38:	44 e6       	ldi	r20, 0x64	; 100
    2b3a:	50 e0       	ldi	r21, 0x00	; 0
    2b3c:	20 e0       	ldi	r18, 0x00	; 0
    2b3e:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2b42:	88 23       	and	r24, r24
    2b44:	09 f4       	brne	.+2      	; 0x2b48 <goXmodemOdbierzFunction+0x178>
    2b46:	dd c0       	rjmp	.+442    	; 0x2d02 <goXmodemOdbierzFunction+0x332>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    2b48:	80 91 ad 0e 	lds	r24, 0x0EAD
    2b4c:	90 91 ae 0e 	lds	r25, 0x0EAE
    2b50:	be 01       	movw	r22, r28
    2b52:	6c 5f       	subi	r22, 0xFC	; 252
    2b54:	7f 4f       	sbci	r23, 0xFF	; 255
    2b56:	41 e0       	ldi	r20, 0x01	; 1
    2b58:	50 e0       	ldi	r21, 0x00	; 0
    2b5a:	20 e0       	ldi	r18, 0x00	; 0
    2b5c:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2b60:	88 23       	and	r24, r24
    2b62:	19 f4       	brne	.+6      	; 0x2b6a <goXmodemOdbierzFunction+0x19a>
    {
      state->errno = (uint8_t)(xModemByteSendTimeout);
    2b64:	83 e0       	ldi	r24, 0x03	; 3
    2b66:	d7 01       	movw	r26, r14
    2b68:	bd c0       	rjmp	.+378    	; 0x2ce4 <goXmodemOdbierzFunction+0x314>
      break; 
    }
  
    //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
    c = 255-nrBlokuZdalnyNeg;
    2b6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6c:	89 2f       	mov	r24, r25
    2b6e:	80 95       	com	r24
    2b70:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny != c)
    2b72:	0b 81       	ldd	r16, Y+3	; 0x03
    2b74:	08 17       	cp	r16, r24
    2b76:	39 f0       	breq	.+14     	; 0x2b86 <goXmodemOdbierzFunction+0x1b6>
    {
      state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
    2b78:	85 e0       	ldi	r24, 0x05	; 5
    2b7a:	f7 01       	movw	r30, r14
    2b7c:	84 8f       	std	Z+28, r24	; 0x1c
      state->err1 = nrBlokuZdalny;
    2b7e:	05 8f       	std	Z+29, r16	; 0x1d
    2b80:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBlokuZdalnyNeg;
    2b82:	97 8f       	std	Z+31, r25	; 0x1f
    2b84:	f9 c0       	rjmp	.+498    	; 0x2d78 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    
    //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od bloku 0
    c = nrBloku-1;
    2b86:	81 2f       	mov	r24, r17
    2b88:	81 50       	subi	r24, 0x01	; 1
    2b8a:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny == c)
    2b8c:	08 17       	cp	r16, r24
    2b8e:	11 f0       	breq	.+4      	; 0x2b94 <goXmodemOdbierzFunction+0x1c4>
    2b90:	01 2f       	mov	r16, r17
    2b92:	08 c0       	rjmp	.+16     	; 0x2ba4 <goXmodemOdbierzFunction+0x1d4>
    {
      nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2b94:	84 e6       	ldi	r24, 0x64	; 100
    2b96:	9f e0       	ldi	r25, 0x0F	; 15
    2b98:	60 2f       	mov	r22, r16
    2b9a:	70 e0       	ldi	r23, 0x00	; 0
    2b9c:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <ramDyskDodajBlokXmodem>
    2ba0:	6c 01       	movw	r12, r24
    2ba2:	5c 01       	movw	r10, r24
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    2ba4:	1b 81       	ldd	r17, Y+3	; 0x03
    2ba6:	10 17       	cp	r17, r16
    2ba8:	79 f0       	breq	.+30     	; 0x2bc8 <goXmodemOdbierzFunction+0x1f8>
    {
      state->errno = (uint8_t)(xModemWrongFrameNo);
    2baa:	84 e0       	ldi	r24, 0x04	; 4
    2bac:	d7 01       	movw	r26, r14
    2bae:	5c 96       	adiw	r26, 0x1c	; 28
    2bb0:	8c 93       	st	X, r24
    2bb2:	5c 97       	sbiw	r26, 0x1c	; 28
      state->err1 = nrBlokuZdalnyNeg;
    2bb4:	8c 81       	ldd	r24, Y+4	; 0x04
    2bb6:	5d 96       	adiw	r26, 0x1d	; 29
    2bb8:	8c 93       	st	X, r24
    2bba:	5d 97       	sbiw	r26, 0x1d	; 29
    2bbc:	5e 96       	adiw	r26, 0x1e	; 30
    2bbe:	1c 92       	st	X, r1
    2bc0:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    2bc2:	5f 96       	adiw	r26, 0x1f	; 31
    2bc4:	0c 93       	st	X, r16
    2bc6:	d8 c0       	rjmp	.+432    	; 0x2d78 <goXmodemOdbierzFunction+0x3a8>
      break;
    2bc8:	00 e0       	ldi	r16, 0x00	; 0
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    {
      if(xQueueReceive(xVtyRec, &c, 10))
    2bca:	80 91 ad 0e 	lds	r24, 0x0EAD
    2bce:	90 91 ae 0e 	lds	r25, 0x0EAE
    2bd2:	be 01       	movw	r22, r28
    2bd4:	6e 5f       	subi	r22, 0xFE	; 254
    2bd6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd8:	4a e0       	ldi	r20, 0x0A	; 10
    2bda:	50 e0       	ldi	r21, 0x00	; 0
    2bdc:	20 e0       	ldi	r18, 0x00	; 0
    2bde:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2be2:	88 23       	and	r24, r24
    2be4:	41 f0       	breq	.+16     	; 0x2bf6 <goXmodemOdbierzFunction+0x226>
        *(zapPtr++) = c;
    2be6:	8a 81       	ldd	r24, Y+2	; 0x02
    2be8:	f6 01       	movw	r30, r12
    2bea:	81 93       	st	Z+, r24
    2bec:	6f 01       	movw	r12, r30
      state->err1 = nrBlokuZdalnyNeg;
      state->err2 = nrBloku;
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    2bee:	0f 5f       	subi	r16, 0xFF	; 255
    2bf0:	00 38       	cpi	r16, 0x80	; 128
    2bf2:	59 f7       	brne	.-42     	; 0x2bca <goXmodemOdbierzFunction+0x1fa>
    2bf4:	03 c0       	rjmp	.+6      	; 0x2bfc <goXmodemOdbierzFunction+0x22c>
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2bf6:	d7 01       	movw	r26, r14
    2bf8:	5c 96       	adiw	r26, 0x1c	; 28
    2bfa:	8c 92       	st	X, r8
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    2bfc:	80 91 ad 0e 	lds	r24, 0x0EAD
    2c00:	90 91 ae 0e 	lds	r25, 0x0EAE
    2c04:	b1 01       	movw	r22, r2
    2c06:	4a e0       	ldi	r20, 0x0A	; 10
    2c08:	50 e0       	ldi	r21, 0x00	; 0
    2c0a:	20 e0       	ldi	r18, 0x00	; 0
    2c0c:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2c10:	88 23       	and	r24, r24
    2c12:	41 f4       	brne	.+16     	; 0x2c24 <goXmodemOdbierzFunction+0x254>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2c14:	86 e0       	ldi	r24, 0x06	; 6
    2c16:	f7 01       	movw	r30, r14
    2c18:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 2;
    2c1a:	82 e0       	ldi	r24, 0x02	; 2
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	96 8f       	std	Z+30, r25	; 0x1e
    2c20:	85 8f       	std	Z+29, r24	; 0x1d
    2c22:	aa c0       	rjmp	.+340    	; 0x2d78 <goXmodemOdbierzFunction+0x3a8>
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    2c24:	80 91 ad 0e 	lds	r24, 0x0EAD
    2c28:	90 91 ae 0e 	lds	r25, 0x0EAE
    2c2c:	b2 01       	movw	r22, r4
    2c2e:	4a e0       	ldi	r20, 0x0A	; 10
    2c30:	50 e0       	ldi	r21, 0x00	; 0
    2c32:	20 e0       	ldi	r18, 0x00	; 0
    2c34:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2c38:	88 23       	and	r24, r24
    2c3a:	61 f4       	brne	.+24     	; 0x2c54 <goXmodemOdbierzFunction+0x284>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2c3c:	86 e0       	ldi	r24, 0x06	; 6
    2c3e:	d7 01       	movw	r26, r14
    2c40:	5c 96       	adiw	r26, 0x1c	; 28
    2c42:	8c 93       	st	X, r24
    2c44:	5c 97       	sbiw	r26, 0x1c	; 28
        state->err1 = 1;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	90 e0       	ldi	r25, 0x00	; 0
    2c4a:	5e 96       	adiw	r26, 0x1e	; 30
    2c4c:	9c 93       	st	X, r25
    2c4e:	8e 93       	st	-X, r24
    2c50:	5d 97       	sbiw	r26, 0x1d	; 29
    2c52:	92 c0       	rjmp	.+292    	; 0x2d78 <goXmodemOdbierzFunction+0x3a8>
        break;      
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	40 e0       	ldi	r20, 0x00	; 0
    2c58:	50 e0       	ldi	r21, 0x00	; 0
    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
    2c5a:	f5 01       	movw	r30, r10
    2c5c:	81 91       	ld	r24, Z+
    2c5e:	5f 01       	movw	r10, r30
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    2c60:	58 27       	eor	r21, r24
    2c62:	05 2e       	mov	r0, r21
    2c64:	02 94       	swap	r0
    2c66:	80 2d       	mov	r24, r0
    2c68:	8f 70       	andi	r24, 0x0F	; 15
    2c6a:	85 27       	eor	r24, r21
    2c6c:	25 2f       	mov	r18, r21
    2c6e:	20 25       	eor	r18, r0
    2c70:	22 0f       	add	r18, r18
    2c72:	20 7e       	andi	r18, 0xE0	; 224
    2c74:	82 27       	eor	r24, r18
    2c76:	20 2d       	mov	r18, r0
    2c78:	25 27       	eor	r18, r21
    2c7a:	20 7f       	andi	r18, 0xF0	; 240
    2c7c:	26 95       	lsr	r18
    2c7e:	05 2e       	mov	r0, r21
    2c80:	00 0c       	add	r0, r0
    2c82:	22 1f       	adc	r18, r18
    2c84:	56 95       	lsr	r21
    2c86:	56 95       	lsr	r21
    2c88:	56 95       	lsr	r21
    2c8a:	5f 71       	andi	r21, 0x1F	; 31
    2c8c:	52 27       	eor	r21, r18
    2c8e:	54 27       	eor	r21, r20
    2c90:	48 2f       	mov	r20, r24

    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    2c92:	9f 5f       	subi	r25, 0xFF	; 255
    2c94:	90 38       	cpi	r25, 0x80	; 128
    2c96:	09 f7       	brne	.-62     	; 0x2c5a <goXmodemOdbierzFunction+0x28a>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    2c98:	8d 81       	ldd	r24, Y+5	; 0x05
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	25 2f       	mov	r18, r21
    2c9e:	33 27       	eor	r19, r19
    2ca0:	82 17       	cp	r24, r18
    2ca2:	93 07       	cpc	r25, r19
    2ca4:	61 f4       	brne	.+24     	; 0x2cbe <goXmodemOdbierzFunction+0x2ee>
    2ca6:	8e 81       	ldd	r24, Y+6	; 0x06
    2ca8:	90 e0       	ldi	r25, 0x00	; 0
    2caa:	50 70       	andi	r21, 0x00	; 0
    2cac:	84 17       	cp	r24, r20
    2cae:	95 07       	cpc	r25, r21
    2cb0:	31 f4       	brne	.+12     	; 0x2cbe <goXmodemOdbierzFunction+0x2ee>
    {
      liczbaProb = 10;
      uartVtySendByte(ACK);      
    2cb2:	86 e0       	ldi	r24, 0x06	; 6
    2cb4:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
    2cb8:	4a e0       	ldi	r20, 0x0A	; 10
    2cba:	94 2e       	mov	r9, r20
    2cbc:	16 c0       	rjmp	.+44     	; 0x2cea <goXmodemOdbierzFunction+0x31a>
    }
    else
    {
      liczbaProb--;
    2cbe:	9a 94       	dec	r9
      nrBloku--;
    2cc0:	11 50       	subi	r17, 0x01	; 1
      uartVtySendByte(NAK);   
    2cc2:	85 e1       	ldi	r24, 0x15	; 21
    2cc4:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
    }
    
    if (liczbaProb == 0)
    2cc8:	99 20       	and	r9, r9
    2cca:	79 f4       	brne	.+30     	; 0x2cea <goXmodemOdbierzFunction+0x31a>
    {
      state->err1 = nrBlokuZdalny;
    2ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cce:	d7 01       	movw	r26, r14
    2cd0:	5d 96       	adiw	r26, 0x1d	; 29
    2cd2:	8c 93       	st	X, r24
    2cd4:	5d 97       	sbiw	r26, 0x1d	; 29
    2cd6:	5e 96       	adiw	r26, 0x1e	; 30
    2cd8:	1c 92       	st	X, r1
    2cda:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    2cdc:	5f 96       	adiw	r26, 0x1f	; 31
    2cde:	1c 93       	st	X, r17
    2ce0:	5f 97       	sbiw	r26, 0x1f	; 31
      state->errno = (uint8_t)(xModemWrongFrameNo);
    2ce2:	84 e0       	ldi	r24, 0x04	; 4
    2ce4:	5c 96       	adiw	r26, 0x1c	; 28
    2ce6:	8c 93       	st	X, r24
    2ce8:	47 c0       	rjmp	.+142    	; 0x2d78 <goXmodemOdbierzFunction+0x3a8>
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    2cea:	80 91 ad 0e 	lds	r24, 0x0EAD
    2cee:	90 91 ae 0e 	lds	r25, 0x0EAE
    2cf2:	b3 01       	movw	r22, r6
    2cf4:	44 e6       	ldi	r20, 0x64	; 100
    2cf6:	50 e0       	ldi	r21, 0x00	; 0
    2cf8:	20 e0       	ldi	r18, 0x00	; 0
    2cfa:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2cfe:	88 23       	and	r24, r24
    2d00:	19 f4       	brne	.+6      	; 0x2d08 <goXmodemOdbierzFunction+0x338>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    2d02:	82 e0       	ldi	r24, 0x02	; 2
    2d04:	f7 01       	movw	r30, r14
    2d06:	16 c0       	rjmp	.+44     	; 0x2d34 <goXmodemOdbierzFunction+0x364>
      break;
    }
    
    if (temp1 == SOH)
    2d08:	99 81       	ldd	r25, Y+1	; 0x01
    2d0a:	91 30       	cpi	r25, 0x01	; 1
    2d0c:	69 f4       	brne	.+26     	; 0x2d28 <goXmodemOdbierzFunction+0x358>
    {
      nrBloku++;
    2d0e:	1f 5f       	subi	r17, 0xFF	; 255
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2d10:	84 e6       	ldi	r24, 0x64	; 100
    2d12:	9f e0       	ldi	r25, 0x0F	; 15
    2d14:	61 2f       	mov	r22, r17
    2d16:	70 e0       	ldi	r23, 0x00	; 0
    2d18:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <ramDyskDodajBlokXmodem>
    2d1c:	6c 01       	movw	r12, r24
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
    2d1e:	d7 01       	movw	r26, r14
    2d20:	5c 96       	adiw	r26, 0x1c	; 28
    2d22:	1c 92       	st	X, r1
    2d24:	5c 01       	movw	r10, r24
    2d26:	01 cf       	rjmp	.-510    	; 0x2b2a <goXmodemOdbierzFunction+0x15a>
      continue;
    }

    if (temp1 == CAN)
    2d28:	98 31       	cpi	r25, 0x18	; 24
    2d2a:	31 f4       	brne	.+12     	; 0x2d38 <goXmodemOdbierzFunction+0x368>
    {
      state->err1 = nrBloku;
    2d2c:	f7 01       	movw	r30, r14
    2d2e:	15 8f       	std	Z+29, r17	; 0x1d
    2d30:	16 8e       	std	Z+30, r1	; 0x1e
      state->errno = (uint8_t)(xModemRemoteSideCan);
    2d32:	87 e0       	ldi	r24, 0x07	; 7
    2d34:	84 8f       	std	Z+28, r24	; 0x1c
    2d36:	20 c0       	rjmp	.+64     	; 0x2d78 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    if (temp1 == EOT)
    2d38:	94 30       	cpi	r25, 0x04	; 4
    2d3a:	c9 f4       	brne	.+50     	; 0x2d6e <goXmodemOdbierzFunction+0x39e>
    {
      uartVtySendByte(NAK);
    2d3c:	85 e1       	ldi	r24, 0x15	; 21
    2d3e:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
      if (xQueueReceive(xVtyRec, &temp1, 10))
    2d42:	80 91 ad 0e 	lds	r24, 0x0EAD
    2d46:	90 91 ae 0e 	lds	r25, 0x0EAE
    2d4a:	b3 01       	movw	r22, r6
    2d4c:	4a e0       	ldi	r20, 0x0A	; 10
    2d4e:	50 e0       	ldi	r21, 0x00	; 0
    2d50:	20 e0       	ldi	r18, 0x00	; 0
    2d52:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    2d56:	88 23       	and	r24, r24
    2d58:	31 f0       	breq	.+12     	; 0x2d66 <goXmodemOdbierzFunction+0x396>
      {
        if (temp1 == EOT)
    2d5a:	89 81       	ldd	r24, Y+1	; 0x01
    2d5c:	84 30       	cpi	r24, 0x04	; 4
    2d5e:	19 f4       	brne	.+6      	; 0x2d66 <goXmodemOdbierzFunction+0x396>
          uartVtySendByte(ACK);  
    2d60:	86 e0       	ldi	r24, 0x06	; 6
    2d62:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
      }
      state->errno = (uint8_t)(AllOK);
    2d66:	d7 01       	movw	r26, r14
    2d68:	5c 96       	adiw	r26, 0x1c	; 28
    2d6a:	1c 92       	st	X, r1
    2d6c:	05 c0       	rjmp	.+10     	; 0x2d78 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    2d6e:	88 e0       	ldi	r24, 0x08	; 8
    2d70:	f7 01       	movw	r30, r14
    2d72:	84 8f       	std	Z+28, r24	; 0x1c
    state->err1 = temp1;
    2d74:	95 8f       	std	Z+29, r25	; 0x1d
    2d76:	16 8e       	std	Z+30, r1	; 0x1e
    break;
  }
  ramDyskZamknijPlik(&fdVty);
    2d78:	84 e6       	ldi	r24, 0x64	; 100
    2d7a:	9f e0       	ldi	r25, 0x0F	; 15
    2d7c:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <ramDyskZamknijPlik>
    2d80:	20 e0       	ldi	r18, 0x00	; 0
    2d82:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2d84:	c9 01       	movw	r24, r18
    2d86:	26 96       	adiw	r28, 0x06	; 6
    2d88:	0f b6       	in	r0, 0x3f	; 63
    2d8a:	f8 94       	cli
    2d8c:	de bf       	out	0x3e, r29	; 62
    2d8e:	0f be       	out	0x3f, r0	; 63
    2d90:	cd bf       	out	0x3d, r28	; 61
    2d92:	cf 91       	pop	r28
    2d94:	df 91       	pop	r29
    2d96:	1f 91       	pop	r17
    2d98:	0f 91       	pop	r16
    2d9a:	ff 90       	pop	r15
    2d9c:	ef 90       	pop	r14
    2d9e:	df 90       	pop	r13
    2da0:	cf 90       	pop	r12
    2da2:	bf 90       	pop	r11
    2da4:	af 90       	pop	r10
    2da6:	9f 90       	pop	r9
    2da8:	8f 90       	pop	r8
    2daa:	7f 90       	pop	r7
    2dac:	6f 90       	pop	r6
    2dae:	5f 90       	pop	r5
    2db0:	4f 90       	pop	r4
    2db2:	3f 90       	pop	r3
    2db4:	2f 90       	pop	r2
    2db6:	08 95       	ret

00002db8 <debugFunction>:
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
  return OK_SILENT;
}

static cliExRes_t debugFunction          (cmdState_t *state)
{
    2db8:	ff 92       	push	r15
    2dba:	0f 93       	push	r16
    2dbc:	1f 93       	push	r17
    2dbe:	cf 93       	push	r28
    2dc0:	df 93       	push	r29
    2dc2:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    2dc4:	89 8d       	ldd	r24, Y+25	; 0x19
    2dc6:	82 30       	cpi	r24, 0x02	; 2
    2dc8:	08 f4       	brcc	.+2      	; 0x2dcc <debugFunction+0x14>
    2dca:	d2 c0       	rjmp	.+420    	; 0x2f70 <debugFunction+0x1b8>
    return SYNTAX_ERROR;

  uint8_t level = cmdlineGetArgInt(2, state);
    2dcc:	82 e0       	ldi	r24, 0x02	; 2
    2dce:	be 01       	movw	r22, r28
    2dd0:	0e 94 67 22 	call	0x44ce	; 0x44ce <cmdlineGetArgInt>
    2dd4:	f6 2e       	mov	r15, r22
  const char *str = (const char*)cmdlineGetArgStr(1, state);
    2dd6:	81 e0       	ldi	r24, 0x01	; 1
    2dd8:	be 01       	movw	r22, r28
    2dda:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2dde:	8c 01       	movw	r16, r24
  if (level == 0)
    2de0:	ff 20       	and	r15, r15
    2de2:	09 f0       	breq	.+2      	; 0x2de6 <debugFunction+0x2e>
    2de4:	5b c0       	rjmp	.+182    	; 0x2e9c <debugFunction+0xe4>
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2de6:	6b ec       	ldi	r22, 0xCB	; 203
    2de8:	7a e0       	ldi	r23, 0x0A	; 10
    2dea:	43 e0       	ldi	r20, 0x03	; 3
    2dec:	50 e0       	ldi	r21, 0x00	; 0
    2dee:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2df2:	89 2b       	or	r24, r25
    2df4:	31 f4       	brne	.+12     	; 0x2e02 <debugFunction+0x4a>
    {
      setArpDebug(NULL, 0);
    2df6:	80 e0       	ldi	r24, 0x00	; 0
    2df8:	90 e0       	ldi	r25, 0x00	; 0
    2dfa:	60 e0       	ldi	r22, 0x00	; 0
    2dfc:	0e 94 24 36 	call	0x6c48	; 0x6c48 <setArpDebug>
    2e00:	2c c0       	rjmp	.+88     	; 0x2e5a <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2e02:	c8 01       	movw	r24, r16
    2e04:	68 ec       	ldi	r22, 0xC8	; 200
    2e06:	7a e0       	ldi	r23, 0x0A	; 10
    2e08:	42 e0       	ldi	r20, 0x02	; 2
    2e0a:	50 e0       	ldi	r21, 0x00	; 0
    2e0c:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2e10:	89 2b       	or	r24, r25
    2e12:	31 f4       	brne	.+12     	; 0x2e20 <debugFunction+0x68>
    {
      setIpDebug(NULL, 0);
    2e14:	80 e0       	ldi	r24, 0x00	; 0
    2e16:	90 e0       	ldi	r25, 0x00	; 0
    2e18:	60 e0       	ldi	r22, 0x00	; 0
    2e1a:	0e 94 c8 31 	call	0x6390	; 0x6390 <setIpDebug>
    2e1e:	1d c0       	rjmp	.+58     	; 0x2e5a <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2e20:	c8 01       	movw	r24, r16
    2e22:	63 ec       	ldi	r22, 0xC3	; 195
    2e24:	7a e0       	ldi	r23, 0x0A	; 10
    2e26:	42 e0       	ldi	r20, 0x02	; 2
    2e28:	50 e0       	ldi	r21, 0x00	; 0
    2e2a:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2e2e:	89 2b       	or	r24, r25
    2e30:	31 f4       	brne	.+12     	; 0x2e3e <debugFunction+0x86>
    {
      setIcmpDebug(NULL, 0);
    2e32:	80 e0       	ldi	r24, 0x00	; 0
    2e34:	90 e0       	ldi	r25, 0x00	; 0
    2e36:	60 e0       	ldi	r22, 0x00	; 0
    2e38:	0e 94 99 34 	call	0x6932	; 0x6932 <setIcmpDebug>
    2e3c:	0e c0       	rjmp	.+28     	; 0x2e5a <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2e3e:	c8 01       	movw	r24, r16
    2e40:	6f eb       	ldi	r22, 0xBF	; 191
    2e42:	7a e0       	ldi	r23, 0x0A	; 10
    2e44:	42 e0       	ldi	r20, 0x02	; 2
    2e46:	50 e0       	ldi	r21, 0x00	; 0
    2e48:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2e4c:	89 2b       	or	r24, r25
    2e4e:	b1 f4       	brne	.+44     	; 0x2e7c <debugFunction+0xc4>
    {
      setTcpDebug(NULL, 0);
    2e50:	80 e0       	ldi	r24, 0x00	; 0
    2e52:	90 e0       	ldi	r25, 0x00	; 0
    2e54:	60 e0       	ldi	r22, 0x00	; 0
    2e56:	0e 94 77 3a 	call	0x74ee	; 0x74ee <setTcpDebug>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
    2e5a:	00 d0       	rcall	.+0      	; 0x2e5c <debugFunction+0xa4>
    2e5c:	00 d0       	rcall	.+0      	; 0x2e5e <debugFunction+0xa6>
    2e5e:	00 d0       	rcall	.+0      	; 0x2e60 <debugFunction+0xa8>
    2e60:	ed b7       	in	r30, 0x3d	; 61
    2e62:	fe b7       	in	r31, 0x3e	; 62
    2e64:	31 96       	adiw	r30, 0x01	; 1
    2e66:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2e68:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2e6a:	ad b7       	in	r26, 0x3d	; 61
    2e6c:	be b7       	in	r27, 0x3e	; 62
    2e6e:	12 96       	adiw	r26, 0x02	; 2
    2e70:	9c 93       	st	X, r25
    2e72:	8e 93       	st	-X, r24
    2e74:	11 97       	sbiw	r26, 0x01	; 1
    2e76:	88 e2       	ldi	r24, 0x28	; 40
    2e78:	94 e0       	ldi	r25, 0x04	; 4
    2e7a:	5a c0       	rjmp	.+180    	; 0x2f30 <debugFunction+0x178>
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2e7c:	c8 01       	movw	r24, r16
    2e7e:	6b eb       	ldi	r22, 0xBB	; 187
    2e80:	7a e0       	ldi	r23, 0x0A	; 10
    2e82:	42 e0       	ldi	r20, 0x02	; 2
    2e84:	50 e0       	ldi	r21, 0x00	; 0
    2e86:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2e8a:	89 2b       	or	r24, r25
    2e8c:	09 f0       	breq	.+2      	; 0x2e90 <debugFunction+0xd8>
    2e8e:	70 c0       	rjmp	.+224    	; 0x2f70 <debugFunction+0x1b8>
    {
      setUdpDebug(NULL, 0);
    2e90:	80 e0       	ldi	r24, 0x00	; 0
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	60 e0       	ldi	r22, 0x00	; 0
    2e96:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <setUdpDebug>
    2e9a:	df cf       	rjmp	.-66     	; 0x2e5a <debugFunction+0xa2>


  }
  else                   //level > 0
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2e9c:	67 eb       	ldi	r22, 0xB7	; 183
    2e9e:	7a e0       	ldi	r23, 0x0A	; 10
    2ea0:	43 e0       	ldi	r20, 0x03	; 3
    2ea2:	50 e0       	ldi	r21, 0x00	; 0
    2ea4:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2ea8:	89 2b       	or	r24, r25
    2eaa:	31 f4       	brne	.+12     	; 0x2eb8 <debugFunction+0x100>
    {
      setArpDebug(state->myStdInOut, level);
    2eac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2eae:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2eb0:	6f 2d       	mov	r22, r15
    2eb2:	0e 94 24 36 	call	0x6c48	; 0x6c48 <setArpDebug>
    2eb6:	2c c0       	rjmp	.+88     	; 0x2f10 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }   
    
    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2eb8:	c8 01       	movw	r24, r16
    2eba:	64 eb       	ldi	r22, 0xB4	; 180
    2ebc:	7a e0       	ldi	r23, 0x0A	; 10
    2ebe:	42 e0       	ldi	r20, 0x02	; 2
    2ec0:	50 e0       	ldi	r21, 0x00	; 0
    2ec2:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2ec6:	89 2b       	or	r24, r25
    2ec8:	31 f4       	brne	.+12     	; 0x2ed6 <debugFunction+0x11e>
    {
      setIpDebug(state->myStdInOut, level);
    2eca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ecc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2ece:	6f 2d       	mov	r22, r15
    2ed0:	0e 94 c8 31 	call	0x6390	; 0x6390 <setIpDebug>
    2ed4:	1d c0       	rjmp	.+58     	; 0x2f10 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2ed6:	c8 01       	movw	r24, r16
    2ed8:	6f ea       	ldi	r22, 0xAF	; 175
    2eda:	7a e0       	ldi	r23, 0x0A	; 10
    2edc:	42 e0       	ldi	r20, 0x02	; 2
    2ede:	50 e0       	ldi	r21, 0x00	; 0
    2ee0:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2ee4:	89 2b       	or	r24, r25
    2ee6:	31 f4       	brne	.+12     	; 0x2ef4 <debugFunction+0x13c>
    {
      setIcmpDebug(state->myStdInOut, level);
    2ee8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2eea:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2eec:	6f 2d       	mov	r22, r15
    2eee:	0e 94 99 34 	call	0x6932	; 0x6932 <setIcmpDebug>
    2ef2:	0e c0       	rjmp	.+28     	; 0x2f10 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2ef4:	c8 01       	movw	r24, r16
    2ef6:	6b ea       	ldi	r22, 0xAB	; 171
    2ef8:	7a e0       	ldi	r23, 0x0A	; 10
    2efa:	42 e0       	ldi	r20, 0x02	; 2
    2efc:	50 e0       	ldi	r21, 0x00	; 0
    2efe:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2f02:	89 2b       	or	r24, r25
    2f04:	31 f5       	brne	.+76     	; 0x2f52 <debugFunction+0x19a>
    {
      setTcpDebug(state->myStdInOut, level);
    2f06:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f08:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2f0a:	6f 2d       	mov	r22, r15
    2f0c:	0e 94 77 3a 	call	0x74ee	; 0x74ee <setTcpDebug>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
    2f10:	00 d0       	rcall	.+0      	; 0x2f12 <debugFunction+0x15a>
    2f12:	00 d0       	rcall	.+0      	; 0x2f14 <debugFunction+0x15c>
    2f14:	00 d0       	rcall	.+0      	; 0x2f16 <debugFunction+0x15e>
    2f16:	ed b7       	in	r30, 0x3d	; 61
    2f18:	fe b7       	in	r31, 0x3e	; 62
    2f1a:	31 96       	adiw	r30, 0x01	; 1
    2f1c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f1e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2f20:	ad b7       	in	r26, 0x3d	; 61
    2f22:	be b7       	in	r27, 0x3e	; 62
    2f24:	12 96       	adiw	r26, 0x02	; 2
    2f26:	9c 93       	st	X, r25
    2f28:	8e 93       	st	-X, r24
    2f2a:	11 97       	sbiw	r26, 0x01	; 1
    2f2c:	85 e1       	ldi	r24, 0x15	; 21
    2f2e:	94 e0       	ldi	r25, 0x04	; 4
    2f30:	93 83       	std	Z+3, r25	; 0x03
    2f32:	82 83       	std	Z+2, r24	; 0x02
    2f34:	15 83       	std	Z+5, r17	; 0x05
    2f36:	04 83       	std	Z+4, r16	; 0x04
    2f38:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    2f3c:	20 e0       	ldi	r18, 0x00	; 0
    2f3e:	30 e0       	ldi	r19, 0x00	; 0
    2f40:	8d b7       	in	r24, 0x3d	; 61
    2f42:	9e b7       	in	r25, 0x3e	; 62
    2f44:	06 96       	adiw	r24, 0x06	; 6
    2f46:	0f b6       	in	r0, 0x3f	; 63
    2f48:	f8 94       	cli
    2f4a:	9e bf       	out	0x3e, r25	; 62
    2f4c:	0f be       	out	0x3f, r0	; 63
    2f4e:	8d bf       	out	0x3d, r24	; 61
    2f50:	11 c0       	rjmp	.+34     	; 0x2f74 <debugFunction+0x1bc>
      return OK_SILENT;  
    }
    
    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2f52:	c8 01       	movw	r24, r16
    2f54:	67 ea       	ldi	r22, 0xA7	; 167
    2f56:	7a e0       	ldi	r23, 0x0A	; 10
    2f58:	42 e0       	ldi	r20, 0x02	; 2
    2f5a:	50 e0       	ldi	r21, 0x00	; 0
    2f5c:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    2f60:	89 2b       	or	r24, r25
    2f62:	31 f4       	brne	.+12     	; 0x2f70 <debugFunction+0x1b8>
    {
      setUdpDebug(state->myStdInOut, level);
    2f64:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f66:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2f68:	6f 2d       	mov	r22, r15
    2f6a:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <setUdpDebug>
    2f6e:	d0 cf       	rjmp	.-96     	; 0x2f10 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    2f70:	22 e0       	ldi	r18, 0x02	; 2
    2f72:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  
  return SYNTAX_ERROR;
}
    2f74:	c9 01       	movw	r24, r18
    2f76:	df 91       	pop	r29
    2f78:	cf 91       	pop	r28
    2f7a:	1f 91       	pop	r17
    2f7c:	0f 91       	pop	r16
    2f7e:	ff 90       	pop	r15
    2f80:	08 95       	ret

00002f82 <statusEncFunction>:
  return OK_SILENT; 
}

static cliExRes_t statusEncFunction(cmdState_t *state)
{
  nicRegDump(state->myStdInOut);
    2f82:	fc 01       	movw	r30, r24
    2f84:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f86:	93 8d       	ldd	r25, Z+27	; 0x1b
    2f88:	0e 94 57 2a 	call	0x54ae	; 0x54ae <nicRegDump>
  return OK_SILENT;
}
    2f8c:	80 e0       	ldi	r24, 0x00	; 0
    2f8e:	90 e0       	ldi	r25, 0x00	; 0
    2f90:	08 95       	ret

00002f92 <readRamFIleFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
{
    2f92:	cf 92       	push	r12
    2f94:	df 92       	push	r13
    2f96:	ef 92       	push	r14
    2f98:	ff 92       	push	r15
    2f9a:	0f 93       	push	r16
    2f9c:	1f 93       	push	r17
    2f9e:	df 93       	push	r29
    2fa0:	cf 93       	push	r28
    2fa2:	0f 92       	push	r0
    2fa4:	cd b7       	in	r28, 0x3d	; 61
    2fa6:	de b7       	in	r29, 0x3e	; 62
    2fa8:	8c 01       	movw	r16, r24
  uint8_t rezultat;
  uint8_t znak = ' ';
    2faa:	80 e2       	ldi	r24, 0x20	; 32
    2fac:	89 83       	std	Y+1, r24	; 0x01
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
    2fae:	81 e0       	ldi	r24, 0x01	; 1
    2fb0:	b8 01       	movw	r22, r16
    2fb2:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2fb6:	64 e6       	ldi	r22, 0x64	; 100
    2fb8:	7f e0       	ldi	r23, 0x0F	; 15
    2fba:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <ramDyskOtworzPlik>
    2fbe:	d8 01       	movw	r26, r16
    2fc0:	5a 96       	adiw	r26, 0x1a	; 26
    2fc2:	ed 90       	ld	r14, X+
    2fc4:	fc 90       	ld	r15, X
    2fc6:	5b 97       	sbiw	r26, 0x1b	; 27
    2fc8:	88 23       	and	r24, r24
    2fca:	19 f1       	breq	.+70     	; 0x3012 <readRamFIleFunction+0x80>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2fcc:	81 e0       	ldi	r24, 0x01	; 1
    2fce:	b8 01       	movw	r22, r16
    2fd0:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    2fd4:	00 d0       	rcall	.+0      	; 0x2fd6 <readRamFIleFunction+0x44>
    2fd6:	00 d0       	rcall	.+0      	; 0x2fd8 <readRamFIleFunction+0x46>
    2fd8:	00 d0       	rcall	.+0      	; 0x2fda <readRamFIleFunction+0x48>
    2fda:	ed b7       	in	r30, 0x3d	; 61
    2fdc:	fe b7       	in	r31, 0x3e	; 62
    2fde:	31 96       	adiw	r30, 0x01	; 1
    2fe0:	ad b7       	in	r26, 0x3d	; 61
    2fe2:	be b7       	in	r27, 0x3e	; 62
    2fe4:	12 96       	adiw	r26, 0x02	; 2
    2fe6:	fc 92       	st	X, r15
    2fe8:	ee 92       	st	-X, r14
    2fea:	11 97       	sbiw	r26, 0x01	; 1
    2fec:	22 e8       	ldi	r18, 0x82	; 130
    2fee:	31 e0       	ldi	r19, 0x01	; 1
    2ff0:	33 83       	std	Z+3, r19	; 0x03
    2ff2:	22 83       	std	Z+2, r18	; 0x02
    2ff4:	95 83       	std	Z+5, r25	; 0x05
    2ff6:	84 83       	std	Z+4, r24	; 0x04
    2ff8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    2ffc:	24 e0       	ldi	r18, 0x04	; 4
    2ffe:	30 e0       	ldi	r19, 0x00	; 0
    3000:	ed b7       	in	r30, 0x3d	; 61
    3002:	fe b7       	in	r31, 0x3e	; 62
    3004:	36 96       	adiw	r30, 0x06	; 6
    3006:	0f b6       	in	r0, 0x3f	; 63
    3008:	f8 94       	cli
    300a:	fe bf       	out	0x3e, r31	; 62
    300c:	0f be       	out	0x3f, r0	; 63
    300e:	ed bf       	out	0x3d, r30	; 61
    3010:	58 c0       	rjmp	.+176    	; 0x30c2 <readRamFIleFunction+0x130>
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    3012:	20 91 68 0f 	lds	r18, 0x0F68
    3016:	30 91 69 0f 	lds	r19, 0x0F69
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    301a:	00 d0       	rcall	.+0      	; 0x301c <readRamFIleFunction+0x8a>
    301c:	00 d0       	rcall	.+0      	; 0x301e <readRamFIleFunction+0x8c>
    301e:	00 d0       	rcall	.+0      	; 0x3020 <readRamFIleFunction+0x8e>
    3020:	ad b7       	in	r26, 0x3d	; 61
    3022:	be b7       	in	r27, 0x3e	; 62
    3024:	11 96       	adiw	r26, 0x01	; 1
    3026:	ed b7       	in	r30, 0x3d	; 61
    3028:	fe b7       	in	r31, 0x3e	; 62
    302a:	f2 82       	std	Z+2, r15	; 0x02
    302c:	e1 82       	std	Z+1, r14	; 0x01
    302e:	80 e7       	ldi	r24, 0x70	; 112
    3030:	93 e0       	ldi	r25, 0x03	; 3
    3032:	13 96       	adiw	r26, 0x03	; 3
    3034:	9c 93       	st	X, r25
    3036:	8e 93       	st	-X, r24
    3038:	12 97       	sbiw	r26, 0x02	; 2
    303a:	f9 01       	movw	r30, r18
    303c:	92 81       	ldd	r25, Z+2	; 0x02
    303e:	80 e0       	ldi	r24, 0x00	; 0
    3040:	21 81       	ldd	r18, Z+1	; 0x01
    3042:	82 0f       	add	r24, r18
    3044:	91 1d       	adc	r25, r1
    3046:	15 96       	adiw	r26, 0x05	; 5
    3048:	9c 93       	st	X, r25
    304a:	8e 93       	st	-X, r24
    304c:	14 97       	sbiw	r26, 0x04	; 4
    304e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    3052:	8d b7       	in	r24, 0x3d	; 61
    3054:	9e b7       	in	r25, 0x3e	; 62
    3056:	06 96       	adiw	r24, 0x06	; 6
    3058:	0f b6       	in	r0, 0x3f	; 63
    305a:	f8 94       	cli
    305c:	9e bf       	out	0x3e, r25	; 62
    305e:	0f be       	out	0x3f, r0	; 63
    3060:	8d bf       	out	0x3d, r24	; 61
  while (rezultat == 0)
  {
    rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
    3062:	6e 01       	movw	r12, r28
    3064:	08 94       	sec
    3066:	c1 1c       	adc	r12, r1
    3068:	d1 1c       	adc	r13, r1
    306a:	84 e6       	ldi	r24, 0x64	; 100
    306c:	9f e0       	ldi	r25, 0x0F	; 15
    306e:	b6 01       	movw	r22, r12
    3070:	0e 94 16 1e 	call	0x3c2c	; 0x3c2c <ramDyskCzytajBajtZPliku>
    3074:	f8 2e       	mov	r15, r24
    
    uartVtySendByte(znak);
    3076:	89 81       	ldd	r24, Y+1	; 0x01
    3078:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
    if (znak == '\r')
    307c:	89 81       	ldd	r24, Y+1	; 0x01
    307e:	8d 30       	cpi	r24, 0x0D	; 13
    3080:	19 f4       	brne	.+6      	; 0x3088 <readRamFIleFunction+0xf6>
      uartVtySendByte('\n');
    3082:	8a e0       	ldi	r24, 0x0A	; 10
    3084:	0e 94 94 0b 	call	0x1728	; 0x1728 <uartVtySendByte>
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
  while (rezultat == 0)
    3088:	ff 20       	and	r15, r15
    308a:	79 f3       	breq	.-34     	; 0x306a <readRamFIleFunction+0xd8>
    
    uartVtySendByte(znak);
    if (znak == '\r')
      uartVtySendByte('\n');
  }
  fprintf_P(state->myStdInOut, nlStr);
    308c:	00 d0       	rcall	.+0      	; 0x308e <readRamFIleFunction+0xfc>
    308e:	00 d0       	rcall	.+0      	; 0x3090 <readRamFIleFunction+0xfe>
    3090:	d8 01       	movw	r26, r16
    3092:	5a 96       	adiw	r26, 0x1a	; 26
    3094:	8d 91       	ld	r24, X+
    3096:	9c 91       	ld	r25, X
    3098:	5b 97       	sbiw	r26, 0x1b	; 27
    309a:	ed b7       	in	r30, 0x3d	; 61
    309c:	fe b7       	in	r31, 0x3e	; 62
    309e:	92 83       	std	Z+2, r25	; 0x02
    30a0:	81 83       	std	Z+1, r24	; 0x01
    30a2:	85 e0       	ldi	r24, 0x05	; 5
    30a4:	99 e0       	ldi	r25, 0x09	; 9
    30a6:	94 83       	std	Z+4, r25	; 0x04
    30a8:	83 83       	std	Z+3, r24	; 0x03
    30aa:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  ramDyskZamknijPlik(&fdVty);
    30ae:	0f 90       	pop	r0
    30b0:	0f 90       	pop	r0
    30b2:	0f 90       	pop	r0
    30b4:	0f 90       	pop	r0
    30b6:	84 e6       	ldi	r24, 0x64	; 100
    30b8:	9f e0       	ldi	r25, 0x0F	; 15
    30ba:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <ramDyskZamknijPlik>
    30be:	20 e0       	ldi	r18, 0x00	; 0
    30c0:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    30c2:	c9 01       	movw	r24, r18
    30c4:	0f 90       	pop	r0
    30c6:	cf 91       	pop	r28
    30c8:	df 91       	pop	r29
    30ca:	1f 91       	pop	r17
    30cc:	0f 91       	pop	r16
    30ce:	ff 90       	pop	r15
    30d0:	ef 90       	pop	r14
    30d2:	df 90       	pop	r13
    30d4:	cf 90       	pop	r12
    30d6:	08 95       	ret

000030d8 <writeRamFileFunction>:
  return ERROR_INFORM;
}

static cliExRes_t writeRamFileFunction(cmdState_t *state)
{
  ramDyskDir(state->myStdInOut);
    30d8:	fc 01       	movw	r30, r24
    30da:	82 8d       	ldd	r24, Z+26	; 0x1a
    30dc:	93 8d       	ldd	r25, Z+27	; 0x1b
    30de:	0e 94 4a 1c 	call	0x3894	; 0x3894 <ramDyskDir>
  return OK_SILENT;
}
    30e2:	80 e0       	ldi	r24, 0x00	; 0
    30e4:	90 e0       	ldi	r25, 0x00	; 0
    30e6:	08 95       	ret

000030e8 <pokazCzasFunction>:
  nicRegDump(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
    30e8:	0f 93       	push	r16
    30ea:	1f 93       	push	r17
    30ec:	cf 93       	push	r28
    30ee:	df 93       	push	r29
    30f0:	8c 01       	movw	r16, r24
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
    30f2:	83 eb       	ldi	r24, 0xB3	; 179
    30f4:	9e e0       	ldi	r25, 0x0E	; 14
    30f6:	0e 94 3a 28 	call	0x5074	; 0x5074 <readTimeDecoded>
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    30fa:	20 91 b5 0e 	lds	r18, 0x0EB5
    30fe:	22 95       	swap	r18
    3100:	2f 70       	andi	r18, 0x0F	; 15
    3102:	40 91 b5 0e 	lds	r20, 0x0EB5
    3106:	4f 70       	andi	r20, 0x0F	; 15
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    3108:	70 91 b4 0e 	lds	r23, 0x0EB4
    310c:	72 95       	swap	r23
    310e:	7f 70       	andi	r23, 0x0F	; 15
    3110:	50 91 b4 0e 	lds	r21, 0x0EB4
    3114:	5f 70       	andi	r21, 0x0F	; 15
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    3116:	a0 91 b3 0e 	lds	r26, 0x0EB3
    311a:	a2 95       	swap	r26
    311c:	af 70       	andi	r26, 0x0F	; 15
    311e:	60 91 b3 0e 	lds	r22, 0x0EB3
    3122:	6f 70       	andi	r22, 0x0F	; 15
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    3124:	8d b7       	in	r24, 0x3d	; 61
    3126:	9e b7       	in	r25, 0x3e	; 62
    3128:	0a 97       	sbiw	r24, 0x0a	; 10
    312a:	0f b6       	in	r0, 0x3f	; 63
    312c:	f8 94       	cli
    312e:	9e bf       	out	0x3e, r25	; 62
    3130:	0f be       	out	0x3f, r0	; 63
    3132:	8d bf       	out	0x3d, r24	; 61
    3134:	ed b7       	in	r30, 0x3d	; 61
    3136:	fe b7       	in	r31, 0x3e	; 62
    3138:	31 96       	adiw	r30, 0x01	; 1
    313a:	e8 01       	movw	r28, r16
    313c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    313e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3140:	cd b7       	in	r28, 0x3d	; 61
    3142:	de b7       	in	r29, 0x3e	; 62
    3144:	9a 83       	std	Y+2, r25	; 0x02
    3146:	89 83       	std	Y+1, r24	; 0x01
    3148:	8f ec       	ldi	r24, 0xCF	; 207
    314a:	9a e0       	ldi	r25, 0x0A	; 10
    314c:	93 83       	std	Z+3, r25	; 0x03
    314e:	82 83       	std	Z+2, r24	; 0x02
    3150:	82 2f       	mov	r24, r18
    3152:	83 70       	andi	r24, 0x03	; 3
    3154:	90 e0       	ldi	r25, 0x00	; 0
    3156:	9c 01       	movw	r18, r24
    3158:	13 e0       	ldi	r17, 0x03	; 3
    315a:	22 0f       	add	r18, r18
    315c:	33 1f       	adc	r19, r19
    315e:	1a 95       	dec	r17
    3160:	e1 f7       	brne	.-8      	; 0x315a <pokazCzasFunction+0x72>
    3162:	88 0f       	add	r24, r24
    3164:	99 1f       	adc	r25, r25
    3166:	28 0f       	add	r18, r24
    3168:	39 1f       	adc	r19, r25
    316a:	42 0f       	add	r20, r18
    316c:	44 83       	std	Z+4, r20	; 0x04
    316e:	15 82       	std	Z+5, r1	; 0x05
    3170:	87 2f       	mov	r24, r23
    3172:	87 70       	andi	r24, 0x07	; 7
    3174:	90 e0       	ldi	r25, 0x00	; 0
    3176:	9c 01       	movw	r18, r24
    3178:	73 e0       	ldi	r23, 0x03	; 3
    317a:	22 0f       	add	r18, r18
    317c:	33 1f       	adc	r19, r19
    317e:	7a 95       	dec	r23
    3180:	e1 f7       	brne	.-8      	; 0x317a <pokazCzasFunction+0x92>
    3182:	88 0f       	add	r24, r24
    3184:	99 1f       	adc	r25, r25
    3186:	28 0f       	add	r18, r24
    3188:	39 1f       	adc	r19, r25
    318a:	52 0f       	add	r21, r18
    318c:	56 83       	std	Z+6, r21	; 0x06
    318e:	17 82       	std	Z+7, r1	; 0x07
    3190:	8a 2f       	mov	r24, r26
    3192:	87 70       	andi	r24, 0x07	; 7
    3194:	90 e0       	ldi	r25, 0x00	; 0
    3196:	9c 01       	movw	r18, r24
    3198:	03 e0       	ldi	r16, 0x03	; 3
    319a:	22 0f       	add	r18, r18
    319c:	33 1f       	adc	r19, r19
    319e:	0a 95       	dec	r16
    31a0:	e1 f7       	brne	.-8      	; 0x319a <pokazCzasFunction+0xb2>
    31a2:	88 0f       	add	r24, r24
    31a4:	99 1f       	adc	r25, r25
    31a6:	28 0f       	add	r18, r24
    31a8:	39 1f       	adc	r19, r25
    31aa:	62 0f       	add	r22, r18
    31ac:	60 87       	std	Z+8, r22	; 0x08
    31ae:	11 86       	std	Z+9, r1	; 0x09
    31b0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    31b4:	8d b7       	in	r24, 0x3d	; 61
    31b6:	9e b7       	in	r25, 0x3e	; 62
    31b8:	0a 96       	adiw	r24, 0x0a	; 10
    31ba:	0f b6       	in	r0, 0x3f	; 63
    31bc:	f8 94       	cli
    31be:	9e bf       	out	0x3e, r25	; 62
    31c0:	0f be       	out	0x3f, r0	; 63
    31c2:	8d bf       	out	0x3d, r24	; 61
  return OK_SILENT;
}
    31c4:	80 e0       	ldi	r24, 0x00	; 0
    31c6:	90 e0       	ldi	r25, 0x00	; 0
    31c8:	df 91       	pop	r29
    31ca:	cf 91       	pop	r28
    31cc:	1f 91       	pop	r17
    31ce:	0f 91       	pop	r16
    31d0:	08 95       	ret

000031d2 <helpFunction>:
  return OK_SILENT;
}

static cliExRes_t helpFunction(cmdState_t *state)
{
  cmdPrintHelp(state);
    31d2:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <cmdPrintHelp>
  return OK_SILENT;
}
    31d6:	80 e0       	ldi	r24, 0x00	; 0
    31d8:	90 e0       	ldi	r25, 0x00	; 0
    31da:	08 95       	ret

000031dc <printStatus>:
  return ERROR_OPERATION_NOT_ALLOWED;
}

// ************************** VTY API ***************************************************************************************
void printStatus(FILE *stream)
{
    31dc:	cf 93       	push	r28
    31de:	df 93       	push	r29
    31e0:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
    31e2:	00 d0       	rcall	.+0      	; 0x31e4 <printStatus+0x8>
    31e4:	00 d0       	rcall	.+0      	; 0x31e6 <printStatus+0xa>
    31e6:	ad b7       	in	r26, 0x3d	; 61
    31e8:	be b7       	in	r27, 0x3e	; 62
    31ea:	12 96       	adiw	r26, 0x02	; 2
    31ec:	9c 93       	st	X, r25
    31ee:	8e 93       	st	-X, r24
    31f0:	11 97       	sbiw	r26, 0x01	; 1
    31f2:	84 ef       	ldi	r24, 0xF4	; 244
    31f4:	9a e0       	ldi	r25, 0x0A	; 10
    31f6:	14 96       	adiw	r26, 0x04	; 4
    31f8:	9c 93       	st	X, r25
    31fa:	8e 93       	st	-X, r24
    31fc:	13 97       	sbiw	r26, 0x03	; 3
    31fe:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  //Print system state
  fprintf_P(stream, systemStateStr);
    3202:	ed b7       	in	r30, 0x3d	; 61
    3204:	fe b7       	in	r31, 0x3e	; 62
    3206:	d2 83       	std	Z+2, r29	; 0x02
    3208:	c1 83       	std	Z+1, r28	; 0x01
    320a:	87 e9       	ldi	r24, 0x97	; 151
    320c:	91 e0       	ldi	r25, 0x01	; 1
    320e:	94 83       	std	Z+4, r25	; 0x04
    3210:	83 83       	std	Z+3, r24	; 0x03
    3212:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	0f 90       	pop	r0
    321e:	0e 94 f2 48 	call	0x91e4	; 0x91e4 <uxTaskGetNumberOfTasks>
    3222:	00 d0       	rcall	.+0      	; 0x3224 <printStatus+0x48>
    3224:	00 d0       	rcall	.+0      	; 0x3226 <printStatus+0x4a>
    3226:	00 d0       	rcall	.+0      	; 0x3228 <printStatus+0x4c>
    3228:	ed b7       	in	r30, 0x3d	; 61
    322a:	fe b7       	in	r31, 0x3e	; 62
    322c:	31 96       	adiw	r30, 0x01	; 1
    322e:	ad b7       	in	r26, 0x3d	; 61
    3230:	be b7       	in	r27, 0x3e	; 62
    3232:	12 96       	adiw	r26, 0x02	; 2
    3234:	dc 93       	st	X, r29
    3236:	ce 93       	st	-X, r28
    3238:	11 97       	sbiw	r26, 0x01	; 1
    323a:	27 ea       	ldi	r18, 0xA7	; 167
    323c:	31 e0       	ldi	r19, 0x01	; 1
    323e:	33 83       	std	Z+3, r19	; 0x03
    3240:	22 83       	std	Z+2, r18	; 0x02
    3242:	84 83       	std	Z+4, r24	; 0x04
    3244:	15 82       	std	Z+5, r1	; 0x05
    3246:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
    324a:	ed b7       	in	r30, 0x3d	; 61
    324c:	fe b7       	in	r31, 0x3e	; 62
    324e:	36 96       	adiw	r30, 0x06	; 6
    3250:	0f b6       	in	r0, 0x3f	; 63
    3252:	f8 94       	cli
    3254:	fe bf       	out	0x3e, r31	; 62
    3256:	0f be       	out	0x3f, r0	; 63
    3258:	ed bf       	out	0x3d, r30	; 61
    325a:	0e 94 46 55 	call	0xaa8c	; 0xaa8c <xPortGetFreeHeapSize>
    325e:	2d b7       	in	r18, 0x3d	; 61
    3260:	3e b7       	in	r19, 0x3e	; 62
    3262:	28 50       	subi	r18, 0x08	; 8
    3264:	30 40       	sbci	r19, 0x00	; 0
    3266:	0f b6       	in	r0, 0x3f	; 63
    3268:	f8 94       	cli
    326a:	3e bf       	out	0x3e, r19	; 62
    326c:	0f be       	out	0x3f, r0	; 63
    326e:	2d bf       	out	0x3d, r18	; 61
    3270:	ed b7       	in	r30, 0x3d	; 61
    3272:	fe b7       	in	r31, 0x3e	; 62
    3274:	31 96       	adiw	r30, 0x01	; 1
    3276:	ad b7       	in	r26, 0x3d	; 61
    3278:	be b7       	in	r27, 0x3e	; 62
    327a:	12 96       	adiw	r26, 0x02	; 2
    327c:	dc 93       	st	X, r29
    327e:	ce 93       	st	-X, r28
    3280:	11 97       	sbiw	r26, 0x01	; 1
    3282:	20 ec       	ldi	r18, 0xC0	; 192
    3284:	31 e0       	ldi	r19, 0x01	; 1
    3286:	33 83       	std	Z+3, r19	; 0x03
    3288:	22 83       	std	Z+2, r18	; 0x02
    328a:	95 83       	std	Z+5, r25	; 0x05
    328c:	84 83       	std	Z+4, r24	; 0x04
    328e:	8c e1       	ldi	r24, 0x1C	; 28
    3290:	9c e0       	ldi	r25, 0x0C	; 12
    3292:	97 83       	std	Z+7, r25	; 0x07
    3294:	86 83       	std	Z+6, r24	; 0x06
    3296:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
    329a:	ed b7       	in	r30, 0x3d	; 61
    329c:	fe b7       	in	r31, 0x3e	; 62
    329e:	38 96       	adiw	r30, 0x08	; 8
    32a0:	0f b6       	in	r0, 0x3f	; 63
    32a2:	f8 94       	cli
    32a4:	fe bf       	out	0x3e, r31	; 62
    32a6:	0f be       	out	0x3f, r0	; 63
    32a8:	ed bf       	out	0x3d, r30	; 61
    32aa:	0e 94 20 1c 	call	0x3840	; 0x3840 <xmallocAvailable>
    32ae:	2d b7       	in	r18, 0x3d	; 61
    32b0:	3e b7       	in	r19, 0x3e	; 62
    32b2:	28 50       	subi	r18, 0x08	; 8
    32b4:	30 40       	sbci	r19, 0x00	; 0
    32b6:	0f b6       	in	r0, 0x3f	; 63
    32b8:	f8 94       	cli
    32ba:	3e bf       	out	0x3e, r19	; 62
    32bc:	0f be       	out	0x3f, r0	; 63
    32be:	2d bf       	out	0x3d, r18	; 61
    32c0:	ed b7       	in	r30, 0x3d	; 61
    32c2:	fe b7       	in	r31, 0x3e	; 62
    32c4:	31 96       	adiw	r30, 0x01	; 1
    32c6:	ad b7       	in	r26, 0x3d	; 61
    32c8:	be b7       	in	r27, 0x3e	; 62
    32ca:	12 96       	adiw	r26, 0x02	; 2
    32cc:	dc 93       	st	X, r29
    32ce:	ce 93       	st	-X, r28
    32d0:	11 97       	sbiw	r26, 0x01	; 1
    32d2:	2a ee       	ldi	r18, 0xEA	; 234
    32d4:	31 e0       	ldi	r19, 0x01	; 1
    32d6:	33 83       	std	Z+3, r19	; 0x03
    32d8:	22 83       	std	Z+2, r18	; 0x02
    32da:	95 83       	std	Z+5, r25	; 0x05
    32dc:	84 83       	std	Z+4, r24	; 0x04
    32de:	80 e0       	ldi	r24, 0x00	; 0
    32e0:	97 e1       	ldi	r25, 0x17	; 23
    32e2:	97 83       	std	Z+7, r25	; 0x07
    32e4:	86 83       	std	Z+6, r24	; 0x06
    32e6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, statusTemperatureStr, temperature); 
    32ea:	20 91 a4 0e 	lds	r18, 0x0EA4
    32ee:	0f 90       	pop	r0
    32f0:	0f 90       	pop	r0
    32f2:	ed b7       	in	r30, 0x3d	; 61
    32f4:	fe b7       	in	r31, 0x3e	; 62
    32f6:	31 96       	adiw	r30, 0x01	; 1
    32f8:	ad b7       	in	r26, 0x3d	; 61
    32fa:	be b7       	in	r27, 0x3e	; 62
    32fc:	12 96       	adiw	r26, 0x02	; 2
    32fe:	dc 93       	st	X, r29
    3300:	ce 93       	st	-X, r28
    3302:	11 97       	sbiw	r26, 0x01	; 1
    3304:	81 e4       	ldi	r24, 0x41	; 65
    3306:	92 e0       	ldi	r25, 0x02	; 2
    3308:	93 83       	std	Z+3, r25	; 0x03
    330a:	82 83       	std	Z+2, r24	; 0x02
    330c:	24 83       	std	Z+4, r18	; 0x04
    330e:	15 82       	std	Z+5, r1	; 0x05
    3310:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, statusVoltageStr, voltage); 
    3314:	20 91 ac 0e 	lds	r18, 0x0EAC
    3318:	ed b7       	in	r30, 0x3d	; 61
    331a:	fe b7       	in	r31, 0x3e	; 62
    331c:	31 96       	adiw	r30, 0x01	; 1
    331e:	ad b7       	in	r26, 0x3d	; 61
    3320:	be b7       	in	r27, 0x3e	; 62
    3322:	12 96       	adiw	r26, 0x02	; 2
    3324:	dc 93       	st	X, r29
    3326:	ce 93       	st	-X, r28
    3328:	11 97       	sbiw	r26, 0x01	; 1
    332a:	8c e5       	ldi	r24, 0x5C	; 92
    332c:	92 e0       	ldi	r25, 0x02	; 2
    332e:	93 83       	std	Z+3, r25	; 0x03
    3330:	82 83       	std	Z+2, r24	; 0x02
    3332:	24 83       	std	Z+4, r18	; 0x04
    3334:	15 82       	std	Z+5, r1	; 0x05
    3336:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>

  uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
    333a:	ed b7       	in	r30, 0x3d	; 61
    333c:	fe b7       	in	r31, 0x3e	; 62
    333e:	36 96       	adiw	r30, 0x06	; 6
    3340:	0f b6       	in	r0, 0x3f	; 63
    3342:	f8 94       	cli
    3344:	fe bf       	out	0x3e, r31	; 62
    3346:	0f be       	out	0x3f, r0	; 63
    3348:	ed bf       	out	0x3d, r30	; 61
    334a:	0e 94 3c 1c 	call	0x3878	; 0x3878 <ramDyskLiczbaWolnychKlastrow>
  fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
    334e:	2d b7       	in	r18, 0x3d	; 61
    3350:	3e b7       	in	r19, 0x3e	; 62
    3352:	28 50       	subi	r18, 0x08	; 8
    3354:	30 40       	sbci	r19, 0x00	; 0
    3356:	0f b6       	in	r0, 0x3f	; 63
    3358:	f8 94       	cli
    335a:	3e bf       	out	0x3e, r19	; 62
    335c:	0f be       	out	0x3f, r0	; 63
    335e:	2d bf       	out	0x3d, r18	; 61
    3360:	ed b7       	in	r30, 0x3d	; 61
    3362:	fe b7       	in	r31, 0x3e	; 62
    3364:	31 96       	adiw	r30, 0x01	; 1
    3366:	ad b7       	in	r26, 0x3d	; 61
    3368:	be b7       	in	r27, 0x3e	; 62
    336a:	12 96       	adiw	r26, 0x02	; 2
    336c:	dc 93       	st	X, r29
    336e:	ce 93       	st	-X, r28
    3370:	11 97       	sbiw	r26, 0x01	; 1
    3372:	24 e1       	ldi	r18, 0x14	; 20
    3374:	32 e0       	ldi	r19, 0x02	; 2
    3376:	33 83       	std	Z+3, r19	; 0x03
    3378:	22 83       	std	Z+2, r18	; 0x02
    337a:	84 83       	std	Z+4, r24	; 0x04
    337c:	15 82       	std	Z+5, r1	; 0x05
    337e:	80 e8       	ldi	r24, 0x80	; 128
    3380:	90 e0       	ldi	r25, 0x00	; 0
    3382:	97 83       	std	Z+7, r25	; 0x07
    3384:	86 83       	std	Z+6, r24	; 0x06
    3386:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
//  printErrorInfo(state); //TODO fix and uncomment
  
  //Print system configuration
  fprintf_P(stream, systemRamConfigStr);
    338a:	0f 90       	pop	r0
    338c:	0f 90       	pop	r0
    338e:	0f 90       	pop	r0
    3390:	0f 90       	pop	r0
    3392:	ed b7       	in	r30, 0x3d	; 61
    3394:	fe b7       	in	r31, 0x3e	; 62
    3396:	d2 83       	std	Z+2, r29	; 0x02
    3398:	c1 83       	std	Z+1, r28	; 0x01
    339a:	87 e7       	ldi	r24, 0x77	; 119
    339c:	92 e0       	ldi	r25, 0x02	; 2
    339e:	94 83       	std	Z+4, r25	; 0x04
    33a0:	83 83       	std	Z+3, r24	; 0x03
    33a2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>

  fprintf_P(stream, statusMacStr);
    33a6:	ad b7       	in	r26, 0x3d	; 61
    33a8:	be b7       	in	r27, 0x3e	; 62
    33aa:	12 96       	adiw	r26, 0x02	; 2
    33ac:	dc 93       	st	X, r29
    33ae:	ce 93       	st	-X, r28
    33b0:	11 97       	sbiw	r26, 0x01	; 1
    33b2:	8a e8       	ldi	r24, 0x8A	; 138
    33b4:	92 e0       	ldi	r25, 0x02	; 2
    33b6:	14 96       	adiw	r26, 0x04	; 4
    33b8:	9c 93       	st	X, r25
    33ba:	8e 93       	st	-X, r24
    33bc:	13 97       	sbiw	r26, 0x03	; 3
    33be:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    33c2:	0f 90       	pop	r0
    33c4:	0f 90       	pop	r0
    33c6:	0f 90       	pop	r0
    33c8:	0f 90       	pop	r0
    33ca:	ce 01       	movw	r24, r28
    33cc:	60 e8       	ldi	r22, 0x80	; 128
    33ce:	7e e0       	ldi	r23, 0x0E	; 14
    33d0:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <netPrintEthAddr>
  fprintf_P(stream, PSTR("\r\n"));
    33d4:	00 d0       	rcall	.+0      	; 0x33d6 <printStatus+0x1fa>
    33d6:	00 d0       	rcall	.+0      	; 0x33d8 <printStatus+0x1fc>
    33d8:	ed b7       	in	r30, 0x3d	; 61
    33da:	fe b7       	in	r31, 0x3e	; 62
    33dc:	d2 83       	std	Z+2, r29	; 0x02
    33de:	c1 83       	std	Z+1, r28	; 0x01
    33e0:	81 ef       	ldi	r24, 0xF1	; 241
    33e2:	9a e0       	ldi	r25, 0x0A	; 10
    33e4:	94 83       	std	Z+4, r25	; 0x04
    33e6:	83 83       	std	Z+3, r24	; 0x03
    33e8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  
  fprintf_P(stream, statusIpStr);
    33ec:	ad b7       	in	r26, 0x3d	; 61
    33ee:	be b7       	in	r27, 0x3e	; 62
    33f0:	12 96       	adiw	r26, 0x02	; 2
    33f2:	dc 93       	st	X, r29
    33f4:	ce 93       	st	-X, r28
    33f6:	11 97       	sbiw	r26, 0x01	; 1
    33f8:	8f e9       	ldi	r24, 0x9F	; 159
    33fa:	92 e0       	ldi	r25, 0x02	; 2
    33fc:	14 96       	adiw	r26, 0x04	; 4
    33fe:	9c 93       	st	X, r25
    3400:	8e 93       	st	-X, r24
    3402:	13 97       	sbiw	r26, 0x03	; 3
    3404:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->ip);
    3408:	0f 90       	pop	r0
    340a:	0f 90       	pop	r0
    340c:	0f 90       	pop	r0
    340e:	0f 90       	pop	r0
    3410:	0e 94 11 32 	call	0x6422	; 0x6422 <ipGetConfig>
    3414:	fc 01       	movw	r30, r24
    3416:	40 81       	ld	r20, Z
    3418:	51 81       	ldd	r21, Z+1	; 0x01
    341a:	62 81       	ldd	r22, Z+2	; 0x02
    341c:	73 81       	ldd	r23, Z+3	; 0x03
    341e:	ce 01       	movw	r24, r28
    3420:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3424:	00 d0       	rcall	.+0      	; 0x3426 <printStatus+0x24a>
    3426:	00 d0       	rcall	.+0      	; 0x3428 <printStatus+0x24c>
    3428:	ed b7       	in	r30, 0x3d	; 61
    342a:	fe b7       	in	r31, 0x3e	; 62
    342c:	d2 83       	std	Z+2, r29	; 0x02
    342e:	c1 83       	std	Z+1, r28	; 0x01
    3430:	8e ee       	ldi	r24, 0xEE	; 238
    3432:	9a e0       	ldi	r25, 0x0A	; 10
    3434:	94 83       	std	Z+4, r25	; 0x04
    3436:	83 83       	std	Z+3, r24	; 0x03
    3438:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>

  fprintf_P(stream, statusIpMaskStr);
    343c:	ad b7       	in	r26, 0x3d	; 61
    343e:	be b7       	in	r27, 0x3e	; 62
    3440:	12 96       	adiw	r26, 0x02	; 2
    3442:	dc 93       	st	X, r29
    3444:	ce 93       	st	-X, r28
    3446:	11 97       	sbiw	r26, 0x01	; 1
    3448:	84 eb       	ldi	r24, 0xB4	; 180
    344a:	92 e0       	ldi	r25, 0x02	; 2
    344c:	14 96       	adiw	r26, 0x04	; 4
    344e:	9c 93       	st	X, r25
    3450:	8e 93       	st	-X, r24
    3452:	13 97       	sbiw	r26, 0x03	; 3
    3454:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->netmask);
    3458:	0f 90       	pop	r0
    345a:	0f 90       	pop	r0
    345c:	0f 90       	pop	r0
    345e:	0f 90       	pop	r0
    3460:	0e 94 11 32 	call	0x6422	; 0x6422 <ipGetConfig>
    3464:	fc 01       	movw	r30, r24
    3466:	44 81       	ldd	r20, Z+4	; 0x04
    3468:	55 81       	ldd	r21, Z+5	; 0x05
    346a:	66 81       	ldd	r22, Z+6	; 0x06
    346c:	77 81       	ldd	r23, Z+7	; 0x07
    346e:	ce 01       	movw	r24, r28
    3470:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3474:	00 d0       	rcall	.+0      	; 0x3476 <printStatus+0x29a>
    3476:	00 d0       	rcall	.+0      	; 0x3478 <printStatus+0x29c>
    3478:	ad b7       	in	r26, 0x3d	; 61
    347a:	be b7       	in	r27, 0x3e	; 62
    347c:	12 96       	adiw	r26, 0x02	; 2
    347e:	dc 93       	st	X, r29
    3480:	ce 93       	st	-X, r28
    3482:	11 97       	sbiw	r26, 0x01	; 1
    3484:	8b ee       	ldi	r24, 0xEB	; 235
    3486:	9a e0       	ldi	r25, 0x0A	; 10
    3488:	14 96       	adiw	r26, 0x04	; 4
    348a:	9c 93       	st	X, r25
    348c:	8e 93       	st	-X, r24
    348e:	13 97       	sbiw	r26, 0x03	; 3
    3490:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  
  fprintf_P(stream, statusIpGwStr);
    3494:	ed b7       	in	r30, 0x3d	; 61
    3496:	fe b7       	in	r31, 0x3e	; 62
    3498:	d2 83       	std	Z+2, r29	; 0x02
    349a:	c1 83       	std	Z+1, r28	; 0x01
    349c:	89 ec       	ldi	r24, 0xC9	; 201
    349e:	92 e0       	ldi	r25, 0x02	; 2
    34a0:	94 83       	std	Z+4, r25	; 0x04
    34a2:	83 83       	std	Z+3, r24	; 0x03
    34a4:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->gateway);
    34a8:	0f 90       	pop	r0
    34aa:	0f 90       	pop	r0
    34ac:	0f 90       	pop	r0
    34ae:	0f 90       	pop	r0
    34b0:	0e 94 11 32 	call	0x6422	; 0x6422 <ipGetConfig>
    34b4:	dc 01       	movw	r26, r24
    34b6:	18 96       	adiw	r26, 0x08	; 8
    34b8:	4d 91       	ld	r20, X+
    34ba:	5d 91       	ld	r21, X+
    34bc:	6d 91       	ld	r22, X+
    34be:	7c 91       	ld	r23, X
    34c0:	1b 97       	sbiw	r26, 0x0b	; 11
    34c2:	ce 01       	movw	r24, r28
    34c4:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    34c8:	00 d0       	rcall	.+0      	; 0x34ca <printStatus+0x2ee>
    34ca:	00 d0       	rcall	.+0      	; 0x34cc <printStatus+0x2f0>
    34cc:	ed b7       	in	r30, 0x3d	; 61
    34ce:	fe b7       	in	r31, 0x3e	; 62
    34d0:	d2 83       	std	Z+2, r29	; 0x02
    34d2:	c1 83       	std	Z+1, r28	; 0x01
    34d4:	88 ee       	ldi	r24, 0xE8	; 232
    34d6:	9a e0       	ldi	r25, 0x0A	; 10
    34d8:	94 83       	std	Z+4, r25	; 0x04
    34da:	83 83       	std	Z+3, r24	; 0x03
    34dc:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  
  //Print Rs485 Execitive modules
  fprintf_P(stream, statusRs485listStr);
    34e0:	ad b7       	in	r26, 0x3d	; 61
    34e2:	be b7       	in	r27, 0x3e	; 62
    34e4:	12 96       	adiw	r26, 0x02	; 2
    34e6:	dc 93       	st	X, r29
    34e8:	ce 93       	st	-X, r28
    34ea:	11 97       	sbiw	r26, 0x01	; 1
    34ec:	8e ed       	ldi	r24, 0xDE	; 222
    34ee:	92 e0       	ldi	r25, 0x02	; 2
    34f0:	14 96       	adiw	r26, 0x04	; 4
    34f2:	9c 93       	st	X, r25
    34f4:	8e 93       	st	-X, r24
    34f6:	13 97       	sbiw	r26, 0x03	; 3
    34f8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  tmp = printRs485devices(stream);
    34fc:	0f 90       	pop	r0
    34fe:	0f 90       	pop	r0
    3500:	0f 90       	pop	r0
    3502:	0f 90       	pop	r0
    3504:	ce 01       	movw	r24, r28
    3506:	0e 94 52 41 	call	0x82a4	; 0x82a4 <printRs485devices>
  if (tmp == 0)
    350a:	88 23       	and	r24, r24
    350c:	81 f4       	brne	.+32     	; 0x352e <printStatus+0x352>
    fprintf_P(stream, statusNoRs485Dev);  
    350e:	00 d0       	rcall	.+0      	; 0x3510 <printStatus+0x334>
    3510:	00 d0       	rcall	.+0      	; 0x3512 <printStatus+0x336>
    3512:	ed b7       	in	r30, 0x3d	; 61
    3514:	fe b7       	in	r31, 0x3e	; 62
    3516:	d2 83       	std	Z+2, r29	; 0x02
    3518:	c1 83       	std	Z+1, r28	; 0x01
    351a:	89 ef       	ldi	r24, 0xF9	; 249
    351c:	92 e0       	ldi	r25, 0x02	; 2
    351e:	94 83       	std	Z+4, r25	; 0x04
    3520:	83 83       	std	Z+3, r24	; 0x03
    3522:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    3526:	0f 90       	pop	r0
    3528:	0f 90       	pop	r0
    352a:	0f 90       	pop	r0
    352c:	0f 90       	pop	r0
  
  //Print locker sensors
  fprintf_P(stream, statusLockerSensorsStr);
    352e:	00 d0       	rcall	.+0      	; 0x3530 <printStatus+0x354>
    3530:	00 d0       	rcall	.+0      	; 0x3532 <printStatus+0x356>
    3532:	ad b7       	in	r26, 0x3d	; 61
    3534:	be b7       	in	r27, 0x3e	; 62
    3536:	12 96       	adiw	r26, 0x02	; 2
    3538:	dc 93       	st	X, r29
    353a:	ce 93       	st	-X, r28
    353c:	11 97       	sbiw	r26, 0x01	; 1
    353e:	83 e1       	ldi	r24, 0x13	; 19
    3540:	93 e0       	ldi	r25, 0x03	; 3
    3542:	14 96       	adiw	r26, 0x04	; 4
    3544:	9c 93       	st	X, r25
    3546:	8e 93       	st	-X, r24
    3548:	13 97       	sbiw	r26, 0x03	; 3
    354a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  tmp = printLockers(stream);
    354e:	0f 90       	pop	r0
    3550:	0f 90       	pop	r0
    3552:	0f 90       	pop	r0
    3554:	0f 90       	pop	r0
    3556:	ce 01       	movw	r24, r28
    3558:	0e 94 62 0e 	call	0x1cc4	; 0x1cc4 <printLockers>
  if (tmp == 0)
    355c:	88 23       	and	r24, r24
    355e:	81 f4       	brne	.+32     	; 0x3580 <printStatus+0x3a4>
    fprintf_P(stream, statusLockerSensorsDisStr);
    3560:	00 d0       	rcall	.+0      	; 0x3562 <printStatus+0x386>
    3562:	00 d0       	rcall	.+0      	; 0x3564 <printStatus+0x388>
    3564:	ed b7       	in	r30, 0x3d	; 61
    3566:	fe b7       	in	r31, 0x3e	; 62
    3568:	d2 83       	std	Z+2, r29	; 0x02
    356a:	c1 83       	std	Z+1, r28	; 0x01
    356c:	8c e2       	ldi	r24, 0x2C	; 44
    356e:	93 e0       	ldi	r25, 0x03	; 3
    3570:	94 83       	std	Z+4, r25	; 0x04
    3572:	83 83       	std	Z+3, r24	; 0x03
    3574:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    3578:	0f 90       	pop	r0
    357a:	0f 90       	pop	r0
    357c:	0f 90       	pop	r0
    357e:	0f 90       	pop	r0
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    3580:	ce 01       	movw	r24, r28
    3582:	0e 94 40 3d 	call	0x7a80	; 0x7a80 <udpPrintStatus>
//  arpPrintTable(stream);
}
    3586:	df 91       	pop	r29
    3588:	cf 91       	pop	r28
    358a:	08 95       	ret

0000358c <statusFunction>:


// ************************** CLI Functions *********************************************************************************

static cliExRes_t statusFunction(cmdState_t *state)
{
    358c:	ef 92       	push	r14
    358e:	ff 92       	push	r15
    3590:	0f 93       	push	r16
    3592:	1f 93       	push	r17
    3594:	df 93       	push	r29
    3596:	cf 93       	push	r28
    3598:	cd b7       	in	r28, 0x3d	; 61
    359a:	de b7       	in	r29, 0x3e	; 62
    359c:	2e 97       	sbiw	r28, 0x0e	; 14
    359e:	0f b6       	in	r0, 0x3f	; 63
    35a0:	f8 94       	cli
    35a2:	de bf       	out	0x3e, r29	; 62
    35a4:	0f be       	out	0x3f, r0	; 63
    35a6:	cd bf       	out	0x3d, r28	; 61
    35a8:	7c 01       	movw	r14, r24
  if (state->argc < 1)
    35aa:	dc 01       	movw	r26, r24
    35ac:	59 96       	adiw	r26, 0x19	; 25
    35ae:	8c 91       	ld	r24, X
    35b0:	59 97       	sbiw	r26, 0x19	; 25
    35b2:	88 23       	and	r24, r24
    35b4:	39 f4       	brne	.+14     	; 0x35c4 <statusFunction+0x38>
  {
    printStatus(state->myStdInOut);
    35b6:	5a 96       	adiw	r26, 0x1a	; 26
    35b8:	8d 91       	ld	r24, X+
    35ba:	9c 91       	ld	r25, X
    35bc:	5b 97       	sbiw	r26, 0x1b	; 27
    35be:	0e 94 ee 18 	call	0x31dc	; 0x31dc <printStatus>
    35c2:	3b c0       	rjmp	.+118    	; 0x363a <statusFunction+0xae>
    return OK_SILENT; 
  }
  
  FILE stream;
  if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
    35c4:	81 e0       	ldi	r24, 0x01	; 1
    35c6:	b7 01       	movw	r22, r14
    35c8:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    35cc:	64 e6       	ldi	r22, 0x64	; 100
    35ce:	7f e0       	ldi	r23, 0x0F	; 15
    35d0:	8e 01       	movw	r16, r28
    35d2:	0f 5f       	subi	r16, 0xFF	; 255
    35d4:	1f 4f       	sbci	r17, 0xFF	; 255
    35d6:	a8 01       	movw	r20, r16
    35d8:	23 e0       	ldi	r18, 0x03	; 3
    35da:	0e 94 0a 21 	call	0x4214	; 0x4214 <ramDyskOtworzPlikStdIo>
    35de:	88 23       	and	r24, r24
    35e0:	31 f1       	breq	.+76     	; 0x362e <statusFunction+0xa2>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    35e2:	f7 01       	movw	r30, r14
    35e4:	02 8d       	ldd	r16, Z+26	; 0x1a
    35e6:	13 8d       	ldd	r17, Z+27	; 0x1b
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	b7 01       	movw	r22, r14
    35ec:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    35f0:	00 d0       	rcall	.+0      	; 0x35f2 <statusFunction+0x66>
    35f2:	00 d0       	rcall	.+0      	; 0x35f4 <statusFunction+0x68>
    35f4:	00 d0       	rcall	.+0      	; 0x35f6 <statusFunction+0x6a>
    35f6:	ed b7       	in	r30, 0x3d	; 61
    35f8:	fe b7       	in	r31, 0x3e	; 62
    35fa:	31 96       	adiw	r30, 0x01	; 1
    35fc:	ad b7       	in	r26, 0x3d	; 61
    35fe:	be b7       	in	r27, 0x3e	; 62
    3600:	12 96       	adiw	r26, 0x02	; 2
    3602:	1c 93       	st	X, r17
    3604:	0e 93       	st	-X, r16
    3606:	11 97       	sbiw	r26, 0x01	; 1
    3608:	22 e8       	ldi	r18, 0x82	; 130
    360a:	31 e0       	ldi	r19, 0x01	; 1
    360c:	33 83       	std	Z+3, r19	; 0x03
    360e:	22 83       	std	Z+2, r18	; 0x02
    3610:	95 83       	std	Z+5, r25	; 0x05
    3612:	84 83       	std	Z+4, r24	; 0x04
    3614:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    3618:	24 e0       	ldi	r18, 0x04	; 4
    361a:	30 e0       	ldi	r19, 0x00	; 0
    361c:	ed b7       	in	r30, 0x3d	; 61
    361e:	fe b7       	in	r31, 0x3e	; 62
    3620:	36 96       	adiw	r30, 0x06	; 6
    3622:	0f b6       	in	r0, 0x3f	; 63
    3624:	f8 94       	cli
    3626:	fe bf       	out	0x3e, r31	; 62
    3628:	0f be       	out	0x3f, r0	; 63
    362a:	ed bf       	out	0x3d, r30	; 61
    362c:	08 c0       	rjmp	.+16     	; 0x363e <statusFunction+0xb2>
    return ERROR_INFORM;
  }

  printStatus(&stream);
    362e:	c8 01       	movw	r24, r16
    3630:	0e 94 ee 18 	call	0x31dc	; 0x31dc <printStatus>
  ramDyskZamknijPlikStdIo(&stream);
    3634:	c8 01       	movw	r24, r16
    3636:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <ramDyskZamknijPlikStdIo>
    363a:	20 e0       	ldi	r18, 0x00	; 0
    363c:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT; 
}
    363e:	c9 01       	movw	r24, r18
    3640:	2e 96       	adiw	r28, 0x0e	; 14
    3642:	0f b6       	in	r0, 0x3f	; 63
    3644:	f8 94       	cli
    3646:	de bf       	out	0x3e, r29	; 62
    3648:	0f be       	out	0x3f, r0	; 63
    364a:	cd bf       	out	0x3d, r28	; 61
    364c:	cf 91       	pop	r28
    364e:	df 91       	pop	r29
    3650:	1f 91       	pop	r17
    3652:	0f 91       	pop	r16
    3654:	ff 90       	pop	r15
    3656:	ef 90       	pop	r14
    3658:	08 95       	ret

0000365a <VtyInit>:
  {cmd_disable,      cmd_help_disable,      disableFunction},
  {NULL, NULL, NULL}
};

void VtyInit(cmdState_t* state, FILE *stream)
{
    365a:	ef 92       	push	r14
    365c:	0f 93       	push	r16
    365e:	1f 93       	push	r17
    3660:	9b 01       	movw	r18, r22
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
    3662:	60 e0       	ldi	r22, 0x00	; 0
    3664:	78 e2       	ldi	r23, 0x28	; 40
    3666:	40 e0       	ldi	r20, 0x00	; 0
    3668:	51 e0       	ldi	r21, 0x01	; 1
    366a:	0a e4       	ldi	r16, 0x4A	; 74
    366c:	19 e0       	ldi	r17, 0x09	; 9
    366e:	ee 24       	eor	r14, r14
    3670:	0e 94 de 23 	call	0x47bc	; 0x47bc <cmdStateConfigure>
}
    3674:	1f 91       	pop	r17
    3676:	0f 91       	pop	r16
    3678:	ef 90       	pop	r14
    367a:	08 95       	ret

0000367c <encTask>:
//   return 0;
// }


void encTask ( void *pvParameters )
{
    367c:	ef 92       	push	r14
    367e:	ff 92       	push	r15
    3680:	0f 93       	push	r16
    3682:	1f 93       	push	r17
    3684:	cf 93       	push	r28
    3686:	df 93       	push	r29
  FILE *netstackDebug = (FILE *) pvParameters;
    3688:	ec 01       	movw	r28, r24
  uint16_t plen;

  nicInit();
    368a:	0e 94 a8 2d 	call	0x5b50	; 0x5b50 <nicInit>
  ipInit();
    368e:	0e 94 67 34 	call	0x68ce	; 0x68ce <ipInit>
  arpInit();
    3692:	0e 94 9d 39 	call	0x733a	; 0x733a <arpInit>
  icmpInit();
    3696:	0e 94 92 34 	call	0x6924	; 0x6924 <icmpInit>
    }
    else
    {
      if (netstackDebug != NULL)
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    369a:	86 e2       	ldi	r24, 0x26	; 38
    369c:	e8 2e       	mov	r14, r24
    369e:	8b e0       	ldi	r24, 0x0B	; 11
    36a0:	f8 2e       	mov	r15, r24
  //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);
  
  
  for ( ; ; )
  {
    vTaskDelay ( 10 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwolniony po odebrzeniu przerwania od ENC
    36a2:	8a e0       	ldi	r24, 0x0A	; 10
    36a4:	90 e0       	ldi	r25, 0x00	; 0
    36a6:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    
    // get the next new packet:
    plen = nicPoll();
    36aa:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <nicPoll>
    /*plen will ne unequal to zero if there is a valid
    * packet (without crc error) */
    if ( plen==0 )
    36ae:	89 2b       	or	r24, r25
    36b0:	29 f4       	brne	.+10     	; 0x36bc <encTask+0x40>
    {
      flushUdpQueues();
    36b2:	0e 94 53 3f 	call	0x7ea6	; 0x7ea6 <flushUdpQueues>
      flushTcpQueues();
    36b6:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <flushTcpQueues>
    36ba:	f3 cf       	rjmp	.-26     	; 0x36a2 <encTask+0x26>
      //flush HTTP long file queue 
      continue;
    }
    
    if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
    36bc:	e0 91 86 0e 	lds	r30, 0x0E86
    36c0:	f0 91 87 0e 	lds	r31, 0x0E87
    36c4:	04 85       	ldd	r16, Z+12	; 0x0c
    36c6:	15 85       	ldd	r17, Z+13	; 0x0d
    36c8:	80 e0       	ldi	r24, 0x00	; 0
    36ca:	98 e0       	ldi	r25, 0x08	; 8
    36cc:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    36d0:	08 17       	cp	r16, r24
    36d2:	19 07       	cpc	r17, r25
    36d4:	29 f4       	brne	.+10     	; 0x36e0 <encTask+0x64>
    {
      arpIpIn();
    36d6:	0e 94 52 37 	call	0x6ea4	; 0x6ea4 <arpIpIn>
      netstackIPv4Process();
    36da:	0e 94 7b 33 	call	0x66f6	; 0x66f6 <netstackIPv4Process>
    36de:	e1 cf       	rjmp	.-62     	; 0x36a2 <encTask+0x26>
    }
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
    36e0:	e0 91 86 0e 	lds	r30, 0x0E86
    36e4:	f0 91 87 0e 	lds	r31, 0x0E87
    36e8:	04 85       	ldd	r16, Z+12	; 0x0c
    36ea:	15 85       	ldd	r17, Z+13	; 0x0d
    36ec:	86 e0       	ldi	r24, 0x06	; 6
    36ee:	98 e0       	ldi	r25, 0x08	; 8
    36f0:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    36f4:	08 17       	cp	r16, r24
    36f6:	19 07       	cpc	r17, r25
    36f8:	19 f4       	brne	.+6      	; 0x3700 <encTask+0x84>
    {
      arpArpIn();
    36fa:	0e 94 a9 39 	call	0x7352	; 0x7352 <arpArpIn>
    36fe:	d1 cf       	rjmp	.-94     	; 0x36a2 <encTask+0x26>
    }
    else
    {
      if (netstackDebug != NULL)
    3700:	20 97       	sbiw	r28, 0x00	; 0
    3702:	79 f2       	breq	.-98     	; 0x36a2 <encTask+0x26>
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    3704:	00 d0       	rcall	.+0      	; 0x3706 <encTask+0x8a>
    3706:	00 d0       	rcall	.+0      	; 0x3708 <encTask+0x8c>
    3708:	ed b7       	in	r30, 0x3d	; 61
    370a:	fe b7       	in	r31, 0x3e	; 62
    370c:	d2 83       	std	Z+2, r29	; 0x02
    370e:	c1 83       	std	Z+1, r28	; 0x01
    3710:	f4 82       	std	Z+4, r15	; 0x04
    3712:	e3 82       	std	Z+3, r14	; 0x03
    3714:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    3718:	0f 90       	pop	r0
    371a:	0f 90       	pop	r0
    371c:	0f 90       	pop	r0
    371e:	0f 90       	pop	r0
    3720:	c0 cf       	rjmp	.-128    	; 0x36a2 <encTask+0x26>

00003722 <vTaskVTYsocket>:
    }  
  }
}

void vTaskVTYsocket(void *cliStatePtr)
{
    3722:	cf 93       	push	r28
    3724:	df 93       	push	r29
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    3726:	ec 01       	movw	r28, r24
  
  char znak;
  for( ;; )
  {
    znak = 0;
    znak = fgetc(state->myStdInOut);
    3728:	8a 8d       	ldd	r24, Y+26	; 0x1a
    372a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    372c:	0e 94 af 59 	call	0xb35e	; 0xb35e <fgetc>
    cmdlineInputFunc((char)znak, state);
    3730:	be 01       	movw	r22, r28
    3732:	0e 94 4b 24 	call	0x4896	; 0x4896 <cmdlineInputFunc>
    cmdlineMainLoop(state);
    3736:	ce 01       	movw	r24, r28
    3738:	0e 94 a2 22 	call	0x4544	; 0x4544 <cmdlineMainLoop>
    373c:	f5 cf       	rjmp	.-22     	; 0x3728 <vTaskVTYsocket+0x6>

0000373e <vTaskVTYusb>:
#include "cli_task.h"

void vTaskVTYusb(void *cliStatePtr)
{
    373e:	df 92       	push	r13
    3740:	ef 92       	push	r14
    3742:	ff 92       	push	r15
    3744:	0f 93       	push	r16
    3746:	1f 93       	push	r17
    3748:	df 93       	push	r29
    374a:	cf 93       	push	r28
    374c:	0f 92       	push	r0
    374e:	cd b7       	in	r28, 0x3d	; 61
    3750:	de b7       	in	r29, 0x3e	; 62
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    3752:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Restart\r\n"));
    3754:	00 d0       	rcall	.+0      	; 0x3756 <vTaskVTYusb+0x18>
    3756:	00 d0       	rcall	.+0      	; 0x3758 <vTaskVTYusb+0x1a>
    3758:	fc 01       	movw	r30, r24
    375a:	82 8d       	ldd	r24, Z+26	; 0x1a
    375c:	93 8d       	ldd	r25, Z+27	; 0x1b
    375e:	ed b7       	in	r30, 0x3d	; 61
    3760:	fe b7       	in	r31, 0x3e	; 62
    3762:	92 83       	std	Z+2, r25	; 0x02
    3764:	81 83       	std	Z+1, r24	; 0x01
    3766:	87 e3       	ldi	r24, 0x37	; 55
    3768:	9b e0       	ldi	r25, 0x0B	; 11
    376a:	94 83       	std	Z+4, r25	; 0x04
    376c:	83 83       	std	Z+3, r24	; 0x03
    376e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  cmdlineInputFunc('\r', state);
    3772:	0f 90       	pop	r0
    3774:	0f 90       	pop	r0
    3776:	0f 90       	pop	r0
    3778:	0f 90       	pop	r0
    377a:	8d e0       	ldi	r24, 0x0D	; 13
    377c:	b8 01       	movw	r22, r16
    377e:	0e 94 4b 24 	call	0x4896	; 0x4896 <cmdlineInputFunc>
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    3782:	7e 01       	movw	r14, r28
    3784:	08 94       	sec
    3786:	e1 1c       	adc	r14, r1
    3788:	f1 1c       	adc	r15, r1
    {
      cmdlineInputFunc((char)znak, state);
      cmdlineMainLoop(state);
      PORTF ^= 0x08;
    378a:	88 e0       	ldi	r24, 0x08	; 8
    378c:	d8 2e       	mov	r13, r24
  cmdlineInputFunc('\r', state);
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    378e:	80 91 ad 0e 	lds	r24, 0x0EAD
    3792:	90 91 ae 0e 	lds	r25, 0x0EAE
    3796:	b7 01       	movw	r22, r14
    3798:	4f ef       	ldi	r20, 0xFF	; 255
    379a:	5f ef       	ldi	r21, 0xFF	; 255
    379c:	20 e0       	ldi	r18, 0x00	; 0
    379e:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    37a2:	88 23       	and	r24, r24
    37a4:	a1 f3       	breq	.-24     	; 0x378e <vTaskVTYusb+0x50>
    {
      cmdlineInputFunc((char)znak, state);
    37a6:	89 81       	ldd	r24, Y+1	; 0x01
    37a8:	b8 01       	movw	r22, r16
    37aa:	0e 94 4b 24 	call	0x4896	; 0x4896 <cmdlineInputFunc>
      cmdlineMainLoop(state);
    37ae:	c8 01       	movw	r24, r16
    37b0:	0e 94 a2 22 	call	0x4544	; 0x4544 <cmdlineMainLoop>
      PORTF ^= 0x08;
    37b4:	80 91 62 00 	lds	r24, 0x0062
    37b8:	8d 25       	eor	r24, r13
    37ba:	80 93 62 00 	sts	0x0062, r24
    37be:	e7 cf       	rjmp	.-50     	; 0x378e <vTaskVTYusb+0x50>

000037c0 <spiSetCPHA>:
  //mode 0,0
}

void spiSetCPHA(void)
{
  SPCR |= (1<<CPHA);
    37c0:	6a 9a       	sbi	0x0d, 2	; 13
}
    37c2:	08 95       	ret

000037c4 <spiClearCPHA>:

void spiClearCPHA(void)
{
  SPCR &= ~(1<<CPHA);
    37c4:	6a 98       	cbi	0x0d, 2	; 13
}
    37c6:	08 95       	ret

000037c8 <spiSetCPOL>:

void spiSetCPOL(void)
{
  SPCR |= (1<<CPOL);
    37c8:	6b 9a       	sbi	0x0d, 3	; 13
}
    37ca:	08 95       	ret

000037cc <spiClearCPOL>:

void spiClearCPOL(void)
{
  SPCR &= ~(1<<CPOL);
    37cc:	6b 98       	cbi	0x0d, 3	; 13
}
    37ce:	08 95       	ret
    37d0:	80 e0       	ldi	r24, 0x00	; 0
    37d2:	08 95       	ret
    37d4:	80 e0       	ldi	r24, 0x00	; 0
    37d6:	08 95       	ret

000037d8 <spiGive>:
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
}

void spiGive(void)
{
  xSemaphoreGive(xSemaphoreSpiSS);
    37d8:	80 91 be 0e 	lds	r24, 0x0EBE
    37dc:	90 91 bf 0e 	lds	r25, 0x0EBF
    37e0:	60 e0       	ldi	r22, 0x00	; 0
    37e2:	70 e0       	ldi	r23, 0x00	; 0
    37e4:	40 e0       	ldi	r20, 0x00	; 0
    37e6:	50 e0       	ldi	r21, 0x00	; 0
    37e8:	20 e0       	ldi	r18, 0x00	; 0
    37ea:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>
}
    37ee:	08 95       	ret

000037f0 <spiTake>:
  SPCR &= ~(1<<CPOL);
}

void spiTake(void)
{
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
    37f0:	80 91 be 0e 	lds	r24, 0x0EBE
    37f4:	90 91 bf 0e 	lds	r25, 0x0EBF
    37f8:	60 e0       	ldi	r22, 0x00	; 0
    37fa:	70 e0       	ldi	r23, 0x00	; 0
    37fc:	4f ef       	ldi	r20, 0xFF	; 255
    37fe:	5f ef       	ldi	r21, 0xFF	; 255
    3800:	20 e0       	ldi	r18, 0x00	; 0
    3802:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
}
    3806:	08 95       	ret

00003808 <spiInit>:
#include "semphr.h"


void spiInit(void (*disableAllSpiDevicesFun)(void))
{
  disableAllSpiDevicesFun();
    3808:	fc 01       	movw	r30, r24
    380a:	09 95       	icall
  portENTER_CRITICAL();
    380c:	0f b6       	in	r0, 0x3f	; 63
    380e:	f8 94       	cli
    3810:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    3812:	81 e0       	ldi	r24, 0x01	; 1
    3814:	60 e0       	ldi	r22, 0x00	; 0
    3816:	0e 94 87 52 	call	0xa50e	; 0xa50e <xQueueCreate>
    381a:	90 93 bf 0e 	sts	0x0EBF, r25
    381e:	80 93 be 0e 	sts	0x0EBE, r24
    3822:	00 97       	sbiw	r24, 0x00	; 0
    3824:	39 f0       	breq	.+14     	; 0x3834 <spiInit+0x2c>
    3826:	60 e0       	ldi	r22, 0x00	; 0
    3828:	70 e0       	ldi	r23, 0x00	; 0
    382a:	40 e0       	ldi	r20, 0x00	; 0
    382c:	50 e0       	ldi	r21, 0x00	; 0
    382e:	20 e0       	ldi	r18, 0x00	; 0
    3830:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>

  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPIE);
    3834:	80 ed       	ldi	r24, 0xD0	; 208
    3836:	8d b9       	out	0x0d, r24	; 13
  //SPCR = (1<<SPE)|(1<<MSTR);
  SPSR |= (1<<SPI2X);
    3838:	70 9a       	sbi	0x0e, 0	; 14
  portEXIT_CRITICAL();
    383a:	0f 90       	pop	r0
    383c:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    383e:	08 95       	ret

00003840 <xmallocAvailable>:
  
  return result;
}

size_t xmallocAvailable(void)
{
    3840:	20 91 86 01 	lds	r18, 0x0186
    3844:	30 91 87 01 	lds	r19, 0x0187
    3848:	2f 5f       	subi	r18, 0xFF	; 255
    384a:	3f 4f       	sbci	r19, 0xFF	; 255
    384c:	80 91 02 01 	lds	r24, 0x0102
    3850:	90 91 03 01 	lds	r25, 0x0103
    3854:	28 1b       	sub	r18, r24
    3856:	39 0b       	sbc	r19, r25
  return __malloc_heap_end - heapEnd + 1;
    3858:	c9 01       	movw	r24, r18
    385a:	08 95       	ret

0000385c <xmalloc>:
#include "hardwareConfig.h"

char *heapEnd = HEAP_BEGIN;

void *xmalloc(size_t size)
{
    385c:	0f 93       	push	r16
    385e:	1f 93       	push	r17
    3860:	8c 01       	movw	r16, r24
  void *result = malloc(size);
    3862:	0e 94 f2 56 	call	0xade4	; 0xade4 <malloc>
  
  heapEnd = (char *)(result);
  heapEnd += size;
    3866:	08 0f       	add	r16, r24
    3868:	19 1f       	adc	r17, r25
    386a:	10 93 03 01 	sts	0x0103, r17
    386e:	00 93 02 01 	sts	0x0102, r16
  
  return result;
}
    3872:	1f 91       	pop	r17
    3874:	0f 91       	pop	r16
    3876:	08 95       	ret

00003878 <ramDyskLiczbaWolnychKlastrow>:
  }
  while (tmpKlaster != tmpKlaster2);
}

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
    3878:	ea e4       	ldi	r30, 0x4A	; 74
    387a:	ff e0       	ldi	r31, 0x0F	; 15
    387c:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    if (klastry[temp] == 0)
    387e:	80 81       	ld	r24, Z
    3880:	88 23       	and	r24, r24
    3882:	09 f4       	brne	.+2      	; 0x3886 <ramDyskLiczbaWolnychKlastrow+0xe>
      wynik++;
    3884:	9f 5f       	subi	r25, 0xFF	; 255
    3886:	31 97       	sbiw	r30, 0x01	; 1

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    3888:	8e e0       	ldi	r24, 0x0E	; 14
    388a:	eb 3c       	cpi	r30, 0xCB	; 203
    388c:	f8 07       	cpc	r31, r24
    388e:	b9 f7       	brne	.-18     	; 0x387e <ramDyskLiczbaWolnychKlastrow+0x6>
    if (klastry[temp] == 0)
      wynik++;
  return wynik;
}
    3890:	89 2f       	mov	r24, r25
    3892:	08 95       	ret

00003894 <ramDyskDir>:
  }
  return wynik;
}

void ramDyskDir(FILE *ostream)
{
    3894:	2f 92       	push	r2
    3896:	3f 92       	push	r3
    3898:	4f 92       	push	r4
    389a:	5f 92       	push	r5
    389c:	7f 92       	push	r7
    389e:	8f 92       	push	r8
    38a0:	9f 92       	push	r9
    38a2:	af 92       	push	r10
    38a4:	bf 92       	push	r11
    38a6:	cf 92       	push	r12
    38a8:	df 92       	push	r13
    38aa:	ef 92       	push	r14
    38ac:	ff 92       	push	r15
    38ae:	0f 93       	push	r16
    38b0:	1f 93       	push	r17
    38b2:	cf 93       	push	r28
    38b4:	df 93       	push	r29
    38b6:	4c 01       	movw	r8, r24
  fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
    38b8:	84 e0       	ldi	r24, 0x04	; 4
    38ba:	91 e0       	ldi	r25, 0x01	; 1
    38bc:	b4 01       	movw	r22, r8
    38be:	0e 94 4c 5a 	call	0xb498	; 0xb498 <fputs>
    38c2:	77 24       	eor	r7, r7
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    38c4:	2d e1       	ldi	r18, 0x1D	; 29
    38c6:	22 2e       	mov	r2, r18
    38c8:	21 e0       	ldi	r18, 0x01	; 1
    38ca:	32 2e       	mov	r3, r18
  uint8_t tmpKlaster = 0;
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    38cc:	e7 2c       	mov	r14, r7
    38ce:	ff 24       	eor	r15, r15
    38d0:	20 e8       	ldi	r18, 0x80	; 128
    38d2:	30 e0       	ldi	r19, 0x00	; 0
    38d4:	e2 0e       	add	r14, r18
    38d6:	f3 1e       	adc	r15, r19
    38d8:	de 2d       	mov	r29, r14
    38da:	cc 27       	eor	r28, r28
    38dc:	80 e8       	ldi	r24, 0x80	; 128
    38de:	9f ef       	ldi	r25, 0xFF	; 255
    38e0:	e8 0e       	add	r14, r24
    38e2:	f9 1e       	adc	r15, r25
    for (tmp=0; tmp<16; tmp++)
    38e4:	80 ef       	ldi	r24, 0xF0	; 240
    38e6:	48 2e       	mov	r4, r24
    38e8:	51 2c       	mov	r5, r1
    38ea:	4c 0e       	add	r4, r28
    38ec:	5d 1e       	adc	r5, r29
    {
      tmp3=plik->nazwa[0];
    38ee:	1c 81       	ldd	r17, Y+4	; 0x04
      if (tmp3 == 0)
    38f0:	11 23       	and	r17, r17
    38f2:	09 f4       	brne	.+2      	; 0x38f6 <ramDyskDir+0x62>
    38f4:	4b c0       	rjmp	.+150    	; 0x398c <ramDyskDir+0xf8>
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
    38f6:	81 2f       	mov	r24, r17
    38f8:	90 e0       	ldi	r25, 0x00	; 0
    38fa:	b4 01       	movw	r22, r8
    38fc:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    3900:	6e 01       	movw	r12, r28
    3902:	01 e0       	ldi	r16, 0x01	; 1
      for (tmp2=1; tmp2<8; tmp2++)
      {
        if (tmp3 != 0)
    3904:	11 23       	and	r17, r17
    3906:	59 f0       	breq	.+22     	; 0x391e <ramDyskDir+0x8a>
          tmp3=plik->nazwa[tmp2];
    3908:	d6 01       	movw	r26, r12
    390a:	15 96       	adiw	r26, 0x05	; 5
    390c:	1c 91       	ld	r17, X

        if (tmp3 != 0)
    390e:	11 23       	and	r17, r17
    3910:	31 f0       	breq	.+12     	; 0x391e <ramDyskDir+0x8a>
          fputc(tmp3     , ostream);
    3912:	81 2f       	mov	r24, r17
    3914:	90 e0       	ldi	r25, 0x00	; 0
    3916:	b4 01       	movw	r22, r8
    3918:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    391c:	06 c0       	rjmp	.+12     	; 0x392a <ramDyskDir+0x96>
        else
          fputc(' '      , ostream);
    391e:	80 e2       	ldi	r24, 0x20	; 32
    3920:	90 e0       	ldi	r25, 0x00	; 0
    3922:	b4 01       	movw	r22, r8
    3924:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    3928:	10 e0       	ldi	r17, 0x00	; 0
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
    392a:	0f 5f       	subi	r16, 0xFF	; 255
    392c:	08 94       	sec
    392e:	c1 1c       	adc	r12, r1
    3930:	d1 1c       	adc	r13, r1
    3932:	08 30       	cpi	r16, 0x08	; 8
    3934:	39 f7       	brne	.-50     	; 0x3904 <ramDyskDir+0x70>
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    3936:	ed b7       	in	r30, 0x3d	; 61
    3938:	fe b7       	in	r31, 0x3e	; 62
    393a:	38 97       	sbiw	r30, 0x08	; 8
    393c:	0f b6       	in	r0, 0x3f	; 63
    393e:	f8 94       	cli
    3940:	fe bf       	out	0x3e, r31	; 62
    3942:	0f be       	out	0x3f, r0	; 63
    3944:	ed bf       	out	0x3d, r30	; 61
    3946:	31 96       	adiw	r30, 0x01	; 1
    3948:	ad b7       	in	r26, 0x3d	; 61
    394a:	be b7       	in	r27, 0x3e	; 62
    394c:	12 96       	adiw	r26, 0x02	; 2
    394e:	9c 92       	st	X, r9
    3950:	8e 92       	st	-X, r8
    3952:	11 97       	sbiw	r26, 0x01	; 1
    3954:	33 82       	std	Z+3, r3	; 0x03
    3956:	22 82       	std	Z+2, r2	; 0x02
    3958:	ba 80       	ldd	r11, Y+2	; 0x02
    395a:	aa 24       	eor	r10, r10
    395c:	89 81       	ldd	r24, Y+1	; 0x01
    395e:	95 01       	movw	r18, r10
    3960:	28 0f       	add	r18, r24
    3962:	31 1d       	adc	r19, r1
    3964:	35 83       	std	Z+5, r19	; 0x05
    3966:	24 83       	std	Z+4, r18	; 0x04
    3968:	8b 81       	ldd	r24, Y+3	; 0x03
    396a:	86 83       	std	Z+6, r24	; 0x06
    396c:	17 82       	std	Z+7, r1	; 0x07
    396e:	0e 94 f1 59 	call	0xb3e2	; 0xb3e2 <fprintf>
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    3972:	8d b7       	in	r24, 0x3d	; 61
    3974:	9e b7       	in	r25, 0x3e	; 62
    3976:	08 96       	adiw	r24, 0x08	; 8
    3978:	0f b6       	in	r0, 0x3f	; 63
    397a:	f8 94       	cli
    397c:	9e bf       	out	0x3e, r25	; 62
    397e:	0f be       	out	0x3f, r0	; 63
    3980:	8d bf       	out	0x3d, r24	; 61
    3982:	c4 15       	cp	r28, r4
    3984:	d5 05       	cpc	r29, r5
    3986:	11 f0       	breq	.+4      	; 0x398c <ramDyskDir+0xf8>
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
      plik++;
    3988:	60 96       	adiw	r28, 0x10	; 16
    398a:	b1 cf       	rjmp	.-158    	; 0x38ee <ramDyskDir+0x5a>
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    398c:	ab ec       	ldi	r26, 0xCB	; 203
    398e:	be e0       	ldi	r27, 0x0E	; 14
    3990:	ea 0e       	add	r14, r26
    3992:	fb 1e       	adc	r15, r27
    3994:	f7 01       	movw	r30, r14
    3996:	80 81       	ld	r24, Z
  }
  while (tmpKlaster != tmpKlaster2);
    3998:	87 15       	cp	r24, r7
    399a:	11 f0       	breq	.+4      	; 0x39a0 <ramDyskDir+0x10c>
    399c:	78 2e       	mov	r7, r24
    399e:	96 cf       	rjmp	.-212    	; 0x38cc <ramDyskDir+0x38>
}
    39a0:	df 91       	pop	r29
    39a2:	cf 91       	pop	r28
    39a4:	1f 91       	pop	r17
    39a6:	0f 91       	pop	r16
    39a8:	ff 90       	pop	r15
    39aa:	ef 90       	pop	r14
    39ac:	df 90       	pop	r13
    39ae:	cf 90       	pop	r12
    39b0:	bf 90       	pop	r11
    39b2:	af 90       	pop	r10
    39b4:	9f 90       	pop	r9
    39b6:	8f 90       	pop	r8
    39b8:	7f 90       	pop	r7
    39ba:	5f 90       	pop	r5
    39bc:	4f 90       	pop	r4
    39be:	3f 90       	pop	r3
    39c0:	2f 90       	pop	r2
    39c2:	08 95       	ret

000039c4 <znajdzWolnyKlaster>:
      fd->wpis->rozmiarHi = fd->IndHi;    
  }
}

static uint8_t znajdzWolnyKlaster(void)
{
    39c4:	21 e0       	ldi	r18, 0x01	; 1
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
  {                                        //Może być rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    39c6:	42 2f       	mov	r20, r18
    39c8:	50 e0       	ldi	r21, 0x00	; 0
    39ca:	fa 01       	movw	r30, r20
    39cc:	e5 53       	subi	r30, 0x35	; 53
    39ce:	f1 4f       	sbci	r31, 0xF1	; 241
    39d0:	80 81       	ld	r24, Z
    39d2:	88 23       	and	r24, r24
    39d4:	69 f4       	brne	.+26     	; 0x39f0 <znajdzWolnyKlaster+0x2c>
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
    39d6:	20 83       	st	Z, r18
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    39d8:	e0 e0       	ldi	r30, 0x00	; 0
    39da:	f2 2f       	mov	r31, r18
    39dc:	f0 58       	subi	r31, 0x80	; 128
    39de:	80 e0       	ldi	r24, 0x00	; 0
    39e0:	91 e0       	ldi	r25, 0x01	; 1
    39e2:	df 01       	movw	r26, r30
    39e4:	ac 01       	movw	r20, r24
    39e6:	1d 92       	st	X+, r1
    39e8:	41 50       	subi	r20, 0x01	; 1
    39ea:	50 40       	sbci	r21, 0x00	; 0
    39ec:	e1 f7       	brne	.-8      	; 0x39e6 <znajdzWolnyKlaster+0x22>
    39ee:	04 c0       	rjmp	.+8      	; 0x39f8 <znajdzWolnyKlaster+0x34>
}

static uint8_t znajdzWolnyKlaster(void)
{
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    39f0:	2f 5f       	subi	r18, 0xFF	; 255
    39f2:	20 38       	cpi	r18, 0x80	; 128
    39f4:	41 f7       	brne	.-48     	; 0x39c6 <znajdzWolnyKlaster+0x2>
    39f6:	20 e0       	ldi	r18, 0x00	; 0
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
      return i;
    }
  }
  return 0;
}
    39f8:	82 2f       	mov	r24, r18
    39fa:	08 95       	ret

000039fc <nastepnyKlaster>:

static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
    39fc:	a8 2f       	mov	r26, r24
    39fe:	b0 e0       	ldi	r27, 0x00	; 0
    3a00:	fd 01       	movw	r30, r26
    3a02:	e5 53       	subi	r30, 0x35	; 53
    3a04:	f1 4f       	sbci	r31, 0xF1	; 241
    3a06:	20 81       	ld	r18, Z
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
    3a08:	28 17       	cp	r18, r24
    3a0a:	f9 f4       	brne	.+62     	; 0x3a4a <nastepnyKlaster+0x4e>
    3a0c:	21 e0       	ldi	r18, 0x01	; 1
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma wolnego klastra
      if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, że jest on pusty
    3a0e:	e2 2f       	mov	r30, r18
    3a10:	f0 e0       	ldi	r31, 0x00	; 0
    3a12:	e5 53       	subi	r30, 0x35	; 53
    3a14:	f1 4f       	sbci	r31, 0xF1	; 241
    3a16:	80 81       	ld	r24, Z
    3a18:	88 23       	and	r24, r24
    3a1a:	19 f0       	breq	.+6      	; 0x3a22 <nastepnyKlaster+0x26>
static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    3a1c:	2f 5f       	subi	r18, 0xFF	; 255
    3a1e:	20 38       	cpi	r18, 0x80	; 128
    3a20:	b1 f7       	brne	.-20     	; 0x3a0e <nastepnyKlaster+0x12>
        break;                             //Wtedy można przerwać szukanie kolejnych klastrów dla klastra
    }                                      //Taka implementacja z założenia powoduje defragmentację.
    
    if (temp != 0)                         //Znaleziono jakiś wolny klaster
    {
      klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku kolejnego klastra
    3a22:	a5 53       	subi	r26, 0x35	; 53
    3a24:	b1 4f       	sbci	r27, 0xF1	; 241
    3a26:	2c 93       	st	X, r18
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
    3a28:	82 2f       	mov	r24, r18
    3a2a:	90 e0       	ldi	r25, 0x00	; 0
    3a2c:	fc 01       	movw	r30, r24
    3a2e:	e5 53       	subi	r30, 0x35	; 53
    3a30:	f1 4f       	sbci	r31, 0xF1	; 241
    3a32:	20 83       	st	Z, r18
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    3a34:	e0 e0       	ldi	r30, 0x00	; 0
    3a36:	f2 2f       	mov	r31, r18
    3a38:	f0 58       	subi	r31, 0x80	; 128
    3a3a:	80 e0       	ldi	r24, 0x00	; 0
    3a3c:	91 e0       	ldi	r25, 0x01	; 1
    3a3e:	df 01       	movw	r26, r30
    3a40:	ac 01       	movw	r20, r24
    3a42:	1d 92       	st	X+, r1
    3a44:	41 50       	subi	r20, 0x01	; 1
    3a46:	50 40       	sbci	r21, 0x00	; 0
    3a48:	e1 f7       	brne	.-8      	; 0x3a42 <nastepnyKlaster+0x46>
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
      czyscKlaster(temp);                  //Czyszczenie klastra
    }
  }
  return temp;
}
    3a4a:	82 2f       	mov	r24, r18
    3a4c:	08 95       	ret

00003a4e <znajdzKlasterN>:

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
    3a4e:	0f 93       	push	r16
    3a50:	1f 93       	push	r17
    3a52:	06 2f       	mov	r16, r22
    3a54:	10 e0       	ldi	r17, 0x00	; 0
    3a56:	05 c0       	rjmp	.+10     	; 0x3a62 <znajdzKlasterN+0x14>
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
  {
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    3a58:	0e 94 fe 1c 	call	0x39fc	; 0x39fc <nastepnyKlaster>
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
    3a5c:	88 23       	and	r24, r24
    3a5e:	19 f0       	breq	.+6      	; 0x3a66 <znajdzKlasterN+0x18>

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3a60:	1f 5f       	subi	r17, 0xFF	; 255
    3a62:	10 17       	cp	r17, r16
    3a64:	c8 f3       	brcs	.-14     	; 0x3a58 <znajdzKlasterN+0xa>
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
      break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany na początek tablicy plików
  }
  return wynik;
}
    3a66:	1f 91       	pop	r17
    3a68:	0f 91       	pop	r16
    3a6a:	08 95       	ret

00003a6c <ramDyskDodajBlokXmodem>:
  }  
  return 0;
}

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
    3a6c:	cf 92       	push	r12
    3a6e:	df 92       	push	r13
    3a70:	ef 92       	push	r14
    3a72:	ff 92       	push	r15
    3a74:	1f 93       	push	r17
    3a76:	cf 93       	push	r28
    3a78:	df 93       	push	r29
    3a7a:	7c 01       	movw	r14, r24
    3a7c:	6b 01       	movw	r12, r22
  if (nrBloku == 0)
    3a7e:	61 15       	cp	r22, r1
    3a80:	71 05       	cpc	r23, r1
    3a82:	09 f4       	brne	.+2      	; 0x3a86 <ramDyskDodajBlokXmodem+0x1a>
    3a84:	4e c0       	rjmp	.+156    	; 0x3b22 <ramDyskDodajBlokXmodem+0xb6>
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
  uint8_t indLo = 0;
  uint8_t *wynik;
  
  if (fd->wpis->pierwszyKlaster == 0)
    3a86:	dc 01       	movw	r26, r24
    3a88:	14 96       	adiw	r26, 0x04	; 4
    3a8a:	cd 91       	ld	r28, X+
    3a8c:	dc 91       	ld	r29, X
    3a8e:	15 97       	sbiw	r26, 0x05	; 5
    3a90:	88 81       	ld	r24, Y
    3a92:	88 23       	and	r24, r24
    3a94:	19 f4       	brne	.+6      	; 0x3a9c <ramDyskDodajBlokXmodem+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    3a96:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <znajdzWolnyKlaster>
    3a9a:	88 83       	st	Y, r24
  if (fd->wpis->pierwszyKlaster == 0)
    3a9c:	d7 01       	movw	r26, r14
    3a9e:	14 96       	adiw	r26, 0x04	; 4
    3aa0:	ed 91       	ld	r30, X+
    3aa2:	fc 91       	ld	r31, X
    3aa4:	15 97       	sbiw	r26, 0x05	; 5
    3aa6:	80 81       	ld	r24, Z
    3aa8:	88 23       	and	r24, r24
    3aaa:	d9 f1       	breq	.+118    	; 0x3b22 <ramDyskDodajBlokXmodem+0xb6>

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
  if (nrBloku == 0)
    return NULL;
  nrBloku --;
    3aac:	08 94       	sec
    3aae:	c1 08       	sbc	r12, r1
    3ab0:	d1 08       	sbc	r13, r1
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
    3ab2:	e6 01       	movw	r28, r12
    3ab4:	d6 95       	lsr	r29
    3ab6:	c7 95       	ror	r28
    3ab8:	1c 2f       	mov	r17, r28
  if (fd->wpis->pierwszyKlaster == 0)
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
    3aba:	6c 2f       	mov	r22, r28
    3abc:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <znajdzKlasterN>
    3ac0:	98 2f       	mov	r25, r24
  if (tmpKlaster == 0)
    3ac2:	88 23       	and	r24, r24
    3ac4:	71 f1       	breq	.+92     	; 0x3b22 <ramDyskDodajBlokXmodem+0xb6>
    3ac6:	d7 01       	movw	r26, r14
    3ac8:	14 96       	adiw	r26, 0x04	; 4
    3aca:	ed 91       	ld	r30, X+
    3acc:	fc 91       	ld	r31, X
    3ace:	15 97       	sbiw	r26, 0x05	; 5
    return NULL;
  if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
    3ad0:	c0 fe       	sbrs	r12, 0
    3ad2:	0f c0       	rjmp	.+30     	; 0x3af2 <ramDyskDodajBlokXmodem+0x86>
  {
    indLo = 128;
    if (fd->wpis->rozmiarHi <= indHi)
    3ad4:	82 81       	ldd	r24, Z+2	; 0x02
    3ad6:	c8 17       	cp	r28, r24
    3ad8:	38 f0       	brcs	.+14     	; 0x3ae8 <ramDyskDodajBlokXmodem+0x7c>
    {
      fd->wpis->rozmiarHi = indHi+1;
    3ada:	1f 5f       	subi	r17, 0xFF	; 255
    3adc:	12 83       	std	Z+2, r17	; 0x02
      fd->wpis->rozmiarLo = 0;
    3ade:	14 96       	adiw	r26, 0x04	; 4
    3ae0:	ed 91       	ld	r30, X+
    3ae2:	fc 91       	ld	r31, X
    3ae4:	15 97       	sbiw	r26, 0x05	; 5
    3ae6:	11 82       	std	Z+1, r1	; 0x01
    }
    wynik=dataPtr(tmpKlaster, 128);
    3ae8:	39 2f       	mov	r19, r25
    3aea:	20 e0       	ldi	r18, 0x00	; 0
    3aec:	20 58       	subi	r18, 0x80	; 128
    3aee:	3f 47       	sbci	r19, 0x7F	; 127
    3af0:	1a c0       	rjmp	.+52     	; 0x3b26 <ramDyskDodajBlokXmodem+0xba>
  }
  else
  {
    if (fd->wpis->rozmiarHi < indHi)
    3af2:	82 81       	ldd	r24, Z+2	; 0x02
    3af4:	8c 17       	cp	r24, r28
    3af6:	38 f4       	brcc	.+14     	; 0x3b06 <ramDyskDodajBlokXmodem+0x9a>
    {
      fd->wpis->rozmiarHi = indHi;
    3af8:	c2 83       	std	Z+2, r28	; 0x02
      fd->wpis->rozmiarLo = 128;
    3afa:	d7 01       	movw	r26, r14
    3afc:	14 96       	adiw	r26, 0x04	; 4
    3afe:	ed 91       	ld	r30, X+
    3b00:	fc 91       	ld	r31, X
    3b02:	15 97       	sbiw	r26, 0x05	; 5
    3b04:	05 c0       	rjmp	.+10     	; 0x3b10 <ramDyskDodajBlokXmodem+0xa4>
    }
    else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
    3b06:	8c 17       	cp	r24, r28
    3b08:	29 f4       	brne	.+10     	; 0x3b14 <ramDyskDodajBlokXmodem+0xa8>
    3b0a:	81 81       	ldd	r24, Z+1	; 0x01
    3b0c:	87 fd       	sbrc	r24, 7
    3b0e:	02 c0       	rjmp	.+4      	; 0x3b14 <ramDyskDodajBlokXmodem+0xa8>
      fd->wpis->rozmiarLo = 128;
    3b10:	80 e8       	ldi	r24, 0x80	; 128
    3b12:	81 83       	std	Z+1, r24	; 0x01
    
    wynik=dataPtr(tmpKlaster, 0);
    3b14:	89 2f       	mov	r24, r25
    3b16:	90 e0       	ldi	r25, 0x00	; 0
    3b18:	80 58       	subi	r24, 0x80	; 128
    3b1a:	9f 4f       	sbci	r25, 0xFF	; 255
    3b1c:	38 2f       	mov	r19, r24
    3b1e:	22 27       	eor	r18, r18
    3b20:	02 c0       	rjmp	.+4      	; 0x3b26 <ramDyskDodajBlokXmodem+0xba>
    3b22:	20 e0       	ldi	r18, 0x00	; 0
    3b24:	30 e0       	ldi	r19, 0x00	; 0
  }
  return wynik;
}
    3b26:	c9 01       	movw	r24, r18
    3b28:	df 91       	pop	r29
    3b2a:	cf 91       	pop	r28
    3b2c:	1f 91       	pop	r17
    3b2e:	ff 90       	pop	r15
    3b30:	ef 90       	pop	r14
    3b32:	df 90       	pop	r13
    3b34:	cf 90       	pop	r12
    3b36:	08 95       	ret

00003b38 <ramDyskUstawWskaznikNaKoniec>:

  return 0; 
}

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
    3b38:	cf 93       	push	r28
    3b3a:	df 93       	push	r29
    3b3c:	ec 01       	movw	r28, r24
  if (fd == NULL)
    3b3e:	00 97       	sbiw	r24, 0x00	; 0
    3b40:	11 f4       	brne	.+4      	; 0x3b46 <ramDyskUstawWskaznikNaKoniec+0xe>
    3b42:	81 e0       	ldi	r24, 0x01	; 1
    3b44:	17 c0       	rjmp	.+46     	; 0x3b74 <ramDyskUstawWskaznikNaKoniec+0x3c>
    return 1;
  fd->IndLo = fd->wpis->rozmiarLo;
    3b46:	ec 81       	ldd	r30, Y+4	; 0x04
    3b48:	fd 81       	ldd	r31, Y+5	; 0x05
    3b4a:	91 81       	ldd	r25, Z+1	; 0x01
    3b4c:	9a 83       	std	Y+2, r25	; 0x02
  fd->IndHi = fd->wpis->rozmiarHi;
    3b4e:	82 81       	ldd	r24, Z+2	; 0x02
    3b50:	8b 83       	std	Y+3, r24	; 0x03
//  fd->IndLo++;
  uint8_t tmpKlaster = 0;
  if (fd->IndLo != 0)
    3b52:	99 23       	and	r25, r25
    3b54:	71 f0       	breq	.+28     	; 0x3b72 <ramDyskUstawWskaznikNaKoniec+0x3a>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    3b56:	80 81       	ld	r24, Z
    3b58:	62 81       	ldd	r22, Z+2	; 0x02
    3b5a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <znajdzKlasterN>
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
    3b5e:	90 e0       	ldi	r25, 0x00	; 0
    3b60:	80 58       	subi	r24, 0x80	; 128
    3b62:	9f 4f       	sbci	r25, 0xFF	; 255
    3b64:	98 2f       	mov	r25, r24
    3b66:	88 27       	eor	r24, r24
    3b68:	2a 81       	ldd	r18, Y+2	; 0x02
    3b6a:	82 0f       	add	r24, r18
    3b6c:	91 1d       	adc	r25, r1
    3b6e:	99 83       	std	Y+1, r25	; 0x01
    3b70:	88 83       	st	Y, r24
    3b72:	80 e0       	ldi	r24, 0x00	; 0
  }  
  return 0;
}
    3b74:	df 91       	pop	r29
    3b76:	cf 91       	pop	r28
    3b78:	08 95       	ret

00003b7a <ramDyskUstawWskaznik>:
  }
  return 0;
}

uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
{
    3b7a:	ef 92       	push	r14
    3b7c:	ff 92       	push	r15
    3b7e:	0f 93       	push	r16
    3b80:	1f 93       	push	r17
    3b82:	cf 93       	push	r28
    3b84:	df 93       	push	r29
    3b86:	ec 01       	movw	r28, r24
  if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje na początek pliku.
    3b88:	61 15       	cp	r22, r1
    3b8a:	71 05       	cpc	r23, r1
    3b8c:	19 f4       	brne	.+6      	; 0x3b94 <ramDyskUstawWskaznik+0x1a>
  {                                                       //Jeśli tak, to nie ma potzeby tworzenia klastrów. Plik może nadal nei mieć żadnego klastra.
    fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bardziej znaczącego bajtu)
    3b8e:	1a 82       	std	Y+2, r1	; 0x02
    fd->IndHi = 0;
    3b90:	1b 82       	std	Y+3, r1	; 0x03
    3b92:	44 c0       	rjmp	.+136    	; 0x3c1c <ramDyskUstawWskaznik+0xa2>
    return 0;
  }
  indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio ustawić rozmair pliku.
    3b94:	8b 01       	movw	r16, r22
    3b96:	01 50       	subi	r16, 0x01	; 1
    3b98:	10 40       	sbci	r17, 0x00	; 0
                                                          //Jeśli indeks jest większy niż rozmiar pliku, to plik zostanie rozciągnięty do zadanej wartości indeksu -1
  
  if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydzielony pierwszy klaster
    3b9a:	ec 80       	ldd	r14, Y+4	; 0x04
    3b9c:	fd 80       	ldd	r15, Y+5	; 0x05
    3b9e:	f7 01       	movw	r30, r14
    3ba0:	80 81       	ld	r24, Z
    3ba2:	88 23       	and	r24, r24
    3ba4:	21 f4       	brne	.+8      	; 0x3bae <ramDyskUstawWskaznik+0x34>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pliku. Jest to konieczne, ponieważ klaster ma wartość niezerową
    3ba6:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <znajdzWolnyKlaster>
    3baa:	f7 01       	movw	r30, r14
    3bac:	80 83       	st	Z, r24

  uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką należy dodać do pierwszego klastra`

  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
    3bae:	0a 83       	std	Y+2, r16	; 0x02
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
    3bb0:	1b 83       	std	Y+3, r17	; 0x03
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
    3bb2:	ec 81       	ldd	r30, Y+4	; 0x04
    3bb4:	fd 81       	ldd	r31, Y+5	; 0x05
    3bb6:	80 81       	ld	r24, Z
    3bb8:	61 2f       	mov	r22, r17
    3bba:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <znajdzKlasterN>
    3bbe:	38 2f       	mov	r19, r24
  if (nrKlastra == 0)
    3bc0:	88 23       	and	r24, r24
    3bc2:	11 f4       	brne	.+4      	; 0x3bc8 <ramDyskUstawWskaznik+0x4e>
    3bc4:	81 e0       	ldi	r24, 0x01	; 1
    3bc6:	2b c0       	rjmp	.+86     	; 0x3c1e <ramDyskUstawWskaznik+0xa4>
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    3bc8:	ec 81       	ldd	r30, Y+4	; 0x04
    3bca:	fd 81       	ldd	r31, Y+5	; 0x05
    3bcc:	92 81       	ldd	r25, Z+2	; 0x02
    3bce:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd0:	98 17       	cp	r25, r24
    3bd2:	29 f4       	brne	.+10     	; 0x3bde <ramDyskUstawWskaznik+0x64>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    3bd4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bd6:	81 81       	ldd	r24, Z+1	; 0x01
    3bd8:	89 17       	cp	r24, r25
    3bda:	08 f4       	brcc	.+2      	; 0x3bde <ramDyskUstawWskaznik+0x64>
      fd->wpis->rozmiarLo = fd->IndLo;
    3bdc:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    3bde:	ec 81       	ldd	r30, Y+4	; 0x04
    3be0:	fd 81       	ldd	r31, Y+5	; 0x05
    3be2:	92 81       	ldd	r25, Z+2	; 0x02
    3be4:	8b 81       	ldd	r24, Y+3	; 0x03
    3be6:	98 17       	cp	r25, r24
    3be8:	30 f4       	brcc	.+12     	; 0x3bf6 <ramDyskUstawWskaznik+0x7c>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    3bea:	8a 81       	ldd	r24, Y+2	; 0x02
    3bec:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    3bee:	ec 81       	ldd	r30, Y+4	; 0x04
    3bf0:	fd 81       	ldd	r31, Y+5	; 0x05
    3bf2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf4:	82 83       	std	Z+2, r24	; 0x02
  if (nrKlastra == 0)
    return 1;                                             //Brak klastrów

  uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku

  fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
    3bf6:	2a 81       	ldd	r18, Y+2	; 0x02
    3bf8:	2f 5f       	subi	r18, 0xFF	; 255
    3bfa:	2a 83       	std	Y+2, r18	; 0x02
  if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, to jeszcze on nie iestnieje
    3bfc:	22 23       	and	r18, r18
    3bfe:	21 f4       	brne	.+8      	; 0x3c08 <ramDyskUstawWskaznik+0x8e>
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
    3c00:	8b 81       	ldd	r24, Y+3	; 0x03
    3c02:	8f 5f       	subi	r24, 0xFF	; 255
    3c04:	8b 83       	std	Y+3, r24	; 0x03
    3c06:	0a c0       	rjmp	.+20     	; 0x3c1c <ramDyskUstawWskaznik+0xa2>
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra
    3c08:	83 2f       	mov	r24, r19
    3c0a:	90 e0       	ldi	r25, 0x00	; 0
    3c0c:	80 58       	subi	r24, 0x80	; 128
    3c0e:	9f 4f       	sbci	r25, 0xFF	; 255
    3c10:	98 2f       	mov	r25, r24
    3c12:	88 27       	eor	r24, r24
    3c14:	82 0f       	add	r24, r18
    3c16:	91 1d       	adc	r25, r1
    3c18:	99 83       	std	Y+1, r25	; 0x01
    3c1a:	88 83       	st	Y, r24
    3c1c:	80 e0       	ldi	r24, 0x00	; 0

  return 0; 
}
    3c1e:	df 91       	pop	r29
    3c20:	cf 91       	pop	r28
    3c22:	1f 91       	pop	r17
    3c24:	0f 91       	pop	r16
    3c26:	ff 90       	pop	r15
    3c28:	ef 90       	pop	r14
    3c2a:	08 95       	ret

00003c2c <ramDyskCzytajBajtZPliku>:
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
    3c2c:	0f 93       	push	r16
    3c2e:	1f 93       	push	r17
    3c30:	cf 93       	push	r28
    3c32:	df 93       	push	r29
    3c34:	ec 01       	movw	r28, r24
    3c36:	8b 01       	movw	r16, r22
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3c38:	ec 81       	ldd	r30, Y+4	; 0x04
    3c3a:	fd 81       	ldd	r31, Y+5	; 0x05
    3c3c:	82 81       	ldd	r24, Z+2	; 0x02
    3c3e:	6b 81       	ldd	r22, Y+3	; 0x03
    3c40:	68 17       	cp	r22, r24
    3c42:	30 f0       	brcs	.+12     	; 0x3c50 <ramDyskCzytajBajtZPliku+0x24>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3c44:	86 17       	cp	r24, r22
    3c46:	21 f5       	brne	.+72     	; 0x3c90 <ramDyskCzytajBajtZPliku+0x64>
    3c48:	91 81       	ldd	r25, Z+1	; 0x01
    3c4a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c4c:	98 17       	cp	r25, r24
    3c4e:	00 f1       	brcs	.+64     	; 0x3c90 <ramDyskCzytajBajtZPliku+0x64>
uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof

  if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku nowego klastra
    3c50:	8a 81       	ldd	r24, Y+2	; 0x02
    3c52:	88 23       	and	r24, r24
    3c54:	41 f4       	brne	.+16     	; 0x3c66 <ramDyskCzytajBajtZPliku+0x3a>
  {
    uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    3c56:	80 81       	ld	r24, Z
    3c58:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <znajdzKlasterN>
    fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego klastra
    3c5c:	90 e0       	ldi	r25, 0x00	; 0
    3c5e:	80 58       	subi	r24, 0x80	; 128
    3c60:	9f 4f       	sbci	r25, 0xFF	; 255
    3c62:	18 82       	st	Y, r1
    3c64:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *bajt = *(fd->Wsk);                                 //Odczyt z pliku
    3c66:	e8 81       	ld	r30, Y
    3c68:	f9 81       	ldd	r31, Y+1	; 0x01
    3c6a:	80 81       	ld	r24, Z
    3c6c:	f8 01       	movw	r30, r16
    3c6e:	80 83       	st	Z, r24
  fd->IndLo++;                                        //Zwiększenie indeksu o 1
    3c70:	8a 81       	ldd	r24, Y+2	; 0x02
    3c72:	8f 5f       	subi	r24, 0xFF	; 255
    3c74:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    3c76:	88 23       	and	r24, r24
    3c78:	21 f4       	brne	.+8      	; 0x3c82 <ramDyskCzytajBajtZPliku+0x56>
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
    3c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c7c:	8f 5f       	subi	r24, 0xFF	; 255
    3c7e:	8b 83       	std	Y+3, r24	; 0x03
    3c80:	05 c0       	rjmp	.+10     	; 0x3c8c <ramDyskCzytajBajtZPliku+0x60>
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
    3c82:	88 81       	ld	r24, Y
    3c84:	99 81       	ldd	r25, Y+1	; 0x01
    3c86:	01 96       	adiw	r24, 0x01	; 1
    3c88:	99 83       	std	Y+1, r25	; 0x01
    3c8a:	88 83       	st	Y, r24
    3c8c:	80 e0       	ldi	r24, 0x00	; 0
    3c8e:	01 c0       	rjmp	.+2      	; 0x3c92 <ramDyskCzytajBajtZPliku+0x66>
    3c90:	81 e0       	ldi	r24, 0x01	; 1
  return 0;
}
    3c92:	df 91       	pop	r29
    3c94:	cf 91       	pop	r28
    3c96:	1f 91       	pop	r17
    3c98:	0f 91       	pop	r16
    3c9a:	08 95       	ret

00003c9c <getSTD>:
  return wynik;
}


static int getSTD(FILE *stream)
{
    3c9c:	df 93       	push	r29
    3c9e:	cf 93       	push	r28
    3ca0:	0f 92       	push	r0
    3ca2:	cd b7       	in	r28, 0x3d	; 61
    3ca4:	de b7       	in	r29, 0x3e	; 62
  uint8_t wynik;
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  
  if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
    3ca6:	fc 01       	movw	r30, r24
    3ca8:	84 85       	ldd	r24, Z+12	; 0x0c
    3caa:	95 85       	ldd	r25, Z+13	; 0x0d
    3cac:	be 01       	movw	r22, r28
    3cae:	6f 5f       	subi	r22, 0xFF	; 255
    3cb0:	7f 4f       	sbci	r23, 0xFF	; 255
    3cb2:	0e 94 16 1e 	call	0x3c2c	; 0x3c2c <ramDyskCzytajBajtZPliku>
    3cb6:	88 23       	and	r24, r24
    3cb8:	19 f0       	breq	.+6      	; 0x3cc0 <getSTD+0x24>
    3cba:	2f ef       	ldi	r18, 0xFF	; 255
    3cbc:	3f ef       	ldi	r19, 0xFF	; 255
    3cbe:	03 c0       	rjmp	.+6      	; 0x3cc6 <getSTD+0x2a>
    return wynik;
    3cc0:	89 81       	ldd	r24, Y+1	; 0x01
    3cc2:	28 2f       	mov	r18, r24
    3cc4:	30 e0       	ldi	r19, 0x00	; 0
  return EOF;
}
    3cc6:	c9 01       	movw	r24, r18
    3cc8:	0f 90       	pop	r0
    3cca:	cf 91       	pop	r28
    3ccc:	df 91       	pop	r29
    3cce:	08 95       	ret

00003cd0 <ramDyskZapiszBajtDoPliku>:
  memset (fd, 0, 4);
  return 0;
}

uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
{
    3cd0:	1f 93       	push	r17
    3cd2:	cf 93       	push	r28
    3cd4:	df 93       	push	r29
    3cd6:	ec 01       	movw	r28, r24
    3cd8:	16 2f       	mov	r17, r22
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
    3cda:	ec 81       	ldd	r30, Y+4	; 0x04
    3cdc:	fd 81       	ldd	r31, Y+5	; 0x05
    3cde:	80 81       	ld	r24, Z
    3ce0:	88 23       	and	r24, r24
    3ce2:	49 f4       	brne	.+18     	; 0x3cf6 <ramDyskZapiszBajtDoPliku+0x26>
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
    3ce4:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <znajdzWolnyKlaster>
    3ce8:	88 23       	and	r24, r24
    3cea:	11 f4       	brne	.+4      	; 0x3cf0 <ramDyskZapiszBajtDoPliku+0x20>
    3cec:	81 e0       	ldi	r24, 0x01	; 1
    3cee:	3e c0       	rjmp	.+124    	; 0x3d6c <ramDyskZapiszBajtDoPliku+0x9c>
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    fd->wpis->pierwszyKlaster = tmpKlaster;
    3cf0:	ec 81       	ldd	r30, Y+4	; 0x04
    3cf2:	fd 81       	ldd	r31, Y+5	; 0x05
    3cf4:	80 83       	st	Z, r24
  }
  if (fd->IndLo == 0)
    3cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    3cf8:	88 23       	and	r24, r24
    3cfa:	79 f4       	brne	.+30     	; 0x3d1a <ramDyskZapiszBajtDoPliku+0x4a>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    3cfc:	ec 81       	ldd	r30, Y+4	; 0x04
    3cfe:	fd 81       	ldd	r31, Y+5	; 0x05
    3d00:	80 81       	ld	r24, Z
    3d02:	6b 81       	ldd	r22, Y+3	; 0x03
    3d04:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <znajdzKlasterN>
    if (tmpKlaster == 0)
    3d08:	88 23       	and	r24, r24
    3d0a:	11 f4       	brne	.+4      	; 0x3d10 <ramDyskZapiszBajtDoPliku+0x40>
    3d0c:	82 e0       	ldi	r24, 0x02	; 2
    3d0e:	2e c0       	rjmp	.+92     	; 0x3d6c <ramDyskZapiszBajtDoPliku+0x9c>
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    }
    fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego klastra
    3d10:	90 e0       	ldi	r25, 0x00	; 0
    3d12:	80 58       	subi	r24, 0x80	; 128
    3d14:	9f 4f       	sbci	r25, 0xFF	; 255
    3d16:	18 82       	st	Y, r1
    3d18:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
    3d1a:	e8 81       	ld	r30, Y
    3d1c:	f9 81       	ldd	r31, Y+1	; 0x01
    3d1e:	10 83       	st	Z, r17

  fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
    3d20:	8a 81       	ldd	r24, Y+2	; 0x02
    3d22:	8f 5f       	subi	r24, 0xFF	; 255
    3d24:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, że czły klaster jest zapisany
    3d26:	88 23       	and	r24, r24
    3d28:	21 f4       	brne	.+8      	; 0x3d32 <ramDyskZapiszBajtDoPliku+0x62>
    fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt indeksu. Nie utworzono nowego klastra, zatem nie uaktualniamy wskaźnika
    3d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d2c:	8f 5f       	subi	r24, 0xFF	; 255
    3d2e:	8b 83       	std	Y+3, r24	; 0x03
    3d30:	05 c0       	rjmp	.+10     	; 0x3d3c <ramDyskZapiszBajtDoPliku+0x6c>
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    3d32:	88 81       	ld	r24, Y
    3d34:	99 81       	ldd	r25, Y+1	; 0x01
    3d36:	01 96       	adiw	r24, 0x01	; 1
    3d38:	99 83       	std	Y+1, r25	; 0x01
    3d3a:	88 83       	st	Y, r24
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    3d3c:	ec 81       	ldd	r30, Y+4	; 0x04
    3d3e:	fd 81       	ldd	r31, Y+5	; 0x05
    3d40:	92 81       	ldd	r25, Z+2	; 0x02
    3d42:	8b 81       	ldd	r24, Y+3	; 0x03
    3d44:	98 17       	cp	r25, r24
    3d46:	29 f4       	brne	.+10     	; 0x3d52 <ramDyskZapiszBajtDoPliku+0x82>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    3d48:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4a:	81 81       	ldd	r24, Z+1	; 0x01
    3d4c:	89 17       	cp	r24, r25
    3d4e:	08 f4       	brcc	.+2      	; 0x3d52 <ramDyskZapiszBajtDoPliku+0x82>
      fd->wpis->rozmiarLo = fd->IndLo;
    3d50:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    3d52:	ec 81       	ldd	r30, Y+4	; 0x04
    3d54:	fd 81       	ldd	r31, Y+5	; 0x05
    3d56:	92 81       	ldd	r25, Z+2	; 0x02
    3d58:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5a:	98 17       	cp	r25, r24
    3d5c:	30 f4       	brcc	.+12     	; 0x3d6a <ramDyskZapiszBajtDoPliku+0x9a>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    3d5e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d60:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    3d62:	ec 81       	ldd	r30, Y+4	; 0x04
    3d64:	fd 81       	ldd	r31, Y+5	; 0x05
    3d66:	8b 81       	ldd	r24, Y+3	; 0x03
    3d68:	82 83       	std	Z+2, r24	; 0x02
    3d6a:	80 e0       	ldi	r24, 0x00	; 0
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}
    3d6c:	df 91       	pop	r29
    3d6e:	cf 91       	pop	r28
    3d70:	1f 91       	pop	r17
    3d72:	08 95       	ret

00003d74 <putSTD>:
    return wynik;
  return EOF;
}

static int putSTD(char c, FILE *stream)
{
    3d74:	28 2f       	mov	r18, r24
    3d76:	fb 01       	movw	r30, r22
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
    3d78:	84 85       	ldd	r24, Z+12	; 0x0c
    3d7a:	95 85       	ldd	r25, Z+13	; 0x0d
    3d7c:	62 2f       	mov	r22, r18
    3d7e:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <ramDyskZapiszBajtDoPliku>
}
    3d82:	90 e0       	ldi	r25, 0x00	; 0
    3d84:	08 95       	ret

00003d86 <ramDyskCzyscPlik>:
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
  }
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
    3d86:	cf 93       	push	r28
    3d88:	df 93       	push	r29
    3d8a:	9c 01       	movw	r18, r24
    3d8c:	0e c0       	rjmp	.+28     	; 0x3daa <ramDyskCzyscPlik+0x24>
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
  {
    usuwanyKlaster = fd->wpis->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3d8e:	a8 2f       	mov	r26, r24
    3d90:	b0 e0       	ldi	r27, 0x00	; 0
    3d92:	fd 01       	movw	r30, r26
    3d94:	e5 53       	subi	r30, 0x35	; 53
    3d96:	f1 4f       	sbci	r31, 0xF1	; 241
    3d98:	e0 81       	ld	r30, Z
    3d9a:	e8 17       	cp	r30, r24
    3d9c:	11 f4       	brne	.+4      	; 0x3da2 <ramDyskCzyscPlik+0x1c>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3d9e:	18 82       	st	Y, r1
    3da0:	01 c0       	rjmp	.+2      	; 0x3da4 <ramDyskCzyscPlik+0x1e>
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3da2:	e8 83       	st	Y, r30
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
    3da4:	a5 53       	subi	r26, 0x35	; 53
    3da6:	b1 4f       	sbci	r27, 0xF1	; 241
    3da8:	1c 92       	st	X, r1
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3daa:	d9 01       	movw	r26, r18
    3dac:	14 96       	adiw	r26, 0x04	; 4
    3dae:	cd 91       	ld	r28, X+
    3db0:	dc 91       	ld	r29, X
    3db2:	15 97       	sbiw	r26, 0x05	; 5
    3db4:	88 81       	ld	r24, Y
    3db6:	88 23       	and	r24, r24
    3db8:	51 f7       	brne	.-44     	; 0x3d8e <ramDyskCzyscPlik+0x8>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
  }
  fd->wpis->rozmiarLo       = 0;
    3dba:	19 82       	std	Y+1, r1	; 0x01
  fd->wpis->rozmiarHi       = 0;
    3dbc:	14 96       	adiw	r26, 0x04	; 4
    3dbe:	ed 91       	ld	r30, X+
    3dc0:	fc 91       	ld	r31, X
    3dc2:	15 97       	sbiw	r26, 0x05	; 5
    3dc4:	12 82       	std	Z+2, r1	; 0x02
  fd->wpis->dataMod         = systemTime();
    3dc6:	14 96       	adiw	r26, 0x04	; 4
    3dc8:	ed 91       	ld	r30, X+
    3dca:	fc 91       	ld	r31, X
    3dcc:	15 97       	sbiw	r26, 0x05	; 5
    3dce:	14 86       	std	Z+12, r1	; 0x0c
    3dd0:	15 86       	std	Z+13, r1	; 0x0d
    3dd2:	16 86       	std	Z+14, r1	; 0x0e
    3dd4:	17 86       	std	Z+15, r1	; 0x0f
  memset (fd, 0, 4);
    3dd6:	f9 01       	movw	r30, r18
    3dd8:	10 82       	st	Z, r1
    3dda:	11 82       	std	Z+1, r1	; 0x01
    3ddc:	12 82       	std	Z+2, r1	; 0x02
    3dde:	13 82       	std	Z+3, r1	; 0x03
  return 0;
}
    3de0:	df 91       	pop	r29
    3de2:	cf 91       	pop	r28
    3de4:	08 95       	ret

00003de6 <ramDyskZamknijPlik>:
//relokacjaTablicyWpisow()
  return 0;
}

void ramDyskZamknijPlik(struct ramPlikFd *fd)
{
    3de6:	dc 01       	movw	r26, r24
  if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest poprawny
    3de8:	14 96       	adiw	r26, 0x04	; 4
    3dea:	ed 91       	ld	r30, X+
    3dec:	fc 91       	ld	r31, X
    3dee:	15 97       	sbiw	r26, 0x05	; 5
    3df0:	83 81       	ldd	r24, Z+3	; 0x03
    3df2:	88 23       	and	r24, r24
    3df4:	39 f0       	breq	.+14     	; 0x3e04 <ramDyskZamknijPlik+0x1e>
  {
    fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
    3df6:	81 50       	subi	r24, 0x01	; 1
    3df8:	83 83       	std	Z+3, r24	; 0x03
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
    3dfa:	86 e0       	ldi	r24, 0x06	; 6
    3dfc:	fd 01       	movw	r30, r26
    3dfe:	11 92       	st	Z+, r1
    3e00:	8a 95       	dec	r24
    3e02:	e9 f7       	brne	.-6      	; 0x3dfe <ramDyskZamknijPlik+0x18>
    3e04:	08 95       	ret

00003e06 <ramDyskZamknijPlikStdIo>:
  fdev_set_udata(stream, fd);
  return 0;
}

uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
{
    3e06:	ef 92       	push	r14
    3e08:	ff 92       	push	r15
    3e0a:	0f 93       	push	r16
    3e0c:	1f 93       	push	r17
    3e0e:	8c 01       	movw	r16, r24
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
    3e10:	dc 01       	movw	r26, r24
    3e12:	1c 96       	adiw	r26, 0x0c	; 12
    3e14:	ed 90       	ld	r14, X+
    3e16:	fc 90       	ld	r15, X
    3e18:	1d 97       	sbiw	r26, 0x0d	; 13
  ramDyskZamknijPlik(fd);
    3e1a:	c7 01       	movw	r24, r14
    3e1c:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <ramDyskZamknijPlik>
  fclose(stream);
    3e20:	c8 01       	movw	r24, r16
    3e22:	0e 94 84 59 	call	0xb308	; 0xb308 <fclose>
    3e26:	d7 01       	movw	r26, r14
    3e28:	14 96       	adiw	r26, 0x04	; 4
    3e2a:	ed 91       	ld	r30, X+
    3e2c:	fc 91       	ld	r31, X
    3e2e:	15 97       	sbiw	r26, 0x05	; 5
  return fd->wpis->lAktOtw;
}
    3e30:	83 81       	ldd	r24, Z+3	; 0x03
    3e32:	1f 91       	pop	r17
    3e34:	0f 91       	pop	r16
    3e36:	ff 90       	pop	r15
    3e38:	ef 90       	pop	r14
    3e3a:	08 95       	ret

00003e3c <ramDyskInit>:
}


void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
    3e3c:	80 e8       	ldi	r24, 0x80	; 128
    3e3e:	eb ec       	ldi	r30, 0xCB	; 203
    3e40:	fe e0       	ldi	r31, 0x0E	; 14
    3e42:	df 01       	movw	r26, r30
    3e44:	1d 92       	st	X+, r1
    3e46:	8a 95       	dec	r24
    3e48:	e9 f7       	brne	.-6      	; 0x3e44 <ramDyskInit+0x8>
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
    3e4a:	80 e0       	ldi	r24, 0x00	; 0
    3e4c:	91 e0       	ldi	r25, 0x01	; 1
    3e4e:	e0 e0       	ldi	r30, 0x00	; 0
    3e50:	f0 e8       	ldi	r31, 0x80	; 128
    3e52:	df 01       	movw	r26, r30
    3e54:	9c 01       	movw	r18, r24
    3e56:	1d 92       	st	X+, r1
    3e58:	21 50       	subi	r18, 0x01	; 1
    3e5a:	30 40       	sbci	r19, 0x00	; 0
    3e5c:	e1 f7       	brne	.-8      	; 0x3e56 <ramDyskInit+0x1a>
}
    3e5e:	08 95       	ret

00003e60 <ramDyskCzytajBlokZPliku>:
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}

uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3e60:	9f 92       	push	r9
    3e62:	af 92       	push	r10
    3e64:	bf 92       	push	r11
    3e66:	cf 92       	push	r12
    3e68:	df 92       	push	r13
    3e6a:	ef 92       	push	r14
    3e6c:	ff 92       	push	r15
    3e6e:	0f 93       	push	r16
    3e70:	1f 93       	push	r17
    3e72:	cf 93       	push	r28
    3e74:	df 93       	push	r29
    3e76:	ec 01       	movw	r28, r24
    3e78:	5b 01       	movw	r10, r22
    3e7a:	6a 01       	movw	r12, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3e7c:	ec 81       	ldd	r30, Y+4	; 0x04
    3e7e:	fd 81       	ldd	r31, Y+5	; 0x05
    3e80:	80 81       	ld	r24, Z
    3e82:	88 23       	and	r24, r24
    3e84:	29 f4       	brne	.+10     	; 0x3e90 <ramDyskCzytajBlokZPliku+0x30>
  {
    *dlugosc = 0;
    3e86:	fa 01       	movw	r30, r20
    3e88:	11 82       	std	Z+1, r1	; 0x01
    3e8a:	10 82       	st	Z, r1
    3e8c:	81 e0       	ldi	r24, 0x01	; 1
    3e8e:	77 c0       	rjmp	.+238    	; 0x3f7e <ramDyskCzytajBlokZPliku+0x11e>
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3e90:	22 81       	ldd	r18, Z+2	; 0x02
    3e92:	3b 81       	ldd	r19, Y+3	; 0x03
    3e94:	32 17       	cp	r19, r18
    3e96:	40 f0       	brcs	.+16     	; 0x3ea8 <ramDyskCzytajBlokZPliku+0x48>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3e98:	23 17       	cp	r18, r19
    3e9a:	09 f0       	breq	.+2      	; 0x3e9e <ramDyskCzytajBlokZPliku+0x3e>
    3e9c:	7c c0       	rjmp	.+248    	; 0x3f96 <ramDyskCzytajBlokZPliku+0x136>
    3e9e:	91 81       	ldd	r25, Z+1	; 0x01
    3ea0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ea2:	98 17       	cp	r25, r24
    3ea4:	08 f4       	brcc	.+2      	; 0x3ea8 <ramDyskCzytajBlokZPliku+0x48>
    3ea6:	77 c0       	rjmp	.+238    	; 0x3f96 <ramDyskCzytajBlokZPliku+0x136>
  {
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
    3ea8:	82 2f       	mov	r24, r18
    3eaa:	90 e0       	ldi	r25, 0x00	; 0
    3eac:	83 1b       	sub	r24, r19
    3eae:	91 09       	sbc	r25, r1
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3eb0:	21 81       	ldd	r18, Z+1	; 0x01
    3eb2:	42 2f       	mov	r20, r18
    3eb4:	50 e0       	ldi	r21, 0x00	; 0
    3eb6:	2a 81       	ldd	r18, Y+2	; 0x02
    3eb8:	42 1b       	sub	r20, r18
    3eba:	51 09       	sbc	r21, r1
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
  
  uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i określenie ile bajtów zdoła się odczytać
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
    3ebc:	48 0f       	add	r20, r24
    3ebe:	59 1f       	adc	r21, r25
    3ec0:	f6 01       	movw	r30, r12
    3ec2:	e0 80       	ld	r14, Z
    3ec4:	f1 80       	ldd	r15, Z+1	; 0x01
    3ec6:	4e 15       	cp	r20, r14
    3ec8:	5f 05       	cpc	r21, r15
    3eca:	08 f4       	brcc	.+2      	; 0x3ece <ramDyskCzytajBlokZPliku+0x6e>
    3ecc:	7a 01       	movw	r14, r20
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
    3ece:	f6 01       	movw	r30, r12
    3ed0:	11 82       	std	Z+1, r1	; 0x01
    3ed2:	10 82       	st	Z, r1
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
    3ed4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ed6:	00 e0       	ldi	r16, 0x00	; 0
    3ed8:	11 e0       	ldi	r17, 0x01	; 1
    3eda:	08 1b       	sub	r16, r24
    3edc:	11 09       	sbc	r17, r1
    3ede:	99 24       	eor	r9, r9
    3ee0:	49 c0       	rjmp	.+146    	; 0x3f74 <ramDyskCzytajBlokZPliku+0x114>
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
  {
    if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, że wskaźnik nie jest jeszcze ustawiony
    3ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ee4:	88 23       	and	r24, r24
    3ee6:	b1 f4       	brne	.+44     	; 0x3f14 <ramDyskCzytajBlokZPliku+0xb4>
    {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (od początkowego) należy się przesunąć do przodu
      if (tmpKlaster == 0)
    3ee8:	99 20       	and	r9, r9
    3eea:	39 f4       	brne	.+14     	; 0x3efa <ramDyskCzytajBlokZPliku+0x9a>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
    3eec:	ec 81       	ldd	r30, Y+4	; 0x04
    3eee:	fd 81       	ldd	r31, Y+5	; 0x05
    3ef0:	80 81       	ld	r24, Z
    3ef2:	6b 81       	ldd	r22, Y+3	; 0x03
    3ef4:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <znajdzKlasterN>
    3ef8:	03 c0       	rjmp	.+6      	; 0x3f00 <ramDyskCzytajBlokZPliku+0xa0>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
    3efa:	89 2d       	mov	r24, r9
    3efc:	0e 94 fe 1c 	call	0x39fc	; 0x39fc <nastepnyKlaster>
    3f00:	98 2e       	mov	r9, r24
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
    3f02:	88 23       	and	r24, r24
    3f04:	11 f4       	brne	.+4      	; 0x3f0a <ramDyskCzytajBlokZPliku+0xaa>
    3f06:	83 e0       	ldi	r24, 0x03	; 3
    3f08:	3a c0       	rjmp	.+116    	; 0x3f7e <ramDyskCzytajBlokZPliku+0x11e>
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
    3f0a:	90 e0       	ldi	r25, 0x00	; 0
    3f0c:	80 58       	subi	r24, 0x80	; 128
    3f0e:	9f 4f       	sbci	r25, 0xFF	; 255
    3f10:	18 82       	st	Y, r1
    3f12:	89 83       	std	Y+1, r24	; 0x01
    3f14:	68 81       	ld	r22, Y
    3f16:	79 81       	ldd	r23, Y+1	; 0x01
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    }
    
    if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
    3f18:	0e 15       	cp	r16, r14
    3f1a:	1f 05       	cpc	r17, r15
    3f1c:	b0 f4       	brcc	.+44     	; 0x3f4a <ramDyskCzytajBlokZPliku+0xea>
    {                                  //dlBloku określa ile zostało jeszcze bajtów do końca klasrta
      memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
    3f1e:	c5 01       	movw	r24, r10
    3f20:	a8 01       	movw	r20, r16
    3f22:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
      znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy odczytane bajty
    3f26:	a0 0e       	add	r10, r16
    3f28:	b1 1e       	adc	r11, r17
      fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
    3f2a:	1a 82       	std	Y+2, r1	; 0x02
      fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz nie ma potrzeby ustawienia wskaźnika odczytu na jego początek
    3f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f2e:	8f 5f       	subi	r24, 0xFF	; 255
    3f30:	8b 83       	std	Y+3, r24	; 0x03
      doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
    3f32:	e0 1a       	sub	r14, r16
    3f34:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;             //Uaktualnienie 
    3f36:	f6 01       	movw	r30, r12
    3f38:	80 81       	ld	r24, Z
    3f3a:	91 81       	ldd	r25, Z+1	; 0x01
    3f3c:	80 0f       	add	r24, r16
    3f3e:	91 1f       	adc	r25, r17
    3f40:	91 83       	std	Z+1, r25	; 0x01
    3f42:	80 83       	st	Z, r24
    3f44:	00 e0       	ldi	r16, 0x00	; 0
    3f46:	11 e0       	ldi	r17, 0x01	; 1
    3f48:	15 c0       	rjmp	.+42     	; 0x3f74 <ramDyskCzytajBlokZPliku+0x114>
      dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całego klastra.
    }
    else                               //Ostatnia operacja odczytu
    {
      memcpy(znaki, fd->Wsk, doOdczytania);
    3f4a:	c5 01       	movw	r24, r10
    3f4c:	a7 01       	movw	r20, r14
    3f4e:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
      fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym samym klastrze, zatem trzeba teraz uaktualnić wzkaźnik
    3f52:	88 81       	ld	r24, Y
    3f54:	99 81       	ldd	r25, Y+1	; 0x01
    3f56:	8e 0d       	add	r24, r14
    3f58:	9f 1d       	adc	r25, r15
    3f5a:	99 83       	std	Y+1, r25	; 0x01
    3f5c:	88 83       	st	Y, r24
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
    3f5e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f60:	8e 0d       	add	r24, r14
    3f62:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
    3f64:	f6 01       	movw	r30, r12
    3f66:	80 81       	ld	r24, Z
    3f68:	91 81       	ldd	r25, Z+1	; 0x01
    3f6a:	8e 0d       	add	r24, r14
    3f6c:	9f 1d       	adc	r25, r15
    3f6e:	91 83       	std	Z+1, r25	; 0x01
    3f70:	80 83       	st	Z, r24
    3f72:	04 c0       	rjmp	.+8      	; 0x3f7c <ramDyskCzytajBlokZPliku+0x11c>
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
    3f74:	e1 14       	cp	r14, r1
    3f76:	f1 04       	cpc	r15, r1
    3f78:	09 f0       	breq	.+2      	; 0x3f7c <ramDyskCzytajBlokZPliku+0x11c>
    3f7a:	b3 cf       	rjmp	.-154    	; 0x3ee2 <ramDyskCzytajBlokZPliku+0x82>
    3f7c:	80 e0       	ldi	r24, 0x00	; 0
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
}
    3f7e:	df 91       	pop	r29
    3f80:	cf 91       	pop	r28
    3f82:	1f 91       	pop	r17
    3f84:	0f 91       	pop	r16
    3f86:	ff 90       	pop	r15
    3f88:	ef 90       	pop	r14
    3f8a:	df 90       	pop	r13
    3f8c:	cf 90       	pop	r12
    3f8e:	bf 90       	pop	r11
    3f90:	af 90       	pop	r10
    3f92:	9f 90       	pop	r9
    3f94:	08 95       	ret
    *dlugosc = 0;
    return 1;                         //1 - Plik jest pusty
  }
  if (wObrebiePliku(fd) != 0)
  {
    *dlugosc = 0;
    3f96:	f6 01       	movw	r30, r12
    3f98:	11 82       	std	Z+1, r1	; 0x01
    3f9a:	10 82       	st	Z, r1
    3f9c:	82 e0       	ldi	r24, 0x02	; 2
    3f9e:	ef cf       	rjmp	.-34     	; 0x3f7e <ramDyskCzytajBlokZPliku+0x11e>

00003fa0 <ramDyskZapiszBlokDoPliku>:
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}

uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3fa0:	8f 92       	push	r8
    3fa2:	9f 92       	push	r9
    3fa4:	bf 92       	push	r11
    3fa6:	cf 92       	push	r12
    3fa8:	df 92       	push	r13
    3faa:	ef 92       	push	r14
    3fac:	ff 92       	push	r15
    3fae:	0f 93       	push	r16
    3fb0:	1f 93       	push	r17
    3fb2:	cf 93       	push	r28
    3fb4:	df 93       	push	r29
    3fb6:	ec 01       	movw	r28, r24
    3fb8:	6b 01       	movw	r12, r22
    3fba:	4a 01       	movw	r8, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3fbc:	0c 81       	ldd	r16, Y+4	; 0x04
    3fbe:	1d 81       	ldd	r17, Y+5	; 0x05
    3fc0:	f8 01       	movw	r30, r16
    3fc2:	80 81       	ld	r24, Z
    3fc4:	88 23       	and	r24, r24
    3fc6:	21 f4       	brne	.+8      	; 0x3fd0 <ramDyskZapiszBlokDoPliku+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    3fc8:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <znajdzWolnyKlaster>
    3fcc:	f8 01       	movw	r30, r16
    3fce:	80 83       	st	Z, r24
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
    3fd0:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd2:	00 e0       	ldi	r16, 0x00	; 0
    3fd4:	11 e0       	ldi	r17, 0x01	; 1
    3fd6:	08 1b       	sub	r16, r24
    3fd8:	11 09       	sbc	r17, r1
  uint16_t doZapisu = *dlugosc;
    3fda:	f4 01       	movw	r30, r8
    3fdc:	e0 80       	ld	r14, Z
    3fde:	f1 80       	ldd	r15, Z+1	; 0x01
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
    3fe0:	11 82       	std	Z+1, r1	; 0x01
    3fe2:	10 82       	st	Z, r1
    3fe4:	bb 24       	eor	r11, r11
    3fe6:	4e c0       	rjmp	.+156    	; 0x4084 <ramDyskZapiszBlokDoPliku+0xe4>
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
  {
    if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to należy odczytać jego numer oraz ustawić na niego wskaźnik
    3fe8:	8a 81       	ldd	r24, Y+2	; 0x02
    3fea:	88 23       	and	r24, r24
    3fec:	b1 f4       	brne	.+44     	; 0x401a <ramDyskZapiszBlokDoPliku+0x7a>
    {
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
    3fee:	bb 20       	and	r11, r11
    3ff0:	39 f4       	brne	.+14     	; 0x4000 <ramDyskZapiszBlokDoPliku+0x60>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
    3ff2:	ec 81       	ldd	r30, Y+4	; 0x04
    3ff4:	fd 81       	ldd	r31, Y+5	; 0x05
    3ff6:	80 81       	ld	r24, Z
    3ff8:	6b 81       	ldd	r22, Y+3	; 0x03
    3ffa:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <znajdzKlasterN>
    3ffe:	03 c0       	rjmp	.+6      	; 0x4006 <ramDyskZapiszBlokDoPliku+0x66>
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
    4000:	8b 2d       	mov	r24, r11
    4002:	0e 94 fe 1c 	call	0x39fc	; 0x39fc <nastepnyKlaster>
    4006:	b8 2e       	mov	r11, r24
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
    4008:	88 23       	and	r24, r24
    400a:	11 f4       	brne	.+4      	; 0x4010 <ramDyskZapiszBlokDoPliku+0x70>
    400c:	81 e0       	ldi	r24, 0x01	; 1
    400e:	56 c0       	rjmp	.+172    	; 0x40bc <ramDyskZapiszBlokDoPliku+0x11c>
        return 1;                                 //1 - Brak wolnego klastra

      fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Teraz można do niego już pisać
    4010:	90 e0       	ldi	r25, 0x00	; 0
    4012:	80 58       	subi	r24, 0x80	; 128
    4014:	9f 4f       	sbci	r25, 0xFF	; 255
    4016:	18 82       	st	Y, r1
    4018:	89 83       	std	Y+1, r24	; 0x01
    401a:	88 81       	ld	r24, Y
    401c:	99 81       	ldd	r25, Y+1	; 0x01
    }
    if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w bieżącym klastrze
    401e:	0e 15       	cp	r16, r14
    4020:	1f 05       	cpc	r17, r15
    4022:	b0 f4       	brcc	.+44     	; 0x4050 <ramDyskZapiszBlokDoPliku+0xb0>
    {                                             //Nie uda się, teraz zapiszemy cały klastr do końca
      memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
    4024:	b6 01       	movw	r22, r12
    4026:	a8 01       	movw	r20, r16
    4028:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
      znaki +=dlBloku;                      
    402c:	c0 0e       	add	r12, r16
    402e:	d1 1e       	adc	r13, r17
      fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na początek nowego klastra. Kolejna iteracja go utworzy
    4030:	1a 82       	std	Y+2, r1	; 0x02
      doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka pozostałą do zapisujemy
    4032:	e0 1a       	sub	r14, r16
    4034:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych danych
    4036:	f4 01       	movw	r30, r8
    4038:	80 81       	ld	r24, Z
    403a:	91 81       	ldd	r25, Z+1	; 0x01
    403c:	80 0f       	add	r24, r16
    403e:	91 1f       	adc	r25, r17
    4040:	91 83       	std	Z+1, r25	; 0x01
    4042:	80 83       	st	Z, r24
      fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. Oznacza to przejście do kolejnego klastra
    4044:	8b 81       	ldd	r24, Y+3	; 0x03
    4046:	8f 5f       	subi	r24, 0xFF	; 255
    4048:	8b 83       	std	Y+3, r24	; 0x03
    404a:	00 e0       	ldi	r16, 0x00	; 0
    404c:	11 e0       	ldi	r17, 0x01	; 1
    404e:	1a c0       	rjmp	.+52     	; 0x4084 <ramDyskZapiszBlokDoPliku+0xe4>
      dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 bajtów
    }
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
    4050:	b6 01       	movw	r22, r12
    4052:	a7 01       	movw	r20, r14
    4054:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
    4058:	8a 81       	ldd	r24, Y+2	; 0x02
    405a:	8e 0d       	add	r24, r14
    405c:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
    405e:	f4 01       	movw	r30, r8
    4060:	80 81       	ld	r24, Z
    4062:	91 81       	ldd	r25, Z+1	; 0x01
    4064:	8e 0d       	add	r24, r14
    4066:	9f 1d       	adc	r25, r15
    4068:	91 83       	std	Z+1, r25	; 0x01
    406a:	80 83       	st	Z, r24
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    406c:	8b 2d       	mov	r24, r11
    406e:	90 e0       	ldi	r25, 0x00	; 0
    4070:	80 58       	subi	r24, 0x80	; 128
    4072:	9f 4f       	sbci	r25, 0xFF	; 255
    4074:	98 2f       	mov	r25, r24
    4076:	88 27       	eor	r24, r24
    4078:	2a 81       	ldd	r18, Y+2	; 0x02
    407a:	82 0f       	add	r24, r18
    407c:	91 1d       	adc	r25, r1
    407e:	99 83       	std	Y+1, r25	; 0x01
    4080:	88 83       	st	Y, r24
    4082:	04 c0       	rjmp	.+8      	; 0x408c <ramDyskZapiszBlokDoPliku+0xec>
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
  uint16_t doZapisu = *dlugosc;
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
    4084:	e1 14       	cp	r14, r1
    4086:	f1 04       	cpc	r15, r1
    4088:	09 f0       	breq	.+2      	; 0x408c <ramDyskZapiszBlokDoPliku+0xec>
    408a:	ae cf       	rjmp	.-164    	; 0x3fe8 <ramDyskZapiszBlokDoPliku+0x48>
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    408c:	ec 81       	ldd	r30, Y+4	; 0x04
    408e:	fd 81       	ldd	r31, Y+5	; 0x05
    4090:	92 81       	ldd	r25, Z+2	; 0x02
    4092:	8b 81       	ldd	r24, Y+3	; 0x03
    4094:	98 17       	cp	r25, r24
    4096:	29 f4       	brne	.+10     	; 0x40a2 <ramDyskZapiszBlokDoPliku+0x102>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    4098:	9a 81       	ldd	r25, Y+2	; 0x02
    409a:	81 81       	ldd	r24, Z+1	; 0x01
    409c:	89 17       	cp	r24, r25
    409e:	08 f4       	brcc	.+2      	; 0x40a2 <ramDyskZapiszBlokDoPliku+0x102>
      fd->wpis->rozmiarLo = fd->IndLo;
    40a0:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    40a2:	ec 81       	ldd	r30, Y+4	; 0x04
    40a4:	fd 81       	ldd	r31, Y+5	; 0x05
    40a6:	92 81       	ldd	r25, Z+2	; 0x02
    40a8:	8b 81       	ldd	r24, Y+3	; 0x03
    40aa:	98 17       	cp	r25, r24
    40ac:	30 f4       	brcc	.+12     	; 0x40ba <ramDyskZapiszBlokDoPliku+0x11a>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    40ae:	8a 81       	ldd	r24, Y+2	; 0x02
    40b0:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    40b2:	ec 81       	ldd	r30, Y+4	; 0x04
    40b4:	fd 81       	ldd	r31, Y+5	; 0x05
    40b6:	8b 81       	ldd	r24, Y+3	; 0x03
    40b8:	82 83       	std	Z+2, r24	; 0x02
    40ba:	80 e0       	ldi	r24, 0x00	; 0
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}
    40bc:	df 91       	pop	r29
    40be:	cf 91       	pop	r28
    40c0:	1f 91       	pop	r17
    40c2:	0f 91       	pop	r16
    40c4:	ff 90       	pop	r15
    40c6:	ef 90       	pop	r14
    40c8:	df 90       	pop	r13
    40ca:	cf 90       	pop	r12
    40cc:	bf 90       	pop	r11
    40ce:	9f 90       	pop	r9
    40d0:	8f 90       	pop	r8
    40d2:	08 95       	ret

000040d4 <znajdzPlik>:
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
{
    40d4:	af 92       	push	r10
    40d6:	bf 92       	push	r11
    40d8:	cf 92       	push	r12
    40da:	df 92       	push	r13
    40dc:	ef 92       	push	r14
    40de:	ff 92       	push	r15
    40e0:	0f 93       	push	r16
    40e2:	1f 93       	push	r17
    40e4:	cf 93       	push	r28
    40e6:	df 93       	push	r29
    40e8:	6c 01       	movw	r12, r24
  uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
    40ea:	fc 01       	movw	r30, r24
    40ec:	01 90       	ld	r0, Z+
    40ee:	00 20       	and	r0, r0
    40f0:	e9 f7       	brne	.-6      	; 0x40ec <znajdzPlik+0x18>
    40f2:	31 97       	sbiw	r30, 0x01	; 1
    40f4:	fe 2e       	mov	r15, r30
    40f6:	f8 1a       	sub	r15, r24
    40f8:	88 e0       	ldi	r24, 0x08	; 8
    40fa:	8f 15       	cp	r24, r15
    40fc:	10 f4       	brcc	.+4      	; 0x4102 <znajdzPlik+0x2e>
    40fe:	a8 e0       	ldi	r26, 0x08	; 8
    4100:	fa 2e       	mov	r15, r26
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  
  if (nazwa[dlNazwy-1] == 0)
    4102:	f6 01       	movw	r30, r12
    4104:	ef 0d       	add	r30, r15
    4106:	f1 1d       	adc	r31, r1
    4108:	31 97       	sbiw	r30, 0x01	; 1
    410a:	80 81       	ld	r24, Z
    410c:	88 23       	and	r24, r24
    410e:	09 f4       	brne	.+2      	; 0x4112 <znajdzPlik+0x3e>
    dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
    4110:	fa 94       	dec	r15
    4112:	f6 01       	movw	r30, r12
    4114:	91 e0       	ldi	r25, 0x01	; 1
    4116:	07 c0       	rjmp	.+14     	; 0x4126 <znajdzPlik+0x52>
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    4118:	81 81       	ldd	r24, Z+1	; 0x01
    411a:	31 96       	adiw	r30, 0x01	; 1
    411c:	80 32       	cpi	r24, 0x20	; 32
    411e:	11 f4       	brne	.+4      	; 0x4124 <znajdzPlik+0x50>
    4120:	f9 2e       	mov	r15, r25
    4122:	05 c0       	rjmp	.+10     	; 0x412e <znajdzPlik+0x5a>
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    4124:	9f 5f       	subi	r25, 0xFF	; 255
    4126:	9f 15       	cp	r25, r15
    4128:	b8 f3       	brcs	.-18     	; 0x4118 <znajdzPlik+0x44>
    {
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    412a:	ff 20       	and	r15, r15
    412c:	29 f1       	breq	.+74     	; 0x4178 <znajdzPlik+0xa4>
    412e:	ee 24       	eor	r14, r14
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    4130:	0e 2d       	mov	r16, r14
    4132:	10 e0       	ldi	r17, 0x00	; 0
    4134:	00 58       	subi	r16, 0x80	; 128
    4136:	1f 4f       	sbci	r17, 0xFF	; 255
    4138:	d0 2f       	mov	r29, r16
    413a:	cc 27       	eor	r28, r28
    413c:	00 58       	subi	r16, 0x80	; 128
    413e:	10 40       	sbci	r17, 0x00	; 0
    for (temp=0; temp <16; temp++)
    4140:	e0 ef       	ldi	r30, 0xF0	; 240
    4142:	ae 2e       	mov	r10, r30
    4144:	b1 2c       	mov	r11, r1
    4146:	ac 0e       	add	r10, r28
    4148:	bd 1e       	adc	r11, r29
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    414a:	be 01       	movw	r22, r28
    414c:	6c 5f       	subi	r22, 0xFC	; 252
    414e:	7f 4f       	sbci	r23, 0xFF	; 255
    4150:	c6 01       	movw	r24, r12
    4152:	4f 2d       	mov	r20, r15
    4154:	50 e0       	ldi	r21, 0x00	; 0
    4156:	0e 94 67 59 	call	0xb2ce	; 0xb2ce <strncmp>
    415a:	00 97       	sbiw	r24, 0x00	; 0
    415c:	79 f0       	breq	.+30     	; 0x417c <znajdzPlik+0xa8>
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    415e:	ca 15       	cp	r28, r10
    4160:	db 05       	cpc	r29, r11
    4162:	11 f0       	breq	.+4      	; 0x4168 <znajdzPlik+0x94>
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    4164:	60 96       	adiw	r28, 0x10	; 16
    4166:	f1 cf       	rjmp	.-30     	; 0x414a <znajdzPlik+0x76>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    4168:	05 53       	subi	r16, 0x35	; 53
    416a:	11 4f       	sbci	r17, 0xF1	; 241
    416c:	f8 01       	movw	r30, r16
    416e:	80 81       	ld	r24, Z
  }
  while (tempKlaster2 != tempKlaster);
    4170:	e8 16       	cp	r14, r24
    4172:	11 f0       	breq	.+4      	; 0x4178 <znajdzPlik+0xa4>
    4174:	e8 2e       	mov	r14, r24
    4176:	dc cf       	rjmp	.-72     	; 0x4130 <znajdzPlik+0x5c>
    4178:	c0 e0       	ldi	r28, 0x00	; 0
    417a:	d0 e0       	ldi	r29, 0x00	; 0
  return NULL;
}
    417c:	ce 01       	movw	r24, r28
    417e:	df 91       	pop	r29
    4180:	cf 91       	pop	r28
    4182:	1f 91       	pop	r17
    4184:	0f 91       	pop	r16
    4186:	ff 90       	pop	r15
    4188:	ef 90       	pop	r14
    418a:	df 90       	pop	r13
    418c:	cf 90       	pop	r12
    418e:	bf 90       	pop	r11
    4190:	af 90       	pop	r10
    4192:	08 95       	ret

00004194 <ramDyskUsunPlik>:
  }
  return wynik;
}

uint8_t ramDyskUsunPlik(const char *nazwa)
{
    4194:	cf 93       	push	r28
    4196:	df 93       	push	r29
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    4198:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <znajdzPlik>
    419c:	ec 01       	movw	r28, r24
    419e:	00 97       	sbiw	r24, 0x00	; 0
    41a0:	11 f4       	brne	.+4      	; 0x41a6 <ramDyskUsunPlik+0x12>
    41a2:	81 e0       	ldi	r24, 0x01	; 1
    41a4:	1c c0       	rjmp	.+56     	; 0x41de <ramDyskUsunPlik+0x4a>
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    41a6:	8b 81       	ldd	r24, Y+3	; 0x03
    41a8:	88 23       	and	r24, r24
    41aa:	81 f0       	breq	.+32     	; 0x41cc <ramDyskUsunPlik+0x38>
    41ac:	82 e0       	ldi	r24, 0x02	; 2
    41ae:	17 c0       	rjmp	.+46     	; 0x41de <ramDyskUsunPlik+0x4a>
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
  {
    usuwanyKlaster = plik->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatniego klastra
    41b0:	a8 2f       	mov	r26, r24
    41b2:	b0 e0       	ldi	r27, 0x00	; 0
    41b4:	fd 01       	movw	r30, r26
    41b6:	e5 53       	subi	r30, 0x35	; 53
    41b8:	f1 4f       	sbci	r31, 0xF1	; 241
    41ba:	e0 81       	ld	r30, Z
    41bc:	e8 17       	cp	r30, r24
    41be:	11 f4       	brne	.+4      	; 0x41c4 <ramDyskUsunPlik+0x30>
      plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    41c0:	18 82       	st	Y, r1
    41c2:	01 c0       	rjmp	.+2      	; 0x41c6 <ramDyskUsunPlik+0x32>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    41c4:	e8 83       	st	Y, r30
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
    41c6:	a5 53       	subi	r26, 0x35	; 53
    41c8:	b1 4f       	sbci	r27, 0xF1	; 241
    41ca:	1c 92       	st	X, r1
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    41cc:	88 81       	ld	r24, Y
    41ce:	88 23       	and	r24, r24
    41d0:	79 f7       	brne	.-34     	; 0x41b0 <ramDyskUsunPlik+0x1c>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
    41d2:	80 e1       	ldi	r24, 0x10	; 16
    41d4:	fe 01       	movw	r30, r28
    41d6:	11 92       	st	Z+, r1
    41d8:	8a 95       	dec	r24
    41da:	e9 f7       	brne	.-6      	; 0x41d6 <ramDyskUsunPlik+0x42>
    41dc:	80 e0       	ldi	r24, 0x00	; 0
//relokacjaTablicyWpisow()
  return 0;
}
    41de:	df 91       	pop	r29
    41e0:	cf 91       	pop	r28
    41e2:	08 95       	ret

000041e4 <ramDyskOtworzPlik>:
  }
  return 1;
}

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
    41e4:	cf 93       	push	r28
    41e6:	df 93       	push	r29
    41e8:	eb 01       	movw	r28, r22
  uint8_t wynik = 1;
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    41ea:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <znajdzPlik>
    41ee:	fc 01       	movw	r30, r24
    41f0:	00 97       	sbiw	r24, 0x00	; 0
    41f2:	11 f4       	brne	.+4      	; 0x41f8 <ramDyskOtworzPlik+0x14>
    41f4:	81 e0       	ldi	r24, 0x01	; 1
    41f6:	0b c0       	rjmp	.+22     	; 0x420e <ramDyskOtworzPlik+0x2a>
  {
    memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
    41f8:	83 e0       	ldi	r24, 0x03	; 3
    41fa:	de 01       	movw	r26, r28
    41fc:	1d 92       	st	X+, r1
    41fe:	8a 95       	dec	r24
    4200:	e9 f7       	brne	.-6      	; 0x41fc <ramDyskOtworzPlik+0x18>
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    4202:	fd 83       	std	Y+5, r31	; 0x05
    4204:	ec 83       	std	Y+4, r30	; 0x04
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    4206:	83 81       	ldd	r24, Z+3	; 0x03
    4208:	8f 5f       	subi	r24, 0xFF	; 255
    420a:	83 83       	std	Z+3, r24	; 0x03
    420c:	80 e0       	ldi	r24, 0x00	; 0
    wynik = 0;
  }
  return wynik;
}
    420e:	df 91       	pop	r29
    4210:	cf 91       	pop	r28
    4212:	08 95       	ret

00004214 <ramDyskOtworzPlikStdIo>:
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
}

uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags)
{
    4214:	ff 92       	push	r15
    4216:	0f 93       	push	r16
    4218:	1f 93       	push	r17
    421a:	cf 93       	push	r28
    421c:	df 93       	push	r29
    421e:	8b 01       	movw	r16, r22
    4220:	ea 01       	movw	r28, r20
    4222:	f2 2e       	mov	r15, r18
  uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
    4224:	0e 94 f2 20 	call	0x41e4	; 0x41e4 <ramDyskOtworzPlik>
    4228:	28 2f       	mov	r18, r24
  if (wynik != 0)
    422a:	88 23       	and	r24, r24
    422c:	59 f4       	brne	.+22     	; 0x4244 <ramDyskOtworzPlikStdIo+0x30>
    return wynik;
  
  fdev_setup_stream(stream, putSTD, getSTD, flags);
    422e:	8a eb       	ldi	r24, 0xBA	; 186
    4230:	9e e1       	ldi	r25, 0x1E	; 30
    4232:	99 87       	std	Y+9, r25	; 0x09
    4234:	88 87       	std	Y+8, r24	; 0x08
    4236:	8e e4       	ldi	r24, 0x4E	; 78
    4238:	9e e1       	ldi	r25, 0x1E	; 30
    423a:	9b 87       	std	Y+11, r25	; 0x0b
    423c:	8a 87       	std	Y+10, r24	; 0x0a
    423e:	fb 82       	std	Y+3, r15	; 0x03
  fdev_set_udata(stream, fd);
    4240:	1d 87       	std	Y+13, r17	; 0x0d
    4242:	0c 87       	std	Y+12, r16	; 0x0c
  return 0;
}
    4244:	82 2f       	mov	r24, r18
    4246:	df 91       	pop	r29
    4248:	cf 91       	pop	r28
    424a:	1f 91       	pop	r17
    424c:	0f 91       	pop	r16
    424e:	ff 90       	pop	r15
    4250:	08 95       	ret

00004252 <ramDyskUtworzPlik>:
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
}
uint8_t ramDyskUtworzPlik(const char *nazwa)
{                                        //Nowo utworzony plik nie zajmuje żadnego klastra
    4252:	ff 92       	push	r15
    4254:	0f 93       	push	r16
    4256:	1f 93       	push	r17
    4258:	cf 93       	push	r28
    425a:	df 93       	push	r29
    425c:	08 2f       	mov	r16, r24
    425e:	f9 2e       	mov	r15, r25
  uint8_t dlNazwy = strlen(nazwa);
    4260:	a8 2f       	mov	r26, r24
    4262:	b9 2f       	mov	r27, r25
    4264:	fd 01       	movw	r30, r26
    4266:	01 90       	ld	r0, Z+
    4268:	00 20       	and	r0, r0
    426a:	e9 f7       	brne	.-6      	; 0x4266 <ramDyskUtworzPlik+0x14>
    426c:	31 97       	sbiw	r30, 0x01	; 1
    426e:	1e 2f       	mov	r17, r30
    4270:	18 1b       	sub	r17, r24
    4272:	19 30       	cpi	r17, 0x09	; 9
    4274:	08 f0       	brcs	.+2      	; 0x4278 <ramDyskUtworzPlik+0x26>
    4276:	18 e0       	ldi	r17, 0x08	; 8
    4278:	80 2f       	mov	r24, r16
    427a:	9f 2d       	mov	r25, r15
    427c:	9c 01       	movw	r18, r24
    427e:	f9 01       	movw	r30, r18
    4280:	90 e0       	ldi	r25, 0x00	; 0
    4282:	06 c0       	rjmp	.+12     	; 0x4290 <ramDyskUtworzPlik+0x3e>
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
  {  if (nazwa[i] == ' ')
    4284:	81 91       	ld	r24, Z+
    4286:	80 32       	cpi	r24, 0x20	; 32
    4288:	11 f4       	brne	.+4      	; 0x428e <ramDyskUtworzPlik+0x3c>
    428a:	19 2f       	mov	r17, r25
    428c:	03 c0       	rjmp	.+6      	; 0x4294 <ramDyskUtworzPlik+0x42>
  uint8_t dlNazwy = strlen(nazwa);
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    428e:	9f 5f       	subi	r25, 0xFF	; 255
    4290:	91 17       	cp	r25, r17
    4292:	c0 f3       	brcs	.-16     	; 0x4284 <ramDyskUtworzPlik+0x32>
     {
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    4294:	11 23       	and	r17, r17
    4296:	09 f4       	brne	.+2      	; 0x429a <ramDyskUtworzPlik+0x48>
    4298:	3f c0       	rjmp	.+126    	; 0x4318 <ramDyskUtworzPlik+0xc6>
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    429a:	80 2f       	mov	r24, r16
    429c:	9f 2d       	mov	r25, r15
    429e:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <znajdzPlik>
    42a2:	89 2b       	or	r24, r25
    42a4:	c9 f5       	brne	.+114    	; 0x4318 <ramDyskUtworzPlik+0xc6>
    42a6:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t temp;
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    42a8:	29 2f       	mov	r18, r25
    42aa:	30 e0       	ldi	r19, 0x00	; 0
    42ac:	20 58       	subi	r18, 0x80	; 128
    42ae:	3f 4f       	sbci	r19, 0xFF	; 255
    42b0:	d2 2f       	mov	r29, r18
    42b2:	cc 27       	eor	r28, r28
    42b4:	20 58       	subi	r18, 0x80	; 128
    42b6:	30 40       	sbci	r19, 0x00	; 0
    for (temp=0; temp <16; temp++)
    42b8:	ae 01       	movw	r20, r28
    42ba:	40 51       	subi	r20, 0x10	; 16
    42bc:	5f 4f       	sbci	r21, 0xFF	; 255
    {
      if (plik->nazwa[0] == 0)
    42be:	8c 81       	ldd	r24, Y+4	; 0x04
    42c0:	88 23       	and	r24, r24
    42c2:	b9 f0       	breq	.+46     	; 0x42f2 <ramDyskUtworzPlik+0xa0>
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    42c4:	c4 17       	cp	r28, r20
    42c6:	d5 07       	cpc	r29, r21
    42c8:	11 f0       	breq	.+4      	; 0x42ce <ramDyskUtworzPlik+0x7c>
    {
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    42ca:	60 96       	adiw	r28, 0x10	; 16
    42cc:	f8 cf       	rjmp	.-16     	; 0x42be <ramDyskUtworzPlik+0x6c>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    42ce:	e9 01       	movw	r28, r18
    42d0:	c5 53       	subi	r28, 0x35	; 53
    42d2:	d1 4f       	sbci	r29, 0xF1	; 241
    42d4:	88 81       	ld	r24, Y
  }
  while (tempKlaster2 != tempKlaster);
    42d6:	98 17       	cp	r25, r24
    42d8:	11 f0       	breq	.+4      	; 0x42de <ramDyskUtworzPlik+0x8c>
    42da:	98 2f       	mov	r25, r24
    42dc:	e5 cf       	rjmp	.-54     	; 0x42a8 <ramDyskUtworzPlik+0x56>
  
  klastry[tempKlaster] = znajdzWolnyKlaster();
    42de:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <znajdzWolnyKlaster>
    42e2:	88 83       	st	Y, r24
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    42e4:	88 23       	and	r24, r24
    42e6:	d1 f0       	breq	.+52     	; 0x431c <ramDyskUtworzPlik+0xca>
    plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
    42e8:	90 e0       	ldi	r25, 0x00	; 0
    42ea:	80 58       	subi	r24, 0x80	; 128
    42ec:	9f 4f       	sbci	r25, 0xFF	; 255
    42ee:	d8 2f       	mov	r29, r24
    42f0:	cc 27       	eor	r28, r28
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
  }
  
  if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym pliku
    42f2:	20 97       	sbiw	r28, 0x00	; 0
    42f4:	99 f0       	breq	.+38     	; 0x431c <ramDyskUtworzPlik+0xca>
  {
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    42f6:	8c e0       	ldi	r24, 0x0C	; 12
    42f8:	fe 01       	movw	r30, r28
    42fa:	11 92       	st	Z+, r1
    42fc:	8a 95       	dec	r24
    42fe:	e9 f7       	brne	.-6      	; 0x42fa <ramDyskUtworzPlik+0xa8>
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    4300:	ce 01       	movw	r24, r28
    4302:	04 96       	adiw	r24, 0x04	; 4
    4304:	60 2f       	mov	r22, r16
    4306:	7f 2d       	mov	r23, r15
    4308:	41 2f       	mov	r20, r17
    430a:	50 e0       	ldi	r21, 0x00	; 0
    430c:	0e 94 75 59 	call	0xb2ea	; 0xb2ea <strncpy>
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    4310:	1c 86       	std	Y+12, r1	; 0x0c
    4312:	1d 86       	std	Y+13, r1	; 0x0d
    4314:	1e 86       	std	Y+14, r1	; 0x0e
    4316:	1f 86       	std	Y+15, r1	; 0x0f
    return 0;                            
    4318:	80 e0       	ldi	r24, 0x00	; 0
    431a:	01 c0       	rjmp	.+2      	; 0x431e <ramDyskUtworzPlik+0xcc>
    431c:	81 e0       	ldi	r24, 0x01	; 1
  }
  return 1;
}
    431e:	df 91       	pop	r29
    4320:	cf 91       	pop	r28
    4322:	1f 91       	pop	r17
    4324:	0f 91       	pop	r16
    4326:	ff 90       	pop	r15
    4328:	08 95       	ret

0000432a <cmdLineGetLastArgIdx>:

uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
    432a:	dc 01       	movw	r26, r24
    432c:	12 96       	adiw	r26, 0x02	; 2
    432e:	ed 91       	ld	r30, X+
    4330:	fc 91       	ld	r31, X
    4332:	13 97       	sbiw	r26, 0x03	; 3
    4334:	80 e0       	ldi	r24, 0x00	; 0
    4336:	21 e0       	ldi	r18, 0x01	; 1
    4338:	09 c0       	rjmp	.+18     	; 0x434c <cmdLineGetLastArgIdx+0x22>
  while(*str != 0)
  {
    if (*str == ' ')
    433a:	90 32       	cpi	r25, 0x20	; 32
    433c:	11 f0       	breq	.+4      	; 0x4342 <cmdLineGetLastArgIdx+0x18>
    433e:	20 e0       	ldi	r18, 0x00	; 0
    4340:	04 c0       	rjmp	.+8      	; 0x434a <cmdLineGetLastArgIdx+0x20>
    {
      if (lastWhite == 0)
    4342:	22 23       	and	r18, r18
    4344:	09 f4       	brne	.+2      	; 0x4348 <cmdLineGetLastArgIdx+0x1e>
        result++;
    4346:	8f 5f       	subi	r24, 0xFF	; 255
    4348:	21 e0       	ldi	r18, 0x01	; 1
      lastWhite = 1;
    }
    else
      lastWhite = 0;
    str++;
    434a:	31 96       	adiw	r30, 0x01	; 1
uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    434c:	90 81       	ld	r25, Z
    434e:	99 23       	and	r25, r25
    4350:	a1 f7       	brne	.-24     	; 0x433a <cmdLineGetLastArgIdx+0x10>
    else
      lastWhite = 0;
    str++;
  }
  return result;
}
    4352:	08 95       	ret

00004354 <cmdlineGetArgStr>:

char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
{
    4354:	58 2f       	mov	r21, r24
    4356:	fb 01       	movw	r30, r22
  // find the offset of argument number [argnum]
  uint8_t idx=0;
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4358:	22 81       	ldd	r18, Z+2	; 0x02
    435a:	33 81       	ldd	r19, Z+3	; 0x03
    435c:	90 e0       	ldi	r25, 0x00	; 0
    435e:	01 c0       	rjmp	.+2      	; 0x4362 <cmdlineGetArgStr+0xe>
    4360:	9f 5f       	subi	r25, 0xFF	; 255
    4362:	f9 01       	movw	r30, r18
    4364:	e9 0f       	add	r30, r25
    4366:	f1 1d       	adc	r31, r1
    4368:	80 81       	ld	r24, Z
    436a:	80 32       	cpi	r24, 0x20	; 32
    436c:	c9 f3       	breq	.-14     	; 0x4360 <cmdlineGetArgStr+0xc>
    436e:	40 e0       	ldi	r20, 0x00	; 0
    4370:	12 c0       	rjmp	.+36     	; 0x4396 <cmdlineGetArgStr+0x42>
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
  {
    // find the next whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    4372:	9f 5f       	subi	r25, 0xFF	; 255
    4374:	f9 01       	movw	r30, r18
    4376:	e9 0f       	add	r30, r25
    4378:	f1 1d       	adc	r31, r1
    437a:	e0 81       	ld	r30, Z
    437c:	ee 23       	and	r30, r30
    437e:	21 f0       	breq	.+8      	; 0x4388 <cmdlineGetArgStr+0x34>
    4380:	e0 32       	cpi	r30, 0x20	; 32
    4382:	b9 f7       	brne	.-18     	; 0x4372 <cmdlineGetArgStr+0x1e>
    4384:	01 c0       	rjmp	.+2      	; 0x4388 <cmdlineGetArgStr+0x34>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4386:	9f 5f       	subi	r25, 0xFF	; 255
    4388:	f9 01       	movw	r30, r18
    438a:	e9 0f       	add	r30, r25
    438c:	f1 1d       	adc	r31, r1
    438e:	80 81       	ld	r24, Z
    4390:	80 32       	cpi	r24, 0x20	; 32
    4392:	c9 f3       	breq	.-14     	; 0x4386 <cmdlineGetArgStr+0x32>
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    4394:	4f 5f       	subi	r20, 0xFF	; 255
    4396:	45 17       	cp	r20, r21
    4398:	68 f3       	brcs	.-38     	; 0x4374 <cmdlineGetArgStr+0x20>
    439a:	29 0f       	add	r18, r25
    439c:	31 1d       	adc	r19, r1
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  }
  // we are at the requested argument or the end of the buffer
  return &state->CmdlineExcBuffer[idx];
}
    439e:	c9 01       	movw	r24, r18
    43a0:	08 95       	ret

000043a2 <cmdPrintHelp>:
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
}

void cmdPrintHelp(cmdState_t *state)
{
    43a2:	6f 92       	push	r6
    43a4:	7f 92       	push	r7
    43a6:	8f 92       	push	r8
    43a8:	9f 92       	push	r9
    43aa:	bf 92       	push	r11
    43ac:	cf 92       	push	r12
    43ae:	df 92       	push	r13
    43b0:	ef 92       	push	r14
    43b2:	ff 92       	push	r15
    43b4:	0f 93       	push	r16
    43b6:	1f 93       	push	r17
    43b8:	df 93       	push	r29
    43ba:	cf 93       	push	r28
    43bc:	00 d0       	rcall	.+0      	; 0x43be <cmdPrintHelp+0x1c>
    43be:	00 d0       	rcall	.+0      	; 0x43c0 <cmdPrintHelp+0x1e>
    43c0:	00 d0       	rcall	.+0      	; 0x43c2 <cmdPrintHelp+0x20>
    43c2:	cd b7       	in	r28, 0x3d	; 61
    43c4:	de b7       	in	r29, 0x3e	; 62
    43c6:	7c 01       	movw	r14, r24
  command_t  tmp;
  const command_t *tmpPtr = state->cmdList;
    43c8:	fc 01       	movw	r30, r24
    43ca:	c1 a0       	ldd	r12, Z+33	; 0x21
    43cc:	d2 a0       	ldd	r13, Z+34	; 0x22
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    43ce:	8e 01       	movw	r16, r28
    43d0:	0f 5f       	subi	r16, 0xFF	; 255
    43d2:	1f 4f       	sbci	r17, 0xFF	; 255
    43d4:	c8 01       	movw	r24, r16
    43d6:	b6 01       	movw	r22, r12
    43d8:	46 e0       	ldi	r20, 0x06	; 6
    43da:	50 e0       	ldi	r21, 0x00	; 0
    43dc:	0e 94 2e 59 	call	0xb25c	; 0xb25c <memcpy_P>
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    fprintf_P(state->myStdInOut, PSTR("\t"));
    43e0:	98 e6       	ldi	r25, 0x68	; 104
    43e2:	69 2e       	mov	r6, r25
    43e4:	9b e0       	ldi	r25, 0x0B	; 11
    43e6:	79 2e       	mov	r7, r25
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    43e8:	85 e6       	ldi	r24, 0x65	; 101
    43ea:	88 2e       	mov	r8, r24
    43ec:	8b e0       	ldi	r24, 0x0B	; 11
    43ee:	98 2e       	mov	r9, r24

    tmpPtr++;
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    43f0:	b0 2e       	mov	r11, r16
    43f2:	01 2f       	mov	r16, r17
  const command_t *tmpPtr = state->cmdList;
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    43f4:	00 d0       	rcall	.+0      	; 0x43f6 <cmdPrintHelp+0x54>
    43f6:	00 d0       	rcall	.+0      	; 0x43f8 <cmdPrintHelp+0x56>
    43f8:	f7 01       	movw	r30, r14
    43fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    43fc:	93 8d       	ldd	r25, Z+27	; 0x1b
    43fe:	ed b7       	in	r30, 0x3d	; 61
    4400:	fe b7       	in	r31, 0x3e	; 62
    4402:	92 83       	std	Z+2, r25	; 0x02
    4404:	81 83       	std	Z+1, r24	; 0x01
    4406:	89 81       	ldd	r24, Y+1	; 0x01
    4408:	9a 81       	ldd	r25, Y+2	; 0x02
    440a:	94 83       	std	Z+4, r25	; 0x04
    440c:	83 83       	std	Z+3, r24	; 0x03
    440e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4412:	f7 01       	movw	r30, r14
    4414:	82 8d       	ldd	r24, Z+26	; 0x1a
    4416:	93 8d       	ldd	r25, Z+27	; 0x1b
    4418:	ed b7       	in	r30, 0x3d	; 61
    441a:	fe b7       	in	r31, 0x3e	; 62
    441c:	92 83       	std	Z+2, r25	; 0x02
    441e:	81 83       	std	Z+1, r24	; 0x01
    4420:	74 82       	std	Z+4, r7	; 0x04
    4422:	63 82       	std	Z+3, r6	; 0x03
    4424:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    4428:	f7 01       	movw	r30, r14
    442a:	82 8d       	ldd	r24, Z+26	; 0x1a
    442c:	93 8d       	ldd	r25, Z+27	; 0x1b
    442e:	ed b7       	in	r30, 0x3d	; 61
    4430:	fe b7       	in	r31, 0x3e	; 62
    4432:	92 83       	std	Z+2, r25	; 0x02
    4434:	81 83       	std	Z+1, r24	; 0x01
    4436:	8b 81       	ldd	r24, Y+3	; 0x03
    4438:	9c 81       	ldd	r25, Y+4	; 0x04
    443a:	94 83       	std	Z+4, r25	; 0x04
    443c:	83 83       	std	Z+3, r24	; 0x03
    443e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4442:	f7 01       	movw	r30, r14
    4444:	82 8d       	ldd	r24, Z+26	; 0x1a
    4446:	93 8d       	ldd	r25, Z+27	; 0x1b
    4448:	ed b7       	in	r30, 0x3d	; 61
    444a:	fe b7       	in	r31, 0x3e	; 62
    444c:	92 83       	std	Z+2, r25	; 0x02
    444e:	81 83       	std	Z+1, r24	; 0x01
    4450:	94 82       	std	Z+4, r9	; 0x04
    4452:	83 82       	std	Z+3, r8	; 0x03
    4454:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>

    tmpPtr++;
    4458:	86 e0       	ldi	r24, 0x06	; 6
    445a:	90 e0       	ldi	r25, 0x00	; 0
    445c:	c8 0e       	add	r12, r24
    445e:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4460:	0f 90       	pop	r0
    4462:	0f 90       	pop	r0
    4464:	0f 90       	pop	r0
    4466:	0f 90       	pop	r0
    4468:	8b 2d       	mov	r24, r11
    446a:	90 2f       	mov	r25, r16
    446c:	b6 01       	movw	r22, r12
    446e:	46 e0       	ldi	r20, 0x06	; 6
    4470:	50 e0       	ldi	r21, 0x00	; 0
    4472:	0e 94 2e 59 	call	0xb25c	; 0xb25c <memcpy_P>
  }
  while (tmp.commandFun != NULL);
    4476:	8d 81       	ldd	r24, Y+5	; 0x05
    4478:	9e 81       	ldd	r25, Y+6	; 0x06
    447a:	89 2b       	or	r24, r25
    447c:	09 f0       	breq	.+2      	; 0x4480 <cmdPrintHelp+0xde>
    447e:	ba cf       	rjmp	.-140    	; 0x43f4 <cmdPrintHelp+0x52>
}
    4480:	26 96       	adiw	r28, 0x06	; 6
    4482:	0f b6       	in	r0, 0x3f	; 63
    4484:	f8 94       	cli
    4486:	de bf       	out	0x3e, r29	; 62
    4488:	0f be       	out	0x3f, r0	; 63
    448a:	cd bf       	out	0x3d, r28	; 61
    448c:	cf 91       	pop	r28
    448e:	df 91       	pop	r29
    4490:	1f 91       	pop	r17
    4492:	0f 91       	pop	r16
    4494:	ff 90       	pop	r15
    4496:	ef 90       	pop	r14
    4498:	df 90       	pop	r13
    449a:	cf 90       	pop	r12
    449c:	bf 90       	pop	r11
    449e:	9f 90       	pop	r9
    44a0:	8f 90       	pop	r8
    44a2:	7f 90       	pop	r7
    44a4:	6f 90       	pop	r6
    44a6:	08 95       	ret

000044a8 <cmdlineGetArgHex>:
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
}

// return argument [argnum] interpreted as a hex integer
long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
{
    44a8:	df 93       	push	r29
    44aa:	cf 93       	push	r28
    44ac:	00 d0       	rcall	.+0      	; 0x44ae <cmdlineGetArgHex+0x6>
    44ae:	cd b7       	in	r28, 0x3d	; 61
    44b0:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
    44b2:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    44b6:	be 01       	movw	r22, r28
    44b8:	6f 5f       	subi	r22, 0xFF	; 255
    44ba:	7f 4f       	sbci	r23, 0xFF	; 255
    44bc:	40 e1       	ldi	r20, 0x10	; 16
    44be:	50 e0       	ldi	r21, 0x00	; 0
    44c0:	0e 94 f7 57 	call	0xafee	; 0xafee <strtol>
}
    44c4:	0f 90       	pop	r0
    44c6:	0f 90       	pop	r0
    44c8:	cf 91       	pop	r28
    44ca:	df 91       	pop	r29
    44cc:	08 95       	ret

000044ce <cmdlineGetArgInt>:
  return &state->CmdlineExcBuffer[idx];
}

// return argument [argnum] interpreted as a decimal integer
long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
{
    44ce:	df 93       	push	r29
    44d0:	cf 93       	push	r28
    44d2:	00 d0       	rcall	.+0      	; 0x44d4 <cmdlineGetArgInt+0x6>
    44d4:	cd b7       	in	r28, 0x3d	; 61
    44d6:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
    44d8:	0e 94 aa 21 	call	0x4354	; 0x4354 <cmdlineGetArgStr>
    44dc:	be 01       	movw	r22, r28
    44de:	6f 5f       	subi	r22, 0xFF	; 255
    44e0:	7f 4f       	sbci	r23, 0xFF	; 255
    44e2:	4a e0       	ldi	r20, 0x0A	; 10
    44e4:	50 e0       	ldi	r21, 0x00	; 0
    44e6:	0e 94 f7 57 	call	0xafee	; 0xafee <strtol>
}
    44ea:	0f 90       	pop	r0
    44ec:	0f 90       	pop	r0
    44ee:	cf 91       	pop	r28
    44f0:	df 91       	pop	r29
    44f2:	08 95       	ret

000044f4 <cmdlinePrintPrompt>:
    cmdlinePrintPrompt(state);                  // output new prompt
  }
}

void cmdlinePrintPrompt(cmdState_t *state)
{
    44f4:	0f 93       	push	r16
    44f6:	1f 93       	push	r17
    44f8:	cf 93       	push	r28
    44fa:	df 93       	push	r29
    44fc:	8c 01       	movw	r16, r24
  const char* ptr;
  // print a new command prompt
  switch (state->cliMode)
    44fe:	fc 01       	movw	r30, r24
    4500:	80 a1       	ldd	r24, Z+32	; 0x20
    4502:	81 30       	cpi	r24, 0x01	; 1
    4504:	19 f0       	breq	.+6      	; 0x450c <cmdlinePrintPrompt+0x18>
    4506:	82 30       	cpi	r24, 0x02	; 2
    4508:	21 f4       	brne	.+8      	; 0x4512 <cmdlinePrintPrompt+0x1e>
    450a:	06 c0       	rjmp	.+12     	; 0x4518 <cmdlinePrintPrompt+0x24>
    450c:	c8 e4       	ldi	r28, 0x48	; 72
    450e:	db e0       	ldi	r29, 0x0B	; 11
    4510:	0f c0       	rjmp	.+30     	; 0x4530 <cmdlinePrintPrompt+0x3c>
    4512:	c1 e4       	ldi	r28, 0x41	; 65
    4514:	db e0       	ldi	r29, 0x0B	; 11
    4516:	0c c0       	rjmp	.+24     	; 0x4530 <cmdlinePrintPrompt+0x3c>
    4518:	cf e4       	ldi	r28, 0x4F	; 79
    451a:	db e0       	ldi	r29, 0x0B	; 11
    451c:	09 c0       	rjmp	.+18     	; 0x4530 <cmdlinePrintPrompt+0x3c>
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    451e:	21 96       	adiw	r28, 0x01	; 1
    4520:	f9 01       	movw	r30, r18
    4522:	84 91       	lpm	r24, Z+
    4524:	f8 01       	movw	r30, r16
    4526:	62 8d       	ldd	r22, Z+26	; 0x1a
    4528:	73 8d       	ldd	r23, Z+27	; 0x1b
    452a:	90 e0       	ldi	r25, 0x00	; 0
    452c:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    4530:	9e 01       	movw	r18, r28
      break;
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    4532:	fe 01       	movw	r30, r28
    4534:	84 91       	lpm	r24, Z+
    4536:	88 23       	and	r24, r24
    4538:	91 f7       	brne	.-28     	; 0x451e <cmdlinePrintPrompt+0x2a>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
}
    453a:	df 91       	pop	r29
    453c:	cf 91       	pop	r28
    453e:	1f 91       	pop	r17
    4540:	0f 91       	pop	r16
    4542:	08 95       	ret

00004544 <cmdlineMainLoop>:
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
}

void cmdlineMainLoop(cmdState_t *state)
{
    4544:	cf 93       	push	r28
    4546:	df 93       	push	r29
    4548:	ec 01       	movw	r28, r24
  cliExRes_t result;
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
    454a:	8f 89       	ldd	r24, Y+23	; 0x17
    454c:	98 8d       	ldd	r25, Y+24	; 0x18
    454e:	89 2b       	or	r24, r25
    4550:	09 f4       	brne	.+2      	; 0x4554 <cmdlineMainLoop+0x10>
    4552:	86 c0       	rjmp	.+268    	; 0x4660 <cmdlineMainLoop+0x11c>
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    4554:	ce 01       	movw	r24, r28
    4556:	0e 94 95 21 	call	0x432a	; 0x432a <cmdLineGetLastArgIdx>
    455a:	89 8f       	std	Y+25, r24	; 0x19
    result = state->CmdlineExecFunction(state); // run it
    455c:	ef 89       	ldd	r30, Y+23	; 0x17
    455e:	f8 8d       	ldd	r31, Y+24	; 0x18
    4560:	ce 01       	movw	r24, r28
    4562:	09 95       	icall
    
    switch(result)
    4564:	82 30       	cpi	r24, 0x02	; 2
    4566:	91 05       	cpc	r25, r1
    4568:	d1 f0       	breq	.+52     	; 0x459e <cmdlineMainLoop+0x5a>
    456a:	83 30       	cpi	r24, 0x03	; 3
    456c:	91 05       	cpc	r25, r1
    456e:	20 f4       	brcc	.+8      	; 0x4578 <cmdlineMainLoop+0x34>
    4570:	01 97       	sbiw	r24, 0x01	; 1
    4572:	09 f0       	breq	.+2      	; 0x4576 <cmdlineMainLoop+0x32>
    4574:	6c c0       	rjmp	.+216    	; 0x464e <cmdlineMainLoop+0x10a>
    4576:	08 c0       	rjmp	.+16     	; 0x4588 <cmdlineMainLoop+0x44>
    4578:	84 30       	cpi	r24, 0x04	; 4
    457a:	91 05       	cpc	r25, r1
    457c:	09 f4       	brne	.+2      	; 0x4580 <cmdlineMainLoop+0x3c>
    457e:	4a c0       	rjmp	.+148    	; 0x4614 <cmdlineMainLoop+0xd0>
    4580:	05 97       	sbiw	r24, 0x05	; 5
    4582:	09 f0       	breq	.+2      	; 0x4586 <cmdlineMainLoop+0x42>
    4584:	64 c0       	rjmp	.+200    	; 0x464e <cmdlineMainLoop+0x10a>
    4586:	51 c0       	rjmp	.+162    	; 0x462a <cmdlineMainLoop+0xe6>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
    4588:	00 d0       	rcall	.+0      	; 0x458a <cmdlineMainLoop+0x46>
    458a:	00 d0       	rcall	.+0      	; 0x458c <cmdlineMainLoop+0x48>
    458c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    458e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4590:	ed b7       	in	r30, 0x3d	; 61
    4592:	fe b7       	in	r31, 0x3e	; 62
    4594:	92 83       	std	Z+2, r25	; 0x02
    4596:	81 83       	std	Z+1, r24	; 0x01
    4598:	8e ea       	ldi	r24, 0xAE	; 174
    459a:	9b e0       	ldi	r25, 0x0B	; 11
    459c:	50 c0       	rjmp	.+160    	; 0x463e <cmdlineMainLoop+0xfa>
        break;
      case SYNTAX_ERROR:
        fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
    459e:	00 d0       	rcall	.+0      	; 0x45a0 <cmdlineMainLoop+0x5c>
    45a0:	00 d0       	rcall	.+0      	; 0x45a2 <cmdlineMainLoop+0x5e>
    45a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    45a4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    45a6:	ed b7       	in	r30, 0x3d	; 61
    45a8:	fe b7       	in	r31, 0x3e	; 62
    45aa:	92 83       	std	Z+2, r25	; 0x02
    45ac:	81 83       	std	Z+1, r24	; 0x01
    45ae:	8a e9       	ldi	r24, 0x9A	; 154
    45b0:	9b e0       	ldi	r25, 0x0B	; 11
    45b2:	94 83       	std	Z+4, r25	; 0x04
    45b4:	83 83       	std	Z+3, r24	; 0x03
    45b6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_str);
    45ba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    45bc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    45be:	ed b7       	in	r30, 0x3d	; 61
    45c0:	fe b7       	in	r31, 0x3e	; 62
    45c2:	92 83       	std	Z+2, r25	; 0x02
    45c4:	81 83       	std	Z+1, r24	; 0x01
    45c6:	8b 89       	ldd	r24, Y+19	; 0x13
    45c8:	9c 89       	ldd	r25, Y+20	; 0x14
    45ca:	94 83       	std	Z+4, r25	; 0x04
    45cc:	83 83       	std	Z+3, r24	; 0x03
    45ce:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR(" "));
    45d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    45d4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    45d6:	ed b7       	in	r30, 0x3d	; 61
    45d8:	fe b7       	in	r31, 0x3e	; 62
    45da:	92 83       	std	Z+2, r25	; 0x02
    45dc:	81 83       	std	Z+1, r24	; 0x01
    45de:	88 e9       	ldi	r24, 0x98	; 152
    45e0:	9b e0       	ldi	r25, 0x0B	; 11
    45e2:	94 83       	std	Z+4, r25	; 0x04
    45e4:	83 83       	std	Z+3, r24	; 0x03
    45e6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_help_str);
    45ea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    45ec:	9b 8d       	ldd	r25, Y+27	; 0x1b
    45ee:	ed b7       	in	r30, 0x3d	; 61
    45f0:	fe b7       	in	r31, 0x3e	; 62
    45f2:	92 83       	std	Z+2, r25	; 0x02
    45f4:	81 83       	std	Z+1, r24	; 0x01
    45f6:	8d 89       	ldd	r24, Y+21	; 0x15
    45f8:	9e 89       	ldd	r25, Y+22	; 0x16
    45fa:	94 83       	std	Z+4, r25	; 0x04
    45fc:	83 83       	std	Z+3, r24	; 0x03
    45fe:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4602:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4604:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4606:	ed b7       	in	r30, 0x3d	; 61
    4608:	fe b7       	in	r31, 0x3e	; 62
    460a:	92 83       	std	Z+2, r25	; 0x02
    460c:	81 83       	std	Z+1, r24	; 0x01
    460e:	85 e9       	ldi	r24, 0x95	; 149
    4610:	9b e0       	ldi	r25, 0x0B	; 11
    4612:	15 c0       	rjmp	.+42     	; 0x463e <cmdlineMainLoop+0xfa>
        break;
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
    4614:	00 d0       	rcall	.+0      	; 0x4616 <cmdlineMainLoop+0xd2>
    4616:	00 d0       	rcall	.+0      	; 0x4618 <cmdlineMainLoop+0xd4>
    4618:	8a 8d       	ldd	r24, Y+26	; 0x1a
    461a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    461c:	ed b7       	in	r30, 0x3d	; 61
    461e:	fe b7       	in	r31, 0x3e	; 62
    4620:	92 83       	std	Z+2, r25	; 0x02
    4622:	81 83       	std	Z+1, r24	; 0x01
    4624:	82 e8       	ldi	r24, 0x82	; 130
    4626:	9b e0       	ldi	r25, 0x0B	; 11
    4628:	0a c0       	rjmp	.+20     	; 0x463e <cmdlineMainLoop+0xfa>
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    462a:	00 d0       	rcall	.+0      	; 0x462c <cmdlineMainLoop+0xe8>
    462c:	00 d0       	rcall	.+0      	; 0x462e <cmdlineMainLoop+0xea>
    462e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4630:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4632:	ed b7       	in	r30, 0x3d	; 61
    4634:	fe b7       	in	r31, 0x3e	; 62
    4636:	92 83       	std	Z+2, r25	; 0x02
    4638:	81 83       	std	Z+1, r24	; 0x01
    463a:	8a e6       	ldi	r24, 0x6A	; 106
    463c:	9b e0       	ldi	r25, 0x0B	; 11
    463e:	94 83       	std	Z+4, r25	; 0x04
    4640:	83 83       	std	Z+3, r24	; 0x03
    4642:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    4646:	0f 90       	pop	r0
    4648:	0f 90       	pop	r0
    464a:	0f 90       	pop	r0
    464c:	0f 90       	pop	r0
        break;
      default:
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    464e:	18 8e       	std	Y+24, r1	; 0x18
    4650:	1f 8a       	std	Y+23, r1	; 0x17
    state->command_str         = NULL;
    4652:	1c 8a       	std	Y+20, r1	; 0x14
    4654:	1b 8a       	std	Y+19, r1	; 0x13
    state->command_help_str    = NULL;
    4656:	1e 8a       	std	Y+22, r1	; 0x16
    4658:	1d 8a       	std	Y+21, r1	; 0x15
    cmdlinePrintPrompt(state);                  // output new prompt
    465a:	ce 01       	movw	r24, r28
    465c:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <cmdlinePrintPrompt>
  }
}
    4660:	df 91       	pop	r29
    4662:	cf 91       	pop	r28
    4664:	08 95       	ret

00004666 <cmdlineRepaint>:
    state->CmdlineInputVT100State = 1;
  }
}

void cmdlineRepaint(cmdState_t *state, char *buf)
{
    4666:	ef 92       	push	r14
    4668:	ff 92       	push	r15
    466a:	1f 93       	push	r17
    466c:	cf 93       	push	r28
    466e:	df 93       	push	r29
    4670:	ec 01       	movw	r28, r24
    4672:	7b 01       	movw	r14, r22
  uint8_t i;

  // carriage return
  fputc(ASCII_CR         , state->myStdInOut);
    4674:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4676:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4678:	8d e0       	ldi	r24, 0x0D	; 13
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
  // print fresh prompt
  cmdlinePrintPrompt(state);
    4680:	ce 01       	movw	r24, r28
    4682:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <cmdlinePrintPrompt>
  // print the new command line buffer
  i = state->CmdlineBufferLength;
    4686:	1d 85       	ldd	r17, Y+13	; 0x0d
    4688:	0b c0       	rjmp	.+22     	; 0x46a0 <cmdlineRepaint+0x3a>
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
    468a:	f7 01       	movw	r30, r14
    468c:	81 91       	ld	r24, Z+
    468e:	7f 01       	movw	r14, r30
    4690:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4692:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4694:	99 27       	eor	r25, r25
    4696:	87 fd       	sbrc	r24, 7
    4698:	90 95       	com	r25
    469a:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    469e:	11 50       	subi	r17, 0x01	; 1
  fputc(ASCII_CR         , state->myStdInOut);
  // print fresh prompt
  cmdlinePrintPrompt(state);
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    46a0:	11 23       	and	r17, r17
    46a2:	99 f7       	brne	.-26     	; 0x468a <cmdlineRepaint+0x24>
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    46a4:	1c 85       	ldd	r17, Y+12	; 0x0c
    46a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    46a8:	18 1b       	sub	r17, r24
    46aa:	07 c0       	rjmp	.+14     	; 0x46ba <cmdlineRepaint+0x54>
  while (i--)
    fputc(' ', state->myStdInOut);
    46ac:	6a 8d       	ldd	r22, Y+26	; 0x1a
    46ae:	7b 8d       	ldd	r23, Y+27	; 0x1b
    46b0:	80 e2       	ldi	r24, 0x20	; 32
    46b2:	90 e0       	ldi	r25, 0x00	; 0
    46b4:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    46b8:	11 50       	subi	r17, 0x01	; 1
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    46ba:	11 23       	and	r17, r17
    46bc:	b9 f7       	brne	.-18     	; 0x46ac <cmdlineRepaint+0x46>
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    46be:	1c 85       	ldd	r17, Y+12	; 0x0c
    46c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    46c2:	18 1b       	sub	r17, r24
    46c4:	07 c0       	rjmp	.+14     	; 0x46d4 <cmdlineRepaint+0x6e>
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
    46c6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    46c8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    46ca:	88 e0       	ldi	r24, 0x08	; 8
    46cc:	90 e0       	ldi	r25, 0x00	; 0
    46ce:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    46d2:	11 50       	subi	r17, 0x01	; 1
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    46d4:	11 23       	and	r17, r17
    46d6:	b9 f7       	brne	.-18     	; 0x46c6 <cmdlineRepaint+0x60>
    fputc(ASCII_BS,  state->myStdInOut);
}
    46d8:	df 91       	pop	r29
    46da:	cf 91       	pop	r28
    46dc:	1f 91       	pop	r17
    46de:	ff 90       	pop	r15
    46e0:	ef 90       	pop	r14
    46e2:	08 95       	ret

000046e4 <cmdlineDoHistory>:
  state->historyDepthIdx = 0;
  state->bufferHistoryState = COPIED;
}

void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
{
    46e4:	cf 93       	push	r28
    46e6:	df 93       	push	r29
    46e8:	eb 01       	movw	r28, r22
  uint8_t historyReadIdx;
  switch(action)
    46ea:	81 30       	cpi	r24, 0x01	; 1
    46ec:	f1 f0       	breq	.+60     	; 0x472a <cmdlineDoHistory+0x46>
    46ee:	81 30       	cpi	r24, 0x01	; 1
    46f0:	20 f0       	brcs	.+8      	; 0x46fa <cmdlineDoHistory+0x16>
    46f2:	82 30       	cpi	r24, 0x02	; 2
    46f4:	09 f0       	breq	.+2      	; 0x46f8 <cmdlineDoHistory+0x14>
    46f6:	5f c0       	rjmp	.+190    	; 0x47b6 <cmdlineDoHistory+0xd2>
    46f8:	3f c0       	rjmp	.+126    	; 0x4778 <cmdlineDoHistory+0x94>
  {
  case CMDLINE_HISTORY_SAVE:
    // copy CmdlineBuffer to history if not null string
    state->CmdlineBufferLength  = 0;
    46fa:	1d 86       	std	Y+13, r1	; 0x0d
    state->CmdlineBufferEditPos = 0;     
    46fc:	1e 86       	std	Y+14, r1	; 0x0e
    state->bufferHistoryState   = NOT_COPIED;
    46fe:	19 8a       	std	Y+17, r1	; 0x11

    if( strlen(state->CmdlineBuffer) )
    4700:	e8 81       	ld	r30, Y
    4702:	f9 81       	ldd	r31, Y+1	; 0x01
    4704:	80 81       	ld	r24, Z
    4706:	88 23       	and	r24, r24
    4708:	09 f4       	brne	.+2      	; 0x470c <cmdlineDoHistory+0x28>
    470a:	55 c0       	rjmp	.+170    	; 0x47b6 <cmdlineDoHistory+0xd2>
    {
      state->historyWrIdx++;
      state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
    470c:	ef 85       	ldd	r30, Y+15	; 0x0f
    470e:	ef 5f       	subi	r30, 0xFF	; 255
    4710:	e3 70       	andi	r30, 0x03	; 3
    4712:	ef 87       	std	Y+15, r30	; 0x0f
      
      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    4714:	f0 e0       	ldi	r31, 0x00	; 0
    4716:	32 96       	adiw	r30, 0x02	; 2
    4718:	ee 0f       	add	r30, r30
    471a:	ff 1f       	adc	r31, r31
    471c:	e6 0f       	add	r30, r22
    471e:	f7 1f       	adc	r31, r23
    4720:	80 81       	ld	r24, Z
    4722:	91 81       	ldd	r25, Z+1	; 0x01
    4724:	99 83       	std	Y+1, r25	; 0x01
    4726:	88 83       	st	Y, r24
    4728:	46 c0       	rjmp	.+140    	; 0x47b6 <cmdlineDoHistory+0xd2>
    }
    break;
  case CMDLINE_HISTORY_PREV:
    if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
    472a:	98 89       	ldd	r25, Y+16	; 0x10
    472c:	93 30       	cpi	r25, 0x03	; 3
    472e:	09 f4       	brne	.+2      	; 0x4732 <cmdlineDoHistory+0x4e>
    4730:	42 c0       	rjmp	.+132    	; 0x47b6 <cmdlineDoHistory+0xd2>
      break;                                               //We are on the end of the history list
    
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
    
    if (state->CmdlineHistory[historyReadIdx][0] == 0)
    4732:	8f 85       	ldd	r24, Y+15	; 0x0f
    4734:	81 50       	subi	r24, 0x01	; 1
    4736:	89 1b       	sub	r24, r25
    4738:	83 70       	andi	r24, 0x03	; 3
    473a:	e8 2f       	mov	r30, r24
    473c:	f0 e0       	ldi	r31, 0x00	; 0
    473e:	32 96       	adiw	r30, 0x02	; 2
    4740:	ee 0f       	add	r30, r30
    4742:	ff 1f       	adc	r31, r31
    4744:	e6 0f       	add	r30, r22
    4746:	f7 1f       	adc	r31, r23
    4748:	20 81       	ld	r18, Z
    474a:	31 81       	ldd	r19, Z+1	; 0x01
    474c:	d9 01       	movw	r26, r18
    474e:	8c 91       	ld	r24, X
    4750:	88 23       	and	r24, r24
    4752:	89 f1       	breq	.+98     	; 0x47b6 <cmdlineDoHistory+0xd2>
      break;
    
    state->historyDepthIdx++;
    state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
    4754:	9f 5f       	subi	r25, 0xFF	; 255
    4756:	93 70       	andi	r25, 0x03	; 3
    4758:	98 8b       	std	Y+16, r25	; 0x10
    
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    475a:	a0 81       	ld	r26, Z
    475c:	b1 81       	ldd	r27, Z+1	; 0x01
    475e:	fd 01       	movw	r30, r26
    4760:	01 90       	ld	r0, Z+
    4762:	00 20       	and	r0, r0
    4764:	e9 f7       	brne	.-6      	; 0x4760 <cmdlineDoHistory+0x7c>
    4766:	31 97       	sbiw	r30, 0x01	; 1
    4768:	ea 1b       	sub	r30, r26
    476a:	fb 0b       	sbc	r31, r27
    476c:	ed 87       	std	Y+13, r30	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    476e:	ee 87       	std	Y+14, r30	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    4770:	19 8a       	std	Y+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    4772:	cb 01       	movw	r24, r22
    4774:	b9 01       	movw	r22, r18
    4776:	1d c0       	rjmp	.+58     	; 0x47b2 <cmdlineDoHistory+0xce>
    
    break;
  case CMDLINE_HISTORY_NEXT:      
    if (state->historyDepthIdx == 0)
    4778:	88 89       	ldd	r24, Y+16	; 0x10
    477a:	88 23       	and	r24, r24
    477c:	e1 f0       	breq	.+56     	; 0x47b6 <cmdlineDoHistory+0xd2>
      break;                                               //We are on the begining of the history list

    state->historyDepthIdx --;
    477e:	81 50       	subi	r24, 0x01	; 1
    4780:	88 8b       	std	Y+16, r24	; 0x10
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
   
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    4782:	ef 85       	ldd	r30, Y+15	; 0x0f
    4784:	e8 1b       	sub	r30, r24
    4786:	e3 70       	andi	r30, 0x03	; 3
    4788:	f0 e0       	ldi	r31, 0x00	; 0
    478a:	32 96       	adiw	r30, 0x02	; 2
    478c:	ee 0f       	add	r30, r30
    478e:	ff 1f       	adc	r31, r31
    4790:	e6 0f       	add	r30, r22
    4792:	f7 1f       	adc	r31, r23
    4794:	80 81       	ld	r24, Z
    4796:	91 81       	ldd	r25, Z+1	; 0x01
    4798:	dc 01       	movw	r26, r24
    479a:	0d 90       	ld	r0, X+
    479c:	00 20       	and	r0, r0
    479e:	e9 f7       	brne	.-6      	; 0x479a <cmdlineDoHistory+0xb6>
    47a0:	11 97       	sbiw	r26, 0x01	; 1
    47a2:	a8 1b       	sub	r26, r24
    47a4:	b9 0b       	sbc	r27, r25
    47a6:	ad 87       	std	Y+13, r26	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    47a8:	ae 87       	std	Y+14, r26	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    47aa:	19 8a       	std	Y+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    47ac:	60 81       	ld	r22, Z
    47ae:	71 81       	ldd	r23, Z+1	; 0x01
    47b0:	ce 01       	movw	r24, r28
    47b2:	0e 94 33 23 	call	0x4666	; 0x4666 <cmdlineRepaint>
    break;
  }
}
    47b6:	df 91       	pop	r29
    47b8:	cf 91       	pop	r28
    47ba:	08 95       	ret

000047bc <cmdStateConfigure>:
static void cmdHistoryCopy            (cmdState_t *state);
static void cmdHistoryMove            (cmdState_t *state);


void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, const command_t *commands, enum cliModeState mode)
{
    47bc:	8f 92       	push	r8
    47be:	9f 92       	push	r9
    47c0:	bf 92       	push	r11
    47c2:	cf 92       	push	r12
    47c4:	df 92       	push	r13
    47c6:	ef 92       	push	r14
    47c8:	ff 92       	push	r15
    47ca:	0f 93       	push	r16
    47cc:	1f 93       	push	r17
    47ce:	cf 93       	push	r28
    47d0:	df 93       	push	r29
    47d2:	ec 01       	movw	r28, r24
    47d4:	f6 2e       	mov	r15, r22
    47d6:	b7 2e       	mov	r11, r23
    47d8:	6a 01       	movw	r12, r20
    47da:	49 01       	movw	r8, r18
  memset(state, 0, sizeof(cmdState_t));
    47dc:	83 e2       	ldi	r24, 0x23	; 35
    47de:	fe 01       	movw	r30, r28
    47e0:	11 92       	st	Z+, r1
    47e2:	8a 95       	dec	r24
    47e4:	e9 f7       	brne	.-6      	; 0x47e0 <cmdStateConfigure+0x24>
  memset(buffPtr, 0, bufferTotalSize);
    47e6:	86 2f       	mov	r24, r22
    47e8:	97 2f       	mov	r25, r23
    47ea:	60 e0       	ldi	r22, 0x00	; 0
    47ec:	70 e0       	ldi	r23, 0x00	; 0
    47ee:	0e 94 4e 59 	call	0xb29c	; 0xb29c <memset>
    
  state->CmdlineBuffer = buffPtr;
    47f2:	f8 82       	st	Y, r15
    47f4:	b9 82       	std	Y+1, r11	; 0x01
  state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
    47f6:	d6 94       	lsr	r13
    47f8:	c7 94       	ror	r12
    47fa:	d6 94       	lsr	r13
    47fc:	c7 94       	ror	r12
    47fe:	cc 86       	std	Y+12, r12	; 0x0c

  state->cliMode = mode;
    4800:	e8 a2       	std	Y+32, r14	; 0x20
  state->cmdList = commands;
    4802:	1a a3       	std	Y+34, r17	; 0x22
    4804:	09 a3       	std	Y+33, r16	; 0x21
    4806:	fe 01       	movw	r30, r28
    4808:	2f 2d       	mov	r18, r15
    480a:	3b 2d       	mov	r19, r11
    480c:	c9 01       	movw	r24, r18
    480e:	9c 01       	movw	r18, r24
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
    4810:	ae 01       	movw	r20, r28
    4812:	48 5f       	subi	r20, 0xF8	; 248
    4814:	5f 4f       	sbci	r21, 0xFF	; 255
  {
    state->CmdlineHistory[i] = tmpPtr;
    4816:	35 83       	std	Z+5, r19	; 0x05
    4818:	24 83       	std	Z+4, r18	; 0x04
    tmpPtr += state->bufferMaxSize;
    481a:	8c 85       	ldd	r24, Y+12	; 0x0c
    481c:	28 0f       	add	r18, r24
    481e:	31 1d       	adc	r19, r1
    4820:	32 96       	adiw	r30, 0x02	; 2
  state->cliMode = mode;
  state->cmdList = commands;
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
    4822:	e4 17       	cp	r30, r20
    4824:	f5 07       	cpc	r31, r21
    4826:	b9 f7       	brne	.-18     	; 0x4816 <cmdStateConfigure+0x5a>
  {
    state->CmdlineHistory[i] = tmpPtr;
    tmpPtr += state->bufferMaxSize;
  }
  state->myStdInOut = stream;
    4828:	9b 8e       	std	Y+27, r9	; 0x1b
    482a:	8a 8e       	std	Y+26, r8	; 0x1a
}
    482c:	df 91       	pop	r29
    482e:	cf 91       	pop	r28
    4830:	1f 91       	pop	r17
    4832:	0f 91       	pop	r16
    4834:	ff 90       	pop	r15
    4836:	ef 90       	pop	r14
    4838:	df 90       	pop	r13
    483a:	cf 90       	pop	r12
    483c:	bf 90       	pop	r11
    483e:	9f 90       	pop	r9
    4840:	8f 90       	pop	r8
    4842:	08 95       	ret

00004844 <cmdHistoryCopy>:
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
}

void cmdHistoryCopy(cmdState_t *state)
{
    4844:	0f 93       	push	r16
    4846:	1f 93       	push	r17
    4848:	cf 93       	push	r28
    484a:	df 93       	push	r29
    484c:	ec 01       	movw	r28, r24
  if (state->historyDepthIdx != 0)
    484e:	88 89       	ldd	r24, Y+16	; 0x10
    4850:	88 23       	and	r24, r24
    4852:	c9 f0       	breq	.+50     	; 0x4886 <cmdHistoryCopy+0x42>
  {
    uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    4854:	0f 85       	ldd	r16, Y+15	; 0x0f
    4856:	08 1b       	sub	r16, r24
    4858:	03 70       	andi	r16, 0x03	; 3
    memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
    485a:	4c 85       	ldd	r20, Y+12	; 0x0c
    485c:	88 81       	ld	r24, Y
    485e:	99 81       	ldd	r25, Y+1	; 0x01
    4860:	60 e0       	ldi	r22, 0x00	; 0
    4862:	70 e0       	ldi	r23, 0x00	; 0
    4864:	50 e0       	ldi	r21, 0x00	; 0
    4866:	0e 94 4e 59 	call	0xb29c	; 0xb29c <memset>
    strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
    486a:	10 e0       	ldi	r17, 0x00	; 0
    486c:	0e 5f       	subi	r16, 0xFE	; 254
    486e:	1f 4f       	sbci	r17, 0xFF	; 255
    4870:	00 0f       	add	r16, r16
    4872:	11 1f       	adc	r17, r17
    4874:	0c 0f       	add	r16, r28
    4876:	1d 1f       	adc	r17, r29
    4878:	f8 01       	movw	r30, r16
    487a:	60 81       	ld	r22, Z
    487c:	71 81       	ldd	r23, Z+1	; 0x01
    487e:	88 81       	ld	r24, Y
    4880:	99 81       	ldd	r25, Y+1	; 0x01
    4882:	0e 94 60 59 	call	0xb2c0	; 0xb2c0 <strcpy>
  }
  
  state->historyDepthIdx = 0;
    4886:	18 8a       	std	Y+16, r1	; 0x10
  state->bufferHistoryState = COPIED;
    4888:	81 e0       	ldi	r24, 0x01	; 1
    488a:	89 8b       	std	Y+17, r24	; 0x11
}
    488c:	df 91       	pop	r29
    488e:	cf 91       	pop	r28
    4890:	1f 91       	pop	r17
    4892:	0f 91       	pop	r16
    4894:	08 95       	ret

00004896 <cmdlineInputFunc>:
  // initialize executing function
  state->CmdlineExecFunction = 0;
}

void cmdlineInputFunc(char c, cmdState_t *state)
{
    4896:	9f 92       	push	r9
    4898:	af 92       	push	r10
    489a:	bf 92       	push	r11
    489c:	cf 92       	push	r12
    489e:	df 92       	push	r13
    48a0:	ef 92       	push	r14
    48a2:	ff 92       	push	r15
    48a4:	0f 93       	push	r16
    48a6:	1f 93       	push	r17
    48a8:	df 93       	push	r29
    48aa:	cf 93       	push	r28
    48ac:	00 d0       	rcall	.+0      	; 0x48ae <cmdlineInputFunc+0x18>
    48ae:	00 d0       	rcall	.+0      	; 0x48b0 <cmdlineInputFunc+0x1a>
    48b0:	00 d0       	rcall	.+0      	; 0x48b2 <cmdlineInputFunc+0x1c>
    48b2:	cd b7       	in	r28, 0x3d	; 61
    48b4:	de b7       	in	r29, 0x3e	; 62
    48b6:	18 2f       	mov	r17, r24
    48b8:	7b 01       	movw	r14, r22
  uint8_t i;
  // process the received character

  // VT100 handling
  // are we processing a VT100 command?
  if(state->CmdlineInputVT100State == 2)
    48ba:	db 01       	movw	r26, r22
    48bc:	52 96       	adiw	r26, 0x12	; 18
    48be:	8c 91       	ld	r24, X
    48c0:	82 30       	cpi	r24, 0x02	; 2
    48c2:	09 f0       	breq	.+2      	; 0x48c6 <cmdlineInputFunc+0x30>
    48c4:	5d c0       	rjmp	.+186    	; 0x4980 <cmdlineInputFunc+0xea>
  {
    // we have already received ESC and [
    // now process the vt100 codeCmdlineExcBuffer
    switch(c)
    48c6:	12 34       	cpi	r17, 0x42	; 66
    48c8:	71 f0       	breq	.+28     	; 0x48e6 <cmdlineInputFunc+0x50>
    48ca:	13 34       	cpi	r17, 0x43	; 67
    48cc:	24 f4       	brge	.+8      	; 0x48d6 <cmdlineInputFunc+0x40>
    48ce:	11 34       	cpi	r17, 0x41	; 65
    48d0:	09 f0       	breq	.+2      	; 0x48d4 <cmdlineInputFunc+0x3e>
    48d2:	53 c0       	rjmp	.+166    	; 0x497a <cmdlineInputFunc+0xe4>
    48d4:	06 c0       	rjmp	.+12     	; 0x48e2 <cmdlineInputFunc+0x4c>
    48d6:	13 34       	cpi	r17, 0x43	; 67
    48d8:	59 f0       	breq	.+22     	; 0x48f0 <cmdlineInputFunc+0x5a>
    48da:	14 34       	cpi	r17, 0x44	; 68
    48dc:	09 f0       	breq	.+2      	; 0x48e0 <cmdlineInputFunc+0x4a>
    48de:	4d c0       	rjmp	.+154    	; 0x497a <cmdlineInputFunc+0xe4>
    48e0:	31 c0       	rjmp	.+98     	; 0x4944 <cmdlineInputFunc+0xae>
    {
    case VT100_ARROWUP:
      cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
    48e2:	81 e0       	ldi	r24, 0x01	; 1
    48e4:	01 c0       	rjmp	.+2      	; 0x48e8 <cmdlineInputFunc+0x52>
      break;
    case VT100_ARROWDOWN:
      cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
    48e6:	82 e0       	ldi	r24, 0x02	; 2
    48e8:	b7 01       	movw	r22, r14
    48ea:	0e 94 72 23 	call	0x46e4	; 0x46e4 <cmdlineDoHistory>
    48ee:	45 c0       	rjmp	.+138    	; 0x497a <cmdlineInputFunc+0xe4>
      break;
    case VT100_ARROWRIGHT:
      if (state->bufferHistoryState == NOT_COPIED)
    48f0:	fb 01       	movw	r30, r22
    48f2:	81 89       	ldd	r24, Z+17	; 0x11
    48f4:	88 23       	and	r24, r24
    48f6:	19 f4       	brne	.+6      	; 0x48fe <cmdlineInputFunc+0x68>
        cmdHistoryCopy(state);
    48f8:	cb 01       	movw	r24, r22
    48fa:	0e 94 22 24 	call	0x4844	; 0x4844 <cmdHistoryCopy>
      // if the edit position less than current string length
      if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
    48fe:	d7 01       	movw	r26, r14
    4900:	1e 96       	adiw	r26, 0x0e	; 14
    4902:	9c 91       	ld	r25, X
    4904:	1e 97       	sbiw	r26, 0x0e	; 14
    4906:	1d 96       	adiw	r26, 0x0d	; 13
    4908:	8c 91       	ld	r24, X
    490a:	1d 97       	sbiw	r26, 0x0d	; 13
    490c:	5a 96       	adiw	r26, 0x1a	; 26
    490e:	6d 91       	ld	r22, X+
    4910:	7c 91       	ld	r23, X
    4912:	5b 97       	sbiw	r26, 0x1b	; 27
    4914:	98 17       	cp	r25, r24
    4916:	68 f5       	brcc	.+90     	; 0x4972 <cmdlineInputFunc+0xdc>
      {
        // increment the edit position
        state->CmdlineBufferEditPos++;
    4918:	9f 5f       	subi	r25, 0xFF	; 255
    491a:	1e 96       	adiw	r26, 0x0e	; 14
    491c:	9c 93       	st	X, r25
        // move cursor forward one space (no erase)
        fputc(ASCII_ESC        , state->myStdInOut);
    491e:	8b e1       	ldi	r24, 0x1B	; 27
    4920:	90 e0       	ldi	r25, 0x00	; 0
    4922:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
        fputc('['              , state->myStdInOut);
    4926:	f7 01       	movw	r30, r14
    4928:	62 8d       	ldd	r22, Z+26	; 0x1a
    492a:	73 8d       	ldd	r23, Z+27	; 0x1b
    492c:	8b e5       	ldi	r24, 0x5B	; 91
    492e:	90 e0       	ldi	r25, 0x00	; 0
    4930:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
        fputc(VT100_ARROWRIGHT , state->myStdInOut);
    4934:	d7 01       	movw	r26, r14
    4936:	5a 96       	adiw	r26, 0x1a	; 26
    4938:	6d 91       	ld	r22, X+
    493a:	7c 91       	ld	r23, X
    493c:	5b 97       	sbiw	r26, 0x1b	; 27
    493e:	83 e4       	ldi	r24, 0x43	; 67
    4940:	90 e0       	ldi	r25, 0x00	; 0
    4942:	19 c0       	rjmp	.+50     	; 0x4976 <cmdlineInputFunc+0xe0>
        fputc(ASCII_BEL        , state->myStdInOut);
      }
      break;
    case VT100_ARROWLEFT:
      // if the edit position is non-zero
      if (state->bufferHistoryState == NOT_COPIED)
    4944:	fb 01       	movw	r30, r22
    4946:	81 89       	ldd	r24, Z+17	; 0x11
    4948:	88 23       	and	r24, r24
    494a:	19 f4       	brne	.+6      	; 0x4952 <cmdlineInputFunc+0xbc>
        cmdHistoryCopy(state);
    494c:	cb 01       	movw	r24, r22
    494e:	0e 94 22 24 	call	0x4844	; 0x4844 <cmdHistoryCopy>
      
      if(state->CmdlineBufferEditPos)
    4952:	d7 01       	movw	r26, r14
    4954:	1e 96       	adiw	r26, 0x0e	; 14
    4956:	8c 91       	ld	r24, X
    4958:	1e 97       	sbiw	r26, 0x0e	; 14
    495a:	5a 96       	adiw	r26, 0x1a	; 26
    495c:	6d 91       	ld	r22, X+
    495e:	7c 91       	ld	r23, X
    4960:	5b 97       	sbiw	r26, 0x1b	; 27
    4962:	88 23       	and	r24, r24
    4964:	31 f0       	breq	.+12     	; 0x4972 <cmdlineInputFunc+0xdc>
      {
        // decrement the edit position
        state->CmdlineBufferEditPos--;
    4966:	81 50       	subi	r24, 0x01	; 1
    4968:	1e 96       	adiw	r26, 0x0e	; 14
    496a:	8c 93       	st	X, r24
        // move cursor back one space (no erase)
        fputc(ASCII_BS         , state->myStdInOut);
    496c:	88 e0       	ldi	r24, 0x08	; 8
    496e:	90 e0       	ldi	r25, 0x00	; 0
    4970:	02 c0       	rjmp	.+4      	; 0x4976 <cmdlineInputFunc+0xe0>
      }
      else
      {
        // else, ring the bell
        fputc(ASCII_BEL        , state->myStdInOut);
    4972:	87 e0       	ldi	r24, 0x07	; 7
    4974:	90 e0       	ldi	r25, 0x00	; 0
    4976:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
      break;
    default:
      break;
    }
    // done, reset state
    state->CmdlineInputVT100State = 0;
    497a:	f7 01       	movw	r30, r14
    497c:	12 8a       	std	Z+18, r1	; 0x12
    497e:	1e c2       	rjmp	.+1084   	; 0x4dbc <cmdlineInputFunc+0x526>
    return;
  }
  else if(state->CmdlineInputVT100State == 1)
    4980:	81 30       	cpi	r24, 0x01	; 1
    4982:	39 f4       	brne	.+14     	; 0x4992 <cmdlineInputFunc+0xfc>
  {
    // we last received [ESC]
    if(c == '[')
    4984:	1b 35       	cpi	r17, 0x5B	; 91
    4986:	11 f4       	brne	.+4      	; 0x498c <cmdlineInputFunc+0xf6>
    {
      state->CmdlineInputVT100State = 2;
    4988:	82 e0       	ldi	r24, 0x02	; 2
    498a:	15 c2       	rjmp	.+1066   	; 0x4db6 <cmdlineInputFunc+0x520>
      return;
    }
    else
      state->CmdlineInputVT100State = 0;
    498c:	fb 01       	movw	r30, r22
    498e:	12 8a       	std	Z+18, r1	; 0x12
    4990:	03 c0       	rjmp	.+6      	; 0x4998 <cmdlineInputFunc+0x102>
  }
  else
  {
    // anything else, reset state
    state->CmdlineInputVT100State = 0;
    4992:	db 01       	movw	r26, r22
    4994:	52 96       	adiw	r26, 0x12	; 18
    4996:	1c 92       	st	X, r1
  }

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
    4998:	f7 01       	movw	r30, r14
    499a:	95 85       	ldd	r25, Z+13	; 0x0d
    499c:	84 85       	ldd	r24, Z+12	; 0x0c
    499e:	98 17       	cp	r25, r24
    49a0:	89 f4       	brne	.+34     	; 0x49c4 <cmdlineInputFunc+0x12e>
  {
    state->CmdlineBufferLength--;
    49a2:	91 50       	subi	r25, 0x01	; 1
    49a4:	95 87       	std	Z+13, r25	; 0x0d
    49a6:	91 e0       	ldi	r25, 0x01	; 1
    49a8:	09 c0       	rjmp	.+18     	; 0x49bc <cmdlineInputFunc+0x126>
    for (i=1; i < state->bufferMaxSize; i++)
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    49aa:	d7 01       	movw	r26, r14
    49ac:	ed 91       	ld	r30, X+
    49ae:	fc 91       	ld	r31, X
    49b0:	e9 0f       	add	r30, r25
    49b2:	f1 1d       	adc	r31, r1
    49b4:	80 81       	ld	r24, Z
    49b6:	31 97       	sbiw	r30, 0x01	; 1
    49b8:	80 83       	st	Z, r24
  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    for (i=1; i < state->bufferMaxSize; i++)
    49ba:	9f 5f       	subi	r25, 0xFF	; 255
    49bc:	f7 01       	movw	r30, r14
    49be:	84 85       	ldd	r24, Z+12	; 0x0c
    49c0:	98 17       	cp	r25, r24
    49c2:	98 f3       	brcs	.-26     	; 0x49aa <cmdlineInputFunc+0x114>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    }
  }
  
  if( (c >= 0x20) && (c < 0x7F) )
    49c4:	81 2f       	mov	r24, r17
    49c6:	80 52       	subi	r24, 0x20	; 32
    49c8:	8f 35       	cpi	r24, 0x5F	; 95
    49ca:	08 f0       	brcs	.+2      	; 0x49ce <cmdlineInputFunc+0x138>
    49cc:	5b c0       	rjmp	.+182    	; 0x4a84 <cmdlineInputFunc+0x1ee>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    49ce:	d7 01       	movw	r26, r14
    49d0:	51 96       	adiw	r26, 0x11	; 17
    49d2:	8c 91       	ld	r24, X
    49d4:	88 23       	and	r24, r24
    49d6:	19 f4       	brne	.+6      	; 0x49de <cmdlineInputFunc+0x148>
      cmdHistoryCopy(state);
    49d8:	c7 01       	movw	r24, r14
    49da:	0e 94 22 24 	call	0x4844	; 0x4844 <cmdHistoryCopy>
    // character is printable
    // is this a simple append
    if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    49de:	f7 01       	movw	r30, r14
    49e0:	95 85       	ldd	r25, Z+13	; 0x0d
    49e2:	86 85       	ldd	r24, Z+14	; 0x0e
    49e4:	89 17       	cp	r24, r25
    49e6:	e9 f4       	brne	.+58     	; 0x4a22 <cmdlineInputFunc+0x18c>
    {
      // echo character to the output
      fputc(c                , state->myStdInOut);
    49e8:	62 8d       	ldd	r22, Z+26	; 0x1a
    49ea:	73 8d       	ldd	r23, Z+27	; 0x1b
    49ec:	81 2f       	mov	r24, r17
    49ee:	99 27       	eor	r25, r25
    49f0:	87 fd       	sbrc	r24, 7
    49f2:	90 95       	com	r25
    49f4:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
      // add it to the command line buffer
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    49f8:	d7 01       	movw	r26, r14
    49fa:	1e 96       	adiw	r26, 0x0e	; 14
    49fc:	8c 91       	ld	r24, X
    49fe:	1e 97       	sbiw	r26, 0x0e	; 14
    4a00:	ed 91       	ld	r30, X+
    4a02:	fc 91       	ld	r31, X
    4a04:	11 97       	sbiw	r26, 0x01	; 1
    4a06:	e8 0f       	add	r30, r24
    4a08:	f1 1d       	adc	r31, r1
    4a0a:	10 83       	st	Z, r17
    4a0c:	8f 5f       	subi	r24, 0xFF	; 255
    4a0e:	1e 96       	adiw	r26, 0x0e	; 14
    4a10:	8c 93       	st	X, r24
    4a12:	1e 97       	sbiw	r26, 0x0e	; 14
      // update buffer length
      state->CmdlineBufferLength++;
    4a14:	1d 96       	adiw	r26, 0x0d	; 13
    4a16:	8c 91       	ld	r24, X
    4a18:	1d 97       	sbiw	r26, 0x0d	; 13
    4a1a:	8f 5f       	subi	r24, 0xFF	; 255
    4a1c:	1d 96       	adiw	r26, 0x0d	; 13
    4a1e:	8c 93       	st	X, r24
    4a20:	cd c1       	rjmp	.+922    	; 0x4dbc <cmdlineInputFunc+0x526>
    else
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
    4a22:	9f 5f       	subi	r25, 0xFF	; 255
    4a24:	f7 01       	movw	r30, r14
    4a26:	95 87       	std	Z+13, r25	; 0x0d
    4a28:	06 c0       	rjmp	.+12     	; 0x4a36 <cmdlineInputFunc+0x1a0>
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
    4a2a:	e9 0f       	add	r30, r25
    4a2c:	f1 1d       	adc	r31, r1
    4a2e:	82 91       	ld	r24, -Z
    4a30:	31 96       	adiw	r30, 0x01	; 1
    4a32:	80 83       	st	Z, r24
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    4a34:	91 50       	subi	r25, 0x01	; 1
    4a36:	d7 01       	movw	r26, r14
    4a38:	1e 96       	adiw	r26, 0x0e	; 14
    4a3a:	8c 91       	ld	r24, X
    4a3c:	1e 97       	sbiw	r26, 0x0e	; 14
    4a3e:	ed 91       	ld	r30, X+
    4a40:	fc 91       	ld	r31, X
    4a42:	11 97       	sbiw	r26, 0x01	; 1
    4a44:	89 17       	cp	r24, r25
    4a46:	88 f3       	brcs	.-30     	; 0x4a2a <cmdlineInputFunc+0x194>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4a48:	e8 0f       	add	r30, r24
    4a4a:	f1 1d       	adc	r31, r1
    4a4c:	10 83       	st	Z, r17
    4a4e:	8f 5f       	subi	r24, 0xFF	; 255
    4a50:	1e 96       	adiw	r26, 0x0e	; 14
    4a52:	8c 93       	st	X, r24
    4a54:	1e 97       	sbiw	r26, 0x0e	; 14
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
    4a56:	6d 91       	ld	r22, X+
    4a58:	7c 91       	ld	r23, X
    4a5a:	c7 01       	movw	r24, r14
    4a5c:	0e 94 33 23 	call	0x4666	; 0x4666 <cmdlineRepaint>
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4a60:	f7 01       	movw	r30, r14
    4a62:	16 85       	ldd	r17, Z+14	; 0x0e
    4a64:	0a c0       	rjmp	.+20     	; 0x4a7a <cmdlineInputFunc+0x1e4>
        fputc(ASCII_BS         , state->myStdInOut);
    4a66:	d7 01       	movw	r26, r14
    4a68:	5a 96       	adiw	r26, 0x1a	; 26
    4a6a:	6d 91       	ld	r22, X+
    4a6c:	7c 91       	ld	r23, X
    4a6e:	5b 97       	sbiw	r26, 0x1b	; 27
    4a70:	88 e0       	ldi	r24, 0x08	; 8
    4a72:	90 e0       	ldi	r25, 0x00	; 0
    4a74:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4a78:	1f 5f       	subi	r17, 0xFF	; 255
    4a7a:	f7 01       	movw	r30, r14
    4a7c:	85 85       	ldd	r24, Z+13	; 0x0d
    4a7e:	18 17       	cp	r17, r24
    4a80:	90 f3       	brcs	.-28     	; 0x4a66 <cmdlineInputFunc+0x1d0>
    4a82:	9c c1       	rjmp	.+824    	; 0x4dbc <cmdlineInputFunc+0x526>
        fputc(ASCII_BS         , state->myStdInOut);
    }
  }
  // handle special characters
  else if(c == ASCII_CR)
    4a84:	1d 30       	cpi	r17, 0x0D	; 13
    4a86:	09 f0       	breq	.+2      	; 0x4a8a <cmdlineInputFunc+0x1f4>
    4a88:	25 c1       	rjmp	.+586    	; 0x4cd4 <cmdlineInputFunc+0x43e>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    4a8a:	d7 01       	movw	r26, r14
    4a8c:	51 96       	adiw	r26, 0x11	; 17
    4a8e:	8c 91       	ld	r24, X
    4a90:	51 97       	sbiw	r26, 0x11	; 17
    4a92:	88 23       	and	r24, r24
    4a94:	09 f0       	breq	.+2      	; 0x4a98 <cmdlineInputFunc+0x202>
    4a96:	49 c0       	rjmp	.+146    	; 0x4b2a <cmdlineInputFunc+0x294>
  state->bufferHistoryState = COPIED;
}

void cmdHistoryMove(cmdState_t *state)
{
  uint8_t i=state->historyDepthIdx;
    4a98:	50 96       	adiw	r26, 0x10	; 16
    4a9a:	2c 91       	ld	r18, X
    4a9c:	50 97       	sbiw	r26, 0x10	; 16

  if (state->historyDepthIdx != 0)
    4a9e:	22 23       	and	r18, r18
    4aa0:	79 f1       	breq	.+94     	; 0x4b00 <cmdlineInputFunc+0x26a>
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    4aa2:	1f 96       	adiw	r26, 0x0f	; 15
    4aa4:	ec 91       	ld	r30, X
    4aa6:	1f 97       	sbiw	r26, 0x0f	; 15
    4aa8:	f0 e0       	ldi	r31, 0x00	; 0
    4aaa:	e2 1b       	sub	r30, r18
    4aac:	f1 09       	sbc	r31, r1
    4aae:	e3 70       	andi	r30, 0x03	; 3
    4ab0:	f0 70       	andi	r31, 0x00	; 0
    4ab2:	32 96       	adiw	r30, 0x02	; 2
    4ab4:	ee 0f       	add	r30, r30
    4ab6:	ff 1f       	adc	r31, r31
    4ab8:	ee 0d       	add	r30, r14
    4aba:	ff 1d       	adc	r31, r15
    4abc:	80 81       	ld	r24, Z
    4abe:	91 81       	ldd	r25, Z+1	; 0x01
    4ac0:	8d 93       	st	X+, r24
    4ac2:	9c 93       	st	X, r25
    4ac4:	1b c0       	rjmp	.+54     	; 0x4afc <cmdlineInputFunc+0x266>
    for ( ; i<CMD_STATE_HISTORY; i++)
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    4ac6:	d7 01       	movw	r26, r14
    4ac8:	1f 96       	adiw	r26, 0x0f	; 15
    4aca:	ec 91       	ld	r30, X
    4acc:	f0 e0       	ldi	r31, 0x00	; 0
    4ace:	e2 1b       	sub	r30, r18
    4ad0:	f1 09       	sbc	r31, r1
    4ad2:	df 01       	movw	r26, r30
    4ad4:	a3 70       	andi	r26, 0x03	; 3
    4ad6:	b0 70       	andi	r27, 0x00	; 0
    4ad8:	12 96       	adiw	r26, 0x02	; 2
    4ada:	aa 0f       	add	r26, r26
    4adc:	bb 1f       	adc	r27, r27
    4ade:	ae 0d       	add	r26, r14
    4ae0:	bf 1d       	adc	r27, r15
    4ae2:	31 97       	sbiw	r30, 0x01	; 1
    4ae4:	e3 70       	andi	r30, 0x03	; 3
    4ae6:	f0 70       	andi	r31, 0x00	; 0
    4ae8:	32 96       	adiw	r30, 0x02	; 2
    4aea:	ee 0f       	add	r30, r30
    4aec:	ff 1f       	adc	r31, r31
    4aee:	ee 0d       	add	r30, r14
    4af0:	ff 1d       	adc	r31, r15
    4af2:	80 81       	ld	r24, Z
    4af4:	91 81       	ldd	r25, Z+1	; 0x01
    4af6:	8d 93       	st	X+, r24
    4af8:	9c 93       	st	X, r25
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    for ( ; i<CMD_STATE_HISTORY; i++)
    4afa:	2f 5f       	subi	r18, 0xFF	; 255
    4afc:	24 30       	cpi	r18, 0x04	; 4
    4afe:	18 f3       	brcs	.-58     	; 0x4ac6 <cmdlineInputFunc+0x230>
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    }
  }
  state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
    4b00:	d7 01       	movw	r26, r14
    4b02:	1f 96       	adiw	r26, 0x0f	; 15
    4b04:	ec 91       	ld	r30, X
    4b06:	1f 97       	sbiw	r26, 0x0f	; 15
    4b08:	f0 e0       	ldi	r31, 0x00	; 0
    4b0a:	32 96       	adiw	r30, 0x02	; 2
    4b0c:	ee 0f       	add	r30, r30
    4b0e:	ff 1f       	adc	r31, r31
    4b10:	ee 0d       	add	r30, r14
    4b12:	ff 1d       	adc	r31, r15
    4b14:	8d 91       	ld	r24, X+
    4b16:	9c 91       	ld	r25, X
    4b18:	11 97       	sbiw	r26, 0x01	; 1
    4b1a:	91 83       	std	Z+1, r25	; 0x01
    4b1c:	80 83       	st	Z, r24

  state->historyDepthIdx = 0;
    4b1e:	50 96       	adiw	r26, 0x10	; 16
    4b20:	1c 92       	st	X, r1
    4b22:	50 97       	sbiw	r26, 0x10	; 16
  state->bufferHistoryState = COPIED;
    4b24:	81 e0       	ldi	r24, 0x01	; 1
    4b26:	51 96       	adiw	r26, 0x11	; 17
    4b28:	8c 93       	st	X, r24
    if (state->bufferHistoryState == NOT_COPIED)
      cmdHistoryMove(state);
    
    // user pressed [ENTER]
    // echo CR and LF to terminal
    fputc(ASCII_CR         , state->myStdInOut);
    4b2a:	f7 01       	movw	r30, r14
    4b2c:	62 8d       	ldd	r22, Z+26	; 0x1a
    4b2e:	73 8d       	ldd	r23, Z+27	; 0x1b
    4b30:	8d e0       	ldi	r24, 0x0D	; 13
    4b32:	90 e0       	ldi	r25, 0x00	; 0
    4b34:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    fputc(ASCII_LF         , state->myStdInOut);
    4b38:	d7 01       	movw	r26, r14
    4b3a:	5a 96       	adiw	r26, 0x1a	; 26
    4b3c:	6d 91       	ld	r22, X+
    4b3e:	7c 91       	ld	r23, X
    4b40:	5b 97       	sbiw	r26, 0x1b	; 27
    4b42:	8a e0       	ldi	r24, 0x0A	; 10
    4b44:	90 e0       	ldi	r25, 0x00	; 0
    4b46:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    // add null termination to command
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    4b4a:	f7 01       	movw	r30, r14
    4b4c:	85 85       	ldd	r24, Z+13	; 0x0d
    4b4e:	01 90       	ld	r0, Z+
    4b50:	f0 81       	ld	r31, Z
    4b52:	e0 2d       	mov	r30, r0
    4b54:	e8 0f       	add	r30, r24
    4b56:	f1 1d       	adc	r31, r1
    4b58:	10 82       	st	Z, r1
    4b5a:	8f 5f       	subi	r24, 0xFF	; 255
    4b5c:	d7 01       	movw	r26, r14
    4b5e:	1d 96       	adiw	r26, 0x0d	; 13
    4b60:	8c 93       	st	X, r24
    4b62:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos++;
    4b64:	1e 96       	adiw	r26, 0x0e	; 14
    4b66:	8c 91       	ld	r24, X
    4b68:	1e 97       	sbiw	r26, 0x0e	; 14
    4b6a:	8f 5f       	subi	r24, 0xFF	; 255
    4b6c:	1e 96       	adiw	r26, 0x0e	; 14
    4b6e:	8c 93       	st	X, r24
    4b70:	1e 97       	sbiw	r26, 0x0e	; 14
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments
    4b72:	8d 91       	ld	r24, X+
    4b74:	9c 91       	ld	r25, X
    4b76:	11 97       	sbiw	r26, 0x01	; 1
    4b78:	13 96       	adiw	r26, 0x03	; 3
    4b7a:	9c 93       	st	X, r25
    4b7c:	8e 93       	st	-X, r24
    4b7e:	12 97       	sbiw	r26, 0x02	; 2
    4b80:	bb 24       	eor	r11, r11
    4b82:	01 c0       	rjmp	.+2      	; 0x4b86 <cmdlineInputFunc+0x2f0>

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length
    4b84:	b3 94       	inc	r11
void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    4b86:	fc 01       	movw	r30, r24
    4b88:	eb 0d       	add	r30, r11
    4b8a:	f1 1d       	adc	r31, r1
    4b8c:	e0 81       	ld	r30, Z
    4b8e:	e0 32       	cpi	r30, 0x20	; 32
    4b90:	11 f0       	breq	.+4      	; 0x4b96 <cmdlineInputFunc+0x300>
    4b92:	ee 23       	and	r30, r30
    4b94:	b9 f7       	brne	.-18     	; 0x4b84 <cmdlineInputFunc+0x2ee>
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length

  if(!i)                                                              // command was null or empty
    4b96:	bb 20       	and	r11, r11
    4b98:	09 f4       	brne	.+2      	; 0x4b9c <cmdlineInputFunc+0x306>
    4b9a:	92 c0       	rjmp	.+292    	; 0x4cc0 <cmdlineInputFunc+0x42a>
  {
    cmdlinePrintPrompt(state);                                        // output a new prompt
    return;
  }

  const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The list depends of the cli mode
    4b9c:	f7 01       	movw	r30, r14
    4b9e:	c1 a0       	ldd	r12, Z+33	; 0x21
    4ba0:	d2 a0       	ldd	r13, Z+34	; 0x22
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.
    4ba2:	8e 01       	movw	r16, r28
    4ba4:	0f 5f       	subi	r16, 0xFF	; 255
    4ba6:	1f 4f       	sbci	r17, 0xFF	; 255
    4ba8:	c8 01       	movw	r24, r16
    4baa:	b6 01       	movw	r22, r12
    4bac:	46 e0       	ldi	r20, 0x06	; 6
    4bae:	50 e0       	ldi	r21, 0x00	; 0
    4bb0:	0e 94 2e 59 	call	0xb25c	; 0xb25c <memcpy_P>
      state->command_help_str    = tmp.commandHelpStr;
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
      return;
    }
    tmpPtr++;                                                         // Next command
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    4bb4:	90 2e       	mov	r9, r16
    4bb6:	a1 2e       	mov	r10, r17
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.

  do                                                                  // search command list for match with entered command
  {
    if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command matched a command in the list
    4bb8:	09 81       	ldd	r16, Y+1	; 0x01
    4bba:	1a 81       	ldd	r17, Y+2	; 0x02
    4bbc:	d7 01       	movw	r26, r14
    4bbe:	12 96       	adiw	r26, 0x02	; 2
    4bc0:	8d 91       	ld	r24, X+
    4bc2:	9c 91       	ld	r25, X
    4bc4:	13 97       	sbiw	r26, 0x03	; 3
    4bc6:	b8 01       	movw	r22, r16
    4bc8:	4b 2d       	mov	r20, r11
    4bca:	50 e0       	ldi	r21, 0x00	; 0
    4bcc:	0e 94 37 59 	call	0xb26e	; 0xb26e <strncmp_P>
    4bd0:	89 2b       	or	r24, r25
    4bd2:	81 f4       	brne	.+32     	; 0x4bf4 <cmdlineInputFunc+0x35e>
    {                                                                 // 
      state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
    4bd4:	8d 81       	ldd	r24, Y+5	; 0x05
    4bd6:	9e 81       	ldd	r25, Y+6	; 0x06
    4bd8:	f7 01       	movw	r30, r14
    4bda:	90 8f       	std	Z+24, r25	; 0x18
    4bdc:	87 8b       	std	Z+23, r24	; 0x17
      state->command_str         = tmp.commandStr;
    4bde:	14 8b       	std	Z+20, r17	; 0x14
    4be0:	03 8b       	std	Z+19, r16	; 0x13
      state->command_help_str    = tmp.commandHelpStr;
    4be2:	8b 81       	ldd	r24, Y+3	; 0x03
    4be4:	9c 81       	ldd	r25, Y+4	; 0x04
    4be6:	96 8b       	std	Z+22, r25	; 0x16
    4be8:	85 8b       	std	Z+21, r24	; 0x15
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
    4bea:	80 e0       	ldi	r24, 0x00	; 0
    4bec:	b7 01       	movw	r22, r14
    4bee:	0e 94 72 23 	call	0x46e4	; 0x46e4 <cmdlineDoHistory>
    4bf2:	69 c0       	rjmp	.+210    	; 0x4cc6 <cmdlineInputFunc+0x430>
      return;
    }
    tmpPtr++;                                                         // Next command
    4bf4:	86 e0       	ldi	r24, 0x06	; 6
    4bf6:	90 e0       	ldi	r25, 0x00	; 0
    4bf8:	c8 0e       	add	r12, r24
    4bfa:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    4bfc:	89 2d       	mov	r24, r9
    4bfe:	9a 2d       	mov	r25, r10
    4c00:	b6 01       	movw	r22, r12
    4c02:	46 e0       	ldi	r20, 0x06	; 6
    4c04:	50 e0       	ldi	r21, 0x00	; 0
    4c06:	0e 94 2e 59 	call	0xb25c	; 0xb25c <memcpy_P>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
    4c0a:	89 81       	ldd	r24, Y+1	; 0x01
    4c0c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c0e:	89 2b       	or	r24, r25
    4c10:	99 f6       	brne	.-90     	; 0x4bb8 <cmdlineInputFunc+0x322>
    4c12:	06 e5       	ldi	r16, 0x56	; 86
    4c14:	1b e0       	ldi	r17, 0x0B	; 11
    4c16:	0c c0       	rjmp	.+24     	; 0x4c30 <cmdlineInputFunc+0x39a>

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4c18:	0f 5f       	subi	r16, 0xFF	; 255
    4c1a:	1f 4f       	sbci	r17, 0xFF	; 255
    4c1c:	f9 01       	movw	r30, r18
    4c1e:	84 91       	lpm	r24, Z+
    4c20:	d7 01       	movw	r26, r14
    4c22:	5a 96       	adiw	r26, 0x1a	; 26
    4c24:	6d 91       	ld	r22, X+
    4c26:	7c 91       	ld	r23, X
    4c28:	5b 97       	sbiw	r26, 0x1b	; 27
    4c2a:	90 e0       	ldi	r25, 0x00	; 0
    4c2c:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    4c30:	98 01       	movw	r18, r16
  char * ptr;

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    4c32:	f8 01       	movw	r30, r16
    4c34:	84 91       	lpm	r24, Z+
    4c36:	88 23       	and	r24, r24
    4c38:	79 f7       	brne	.-34     	; 0x4c18 <cmdlineInputFunc+0x382>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
    4c3a:	d7 01       	movw	r26, r14
    4c3c:	0d 91       	ld	r16, X+
    4c3e:	1c 91       	ld	r17, X
    4c40:	0a c0       	rjmp	.+20     	; 0x4c56 <cmdlineInputFunc+0x3c0>
  while((*ptr) && (*ptr != ' '))
    fputc(*ptr++    , state->myStdInOut);
    4c42:	0f 5f       	subi	r16, 0xFF	; 255
    4c44:	1f 4f       	sbci	r17, 0xFF	; 255
    4c46:	f7 01       	movw	r30, r14
    4c48:	62 8d       	ldd	r22, Z+26	; 0x1a
    4c4a:	73 8d       	ldd	r23, Z+27	; 0x1b
    4c4c:	99 27       	eor	r25, r25
    4c4e:	87 fd       	sbrc	r24, 7
    4c50:	90 95       	com	r25
    4c52:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    4c56:	d8 01       	movw	r26, r16
    4c58:	8c 91       	ld	r24, X
    4c5a:	88 23       	and	r24, r24
    4c5c:	11 f0       	breq	.+4      	; 0x4c62 <cmdlineInputFunc+0x3cc>
    4c5e:	80 32       	cpi	r24, 0x20	; 32
    4c60:	81 f7       	brne	.-32     	; 0x4c42 <cmdlineInputFunc+0x3ac>
    fputc(*ptr++    , state->myStdInOut);

  fputc(':'         , state->myStdInOut);
    4c62:	f7 01       	movw	r30, r14
    4c64:	62 8d       	ldd	r22, Z+26	; 0x1a
    4c66:	73 8d       	ldd	r23, Z+27	; 0x1b
    4c68:	8a e3       	ldi	r24, 0x3A	; 58
    4c6a:	90 e0       	ldi	r25, 0x00	; 0
    4c6c:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
  fputc(' '         , state->myStdInOut);
    4c70:	d7 01       	movw	r26, r14
    4c72:	5a 96       	adiw	r26, 0x1a	; 26
    4c74:	6d 91       	ld	r22, X+
    4c76:	7c 91       	ld	r23, X
    4c78:	5b 97       	sbiw	r26, 0x1b	; 27
    4c7a:	80 e2       	ldi	r24, 0x20	; 32
    4c7c:	90 e0       	ldi	r25, 0x00	; 0
    4c7e:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    4c82:	00 e6       	ldi	r16, 0x60	; 96
    4c84:	1b e0       	ldi	r17, 0x0B	; 11
    4c86:	07 c0       	rjmp	.+14     	; 0x4c96 <cmdlineInputFunc+0x400>

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4c88:	0f 5f       	subi	r16, 0xFF	; 255
    4c8a:	1f 4f       	sbci	r17, 0xFF	; 255
    4c8c:	f9 01       	movw	r30, r18
    4c8e:	84 91       	lpm	r24, Z+
    4c90:	90 e0       	ldi	r25, 0x00	; 0
    4c92:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    4c96:	98 01       	movw	r18, r16
  fputc(' '         , state->myStdInOut);

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    4c98:	f8 01       	movw	r30, r16
    4c9a:	84 91       	lpm	r24, Z+
    4c9c:	d7 01       	movw	r26, r14
    4c9e:	5a 96       	adiw	r26, 0x1a	; 26
    4ca0:	6d 91       	ld	r22, X+
    4ca2:	7c 91       	ld	r23, X
    4ca4:	5b 97       	sbiw	r26, 0x1b	; 27
    4ca6:	88 23       	and	r24, r24
    4ca8:	79 f7       	brne	.-34     	; 0x4c88 <cmdlineInputFunc+0x3f2>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);

  fputc('\r'        , state->myStdInOut);
    4caa:	8d e0       	ldi	r24, 0x0D	; 13
    4cac:	90 e0       	ldi	r25, 0x00	; 0
    4cae:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
  fputc('\n'        , state->myStdInOut);
    4cb2:	f7 01       	movw	r30, r14
    4cb4:	62 8d       	ldd	r22, Z+26	; 0x1a
    4cb6:	73 8d       	ldd	r23, Z+27	; 0x1b
    4cb8:	8a e0       	ldi	r24, 0x0A	; 10
    4cba:	90 e0       	ldi	r25, 0x00	; 0
    4cbc:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
  
  // if we did not get a match
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
    4cc0:	c7 01       	movw	r24, r14
    4cc2:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <cmdlinePrintPrompt>
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    state->CmdlineBufferEditPos++;
    // command is complete, process it
    cmdlineProcessInputString(state);
    // reset buffer
    state->CmdlineBufferLength = 0;
    4cc6:	d7 01       	movw	r26, r14
    4cc8:	1d 96       	adiw	r26, 0x0d	; 13
    4cca:	1c 92       	st	X, r1
    4ccc:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = 0;
    4cce:	1e 96       	adiw	r26, 0x0e	; 14
    4cd0:	1c 92       	st	X, r1
    4cd2:	74 c0       	rjmp	.+232    	; 0x4dbc <cmdlineInputFunc+0x526>
  }
  else if(c == ASCII_BS)
    4cd4:	18 30       	cpi	r17, 0x08	; 8
    4cd6:	09 f0       	breq	.+2      	; 0x4cda <cmdlineInputFunc+0x444>
    4cd8:	69 c0       	rjmp	.+210    	; 0x4dac <cmdlineInputFunc+0x516>
  {
    if(state->CmdlineBufferEditPos)
    4cda:	f7 01       	movw	r30, r14
    4cdc:	96 85       	ldd	r25, Z+14	; 0x0e
    4cde:	99 23       	and	r25, r25
    4ce0:	09 f4       	brne	.+2      	; 0x4ce4 <cmdlineInputFunc+0x44e>
    4ce2:	5c c0       	rjmp	.+184    	; 0x4d9c <cmdlineInputFunc+0x506>
    {
      // is this a simple delete (off the end of the line)
      if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    4ce4:	85 85       	ldd	r24, Z+13	; 0x0d
    4ce6:	98 17       	cp	r25, r24
    4ce8:	29 f5       	brne	.+74     	; 0x4d34 <cmdlineInputFunc+0x49e>
      {
        // destructive backspace
        // echo backspace-space-backspace
        fputc(ASCII_BS         , state->myStdInOut);
    4cea:	62 8d       	ldd	r22, Z+26	; 0x1a
    4cec:	73 8d       	ldd	r23, Z+27	; 0x1b
    4cee:	88 e0       	ldi	r24, 0x08	; 8
    4cf0:	90 e0       	ldi	r25, 0x00	; 0
    4cf2:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
        fputc(' '              , state->myStdInOut);
    4cf6:	d7 01       	movw	r26, r14
    4cf8:	5a 96       	adiw	r26, 0x1a	; 26
    4cfa:	6d 91       	ld	r22, X+
    4cfc:	7c 91       	ld	r23, X
    4cfe:	5b 97       	sbiw	r26, 0x1b	; 27
    4d00:	80 e2       	ldi	r24, 0x20	; 32
    4d02:	90 e0       	ldi	r25, 0x00	; 0
    4d04:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
        fputc(ASCII_BS         , state->myStdInOut);
    4d08:	f7 01       	movw	r30, r14
    4d0a:	62 8d       	ldd	r22, Z+26	; 0x1a
    4d0c:	73 8d       	ldd	r23, Z+27	; 0x1b
    4d0e:	88 e0       	ldi	r24, 0x08	; 8
    4d10:	90 e0       	ldi	r25, 0x00	; 0
    4d12:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
        // decrement our buffer length and edit position
        state->CmdlineBufferLength--;
    4d16:	d7 01       	movw	r26, r14
    4d18:	1d 96       	adiw	r26, 0x0d	; 13
    4d1a:	8c 91       	ld	r24, X
    4d1c:	1d 97       	sbiw	r26, 0x0d	; 13
    4d1e:	81 50       	subi	r24, 0x01	; 1
    4d20:	1d 96       	adiw	r26, 0x0d	; 13
    4d22:	8c 93       	st	X, r24
    4d24:	1d 97       	sbiw	r26, 0x0d	; 13
        state->CmdlineBufferEditPos--;
    4d26:	1e 96       	adiw	r26, 0x0e	; 14
    4d28:	8c 91       	ld	r24, X
    4d2a:	1e 97       	sbiw	r26, 0x0e	; 14
    4d2c:	81 50       	subi	r24, 0x01	; 1
    4d2e:	1e 96       	adiw	r26, 0x0e	; 14
    4d30:	8c 93       	st	X, r24
    4d32:	44 c0       	rjmp	.+136    	; 0x4dbc <cmdlineInputFunc+0x526>
      else
      {
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
    4d34:	81 50       	subi	r24, 0x01	; 1
    4d36:	f7 01       	movw	r30, r14
    4d38:	85 87       	std	Z+13, r24	; 0x0d
        state->CmdlineBufferEditPos--;
    4d3a:	91 50       	subi	r25, 0x01	; 1
    4d3c:	96 87       	std	Z+14, r25	; 0x0e
    4d3e:	05 c0       	rjmp	.+10     	; 0x4d4a <cmdlineInputFunc+0x4b4>
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
    4d40:	e9 0f       	add	r30, r25
    4d42:	f1 1d       	adc	r31, r1
    4d44:	81 81       	ldd	r24, Z+1	; 0x01
    4d46:	80 83       	st	Z, r24
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
        state->CmdlineBufferEditPos--;
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4d48:	9f 5f       	subi	r25, 0xFF	; 255
    4d4a:	d7 01       	movw	r26, r14
    4d4c:	1d 96       	adiw	r26, 0x0d	; 13
    4d4e:	8c 91       	ld	r24, X
    4d50:	1d 97       	sbiw	r26, 0x0d	; 13
    4d52:	ed 91       	ld	r30, X+
    4d54:	fc 91       	ld	r31, X
    4d56:	98 17       	cp	r25, r24
    4d58:	98 f3       	brcs	.-26     	; 0x4d40 <cmdlineInputFunc+0x4aa>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
    4d5a:	c7 01       	movw	r24, r14
    4d5c:	bf 01       	movw	r22, r30
    4d5e:	0e 94 33 23 	call	0x4666	; 0x4666 <cmdlineRepaint>
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
    4d62:	f7 01       	movw	r30, r14
    4d64:	62 8d       	ldd	r22, Z+26	; 0x1a
    4d66:	73 8d       	ldd	r23, Z+27	; 0x1b
    4d68:	80 e2       	ldi	r24, 0x20	; 32
    4d6a:	90 e0       	ldi	r25, 0x00	; 0
    4d6c:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4d70:	d7 01       	movw	r26, r14
    4d72:	1e 96       	adiw	r26, 0x0e	; 14
    4d74:	1c 91       	ld	r17, X
    4d76:	08 c0       	rjmp	.+16     	; 0x4d88 <cmdlineInputFunc+0x4f2>
          fputc(ASCII_BS       , state->myStdInOut);
    4d78:	f7 01       	movw	r30, r14
    4d7a:	62 8d       	ldd	r22, Z+26	; 0x1a
    4d7c:	73 8d       	ldd	r23, Z+27	; 0x1b
    4d7e:	88 e0       	ldi	r24, 0x08	; 8
    4d80:	90 e0       	ldi	r25, 0x00	; 0
    4d82:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4d86:	1f 5f       	subi	r17, 0xFF	; 255
    4d88:	d7 01       	movw	r26, r14
    4d8a:	1d 96       	adiw	r26, 0x0d	; 13
    4d8c:	8c 91       	ld	r24, X
    4d8e:	90 e0       	ldi	r25, 0x00	; 0
    4d90:	21 2f       	mov	r18, r17
    4d92:	30 e0       	ldi	r19, 0x00	; 0
    4d94:	82 17       	cp	r24, r18
    4d96:	93 07       	cpc	r25, r19
    4d98:	7c f7       	brge	.-34     	; 0x4d78 <cmdlineInputFunc+0x4e2>
    4d9a:	10 c0       	rjmp	.+32     	; 0x4dbc <cmdlineInputFunc+0x526>
      }
    }
    else
    {
      // else, ring the bell
      fputc(ASCII_BEL          , state->myStdInOut);
    4d9c:	f7 01       	movw	r30, r14
    4d9e:	62 8d       	ldd	r22, Z+26	; 0x1a
    4da0:	73 8d       	ldd	r23, Z+27	; 0x1b
    4da2:	87 e0       	ldi	r24, 0x07	; 7
    4da4:	90 e0       	ldi	r25, 0x00	; 0
    4da6:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    4daa:	08 c0       	rjmp	.+16     	; 0x4dbc <cmdlineInputFunc+0x526>
    }
  }
  else if(c == ASCII_DEL)
    4dac:	1f 37       	cpi	r17, 0x7F	; 127
    4dae:	31 f0       	breq	.+12     	; 0x4dbc <cmdlineInputFunc+0x526>
  {
    // not yet handled
  }
  else if(c == ASCII_ESC)
    4db0:	1b 31       	cpi	r17, 0x1B	; 27
    4db2:	21 f4       	brne	.+8      	; 0x4dbc <cmdlineInputFunc+0x526>
  {
    state->CmdlineInputVT100State = 1;
    4db4:	81 e0       	ldi	r24, 0x01	; 1
    4db6:	d7 01       	movw	r26, r14
    4db8:	52 96       	adiw	r26, 0x12	; 18
    4dba:	8c 93       	st	X, r24
  }
}
    4dbc:	26 96       	adiw	r28, 0x06	; 6
    4dbe:	0f b6       	in	r0, 0x3f	; 63
    4dc0:	f8 94       	cli
    4dc2:	de bf       	out	0x3e, r29	; 62
    4dc4:	0f be       	out	0x3f, r0	; 63
    4dc6:	cd bf       	out	0x3d, r28	; 61
    4dc8:	cf 91       	pop	r28
    4dca:	df 91       	pop	r29
    4dcc:	1f 91       	pop	r17
    4dce:	0f 91       	pop	r16
    4dd0:	ff 90       	pop	r15
    4dd2:	ef 90       	pop	r14
    4dd4:	df 90       	pop	r13
    4dd6:	cf 90       	pop	r12
    4dd8:	bf 90       	pop	r11
    4dda:	af 90       	pop	r10
    4ddc:	9f 90       	pop	r9
    4dde:	08 95       	ret

00004de0 <vt100SetCursorPos>:
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
}

void vt100SetCursorPos(uint8_t line, uint8_t col, cmdState_t *state)
{
    4de0:	da 01       	movw	r26, r20
  // ESC [ Pl ; Pc H
  fprintf_P(state->myStdInOut, "\x1B[%d;%dH",line,col);
    4de2:	2d b7       	in	r18, 0x3d	; 61
    4de4:	3e b7       	in	r19, 0x3e	; 62
    4de6:	28 50       	subi	r18, 0x08	; 8
    4de8:	30 40       	sbci	r19, 0x00	; 0
    4dea:	0f b6       	in	r0, 0x3f	; 63
    4dec:	f8 94       	cli
    4dee:	3e bf       	out	0x3e, r19	; 62
    4df0:	0f be       	out	0x3f, r0	; 63
    4df2:	2d bf       	out	0x3d, r18	; 61
    4df4:	ed b7       	in	r30, 0x3d	; 61
    4df6:	fe b7       	in	r31, 0x3e	; 62
    4df8:	31 96       	adiw	r30, 0x01	; 1
    4dfa:	5a 96       	adiw	r26, 0x1a	; 26
    4dfc:	2d 91       	ld	r18, X+
    4dfe:	3c 91       	ld	r19, X
    4e00:	5b 97       	sbiw	r26, 0x1b	; 27
    4e02:	ad b7       	in	r26, 0x3d	; 61
    4e04:	be b7       	in	r27, 0x3e	; 62
    4e06:	12 96       	adiw	r26, 0x02	; 2
    4e08:	3c 93       	st	X, r19
    4e0a:	2e 93       	st	-X, r18
    4e0c:	11 97       	sbiw	r26, 0x01	; 1
    4e0e:	26 e2       	ldi	r18, 0x26	; 38
    4e10:	31 e0       	ldi	r19, 0x01	; 1
    4e12:	33 83       	std	Z+3, r19	; 0x03
    4e14:	22 83       	std	Z+2, r18	; 0x02
    4e16:	84 83       	std	Z+4, r24	; 0x04
    4e18:	15 82       	std	Z+5, r1	; 0x05
    4e1a:	66 83       	std	Z+6, r22	; 0x06
    4e1c:	17 82       	std	Z+7, r1	; 0x07
    4e1e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    4e22:	2d b7       	in	r18, 0x3d	; 61
    4e24:	3e b7       	in	r19, 0x3e	; 62
    4e26:	28 5f       	subi	r18, 0xF8	; 248
    4e28:	3f 4f       	sbci	r19, 0xFF	; 255
    4e2a:	0f b6       	in	r0, 0x3f	; 63
    4e2c:	f8 94       	cli
    4e2e:	3e bf       	out	0x3e, r19	; 62
    4e30:	0f be       	out	0x3f, r0	; 63
    4e32:	2d bf       	out	0x3d, r18	; 61
}
    4e34:	08 95       	ret

00004e36 <vt100SetCursorMode>:
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
}

void vt100SetCursorMode(uint8_t visible, cmdState_t *state)
{
    4e36:	fb 01       	movw	r30, r22
    4e38:	22 8d       	ldd	r18, Z+26	; 0x1a
    4e3a:	33 8d       	ldd	r19, Z+27	; 0x1b
  if(visible)
    4e3c:	88 23       	and	r24, r24
    4e3e:	49 f0       	breq	.+18     	; 0x4e52 <vt100SetCursorMode+0x1c>
  // ESC [ ? 25 h
    fprintf_P(state->myStdInOut, "\x1B[?25h");
    4e40:	00 d0       	rcall	.+0      	; 0x4e42 <vt100SetCursorMode+0xc>
    4e42:	00 d0       	rcall	.+0      	; 0x4e44 <vt100SetCursorMode+0xe>
    4e44:	ed b7       	in	r30, 0x3d	; 61
    4e46:	fe b7       	in	r31, 0x3e	; 62
    4e48:	32 83       	std	Z+2, r19	; 0x02
    4e4a:	21 83       	std	Z+1, r18	; 0x01
    4e4c:	8f e2       	ldi	r24, 0x2F	; 47
    4e4e:	91 e0       	ldi	r25, 0x01	; 1
    4e50:	08 c0       	rjmp	.+16     	; 0x4e62 <vt100SetCursorMode+0x2c>
  else
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
    4e52:	00 d0       	rcall	.+0      	; 0x4e54 <vt100SetCursorMode+0x1e>
    4e54:	00 d0       	rcall	.+0      	; 0x4e56 <vt100SetCursorMode+0x20>
    4e56:	ed b7       	in	r30, 0x3d	; 61
    4e58:	fe b7       	in	r31, 0x3e	; 62
    4e5a:	32 83       	std	Z+2, r19	; 0x02
    4e5c:	21 83       	std	Z+1, r18	; 0x01
    4e5e:	86 e3       	ldi	r24, 0x36	; 54
    4e60:	91 e0       	ldi	r25, 0x01	; 1
    4e62:	94 83       	std	Z+4, r25	; 0x04
    4e64:	83 83       	std	Z+3, r24	; 0x03
    4e66:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    4e6a:	0f 90       	pop	r0
    4e6c:	0f 90       	pop	r0
    4e6e:	0f 90       	pop	r0
    4e70:	0f 90       	pop	r0
    4e72:	08 95       	ret

00004e74 <vt100SetAttr>:
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
}

void vt100SetAttr(uint8_t attr, cmdState_t *state)
{
    4e74:	db 01       	movw	r26, r22
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
    4e76:	00 d0       	rcall	.+0      	; 0x4e78 <vt100SetAttr+0x4>
    4e78:	00 d0       	rcall	.+0      	; 0x4e7a <vt100SetAttr+0x6>
    4e7a:	00 d0       	rcall	.+0      	; 0x4e7c <vt100SetAttr+0x8>
    4e7c:	ed b7       	in	r30, 0x3d	; 61
    4e7e:	fe b7       	in	r31, 0x3e	; 62
    4e80:	31 96       	adiw	r30, 0x01	; 1
    4e82:	5a 96       	adiw	r26, 0x1a	; 26
    4e84:	2d 91       	ld	r18, X+
    4e86:	3c 91       	ld	r19, X
    4e88:	5b 97       	sbiw	r26, 0x1b	; 27
    4e8a:	ad b7       	in	r26, 0x3d	; 61
    4e8c:	be b7       	in	r27, 0x3e	; 62
    4e8e:	12 96       	adiw	r26, 0x02	; 2
    4e90:	3c 93       	st	X, r19
    4e92:	2e 93       	st	-X, r18
    4e94:	11 97       	sbiw	r26, 0x01	; 1
    4e96:	2d e3       	ldi	r18, 0x3D	; 61
    4e98:	31 e0       	ldi	r19, 0x01	; 1
    4e9a:	33 83       	std	Z+3, r19	; 0x03
    4e9c:	22 83       	std	Z+2, r18	; 0x02
    4e9e:	84 83       	std	Z+4, r24	; 0x04
    4ea0:	15 82       	std	Z+5, r1	; 0x05
    4ea2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    4ea6:	8d b7       	in	r24, 0x3d	; 61
    4ea8:	9e b7       	in	r25, 0x3e	; 62
    4eaa:	06 96       	adiw	r24, 0x06	; 6
    4eac:	0f b6       	in	r0, 0x3f	; 63
    4eae:	f8 94       	cli
    4eb0:	9e bf       	out	0x3e, r25	; 62
    4eb2:	0f be       	out	0x3f, r0	; 63
    4eb4:	8d bf       	out	0x3d, r24	; 61
}
    4eb6:	08 95       	ret

00004eb8 <vt100ClearScreen>:
}

void vt100ClearScreen(cmdState_t *state)
{
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
    4eb8:	00 d0       	rcall	.+0      	; 0x4eba <vt100ClearScreen+0x2>
    4eba:	00 d0       	rcall	.+0      	; 0x4ebc <vt100ClearScreen+0x4>
    4ebc:	fc 01       	movw	r30, r24
    4ebe:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ec0:	93 8d       	ldd	r25, Z+27	; 0x1b
    4ec2:	ed b7       	in	r30, 0x3d	; 61
    4ec4:	fe b7       	in	r31, 0x3e	; 62
    4ec6:	92 83       	std	Z+2, r25	; 0x02
    4ec8:	81 83       	std	Z+1, r24	; 0x01
    4eca:	83 e4       	ldi	r24, 0x43	; 67
    4ecc:	91 e0       	ldi	r25, 0x01	; 1
    4ece:	94 83       	std	Z+4, r25	; 0x04
    4ed0:	83 83       	std	Z+3, r24	; 0x03
    4ed2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    4ed6:	0f 90       	pop	r0
    4ed8:	0f 90       	pop	r0
    4eda:	0f 90       	pop	r0
    4edc:	0f 90       	pop	r0
}
    4ede:	08 95       	ret

00004ee0 <vt100Init>:
void vt100Init(cmdState_t *state)
{
  // initializes terminal to "power-on" settings
  // ESC c

 fprintf_P(state->myStdInOut, "\x1B\x63");
    4ee0:	00 d0       	rcall	.+0      	; 0x4ee2 <vt100Init+0x2>
    4ee2:	00 d0       	rcall	.+0      	; 0x4ee4 <vt100Init+0x4>
    4ee4:	fc 01       	movw	r30, r24
    4ee6:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ee8:	93 8d       	ldd	r25, Z+27	; 0x1b
    4eea:	ed b7       	in	r30, 0x3d	; 61
    4eec:	fe b7       	in	r31, 0x3e	; 62
    4eee:	92 83       	std	Z+2, r25	; 0x02
    4ef0:	81 83       	std	Z+1, r24	; 0x01
    4ef2:	88 e4       	ldi	r24, 0x48	; 72
    4ef4:	91 e0       	ldi	r25, 0x01	; 1
    4ef6:	94 83       	std	Z+4, r25	; 0x04
    4ef8:	83 83       	std	Z+3, r24	; 0x03
    4efa:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    4efe:	0f 90       	pop	r0
    4f00:	0f 90       	pop	r0
    4f02:	0f 90       	pop	r0
    4f04:	0f 90       	pop	r0
}
    4f06:	08 95       	ret
    4f08:	08 95       	ret
    4f0a:	08 95       	ret

00004f0c <ds1305readMem>:
  spiDisableDS1305();  
  spiGive();
  return 0;
}
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
    4f0c:	0f 93       	push	r16
    4f0e:	1f 93       	push	r17
    4f10:	cf 93       	push	r28
    4f12:	df 93       	push	r29
    4f14:	18 2f       	mov	r17, r24
    4f16:	06 2f       	mov	r16, r22
    4f18:	ea 01       	movw	r28, r20
  if (addr >95)
    4f1a:	80 36       	cpi	r24, 0x60	; 96
    4f1c:	10 f0       	brcs	.+4      	; 0x4f22 <ds1305readMem+0x16>
    4f1e:	81 e0       	ldi	r24, 0x01	; 1
    4f20:	1d c0       	rjmp	.+58     	; 0x4f5c <ds1305readMem+0x50>
    return 1;
  if (addr + length > 95)
    4f22:	90 e0       	ldi	r25, 0x00	; 0
    4f24:	86 0f       	add	r24, r22
    4f26:	91 1d       	adc	r25, r1
    4f28:	80 36       	cpi	r24, 0x60	; 96
    4f2a:	91 05       	cpc	r25, r1
    4f2c:	14 f0       	brlt	.+4      	; 0x4f32 <ds1305readMem+0x26>
    4f2e:	82 e0       	ldi	r24, 0x02	; 2
    4f30:	15 c0       	rjmp	.+42     	; 0x4f5c <ds1305readMem+0x50>
    return 2;
  
  addr += 0x20;
  
  spiTake();
    4f32:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  spiEnableDS1305();
    4f36:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <spiEnableDS1305>

  spiSend(addr);
    4f3a:	81 2f       	mov	r24, r17
    4f3c:	80 5e       	subi	r24, 0xE0	; 224
    4f3e:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    4f42:	05 c0       	rjmp	.+10     	; 0x4f4e <ds1305readMem+0x42>
  while (length > 0)
  {
    *data = spiSend(0);
    4f44:	80 e0       	ldi	r24, 0x00	; 0
    4f46:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    4f4a:	89 93       	st	Y+, r24
    data++;
    length--;
    4f4c:	01 50       	subi	r16, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    4f4e:	00 23       	and	r16, r16
    4f50:	c9 f7       	brne	.-14     	; 0x4f44 <ds1305readMem+0x38>
    *data = spiSend(0);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    4f52:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <spiDisableDS1305>
  spiGive();
    4f56:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
    4f5a:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    4f5c:	df 91       	pop	r29
    4f5e:	cf 91       	pop	r28
    4f60:	1f 91       	pop	r17
    4f62:	0f 91       	pop	r16
    4f64:	08 95       	ret

00004f66 <ds1305writeMem>:
  return;
}


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
    4f66:	0f 93       	push	r16
    4f68:	1f 93       	push	r17
    4f6a:	cf 93       	push	r28
    4f6c:	df 93       	push	r29
    4f6e:	18 2f       	mov	r17, r24
    4f70:	06 2f       	mov	r16, r22
    4f72:	ea 01       	movw	r28, r20
  if (addr > 95)
    4f74:	80 36       	cpi	r24, 0x60	; 96
    4f76:	10 f0       	brcs	.+4      	; 0x4f7c <ds1305writeMem+0x16>
    4f78:	81 e0       	ldi	r24, 0x01	; 1
    4f7a:	1c c0       	rjmp	.+56     	; 0x4fb4 <ds1305writeMem+0x4e>
    return 1;
  if (addr + length > 95)
    4f7c:	90 e0       	ldi	r25, 0x00	; 0
    4f7e:	86 0f       	add	r24, r22
    4f80:	91 1d       	adc	r25, r1
    4f82:	80 36       	cpi	r24, 0x60	; 96
    4f84:	91 05       	cpc	r25, r1
    4f86:	14 f0       	brlt	.+4      	; 0x4f8c <ds1305writeMem+0x26>
    4f88:	82 e0       	ldi	r24, 0x02	; 2
    4f8a:	14 c0       	rjmp	.+40     	; 0x4fb4 <ds1305writeMem+0x4e>
    return 2;

  addr += 0xA0;
  
  spiTake();
    4f8c:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  spiEnableDS1305();
    4f90:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <spiEnableDS1305>

  spiSend(addr);
    4f94:	81 2f       	mov	r24, r17
    4f96:	80 56       	subi	r24, 0x60	; 96
    4f98:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    4f9c:	04 c0       	rjmp	.+8      	; 0x4fa6 <ds1305writeMem+0x40>
  while (length > 0)
  {
    spiSend(*data);
    4f9e:	89 91       	ld	r24, Y+
    4fa0:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    data++;
    length--;
    4fa4:	01 50       	subi	r16, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    4fa6:	00 23       	and	r16, r16
    4fa8:	d1 f7       	brne	.-12     	; 0x4f9e <ds1305writeMem+0x38>
    spiSend(*data);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    4faa:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <spiDisableDS1305>
  spiGive();
    4fae:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
    4fb2:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    4fb4:	df 91       	pop	r29
    4fb6:	cf 91       	pop	r28
    4fb8:	1f 91       	pop	r17
    4fba:	0f 91       	pop	r16
    4fbc:	08 95       	ret

00004fbe <ds1305start>:
}
#endif /* USE_DECODED_TIME_STRUCT */

void ds1305start(void)
{  
  spiTake();
    4fbe:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  spiEnableDS1305();
    4fc2:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <spiEnableDS1305>

  spiSend(0x8F);
    4fc6:	8f e8       	ldi	r24, 0x8F	; 143
    4fc8:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(0x00);
    4fcc:	80 e0       	ldi	r24, 0x00	; 0
    4fce:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  
  spiDisableDS1305();  
    4fd2:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <spiDisableDS1305>
  spiGive();
    4fd6:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>

  return;
}
    4fda:	08 95       	ret

00004fdc <setTimeBCD>:
}
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
{
    4fdc:	0f 93       	push	r16
    4fde:	1f 93       	push	r17
    4fe0:	cf 93       	push	r28
    4fe2:	df 93       	push	r29
    4fe4:	18 2f       	mov	r17, r24
    4fe6:	09 2f       	mov	r16, r25
  spiTake();
    4fe8:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  spiEnableDS1305();
    4fec:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    4ff0:	21 2f       	mov	r18, r17
    4ff2:	30 2f       	mov	r19, r16
    4ff4:	c9 01       	movw	r24, r18
    4ff6:	ec 01       	movw	r28, r24
  uint8_t i;
  spiSend(0x80);
    4ff8:	80 e8       	ldi	r24, 0x80	; 128
    4ffa:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    4ffe:	10 e0       	ldi	r17, 0x00	; 0
  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    spiSend(*ptr);
    5000:	89 91       	ld	r24, Y+
    5002:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiEnableDS1305();
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
    5006:	1f 5f       	subi	r17, 0xFF	; 255
    5008:	17 30       	cpi	r17, 0x07	; 7
    500a:	d1 f7       	brne	.-12     	; 0x5000 <setTimeBCD+0x24>
  {
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
    500c:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <spiDisableDS1305>
  spiGive();
    5010:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    5014:	df 91       	pop	r29
    5016:	cf 91       	pop	r28
    5018:	1f 91       	pop	r17
    501a:	0f 91       	pop	r16
    501c:	08 95       	ret

0000501e <setTime>:
{
  setTimeBCD((timeBCD_t *)(time));
}
void setTime(time_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    501e:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <setTimeBCD>
}
    5022:	08 95       	ret

00005024 <setTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void setTimeDecoded(timeDecoded_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    5024:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <setTimeBCD>
}
    5028:	08 95       	ret

0000502a <readTimeBCD>:
void spiEnableDS1305(void)  {};
void spiDisableDS1305(void) {};


void readTimeBCD(timeBCD_t *time)
{
    502a:	0f 93       	push	r16
    502c:	1f 93       	push	r17
    502e:	cf 93       	push	r28
    5030:	df 93       	push	r29
    5032:	18 2f       	mov	r17, r24
    5034:	09 2f       	mov	r16, r25
  spiTake();
    5036:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  spiEnableDS1305();
    503a:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    503e:	21 2f       	mov	r18, r17
    5040:	30 2f       	mov	r19, r16
    5042:	c9 01       	movw	r24, r18
    5044:	ec 01       	movw	r28, r24
  uint8_t i;
  
  spiSend(0x00);
    5046:	80 e0       	ldi	r24, 0x00	; 0
    5048:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    504c:	10 e0       	ldi	r17, 0x00	; 0

  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    *ptr = spiSend(i);
    504e:	81 2f       	mov	r24, r17
    5050:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    5054:	89 93       	st	Y+, r24
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);

  for (i=0; i<sizeof(timeBCD_t); i++)
    5056:	1f 5f       	subi	r17, 0xFF	; 255
    5058:	17 30       	cpi	r17, 0x07	; 7
    505a:	c9 f7       	brne	.-14     	; 0x504e <readTimeBCD+0x24>
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
    505c:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <spiDisableDS1305>
  spiGive();
    5060:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    5064:	df 91       	pop	r29
    5066:	cf 91       	pop	r28
    5068:	1f 91       	pop	r17
    506a:	0f 91       	pop	r16
    506c:	08 95       	ret

0000506e <readTime>:
{
  readTimeBCD((timeBCD_t *)(time));
}
void readTime (time_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    506e:	0e 94 15 28 	call	0x502a	; 0x502a <readTimeBCD>
}
    5072:	08 95       	ret

00005074 <readTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void readTimeDecoded(timeDecoded_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    5074:	0e 94 15 28 	call	0x502a	; 0x502a <readTimeBCD>
}
    5078:	08 95       	ret
    507a:	08 95       	ret
    507c:	08 95       	ret

0000507e <MPC23s17ReadPortB>:

  return result; 
}

uint8_t MPC23s17ReadPortB(uint8_t addr)
{
    507e:	1f 93       	push	r17
  addr = addr<<1;
    5080:	18 2f       	mov	r17, r24
    5082:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5084:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    5086:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    5088:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    508c:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>

  spiSend(addr);
    5090:	81 2f       	mov	r24, r17
    5092:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_GPIOB);
    5096:	83 e1       	ldi	r24, 0x13	; 19
    5098:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  uint8_t result = spiSend(addr);  
    509c:	81 2f       	mov	r24, r17
    509e:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    50a2:	18 2f       	mov	r17, r24

  disableSpiMPC23S17();
    50a4:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    50a8:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>

  return result; 
}
    50ac:	81 2f       	mov	r24, r17
    50ae:	1f 91       	pop	r17
    50b0:	08 95       	ret

000050b2 <MPC23s17ReadPortA>:
  disableSpiMPC23S17();
  spiGive();
}

uint8_t MPC23s17ReadPortA(uint8_t addr)
{
    50b2:	1f 93       	push	r17
  addr = addr<<1;
    50b4:	18 2f       	mov	r17, r24
    50b6:	11 0f       	add	r17, r17
  addr &= 0x0E;
    50b8:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    50ba:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    50bc:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    50c0:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>

  spiSend(addr);
    50c4:	81 2f       	mov	r24, r17
    50c6:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_GPIOA);
    50ca:	82 e1       	ldi	r24, 0x12	; 18
    50cc:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  uint8_t result = spiSend(addr);  
    50d0:	81 2f       	mov	r24, r17
    50d2:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    50d6:	18 2f       	mov	r17, r24

  disableSpiMPC23S17();
    50d8:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    50dc:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>

  return result; 
}
    50e0:	81 2f       	mov	r24, r17
    50e2:	1f 91       	pop	r17
    50e4:	08 95       	ret

000050e6 <MPC23s17ClearBitsOnPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17ClearBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    50e6:	1f 93       	push	r17
    50e8:	16 2f       	mov	r17, r22
  addr = addr<<1;
    50ea:	11 0f       	add	r17, r17
  addr &= 0x0E;
    50ec:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB &= (~portBout);
    50ee:	90 91 79 0e 	lds	r25, 0x0E79
    50f2:	80 95       	com	r24
    50f4:	98 23       	and	r25, r24
    50f6:	90 93 79 0e 	sts	0x0E79, r25

  spiTake();
    50fa:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    50fe:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  spiSend(addr);
    5102:	81 2f       	mov	r24, r17
    5104:	80 64       	ori	r24, 0x40	; 64
    5106:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_OLATB);
    510a:	85 e1       	ldi	r24, 0x15	; 21
    510c:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portB);  
    5110:	80 91 79 0e 	lds	r24, 0x0E79
    5114:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>

  disableSpiMPC23S17();
    5118:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    511c:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    5120:	1f 91       	pop	r17
    5122:	08 95       	ret

00005124 <MPC23s17SetBitsOnPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5124:	1f 93       	push	r17
    5126:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5128:	11 0f       	add	r17, r17
  addr &= 0x0E;
    512a:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB |= portBout;
    512c:	90 91 79 0e 	lds	r25, 0x0E79
    5130:	98 2b       	or	r25, r24
    5132:	90 93 79 0e 	sts	0x0E79, r25

  spiTake();
    5136:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    513a:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  spiSend(addr);
    513e:	81 2f       	mov	r24, r17
    5140:	80 64       	ori	r24, 0x40	; 64
    5142:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_OLATB);
    5146:	85 e1       	ldi	r24, 0x15	; 21
    5148:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portB);  
    514c:	80 91 79 0e 	lds	r24, 0x0E79
    5150:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  disableSpiMPC23S17();
    5154:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    5158:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    515c:	1f 91       	pop	r17
    515e:	08 95       	ret

00005160 <MPC23s17SetPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetPortB(uint8_t portBout, uint8_t addr)
{
    5160:	1f 93       	push	r17
    5162:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5164:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5166:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB = portBout;
    5168:	80 93 79 0e 	sts	0x0E79, r24

  spiTake();
    516c:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    5170:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  spiSend(addr);
    5174:	81 2f       	mov	r24, r17
    5176:	80 64       	ori	r24, 0x40	; 64
    5178:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_OLATB);
    517c:	85 e1       	ldi	r24, 0x15	; 21
    517e:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portB);  
    5182:	80 91 79 0e 	lds	r24, 0x0E79
    5186:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  disableSpiMPC23S17();
    518a:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    518e:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    5192:	1f 91       	pop	r17
    5194:	08 95       	ret

00005196 <MPC23s17ClearBitsOnPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17ClearBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    5196:	1f 93       	push	r17
    5198:	16 2f       	mov	r17, r22
  addr = addr<<1;
    519a:	11 0f       	add	r17, r17
  addr &= 0x0E;
    519c:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA &= (~portAout);
    519e:	90 91 c2 0e 	lds	r25, 0x0EC2
    51a2:	80 95       	com	r24
    51a4:	98 23       	and	r25, r24
    51a6:	90 93 c2 0e 	sts	0x0EC2, r25

  spiTake();
    51aa:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    51ae:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  spiSend(addr);
    51b2:	81 2f       	mov	r24, r17
    51b4:	80 64       	ori	r24, 0x40	; 64
    51b6:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_OLATA);
    51ba:	84 e1       	ldi	r24, 0x14	; 20
    51bc:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portA);  
    51c0:	80 91 c2 0e 	lds	r24, 0x0EC2
    51c4:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  disableSpiMPC23S17();
    51c8:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    51cc:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    51d0:	1f 91       	pop	r17
    51d2:	08 95       	ret

000051d4 <MPC23s17SetBitsOnPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    51d4:	1f 93       	push	r17
    51d6:	16 2f       	mov	r17, r22
  addr = addr<<1;
    51d8:	11 0f       	add	r17, r17
  addr &= 0x0E;
    51da:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA |= portAout;  
    51dc:	90 91 c2 0e 	lds	r25, 0x0EC2
    51e0:	98 2b       	or	r25, r24
    51e2:	90 93 c2 0e 	sts	0x0EC2, r25

  spiTake();
    51e6:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    51ea:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  spiSend(addr);
    51ee:	81 2f       	mov	r24, r17
    51f0:	80 64       	ori	r24, 0x40	; 64
    51f2:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_OLATA);
    51f6:	84 e1       	ldi	r24, 0x14	; 20
    51f8:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portA);  
    51fc:	80 91 c2 0e 	lds	r24, 0x0EC2
    5200:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  disableSpiMPC23S17();
    5204:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    5208:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    520c:	1f 91       	pop	r17
    520e:	08 95       	ret

00005210 <MPC23s17SetPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetPortA(uint8_t portAout, uint8_t addr)
{
    5210:	0f 93       	push	r16
    5212:	1f 93       	push	r17
    5214:	18 2f       	mov	r17, r24
    5216:	06 2f       	mov	r16, r22
  addr = addr<<1;
    5218:	00 0f       	add	r16, r16
  addr &= 0x0E;
    521a:	0e 70       	andi	r16, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    521c:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    5220:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  portA = portAout;  
    5224:	10 93 c2 0e 	sts	0x0EC2, r17
  spiSend(addr);
    5228:	80 2f       	mov	r24, r16
    522a:	80 64       	ori	r24, 0x40	; 64
    522c:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_OLATA);
    5230:	84 e1       	ldi	r24, 0x14	; 20
    5232:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portA);  
    5236:	80 91 c2 0e 	lds	r24, 0x0EC2
    523a:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>

  disableSpiMPC23S17();
    523e:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    5242:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    5246:	1f 91       	pop	r17
    5248:	0f 91       	pop	r16
    524a:	08 95       	ret

0000524c <MPC23s17SetDirB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetDirB(uint8_t portBdir, uint8_t addr)
{
    524c:	0f 93       	push	r16
    524e:	1f 93       	push	r17
    5250:	08 2f       	mov	r16, r24
    5252:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5254:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5256:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    5258:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17();
    525c:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  
  spiSend(addr);
    5260:	81 2f       	mov	r24, r17
    5262:	80 64       	ori	r24, 0x40	; 64
    5264:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_IODIRB);
    5268:	81 e0       	ldi	r24, 0x01	; 1
    526a:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portBdir);  
    526e:	80 2f       	mov	r24, r16
    5270:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  
  disableSpiMPC23S17();
    5274:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    5278:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    527c:	1f 91       	pop	r17
    527e:	0f 91       	pop	r16
    5280:	08 95       	ret

00005282 <MPC23s17SetDirA>:
void enableSpiMPC23S17(void)  {}
void disableSpiMPC23S17(void) {}


void MPC23s17SetDirA(uint8_t portAdir, uint8_t addr)
{
    5282:	0f 93       	push	r16
    5284:	1f 93       	push	r17
    5286:	08 2f       	mov	r16, r24
    5288:	16 2f       	mov	r17, r22
  addr = addr<<1;
    528a:	11 0f       	add	r17, r17
  addr &= 0x0E;
    528c:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    528e:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMPC23S17(); 
    5292:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <enableSpiMPC23S17>
  spiSend(addr);
    5296:	81 2f       	mov	r24, r17
    5298:	80 64       	ori	r24, 0x40	; 64
    529a:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(B0_IODIRA);
    529e:	80 e0       	ldi	r24, 0x00	; 0
    52a0:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(portAdir);  
    52a4:	80 2f       	mov	r24, r16
    52a6:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  
  disableSpiMPC23S17();
    52aa:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <disableSpiMPC23S17>
  spiGive();
    52ae:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    52b2:	1f 91       	pop	r17
    52b4:	0f 91       	pop	r16
    52b6:	08 95       	ret
    52b8:	08 95       	ret
    52ba:	08 95       	ret

000052bc <MCP3008_getSampleSingle>:
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}

uint16_t MCP3008_getSampleSingle(uint8_t inputNo)
{
    52bc:	ff 92       	push	r15
    52be:	0f 93       	push	r16
    52c0:	1f 93       	push	r17
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    52c2:	18 2f       	mov	r17, r24
    52c4:	12 95       	swap	r17
  inputNo &= 0x70;
    52c6:	10 77       	andi	r17, 0x70	; 112
  inputNo |= 0x80;
  
  spiTake();
    52c8:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMCP3008();
    52cc:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <enableSpiMCP3008>
  
  spiSend(0x01);                //Start
    52d0:	81 e0       	ldi	r24, 0x01	; 1
    52d2:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    52d6:	81 2f       	mov	r24, r17
    52d8:	80 68       	ori	r24, 0x80	; 128
    52da:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    52de:	f8 2e       	mov	r15, r24
  resultLo = spiSend(0);        //X X X X X X X X
    52e0:	80 e0       	ldi	r24, 0x00	; 0
    52e2:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    52e6:	08 2f       	mov	r16, r24
  
  disableSpiMCP3008(); 
    52e8:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <disableSpiMCP3008>
  spiGive();
    52ec:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
    52f0:	9f 2d       	mov	r25, r15
    52f2:	93 70       	andi	r25, 0x03	; 3
    52f4:	80 e0       	ldi	r24, 0x00	; 0
    52f6:	10 e0       	ldi	r17, 0x00	; 0
    52f8:	08 2b       	or	r16, r24
    52fa:	19 2b       	or	r17, r25
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}
    52fc:	c8 01       	movw	r24, r16
    52fe:	1f 91       	pop	r17
    5300:	0f 91       	pop	r16
    5302:	ff 90       	pop	r15
    5304:	08 95       	ret

00005306 <MCP3008_getSampleDiff>:
void enableSpiMCP3008(void)   {};
void disableSpiMCP3008(void)  {};


uint16_t MCP3008_getSampleDiff(uint8_t inputNo)
{
    5306:	ff 92       	push	r15
    5308:	0f 93       	push	r16
    530a:	1f 93       	push	r17
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    530c:	18 2f       	mov	r17, r24
    530e:	12 95       	swap	r17
    5310:	10 7f       	andi	r17, 0xF0	; 240
  inputNo &= 0x70;
  
  spiTake();
    5312:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMCP3008();
    5316:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <enableSpiMCP3008>
  
  spiSend(0x01);                               //Start
    531a:	81 e0       	ldi	r24, 0x01	; 1
    531c:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    5320:	81 2f       	mov	r24, r17
    5322:	80 77       	andi	r24, 0x70	; 112
    5324:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    5328:	f8 2e       	mov	r15, r24
  resultLo = spiSend(0);        //X X X X X X X X
    532a:	80 e0       	ldi	r24, 0x00	; 0
    532c:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    5330:	08 2f       	mov	r16, r24
  
  disableSpiMCP3008(); 
    5332:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <disableSpiMCP3008>
  spiGive();
    5336:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
    533a:	9f 2d       	mov	r25, r15
    533c:	93 70       	andi	r25, 0x03	; 3
    533e:	80 e0       	ldi	r24, 0x00	; 0
    5340:	10 e0       	ldi	r17, 0x00	; 0
    5342:	08 2b       	or	r16, r24
    5344:	19 2b       	or	r17, r25
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}
    5346:	c8 01       	movw	r24, r16
    5348:	1f 91       	pop	r17
    534a:	0f 91       	pop	r16
    534c:	ff 90       	pop	r15
    534e:	08 95       	ret
    5350:	08 95       	ret
    5352:	08 95       	ret

00005354 <MCP4150_setValue>:
/**
 * Ustawia wartość rezystancji
 * @param inputNo - WARTOŚĆ OD 0 DO 255.
 */
void MCP4150_setValue(uint8_t value)
{  
    5354:	1f 93       	push	r17
    5356:	18 2f       	mov	r17, r24
  spiTake();
    5358:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  enableSpiMCP4150();
    535c:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <enableSpiMCP4150>
  
  spiSend(0x11);  
    5360:	81 e1       	ldi	r24, 0x11	; 17
    5362:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(value);
    5366:	81 2f       	mov	r24, r17
    5368:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  
  disableSpiMCP4150(); 
    536c:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <disableSpiMCP4150>
  spiGive();
    5370:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    5374:	1f 91       	pop	r17
    5376:	08 95       	ret
    5378:	08 95       	ret
    537a:	08 95       	ret

0000537c <enc28j60WriteOp>:
  spiGive();
  return result; 
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
    537c:	ff 92       	push	r15
    537e:	0f 93       	push	r16
    5380:	1f 93       	push	r17
    5382:	18 2f       	mov	r17, r24
    5384:	06 2f       	mov	r16, r22
    5386:	f4 2e       	mov	r15, r20
  spiTake();
    5388:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  spiEnableEnc28j60();
    538c:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <spiEnableEnc28j60>
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSend(op | (address & ADDR_MASK));
    5390:	0f 71       	andi	r16, 0x1F	; 31
    5392:	80 2f       	mov	r24, r16
    5394:	81 2b       	or	r24, r17
    5396:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiSend(data);
    539a:	8f 2d       	mov	r24, r15
    539c:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
  spiDisableEnc28j60();
    53a0:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <spiDisableEnc28j60>
  spiGive();
    53a4:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
}
    53a8:	1f 91       	pop	r17
    53aa:	0f 91       	pop	r16
    53ac:	ff 90       	pop	r15
    53ae:	08 95       	ret

000053b0 <enc28j60SetBank>:
//   spiGive();
// }


void enc28j60SetBank(uint8_t address)
{
    53b0:	1f 93       	push	r17
    53b2:	cf 93       	push	r28
    53b4:	df 93       	push	r29
    53b6:	18 2f       	mov	r17, r24
  // set the bank (if needed)
  if((address & BANK_MASK) != Enc28j60Bank)
    53b8:	c8 2f       	mov	r28, r24
    53ba:	d0 e0       	ldi	r29, 0x00	; 0
    53bc:	c0 76       	andi	r28, 0x60	; 96
    53be:	d0 70       	andi	r29, 0x00	; 0
    53c0:	80 91 90 01 	lds	r24, 0x0190
    53c4:	90 e0       	ldi	r25, 0x00	; 0
    53c6:	c8 17       	cp	r28, r24
    53c8:	d9 07       	cpc	r29, r25
    53ca:	91 f0       	breq	.+36     	; 0x53f0 <enc28j60SetBank+0x40>
  {
    // set the bank
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    53cc:	80 ea       	ldi	r24, 0xA0	; 160
    53ce:	6f e1       	ldi	r22, 0x1F	; 31
    53d0:	43 e0       	ldi	r20, 0x03	; 3
    53d2:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    53d6:	85 e0       	ldi	r24, 0x05	; 5
    53d8:	d5 95       	asr	r29
    53da:	c7 95       	ror	r28
    53dc:	8a 95       	dec	r24
    53de:	e1 f7       	brne	.-8      	; 0x53d8 <enc28j60SetBank+0x28>
    53e0:	80 e8       	ldi	r24, 0x80	; 128
    53e2:	6f e1       	ldi	r22, 0x1F	; 31
    53e4:	4c 2f       	mov	r20, r28
    53e6:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    Enc28j60Bank = (address & BANK_MASK);
    53ea:	10 76       	andi	r17, 0x60	; 96
    53ec:	10 93 90 01 	sts	0x0190, r17
  }
}
    53f0:	df 91       	pop	r29
    53f2:	cf 91       	pop	r28
    53f4:	1f 91       	pop	r17
    53f6:	08 95       	ret

000053f8 <enc28j60Write>:

  return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    53f8:	0f 93       	push	r16
    53fa:	1f 93       	push	r17
    53fc:	18 2f       	mov	r17, r24
    53fe:	06 2f       	mov	r16, r22
  // set the bank
  enc28j60SetBank(address);
    5400:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <enc28j60SetBank>
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    5404:	80 e4       	ldi	r24, 0x40	; 64
    5406:	61 2f       	mov	r22, r17
    5408:	40 2f       	mov	r20, r16
    540a:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
}
    540e:	1f 91       	pop	r17
    5410:	0f 91       	pop	r16
    5412:	08 95       	ret

00005414 <nicSetMacAddress>:
    5414:	0f 93       	push	r16
    5416:	1f 93       	push	r17
    5418:	8c 01       	movw	r16, r24
    541a:	84 ee       	ldi	r24, 0xE4	; 228
    541c:	f8 01       	movw	r30, r16
    541e:	60 81       	ld	r22, Z
    5420:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5424:	85 ee       	ldi	r24, 0xE5	; 229
    5426:	f8 01       	movw	r30, r16
    5428:	61 81       	ldd	r22, Z+1	; 0x01
    542a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    542e:	82 ee       	ldi	r24, 0xE2	; 226
    5430:	f8 01       	movw	r30, r16
    5432:	62 81       	ldd	r22, Z+2	; 0x02
    5434:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5438:	83 ee       	ldi	r24, 0xE3	; 227
    543a:	f8 01       	movw	r30, r16
    543c:	63 81       	ldd	r22, Z+3	; 0x03
    543e:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5442:	80 ee       	ldi	r24, 0xE0	; 224
    5444:	f8 01       	movw	r30, r16
    5446:	64 81       	ldd	r22, Z+4	; 0x04
    5448:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    544c:	81 ee       	ldi	r24, 0xE1	; 225
    544e:	f8 01       	movw	r30, r16
    5450:	65 81       	ldd	r22, Z+5	; 0x05
    5452:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5456:	1f 91       	pop	r17
    5458:	0f 91       	pop	r16
    545a:	08 95       	ret

0000545c <enc28j60ReadOp>:
    enc28j60PhyWrite    (PHLCON, 0x476);
    vTaskDelay          (2);
}

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
    545c:	0f 93       	push	r16
    545e:	1f 93       	push	r17
    5460:	18 2f       	mov	r17, r24
    5462:	06 2f       	mov	r16, r22
  uint8_t result;
  spiTake();
    5464:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
  spiEnableEnc28j60();
    5468:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <spiEnableEnc28j60>
  
  // issue read command
  spiSend(op | (address & ADDR_MASK));
    546c:	80 2f       	mov	r24, r16
    546e:	8f 71       	andi	r24, 0x1F	; 31
    5470:	81 2b       	or	r24, r17
    5472:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>

  // read data
  result = spiSend(0x00);
    5476:	80 e0       	ldi	r24, 0x00	; 0
    5478:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    547c:	18 2f       	mov	r17, r24

  // do dummy read if needed (for mac and mii, see datasheet page 29)
  if(address & 0x80)
    547e:	07 ff       	sbrs	r16, 7
    5480:	04 c0       	rjmp	.+8      	; 0x548a <enc28j60ReadOp+0x2e>
  {
    result = spiSend(0x00);
    5482:	80 e0       	ldi	r24, 0x00	; 0
    5484:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    5488:	18 2f       	mov	r17, r24
  }

  spiDisableEnc28j60();
    548a:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <spiDisableEnc28j60>
  spiGive();
    548e:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
  return result; 
}
    5492:	81 2f       	mov	r24, r17
    5494:	1f 91       	pop	r17
    5496:	0f 91       	pop	r16
    5498:	08 95       	ret

0000549a <enc28j60Read>:
    Enc28j60Bank = (address & BANK_MASK);
  }
}

uint8_t enc28j60Read(uint8_t address)
{
    549a:	1f 93       	push	r17
    549c:	18 2f       	mov	r17, r24
  // set the bank
  enc28j60SetBank(address);
    549e:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <enc28j60SetBank>
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    54a2:	80 e0       	ldi	r24, 0x00	; 0
    54a4:	61 2f       	mov	r22, r17
    54a6:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
  return result;
}
    54aa:	1f 91       	pop	r17
    54ac:	08 95       	ret

000054ae <nicRegDump>:
    54ae:	0f 93       	push	r16
    54b0:	1f 93       	push	r17
    54b2:	8c 01       	movw	r16, r24
    54b4:	00 d0       	rcall	.+0      	; 0x54b6 <nicRegDump+0x8>
    54b6:	00 d0       	rcall	.+0      	; 0x54b8 <nicRegDump+0xa>
    54b8:	ad b7       	in	r26, 0x3d	; 61
    54ba:	be b7       	in	r27, 0x3e	; 62
    54bc:	12 96       	adiw	r26, 0x02	; 2
    54be:	9c 93       	st	X, r25
    54c0:	8e 93       	st	-X, r24
    54c2:	11 97       	sbiw	r26, 0x01	; 1
    54c4:	8d e0       	ldi	r24, 0x0D	; 13
    54c6:	9c e0       	ldi	r25, 0x0C	; 12
    54c8:	14 96       	adiw	r26, 0x04	; 4
    54ca:	9c 93       	st	X, r25
    54cc:	8e 93       	st	-X, r24
    54ce:	13 97       	sbiw	r26, 0x03	; 3
    54d0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    54d4:	0f 90       	pop	r0
    54d6:	0f 90       	pop	r0
    54d8:	0f 90       	pop	r0
    54da:	0f 90       	pop	r0
    54dc:	81 ee       	ldi	r24, 0xE1	; 225
    54de:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    54e2:	00 d0       	rcall	.+0      	; 0x54e4 <nicRegDump+0x36>
    54e4:	00 d0       	rcall	.+0      	; 0x54e6 <nicRegDump+0x38>
    54e6:	00 d0       	rcall	.+0      	; 0x54e8 <nicRegDump+0x3a>
    54e8:	ed b7       	in	r30, 0x3d	; 61
    54ea:	fe b7       	in	r31, 0x3e	; 62
    54ec:	31 96       	adiw	r30, 0x01	; 1
    54ee:	ad b7       	in	r26, 0x3d	; 61
    54f0:	be b7       	in	r27, 0x3e	; 62
    54f2:	12 96       	adiw	r26, 0x02	; 2
    54f4:	1c 93       	st	X, r17
    54f6:	0e 93       	st	-X, r16
    54f8:	11 97       	sbiw	r26, 0x01	; 1
    54fa:	2e ef       	ldi	r18, 0xFE	; 254
    54fc:	3b e0       	ldi	r19, 0x0B	; 11
    54fe:	33 83       	std	Z+3, r19	; 0x03
    5500:	22 83       	std	Z+2, r18	; 0x02
    5502:	84 83       	std	Z+4, r24	; 0x04
    5504:	15 82       	std	Z+5, r1	; 0x05
    5506:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    550a:	ed b7       	in	r30, 0x3d	; 61
    550c:	fe b7       	in	r31, 0x3e	; 62
    550e:	36 96       	adiw	r30, 0x06	; 6
    5510:	0f b6       	in	r0, 0x3f	; 63
    5512:	f8 94       	cli
    5514:	fe bf       	out	0x3e, r31	; 62
    5516:	0f be       	out	0x3f, r0	; 63
    5518:	ed bf       	out	0x3d, r30	; 61
    551a:	80 ee       	ldi	r24, 0xE0	; 224
    551c:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5520:	00 d0       	rcall	.+0      	; 0x5522 <nicRegDump+0x74>
    5522:	00 d0       	rcall	.+0      	; 0x5524 <nicRegDump+0x76>
    5524:	00 d0       	rcall	.+0      	; 0x5526 <nicRegDump+0x78>
    5526:	ed b7       	in	r30, 0x3d	; 61
    5528:	fe b7       	in	r31, 0x3e	; 62
    552a:	31 96       	adiw	r30, 0x01	; 1
    552c:	ad b7       	in	r26, 0x3d	; 61
    552e:	be b7       	in	r27, 0x3e	; 62
    5530:	12 96       	adiw	r26, 0x02	; 2
    5532:	1c 93       	st	X, r17
    5534:	0e 93       	st	-X, r16
    5536:	11 97       	sbiw	r26, 0x01	; 1
    5538:	2f ee       	ldi	r18, 0xEF	; 239
    553a:	3b e0       	ldi	r19, 0x0B	; 11
    553c:	33 83       	std	Z+3, r19	; 0x03
    553e:	22 83       	std	Z+2, r18	; 0x02
    5540:	84 83       	std	Z+4, r24	; 0x04
    5542:	15 82       	std	Z+5, r1	; 0x05
    5544:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5548:	ed b7       	in	r30, 0x3d	; 61
    554a:	fe b7       	in	r31, 0x3e	; 62
    554c:	36 96       	adiw	r30, 0x06	; 6
    554e:	0f b6       	in	r0, 0x3f	; 63
    5550:	f8 94       	cli
    5552:	fe bf       	out	0x3e, r31	; 62
    5554:	0f be       	out	0x3f, r0	; 63
    5556:	ed bf       	out	0x3d, r30	; 61
    5558:	83 ee       	ldi	r24, 0xE3	; 227
    555a:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    555e:	00 d0       	rcall	.+0      	; 0x5560 <nicRegDump+0xb2>
    5560:	00 d0       	rcall	.+0      	; 0x5562 <nicRegDump+0xb4>
    5562:	00 d0       	rcall	.+0      	; 0x5564 <nicRegDump+0xb6>
    5564:	ed b7       	in	r30, 0x3d	; 61
    5566:	fe b7       	in	r31, 0x3e	; 62
    5568:	31 96       	adiw	r30, 0x01	; 1
    556a:	ad b7       	in	r26, 0x3d	; 61
    556c:	be b7       	in	r27, 0x3e	; 62
    556e:	12 96       	adiw	r26, 0x02	; 2
    5570:	1c 93       	st	X, r17
    5572:	0e 93       	st	-X, r16
    5574:	11 97       	sbiw	r26, 0x01	; 1
    5576:	20 ee       	ldi	r18, 0xE0	; 224
    5578:	3b e0       	ldi	r19, 0x0B	; 11
    557a:	33 83       	std	Z+3, r19	; 0x03
    557c:	22 83       	std	Z+2, r18	; 0x02
    557e:	84 83       	std	Z+4, r24	; 0x04
    5580:	15 82       	std	Z+5, r1	; 0x05
    5582:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5586:	ed b7       	in	r30, 0x3d	; 61
    5588:	fe b7       	in	r31, 0x3e	; 62
    558a:	36 96       	adiw	r30, 0x06	; 6
    558c:	0f b6       	in	r0, 0x3f	; 63
    558e:	f8 94       	cli
    5590:	fe bf       	out	0x3e, r31	; 62
    5592:	0f be       	out	0x3f, r0	; 63
    5594:	ed bf       	out	0x3d, r30	; 61
    5596:	82 ee       	ldi	r24, 0xE2	; 226
    5598:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    559c:	00 d0       	rcall	.+0      	; 0x559e <nicRegDump+0xf0>
    559e:	00 d0       	rcall	.+0      	; 0x55a0 <nicRegDump+0xf2>
    55a0:	00 d0       	rcall	.+0      	; 0x55a2 <nicRegDump+0xf4>
    55a2:	ed b7       	in	r30, 0x3d	; 61
    55a4:	fe b7       	in	r31, 0x3e	; 62
    55a6:	31 96       	adiw	r30, 0x01	; 1
    55a8:	ad b7       	in	r26, 0x3d	; 61
    55aa:	be b7       	in	r27, 0x3e	; 62
    55ac:	12 96       	adiw	r26, 0x02	; 2
    55ae:	1c 93       	st	X, r17
    55b0:	0e 93       	st	-X, r16
    55b2:	11 97       	sbiw	r26, 0x01	; 1
    55b4:	21 ed       	ldi	r18, 0xD1	; 209
    55b6:	3b e0       	ldi	r19, 0x0B	; 11
    55b8:	33 83       	std	Z+3, r19	; 0x03
    55ba:	22 83       	std	Z+2, r18	; 0x02
    55bc:	84 83       	std	Z+4, r24	; 0x04
    55be:	15 82       	std	Z+5, r1	; 0x05
    55c0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    55c4:	ed b7       	in	r30, 0x3d	; 61
    55c6:	fe b7       	in	r31, 0x3e	; 62
    55c8:	36 96       	adiw	r30, 0x06	; 6
    55ca:	0f b6       	in	r0, 0x3f	; 63
    55cc:	f8 94       	cli
    55ce:	fe bf       	out	0x3e, r31	; 62
    55d0:	0f be       	out	0x3f, r0	; 63
    55d2:	ed bf       	out	0x3d, r30	; 61
    55d4:	85 ee       	ldi	r24, 0xE5	; 229
    55d6:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    55da:	00 d0       	rcall	.+0      	; 0x55dc <nicRegDump+0x12e>
    55dc:	00 d0       	rcall	.+0      	; 0x55de <nicRegDump+0x130>
    55de:	00 d0       	rcall	.+0      	; 0x55e0 <nicRegDump+0x132>
    55e0:	ed b7       	in	r30, 0x3d	; 61
    55e2:	fe b7       	in	r31, 0x3e	; 62
    55e4:	31 96       	adiw	r30, 0x01	; 1
    55e6:	ad b7       	in	r26, 0x3d	; 61
    55e8:	be b7       	in	r27, 0x3e	; 62
    55ea:	12 96       	adiw	r26, 0x02	; 2
    55ec:	1c 93       	st	X, r17
    55ee:	0e 93       	st	-X, r16
    55f0:	11 97       	sbiw	r26, 0x01	; 1
    55f2:	22 ec       	ldi	r18, 0xC2	; 194
    55f4:	3b e0       	ldi	r19, 0x0B	; 11
    55f6:	33 83       	std	Z+3, r19	; 0x03
    55f8:	22 83       	std	Z+2, r18	; 0x02
    55fa:	84 83       	std	Z+4, r24	; 0x04
    55fc:	15 82       	std	Z+5, r1	; 0x05
    55fe:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5602:	ed b7       	in	r30, 0x3d	; 61
    5604:	fe b7       	in	r31, 0x3e	; 62
    5606:	36 96       	adiw	r30, 0x06	; 6
    5608:	0f b6       	in	r0, 0x3f	; 63
    560a:	f8 94       	cli
    560c:	fe bf       	out	0x3e, r31	; 62
    560e:	0f be       	out	0x3f, r0	; 63
    5610:	ed bf       	out	0x3d, r30	; 61
    5612:	84 ee       	ldi	r24, 0xE4	; 228
    5614:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5618:	00 d0       	rcall	.+0      	; 0x561a <nicRegDump+0x16c>
    561a:	00 d0       	rcall	.+0      	; 0x561c <nicRegDump+0x16e>
    561c:	00 d0       	rcall	.+0      	; 0x561e <nicRegDump+0x170>
    561e:	ed b7       	in	r30, 0x3d	; 61
    5620:	fe b7       	in	r31, 0x3e	; 62
    5622:	31 96       	adiw	r30, 0x01	; 1
    5624:	ad b7       	in	r26, 0x3d	; 61
    5626:	be b7       	in	r27, 0x3e	; 62
    5628:	12 96       	adiw	r26, 0x02	; 2
    562a:	1c 93       	st	X, r17
    562c:	0e 93       	st	-X, r16
    562e:	11 97       	sbiw	r26, 0x01	; 1
    5630:	23 eb       	ldi	r18, 0xB3	; 179
    5632:	3b e0       	ldi	r19, 0x0B	; 11
    5634:	33 83       	std	Z+3, r19	; 0x03
    5636:	22 83       	std	Z+2, r18	; 0x02
    5638:	84 83       	std	Z+4, r24	; 0x04
    563a:	15 82       	std	Z+5, r1	; 0x05
    563c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5640:	ed b7       	in	r30, 0x3d	; 61
    5642:	fe b7       	in	r31, 0x3e	; 62
    5644:	36 96       	adiw	r30, 0x06	; 6
    5646:	0f b6       	in	r0, 0x3f	; 63
    5648:	f8 94       	cli
    564a:	fe bf       	out	0x3e, r31	; 62
    564c:	0f be       	out	0x3f, r0	; 63
    564e:	ed bf       	out	0x3d, r30	; 61
    5650:	1f 91       	pop	r17
    5652:	0f 91       	pop	r16
    5654:	08 95       	ret

00005656 <nicGetMacAddress>:
    5656:	0f 93       	push	r16
    5658:	1f 93       	push	r17
    565a:	8c 01       	movw	r16, r24
    565c:	81 ee       	ldi	r24, 0xE1	; 225
    565e:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5662:	f8 01       	movw	r30, r16
    5664:	85 83       	std	Z+5, r24	; 0x05
    5666:	80 ee       	ldi	r24, 0xE0	; 224
    5668:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    566c:	f8 01       	movw	r30, r16
    566e:	84 83       	std	Z+4, r24	; 0x04
    5670:	83 ee       	ldi	r24, 0xE3	; 227
    5672:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5676:	f8 01       	movw	r30, r16
    5678:	83 83       	std	Z+3, r24	; 0x03
    567a:	82 ee       	ldi	r24, 0xE2	; 226
    567c:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5680:	f8 01       	movw	r30, r16
    5682:	82 83       	std	Z+2, r24	; 0x02
    5684:	85 ee       	ldi	r24, 0xE5	; 229
    5686:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    568a:	f8 01       	movw	r30, r16
    568c:	81 83       	std	Z+1, r24	; 0x01
    568e:	84 ee       	ldi	r24, 0xE4	; 228
    5690:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5694:	f8 01       	movw	r30, r16
    5696:	80 83       	st	Z, r24
    5698:	1f 91       	pop	r17
    569a:	0f 91       	pop	r16
    569c:	08 95       	ret

0000569e <enc28j60hasRxPkt>:
}

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
  if( enc28j60Read(EPKTCNT) ==0 )
    569e:	89 e3       	ldi	r24, 0x39	; 57
    56a0:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    56a4:	81 11       	cpse	r24, r1
    56a6:	81 e0       	ldi	r24, 0x01	; 1
  {
    return(0);
  }
  return(1);
}
    56a8:	08 95       	ret

000056aa <enc28j60getrev>:
}

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
  return(enc28j60Read(EREVID));
    56aa:	82 e7       	ldi	r24, 0x72	; 114
    56ac:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
}
    56b0:	08 95       	ret

000056b2 <nicPoll>:
    56b2:	cf 92       	push	r12
    56b4:	df 92       	push	r13
    56b6:	ef 92       	push	r14
    56b8:	ff 92       	push	r15
    56ba:	0f 93       	push	r16
    56bc:	1f 93       	push	r17
    56be:	cf 93       	push	r28
    56c0:	df 93       	push	r29
    56c2:	89 e3       	ldi	r24, 0x39	; 57
    56c4:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    56c8:	88 23       	and	r24, r24
    56ca:	19 f4       	brne	.+6      	; 0x56d2 <nicPoll+0x20>
    56cc:	ee 24       	eor	r14, r14
    56ce:	ff 24       	eor	r15, r15
    56d0:	9d c0       	rjmp	.+314    	; 0x580c <nicPoll+0x15a>
    56d2:	80 e0       	ldi	r24, 0x00	; 0
    56d4:	60 91 91 01 	lds	r22, 0x0191
    56d8:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    56dc:	60 91 92 01 	lds	r22, 0x0192
    56e0:	81 e0       	ldi	r24, 0x01	; 1
    56e2:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    56e6:	8a e3       	ldi	r24, 0x3A	; 58
    56e8:	60 e0       	ldi	r22, 0x00	; 0
    56ea:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
    56ee:	08 2f       	mov	r16, r24
    56f0:	10 e0       	ldi	r17, 0x00	; 0
    56f2:	10 93 92 01 	sts	0x0192, r17
    56f6:	00 93 91 01 	sts	0x0191, r16
    56fa:	8a e3       	ldi	r24, 0x3A	; 58
    56fc:	60 e0       	ldi	r22, 0x00	; 0
    56fe:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
    5702:	38 2f       	mov	r19, r24
    5704:	20 e0       	ldi	r18, 0x00	; 0
    5706:	20 2b       	or	r18, r16
    5708:	31 2b       	or	r19, r17
    570a:	30 93 92 01 	sts	0x0192, r19
    570e:	20 93 91 01 	sts	0x0191, r18
    5712:	8a e3       	ldi	r24, 0x3A	; 58
    5714:	60 e0       	ldi	r22, 0x00	; 0
    5716:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
    571a:	f8 2e       	mov	r15, r24
    571c:	8a e3       	ldi	r24, 0x3A	; 58
    571e:	60 e0       	ldi	r22, 0x00	; 0
    5720:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
    5724:	d8 2e       	mov	r13, r24
    5726:	8a e3       	ldi	r24, 0x3A	; 58
    5728:	60 e0       	ldi	r22, 0x00	; 0
    572a:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
    572e:	08 2f       	mov	r16, r24
    5730:	10 e0       	ldi	r17, 0x00	; 0
    5732:	8a e3       	ldi	r24, 0x3A	; 58
    5734:	60 e0       	ldi	r22, 0x00	; 0
    5736:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
    573a:	40 91 7e 0e 	lds	r20, 0x0E7E
    573e:	50 91 7f 0e 	lds	r21, 0x0E7F
    5742:	38 2f       	mov	r19, r24
    5744:	20 e0       	ldi	r18, 0x00	; 0
    5746:	20 2b       	or	r18, r16
    5748:	31 2b       	or	r19, r17
    574a:	27 fd       	sbrc	r18, 7
    574c:	03 c0       	rjmp	.+6      	; 0x5754 <nicPoll+0xa2>
    574e:	ee 24       	eor	r14, r14
    5750:	ff 24       	eor	r15, r15
    5752:	2f c0       	rjmp	.+94     	; 0x57b2 <nicPoll+0x100>
    5754:	ef 2c       	mov	r14, r15
    5756:	ff 24       	eor	r15, r15
    5758:	9d 2d       	mov	r25, r13
    575a:	80 e0       	ldi	r24, 0x00	; 0
    575c:	e8 2a       	or	r14, r24
    575e:	f9 2a       	or	r15, r25
    5760:	ca 01       	movw	r24, r20
    5762:	01 97       	sbiw	r24, 0x01	; 1
    5764:	2c ef       	ldi	r18, 0xFC	; 252
    5766:	3f ef       	ldi	r19, 0xFF	; 255
    5768:	e2 0e       	add	r14, r18
    576a:	f3 1e       	adc	r15, r19
    576c:	8e 15       	cp	r24, r14
    576e:	9f 05       	cpc	r25, r15
    5770:	08 f4       	brcc	.+2      	; 0x5774 <nicPoll+0xc2>
    5772:	7c 01       	movw	r14, r24
    5774:	00 91 86 0e 	lds	r16, 0x0E86
    5778:	10 91 87 0e 	lds	r17, 0x0E87
    577c:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
    5780:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <spiEnableEnc28j60>
    5784:	8a e3       	ldi	r24, 0x3A	; 58
    5786:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    578a:	68 01       	movw	r12, r16
    578c:	e7 01       	movw	r28, r14
    578e:	07 c0       	rjmp	.+14     	; 0x579e <nicPoll+0xec>
    5790:	21 97       	sbiw	r28, 0x01	; 1
    5792:	80 e0       	ldi	r24, 0x00	; 0
    5794:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    5798:	f6 01       	movw	r30, r12
    579a:	81 93       	st	Z+, r24
    579c:	6f 01       	movw	r12, r30
    579e:	20 97       	sbiw	r28, 0x00	; 0
    57a0:	b9 f7       	brne	.-18     	; 0x5790 <nicPoll+0xde>
    57a2:	0e 0d       	add	r16, r14
    57a4:	1f 1d       	adc	r17, r15
    57a6:	f8 01       	movw	r30, r16
    57a8:	10 82       	st	Z, r1
    57aa:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <spiDisableEnc28j60>
    57ae:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
    57b2:	8c e0       	ldi	r24, 0x0C	; 12
    57b4:	60 91 91 01 	lds	r22, 0x0191
    57b8:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    57bc:	60 91 92 01 	lds	r22, 0x0192
    57c0:	8d e0       	ldi	r24, 0x0D	; 13
    57c2:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    57c6:	60 91 91 01 	lds	r22, 0x0191
    57ca:	70 91 92 01 	lds	r23, 0x0192
    57ce:	cb 01       	movw	r24, r22
    57d0:	01 97       	sbiw	r24, 0x01	; 1
    57d2:	8f 5f       	subi	r24, 0xFF	; 255
    57d4:	99 41       	sbci	r25, 0x19	; 25
    57d6:	38 f0       	brcs	.+14     	; 0x57e6 <nicPoll+0x134>
    57d8:	8c e0       	ldi	r24, 0x0C	; 12
    57da:	6e ef       	ldi	r22, 0xFE	; 254
    57dc:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    57e0:	8d e0       	ldi	r24, 0x0D	; 13
    57e2:	69 e1       	ldi	r22, 0x19	; 25
    57e4:	0c c0       	rjmp	.+24     	; 0x57fe <nicPoll+0x14c>
    57e6:	61 50       	subi	r22, 0x01	; 1
    57e8:	8c e0       	ldi	r24, 0x0C	; 12
    57ea:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    57ee:	20 91 91 01 	lds	r18, 0x0191
    57f2:	30 91 92 01 	lds	r19, 0x0192
    57f6:	21 50       	subi	r18, 0x01	; 1
    57f8:	30 40       	sbci	r19, 0x00	; 0
    57fa:	8d e0       	ldi	r24, 0x0D	; 13
    57fc:	63 2f       	mov	r22, r19
    57fe:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5802:	80 e8       	ldi	r24, 0x80	; 128
    5804:	6e e1       	ldi	r22, 0x1E	; 30
    5806:	40 e4       	ldi	r20, 0x40	; 64
    5808:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    580c:	c7 01       	movw	r24, r14
    580e:	df 91       	pop	r29
    5810:	cf 91       	pop	r28
    5812:	1f 91       	pop	r17
    5814:	0f 91       	pop	r16
    5816:	ff 90       	pop	r15
    5818:	ef 90       	pop	r14
    581a:	df 90       	pop	r13
    581c:	cf 90       	pop	r12
    581e:	08 95       	ret

00005820 <nicSend>:
    5820:	0f 93       	push	r16
    5822:	1f 93       	push	r17
    5824:	cf 93       	push	r28
    5826:	df 93       	push	r29
    5828:	8c 01       	movw	r16, r24
    582a:	13 c0       	rjmp	.+38     	; 0x5852 <nicSend+0x32>
    582c:	8c e1       	ldi	r24, 0x1C	; 28
    582e:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5832:	81 ff       	sbrs	r24, 1
    5834:	0a c0       	rjmp	.+20     	; 0x584a <nicSend+0x2a>
    5836:	80 e8       	ldi	r24, 0x80	; 128
    5838:	6f e1       	ldi	r22, 0x1F	; 31
    583a:	40 e8       	ldi	r20, 0x80	; 128
    583c:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    5840:	80 ea       	ldi	r24, 0xA0	; 160
    5842:	6f e1       	ldi	r22, 0x1F	; 31
    5844:	40 e8       	ldi	r20, 0x80	; 128
    5846:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    584a:	80 e0       	ldi	r24, 0x00	; 0
    584c:	90 e0       	ldi	r25, 0x00	; 0
    584e:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    5852:	80 e0       	ldi	r24, 0x00	; 0
    5854:	6f e1       	ldi	r22, 0x1F	; 31
    5856:	0e 94 2e 2a 	call	0x545c	; 0x545c <enc28j60ReadOp>
    585a:	83 fd       	sbrc	r24, 3
    585c:	e7 cf       	rjmp	.-50     	; 0x582c <nicSend+0xc>
    585e:	82 e0       	ldi	r24, 0x02	; 2
    5860:	6f ef       	ldi	r22, 0xFF	; 255
    5862:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5866:	83 e0       	ldi	r24, 0x03	; 3
    5868:	69 e1       	ldi	r22, 0x19	; 25
    586a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    586e:	60 2f       	mov	r22, r16
    5870:	61 50       	subi	r22, 0x01	; 1
    5872:	86 e0       	ldi	r24, 0x06	; 6
    5874:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5878:	98 01       	movw	r18, r16
    587a:	21 50       	subi	r18, 0x01	; 1
    587c:	36 4e       	sbci	r19, 0xE6	; 230
    587e:	87 e0       	ldi	r24, 0x07	; 7
    5880:	63 2f       	mov	r22, r19
    5882:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5886:	8a e7       	ldi	r24, 0x7A	; 122
    5888:	60 e0       	ldi	r22, 0x00	; 0
    588a:	40 e0       	ldi	r20, 0x00	; 0
    588c:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    5890:	c0 91 86 0e 	lds	r28, 0x0E86
    5894:	d0 91 87 0e 	lds	r29, 0x0E87
    5898:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <spiTake>
    589c:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <spiEnableEnc28j60>
    58a0:	8a e7       	ldi	r24, 0x7A	; 122
    58a2:	03 c0       	rjmp	.+6      	; 0x58aa <nicSend+0x8a>
    58a4:	01 50       	subi	r16, 0x01	; 1
    58a6:	10 40       	sbci	r17, 0x00	; 0
    58a8:	89 91       	ld	r24, Y+
    58aa:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <spiSend>
    58ae:	01 15       	cp	r16, r1
    58b0:	11 05       	cpc	r17, r1
    58b2:	c1 f7       	brne	.-16     	; 0x58a4 <nicSend+0x84>
    58b4:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <spiDisableEnc28j60>
    58b8:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <spiGive>
    58bc:	80 e8       	ldi	r24, 0x80	; 128
    58be:	6f e1       	ldi	r22, 0x1F	; 31
    58c0:	48 e0       	ldi	r20, 0x08	; 8
    58c2:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    58c6:	df 91       	pop	r29
    58c8:	cf 91       	pop	r28
    58ca:	1f 91       	pop	r17
    58cc:	0f 91       	pop	r16
    58ce:	08 95       	ret

000058d0 <enc28j60linkup>:

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
  // Set the right address and start the register read operation
  enc28j60Write(MIREGADR, address);
    58d0:	84 ed       	ldi	r24, 0xD4	; 212
    58d2:	61 e1       	ldi	r22, 0x11	; 17
    58d4:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
  enc28j60Write(MICMD, MICMD_MIIRD);
    58d8:	82 ed       	ldi	r24, 0xD2	; 210
    58da:	61 e0       	ldi	r22, 0x01	; 1
    58dc:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie
    58e0:	80 e0       	ldi	r24, 0x00	; 0
    58e2:	90 e0       	ldi	r25, 0x00	; 0
    58e4:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
  enc28j60Write(MICMD, MICMD_MIIRD);
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    58e8:	8a ee       	ldi	r24, 0xEA	; 234
    58ea:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    58ee:	80 fd       	sbrc	r24, 0
    58f0:	f7 cf       	rjmp	.-18     	; 0x58e0 <enc28j60linkup+0x10>
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie

  // reset reading bit
  enc28j60Write(MICMD, 0x00);
    58f2:	82 ed       	ldi	r24, 0xD2	; 210
    58f4:	60 e0       	ldi	r22, 0x00	; 0
    58f6:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>

  return (enc28j60Read(MIRDH));
    58fa:	89 ed       	ldi	r24, 0xD9	; 217
    58fc:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5900:	81 11       	cpse	r24, r1
    5902:	81 e0       	ldi	r24, 0x01	; 1
// link status
uint8_t enc28j60linkup(void)
{
  // bit 10 (= bit 3 in upper reg)
  return(enc28j60PhyReadH(PHSTAT2) && 4);
}
    5904:	08 95       	ret

00005906 <enc28j60PhyWrite>:
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    5906:	0f 93       	push	r16
    5908:	1f 93       	push	r17
    590a:	98 2f       	mov	r25, r24
    590c:	16 2f       	mov	r17, r22
    590e:	07 2f       	mov	r16, r23
  // set the PHY register address
  enc28j60Write(MIREGADR, address);
    5910:	84 ed       	ldi	r24, 0xD4	; 212
    5912:	69 2f       	mov	r22, r25
    5914:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
  // write the PHY data
  enc28j60Write(MIWRL, data);
    5918:	86 ed       	ldi	r24, 0xD6	; 214
    591a:	61 2f       	mov	r22, r17
    591c:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
  enc28j60Write(MIWRH, data>>8);
    5920:	87 ed       	ldi	r24, 0xD7	; 215
    5922:	60 2f       	mov	r22, r16
    5924:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5928:	04 c0       	rjmp	.+8      	; 0x5932 <enc28j60PhyWrite+0x2c>
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
    592a:	80 e0       	ldi	r24, 0x00	; 0
    592c:	90 e0       	ldi	r25, 0x00	; 0
    592e:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
  // write the PHY data
  enc28j60Write(MIWRL, data);
  enc28j60Write(MIWRH, data>>8);
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    5932:	8a ee       	ldi	r24, 0xEA	; 234
    5934:	0e 94 4d 2a 	call	0x549a	; 0x549a <enc28j60Read>
    5938:	80 fd       	sbrc	r24, 0
    593a:	f7 cf       	rjmp	.-18     	; 0x592a <enc28j60PhyWrite+0x24>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
  }
}
    593c:	1f 91       	pop	r17
    593e:	0f 91       	pop	r16
    5940:	08 95       	ret

00005942 <nicMacInit>:
    5942:	85 e0       	ldi	r24, 0x05	; 5
    5944:	90 e0       	ldi	r25, 0x00	; 0
    5946:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    594a:	1a 98       	cbi	0x03, 2	; 3
    594c:	85 e0       	ldi	r24, 0x05	; 5
    594e:	90 e0       	ldi	r25, 0x00	; 0
    5950:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    5954:	1a 9a       	sbi	0x03, 2	; 3
    5956:	85 e0       	ldi	r24, 0x05	; 5
    5958:	90 e0       	ldi	r25, 0x00	; 0
    595a:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    595e:	10 92 92 01 	sts	0x0192, r1
    5962:	10 92 91 01 	sts	0x0191, r1
    5966:	88 e0       	ldi	r24, 0x08	; 8
    5968:	60 e0       	ldi	r22, 0x00	; 0
    596a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    596e:	89 e0       	ldi	r24, 0x09	; 9
    5970:	60 e0       	ldi	r22, 0x00	; 0
    5972:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5976:	8c e0       	ldi	r24, 0x0C	; 12
    5978:	60 e0       	ldi	r22, 0x00	; 0
    597a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    597e:	8d e0       	ldi	r24, 0x0D	; 13
    5980:	60 e0       	ldi	r22, 0x00	; 0
    5982:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5986:	8a e0       	ldi	r24, 0x0A	; 10
    5988:	6e ef       	ldi	r22, 0xFE	; 254
    598a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    598e:	8b e0       	ldi	r24, 0x0B	; 11
    5990:	69 e1       	ldi	r22, 0x19	; 25
    5992:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5996:	84 e0       	ldi	r24, 0x04	; 4
    5998:	6f ef       	ldi	r22, 0xFF	; 255
    599a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    599e:	85 e0       	ldi	r24, 0x05	; 5
    59a0:	69 e1       	ldi	r22, 0x19	; 25
    59a2:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59a6:	86 e0       	ldi	r24, 0x06	; 6
    59a8:	6f ef       	ldi	r22, 0xFF	; 255
    59aa:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59ae:	87 e0       	ldi	r24, 0x07	; 7
    59b0:	6f e1       	ldi	r22, 0x1F	; 31
    59b2:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59b6:	88 e3       	ldi	r24, 0x38	; 56
    59b8:	60 eb       	ldi	r22, 0xB0	; 176
    59ba:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59be:	88 e2       	ldi	r24, 0x28	; 40
    59c0:	6f e3       	ldi	r22, 0x3F	; 63
    59c2:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59c6:	89 e2       	ldi	r24, 0x29	; 41
    59c8:	60 e3       	ldi	r22, 0x30	; 48
    59ca:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59ce:	80 e3       	ldi	r24, 0x30	; 48
    59d0:	69 ef       	ldi	r22, 0xF9	; 249
    59d2:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59d6:	81 e3       	ldi	r24, 0x31	; 49
    59d8:	67 ef       	ldi	r22, 0xF7	; 247
    59da:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59de:	80 ec       	ldi	r24, 0xC0	; 192
    59e0:	6d e0       	ldi	r22, 0x0D	; 13
    59e2:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59e6:	81 ec       	ldi	r24, 0xC1	; 193
    59e8:	60 e0       	ldi	r22, 0x00	; 0
    59ea:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    59ee:	80 e8       	ldi	r24, 0x80	; 128
    59f0:	62 ec       	ldi	r22, 0xC2	; 194
    59f2:	42 e3       	ldi	r20, 0x32	; 50
    59f4:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    59f8:	86 ec       	ldi	r24, 0xC6	; 198
    59fa:	62 e1       	ldi	r22, 0x12	; 18
    59fc:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5a00:	87 ec       	ldi	r24, 0xC7	; 199
    5a02:	6c e0       	ldi	r22, 0x0C	; 12
    5a04:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5a08:	84 ec       	ldi	r24, 0xC4	; 196
    5a0a:	62 e1       	ldi	r22, 0x12	; 18
    5a0c:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5a10:	8a ec       	ldi	r24, 0xCA	; 202
    5a12:	6c ed       	ldi	r22, 0xDC	; 220
    5a14:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5a18:	8b ec       	ldi	r24, 0xCB	; 203
    5a1a:	65 e0       	ldi	r22, 0x05	; 5
    5a1c:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <enc28j60Write>
    5a20:	80 e8       	ldi	r24, 0x80	; 128
    5a22:	9e e0       	ldi	r25, 0x0E	; 14
    5a24:	0e 94 0a 2a 	call	0x5414	; 0x5414 <nicSetMacAddress>
    5a28:	80 e1       	ldi	r24, 0x10	; 16
    5a2a:	60 e0       	ldi	r22, 0x00	; 0
    5a2c:	71 e0       	ldi	r23, 0x01	; 1
    5a2e:	0e 94 83 2c 	call	0x5906	; 0x5906 <enc28j60PhyWrite>
    5a32:	8f e1       	ldi	r24, 0x1F	; 31
    5a34:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <enc28j60SetBank>
    5a38:	80 e8       	ldi	r24, 0x80	; 128
    5a3a:	6b e1       	ldi	r22, 0x1B	; 27
    5a3c:	40 ec       	ldi	r20, 0xC0	; 192
    5a3e:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    5a42:	80 e8       	ldi	r24, 0x80	; 128
    5a44:	6f e1       	ldi	r22, 0x1F	; 31
    5a46:	44 e0       	ldi	r20, 0x04	; 4
    5a48:	0e 94 be 29 	call	0x537c	; 0x537c <enc28j60WriteOp>
    5a4c:	85 e0       	ldi	r24, 0x05	; 5
    5a4e:	90 e0       	ldi	r25, 0x00	; 0
    5a50:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    5a54:	84 e1       	ldi	r24, 0x14	; 20
    5a56:	66 e7       	ldi	r22, 0x76	; 118
    5a58:	74 e0       	ldi	r23, 0x04	; 4
    5a5a:	0e 94 83 2c 	call	0x5906	; 0x5906 <enc28j60PhyWrite>
    5a5e:	82 e0       	ldi	r24, 0x02	; 2
    5a60:	90 e0       	ldi	r25, 0x00	; 0
    5a62:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    5a66:	08 95       	ret

00005a68 <initQueueStream>:

static int streamQueueOutputFun(char c, FILE *ostream);
static int streamQueueInputFun(FILE *istream);

void initQueueStream(FILE *stream, streamBuffers_t *buffer, xQueueHandle Rx, xQueueHandle Tx)
{
    5a68:	fc 01       	movw	r30, r24
    5a6a:	db 01       	movw	r26, r22
  fdev_setup_stream(stream, streamQueueOutputFun, streamQueueInputFun, _FDEV_SETUP_RW);
    5a6c:	87 e6       	ldi	r24, 0x67	; 103
    5a6e:	9d e2       	ldi	r25, 0x2D	; 45
    5a70:	91 87       	std	Z+9, r25	; 0x09
    5a72:	80 87       	std	Z+8, r24	; 0x08
    5a74:	8a e4       	ldi	r24, 0x4A	; 74
    5a76:	9d e2       	ldi	r25, 0x2D	; 45
    5a78:	93 87       	std	Z+11, r25	; 0x0b
    5a7a:	82 87       	std	Z+10, r24	; 0x0a
    5a7c:	83 e0       	ldi	r24, 0x03	; 3
    5a7e:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, (void *)buffer);
    5a80:	75 87       	std	Z+13, r23	; 0x0d
    5a82:	64 87       	std	Z+12, r22	; 0x0c
  buffer->Rx = Rx;
    5a84:	11 96       	adiw	r26, 0x01	; 1
    5a86:	5c 93       	st	X, r21
    5a88:	4e 93       	st	-X, r20
  buffer->Tx = Tx;
    5a8a:	13 96       	adiw	r26, 0x03	; 3
    5a8c:	3c 93       	st	X, r19
    5a8e:	2e 93       	st	-X, r18
    5a90:	12 97       	sbiw	r26, 0x02	; 2
  return;
}
    5a92:	08 95       	ret

00005a94 <streamQueueInputFun>:
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
  return 0;
}

static int streamQueueInputFun(FILE *istream)
{
    5a94:	df 93       	push	r29
    5a96:	cf 93       	push	r28
    5a98:	0f 92       	push	r0
    5a9a:	cd b7       	in	r28, 0x3d	; 61
    5a9c:	de b7       	in	r29, 0x3e	; 62
  char c;
  streamBuffers_t *strBuf = (streamBuffers_t *) istream->udata;
  xQueueReceive(strBuf->Rx, &c, portMAX_DELAY);
    5a9e:	dc 01       	movw	r26, r24
    5aa0:	1c 96       	adiw	r26, 0x0c	; 12
    5aa2:	ed 91       	ld	r30, X+
    5aa4:	fc 91       	ld	r31, X
    5aa6:	1d 97       	sbiw	r26, 0x0d	; 13
    5aa8:	80 81       	ld	r24, Z
    5aaa:	91 81       	ldd	r25, Z+1	; 0x01
    5aac:	be 01       	movw	r22, r28
    5aae:	6f 5f       	subi	r22, 0xFF	; 255
    5ab0:	7f 4f       	sbci	r23, 0xFF	; 255
    5ab2:	4f ef       	ldi	r20, 0xFF	; 255
    5ab4:	5f ef       	ldi	r21, 0xFF	; 255
    5ab6:	20 e0       	ldi	r18, 0x00	; 0
    5ab8:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    5abc:	29 81       	ldd	r18, Y+1	; 0x01
    5abe:	33 27       	eor	r19, r19
    5ac0:	27 fd       	sbrc	r18, 7
    5ac2:	30 95       	com	r19
  return c;
}
    5ac4:	c9 01       	movw	r24, r18
    5ac6:	0f 90       	pop	r0
    5ac8:	cf 91       	pop	r28
    5aca:	df 91       	pop	r29
    5acc:	08 95       	ret

00005ace <streamQueueOutputFun>:
  buffer->Tx = Tx;
  return;
}

static int streamQueueOutputFun(char c, FILE *ostream)
{
    5ace:	df 93       	push	r29
    5ad0:	cf 93       	push	r28
    5ad2:	0f 92       	push	r0
    5ad4:	cd b7       	in	r28, 0x3d	; 61
    5ad6:	de b7       	in	r29, 0x3e	; 62
    5ad8:	89 83       	std	Y+1, r24	; 0x01
    5ada:	fb 01       	movw	r30, r22
/*  if (xQueueSend( strBuf->Tx, &c, strBuf->tx_timeout))
  {
    return EOF;
  }
  else*/
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
    5adc:	04 84       	ldd	r0, Z+12	; 0x0c
    5ade:	f5 85       	ldd	r31, Z+13	; 0x0d
    5ae0:	e0 2d       	mov	r30, r0
    5ae2:	82 81       	ldd	r24, Z+2	; 0x02
    5ae4:	93 81       	ldd	r25, Z+3	; 0x03
    5ae6:	be 01       	movw	r22, r28
    5ae8:	6f 5f       	subi	r22, 0xFF	; 255
    5aea:	7f 4f       	sbci	r23, 0xFF	; 255
    5aec:	4f ef       	ldi	r20, 0xFF	; 255
    5aee:	5f ef       	ldi	r21, 0xFF	; 255
    5af0:	20 e0       	ldi	r18, 0x00	; 0
    5af2:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>
  return 0;
}
    5af6:	80 e0       	ldi	r24, 0x00	; 0
    5af8:	90 e0       	ldi	r25, 0x00	; 0
    5afa:	0f 90       	pop	r0
    5afc:	cf 91       	pop	r28
    5afe:	df 91       	pop	r29
    5b00:	08 95       	ret
    5b02:	08 95       	ret
    5b04:	08 95       	ret
    5b06:	80 e0       	ldi	r24, 0x00	; 0
    5b08:	90 e0       	ldi	r25, 0x00	; 0
    5b0a:	08 95       	ret
    5b0c:	00 d0       	rcall	.+0      	; 0x5b0e <streamQueueOutputFun+0x40>
    5b0e:	00 d0       	rcall	.+0      	; 0x5b10 <streamQueueOutputFun+0x42>
    5b10:	ed b7       	in	r30, 0x3d	; 61
    5b12:	fe b7       	in	r31, 0x3e	; 62
    5b14:	92 83       	std	Z+2, r25	; 0x02
    5b16:	81 83       	std	Z+1, r24	; 0x01
    5b18:	88 e2       	ldi	r24, 0x28	; 40
    5b1a:	9c e0       	ldi	r25, 0x0C	; 12
    5b1c:	94 83       	std	Z+4, r25	; 0x04
    5b1e:	83 83       	std	Z+3, r24	; 0x03
    5b20:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5b24:	0f 90       	pop	r0
    5b26:	0f 90       	pop	r0
    5b28:	0f 90       	pop	r0
    5b2a:	0f 90       	pop	r0
    5b2c:	08 95       	ret
    5b2e:	bc 01       	movw	r22, r24
    5b30:	80 e8       	ldi	r24, 0x80	; 128
    5b32:	9e e0       	ldi	r25, 0x0E	; 14
    5b34:	46 e0       	ldi	r20, 0x06	; 6
    5b36:	50 e0       	ldi	r21, 0x00	; 0
    5b38:	0e 94 75 59 	call	0xb2ea	; 0xb2ea <strncpy>
    5b3c:	0e 94 a1 2c 	call	0x5942	; 0x5942 <nicMacInit>
    5b40:	08 95       	ret
    5b42:	60 e8       	ldi	r22, 0x80	; 128
    5b44:	7e e0       	ldi	r23, 0x0E	; 14
    5b46:	46 e0       	ldi	r20, 0x06	; 6
    5b48:	50 e0       	ldi	r21, 0x00	; 0
    5b4a:	0e 94 75 59 	call	0xb2ea	; 0xb2ea <strncpy>
    5b4e:	08 95       	ret

00005b50 <nicInit>:
unsigned int nicPoll(void)                                       { return 0; }


static void nicBufferInit(void)
{
  nicState.bufferSize  = NETWORK_STACK_BUF_SIZE;
    5b50:	20 e0       	ldi	r18, 0x00	; 0
    5b52:	36 e0       	ldi	r19, 0x06	; 6
    5b54:	30 93 7f 0e 	sts	0x0E7F, r19
    5b58:	20 93 7e 0e 	sts	0x0E7E, r18
  nicState.layer2.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR);
    5b5c:	e0 e0       	ldi	r30, 0x00	; 0
    5b5e:	fa e7       	ldi	r31, 0x7A	; 122
    5b60:	f0 93 87 0e 	sts	0x0E87, r31
    5b64:	e0 93 86 0e 	sts	0x0E86, r30
  nicState.layer3.ip   = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
    5b68:	8e e0       	ldi	r24, 0x0E	; 14
    5b6a:	9a e7       	ldi	r25, 0x7A	; 122
    5b6c:	90 93 89 0e 	sts	0x0E89, r25
    5b70:	80 93 88 0e 	sts	0x0E88, r24
  nicState.layer4.icmp = (struct  netIcmpHeader *)(NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN + IP_HEADER_LEN);
    5b74:	82 e2       	ldi	r24, 0x22	; 34
    5b76:	9a e7       	ldi	r25, 0x7A	; 122
    5b78:	90 93 8b 0e 	sts	0x0E8B, r25
    5b7c:	80 93 8a 0e 	sts	0x0E8A, r24
  memset(nicState.layer2.buf, 0, nicState.bufferSize);
    5b80:	df 01       	movw	r26, r30
    5b82:	c9 01       	movw	r24, r18
    5b84:	1d 92       	st	X+, r1
    5b86:	01 97       	sbiw	r24, 0x01	; 1
    5b88:	e9 f7       	brne	.-6      	; 0x5b84 <nicInit+0x34>
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
    5b8a:	80 e8       	ldi	r24, 0x80	; 128
    5b8c:	9e e0       	ldi	r25, 0x0E	; 14
    5b8e:	68 e1       	ldi	r22, 0x18	; 24
    5b90:	70 e0       	ldi	r23, 0x00	; 0
    5b92:	46 e0       	ldi	r20, 0x06	; 6
    5b94:	50 e0       	ldi	r21, 0x00	; 0
    5b96:	0e 94 ae 5c 	call	0xb95c	; 0xb95c <__eerd_block_m128>
}

void nicInit()
{
  nicBufferInit();
  nicMacInit();
    5b9a:	0e 94 a1 2c 	call	0x5942	; 0x5942 <nicMacInit>
}
    5b9e:	08 95       	ret

00005ba0 <saveNic>:
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
}

void saveNic(void)
{
  eeprom_update_block(&nicState.mac.addr, mymac_eep, 6);
    5ba0:	80 e8       	ldi	r24, 0x80	; 128
    5ba2:	9e e0       	ldi	r25, 0x0E	; 14
    5ba4:	68 e1       	ldi	r22, 0x18	; 24
    5ba6:	70 e0       	ldi	r23, 0x00	; 0
    5ba8:	46 e0       	ldi	r20, 0x06	; 6
    5baa:	50 e0       	ldi	r21, 0x00	; 0
    5bac:	0e 94 ca 5c 	call	0xb994	; 0xb994 <__eeupd_block_m128>
}
    5bb0:	08 95       	ret

00005bb2 <htons>:

#include "net.h"


uint16_t htons(uint16_t val)
{
    5bb2:	28 2f       	mov	r18, r24
  return (val<<8) | (val>>8);
}
    5bb4:	89 2f       	mov	r24, r25
    5bb6:	92 2f       	mov	r25, r18
    5bb8:	08 95       	ret

00005bba <htonl>:

uint32_t htonl(uint32_t val)
{
    5bba:	ef 92       	push	r14
    5bbc:	ff 92       	push	r15
    5bbe:	0f 93       	push	r16
    5bc0:	1f 93       	push	r17
    5bc2:	f6 2e       	mov	r15, r22
    5bc4:	e7 2e       	mov	r14, r23
    5bc6:	00 e0       	ldi	r16, 0x00	; 0
    5bc8:	10 e0       	ldi	r17, 0x00	; 0
    5bca:	87 01       	movw	r16, r14
    5bcc:	ff 24       	eor	r15, r15
    5bce:	ee 24       	eor	r14, r14
    5bd0:	bc 01       	movw	r22, r24
    5bd2:	88 27       	eor	r24, r24
    5bd4:	99 27       	eor	r25, r25
    5bd6:	36 2f       	mov	r19, r22
    5bd8:	27 2f       	mov	r18, r23
    5bda:	40 e0       	ldi	r20, 0x00	; 0
    5bdc:	50 e0       	ldi	r21, 0x00	; 0
    5bde:	e2 2a       	or	r14, r18
    5be0:	f3 2a       	or	r15, r19
    5be2:	04 2b       	or	r16, r20
    5be4:	15 2b       	or	r17, r21
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
}
    5be6:	b7 01       	movw	r22, r14
    5be8:	c8 01       	movw	r24, r16
    5bea:	1f 91       	pop	r17
    5bec:	0f 91       	pop	r16
    5bee:	ff 90       	pop	r15
    5bf0:	ef 90       	pop	r14
    5bf2:	08 95       	ret

00005bf4 <netChecksum>:


uint16_t netChecksum(uint8_t *data, uint16_t len)
{
    5bf4:	0f 93       	push	r16
    5bf6:	1f 93       	push	r17
    5bf8:	cf 93       	push	r28
    5bfa:	df 93       	push	r29
    5bfc:	8c 01       	movw	r16, r24
    5bfe:	ec 01       	movw	r28, r24
    5c00:	fb 01       	movw	r30, r22
    5c02:	20 e0       	ldi	r18, 0x00	; 0
    5c04:	30 e0       	ldi	r19, 0x00	; 0
    5c06:	40 e0       	ldi	r20, 0x00	; 0
    5c08:	50 e0       	ldi	r21, 0x00	; 0
  register uint32_t sum = 0;

  for (;;) 
  {
    if (len < 2)
    5c0a:	e2 30       	cpi	r30, 0x02	; 2
    5c0c:	f1 05       	cpc	r31, r1
    5c0e:	50 f0       	brcs	.+20     	; 0x5c24 <netChecksum+0x30>
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    5c10:	89 91       	ld	r24, Y+
    5c12:	99 91       	ld	r25, Y+
    5c14:	a0 e0       	ldi	r26, 0x00	; 0
    5c16:	b0 e0       	ldi	r27, 0x00	; 0
    5c18:	28 0f       	add	r18, r24
    5c1a:	39 1f       	adc	r19, r25
    5c1c:	4a 1f       	adc	r20, r26
    5c1e:	5b 1f       	adc	r21, r27
    data+=2;
    len -= 2;
    5c20:	32 97       	sbiw	r30, 0x02	; 2
    5c22:	f3 cf       	rjmp	.-26     	; 0x5c0a <netChecksum+0x16>
  }
    5c24:	fb 01       	movw	r30, r22
    5c26:	ee 7f       	andi	r30, 0xFE	; 254
    5c28:	e0 0f       	add	r30, r16
    5c2a:	f1 1f       	adc	r31, r17
  if (len)
    5c2c:	60 ff       	sbrs	r22, 0
    5c2e:	0b c0       	rjmp	.+22     	; 0x5c46 <netChecksum+0x52>
    sum += *(uint8_t *) data;
    5c30:	80 81       	ld	r24, Z
    5c32:	28 0f       	add	r18, r24
    5c34:	31 1d       	adc	r19, r1
    5c36:	41 1d       	adc	r20, r1
    5c38:	51 1d       	adc	r21, r1
    5c3a:	05 c0       	rjmp	.+10     	; 0x5c46 <netChecksum+0x52>

  while ((len = (uint16_t) (sum >> 16)) != 0)
    sum = (uint16_t) sum + len;
    5c3c:	62 0f       	add	r22, r18
    5c3e:	73 1f       	adc	r23, r19
    5c40:	9b 01       	movw	r18, r22
    5c42:	40 e0       	ldi	r20, 0x00	; 0
    5c44:	50 e0       	ldi	r21, 0x00	; 0
    len -= 2;
  }
  if (len)
    sum += *(uint8_t *) data;

  while ((len = (uint16_t) (sum >> 16)) != 0)
    5c46:	ca 01       	movw	r24, r20
    5c48:	aa 27       	eor	r26, r26
    5c4a:	bb 27       	eor	r27, r27
    5c4c:	bc 01       	movw	r22, r24
    5c4e:	89 2b       	or	r24, r25
    5c50:	a9 f7       	brne	.-22     	; 0x5c3c <netChecksum+0x48>
    5c52:	20 95       	com	r18
    5c54:	30 95       	com	r19
    sum = (uint16_t) sum + len;

  return (uint16_t) sum ^ 0xFFFF;
}
    5c56:	c9 01       	movw	r24, r18
    5c58:	df 91       	pop	r29
    5c5a:	cf 91       	pop	r28
    5c5c:	1f 91       	pop	r17
    5c5e:	0f 91       	pop	r16
    5c60:	08 95       	ret

00005c62 <netPrintTcpHeader>:
  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
}

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
    5c62:	cf 92       	push	r12
    5c64:	df 92       	push	r13
    5c66:	ef 92       	push	r14
    5c68:	ff 92       	push	r15
    5c6a:	0f 93       	push	r16
    5c6c:	1f 93       	push	r17
    5c6e:	cf 93       	push	r28
    5c70:	df 93       	push	r29
    5c72:	6c 01       	movw	r12, r24
    5c74:	eb 01       	movw	r28, r22
  fprintf_P(stream, PSTR("TCP Header\r\n"));
    5c76:	00 d0       	rcall	.+0      	; 0x5c78 <netPrintTcpHeader+0x16>
    5c78:	00 d0       	rcall	.+0      	; 0x5c7a <netPrintTcpHeader+0x18>
    5c7a:	ad b7       	in	r26, 0x3d	; 61
    5c7c:	be b7       	in	r27, 0x3e	; 62
    5c7e:	12 96       	adiw	r26, 0x02	; 2
    5c80:	9c 93       	st	X, r25
    5c82:	8e 93       	st	-X, r24
    5c84:	11 97       	sbiw	r26, 0x01	; 1
    5c86:	81 eb       	ldi	r24, 0xB1	; 177
    5c88:	9c e0       	ldi	r25, 0x0C	; 12
    5c8a:	14 96       	adiw	r26, 0x04	; 4
    5c8c:	9c 93       	st	X, r25
    5c8e:	8e 93       	st	-X, r24
    5c90:	13 97       	sbiw	r26, 0x03	; 3
    5c92:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    5c96:	00 d0       	rcall	.+0      	; 0x5c98 <netPrintTcpHeader+0x36>
    5c98:	ed b7       	in	r30, 0x3d	; 61
    5c9a:	fe b7       	in	r31, 0x3e	; 62
    5c9c:	31 96       	adiw	r30, 0x01	; 1
    5c9e:	ad b7       	in	r26, 0x3d	; 61
    5ca0:	be b7       	in	r27, 0x3e	; 62
    5ca2:	12 96       	adiw	r26, 0x02	; 2
    5ca4:	dc 92       	st	X, r13
    5ca6:	ce 92       	st	-X, r12
    5ca8:	11 97       	sbiw	r26, 0x01	; 1
    5caa:	82 ea       	ldi	r24, 0xA2	; 162
    5cac:	9c e0       	ldi	r25, 0x0C	; 12
    5cae:	93 83       	std	Z+3, r25	; 0x03
    5cb0:	82 83       	std	Z+2, r24	; 0x02
    5cb2:	98 81       	ld	r25, Y
    5cb4:	89 81       	ldd	r24, Y+1	; 0x01
    5cb6:	84 83       	std	Z+4, r24	; 0x04
    5cb8:	95 83       	std	Z+5, r25	; 0x05
    5cba:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    5cbe:	ed b7       	in	r30, 0x3d	; 61
    5cc0:	fe b7       	in	r31, 0x3e	; 62
    5cc2:	31 96       	adiw	r30, 0x01	; 1
    5cc4:	ad b7       	in	r26, 0x3d	; 61
    5cc6:	be b7       	in	r27, 0x3e	; 62
    5cc8:	12 96       	adiw	r26, 0x02	; 2
    5cca:	dc 92       	st	X, r13
    5ccc:	ce 92       	st	-X, r12
    5cce:	11 97       	sbiw	r26, 0x01	; 1
    5cd0:	83 e9       	ldi	r24, 0x93	; 147
    5cd2:	9c e0       	ldi	r25, 0x0C	; 12
    5cd4:	93 83       	std	Z+3, r25	; 0x03
    5cd6:	82 83       	std	Z+2, r24	; 0x02
    5cd8:	9a 81       	ldd	r25, Y+2	; 0x02
    5cda:	8b 81       	ldd	r24, Y+3	; 0x03
    5cdc:	84 83       	std	Z+4, r24	; 0x04
    5cde:	95 83       	std	Z+5, r25	; 0x05
    5ce0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Seq Num : 0x%x"), htonl(tcpheader->seqno));
    5ce4:	ec 80       	ldd	r14, Y+4	; 0x04
    5ce6:	fd 80       	ldd	r15, Y+5	; 0x05
    5ce8:	0e 81       	ldd	r16, Y+6	; 0x06
    5cea:	1f 81       	ldd	r17, Y+7	; 0x07
    5cec:	00 d0       	rcall	.+0      	; 0x5cee <netPrintTcpHeader+0x8c>
    5cee:	ed b7       	in	r30, 0x3d	; 61
    5cf0:	fe b7       	in	r31, 0x3e	; 62
    5cf2:	31 96       	adiw	r30, 0x01	; 1
    5cf4:	ad b7       	in	r26, 0x3d	; 61
    5cf6:	be b7       	in	r27, 0x3e	; 62
    5cf8:	12 96       	adiw	r26, 0x02	; 2
    5cfa:	dc 92       	st	X, r13
    5cfc:	ce 92       	st	-X, r12
    5cfe:	11 97       	sbiw	r26, 0x01	; 1
    5d00:	84 e8       	ldi	r24, 0x84	; 132
    5d02:	9c e0       	ldi	r25, 0x0C	; 12
    5d04:	93 83       	std	Z+3, r25	; 0x03
    5d06:	82 83       	std	Z+2, r24	; 0x02
    5d08:	3e 2d       	mov	r19, r14
    5d0a:	2f 2d       	mov	r18, r15
    5d0c:	40 e0       	ldi	r20, 0x00	; 0
    5d0e:	50 e0       	ldi	r21, 0x00	; 0
    5d10:	a9 01       	movw	r20, r18
    5d12:	33 27       	eor	r19, r19
    5d14:	22 27       	eor	r18, r18
    5d16:	78 01       	movw	r14, r16
    5d18:	00 27       	eor	r16, r16
    5d1a:	11 27       	eor	r17, r17
    5d1c:	9e 2d       	mov	r25, r14
    5d1e:	8f 2d       	mov	r24, r15
    5d20:	a0 e0       	ldi	r26, 0x00	; 0
    5d22:	b0 e0       	ldi	r27, 0x00	; 0
    5d24:	28 2b       	or	r18, r24
    5d26:	39 2b       	or	r19, r25
    5d28:	4a 2b       	or	r20, r26
    5d2a:	5b 2b       	or	r21, r27
    5d2c:	24 83       	std	Z+4, r18	; 0x04
    5d2e:	35 83       	std	Z+5, r19	; 0x05
    5d30:	46 83       	std	Z+6, r20	; 0x06
    5d32:	57 83       	std	Z+7, r21	; 0x07
    5d34:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Ack Num : 0x%x\r\n"), htonl(tcpheader->ackno));
    5d38:	e8 84       	ldd	r14, Y+8	; 0x08
    5d3a:	f9 84       	ldd	r15, Y+9	; 0x09
    5d3c:	0a 85       	ldd	r16, Y+10	; 0x0a
    5d3e:	1b 85       	ldd	r17, Y+11	; 0x0b
    5d40:	ed b7       	in	r30, 0x3d	; 61
    5d42:	fe b7       	in	r31, 0x3e	; 62
    5d44:	31 96       	adiw	r30, 0x01	; 1
    5d46:	ad b7       	in	r26, 0x3d	; 61
    5d48:	be b7       	in	r27, 0x3e	; 62
    5d4a:	12 96       	adiw	r26, 0x02	; 2
    5d4c:	dc 92       	st	X, r13
    5d4e:	ce 92       	st	-X, r12
    5d50:	11 97       	sbiw	r26, 0x01	; 1
    5d52:	83 e7       	ldi	r24, 0x73	; 115
    5d54:	9c e0       	ldi	r25, 0x0C	; 12
    5d56:	93 83       	std	Z+3, r25	; 0x03
    5d58:	82 83       	std	Z+2, r24	; 0x02
    5d5a:	3e 2d       	mov	r19, r14
    5d5c:	2f 2d       	mov	r18, r15
    5d5e:	40 e0       	ldi	r20, 0x00	; 0
    5d60:	50 e0       	ldi	r21, 0x00	; 0
    5d62:	a9 01       	movw	r20, r18
    5d64:	33 27       	eor	r19, r19
    5d66:	22 27       	eor	r18, r18
    5d68:	78 01       	movw	r14, r16
    5d6a:	00 27       	eor	r16, r16
    5d6c:	11 27       	eor	r17, r17
    5d6e:	9e 2d       	mov	r25, r14
    5d70:	8f 2d       	mov	r24, r15
    5d72:	a0 e0       	ldi	r26, 0x00	; 0
    5d74:	b0 e0       	ldi	r27, 0x00	; 0
    5d76:	28 2b       	or	r18, r24
    5d78:	39 2b       	or	r19, r25
    5d7a:	4a 2b       	or	r20, r26
    5d7c:	5b 2b       	or	r21, r27
    5d7e:	24 83       	std	Z+4, r18	; 0x04
    5d80:	35 83       	std	Z+5, r19	; 0x05
    5d82:	46 83       	std	Z+6, r20	; 0x06
    5d84:	57 83       	std	Z+7, r21	; 0x07
    5d86:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Flags   : "));
    5d8a:	0f 90       	pop	r0
    5d8c:	0f 90       	pop	r0
    5d8e:	0f 90       	pop	r0
    5d90:	0f 90       	pop	r0
    5d92:	ed b7       	in	r30, 0x3d	; 61
    5d94:	fe b7       	in	r31, 0x3e	; 62
    5d96:	d2 82       	std	Z+2, r13	; 0x02
    5d98:	c1 82       	std	Z+1, r12	; 0x01
    5d9a:	88 e6       	ldi	r24, 0x68	; 104
    5d9c:	9c e0       	ldi	r25, 0x0C	; 12
    5d9e:	94 83       	std	Z+4, r25	; 0x04
    5da0:	83 83       	std	Z+3, r24	; 0x03
    5da2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  if(tcpheader->flags & TCP_FLAGS_FIN)
    5da6:	8d 85       	ldd	r24, Y+13	; 0x0d
    5da8:	0f 90       	pop	r0
    5daa:	0f 90       	pop	r0
    5dac:	0f 90       	pop	r0
    5dae:	0f 90       	pop	r0
    5db0:	80 ff       	sbrs	r24, 0
    5db2:	14 c0       	rjmp	.+40     	; 0x5ddc <netPrintTcpHeader+0x17a>
    fprintf_P(stream, PSTR("FIN "));
    5db4:	00 d0       	rcall	.+0      	; 0x5db6 <netPrintTcpHeader+0x154>
    5db6:	00 d0       	rcall	.+0      	; 0x5db8 <netPrintTcpHeader+0x156>
    5db8:	ad b7       	in	r26, 0x3d	; 61
    5dba:	be b7       	in	r27, 0x3e	; 62
    5dbc:	12 96       	adiw	r26, 0x02	; 2
    5dbe:	dc 92       	st	X, r13
    5dc0:	ce 92       	st	-X, r12
    5dc2:	11 97       	sbiw	r26, 0x01	; 1
    5dc4:	83 e6       	ldi	r24, 0x63	; 99
    5dc6:	9c e0       	ldi	r25, 0x0C	; 12
    5dc8:	14 96       	adiw	r26, 0x04	; 4
    5dca:	9c 93       	st	X, r25
    5dcc:	8e 93       	st	-X, r24
    5dce:	13 97       	sbiw	r26, 0x03	; 3
    5dd0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5dd4:	0f 90       	pop	r0
    5dd6:	0f 90       	pop	r0
    5dd8:	0f 90       	pop	r0
    5dda:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_SYN)
    5ddc:	8d 85       	ldd	r24, Y+13	; 0x0d
    5dde:	81 ff       	sbrs	r24, 1
    5de0:	10 c0       	rjmp	.+32     	; 0x5e02 <netPrintTcpHeader+0x1a0>
    fprintf_P(stream, PSTR("SYN "));
    5de2:	00 d0       	rcall	.+0      	; 0x5de4 <netPrintTcpHeader+0x182>
    5de4:	00 d0       	rcall	.+0      	; 0x5de6 <netPrintTcpHeader+0x184>
    5de6:	ed b7       	in	r30, 0x3d	; 61
    5de8:	fe b7       	in	r31, 0x3e	; 62
    5dea:	d2 82       	std	Z+2, r13	; 0x02
    5dec:	c1 82       	std	Z+1, r12	; 0x01
    5dee:	8e e5       	ldi	r24, 0x5E	; 94
    5df0:	9c e0       	ldi	r25, 0x0C	; 12
    5df2:	94 83       	std	Z+4, r25	; 0x04
    5df4:	83 83       	std	Z+3, r24	; 0x03
    5df6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5dfa:	0f 90       	pop	r0
    5dfc:	0f 90       	pop	r0
    5dfe:	0f 90       	pop	r0
    5e00:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_RST)
    5e02:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e04:	82 ff       	sbrs	r24, 2
    5e06:	14 c0       	rjmp	.+40     	; 0x5e30 <netPrintTcpHeader+0x1ce>
    fprintf_P(stream, PSTR("RST "));
    5e08:	00 d0       	rcall	.+0      	; 0x5e0a <netPrintTcpHeader+0x1a8>
    5e0a:	00 d0       	rcall	.+0      	; 0x5e0c <netPrintTcpHeader+0x1aa>
    5e0c:	ad b7       	in	r26, 0x3d	; 61
    5e0e:	be b7       	in	r27, 0x3e	; 62
    5e10:	12 96       	adiw	r26, 0x02	; 2
    5e12:	dc 92       	st	X, r13
    5e14:	ce 92       	st	-X, r12
    5e16:	11 97       	sbiw	r26, 0x01	; 1
    5e18:	89 e5       	ldi	r24, 0x59	; 89
    5e1a:	9c e0       	ldi	r25, 0x0C	; 12
    5e1c:	14 96       	adiw	r26, 0x04	; 4
    5e1e:	9c 93       	st	X, r25
    5e20:	8e 93       	st	-X, r24
    5e22:	13 97       	sbiw	r26, 0x03	; 3
    5e24:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5e28:	0f 90       	pop	r0
    5e2a:	0f 90       	pop	r0
    5e2c:	0f 90       	pop	r0
    5e2e:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_PSH)
    5e30:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e32:	83 ff       	sbrs	r24, 3
    5e34:	10 c0       	rjmp	.+32     	; 0x5e56 <netPrintTcpHeader+0x1f4>
    fprintf_P(stream, PSTR("PSH "));
    5e36:	00 d0       	rcall	.+0      	; 0x5e38 <netPrintTcpHeader+0x1d6>
    5e38:	00 d0       	rcall	.+0      	; 0x5e3a <netPrintTcpHeader+0x1d8>
    5e3a:	ed b7       	in	r30, 0x3d	; 61
    5e3c:	fe b7       	in	r31, 0x3e	; 62
    5e3e:	d2 82       	std	Z+2, r13	; 0x02
    5e40:	c1 82       	std	Z+1, r12	; 0x01
    5e42:	84 e5       	ldi	r24, 0x54	; 84
    5e44:	9c e0       	ldi	r25, 0x0C	; 12
    5e46:	94 83       	std	Z+4, r25	; 0x04
    5e48:	83 83       	std	Z+3, r24	; 0x03
    5e4a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5e4e:	0f 90       	pop	r0
    5e50:	0f 90       	pop	r0
    5e52:	0f 90       	pop	r0
    5e54:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_ACK)
    5e56:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e58:	84 ff       	sbrs	r24, 4
    5e5a:	14 c0       	rjmp	.+40     	; 0x5e84 <netPrintTcpHeader+0x222>
    fprintf_P(stream, PSTR("ACK "));
    5e5c:	00 d0       	rcall	.+0      	; 0x5e5e <netPrintTcpHeader+0x1fc>
    5e5e:	00 d0       	rcall	.+0      	; 0x5e60 <netPrintTcpHeader+0x1fe>
    5e60:	ad b7       	in	r26, 0x3d	; 61
    5e62:	be b7       	in	r27, 0x3e	; 62
    5e64:	12 96       	adiw	r26, 0x02	; 2
    5e66:	dc 92       	st	X, r13
    5e68:	ce 92       	st	-X, r12
    5e6a:	11 97       	sbiw	r26, 0x01	; 1
    5e6c:	8f e4       	ldi	r24, 0x4F	; 79
    5e6e:	9c e0       	ldi	r25, 0x0C	; 12
    5e70:	14 96       	adiw	r26, 0x04	; 4
    5e72:	9c 93       	st	X, r25
    5e74:	8e 93       	st	-X, r24
    5e76:	13 97       	sbiw	r26, 0x03	; 3
    5e78:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5e7c:	0f 90       	pop	r0
    5e7e:	0f 90       	pop	r0
    5e80:	0f 90       	pop	r0
    5e82:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_URG)
    5e84:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e86:	85 ff       	sbrs	r24, 5
    5e88:	10 c0       	rjmp	.+32     	; 0x5eaa <netPrintTcpHeader+0x248>
    fprintf_P(stream, PSTR("URG "));
    5e8a:	00 d0       	rcall	.+0      	; 0x5e8c <netPrintTcpHeader+0x22a>
    5e8c:	00 d0       	rcall	.+0      	; 0x5e8e <netPrintTcpHeader+0x22c>
    5e8e:	ed b7       	in	r30, 0x3d	; 61
    5e90:	fe b7       	in	r31, 0x3e	; 62
    5e92:	d2 82       	std	Z+2, r13	; 0x02
    5e94:	c1 82       	std	Z+1, r12	; 0x01
    5e96:	8a e4       	ldi	r24, 0x4A	; 74
    5e98:	9c e0       	ldi	r25, 0x0C	; 12
    5e9a:	94 83       	std	Z+4, r25	; 0x04
    5e9c:	83 83       	std	Z+3, r24	; 0x03
    5e9e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5ea2:	0f 90       	pop	r0
    5ea4:	0f 90       	pop	r0
    5ea6:	0f 90       	pop	r0
    5ea8:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    5eaa:	00 d0       	rcall	.+0      	; 0x5eac <netPrintTcpHeader+0x24a>
    5eac:	00 d0       	rcall	.+0      	; 0x5eae <netPrintTcpHeader+0x24c>
    5eae:	ad b7       	in	r26, 0x3d	; 61
    5eb0:	be b7       	in	r27, 0x3e	; 62
    5eb2:	12 96       	adiw	r26, 0x02	; 2
    5eb4:	dc 92       	st	X, r13
    5eb6:	ce 92       	st	-X, r12
    5eb8:	11 97       	sbiw	r26, 0x01	; 1
    5eba:	87 e4       	ldi	r24, 0x47	; 71
    5ebc:	9c e0       	ldi	r25, 0x0C	; 12
    5ebe:	14 96       	adiw	r26, 0x04	; 4
    5ec0:	9c 93       	st	X, r25
    5ec2:	8e 93       	st	-X, r24
    5ec4:	13 97       	sbiw	r26, 0x03	; 3
    5ec6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5eca:	0f 90       	pop	r0
    5ecc:	0f 90       	pop	r0
    5ece:	0f 90       	pop	r0
    5ed0:	0f 90       	pop	r0
}
    5ed2:	df 91       	pop	r29
    5ed4:	cf 91       	pop	r28
    5ed6:	1f 91       	pop	r17
    5ed8:	0f 91       	pop	r16
    5eda:	ff 90       	pop	r15
    5edc:	ef 90       	pop	r14
    5ede:	df 90       	pop	r13
    5ee0:	cf 90       	pop	r12
    5ee2:	08 95       	ret

00005ee4 <netPrintIPAddr>:
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
}

void netPrintIPAddr(FILE *stream, uint32_t ipaddr)
{
    5ee4:	df 93       	push	r29
    5ee6:	cf 93       	push	r28
    5ee8:	00 d0       	rcall	.+0      	; 0x5eea <netPrintIPAddr+0x6>
    5eea:	00 d0       	rcall	.+0      	; 0x5eec <netPrintIPAddr+0x8>
    5eec:	cd b7       	in	r28, 0x3d	; 61
    5eee:	de b7       	in	r29, 0x3e	; 62
    5ef0:	49 83       	std	Y+1, r20	; 0x01
    5ef2:	5a 83       	std	Y+2, r21	; 0x02
    5ef4:	6b 83       	std	Y+3, r22	; 0x03
    5ef6:	7c 83       	std	Y+4, r23	; 0x04
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
    5ef8:	ae 01       	movw	r20, r28
    5efa:	4f 5f       	subi	r20, 0xFF	; 255
    5efc:	5f 4f       	sbci	r21, 0xFF	; 255
    5efe:	2d b7       	in	r18, 0x3d	; 61
    5f00:	3e b7       	in	r19, 0x3e	; 62
    5f02:	2c 50       	subi	r18, 0x0C	; 12
    5f04:	30 40       	sbci	r19, 0x00	; 0
    5f06:	0f b6       	in	r0, 0x3f	; 63
    5f08:	f8 94       	cli
    5f0a:	3e bf       	out	0x3e, r19	; 62
    5f0c:	0f be       	out	0x3f, r0	; 63
    5f0e:	2d bf       	out	0x3d, r18	; 61
    5f10:	ed b7       	in	r30, 0x3d	; 61
    5f12:	fe b7       	in	r31, 0x3e	; 62
    5f14:	31 96       	adiw	r30, 0x01	; 1
    5f16:	ad b7       	in	r26, 0x3d	; 61
    5f18:	be b7       	in	r27, 0x3e	; 62
    5f1a:	12 96       	adiw	r26, 0x02	; 2
    5f1c:	9c 93       	st	X, r25
    5f1e:	8e 93       	st	-X, r24
    5f20:	11 97       	sbiw	r26, 0x01	; 1
    5f22:	87 e6       	ldi	r24, 0x67	; 103
    5f24:	9d e0       	ldi	r25, 0x0D	; 13
    5f26:	93 83       	std	Z+3, r25	; 0x03
    5f28:	82 83       	std	Z+2, r24	; 0x02
    5f2a:	89 81       	ldd	r24, Y+1	; 0x01
    5f2c:	84 83       	std	Z+4, r24	; 0x04
    5f2e:	15 82       	std	Z+5, r1	; 0x05
    5f30:	da 01       	movw	r26, r20
    5f32:	11 96       	adiw	r26, 0x01	; 1
    5f34:	8c 91       	ld	r24, X
    5f36:	11 97       	sbiw	r26, 0x01	; 1
    5f38:	86 83       	std	Z+6, r24	; 0x06
    5f3a:	17 82       	std	Z+7, r1	; 0x07
    5f3c:	12 96       	adiw	r26, 0x02	; 2
    5f3e:	8c 91       	ld	r24, X
    5f40:	12 97       	sbiw	r26, 0x02	; 2
    5f42:	80 87       	std	Z+8, r24	; 0x08
    5f44:	11 86       	std	Z+9, r1	; 0x09
    5f46:	13 96       	adiw	r26, 0x03	; 3
    5f48:	8c 91       	ld	r24, X
    5f4a:	82 87       	std	Z+10, r24	; 0x0a
    5f4c:	13 86       	std	Z+11, r1	; 0x0b
    5f4e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    5f52:	2d b7       	in	r18, 0x3d	; 61
    5f54:	3e b7       	in	r19, 0x3e	; 62
    5f56:	24 5f       	subi	r18, 0xF4	; 244
    5f58:	3f 4f       	sbci	r19, 0xFF	; 255
    5f5a:	0f b6       	in	r0, 0x3f	; 63
    5f5c:	f8 94       	cli
    5f5e:	3e bf       	out	0x3e, r19	; 62
    5f60:	0f be       	out	0x3f, r0	; 63
    5f62:	2d bf       	out	0x3d, r18	; 61
}
    5f64:	0f 90       	pop	r0
    5f66:	0f 90       	pop	r0
    5f68:	0f 90       	pop	r0
    5f6a:	0f 90       	pop	r0
    5f6c:	cf 91       	pop	r28
    5f6e:	df 91       	pop	r29
    5f70:	08 95       	ret

00005f72 <netPrintIpHeader>:
  fprintf_P(stream, PSTR("->DST:"));
  netPrintEthAddr(stream, &eth_hdr->dest);
}

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
    5f72:	ef 92       	push	r14
    5f74:	ff 92       	push	r15
    5f76:	0f 93       	push	r16
    5f78:	1f 93       	push	r17
    5f7a:	cf 93       	push	r28
    5f7c:	df 93       	push	r29
    5f7e:	ec 01       	movw	r28, r24
    5f80:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("IP Header\r\n"));
    5f82:	00 d0       	rcall	.+0      	; 0x5f84 <netPrintIpHeader+0x12>
    5f84:	00 d0       	rcall	.+0      	; 0x5f86 <netPrintIpHeader+0x14>
    5f86:	ad b7       	in	r26, 0x3d	; 61
    5f88:	be b7       	in	r27, 0x3e	; 62
    5f8a:	12 96       	adiw	r26, 0x02	; 2
    5f8c:	9c 93       	st	X, r25
    5f8e:	8e 93       	st	-X, r24
    5f90:	11 97       	sbiw	r26, 0x01	; 1
    5f92:	88 e3       	ldi	r24, 0x38	; 56
    5f94:	9d e0       	ldi	r25, 0x0D	; 13
    5f96:	14 96       	adiw	r26, 0x04	; 4
    5f98:	9c 93       	st	X, r25
    5f9a:	8e 93       	st	-X, r24
    5f9c:	13 97       	sbiw	r26, 0x03	; 3
    5f9e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
    5fa2:	00 d0       	rcall	.+0      	; 0x5fa4 <netPrintIpHeader+0x32>
    5fa4:	ed b7       	in	r30, 0x3d	; 61
    5fa6:	fe b7       	in	r31, 0x3e	; 62
    5fa8:	31 96       	adiw	r30, 0x01	; 1
    5faa:	ad b7       	in	r26, 0x3d	; 61
    5fac:	be b7       	in	r27, 0x3e	; 62
    5fae:	12 96       	adiw	r26, 0x02	; 2
    5fb0:	dc 93       	st	X, r29
    5fb2:	ce 93       	st	-X, r28
    5fb4:	11 97       	sbiw	r26, 0x01	; 1
    5fb6:	89 e2       	ldi	r24, 0x29	; 41
    5fb8:	9d e0       	ldi	r25, 0x0D	; 13
    5fba:	93 83       	std	Z+3, r25	; 0x03
    5fbc:	82 83       	std	Z+2, r24	; 0x02
    5fbe:	d7 01       	movw	r26, r14
    5fc0:	8c 91       	ld	r24, X
    5fc2:	82 95       	swap	r24
    5fc4:	8f 70       	andi	r24, 0x0F	; 15
    5fc6:	84 83       	std	Z+4, r24	; 0x04
    5fc8:	15 82       	std	Z+5, r1	; 0x05
    5fca:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5fce:	ed b7       	in	r30, 0x3d	; 61
    5fd0:	fe b7       	in	r31, 0x3e	; 62
    5fd2:	31 96       	adiw	r30, 0x01	; 1
    5fd4:	ad b7       	in	r26, 0x3d	; 61
    5fd6:	be b7       	in	r27, 0x3e	; 62
    5fd8:	12 96       	adiw	r26, 0x02	; 2
    5fda:	dc 93       	st	X, r29
    5fdc:	ce 93       	st	-X, r28
    5fde:	11 97       	sbiw	r26, 0x01	; 1
    5fe0:	8a e1       	ldi	r24, 0x1A	; 26
    5fe2:	9d e0       	ldi	r25, 0x0D	; 13
    5fe4:	93 83       	std	Z+3, r25	; 0x03
    5fe6:	82 83       	std	Z+2, r24	; 0x02
    5fe8:	d7 01       	movw	r26, r14
    5fea:	12 96       	adiw	r26, 0x02	; 2
    5fec:	9c 91       	ld	r25, X
    5fee:	12 97       	sbiw	r26, 0x02	; 2
    5ff0:	13 96       	adiw	r26, 0x03	; 3
    5ff2:	8c 91       	ld	r24, X
    5ff4:	84 83       	std	Z+4, r24	; 0x04
    5ff6:	95 83       	std	Z+5, r25	; 0x05
    5ff8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  if(ipheader->proto == IP_PROTO_ICMP)
    5ffc:	f7 01       	movw	r30, r14
    5ffe:	21 85       	ldd	r18, Z+9	; 0x09
    6000:	8d b7       	in	r24, 0x3d	; 61
    6002:	9e b7       	in	r25, 0x3e	; 62
    6004:	06 96       	adiw	r24, 0x06	; 6
    6006:	0f b6       	in	r0, 0x3f	; 63
    6008:	f8 94       	cli
    600a:	9e bf       	out	0x3e, r25	; 62
    600c:	0f be       	out	0x3f, r0	; 63
    600e:	8d bf       	out	0x3d, r24	; 61
    6010:	21 30       	cpi	r18, 0x01	; 1
    6012:	59 f4       	brne	.+22     	; 0x602a <netPrintIpHeader+0xb8>
    fprintf_P(stream, PSTR("Protocol: ICMP\r\n"));
    6014:	00 d0       	rcall	.+0      	; 0x6016 <netPrintIpHeader+0xa4>
    6016:	00 d0       	rcall	.+0      	; 0x6018 <netPrintIpHeader+0xa6>
    6018:	ad b7       	in	r26, 0x3d	; 61
    601a:	be b7       	in	r27, 0x3e	; 62
    601c:	12 96       	adiw	r26, 0x02	; 2
    601e:	dc 93       	st	X, r29
    6020:	ce 93       	st	-X, r28
    6022:	11 97       	sbiw	r26, 0x01	; 1
    6024:	89 e0       	ldi	r24, 0x09	; 9
    6026:	9d e0       	ldi	r25, 0x0D	; 13
    6028:	1f c0       	rjmp	.+62     	; 0x6068 <netPrintIpHeader+0xf6>
  else if(ipheader->proto == IP_PROTO_TCP)
    602a:	26 30       	cpi	r18, 0x06	; 6
    602c:	89 f4       	brne	.+34     	; 0x6050 <netPrintIpHeader+0xde>
    fprintf_P(stream, PSTR("Protocol: TCP\r\n"));
    602e:	00 d0       	rcall	.+0      	; 0x6030 <netPrintIpHeader+0xbe>
    6030:	00 d0       	rcall	.+0      	; 0x6032 <netPrintIpHeader+0xc0>
    6032:	ed b7       	in	r30, 0x3d	; 61
    6034:	fe b7       	in	r31, 0x3e	; 62
    6036:	d2 83       	std	Z+2, r29	; 0x02
    6038:	c1 83       	std	Z+1, r28	; 0x01
    603a:	89 ef       	ldi	r24, 0xF9	; 249
    603c:	9c e0       	ldi	r25, 0x0C	; 12
    603e:	94 83       	std	Z+4, r25	; 0x04
    6040:	83 83       	std	Z+3, r24	; 0x03
    6042:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6046:	0f 90       	pop	r0
    6048:	0f 90       	pop	r0
    604a:	0f 90       	pop	r0
    604c:	0f 90       	pop	r0
    604e:	2d c0       	rjmp	.+90     	; 0x60aa <netPrintIpHeader+0x138>
  else if(ipheader->proto == IP_PROTO_UDP)
    6050:	21 31       	cpi	r18, 0x11	; 17
    6052:	79 f4       	brne	.+30     	; 0x6072 <netPrintIpHeader+0x100>
    fprintf_P(stream, PSTR("Protocol: UDP\r\n"));
    6054:	00 d0       	rcall	.+0      	; 0x6056 <netPrintIpHeader+0xe4>
    6056:	00 d0       	rcall	.+0      	; 0x6058 <netPrintIpHeader+0xe6>
    6058:	ad b7       	in	r26, 0x3d	; 61
    605a:	be b7       	in	r27, 0x3e	; 62
    605c:	12 96       	adiw	r26, 0x02	; 2
    605e:	dc 93       	st	X, r29
    6060:	ce 93       	st	-X, r28
    6062:	11 97       	sbiw	r26, 0x01	; 1
    6064:	89 ee       	ldi	r24, 0xE9	; 233
    6066:	9c e0       	ldi	r25, 0x0C	; 12
    6068:	14 96       	adiw	r26, 0x04	; 4
    606a:	9c 93       	st	X, r25
    606c:	8e 93       	st	-X, r24
    606e:	13 97       	sbiw	r26, 0x03	; 3
    6070:	e8 cf       	rjmp	.-48     	; 0x6042 <netPrintIpHeader+0xd0>
  else
    fprintf_P(stream, PSTR("Protocol: %d\r\n"), ipheader->proto);
    6072:	00 d0       	rcall	.+0      	; 0x6074 <netPrintIpHeader+0x102>
    6074:	00 d0       	rcall	.+0      	; 0x6076 <netPrintIpHeader+0x104>
    6076:	00 d0       	rcall	.+0      	; 0x6078 <netPrintIpHeader+0x106>
    6078:	ed b7       	in	r30, 0x3d	; 61
    607a:	fe b7       	in	r31, 0x3e	; 62
    607c:	31 96       	adiw	r30, 0x01	; 1
    607e:	ad b7       	in	r26, 0x3d	; 61
    6080:	be b7       	in	r27, 0x3e	; 62
    6082:	12 96       	adiw	r26, 0x02	; 2
    6084:	dc 93       	st	X, r29
    6086:	ce 93       	st	-X, r28
    6088:	11 97       	sbiw	r26, 0x01	; 1
    608a:	8a ed       	ldi	r24, 0xDA	; 218
    608c:	9c e0       	ldi	r25, 0x0C	; 12
    608e:	93 83       	std	Z+3, r25	; 0x03
    6090:	82 83       	std	Z+2, r24	; 0x02
    6092:	24 83       	std	Z+4, r18	; 0x04
    6094:	15 82       	std	Z+5, r1	; 0x05
    6096:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    609a:	ed b7       	in	r30, 0x3d	; 61
    609c:	fe b7       	in	r31, 0x3e	; 62
    609e:	36 96       	adiw	r30, 0x06	; 6
    60a0:	0f b6       	in	r0, 0x3f	; 63
    60a2:	f8 94       	cli
    60a4:	fe bf       	out	0x3e, r31	; 62
    60a6:	0f be       	out	0x3f, r0	; 63
    60a8:	ed bf       	out	0x3d, r30	; 61

  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
    60aa:	00 d0       	rcall	.+0      	; 0x60ac <netPrintIpHeader+0x13a>
    60ac:	00 d0       	rcall	.+0      	; 0x60ae <netPrintIpHeader+0x13c>
    60ae:	ad b7       	in	r26, 0x3d	; 61
    60b0:	be b7       	in	r27, 0x3e	; 62
    60b2:	12 96       	adiw	r26, 0x02	; 2
    60b4:	dc 93       	st	X, r29
    60b6:	ce 93       	st	-X, r28
    60b8:	11 97       	sbiw	r26, 0x01	; 1
    60ba:	8f ec       	ldi	r24, 0xCF	; 207
    60bc:	9c e0       	ldi	r25, 0x0C	; 12
    60be:	14 96       	adiw	r26, 0x04	; 4
    60c0:	9c 93       	st	X, r25
    60c2:	8e 93       	st	-X, r24
    60c4:	13 97       	sbiw	r26, 0x03	; 3
    60c6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    60ca:	f7 01       	movw	r30, r14
    60cc:	04 85       	ldd	r16, Z+12	; 0x0c
    60ce:	15 85       	ldd	r17, Z+13	; 0x0d
    60d0:	26 85       	ldd	r18, Z+14	; 0x0e
    60d2:	37 85       	ldd	r19, Z+15	; 0x0f
    60d4:	0f 90       	pop	r0
    60d6:	0f 90       	pop	r0
    60d8:	0f 90       	pop	r0
    60da:	0f 90       	pop	r0
    60dc:	50 2f       	mov	r21, r16
    60de:	41 2f       	mov	r20, r17
    60e0:	60 e0       	ldi	r22, 0x00	; 0
    60e2:	70 e0       	ldi	r23, 0x00	; 0
    60e4:	ba 01       	movw	r22, r20
    60e6:	55 27       	eor	r21, r21
    60e8:	44 27       	eor	r20, r20
    60ea:	89 01       	movw	r16, r18
    60ec:	22 27       	eor	r18, r18
    60ee:	33 27       	eor	r19, r19
    60f0:	90 2f       	mov	r25, r16
    60f2:	81 2f       	mov	r24, r17
    60f4:	a0 e0       	ldi	r26, 0x00	; 0
    60f6:	b0 e0       	ldi	r27, 0x00	; 0
    60f8:	48 2b       	or	r20, r24
    60fa:	59 2b       	or	r21, r25
    60fc:	6a 2b       	or	r22, r26
    60fe:	7b 2b       	or	r23, r27
    6100:	ce 01       	movw	r24, r28
    6102:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    6106:	00 d0       	rcall	.+0      	; 0x6108 <netPrintIpHeader+0x196>
    6108:	00 d0       	rcall	.+0      	; 0x610a <netPrintIpHeader+0x198>
    610a:	ad b7       	in	r26, 0x3d	; 61
    610c:	be b7       	in	r27, 0x3e	; 62
    610e:	12 96       	adiw	r26, 0x02	; 2
    6110:	dc 93       	st	X, r29
    6112:	ce 93       	st	-X, r28
    6114:	11 97       	sbiw	r26, 0x01	; 1
    6116:	8c ec       	ldi	r24, 0xCC	; 204
    6118:	9c e0       	ldi	r25, 0x0C	; 12
    611a:	14 96       	adiw	r26, 0x04	; 4
    611c:	9c 93       	st	X, r25
    611e:	8e 93       	st	-X, r24
    6120:	13 97       	sbiw	r26, 0x03	; 3
    6122:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
    6126:	ed b7       	in	r30, 0x3d	; 61
    6128:	fe b7       	in	r31, 0x3e	; 62
    612a:	d2 83       	std	Z+2, r29	; 0x02
    612c:	c1 83       	std	Z+1, r28	; 0x01
    612e:	81 ec       	ldi	r24, 0xC1	; 193
    6130:	9c e0       	ldi	r25, 0x0C	; 12
    6132:	94 83       	std	Z+4, r25	; 0x04
    6134:	83 83       	std	Z+3, r24	; 0x03
    6136:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    613a:	d7 01       	movw	r26, r14
    613c:	50 96       	adiw	r26, 0x10	; 16
    613e:	0d 91       	ld	r16, X+
    6140:	1d 91       	ld	r17, X+
    6142:	2d 91       	ld	r18, X+
    6144:	3c 91       	ld	r19, X
    6146:	53 97       	sbiw	r26, 0x13	; 19
    6148:	0f 90       	pop	r0
    614a:	0f 90       	pop	r0
    614c:	0f 90       	pop	r0
    614e:	0f 90       	pop	r0
    6150:	50 2f       	mov	r21, r16
    6152:	41 2f       	mov	r20, r17
    6154:	60 e0       	ldi	r22, 0x00	; 0
    6156:	70 e0       	ldi	r23, 0x00	; 0
    6158:	ba 01       	movw	r22, r20
    615a:	55 27       	eor	r21, r21
    615c:	44 27       	eor	r20, r20
    615e:	89 01       	movw	r16, r18
    6160:	22 27       	eor	r18, r18
    6162:	33 27       	eor	r19, r19
    6164:	90 2f       	mov	r25, r16
    6166:	81 2f       	mov	r24, r17
    6168:	a0 e0       	ldi	r26, 0x00	; 0
    616a:	b0 e0       	ldi	r27, 0x00	; 0
    616c:	48 2b       	or	r20, r24
    616e:	59 2b       	or	r21, r25
    6170:	6a 2b       	or	r22, r26
    6172:	7b 2b       	or	r23, r27
    6174:	ce 01       	movw	r24, r28
    6176:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    617a:	00 d0       	rcall	.+0      	; 0x617c <netPrintIpHeader+0x20a>
    617c:	00 d0       	rcall	.+0      	; 0x617e <netPrintIpHeader+0x20c>
    617e:	ed b7       	in	r30, 0x3d	; 61
    6180:	fe b7       	in	r31, 0x3e	; 62
    6182:	d2 83       	std	Z+2, r29	; 0x02
    6184:	c1 83       	std	Z+1, r28	; 0x01
    6186:	8e eb       	ldi	r24, 0xBE	; 190
    6188:	9c e0       	ldi	r25, 0x0C	; 12
    618a:	94 83       	std	Z+4, r25	; 0x04
    618c:	83 83       	std	Z+3, r24	; 0x03
    618e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6192:	0f 90       	pop	r0
    6194:	0f 90       	pop	r0
    6196:	0f 90       	pop	r0
    6198:	0f 90       	pop	r0
}
    619a:	df 91       	pop	r29
    619c:	cf 91       	pop	r28
    619e:	1f 91       	pop	r17
    61a0:	0f 91       	pop	r16
    61a2:	ff 90       	pop	r15
    61a4:	ef 90       	pop	r14
    61a6:	08 95       	ret

000061a8 <netPrintEthAddr>:

  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
    61a8:	cf 93       	push	r28
    61aa:	df 93       	push	r29
    61ac:	db 01       	movw	r26, r22
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    61ae:	2d b7       	in	r18, 0x3d	; 61
    61b0:	3e b7       	in	r19, 0x3e	; 62
    61b2:	20 51       	subi	r18, 0x10	; 16
    61b4:	30 40       	sbci	r19, 0x00	; 0
    61b6:	0f b6       	in	r0, 0x3f	; 63
    61b8:	f8 94       	cli
    61ba:	3e bf       	out	0x3e, r19	; 62
    61bc:	0f be       	out	0x3f, r0	; 63
    61be:	2d bf       	out	0x3d, r18	; 61
    61c0:	ed b7       	in	r30, 0x3d	; 61
    61c2:	fe b7       	in	r31, 0x3e	; 62
    61c4:	31 96       	adiw	r30, 0x01	; 1
    61c6:	cd b7       	in	r28, 0x3d	; 61
    61c8:	de b7       	in	r29, 0x3e	; 62
    61ca:	9a 83       	std	Y+2, r25	; 0x02
    61cc:	89 83       	std	Y+1, r24	; 0x01
    61ce:	83 e7       	ldi	r24, 0x73	; 115
    61d0:	9d e0       	ldi	r25, 0x0D	; 13
    61d2:	93 83       	std	Z+3, r25	; 0x03
    61d4:	82 83       	std	Z+2, r24	; 0x02
    61d6:	8c 91       	ld	r24, X
    61d8:	84 83       	std	Z+4, r24	; 0x04
    61da:	15 82       	std	Z+5, r1	; 0x05
    61dc:	11 96       	adiw	r26, 0x01	; 1
    61de:	8c 91       	ld	r24, X
    61e0:	11 97       	sbiw	r26, 0x01	; 1
    61e2:	86 83       	std	Z+6, r24	; 0x06
    61e4:	17 82       	std	Z+7, r1	; 0x07
    61e6:	12 96       	adiw	r26, 0x02	; 2
    61e8:	8c 91       	ld	r24, X
    61ea:	12 97       	sbiw	r26, 0x02	; 2
    61ec:	80 87       	std	Z+8, r24	; 0x08
    61ee:	11 86       	std	Z+9, r1	; 0x09
    61f0:	13 96       	adiw	r26, 0x03	; 3
    61f2:	8c 91       	ld	r24, X
    61f4:	13 97       	sbiw	r26, 0x03	; 3
    61f6:	82 87       	std	Z+10, r24	; 0x0a
    61f8:	13 86       	std	Z+11, r1	; 0x0b
    61fa:	14 96       	adiw	r26, 0x04	; 4
    61fc:	8c 91       	ld	r24, X
    61fe:	14 97       	sbiw	r26, 0x04	; 4
    6200:	84 87       	std	Z+12, r24	; 0x0c
    6202:	15 86       	std	Z+13, r1	; 0x0d
    6204:	15 96       	adiw	r26, 0x05	; 5
    6206:	8c 91       	ld	r24, X
    6208:	86 87       	std	Z+14, r24	; 0x0e
    620a:	17 86       	std	Z+15, r1	; 0x0f
    620c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6210:	2d b7       	in	r18, 0x3d	; 61
    6212:	3e b7       	in	r19, 0x3e	; 62
    6214:	20 5f       	subi	r18, 0xF0	; 240
    6216:	3f 4f       	sbci	r19, 0xFF	; 255
    6218:	0f b6       	in	r0, 0x3f	; 63
    621a:	f8 94       	cli
    621c:	3e bf       	out	0x3e, r19	; 62
    621e:	0f be       	out	0x3f, r0	; 63
    6220:	2d bf       	out	0x3d, r18	; 61
}
    6222:	df 91       	pop	r29
    6224:	cf 91       	pop	r28
    6226:	08 95       	ret

00006228 <netPrintEthHeader>:
{
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
}

void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
    6228:	cf 92       	push	r12
    622a:	df 92       	push	r13
    622c:	ef 92       	push	r14
    622e:	ff 92       	push	r15
    6230:	0f 93       	push	r16
    6232:	1f 93       	push	r17
    6234:	7c 01       	movw	r14, r24
    6236:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
    6238:	00 d0       	rcall	.+0      	; 0x623a <netPrintEthHeader+0x12>
    623a:	00 d0       	rcall	.+0      	; 0x623c <netPrintEthHeader+0x14>
    623c:	00 d0       	rcall	.+0      	; 0x623e <netPrintEthHeader+0x16>
    623e:	ed b7       	in	r30, 0x3d	; 61
    6240:	fe b7       	in	r31, 0x3e	; 62
    6242:	31 96       	adiw	r30, 0x01	; 1
    6244:	ad b7       	in	r26, 0x3d	; 61
    6246:	be b7       	in	r27, 0x3e	; 62
    6248:	12 96       	adiw	r26, 0x02	; 2
    624a:	9c 93       	st	X, r25
    624c:	8e 93       	st	-X, r24
    624e:	11 97       	sbiw	r26, 0x01	; 1
    6250:	81 e5       	ldi	r24, 0x51	; 81
    6252:	9d e0       	ldi	r25, 0x0D	; 13
    6254:	93 83       	std	Z+3, r25	; 0x03
    6256:	82 83       	std	Z+2, r24	; 0x02
    6258:	db 01       	movw	r26, r22
    625a:	1c 96       	adiw	r26, 0x0c	; 12
    625c:	8d 91       	ld	r24, X+
    625e:	9c 91       	ld	r25, X
    6260:	1d 97       	sbiw	r26, 0x0d	; 13
    6262:	95 83       	std	Z+5, r25	; 0x05
    6264:	84 83       	std	Z+4, r24	; 0x04
    6266:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR(" SRC:"));
    626a:	0f 90       	pop	r0
    626c:	0f 90       	pop	r0
    626e:	ed b7       	in	r30, 0x3d	; 61
    6270:	fe b7       	in	r31, 0x3e	; 62
    6272:	f2 82       	std	Z+2, r15	; 0x02
    6274:	e1 82       	std	Z+1, r14	; 0x01
    6276:	8b e4       	ldi	r24, 0x4B	; 75
    6278:	9d e0       	ldi	r25, 0x0D	; 13
    627a:	94 83       	std	Z+4, r25	; 0x04
    627c:	83 83       	std	Z+3, r24	; 0x03
    627e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    6282:	8d b7       	in	r24, 0x3d	; 61
    6284:	9e b7       	in	r25, 0x3e	; 62
    6286:	0c 97       	sbiw	r24, 0x0c	; 12
    6288:	0f b6       	in	r0, 0x3f	; 63
    628a:	f8 94       	cli
    628c:	9e bf       	out	0x3e, r25	; 62
    628e:	0f be       	out	0x3f, r0	; 63
    6290:	8d bf       	out	0x3d, r24	; 61
    6292:	ed b7       	in	r30, 0x3d	; 61
    6294:	fe b7       	in	r31, 0x3e	; 62
    6296:	31 96       	adiw	r30, 0x01	; 1
    6298:	ad b7       	in	r26, 0x3d	; 61
    629a:	be b7       	in	r27, 0x3e	; 62
    629c:	12 96       	adiw	r26, 0x02	; 2
    629e:	fc 92       	st	X, r15
    62a0:	ee 92       	st	-X, r14
    62a2:	11 97       	sbiw	r26, 0x01	; 1
    62a4:	b3 e7       	ldi	r27, 0x73	; 115
    62a6:	cb 2e       	mov	r12, r27
    62a8:	bd e0       	ldi	r27, 0x0D	; 13
    62aa:	db 2e       	mov	r13, r27
    62ac:	d3 82       	std	Z+3, r13	; 0x03
    62ae:	c2 82       	std	Z+2, r12	; 0x02
    62b0:	d8 01       	movw	r26, r16
    62b2:	16 96       	adiw	r26, 0x06	; 6
    62b4:	8c 91       	ld	r24, X
    62b6:	16 97       	sbiw	r26, 0x06	; 6
    62b8:	84 83       	std	Z+4, r24	; 0x04
    62ba:	15 82       	std	Z+5, r1	; 0x05
    62bc:	17 96       	adiw	r26, 0x07	; 7
    62be:	8c 91       	ld	r24, X
    62c0:	17 97       	sbiw	r26, 0x07	; 7
    62c2:	86 83       	std	Z+6, r24	; 0x06
    62c4:	17 82       	std	Z+7, r1	; 0x07
    62c6:	18 96       	adiw	r26, 0x08	; 8
    62c8:	8c 91       	ld	r24, X
    62ca:	18 97       	sbiw	r26, 0x08	; 8
    62cc:	80 87       	std	Z+8, r24	; 0x08
    62ce:	11 86       	std	Z+9, r1	; 0x09
    62d0:	19 96       	adiw	r26, 0x09	; 9
    62d2:	8c 91       	ld	r24, X
    62d4:	19 97       	sbiw	r26, 0x09	; 9
    62d6:	82 87       	std	Z+10, r24	; 0x0a
    62d8:	13 86       	std	Z+11, r1	; 0x0b
    62da:	1a 96       	adiw	r26, 0x0a	; 10
    62dc:	8c 91       	ld	r24, X
    62de:	1a 97       	sbiw	r26, 0x0a	; 10
    62e0:	84 87       	std	Z+12, r24	; 0x0c
    62e2:	15 86       	std	Z+13, r1	; 0x0d
    62e4:	1b 96       	adiw	r26, 0x0b	; 11
    62e6:	8c 91       	ld	r24, X
    62e8:	86 87       	std	Z+14, r24	; 0x0e
    62ea:	17 86       	std	Z+15, r1	; 0x0f
    62ec:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
  fprintf_P(stream, PSTR(" SRC:"));
  netPrintEthAddr(stream, &eth_hdr->src);
  fprintf_P(stream, PSTR("->DST:"));
    62f0:	ed b7       	in	r30, 0x3d	; 61
    62f2:	fe b7       	in	r31, 0x3e	; 62
    62f4:	3c 96       	adiw	r30, 0x0c	; 12
    62f6:	0f b6       	in	r0, 0x3f	; 63
    62f8:	f8 94       	cli
    62fa:	fe bf       	out	0x3e, r31	; 62
    62fc:	0f be       	out	0x3f, r0	; 63
    62fe:	ed bf       	out	0x3d, r30	; 61
    6300:	f2 82       	std	Z+2, r15	; 0x02
    6302:	e1 82       	std	Z+1, r14	; 0x01
    6304:	84 e4       	ldi	r24, 0x44	; 68
    6306:	9d e0       	ldi	r25, 0x0D	; 13
    6308:	94 83       	std	Z+4, r25	; 0x04
    630a:	83 83       	std	Z+3, r24	; 0x03
    630c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    6310:	8d b7       	in	r24, 0x3d	; 61
    6312:	9e b7       	in	r25, 0x3e	; 62
    6314:	0c 97       	sbiw	r24, 0x0c	; 12
    6316:	0f b6       	in	r0, 0x3f	; 63
    6318:	f8 94       	cli
    631a:	9e bf       	out	0x3e, r25	; 62
    631c:	0f be       	out	0x3f, r0	; 63
    631e:	8d bf       	out	0x3d, r24	; 61
    6320:	ed b7       	in	r30, 0x3d	; 61
    6322:	fe b7       	in	r31, 0x3e	; 62
    6324:	31 96       	adiw	r30, 0x01	; 1
    6326:	ad b7       	in	r26, 0x3d	; 61
    6328:	be b7       	in	r27, 0x3e	; 62
    632a:	12 96       	adiw	r26, 0x02	; 2
    632c:	fc 92       	st	X, r15
    632e:	ee 92       	st	-X, r14
    6330:	11 97       	sbiw	r26, 0x01	; 1
    6332:	d3 82       	std	Z+3, r13	; 0x03
    6334:	c2 82       	std	Z+2, r12	; 0x02
    6336:	d8 01       	movw	r26, r16
    6338:	8c 91       	ld	r24, X
    633a:	84 83       	std	Z+4, r24	; 0x04
    633c:	15 82       	std	Z+5, r1	; 0x05
    633e:	11 96       	adiw	r26, 0x01	; 1
    6340:	8c 91       	ld	r24, X
    6342:	11 97       	sbiw	r26, 0x01	; 1
    6344:	86 83       	std	Z+6, r24	; 0x06
    6346:	17 82       	std	Z+7, r1	; 0x07
    6348:	12 96       	adiw	r26, 0x02	; 2
    634a:	8c 91       	ld	r24, X
    634c:	12 97       	sbiw	r26, 0x02	; 2
    634e:	80 87       	std	Z+8, r24	; 0x08
    6350:	11 86       	std	Z+9, r1	; 0x09
    6352:	13 96       	adiw	r26, 0x03	; 3
    6354:	8c 91       	ld	r24, X
    6356:	13 97       	sbiw	r26, 0x03	; 3
    6358:	82 87       	std	Z+10, r24	; 0x0a
    635a:	13 86       	std	Z+11, r1	; 0x0b
    635c:	14 96       	adiw	r26, 0x04	; 4
    635e:	8c 91       	ld	r24, X
    6360:	14 97       	sbiw	r26, 0x04	; 4
    6362:	84 87       	std	Z+12, r24	; 0x0c
    6364:	15 86       	std	Z+13, r1	; 0x0d
    6366:	15 96       	adiw	r26, 0x05	; 5
    6368:	8c 91       	ld	r24, X
    636a:	86 87       	std	Z+14, r24	; 0x0e
    636c:	17 86       	std	Z+15, r1	; 0x0f
    636e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6372:	ed b7       	in	r30, 0x3d	; 61
    6374:	fe b7       	in	r31, 0x3e	; 62
    6376:	70 96       	adiw	r30, 0x10	; 16
    6378:	0f b6       	in	r0, 0x3f	; 63
    637a:	f8 94       	cli
    637c:	fe bf       	out	0x3e, r31	; 62
    637e:	0f be       	out	0x3f, r0	; 63
    6380:	ed bf       	out	0x3d, r30	; 61
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
  fprintf_P(stream, PSTR(" SRC:"));
  netPrintEthAddr(stream, &eth_hdr->src);
  fprintf_P(stream, PSTR("->DST:"));
  netPrintEthAddr(stream, &eth_hdr->dest);
}
    6382:	1f 91       	pop	r17
    6384:	0f 91       	pop	r16
    6386:	ff 90       	pop	r15
    6388:	ef 90       	pop	r14
    638a:	df 90       	pop	r13
    638c:	cf 90       	pop	r12
    638e:	08 95       	ret

00006390 <setIpDebug>:
}

#if IP_DEBUG
void setIpDebug(FILE *stream, uint8_t level)
{
  IpMyConfig.dbgStream = stream;
    6390:	90 93 5d 0f 	sts	0x0F5D, r25
    6394:	80 93 5c 0f 	sts	0x0F5C, r24
  IpMyConfig.dbgLevel = level;
    6398:	60 93 5e 0f 	sts	0x0F5E, r22
  if (level == 0)
    639c:	66 23       	and	r22, r22
    639e:	21 f4       	brne	.+8      	; 0x63a8 <setIpDebug+0x18>
    IpMyConfig.dbgStream = NULL;
    63a0:	10 92 5d 0f 	sts	0x0F5D, r1
    63a4:	10 92 5c 0f 	sts	0x0F5C, r1
    63a8:	08 95       	ret

000063aa <ipSetConfig>:
}
#endif

void ipSetConfig(uint32_t myIp, uint32_t netmask, uint32_t gatewayIp)
{
    63aa:	ef 92       	push	r14
    63ac:	ff 92       	push	r15
    63ae:	0f 93       	push	r16
    63b0:	1f 93       	push	r17
  // set local addressing
  IpMyConfig.ip = myIp;
    63b2:	60 93 50 0f 	sts	0x0F50, r22
    63b6:	70 93 51 0f 	sts	0x0F51, r23
    63ba:	80 93 52 0f 	sts	0x0F52, r24
    63be:	90 93 53 0f 	sts	0x0F53, r25
  IpMyConfig.netmask = netmask;
    63c2:	20 93 54 0f 	sts	0x0F54, r18
    63c6:	30 93 55 0f 	sts	0x0F55, r19
    63ca:	40 93 56 0f 	sts	0x0F56, r20
    63ce:	50 93 57 0f 	sts	0x0F57, r21
  IpMyConfig.gateway = gatewayIp;
    63d2:	e0 92 58 0f 	sts	0x0F58, r14
    63d6:	f0 92 59 0f 	sts	0x0F59, r15
    63da:	00 93 5a 0f 	sts	0x0F5A, r16
    63de:	10 93 5b 0f 	sts	0x0F5B, r17
}
    63e2:	1f 91       	pop	r17
    63e4:	0f 91       	pop	r16
    63e6:	ff 90       	pop	r15
    63e8:	ef 90       	pop	r14
    63ea:	08 95       	ret

000063ec <ipSetConfigIp>:

void ipSetConfigIp(uint32_t myIp)
{
  // set local addressing
  IpMyConfig.ip = myIp; 
    63ec:	60 93 50 0f 	sts	0x0F50, r22
    63f0:	70 93 51 0f 	sts	0x0F51, r23
    63f4:	80 93 52 0f 	sts	0x0F52, r24
    63f8:	90 93 53 0f 	sts	0x0F53, r25
}
    63fc:	08 95       	ret

000063fe <ipSetConfigMask>:

void ipSetConfigMask(uint32_t netmask)
{
  IpMyConfig.netmask = netmask;
    63fe:	60 93 54 0f 	sts	0x0F54, r22
    6402:	70 93 55 0f 	sts	0x0F55, r23
    6406:	80 93 56 0f 	sts	0x0F56, r24
    640a:	90 93 57 0f 	sts	0x0F57, r25
}
    640e:	08 95       	ret

00006410 <ipSetConfigGw>:

void ipSetConfigGw(uint32_t gatewayIp)
{
  IpMyConfig.gateway = gatewayIp;
    6410:	60 93 58 0f 	sts	0x0F58, r22
    6414:	70 93 59 0f 	sts	0x0F59, r23
    6418:	80 93 5a 0f 	sts	0x0F5A, r24
    641c:	90 93 5b 0f 	sts	0x0F5B, r25
}
    6420:	08 95       	ret

00006422 <ipGetConfig>:


struct ipConfig* ipGetConfig(void)
{
  return &IpMyConfig;
}
    6422:	80 e5       	ldi	r24, 0x50	; 80
    6424:	9f e0       	ldi	r25, 0x0F	; 15
    6426:	08 95       	ret

00006428 <ipPrintConfig>:
// send it
  nicSend(len);
}

void ipPrintConfig(FILE *stream, struct ipConfig* config)
{
    6428:	ef 92       	push	r14
    642a:	ff 92       	push	r15
    642c:	0f 93       	push	r16
    642e:	1f 93       	push	r17
    6430:	8c 01       	movw	r16, r24
    6432:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("IP Addr : ")); netPrintIPAddr(stream, config->ip);        fprintf_P(stream, PSTR("\r\n"));
    6434:	00 d0       	rcall	.+0      	; 0x6436 <ipPrintConfig+0xe>
    6436:	00 d0       	rcall	.+0      	; 0x6438 <ipPrintConfig+0x10>
    6438:	ed b7       	in	r30, 0x3d	; 61
    643a:	fe b7       	in	r31, 0x3e	; 62
    643c:	92 83       	std	Z+2, r25	; 0x02
    643e:	81 83       	std	Z+1, r24	; 0x01
    6440:	80 eb       	ldi	r24, 0xB0	; 176
    6442:	9d e0       	ldi	r25, 0x0D	; 13
    6444:	94 83       	std	Z+4, r25	; 0x04
    6446:	83 83       	std	Z+3, r24	; 0x03
    6448:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    644c:	0f 90       	pop	r0
    644e:	0f 90       	pop	r0
    6450:	0f 90       	pop	r0
    6452:	0f 90       	pop	r0
    6454:	f7 01       	movw	r30, r14
    6456:	40 81       	ld	r20, Z
    6458:	51 81       	ldd	r21, Z+1	; 0x01
    645a:	62 81       	ldd	r22, Z+2	; 0x02
    645c:	73 81       	ldd	r23, Z+3	; 0x03
    645e:	c8 01       	movw	r24, r16
    6460:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    6464:	00 d0       	rcall	.+0      	; 0x6466 <ipPrintConfig+0x3e>
    6466:	00 d0       	rcall	.+0      	; 0x6468 <ipPrintConfig+0x40>
    6468:	ed b7       	in	r30, 0x3d	; 61
    646a:	fe b7       	in	r31, 0x3e	; 62
    646c:	12 83       	std	Z+2, r17	; 0x02
    646e:	01 83       	std	Z+1, r16	; 0x01
    6470:	8d ea       	ldi	r24, 0xAD	; 173
    6472:	9d e0       	ldi	r25, 0x0D	; 13
    6474:	94 83       	std	Z+4, r25	; 0x04
    6476:	83 83       	std	Z+3, r24	; 0x03
    6478:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Netmask : ")); netPrintIPAddr(stream, config->netmask);   fprintf_P(stream, PSTR("\r\n"));
    647c:	ed b7       	in	r30, 0x3d	; 61
    647e:	fe b7       	in	r31, 0x3e	; 62
    6480:	12 83       	std	Z+2, r17	; 0x02
    6482:	01 83       	std	Z+1, r16	; 0x01
    6484:	82 ea       	ldi	r24, 0xA2	; 162
    6486:	9d e0       	ldi	r25, 0x0D	; 13
    6488:	94 83       	std	Z+4, r25	; 0x04
    648a:	83 83       	std	Z+3, r24	; 0x03
    648c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6490:	0f 90       	pop	r0
    6492:	0f 90       	pop	r0
    6494:	0f 90       	pop	r0
    6496:	0f 90       	pop	r0
    6498:	f7 01       	movw	r30, r14
    649a:	44 81       	ldd	r20, Z+4	; 0x04
    649c:	55 81       	ldd	r21, Z+5	; 0x05
    649e:	66 81       	ldd	r22, Z+6	; 0x06
    64a0:	77 81       	ldd	r23, Z+7	; 0x07
    64a2:	c8 01       	movw	r24, r16
    64a4:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    64a8:	00 d0       	rcall	.+0      	; 0x64aa <ipPrintConfig+0x82>
    64aa:	00 d0       	rcall	.+0      	; 0x64ac <ipPrintConfig+0x84>
    64ac:	ed b7       	in	r30, 0x3d	; 61
    64ae:	fe b7       	in	r31, 0x3e	; 62
    64b0:	12 83       	std	Z+2, r17	; 0x02
    64b2:	01 83       	std	Z+1, r16	; 0x01
    64b4:	8f e9       	ldi	r24, 0x9F	; 159
    64b6:	9d e0       	ldi	r25, 0x0D	; 13
    64b8:	94 83       	std	Z+4, r25	; 0x04
    64ba:	83 83       	std	Z+3, r24	; 0x03
    64bc:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("Gateway : ")); netPrintIPAddr(stream, config->gateway);   fprintf_P(stream, PSTR("\r\n"));
    64c0:	ed b7       	in	r30, 0x3d	; 61
    64c2:	fe b7       	in	r31, 0x3e	; 62
    64c4:	12 83       	std	Z+2, r17	; 0x02
    64c6:	01 83       	std	Z+1, r16	; 0x01
    64c8:	84 e9       	ldi	r24, 0x94	; 148
    64ca:	9d e0       	ldi	r25, 0x0D	; 13
    64cc:	94 83       	std	Z+4, r25	; 0x04
    64ce:	83 83       	std	Z+3, r24	; 0x03
    64d0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    64d4:	0f 90       	pop	r0
    64d6:	0f 90       	pop	r0
    64d8:	0f 90       	pop	r0
    64da:	0f 90       	pop	r0
    64dc:	f7 01       	movw	r30, r14
    64de:	40 85       	ldd	r20, Z+8	; 0x08
    64e0:	51 85       	ldd	r21, Z+9	; 0x09
    64e2:	62 85       	ldd	r22, Z+10	; 0x0a
    64e4:	73 85       	ldd	r23, Z+11	; 0x0b
    64e6:	c8 01       	movw	r24, r16
    64e8:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    64ec:	00 d0       	rcall	.+0      	; 0x64ee <ipPrintConfig+0xc6>
    64ee:	00 d0       	rcall	.+0      	; 0x64f0 <ipPrintConfig+0xc8>
    64f0:	ed b7       	in	r30, 0x3d	; 61
    64f2:	fe b7       	in	r31, 0x3e	; 62
    64f4:	12 83       	std	Z+2, r17	; 0x02
    64f6:	01 83       	std	Z+1, r16	; 0x01
    64f8:	81 e9       	ldi	r24, 0x91	; 145
    64fa:	9d e0       	ldi	r25, 0x0D	; 13
    64fc:	94 83       	std	Z+4, r25	; 0x04
    64fe:	83 83       	std	Z+3, r24	; 0x03
    6500:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6504:	0f 90       	pop	r0
    6506:	0f 90       	pop	r0
    6508:	0f 90       	pop	r0
    650a:	0f 90       	pop	r0
}
    650c:	1f 91       	pop	r17
    650e:	0f 91       	pop	r16
    6510:	ff 90       	pop	r15
    6512:	ef 90       	pop	r14
    6514:	08 95       	ret

00006516 <ipSend>:
{
  return &IpMyConfig;
}

void ipSend(uint32_t dstIp, uint8_t protocol, uint16_t len)
{
    6516:	bf 92       	push	r11
    6518:	cf 92       	push	r12
    651a:	df 92       	push	r13
    651c:	ef 92       	push	r14
    651e:	ff 92       	push	r15
    6520:	0f 93       	push	r16
    6522:	1f 93       	push	r17
    6524:	cf 93       	push	r28
    6526:	df 93       	push	r29
    6528:	6b 01       	movw	r12, r22
    652a:	7c 01       	movw	r14, r24
    652c:	b4 2e       	mov	r11, r20
    652e:	e9 01       	movw	r28, r18
// make pointer to ethernet/IP header
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6530:	20 91 5c 0f 	lds	r18, 0x0F5C
    6534:	30 91 5d 0f 	lds	r19, 0x0F5D
    6538:	21 15       	cp	r18, r1
    653a:	31 05       	cpc	r19, r1
    653c:	a1 f0       	breq	.+40     	; 0x6566 <ipSend+0x50>
  {  
    if (IpMyConfig.dbgLevel > 2)
    653e:	80 91 5e 0f 	lds	r24, 0x0F5E
    6542:	83 30       	cpi	r24, 0x03	; 3
    6544:	80 f0       	brcs	.+32     	; 0x6566 <ipSend+0x50>
      fprintf_P(IpMyConfig.dbgStream, "Sending Ip packet\r\n");
    6546:	00 d0       	rcall	.+0      	; 0x6548 <ipSend+0x32>
    6548:	00 d0       	rcall	.+0      	; 0x654a <ipSend+0x34>
    654a:	ed b7       	in	r30, 0x3d	; 61
    654c:	fe b7       	in	r31, 0x3e	; 62
    654e:	32 83       	std	Z+2, r19	; 0x02
    6550:	21 83       	std	Z+1, r18	; 0x01
    6552:	8b e4       	ldi	r24, 0x4B	; 75
    6554:	91 e0       	ldi	r25, 0x01	; 1
    6556:	94 83       	std	Z+4, r25	; 0x04
    6558:	83 83       	std	Z+3, r24	; 0x03
    655a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    655e:	0f 90       	pop	r0
    6560:	0f 90       	pop	r0
    6562:	0f 90       	pop	r0
    6564:	0f 90       	pop	r0
  }
#endif

// adjust length to add IP header
  len += IP_HEADER_LEN;
    6566:	64 96       	adiw	r28, 0x14	; 20

// fill IP header
  nicState.layer3.ip->destipaddr = dstIp;
    6568:	00 91 88 0e 	lds	r16, 0x0E88
    656c:	10 91 89 0e 	lds	r17, 0x0E89
    6570:	f8 01       	movw	r30, r16
    6572:	c0 8a       	std	Z+16, r12	; 0x10
    6574:	d1 8a       	std	Z+17, r13	; 0x11
    6576:	e2 8a       	std	Z+18, r14	; 0x12
    6578:	f3 8a       	std	Z+19, r15	; 0x13
  nicState.layer3.ip->srcipaddr  = IpMyConfig.ip;
    657a:	80 91 50 0f 	lds	r24, 0x0F50
    657e:	90 91 51 0f 	lds	r25, 0x0F51
    6582:	a0 91 52 0f 	lds	r26, 0x0F52
    6586:	b0 91 53 0f 	lds	r27, 0x0F53
    658a:	84 87       	std	Z+12, r24	; 0x0c
    658c:	95 87       	std	Z+13, r25	; 0x0d
    658e:	a6 87       	std	Z+14, r26	; 0x0e
    6590:	b7 87       	std	Z+15, r27	; 0x0f
  nicState.layer3.ip->proto      = protocol;
    6592:	b1 86       	std	Z+9, r11	; 0x09
  nicState.layer3.ip->len        = htons(len);
    6594:	ce 01       	movw	r24, r28
    6596:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    659a:	f8 01       	movw	r30, r16
    659c:	93 83       	std	Z+3, r25	; 0x03
    659e:	82 83       	std	Z+2, r24	; 0x02
  nicState.layer3.ip->vhl        = 0x45;
    65a0:	e0 91 88 0e 	lds	r30, 0x0E88
    65a4:	f0 91 89 0e 	lds	r31, 0x0E89
    65a8:	85 e4       	ldi	r24, 0x45	; 69
    65aa:	80 83       	st	Z, r24
  nicState.layer3.ip->tos        = 0;
    65ac:	e0 91 88 0e 	lds	r30, 0x0E88
    65b0:	f0 91 89 0e 	lds	r31, 0x0E89
    65b4:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ip->ipid       = 0;
    65b6:	e0 91 88 0e 	lds	r30, 0x0E88
    65ba:	f0 91 89 0e 	lds	r31, 0x0E89
    65be:	15 82       	std	Z+5, r1	; 0x05
    65c0:	14 82       	std	Z+4, r1	; 0x04
  nicState.layer3.ip->ipoffset   = 0;
    65c2:	17 82       	std	Z+7, r1	; 0x07
    65c4:	16 82       	std	Z+6, r1	; 0x06
  nicState.layer3.ip->ttl        = IP_TIME_TO_LIVE;
    65c6:	80 e8       	ldi	r24, 0x80	; 128
    65c8:	80 87       	std	Z+8, r24	; 0x08
  nicState.layer3.ip->ipchksum   = 0;
    65ca:	13 86       	std	Z+11, r1	; 0x0b
    65cc:	12 86       	std	Z+10, r1	; 0x0a

// calculate and apply IP checksum
// DO THIS ONLY AFTER ALL CHANGES HAVE BEEN MADE TO IP HEADER
  nicState.layer3.ip->ipchksum   = netChecksum((uint8_t *)(nicState.layer3.ip), IP_HEADER_LEN);
    65ce:	00 91 88 0e 	lds	r16, 0x0E88
    65d2:	10 91 89 0e 	lds	r17, 0x0E89
    65d6:	c8 01       	movw	r24, r16
    65d8:	64 e1       	ldi	r22, 0x14	; 20
    65da:	70 e0       	ldi	r23, 0x00	; 0
    65dc:	0e 94 fa 2d 	call	0x5bf4	; 0x5bf4 <netChecksum>
    65e0:	f8 01       	movw	r30, r16
    65e2:	93 87       	std	Z+11, r25	; 0x0b
    65e4:	82 87       	std	Z+10, r24	; 0x0a

// add ethernet routing
// check if we need to send to gateway
  if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    65e6:	20 91 50 0f 	lds	r18, 0x0F50
    65ea:	30 91 51 0f 	lds	r19, 0x0F51
    65ee:	40 91 52 0f 	lds	r20, 0x0F52
    65f2:	50 91 53 0f 	lds	r21, 0x0F53
    65f6:	2c 25       	eor	r18, r12
    65f8:	3d 25       	eor	r19, r13
    65fa:	4e 25       	eor	r20, r14
    65fc:	5f 25       	eor	r21, r15
    65fe:	80 91 54 0f 	lds	r24, 0x0F54
    6602:	90 91 55 0f 	lds	r25, 0x0F55
    6606:	a0 91 56 0f 	lds	r26, 0x0F56
    660a:	b0 91 57 0f 	lds	r27, 0x0F57
    660e:	82 23       	and	r24, r18
    6610:	93 23       	and	r25, r19
    6612:	a4 23       	and	r26, r20
    6614:	b5 23       	and	r27, r21
    6616:	00 97       	sbiw	r24, 0x00	; 0
    6618:	a1 05       	cpc	r26, r1
    661a:	b1 05       	cpc	r27, r1
    661c:	a9 f4       	brne	.+42     	; 0x6648 <ipSend+0x132>
  {
    arpIpOut(0);  // local send
    661e:	60 e0       	ldi	r22, 0x00	; 0
    6620:	70 e0       	ldi	r23, 0x00	; 0
    6622:	80 e0       	ldi	r24, 0x00	; 0
    6624:	90 e0       	ldi	r25, 0x00	; 0
    6626:	0e 94 1f 39 	call	0x723e	; 0x723e <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    662a:	80 91 5c 0f 	lds	r24, 0x0F5C
    662e:	90 91 5d 0f 	lds	r25, 0x0F5D
    6632:	00 97       	sbiw	r24, 0x00	; 0
    6634:	49 f1       	breq	.+82     	; 0x6688 <ipSend+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet on local net\r\n"));
    6636:	00 d0       	rcall	.+0      	; 0x6638 <ipSend+0x122>
    6638:	00 d0       	rcall	.+0      	; 0x663a <ipSend+0x124>
    663a:	ed b7       	in	r30, 0x3d	; 61
    663c:	fe b7       	in	r31, 0x3e	; 62
    663e:	92 83       	std	Z+2, r25	; 0x02
    6640:	81 83       	std	Z+1, r24	; 0x01
    6642:	87 e4       	ldi	r24, 0x47	; 71
    6644:	9e e0       	ldi	r25, 0x0E	; 14
    6646:	18 c0       	rjmp	.+48     	; 0x6678 <ipSend+0x162>
#endif
  }
  else
  {
    arpIpOut(IpMyConfig.gateway);  // gateway send
    6648:	60 91 58 0f 	lds	r22, 0x0F58
    664c:	70 91 59 0f 	lds	r23, 0x0F59
    6650:	80 91 5a 0f 	lds	r24, 0x0F5A
    6654:	90 91 5b 0f 	lds	r25, 0x0F5B
    6658:	0e 94 1f 39 	call	0x723e	; 0x723e <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    665c:	80 91 5c 0f 	lds	r24, 0x0F5C
    6660:	90 91 5d 0f 	lds	r25, 0x0F5D
    6664:	00 97       	sbiw	r24, 0x00	; 0
    6666:	81 f0       	breq	.+32     	; 0x6688 <ipSend+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet to gateway\r\n"));
    6668:	00 d0       	rcall	.+0      	; 0x666a <ipSend+0x154>
    666a:	00 d0       	rcall	.+0      	; 0x666c <ipSend+0x156>
    666c:	ed b7       	in	r30, 0x3d	; 61
    666e:	fe b7       	in	r31, 0x3e	; 62
    6670:	92 83       	std	Z+2, r25	; 0x02
    6672:	81 83       	std	Z+1, r24	; 0x01
    6674:	88 e2       	ldi	r24, 0x28	; 40
    6676:	9e e0       	ldi	r25, 0x0E	; 14
    6678:	94 83       	std	Z+4, r25	; 0x04
    667a:	83 83       	std	Z+3, r24	; 0x03
    667c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6680:	0f 90       	pop	r0
    6682:	0f 90       	pop	r0
    6684:	0f 90       	pop	r0
    6686:	0f 90       	pop	r0

// adjust length to add ethernet header
  len += ETH_HEADER_LEN;

#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6688:	20 91 5c 0f 	lds	r18, 0x0F5C
    668c:	30 91 5d 0f 	lds	r19, 0x0F5D
    6690:	21 15       	cp	r18, r1
    6692:	31 05       	cpc	r19, r1
    6694:	11 f1       	breq	.+68     	; 0x66da <ipSend+0x1c4>
  {
    if (IpMyConfig.dbgLevel > 3)
    6696:	80 91 5e 0f 	lds	r24, 0x0F5E
    669a:	84 30       	cpi	r24, 0x04	; 4
    669c:	f0 f0       	brcs	.+60     	; 0x66da <ipSend+0x1c4>
    {
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(ETH_HEADER_LEN, &data[0]);"));
    669e:	00 d0       	rcall	.+0      	; 0x66a0 <ipSend+0x18a>
    66a0:	00 d0       	rcall	.+0      	; 0x66a2 <ipSend+0x18c>
    66a2:	ed b7       	in	r30, 0x3d	; 61
    66a4:	fe b7       	in	r31, 0x3e	; 62
    66a6:	32 83       	std	Z+2, r19	; 0x02
    66a8:	21 83       	std	Z+1, r18	; 0x01
    66aa:	8a ef       	ldi	r24, 0xFA	; 250
    66ac:	9d e0       	ldi	r25, 0x0D	; 13
    66ae:	94 83       	std	Z+4, r25	; 0x04
    66b0:	83 83       	std	Z+3, r24	; 0x03
    66b2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    66b6:	80 91 5c 0f 	lds	r24, 0x0F5C
    66ba:	90 91 5d 0f 	lds	r25, 0x0F5D
    66be:	ed b7       	in	r30, 0x3d	; 61
    66c0:	fe b7       	in	r31, 0x3e	; 62
    66c2:	92 83       	std	Z+2, r25	; 0x02
    66c4:	81 83       	std	Z+1, r24	; 0x01
    66c6:	8b eb       	ldi	r24, 0xBB	; 187
    66c8:	9d e0       	ldi	r25, 0x0D	; 13
    66ca:	94 83       	std	Z+4, r25	; 0x04
    66cc:	83 83       	std	Z+3, r24	; 0x03
    66ce:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    66d2:	0f 90       	pop	r0
    66d4:	0f 90       	pop	r0
    66d6:	0f 90       	pop	r0
    66d8:	0f 90       	pop	r0
    }
  }
#endif
// send it
  nicSend(len);
    66da:	ce 01       	movw	r24, r28
    66dc:	0e 96       	adiw	r24, 0x0e	; 14
    66de:	0e 94 10 2c 	call	0x5820	; 0x5820 <nicSend>
}
    66e2:	df 91       	pop	r29
    66e4:	cf 91       	pop	r28
    66e6:	1f 91       	pop	r17
    66e8:	0f 91       	pop	r16
    66ea:	ff 90       	pop	r15
    66ec:	ef 90       	pop	r14
    66ee:	df 90       	pop	r13
    66f0:	cf 90       	pop	r12
    66f2:	bf 90       	pop	r11
    66f4:	08 95       	ret

000066f6 <netstackIPv4Process>:
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
}

inline void netstackIPv4Process(void)
{
    66f6:	ef 92       	push	r14
    66f8:	ff 92       	push	r15
    66fa:	0f 93       	push	r16
    66fc:	1f 93       	push	r17
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    66fe:	e0 91 88 0e 	lds	r30, 0x0E88
    6702:	f0 91 89 0e 	lds	r31, 0x0E89
    6706:	e0 88       	ldd	r14, Z+16	; 0x10
    6708:	f1 88       	ldd	r15, Z+17	; 0x11
    670a:	02 89       	ldd	r16, Z+18	; 0x12
    670c:	13 89       	ldd	r17, Z+19	; 0x13
    670e:	20 91 50 0f 	lds	r18, 0x0F50
    6712:	30 91 51 0f 	lds	r19, 0x0F51
    6716:	40 91 52 0f 	lds	r20, 0x0F52
    671a:	50 91 53 0f 	lds	r21, 0x0F53
    671e:	e2 16       	cp	r14, r18
    6720:	f3 06       	cpc	r15, r19
    6722:	04 07       	cpc	r16, r20
    6724:	15 07       	cpc	r17, r21
    6726:	d9 f0       	breq	.+54     	; 0x675e <netstackIPv4Process+0x68>
    6728:	80 91 54 0f 	lds	r24, 0x0F54
    672c:	90 91 55 0f 	lds	r25, 0x0F55
    6730:	a0 91 56 0f 	lds	r26, 0x0F56
    6734:	b0 91 57 0f 	lds	r27, 0x0F57
    6738:	28 2b       	or	r18, r24
    673a:	39 2b       	or	r19, r25
    673c:	4a 2b       	or	r20, r26
    673e:	5b 2b       	or	r21, r27
    6740:	e2 16       	cp	r14, r18
    6742:	f3 06       	cpc	r15, r19
    6744:	04 07       	cpc	r16, r20
    6746:	15 07       	cpc	r17, r21
    6748:	51 f0       	breq	.+20     	; 0x675e <netstackIPv4Process+0x68>
    674a:	8f ef       	ldi	r24, 0xFF	; 255
    674c:	e8 16       	cp	r14, r24
    674e:	8f ef       	ldi	r24, 0xFF	; 255
    6750:	f8 06       	cpc	r15, r24
    6752:	8f ef       	ldi	r24, 0xFF	; 255
    6754:	08 07       	cpc	r16, r24
    6756:	8f ef       	ldi	r24, 0xFF	; 255
    6758:	18 07       	cpc	r17, r24
    675a:	09 f0       	breq	.+2      	; 0x675e <netstackIPv4Process+0x68>
    675c:	8e c0       	rjmp	.+284    	; 0x687a <netstackIPv4Process+0x184>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
      (nicState.layer3.ip->destipaddr != 0xFFFFFFFF)) 
    return;

// handle ICMP packet
  if(nicState.layer3.ip->proto == IP_PROTO_ICMP)
    675e:	81 85       	ldd	r24, Z+9	; 0x09
    6760:	81 30       	cpi	r24, 0x01	; 1
    6762:	81 f5       	brne	.+96     	; 0x67c4 <netstackIPv4Process+0xce>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6764:	20 91 5c 0f 	lds	r18, 0x0F5C
    6768:	30 91 5d 0f 	lds	r19, 0x0F5D
    676c:	21 15       	cp	r18, r1
    676e:	31 05       	cpc	r19, r1
    6770:	31 f1       	breq	.+76     	; 0x67be <netstackIPv4Process+0xc8>
    {
      if (IpMyConfig.dbgLevel > 0)
    6772:	80 91 5e 0f 	lds	r24, 0x0F5E
    6776:	88 23       	and	r24, r24
    6778:	81 f0       	breq	.+32     	; 0x679a <netstackIPv4Process+0xa4>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
    677a:	00 d0       	rcall	.+0      	; 0x677c <netstackIPv4Process+0x86>
    677c:	00 d0       	rcall	.+0      	; 0x677e <netstackIPv4Process+0x88>
    677e:	ed b7       	in	r30, 0x3d	; 61
    6780:	fe b7       	in	r31, 0x3e	; 62
    6782:	32 83       	std	Z+2, r19	; 0x02
    6784:	21 83       	std	Z+1, r18	; 0x01
    6786:	84 eb       	ldi	r24, 0xB4	; 180
    6788:	9e e0       	ldi	r25, 0x0E	; 14
    678a:	94 83       	std	Z+4, r25	; 0x04
    678c:	83 83       	std	Z+3, r24	; 0x03
    678e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6792:	0f 90       	pop	r0
    6794:	0f 90       	pop	r0
    6796:	0f 90       	pop	r0
    6798:	0f 90       	pop	r0
      if (IpMyConfig.dbgLevel > 2)
    679a:	80 91 5e 0f 	lds	r24, 0x0F5E
    679e:	83 30       	cpi	r24, 0x03	; 3
    67a0:	70 f0       	brcs	.+28     	; 0x67be <netstackIPv4Process+0xc8>
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    67a2:	60 91 88 0e 	lds	r22, 0x0E88
    67a6:	70 91 89 0e 	lds	r23, 0x0E89
    67aa:	40 91 8a 0e 	lds	r20, 0x0E8A
    67ae:	50 91 8b 0e 	lds	r21, 0x0E8B
    67b2:	80 91 5c 0f 	lds	r24, 0x0F5C
    67b6:	90 91 5d 0f 	lds	r25, 0x0F5D
    67ba:	0e 94 a0 34 	call	0x6940	; 0x6940 <icmpPrintHeader>
    }
#endif /*IP_DEBUG*/
    icmpIpIn();
    67be:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <icmpIpIn>
    67c2:	5b c0       	rjmp	.+182    	; 0x687a <netstackIPv4Process+0x184>
    return;
  }
  if( nicState.layer3.ip->proto == IP_PROTO_UDP )
    67c4:	81 31       	cpi	r24, 0x11	; 17
    67c6:	f1 f4       	brne	.+60     	; 0x6804 <netstackIPv4Process+0x10e>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    67c8:	20 91 5c 0f 	lds	r18, 0x0F5C
    67cc:	30 91 5d 0f 	lds	r19, 0x0F5D
    67d0:	21 15       	cp	r18, r1
    67d2:	31 05       	cpc	r19, r1
    67d4:	a1 f0       	breq	.+40     	; 0x67fe <netstackIPv4Process+0x108>
    {
      if (IpMyConfig.dbgLevel > 0)
    67d6:	80 91 5e 0f 	lds	r24, 0x0F5E
    67da:	88 23       	and	r24, r24
    67dc:	81 f0       	breq	.+32     	; 0x67fe <netstackIPv4Process+0x108>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    67de:	00 d0       	rcall	.+0      	; 0x67e0 <netstackIPv4Process+0xea>
    67e0:	00 d0       	rcall	.+0      	; 0x67e2 <netstackIPv4Process+0xec>
    67e2:	ed b7       	in	r30, 0x3d	; 61
    67e4:	fe b7       	in	r31, 0x3e	; 62
    67e6:	32 83       	std	Z+2, r19	; 0x02
    67e8:	21 83       	std	Z+1, r18	; 0x01
    67ea:	8c e9       	ldi	r24, 0x9C	; 156
    67ec:	9e e0       	ldi	r25, 0x0E	; 14
    67ee:	94 83       	std	Z+4, r25	; 0x04
    67f0:	83 83       	std	Z+3, r24	; 0x03
    67f2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    67f6:	0f 90       	pop	r0
    67f8:	0f 90       	pop	r0
    67fa:	0f 90       	pop	r0
    67fc:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackUDPIPProcess();
    67fe:	0e 94 ef 3d 	call	0x7bde	; 0x7bde <netstackUDPIPProcess>
    6802:	3b c0       	rjmp	.+118    	; 0x687a <netstackIPv4Process+0x184>
    return;
  }
  if( nicState.layer3.ip->proto == IP_PROTO_TCP )
    6804:	86 30       	cpi	r24, 0x06	; 6
    6806:	f1 f4       	brne	.+60     	; 0x6844 <netstackIPv4Process+0x14e>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6808:	20 91 5c 0f 	lds	r18, 0x0F5C
    680c:	30 91 5d 0f 	lds	r19, 0x0F5D
    6810:	21 15       	cp	r18, r1
    6812:	31 05       	cpc	r19, r1
    6814:	a1 f0       	breq	.+40     	; 0x683e <netstackIPv4Process+0x148>
    {
      if (IpMyConfig.dbgLevel > 0)
    6816:	80 91 5e 0f 	lds	r24, 0x0F5E
    681a:	88 23       	and	r24, r24
    681c:	81 f0       	breq	.+32     	; 0x683e <netstackIPv4Process+0x148>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: TCP/IP packet\r\n"));
    681e:	00 d0       	rcall	.+0      	; 0x6820 <netstackIPv4Process+0x12a>
    6820:	00 d0       	rcall	.+0      	; 0x6822 <netstackIPv4Process+0x12c>
    6822:	ed b7       	in	r30, 0x3d	; 61
    6824:	fe b7       	in	r31, 0x3e	; 62
    6826:	32 83       	std	Z+2, r19	; 0x02
    6828:	21 83       	std	Z+1, r18	; 0x01
    682a:	84 e8       	ldi	r24, 0x84	; 132
    682c:	9e e0       	ldi	r25, 0x0E	; 14
    682e:	94 83       	std	Z+4, r25	; 0x04
    6830:	83 83       	std	Z+3, r24	; 0x03
    6832:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6836:	0f 90       	pop	r0
    6838:	0f 90       	pop	r0
    683a:	0f 90       	pop	r0
    683c:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackTCPIPProcess();
    683e:	0e 94 bd 3c 	call	0x797a	; 0x797a <netstackTCPIPProcess>
    6842:	1b c0       	rjmp	.+54     	; 0x687a <netstackIPv4Process+0x184>
    return;
  }
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6844:	20 91 5c 0f 	lds	r18, 0x0F5C
    6848:	30 91 5d 0f 	lds	r19, 0x0F5D
    684c:	21 15       	cp	r18, r1
    684e:	31 05       	cpc	r19, r1
    6850:	a1 f0       	breq	.+40     	; 0x687a <netstackIPv4Process+0x184>
  {
    if (IpMyConfig.dbgLevel > 0)
    6852:	80 91 5e 0f 	lds	r24, 0x0F5E
    6856:	88 23       	and	r24, r24
    6858:	81 f0       	breq	.+32     	; 0x687a <netstackIPv4Process+0x184>
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
    685a:	00 d0       	rcall	.+0      	; 0x685c <netstackIPv4Process+0x166>
    685c:	00 d0       	rcall	.+0      	; 0x685e <netstackIPv4Process+0x168>
    685e:	ed b7       	in	r30, 0x3d	; 61
    6860:	fe b7       	in	r31, 0x3e	; 62
    6862:	32 83       	std	Z+2, r19	; 0x02
    6864:	21 83       	std	Z+1, r18	; 0x01
    6866:	88 e6       	ldi	r24, 0x68	; 104
    6868:	9e e0       	ldi	r25, 0x0E	; 14
    686a:	94 83       	std	Z+4, r25	; 0x04
    686c:	83 83       	std	Z+3, r24	; 0x03
    686e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6872:	0f 90       	pop	r0
    6874:	0f 90       	pop	r0
    6876:	0f 90       	pop	r0
    6878:	0f 90       	pop	r0
  }
#endif /*IP_DEBUG*/
}
    687a:	1f 91       	pop	r17
    687c:	0f 91       	pop	r16
    687e:	ff 90       	pop	r15
    6880:	ef 90       	pop	r14
    6882:	08 95       	ret

00006884 <ipSaveConfig>:
#endif
}

void ipSaveConfig(void)
{
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
    6884:	40 91 50 0f 	lds	r20, 0x0F50
    6888:	50 91 51 0f 	lds	r21, 0x0F51
    688c:	60 91 52 0f 	lds	r22, 0x0F52
    6890:	70 91 53 0f 	lds	r23, 0x0F53
    6894:	8e e1       	ldi	r24, 0x1E	; 30
    6896:	90 e0       	ldi	r25, 0x00	; 0
    6898:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__eeupd_dword_m128>
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
    689c:	40 91 54 0f 	lds	r20, 0x0F54
    68a0:	50 91 55 0f 	lds	r21, 0x0F55
    68a4:	60 91 56 0f 	lds	r22, 0x0F56
    68a8:	70 91 57 0f 	lds	r23, 0x0F57
    68ac:	82 e2       	ldi	r24, 0x22	; 34
    68ae:	90 e0       	ldi	r25, 0x00	; 0
    68b0:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__eeupd_dword_m128>
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    68b4:	40 91 58 0f 	lds	r20, 0x0F58
    68b8:	50 91 59 0f 	lds	r21, 0x0F59
    68bc:	60 91 5a 0f 	lds	r22, 0x0F5A
    68c0:	70 91 5b 0f 	lds	r23, 0x0F5B
    68c4:	86 e2       	ldi	r24, 0x26	; 38
    68c6:	90 e0       	ldi	r25, 0x00	; 0
    68c8:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__eeupd_dword_m128>
}
    68cc:	08 95       	ret

000068ce <ipInit>:
static uint32_t mask_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_MASK4 << 24) + ((uint32_t)MY_MASK3 <<16) + ((uint32_t)MY_MASK2 <<8) + MY_MASK1;
static uint32_t defGw_eep   __attribute__((section (".eeprom"))) = ((uint32_t)MY_GW4   << 24) + ((uint32_t)MY_GW3   <<16) + ((uint32_t)MY_GW2   <<8) + MY_GW1;

void ipInit(void)
{
  IpMyConfig.ip      = eeprom_read_dword(&myip_eep);
    68ce:	8e e1       	ldi	r24, 0x1E	; 30
    68d0:	90 e0       	ldi	r25, 0x00	; 0
    68d2:	0e 94 be 5c 	call	0xb97c	; 0xb97c <__eerd_dword_m128>
    68d6:	60 93 50 0f 	sts	0x0F50, r22
    68da:	70 93 51 0f 	sts	0x0F51, r23
    68de:	80 93 52 0f 	sts	0x0F52, r24
    68e2:	90 93 53 0f 	sts	0x0F53, r25
  IpMyConfig.netmask = eeprom_read_dword(&mask_eep);
    68e6:	82 e2       	ldi	r24, 0x22	; 34
    68e8:	90 e0       	ldi	r25, 0x00	; 0
    68ea:	0e 94 be 5c 	call	0xb97c	; 0xb97c <__eerd_dword_m128>
    68ee:	60 93 54 0f 	sts	0x0F54, r22
    68f2:	70 93 55 0f 	sts	0x0F55, r23
    68f6:	80 93 56 0f 	sts	0x0F56, r24
    68fa:	90 93 57 0f 	sts	0x0F57, r25
  IpMyConfig.gateway = eeprom_read_dword(&defGw_eep);
    68fe:	86 e2       	ldi	r24, 0x26	; 38
    6900:	90 e0       	ldi	r25, 0x00	; 0
    6902:	0e 94 be 5c 	call	0xb97c	; 0xb97c <__eerd_dword_m128>
    6906:	60 93 58 0f 	sts	0x0F58, r22
    690a:	70 93 59 0f 	sts	0x0F59, r23
    690e:	80 93 5a 0f 	sts	0x0F5A, r24
    6912:	90 93 5b 0f 	sts	0x0F5B, r25
#if IP_DEBUG
  IpMyConfig.dbgLevel = 0;
    6916:	10 92 5e 0f 	sts	0x0F5E, r1
  IpMyConfig.dbgStream = NULL;
    691a:	10 92 5d 0f 	sts	0x0F5D, r1
    691e:	10 92 5c 0f 	sts	0x0F5C, r1
#endif
}
    6922:	08 95       	ret

00006924 <icmpInit>:


// functions
void icmpInit(void)
{
  icmpDebug = NULL;
    6924:	10 92 ab 0e 	sts	0x0EAB, r1
    6928:	10 92 aa 0e 	sts	0x0EAA, r1
  icmpDebugLevel = 0;
    692c:	10 92 4d 0f 	sts	0x0F4D, r1
}
    6930:	08 95       	ret

00006932 <setIcmpDebug>:
}

#if ICMP_DEBUG
void setIcmpDebug(FILE *stream, uint8_t level)
{
  icmpDebug = stream;
    6932:	90 93 ab 0e 	sts	0x0EAB, r25
    6936:	80 93 aa 0e 	sts	0x0EAA, r24
  icmpDebugLevel = level;
    693a:	60 93 4d 0f 	sts	0x0F4D, r22
}
    693e:	08 95       	ret

00006940 <icmpPrintHeader>:
#endif

void icmpPrintHeader(FILE *stream, struct netIpHeader *ipPacket, struct netIcmpHeader *icmpPacket)
{
    6940:	ef 92       	push	r14
    6942:	ff 92       	push	r15
    6944:	0f 93       	push	r16
    6946:	1f 93       	push	r17
    6948:	cf 93       	push	r28
    694a:	df 93       	push	r29
    694c:	ec 01       	movw	r28, r24
    694e:	8b 01       	movw	r16, r22
    6950:	7a 01       	movw	r14, r20
  fprintf_P(stream, PSTR("ICMP Packet:\r\n"));
    6952:	00 d0       	rcall	.+0      	; 0x6954 <icmpPrintHeader+0x14>
    6954:	00 d0       	rcall	.+0      	; 0x6956 <icmpPrintHeader+0x16>
    6956:	ad b7       	in	r26, 0x3d	; 61
    6958:	be b7       	in	r27, 0x3e	; 62
    695a:	12 96       	adiw	r26, 0x02	; 2
    695c:	9c 93       	st	X, r25
    695e:	8e 93       	st	-X, r24
    6960:	11 97       	sbiw	r26, 0x01	; 1
    6962:	80 e2       	ldi	r24, 0x20	; 32
    6964:	9f e0       	ldi	r25, 0x0F	; 15
    6966:	14 96       	adiw	r26, 0x04	; 4
    6968:	9c 93       	st	X, r25
    696a:	8e 93       	st	-X, r24
    696c:	13 97       	sbiw	r26, 0x03	; 3
    696e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print source IP address
  fprintf_P(stream, PSTR("SrcIpAddr: "));  netPrintIPAddr(stream, ipPacket->srcipaddr);  fprintf_P(stream, PSTR("\r\n"));
    6972:	ed b7       	in	r30, 0x3d	; 61
    6974:	fe b7       	in	r31, 0x3e	; 62
    6976:	d2 83       	std	Z+2, r29	; 0x02
    6978:	c1 83       	std	Z+1, r28	; 0x01
    697a:	84 e1       	ldi	r24, 0x14	; 20
    697c:	9f e0       	ldi	r25, 0x0F	; 15
    697e:	94 83       	std	Z+4, r25	; 0x04
    6980:	83 83       	std	Z+3, r24	; 0x03
    6982:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6986:	0f 90       	pop	r0
    6988:	0f 90       	pop	r0
    698a:	0f 90       	pop	r0
    698c:	0f 90       	pop	r0
    698e:	d8 01       	movw	r26, r16
    6990:	1c 96       	adiw	r26, 0x0c	; 12
    6992:	4d 91       	ld	r20, X+
    6994:	5d 91       	ld	r21, X+
    6996:	6d 91       	ld	r22, X+
    6998:	7c 91       	ld	r23, X
    699a:	1f 97       	sbiw	r26, 0x0f	; 15
    699c:	ce 01       	movw	r24, r28
    699e:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    69a2:	00 d0       	rcall	.+0      	; 0x69a4 <icmpPrintHeader+0x64>
    69a4:	00 d0       	rcall	.+0      	; 0x69a6 <icmpPrintHeader+0x66>
    69a6:	ed b7       	in	r30, 0x3d	; 61
    69a8:	fe b7       	in	r31, 0x3e	; 62
    69aa:	d2 83       	std	Z+2, r29	; 0x02
    69ac:	c1 83       	std	Z+1, r28	; 0x01
    69ae:	81 e1       	ldi	r24, 0x11	; 17
    69b0:	9f e0       	ldi	r25, 0x0F	; 15
    69b2:	94 83       	std	Z+4, r25	; 0x04
    69b4:	83 83       	std	Z+3, r24	; 0x03
    69b6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print dest IP address
  fprintf_P(stream, PSTR("DstIpAddr: "));  netPrintIPAddr(stream, ipPacket->destipaddr); fprintf_P(stream, PSTR("\r\n"));
    69ba:	ad b7       	in	r26, 0x3d	; 61
    69bc:	be b7       	in	r27, 0x3e	; 62
    69be:	12 96       	adiw	r26, 0x02	; 2
    69c0:	dc 93       	st	X, r29
    69c2:	ce 93       	st	-X, r28
    69c4:	11 97       	sbiw	r26, 0x01	; 1
    69c6:	85 e0       	ldi	r24, 0x05	; 5
    69c8:	9f e0       	ldi	r25, 0x0F	; 15
    69ca:	14 96       	adiw	r26, 0x04	; 4
    69cc:	9c 93       	st	X, r25
    69ce:	8e 93       	st	-X, r24
    69d0:	13 97       	sbiw	r26, 0x03	; 3
    69d2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    69d6:	0f 90       	pop	r0
    69d8:	0f 90       	pop	r0
    69da:	0f 90       	pop	r0
    69dc:	0f 90       	pop	r0
    69de:	f8 01       	movw	r30, r16
    69e0:	40 89       	ldd	r20, Z+16	; 0x10
    69e2:	51 89       	ldd	r21, Z+17	; 0x11
    69e4:	62 89       	ldd	r22, Z+18	; 0x12
    69e6:	73 89       	ldd	r23, Z+19	; 0x13
    69e8:	ce 01       	movw	r24, r28
    69ea:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    69ee:	00 d0       	rcall	.+0      	; 0x69f0 <icmpPrintHeader+0xb0>
    69f0:	00 d0       	rcall	.+0      	; 0x69f2 <icmpPrintHeader+0xb2>
    69f2:	ad b7       	in	r26, 0x3d	; 61
    69f4:	be b7       	in	r27, 0x3e	; 62
    69f6:	12 96       	adiw	r26, 0x02	; 2
    69f8:	dc 93       	st	X, r29
    69fa:	ce 93       	st	-X, r28
    69fc:	11 97       	sbiw	r26, 0x01	; 1
    69fe:	82 e0       	ldi	r24, 0x02	; 2
    6a00:	9f e0       	ldi	r25, 0x0F	; 15
    6a02:	14 96       	adiw	r26, 0x04	; 4
    6a04:	9c 93       	st	X, r25
    6a06:	8e 93       	st	-X, r24
    6a08:	13 97       	sbiw	r26, 0x03	; 3
    6a0a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print type
  fprintf_P(stream, PSTR("Type   : "));
    6a0e:	ed b7       	in	r30, 0x3d	; 61
    6a10:	fe b7       	in	r31, 0x3e	; 62
    6a12:	d2 83       	std	Z+2, r29	; 0x02
    6a14:	c1 83       	std	Z+1, r28	; 0x01
    6a16:	88 ef       	ldi	r24, 0xF8	; 248
    6a18:	9e e0       	ldi	r25, 0x0E	; 14
    6a1a:	94 83       	std	Z+4, r25	; 0x04
    6a1c:	83 83       	std	Z+3, r24	; 0x03
    6a1e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  switch(icmpPacket->type)
    6a22:	0f 90       	pop	r0
    6a24:	0f 90       	pop	r0
    6a26:	0f 90       	pop	r0
    6a28:	0f 90       	pop	r0
    6a2a:	d7 01       	movw	r26, r14
    6a2c:	8c 91       	ld	r24, X
    6a2e:	88 23       	and	r24, r24
    6a30:	59 f0       	breq	.+22     	; 0x6a48 <icmpPrintHeader+0x108>
    6a32:	88 30       	cpi	r24, 0x08	; 8
    6a34:	c1 f4       	brne	.+48     	; 0x6a66 <icmpPrintHeader+0x126>
  {
    case ICMP_TYPE_ECHOREQUEST:
      fprintf_P(stream, PSTR("ECHO REQUEST"));
    6a36:	00 d0       	rcall	.+0      	; 0x6a38 <icmpPrintHeader+0xf8>
    6a38:	00 d0       	rcall	.+0      	; 0x6a3a <icmpPrintHeader+0xfa>
    6a3a:	ed b7       	in	r30, 0x3d	; 61
    6a3c:	fe b7       	in	r31, 0x3e	; 62
    6a3e:	d2 83       	std	Z+2, r29	; 0x02
    6a40:	c1 83       	std	Z+1, r28	; 0x01
    6a42:	8b ee       	ldi	r24, 0xEB	; 235
    6a44:	9e e0       	ldi	r25, 0x0E	; 14
    6a46:	17 c0       	rjmp	.+46     	; 0x6a76 <icmpPrintHeader+0x136>
      break;
    case ICMP_TYPE_ECHOREPLY:
      fprintf_P(stream, PSTR("ECHO REPLY"));
    6a48:	00 d0       	rcall	.+0      	; 0x6a4a <icmpPrintHeader+0x10a>
    6a4a:	00 d0       	rcall	.+0      	; 0x6a4c <icmpPrintHeader+0x10c>
    6a4c:	ad b7       	in	r26, 0x3d	; 61
    6a4e:	be b7       	in	r27, 0x3e	; 62
    6a50:	12 96       	adiw	r26, 0x02	; 2
    6a52:	dc 93       	st	X, r29
    6a54:	ce 93       	st	-X, r28
    6a56:	11 97       	sbiw	r26, 0x01	; 1
    6a58:	80 ee       	ldi	r24, 0xE0	; 224
    6a5a:	9e e0       	ldi	r25, 0x0E	; 14
    6a5c:	14 96       	adiw	r26, 0x04	; 4
    6a5e:	9c 93       	st	X, r25
    6a60:	8e 93       	st	-X, r24
    6a62:	13 97       	sbiw	r26, 0x03	; 3
    6a64:	0a c0       	rjmp	.+20     	; 0x6a7a <icmpPrintHeader+0x13a>
      break;
    default:
      fprintf_P(stream, ("UNKNOWN"));
    6a66:	00 d0       	rcall	.+0      	; 0x6a68 <icmpPrintHeader+0x128>
    6a68:	00 d0       	rcall	.+0      	; 0x6a6a <icmpPrintHeader+0x12a>
    6a6a:	ed b7       	in	r30, 0x3d	; 61
    6a6c:	fe b7       	in	r31, 0x3e	; 62
    6a6e:	d2 83       	std	Z+2, r29	; 0x02
    6a70:	c1 83       	std	Z+1, r28	; 0x01
    6a72:	8f e5       	ldi	r24, 0x5F	; 95
    6a74:	91 e0       	ldi	r25, 0x01	; 1
    6a76:	94 83       	std	Z+4, r25	; 0x04
    6a78:	83 83       	std	Z+3, r24	; 0x03
    6a7a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      break;
  }
  fprintf_P(stream, PSTR("\r\n"));
    6a7e:	ad b7       	in	r26, 0x3d	; 61
    6a80:	be b7       	in	r27, 0x3e	; 62
    6a82:	12 96       	adiw	r26, 0x02	; 2
    6a84:	dc 93       	st	X, r29
    6a86:	ce 93       	st	-X, r28
    6a88:	11 97       	sbiw	r26, 0x01	; 1
    6a8a:	8d ed       	ldi	r24, 0xDD	; 221
    6a8c:	9e e0       	ldi	r25, 0x0E	; 14
    6a8e:	14 96       	adiw	r26, 0x04	; 4
    6a90:	9c 93       	st	X, r25
    6a92:	8e 93       	st	-X, r24
    6a94:	13 97       	sbiw	r26, 0x03	; 3
    6a96:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print code
  fprintf_P(stream, PSTR("Code   : 0x%x\r\n"), icmpPacket->icode);
    6a9a:	00 d0       	rcall	.+0      	; 0x6a9c <icmpPrintHeader+0x15c>
    6a9c:	ed b7       	in	r30, 0x3d	; 61
    6a9e:	fe b7       	in	r31, 0x3e	; 62
    6aa0:	31 96       	adiw	r30, 0x01	; 1
    6aa2:	ad b7       	in	r26, 0x3d	; 61
    6aa4:	be b7       	in	r27, 0x3e	; 62
    6aa6:	12 96       	adiw	r26, 0x02	; 2
    6aa8:	dc 93       	st	X, r29
    6aaa:	ce 93       	st	-X, r28
    6aac:	11 97       	sbiw	r26, 0x01	; 1
    6aae:	8d ec       	ldi	r24, 0xCD	; 205
    6ab0:	9e e0       	ldi	r25, 0x0E	; 14
    6ab2:	93 83       	std	Z+3, r25	; 0x03
    6ab4:	82 83       	std	Z+2, r24	; 0x02
    6ab6:	d7 01       	movw	r26, r14
    6ab8:	11 96       	adiw	r26, 0x01	; 1
    6aba:	8c 91       	ld	r24, X
    6abc:	84 83       	std	Z+4, r24	; 0x04
    6abe:	15 82       	std	Z+5, r1	; 0x05
    6ac0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6ac4:	ed b7       	in	r30, 0x3d	; 61
    6ac6:	fe b7       	in	r31, 0x3e	; 62
    6ac8:	36 96       	adiw	r30, 0x06	; 6
    6aca:	0f b6       	in	r0, 0x3f	; 63
    6acc:	f8 94       	cli
    6ace:	fe bf       	out	0x3e, r31	; 62
    6ad0:	0f be       	out	0x3f, r0	; 63
    6ad2:	ed bf       	out	0x3d, r30	; 61
}
    6ad4:	df 91       	pop	r29
    6ad6:	cf 91       	pop	r28
    6ad8:	1f 91       	pop	r17
    6ada:	0f 91       	pop	r16
    6adc:	ff 90       	pop	r15
    6ade:	ef 90       	pop	r14
    6ae0:	08 95       	ret

00006ae2 <icmpEchoRequest>:
      break;
  }
}

void icmpEchoRequest(void)
{
    6ae2:	0f 93       	push	r16
    6ae4:	1f 93       	push	r17
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6ae6:	20 91 aa 0e 	lds	r18, 0x0EAA
    6aea:	30 91 ab 0e 	lds	r19, 0x0EAB
    6aee:	21 15       	cp	r18, r1
    6af0:	31 05       	cpc	r19, r1
    6af2:	a1 f0       	breq	.+40     	; 0x6b1c <icmpEchoRequest+0x3a>
  {
    if (icmpDebugLevel > 1)
    6af4:	80 91 4d 0f 	lds	r24, 0x0F4D
    6af8:	82 30       	cpi	r24, 0x02	; 2
    6afa:	80 f0       	brcs	.+32     	; 0x6b1c <icmpEchoRequest+0x3a>
      fprintf_P(icmpDebug, PSTR("Received ICMP request: "));
    6afc:	00 d0       	rcall	.+0      	; 0x6afe <icmpEchoRequest+0x1c>
    6afe:	00 d0       	rcall	.+0      	; 0x6b00 <icmpEchoRequest+0x1e>
    6b00:	ed b7       	in	r30, 0x3d	; 61
    6b02:	fe b7       	in	r31, 0x3e	; 62
    6b04:	32 83       	std	Z+2, r19	; 0x02
    6b06:	21 83       	std	Z+1, r18	; 0x01
    6b08:	83 e4       	ldi	r24, 0x43	; 67
    6b0a:	9f e0       	ldi	r25, 0x0F	; 15
    6b0c:	94 83       	std	Z+4, r25	; 0x04
    6b0e:	83 83       	std	Z+3, r24	; 0x03
    6b10:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6b14:	0f 90       	pop	r0
    6b16:	0f 90       	pop	r0
    6b18:	0f 90       	pop	r0
    6b1a:	0f 90       	pop	r0
  }
#endif
  uint32_t tempIp;

  // change type to reply
  nicState.layer4.icmp->type = ICMP_TYPE_ECHOREPLY;
    6b1c:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6b20:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6b24:	10 82       	st	Z, r1
  // recalculate checksum
  nicState.layer4.icmp->icmpchksum = 0;
    6b26:	00 91 8a 0e 	lds	r16, 0x0E8A
    6b2a:	10 91 8b 0e 	lds	r17, 0x0E8B
    6b2e:	f8 01       	movw	r30, r16
    6b30:	13 82       	std	Z+3, r1	; 0x03
    6b32:	12 82       	std	Z+2, r1	; 0x02
  nicState.layer4.icmp->icmpchksum = netChecksum((uint8_t*)(nicState.layer4.icmp), htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
    6b34:	e0 91 88 0e 	lds	r30, 0x0E88
    6b38:	f0 91 89 0e 	lds	r31, 0x0E89
    6b3c:	82 81       	ldd	r24, Z+2	; 0x02
    6b3e:	93 81       	ldd	r25, Z+3	; 0x03
    6b40:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    6b44:	bc 01       	movw	r22, r24
    6b46:	64 51       	subi	r22, 0x14	; 20
    6b48:	70 40       	sbci	r23, 0x00	; 0
    6b4a:	c8 01       	movw	r24, r16
    6b4c:	0e 94 fa 2d 	call	0x5bf4	; 0x5bf4 <netChecksum>
    6b50:	f8 01       	movw	r30, r16
    6b52:	93 83       	std	Z+3, r25	; 0x03
    6b54:	82 83       	std	Z+2, r24	; 0x02
  // return to sender
  tempIp = nicState.layer3.ip->destipaddr;
    6b56:	e0 91 88 0e 	lds	r30, 0x0E88
    6b5a:	f0 91 89 0e 	lds	r31, 0x0E89
    6b5e:	20 89       	ldd	r18, Z+16	; 0x10
    6b60:	31 89       	ldd	r19, Z+17	; 0x11
    6b62:	42 89       	ldd	r20, Z+18	; 0x12
    6b64:	53 89       	ldd	r21, Z+19	; 0x13
  nicState.layer3.ip->destipaddr = nicState.layer3.ip->srcipaddr;
    6b66:	84 85       	ldd	r24, Z+12	; 0x0c
    6b68:	95 85       	ldd	r25, Z+13	; 0x0d
    6b6a:	a6 85       	ldd	r26, Z+14	; 0x0e
    6b6c:	b7 85       	ldd	r27, Z+15	; 0x0f
    6b6e:	80 8b       	std	Z+16, r24	; 0x10
    6b70:	91 8b       	std	Z+17, r25	; 0x11
    6b72:	a2 8b       	std	Z+18, r26	; 0x12
    6b74:	b3 8b       	std	Z+19, r27	; 0x13
  nicState.layer3.ip->srcipaddr = tempIp;
    6b76:	24 87       	std	Z+12, r18	; 0x0c
    6b78:	35 87       	std	Z+13, r19	; 0x0d
    6b7a:	46 87       	std	Z+14, r20	; 0x0e
    6b7c:	57 87       	std	Z+15, r21	; 0x0f
  // add ethernet routing
  arpIpOut(0);
    6b7e:	60 e0       	ldi	r22, 0x00	; 0
    6b80:	70 e0       	ldi	r23, 0x00	; 0
    6b82:	80 e0       	ldi	r24, 0x00	; 0
    6b84:	90 e0       	ldi	r25, 0x00	; 0
    6b86:	0e 94 1f 39 	call	0x723e	; 0x723e <arpIpOut>

  // debugging
  if (icmpDebug != NULL)
    6b8a:	80 91 aa 0e 	lds	r24, 0x0EAA
    6b8e:	90 91 ab 0e 	lds	r25, 0x0EAB
    6b92:	00 97       	sbiw	r24, 0x00	; 0
    6b94:	51 f0       	breq	.+20     	; 0x6baa <icmpEchoRequest+0xc8>
    icmpPrintHeader(icmpDebug, nicState.layer3.ip, nicState.layer4.icmp);
    6b96:	60 91 88 0e 	lds	r22, 0x0E88
    6b9a:	70 91 89 0e 	lds	r23, 0x0E89
    6b9e:	40 91 8a 0e 	lds	r20, 0x0E8A
    6ba2:	50 91 8b 0e 	lds	r21, 0x0E8B
    6ba6:	0e 94 a0 34 	call	0x6940	; 0x6940 <icmpPrintHeader>
  //debugPrintHexTable(htons(packet->ip.len), (uint8_t*)packet);

  // send it (packet->ip.len+ETH_HEADER_LEN
  nicSend(htons(nicState.layer3.ip->len) + ETH_HEADER_LEN);
    6baa:	e0 91 88 0e 	lds	r30, 0x0E88
    6bae:	f0 91 89 0e 	lds	r31, 0x0E89
    6bb2:	82 81       	ldd	r24, Z+2	; 0x02
    6bb4:	93 81       	ldd	r25, Z+3	; 0x03
    6bb6:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    6bba:	0e 96       	adiw	r24, 0x0e	; 14
    6bbc:	0e 94 10 2c 	call	0x5820	; 0x5820 <nicSend>
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6bc0:	20 91 aa 0e 	lds	r18, 0x0EAA
    6bc4:	30 91 ab 0e 	lds	r19, 0x0EAB
    6bc8:	21 15       	cp	r18, r1
    6bca:	31 05       	cpc	r19, r1
    6bcc:	a1 f0       	breq	.+40     	; 0x6bf6 <icmpEchoRequest+0x114>
  {
    if (icmpDebugLevel > 1)
    6bce:	80 91 4d 0f 	lds	r24, 0x0F4D
    6bd2:	82 30       	cpi	r24, 0x02	; 2
    6bd4:	80 f0       	brcs	.+32     	; 0x6bf6 <icmpEchoRequest+0x114>
      fprintf_P(icmpDebug, PSTR("Sending ICMP PONG\r\n"));
    6bd6:	00 d0       	rcall	.+0      	; 0x6bd8 <icmpEchoRequest+0xf6>
    6bd8:	00 d0       	rcall	.+0      	; 0x6bda <icmpEchoRequest+0xf8>
    6bda:	ed b7       	in	r30, 0x3d	; 61
    6bdc:	fe b7       	in	r31, 0x3e	; 62
    6bde:	32 83       	std	Z+2, r19	; 0x02
    6be0:	21 83       	std	Z+1, r18	; 0x01
    6be2:	8f e2       	ldi	r24, 0x2F	; 47
    6be4:	9f e0       	ldi	r25, 0x0F	; 15
    6be6:	94 83       	std	Z+4, r25	; 0x04
    6be8:	83 83       	std	Z+3, r24	; 0x03
    6bea:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6bee:	0f 90       	pop	r0
    6bf0:	0f 90       	pop	r0
    6bf2:	0f 90       	pop	r0
    6bf4:	0f 90       	pop	r0
  }
#endif
}
    6bf6:	1f 91       	pop	r17
    6bf8:	0f 91       	pop	r16
    6bfa:	08 95       	ret

00006bfc <icmpIpIn>:
}

void icmpIpIn(void)
{
  // check ICMP type
  switch(nicState.layer4.icmp->type)
    6bfc:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6c00:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6c04:	80 81       	ld	r24, Z
    6c06:	88 30       	cpi	r24, 0x08	; 8
    6c08:	19 f4       	brne	.+6      	; 0x6c10 <icmpIpIn+0x14>
  {
    case ICMP_TYPE_ECHOREQUEST:
      icmpEchoRequest();       // echo request
    6c0a:	0e 94 71 35 	call	0x6ae2	; 0x6ae2 <icmpEchoRequest>
    6c0e:	08 95       	ret
      break;
    default:
#if ICMP_DEBUG
      if (icmpDebug != NULL)
    6c10:	20 91 aa 0e 	lds	r18, 0x0EAA
    6c14:	30 91 ab 0e 	lds	r19, 0x0EAB
    6c18:	21 15       	cp	r18, r1
    6c1a:	31 05       	cpc	r19, r1
    6c1c:	a1 f0       	breq	.+40     	; 0x6c46 <icmpIpIn+0x4a>
      {
        if (icmpDebugLevel > 0)
    6c1e:	80 91 4d 0f 	lds	r24, 0x0F4D
    6c22:	88 23       	and	r24, r24
    6c24:	81 f0       	breq	.+32     	; 0x6c46 <icmpIpIn+0x4a>
          fprintf_P(icmpDebug, PSTR("Unknown ICMP typeReceived ICMP request: "));
    6c26:	00 d0       	rcall	.+0      	; 0x6c28 <icmpIpIn+0x2c>
    6c28:	00 d0       	rcall	.+0      	; 0x6c2a <icmpIpIn+0x2e>
    6c2a:	ed b7       	in	r30, 0x3d	; 61
    6c2c:	fe b7       	in	r31, 0x3e	; 62
    6c2e:	32 83       	std	Z+2, r19	; 0x02
    6c30:	21 83       	std	Z+1, r18	; 0x01
    6c32:	8b e5       	ldi	r24, 0x5B	; 91
    6c34:	9f e0       	ldi	r25, 0x0F	; 15
    6c36:	94 83       	std	Z+4, r25	; 0x04
    6c38:	83 83       	std	Z+3, r24	; 0x03
    6c3a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6c3e:	0f 90       	pop	r0
    6c40:	0f 90       	pop	r0
    6c42:	0f 90       	pop	r0
    6c44:	0f 90       	pop	r0
    6c46:	08 95       	ret

00006c48 <setArpDebug>:

#ifdef ARP_DEBUG

void setArpDebug(FILE *stream, uint8_t level)
{
  arpDebug = stream;
    6c48:	90 93 8d 0e 	sts	0x0E8D, r25
    6c4c:	80 93 8c 0e 	sts	0x0E8C, r24
  arpDebugLevel = level;
    6c50:	60 93 5f 0f 	sts	0x0F5F, r22
  if (level == 0)
    6c54:	66 23       	and	r22, r22
    6c56:	21 f4       	brne	.+8      	; 0x6c60 <setArpDebug+0x18>
    arpDebug = NULL;
    6c58:	10 92 8d 0e 	sts	0x0E8D, r1
    6c5c:	10 92 8c 0e 	sts	0x0E8C, r1
    6c60:	08 95       	ret

00006c62 <arpTimer>:
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}

void arpTimer(void)
{
    6c62:	e4 e7       	ldi	r30, 0x74	; 116
    6c64:	ff e0       	ldi	r31, 0x0F	; 15
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time)
    6c66:	80 81       	ld	r24, Z
    6c68:	88 23       	and	r24, r24
    6c6a:	11 f0       	breq	.+4      	; 0x6c70 <arpTimer+0xe>
      ArpTable[index].time--;
    6c6c:	81 50       	subi	r24, 0x01	; 1
    6c6e:	80 83       	st	Z, r24
    6c70:	3b 96       	adiw	r30, 0x0b	; 11
{
  int index;
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6c72:	8f e0       	ldi	r24, 0x0F	; 15
    6c74:	e2 3e       	cpi	r30, 0xE2	; 226
    6c76:	f8 07       	cpc	r31, r24
    6c78:	b1 f7       	brne	.-20     	; 0x6c66 <arpTimer+0x4>
  {
    if(ArpTable[index].time)
      ArpTable[index].time--;
  }
}
    6c7a:	08 95       	ret

00006c7c <arpMatchIp>:

int arpMatchIp(uint32_t ipaddr)
{
    6c7c:	ab 01       	movw	r20, r22
    6c7e:	bc 01       	movw	r22, r24
    6c80:	ea e6       	ldi	r30, 0x6A	; 106
    6c82:	ff e0       	ldi	r31, 0x0F	; 15
    6c84:	80 e0       	ldi	r24, 0x00	; 0
    6c86:	90 e0       	ldi	r25, 0x00	; 0
    6c88:	9c 01       	movw	r18, r24
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    6c8a:	80 81       	ld	r24, Z
    6c8c:	91 81       	ldd	r25, Z+1	; 0x01
    6c8e:	a2 81       	ldd	r26, Z+2	; 0x02
    6c90:	b3 81       	ldd	r27, Z+3	; 0x03
    6c92:	84 17       	cp	r24, r20
    6c94:	95 07       	cpc	r25, r21
    6c96:	a6 07       	cpc	r26, r22
    6c98:	b7 07       	cpc	r27, r23
    6c9a:	41 f0       	breq	.+16     	; 0x6cac <arpMatchIp+0x30>
    6c9c:	c9 01       	movw	r24, r18
    6c9e:	01 96       	adiw	r24, 0x01	; 1
    6ca0:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    6ca2:	8a 30       	cpi	r24, 0x0A	; 10
    6ca4:	91 05       	cpc	r25, r1
    6ca6:	81 f7       	brne	.-32     	; 0x6c88 <arpMatchIp+0xc>
    6ca8:	2f ef       	ldi	r18, 0xFF	; 255
    6caa:	3f ef       	ldi	r19, 0xFF	; 255
    }
  }

// no match
  return -1;
}
    6cac:	c9 01       	movw	r24, r18
    6cae:	08 95       	ret

00006cb0 <arpPrintTable>:
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
}
#endif /*ARP_DEBUG*/

void arpPrintTable(FILE *stream)
{
    6cb0:	6f 92       	push	r6
    6cb2:	7f 92       	push	r7
    6cb4:	8f 92       	push	r8
    6cb6:	9f 92       	push	r9
    6cb8:	af 92       	push	r10
    6cba:	bf 92       	push	r11
    6cbc:	cf 92       	push	r12
    6cbe:	df 92       	push	r13
    6cc0:	ef 92       	push	r14
    6cc2:	ff 92       	push	r15
    6cc4:	0f 93       	push	r16
    6cc6:	1f 93       	push	r17
    6cc8:	cf 93       	push	r28
    6cca:	df 93       	push	r29
    6ccc:	ec 01       	movw	r28, r24
  uint8_t i;

  // print ARP table
  fprintf_P(stream, PSTR("Time Eth Address        IP Address\r\n"));
    6cce:	00 d0       	rcall	.+0      	; 0x6cd0 <arpPrintTable+0x20>
    6cd0:	00 d0       	rcall	.+0      	; 0x6cd2 <arpPrintTable+0x22>
    6cd2:	ad b7       	in	r26, 0x3d	; 61
    6cd4:	be b7       	in	r27, 0x3e	; 62
    6cd6:	12 96       	adiw	r26, 0x02	; 2
    6cd8:	9c 93       	st	X, r25
    6cda:	8e 93       	st	-X, r24
    6cdc:	11 97       	sbiw	r26, 0x01	; 1
    6cde:	82 ec       	ldi	r24, 0xC2	; 194
    6ce0:	9f e0       	ldi	r25, 0x0F	; 15
    6ce2:	14 96       	adiw	r26, 0x04	; 4
    6ce4:	9c 93       	st	X, r25
    6ce6:	8e 93       	st	-X, r24
    6ce8:	13 97       	sbiw	r26, 0x03	; 3
    6cea:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("-----------------------------------\r\n"));
    6cee:	ed b7       	in	r30, 0x3d	; 61
    6cf0:	fe b7       	in	r31, 0x3e	; 62
    6cf2:	d2 83       	std	Z+2, r29	; 0x02
    6cf4:	c1 83       	std	Z+1, r28	; 0x01
    6cf6:	8c e9       	ldi	r24, 0x9C	; 156
    6cf8:	9f e0       	ldi	r25, 0x0F	; 15
    6cfa:	94 83       	std	Z+4, r25	; 0x04
    6cfc:	83 83       	std	Z+3, r24	; 0x03
    6cfe:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR(" MY  "));
    6d02:	ad b7       	in	r26, 0x3d	; 61
    6d04:	be b7       	in	r27, 0x3e	; 62
    6d06:	12 96       	adiw	r26, 0x02	; 2
    6d08:	dc 93       	st	X, r29
    6d0a:	ce 93       	st	-X, r28
    6d0c:	11 97       	sbiw	r26, 0x01	; 1
    6d0e:	86 e9       	ldi	r24, 0x96	; 150
    6d10:	9f e0       	ldi	r25, 0x0F	; 15
    6d12:	14 96       	adiw	r26, 0x04	; 4
    6d14:	9c 93       	st	X, r25
    6d16:	8e 93       	st	-X, r24
    6d18:	13 97       	sbiw	r26, 0x03	; 3
    6d1a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    6d1e:	0f 90       	pop	r0
    6d20:	0f 90       	pop	r0
    6d22:	0f 90       	pop	r0
    6d24:	0f 90       	pop	r0
    6d26:	ce 01       	movw	r24, r28
    6d28:	60 e8       	ldi	r22, 0x80	; 128
    6d2a:	7e e0       	ldi	r23, 0x0E	; 14
    6d2c:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <netPrintEthAddr>
  fprintf_P(stream, PSTR("  "));
    6d30:	00 d0       	rcall	.+0      	; 0x6d32 <arpPrintTable+0x82>
    6d32:	00 d0       	rcall	.+0      	; 0x6d34 <arpPrintTable+0x84>
    6d34:	ed b7       	in	r30, 0x3d	; 61
    6d36:	fe b7       	in	r31, 0x3e	; 62
    6d38:	d2 83       	std	Z+2, r29	; 0x02
    6d3a:	c1 83       	std	Z+1, r28	; 0x01
    6d3c:	83 e9       	ldi	r24, 0x93	; 147
    6d3e:	9f e0       	ldi	r25, 0x0F	; 15
    6d40:	94 83       	std	Z+4, r25	; 0x04
    6d42:	83 83       	std	Z+3, r24	; 0x03
    6d44:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  netPrintIPAddr(stream, IpMyConfig.ip);
    6d48:	0f 90       	pop	r0
    6d4a:	0f 90       	pop	r0
    6d4c:	0f 90       	pop	r0
    6d4e:	0f 90       	pop	r0
    6d50:	40 91 50 0f 	lds	r20, 0x0F50
    6d54:	50 91 51 0f 	lds	r21, 0x0F51
    6d58:	60 91 52 0f 	lds	r22, 0x0F52
    6d5c:	70 91 53 0f 	lds	r23, 0x0F53
    6d60:	ce 01       	movw	r24, r28
    6d62:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    6d66:	00 d0       	rcall	.+0      	; 0x6d68 <arpPrintTable+0xb8>
    6d68:	00 d0       	rcall	.+0      	; 0x6d6a <arpPrintTable+0xba>
    6d6a:	ad b7       	in	r26, 0x3d	; 61
    6d6c:	be b7       	in	r27, 0x3e	; 62
    6d6e:	12 96       	adiw	r26, 0x02	; 2
    6d70:	dc 93       	st	X, r29
    6d72:	ce 93       	st	-X, r28
    6d74:	11 97       	sbiw	r26, 0x01	; 1
    6d76:	80 e9       	ldi	r24, 0x90	; 144
    6d78:	9f e0       	ldi	r25, 0x0F	; 15
    6d7a:	14 96       	adiw	r26, 0x04	; 4
    6d7c:	9c 93       	st	X, r25
    6d7e:	8e 93       	st	-X, r24
    6d80:	13 97       	sbiw	r26, 0x03	; 3
    6d82:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6d86:	0a e6       	ldi	r16, 0x6A	; 106
    6d88:	1f e0       	ldi	r17, 0x0F	; 15
    6d8a:	ee 24       	eor	r14, r14
    6d8c:	ff 24       	eor	r15, r15
    6d8e:	0f 90       	pop	r0
    6d90:	0f 90       	pop	r0
    6d92:	0f 90       	pop	r0
    6d94:	0f 90       	pop	r0

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    6d96:	3a e8       	ldi	r19, 0x8A	; 138
    6d98:	63 2e       	mov	r6, r19
    6d9a:	3f e0       	ldi	r19, 0x0F	; 15
    6d9c:	73 2e       	mov	r7, r19
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    6d9e:	2b e0       	ldi	r18, 0x0B	; 11
    6da0:	82 2e       	mov	r8, r18
    6da2:	91 2c       	mov	r9, r1
    fprintf_P(stream, PSTR("  "));
    6da4:	97 e8       	ldi	r25, 0x87	; 135
    6da6:	a9 2e       	mov	r10, r25
    6da8:	9f e0       	ldi	r25, 0x0F	; 15
    6daa:	b9 2e       	mov	r11, r25
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
    6dac:	84 e8       	ldi	r24, 0x84	; 132
    6dae:	c8 2e       	mov	r12, r24
    6db0:	8f e0       	ldi	r24, 0x0F	; 15
    6db2:	d8 2e       	mov	r13, r24
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
    6db4:	f8 01       	movw	r30, r16
    6db6:	80 81       	ld	r24, Z
    6db8:	91 81       	ldd	r25, Z+1	; 0x01
    6dba:	a2 81       	ldd	r26, Z+2	; 0x02
    6dbc:	b3 81       	ldd	r27, Z+3	; 0x03
    6dbe:	00 97       	sbiw	r24, 0x00	; 0
    6dc0:	a1 05       	cpc	r26, r1
    6dc2:	b1 05       	cpc	r27, r1
    6dc4:	09 f4       	brne	.+2      	; 0x6dc8 <arpPrintTable+0x118>
    6dc6:	55 c0       	rjmp	.+170    	; 0x6e72 <arpPrintTable+0x1c2>
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    6dc8:	00 d0       	rcall	.+0      	; 0x6dca <arpPrintTable+0x11a>
    6dca:	00 d0       	rcall	.+0      	; 0x6dcc <arpPrintTable+0x11c>
    6dcc:	00 d0       	rcall	.+0      	; 0x6dce <arpPrintTable+0x11e>
    6dce:	ed b7       	in	r30, 0x3d	; 61
    6dd0:	fe b7       	in	r31, 0x3e	; 62
    6dd2:	31 96       	adiw	r30, 0x01	; 1
    6dd4:	ad b7       	in	r26, 0x3d	; 61
    6dd6:	be b7       	in	r27, 0x3e	; 62
    6dd8:	12 96       	adiw	r26, 0x02	; 2
    6dda:	dc 93       	st	X, r29
    6ddc:	ce 93       	st	-X, r28
    6dde:	11 97       	sbiw	r26, 0x01	; 1
    6de0:	73 82       	std	Z+3, r7	; 0x03
    6de2:	62 82       	std	Z+2, r6	; 0x02
    6de4:	d8 01       	movw	r26, r16
    6de6:	1a 96       	adiw	r26, 0x0a	; 10
    6de8:	8c 91       	ld	r24, X
    6dea:	84 83       	std	Z+4, r24	; 0x04
    6dec:	15 82       	std	Z+5, r1	; 0x05
    6dee:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    6df2:	ed b7       	in	r30, 0x3d	; 61
    6df4:	fe b7       	in	r31, 0x3e	; 62
    6df6:	36 96       	adiw	r30, 0x06	; 6
    6df8:	0f b6       	in	r0, 0x3f	; 63
    6dfa:	f8 94       	cli
    6dfc:	fe bf       	out	0x3e, r31	; 62
    6dfe:	0f be       	out	0x3f, r0	; 63
    6e00:	ed bf       	out	0x3d, r30	; 61
    6e02:	e8 9c       	mul	r14, r8
    6e04:	b0 01       	movw	r22, r0
    6e06:	e9 9c       	mul	r14, r9
    6e08:	70 0d       	add	r23, r0
    6e0a:	f8 9c       	mul	r15, r8
    6e0c:	70 0d       	add	r23, r0
    6e0e:	11 24       	eor	r1, r1
    6e10:	62 59       	subi	r22, 0x92	; 146
    6e12:	70 4f       	sbci	r23, 0xF0	; 240
    6e14:	ce 01       	movw	r24, r28
    6e16:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <netPrintEthAddr>
    fprintf_P(stream, PSTR("  "));
    6e1a:	00 d0       	rcall	.+0      	; 0x6e1c <arpPrintTable+0x16c>
    6e1c:	00 d0       	rcall	.+0      	; 0x6e1e <arpPrintTable+0x16e>
    6e1e:	ad b7       	in	r26, 0x3d	; 61
    6e20:	be b7       	in	r27, 0x3e	; 62
    6e22:	12 96       	adiw	r26, 0x02	; 2
    6e24:	dc 93       	st	X, r29
    6e26:	ce 93       	st	-X, r28
    6e28:	11 97       	sbiw	r26, 0x01	; 1
    6e2a:	14 96       	adiw	r26, 0x04	; 4
    6e2c:	bc 92       	st	X, r11
    6e2e:	ae 92       	st	-X, r10
    6e30:	13 97       	sbiw	r26, 0x03	; 3
    6e32:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    6e36:	0f 90       	pop	r0
    6e38:	0f 90       	pop	r0
    6e3a:	0f 90       	pop	r0
    6e3c:	0f 90       	pop	r0
    6e3e:	f8 01       	movw	r30, r16
    6e40:	40 81       	ld	r20, Z
    6e42:	51 81       	ldd	r21, Z+1	; 0x01
    6e44:	62 81       	ldd	r22, Z+2	; 0x02
    6e46:	73 81       	ldd	r23, Z+3	; 0x03
    6e48:	ce 01       	movw	r24, r28
    6e4a:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    fprintf_P(stream, PSTR("\r\n"));
    6e4e:	00 d0       	rcall	.+0      	; 0x6e50 <arpPrintTable+0x1a0>
    6e50:	00 d0       	rcall	.+0      	; 0x6e52 <arpPrintTable+0x1a2>
    6e52:	ad b7       	in	r26, 0x3d	; 61
    6e54:	be b7       	in	r27, 0x3e	; 62
    6e56:	12 96       	adiw	r26, 0x02	; 2
    6e58:	dc 93       	st	X, r29
    6e5a:	ce 93       	st	-X, r28
    6e5c:	11 97       	sbiw	r26, 0x01	; 1
    6e5e:	14 96       	adiw	r26, 0x04	; 4
    6e60:	dc 92       	st	X, r13
    6e62:	ce 92       	st	-X, r12
    6e64:	13 97       	sbiw	r26, 0x03	; 3
    6e66:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6e6a:	0f 90       	pop	r0
    6e6c:	0f 90       	pop	r0
    6e6e:	0f 90       	pop	r0
    6e70:	0f 90       	pop	r0
    6e72:	08 94       	sec
    6e74:	e1 1c       	adc	r14, r1
    6e76:	f1 1c       	adc	r15, r1
    6e78:	05 5f       	subi	r16, 0xF5	; 245
    6e7a:	1f 4f       	sbci	r17, 0xFF	; 255
  netPrintEthAddr(stream, &nicState.mac);
  fprintf_P(stream, PSTR("  "));
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
    6e7c:	ba e0       	ldi	r27, 0x0A	; 10
    6e7e:	eb 16       	cp	r14, r27
    6e80:	f1 04       	cpc	r15, r1
    6e82:	09 f0       	breq	.+2      	; 0x6e86 <arpPrintTable+0x1d6>
    6e84:	97 cf       	rjmp	.-210    	; 0x6db4 <arpPrintTable+0x104>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
  }
}
    6e86:	df 91       	pop	r29
    6e88:	cf 91       	pop	r28
    6e8a:	1f 91       	pop	r17
    6e8c:	0f 91       	pop	r16
    6e8e:	ff 90       	pop	r15
    6e90:	ef 90       	pop	r14
    6e92:	df 90       	pop	r13
    6e94:	cf 90       	pop	r12
    6e96:	bf 90       	pop	r11
    6e98:	af 90       	pop	r10
    6e9a:	9f 90       	pop	r9
    6e9c:	8f 90       	pop	r8
    6e9e:	7f 90       	pop	r7
    6ea0:	6f 90       	pop	r6
    6ea2:	08 95       	ret

00006ea4 <arpIpIn>:
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
  }
}

void arpIpIn(void)
{
    6ea4:	cf 93       	push	r28
    6ea6:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    6ea8:	20 91 8c 0e 	lds	r18, 0x0E8C
    6eac:	30 91 8d 0e 	lds	r19, 0x0E8D
    6eb0:	21 15       	cp	r18, r1
    6eb2:	31 05       	cpc	r19, r1
    6eb4:	09 f4       	brne	.+2      	; 0x6eb8 <arpIpIn+0x14>
    6eb6:	57 c0       	rjmp	.+174    	; 0x6f66 <arpIpIn+0xc2>
  {
    if (arpDebugLevel > 0)
    6eb8:	80 91 5f 0f 	lds	r24, 0x0F5F
    6ebc:	88 23       	and	r24, r24
    6ebe:	09 f4       	brne	.+2      	; 0x6ec2 <arpIpIn+0x1e>
    6ec0:	52 c0       	rjmp	.+164    	; 0x6f66 <arpIpIn+0xc2>
    {
      fprintf_P(arpDebug, PSTR("ARP IP in MAC: "));
    6ec2:	00 d0       	rcall	.+0      	; 0x6ec4 <arpIpIn+0x20>
    6ec4:	00 d0       	rcall	.+0      	; 0x6ec6 <arpIpIn+0x22>
    6ec6:	ed b7       	in	r30, 0x3d	; 61
    6ec8:	fe b7       	in	r31, 0x3e	; 62
    6eca:	32 83       	std	Z+2, r19	; 0x02
    6ecc:	21 83       	std	Z+1, r18	; 0x01
    6ece:	8e e6       	ldi	r24, 0x6E	; 110
    6ed0:	90 e1       	ldi	r25, 0x10	; 16
    6ed2:	94 83       	std	Z+4, r25	; 0x04
    6ed4:	83 83       	std	Z+3, r24	; 0x03
    6ed6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      netPrintEthAddr(arpDebug, &nicState.layer2.ethHeader->src);
    6eda:	0f 90       	pop	r0
    6edc:	0f 90       	pop	r0
    6ede:	0f 90       	pop	r0
    6ee0:	0f 90       	pop	r0
    6ee2:	60 91 86 0e 	lds	r22, 0x0E86
    6ee6:	70 91 87 0e 	lds	r23, 0x0E87
    6eea:	6a 5f       	subi	r22, 0xFA	; 250
    6eec:	7f 4f       	sbci	r23, 0xFF	; 255
    6eee:	80 91 8c 0e 	lds	r24, 0x0E8C
    6ef2:	90 91 8d 0e 	lds	r25, 0x0E8D
    6ef6:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <netPrintEthAddr>
      fprintf_P(arpDebug, PSTR(" IP: "));
    6efa:	00 d0       	rcall	.+0      	; 0x6efc <arpIpIn+0x58>
    6efc:	00 d0       	rcall	.+0      	; 0x6efe <arpIpIn+0x5a>
    6efe:	80 91 8c 0e 	lds	r24, 0x0E8C
    6f02:	90 91 8d 0e 	lds	r25, 0x0E8D
    6f06:	ed b7       	in	r30, 0x3d	; 61
    6f08:	fe b7       	in	r31, 0x3e	; 62
    6f0a:	92 83       	std	Z+2, r25	; 0x02
    6f0c:	81 83       	std	Z+1, r24	; 0x01
    6f0e:	88 e6       	ldi	r24, 0x68	; 104
    6f10:	90 e1       	ldi	r25, 0x10	; 16
    6f12:	94 83       	std	Z+4, r25	; 0x04
    6f14:	83 83       	std	Z+3, r24	; 0x03
    6f16:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      netPrintIPAddr(arpDebug, nicState.layer3.ip->srcipaddr);
    6f1a:	0f 90       	pop	r0
    6f1c:	0f 90       	pop	r0
    6f1e:	0f 90       	pop	r0
    6f20:	0f 90       	pop	r0
    6f22:	e0 91 88 0e 	lds	r30, 0x0E88
    6f26:	f0 91 89 0e 	lds	r31, 0x0E89
    6f2a:	44 85       	ldd	r20, Z+12	; 0x0c
    6f2c:	55 85       	ldd	r21, Z+13	; 0x0d
    6f2e:	66 85       	ldd	r22, Z+14	; 0x0e
    6f30:	77 85       	ldd	r23, Z+15	; 0x0f
    6f32:	80 91 8c 0e 	lds	r24, 0x0E8C
    6f36:	90 91 8d 0e 	lds	r25, 0x0E8D
    6f3a:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
      fprintf_P(arpDebug, PSTR("\r\n"));
    6f3e:	00 d0       	rcall	.+0      	; 0x6f40 <arpIpIn+0x9c>
    6f40:	00 d0       	rcall	.+0      	; 0x6f42 <arpIpIn+0x9e>
    6f42:	80 91 8c 0e 	lds	r24, 0x0E8C
    6f46:	90 91 8d 0e 	lds	r25, 0x0E8D
    6f4a:	ed b7       	in	r30, 0x3d	; 61
    6f4c:	fe b7       	in	r31, 0x3e	; 62
    6f4e:	92 83       	std	Z+2, r25	; 0x02
    6f50:	81 83       	std	Z+1, r24	; 0x01
    6f52:	85 e6       	ldi	r24, 0x65	; 101
    6f54:	90 e1       	ldi	r25, 0x10	; 16
    6f56:	94 83       	std	Z+4, r25	; 0x04
    6f58:	83 83       	std	Z+3, r24	; 0x03
    6f5a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    6f5e:	0f 90       	pop	r0
    6f60:	0f 90       	pop	r0
    6f62:	0f 90       	pop	r0
    6f64:	0f 90       	pop	r0
  }
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
    6f66:	c0 91 88 0e 	lds	r28, 0x0E88
    6f6a:	d0 91 89 0e 	lds	r29, 0x0E89
    6f6e:	4c 85       	ldd	r20, Y+12	; 0x0c
    6f70:	5d 85       	ldd	r21, Y+13	; 0x0d
    6f72:	6e 85       	ldd	r22, Y+14	; 0x0e
    6f74:	7f 85       	ldd	r23, Y+15	; 0x0f
    6f76:	ea e6       	ldi	r30, 0x6A	; 106
    6f78:	ff e0       	ldi	r31, 0x0F	; 15
    6f7a:	80 e0       	ldi	r24, 0x00	; 0
    6f7c:	90 e0       	ldi	r25, 0x00	; 0
    6f7e:	9c 01       	movw	r18, r24
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    6f80:	80 81       	ld	r24, Z
    6f82:	91 81       	ldd	r25, Z+1	; 0x01
    6f84:	a2 81       	ldd	r26, Z+2	; 0x02
    6f86:	b3 81       	ldd	r27, Z+3	; 0x03
    6f88:	84 17       	cp	r24, r20
    6f8a:	95 07       	cpc	r25, r21
    6f8c:	a6 07       	cpc	r26, r22
    6f8e:	b7 07       	cpc	r27, r23
    6f90:	41 f0       	breq	.+16     	; 0x6fa2 <arpIpIn+0xfe>
    6f92:	c9 01       	movw	r24, r18
    6f94:	01 96       	adiw	r24, 0x01	; 1
    6f96:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    6f98:	8a 30       	cpi	r24, 0x0A	; 10
    6f9a:	91 05       	cpc	r25, r1
    6f9c:	81 f7       	brne	.-32     	; 0x6f7e <arpIpIn+0xda>
    6f9e:	2f ef       	ldi	r18, 0xFF	; 255
    6fa0:	3f ef       	ldi	r19, 0xFF	; 255
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
  if(index != -1)
    6fa2:	2f 3f       	cpi	r18, 0xFF	; 255
    6fa4:	21 f1       	breq	.+72     	; 0x6fee <arpIpIn+0x14a>
  {
// sender's IP address found, update ARP entry
    ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6fa6:	33 27       	eor	r19, r19
    6fa8:	27 fd       	sbrc	r18, 7
    6faa:	30 95       	com	r19
    6fac:	8b e0       	ldi	r24, 0x0B	; 11
    6fae:	90 e0       	ldi	r25, 0x00	; 0
    6fb0:	28 9f       	mul	r18, r24
    6fb2:	d0 01       	movw	r26, r0
    6fb4:	29 9f       	mul	r18, r25
    6fb6:	b0 0d       	add	r27, r0
    6fb8:	38 9f       	mul	r19, r24
    6fba:	b0 0d       	add	r27, r0
    6fbc:	11 24       	eor	r1, r1
    6fbe:	e0 91 86 0e 	lds	r30, 0x0E86
    6fc2:	f0 91 87 0e 	lds	r31, 0x0E87
    6fc6:	a2 59       	subi	r26, 0x92	; 146
    6fc8:	b0 4f       	sbci	r27, 0xF0	; 240
    6fca:	36 96       	adiw	r30, 0x06	; 6
    6fcc:	86 e0       	ldi	r24, 0x06	; 6
    6fce:	01 90       	ld	r0, Z+
    6fd0:	0d 92       	st	X+, r0
    6fd2:	81 50       	subi	r24, 0x01	; 1
    6fd4:	e1 f7       	brne	.-8      	; 0x6fce <arpIpIn+0x12a>
    ArpTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    6fd6:	8b e0       	ldi	r24, 0x0B	; 11
    6fd8:	90 e0       	ldi	r25, 0x00	; 0
    6fda:	28 9f       	mul	r18, r24
    6fdc:	f0 01       	movw	r30, r0
    6fde:	29 9f       	mul	r18, r25
    6fe0:	f0 0d       	add	r31, r0
    6fe2:	38 9f       	mul	r19, r24
    6fe4:	f0 0d       	add	r31, r0
    6fe6:	11 24       	eor	r1, r1
    6fe8:	e6 59       	subi	r30, 0x96	; 150
    6fea:	f0 4f       	sbci	r31, 0xF0	; 240
    6fec:	2f c0       	rjmp	.+94     	; 0x704c <arpIpIn+0x1a8>
// and we're done
    return;
    6fee:	e4 e7       	ldi	r30, 0x74	; 116
    6ff0:	ff e0       	ldi	r31, 0x0F	; 15
    6ff2:	20 e0       	ldi	r18, 0x00	; 0
    6ff4:	30 e0       	ldi	r19, 0x00	; 0

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time == 0)
    6ff6:	80 81       	ld	r24, Z
    6ff8:	88 23       	and	r24, r24
    6ffa:	59 f5       	brne	.+86     	; 0x7052 <arpIpIn+0x1ae>
    {
// write entry
      ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6ffc:	8b e0       	ldi	r24, 0x0B	; 11
    6ffe:	90 e0       	ldi	r25, 0x00	; 0
    7000:	28 9f       	mul	r18, r24
    7002:	d0 01       	movw	r26, r0
    7004:	29 9f       	mul	r18, r25
    7006:	b0 0d       	add	r27, r0
    7008:	38 9f       	mul	r19, r24
    700a:	b0 0d       	add	r27, r0
    700c:	11 24       	eor	r1, r1
    700e:	e0 91 86 0e 	lds	r30, 0x0E86
    7012:	f0 91 87 0e 	lds	r31, 0x0E87
    7016:	a2 59       	subi	r26, 0x92	; 146
    7018:	b0 4f       	sbci	r27, 0xF0	; 240
    701a:	36 96       	adiw	r30, 0x06	; 6
    701c:	86 e0       	ldi	r24, 0x06	; 6
    701e:	01 90       	ld	r0, Z+
    7020:	0d 92       	st	X+, r0
    7022:	81 50       	subi	r24, 0x01	; 1
    7024:	e1 f7       	brne	.-8      	; 0x701e <arpIpIn+0x17a>
      ArpTable[index].ipaddr  = nicState.layer3.ip->srcipaddr;
    7026:	8b e0       	ldi	r24, 0x0B	; 11
    7028:	90 e0       	ldi	r25, 0x00	; 0
    702a:	28 9f       	mul	r18, r24
    702c:	f0 01       	movw	r30, r0
    702e:	29 9f       	mul	r18, r25
    7030:	f0 0d       	add	r31, r0
    7032:	38 9f       	mul	r19, r24
    7034:	f0 0d       	add	r31, r0
    7036:	11 24       	eor	r1, r1
    7038:	e6 59       	subi	r30, 0x96	; 150
    703a:	f0 4f       	sbci	r31, 0xF0	; 240
    703c:	8c 85       	ldd	r24, Y+12	; 0x0c
    703e:	9d 85       	ldd	r25, Y+13	; 0x0d
    7040:	ae 85       	ldd	r26, Y+14	; 0x0e
    7042:	bf 85       	ldd	r27, Y+15	; 0x0f
    7044:	80 83       	st	Z, r24
    7046:	91 83       	std	Z+1, r25	; 0x01
    7048:	a2 83       	std	Z+2, r26	; 0x02
    704a:	b3 83       	std	Z+3, r27	; 0x03
      ArpTable[index].time    = ARP_CACHE_TIME_TO_LIVE;
    704c:	80 e8       	ldi	r24, 0x80	; 128
    704e:	82 87       	std	Z+10, r24	; 0x0a
    7050:	06 c0       	rjmp	.+12     	; 0x705e <arpIpIn+0x1ba>
// and we're done
      return;
    7052:	2f 5f       	subi	r18, 0xFF	; 255
    7054:	3f 4f       	sbci	r19, 0xFF	; 255
    7056:	3b 96       	adiw	r30, 0x0b	; 11
    return;
  }

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
    7058:	2a 30       	cpi	r18, 0x0A	; 10
    705a:	31 05       	cpc	r19, r1
    705c:	61 f6       	brne	.-104    	; 0x6ff6 <arpIpIn+0x152>
// and we're done
      return;
    }
  }
// no space in table, we give up
}
    705e:	df 91       	pop	r29
    7060:	cf 91       	pop	r28
    7062:	08 95       	ret

00007064 <arpPrintHeader>:
  return -1;
}

#if ARP_DEBUG
void arpPrintHeader(FILE *stream, struct netArpHeader* packet)
{
    7064:	ef 92       	push	r14
    7066:	ff 92       	push	r15
    7068:	0f 93       	push	r16
    706a:	1f 93       	push	r17
    706c:	cf 93       	push	r28
    706e:	df 93       	push	r29
    7070:	ec 01       	movw	r28, r24
    7072:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("ARP Packet:\r\n"));
    7074:	00 d0       	rcall	.+0      	; 0x7076 <arpPrintHeader+0x12>
    7076:	00 d0       	rcall	.+0      	; 0x7078 <arpPrintHeader+0x14>
    7078:	ed b7       	in	r30, 0x3d	; 61
    707a:	fe b7       	in	r31, 0x3e	; 62
    707c:	92 83       	std	Z+2, r25	; 0x02
    707e:	81 83       	std	Z+1, r24	; 0x01
    7080:	87 e5       	ldi	r24, 0x57	; 87
    7082:	90 e1       	ldi	r25, 0x10	; 16
    7084:	94 83       	std	Z+4, r25	; 0x04
    7086:	83 83       	std	Z+3, r24	; 0x03
    7088:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  //debugPrintHexTable(60, (unsigned char*)&packet);
  // print operation type
  fprintf_P(stream, PSTR("Operation   : "));
    708c:	ed b7       	in	r30, 0x3d	; 61
    708e:	fe b7       	in	r31, 0x3e	; 62
    7090:	d2 83       	std	Z+2, r29	; 0x02
    7092:	c1 83       	std	Z+1, r28	; 0x01
    7094:	88 e4       	ldi	r24, 0x48	; 72
    7096:	90 e1       	ldi	r25, 0x10	; 16
    7098:	94 83       	std	Z+4, r25	; 0x04
    709a:	83 83       	std	Z+3, r24	; 0x03
    709c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  if(packet->opcode == htons(ARP_OPCODE_REQUEST))
    70a0:	f7 01       	movw	r30, r14
    70a2:	06 81       	ldd	r16, Z+6	; 0x06
    70a4:	17 81       	ldd	r17, Z+7	; 0x07
    70a6:	0f 90       	pop	r0
    70a8:	0f 90       	pop	r0
    70aa:	0f 90       	pop	r0
    70ac:	0f 90       	pop	r0
    70ae:	81 e0       	ldi	r24, 0x01	; 1
    70b0:	90 e0       	ldi	r25, 0x00	; 0
    70b2:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    70b6:	08 17       	cp	r16, r24
    70b8:	19 07       	cpc	r17, r25
    70ba:	49 f4       	brne	.+18     	; 0x70ce <arpPrintHeader+0x6a>
    fprintf_P(stream, PSTR("REQUEST"));
    70bc:	00 d0       	rcall	.+0      	; 0x70be <arpPrintHeader+0x5a>
    70be:	00 d0       	rcall	.+0      	; 0x70c0 <arpPrintHeader+0x5c>
    70c0:	ed b7       	in	r30, 0x3d	; 61
    70c2:	fe b7       	in	r31, 0x3e	; 62
    70c4:	d2 83       	std	Z+2, r29	; 0x02
    70c6:	c1 83       	std	Z+1, r28	; 0x01
    70c8:	80 e4       	ldi	r24, 0x40	; 64
    70ca:	90 e1       	ldi	r25, 0x10	; 16
    70cc:	1b c0       	rjmp	.+54     	; 0x7104 <arpPrintHeader+0xa0>
  else if(packet->opcode == htons(ARP_OPCODE_REPLY))
    70ce:	f7 01       	movw	r30, r14
    70d0:	06 81       	ldd	r16, Z+6	; 0x06
    70d2:	17 81       	ldd	r17, Z+7	; 0x07
    70d4:	82 e0       	ldi	r24, 0x02	; 2
    70d6:	90 e0       	ldi	r25, 0x00	; 0
    70d8:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    70dc:	08 17       	cp	r16, r24
    70de:	19 07       	cpc	r17, r25
    70e0:	49 f4       	brne	.+18     	; 0x70f4 <arpPrintHeader+0x90>
    fprintf_P(stream, PSTR("REPLY"));
    70e2:	00 d0       	rcall	.+0      	; 0x70e4 <arpPrintHeader+0x80>
    70e4:	00 d0       	rcall	.+0      	; 0x70e6 <arpPrintHeader+0x82>
    70e6:	ed b7       	in	r30, 0x3d	; 61
    70e8:	fe b7       	in	r31, 0x3e	; 62
    70ea:	d2 83       	std	Z+2, r29	; 0x02
    70ec:	c1 83       	std	Z+1, r28	; 0x01
    70ee:	8a e3       	ldi	r24, 0x3A	; 58
    70f0:	90 e1       	ldi	r25, 0x10	; 16
    70f2:	08 c0       	rjmp	.+16     	; 0x7104 <arpPrintHeader+0xa0>
  else
    fprintf_P(stream, PSTR("UNKNOWN"));
    70f4:	00 d0       	rcall	.+0      	; 0x70f6 <arpPrintHeader+0x92>
    70f6:	00 d0       	rcall	.+0      	; 0x70f8 <arpPrintHeader+0x94>
    70f8:	ed b7       	in	r30, 0x3d	; 61
    70fa:	fe b7       	in	r31, 0x3e	; 62
    70fc:	d2 83       	std	Z+2, r29	; 0x02
    70fe:	c1 83       	std	Z+1, r28	; 0x01
    7100:	82 e3       	ldi	r24, 0x32	; 50
    7102:	90 e1       	ldi	r25, 0x10	; 16
    7104:	94 83       	std	Z+4, r25	; 0x04
    7106:	83 83       	std	Z+3, r24	; 0x03
    7108:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n"));
    710c:	ed b7       	in	r30, 0x3d	; 61
    710e:	fe b7       	in	r31, 0x3e	; 62
    7110:	d2 83       	std	Z+2, r29	; 0x02
    7112:	c1 83       	std	Z+1, r28	; 0x01
    7114:	8f e2       	ldi	r24, 0x2F	; 47
    7116:	90 e1       	ldi	r25, 0x10	; 16
    7118:	94 83       	std	Z+4, r25	; 0x04
    711a:	83 83       	std	Z+3, r24	; 0x03
    711c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print source hardware address
  fprintf_P(stream, PSTR("SrcHwAddr   : "));  netPrintEthAddr(stream, &packet->shwaddr);   fprintf_P(stream, PSTR("\r\n"));
    7120:	ed b7       	in	r30, 0x3d	; 61
    7122:	fe b7       	in	r31, 0x3e	; 62
    7124:	d2 83       	std	Z+2, r29	; 0x02
    7126:	c1 83       	std	Z+1, r28	; 0x01
    7128:	80 e2       	ldi	r24, 0x20	; 32
    712a:	90 e1       	ldi	r25, 0x10	; 16
    712c:	94 83       	std	Z+4, r25	; 0x04
    712e:	83 83       	std	Z+3, r24	; 0x03
    7130:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7134:	0f 90       	pop	r0
    7136:	0f 90       	pop	r0
    7138:	0f 90       	pop	r0
    713a:	0f 90       	pop	r0
    713c:	b7 01       	movw	r22, r14
    713e:	68 5f       	subi	r22, 0xF8	; 248
    7140:	7f 4f       	sbci	r23, 0xFF	; 255
    7142:	ce 01       	movw	r24, r28
    7144:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <netPrintEthAddr>
    7148:	00 d0       	rcall	.+0      	; 0x714a <arpPrintHeader+0xe6>
    714a:	00 d0       	rcall	.+0      	; 0x714c <arpPrintHeader+0xe8>
    714c:	ed b7       	in	r30, 0x3d	; 61
    714e:	fe b7       	in	r31, 0x3e	; 62
    7150:	d2 83       	std	Z+2, r29	; 0x02
    7152:	c1 83       	std	Z+1, r28	; 0x01
    7154:	8d e1       	ldi	r24, 0x1D	; 29
    7156:	90 e1       	ldi	r25, 0x10	; 16
    7158:	94 83       	std	Z+4, r25	; 0x04
    715a:	83 83       	std	Z+3, r24	; 0x03
    715c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print source protocol address
  fprintf_P(stream, PSTR("SrcProtoAddr: "));  netPrintIPAddr(stream, packet->sipaddr);     fprintf_P(stream, PSTR("\r\n"));
    7160:	ed b7       	in	r30, 0x3d	; 61
    7162:	fe b7       	in	r31, 0x3e	; 62
    7164:	d2 83       	std	Z+2, r29	; 0x02
    7166:	c1 83       	std	Z+1, r28	; 0x01
    7168:	8e e0       	ldi	r24, 0x0E	; 14
    716a:	90 e1       	ldi	r25, 0x10	; 16
    716c:	94 83       	std	Z+4, r25	; 0x04
    716e:	83 83       	std	Z+3, r24	; 0x03
    7170:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7174:	0f 90       	pop	r0
    7176:	0f 90       	pop	r0
    7178:	0f 90       	pop	r0
    717a:	0f 90       	pop	r0
    717c:	f7 01       	movw	r30, r14
    717e:	46 85       	ldd	r20, Z+14	; 0x0e
    7180:	57 85       	ldd	r21, Z+15	; 0x0f
    7182:	60 89       	ldd	r22, Z+16	; 0x10
    7184:	71 89       	ldd	r23, Z+17	; 0x11
    7186:	ce 01       	movw	r24, r28
    7188:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    718c:	00 d0       	rcall	.+0      	; 0x718e <arpPrintHeader+0x12a>
    718e:	00 d0       	rcall	.+0      	; 0x7190 <arpPrintHeader+0x12c>
    7190:	ed b7       	in	r30, 0x3d	; 61
    7192:	fe b7       	in	r31, 0x3e	; 62
    7194:	d2 83       	std	Z+2, r29	; 0x02
    7196:	c1 83       	std	Z+1, r28	; 0x01
    7198:	8b e0       	ldi	r24, 0x0B	; 11
    719a:	90 e1       	ldi	r25, 0x10	; 16
    719c:	94 83       	std	Z+4, r25	; 0x04
    719e:	83 83       	std	Z+3, r24	; 0x03
    71a0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print target hardware address
  fprintf_P(stream, PSTR("DstHwAddr   : "));  netPrintEthAddr(stream, &packet->dhwaddr);   fprintf_P(stream, PSTR("\r\n"));
    71a4:	ed b7       	in	r30, 0x3d	; 61
    71a6:	fe b7       	in	r31, 0x3e	; 62
    71a8:	d2 83       	std	Z+2, r29	; 0x02
    71aa:	c1 83       	std	Z+1, r28	; 0x01
    71ac:	8c ef       	ldi	r24, 0xFC	; 252
    71ae:	9f e0       	ldi	r25, 0x0F	; 15
    71b0:	94 83       	std	Z+4, r25	; 0x04
    71b2:	83 83       	std	Z+3, r24	; 0x03
    71b4:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    71b8:	0f 90       	pop	r0
    71ba:	0f 90       	pop	r0
    71bc:	0f 90       	pop	r0
    71be:	0f 90       	pop	r0
    71c0:	b7 01       	movw	r22, r14
    71c2:	6e 5e       	subi	r22, 0xEE	; 238
    71c4:	7f 4f       	sbci	r23, 0xFF	; 255
    71c6:	ce 01       	movw	r24, r28
    71c8:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <netPrintEthAddr>
    71cc:	00 d0       	rcall	.+0      	; 0x71ce <arpPrintHeader+0x16a>
    71ce:	00 d0       	rcall	.+0      	; 0x71d0 <arpPrintHeader+0x16c>
    71d0:	ed b7       	in	r30, 0x3d	; 61
    71d2:	fe b7       	in	r31, 0x3e	; 62
    71d4:	d2 83       	std	Z+2, r29	; 0x02
    71d6:	c1 83       	std	Z+1, r28	; 0x01
    71d8:	89 ef       	ldi	r24, 0xF9	; 249
    71da:	9f e0       	ldi	r25, 0x0F	; 15
    71dc:	94 83       	std	Z+4, r25	; 0x04
    71de:	83 83       	std	Z+3, r24	; 0x03
    71e0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
// print target protocol address
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
    71e4:	ed b7       	in	r30, 0x3d	; 61
    71e6:	fe b7       	in	r31, 0x3e	; 62
    71e8:	d2 83       	std	Z+2, r29	; 0x02
    71ea:	c1 83       	std	Z+1, r28	; 0x01
    71ec:	8a ee       	ldi	r24, 0xEA	; 234
    71ee:	9f e0       	ldi	r25, 0x0F	; 15
    71f0:	94 83       	std	Z+4, r25	; 0x04
    71f2:	83 83       	std	Z+3, r24	; 0x03
    71f4:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    71f8:	0f 90       	pop	r0
    71fa:	0f 90       	pop	r0
    71fc:	0f 90       	pop	r0
    71fe:	0f 90       	pop	r0
    7200:	f7 01       	movw	r30, r14
    7202:	40 8d       	ldd	r20, Z+24	; 0x18
    7204:	51 8d       	ldd	r21, Z+25	; 0x19
    7206:	62 8d       	ldd	r22, Z+26	; 0x1a
    7208:	73 8d       	ldd	r23, Z+27	; 0x1b
    720a:	ce 01       	movw	r24, r28
    720c:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
    7210:	00 d0       	rcall	.+0      	; 0x7212 <arpPrintHeader+0x1ae>
    7212:	00 d0       	rcall	.+0      	; 0x7214 <arpPrintHeader+0x1b0>
    7214:	ed b7       	in	r30, 0x3d	; 61
    7216:	fe b7       	in	r31, 0x3e	; 62
    7218:	d2 83       	std	Z+2, r29	; 0x02
    721a:	c1 83       	std	Z+1, r28	; 0x01
    721c:	87 ee       	ldi	r24, 0xE7	; 231
    721e:	9f e0       	ldi	r25, 0x0F	; 15
    7220:	94 83       	std	Z+4, r25	; 0x04
    7222:	83 83       	std	Z+3, r24	; 0x03
    7224:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7228:	0f 90       	pop	r0
    722a:	0f 90       	pop	r0
    722c:	0f 90       	pop	r0
    722e:	0f 90       	pop	r0
}
    7230:	df 91       	pop	r29
    7232:	cf 91       	pop	r28
    7234:	1f 91       	pop	r17
    7236:	0f 91       	pop	r16
    7238:	ff 90       	pop	r15
    723a:	ef 90       	pop	r14
    723c:	08 95       	ret

0000723e <arpIpOut>:
  }
// no space in table, we give up
}

void arpIpOut(uint32_t phyDstIp)
{
    723e:	cf 93       	push	r28
    7240:	df 93       	push	r29
    7242:	ab 01       	movw	r20, r22
    7244:	bc 01       	movw	r22, r24
  int index;
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    7246:	41 15       	cp	r20, r1
    7248:	51 05       	cpc	r21, r1
    724a:	61 05       	cpc	r22, r1
    724c:	71 05       	cpc	r23, r1
    724e:	a9 f0       	breq	.+42     	; 0x727a <arpIpOut+0x3c>
    7250:	ea e6       	ldi	r30, 0x6A	; 106
    7252:	ff e0       	ldi	r31, 0x0F	; 15
    7254:	20 e0       	ldi	r18, 0x00	; 0
    7256:	30 e0       	ldi	r19, 0x00	; 0
    7258:	e9 01       	movw	r28, r18
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    725a:	80 81       	ld	r24, Z
    725c:	91 81       	ldd	r25, Z+1	; 0x01
    725e:	a2 81       	ldd	r26, Z+2	; 0x02
    7260:	b3 81       	ldd	r27, Z+3	; 0x03
    7262:	84 17       	cp	r24, r20
    7264:	95 07       	cpc	r25, r21
    7266:	a6 07       	cpc	r26, r22
    7268:	b7 07       	cpc	r27, r23
    726a:	d1 f1       	breq	.+116    	; 0x72e0 <arpIpOut+0xa2>
    726c:	2f 5f       	subi	r18, 0xFF	; 255
    726e:	3f 4f       	sbci	r19, 0xFF	; 255
    7270:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    7272:	2a 30       	cpi	r18, 0x0A	; 10
    7274:	31 05       	cpc	r19, r1
    7276:	81 f7       	brne	.-32     	; 0x7258 <arpIpOut+0x1a>
    7278:	1c c0       	rjmp	.+56     	; 0x72b2 <arpIpOut+0x74>
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    index = arpMatchIp(phyDstIp);
  else
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
    727a:	e0 91 88 0e 	lds	r30, 0x0E88
    727e:	f0 91 89 0e 	lds	r31, 0x0E89
    7282:	40 89       	ldd	r20, Z+16	; 0x10
    7284:	51 89       	ldd	r21, Z+17	; 0x11
    7286:	62 89       	ldd	r22, Z+18	; 0x12
    7288:	73 89       	ldd	r23, Z+19	; 0x13
    728a:	ea e6       	ldi	r30, 0x6A	; 106
    728c:	ff e0       	ldi	r31, 0x0F	; 15
    728e:	20 e0       	ldi	r18, 0x00	; 0
    7290:	30 e0       	ldi	r19, 0x00	; 0
    7292:	e9 01       	movw	r28, r18
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    7294:	80 81       	ld	r24, Z
    7296:	91 81       	ldd	r25, Z+1	; 0x01
    7298:	a2 81       	ldd	r26, Z+2	; 0x02
    729a:	b3 81       	ldd	r27, Z+3	; 0x03
    729c:	84 17       	cp	r24, r20
    729e:	95 07       	cpc	r25, r21
    72a0:	a6 07       	cpc	r26, r22
    72a2:	b7 07       	cpc	r27, r23
    72a4:	e9 f0       	breq	.+58     	; 0x72e0 <arpIpOut+0xa2>
    72a6:	2f 5f       	subi	r18, 0xFF	; 255
    72a8:	3f 4f       	sbci	r19, 0xFF	; 255
    72aa:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    72ac:	2a 30       	cpi	r18, 0x0A	; 10
    72ae:	31 05       	cpc	r19, r1
    72b0:	81 f7       	brne	.-32     	; 0x7292 <arpIpOut+0x54>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
  }
  else
  {
// not in table, must send ARP request
    nicState.layer2.ethHeader->src      = nicState.mac;
    72b2:	e0 91 86 0e 	lds	r30, 0x0E86
    72b6:	f0 91 87 0e 	lds	r31, 0x0E87
    72ba:	36 96       	adiw	r30, 0x06	; 6
    72bc:	a0 e8       	ldi	r26, 0x80	; 128
    72be:	be e0       	ldi	r27, 0x0E	; 14
    72c0:	86 e0       	ldi	r24, 0x06	; 6
    72c2:	0d 90       	ld	r0, X+
    72c4:	01 92       	st	Z+, r0
    72c6:	81 50       	subi	r24, 0x01	; 1
    72c8:	e1 f7       	brne	.-8      	; 0x72c2 <arpIpOut+0x84>
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    72ca:	80 91 86 0e 	lds	r24, 0x0E86
    72ce:	90 91 87 0e 	lds	r25, 0x0E87
    72d2:	6f ef       	ldi	r22, 0xFF	; 255
    72d4:	70 e0       	ldi	r23, 0x00	; 0
    72d6:	46 e0       	ldi	r20, 0x06	; 6
    72d8:	50 e0       	ldi	r21, 0x00	; 0
    72da:	0e 94 4e 59 	call	0xb29c	; 0xb29c <memset>
    72de:	22 c0       	rjmp	.+68     	; 0x7324 <arpIpOut+0xe6>
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
// fill in ethernet info
  if(index != -1)
  {
// ARP entry present, fill eth address(es)
    nicState.layer2.ethHeader->src      = nicState.mac;
    72e0:	e0 91 86 0e 	lds	r30, 0x0E86
    72e4:	f0 91 87 0e 	lds	r31, 0x0E87
    72e8:	36 96       	adiw	r30, 0x06	; 6
    72ea:	a0 e8       	ldi	r26, 0x80	; 128
    72ec:	be e0       	ldi	r27, 0x0E	; 14
    72ee:	86 e0       	ldi	r24, 0x06	; 6
    72f0:	0d 90       	ld	r0, X+
    72f2:	01 92       	st	Z+, r0
    72f4:	81 50       	subi	r24, 0x01	; 1
    72f6:	e1 f7       	brne	.-8      	; 0x72f0 <arpIpOut+0xb2>
    nicState.layer2.ethHeader->dest     = ArpTable[index].ethaddr;
    72f8:	8b e0       	ldi	r24, 0x0B	; 11
    72fa:	90 e0       	ldi	r25, 0x00	; 0
    72fc:	c8 9f       	mul	r28, r24
    72fe:	f0 01       	movw	r30, r0
    7300:	c9 9f       	mul	r28, r25
    7302:	f0 0d       	add	r31, r0
    7304:	d8 9f       	mul	r29, r24
    7306:	f0 0d       	add	r31, r0
    7308:	11 24       	eor	r1, r1
    730a:	20 91 86 0e 	lds	r18, 0x0E86
    730e:	30 91 87 0e 	lds	r19, 0x0E87
    7312:	c9 01       	movw	r24, r18
    7314:	dc 01       	movw	r26, r24
    7316:	e2 59       	subi	r30, 0x92	; 146
    7318:	f0 4f       	sbci	r31, 0xF0	; 240
    731a:	86 e0       	ldi	r24, 0x06	; 6
    731c:	01 90       	ld	r0, Z+
    731e:	0d 92       	st	X+, r0
    7320:	81 50       	subi	r24, 0x01	; 1
    7322:	e1 f7       	brne	.-8      	; 0x731c <arpIpOut+0xde>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
    7324:	e0 91 86 0e 	lds	r30, 0x0E86
    7328:	f0 91 87 0e 	lds	r31, 0x0E87
    732c:	88 e0       	ldi	r24, 0x08	; 8
    732e:	90 e0       	ldi	r25, 0x00	; 0
    7330:	95 87       	std	Z+13, r25	; 0x0d
    7332:	84 87       	std	Z+12, r24	; 0x0c
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}
    7334:	df 91       	pop	r29
    7336:	cf 91       	pop	r28
    7338:	08 95       	ret

0000733a <arpInit>:
#endif /*ARP_DEBUG*/

void arpInit()
{

  memset(ArpTable, 0, sizeof(ArpTable));
    733a:	8e e6       	ldi	r24, 0x6E	; 110
    733c:	ea e6       	ldi	r30, 0x6A	; 106
    733e:	ff e0       	ldi	r31, 0x0F	; 15
    7340:	df 01       	movw	r26, r30
    7342:	1d 92       	st	X+, r1
    7344:	8a 95       	dec	r24
    7346:	e9 f7       	brne	.-6      	; 0x7342 <arpInit+0x8>
  arpDebug = NULL;
    7348:	10 92 8d 0e 	sts	0x0E8D, r1
    734c:	10 92 8c 0e 	sts	0x0E8C, r1
}
    7350:	08 95       	ret

00007352 <arpArpIn>:

void arpArpIn(void)
{
    7352:	0f 93       	push	r16
    7354:	1f 93       	push	r17
    7356:	cf 93       	push	r28
    7358:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    735a:	20 91 8c 0e 	lds	r18, 0x0E8C
    735e:	30 91 8d 0e 	lds	r19, 0x0E8D
    7362:	21 15       	cp	r18, r1
    7364:	31 05       	cpc	r19, r1
    7366:	11 f1       	breq	.+68     	; 0x73ac <arpArpIn+0x5a>
  {
    if (arpDebugLevel > 1)
    7368:	80 91 5f 0f 	lds	r24, 0x0F5F
    736c:	82 30       	cpi	r24, 0x02	; 2
    736e:	80 f0       	brcs	.+32     	; 0x7390 <arpArpIn+0x3e>
      fprintf_P(arpDebug, PSTR("Received ARP Request\r\n"));
    7370:	00 d0       	rcall	.+0      	; 0x7372 <arpArpIn+0x20>
    7372:	00 d0       	rcall	.+0      	; 0x7374 <arpArpIn+0x22>
    7374:	ed b7       	in	r30, 0x3d	; 61
    7376:	fe b7       	in	r31, 0x3e	; 62
    7378:	32 83       	std	Z+2, r19	; 0x02
    737a:	21 83       	std	Z+1, r18	; 0x01
    737c:	82 e9       	ldi	r24, 0x92	; 146
    737e:	90 e1       	ldi	r25, 0x10	; 16
    7380:	94 83       	std	Z+4, r25	; 0x04
    7382:	83 83       	std	Z+3, r24	; 0x03
    7384:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7388:	0f 90       	pop	r0
    738a:	0f 90       	pop	r0
    738c:	0f 90       	pop	r0
    738e:	0f 90       	pop	r0
    if (arpDebugLevel > 2)
    7390:	80 91 5f 0f 	lds	r24, 0x0F5F
    7394:	83 30       	cpi	r24, 0x03	; 3
    7396:	50 f0       	brcs	.+20     	; 0x73ac <arpArpIn+0x5a>
      arpPrintHeader(arpDebug, nicState.layer3.arp);   
    7398:	60 91 88 0e 	lds	r22, 0x0E88
    739c:	70 91 89 0e 	lds	r23, 0x0E89
    73a0:	80 91 8c 0e 	lds	r24, 0x0E8C
    73a4:	90 91 8d 0e 	lds	r25, 0x0E8D
    73a8:	0e 94 32 38 	call	0x7064	; 0x7064 <arpPrintHeader>
  }
#endif

// for now, we just reply to requests
// need to add ARP cache
  if((nicState.layer3.arp->dipaddr == IpMyConfig.ip) && (nicState.layer3.arp->opcode == htons(ARP_OPCODE_REQUEST)) )
    73ac:	e0 91 88 0e 	lds	r30, 0x0E88
    73b0:	f0 91 89 0e 	lds	r31, 0x0E89
    73b4:	20 8d       	ldd	r18, Z+24	; 0x18
    73b6:	31 8d       	ldd	r19, Z+25	; 0x19
    73b8:	42 8d       	ldd	r20, Z+26	; 0x1a
    73ba:	53 8d       	ldd	r21, Z+27	; 0x1b
    73bc:	80 91 50 0f 	lds	r24, 0x0F50
    73c0:	90 91 51 0f 	lds	r25, 0x0F51
    73c4:	a0 91 52 0f 	lds	r26, 0x0F52
    73c8:	b0 91 53 0f 	lds	r27, 0x0F53
    73cc:	28 17       	cp	r18, r24
    73ce:	39 07       	cpc	r19, r25
    73d0:	4a 07       	cpc	r20, r26
    73d2:	5b 07       	cpc	r21, r27
    73d4:	09 f0       	breq	.+2      	; 0x73d8 <arpArpIn+0x86>
    73d6:	84 c0       	rjmp	.+264    	; 0x74e0 <arpArpIn+0x18e>
    73d8:	06 81       	ldd	r16, Z+6	; 0x06
    73da:	17 81       	ldd	r17, Z+7	; 0x07
    73dc:	81 e0       	ldi	r24, 0x01	; 1
    73de:	90 e0       	ldi	r25, 0x00	; 0
    73e0:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    73e4:	08 17       	cp	r16, r24
    73e6:	19 07       	cpc	r17, r25
    73e8:	09 f0       	breq	.+2      	; 0x73ec <arpArpIn+0x9a>
    73ea:	7a c0       	rjmp	.+244    	; 0x74e0 <arpArpIn+0x18e>
  {
// in ARP header
// copy sender's address info to dest. fields
    nicState.layer3.arp->dhwaddr = nicState.layer3.arp->shwaddr;
    73ec:	e0 91 88 0e 	lds	r30, 0x0E88
    73f0:	f0 91 89 0e 	lds	r31, 0x0E89
    73f4:	ef 01       	movw	r28, r30
    73f6:	62 96       	adiw	r28, 0x12	; 18
    73f8:	df 01       	movw	r26, r30
    73fa:	18 96       	adiw	r26, 0x08	; 8
    73fc:	86 e0       	ldi	r24, 0x06	; 6
    73fe:	0d 90       	ld	r0, X+
    7400:	09 92       	st	Y+, r0
    7402:	81 50       	subi	r24, 0x01	; 1
    7404:	e1 f7       	brne	.-8      	; 0x73fe <arpArpIn+0xac>
    nicState.layer3.arp->dipaddr = nicState.layer3.arp->sipaddr;
    7406:	86 85       	ldd	r24, Z+14	; 0x0e
    7408:	97 85       	ldd	r25, Z+15	; 0x0f
    740a:	a0 89       	ldd	r26, Z+16	; 0x10
    740c:	b1 89       	ldd	r27, Z+17	; 0x11
    740e:	80 8f       	std	Z+24, r24	; 0x18
    7410:	91 8f       	std	Z+25, r25	; 0x19
    7412:	a2 8f       	std	Z+26, r26	; 0x1a
    7414:	b3 8f       	std	Z+27, r27	; 0x1b
// fill in our information
    nicState.layer3.arp->shwaddr =  nicState.mac;
    7416:	df 01       	movw	r26, r30
    7418:	18 96       	adiw	r26, 0x08	; 8
    741a:	e0 e8       	ldi	r30, 0x80	; 128
    741c:	fe e0       	ldi	r31, 0x0E	; 14
    741e:	86 e0       	ldi	r24, 0x06	; 6
    7420:	01 90       	ld	r0, Z+
    7422:	0d 92       	st	X+, r0
    7424:	81 50       	subi	r24, 0x01	; 1
    7426:	e1 f7       	brne	.-8      	; 0x7420 <arpArpIn+0xce>
    nicState.layer3.arp->sipaddr =  IpMyConfig.ip;
    7428:	00 91 88 0e 	lds	r16, 0x0E88
    742c:	10 91 89 0e 	lds	r17, 0x0E89
    7430:	80 91 50 0f 	lds	r24, 0x0F50
    7434:	90 91 51 0f 	lds	r25, 0x0F51
    7438:	a0 91 52 0f 	lds	r26, 0x0F52
    743c:	b0 91 53 0f 	lds	r27, 0x0F53
    7440:	f8 01       	movw	r30, r16
    7442:	86 87       	std	Z+14, r24	; 0x0e
    7444:	97 87       	std	Z+15, r25	; 0x0f
    7446:	a0 8b       	std	Z+16, r26	; 0x10
    7448:	b1 8b       	std	Z+17, r27	; 0x11
// change op to reply
    nicState.layer3.arp->opcode = htons(ARP_OPCODE_REPLY);
    744a:	82 e0       	ldi	r24, 0x02	; 2
    744c:	90 e0       	ldi	r25, 0x00	; 0
    744e:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    7452:	f8 01       	movw	r30, r16
    7454:	97 83       	std	Z+7, r25	; 0x07
    7456:	86 83       	std	Z+6, r24	; 0x06

// in ethernet header
    nicState.layer2.ethHeader->dest = nicState.layer2.ethHeader->src;
    7458:	e0 91 86 0e 	lds	r30, 0x0E86
    745c:	f0 91 87 0e 	lds	r31, 0x0E87
    7460:	df 01       	movw	r26, r30
    7462:	16 96       	adiw	r26, 0x06	; 6
    7464:	86 e0       	ldi	r24, 0x06	; 6
    7466:	0d 90       	ld	r0, X+
    7468:	01 92       	st	Z+, r0
    746a:	81 50       	subi	r24, 0x01	; 1
    746c:	e1 f7       	brne	.-8      	; 0x7466 <arpArpIn+0x114>
    nicState.layer2.ethHeader->src  = nicState.mac;
    746e:	e0 91 86 0e 	lds	r30, 0x0E86
    7472:	f0 91 87 0e 	lds	r31, 0x0E87
    7476:	36 96       	adiw	r30, 0x06	; 6
    7478:	a0 e8       	ldi	r26, 0x80	; 128
    747a:	be e0       	ldi	r27, 0x0E	; 14
    747c:	86 e0       	ldi	r24, 0x06	; 6
    747e:	0d 90       	ld	r0, X+
    7480:	01 92       	st	Z+, r0
    7482:	81 50       	subi	r24, 0x01	; 1
    7484:	e1 f7       	brne	.-8      	; 0x747e <arpArpIn+0x12c>

#ifdef ARP_DEBUG
    if (arpDebug != NULL)
    7486:	20 91 8c 0e 	lds	r18, 0x0E8C
    748a:	30 91 8d 0e 	lds	r19, 0x0E8D
    748e:	21 15       	cp	r18, r1
    7490:	31 05       	cpc	r19, r1
    7492:	11 f1       	breq	.+68     	; 0x74d8 <arpArpIn+0x186>
    {
      if (arpDebugLevel > 0)
    7494:	80 91 5f 0f 	lds	r24, 0x0F5F
    7498:	88 23       	and	r24, r24
    749a:	81 f0       	breq	.+32     	; 0x74bc <arpArpIn+0x16a>
        fprintf_P(arpDebug, PSTR("Sending ARP Reply\r\n"));
    749c:	00 d0       	rcall	.+0      	; 0x749e <arpArpIn+0x14c>
    749e:	00 d0       	rcall	.+0      	; 0x74a0 <arpArpIn+0x14e>
    74a0:	ed b7       	in	r30, 0x3d	; 61
    74a2:	fe b7       	in	r31, 0x3e	; 62
    74a4:	32 83       	std	Z+2, r19	; 0x02
    74a6:	21 83       	std	Z+1, r18	; 0x01
    74a8:	8e e7       	ldi	r24, 0x7E	; 126
    74aa:	90 e1       	ldi	r25, 0x10	; 16
    74ac:	94 83       	std	Z+4, r25	; 0x04
    74ae:	83 83       	std	Z+3, r24	; 0x03
    74b0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    74b4:	0f 90       	pop	r0
    74b6:	0f 90       	pop	r0
    74b8:	0f 90       	pop	r0
    74ba:	0f 90       	pop	r0
      if (arpDebugLevel > 2)
    74bc:	80 91 5f 0f 	lds	r24, 0x0F5F
    74c0:	83 30       	cpi	r24, 0x03	; 3
    74c2:	50 f0       	brcs	.+20     	; 0x74d8 <arpArpIn+0x186>
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    74c4:	60 91 88 0e 	lds	r22, 0x0E88
    74c8:	70 91 89 0e 	lds	r23, 0x0E89
    74cc:	80 91 8c 0e 	lds	r24, 0x0E8C
    74d0:	90 91 8d 0e 	lds	r25, 0x0E8D
    74d4:	0e 94 32 38 	call	0x7064	; 0x7064 <arpPrintHeader>
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    74d8:	8a e2       	ldi	r24, 0x2A	; 42
    74da:	90 e0       	ldi	r25, 0x00	; 0
    74dc:	0e 94 10 2c 	call	0x5820	; 0x5820 <nicSend>
  }
}
    74e0:	df 91       	pop	r29
    74e2:	cf 91       	pop	r28
    74e4:	1f 91       	pop	r17
    74e6:	0f 91       	pop	r16
    74e8:	08 95       	ret

000074ea <sendTcBuffer>:

uint8_t sendTcBuffer(uint8_t socketNo)
{
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    74ea:	80 e0       	ldi	r24, 0x00	; 0
    74ec:	08 95       	ret

000074ee <setTcpDebug>:
}

#if TCP_DEBUG
void setTcpDebug(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    74ee:	90 93 4f 0f 	sts	0x0F4F, r25
    74f2:	80 93 4e 0f 	sts	0x0F4E, r24
  tcpDebugLevel = level;
    74f6:	60 93 a5 0e 	sts	0x0EA5, r22
}
    74fa:	08 95       	ret

000074fc <flushTcpQueues>:
  for (sckNo = 0; sckNo < NUMBER_OF_SOCKETS; sckNo++)
  {
    
    sck++;
  }
}
    74fc:	08 95       	ret

000074fe <httpProcess>:
          continue;  
        }
      }

#endif
    74fe:	08 95       	ret

00007500 <calculateTcpChecksun>:
  
  return 0;
}

void calculateTcpChecksun(uint16_t tcpLen)
{
    7500:	0f 93       	push	r16
    7502:	1f 93       	push	r17
    7504:	bc 01       	movw	r22, r24
  nicState.layer4.tcp->tcpchksum = 0;
    7506:	00 91 8a 0e 	lds	r16, 0x0E8A
    750a:	10 91 8b 0e 	lds	r17, 0x0E8B
    750e:	f8 01       	movw	r30, r16
    7510:	11 8a       	std	Z+17, r1	; 0x11
    7512:	10 8a       	std	Z+16, r1	; 0x10
  nicState.layer4.tcp->tcpchksum = netChecksum(nicState.layer4.tcp, tcpLen); //TODO finish it
    7514:	c8 01       	movw	r24, r16
    7516:	0e 94 fa 2d 	call	0x5bf4	; 0x5bf4 <netChecksum>
    751a:	f8 01       	movw	r30, r16
    751c:	91 8b       	std	Z+17, r25	; 0x11
    751e:	80 8b       	std	Z+16, r24	; 0x10
}
    7520:	1f 91       	pop	r17
    7522:	0f 91       	pop	r16
    7524:	08 95       	ret

00007526 <processTcpPacket>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket(void)
{
    7526:	af 92       	push	r10
    7528:	bf 92       	push	r11
    752a:	cf 92       	push	r12
    752c:	df 92       	push	r13
    752e:	ef 92       	push	r14
    7530:	ff 92       	push	r15
    7532:	0f 93       	push	r16
    7534:	1f 93       	push	r17
    7536:	cf 93       	push	r28
    7538:	df 93       	push	r29
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    753a:	e0 91 bc 0e 	lds	r30, 0x0EBC
    753e:	f0 91 bd 0e 	lds	r31, 0x0EBD
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
    7542:	e0 90 88 0e 	lds	r14, 0x0E88
    7546:	f0 90 89 0e 	lds	r15, 0x0E89
    754a:	60 91 8a 0e 	lds	r22, 0x0E8A
    754e:	70 91 8b 0e 	lds	r23, 0x0E8B
    7552:	ef 01       	movw	r28, r30
    7554:	00 e0       	ldi	r16, 0x00	; 0
    7556:	18 81       	ld	r17, Y
    7558:	12 30       	cpi	r17, 0x02	; 2
    755a:	08 f4       	brcc	.+2      	; 0x755e <processTcpPacket+0x38>
    755c:	4b c0       	rjmp	.+150    	; 0x75f4 <processTcpPacket+0xce>
    755e:	29 81       	ldd	r18, Y+1	; 0x01
    7560:	3a 81       	ldd	r19, Y+2	; 0x02
    7562:	4b 81       	ldd	r20, Y+3	; 0x03
    7564:	5c 81       	ldd	r21, Y+4	; 0x04
    7566:	d7 01       	movw	r26, r14
    7568:	1c 96       	adiw	r26, 0x0c	; 12
    756a:	ad 90       	ld	r10, X+
    756c:	bd 90       	ld	r11, X+
    756e:	cd 90       	ld	r12, X+
    7570:	dc 90       	ld	r13, X
    7572:	1f 97       	sbiw	r26, 0x0f	; 15
    7574:	2a 15       	cp	r18, r10
    7576:	3b 05       	cpc	r19, r11
    7578:	4c 05       	cpc	r20, r12
    757a:	5d 05       	cpc	r21, r13
    757c:	d9 f5       	brne	.+118    	; 0x75f4 <processTcpPacket+0xce>
    757e:	2d 81       	ldd	r18, Y+5	; 0x05
    7580:	3e 81       	ldd	r19, Y+6	; 0x06
    7582:	db 01       	movw	r26, r22
    7584:	12 96       	adiw	r26, 0x02	; 2
    7586:	8d 91       	ld	r24, X+
    7588:	9c 91       	ld	r25, X
    758a:	13 97       	sbiw	r26, 0x03	; 3
    758c:	28 17       	cp	r18, r24
    758e:	39 07       	cpc	r19, r25
    7590:	89 f5       	brne	.+98     	; 0x75f4 <processTcpPacket+0xce>
    7592:	2f 81       	ldd	r18, Y+7	; 0x07
    7594:	38 85       	ldd	r19, Y+8	; 0x08
    7596:	8d 91       	ld	r24, X+
    7598:	9c 91       	ld	r25, X
    759a:	28 17       	cp	r18, r24
    759c:	39 07       	cpc	r19, r25
    759e:	51 f5       	brne	.+84     	; 0x75f4 <processTcpPacket+0xce>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    75a0:	20 91 4e 0f 	lds	r18, 0x0F4E
    75a4:	30 91 4f 0f 	lds	r19, 0x0F4F
    75a8:	21 15       	cp	r18, r1
    75aa:	31 05       	cpc	r19, r1
    75ac:	09 f4       	brne	.+2      	; 0x75b0 <processTcpPacket+0x8a>
    75ae:	9d c0       	rjmp	.+314    	; 0x76ea <processTcpPacket+0x1c4>
        if (tcpDebugLevel > 2)
    75b0:	80 91 a5 0e 	lds	r24, 0x0EA5
    75b4:	83 30       	cpi	r24, 0x03	; 3
    75b6:	08 f4       	brcc	.+2      	; 0x75ba <processTcpPacket+0x94>
    75b8:	98 c0       	rjmp	.+304    	; 0x76ea <processTcpPacket+0x1c4>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    75ba:	00 d0       	rcall	.+0      	; 0x75bc <processTcpPacket+0x96>
    75bc:	00 d0       	rcall	.+0      	; 0x75be <processTcpPacket+0x98>
    75be:	00 d0       	rcall	.+0      	; 0x75c0 <processTcpPacket+0x9a>
    75c0:	ed b7       	in	r30, 0x3d	; 61
    75c2:	fe b7       	in	r31, 0x3e	; 62
    75c4:	31 96       	adiw	r30, 0x01	; 1
    75c6:	ad b7       	in	r26, 0x3d	; 61
    75c8:	be b7       	in	r27, 0x3e	; 62
    75ca:	12 96       	adiw	r26, 0x02	; 2
    75cc:	3c 93       	st	X, r19
    75ce:	2e 93       	st	-X, r18
    75d0:	11 97       	sbiw	r26, 0x01	; 1
    75d2:	82 e0       	ldi	r24, 0x02	; 2
    75d4:	92 e1       	ldi	r25, 0x12	; 18
    75d6:	93 83       	std	Z+3, r25	; 0x03
    75d8:	82 83       	std	Z+2, r24	; 0x02
    75da:	14 83       	std	Z+4, r17	; 0x04
    75dc:	15 82       	std	Z+5, r1	; 0x05
    75de:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    75e2:	ed b7       	in	r30, 0x3d	; 61
    75e4:	fe b7       	in	r31, 0x3e	; 62
    75e6:	36 96       	adiw	r30, 0x06	; 6
    75e8:	0f b6       	in	r0, 0x3f	; 63
    75ea:	f8 94       	cli
    75ec:	fe bf       	out	0x3e, r31	; 62
    75ee:	0f be       	out	0x3f, r0	; 63
    75f0:	ed bf       	out	0x3d, r30	; 61
    75f2:	7b c0       	rjmp	.+246    	; 0x76ea <processTcpPacket+0x1c4>

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    75f4:	0f 5f       	subi	r16, 0xFF	; 255
    75f6:	04 31       	cpi	r16, 0x14	; 20
    75f8:	11 f0       	breq	.+4      	; 0x75fe <processTcpPacket+0xd8>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
#endif      
      return result;
    }
    result++;
    75fa:	6c 96       	adiw	r28, 0x1c	; 28
    75fc:	ac cf       	rjmp	.-168    	; 0x7556 <processTcpPacket+0x30>
    75fe:	00 e0       	ldi	r16, 0x00	; 0
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    7600:	80 81       	ld	r24, Z
    7602:	81 30       	cpi	r24, 0x01	; 1
    7604:	e1 f5       	brne	.+120    	; 0x767e <processTcpPacket+0x158>
    7606:	25 81       	ldd	r18, Z+5	; 0x05
    7608:	36 81       	ldd	r19, Z+6	; 0x06
    760a:	db 01       	movw	r26, r22
    760c:	12 96       	adiw	r26, 0x02	; 2
    760e:	8d 91       	ld	r24, X+
    7610:	9c 91       	ld	r25, X
    7612:	13 97       	sbiw	r26, 0x03	; 3
    7614:	28 17       	cp	r18, r24
    7616:	39 07       	cpc	r19, r25
    7618:	91 f5       	brne	.+100    	; 0x767e <processTcpPacket+0x158>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    761a:	20 91 4e 0f 	lds	r18, 0x0F4E
    761e:	30 91 4f 0f 	lds	r19, 0x0F4F
    7622:	21 15       	cp	r18, r1
    7624:	31 05       	cpc	r19, r1
    7626:	01 f1       	breq	.+64     	; 0x7668 <processTcpPacket+0x142>
        if (tcpDebugLevel > 2)
    7628:	80 91 a5 0e 	lds	r24, 0x0EA5
    762c:	83 30       	cpi	r24, 0x03	; 3
    762e:	e0 f0       	brcs	.+56     	; 0x7668 <processTcpPacket+0x142>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    7630:	00 d0       	rcall	.+0      	; 0x7632 <processTcpPacket+0x10c>
    7632:	00 d0       	rcall	.+0      	; 0x7634 <processTcpPacket+0x10e>
    7634:	00 d0       	rcall	.+0      	; 0x7636 <processTcpPacket+0x110>
    7636:	ed b7       	in	r30, 0x3d	; 61
    7638:	fe b7       	in	r31, 0x3e	; 62
    763a:	31 96       	adiw	r30, 0x01	; 1
    763c:	ad b7       	in	r26, 0x3d	; 61
    763e:	be b7       	in	r27, 0x3e	; 62
    7640:	12 96       	adiw	r26, 0x02	; 2
    7642:	3c 93       	st	X, r19
    7644:	2e 93       	st	-X, r18
    7646:	11 97       	sbiw	r26, 0x01	; 1
    7648:	8c ed       	ldi	r24, 0xDC	; 220
    764a:	91 e1       	ldi	r25, 0x11	; 17
    764c:	93 83       	std	Z+3, r25	; 0x03
    764e:	82 83       	std	Z+2, r24	; 0x02
    7650:	04 83       	std	Z+4, r16	; 0x04
    7652:	15 82       	std	Z+5, r1	; 0x05
    7654:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7658:	ed b7       	in	r30, 0x3d	; 61
    765a:	fe b7       	in	r31, 0x3e	; 62
    765c:	36 96       	adiw	r30, 0x06	; 6
    765e:	0f b6       	in	r0, 0x3f	; 63
    7660:	f8 94       	cli
    7662:	fe bf       	out	0x3e, r31	; 62
    7664:	0f be       	out	0x3f, r0	; 63
    7666:	ed bf       	out	0x3d, r30	; 61
#endif      
      return &sockets[i];
    7668:	8c e1       	ldi	r24, 0x1C	; 28
    766a:	08 9f       	mul	r16, r24
    766c:	c0 01       	movw	r24, r0
    766e:	11 24       	eor	r1, r1
    7670:	c0 91 bc 0e 	lds	r28, 0x0EBC
    7674:	d0 91 bd 0e 	lds	r29, 0x0EBD
    7678:	c8 0f       	add	r28, r24
    767a:	d9 1f       	adc	r29, r25
    767c:	36 c0       	rjmp	.+108    	; 0x76ea <processTcpPacket+0x1c4>
    }
    result++;
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    767e:	0f 5f       	subi	r16, 0xFF	; 255
    7680:	04 31       	cpi	r16, 0x14	; 20
    7682:	11 f0       	breq	.+4      	; 0x7688 <processTcpPacket+0x162>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
#endif      
      return &sockets[i];
    }
    result++;
    7684:	7c 96       	adiw	r30, 0x1c	; 28
    7686:	bc cf       	rjmp	.-136    	; 0x7600 <processTcpPacket+0xda>
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    7688:	c0 91 4e 0f 	lds	r28, 0x0F4E
    768c:	d0 91 4f 0f 	lds	r29, 0x0F4F
    7690:	20 97       	sbiw	r28, 0x00	; 0
    7692:	09 f4       	brne	.+2      	; 0x7696 <processTcpPacket+0x170>
    7694:	64 c1       	rjmp	.+712    	; 0x795e <processTcpPacket+0x438>
    if (tcpDebugLevel > 2)
    7696:	80 91 a5 0e 	lds	r24, 0x0EA5
    769a:	83 30       	cpi	r24, 0x03	; 3
    769c:	08 f4       	brcc	.+2      	; 0x76a0 <processTcpPacket+0x17a>
    769e:	5f c1       	rjmp	.+702    	; 0x795e <processTcpPacket+0x438>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    76a0:	db 01       	movw	r26, r22
    76a2:	12 96       	adiw	r26, 0x02	; 2
    76a4:	8d 91       	ld	r24, X+
    76a6:	9c 91       	ld	r25, X
    76a8:	13 97       	sbiw	r26, 0x03	; 3
    76aa:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    76ae:	00 d0       	rcall	.+0      	; 0x76b0 <processTcpPacket+0x18a>
    76b0:	00 d0       	rcall	.+0      	; 0x76b2 <processTcpPacket+0x18c>
    76b2:	00 d0       	rcall	.+0      	; 0x76b4 <processTcpPacket+0x18e>
    76b4:	ed b7       	in	r30, 0x3d	; 61
    76b6:	fe b7       	in	r31, 0x3e	; 62
    76b8:	31 96       	adiw	r30, 0x01	; 1
    76ba:	ad b7       	in	r26, 0x3d	; 61
    76bc:	be b7       	in	r27, 0x3e	; 62
    76be:	12 96       	adiw	r26, 0x02	; 2
    76c0:	dc 93       	st	X, r29
    76c2:	ce 93       	st	-X, r28
    76c4:	11 97       	sbiw	r26, 0x01	; 1
    76c6:	22 eb       	ldi	r18, 0xB2	; 178
    76c8:	31 e1       	ldi	r19, 0x11	; 17
    76ca:	33 83       	std	Z+3, r19	; 0x03
    76cc:	22 83       	std	Z+2, r18	; 0x02
    76ce:	95 83       	std	Z+5, r25	; 0x05
    76d0:	84 83       	std	Z+4, r24	; 0x04
    76d2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    76d6:	81 e0       	ldi	r24, 0x01	; 1
    76d8:	ed b7       	in	r30, 0x3d	; 61
    76da:	fe b7       	in	r31, 0x3e	; 62
    76dc:	36 96       	adiw	r30, 0x06	; 6
    76de:	0f b6       	in	r0, 0x3f	; 63
    76e0:	f8 94       	cli
    76e2:	fe bf       	out	0x3e, r31	; 62
    76e4:	0f be       	out	0x3f, r0	; 63
    76e6:	ed bf       	out	0x3d, r30	; 61
    76e8:	3d c1       	rjmp	.+634    	; 0x7964 <processTcpPacket+0x43e>

inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    76ea:	20 97       	sbiw	r28, 0x00	; 0
    76ec:	09 f4       	brne	.+2      	; 0x76f0 <processTcpPacket+0x1ca>
    76ee:	37 c1       	rjmp	.+622    	; 0x795e <processTcpPacket+0x438>
    return 1;
  
  
  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    76f0:	e0 91 8a 0e 	lds	r30, 0x0E8A
    76f4:	f0 91 8b 0e 	lds	r31, 0x0E8B
    76f8:	64 81       	ldd	r22, Z+4	; 0x04
    76fa:	75 81       	ldd	r23, Z+5	; 0x05
    76fc:	86 81       	ldd	r24, Z+6	; 0x06
    76fe:	97 81       	ldd	r25, Z+7	; 0x07
    7700:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <htonl>
    7704:	69 87       	std	Y+9, r22	; 0x09
    7706:	7a 87       	std	Y+10, r23	; 0x0a
    7708:	8b 87       	std	Y+11, r24	; 0x0b
    770a:	9c 87       	std	Y+12, r25	; 0x0c
  
  if (socket->state == LISTEN)
    770c:	88 81       	ld	r24, Y
    770e:	81 30       	cpi	r24, 0x01	; 1
    7710:	09 f0       	breq	.+2      	; 0x7714 <processTcpPacket+0x1ee>
    7712:	b5 c0       	rjmp	.+362    	; 0x787e <processTcpPacket+0x358>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    7714:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7718:	f0 91 8b 0e 	lds	r31, 0x0E8B
    771c:	85 85       	ldd	r24, Z+13	; 0x0d
    771e:	20 91 4e 0f 	lds	r18, 0x0F4E
    7722:	30 91 4f 0f 	lds	r19, 0x0F4F
    7726:	81 ff       	sbrs	r24, 1
    7728:	96 c0       	rjmp	.+300    	; 0x7856 <processTcpPacket+0x330>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    772a:	21 15       	cp	r18, r1
    772c:	31 05       	cpc	r19, r1
    772e:	c1 f0       	breq	.+48     	; 0x7760 <processTcpPacket+0x23a>
        if (tcpDebugLevel > 2)
    7730:	80 91 a5 0e 	lds	r24, 0x0EA5
    7734:	83 30       	cpi	r24, 0x03	; 3
    7736:	a0 f0       	brcs	.+40     	; 0x7760 <processTcpPacket+0x23a>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    7738:	00 d0       	rcall	.+0      	; 0x773a <processTcpPacket+0x214>
    773a:	00 d0       	rcall	.+0      	; 0x773c <processTcpPacket+0x216>
    773c:	ad b7       	in	r26, 0x3d	; 61
    773e:	be b7       	in	r27, 0x3e	; 62
    7740:	12 96       	adiw	r26, 0x02	; 2
    7742:	3c 93       	st	X, r19
    7744:	2e 93       	st	-X, r18
    7746:	11 97       	sbiw	r26, 0x01	; 1
    7748:	80 e7       	ldi	r24, 0x70	; 112
    774a:	91 e1       	ldi	r25, 0x11	; 17
    774c:	14 96       	adiw	r26, 0x04	; 4
    774e:	9c 93       	st	X, r25
    7750:	8e 93       	st	-X, r24
    7752:	13 97       	sbiw	r26, 0x03	; 3
    7754:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7758:	0f 90       	pop	r0
    775a:	0f 90       	pop	r0
    775c:	0f 90       	pop	r0
    775e:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    7760:	82 e0       	ldi	r24, 0x02	; 2
    7762:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    7764:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7768:	f0 91 8b 0e 	lds	r31, 0x0E8B
    776c:	80 81       	ld	r24, Z
    776e:	91 81       	ldd	r25, Z+1	; 0x01
    7770:	98 87       	std	Y+8, r25	; 0x08
    7772:	8f 83       	std	Y+7, r24	; 0x07
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    7774:	e0 91 88 0e 	lds	r30, 0x0E88
    7778:	f0 91 89 0e 	lds	r31, 0x0E89
    777c:	84 85       	ldd	r24, Z+12	; 0x0c
    777e:	95 85       	ldd	r25, Z+13	; 0x0d
    7780:	a6 85       	ldd	r26, Z+14	; 0x0e
    7782:	b7 85       	ldd	r27, Z+15	; 0x0f
    7784:	89 83       	std	Y+1, r24	; 0x01
    7786:	9a 83       	std	Y+2, r25	; 0x02
    7788:	ab 83       	std	Y+3, r26	; 0x03
    778a:	bc 83       	std	Y+4, r27	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    778c:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7790:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7794:	8d 81       	ldd	r24, Y+5	; 0x05
    7796:	9e 81       	ldd	r25, Y+6	; 0x06
    7798:	91 83       	std	Z+1, r25	; 0x01
    779a:	80 83       	st	Z, r24
      nicState.layer4.tcp->destport  = socket->remotePort;
    779c:	00 91 8a 0e 	lds	r16, 0x0E8A
    77a0:	10 91 8b 0e 	lds	r17, 0x0E8B
    77a4:	8f 81       	ldd	r24, Y+7	; 0x07
    77a6:	98 85       	ldd	r25, Y+8	; 0x08
    77a8:	f8 01       	movw	r30, r16
    77aa:	93 83       	std	Z+3, r25	; 0x03
    77ac:	82 83       	std	Z+2, r24	; 0x02
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    77ae:	6d 85       	ldd	r22, Y+13	; 0x0d
    77b0:	7e 85       	ldd	r23, Y+14	; 0x0e
    77b2:	8f 85       	ldd	r24, Y+15	; 0x0f
    77b4:	98 89       	ldd	r25, Y+16	; 0x10
    77b6:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <htonl>
    77ba:	d8 01       	movw	r26, r16
    77bc:	14 96       	adiw	r26, 0x04	; 4
    77be:	6d 93       	st	X+, r22
    77c0:	7d 93       	st	X+, r23
    77c2:	8d 93       	st	X+, r24
    77c4:	9c 93       	st	X, r25
    77c6:	17 97       	sbiw	r26, 0x07	; 7
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    77c8:	00 91 8a 0e 	lds	r16, 0x0E8A
    77cc:	10 91 8b 0e 	lds	r17, 0x0E8B
    77d0:	69 85       	ldd	r22, Y+9	; 0x09
    77d2:	7a 85       	ldd	r23, Y+10	; 0x0a
    77d4:	8b 85       	ldd	r24, Y+11	; 0x0b
    77d6:	9c 85       	ldd	r25, Y+12	; 0x0c
    77d8:	6f 5f       	subi	r22, 0xFF	; 255
    77da:	7f 4f       	sbci	r23, 0xFF	; 255
    77dc:	8f 4f       	sbci	r24, 0xFF	; 255
    77de:	9f 4f       	sbci	r25, 0xFF	; 255
    77e0:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <htonl>
    77e4:	f8 01       	movw	r30, r16
    77e6:	60 87       	std	Z+8, r22	; 0x08
    77e8:	71 87       	std	Z+9, r23	; 0x09
    77ea:	82 87       	std	Z+10, r24	; 0x0a
    77ec:	93 87       	std	Z+11, r25	; 0x0b
      nicState.layer4.tcp->tcpoffset = 5<<4;
    77ee:	00 91 8a 0e 	lds	r16, 0x0E8A
    77f2:	10 91 8b 0e 	lds	r17, 0x0E8B
    77f6:	80 e5       	ldi	r24, 0x50	; 80
    77f8:	d8 01       	movw	r26, r16
    77fa:	1c 96       	adiw	r26, 0x0c	; 12
    77fc:	8c 93       	st	X, r24
    77fe:	1c 97       	sbiw	r26, 0x0c	; 12
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    7800:	82 e1       	ldi	r24, 0x12	; 18
    7802:	1d 96       	adiw	r26, 0x0d	; 13
    7804:	8c 93       	st	X, r24
      nicState.layer4.tcp->wnd       = htons(100);
    7806:	84 e6       	ldi	r24, 0x64	; 100
    7808:	90 e0       	ldi	r25, 0x00	; 0
    780a:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    780e:	f8 01       	movw	r30, r16
    7810:	97 87       	std	Z+15, r25	; 0x0f
    7812:	86 87       	std	Z+14, r24	; 0x0e
      nicState.layer4.tcp->tcpchksum = 0;
    7814:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7818:	f0 91 8b 0e 	lds	r31, 0x0E8B
    781c:	11 8a       	std	Z+17, r1	; 0x11
    781e:	10 8a       	std	Z+16, r1	; 0x10
      nicState.layer4.tcp->urgp      = 0;
    7820:	13 8a       	std	Z+19, r1	; 0x13
    7822:	12 8a       	std	Z+18, r1	; 0x12
      calculateTcpChecksun(TCP_HEADER_LEN);
    7824:	84 e1       	ldi	r24, 0x14	; 20
    7826:	90 e0       	ldi	r25, 0x00	; 0
    7828:	0e 94 80 3a 	call	0x7500	; 0x7500 <calculateTcpChecksun>

      socket->seqNoLastSent++;
    782c:	8d 85       	ldd	r24, Y+13	; 0x0d
    782e:	9e 85       	ldd	r25, Y+14	; 0x0e
    7830:	af 85       	ldd	r26, Y+15	; 0x0f
    7832:	b8 89       	ldd	r27, Y+16	; 0x10
    7834:	01 96       	adiw	r24, 0x01	; 1
    7836:	a1 1d       	adc	r26, r1
    7838:	b1 1d       	adc	r27, r1
    783a:	8d 87       	std	Y+13, r24	; 0x0d
    783c:	9e 87       	std	Y+14, r25	; 0x0e
    783e:	af 87       	std	Y+15, r26	; 0x0f
    7840:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    7842:	69 81       	ldd	r22, Y+1	; 0x01
    7844:	7a 81       	ldd	r23, Y+2	; 0x02
    7846:	8b 81       	ldd	r24, Y+3	; 0x03
    7848:	9c 81       	ldd	r25, Y+4	; 0x04
    784a:	46 e0       	ldi	r20, 0x06	; 6
    784c:	24 e1       	ldi	r18, 0x14	; 20
    784e:	30 e0       	ldi	r19, 0x00	; 0
    7850:	0e 94 8b 32 	call	0x6516	; 0x6516 <ipSend>
    7854:	86 c0       	rjmp	.+268    	; 0x7962 <processTcpPacket+0x43c>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    7856:	21 15       	cp	r18, r1
    7858:	31 05       	cpc	r19, r1
    785a:	09 f4       	brne	.+2      	; 0x785e <processTcpPacket+0x338>
    785c:	82 c0       	rjmp	.+260    	; 0x7962 <processTcpPacket+0x43c>
        if (tcpDebugLevel > 1)
    785e:	80 91 a5 0e 	lds	r24, 0x0EA5
    7862:	82 30       	cpi	r24, 0x02	; 2
    7864:	08 f4       	brcc	.+2      	; 0x7868 <processTcpPacket+0x342>
    7866:	7d c0       	rjmp	.+250    	; 0x7962 <processTcpPacket+0x43c>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    7868:	00 d0       	rcall	.+0      	; 0x786a <processTcpPacket+0x344>
    786a:	00 d0       	rcall	.+0      	; 0x786c <processTcpPacket+0x346>
    786c:	ad b7       	in	r26, 0x3d	; 61
    786e:	be b7       	in	r27, 0x3e	; 62
    7870:	12 96       	adiw	r26, 0x02	; 2
    7872:	3c 93       	st	X, r19
    7874:	2e 93       	st	-X, r18
    7876:	11 97       	sbiw	r26, 0x01	; 1
    7878:	8c e3       	ldi	r24, 0x3C	; 60
    787a:	91 e1       	ldi	r25, 0x11	; 17
    787c:	39 c0       	rjmp	.+114    	; 0x78f0 <processTcpPacket+0x3ca>
    }
#endif    
    return 0;
  }
  
  if (socket->state == SYN_RECEIVED)
    787e:	82 30       	cpi	r24, 0x02	; 2
    7880:	09 f0       	breq	.+2      	; 0x7884 <processTcpPacket+0x35e>
    7882:	42 c0       	rjmp	.+132    	; 0x7908 <processTcpPacket+0x3e2>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    7884:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7888:	f0 91 8b 0e 	lds	r31, 0x0E8B
    788c:	85 85       	ldd	r24, Z+13	; 0x0d
    788e:	20 91 4e 0f 	lds	r18, 0x0F4E
    7892:	30 91 4f 0f 	lds	r19, 0x0F4F
    7896:	84 ff       	sbrs	r24, 4
    7898:	16 c0       	rjmp	.+44     	; 0x78c6 <processTcpPacket+0x3a0>
    {
      socket->state    = ESTABILISHED;
    789a:	83 e0       	ldi	r24, 0x03	; 3
    789c:	88 83       	st	Y, r24
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    789e:	21 15       	cp	r18, r1
    78a0:	31 05       	cpc	r19, r1
    78a2:	09 f4       	brne	.+2      	; 0x78a6 <processTcpPacket+0x380>
    78a4:	5e c0       	rjmp	.+188    	; 0x7962 <processTcpPacket+0x43c>
      if (tcpDebugLevel > 2)
    78a6:	80 91 a5 0e 	lds	r24, 0x0EA5
    78aa:	83 30       	cpi	r24, 0x03	; 3
    78ac:	08 f4       	brcc	.+2      	; 0x78b0 <processTcpPacket+0x38a>
    78ae:	59 c0       	rjmp	.+178    	; 0x7962 <processTcpPacket+0x43c>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    78b0:	00 d0       	rcall	.+0      	; 0x78b2 <processTcpPacket+0x38c>
    78b2:	00 d0       	rcall	.+0      	; 0x78b4 <processTcpPacket+0x38e>
    78b4:	ed b7       	in	r30, 0x3d	; 61
    78b6:	fe b7       	in	r31, 0x3e	; 62
    78b8:	32 83       	std	Z+2, r19	; 0x02
    78ba:	21 83       	std	Z+1, r18	; 0x01
    78bc:	84 ef       	ldi	r24, 0xF4	; 244
    78be:	90 e1       	ldi	r25, 0x10	; 16
    78c0:	94 83       	std	Z+4, r25	; 0x04
    78c2:	83 83       	std	Z+3, r24	; 0x03
    78c4:	19 c0       	rjmp	.+50     	; 0x78f8 <processTcpPacket+0x3d2>
#endif        

    }
    else
    {
      socket->state = LISTEN;
    78c6:	81 e0       	ldi	r24, 0x01	; 1
    78c8:	88 83       	st	Y, r24
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    78ca:	21 15       	cp	r18, r1
    78cc:	31 05       	cpc	r19, r1
    78ce:	09 f4       	brne	.+2      	; 0x78d2 <processTcpPacket+0x3ac>
    78d0:	48 c0       	rjmp	.+144    	; 0x7962 <processTcpPacket+0x43c>
        if (tcpDebugLevel > 1)
    78d2:	80 91 a5 0e 	lds	r24, 0x0EA5
    78d6:	82 30       	cpi	r24, 0x02	; 2
    78d8:	08 f4       	brcc	.+2      	; 0x78dc <processTcpPacket+0x3b6>
    78da:	43 c0       	rjmp	.+134    	; 0x7962 <processTcpPacket+0x43c>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    78dc:	00 d0       	rcall	.+0      	; 0x78de <processTcpPacket+0x3b8>
    78de:	00 d0       	rcall	.+0      	; 0x78e0 <processTcpPacket+0x3ba>
    78e0:	ad b7       	in	r26, 0x3d	; 61
    78e2:	be b7       	in	r27, 0x3e	; 62
    78e4:	12 96       	adiw	r26, 0x02	; 2
    78e6:	3c 93       	st	X, r19
    78e8:	2e 93       	st	-X, r18
    78ea:	11 97       	sbiw	r26, 0x01	; 1
    78ec:	80 ec       	ldi	r24, 0xC0	; 192
    78ee:	90 e1       	ldi	r25, 0x10	; 16
    78f0:	14 96       	adiw	r26, 0x04	; 4
    78f2:	9c 93       	st	X, r25
    78f4:	8e 93       	st	-X, r24
    78f6:	13 97       	sbiw	r26, 0x03	; 3
    78f8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    78fc:	80 e0       	ldi	r24, 0x00	; 0
    78fe:	0f 90       	pop	r0
    7900:	0f 90       	pop	r0
    7902:	0f 90       	pop	r0
    7904:	0f 90       	pop	r0
    7906:	2e c0       	rjmp	.+92     	; 0x7964 <processTcpPacket+0x43e>
    }
    return 0;
  }
  
  
  if (socket->state == ESTABILISHED)
    7908:	83 30       	cpi	r24, 0x03	; 3
    790a:	59 f5       	brne	.+86     	; 0x7962 <processTcpPacket+0x43c>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    790c:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7910:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7914:	85 85       	ldd	r24, Z+13	; 0x0d
    7916:	80 ff       	sbrs	r24, 0
    7918:	24 c0       	rjmp	.+72     	; 0x7962 <processTcpPacket+0x43c>
    {
      socket->timer              = timer100Hz;
    791a:	80 91 88 01 	lds	r24, 0x0188
    791e:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    7920:	80 e1       	ldi	r24, 0x10	; 16
    7922:	85 87       	std	Z+13, r24	; 0x0d
//      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
//      {
//        dataFromBufLen++;
//        dataPtr++;
//      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    7924:	69 81       	ldd	r22, Y+1	; 0x01
    7926:	7a 81       	ldd	r23, Y+2	; 0x02
    7928:	8b 81       	ldd	r24, Y+3	; 0x03
    792a:	9c 81       	ldd	r25, Y+4	; 0x04
    792c:	46 e0       	ldi	r20, 0x06	; 6
    792e:	24 e1       	ldi	r18, 0x14	; 20
    7930:	30 e0       	ldi	r19, 0x00	; 0
    7932:	0e 94 8b 32 	call	0x6516	; 0x6516 <ipSend>
      socket->state    = CLOSE_WAIT;
    7936:	84 e0       	ldi	r24, 0x04	; 4
    7938:	88 83       	st	Y, r24
      
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    793a:	e0 91 8a 0e 	lds	r30, 0x0E8A
    793e:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7942:	81 e0       	ldi	r24, 0x01	; 1
    7944:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    7946:	69 81       	ldd	r22, Y+1	; 0x01
    7948:	7a 81       	ldd	r23, Y+2	; 0x02
    794a:	8b 81       	ldd	r24, Y+3	; 0x03
    794c:	9c 81       	ldd	r25, Y+4	; 0x04
    794e:	46 e0       	ldi	r20, 0x06	; 6
    7950:	24 e1       	ldi	r18, 0x14	; 20
    7952:	30 e0       	ldi	r19, 0x00	; 0
    7954:	0e 94 8b 32 	call	0x6516	; 0x6516 <ipSend>
      socket->state    = LAST_ACK;
    7958:	85 e0       	ldi	r24, 0x05	; 5
    795a:	88 83       	st	Y, r24
    795c:	02 c0       	rjmp	.+4      	; 0x7962 <processTcpPacket+0x43c>
    795e:	81 e0       	ldi	r24, 0x01	; 1
    7960:	01 c0       	rjmp	.+2      	; 0x7964 <processTcpPacket+0x43e>
    7962:	80 e0       	ldi	r24, 0x00	; 0
  }

  //Read data and put into the queue
  
  return 0;
}
    7964:	df 91       	pop	r29
    7966:	cf 91       	pop	r28
    7968:	1f 91       	pop	r17
    796a:	0f 91       	pop	r16
    796c:	ff 90       	pop	r15
    796e:	ef 90       	pop	r14
    7970:	df 90       	pop	r13
    7972:	cf 90       	pop	r12
    7974:	bf 90       	pop	r11
    7976:	af 90       	pop	r10
    7978:	08 95       	ret

0000797a <netstackTCPIPProcess>:
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}

void netstackTCPIPProcess(void)
{
    797a:	0f 93       	push	r16
    797c:	1f 93       	push	r17
  if (nicState.layer4.tcp->destport == htons(80))
    797e:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7982:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7986:	02 81       	ldd	r16, Z+2	; 0x02
    7988:	13 81       	ldd	r17, Z+3	; 0x03
    798a:	80 e5       	ldi	r24, 0x50	; 80
    798c:	90 e0       	ldi	r25, 0x00	; 0
    798e:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    7992:	08 17       	cp	r16, r24
    7994:	19 07       	cpc	r17, r25
    7996:	b9 f4       	brne	.+46     	; 0x79c6 <netstackTCPIPProcess+0x4c>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    7998:	80 91 4e 0f 	lds	r24, 0x0F4E
    799c:	90 91 4f 0f 	lds	r25, 0x0F4F
    79a0:	00 97       	sbiw	r24, 0x00	; 0
    79a2:	99 f0       	breq	.+38     	; 0x79ca <netstackTCPIPProcess+0x50>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    79a4:	00 d0       	rcall	.+0      	; 0x79a6 <netstackTCPIPProcess+0x2c>
    79a6:	00 d0       	rcall	.+0      	; 0x79a8 <netstackTCPIPProcess+0x2e>
    79a8:	ed b7       	in	r30, 0x3d	; 61
    79aa:	fe b7       	in	r31, 0x3e	; 62
    79ac:	92 83       	std	Z+2, r25	; 0x02
    79ae:	81 83       	std	Z+1, r24	; 0x01
    79b0:	89 ea       	ldi	r24, 0xA9	; 169
    79b2:	90 e1       	ldi	r25, 0x10	; 16
    79b4:	94 83       	std	Z+4, r25	; 0x04
    79b6:	83 83       	std	Z+3, r24	; 0x03
    79b8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    79bc:	0f 90       	pop	r0
    79be:	0f 90       	pop	r0
    79c0:	0f 90       	pop	r0
    79c2:	0f 90       	pop	r0
    79c4:	02 c0       	rjmp	.+4      	; 0x79ca <netstackTCPIPProcess+0x50>
#endif
    ;
  }
  else
  {
    processTcpPacket();
    79c6:	0e 94 93 3a 	call	0x7526	; 0x7526 <processTcpPacket>
  }
}
    79ca:	1f 91       	pop	r17
    79cc:	0f 91       	pop	r16
    79ce:	08 95       	ret

000079d0 <socketInit>:
 * @param *sck socket
 */
static inline void tcpAcceptConn(struct TcpIpSocket *sck);

inline void socketInit(void)
{
    79d0:	bf 92       	push	r11
    79d2:	cf 92       	push	r12
    79d4:	df 92       	push	r13
    79d6:	ef 92       	push	r14
    79d8:	ff 92       	push	r15
    79da:	0f 93       	push	r16
    79dc:	1f 93       	push	r17
    79de:	cf 93       	push	r28
    79e0:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    79e2:	80 e3       	ldi	r24, 0x30	; 48
    79e4:	92 e0       	ldi	r25, 0x02	; 2
    79e6:	0e 94 2e 1c 	call	0x385c	; 0x385c <xmalloc>
    79ea:	80 93 bc 0e 	sts	0x0EBC, r24
    79ee:	90 93 bd 0e 	sts	0x0EBD, r25
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    79f2:	fc 01       	movw	r30, r24
    79f4:	80 e3       	ldi	r24, 0x30	; 48
    79f6:	92 e0       	ldi	r25, 0x02	; 2
    79f8:	df 01       	movw	r26, r30
    79fa:	9c 01       	movw	r18, r24
    79fc:	1d 92       	st	X+, r1
    79fe:	21 50       	subi	r18, 0x01	; 1
    7a00:	30 40       	sbci	r19, 0x00	; 0
    7a02:	e1 f7       	brne	.-8      	; 0x79fc <socketInit+0x2c>
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    7a04:	00 91 bc 0e 	lds	r16, 0x0EBC
    7a08:	10 91 bd 0e 	lds	r17, 0x0EBD
    7a0c:	c8 ea       	ldi	r28, 0xA8	; 168
    7a0e:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7a10:	8f ef       	ldi	r24, 0xFF	; 255
    7a12:	c8 2e       	mov	r12, r24
    7a14:	81 e1       	ldi	r24, 0x11	; 17
    7a16:	d8 2e       	mov	r13, r24
    7a18:	82 e2       	ldi	r24, 0x22	; 34
    7a1a:	e8 2e       	mov	r14, r24
    7a1c:	83 e3       	ldi	r24, 0x33	; 51
    7a1e:	f8 2e       	mov	r15, r24
    sck->state         = LISTEN;   
    7a20:	bb 24       	eor	r11, r11
    7a22:	b3 94       	inc	r11
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    7a24:	de 01       	movw	r26, r28
    7a26:	a8 5a       	subi	r26, 0xA8	; 168
    7a28:	a0 31       	cpi	r26, 0x10	; 16
    7a2a:	18 f0       	brcs	.+6      	; 0x7a32 <socketInit+0x62>
    7a2c:	88 eb       	ldi	r24, 0xB8	; 184
    7a2e:	91 e6       	ldi	r25, 0x61	; 97
    7a30:	03 c0       	rjmp	.+6      	; 0x7a38 <socketInit+0x68>
    7a32:	ce 01       	movw	r24, r28
    7a34:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    7a38:	f8 01       	movw	r30, r16
    7a3a:	96 83       	std	Z+6, r25	; 0x06
    7a3c:	85 83       	std	Z+5, r24	; 0x05
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7a3e:	d8 01       	movw	r26, r16
    7a40:	1d 96       	adiw	r26, 0x0d	; 13
    7a42:	cd 92       	st	X+, r12
    7a44:	dd 92       	st	X+, r13
    7a46:	ed 92       	st	X+, r14
    7a48:	fc 92       	st	X, r15
    7a4a:	50 97       	sbiw	r26, 0x10	; 16
    sck->state         = LISTEN;   
    7a4c:	bc 92       	st	X, r11
    7a4e:	21 96       	adiw	r28, 0x01	; 1
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    7a50:	b1 e6       	ldi	r27, 0x61	; 97
    7a52:	cc 3b       	cpi	r28, 0xBC	; 188
    7a54:	db 07       	cpc	r29, r27
    7a56:	19 f0       	breq	.+6      	; 0x7a5e <socketInit+0x8e>
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    sck->state         = LISTEN;   
    sck++;
    7a58:	04 5e       	subi	r16, 0xE4	; 228
    7a5a:	1f 4f       	sbci	r17, 0xFF	; 255
    7a5c:	e3 cf       	rjmp	.-58     	; 0x7a24 <socketInit+0x54>
  }
}
    7a5e:	df 91       	pop	r29
    7a60:	cf 91       	pop	r28
    7a62:	1f 91       	pop	r17
    7a64:	0f 91       	pop	r16
    7a66:	ff 90       	pop	r15
    7a68:	ef 90       	pop	r14
    7a6a:	df 90       	pop	r13
    7a6c:	cf 90       	pop	r12
    7a6e:	bf 90       	pop	r11
    7a70:	08 95       	ret

00007a72 <setUdpDebug>:
}

#if UDP_DEBUG
void setUdpDebug(FILE *stream, uint8_t level)
{
  udpDbgStream = stream;
    7a72:	90 93 c1 0e 	sts	0x0EC1, r25
    7a76:	80 93 c0 0e 	sts	0x0EC0, r24
  udpDbgLevel = level;
    7a7a:	60 93 7d 0e 	sts	0x0E7D, r22
}
    7a7e:	08 95       	ret

00007a80 <udpPrintStatus>:
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
}

void udpPrintStatus(FILE *stream)
{
    7a80:	cf 93       	push	r28
    7a82:	df 93       	push	r29
    7a84:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR("UDP config:"));
    7a86:	00 d0       	rcall	.+0      	; 0x7a88 <udpPrintStatus+0x8>
    7a88:	00 d0       	rcall	.+0      	; 0x7a8a <udpPrintStatus+0xa>
    7a8a:	ad b7       	in	r26, 0x3d	; 61
    7a8c:	be b7       	in	r27, 0x3e	; 62
    7a8e:	12 96       	adiw	r26, 0x02	; 2
    7a90:	9c 93       	st	X, r25
    7a92:	8e 93       	st	-X, r24
    7a94:	11 97       	sbiw	r26, 0x01	; 1
    7a96:	83 e6       	ldi	r24, 0x63	; 99
    7a98:	92 e1       	ldi	r25, 0x12	; 18
    7a9a:	14 96       	adiw	r26, 0x04	; 4
    7a9c:	9c 93       	st	X, r25
    7a9e:	8e 93       	st	-X, r24
    7aa0:	13 97       	sbiw	r26, 0x03	; 3
    7aa2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n  IP          : ")); netPrintIPAddr(stream, udpSocket->dstIp);
    7aa6:	ed b7       	in	r30, 0x3d	; 61
    7aa8:	fe b7       	in	r31, 0x3e	; 62
    7aaa:	d2 83       	std	Z+2, r29	; 0x02
    7aac:	c1 83       	std	Z+1, r28	; 0x01
    7aae:	80 e5       	ldi	r24, 0x50	; 80
    7ab0:	92 e1       	ldi	r25, 0x12	; 18
    7ab2:	94 83       	std	Z+4, r25	; 0x04
    7ab4:	83 83       	std	Z+3, r24	; 0x03
    7ab6:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7aba:	0f 90       	pop	r0
    7abc:	0f 90       	pop	r0
    7abe:	0f 90       	pop	r0
    7ac0:	0f 90       	pop	r0
    7ac2:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7ac6:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7aca:	46 81       	ldd	r20, Z+6	; 0x06
    7acc:	57 81       	ldd	r21, Z+7	; 0x07
    7ace:	60 85       	ldd	r22, Z+8	; 0x08
    7ad0:	71 85       	ldd	r23, Z+9	; 0x09
    7ad2:	ce 01       	movw	r24, r28
    7ad4:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n  src port    : %d\r\n  dst port    : "), htons(udpSocket->srcPort));
    7ad8:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7adc:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7ae0:	84 81       	ldd	r24, Z+4	; 0x04
    7ae2:	95 81       	ldd	r25, Z+5	; 0x05
    7ae4:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    7ae8:	00 d0       	rcall	.+0      	; 0x7aea <udpPrintStatus+0x6a>
    7aea:	00 d0       	rcall	.+0      	; 0x7aec <udpPrintStatus+0x6c>
    7aec:	00 d0       	rcall	.+0      	; 0x7aee <udpPrintStatus+0x6e>
    7aee:	ed b7       	in	r30, 0x3d	; 61
    7af0:	fe b7       	in	r31, 0x3e	; 62
    7af2:	31 96       	adiw	r30, 0x01	; 1
    7af4:	ad b7       	in	r26, 0x3d	; 61
    7af6:	be b7       	in	r27, 0x3e	; 62
    7af8:	12 96       	adiw	r26, 0x02	; 2
    7afa:	dc 93       	st	X, r29
    7afc:	ce 93       	st	-X, r28
    7afe:	11 97       	sbiw	r26, 0x01	; 1
    7b00:	29 e2       	ldi	r18, 0x29	; 41
    7b02:	32 e1       	ldi	r19, 0x12	; 18
    7b04:	33 83       	std	Z+3, r19	; 0x03
    7b06:	22 83       	std	Z+2, r18	; 0x02
    7b08:	95 83       	std	Z+5, r25	; 0x05
    7b0a:	84 83       	std	Z+4, r24	; 0x04
    7b0c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
  if (udpSocket->dstPortDef == HTONS(0))
    7b10:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7b14:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7b18:	80 81       	ld	r24, Z
    7b1a:	91 81       	ldd	r25, Z+1	; 0x01
    7b1c:	ed b7       	in	r30, 0x3d	; 61
    7b1e:	fe b7       	in	r31, 0x3e	; 62
    7b20:	36 96       	adiw	r30, 0x06	; 6
    7b22:	0f b6       	in	r0, 0x3f	; 63
    7b24:	f8 94       	cli
    7b26:	fe bf       	out	0x3e, r31	; 62
    7b28:	0f be       	out	0x3f, r0	; 63
    7b2a:	ed bf       	out	0x3d, r30	; 61
    7b2c:	00 97       	sbiw	r24, 0x00	; 0
    7b2e:	a9 f4       	brne	.+42     	; 0x7b5a <udpPrintStatus+0xda>
    fprintf_P(stream, PSTR("ANY\r\n"));
    7b30:	00 d0       	rcall	.+0      	; 0x7b32 <udpPrintStatus+0xb2>
    7b32:	00 d0       	rcall	.+0      	; 0x7b34 <udpPrintStatus+0xb4>
    7b34:	ad b7       	in	r26, 0x3d	; 61
    7b36:	be b7       	in	r27, 0x3e	; 62
    7b38:	12 96       	adiw	r26, 0x02	; 2
    7b3a:	dc 93       	st	X, r29
    7b3c:	ce 93       	st	-X, r28
    7b3e:	11 97       	sbiw	r26, 0x01	; 1
    7b40:	83 e2       	ldi	r24, 0x23	; 35
    7b42:	92 e1       	ldi	r25, 0x12	; 18
    7b44:	14 96       	adiw	r26, 0x04	; 4
    7b46:	9c 93       	st	X, r25
    7b48:	8e 93       	st	-X, r24
    7b4a:	13 97       	sbiw	r26, 0x03	; 3
    7b4c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7b50:	0f 90       	pop	r0
    7b52:	0f 90       	pop	r0
    7b54:	0f 90       	pop	r0
    7b56:	0f 90       	pop	r0
    7b58:	1e c0       	rjmp	.+60     	; 0x7b96 <udpPrintStatus+0x116>
  else
    fprintf_P(stream, PSTR("%d\r\n"), htons(udpSocket->dstPortDef));    
    7b5a:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    7b5e:	00 d0       	rcall	.+0      	; 0x7b60 <udpPrintStatus+0xe0>
    7b60:	00 d0       	rcall	.+0      	; 0x7b62 <udpPrintStatus+0xe2>
    7b62:	00 d0       	rcall	.+0      	; 0x7b64 <udpPrintStatus+0xe4>
    7b64:	ed b7       	in	r30, 0x3d	; 61
    7b66:	fe b7       	in	r31, 0x3e	; 62
    7b68:	31 96       	adiw	r30, 0x01	; 1
    7b6a:	ad b7       	in	r26, 0x3d	; 61
    7b6c:	be b7       	in	r27, 0x3e	; 62
    7b6e:	12 96       	adiw	r26, 0x02	; 2
    7b70:	dc 93       	st	X, r29
    7b72:	ce 93       	st	-X, r28
    7b74:	11 97       	sbiw	r26, 0x01	; 1
    7b76:	2e e1       	ldi	r18, 0x1E	; 30
    7b78:	32 e1       	ldi	r19, 0x12	; 18
    7b7a:	33 83       	std	Z+3, r19	; 0x03
    7b7c:	22 83       	std	Z+2, r18	; 0x02
    7b7e:	95 83       	std	Z+5, r25	; 0x05
    7b80:	84 83       	std	Z+4, r24	; 0x04
    7b82:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7b86:	ed b7       	in	r30, 0x3d	; 61
    7b88:	fe b7       	in	r31, 0x3e	; 62
    7b8a:	36 96       	adiw	r30, 0x06	; 6
    7b8c:	0f b6       	in	r0, 0x3f	; 63
    7b8e:	f8 94       	cli
    7b90:	fe bf       	out	0x3e, r31	; 62
    7b92:	0f be       	out	0x3f, r0	; 63
    7b94:	ed bf       	out	0x3d, r30	; 61
}
    7b96:	df 91       	pop	r29
    7b98:	cf 91       	pop	r28
    7b9a:	08 95       	ret

00007b9c <udpSaveConfig>:
  }
}

void udpSaveConfig(void)
{
  eeprom_update_dword(&udpIpDst_eep, udpSocket->dstIp);
    7b9c:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7ba0:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7ba4:	46 81       	ldd	r20, Z+6	; 0x06
    7ba6:	57 81       	ldd	r21, Z+7	; 0x07
    7ba8:	60 85       	ldd	r22, Z+8	; 0x08
    7baa:	71 85       	ldd	r23, Z+9	; 0x09
    7bac:	8a e2       	ldi	r24, 0x2A	; 42
    7bae:	90 e0       	ldi	r25, 0x00	; 0
    7bb0:	0e 94 eb 5c 	call	0xb9d6	; 0xb9d6 <__eeupd_dword_m128>
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
    7bb4:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7bb8:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7bbc:	60 81       	ld	r22, Z
    7bbe:	71 81       	ldd	r23, Z+1	; 0x01
    7bc0:	8e e2       	ldi	r24, 0x2E	; 46
    7bc2:	90 e0       	ldi	r25, 0x00	; 0
    7bc4:	0e 94 f7 5c 	call	0xb9ee	; 0xb9ee <__eeupd_word_m128>
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
    7bc8:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7bcc:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7bd0:	64 81       	ldd	r22, Z+4	; 0x04
    7bd2:	75 81       	ldd	r23, Z+5	; 0x05
    7bd4:	80 e3       	ldi	r24, 0x30	; 48
    7bd6:	90 e0       	ldi	r25, 0x00	; 0
    7bd8:	0e 94 f7 5c 	call	0xb9ee	; 0xb9ee <__eeupd_word_m128>
}
    7bdc:	08 95       	ret

00007bde <netstackUDPIPProcess>:
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
}

inline void netstackUDPIPProcess(void)
{
    7bde:	af 92       	push	r10
    7be0:	bf 92       	push	r11
    7be2:	cf 92       	push	r12
    7be4:	df 92       	push	r13
    7be6:	ff 92       	push	r15
    7be8:	0f 93       	push	r16
    7bea:	1f 93       	push	r17
    7bec:	cf 93       	push	r28
    7bee:	df 93       	push	r29
  uint16_t len = (uint16_t) htons(nicState.layer4.udp->udplen);
    7bf0:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7bf4:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7bf8:	84 81       	ldd	r24, Z+4	; 0x04
    7bfa:	95 81       	ldd	r25, Z+5	; 0x05
    7bfc:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    7c00:	8c 01       	movw	r16, r24
  uint8_t i;

  #if UDP_DEBUG
  if(udpDbgStream != NULL)
    7c02:	20 91 c0 0e 	lds	r18, 0x0EC0
    7c06:	30 91 c1 0e 	lds	r19, 0x0EC1
    7c0a:	21 15       	cp	r18, r1
    7c0c:	31 05       	cpc	r19, r1
    7c0e:	21 f1       	breq	.+72     	; 0x7c58 <netstackUDPIPProcess+0x7a>
    if (udpDbgLevel > 3)
    7c10:	80 91 7d 0e 	lds	r24, 0x0E7D
    7c14:	84 30       	cpi	r24, 0x04	; 4
    7c16:	00 f1       	brcs	.+64     	; 0x7c58 <netstackUDPIPProcess+0x7a>
      fprintf_P(udpDbgStream, PSTR("Proc. UDP packet (data length %d)\r\n"), len-UDP_HEADER_LEN);
    7c18:	00 d0       	rcall	.+0      	; 0x7c1a <netstackUDPIPProcess+0x3c>
    7c1a:	00 d0       	rcall	.+0      	; 0x7c1c <netstackUDPIPProcess+0x3e>
    7c1c:	00 d0       	rcall	.+0      	; 0x7c1e <netstackUDPIPProcess+0x40>
    7c1e:	ed b7       	in	r30, 0x3d	; 61
    7c20:	fe b7       	in	r31, 0x3e	; 62
    7c22:	31 96       	adiw	r30, 0x01	; 1
    7c24:	ad b7       	in	r26, 0x3d	; 61
    7c26:	be b7       	in	r27, 0x3e	; 62
    7c28:	12 96       	adiw	r26, 0x02	; 2
    7c2a:	3c 93       	st	X, r19
    7c2c:	2e 93       	st	-X, r18
    7c2e:	11 97       	sbiw	r26, 0x01	; 1
    7c30:	8f e9       	ldi	r24, 0x9F	; 159
    7c32:	92 e1       	ldi	r25, 0x12	; 18
    7c34:	93 83       	std	Z+3, r25	; 0x03
    7c36:	82 83       	std	Z+2, r24	; 0x02
    7c38:	08 50       	subi	r16, 0x08	; 8
    7c3a:	10 40       	sbci	r17, 0x00	; 0
    7c3c:	15 83       	std	Z+5, r17	; 0x05
    7c3e:	04 83       	std	Z+4, r16	; 0x04
    7c40:	08 5f       	subi	r16, 0xF8	; 248
    7c42:	1f 4f       	sbci	r17, 0xFF	; 255
    7c44:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7c48:	ed b7       	in	r30, 0x3d	; 61
    7c4a:	fe b7       	in	r31, 0x3e	; 62
    7c4c:	36 96       	adiw	r30, 0x06	; 6
    7c4e:	0f b6       	in	r0, 0x3f	; 63
    7c50:	f8 94       	cli
    7c52:	fe bf       	out	0x3e, r31	; 62
    7c54:	0f be       	out	0x3f, r0	; 63
    7c56:	ed bf       	out	0x3d, r30	; 61
#endif

  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    7c58:	c0 91 8a 0e 	lds	r28, 0x0E8A
    7c5c:	d0 91 8b 0e 	lds	r29, 0x0E8B
    7c60:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7c64:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7c68:	2a 81       	ldd	r18, Y+2	; 0x02
    7c6a:	3b 81       	ldd	r19, Y+3	; 0x03
    7c6c:	84 81       	ldd	r24, Z+4	; 0x04
    7c6e:	95 81       	ldd	r25, Z+5	; 0x05
    7c70:	28 17       	cp	r18, r24
    7c72:	39 07       	cpc	r19, r25
    7c74:	09 f0       	breq	.+2      	; 0x7c78 <netstackUDPIPProcess+0x9a>
    7c76:	aa c0       	rjmp	.+340    	; 0x7dcc <netstackUDPIPProcess+0x1ee>
    7c78:	80 81       	ld	r24, Z
    7c7a:	91 81       	ldd	r25, Z+1	; 0x01
    7c7c:	28 81       	ld	r18, Y
    7c7e:	39 81       	ldd	r19, Y+1	; 0x01
    7c80:	89 2b       	or	r24, r25
    7c82:	39 f0       	breq	.+14     	; 0x7c92 <netstackUDPIPProcess+0xb4>
    7c84:	82 81       	ldd	r24, Z+2	; 0x02
    7c86:	93 81       	ldd	r25, Z+3	; 0x03
    7c88:	82 17       	cp	r24, r18
    7c8a:	93 07       	cpc	r25, r19
    7c8c:	09 f0       	breq	.+2      	; 0x7c90 <netstackUDPIPProcess+0xb2>
    7c8e:	9e c0       	rjmp	.+316    	; 0x7dcc <netstackUDPIPProcess+0x1ee>
    7c90:	02 c0       	rjmp	.+4      	; 0x7c96 <netstackUDPIPProcess+0xb8>
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    7c92:	33 83       	std	Z+3, r19	; 0x03
    7c94:	22 83       	std	Z+2, r18	; 0x02
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7c96:	20 91 c0 0e 	lds	r18, 0x0EC0
    7c9a:	30 91 c1 0e 	lds	r19, 0x0EC1
    7c9e:	21 15       	cp	r18, r1
    7ca0:	31 05       	cpc	r19, r1
    7ca2:	c1 f0       	breq	.+48     	; 0x7cd4 <netstackUDPIPProcess+0xf6>
        if (udpDbgLevel > 4)
    7ca4:	80 91 7d 0e 	lds	r24, 0x0E7D
    7ca8:	85 30       	cpi	r24, 0x05	; 5
    7caa:	a0 f0       	brcs	.+40     	; 0x7cd4 <netstackUDPIPProcess+0xf6>
          fprintf_P(udpDbgStream, PSTR("Received data: "));
    7cac:	00 d0       	rcall	.+0      	; 0x7cae <netstackUDPIPProcess+0xd0>
    7cae:	00 d0       	rcall	.+0      	; 0x7cb0 <netstackUDPIPProcess+0xd2>
    7cb0:	ad b7       	in	r26, 0x3d	; 61
    7cb2:	be b7       	in	r27, 0x3e	; 62
    7cb4:	12 96       	adiw	r26, 0x02	; 2
    7cb6:	3c 93       	st	X, r19
    7cb8:	2e 93       	st	-X, r18
    7cba:	11 97       	sbiw	r26, 0x01	; 1
    7cbc:	8f e8       	ldi	r24, 0x8F	; 143
    7cbe:	92 e1       	ldi	r25, 0x12	; 18
    7cc0:	14 96       	adiw	r26, 0x04	; 4
    7cc2:	9c 93       	st	X, r25
    7cc4:	8e 93       	st	-X, r24
    7cc6:	13 97       	sbiw	r26, 0x03	; 3
    7cc8:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7ccc:	0f 90       	pop	r0
    7cce:	0f 90       	pop	r0
    7cd0:	0f 90       	pop	r0
    7cd2:	0f 90       	pop	r0
  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7cd4:	28 96       	adiw	r28, 0x08	; 8
    7cd6:	28 e0       	ldi	r18, 0x08	; 8
    7cd8:	f2 2e       	mov	r15, r18
    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7cda:	97 e8       	ldi	r25, 0x87	; 135
    7cdc:	a9 2e       	mov	r10, r25
    7cde:	92 e1       	ldi	r25, 0x12	; 18
    7ce0:	b9 2e       	mov	r11, r25
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
        if(udpDbgStream != NULL)
          if (udpDbgLevel > 0)
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7ce2:	82 e7       	ldi	r24, 0x72	; 114
    7ce4:	c8 2e       	mov	r12, r24
    7ce6:	82 e1       	ldi	r24, 0x12	; 18
    7ce8:	d8 2e       	mov	r13, r24
    7cea:	4f c0       	rjmp	.+158    	; 0x7d8a <netstackUDPIPProcess+0x1ac>
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7cec:	21 15       	cp	r18, r1
    7cee:	31 05       	cpc	r19, r1
    7cf0:	f9 f0       	breq	.+62     	; 0x7d30 <netstackUDPIPProcess+0x152>
        if (udpDbgLevel > 4)
    7cf2:	80 91 7d 0e 	lds	r24, 0x0E7D
    7cf6:	85 30       	cpi	r24, 0x05	; 5
    7cf8:	d8 f0       	brcs	.+54     	; 0x7d30 <netstackUDPIPProcess+0x152>
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7cfa:	00 d0       	rcall	.+0      	; 0x7cfc <netstackUDPIPProcess+0x11e>
    7cfc:	00 d0       	rcall	.+0      	; 0x7cfe <netstackUDPIPProcess+0x120>
    7cfe:	00 d0       	rcall	.+0      	; 0x7d00 <netstackUDPIPProcess+0x122>
    7d00:	ed b7       	in	r30, 0x3d	; 61
    7d02:	fe b7       	in	r31, 0x3e	; 62
    7d04:	31 96       	adiw	r30, 0x01	; 1
    7d06:	ad b7       	in	r26, 0x3d	; 61
    7d08:	be b7       	in	r27, 0x3e	; 62
    7d0a:	12 96       	adiw	r26, 0x02	; 2
    7d0c:	3c 93       	st	X, r19
    7d0e:	2e 93       	st	-X, r18
    7d10:	11 97       	sbiw	r26, 0x01	; 1
    7d12:	b3 82       	std	Z+3, r11	; 0x03
    7d14:	a2 82       	std	Z+2, r10	; 0x02
    7d16:	88 81       	ld	r24, Y
    7d18:	84 83       	std	Z+4, r24	; 0x04
    7d1a:	15 82       	std	Z+5, r1	; 0x05
    7d1c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7d20:	ed b7       	in	r30, 0x3d	; 61
    7d22:	fe b7       	in	r31, 0x3e	; 62
    7d24:	36 96       	adiw	r30, 0x06	; 6
    7d26:	0f b6       	in	r0, 0x3f	; 63
    7d28:	f8 94       	cli
    7d2a:	fe bf       	out	0x3e, r31	; 62
    7d2c:	0f be       	out	0x3f, r0	; 63
    7d2e:	ed bf       	out	0x3d, r30	; 61
#endif
#if UDB_DEBUG
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
    7d30:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7d34:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7d38:	82 85       	ldd	r24, Z+10	; 0x0a
    7d3a:	93 85       	ldd	r25, Z+11	; 0x0b
    7d3c:	be 01       	movw	r22, r28
    7d3e:	4a e0       	ldi	r20, 0x0A	; 10
    7d40:	50 e0       	ldi	r21, 0x00	; 0
    7d42:	20 e0       	ldi	r18, 0x00	; 0
    7d44:	0e 94 8f 51 	call	0xa31e	; 0xa31e <xQueueGenericSend>
    7d48:	88 23       	and	r24, r24
    7d4a:	e9 f4       	brne	.+58     	; 0x7d86 <netstackUDPIPProcess+0x1a8>
        if(udpDbgStream != NULL)
    7d4c:	20 91 c0 0e 	lds	r18, 0x0EC0
    7d50:	30 91 c1 0e 	lds	r19, 0x0EC1
    7d54:	21 15       	cp	r18, r1
    7d56:	31 05       	cpc	r19, r1
    7d58:	b1 f0       	breq	.+44     	; 0x7d86 <netstackUDPIPProcess+0x1a8>
          if (udpDbgLevel > 0)
    7d5a:	80 91 7d 0e 	lds	r24, 0x0E7D
    7d5e:	88 23       	and	r24, r24
    7d60:	91 f0       	breq	.+36     	; 0x7d86 <netstackUDPIPProcess+0x1a8>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7d62:	00 d0       	rcall	.+0      	; 0x7d64 <netstackUDPIPProcess+0x186>
    7d64:	00 d0       	rcall	.+0      	; 0x7d66 <netstackUDPIPProcess+0x188>
    7d66:	ad b7       	in	r26, 0x3d	; 61
    7d68:	be b7       	in	r27, 0x3e	; 62
    7d6a:	12 96       	adiw	r26, 0x02	; 2
    7d6c:	3c 93       	st	X, r19
    7d6e:	2e 93       	st	-X, r18
    7d70:	11 97       	sbiw	r26, 0x01	; 1
    7d72:	14 96       	adiw	r26, 0x04	; 4
    7d74:	dc 92       	st	X, r13
    7d76:	ce 92       	st	-X, r12
    7d78:	13 97       	sbiw	r26, 0x03	; 3
    7d7a:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7d7e:	0f 90       	pop	r0
    7d80:	0f 90       	pop	r0
    7d82:	0f 90       	pop	r0
    7d84:	0f 90       	pop	r0
#endif
      tmp++;
    7d86:	21 96       	adiw	r28, 0x01	; 1
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received data: "));
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    7d88:	f3 94       	inc	r15
    7d8a:	8f 2d       	mov	r24, r15
    7d8c:	90 e0       	ldi	r25, 0x00	; 0
    7d8e:	20 91 c0 0e 	lds	r18, 0x0EC0
    7d92:	30 91 c1 0e 	lds	r19, 0x0EC1
    7d96:	80 17       	cp	r24, r16
    7d98:	91 07       	cpc	r25, r17
    7d9a:	08 f4       	brcc	.+2      	; 0x7d9e <netstackUDPIPProcess+0x1c0>
    7d9c:	a7 cf       	rjmp	.-178    	; 0x7cec <netstackUDPIPProcess+0x10e>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
#endif
      tmp++;
    }
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    7d9e:	21 15       	cp	r18, r1
    7da0:	31 05       	cpc	r19, r1
    7da2:	a1 f0       	breq	.+40     	; 0x7dcc <netstackUDPIPProcess+0x1ee>
      if (udpDbgLevel > 4)
    7da4:	80 91 7d 0e 	lds	r24, 0x0E7D
    7da8:	85 30       	cpi	r24, 0x05	; 5
    7daa:	80 f0       	brcs	.+32     	; 0x7dcc <netstackUDPIPProcess+0x1ee>
        fprintf_P(udpDbgStream, PSTR("\r\n"));
    7dac:	00 d0       	rcall	.+0      	; 0x7dae <netstackUDPIPProcess+0x1d0>
    7dae:	00 d0       	rcall	.+0      	; 0x7db0 <netstackUDPIPProcess+0x1d2>
    7db0:	ed b7       	in	r30, 0x3d	; 61
    7db2:	fe b7       	in	r31, 0x3e	; 62
    7db4:	32 83       	std	Z+2, r19	; 0x02
    7db6:	21 83       	std	Z+1, r18	; 0x01
    7db8:	8f e6       	ldi	r24, 0x6F	; 111
    7dba:	92 e1       	ldi	r25, 0x12	; 18
    7dbc:	94 83       	std	Z+4, r25	; 0x04
    7dbe:	83 83       	std	Z+3, r24	; 0x03
    7dc0:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7dc4:	0f 90       	pop	r0
    7dc6:	0f 90       	pop	r0
    7dc8:	0f 90       	pop	r0
    7dca:	0f 90       	pop	r0
#endif

  }
}
    7dcc:	df 91       	pop	r29
    7dce:	cf 91       	pop	r28
    7dd0:	1f 91       	pop	r17
    7dd2:	0f 91       	pop	r16
    7dd4:	ff 90       	pop	r15
    7dd6:	df 90       	pop	r13
    7dd8:	cf 90       	pop	r12
    7dda:	bf 90       	pop	r11
    7ddc:	af 90       	pop	r10
    7dde:	08 95       	ret

00007de0 <udpSend>:
  udpDbgLevel = level;
}
#endif

inline void udpSend(uint16_t len)
{
    7de0:	ef 92       	push	r14
    7de2:	ff 92       	push	r15
    7de4:	0f 93       	push	r16
    7de6:	1f 93       	push	r17
    7de8:	cf 93       	push	r28
    7dea:	df 93       	push	r29
    7dec:	7c 01       	movw	r14, r24
// make pointer to UDP header
  nicState.layer4.udp->srcport  = udpSocket->srcPort;
    7dee:	c0 91 8a 0e 	lds	r28, 0x0E8A
    7df2:	d0 91 8b 0e 	lds	r29, 0x0E8B
    7df6:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7dfa:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7dfe:	84 81       	ldd	r24, Z+4	; 0x04
    7e00:	95 81       	ldd	r25, Z+5	; 0x05
    7e02:	99 83       	std	Y+1, r25	; 0x01
    7e04:	88 83       	st	Y, r24
  nicState.layer4.udp->destport = (udpSocket->dstPortDef == 0)? udpSocket->dstPort : udpSocket->dstPortDef;          //data in udpSocket are stored in network order
    7e06:	80 81       	ld	r24, Z
    7e08:	91 81       	ldd	r25, Z+1	; 0x01
    7e0a:	00 97       	sbiw	r24, 0x00	; 0
    7e0c:	11 f4       	brne	.+4      	; 0x7e12 <udpSend+0x32>
    7e0e:	82 81       	ldd	r24, Z+2	; 0x02
    7e10:	93 81       	ldd	r25, Z+3	; 0x03
    7e12:	9b 83       	std	Y+3, r25	; 0x03
    7e14:	8a 83       	std	Y+2, r24	; 0x02
  
  nicState.layer4.udp->udplen = htons(len + UDP_HEADER_LEN);
    7e16:	87 01       	movw	r16, r14
    7e18:	08 5f       	subi	r16, 0xF8	; 248
    7e1a:	1f 4f       	sbci	r17, 0xFF	; 255
    7e1c:	c8 01       	movw	r24, r16
    7e1e:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <htons>
    7e22:	9d 83       	std	Y+5, r25	; 0x05
    7e24:	8c 83       	std	Y+4, r24	; 0x04
  nicState.layer4.udp->udpchksum = 0;
    7e26:	e0 91 8a 0e 	lds	r30, 0x0E8A
    7e2a:	f0 91 8b 0e 	lds	r31, 0x0E8B
    7e2e:	17 82       	std	Z+7, r1	; 0x07
    7e30:	16 82       	std	Z+6, r1	; 0x06

#if UDP_DEBUG
  if (udpDbgStream != NULL)
    7e32:	20 91 c0 0e 	lds	r18, 0x0EC0
    7e36:	30 91 c1 0e 	lds	r19, 0x0EC1
    7e3a:	21 15       	cp	r18, r1
    7e3c:	31 05       	cpc	r19, r1
    7e3e:	01 f1       	breq	.+64     	; 0x7e80 <udpSend+0xa0>
    if (udpDbgLevel > 1)
    7e40:	80 91 7d 0e 	lds	r24, 0x0E7D
    7e44:	82 30       	cpi	r24, 0x02	; 2
    7e46:	e0 f0       	brcs	.+56     	; 0x7e80 <udpSend+0xa0>
      fprintf_P(udpDbgStream, PSTR("Sending UDP packet (data length %d)\r\n"), len);
    7e48:	00 d0       	rcall	.+0      	; 0x7e4a <udpSend+0x6a>
    7e4a:	00 d0       	rcall	.+0      	; 0x7e4c <udpSend+0x6c>
    7e4c:	00 d0       	rcall	.+0      	; 0x7e4e <udpSend+0x6e>
    7e4e:	ed b7       	in	r30, 0x3d	; 61
    7e50:	fe b7       	in	r31, 0x3e	; 62
    7e52:	31 96       	adiw	r30, 0x01	; 1
    7e54:	ad b7       	in	r26, 0x3d	; 61
    7e56:	be b7       	in	r27, 0x3e	; 62
    7e58:	12 96       	adiw	r26, 0x02	; 2
    7e5a:	3c 93       	st	X, r19
    7e5c:	2e 93       	st	-X, r18
    7e5e:	11 97       	sbiw	r26, 0x01	; 1
    7e60:	83 ec       	ldi	r24, 0xC3	; 195
    7e62:	92 e1       	ldi	r25, 0x12	; 18
    7e64:	93 83       	std	Z+3, r25	; 0x03
    7e66:	82 83       	std	Z+2, r24	; 0x02
    7e68:	f5 82       	std	Z+5, r15	; 0x05
    7e6a:	e4 82       	std	Z+4, r14	; 0x04
    7e6c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    7e70:	8d b7       	in	r24, 0x3d	; 61
    7e72:	9e b7       	in	r25, 0x3e	; 62
    7e74:	06 96       	adiw	r24, 0x06	; 6
    7e76:	0f b6       	in	r0, 0x3f	; 63
    7e78:	f8 94       	cli
    7e7a:	9e bf       	out	0x3e, r25	; 62
    7e7c:	0f be       	out	0x3f, r0	; 63
    7e7e:	8d bf       	out	0x3d, r24	; 61
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
    7e80:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7e84:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7e88:	66 81       	ldd	r22, Z+6	; 0x06
    7e8a:	77 81       	ldd	r23, Z+7	; 0x07
    7e8c:	80 85       	ldd	r24, Z+8	; 0x08
    7e8e:	91 85       	ldd	r25, Z+9	; 0x09
    7e90:	41 e1       	ldi	r20, 0x11	; 17
    7e92:	98 01       	movw	r18, r16
    7e94:	0e 94 8b 32 	call	0x6516	; 0x6516 <ipSend>
}
    7e98:	df 91       	pop	r29
    7e9a:	cf 91       	pop	r28
    7e9c:	1f 91       	pop	r17
    7e9e:	0f 91       	pop	r16
    7ea0:	ff 90       	pop	r15
    7ea2:	ef 90       	pop	r14
    7ea4:	08 95       	ret

00007ea6 <flushUdpQueues>:

  }
}

inline void flushUdpQueues(void)
{
    7ea6:	0f 93       	push	r16
    7ea8:	1f 93       	push	r17
    7eaa:	cf 93       	push	r28
    7eac:	df 93       	push	r29
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
    7eae:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7eb2:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7eb6:	84 85       	ldd	r24, Z+12	; 0x0c
    7eb8:	95 85       	ldd	r25, Z+13	; 0x0d
    7eba:	0e 94 b1 4f 	call	0x9f62	; 0x9f62 <uxQueueMessagesWaiting>
    7ebe:	88 23       	and	r24, r24
    7ec0:	e1 f0       	breq	.+56     	; 0x7efa <flushUdpQueues+0x54>
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7ec2:	c0 91 8a 0e 	lds	r28, 0x0E8A
    7ec6:	d0 91 8b 0e 	lds	r29, 0x0E8B
    7eca:	28 96       	adiw	r28, 0x08	; 8
    7ecc:	00 e0       	ldi	r16, 0x00	; 0
    7ece:	10 e0       	ldi	r17, 0x00	; 0
    7ed0:	03 c0       	rjmp	.+6      	; 0x7ed8 <flushUdpQueues+0x32>
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    {
      data++;
    7ed2:	21 96       	adiw	r28, 0x01	; 1
      len++;
    7ed4:	0f 5f       	subi	r16, 0xFF	; 255
    7ed6:	1f 4f       	sbci	r17, 0xFF	; 255
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7ed8:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7edc:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7ee0:	84 85       	ldd	r24, Z+12	; 0x0c
    7ee2:	95 85       	ldd	r25, Z+13	; 0x0d
    7ee4:	be 01       	movw	r22, r28
    7ee6:	40 e0       	ldi	r20, 0x00	; 0
    7ee8:	50 e0       	ldi	r21, 0x00	; 0
    7eea:	20 e0       	ldi	r18, 0x00	; 0
    7eec:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    7ef0:	81 30       	cpi	r24, 0x01	; 1
    7ef2:	79 f3       	breq	.-34     	; 0x7ed2 <flushUdpQueues+0x2c>
    {
      data++;
      len++;
    }
    udpSend(len);
    7ef4:	c8 01       	movw	r24, r16
    7ef6:	0e 94 f0 3e 	call	0x7de0	; 0x7de0 <udpSend>
  }
}
    7efa:	df 91       	pop	r29
    7efc:	cf 91       	pop	r28
    7efe:	1f 91       	pop	r17
    7f00:	0f 91       	pop	r16
    7f02:	08 95       	ret

00007f04 <udpInit>:
static uint32_t udpIpDst_eep   __attribute__((section (".eeprom"))) = ((uint32_t)UDP_DST_IP4   << 24) + ((uint32_t)UDP_DST_IP3   <<16) + ((uint32_t)UDP_DST_IP2   <<8) + UDP_DST_IP1;
static uint16_t udpPortDstEep  __attribute__((section (".eeprom"))) = HTONS(UDP_DST_PORT);
static uint16_t udpPortSrcEep  __attribute__((section (".eeprom"))) = HTONS(UDP_SRC_PORT);

void udpInit(void)
{
    7f04:	0f 93       	push	r16
    7f06:	1f 93       	push	r17
#if UDP_DEBUG
  udpDbgStream         = NULL;
    7f08:	10 92 c1 0e 	sts	0x0EC1, r1
    7f0c:	10 92 c0 0e 	sts	0x0EC0, r1
  udpDbgLevel          = 0;
    7f10:	10 92 7d 0e 	sts	0x0E7D, r1
#endif
  udpSocket = xmalloc(sizeof(UdpSocket_t));
    7f14:	8e e0       	ldi	r24, 0x0E	; 14
    7f16:	90 e0       	ldi	r25, 0x00	; 0
    7f18:	0e 94 2e 1c 	call	0x385c	; 0x385c <xmalloc>
    7f1c:	8c 01       	movw	r16, r24
    7f1e:	90 93 a3 0e 	sts	0x0EA3, r25
    7f22:	80 93 a2 0e 	sts	0x0EA2, r24

  udpSocket->dstIp      = eeprom_read_dword(&udpIpDst_eep);
    7f26:	8a e2       	ldi	r24, 0x2A	; 42
    7f28:	90 e0       	ldi	r25, 0x00	; 0
    7f2a:	0e 94 be 5c 	call	0xb97c	; 0xb97c <__eerd_dword_m128>
    7f2e:	f8 01       	movw	r30, r16
    7f30:	66 83       	std	Z+6, r22	; 0x06
    7f32:	77 83       	std	Z+7, r23	; 0x07
    7f34:	80 87       	std	Z+8, r24	; 0x08
    7f36:	91 87       	std	Z+9, r25	; 0x09
  udpSocket->dstPortDef = eeprom_read_word(&udpPortDstEep);;
    7f38:	8e e2       	ldi	r24, 0x2E	; 46
    7f3a:	90 e0       	ldi	r25, 0x00	; 0
    7f3c:	0e 94 c4 5c 	call	0xb988	; 0xb988 <__eerd_word_m128>
    7f40:	f8 01       	movw	r30, r16
    7f42:	91 83       	std	Z+1, r25	; 0x01
    7f44:	80 83       	st	Z, r24
  udpSocket->srcPort    = eeprom_read_word(&udpPortSrcEep);
    7f46:	80 e3       	ldi	r24, 0x30	; 48
    7f48:	90 e0       	ldi	r25, 0x00	; 0
    7f4a:	0e 94 c4 5c 	call	0xb988	; 0xb988 <__eerd_word_m128>
    7f4e:	f8 01       	movw	r30, r16
    7f50:	95 83       	std	Z+5, r25	; 0x05
    7f52:	84 83       	std	Z+4, r24	; 0x04
  
  udpSocket->Rx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_RX_BUF_ADDR));
    7f54:	8f ef       	ldi	r24, 0xFF	; 255
    7f56:	61 e0       	ldi	r22, 0x01	; 1
    7f58:	40 e0       	ldi	r20, 0x00	; 0
    7f5a:	59 e7       	ldi	r21, 0x79	; 121
    7f5c:	0e 94 33 52 	call	0xa466	; 0xa466 <xQueueCreateExternal>
    7f60:	f8 01       	movw	r30, r16
    7f62:	93 87       	std	Z+11, r25	; 0x0b
    7f64:	82 87       	std	Z+10, r24	; 0x0a
  udpSocket->Tx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_TX_BUF_ADDR));
    7f66:	00 91 a2 0e 	lds	r16, 0x0EA2
    7f6a:	10 91 a3 0e 	lds	r17, 0x0EA3
    7f6e:	8f ef       	ldi	r24, 0xFF	; 255
    7f70:	61 e0       	ldi	r22, 0x01	; 1
    7f72:	40 e0       	ldi	r20, 0x00	; 0
    7f74:	58 e7       	ldi	r21, 0x78	; 120
    7f76:	0e 94 33 52 	call	0xa466	; 0xa466 <xQueueCreateExternal>
    7f7a:	f8 01       	movw	r30, r16
    7f7c:	95 87       	std	Z+13, r25	; 0x0d
    7f7e:	84 87       	std	Z+12, r24	; 0x0c
}
    7f80:	1f 91       	pop	r17
    7f82:	0f 91       	pop	r16
    7f84:	08 95       	ret
    7f86:	08 95       	ret
    7f88:	08 95       	ret
    7f8a:	08 95       	ret
    7f8c:	81 e0       	ldi	r24, 0x01	; 1
    7f8e:	08 95       	ret
    7f90:	81 e0       	ldi	r24, 0x01	; 1
    7f92:	08 95       	ret

00007f94 <rs485curtainUp>:
  releaseRs485();
  return 0;
}

uint8_t rs485curtainUp(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    7f94:	ff 92       	push	r15
    7f96:	0f 93       	push	r16
    7f98:	1f 93       	push	r17
    7f9a:	cf 93       	push	r28
    7f9c:	df 93       	push	r29
    7f9e:	18 2f       	mov	r17, r24
    7fa0:	06 2f       	mov	r16, r22
    7fa2:	f4 2e       	mov	r15, r20
    7fa4:	c0 e0       	ldi	r28, 0x00	; 0
    7fa6:	d0 e0       	ldi	r29, 0x00	; 0
    7fa8:	8a e5       	ldi	r24, 0x5A	; 90
    7faa:	d8 27       	eor	r29, r24
    7fac:	0d 2e       	mov	r0, r29
    7fae:	02 94       	swap	r0
    7fb0:	80 2d       	mov	r24, r0
    7fb2:	8f 70       	andi	r24, 0x0F	; 15
    7fb4:	8d 27       	eor	r24, r29
    7fb6:	9d 2f       	mov	r25, r29
    7fb8:	90 25       	eor	r25, r0
    7fba:	99 0f       	add	r25, r25
    7fbc:	90 7e       	andi	r25, 0xE0	; 224
    7fbe:	89 27       	eor	r24, r25
    7fc0:	90 2d       	mov	r25, r0
    7fc2:	9d 27       	eor	r25, r29
    7fc4:	90 7f       	andi	r25, 0xF0	; 240
    7fc6:	96 95       	lsr	r25
    7fc8:	0d 2e       	mov	r0, r29
    7fca:	00 0c       	add	r0, r0
    7fcc:	99 1f       	adc	r25, r25
    7fce:	d6 95       	lsr	r29
    7fd0:	d6 95       	lsr	r29
    7fd2:	d6 95       	lsr	r29
    7fd4:	df 71       	andi	r29, 0x1F	; 31
    7fd6:	d9 27       	eor	r29, r25
    7fd8:	dc 27       	eor	r29, r28
    7fda:	c8 2f       	mov	r28, r24
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
  uartRs485SendByte(SYNC);
    7fdc:	8a e5       	ldi	r24, 0x5A	; 90
    7fde:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    7fe2:	d1 27       	eor	r29, r17
    7fe4:	0d 2e       	mov	r0, r29
    7fe6:	02 94       	swap	r0
    7fe8:	80 2d       	mov	r24, r0
    7fea:	8f 70       	andi	r24, 0x0F	; 15
    7fec:	8d 27       	eor	r24, r29
    7fee:	9d 2f       	mov	r25, r29
    7ff0:	90 25       	eor	r25, r0
    7ff2:	99 0f       	add	r25, r25
    7ff4:	90 7e       	andi	r25, 0xE0	; 224
    7ff6:	89 27       	eor	r24, r25
    7ff8:	90 2d       	mov	r25, r0
    7ffa:	9d 27       	eor	r25, r29
    7ffc:	90 7f       	andi	r25, 0xF0	; 240
    7ffe:	96 95       	lsr	r25
    8000:	0d 2e       	mov	r0, r29
    8002:	00 0c       	add	r0, r0
    8004:	99 1f       	adc	r25, r25
    8006:	d6 95       	lsr	r29
    8008:	d6 95       	lsr	r29
    800a:	d6 95       	lsr	r29
    800c:	df 71       	andi	r29, 0x1F	; 31
    800e:	d9 27       	eor	r29, r25
    8010:	dc 27       	eor	r29, r28
    8012:	c8 2f       	mov	r28, r24

  crc = _crc_xmodem_update(crc, deviceAddr);
  uartRs485SendByte(deviceAddr);
    8014:	81 2f       	mov	r24, r17
    8016:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  if (curtainNo == 0)
    801a:	00 23       	and	r16, r16
    801c:	e1 f4       	brne	.+56     	; 0x8056 <rs485curtainUp+0xc2>
    801e:	80 e2       	ldi	r24, 0x20	; 32
    8020:	d8 27       	eor	r29, r24
    8022:	0d 2e       	mov	r0, r29
    8024:	02 94       	swap	r0
    8026:	80 2d       	mov	r24, r0
    8028:	8f 70       	andi	r24, 0x0F	; 15
    802a:	8d 27       	eor	r24, r29
    802c:	9d 2f       	mov	r25, r29
    802e:	90 25       	eor	r25, r0
    8030:	99 0f       	add	r25, r25
    8032:	90 7e       	andi	r25, 0xE0	; 224
    8034:	89 27       	eor	r24, r25
    8036:	90 2d       	mov	r25, r0
    8038:	9d 27       	eor	r25, r29
    803a:	90 7f       	andi	r25, 0xF0	; 240
    803c:	96 95       	lsr	r25
    803e:	0d 2e       	mov	r0, r29
    8040:	00 0c       	add	r0, r0
    8042:	99 1f       	adc	r25, r25
    8044:	d6 95       	lsr	r29
    8046:	d6 95       	lsr	r29
    8048:	d6 95       	lsr	r29
    804a:	df 71       	andi	r29, 0x1F	; 31
    804c:	d9 27       	eor	r29, r25
    804e:	dc 27       	eor	r29, r28
    8050:	c8 2f       	mov	r28, r24
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete1);
    uartRs485SendByte(rPodniesRolete1);
    8052:	80 e2       	ldi	r24, 0x20	; 32
    8054:	1b c0       	rjmp	.+54     	; 0x808c <rs485curtainUp+0xf8>
    8056:	81 e2       	ldi	r24, 0x21	; 33
    8058:	d8 27       	eor	r29, r24
    805a:	0d 2e       	mov	r0, r29
    805c:	02 94       	swap	r0
    805e:	80 2d       	mov	r24, r0
    8060:	8f 70       	andi	r24, 0x0F	; 15
    8062:	8d 27       	eor	r24, r29
    8064:	9d 2f       	mov	r25, r29
    8066:	90 25       	eor	r25, r0
    8068:	99 0f       	add	r25, r25
    806a:	90 7e       	andi	r25, 0xE0	; 224
    806c:	89 27       	eor	r24, r25
    806e:	90 2d       	mov	r25, r0
    8070:	9d 27       	eor	r25, r29
    8072:	90 7f       	andi	r25, 0xF0	; 240
    8074:	96 95       	lsr	r25
    8076:	0d 2e       	mov	r0, r29
    8078:	00 0c       	add	r0, r0
    807a:	99 1f       	adc	r25, r25
    807c:	d6 95       	lsr	r29
    807e:	d6 95       	lsr	r29
    8080:	d6 95       	lsr	r29
    8082:	df 71       	andi	r29, 0x1F	; 31
    8084:	d9 27       	eor	r29, r25
    8086:	dc 27       	eor	r29, r28
    8088:	c8 2f       	mov	r28, r24
  }
  else
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete2);
    uartRs485SendByte(rPodniesRolete2); 
    808a:	81 e2       	ldi	r24, 0x21	; 33
    808c:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8090:	81 e0       	ldi	r24, 0x01	; 1
    8092:	d8 27       	eor	r29, r24
    8094:	0d 2e       	mov	r0, r29
    8096:	02 94       	swap	r0
    8098:	80 2d       	mov	r24, r0
    809a:	8f 70       	andi	r24, 0x0F	; 15
    809c:	8d 27       	eor	r24, r29
    809e:	9d 2f       	mov	r25, r29
    80a0:	90 25       	eor	r25, r0
    80a2:	99 0f       	add	r25, r25
    80a4:	90 7e       	andi	r25, 0xE0	; 224
    80a6:	89 27       	eor	r24, r25
    80a8:	90 2d       	mov	r25, r0
    80aa:	9d 27       	eor	r25, r29
    80ac:	90 7f       	andi	r25, 0xF0	; 240
    80ae:	96 95       	lsr	r25
    80b0:	0d 2e       	mov	r0, r29
    80b2:	00 0c       	add	r0, r0
    80b4:	99 1f       	adc	r25, r25
    80b6:	d6 95       	lsr	r29
    80b8:	d6 95       	lsr	r29
    80ba:	d6 95       	lsr	r29
    80bc:	df 71       	andi	r29, 0x1F	; 31
    80be:	d9 27       	eor	r29, r25
    80c0:	dc 27       	eor	r29, r28
    80c2:	c8 2f       	mov	r28, r24
  }
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    80c4:	81 e0       	ldi	r24, 0x01	; 1
    80c6:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    80ca:	df 25       	eor	r29, r15
    80cc:	0d 2e       	mov	r0, r29
    80ce:	02 94       	swap	r0
    80d0:	80 2d       	mov	r24, r0
    80d2:	8f 70       	andi	r24, 0x0F	; 15
    80d4:	8d 27       	eor	r24, r29
    80d6:	9d 2f       	mov	r25, r29
    80d8:	90 25       	eor	r25, r0
    80da:	99 0f       	add	r25, r25
    80dc:	90 7e       	andi	r25, 0xE0	; 224
    80de:	89 27       	eor	r24, r25
    80e0:	90 2d       	mov	r25, r0
    80e2:	9d 27       	eor	r25, r29
    80e4:	90 7f       	andi	r25, 0xF0	; 240
    80e6:	96 95       	lsr	r25
    80e8:	0d 2e       	mov	r0, r29
    80ea:	00 0c       	add	r0, r0
    80ec:	99 1f       	adc	r25, r25
    80ee:	d6 95       	lsr	r29
    80f0:	d6 95       	lsr	r29
    80f2:	d6 95       	lsr	r29
    80f4:	df 71       	andi	r29, 0x1F	; 31
    80f6:	d9 27       	eor	r29, r25
    80f8:	dc 27       	eor	r29, r28
    80fa:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, pos);  uartRs485SendByte(pos);
    80fc:	8f 2d       	mov	r24, r15
    80fe:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8102:	8d 2f       	mov	r24, r29
    8104:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8108:	8c 2f       	mov	r24, r28
    810a:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  
  return 0;
}
    810e:	80 e0       	ldi	r24, 0x00	; 0
    8110:	df 91       	pop	r29
    8112:	cf 91       	pop	r28
    8114:	1f 91       	pop	r17
    8116:	0f 91       	pop	r16
    8118:	ff 90       	pop	r15
    811a:	08 95       	ret

0000811c <rs485curtainDown>:

uint8_t rs485curtainDown(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    811c:	ff 92       	push	r15
    811e:	0f 93       	push	r16
    8120:	1f 93       	push	r17
    8122:	cf 93       	push	r28
    8124:	df 93       	push	r29
    8126:	18 2f       	mov	r17, r24
    8128:	06 2f       	mov	r16, r22
    812a:	f4 2e       	mov	r15, r20
    812c:	c0 e0       	ldi	r28, 0x00	; 0
    812e:	d0 e0       	ldi	r29, 0x00	; 0
    8130:	8a e5       	ldi	r24, 0x5A	; 90
    8132:	d8 27       	eor	r29, r24
    8134:	0d 2e       	mov	r0, r29
    8136:	02 94       	swap	r0
    8138:	80 2d       	mov	r24, r0
    813a:	8f 70       	andi	r24, 0x0F	; 15
    813c:	8d 27       	eor	r24, r29
    813e:	9d 2f       	mov	r25, r29
    8140:	90 25       	eor	r25, r0
    8142:	99 0f       	add	r25, r25
    8144:	90 7e       	andi	r25, 0xE0	; 224
    8146:	89 27       	eor	r24, r25
    8148:	90 2d       	mov	r25, r0
    814a:	9d 27       	eor	r25, r29
    814c:	90 7f       	andi	r25, 0xF0	; 240
    814e:	96 95       	lsr	r25
    8150:	0d 2e       	mov	r0, r29
    8152:	00 0c       	add	r0, r0
    8154:	99 1f       	adc	r25, r25
    8156:	d6 95       	lsr	r29
    8158:	d6 95       	lsr	r29
    815a:	d6 95       	lsr	r29
    815c:	df 71       	andi	r29, 0x1F	; 31
    815e:	d9 27       	eor	r29, r25
    8160:	dc 27       	eor	r29, r28
    8162:	c8 2f       	mov	r28, r24
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);            uartRs485SendByte(SYNC);
    8164:	8a e5       	ldi	r24, 0x5A	; 90
    8166:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    816a:	d1 27       	eor	r29, r17
    816c:	0d 2e       	mov	r0, r29
    816e:	02 94       	swap	r0
    8170:	80 2d       	mov	r24, r0
    8172:	8f 70       	andi	r24, 0x0F	; 15
    8174:	8d 27       	eor	r24, r29
    8176:	9d 2f       	mov	r25, r29
    8178:	90 25       	eor	r25, r0
    817a:	99 0f       	add	r25, r25
    817c:	90 7e       	andi	r25, 0xE0	; 224
    817e:	89 27       	eor	r24, r25
    8180:	90 2d       	mov	r25, r0
    8182:	9d 27       	eor	r25, r29
    8184:	90 7f       	andi	r25, 0xF0	; 240
    8186:	96 95       	lsr	r25
    8188:	0d 2e       	mov	r0, r29
    818a:	00 0c       	add	r0, r0
    818c:	99 1f       	adc	r25, r25
    818e:	d6 95       	lsr	r29
    8190:	d6 95       	lsr	r29
    8192:	d6 95       	lsr	r29
    8194:	df 71       	andi	r29, 0x1F	; 31
    8196:	d9 27       	eor	r29, r25
    8198:	dc 27       	eor	r29, r28
    819a:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, deviceAddr);    uartRs485SendByte(deviceAddr);
    819c:	81 2f       	mov	r24, r17
    819e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  if (curtainNo == 0)
    81a2:	00 23       	and	r16, r16
    81a4:	e1 f4       	brne	.+56     	; 0x81de <rs485curtainDown+0xc2>
    81a6:	80 e1       	ldi	r24, 0x10	; 16
    81a8:	d8 27       	eor	r29, r24
    81aa:	0d 2e       	mov	r0, r29
    81ac:	02 94       	swap	r0
    81ae:	80 2d       	mov	r24, r0
    81b0:	8f 70       	andi	r24, 0x0F	; 15
    81b2:	8d 27       	eor	r24, r29
    81b4:	9d 2f       	mov	r25, r29
    81b6:	90 25       	eor	r25, r0
    81b8:	99 0f       	add	r25, r25
    81ba:	90 7e       	andi	r25, 0xE0	; 224
    81bc:	89 27       	eor	r24, r25
    81be:	90 2d       	mov	r25, r0
    81c0:	9d 27       	eor	r25, r29
    81c2:	90 7f       	andi	r25, 0xF0	; 240
    81c4:	96 95       	lsr	r25
    81c6:	0d 2e       	mov	r0, r29
    81c8:	00 0c       	add	r0, r0
    81ca:	99 1f       	adc	r25, r25
    81cc:	d6 95       	lsr	r29
    81ce:	d6 95       	lsr	r29
    81d0:	d6 95       	lsr	r29
    81d2:	df 71       	andi	r29, 0x1F	; 31
    81d4:	d9 27       	eor	r29, r25
    81d6:	dc 27       	eor	r29, r28
    81d8:	c8 2f       	mov	r28, r24
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete1); uartRs485SendByte(rOpuscRolete1);
    81da:	80 e1       	ldi	r24, 0x10	; 16
    81dc:	1b c0       	rjmp	.+54     	; 0x8214 <rs485curtainDown+0xf8>
    81de:	81 e1       	ldi	r24, 0x11	; 17
    81e0:	d8 27       	eor	r29, r24
    81e2:	0d 2e       	mov	r0, r29
    81e4:	02 94       	swap	r0
    81e6:	80 2d       	mov	r24, r0
    81e8:	8f 70       	andi	r24, 0x0F	; 15
    81ea:	8d 27       	eor	r24, r29
    81ec:	9d 2f       	mov	r25, r29
    81ee:	90 25       	eor	r25, r0
    81f0:	99 0f       	add	r25, r25
    81f2:	90 7e       	andi	r25, 0xE0	; 224
    81f4:	89 27       	eor	r24, r25
    81f6:	90 2d       	mov	r25, r0
    81f8:	9d 27       	eor	r25, r29
    81fa:	90 7f       	andi	r25, 0xF0	; 240
    81fc:	96 95       	lsr	r25
    81fe:	0d 2e       	mov	r0, r29
    8200:	00 0c       	add	r0, r0
    8202:	99 1f       	adc	r25, r25
    8204:	d6 95       	lsr	r29
    8206:	d6 95       	lsr	r29
    8208:	d6 95       	lsr	r29
    820a:	df 71       	andi	r29, 0x1F	; 31
    820c:	d9 27       	eor	r29, r25
    820e:	dc 27       	eor	r29, r28
    8210:	c8 2f       	mov	r28, r24
  }
  else
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete2); uartRs485SendByte(rOpuscRolete2); 
    8212:	81 e1       	ldi	r24, 0x11	; 17
    8214:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8218:	81 e0       	ldi	r24, 0x01	; 1
    821a:	d8 27       	eor	r29, r24
    821c:	0d 2e       	mov	r0, r29
    821e:	02 94       	swap	r0
    8220:	80 2d       	mov	r24, r0
    8222:	8f 70       	andi	r24, 0x0F	; 15
    8224:	8d 27       	eor	r24, r29
    8226:	9d 2f       	mov	r25, r29
    8228:	90 25       	eor	r25, r0
    822a:	99 0f       	add	r25, r25
    822c:	90 7e       	andi	r25, 0xE0	; 224
    822e:	89 27       	eor	r24, r25
    8230:	90 2d       	mov	r25, r0
    8232:	9d 27       	eor	r25, r29
    8234:	90 7f       	andi	r25, 0xF0	; 240
    8236:	96 95       	lsr	r25
    8238:	0d 2e       	mov	r0, r29
    823a:	00 0c       	add	r0, r0
    823c:	99 1f       	adc	r25, r25
    823e:	d6 95       	lsr	r29
    8240:	d6 95       	lsr	r29
    8242:	d6 95       	lsr	r29
    8244:	df 71       	andi	r29, 0x1F	; 31
    8246:	d9 27       	eor	r29, r25
    8248:	dc 27       	eor	r29, r28
    824a:	c8 2f       	mov	r28, r24
  }

  crc = _crc_xmodem_update(crc, 1);               uartRs485SendByte(1);
    824c:	81 e0       	ldi	r24, 0x01	; 1
    824e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8252:	df 25       	eor	r29, r15
    8254:	0d 2e       	mov	r0, r29
    8256:	02 94       	swap	r0
    8258:	80 2d       	mov	r24, r0
    825a:	8f 70       	andi	r24, 0x0F	; 15
    825c:	8d 27       	eor	r24, r29
    825e:	9d 2f       	mov	r25, r29
    8260:	90 25       	eor	r25, r0
    8262:	99 0f       	add	r25, r25
    8264:	90 7e       	andi	r25, 0xE0	; 224
    8266:	89 27       	eor	r24, r25
    8268:	90 2d       	mov	r25, r0
    826a:	9d 27       	eor	r25, r29
    826c:	90 7f       	andi	r25, 0xF0	; 240
    826e:	96 95       	lsr	r25
    8270:	0d 2e       	mov	r0, r29
    8272:	00 0c       	add	r0, r0
    8274:	99 1f       	adc	r25, r25
    8276:	d6 95       	lsr	r29
    8278:	d6 95       	lsr	r29
    827a:	d6 95       	lsr	r29
    827c:	df 71       	andi	r29, 0x1F	; 31
    827e:	d9 27       	eor	r29, r25
    8280:	dc 27       	eor	r29, r28
    8282:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, pos);         uartRs485SendByte(pos);
    8284:	8f 2d       	mov	r24, r15
    8286:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    828a:	8d 2f       	mov	r24, r29
    828c:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8290:	8c 2f       	mov	r24, r28
    8292:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>

  return 0;
}
    8296:	80 e0       	ldi	r24, 0x00	; 0
    8298:	df 91       	pop	r29
    829a:	cf 91       	pop	r28
    829c:	1f 91       	pop	r17
    829e:	0f 91       	pop	r16
    82a0:	ff 90       	pop	r15
    82a2:	08 95       	ret

000082a4 <printRs485devices>:
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
}

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
    82a4:	af 92       	push	r10
    82a6:	bf 92       	push	r11
    82a8:	cf 92       	push	r12
    82aa:	df 92       	push	r13
    82ac:	ef 92       	push	r14
    82ae:	ff 92       	push	r15
    82b0:	0f 93       	push	r16
    82b2:	1f 93       	push	r17
    82b4:	cf 93       	push	r28
    82b6:	df 93       	push	r29
    82b8:	7c 01       	movw	r14, r24
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
    82ba:	c0 91 a8 0e 	lds	r28, 0x0EA8
    82be:	d0 91 a9 0e 	lds	r29, 0x0EA9
    82c2:	00 e0       	ldi	r16, 0x00	; 0
    82c4:	10 e0       	ldi	r17, 0x00	; 0
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    82c6:	99 ee       	ldi	r25, 0xE9	; 233
    82c8:	a9 2e       	mov	r10, r25
    82ca:	92 e1       	ldi	r25, 0x12	; 18
    82cc:	b9 2e       	mov	r11, r25
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    82ce:	87 e2       	ldi	r24, 0x27	; 39
    82d0:	c8 2e       	mov	r12, r24
    82d2:	83 e1       	ldi	r24, 0x13	; 19
    82d4:	d8 2e       	mov	r13, r24
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    82d6:	89 81       	ldd	r24, Y+1	; 0x01
    82d8:	88 23       	and	r24, r24
    82da:	09 f4       	brne	.+2      	; 0x82de <printRs485devices+0x3a>
    82dc:	43 c0       	rjmp	.+134    	; 0x8364 <printRs485devices+0xc0>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    82de:	2d b7       	in	r18, 0x3d	; 61
    82e0:	3e b7       	in	r19, 0x3e	; 62
    82e2:	2a 50       	subi	r18, 0x0A	; 10
    82e4:	30 40       	sbci	r19, 0x00	; 0
    82e6:	0f b6       	in	r0, 0x3f	; 63
    82e8:	f8 94       	cli
    82ea:	3e bf       	out	0x3e, r19	; 62
    82ec:	0f be       	out	0x3f, r0	; 63
    82ee:	2d bf       	out	0x3d, r18	; 61
    82f0:	ed b7       	in	r30, 0x3d	; 61
    82f2:	fe b7       	in	r31, 0x3e	; 62
    82f4:	31 96       	adiw	r30, 0x01	; 1
    82f6:	ad b7       	in	r26, 0x3d	; 61
    82f8:	be b7       	in	r27, 0x3e	; 62
    82fa:	12 96       	adiw	r26, 0x02	; 2
    82fc:	fc 92       	st	X, r15
    82fe:	ee 92       	st	-X, r14
    8300:	11 97       	sbiw	r26, 0x01	; 1
    8302:	b3 82       	std	Z+3, r11	; 0x03
    8304:	a2 82       	std	Z+2, r10	; 0x02
    8306:	84 83       	std	Z+4, r24	; 0x04
    8308:	15 82       	std	Z+5, r1	; 0x05
    830a:	8a 81       	ldd	r24, Y+2	; 0x02
    830c:	90 e0       	ldi	r25, 0x00	; 0
    830e:	8f 73       	andi	r24, 0x3F	; 63
    8310:	90 70       	andi	r25, 0x00	; 0
    8312:	97 83       	std	Z+7, r25	; 0x07
    8314:	86 83       	std	Z+6, r24	; 0x06
    8316:	8b 81       	ldd	r24, Y+3	; 0x03
    8318:	90 e0       	ldi	r25, 0x00	; 0
    831a:	8f 73       	andi	r24, 0x3F	; 63
    831c:	90 70       	andi	r25, 0x00	; 0
    831e:	91 87       	std	Z+9, r25	; 0x09
    8320:	80 87       	std	Z+8, r24	; 0x08
    8322:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    8326:	0f 90       	pop	r0
    8328:	0f 90       	pop	r0
    832a:	0f 90       	pop	r0
    832c:	0f 90       	pop	r0
    832e:	ed b7       	in	r30, 0x3d	; 61
    8330:	fe b7       	in	r31, 0x3e	; 62
    8332:	31 96       	adiw	r30, 0x01	; 1
    8334:	ad b7       	in	r26, 0x3d	; 61
    8336:	be b7       	in	r27, 0x3e	; 62
    8338:	12 96       	adiw	r26, 0x02	; 2
    833a:	fc 92       	st	X, r15
    833c:	ee 92       	st	-X, r14
    833e:	11 97       	sbiw	r26, 0x01	; 1
    8340:	d3 82       	std	Z+3, r13	; 0x03
    8342:	c2 82       	std	Z+2, r12	; 0x02
    8344:	24 96       	adiw	r28, 0x04	; 4
    8346:	d5 83       	std	Z+5, r29	; 0x05
    8348:	c4 83       	std	Z+4, r28	; 0x04
    834a:	24 97       	sbiw	r28, 0x04	; 4
    834c:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
      result++;
    8350:	0f 5f       	subi	r16, 0xFF	; 255
    8352:	2d b7       	in	r18, 0x3d	; 61
    8354:	3e b7       	in	r19, 0x3e	; 62
    8356:	2a 5f       	subi	r18, 0xFA	; 250
    8358:	3f 4f       	sbci	r19, 0xFF	; 255
    835a:	0f b6       	in	r0, 0x3f	; 63
    835c:	f8 94       	cli
    835e:	3e bf       	out	0x3e, r19	; 62
    8360:	0f be       	out	0x3f, r0	; 63
    8362:	2d bf       	out	0x3d, r18	; 61
{
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    8364:	1f 5f       	subi	r17, 0xFF	; 255
    8366:	1a 30       	cpi	r17, 0x0A	; 10
    8368:	11 f0       	breq	.+4      	; 0x836e <printRs485devices+0xca>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
      result++;
    }
    rolTmp++;
    836a:	2a 96       	adiw	r28, 0x0a	; 10
    836c:	b4 cf       	rjmp	.-152    	; 0x82d6 <printRs485devices+0x32>
  }
  
  
  return result;
}
    836e:	80 2f       	mov	r24, r16
    8370:	df 91       	pop	r29
    8372:	cf 91       	pop	r28
    8374:	1f 91       	pop	r17
    8376:	0f 91       	pop	r16
    8378:	ff 90       	pop	r15
    837a:	ef 90       	pop	r14
    837c:	df 90       	pop	r13
    837e:	cf 90       	pop	r12
    8380:	bf 90       	pop	r11
    8382:	af 90       	pop	r10
    8384:	08 95       	ret

00008386 <rs485xModemFlash>:
  return result;
}


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
    8386:	6f 92       	push	r6
    8388:	7f 92       	push	r7
    838a:	8f 92       	push	r8
    838c:	9f 92       	push	r9
    838e:	af 92       	push	r10
    8390:	bf 92       	push	r11
    8392:	cf 92       	push	r12
    8394:	df 92       	push	r13
    8396:	ef 92       	push	r14
    8398:	ff 92       	push	r15
    839a:	0f 93       	push	r16
    839c:	1f 93       	push	r17
    839e:	df 93       	push	r29
    83a0:	cf 93       	push	r28
    83a2:	00 d0       	rcall	.+0      	; 0x83a4 <rs485xModemFlash+0x1e>
    83a4:	cd b7       	in	r28, 0x3d	; 61
    83a6:	de b7       	in	r29, 0x3e	; 62
    83a8:	3c 01       	movw	r6, r24
    83aa:	b6 2e       	mov	r11, r22
    83ac:	6a 01       	movw	r12, r20
  uint8_t  blad = 0;
  uint8_t  data;
  uint8_t  nrBloku;
  uint8_t  lRetransmisji;
  
  takeRs485();                                  // Zajmowanie magistrali Rs485
    83ae:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <takeRs485>
    83b2:	00 e0       	ldi	r16, 0x00	; 0
    83b4:	10 e0       	ldi	r17, 0x00	; 0
    83b6:	8a e5       	ldi	r24, 0x5A	; 90
    83b8:	18 27       	eor	r17, r24
    83ba:	01 2e       	mov	r0, r17
    83bc:	02 94       	swap	r0
    83be:	80 2d       	mov	r24, r0
    83c0:	8f 70       	andi	r24, 0x0F	; 15
    83c2:	81 27       	eor	r24, r17
    83c4:	91 2f       	mov	r25, r17
    83c6:	90 25       	eor	r25, r0
    83c8:	99 0f       	add	r25, r25
    83ca:	90 7e       	andi	r25, 0xE0	; 224
    83cc:	89 27       	eor	r24, r25
    83ce:	90 2d       	mov	r25, r0
    83d0:	91 27       	eor	r25, r17
    83d2:	90 7f       	andi	r25, 0xF0	; 240
    83d4:	96 95       	lsr	r25
    83d6:	01 2e       	mov	r0, r17
    83d8:	00 0c       	add	r0, r0
    83da:	99 1f       	adc	r25, r25
    83dc:	16 95       	lsr	r17
    83de:	16 95       	lsr	r17
    83e0:	16 95       	lsr	r17
    83e2:	1f 71       	andi	r17, 0x1F	; 31
    83e4:	19 27       	eor	r17, r25
    83e6:	10 27       	eor	r17, r16
    83e8:	08 2f       	mov	r16, r24

  // Wysyłanie polecenia restartu
  crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    83ea:	8a e5       	ldi	r24, 0x5A	; 90
    83ec:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    83f0:	1b 25       	eor	r17, r11
    83f2:	01 2e       	mov	r0, r17
    83f4:	02 94       	swap	r0
    83f6:	80 2d       	mov	r24, r0
    83f8:	8f 70       	andi	r24, 0x0F	; 15
    83fa:	81 27       	eor	r24, r17
    83fc:	91 2f       	mov	r25, r17
    83fe:	90 25       	eor	r25, r0
    8400:	99 0f       	add	r25, r25
    8402:	90 7e       	andi	r25, 0xE0	; 224
    8404:	89 27       	eor	r24, r25
    8406:	90 2d       	mov	r25, r0
    8408:	91 27       	eor	r25, r17
    840a:	90 7f       	andi	r25, 0xF0	; 240
    840c:	96 95       	lsr	r25
    840e:	01 2e       	mov	r0, r17
    8410:	00 0c       	add	r0, r0
    8412:	99 1f       	adc	r25, r25
    8414:	16 95       	lsr	r17
    8416:	16 95       	lsr	r17
    8418:	16 95       	lsr	r17
    841a:	1f 71       	andi	r17, 0x1F	; 31
    841c:	19 27       	eor	r17, r25
    841e:	10 27       	eor	r17, r16
    8420:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8422:	8b 2d       	mov	r24, r11
    8424:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8428:	81 e8       	ldi	r24, 0x81	; 129
    842a:	18 27       	eor	r17, r24
    842c:	01 2e       	mov	r0, r17
    842e:	02 94       	swap	r0
    8430:	80 2d       	mov	r24, r0
    8432:	8f 70       	andi	r24, 0x0F	; 15
    8434:	81 27       	eor	r24, r17
    8436:	91 2f       	mov	r25, r17
    8438:	90 25       	eor	r25, r0
    843a:	99 0f       	add	r25, r25
    843c:	90 7e       	andi	r25, 0xE0	; 224
    843e:	89 27       	eor	r24, r25
    8440:	90 2d       	mov	r25, r0
    8442:	91 27       	eor	r25, r17
    8444:	90 7f       	andi	r25, 0xF0	; 240
    8446:	96 95       	lsr	r25
    8448:	01 2e       	mov	r0, r17
    844a:	00 0c       	add	r0, r0
    844c:	99 1f       	adc	r25, r25
    844e:	16 95       	lsr	r17
    8450:	16 95       	lsr	r17
    8452:	16 95       	lsr	r17
    8454:	1f 71       	andi	r17, 0x1F	; 31
    8456:	19 27       	eor	r17, r25
    8458:	10 27       	eor	r17, r16
    845a:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    845c:	81 e8       	ldi	r24, 0x81	; 129
    845e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8462:	81 e0       	ldi	r24, 0x01	; 1
    8464:	18 27       	eor	r17, r24
    8466:	01 2e       	mov	r0, r17
    8468:	02 94       	swap	r0
    846a:	80 2d       	mov	r24, r0
    846c:	8f 70       	andi	r24, 0x0F	; 15
    846e:	81 27       	eor	r24, r17
    8470:	91 2f       	mov	r25, r17
    8472:	90 25       	eor	r25, r0
    8474:	99 0f       	add	r25, r25
    8476:	90 7e       	andi	r25, 0xE0	; 224
    8478:	89 27       	eor	r24, r25
    847a:	90 2d       	mov	r25, r0
    847c:	91 27       	eor	r25, r17
    847e:	90 7f       	andi	r25, 0xF0	; 240
    8480:	96 95       	lsr	r25
    8482:	01 2e       	mov	r0, r17
    8484:	00 0c       	add	r0, r0
    8486:	99 1f       	adc	r25, r25
    8488:	16 95       	lsr	r17
    848a:	16 95       	lsr	r17
    848c:	16 95       	lsr	r17
    848e:	1f 71       	andi	r17, 0x1F	; 31
    8490:	19 27       	eor	r17, r25
    8492:	10 27       	eor	r17, r16
    8494:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    8496:	81 e0       	ldi	r24, 0x01	; 1
    8498:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    849c:	1b 25       	eor	r17, r11
    849e:	01 2e       	mov	r0, r17
    84a0:	02 94       	swap	r0
    84a2:	80 2d       	mov	r24, r0
    84a4:	8f 70       	andi	r24, 0x0F	; 15
    84a6:	81 27       	eor	r24, r17
    84a8:	91 2f       	mov	r25, r17
    84aa:	90 25       	eor	r25, r0
    84ac:	99 0f       	add	r25, r25
    84ae:	90 7e       	andi	r25, 0xE0	; 224
    84b0:	89 27       	eor	r24, r25
    84b2:	90 2d       	mov	r25, r0
    84b4:	91 27       	eor	r25, r17
    84b6:	90 7f       	andi	r25, 0xF0	; 240
    84b8:	96 95       	lsr	r25
    84ba:	01 2e       	mov	r0, r17
    84bc:	00 0c       	add	r0, r0
    84be:	99 1f       	adc	r25, r25
    84c0:	16 95       	lsr	r17
    84c2:	16 95       	lsr	r17
    84c4:	16 95       	lsr	r17
    84c6:	1f 71       	andi	r17, 0x1F	; 31
    84c8:	19 27       	eor	r17, r25
    84ca:	10 27       	eor	r17, r16
    84cc:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    84ce:	8b 2d       	mov	r24, r11
    84d0:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc>>8));
    84d4:	81 2f       	mov	r24, r17
    84d6:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    84da:	80 2f       	mov	r24, r16
    84dc:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
 

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
    84e0:	ce 01       	movw	r24, r28
    84e2:	01 96       	adiw	r24, 0x01	; 1
    84e4:	64 e6       	ldi	r22, 0x64	; 100
    84e6:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    84ea:	81 30       	cpi	r24, 0x01	; 1
    84ec:	11 f4       	brne	.+4      	; 0x84f2 <rs485xModemFlash+0x16c>
    84ee:	10 e0       	ldi	r17, 0x00	; 0
    84f0:	1a c0       	rjmp	.+52     	; 0x8526 <rs485xModemFlash+0x1a0>
  {
    blad = 1;                                  // Timeout
    if (debugStr != NULL)
    84f2:	c1 14       	cp	r12, r1
    84f4:	d1 04       	cpc	r13, r1
    84f6:	11 f4       	brne	.+4      	; 0x84fc <rs485xModemFlash+0x176>
    84f8:	11 e0       	ldi	r17, 0x01	; 1
    84fa:	15 c0       	rjmp	.+42     	; 0x8526 <rs485xModemFlash+0x1a0>
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
    84fc:	00 d0       	rcall	.+0      	; 0x84fe <rs485xModemFlash+0x178>
    84fe:	00 d0       	rcall	.+0      	; 0x8500 <rs485xModemFlash+0x17a>
    8500:	ad b7       	in	r26, 0x3d	; 61
    8502:	be b7       	in	r27, 0x3e	; 62
    8504:	12 96       	adiw	r26, 0x02	; 2
    8506:	dc 92       	st	X, r13
    8508:	ce 92       	st	-X, r12
    850a:	11 97       	sbiw	r26, 0x01	; 1
    850c:	85 e9       	ldi	r24, 0x95	; 149
    850e:	93 e1       	ldi	r25, 0x13	; 19
    8510:	14 96       	adiw	r26, 0x04	; 4
    8512:	9c 93       	st	X, r25
    8514:	8e 93       	st	-X, r24
    8516:	13 97       	sbiw	r26, 0x03	; 3
    8518:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    851c:	11 e0       	ldi	r17, 0x01	; 1
    851e:	0f 90       	pop	r0
    8520:	0f 90       	pop	r0
    8522:	0f 90       	pop	r0
    8524:	0f 90       	pop	r0
  }
  crc = _crc_xmodem_update(0, data);
    8526:	89 81       	ldd	r24, Y+1	; 0x01
    8528:	ee 24       	eor	r14, r14
    852a:	ff 24       	eor	r15, r15
    852c:	f7 01       	movw	r30, r14
    852e:	f8 27       	eor	r31, r24
    8530:	0f 2e       	mov	r0, r31
    8532:	02 94       	swap	r0
    8534:	90 2d       	mov	r25, r0
    8536:	9f 70       	andi	r25, 0x0F	; 15
    8538:	9f 27       	eor	r25, r31
    853a:	2f 2f       	mov	r18, r31
    853c:	20 25       	eor	r18, r0
    853e:	22 0f       	add	r18, r18
    8540:	20 7e       	andi	r18, 0xE0	; 224
    8542:	92 27       	eor	r25, r18
    8544:	20 2d       	mov	r18, r0
    8546:	2f 27       	eor	r18, r31
    8548:	20 7f       	andi	r18, 0xF0	; 240
    854a:	26 95       	lsr	r18
    854c:	0f 2e       	mov	r0, r31
    854e:	00 0c       	add	r0, r0
    8550:	22 1f       	adc	r18, r18
    8552:	f6 95       	lsr	r31
    8554:	f6 95       	lsr	r31
    8556:	f6 95       	lsr	r31
    8558:	ff 71       	andi	r31, 0x1F	; 31
    855a:	f2 27       	eor	r31, r18
    855c:	fe 27       	eor	r31, r30
    855e:	e9 2f       	mov	r30, r25
    8560:	7f 01       	movw	r14, r30
 
  if ((blad == 0) && (data == 'C'))
    8562:	11 23       	and	r17, r17
    8564:	d9 f4       	brne	.+54     	; 0x859c <rs485xModemFlash+0x216>
    8566:	83 34       	cpi	r24, 0x43	; 67
    8568:	c9 f4       	brne	.+50     	; 0x859c <rs485xModemFlash+0x216>
  {
    blad = 253;                                //Na urządzeniu jest wgrany tylko bootloader
    if (debugStr != NULL)
    856a:	c1 14       	cp	r12, r1
    856c:	d1 04       	cpc	r13, r1
    856e:	09 f4       	brne	.+2      	; 0x8572 <rs485xModemFlash+0x1ec>
    8570:	87 c1       	rjmp	.+782    	; 0x8880 <rs485xModemFlash+0x4fa>
      fprintf_P(debugStr, PSTR("na urzadzeniu wgrany jest tylko bootloader\r\n"));    
    8572:	00 d0       	rcall	.+0      	; 0x8574 <rs485xModemFlash+0x1ee>
    8574:	00 d0       	rcall	.+0      	; 0x8576 <rs485xModemFlash+0x1f0>
    8576:	ad b7       	in	r26, 0x3d	; 61
    8578:	be b7       	in	r27, 0x3e	; 62
    857a:	12 96       	adiw	r26, 0x02	; 2
    857c:	dc 92       	st	X, r13
    857e:	ce 92       	st	-X, r12
    8580:	11 97       	sbiw	r26, 0x01	; 1
    8582:	88 e6       	ldi	r24, 0x68	; 104
    8584:	93 e1       	ldi	r25, 0x13	; 19
    8586:	14 96       	adiw	r26, 0x04	; 4
    8588:	9c 93       	st	X, r25
    858a:	8e 93       	st	-X, r24
    858c:	13 97       	sbiw	r26, 0x03	; 3
    858e:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    8592:	0f 90       	pop	r0
    8594:	0f 90       	pop	r0
    8596:	0f 90       	pop	r0
    8598:	0f 90       	pop	r0
    859a:	72 c1       	rjmp	.+740    	; 0x8880 <rs485xModemFlash+0x4fa>
  }
  else
  {
    if (data != SYNC)
    859c:	8a 35       	cpi	r24, 0x5A	; 90
    859e:	09 f0       	breq	.+2      	; 0x85a2 <rs485xModemFlash+0x21c>
    85a0:	c7 c0       	rjmp	.+398    	; 0x8730 <rs485xModemFlash+0x3aa>
      blad = 2;
  }
 
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
    85a2:	11 23       	and	r17, r17
    85a4:	09 f0       	breq	.+2      	; 0x85a8 <rs485xModemFlash+0x222>
    85a6:	c4 c0       	rjmp	.+392    	; 0x8730 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    85a8:	ce 01       	movw	r24, r28
    85aa:	01 96       	adiw	r24, 0x01	; 1
    85ac:	61 e0       	ldi	r22, 0x01	; 1
    85ae:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    85b2:	81 30       	cpi	r24, 0x01	; 1
    85b4:	11 f0       	breq	.+4      	; 0x85ba <rs485xModemFlash+0x234>
    85b6:	13 e0       	ldi	r17, 0x03	; 3
    85b8:	03 c0       	rjmp	.+6      	; 0x85c0 <rs485xModemFlash+0x23a>
      blad = 3;
    else
    {
      if (data != 0)
    85ba:	89 81       	ldd	r24, Y+1	; 0x01
    85bc:	81 11       	cpse	r24, r1
    85be:	14 e0       	ldi	r17, 0x04	; 4
    85c0:	89 81       	ldd	r24, Y+1	; 0x01
    85c2:	f7 01       	movw	r30, r14
    85c4:	f8 27       	eor	r31, r24
    85c6:	0f 2e       	mov	r0, r31
    85c8:	02 94       	swap	r0
    85ca:	80 2d       	mov	r24, r0
    85cc:	8f 70       	andi	r24, 0x0F	; 15
    85ce:	8f 27       	eor	r24, r31
    85d0:	9f 2f       	mov	r25, r31
    85d2:	90 25       	eor	r25, r0
    85d4:	99 0f       	add	r25, r25
    85d6:	90 7e       	andi	r25, 0xE0	; 224
    85d8:	89 27       	eor	r24, r25
    85da:	90 2d       	mov	r25, r0
    85dc:	9f 27       	eor	r25, r31
    85de:	90 7f       	andi	r25, 0xF0	; 240
    85e0:	96 95       	lsr	r25
    85e2:	0f 2e       	mov	r0, r31
    85e4:	00 0c       	add	r0, r0
    85e6:	99 1f       	adc	r25, r25
    85e8:	f6 95       	lsr	r31
    85ea:	f6 95       	lsr	r31
    85ec:	f6 95       	lsr	r31
    85ee:	ff 71       	andi	r31, 0x1F	; 31
    85f0:	f9 27       	eor	r31, r25
    85f2:	fe 27       	eor	r31, r30
    85f4:	e8 2f       	mov	r30, r24
    85f6:	7f 01       	movw	r14, r30
    }
    crc = _crc_xmodem_update(crc, data);
  }
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
    85f8:	11 23       	and	r17, r17
    85fa:	09 f0       	breq	.+2      	; 0x85fe <rs485xModemFlash+0x278>
    85fc:	99 c0       	rjmp	.+306    	; 0x8730 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    85fe:	ce 01       	movw	r24, r28
    8600:	01 96       	adiw	r24, 0x01	; 1
    8602:	61 e0       	ldi	r22, 0x01	; 1
    8604:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8608:	81 30       	cpi	r24, 0x01	; 1
    860a:	11 f0       	breq	.+4      	; 0x8610 <rs485xModemFlash+0x28a>
    860c:	15 e0       	ldi	r17, 0x05	; 5
    860e:	04 c0       	rjmp	.+8      	; 0x8618 <rs485xModemFlash+0x292>
      blad = 5;
    else
    {
      if (data != rFLASH)
    8610:	89 81       	ldd	r24, Y+1	; 0x01
    8612:	81 38       	cpi	r24, 0x81	; 129
    8614:	09 f0       	breq	.+2      	; 0x8618 <rs485xModemFlash+0x292>
    8616:	16 e0       	ldi	r17, 0x06	; 6
    8618:	89 81       	ldd	r24, Y+1	; 0x01
    861a:	97 01       	movw	r18, r14
    861c:	38 27       	eor	r19, r24
    861e:	03 2e       	mov	r0, r19
    8620:	02 94       	swap	r0
    8622:	80 2d       	mov	r24, r0
    8624:	8f 70       	andi	r24, 0x0F	; 15
    8626:	83 27       	eor	r24, r19
    8628:	93 2f       	mov	r25, r19
    862a:	90 25       	eor	r25, r0
    862c:	99 0f       	add	r25, r25
    862e:	90 7e       	andi	r25, 0xE0	; 224
    8630:	89 27       	eor	r24, r25
    8632:	90 2d       	mov	r25, r0
    8634:	93 27       	eor	r25, r19
    8636:	90 7f       	andi	r25, 0xF0	; 240
    8638:	96 95       	lsr	r25
    863a:	03 2e       	mov	r0, r19
    863c:	00 0c       	add	r0, r0
    863e:	99 1f       	adc	r25, r25
    8640:	36 95       	lsr	r19
    8642:	36 95       	lsr	r19
    8644:	36 95       	lsr	r19
    8646:	3f 71       	andi	r19, 0x1F	; 31
    8648:	39 27       	eor	r19, r25
    864a:	32 27       	eor	r19, r18
    864c:	28 2f       	mov	r18, r24
    864e:	79 01       	movw	r14, r18
    }
    crc = _crc_xmodem_update(crc, data);
  }
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
    8650:	11 23       	and	r17, r17
    8652:	09 f0       	breq	.+2      	; 0x8656 <rs485xModemFlash+0x2d0>
    8654:	6d c0       	rjmp	.+218    	; 0x8730 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8656:	ce 01       	movw	r24, r28
    8658:	01 96       	adiw	r24, 0x01	; 1
    865a:	61 e0       	ldi	r22, 0x01	; 1
    865c:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8660:	81 30       	cpi	r24, 0x01	; 1
    8662:	11 f0       	breq	.+4      	; 0x8668 <rs485xModemFlash+0x2e2>
    8664:	17 e0       	ldi	r17, 0x07	; 7
    8666:	04 c0       	rjmp	.+8      	; 0x8670 <rs485xModemFlash+0x2ea>
      blad = 7;
    else
    {
      if (data != 1)
    8668:	89 81       	ldd	r24, Y+1	; 0x01
    866a:	81 30       	cpi	r24, 0x01	; 1
    866c:	09 f0       	breq	.+2      	; 0x8670 <rs485xModemFlash+0x2ea>
    866e:	18 e0       	ldi	r17, 0x08	; 8
    8670:	89 81       	ldd	r24, Y+1	; 0x01
    8672:	a7 01       	movw	r20, r14
    8674:	58 27       	eor	r21, r24
    8676:	05 2e       	mov	r0, r21
    8678:	02 94       	swap	r0
    867a:	80 2d       	mov	r24, r0
    867c:	8f 70       	andi	r24, 0x0F	; 15
    867e:	85 27       	eor	r24, r21
    8680:	95 2f       	mov	r25, r21
    8682:	90 25       	eor	r25, r0
    8684:	99 0f       	add	r25, r25
    8686:	90 7e       	andi	r25, 0xE0	; 224
    8688:	89 27       	eor	r24, r25
    868a:	90 2d       	mov	r25, r0
    868c:	95 27       	eor	r25, r21
    868e:	90 7f       	andi	r25, 0xF0	; 240
    8690:	96 95       	lsr	r25
    8692:	05 2e       	mov	r0, r21
    8694:	00 0c       	add	r0, r0
    8696:	99 1f       	adc	r25, r25
    8698:	56 95       	lsr	r21
    869a:	56 95       	lsr	r21
    869c:	56 95       	lsr	r21
    869e:	5f 71       	andi	r21, 0x1F	; 31
    86a0:	59 27       	eor	r21, r25
    86a2:	54 27       	eor	r21, r20
    86a4:	48 2f       	mov	r20, r24
    86a6:	7a 01       	movw	r14, r20
    }
    crc = _crc_xmodem_update(crc, data);
  }
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
    86a8:	11 23       	and	r17, r17
    86aa:	09 f0       	breq	.+2      	; 0x86ae <rs485xModemFlash+0x328>
    86ac:	41 c0       	rjmp	.+130    	; 0x8730 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    86ae:	ce 01       	movw	r24, r28
    86b0:	01 96       	adiw	r24, 0x01	; 1
    86b2:	61 e0       	ldi	r22, 0x01	; 1
    86b4:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    86b8:	81 30       	cpi	r24, 0x01	; 1
    86ba:	11 f0       	breq	.+4      	; 0x86c0 <rs485xModemFlash+0x33a>
    86bc:	19 e0       	ldi	r17, 0x09	; 9
    86be:	03 c0       	rjmp	.+6      	; 0x86c6 <rs485xModemFlash+0x340>
      blad = 9;
    else
    {
      if (data != devAddr)
    86c0:	89 81       	ldd	r24, Y+1	; 0x01
    86c2:	8b 11       	cpse	r24, r11
    86c4:	1a e0       	ldi	r17, 0x0A	; 10
    86c6:	89 81       	ldd	r24, Y+1	; 0x01
    86c8:	d7 01       	movw	r26, r14
    86ca:	b8 27       	eor	r27, r24
    86cc:	0b 2e       	mov	r0, r27
    86ce:	02 94       	swap	r0
    86d0:	80 2d       	mov	r24, r0
    86d2:	8f 70       	andi	r24, 0x0F	; 15
    86d4:	8b 27       	eor	r24, r27
    86d6:	9b 2f       	mov	r25, r27
    86d8:	90 25       	eor	r25, r0
    86da:	99 0f       	add	r25, r25
    86dc:	90 7e       	andi	r25, 0xE0	; 224
    86de:	89 27       	eor	r24, r25
    86e0:	90 2d       	mov	r25, r0
    86e2:	9b 27       	eor	r25, r27
    86e4:	90 7f       	andi	r25, 0xF0	; 240
    86e6:	96 95       	lsr	r25
    86e8:	0b 2e       	mov	r0, r27
    86ea:	00 0c       	add	r0, r0
    86ec:	99 1f       	adc	r25, r25
    86ee:	b6 95       	lsr	r27
    86f0:	b6 95       	lsr	r27
    86f2:	b6 95       	lsr	r27
    86f4:	bf 71       	andi	r27, 0x1F	; 31
    86f6:	b9 27       	eor	r27, r25
    86f8:	ba 27       	eor	r27, r26
    86fa:	a8 2f       	mov	r26, r24
    86fc:	7d 01       	movw	r14, r26
    }
    crc = _crc_xmodem_update(crc, data);
  }
   
  //Odbieranie CRC Hi
  if (blad == 0)
    86fe:	11 23       	and	r17, r17
    8700:	b9 f4       	brne	.+46     	; 0x8730 <rs485xModemFlash+0x3aa>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    8702:	8e 01       	movw	r16, r28
    8704:	0e 5f       	subi	r16, 0xFE	; 254
    8706:	1f 4f       	sbci	r17, 0xFF	; 255
    8708:	c8 01       	movw	r24, r16
    870a:	61 e0       	ldi	r22, 0x01	; 1
    870c:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8710:	81 30       	cpi	r24, 0x01	; 1
    8712:	71 f4       	brne	.+28     	; 0x8730 <rs485xModemFlash+0x3aa>
      blad = 11;
    else
    {
      if ((uint8_t)(crc>>8) != nrBloku)
    8714:	8a 81       	ldd	r24, Y+2	; 0x02
    8716:	8f 15       	cp	r24, r15
    8718:	59 f4       	brne	.+22     	; 0x8730 <rs485xModemFlash+0x3aa>
  }
   
  //Odbieranie CRC Lo
  if (blad == 0)
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    871a:	c8 01       	movw	r24, r16
    871c:	61 e0       	ldi	r22, 0x01	; 1
    871e:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8722:	a8 2e       	mov	r10, r24
    8724:	b1 e0       	ldi	r27, 0x01	; 1
    8726:	8b 17       	cp	r24, r27
    8728:	19 f4       	brne	.+6      	; 0x8730 <rs485xModemFlash+0x3aa>
      blad = 13;
    else
    {
      if ((uint8_t)(crc & 0xFF) != nrBloku)
    872a:	8a 81       	ldd	r24, Y+2	; 0x02
    872c:	8e 15       	cp	r24, r14
    872e:	29 f0       	breq	.+10     	; 0x873a <rs485xModemFlash+0x3b4>
    }    
  }
   
  if ((blad != 0) && (blad != 253))
  {
    releaseRs485();
    8730:	0e 94 b4 0b 	call	0x1768	; 0x1768 <releaseRs485>
    flushRs485RecBuffer();  
    8734:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <flushRs485RecBuffer>
    8738:	78 c1       	rjmp	.+752    	; 0x8a2a <rs485xModemFlash+0x6a4>
  }

// Wysyłanie polecenia do bootloadera
  if (blad == 0)
  {
    vTaskDelay(100);
    873a:	84 e6       	ldi	r24, 0x64	; 100
    873c:	90 e0       	ldi	r25, 0x00	; 0
    873e:	0e 94 ce 4d 	call	0x9b9c	; 0x9b9c <vTaskDelay>
    8742:	00 e0       	ldi	r16, 0x00	; 0
    8744:	10 e0       	ldi	r17, 0x00	; 0
    8746:	8a e5       	ldi	r24, 0x5A	; 90
    8748:	18 27       	eor	r17, r24
    874a:	01 2e       	mov	r0, r17
    874c:	02 94       	swap	r0
    874e:	80 2d       	mov	r24, r0
    8750:	8f 70       	andi	r24, 0x0F	; 15
    8752:	81 27       	eor	r24, r17
    8754:	91 2f       	mov	r25, r17
    8756:	90 25       	eor	r25, r0
    8758:	99 0f       	add	r25, r25
    875a:	90 7e       	andi	r25, 0xE0	; 224
    875c:	89 27       	eor	r24, r25
    875e:	90 2d       	mov	r25, r0
    8760:	91 27       	eor	r25, r17
    8762:	90 7f       	andi	r25, 0xF0	; 240
    8764:	96 95       	lsr	r25
    8766:	01 2e       	mov	r0, r17
    8768:	00 0c       	add	r0, r0
    876a:	99 1f       	adc	r25, r25
    876c:	16 95       	lsr	r17
    876e:	16 95       	lsr	r17
    8770:	16 95       	lsr	r17
    8772:	1f 71       	andi	r17, 0x1F	; 31
    8774:	19 27       	eor	r17, r25
    8776:	10 27       	eor	r17, r16
    8778:	08 2f       	mov	r16, r24
     
    crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    877a:	8a e5       	ldi	r24, 0x5A	; 90
    877c:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8780:	1b 25       	eor	r17, r11
    8782:	01 2e       	mov	r0, r17
    8784:	02 94       	swap	r0
    8786:	80 2d       	mov	r24, r0
    8788:	8f 70       	andi	r24, 0x0F	; 15
    878a:	81 27       	eor	r24, r17
    878c:	91 2f       	mov	r25, r17
    878e:	90 25       	eor	r25, r0
    8790:	99 0f       	add	r25, r25
    8792:	90 7e       	andi	r25, 0xE0	; 224
    8794:	89 27       	eor	r24, r25
    8796:	90 2d       	mov	r25, r0
    8798:	91 27       	eor	r25, r17
    879a:	90 7f       	andi	r25, 0xF0	; 240
    879c:	96 95       	lsr	r25
    879e:	01 2e       	mov	r0, r17
    87a0:	00 0c       	add	r0, r0
    87a2:	99 1f       	adc	r25, r25
    87a4:	16 95       	lsr	r17
    87a6:	16 95       	lsr	r17
    87a8:	16 95       	lsr	r17
    87aa:	1f 71       	andi	r17, 0x1F	; 31
    87ac:	19 27       	eor	r17, r25
    87ae:	10 27       	eor	r17, r16
    87b0:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    87b2:	8b 2d       	mov	r24, r11
    87b4:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    87b8:	81 e8       	ldi	r24, 0x81	; 129
    87ba:	18 27       	eor	r17, r24
    87bc:	01 2e       	mov	r0, r17
    87be:	02 94       	swap	r0
    87c0:	80 2d       	mov	r24, r0
    87c2:	8f 70       	andi	r24, 0x0F	; 15
    87c4:	81 27       	eor	r24, r17
    87c6:	91 2f       	mov	r25, r17
    87c8:	90 25       	eor	r25, r0
    87ca:	99 0f       	add	r25, r25
    87cc:	90 7e       	andi	r25, 0xE0	; 224
    87ce:	89 27       	eor	r24, r25
    87d0:	90 2d       	mov	r25, r0
    87d2:	91 27       	eor	r25, r17
    87d4:	90 7f       	andi	r25, 0xF0	; 240
    87d6:	96 95       	lsr	r25
    87d8:	01 2e       	mov	r0, r17
    87da:	00 0c       	add	r0, r0
    87dc:	99 1f       	adc	r25, r25
    87de:	16 95       	lsr	r17
    87e0:	16 95       	lsr	r17
    87e2:	16 95       	lsr	r17
    87e4:	1f 71       	andi	r17, 0x1F	; 31
    87e6:	19 27       	eor	r17, r25
    87e8:	10 27       	eor	r17, r16
    87ea:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    87ec:	81 e8       	ldi	r24, 0x81	; 129
    87ee:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    87f2:	1a 25       	eor	r17, r10
    87f4:	01 2e       	mov	r0, r17
    87f6:	02 94       	swap	r0
    87f8:	80 2d       	mov	r24, r0
    87fa:	8f 70       	andi	r24, 0x0F	; 15
    87fc:	81 27       	eor	r24, r17
    87fe:	91 2f       	mov	r25, r17
    8800:	90 25       	eor	r25, r0
    8802:	99 0f       	add	r25, r25
    8804:	90 7e       	andi	r25, 0xE0	; 224
    8806:	89 27       	eor	r24, r25
    8808:	90 2d       	mov	r25, r0
    880a:	91 27       	eor	r25, r17
    880c:	90 7f       	andi	r25, 0xF0	; 240
    880e:	96 95       	lsr	r25
    8810:	01 2e       	mov	r0, r17
    8812:	00 0c       	add	r0, r0
    8814:	99 1f       	adc	r25, r25
    8816:	16 95       	lsr	r17
    8818:	16 95       	lsr	r17
    881a:	16 95       	lsr	r17
    881c:	1f 71       	andi	r17, 0x1F	; 31
    881e:	19 27       	eor	r17, r25
    8820:	10 27       	eor	r17, r16
    8822:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    8824:	81 e0       	ldi	r24, 0x01	; 1
    8826:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    882a:	1b 25       	eor	r17, r11
    882c:	01 2e       	mov	r0, r17
    882e:	02 94       	swap	r0
    8830:	80 2d       	mov	r24, r0
    8832:	8f 70       	andi	r24, 0x0F	; 15
    8834:	81 27       	eor	r24, r17
    8836:	91 2f       	mov	r25, r17
    8838:	90 25       	eor	r25, r0
    883a:	99 0f       	add	r25, r25
    883c:	90 7e       	andi	r25, 0xE0	; 224
    883e:	89 27       	eor	r24, r25
    8840:	90 2d       	mov	r25, r0
    8842:	91 27       	eor	r25, r17
    8844:	90 7f       	andi	r25, 0xF0	; 240
    8846:	96 95       	lsr	r25
    8848:	01 2e       	mov	r0, r17
    884a:	00 0c       	add	r0, r0
    884c:	99 1f       	adc	r25, r25
    884e:	16 95       	lsr	r17
    8850:	16 95       	lsr	r17
    8852:	16 95       	lsr	r17
    8854:	1f 71       	andi	r17, 0x1F	; 31
    8856:	19 27       	eor	r17, r25
    8858:	10 27       	eor	r17, r16
    885a:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    885c:	8b 2d       	mov	r24, r11
    885e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc>>8));
    8862:	81 2f       	mov	r24, r17
    8864:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    8868:	80 2f       	mov	r24, r16
    886a:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
 
    //Odbieranie odpowiedzi od Bootloadera
    if(rs485Receive(&data, 150) != pdTRUE)
    886e:	ce 01       	movw	r24, r28
    8870:	01 96       	adiw	r24, 0x01	; 1
    8872:	66 e9       	ldi	r22, 0x96	; 150
    8874:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
      blad = 15;

    if (data != 'C')
    8878:	89 81       	ldd	r24, Y+1	; 0x01
    887a:	83 34       	cpi	r24, 0x43	; 67
    887c:	09 f0       	breq	.+2      	; 0x8880 <rs485xModemFlash+0x4fa>
    887e:	cd c0       	rjmp	.+410    	; 0x8a1a <rs485xModemFlash+0x694>
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
    8880:	d3 01       	movw	r26, r6
    8882:	14 96       	adiw	r26, 0x04	; 4
    8884:	ed 91       	ld	r30, X+
    8886:	fc 91       	ld	r31, X
    8888:	15 97       	sbiw	r26, 0x05	; 5
    888a:	b2 80       	ldd	r11, Z+2	; 0x02
    888c:	bb 0c       	add	r11, r11
  if (file->wpis->rozmiarLo == 128)
    888e:	81 81       	ldd	r24, Z+1	; 0x01
    8890:	80 38       	cpi	r24, 0x80	; 128
    8892:	a1 f4       	brne	.+40     	; 0x88bc <rs485xModemFlash+0x536>
    8894:	12 c0       	rjmp	.+36     	; 0x88ba <rs485xModemFlash+0x534>
  if (blad != 0)
  {
    releaseRs485();
    flushRs485RecBuffer();  
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    8896:	00 d0       	rcall	.+0      	; 0x8898 <rs485xModemFlash+0x512>
    8898:	00 d0       	rcall	.+0      	; 0x889a <rs485xModemFlash+0x514>
    889a:	ed b7       	in	r30, 0x3d	; 61
    889c:	fe b7       	in	r31, 0x3e	; 62
    889e:	d2 82       	std	Z+2, r13	; 0x02
    88a0:	c1 82       	std	Z+1, r12	; 0x01
    88a2:	8e e3       	ldi	r24, 0x3E	; 62
    88a4:	93 e1       	ldi	r25, 0x13	; 19
    88a6:	94 83       	std	Z+4, r25	; 0x04
    88a8:	83 83       	std	Z+3, r24	; 0x03
    88aa:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    88ae:	81 e0       	ldi	r24, 0x01	; 1
    88b0:	0f 90       	pop	r0
    88b2:	0f 90       	pop	r0
    88b4:	0f 90       	pop	r0
    88b6:	0f 90       	pop	r0
    88b8:	9f c0       	rjmp	.+318    	; 0x89f8 <rs485xModemFlash+0x672>
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
  if (file->wpis->rozmiarLo == 128)
    liczbaBlokow++;
    88ba:	b3 94       	inc	r11
   
  nrBloku = 1;
    88bc:	81 e0       	ldi	r24, 0x01	; 1
    88be:	8a 83       	std	Y+2, r24	; 0x02
    88c0:	ff 24       	eor	r15, r15
    88c2:	ee 24       	eor	r14, r14
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    88c4:	4e 01       	movw	r8, r28
    88c6:	08 94       	sec
    88c8:	81 1c       	adc	r8, r1
    88ca:	91 1c       	adc	r9, r1
    88cc:	5d c0       	rjmp	.+186    	; 0x8988 <rs485xModemFlash+0x602>
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
  {
    if (debugStr != NULL)
    88ce:	c1 14       	cp	r12, r1
    88d0:	d1 04       	cpc	r13, r1
    88d2:	29 f0       	breq	.+10     	; 0x88de <rs485xModemFlash+0x558>
      fputc('#', debugStr);
    88d4:	83 e2       	ldi	r24, 0x23	; 35
    88d6:	90 e0       	ldi	r25, 0x00	; 0
    88d8:	b6 01       	movw	r22, r12
    88da:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    crc = 0;
    uartRs485SendByte(SOH);
    88de:	81 e0       	ldi	r24, 0x01	; 1
    88e0:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    uartRs485SendByte(nrBloku);
    88e4:	8a 81       	ldd	r24, Y+2	; 0x02
    88e6:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    data = (uint8_t)(~nrBloku);
    88ea:	8a 81       	ldd	r24, Y+2	; 0x02
    88ec:	80 95       	com	r24
    88ee:	89 83       	std	Y+1, r24	; 0x01
    uartRs485SendByte(data);
    88f0:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    88f4:	ff 24       	eor	r15, r15
    88f6:	00 e0       	ldi	r16, 0x00	; 0
    88f8:	10 e0       	ldi	r17, 0x00	; 0
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    88fa:	c3 01       	movw	r24, r6
    88fc:	b4 01       	movw	r22, r8
    88fe:	0e 94 16 1e 	call	0x3c2c	; 0x3c2c <ramDyskCzytajBajtZPliku>
    8902:	81 11       	cpse	r24, r1
        data = 0;
    8904:	19 82       	std	Y+1, r1	; 0x01
      crc = _crc_xmodem_update(crc, data);
    8906:	89 81       	ldd	r24, Y+1	; 0x01
    8908:	18 27       	eor	r17, r24
    890a:	01 2e       	mov	r0, r17
    890c:	02 94       	swap	r0
    890e:	90 2d       	mov	r25, r0
    8910:	9f 70       	andi	r25, 0x0F	; 15
    8912:	91 27       	eor	r25, r17
    8914:	21 2f       	mov	r18, r17
    8916:	20 25       	eor	r18, r0
    8918:	22 0f       	add	r18, r18
    891a:	20 7e       	andi	r18, 0xE0	; 224
    891c:	92 27       	eor	r25, r18
    891e:	20 2d       	mov	r18, r0
    8920:	21 27       	eor	r18, r17
    8922:	20 7f       	andi	r18, 0xF0	; 240
    8924:	26 95       	lsr	r18
    8926:	01 2e       	mov	r0, r17
    8928:	00 0c       	add	r0, r0
    892a:	22 1f       	adc	r18, r18
    892c:	16 95       	lsr	r17
    892e:	16 95       	lsr	r17
    8930:	16 95       	lsr	r17
    8932:	1f 71       	andi	r17, 0x1F	; 31
    8934:	12 27       	eor	r17, r18
    8936:	10 27       	eor	r17, r16
    8938:	09 2f       	mov	r16, r25
      uartRs485SendByte(data);
    893a:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    uartRs485SendByte(SOH);
    uartRs485SendByte(nrBloku);
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    893e:	f3 94       	inc	r15
    8940:	f0 e8       	ldi	r31, 0x80	; 128
    8942:	ff 16       	cp	r15, r31
    8944:	09 f0       	breq	.+2      	; 0x8948 <rs485xModemFlash+0x5c2>
    8946:	d9 cf       	rjmp	.-78     	; 0x88fa <rs485xModemFlash+0x574>
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
        data = 0;
      crc = _crc_xmodem_update(crc, data);
      uartRs485SendByte(data);
    }
    uartRs485SendByte((uint8_t)(crc>>8));
    8948:	81 2f       	mov	r24, r17
    894a:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    894e:	80 2f       	mov	r24, r16
    8950:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
 
    if(rs485Receive(&data, 100) != pdTRUE)
    8954:	c4 01       	movw	r24, r8
    8956:	64 e6       	ldi	r22, 0x64	; 100
    8958:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    895c:	81 30       	cpi	r24, 0x01	; 1
    895e:	11 f0       	breq	.+4      	; 0x8964 <rs485xModemFlash+0x5de>
    8960:	3a ef       	ldi	r19, 0xFA	; 250
    8962:	f3 2e       	mov	r15, r19
    {
      blad = 250;
    }
     
    flushRs485RecBuffer();
    8964:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <flushRs485RecBuffer>

    if (data == ACK)
    8968:	89 81       	ldd	r24, Y+1	; 0x01
    896a:	86 30       	cpi	r24, 0x06	; 6
    896c:	29 f4       	brne	.+10     	; 0x8978 <rs485xModemFlash+0x5f2>
    {
      nrBloku ++;
    896e:	8a 81       	ldd	r24, Y+2	; 0x02
    8970:	8f 5f       	subi	r24, 0xFF	; 255
    8972:	8a 83       	std	Y+2, r24	; 0x02
    8974:	ee 24       	eor	r14, r14
    8976:	08 c0       	rjmp	.+16     	; 0x8988 <rs485xModemFlash+0x602>
      lRetransmisji = 0;
      continue;
    }
 
    if (data == CAN)
    8978:	88 31       	cpi	r24, 0x18	; 24
    897a:	11 f4       	brne	.+4      	; 0x8980 <rs485xModemFlash+0x5fa>
    897c:	29 ef       	ldi	r18, 0xF9	; 249
    897e:	f2 2e       	mov	r15, r18
      blad = 249;
 
    lRetransmisji ++;
    8980:	e3 94       	inc	r14
     
    if (lRetransmisji == 3)
    8982:	23 e0       	ldi	r18, 0x03	; 3
    8984:	e2 16       	cp	r14, r18
    8986:	e1 f0       	breq	.+56     	; 0x89c0 <rs485xModemFlash+0x63a>
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    8988:	8a 81       	ldd	r24, Y+2	; 0x02
    898a:	b8 16       	cp	r11, r24
    898c:	08 f0       	brcs	.+2      	; 0x8990 <rs485xModemFlash+0x60a>
    898e:	9f cf       	rjmp	.-194    	; 0x88ce <rs485xModemFlash+0x548>
      blad = 249;
      break;
    }
  }
 
  if (blad == 0)
    8990:	ff 20       	and	r15, r15
    8992:	b1 f4       	brne	.+44     	; 0x89c0 <rs485xModemFlash+0x63a>
  {
    uartRs485SendByte(EOT); 
    8994:	84 e0       	ldi	r24, 0x04	; 4
    8996:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    if(rs485Receive(&data, 25) == pdTRUE)
    899a:	8e 01       	movw	r16, r28
    899c:	0f 5f       	subi	r16, 0xFF	; 255
    899e:	1f 4f       	sbci	r17, 0xFF	; 255
    89a0:	c8 01       	movw	r24, r16
    89a2:	69 e1       	ldi	r22, 0x19	; 25
    89a4:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    89a8:	81 30       	cpi	r24, 0x01	; 1
    89aa:	51 f4       	brne	.+20     	; 0x89c0 <rs485xModemFlash+0x63a>
    {
      if (data == ACK)
    89ac:	89 81       	ldd	r24, Y+1	; 0x01
    89ae:	86 30       	cpi	r24, 0x06	; 6
    89b0:	39 f4       	brne	.+14     	; 0x89c0 <rs485xModemFlash+0x63a>
      {
        uartRs485SendByte(EOT);
    89b2:	84 e0       	ldi	r24, 0x04	; 4
    89b4:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
        rs485Receive(&data, 25);
    89b8:	c8 01       	movw	r24, r16
    89ba:	69 e1       	ldi	r22, 0x19	; 25
    89bc:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
      }
    }
  }
  if (debugStr != NULL)
    89c0:	c1 14       	cp	r12, r1
    89c2:	d1 04       	cpc	r13, r1
    89c4:	a1 f0       	breq	.+40     	; 0x89ee <rs485xModemFlash+0x668>
    fprintf_P(debugStr, PSTR("\r\nOK\r\n"));
    89c6:	00 d0       	rcall	.+0      	; 0x89c8 <rs485xModemFlash+0x642>
    89c8:	00 d0       	rcall	.+0      	; 0x89ca <rs485xModemFlash+0x644>
    89ca:	ad b7       	in	r26, 0x3d	; 61
    89cc:	be b7       	in	r27, 0x3e	; 62
    89ce:	12 96       	adiw	r26, 0x02	; 2
    89d0:	dc 92       	st	X, r13
    89d2:	ce 92       	st	-X, r12
    89d4:	11 97       	sbiw	r26, 0x01	; 1
    89d6:	87 e3       	ldi	r24, 0x37	; 55
    89d8:	93 e1       	ldi	r25, 0x13	; 19
    89da:	14 96       	adiw	r26, 0x04	; 4
    89dc:	9c 93       	st	X, r25
    89de:	8e 93       	st	-X, r24
    89e0:	13 97       	sbiw	r26, 0x03	; 3
    89e2:	0e 94 02 5a 	call	0xb404	; 0xb404 <fprintf_P>
    89e6:	0f 90       	pop	r0
    89e8:	0f 90       	pop	r0
    89ea:	0f 90       	pop	r0
    89ec:	0f 90       	pop	r0

  flushRs485RecBuffer();  
    89ee:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <flushRs485RecBuffer>
  releaseRs485();
    89f2:	0e 94 b4 0b 	call	0x1768	; 0x1768 <releaseRs485>
    89f6:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    89f8:	0f 90       	pop	r0
    89fa:	0f 90       	pop	r0
    89fc:	cf 91       	pop	r28
    89fe:	df 91       	pop	r29
    8a00:	1f 91       	pop	r17
    8a02:	0f 91       	pop	r16
    8a04:	ff 90       	pop	r15
    8a06:	ef 90       	pop	r14
    8a08:	df 90       	pop	r13
    8a0a:	cf 90       	pop	r12
    8a0c:	bf 90       	pop	r11
    8a0e:	af 90       	pop	r10
    8a10:	9f 90       	pop	r9
    8a12:	8f 90       	pop	r8
    8a14:	7f 90       	pop	r7
    8a16:	6f 90       	pop	r6
    8a18:	08 95       	ret
    blad = 0;
  
   
  if (blad != 0)
  {
    releaseRs485();
    8a1a:	0e 94 b4 0b 	call	0x1768	; 0x1768 <releaseRs485>
    flushRs485RecBuffer();  
    8a1e:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <flushRs485RecBuffer>
    if (debugStr != NULL)
    8a22:	c1 14       	cp	r12, r1
    8a24:	d1 04       	cpc	r13, r1
    8a26:	09 f0       	breq	.+2      	; 0x8a2a <rs485xModemFlash+0x6a4>
    8a28:	36 cf       	rjmp	.-404    	; 0x8896 <rs485xModemFlash+0x510>
    8a2a:	81 e0       	ldi	r24, 0x01	; 1
    8a2c:	e5 cf       	rjmp	.-54     	; 0x89f8 <rs485xModemFlash+0x672>

00008a2e <rs485ping>:
  return result;
}
#endif /*PRINT_RS485_DEVICE*/

uint8_t rs485ping(uint8_t devAddr)
{
    8a2e:	bf 92       	push	r11
    8a30:	cf 92       	push	r12
    8a32:	df 92       	push	r13
    8a34:	ef 92       	push	r14
    8a36:	ff 92       	push	r15
    8a38:	0f 93       	push	r16
    8a3a:	1f 93       	push	r17
    8a3c:	df 93       	push	r29
    8a3e:	cf 93       	push	r28
    8a40:	00 d0       	rcall	.+0      	; 0x8a42 <rs485ping+0x14>
    8a42:	0f 92       	push	r0
    8a44:	cd b7       	in	r28, 0x3d	; 61
    8a46:	de b7       	in	r29, 0x3e	; 62
    8a48:	18 2f       	mov	r17, r24
  takeRs485();
    8a4a:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <takeRs485>
    8a4e:	ee 24       	eor	r14, r14
    8a50:	ff 24       	eor	r15, r15
    8a52:	8a e5       	ldi	r24, 0x5A	; 90
    8a54:	97 01       	movw	r18, r14
    8a56:	38 27       	eor	r19, r24
    8a58:	03 2e       	mov	r0, r19
    8a5a:	02 94       	swap	r0
    8a5c:	90 2d       	mov	r25, r0
    8a5e:	9f 70       	andi	r25, 0x0F	; 15
    8a60:	93 27       	eor	r25, r19
    8a62:	83 2f       	mov	r24, r19
    8a64:	80 25       	eor	r24, r0
    8a66:	88 0f       	add	r24, r24
    8a68:	80 7e       	andi	r24, 0xE0	; 224
    8a6a:	98 27       	eor	r25, r24
    8a6c:	80 2d       	mov	r24, r0
    8a6e:	83 27       	eor	r24, r19
    8a70:	80 7f       	andi	r24, 0xF0	; 240
    8a72:	86 95       	lsr	r24
    8a74:	03 2e       	mov	r0, r19
    8a76:	00 0c       	add	r0, r0
    8a78:	88 1f       	adc	r24, r24
    8a7a:	36 95       	lsr	r19
    8a7c:	36 95       	lsr	r19
    8a7e:	36 95       	lsr	r19
    8a80:	3f 71       	andi	r19, 0x1F	; 31
    8a82:	38 27       	eor	r19, r24
    8a84:	32 27       	eor	r19, r18
    8a86:	29 2f       	mov	r18, r25
    8a88:	79 01       	movw	r14, r18

// ********************* Hiden Functions ***************************************************
void sendPing(uint8_t addr, uint8_t pingLen)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
  uartRs485SendByte(SYNC);
    8a8a:	8a e5       	ldi	r24, 0x5A	; 90
    8a8c:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8a90:	97 01       	movw	r18, r14
    8a92:	31 27       	eor	r19, r17
    8a94:	03 2e       	mov	r0, r19
    8a96:	02 94       	swap	r0
    8a98:	90 2d       	mov	r25, r0
    8a9a:	9f 70       	andi	r25, 0x0F	; 15
    8a9c:	93 27       	eor	r25, r19
    8a9e:	83 2f       	mov	r24, r19
    8aa0:	80 25       	eor	r24, r0
    8aa2:	88 0f       	add	r24, r24
    8aa4:	80 7e       	andi	r24, 0xE0	; 224
    8aa6:	98 27       	eor	r25, r24
    8aa8:	80 2d       	mov	r24, r0
    8aaa:	83 27       	eor	r24, r19
    8aac:	80 7f       	andi	r24, 0xF0	; 240
    8aae:	86 95       	lsr	r24
    8ab0:	03 2e       	mov	r0, r19
    8ab2:	00 0c       	add	r0, r0
    8ab4:	88 1f       	adc	r24, r24
    8ab6:	36 95       	lsr	r19
    8ab8:	36 95       	lsr	r19
    8aba:	36 95       	lsr	r19
    8abc:	3f 71       	andi	r19, 0x1F	; 31
    8abe:	38 27       	eor	r19, r24
    8ac0:	32 27       	eor	r19, r18
    8ac2:	29 2f       	mov	r18, r25
    8ac4:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, addr);
  uartRs485SendByte(addr);
    8ac6:	81 2f       	mov	r24, r17
    8ac8:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8acc:	80 e8       	ldi	r24, 0x80	; 128
    8ace:	97 01       	movw	r18, r14
    8ad0:	38 27       	eor	r19, r24
    8ad2:	03 2e       	mov	r0, r19
    8ad4:	02 94       	swap	r0
    8ad6:	90 2d       	mov	r25, r0
    8ad8:	9f 70       	andi	r25, 0x0F	; 15
    8ada:	93 27       	eor	r25, r19
    8adc:	83 2f       	mov	r24, r19
    8ade:	80 25       	eor	r24, r0
    8ae0:	88 0f       	add	r24, r24
    8ae2:	80 7e       	andi	r24, 0xE0	; 224
    8ae4:	98 27       	eor	r25, r24
    8ae6:	80 2d       	mov	r24, r0
    8ae8:	83 27       	eor	r24, r19
    8aea:	80 7f       	andi	r24, 0xF0	; 240
    8aec:	86 95       	lsr	r24
    8aee:	03 2e       	mov	r0, r19
    8af0:	00 0c       	add	r0, r0
    8af2:	88 1f       	adc	r24, r24
    8af4:	36 95       	lsr	r19
    8af6:	36 95       	lsr	r19
    8af8:	36 95       	lsr	r19
    8afa:	3f 71       	andi	r19, 0x1F	; 31
    8afc:	38 27       	eor	r19, r24
    8afe:	32 27       	eor	r19, r18
    8b00:	29 2f       	mov	r18, r25
    8b02:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, rPING);
  uartRs485SendByte(rPING);
    8b04:	80 e8       	ldi	r24, 0x80	; 128
    8b06:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8b0a:	88 e0       	ldi	r24, 0x08	; 8
    8b0c:	97 01       	movw	r18, r14
    8b0e:	38 27       	eor	r19, r24
    8b10:	03 2e       	mov	r0, r19
    8b12:	02 94       	swap	r0
    8b14:	90 2d       	mov	r25, r0
    8b16:	9f 70       	andi	r25, 0x0F	; 15
    8b18:	93 27       	eor	r25, r19
    8b1a:	83 2f       	mov	r24, r19
    8b1c:	80 25       	eor	r24, r0
    8b1e:	88 0f       	add	r24, r24
    8b20:	80 7e       	andi	r24, 0xE0	; 224
    8b22:	98 27       	eor	r25, r24
    8b24:	80 2d       	mov	r24, r0
    8b26:	83 27       	eor	r24, r19
    8b28:	80 7f       	andi	r24, 0xF0	; 240
    8b2a:	86 95       	lsr	r24
    8b2c:	03 2e       	mov	r0, r19
    8b2e:	00 0c       	add	r0, r0
    8b30:	88 1f       	adc	r24, r24
    8b32:	36 95       	lsr	r19
    8b34:	36 95       	lsr	r19
    8b36:	36 95       	lsr	r19
    8b38:	3f 71       	andi	r19, 0x1F	; 31
    8b3a:	38 27       	eor	r19, r24
    8b3c:	32 27       	eor	r19, r18
    8b3e:	29 2f       	mov	r18, r25
    8b40:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
    8b42:	88 e0       	ldi	r24, 0x08	; 8
    8b44:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8b48:	bb 24       	eor	r11, r11
    8b4a:	97 01       	movw	r18, r14
    8b4c:	3b 25       	eor	r19, r11
    8b4e:	03 2e       	mov	r0, r19
    8b50:	02 94       	swap	r0
    8b52:	90 2d       	mov	r25, r0
    8b54:	9f 70       	andi	r25, 0x0F	; 15
    8b56:	93 27       	eor	r25, r19
    8b58:	83 2f       	mov	r24, r19
    8b5a:	80 25       	eor	r24, r0
    8b5c:	88 0f       	add	r24, r24
    8b5e:	80 7e       	andi	r24, 0xE0	; 224
    8b60:	98 27       	eor	r25, r24
    8b62:	80 2d       	mov	r24, r0
    8b64:	83 27       	eor	r24, r19
    8b66:	80 7f       	andi	r24, 0xF0	; 240
    8b68:	86 95       	lsr	r24
    8b6a:	03 2e       	mov	r0, r19
    8b6c:	00 0c       	add	r0, r0
    8b6e:	88 1f       	adc	r24, r24
    8b70:	36 95       	lsr	r19
    8b72:	36 95       	lsr	r19
    8b74:	36 95       	lsr	r19
    8b76:	3f 71       	andi	r19, 0x1F	; 31
    8b78:	38 27       	eor	r19, r24
    8b7a:	32 27       	eor	r19, r18
    8b7c:	29 2f       	mov	r18, r25
    8b7e:	79 01       	movw	r14, r18
  
  for (uint8_t i=0; i < pingLen; i++)
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
    8b80:	8b 2d       	mov	r24, r11
    8b82:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  uartRs485SendByte(rPING);

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
  
  for (uint8_t i=0; i < pingLen; i++)
    8b86:	b3 94       	inc	r11
    8b88:	38 e0       	ldi	r19, 0x08	; 8
    8b8a:	b3 16       	cp	r11, r19
    8b8c:	f1 f6       	brne	.-68     	; 0x8b4a <rs485ping+0x11c>
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
  }
  uartRs485SendByte((uint8_t)(crc >> 8));
    8b8e:	8f 2d       	mov	r24, r15
    8b90:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8b94:	8e 2d       	mov	r24, r14
    8b96:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  addr = 0;
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    8b9a:	6e 01       	movw	r12, r28
    8b9c:	08 94       	sec
    8b9e:	c1 1c       	adc	r12, r1
    8ba0:	d1 1c       	adc	r13, r1
    8ba2:	c6 01       	movw	r24, r12
    8ba4:	64 e1       	ldi	r22, 0x14	; 20
    8ba6:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8baa:	88 23       	and	r24, r24
    8bac:	11 f4       	brne	.+4      	; 0x8bb2 <rs485ping+0x184>
    8bae:	11 e0       	ldi	r17, 0x01	; 1
    8bb0:	ee c0       	rjmp	.+476    	; 0x8d8e <rs485ping+0x360>
    return 1;
  
  if (data != SYNC)
    8bb2:	89 81       	ldd	r24, Y+1	; 0x01
    8bb4:	8a 35       	cpi	r24, 0x5A	; 90
    8bb6:	11 f0       	breq	.+4      	; 0x8bbc <rs485ping+0x18e>
    8bb8:	12 e0       	ldi	r17, 0x02	; 2
    8bba:	e9 c0       	rjmp	.+466    	; 0x8d8e <rs485ping+0x360>
    8bbc:	00 e0       	ldi	r16, 0x00	; 0
    8bbe:	10 e0       	ldi	r17, 0x00	; 0
    8bc0:	18 27       	eor	r17, r24
    8bc2:	01 2e       	mov	r0, r17
    8bc4:	02 94       	swap	r0
    8bc6:	90 2d       	mov	r25, r0
    8bc8:	9f 70       	andi	r25, 0x0F	; 15
    8bca:	91 27       	eor	r25, r17
    8bcc:	81 2f       	mov	r24, r17
    8bce:	80 25       	eor	r24, r0
    8bd0:	88 0f       	add	r24, r24
    8bd2:	80 7e       	andi	r24, 0xE0	; 224
    8bd4:	98 27       	eor	r25, r24
    8bd6:	80 2d       	mov	r24, r0
    8bd8:	81 27       	eor	r24, r17
    8bda:	80 7f       	andi	r24, 0xF0	; 240
    8bdc:	86 95       	lsr	r24
    8bde:	01 2e       	mov	r0, r17
    8be0:	00 0c       	add	r0, r0
    8be2:	88 1f       	adc	r24, r24
    8be4:	16 95       	lsr	r17
    8be6:	16 95       	lsr	r17
    8be8:	16 95       	lsr	r17
    8bea:	1f 71       	andi	r17, 0x1F	; 31
    8bec:	18 27       	eor	r17, r24
    8bee:	10 27       	eor	r17, r16
    8bf0:	09 2f       	mov	r16, r25
    return 2;
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    8bf2:	c6 01       	movw	r24, r12
    8bf4:	61 e0       	ldi	r22, 0x01	; 1
    8bf6:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8bfa:	88 23       	and	r24, r24
    8bfc:	11 f4       	brne	.+4      	; 0x8c02 <rs485ping+0x1d4>
    8bfe:	13 e0       	ldi	r17, 0x03	; 3
    8c00:	c6 c0       	rjmp	.+396    	; 0x8d8e <rs485ping+0x360>
    return 3;

  if (data != 0)
    8c02:	89 81       	ldd	r24, Y+1	; 0x01
    8c04:	88 23       	and	r24, r24
    8c06:	11 f0       	breq	.+4      	; 0x8c0c <rs485ping+0x1de>
    8c08:	14 e0       	ldi	r17, 0x04	; 4
    8c0a:	c1 c0       	rjmp	.+386    	; 0x8d8e <rs485ping+0x360>
    8c0c:	18 27       	eor	r17, r24
    8c0e:	01 2e       	mov	r0, r17
    8c10:	02 94       	swap	r0
    8c12:	90 2d       	mov	r25, r0
    8c14:	9f 70       	andi	r25, 0x0F	; 15
    8c16:	91 27       	eor	r25, r17
    8c18:	81 2f       	mov	r24, r17
    8c1a:	80 25       	eor	r24, r0
    8c1c:	88 0f       	add	r24, r24
    8c1e:	80 7e       	andi	r24, 0xE0	; 224
    8c20:	98 27       	eor	r25, r24
    8c22:	80 2d       	mov	r24, r0
    8c24:	81 27       	eor	r24, r17
    8c26:	80 7f       	andi	r24, 0xF0	; 240
    8c28:	86 95       	lsr	r24
    8c2a:	01 2e       	mov	r0, r17
    8c2c:	00 0c       	add	r0, r0
    8c2e:	88 1f       	adc	r24, r24
    8c30:	16 95       	lsr	r17
    8c32:	16 95       	lsr	r17
    8c34:	16 95       	lsr	r17
    8c36:	1f 71       	andi	r17, 0x1F	; 31
    8c38:	18 27       	eor	r17, r24
    8c3a:	10 27       	eor	r17, r16
    8c3c:	09 2f       	mov	r16, r25
    return 4;
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    8c3e:	c6 01       	movw	r24, r12
    8c40:	61 e0       	ldi	r22, 0x01	; 1
    8c42:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8c46:	88 23       	and	r24, r24
    8c48:	11 f4       	brne	.+4      	; 0x8c4e <rs485ping+0x220>
    8c4a:	15 e0       	ldi	r17, 0x05	; 5
    8c4c:	a0 c0       	rjmp	.+320    	; 0x8d8e <rs485ping+0x360>
    return 5;
  if (data != rPING)
    8c4e:	89 81       	ldd	r24, Y+1	; 0x01
    8c50:	80 38       	cpi	r24, 0x80	; 128
    8c52:	11 f0       	breq	.+4      	; 0x8c58 <rs485ping+0x22a>
    8c54:	16 e0       	ldi	r17, 0x06	; 6
    8c56:	9b c0       	rjmp	.+310    	; 0x8d8e <rs485ping+0x360>
    8c58:	18 27       	eor	r17, r24
    8c5a:	01 2e       	mov	r0, r17
    8c5c:	02 94       	swap	r0
    8c5e:	90 2d       	mov	r25, r0
    8c60:	9f 70       	andi	r25, 0x0F	; 15
    8c62:	91 27       	eor	r25, r17
    8c64:	81 2f       	mov	r24, r17
    8c66:	80 25       	eor	r24, r0
    8c68:	88 0f       	add	r24, r24
    8c6a:	80 7e       	andi	r24, 0xE0	; 224
    8c6c:	98 27       	eor	r25, r24
    8c6e:	80 2d       	mov	r24, r0
    8c70:	81 27       	eor	r24, r17
    8c72:	80 7f       	andi	r24, 0xF0	; 240
    8c74:	86 95       	lsr	r24
    8c76:	01 2e       	mov	r0, r17
    8c78:	00 0c       	add	r0, r0
    8c7a:	88 1f       	adc	r24, r24
    8c7c:	16 95       	lsr	r17
    8c7e:	16 95       	lsr	r17
    8c80:	16 95       	lsr	r17
    8c82:	1f 71       	andi	r17, 0x1F	; 31
    8c84:	18 27       	eor	r17, r24
    8c86:	10 27       	eor	r17, r16
    8c88:	09 2f       	mov	r16, r25
    return 6;
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    8c8a:	c6 01       	movw	r24, r12
    8c8c:	61 e0       	ldi	r22, 0x01	; 1
    8c8e:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8c92:	88 23       	and	r24, r24
    8c94:	11 f4       	brne	.+4      	; 0x8c9a <rs485ping+0x26c>
    8c96:	17 e0       	ldi	r17, 0x07	; 7
    8c98:	7a c0       	rjmp	.+244    	; 0x8d8e <rs485ping+0x360>
    return 7;
  if (data != dataLen)
    8c9a:	89 81       	ldd	r24, Y+1	; 0x01
    8c9c:	88 30       	cpi	r24, 0x08	; 8
    8c9e:	11 f0       	breq	.+4      	; 0x8ca4 <rs485ping+0x276>
    8ca0:	18 e0       	ldi	r17, 0x08	; 8
    8ca2:	75 c0       	rjmp	.+234    	; 0x8d8e <rs485ping+0x360>
    8ca4:	1b 25       	eor	r17, r11
    8ca6:	01 2e       	mov	r0, r17
    8ca8:	02 94       	swap	r0
    8caa:	90 2d       	mov	r25, r0
    8cac:	9f 70       	andi	r25, 0x0F	; 15
    8cae:	91 27       	eor	r25, r17
    8cb0:	81 2f       	mov	r24, r17
    8cb2:	80 25       	eor	r24, r0
    8cb4:	88 0f       	add	r24, r24
    8cb6:	80 7e       	andi	r24, 0xE0	; 224
    8cb8:	98 27       	eor	r25, r24
    8cba:	80 2d       	mov	r24, r0
    8cbc:	81 27       	eor	r24, r17
    8cbe:	80 7f       	andi	r24, 0xF0	; 240
    8cc0:	86 95       	lsr	r24
    8cc2:	01 2e       	mov	r0, r17
    8cc4:	00 0c       	add	r0, r0
    8cc6:	88 1f       	adc	r24, r24
    8cc8:	16 95       	lsr	r17
    8cca:	16 95       	lsr	r17
    8ccc:	16 95       	lsr	r17
    8cce:	1f 71       	andi	r17, 0x1F	; 31
    8cd0:	18 27       	eor	r17, r24
    8cd2:	10 27       	eor	r17, r16
    8cd4:	09 2f       	mov	r16, r25
    8cd6:	ff 24       	eor	r15, r15

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
  {
    if(rs485Receive(&data, 5) == pdFALSE)
    8cd8:	c6 01       	movw	r24, r12
    8cda:	dc 2c       	mov	r13, r12
    8cdc:	e9 2e       	mov	r14, r25
    8cde:	8d 2d       	mov	r24, r13
    8ce0:	9e 2d       	mov	r25, r14
    8ce2:	65 e0       	ldi	r22, 0x05	; 5
    8ce4:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8ce8:	88 23       	and	r24, r24
    8cea:	21 f4       	brne	.+8      	; 0x8cf4 <rs485ping+0x2c6>
      return 2*temp+9;
    8cec:	1f 2d       	mov	r17, r15
    8cee:	11 0f       	add	r17, r17
    8cf0:	17 5f       	subi	r17, 0xF7	; 247
    8cf2:	4d c0       	rjmp	.+154    	; 0x8d8e <rs485ping+0x360>
    crc = _crc_xmodem_update(crc, data);
    8cf4:	89 81       	ldd	r24, Y+1	; 0x01
    8cf6:	18 27       	eor	r17, r24
    8cf8:	01 2e       	mov	r0, r17
    8cfa:	02 94       	swap	r0
    8cfc:	20 2d       	mov	r18, r0
    8cfe:	2f 70       	andi	r18, 0x0F	; 15
    8d00:	21 27       	eor	r18, r17
    8d02:	91 2f       	mov	r25, r17
    8d04:	90 25       	eor	r25, r0
    8d06:	99 0f       	add	r25, r25
    8d08:	90 7e       	andi	r25, 0xE0	; 224
    8d0a:	29 27       	eor	r18, r25
    8d0c:	90 2d       	mov	r25, r0
    8d0e:	91 27       	eor	r25, r17
    8d10:	90 7f       	andi	r25, 0xF0	; 240
    8d12:	96 95       	lsr	r25
    8d14:	01 2e       	mov	r0, r17
    8d16:	00 0c       	add	r0, r0
    8d18:	99 1f       	adc	r25, r25
    8d1a:	16 95       	lsr	r17
    8d1c:	16 95       	lsr	r17
    8d1e:	16 95       	lsr	r17
    8d20:	1f 71       	andi	r17, 0x1F	; 31
    8d22:	19 27       	eor	r17, r25
    8d24:	10 27       	eor	r17, r16
    8d26:	02 2f       	mov	r16, r18
    if (data != temp)
    8d28:	8f 15       	cp	r24, r15
    8d2a:	21 f0       	breq	.+8      	; 0x8d34 <rs485ping+0x306>
      return 2*temp+10; 
    8d2c:	1f 2d       	mov	r17, r15
    8d2e:	11 0f       	add	r17, r17
    8d30:	16 5f       	subi	r17, 0xF6	; 246
    8d32:	2d c0       	rjmp	.+90     	; 0x8d8e <rs485ping+0x360>
    return 8;
  crc = _crc_xmodem_update(crc, data);

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    8d34:	f3 94       	inc	r15
    8d36:	87 e0       	ldi	r24, 0x07	; 7
    8d38:	8f 15       	cp	r24, r15
    8d3a:	08 f0       	brcs	.+2      	; 0x8d3e <rs485ping+0x310>
    8d3c:	d0 cf       	rjmp	.-96     	; 0x8cde <rs485ping+0x2b0>
      return 2*temp+10; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    8d3e:	ce 01       	movw	r24, r28
    8d40:	02 96       	adiw	r24, 0x02	; 2
    8d42:	61 e0       	ldi	r22, 0x01	; 1
    8d44:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8d48:	81 30       	cpi	r24, 0x01	; 1
    8d4a:	21 f0       	breq	.+8      	; 0x8d54 <rs485ping+0x326>
    return 2*temp+11;
    8d4c:	1f 2d       	mov	r17, r15
    8d4e:	11 0f       	add	r17, r17
    8d50:	15 5f       	subi	r17, 0xF5	; 245
    8d52:	1d c0       	rjmp	.+58     	; 0x8d8e <rs485ping+0x360>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    8d54:	80 91 9c 0e 	lds	r24, 0x0E9C
    8d58:	90 91 9d 0e 	lds	r25, 0x0E9D
    8d5c:	be 01       	movw	r22, r28
    8d5e:	6d 5f       	subi	r22, 0xFD	; 253
    8d60:	7f 4f       	sbci	r23, 0xFF	; 255
    8d62:	41 e0       	ldi	r20, 0x01	; 1
    8d64:	50 e0       	ldi	r21, 0x00	; 0
    8d66:	20 e0       	ldi	r18, 0x00	; 0
    8d68:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    8d6c:	81 30       	cpi	r24, 0x01	; 1
    8d6e:	21 f0       	breq	.+8      	; 0x8d78 <rs485ping+0x34a>
    return 2*temp+12;
    8d70:	1f 2d       	mov	r17, r15
    8d72:	11 0f       	add	r17, r17
    8d74:	14 5f       	subi	r17, 0xF4	; 244
    8d76:	0b c0       	rjmp	.+22     	; 0x8d8e <rs485ping+0x360>

  if (crcHi != (uint8_t)(crc>>8))
    8d78:	8a 81       	ldd	r24, Y+2	; 0x02
    8d7a:	81 17       	cp	r24, r17
    8d7c:	11 f0       	breq	.+4      	; 0x8d82 <rs485ping+0x354>
    8d7e:	1e ef       	ldi	r17, 0xFE	; 254
    8d80:	06 c0       	rjmp	.+12     	; 0x8d8e <rs485ping+0x360>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    8d82:	8b 81       	ldd	r24, Y+3	; 0x03
    8d84:	80 17       	cp	r24, r16
    8d86:	11 f4       	brne	.+4      	; 0x8d8c <rs485ping+0x35e>
    8d88:	10 e0       	ldi	r17, 0x00	; 0
    8d8a:	01 c0       	rjmp	.+2      	; 0x8d8e <rs485ping+0x360>
    8d8c:	1f ef       	ldi	r17, 0xFF	; 255
{
  takeRs485();
  const int len = 8;    
  sendPing(devAddr, len);
  uint8_t result = receivePong(devAddr, len);
  flushRs485RecBuffer();
    8d8e:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <flushRs485RecBuffer>

  releaseRs485();
    8d92:	0e 94 b4 0b 	call	0x1768	; 0x1768 <releaseRs485>
  return result;
}
    8d96:	81 2f       	mov	r24, r17
    8d98:	0f 90       	pop	r0
    8d9a:	0f 90       	pop	r0
    8d9c:	0f 90       	pop	r0
    8d9e:	cf 91       	pop	r28
    8da0:	df 91       	pop	r29
    8da2:	1f 91       	pop	r17
    8da4:	0f 91       	pop	r16
    8da6:	ff 90       	pop	r15
    8da8:	ef 90       	pop	r14
    8daa:	df 90       	pop	r13
    8dac:	cf 90       	pop	r12
    8dae:	bf 90       	pop	r11
    8db0:	08 95       	ret

00008db2 <rs485rollerHello>:

uint8_t rs485rollerHello(uint8_t devAddr)
{
    8db2:	af 92       	push	r10
    8db4:	bf 92       	push	r11
    8db6:	cf 92       	push	r12
    8db8:	df 92       	push	r13
    8dba:	ef 92       	push	r14
    8dbc:	ff 92       	push	r15
    8dbe:	0f 93       	push	r16
    8dc0:	1f 93       	push	r17
    8dc2:	df 93       	push	r29
    8dc4:	cf 93       	push	r28
    8dc6:	00 d0       	rcall	.+0      	; 0x8dc8 <rs485rollerHello+0x16>
    8dc8:	0f 92       	push	r0
    8dca:	cd b7       	in	r28, 0x3d	; 61
    8dcc:	de b7       	in	r29, 0x3e	; 62
    8dce:	d8 2e       	mov	r13, r24
    8dd0:	e0 91 a8 0e 	lds	r30, 0x0EA8
    8dd4:	f0 91 a9 0e 	lds	r31, 0x0EA9
    8dd8:	ee 24       	eor	r14, r14
    8dda:	ff 24       	eor	r15, r15
    8ddc:	40 e0       	ldi	r20, 0x00	; 0
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    8dde:	81 81       	ldd	r24, Z+1	; 0x01
    8de0:	8d 15       	cp	r24, r13
    8de2:	09 f4       	brne	.+2      	; 0x8de6 <rs485rollerHello+0x34>
    8de4:	7f 01       	movw	r14, r30

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    8de6:	4f 5f       	subi	r20, 0xFF	; 255
    8de8:	3a 96       	adiw	r30, 0x0a	; 10
    8dea:	4a 30       	cpi	r20, 0x0A	; 10
    8dec:	c1 f7       	brne	.-16     	; 0x8dde <rs485rollerHello+0x2c>
    if (rollers[i].address == devAddr)
      tmp = &rollers[i];
    
  if (rs485ping(devAddr)==0)
    8dee:	8d 2d       	mov	r24, r13
    8df0:	0e 94 17 45 	call	0x8a2e	; 0x8a2e <rs485ping>
    8df4:	88 23       	and	r24, r24
    8df6:	e9 f4       	brne	.+58     	; 0x8e32 <rs485rollerHello+0x80>
  {
    if (tmp == NULL)
    8df8:	e1 14       	cp	r14, r1
    8dfa:	f1 04       	cpc	r15, r1
    8dfc:	81 f4       	brne	.+32     	; 0x8e1e <rs485rollerHello+0x6c>
    8dfe:	e0 91 a8 0e 	lds	r30, 0x0EA8
    8e02:	f0 91 a9 0e 	lds	r31, 0x0EA9
    8e06:	90 e0       	ldi	r25, 0x00	; 0
    8e08:	7f 01       	movw	r14, r30
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
      {
        if (rollers[i].address == 0)
    8e0a:	81 81       	ldd	r24, Z+1	; 0x01
    8e0c:	88 23       	and	r24, r24
    8e0e:	11 f4       	brne	.+4      	; 0x8e14 <rs485rollerHello+0x62>
        {
          tmp = &rollers[i];
          tmp->address = devAddr;
    8e10:	d1 82       	std	Z+1, r13	; 0x01
    8e12:	05 c0       	rjmp	.+10     	; 0x8e1e <rs485rollerHello+0x6c>
    
  if (rs485ping(devAddr)==0)
  {
    if (tmp == NULL)
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    8e14:	9f 5f       	subi	r25, 0xFF	; 255
    8e16:	3a 96       	adiw	r30, 0x0a	; 10
    8e18:	9a 30       	cpi	r25, 0x0A	; 10
    8e1a:	b1 f7       	brne	.-20     	; 0x8e08 <rs485rollerHello+0x56>
    8e1c:	90 c1       	rjmp	.+800    	; 0x913e <rs485rollerHello+0x38c>
          tmp->address = devAddr;
          break;
        }
      }
    }
    if (tmp != NULL)
    8e1e:	e1 14       	cp	r14, r1
    8e20:	f1 04       	cpc	r15, r1
    8e22:	09 f4       	brne	.+2      	; 0x8e26 <rs485rollerHello+0x74>
    8e24:	8c c1       	rjmp	.+792    	; 0x913e <rs485rollerHello+0x38c>
    {
      tmp->state &= (~NOT_DETECTED);
    8e26:	f7 01       	movw	r30, r14
    8e28:	80 81       	ld	r24, Z
    8e2a:	8e 7f       	andi	r24, 0xFE	; 254
    8e2c:	80 83       	st	Z, r24
      tmp->address = devAddr;
    8e2e:	d1 82       	std	Z+1, r13	; 0x01
    8e30:	0d c0       	rjmp	.+26     	; 0x8e4c <rs485rollerHello+0x9a>
    else
      return 1;
  }
  else
  {
    if (tmp != NULL)
    8e32:	e1 14       	cp	r14, r1
    8e34:	f1 04       	cpc	r15, r1
    8e36:	51 f0       	breq	.+20     	; 0x8e4c <rs485rollerHello+0x9a>
    {
      if (tmp->state & NOT_DETECTED)
    8e38:	f7 01       	movw	r30, r14
    8e3a:	80 81       	ld	r24, Z
    8e3c:	80 fd       	sbrc	r24, 0
      {
        tmp->address = 0;
    8e3e:	11 82       	std	Z+1, r1	; 0x01
      }
      tmp->state |= NOT_DETECTED;
    8e40:	f7 01       	movw	r30, r14
    8e42:	80 81       	ld	r24, Z
    8e44:	81 60       	ori	r24, 0x01	; 1
    8e46:	80 83       	st	Z, r24
    8e48:	02 e0       	ldi	r16, 0x02	; 2
    8e4a:	7a c1       	rjmp	.+756    	; 0x9140 <rs485rollerHello+0x38e>
      return 2;
    }
  }
  
  takeRs485();
    8e4c:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <takeRs485>
    8e50:	aa 24       	eor	r10, r10
    8e52:	bb 24       	eor	r11, r11
    8e54:	85 01       	movw	r16, r10
    8e56:	8a e5       	ldi	r24, 0x5A	; 90
    8e58:	18 27       	eor	r17, r24
    8e5a:	01 2e       	mov	r0, r17
    8e5c:	02 94       	swap	r0
    8e5e:	90 2d       	mov	r25, r0
    8e60:	9f 70       	andi	r25, 0x0F	; 15
    8e62:	91 27       	eor	r25, r17
    8e64:	81 2f       	mov	r24, r17
    8e66:	80 25       	eor	r24, r0
    8e68:	88 0f       	add	r24, r24
    8e6a:	80 7e       	andi	r24, 0xE0	; 224
    8e6c:	98 27       	eor	r25, r24
    8e6e:	80 2d       	mov	r24, r0
    8e70:	81 27       	eor	r24, r17
    8e72:	80 7f       	andi	r24, 0xF0	; 240
    8e74:	86 95       	lsr	r24
    8e76:	01 2e       	mov	r0, r17
    8e78:	00 0c       	add	r0, r0
    8e7a:	88 1f       	adc	r24, r24
    8e7c:	16 95       	lsr	r17
    8e7e:	16 95       	lsr	r17
    8e80:	16 95       	lsr	r17
    8e82:	1f 71       	andi	r17, 0x1F	; 31
    8e84:	18 27       	eor	r17, r24
    8e86:	10 27       	eor	r17, r16
    8e88:	09 2f       	mov	r16, r25
}

static void    sendHello(uint8_t addr)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
  uartRs485SendByte(SYNC);
    8e8a:	8a e5       	ldi	r24, 0x5A	; 90
    8e8c:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8e90:	1d 25       	eor	r17, r13
    8e92:	01 2e       	mov	r0, r17
    8e94:	02 94       	swap	r0
    8e96:	90 2d       	mov	r25, r0
    8e98:	9f 70       	andi	r25, 0x0F	; 15
    8e9a:	91 27       	eor	r25, r17
    8e9c:	81 2f       	mov	r24, r17
    8e9e:	80 25       	eor	r24, r0
    8ea0:	88 0f       	add	r24, r24
    8ea2:	80 7e       	andi	r24, 0xE0	; 224
    8ea4:	98 27       	eor	r25, r24
    8ea6:	80 2d       	mov	r24, r0
    8ea8:	81 27       	eor	r24, r17
    8eaa:	80 7f       	andi	r24, 0xF0	; 240
    8eac:	86 95       	lsr	r24
    8eae:	01 2e       	mov	r0, r17
    8eb0:	00 0c       	add	r0, r0
    8eb2:	88 1f       	adc	r24, r24
    8eb4:	16 95       	lsr	r17
    8eb6:	16 95       	lsr	r17
    8eb8:	16 95       	lsr	r17
    8eba:	1f 71       	andi	r17, 0x1F	; 31
    8ebc:	18 27       	eor	r17, r24
    8ebe:	10 27       	eor	r17, r16
    8ec0:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, addr);
  uartRs485SendByte(addr);
    8ec2:	8d 2d       	mov	r24, r13
    8ec4:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8ec8:	82 e8       	ldi	r24, 0x82	; 130
    8eca:	18 27       	eor	r17, r24
    8ecc:	01 2e       	mov	r0, r17
    8ece:	02 94       	swap	r0
    8ed0:	90 2d       	mov	r25, r0
    8ed2:	9f 70       	andi	r25, 0x0F	; 15
    8ed4:	91 27       	eor	r25, r17
    8ed6:	81 2f       	mov	r24, r17
    8ed8:	80 25       	eor	r24, r0
    8eda:	88 0f       	add	r24, r24
    8edc:	80 7e       	andi	r24, 0xE0	; 224
    8ede:	98 27       	eor	r25, r24
    8ee0:	80 2d       	mov	r24, r0
    8ee2:	81 27       	eor	r24, r17
    8ee4:	80 7f       	andi	r24, 0xF0	; 240
    8ee6:	86 95       	lsr	r24
    8ee8:	01 2e       	mov	r0, r17
    8eea:	00 0c       	add	r0, r0
    8eec:	88 1f       	adc	r24, r24
    8eee:	16 95       	lsr	r17
    8ef0:	16 95       	lsr	r17
    8ef2:	16 95       	lsr	r17
    8ef4:	1f 71       	andi	r17, 0x1F	; 31
    8ef6:	18 27       	eor	r17, r24
    8ef8:	10 27       	eor	r17, r16
    8efa:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, rHELLO);
  uartRs485SendByte(rHELLO);
    8efc:	82 e8       	ldi	r24, 0x82	; 130
    8efe:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
    8f02:	80 e0       	ldi	r24, 0x00	; 0
    8f04:	18 27       	eor	r17, r24
    8f06:	01 2e       	mov	r0, r17
    8f08:	02 94       	swap	r0
    8f0a:	90 2d       	mov	r25, r0
    8f0c:	9f 70       	andi	r25, 0x0F	; 15
    8f0e:	91 27       	eor	r25, r17
    8f10:	81 2f       	mov	r24, r17
    8f12:	80 25       	eor	r24, r0
    8f14:	88 0f       	add	r24, r24
    8f16:	80 7e       	andi	r24, 0xE0	; 224
    8f18:	98 27       	eor	r25, r24
    8f1a:	80 2d       	mov	r24, r0
    8f1c:	81 27       	eor	r24, r17
    8f1e:	80 7f       	andi	r24, 0xF0	; 240
    8f20:	86 95       	lsr	r24
    8f22:	01 2e       	mov	r0, r17
    8f24:	00 0c       	add	r0, r0
    8f26:	88 1f       	adc	r24, r24
    8f28:	16 95       	lsr	r17
    8f2a:	16 95       	lsr	r17
    8f2c:	16 95       	lsr	r17
    8f2e:	1f 71       	andi	r17, 0x1F	; 31
    8f30:	18 27       	eor	r17, r24
    8f32:	10 27       	eor	r17, r16
    8f34:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, 0);
  uartRs485SendByte(0);
    8f36:	80 e0       	ldi	r24, 0x00	; 0
    8f38:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc >> 8));
    8f3c:	81 2f       	mov	r24, r17
    8f3e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8f42:	80 2f       	mov	r24, r16
    8f44:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uartRs485SendByte>
static uint8_t receiveHello(uint8_t* response, uint8_t maxSize)
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    8f48:	6e 01       	movw	r12, r28
    8f4a:	08 94       	sec
    8f4c:	c1 1c       	adc	r12, r1
    8f4e:	d1 1c       	adc	r13, r1
    8f50:	c6 01       	movw	r24, r12
    8f52:	64 e1       	ldi	r22, 0x14	; 20
    8f54:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8f58:	88 23       	and	r24, r24
    8f5a:	11 f4       	brne	.+4      	; 0x8f60 <rs485rollerHello+0x1ae>
    8f5c:	08 e0       	ldi	r16, 0x08	; 8
    8f5e:	ec c0       	rjmp	.+472    	; 0x9138 <rs485rollerHello+0x386>
    return 8;
  
  if (data != SYNC)
    8f60:	89 81       	ldd	r24, Y+1	; 0x01
    8f62:	8a 35       	cpi	r24, 0x5A	; 90
    8f64:	11 f0       	breq	.+4      	; 0x8f6a <rs485rollerHello+0x1b8>
    8f66:	02 e0       	ldi	r16, 0x02	; 2
    8f68:	e7 c0       	rjmp	.+462    	; 0x9138 <rs485rollerHello+0x386>
    8f6a:	85 01       	movw	r16, r10
    8f6c:	18 27       	eor	r17, r24
    8f6e:	01 2e       	mov	r0, r17
    8f70:	02 94       	swap	r0
    8f72:	90 2d       	mov	r25, r0
    8f74:	9f 70       	andi	r25, 0x0F	; 15
    8f76:	91 27       	eor	r25, r17
    8f78:	81 2f       	mov	r24, r17
    8f7a:	80 25       	eor	r24, r0
    8f7c:	88 0f       	add	r24, r24
    8f7e:	80 7e       	andi	r24, 0xE0	; 224
    8f80:	98 27       	eor	r25, r24
    8f82:	80 2d       	mov	r24, r0
    8f84:	81 27       	eor	r24, r17
    8f86:	80 7f       	andi	r24, 0xF0	; 240
    8f88:	86 95       	lsr	r24
    8f8a:	01 2e       	mov	r0, r17
    8f8c:	00 0c       	add	r0, r0
    8f8e:	88 1f       	adc	r24, r24
    8f90:	16 95       	lsr	r17
    8f92:	16 95       	lsr	r17
    8f94:	16 95       	lsr	r17
    8f96:	1f 71       	andi	r17, 0x1F	; 31
    8f98:	18 27       	eor	r17, r24
    8f9a:	10 27       	eor	r17, r16
    8f9c:	09 2f       	mov	r16, r25
    return 2;
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    8f9e:	c6 01       	movw	r24, r12
    8fa0:	61 e0       	ldi	r22, 0x01	; 1
    8fa2:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8fa6:	88 23       	and	r24, r24
    8fa8:	11 f4       	brne	.+4      	; 0x8fae <rs485rollerHello+0x1fc>
    8faa:	03 e0       	ldi	r16, 0x03	; 3
    8fac:	c5 c0       	rjmp	.+394    	; 0x9138 <rs485rollerHello+0x386>
    return 3;

  if (data != 0)
    8fae:	89 81       	ldd	r24, Y+1	; 0x01
    8fb0:	88 23       	and	r24, r24
    8fb2:	11 f0       	breq	.+4      	; 0x8fb8 <rs485rollerHello+0x206>
    8fb4:	04 e0       	ldi	r16, 0x04	; 4
    8fb6:	c0 c0       	rjmp	.+384    	; 0x9138 <rs485rollerHello+0x386>
    8fb8:	18 27       	eor	r17, r24
    8fba:	01 2e       	mov	r0, r17
    8fbc:	02 94       	swap	r0
    8fbe:	90 2d       	mov	r25, r0
    8fc0:	9f 70       	andi	r25, 0x0F	; 15
    8fc2:	91 27       	eor	r25, r17
    8fc4:	81 2f       	mov	r24, r17
    8fc6:	80 25       	eor	r24, r0
    8fc8:	88 0f       	add	r24, r24
    8fca:	80 7e       	andi	r24, 0xE0	; 224
    8fcc:	98 27       	eor	r25, r24
    8fce:	80 2d       	mov	r24, r0
    8fd0:	81 27       	eor	r24, r17
    8fd2:	80 7f       	andi	r24, 0xF0	; 240
    8fd4:	86 95       	lsr	r24
    8fd6:	01 2e       	mov	r0, r17
    8fd8:	00 0c       	add	r0, r0
    8fda:	88 1f       	adc	r24, r24
    8fdc:	16 95       	lsr	r17
    8fde:	16 95       	lsr	r17
    8fe0:	16 95       	lsr	r17
    8fe2:	1f 71       	andi	r17, 0x1F	; 31
    8fe4:	18 27       	eor	r17, r24
    8fe6:	10 27       	eor	r17, r16
    8fe8:	09 2f       	mov	r16, r25
    return 4;
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    8fea:	c6 01       	movw	r24, r12
    8fec:	61 e0       	ldi	r22, 0x01	; 1
    8fee:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    8ff2:	88 23       	and	r24, r24
    8ff4:	11 f4       	brne	.+4      	; 0x8ffa <rs485rollerHello+0x248>
    8ff6:	05 e0       	ldi	r16, 0x05	; 5
    8ff8:	9f c0       	rjmp	.+318    	; 0x9138 <rs485rollerHello+0x386>
    return 5;
  if (data != rHELLO)
    8ffa:	89 81       	ldd	r24, Y+1	; 0x01
    8ffc:	82 38       	cpi	r24, 0x82	; 130
    8ffe:	11 f0       	breq	.+4      	; 0x9004 <rs485rollerHello+0x252>
    9000:	06 e0       	ldi	r16, 0x06	; 6
    9002:	9a c0       	rjmp	.+308    	; 0x9138 <rs485rollerHello+0x386>
    9004:	18 27       	eor	r17, r24
    9006:	01 2e       	mov	r0, r17
    9008:	02 94       	swap	r0
    900a:	90 2d       	mov	r25, r0
    900c:	9f 70       	andi	r25, 0x0F	; 15
    900e:	91 27       	eor	r25, r17
    9010:	81 2f       	mov	r24, r17
    9012:	80 25       	eor	r24, r0
    9014:	88 0f       	add	r24, r24
    9016:	80 7e       	andi	r24, 0xE0	; 224
    9018:	98 27       	eor	r25, r24
    901a:	80 2d       	mov	r24, r0
    901c:	81 27       	eor	r24, r17
    901e:	80 7f       	andi	r24, 0xF0	; 240
    9020:	86 95       	lsr	r24
    9022:	01 2e       	mov	r0, r17
    9024:	00 0c       	add	r0, r0
    9026:	88 1f       	adc	r24, r24
    9028:	16 95       	lsr	r17
    902a:	16 95       	lsr	r17
    902c:	16 95       	lsr	r17
    902e:	1f 71       	andi	r17, 0x1F	; 31
    9030:	18 27       	eor	r17, r24
    9032:	10 27       	eor	r17, r16
    9034:	09 2f       	mov	r16, r25
    return 6;
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    9036:	c6 01       	movw	r24, r12
    9038:	61 e0       	ldi	r22, 0x01	; 1
    903a:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    903e:	88 23       	and	r24, r24
    9040:	11 f4       	brne	.+4      	; 0x9046 <rs485rollerHello+0x294>
    9042:	07 e0       	ldi	r16, 0x07	; 7
    9044:	79 c0       	rjmp	.+242    	; 0x9138 <rs485rollerHello+0x386>
    return 7;
  if (data > maxSize)
    9046:	89 81       	ldd	r24, Y+1	; 0x01
    9048:	88 30       	cpi	r24, 0x08	; 8
    904a:	10 f0       	brcs	.+4      	; 0x9050 <rs485rollerHello+0x29e>
    904c:	01 e0       	ldi	r16, 0x01	; 1
    904e:	74 c0       	rjmp	.+232    	; 0x9138 <rs485rollerHello+0x386>
    }
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
    9050:	22 e0       	ldi	r18, 0x02	; 2
    9052:	30 e0       	ldi	r19, 0x00	; 0
    9054:	e2 0e       	add	r14, r18
    9056:	f3 1e       	adc	r15, r19
    9058:	18 27       	eor	r17, r24
    905a:	01 2e       	mov	r0, r17
    905c:	02 94       	swap	r0
    905e:	90 2d       	mov	r25, r0
    9060:	9f 70       	andi	r25, 0x0F	; 15
    9062:	91 27       	eor	r25, r17
    9064:	81 2f       	mov	r24, r17
    9066:	80 25       	eor	r24, r0
    9068:	88 0f       	add	r24, r24
    906a:	80 7e       	andi	r24, 0xE0	; 224
    906c:	98 27       	eor	r25, r24
    906e:	80 2d       	mov	r24, r0
    9070:	81 27       	eor	r24, r17
    9072:	80 7f       	andi	r24, 0xF0	; 240
    9074:	86 95       	lsr	r24
    9076:	01 2e       	mov	r0, r17
    9078:	00 0c       	add	r0, r0
    907a:	88 1f       	adc	r24, r24
    907c:	16 95       	lsr	r17
    907e:	16 95       	lsr	r17
    9080:	16 95       	lsr	r17
    9082:	1f 71       	andi	r17, 0x1F	; 31
    9084:	18 27       	eor	r17, r24
    9086:	10 27       	eor	r17, r16
    9088:	09 2f       	mov	r16, r25
    return 7;
  if (data > maxSize)
    return 1;
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
    908a:	87 e0       	ldi	r24, 0x07	; 7
    908c:	f7 01       	movw	r30, r14
    908e:	11 92       	st	Z+, r1
    9090:	8a 95       	dec	r24
    9092:	e9 f7       	brne	.-6      	; 0x908e <rs485rollerHello+0x2dc>
  maxSize = data;
    9094:	d9 80       	ldd	r13, Y+1	; 0x01
  
  for (data=0; data < maxSize; data++)
    9096:	19 82       	std	Y+1, r1	; 0x01
    9098:	27 c0       	rjmp	.+78     	; 0x90e8 <rs485rollerHello+0x336>
  {
    if(rs485Receive(response, 5) == pdFALSE)
    909a:	c7 01       	movw	r24, r14
    909c:	65 e0       	ldi	r22, 0x05	; 5
    909e:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    90a2:	88 23       	and	r24, r24
    90a4:	11 f4       	brne	.+4      	; 0x90aa <rs485rollerHello+0x2f8>
    90a6:	04 e1       	ldi	r16, 0x14	; 20
    90a8:	47 c0       	rjmp	.+142    	; 0x9138 <rs485rollerHello+0x386>
    90aa:	f7 01       	movw	r30, r14
    90ac:	81 91       	ld	r24, Z+
    90ae:	7f 01       	movw	r14, r30
    90b0:	18 27       	eor	r17, r24
    90b2:	01 2e       	mov	r0, r17
    90b4:	02 94       	swap	r0
    90b6:	90 2d       	mov	r25, r0
    90b8:	9f 70       	andi	r25, 0x0F	; 15
    90ba:	91 27       	eor	r25, r17
    90bc:	81 2f       	mov	r24, r17
    90be:	80 25       	eor	r24, r0
    90c0:	88 0f       	add	r24, r24
    90c2:	80 7e       	andi	r24, 0xE0	; 224
    90c4:	98 27       	eor	r25, r24
    90c6:	80 2d       	mov	r24, r0
    90c8:	81 27       	eor	r24, r17
    90ca:	80 7f       	andi	r24, 0xF0	; 240
    90cc:	86 95       	lsr	r24
    90ce:	01 2e       	mov	r0, r17
    90d0:	00 0c       	add	r0, r0
    90d2:	88 1f       	adc	r24, r24
    90d4:	16 95       	lsr	r17
    90d6:	16 95       	lsr	r17
    90d8:	16 95       	lsr	r17
    90da:	1f 71       	andi	r17, 0x1F	; 31
    90dc:	18 27       	eor	r17, r24
    90de:	10 27       	eor	r17, r16
    90e0:	09 2f       	mov	r16, r25
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
    90e2:	89 81       	ldd	r24, Y+1	; 0x01
    90e4:	8f 5f       	subi	r24, 0xFF	; 255
    90e6:	89 83       	std	Y+1, r24	; 0x01
    90e8:	89 81       	ldd	r24, Y+1	; 0x01
    90ea:	8d 15       	cp	r24, r13
    90ec:	08 f4       	brcc	.+2      	; 0x90f0 <rs485rollerHello+0x33e>
    90ee:	d5 cf       	rjmp	.-86     	; 0x909a <rs485rollerHello+0x2e8>
    response++; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    90f0:	ce 01       	movw	r24, r28
    90f2:	02 96       	adiw	r24, 0x02	; 2
    90f4:	61 e0       	ldi	r22, 0x01	; 1
    90f6:	0e 94 8f 0c 	call	0x191e	; 0x191e <rs485Receive>
    90fa:	81 30       	cpi	r24, 0x01	; 1
    90fc:	11 f0       	breq	.+4      	; 0x9102 <rs485rollerHello+0x350>
    90fe:	05 e1       	ldi	r16, 0x15	; 21
    9100:	1b c0       	rjmp	.+54     	; 0x9138 <rs485rollerHello+0x386>
    return 21;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    9102:	80 91 9c 0e 	lds	r24, 0x0E9C
    9106:	90 91 9d 0e 	lds	r25, 0x0E9D
    910a:	be 01       	movw	r22, r28
    910c:	6d 5f       	subi	r22, 0xFD	; 253
    910e:	7f 4f       	sbci	r23, 0xFF	; 255
    9110:	41 e0       	ldi	r20, 0x01	; 1
    9112:	50 e0       	ldi	r21, 0x00	; 0
    9114:	20 e0       	ldi	r18, 0x00	; 0
    9116:	0e 94 c3 50 	call	0xa186	; 0xa186 <xQueueGenericReceive>
    911a:	81 30       	cpi	r24, 0x01	; 1
    911c:	11 f0       	breq	.+4      	; 0x9122 <rs485rollerHello+0x370>
    911e:	06 e1       	ldi	r16, 0x16	; 22
    9120:	0b c0       	rjmp	.+22     	; 0x9138 <rs485rollerHello+0x386>
    return 22;

  if (crcHi != (uint8_t)(crc>>8))
    9122:	8a 81       	ldd	r24, Y+2	; 0x02
    9124:	81 17       	cp	r24, r17
    9126:	11 f0       	breq	.+4      	; 0x912c <rs485rollerHello+0x37a>
    9128:	0e ef       	ldi	r16, 0xFE	; 254
    912a:	06 c0       	rjmp	.+12     	; 0x9138 <rs485rollerHello+0x386>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    912c:	8b 81       	ldd	r24, Y+3	; 0x03
    912e:	80 17       	cp	r24, r16
    9130:	11 f4       	brne	.+4      	; 0x9136 <rs485rollerHello+0x384>
    9132:	00 e0       	ldi	r16, 0x00	; 0
    9134:	01 c0       	rjmp	.+2      	; 0x9138 <rs485rollerHello+0x386>
    9136:	0f ef       	ldi	r16, 0xFF	; 255
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
    9138:	0e 94 b4 0b 	call	0x1768	; 0x1768 <releaseRs485>
    913c:	01 c0       	rjmp	.+2      	; 0x9140 <rs485rollerHello+0x38e>
  return result;
    913e:	01 e0       	ldi	r16, 0x01	; 1
}
    9140:	80 2f       	mov	r24, r16
    9142:	0f 90       	pop	r0
    9144:	0f 90       	pop	r0
    9146:	0f 90       	pop	r0
    9148:	cf 91       	pop	r28
    914a:	df 91       	pop	r29
    914c:	1f 91       	pop	r17
    914e:	0f 91       	pop	r16
    9150:	ff 90       	pop	r15
    9152:	ef 90       	pop	r14
    9154:	df 90       	pop	r13
    9156:	cf 90       	pop	r12
    9158:	bf 90       	pop	r11
    915a:	af 90       	pop	r10
    915c:	08 95       	ret

0000915e <rollersMemInit>:

// ************************ Rs485 API ************************************

void rollersMemInit(void)
{
  rollers = xmalloc(MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    915e:	84 e6       	ldi	r24, 0x64	; 100
    9160:	90 e0       	ldi	r25, 0x00	; 0
    9162:	0e 94 2e 1c 	call	0x385c	; 0x385c <xmalloc>
    9166:	80 93 a8 0e 	sts	0x0EA8, r24
    916a:	90 93 a9 0e 	sts	0x0EA9, r25
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    916e:	fc 01       	movw	r30, r24
    9170:	84 e6       	ldi	r24, 0x64	; 100
    9172:	df 01       	movw	r26, r30
    9174:	1d 92       	st	X+, r1
    9176:	8a 95       	dec	r24
    9178:	e9 f7       	brne	.-6      	; 0x9174 <rollersMemInit+0x16>
}
    917a:	08 95       	ret

0000917c <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		portENTER_CRITICAL();
    917c:	0f b6       	in	r0, 0x3f	; 63
    917e:	f8 94       	cli
    9180:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    9182:	00 97       	sbiw	r24, 0x00	; 0
    9184:	29 f4       	brne	.+10     	; 0x9190 <uxTaskPriorityGet+0x14>
    9186:	e0 91 93 01 	lds	r30, 0x0193
    918a:	f0 91 94 01 	lds	r31, 0x0194
    918e:	01 c0       	rjmp	.+2      	; 0x9192 <uxTaskPriorityGet+0x16>
    9190:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portEXIT_CRITICAL();
    9192:	0f 90       	pop	r0
    9194:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    9196:	86 89       	ldd	r24, Z+22	; 0x16
    9198:	08 95       	ret

0000919a <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    919a:	fc 01       	movw	r30, r24

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    919c:	82 85       	ldd	r24, Z+10	; 0x0a
    919e:	93 85       	ldd	r25, Z+11	; 0x0b
    91a0:	8b 5d       	subi	r24, 0xDB	; 219
    91a2:	91 40       	sbci	r25, 0x01	; 1
    91a4:	59 f4       	brne	.+22     	; 0x91bc <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    91a6:	84 89       	ldd	r24, Z+20	; 0x14
    91a8:	95 89       	ldd	r25, Z+21	; 0x15
    91aa:	21 e0       	ldi	r18, 0x01	; 1
    91ac:	82 3d       	cpi	r24, 0xD2	; 210
    91ae:	92 07       	cpc	r25, r18
    91b0:	29 f0       	breq	.+10     	; 0x91bc <xTaskIsTaskSuspended+0x22>
    91b2:	20 e0       	ldi	r18, 0x00	; 0
    91b4:	89 2b       	or	r24, r25
    91b6:	19 f4       	brne	.+6      	; 0x91be <xTaskIsTaskSuspended+0x24>
    91b8:	21 e0       	ldi	r18, 0x01	; 1
    91ba:	01 c0       	rjmp	.+2      	; 0x91be <xTaskIsTaskSuspended+0x24>
    91bc:	20 e0       	ldi	r18, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    91be:	82 2f       	mov	r24, r18
    91c0:	08 95       	ret

000091c2 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    91c2:	80 91 99 01 	lds	r24, 0x0199
    91c6:	8f 5f       	subi	r24, 0xFF	; 255
    91c8:	80 93 99 01 	sts	0x0199, r24
}
    91cc:	08 95       	ret

000091ce <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    91ce:	0f b6       	in	r0, 0x3f	; 63
    91d0:	f8 94       	cli
    91d2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    91d4:	20 91 97 01 	lds	r18, 0x0197
    91d8:	30 91 98 01 	lds	r19, 0x0198
	}
	portEXIT_CRITICAL();
    91dc:	0f 90       	pop	r0
    91de:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    91e0:	c9 01       	movw	r24, r18
    91e2:	08 95       	ret

000091e4 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    91e4:	80 91 9e 01 	lds	r24, 0x019E
}
    91e8:	08 95       	ret

000091ea <vTaskStartTrace>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
	{
		portENTER_CRITICAL();
    91ea:	0f b6       	in	r0, 0x3f	; 63
    91ec:	f8 94       	cli
    91ee:	0f 92       	push	r0
		{
			pcTraceBuffer = ( signed char * )pcBuffer;
    91f0:	90 93 e5 01 	sts	0x01E5, r25
    91f4:	80 93 e4 01 	sts	0x01E4, r24
			pcTraceBufferStart = pcBuffer;
    91f8:	90 93 e7 01 	sts	0x01E7, r25
    91fc:	80 93 e6 01 	sts	0x01E6, r24
			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
    9200:	48 50       	subi	r20, 0x08	; 8
    9202:	50 40       	sbci	r21, 0x00	; 0
    9204:	48 0f       	add	r20, r24
    9206:	59 1f       	adc	r21, r25
    9208:	50 93 e9 01 	sts	0x01E9, r21
    920c:	40 93 e8 01 	sts	0x01E8, r20
			xTracing = pdTRUE;
    9210:	81 e0       	ldi	r24, 0x01	; 1
    9212:	80 93 9b 01 	sts	0x019B, r24
		}
		portEXIT_CRITICAL();
    9216:	0f 90       	pop	r0
    9218:	0f be       	out	0x3f, r0	; 63
	}
    921a:	08 95       	ret

0000921c <ulTaskEndTrace>:

	unsigned long ulTaskEndTrace( void )
	{
	unsigned long ulBufferLength;

		portENTER_CRITICAL();
    921c:	0f b6       	in	r0, 0x3f	; 63
    921e:	f8 94       	cli
    9220:	0f 92       	push	r0
			xTracing = pdFALSE;
    9222:	10 92 9b 01 	sts	0x019B, r1
		portEXIT_CRITICAL();
    9226:	0f 90       	pop	r0
    9228:	0f be       	out	0x3f, r0	; 63

		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
    922a:	20 91 e4 01 	lds	r18, 0x01E4
    922e:	30 91 e5 01 	lds	r19, 0x01E5
    9232:	80 91 e6 01 	lds	r24, 0x01E6
    9236:	90 91 e7 01 	lds	r25, 0x01E7
    923a:	28 1b       	sub	r18, r24
    923c:	39 0b       	sbc	r19, r25
    923e:	44 27       	eor	r20, r20
    9240:	37 fd       	sbrc	r19, 7
    9242:	40 95       	com	r20
    9244:	54 2f       	mov	r21, r20

		return ulBufferLength;
	}
    9246:	b9 01       	movw	r22, r18
    9248:	ca 01       	movw	r24, r20
    924a:	08 95       	ret

0000924c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    924c:	80 91 99 01 	lds	r24, 0x0199
    9250:	88 23       	and	r24, r24
    9252:	51 f0       	breq	.+20     	; 0x9268 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    9254:	81 e0       	ldi	r24, 0x01	; 1
    9256:	80 93 95 01 	sts	0x0195, r24
    925a:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    925c:	80 91 9a 01 	lds	r24, 0x019A
    9260:	81 50       	subi	r24, 0x01	; 1
    9262:	80 93 9a 01 	sts	0x019A, r24
    9266:	01 c0       	rjmp	.+2      	; 0x926a <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    9268:	99 e0       	ldi	r25, 0x09	; 9
    926a:	e0 91 9a 01 	lds	r30, 0x019A
    926e:	e9 9f       	mul	r30, r25
    9270:	f0 01       	movw	r30, r0
    9272:	11 24       	eor	r1, r1
    9274:	ef 55       	subi	r30, 0x5F	; 95
    9276:	fe 4f       	sbci	r31, 0xFE	; 254
    9278:	80 81       	ld	r24, Z
    927a:	88 23       	and	r24, r24
    927c:	79 f3       	breq	.-34     	; 0x925c <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    927e:	90 91 9a 01 	lds	r25, 0x019A
    9282:	89 e0       	ldi	r24, 0x09	; 9
    9284:	98 9f       	mul	r25, r24
    9286:	d0 01       	movw	r26, r0
    9288:	11 24       	eor	r1, r1
    928a:	af 55       	subi	r26, 0x5F	; 95
    928c:	be 4f       	sbci	r27, 0xFE	; 254
    928e:	11 96       	adiw	r26, 0x01	; 1
    9290:	ed 91       	ld	r30, X+
    9292:	fc 91       	ld	r31, X
    9294:	12 97       	sbiw	r26, 0x02	; 2
    9296:	02 80       	ldd	r0, Z+2	; 0x02
    9298:	f3 81       	ldd	r31, Z+3	; 0x03
    929a:	e0 2d       	mov	r30, r0
    929c:	12 96       	adiw	r26, 0x02	; 2
    929e:	fc 93       	st	X, r31
    92a0:	ee 93       	st	-X, r30
    92a2:	11 97       	sbiw	r26, 0x01	; 1
    92a4:	cd 01       	movw	r24, r26
    92a6:	03 96       	adiw	r24, 0x03	; 3
    92a8:	e8 17       	cp	r30, r24
    92aa:	f9 07       	cpc	r31, r25
    92ac:	31 f4       	brne	.+12     	; 0x92ba <vTaskSwitchContext+0x6e>
    92ae:	82 81       	ldd	r24, Z+2	; 0x02
    92b0:	93 81       	ldd	r25, Z+3	; 0x03
    92b2:	12 96       	adiw	r26, 0x02	; 2
    92b4:	9c 93       	st	X, r25
    92b6:	8e 93       	st	-X, r24
    92b8:	11 97       	sbiw	r26, 0x01	; 1
    92ba:	11 96       	adiw	r26, 0x01	; 1
    92bc:	ed 91       	ld	r30, X+
    92be:	fc 91       	ld	r31, X
    92c0:	12 97       	sbiw	r26, 0x02	; 2
    92c2:	86 81       	ldd	r24, Z+6	; 0x06
    92c4:	97 81       	ldd	r25, Z+7	; 0x07
    92c6:	90 93 94 01 	sts	0x0194, r25
    92ca:	80 93 93 01 	sts	0x0193, r24

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
    92ce:	80 91 9b 01 	lds	r24, 0x019B
    92d2:	88 23       	and	r24, r24
    92d4:	09 f4       	brne	.+2      	; 0x92d8 <vTaskSwitchContext+0x8c>
    92d6:	4b c0       	rjmp	.+150    	; 0x936e <vTaskSwitchContext+0x122>
    92d8:	e0 91 93 01 	lds	r30, 0x0193
    92dc:	f0 91 94 01 	lds	r31, 0x0194
    92e0:	90 91 81 01 	lds	r25, 0x0181
    92e4:	83 a1       	ldd	r24, Z+35	; 0x23
    92e6:	98 17       	cp	r25, r24
    92e8:	09 f4       	brne	.+2      	; 0x92ec <vTaskSwitchContext+0xa0>
    92ea:	41 c0       	rjmp	.+130    	; 0x936e <vTaskSwitchContext+0x122>
    92ec:	80 91 e4 01 	lds	r24, 0x01E4
    92f0:	90 91 e5 01 	lds	r25, 0x01E5
    92f4:	08 96       	adiw	r24, 0x08	; 8
    92f6:	20 91 e8 01 	lds	r18, 0x01E8
    92fa:	30 91 e9 01 	lds	r19, 0x01E9
    92fe:	82 17       	cp	r24, r18
    9300:	93 07       	cpc	r25, r19
    9302:	98 f5       	brcc	.+102    	; 0x936a <vTaskSwitchContext+0x11e>
    9304:	e0 91 93 01 	lds	r30, 0x0193
    9308:	f0 91 94 01 	lds	r31, 0x0194
    930c:	23 a1       	ldd	r18, Z+35	; 0x23
    930e:	20 93 81 01 	sts	0x0181, r18
    9312:	e0 91 e4 01 	lds	r30, 0x01E4
    9316:	f0 91 e5 01 	lds	r31, 0x01E5
    931a:	80 91 97 01 	lds	r24, 0x0197
    931e:	90 91 98 01 	lds	r25, 0x0198
    9322:	a0 e0       	ldi	r26, 0x00	; 0
    9324:	b0 e0       	ldi	r27, 0x00	; 0
    9326:	80 83       	st	Z, r24
    9328:	91 83       	std	Z+1, r25	; 0x01
    932a:	a2 83       	std	Z+2, r26	; 0x02
    932c:	b3 83       	std	Z+3, r27	; 0x03
    932e:	80 91 e4 01 	lds	r24, 0x01E4
    9332:	90 91 e5 01 	lds	r25, 0x01E5
    9336:	04 96       	adiw	r24, 0x04	; 4
    9338:	90 93 e5 01 	sts	0x01E5, r25
    933c:	80 93 e4 01 	sts	0x01E4, r24
    9340:	e0 91 e4 01 	lds	r30, 0x01E4
    9344:	f0 91 e5 01 	lds	r31, 0x01E5
    9348:	30 e0       	ldi	r19, 0x00	; 0
    934a:	40 e0       	ldi	r20, 0x00	; 0
    934c:	50 e0       	ldi	r21, 0x00	; 0
    934e:	20 83       	st	Z, r18
    9350:	31 83       	std	Z+1, r19	; 0x01
    9352:	42 83       	std	Z+2, r20	; 0x02
    9354:	53 83       	std	Z+3, r21	; 0x03
    9356:	80 91 e4 01 	lds	r24, 0x01E4
    935a:	90 91 e5 01 	lds	r25, 0x01E5
    935e:	04 96       	adiw	r24, 0x04	; 4
    9360:	90 93 e5 01 	sts	0x01E5, r25
    9364:	80 93 e4 01 	sts	0x01E4, r24
    9368:	08 95       	ret
    936a:	10 92 9b 01 	sts	0x019B, r1
    936e:	08 95       	ret

00009370 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    9370:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    9372:	80 91 96 01 	lds	r24, 0x0196
    9376:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    9378:	80 91 97 01 	lds	r24, 0x0197
    937c:	90 91 98 01 	lds	r25, 0x0198
    9380:	92 83       	std	Z+2, r25	; 0x02
    9382:	81 83       	std	Z+1, r24	; 0x01
}
    9384:	08 95       	ret

00009386 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    9386:	fc 01       	movw	r30, r24
    9388:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    938a:	0f b6       	in	r0, 0x3f	; 63
    938c:	f8 94       	cli
    938e:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    9390:	4d 91       	ld	r20, X+
    9392:	5c 91       	ld	r21, X
    9394:	11 97       	sbiw	r26, 0x01	; 1
    9396:	8f ef       	ldi	r24, 0xFF	; 255
    9398:	4f 3f       	cpi	r20, 0xFF	; 255
    939a:	58 07       	cpc	r21, r24
    939c:	61 f1       	breq	.+88     	; 0x93f6 <xTaskCheckForTimeOut+0x70>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    939e:	90 91 96 01 	lds	r25, 0x0196
    93a2:	80 81       	ld	r24, Z
    93a4:	98 17       	cp	r25, r24
    93a6:	49 f0       	breq	.+18     	; 0x93ba <xTaskCheckForTimeOut+0x34>
    93a8:	20 91 97 01 	lds	r18, 0x0197
    93ac:	30 91 98 01 	lds	r19, 0x0198
    93b0:	81 81       	ldd	r24, Z+1	; 0x01
    93b2:	92 81       	ldd	r25, Z+2	; 0x02
    93b4:	28 17       	cp	r18, r24
    93b6:	39 07       	cpc	r19, r25
    93b8:	00 f5       	brcc	.+64     	; 0x93fa <xTaskCheckForTimeOut+0x74>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    93ba:	80 91 97 01 	lds	r24, 0x0197
    93be:	90 91 98 01 	lds	r25, 0x0198
    93c2:	21 81       	ldd	r18, Z+1	; 0x01
    93c4:	32 81       	ldd	r19, Z+2	; 0x02
    93c6:	82 1b       	sub	r24, r18
    93c8:	93 0b       	sbc	r25, r19
    93ca:	84 17       	cp	r24, r20
    93cc:	95 07       	cpc	r25, r21
    93ce:	a8 f4       	brcc	.+42     	; 0x93fa <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    93d0:	80 91 97 01 	lds	r24, 0x0197
    93d4:	90 91 98 01 	lds	r25, 0x0198
    93d8:	28 1b       	sub	r18, r24
    93da:	39 0b       	sbc	r19, r25
    93dc:	24 0f       	add	r18, r20
    93de:	35 1f       	adc	r19, r21
    93e0:	2d 93       	st	X+, r18
    93e2:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    93e4:	80 91 96 01 	lds	r24, 0x0196
    93e8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    93ea:	80 91 97 01 	lds	r24, 0x0197
    93ee:	90 91 98 01 	lds	r25, 0x0198
    93f2:	92 83       	std	Z+2, r25	; 0x02
    93f4:	81 83       	std	Z+1, r24	; 0x01
    93f6:	80 e0       	ldi	r24, 0x00	; 0
    93f8:	01 c0       	rjmp	.+2      	; 0x93fc <xTaskCheckForTimeOut+0x76>
    93fa:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    93fc:	0f 90       	pop	r0
    93fe:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    9400:	08 95       	ret

00009402 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    9402:	81 e0       	ldi	r24, 0x01	; 1
    9404:	80 93 95 01 	sts	0x0195, r24
}
    9408:	08 95       	ret

0000940a <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    940a:	0f 93       	push	r16
    940c:	1f 93       	push	r17
    940e:	cf 93       	push	r28
    9410:	df 93       	push	r29
    9412:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    9414:	80 81       	ld	r24, Z
    9416:	88 23       	and	r24, r24
    9418:	19 f4       	brne	.+6      	; 0x9420 <xTaskRemoveFromEventList+0x16>
    941a:	c0 e0       	ldi	r28, 0x00	; 0
    941c:	d0 e0       	ldi	r29, 0x00	; 0
    941e:	05 c0       	rjmp	.+10     	; 0x942a <xTaskRemoveFromEventList+0x20>
    9420:	05 80       	ldd	r0, Z+5	; 0x05
    9422:	f6 81       	ldd	r31, Z+6	; 0x06
    9424:	e0 2d       	mov	r30, r0
    9426:	c6 81       	ldd	r28, Z+6	; 0x06
    9428:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    942a:	8e 01       	movw	r16, r28
    942c:	04 5f       	subi	r16, 0xF4	; 244
    942e:	1f 4f       	sbci	r17, 0xFF	; 255
    9430:	c8 01       	movw	r24, r16
    9432:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9436:	80 91 99 01 	lds	r24, 0x0199
    943a:	88 23       	and	r24, r24
    943c:	a1 f4       	brne	.+40     	; 0x9466 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    943e:	8e 01       	movw	r16, r28
    9440:	0e 5f       	subi	r16, 0xFE	; 254
    9442:	1f 4f       	sbci	r17, 0xFF	; 255
    9444:	c8 01       	movw	r24, r16
    9446:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    944a:	9e 89       	ldd	r25, Y+22	; 0x16
    944c:	80 91 9a 01 	lds	r24, 0x019A
    9450:	89 17       	cp	r24, r25
    9452:	10 f4       	brcc	.+4      	; 0x9458 <xTaskRemoveFromEventList+0x4e>
    9454:	90 93 9a 01 	sts	0x019A, r25
    9458:	89 e0       	ldi	r24, 0x09	; 9
    945a:	98 9f       	mul	r25, r24
    945c:	c0 01       	movw	r24, r0
    945e:	11 24       	eor	r1, r1
    9460:	8f 55       	subi	r24, 0x5F	; 95
    9462:	9e 4f       	sbci	r25, 0xFE	; 254
    9464:	02 c0       	rjmp	.+4      	; 0x946a <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    9466:	82 ed       	ldi	r24, 0xD2	; 210
    9468:	91 e0       	ldi	r25, 0x01	; 1
    946a:	b8 01       	movw	r22, r16
    946c:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9470:	e0 91 93 01 	lds	r30, 0x0193
    9474:	f0 91 94 01 	lds	r31, 0x0194
    9478:	20 e0       	ldi	r18, 0x00	; 0
    947a:	9e 89       	ldd	r25, Y+22	; 0x16
    947c:	86 89       	ldd	r24, Z+22	; 0x16
    947e:	98 17       	cp	r25, r24
    9480:	08 f0       	brcs	.+2      	; 0x9484 <xTaskRemoveFromEventList+0x7a>
    9482:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    9484:	82 2f       	mov	r24, r18
    9486:	df 91       	pop	r29
    9488:	cf 91       	pop	r28
    948a:	1f 91       	pop	r17
    948c:	0f 91       	pop	r16
    948e:	08 95       	ret

00009490 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    9490:	df 92       	push	r13
    9492:	ef 92       	push	r14
    9494:	ff 92       	push	r15
    9496:	0f 93       	push	r16
    9498:	1f 93       	push	r17
    949a:	cf 93       	push	r28
    949c:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
    949e:	ec 01       	movw	r28, r24
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    94a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    94a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    94a4:	8b 5d       	subi	r24, 0xDB	; 219
    94a6:	91 40       	sbci	r25, 0x01	; 1
    94a8:	91 f5       	brne	.+100    	; 0x950e <xTaskResumeFromISR+0x7e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    94aa:	8c 89       	ldd	r24, Y+20	; 0x14
    94ac:	9d 89       	ldd	r25, Y+21	; 0x15
    94ae:	21 e0       	ldi	r18, 0x01	; 1
    94b0:	82 3d       	cpi	r24, 0xD2	; 210
    94b2:	92 07       	cpc	r25, r18
    94b4:	61 f1       	breq	.+88     	; 0x950e <xTaskResumeFromISR+0x7e>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    94b6:	89 2b       	or	r24, r25
    94b8:	51 f5       	brne	.+84     	; 0x950e <xTaskResumeFromISR+0x7e>
    94ba:	33 c0       	rjmp	.+102    	; 0x9522 <xTaskResumeFromISR+0x92>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    94bc:	de 88       	ldd	r13, Y+22	; 0x16
    94be:	e0 91 93 01 	lds	r30, 0x0193
    94c2:	f0 91 94 01 	lds	r31, 0x0194
    94c6:	06 89       	ldd	r16, Z+22	; 0x16
				vListRemove(  &( pxTCB->xGenericListItem ) );
    94c8:	82 e0       	ldi	r24, 0x02	; 2
    94ca:	e8 2e       	mov	r14, r24
    94cc:	f1 2c       	mov	r15, r1
    94ce:	ec 0e       	add	r14, r28
    94d0:	fd 1e       	adc	r15, r29
    94d2:	c7 01       	movw	r24, r14
    94d4:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    94d8:	6e 89       	ldd	r22, Y+22	; 0x16
    94da:	80 91 9a 01 	lds	r24, 0x019A
    94de:	86 17       	cp	r24, r22
    94e0:	10 f4       	brcc	.+4      	; 0x94e6 <xTaskResumeFromISR+0x56>
    94e2:	60 93 9a 01 	sts	0x019A, r22
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    94e6:	10 e0       	ldi	r17, 0x00	; 0
    94e8:	d0 16       	cp	r13, r16
    94ea:	08 f0       	brcs	.+2      	; 0x94ee <xTaskResumeFromISR+0x5e>
    94ec:	11 e0       	ldi	r17, 0x01	; 1
				vListRemove(  &( pxTCB->xGenericListItem ) );
				prvAddTaskToReadyQueue( pxTCB );
    94ee:	89 e0       	ldi	r24, 0x09	; 9
    94f0:	68 9f       	mul	r22, r24
    94f2:	c0 01       	movw	r24, r0
    94f4:	11 24       	eor	r1, r1
    94f6:	8f 55       	subi	r24, 0x5F	; 95
    94f8:	9e 4f       	sbci	r25, 0xFE	; 254
    94fa:	b7 01       	movw	r22, r14
    94fc:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
    9500:	07 c0       	rjmp	.+14     	; 0x9510 <xTaskResumeFromISR+0x80>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    9502:	2c 96       	adiw	r28, 0x0c	; 12
    9504:	82 ed       	ldi	r24, 0xD2	; 210
    9506:	91 e0       	ldi	r25, 0x01	; 1
    9508:	be 01       	movw	r22, r28
    950a:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
    950e:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		return xYieldRequired;
	}
    9510:	81 2f       	mov	r24, r17
    9512:	df 91       	pop	r29
    9514:	cf 91       	pop	r28
    9516:	1f 91       	pop	r17
    9518:	0f 91       	pop	r16
    951a:	ff 90       	pop	r15
    951c:	ef 90       	pop	r14
    951e:	df 90       	pop	r13
    9520:	08 95       	ret

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9522:	80 91 99 01 	lds	r24, 0x0199
    9526:	88 23       	and	r24, r24
    9528:	49 f2       	breq	.-110    	; 0x94bc <xTaskResumeFromISR+0x2c>
    952a:	eb cf       	rjmp	.-42     	; 0x9502 <xTaskResumeFromISR+0x72>

0000952c <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    952c:	cf 93       	push	r28
    952e:	df 93       	push	r29
    9530:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    9532:	60 91 93 01 	lds	r22, 0x0193
    9536:	70 91 94 01 	lds	r23, 0x0194
    953a:	64 5f       	subi	r22, 0xF4	; 244
    953c:	7f 4f       	sbci	r23, 0xFF	; 255
    953e:	0e 94 27 53 	call	0xa64e	; 0xa64e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9542:	80 91 93 01 	lds	r24, 0x0193
    9546:	90 91 94 01 	lds	r25, 0x0194
    954a:	02 96       	adiw	r24, 0x02	; 2
    954c:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    9550:	8f ef       	ldi	r24, 0xFF	; 255
    9552:	cf 3f       	cpi	r28, 0xFF	; 255
    9554:	d8 07       	cpc	r29, r24
    9556:	59 f4       	brne	.+22     	; 0x956e <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9558:	60 91 93 01 	lds	r22, 0x0193
    955c:	70 91 94 01 	lds	r23, 0x0194
    9560:	6e 5f       	subi	r22, 0xFE	; 254
    9562:	7f 4f       	sbci	r23, 0xFF	; 255
    9564:	8b ed       	ldi	r24, 0xDB	; 219
    9566:	91 e0       	ldi	r25, 0x01	; 1
    9568:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
    956c:	24 c0       	rjmp	.+72     	; 0x95b6 <vTaskPlaceOnEventList+0x8a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    956e:	80 91 97 01 	lds	r24, 0x0197
    9572:	90 91 98 01 	lds	r25, 0x0198
    9576:	8c 0f       	add	r24, r28
    9578:	9d 1f       	adc	r25, r29

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    957a:	e0 91 93 01 	lds	r30, 0x0193
    957e:	f0 91 94 01 	lds	r31, 0x0194
    9582:	93 83       	std	Z+3, r25	; 0x03
    9584:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    9586:	20 91 97 01 	lds	r18, 0x0197
    958a:	30 91 98 01 	lds	r19, 0x0198
    958e:	82 17       	cp	r24, r18
    9590:	93 07       	cpc	r25, r19
    9592:	28 f4       	brcc	.+10     	; 0x959e <vTaskPlaceOnEventList+0x72>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9594:	80 91 d0 01 	lds	r24, 0x01D0
    9598:	90 91 d1 01 	lds	r25, 0x01D1
    959c:	04 c0       	rjmp	.+8      	; 0x95a6 <vTaskPlaceOnEventList+0x7a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    959e:	80 91 ce 01 	lds	r24, 0x01CE
    95a2:	90 91 cf 01 	lds	r25, 0x01CF
    95a6:	60 91 93 01 	lds	r22, 0x0193
    95aa:	70 91 94 01 	lds	r23, 0x0194
    95ae:	6e 5f       	subi	r22, 0xFE	; 254
    95b0:	7f 4f       	sbci	r23, 0xFF	; 255
    95b2:	0e 94 27 53 	call	0xa64e	; 0xa64e <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    95b6:	df 91       	pop	r29
    95b8:	cf 91       	pop	r28
    95ba:	08 95       	ret

000095bc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    95bc:	ff 92       	push	r15
    95be:	0f 93       	push	r16
    95c0:	1f 93       	push	r17
    95c2:	cf 93       	push	r28
    95c4:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    95c6:	80 91 99 01 	lds	r24, 0x0199
    95ca:	88 23       	and	r24, r24
    95cc:	09 f0       	breq	.+2      	; 0x95d0 <vTaskIncrementTick+0x14>
    95ce:	61 c0       	rjmp	.+194    	; 0x9692 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    95d0:	80 91 97 01 	lds	r24, 0x0197
    95d4:	90 91 98 01 	lds	r25, 0x0198
    95d8:	01 96       	adiw	r24, 0x01	; 1
    95da:	90 93 98 01 	sts	0x0198, r25
    95de:	80 93 97 01 	sts	0x0197, r24
		if( xTickCount == ( portTickType ) 0 )
    95e2:	80 91 97 01 	lds	r24, 0x0197
    95e6:	90 91 98 01 	lds	r25, 0x0198
    95ea:	89 2b       	or	r24, r25
    95ec:	e9 f5       	brne	.+122    	; 0x9668 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    95ee:	80 91 ce 01 	lds	r24, 0x01CE
    95f2:	90 91 cf 01 	lds	r25, 0x01CF
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    95f6:	20 91 d0 01 	lds	r18, 0x01D0
    95fa:	30 91 d1 01 	lds	r19, 0x01D1
    95fe:	30 93 cf 01 	sts	0x01CF, r19
    9602:	20 93 ce 01 	sts	0x01CE, r18
			pxOverflowDelayedTaskList = pxTemp;
    9606:	90 93 d1 01 	sts	0x01D1, r25
    960a:	80 93 d0 01 	sts	0x01D0, r24
			xNumOfOverflows++;
    960e:	80 91 96 01 	lds	r24, 0x0196
    9612:	8f 5f       	subi	r24, 0xFF	; 255
    9614:	80 93 96 01 	sts	0x0196, r24
    9618:	27 c0       	rjmp	.+78     	; 0x9668 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    961a:	20 91 97 01 	lds	r18, 0x0197
    961e:	30 91 98 01 	lds	r19, 0x0198
    9622:	8a 81       	ldd	r24, Y+2	; 0x02
    9624:	9b 81       	ldd	r25, Y+3	; 0x03
    9626:	28 17       	cp	r18, r24
    9628:	39 07       	cpc	r19, r25
    962a:	d0 f1       	brcs	.+116    	; 0x96a0 <vTaskIncrementTick+0xe4>
    962c:	8e 01       	movw	r16, r28
    962e:	0e 5f       	subi	r16, 0xFE	; 254
    9630:	1f 4f       	sbci	r17, 0xFF	; 255
    9632:	c8 01       	movw	r24, r16
    9634:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
    9638:	8c 89       	ldd	r24, Y+20	; 0x14
    963a:	9d 89       	ldd	r25, Y+21	; 0x15
    963c:	89 2b       	or	r24, r25
    963e:	21 f0       	breq	.+8      	; 0x9648 <vTaskIncrementTick+0x8c>
    9640:	ce 01       	movw	r24, r28
    9642:	0c 96       	adiw	r24, 0x0c	; 12
    9644:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
    9648:	9e 89       	ldd	r25, Y+22	; 0x16
    964a:	80 91 9a 01 	lds	r24, 0x019A
    964e:	89 17       	cp	r24, r25
    9650:	10 f4       	brcc	.+4      	; 0x9656 <vTaskIncrementTick+0x9a>
    9652:	90 93 9a 01 	sts	0x019A, r25
    9656:	9f 9d       	mul	r25, r15
    9658:	c0 01       	movw	r24, r0
    965a:	11 24       	eor	r1, r1
    965c:	8f 55       	subi	r24, 0x5F	; 95
    965e:	9e 4f       	sbci	r25, 0xFE	; 254
    9660:	b8 01       	movw	r22, r16
    9662:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
    9666:	02 c0       	rjmp	.+4      	; 0x966c <vTaskIncrementTick+0xb0>
    9668:	99 e0       	ldi	r25, 0x09	; 9
    966a:	f9 2e       	mov	r15, r25
    966c:	e0 91 ce 01 	lds	r30, 0x01CE
    9670:	f0 91 cf 01 	lds	r31, 0x01CF
    9674:	80 81       	ld	r24, Z
    9676:	88 23       	and	r24, r24
    9678:	99 f0       	breq	.+38     	; 0x96a0 <vTaskIncrementTick+0xe4>
    967a:	e0 91 ce 01 	lds	r30, 0x01CE
    967e:	f0 91 cf 01 	lds	r31, 0x01CF
    9682:	05 80       	ldd	r0, Z+5	; 0x05
    9684:	f6 81       	ldd	r31, Z+6	; 0x06
    9686:	e0 2d       	mov	r30, r0
    9688:	c6 81       	ldd	r28, Z+6	; 0x06
    968a:	d7 81       	ldd	r29, Z+7	; 0x07
    968c:	20 97       	sbiw	r28, 0x00	; 0
    968e:	29 f6       	brne	.-118    	; 0x961a <vTaskIncrementTick+0x5e>
    9690:	07 c0       	rjmp	.+14     	; 0x96a0 <vTaskIncrementTick+0xe4>
	}
	else
	{
		++uxMissedTicks;
    9692:	80 91 9c 01 	lds	r24, 0x019C
    9696:	8f 5f       	subi	r24, 0xFF	; 255
    9698:	80 93 9c 01 	sts	0x019C, r24
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
    969c:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
    96a0:	80 91 9c 01 	lds	r24, 0x019C
    96a4:	88 23       	and	r24, r24
    96a6:	11 f4       	brne	.+4      	; 0x96ac <vTaskIncrementTick+0xf0>
		{
			vApplicationTickHook();
    96a8:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    96ac:	df 91       	pop	r29
    96ae:	cf 91       	pop	r28
    96b0:	1f 91       	pop	r17
    96b2:	0f 91       	pop	r16
    96b4:	ff 90       	pop	r15
    96b6:	08 95       	ret

000096b8 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
    96b8:	4f 92       	push	r4
    96ba:	5f 92       	push	r5
    96bc:	6f 92       	push	r6
    96be:	7f 92       	push	r7
    96c0:	8f 92       	push	r8
    96c2:	9f 92       	push	r9
    96c4:	af 92       	push	r10
    96c6:	bf 92       	push	r11
    96c8:	cf 92       	push	r12
    96ca:	df 92       	push	r13
    96cc:	ef 92       	push	r14
    96ce:	ff 92       	push	r15
    96d0:	0f 93       	push	r16
    96d2:	1f 93       	push	r17
    96d4:	cf 93       	push	r28
    96d6:	df 93       	push	r29
    96d8:	4c 01       	movw	r8, r24
    96da:	8b 01       	movw	r16, r22
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    96dc:	db 01       	movw	r26, r22
    96de:	11 96       	adiw	r26, 0x01	; 1
    96e0:	ed 91       	ld	r30, X+
    96e2:	fc 91       	ld	r31, X
    96e4:	12 97       	sbiw	r26, 0x02	; 2
    96e6:	02 80       	ldd	r0, Z+2	; 0x02
    96e8:	f3 81       	ldd	r31, Z+3	; 0x03
    96ea:	e0 2d       	mov	r30, r0
    96ec:	12 96       	adiw	r26, 0x02	; 2
    96ee:	fc 93       	st	X, r31
    96f0:	ee 93       	st	-X, r30
    96f2:	11 97       	sbiw	r26, 0x01	; 1
    96f4:	cb 01       	movw	r24, r22
    96f6:	03 96       	adiw	r24, 0x03	; 3
    96f8:	e8 17       	cp	r30, r24
    96fa:	f9 07       	cpc	r31, r25
    96fc:	31 f4       	brne	.+12     	; 0x970a <prvListTaskWithinSingleList+0x52>
    96fe:	82 81       	ldd	r24, Z+2	; 0x02
    9700:	93 81       	ldd	r25, Z+3	; 0x03
    9702:	12 96       	adiw	r26, 0x02	; 2
    9704:	9c 93       	st	X, r25
    9706:	8e 93       	st	-X, r24
    9708:	11 97       	sbiw	r26, 0x01	; 1
    970a:	d8 01       	movw	r26, r16
    970c:	11 96       	adiw	r26, 0x01	; 1
    970e:	ed 91       	ld	r30, X+
    9710:	fc 91       	ld	r31, X
    9712:	12 97       	sbiw	r26, 0x02	; 2
    9714:	a6 80       	ldd	r10, Z+6	; 0x06
    9716:	b7 80       	ldd	r11, Z+7	; 0x07
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    9718:	53 e0       	ldi	r21, 0x03	; 3
    971a:	e5 2e       	mov	r14, r21
    971c:	f1 2c       	mov	r15, r1
    971e:	e0 0e       	add	r14, r16
    9720:	f1 1e       	adc	r15, r17
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    9722:	3a ee       	ldi	r19, 0xEA	; 234
    9724:	63 2e       	mov	r6, r19
    9726:	31 e0       	ldi	r19, 0x01	; 1
    9728:	73 2e       	mov	r7, r19
    972a:	27 e6       	ldi	r18, 0x67	; 103
    972c:	42 2e       	mov	r4, r18
    972e:	21 e0       	ldi	r18, 0x01	; 1
    9730:	52 2e       	mov	r5, r18
    9732:	c4 2e       	mov	r12, r20
    9734:	dd 24       	eor	r13, r13
    9736:	c7 fc       	sbrc	r12, 7
    9738:	d0 94       	com	r13

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    973a:	d8 01       	movw	r26, r16
    973c:	11 96       	adiw	r26, 0x01	; 1
    973e:	ed 91       	ld	r30, X+
    9740:	fc 91       	ld	r31, X
    9742:	12 97       	sbiw	r26, 0x02	; 2
    9744:	82 81       	ldd	r24, Z+2	; 0x02
    9746:	93 81       	ldd	r25, Z+3	; 0x03
    9748:	12 96       	adiw	r26, 0x02	; 2
    974a:	9c 93       	st	X, r25
    974c:	8e 93       	st	-X, r24
    974e:	11 97       	sbiw	r26, 0x01	; 1
    9750:	8e 15       	cp	r24, r14
    9752:	9f 05       	cpc	r25, r15
    9754:	39 f4       	brne	.+14     	; 0x9764 <prvListTaskWithinSingleList+0xac>
    9756:	f7 01       	movw	r30, r14
    9758:	82 81       	ldd	r24, Z+2	; 0x02
    975a:	93 81       	ldd	r25, Z+3	; 0x03
    975c:	12 96       	adiw	r26, 0x02	; 2
    975e:	9c 93       	st	X, r25
    9760:	8e 93       	st	-X, r24
    9762:	11 97       	sbiw	r26, 0x01	; 1
    9764:	d8 01       	movw	r26, r16
    9766:	11 96       	adiw	r26, 0x01	; 1
    9768:	ed 91       	ld	r30, X+
    976a:	fc 91       	ld	r31, X
    976c:	12 97       	sbiw	r26, 0x02	; 2
    976e:	c6 81       	ldd	r28, Z+6	; 0x06
    9770:	d7 81       	ldd	r29, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
    9772:	ef 89       	ldd	r30, Y+23	; 0x17
    9774:	f8 8d       	ldd	r31, Y+24	; 0x18
    9776:	20 e0       	ldi	r18, 0x00	; 0
    9778:	30 e0       	ldi	r19, 0x00	; 0
    977a:	03 c0       	rjmp	.+6      	; 0x9782 <prvListTaskWithinSingleList+0xca>
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
    977c:	31 96       	adiw	r30, 0x01	; 1
			usCount++;
    977e:	2f 5f       	subi	r18, 0xFF	; 255
    9780:	3f 4f       	sbci	r19, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    9782:	80 81       	ld	r24, Z
    9784:	85 3a       	cpi	r24, 0xA5	; 165
    9786:	d1 f3       	breq	.-12     	; 0x977c <prvListTaskWithinSingleList+0xc4>
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    9788:	8e 89       	ldd	r24, Y+22	; 0x16
    978a:	9b a1       	ldd	r25, Y+35	; 0x23
    978c:	ed b7       	in	r30, 0x3d	; 61
    978e:	fe b7       	in	r31, 0x3e	; 62
    9790:	3e 97       	sbiw	r30, 0x0e	; 14
    9792:	0f b6       	in	r0, 0x3f	; 63
    9794:	f8 94       	cli
    9796:	fe bf       	out	0x3e, r31	; 62
    9798:	0f be       	out	0x3f, r0	; 63
    979a:	ed bf       	out	0x3d, r30	; 61
    979c:	31 96       	adiw	r30, 0x01	; 1
    979e:	ad b7       	in	r26, 0x3d	; 61
    97a0:	be b7       	in	r27, 0x3e	; 62
    97a2:	12 96       	adiw	r26, 0x02	; 2
    97a4:	7c 92       	st	X, r7
    97a6:	6e 92       	st	-X, r6
    97a8:	11 97       	sbiw	r26, 0x01	; 1
    97aa:	53 82       	std	Z+3, r5	; 0x03
    97ac:	42 82       	std	Z+2, r4	; 0x02
    97ae:	69 96       	adiw	r28, 0x19	; 25
    97b0:	d5 83       	std	Z+5, r29	; 0x05
    97b2:	c4 83       	std	Z+4, r28	; 0x04
    97b4:	69 97       	sbiw	r28, 0x19	; 25
    97b6:	d7 82       	std	Z+7, r13	; 0x07
    97b8:	c6 82       	std	Z+6, r12	; 0x06
    97ba:	80 87       	std	Z+8, r24	; 0x08
    97bc:	11 86       	std	Z+9, r1	; 0x09
    97be:	33 87       	std	Z+11, r19	; 0x0b
    97c0:	22 87       	std	Z+10, r18	; 0x0a
    97c2:	94 87       	std	Z+12, r25	; 0x0c
    97c4:	15 86       	std	Z+13, r1	; 0x0d
    97c6:	0e 94 77 5a 	call	0xb4ee	; 0xb4ee <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
    97ca:	ed b7       	in	r30, 0x3d	; 61
    97cc:	fe b7       	in	r31, 0x3e	; 62
    97ce:	3e 96       	adiw	r30, 0x0e	; 14
    97d0:	0f b6       	in	r0, 0x3f	; 63
    97d2:	f8 94       	cli
    97d4:	fe bf       	out	0x3e, r31	; 62
    97d6:	0f be       	out	0x3f, r0	; 63
    97d8:	ed bf       	out	0x3d, r30	; 61
    97da:	c4 01       	movw	r24, r8
    97dc:	b3 01       	movw	r22, r6
    97de:	0e 94 55 59 	call	0xb2aa	; 0xb2aa <strcat>

		} while( pxNextTCB != pxFirstTCB );
    97e2:	ca 15       	cp	r28, r10
    97e4:	db 05       	cpc	r29, r11
    97e6:	09 f0       	breq	.+2      	; 0x97ea <prvListTaskWithinSingleList+0x132>
    97e8:	a8 cf       	rjmp	.-176    	; 0x973a <prvListTaskWithinSingleList+0x82>
	}
    97ea:	df 91       	pop	r29
    97ec:	cf 91       	pop	r28
    97ee:	1f 91       	pop	r17
    97f0:	0f 91       	pop	r16
    97f2:	ff 90       	pop	r15
    97f4:	ef 90       	pop	r14
    97f6:	df 90       	pop	r13
    97f8:	cf 90       	pop	r12
    97fa:	bf 90       	pop	r11
    97fc:	af 90       	pop	r10
    97fe:	9f 90       	pop	r9
    9800:	8f 90       	pop	r8
    9802:	7f 90       	pop	r7
    9804:	6f 90       	pop	r6
    9806:	5f 90       	pop	r5
    9808:	4f 90       	pop	r4
    980a:	08 95       	ret

0000980c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    980c:	cf 92       	push	r12
    980e:	df 92       	push	r13
    9810:	ff 92       	push	r15
    9812:	0f 93       	push	r16
    9814:	1f 93       	push	r17
    9816:	df 93       	push	r29
    9818:	cf 93       	push	r28
    981a:	0f 92       	push	r0
    981c:	cd b7       	in	r28, 0x3d	; 61
    981e:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    9820:	0f b6       	in	r0, 0x3f	; 63
    9822:	f8 94       	cli
    9824:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    9826:	80 91 99 01 	lds	r24, 0x0199
    982a:	81 50       	subi	r24, 0x01	; 1
    982c:	80 93 99 01 	sts	0x0199, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9830:	80 91 99 01 	lds	r24, 0x0199
    9834:	88 23       	and	r24, r24
    9836:	09 f0       	breq	.+2      	; 0x983a <xTaskResumeAll+0x2e>
    9838:	5a c0       	rjmp	.+180    	; 0x98ee <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    983a:	80 91 9e 01 	lds	r24, 0x019E
    983e:	88 23       	and	r24, r24
    9840:	09 f4       	brne	.+2      	; 0x9844 <xTaskResumeAll+0x38>
    9842:	55 c0       	rjmp	.+170    	; 0x98ee <xTaskResumeAll+0xe2>
    9844:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    9846:	69 e0       	ldi	r22, 0x09	; 9
    9848:	f6 2e       	mov	r15, r22
    984a:	27 c0       	rjmp	.+78     	; 0x989a <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    984c:	c6 01       	movw	r24, r12
    984e:	0c 96       	adiw	r24, 0x0c	; 12
    9850:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    9854:	86 01       	movw	r16, r12
    9856:	0e 5f       	subi	r16, 0xFE	; 254
    9858:	1f 4f       	sbci	r17, 0xFF	; 255
    985a:	c8 01       	movw	r24, r16
    985c:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    9860:	d6 01       	movw	r26, r12
    9862:	56 96       	adiw	r26, 0x16	; 22
    9864:	9c 91       	ld	r25, X
    9866:	80 91 9a 01 	lds	r24, 0x019A
    986a:	89 17       	cp	r24, r25
    986c:	10 f4       	brcc	.+4      	; 0x9872 <xTaskResumeAll+0x66>
    986e:	90 93 9a 01 	sts	0x019A, r25
    9872:	9f 9d       	mul	r25, r15
    9874:	c0 01       	movw	r24, r0
    9876:	11 24       	eor	r1, r1
    9878:	8f 55       	subi	r24, 0x5F	; 95
    987a:	9e 4f       	sbci	r25, 0xFE	; 254
    987c:	b8 01       	movw	r22, r16
    987e:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9882:	e0 91 93 01 	lds	r30, 0x0193
    9886:	f0 91 94 01 	lds	r31, 0x0194
    988a:	d6 01       	movw	r26, r12
    988c:	56 96       	adiw	r26, 0x16	; 22
    988e:	9c 91       	ld	r25, X
    9890:	86 89       	ldd	r24, Z+22	; 0x16
    9892:	98 17       	cp	r25, r24
    9894:	10 f0       	brcs	.+4      	; 0x989a <xTaskResumeAll+0x8e>
    9896:	b1 e0       	ldi	r27, 0x01	; 1
    9898:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    989a:	80 91 d2 01 	lds	r24, 0x01D2
    989e:	88 23       	and	r24, r24
    98a0:	49 f0       	breq	.+18     	; 0x98b4 <xTaskResumeAll+0xa8>
    98a2:	e0 91 d7 01 	lds	r30, 0x01D7
    98a6:	f0 91 d8 01 	lds	r31, 0x01D8
    98aa:	c6 80       	ldd	r12, Z+6	; 0x06
    98ac:	d7 80       	ldd	r13, Z+7	; 0x07
    98ae:	c1 14       	cp	r12, r1
    98b0:	d1 04       	cpc	r13, r1
    98b2:	61 f6       	brne	.-104    	; 0x984c <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    98b4:	80 91 9c 01 	lds	r24, 0x019C
    98b8:	88 23       	and	r24, r24
    98ba:	41 f4       	brne	.+16     	; 0x98cc <xTaskResumeAll+0xc0>
    98bc:	0b c0       	rjmp	.+22     	; 0x98d4 <xTaskResumeAll+0xc8>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    98be:	0e 94 de 4a 	call	0x95bc	; 0x95bc <vTaskIncrementTick>
						--uxMissedTicks;
    98c2:	80 91 9c 01 	lds	r24, 0x019C
    98c6:	81 50       	subi	r24, 0x01	; 1
    98c8:	80 93 9c 01 	sts	0x019C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    98cc:	80 91 9c 01 	lds	r24, 0x019C
    98d0:	88 23       	and	r24, r24
    98d2:	a9 f7       	brne	.-22     	; 0x98be <xTaskResumeAll+0xb2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    98d4:	e9 81       	ldd	r30, Y+1	; 0x01
    98d6:	e1 30       	cpi	r30, 0x01	; 1
    98d8:	21 f0       	breq	.+8      	; 0x98e2 <xTaskResumeAll+0xd6>
    98da:	80 91 95 01 	lds	r24, 0x0195
    98de:	81 30       	cpi	r24, 0x01	; 1
    98e0:	31 f4       	brne	.+12     	; 0x98ee <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    98e2:	10 92 95 01 	sts	0x0195, r1
					portYIELD_WITHIN_API();
    98e6:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
    98ea:	81 e0       	ldi	r24, 0x01	; 1
    98ec:	01 c0       	rjmp	.+2      	; 0x98f0 <xTaskResumeAll+0xe4>
    98ee:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    98f0:	0f 90       	pop	r0
    98f2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    98f4:	0f 90       	pop	r0
    98f6:	cf 91       	pop	r28
    98f8:	df 91       	pop	r29
    98fa:	1f 91       	pop	r17
    98fc:	0f 91       	pop	r16
    98fe:	ff 90       	pop	r15
    9900:	df 90       	pop	r13
    9902:	cf 90       	pop	r12
    9904:	08 95       	ret

00009906 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
    9906:	0f 93       	push	r16
    9908:	1f 93       	push	r17
    990a:	cf 93       	push	r28
    990c:	df 93       	push	r29
    990e:	ec 01       	movw	r28, r24

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    9910:	80 91 99 01 	lds	r24, 0x0199
    9914:	8f 5f       	subi	r24, 0xFF	; 255
    9916:	80 93 99 01 	sts	0x0199, r24
		vTaskSuspendAll();
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
    991a:	18 82       	st	Y, r1
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
    991c:	ce 01       	movw	r24, r28
    991e:	69 e7       	ldi	r22, 0x79	; 121
    9920:	71 e0       	ldi	r23, 0x01	; 1
    9922:	0e 94 55 59 	call	0xb2aa	; 0xb2aa <strcat>

			uxQueue = uxTopUsedPriority + 1;
    9926:	10 91 9d 01 	lds	r17, 0x019D
    992a:	1f 5f       	subi	r17, 0xFF	; 255

			do
			{
				uxQueue--;

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    992c:	09 e0       	ldi	r16, 0x09	; 9

			uxQueue = uxTopUsedPriority + 1;

			do
			{
				uxQueue--;
    992e:	11 50       	subi	r17, 0x01	; 1

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    9930:	10 9f       	mul	r17, r16
    9932:	f0 01       	movw	r30, r0
    9934:	11 24       	eor	r1, r1
    9936:	ef 55       	subi	r30, 0x5F	; 95
    9938:	fe 4f       	sbci	r31, 0xFE	; 254
    993a:	80 81       	ld	r24, Z
    993c:	88 23       	and	r24, r24
    993e:	29 f0       	breq	.+10     	; 0x994a <vTaskList+0x44>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
    9940:	ce 01       	movw	r24, r28
    9942:	bf 01       	movw	r22, r30
    9944:	42 e5       	ldi	r20, 0x52	; 82
    9946:	0e 94 5c 4b 	call	0x96b8	; 0x96b8 <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
    994a:	11 23       	and	r17, r17
    994c:	81 f7       	brne	.-32     	; 0x992e <vTaskList+0x28>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
    994e:	e0 91 ce 01 	lds	r30, 0x01CE
    9952:	f0 91 cf 01 	lds	r31, 0x01CF
    9956:	80 81       	ld	r24, Z
    9958:	88 23       	and	r24, r24
    995a:	41 f0       	breq	.+16     	; 0x996c <vTaskList+0x66>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
    995c:	60 91 ce 01 	lds	r22, 0x01CE
    9960:	70 91 cf 01 	lds	r23, 0x01CF
    9964:	ce 01       	movw	r24, r28
    9966:	42 e4       	ldi	r20, 0x42	; 66
    9968:	0e 94 5c 4b 	call	0x96b8	; 0x96b8 <prvListTaskWithinSingleList>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
    996c:	e0 91 d0 01 	lds	r30, 0x01D0
    9970:	f0 91 d1 01 	lds	r31, 0x01D1
    9974:	80 81       	ld	r24, Z
    9976:	88 23       	and	r24, r24
    9978:	41 f0       	breq	.+16     	; 0x998a <vTaskList+0x84>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
    997a:	60 91 d0 01 	lds	r22, 0x01D0
    997e:	70 91 d1 01 	lds	r23, 0x01D1
    9982:	ce 01       	movw	r24, r28
    9984:	42 e4       	ldi	r20, 0x42	; 66
    9986:	0e 94 5c 4b 	call	0x96b8	; 0x96b8 <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
    998a:	80 91 db 01 	lds	r24, 0x01DB
    998e:	88 23       	and	r24, r24
    9990:	31 f0       	breq	.+12     	; 0x999e <vTaskList+0x98>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
    9992:	ce 01       	movw	r24, r28
    9994:	6b ed       	ldi	r22, 0xDB	; 219
    9996:	71 e0       	ldi	r23, 0x01	; 1
    9998:	43 e5       	ldi	r20, 0x53	; 83
    999a:	0e 94 5c 4b 	call	0x96b8	; 0x96b8 <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
    999e:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
	}
    99a2:	df 91       	pop	r29
    99a4:	cf 91       	pop	r28
    99a6:	1f 91       	pop	r17
    99a8:	0f 91       	pop	r16
    99aa:	08 95       	ret

000099ac <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    99ac:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
    99b0:	fd cf       	rjmp	.-6      	; 0x99ac <prvIdleTask>

000099b2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    99b2:	0f 93       	push	r16
    99b4:	1f 93       	push	r17
    99b6:	cf 93       	push	r28
    99b8:	df 93       	push	r29
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    99ba:	ec 01       	movw	r28, r24

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    99bc:	00 97       	sbiw	r24, 0x00	; 0
    99be:	09 f4       	brne	.+2      	; 0x99c2 <vTaskResume+0x10>
    99c0:	3c c0       	rjmp	.+120    	; 0x9a3a <vTaskResume+0x88>
    99c2:	80 91 93 01 	lds	r24, 0x0193
    99c6:	90 91 94 01 	lds	r25, 0x0194
    99ca:	c8 17       	cp	r28, r24
    99cc:	d9 07       	cpc	r29, r25
    99ce:	a9 f1       	breq	.+106    	; 0x9a3a <vTaskResume+0x88>
		{
			portENTER_CRITICAL();
    99d0:	0f b6       	in	r0, 0x3f	; 63
    99d2:	f8 94       	cli
    99d4:	0f 92       	push	r0
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    99d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    99d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    99da:	8b 5d       	subi	r24, 0xDB	; 219
    99dc:	91 40       	sbci	r25, 0x01	; 1
    99de:	f1 f4       	brne	.+60     	; 0x9a1c <vTaskResume+0x6a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    99e0:	8c 89       	ldd	r24, Y+20	; 0x14
    99e2:	9d 89       	ldd	r25, Y+21	; 0x15
    99e4:	21 e0       	ldi	r18, 0x01	; 1
    99e6:	82 3d       	cpi	r24, 0xD2	; 210
    99e8:	92 07       	cpc	r25, r18
    99ea:	c1 f0       	breq	.+48     	; 0x9a1c <vTaskResume+0x6a>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    99ec:	89 2b       	or	r24, r25
    99ee:	b1 f4       	brne	.+44     	; 0x9a1c <vTaskResume+0x6a>
    99f0:	18 c0       	rjmp	.+48     	; 0x9a22 <vTaskResume+0x70>
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    99f2:	90 93 9a 01 	sts	0x019A, r25
    99f6:	89 e0       	ldi	r24, 0x09	; 9
    99f8:	98 9f       	mul	r25, r24
    99fa:	c0 01       	movw	r24, r0
    99fc:	11 24       	eor	r1, r1
    99fe:	8f 55       	subi	r24, 0x5F	; 95
    9a00:	9e 4f       	sbci	r25, 0xFE	; 254
    9a02:	b8 01       	movw	r22, r16
    9a04:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9a08:	e0 91 93 01 	lds	r30, 0x0193
    9a0c:	f0 91 94 01 	lds	r31, 0x0194
    9a10:	9e 89       	ldd	r25, Y+22	; 0x16
    9a12:	86 89       	ldd	r24, Z+22	; 0x16
    9a14:	98 17       	cp	r25, r24
    9a16:	10 f0       	brcs	.+4      	; 0x9a1c <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    9a18:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    9a1c:	0f 90       	pop	r0
    9a1e:	0f be       	out	0x3f, r0	; 63
    9a20:	0c c0       	rjmp	.+24     	; 0x9a3a <vTaskResume+0x88>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    9a22:	8e 01       	movw	r16, r28
    9a24:	0e 5f       	subi	r16, 0xFE	; 254
    9a26:	1f 4f       	sbci	r17, 0xFF	; 255
    9a28:	c8 01       	movw	r24, r16
    9a2a:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    9a2e:	9e 89       	ldd	r25, Y+22	; 0x16
    9a30:	80 91 9a 01 	lds	r24, 0x019A
    9a34:	89 17       	cp	r24, r25
    9a36:	e8 f2       	brcs	.-70     	; 0x99f2 <vTaskResume+0x40>
    9a38:	de cf       	rjmp	.-68     	; 0x99f6 <vTaskResume+0x44>
					}
				}
			}
			portEXIT_CRITICAL();
		}
	}
    9a3a:	df 91       	pop	r29
    9a3c:	cf 91       	pop	r28
    9a3e:	1f 91       	pop	r17
    9a40:	0f 91       	pop	r16
    9a42:	08 95       	ret

00009a44 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    9a44:	ef 92       	push	r14
    9a46:	ff 92       	push	r15
    9a48:	0f 93       	push	r16
    9a4a:	1f 93       	push	r17
    9a4c:	cf 93       	push	r28
    9a4e:	df 93       	push	r29
    9a50:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    9a52:	0f b6       	in	r0, 0x3f	; 63
    9a54:	f8 94       	cli
    9a56:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    9a58:	80 91 93 01 	lds	r24, 0x0193
    9a5c:	90 91 94 01 	lds	r25, 0x0194
    9a60:	08 17       	cp	r16, r24
    9a62:	19 07       	cpc	r17, r25
    9a64:	19 f4       	brne	.+6      	; 0x9a6c <vTaskSuspend+0x28>
    9a66:	00 e0       	ldi	r16, 0x00	; 0
    9a68:	10 e0       	ldi	r17, 0x00	; 0
    9a6a:	03 c0       	rjmp	.+6      	; 0x9a72 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    9a6c:	01 15       	cp	r16, r1
    9a6e:	11 05       	cpc	r17, r1
    9a70:	29 f4       	brne	.+10     	; 0x9a7c <vTaskSuspend+0x38>
    9a72:	c0 91 93 01 	lds	r28, 0x0193
    9a76:	d0 91 94 01 	lds	r29, 0x0194
    9a7a:	01 c0       	rjmp	.+2      	; 0x9a7e <vTaskSuspend+0x3a>
    9a7c:	e8 01       	movw	r28, r16

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    9a7e:	72 e0       	ldi	r23, 0x02	; 2
    9a80:	e7 2e       	mov	r14, r23
    9a82:	f1 2c       	mov	r15, r1
    9a84:	ec 0e       	add	r14, r28
    9a86:	fd 1e       	adc	r15, r29
    9a88:	c7 01       	movw	r24, r14
    9a8a:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    9a8e:	8c 89       	ldd	r24, Y+20	; 0x14
    9a90:	9d 89       	ldd	r25, Y+21	; 0x15
    9a92:	89 2b       	or	r24, r25
    9a94:	21 f0       	breq	.+8      	; 0x9a9e <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    9a96:	ce 01       	movw	r24, r28
    9a98:	0c 96       	adiw	r24, 0x0c	; 12
    9a9a:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    9a9e:	8b ed       	ldi	r24, 0xDB	; 219
    9aa0:	91 e0       	ldi	r25, 0x01	; 1
    9aa2:	b7 01       	movw	r22, r14
    9aa4:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    9aa8:	0f 90       	pop	r0
    9aaa:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    9aac:	01 2b       	or	r16, r17
    9aae:	11 f4       	brne	.+4      	; 0x9ab4 <vTaskSuspend+0x70>
		{
			portYIELD_WITHIN_API();
    9ab0:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
		}
	}
    9ab4:	df 91       	pop	r29
    9ab6:	cf 91       	pop	r28
    9ab8:	1f 91       	pop	r17
    9aba:	0f 91       	pop	r16
    9abc:	ff 90       	pop	r15
    9abe:	ef 90       	pop	r14
    9ac0:	08 95       	ret

00009ac2 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    9ac2:	ef 92       	push	r14
    9ac4:	ff 92       	push	r15
    9ac6:	0f 93       	push	r16
    9ac8:	1f 93       	push	r17
    9aca:	df 93       	push	r29
    9acc:	cf 93       	push	r28
    9ace:	0f 92       	push	r0
    9ad0:	cd b7       	in	r28, 0x3d	; 61
    9ad2:	de b7       	in	r29, 0x3e	; 62
    9ad4:	9c 01       	movw	r18, r24
    9ad6:	63 30       	cpi	r22, 0x03	; 3
    9ad8:	08 f0       	brcs	.+2      	; 0x9adc <vTaskPrioritySet+0x1a>
    9ada:	62 e0       	ldi	r22, 0x02	; 2
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		portENTER_CRITICAL();
    9adc:	0f b6       	in	r0, 0x3f	; 63
    9ade:	f8 94       	cli
    9ae0:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    9ae2:	80 91 93 01 	lds	r24, 0x0193
    9ae6:	90 91 94 01 	lds	r25, 0x0194
    9aea:	28 17       	cp	r18, r24
    9aec:	39 07       	cpc	r19, r25
    9aee:	19 f4       	brne	.+6      	; 0x9af6 <vTaskPrioritySet+0x34>
    9af0:	20 e0       	ldi	r18, 0x00	; 0
    9af2:	30 e0       	ldi	r19, 0x00	; 0
    9af4:	03 c0       	rjmp	.+6      	; 0x9afc <vTaskPrioritySet+0x3a>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    9af6:	21 15       	cp	r18, r1
    9af8:	31 05       	cpc	r19, r1
    9afa:	29 f4       	brne	.+10     	; 0x9b06 <vTaskPrioritySet+0x44>
    9afc:	e0 90 93 01 	lds	r14, 0x0193
    9b00:	f0 90 94 01 	lds	r15, 0x0194
    9b04:	01 c0       	rjmp	.+2      	; 0x9b08 <vTaskPrioritySet+0x46>
    9b06:	79 01       	movw	r14, r18
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    9b08:	f7 01       	movw	r30, r14
    9b0a:	46 89       	ldd	r20, Z+22	; 0x16
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    9b0c:	46 17       	cp	r20, r22
    9b0e:	e1 f1       	breq	.+120    	; 0x9b88 <vTaskPrioritySet+0xc6>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    9b10:	46 17       	cp	r20, r22
    9b12:	30 f4       	brcc	.+12     	; 0x9b20 <vTaskPrioritySet+0x5e>
    9b14:	19 82       	std	Y+1, r1	; 0x01
    9b16:	23 2b       	or	r18, r19
    9b18:	41 f0       	breq	.+16     	; 0x9b2a <vTaskPrioritySet+0x68>
    9b1a:	f1 e0       	ldi	r31, 0x01	; 1
    9b1c:	f9 83       	std	Y+1, r31	; 0x01
    9b1e:	05 c0       	rjmp	.+10     	; 0x9b2a <vTaskPrioritySet+0x68>
    9b20:	19 82       	std	Y+1, r1	; 0x01
    9b22:	23 2b       	or	r18, r19
    9b24:	11 f4       	brne	.+4      	; 0x9b2a <vTaskPrioritySet+0x68>
    9b26:	81 e0       	ldi	r24, 0x01	; 1
    9b28:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    9b2a:	f7 01       	movw	r30, r14
    9b2c:	66 8b       	std	Z+22, r22	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    9b2e:	83 e0       	ldi	r24, 0x03	; 3
    9b30:	90 e0       	ldi	r25, 0x00	; 0
    9b32:	86 1b       	sub	r24, r22
    9b34:	91 09       	sbc	r25, r1
    9b36:	95 87       	std	Z+13, r25	; 0x0d
    9b38:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    9b3a:	89 e0       	ldi	r24, 0x09	; 9
    9b3c:	48 9f       	mul	r20, r24
    9b3e:	c0 01       	movw	r24, r0
    9b40:	11 24       	eor	r1, r1
    9b42:	8f 55       	subi	r24, 0x5F	; 95
    9b44:	9e 4f       	sbci	r25, 0xFE	; 254
    9b46:	22 85       	ldd	r18, Z+10	; 0x0a
    9b48:	33 85       	ldd	r19, Z+11	; 0x0b
    9b4a:	28 17       	cp	r18, r24
    9b4c:	39 07       	cpc	r19, r25
    9b4e:	b9 f4       	brne	.+46     	; 0x9b7e <vTaskPrioritySet+0xbc>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    9b50:	87 01       	movw	r16, r14
    9b52:	0e 5f       	subi	r16, 0xFE	; 254
    9b54:	1f 4f       	sbci	r17, 0xFF	; 255
    9b56:	c8 01       	movw	r24, r16
    9b58:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    9b5c:	f7 01       	movw	r30, r14
    9b5e:	96 89       	ldd	r25, Z+22	; 0x16
    9b60:	80 91 9a 01 	lds	r24, 0x019A
    9b64:	89 17       	cp	r24, r25
    9b66:	10 f4       	brcc	.+4      	; 0x9b6c <vTaskPrioritySet+0xaa>
    9b68:	90 93 9a 01 	sts	0x019A, r25
    9b6c:	89 e0       	ldi	r24, 0x09	; 9
    9b6e:	98 9f       	mul	r25, r24
    9b70:	c0 01       	movw	r24, r0
    9b72:	11 24       	eor	r1, r1
    9b74:	8f 55       	subi	r24, 0x5F	; 95
    9b76:	9e 4f       	sbci	r25, 0xFE	; 254
    9b78:	b8 01       	movw	r22, r16
    9b7a:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    9b7e:	f9 81       	ldd	r31, Y+1	; 0x01
    9b80:	f1 30       	cpi	r31, 0x01	; 1
    9b82:	11 f4       	brne	.+4      	; 0x9b88 <vTaskPrioritySet+0xc6>
				{
					portYIELD_WITHIN_API();
    9b84:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
				}
			}
		}
		portEXIT_CRITICAL();
    9b88:	0f 90       	pop	r0
    9b8a:	0f be       	out	0x3f, r0	; 63
	}
    9b8c:	0f 90       	pop	r0
    9b8e:	cf 91       	pop	r28
    9b90:	df 91       	pop	r29
    9b92:	1f 91       	pop	r17
    9b94:	0f 91       	pop	r16
    9b96:	ff 90       	pop	r15
    9b98:	ef 90       	pop	r14
    9b9a:	08 95       	ret

00009b9c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    9b9c:	0f 93       	push	r16
    9b9e:	1f 93       	push	r17
    9ba0:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    9ba2:	00 97       	sbiw	r24, 0x00	; 0
    9ba4:	a1 f1       	breq	.+104    	; 0x9c0e <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    9ba6:	80 91 99 01 	lds	r24, 0x0199
    9baa:	8f 5f       	subi	r24, 0xFF	; 255
    9bac:	80 93 99 01 	sts	0x0199, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    9bb0:	00 91 97 01 	lds	r16, 0x0197
    9bb4:	10 91 98 01 	lds	r17, 0x0198
    9bb8:	02 0f       	add	r16, r18
    9bba:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9bbc:	80 91 93 01 	lds	r24, 0x0193
    9bc0:	90 91 94 01 	lds	r25, 0x0194
    9bc4:	02 96       	adiw	r24, 0x02	; 2
    9bc6:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    9bca:	e0 91 93 01 	lds	r30, 0x0193
    9bce:	f0 91 94 01 	lds	r31, 0x0194
    9bd2:	13 83       	std	Z+3, r17	; 0x03
    9bd4:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    9bd6:	80 91 97 01 	lds	r24, 0x0197
    9bda:	90 91 98 01 	lds	r25, 0x0198
    9bde:	08 17       	cp	r16, r24
    9be0:	19 07       	cpc	r17, r25
    9be2:	28 f4       	brcc	.+10     	; 0x9bee <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9be4:	80 91 d0 01 	lds	r24, 0x01D0
    9be8:	90 91 d1 01 	lds	r25, 0x01D1
    9bec:	04 c0       	rjmp	.+8      	; 0x9bf6 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9bee:	80 91 ce 01 	lds	r24, 0x01CE
    9bf2:	90 91 cf 01 	lds	r25, 0x01CF
    9bf6:	60 91 93 01 	lds	r22, 0x0193
    9bfa:	70 91 94 01 	lds	r23, 0x0194
    9bfe:	6e 5f       	subi	r22, 0xFE	; 254
    9c00:	7f 4f       	sbci	r23, 0xFF	; 255
    9c02:	0e 94 27 53 	call	0xa64e	; 0xa64e <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    9c06:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    9c0a:	88 23       	and	r24, r24
    9c0c:	11 f4       	brne	.+4      	; 0x9c12 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    9c0e:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
		}
	}
    9c12:	1f 91       	pop	r17
    9c14:	0f 91       	pop	r16
    9c16:	08 95       	ret

00009c18 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    9c18:	cf 93       	push	r28
    9c1a:	df 93       	push	r29
    9c1c:	fc 01       	movw	r30, r24
    9c1e:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    9c20:	80 91 99 01 	lds	r24, 0x0199
    9c24:	8f 5f       	subi	r24, 0xFF	; 255
    9c26:	80 93 99 01 	sts	0x0199, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    9c2a:	20 81       	ld	r18, Z
    9c2c:	31 81       	ldd	r19, Z+1	; 0x01
    9c2e:	c2 0f       	add	r28, r18
    9c30:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    9c32:	80 91 97 01 	lds	r24, 0x0197
    9c36:	90 91 98 01 	lds	r25, 0x0198
    9c3a:	82 17       	cp	r24, r18
    9c3c:	93 07       	cpc	r25, r19
    9c3e:	28 f4       	brcc	.+10     	; 0x9c4a <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    9c40:	c2 17       	cp	r28, r18
    9c42:	d3 07       	cpc	r29, r19
    9c44:	28 f0       	brcs	.+10     	; 0x9c50 <vTaskDelayUntil+0x38>
    9c46:	20 e0       	ldi	r18, 0x00	; 0
    9c48:	0c c0       	rjmp	.+24     	; 0x9c62 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    9c4a:	c2 17       	cp	r28, r18
    9c4c:	d3 07       	cpc	r29, r19
    9c4e:	40 f0       	brcs	.+16     	; 0x9c60 <vTaskDelayUntil+0x48>
    9c50:	80 91 97 01 	lds	r24, 0x0197
    9c54:	90 91 98 01 	lds	r25, 0x0198
    9c58:	20 e0       	ldi	r18, 0x00	; 0
    9c5a:	8c 17       	cp	r24, r28
    9c5c:	9d 07       	cpc	r25, r29
    9c5e:	08 f4       	brcc	.+2      	; 0x9c62 <vTaskDelayUntil+0x4a>
    9c60:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    9c62:	d1 83       	std	Z+1, r29	; 0x01
    9c64:	c0 83       	st	Z, r28

			if( xShouldDelay )
    9c66:	22 23       	and	r18, r18
    9c68:	29 f1       	breq	.+74     	; 0x9cb4 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9c6a:	80 91 93 01 	lds	r24, 0x0193
    9c6e:	90 91 94 01 	lds	r25, 0x0194
    9c72:	02 96       	adiw	r24, 0x02	; 2
    9c74:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    9c78:	e0 91 93 01 	lds	r30, 0x0193
    9c7c:	f0 91 94 01 	lds	r31, 0x0194
    9c80:	d3 83       	std	Z+3, r29	; 0x03
    9c82:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    9c84:	80 91 97 01 	lds	r24, 0x0197
    9c88:	90 91 98 01 	lds	r25, 0x0198
    9c8c:	c8 17       	cp	r28, r24
    9c8e:	d9 07       	cpc	r29, r25
    9c90:	28 f4       	brcc	.+10     	; 0x9c9c <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9c92:	80 91 d0 01 	lds	r24, 0x01D0
    9c96:	90 91 d1 01 	lds	r25, 0x01D1
    9c9a:	04 c0       	rjmp	.+8      	; 0x9ca4 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9c9c:	80 91 ce 01 	lds	r24, 0x01CE
    9ca0:	90 91 cf 01 	lds	r25, 0x01CF
    9ca4:	60 91 93 01 	lds	r22, 0x0193
    9ca8:	70 91 94 01 	lds	r23, 0x0194
    9cac:	6e 5f       	subi	r22, 0xFE	; 254
    9cae:	7f 4f       	sbci	r23, 0xFF	; 255
    9cb0:	0e 94 27 53 	call	0xa64e	; 0xa64e <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    9cb4:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    9cb8:	88 23       	and	r24, r24
    9cba:	11 f4       	brne	.+4      	; 0x9cc0 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    9cbc:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
		}
	}
    9cc0:	df 91       	pop	r29
    9cc2:	cf 91       	pop	r28
    9cc4:	08 95       	ret

00009cc6 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    9cc6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    9cc8:	10 92 9f 01 	sts	0x019F, r1
	vPortEndScheduler();
    9ccc:	0e 94 f5 55 	call	0xabea	; 0xabea <vPortEndScheduler>
}
    9cd0:	08 95       	ret

00009cd2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    9cd2:	2f 92       	push	r2
    9cd4:	3f 92       	push	r3
    9cd6:	4f 92       	push	r4
    9cd8:	5f 92       	push	r5
    9cda:	7f 92       	push	r7
    9cdc:	8f 92       	push	r8
    9cde:	9f 92       	push	r9
    9ce0:	af 92       	push	r10
    9ce2:	bf 92       	push	r11
    9ce4:	cf 92       	push	r12
    9ce6:	df 92       	push	r13
    9ce8:	ef 92       	push	r14
    9cea:	ff 92       	push	r15
    9cec:	0f 93       	push	r16
    9cee:	1f 93       	push	r17
    9cf0:	df 93       	push	r29
    9cf2:	cf 93       	push	r28
    9cf4:	00 d0       	rcall	.+0      	; 0x9cf6 <xTaskGenericCreate+0x24>
    9cf6:	00 d0       	rcall	.+0      	; 0x9cf8 <xTaskGenericCreate+0x26>
    9cf8:	cd b7       	in	r28, 0x3d	; 61
    9cfa:	de b7       	in	r29, 0x3e	; 62
    9cfc:	1c 01       	movw	r2, r24
    9cfe:	4b 01       	movw	r8, r22
    9d00:	5a 01       	movw	r10, r20
    9d02:	29 01       	movw	r4, r18
    9d04:	70 2e       	mov	r7, r16
    9d06:	fa 82       	std	Y+2, r15	; 0x02
    9d08:	e9 82       	std	Y+1, r14	; 0x01
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    9d0a:	84 e2       	ldi	r24, 0x24	; 36
    9d0c:	90 e0       	ldi	r25, 0x00	; 0
    9d0e:	0e 94 50 55 	call	0xaaa0	; 0xaaa0 <pvPortMalloc>
    9d12:	8b 83       	std	Y+3, r24	; 0x03
    9d14:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    9d16:	8b 81       	ldd	r24, Y+3	; 0x03
    9d18:	9c 81       	ldd	r25, Y+4	; 0x04
    9d1a:	89 2b       	or	r24, r25
    9d1c:	89 f0       	breq	.+34     	; 0x9d40 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    9d1e:	c1 14       	cp	r12, r1
    9d20:	d1 04       	cpc	r13, r1
    9d22:	21 f4       	brne	.+8      	; 0x9d2c <xTaskGenericCreate+0x5a>
    9d24:	c5 01       	movw	r24, r10
    9d26:	0e 94 50 55 	call	0xaaa0	; 0xaaa0 <pvPortMalloc>
    9d2a:	6c 01       	movw	r12, r24
    9d2c:	eb 81       	ldd	r30, Y+3	; 0x03
    9d2e:	fc 81       	ldd	r31, Y+4	; 0x04
    9d30:	d0 8e       	std	Z+24, r13	; 0x18
    9d32:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    9d34:	c1 14       	cp	r12, r1
    9d36:	d1 04       	cpc	r13, r1
    9d38:	29 f4       	brne	.+10     	; 0x9d44 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    9d3a:	cf 01       	movw	r24, r30
    9d3c:	0e 94 40 55 	call	0xaa80	; 0xaa80 <vPortFree>
    9d40:	8f ef       	ldi	r24, 0xFF	; 255
    9d42:	ce c0       	rjmp	.+412    	; 0x9ee0 <xTaskGenericCreate+0x20e>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    9d44:	c6 01       	movw	r24, r12
    9d46:	65 ea       	ldi	r22, 0xA5	; 165
    9d48:	70 e0       	ldi	r23, 0x00	; 0
    9d4a:	a5 01       	movw	r20, r10
    9d4c:	0e 94 4e 59 	call	0xb29c	; 0xb29c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    9d50:	08 94       	sec
    9d52:	a1 08       	sbc	r10, r1
    9d54:	b1 08       	sbc	r11, r1
    9d56:	eb 81       	ldd	r30, Y+3	; 0x03
    9d58:	fc 81       	ldd	r31, Y+4	; 0x04
    9d5a:	e7 88       	ldd	r14, Z+23	; 0x17
    9d5c:	f0 8c       	ldd	r15, Z+24	; 0x18
    9d5e:	ea 0c       	add	r14, r10
    9d60:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    9d62:	cf 01       	movw	r24, r30
    9d64:	49 96       	adiw	r24, 0x19	; 25
    9d66:	b4 01       	movw	r22, r8
    9d68:	4a e0       	ldi	r20, 0x0A	; 10
    9d6a:	50 e0       	ldi	r21, 0x00	; 0
    9d6c:	0e 94 75 59 	call	0xb2ea	; 0xb2ea <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    9d70:	eb 81       	ldd	r30, Y+3	; 0x03
    9d72:	fc 81       	ldd	r31, Y+4	; 0x04
    9d74:	12 a2       	std	Z+34, r1	; 0x22
    9d76:	07 2d       	mov	r16, r7
    9d78:	f2 e0       	ldi	r31, 0x02	; 2
    9d7a:	f7 15       	cp	r31, r7
    9d7c:	08 f4       	brcc	.+2      	; 0x9d80 <xTaskGenericCreate+0xae>
    9d7e:	02 e0       	ldi	r16, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    9d80:	eb 81       	ldd	r30, Y+3	; 0x03
    9d82:	fc 81       	ldd	r31, Y+4	; 0x04
    9d84:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    9d86:	a2 e0       	ldi	r26, 0x02	; 2
    9d88:	ca 2e       	mov	r12, r26
    9d8a:	d1 2c       	mov	r13, r1
    9d8c:	ce 0e       	add	r12, r30
    9d8e:	df 1e       	adc	r13, r31
    9d90:	c6 01       	movw	r24, r12
    9d92:	0e 94 fa 52 	call	0xa5f4	; 0xa5f4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    9d96:	8b 81       	ldd	r24, Y+3	; 0x03
    9d98:	9c 81       	ldd	r25, Y+4	; 0x04
    9d9a:	0c 96       	adiw	r24, 0x0c	; 12
    9d9c:	0e 94 fa 52 	call	0xa5f4	; 0xa5f4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    9da0:	8b 81       	ldd	r24, Y+3	; 0x03
    9da2:	9c 81       	ldd	r25, Y+4	; 0x04
    9da4:	fc 01       	movw	r30, r24
    9da6:	91 87       	std	Z+9, r25	; 0x09
    9da8:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    9daa:	83 e0       	ldi	r24, 0x03	; 3
    9dac:	90 e0       	ldi	r25, 0x00	; 0
    9dae:	80 1b       	sub	r24, r16
    9db0:	91 09       	sbc	r25, r1
    9db2:	95 87       	std	Z+13, r25	; 0x0d
    9db4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    9db6:	f3 8b       	std	Z+19, r31	; 0x13
    9db8:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    9dba:	c7 01       	movw	r24, r14
    9dbc:	b1 01       	movw	r22, r2
    9dbe:	a2 01       	movw	r20, r4
    9dc0:	0e 94 77 55 	call	0xaaee	; 0xaaee <pxPortInitialiseStack>
    9dc4:	eb 81       	ldd	r30, Y+3	; 0x03
    9dc6:	fc 81       	ldd	r31, Y+4	; 0x04
    9dc8:	91 83       	std	Z+1, r25	; 0x01
    9dca:	80 83       	st	Z, r24
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    9dcc:	0f b6       	in	r0, 0x3f	; 63
    9dce:	f8 94       	cli
    9dd0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    9dd2:	80 91 9e 01 	lds	r24, 0x019E
    9dd6:	8f 5f       	subi	r24, 0xFF	; 255
    9dd8:	80 93 9e 01 	sts	0x019E, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    9ddc:	80 91 9e 01 	lds	r24, 0x019E
    9de0:	81 30       	cpi	r24, 0x01	; 1
    9de2:	69 f5       	brne	.+90     	; 0x9e3e <xTaskGenericCreate+0x16c>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    9de4:	f0 93 94 01 	sts	0x0194, r31
    9de8:	e0 93 93 01 	sts	0x0193, r30
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    9dec:	81 ea       	ldi	r24, 0xA1	; 161
    9dee:	91 e0       	ldi	r25, 0x01	; 1
    9df0:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
    9df4:	8a ea       	ldi	r24, 0xAA	; 170
    9df6:	91 e0       	ldi	r25, 0x01	; 1
    9df8:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
    9dfc:	83 eb       	ldi	r24, 0xB3	; 179
    9dfe:	91 e0       	ldi	r25, 0x01	; 1
    9e00:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    9e04:	ec eb       	ldi	r30, 0xBC	; 188
    9e06:	ee 2e       	mov	r14, r30
    9e08:	e1 e0       	ldi	r30, 0x01	; 1
    9e0a:	fe 2e       	mov	r15, r30
    9e0c:	c7 01       	movw	r24, r14
    9e0e:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    9e12:	05 ec       	ldi	r16, 0xC5	; 197
    9e14:	11 e0       	ldi	r17, 0x01	; 1
    9e16:	c8 01       	movw	r24, r16
    9e18:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    9e1c:	82 ed       	ldi	r24, 0xD2	; 210
    9e1e:	91 e0       	ldi	r25, 0x01	; 1
    9e20:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    9e24:	8b ed       	ldi	r24, 0xDB	; 219
    9e26:	91 e0       	ldi	r25, 0x01	; 1
    9e28:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    9e2c:	f0 92 cf 01 	sts	0x01CF, r15
    9e30:	e0 92 ce 01 	sts	0x01CE, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    9e34:	10 93 d1 01 	sts	0x01D1, r17
    9e38:	00 93 d0 01 	sts	0x01D0, r16
    9e3c:	11 c0       	rjmp	.+34     	; 0x9e60 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    9e3e:	80 91 9f 01 	lds	r24, 0x019F
    9e42:	88 23       	and	r24, r24
    9e44:	69 f4       	brne	.+26     	; 0x9e60 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    9e46:	e0 91 93 01 	lds	r30, 0x0193
    9e4a:	f0 91 94 01 	lds	r31, 0x0194
    9e4e:	86 89       	ldd	r24, Z+22	; 0x16
    9e50:	78 16       	cp	r7, r24
    9e52:	30 f0       	brcs	.+12     	; 0x9e60 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    9e54:	8b 81       	ldd	r24, Y+3	; 0x03
    9e56:	9c 81       	ldd	r25, Y+4	; 0x04
    9e58:	90 93 94 01 	sts	0x0194, r25
    9e5c:	80 93 93 01 	sts	0x0193, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    9e60:	eb 81       	ldd	r30, Y+3	; 0x03
    9e62:	fc 81       	ldd	r31, Y+4	; 0x04
    9e64:	96 89       	ldd	r25, Z+22	; 0x16
    9e66:	80 91 9d 01 	lds	r24, 0x019D
    9e6a:	89 17       	cp	r24, r25
    9e6c:	10 f4       	brcc	.+4      	; 0x9e72 <xTaskGenericCreate+0x1a0>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    9e6e:	90 93 9d 01 	sts	0x019D, r25
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    9e72:	80 91 a0 01 	lds	r24, 0x01A0
    9e76:	eb 81       	ldd	r30, Y+3	; 0x03
    9e78:	fc 81       	ldd	r31, Y+4	; 0x04
    9e7a:	83 a3       	std	Z+35, r24	; 0x23
			}
			#endif
			uxTaskNumber++;
    9e7c:	80 91 a0 01 	lds	r24, 0x01A0
    9e80:	8f 5f       	subi	r24, 0xFF	; 255
    9e82:	80 93 a0 01 	sts	0x01A0, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    9e86:	96 89       	ldd	r25, Z+22	; 0x16
    9e88:	80 91 9a 01 	lds	r24, 0x019A
    9e8c:	89 17       	cp	r24, r25
    9e8e:	10 f4       	brcc	.+4      	; 0x9e94 <xTaskGenericCreate+0x1c2>
    9e90:	90 93 9a 01 	sts	0x019A, r25
    9e94:	eb 81       	ldd	r30, Y+3	; 0x03
    9e96:	fc 81       	ldd	r31, Y+4	; 0x04
    9e98:	86 89       	ldd	r24, Z+22	; 0x16
    9e9a:	29 e0       	ldi	r18, 0x09	; 9
    9e9c:	82 9f       	mul	r24, r18
    9e9e:	c0 01       	movw	r24, r0
    9ea0:	11 24       	eor	r1, r1
    9ea2:	8f 55       	subi	r24, 0x5F	; 95
    9ea4:	9e 4f       	sbci	r25, 0xFE	; 254
    9ea6:	b6 01       	movw	r22, r12
    9ea8:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    9eac:	0f 90       	pop	r0
    9eae:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    9eb0:	89 81       	ldd	r24, Y+1	; 0x01
    9eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    9eb4:	89 2b       	or	r24, r25
    9eb6:	31 f0       	breq	.+12     	; 0x9ec4 <xTaskGenericCreate+0x1f2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    9eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    9eba:	9c 81       	ldd	r25, Y+4	; 0x04
    9ebc:	e9 81       	ldd	r30, Y+1	; 0x01
    9ebe:	fa 81       	ldd	r31, Y+2	; 0x02
    9ec0:	91 83       	std	Z+1, r25	; 0x01
    9ec2:	80 83       	st	Z, r24
		}

		if( xSchedulerRunning != pdFALSE )
    9ec4:	80 91 9f 01 	lds	r24, 0x019F
    9ec8:	88 23       	and	r24, r24
    9eca:	49 f0       	breq	.+18     	; 0x9ede <xTaskGenericCreate+0x20c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    9ecc:	e0 91 93 01 	lds	r30, 0x0193
    9ed0:	f0 91 94 01 	lds	r31, 0x0194
    9ed4:	86 89       	ldd	r24, Z+22	; 0x16
    9ed6:	87 15       	cp	r24, r7
    9ed8:	10 f4       	brcc	.+4      	; 0x9ede <xTaskGenericCreate+0x20c>
			{
				portYIELD_WITHIN_API();
    9eda:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
    9ede:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    9ee0:	0f 90       	pop	r0
    9ee2:	0f 90       	pop	r0
    9ee4:	0f 90       	pop	r0
    9ee6:	0f 90       	pop	r0
    9ee8:	cf 91       	pop	r28
    9eea:	df 91       	pop	r29
    9eec:	1f 91       	pop	r17
    9eee:	0f 91       	pop	r16
    9ef0:	ff 90       	pop	r15
    9ef2:	ef 90       	pop	r14
    9ef4:	df 90       	pop	r13
    9ef6:	cf 90       	pop	r12
    9ef8:	bf 90       	pop	r11
    9efa:	af 90       	pop	r10
    9efc:	9f 90       	pop	r9
    9efe:	8f 90       	pop	r8
    9f00:	7f 90       	pop	r7
    9f02:	5f 90       	pop	r5
    9f04:	4f 90       	pop	r4
    9f06:	3f 90       	pop	r3
    9f08:	2f 90       	pop	r2
    9f0a:	08 95       	ret

00009f0c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    9f0c:	af 92       	push	r10
    9f0e:	bf 92       	push	r11
    9f10:	cf 92       	push	r12
    9f12:	df 92       	push	r13
    9f14:	ef 92       	push	r14
    9f16:	ff 92       	push	r15
    9f18:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    9f1a:	86 ed       	ldi	r24, 0xD6	; 214
    9f1c:	9c e4       	ldi	r25, 0x4C	; 76
    9f1e:	6c e7       	ldi	r22, 0x7C	; 124
    9f20:	71 e0       	ldi	r23, 0x01	; 1
    9f22:	44 e6       	ldi	r20, 0x64	; 100
    9f24:	50 e0       	ldi	r21, 0x00	; 0
    9f26:	20 e0       	ldi	r18, 0x00	; 0
    9f28:	30 e0       	ldi	r19, 0x00	; 0
    9f2a:	00 e0       	ldi	r16, 0x00	; 0
    9f2c:	ee 24       	eor	r14, r14
    9f2e:	ff 24       	eor	r15, r15
    9f30:	cc 24       	eor	r12, r12
    9f32:	dd 24       	eor	r13, r13
    9f34:	aa 24       	eor	r10, r10
    9f36:	bb 24       	eor	r11, r11
    9f38:	0e 94 69 4e 	call	0x9cd2	; 0x9cd2 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    9f3c:	81 30       	cpi	r24, 0x01	; 1
    9f3e:	49 f4       	brne	.+18     	; 0x9f52 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    9f40:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    9f42:	80 93 9f 01 	sts	0x019F, r24
		xTickCount = ( portTickType ) 0;
    9f46:	10 92 98 01 	sts	0x0198, r1
    9f4a:	10 92 97 01 	sts	0x0197, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    9f4e:	0e 94 bf 55 	call	0xab7e	; 0xab7e <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    9f52:	0f 91       	pop	r16
    9f54:	ff 90       	pop	r15
    9f56:	ef 90       	pop	r14
    9f58:	df 90       	pop	r13
    9f5a:	cf 90       	pop	r12
    9f5c:	bf 90       	pop	r11
    9f5e:	af 90       	pop	r10
    9f60:	08 95       	ret

00009f62 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    9f62:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    9f64:	0f b6       	in	r0, 0x3f	; 63
    9f66:	f8 94       	cli
    9f68:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    9f6a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9f6c:	0f 90       	pop	r0
    9f6e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    9f70:	08 95       	ret

00009f72 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    9f72:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    9f74:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    9f76:	08 95       	ret

00009f78 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    9f78:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    9f7a:	82 8d       	ldd	r24, Z+26	; 0x1a
    9f7c:	90 e0       	ldi	r25, 0x00	; 0
    9f7e:	88 23       	and	r24, r24
    9f80:	09 f4       	brne	.+2      	; 0x9f84 <xQueueIsQueueEmptyFromISR+0xc>
    9f82:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    9f84:	89 2f       	mov	r24, r25
    9f86:	08 95       	ret

00009f88 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    9f88:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    9f8a:	92 8d       	ldd	r25, Z+26	; 0x1a
    9f8c:	20 e0       	ldi	r18, 0x00	; 0
    9f8e:	83 8d       	ldd	r24, Z+27	; 0x1b
    9f90:	98 17       	cp	r25, r24
    9f92:	09 f4       	brne	.+2      	; 0x9f96 <xQueueIsQueueFullFromISR+0xe>
    9f94:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    9f96:	82 2f       	mov	r24, r18
    9f98:	08 95       	ret

00009f9a <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    9f9a:	0f 93       	push	r16
    9f9c:	1f 93       	push	r17
    9f9e:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    9fa0:	fc 01       	movw	r30, r24
    9fa2:	80 81       	ld	r24, Z
    9fa4:	91 81       	ldd	r25, Z+1	; 0x01
    9fa6:	0e 94 40 55 	call	0xaa80	; 0xaa80 <vPortFree>
	vPortFree( pxQueue );
    9faa:	c8 01       	movw	r24, r16
    9fac:	0e 94 40 55 	call	0xaa80	; 0xaa80 <vPortFree>
}
    9fb0:	1f 91       	pop	r17
    9fb2:	0f 91       	pop	r16
    9fb4:	08 95       	ret

00009fb6 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    9fb6:	0f 93       	push	r16
    9fb8:	1f 93       	push	r17
    9fba:	cf 93       	push	r28
    9fbc:	df 93       	push	r29
    9fbe:	ec 01       	movw	r28, r24
    9fc0:	fb 01       	movw	r30, r22
    9fc2:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    9fc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9fc6:	88 23       	and	r24, r24
    9fc8:	81 f1       	breq	.+96     	; 0xa02a <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    9fca:	48 81       	ld	r20, Y
    9fcc:	59 81       	ldd	r21, Y+1	; 0x01
    9fce:	41 15       	cp	r20, r1
    9fd0:	51 05       	cpc	r21, r1
    9fd2:	a9 f0       	breq	.+42     	; 0x9ffe <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    9fd4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    9fd6:	2e 81       	ldd	r18, Y+6	; 0x06
    9fd8:	3f 81       	ldd	r19, Y+7	; 0x07
    9fda:	28 0f       	add	r18, r24
    9fdc:	31 1d       	adc	r19, r1
    9fde:	3f 83       	std	Y+7, r19	; 0x07
    9fe0:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    9fe2:	8a 81       	ldd	r24, Y+2	; 0x02
    9fe4:	9b 81       	ldd	r25, Y+3	; 0x03
    9fe6:	28 17       	cp	r18, r24
    9fe8:	39 07       	cpc	r19, r25
    9fea:	10 f0       	brcs	.+4      	; 0x9ff0 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    9fec:	5f 83       	std	Y+7, r21	; 0x07
    9fee:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    9ff0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9ff2:	6e 81       	ldd	r22, Y+6	; 0x06
    9ff4:	7f 81       	ldd	r23, Y+7	; 0x07
    9ff6:	cf 01       	movw	r24, r30
    9ff8:	50 e0       	ldi	r21, 0x00	; 0
    9ffa:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    9ffe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    a000:	81 50       	subi	r24, 0x01	; 1
    a002:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    a004:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a006:	8f 3f       	cpi	r24, 0xFF	; 255
    a008:	69 f4       	brne	.+26     	; 0xa024 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    a00a:	88 85       	ldd	r24, Y+8	; 0x08
    a00c:	88 23       	and	r24, r24
    a00e:	61 f0       	breq	.+24     	; 0xa028 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    a010:	ce 01       	movw	r24, r28
    a012:	08 96       	adiw	r24, 0x08	; 8
    a014:	0e 94 05 4a 	call	0x940a	; 0x940a <xTaskRemoveFromEventList>
    a018:	88 23       	and	r24, r24
    a01a:	31 f0       	breq	.+12     	; 0xa028 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    a01c:	81 e0       	ldi	r24, 0x01	; 1
    a01e:	f8 01       	movw	r30, r16
    a020:	80 83       	st	Z, r24
    a022:	03 c0       	rjmp	.+6      	; 0xa02a <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    a024:	8f 5f       	subi	r24, 0xFF	; 255
    a026:	8d 8f       	std	Y+29, r24	; 0x1d
    a028:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    a02a:	df 91       	pop	r29
    a02c:	cf 91       	pop	r28
    a02e:	1f 91       	pop	r17
    a030:	0f 91       	pop	r16
    a032:	08 95       	ret

0000a034 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    a034:	cf 93       	push	r28
    a036:	df 93       	push	r29
    a038:	ec 01       	movw	r28, r24
    a03a:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    a03c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a03e:	44 23       	and	r20, r20
    a040:	a1 f1       	breq	.+104    	; 0xa0aa <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    a042:	88 23       	and	r24, r24
    a044:	b1 f4       	brne	.+44     	; 0xa072 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    a046:	8c 81       	ldd	r24, Y+4	; 0x04
    a048:	9d 81       	ldd	r25, Y+5	; 0x05
    a04a:	50 e0       	ldi	r21, 0x00	; 0
    a04c:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    a050:	8c 8d       	ldd	r24, Y+28	; 0x1c
    a052:	2c 81       	ldd	r18, Y+4	; 0x04
    a054:	3d 81       	ldd	r19, Y+5	; 0x05
    a056:	28 0f       	add	r18, r24
    a058:	31 1d       	adc	r19, r1
    a05a:	3d 83       	std	Y+5, r19	; 0x05
    a05c:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    a05e:	8a 81       	ldd	r24, Y+2	; 0x02
    a060:	9b 81       	ldd	r25, Y+3	; 0x03
    a062:	28 17       	cp	r18, r24
    a064:	39 07       	cpc	r19, r25
    a066:	08 f1       	brcs	.+66     	; 0xa0aa <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    a068:	88 81       	ld	r24, Y
    a06a:	99 81       	ldd	r25, Y+1	; 0x01
    a06c:	9d 83       	std	Y+5, r25	; 0x05
    a06e:	8c 83       	std	Y+4, r24	; 0x04
    a070:	1c c0       	rjmp	.+56     	; 0xa0aa <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    a072:	8e 81       	ldd	r24, Y+6	; 0x06
    a074:	9f 81       	ldd	r25, Y+7	; 0x07
    a076:	50 e0       	ldi	r21, 0x00	; 0
    a078:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    a07c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    a07e:	90 e0       	ldi	r25, 0x00	; 0
    a080:	44 27       	eor	r20, r20
    a082:	55 27       	eor	r21, r21
    a084:	48 1b       	sub	r20, r24
    a086:	59 0b       	sbc	r21, r25
    a088:	8e 81       	ldd	r24, Y+6	; 0x06
    a08a:	9f 81       	ldd	r25, Y+7	; 0x07
    a08c:	84 0f       	add	r24, r20
    a08e:	95 1f       	adc	r25, r21
    a090:	9f 83       	std	Y+7, r25	; 0x07
    a092:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    a094:	28 81       	ld	r18, Y
    a096:	39 81       	ldd	r19, Y+1	; 0x01
    a098:	82 17       	cp	r24, r18
    a09a:	93 07       	cpc	r25, r19
    a09c:	30 f4       	brcc	.+12     	; 0xa0aa <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    a09e:	8a 81       	ldd	r24, Y+2	; 0x02
    a0a0:	9b 81       	ldd	r25, Y+3	; 0x03
    a0a2:	84 0f       	add	r24, r20
    a0a4:	95 1f       	adc	r25, r21
    a0a6:	9f 83       	std	Y+7, r25	; 0x07
    a0a8:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    a0aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    a0ac:	8f 5f       	subi	r24, 0xFF	; 255
    a0ae:	8a 8f       	std	Y+26, r24	; 0x1a
}
    a0b0:	df 91       	pop	r29
    a0b2:	cf 91       	pop	r28
    a0b4:	08 95       	ret

0000a0b6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    a0b6:	0f 93       	push	r16
    a0b8:	1f 93       	push	r17
    a0ba:	cf 93       	push	r28
    a0bc:	df 93       	push	r29
    a0be:	ec 01       	movw	r28, r24
    a0c0:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    a0c2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a0c4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    a0c6:	98 17       	cp	r25, r24
    a0c8:	10 f0       	brcs	.+4      	; 0xa0ce <xQueueGenericSendFromISR+0x18>
    a0ca:	80 e0       	ldi	r24, 0x00	; 0
    a0cc:	17 c0       	rjmp	.+46     	; 0xa0fc <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    a0ce:	ce 01       	movw	r24, r28
    a0d0:	42 2f       	mov	r20, r18
    a0d2:	0e 94 1a 50 	call	0xa034	; 0xa034 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    a0d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    a0d8:	8f 3f       	cpi	r24, 0xFF	; 255
    a0da:	69 f4       	brne	.+26     	; 0xa0f6 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    a0dc:	89 89       	ldd	r24, Y+17	; 0x11
    a0de:	88 23       	and	r24, r24
    a0e0:	61 f0       	breq	.+24     	; 0xa0fa <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a0e2:	ce 01       	movw	r24, r28
    a0e4:	41 96       	adiw	r24, 0x11	; 17
    a0e6:	0e 94 05 4a 	call	0x940a	; 0x940a <xTaskRemoveFromEventList>
    a0ea:	88 23       	and	r24, r24
    a0ec:	31 f0       	breq	.+12     	; 0xa0fa <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    a0ee:	81 e0       	ldi	r24, 0x01	; 1
    a0f0:	f8 01       	movw	r30, r16
    a0f2:	80 83       	st	Z, r24
    a0f4:	03 c0       	rjmp	.+6      	; 0xa0fc <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    a0f6:	8f 5f       	subi	r24, 0xFF	; 255
    a0f8:	8e 8f       	std	Y+30, r24	; 0x1e
    a0fa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    a0fc:	df 91       	pop	r29
    a0fe:	cf 91       	pop	r28
    a100:	1f 91       	pop	r17
    a102:	0f 91       	pop	r16
    a104:	08 95       	ret

0000a106 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    a106:	0f 93       	push	r16
    a108:	1f 93       	push	r17
    a10a:	cf 93       	push	r28
    a10c:	df 93       	push	r29
    a10e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    a110:	0f b6       	in	r0, 0x3f	; 63
    a112:	f8 94       	cli
    a114:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a116:	8c 01       	movw	r16, r24
    a118:	0f 5e       	subi	r16, 0xEF	; 239
    a11a:	1f 4f       	sbci	r17, 0xFF	; 255
    a11c:	0d c0       	rjmp	.+26     	; 0xa138 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    a11e:	89 89       	ldd	r24, Y+17	; 0x11
    a120:	88 23       	and	r24, r24
    a122:	69 f0       	breq	.+26     	; 0xa13e <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a124:	c8 01       	movw	r24, r16
    a126:	0e 94 05 4a 	call	0x940a	; 0x940a <xTaskRemoveFromEventList>
    a12a:	88 23       	and	r24, r24
    a12c:	11 f0       	breq	.+4      	; 0xa132 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    a12e:	0e 94 01 4a 	call	0x9402	; 0x9402 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    a132:	8e 8d       	ldd	r24, Y+30	; 0x1e
    a134:	81 50       	subi	r24, 0x01	; 1
    a136:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    a138:	8e 8d       	ldd	r24, Y+30	; 0x1e
    a13a:	18 16       	cp	r1, r24
    a13c:	84 f3       	brlt	.-32     	; 0xa11e <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    a13e:	8f ef       	ldi	r24, 0xFF	; 255
    a140:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    a142:	0f 90       	pop	r0
    a144:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    a146:	0f b6       	in	r0, 0x3f	; 63
    a148:	f8 94       	cli
    a14a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    a14c:	8e 01       	movw	r16, r28
    a14e:	08 5f       	subi	r16, 0xF8	; 248
    a150:	1f 4f       	sbci	r17, 0xFF	; 255
    a152:	0d c0       	rjmp	.+26     	; 0xa16e <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    a154:	88 85       	ldd	r24, Y+8	; 0x08
    a156:	88 23       	and	r24, r24
    a158:	69 f0       	breq	.+26     	; 0xa174 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    a15a:	c8 01       	movw	r24, r16
    a15c:	0e 94 05 4a 	call	0x940a	; 0x940a <xTaskRemoveFromEventList>
    a160:	88 23       	and	r24, r24
    a162:	11 f0       	breq	.+4      	; 0xa168 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    a164:	0e 94 01 4a 	call	0x9402	; 0x9402 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    a168:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a16a:	81 50       	subi	r24, 0x01	; 1
    a16c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    a16e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a170:	18 16       	cp	r1, r24
    a172:	84 f3       	brlt	.-32     	; 0xa154 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    a174:	8f ef       	ldi	r24, 0xFF	; 255
    a176:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    a178:	0f 90       	pop	r0
    a17a:	0f be       	out	0x3f, r0	; 63
}
    a17c:	df 91       	pop	r29
    a17e:	cf 91       	pop	r28
    a180:	1f 91       	pop	r17
    a182:	0f 91       	pop	r16
    a184:	08 95       	ret

0000a186 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    a186:	7f 92       	push	r7
    a188:	8f 92       	push	r8
    a18a:	9f 92       	push	r9
    a18c:	af 92       	push	r10
    a18e:	bf 92       	push	r11
    a190:	cf 92       	push	r12
    a192:	df 92       	push	r13
    a194:	ef 92       	push	r14
    a196:	ff 92       	push	r15
    a198:	0f 93       	push	r16
    a19a:	1f 93       	push	r17
    a19c:	df 93       	push	r29
    a19e:	cf 93       	push	r28
    a1a0:	00 d0       	rcall	.+0      	; 0xa1a2 <xQueueGenericReceive+0x1c>
    a1a2:	00 d0       	rcall	.+0      	; 0xa1a4 <xQueueGenericReceive+0x1e>
    a1a4:	0f 92       	push	r0
    a1a6:	cd b7       	in	r28, 0x3d	; 61
    a1a8:	de b7       	in	r29, 0x3e	; 62
    a1aa:	8c 01       	movw	r16, r24
    a1ac:	96 2e       	mov	r9, r22
    a1ae:	87 2e       	mov	r8, r23
    a1b0:	5d 83       	std	Y+5, r21	; 0x05
    a1b2:	4c 83       	std	Y+4, r20	; 0x04
    a1b4:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    a1b6:	91 e1       	ldi	r25, 0x11	; 17
    a1b8:	c9 2e       	mov	r12, r25
    a1ba:	d1 2c       	mov	r13, r1
    a1bc:	c0 0e       	add	r12, r16
    a1be:	d1 1e       	adc	r13, r17
    a1c0:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a1c2:	7e 01       	movw	r14, r28
    a1c4:	08 94       	sec
    a1c6:	e1 1c       	adc	r14, r1
    a1c8:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    a1ca:	84 e0       	ldi	r24, 0x04	; 4
    a1cc:	a8 2e       	mov	r10, r24
    a1ce:	b1 2c       	mov	r11, r1
    a1d0:	ac 0e       	add	r10, r28
    a1d2:	bd 1e       	adc	r11, r29
    a1d4:	01 c0       	rjmp	.+2      	; 0xa1d8 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    a1d6:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    a1d8:	0f b6       	in	r0, 0x3f	; 63
    a1da:	f8 94       	cli
    a1dc:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    a1de:	f8 01       	movw	r30, r16
    a1e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    a1e2:	88 23       	and	r24, r24
    a1e4:	09 f4       	brne	.+2      	; 0xa1e8 <xQueueGenericReceive+0x62>
    a1e6:	3e c0       	rjmp	.+124    	; 0xa264 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    a1e8:	e6 80       	ldd	r14, Z+6	; 0x06
    a1ea:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    a1ec:	40 81       	ld	r20, Z
    a1ee:	51 81       	ldd	r21, Z+1	; 0x01
    a1f0:	41 15       	cp	r20, r1
    a1f2:	51 05       	cpc	r21, r1
    a1f4:	b1 f0       	breq	.+44     	; 0xa222 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    a1f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    a1f8:	97 01       	movw	r18, r14
    a1fa:	28 0f       	add	r18, r24
    a1fc:	31 1d       	adc	r19, r1
    a1fe:	37 83       	std	Z+7, r19	; 0x07
    a200:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    a202:	82 81       	ldd	r24, Z+2	; 0x02
    a204:	93 81       	ldd	r25, Z+3	; 0x03
    a206:	28 17       	cp	r18, r24
    a208:	39 07       	cpc	r19, r25
    a20a:	10 f0       	brcs	.+4      	; 0xa210 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    a20c:	57 83       	std	Z+7, r21	; 0x07
    a20e:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    a210:	f8 01       	movw	r30, r16
    a212:	44 8d       	ldd	r20, Z+28	; 0x1c
    a214:	66 81       	ldd	r22, Z+6	; 0x06
    a216:	77 81       	ldd	r23, Z+7	; 0x07
    a218:	89 2d       	mov	r24, r9
    a21a:	98 2d       	mov	r25, r8
    a21c:	50 e0       	ldi	r21, 0x00	; 0
    a21e:	0e 94 45 59 	call	0xb28a	; 0xb28a <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    a222:	77 20       	and	r7, r7
    a224:	71 f4       	brne	.+28     	; 0xa242 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    a226:	f8 01       	movw	r30, r16
    a228:	82 8d       	ldd	r24, Z+26	; 0x1a
    a22a:	81 50       	subi	r24, 0x01	; 1
    a22c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    a22e:	80 85       	ldd	r24, Z+8	; 0x08
    a230:	88 23       	and	r24, r24
    a232:	a1 f0       	breq	.+40     	; 0xa25c <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    a234:	c8 01       	movw	r24, r16
    a236:	08 96       	adiw	r24, 0x08	; 8
    a238:	0e 94 05 4a 	call	0x940a	; 0x940a <xTaskRemoveFromEventList>
    a23c:	81 30       	cpi	r24, 0x01	; 1
    a23e:	71 f4       	brne	.+28     	; 0xa25c <xQueueGenericReceive+0xd6>
    a240:	0b c0       	rjmp	.+22     	; 0xa258 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    a242:	f8 01       	movw	r30, r16
    a244:	f7 82       	std	Z+7, r15	; 0x07
    a246:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    a248:	81 89       	ldd	r24, Z+17	; 0x11
    a24a:	88 23       	and	r24, r24
    a24c:	39 f0       	breq	.+14     	; 0xa25c <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    a24e:	c6 01       	movw	r24, r12
    a250:	0e 94 05 4a 	call	0x940a	; 0x940a <xTaskRemoveFromEventList>
    a254:	88 23       	and	r24, r24
    a256:	11 f0       	breq	.+4      	; 0xa25c <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    a258:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    a25c:	0f 90       	pop	r0
    a25e:	0f be       	out	0x3f, r0	; 63
    a260:	81 e0       	ldi	r24, 0x01	; 1
    a262:	4a c0       	rjmp	.+148    	; 0xa2f8 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    a264:	8c 81       	ldd	r24, Y+4	; 0x04
    a266:	9d 81       	ldd	r25, Y+5	; 0x05
    a268:	89 2b       	or	r24, r25
    a26a:	19 f4       	brne	.+6      	; 0xa272 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    a26c:	0f 90       	pop	r0
    a26e:	0f be       	out	0x3f, r0	; 63
    a270:	42 c0       	rjmp	.+132    	; 0xa2f6 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    a272:	22 23       	and	r18, r18
    a274:	19 f4       	brne	.+6      	; 0xa27c <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a276:	c7 01       	movw	r24, r14
    a278:	0e 94 b8 49 	call	0x9370	; 0x9370 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    a27c:	0f 90       	pop	r0
    a27e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    a280:	0e 94 e1 48 	call	0x91c2	; 0x91c2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    a284:	0f b6       	in	r0, 0x3f	; 63
    a286:	f8 94       	cli
    a288:	0f 92       	push	r0
    a28a:	f8 01       	movw	r30, r16
    a28c:	85 8d       	ldd	r24, Z+29	; 0x1d
    a28e:	8f 3f       	cpi	r24, 0xFF	; 255
    a290:	09 f4       	brne	.+2      	; 0xa294 <xQueueGenericReceive+0x10e>
    a292:	15 8e       	std	Z+29, r1	; 0x1d
    a294:	f8 01       	movw	r30, r16
    a296:	86 8d       	ldd	r24, Z+30	; 0x1e
    a298:	8f 3f       	cpi	r24, 0xFF	; 255
    a29a:	09 f4       	brne	.+2      	; 0xa29e <xQueueGenericReceive+0x118>
    a29c:	16 8e       	std	Z+30, r1	; 0x1e
    a29e:	0f 90       	pop	r0
    a2a0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    a2a2:	c7 01       	movw	r24, r14
    a2a4:	b5 01       	movw	r22, r10
    a2a6:	0e 94 c3 49 	call	0x9386	; 0x9386 <xTaskCheckForTimeOut>
    a2aa:	88 23       	and	r24, r24
    a2ac:	f9 f4       	brne	.+62     	; 0xa2ec <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    a2ae:	0f b6       	in	r0, 0x3f	; 63
    a2b0:	f8 94       	cli
    a2b2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    a2b4:	f8 01       	movw	r30, r16
    a2b6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    a2b8:	0f 90       	pop	r0
    a2ba:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    a2bc:	88 23       	and	r24, r24
    a2be:	81 f4       	brne	.+32     	; 0xa2e0 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    a2c0:	6c 81       	ldd	r22, Y+4	; 0x04
    a2c2:	7d 81       	ldd	r23, Y+5	; 0x05
    a2c4:	c6 01       	movw	r24, r12
    a2c6:	0e 94 96 4a 	call	0x952c	; 0x952c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    a2ca:	c8 01       	movw	r24, r16
    a2cc:	0e 94 83 50 	call	0xa106	; 0xa106 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    a2d0:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
    a2d4:	88 23       	and	r24, r24
    a2d6:	09 f0       	breq	.+2      	; 0xa2da <xQueueGenericReceive+0x154>
    a2d8:	7e cf       	rjmp	.-260    	; 0xa1d6 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    a2da:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
    a2de:	7b cf       	rjmp	.-266    	; 0xa1d6 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    a2e0:	c8 01       	movw	r24, r16
    a2e2:	0e 94 83 50 	call	0xa106	; 0xa106 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    a2e6:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
    a2ea:	75 cf       	rjmp	.-278    	; 0xa1d6 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    a2ec:	c8 01       	movw	r24, r16
    a2ee:	0e 94 83 50 	call	0xa106	; 0xa106 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    a2f2:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
    a2f6:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    a2f8:	0f 90       	pop	r0
    a2fa:	0f 90       	pop	r0
    a2fc:	0f 90       	pop	r0
    a2fe:	0f 90       	pop	r0
    a300:	0f 90       	pop	r0
    a302:	cf 91       	pop	r28
    a304:	df 91       	pop	r29
    a306:	1f 91       	pop	r17
    a308:	0f 91       	pop	r16
    a30a:	ff 90       	pop	r15
    a30c:	ef 90       	pop	r14
    a30e:	df 90       	pop	r13
    a310:	cf 90       	pop	r12
    a312:	bf 90       	pop	r11
    a314:	af 90       	pop	r10
    a316:	9f 90       	pop	r9
    a318:	8f 90       	pop	r8
    a31a:	7f 90       	pop	r7
    a31c:	08 95       	ret

0000a31e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    a31e:	7f 92       	push	r7
    a320:	8f 92       	push	r8
    a322:	9f 92       	push	r9
    a324:	af 92       	push	r10
    a326:	bf 92       	push	r11
    a328:	cf 92       	push	r12
    a32a:	df 92       	push	r13
    a32c:	ef 92       	push	r14
    a32e:	ff 92       	push	r15
    a330:	0f 93       	push	r16
    a332:	1f 93       	push	r17
    a334:	df 93       	push	r29
    a336:	cf 93       	push	r28
    a338:	00 d0       	rcall	.+0      	; 0xa33a <xQueueGenericSend+0x1c>
    a33a:	00 d0       	rcall	.+0      	; 0xa33c <xQueueGenericSend+0x1e>
    a33c:	0f 92       	push	r0
    a33e:	cd b7       	in	r28, 0x3d	; 61
    a340:	de b7       	in	r29, 0x3e	; 62
    a342:	8c 01       	movw	r16, r24
    a344:	6b 01       	movw	r12, r22
    a346:	5d 83       	std	Y+5, r21	; 0x05
    a348:	4c 83       	std	Y+4, r20	; 0x04
    a34a:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    a34c:	48 e0       	ldi	r20, 0x08	; 8
    a34e:	e4 2e       	mov	r14, r20
    a350:	f1 2c       	mov	r15, r1
    a352:	e8 0e       	add	r14, r24
    a354:	f9 1e       	adc	r15, r25
    a356:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a358:	5e 01       	movw	r10, r28
    a35a:	08 94       	sec
    a35c:	a1 1c       	adc	r10, r1
    a35e:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    a360:	34 e0       	ldi	r19, 0x04	; 4
    a362:	83 2e       	mov	r8, r19
    a364:	91 2c       	mov	r9, r1
    a366:	8c 0e       	add	r8, r28
    a368:	9d 1e       	adc	r9, r29
    a36a:	01 c0       	rjmp	.+2      	; 0xa36e <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    a36c:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    a36e:	0f b6       	in	r0, 0x3f	; 63
    a370:	f8 94       	cli
    a372:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    a374:	f8 01       	movw	r30, r16
    a376:	92 8d       	ldd	r25, Z+26	; 0x1a
    a378:	83 8d       	ldd	r24, Z+27	; 0x1b
    a37a:	98 17       	cp	r25, r24
    a37c:	a8 f4       	brcc	.+42     	; 0xa3a8 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    a37e:	c8 01       	movw	r24, r16
    a380:	b6 01       	movw	r22, r12
    a382:	47 2d       	mov	r20, r7
    a384:	0e 94 1a 50 	call	0xa034	; 0xa034 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    a388:	f8 01       	movw	r30, r16
    a38a:	81 89       	ldd	r24, Z+17	; 0x11
    a38c:	88 23       	and	r24, r24
    a38e:	41 f0       	breq	.+16     	; 0xa3a0 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    a390:	c8 01       	movw	r24, r16
    a392:	41 96       	adiw	r24, 0x11	; 17
    a394:	0e 94 05 4a 	call	0x940a	; 0x940a <xTaskRemoveFromEventList>
    a398:	81 30       	cpi	r24, 0x01	; 1
    a39a:	11 f4       	brne	.+4      	; 0xa3a0 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    a39c:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    a3a0:	0f 90       	pop	r0
    a3a2:	0f be       	out	0x3f, r0	; 63
    a3a4:	81 e0       	ldi	r24, 0x01	; 1
    a3a6:	4c c0       	rjmp	.+152    	; 0xa440 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    a3a8:	8c 81       	ldd	r24, Y+4	; 0x04
    a3aa:	9d 81       	ldd	r25, Y+5	; 0x05
    a3ac:	89 2b       	or	r24, r25
    a3ae:	19 f4       	brne	.+6      	; 0xa3b6 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    a3b0:	0f 90       	pop	r0
    a3b2:	0f be       	out	0x3f, r0	; 63
    a3b4:	44 c0       	rjmp	.+136    	; 0xa43e <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    a3b6:	22 23       	and	r18, r18
    a3b8:	19 f4       	brne	.+6      	; 0xa3c0 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    a3ba:	c5 01       	movw	r24, r10
    a3bc:	0e 94 b8 49 	call	0x9370	; 0x9370 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    a3c0:	0f 90       	pop	r0
    a3c2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    a3c4:	0e 94 e1 48 	call	0x91c2	; 0x91c2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    a3c8:	0f b6       	in	r0, 0x3f	; 63
    a3ca:	f8 94       	cli
    a3cc:	0f 92       	push	r0
    a3ce:	f8 01       	movw	r30, r16
    a3d0:	85 8d       	ldd	r24, Z+29	; 0x1d
    a3d2:	8f 3f       	cpi	r24, 0xFF	; 255
    a3d4:	09 f4       	brne	.+2      	; 0xa3d8 <xQueueGenericSend+0xba>
    a3d6:	15 8e       	std	Z+29, r1	; 0x1d
    a3d8:	f8 01       	movw	r30, r16
    a3da:	86 8d       	ldd	r24, Z+30	; 0x1e
    a3dc:	8f 3f       	cpi	r24, 0xFF	; 255
    a3de:	09 f4       	brne	.+2      	; 0xa3e2 <xQueueGenericSend+0xc4>
    a3e0:	16 8e       	std	Z+30, r1	; 0x1e
    a3e2:	0f 90       	pop	r0
    a3e4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    a3e6:	c5 01       	movw	r24, r10
    a3e8:	b4 01       	movw	r22, r8
    a3ea:	0e 94 c3 49 	call	0x9386	; 0x9386 <xTaskCheckForTimeOut>
    a3ee:	88 23       	and	r24, r24
    a3f0:	09 f5       	brne	.+66     	; 0xa434 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    a3f2:	0f b6       	in	r0, 0x3f	; 63
    a3f4:	f8 94       	cli
    a3f6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    a3f8:	f8 01       	movw	r30, r16
    a3fa:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    a3fc:	0f 90       	pop	r0
    a3fe:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    a400:	f8 01       	movw	r30, r16
    a402:	83 8d       	ldd	r24, Z+27	; 0x1b
    a404:	98 17       	cp	r25, r24
    a406:	81 f4       	brne	.+32     	; 0xa428 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    a408:	6c 81       	ldd	r22, Y+4	; 0x04
    a40a:	7d 81       	ldd	r23, Y+5	; 0x05
    a40c:	c7 01       	movw	r24, r14
    a40e:	0e 94 96 4a 	call	0x952c	; 0x952c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    a412:	c8 01       	movw	r24, r16
    a414:	0e 94 83 50 	call	0xa106	; 0xa106 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    a418:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
    a41c:	88 23       	and	r24, r24
    a41e:	09 f0       	breq	.+2      	; 0xa422 <xQueueGenericSend+0x104>
    a420:	a5 cf       	rjmp	.-182    	; 0xa36c <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    a422:	0e 94 79 56 	call	0xacf2	; 0xacf2 <vPortYield>
    a426:	a2 cf       	rjmp	.-188    	; 0xa36c <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    a428:	c8 01       	movw	r24, r16
    a42a:	0e 94 83 50 	call	0xa106	; 0xa106 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    a42e:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
    a432:	9c cf       	rjmp	.-200    	; 0xa36c <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    a434:	c8 01       	movw	r24, r16
    a436:	0e 94 83 50 	call	0xa106	; 0xa106 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    a43a:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
    a43e:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    a440:	0f 90       	pop	r0
    a442:	0f 90       	pop	r0
    a444:	0f 90       	pop	r0
    a446:	0f 90       	pop	r0
    a448:	0f 90       	pop	r0
    a44a:	cf 91       	pop	r28
    a44c:	df 91       	pop	r29
    a44e:	1f 91       	pop	r17
    a450:	0f 91       	pop	r16
    a452:	ff 90       	pop	r15
    a454:	ef 90       	pop	r14
    a456:	df 90       	pop	r13
    a458:	cf 90       	pop	r12
    a45a:	bf 90       	pop	r11
    a45c:	af 90       	pop	r10
    a45e:	9f 90       	pop	r9
    a460:	8f 90       	pop	r8
    a462:	7f 90       	pop	r7
    a464:	08 95       	ret

0000a466 <xQueueCreateExternal>:
	was required. */
	return NULL;
}

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    a466:	ef 92       	push	r14
    a468:	ff 92       	push	r15
    a46a:	0f 93       	push	r16
    a46c:	1f 93       	push	r17
    a46e:	cf 93       	push	r28
    a470:	df 93       	push	r29
    a472:	18 2f       	mov	r17, r24
    a474:	e6 2e       	mov	r14, r22
    a476:	04 2f       	mov	r16, r20
    a478:	f5 2e       	mov	r15, r21
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    a47a:	88 23       	and	r24, r24
    a47c:	f1 f1       	breq	.+124    	; 0xa4fa <xQueueCreateExternal+0x94>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    a47e:	8f e1       	ldi	r24, 0x1F	; 31
    a480:	90 e0       	ldi	r25, 0x00	; 0
    a482:	0e 94 50 55 	call	0xaaa0	; 0xaaa0 <pvPortMalloc>
    a486:	fc 01       	movw	r30, r24
    a488:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    a48a:	00 97       	sbiw	r24, 0x00	; 0
    a48c:	c1 f1       	breq	.+112    	; 0xa4fe <xQueueCreateExternal+0x98>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    a48e:	60 2f       	mov	r22, r16
    a490:	7f 2d       	mov	r23, r15
    a492:	71 83       	std	Z+1, r23	; 0x01
    a494:	60 83       	st	Z, r22
			if( pxNewQueue->pcHead != NULL )
    a496:	61 15       	cp	r22, r1
    a498:	71 05       	cpc	r23, r1
    a49a:	69 f1       	breq	.+90     	; 0xa4f6 <xQueueCreateExternal+0x90>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    a49c:	21 2f       	mov	r18, r17
    a49e:	30 e0       	ldi	r19, 0x00	; 0
    a4a0:	4e 2d       	mov	r20, r14
    a4a2:	50 e0       	ldi	r21, 0x00	; 0
    a4a4:	42 9f       	mul	r20, r18
    a4a6:	c0 01       	movw	r24, r0
    a4a8:	43 9f       	mul	r20, r19
    a4aa:	90 0d       	add	r25, r0
    a4ac:	52 9f       	mul	r21, r18
    a4ae:	90 0d       	add	r25, r0
    a4b0:	11 24       	eor	r1, r1
    a4b2:	86 0f       	add	r24, r22
    a4b4:	97 1f       	adc	r25, r23
    a4b6:	93 83       	std	Z+3, r25	; 0x03
    a4b8:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    a4ba:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    a4bc:	75 83       	std	Z+5, r23	; 0x05
    a4be:	64 83       	std	Z+4, r22	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    a4c0:	21 50       	subi	r18, 0x01	; 1
    a4c2:	30 40       	sbci	r19, 0x00	; 0
    a4c4:	24 9f       	mul	r18, r20
    a4c6:	c0 01       	movw	r24, r0
    a4c8:	25 9f       	mul	r18, r21
    a4ca:	90 0d       	add	r25, r0
    a4cc:	34 9f       	mul	r19, r20
    a4ce:	90 0d       	add	r25, r0
    a4d0:	11 24       	eor	r1, r1
    a4d2:	68 0f       	add	r22, r24
    a4d4:	79 1f       	adc	r23, r25
    a4d6:	77 83       	std	Z+7, r23	; 0x07
    a4d8:	66 83       	std	Z+6, r22	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    a4da:	13 8f       	std	Z+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    a4dc:	e4 8e       	std	Z+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    a4de:	8f ef       	ldi	r24, 0xFF	; 255
    a4e0:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    a4e2:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    a4e4:	cf 01       	movw	r24, r30
    a4e6:	08 96       	adiw	r24, 0x08	; 8
    a4e8:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    a4ec:	ce 01       	movw	r24, r28
    a4ee:	41 96       	adiw	r24, 0x11	; 17
    a4f0:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
    a4f4:	04 c0       	rjmp	.+8      	; 0xa4fe <xQueueCreateExternal+0x98>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    a4f6:	0e 94 40 55 	call	0xaa80	; 0xaa80 <vPortFree>
    a4fa:	c0 e0       	ldi	r28, 0x00	; 0
    a4fc:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    a4fe:	ce 01       	movw	r24, r28
    a500:	df 91       	pop	r29
    a502:	cf 91       	pop	r28
    a504:	1f 91       	pop	r17
    a506:	0f 91       	pop	r16
    a508:	ff 90       	pop	r15
    a50a:	ef 90       	pop	r14
    a50c:	08 95       	ret

0000a50e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    a50e:	8f 92       	push	r8
    a510:	9f 92       	push	r9
    a512:	af 92       	push	r10
    a514:	bf 92       	push	r11
    a516:	cf 92       	push	r12
    a518:	df 92       	push	r13
    a51a:	ef 92       	push	r14
    a51c:	ff 92       	push	r15
    a51e:	0f 93       	push	r16
    a520:	1f 93       	push	r17
    a522:	cf 93       	push	r28
    a524:	df 93       	push	r29
    a526:	98 2e       	mov	r9, r24
    a528:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    a52a:	88 23       	and	r24, r24
    a52c:	09 f4       	brne	.+2      	; 0xa530 <xQueueCreate+0x22>
    a52e:	42 c0       	rjmp	.+132    	; 0xa5b4 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    a530:	8f e1       	ldi	r24, 0x1F	; 31
    a532:	90 e0       	ldi	r25, 0x00	; 0
    a534:	0e 94 50 55 	call	0xaaa0	; 0xaaa0 <pvPortMalloc>
    a538:	8c 01       	movw	r16, r24
    a53a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    a53c:	00 97       	sbiw	r24, 0x00	; 0
    a53e:	e1 f1       	breq	.+120    	; 0xa5b8 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    a540:	c9 2c       	mov	r12, r9
    a542:	dd 24       	eor	r13, r13
    a544:	a8 2c       	mov	r10, r8
    a546:	bb 24       	eor	r11, r11
    a548:	ac 9c       	mul	r10, r12
    a54a:	70 01       	movw	r14, r0
    a54c:	ad 9c       	mul	r10, r13
    a54e:	f0 0c       	add	r15, r0
    a550:	bc 9c       	mul	r11, r12
    a552:	f0 0c       	add	r15, r0
    a554:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    a556:	c7 01       	movw	r24, r14
    a558:	01 96       	adiw	r24, 0x01	; 1
    a55a:	0e 94 50 55 	call	0xaaa0	; 0xaaa0 <pvPortMalloc>
    a55e:	9c 01       	movw	r18, r24
    a560:	99 83       	std	Y+1, r25	; 0x01
    a562:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    a564:	00 97       	sbiw	r24, 0x00	; 0
    a566:	19 f1       	breq	.+70     	; 0xa5ae <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    a568:	e8 0e       	add	r14, r24
    a56a:	f9 1e       	adc	r15, r25
    a56c:	fb 82       	std	Y+3, r15	; 0x03
    a56e:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    a570:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    a572:	9d 83       	std	Y+5, r25	; 0x05
    a574:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    a576:	08 94       	sec
    a578:	c1 08       	sbc	r12, r1
    a57a:	d1 08       	sbc	r13, r1
    a57c:	ca 9c       	mul	r12, r10
    a57e:	c0 01       	movw	r24, r0
    a580:	cb 9c       	mul	r12, r11
    a582:	90 0d       	add	r25, r0
    a584:	da 9c       	mul	r13, r10
    a586:	90 0d       	add	r25, r0
    a588:	11 24       	eor	r1, r1
    a58a:	28 0f       	add	r18, r24
    a58c:	39 1f       	adc	r19, r25
    a58e:	3f 83       	std	Y+7, r19	; 0x07
    a590:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    a592:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    a594:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    a596:	8f ef       	ldi	r24, 0xFF	; 255
    a598:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    a59a:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    a59c:	c8 01       	movw	r24, r16
    a59e:	08 96       	adiw	r24, 0x08	; 8
    a5a0:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    a5a4:	c8 01       	movw	r24, r16
    a5a6:	41 96       	adiw	r24, 0x11	; 17
    a5a8:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
    a5ac:	05 c0       	rjmp	.+10     	; 0xa5b8 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    a5ae:	c8 01       	movw	r24, r16
    a5b0:	0e 94 40 55 	call	0xaa80	; 0xaa80 <vPortFree>
    a5b4:	c0 e0       	ldi	r28, 0x00	; 0
    a5b6:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    a5b8:	ce 01       	movw	r24, r28
    a5ba:	df 91       	pop	r29
    a5bc:	cf 91       	pop	r28
    a5be:	1f 91       	pop	r17
    a5c0:	0f 91       	pop	r16
    a5c2:	ff 90       	pop	r15
    a5c4:	ef 90       	pop	r14
    a5c6:	df 90       	pop	r13
    a5c8:	cf 90       	pop	r12
    a5ca:	bf 90       	pop	r11
    a5cc:	af 90       	pop	r10
    a5ce:	9f 90       	pop	r9
    a5d0:	8f 90       	pop	r8
    a5d2:	08 95       	ret

0000a5d4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    a5d4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    a5d6:	9c 01       	movw	r18, r24
    a5d8:	2d 5f       	subi	r18, 0xFD	; 253
    a5da:	3f 4f       	sbci	r19, 0xFF	; 255
    a5dc:	32 83       	std	Z+2, r19	; 0x02
    a5de:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    a5e0:	8f ef       	ldi	r24, 0xFF	; 255
    a5e2:	9f ef       	ldi	r25, 0xFF	; 255
    a5e4:	94 83       	std	Z+4, r25	; 0x04
    a5e6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    a5e8:	36 83       	std	Z+6, r19	; 0x06
    a5ea:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    a5ec:	30 87       	std	Z+8, r19	; 0x08
    a5ee:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    a5f0:	10 82       	st	Z, r1
}
    a5f2:	08 95       	ret

0000a5f4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    a5f4:	fc 01       	movw	r30, r24
    a5f6:	11 86       	std	Z+9, r1	; 0x09
    a5f8:	10 86       	std	Z+8, r1	; 0x08
}
    a5fa:	08 95       	ret

0000a5fc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    a5fc:	cf 93       	push	r28
    a5fe:	df 93       	push	r29
    a600:	ac 01       	movw	r20, r24
    a602:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    a604:	ec 01       	movw	r28, r24
    a606:	29 81       	ldd	r18, Y+1	; 0x01
    a608:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    a60a:	f9 01       	movw	r30, r18
    a60c:	82 81       	ldd	r24, Z+2	; 0x02
    a60e:	93 81       	ldd	r25, Z+3	; 0x03
    a610:	13 96       	adiw	r26, 0x03	; 3
    a612:	9c 93       	st	X, r25
    a614:	8e 93       	st	-X, r24
    a616:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    a618:	89 81       	ldd	r24, Y+1	; 0x01
    a61a:	9a 81       	ldd	r25, Y+2	; 0x02
    a61c:	15 96       	adiw	r26, 0x05	; 5
    a61e:	9c 93       	st	X, r25
    a620:	8e 93       	st	-X, r24
    a622:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a624:	02 80       	ldd	r0, Z+2	; 0x02
    a626:	f3 81       	ldd	r31, Z+3	; 0x03
    a628:	e0 2d       	mov	r30, r0
    a62a:	75 83       	std	Z+5, r23	; 0x05
    a62c:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    a62e:	e9 01       	movw	r28, r18
    a630:	7b 83       	std	Y+3, r23	; 0x03
    a632:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    a634:	fa 01       	movw	r30, r20
    a636:	72 83       	std	Z+2, r23	; 0x02
    a638:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a63a:	19 96       	adiw	r26, 0x09	; 9
    a63c:	5c 93       	st	X, r21
    a63e:	4e 93       	st	-X, r20
    a640:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    a642:	80 81       	ld	r24, Z
    a644:	8f 5f       	subi	r24, 0xFF	; 255
    a646:	80 83       	st	Z, r24
}
    a648:	df 91       	pop	r29
    a64a:	cf 91       	pop	r28
    a64c:	08 95       	ret

0000a64e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    a64e:	cf 93       	push	r28
    a650:	df 93       	push	r29
    a652:	9c 01       	movw	r18, r24
    a654:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    a656:	48 81       	ld	r20, Y
    a658:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    a65a:	8f ef       	ldi	r24, 0xFF	; 255
    a65c:	4f 3f       	cpi	r20, 0xFF	; 255
    a65e:	58 07       	cpc	r21, r24
    a660:	21 f4       	brne	.+8      	; 0xa66a <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    a662:	f9 01       	movw	r30, r18
    a664:	a7 81       	ldd	r26, Z+7	; 0x07
    a666:	b0 85       	ldd	r27, Z+8	; 0x08
    a668:	10 c0       	rjmp	.+32     	; 0xa68a <vListInsert+0x3c>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    a66a:	d9 01       	movw	r26, r18
    a66c:	13 96       	adiw	r26, 0x03	; 3
    a66e:	04 c0       	rjmp	.+8      	; 0xa678 <vListInsert+0x2a>
    a670:	12 96       	adiw	r26, 0x02	; 2
    a672:	0d 90       	ld	r0, X+
    a674:	bc 91       	ld	r27, X
    a676:	a0 2d       	mov	r26, r0
    a678:	12 96       	adiw	r26, 0x02	; 2
    a67a:	ed 91       	ld	r30, X+
    a67c:	fc 91       	ld	r31, X
    a67e:	13 97       	sbiw	r26, 0x03	; 3
    a680:	80 81       	ld	r24, Z
    a682:	91 81       	ldd	r25, Z+1	; 0x01
    a684:	48 17       	cp	r20, r24
    a686:	59 07       	cpc	r21, r25
    a688:	98 f7       	brcc	.-26     	; 0xa670 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    a68a:	12 96       	adiw	r26, 0x02	; 2
    a68c:	ed 91       	ld	r30, X+
    a68e:	fc 91       	ld	r31, X
    a690:	13 97       	sbiw	r26, 0x03	; 3
    a692:	fb 83       	std	Y+3, r31	; 0x03
    a694:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a696:	d5 83       	std	Z+5, r29	; 0x05
    a698:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    a69a:	bd 83       	std	Y+5, r27	; 0x05
    a69c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    a69e:	13 96       	adiw	r26, 0x03	; 3
    a6a0:	dc 93       	st	X, r29
    a6a2:	ce 93       	st	-X, r28
    a6a4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a6a6:	39 87       	std	Y+9, r19	; 0x09
    a6a8:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    a6aa:	f9 01       	movw	r30, r18
    a6ac:	80 81       	ld	r24, Z
    a6ae:	8f 5f       	subi	r24, 0xFF	; 255
    a6b0:	80 83       	st	Z, r24
}
    a6b2:	df 91       	pop	r29
    a6b4:	cf 91       	pop	r28
    a6b6:	08 95       	ret

0000a6b8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    a6b8:	cf 93       	push	r28
    a6ba:	df 93       	push	r29
    a6bc:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    a6be:	12 96       	adiw	r26, 0x02	; 2
    a6c0:	ed 91       	ld	r30, X+
    a6c2:	fc 91       	ld	r31, X
    a6c4:	13 97       	sbiw	r26, 0x03	; 3
    a6c6:	14 96       	adiw	r26, 0x04	; 4
    a6c8:	8d 91       	ld	r24, X+
    a6ca:	9c 91       	ld	r25, X
    a6cc:	15 97       	sbiw	r26, 0x05	; 5
    a6ce:	95 83       	std	Z+5, r25	; 0x05
    a6d0:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    a6d2:	14 96       	adiw	r26, 0x04	; 4
    a6d4:	cd 91       	ld	r28, X+
    a6d6:	dc 91       	ld	r29, X
    a6d8:	15 97       	sbiw	r26, 0x05	; 5
    a6da:	fb 83       	std	Y+3, r31	; 0x03
    a6dc:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    a6de:	18 96       	adiw	r26, 0x08	; 8
    a6e0:	ed 91       	ld	r30, X+
    a6e2:	fc 91       	ld	r31, X
    a6e4:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    a6e6:	81 81       	ldd	r24, Z+1	; 0x01
    a6e8:	92 81       	ldd	r25, Z+2	; 0x02
    a6ea:	8a 17       	cp	r24, r26
    a6ec:	9b 07       	cpc	r25, r27
    a6ee:	11 f4       	brne	.+4      	; 0xa6f4 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    a6f0:	d2 83       	std	Z+2, r29	; 0x02
    a6f2:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    a6f4:	19 96       	adiw	r26, 0x09	; 9
    a6f6:	1c 92       	st	X, r1
    a6f8:	1e 92       	st	-X, r1
    a6fa:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    a6fc:	80 81       	ld	r24, Z
    a6fe:	81 50       	subi	r24, 0x01	; 1
    a700:	80 83       	st	Z, r24
}
    a702:	df 91       	pop	r29
    a704:	cf 91       	pop	r28
    a706:	08 95       	ret

0000a708 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    a708:	0f 93       	push	r16
    a70a:	1f 93       	push	r17
    a70c:	cf 93       	push	r28
    a70e:	df 93       	push	r29
    a710:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    a712:	80 81       	ld	r24, Z
    a714:	88 23       	and	r24, r24
    a716:	19 f4       	brne	.+6      	; 0xa71e <xCoRoutineRemoveFromEventList+0x16>
    a718:	c0 e0       	ldi	r28, 0x00	; 0
    a71a:	d0 e0       	ldi	r29, 0x00	; 0
    a71c:	05 c0       	rjmp	.+10     	; 0xa728 <xCoRoutineRemoveFromEventList+0x20>
    a71e:	05 80       	ldd	r0, Z+5	; 0x05
    a720:	f6 81       	ldd	r31, Z+6	; 0x06
    a722:	e0 2d       	mov	r30, r0
    a724:	c6 81       	ldd	r28, Z+6	; 0x06
    a726:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a728:	8e 01       	movw	r16, r28
    a72a:	04 5f       	subi	r16, 0xF4	; 244
    a72c:	1f 4f       	sbci	r17, 0xFF	; 255
    a72e:	c8 01       	movw	r24, r16
    a730:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    a734:	84 e4       	ldi	r24, 0x44	; 68
    a736:	92 e0       	ldi	r25, 0x02	; 2
    a738:	b8 01       	movw	r22, r16
    a73a:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
    a73e:	20 e0       	ldi	r18, 0x00	; 0
    a740:	e0 91 1c 02 	lds	r30, 0x021C
    a744:	f0 91 1d 02 	lds	r31, 0x021D
    a748:	9e 89       	ldd	r25, Y+22	; 0x16
    a74a:	86 89       	ldd	r24, Z+22	; 0x16
    a74c:	98 17       	cp	r25, r24
    a74e:	08 f0       	brcs	.+2      	; 0xa752 <xCoRoutineRemoveFromEventList+0x4a>
    a750:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    a752:	82 2f       	mov	r24, r18
    a754:	df 91       	pop	r29
    a756:	cf 91       	pop	r28
    a758:	1f 91       	pop	r17
    a75a:	0f 91       	pop	r16
    a75c:	08 95       	ret

0000a75e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    a75e:	ff 92       	push	r15
    a760:	0f 93       	push	r16
    a762:	1f 93       	push	r17
    a764:	cf 93       	push	r28
    a766:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    a768:	99 e0       	ldi	r25, 0x09	; 9
    a76a:	f9 2e       	mov	r15, r25
    a76c:	28 c0       	rjmp	.+80     	; 0xa7be <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    a76e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    a770:	80 91 44 02 	lds	r24, 0x0244
    a774:	88 23       	and	r24, r24
    a776:	19 f4       	brne	.+6      	; 0xa77e <vCoRoutineSchedule+0x20>
    a778:	c0 e0       	ldi	r28, 0x00	; 0
    a77a:	d0 e0       	ldi	r29, 0x00	; 0
    a77c:	06 c0       	rjmp	.+12     	; 0xa78a <vCoRoutineSchedule+0x2c>
    a77e:	e0 91 49 02 	lds	r30, 0x0249
    a782:	f0 91 4a 02 	lds	r31, 0x024A
    a786:	c6 81       	ldd	r28, Z+6	; 0x06
    a788:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a78a:	ce 01       	movw	r24, r28
    a78c:	0c 96       	adiw	r24, 0x0c	; 12
    a78e:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    a792:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    a794:	8e 01       	movw	r16, r28
    a796:	0e 5f       	subi	r16, 0xFE	; 254
    a798:	1f 4f       	sbci	r17, 0xFF	; 255
    a79a:	c8 01       	movw	r24, r16
    a79c:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    a7a0:	9e 89       	ldd	r25, Y+22	; 0x16
    a7a2:	80 91 1e 02 	lds	r24, 0x021E
    a7a6:	89 17       	cp	r24, r25
    a7a8:	10 f4       	brcc	.+4      	; 0xa7ae <vCoRoutineSchedule+0x50>
    a7aa:	90 93 1e 02 	sts	0x021E, r25
    a7ae:	9f 9d       	mul	r25, r15
    a7b0:	c0 01       	movw	r24, r0
    a7b2:	11 24       	eor	r1, r1
    a7b4:	8b 5d       	subi	r24, 0xDB	; 219
    a7b6:	9d 4f       	sbci	r25, 0xFD	; 253
    a7b8:	b8 01       	movw	r22, r16
    a7ba:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    a7be:	80 91 44 02 	lds	r24, 0x0244
    a7c2:	88 23       	and	r24, r24
    a7c4:	a1 f6       	brne	.-88     	; 0xa76e <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    a7c6:	0e 94 e7 48 	call	0x91ce	; 0x91ce <xTaskGetTickCount>
    a7ca:	20 91 1f 02 	lds	r18, 0x021F
    a7ce:	30 91 20 02 	lds	r19, 0x0220
    a7d2:	82 1b       	sub	r24, r18
    a7d4:	93 0b       	sbc	r25, r19
    a7d6:	90 93 22 02 	sts	0x0222, r25
    a7da:	80 93 21 02 	sts	0x0221, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    a7de:	89 e0       	ldi	r24, 0x09	; 9
    a7e0:	f8 2e       	mov	r15, r24
    a7e2:	54 c0       	rjmp	.+168    	; 0xa88c <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    a7e4:	01 96       	adiw	r24, 0x01	; 1
    a7e6:	90 93 24 02 	sts	0x0224, r25
    a7ea:	80 93 23 02 	sts	0x0223, r24
		xPassedTicks--;
    a7ee:	21 50       	subi	r18, 0x01	; 1
    a7f0:	30 40       	sbci	r19, 0x00	; 0
    a7f2:	30 93 22 02 	sts	0x0222, r19
    a7f6:	20 93 21 02 	sts	0x0221, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    a7fa:	89 2b       	or	r24, r25
    a7fc:	c9 f5       	brne	.+114    	; 0xa870 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    a7fe:	20 91 40 02 	lds	r18, 0x0240
    a802:	30 91 41 02 	lds	r19, 0x0241
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    a806:	80 91 42 02 	lds	r24, 0x0242
    a80a:	90 91 43 02 	lds	r25, 0x0243
    a80e:	90 93 41 02 	sts	0x0241, r25
    a812:	80 93 40 02 	sts	0x0240, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    a816:	30 93 43 02 	sts	0x0243, r19
    a81a:	20 93 42 02 	sts	0x0242, r18
    a81e:	28 c0       	rjmp	.+80     	; 0xa870 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    a820:	20 91 23 02 	lds	r18, 0x0223
    a824:	30 91 24 02 	lds	r19, 0x0224
    a828:	8a 81       	ldd	r24, Y+2	; 0x02
    a82a:	9b 81       	ldd	r25, Y+3	; 0x03
    a82c:	28 17       	cp	r18, r24
    a82e:	39 07       	cpc	r19, r25
    a830:	68 f1       	brcs	.+90     	; 0xa88c <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    a832:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    a834:	8e 01       	movw	r16, r28
    a836:	0e 5f       	subi	r16, 0xFE	; 254
    a838:	1f 4f       	sbci	r17, 0xFF	; 255
    a83a:	c8 01       	movw	r24, r16
    a83c:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    a840:	8c 89       	ldd	r24, Y+20	; 0x14
    a842:	9d 89       	ldd	r25, Y+21	; 0x15
    a844:	89 2b       	or	r24, r25
    a846:	21 f0       	breq	.+8      	; 0xa850 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    a848:	ce 01       	movw	r24, r28
    a84a:	0c 96       	adiw	r24, 0x0c	; 12
    a84c:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    a850:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    a852:	9e 89       	ldd	r25, Y+22	; 0x16
    a854:	80 91 1e 02 	lds	r24, 0x021E
    a858:	89 17       	cp	r24, r25
    a85a:	10 f4       	brcc	.+4      	; 0xa860 <vCoRoutineSchedule+0x102>
    a85c:	90 93 1e 02 	sts	0x021E, r25
    a860:	9f 9d       	mul	r25, r15
    a862:	c0 01       	movw	r24, r0
    a864:	11 24       	eor	r1, r1
    a866:	8b 5d       	subi	r24, 0xDB	; 219
    a868:	9d 4f       	sbci	r25, 0xFD	; 253
    a86a:	b8 01       	movw	r22, r16
    a86c:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    a870:	e0 91 40 02 	lds	r30, 0x0240
    a874:	f0 91 41 02 	lds	r31, 0x0241
    a878:	80 81       	ld	r24, Z
    a87a:	88 23       	and	r24, r24
    a87c:	39 f0       	breq	.+14     	; 0xa88c <vCoRoutineSchedule+0x12e>
    a87e:	05 80       	ldd	r0, Z+5	; 0x05
    a880:	f6 81       	ldd	r31, Z+6	; 0x06
    a882:	e0 2d       	mov	r30, r0
    a884:	c6 81       	ldd	r28, Z+6	; 0x06
    a886:	d7 81       	ldd	r29, Z+7	; 0x07
    a888:	20 97       	sbiw	r28, 0x00	; 0
    a88a:	51 f6       	brne	.-108    	; 0xa820 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    a88c:	20 91 21 02 	lds	r18, 0x0221
    a890:	30 91 22 02 	lds	r19, 0x0222
    a894:	80 91 23 02 	lds	r24, 0x0223
    a898:	90 91 24 02 	lds	r25, 0x0224
    a89c:	21 15       	cp	r18, r1
    a89e:	31 05       	cpc	r19, r1
    a8a0:	09 f0       	breq	.+2      	; 0xa8a4 <vCoRoutineSchedule+0x146>
    a8a2:	a0 cf       	rjmp	.-192    	; 0xa7e4 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    a8a4:	90 93 20 02 	sts	0x0220, r25
    a8a8:	80 93 1f 02 	sts	0x021F, r24
    a8ac:	90 91 1e 02 	lds	r25, 0x021E

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a8b0:	29 e0       	ldi	r18, 0x09	; 9
    a8b2:	06 c0       	rjmp	.+12     	; 0xa8c0 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    a8b4:	99 23       	and	r25, r25
    a8b6:	19 f4       	brne	.+6      	; 0xa8be <vCoRoutineSchedule+0x160>
    a8b8:	10 92 1e 02 	sts	0x021E, r1
    a8bc:	32 c0       	rjmp	.+100    	; 0xa922 <vCoRoutineSchedule+0x1c4>
    a8be:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a8c0:	92 9f       	mul	r25, r18
    a8c2:	d0 01       	movw	r26, r0
    a8c4:	11 24       	eor	r1, r1
    a8c6:	ab 5d       	subi	r26, 0xDB	; 219
    a8c8:	bd 4f       	sbci	r27, 0xFD	; 253
    a8ca:	8c 91       	ld	r24, X
    a8cc:	88 23       	and	r24, r24
    a8ce:	91 f3       	breq	.-28     	; 0xa8b4 <vCoRoutineSchedule+0x156>
    a8d0:	90 93 1e 02 	sts	0x021E, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    a8d4:	11 96       	adiw	r26, 0x01	; 1
    a8d6:	ed 91       	ld	r30, X+
    a8d8:	fc 91       	ld	r31, X
    a8da:	12 97       	sbiw	r26, 0x02	; 2
    a8dc:	02 80       	ldd	r0, Z+2	; 0x02
    a8de:	f3 81       	ldd	r31, Z+3	; 0x03
    a8e0:	e0 2d       	mov	r30, r0
    a8e2:	12 96       	adiw	r26, 0x02	; 2
    a8e4:	fc 93       	st	X, r31
    a8e6:	ee 93       	st	-X, r30
    a8e8:	11 97       	sbiw	r26, 0x01	; 1
    a8ea:	cd 01       	movw	r24, r26
    a8ec:	03 96       	adiw	r24, 0x03	; 3
    a8ee:	e8 17       	cp	r30, r24
    a8f0:	f9 07       	cpc	r31, r25
    a8f2:	31 f4       	brne	.+12     	; 0xa900 <vCoRoutineSchedule+0x1a2>
    a8f4:	82 81       	ldd	r24, Z+2	; 0x02
    a8f6:	93 81       	ldd	r25, Z+3	; 0x03
    a8f8:	12 96       	adiw	r26, 0x02	; 2
    a8fa:	9c 93       	st	X, r25
    a8fc:	8e 93       	st	-X, r24
    a8fe:	11 97       	sbiw	r26, 0x01	; 1
    a900:	11 96       	adiw	r26, 0x01	; 1
    a902:	ed 91       	ld	r30, X+
    a904:	fc 91       	ld	r31, X
    a906:	12 97       	sbiw	r26, 0x02	; 2
    a908:	06 80       	ldd	r0, Z+6	; 0x06
    a90a:	f7 81       	ldd	r31, Z+7	; 0x07
    a90c:	e0 2d       	mov	r30, r0
    a90e:	f0 93 1d 02 	sts	0x021D, r31
    a912:	e0 93 1c 02 	sts	0x021C, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    a916:	20 81       	ld	r18, Z
    a918:	31 81       	ldd	r19, Z+1	; 0x01
    a91a:	cf 01       	movw	r24, r30
    a91c:	67 89       	ldd	r22, Z+23	; 0x17
    a91e:	f9 01       	movw	r30, r18
    a920:	09 95       	icall

	return;
}
    a922:	df 91       	pop	r29
    a924:	cf 91       	pop	r28
    a926:	1f 91       	pop	r17
    a928:	0f 91       	pop	r16
    a92a:	ff 90       	pop	r15
    a92c:	08 95       	ret

0000a92e <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    a92e:	0f 93       	push	r16
    a930:	1f 93       	push	r17
    a932:	cf 93       	push	r28
    a934:	df 93       	push	r29
    a936:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    a938:	00 91 23 02 	lds	r16, 0x0223
    a93c:	10 91 24 02 	lds	r17, 0x0224
    a940:	08 0f       	add	r16, r24
    a942:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a944:	80 91 1c 02 	lds	r24, 0x021C
    a948:	90 91 1d 02 	lds	r25, 0x021D
    a94c:	02 96       	adiw	r24, 0x02	; 2
    a94e:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    a952:	e0 91 1c 02 	lds	r30, 0x021C
    a956:	f0 91 1d 02 	lds	r31, 0x021D
    a95a:	13 83       	std	Z+3, r17	; 0x03
    a95c:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    a95e:	80 91 23 02 	lds	r24, 0x0223
    a962:	90 91 24 02 	lds	r25, 0x0224
    a966:	bf 01       	movw	r22, r30
    a968:	6e 5f       	subi	r22, 0xFE	; 254
    a96a:	7f 4f       	sbci	r23, 0xFF	; 255
    a96c:	08 17       	cp	r16, r24
    a96e:	19 07       	cpc	r17, r25
    a970:	28 f4       	brcc	.+10     	; 0xa97c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a972:	80 91 42 02 	lds	r24, 0x0242
    a976:	90 91 43 02 	lds	r25, 0x0243
    a97a:	04 c0       	rjmp	.+8      	; 0xa984 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a97c:	80 91 40 02 	lds	r24, 0x0240
    a980:	90 91 41 02 	lds	r25, 0x0241
    a984:	0e 94 27 53 	call	0xa64e	; 0xa64e <vListInsert>
	}

	if( pxEventList )
    a988:	20 97       	sbiw	r28, 0x00	; 0
    a98a:	49 f0       	breq	.+18     	; 0xa99e <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    a98c:	60 91 1c 02 	lds	r22, 0x021C
    a990:	70 91 1d 02 	lds	r23, 0x021D
    a994:	64 5f       	subi	r22, 0xF4	; 244
    a996:	7f 4f       	sbci	r23, 0xFF	; 255
    a998:	ce 01       	movw	r24, r28
    a99a:	0e 94 27 53 	call	0xa64e	; 0xa64e <vListInsert>
	}
}
    a99e:	df 91       	pop	r29
    a9a0:	cf 91       	pop	r28
    a9a2:	1f 91       	pop	r17
    a9a4:	0f 91       	pop	r16
    a9a6:	08 95       	ret

0000a9a8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    a9a8:	bf 92       	push	r11
    a9aa:	cf 92       	push	r12
    a9ac:	df 92       	push	r13
    a9ae:	ef 92       	push	r14
    a9b0:	ff 92       	push	r15
    a9b2:	0f 93       	push	r16
    a9b4:	1f 93       	push	r17
    a9b6:	cf 93       	push	r28
    a9b8:	df 93       	push	r29
    a9ba:	6c 01       	movw	r12, r24
    a9bc:	b4 2e       	mov	r11, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    a9be:	8a e1       	ldi	r24, 0x1A	; 26
    a9c0:	90 e0       	ldi	r25, 0x00	; 0
    a9c2:	0e 94 50 55 	call	0xaaa0	; 0xaaa0 <pvPortMalloc>
    a9c6:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    a9c8:	00 97       	sbiw	r24, 0x00	; 0
    a9ca:	11 f4       	brne	.+4      	; 0xa9d0 <xCoRoutineCreate+0x28>
    a9cc:	8f ef       	ldi	r24, 0xFF	; 255
    a9ce:	4e c0       	rjmp	.+156    	; 0xaa6c <xCoRoutineCreate+0xc4>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    a9d0:	80 91 1c 02 	lds	r24, 0x021C
    a9d4:	90 91 1d 02 	lds	r25, 0x021D
    a9d8:	89 2b       	or	r24, r25
    a9da:	01 f5       	brne	.+64     	; 0xaa1c <xCoRoutineCreate+0x74>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    a9dc:	d0 93 1d 02 	sts	0x021D, r29
    a9e0:	c0 93 1c 02 	sts	0x021C, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    a9e4:	85 e2       	ldi	r24, 0x25	; 37
    a9e6:	92 e0       	ldi	r25, 0x02	; 2
    a9e8:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    a9ec:	2e e2       	ldi	r18, 0x2E	; 46
    a9ee:	e2 2e       	mov	r14, r18
    a9f0:	22 e0       	ldi	r18, 0x02	; 2
    a9f2:	f2 2e       	mov	r15, r18
    a9f4:	c7 01       	movw	r24, r14
    a9f6:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    a9fa:	07 e3       	ldi	r16, 0x37	; 55
    a9fc:	12 e0       	ldi	r17, 0x02	; 2
    a9fe:	c8 01       	movw	r24, r16
    aa00:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    aa04:	84 e4       	ldi	r24, 0x44	; 68
    aa06:	92 e0       	ldi	r25, 0x02	; 2
    aa08:	0e 94 ea 52 	call	0xa5d4	; 0xa5d4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    aa0c:	f0 92 41 02 	sts	0x0241, r15
    aa10:	e0 92 40 02 	sts	0x0240, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    aa14:	10 93 43 02 	sts	0x0243, r17
    aa18:	00 93 42 02 	sts	0x0242, r16
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    aa1c:	19 8e       	std	Y+25, r1	; 0x19
    aa1e:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    aa20:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    aa22:	bf 8a       	std	Y+23, r11	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    aa24:	fe 01       	movw	r30, r28
    aa26:	c1 92       	st	Z+, r12
    aa28:	d1 92       	st	Z+, r13
    aa2a:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    aa2c:	cf 01       	movw	r24, r30
    aa2e:	0e 94 fa 52 	call	0xa5f4	; 0xa5f4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    aa32:	ce 01       	movw	r24, r28
    aa34:	0c 96       	adiw	r24, 0x0c	; 12
    aa36:	0e 94 fa 52 	call	0xa5f4	; 0xa5f4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    aa3a:	d9 87       	std	Y+9, r29	; 0x09
    aa3c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    aa3e:	db 8b       	std	Y+19, r29	; 0x13
    aa40:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    aa42:	83 e0       	ldi	r24, 0x03	; 3
    aa44:	90 e0       	ldi	r25, 0x00	; 0
    aa46:	9d 87       	std	Y+13, r25	; 0x0d
    aa48:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    aa4a:	9e 89       	ldd	r25, Y+22	; 0x16
    aa4c:	80 91 1e 02 	lds	r24, 0x021E
    aa50:	89 17       	cp	r24, r25
    aa52:	10 f4       	brcc	.+4      	; 0xaa58 <xCoRoutineCreate+0xb0>
    aa54:	90 93 1e 02 	sts	0x021E, r25
    aa58:	89 e0       	ldi	r24, 0x09	; 9
    aa5a:	98 9f       	mul	r25, r24
    aa5c:	c0 01       	movw	r24, r0
    aa5e:	11 24       	eor	r1, r1
    aa60:	8b 5d       	subi	r24, 0xDB	; 219
    aa62:	9d 4f       	sbci	r25, 0xFD	; 253
    aa64:	b8 01       	movw	r22, r16
    aa66:	0e 94 fe 52 	call	0xa5fc	; 0xa5fc <vListInsertEnd>
    aa6a:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    aa6c:	df 91       	pop	r29
    aa6e:	cf 91       	pop	r28
    aa70:	1f 91       	pop	r17
    aa72:	0f 91       	pop	r16
    aa74:	ff 90       	pop	r15
    aa76:	ef 90       	pop	r14
    aa78:	df 90       	pop	r13
    aa7a:	cf 90       	pop	r12
    aa7c:	bf 90       	pop	r11
    aa7e:	08 95       	ret

0000aa80 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    aa80:	08 95       	ret

0000aa82 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    aa82:	10 92 4e 02 	sts	0x024E, r1
    aa86:	10 92 4d 02 	sts	0x024D, r1
}
    aa8a:	08 95       	ret

0000aa8c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    aa8c:	2c e1       	ldi	r18, 0x1C	; 28
    aa8e:	3c e0       	ldi	r19, 0x0C	; 12
    aa90:	80 91 4d 02 	lds	r24, 0x024D
    aa94:	90 91 4e 02 	lds	r25, 0x024E
    aa98:	28 1b       	sub	r18, r24
    aa9a:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    aa9c:	c9 01       	movw	r24, r18
    aa9e:	08 95       	ret

0000aaa0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    aaa0:	0f 93       	push	r16
    aaa2:	1f 93       	push	r17
    aaa4:	cf 93       	push	r28
    aaa6:	df 93       	push	r29
    aaa8:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    aaaa:	0e 94 e1 48 	call	0x91c2	; 0x91c2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    aaae:	80 91 4d 02 	lds	r24, 0x024D
    aab2:	90 91 4e 02 	lds	r25, 0x024E
    aab6:	98 01       	movw	r18, r16
    aab8:	28 0f       	add	r18, r24
    aaba:	39 1f       	adc	r19, r25
    aabc:	4c e0       	ldi	r20, 0x0C	; 12
    aabe:	2c 31       	cpi	r18, 0x1C	; 28
    aac0:	34 07       	cpc	r19, r20
    aac2:	58 f4       	brcc	.+22     	; 0xaada <pvPortMalloc+0x3a>
    aac4:	82 17       	cp	r24, r18
    aac6:	93 07       	cpc	r25, r19
    aac8:	40 f4       	brcc	.+16     	; 0xaada <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    aaca:	ec 01       	movw	r28, r24
    aacc:	c1 5b       	subi	r28, 0xB1	; 177
    aace:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    aad0:	30 93 4e 02 	sts	0x024E, r19
    aad4:	20 93 4d 02 	sts	0x024D, r18
    aad8:	02 c0       	rjmp	.+4      	; 0xaade <pvPortMalloc+0x3e>
    aada:	c0 e0       	ldi	r28, 0x00	; 0
    aadc:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    aade:	0e 94 06 4c 	call	0x980c	; 0x980c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    aae2:	ce 01       	movw	r24, r28
    aae4:	df 91       	pop	r29
    aae6:	cf 91       	pop	r28
    aae8:	1f 91       	pop	r17
    aaea:	0f 91       	pop	r16
    aaec:	08 95       	ret

0000aaee <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    aaee:	fc 01       	movw	r30, r24
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    aaf0:	91 e1       	ldi	r25, 0x11	; 17
    aaf2:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    aaf4:	22 e2       	ldi	r18, 0x22	; 34
    aaf6:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    aaf8:	83 e3       	ldi	r24, 0x33	; 51
    aafa:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    aafc:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    aafe:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    ab00:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    ab02:	80 e8       	ldi	r24, 0x80	; 128
    ab04:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    ab06:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    ab08:	82 e0       	ldi	r24, 0x02	; 2
    ab0a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    ab0c:	83 e0       	ldi	r24, 0x03	; 3
    ab0e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    ab10:	84 e0       	ldi	r24, 0x04	; 4
    ab12:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    ab14:	85 e0       	ldi	r24, 0x05	; 5
    ab16:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    ab18:	86 e0       	ldi	r24, 0x06	; 6
    ab1a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    ab1c:	87 e0       	ldi	r24, 0x07	; 7
    ab1e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    ab20:	88 e0       	ldi	r24, 0x08	; 8
    ab22:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    ab24:	89 e0       	ldi	r24, 0x09	; 9
    ab26:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    ab28:	80 e1       	ldi	r24, 0x10	; 16
    ab2a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    ab2c:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    ab2e:	82 e1       	ldi	r24, 0x12	; 18
    ab30:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    ab32:	83 e1       	ldi	r24, 0x13	; 19
    ab34:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    ab36:	84 e1       	ldi	r24, 0x14	; 20
    ab38:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    ab3a:	85 e1       	ldi	r24, 0x15	; 21
    ab3c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    ab3e:	86 e1       	ldi	r24, 0x16	; 22
    ab40:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    ab42:	87 e1       	ldi	r24, 0x17	; 23
    ab44:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    ab46:	88 e1       	ldi	r24, 0x18	; 24
    ab48:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    ab4a:	89 e1       	ldi	r24, 0x19	; 25
    ab4c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    ab4e:	80 e2       	ldi	r24, 0x20	; 32
    ab50:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    ab52:	81 e2       	ldi	r24, 0x21	; 33
    ab54:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    ab56:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    ab58:	83 e2       	ldi	r24, 0x23	; 35
    ab5a:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    ab5c:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    ab5e:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    ab60:	86 e2       	ldi	r24, 0x26	; 38
    ab62:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    ab64:	87 e2       	ldi	r24, 0x27	; 39
    ab66:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    ab68:	88 e2       	ldi	r24, 0x28	; 40
    ab6a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    ab6c:	89 e2       	ldi	r24, 0x29	; 41
    ab6e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    ab70:	80 e3       	ldi	r24, 0x30	; 48
    ab72:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    ab74:	81 e3       	ldi	r24, 0x31	; 49
    ab76:	82 93       	st	-Z, r24
    ab78:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    ab7a:	cf 01       	movw	r24, r30
    ab7c:	08 95       	ret

0000ab7e <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	OCR1AH = ucHighByte;
    ab7e:	88 e0       	ldi	r24, 0x08	; 8
    ab80:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
    ab82:	8f ef       	ldi	r24, 0xFF	; 255
    ab84:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    ab86:	8b e0       	ldi	r24, 0x0B	; 11
    ab88:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    ab8a:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    ab8c:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    ab8e:	87 bf       	out	0x37, r24	; 55
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    ab90:	a0 91 93 01 	lds	r26, 0x0193
    ab94:	b0 91 94 01 	lds	r27, 0x0194
    ab98:	cd 91       	ld	r28, X+
    ab9a:	cd bf       	out	0x3d, r28	; 61
    ab9c:	dd 91       	ld	r29, X+
    ab9e:	de bf       	out	0x3e, r29	; 62
    aba0:	ff 91       	pop	r31
    aba2:	ef 91       	pop	r30
    aba4:	df 91       	pop	r29
    aba6:	cf 91       	pop	r28
    aba8:	bf 91       	pop	r27
    abaa:	af 91       	pop	r26
    abac:	9f 91       	pop	r25
    abae:	8f 91       	pop	r24
    abb0:	7f 91       	pop	r23
    abb2:	6f 91       	pop	r22
    abb4:	5f 91       	pop	r21
    abb6:	4f 91       	pop	r20
    abb8:	3f 91       	pop	r19
    abba:	2f 91       	pop	r18
    abbc:	1f 91       	pop	r17
    abbe:	0f 91       	pop	r16
    abc0:	ff 90       	pop	r15
    abc2:	ef 90       	pop	r14
    abc4:	df 90       	pop	r13
    abc6:	cf 90       	pop	r12
    abc8:	bf 90       	pop	r11
    abca:	af 90       	pop	r10
    abcc:	9f 90       	pop	r9
    abce:	8f 90       	pop	r8
    abd0:	7f 90       	pop	r7
    abd2:	6f 90       	pop	r6
    abd4:	5f 90       	pop	r5
    abd6:	4f 90       	pop	r4
    abd8:	3f 90       	pop	r3
    abda:	2f 90       	pop	r2
    abdc:	1f 90       	pop	r1
    abde:	0f 90       	pop	r0
    abe0:	0f be       	out	0x3f, r0	; 63
    abe2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    abe4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    abe6:	81 e0       	ldi	r24, 0x01	; 1
    abe8:	08 95       	ret

0000abea <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    abea:	08 95       	ret

0000abec <__vector_12>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    abec:	1f 92       	push	r1
    abee:	0f 92       	push	r0
    abf0:	0f b6       	in	r0, 0x3f	; 63
    abf2:	0f 92       	push	r0
    abf4:	0b b6       	in	r0, 0x3b	; 59
    abf6:	0f 92       	push	r0
    abf8:	11 24       	eor	r1, r1
    abfa:	2f 93       	push	r18
    abfc:	3f 93       	push	r19
    abfe:	4f 93       	push	r20
    ac00:	5f 93       	push	r21
    ac02:	6f 93       	push	r22
    ac04:	7f 93       	push	r23
    ac06:	8f 93       	push	r24
    ac08:	9f 93       	push	r25
    ac0a:	af 93       	push	r26
    ac0c:	bf 93       	push	r27
    ac0e:	ef 93       	push	r30
    ac10:	ff 93       	push	r31
		vTaskIncrementTick();
    ac12:	0e 94 de 4a 	call	0x95bc	; 0x95bc <vTaskIncrementTick>
	}
    ac16:	ff 91       	pop	r31
    ac18:	ef 91       	pop	r30
    ac1a:	bf 91       	pop	r27
    ac1c:	af 91       	pop	r26
    ac1e:	9f 91       	pop	r25
    ac20:	8f 91       	pop	r24
    ac22:	7f 91       	pop	r23
    ac24:	6f 91       	pop	r22
    ac26:	5f 91       	pop	r21
    ac28:	4f 91       	pop	r20
    ac2a:	3f 91       	pop	r19
    ac2c:	2f 91       	pop	r18
    ac2e:	0f 90       	pop	r0
    ac30:	0b be       	out	0x3b, r0	; 59
    ac32:	0f 90       	pop	r0
    ac34:	0f be       	out	0x3f, r0	; 63
    ac36:	0f 90       	pop	r0
    ac38:	1f 90       	pop	r1
    ac3a:	18 95       	reti

0000ac3c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    ac3c:	0f 92       	push	r0
    ac3e:	0f b6       	in	r0, 0x3f	; 63
    ac40:	f8 94       	cli
    ac42:	0f 92       	push	r0
    ac44:	1f 92       	push	r1
    ac46:	11 24       	eor	r1, r1
    ac48:	2f 92       	push	r2
    ac4a:	3f 92       	push	r3
    ac4c:	4f 92       	push	r4
    ac4e:	5f 92       	push	r5
    ac50:	6f 92       	push	r6
    ac52:	7f 92       	push	r7
    ac54:	8f 92       	push	r8
    ac56:	9f 92       	push	r9
    ac58:	af 92       	push	r10
    ac5a:	bf 92       	push	r11
    ac5c:	cf 92       	push	r12
    ac5e:	df 92       	push	r13
    ac60:	ef 92       	push	r14
    ac62:	ff 92       	push	r15
    ac64:	0f 93       	push	r16
    ac66:	1f 93       	push	r17
    ac68:	2f 93       	push	r18
    ac6a:	3f 93       	push	r19
    ac6c:	4f 93       	push	r20
    ac6e:	5f 93       	push	r21
    ac70:	6f 93       	push	r22
    ac72:	7f 93       	push	r23
    ac74:	8f 93       	push	r24
    ac76:	9f 93       	push	r25
    ac78:	af 93       	push	r26
    ac7a:	bf 93       	push	r27
    ac7c:	cf 93       	push	r28
    ac7e:	df 93       	push	r29
    ac80:	ef 93       	push	r30
    ac82:	ff 93       	push	r31
    ac84:	a0 91 93 01 	lds	r26, 0x0193
    ac88:	b0 91 94 01 	lds	r27, 0x0194
    ac8c:	0d b6       	in	r0, 0x3d	; 61
    ac8e:	0d 92       	st	X+, r0
    ac90:	0e b6       	in	r0, 0x3e	; 62
    ac92:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    ac94:	0e 94 de 4a 	call	0x95bc	; 0x95bc <vTaskIncrementTick>
	vTaskSwitchContext();
    ac98:	0e 94 26 49 	call	0x924c	; 0x924c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    ac9c:	a0 91 93 01 	lds	r26, 0x0193
    aca0:	b0 91 94 01 	lds	r27, 0x0194
    aca4:	cd 91       	ld	r28, X+
    aca6:	cd bf       	out	0x3d, r28	; 61
    aca8:	dd 91       	ld	r29, X+
    acaa:	de bf       	out	0x3e, r29	; 62
    acac:	ff 91       	pop	r31
    acae:	ef 91       	pop	r30
    acb0:	df 91       	pop	r29
    acb2:	cf 91       	pop	r28
    acb4:	bf 91       	pop	r27
    acb6:	af 91       	pop	r26
    acb8:	9f 91       	pop	r25
    acba:	8f 91       	pop	r24
    acbc:	7f 91       	pop	r23
    acbe:	6f 91       	pop	r22
    acc0:	5f 91       	pop	r21
    acc2:	4f 91       	pop	r20
    acc4:	3f 91       	pop	r19
    acc6:	2f 91       	pop	r18
    acc8:	1f 91       	pop	r17
    acca:	0f 91       	pop	r16
    accc:	ff 90       	pop	r15
    acce:	ef 90       	pop	r14
    acd0:	df 90       	pop	r13
    acd2:	cf 90       	pop	r12
    acd4:	bf 90       	pop	r11
    acd6:	af 90       	pop	r10
    acd8:	9f 90       	pop	r9
    acda:	8f 90       	pop	r8
    acdc:	7f 90       	pop	r7
    acde:	6f 90       	pop	r6
    ace0:	5f 90       	pop	r5
    ace2:	4f 90       	pop	r4
    ace4:	3f 90       	pop	r3
    ace6:	2f 90       	pop	r2
    ace8:	1f 90       	pop	r1
    acea:	0f 90       	pop	r0
    acec:	0f be       	out	0x3f, r0	; 63
    acee:	0f 90       	pop	r0

	asm volatile ( "ret" );
    acf0:	08 95       	ret

0000acf2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    acf2:	0f 92       	push	r0
    acf4:	0f b6       	in	r0, 0x3f	; 63
    acf6:	f8 94       	cli
    acf8:	0f 92       	push	r0
    acfa:	1f 92       	push	r1
    acfc:	11 24       	eor	r1, r1
    acfe:	2f 92       	push	r2
    ad00:	3f 92       	push	r3
    ad02:	4f 92       	push	r4
    ad04:	5f 92       	push	r5
    ad06:	6f 92       	push	r6
    ad08:	7f 92       	push	r7
    ad0a:	8f 92       	push	r8
    ad0c:	9f 92       	push	r9
    ad0e:	af 92       	push	r10
    ad10:	bf 92       	push	r11
    ad12:	cf 92       	push	r12
    ad14:	df 92       	push	r13
    ad16:	ef 92       	push	r14
    ad18:	ff 92       	push	r15
    ad1a:	0f 93       	push	r16
    ad1c:	1f 93       	push	r17
    ad1e:	2f 93       	push	r18
    ad20:	3f 93       	push	r19
    ad22:	4f 93       	push	r20
    ad24:	5f 93       	push	r21
    ad26:	6f 93       	push	r22
    ad28:	7f 93       	push	r23
    ad2a:	8f 93       	push	r24
    ad2c:	9f 93       	push	r25
    ad2e:	af 93       	push	r26
    ad30:	bf 93       	push	r27
    ad32:	cf 93       	push	r28
    ad34:	df 93       	push	r29
    ad36:	ef 93       	push	r30
    ad38:	ff 93       	push	r31
    ad3a:	a0 91 93 01 	lds	r26, 0x0193
    ad3e:	b0 91 94 01 	lds	r27, 0x0194
    ad42:	0d b6       	in	r0, 0x3d	; 61
    ad44:	0d 92       	st	X+, r0
    ad46:	0e b6       	in	r0, 0x3e	; 62
    ad48:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    ad4a:	0e 94 26 49 	call	0x924c	; 0x924c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    ad4e:	a0 91 93 01 	lds	r26, 0x0193
    ad52:	b0 91 94 01 	lds	r27, 0x0194
    ad56:	cd 91       	ld	r28, X+
    ad58:	cd bf       	out	0x3d, r28	; 61
    ad5a:	dd 91       	ld	r29, X+
    ad5c:	de bf       	out	0x3e, r29	; 62
    ad5e:	ff 91       	pop	r31
    ad60:	ef 91       	pop	r30
    ad62:	df 91       	pop	r29
    ad64:	cf 91       	pop	r28
    ad66:	bf 91       	pop	r27
    ad68:	af 91       	pop	r26
    ad6a:	9f 91       	pop	r25
    ad6c:	8f 91       	pop	r24
    ad6e:	7f 91       	pop	r23
    ad70:	6f 91       	pop	r22
    ad72:	5f 91       	pop	r21
    ad74:	4f 91       	pop	r20
    ad76:	3f 91       	pop	r19
    ad78:	2f 91       	pop	r18
    ad7a:	1f 91       	pop	r17
    ad7c:	0f 91       	pop	r16
    ad7e:	ff 90       	pop	r15
    ad80:	ef 90       	pop	r14
    ad82:	df 90       	pop	r13
    ad84:	cf 90       	pop	r12
    ad86:	bf 90       	pop	r11
    ad88:	af 90       	pop	r10
    ad8a:	9f 90       	pop	r9
    ad8c:	8f 90       	pop	r8
    ad8e:	7f 90       	pop	r7
    ad90:	6f 90       	pop	r6
    ad92:	5f 90       	pop	r5
    ad94:	4f 90       	pop	r4
    ad96:	3f 90       	pop	r3
    ad98:	2f 90       	pop	r2
    ad9a:	1f 90       	pop	r1
    ad9c:	0f 90       	pop	r0
    ad9e:	0f be       	out	0x3f, r0	; 63
    ada0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    ada2:	08 95       	ret

0000ada4 <__udivmodqi4>:
    ada4:	99 1b       	sub	r25, r25
    ada6:	79 e0       	ldi	r23, 0x09	; 9
    ada8:	04 c0       	rjmp	.+8      	; 0xadb2 <__udivmodqi4_ep>

0000adaa <__udivmodqi4_loop>:
    adaa:	99 1f       	adc	r25, r25
    adac:	96 17       	cp	r25, r22
    adae:	08 f0       	brcs	.+2      	; 0xadb2 <__udivmodqi4_ep>
    adb0:	96 1b       	sub	r25, r22

0000adb2 <__udivmodqi4_ep>:
    adb2:	88 1f       	adc	r24, r24
    adb4:	7a 95       	dec	r23
    adb6:	c9 f7       	brne	.-14     	; 0xadaa <__udivmodqi4_loop>
    adb8:	80 95       	com	r24
    adba:	08 95       	ret

0000adbc <__udivmodhi4>:
    adbc:	aa 1b       	sub	r26, r26
    adbe:	bb 1b       	sub	r27, r27
    adc0:	51 e1       	ldi	r21, 0x11	; 17
    adc2:	07 c0       	rjmp	.+14     	; 0xadd2 <__udivmodhi4_ep>

0000adc4 <__udivmodhi4_loop>:
    adc4:	aa 1f       	adc	r26, r26
    adc6:	bb 1f       	adc	r27, r27
    adc8:	a6 17       	cp	r26, r22
    adca:	b7 07       	cpc	r27, r23
    adcc:	10 f0       	brcs	.+4      	; 0xadd2 <__udivmodhi4_ep>
    adce:	a6 1b       	sub	r26, r22
    add0:	b7 0b       	sbc	r27, r23

0000add2 <__udivmodhi4_ep>:
    add2:	88 1f       	adc	r24, r24
    add4:	99 1f       	adc	r25, r25
    add6:	5a 95       	dec	r21
    add8:	a9 f7       	brne	.-22     	; 0xadc4 <__udivmodhi4_loop>
    adda:	80 95       	com	r24
    addc:	90 95       	com	r25
    adde:	bc 01       	movw	r22, r24
    ade0:	cd 01       	movw	r24, r26
    ade2:	08 95       	ret

0000ade4 <malloc>:
    ade4:	cf 93       	push	r28
    ade6:	df 93       	push	r29
    ade8:	bc 01       	movw	r22, r24
    adea:	82 30       	cpi	r24, 0x02	; 2
    adec:	91 05       	cpc	r25, r1
    adee:	10 f4       	brcc	.+4      	; 0xadf4 <malloc+0x10>
    adf0:	62 e0       	ldi	r22, 0x02	; 2
    adf2:	70 e0       	ldi	r23, 0x00	; 0
    adf4:	a0 91 da 0f 	lds	r26, 0x0FDA
    adf8:	b0 91 db 0f 	lds	r27, 0x0FDB
    adfc:	ed 01       	movw	r28, r26
    adfe:	e0 e0       	ldi	r30, 0x00	; 0
    ae00:	f0 e0       	ldi	r31, 0x00	; 0
    ae02:	40 e0       	ldi	r20, 0x00	; 0
    ae04:	50 e0       	ldi	r21, 0x00	; 0
    ae06:	21 c0       	rjmp	.+66     	; 0xae4a <malloc+0x66>
    ae08:	88 81       	ld	r24, Y
    ae0a:	99 81       	ldd	r25, Y+1	; 0x01
    ae0c:	86 17       	cp	r24, r22
    ae0e:	97 07       	cpc	r25, r23
    ae10:	69 f4       	brne	.+26     	; 0xae2c <malloc+0x48>
    ae12:	8a 81       	ldd	r24, Y+2	; 0x02
    ae14:	9b 81       	ldd	r25, Y+3	; 0x03
    ae16:	30 97       	sbiw	r30, 0x00	; 0
    ae18:	19 f0       	breq	.+6      	; 0xae20 <malloc+0x3c>
    ae1a:	93 83       	std	Z+3, r25	; 0x03
    ae1c:	82 83       	std	Z+2, r24	; 0x02
    ae1e:	04 c0       	rjmp	.+8      	; 0xae28 <malloc+0x44>
    ae20:	90 93 db 0f 	sts	0x0FDB, r25
    ae24:	80 93 da 0f 	sts	0x0FDA, r24
    ae28:	fe 01       	movw	r30, r28
    ae2a:	34 c0       	rjmp	.+104    	; 0xae94 <malloc+0xb0>
    ae2c:	68 17       	cp	r22, r24
    ae2e:	79 07       	cpc	r23, r25
    ae30:	38 f4       	brcc	.+14     	; 0xae40 <malloc+0x5c>
    ae32:	41 15       	cp	r20, r1
    ae34:	51 05       	cpc	r21, r1
    ae36:	19 f0       	breq	.+6      	; 0xae3e <malloc+0x5a>
    ae38:	84 17       	cp	r24, r20
    ae3a:	95 07       	cpc	r25, r21
    ae3c:	08 f4       	brcc	.+2      	; 0xae40 <malloc+0x5c>
    ae3e:	ac 01       	movw	r20, r24
    ae40:	fe 01       	movw	r30, r28
    ae42:	8a 81       	ldd	r24, Y+2	; 0x02
    ae44:	9b 81       	ldd	r25, Y+3	; 0x03
    ae46:	9c 01       	movw	r18, r24
    ae48:	e9 01       	movw	r28, r18
    ae4a:	20 97       	sbiw	r28, 0x00	; 0
    ae4c:	e9 f6       	brne	.-70     	; 0xae08 <malloc+0x24>
    ae4e:	41 15       	cp	r20, r1
    ae50:	51 05       	cpc	r21, r1
    ae52:	a9 f1       	breq	.+106    	; 0xaebe <malloc+0xda>
    ae54:	ca 01       	movw	r24, r20
    ae56:	86 1b       	sub	r24, r22
    ae58:	97 0b       	sbc	r25, r23
    ae5a:	04 97       	sbiw	r24, 0x04	; 4
    ae5c:	08 f4       	brcc	.+2      	; 0xae60 <malloc+0x7c>
    ae5e:	ba 01       	movw	r22, r20
    ae60:	e0 e0       	ldi	r30, 0x00	; 0
    ae62:	f0 e0       	ldi	r31, 0x00	; 0
    ae64:	2a c0       	rjmp	.+84     	; 0xaeba <malloc+0xd6>
    ae66:	8d 91       	ld	r24, X+
    ae68:	9c 91       	ld	r25, X
    ae6a:	11 97       	sbiw	r26, 0x01	; 1
    ae6c:	84 17       	cp	r24, r20
    ae6e:	95 07       	cpc	r25, r21
    ae70:	f9 f4       	brne	.+62     	; 0xaeb0 <malloc+0xcc>
    ae72:	64 17       	cp	r22, r20
    ae74:	75 07       	cpc	r23, r21
    ae76:	81 f4       	brne	.+32     	; 0xae98 <malloc+0xb4>
    ae78:	12 96       	adiw	r26, 0x02	; 2
    ae7a:	8d 91       	ld	r24, X+
    ae7c:	9c 91       	ld	r25, X
    ae7e:	13 97       	sbiw	r26, 0x03	; 3
    ae80:	30 97       	sbiw	r30, 0x00	; 0
    ae82:	19 f0       	breq	.+6      	; 0xae8a <malloc+0xa6>
    ae84:	93 83       	std	Z+3, r25	; 0x03
    ae86:	82 83       	std	Z+2, r24	; 0x02
    ae88:	04 c0       	rjmp	.+8      	; 0xae92 <malloc+0xae>
    ae8a:	90 93 db 0f 	sts	0x0FDB, r25
    ae8e:	80 93 da 0f 	sts	0x0FDA, r24
    ae92:	fd 01       	movw	r30, r26
    ae94:	32 96       	adiw	r30, 0x02	; 2
    ae96:	4f c0       	rjmp	.+158    	; 0xaf36 <malloc+0x152>
    ae98:	ca 01       	movw	r24, r20
    ae9a:	86 1b       	sub	r24, r22
    ae9c:	97 0b       	sbc	r25, r23
    ae9e:	fd 01       	movw	r30, r26
    aea0:	e8 0f       	add	r30, r24
    aea2:	f9 1f       	adc	r31, r25
    aea4:	61 93       	st	Z+, r22
    aea6:	71 93       	st	Z+, r23
    aea8:	02 97       	sbiw	r24, 0x02	; 2
    aeaa:	8d 93       	st	X+, r24
    aeac:	9c 93       	st	X, r25
    aeae:	43 c0       	rjmp	.+134    	; 0xaf36 <malloc+0x152>
    aeb0:	fd 01       	movw	r30, r26
    aeb2:	82 81       	ldd	r24, Z+2	; 0x02
    aeb4:	93 81       	ldd	r25, Z+3	; 0x03
    aeb6:	9c 01       	movw	r18, r24
    aeb8:	d9 01       	movw	r26, r18
    aeba:	10 97       	sbiw	r26, 0x00	; 0
    aebc:	a1 f6       	brne	.-88     	; 0xae66 <malloc+0x82>
    aebe:	80 91 d8 0f 	lds	r24, 0x0FD8
    aec2:	90 91 d9 0f 	lds	r25, 0x0FD9
    aec6:	89 2b       	or	r24, r25
    aec8:	41 f4       	brne	.+16     	; 0xaeda <malloc+0xf6>
    aeca:	80 91 84 01 	lds	r24, 0x0184
    aece:	90 91 85 01 	lds	r25, 0x0185
    aed2:	90 93 d9 0f 	sts	0x0FD9, r25
    aed6:	80 93 d8 0f 	sts	0x0FD8, r24
    aeda:	40 91 86 01 	lds	r20, 0x0186
    aede:	50 91 87 01 	lds	r21, 0x0187
    aee2:	41 15       	cp	r20, r1
    aee4:	51 05       	cpc	r21, r1
    aee6:	41 f4       	brne	.+16     	; 0xaef8 <malloc+0x114>
    aee8:	4d b7       	in	r20, 0x3d	; 61
    aeea:	5e b7       	in	r21, 0x3e	; 62
    aeec:	80 91 82 01 	lds	r24, 0x0182
    aef0:	90 91 83 01 	lds	r25, 0x0183
    aef4:	48 1b       	sub	r20, r24
    aef6:	59 0b       	sbc	r21, r25
    aef8:	20 91 d8 0f 	lds	r18, 0x0FD8
    aefc:	30 91 d9 0f 	lds	r19, 0x0FD9
    af00:	24 17       	cp	r18, r20
    af02:	35 07       	cpc	r19, r21
    af04:	b0 f4       	brcc	.+44     	; 0xaf32 <malloc+0x14e>
    af06:	ca 01       	movw	r24, r20
    af08:	82 1b       	sub	r24, r18
    af0a:	93 0b       	sbc	r25, r19
    af0c:	86 17       	cp	r24, r22
    af0e:	97 07       	cpc	r25, r23
    af10:	80 f0       	brcs	.+32     	; 0xaf32 <malloc+0x14e>
    af12:	ab 01       	movw	r20, r22
    af14:	4e 5f       	subi	r20, 0xFE	; 254
    af16:	5f 4f       	sbci	r21, 0xFF	; 255
    af18:	84 17       	cp	r24, r20
    af1a:	95 07       	cpc	r25, r21
    af1c:	50 f0       	brcs	.+20     	; 0xaf32 <malloc+0x14e>
    af1e:	42 0f       	add	r20, r18
    af20:	53 1f       	adc	r21, r19
    af22:	50 93 d9 0f 	sts	0x0FD9, r21
    af26:	40 93 d8 0f 	sts	0x0FD8, r20
    af2a:	f9 01       	movw	r30, r18
    af2c:	61 93       	st	Z+, r22
    af2e:	71 93       	st	Z+, r23
    af30:	02 c0       	rjmp	.+4      	; 0xaf36 <malloc+0x152>
    af32:	e0 e0       	ldi	r30, 0x00	; 0
    af34:	f0 e0       	ldi	r31, 0x00	; 0
    af36:	cf 01       	movw	r24, r30
    af38:	df 91       	pop	r29
    af3a:	cf 91       	pop	r28
    af3c:	08 95       	ret

0000af3e <free>:
    af3e:	cf 93       	push	r28
    af40:	df 93       	push	r29
    af42:	00 97       	sbiw	r24, 0x00	; 0
    af44:	09 f4       	brne	.+2      	; 0xaf48 <free+0xa>
    af46:	50 c0       	rjmp	.+160    	; 0xafe8 <free+0xaa>
    af48:	ec 01       	movw	r28, r24
    af4a:	22 97       	sbiw	r28, 0x02	; 2
    af4c:	1b 82       	std	Y+3, r1	; 0x03
    af4e:	1a 82       	std	Y+2, r1	; 0x02
    af50:	a0 91 da 0f 	lds	r26, 0x0FDA
    af54:	b0 91 db 0f 	lds	r27, 0x0FDB
    af58:	10 97       	sbiw	r26, 0x00	; 0
    af5a:	09 f1       	breq	.+66     	; 0xaf9e <free+0x60>
    af5c:	40 e0       	ldi	r20, 0x00	; 0
    af5e:	50 e0       	ldi	r21, 0x00	; 0
    af60:	ac 17       	cp	r26, r28
    af62:	bd 07       	cpc	r27, r29
    af64:	08 f1       	brcs	.+66     	; 0xafa8 <free+0x6a>
    af66:	bb 83       	std	Y+3, r27	; 0x03
    af68:	aa 83       	std	Y+2, r26	; 0x02
    af6a:	fe 01       	movw	r30, r28
    af6c:	21 91       	ld	r18, Z+
    af6e:	31 91       	ld	r19, Z+
    af70:	e2 0f       	add	r30, r18
    af72:	f3 1f       	adc	r31, r19
    af74:	ae 17       	cp	r26, r30
    af76:	bf 07       	cpc	r27, r31
    af78:	79 f4       	brne	.+30     	; 0xaf98 <free+0x5a>
    af7a:	8d 91       	ld	r24, X+
    af7c:	9c 91       	ld	r25, X
    af7e:	11 97       	sbiw	r26, 0x01	; 1
    af80:	28 0f       	add	r18, r24
    af82:	39 1f       	adc	r19, r25
    af84:	2e 5f       	subi	r18, 0xFE	; 254
    af86:	3f 4f       	sbci	r19, 0xFF	; 255
    af88:	39 83       	std	Y+1, r19	; 0x01
    af8a:	28 83       	st	Y, r18
    af8c:	12 96       	adiw	r26, 0x02	; 2
    af8e:	8d 91       	ld	r24, X+
    af90:	9c 91       	ld	r25, X
    af92:	13 97       	sbiw	r26, 0x03	; 3
    af94:	9b 83       	std	Y+3, r25	; 0x03
    af96:	8a 83       	std	Y+2, r24	; 0x02
    af98:	41 15       	cp	r20, r1
    af9a:	51 05       	cpc	r21, r1
    af9c:	71 f4       	brne	.+28     	; 0xafba <free+0x7c>
    af9e:	d0 93 db 0f 	sts	0x0FDB, r29
    afa2:	c0 93 da 0f 	sts	0x0FDA, r28
    afa6:	20 c0       	rjmp	.+64     	; 0xafe8 <free+0xaa>
    afa8:	12 96       	adiw	r26, 0x02	; 2
    afaa:	8d 91       	ld	r24, X+
    afac:	9c 91       	ld	r25, X
    afae:	13 97       	sbiw	r26, 0x03	; 3
    afb0:	ad 01       	movw	r20, r26
    afb2:	00 97       	sbiw	r24, 0x00	; 0
    afb4:	11 f0       	breq	.+4      	; 0xafba <free+0x7c>
    afb6:	dc 01       	movw	r26, r24
    afb8:	d3 cf       	rjmp	.-90     	; 0xaf60 <free+0x22>
    afba:	fa 01       	movw	r30, r20
    afbc:	d3 83       	std	Z+3, r29	; 0x03
    afbe:	c2 83       	std	Z+2, r28	; 0x02
    afc0:	21 91       	ld	r18, Z+
    afc2:	31 91       	ld	r19, Z+
    afc4:	e2 0f       	add	r30, r18
    afc6:	f3 1f       	adc	r31, r19
    afc8:	ce 17       	cp	r28, r30
    afca:	df 07       	cpc	r29, r31
    afcc:	69 f4       	brne	.+26     	; 0xafe8 <free+0xaa>
    afce:	88 81       	ld	r24, Y
    afd0:	99 81       	ldd	r25, Y+1	; 0x01
    afd2:	28 0f       	add	r18, r24
    afd4:	39 1f       	adc	r19, r25
    afd6:	2e 5f       	subi	r18, 0xFE	; 254
    afd8:	3f 4f       	sbci	r19, 0xFF	; 255
    afda:	fa 01       	movw	r30, r20
    afdc:	31 83       	std	Z+1, r19	; 0x01
    afde:	20 83       	st	Z, r18
    afe0:	8a 81       	ldd	r24, Y+2	; 0x02
    afe2:	9b 81       	ldd	r25, Y+3	; 0x03
    afe4:	93 83       	std	Z+3, r25	; 0x03
    afe6:	82 83       	std	Z+2, r24	; 0x02
    afe8:	df 91       	pop	r29
    afea:	cf 91       	pop	r28
    afec:	08 95       	ret

0000afee <strtol>:
    afee:	2f 92       	push	r2
    aff0:	3f 92       	push	r3
    aff2:	5f 92       	push	r5
    aff4:	6f 92       	push	r6
    aff6:	7f 92       	push	r7
    aff8:	8f 92       	push	r8
    affa:	9f 92       	push	r9
    affc:	af 92       	push	r10
    affe:	bf 92       	push	r11
    b000:	cf 92       	push	r12
    b002:	df 92       	push	r13
    b004:	ef 92       	push	r14
    b006:	ff 92       	push	r15
    b008:	0f 93       	push	r16
    b00a:	1f 93       	push	r17
    b00c:	cf 93       	push	r28
    b00e:	df 93       	push	r29
    b010:	8c 01       	movw	r16, r24
    b012:	1b 01       	movw	r2, r22
    b014:	ea 01       	movw	r28, r20
    b016:	61 15       	cp	r22, r1
    b018:	71 05       	cpc	r23, r1
    b01a:	19 f0       	breq	.+6      	; 0xb022 <strtol+0x34>
    b01c:	fb 01       	movw	r30, r22
    b01e:	91 83       	std	Z+1, r25	; 0x01
    b020:	80 83       	st	Z, r24
    b022:	20 97       	sbiw	r28, 0x00	; 0
    b024:	49 f0       	breq	.+18     	; 0xb038 <strtol+0x4a>
    b026:	ce 01       	movw	r24, r28
    b028:	02 97       	sbiw	r24, 0x02	; 2
    b02a:	83 97       	sbiw	r24, 0x23	; 35
    b02c:	28 f0       	brcs	.+10     	; 0xb038 <strtol+0x4a>
    b02e:	20 e0       	ldi	r18, 0x00	; 0
    b030:	30 e0       	ldi	r19, 0x00	; 0
    b032:	40 e0       	ldi	r20, 0x00	; 0
    b034:	50 e0       	ldi	r21, 0x00	; 0
    b036:	f6 c0       	rjmp	.+492    	; 0xb224 <strtol+0x236>
    b038:	f8 01       	movw	r30, r16
    b03a:	a1 90       	ld	r10, Z+
    b03c:	8f 01       	movw	r16, r30
    b03e:	8a 2d       	mov	r24, r10
    b040:	90 e0       	ldi	r25, 0x00	; 0
    b042:	0e 94 26 59 	call	0xb24c	; 0xb24c <isspace>
    b046:	89 2b       	or	r24, r25
    b048:	b9 f7       	brne	.-18     	; 0xb038 <strtol+0x4a>
    b04a:	fd e2       	ldi	r31, 0x2D	; 45
    b04c:	af 16       	cp	r10, r31
    b04e:	31 f4       	brne	.+12     	; 0xb05c <strtol+0x6e>
    b050:	f8 01       	movw	r30, r16
    b052:	a1 90       	ld	r10, Z+
    b054:	8f 01       	movw	r16, r30
    b056:	55 24       	eor	r5, r5
    b058:	53 94       	inc	r5
    b05a:	07 c0       	rjmp	.+14     	; 0xb06a <strtol+0x7c>
    b05c:	fb e2       	ldi	r31, 0x2B	; 43
    b05e:	af 16       	cp	r10, r31
    b060:	19 f4       	brne	.+6      	; 0xb068 <strtol+0x7a>
    b062:	f8 01       	movw	r30, r16
    b064:	a1 90       	ld	r10, Z+
    b066:	8f 01       	movw	r16, r30
    b068:	55 24       	eor	r5, r5
    b06a:	20 97       	sbiw	r28, 0x00	; 0
    b06c:	19 f0       	breq	.+6      	; 0xb074 <strtol+0x86>
    b06e:	c0 31       	cpi	r28, 0x10	; 16
    b070:	d1 05       	cpc	r29, r1
    b072:	c1 f4       	brne	.+48     	; 0xb0a4 <strtol+0xb6>
    b074:	f0 e3       	ldi	r31, 0x30	; 48
    b076:	af 16       	cp	r10, r31
    b078:	79 f4       	brne	.+30     	; 0xb098 <strtol+0xaa>
    b07a:	f8 01       	movw	r30, r16
    b07c:	80 81       	ld	r24, Z
    b07e:	88 37       	cpi	r24, 0x78	; 120
    b080:	11 f0       	breq	.+4      	; 0xb086 <strtol+0x98>
    b082:	88 35       	cpi	r24, 0x58	; 88
    b084:	49 f4       	brne	.+18     	; 0xb098 <strtol+0xaa>
    b086:	f8 01       	movw	r30, r16
    b088:	a1 80       	ldd	r10, Z+1	; 0x01
    b08a:	0e 5f       	subi	r16, 0xFE	; 254
    b08c:	1f 4f       	sbci	r17, 0xFF	; 255
    b08e:	f2 e0       	ldi	r31, 0x02	; 2
    b090:	5f 2a       	or	r5, r31
    b092:	c0 e1       	ldi	r28, 0x10	; 16
    b094:	d0 e0       	ldi	r29, 0x00	; 0
    b096:	06 c0       	rjmp	.+12     	; 0xb0a4 <strtol+0xb6>
    b098:	20 97       	sbiw	r28, 0x00	; 0
    b09a:	21 f4       	brne	.+8      	; 0xb0a4 <strtol+0xb6>
    b09c:	80 e3       	ldi	r24, 0x30	; 48
    b09e:	a8 16       	cp	r10, r24
    b0a0:	e9 f4       	brne	.+58     	; 0xb0dc <strtol+0xee>
    b0a2:	27 c0       	rjmp	.+78     	; 0xb0f2 <strtol+0x104>
    b0a4:	c8 30       	cpi	r28, 0x08	; 8
    b0a6:	d1 05       	cpc	r29, r1
    b0a8:	31 f1       	breq	.+76     	; 0xb0f6 <strtol+0x108>
    b0aa:	c9 30       	cpi	r28, 0x09	; 9
    b0ac:	d1 05       	cpc	r29, r1
    b0ae:	24 f4       	brge	.+8      	; 0xb0b8 <strtol+0xca>
    b0b0:	c2 30       	cpi	r28, 0x02	; 2
    b0b2:	d1 05       	cpc	r29, r1
    b0b4:	31 f5       	brne	.+76     	; 0xb102 <strtol+0x114>
    b0b6:	0c c0       	rjmp	.+24     	; 0xb0d0 <strtol+0xe2>
    b0b8:	ca 30       	cpi	r28, 0x0A	; 10
    b0ba:	d1 05       	cpc	r29, r1
    b0bc:	89 f0       	breq	.+34     	; 0xb0e0 <strtol+0xf2>
    b0be:	c0 31       	cpi	r28, 0x10	; 16
    b0c0:	d1 05       	cpc	r29, r1
    b0c2:	f9 f4       	brne	.+62     	; 0xb102 <strtol+0x114>
    b0c4:	c1 2c       	mov	r12, r1
    b0c6:	d1 2c       	mov	r13, r1
    b0c8:	e1 2c       	mov	r14, r1
    b0ca:	b8 e0       	ldi	r27, 0x08	; 8
    b0cc:	fb 2e       	mov	r15, r27
    b0ce:	28 c0       	rjmp	.+80     	; 0xb120 <strtol+0x132>
    b0d0:	c1 2c       	mov	r12, r1
    b0d2:	d1 2c       	mov	r13, r1
    b0d4:	e1 2c       	mov	r14, r1
    b0d6:	a0 e4       	ldi	r26, 0x40	; 64
    b0d8:	fa 2e       	mov	r15, r26
    b0da:	22 c0       	rjmp	.+68     	; 0xb120 <strtol+0x132>
    b0dc:	ca e0       	ldi	r28, 0x0A	; 10
    b0de:	d0 e0       	ldi	r29, 0x00	; 0
    b0e0:	fc ec       	ldi	r31, 0xCC	; 204
    b0e2:	cf 2e       	mov	r12, r31
    b0e4:	fc ec       	ldi	r31, 0xCC	; 204
    b0e6:	df 2e       	mov	r13, r31
    b0e8:	fc ec       	ldi	r31, 0xCC	; 204
    b0ea:	ef 2e       	mov	r14, r31
    b0ec:	fc e0       	ldi	r31, 0x0C	; 12
    b0ee:	ff 2e       	mov	r15, r31
    b0f0:	17 c0       	rjmp	.+46     	; 0xb120 <strtol+0x132>
    b0f2:	c8 e0       	ldi	r28, 0x08	; 8
    b0f4:	d0 e0       	ldi	r29, 0x00	; 0
    b0f6:	c1 2c       	mov	r12, r1
    b0f8:	d1 2c       	mov	r13, r1
    b0fa:	e1 2c       	mov	r14, r1
    b0fc:	e0 e1       	ldi	r30, 0x10	; 16
    b0fe:	fe 2e       	mov	r15, r30
    b100:	0f c0       	rjmp	.+30     	; 0xb120 <strtol+0x132>
    b102:	9e 01       	movw	r18, r28
    b104:	44 27       	eor	r20, r20
    b106:	37 fd       	sbrc	r19, 7
    b108:	40 95       	com	r20
    b10a:	54 2f       	mov	r21, r20
    b10c:	60 e0       	ldi	r22, 0x00	; 0
    b10e:	70 e0       	ldi	r23, 0x00	; 0
    b110:	80 e0       	ldi	r24, 0x00	; 0
    b112:	90 e8       	ldi	r25, 0x80	; 128
    b114:	0e 94 93 5d 	call	0xbb26	; 0xbb26 <__udivmodsi4>
    b118:	c9 01       	movw	r24, r18
    b11a:	da 01       	movw	r26, r20
    b11c:	6c 01       	movw	r12, r24
    b11e:	7d 01       	movw	r14, r26
    b120:	20 e0       	ldi	r18, 0x00	; 0
    b122:	30 e0       	ldi	r19, 0x00	; 0
    b124:	40 e0       	ldi	r20, 0x00	; 0
    b126:	50 e0       	ldi	r21, 0x00	; 0
    b128:	60 e0       	ldi	r22, 0x00	; 0
    b12a:	3e 01       	movw	r6, r28
    b12c:	88 24       	eor	r8, r8
    b12e:	77 fc       	sbrc	r7, 7
    b130:	80 94       	com	r8
    b132:	98 2c       	mov	r9, r8
    b134:	70 ed       	ldi	r23, 0xD0	; 208
    b136:	b7 2e       	mov	r11, r23
    b138:	ba 0c       	add	r11, r10
    b13a:	e9 e0       	ldi	r30, 0x09	; 9
    b13c:	eb 15       	cp	r30, r11
    b13e:	70 f4       	brcc	.+28     	; 0xb15c <strtol+0x16e>
    b140:	8a 2d       	mov	r24, r10
    b142:	81 54       	subi	r24, 0x41	; 65
    b144:	8a 31       	cpi	r24, 0x1A	; 26
    b146:	18 f4       	brcc	.+6      	; 0xb14e <strtol+0x160>
    b148:	99 ec       	ldi	r25, 0xC9	; 201
    b14a:	b9 2e       	mov	r11, r25
    b14c:	06 c0       	rjmp	.+12     	; 0xb15a <strtol+0x16c>
    b14e:	8a 2d       	mov	r24, r10
    b150:	81 56       	subi	r24, 0x61	; 97
    b152:	8a 31       	cpi	r24, 0x1A	; 26
    b154:	50 f5       	brcc	.+84     	; 0xb1aa <strtol+0x1bc>
    b156:	89 ea       	ldi	r24, 0xA9	; 169
    b158:	b8 2e       	mov	r11, r24
    b15a:	ba 0c       	add	r11, r10
    b15c:	8b 2d       	mov	r24, r11
    b15e:	90 e0       	ldi	r25, 0x00	; 0
    b160:	8c 17       	cp	r24, r28
    b162:	9d 07       	cpc	r25, r29
    b164:	14 f5       	brge	.+68     	; 0xb1aa <strtol+0x1bc>
    b166:	6f 3f       	cpi	r22, 0xFF	; 255
    b168:	e1 f0       	breq	.+56     	; 0xb1a2 <strtol+0x1b4>
    b16a:	c2 16       	cp	r12, r18
    b16c:	d3 06       	cpc	r13, r19
    b16e:	e4 06       	cpc	r14, r20
    b170:	f5 06       	cpc	r15, r21
    b172:	b0 f0       	brcs	.+44     	; 0xb1a0 <strtol+0x1b2>
    b174:	ca 01       	movw	r24, r20
    b176:	b9 01       	movw	r22, r18
    b178:	a4 01       	movw	r20, r8
    b17a:	93 01       	movw	r18, r6
    b17c:	0e 94 74 5d 	call	0xbae8	; 0xbae8 <__mulsi3>
    b180:	9b 01       	movw	r18, r22
    b182:	ac 01       	movw	r20, r24
    b184:	2b 0d       	add	r18, r11
    b186:	31 1d       	adc	r19, r1
    b188:	41 1d       	adc	r20, r1
    b18a:	51 1d       	adc	r21, r1
    b18c:	21 30       	cpi	r18, 0x01	; 1
    b18e:	f0 e0       	ldi	r31, 0x00	; 0
    b190:	3f 07       	cpc	r19, r31
    b192:	f0 e0       	ldi	r31, 0x00	; 0
    b194:	4f 07       	cpc	r20, r31
    b196:	f0 e8       	ldi	r31, 0x80	; 128
    b198:	5f 07       	cpc	r21, r31
    b19a:	10 f4       	brcc	.+4      	; 0xb1a0 <strtol+0x1b2>
    b19c:	61 e0       	ldi	r22, 0x01	; 1
    b19e:	01 c0       	rjmp	.+2      	; 0xb1a2 <strtol+0x1b4>
    b1a0:	6f ef       	ldi	r22, 0xFF	; 255
    b1a2:	f8 01       	movw	r30, r16
    b1a4:	a1 90       	ld	r10, Z+
    b1a6:	8f 01       	movw	r16, r30
    b1a8:	c5 cf       	rjmp	.-118    	; 0xb134 <strtol+0x146>
    b1aa:	21 14       	cp	r2, r1
    b1ac:	31 04       	cpc	r3, r1
    b1ae:	81 f0       	breq	.+32     	; 0xb1d0 <strtol+0x1e2>
    b1b0:	66 23       	and	r22, r22
    b1b2:	31 f0       	breq	.+12     	; 0xb1c0 <strtol+0x1d2>
    b1b4:	01 50       	subi	r16, 0x01	; 1
    b1b6:	10 40       	sbci	r17, 0x00	; 0
    b1b8:	f1 01       	movw	r30, r2
    b1ba:	11 83       	std	Z+1, r17	; 0x01
    b1bc:	00 83       	st	Z, r16
    b1be:	08 c0       	rjmp	.+16     	; 0xb1d0 <strtol+0x1e2>
    b1c0:	51 fe       	sbrs	r5, 1
    b1c2:	1a c0       	rjmp	.+52     	; 0xb1f8 <strtol+0x20a>
    b1c4:	02 50       	subi	r16, 0x02	; 2
    b1c6:	10 40       	sbci	r17, 0x00	; 0
    b1c8:	f1 01       	movw	r30, r2
    b1ca:	11 83       	std	Z+1, r17	; 0x01
    b1cc:	00 83       	st	Z, r16
    b1ce:	14 c0       	rjmp	.+40     	; 0xb1f8 <strtol+0x20a>
    b1d0:	67 ff       	sbrs	r22, 7
    b1d2:	12 c0       	rjmp	.+36     	; 0xb1f8 <strtol+0x20a>
    b1d4:	50 fc       	sbrc	r5, 0
    b1d6:	05 c0       	rjmp	.+10     	; 0xb1e2 <strtol+0x1f4>
    b1d8:	2f ef       	ldi	r18, 0xFF	; 255
    b1da:	3f ef       	ldi	r19, 0xFF	; 255
    b1dc:	4f ef       	ldi	r20, 0xFF	; 255
    b1de:	5f e7       	ldi	r21, 0x7F	; 127
    b1e0:	04 c0       	rjmp	.+8      	; 0xb1ea <strtol+0x1fc>
    b1e2:	20 e0       	ldi	r18, 0x00	; 0
    b1e4:	30 e0       	ldi	r19, 0x00	; 0
    b1e6:	40 e0       	ldi	r20, 0x00	; 0
    b1e8:	50 e8       	ldi	r21, 0x80	; 128
    b1ea:	82 e2       	ldi	r24, 0x22	; 34
    b1ec:	90 e0       	ldi	r25, 0x00	; 0
    b1ee:	90 93 e3 0f 	sts	0x0FE3, r25
    b1f2:	80 93 e2 0f 	sts	0x0FE2, r24
    b1f6:	16 c0       	rjmp	.+44     	; 0xb224 <strtol+0x236>
    b1f8:	50 fe       	sbrs	r5, 0
    b1fa:	08 c0       	rjmp	.+16     	; 0xb20c <strtol+0x21e>
    b1fc:	50 95       	com	r21
    b1fe:	40 95       	com	r20
    b200:	30 95       	com	r19
    b202:	21 95       	neg	r18
    b204:	3f 4f       	sbci	r19, 0xFF	; 255
    b206:	4f 4f       	sbci	r20, 0xFF	; 255
    b208:	5f 4f       	sbci	r21, 0xFF	; 255
    b20a:	0c c0       	rjmp	.+24     	; 0xb224 <strtol+0x236>
    b20c:	57 ff       	sbrs	r21, 7
    b20e:	0a c0       	rjmp	.+20     	; 0xb224 <strtol+0x236>
    b210:	82 e2       	ldi	r24, 0x22	; 34
    b212:	90 e0       	ldi	r25, 0x00	; 0
    b214:	90 93 e3 0f 	sts	0x0FE3, r25
    b218:	80 93 e2 0f 	sts	0x0FE2, r24
    b21c:	2f ef       	ldi	r18, 0xFF	; 255
    b21e:	3f ef       	ldi	r19, 0xFF	; 255
    b220:	4f ef       	ldi	r20, 0xFF	; 255
    b222:	5f e7       	ldi	r21, 0x7F	; 127
    b224:	b9 01       	movw	r22, r18
    b226:	ca 01       	movw	r24, r20
    b228:	df 91       	pop	r29
    b22a:	cf 91       	pop	r28
    b22c:	1f 91       	pop	r17
    b22e:	0f 91       	pop	r16
    b230:	ff 90       	pop	r15
    b232:	ef 90       	pop	r14
    b234:	df 90       	pop	r13
    b236:	cf 90       	pop	r12
    b238:	bf 90       	pop	r11
    b23a:	af 90       	pop	r10
    b23c:	9f 90       	pop	r9
    b23e:	8f 90       	pop	r8
    b240:	7f 90       	pop	r7
    b242:	6f 90       	pop	r6
    b244:	5f 90       	pop	r5
    b246:	3f 90       	pop	r3
    b248:	2f 90       	pop	r2
    b24a:	08 95       	ret

0000b24c <isspace>:
    b24c:	91 11       	cpse	r25, r1
    b24e:	d5 c3       	rjmp	.+1962   	; 0xb9fa <__ctype_isfalse>
    b250:	80 32       	cpi	r24, 0x20	; 32
    b252:	19 f0       	breq	.+6      	; 0xb25a <isspace+0xe>
    b254:	89 50       	subi	r24, 0x09	; 9
    b256:	85 50       	subi	r24, 0x05	; 5
    b258:	d0 f7       	brcc	.-12     	; 0xb24e <isspace+0x2>
    b25a:	08 95       	ret

0000b25c <memcpy_P>:
    b25c:	fb 01       	movw	r30, r22
    b25e:	dc 01       	movw	r26, r24
    b260:	02 c0       	rjmp	.+4      	; 0xb266 <memcpy_P+0xa>
    b262:	05 90       	lpm	r0, Z+
    b264:	0d 92       	st	X+, r0
    b266:	41 50       	subi	r20, 0x01	; 1
    b268:	50 40       	sbci	r21, 0x00	; 0
    b26a:	d8 f7       	brcc	.-10     	; 0xb262 <memcpy_P+0x6>
    b26c:	08 95       	ret

0000b26e <strncmp_P>:
    b26e:	fb 01       	movw	r30, r22
    b270:	dc 01       	movw	r26, r24
    b272:	41 50       	subi	r20, 0x01	; 1
    b274:	50 40       	sbci	r21, 0x00	; 0
    b276:	30 f0       	brcs	.+12     	; 0xb284 <strncmp_P+0x16>
    b278:	8d 91       	ld	r24, X+
    b27a:	05 90       	lpm	r0, Z+
    b27c:	80 19       	sub	r24, r0
    b27e:	19 f4       	brne	.+6      	; 0xb286 <strncmp_P+0x18>
    b280:	00 20       	and	r0, r0
    b282:	b9 f7       	brne	.-18     	; 0xb272 <strncmp_P+0x4>
    b284:	88 1b       	sub	r24, r24
    b286:	99 0b       	sbc	r25, r25
    b288:	08 95       	ret

0000b28a <memcpy>:
    b28a:	fb 01       	movw	r30, r22
    b28c:	dc 01       	movw	r26, r24
    b28e:	02 c0       	rjmp	.+4      	; 0xb294 <memcpy+0xa>
    b290:	01 90       	ld	r0, Z+
    b292:	0d 92       	st	X+, r0
    b294:	41 50       	subi	r20, 0x01	; 1
    b296:	50 40       	sbci	r21, 0x00	; 0
    b298:	d8 f7       	brcc	.-10     	; 0xb290 <memcpy+0x6>
    b29a:	08 95       	ret

0000b29c <memset>:
    b29c:	dc 01       	movw	r26, r24
    b29e:	01 c0       	rjmp	.+2      	; 0xb2a2 <memset+0x6>
    b2a0:	6d 93       	st	X+, r22
    b2a2:	41 50       	subi	r20, 0x01	; 1
    b2a4:	50 40       	sbci	r21, 0x00	; 0
    b2a6:	e0 f7       	brcc	.-8      	; 0xb2a0 <memset+0x4>
    b2a8:	08 95       	ret

0000b2aa <strcat>:
    b2aa:	fb 01       	movw	r30, r22
    b2ac:	dc 01       	movw	r26, r24
    b2ae:	0d 90       	ld	r0, X+
    b2b0:	00 20       	and	r0, r0
    b2b2:	e9 f7       	brne	.-6      	; 0xb2ae <strcat+0x4>
    b2b4:	11 97       	sbiw	r26, 0x01	; 1
    b2b6:	01 90       	ld	r0, Z+
    b2b8:	0d 92       	st	X+, r0
    b2ba:	00 20       	and	r0, r0
    b2bc:	e1 f7       	brne	.-8      	; 0xb2b6 <strcat+0xc>
    b2be:	08 95       	ret

0000b2c0 <strcpy>:
    b2c0:	fb 01       	movw	r30, r22
    b2c2:	dc 01       	movw	r26, r24
    b2c4:	01 90       	ld	r0, Z+
    b2c6:	0d 92       	st	X+, r0
    b2c8:	00 20       	and	r0, r0
    b2ca:	e1 f7       	brne	.-8      	; 0xb2c4 <strcpy+0x4>
    b2cc:	08 95       	ret

0000b2ce <strncmp>:
    b2ce:	fb 01       	movw	r30, r22
    b2d0:	dc 01       	movw	r26, r24
    b2d2:	41 50       	subi	r20, 0x01	; 1
    b2d4:	50 40       	sbci	r21, 0x00	; 0
    b2d6:	30 f0       	brcs	.+12     	; 0xb2e4 <strncmp+0x16>
    b2d8:	8d 91       	ld	r24, X+
    b2da:	01 90       	ld	r0, Z+
    b2dc:	80 19       	sub	r24, r0
    b2de:	19 f4       	brne	.+6      	; 0xb2e6 <strncmp+0x18>
    b2e0:	00 20       	and	r0, r0
    b2e2:	b9 f7       	brne	.-18     	; 0xb2d2 <strncmp+0x4>
    b2e4:	88 1b       	sub	r24, r24
    b2e6:	99 0b       	sbc	r25, r25
    b2e8:	08 95       	ret

0000b2ea <strncpy>:
    b2ea:	fb 01       	movw	r30, r22
    b2ec:	dc 01       	movw	r26, r24
    b2ee:	41 50       	subi	r20, 0x01	; 1
    b2f0:	50 40       	sbci	r21, 0x00	; 0
    b2f2:	48 f0       	brcs	.+18     	; 0xb306 <strncpy+0x1c>
    b2f4:	01 90       	ld	r0, Z+
    b2f6:	0d 92       	st	X+, r0
    b2f8:	00 20       	and	r0, r0
    b2fa:	c9 f7       	brne	.-14     	; 0xb2ee <strncpy+0x4>
    b2fc:	01 c0       	rjmp	.+2      	; 0xb300 <strncpy+0x16>
    b2fe:	1d 92       	st	X+, r1
    b300:	41 50       	subi	r20, 0x01	; 1
    b302:	50 40       	sbci	r21, 0x00	; 0
    b304:	e0 f7       	brcc	.-8      	; 0xb2fe <strncpy+0x14>
    b306:	08 95       	ret

0000b308 <fclose>:
    b308:	fc 01       	movw	r30, r24
    b30a:	83 81       	ldd	r24, Z+3	; 0x03
    b30c:	87 ff       	sbrs	r24, 7
    b30e:	24 c0       	rjmp	.+72     	; 0xb358 <fclose+0x50>
    b310:	80 91 dc 0f 	lds	r24, 0x0FDC
    b314:	90 91 dd 0f 	lds	r25, 0x0FDD
    b318:	8e 17       	cp	r24, r30
    b31a:	9f 07       	cpc	r25, r31
    b31c:	21 f4       	brne	.+8      	; 0xb326 <fclose+0x1e>
    b31e:	10 92 dd 0f 	sts	0x0FDD, r1
    b322:	10 92 dc 0f 	sts	0x0FDC, r1
    b326:	80 91 de 0f 	lds	r24, 0x0FDE
    b32a:	90 91 df 0f 	lds	r25, 0x0FDF
    b32e:	8e 17       	cp	r24, r30
    b330:	9f 07       	cpc	r25, r31
    b332:	21 f4       	brne	.+8      	; 0xb33c <fclose+0x34>
    b334:	10 92 df 0f 	sts	0x0FDF, r1
    b338:	10 92 de 0f 	sts	0x0FDE, r1
    b33c:	80 91 e0 0f 	lds	r24, 0x0FE0
    b340:	90 91 e1 0f 	lds	r25, 0x0FE1
    b344:	8e 17       	cp	r24, r30
    b346:	9f 07       	cpc	r25, r31
    b348:	21 f4       	brne	.+8      	; 0xb352 <fclose+0x4a>
    b34a:	10 92 e1 0f 	sts	0x0FE1, r1
    b34e:	10 92 e0 0f 	sts	0x0FE0, r1
    b352:	cf 01       	movw	r24, r30
    b354:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <free>
    b358:	80 e0       	ldi	r24, 0x00	; 0
    b35a:	90 e0       	ldi	r25, 0x00	; 0
    b35c:	08 95       	ret

0000b35e <fgetc>:
    b35e:	cf 93       	push	r28
    b360:	df 93       	push	r29
    b362:	ec 01       	movw	r28, r24
    b364:	4b 81       	ldd	r20, Y+3	; 0x03
    b366:	40 ff       	sbrs	r20, 0
    b368:	1a c0       	rjmp	.+52     	; 0xb39e <fgetc+0x40>
    b36a:	46 ff       	sbrs	r20, 6
    b36c:	0a c0       	rjmp	.+20     	; 0xb382 <fgetc+0x24>
    b36e:	4f 7b       	andi	r20, 0xBF	; 191
    b370:	4b 83       	std	Y+3, r20	; 0x03
    b372:	8e 81       	ldd	r24, Y+6	; 0x06
    b374:	9f 81       	ldd	r25, Y+7	; 0x07
    b376:	01 96       	adiw	r24, 0x01	; 1
    b378:	9f 83       	std	Y+7, r25	; 0x07
    b37a:	8e 83       	std	Y+6, r24	; 0x06
    b37c:	8a 81       	ldd	r24, Y+2	; 0x02
    b37e:	28 2f       	mov	r18, r24
    b380:	2b c0       	rjmp	.+86     	; 0xb3d8 <fgetc+0x7a>
    b382:	42 ff       	sbrs	r20, 2
    b384:	13 c0       	rjmp	.+38     	; 0xb3ac <fgetc+0x4e>
    b386:	e8 81       	ld	r30, Y
    b388:	f9 81       	ldd	r31, Y+1	; 0x01
    b38a:	80 81       	ld	r24, Z
    b38c:	28 2f       	mov	r18, r24
    b38e:	33 27       	eor	r19, r19
    b390:	27 fd       	sbrc	r18, 7
    b392:	30 95       	com	r19
    b394:	21 15       	cp	r18, r1
    b396:	31 05       	cpc	r19, r1
    b398:	29 f4       	brne	.+10     	; 0xb3a4 <fgetc+0x46>
    b39a:	40 62       	ori	r20, 0x20	; 32
    b39c:	4b 83       	std	Y+3, r20	; 0x03
    b39e:	2f ef       	ldi	r18, 0xFF	; 255
    b3a0:	3f ef       	ldi	r19, 0xFF	; 255
    b3a2:	1b c0       	rjmp	.+54     	; 0xb3da <fgetc+0x7c>
    b3a4:	31 96       	adiw	r30, 0x01	; 1
    b3a6:	f9 83       	std	Y+1, r31	; 0x01
    b3a8:	e8 83       	st	Y, r30
    b3aa:	11 c0       	rjmp	.+34     	; 0xb3ce <fgetc+0x70>
    b3ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    b3ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    b3b0:	ce 01       	movw	r24, r28
    b3b2:	09 95       	icall
    b3b4:	9c 01       	movw	r18, r24
    b3b6:	97 ff       	sbrs	r25, 7
    b3b8:	0a c0       	rjmp	.+20     	; 0xb3ce <fgetc+0x70>
    b3ba:	9b 81       	ldd	r25, Y+3	; 0x03
    b3bc:	2f 5f       	subi	r18, 0xFF	; 255
    b3be:	3f 4f       	sbci	r19, 0xFF	; 255
    b3c0:	11 f0       	breq	.+4      	; 0xb3c6 <fgetc+0x68>
    b3c2:	80 e2       	ldi	r24, 0x20	; 32
    b3c4:	01 c0       	rjmp	.+2      	; 0xb3c8 <fgetc+0x6a>
    b3c6:	80 e1       	ldi	r24, 0x10	; 16
    b3c8:	89 2b       	or	r24, r25
    b3ca:	8b 83       	std	Y+3, r24	; 0x03
    b3cc:	e8 cf       	rjmp	.-48     	; 0xb39e <fgetc+0x40>
    b3ce:	8e 81       	ldd	r24, Y+6	; 0x06
    b3d0:	9f 81       	ldd	r25, Y+7	; 0x07
    b3d2:	01 96       	adiw	r24, 0x01	; 1
    b3d4:	9f 83       	std	Y+7, r25	; 0x07
    b3d6:	8e 83       	std	Y+6, r24	; 0x06
    b3d8:	30 e0       	ldi	r19, 0x00	; 0
    b3da:	c9 01       	movw	r24, r18
    b3dc:	df 91       	pop	r29
    b3de:	cf 91       	pop	r28
    b3e0:	08 95       	ret

0000b3e2 <fprintf>:
    b3e2:	df 93       	push	r29
    b3e4:	cf 93       	push	r28
    b3e6:	cd b7       	in	r28, 0x3d	; 61
    b3e8:	de b7       	in	r29, 0x3e	; 62
    b3ea:	9e 01       	movw	r18, r28
    b3ec:	27 5f       	subi	r18, 0xF7	; 247
    b3ee:	3f 4f       	sbci	r19, 0xFF	; 255
    b3f0:	8d 81       	ldd	r24, Y+5	; 0x05
    b3f2:	9e 81       	ldd	r25, Y+6	; 0x06
    b3f4:	6f 81       	ldd	r22, Y+7	; 0x07
    b3f6:	78 85       	ldd	r23, Y+8	; 0x08
    b3f8:	a9 01       	movw	r20, r18
    b3fa:	0e 94 a8 5a 	call	0xb550	; 0xb550 <vfprintf>
    b3fe:	cf 91       	pop	r28
    b400:	df 91       	pop	r29
    b402:	08 95       	ret

0000b404 <fprintf_P>:
    b404:	0f 93       	push	r16
    b406:	1f 93       	push	r17
    b408:	df 93       	push	r29
    b40a:	cf 93       	push	r28
    b40c:	cd b7       	in	r28, 0x3d	; 61
    b40e:	de b7       	in	r29, 0x3e	; 62
    b410:	0f 81       	ldd	r16, Y+7	; 0x07
    b412:	18 85       	ldd	r17, Y+8	; 0x08
    b414:	9e 01       	movw	r18, r28
    b416:	25 5f       	subi	r18, 0xF5	; 245
    b418:	3f 4f       	sbci	r19, 0xFF	; 255
    b41a:	f8 01       	movw	r30, r16
    b41c:	83 81       	ldd	r24, Z+3	; 0x03
    b41e:	88 60       	ori	r24, 0x08	; 8
    b420:	83 83       	std	Z+3, r24	; 0x03
    b422:	c8 01       	movw	r24, r16
    b424:	69 85       	ldd	r22, Y+9	; 0x09
    b426:	7a 85       	ldd	r23, Y+10	; 0x0a
    b428:	a9 01       	movw	r20, r18
    b42a:	0e 94 a8 5a 	call	0xb550	; 0xb550 <vfprintf>
    b42e:	f8 01       	movw	r30, r16
    b430:	23 81       	ldd	r18, Z+3	; 0x03
    b432:	27 7f       	andi	r18, 0xF7	; 247
    b434:	23 83       	std	Z+3, r18	; 0x03
    b436:	cf 91       	pop	r28
    b438:	df 91       	pop	r29
    b43a:	1f 91       	pop	r17
    b43c:	0f 91       	pop	r16
    b43e:	08 95       	ret

0000b440 <fputc>:
    b440:	0f 93       	push	r16
    b442:	1f 93       	push	r17
    b444:	cf 93       	push	r28
    b446:	df 93       	push	r29
    b448:	8c 01       	movw	r16, r24
    b44a:	eb 01       	movw	r28, r22
    b44c:	8b 81       	ldd	r24, Y+3	; 0x03
    b44e:	81 ff       	sbrs	r24, 1
    b450:	1b c0       	rjmp	.+54     	; 0xb488 <fputc+0x48>
    b452:	82 ff       	sbrs	r24, 2
    b454:	0d c0       	rjmp	.+26     	; 0xb470 <fputc+0x30>
    b456:	2e 81       	ldd	r18, Y+6	; 0x06
    b458:	3f 81       	ldd	r19, Y+7	; 0x07
    b45a:	8c 81       	ldd	r24, Y+4	; 0x04
    b45c:	9d 81       	ldd	r25, Y+5	; 0x05
    b45e:	28 17       	cp	r18, r24
    b460:	39 07       	cpc	r19, r25
    b462:	64 f4       	brge	.+24     	; 0xb47c <fputc+0x3c>
    b464:	e8 81       	ld	r30, Y
    b466:	f9 81       	ldd	r31, Y+1	; 0x01
    b468:	01 93       	st	Z+, r16
    b46a:	f9 83       	std	Y+1, r31	; 0x01
    b46c:	e8 83       	st	Y, r30
    b46e:	06 c0       	rjmp	.+12     	; 0xb47c <fputc+0x3c>
    b470:	e8 85       	ldd	r30, Y+8	; 0x08
    b472:	f9 85       	ldd	r31, Y+9	; 0x09
    b474:	80 2f       	mov	r24, r16
    b476:	09 95       	icall
    b478:	89 2b       	or	r24, r25
    b47a:	31 f4       	brne	.+12     	; 0xb488 <fputc+0x48>
    b47c:	8e 81       	ldd	r24, Y+6	; 0x06
    b47e:	9f 81       	ldd	r25, Y+7	; 0x07
    b480:	01 96       	adiw	r24, 0x01	; 1
    b482:	9f 83       	std	Y+7, r25	; 0x07
    b484:	8e 83       	std	Y+6, r24	; 0x06
    b486:	02 c0       	rjmp	.+4      	; 0xb48c <fputc+0x4c>
    b488:	0f ef       	ldi	r16, 0xFF	; 255
    b48a:	1f ef       	ldi	r17, 0xFF	; 255
    b48c:	c8 01       	movw	r24, r16
    b48e:	df 91       	pop	r29
    b490:	cf 91       	pop	r28
    b492:	1f 91       	pop	r17
    b494:	0f 91       	pop	r16
    b496:	08 95       	ret

0000b498 <fputs>:
    b498:	ef 92       	push	r14
    b49a:	ff 92       	push	r15
    b49c:	0f 93       	push	r16
    b49e:	1f 93       	push	r17
    b4a0:	cf 93       	push	r28
    b4a2:	df 93       	push	r29
    b4a4:	7c 01       	movw	r14, r24
    b4a6:	8b 01       	movw	r16, r22
    b4a8:	db 01       	movw	r26, r22
    b4aa:	13 96       	adiw	r26, 0x03	; 3
    b4ac:	8c 91       	ld	r24, X
    b4ae:	81 fd       	sbrc	r24, 1
    b4b0:	03 c0       	rjmp	.+6      	; 0xb4b8 <fputs+0x20>
    b4b2:	cf ef       	ldi	r28, 0xFF	; 255
    b4b4:	df ef       	ldi	r29, 0xFF	; 255
    b4b6:	13 c0       	rjmp	.+38     	; 0xb4de <fputs+0x46>
    b4b8:	c0 e0       	ldi	r28, 0x00	; 0
    b4ba:	d0 e0       	ldi	r29, 0x00	; 0
    b4bc:	0b c0       	rjmp	.+22     	; 0xb4d4 <fputs+0x3c>
    b4be:	d8 01       	movw	r26, r16
    b4c0:	18 96       	adiw	r26, 0x08	; 8
    b4c2:	ed 91       	ld	r30, X+
    b4c4:	fc 91       	ld	r31, X
    b4c6:	19 97       	sbiw	r26, 0x09	; 9
    b4c8:	b8 01       	movw	r22, r16
    b4ca:	09 95       	icall
    b4cc:	89 2b       	or	r24, r25
    b4ce:	11 f0       	breq	.+4      	; 0xb4d4 <fputs+0x3c>
    b4d0:	cf ef       	ldi	r28, 0xFF	; 255
    b4d2:	df ef       	ldi	r29, 0xFF	; 255
    b4d4:	f7 01       	movw	r30, r14
    b4d6:	81 91       	ld	r24, Z+
    b4d8:	7f 01       	movw	r14, r30
    b4da:	88 23       	and	r24, r24
    b4dc:	81 f7       	brne	.-32     	; 0xb4be <fputs+0x26>
    b4de:	ce 01       	movw	r24, r28
    b4e0:	df 91       	pop	r29
    b4e2:	cf 91       	pop	r28
    b4e4:	1f 91       	pop	r17
    b4e6:	0f 91       	pop	r16
    b4e8:	ff 90       	pop	r15
    b4ea:	ef 90       	pop	r14
    b4ec:	08 95       	ret

0000b4ee <sprintf>:
    b4ee:	0f 93       	push	r16
    b4f0:	1f 93       	push	r17
    b4f2:	df 93       	push	r29
    b4f4:	cf 93       	push	r28
    b4f6:	cd b7       	in	r28, 0x3d	; 61
    b4f8:	de b7       	in	r29, 0x3e	; 62
    b4fa:	2e 97       	sbiw	r28, 0x0e	; 14
    b4fc:	0f b6       	in	r0, 0x3f	; 63
    b4fe:	f8 94       	cli
    b500:	de bf       	out	0x3e, r29	; 62
    b502:	0f be       	out	0x3f, r0	; 63
    b504:	cd bf       	out	0x3d, r28	; 61
    b506:	0d 89       	ldd	r16, Y+21	; 0x15
    b508:	1e 89       	ldd	r17, Y+22	; 0x16
    b50a:	86 e0       	ldi	r24, 0x06	; 6
    b50c:	8c 83       	std	Y+4, r24	; 0x04
    b50e:	1a 83       	std	Y+2, r17	; 0x02
    b510:	09 83       	std	Y+1, r16	; 0x01
    b512:	8f ef       	ldi	r24, 0xFF	; 255
    b514:	9f e7       	ldi	r25, 0x7F	; 127
    b516:	9e 83       	std	Y+6, r25	; 0x06
    b518:	8d 83       	std	Y+5, r24	; 0x05
    b51a:	9e 01       	movw	r18, r28
    b51c:	27 5e       	subi	r18, 0xE7	; 231
    b51e:	3f 4f       	sbci	r19, 0xFF	; 255
    b520:	ce 01       	movw	r24, r28
    b522:	01 96       	adiw	r24, 0x01	; 1
    b524:	6f 89       	ldd	r22, Y+23	; 0x17
    b526:	78 8d       	ldd	r23, Y+24	; 0x18
    b528:	a9 01       	movw	r20, r18
    b52a:	0e 94 a8 5a 	call	0xb550	; 0xb550 <vfprintf>
    b52e:	2f 81       	ldd	r18, Y+7	; 0x07
    b530:	38 85       	ldd	r19, Y+8	; 0x08
    b532:	02 0f       	add	r16, r18
    b534:	13 1f       	adc	r17, r19
    b536:	f8 01       	movw	r30, r16
    b538:	10 82       	st	Z, r1
    b53a:	2e 96       	adiw	r28, 0x0e	; 14
    b53c:	0f b6       	in	r0, 0x3f	; 63
    b53e:	f8 94       	cli
    b540:	de bf       	out	0x3e, r29	; 62
    b542:	0f be       	out	0x3f, r0	; 63
    b544:	cd bf       	out	0x3d, r28	; 61
    b546:	cf 91       	pop	r28
    b548:	df 91       	pop	r29
    b54a:	1f 91       	pop	r17
    b54c:	0f 91       	pop	r16
    b54e:	08 95       	ret

0000b550 <vfprintf>:
    b550:	2f 92       	push	r2
    b552:	3f 92       	push	r3
    b554:	4f 92       	push	r4
    b556:	5f 92       	push	r5
    b558:	6f 92       	push	r6
    b55a:	7f 92       	push	r7
    b55c:	8f 92       	push	r8
    b55e:	9f 92       	push	r9
    b560:	af 92       	push	r10
    b562:	bf 92       	push	r11
    b564:	cf 92       	push	r12
    b566:	df 92       	push	r13
    b568:	ef 92       	push	r14
    b56a:	ff 92       	push	r15
    b56c:	0f 93       	push	r16
    b56e:	1f 93       	push	r17
    b570:	df 93       	push	r29
    b572:	cf 93       	push	r28
    b574:	cd b7       	in	r28, 0x3d	; 61
    b576:	de b7       	in	r29, 0x3e	; 62
    b578:	2b 97       	sbiw	r28, 0x0b	; 11
    b57a:	0f b6       	in	r0, 0x3f	; 63
    b57c:	f8 94       	cli
    b57e:	de bf       	out	0x3e, r29	; 62
    b580:	0f be       	out	0x3f, r0	; 63
    b582:	cd bf       	out	0x3d, r28	; 61
    b584:	3c 01       	movw	r6, r24
    b586:	2b 01       	movw	r4, r22
    b588:	5a 01       	movw	r10, r20
    b58a:	fc 01       	movw	r30, r24
    b58c:	17 82       	std	Z+7, r1	; 0x07
    b58e:	16 82       	std	Z+6, r1	; 0x06
    b590:	83 81       	ldd	r24, Z+3	; 0x03
    b592:	81 fd       	sbrc	r24, 1
    b594:	03 c0       	rjmp	.+6      	; 0xb59c <vfprintf+0x4c>
    b596:	6f ef       	ldi	r22, 0xFF	; 255
    b598:	7f ef       	ldi	r23, 0xFF	; 255
    b59a:	c6 c1       	rjmp	.+908    	; 0xb928 <vfprintf+0x3d8>
    b59c:	9a e0       	ldi	r25, 0x0A	; 10
    b59e:	89 2e       	mov	r8, r25
    b5a0:	1e 01       	movw	r2, r28
    b5a2:	08 94       	sec
    b5a4:	21 1c       	adc	r2, r1
    b5a6:	31 1c       	adc	r3, r1
    b5a8:	f3 01       	movw	r30, r6
    b5aa:	23 81       	ldd	r18, Z+3	; 0x03
    b5ac:	f2 01       	movw	r30, r4
    b5ae:	23 fd       	sbrc	r18, 3
    b5b0:	85 91       	lpm	r24, Z+
    b5b2:	23 ff       	sbrs	r18, 3
    b5b4:	81 91       	ld	r24, Z+
    b5b6:	2f 01       	movw	r4, r30
    b5b8:	88 23       	and	r24, r24
    b5ba:	09 f4       	brne	.+2      	; 0xb5be <vfprintf+0x6e>
    b5bc:	b2 c1       	rjmp	.+868    	; 0xb922 <vfprintf+0x3d2>
    b5be:	85 32       	cpi	r24, 0x25	; 37
    b5c0:	39 f4       	brne	.+14     	; 0xb5d0 <vfprintf+0x80>
    b5c2:	23 fd       	sbrc	r18, 3
    b5c4:	85 91       	lpm	r24, Z+
    b5c6:	23 ff       	sbrs	r18, 3
    b5c8:	81 91       	ld	r24, Z+
    b5ca:	2f 01       	movw	r4, r30
    b5cc:	85 32       	cpi	r24, 0x25	; 37
    b5ce:	29 f4       	brne	.+10     	; 0xb5da <vfprintf+0x8a>
    b5d0:	90 e0       	ldi	r25, 0x00	; 0
    b5d2:	b3 01       	movw	r22, r6
    b5d4:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b5d8:	e7 cf       	rjmp	.-50     	; 0xb5a8 <vfprintf+0x58>
    b5da:	98 2f       	mov	r25, r24
    b5dc:	ff 24       	eor	r15, r15
    b5de:	ee 24       	eor	r14, r14
    b5e0:	99 24       	eor	r9, r9
    b5e2:	ff e1       	ldi	r31, 0x1F	; 31
    b5e4:	ff 15       	cp	r31, r15
    b5e6:	d0 f0       	brcs	.+52     	; 0xb61c <vfprintf+0xcc>
    b5e8:	9b 32       	cpi	r25, 0x2B	; 43
    b5ea:	69 f0       	breq	.+26     	; 0xb606 <vfprintf+0xb6>
    b5ec:	9c 32       	cpi	r25, 0x2C	; 44
    b5ee:	28 f4       	brcc	.+10     	; 0xb5fa <vfprintf+0xaa>
    b5f0:	90 32       	cpi	r25, 0x20	; 32
    b5f2:	59 f0       	breq	.+22     	; 0xb60a <vfprintf+0xba>
    b5f4:	93 32       	cpi	r25, 0x23	; 35
    b5f6:	91 f4       	brne	.+36     	; 0xb61c <vfprintf+0xcc>
    b5f8:	0e c0       	rjmp	.+28     	; 0xb616 <vfprintf+0xc6>
    b5fa:	9d 32       	cpi	r25, 0x2D	; 45
    b5fc:	49 f0       	breq	.+18     	; 0xb610 <vfprintf+0xc0>
    b5fe:	90 33       	cpi	r25, 0x30	; 48
    b600:	69 f4       	brne	.+26     	; 0xb61c <vfprintf+0xcc>
    b602:	41 e0       	ldi	r20, 0x01	; 1
    b604:	24 c0       	rjmp	.+72     	; 0xb64e <vfprintf+0xfe>
    b606:	52 e0       	ldi	r21, 0x02	; 2
    b608:	f5 2a       	or	r15, r21
    b60a:	84 e0       	ldi	r24, 0x04	; 4
    b60c:	f8 2a       	or	r15, r24
    b60e:	28 c0       	rjmp	.+80     	; 0xb660 <vfprintf+0x110>
    b610:	98 e0       	ldi	r25, 0x08	; 8
    b612:	f9 2a       	or	r15, r25
    b614:	25 c0       	rjmp	.+74     	; 0xb660 <vfprintf+0x110>
    b616:	e0 e1       	ldi	r30, 0x10	; 16
    b618:	fe 2a       	or	r15, r30
    b61a:	22 c0       	rjmp	.+68     	; 0xb660 <vfprintf+0x110>
    b61c:	f7 fc       	sbrc	r15, 7
    b61e:	29 c0       	rjmp	.+82     	; 0xb672 <vfprintf+0x122>
    b620:	89 2f       	mov	r24, r25
    b622:	80 53       	subi	r24, 0x30	; 48
    b624:	8a 30       	cpi	r24, 0x0A	; 10
    b626:	70 f4       	brcc	.+28     	; 0xb644 <vfprintf+0xf4>
    b628:	f6 fe       	sbrs	r15, 6
    b62a:	05 c0       	rjmp	.+10     	; 0xb636 <vfprintf+0xe6>
    b62c:	98 9c       	mul	r9, r8
    b62e:	90 2c       	mov	r9, r0
    b630:	11 24       	eor	r1, r1
    b632:	98 0e       	add	r9, r24
    b634:	15 c0       	rjmp	.+42     	; 0xb660 <vfprintf+0x110>
    b636:	e8 9c       	mul	r14, r8
    b638:	e0 2c       	mov	r14, r0
    b63a:	11 24       	eor	r1, r1
    b63c:	e8 0e       	add	r14, r24
    b63e:	f0 e2       	ldi	r31, 0x20	; 32
    b640:	ff 2a       	or	r15, r31
    b642:	0e c0       	rjmp	.+28     	; 0xb660 <vfprintf+0x110>
    b644:	9e 32       	cpi	r25, 0x2E	; 46
    b646:	29 f4       	brne	.+10     	; 0xb652 <vfprintf+0x102>
    b648:	f6 fc       	sbrc	r15, 6
    b64a:	6b c1       	rjmp	.+726    	; 0xb922 <vfprintf+0x3d2>
    b64c:	40 e4       	ldi	r20, 0x40	; 64
    b64e:	f4 2a       	or	r15, r20
    b650:	07 c0       	rjmp	.+14     	; 0xb660 <vfprintf+0x110>
    b652:	9c 36       	cpi	r25, 0x6C	; 108
    b654:	19 f4       	brne	.+6      	; 0xb65c <vfprintf+0x10c>
    b656:	50 e8       	ldi	r21, 0x80	; 128
    b658:	f5 2a       	or	r15, r21
    b65a:	02 c0       	rjmp	.+4      	; 0xb660 <vfprintf+0x110>
    b65c:	98 36       	cpi	r25, 0x68	; 104
    b65e:	49 f4       	brne	.+18     	; 0xb672 <vfprintf+0x122>
    b660:	f2 01       	movw	r30, r4
    b662:	23 fd       	sbrc	r18, 3
    b664:	95 91       	lpm	r25, Z+
    b666:	23 ff       	sbrs	r18, 3
    b668:	91 91       	ld	r25, Z+
    b66a:	2f 01       	movw	r4, r30
    b66c:	99 23       	and	r25, r25
    b66e:	09 f0       	breq	.+2      	; 0xb672 <vfprintf+0x122>
    b670:	b8 cf       	rjmp	.-144    	; 0xb5e2 <vfprintf+0x92>
    b672:	89 2f       	mov	r24, r25
    b674:	85 54       	subi	r24, 0x45	; 69
    b676:	83 30       	cpi	r24, 0x03	; 3
    b678:	18 f0       	brcs	.+6      	; 0xb680 <vfprintf+0x130>
    b67a:	80 52       	subi	r24, 0x20	; 32
    b67c:	83 30       	cpi	r24, 0x03	; 3
    b67e:	38 f4       	brcc	.+14     	; 0xb68e <vfprintf+0x13e>
    b680:	44 e0       	ldi	r20, 0x04	; 4
    b682:	50 e0       	ldi	r21, 0x00	; 0
    b684:	a4 0e       	add	r10, r20
    b686:	b5 1e       	adc	r11, r21
    b688:	5f e3       	ldi	r21, 0x3F	; 63
    b68a:	59 83       	std	Y+1, r21	; 0x01
    b68c:	0f c0       	rjmp	.+30     	; 0xb6ac <vfprintf+0x15c>
    b68e:	93 36       	cpi	r25, 0x63	; 99
    b690:	31 f0       	breq	.+12     	; 0xb69e <vfprintf+0x14e>
    b692:	93 37       	cpi	r25, 0x73	; 115
    b694:	79 f0       	breq	.+30     	; 0xb6b4 <vfprintf+0x164>
    b696:	93 35       	cpi	r25, 0x53	; 83
    b698:	09 f0       	breq	.+2      	; 0xb69c <vfprintf+0x14c>
    b69a:	56 c0       	rjmp	.+172    	; 0xb748 <vfprintf+0x1f8>
    b69c:	20 c0       	rjmp	.+64     	; 0xb6de <vfprintf+0x18e>
    b69e:	f5 01       	movw	r30, r10
    b6a0:	80 81       	ld	r24, Z
    b6a2:	89 83       	std	Y+1, r24	; 0x01
    b6a4:	42 e0       	ldi	r20, 0x02	; 2
    b6a6:	50 e0       	ldi	r21, 0x00	; 0
    b6a8:	a4 0e       	add	r10, r20
    b6aa:	b5 1e       	adc	r11, r21
    b6ac:	61 01       	movw	r12, r2
    b6ae:	01 e0       	ldi	r16, 0x01	; 1
    b6b0:	10 e0       	ldi	r17, 0x00	; 0
    b6b2:	12 c0       	rjmp	.+36     	; 0xb6d8 <vfprintf+0x188>
    b6b4:	f5 01       	movw	r30, r10
    b6b6:	c0 80       	ld	r12, Z
    b6b8:	d1 80       	ldd	r13, Z+1	; 0x01
    b6ba:	f6 fc       	sbrc	r15, 6
    b6bc:	03 c0       	rjmp	.+6      	; 0xb6c4 <vfprintf+0x174>
    b6be:	6f ef       	ldi	r22, 0xFF	; 255
    b6c0:	7f ef       	ldi	r23, 0xFF	; 255
    b6c2:	02 c0       	rjmp	.+4      	; 0xb6c8 <vfprintf+0x178>
    b6c4:	69 2d       	mov	r22, r9
    b6c6:	70 e0       	ldi	r23, 0x00	; 0
    b6c8:	42 e0       	ldi	r20, 0x02	; 2
    b6ca:	50 e0       	ldi	r21, 0x00	; 0
    b6cc:	a4 0e       	add	r10, r20
    b6ce:	b5 1e       	adc	r11, r21
    b6d0:	c6 01       	movw	r24, r12
    b6d2:	0e 94 0b 5d 	call	0xba16	; 0xba16 <strnlen>
    b6d6:	8c 01       	movw	r16, r24
    b6d8:	5f e7       	ldi	r21, 0x7F	; 127
    b6da:	f5 22       	and	r15, r21
    b6dc:	14 c0       	rjmp	.+40     	; 0xb706 <vfprintf+0x1b6>
    b6de:	f5 01       	movw	r30, r10
    b6e0:	c0 80       	ld	r12, Z
    b6e2:	d1 80       	ldd	r13, Z+1	; 0x01
    b6e4:	f6 fc       	sbrc	r15, 6
    b6e6:	03 c0       	rjmp	.+6      	; 0xb6ee <vfprintf+0x19e>
    b6e8:	6f ef       	ldi	r22, 0xFF	; 255
    b6ea:	7f ef       	ldi	r23, 0xFF	; 255
    b6ec:	02 c0       	rjmp	.+4      	; 0xb6f2 <vfprintf+0x1a2>
    b6ee:	69 2d       	mov	r22, r9
    b6f0:	70 e0       	ldi	r23, 0x00	; 0
    b6f2:	42 e0       	ldi	r20, 0x02	; 2
    b6f4:	50 e0       	ldi	r21, 0x00	; 0
    b6f6:	a4 0e       	add	r10, r20
    b6f8:	b5 1e       	adc	r11, r21
    b6fa:	c6 01       	movw	r24, r12
    b6fc:	0e 94 00 5d 	call	0xba00	; 0xba00 <strnlen_P>
    b700:	8c 01       	movw	r16, r24
    b702:	50 e8       	ldi	r21, 0x80	; 128
    b704:	f5 2a       	or	r15, r21
    b706:	f3 fe       	sbrs	r15, 3
    b708:	07 c0       	rjmp	.+14     	; 0xb718 <vfprintf+0x1c8>
    b70a:	1a c0       	rjmp	.+52     	; 0xb740 <vfprintf+0x1f0>
    b70c:	80 e2       	ldi	r24, 0x20	; 32
    b70e:	90 e0       	ldi	r25, 0x00	; 0
    b710:	b3 01       	movw	r22, r6
    b712:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b716:	ea 94       	dec	r14
    b718:	8e 2d       	mov	r24, r14
    b71a:	90 e0       	ldi	r25, 0x00	; 0
    b71c:	08 17       	cp	r16, r24
    b71e:	19 07       	cpc	r17, r25
    b720:	a8 f3       	brcs	.-22     	; 0xb70c <vfprintf+0x1bc>
    b722:	0e c0       	rjmp	.+28     	; 0xb740 <vfprintf+0x1f0>
    b724:	f6 01       	movw	r30, r12
    b726:	f7 fc       	sbrc	r15, 7
    b728:	85 91       	lpm	r24, Z+
    b72a:	f7 fe       	sbrs	r15, 7
    b72c:	81 91       	ld	r24, Z+
    b72e:	6f 01       	movw	r12, r30
    b730:	90 e0       	ldi	r25, 0x00	; 0
    b732:	b3 01       	movw	r22, r6
    b734:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b738:	e1 10       	cpse	r14, r1
    b73a:	ea 94       	dec	r14
    b73c:	01 50       	subi	r16, 0x01	; 1
    b73e:	10 40       	sbci	r17, 0x00	; 0
    b740:	01 15       	cp	r16, r1
    b742:	11 05       	cpc	r17, r1
    b744:	79 f7       	brne	.-34     	; 0xb724 <vfprintf+0x1d4>
    b746:	ea c0       	rjmp	.+468    	; 0xb91c <vfprintf+0x3cc>
    b748:	94 36       	cpi	r25, 0x64	; 100
    b74a:	11 f0       	breq	.+4      	; 0xb750 <vfprintf+0x200>
    b74c:	99 36       	cpi	r25, 0x69	; 105
    b74e:	69 f5       	brne	.+90     	; 0xb7aa <vfprintf+0x25a>
    b750:	f7 fe       	sbrs	r15, 7
    b752:	08 c0       	rjmp	.+16     	; 0xb764 <vfprintf+0x214>
    b754:	f5 01       	movw	r30, r10
    b756:	20 81       	ld	r18, Z
    b758:	31 81       	ldd	r19, Z+1	; 0x01
    b75a:	42 81       	ldd	r20, Z+2	; 0x02
    b75c:	53 81       	ldd	r21, Z+3	; 0x03
    b75e:	84 e0       	ldi	r24, 0x04	; 4
    b760:	90 e0       	ldi	r25, 0x00	; 0
    b762:	0a c0       	rjmp	.+20     	; 0xb778 <vfprintf+0x228>
    b764:	f5 01       	movw	r30, r10
    b766:	80 81       	ld	r24, Z
    b768:	91 81       	ldd	r25, Z+1	; 0x01
    b76a:	9c 01       	movw	r18, r24
    b76c:	44 27       	eor	r20, r20
    b76e:	37 fd       	sbrc	r19, 7
    b770:	40 95       	com	r20
    b772:	54 2f       	mov	r21, r20
    b774:	82 e0       	ldi	r24, 0x02	; 2
    b776:	90 e0       	ldi	r25, 0x00	; 0
    b778:	a8 0e       	add	r10, r24
    b77a:	b9 1e       	adc	r11, r25
    b77c:	9f e6       	ldi	r25, 0x6F	; 111
    b77e:	f9 22       	and	r15, r25
    b780:	57 ff       	sbrs	r21, 7
    b782:	09 c0       	rjmp	.+18     	; 0xb796 <vfprintf+0x246>
    b784:	50 95       	com	r21
    b786:	40 95       	com	r20
    b788:	30 95       	com	r19
    b78a:	21 95       	neg	r18
    b78c:	3f 4f       	sbci	r19, 0xFF	; 255
    b78e:	4f 4f       	sbci	r20, 0xFF	; 255
    b790:	5f 4f       	sbci	r21, 0xFF	; 255
    b792:	e0 e8       	ldi	r30, 0x80	; 128
    b794:	fe 2a       	or	r15, r30
    b796:	ca 01       	movw	r24, r20
    b798:	b9 01       	movw	r22, r18
    b79a:	a1 01       	movw	r20, r2
    b79c:	2a e0       	ldi	r18, 0x0A	; 10
    b79e:	30 e0       	ldi	r19, 0x00	; 0
    b7a0:	0e 94 16 5d 	call	0xba2c	; 0xba2c <__ultoa_invert>
    b7a4:	d8 2e       	mov	r13, r24
    b7a6:	d2 18       	sub	r13, r2
    b7a8:	40 c0       	rjmp	.+128    	; 0xb82a <vfprintf+0x2da>
    b7aa:	95 37       	cpi	r25, 0x75	; 117
    b7ac:	29 f4       	brne	.+10     	; 0xb7b8 <vfprintf+0x268>
    b7ae:	1f 2d       	mov	r17, r15
    b7b0:	1f 7e       	andi	r17, 0xEF	; 239
    b7b2:	2a e0       	ldi	r18, 0x0A	; 10
    b7b4:	30 e0       	ldi	r19, 0x00	; 0
    b7b6:	1d c0       	rjmp	.+58     	; 0xb7f2 <vfprintf+0x2a2>
    b7b8:	1f 2d       	mov	r17, r15
    b7ba:	19 7f       	andi	r17, 0xF9	; 249
    b7bc:	9f 36       	cpi	r25, 0x6F	; 111
    b7be:	61 f0       	breq	.+24     	; 0xb7d8 <vfprintf+0x288>
    b7c0:	90 37       	cpi	r25, 0x70	; 112
    b7c2:	20 f4       	brcc	.+8      	; 0xb7cc <vfprintf+0x27c>
    b7c4:	98 35       	cpi	r25, 0x58	; 88
    b7c6:	09 f0       	breq	.+2      	; 0xb7ca <vfprintf+0x27a>
    b7c8:	ac c0       	rjmp	.+344    	; 0xb922 <vfprintf+0x3d2>
    b7ca:	0f c0       	rjmp	.+30     	; 0xb7ea <vfprintf+0x29a>
    b7cc:	90 37       	cpi	r25, 0x70	; 112
    b7ce:	39 f0       	breq	.+14     	; 0xb7de <vfprintf+0x28e>
    b7d0:	98 37       	cpi	r25, 0x78	; 120
    b7d2:	09 f0       	breq	.+2      	; 0xb7d6 <vfprintf+0x286>
    b7d4:	a6 c0       	rjmp	.+332    	; 0xb922 <vfprintf+0x3d2>
    b7d6:	04 c0       	rjmp	.+8      	; 0xb7e0 <vfprintf+0x290>
    b7d8:	28 e0       	ldi	r18, 0x08	; 8
    b7da:	30 e0       	ldi	r19, 0x00	; 0
    b7dc:	0a c0       	rjmp	.+20     	; 0xb7f2 <vfprintf+0x2a2>
    b7de:	10 61       	ori	r17, 0x10	; 16
    b7e0:	14 fd       	sbrc	r17, 4
    b7e2:	14 60       	ori	r17, 0x04	; 4
    b7e4:	20 e1       	ldi	r18, 0x10	; 16
    b7e6:	30 e0       	ldi	r19, 0x00	; 0
    b7e8:	04 c0       	rjmp	.+8      	; 0xb7f2 <vfprintf+0x2a2>
    b7ea:	14 fd       	sbrc	r17, 4
    b7ec:	16 60       	ori	r17, 0x06	; 6
    b7ee:	20 e1       	ldi	r18, 0x10	; 16
    b7f0:	32 e0       	ldi	r19, 0x02	; 2
    b7f2:	17 ff       	sbrs	r17, 7
    b7f4:	08 c0       	rjmp	.+16     	; 0xb806 <vfprintf+0x2b6>
    b7f6:	f5 01       	movw	r30, r10
    b7f8:	60 81       	ld	r22, Z
    b7fa:	71 81       	ldd	r23, Z+1	; 0x01
    b7fc:	82 81       	ldd	r24, Z+2	; 0x02
    b7fe:	93 81       	ldd	r25, Z+3	; 0x03
    b800:	44 e0       	ldi	r20, 0x04	; 4
    b802:	50 e0       	ldi	r21, 0x00	; 0
    b804:	08 c0       	rjmp	.+16     	; 0xb816 <vfprintf+0x2c6>
    b806:	f5 01       	movw	r30, r10
    b808:	80 81       	ld	r24, Z
    b80a:	91 81       	ldd	r25, Z+1	; 0x01
    b80c:	bc 01       	movw	r22, r24
    b80e:	80 e0       	ldi	r24, 0x00	; 0
    b810:	90 e0       	ldi	r25, 0x00	; 0
    b812:	42 e0       	ldi	r20, 0x02	; 2
    b814:	50 e0       	ldi	r21, 0x00	; 0
    b816:	a4 0e       	add	r10, r20
    b818:	b5 1e       	adc	r11, r21
    b81a:	a1 01       	movw	r20, r2
    b81c:	0e 94 16 5d 	call	0xba2c	; 0xba2c <__ultoa_invert>
    b820:	d8 2e       	mov	r13, r24
    b822:	d2 18       	sub	r13, r2
    b824:	8f e7       	ldi	r24, 0x7F	; 127
    b826:	f8 2e       	mov	r15, r24
    b828:	f1 22       	and	r15, r17
    b82a:	f6 fe       	sbrs	r15, 6
    b82c:	0b c0       	rjmp	.+22     	; 0xb844 <vfprintf+0x2f4>
    b82e:	5e ef       	ldi	r21, 0xFE	; 254
    b830:	f5 22       	and	r15, r21
    b832:	d9 14       	cp	r13, r9
    b834:	38 f4       	brcc	.+14     	; 0xb844 <vfprintf+0x2f4>
    b836:	f4 fe       	sbrs	r15, 4
    b838:	07 c0       	rjmp	.+14     	; 0xb848 <vfprintf+0x2f8>
    b83a:	f2 fc       	sbrc	r15, 2
    b83c:	05 c0       	rjmp	.+10     	; 0xb848 <vfprintf+0x2f8>
    b83e:	8f ee       	ldi	r24, 0xEF	; 239
    b840:	f8 22       	and	r15, r24
    b842:	02 c0       	rjmp	.+4      	; 0xb848 <vfprintf+0x2f8>
    b844:	1d 2d       	mov	r17, r13
    b846:	01 c0       	rjmp	.+2      	; 0xb84a <vfprintf+0x2fa>
    b848:	19 2d       	mov	r17, r9
    b84a:	f4 fe       	sbrs	r15, 4
    b84c:	0d c0       	rjmp	.+26     	; 0xb868 <vfprintf+0x318>
    b84e:	fe 01       	movw	r30, r28
    b850:	ed 0d       	add	r30, r13
    b852:	f1 1d       	adc	r31, r1
    b854:	80 81       	ld	r24, Z
    b856:	80 33       	cpi	r24, 0x30	; 48
    b858:	19 f4       	brne	.+6      	; 0xb860 <vfprintf+0x310>
    b85a:	99 ee       	ldi	r25, 0xE9	; 233
    b85c:	f9 22       	and	r15, r25
    b85e:	08 c0       	rjmp	.+16     	; 0xb870 <vfprintf+0x320>
    b860:	1f 5f       	subi	r17, 0xFF	; 255
    b862:	f2 fe       	sbrs	r15, 2
    b864:	05 c0       	rjmp	.+10     	; 0xb870 <vfprintf+0x320>
    b866:	03 c0       	rjmp	.+6      	; 0xb86e <vfprintf+0x31e>
    b868:	8f 2d       	mov	r24, r15
    b86a:	86 78       	andi	r24, 0x86	; 134
    b86c:	09 f0       	breq	.+2      	; 0xb870 <vfprintf+0x320>
    b86e:	1f 5f       	subi	r17, 0xFF	; 255
    b870:	0f 2d       	mov	r16, r15
    b872:	f3 fc       	sbrc	r15, 3
    b874:	14 c0       	rjmp	.+40     	; 0xb89e <vfprintf+0x34e>
    b876:	f0 fe       	sbrs	r15, 0
    b878:	0f c0       	rjmp	.+30     	; 0xb898 <vfprintf+0x348>
    b87a:	1e 15       	cp	r17, r14
    b87c:	10 f0       	brcs	.+4      	; 0xb882 <vfprintf+0x332>
    b87e:	9d 2c       	mov	r9, r13
    b880:	0b c0       	rjmp	.+22     	; 0xb898 <vfprintf+0x348>
    b882:	9d 2c       	mov	r9, r13
    b884:	9e 0c       	add	r9, r14
    b886:	91 1a       	sub	r9, r17
    b888:	1e 2d       	mov	r17, r14
    b88a:	06 c0       	rjmp	.+12     	; 0xb898 <vfprintf+0x348>
    b88c:	80 e2       	ldi	r24, 0x20	; 32
    b88e:	90 e0       	ldi	r25, 0x00	; 0
    b890:	b3 01       	movw	r22, r6
    b892:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b896:	1f 5f       	subi	r17, 0xFF	; 255
    b898:	1e 15       	cp	r17, r14
    b89a:	c0 f3       	brcs	.-16     	; 0xb88c <vfprintf+0x33c>
    b89c:	04 c0       	rjmp	.+8      	; 0xb8a6 <vfprintf+0x356>
    b89e:	1e 15       	cp	r17, r14
    b8a0:	10 f4       	brcc	.+4      	; 0xb8a6 <vfprintf+0x356>
    b8a2:	e1 1a       	sub	r14, r17
    b8a4:	01 c0       	rjmp	.+2      	; 0xb8a8 <vfprintf+0x358>
    b8a6:	ee 24       	eor	r14, r14
    b8a8:	04 ff       	sbrs	r16, 4
    b8aa:	0f c0       	rjmp	.+30     	; 0xb8ca <vfprintf+0x37a>
    b8ac:	80 e3       	ldi	r24, 0x30	; 48
    b8ae:	90 e0       	ldi	r25, 0x00	; 0
    b8b0:	b3 01       	movw	r22, r6
    b8b2:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b8b6:	02 ff       	sbrs	r16, 2
    b8b8:	1d c0       	rjmp	.+58     	; 0xb8f4 <vfprintf+0x3a4>
    b8ba:	01 fd       	sbrc	r16, 1
    b8bc:	03 c0       	rjmp	.+6      	; 0xb8c4 <vfprintf+0x374>
    b8be:	88 e7       	ldi	r24, 0x78	; 120
    b8c0:	90 e0       	ldi	r25, 0x00	; 0
    b8c2:	0e c0       	rjmp	.+28     	; 0xb8e0 <vfprintf+0x390>
    b8c4:	88 e5       	ldi	r24, 0x58	; 88
    b8c6:	90 e0       	ldi	r25, 0x00	; 0
    b8c8:	0b c0       	rjmp	.+22     	; 0xb8e0 <vfprintf+0x390>
    b8ca:	80 2f       	mov	r24, r16
    b8cc:	86 78       	andi	r24, 0x86	; 134
    b8ce:	91 f0       	breq	.+36     	; 0xb8f4 <vfprintf+0x3a4>
    b8d0:	01 ff       	sbrs	r16, 1
    b8d2:	02 c0       	rjmp	.+4      	; 0xb8d8 <vfprintf+0x388>
    b8d4:	8b e2       	ldi	r24, 0x2B	; 43
    b8d6:	01 c0       	rjmp	.+2      	; 0xb8da <vfprintf+0x38a>
    b8d8:	80 e2       	ldi	r24, 0x20	; 32
    b8da:	f7 fc       	sbrc	r15, 7
    b8dc:	8d e2       	ldi	r24, 0x2D	; 45
    b8de:	90 e0       	ldi	r25, 0x00	; 0
    b8e0:	b3 01       	movw	r22, r6
    b8e2:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b8e6:	06 c0       	rjmp	.+12     	; 0xb8f4 <vfprintf+0x3a4>
    b8e8:	80 e3       	ldi	r24, 0x30	; 48
    b8ea:	90 e0       	ldi	r25, 0x00	; 0
    b8ec:	b3 01       	movw	r22, r6
    b8ee:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b8f2:	9a 94       	dec	r9
    b8f4:	d9 14       	cp	r13, r9
    b8f6:	c0 f3       	brcs	.-16     	; 0xb8e8 <vfprintf+0x398>
    b8f8:	da 94       	dec	r13
    b8fa:	f1 01       	movw	r30, r2
    b8fc:	ed 0d       	add	r30, r13
    b8fe:	f1 1d       	adc	r31, r1
    b900:	80 81       	ld	r24, Z
    b902:	90 e0       	ldi	r25, 0x00	; 0
    b904:	b3 01       	movw	r22, r6
    b906:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b90a:	dd 20       	and	r13, r13
    b90c:	a9 f7       	brne	.-22     	; 0xb8f8 <vfprintf+0x3a8>
    b90e:	06 c0       	rjmp	.+12     	; 0xb91c <vfprintf+0x3cc>
    b910:	80 e2       	ldi	r24, 0x20	; 32
    b912:	90 e0       	ldi	r25, 0x00	; 0
    b914:	b3 01       	movw	r22, r6
    b916:	0e 94 20 5a 	call	0xb440	; 0xb440 <fputc>
    b91a:	ea 94       	dec	r14
    b91c:	ee 20       	and	r14, r14
    b91e:	c1 f7       	brne	.-16     	; 0xb910 <vfprintf+0x3c0>
    b920:	43 ce       	rjmp	.-890    	; 0xb5a8 <vfprintf+0x58>
    b922:	f3 01       	movw	r30, r6
    b924:	66 81       	ldd	r22, Z+6	; 0x06
    b926:	77 81       	ldd	r23, Z+7	; 0x07
    b928:	cb 01       	movw	r24, r22
    b92a:	2b 96       	adiw	r28, 0x0b	; 11
    b92c:	0f b6       	in	r0, 0x3f	; 63
    b92e:	f8 94       	cli
    b930:	de bf       	out	0x3e, r29	; 62
    b932:	0f be       	out	0x3f, r0	; 63
    b934:	cd bf       	out	0x3d, r28	; 61
    b936:	cf 91       	pop	r28
    b938:	df 91       	pop	r29
    b93a:	1f 91       	pop	r17
    b93c:	0f 91       	pop	r16
    b93e:	ff 90       	pop	r15
    b940:	ef 90       	pop	r14
    b942:	df 90       	pop	r13
    b944:	cf 90       	pop	r12
    b946:	bf 90       	pop	r11
    b948:	af 90       	pop	r10
    b94a:	9f 90       	pop	r9
    b94c:	8f 90       	pop	r8
    b94e:	7f 90       	pop	r7
    b950:	6f 90       	pop	r6
    b952:	5f 90       	pop	r5
    b954:	4f 90       	pop	r4
    b956:	3f 90       	pop	r3
    b958:	2f 90       	pop	r2
    b95a:	08 95       	ret

0000b95c <__eerd_block_m128>:
    b95c:	dc 01       	movw	r26, r24
    b95e:	cb 01       	movw	r24, r22

0000b960 <__eerd_blraw_m128>:
    b960:	fc 01       	movw	r30, r24
    b962:	e1 99       	sbic	0x1c, 1	; 28
    b964:	fe cf       	rjmp	.-4      	; 0xb962 <__eerd_blraw_m128+0x2>
    b966:	06 c0       	rjmp	.+12     	; 0xb974 <__eerd_blraw_m128+0x14>
    b968:	ff bb       	out	0x1f, r31	; 31
    b96a:	ee bb       	out	0x1e, r30	; 30
    b96c:	e0 9a       	sbi	0x1c, 0	; 28
    b96e:	31 96       	adiw	r30, 0x01	; 1
    b970:	0d b2       	in	r0, 0x1d	; 29
    b972:	0d 92       	st	X+, r0
    b974:	41 50       	subi	r20, 0x01	; 1
    b976:	50 40       	sbci	r21, 0x00	; 0
    b978:	b8 f7       	brcc	.-18     	; 0xb968 <__eerd_blraw_m128+0x8>
    b97a:	08 95       	ret

0000b97c <__eerd_dword_m128>:
    b97c:	a6 e1       	ldi	r26, 0x16	; 22
    b97e:	b0 e0       	ldi	r27, 0x00	; 0
    b980:	44 e0       	ldi	r20, 0x04	; 4
    b982:	50 e0       	ldi	r21, 0x00	; 0
    b984:	0c 94 b0 5c 	jmp	0xb960	; 0xb960 <__eerd_blraw_m128>

0000b988 <__eerd_word_m128>:
    b988:	a8 e1       	ldi	r26, 0x18	; 24
    b98a:	b0 e0       	ldi	r27, 0x00	; 0
    b98c:	42 e0       	ldi	r20, 0x02	; 2
    b98e:	50 e0       	ldi	r21, 0x00	; 0
    b990:	0c 94 b0 5c 	jmp	0xb960	; 0xb960 <__eerd_blraw_m128>

0000b994 <__eeupd_block_m128>:
    b994:	dc 01       	movw	r26, r24
    b996:	a4 0f       	add	r26, r20
    b998:	b5 1f       	adc	r27, r21
    b99a:	41 50       	subi	r20, 0x01	; 1
    b99c:	50 40       	sbci	r21, 0x00	; 0
    b99e:	48 f0       	brcs	.+18     	; 0xb9b2 <__eeupd_block_m128+0x1e>
    b9a0:	cb 01       	movw	r24, r22
    b9a2:	84 0f       	add	r24, r20
    b9a4:	95 1f       	adc	r25, r21
    b9a6:	2e 91       	ld	r18, -X
    b9a8:	0e 94 db 5c 	call	0xb9b6	; 0xb9b6 <__eeupd_r18_m128>
    b9ac:	41 50       	subi	r20, 0x01	; 1
    b9ae:	50 40       	sbci	r21, 0x00	; 0
    b9b0:	d0 f7       	brcc	.-12     	; 0xb9a6 <__eeupd_block_m128+0x12>
    b9b2:	08 95       	ret

0000b9b4 <__eeupd_byte_m128>:
    b9b4:	26 2f       	mov	r18, r22

0000b9b6 <__eeupd_r18_m128>:
    b9b6:	e1 99       	sbic	0x1c, 1	; 28
    b9b8:	fe cf       	rjmp	.-4      	; 0xb9b6 <__eeupd_r18_m128>
    b9ba:	9f bb       	out	0x1f, r25	; 31
    b9bc:	8e bb       	out	0x1e, r24	; 30
    b9be:	e0 9a       	sbi	0x1c, 0	; 28
    b9c0:	01 97       	sbiw	r24, 0x01	; 1
    b9c2:	0d b2       	in	r0, 0x1d	; 29
    b9c4:	02 16       	cp	r0, r18
    b9c6:	31 f0       	breq	.+12     	; 0xb9d4 <__eeupd_r18_m128+0x1e>
    b9c8:	2d bb       	out	0x1d, r18	; 29
    b9ca:	0f b6       	in	r0, 0x3f	; 63
    b9cc:	f8 94       	cli
    b9ce:	e2 9a       	sbi	0x1c, 2	; 28
    b9d0:	e1 9a       	sbi	0x1c, 1	; 28
    b9d2:	0f be       	out	0x3f, r0	; 63
    b9d4:	08 95       	ret

0000b9d6 <__eeupd_dword_m128>:
    b9d6:	03 96       	adiw	r24, 0x03	; 3
    b9d8:	27 2f       	mov	r18, r23
    b9da:	0e 94 db 5c 	call	0xb9b6	; 0xb9b6 <__eeupd_r18_m128>
    b9de:	0e 94 da 5c 	call	0xb9b4	; 0xb9b4 <__eeupd_byte_m128>
    b9e2:	25 2f       	mov	r18, r21
    b9e4:	0e 94 db 5c 	call	0xb9b6	; 0xb9b6 <__eeupd_r18_m128>
    b9e8:	24 2f       	mov	r18, r20
    b9ea:	0c 94 db 5c 	jmp	0xb9b6	; 0xb9b6 <__eeupd_r18_m128>

0000b9ee <__eeupd_word_m128>:
    b9ee:	01 96       	adiw	r24, 0x01	; 1
    b9f0:	27 2f       	mov	r18, r23
    b9f2:	0e 94 db 5c 	call	0xb9b6	; 0xb9b6 <__eeupd_r18_m128>
    b9f6:	0c 94 da 5c 	jmp	0xb9b4	; 0xb9b4 <__eeupd_byte_m128>

0000b9fa <__ctype_isfalse>:
    b9fa:	99 27       	eor	r25, r25
    b9fc:	88 27       	eor	r24, r24

0000b9fe <__ctype_istrue>:
    b9fe:	08 95       	ret

0000ba00 <strnlen_P>:
    ba00:	fc 01       	movw	r30, r24
    ba02:	05 90       	lpm	r0, Z+
    ba04:	61 50       	subi	r22, 0x01	; 1
    ba06:	70 40       	sbci	r23, 0x00	; 0
    ba08:	01 10       	cpse	r0, r1
    ba0a:	d8 f7       	brcc	.-10     	; 0xba02 <strnlen_P+0x2>
    ba0c:	80 95       	com	r24
    ba0e:	90 95       	com	r25
    ba10:	8e 0f       	add	r24, r30
    ba12:	9f 1f       	adc	r25, r31
    ba14:	08 95       	ret

0000ba16 <strnlen>:
    ba16:	fc 01       	movw	r30, r24
    ba18:	61 50       	subi	r22, 0x01	; 1
    ba1a:	70 40       	sbci	r23, 0x00	; 0
    ba1c:	01 90       	ld	r0, Z+
    ba1e:	01 10       	cpse	r0, r1
    ba20:	d8 f7       	brcc	.-10     	; 0xba18 <strnlen+0x2>
    ba22:	80 95       	com	r24
    ba24:	90 95       	com	r25
    ba26:	8e 0f       	add	r24, r30
    ba28:	9f 1f       	adc	r25, r31
    ba2a:	08 95       	ret

0000ba2c <__ultoa_invert>:
    ba2c:	fa 01       	movw	r30, r20
    ba2e:	aa 27       	eor	r26, r26
    ba30:	28 30       	cpi	r18, 0x08	; 8
    ba32:	51 f1       	breq	.+84     	; 0xba88 <__ultoa_invert+0x5c>
    ba34:	20 31       	cpi	r18, 0x10	; 16
    ba36:	81 f1       	breq	.+96     	; 0xba98 <__ultoa_invert+0x6c>
    ba38:	e8 94       	clt
    ba3a:	6f 93       	push	r22
    ba3c:	6e 7f       	andi	r22, 0xFE	; 254
    ba3e:	6e 5f       	subi	r22, 0xFE	; 254
    ba40:	7f 4f       	sbci	r23, 0xFF	; 255
    ba42:	8f 4f       	sbci	r24, 0xFF	; 255
    ba44:	9f 4f       	sbci	r25, 0xFF	; 255
    ba46:	af 4f       	sbci	r26, 0xFF	; 255
    ba48:	b1 e0       	ldi	r27, 0x01	; 1
    ba4a:	3e d0       	rcall	.+124    	; 0xbac8 <__ultoa_invert+0x9c>
    ba4c:	b4 e0       	ldi	r27, 0x04	; 4
    ba4e:	3c d0       	rcall	.+120    	; 0xbac8 <__ultoa_invert+0x9c>
    ba50:	67 0f       	add	r22, r23
    ba52:	78 1f       	adc	r23, r24
    ba54:	89 1f       	adc	r24, r25
    ba56:	9a 1f       	adc	r25, r26
    ba58:	a1 1d       	adc	r26, r1
    ba5a:	68 0f       	add	r22, r24
    ba5c:	79 1f       	adc	r23, r25
    ba5e:	8a 1f       	adc	r24, r26
    ba60:	91 1d       	adc	r25, r1
    ba62:	a1 1d       	adc	r26, r1
    ba64:	6a 0f       	add	r22, r26
    ba66:	71 1d       	adc	r23, r1
    ba68:	81 1d       	adc	r24, r1
    ba6a:	91 1d       	adc	r25, r1
    ba6c:	a1 1d       	adc	r26, r1
    ba6e:	20 d0       	rcall	.+64     	; 0xbab0 <__ultoa_invert+0x84>
    ba70:	09 f4       	brne	.+2      	; 0xba74 <__ultoa_invert+0x48>
    ba72:	68 94       	set
    ba74:	3f 91       	pop	r19
    ba76:	2a e0       	ldi	r18, 0x0A	; 10
    ba78:	26 9f       	mul	r18, r22
    ba7a:	11 24       	eor	r1, r1
    ba7c:	30 19       	sub	r19, r0
    ba7e:	30 5d       	subi	r19, 0xD0	; 208
    ba80:	31 93       	st	Z+, r19
    ba82:	de f6       	brtc	.-74     	; 0xba3a <__ultoa_invert+0xe>
    ba84:	cf 01       	movw	r24, r30
    ba86:	08 95       	ret
    ba88:	46 2f       	mov	r20, r22
    ba8a:	47 70       	andi	r20, 0x07	; 7
    ba8c:	40 5d       	subi	r20, 0xD0	; 208
    ba8e:	41 93       	st	Z+, r20
    ba90:	b3 e0       	ldi	r27, 0x03	; 3
    ba92:	0f d0       	rcall	.+30     	; 0xbab2 <__ultoa_invert+0x86>
    ba94:	c9 f7       	brne	.-14     	; 0xba88 <__ultoa_invert+0x5c>
    ba96:	f6 cf       	rjmp	.-20     	; 0xba84 <__ultoa_invert+0x58>
    ba98:	46 2f       	mov	r20, r22
    ba9a:	4f 70       	andi	r20, 0x0F	; 15
    ba9c:	40 5d       	subi	r20, 0xD0	; 208
    ba9e:	4a 33       	cpi	r20, 0x3A	; 58
    baa0:	18 f0       	brcs	.+6      	; 0xbaa8 <__ultoa_invert+0x7c>
    baa2:	49 5d       	subi	r20, 0xD9	; 217
    baa4:	31 fd       	sbrc	r19, 1
    baa6:	40 52       	subi	r20, 0x20	; 32
    baa8:	41 93       	st	Z+, r20
    baaa:	02 d0       	rcall	.+4      	; 0xbab0 <__ultoa_invert+0x84>
    baac:	a9 f7       	brne	.-22     	; 0xba98 <__ultoa_invert+0x6c>
    baae:	ea cf       	rjmp	.-44     	; 0xba84 <__ultoa_invert+0x58>
    bab0:	b4 e0       	ldi	r27, 0x04	; 4
    bab2:	a6 95       	lsr	r26
    bab4:	97 95       	ror	r25
    bab6:	87 95       	ror	r24
    bab8:	77 95       	ror	r23
    baba:	67 95       	ror	r22
    babc:	ba 95       	dec	r27
    babe:	c9 f7       	brne	.-14     	; 0xbab2 <__ultoa_invert+0x86>
    bac0:	00 97       	sbiw	r24, 0x00	; 0
    bac2:	61 05       	cpc	r22, r1
    bac4:	71 05       	cpc	r23, r1
    bac6:	08 95       	ret
    bac8:	9b 01       	movw	r18, r22
    baca:	ac 01       	movw	r20, r24
    bacc:	0a 2e       	mov	r0, r26
    bace:	06 94       	lsr	r0
    bad0:	57 95       	ror	r21
    bad2:	47 95       	ror	r20
    bad4:	37 95       	ror	r19
    bad6:	27 95       	ror	r18
    bad8:	ba 95       	dec	r27
    bada:	c9 f7       	brne	.-14     	; 0xbace <__ultoa_invert+0xa2>
    badc:	62 0f       	add	r22, r18
    bade:	73 1f       	adc	r23, r19
    bae0:	84 1f       	adc	r24, r20
    bae2:	95 1f       	adc	r25, r21
    bae4:	a0 1d       	adc	r26, r0
    bae6:	08 95       	ret

0000bae8 <__mulsi3>:
    bae8:	62 9f       	mul	r22, r18
    baea:	d0 01       	movw	r26, r0
    baec:	73 9f       	mul	r23, r19
    baee:	f0 01       	movw	r30, r0
    baf0:	82 9f       	mul	r24, r18
    baf2:	e0 0d       	add	r30, r0
    baf4:	f1 1d       	adc	r31, r1
    baf6:	64 9f       	mul	r22, r20
    baf8:	e0 0d       	add	r30, r0
    bafa:	f1 1d       	adc	r31, r1
    bafc:	92 9f       	mul	r25, r18
    bafe:	f0 0d       	add	r31, r0
    bb00:	83 9f       	mul	r24, r19
    bb02:	f0 0d       	add	r31, r0
    bb04:	74 9f       	mul	r23, r20
    bb06:	f0 0d       	add	r31, r0
    bb08:	65 9f       	mul	r22, r21
    bb0a:	f0 0d       	add	r31, r0
    bb0c:	99 27       	eor	r25, r25
    bb0e:	72 9f       	mul	r23, r18
    bb10:	b0 0d       	add	r27, r0
    bb12:	e1 1d       	adc	r30, r1
    bb14:	f9 1f       	adc	r31, r25
    bb16:	63 9f       	mul	r22, r19
    bb18:	b0 0d       	add	r27, r0
    bb1a:	e1 1d       	adc	r30, r1
    bb1c:	f9 1f       	adc	r31, r25
    bb1e:	bd 01       	movw	r22, r26
    bb20:	cf 01       	movw	r24, r30
    bb22:	11 24       	eor	r1, r1
    bb24:	08 95       	ret

0000bb26 <__udivmodsi4>:
    bb26:	a1 e2       	ldi	r26, 0x21	; 33
    bb28:	1a 2e       	mov	r1, r26
    bb2a:	aa 1b       	sub	r26, r26
    bb2c:	bb 1b       	sub	r27, r27
    bb2e:	fd 01       	movw	r30, r26
    bb30:	0d c0       	rjmp	.+26     	; 0xbb4c <__udivmodsi4_ep>

0000bb32 <__udivmodsi4_loop>:
    bb32:	aa 1f       	adc	r26, r26
    bb34:	bb 1f       	adc	r27, r27
    bb36:	ee 1f       	adc	r30, r30
    bb38:	ff 1f       	adc	r31, r31
    bb3a:	a2 17       	cp	r26, r18
    bb3c:	b3 07       	cpc	r27, r19
    bb3e:	e4 07       	cpc	r30, r20
    bb40:	f5 07       	cpc	r31, r21
    bb42:	20 f0       	brcs	.+8      	; 0xbb4c <__udivmodsi4_ep>
    bb44:	a2 1b       	sub	r26, r18
    bb46:	b3 0b       	sbc	r27, r19
    bb48:	e4 0b       	sbc	r30, r20
    bb4a:	f5 0b       	sbc	r31, r21

0000bb4c <__udivmodsi4_ep>:
    bb4c:	66 1f       	adc	r22, r22
    bb4e:	77 1f       	adc	r23, r23
    bb50:	88 1f       	adc	r24, r24
    bb52:	99 1f       	adc	r25, r25
    bb54:	1a 94       	dec	r1
    bb56:	69 f7       	brne	.-38     	; 0xbb32 <__udivmodsi4_loop>
    bb58:	60 95       	com	r22
    bb5a:	70 95       	com	r23
    bb5c:	80 95       	com	r24
    bb5e:	90 95       	com	r25
    bb60:	9b 01       	movw	r18, r22
    bb62:	ac 01       	movw	r20, r24
    bb64:	bd 01       	movw	r22, r26
    bb66:	cf 01       	movw	r24, r30
    bb68:	08 95       	ret

0000bb6a <_exit>:
    bb6a:	f8 94       	cli

0000bb6c <__stop_program>:
    bb6c:	ff cf       	rjmp	.-2      	; 0xbb6c <__stop_program>
