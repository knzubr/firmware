   1               		.file	"vty.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 262               	enableFunction:
 263               		.stabd	46,0,0
   1:vty.c         **** #include "main.h"
   2:vty.c         **** #include "vty.h"
   3:vty.c         **** #include "ramdysk.h"
   4:vty.c         **** #include "protocol1.h"
   5:vty.c         **** #include "mpc23s17.h"
   6:vty.c         **** #include "mcp3008.h"
   7:vty.c         **** #include "ds1305.h"
   8:vty.c         **** #include "hardwareConfig.h"
   9:vty.c         **** #include "configuration.h"
  10:vty.c         **** #include "Rs485_prot.h"
  11:vty.c         **** #include "net.h"
  12:vty.c         **** #include "ip.h"
  13:vty.c         **** #include "arp.h"
  14:vty.c         **** #include "softwareConfig.h"
  15:vty.c         **** #include "mcp4150.h"
  16:vty.c         **** 
  17:vty.c         **** #if LANG_EN
  18:vty.c         **** #include "vty_en.h"
  19:vty.c         **** #endif
  20:vty.c         **** 
  21:vty.c         **** #if LANG_PL
  22:vty.c         **** #include "vty_pl.h"
  23:vty.c         **** #endif
  24:vty.c         **** 
  25:vty.c         **** #ifndef LANG_VTY
  26:vty.c         **** #error "Vty Language not defined"
  27:vty.c         **** #endif
  28:vty.c         **** 
  29:vty.c         **** 
  30:vty.c         **** static cliExRes_t helpFunction           (cmdState_t *state);
  31:vty.c         **** static cliExRes_t statusFunction         (cmdState_t *state);
  32:vty.c         **** static cliExRes_t statusEncFunction      (cmdState_t *state);
  33:vty.c         **** static cliExRes_t curtainDownFunction    (cmdState_t *state);
  34:vty.c         **** static cliExRes_t curtainUpFunction      (cmdState_t *state);
  35:vty.c         **** static cliExRes_t rpingFunction          (cmdState_t *state);
  36:vty.c         **** static cliExRes_t pingFunction           (cmdState_t *state);
  37:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state);
  38:vty.c         **** static cliExRes_t goXmodemWyslijFunction (cmdState_t *state);
  39:vty.c         **** static cliExRes_t dodajRamPlikFunction   (cmdState_t *state);
  40:vty.c         **** static cliExRes_t eraseRamFileFunction   (cmdState_t *state);
  41:vty.c         **** static cliExRes_t flashExModuleFunction  (cmdState_t *state);
  42:vty.c         **** static cliExRes_t writeRamFileFunction   (cmdState_t *state);
  43:vty.c         **** static cliExRes_t editRamFileFunction    (cmdState_t *state);
  44:vty.c         **** static cliExRes_t readRamFIleFunction    (cmdState_t *state);
  45:vty.c         **** 
  46:vty.c         **** static cliExRes_t ustawPortExtAFunction  (cmdState_t *state);
  47:vty.c         **** static cliExRes_t ustawPortExtBFunction  (cmdState_t *state);
  48:vty.c         **** static cliExRes_t ustawPortRezystor      (cmdState_t *state);
  49:vty.c         **** 
  50:vty.c         **** static cliExRes_t pokazCzasFunction      (cmdState_t *state);
  51:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state);
  52:vty.c         **** static cliExRes_t czytajAC_Function      (cmdState_t *state);
  53:vty.c         **** 
  54:vty.c         **** static cliExRes_t enableFunction         (cmdState_t *state);
  55:vty.c         **** static cliExRes_t disableFunction        (cmdState_t *state);
  56:vty.c         **** static cliExRes_t configureModeFunction  (cmdState_t *state);
  57:vty.c         **** 
  58:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state);
  59:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state);
  60:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state);
  61:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state);
  62:vty.c         **** 
  63:vty.c         **** static cliExRes_t setMacAddrFunction     (cmdState_t *state);
  64:vty.c         **** static cliExRes_t setTimeFunction        (cmdState_t *state);
  65:vty.c         **** 
  66:vty.c         **** static cliExRes_t saveConfigFunction     (cmdState_t *state);
  67:vty.c         **** 
  68:vty.c         **** #ifdef testZewPamiec
  69:vty.c         **** static cliExRes_t testPamZewFunction     (cmdState_t *state);
  70:vty.c         **** #endif
  71:vty.c         **** 
  72:vty.c         **** struct ramPlikFd    fdVty;  //TODO move it to CLI struct
  73:vty.c         **** 
  74:vty.c         **** prog_char okStr[] = "OK\r\n";
  75:vty.c         **** prog_char nlStr[] = "\r\n";
  76:vty.c         **** prog_char BladBuforaPozostaloBajtowStr[]           = "!!! W budorze Rs485 pozostalo %d bajtow\r\n";
  77:vty.c         **** 
  78:vty.c         **** 
  79:vty.c         **** prog_char __ATTR_PROGMEM__ *errorStrings[] = {
  80:vty.c         ****   errorOK,
  81:vty.c         ****   errorNoFile,
  82:vty.c         ****   errorxModemFrameStartTimeout,
  83:vty.c         ****   errorxModemByteSendTimeout,
  84:vty.c         ****   errorxModemWrongFrameNo,
  85:vty.c         ****   errorxModemFrameFrameNoCorrectionNotMatch,
  86:vty.c         ****   errorxModemFrameCrc,
  87:vty.c         ****   errorxModemRemoteSideCan,
  88:vty.c         ****   errorxModemUnknownResponse,
  89:vty.c         ****   errorNoRemoteDevice,
  90:vty.c         ****   errorBootloaderNotResponding,
  91:vty.c         ****   errorOpenFile
  92:vty.c         **** };
  93:vty.c         **** 
  94:vty.c         **** command_t __ATTR_PROGMEM__ cmdListNormal[] =
  95:vty.c         **** {
  96:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
  97:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
  98:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},  
  99:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 100:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 101:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 102:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 103:vty.c         ****   {cmd_enable,    cmd_help_enable,    enableFunction},
 104:vty.c         ****   {NULL, NULL, NULL}
 105:vty.c         **** };
 106:vty.c         **** 
 107:vty.c         **** command_t __ATTR_PROGMEM__ cmdListEnable[] =
 108:vty.c         **** {
 109:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
 110:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
 111:vty.c         ****   {cmd_enc_stat,  cmd_help_enc_stat,  statusEncFunction},
 112:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},
 113:vty.c         ****   {cmd_net_dbg,   cmd_help_net_dbg,   debugFunction},
 114:vty.c         ****   
 115:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 116:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 117:vty.c         ****   {cmd_xRec,      cmd_help_xRec,      goXmodemOdbierzFunction},
 118:vty.c         ****   {cmd_xSend,     cmd_help_xSend,     goXmodemWyslijFunction},
 119:vty.c         ****   {cmd_xflash,    cmd_help_xflash,    flashExModuleFunction},
 120:vty.c         **** #ifdef testZewPamiec
 121:vty.c         ****   {cmd_rtest,     cmd_help_rtest,     testPamZewFunction},
 122:vty.c         **** #endif
 123:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 124:vty.c         ****   {cmd_create_rf, cmd_help_create_rf, dodajRamPlikFunction},
 125:vty.c         ****   {cmd_erase_rf,  cmd_help_erase_rf,  eraseRamFileFunction},
 126:vty.c         ****   {cmd_edit_rf,   cmd_help_edit_rf,   editRamFileFunction},
 127:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 128:vty.c         **** 
 129:vty.c         ****   {cmd_up,        cmd_help_up,        curtainUpFunction},
 130:vty.c         ****   {cmd_down,      cmd_help_down,      curtainDownFunction},
 131:vty.c         **** 
 132:vty.c         ****   {cmd_spa,       cmd_help_spa,       ustawPortExtAFunction},
 133:vty.c         ****   {cmd_spb,       cmd_help_spb,       ustawPortExtBFunction},
 134:vty.c         ****   {cmd_ustawR,    cmd_help_ustawR,    ustawPortRezystor},
 135:vty.c         ****   {cmd_settime,   cmd_help_settime,   setTimeFunction},
 136:vty.c         ****   {cmd_ac,        cmd_help_ac,        czytajAC_Function},
 137:vty.c         ****   {cmd_disable,   cmd_help_disable,   disableFunction},
 138:vty.c         ****   {cmd_configure, cmd_help_configure, configureModeFunction},
 139:vty.c         ****   {NULL, NULL, NULL}
 140:vty.c         **** };
 141:vty.c         **** 
 142:vty.c         **** command_t __ATTR_PROGMEM__ cmdListConfigure[] =
 143:vty.c         **** {
 144:vty.c         ****   {cmd_help,         cmd_help_help,         helpFunction},
 145:vty.c         ****   {cmd_status,       cmd_help_status,       statusFunction},
 146:vty.c         ****   {cmd_time,         cmd_help_time,         pokazCzasFunction},
 147:vty.c         ****   {cmd_settime,      cmd_help_settime,      setTimeFunction},
 148:vty.c         ****   {cmd_conf_ip,      cmd_help_conf_ip,      setIpFunction},
 149:vty.c         ****   {cmd_conf_ip_mask, cmd_conf_ip_mask_help, setIpMaskFunction},
 150:vty.c         ****   {cmd_conf_ip_gw,   cmd_conf_ip_gw_help,   setIpGwFunction},
 151:vty.c         ****   {cmd_conf_udp,     cmd_help_conf_udp,     setUdpFunction},
 152:vty.c         ****   {cmd_conf_mac,     cmd_help_conf_mac,     setMacAddrFunction},
 153:vty.c         ****   {cmd_conf_save,    cmd_help_conf_save,    saveConfigFunction},
 154:vty.c         ****   {cmd_enable,       cmd_help_enable,       enableFunction},
 155:vty.c         ****   {cmd_disable,      cmd_help_disable,      disableFunction},
 156:vty.c         ****   {NULL, NULL, NULL}
 157:vty.c         **** };
 158:vty.c         **** 
 159:vty.c         **** void VtyInit(cmdState_t* state, FILE *stream)
 160:vty.c         **** {
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 162:vty.c         **** }
 163:vty.c         **** 
 164:vty.c         **** void printErrorInfo(cmdState_t *state)
 165:vty.c         **** {
 166:vty.c         ****   if (state->errno != 0)
 167:vty.c         ****   {
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 169:vty.c         ****   }
 170:vty.c         ****   state->errno = 0;
 171:vty.c         ****   state->err1 = 0;
 172:vty.c         ****   state->err2 = 0;
 173:vty.c         **** }
 174:vty.c         **** 
 175:vty.c         **** static cliExRes_t enableFunction(cmdState_t *state)
 176:vty.c         **** {
 265               	.LM0:
 266               	.LFBB1:
 267               	/* prologue: function */
 268               	/* frame size = 0 */
 269 0000 FC01      		movw r30,r24
 177:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 271               	.LM1:
 272 0002 80A1      		ldd r24,Z+32
 273 0004 8330      		cpi r24,lo8(3)
 274 0006 01F4      		brne .L2
 275 0008 25E0      		ldi r18,lo8(5)
 276 000a 30E0      		ldi r19,hi8(5)
 277 000c 00C0      		rjmp .L3
 278               	.L2:
 178:vty.c         ****   {
 179:vty.c         ****     state->cmdList = cmdListEnable;
 280               	.LM2:
 281 000e 80E0      		ldi r24,lo8(cmdListEnable)
 282 0010 90E0      		ldi r25,hi8(cmdListEnable)
 283 0012 92A3      		std Z+34,r25
 284 0014 81A3      		std Z+33,r24
 180:vty.c         ****     state->cliMode = NR_ENABLE;
 286               	.LM3:
 287 0016 81E0      		ldi r24,lo8(1)
 288 0018 80A3      		std Z+32,r24
 289 001a 20E0      		ldi r18,lo8(0)
 290 001c 30E0      		ldi r19,hi8(0)
 291               	.L3:
 181:vty.c         ****     return OK_SILENT;
 182:vty.c         ****   }
 183:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 184:vty.c         **** }
 293               	.LM4:
 294 001e C901      		movw r24,r18
 295               	/* epilogue start */
 296 0020 0895      		ret
 298               	.Lscope1:
 300               		.stabd	78,0,0
 304               	disableFunction:
 305               		.stabd	46,0,0
 185:vty.c         **** static cliExRes_t disableFunction(cmdState_t *state)
 186:vty.c         **** {
 307               	.LM5:
 308               	.LFBB2:
 309               	/* prologue: function */
 310               	/* frame size = 0 */
 311 0022 FC01      		movw r30,r24
 187:vty.c         ****   state->cmdList = cmdListNormal;
 313               	.LM6:
 314 0024 80E0      		ldi r24,lo8(cmdListNormal)
 315 0026 90E0      		ldi r25,hi8(cmdListNormal)
 316 0028 92A3      		std Z+34,r25
 317 002a 81A3      		std Z+33,r24
 188:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 319               	.LM7:
 320 002c 80A1      		ldd r24,Z+32
 321 002e 8330      		cpi r24,lo8(3)
 322 0030 01F0      		breq .L6
 189:vty.c         ****   {
 190:vty.c         ****     state->cliMode = NR_NORMAL;
 324               	.LM8:
 325 0032 10A2      		std Z+32,__zero_reg__
 326               	.L6:
 191:vty.c         ****   }
 192:vty.c         ****   return OK_SILENT;
 193:vty.c         **** }
 328               	.LM9:
 329 0034 80E0      		ldi r24,lo8(0)
 330 0036 90E0      		ldi r25,hi8(0)
 331               	/* epilogue start */
 332 0038 0895      		ret
 334               	.Lscope2:
 336               		.stabd	78,0,0
 340               	configureModeFunction:
 341               		.stabd	46,0,0
 194:vty.c         **** static cliExRes_t configureModeFunction(cmdState_t *state)
 195:vty.c         **** {
 343               	.LM10:
 344               	.LFBB3:
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347 003a FC01      		movw r30,r24
 196:vty.c         ****   if (state->cliMode == NR_ENABLE)
 349               	.LM11:
 350 003c 80A1      		ldd r24,Z+32
 351 003e 8130      		cpi r24,lo8(1)
 352 0040 01F0      		breq .L9
 353 0042 25E0      		ldi r18,lo8(5)
 354 0044 30E0      		ldi r19,hi8(5)
 355 0046 00C0      		rjmp .L10
 356               	.L9:
 197:vty.c         ****   {
 198:vty.c         ****     state->cmdList = cmdListConfigure;
 358               	.LM12:
 359 0048 80E0      		ldi r24,lo8(cmdListConfigure)
 360 004a 90E0      		ldi r25,hi8(cmdListConfigure)
 361 004c 92A3      		std Z+34,r25
 362 004e 81A3      		std Z+33,r24
 199:vty.c         ****     state->cliMode = NR_CONFIGURE;
 364               	.LM13:
 365 0050 82E0      		ldi r24,lo8(2)
 366 0052 80A3      		std Z+32,r24
 367 0054 20E0      		ldi r18,lo8(0)
 368 0056 30E0      		ldi r19,hi8(0)
 369               	.L10:
 200:vty.c         ****     return OK_SILENT;
 201:vty.c         ****   }
 202:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 203:vty.c         **** }
 371               	.LM14:
 372 0058 C901      		movw r24,r18
 373               	/* epilogue start */
 374 005a 0895      		ret
 376               	.Lscope3:
 378               		.stabd	78,0,0
 382               	saveConfigFunction:
 383               		.stabd	46,0,0
 204:vty.c         **** 
 205:vty.c         **** // ************************** VTY API *************************************************************
 206:vty.c         **** void printStatus(FILE *stream)
 207:vty.c         **** {
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 209:vty.c         ****   //Print system state
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 216:vty.c         **** 
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 219:vty.c         **** //  printErrorInfo(state); //TODO fix and uncomment
 220:vty.c         ****   
 221:vty.c         ****   //Print system configuration
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 223:vty.c         **** 
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 227:vty.c         ****   
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 231:vty.c         **** 
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 235:vty.c         ****   
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 239:vty.c         ****   
 240:vty.c         ****   //Print Rs485 Execitive modules
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 242:vty.c         ****   tmp = printRs485devices(stream);
 243:vty.c         ****   if (tmp == 0)
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 245:vty.c         ****   
 246:vty.c         ****   //Print locker sensors
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 248:vty.c         ****   tmp = printLockers(stream);
 249:vty.c         ****   if (tmp == 0)
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 251:vty.c         ****   
 252:vty.c         ****   //Print time FIXME deadlock problem
 253:vty.c         **** /*  readTimeDecoded((timeDecoded_t *)(&czasRtc));
 254:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 255:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 256:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 257:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/
 258:vty.c         **** 
 259:vty.c         ****   udpPrintStatus(stream);
 260:vty.c         **** //  arpPrintTable(stream);
 261:vty.c         **** }
 262:vty.c         **** 
 263:vty.c         **** 
 264:vty.c         **** // ************************** CLI Functions *******************************************************
 265:vty.c         **** 
 266:vty.c         **** static cliExRes_t statusFunction(cmdState_t *state)
 267:vty.c         **** {
 268:vty.c         ****   if (state->argc < 1)
 269:vty.c         ****   {
 270:vty.c         ****     printStatus(state->myStdInOut);
 271:vty.c         ****     return OK_SILENT; 
 272:vty.c         ****   }
 273:vty.c         ****   
 274:vty.c         ****   FILE stream;
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 276:vty.c         ****   {
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 278:vty.c         ****     return ERROR_INFORM;
 279:vty.c         ****   }
 280:vty.c         **** 
 281:vty.c         ****   printStatus(&stream);
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 283:vty.c         ****   return OK_SILENT; 
 284:vty.c         **** }
 285:vty.c         **** 
 286:vty.c         **** static cliExRes_t statusEncFunction(cmdState_t *state)
 287:vty.c         **** {
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 289:vty.c         ****   return OK_SILENT;
 290:vty.c         **** }
 291:vty.c         **** 
 292:vty.c         **** static cliExRes_t pokazCzasFunction(cmdState_t *state)
 293:vty.c         **** {
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 299:vty.c         ****   return OK_SILENT;
 300:vty.c         **** }
 301:vty.c         **** 
 302:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state)
 303:vty.c         **** {
 304:vty.c         ****   if (state->argc < 2)
 305:vty.c         ****     return SYNTAX_ERROR;
 306:vty.c         **** 
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 309:vty.c         ****   if (level == 0)
 310:vty.c         ****   {
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 312:vty.c         ****     {
 313:vty.c         ****       setArpDebug(NULL, 0);
 314:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 315:vty.c         ****       return OK_SILENT;  
 316:vty.c         ****     }    
 317:vty.c         **** 
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 319:vty.c         ****     {
 320:vty.c         ****       setIpDebug(NULL, 0);
 321:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 322:vty.c         ****       return OK_SILENT;  
 323:vty.c         ****     }    
 324:vty.c         **** 
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 326:vty.c         ****     {
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 328:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 329:vty.c         ****       return OK_SILENT;  
 330:vty.c         ****     }    
 331:vty.c         **** 
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 333:vty.c         ****     {
 334:vty.c         ****       setTcpDebug(NULL, 0);
 335:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 336:vty.c         ****       return OK_SILENT;  
 337:vty.c         ****     }    
 338:vty.c         **** 
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 340:vty.c         ****     {
 341:vty.c         ****       setUdpDebug(NULL, 0);
 342:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 343:vty.c         ****       return OK_SILENT;  
 344:vty.c         ****     }    
 345:vty.c         **** 
 346:vty.c         **** 
 347:vty.c         ****   }
 348:vty.c         ****   else                   //level > 0
 349:vty.c         ****   {
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 351:vty.c         ****     {
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 353:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 354:vty.c         ****       return OK_SILENT;  
 355:vty.c         ****     }   
 356:vty.c         ****     
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 358:vty.c         ****     {
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 360:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 361:vty.c         ****       return OK_SILENT;  
 362:vty.c         ****     }
 363:vty.c         **** 
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 365:vty.c         ****     {
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 367:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 368:vty.c         ****       return OK_SILENT;  
 369:vty.c         ****     }
 370:vty.c         **** 
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 372:vty.c         ****     {
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 374:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 375:vty.c         ****       return OK_SILENT;  
 376:vty.c         ****     }
 377:vty.c         ****     
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 379:vty.c         ****     {
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 381:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 382:vty.c         ****       return OK_SILENT;  
 383:vty.c         ****     }
 384:vty.c         ****   }
 385:vty.c         ****   
 386:vty.c         ****   return SYNTAX_ERROR;
 387:vty.c         **** }
 388:vty.c         **** 
 389:vty.c         **** 
 390:vty.c         **** static cliExRes_t setTimeFunction(cmdState_t *state)
 391:vty.c         **** {
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 395:vty.c         ****   
 396:vty.c         ****   ds1305start();
 397:vty.c         **** 
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 399:vty.c         ****   uint8_t cJedn = godzina - cDzies*10;
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 402:vty.c         ****   
 403:vty.c         ****   cDzies = minuta/10;
 404:vty.c         ****   cJedn = minuta - cDzies * 10;
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 407:vty.c         ****   
 408:vty.c         ****   cDzies = sekunda/10;
 409:vty.c         ****   cJedn  = sekunda - cDzies * 10;
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 412:vty.c         ****   
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 414:vty.c         ****   return OK_SILENT;
 415:vty.c         **** }
 416:vty.c         **** 
 417:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state)
 418:vty.c         **** {
 419:vty.c         ****   if (state->argc < 4)
 420:vty.c         ****     return SYNTAX_ERROR;
 421:vty.c         ****   
 422:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 423:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 424:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 426:vty.c         ****   
 427:vty.c         ****   ipSetConfigIp(ip);
 428:vty.c         ****   return OK_SILENT;
 429:vty.c         **** }
 430:vty.c         **** 
 431:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state)
 432:vty.c         **** {
 433:vty.c         ****   if (state->argc < 5)
 434:vty.c         ****     return SYNTAX_ERROR;
 435:vty.c         ****   
 436:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 437:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 438:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 440:vty.c         ****   udpSocket->dstIp = ip;
 441:vty.c         ****   
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 444:vty.c         ****   
 445:vty.c         ****   if (state->argc > 5)
 446:vty.c         ****   {
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 449:vty.c         ****   }
 450:vty.c         ****   return OK_SILENT;
 451:vty.c         **** }
 452:vty.c         **** 
 453:vty.c         **** 
 454:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state)
 455:vty.c         **** {
 456:vty.c         ****   if (state->argc < 1)
 457:vty.c         ****     return SYNTAX_ERROR;
 458:vty.c         ****   
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 460:vty.c         ****   
 461:vty.c         ****   ipSetConfigMask(mask);
 462:vty.c         ****   return OK_SILENT;
 463:vty.c         **** }
 464:vty.c         **** 
 465:vty.c         **** 
 466:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state)
 467:vty.c         **** {
 468:vty.c         ****   if (state->argc < 4)
 469:vty.c         ****     return SYNTAX_ERROR;
 470:vty.c         ****   
 471:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) + 
 472:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 473:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 475:vty.c         ****   ipSetConfigGw(gw);
 476:vty.c         ****   return OK_SILENT;
 477:vty.c         **** }
 478:vty.c         **** 
 479:vty.c         **** static cliExRes_t setMacAddrFunction(cmdState_t *state)
 480:vty.c         **** {
 481:vty.c         ****   if (state->argc < 6)
 482:vty.c         ****     return SYNTAX_ERROR;  
 483:vty.c         ****   
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 491:vty.c         ****   return OK_SILENT;
 492:vty.c         **** }
 493:vty.c         **** 
 494:vty.c         **** static cliExRes_t czytajAC_Function(cmdState_t *state)
 495:vty.c         **** {
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 499:vty.c         ****   return OK_SILENT;
 500:vty.c         **** }
 501:vty.c         **** 
 502:vty.c         **** static cliExRes_t helpFunction(cmdState_t *state)
 503:vty.c         **** {
 504:vty.c         ****   cmdPrintHelp(state);
 505:vty.c         ****   return OK_SILENT;
 506:vty.c         **** }
 507:vty.c         **** 
 508:vty.c         **** static cliExRes_t curtainDownFunction(cmdState_t *state)
 509:vty.c         **** {
 510:vty.c         ****   uint8_t nrRolety;
 511:vty.c         ****   uint8_t nrSterownika;
 512:vty.c         ****   uint8_t wartosc;
 513:vty.c         ****   
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 516:vty.c         ****   nrRolety &= 0x01;
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 518:vty.c         **** 
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 520:vty.c         **** 
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 523:vty.c         **** 
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 525:vty.c         ****   
 526:vty.c         ****   if (result == 0)
 527:vty.c         ****     return OK_INFORM;
 528:vty.c         ****   
 529:vty.c         ****   return ERROR_SILENT;
 530:vty.c         **** }
 531:vty.c         **** 
 532:vty.c         **** static cliExRes_t curtainUpFunction(cmdState_t *state)
 533:vty.c         **** {
 534:vty.c         ****   if (state->argc < 2)
 535:vty.c         ****     return SYNTAX_ERROR;
 536:vty.c         ****   
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 539:vty.c         ****   uint8_t wartosc = 255;
 540:vty.c         ****   if (state->argc > 2)
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 542:vty.c         **** 
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 546:vty.c         **** 
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 548:vty.c         ****   
 549:vty.c         ****   if (result == 0)
 550:vty.c         ****     return OK_INFORM;
 551:vty.c         ****   
 552:vty.c         ****   return ERROR_SILENT;
 553:vty.c         **** }
 554:vty.c         **** 
 555:vty.c         **** static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
 556:vty.c         **** {
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 560:vty.c         ****   return OK_SILENT;
 561:vty.c         **** }
 562:vty.c         **** 
 563:vty.c         **** static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
 564:vty.c         **** {
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 568:vty.c         ****   return OK_SILENT;
 569:vty.c         **** }
 570:vty.c         **** 
 571:vty.c         **** static cliExRes_t ustawPortRezystor(cmdState_t *state)
 572:vty.c         **** {
 573:vty.c         ****   if (state->argc < 1)
 574:vty.c         ****     return SYNTAX_ERROR;
 575:vty.c         **** 
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 577:vty.c         ****   
 578:vty.c         ****   MCP4150_setValue(wartosc);
 579:vty.c         ****   
 580:vty.c         ****   return OK_SILENT;
 581:vty.c         **** }
 582:vty.c         **** 
 583:vty.c         **** static cliExRes_t rpingFunction(cmdState_t *state)
 584:vty.c         **** {
 585:vty.c         ****   if (state->argc < 1)
 586:vty.c         ****     return SYNTAX_ERROR;
 587:vty.c         ****   
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 590:vty.c         ****     return OK_INFORM;
 591:vty.c         **** 
 592:vty.c         ****   state->errno = noRemoteDevice;
 593:vty.c         ****   state->err1 = nrSterownika;
 594:vty.c         ****   printErrorInfo(state);
 595:vty.c         ****   return OK_SILENT;
 596:vty.c         **** }
 597:vty.c         **** 
 598:vty.c         **** static cliExRes_t pingFunction(cmdState_t *state)
 599:vty.c         **** {
 600:vty.c         ****   if (state->argc < 4)
 601:vty.c         ****     return SYNTAX_ERROR;
 602:vty.c         ****   
 603:vty.c         ****   uint8_t ip[4];
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 608:vty.c         **** 
 609:vty.c         **** //  Ipv4Ping(*((uint32_t *)(ip)));
 610:vty.c         ****   
 611:vty.c         ****   return OK_SILENT;
 612:vty.c         **** }
 613:vty.c         **** 
 614:vty.c         **** 
 615:vty.c         **** static cliExRes_t flashExModuleFunction(cmdState_t *state)
 616:vty.c         **** {
 617:vty.c         ****   if (state->argc != 2)
 618:vty.c         ****     return SYNTAX_ERROR;
 619:vty.c         ****   
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 622:vty.c         ****   uint8_t  blad;
 623:vty.c         ****   
 624:vty.c         ****   // Sprawdzanie, czy moduł wykonawczy odpowiada
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 626:vty.c         ****   {
 627:vty.c         ****     state->errno = noRemoteDevice;
 628:vty.c         ****     printErrorInfo(state);
 629:vty.c         ****     return ERROR_INFORM;
 630:vty.c         ****   }
 631:vty.c         ****   
 632:vty.c         ****   //Sprawdzanie, czy istnieje odpowiedni plik z firmware
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 634:vty.c         ****   {
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 636:vty.c         ****     return ERROR_INFORM;
 637:vty.c         ****   }
 638:vty.c         ****   
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 640:vty.c         **** 
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 642:vty.c         ****   
 643:vty.c         ****   if (blad != 0)
 644:vty.c         ****     return ERROR_INFORM;
 645:vty.c         **** 
 646:vty.c         ****   return OK_SILENT;
 647:vty.c         **** }
 648:vty.c         **** 
 649:vty.c         **** static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
 650:vty.c         **** {
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 653:vty.c         ****   {
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 655:vty.c         ****     return ERROR_INFORM;
 656:vty.c         ****   }
 657:vty.c         ****   return OK_SILENT;
 658:vty.c         **** }
 659:vty.c         **** 
 660:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
 661:vty.c         **** {
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 664:vty.c         ****   {
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 666:vty.c         ****     return ERROR_INFORM;
 667:vty.c         ****   }
 668:vty.c         ****    
 669:vty.c         ****   uint8_t  i = 25;
 670:vty.c         **** 
 671:vty.c         ****   uint8_t  temp1;
 672:vty.c         **** //  uint8_t  temp2;
 673:vty.c         **** 
 674:vty.c         ****   uint8_t  c;
 675:vty.c         ****   uint8_t  liczbaProb;
 676:vty.c         ****   uint8_t  *zapPtr;
 677:vty.c         ****   uint8_t  *zapPtrKopia;
 678:vty.c         ****  
 679:vty.c         ****   uint16_t crcLokalne;
 680:vty.c         ****   uint8_t nrBloku;
 681:vty.c         **** 
 682:vty.c         ****   uint8_t nrBlokuZdalny;
 683:vty.c         ****   uint8_t nrBlokuZdalnyNeg;
 684:vty.c         **** 
 685:vty.c         ****   uint8_t crcHi;
 686:vty.c         ****   uint8_t crcLo;
 687:vty.c         **** 
 688:vty.c         ****   state->err1=0;
 689:vty.c         ****   state->err2=0;
 690:vty.c         ****   liczbaProb = 20;
 691:vty.c         ****   for ( ; ; )
 692:vty.c         ****   {
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 694:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 695:vty.c         **** 
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 697:vty.c         ****       if (c == SOH)
 698:vty.c         ****         break;                                                   //Rozpoczynamy transmisje
 699:vty.c         **** 
 700:vty.c         ****     liczbaProb--;
 701:vty.c         ****     if (liczbaProb == 0)
 702:vty.c         ****     {
 703:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 704:vty.c         ****       state->errno = (uint8_t)(AllOK);
 705:vty.c         ****       return ERROR_INFORM;
 706:vty.c         ****     }
 707:vty.c         ****   }
 708:vty.c         ****   
 709:vty.c         ****   nrBloku = 1;
 710:vty.c         ****   liczbaProb = 10;
 711:vty.c         **** 
 712:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 713:vty.c         ****   zapPtrKopia     = zapPtr;
 714:vty.c         ****   for ( ; ; )
 715:vty.c         ****   {
 716:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 717:vty.c         ****     {
 718:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 719:vty.c         ****       break; 
 720:vty.c         ****     }
 721:vty.c         ****     
 722:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 723:vty.c         ****     {
 724:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 725:vty.c         ****       break; 
 726:vty.c         ****     }
 727:vty.c         ****   
 728:vty.c         ****     //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
 729:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 730:vty.c         ****     if (nrBlokuZdalny != c)
 731:vty.c         ****     {
 732:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 733:vty.c         ****       state->err1 = nrBlokuZdalny;
 734:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 735:vty.c         ****       break;
 736:vty.c         ****     }
 737:vty.c         ****     
 738:vty.c         ****     //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od b
 739:vty.c         ****     c = nrBloku-1;
 740:vty.c         ****     if (nrBlokuZdalny == c)
 741:vty.c         ****     {
 742:vty.c         ****       nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
 743:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 744:vty.c         ****       zapPtrKopia = zapPtr;
 745:vty.c         ****     }
 746:vty.c         ****     
 747:vty.c         ****     //2 Sprawdzanie, czy pasuje numer bloku
 748:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 749:vty.c         ****     {
 750:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 751:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 752:vty.c         ****       state->err2 = nrBloku;
 753:vty.c         ****       break;
 754:vty.c         ****     }
 755:vty.c         ****         
 756:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 757:vty.c         ****     {
 758:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 759:vty.c         ****         *(zapPtr++) = c;
 760:vty.c         ****       else
 761:vty.c         ****       {
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 763:vty.c         ****         break;
 764:vty.c         ****       }
 765:vty.c         ****     }
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 767:vty.c         ****     {
 768:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 769:vty.c         ****         state->err1 = 2;
 770:vty.c         ****         break;      
 771:vty.c         ****     }
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 773:vty.c         ****     {
 774:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 775:vty.c         ****         state->err1 = 1;
 776:vty.c         ****         break;      
 777:vty.c         ****     }
 778:vty.c         **** 
 779:vty.c         ****     //3 Zerowanie CRC
 780:vty.c         ****     crcLokalne=0; 
 781:vty.c         ****     
 782:vty.c         ****     //4 Obliczanie CRC
 783:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 784:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 785:vty.c         ****      
 786:vty.c         ****     //5 Srawdzanie CRC
 787:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 788:vty.c         ****     {
 789:vty.c         ****       liczbaProb = 10;
 790:vty.c         ****       uartVtySendByte(ACK);      
 791:vty.c         ****     }
 792:vty.c         ****     else
 793:vty.c         ****     {
 794:vty.c         ****       liczbaProb--;
 795:vty.c         ****       nrBloku--;
 796:vty.c         ****       uartVtySendByte(NAK);   
 797:vty.c         ****     }
 798:vty.c         ****     
 799:vty.c         ****     if (liczbaProb == 0)
 800:vty.c         ****     {
 801:vty.c         ****       state->err1 = nrBlokuZdalny;
 802:vty.c         ****       state->err2 = nrBloku;
 803:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 804:vty.c         ****       break; 
 805:vty.c         ****     }
 806:vty.c         **** 
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 808:vty.c         ****     {
 809:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 810:vty.c         ****       break;
 811:vty.c         ****     }
 812:vty.c         ****     
 813:vty.c         ****     if (temp1 == SOH)
 814:vty.c         ****     {
 815:vty.c         ****       nrBloku++;
 816:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 817:vty.c         ****       zapPtrKopia = zapPtr;
 818:vty.c         ****       state->errno = (uint8_t)(AllOK);
 819:vty.c         ****       continue;
 820:vty.c         ****     }
 821:vty.c         **** 
 822:vty.c         ****     if (temp1 == CAN)
 823:vty.c         ****     {
 824:vty.c         ****       state->err1 = nrBloku;
 825:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 826:vty.c         ****       break;
 827:vty.c         ****     }
 828:vty.c         ****     if (temp1 == EOT)
 829:vty.c         ****     {
 830:vty.c         ****       uartVtySendByte(NAK);
 831:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 832:vty.c         ****       {
 833:vty.c         ****         if (temp1 == EOT)
 834:vty.c         ****           uartVtySendByte(ACK);  
 835:vty.c         ****       }
 836:vty.c         ****       state->errno = (uint8_t)(AllOK);
 837:vty.c         ****       break;
 838:vty.c         ****     }
 839:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 840:vty.c         ****     state->err1 = temp1;
 841:vty.c         ****     break;
 842:vty.c         ****   }
 843:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 844:vty.c         ****   return OK_SILENT;
 845:vty.c         **** }
 846:vty.c         **** 
 847:vty.c         **** static cliExRes_t eraseRamFileFunction(cmdState_t *state)
 848:vty.c         **** {
 849:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 850:vty.c         ****     return OK_INFORM;
 851:vty.c         **** 
 852:vty.c         ****   printErrorInfo(state);
 853:vty.c         ****   return ERROR_INFORM;
 854:vty.c         **** }
 855:vty.c         **** 
 856:vty.c         **** static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
 857:vty.c         **** {
 858:vty.c         ****   if (state->argc != 1)
 859:vty.c         ****     return SYNTAX_ERROR;
 860:vty.c         **** 
 861:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 862:vty.c         ****   {
 863:vty.c         ****     return OK_INFORM;
 864:vty.c         ****   }
 865:vty.c         ****   printErrorInfo(state);
 866:vty.c         ****   return ERROR_INFORM;
 867:vty.c         **** }
 868:vty.c         **** 
 869:vty.c         **** static cliExRes_t writeRamFileFunction(cmdState_t *state)
 870:vty.c         **** {
 871:vty.c         ****   ramDyskDir(state->myStdInOut);
 872:vty.c         ****   return OK_SILENT;
 873:vty.c         **** }
 874:vty.c         **** 
 875:vty.c         **** static cliExRes_t editRamFileFunction(cmdState_t *state)
 876:vty.c         **** {
 877:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 878:vty.c         ****   {
 879:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 880:vty.c         ****     return ERROR_INFORM;
 881:vty.c         ****   }
 882:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 883:vty.c         ****   uint8_t znak = 0;
 884:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 885:vty.c         ****   while(1)
 886:vty.c         ****   {
 887:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 888:vty.c         ****       continue;
 889:vty.c         **** 
 890:vty.c         ****     if (znak == 0x03)                                       // ^C
 891:vty.c         ****       break;
 892:vty.c         **** 
 893:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 894:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 895:vty.c         ****   }
 896:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 897:vty.c         ****   return OK_SILENT;
 898:vty.c         **** }
 899:vty.c         **** 
 900:vty.c         **** static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
 901:vty.c         **** {
 902:vty.c         ****   uint8_t rezultat;
 903:vty.c         ****   uint8_t znak = ' ';
 904:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 905:vty.c         ****   {
 906:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 907:vty.c         ****     return ERROR_INFORM;
 908:vty.c         ****   }
 909:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 910:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 911:vty.c         ****   while (rezultat == 0)
 912:vty.c         ****   {
 913:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 914:vty.c         ****     
 915:vty.c         ****     uartVtySendByte(znak);
 916:vty.c         ****     if (znak == '\r')
 917:vty.c         ****       uartVtySendByte('\n');
 918:vty.c         ****   }
 919:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 920:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 921:vty.c         ****   return OK_SILENT;
 922:vty.c         **** }
 923:vty.c         **** 
 924:vty.c         **** static cliExRes_t saveConfigFunction(cmdState_t *state)
 925:vty.c         **** {
 385               	.LM15:
 386               	.LFBB4:
 387               	/* prologue: function */
 388               	/* frame size = 0 */
 926:vty.c         ****   state = NULL;
 927:vty.c         ****   saveConfiguration();
 390               	.LM16:
 391 005c 0E94 0000 		call saveConfiguration
 928:vty.c         ****   return OK_SILENT;
 929:vty.c         **** }
 393               	.LM17:
 394 0060 80E0      		ldi r24,lo8(0)
 395 0062 90E0      		ldi r25,hi8(0)
 396               	/* epilogue start */
 397 0064 0895      		ret
 399               	.Lscope4:
 401               		.stabd	78,0,0
 405               	setMacAddrFunction:
 406               		.stabd	46,0,0
 480:vty.c         **** {
 408               	.LM18:
 409               	.LFBB5:
 410 0066 CF93      		push r28
 411 0068 DF93      		push r29
 412               	/* prologue: function */
 413               	/* frame size = 0 */
 414 006a EC01      		movw r28,r24
 481:vty.c         ****   if (state->argc < 6)
 416               	.LM19:
 417 006c 898D      		ldd r24,Y+25
 418 006e 8630      		cpi r24,lo8(6)
 419 0070 00F4      		brsh .L15
 420 0072 22E0      		ldi r18,lo8(2)
 421 0074 30E0      		ldi r19,hi8(2)
 422 0076 00C0      		rjmp .L16
 423               	.L15:
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 425               	.LM20:
 426 0078 81E0      		ldi r24,lo8(1)
 427 007a BE01      		movw r22,r28
 428 007c 0E94 0000 		call cmdlineGetArgHex
 429 0080 6093 0000 		sts nicState+2,r22
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 431               	.LM21:
 432 0084 82E0      		ldi r24,lo8(2)
 433 0086 BE01      		movw r22,r28
 434 0088 0E94 0000 		call cmdlineGetArgHex
 435 008c 6093 0000 		sts nicState+3,r22
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 437               	.LM22:
 438 0090 83E0      		ldi r24,lo8(3)
 439 0092 BE01      		movw r22,r28
 440 0094 0E94 0000 		call cmdlineGetArgHex
 441 0098 6093 0000 		sts nicState+4,r22
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 443               	.LM23:
 444 009c 84E0      		ldi r24,lo8(4)
 445 009e BE01      		movw r22,r28
 446 00a0 0E94 0000 		call cmdlineGetArgHex
 447 00a4 6093 0000 		sts nicState+5,r22
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 449               	.LM24:
 450 00a8 85E0      		ldi r24,lo8(5)
 451 00aa BE01      		movw r22,r28
 452 00ac 0E94 0000 		call cmdlineGetArgHex
 453 00b0 6093 0000 		sts nicState+6,r22
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 455               	.LM25:
 456 00b4 86E0      		ldi r24,lo8(6)
 457 00b6 BE01      		movw r22,r28
 458 00b8 0E94 0000 		call cmdlineGetArgHex
 459 00bc 6093 0000 		sts nicState+7,r22
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 461               	.LM26:
 462 00c0 80E0      		ldi r24,lo8(nicState+2)
 463 00c2 90E0      		ldi r25,hi8(nicState+2)
 464 00c4 0E94 0000 		call nicSetMacAddress
 465 00c8 20E0      		ldi r18,lo8(0)
 466 00ca 30E0      		ldi r19,hi8(0)
 467               	.L16:
 492:vty.c         **** }
 469               	.LM27:
 470 00cc C901      		movw r24,r18
 471               	/* epilogue start */
 472 00ce DF91      		pop r29
 473 00d0 CF91      		pop r28
 474 00d2 0895      		ret
 476               	.Lscope5:
 478               		.stabd	78,0,0
 482               	pingFunction:
 483               		.stabd	46,0,0
 599:vty.c         **** {
 485               	.LM28:
 486               	.LFBB6:
 487 00d4 CF93      		push r28
 488 00d6 DF93      		push r29
 489               	/* prologue: function */
 490               	/* frame size = 0 */
 491 00d8 EC01      		movw r28,r24
 600:vty.c         ****   if (state->argc < 4)
 493               	.LM29:
 494 00da 898D      		ldd r24,Y+25
 495 00dc 8430      		cpi r24,lo8(4)
 496 00de 00F4      		brsh .L19
 497 00e0 22E0      		ldi r18,lo8(2)
 498 00e2 30E0      		ldi r19,hi8(2)
 499 00e4 00C0      		rjmp .L20
 500               	.L19:
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 502               	.LM30:
 503 00e6 81E0      		ldi r24,lo8(1)
 504 00e8 BE01      		movw r22,r28
 505 00ea 0E94 0000 		call cmdlineGetArgInt
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 507               	.LM31:
 508 00ee 82E0      		ldi r24,lo8(2)
 509 00f0 BE01      		movw r22,r28
 510 00f2 0E94 0000 		call cmdlineGetArgInt
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 512               	.LM32:
 513 00f6 83E0      		ldi r24,lo8(3)
 514 00f8 BE01      		movw r22,r28
 515 00fa 0E94 0000 		call cmdlineGetArgInt
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 517               	.LM33:
 518 00fe 84E0      		ldi r24,lo8(4)
 519 0100 BE01      		movw r22,r28
 520 0102 0E94 0000 		call cmdlineGetArgInt
 521 0106 20E0      		ldi r18,lo8(0)
 522 0108 30E0      		ldi r19,hi8(0)
 523               	.L20:
 612:vty.c         **** }
 525               	.LM34:
 526 010a C901      		movw r24,r18
 527               	/* epilogue start */
 528 010c DF91      		pop r29
 529 010e CF91      		pop r28
 530 0110 0895      		ret
 532               	.Lscope6:
 534               		.stabd	78,0,0
 538               	setUdpFunction:
 539               		.stabd	46,0,0
 432:vty.c         **** {
 541               	.LM35:
 542               	.LFBB7:
 543 0112 6F92      		push r6
 544 0114 7F92      		push r7
 545 0116 8F92      		push r8
 546 0118 9F92      		push r9
 547 011a AF92      		push r10
 548 011c BF92      		push r11
 549 011e CF92      		push r12
 550 0120 DF92      		push r13
 551 0122 EF92      		push r14
 552 0124 FF92      		push r15
 553 0126 0F93      		push r16
 554 0128 1F93      		push r17
 555 012a CF93      		push r28
 556 012c DF93      		push r29
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559 012e EC01      		movw r28,r24
 433:vty.c         ****   if (state->argc < 5)
 561               	.LM36:
 562 0130 898D      		ldd r24,Y+25
 563 0132 8530      		cpi r24,lo8(5)
 564 0134 00F4      		brsh .L23
 565 0136 22E0      		ldi r18,lo8(2)
 566 0138 30E0      		ldi r19,hi8(2)
 567 013a 00C0      		rjmp .L24
 568               	.L23:
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 570               	.LM37:
 571 013c 81E0      		ldi r24,lo8(1)
 572 013e BE01      		movw r22,r28
 573 0140 0E94 0000 		call cmdlineGetArgInt
 574 0144 3B01      		movw r6,r22
 575 0146 4C01      		movw r8,r24
 576 0148 82E0      		ldi r24,lo8(2)
 577 014a BE01      		movw r22,r28
 578 014c 0E94 0000 		call cmdlineGetArgInt
 579 0150 7B01      		movw r14,r22
 580 0152 8C01      		movw r16,r24
 581 0154 83E0      		ldi r24,lo8(3)
 582 0156 BE01      		movw r22,r28
 583 0158 0E94 0000 		call cmdlineGetArgInt
 584 015c 5B01      		movw r10,r22
 585 015e 6C01      		movw r12,r24
 586 0160 84E0      		ldi r24,lo8(4)
 587 0162 BE01      		movw r22,r28
 588 0164 0E94 0000 		call cmdlineGetArgInt
 440:vty.c         ****   udpSocket->dstIp = ip;
 590               	.LM38:
 591 0168 E091 0000 		lds r30,udpSocket
 592 016c F091 0000 		lds r31,(udpSocket)+1
 593 0170 102F      		mov r17,r16
 594 0172 0F2D      		mov r16,r15
 595 0174 FE2C      		mov r15,r14
 596 0176 EE24      		clr r14
 597 0178 6501      		movw r12,r10
 598 017a BB24      		clr r11
 599 017c AA24      		clr r10
 600 017e EA0C      		add r14,r10
 601 0180 FB1C      		adc r15,r11
 602 0182 0C1D      		adc r16,r12
 603 0184 1D1D      		adc r17,r13
 604 0186 E60C      		add r14,r6
 605 0188 F71C      		adc r15,r7
 606 018a 081D      		adc r16,r8
 607 018c 191D      		adc r17,r9
 608 018e 962F      		mov r25,r22
 609 0190 8827      		clr r24
 610 0192 7727      		clr r23
 611 0194 6627      		clr r22
 612 0196 E60E      		add r14,r22
 613 0198 F71E      		adc r15,r23
 614 019a 081F      		adc r16,r24
 615 019c 191F      		adc r17,r25
 616 019e E682      		std Z+6,r14
 617 01a0 F782      		std Z+7,r15
 618 01a2 0087      		std Z+8,r16
 619 01a4 1187      		std Z+9,r17
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 621               	.LM39:
 622 01a6 85E0      		ldi r24,lo8(5)
 623 01a8 BE01      		movw r22,r28
 624 01aa 0E94 0000 		call cmdlineGetArgInt
 625 01ae DC01      		movw r26,r24
 626 01b0 CB01      		movw r24,r22
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 628               	.LM40:
 629 01b2 0091 0000 		lds r16,udpSocket
 630 01b6 1091 0000 		lds r17,(udpSocket)+1
 631 01ba 0E94 0000 		call htons
 632 01be F801      		movw r30,r16
 633 01c0 9583      		std Z+5,r25
 634 01c2 8483      		std Z+4,r24
 445:vty.c         ****   if (state->argc > 5)
 636               	.LM41:
 637 01c4 898D      		ldd r24,Y+25
 638 01c6 8630      		cpi r24,lo8(6)
 639 01c8 00F0      		brlo .L27
 640               	.L25:
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 642               	.LM42:
 643 01ca 86E0      		ldi r24,lo8(6)
 644 01cc BE01      		movw r22,r28
 645 01ce 0E94 0000 		call cmdlineGetArgInt
 646 01d2 DC01      		movw r26,r24
 647 01d4 CB01      		movw r24,r22
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 649               	.LM43:
 650 01d6 0091 0000 		lds r16,udpSocket
 651 01da 1091 0000 		lds r17,(udpSocket)+1
 652 01de 0E94 0000 		call htons
 653 01e2 F801      		movw r30,r16
 654 01e4 9383      		std Z+3,r25
 655 01e6 8283      		std Z+2,r24
 656               	.L27:
 657 01e8 20E0      		ldi r18,lo8(0)
 658 01ea 30E0      		ldi r19,hi8(0)
 659               	.L24:
 451:vty.c         **** }
 661               	.LM44:
 662 01ec C901      		movw r24,r18
 663               	/* epilogue start */
 664 01ee DF91      		pop r29
 665 01f0 CF91      		pop r28
 666 01f2 1F91      		pop r17
 667 01f4 0F91      		pop r16
 668 01f6 FF90      		pop r15
 669 01f8 EF90      		pop r14
 670 01fa DF90      		pop r13
 671 01fc CF90      		pop r12
 672 01fe BF90      		pop r11
 673 0200 AF90      		pop r10
 674 0202 9F90      		pop r9
 675 0204 8F90      		pop r8
 676 0206 7F90      		pop r7
 677 0208 6F90      		pop r6
 678 020a 0895      		ret
 680               	.Lscope7:
 682               		.stabd	78,0,0
 686               	setIpGwFunction:
 687               		.stabd	46,0,0
 467:vty.c         **** {
 689               	.LM45:
 690               	.LFBB8:
 691 020c 6F92      		push r6
 692 020e 7F92      		push r7
 693 0210 8F92      		push r8
 694 0212 9F92      		push r9
 695 0214 AF92      		push r10
 696 0216 BF92      		push r11
 697 0218 CF92      		push r12
 698 021a DF92      		push r13
 699 021c EF92      		push r14
 700 021e FF92      		push r15
 701 0220 0F93      		push r16
 702 0222 1F93      		push r17
 703 0224 CF93      		push r28
 704 0226 DF93      		push r29
 705               	/* prologue: function */
 706               	/* frame size = 0 */
 707 0228 EC01      		movw r28,r24
 468:vty.c         ****   if (state->argc < 4)
 709               	.LM46:
 710 022a 898D      		ldd r24,Y+25
 711 022c 8430      		cpi r24,lo8(4)
 712 022e 00F4      		brsh .L29
 713 0230 22E0      		ldi r18,lo8(2)
 714 0232 30E0      		ldi r19,hi8(2)
 715 0234 00C0      		rjmp .L30
 716               	.L29:
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 718               	.LM47:
 719 0236 81E0      		ldi r24,lo8(1)
 720 0238 BE01      		movw r22,r28
 721 023a 0E94 0000 		call cmdlineGetArgInt
 722 023e 3B01      		movw r6,r22
 723 0240 4C01      		movw r8,r24
 724 0242 82E0      		ldi r24,lo8(2)
 725 0244 BE01      		movw r22,r28
 726 0246 0E94 0000 		call cmdlineGetArgInt
 727 024a 7B01      		movw r14,r22
 728 024c 8C01      		movw r16,r24
 729 024e 83E0      		ldi r24,lo8(3)
 730 0250 BE01      		movw r22,r28
 731 0252 0E94 0000 		call cmdlineGetArgInt
 732 0256 5B01      		movw r10,r22
 733 0258 6C01      		movw r12,r24
 734 025a 84E0      		ldi r24,lo8(4)
 735 025c BE01      		movw r22,r28
 736 025e 0E94 0000 		call cmdlineGetArgInt
 475:vty.c         ****   ipSetConfigGw(gw);
 738               	.LM48:
 739 0262 102F      		mov r17,r16
 740 0264 0F2D      		mov r16,r15
 741 0266 FE2C      		mov r15,r14
 742 0268 EE24      		clr r14
 743 026a 6501      		movw r12,r10
 744 026c BB24      		clr r11
 745 026e AA24      		clr r10
 746 0270 EA0C      		add r14,r10
 747 0272 FB1C      		adc r15,r11
 748 0274 0C1D      		adc r16,r12
 749 0276 1D1D      		adc r17,r13
 750 0278 E60C      		add r14,r6
 751 027a F71C      		adc r15,r7
 752 027c 081D      		adc r16,r8
 753 027e 191D      		adc r17,r9
 754 0280 962F      		mov r25,r22
 755 0282 8827      		clr r24
 756 0284 7727      		clr r23
 757 0286 6627      		clr r22
 758 0288 E60E      		add r14,r22
 759 028a F71E      		adc r15,r23
 760 028c 081F      		adc r16,r24
 761 028e 191F      		adc r17,r25
 762 0290 C801      		movw r24,r16
 763 0292 B701      		movw r22,r14
 764 0294 0E94 0000 		call ipSetConfigGw
 765 0298 20E0      		ldi r18,lo8(0)
 766 029a 30E0      		ldi r19,hi8(0)
 767               	.L30:
 477:vty.c         **** }
 769               	.LM49:
 770 029c C901      		movw r24,r18
 771               	/* epilogue start */
 772 029e DF91      		pop r29
 773 02a0 CF91      		pop r28
 774 02a2 1F91      		pop r17
 775 02a4 0F91      		pop r16
 776 02a6 FF90      		pop r15
 777 02a8 EF90      		pop r14
 778 02aa DF90      		pop r13
 779 02ac CF90      		pop r12
 780 02ae BF90      		pop r11
 781 02b0 AF90      		pop r10
 782 02b2 9F90      		pop r9
 783 02b4 8F90      		pop r8
 784 02b6 7F90      		pop r7
 785 02b8 6F90      		pop r6
 786 02ba 0895      		ret
 788               	.Lscope8:
 790               		.stabd	78,0,0
 794               	setIpMaskFunction:
 795               		.stabd	46,0,0
 455:vty.c         **** {
 797               	.LM50:
 798               	.LFBB9:
 799               	/* prologue: function */
 800               	/* frame size = 0 */
 801 02bc FC01      		movw r30,r24
 456:vty.c         ****   if (state->argc < 1)
 803               	.LM51:
 804 02be 818D      		ldd r24,Z+25
 805 02c0 8823      		tst r24
 806 02c2 01F4      		brne .L33
 807 02c4 22E0      		ldi r18,lo8(2)
 808 02c6 30E0      		ldi r19,hi8(2)
 809 02c8 00C0      		rjmp .L34
 810               	.L33:
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 812               	.LM52:
 813 02ca 81E0      		ldi r24,lo8(1)
 814 02cc BF01      		movw r22,r30
 815 02ce 0E94 0000 		call cmdlineGetArgInt
 461:vty.c         ****   ipSetConfigMask(mask);
 817               	.LM53:
 818 02d2 20E2      		ldi r18,lo8(32)
 819 02d4 30E0      		ldi r19,hi8(32)
 820 02d6 261B      		sub r18,r22
 821 02d8 370B      		sbc r19,r23
 822 02da 6FEF      		ldi r22,lo8(-1)
 823 02dc 7FEF      		ldi r23,hi8(-1)
 824 02de 8FEF      		ldi r24,hlo8(-1)
 825 02e0 9FEF      		ldi r25,hhi8(-1)
 826 02e2 00C0      		rjmp 2f
 827 02e4 9695      	1:	lsr r25
 828 02e6 8795      		ror r24
 829 02e8 7795      		ror r23
 830 02ea 6795      		ror r22
 831 02ec 2A95      	2:	dec r18
 832 02ee 02F4      		brpl 1b
 833 02f0 0E94 0000 		call ipSetConfigMask
 834 02f4 20E0      		ldi r18,lo8(0)
 835 02f6 30E0      		ldi r19,hi8(0)
 836               	.L34:
 463:vty.c         **** }
 838               	.LM54:
 839 02f8 C901      		movw r24,r18
 840               	/* epilogue start */
 841 02fa 0895      		ret
 843               	.Lscope9:
 845               		.stabd	78,0,0
 849               	setIpFunction:
 850               		.stabd	46,0,0
 418:vty.c         **** {
 852               	.LM55:
 853               	.LFBB10:
 854 02fc 6F92      		push r6
 855 02fe 7F92      		push r7
 856 0300 8F92      		push r8
 857 0302 9F92      		push r9
 858 0304 AF92      		push r10
 859 0306 BF92      		push r11
 860 0308 CF92      		push r12
 861 030a DF92      		push r13
 862 030c EF92      		push r14
 863 030e FF92      		push r15
 864 0310 0F93      		push r16
 865 0312 1F93      		push r17
 866 0314 CF93      		push r28
 867 0316 DF93      		push r29
 868               	/* prologue: function */
 869               	/* frame size = 0 */
 870 0318 EC01      		movw r28,r24
 419:vty.c         ****   if (state->argc < 4)
 872               	.LM56:
 873 031a 898D      		ldd r24,Y+25
 874 031c 8430      		cpi r24,lo8(4)
 875 031e 00F4      		brsh .L37
 876 0320 22E0      		ldi r18,lo8(2)
 877 0322 30E0      		ldi r19,hi8(2)
 878 0324 00C0      		rjmp .L38
 879               	.L37:
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 881               	.LM57:
 882 0326 81E0      		ldi r24,lo8(1)
 883 0328 BE01      		movw r22,r28
 884 032a 0E94 0000 		call cmdlineGetArgInt
 885 032e 3B01      		movw r6,r22
 886 0330 4C01      		movw r8,r24
 887 0332 82E0      		ldi r24,lo8(2)
 888 0334 BE01      		movw r22,r28
 889 0336 0E94 0000 		call cmdlineGetArgInt
 890 033a 7B01      		movw r14,r22
 891 033c 8C01      		movw r16,r24
 892 033e 83E0      		ldi r24,lo8(3)
 893 0340 BE01      		movw r22,r28
 894 0342 0E94 0000 		call cmdlineGetArgInt
 895 0346 5B01      		movw r10,r22
 896 0348 6C01      		movw r12,r24
 897 034a 84E0      		ldi r24,lo8(4)
 898 034c BE01      		movw r22,r28
 899 034e 0E94 0000 		call cmdlineGetArgInt
 427:vty.c         ****   ipSetConfigIp(ip);
 901               	.LM58:
 902 0352 102F      		mov r17,r16
 903 0354 0F2D      		mov r16,r15
 904 0356 FE2C      		mov r15,r14
 905 0358 EE24      		clr r14
 906 035a 6501      		movw r12,r10
 907 035c BB24      		clr r11
 908 035e AA24      		clr r10
 909 0360 EA0C      		add r14,r10
 910 0362 FB1C      		adc r15,r11
 911 0364 0C1D      		adc r16,r12
 912 0366 1D1D      		adc r17,r13
 913 0368 E60C      		add r14,r6
 914 036a F71C      		adc r15,r7
 915 036c 081D      		adc r16,r8
 916 036e 191D      		adc r17,r9
 917 0370 962F      		mov r25,r22
 918 0372 8827      		clr r24
 919 0374 7727      		clr r23
 920 0376 6627      		clr r22
 921 0378 E60E      		add r14,r22
 922 037a F71E      		adc r15,r23
 923 037c 081F      		adc r16,r24
 924 037e 191F      		adc r17,r25
 925 0380 C801      		movw r24,r16
 926 0382 B701      		movw r22,r14
 927 0384 0E94 0000 		call ipSetConfigIp
 928 0388 20E0      		ldi r18,lo8(0)
 929 038a 30E0      		ldi r19,hi8(0)
 930               	.L38:
 429:vty.c         **** }
 932               	.LM59:
 933 038c C901      		movw r24,r18
 934               	/* epilogue start */
 935 038e DF91      		pop r29
 936 0390 CF91      		pop r28
 937 0392 1F91      		pop r17
 938 0394 0F91      		pop r16
 939 0396 FF90      		pop r15
 940 0398 EF90      		pop r14
 941 039a DF90      		pop r13
 942 039c CF90      		pop r12
 943 039e BF90      		pop r11
 944 03a0 AF90      		pop r10
 945 03a2 9F90      		pop r9
 946 03a4 8F90      		pop r8
 947 03a6 7F90      		pop r7
 948 03a8 6F90      		pop r6
 949 03aa 0895      		ret
 951               	.Lscope10:
 953               		.stabd	78,0,0
 957               	czytajAC_Function:
 958               		.stabd	46,0,0
 495:vty.c         **** {
 960               	.LM60:
 961               	.LFBB11:
 962 03ac FF92      		push r15
 963 03ae 0F93      		push r16
 964 03b0 1F93      		push r17
 965               	/* prologue: function */
 966               	/* frame size = 0 */
 967 03b2 8C01      		movw r16,r24
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 969               	.LM61:
 970 03b4 81E0      		ldi r24,lo8(1)
 971 03b6 B801      		movw r22,r16
 972 03b8 0E94 0000 		call cmdlineGetArgInt
 973 03bc F62E      		mov r15,r22
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 975               	.LM62:
 976 03be 862F      		mov r24,r22
 977 03c0 0E94 0000 		call MCP3008_getSampleSingle
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 979               	.LM63:
 980 03c4 2DB7      		in r18,__SP_L__
 981 03c6 3EB7      		in r19,__SP_H__
 982 03c8 2850      		subi r18,lo8(-(-8))
 983 03ca 3040      		sbci r19,hi8(-(-8))
 984 03cc 0FB6      		in __tmp_reg__,__SREG__
 985 03ce F894      		cli
 986 03d0 3EBF      		out __SP_H__,r19
 987 03d2 0FBE      		out __SREG__,__tmp_reg__
 988 03d4 2DBF      		out __SP_L__,r18
 989 03d6 EDB7      		in r30,__SP_L__
 990 03d8 FEB7      		in r31,__SP_H__
 991 03da 3196      		adiw r30,1
 992 03dc D801      		movw r26,r16
 993 03de 5A96      		adiw r26,26
 994 03e0 2D91      		ld r18,X+
 995 03e2 3C91      		ld r19,X
 996 03e4 5B97      		sbiw r26,26+1
 997 03e6 ADB7      		in r26,__SP_L__
 998 03e8 BEB7      		in r27,__SP_H__
 999 03ea 1296      		adiw r26,1+1
 1000 03ec 3C93      		st X,r19
 1001 03ee 2E93      		st -X,r18
 1002 03f0 1197      		sbiw r26,1
 1003 03f2 20E0      		ldi r18,lo8(__c.3459)
 1004 03f4 30E0      		ldi r19,hi8(__c.3459)
 1005 03f6 3383      		std Z+3,r19
 1006 03f8 2283      		std Z+2,r18
 1007 03fa F482      		std Z+4,r15
 1008 03fc 1582      		std Z+5,__zero_reg__
 1009 03fe 9783      		std Z+7,r25
 1010 0400 8683      		std Z+6,r24
 1011 0402 0E94 0000 		call fprintf_P
 1012 0406 2DB7      		in r18,__SP_L__
 1013 0408 3EB7      		in r19,__SP_H__
 1014 040a 285F      		subi r18,lo8(-(8))
 1015 040c 3F4F      		sbci r19,hi8(-(8))
 1016 040e 0FB6      		in __tmp_reg__,__SREG__
 1017 0410 F894      		cli
 1018 0412 3EBF      		out __SP_H__,r19
 1019 0414 0FBE      		out __SREG__,__tmp_reg__
 1020 0416 2DBF      		out __SP_L__,r18
 500:vty.c         **** }
 1022               	.LM64:
 1023 0418 80E0      		ldi r24,lo8(0)
 1024 041a 90E0      		ldi r25,hi8(0)
 1025               	/* epilogue start */
 1026 041c 1F91      		pop r17
 1027 041e 0F91      		pop r16
 1028 0420 FF90      		pop r15
 1029 0422 0895      		ret
 1031               	.Lscope11:
 1033               		.stabd	78,0,0
 1036               	.global	printErrorInfo
 1038               	printErrorInfo:
 1039               		.stabd	46,0,0
 165:vty.c         **** {
 1041               	.LM65:
 1042               	.LFBB12:
 1043 0424 CF93      		push r28
 1044 0426 DF93      		push r29
 1045               	/* prologue: function */
 1046               	/* frame size = 0 */
 1047 0428 EC01      		movw r28,r24
 166:vty.c         ****   if (state->errno != 0)
 1049               	.LM66:
 1050 042a 8C8D      		ldd r24,Y+28
 1051 042c 8823      		tst r24
 1052 042e 01F0      		breq .L43
 1053               	.LBB5:
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 1055               	.LM67:
 1056 0430 E82F      		mov r30,r24
 1057 0432 F0E0      		ldi r31,lo8(0)
 1058 0434 EE0F      		lsl r30
 1059 0436 FF1F      		rol r31
 1060 0438 E050      		subi r30,lo8(-(errorStrings))
 1061 043a F040      		sbci r31,hi8(-(errorStrings))
 1062               	/* #APP */
 1063               	 ;  168 "vty.c" 1
 1064 043c 2591      		lpm r18, Z+
 1065 043e 3491      		lpm r19, Z
 1066               		
 1067               	 ;  0 "" 2
 1068               	/* #NOAPP */
 1069               	.LBE5:
 1070 0440 8DB7      		in r24,__SP_L__
 1071 0442 9EB7      		in r25,__SP_H__
 1072 0444 0897      		sbiw r24,8
 1073 0446 0FB6      		in __tmp_reg__,__SREG__
 1074 0448 F894      		cli
 1075 044a 9EBF      		out __SP_H__,r25
 1076 044c 0FBE      		out __SREG__,__tmp_reg__
 1077 044e 8DBF      		out __SP_L__,r24
 1078 0450 EDB7      		in r30,__SP_L__
 1079 0452 FEB7      		in r31,__SP_H__
 1080 0454 3196      		adiw r30,1
 1081 0456 8A8D      		ldd r24,Y+26
 1082 0458 9B8D      		ldd r25,Y+27
 1083 045a ADB7      		in r26,__SP_L__
 1084 045c BEB7      		in r27,__SP_H__
 1085 045e 1296      		adiw r26,1+1
 1086 0460 9C93      		st X,r25
 1087 0462 8E93      		st -X,r24
 1088 0464 1197      		sbiw r26,1
 1089 0466 3383      		std Z+3,r19
 1090 0468 2283      		std Z+2,r18
 1091 046a 8D8D      		ldd r24,Y+29
 1092 046c 9E8D      		ldd r25,Y+30
 1093 046e 9583      		std Z+5,r25
 1094 0470 8483      		std Z+4,r24
 1095 0472 8F8D      		ldd r24,Y+31
 1096 0474 8683      		std Z+6,r24
 1097 0476 1782      		std Z+7,__zero_reg__
 1098 0478 0E94 0000 		call fprintf_P
 1099 047c 8DB7      		in r24,__SP_L__
 1100 047e 9EB7      		in r25,__SP_H__
 1101 0480 0896      		adiw r24,8
 1102 0482 0FB6      		in __tmp_reg__,__SREG__
 1103 0484 F894      		cli
 1104 0486 9EBF      		out __SP_H__,r25
 1105 0488 0FBE      		out __SREG__,__tmp_reg__
 1106 048a 8DBF      		out __SP_L__,r24
 1107               	.L43:
 170:vty.c         ****   state->errno = 0;
 1109               	.LM68:
 1110 048c 1C8E      		std Y+28,__zero_reg__
 171:vty.c         ****   state->err1 = 0;
 1112               	.LM69:
 1113 048e 1E8E      		std Y+30,__zero_reg__
 1114 0490 1D8E      		std Y+29,__zero_reg__
 172:vty.c         ****   state->err2 = 0;
 1116               	.LM70:
 1117 0492 1F8E      		std Y+31,__zero_reg__
 1118               	/* epilogue start */
 173:vty.c         **** }
 1120               	.LM71:
 1121 0494 DF91      		pop r29
 1122 0496 CF91      		pop r28
 1123 0498 0895      		ret
 1129               	.Lscope12:
 1131               		.stabd	78,0,0
 1135               	setTimeFunction:
 1136               		.stabd	46,0,0
 391:vty.c         **** {
 1138               	.LM72:
 1139               	.LFBB13:
 1140 049a EF92      		push r14
 1141 049c FF92      		push r15
 1142 049e 0F93      		push r16
 1143 04a0 1F93      		push r17
 1144               	/* prologue: function */
 1145               	/* frame size = 0 */
 1146 04a2 8C01      		movw r16,r24
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 1148               	.LM73:
 1149 04a4 81E0      		ldi r24,lo8(1)
 1150 04a6 B801      		movw r22,r16
 1151 04a8 0E94 0000 		call cmdlineGetArgInt
 1152 04ac F62E      		mov r15,r22
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 1154               	.LM74:
 1155 04ae 82E0      		ldi r24,lo8(2)
 1156 04b0 B801      		movw r22,r16
 1157 04b2 0E94 0000 		call cmdlineGetArgInt
 1158 04b6 E62E      		mov r14,r22
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 1160               	.LM75:
 1161 04b8 83E0      		ldi r24,lo8(3)
 1162 04ba B801      		movw r22,r16
 1163 04bc 0E94 0000 		call cmdlineGetArgInt
 1164 04c0 162F      		mov r17,r22
 396:vty.c         ****   ds1305start();
 1166               	.LM76:
 1167 04c2 0E94 0000 		call ds1305start
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 1169               	.LM77:
 1170 04c6 8F2D      		mov r24,r15
 1171 04c8 6AE0      		ldi r22,lo8(10)
 1172 04ca 0E94 0000 		call __udivmodqi4
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 1174               	.LM78:
 1175 04ce 282F      		mov r18,r24
 1176 04d0 2370      		andi r18,lo8(3)
 1177 04d2 A0E0      		ldi r26,lo8(czasRtc+2)
 1178 04d4 B0E0      		ldi r27,hi8(czasRtc+2)
 1179 04d6 2295      		swap r18
 1180 04d8 207F      		andi r18,lo8(-16)
 1181 04da 9091 0000 		lds r25,czasRtc+2
 1182 04de 9F7C      		andi r25,lo8(-49)
 1183 04e0 922B      		or r25,r18
 1184 04e2 9093 0000 		sts czasRtc+2,r25
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 1186               	.LM79:
 1187 04e6 46EF      		ldi r20,lo8(-10)
 1188 04e8 5FEF      		ldi r21,hi8(-10)
 1189 04ea 849F      		mul r24,r20
 1190 04ec 802D      		mov r24,r0
 1191 04ee 1124      		clr r1
 1192 04f0 8F0D      		add r24,r15
 1193 04f2 8F70      		andi r24,lo8(15)
 1194 04f4 9091 0000 		lds r25,czasRtc+2
 1195 04f8 907F      		andi r25,lo8(-16)
 1196 04fa 982B      		or r25,r24
 1197 04fc 9093 0000 		sts czasRtc+2,r25
 403:vty.c         ****   cDzies = minuta/10;
 1199               	.LM80:
 1200 0500 8E2D      		mov r24,r14
 1201 0502 0E94 0000 		call __udivmodqi4
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 1203               	.LM81:
 1204 0506 282F      		mov r18,r24
 1205 0508 2770      		andi r18,lo8(7)
 1206 050a FD01      		movw r30,r26
 1207 050c 2295      		swap r18
 1208 050e 207F      		andi r18,lo8(-16)
 1209 0510 9291      		ld r25,-Z
 1210 0512 9F78      		andi r25,lo8(-113)
 1211 0514 922B      		or r25,r18
 1212 0516 9083      		st Z,r25
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 1214               	.LM82:
 1215 0518 849F      		mul r24,r20
 1216 051a 802D      		mov r24,r0
 1217 051c 1124      		clr r1
 1218 051e 8E0D      		add r24,r14
 1219 0520 8F70      		andi r24,lo8(15)
 1220 0522 9081      		ld r25,Z
 1221 0524 907F      		andi r25,lo8(-16)
 1222 0526 982B      		or r25,r24
 1223 0528 9083      		st Z,r25
 408:vty.c         ****   cDzies = sekunda/10;
 1225               	.LM83:
 1226 052a 812F      		mov r24,r17
 1227 052c 0E94 0000 		call __udivmodqi4
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 1229               	.LM84:
 1230 0530 282F      		mov r18,r24
 1231 0532 2770      		andi r18,lo8(7)
 1232 0534 1297      		sbiw r26,2
 1233 0536 2295      		swap r18
 1234 0538 207F      		andi r18,lo8(-16)
 1235 053a 9C91      		ld r25,X
 1236 053c 9F78      		andi r25,lo8(-113)
 1237 053e 922B      		or r25,r18
 1238 0540 9C93      		st X,r25
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 1240               	.LM85:
 1241 0542 849F      		mul r24,r20
 1242 0544 802D      		mov r24,r0
 1243 0546 1124      		clr r1
 1244 0548 810F      		add r24,r17
 1245 054a 8F70      		andi r24,lo8(15)
 1246 054c 9C91      		ld r25,X
 1247 054e 907F      		andi r25,lo8(-16)
 1248 0550 982B      		or r25,r24
 1249 0552 9C93      		st X,r25
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 1251               	.LM86:
 1252 0554 CD01      		movw r24,r26
 1253 0556 0E94 0000 		call setTimeDecoded
 415:vty.c         **** }
 1255               	.LM87:
 1256 055a 80E0      		ldi r24,lo8(0)
 1257 055c 90E0      		ldi r25,hi8(0)
 1258               	/* epilogue start */
 1259 055e 1F91      		pop r17
 1260 0560 0F91      		pop r16
 1261 0562 FF90      		pop r15
 1262 0564 EF90      		pop r14
 1263 0566 0895      		ret
 1265               	.Lscope13:
 1267               		.stabd	78,0,0
 1271               	ustawPortRezystor:
 1272               		.stabd	46,0,0
 572:vty.c         **** {
 1274               	.LM88:
 1275               	.LFBB14:
 1276               	/* prologue: function */
 1277               	/* frame size = 0 */
 1278 0568 FC01      		movw r30,r24
 573:vty.c         ****   if (state->argc < 1)
 1280               	.LM89:
 1281 056a 818D      		ldd r24,Z+25
 1282 056c 8823      		tst r24
 1283 056e 01F4      		brne .L48
 1284 0570 22E0      		ldi r18,lo8(2)
 1285 0572 30E0      		ldi r19,hi8(2)
 1286 0574 00C0      		rjmp .L49
 1287               	.L48:
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 1289               	.LM90:
 1290 0576 81E0      		ldi r24,lo8(1)
 1291 0578 BF01      		movw r22,r30
 1292 057a 0E94 0000 		call cmdlineGetArgInt
 1293 057e 862F      		mov r24,r22
 578:vty.c         ****   MCP4150_setValue(wartosc);
 1295               	.LM91:
 1296 0580 0E94 0000 		call MCP4150_setValue
 1297 0584 20E0      		ldi r18,lo8(0)
 1298 0586 30E0      		ldi r19,hi8(0)
 1299               	.L49:
 581:vty.c         **** }
 1301               	.LM92:
 1302 0588 C901      		movw r24,r18
 1303               	/* epilogue start */
 1304 058a 0895      		ret
 1306               	.Lscope14:
 1308               		.stabd	78,0,0
 1312               	ustawPortExtBFunction:
 1313               		.stabd	46,0,0
 564:vty.c         **** {
 1315               	.LM93:
 1316               	.LFBB15:
 1317 058c 1F93      		push r17
 1318               	/* prologue: function */
 1319               	/* frame size = 0 */
 1320 058e BC01      		movw r22,r24
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1322               	.LM94:
 1323 0590 81E0      		ldi r24,lo8(1)
 1324 0592 0E94 0000 		call cmdlineGetArgInt
 1325 0596 162F      		mov r17,r22
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 1327               	.LM95:
 1328 0598 80E0      		ldi r24,lo8(0)
 1329 059a 60E0      		ldi r22,lo8(0)
 1330 059c 0E94 0000 		call MPC23s17SetDirB
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 1332               	.LM96:
 1333 05a0 812F      		mov r24,r17
 1334 05a2 60E0      		ldi r22,lo8(0)
 1335 05a4 0E94 0000 		call MPC23s17SetPortB
 569:vty.c         **** }
 1337               	.LM97:
 1338 05a8 80E0      		ldi r24,lo8(0)
 1339 05aa 90E0      		ldi r25,hi8(0)
 1340               	/* epilogue start */
 1341 05ac 1F91      		pop r17
 1342 05ae 0895      		ret
 1344               	.Lscope15:
 1346               		.stabd	78,0,0
 1350               	ustawPortExtAFunction:
 1351               		.stabd	46,0,0
 556:vty.c         **** {
 1353               	.LM98:
 1354               	.LFBB16:
 1355 05b0 1F93      		push r17
 1356               	/* prologue: function */
 1357               	/* frame size = 0 */
 1358 05b2 BC01      		movw r22,r24
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1360               	.LM99:
 1361 05b4 81E0      		ldi r24,lo8(1)
 1362 05b6 0E94 0000 		call cmdlineGetArgInt
 1363 05ba 162F      		mov r17,r22
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 1365               	.LM100:
 1366 05bc 80E0      		ldi r24,lo8(0)
 1367 05be 60E0      		ldi r22,lo8(0)
 1368 05c0 0E94 0000 		call MPC23s17SetDirA
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 1370               	.LM101:
 1371 05c4 812F      		mov r24,r17
 1372 05c6 60E0      		ldi r22,lo8(0)
 1373 05c8 0E94 0000 		call MPC23s17SetPortA
 561:vty.c         **** }
 1375               	.LM102:
 1376 05cc 80E0      		ldi r24,lo8(0)
 1377 05ce 90E0      		ldi r25,hi8(0)
 1378               	/* epilogue start */
 1379 05d0 1F91      		pop r17
 1380 05d2 0895      		ret
 1382               	.Lscope16:
 1384               		.stabd	78,0,0
 1388               	curtainDownFunction:
 1389               		.stabd	46,0,0
 509:vty.c         **** {
 1391               	.LM103:
 1392               	.LFBB17:
 1393 05d4 FF92      		push r15
 1394 05d6 0F93      		push r16
 1395 05d8 1F93      		push r17
 1396 05da CF93      		push r28
 1397 05dc DF93      		push r29
 1398               	/* prologue: function */
 1399               	/* frame size = 0 */
 1400 05de EC01      		movw r28,r24
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 1402               	.LM104:
 1403 05e0 81E0      		ldi r24,lo8(1)
 1404 05e2 BE01      		movw r22,r28
 1405 05e4 0E94 0000 		call cmdlineGetArgInt
 1406 05e8 F62E      		mov r15,r22
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 1408               	.LM105:
 1409 05ea 82E0      		ldi r24,lo8(2)
 1410 05ec BE01      		movw r22,r28
 1411 05ee 0E94 0000 		call cmdlineGetArgInt
 1412 05f2 162F      		mov r17,r22
 516:vty.c         ****   nrRolety &= 0x01;
 1414               	.LM106:
 1415 05f4 1170      		andi r17,lo8(1)
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 1417               	.LM107:
 1418 05f6 83E0      		ldi r24,lo8(3)
 1419 05f8 BE01      		movw r22,r28
 1420 05fa 0E94 0000 		call cmdlineGetArgInt
 1421 05fe 062F      		mov r16,r22
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 1423               	.LM108:
 1424 0600 2DB7      		in r18,__SP_L__
 1425 0602 3EB7      		in r19,__SP_H__
 1426 0604 2850      		subi r18,lo8(-(-8))
 1427 0606 3040      		sbci r19,hi8(-(-8))
 1428 0608 0FB6      		in __tmp_reg__,__SREG__
 1429 060a F894      		cli
 1430 060c 3EBF      		out __SP_H__,r19
 1431 060e 0FBE      		out __SREG__,__tmp_reg__
 1432 0610 2DBF      		out __SP_L__,r18
 1433 0612 EDB7      		in r30,__SP_L__
 1434 0614 FEB7      		in r31,__SP_H__
 1435 0616 3196      		adiw r30,1
 1436 0618 8A8D      		ldd r24,Y+26
 1437 061a 9B8D      		ldd r25,Y+27
 1438 061c ADB7      		in r26,__SP_L__
 1439 061e BEB7      		in r27,__SP_H__
 1440 0620 1296      		adiw r26,1+1
 1441 0622 9C93      		st X,r25
 1442 0624 8E93      		st -X,r24
 1443 0626 1197      		sbiw r26,1
 1444 0628 80E0      		ldi r24,lo8(movingCurtainDownStr)
 1445 062a 90E0      		ldi r25,hi8(movingCurtainDownStr)
 1446 062c 9383      		std Z+3,r25
 1447 062e 8283      		std Z+2,r24
 1448 0630 F482      		std Z+4,r15
 1449 0632 1582      		std Z+5,__zero_reg__
 1450 0634 812F      		mov r24,r17
 1451 0636 90E0      		ldi r25,lo8(0)
 1452 0638 0196      		adiw r24,1
 1453 063a 9783      		std Z+7,r25
 1454 063c 8683      		std Z+6,r24
 1455 063e 0E94 0000 		call fprintf_P
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1457               	.LM109:
 1458 0642 802F      		mov r24,r16
 1459 0644 8150      		subi r24,lo8(-(-1))
 1460 0646 2DB7      		in r18,__SP_L__
 1461 0648 3EB7      		in r19,__SP_H__
 1462 064a 285F      		subi r18,lo8(-(8))
 1463 064c 3F4F      		sbci r19,hi8(-(8))
 1464 064e 0FB6      		in __tmp_reg__,__SREG__
 1465 0650 F894      		cli
 1466 0652 3EBF      		out __SP_H__,r19
 1467 0654 0FBE      		out __SREG__,__tmp_reg__
 1468 0656 2DBF      		out __SP_L__,r18
 1469 0658 8436      		cpi r24,lo8(100)
 1470 065a 00F4      		brsh .L56
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1472               	.LM110:
 1473 065c 00D0      		rcall .
 1474 065e 00D0      		rcall .
 1475 0660 00D0      		rcall .
 1476 0662 EDB7      		in r30,__SP_L__
 1477 0664 FEB7      		in r31,__SP_H__
 1478 0666 3196      		adiw r30,1
 1479 0668 8A8D      		ldd r24,Y+26
 1480 066a 9B8D      		ldd r25,Y+27
 1481 066c ADB7      		in r26,__SP_L__
 1482 066e BEB7      		in r27,__SP_H__
 1483 0670 1296      		adiw r26,1+1
 1484 0672 9C93      		st X,r25
 1485 0674 8E93      		st -X,r24
 1486 0676 1197      		sbiw r26,1
 1487 0678 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1488 067a 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1489 067c 9383      		std Z+3,r25
 1490 067e 8283      		std Z+2,r24
 1491 0680 0483      		std Z+4,r16
 1492 0682 1582      		std Z+5,__zero_reg__
 1493 0684 0E94 0000 		call fprintf_P
 1494 0688 2DB7      		in r18,__SP_L__
 1495 068a 3EB7      		in r19,__SP_H__
 1496 068c 2A5F      		subi r18,lo8(-(6))
 1497 068e 3F4F      		sbci r19,hi8(-(6))
 1498 0690 0FB6      		in __tmp_reg__,__SREG__
 1499 0692 F894      		cli
 1500 0694 3EBF      		out __SP_H__,r19
 1501 0696 0FBE      		out __SREG__,__tmp_reg__
 1502 0698 2DBF      		out __SP_L__,r18
 1503               	.L56:
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 1505               	.LM111:
 1506 069a 8F2D      		mov r24,r15
 1507 069c 612F      		mov r22,r17
 1508 069e 402F      		mov r20,r16
 1509 06a0 0E94 0000 		call rs485curtainDown
 526:vty.c         ****   if (result == 0)
 1511               	.LM112:
 1512 06a4 8823      		tst r24
 1513 06a6 01F0      		breq .L57
 1514 06a8 23E0      		ldi r18,lo8(3)
 1515 06aa 30E0      		ldi r19,hi8(3)
 1516 06ac 00C0      		rjmp .L58
 1517               	.L57:
 1518 06ae 21E0      		ldi r18,lo8(1)
 1519 06b0 30E0      		ldi r19,hi8(1)
 1520               	.L58:
 530:vty.c         **** }
 1522               	.LM113:
 1523 06b2 C901      		movw r24,r18
 1524               	/* epilogue start */
 1525 06b4 DF91      		pop r29
 1526 06b6 CF91      		pop r28
 1527 06b8 1F91      		pop r17
 1528 06ba 0F91      		pop r16
 1529 06bc FF90      		pop r15
 1530 06be 0895      		ret
 1536               	.Lscope17:
 1538               		.stabd	78,0,0
 1542               	curtainUpFunction:
 1543               		.stabd	46,0,0
 533:vty.c         **** {
 1545               	.LM114:
 1546               	.LFBB18:
 1547 06c0 FF92      		push r15
 1548 06c2 0F93      		push r16
 1549 06c4 1F93      		push r17
 1550 06c6 CF93      		push r28
 1551 06c8 DF93      		push r29
 1552               	/* prologue: function */
 1553               	/* frame size = 0 */
 1554 06ca EC01      		movw r28,r24
 534:vty.c         ****   if (state->argc < 2)
 1556               	.LM115:
 1557 06cc 898D      		ldd r24,Y+25
 1558 06ce 8230      		cpi r24,lo8(2)
 1559 06d0 00F4      		brsh .L61
 1560 06d2 22E0      		ldi r18,lo8(2)
 1561 06d4 30E0      		ldi r19,hi8(2)
 1562 06d6 00C0      		rjmp .L62
 1563               	.L61:
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 1565               	.LM116:
 1566 06d8 81E0      		ldi r24,lo8(1)
 1567 06da BE01      		movw r22,r28
 1568 06dc 0E94 0000 		call cmdlineGetArgInt
 1569 06e0 F62E      		mov r15,r22
 1570 06e2 2FE3      		ldi r18,lo8(63)
 1571 06e4 F222      		and r15,r18
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 1573               	.LM117:
 1574 06e6 82E0      		ldi r24,lo8(2)
 1575 06e8 BE01      		movw r22,r28
 1576 06ea 0E94 0000 		call cmdlineGetArgInt
 1577 06ee 062F      		mov r16,r22
 1578 06f0 0170      		andi r16,lo8(1)
 540:vty.c         ****   if (state->argc > 2)
 1580               	.LM118:
 1581 06f2 898D      		ldd r24,Y+25
 1582 06f4 8330      		cpi r24,lo8(3)
 1583 06f6 00F4      		brsh .L63
 1584 06f8 1FEF      		ldi r17,lo8(-1)
 1585 06fa 00C0      		rjmp .L64
 1586               	.L63:
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 1588               	.LM119:
 1589 06fc 83E0      		ldi r24,lo8(3)
 1590 06fe BE01      		movw r22,r28
 1591 0700 0E94 0000 		call cmdlineGetArgInt
 1592 0704 162F      		mov r17,r22
 1593               	.L64:
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 1595               	.LM120:
 1596 0706 8DB7      		in r24,__SP_L__
 1597 0708 9EB7      		in r25,__SP_H__
 1598 070a 0897      		sbiw r24,8
 1599 070c 0FB6      		in __tmp_reg__,__SREG__
 1600 070e F894      		cli
 1601 0710 9EBF      		out __SP_H__,r25
 1602 0712 0FBE      		out __SREG__,__tmp_reg__
 1603 0714 8DBF      		out __SP_L__,r24
 1604 0716 EDB7      		in r30,__SP_L__
 1605 0718 FEB7      		in r31,__SP_H__
 1606 071a 3196      		adiw r30,1
 1607 071c 8A8D      		ldd r24,Y+26
 1608 071e 9B8D      		ldd r25,Y+27
 1609 0720 ADB7      		in r26,__SP_L__
 1610 0722 BEB7      		in r27,__SP_H__
 1611 0724 1296      		adiw r26,1+1
 1612 0726 9C93      		st X,r25
 1613 0728 8E93      		st -X,r24
 1614 072a 1197      		sbiw r26,1
 1615 072c 80E0      		ldi r24,lo8(movingCurtainUpStr)
 1616 072e 90E0      		ldi r25,hi8(movingCurtainUpStr)
 1617 0730 9383      		std Z+3,r25
 1618 0732 8283      		std Z+2,r24
 1619 0734 F482      		std Z+4,r15
 1620 0736 1582      		std Z+5,__zero_reg__
 1621 0738 802F      		mov r24,r16
 1622 073a 90E0      		ldi r25,lo8(0)
 1623 073c 0196      		adiw r24,1
 1624 073e 9783      		std Z+7,r25
 1625 0740 8683      		std Z+6,r24
 1626 0742 0E94 0000 		call fprintf_P
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1628               	.LM121:
 1629 0746 812F      		mov r24,r17
 1630 0748 8150      		subi r24,lo8(-(-1))
 1631 074a 2DB7      		in r18,__SP_L__
 1632 074c 3EB7      		in r19,__SP_H__
 1633 074e 285F      		subi r18,lo8(-(8))
 1634 0750 3F4F      		sbci r19,hi8(-(8))
 1635 0752 0FB6      		in __tmp_reg__,__SREG__
 1636 0754 F894      		cli
 1637 0756 3EBF      		out __SP_H__,r19
 1638 0758 0FBE      		out __SREG__,__tmp_reg__
 1639 075a 2DBF      		out __SP_L__,r18
 1640 075c 8436      		cpi r24,lo8(100)
 1641 075e 00F4      		brsh .L65
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1643               	.LM122:
 1644 0760 00D0      		rcall .
 1645 0762 00D0      		rcall .
 1646 0764 00D0      		rcall .
 1647 0766 EDB7      		in r30,__SP_L__
 1648 0768 FEB7      		in r31,__SP_H__
 1649 076a 3196      		adiw r30,1
 1650 076c 8A8D      		ldd r24,Y+26
 1651 076e 9B8D      		ldd r25,Y+27
 1652 0770 ADB7      		in r26,__SP_L__
 1653 0772 BEB7      		in r27,__SP_H__
 1654 0774 1296      		adiw r26,1+1
 1655 0776 9C93      		st X,r25
 1656 0778 8E93      		st -X,r24
 1657 077a 1197      		sbiw r26,1
 1658 077c 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1659 077e 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1660 0780 9383      		std Z+3,r25
 1661 0782 8283      		std Z+2,r24
 1662 0784 1483      		std Z+4,r17
 1663 0786 1582      		std Z+5,__zero_reg__
 1664 0788 0E94 0000 		call fprintf_P
 1665 078c 2DB7      		in r18,__SP_L__
 1666 078e 3EB7      		in r19,__SP_H__
 1667 0790 2A5F      		subi r18,lo8(-(6))
 1668 0792 3F4F      		sbci r19,hi8(-(6))
 1669 0794 0FB6      		in __tmp_reg__,__SREG__
 1670 0796 F894      		cli
 1671 0798 3EBF      		out __SP_H__,r19
 1672 079a 0FBE      		out __SREG__,__tmp_reg__
 1673 079c 2DBF      		out __SP_L__,r18
 1674               	.L65:
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 1676               	.LM123:
 1677 079e 8F2D      		mov r24,r15
 1678 07a0 602F      		mov r22,r16
 1679 07a2 412F      		mov r20,r17
 1680 07a4 0E94 0000 		call rs485curtainUp
 549:vty.c         ****   if (result == 0)
 1682               	.LM124:
 1683 07a8 8823      		tst r24
 1684 07aa 01F0      		breq .L66
 1685 07ac 23E0      		ldi r18,lo8(3)
 1686 07ae 30E0      		ldi r19,hi8(3)
 1687 07b0 00C0      		rjmp .L62
 1688               	.L66:
 1689 07b2 21E0      		ldi r18,lo8(1)
 1690 07b4 30E0      		ldi r19,hi8(1)
 1691               	.L62:
 553:vty.c         **** }
 1693               	.LM125:
 1694 07b6 C901      		movw r24,r18
 1695               	/* epilogue start */
 1696 07b8 DF91      		pop r29
 1697 07ba CF91      		pop r28
 1698 07bc 1F91      		pop r17
 1699 07be 0F91      		pop r16
 1700 07c0 FF90      		pop r15
 1701 07c2 0895      		ret
 1708               	.Lscope18:
 1710               		.stabd	78,0,0
 1714               	goXmodemWyslijFunction:
 1715               		.stabd	46,0,0
 650:vty.c         **** {
 1717               	.LM126:
 1718               	.LFBB19:
 1719 07c4 0F93      		push r16
 1720 07c6 1F93      		push r17
 1721 07c8 CF93      		push r28
 1722 07ca DF93      		push r29
 1723               	/* prologue: function */
 1724               	/* frame size = 0 */
 1725 07cc EC01      		movw r28,r24
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 1727               	.LM127:
 1728 07ce 00D0      		rcall .
 1729 07d0 00D0      		rcall .
 1730 07d2 8A8D      		ldd r24,Y+26
 1731 07d4 9B8D      		ldd r25,Y+27
 1732 07d6 ADB7      		in r26,__SP_L__
 1733 07d8 BEB7      		in r27,__SP_H__
 1734 07da 1296      		adiw r26,1+1
 1735 07dc 9C93      		st X,r25
 1736 07de 8E93      		st -X,r24
 1737 07e0 1197      		sbiw r26,1
 1738 07e2 80E0      		ldi r24,lo8(xwyslijStartStr)
 1739 07e4 90E0      		ldi r25,hi8(xwyslijStartStr)
 1740 07e6 1496      		adiw r26,3+1
 1741 07e8 9C93      		st X,r25
 1742 07ea 8E93      		st -X,r24
 1743 07ec 1397      		sbiw r26,3
 1744 07ee 0E94 0000 		call fprintf_P
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1746               	.LM128:
 1747 07f2 0F90      		pop __tmp_reg__
 1748 07f4 0F90      		pop __tmp_reg__
 1749 07f6 0F90      		pop __tmp_reg__
 1750 07f8 0F90      		pop __tmp_reg__
 1751 07fa 81E0      		ldi r24,lo8(1)
 1752 07fc BE01      		movw r22,r28
 1753 07fe 0E94 0000 		call cmdlineGetArgStr
 1754 0802 60E0      		ldi r22,lo8(fdVty)
 1755 0804 70E0      		ldi r23,hi8(fdVty)
 1756 0806 0E94 0000 		call ramDyskOtworzPlik
 1757 080a 8823      		tst r24
 1758 080c 01F4      		brne .L69
 1759 080e 20E0      		ldi r18,lo8(0)
 1760 0810 30E0      		ldi r19,hi8(0)
 1761 0812 00C0      		rjmp .L70
 1762               	.L69:
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 1764               	.LM129:
 1765 0814 0A8D      		ldd r16,Y+26
 1766 0816 1B8D      		ldd r17,Y+27
 1767 0818 81E0      		ldi r24,lo8(1)
 1768 081a BE01      		movw r22,r28
 1769 081c 0E94 0000 		call cmdlineGetArgStr
 1770 0820 00D0      		rcall .
 1771 0822 00D0      		rcall .
 1772 0824 00D0      		rcall .
 1773 0826 EDB7      		in r30,__SP_L__
 1774 0828 FEB7      		in r31,__SP_H__
 1775 082a 3196      		adiw r30,1
 1776 082c ADB7      		in r26,__SP_L__
 1777 082e BEB7      		in r27,__SP_H__
 1778 0830 1296      		adiw r26,1+1
 1779 0832 1C93      		st X,r17
 1780 0834 0E93      		st -X,r16
 1781 0836 1197      		sbiw r26,1
 1782 0838 20E0      		ldi r18,lo8(errorOpenFile)
 1783 083a 30E0      		ldi r19,hi8(errorOpenFile)
 1784 083c 3383      		std Z+3,r19
 1785 083e 2283      		std Z+2,r18
 1786 0840 9583      		std Z+5,r25
 1787 0842 8483      		std Z+4,r24
 1788 0844 0E94 0000 		call fprintf_P
 1789 0848 24E0      		ldi r18,lo8(4)
 1790 084a 30E0      		ldi r19,hi8(4)
 1791 084c EDB7      		in r30,__SP_L__
 1792 084e FEB7      		in r31,__SP_H__
 1793 0850 3696      		adiw r30,6
 1794 0852 0FB6      		in __tmp_reg__,__SREG__
 1795 0854 F894      		cli
 1796 0856 FEBF      		out __SP_H__,r31
 1797 0858 0FBE      		out __SREG__,__tmp_reg__
 1798 085a EDBF      		out __SP_L__,r30
 1799               	.L70:
 658:vty.c         **** }
 1801               	.LM130:
 1802 085c C901      		movw r24,r18
 1803               	/* epilogue start */
 1804 085e DF91      		pop r29
 1805 0860 CF91      		pop r28
 1806 0862 1F91      		pop r17
 1807 0864 0F91      		pop r16
 1808 0866 0895      		ret
 1810               	.Lscope19:
 1812               		.stabd	78,0,0
 1816               	editRamFileFunction:
 1817               		.stabd	46,0,0
 876:vty.c         **** {
 1819               	.LM131:
 1820               	.LFBB20:
 1821 0868 EF92      		push r14
 1822 086a FF92      		push r15
 1823 086c 0F93      		push r16
 1824 086e 1F93      		push r17
 1825 0870 DF93      		push r29
 1826 0872 CF93      		push r28
 1827 0874 0F92      		push __tmp_reg__
 1828 0876 CDB7      		in r28,__SP_L__
 1829 0878 DEB7      		in r29,__SP_H__
 1830               	/* prologue: function */
 1831               	/* frame size = 1 */
 1832 087a 7C01      		movw r14,r24
 877:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1834               	.LM132:
 1835 087c 81E0      		ldi r24,lo8(1)
 1836 087e B701      		movw r22,r14
 1837 0880 0E94 0000 		call cmdlineGetArgStr
 1838 0884 60E0      		ldi r22,lo8(fdVty)
 1839 0886 70E0      		ldi r23,hi8(fdVty)
 1840 0888 0E94 0000 		call ramDyskOtworzPlik
 1841 088c 8823      		tst r24
 1842 088e 01F0      		breq .L73
 879:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 1844               	.LM133:
 1845 0890 D701      		movw r26,r14
 1846 0892 5A96      		adiw r26,26
 1847 0894 0D91      		ld r16,X+
 1848 0896 1C91      		ld r17,X
 1849 0898 5B97      		sbiw r26,26+1
 1850 089a 81E0      		ldi r24,lo8(1)
 1851 089c B701      		movw r22,r14
 1852 089e 0E94 0000 		call cmdlineGetArgStr
 1853 08a2 00D0      		rcall .
 1854 08a4 00D0      		rcall .
 1855 08a6 00D0      		rcall .
 1856 08a8 EDB7      		in r30,__SP_L__
 1857 08aa FEB7      		in r31,__SP_H__
 1858 08ac 3196      		adiw r30,1
 1859 08ae ADB7      		in r26,__SP_L__
 1860 08b0 BEB7      		in r27,__SP_H__
 1861 08b2 1296      		adiw r26,1+1
 1862 08b4 1C93      		st X,r17
 1863 08b6 0E93      		st -X,r16
 1864 08b8 1197      		sbiw r26,1
 1865 08ba 20E0      		ldi r18,lo8(errorOpenFile)
 1866 08bc 30E0      		ldi r19,hi8(errorOpenFile)
 1867 08be 3383      		std Z+3,r19
 1868 08c0 2283      		std Z+2,r18
 1869 08c2 9583      		std Z+5,r25
 1870 08c4 8483      		std Z+4,r24
 1871 08c6 0E94 0000 		call fprintf_P
 1872 08ca 24E0      		ldi r18,lo8(4)
 1873 08cc 30E0      		ldi r19,hi8(4)
 1874 08ce EDB7      		in r30,__SP_L__
 1875 08d0 FEB7      		in r31,__SP_H__
 1876 08d2 3696      		adiw r30,6
 1877 08d4 0FB6      		in __tmp_reg__,__SREG__
 1878 08d6 F894      		cli
 1879 08d8 FEBF      		out __SP_H__,r31
 1880 08da 0FBE      		out __SREG__,__tmp_reg__
 1881 08dc EDBF      		out __SP_L__,r30
 1882 08de 00C0      		rjmp .L74
 1883               	.L73:
 882:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 1885               	.LM134:
 1886 08e0 80E0      		ldi r24,lo8(fdVty)
 1887 08e2 90E0      		ldi r25,hi8(fdVty)
 1888 08e4 0E94 0000 		call ramDyskUstawWskaznikNaKoniec
 883:vty.c         ****   uint8_t znak = 0;
 1890               	.LM135:
 1891 08e8 1982      		std Y+1,__zero_reg__
 884:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 1893               	.LM136:
 1894 08ea 00D0      		rcall .
 1895 08ec 00D0      		rcall .
 1896 08ee D701      		movw r26,r14
 1897 08f0 5A96      		adiw r26,26
 1898 08f2 8D91      		ld r24,X+
 1899 08f4 9C91      		ld r25,X
 1900 08f6 5B97      		sbiw r26,26+1
 1901 08f8 EDB7      		in r30,__SP_L__
 1902 08fa FEB7      		in r31,__SP_H__
 1903 08fc 9283      		std Z+2,r25
 1904 08fe 8183      		std Z+1,r24
 1905 0900 80E0      		ldi r24,lo8(editRamFileIntroStr)
 1906 0902 90E0      		ldi r25,hi8(editRamFileIntroStr)
 1907 0904 9483      		std Z+4,r25
 1908 0906 8383      		std Z+3,r24
 1909 0908 0E94 0000 		call fprintf_P
 1910 090c 0F90      		pop __tmp_reg__
 1911 090e 0F90      		pop __tmp_reg__
 1912 0910 0F90      		pop __tmp_reg__
 1913 0912 0F90      		pop __tmp_reg__
 887:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 1915               	.LM137:
 1916 0914 7E01      		movw r14,r28
 1917 0916 0894      		sec
 1918 0918 E11C      		adc r14,__zero_reg__
 1919 091a F11C      		adc r15,__zero_reg__
 1920               	.L80:
 1921 091c 8091 0000 		lds r24,xVtyRec
 1922 0920 9091 0000 		lds r25,(xVtyRec)+1
 1923 0924 B701      		movw r22,r14
 1924 0926 4FEF      		ldi r20,lo8(-1)
 1925 0928 5FEF      		ldi r21,hi8(-1)
 1926 092a 20E0      		ldi r18,lo8(0)
 1927 092c 0E94 0000 		call xQueueGenericReceive
 1928 0930 8823      		tst r24
 1929 0932 01F0      		breq .L80
 890:vty.c         ****     if (znak == 0x03)                                       // ^C
 1931               	.LM138:
 1932 0934 8981      		ldd r24,Y+1
 1933 0936 8330      		cpi r24,lo8(3)
 1934 0938 01F0      		breq .L76
 893:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 1936               	.LM139:
 1937 093a 0E94 0000 		call uartVtySendByte
 894:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 1939               	.LM140:
 1940 093e 80E0      		ldi r24,lo8(fdVty)
 1941 0940 90E0      		ldi r25,hi8(fdVty)
 1942 0942 6981      		ldd r22,Y+1
 1943 0944 0E94 0000 		call ramDyskZapiszBajtDoPliku
 1944 0948 00C0      		rjmp .L80
 1945               	.L76:
 896:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 1947               	.LM141:
 1948 094a 80E0      		ldi r24,lo8(fdVty)
 1949 094c 90E0      		ldi r25,hi8(fdVty)
 1950 094e 0E94 0000 		call ramDyskZamknijPlik
 1951 0952 20E0      		ldi r18,lo8(0)
 1952 0954 30E0      		ldi r19,hi8(0)
 1953               	.L74:
 898:vty.c         **** }
 1955               	.LM142:
 1956 0956 C901      		movw r24,r18
 1957               	/* epilogue start */
 1958 0958 0F90      		pop __tmp_reg__
 1959 095a CF91      		pop r28
 1960 095c DF91      		pop r29
 1961 095e 1F91      		pop r17
 1962 0960 0F91      		pop r16
 1963 0962 FF90      		pop r15
 1964 0964 EF90      		pop r14
 1965 0966 0895      		ret
 1970               	.Lscope20:
 1972               		.stabd	78,0,0
 1976               	eraseRamFileFunction:
 1977               		.stabd	46,0,0
 848:vty.c         **** {
 1979               	.LM143:
 1980               	.LFBB21:
 1981 0968 CF93      		push r28
 1982 096a DF93      		push r29
 1983               	/* prologue: function */
 1984               	/* frame size = 0 */
 1985 096c EC01      		movw r28,r24
 849:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 1987               	.LM144:
 1988 096e 81E0      		ldi r24,lo8(1)
 1989 0970 BE01      		movw r22,r28
 1990 0972 0E94 0000 		call cmdlineGetArgStr
 1991 0976 0E94 0000 		call ramDyskUsunPlik
 1992 097a 8823      		tst r24
 1993 097c 01F4      		brne .L82
 1994 097e 21E0      		ldi r18,lo8(1)
 1995 0980 30E0      		ldi r19,hi8(1)
 1996 0982 00C0      		rjmp .L83
 1997               	.L82:
 852:vty.c         ****   printErrorInfo(state);
 1999               	.LM145:
 2000 0984 CE01      		movw r24,r28
 2001 0986 0E94 0000 		call printErrorInfo
 2002 098a 24E0      		ldi r18,lo8(4)
 2003 098c 30E0      		ldi r19,hi8(4)
 2004               	.L83:
 854:vty.c         **** }
 2006               	.LM146:
 2007 098e C901      		movw r24,r18
 2008               	/* epilogue start */
 2009 0990 DF91      		pop r29
 2010 0992 CF91      		pop r28
 2011 0994 0895      		ret
 2013               	.Lscope21:
 2015               		.stabd	78,0,0
 2019               	dodajRamPlikFunction:
 2020               		.stabd	46,0,0
 857:vty.c         **** {
 2022               	.LM147:
 2023               	.LFBB22:
 2024 0996 CF93      		push r28
 2025 0998 DF93      		push r29
 2026               	/* prologue: function */
 2027               	/* frame size = 0 */
 2028 099a EC01      		movw r28,r24
 858:vty.c         ****   if (state->argc != 1)
 2030               	.LM148:
 2031 099c 898D      		ldd r24,Y+25
 2032 099e 8130      		cpi r24,lo8(1)
 2033 09a0 01F0      		breq .L86
 2034 09a2 22E0      		ldi r18,lo8(2)
 2035 09a4 30E0      		ldi r19,hi8(2)
 2036 09a6 00C0      		rjmp .L87
 2037               	.L86:
 861:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 2039               	.LM149:
 2040 09a8 81E0      		ldi r24,lo8(1)
 2041 09aa BE01      		movw r22,r28
 2042 09ac 0E94 0000 		call cmdlineGetArgStr
 2043 09b0 0E94 0000 		call ramDyskUtworzPlik
 2044 09b4 8823      		tst r24
 2045 09b6 01F4      		brne .L88
 2046 09b8 21E0      		ldi r18,lo8(1)
 2047 09ba 30E0      		ldi r19,hi8(1)
 2048 09bc 00C0      		rjmp .L87
 2049               	.L88:
 865:vty.c         ****   printErrorInfo(state);
 2051               	.LM150:
 2052 09be CE01      		movw r24,r28
 2053 09c0 0E94 0000 		call printErrorInfo
 2054 09c4 24E0      		ldi r18,lo8(4)
 2055 09c6 30E0      		ldi r19,hi8(4)
 2056               	.L87:
 867:vty.c         **** }
 2058               	.LM151:
 2059 09c8 C901      		movw r24,r18
 2060               	/* epilogue start */
 2061 09ca DF91      		pop r29
 2062 09cc CF91      		pop r28
 2063 09ce 0895      		ret
 2065               	.Lscope22:
 2067               		.stabd	78,0,0
 2071               	rpingFunction:
 2072               		.stabd	46,0,0
 584:vty.c         **** {
 2074               	.LM152:
 2075               	.LFBB23:
 2076 09d0 1F93      		push r17
 2077 09d2 CF93      		push r28
 2078 09d4 DF93      		push r29
 2079               	/* prologue: function */
 2080               	/* frame size = 0 */
 2081 09d6 EC01      		movw r28,r24
 585:vty.c         ****   if (state->argc < 1)
 2083               	.LM153:
 2084 09d8 898D      		ldd r24,Y+25
 2085 09da 8823      		tst r24
 2086 09dc 01F4      		brne .L91
 2087 09de 22E0      		ldi r18,lo8(2)
 2088 09e0 30E0      		ldi r19,hi8(2)
 2089 09e2 00C0      		rjmp .L92
 2090               	.L91:
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 2092               	.LM154:
 2093 09e4 81E0      		ldi r24,lo8(1)
 2094 09e6 BE01      		movw r22,r28
 2095 09e8 0E94 0000 		call cmdlineGetArgInt
 2096 09ec 162F      		mov r17,r22
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 2098               	.LM155:
 2099 09ee 862F      		mov r24,r22
 2100 09f0 0E94 0000 		call rs485ping
 2101 09f4 8F8F      		std Y+31,r24
 2102 09f6 8823      		tst r24
 2103 09f8 01F4      		brne .L93
 2104 09fa 21E0      		ldi r18,lo8(1)
 2105 09fc 30E0      		ldi r19,hi8(1)
 2106 09fe 00C0      		rjmp .L92
 2107               	.L93:
 592:vty.c         ****   state->errno = noRemoteDevice;
 2109               	.LM156:
 2110 0a00 89E0      		ldi r24,lo8(9)
 2111 0a02 8C8F      		std Y+28,r24
 593:vty.c         ****   state->err1 = nrSterownika;
 2113               	.LM157:
 2114 0a04 1D8F      		std Y+29,r17
 2115 0a06 1E8E      		std Y+30,__zero_reg__
 594:vty.c         ****   printErrorInfo(state);
 2117               	.LM158:
 2118 0a08 CE01      		movw r24,r28
 2119 0a0a 0E94 0000 		call printErrorInfo
 2120 0a0e 20E0      		ldi r18,lo8(0)
 2121 0a10 30E0      		ldi r19,hi8(0)
 2122               	.L92:
 596:vty.c         **** }
 2124               	.LM159:
 2125 0a12 C901      		movw r24,r18
 2126               	/* epilogue start */
 2127 0a14 DF91      		pop r29
 2128 0a16 CF91      		pop r28
 2129 0a18 1F91      		pop r17
 2130 0a1a 0895      		ret
 2132               	.Lscope23:
 2134               		.stabd	78,0,0
 2138               	flashExModuleFunction:
 2139               		.stabd	46,0,0
 616:vty.c         **** {
 2141               	.LM160:
 2142               	.LFBB24:
 2143 0a1c FF92      		push r15
 2144 0a1e 0F93      		push r16
 2145 0a20 1F93      		push r17
 2146 0a22 CF93      		push r28
 2147 0a24 DF93      		push r29
 2148               	/* prologue: function */
 2149               	/* frame size = 0 */
 2150 0a26 EC01      		movw r28,r24
 617:vty.c         ****   if (state->argc != 2)
 2152               	.LM161:
 2153 0a28 898D      		ldd r24,Y+25
 2154 0a2a 8230      		cpi r24,lo8(2)
 2155 0a2c 01F0      		breq .L96
 2156 0a2e 22E0      		ldi r18,lo8(2)
 2157 0a30 30E0      		ldi r19,hi8(2)
 2158 0a32 00C0      		rjmp .L97
 2159               	.L96:
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 2161               	.LM162:
 2162 0a34 81E0      		ldi r24,lo8(1)
 2163 0a36 BE01      		movw r22,r28
 2164 0a38 0E94 0000 		call cmdlineGetArgInt
 2165 0a3c F62E      		mov r15,r22
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 2167               	.LM163:
 2168 0a3e 82E0      		ldi r24,lo8(2)
 2169 0a40 BE01      		movw r22,r28
 2170 0a42 0E94 0000 		call cmdlineGetArgStr
 2171 0a46 8C01      		movw r16,r24
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 2173               	.LM164:
 2174 0a48 8F2D      		mov r24,r15
 2175 0a4a 0E94 0000 		call rs485ping
 2176 0a4e 8823      		tst r24
 2177 0a50 01F0      		breq .L98
 627:vty.c         ****     state->errno = noRemoteDevice;
 2179               	.LM165:
 2180 0a52 89E0      		ldi r24,lo8(9)
 2181 0a54 8C8F      		std Y+28,r24
 628:vty.c         ****     printErrorInfo(state);
 2183               	.LM166:
 2184 0a56 CE01      		movw r24,r28
 2185 0a58 0E94 0000 		call printErrorInfo
 2186 0a5c 00C0      		rjmp .L100
 2187               	.L98:
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 2189               	.LM167:
 2190 0a5e C801      		movw r24,r16
 2191 0a60 60E0      		ldi r22,lo8(fdVty)
 2192 0a62 70E0      		ldi r23,hi8(fdVty)
 2193 0a64 0E94 0000 		call ramDyskOtworzPlik
 2194 0a68 4A8D      		ldd r20,Y+26
 2195 0a6a 5B8D      		ldd r21,Y+27
 2196 0a6c 8823      		tst r24
 2197 0a6e 01F0      		breq .L99
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 2199               	.LM168:
 2200 0a70 00D0      		rcall .
 2201 0a72 00D0      		rcall .
 2202 0a74 00D0      		rcall .
 2203 0a76 EDB7      		in r30,__SP_L__
 2204 0a78 FEB7      		in r31,__SP_H__
 2205 0a7a 3196      		adiw r30,1
 2206 0a7c ADB7      		in r26,__SP_L__
 2207 0a7e BEB7      		in r27,__SP_H__
 2208 0a80 1296      		adiw r26,1+1
 2209 0a82 5C93      		st X,r21
 2210 0a84 4E93      		st -X,r20
 2211 0a86 1197      		sbiw r26,1
 2212 0a88 80E0      		ldi r24,lo8(errorOpenFile)
 2213 0a8a 90E0      		ldi r25,hi8(errorOpenFile)
 2214 0a8c 9383      		std Z+3,r25
 2215 0a8e 8283      		std Z+2,r24
 2216 0a90 1583      		std Z+5,r17
 2217 0a92 0483      		std Z+4,r16
 2218 0a94 0E94 0000 		call fprintf_P
 2219 0a98 24E0      		ldi r18,lo8(4)
 2220 0a9a 30E0      		ldi r19,hi8(4)
 2221 0a9c 8DB7      		in r24,__SP_L__
 2222 0a9e 9EB7      		in r25,__SP_H__
 2223 0aa0 0696      		adiw r24,6
 2224 0aa2 0FB6      		in __tmp_reg__,__SREG__
 2225 0aa4 F894      		cli
 2226 0aa6 9EBF      		out __SP_H__,r25
 2227 0aa8 0FBE      		out __SREG__,__tmp_reg__
 2228 0aaa 8DBF      		out __SP_L__,r24
 2229 0aac 00C0      		rjmp .L97
 2230               	.L99:
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 2232               	.LM169:
 2233 0aae 80E0      		ldi r24,lo8(fdVty)
 2234 0ab0 90E0      		ldi r25,hi8(fdVty)
 2235 0ab2 6F2D      		mov r22,r15
 2236 0ab4 0E94 0000 		call rs485xModemFlash
 2237 0ab8 182F      		mov r17,r24
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2239               	.LM170:
 2240 0aba 80E0      		ldi r24,lo8(fdVty)
 2241 0abc 90E0      		ldi r25,hi8(fdVty)
 2242 0abe 0E94 0000 		call ramDyskZamknijPlik
 643:vty.c         ****   if (blad != 0)
 2244               	.LM171:
 2245 0ac2 1123      		tst r17
 2246 0ac4 01F4      		brne .L100
 2247 0ac6 20E0      		ldi r18,lo8(0)
 2248 0ac8 30E0      		ldi r19,hi8(0)
 2249 0aca 00C0      		rjmp .L97
 2250               	.L100:
 2251 0acc 24E0      		ldi r18,lo8(4)
 2252 0ace 30E0      		ldi r19,hi8(4)
 2253               	.L97:
 647:vty.c         **** }
 2255               	.LM172:
 2256 0ad0 C901      		movw r24,r18
 2257               	/* epilogue start */
 2258 0ad2 DF91      		pop r29
 2259 0ad4 CF91      		pop r28
 2260 0ad6 1F91      		pop r17
 2261 0ad8 0F91      		pop r16
 2262 0ada FF90      		pop r15
 2263 0adc 0895      		ret
 2269               	.Lscope24:
 2271               		.stabd	78,0,0
 2275               	goXmodemOdbierzFunction:
 2276               		.stabd	46,0,0
 661:vty.c         **** {
 2278               	.LM173:
 2279               	.LFBB25:
 2280 0ade 2F92      		push r2
 2281 0ae0 3F92      		push r3
 2282 0ae2 4F92      		push r4
 2283 0ae4 5F92      		push r5
 2284 0ae6 6F92      		push r6
 2285 0ae8 7F92      		push r7
 2286 0aea 8F92      		push r8
 2287 0aec 9F92      		push r9
 2288 0aee AF92      		push r10
 2289 0af0 BF92      		push r11
 2290 0af2 CF92      		push r12
 2291 0af4 DF92      		push r13
 2292 0af6 EF92      		push r14
 2293 0af8 FF92      		push r15
 2294 0afa 0F93      		push r16
 2295 0afc 1F93      		push r17
 2296 0afe DF93      		push r29
 2297 0b00 CF93      		push r28
 2298 0b02 00D0      		rcall .
 2299 0b04 00D0      		rcall .
 2300 0b06 00D0      		rcall .
 2301 0b08 CDB7      		in r28,__SP_L__
 2302 0b0a DEB7      		in r29,__SP_H__
 2303               	/* prologue: function */
 2304               	/* frame size = 6 */
 2305 0b0c 7C01      		movw r14,r24
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 2307               	.LM174:
 2308 0b0e 00D0      		rcall .
 2309 0b10 00D0      		rcall .
 2310 0b12 DC01      		movw r26,r24
 2311 0b14 5A96      		adiw r26,26
 2312 0b16 8D91      		ld r24,X+
 2313 0b18 9C91      		ld r25,X
 2314 0b1a 5B97      		sbiw r26,26+1
 2315 0b1c EDB7      		in r30,__SP_L__
 2316 0b1e FEB7      		in r31,__SP_H__
 2317 0b20 9283      		std Z+2,r25
 2318 0b22 8183      		std Z+1,r24
 2319 0b24 80E0      		ldi r24,lo8(__c.3577)
 2320 0b26 90E0      		ldi r25,hi8(__c.3577)
 2321 0b28 9483      		std Z+4,r25
 2322 0b2a 8383      		std Z+3,r24
 2323 0b2c 0E94 0000 		call fprintf_P
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 2325               	.LM175:
 2326 0b30 0F90      		pop __tmp_reg__
 2327 0b32 0F90      		pop __tmp_reg__
 2328 0b34 0F90      		pop __tmp_reg__
 2329 0b36 0F90      		pop __tmp_reg__
 2330 0b38 81E0      		ldi r24,lo8(1)
 2331 0b3a B701      		movw r22,r14
 2332 0b3c 0E94 0000 		call cmdlineGetArgStr
 2333 0b40 60E0      		ldi r22,lo8(fdVty)
 2334 0b42 70E0      		ldi r23,hi8(fdVty)
 2335 0b44 0E94 0000 		call ramDyskOtworzPlik
 2336 0b48 8823      		tst r24
 2337 0b4a 01F0      		breq .L103
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 2339               	.LM176:
 2340 0b4c D701      		movw r26,r14
 2341 0b4e 5A96      		adiw r26,26
 2342 0b50 0D91      		ld r16,X+
 2343 0b52 1C91      		ld r17,X
 2344 0b54 5B97      		sbiw r26,26+1
 2345 0b56 81E0      		ldi r24,lo8(1)
 2346 0b58 B701      		movw r22,r14
 2347 0b5a 0E94 0000 		call cmdlineGetArgStr
 2348 0b5e 00D0      		rcall .
 2349 0b60 00D0      		rcall .
 2350 0b62 00D0      		rcall .
 2351 0b64 EDB7      		in r30,__SP_L__
 2352 0b66 FEB7      		in r31,__SP_H__
 2353 0b68 3196      		adiw r30,1
 2354 0b6a ADB7      		in r26,__SP_L__
 2355 0b6c BEB7      		in r27,__SP_H__
 2356 0b6e 1296      		adiw r26,1+1
 2357 0b70 1C93      		st X,r17
 2358 0b72 0E93      		st -X,r16
 2359 0b74 1197      		sbiw r26,1
 2360 0b76 20E0      		ldi r18,lo8(errorOpenFile)
 2361 0b78 30E0      		ldi r19,hi8(errorOpenFile)
 2362 0b7a 3383      		std Z+3,r19
 2363 0b7c 2283      		std Z+2,r18
 2364 0b7e 9583      		std Z+5,r25
 2365 0b80 8483      		std Z+4,r24
 2366 0b82 0E94 0000 		call fprintf_P
 2367 0b86 24E0      		ldi r18,lo8(4)
 2368 0b88 30E0      		ldi r19,hi8(4)
 2369 0b8a EDB7      		in r30,__SP_L__
 2370 0b8c FEB7      		in r31,__SP_H__
 2371 0b8e 3696      		adiw r30,6
 2372 0b90 0FB6      		in __tmp_reg__,__SREG__
 2373 0b92 F894      		cli
 2374 0b94 FEBF      		out __SP_H__,r31
 2375 0b96 0FBE      		out __SREG__,__tmp_reg__
 2376 0b98 EDBF      		out __SP_L__,r30
 2377 0b9a 00C0      		rjmp .L104
 2378               	.L103:
 688:vty.c         ****   state->err1=0;
 2380               	.LM177:
 2381 0b9c D701      		movw r26,r14
 2382 0b9e 5E96      		adiw r26,29+1
 2383 0ba0 1C92      		st X,__zero_reg__
 2384 0ba2 1E92      		st -X,__zero_reg__
 2385 0ba4 5D97      		sbiw r26,29
 689:vty.c         ****   state->err2=0;
 2387               	.LM178:
 2388 0ba6 5F96      		adiw r26,31
 2389 0ba8 1C92      		st X,__zero_reg__
 2390 0baa 04E1      		ldi r16,lo8(20)
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2392               	.LM179:
 2393 0bac B2E0      		ldi r27,lo8(2)
 2394 0bae CB2E      		mov r12,r27
 2395 0bb0 D12C      		mov r13,__zero_reg__
 2396 0bb2 CC0E      		add r12,r28
 2397 0bb4 DD1E      		adc r13,r29
 2398               	.L108:
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 2400               	.LM180:
 2401 0bb6 F701      		movw r30,r14
 2402 0bb8 628D      		ldd r22,Z+26
 2403 0bba 738D      		ldd r23,Z+27
 2404 0bbc 83E4      		ldi r24,lo8(67)
 2405 0bbe 90E0      		ldi r25,hi8(67)
 2406 0bc0 0E94 0000 		call fputc
 2407               	.L105:
 694:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 2409               	.LM181:
 2410 0bc4 8091 9B00 		lds r24,155
 2411 0bc8 86FF      		sbrs r24,6
 2412 0bca 00C0      		rjmp .L105
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2414               	.LM182:
 2415 0bcc 8091 0000 		lds r24,xVtyRec
 2416 0bd0 9091 0000 		lds r25,(xVtyRec)+1
 2417 0bd4 B601      		movw r22,r12
 2418 0bd6 44E6      		ldi r20,lo8(100)
 2419 0bd8 50E0      		ldi r21,hi8(100)
 2420 0bda 20E0      		ldi r18,lo8(0)
 2421 0bdc 0E94 0000 		call xQueueGenericReceive
 2422 0be0 8823      		tst r24
 2423 0be2 01F0      		breq .L106
 697:vty.c         ****       if (c == SOH)
 2425               	.LM183:
 2426 0be4 8A81      		ldd r24,Y+2
 2427 0be6 8130      		cpi r24,lo8(1)
 2428 0be8 01F0      		breq .L107
 2429               	.L106:
 700:vty.c         ****     liczbaProb--;
 2431               	.LM184:
 2432 0bea 0150      		subi r16,lo8(-(-1))
 701:vty.c         ****     if (liczbaProb == 0)
 2434               	.LM185:
 2435 0bec 01F4      		brne .L108
 703:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 2437               	.LM186:
 2438 0bee 80E0      		ldi r24,lo8(fdVty)
 2439 0bf0 90E0      		ldi r25,hi8(fdVty)
 2440 0bf2 0E94 0000 		call ramDyskZamknijPlik
 704:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2442               	.LM187:
 2443 0bf6 D701      		movw r26,r14
 2444 0bf8 5C96      		adiw r26,28
 2445 0bfa 1C92      		st X,__zero_reg__
 2446 0bfc 24E0      		ldi r18,lo8(4)
 2447 0bfe 30E0      		ldi r19,hi8(4)
 2448 0c00 00C0      		rjmp .L104
 2449               	.L107:
 712:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2451               	.LM188:
 2452 0c02 80E0      		ldi r24,lo8(fdVty)
 2453 0c04 90E0      		ldi r25,hi8(fdVty)
 2454 0c06 61E0      		ldi r22,lo8(1)
 2455 0c08 70E0      		ldi r23,hi8(1)
 2456 0c0a 0E94 0000 		call ramDyskDodajBlokXmodem
 2457 0c0e 6C01      		movw r12,r24
 2458 0c10 5C01      		movw r10,r24
 2459 0c12 AAE0      		ldi r26,lo8(10)
 2460 0c14 9A2E      		mov r9,r26
 2461 0c16 11E0      		ldi r17,lo8(1)
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2463               	.LM189:
 2464 0c18 F3E0      		ldi r31,lo8(3)
 2465 0c1a 8F2E      		mov r8,r31
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 2467               	.LM190:
 2468 0c1c E5E0      		ldi r30,lo8(5)
 2469 0c1e 2E2E      		mov r2,r30
 2470 0c20 312C      		mov r3,__zero_reg__
 2471 0c22 2C0E      		add r2,r28
 2472 0c24 3D1E      		adc r3,r29
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2474               	.LM191:
 2475 0c26 76E0      		ldi r23,lo8(6)
 2476 0c28 472E      		mov r4,r23
 2477 0c2a 512C      		mov r5,__zero_reg__
 2478 0c2c 4C0E      		add r4,r28
 2479 0c2e 5D1E      		adc r5,r29
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2481               	.LM192:
 2482 0c30 3E01      		movw r6,r28
 2483 0c32 0894      		sec
 2484 0c34 611C      		adc r6,__zero_reg__
 2485 0c36 711C      		adc r7,__zero_reg__
 2486               	.L126:
 716:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 2488               	.LM193:
 2489 0c38 8091 0000 		lds r24,xVtyRec
 2490 0c3c 9091 0000 		lds r25,(xVtyRec)+1
 2491 0c40 BE01      		movw r22,r28
 2492 0c42 6D5F      		subi r22,lo8(-(3))
 2493 0c44 7F4F      		sbci r23,hi8(-(3))
 2494 0c46 44E6      		ldi r20,lo8(100)
 2495 0c48 50E0      		ldi r21,hi8(100)
 2496 0c4a 20E0      		ldi r18,lo8(0)
 2497 0c4c 0E94 0000 		call xQueueGenericReceive
 2498 0c50 8823      		tst r24
 2499 0c52 01F4      		brne .+2
 2500 0c54 00C0      		rjmp .L135
 2501               	.L109:
 722:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 2503               	.LM194:
 2504 0c56 8091 0000 		lds r24,xVtyRec
 2505 0c5a 9091 0000 		lds r25,(xVtyRec)+1
 2506 0c5e BE01      		movw r22,r28
 2507 0c60 6C5F      		subi r22,lo8(-(4))
 2508 0c62 7F4F      		sbci r23,hi8(-(4))
 2509 0c64 41E0      		ldi r20,lo8(1)
 2510 0c66 50E0      		ldi r21,hi8(1)
 2511 0c68 20E0      		ldi r18,lo8(0)
 2512 0c6a 0E94 0000 		call xQueueGenericReceive
 2513 0c6e 8823      		tst r24
 2514 0c70 01F4      		brne .L111
 724:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 2516               	.LM195:
 2517 0c72 83E0      		ldi r24,lo8(3)
 2518 0c74 D701      		movw r26,r14
 2519 0c76 00C0      		rjmp .L136
 2520               	.L111:
 729:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 2522               	.LM196:
 2523 0c78 9C81      		ldd r25,Y+4
 2524 0c7a 892F      		mov r24,r25
 2525 0c7c 8095      		com r24
 2526 0c7e 8A83      		std Y+2,r24
 730:vty.c         ****     if (nrBlokuZdalny != c)
 2528               	.LM197:
 2529 0c80 0B81      		ldd r16,Y+3
 2530 0c82 0817      		cp r16,r24
 2531 0c84 01F0      		breq .L112
 732:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 2533               	.LM198:
 2534 0c86 85E0      		ldi r24,lo8(5)
 2535 0c88 F701      		movw r30,r14
 2536 0c8a 848F      		std Z+28,r24
 733:vty.c         ****       state->err1 = nrBlokuZdalny;
 2538               	.LM199:
 2539 0c8c 058F      		std Z+29,r16
 2540 0c8e 168E      		std Z+30,__zero_reg__
 734:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 2542               	.LM200:
 2543 0c90 978F      		std Z+31,r25
 2544 0c92 00C0      		rjmp .L110
 2545               	.L112:
 739:vty.c         ****     c = nrBloku-1;
 2547               	.LM201:
 2548 0c94 812F      		mov r24,r17
 2549 0c96 8150      		subi r24,lo8(-(-1))
 2550 0c98 8A83      		std Y+2,r24
 740:vty.c         ****     if (nrBlokuZdalny == c)
 2552               	.LM202:
 2553 0c9a 0817      		cp r16,r24
 2554 0c9c 01F0      		breq .L113
 2555 0c9e 012F      		mov r16,r17
 2556 0ca0 00C0      		rjmp .L114
 2557               	.L113:
 743:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2559               	.LM203:
 2560 0ca2 80E0      		ldi r24,lo8(fdVty)
 2561 0ca4 90E0      		ldi r25,hi8(fdVty)
 2562 0ca6 602F      		mov r22,r16
 2563 0ca8 70E0      		ldi r23,lo8(0)
 2564 0caa 0E94 0000 		call ramDyskDodajBlokXmodem
 2565 0cae 6C01      		movw r12,r24
 2566 0cb0 5C01      		movw r10,r24
 2567               	.L114:
 748:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 2569               	.LM204:
 2570 0cb2 1B81      		ldd r17,Y+3
 2571 0cb4 1017      		cp r17,r16
 2572 0cb6 01F0      		breq .L115
 750:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2574               	.LM205:
 2575 0cb8 84E0      		ldi r24,lo8(4)
 2576 0cba D701      		movw r26,r14
 2577 0cbc 5C96      		adiw r26,28
 2578 0cbe 8C93      		st X,r24
 2579 0cc0 5C97      		sbiw r26,28
 751:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 2581               	.LM206:
 2582 0cc2 8C81      		ldd r24,Y+4
 2583 0cc4 5D96      		adiw r26,29
 2584 0cc6 8C93      		st X,r24
 2585 0cc8 5D97      		sbiw r26,29
 2586 0cca 5E96      		adiw r26,30
 2587 0ccc 1C92      		st X,__zero_reg__
 2588 0cce 5E97      		sbiw r26,30
 752:vty.c         ****       state->err2 = nrBloku;
 2590               	.LM207:
 2591 0cd0 5F96      		adiw r26,31
 2592 0cd2 0C93      		st X,r16
 2593 0cd4 00C0      		rjmp .L110
 2594               	.L115:
 753:vty.c         ****       break;
 2596               	.LM208:
 2597 0cd6 00E0      		ldi r16,lo8(0)
 2598               	.L117:
 758:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 2600               	.LM209:
 2601 0cd8 8091 0000 		lds r24,xVtyRec
 2602 0cdc 9091 0000 		lds r25,(xVtyRec)+1
 2603 0ce0 BE01      		movw r22,r28
 2604 0ce2 6E5F      		subi r22,lo8(-(2))
 2605 0ce4 7F4F      		sbci r23,hi8(-(2))
 2606 0ce6 4AE0      		ldi r20,lo8(10)
 2607 0ce8 50E0      		ldi r21,hi8(10)
 2608 0cea 20E0      		ldi r18,lo8(0)
 2609 0cec 0E94 0000 		call xQueueGenericReceive
 2610 0cf0 8823      		tst r24
 2611 0cf2 01F0      		breq .L116
 759:vty.c         ****         *(zapPtr++) = c;
 2613               	.LM210:
 2614 0cf4 8A81      		ldd r24,Y+2
 2615 0cf6 F601      		movw r30,r12
 2616 0cf8 8193      		st Z+,r24
 2617 0cfa 6F01      		movw r12,r30
 756:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2619               	.LM211:
 2620 0cfc 0F5F      		subi r16,lo8(-(1))
 2621 0cfe 0038      		cpi r16,lo8(-128)
 2622 0d00 01F4      		brne .L117
 2623 0d02 00C0      		rjmp .L118
 2624               	.L116:
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2626               	.LM212:
 2627 0d04 D701      		movw r26,r14
 2628 0d06 5C96      		adiw r26,28
 2629 0d08 8C92      		st X,r8
 2630               	.L118:
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 2632               	.LM213:
 2633 0d0a 8091 0000 		lds r24,xVtyRec
 2634 0d0e 9091 0000 		lds r25,(xVtyRec)+1
 2635 0d12 B101      		movw r22,r2
 2636 0d14 4AE0      		ldi r20,lo8(10)
 2637 0d16 50E0      		ldi r21,hi8(10)
 2638 0d18 20E0      		ldi r18,lo8(0)
 2639 0d1a 0E94 0000 		call xQueueGenericReceive
 2640 0d1e 8823      		tst r24
 2641 0d20 01F4      		brne .L119
 768:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2643               	.LM214:
 2644 0d22 86E0      		ldi r24,lo8(6)
 2645 0d24 F701      		movw r30,r14
 2646 0d26 848F      		std Z+28,r24
 769:vty.c         ****         state->err1 = 2;
 2648               	.LM215:
 2649 0d28 82E0      		ldi r24,lo8(2)
 2650 0d2a 90E0      		ldi r25,hi8(2)
 2651 0d2c 968F      		std Z+30,r25
 2652 0d2e 858F      		std Z+29,r24
 2653 0d30 00C0      		rjmp .L110
 2654               	.L119:
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2656               	.LM216:
 2657 0d32 8091 0000 		lds r24,xVtyRec
 2658 0d36 9091 0000 		lds r25,(xVtyRec)+1
 2659 0d3a B201      		movw r22,r4
 2660 0d3c 4AE0      		ldi r20,lo8(10)
 2661 0d3e 50E0      		ldi r21,hi8(10)
 2662 0d40 20E0      		ldi r18,lo8(0)
 2663 0d42 0E94 0000 		call xQueueGenericReceive
 2664 0d46 8823      		tst r24
 2665 0d48 01F4      		brne .L120
 774:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2667               	.LM217:
 2668 0d4a 86E0      		ldi r24,lo8(6)
 2669 0d4c D701      		movw r26,r14
 2670 0d4e 5C96      		adiw r26,28
 2671 0d50 8C93      		st X,r24
 2672 0d52 5C97      		sbiw r26,28
 775:vty.c         ****         state->err1 = 1;
 2674               	.LM218:
 2675 0d54 81E0      		ldi r24,lo8(1)
 2676 0d56 90E0      		ldi r25,hi8(1)
 2677 0d58 5E96      		adiw r26,29+1
 2678 0d5a 9C93      		st X,r25
 2679 0d5c 8E93      		st -X,r24
 2680 0d5e 5D97      		sbiw r26,29
 2681 0d60 00C0      		rjmp .L110
 2682               	.L120:
 776:vty.c         ****         break;      
 2684               	.LM219:
 2685 0d62 90E0      		ldi r25,lo8(0)
 2686 0d64 40E0      		ldi r20,lo8(0)
 2687 0d66 50E0      		ldi r21,hi8(0)
 2688               	.L121:
 784:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 2690               	.LM220:
 2691 0d68 F501      		movw r30,r10
 2692 0d6a 8191      		ld r24,Z+
 2693 0d6c 5F01      		movw r10,r30
 2694               	.LBB6:
 2695               	.LBB7:
 2697               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
   5:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
   8:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  11:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  16:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  20:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  32:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /* $Id: crc16.h,v 1.4 2007/01/23 15:32:48 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  34:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  35:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  36:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  37:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #include <stdint.h>
  38:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  39:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \file */
  40:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  41:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  42:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  43:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  44:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  45:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  46:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par References:
  47:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  48:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par
  49:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  50:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  51:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  52:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  53:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  54:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par
  55:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  56:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  57:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  58:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  59:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     obtain a copy.
  60:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  61:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     A typical application would look like:
  62:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  63:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
  64:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     // Dallas iButton test vector.
  65:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  66:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  67:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     int
  68:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     checkcrc(void)
  69:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
  70:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  71:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  72:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  73:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  74:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  75:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return crc; // must be 0
  76:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
  77:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode
  78:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** */
  79:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  80:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
  81:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  82:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  83:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  84:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Initial value: 0xffff
  85:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  86:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  87:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  88:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  89:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  90:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
  91:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t
  92:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  93:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
  94:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	int i;
  95:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  96:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	crc ^= a;
  97:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
  98:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	{
  99:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    if (crc & 1)
 100:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 101:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    else
 102:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1);
 103:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	}
 104:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 105:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return crc;
 106:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
 107:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 108:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode */
 109:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 110:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 111:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 112:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** {
 113:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint8_t __tmp;
 114:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint16_t __ret;
 115:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 116:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 117:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 118:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 119:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 120:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 121:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 122:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 123:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 124:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 125:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 126:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 127:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 128:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 129:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 130:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 131:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 132:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 133:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 134:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 135:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 136:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 137:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 138:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 139:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%1"
 140:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 141:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 142:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "r0"
 143:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	);
 144:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return __ret;
 145:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** }
 146:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 147:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
 148:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 149:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 150:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 151:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Initial value: 0x0
 152:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 153:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 154:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 155:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 156:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 157:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
 158:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t
 159:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 160:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
 161:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         int i;
 162:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 163:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 164:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 165:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         {
 166:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****             if (crc & 0x8000)
 167:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 168:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****             else
 169:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                 crc <<= 1;
 170:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         }
 171:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 172:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         return crc;
 173:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
 174:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode */
 175:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 176:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 177:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 178:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** {
 179:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 180:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 181:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 182:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                                 /* %3  __data */
 183:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 184:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     __asm__ __volatile__ (
 2699               	.LM221:
 2700               	/* #APP */
 2701               	 ;  184 "/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h" 1
 2702 0d6e 5827      		eor    r21,r24
 2703 0d70 052E      		mov    __tmp_reg__,r21
 2704 0d72 0294      		swap   __tmp_reg__
 2705 0d74 802D      		mov    r24,__tmp_reg__
 2706 0d76 8F70      		andi   r24,0x0f
 2707 0d78 8527      		eor    r24,r21
 2708 0d7a 252F      		mov    r18,r21
 2709 0d7c 2025      		eor    r18,__tmp_reg__
 2710 0d7e 220F      		lsl    r18
 2711 0d80 207E      		andi   r18,0xe0
 2712 0d82 8227      		eor    r24,r18
 2713 0d84 202D      		mov    r18,__tmp_reg__
 2714 0d86 2527      		eor    r18,r21
 2715 0d88 207F      		andi   r18,0xf0
 2716 0d8a 2695      		lsr    r18
 2717 0d8c 052E      		mov    __tmp_reg__,r21
 2718 0d8e 000C      		lsl    __tmp_reg__
 2719 0d90 221F      		rol    r18
 2720 0d92 5695      		lsr    r21
 2721 0d94 5695      		lsr    r21
 2722 0d96 5695      		lsr    r21
 2723 0d98 5F71      		andi   r21,0x1f
 2724 0d9a 5227      		eor    r21,r18
 2725 0d9c 5427      		eor    r21,r20
 2726 0d9e 482F      		mov    r20,r24
 2727               		
 2728               	 ;  0 "" 2
 2729               	/* #NOAPP */
 2730               	.LBE7:
 2731               	.LBE6:
 2733               	.Ltext2:
 783:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2735               	.LM222:
 2736 0da0 9F5F      		subi r25,lo8(-(1))
 2737 0da2 9038      		cpi r25,lo8(-128)
 2738 0da4 01F4      		brne .L121
 787:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 2740               	.LM223:
 2741 0da6 8D81      		ldd r24,Y+5
 2742 0da8 90E0      		ldi r25,lo8(0)
 2743 0daa 252F      		mov r18,r21
 2744 0dac 3327      		clr r19
 2745 0dae 8217      		cp r24,r18
 2746 0db0 9307      		cpc r25,r19
 2747 0db2 01F4      		brne .L122
 2748 0db4 8E81      		ldd r24,Y+6
 2749 0db6 90E0      		ldi r25,lo8(0)
 2750 0db8 5070      		andi r21,hi8(255)
 2751 0dba 8417      		cp r24,r20
 2752 0dbc 9507      		cpc r25,r21
 2753 0dbe 01F4      		brne .L122
 790:vty.c         ****       uartVtySendByte(ACK);      
 2755               	.LM224:
 2756 0dc0 86E0      		ldi r24,lo8(6)
 2757 0dc2 0E94 0000 		call uartVtySendByte
 2758 0dc6 4AE0      		ldi r20,lo8(10)
 2759 0dc8 942E      		mov r9,r20
 2760 0dca 00C0      		rjmp .L123
 2761               	.L122:
 794:vty.c         ****       liczbaProb--;
 2763               	.LM225:
 2764 0dcc 9A94      		dec r9
 795:vty.c         ****       nrBloku--;
 2766               	.LM226:
 2767 0dce 1150      		subi r17,lo8(-(-1))
 796:vty.c         ****       uartVtySendByte(NAK);   
 2769               	.LM227:
 2770 0dd0 85E1      		ldi r24,lo8(21)
 2771 0dd2 0E94 0000 		call uartVtySendByte
 799:vty.c         ****     if (liczbaProb == 0)
 2773               	.LM228:
 2774 0dd6 9920      		tst r9
 2775 0dd8 01F4      		brne .L123
 801:vty.c         ****       state->err1 = nrBlokuZdalny;
 2777               	.LM229:
 2778 0dda 8B81      		ldd r24,Y+3
 2779 0ddc D701      		movw r26,r14
 2780 0dde 5D96      		adiw r26,29
 2781 0de0 8C93      		st X,r24
 2782 0de2 5D97      		sbiw r26,29
 2783 0de4 5E96      		adiw r26,30
 2784 0de6 1C92      		st X,__zero_reg__
 2785 0de8 5E97      		sbiw r26,30
 802:vty.c         ****       state->err2 = nrBloku;
 2787               	.LM230:
 2788 0dea 5F96      		adiw r26,31
 2789 0dec 1C93      		st X,r17
 2790 0dee 5F97      		sbiw r26,31
 803:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2792               	.LM231:
 2793 0df0 84E0      		ldi r24,lo8(4)
 2794               	.L136:
 2795 0df2 5C96      		adiw r26,28
 2796 0df4 8C93      		st X,r24
 2797 0df6 00C0      		rjmp .L110
 2798               	.L123:
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2800               	.LM232:
 2801 0df8 8091 0000 		lds r24,xVtyRec
 2802 0dfc 9091 0000 		lds r25,(xVtyRec)+1
 2803 0e00 B301      		movw r22,r6
 2804 0e02 44E6      		ldi r20,lo8(100)
 2805 0e04 50E0      		ldi r21,hi8(100)
 2806 0e06 20E0      		ldi r18,lo8(0)
 2807 0e08 0E94 0000 		call xQueueGenericReceive
 2808 0e0c 8823      		tst r24
 2809 0e0e 01F4      		brne .L124
 2810               	.L135:
 809:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 2812               	.LM233:
 2813 0e10 82E0      		ldi r24,lo8(2)
 2814 0e12 F701      		movw r30,r14
 2815 0e14 00C0      		rjmp .L137
 2816               	.L124:
 813:vty.c         ****     if (temp1 == SOH)
 2818               	.LM234:
 2819 0e16 9981      		ldd r25,Y+1
 2820 0e18 9130      		cpi r25,lo8(1)
 2821 0e1a 01F4      		brne .L125
 815:vty.c         ****       nrBloku++;
 2823               	.LM235:
 2824 0e1c 1F5F      		subi r17,lo8(-(1))
 816:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2826               	.LM236:
 2827 0e1e 80E0      		ldi r24,lo8(fdVty)
 2828 0e20 90E0      		ldi r25,hi8(fdVty)
 2829 0e22 612F      		mov r22,r17
 2830 0e24 70E0      		ldi r23,lo8(0)
 2831 0e26 0E94 0000 		call ramDyskDodajBlokXmodem
 2832 0e2a 6C01      		movw r12,r24
 818:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2834               	.LM237:
 2835 0e2c D701      		movw r26,r14
 2836 0e2e 5C96      		adiw r26,28
 2837 0e30 1C92      		st X,__zero_reg__
 2838 0e32 5C01      		movw r10,r24
 2839 0e34 00C0      		rjmp .L126
 2840               	.L125:
 822:vty.c         ****     if (temp1 == CAN)
 2842               	.LM238:
 2843 0e36 9831      		cpi r25,lo8(24)
 2844 0e38 01F4      		brne .L127
 824:vty.c         ****       state->err1 = nrBloku;
 2846               	.LM239:
 2847 0e3a F701      		movw r30,r14
 2848 0e3c 158F      		std Z+29,r17
 2849 0e3e 168E      		std Z+30,__zero_reg__
 825:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 2851               	.LM240:
 2852 0e40 87E0      		ldi r24,lo8(7)
 2853               	.L137:
 2854 0e42 848F      		std Z+28,r24
 2855 0e44 00C0      		rjmp .L110
 2856               	.L127:
 828:vty.c         ****     if (temp1 == EOT)
 2858               	.LM241:
 2859 0e46 9430      		cpi r25,lo8(4)
 2860 0e48 01F4      		brne .L128
 830:vty.c         ****       uartVtySendByte(NAK);
 2862               	.LM242:
 2863 0e4a 85E1      		ldi r24,lo8(21)
 2864 0e4c 0E94 0000 		call uartVtySendByte
 831:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 2866               	.LM243:
 2867 0e50 8091 0000 		lds r24,xVtyRec
 2868 0e54 9091 0000 		lds r25,(xVtyRec)+1
 2869 0e58 B301      		movw r22,r6
 2870 0e5a 4AE0      		ldi r20,lo8(10)
 2871 0e5c 50E0      		ldi r21,hi8(10)
 2872 0e5e 20E0      		ldi r18,lo8(0)
 2873 0e60 0E94 0000 		call xQueueGenericReceive
 2874 0e64 8823      		tst r24
 2875 0e66 01F0      		breq .L129
 833:vty.c         ****         if (temp1 == EOT)
 2877               	.LM244:
 2878 0e68 8981      		ldd r24,Y+1
 2879 0e6a 8430      		cpi r24,lo8(4)
 2880 0e6c 01F4      		brne .L129
 834:vty.c         ****           uartVtySendByte(ACK);  
 2882               	.LM245:
 2883 0e6e 86E0      		ldi r24,lo8(6)
 2884 0e70 0E94 0000 		call uartVtySendByte
 2885               	.L129:
 836:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2887               	.LM246:
 2888 0e74 D701      		movw r26,r14
 2889 0e76 5C96      		adiw r26,28
 2890 0e78 1C92      		st X,__zero_reg__
 2891 0e7a 00C0      		rjmp .L110
 2892               	.L128:
 839:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 2894               	.LM247:
 2895 0e7c 88E0      		ldi r24,lo8(8)
 2896 0e7e F701      		movw r30,r14
 2897 0e80 848F      		std Z+28,r24
 840:vty.c         ****     state->err1 = temp1;
 2899               	.LM248:
 2900 0e82 958F      		std Z+29,r25
 2901 0e84 168E      		std Z+30,__zero_reg__
 2902               	.L110:
 843:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2904               	.LM249:
 2905 0e86 80E0      		ldi r24,lo8(fdVty)
 2906 0e88 90E0      		ldi r25,hi8(fdVty)
 2907 0e8a 0E94 0000 		call ramDyskZamknijPlik
 2908 0e8e 20E0      		ldi r18,lo8(0)
 2909 0e90 30E0      		ldi r19,hi8(0)
 2910               	.L104:
 845:vty.c         **** }
 2912               	.LM250:
 2913 0e92 C901      		movw r24,r18
 2914               	/* epilogue start */
 2915 0e94 2696      		adiw r28,6
 2916 0e96 0FB6      		in __tmp_reg__,__SREG__
 2917 0e98 F894      		cli
 2918 0e9a DEBF      		out __SP_H__,r29
 2919 0e9c 0FBE      		out __SREG__,__tmp_reg__
 2920 0e9e CDBF      		out __SP_L__,r28
 2921 0ea0 CF91      		pop r28
 2922 0ea2 DF91      		pop r29
 2923 0ea4 1F91      		pop r17
 2924 0ea6 0F91      		pop r16
 2925 0ea8 FF90      		pop r15
 2926 0eaa EF90      		pop r14
 2927 0eac DF90      		pop r13
 2928 0eae CF90      		pop r12
 2929 0eb0 BF90      		pop r11
 2930 0eb2 AF90      		pop r10
 2931 0eb4 9F90      		pop r9
 2932 0eb6 8F90      		pop r8
 2933 0eb8 7F90      		pop r7
 2934 0eba 6F90      		pop r6
 2935 0ebc 5F90      		pop r5
 2936 0ebe 4F90      		pop r4
 2937 0ec0 3F90      		pop r3
 2938 0ec2 2F90      		pop r2
 2939 0ec4 0895      		ret
 2955               	.Lscope25:
 2957               		.stabd	78,0,0
 2961               	debugFunction:
 2962               		.stabd	46,0,0
 303:vty.c         **** {
 2964               	.LM251:
 2965               	.LFBB26:
 2966 0ec6 FF92      		push r15
 2967 0ec8 0F93      		push r16
 2968 0eca 1F93      		push r17
 2969 0ecc CF93      		push r28
 2970 0ece DF93      		push r29
 2971               	/* prologue: function */
 2972               	/* frame size = 0 */
 2973 0ed0 EC01      		movw r28,r24
 304:vty.c         ****   if (state->argc < 2)
 2975               	.LM252:
 2976 0ed2 898D      		ldd r24,Y+25
 2977 0ed4 8230      		cpi r24,lo8(2)
 2978 0ed6 00F4      		brsh .+2
 2979 0ed8 00C0      		rjmp .L139
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 2981               	.LM253:
 2982 0eda 82E0      		ldi r24,lo8(2)
 2983 0edc BE01      		movw r22,r28
 2984 0ede 0E94 0000 		call cmdlineGetArgInt
 2985 0ee2 F62E      		mov r15,r22
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 2987               	.LM254:
 2988 0ee4 81E0      		ldi r24,lo8(1)
 2989 0ee6 BE01      		movw r22,r28
 2990 0ee8 0E94 0000 		call cmdlineGetArgStr
 2991 0eec 8C01      		movw r16,r24
 309:vty.c         ****   if (level == 0)
 2993               	.LM255:
 2994 0eee FF20      		tst r15
 2995 0ef0 01F0      		breq .+2
 2996 0ef2 00C0      		rjmp .L140
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 2998               	.LM256:
 2999 0ef4 60E0      		ldi r22,lo8(__c.3311)
 3000 0ef6 70E0      		ldi r23,hi8(__c.3311)
 3001 0ef8 43E0      		ldi r20,lo8(3)
 3002 0efa 50E0      		ldi r21,hi8(3)
 3003 0efc 0E94 0000 		call strncmp_P
 3004 0f00 892B      		or r24,r25
 3005 0f02 01F4      		brne .L141
 313:vty.c         ****       setArpDebug(NULL, 0);
 3007               	.LM257:
 3008 0f04 80E0      		ldi r24,lo8(0)
 3009 0f06 90E0      		ldi r25,hi8(0)
 3010 0f08 60E0      		ldi r22,lo8(0)
 3011 0f0a 0E94 0000 		call setArpDebug
 3012 0f0e 00C0      		rjmp .L152
 3013               	.L141:
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3015               	.LM258:
 3016 0f10 C801      		movw r24,r16
 3017 0f12 60E0      		ldi r22,lo8(__c.3313)
 3018 0f14 70E0      		ldi r23,hi8(__c.3313)
 3019 0f16 42E0      		ldi r20,lo8(2)
 3020 0f18 50E0      		ldi r21,hi8(2)
 3021 0f1a 0E94 0000 		call strncmp_P
 3022 0f1e 892B      		or r24,r25
 3023 0f20 01F4      		brne .L143
 320:vty.c         ****       setIpDebug(NULL, 0);
 3025               	.LM259:
 3026 0f22 80E0      		ldi r24,lo8(0)
 3027 0f24 90E0      		ldi r25,hi8(0)
 3028 0f26 60E0      		ldi r22,lo8(0)
 3029 0f28 0E94 0000 		call setIpDebug
 3030 0f2c 00C0      		rjmp .L152
 3031               	.L143:
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3033               	.LM260:
 3034 0f2e C801      		movw r24,r16
 3035 0f30 60E0      		ldi r22,lo8(__c.3315)
 3036 0f32 70E0      		ldi r23,hi8(__c.3315)
 3037 0f34 42E0      		ldi r20,lo8(2)
 3038 0f36 50E0      		ldi r21,hi8(2)
 3039 0f38 0E94 0000 		call strncmp_P
 3040 0f3c 892B      		or r24,r25
 3041 0f3e 01F4      		brne .L144
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 3043               	.LM261:
 3044 0f40 80E0      		ldi r24,lo8(0)
 3045 0f42 90E0      		ldi r25,hi8(0)
 3046 0f44 60E0      		ldi r22,lo8(0)
 3047 0f46 0E94 0000 		call setIcmpDebug
 3048 0f4a 00C0      		rjmp .L152
 3049               	.L144:
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3051               	.LM262:
 3052 0f4c C801      		movw r24,r16
 3053 0f4e 60E0      		ldi r22,lo8(__c.3317)
 3054 0f50 70E0      		ldi r23,hi8(__c.3317)
 3055 0f52 42E0      		ldi r20,lo8(2)
 3056 0f54 50E0      		ldi r21,hi8(2)
 3057 0f56 0E94 0000 		call strncmp_P
 3058 0f5a 892B      		or r24,r25
 3059 0f5c 01F4      		brne .L145
 334:vty.c         ****       setTcpDebug(NULL, 0);
 3061               	.LM263:
 3062 0f5e 80E0      		ldi r24,lo8(0)
 3063 0f60 90E0      		ldi r25,hi8(0)
 3064 0f62 60E0      		ldi r22,lo8(0)
 3065 0f64 0E94 0000 		call setTcpDebug
 3066               	.L152:
 335:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 3068               	.LM264:
 3069 0f68 00D0      		rcall .
 3070 0f6a 00D0      		rcall .
 3071 0f6c 00D0      		rcall .
 3072 0f6e EDB7      		in r30,__SP_L__
 3073 0f70 FEB7      		in r31,__SP_H__
 3074 0f72 3196      		adiw r30,1
 3075 0f74 8A8D      		ldd r24,Y+26
 3076 0f76 9B8D      		ldd r25,Y+27
 3077 0f78 ADB7      		in r26,__SP_L__
 3078 0f7a BEB7      		in r27,__SP_H__
 3079 0f7c 1296      		adiw r26,1+1
 3080 0f7e 9C93      		st X,r25
 3081 0f80 8E93      		st -X,r24
 3082 0f82 1197      		sbiw r26,1
 3083 0f84 80E0      		ldi r24,lo8(debugDisabledInfoStr)
 3084 0f86 90E0      		ldi r25,hi8(debugDisabledInfoStr)
 3085 0f88 00C0      		rjmp .L151
 3086               	.L145:
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3088               	.LM265:
 3089 0f8a C801      		movw r24,r16
 3090 0f8c 60E0      		ldi r22,lo8(__c.3319)
 3091 0f8e 70E0      		ldi r23,hi8(__c.3319)
 3092 0f90 42E0      		ldi r20,lo8(2)
 3093 0f92 50E0      		ldi r21,hi8(2)
 3094 0f94 0E94 0000 		call strncmp_P
 3095 0f98 892B      		or r24,r25
 3096 0f9a 01F0      		breq .+2
 3097 0f9c 00C0      		rjmp .L139
 341:vty.c         ****       setUdpDebug(NULL, 0);
 3099               	.LM266:
 3100 0f9e 80E0      		ldi r24,lo8(0)
 3101 0fa0 90E0      		ldi r25,hi8(0)
 3102 0fa2 60E0      		ldi r22,lo8(0)
 3103 0fa4 0E94 0000 		call setUdpDebug
 3104 0fa8 00C0      		rjmp .L152
 3105               	.L140:
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 3107               	.LM267:
 3108 0faa 60E0      		ldi r22,lo8(__c.3321)
 3109 0fac 70E0      		ldi r23,hi8(__c.3321)
 3110 0fae 43E0      		ldi r20,lo8(3)
 3111 0fb0 50E0      		ldi r21,hi8(3)
 3112 0fb2 0E94 0000 		call strncmp_P
 3113 0fb6 892B      		or r24,r25
 3114 0fb8 01F4      		brne .L146
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 3116               	.LM268:
 3117 0fba 8A8D      		ldd r24,Y+26
 3118 0fbc 9B8D      		ldd r25,Y+27
 3119 0fbe 6F2D      		mov r22,r15
 3120 0fc0 0E94 0000 		call setArpDebug
 3121 0fc4 00C0      		rjmp .L153
 3122               	.L146:
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3124               	.LM269:
 3125 0fc6 C801      		movw r24,r16
 3126 0fc8 60E0      		ldi r22,lo8(__c.3323)
 3127 0fca 70E0      		ldi r23,hi8(__c.3323)
 3128 0fcc 42E0      		ldi r20,lo8(2)
 3129 0fce 50E0      		ldi r21,hi8(2)
 3130 0fd0 0E94 0000 		call strncmp_P
 3131 0fd4 892B      		or r24,r25
 3132 0fd6 01F4      		brne .L147
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 3134               	.LM270:
 3135 0fd8 8A8D      		ldd r24,Y+26
 3136 0fda 9B8D      		ldd r25,Y+27
 3137 0fdc 6F2D      		mov r22,r15
 3138 0fde 0E94 0000 		call setIpDebug
 3139 0fe2 00C0      		rjmp .L153
 3140               	.L147:
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3142               	.LM271:
 3143 0fe4 C801      		movw r24,r16
 3144 0fe6 60E0      		ldi r22,lo8(__c.3325)
 3145 0fe8 70E0      		ldi r23,hi8(__c.3325)
 3146 0fea 42E0      		ldi r20,lo8(2)
 3147 0fec 50E0      		ldi r21,hi8(2)
 3148 0fee 0E94 0000 		call strncmp_P
 3149 0ff2 892B      		or r24,r25
 3150 0ff4 01F4      		brne .L148
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 3152               	.LM272:
 3153 0ff6 8A8D      		ldd r24,Y+26
 3154 0ff8 9B8D      		ldd r25,Y+27
 3155 0ffa 6F2D      		mov r22,r15
 3156 0ffc 0E94 0000 		call setIcmpDebug
 3157 1000 00C0      		rjmp .L153
 3158               	.L148:
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3160               	.LM273:
 3161 1002 C801      		movw r24,r16
 3162 1004 60E0      		ldi r22,lo8(__c.3327)
 3163 1006 70E0      		ldi r23,hi8(__c.3327)
 3164 1008 42E0      		ldi r20,lo8(2)
 3165 100a 50E0      		ldi r21,hi8(2)
 3166 100c 0E94 0000 		call strncmp_P
 3167 1010 892B      		or r24,r25
 3168 1012 01F4      		brne .L149
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 3170               	.LM274:
 3171 1014 8A8D      		ldd r24,Y+26
 3172 1016 9B8D      		ldd r25,Y+27
 3173 1018 6F2D      		mov r22,r15
 3174 101a 0E94 0000 		call setTcpDebug
 3175               	.L153:
 374:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 3177               	.LM275:
 3178 101e 00D0      		rcall .
 3179 1020 00D0      		rcall .
 3180 1022 00D0      		rcall .
 3181 1024 EDB7      		in r30,__SP_L__
 3182 1026 FEB7      		in r31,__SP_H__
 3183 1028 3196      		adiw r30,1
 3184 102a 8A8D      		ldd r24,Y+26
 3185 102c 9B8D      		ldd r25,Y+27
 3186 102e ADB7      		in r26,__SP_L__
 3187 1030 BEB7      		in r27,__SP_H__
 3188 1032 1296      		adiw r26,1+1
 3189 1034 9C93      		st X,r25
 3190 1036 8E93      		st -X,r24
 3191 1038 1197      		sbiw r26,1
 3192 103a 80E0      		ldi r24,lo8(debugEnabledInfoStr)
 3193 103c 90E0      		ldi r25,hi8(debugEnabledInfoStr)
 3194               	.L151:
 3195 103e 9383      		std Z+3,r25
 3196 1040 8283      		std Z+2,r24
 3197 1042 1583      		std Z+5,r17
 3198 1044 0483      		std Z+4,r16
 3199 1046 0E94 0000 		call fprintf_P
 3200 104a 20E0      		ldi r18,lo8(0)
 3201 104c 30E0      		ldi r19,hi8(0)
 3202 104e 8DB7      		in r24,__SP_L__
 3203 1050 9EB7      		in r25,__SP_H__
 3204 1052 0696      		adiw r24,6
 3205 1054 0FB6      		in __tmp_reg__,__SREG__
 3206 1056 F894      		cli
 3207 1058 9EBF      		out __SP_H__,r25
 3208 105a 0FBE      		out __SREG__,__tmp_reg__
 3209 105c 8DBF      		out __SP_L__,r24
 3210 105e 00C0      		rjmp .L142
 3211               	.L149:
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3213               	.LM276:
 3214 1060 C801      		movw r24,r16
 3215 1062 60E0      		ldi r22,lo8(__c.3329)
 3216 1064 70E0      		ldi r23,hi8(__c.3329)
 3217 1066 42E0      		ldi r20,lo8(2)
 3218 1068 50E0      		ldi r21,hi8(2)
 3219 106a 0E94 0000 		call strncmp_P
 3220 106e 892B      		or r24,r25
 3221 1070 01F4      		brne .L139
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 3223               	.LM277:
 3224 1072 8A8D      		ldd r24,Y+26
 3225 1074 9B8D      		ldd r25,Y+27
 3226 1076 6F2D      		mov r22,r15
 3227 1078 0E94 0000 		call setUdpDebug
 3228 107c 00C0      		rjmp .L153
 3229               	.L139:
 382:vty.c         ****       return OK_SILENT;  
 3231               	.LM278:
 3232 107e 22E0      		ldi r18,lo8(2)
 3233 1080 30E0      		ldi r19,hi8(2)
 3234               	.L142:
 387:vty.c         **** }
 3236               	.LM279:
 3237 1082 C901      		movw r24,r18
 3238               	/* epilogue start */
 3239 1084 DF91      		pop r29
 3240 1086 CF91      		pop r28
 3241 1088 1F91      		pop r17
 3242 108a 0F91      		pop r16
 3243 108c FF90      		pop r15
 3244 108e 0895      		ret
 3246               	.Lscope26:
 3248               		.stabd	78,0,0
 3252               	statusEncFunction:
 3253               		.stabd	46,0,0
 287:vty.c         **** {
 3255               	.LM280:
 3256               	.LFBB27:
 3257               	/* prologue: function */
 3258               	/* frame size = 0 */
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 3260               	.LM281:
 3261 1090 FC01      		movw r30,r24
 3262 1092 828D      		ldd r24,Z+26
 3263 1094 938D      		ldd r25,Z+27
 3264 1096 0E94 0000 		call nicRegDump
 290:vty.c         **** }
 3266               	.LM282:
 3267 109a 80E0      		ldi r24,lo8(0)
 3268 109c 90E0      		ldi r25,hi8(0)
 3269               	/* epilogue start */
 3270 109e 0895      		ret
 3272               	.Lscope27:
 3274               		.stabd	78,0,0
 3278               	readRamFIleFunction:
 3279               		.stabd	46,0,0
 901:vty.c         **** {
 3281               	.LM283:
 3282               	.LFBB28:
 3283 10a0 CF92      		push r12
 3284 10a2 DF92      		push r13
 3285 10a4 EF92      		push r14
 3286 10a6 FF92      		push r15
 3287 10a8 0F93      		push r16
 3288 10aa 1F93      		push r17
 3289 10ac DF93      		push r29
 3290 10ae CF93      		push r28
 3291 10b0 0F92      		push __tmp_reg__
 3292 10b2 CDB7      		in r28,__SP_L__
 3293 10b4 DEB7      		in r29,__SP_H__
 3294               	/* prologue: function */
 3295               	/* frame size = 1 */
 3296 10b6 8C01      		movw r16,r24
 903:vty.c         ****   uint8_t znak = ' ';
 3298               	.LM284:
 3299 10b8 80E2      		ldi r24,lo8(32)
 3300 10ba 8983      		std Y+1,r24
 904:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 3302               	.LM285:
 3303 10bc 81E0      		ldi r24,lo8(1)
 3304 10be B801      		movw r22,r16
 3305 10c0 0E94 0000 		call cmdlineGetArgStr
 3306 10c4 60E0      		ldi r22,lo8(fdVty)
 3307 10c6 70E0      		ldi r23,hi8(fdVty)
 3308 10c8 0E94 0000 		call ramDyskOtworzPlik
 3309 10cc D801      		movw r26,r16
 3310 10ce 5A96      		adiw r26,26
 3311 10d0 ED90      		ld r14,X+
 3312 10d2 FC90      		ld r15,X
 3313 10d4 5B97      		sbiw r26,26+1
 3314 10d6 8823      		tst r24
 3315 10d8 01F0      		breq .L157
 906:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 3317               	.LM286:
 3318 10da 81E0      		ldi r24,lo8(1)
 3319 10dc B801      		movw r22,r16
 3320 10de 0E94 0000 		call cmdlineGetArgStr
 3321 10e2 00D0      		rcall .
 3322 10e4 00D0      		rcall .
 3323 10e6 00D0      		rcall .
 3324 10e8 EDB7      		in r30,__SP_L__
 3325 10ea FEB7      		in r31,__SP_H__
 3326 10ec 3196      		adiw r30,1
 3327 10ee ADB7      		in r26,__SP_L__
 3328 10f0 BEB7      		in r27,__SP_H__
 3329 10f2 1296      		adiw r26,1+1
 3330 10f4 FC92      		st X,r15
 3331 10f6 EE92      		st -X,r14
 3332 10f8 1197      		sbiw r26,1
 3333 10fa 20E0      		ldi r18,lo8(errorOpenFile)
 3334 10fc 30E0      		ldi r19,hi8(errorOpenFile)
 3335 10fe 3383      		std Z+3,r19
 3336 1100 2283      		std Z+2,r18
 3337 1102 9583      		std Z+5,r25
 3338 1104 8483      		std Z+4,r24
 3339 1106 0E94 0000 		call fprintf_P
 3340 110a 24E0      		ldi r18,lo8(4)
 3341 110c 30E0      		ldi r19,hi8(4)
 3342 110e EDB7      		in r30,__SP_L__
 3343 1110 FEB7      		in r31,__SP_H__
 3344 1112 3696      		adiw r30,6
 3345 1114 0FB6      		in __tmp_reg__,__SREG__
 3346 1116 F894      		cli
 3347 1118 FEBF      		out __SP_H__,r31
 3348 111a 0FBE      		out __SREG__,__tmp_reg__
 3349 111c EDBF      		out __SP_L__,r30
 3350 111e 00C0      		rjmp .L158
 3351               	.L157:
 909:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 3353               	.LM287:
 3354 1120 2091 0000 		lds r18,fdVty+4
 3355 1124 3091 0000 		lds r19,(fdVty+4)+1
 910:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 3357               	.LM288:
 3358 1128 00D0      		rcall .
 3359 112a 00D0      		rcall .
 3360 112c 00D0      		rcall .
 3361 112e ADB7      		in r26,__SP_L__
 3362 1130 BEB7      		in r27,__SP_H__
 3363 1132 1196      		adiw r26,1
 3364 1134 EDB7      		in r30,__SP_L__
 3365 1136 FEB7      		in r31,__SP_H__
 3366 1138 F282      		std Z+2,r15
 3367 113a E182      		std Z+1,r14
 3368 113c 80E0      		ldi r24,lo8(readRamFIleLenStr)
 3369 113e 90E0      		ldi r25,hi8(readRamFIleLenStr)
 3370 1140 1396      		adiw r26,2+1
 3371 1142 9C93      		st X,r25
 3372 1144 8E93      		st -X,r24
 3373 1146 1297      		sbiw r26,2
 3374 1148 F901      		movw r30,r18
 3375 114a 9281      		ldd r25,Z+2
 3376 114c 80E0      		ldi r24,lo8(0)
 3377 114e 2181      		ldd r18,Z+1
 3378 1150 820F      		add r24,r18
 3379 1152 911D      		adc r25,__zero_reg__
 3380 1154 1596      		adiw r26,4+1
 3381 1156 9C93      		st X,r25
 3382 1158 8E93      		st -X,r24
 3383 115a 1497      		sbiw r26,4
 3384 115c 0E94 0000 		call fprintf_P
 3385 1160 8DB7      		in r24,__SP_L__
 3386 1162 9EB7      		in r25,__SP_H__
 3387 1164 0696      		adiw r24,6
 3388 1166 0FB6      		in __tmp_reg__,__SREG__
 3389 1168 F894      		cli
 3390 116a 9EBF      		out __SP_H__,r25
 3391 116c 0FBE      		out __SREG__,__tmp_reg__
 3392 116e 8DBF      		out __SP_L__,r24
 913:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 3394               	.LM289:
 3395 1170 6E01      		movw r12,r28
 3396 1172 0894      		sec
 3397 1174 C11C      		adc r12,__zero_reg__
 3398 1176 D11C      		adc r13,__zero_reg__
 3399               	.L160:
 3400 1178 80E0      		ldi r24,lo8(fdVty)
 3401 117a 90E0      		ldi r25,hi8(fdVty)
 3402 117c B601      		movw r22,r12
 3403 117e 0E94 0000 		call ramDyskCzytajBajtZPliku
 3404 1182 F82E      		mov r15,r24
 915:vty.c         ****     uartVtySendByte(znak);
 3406               	.LM290:
 3407 1184 8981      		ldd r24,Y+1
 3408 1186 0E94 0000 		call uartVtySendByte
 916:vty.c         ****     if (znak == '\r')
 3410               	.LM291:
 3411 118a 8981      		ldd r24,Y+1
 3412 118c 8D30      		cpi r24,lo8(13)
 3413 118e 01F4      		brne .L159
 917:vty.c         ****       uartVtySendByte('\n');
 3415               	.LM292:
 3416 1190 8AE0      		ldi r24,lo8(10)
 3417 1192 0E94 0000 		call uartVtySendByte
 3418               	.L159:
 911:vty.c         ****   while (rezultat == 0)
 3420               	.LM293:
 3421 1196 FF20      		tst r15
 3422 1198 01F0      		breq .L160
 919:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 3424               	.LM294:
 3425 119a 00D0      		rcall .
 3426 119c 00D0      		rcall .
 3427 119e D801      		movw r26,r16
 3428 11a0 5A96      		adiw r26,26
 3429 11a2 8D91      		ld r24,X+
 3430 11a4 9C91      		ld r25,X
 3431 11a6 5B97      		sbiw r26,26+1
 3432 11a8 EDB7      		in r30,__SP_L__
 3433 11aa FEB7      		in r31,__SP_H__
 3434 11ac 9283      		std Z+2,r25
 3435 11ae 8183      		std Z+1,r24
 3436 11b0 80E0      		ldi r24,lo8(nlStr)
 3437 11b2 90E0      		ldi r25,hi8(nlStr)
 3438 11b4 9483      		std Z+4,r25
 3439 11b6 8383      		std Z+3,r24
 3440 11b8 0E94 0000 		call fprintf_P
 920:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 3442               	.LM295:
 3443 11bc 0F90      		pop __tmp_reg__
 3444 11be 0F90      		pop __tmp_reg__
 3445 11c0 0F90      		pop __tmp_reg__
 3446 11c2 0F90      		pop __tmp_reg__
 3447 11c4 80E0      		ldi r24,lo8(fdVty)
 3448 11c6 90E0      		ldi r25,hi8(fdVty)
 3449 11c8 0E94 0000 		call ramDyskZamknijPlik
 3450 11cc 20E0      		ldi r18,lo8(0)
 3451 11ce 30E0      		ldi r19,hi8(0)
 3452               	.L158:
 922:vty.c         **** }
 3454               	.LM296:
 3455 11d0 C901      		movw r24,r18
 3456               	/* epilogue start */
 3457 11d2 0F90      		pop __tmp_reg__
 3458 11d4 CF91      		pop r28
 3459 11d6 DF91      		pop r29
 3460 11d8 1F91      		pop r17
 3461 11da 0F91      		pop r16
 3462 11dc FF90      		pop r15
 3463 11de EF90      		pop r14
 3464 11e0 DF90      		pop r13
 3465 11e2 CF90      		pop r12
 3466 11e4 0895      		ret
 3471               	.Lscope28:
 3473               		.stabd	78,0,0
 3477               	writeRamFileFunction:
 3478               		.stabd	46,0,0
 870:vty.c         **** {
 3480               	.LM297:
 3481               	.LFBB29:
 3482               	/* prologue: function */
 3483               	/* frame size = 0 */
 871:vty.c         ****   ramDyskDir(state->myStdInOut);
 3485               	.LM298:
 3486 11e6 FC01      		movw r30,r24
 3487 11e8 828D      		ldd r24,Z+26
 3488 11ea 938D      		ldd r25,Z+27
 3489 11ec 0E94 0000 		call ramDyskDir
 873:vty.c         **** }
 3491               	.LM299:
 3492 11f0 80E0      		ldi r24,lo8(0)
 3493 11f2 90E0      		ldi r25,hi8(0)
 3494               	/* epilogue start */
 3495 11f4 0895      		ret
 3497               	.Lscope29:
 3499               		.stabd	78,0,0
 3503               	pokazCzasFunction:
 3504               		.stabd	46,0,0
 293:vty.c         **** {
 3506               	.LM300:
 3507               	.LFBB30:
 3508 11f6 0F93      		push r16
 3509 11f8 1F93      		push r17
 3510 11fa CF93      		push r28
 3511 11fc DF93      		push r29
 3512               	/* prologue: function */
 3513               	/* frame size = 0 */
 3514 11fe 8C01      		movw r16,r24
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 3516               	.LM301:
 3517 1200 80E0      		ldi r24,lo8(czasRtc)
 3518 1202 90E0      		ldi r25,hi8(czasRtc)
 3519 1204 0E94 0000 		call readTimeDecoded
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 3521               	.LM302:
 3522 1208 2091 0000 		lds r18,czasRtc+2
 3523 120c 2295      		swap r18
 3524 120e 2F70      		andi r18,lo8(15)
 3525 1210 4091 0000 		lds r20,czasRtc+2
 3526 1214 4F70      		andi r20,lo8(15)
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 3528               	.LM303:
 3529 1216 7091 0000 		lds r23,czasRtc+1
 3530 121a 7295      		swap r23
 3531 121c 7F70      		andi r23,lo8(15)
 3532 121e 5091 0000 		lds r21,czasRtc+1
 3533 1222 5F70      		andi r21,lo8(15)
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 3535               	.LM304:
 3536 1224 A091 0000 		lds r26,czasRtc
 3537 1228 A295      		swap r26
 3538 122a AF70      		andi r26,lo8(15)
 3539 122c 6091 0000 		lds r22,czasRtc
 3540 1230 6F70      		andi r22,lo8(15)
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 3542               	.LM305:
 3543 1232 8DB7      		in r24,__SP_L__
 3544 1234 9EB7      		in r25,__SP_H__
 3545 1236 0A97      		sbiw r24,10
 3546 1238 0FB6      		in __tmp_reg__,__SREG__
 3547 123a F894      		cli
 3548 123c 9EBF      		out __SP_H__,r25
 3549 123e 0FBE      		out __SREG__,__tmp_reg__
 3550 1240 8DBF      		out __SP_L__,r24
 3551 1242 EDB7      		in r30,__SP_L__
 3552 1244 FEB7      		in r31,__SP_H__
 3553 1246 3196      		adiw r30,1
 3554 1248 E801      		movw r28,r16
 3555 124a 8A8D      		ldd r24,Y+26
 3556 124c 9B8D      		ldd r25,Y+27
 3557 124e CDB7      		in r28,__SP_L__
 3558 1250 DEB7      		in r29,__SP_H__
 3559 1252 9A83      		std Y+2,r25
 3560 1254 8983      		std Y+1,r24
 3561 1256 80E0      		ldi r24,lo8(__c.3281)
 3562 1258 90E0      		ldi r25,hi8(__c.3281)
 3563 125a 9383      		std Z+3,r25
 3564 125c 8283      		std Z+2,r24
 3565 125e 822F      		mov r24,r18
 3566 1260 8370      		andi r24,lo8(3)
 3567 1262 90E0      		ldi r25,lo8(0)
 3568 1264 9C01      		movw r18,r24
 3569 1266 13E0      		ldi r17,3
 3570 1268 220F      	1:	lsl r18
 3571 126a 331F      		rol r19
 3572 126c 1A95      		dec r17
 3573 126e 01F4      		brne 1b
 3574 1270 880F      		lsl r24
 3575 1272 991F      		rol r25
 3576 1274 280F      		add r18,r24
 3577 1276 391F      		adc r19,r25
 3578 1278 420F      		add r20,r18
 3579 127a 4483      		std Z+4,r20
 3580 127c 1582      		std Z+5,__zero_reg__
 3581 127e 872F      		mov r24,r23
 3582 1280 8770      		andi r24,lo8(7)
 3583 1282 90E0      		ldi r25,lo8(0)
 3584 1284 9C01      		movw r18,r24
 3585 1286 73E0      		ldi r23,3
 3586 1288 220F      	1:	lsl r18
 3587 128a 331F      		rol r19
 3588 128c 7A95      		dec r23
 3589 128e 01F4      		brne 1b
 3590 1290 880F      		lsl r24
 3591 1292 991F      		rol r25
 3592 1294 280F      		add r18,r24
 3593 1296 391F      		adc r19,r25
 3594 1298 520F      		add r21,r18
 3595 129a 5683      		std Z+6,r21
 3596 129c 1782      		std Z+7,__zero_reg__
 3597 129e 8A2F      		mov r24,r26
 3598 12a0 8770      		andi r24,lo8(7)
 3599 12a2 90E0      		ldi r25,lo8(0)
 3600 12a4 9C01      		movw r18,r24
 3601 12a6 03E0      		ldi r16,3
 3602 12a8 220F      	1:	lsl r18
 3603 12aa 331F      		rol r19
 3604 12ac 0A95      		dec r16
 3605 12ae 01F4      		brne 1b
 3606 12b0 880F      		lsl r24
 3607 12b2 991F      		rol r25
 3608 12b4 280F      		add r18,r24
 3609 12b6 391F      		adc r19,r25
 3610 12b8 620F      		add r22,r18
 3611 12ba 6087      		std Z+8,r22
 3612 12bc 1186      		std Z+9,__zero_reg__
 3613 12be 0E94 0000 		call fprintf_P
 3614 12c2 8DB7      		in r24,__SP_L__
 3615 12c4 9EB7      		in r25,__SP_H__
 3616 12c6 0A96      		adiw r24,10
 3617 12c8 0FB6      		in __tmp_reg__,__SREG__
 3618 12ca F894      		cli
 3619 12cc 9EBF      		out __SP_H__,r25
 3620 12ce 0FBE      		out __SREG__,__tmp_reg__
 3621 12d0 8DBF      		out __SP_L__,r24
 300:vty.c         **** }
 3623               	.LM306:
 3624 12d2 80E0      		ldi r24,lo8(0)
 3625 12d4 90E0      		ldi r25,hi8(0)
 3626               	/* epilogue start */
 3627 12d6 DF91      		pop r29
 3628 12d8 CF91      		pop r28
 3629 12da 1F91      		pop r17
 3630 12dc 0F91      		pop r16
 3631 12de 0895      		ret
 3633               	.Lscope30:
 3635               		.stabd	78,0,0
 3639               	helpFunction:
 3640               		.stabd	46,0,0
 503:vty.c         **** {
 3642               	.LM307:
 3643               	.LFBB31:
 3644               	/* prologue: function */
 3645               	/* frame size = 0 */
 504:vty.c         ****   cmdPrintHelp(state);
 3647               	.LM308:
 3648 12e0 0E94 0000 		call cmdPrintHelp
 506:vty.c         **** }
 3650               	.LM309:
 3651 12e4 80E0      		ldi r24,lo8(0)
 3652 12e6 90E0      		ldi r25,hi8(0)
 3653               	/* epilogue start */
 3654 12e8 0895      		ret
 3656               	.Lscope31:
 3658               		.stabd	78,0,0
 3661               	.global	printStatus
 3663               	printStatus:
 3664               		.stabd	46,0,0
 207:vty.c         **** {
 3666               	.LM310:
 3667               	.LFBB32:
 3668 12ea CF93      		push r28
 3669 12ec DF93      		push r29
 3670               	/* prologue: function */
 3671               	/* frame size = 0 */
 3672 12ee EC01      		movw r28,r24
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 3674               	.LM311:
 3675 12f0 00D0      		rcall .
 3676 12f2 00D0      		rcall .
 3677 12f4 ADB7      		in r26,__SP_L__
 3678 12f6 BEB7      		in r27,__SP_H__
 3679 12f8 1296      		adiw r26,1+1
 3680 12fa 9C93      		st X,r25
 3681 12fc 8E93      		st -X,r24
 3682 12fe 1197      		sbiw r26,1
 3683 1300 80E0      		ldi r24,lo8(__c.3231)
 3684 1302 90E0      		ldi r25,hi8(__c.3231)
 3685 1304 1496      		adiw r26,3+1
 3686 1306 9C93      		st X,r25
 3687 1308 8E93      		st -X,r24
 3688 130a 1397      		sbiw r26,3
 3689 130c 0E94 0000 		call fprintf_P
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 3691               	.LM312:
 3692 1310 EDB7      		in r30,__SP_L__
 3693 1312 FEB7      		in r31,__SP_H__
 3694 1314 D283      		std Z+2,r29
 3695 1316 C183      		std Z+1,r28
 3696 1318 80E0      		ldi r24,lo8(systemStateStr)
 3697 131a 90E0      		ldi r25,hi8(systemStateStr)
 3698 131c 9483      		std Z+4,r25
 3699 131e 8383      		std Z+3,r24
 3700 1320 0E94 0000 		call fprintf_P
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 3702               	.LM313:
 3703 1324 0F90      		pop __tmp_reg__
 3704 1326 0F90      		pop __tmp_reg__
 3705 1328 0F90      		pop __tmp_reg__
 3706 132a 0F90      		pop __tmp_reg__
 3707 132c 0E94 0000 		call uxTaskGetNumberOfTasks
 3708 1330 00D0      		rcall .
 3709 1332 00D0      		rcall .
 3710 1334 00D0      		rcall .
 3711 1336 EDB7      		in r30,__SP_L__
 3712 1338 FEB7      		in r31,__SP_H__
 3713 133a 3196      		adiw r30,1
 3714 133c ADB7      		in r26,__SP_L__
 3715 133e BEB7      		in r27,__SP_H__
 3716 1340 1296      		adiw r26,1+1
 3717 1342 DC93      		st X,r29
 3718 1344 CE93      		st -X,r28
 3719 1346 1197      		sbiw r26,1
 3720 1348 20E0      		ldi r18,lo8(statusNumberOfTasksStr)
 3721 134a 30E0      		ldi r19,hi8(statusNumberOfTasksStr)
 3722 134c 3383      		std Z+3,r19
 3723 134e 2283      		std Z+2,r18
 3724 1350 8483      		std Z+4,r24
 3725 1352 1582      		std Z+5,__zero_reg__
 3726 1354 0E94 0000 		call fprintf_P
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 3728               	.LM314:
 3729 1358 EDB7      		in r30,__SP_L__
 3730 135a FEB7      		in r31,__SP_H__
 3731 135c 3696      		adiw r30,6
 3732 135e 0FB6      		in __tmp_reg__,__SREG__
 3733 1360 F894      		cli
 3734 1362 FEBF      		out __SP_H__,r31
 3735 1364 0FBE      		out __SREG__,__tmp_reg__
 3736 1366 EDBF      		out __SP_L__,r30
 3737 1368 0E94 0000 		call xPortGetFreeHeapSize
 3738 136c 2DB7      		in r18,__SP_L__
 3739 136e 3EB7      		in r19,__SP_H__
 3740 1370 2850      		subi r18,lo8(-(-8))
 3741 1372 3040      		sbci r19,hi8(-(-8))
 3742 1374 0FB6      		in __tmp_reg__,__SREG__
 3743 1376 F894      		cli
 3744 1378 3EBF      		out __SP_H__,r19
 3745 137a 0FBE      		out __SREG__,__tmp_reg__
 3746 137c 2DBF      		out __SP_L__,r18
 3747 137e EDB7      		in r30,__SP_L__
 3748 1380 FEB7      		in r31,__SP_H__
 3749 1382 3196      		adiw r30,1
 3750 1384 ADB7      		in r26,__SP_L__
 3751 1386 BEB7      		in r27,__SP_H__
 3752 1388 1296      		adiw r26,1+1
 3753 138a DC93      		st X,r29
 3754 138c CE93      		st -X,r28
 3755 138e 1197      		sbiw r26,1
 3756 1390 20E0      		ldi r18,lo8(statusStaticHeapStateStr)
 3757 1392 30E0      		ldi r19,hi8(statusStaticHeapStateStr)
 3758 1394 3383      		std Z+3,r19
 3759 1396 2283      		std Z+2,r18
 3760 1398 9583      		std Z+5,r25
 3761 139a 8483      		std Z+4,r24
 3762 139c 8CE1      		ldi r24,lo8(3100)
 3763 139e 9CE0      		ldi r25,hi8(3100)
 3764 13a0 9783      		std Z+7,r25
 3765 13a2 8683      		std Z+6,r24
 3766 13a4 0E94 0000 		call fprintf_P
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 3768               	.LM315:
 3769 13a8 EDB7      		in r30,__SP_L__
 3770 13aa FEB7      		in r31,__SP_H__
 3771 13ac 3896      		adiw r30,8
 3772 13ae 0FB6      		in __tmp_reg__,__SREG__
 3773 13b0 F894      		cli
 3774 13b2 FEBF      		out __SP_H__,r31
 3775 13b4 0FBE      		out __SREG__,__tmp_reg__
 3776 13b6 EDBF      		out __SP_L__,r30
 3777 13b8 0E94 0000 		call xmallocAvailable
 3778 13bc 2DB7      		in r18,__SP_L__
 3779 13be 3EB7      		in r19,__SP_H__
 3780 13c0 2850      		subi r18,lo8(-(-8))
 3781 13c2 3040      		sbci r19,hi8(-(-8))
 3782 13c4 0FB6      		in __tmp_reg__,__SREG__
 3783 13c6 F894      		cli
 3784 13c8 3EBF      		out __SP_H__,r19
 3785 13ca 0FBE      		out __SREG__,__tmp_reg__
 3786 13cc 2DBF      		out __SP_L__,r18
 3787 13ce EDB7      		in r30,__SP_L__
 3788 13d0 FEB7      		in r31,__SP_H__
 3789 13d2 3196      		adiw r30,1
 3790 13d4 ADB7      		in r26,__SP_L__
 3791 13d6 BEB7      		in r27,__SP_H__
 3792 13d8 1296      		adiw r26,1+1
 3793 13da DC93      		st X,r29
 3794 13dc CE93      		st -X,r28
 3795 13de 1197      		sbiw r26,1
 3796 13e0 20E0      		ldi r18,lo8(statusDynamicHeapStateStr)
 3797 13e2 30E0      		ldi r19,hi8(statusDynamicHeapStateStr)
 3798 13e4 3383      		std Z+3,r19
 3799 13e6 2283      		std Z+2,r18
 3800 13e8 9583      		std Z+5,r25
 3801 13ea 8483      		std Z+4,r24
 3802 13ec 80E0      		ldi r24,lo8(5888)
 3803 13ee 97E1      		ldi r25,hi8(5888)
 3804 13f0 9783      		std Z+7,r25
 3805 13f2 8683      		std Z+6,r24
 3806 13f4 0E94 0000 		call fprintf_P
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 3808               	.LM316:
 3809 13f8 2091 0000 		lds r18,temperature
 3810 13fc 0F90      		pop __tmp_reg__
 3811 13fe 0F90      		pop __tmp_reg__
 3812 1400 EDB7      		in r30,__SP_L__
 3813 1402 FEB7      		in r31,__SP_H__
 3814 1404 3196      		adiw r30,1
 3815 1406 ADB7      		in r26,__SP_L__
 3816 1408 BEB7      		in r27,__SP_H__
 3817 140a 1296      		adiw r26,1+1
 3818 140c DC93      		st X,r29
 3819 140e CE93      		st -X,r28
 3820 1410 1197      		sbiw r26,1
 3821 1412 80E0      		ldi r24,lo8(statusTemperatureStr)
 3822 1414 90E0      		ldi r25,hi8(statusTemperatureStr)
 3823 1416 9383      		std Z+3,r25
 3824 1418 8283      		std Z+2,r24
 3825 141a 2483      		std Z+4,r18
 3826 141c 1582      		std Z+5,__zero_reg__
 3827 141e 0E94 0000 		call fprintf_P
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 3829               	.LM317:
 3830 1422 2091 0000 		lds r18,voltage
 3831 1426 EDB7      		in r30,__SP_L__
 3832 1428 FEB7      		in r31,__SP_H__
 3833 142a 3196      		adiw r30,1
 3834 142c ADB7      		in r26,__SP_L__
 3835 142e BEB7      		in r27,__SP_H__
 3836 1430 1296      		adiw r26,1+1
 3837 1432 DC93      		st X,r29
 3838 1434 CE93      		st -X,r28
 3839 1436 1197      		sbiw r26,1
 3840 1438 80E0      		ldi r24,lo8(statusVoltageStr)
 3841 143a 90E0      		ldi r25,hi8(statusVoltageStr)
 3842 143c 9383      		std Z+3,r25
 3843 143e 8283      		std Z+2,r24
 3844 1440 2483      		std Z+4,r18
 3845 1442 1582      		std Z+5,__zero_reg__
 3846 1444 0E94 0000 		call fprintf_P
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 3848               	.LM318:
 3849 1448 EDB7      		in r30,__SP_L__
 3850 144a FEB7      		in r31,__SP_H__
 3851 144c 3696      		adiw r30,6
 3852 144e 0FB6      		in __tmp_reg__,__SREG__
 3853 1450 F894      		cli
 3854 1452 FEBF      		out __SP_H__,r31
 3855 1454 0FBE      		out __SREG__,__tmp_reg__
 3856 1456 EDBF      		out __SP_L__,r30
 3857 1458 0E94 0000 		call ramDyskLiczbaWolnychKlastrow
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 3859               	.LM319:
 3860 145c 2DB7      		in r18,__SP_L__
 3861 145e 3EB7      		in r19,__SP_H__
 3862 1460 2850      		subi r18,lo8(-(-8))
 3863 1462 3040      		sbci r19,hi8(-(-8))
 3864 1464 0FB6      		in __tmp_reg__,__SREG__
 3865 1466 F894      		cli
 3866 1468 3EBF      		out __SP_H__,r19
 3867 146a 0FBE      		out __SREG__,__tmp_reg__
 3868 146c 2DBF      		out __SP_L__,r18
 3869 146e EDB7      		in r30,__SP_L__
 3870 1470 FEB7      		in r31,__SP_H__
 3871 1472 3196      		adiw r30,1
 3872 1474 ADB7      		in r26,__SP_L__
 3873 1476 BEB7      		in r27,__SP_H__
 3874 1478 1296      		adiw r26,1+1
 3875 147a DC93      		st X,r29
 3876 147c CE93      		st -X,r28
 3877 147e 1197      		sbiw r26,1
 3878 1480 20E0      		ldi r18,lo8(statusRamDiskStateStr)
 3879 1482 30E0      		ldi r19,hi8(statusRamDiskStateStr)
 3880 1484 3383      		std Z+3,r19
 3881 1486 2283      		std Z+2,r18
 3882 1488 8483      		std Z+4,r24
 3883 148a 1582      		std Z+5,__zero_reg__
 3884 148c 80E8      		ldi r24,lo8(128)
 3885 148e 90E0      		ldi r25,hi8(128)
 3886 1490 9783      		std Z+7,r25
 3887 1492 8683      		std Z+6,r24
 3888 1494 0E94 0000 		call fprintf_P
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 3890               	.LM320:
 3891 1498 0F90      		pop __tmp_reg__
 3892 149a 0F90      		pop __tmp_reg__
 3893 149c 0F90      		pop __tmp_reg__
 3894 149e 0F90      		pop __tmp_reg__
 3895 14a0 EDB7      		in r30,__SP_L__
 3896 14a2 FEB7      		in r31,__SP_H__
 3897 14a4 D283      		std Z+2,r29
 3898 14a6 C183      		std Z+1,r28
 3899 14a8 80E0      		ldi r24,lo8(systemRamConfigStr)
 3900 14aa 90E0      		ldi r25,hi8(systemRamConfigStr)
 3901 14ac 9483      		std Z+4,r25
 3902 14ae 8383      		std Z+3,r24
 3903 14b0 0E94 0000 		call fprintf_P
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 3905               	.LM321:
 3906 14b4 ADB7      		in r26,__SP_L__
 3907 14b6 BEB7      		in r27,__SP_H__
 3908 14b8 1296      		adiw r26,1+1
 3909 14ba DC93      		st X,r29
 3910 14bc CE93      		st -X,r28
 3911 14be 1197      		sbiw r26,1
 3912 14c0 80E0      		ldi r24,lo8(statusMacStr)
 3913 14c2 90E0      		ldi r25,hi8(statusMacStr)
 3914 14c4 1496      		adiw r26,3+1
 3915 14c6 9C93      		st X,r25
 3916 14c8 8E93      		st -X,r24
 3917 14ca 1397      		sbiw r26,3
 3918 14cc 0E94 0000 		call fprintf_P
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 3920               	.LM322:
 3921 14d0 0F90      		pop __tmp_reg__
 3922 14d2 0F90      		pop __tmp_reg__
 3923 14d4 0F90      		pop __tmp_reg__
 3924 14d6 0F90      		pop __tmp_reg__
 3925 14d8 CE01      		movw r24,r28
 3926 14da 60E0      		ldi r22,lo8(nicState+2)
 3927 14dc 70E0      		ldi r23,hi8(nicState+2)
 3928 14de 0E94 0000 		call netPrintEthAddr
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3930               	.LM323:
 3931 14e2 00D0      		rcall .
 3932 14e4 00D0      		rcall .
 3933 14e6 EDB7      		in r30,__SP_L__
 3934 14e8 FEB7      		in r31,__SP_H__
 3935 14ea D283      		std Z+2,r29
 3936 14ec C183      		std Z+1,r28
 3937 14ee 80E0      		ldi r24,lo8(__c.3234)
 3938 14f0 90E0      		ldi r25,hi8(__c.3234)
 3939 14f2 9483      		std Z+4,r25
 3940 14f4 8383      		std Z+3,r24
 3941 14f6 0E94 0000 		call fprintf_P
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 3943               	.LM324:
 3944 14fa ADB7      		in r26,__SP_L__
 3945 14fc BEB7      		in r27,__SP_H__
 3946 14fe 1296      		adiw r26,1+1
 3947 1500 DC93      		st X,r29
 3948 1502 CE93      		st -X,r28
 3949 1504 1197      		sbiw r26,1
 3950 1506 80E0      		ldi r24,lo8(statusIpStr)
 3951 1508 90E0      		ldi r25,hi8(statusIpStr)
 3952 150a 1496      		adiw r26,3+1
 3953 150c 9C93      		st X,r25
 3954 150e 8E93      		st -X,r24
 3955 1510 1397      		sbiw r26,3
 3956 1512 0E94 0000 		call fprintf_P
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 3958               	.LM325:
 3959 1516 0F90      		pop __tmp_reg__
 3960 1518 0F90      		pop __tmp_reg__
 3961 151a 0F90      		pop __tmp_reg__
 3962 151c 0F90      		pop __tmp_reg__
 3963 151e 0E94 0000 		call ipGetConfig
 3964 1522 FC01      		movw r30,r24
 3965 1524 4081      		ld r20,Z
 3966 1526 5181      		ldd r21,Z+1
 3967 1528 6281      		ldd r22,Z+2
 3968 152a 7381      		ldd r23,Z+3
 3969 152c CE01      		movw r24,r28
 3970 152e 0E94 0000 		call netPrintIPAddr
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3972               	.LM326:
 3973 1532 00D0      		rcall .
 3974 1534 00D0      		rcall .
 3975 1536 EDB7      		in r30,__SP_L__
 3976 1538 FEB7      		in r31,__SP_H__
 3977 153a D283      		std Z+2,r29
 3978 153c C183      		std Z+1,r28
 3979 153e 80E0      		ldi r24,lo8(__c.3236)
 3980 1540 90E0      		ldi r25,hi8(__c.3236)
 3981 1542 9483      		std Z+4,r25
 3982 1544 8383      		std Z+3,r24
 3983 1546 0E94 0000 		call fprintf_P
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 3985               	.LM327:
 3986 154a ADB7      		in r26,__SP_L__
 3987 154c BEB7      		in r27,__SP_H__
 3988 154e 1296      		adiw r26,1+1
 3989 1550 DC93      		st X,r29
 3990 1552 CE93      		st -X,r28
 3991 1554 1197      		sbiw r26,1
 3992 1556 80E0      		ldi r24,lo8(statusIpMaskStr)
 3993 1558 90E0      		ldi r25,hi8(statusIpMaskStr)
 3994 155a 1496      		adiw r26,3+1
 3995 155c 9C93      		st X,r25
 3996 155e 8E93      		st -X,r24
 3997 1560 1397      		sbiw r26,3
 3998 1562 0E94 0000 		call fprintf_P
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 4000               	.LM328:
 4001 1566 0F90      		pop __tmp_reg__
 4002 1568 0F90      		pop __tmp_reg__
 4003 156a 0F90      		pop __tmp_reg__
 4004 156c 0F90      		pop __tmp_reg__
 4005 156e 0E94 0000 		call ipGetConfig
 4006 1572 FC01      		movw r30,r24
 4007 1574 4481      		ldd r20,Z+4
 4008 1576 5581      		ldd r21,Z+5
 4009 1578 6681      		ldd r22,Z+6
 4010 157a 7781      		ldd r23,Z+7
 4011 157c CE01      		movw r24,r28
 4012 157e 0E94 0000 		call netPrintIPAddr
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4014               	.LM329:
 4015 1582 00D0      		rcall .
 4016 1584 00D0      		rcall .
 4017 1586 ADB7      		in r26,__SP_L__
 4018 1588 BEB7      		in r27,__SP_H__
 4019 158a 1296      		adiw r26,1+1
 4020 158c DC93      		st X,r29
 4021 158e CE93      		st -X,r28
 4022 1590 1197      		sbiw r26,1
 4023 1592 80E0      		ldi r24,lo8(__c.3238)
 4024 1594 90E0      		ldi r25,hi8(__c.3238)
 4025 1596 1496      		adiw r26,3+1
 4026 1598 9C93      		st X,r25
 4027 159a 8E93      		st -X,r24
 4028 159c 1397      		sbiw r26,3
 4029 159e 0E94 0000 		call fprintf_P
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 4031               	.LM330:
 4032 15a2 EDB7      		in r30,__SP_L__
 4033 15a4 FEB7      		in r31,__SP_H__
 4034 15a6 D283      		std Z+2,r29
 4035 15a8 C183      		std Z+1,r28
 4036 15aa 80E0      		ldi r24,lo8(statusIpGwStr)
 4037 15ac 90E0      		ldi r25,hi8(statusIpGwStr)
 4038 15ae 9483      		std Z+4,r25
 4039 15b0 8383      		std Z+3,r24
 4040 15b2 0E94 0000 		call fprintf_P
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 4042               	.LM331:
 4043 15b6 0F90      		pop __tmp_reg__
 4044 15b8 0F90      		pop __tmp_reg__
 4045 15ba 0F90      		pop __tmp_reg__
 4046 15bc 0F90      		pop __tmp_reg__
 4047 15be 0E94 0000 		call ipGetConfig
 4048 15c2 DC01      		movw r26,r24
 4049 15c4 1896      		adiw r26,8
 4050 15c6 4D91      		ld r20,X+
 4051 15c8 5D91      		ld r21,X+
 4052 15ca 6D91      		ld r22,X+
 4053 15cc 7C91      		ld r23,X
 4054 15ce 1B97      		sbiw r26,8+3
 4055 15d0 CE01      		movw r24,r28
 4056 15d2 0E94 0000 		call netPrintIPAddr
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4058               	.LM332:
 4059 15d6 00D0      		rcall .
 4060 15d8 00D0      		rcall .
 4061 15da EDB7      		in r30,__SP_L__
 4062 15dc FEB7      		in r31,__SP_H__
 4063 15de D283      		std Z+2,r29
 4064 15e0 C183      		std Z+1,r28
 4065 15e2 80E0      		ldi r24,lo8(__c.3240)
 4066 15e4 90E0      		ldi r25,hi8(__c.3240)
 4067 15e6 9483      		std Z+4,r25
 4068 15e8 8383      		std Z+3,r24
 4069 15ea 0E94 0000 		call fprintf_P
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 4071               	.LM333:
 4072 15ee ADB7      		in r26,__SP_L__
 4073 15f0 BEB7      		in r27,__SP_H__
 4074 15f2 1296      		adiw r26,1+1
 4075 15f4 DC93      		st X,r29
 4076 15f6 CE93      		st -X,r28
 4077 15f8 1197      		sbiw r26,1
 4078 15fa 80E0      		ldi r24,lo8(statusRs485listStr)
 4079 15fc 90E0      		ldi r25,hi8(statusRs485listStr)
 4080 15fe 1496      		adiw r26,3+1
 4081 1600 9C93      		st X,r25
 4082 1602 8E93      		st -X,r24
 4083 1604 1397      		sbiw r26,3
 4084 1606 0E94 0000 		call fprintf_P
 242:vty.c         ****   tmp = printRs485devices(stream);
 4086               	.LM334:
 4087 160a 0F90      		pop __tmp_reg__
 4088 160c 0F90      		pop __tmp_reg__
 4089 160e 0F90      		pop __tmp_reg__
 4090 1610 0F90      		pop __tmp_reg__
 4091 1612 CE01      		movw r24,r28
 4092 1614 0E94 0000 		call printRs485devices
 243:vty.c         ****   if (tmp == 0)
 4094               	.LM335:
 4095 1618 8823      		tst r24
 4096 161a 01F4      		brne .L170
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 4098               	.LM336:
 4099 161c 00D0      		rcall .
 4100 161e 00D0      		rcall .
 4101 1620 EDB7      		in r30,__SP_L__
 4102 1622 FEB7      		in r31,__SP_H__
 4103 1624 D283      		std Z+2,r29
 4104 1626 C183      		std Z+1,r28
 4105 1628 80E0      		ldi r24,lo8(statusNoRs485Dev)
 4106 162a 90E0      		ldi r25,hi8(statusNoRs485Dev)
 4107 162c 9483      		std Z+4,r25
 4108 162e 8383      		std Z+3,r24
 4109 1630 0E94 0000 		call fprintf_P
 4110 1634 0F90      		pop __tmp_reg__
 4111 1636 0F90      		pop __tmp_reg__
 4112 1638 0F90      		pop __tmp_reg__
 4113 163a 0F90      		pop __tmp_reg__
 4114               	.L170:
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 4116               	.LM337:
 4117 163c 00D0      		rcall .
 4118 163e 00D0      		rcall .
 4119 1640 ADB7      		in r26,__SP_L__
 4120 1642 BEB7      		in r27,__SP_H__
 4121 1644 1296      		adiw r26,1+1
 4122 1646 DC93      		st X,r29
 4123 1648 CE93      		st -X,r28
 4124 164a 1197      		sbiw r26,1
 4125 164c 80E0      		ldi r24,lo8(statusLockerSensorsStr)
 4126 164e 90E0      		ldi r25,hi8(statusLockerSensorsStr)
 4127 1650 1496      		adiw r26,3+1
 4128 1652 9C93      		st X,r25
 4129 1654 8E93      		st -X,r24
 4130 1656 1397      		sbiw r26,3
 4131 1658 0E94 0000 		call fprintf_P
 248:vty.c         ****   tmp = printLockers(stream);
 4133               	.LM338:
 4134 165c 0F90      		pop __tmp_reg__
 4135 165e 0F90      		pop __tmp_reg__
 4136 1660 0F90      		pop __tmp_reg__
 4137 1662 0F90      		pop __tmp_reg__
 4138 1664 CE01      		movw r24,r28
 4139 1666 0E94 0000 		call printLockers
 249:vty.c         ****   if (tmp == 0)
 4141               	.LM339:
 4142 166a 8823      		tst r24
 4143 166c 01F4      		brne .L171
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 4145               	.LM340:
 4146 166e 00D0      		rcall .
 4147 1670 00D0      		rcall .
 4148 1672 EDB7      		in r30,__SP_L__
 4149 1674 FEB7      		in r31,__SP_H__
 4150 1676 D283      		std Z+2,r29
 4151 1678 C183      		std Z+1,r28
 4152 167a 80E0      		ldi r24,lo8(statusLockerSensorsDisStr)
 4153 167c 90E0      		ldi r25,hi8(statusLockerSensorsDisStr)
 4154 167e 9483      		std Z+4,r25
 4155 1680 8383      		std Z+3,r24
 4156 1682 0E94 0000 		call fprintf_P
 4157 1686 0F90      		pop __tmp_reg__
 4158 1688 0F90      		pop __tmp_reg__
 4159 168a 0F90      		pop __tmp_reg__
 4160 168c 0F90      		pop __tmp_reg__
 4161               	.L171:
 259:vty.c         ****   udpPrintStatus(stream);
 4163               	.LM341:
 4164 168e CE01      		movw r24,r28
 4165 1690 0E94 0000 		call udpPrintStatus
 4166               	/* epilogue start */
 261:vty.c         **** }
 4168               	.LM342:
 4169 1694 DF91      		pop r29
 4170 1696 CF91      		pop r28
 4171 1698 0895      		ret
 4173               	.Lscope32:
 4175               		.stabd	78,0,0
 4179               	statusFunction:
 4180               		.stabd	46,0,0
 267:vty.c         **** {
 4182               	.LM343:
 4183               	.LFBB33:
 4184 169a EF92      		push r14
 4185 169c FF92      		push r15
 4186 169e 0F93      		push r16
 4187 16a0 1F93      		push r17
 4188 16a2 DF93      		push r29
 4189 16a4 CF93      		push r28
 4190 16a6 CDB7      		in r28,__SP_L__
 4191 16a8 DEB7      		in r29,__SP_H__
 4192 16aa 2E97      		sbiw r28,14
 4193 16ac 0FB6      		in __tmp_reg__,__SREG__
 4194 16ae F894      		cli
 4195 16b0 DEBF      		out __SP_H__,r29
 4196 16b2 0FBE      		out __SREG__,__tmp_reg__
 4197 16b4 CDBF      		out __SP_L__,r28
 4198               	/* prologue: function */
 4199               	/* frame size = 14 */
 4200 16b6 7C01      		movw r14,r24
 268:vty.c         ****   if (state->argc < 1)
 4202               	.LM344:
 4203 16b8 DC01      		movw r26,r24
 4204 16ba 5996      		adiw r26,25
 4205 16bc 8C91      		ld r24,X
 4206 16be 5997      		sbiw r26,25
 4207 16c0 8823      		tst r24
 4208 16c2 01F4      		brne .L174
 270:vty.c         ****     printStatus(state->myStdInOut);
 4210               	.LM345:
 4211 16c4 5A96      		adiw r26,26
 4212 16c6 8D91      		ld r24,X+
 4213 16c8 9C91      		ld r25,X
 4214 16ca 5B97      		sbiw r26,26+1
 4215 16cc 0E94 0000 		call printStatus
 4216 16d0 00C0      		rjmp .L178
 4217               	.L174:
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 4219               	.LM346:
 4220 16d2 81E0      		ldi r24,lo8(1)
 4221 16d4 B701      		movw r22,r14
 4222 16d6 0E94 0000 		call cmdlineGetArgStr
 4223 16da 60E0      		ldi r22,lo8(fdVty)
 4224 16dc 70E0      		ldi r23,hi8(fdVty)
 4225 16de 8E01      		movw r16,r28
 4226 16e0 0F5F      		subi r16,lo8(-(1))
 4227 16e2 1F4F      		sbci r17,hi8(-(1))
 4228 16e4 A801      		movw r20,r16
 4229 16e6 23E0      		ldi r18,lo8(3)
 4230 16e8 0E94 0000 		call ramDyskOtworzPlikStdIo
 4231 16ec 8823      		tst r24
 4232 16ee 01F0      		breq .L176
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 4234               	.LM347:
 4235 16f0 F701      		movw r30,r14
 4236 16f2 028D      		ldd r16,Z+26
 4237 16f4 138D      		ldd r17,Z+27
 4238 16f6 81E0      		ldi r24,lo8(1)
 4239 16f8 B701      		movw r22,r14
 4240 16fa 0E94 0000 		call cmdlineGetArgStr
 4241 16fe 00D0      		rcall .
 4242 1700 00D0      		rcall .
 4243 1702 00D0      		rcall .
 4244 1704 EDB7      		in r30,__SP_L__
 4245 1706 FEB7      		in r31,__SP_H__
 4246 1708 3196      		adiw r30,1
 4247 170a ADB7      		in r26,__SP_L__
 4248 170c BEB7      		in r27,__SP_H__
 4249 170e 1296      		adiw r26,1+1
 4250 1710 1C93      		st X,r17
 4251 1712 0E93      		st -X,r16
 4252 1714 1197      		sbiw r26,1
 4253 1716 20E0      		ldi r18,lo8(errorOpenFile)
 4254 1718 30E0      		ldi r19,hi8(errorOpenFile)
 4255 171a 3383      		std Z+3,r19
 4256 171c 2283      		std Z+2,r18
 4257 171e 9583      		std Z+5,r25
 4258 1720 8483      		std Z+4,r24
 4259 1722 0E94 0000 		call fprintf_P
 4260 1726 24E0      		ldi r18,lo8(4)
 4261 1728 30E0      		ldi r19,hi8(4)
 4262 172a EDB7      		in r30,__SP_L__
 4263 172c FEB7      		in r31,__SP_H__
 4264 172e 3696      		adiw r30,6
 4265 1730 0FB6      		in __tmp_reg__,__SREG__
 4266 1732 F894      		cli
 4267 1734 FEBF      		out __SP_H__,r31
 4268 1736 0FBE      		out __SREG__,__tmp_reg__
 4269 1738 EDBF      		out __SP_L__,r30
 4270 173a 00C0      		rjmp .L175
 4271               	.L176:
 281:vty.c         ****   printStatus(&stream);
 4273               	.LM348:
 4274 173c C801      		movw r24,r16
 4275 173e 0E94 0000 		call printStatus
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 4277               	.LM349:
 4278 1742 C801      		movw r24,r16
 4279 1744 0E94 0000 		call ramDyskZamknijPlikStdIo
 4280               	.L178:
 4281 1748 20E0      		ldi r18,lo8(0)
 4282 174a 30E0      		ldi r19,hi8(0)
 4283               	.L175:
 284:vty.c         **** }
 4285               	.LM350:
 4286 174c C901      		movw r24,r18
 4287               	/* epilogue start */
 4288 174e 2E96      		adiw r28,14
 4289 1750 0FB6      		in __tmp_reg__,__SREG__
 4290 1752 F894      		cli
 4291 1754 DEBF      		out __SP_H__,r29
 4292 1756 0FBE      		out __SREG__,__tmp_reg__
 4293 1758 CDBF      		out __SP_L__,r28
 4294 175a CF91      		pop r28
 4295 175c DF91      		pop r29
 4296 175e 1F91      		pop r17
 4297 1760 0F91      		pop r16
 4298 1762 FF90      		pop r15
 4299 1764 EF90      		pop r14
 4300 1766 0895      		ret
 4305               	.Lscope33:
 4307               		.stabd	78,0,0
 4311               	.global	VtyInit
 4313               	VtyInit:
 4314               		.stabd	46,0,0
 160:vty.c         **** {
 4316               	.LM351:
 4317               	.LFBB34:
 4318 1768 EF92      		push r14
 4319 176a 0F93      		push r16
 4320 176c 1F93      		push r17
 4321               	/* prologue: function */
 4322               	/* frame size = 0 */
 4323 176e 9B01      		movw r18,r22
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 4325               	.LM352:
 4326 1770 60E0      		ldi r22,lo8(10240)
 4327 1772 78E2      		ldi r23,hi8(10240)
 4328 1774 40E0      		ldi r20,lo8(256)
 4329 1776 51E0      		ldi r21,hi8(256)
 4330 1778 00E0      		ldi r16,lo8(cmdListNormal)
 4331 177a 10E0      		ldi r17,hi8(cmdListNormal)
 4332 177c EE24      		clr r14
 4333 177e 0E94 0000 		call cmdStateConfigure
 4334               	/* epilogue start */
 162:vty.c         **** }
 4336               	.LM353:
 4337 1782 1F91      		pop r17
 4338 1784 0F91      		pop r16
 4339 1786 EF90      		pop r14
 4340 1788 0895      		ret
 4342               	.Lscope34:
 4344               		.stabd	78,0,0
 4345               	.global	errorOK
 4346               		.section	.progmem.data,"a",@progbits
 4349               	errorOK:
 4350 0000 416C 6C20 		.string	"All OK\r\n"
 4350      4F4B 0D0A 
 4350      00
 4351               	.global	errorNoFile
 4354               	errorNoFile:
 4355 0009 4E6F 2046 		.string	"No File\r\n"
 4355      696C 650D 
 4355      0A00 
 4356               	.global	errorxModemFrameStartTimeout
 4359               	errorxModemFrameStartTimeout:
 4360 0013 0D0A 00   		.string	"\r\n"
 4361               	.global	errorxModemByteSendTimeout
 4364               	errorxModemByteSendTimeout:
 4365 0016 0D0A 00   		.string	"\r\n"
 4366               	.global	errorxModemWrongFrameNo
 4369               	errorxModemWrongFrameNo:
 4370 0019 0D0A 00   		.string	"\r\n"
 4371               	.global	errorxModemFrameFrameNoCorrectionNotMatch
 4374               	errorxModemFrameFrameNoCorrectionNotMatch:
 4375 001c 0D0A 00   		.string	"\r\n"
 4376               	.global	errorxModemFrameCrc
 4379               	errorxModemFrameCrc:
 4380 001f 784D 6F64 		.string	"xModem CRC error\r\n"
 4380      656D 2043 
 4380      5243 2065 
 4380      7272 6F72 
 4380      0D0A 00
 4381               	.global	errorxModemRemoteSideCan
 4384               	errorxModemRemoteSideCan:
 4385 0032 5265 6D6F 		.string	"Remote side cancelled at frame no %d\r\n"
 4385      7465 2073 
 4385      6964 6520 
 4385      6361 6E63 
 4385      656C 6C65 
 4386               	.global	errorxModemUnknownResponse
 4389               	errorxModemUnknownResponse:
 4390 0059 784D 6F64 		.string	"xModem unknown response 0x%x\r\n"
 4390      656D 2075 
 4390      6E6B 6E6F 
 4390      776E 2072 
 4390      6573 706F 
 4391               	.global	errorNoRemoteDevice
 4394               	errorNoRemoteDevice:
 4395 0078 4465 7669 		.string	"Device %d is not responding (%d)\r\n"
 4395      6365 2025 
 4395      6420 6973 
 4395      206E 6F74 
 4395      2072 6573 
 4396               	.global	errorBootloaderNotResponding
 4399               	errorBootloaderNotResponding:
 4400 009b 426F 6F74 		.string	"Bootloader is not responding\r\n"
 4400      6C6F 6164 
 4400      6572 2069 
 4400      7320 6E6F 
 4400      7420 7265 
 4401               	.global	errorOpenFile
 4404               	errorOpenFile:
 4405 00ba 4361 6E27 		.string	"Can't open file %s\r\n"
 4405      7420 6F70 
 4405      656E 2066 
 4405      696C 6520 
 4405      2573 0D0A 
 4406               	.global	systemStateStr
 4409               	systemStateStr:
 4410 00cf 5379 7374 		.string	"System state:\r\n"
 4410      656D 2073 
 4410      7461 7465 
 4410      3A0D 0A00 
 4411               	.global	statusNumberOfTasksStr
 4414               	statusNumberOfTasksStr:
 4415 00df 2020 4E75 		.string	"  Number of tasks : %d\r\n"
 4415      6D62 6572 
 4415      206F 6620 
 4415      7461 736B 
 4415      7320 3A20 
 4416               	.global	statusStaticHeapStateStr
 4419               	statusStaticHeapStateStr:
 4420 00f8 2020 4672 		.string	"  FreeRtos heap   : %d free of %d bytes\r\n"
 4420      6565 5274 
 4420      6F73 2068 
 4420      6561 7020 
 4420      2020 3A20 
 4421               	.global	statusDynamicHeapStateStr
 4424               	statusDynamicHeapStateStr:
 4425 0122 2020 4D61 		.string	"  Malloc heap     : %d free of %d bytes\r\n"
 4425      6C6C 6F63 
 4425      2068 6561 
 4425      7020 2020 
 4425      2020 3A20 
 4426               	.global	statusRamDiskStateStr
 4429               	statusRamDiskStateStr:
 4430 014c 2020 5261 		.string	"  Ram disc space  : %d free of %d clusters\r\n"
 4430      6D20 6469 
 4430      7363 2073 
 4430      7061 6365 
 4430      2020 3A20 
 4431               	.global	statusTemperatureStr
 4434               	statusTemperatureStr:
 4435 0179 2020 5465 		.string	"  Temperature     : %d C\r\n"
 4435      6D70 6572 
 4435      6174 7572 
 4435      6520 2020 
 4435      2020 3A20 
 4436               	.global	statusVoltageStr
 4439               	statusVoltageStr:
 4440 0194 2020 566F 		.string	"  Voltage         : %d V\r\n"
 4440      6C74 6167 
 4440      6520 2020 
 4440      2020 2020 
 4440      2020 3A20 
 4441               	.global	systemRamConfigStr
 4444               	systemRamConfigStr:
 4445 01af 5379 7374 		.string	"System settings:\r\n"
 4445      656D 2073 
 4445      6574 7469 
 4445      6E67 733A 
 4445      0D0A 00
 4446               	.global	statusMacStr
 4449               	statusMacStr:
 4450 01c2 2020 4D61 		.string	"  Mac address     : "
 4450      6320 6164 
 4450      6472 6573 
 4450      7320 2020 
 4450      2020 3A20 
 4451               	.global	statusIpStr
 4454               	statusIpStr:
 4455 01d7 2020 4950 		.string	"  IP address      : "
 4455      2061 6464 
 4455      7265 7373 
 4455      2020 2020 
 4455      2020 3A20 
 4456               	.global	statusIpMaskStr
 4459               	statusIpMaskStr:
 4460 01ec 2020 6D61 		.string	"  mask            : "
 4460      736B 2020 
 4460      2020 2020 
 4460      2020 2020 
 4460      2020 3A20 
 4461               	.global	statusIpGwStr
 4464               	statusIpGwStr:
 4465 0201 2020 6761 		.string	"  gateway         : "
 4465      7465 7761 
 4465      7920 2020 
 4465      2020 2020 
 4465      2020 3A20 
 4466               	.global	statusRs485listStr
 4469               	statusRs485listStr:
 4470 0216 4465 7465 		.string	"Detected RS 485 devices:\r\n"
 4470      6374 6564 
 4470      2052 5320 
 4470      3438 3520 
 4470      6465 7669 
 4471               	.global	statusNoRs485Dev
 4474               	statusNoRs485Dev:
 4475 0231 2020 4361 		.string	"  Can't find any device\r\n"
 4475      6E27 7420 
 4475      6669 6E64 
 4475      2061 6E79 
 4475      2064 6576 
 4476               	.global	statusLockerSensorsStr
 4479               	statusLockerSensorsStr:
 4480 024b 4C6F 636B 		.string	"Locker sensors states:\r\n"
 4480      6572 2073 
 4480      656E 736F 
 4480      7273 2073 
 4480      7461 7465 
 4481               	.global	statusLockerSensorsDisStr
 4484               	statusLockerSensorsDisStr:
 4485 0264 2020 4C6F 		.string	"  Locker sensors disabled\r\n"
 4485      636B 6572 
 4485      2073 656E 
 4485      736F 7273 
 4485      2064 6973 
 4486               	.global	editRamFileIntroStr
 4489               	editRamFileIntroStr:
 4490 0280 5772 6974 		.string	"Writing to file. Press CTRL+C to quit\r\n"
 4490      696E 6720 
 4490      746F 2066 
 4490      696C 652E 
 4490      2050 7265 
 4491               	.global	readRamFIleLenStr
 4494               	readRamFIleLenStr:
 4495 02a8 4669 6C65 		.string	"File length: %d\r\n"
 4495      206C 656E 
 4495      6774 683A 
 4495      2025 640D 
 4495      0A00 
 4496               	.global	xwyslijStartStr
 4499               	xwyslijStartStr:
 4500 02ba 586D 6F64 		.string	"Xmodem: Transmission start\r\n"
 4500      656D 3A20 
 4500      5472 616E 
 4500      736D 6973 
 4500      7369 6F6E 
 4501               	.global	movingCurtainUpStr
 4504               	movingCurtainUpStr:
 4505 02d7 506F 646E 		.string	"Podnoszenie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4505      6F73 7A65 
 4505      6E69 6520 
 4505      726F 6C65 
 4505      7479 0D0A 
 4506               	.global	movingCurtainDownStr
 4509               	movingCurtainDownStr:
 4510 030a 4F70 7573 		.string	"Opuszczanie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4510      7A63 7A61 
 4510      6E69 6520 
 4510      726F 6C65 
 4510      7479 0D0A 
 4511               	.global	movingCurtainPosStr
 4514               	movingCurtainPosStr:
 4515 033d 0970 6F7A 		.string	"\tpozycja   %d\r\n"
 4515      7963 6A61 
 4515      2020 2025 
 4515      640D 0A00 
 4516               	.global	debugEnabledInfoStr
 4519               	debugEnabledInfoStr:
 4520 034d 456E 6162 		.string	"Enabled %s debug\r\n"
 4520      6C65 6420 
 4520      2573 2064 
 4520      6562 7567 
 4520      0D0A 00
 4521               	.global	debugDisabledInfoStr
 4524               	debugDisabledInfoStr:
 4525 0360 4469 7361 		.string	"Disabled %s debug\r\n"
 4525      626C 6564 
 4525      2025 7320 
 4525      6465 6275 
 4525      670D 0A00 
 4526               	.global	cmd_help
 4529               	cmd_help:
 4530 0374 6865 6C70 		.string	"help"
 4530      00
 4531               	.global	cmd_help_help
 4534               	cmd_help_help:
 4535 0379 5072 696E 		.string	"Print help string"
 4535      7420 6865 
 4535      6C70 2073 
 4535      7472 696E 
 4535      6700 
 4536               	.global	cmd_status
 4539               	cmd_status:
 4540 038b 7374 6174 		.string	"status"
 4540      7573 00
 4541               	.global	cmd_help_status
 4544               	cmd_help_status:
 4545 0392 7B66 696C 		.string	"{filename} Print device status on VTY or write to file"
 4545      656E 616D 
 4545      657D 2050 
 4545      7269 6E74 
 4545      2064 6576 
 4546               	.global	cmd_enc_stat
 4549               	cmd_enc_stat:
 4550 03c9 656E 6373 		.string	"encstat"
 4550      7461 7400 
 4551               	.global	cmd_help_enc_stat
 4554               	cmd_help_enc_stat:
 4555 03d1 5072 696E 		.string	"Print Enc 28j60 registers"
 4555      7420 456E 
 4555      6320 3238 
 4555      6A36 3020 
 4555      7265 6769 
 4556               	.global	cmd_time
 4559               	cmd_time:
 4560 03eb 7469 6D65 		.string	"time"
 4560      00
 4561               	.global	cmd_help_time
 4564               	cmd_help_time:
 4565 03f0 5072 696E 		.string	"Print time"
 4565      7420 7469 
 4565      6D65 00
 4566               	.global	cmd_net_dbg
 4569               	cmd_net_dbg:
 4570 03fb 6465 6275 		.string	"debug"
 4570      6700 
 4571               	.global	cmd_help_net_dbg
 4574               	cmd_help_net_dbg:
 4575 0401 5B61 7270 		.ascii	"[arp|icm"
 4575      7C69 636D 
 4576 0409 707C 6970 		.string	"p|ip|tcp|udp] [level] write debug info. Level 0 disable debuging"
 4576      7C74 6370 
 4576      7C75 6470 
 4576      5D20 5B6C 
 4576      6576 656C 
 4577               	.global	cmd_rping
 4580               	cmd_rping:
 4581 044a 7270 696E 		.string	"rping"
 4581      6700 
 4582               	.global	cmd_help_rping
 4585               	cmd_help_rping:
 4586 0450 5B44 6576 		.string	"[Device no] Send ping to Rs485 device"
 4586      6963 6520 
 4586      6E6F 5D20 
 4586      5365 6E64 
 4586      2070 696E 
 4587               	.global	cmd_ping
 4590               	cmd_ping:
 4591 0476 7069 6E67 		.string	"ping"
 4591      00
 4592               	.global	cmd_help_ping
 4595               	cmd_help_ping:
 4596 047b 5B41 315D 		.string	"[A1] [A2] [A3] [A4] Sends ping throught ethernet"
 4596      205B 4132 
 4596      5D20 5B41 
 4596      335D 205B 
 4596      4134 5D20 
 4597               	.global	cmd_xRec
 4600               	cmd_xRec:
 4601 04ac 7872 6563 		.string	"xrec"
 4601      00
 4602               	.global	cmd_help_xRec
 4605               	cmd_help_xRec:
 4606 04b1 5B66 696C 		.string	"[file name] receive file using xModem"
 4606      6520 6E61 
 4606      6D65 5D20 
 4606      7265 6365 
 4606      6976 6520 
 4607               	.global	cmd_xSend
 4610               	cmd_xSend:
 4611 04d7 7873 656E 		.string	"xsend"
 4611      6400 
 4612               	.global	cmd_help_xSend
 4615               	cmd_help_xSend:
 4616 04dd 5B66 696C 		.string	"[file name] send file using xModem"
 4616      6520 6E61 
 4616      6D65 5D20 
 4616      7365 6E64 
 4616      2066 696C 
 4617               	.global	cmd_xflash
 4620               	cmd_xflash:
 4621 0500 7866 6C61 		.string	"xflash"
 4621      7368 00
 4622               	.global	cmd_help_xflash
 4625               	cmd_help_xflash:
 4626 0507 5B64 6576 		.string	"[device no] [file name] flash device connected to Rs485"
 4626      6963 6520 
 4626      6E6F 5D20 
 4626      5B66 696C 
 4626      6520 6E61 
 4627               	.global	cmd_dir_rf
 4630               	cmd_dir_rf:
 4631 053f 6469 7272 		.string	"dirrf"
 4631      6600 
 4632               	.global	cmd_help_dir_rf
 4635               	cmd_help_dir_rf:
 4636 0545 5072 696E 		.string	"Print ramdisk files"
 4636      7420 7261 
 4636      6D64 6973 
 4636      6B20 6669 
 4636      6C65 7300 
 4637               	.global	cmd_create_rf
 4640               	cmd_create_rf:
 4641 0559 6372 6600 		.string	"crf"
 4642               	.global	cmd_help_create_rf
 4645               	cmd_help_create_rf:
 4646 055d 5B66 696C 		.string	"[file name] create ram file"
 4646      6520 6E61 
 4646      6D65 5D20 
 4646      6372 6561 
 4646      7465 2072 
 4647               	.global	cmd_erase_rf
 4650               	cmd_erase_rf:
 4651 0579 6572 6173 		.string	"eraserf"
 4651      6572 6600 
 4652               	.global	cmd_help_erase_rf
 4655               	cmd_help_erase_rf:
 4656 0581 5B66 696C 		.string	"[file name] erase file from ram disk"
 4656      6520 6E61 
 4656      6D65 5D20 
 4656      6572 6173 
 4656      6520 6669 
 4657               	.global	cmd_edit_rf
 4660               	cmd_edit_rf:
 4661 05a6 6564 6974 		.string	"editrf"
 4661      7266 00
 4662               	.global	cmd_help_edit_rf
 4665               	cmd_help_edit_rf:
 4666 05ad 5B66 696C 		.string	"[file name] edit file located on ram disk"
 4666      6520 6E61 
 4666      6D65 5D20 
 4666      6564 6974 
 4666      2066 696C 
 4667               	.global	cmd_read_rf
 4670               	cmd_read_rf:
 4671 05d7 7265 6164 		.string	"readrf"
 4671      7266 00
 4672               	.global	cmd_help_read_rf
 4675               	cmd_help_read_rf:
 4676 05de 5B66 696C 		.string	"[file name] read file located on ram disk"
 4676      6520 6E61 
 4676      6D65 5D20 
 4676      7265 6164 
 4676      2066 696C 
 4677               	.global	cmd_up
 4680               	cmd_up:
 4681 0608 7570 00   		.string	"up"
 4682               	.global	cmd_help_up
 4685               	cmd_help_up:
 4686 060b 5B64 7269 		.string	"[driver no] [channel] {value} move up"
 4686      7665 7220 
 4686      6E6F 5D20 
 4686      5B63 6861 
 4686      6E6E 656C 
 4687               	.global	cmd_down
 4690               	cmd_down:
 4691 0631 646F 776E 		.string	"down"
 4691      00
 4692               	.global	cmd_help_down
 4695               	cmd_help_down:
 4696 0636 5B64 7269 		.string	"[driver no] [channel] {value} move down"
 4696      7665 7220 
 4696      6E6F 5D20 
 4696      5B63 6861 
 4696      6E6E 656C 
 4697               	.global	cmd_spa
 4700               	cmd_spa:
 4701 065e 7370 6100 		.string	"spa"
 4702               	.global	cmd_help_spa
 4705               	cmd_help_spa:
 4706 0662 5B76 616C 		.string	"[value] set port A"
 4706      7565 5D20 
 4706      7365 7420 
 4706      706F 7274 
 4706      2041 00
 4707               	.global	cmd_spb
 4710               	cmd_spb:
 4711 0675 7370 6200 		.string	"spb"
 4712               	.global	cmd_help_spb
 4715               	cmd_help_spb:
 4716 0679 5B76 616C 		.string	"[value] set port B"
 4716      7565 5D20 
 4716      7365 7420 
 4716      706F 7274 
 4716      2042 00
 4717               	.global	cmd_settime
 4720               	cmd_settime:
 4721 068c 7365 7474 		.string	"settime"
 4721      696D 6500 
 4722               	.global	cmd_help_settime
 4725               	cmd_help_settime:
 4726 0694 5B68 5D20 		.string	"[h] [m] [s] set time (24h format)"
 4726      5B6D 5D20 
 4726      5B73 5D20 
 4726      7365 7420 
 4726      7469 6D65 
 4727               	.global	cmd_ac
 4730               	cmd_ac:
 4731 06b6 6163 00   		.string	"ac"
 4732               	.global	cmd_help_ac
 4735               	cmd_help_ac:
 4736 06b9 5B63 6861 		.string	"[channel 0-7] read analog value"
 4736      6E6E 656C 
 4736      2030 2D37 
 4736      5D20 7265 
 4736      6164 2061 
 4737               	.global	cmd_enable
 4740               	cmd_enable:
 4741 06d9 656E 6162 		.string	"enable"
 4741      6C65 00
 4742               	.global	cmd_help_enable
 4745               	cmd_help_enable:
 4746 06e0 456E 6162 		.string	"Enable mode"
 4746      6C65 206D 
 4746      6F64 6500 
 4747               	.global	cmd_disable
 4750               	cmd_disable:
 4751 06ec 6469 7361 		.string	"disable"
 4751      626C 6500 
 4752               	.global	cmd_help_disable
 4755               	cmd_help_disable:
 4756 06f4 5669 6577 		.string	"View mode"
 4756      206D 6F64 
 4756      6500 
 4757               	.global	cmd_configure
 4760               	cmd_configure:
 4761 06fe 636F 6E66 		.string	"config"
 4761      6967 00
 4762               	.global	cmd_help_configure
 4765               	cmd_help_configure:
 4766 0705 436F 6E66 		.string	"Configure mode"
 4766      6967 7572 
 4766      6520 6D6F 
 4766      6465 00
 4767               	.global	cmd_conf_ip
 4770               	cmd_conf_ip:
 4771 0714 6970 00   		.string	"ip"
 4772               	.global	cmd_help_conf_ip
 4775               	cmd_help_conf_ip:
 4776 0717 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set IP address"
 4776      205B 4132 
 4776      5D20 5B41 
 4776      335D 205B 
 4776      4134 5D20 
 4777               	.global	cmd_conf_udp
 4780               	cmd_conf_udp:
 4781 073a 7564 7000 		.string	"udp"
 4782               	.global	cmd_help_conf_udp
 4785               	cmd_help_conf_udp:
 4786 073e 5B41 315D 		.ascii	"[A1] [A2] [A3"
 4786      205B 4132 
 4786      5D20 5B41 
 4786      33
 4787 074b 5D20 5B41 		.string	"] [A4] [src port] {dst port} set udp client IP address and ports"
 4787      345D 205B 
 4787      7372 6320 
 4787      706F 7274 
 4787      5D20 7B64 
 4788               	.global	cmd_conf_ip_mask
 4791               	cmd_conf_ip_mask:
 4792 078c 6D61 736B 		.string	"mask"
 4792      00
 4793               	.global	cmd_conf_ip_mask_help
 4796               	cmd_conf_ip_mask_help:
 4797 0791 5B6D 6173 		.string	"[mask] set mask"
 4797      6B5D 2073 
 4797      6574 206D 
 4797      6173 6B00 
 4798               	.global	cmd_conf_ip_gw
 4801               	cmd_conf_ip_gw:
 4802 07a1 6777 00   		.string	"gw"
 4803               	.global	cmd_conf_ip_gw_help
 4806               	cmd_conf_ip_gw_help:
 4807 07a4 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set default gateway"
 4807      205B 4132 
 4807      5D20 5B41 
 4807      335D 205B 
 4807      4134 5D20 
 4808               	.global	cmd_conf_mac
 4811               	cmd_conf_mac:
 4812 07cc 6D61 6300 		.string	"mac"
 4813               	.global	cmd_help_conf_mac
 4816               	cmd_help_conf_mac:
 4817 07d0 5B41 315D 		.string	"[A1] [A2] [A3] [A4] [A5] [A6] set MAC address"
 4817      205B 4132 
 4817      5D20 5B41 
 4817      335D 205B 
 4817      4134 5D20 
 4818               	.global	cmd_conf_save
 4821               	cmd_conf_save:
 4822 07fe 7361 7665 		.string	"save"
 4822      00
 4823               	.global	cmd_help_conf_save
 4826               	cmd_help_conf_save:
 4827 0803 5361 7665 		.string	"Save configuration"
 4827      2063 6F6E 
 4827      6669 6775 
 4827      7261 7469 
 4827      6F6E 00
 4828               	.global	cmd_ustawR
 4831               	cmd_ustawR:
 4832 0816 7365 7472 		.string	"setr"
 4832      00
 4833               	.global	cmd_help_ustawR
 4836               	cmd_help_ustawR:
 4837 081b 5B76 616C 		.string	"[value] set resistance value"
 4837      7565 5D20 
 4837      7365 7420 
 4837      7265 7369 
 4837      7374 616E 
 4838               	.global	okStr
 4841               	okStr:
 4842 0838 4F4B 0D0A 		.string	"OK\r\n"
 4842      00
 4843               	.global	nlStr
 4846               	nlStr:
 4847 083d 0D0A 00   		.string	"\r\n"
 4848               	.global	BladBuforaPozostaloBajtowStr
 4851               	BladBuforaPozostaloBajtowStr:
 4852 0840 2121 2120 		.string	"!!! W budorze Rs485 pozostalo %d bajtow\r\n"
 4852      5720 6275 
 4852      646F 727A 
 4852      6520 5273 
 4852      3438 3520 
 4853               	.global	errorStrings
 4856               	errorStrings:
 4857 086a 0000      		.word	errorOK
 4858 086c 0000      		.word	errorNoFile
 4859 086e 0000      		.word	errorxModemFrameStartTimeout
 4860 0870 0000      		.word	errorxModemByteSendTimeout
 4861 0872 0000      		.word	errorxModemWrongFrameNo
 4862 0874 0000      		.word	errorxModemFrameFrameNoCorrectionNotMatch
 4863 0876 0000      		.word	errorxModemFrameCrc
 4864 0878 0000      		.word	errorxModemRemoteSideCan
 4865 087a 0000      		.word	errorxModemUnknownResponse
 4866 087c 0000      		.word	errorNoRemoteDevice
 4867 087e 0000      		.word	errorBootloaderNotResponding
 4868 0880 0000      		.word	errorOpenFile
 4869               	.global	cmdListNormal
 4872               	cmdListNormal:
 4873 0882 0000      		.word	cmd_help
 4874 0884 0000      		.word	cmd_help_help
 4875 0886 0000      		.word	gs(helpFunction)
 4876 0888 0000      		.word	cmd_status
 4877 088a 0000      		.word	cmd_help_status
 4878 088c 0000      		.word	gs(statusFunction)
 4879 088e 0000      		.word	cmd_time
 4880 0890 0000      		.word	cmd_help_time
 4881 0892 0000      		.word	gs(pokazCzasFunction)
 4882 0894 0000      		.word	cmd_rping
 4883 0896 0000      		.word	cmd_help_rping
 4884 0898 0000      		.word	gs(rpingFunction)
 4885 089a 0000      		.word	cmd_ping
 4886 089c 0000      		.word	cmd_help_ping
 4887 089e 0000      		.word	gs(pingFunction)
 4888 08a0 0000      		.word	cmd_dir_rf
 4889 08a2 0000      		.word	cmd_help_dir_rf
 4890 08a4 0000      		.word	gs(writeRamFileFunction)
 4891 08a6 0000      		.word	cmd_read_rf
 4892 08a8 0000      		.word	cmd_help_read_rf
 4893 08aa 0000      		.word	gs(readRamFIleFunction)
 4894 08ac 0000      		.word	cmd_enable
 4895 08ae 0000      		.word	cmd_help_enable
 4896 08b0 0000      		.word	gs(enableFunction)
 4897 08b2 0000      		.word	0
 4898 08b4 0000      		.word	0
 4899 08b6 0000      		.word	0
 4900               	.global	cmdListEnable
 4903               	cmdListEnable:
 4904 08b8 0000      		.word	cmd_help
 4905 08ba 0000      		.word	cmd_help_help
 4906 08bc 0000      		.word	gs(helpFunction)
 4907 08be 0000      		.word	cmd_status
 4908 08c0 0000      		.word	cmd_help_status
 4909 08c2 0000      		.word	gs(statusFunction)
 4910 08c4 0000      		.word	cmd_enc_stat
 4911 08c6 0000      		.word	cmd_help_enc_stat
 4912 08c8 0000      		.word	gs(statusEncFunction)
 4913 08ca 0000      		.word	cmd_time
 4914 08cc 0000      		.word	cmd_help_time
 4915 08ce 0000      		.word	gs(pokazCzasFunction)
 4916 08d0 0000      		.word	cmd_net_dbg
 4917 08d2 0000      		.word	cmd_help_net_dbg
 4918 08d4 0000      		.word	gs(debugFunction)
 4919 08d6 0000      		.word	cmd_rping
 4920 08d8 0000      		.word	cmd_help_rping
 4921 08da 0000      		.word	gs(rpingFunction)
 4922 08dc 0000      		.word	cmd_ping
 4923 08de 0000      		.word	cmd_help_ping
 4924 08e0 0000      		.word	gs(pingFunction)
 4925 08e2 0000      		.word	cmd_xRec
 4926 08e4 0000      		.word	cmd_help_xRec
 4927 08e6 0000      		.word	gs(goXmodemOdbierzFunction)
 4928 08e8 0000      		.word	cmd_xSend
 4929 08ea 0000      		.word	cmd_help_xSend
 4930 08ec 0000      		.word	gs(goXmodemWyslijFunction)
 4931 08ee 0000      		.word	cmd_xflash
 4932 08f0 0000      		.word	cmd_help_xflash
 4933 08f2 0000      		.word	gs(flashExModuleFunction)
 4934 08f4 0000      		.word	cmd_dir_rf
 4935 08f6 0000      		.word	cmd_help_dir_rf
 4936 08f8 0000      		.word	gs(writeRamFileFunction)
 4937 08fa 0000      		.word	cmd_create_rf
 4938 08fc 0000      		.word	cmd_help_create_rf
 4939 08fe 0000      		.word	gs(dodajRamPlikFunction)
 4940 0900 0000      		.word	cmd_erase_rf
 4941 0902 0000      		.word	cmd_help_erase_rf
 4942 0904 0000      		.word	gs(eraseRamFileFunction)
 4943 0906 0000      		.word	cmd_edit_rf
 4944 0908 0000      		.word	cmd_help_edit_rf
 4945 090a 0000      		.word	gs(editRamFileFunction)
 4946 090c 0000      		.word	cmd_read_rf
 4947 090e 0000      		.word	cmd_help_read_rf
 4948 0910 0000      		.word	gs(readRamFIleFunction)
 4949 0912 0000      		.word	cmd_up
 4950 0914 0000      		.word	cmd_help_up
 4951 0916 0000      		.word	gs(curtainUpFunction)
 4952 0918 0000      		.word	cmd_down
 4953 091a 0000      		.word	cmd_help_down
 4954 091c 0000      		.word	gs(curtainDownFunction)
 4955 091e 0000      		.word	cmd_spa
 4956 0920 0000      		.word	cmd_help_spa
 4957 0922 0000      		.word	gs(ustawPortExtAFunction)
 4958 0924 0000      		.word	cmd_spb
 4959 0926 0000      		.word	cmd_help_spb
 4960 0928 0000      		.word	gs(ustawPortExtBFunction)
 4961 092a 0000      		.word	cmd_ustawR
 4962 092c 0000      		.word	cmd_help_ustawR
 4963 092e 0000      		.word	gs(ustawPortRezystor)
 4964 0930 0000      		.word	cmd_settime
 4965 0932 0000      		.word	cmd_help_settime
 4966 0934 0000      		.word	gs(setTimeFunction)
 4967 0936 0000      		.word	cmd_ac
 4968 0938 0000      		.word	cmd_help_ac
 4969 093a 0000      		.word	gs(czytajAC_Function)
 4970 093c 0000      		.word	cmd_disable
 4971 093e 0000      		.word	cmd_help_disable
 4972 0940 0000      		.word	gs(disableFunction)
 4973 0942 0000      		.word	cmd_configure
 4974 0944 0000      		.word	cmd_help_configure
 4975 0946 0000      		.word	gs(configureModeFunction)
 4976 0948 0000      		.word	0
 4977 094a 0000      		.word	0
 4978 094c 0000      		.word	0
 4979               	.global	cmdListConfigure
 4982               	cmdListConfigure:
 4983 094e 0000      		.word	cmd_help
 4984 0950 0000      		.word	cmd_help_help
 4985 0952 0000      		.word	gs(helpFunction)
 4986 0954 0000      		.word	cmd_status
 4987 0956 0000      		.word	cmd_help_status
 4988 0958 0000      		.word	gs(statusFunction)
 4989 095a 0000      		.word	cmd_time
 4990 095c 0000      		.word	cmd_help_time
 4991 095e 0000      		.word	gs(pokazCzasFunction)
 4992 0960 0000      		.word	cmd_settime
 4993 0962 0000      		.word	cmd_help_settime
 4994 0964 0000      		.word	gs(setTimeFunction)
 4995 0966 0000      		.word	cmd_conf_ip
 4996 0968 0000      		.word	cmd_help_conf_ip
 4997 096a 0000      		.word	gs(setIpFunction)
 4998 096c 0000      		.word	cmd_conf_ip_mask
 4999 096e 0000      		.word	cmd_conf_ip_mask_help
 5000 0970 0000      		.word	gs(setIpMaskFunction)
 5001 0972 0000      		.word	cmd_conf_ip_gw
 5002 0974 0000      		.word	cmd_conf_ip_gw_help
 5003 0976 0000      		.word	gs(setIpGwFunction)
 5004 0978 0000      		.word	cmd_conf_udp
 5005 097a 0000      		.word	cmd_help_conf_udp
 5006 097c 0000      		.word	gs(setUdpFunction)
 5007 097e 0000      		.word	cmd_conf_mac
 5008 0980 0000      		.word	cmd_help_conf_mac
 5009 0982 0000      		.word	gs(setMacAddrFunction)
 5010 0984 0000      		.word	cmd_conf_save
 5011 0986 0000      		.word	cmd_help_conf_save
 5012 0988 0000      		.word	gs(saveConfigFunction)
 5013 098a 0000      		.word	cmd_enable
 5014 098c 0000      		.word	cmd_help_enable
 5015 098e 0000      		.word	gs(enableFunction)
 5016 0990 0000      		.word	cmd_disable
 5017 0992 0000      		.word	cmd_help_disable
 5018 0994 0000      		.word	gs(disableFunction)
 5019 0996 0000      		.word	0
 5020 0998 0000      		.word	0
 5021 099a 0000      		.word	0
 5024               	__c.3459:
 5025 099c 5761 7274 		.string	"Wartosc probki na wejsciu %d: %d\r\n"
 5025      6F73 6320 
 5025      7072 6F62 
 5025      6B69 206E 
 5025      6120 7765 
 5028               	__c.3577:
 5029 09bf 586D 6F64 		.string	"Xmodem: rozpoczynanie odbioru\r\n"
 5029      656D 3A20 
 5029      726F 7A70 
 5029      6F63 7A79 
 5029      6E61 6E69 
 5032               	__c.3329:
 5033 09df 7564 7000 		.string	"udp"
 5036               	__c.3327:
 5037 09e3 7463 7000 		.string	"tcp"
 5040               	__c.3325:
 5041 09e7 6963 6D70 		.string	"icmp"
 5041      00
 5044               	__c.3323:
 5045 09ec 6970 00   		.string	"ip"
 5048               	__c.3321:
 5049 09ef 6172 7000 		.string	"arp"
 5052               	__c.3319:
 5053 09f3 7564 7000 		.string	"udp"
 5056               	__c.3317:
 5057 09f7 7463 7000 		.string	"tcp"
 5060               	__c.3315:
 5061 09fb 6963 6D70 		.string	"icmp"
 5061      00
 5064               	__c.3313:
 5065 0a00 6970 00   		.string	"ip"
 5068               	__c.3311:
 5069 0a03 6172 7000 		.string	"arp"
 5072               	__c.3281:
 5073 0a07 416B 7475 		.string	"Aktualny czas %d:%d:%d\r\n"
 5073      616C 6E79 
 5073      2063 7A61 
 5073      7320 2564 
 5073      3A25 643A 
 5076               	__c.3240:
 5077 0a20 0D0A 00   		.string	"\r\n"
 5080               	__c.3238:
 5081 0a23 0D0A 00   		.string	"\r\n"
 5084               	__c.3236:
 5085 0a26 0D0A 00   		.string	"\r\n"
 5088               	__c.3234:
 5089 0a29 0D0A 00   		.string	"\r\n"
 5092               	__c.3231:
 5093 0a2c 4672 6565 		.string	"FreeRtos+ ver 0.31 build: Aug 19 2011, 15:03:16\r\n"
 5093      5274 6F73 
 5093      2B20 7665 
 5093      7220 302E 
 5093      3331 2062 
 5094               		.comm klastry,128,1
 5095               		.comm wwwport,1,1
 5096               		.comm rollers,2,1
 5097               		.comm xSemaphoreSpiSS,2,1
 5098               		.comm portA,1,1
 5099               		.comm portB,1,1
 5100               		.comm lockSensors,2,1
 5101               		.comm xSemaphoreRs485,2,1
 5102               		.comm nicState,14,1
 5103               		.comm IpMyConfig,15,1
 5104               		.comm arpDebug,2,1
 5105               		.comm arpDebugLevel,1,1
 5106               		.comm icmpDebug,2,1
 5107               		.comm icmpDebugLevel,1,1
 5108               		.comm udpSocket,2,1
 5109               		.comm udpDbgStream,2,1
 5110               		.comm udpDbgLevel,1,1
 5111               		.comm tcpDebugStream,2,1
 5112               		.comm tcpDebugLevel,1,1
 5113               		.comm sockets,2,1
 5114               		.comm Ipv6MyConfig,5,1
 5115               		.comm debugStream,2,1
 5116               		.comm czasRtc,7,1
 5117               		.comm fdVty,6,1
 5265               		.weak	nicRegDump
 5266               		.weak	nicSetMacAddress
 5267               		.text
 5269               	.Letext0:
 5270               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 vty.c
     /tmp/cc9RgtHo.s:2      *ABS*:0000003f __SREG__
     /tmp/cc9RgtHo.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc9RgtHo.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc9RgtHo.s:5      *ABS*:00000034 __CCP__
     /tmp/cc9RgtHo.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc9RgtHo.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc9RgtHo.s:262    .text:00000000 enableFunction
     /tmp/cc9RgtHo.s:4903   .progmem.data:000008b8 cmdListEnable
     /tmp/cc9RgtHo.s:304    .text:00000022 disableFunction
     /tmp/cc9RgtHo.s:4872   .progmem.data:00000882 cmdListNormal
     /tmp/cc9RgtHo.s:340    .text:0000003a configureModeFunction
     /tmp/cc9RgtHo.s:4982   .progmem.data:0000094e cmdListConfigure
     /tmp/cc9RgtHo.s:382    .text:0000005c saveConfigFunction
     /tmp/cc9RgtHo.s:405    .text:00000066 setMacAddrFunction
                            *COM*:0000000e nicState
     /tmp/cc9RgtHo.s:482    .text:000000d4 pingFunction
     /tmp/cc9RgtHo.s:538    .text:00000112 setUdpFunction
                            *COM*:00000002 udpSocket
     /tmp/cc9RgtHo.s:686    .text:0000020c setIpGwFunction
     /tmp/cc9RgtHo.s:794    .text:000002bc setIpMaskFunction
     /tmp/cc9RgtHo.s:849    .text:000002fc setIpFunction
     /tmp/cc9RgtHo.s:957    .text:000003ac czytajAC_Function
     /tmp/cc9RgtHo.s:5024   .progmem.data:0000099c __c.3459
     /tmp/cc9RgtHo.s:1038   .text:00000424 printErrorInfo
     /tmp/cc9RgtHo.s:4856   .progmem.data:0000086a errorStrings
     /tmp/cc9RgtHo.s:1135   .text:0000049a setTimeFunction
                            *COM*:00000007 czasRtc
     /tmp/cc9RgtHo.s:1271   .text:00000568 ustawPortRezystor
     /tmp/cc9RgtHo.s:1312   .text:0000058c ustawPortExtBFunction
     /tmp/cc9RgtHo.s:1350   .text:000005b0 ustawPortExtAFunction
     /tmp/cc9RgtHo.s:1388   .text:000005d4 curtainDownFunction
     /tmp/cc9RgtHo.s:4509   .progmem.data:0000030a movingCurtainDownStr
     /tmp/cc9RgtHo.s:4514   .progmem.data:0000033d movingCurtainPosStr
     /tmp/cc9RgtHo.s:1542   .text:000006c0 curtainUpFunction
     /tmp/cc9RgtHo.s:4504   .progmem.data:000002d7 movingCurtainUpStr
     /tmp/cc9RgtHo.s:1714   .text:000007c4 goXmodemWyslijFunction
     /tmp/cc9RgtHo.s:4499   .progmem.data:000002ba xwyslijStartStr
                            *COM*:00000006 fdVty
     /tmp/cc9RgtHo.s:4404   .progmem.data:000000ba errorOpenFile
     /tmp/cc9RgtHo.s:1816   .text:00000868 editRamFileFunction
     /tmp/cc9RgtHo.s:4489   .progmem.data:00000280 editRamFileIntroStr
     /tmp/cc9RgtHo.s:1976   .text:00000968 eraseRamFileFunction
     /tmp/cc9RgtHo.s:2019   .text:00000996 dodajRamPlikFunction
     /tmp/cc9RgtHo.s:2071   .text:000009d0 rpingFunction
     /tmp/cc9RgtHo.s:2138   .text:00000a1c flashExModuleFunction
     /tmp/cc9RgtHo.s:2275   .text:00000ade goXmodemOdbierzFunction
     /tmp/cc9RgtHo.s:5028   .progmem.data:000009bf __c.3577
     /tmp/cc9RgtHo.s:2961   .text:00000ec6 debugFunction
     /tmp/cc9RgtHo.s:5068   .progmem.data:00000a03 __c.3311
     /tmp/cc9RgtHo.s:5064   .progmem.data:00000a00 __c.3313
     /tmp/cc9RgtHo.s:5060   .progmem.data:000009fb __c.3315
     /tmp/cc9RgtHo.s:5056   .progmem.data:000009f7 __c.3317
     /tmp/cc9RgtHo.s:4524   .progmem.data:00000360 debugDisabledInfoStr
     /tmp/cc9RgtHo.s:5052   .progmem.data:000009f3 __c.3319
     /tmp/cc9RgtHo.s:5048   .progmem.data:000009ef __c.3321
     /tmp/cc9RgtHo.s:5044   .progmem.data:000009ec __c.3323
     /tmp/cc9RgtHo.s:5040   .progmem.data:000009e7 __c.3325
     /tmp/cc9RgtHo.s:5036   .progmem.data:000009e3 __c.3327
     /tmp/cc9RgtHo.s:4519   .progmem.data:0000034d debugEnabledInfoStr
     /tmp/cc9RgtHo.s:5032   .progmem.data:000009df __c.3329
     /tmp/cc9RgtHo.s:3252   .text:00001090 statusEncFunction
     /tmp/cc9RgtHo.s:3278   .text:000010a0 readRamFIleFunction
     /tmp/cc9RgtHo.s:4494   .progmem.data:000002a8 readRamFIleLenStr
     /tmp/cc9RgtHo.s:4846   .progmem.data:0000083d nlStr
     /tmp/cc9RgtHo.s:3477   .text:000011e6 writeRamFileFunction
     /tmp/cc9RgtHo.s:3503   .text:000011f6 pokazCzasFunction
     /tmp/cc9RgtHo.s:5072   .progmem.data:00000a07 __c.3281
     /tmp/cc9RgtHo.s:3639   .text:000012e0 helpFunction
     /tmp/cc9RgtHo.s:3663   .text:000012ea printStatus
     /tmp/cc9RgtHo.s:5092   .progmem.data:00000a2c __c.3231
     /tmp/cc9RgtHo.s:4409   .progmem.data:000000cf systemStateStr
     /tmp/cc9RgtHo.s:4414   .progmem.data:000000df statusNumberOfTasksStr
     /tmp/cc9RgtHo.s:4419   .progmem.data:000000f8 statusStaticHeapStateStr
     /tmp/cc9RgtHo.s:4424   .progmem.data:00000122 statusDynamicHeapStateStr
     /tmp/cc9RgtHo.s:4434   .progmem.data:00000179 statusTemperatureStr
     /tmp/cc9RgtHo.s:4439   .progmem.data:00000194 statusVoltageStr
     /tmp/cc9RgtHo.s:4429   .progmem.data:0000014c statusRamDiskStateStr
     /tmp/cc9RgtHo.s:4444   .progmem.data:000001af systemRamConfigStr
     /tmp/cc9RgtHo.s:4449   .progmem.data:000001c2 statusMacStr
     /tmp/cc9RgtHo.s:5088   .progmem.data:00000a29 __c.3234
     /tmp/cc9RgtHo.s:4454   .progmem.data:000001d7 statusIpStr
     /tmp/cc9RgtHo.s:5084   .progmem.data:00000a26 __c.3236
     /tmp/cc9RgtHo.s:4459   .progmem.data:000001ec statusIpMaskStr
     /tmp/cc9RgtHo.s:5080   .progmem.data:00000a23 __c.3238
     /tmp/cc9RgtHo.s:4464   .progmem.data:00000201 statusIpGwStr
     /tmp/cc9RgtHo.s:5076   .progmem.data:00000a20 __c.3240
     /tmp/cc9RgtHo.s:4469   .progmem.data:00000216 statusRs485listStr
     /tmp/cc9RgtHo.s:4474   .progmem.data:00000231 statusNoRs485Dev
     /tmp/cc9RgtHo.s:4479   .progmem.data:0000024b statusLockerSensorsStr
     /tmp/cc9RgtHo.s:4484   .progmem.data:00000264 statusLockerSensorsDisStr
     /tmp/cc9RgtHo.s:4179   .text:0000169a statusFunction
     /tmp/cc9RgtHo.s:4313   .text:00001768 VtyInit
     /tmp/cc9RgtHo.s:4349   .progmem.data:00000000 errorOK
     /tmp/cc9RgtHo.s:4354   .progmem.data:00000009 errorNoFile
     /tmp/cc9RgtHo.s:4359   .progmem.data:00000013 errorxModemFrameStartTimeout
     /tmp/cc9RgtHo.s:4364   .progmem.data:00000016 errorxModemByteSendTimeout
     /tmp/cc9RgtHo.s:4369   .progmem.data:00000019 errorxModemWrongFrameNo
     /tmp/cc9RgtHo.s:4374   .progmem.data:0000001c errorxModemFrameFrameNoCorrectionNotMatch
     /tmp/cc9RgtHo.s:4379   .progmem.data:0000001f errorxModemFrameCrc
     /tmp/cc9RgtHo.s:4384   .progmem.data:00000032 errorxModemRemoteSideCan
     /tmp/cc9RgtHo.s:4389   .progmem.data:00000059 errorxModemUnknownResponse
     /tmp/cc9RgtHo.s:4394   .progmem.data:00000078 errorNoRemoteDevice
     /tmp/cc9RgtHo.s:4399   .progmem.data:0000009b errorBootloaderNotResponding
     /tmp/cc9RgtHo.s:4529   .progmem.data:00000374 cmd_help
     /tmp/cc9RgtHo.s:4534   .progmem.data:00000379 cmd_help_help
     /tmp/cc9RgtHo.s:4539   .progmem.data:0000038b cmd_status
     /tmp/cc9RgtHo.s:4544   .progmem.data:00000392 cmd_help_status
     /tmp/cc9RgtHo.s:4549   .progmem.data:000003c9 cmd_enc_stat
     /tmp/cc9RgtHo.s:4554   .progmem.data:000003d1 cmd_help_enc_stat
     /tmp/cc9RgtHo.s:4559   .progmem.data:000003eb cmd_time
     /tmp/cc9RgtHo.s:4564   .progmem.data:000003f0 cmd_help_time
     /tmp/cc9RgtHo.s:4569   .progmem.data:000003fb cmd_net_dbg
     /tmp/cc9RgtHo.s:4574   .progmem.data:00000401 cmd_help_net_dbg
     /tmp/cc9RgtHo.s:4580   .progmem.data:0000044a cmd_rping
     /tmp/cc9RgtHo.s:4585   .progmem.data:00000450 cmd_help_rping
     /tmp/cc9RgtHo.s:4590   .progmem.data:00000476 cmd_ping
     /tmp/cc9RgtHo.s:4595   .progmem.data:0000047b cmd_help_ping
     /tmp/cc9RgtHo.s:4600   .progmem.data:000004ac cmd_xRec
     /tmp/cc9RgtHo.s:4605   .progmem.data:000004b1 cmd_help_xRec
     /tmp/cc9RgtHo.s:4610   .progmem.data:000004d7 cmd_xSend
     /tmp/cc9RgtHo.s:4615   .progmem.data:000004dd cmd_help_xSend
     /tmp/cc9RgtHo.s:4620   .progmem.data:00000500 cmd_xflash
     /tmp/cc9RgtHo.s:4625   .progmem.data:00000507 cmd_help_xflash
     /tmp/cc9RgtHo.s:4630   .progmem.data:0000053f cmd_dir_rf
     /tmp/cc9RgtHo.s:4635   .progmem.data:00000545 cmd_help_dir_rf
     /tmp/cc9RgtHo.s:4640   .progmem.data:00000559 cmd_create_rf
     /tmp/cc9RgtHo.s:4645   .progmem.data:0000055d cmd_help_create_rf
     /tmp/cc9RgtHo.s:4650   .progmem.data:00000579 cmd_erase_rf
     /tmp/cc9RgtHo.s:4655   .progmem.data:00000581 cmd_help_erase_rf
     /tmp/cc9RgtHo.s:4660   .progmem.data:000005a6 cmd_edit_rf
     /tmp/cc9RgtHo.s:4665   .progmem.data:000005ad cmd_help_edit_rf
     /tmp/cc9RgtHo.s:4670   .progmem.data:000005d7 cmd_read_rf
     /tmp/cc9RgtHo.s:4675   .progmem.data:000005de cmd_help_read_rf
     /tmp/cc9RgtHo.s:4680   .progmem.data:00000608 cmd_up
     /tmp/cc9RgtHo.s:4685   .progmem.data:0000060b cmd_help_up
     /tmp/cc9RgtHo.s:4690   .progmem.data:00000631 cmd_down
     /tmp/cc9RgtHo.s:4695   .progmem.data:00000636 cmd_help_down
     /tmp/cc9RgtHo.s:4700   .progmem.data:0000065e cmd_spa
     /tmp/cc9RgtHo.s:4705   .progmem.data:00000662 cmd_help_spa
     /tmp/cc9RgtHo.s:4710   .progmem.data:00000675 cmd_spb
     /tmp/cc9RgtHo.s:4715   .progmem.data:00000679 cmd_help_spb
     /tmp/cc9RgtHo.s:4720   .progmem.data:0000068c cmd_settime
     /tmp/cc9RgtHo.s:4725   .progmem.data:00000694 cmd_help_settime
     /tmp/cc9RgtHo.s:4730   .progmem.data:000006b6 cmd_ac
     /tmp/cc9RgtHo.s:4735   .progmem.data:000006b9 cmd_help_ac
     /tmp/cc9RgtHo.s:4740   .progmem.data:000006d9 cmd_enable
     /tmp/cc9RgtHo.s:4745   .progmem.data:000006e0 cmd_help_enable
     /tmp/cc9RgtHo.s:4750   .progmem.data:000006ec cmd_disable
     /tmp/cc9RgtHo.s:4755   .progmem.data:000006f4 cmd_help_disable
     /tmp/cc9RgtHo.s:4760   .progmem.data:000006fe cmd_configure
     /tmp/cc9RgtHo.s:4765   .progmem.data:00000705 cmd_help_configure
     /tmp/cc9RgtHo.s:4770   .progmem.data:00000714 cmd_conf_ip
     /tmp/cc9RgtHo.s:4775   .progmem.data:00000717 cmd_help_conf_ip
     /tmp/cc9RgtHo.s:4780   .progmem.data:0000073a cmd_conf_udp
     /tmp/cc9RgtHo.s:4785   .progmem.data:0000073e cmd_help_conf_udp
     /tmp/cc9RgtHo.s:4791   .progmem.data:0000078c cmd_conf_ip_mask
     /tmp/cc9RgtHo.s:4796   .progmem.data:00000791 cmd_conf_ip_mask_help
     /tmp/cc9RgtHo.s:4801   .progmem.data:000007a1 cmd_conf_ip_gw
     /tmp/cc9RgtHo.s:4806   .progmem.data:000007a4 cmd_conf_ip_gw_help
     /tmp/cc9RgtHo.s:4811   .progmem.data:000007cc cmd_conf_mac
     /tmp/cc9RgtHo.s:4816   .progmem.data:000007d0 cmd_help_conf_mac
     /tmp/cc9RgtHo.s:4821   .progmem.data:000007fe cmd_conf_save
     /tmp/cc9RgtHo.s:4826   .progmem.data:00000803 cmd_help_conf_save
     /tmp/cc9RgtHo.s:4831   .progmem.data:00000816 cmd_ustawR
     /tmp/cc9RgtHo.s:4836   .progmem.data:0000081b cmd_help_ustawR
     /tmp/cc9RgtHo.s:4841   .progmem.data:00000838 okStr
     /tmp/cc9RgtHo.s:4851   .progmem.data:00000840 BladBuforaPozostaloBajtowStr
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000005 Ipv6MyConfig
                            *COM*:00000002 debugStream

UNDEFINED SYMBOLS
saveConfiguration
cmdlineGetArgHex
nicSetMacAddress
cmdlineGetArgInt
htons
ipSetConfigGw
ipSetConfigMask
ipSetConfigIp
MCP3008_getSampleSingle
fprintf_P
ds1305start
__udivmodqi4
setTimeDecoded
MCP4150_setValue
MPC23s17SetDirB
MPC23s17SetPortB
MPC23s17SetDirA
MPC23s17SetPortA
rs485curtainDown
rs485curtainUp
cmdlineGetArgStr
ramDyskOtworzPlik
ramDyskUstawWskaznikNaKoniec
xVtyRec
xQueueGenericReceive
uartVtySendByte
ramDyskZapiszBajtDoPliku
ramDyskZamknijPlik
ramDyskUsunPlik
ramDyskUtworzPlik
rs485ping
rs485xModemFlash
fputc
ramDyskDodajBlokXmodem
strncmp_P
setArpDebug
setIpDebug
setIcmpDebug
setTcpDebug
setUdpDebug
nicRegDump
ramDyskCzytajBajtZPliku
ramDyskDir
readTimeDecoded
cmdPrintHelp
uxTaskGetNumberOfTasks
xPortGetFreeHeapSize
xmallocAvailable
temperature
voltage
ramDyskLiczbaWolnychKlastrow
netPrintEthAddr
ipGetConfig
netPrintIPAddr
printRs485devices
printLockers
udpPrintStatus
ramDyskOtworzPlikStdIo
ramDyskZamknijPlikStdIo
cmdStateConfigure
__do_clear_bss
