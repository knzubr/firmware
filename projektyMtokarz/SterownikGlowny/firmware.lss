
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000b69a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000054a  00802000  0000b69a  0000b74e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000dfa  0080254a  0080254a  0000bc98  2**0
                  ALLOC
  3 .eeprom       00000032  00810000  00810000  0000bc98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00019a40  00000000  00000000  0000bccc  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00014c7e  00000000  00000000  0002570c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2c 08 	jmp	0x1058	; 0x1058 <__ctors_end>
       4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
       8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
       c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      10:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      14:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      18:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      1c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      20:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      24:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      28:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      2c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      30:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      34:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      38:	0c 94 1c 54 	jmp	0xa838	; 0xa838 <__vector_14>
      3c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      40:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      44:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      48:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      4c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      50:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      54:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      58:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      5c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      60:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      64:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      68:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      6c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      70:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      74:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      78:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      7c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      80:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      84:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      88:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      8c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      90:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      94:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      98:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      9c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      ac:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      bc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      cc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      dc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      ec:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      fc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     100:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     104:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     108:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     10c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     110:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     114:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     118:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     11c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     120:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     124:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     128:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     12c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     130:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     134:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     138:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     13c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     140:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     144:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     148:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     14c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     150:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     154:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     158:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     15c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     160:	0c 94 7b 0a 	jmp	0x14f6	; 0x14f6 <__vector_88>
     164:	0c 94 eb 0a 	jmp	0x15d6	; 0x15d6 <__vector_89>
     168:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     16c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     170:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     174:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     178:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     17c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     180:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     184:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     188:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     18c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     190:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     194:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     198:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     19c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1ac:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1bc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1cc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1dc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1e0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1e4:	0c 94 17 0a 	jmp	0x142e	; 0x142e <__vector_121>
     1e8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1ec:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1f0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>

000001f4 <statusLockerSensDescStr>:
     1f4:	20 6c 6f 63 6b 65 72 20 25 64 00                     locker %d.

000001ff <statusLockerOpenStr>:
     1ff:	20 6f 70 65 6e 20 20 20 00                           open   .

00000208 <statusLockerCloseStr>:
     208:	20 6c 6f 63 6b 65 64 20 00                           locked .

00000211 <statusLockerSensAdditionalDescStr>:
     211:	20 28 74 68 72 65 73 68 6f 6c 64 20 25 64 2c 20      (threshold %d, 
     221:	41 43 20 76 61 6c 75 65 20 25 64 29 0d 0a 00        AC value %d)...

00000230 <errorOK>:
     230:	41 6c 6c 20 4f 4b 0d 0a 00                          All OK...

00000239 <errorNoFile>:
     239:	4e 6f 20 46 69 6c 65 0d 0a 00                       No File...

00000243 <errorxModemFrameStartTimeout>:
     243:	0d 0a 00                                            ...

00000246 <errorxModemByteSendTimeout>:
     246:	0d 0a 00                                            ...

00000249 <errorxModemWrongFrameNo>:
     249:	0d 0a 00                                            ...

0000024c <errorxModemFrameFrameNoCorrectionNotMatch>:
     24c:	0d 0a 00                                            ...

0000024f <errorxModemFrameCrc>:
     24f:	78 4d 6f 64 65 6d 20 43 52 43 20 65 72 72 6f 72     xModem CRC error
     25f:	0d 0a 00                                            ...

00000262 <errorxModemRemoteSideCan>:
     262:	52 65 6d 6f 74 65 20 73 69 64 65 20 63 61 6e 63     Remote side canc
     272:	65 6c 6c 65 64 20 61 74 20 66 72 61 6d 65 20 6e     elled at frame n
     282:	6f 20 25 64 0d 0a 00                                o %d...

00000289 <errorxModemUnknownResponse>:
     289:	78 4d 6f 64 65 6d 20 75 6e 6b 6e 6f 77 6e 20 72     xModem unknown r
     299:	65 73 70 6f 6e 73 65 20 30 78 25 78 0d 0a 00        esponse 0x%x...

000002a8 <errorNoRemoteDevice>:
     2a8:	44 65 76 69 63 65 20 25 64 20 69 73 20 6e 6f 74     Device %d is not
     2b8:	20 72 65 73 70 6f 6e 64 69 6e 67 20 28 25 64 29      responding (%d)
     2c8:	0d 0a 00                                            ...

000002cb <errorBootloaderNotResponding>:
     2cb:	42 6f 6f 74 6c 6f 61 64 65 72 20 69 73 20 6e 6f     Bootloader is no
     2db:	74 20 72 65 73 70 6f 6e 64 69 6e 67 0d 0a 00        t responding...

000002ea <errorOpenFile>:
     2ea:	43 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 20     Can't open file 
     2fa:	25 73 0d 0a 00                                      %s...

000002ff <systemStateStr>:
     2ff:	53 79 73 74 65 6d 20 73 74 61 74 65 3a 0d 0a 00     System state:...

0000030f <statusNumberOfTasksStr>:
     30f:	20 20 4e 75 6d 62 65 72 20 6f 66 20 74 61 73 6b       Number of task
     31f:	73 20 3a 20 25 64 0d 0a 00                          s : %d...

00000328 <statusStaticHeapStateStr>:
     328:	20 20 46 72 65 65 52 74 6f 73 20 68 65 61 70 20       FreeRtos heap 
     338:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     348:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000352 <statusDynamicHeapStateStr>:
     352:	20 20 4d 61 6c 6c 6f 63 20 68 65 61 70 20 20 20       Malloc heap   
     362:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     372:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

0000037c <statusRamDiskStateStr>:
     37c:	20 20 52 61 6d 20 64 69 73 63 20 73 70 61 63 65       Ram disc space
     38c:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     39c:	64 20 63 6c 75 73 74 65 72 73 0d 0a 00              d clusters...

000003a9 <statusTemperatureStr>:
     3a9:	20 20 54 65 6d 70 65 72 61 74 75 72 65 20 20 20       Temperature   
     3b9:	20 20 3a 20 25 64 20 43 0d 0a 00                      : %d C...

000003c4 <statusVoltageStr>:
     3c4:	20 20 56 6f 6c 74 61 67 65 20 20 20 20 20 20 20       Voltage       
     3d4:	20 20 3a 20 25 64 20 56 0d 0a 00                      : %d V...

000003df <systemRamConfigStr>:
     3df:	53 79 73 74 65 6d 20 73 65 74 74 69 6e 67 73 3a     System settings:
     3ef:	0d 0a 00                                            ...

000003f2 <statusMacStr>:
     3f2:	20 20 4d 61 63 20 61 64 64 72 65 73 73 20 20 20       Mac address   
     402:	20 20 3a 20 00                                        : .

00000407 <statusIpStr>:
     407:	20 20 49 50 20 61 64 64 72 65 73 73 20 20 20 20       IP address    
     417:	20 20 3a 20 00                                        : .

0000041c <statusIpMaskStr>:
     41c:	20 20 6d 61 73 6b 20 20 20 20 20 20 20 20 20 20       mask          
     42c:	20 20 3a 20 00                                        : .

00000431 <statusIpGwStr>:
     431:	20 20 67 61 74 65 77 61 79 20 20 20 20 20 20 20       gateway       
     441:	20 20 3a 20 00                                        : .

00000446 <statusRs485listStr>:
     446:	44 65 74 65 63 74 65 64 20 52 53 20 34 38 35 20     Detected RS 485 
     456:	64 65 76 69 63 65 73 3a 0d 0a 00                    devices:...

00000461 <statusNoRs485Dev>:
     461:	20 20 43 61 6e 27 74 20 66 69 6e 64 20 61 6e 79       Can't find any
     471:	20 64 65 76 69 63 65 0d 0a 00                        device...

0000047b <statusLockerSensorsStr>:
     47b:	4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73 20 73     Locker sensors s
     48b:	74 61 74 65 73 3a 0d 0a 00                          tates:...

00000494 <statusLockerSensorsDisStr>:
     494:	20 20 4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73       Locker sensors
     4a4:	20 64 69 73 61 62 6c 65 64 0d 0a 00                  disabled...

000004b0 <editRamFileIntroStr>:
     4b0:	57 72 69 74 69 6e 67 20 74 6f 20 66 69 6c 65 2e     Writing to file.
     4c0:	20 50 72 65 73 73 20 43 54 52 4c 2b 43 20 74 6f      Press CTRL+C to
     4d0:	20 71 75 69 74 0d 0a 00                              quit...

000004d8 <readRamFIleLenStr>:
     4d8:	46 69 6c 65 20 6c 65 6e 67 74 68 3a 20 25 64 0d     File length: %d.
     4e8:	0a 00                                               ..

000004ea <xwyslijStartStr>:
     4ea:	58 6d 6f 64 65 6d 3a 20 54 72 61 6e 73 6d 69 73     Xmodem: Transmis
     4fa:	73 69 6f 6e 20 73 74 61 72 74 0d 0a 00              sion start...

00000507 <movingCurtainUpStr>:
     507:	50 6f 64 6e 6f 73 7a 65 6e 69 65 20 72 6f 6c 65     Podnoszenie role
     517:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     527:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     537:	0d 0a 00                                            ...

0000053a <movingCurtainDownStr>:
     53a:	4f 70 75 73 7a 63 7a 61 6e 69 65 20 72 6f 6c 65     Opuszczanie role
     54a:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     55a:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     56a:	0d 0a 00                                            ...

0000056d <movingCurtainPosStr>:
     56d:	09 70 6f 7a 79 63 6a 61 20 20 20 25 64 0d 0a 00     .pozycja   %d...

0000057d <debugEnabledInfoStr>:
     57d:	45 6e 61 62 6c 65 64 20 25 73 20 64 65 62 75 67     Enabled %s debug
     58d:	0d 0a 00                                            ...

00000590 <debugDisabledInfoStr>:
     590:	44 69 73 61 62 6c 65 64 20 25 73 20 64 65 62 75     Disabled %s debu
     5a0:	67 0d 0a 00                                         g...

000005a4 <cmd_help>:
     5a4:	68 65 6c 70 00                                      help.

000005a9 <cmd_status>:
     5a9:	73 74 61 74 75 73 00                                status.

000005b0 <cmd_enc_stat>:
     5b0:	65 6e 63 73 74 61 74 00                             encstat.

000005b8 <cmd_time>:
     5b8:	74 69 6d 65 00                                      time.

000005bd <cmd_net_dbg>:
     5bd:	64 65 62 75 67 00                                   debug.

000005c3 <cmd_rping>:
     5c3:	72 70 69 6e 67 00                                   rping.

000005c9 <cmd_ping>:
     5c9:	70 69 6e 67 00                                      ping.

000005ce <cmd_xRec>:
     5ce:	78 72 65 63 00                                      xrec.

000005d3 <cmd_xSend>:
     5d3:	78 73 65 6e 64 00                                   xsend.

000005d9 <cmd_xflash>:
     5d9:	78 66 6c 61 73 68 00                                xflash.

000005e0 <cmd_dir_rf>:
     5e0:	64 69 72 72 66 00                                   dirrf.

000005e6 <cmd_create_rf>:
     5e6:	63 72 66 00                                         crf.

000005ea <cmd_erase_rf>:
     5ea:	65 72 61 73 65 72 66 00                             eraserf.

000005f2 <cmd_edit_rf>:
     5f2:	65 64 69 74 72 66 00                                editrf.

000005f9 <cmd_read_rf>:
     5f9:	72 65 61 64 72 66 00                                readrf.

00000600 <cmd_up>:
     600:	75 70 00                                            up.

00000603 <cmd_down>:
     603:	64 6f 77 6e 00                                      down.

00000608 <cmd_spa>:
     608:	73 70 61 00                                         spa.

0000060c <cmd_spb>:
     60c:	73 70 62 00                                         spb.

00000610 <cmd_settime>:
     610:	73 65 74 74 69 6d 65 00                             settime.

00000618 <cmd_ac>:
     618:	61 63 00                                            ac.

0000061b <cmd_enable>:
     61b:	65 6e 61 62 6c 65 00                                enable.

00000622 <cmd_disable>:
     622:	64 69 73 61 62 6c 65 00                             disable.

0000062a <cmd_configure>:
     62a:	63 6f 6e 66 69 67 00                                config.

00000631 <cmd_conf_ip>:
     631:	69 70 00                                            ip.

00000634 <cmd_conf_udp>:
     634:	75 64 70 00                                         udp.

00000638 <cmd_conf_ip_mask>:
     638:	6d 61 73 6b 00                                      mask.

0000063d <cmd_conf_ip_gw>:
     63d:	67 77 00                                            gw.

00000640 <cmd_conf_mac>:
     640:	6d 61 63 00                                         mac.

00000644 <cmd_conf_save>:
     644:	73 61 76 65 00                                      save.

00000649 <cmd_ustawR>:
     649:	73 65 74 72 00                                      setr.

0000064e <okStr>:
     64e:	4f 4b 0d 0a 00                                      OK...

00000653 <nlStr>:
     653:	0d 0a 00                                            ...

00000656 <BladBuforaPozostaloBajtowStr>:
     656:	21 21 21 20 57 20 62 75 64 6f 72 7a 65 20 52 73     !!! W budorze Rs
     666:	34 38 35 20 70 6f 7a 6f 73 74 61 6c 6f 20 25 64     485 pozostalo %d
     676:	20 62 61 6a 74 6f 77 0d 0a 00                        bajtow...

00000680 <errorStrings>:
     680:	30 02 39 02 43 02 46 02 49 02 4c 02 4f 02 62 02     0.9.C.F.I.L.O.b.
     690:	89 02 a8 02 cb 02 ea 02                             ........

00000698 <cmdListNormal>:
     698:	a4 05 03 20 96 16 a9 05 15 20 69 19 b8 05 66 20     ... ..... i...f 
     6a8:	3f 16 c3 05 ba 20 71 17 c9 05 e0 20 a3 0e e0 05     ?.... q.... ....
     6b8:	92 21 37 16 f9 05 11 22 9e 15 1b 06 f1 22 39 0e     .!7...."....."9.
     6c8:	00 00 00 00 00 00                                   ......

000006ce <cmdListConfigure>:
     6ce:	a4 05 03 20 96 16 a9 05 15 20 69 19 b8 05 66 20     ... ..... i...f 
     6de:	3f 16 10 06 af 22 59 10 31 06 16 23 c3 0f 38 06     ?...."Y.1..#..8.
     6ee:	87 23 a4 0f 3d 06 97 23 4a 0f 34 06 39 23 c2 0e     .#..=..#J.4.9#..
     6fe:	40 06 bf 23 6c 0e 44 06 ed 23 67 0e 1b 06 f1 22     @..#l.D..#g...."
     70e:	39 0e 22 06 fd 22 4a 0e 00 00 00 00 00 00           9.".."J.......

0000071c <__c.5194>:
     71c:	57 61 72 74 6f 73 63 20 70 72 6f 62 6b 69 20 6e     Wartosc probki n
     72c:	61 20 77 65 6a 73 63 69 75 20 25 64 3a 20 25 64     a wejsciu %d: %d
     73c:	0d 0a 00                                            ...

0000073f <__c.5245>:
     73f:	58 6d 6f 64 65 6d 3a 20 72 6f 7a 70 6f 63 7a 79     Xmodem: rozpoczy
     74f:	6e 61 6e 69 65 20 6f 64 62 69 6f 72 75 0d 0a 00     nanie odbioru...

0000075f <__c.5159>:
     75f:	75 64 70 00                                         udp.

00000763 <__c.5157>:
     763:	74 63 70 00                                         tcp.

00000767 <__c.5155>:
     767:	69 63 6d 70 00                                      icmp.

0000076c <__c.5153>:
     76c:	69 70 00                                            ip.

0000076f <__c.5151>:
     76f:	61 72 70 00                                         arp.

00000773 <__c.5149>:
     773:	75 64 70 00                                         udp.

00000777 <__c.5147>:
     777:	74 63 70 00                                         tcp.

0000077b <__c.5145>:
     77b:	69 63 6d 70 00                                      icmp.

00000780 <__c.5143>:
     780:	69 70 00                                            ip.

00000783 <__c.5141>:
     783:	61 72 70 00                                         arp.

00000787 <__c.5134>:
     787:	41 6b 74 75 61 6c 6e 79 20 63 7a 61 73 20 25 64     Aktualny czas %d
     797:	3a 25 64 3a 25 64 0d 0a 00                          :%d:%d...

000007a0 <__c.5119>:
     7a0:	0d 0a 00                                            ...

000007a3 <__c.5117>:
     7a3:	0d 0a 00                                            ...

000007a6 <__c.5115>:
     7a6:	0d 0a 00                                            ...

000007a9 <__c.5113>:
     7a9:	0d 0a 00                                            ...

000007ac <__c.5110>:
     7ac:	46 72 65 65 52 74 6f 73 2b 20 76 65 72 20 30 2e     FreeRtos+ ver 0.
     7bc:	33 31 20 62 75 69 6c 64 3a 20 41 70 72 20 20 33     31 build: Apr  3
     7cc:	20 32 30 31 33 2c 20 32 32 3a 30 37 3a 33 38 0d      2013, 22:07:38.
     7dc:	0a 00                                               ..

000007de <__c.4920>:
     7de:	55 6e 6b 6e 6f 77 6e 20 70 61 63 6b 65 74 0d 0a     Unknown packet..
	...

000007ef <__c.3619>:
     7ef:	52 65 73 74 61 72 74 0d 0a 00                       Restart...

000007f9 <CmdlinePromptNormal>:
     7f9:	44 6f 6d 4f 73 3e 00                                DomOs>.

00000800 <CmdlinePromptEnable>:
     800:	44 6f 6d 4f 73 23 00                                DomOs#.

00000807 <CmdlinePromptConfigure>:
     807:	44 6f 6d 4f 73 40 00                                DomOs@.

0000080e <CmdlineNotice>:
     80e:	63 6d 64 6c 69 6e 65 3a 20 00                       cmdline: .

00000818 <CmdlineCmdNotFound>:
     818:	23 20 6e 6b 00                                      # nk.

0000081d <__c.5147>:
     81d:	0d 0a 00                                            ...

00000820 <__c.5145>:
     820:	09 00                                               ..

00000822 <__c.5057>:
     822:	4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 61 6c     Operation not al
     832:	6c 6f 77 65 64 0d 0a 00                             lowed...

0000083a <__c.5054>:
     83a:	4f 70 65 72 61 74 69 6f 6e 20 66 61 69 6c 65 64     Operation failed
     84a:	0d 0a 00                                            ...

0000084d <__c.5051>:
     84d:	0d 0a 00                                            ...

00000850 <__c.5049>:
     850:	20 00                                                .

00000852 <__c.5047>:
     852:	53 79 6e 74 61 78 20 45 72 72 6f 72 2e 20 55 73     Syntax Error. Us
     862:	65 3a 20 00                                         e: .

00000866 <__c.5043>:
     866:	4f 4b 0d 0a 00                                      OK...

0000086b <__c.5051>:
     86b:	09 4d 41 41 44 52 35 20 30 78 25 78 0d 0a 00        .MAADR5 0x%x...

0000087a <__c.5049>:
     87a:	09 4d 41 41 44 52 34 20 30 78 25 78 0d 0a 00        .MAADR4 0x%x...

00000889 <__c.5047>:
     889:	09 4d 41 41 44 52 33 20 30 78 25 78 0d 0a 00        .MAADR3 0x%x...

00000898 <__c.5045>:
     898:	09 4d 41 41 44 52 32 20 30 78 25 78 0d 0a 00        .MAADR2 0x%x...

000008a7 <__c.5043>:
     8a7:	09 4d 41 41 44 52 31 20 30 78 25 78 0d 0a 00        .MAADR1 0x%x...

000008b6 <__c.5041>:
     8b6:	09 4d 41 41 44 52 30 20 30 78 25 78 0d 0a 00        .MAADR0 0x%x...

000008c5 <__c.5039>:
     8c5:	45 4e 43 32 38 6a 36 30 20 73 74 61 6e 20 72 65     ENC28j60 stan re
     8d5:	6a 65 73 74 72 6f 77 3a 0d 0a 00                    jestrow:...

000008e0 <__c.3740>:
     8e0:	4e 49 43 20 72 65 67 20 64 75 6d 70 20 6e 6f 74     NIC reg dump not
     8f0:	20 69 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00         implemented...

000008ff <__c.3601>:
     8ff:	0d 0a 00                                            ...

00000902 <__c.3599>:
     902:	55 52 47 20 00                                      URG .

00000907 <__c.3597>:
     907:	41 43 4b 20 00                                      ACK .

0000090c <__c.3595>:
     90c:	50 53 48 20 00                                      PSH .

00000911 <__c.3593>:
     911:	52 53 54 20 00                                      RST .

00000916 <__c.3591>:
     916:	53 59 4e 20 00                                      SYN .

0000091b <__c.3589>:
     91b:	46 49 4e 20 00                                      FIN .

00000920 <__c.3587>:
     920:	46 6c 61 67 73 20 20 20 3a 20 00                    Flags   : .

0000092b <__c.3585>:
     92b:	41 63 6b 20 4e 75 6d 20 3a 20 30 78 25 78 0d 0a     Ack Num : 0x%x..
	...

0000093c <__c.3583>:
     93c:	53 65 71 20 4e 75 6d 20 3a 20 30 78 25 78 00        Seq Num : 0x%x.

0000094b <__c.3581>:
     94b:	44 73 74 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Dst Port: %d...

0000095a <__c.3579>:
     95a:	53 72 63 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Src Port: %d...

00000969 <__c.3577>:
     969:	54 43 50 20 48 65 61 64 65 72 0d 0a 00              TCP Header...

00000976 <__c.3571>:
     976:	0d 0a 00                                            ...

00000979 <__c.3569>:
     979:	44 65 73 74 20 20 49 50 3a 20 00                    Dest  IP: .

00000984 <__c.3567>:
     984:	0d 0a 00                                            ...

00000987 <__c.3565>:
     987:	53 6f 75 72 63 65 49 50 3a 20 00                    SourceIP: .

00000992 <__c.3563>:
     992:	50 72 6f 74 6f 63 6f 6c 3a 20 25 64 0d 0a 00        Protocol: %d...

000009a1 <__c.3561>:
     9a1:	50 72 6f 74 6f 63 6f 6c 3a 20 55 44 50 0d 0a 00     Protocol: UDP...

000009b1 <__c.3559>:
     9b1:	50 72 6f 74 6f 63 6f 6c 3a 20 54 43 50 0d 0a 00     Protocol: TCP...

000009c1 <__c.3557>:
     9c1:	50 72 6f 74 6f 63 6f 6c 3a 20 49 43 4d 50 0d 0a     Protocol: ICMP..
	...

000009d2 <__c.3555>:
     9d2:	4c 65 6e 67 74 68 20 20 3a 20 25 64 0d 0a 00        Length  : %d...

000009e1 <__c.3553>:
     9e1:	56 65 72 20 20 20 20 20 3a 20 25 64 0d 0a 00        Ver     : %d...

000009f0 <__c.3551>:
     9f0:	49 50 20 48 65 61 64 65 72 0d 0a 00                 IP Header...

000009fc <__c.3545>:
     9fc:	2d 3e 44 53 54 3a 00                                ->DST:.

00000a03 <__c.3543>:
     a03:	20 53 52 43 3a 00                                    SRC:.

00000a09 <__c.3541>:
     a09:	45 74 68 20 50 61 63 6b 65 74 20 54 79 70 65 3a     Eth Packet Type:
     a19:	20 30 78 25 78 00                                    0x%x.

00000a1f <__c.3535>:
     a1f:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

00000a2b <__c.3529>:
     a2b:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
     a3b:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

00000a49 <__c.4280>:
     a49:	0d 0a 00                                            ...

00000a4c <__c.4278>:
     a4c:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00000a57 <__c.4276>:
     a57:	0d 0a 00                                            ...

00000a5a <__c.4274>:
     a5a:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00000a65 <__c.4272>:
     a65:	0d 0a 00                                            ...

00000a68 <__c.4270>:
     a68:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00000a73 <__c.4264>:
     a73:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     a83:	6c 65 28 6c 65 6e 2d 45 54 48 5f 48 45 41 44 45     le(len-ETH_HEADE
     a93:	52 5f 4c 45 4e 2c 20 26 64 61 74 61 5b 45 54 48     R_LEN, &data[ETH
     aa3:	5f 48 45 41 44 45 52 5f 4c 45 4e 5d 29 3b 00        _HEADER_LEN]);.

00000ab2 <__c.4262>:
     ab2:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     ac2:	6c 65 28 45 54 48 5f 48 45 41 44 45 52 5f 4c 45     le(ETH_HEADER_LE
     ad2:	4e 2c 20 26 64 61 74 61 5b 30 5d 29 3b 00           N, &data[0]);.

00000ae0 <__c.4260>:
     ae0:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     af0:	74 20 74 6f 20 67 61 74 65 77 61 79 0d 0a 00        t to gateway...

00000aff <__c.4258>:
     aff:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     b0f:	74 20 6f 6e 20 6c 6f 63 61 6c 20 6e 65 74 0d 0a     t on local net..
	...

00000b20 <__c.4230>:
     b20:	4e 45 54 20 52 78 3a 20 55 6e 6b 6e 6f 77 6e 20     NET Rx: Unknown 
     b30:	49 50 20 70 61 63 6b 65 74 0d 0a 00                 IP packet...

00000b3c <__c.4228>:
     b3c:	4e 45 54 20 52 78 3a 20 54 43 50 2f 49 50 20 70     NET Rx: TCP/IP p
     b4c:	61 63 6b 65 74 0d 0a 00                             acket...

00000b54 <__c.4226>:
     b54:	4e 45 54 20 52 78 3a 20 55 44 50 2f 49 50 20 70     NET Rx: UDP/IP p
     b64:	61 63 6b 65 74 0d 0a 00                             acket...

00000b6c <__c.4224>:
     b6c:	4e 45 54 20 52 78 3a 20 49 43 4d 50 2f 49 50 20     NET Rx: ICMP/IP 
     b7c:	70 61 63 6b 65 74 0d 0a 00                          packet...

00000b85 <__c.4262>:
     b85:	43 6f 64 65 20 20 20 3a 20 30 78 25 78 0d 0a 00     Code   : 0x%x...

00000b95 <__c.4260>:
     b95:	0d 0a 00                                            ...

00000b98 <__c.4257>:
     b98:	45 43 48 4f 20 52 45 50 4c 59 00                    ECHO REPLY.

00000ba3 <__c.4253>:
     ba3:	45 43 48 4f 20 52 45 51 55 45 53 54 00              ECHO REQUEST.

00000bb0 <__c.4250>:
     bb0:	54 79 70 65 20 20 20 3a 20 00                       Type   : .

00000bba <__c.4248>:
     bba:	0d 0a 00                                            ...

00000bbd <__c.4246>:
     bbd:	44 73 74 49 70 41 64 64 72 3a 20 00                 DstIpAddr: .

00000bc9 <__c.4244>:
     bc9:	0d 0a 00                                            ...

00000bcc <__c.4242>:
     bcc:	53 72 63 49 70 41 64 64 72 3a 20 00                 SrcIpAddr: .

00000bd8 <__c.4240>:
     bd8:	49 43 4d 50 20 50 61 63 6b 65 74 3a 0d 0a 00        ICMP Packet:...

00000be7 <__c.4229>:
     be7:	53 65 6e 64 69 6e 67 20 49 43 4d 50 20 50 4f 4e     Sending ICMP PON
     bf7:	47 0d 0a 00                                         G...

00000bfb <__c.4226>:
     bfb:	52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72 65     Received ICMP re
     c0b:	71 75 65 73 74 3a 20 00                             quest: .

00000c13 <__c.4221>:
     c13:	55 6e 6b 6e 6f 77 6e 20 49 43 4d 50 20 74 79 70     Unknown ICMP typ
     c23:	65 52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72     eReceived ICMP r
     c33:	65 71 75 65 73 74 3a 20 00                          equest: .

00000c3c <__c.4312>:
     c3c:	0d 0a 00                                            ...

00000c3f <__c.4310>:
     c3f:	20 20 00                                              .

00000c42 <__c.4308>:
     c42:	25 33 64 20 20 00                                   %3d  .

00000c48 <__c.4305>:
     c48:	0d 0a 00                                            ...

00000c4b <__c.4303>:
     c4b:	20 20 00                                              .

00000c4e <__c.4301>:
     c4e:	20 4d 59 20 20 00                                    MY  .

00000c54 <__c.4299>:
     c54:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     c64:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     c74:	2d 2d 2d 0d 0a 00                                   ---...

00000c7a <__c.4297>:
     c7a:	54 69 6d 65 20 45 74 68 20 41 64 64 72 65 73 73     Time Eth Address
     c8a:	20 20 20 20 20 20 20 20 49 50 20 41 64 64 72 65             IP Addre
     c9a:	73 73 0d 0a 00                                      ss...

00000c9f <__c.4291>:
     c9f:	0d 0a 00                                            ...

00000ca2 <__c.4289>:
     ca2:	44 73 74 50 72 6f 74 6f 41 64 64 72 3a 20 00        DstProtoAddr: .

00000cb1 <__c.4287>:
     cb1:	0d 0a 00                                            ...

00000cb4 <__c.4285>:
     cb4:	44 73 74 48 77 41 64 64 72 20 20 20 3a 20 00        DstHwAddr   : .

00000cc3 <__c.4283>:
     cc3:	0d 0a 00                                            ...

00000cc6 <__c.4281>:
     cc6:	53 72 63 50 72 6f 74 6f 41 64 64 72 3a 20 00        SrcProtoAddr: .

00000cd5 <__c.4279>:
     cd5:	0d 0a 00                                            ...

00000cd8 <__c.4277>:
     cd8:	53 72 63 48 77 41 64 64 72 20 20 20 3a 20 00        SrcHwAddr   : .

00000ce7 <__c.4275>:
     ce7:	0d 0a 00                                            ...

00000cea <__c.4273>:
     cea:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

00000cf2 <__c.4271>:
     cf2:	52 45 50 4c 59 00                                   REPLY.

00000cf8 <__c.4269>:
     cf8:	52 45 51 55 45 53 54 00                             REQUEST.

00000d00 <__c.4267>:
     d00:	4f 70 65 72 61 74 69 6f 6e 20 20 20 3a 20 00        Operation   : .

00000d0f <__c.4265>:
     d0f:	41 52 50 20 50 61 63 6b 65 74 3a 0d 0a 00           ARP Packet:...

00000d1d <__c.4237>:
     d1d:	0d 0a 00                                            ...

00000d20 <__c.4235>:
     d20:	20 49 50 3a 20 00                                    IP: .

00000d26 <__c.4233>:
     d26:	41 52 50 20 49 50 20 69 6e 20 4d 41 43 3a 20 00     ARP IP in MAC: .

00000d36 <__c.4228>:
     d36:	53 65 6e 64 69 6e 67 20 41 52 50 20 52 65 70 6c     Sending ARP Repl
     d46:	79 0d 0a 00                                         y...

00000d4a <__c.4226>:
     d4a:	52 65 63 65 69 76 65 64 20 41 52 50 20 52 65 71     Received ARP Req
     d5a:	75 65 73 74 0d 0a 00                                uest...

00000d61 <__c.4269>:
     d61:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
     d71:	6e 74 65 64 0d 0a 00                                nted...

00000d78 <__c.4255>:
     d78:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     d88:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
     d98:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
     da8:	74 0d 0a 00                                         t...

00000dac <__c.4253>:
     dac:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     dbc:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
     dcc:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
     ddc:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
     dec:	49 53 48 45 44 0d 0a 00                             ISHED...

00000df4 <__c.4251>:
     df4:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     e04:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
     e14:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
     e24:	74 0d 0a 00                                         t...

00000e28 <__c.4249>:
     e28:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     e38:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
     e48:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
     e58:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
     e68:	0a 00                                               ..

00000e6a <__c.4240>:
     e6a:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
     e7a:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
     e8a:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

00000e94 <__c.4235>:
     e94:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
     ea4:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
     eb4:	54 45 4e 0d 0a 00                                   TEN...

00000eba <__c.4230>:
     eba:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
     eca:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

00000ed6 <__c.4268>:
     ed6:	25 64 0d 0a 00                                      %d...

00000edb <__c.4266>:
     edb:	41 4e 59 0d 0a 00                                   ANY...

00000ee1 <__c.4264>:
     ee1:	0d 0a 20 20 73 72 63 20 70 6f 72 74 20 20 20 20     ..  src port    
     ef1:	3a 20 25 64 0d 0a 20 20 64 73 74 20 70 6f 72 74     : %d..  dst port
     f01:	20 20 20 20 3a 20 00                                    : .

00000f08 <__c.4262>:
     f08:	0d 0a 20 20 49 50 20 20 20 20 20 20 20 20 20 20     ..  IP          
     f18:	3a 20 00                                            : .

00000f1b <__c.4260>:
     f1b:	55 44 50 20 63 6f 6e 66 69 67 3a 00                 UDP config:.

00000f27 <__c.4244>:
     f27:	0d 0a 00                                            ...

00000f2a <__c.4239>:
     f2a:	55 44 50 20 54 58 20 62 75 66 66 65 72 20 62 75     UDP TX buffer bu
     f3a:	73 79 0d 0a 00                                      sy...

00000f3f <__c.4237>:
     f3f:	30 78 25 32 78 0d 0a 00                             0x%2x...

00000f47 <__c.4235>:
     f47:	52 65 63 65 69 76 65 64 20 64 61 74 61 3a 20 00     Received data: .

00000f57 <__c.4232>:
     f57:	50 72 6f 63 2e 20 55 44 50 20 70 61 63 6b 65 74     Proc. UDP packet
     f67:	20 28 64 61 74 61 20 6c 65 6e 67 74 68 20 25 64      (data length %d
     f77:	29 0d 0a 00                                         )...

00000f7b <__c.4225>:
     f7b:	53 65 6e 64 69 6e 67 20 55 44 50 20 70 61 63 6b     Sending UDP pack
     f8b:	65 74 20 28 64 61 74 61 20 6c 65 6e 67 74 68 20     et (data length 
     f9b:	25 64 29 0d 0a 00                                   %d)...

00000fa1 <statusRollerDescStr>:
     fa1:	20 25 64 20 72 6f 6c 6c 65 72 20 64 72 69 76 65      %d roller drive
     fb1:	72 3a 20 72 6f 6c 6c 65 72 20 31 20 70 6f 73 69     r: roller 1 posi
     fc1:	74 69 6f 6e 20 25 64 2c 20 72 6f 6c 6c 65 72 20     tion %d, roller 
     fd1:	32 20 70 6f 73 69 74 69 6f 6e 20 25 64 00           2 position %d.

00000fdf <statusRollerDescStr2>:
     fdf:	2c 20 66 69 72 6d 77 61 72 65 20 25 73 0d 0a 00     , firmware %s...

00000fef <__c.5031>:
     fef:	62 6f 6f 74 6c 6f 61 64 65 72 20 6e 69 65 20 72     bootloader nie r
     fff:	6f 7a 70 6f 63 7a 61 6c 20 6f 64 62 69 6f 72 75     ozpoczal odbioru
    100f:	20 64 61 6e 79 63 68 0d 0a 00                        danych...

00001019 <__c.5029>:
    1019:	6e 61 20 75 72 7a 61 64 7a 65 6e 69 75 20 77 67     na urzadzeniu wg
    1029:	72 61 6e 79 20 6a 65 73 74 20 74 79 6c 6b 6f 20     rany jest tylko 
    1039:	62 6f 6f 74 6c 6f 61 64 65 72 0d 0a 00              bootloader...

00001046 <__c.5027>:
    1046:	72 46 4c 41 53 48 20 74 69 6d 65 6f 75 74 0d 0a     rFLASH timeout..
	...

00001058 <__ctors_end>:
    1058:	11 24       	eor	r1, r1
    105a:	1f be       	out	0x3f, r1	; 63
    105c:	cf ef       	ldi	r28, 0xFF	; 255
    105e:	df e3       	ldi	r29, 0x3F	; 63
    1060:	de bf       	out	0x3e, r29	; 62
    1062:	cd bf       	out	0x3d, r28	; 61
    1064:	00 e0       	ldi	r16, 0x00	; 0
    1066:	0c bf       	out	0x3c, r16	; 60
    1068:	18 be       	out	0x38, r1	; 56
    106a:	19 be       	out	0x39, r1	; 57
    106c:	1a be       	out	0x3a, r1	; 58
    106e:	1b be       	out	0x3b, r1	; 59

00001070 <__do_copy_data>:
    1070:	15 e2       	ldi	r17, 0x25	; 37
    1072:	a0 e0       	ldi	r26, 0x00	; 0
    1074:	b0 e2       	ldi	r27, 0x20	; 32
    1076:	ea e9       	ldi	r30, 0x9A	; 154
    1078:	f6 eb       	ldi	r31, 0xB6	; 182
    107a:	00 e0       	ldi	r16, 0x00	; 0
    107c:	0b bf       	out	0x3b, r16	; 59
    107e:	02 c0       	rjmp	.+4      	; 0x1084 <__do_copy_data+0x14>
    1080:	07 90       	elpm	r0, Z+
    1082:	0d 92       	st	X+, r0
    1084:	aa 34       	cpi	r26, 0x4A	; 74
    1086:	b1 07       	cpc	r27, r17
    1088:	d9 f7       	brne	.-10     	; 0x1080 <__do_copy_data+0x10>

0000108a <__do_clear_bss>:
    108a:	13 e3       	ldi	r17, 0x33	; 51
    108c:	aa e4       	ldi	r26, 0x4A	; 74
    108e:	b5 e2       	ldi	r27, 0x25	; 37
    1090:	01 c0       	rjmp	.+2      	; 0x1094 <.do_clear_bss_start>

00001092 <.do_clear_bss_loop>:
    1092:	1d 92       	st	X+, r1

00001094 <.do_clear_bss_start>:
    1094:	a4 34       	cpi	r26, 0x44	; 68
    1096:	b1 07       	cpc	r27, r17
    1098:	e1 f7       	brne	.-8      	; 0x1092 <.do_clear_bss_loop>
    109a:	0e 94 53 08 	call	0x10a6	; 0x10a6 <main>
    109e:	0c 94 4b 5b 	jmp	0xb696	; 0xb696 <_exit>

000010a2 <__bad_interrupt>:
    10a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000010a6 <main>:
FILE udpStream;

streamBuffers_t udpBuffers;

portSHORT main( void )
{
    10a6:	af 92       	push	r10
    10a8:	bf 92       	push	r11
    10aa:	cf 92       	push	r12
    10ac:	df 92       	push	r13
    10ae:	ef 92       	push	r14
    10b0:	ff 92       	push	r15
    10b2:	0f 93       	push	r16
  //ramDyskInit();              //Inicjalizacja Ram dysku
  //hardwareInit();
  //spiInit(disableAllSpiDevices);
  // MOJE
  /* konfiguracja zewnętrznego kwarcu, bez PLL, Pres ABCD=1*/
	OSC.XOSCCTRL=0b1101011;
    10b4:	8b e6       	ldi	r24, 0x6B	; 107
    10b6:	e0 e5       	ldi	r30, 0x50	; 80
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	82 83       	std	Z+2, r24	; 0x02
	OSC.CTRL=0b00001000;
    10bc:	88 e0       	ldi	r24, 0x08	; 8
    10be:	80 93 50 00 	sts	0x0050, r24
	while(!(OSC.STATUS & OSC_XOSCEN_bm));
    10c2:	80 91 51 00 	lds	r24, 0x0051
    10c6:	83 ff       	sbrs	r24, 3
    10c8:	fc cf       	rjmp	.-8      	; 0x10c2 <main+0x1c>
	CCP = CCP_IOREG_gc;
    10ca:	88 ed       	ldi	r24, 0xD8	; 216
    10cc:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL=CLK_SCLKSEL_XOSC_gc;
    10ce:	83 e0       	ldi	r24, 0x03	; 3
    10d0:	80 93 40 00 	sts	0x0040, r24
	// Koniec konfuguracji, Zew kwarc 16MHz
	PORTD.OUT=0xFF; //ok
    10d4:	e0 e6       	ldi	r30, 0x60	; 96
    10d6:	f6 e0       	ldi	r31, 0x06	; 6
    10d8:	9f ef       	ldi	r25, 0xFF	; 255
    10da:	94 83       	std	Z+4, r25	; 0x04
	PORTD.DIR=PIN3_bm;//ok
    10dc:	98 e0       	ldi	r25, 0x08	; 8
    10de:	90 93 60 06 	sts	0x0660, r25
	PORTD.DIRCLR = PIN2_bm;//ok
    10e2:	94 e0       	ldi	r25, 0x04	; 4
    10e4:	92 83       	std	Z+2, r25	; 0x02
	USARTD0.CTRLC=0b00000011;//ok
    10e6:	e0 ea       	ldi	r30, 0xA0	; 160
    10e8:	f9 e0       	ldi	r31, 0x09	; 9
    10ea:	85 83       	std	Z+5, r24	; 0x05
	USARTD0.CTRLA|=(USART_RXCINTLVL_LO_gc)|(USART_TXCINTLVL_LO_gc);
    10ec:	80 91 a3 09 	lds	r24, 0x09A3
    10f0:	84 61       	ori	r24, 0x14	; 20
    10f2:	83 83       	std	Z+3, r24	; 0x03
	USARTD0.BAUDCTRLA=0b01100111;//12;
    10f4:	87 e6       	ldi	r24, 0x67	; 103
    10f6:	86 83       	std	Z+6, r24	; 0x06
	USARTD0.BAUDCTRLB=0;//(0 << USART_BSCALE0_bp)|(12 >> 8);
    10f8:	17 82       	std	Z+7, r1	; 0x07
	USARTD0.CTRLB=0b00011000;
    10fa:	88 e1       	ldi	r24, 0x18	; 24
    10fc:	84 83       	std	Z+4, r24	; 0x04
  
  //MOJE
// VTY on serial  
  //xSerialPortInitMinimal(); 
  CLIStateSerialUsb  = xmalloc(sizeof(cmdState_t));
    10fe:	83 e2       	ldi	r24, 0x23	; 35
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xmalloc>
    1106:	80 93 fe 31 	sts	0x31FE, r24
    110a:	90 93 ff 31 	sts	0x31FF, r25
  CLIStateSerialUdp  = xmalloc(sizeof(cmdState_t));
    110e:	83 e2       	ldi	r24, 0x23	; 35
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xmalloc>
    1116:	80 93 c0 32 	sts	0x32C0, r24
    111a:	90 93 c1 32 	sts	0x32C1, r25
 // socketInit();
 // initQueueStream(&udpStream, &udpBuffers, udpSocket->Rx, udpSocket->Tx);
 // VtyInit(CLIStateSerialUdp, &udpStream);
  
//xTaskCreate(encTask,        NULL /*"ENC"    */, STACK_SIZE_ENC,       (void *)CLIStateSerialUsb->myStdInOut,  0, &xHandleEnc);
  xTaskCreate(vTaskVTYusb,    NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUsb),            1, &xHandleVTY_USB);
    111e:	20 91 fe 31 	lds	r18, 0x31FE
    1122:	30 91 ff 31 	lds	r19, 0x31FF
    1126:	8b e1       	ldi	r24, 0x1B	; 27
    1128:	9a e1       	ldi	r25, 0x1A	; 26
    112a:	60 e0       	ldi	r22, 0x00	; 0
    112c:	70 e0       	ldi	r23, 0x00	; 0
    112e:	4c eb       	ldi	r20, 0xBC	; 188
    1130:	52 e0       	ldi	r21, 0x02	; 2
    1132:	01 e0       	ldi	r16, 0x01	; 1
    1134:	fc e1       	ldi	r31, 0x1C	; 28
    1136:	ef 2e       	mov	r14, r31
    1138:	f2 e3       	ldi	r31, 0x32	; 50
    113a:	ff 2e       	mov	r15, r31
    113c:	cc 24       	eor	r12, r12
    113e:	dd 24       	eor	r13, r13
    1140:	aa 24       	eor	r10, r10
    1142:	bb 24       	eor	r11, r11
    1144:	0e 94 37 46 	call	0x8c6e	; 0x8c6e <xTaskGenericCreate>
//xTaskCreate(vTaskVTYsocket, NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUdp),            1, &xHandleVTY_UDP);
//xTaskCreate(sensorsTask,    NULL /*"Sensors"*/, STACK_SIZE_SENSORS,   NULL,                                   1, &xHandleSensors);
  xTaskCreate(vTaskUSB,NULL,100,NULL,0,&xHandleUSB);
    1148:	84 e5       	ldi	r24, 0x54	; 84
    114a:	9a e1       	ldi	r25, 0x1A	; 26
    114c:	60 e0       	ldi	r22, 0x00	; 0
    114e:	70 e0       	ldi	r23, 0x00	; 0
    1150:	44 e6       	ldi	r20, 0x64	; 100
    1152:	50 e0       	ldi	r21, 0x00	; 0
    1154:	20 e0       	ldi	r18, 0x00	; 0
    1156:	30 e0       	ldi	r19, 0x00	; 0
    1158:	00 e0       	ldi	r16, 0x00	; 0
    115a:	ea ee       	ldi	r30, 0xEA	; 234
    115c:	ee 2e       	mov	r14, r30
    115e:	e1 e3       	ldi	r30, 0x31	; 49
    1160:	fe 2e       	mov	r15, r30
    1162:	0e 94 37 46 	call	0x8c6e	; 0x8c6e <xTaskGenericCreate>
  vTaskStartScheduler();
    1166:	0e 94 a1 48 	call	0x9142	; 0x9142 <vTaskStartScheduler>
  return 0;
}
    116a:	80 e0       	ldi	r24, 0x00	; 0
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	0f 91       	pop	r16
    1170:	ff 90       	pop	r15
    1172:	ef 90       	pop	r14
    1174:	df 90       	pop	r13
    1176:	cf 90       	pop	r12
    1178:	bf 90       	pop	r11
    117a:	af 90       	pop	r10
    117c:	08 95       	ret

0000117e <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
    117e:	0e 94 3e 51 	call	0xa27c	; 0xa27c <vCoRoutineSchedule>
    1182:	fd cf       	rjmp	.-6      	; 0x117e <vApplicationIdleHook>

00001184 <vApplicationTickHook>:
}

void vApplicationTickHook( void )
{
  static uint16_t tickCntr = configTICK_RATE_HZ;
  if (--tickCntr == 0)
    1184:	80 91 00 20 	lds	r24, 0x2000
    1188:	90 91 01 20 	lds	r25, 0x2001
    118c:	01 97       	sbiw	r24, 0x01	; 1
    118e:	80 93 00 20 	sts	0x2000, r24
    1192:	90 93 01 20 	sts	0x2001, r25
    1196:	00 97       	sbiw	r24, 0x00	; 0
    1198:	41 f4       	brne	.+16     	; 0x11aa <vApplicationTickHook+0x26>
  {
    tickCntr = configTICK_RATE_HZ;
    119a:	88 ee       	ldi	r24, 0xE8	; 232
    119c:	93 e0       	ldi	r25, 0x03	; 3
    119e:	80 93 00 20 	sts	0x2000, r24
    11a2:	90 93 01 20 	sts	0x2001, r25
    arpTimer();    
    11a6:	0e 94 1e 36 	call	0x6c3c	; 0x6c3c <arpTimer>
    11aa:	08 95       	ret

000011ac <loadConfiguration>:
                                                                                       {LOCK_SENS_3_ENA, LOCK_SENS_3_THR, 0, 0},
                                                                                       {LOCK_SENS_4_ENA, LOCK_SENS_4_THR, 0, 0}};

void loadConfiguration(void)
{
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
    11ac:	80 91 00 32 	lds	r24, 0x3200
    11b0:	90 91 01 32 	lds	r25, 0x3201
    11b4:	60 e0       	ldi	r22, 0x00	; 0
    11b6:	70 e0       	ldi	r23, 0x00	; 0
    11b8:	48 e1       	ldi	r20, 0x18	; 24
    11ba:	50 e0       	ldi	r21, 0x00	; 0
    11bc:	0e 94 1b 5a 	call	0xb436	; 0xb436 <__eerd_block_x128a1>
}
    11c0:	08 95       	ret

000011c2 <saveConfiguration>:

void saveConfiguration(void)
{
  saveNic();
    11c2:	0e 94 04 2e 	call	0x5c08	; 0x5c08 <saveNic>
  ipSaveConfig();
    11c6:	0e 94 cc 31 	call	0x6398	; 0x6398 <ipSaveConfig>
  udpSaveConfig();
    11ca:	0e 94 99 3e 	call	0x7d32	; 0x7d32 <udpSaveConfig>
}
    11ce:	08 95       	ret

000011d0 <VtyGetChar>:
  fdev_set_udata(stream, NULL);
  return;
}

int VtyGetChar(FILE *stream)
{
    11d0:	df 93       	push	r29
    11d2:	cf 93       	push	r28
    11d4:	0f 92       	push	r0
    11d6:	cd b7       	in	r28, 0x3d	; 61
    11d8:	de b7       	in	r29, 0x3e	; 62
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    11da:	80 91 0d 32 	lds	r24, 0x320D
    11de:	90 91 0e 32 	lds	r25, 0x320E
    11e2:	be 01       	movw	r22, r28
    11e4:	6f 5f       	subi	r22, 0xFF	; 255
    11e6:	7f 4f       	sbci	r23, 0xFF	; 255
    11e8:	4f ef       	ldi	r20, 0xFF	; 255
    11ea:	5f ef       	ldi	r21, 0xFF	; 255
    11ec:	20 e0       	ldi	r18, 0x00	; 0
    11ee:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    11f2:	88 23       	and	r24, r24
    11f4:	19 f0       	breq	.+6      	; 0x11fc <VtyGetChar+0x2c>
    return EOF;
  return c;
    11f6:	29 81       	ldd	r18, Y+1	; 0x01
    11f8:	30 e0       	ldi	r19, 0x00	; 0
    11fa:	02 c0       	rjmp	.+4      	; 0x1200 <VtyGetChar+0x30>
int VtyGetChar(FILE *stream)
{
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    return EOF;
    11fc:	2f ef       	ldi	r18, 0xFF	; 255
    11fe:	3f ef       	ldi	r19, 0xFF	; 255
  return c;
}
    1200:	c9 01       	movw	r24, r18
    1202:	0f 90       	pop	r0
    1204:	cf 91       	pop	r28
    1206:	df 91       	pop	r29
    1208:	08 95       	ret

0000120a <initQueueStreamUSB>:
#define debug 1

/*-----------------------------------------------------------*/

void initQueueStreamUSB(FILE *stream)
{
    120a:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
    120c:	86 ee       	ldi	r24, 0xE6	; 230
    120e:	9a e0       	ldi	r25, 0x0A	; 10
    1210:	80 87       	std	Z+8, r24	; 0x08
    1212:	91 87       	std	Z+9, r25	; 0x09
    1214:	88 ee       	ldi	r24, 0xE8	; 232
    1216:	98 e0       	ldi	r25, 0x08	; 8
    1218:	82 87       	std	Z+10, r24	; 0x0a
    121a:	93 87       	std	Z+11, r25	; 0x0b
    121c:	83 e0       	ldi	r24, 0x03	; 3
    121e:	83 83       	std	Z+3, r24	; 0x03
    1220:	14 86       	std	Z+12, r1	; 0x0c
    1222:	15 86       	std	Z+13, r1	; 0x0d
  fdev_set_udata(stream, NULL);
  return;
}
    1224:	08 95       	ret

00001226 <xSerialPortInitMinimal>:
  return 0;
}

void xSerialPortInitMinimal(void)
{
  portENTER_CRITICAL();
    1226:	0f b6       	in	r0, 0x3f	; 63
    1228:	f8 94       	cli
    122a:	0f 92       	push	r0
  {
    xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    122c:	80 e4       	ldi	r24, 0x40	; 64
    122e:	61 e0       	ldi	r22, 0x01	; 1
    1230:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    1234:	80 93 0d 32 	sts	0x320D, r24
    1238:	90 93 0e 32 	sts	0x320E, r25
    xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    123c:	80 e2       	ldi	r24, 0x20	; 32
    123e:	61 e0       	ldi	r22, 0x01	; 1
    1240:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    1244:	80 93 d9 31 	sts	0x31D9, r24
    1248:	90 93 da 31 	sts	0x31DA, r25
    xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    124c:	80 e1       	ldi	r24, 0x10	; 16
    124e:	61 e0       	ldi	r22, 0x01	; 1
    1250:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    1254:	80 93 fc 31 	sts	0x31FC, r24
    1258:	90 93 fd 31 	sts	0x31FD, r25
    xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    125c:	84 e0       	ldi	r24, 0x04	; 4
    125e:	61 e0       	ldi	r22, 0x01	; 1
    1260:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    1264:	80 93 25 32 	sts	0x3225, r24
    1268:	90 93 26 32 	sts	0x3226, r25
    
    vSemaphoreCreateBinary(xSemaphoreRs485); 
    126c:	81 e0       	ldi	r24, 0x01	; 1
    126e:	60 e0       	ldi	r22, 0x00	; 0
    1270:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    1274:	80 93 0f 32 	sts	0x320F, r24
    1278:	90 93 10 32 	sts	0x3210, r25
    127c:	00 97       	sbiw	r24, 0x00	; 0
    127e:	39 f0       	breq	.+14     	; 0x128e <xSerialPortInitMinimal+0x68>
    1280:	60 e0       	ldi	r22, 0x00	; 0
    1282:	70 e0       	ldi	r23, 0x00	; 0
    1284:	40 e0       	ldi	r20, 0x00	; 0
    1286:	50 e0       	ldi	r21, 0x00	; 0
    1288:	20 e0       	ldi	r18, 0x00	; 0
    128a:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63
  UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );      Set the data bits to 8. */
  //UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
  //UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );      Set the data bits to 8. */
  
  return;
}
    1292:	08 95       	ret

00001294 <USARTF0_RX_vect>:

/*-----------------------------------------------------------*/
ISR(USARTF0_RX_vect)
{
    1294:	1f 92       	push	r1
    1296:	0f 92       	push	r0
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	0f 92       	push	r0
    129c:	08 b6       	in	r0, 0x38	; 56
    129e:	0f 92       	push	r0
    12a0:	09 b6       	in	r0, 0x39	; 57
    12a2:	0f 92       	push	r0
    12a4:	0b b6       	in	r0, 0x3b	; 59
    12a6:	0f 92       	push	r0
    12a8:	11 24       	eor	r1, r1
    12aa:	18 be       	out	0x38, r1	; 56
    12ac:	19 be       	out	0x39, r1	; 57
    12ae:	1b be       	out	0x3b, r1	; 59
    12b0:	2f 93       	push	r18
    12b2:	3f 93       	push	r19
    12b4:	4f 93       	push	r20
    12b6:	5f 93       	push	r21
    12b8:	6f 93       	push	r22
    12ba:	7f 93       	push	r23
    12bc:	8f 93       	push	r24
    12be:	9f 93       	push	r25
    12c0:	af 93       	push	r26
    12c2:	bf 93       	push	r27
    12c4:	ef 93       	push	r30
    12c6:	ff 93       	push	r31
    12c8:	df 93       	push	r29
    12ca:	cf 93       	push	r28
    12cc:	0f 92       	push	r0
    12ce:	cd b7       	in	r28, 0x3d	; 61
    12d0:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  signed portCHAR cChar;

  cChar = USARTF0.DATA;//UDR0;
    12d2:	80 91 a0 0b 	lds	r24, 0x0BA0
    12d6:	89 83       	std	Y+1, r24	; 0x01

  xHigherPriorityTaskWoken = pdFALSE;
    12d8:	10 92 02 20 	sts	0x2002, r1

//  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
    12dc:	80 91 fc 31 	lds	r24, 0x31FC
    12e0:	90 91 fd 31 	lds	r25, 0x31FD
    12e4:	be 01       	movw	r22, r28
    12e6:	6f 5f       	subi	r22, 0xFF	; 255
    12e8:	7f 4f       	sbci	r23, 0xFF	; 255
    12ea:	42 e0       	ldi	r20, 0x02	; 2
    12ec:	50 e2       	ldi	r21, 0x20	; 32
    12ee:	20 e0       	ldi	r18, 0x00	; 0
    12f0:	0e 94 6c 4e 	call	0x9cd8	; 0x9cd8 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    12f4:	80 91 02 20 	lds	r24, 0x2002
    12f8:	88 23       	and	r24, r24
    12fa:	11 f0       	breq	.+4      	; 0x1300 <USARTF0_RX_vect+0x6c>
  {
    taskYIELD();
    12fc:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
  }
}
    1300:	0f 90       	pop	r0
    1302:	cf 91       	pop	r28
    1304:	df 91       	pop	r29
    1306:	ff 91       	pop	r31
    1308:	ef 91       	pop	r30
    130a:	bf 91       	pop	r27
    130c:	af 91       	pop	r26
    130e:	9f 91       	pop	r25
    1310:	8f 91       	pop	r24
    1312:	7f 91       	pop	r23
    1314:	6f 91       	pop	r22
    1316:	5f 91       	pop	r21
    1318:	4f 91       	pop	r20
    131a:	3f 91       	pop	r19
    131c:	2f 91       	pop	r18
    131e:	0f 90       	pop	r0
    1320:	0b be       	out	0x3b, r0	; 59
    1322:	0f 90       	pop	r0
    1324:	09 be       	out	0x39, r0	; 57
    1326:	0f 90       	pop	r0
    1328:	08 be       	out	0x38, r0	; 56
    132a:	0f 90       	pop	r0
    132c:	0f be       	out	0x3f, r0	; 63
    132e:	0f 90       	pop	r0
    1330:	1f 90       	pop	r1
    1332:	18 95       	reti

00001334 <uartRs485SendByte>:
    1334:	df 93       	push	r29
    1336:	cf 93       	push	r28
    1338:	0f 92       	push	r0
    133a:	cd b7       	in	r28, 0x3d	; 61
    133c:	de b7       	in	r29, 0x3e	; 62
    133e:	89 83       	std	Y+1, r24	; 0x01
    1340:	80 91 25 32 	lds	r24, 0x3225
    1344:	90 91 26 32 	lds	r25, 0x3226
    1348:	be 01       	movw	r22, r28
    134a:	6f 5f       	subi	r22, 0xFF	; 255
    134c:	7f 4f       	sbci	r23, 0xFF	; 255
    134e:	4f ef       	ldi	r20, 0xFF	; 255
    1350:	5f ef       	ldi	r21, 0xFF	; 255
    1352:	20 e0       	ldi	r18, 0x00	; 0
    1354:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>
    1358:	e0 ea       	ldi	r30, 0xA0	; 160
    135a:	fb e0       	ldi	r31, 0x0B	; 11
    135c:	81 81       	ldd	r24, Z+1	; 0x01
    135e:	80 62       	ori	r24, 0x20	; 32
    1360:	81 83       	std	Z+1, r24	; 0x01
    1362:	0f 90       	pop	r0
    1364:	cf 91       	pop	r28
    1366:	df 91       	pop	r29
    1368:	08 95       	ret

0000136a <rs485Receive>:
    136a:	9c 01       	movw	r18, r24
    136c:	46 2f       	mov	r20, r22
    136e:	80 91 fc 31 	lds	r24, 0x31FC
    1372:	90 91 fd 31 	lds	r25, 0x31FD
    1376:	b9 01       	movw	r22, r18
    1378:	50 e0       	ldi	r21, 0x00	; 0
    137a:	20 e0       	ldi	r18, 0x00	; 0
    137c:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    1380:	08 95       	ret

00001382 <USARTF0_UDRE_vect>:
{
  return xQueueReceive(xRs485Rec, c, timeout);
}

ISR(USARTF0_UDRE_vect) //   USART0_UDRE_vect
{
    1382:	1f 92       	push	r1
    1384:	0f 92       	push	r0
    1386:	0f b6       	in	r0, 0x3f	; 63
    1388:	0f 92       	push	r0
    138a:	08 b6       	in	r0, 0x38	; 56
    138c:	0f 92       	push	r0
    138e:	09 b6       	in	r0, 0x39	; 57
    1390:	0f 92       	push	r0
    1392:	0b b6       	in	r0, 0x3b	; 59
    1394:	0f 92       	push	r0
    1396:	11 24       	eor	r1, r1
    1398:	18 be       	out	0x38, r1	; 56
    139a:	19 be       	out	0x39, r1	; 57
    139c:	1b be       	out	0x3b, r1	; 59
    139e:	2f 93       	push	r18
    13a0:	3f 93       	push	r19
    13a2:	4f 93       	push	r20
    13a4:	5f 93       	push	r21
    13a6:	6f 93       	push	r22
    13a8:	7f 93       	push	r23
    13aa:	8f 93       	push	r24
    13ac:	9f 93       	push	r25
    13ae:	af 93       	push	r26
    13b0:	bf 93       	push	r27
    13b2:	ef 93       	push	r30
    13b4:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
    13b6:	80 91 25 32 	lds	r24, 0x3225
    13ba:	90 91 26 32 	lds	r25, 0x3226
    13be:	6e e4       	ldi	r22, 0x4E	; 78
    13c0:	75 e2       	ldi	r23, 0x25	; 37
    13c2:	4f e4       	ldi	r20, 0x4F	; 79
    13c4:	55 e2       	ldi	r21, 0x25	; 37
    13c6:	0e 94 94 4f 	call	0x9f28	; 0x9f28 <xQueueReceiveFromISR>
    13ca:	81 30       	cpi	r24, 0x01	; 1
    13cc:	59 f4       	brne	.+22     	; 0x13e4 <USARTF0_UDRE_vect+0x62>
  {
    Rs485TxStart();
    13ce:	80 91 a4 06 	lds	r24, 0x06A4
    13d2:	80 62       	ori	r24, 0x20	; 32
    13d4:	e0 ea       	ldi	r30, 0xA0	; 160
    13d6:	f6 e0       	ldi	r31, 0x06	; 6
    13d8:	84 83       	std	Z+4, r24	; 0x04
    USARTF0.DATA = data; 
    13da:	80 91 4e 25 	lds	r24, 0x254E
    13de:	80 93 a0 0b 	sts	0x0BA0, r24
    13e2:	08 c0       	rjmp	.+16     	; 0x13f4 <USARTF0_UDRE_vect+0x72>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    13e4:	10 92 4f 25 	sts	0x254F, r1
    vInterruptRs485Off();
    13e8:	80 91 a1 0b 	lds	r24, 0x0BA1
    13ec:	8f 7d       	andi	r24, 0xDF	; 223
    13ee:	e0 ea       	ldi	r30, 0xA0	; 160
    13f0:	fb e0       	ldi	r31, 0x0B	; 11
    13f2:	81 83       	std	Z+1, r24	; 0x01
  }
  if( xHigherPriorityTaskWoken )
    13f4:	80 91 4f 25 	lds	r24, 0x254F
    13f8:	88 23       	and	r24, r24
    13fa:	11 f0       	breq	.+4      	; 0x1400 <USARTF0_UDRE_vect+0x7e>
  {
    taskYIELD();
    13fc:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
  }
}
    1400:	ff 91       	pop	r31
    1402:	ef 91       	pop	r30
    1404:	bf 91       	pop	r27
    1406:	af 91       	pop	r26
    1408:	9f 91       	pop	r25
    140a:	8f 91       	pop	r24
    140c:	7f 91       	pop	r23
    140e:	6f 91       	pop	r22
    1410:	5f 91       	pop	r21
    1412:	4f 91       	pop	r20
    1414:	3f 91       	pop	r19
    1416:	2f 91       	pop	r18
    1418:	0f 90       	pop	r0
    141a:	0b be       	out	0x3b, r0	; 59
    141c:	0f 90       	pop	r0
    141e:	09 be       	out	0x39, r0	; 57
    1420:	0f 90       	pop	r0
    1422:	08 be       	out	0x38, r0	; 56
    1424:	0f 90       	pop	r0
    1426:	0f be       	out	0x3f, r0	; 63
    1428:	0f 90       	pop	r0
    142a:	1f 90       	pop	r1
    142c:	18 95       	reti

0000142e <__vector_121>:

ISR(USARTF0_TXC_vect) //  USART0_TX_vect
{
    142e:	1f 92       	push	r1
    1430:	0f 92       	push	r0
    1432:	0f b6       	in	r0, 0x3f	; 63
    1434:	0f 92       	push	r0
    1436:	08 b6       	in	r0, 0x38	; 56
    1438:	0f 92       	push	r0
    143a:	0b b6       	in	r0, 0x3b	; 59
    143c:	0f 92       	push	r0
    143e:	11 24       	eor	r1, r1
    1440:	18 be       	out	0x38, r1	; 56
    1442:	1b be       	out	0x3b, r1	; 59
    1444:	8f 93       	push	r24
    1446:	ef 93       	push	r30
    1448:	ff 93       	push	r31
  if (!vIsInterruptRs485On())
    144a:	80 91 a1 0b 	lds	r24, 0x0BA1
    144e:	85 fd       	sbrc	r24, 5
    1450:	06 c0       	rjmp	.+12     	; 0x145e <__vector_121+0x30>
    Rs485TxStop();
    1452:	80 91 a4 06 	lds	r24, 0x06A4
    1456:	8f 7d       	andi	r24, 0xDF	; 223
    1458:	e0 ea       	ldi	r30, 0xA0	; 160
    145a:	f6 e0       	ldi	r31, 0x06	; 6
    145c:	84 83       	std	Z+4, r24	; 0x04
}
    145e:	ff 91       	pop	r31
    1460:	ef 91       	pop	r30
    1462:	8f 91       	pop	r24
    1464:	0f 90       	pop	r0
    1466:	0b be       	out	0x3b, r0	; 59
    1468:	0f 90       	pop	r0
    146a:	08 be       	out	0x38, r0	; 56
    146c:	0f 90       	pop	r0
    146e:	0f be       	out	0x3f, r0	; 63
    1470:	0f 90       	pop	r0
    1472:	1f 90       	pop	r1
    1474:	18 95       	reti

00001476 <flushRs485RecBuffer>:
    1476:	ff 92       	push	r15
    1478:	0f 93       	push	r16
    147a:	1f 93       	push	r17
    147c:	df 93       	push	r29
    147e:	cf 93       	push	r28
    1480:	0f 92       	push	r0
    1482:	cd b7       	in	r28, 0x3d	; 61
    1484:	de b7       	in	r29, 0x3e	; 62
    1486:	ff 24       	eor	r15, r15
    1488:	8e 01       	movw	r16, r28
    148a:	0f 5f       	subi	r16, 0xFF	; 255
    148c:	1f 4f       	sbci	r17, 0xFF	; 255
    148e:	01 c0       	rjmp	.+2      	; 0x1492 <flushRs485RecBuffer+0x1c>
    1490:	f3 94       	inc	r15
    1492:	80 91 fc 31 	lds	r24, 0x31FC
    1496:	90 91 fd 31 	lds	r25, 0x31FD
    149a:	b8 01       	movw	r22, r16
    149c:	4a e0       	ldi	r20, 0x0A	; 10
    149e:	50 e0       	ldi	r21, 0x00	; 0
    14a0:	20 e0       	ldi	r18, 0x00	; 0
    14a2:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    14a6:	81 30       	cpi	r24, 0x01	; 1
    14a8:	99 f3       	breq	.-26     	; 0x1490 <flushRs485RecBuffer+0x1a>
    14aa:	8f 2d       	mov	r24, r15
    14ac:	0f 90       	pop	r0
    14ae:	cf 91       	pop	r28
    14b0:	df 91       	pop	r29
    14b2:	1f 91       	pop	r17
    14b4:	0f 91       	pop	r16
    14b6:	ff 90       	pop	r15
    14b8:	08 95       	ret

000014ba <takeRs485>:
    14ba:	80 91 0f 32 	lds	r24, 0x320F
    14be:	90 91 10 32 	lds	r25, 0x3210
    14c2:	60 e0       	ldi	r22, 0x00	; 0
    14c4:	70 e0       	ldi	r23, 0x00	; 0
    14c6:	4f ef       	ldi	r20, 0xFF	; 255
    14c8:	5f ef       	ldi	r21, 0xFF	; 255
    14ca:	20 e0       	ldi	r18, 0x00	; 0
    14cc:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    14d0:	08 95       	ret

000014d2 <releaseRs485>:
    14d2:	80 91 0f 32 	lds	r24, 0x320F
    14d6:	90 91 10 32 	lds	r25, 0x3210
    14da:	60 e0       	ldi	r22, 0x00	; 0
    14dc:	70 e0       	ldi	r23, 0x00	; 0
    14de:	40 e0       	ldi	r20, 0x00	; 0
    14e0:	50 e0       	ldi	r21, 0x00	; 0
    14e2:	20 e0       	ldi	r18, 0x00	; 0
    14e4:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>
    14e8:	08 95       	ret

000014ea <InterruptVtyOn>:
}

void InterruptVtyOn(void)
{                                  
  unsigned portCHAR ucByte;                                       
  ucByte = USARTD0.STATUS;//UCSR1B;                 
    14ea:	e0 ea       	ldi	r30, 0xA0	; 160
    14ec:	f9 e0       	ldi	r31, 0x09	; 9
    14ee:	81 81       	ldd	r24, Z+1	; 0x01
  ucByte |= serDATA_INT_ENABLE;    
    14f0:	80 62       	ori	r24, 0x20	; 32
 // UCSR1B = ucByte;       
  USARTD0.STATUS=ucByte;
    14f2:	81 83       	std	Z+1, r24	; 0x01
}
    14f4:	08 95       	ret

000014f6 <__vector_88>:

/*-----------------------------------------------------------*/
ISR(USARTD0_RXC_vect)//  USART1_RX_vect
{
    14f6:	1f 92       	push	r1
    14f8:	0f 92       	push	r0
    14fa:	0f b6       	in	r0, 0x3f	; 63
    14fc:	0f 92       	push	r0
    14fe:	08 b6       	in	r0, 0x38	; 56
    1500:	0f 92       	push	r0
    1502:	09 b6       	in	r0, 0x39	; 57
    1504:	0f 92       	push	r0
    1506:	0b b6       	in	r0, 0x3b	; 59
    1508:	0f 92       	push	r0
    150a:	11 24       	eor	r1, r1
    150c:	18 be       	out	0x38, r1	; 56
    150e:	19 be       	out	0x39, r1	; 57
    1510:	1b be       	out	0x3b, r1	; 59
    1512:	2f 93       	push	r18
    1514:	3f 93       	push	r19
    1516:	4f 93       	push	r20
    1518:	5f 93       	push	r21
    151a:	6f 93       	push	r22
    151c:	7f 93       	push	r23
    151e:	8f 93       	push	r24
    1520:	9f 93       	push	r25
    1522:	af 93       	push	r26
    1524:	bf 93       	push	r27
    1526:	ef 93       	push	r30
    1528:	ff 93       	push	r31
    152a:	df 93       	push	r29
    152c:	cf 93       	push	r28
    152e:	0f 92       	push	r0
    1530:	cd b7       	in	r28, 0x3d	; 61
    1532:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  signed portCHAR cChar;

  cChar = USARTD0.DATA;//UDR1;
    1534:	80 91 a0 09 	lds	r24, 0x09A0
    1538:	89 83       	std	Y+1, r24	; 0x01
//  xQueueSendFromISR(xVtyRec, &cChar, NULL);

  xHigherPriorityTaskWoken = pdFALSE;
    153a:	10 92 4d 25 	sts	0x254D, r1
  xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
    153e:	80 91 0d 32 	lds	r24, 0x320D
    1542:	90 91 0e 32 	lds	r25, 0x320E
    1546:	be 01       	movw	r22, r28
    1548:	6f 5f       	subi	r22, 0xFF	; 255
    154a:	7f 4f       	sbci	r23, 0xFF	; 255
    154c:	4d e4       	ldi	r20, 0x4D	; 77
    154e:	55 e2       	ldi	r21, 0x25	; 37
    1550:	20 e0       	ldi	r18, 0x00	; 0
    1552:	0e 94 6c 4e 	call	0x9cd8	; 0x9cd8 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    1556:	80 91 4d 25 	lds	r24, 0x254D
    155a:	88 23       	and	r24, r24
    155c:	11 f0       	breq	.+4      	; 0x1562 <__vector_88+0x6c>
  {
    taskYIELD();
    155e:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
  }
}
    1562:	0f 90       	pop	r0
    1564:	cf 91       	pop	r28
    1566:	df 91       	pop	r29
    1568:	ff 91       	pop	r31
    156a:	ef 91       	pop	r30
    156c:	bf 91       	pop	r27
    156e:	af 91       	pop	r26
    1570:	9f 91       	pop	r25
    1572:	8f 91       	pop	r24
    1574:	7f 91       	pop	r23
    1576:	6f 91       	pop	r22
    1578:	5f 91       	pop	r21
    157a:	4f 91       	pop	r20
    157c:	3f 91       	pop	r19
    157e:	2f 91       	pop	r18
    1580:	0f 90       	pop	r0
    1582:	0b be       	out	0x3b, r0	; 59
    1584:	0f 90       	pop	r0
    1586:	09 be       	out	0x39, r0	; 57
    1588:	0f 90       	pop	r0
    158a:	08 be       	out	0x38, r0	; 56
    158c:	0f 90       	pop	r0
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	0f 90       	pop	r0
    1592:	1f 90       	pop	r1
    1594:	18 95       	reti

00001596 <uartVtySendByte>:

void uartVtySendByte(uint8_t data)
{
    1596:	df 93       	push	r29
    1598:	cf 93       	push	r28
    159a:	0f 92       	push	r0
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
    15a0:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
    15a2:	80 91 d9 31 	lds	r24, 0x31D9
    15a6:	90 91 da 31 	lds	r25, 0x31DA
    15aa:	be 01       	movw	r22, r28
    15ac:	6f 5f       	subi	r22, 0xFF	; 255
    15ae:	7f 4f       	sbci	r23, 0xFF	; 255
    15b0:	4f ef       	ldi	r20, 0xFF	; 255
    15b2:	5f ef       	ldi	r21, 0xFF	; 255
    15b4:	20 e0       	ldi	r18, 0x00	; 0
    15b6:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>
  vInterruptVtyOn();
    15ba:	e0 ea       	ldi	r30, 0xA0	; 160
    15bc:	f9 e0       	ldi	r31, 0x09	; 9
    15be:	81 81       	ldd	r24, Z+1	; 0x01
    15c0:	80 62       	ori	r24, 0x20	; 32
    15c2:	81 83       	std	Z+1, r24	; 0x01
}
    15c4:	0f 90       	pop	r0
    15c6:	cf 91       	pop	r28
    15c8:	df 91       	pop	r29
    15ca:	08 95       	ret

000015cc <VtyPutChar>:
}

int VtyPutChar(char c, FILE *stream)
{
  stream = NULL;
  uartVtySendByte(c);
    15cc:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
  return 0;
}
    15d0:	80 e0       	ldi	r24, 0x00	; 0
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	08 95       	ret

000015d6 <__vector_89>:
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
  vInterruptVtyOn();
}

ISR(USARTD0_DRE_vect) // USART1_UDRE_vect
{
    15d6:	1f 92       	push	r1
    15d8:	0f 92       	push	r0
    15da:	0f b6       	in	r0, 0x3f	; 63
    15dc:	0f 92       	push	r0
    15de:	08 b6       	in	r0, 0x38	; 56
    15e0:	0f 92       	push	r0
    15e2:	09 b6       	in	r0, 0x39	; 57
    15e4:	0f 92       	push	r0
    15e6:	0b b6       	in	r0, 0x3b	; 59
    15e8:	0f 92       	push	r0
    15ea:	11 24       	eor	r1, r1
    15ec:	18 be       	out	0x38, r1	; 56
    15ee:	19 be       	out	0x39, r1	; 57
    15f0:	1b be       	out	0x3b, r1	; 59
    15f2:	2f 93       	push	r18
    15f4:	3f 93       	push	r19
    15f6:	4f 93       	push	r20
    15f8:	5f 93       	push	r21
    15fa:	6f 93       	push	r22
    15fc:	7f 93       	push	r23
    15fe:	8f 93       	push	r24
    1600:	9f 93       	push	r25
    1602:	af 93       	push	r26
    1604:	bf 93       	push	r27
    1606:	ef 93       	push	r30
    1608:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
    160a:	80 91 d9 31 	lds	r24, 0x31D9
    160e:	90 91 da 31 	lds	r25, 0x31DA
    1612:	6b e4       	ldi	r22, 0x4B	; 75
    1614:	75 e2       	ldi	r23, 0x25	; 37
    1616:	4c e4       	ldi	r20, 0x4C	; 76
    1618:	55 e2       	ldi	r21, 0x25	; 37
    161a:	0e 94 94 4f 	call	0x9f28	; 0x9f28 <xQueueReceiveFromISR>
    161e:	81 30       	cpi	r24, 0x01	; 1
    1620:	29 f4       	brne	.+10     	; 0x162c <__vector_89+0x56>
  {
    USARTD0.DATA = data; 
    1622:	80 91 4b 25 	lds	r24, 0x254B
    1626:	80 93 a0 09 	sts	0x09A0, r24
    162a:	08 c0       	rjmp	.+16     	; 0x163c <__vector_89+0x66>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    162c:	10 92 4c 25 	sts	0x254C, r1
    vInterruptVtyOff();
    1630:	80 91 a1 09 	lds	r24, 0x09A1
    1634:	8f 7d       	andi	r24, 0xDF	; 223
    1636:	e0 ea       	ldi	r30, 0xA0	; 160
    1638:	f9 e0       	ldi	r31, 0x09	; 9
    163a:	81 83       	std	Z+1, r24	; 0x01
  }
  if( xHigherPriorityTaskWoken )
    163c:	80 91 4c 25 	lds	r24, 0x254C
    1640:	88 23       	and	r24, r24
    1642:	11 f0       	breq	.+4      	; 0x1648 <__vector_89+0x72>
  {
    taskYIELD();
    1644:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
  }
}
    1648:	ff 91       	pop	r31
    164a:	ef 91       	pop	r30
    164c:	bf 91       	pop	r27
    164e:	af 91       	pop	r26
    1650:	9f 91       	pop	r25
    1652:	8f 91       	pop	r24
    1654:	7f 91       	pop	r23
    1656:	6f 91       	pop	r22
    1658:	5f 91       	pop	r21
    165a:	4f 91       	pop	r20
    165c:	3f 91       	pop	r19
    165e:	2f 91       	pop	r18
    1660:	0f 90       	pop	r0
    1662:	0b be       	out	0x3b, r0	; 59
    1664:	0f 90       	pop	r0
    1666:	09 be       	out	0x39, r0	; 57
    1668:	0f 90       	pop	r0
    166a:	08 be       	out	0x38, r0	; 56
    166c:	0f 90       	pop	r0
    166e:	0f be       	out	0x3f, r0	; 63
    1670:	0f 90       	pop	r0
    1672:	1f 90       	pop	r1
    1674:	18 95       	reti

00001676 <hardwareInit>:
xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisję do czasu zakończenia wysyłania poprzedniego bajtu

void hardwareInit(void)
{
  //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    1676:	0f b6       	in	r0, 0x3f	; 63
    1678:	f8 94       	cli
    167a:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    167c:	81 e0       	ldi	r24, 0x01	; 1
    167e:	61 e0       	ldi	r22, 0x01	; 1
    1680:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    1684:	80 93 c2 32 	sts	0x32C2, r24
    1688:	90 93 c3 32 	sts	0x32C3, r25
  portEXIT_CRITICAL();
    168c:	0f 90       	pop	r0
    168e:	0f be       	out	0x3f, r0	; 63

 //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    1690:	0f b6       	in	r0, 0x3f	; 63
    1692:	f8 94       	cli
    1694:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    1696:	81 e0       	ldi	r24, 0x01	; 1
    1698:	61 e0       	ldi	r22, 0x01	; 1
    169a:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    169e:	80 93 c2 32 	sts	0x32C2, r24
    16a2:	90 93 c3 32 	sts	0x32C3, r25
  portEXIT_CRITICAL();
    16a6:	0f 90       	pop	r0
    16a8:	0f be       	out	0x3f, r0	; 63
5- JTAG TDI
4- JTAG TMS
5:2 - LCD D4:D7
0 - ENC28J60 CS
*/
PORTB.DIR=0x01;
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	80 93 20 06 	sts	0x0620, r24
4- SD_card CS
3- ST2378 OE
1- I2C SCL
0- I2C SDA
*/
PORTC.DIR=0xA0;
    16b0:	80 ea       	ldi	r24, 0xA0	; 160
    16b2:	80 93 40 06 	sts	0x0640, r24
3- FT232 TXT-WY
2- FT232 RXT-WE
1- ENC28J60 RST
0- ENC28J60 INT
*/
PORTD.DIR=0xBA;
    16b6:	8a eb       	ldi	r24, 0xBA	; 186
    16b8:	80 93 60 06 	sts	0x0660, r24
/* PORTE
7:0- ZL SPI A7:A0
*/
PORTE.DIR=0xFF;
    16bc:	8f ef       	ldi	r24, 0xFF	; 255
    16be:	80 93 80 06 	sts	0x0680, r24
5- RS485 DE/RE
4- INT
3- RS485 TXD
2- RS485 RXD
*/
PORTF.DIR=0x28;
    16c2:	98 e2       	ldi	r25, 0x28	; 40
    16c4:	90 93 a0 06 	sts	0x06A0, r25
6:4- EBI A18:A16
2-   EBI ALE
1-   EBI RE
0-   EBI WE
*/
PORTH.DIR=0xFF;
    16c8:	80 93 e0 06 	sts	0x06E0, r24
/* PORTJ
7:0- EBI D7:D0/A0:A7
*/
PORTJ.DIR=0xFF;
    16cc:	80 93 00 07 	sts	0x0700, r24
/* PORTK
7:0- EBI A8:A15
*/
PORTK.DIR=0xFF;
    16d0:	80 93 20 07 	sts	0x0720, r24
}
    16d4:	08 95       	ret

000016d6 <LockersMemInit>:

void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
    16d6:	88 e1       	ldi	r24, 0x18	; 24
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xmalloc>
    16de:	80 93 00 32 	sts	0x3200, r24
    16e2:	90 93 01 32 	sts	0x3201, r25
}
    16e6:	08 95       	ret

000016e8 <printLockers>:

uint8_t printLockers(FILE *stream)
{
    16e8:	4f 92       	push	r4
    16ea:	5f 92       	push	r5
    16ec:	6f 92       	push	r6
    16ee:	7f 92       	push	r7
    16f0:	9f 92       	push	r9
    16f2:	af 92       	push	r10
    16f4:	bf 92       	push	r11
    16f6:	cf 92       	push	r12
    16f8:	df 92       	push	r13
    16fa:	ef 92       	push	r14
    16fc:	ff 92       	push	r15
    16fe:	0f 93       	push	r16
    1700:	1f 93       	push	r17
    1702:	cf 93       	push	r28
    1704:	df 93       	push	r29
    1706:	7c 01       	movw	r14, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
    1708:	c0 91 00 32 	lds	r28, 0x3200
    170c:	d0 91 01 32 	lds	r29, 0x3201
    1710:	00 e0       	ldi	r16, 0x00	; 0
    1712:	10 e0       	ldi	r17, 0x00	; 0
}

uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
    1714:	99 24       	eor	r9, r9
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1716:	34 ef       	ldi	r19, 0xF4	; 244
    1718:	c3 2e       	mov	r12, r19
    171a:	31 e0       	ldi	r19, 0x01	; 1
    171c:	d3 2e       	mov	r13, r19
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    171e:	21 e1       	ldi	r18, 0x11	; 17
    1720:	a2 2e       	mov	r10, r18
    1722:	22 e0       	ldi	r18, 0x02	; 2
    1724:	b2 2e       	mov	r11, r18
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
    1726:	98 e0       	ldi	r25, 0x08	; 8
    1728:	69 2e       	mov	r6, r25
    172a:	92 e0       	ldi	r25, 0x02	; 2
    172c:	79 2e       	mov	r7, r25
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
    172e:	8f ef       	ldi	r24, 0xFF	; 255
    1730:	48 2e       	mov	r4, r24
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	58 2e       	mov	r5, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    1736:	88 81       	ld	r24, Y
    1738:	88 23       	and	r24, r24
    173a:	09 f4       	brne	.+2      	; 0x173e <printLockers+0x56>
    173c:	5a c0       	rjmp	.+180    	; 0x17f2 <printLockers+0x10a>
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    173e:	00 d0       	rcall	.+0      	; 0x1740 <printLockers+0x58>
    1740:	00 d0       	rcall	.+0      	; 0x1742 <printLockers+0x5a>
    1742:	ed b7       	in	r30, 0x3d	; 61
    1744:	fe b7       	in	r31, 0x3e	; 62
    1746:	31 96       	adiw	r30, 0x01	; 1
    1748:	ad b7       	in	r26, 0x3d	; 61
    174a:	be b7       	in	r27, 0x3e	; 62
    174c:	11 96       	adiw	r26, 0x01	; 1
    174e:	ed 92       	st	X+, r14
    1750:	fc 92       	st	X, r15
    1752:	12 97       	sbiw	r26, 0x02	; 2
    1754:	c2 82       	std	Z+2, r12	; 0x02
    1756:	d3 82       	std	Z+3, r13	; 0x03
void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
}

uint8_t printLockers(FILE *stream)
    1758:	c8 01       	movw	r24, r16
    175a:	01 96       	adiw	r24, 0x01	; 1
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    175c:	84 83       	std	Z+4, r24	; 0x04
    175e:	95 83       	std	Z+5, r25	; 0x05
    1760:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      if (tmpLock->threshold > tmpLock->acVal)
    1764:	ed b7       	in	r30, 0x3d	; 61
    1766:	fe b7       	in	r31, 0x3e	; 62
    1768:	36 96       	adiw	r30, 0x06	; 6
    176a:	ed bf       	out	0x3d, r30	; 61
    176c:	fe bf       	out	0x3e, r31	; 62
    176e:	29 81       	ldd	r18, Y+1	; 0x01
    1770:	3a 81       	ldd	r19, Y+2	; 0x02
    1772:	8b 81       	ldd	r24, Y+3	; 0x03
    1774:	9c 81       	ldd	r25, Y+4	; 0x04
    1776:	82 17       	cp	r24, r18
    1778:	93 07       	cpc	r25, r19
    177a:	68 f4       	brcc	.+26     	; 0x1796 <printLockers+0xae>
        fprintf_P(stream, statusLockerOpenStr);
    177c:	00 d0       	rcall	.+0      	; 0x177e <printLockers+0x96>
    177e:	0f 92       	push	r0
    1780:	ad b7       	in	r26, 0x3d	; 61
    1782:	be b7       	in	r27, 0x3e	; 62
    1784:	11 96       	adiw	r26, 0x01	; 1
    1786:	ed 92       	st	X+, r14
    1788:	fc 92       	st	X, r15
    178a:	12 97       	sbiw	r26, 0x02	; 2
    178c:	13 96       	adiw	r26, 0x03	; 3
    178e:	4d 92       	st	X+, r4
    1790:	5c 92       	st	X, r5
    1792:	14 97       	sbiw	r26, 0x04	; 4
    1794:	08 c0       	rjmp	.+16     	; 0x17a6 <printLockers+0xbe>
      else
        fprintf_P(stream, statusLockerCloseStr);
    1796:	00 d0       	rcall	.+0      	; 0x1798 <printLockers+0xb0>
    1798:	0f 92       	push	r0
    179a:	ed b7       	in	r30, 0x3d	; 61
    179c:	fe b7       	in	r31, 0x3e	; 62
    179e:	e1 82       	std	Z+1, r14	; 0x01
    17a0:	f2 82       	std	Z+2, r15	; 0x02
    17a2:	63 82       	std	Z+3, r6	; 0x03
    17a4:	74 82       	std	Z+4, r7	; 0x04
    17a6:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    17aa:	0f 90       	pop	r0
    17ac:	0f 90       	pop	r0
    17ae:	0f 90       	pop	r0
    17b0:	0f 90       	pop	r0
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    17b2:	8d b7       	in	r24, 0x3d	; 61
    17b4:	9e b7       	in	r25, 0x3e	; 62
    17b6:	08 97       	sbiw	r24, 0x08	; 8
    17b8:	8d bf       	out	0x3d, r24	; 61
    17ba:	9e bf       	out	0x3e, r25	; 62
    17bc:	ed b7       	in	r30, 0x3d	; 61
    17be:	fe b7       	in	r31, 0x3e	; 62
    17c0:	31 96       	adiw	r30, 0x01	; 1
    17c2:	ad b7       	in	r26, 0x3d	; 61
    17c4:	be b7       	in	r27, 0x3e	; 62
    17c6:	11 96       	adiw	r26, 0x01	; 1
    17c8:	ed 92       	st	X+, r14
    17ca:	fc 92       	st	X, r15
    17cc:	12 97       	sbiw	r26, 0x02	; 2
    17ce:	a2 82       	std	Z+2, r10	; 0x02
    17d0:	b3 82       	std	Z+3, r11	; 0x03
    17d2:	89 81       	ldd	r24, Y+1	; 0x01
    17d4:	9a 81       	ldd	r25, Y+2	; 0x02
    17d6:	84 83       	std	Z+4, r24	; 0x04
    17d8:	95 83       	std	Z+5, r25	; 0x05
    17da:	8b 81       	ldd	r24, Y+3	; 0x03
    17dc:	9c 81       	ldd	r25, Y+4	; 0x04
    17de:	86 83       	std	Z+6, r24	; 0x06
    17e0:	97 83       	std	Z+7, r25	; 0x07
    17e2:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      result++;
    17e6:	93 94       	inc	r9
    17e8:	ed b7       	in	r30, 0x3d	; 61
    17ea:	fe b7       	in	r31, 0x3e	; 62
    17ec:	38 96       	adiw	r30, 0x08	; 8
    17ee:	ed bf       	out	0x3d, r30	; 61
    17f0:	fe bf       	out	0x3e, r31	; 62
    17f2:	0f 5f       	subi	r16, 0xFF	; 255
    17f4:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
    17f6:	04 30       	cpi	r16, 0x04	; 4
    17f8:	11 05       	cpc	r17, r1
    17fa:	11 f0       	breq	.+4      	; 0x1800 <printLockers+0x118>
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
      result++;
    }
    tmpLock++;
    17fc:	26 96       	adiw	r28, 0x06	; 6
    17fe:	9b cf       	rjmp	.-202    	; 0x1736 <printLockers+0x4e>
  }
  return result;
}
    1800:	89 2d       	mov	r24, r9
    1802:	df 91       	pop	r29
    1804:	cf 91       	pop	r28
    1806:	1f 91       	pop	r17
    1808:	0f 91       	pop	r16
    180a:	ff 90       	pop	r15
    180c:	ef 90       	pop	r14
    180e:	df 90       	pop	r13
    1810:	cf 90       	pop	r12
    1812:	bf 90       	pop	r11
    1814:	af 90       	pop	r10
    1816:	9f 90       	pop	r9
    1818:	7f 90       	pop	r7
    181a:	6f 90       	pop	r6
    181c:	5f 90       	pop	r5
    181e:	4f 90       	pop	r4
    1820:	08 95       	ret

00001822 <checkLockerSensors>:

void checkLockerSensors(void)
{
    1822:	cf 93       	push	r28
    1824:	df 93       	push	r29
  if (lockSensors[0].enabled)
    1826:	e0 91 00 32 	lds	r30, 0x3200
    182a:	f0 91 01 32 	lds	r31, 0x3201
    182e:	80 81       	ld	r24, Z
    1830:	88 23       	and	r24, r24
    1832:	39 f1       	breq	.+78     	; 0x1882 <checkLockerSensors+0x60>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1834:	80 e4       	ldi	r24, 0x40	; 64
    1836:	60 e0       	ldi	r22, 0x00	; 0
    1838:	0e 94 cc 28 	call	0x5198	; 0x5198 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    183c:	8e e1       	ldi	r24, 0x1E	; 30
    183e:	90 e0       	ldi	r25, 0x00	; 0
    1840:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
    1844:	c0 91 00 32 	lds	r28, 0x3200
    1848:	d0 91 01 32 	lds	r29, 0x3201
    184c:	84 e0       	ldi	r24, 0x04	; 4
    184e:	0e 94 f5 29 	call	0x53ea	; 0x53ea <MCP3008_getSampleSingle>
    1852:	8b 83       	std	Y+3, r24	; 0x03
    1854:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1856:	80 e4       	ldi	r24, 0x40	; 64
    1858:	60 e0       	ldi	r22, 0x00	; 0
    185a:	0e 94 f1 28 	call	0x51e2	; 0x51e2 <MPC23s17ClearBitsOnPortA>
    lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
    185e:	e0 91 00 32 	lds	r30, 0x3200
    1862:	f0 91 01 32 	lds	r31, 0x3201
    1866:	41 e0       	ldi	r20, 0x01	; 1
    1868:	23 81       	ldd	r18, Z+3	; 0x03
    186a:	34 81       	ldd	r19, Z+4	; 0x04
    186c:	81 81       	ldd	r24, Z+1	; 0x01
    186e:	92 81       	ldd	r25, Z+2	; 0x02
    1870:	82 17       	cp	r24, r18
    1872:	93 07       	cpc	r25, r19
    1874:	08 f0       	brcs	.+2      	; 0x1878 <checkLockerSensors+0x56>
    1876:	40 e0       	ldi	r20, 0x00	; 0
    1878:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    187a:	8a e0       	ldi	r24, 0x0A	; 10
    187c:	90 e0       	ldi	r25, 0x00	; 0
    187e:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
  }
  
  if (lockSensors[1].enabled)
    1882:	e0 91 00 32 	lds	r30, 0x3200
    1886:	f0 91 01 32 	lds	r31, 0x3201
    188a:	86 81       	ldd	r24, Z+6	; 0x06
    188c:	88 23       	and	r24, r24
    188e:	49 f1       	breq	.+82     	; 0x18e2 <checkLockerSensors+0xc0>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1890:	80 e2       	ldi	r24, 0x20	; 32
    1892:	60 e0       	ldi	r22, 0x00	; 0
    1894:	0e 94 cc 28 	call	0x5198	; 0x5198 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1898:	8e e1       	ldi	r24, 0x1E	; 30
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
    18a0:	c0 91 00 32 	lds	r28, 0x3200
    18a4:	d0 91 01 32 	lds	r29, 0x3201
    18a8:	26 96       	adiw	r28, 0x06	; 6
    18aa:	85 e0       	ldi	r24, 0x05	; 5
    18ac:	0e 94 f5 29 	call	0x53ea	; 0x53ea <MCP3008_getSampleSingle>
    18b0:	8b 83       	std	Y+3, r24	; 0x03
    18b2:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    18b4:	80 e2       	ldi	r24, 0x20	; 32
    18b6:	60 e0       	ldi	r22, 0x00	; 0
    18b8:	0e 94 f1 28 	call	0x51e2	; 0x51e2 <MPC23s17ClearBitsOnPortA>
    lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
    18bc:	e0 91 00 32 	lds	r30, 0x3200
    18c0:	f0 91 01 32 	lds	r31, 0x3201
    18c4:	36 96       	adiw	r30, 0x06	; 6
    18c6:	41 e0       	ldi	r20, 0x01	; 1
    18c8:	23 81       	ldd	r18, Z+3	; 0x03
    18ca:	34 81       	ldd	r19, Z+4	; 0x04
    18cc:	81 81       	ldd	r24, Z+1	; 0x01
    18ce:	92 81       	ldd	r25, Z+2	; 0x02
    18d0:	82 17       	cp	r24, r18
    18d2:	93 07       	cpc	r25, r19
    18d4:	08 f0       	brcs	.+2      	; 0x18d8 <checkLockerSensors+0xb6>
    18d6:	40 e0       	ldi	r20, 0x00	; 0
    18d8:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    18da:	8a e0       	ldi	r24, 0x0A	; 10
    18dc:	90 e0       	ldi	r25, 0x00	; 0
    18de:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
  }
  
  if (lockSensors[2].enabled)
    18e2:	e0 91 00 32 	lds	r30, 0x3200
    18e6:	f0 91 01 32 	lds	r31, 0x3201
    18ea:	84 85       	ldd	r24, Z+12	; 0x0c
    18ec:	88 23       	and	r24, r24
    18ee:	49 f1       	breq	.+82     	; 0x1942 <checkLockerSensors+0x120>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    18f0:	80 e1       	ldi	r24, 0x10	; 16
    18f2:	60 e0       	ldi	r22, 0x00	; 0
    18f4:	0e 94 cc 28 	call	0x5198	; 0x5198 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    18f8:	8e e1       	ldi	r24, 0x1E	; 30
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
    1900:	c0 91 00 32 	lds	r28, 0x3200
    1904:	d0 91 01 32 	lds	r29, 0x3201
    1908:	2c 96       	adiw	r28, 0x0c	; 12
    190a:	86 e0       	ldi	r24, 0x06	; 6
    190c:	0e 94 f5 29 	call	0x53ea	; 0x53ea <MCP3008_getSampleSingle>
    1910:	8b 83       	std	Y+3, r24	; 0x03
    1912:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1914:	80 e1       	ldi	r24, 0x10	; 16
    1916:	60 e0       	ldi	r22, 0x00	; 0
    1918:	0e 94 f1 28 	call	0x51e2	; 0x51e2 <MPC23s17ClearBitsOnPortA>
    lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
    191c:	e0 91 00 32 	lds	r30, 0x3200
    1920:	f0 91 01 32 	lds	r31, 0x3201
    1924:	3c 96       	adiw	r30, 0x0c	; 12
    1926:	41 e0       	ldi	r20, 0x01	; 1
    1928:	23 81       	ldd	r18, Z+3	; 0x03
    192a:	34 81       	ldd	r19, Z+4	; 0x04
    192c:	81 81       	ldd	r24, Z+1	; 0x01
    192e:	92 81       	ldd	r25, Z+2	; 0x02
    1930:	82 17       	cp	r24, r18
    1932:	93 07       	cpc	r25, r19
    1934:	08 f0       	brcs	.+2      	; 0x1938 <checkLockerSensors+0x116>
    1936:	40 e0       	ldi	r20, 0x00	; 0
    1938:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    193a:	8a e0       	ldi	r24, 0x0A	; 10
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
  }
  
  if (lockSensors[3].enabled)
    1942:	e0 91 00 32 	lds	r30, 0x3200
    1946:	f0 91 01 32 	lds	r31, 0x3201
    194a:	82 89       	ldd	r24, Z+18	; 0x12
    194c:	88 23       	and	r24, r24
    194e:	49 f1       	breq	.+82     	; 0x19a2 <checkLockerSensors+0x180>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1950:	88 e0       	ldi	r24, 0x08	; 8
    1952:	60 e0       	ldi	r22, 0x00	; 0
    1954:	0e 94 cc 28 	call	0x5198	; 0x5198 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1958:	8e e1       	ldi	r24, 0x1E	; 30
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    1960:	c0 91 00 32 	lds	r28, 0x3200
    1964:	d0 91 01 32 	lds	r29, 0x3201
    1968:	62 96       	adiw	r28, 0x12	; 18
    196a:	87 e0       	ldi	r24, 0x07	; 7
    196c:	0e 94 f5 29 	call	0x53ea	; 0x53ea <MCP3008_getSampleSingle>
    1970:	8b 83       	std	Y+3, r24	; 0x03
    1972:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1974:	88 e0       	ldi	r24, 0x08	; 8
    1976:	60 e0       	ldi	r22, 0x00	; 0
    1978:	0e 94 f1 28 	call	0x51e2	; 0x51e2 <MPC23s17ClearBitsOnPortA>
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    197c:	e0 91 00 32 	lds	r30, 0x3200
    1980:	f0 91 01 32 	lds	r31, 0x3201
    1984:	72 96       	adiw	r30, 0x12	; 18
    1986:	41 e0       	ldi	r20, 0x01	; 1
    1988:	23 81       	ldd	r18, Z+3	; 0x03
    198a:	34 81       	ldd	r19, Z+4	; 0x04
    198c:	81 81       	ldd	r24, Z+1	; 0x01
    198e:	92 81       	ldd	r25, Z+2	; 0x02
    1990:	82 17       	cp	r24, r18
    1992:	93 07       	cpc	r25, r19
    1994:	08 f0       	brcs	.+2      	; 0x1998 <checkLockerSensors+0x176>
    1996:	40 e0       	ldi	r20, 0x00	; 0
    1998:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    199a:	8a e0       	ldi	r24, 0x0A	; 10
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
  }
}
    19a2:	df 91       	pop	r29
    19a4:	cf 91       	pop	r28
    19a6:	08 95       	ret

000019a8 <spiSend>:
    19a8:	df 93       	push	r29
    19aa:	cf 93       	push	r28
    19ac:	0f 92       	push	r0
    19ae:	cd b7       	in	r28, 0x3d	; 61
    19b0:	de b7       	in	r29, 0x3e	; 62
    19b2:	e0 ec       	ldi	r30, 0xC0	; 192
    19b4:	f8 e0       	ldi	r31, 0x08	; 8
    19b6:	83 83       	std	Z+3, r24	; 0x03
    19b8:	e0 ec       	ldi	r30, 0xC0	; 192
    19ba:	f9 e0       	ldi	r31, 0x09	; 9
    19bc:	83 83       	std	Z+3, r24	; 0x03
    19be:	80 91 c2 32 	lds	r24, 0x32C2
    19c2:	90 91 c3 32 	lds	r25, 0x32C3
    19c6:	be 01       	movw	r22, r28
    19c8:	6f 5f       	subi	r22, 0xFF	; 255
    19ca:	7f 4f       	sbci	r23, 0xFF	; 255
    19cc:	4a e0       	ldi	r20, 0x0A	; 10
    19ce:	50 e0       	ldi	r21, 0x00	; 0
    19d0:	20 e0       	ldi	r18, 0x00	; 0
    19d2:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    19d6:	89 81       	ldd	r24, Y+1	; 0x01
    19d8:	0f 90       	pop	r0
    19da:	cf 91       	pop	r28
    19dc:	df 91       	pop	r29
    19de:	08 95       	ret

000019e0 <spiSendENC>:
  SPID.DATA = data; 
  xQueueReceive(xSpiRx, &result, 10); 
  return result;
}
uint8_t spiSendENC(uint8_t data)
{
    19e0:	df 93       	push	r29
    19e2:	cf 93       	push	r28
    19e4:	0f 92       	push	r0
    19e6:	cd b7       	in	r28, 0x3d	; 61
    19e8:	de b7       	in	r29, 0x3e	; 62
  uint8_t result; 
  SPIC.DATA = data;
    19ea:	e0 ec       	ldi	r30, 0xC0	; 192
    19ec:	f8 e0       	ldi	r31, 0x08	; 8
    19ee:	83 83       	std	Z+3, r24	; 0x03
  //SPID.DATA = data; 
  xQueueReceive(xSpiRx, &result, 10); 
    19f0:	80 91 c2 32 	lds	r24, 0x32C2
    19f4:	90 91 c3 32 	lds	r25, 0x32C3
    19f8:	be 01       	movw	r22, r28
    19fa:	6f 5f       	subi	r22, 0xFF	; 255
    19fc:	7f 4f       	sbci	r23, 0xFF	; 255
    19fe:	4a e0       	ldi	r20, 0x0A	; 10
    1a00:	50 e0       	ldi	r21, 0x00	; 0
    1a02:	20 e0       	ldi	r18, 0x00	; 0
    1a04:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
  return result;
}
    1a08:	89 81       	ldd	r24, Y+1	; 0x01
    1a0a:	0f 90       	pop	r0
    1a0c:	cf 91       	pop	r28
    1a0e:	df 91       	pop	r29
    1a10:	08 95       	ret

00001a12 <spiSendSpinBlock>:
    1a12:	80 91 c2 09 	lds	r24, 0x09C2
    1a16:	87 ff       	sbrs	r24, 7
    1a18:	fc cf       	rjmp	.-8      	; 0x1a12 <spiSendSpinBlock>
    1a1a:	80 91 c3 09 	lds	r24, 0x09C3
    1a1e:	80 91 c3 09 	lds	r24, 0x09C3
    1a22:	90 91 c1 09 	lds	r25, 0x09C1
    1a26:	91 60       	ori	r25, 0x01	; 1
    1a28:	e0 ec       	ldi	r30, 0xC0	; 192
    1a2a:	f9 e0       	ldi	r31, 0x09	; 9
    1a2c:	91 83       	std	Z+1, r25	; 0x01
    1a2e:	08 95       	ret

00001a30 <spiSendSpinBlockENC>:
  return data;                     
}
uint8_t spiSendSpinBlockENC(uint8_t data)
{
  //SPDR = data;
  SPIC.DATA=data;
    1a30:	e0 ec       	ldi	r30, 0xC0	; 192
    1a32:	f8 e0       	ldi	r31, 0x08	; 8
    1a34:	83 83       	std	Z+3, r24	; 0x03
  //SPCR &= ~(1<<SPIE);                
  SPIC.INTCTRL=0x00; //Disable SPI interrupt
    1a36:	11 82       	std	Z+1, r1	; 0x01
  while(!(SPIC.STATUS&(0x80))); //(SPSR&(1<<SPIF)));
    1a38:	80 91 c2 08 	lds	r24, 0x08C2
    1a3c:	87 ff       	sbrs	r24, 7
    1a3e:	fc cf       	rjmp	.-8      	; 0x1a38 <spiSendSpinBlockENC+0x8>
  data = SPIC.DATA;//SPSR;                       Clearing interrupt flag
    1a40:	80 91 c3 08 	lds	r24, 0x08C3
  data = SPIC.DATA; //SPDR;                      Resfing DPI buffer register
    1a44:	80 91 c3 08 	lds	r24, 0x08C3
  //SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
  SPIC.INTCTRL|=0x01; //low level
    1a48:	90 91 c1 08 	lds	r25, 0x08C1
    1a4c:	91 60       	ori	r25, 0x01	; 1
    1a4e:	e0 ec       	ldi	r30, 0xC0	; 192
    1a50:	f8 e0       	ldi	r31, 0x08	; 8
    1a52:	91 83       	std	Z+1, r25	; 0x01
  return data;                     
}
    1a54:	08 95       	ret

00001a56 <disableAllSpiDevices>:
{ 
#if disableSpiPORTA_OR !=0
  PORTA.OUT |= disableSpiPORTA_OR;
#endif
#if disableSpiPORTB_AND !=0xFF
  PORTA.OUT &= disableSpiPORTB_AND;
    1a56:	e0 e0       	ldi	r30, 0x00	; 0
    1a58:	f6 e0       	ldi	r31, 0x06	; 6
    1a5a:	84 81       	ldd	r24, Z+4	; 0x04
    1a5c:	8e 7f       	andi	r24, 0xFE	; 254
    1a5e:	84 83       	std	Z+4, r24	; 0x04
#endif
  
#if disableSpiPORTB_OR != 0
  PORTB.OUT |= disableSpiPORTB_OR;
    1a60:	e0 e2       	ldi	r30, 0x20	; 32
    1a62:	f6 e0       	ldi	r31, 0x06	; 6
    1a64:	84 81       	ldd	r24, Z+4	; 0x04
    1a66:	81 60       	ori	r24, 0x01	; 1
    1a68:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTB_AND != 0xFF 
  PORTB.OUT &= disableSpiPORTB_AND;
    1a6a:	84 81       	ldd	r24, Z+4	; 0x04
    1a6c:	8e 7f       	andi	r24, 0xFE	; 254
    1a6e:	84 83       	std	Z+4, r24	; 0x04
#endif
  
#if disableSpiPORTC_OR !=0
  PORTC.OUT |= disableSpiPORTC_OR;
    1a70:	e0 e4       	ldi	r30, 0x40	; 64
    1a72:	f6 e0       	ldi	r31, 0x06	; 6
    1a74:	84 81       	ldd	r24, Z+4	; 0x04
    1a76:	80 61       	ori	r24, 0x10	; 16
    1a78:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTC_AND !=0xFF
  PORTC.OUT |= disableSpiPORTC_AND;
    1a7a:	84 81       	ldd	r24, Z+4	; 0x04
    1a7c:	8f 6e       	ori	r24, 0xEF	; 239
    1a7e:	84 83       	std	Z+4, r24	; 0x04
#if disableSpiPORTD_AND != 0xFF
  PORTD.OUT &= disableSpiPORTD_AND;
#endif
  
#if disableSpiPORTE_OR != 0
  PORTE.OUT |= disableSpiPORTE_OR;
    1a80:	e0 e8       	ldi	r30, 0x80	; 128
    1a82:	f6 e0       	ldi	r31, 0x06	; 6
    1a84:	84 81       	ldd	r24, Z+4	; 0x04
    1a86:	80 6c       	ori	r24, 0xC0	; 192
    1a88:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTE_AND != 0xFF
  PORTE.OUT &= disableSpiPORTE_AND;
    1a8a:	84 81       	ldd	r24, Z+4	; 0x04
    1a8c:	8f 7d       	andi	r24, 0xDF	; 223
    1a8e:	84 83       	std	Z+4, r24	; 0x04
#if disableSpiPORTH_AND != 0xFF
#error Port H is memory bus
  PORTH.OUT &= disableSpiPORTG_AND;
#endif

}
    1a90:	08 95       	ret

00001a92 <spiEnableEnc28j60>:
    1a92:	e0 e2       	ldi	r30, 0x20	; 32
    1a94:	f6 e0       	ldi	r31, 0x06	; 6
    1a96:	84 81       	ldd	r24, Z+4	; 0x04
    1a98:	8e 7f       	andi	r24, 0xFE	; 254
    1a9a:	84 83       	std	Z+4, r24	; 0x04
    1a9c:	08 95       	ret

00001a9e <spiDisableEnc28j60>:
    1a9e:	e0 e2       	ldi	r30, 0x20	; 32
    1aa0:	f6 e0       	ldi	r31, 0x06	; 6
    1aa2:	84 81       	ldd	r24, Z+4	; 0x04
    1aa4:	81 60       	ori	r24, 0x01	; 1
    1aa6:	84 83       	std	Z+4, r24	; 0x04
    1aa8:	08 95       	ret

00001aaa <enableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
    1aaa:	e0 e4       	ldi	r30, 0x40	; 64
    1aac:	f6 e0       	ldi	r31, 0x06	; 6
    1aae:	84 81       	ldd	r24, Z+4	; 0x04
    1ab0:	8f 7e       	andi	r24, 0xEF	; 239
    1ab2:	84 83       	std	Z+4, r24	; 0x04
#endif   
}
    1ab4:	08 95       	ret

00001ab6 <disableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
    1ab6:	e0 e4       	ldi	r30, 0x40	; 64
    1ab8:	f6 e0       	ldi	r31, 0x06	; 6
    1aba:	84 81       	ldd	r24, Z+4	; 0x04
    1abc:	80 61       	ori	r24, 0x10	; 16
    1abe:	84 83       	std	Z+4, r24	; 0x04
#endif  
}
    1ac0:	08 95       	ret

00001ac2 <enableSpiMPC23S17>:
    1ac2:	e0 e8       	ldi	r30, 0x80	; 128
    1ac4:	f6 e0       	ldi	r31, 0x06	; 6
    1ac6:	84 81       	ldd	r24, Z+4	; 0x04
    1ac8:	8f 77       	andi	r24, 0x7F	; 127
    1aca:	84 83       	std	Z+4, r24	; 0x04
    1acc:	08 95       	ret

00001ace <disableSpiMPC23S17>:
    1ace:	e0 e8       	ldi	r30, 0x80	; 128
    1ad0:	f6 e0       	ldi	r31, 0x06	; 6
    1ad2:	84 81       	ldd	r24, Z+4	; 0x04
    1ad4:	80 68       	ori	r24, 0x80	; 128
    1ad6:	84 83       	std	Z+4, r24	; 0x04
    1ad8:	08 95       	ret

00001ada <enableSpiMCP3008>:
    1ada:	e0 ec       	ldi	r30, 0xC0	; 192
    1adc:	f9 e0       	ldi	r31, 0x09	; 9
    1ade:	80 81       	ld	r24, Z
    1ae0:	83 60       	ori	r24, 0x03	; 3
    1ae2:	80 83       	st	Z, r24
    1ae4:	e0 e8       	ldi	r30, 0x80	; 128
    1ae6:	f6 e0       	ldi	r31, 0x06	; 6
    1ae8:	84 81       	ldd	r24, Z+4	; 0x04
    1aea:	8f 7b       	andi	r24, 0xBF	; 191
    1aec:	84 83       	std	Z+4, r24	; 0x04
    1aee:	08 95       	ret

00001af0 <disableSpiMCP3008>:
    1af0:	e0 ec       	ldi	r30, 0xC0	; 192
    1af2:	f9 e0       	ldi	r31, 0x09	; 9
    1af4:	80 81       	ld	r24, Z
    1af6:	8c 7f       	andi	r24, 0xFC	; 252
    1af8:	80 83       	st	Z, r24
    1afa:	e0 e8       	ldi	r30, 0x80	; 128
    1afc:	f6 e0       	ldi	r31, 0x06	; 6
    1afe:	84 81       	ldd	r24, Z+4	; 0x04
    1b00:	80 64       	ori	r24, 0x40	; 64
    1b02:	84 83       	std	Z+4, r24	; 0x04
    1b04:	08 95       	ret

00001b06 <enableSpiMCP4150>:
    1b06:	e0 ec       	ldi	r30, 0xC0	; 192
    1b08:	f9 e0       	ldi	r31, 0x09	; 9
    1b0a:	80 81       	ld	r24, Z
    1b0c:	83 60       	ori	r24, 0x03	; 3
    1b0e:	80 83       	st	Z, r24
    1b10:	e0 e8       	ldi	r30, 0x80	; 128
    1b12:	f6 e0       	ldi	r31, 0x06	; 6
    1b14:	84 81       	ldd	r24, Z+4	; 0x04
    1b16:	8f 7b       	andi	r24, 0xBF	; 191
    1b18:	84 83       	std	Z+4, r24	; 0x04
    1b1a:	08 95       	ret

00001b1c <disableSpiMCP4150>:
    1b1c:	e0 ec       	ldi	r30, 0xC0	; 192
    1b1e:	f9 e0       	ldi	r31, 0x09	; 9
    1b20:	80 81       	ld	r24, Z
    1b22:	8c 7f       	andi	r24, 0xFC	; 252
    1b24:	80 83       	st	Z, r24
    1b26:	e0 e8       	ldi	r30, 0x80	; 128
    1b28:	f6 e0       	ldi	r31, 0x06	; 6
    1b2a:	84 81       	ldd	r24, Z+4	; 0x04
    1b2c:	80 64       	ori	r24, 0x40	; 64
    1b2e:	84 83       	std	Z+4, r24	; 0x04
    1b30:	08 95       	ret

00001b32 <spiEnableDS1305>:
    1b32:	e0 ec       	ldi	r30, 0xC0	; 192
    1b34:	f9 e0       	ldi	r31, 0x09	; 9
    1b36:	80 81       	ld	r24, Z
    1b38:	85 60       	ori	r24, 0x05	; 5
    1b3a:	80 83       	st	Z, r24
    1b3c:	e0 e8       	ldi	r30, 0x80	; 128
    1b3e:	f6 e0       	ldi	r31, 0x06	; 6
    1b40:	84 81       	ldd	r24, Z+4	; 0x04
    1b42:	80 62       	ori	r24, 0x20	; 32
    1b44:	84 83       	std	Z+4, r24	; 0x04
    1b46:	08 95       	ret

00001b48 <spiDisableDS1305>:
    1b48:	e0 ec       	ldi	r30, 0xC0	; 192
    1b4a:	f9 e0       	ldi	r31, 0x09	; 9
    1b4c:	80 81       	ld	r24, Z
    1b4e:	8a 7f       	andi	r24, 0xFA	; 250
    1b50:	80 83       	st	Z, r24
    1b52:	e0 e8       	ldi	r30, 0x80	; 128
    1b54:	f6 e0       	ldi	r31, 0x06	; 6
    1b56:	84 81       	ldd	r24, Z+4	; 0x04
    1b58:	8f 7d       	andi	r24, 0xDF	; 223
    1b5a:	84 83       	std	Z+4, r24	; 0x04
    1b5c:	08 95       	ret

00001b5e <SPI_STC_vect>:
  DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
#endif  
}

ISR(SPI_STC_vect)
{
    1b5e:	1f 92       	push	r1
    1b60:	0f 92       	push	r0
    1b62:	0f b6       	in	r0, 0x3f	; 63
    1b64:	0f 92       	push	r0
    1b66:	08 b6       	in	r0, 0x38	; 56
    1b68:	0f 92       	push	r0
    1b6a:	09 b6       	in	r0, 0x39	; 57
    1b6c:	0f 92       	push	r0
    1b6e:	0b b6       	in	r0, 0x3b	; 59
    1b70:	0f 92       	push	r0
    1b72:	11 24       	eor	r1, r1
    1b74:	18 be       	out	0x38, r1	; 56
    1b76:	19 be       	out	0x39, r1	; 57
    1b78:	1b be       	out	0x3b, r1	; 59
    1b7a:	2f 93       	push	r18
    1b7c:	3f 93       	push	r19
    1b7e:	4f 93       	push	r20
    1b80:	5f 93       	push	r21
    1b82:	6f 93       	push	r22
    1b84:	7f 93       	push	r23
    1b86:	8f 93       	push	r24
    1b88:	9f 93       	push	r25
    1b8a:	af 93       	push	r26
    1b8c:	bf 93       	push	r27
    1b8e:	ef 93       	push	r30
    1b90:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 

  static uint8_t data;
  data = SPID.DATA;//SPDR;
    1b92:	80 91 c3 09 	lds	r24, 0x09C3
    1b96:	80 93 50 25 	sts	0x2550, r24
  
  xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
    1b9a:	80 91 c2 32 	lds	r24, 0x32C2
    1b9e:	90 91 c3 32 	lds	r25, 0x32C3
    1ba2:	60 e5       	ldi	r22, 0x50	; 80
    1ba4:	75 e2       	ldi	r23, 0x25	; 37
    1ba6:	41 e5       	ldi	r20, 0x51	; 81
    1ba8:	55 e2       	ldi	r21, 0x25	; 37
    1baa:	20 e0       	ldi	r18, 0x00	; 0
    1bac:	0e 94 6c 4e 	call	0x9cd8	; 0x9cd8 <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    1bb0:	80 91 51 25 	lds	r24, 0x2551
    1bb4:	88 23       	and	r24, r24
    1bb6:	11 f0       	breq	.+4      	; 0x1bbc <SPI_STC_vect+0x5e>
  {
    taskYIELD();
    1bb8:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
  }
  
  //clear SPI interrupt SPI |= 1;
}
    1bbc:	ff 91       	pop	r31
    1bbe:	ef 91       	pop	r30
    1bc0:	bf 91       	pop	r27
    1bc2:	af 91       	pop	r26
    1bc4:	9f 91       	pop	r25
    1bc6:	8f 91       	pop	r24
    1bc8:	7f 91       	pop	r23
    1bca:	6f 91       	pop	r22
    1bcc:	5f 91       	pop	r21
    1bce:	4f 91       	pop	r20
    1bd0:	3f 91       	pop	r19
    1bd2:	2f 91       	pop	r18
    1bd4:	0f 90       	pop	r0
    1bd6:	0b be       	out	0x3b, r0	; 59
    1bd8:	0f 90       	pop	r0
    1bda:	09 be       	out	0x39, r0	; 57
    1bdc:	0f 90       	pop	r0
    1bde:	08 be       	out	0x38, r0	; 56
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	0f 90       	pop	r0
    1be6:	1f 90       	pop	r1
    1be8:	18 95       	reti

00001bea <sensorsTaskInit>:



void sensorsTaskInit(void)
{
  LockersMemInit();
    1bea:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <LockersMemInit>
  rollersMemInit();
    1bee:	0e 94 e0 3f 	call	0x7fc0	; 0x7fc0 <rollersMemInit>
}
    1bf2:	08 95       	ret

00001bf4 <sensorsTask>:

void sensorsTask(void* pvParameters)
{
    1bf4:	1f 93       	push	r17
    1bf6:	cf 93       	push	r28
    1bf8:	df 93       	push	r29
  pvParameters = NULL;
  uint8_t addr = 255;
//  uint8_t i;

  MPC23s17SetDirA(0x00, 0);
    1bfa:	80 e0       	ldi	r24, 0x00	; 0
    1bfc:	60 e0       	ldi	r22, 0x00	; 0
    1bfe:	0e 94 63 28 	call	0x50c6	; 0x50c6 <MPC23s17SetDirA>
  
  MPC23s17SetDirB(0x00, 0);
    1c02:	80 e0       	ldi	r24, 0x00	; 0
    1c04:	60 e0       	ldi	r22, 0x00	; 0
    1c06:	0e 94 85 28 	call	0x510a	; 0x510a <MPC23s17SetDirB>
    vTaskDelay(10);
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    tmp *=10;
    temperature = (uint8_t)(tmp / 24);
    1c0a:	c8 e1       	ldi	r28, 0x18	; 24
    1c0c:	d0 e0       	ldi	r29, 0x00	; 0

  for( ; ; )
  {
    uint16_t tmp;
    //Read power suply voltage
    tmp = MCP3008_getSampleSingle(0);
    1c0e:	80 e0       	ldi	r24, 0x00	; 0
    1c10:	0e 94 f5 29 	call	0x53ea	; 0x53ea <MCP3008_getSampleSingle>
    voltage = (uint8_t)(tmp>>5);
    1c14:	65 e0       	ldi	r22, 0x05	; 5
    1c16:	96 95       	lsr	r25
    1c18:	87 95       	ror	r24
    1c1a:	6a 95       	dec	r22
    1c1c:	e1 f7       	brne	.-8      	; 0x1c16 <sensorsTask+0x22>
    1c1e:	80 93 0c 32 	sts	0x320C, r24
    vTaskDelay(10);
    1c22:	8a e0       	ldi	r24, 0x0A	; 10
    1c24:	90 e0       	ldi	r25, 0x00	; 0
    1c26:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    1c2a:	81 e0       	ldi	r24, 0x01	; 1
    1c2c:	0e 94 f5 29 	call	0x53ea	; 0x53ea <MCP3008_getSampleSingle>
    tmp *=10;
    1c30:	9c 01       	movw	r18, r24
    1c32:	88 0f       	add	r24, r24
    1c34:	99 1f       	adc	r25, r25
    1c36:	43 e0       	ldi	r20, 0x03	; 3
    1c38:	22 0f       	add	r18, r18
    1c3a:	33 1f       	adc	r19, r19
    1c3c:	4a 95       	dec	r20
    1c3e:	e1 f7       	brne	.-8      	; 0x1c38 <sensorsTask+0x44>
    1c40:	82 0f       	add	r24, r18
    1c42:	93 1f       	adc	r25, r19
    temperature = (uint8_t)(tmp / 24);
    1c44:	be 01       	movw	r22, r28
    1c46:	0e 94 2a 54 	call	0xa854	; 0xa854 <__udivmodhi4>
    1c4a:	60 93 04 32 	sts	0x3204, r22
    vTaskDelay(10);
    1c4e:	8a e0       	ldi	r24, 0x0A	; 10
    1c50:	90 e0       	ldi	r25, 0x00	; 0
    1c52:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
      
    //read lock
    checkLockerSensors();
    1c56:	0e 94 11 0c 	call	0x1822	; 0x1822 <checkLockerSensors>

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1c5a:	11 e0       	ldi	r17, 0x01	; 1
    {
      rs485rollerHello(addr);
    1c5c:	81 2f       	mov	r24, r17
    1c5e:	0e 94 46 41 	call	0x828c	; 0x828c <rs485rollerHello>
      vTaskDelay(10);
    1c62:	8a e0       	ldi	r24, 0x0A	; 10
    1c64:	90 e0       	ldi	r25, 0x00	; 0
    1c66:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    vTaskDelay(10);
      
    //read lock
    checkLockerSensors();

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1c6a:	1f 5f       	subi	r17, 0xFF	; 255
    1c6c:	10 32       	cpi	r17, 0x20	; 32
    1c6e:	b1 f7       	brne	.-20     	; 0x1c5c <sensorsTask+0x68>
    1c70:	ce cf       	rjmp	.-100    	; 0x1c0e <sensorsTask+0x1a>

00001c72 <enableFunction>:
  state->err1 = 0;
  state->err2 = 0;
}

static cliExRes_t enableFunction(cmdState_t *state)
{
    1c72:	fc 01       	movw	r30, r24
  if (state->cliMode != RESTRICTED_NORMAL)
    1c74:	80 a1       	ldd	r24, Z+32	; 0x20
    1c76:	83 30       	cpi	r24, 0x03	; 3
    1c78:	49 f0       	breq	.+18     	; 0x1c8c <enableFunction+0x1a>
  {
    state->cmdList = cmdListEnable;
    1c7a:	8d e1       	ldi	r24, 0x1D	; 29
    1c7c:	94 e2       	ldi	r25, 0x24	; 36
    1c7e:	81 a3       	std	Z+33, r24	; 0x21
    1c80:	92 a3       	std	Z+34, r25	; 0x22
    state->cliMode = NR_ENABLE;
    1c82:	81 e0       	ldi	r24, 0x01	; 1
    1c84:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1c86:	20 e0       	ldi	r18, 0x00	; 0
    1c88:	30 e0       	ldi	r19, 0x00	; 0
    1c8a:	02 c0       	rjmp	.+4      	; 0x1c90 <enableFunction+0x1e>
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1c8c:	25 e0       	ldi	r18, 0x05	; 5
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
}
    1c90:	c9 01       	movw	r24, r18
    1c92:	08 95       	ret

00001c94 <disableFunction>:
static cliExRes_t disableFunction(cmdState_t *state)
{
    1c94:	fc 01       	movw	r30, r24
  state->cmdList = cmdListNormal;
    1c96:	88 e9       	ldi	r24, 0x98	; 152
    1c98:	96 e0       	ldi	r25, 0x06	; 6
    1c9a:	81 a3       	std	Z+33, r24	; 0x21
    1c9c:	92 a3       	std	Z+34, r25	; 0x22
  if (state->cliMode != RESTRICTED_NORMAL)
    1c9e:	80 a1       	ldd	r24, Z+32	; 0x20
    1ca0:	83 30       	cpi	r24, 0x03	; 3
    1ca2:	09 f0       	breq	.+2      	; 0x1ca6 <disableFunction+0x12>
  {
    state->cliMode = NR_NORMAL;
    1ca4:	10 a2       	std	Z+32, r1	; 0x20
  }
  return OK_SILENT;
}
    1ca6:	80 e0       	ldi	r24, 0x00	; 0
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	08 95       	ret

00001cac <configureModeFunction>:
static cliExRes_t configureModeFunction(cmdState_t *state)
{
    1cac:	fc 01       	movw	r30, r24
  if (state->cliMode == NR_ENABLE)
    1cae:	80 a1       	ldd	r24, Z+32	; 0x20
    1cb0:	81 30       	cpi	r24, 0x01	; 1
    1cb2:	49 f4       	brne	.+18     	; 0x1cc6 <configureModeFunction+0x1a>
  {
    state->cmdList = cmdListConfigure;
    1cb4:	8e ec       	ldi	r24, 0xCE	; 206
    1cb6:	96 e0       	ldi	r25, 0x06	; 6
    1cb8:	81 a3       	std	Z+33, r24	; 0x21
    1cba:	92 a3       	std	Z+34, r25	; 0x22
    state->cliMode = NR_CONFIGURE;
    1cbc:	82 e0       	ldi	r24, 0x02	; 2
    1cbe:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1cc0:	20 e0       	ldi	r18, 0x00	; 0
    1cc2:	30 e0       	ldi	r19, 0x00	; 0
    1cc4:	02 c0       	rjmp	.+4      	; 0x1cca <configureModeFunction+0x1e>
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1cc6:	25 e0       	ldi	r18, 0x05	; 5
    1cc8:	30 e0       	ldi	r19, 0x00	; 0
}
    1cca:	c9 01       	movw	r24, r18
    1ccc:	08 95       	ret

00001cce <saveConfigFunction>:
}

static cliExRes_t saveConfigFunction(cmdState_t *state)
{
  state = NULL;
  saveConfiguration();
    1cce:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <saveConfiguration>
  return OK_SILENT;
}
    1cd2:	80 e0       	ldi	r24, 0x00	; 0
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	08 95       	ret

00001cd8 <setMacAddrFunction>:
  ipSetConfigGw(gw);
  return OK_SILENT;
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
    1cd8:	cf 93       	push	r28
    1cda:	df 93       	push	r29
    1cdc:	ec 01       	movw	r28, r24
  if (state->argc < 6)
    1cde:	89 8d       	ldd	r24, Y+25	; 0x19
    1ce0:	86 30       	cpi	r24, 0x06	; 6
    1ce2:	58 f1       	brcs	.+86     	; 0x1d3a <setMacAddrFunction+0x62>
    return SYNTAX_ERROR;  
  
  nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
    1ce4:	81 e0       	ldi	r24, 0x01	; 1
    1ce6:	be 01       	movw	r22, r28
    1ce8:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <cmdlineGetArgHex>
    1cec:	60 93 de 31 	sts	0x31DE, r22
  nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
    1cf0:	82 e0       	ldi	r24, 0x02	; 2
    1cf2:	be 01       	movw	r22, r28
    1cf4:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <cmdlineGetArgHex>
    1cf8:	60 93 df 31 	sts	0x31DF, r22
  nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
    1cfc:	83 e0       	ldi	r24, 0x03	; 3
    1cfe:	be 01       	movw	r22, r28
    1d00:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <cmdlineGetArgHex>
    1d04:	60 93 e0 31 	sts	0x31E0, r22
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
    1d08:	84 e0       	ldi	r24, 0x04	; 4
    1d0a:	be 01       	movw	r22, r28
    1d0c:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <cmdlineGetArgHex>
    1d10:	60 93 e1 31 	sts	0x31E1, r22
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
    1d14:	85 e0       	ldi	r24, 0x05	; 5
    1d16:	be 01       	movw	r22, r28
    1d18:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <cmdlineGetArgHex>
    1d1c:	60 93 e2 31 	sts	0x31E2, r22
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
    1d20:	86 e0       	ldi	r24, 0x06	; 6
    1d22:	be 01       	movw	r22, r28
    1d24:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <cmdlineGetArgHex>
    1d28:	60 93 e3 31 	sts	0x31E3, r22
  nicSetMacAddress(nicState.mac.addr);
    1d2c:	8e ed       	ldi	r24, 0xDE	; 222
    1d2e:	91 e3       	ldi	r25, 0x31	; 49
    1d30:	0e 94 27 2c 	call	0x584e	; 0x584e <nicSetMacAddress>
  return OK_SILENT;
    1d34:	20 e0       	ldi	r18, 0x00	; 0
    1d36:	30 e0       	ldi	r19, 0x00	; 0
    1d38:	02 c0       	rjmp	.+4      	; 0x1d3e <setMacAddrFunction+0x66>
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
  if (state->argc < 6)
    return SYNTAX_ERROR;  
    1d3a:	22 e0       	ldi	r18, 0x02	; 2
    1d3c:	30 e0       	ldi	r19, 0x00	; 0
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}
    1d3e:	c9 01       	movw	r24, r18
    1d40:	df 91       	pop	r29
    1d42:	cf 91       	pop	r28
    1d44:	08 95       	ret

00001d46 <pingFunction>:
  printErrorInfo(state);
  return OK_SILENT;
}

static cliExRes_t pingFunction(cmdState_t *state)
{
    1d46:	cf 93       	push	r28
    1d48:	df 93       	push	r29
    1d4a:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1d4c:	89 8d       	ldd	r24, Y+25	; 0x19
    1d4e:	84 30       	cpi	r24, 0x04	; 4
    1d50:	98 f0       	brcs	.+38     	; 0x1d78 <pingFunction+0x32>
    return SYNTAX_ERROR;
  
  uint8_t ip[4];
  ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
    1d52:	81 e0       	ldi	r24, 0x01	; 1
    1d54:	be 01       	movw	r22, r28
    1d56:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
  ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
    1d5a:	82 e0       	ldi	r24, 0x02	; 2
    1d5c:	be 01       	movw	r22, r28
    1d5e:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
  ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
    1d62:	83 e0       	ldi	r24, 0x03	; 3
    1d64:	be 01       	movw	r22, r28
    1d66:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
    1d6a:	84 e0       	ldi	r24, 0x04	; 4
    1d6c:	be 01       	movw	r22, r28
    1d6e:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
    1d72:	20 e0       	ldi	r18, 0x00	; 0
    1d74:	30 e0       	ldi	r19, 0x00	; 0
    1d76:	02 c0       	rjmp	.+4      	; 0x1d7c <pingFunction+0x36>
}

static cliExRes_t pingFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    1d78:	22 e0       	ldi	r18, 0x02	; 2
    1d7a:	30 e0       	ldi	r19, 0x00	; 0
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
}
    1d7c:	c9 01       	movw	r24, r18
    1d7e:	df 91       	pop	r29
    1d80:	cf 91       	pop	r28
    1d82:	08 95       	ret

00001d84 <setUdpFunction>:
  ipSetConfigIp(ip);
  return OK_SILENT;
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
    1d84:	2f 92       	push	r2
    1d86:	3f 92       	push	r3
    1d88:	4f 92       	push	r4
    1d8a:	5f 92       	push	r5
    1d8c:	6f 92       	push	r6
    1d8e:	7f 92       	push	r7
    1d90:	8f 92       	push	r8
    1d92:	9f 92       	push	r9
    1d94:	af 92       	push	r10
    1d96:	bf 92       	push	r11
    1d98:	cf 92       	push	r12
    1d9a:	df 92       	push	r13
    1d9c:	ef 92       	push	r14
    1d9e:	ff 92       	push	r15
    1da0:	0f 93       	push	r16
    1da2:	1f 93       	push	r17
    1da4:	cf 93       	push	r28
    1da6:	df 93       	push	r29
    1da8:	ec 01       	movw	r28, r24
  if (state->argc < 5)
    1daa:	89 8d       	ldd	r24, Y+25	; 0x19
    1dac:	85 30       	cpi	r24, 0x05	; 5
    1dae:	08 f4       	brcc	.+2      	; 0x1db2 <setUdpFunction+0x2e>
    1db0:	58 c0       	rjmp	.+176    	; 0x1e62 <setUdpFunction+0xde>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	be 01       	movw	r22, r28
    1db6:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1dba:	1b 01       	movw	r2, r22
    1dbc:	2c 01       	movw	r4, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1dbe:	82 e0       	ldi	r24, 0x02	; 2
    1dc0:	be 01       	movw	r22, r28
    1dc2:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1dc6:	5b 01       	movw	r10, r22
    1dc8:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1dca:	83 e0       	ldi	r24, 0x03	; 3
    1dcc:	be 01       	movw	r22, r28
    1dce:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1dd2:	3b 01       	movw	r6, r22
    1dd4:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1dd6:	84 e0       	ldi	r24, 0x04	; 4
    1dd8:	be 01       	movw	r22, r28
    1dda:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1dde:	7b 01       	movw	r14, r22
    1de0:	8c 01       	movw	r16, r24
  udpSocket->dstIp = ip;
    1de2:	e0 91 02 32 	lds	r30, 0x3202
    1de6:	f0 91 03 32 	lds	r31, 0x3203
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1dea:	bc 2d       	mov	r27, r12
    1dec:	ab 2d       	mov	r26, r11
    1dee:	9a 2d       	mov	r25, r10
    1df0:	88 27       	eor	r24, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1df2:	a3 01       	movw	r20, r6
    1df4:	33 27       	eor	r19, r19
    1df6:	22 27       	eor	r18, r18
static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1df8:	82 0f       	add	r24, r18
    1dfa:	93 1f       	adc	r25, r19
    1dfc:	a4 1f       	adc	r26, r20
    1dfe:	b5 1f       	adc	r27, r21
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1e00:	82 0d       	add	r24, r2
    1e02:	93 1d       	adc	r25, r3
    1e04:	a4 1d       	adc	r26, r4
    1e06:	b5 1d       	adc	r27, r5
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1e08:	1e 2d       	mov	r17, r14
    1e0a:	00 27       	eor	r16, r16
    1e0c:	ff 24       	eor	r15, r15
    1e0e:	ee 24       	eor	r14, r14
static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1e10:	8e 0d       	add	r24, r14
    1e12:	9f 1d       	adc	r25, r15
    1e14:	a0 1f       	adc	r26, r16
    1e16:	b1 1f       	adc	r27, r17
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  udpSocket->dstIp = ip;
    1e18:	86 83       	std	Z+6, r24	; 0x06
    1e1a:	97 83       	std	Z+7, r25	; 0x07
    1e1c:	a0 87       	std	Z+8, r26	; 0x08
    1e1e:	b1 87       	std	Z+9, r27	; 0x09
  
  uint16_t port = cmdlineGetArgInt(5, state);
    1e20:	85 e0       	ldi	r24, 0x05	; 5
    1e22:	be 01       	movw	r22, r28
    1e24:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1e28:	dc 01       	movw	r26, r24
    1e2a:	cb 01       	movw	r24, r22
  udpSocket->srcPort = htons(port);
    1e2c:	e0 90 02 32 	lds	r14, 0x3202
    1e30:	f0 90 03 32 	lds	r15, 0x3203
    1e34:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    1e38:	f7 01       	movw	r30, r14
    1e3a:	84 83       	std	Z+4, r24	; 0x04
    1e3c:	95 83       	std	Z+5, r25	; 0x05
  
  if (state->argc > 5)
    1e3e:	89 8d       	ldd	r24, Y+25	; 0x19
    1e40:	86 30       	cpi	r24, 0x06	; 6
    1e42:	90 f0       	brcs	.+36     	; 0x1e68 <setUdpFunction+0xe4>
  {
    port = cmdlineGetArgInt(6, state);
    1e44:	86 e0       	ldi	r24, 0x06	; 6
    1e46:	be 01       	movw	r22, r28
    1e48:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1e4c:	dc 01       	movw	r26, r24
    1e4e:	cb 01       	movw	r24, r22
    udpSocket->dstPort = htons(port);    
    1e50:	c0 91 02 32 	lds	r28, 0x3202
    1e54:	d0 91 03 32 	lds	r29, 0x3203
    1e58:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    1e5c:	8a 83       	std	Y+2, r24	; 0x02
    1e5e:	9b 83       	std	Y+3, r25	; 0x03
    1e60:	03 c0       	rjmp	.+6      	; 0x1e68 <setUdpFunction+0xe4>
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
    1e62:	22 e0       	ldi	r18, 0x02	; 2
    1e64:	30 e0       	ldi	r19, 0x00	; 0
    1e66:	02 c0       	rjmp	.+4      	; 0x1e6c <setUdpFunction+0xe8>
  if (state->argc > 5)
  {
    port = cmdlineGetArgInt(6, state);
    udpSocket->dstPort = htons(port);    
  }
  return OK_SILENT;
    1e68:	20 e0       	ldi	r18, 0x00	; 0
    1e6a:	30 e0       	ldi	r19, 0x00	; 0
}
    1e6c:	c9 01       	movw	r24, r18
    1e6e:	df 91       	pop	r29
    1e70:	cf 91       	pop	r28
    1e72:	1f 91       	pop	r17
    1e74:	0f 91       	pop	r16
    1e76:	ff 90       	pop	r15
    1e78:	ef 90       	pop	r14
    1e7a:	df 90       	pop	r13
    1e7c:	cf 90       	pop	r12
    1e7e:	bf 90       	pop	r11
    1e80:	af 90       	pop	r10
    1e82:	9f 90       	pop	r9
    1e84:	8f 90       	pop	r8
    1e86:	7f 90       	pop	r7
    1e88:	6f 90       	pop	r6
    1e8a:	5f 90       	pop	r5
    1e8c:	4f 90       	pop	r4
    1e8e:	3f 90       	pop	r3
    1e90:	2f 90       	pop	r2
    1e92:	08 95       	ret

00001e94 <setIpGwFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
    1e94:	6f 92       	push	r6
    1e96:	7f 92       	push	r7
    1e98:	8f 92       	push	r8
    1e9a:	9f 92       	push	r9
    1e9c:	af 92       	push	r10
    1e9e:	bf 92       	push	r11
    1ea0:	cf 92       	push	r12
    1ea2:	df 92       	push	r13
    1ea4:	ef 92       	push	r14
    1ea6:	ff 92       	push	r15
    1ea8:	0f 93       	push	r16
    1eaa:	1f 93       	push	r17
    1eac:	cf 93       	push	r28
    1eae:	df 93       	push	r29
    1eb0:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1eb2:	89 8d       	ldd	r24, Y+25	; 0x19
    1eb4:	84 30       	cpi	r24, 0x04	; 4
    1eb6:	b0 f1       	brcs	.+108    	; 0x1f24 <setIpGwFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1eb8:	81 e0       	ldi	r24, 0x01	; 1
    1eba:	be 01       	movw	r22, r28
    1ebc:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1ec0:	3b 01       	movw	r6, r22
    1ec2:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1ec4:	82 e0       	ldi	r24, 0x02	; 2
    1ec6:	be 01       	movw	r22, r28
    1ec8:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1ecc:	7b 01       	movw	r14, r22
    1ece:	8c 01       	movw	r16, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    1ed0:	83 e0       	ldi	r24, 0x03	; 3
    1ed2:	be 01       	movw	r22, r28
    1ed4:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1ed8:	5b 01       	movw	r10, r22
    1eda:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1edc:	84 e0       	ldi	r24, 0x04	; 4
    1ede:	be 01       	movw	r22, r28
    1ee0:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1ee4:	dc 01       	movw	r26, r24
    1ee6:	cb 01       	movw	r24, r22
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1ee8:	10 2f       	mov	r17, r16
    1eea:	0f 2d       	mov	r16, r15
    1eec:	fe 2c       	mov	r15, r14
    1eee:	ee 24       	eor	r14, r14
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    1ef0:	65 01       	movw	r12, r10
    1ef2:	bb 24       	eor	r11, r11
    1ef4:	aa 24       	eor	r10, r10
static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1ef6:	ea 0c       	add	r14, r10
    1ef8:	fb 1c       	adc	r15, r11
    1efa:	0c 1d       	adc	r16, r12
    1efc:	1d 1d       	adc	r17, r13
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1efe:	e6 0c       	add	r14, r6
    1f00:	f7 1c       	adc	r15, r7
    1f02:	08 1d       	adc	r16, r8
    1f04:	19 1d       	adc	r17, r9
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1f06:	b8 2f       	mov	r27, r24
    1f08:	aa 27       	eor	r26, r26
    1f0a:	99 27       	eor	r25, r25
    1f0c:	88 27       	eor	r24, r24
static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1f0e:	e8 0e       	add	r14, r24
    1f10:	f9 1e       	adc	r15, r25
    1f12:	0a 1f       	adc	r16, r26
    1f14:	1b 1f       	adc	r17, r27
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  ipSetConfigGw(gw);
    1f16:	c8 01       	movw	r24, r16
    1f18:	b7 01       	movw	r22, r14
    1f1a:	0e 94 ef 32 	call	0x65de	; 0x65de <ipSetConfigGw>
  return OK_SILENT;
    1f1e:	20 e0       	ldi	r18, 0x00	; 0
    1f20:	30 e0       	ldi	r19, 0x00	; 0
    1f22:	02 c0       	rjmp	.+4      	; 0x1f28 <setIpGwFunction+0x94>


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    1f24:	22 e0       	ldi	r18, 0x02	; 2
    1f26:	30 e0       	ldi	r19, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  ipSetConfigGw(gw);
  return OK_SILENT;
}
    1f28:	c9 01       	movw	r24, r18
    1f2a:	df 91       	pop	r29
    1f2c:	cf 91       	pop	r28
    1f2e:	1f 91       	pop	r17
    1f30:	0f 91       	pop	r16
    1f32:	ff 90       	pop	r15
    1f34:	ef 90       	pop	r14
    1f36:	df 90       	pop	r13
    1f38:	cf 90       	pop	r12
    1f3a:	bf 90       	pop	r11
    1f3c:	af 90       	pop	r10
    1f3e:	9f 90       	pop	r9
    1f40:	8f 90       	pop	r8
    1f42:	7f 90       	pop	r7
    1f44:	6f 90       	pop	r6
    1f46:	08 95       	ret

00001f48 <setIpMaskFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
    1f48:	bc 01       	movw	r22, r24
  if (state->argc < 1)
    1f4a:	fc 01       	movw	r30, r24
    1f4c:	81 8d       	ldd	r24, Z+25	; 0x19
    1f4e:	88 23       	and	r24, r24
    1f50:	b1 f0       	breq	.+44     	; 0x1f7e <setIpMaskFunction+0x36>
    return SYNTAX_ERROR;
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
    1f52:	81 e0       	ldi	r24, 0x01	; 1
    1f54:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1f58:	20 e2       	ldi	r18, 0x20	; 32
    1f5a:	30 e0       	ldi	r19, 0x00	; 0
    1f5c:	26 1b       	sub	r18, r22
    1f5e:	37 0b       	sbc	r19, r23
    1f60:	6f ef       	ldi	r22, 0xFF	; 255
    1f62:	7f ef       	ldi	r23, 0xFF	; 255
    1f64:	cb 01       	movw	r24, r22
    1f66:	04 c0       	rjmp	.+8      	; 0x1f70 <setIpMaskFunction+0x28>
    1f68:	96 95       	lsr	r25
    1f6a:	87 95       	ror	r24
    1f6c:	77 95       	ror	r23
    1f6e:	67 95       	ror	r22
    1f70:	2a 95       	dec	r18
    1f72:	d2 f7       	brpl	.-12     	; 0x1f68 <setIpMaskFunction+0x20>
  
  ipSetConfigMask(mask);
    1f74:	0e 94 e6 32 	call	0x65cc	; 0x65cc <ipSetConfigMask>
  return OK_SILENT;
    1f78:	20 e0       	ldi	r18, 0x00	; 0
    1f7a:	30 e0       	ldi	r19, 0x00	; 0
    1f7c:	02 c0       	rjmp	.+4      	; 0x1f82 <setIpMaskFunction+0x3a>


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    1f7e:	22 e0       	ldi	r18, 0x02	; 2
    1f80:	30 e0       	ldi	r19, 0x00	; 0
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
  
  ipSetConfigMask(mask);
  return OK_SILENT;
}
    1f82:	c9 01       	movw	r24, r18
    1f84:	08 95       	ret

00001f86 <setIpFunction>:
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
  return OK_SILENT;
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
    1f86:	6f 92       	push	r6
    1f88:	7f 92       	push	r7
    1f8a:	8f 92       	push	r8
    1f8c:	9f 92       	push	r9
    1f8e:	af 92       	push	r10
    1f90:	bf 92       	push	r11
    1f92:	cf 92       	push	r12
    1f94:	df 92       	push	r13
    1f96:	ef 92       	push	r14
    1f98:	ff 92       	push	r15
    1f9a:	0f 93       	push	r16
    1f9c:	1f 93       	push	r17
    1f9e:	cf 93       	push	r28
    1fa0:	df 93       	push	r29
    1fa2:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1fa4:	89 8d       	ldd	r24, Y+25	; 0x19
    1fa6:	84 30       	cpi	r24, 0x04	; 4
    1fa8:	b0 f1       	brcs	.+108    	; 0x2016 <setIpFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1faa:	81 e0       	ldi	r24, 0x01	; 1
    1fac:	be 01       	movw	r22, r28
    1fae:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1fb2:	3b 01       	movw	r6, r22
    1fb4:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1fb6:	82 e0       	ldi	r24, 0x02	; 2
    1fb8:	be 01       	movw	r22, r28
    1fba:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1fbe:	7b 01       	movw	r14, r22
    1fc0:	8c 01       	movw	r16, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1fc2:	83 e0       	ldi	r24, 0x03	; 3
    1fc4:	be 01       	movw	r22, r28
    1fc6:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1fca:	5b 01       	movw	r10, r22
    1fcc:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1fce:	84 e0       	ldi	r24, 0x04	; 4
    1fd0:	be 01       	movw	r22, r28
    1fd2:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    1fd6:	dc 01       	movw	r26, r24
    1fd8:	cb 01       	movw	r24, r22
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1fda:	10 2f       	mov	r17, r16
    1fdc:	0f 2d       	mov	r16, r15
    1fde:	fe 2c       	mov	r15, r14
    1fe0:	ee 24       	eor	r14, r14
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1fe2:	65 01       	movw	r12, r10
    1fe4:	bb 24       	eor	r11, r11
    1fe6:	aa 24       	eor	r10, r10
static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1fe8:	ea 0c       	add	r14, r10
    1fea:	fb 1c       	adc	r15, r11
    1fec:	0c 1d       	adc	r16, r12
    1fee:	1d 1d       	adc	r17, r13
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1ff0:	e6 0c       	add	r14, r6
    1ff2:	f7 1c       	adc	r15, r7
    1ff4:	08 1d       	adc	r16, r8
    1ff6:	19 1d       	adc	r17, r9
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1ff8:	b8 2f       	mov	r27, r24
    1ffa:	aa 27       	eor	r26, r26
    1ffc:	99 27       	eor	r25, r25
    1ffe:	88 27       	eor	r24, r24
static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    2000:	e8 0e       	add	r14, r24
    2002:	f9 1e       	adc	r15, r25
    2004:	0a 1f       	adc	r16, r26
    2006:	1b 1f       	adc	r17, r27
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  
  ipSetConfigIp(ip);
    2008:	c8 01       	movw	r24, r16
    200a:	b7 01       	movw	r22, r14
    200c:	0e 94 dd 32 	call	0x65ba	; 0x65ba <ipSetConfigIp>
  return OK_SILENT;
    2010:	20 e0       	ldi	r18, 0x00	; 0
    2012:	30 e0       	ldi	r19, 0x00	; 0
    2014:	02 c0       	rjmp	.+4      	; 0x201a <setIpFunction+0x94>
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    2016:	22 e0       	ldi	r18, 0x02	; 2
    2018:	30 e0       	ldi	r19, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  
  ipSetConfigIp(ip);
  return OK_SILENT;
}
    201a:	c9 01       	movw	r24, r18
    201c:	df 91       	pop	r29
    201e:	cf 91       	pop	r28
    2020:	1f 91       	pop	r17
    2022:	0f 91       	pop	r16
    2024:	ff 90       	pop	r15
    2026:	ef 90       	pop	r14
    2028:	df 90       	pop	r13
    202a:	cf 90       	pop	r12
    202c:	bf 90       	pop	r11
    202e:	af 90       	pop	r10
    2030:	9f 90       	pop	r9
    2032:	8f 90       	pop	r8
    2034:	7f 90       	pop	r7
    2036:	6f 90       	pop	r6
    2038:	08 95       	ret

0000203a <czytajAC_Function>:
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}

static cliExRes_t czytajAC_Function(cmdState_t *state)
{
    203a:	0f 93       	push	r16
    203c:	1f 93       	push	r17
    203e:	df 93       	push	r29
    2040:	cf 93       	push	r28
    2042:	0f 92       	push	r0
    2044:	cd b7       	in	r28, 0x3d	; 61
    2046:	de b7       	in	r29, 0x3e	; 62
    2048:	8c 01       	movw	r16, r24
  uint8_t nrWejscia = cmdlineGetArgInt(1, state);
    204a:	81 e0       	ldi	r24, 0x01	; 1
    204c:	b8 01       	movw	r22, r16
    204e:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
  uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
    2052:	86 2f       	mov	r24, r22
    2054:	69 83       	std	Y+1, r22	; 0x01
    2056:	0e 94 f5 29 	call	0x53ea	; 0x53ea <MCP3008_getSampleSingle>
  fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
    205a:	2d b7       	in	r18, 0x3d	; 61
    205c:	3e b7       	in	r19, 0x3e	; 62
    205e:	28 50       	subi	r18, 0x08	; 8
    2060:	30 40       	sbci	r19, 0x00	; 0
    2062:	2d bf       	out	0x3d, r18	; 61
    2064:	3e bf       	out	0x3e, r19	; 62
    2066:	ed b7       	in	r30, 0x3d	; 61
    2068:	fe b7       	in	r31, 0x3e	; 62
    206a:	31 96       	adiw	r30, 0x01	; 1
    206c:	d8 01       	movw	r26, r16
    206e:	5a 96       	adiw	r26, 0x1a	; 26
    2070:	2d 91       	ld	r18, X+
    2072:	3c 91       	ld	r19, X
    2074:	5b 97       	sbiw	r26, 0x1b	; 27
    2076:	ad b7       	in	r26, 0x3d	; 61
    2078:	be b7       	in	r27, 0x3e	; 62
    207a:	11 96       	adiw	r26, 0x01	; 1
    207c:	2d 93       	st	X+, r18
    207e:	3c 93       	st	X, r19
    2080:	12 97       	sbiw	r26, 0x02	; 2
    2082:	2c e1       	ldi	r18, 0x1C	; 28
    2084:	37 e0       	ldi	r19, 0x07	; 7
    2086:	22 83       	std	Z+2, r18	; 0x02
    2088:	33 83       	std	Z+3, r19	; 0x03
    208a:	69 81       	ldd	r22, Y+1	; 0x01
    208c:	64 83       	std	Z+4, r22	; 0x04
    208e:	15 82       	std	Z+5, r1	; 0x05
    2090:	86 83       	std	Z+6, r24	; 0x06
    2092:	97 83       	std	Z+7, r25	; 0x07
    2094:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    2098:	ed b7       	in	r30, 0x3d	; 61
    209a:	fe b7       	in	r31, 0x3e	; 62
    209c:	38 96       	adiw	r30, 0x08	; 8
    209e:	ed bf       	out	0x3d, r30	; 61
    20a0:	fe bf       	out	0x3e, r31	; 62
  return OK_SILENT;
}
    20a2:	80 e0       	ldi	r24, 0x00	; 0
    20a4:	90 e0       	ldi	r25, 0x00	; 0
    20a6:	0f 90       	pop	r0
    20a8:	cf 91       	pop	r28
    20aa:	df 91       	pop	r29
    20ac:	1f 91       	pop	r17
    20ae:	0f 91       	pop	r16
    20b0:	08 95       	ret

000020b2 <setTimeFunction>:
  return SYNTAX_ERROR;
}


static cliExRes_t setTimeFunction(cmdState_t *state)
{
    20b2:	ff 92       	push	r15
    20b4:	0f 93       	push	r16
    20b6:	1f 93       	push	r17
    20b8:	cf 93       	push	r28
    20ba:	df 93       	push	r29
    20bc:	ec 01       	movw	r28, r24
  uint8_t godzina =  cmdlineGetArgInt(1, state);
    20be:	81 e0       	ldi	r24, 0x01	; 1
    20c0:	be 01       	movw	r22, r28
    20c2:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    20c6:	f6 2e       	mov	r15, r22
  uint8_t minuta  =  cmdlineGetArgInt(2, state);
    20c8:	82 e0       	ldi	r24, 0x02	; 2
    20ca:	be 01       	movw	r22, r28
    20cc:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    20d0:	06 2f       	mov	r16, r22
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
    20d2:	83 e0       	ldi	r24, 0x03	; 3
    20d4:	be 01       	movw	r22, r28
    20d6:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    20da:	16 2f       	mov	r17, r22
  
  ds1305start();
    20dc:	0e 94 e7 27 	call	0x4fce	; 0x4fce <ds1305start>

  uint8_t cDzies = godzina/10;
    20e0:	5a e0       	ldi	r21, 0x0A	; 10
    20e2:	8f 2d       	mov	r24, r15
    20e4:	65 2f       	mov	r22, r21
    20e6:	0e 94 1e 54 	call	0xa83c	; 0xa83c <__udivmodqi4>
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
    20ea:	48 2f       	mov	r20, r24
    20ec:	43 70       	andi	r20, 0x03	; 3
    20ee:	27 e1       	ldi	r18, 0x17	; 23
    20f0:	32 e3       	ldi	r19, 0x32	; 50
    20f2:	42 95       	swap	r20
    20f4:	40 7f       	andi	r20, 0xF0	; 240
    20f6:	90 91 17 32 	lds	r25, 0x3217
    20fa:	9f 7c       	andi	r25, 0xCF	; 207
    20fc:	94 2b       	or	r25, r20
    20fe:	90 93 17 32 	sts	0x3217, r25
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
  
  ds1305start();

  uint8_t cDzies = godzina/10;
  uint8_t cJedn = godzina - cDzies*10;
    2102:	46 ef       	ldi	r20, 0xF6	; 246
    2104:	84 9f       	mul	r24, r20
    2106:	80 2d       	mov	r24, r0
    2108:	11 24       	eor	r1, r1
    210a:	8f 0d       	add	r24, r15
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;
    210c:	8f 70       	andi	r24, 0x0F	; 15
    210e:	90 91 17 32 	lds	r25, 0x3217
    2112:	90 7f       	andi	r25, 0xF0	; 240
    2114:	98 2b       	or	r25, r24
    2116:	90 93 17 32 	sts	0x3217, r25
  
  cDzies = minuta/10;
    211a:	80 2f       	mov	r24, r16
    211c:	0e 94 1e 54 	call	0xa83c	; 0xa83c <__udivmodqi4>
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
    2120:	68 2f       	mov	r22, r24
    2122:	67 70       	andi	r22, 0x07	; 7
    2124:	f9 01       	movw	r30, r18
    2126:	62 95       	swap	r22
    2128:	60 7f       	andi	r22, 0xF0	; 240
    212a:	92 91       	ld	r25, -Z
    212c:	9f 78       	andi	r25, 0x8F	; 143
    212e:	96 2b       	or	r25, r22
    2130:	90 83       	st	Z, r25
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;
  
  cDzies = minuta/10;
  cJedn = minuta - cDzies * 10;
    2132:	84 9f       	mul	r24, r20
    2134:	80 2d       	mov	r24, r0
    2136:	11 24       	eor	r1, r1
    2138:	80 0f       	add	r24, r16
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;
    213a:	8f 70       	andi	r24, 0x0F	; 15
    213c:	90 81       	ld	r25, Z
    213e:	90 7f       	andi	r25, 0xF0	; 240
    2140:	98 2b       	or	r25, r24
    2142:	90 83       	st	Z, r25
  
  cDzies = sekunda/10;
    2144:	81 2f       	mov	r24, r17
    2146:	65 2f       	mov	r22, r21
    2148:	0e 94 1e 54 	call	0xa83c	; 0xa83c <__udivmodqi4>
  cJedn  = sekunda - cDzies * 10;
  czasRtc.seconds.cDzies = cDzies;
    214c:	58 2f       	mov	r21, r24
    214e:	57 70       	andi	r21, 0x07	; 7
    2150:	f9 01       	movw	r30, r18
    2152:	32 97       	sbiw	r30, 0x02	; 2
    2154:	52 95       	swap	r21
    2156:	50 7f       	andi	r21, 0xF0	; 240
    2158:	90 81       	ld	r25, Z
    215a:	9f 78       	andi	r25, 0x8F	; 143
    215c:	95 2b       	or	r25, r21
    215e:	90 83       	st	Z, r25
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;
  
  cDzies = sekunda/10;
  cJedn  = sekunda - cDzies * 10;
    2160:	84 9f       	mul	r24, r20
    2162:	40 2d       	mov	r20, r0
    2164:	11 24       	eor	r1, r1
    2166:	41 0f       	add	r20, r17
  czasRtc.seconds.cDzies = cDzies;
  czasRtc.seconds.cJedn  = cJedn;
    2168:	4f 70       	andi	r20, 0x0F	; 15
    216a:	90 81       	ld	r25, Z
    216c:	90 7f       	andi	r25, 0xF0	; 240
    216e:	94 2b       	or	r25, r20
    2170:	90 83       	st	Z, r25
  
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
    2172:	cf 01       	movw	r24, r30
    2174:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <setTimeDecoded>
  return OK_SILENT;
}
    2178:	80 e0       	ldi	r24, 0x00	; 0
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	df 91       	pop	r29
    217e:	cf 91       	pop	r28
    2180:	1f 91       	pop	r17
    2182:	0f 91       	pop	r16
    2184:	ff 90       	pop	r15
    2186:	08 95       	ret

00002188 <ustawPortRezystor>:
  MPC23s17SetPortB(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
    2188:	bc 01       	movw	r22, r24
  if (state->argc < 1)
    218a:	fc 01       	movw	r30, r24
    218c:	81 8d       	ldd	r24, Z+25	; 0x19
    218e:	88 23       	and	r24, r24
    2190:	49 f0       	breq	.+18     	; 0x21a4 <ustawPortRezystor+0x1c>
    return SYNTAX_ERROR;

  uint8_t wartosc = cmdlineGetArgInt(1, state);
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    2198:	86 2f       	mov	r24, r22
  
  MCP4150_setValue(wartosc);
    219a:	0e 94 22 2a 	call	0x5444	; 0x5444 <MCP4150_setValue>
  
  return OK_SILENT;
    219e:	20 e0       	ldi	r18, 0x00	; 0
    21a0:	30 e0       	ldi	r19, 0x00	; 0
    21a2:	02 c0       	rjmp	.+4      	; 0x21a8 <ustawPortRezystor+0x20>
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    21a4:	22 e0       	ldi	r18, 0x02	; 2
    21a6:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t wartosc = cmdlineGetArgInt(1, state);
  
  MCP4150_setValue(wartosc);
  
  return OK_SILENT;
}
    21a8:	c9 01       	movw	r24, r18
    21aa:	08 95       	ret

000021ac <ustawPortExtBFunction>:
  MPC23s17SetPortA(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
{
    21ac:	1f 93       	push	r17
    21ae:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    21b0:	81 e0       	ldi	r24, 0x01	; 1
    21b2:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    21b6:	16 2f       	mov	r17, r22
  MPC23s17SetDirB(0x00, 0);
    21b8:	80 e0       	ldi	r24, 0x00	; 0
    21ba:	60 e0       	ldi	r22, 0x00	; 0
    21bc:	0e 94 85 28 	call	0x510a	; 0x510a <MPC23s17SetDirB>
  MPC23s17SetPortB(wyjscie, 0);
    21c0:	81 2f       	mov	r24, r17
    21c2:	60 e0       	ldi	r22, 0x00	; 0
    21c4:	0e 94 17 29 	call	0x522e	; 0x522e <MPC23s17SetPortB>
  return OK_SILENT;
}
    21c8:	80 e0       	ldi	r24, 0x00	; 0
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	1f 91       	pop	r17
    21ce:	08 95       	ret

000021d0 <ustawPortExtAFunction>:
  
  return ERROR_SILENT;
}

static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
{
    21d0:	1f 93       	push	r17
    21d2:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    21da:	16 2f       	mov	r17, r22
  MPC23s17SetDirA(0x00, 0);
    21dc:	80 e0       	ldi	r24, 0x00	; 0
    21de:	60 e0       	ldi	r22, 0x00	; 0
    21e0:	0e 94 63 28 	call	0x50c6	; 0x50c6 <MPC23s17SetDirA>
  MPC23s17SetPortA(wyjscie, 0);
    21e4:	81 2f       	mov	r24, r17
    21e6:	60 e0       	ldi	r22, 0x00	; 0
    21e8:	0e 94 a7 28 	call	0x514e	; 0x514e <MPC23s17SetPortA>
  return OK_SILENT;
}
    21ec:	80 e0       	ldi	r24, 0x00	; 0
    21ee:	90 e0       	ldi	r25, 0x00	; 0
    21f0:	1f 91       	pop	r17
    21f2:	08 95       	ret

000021f4 <curtainDownFunction>:
  cmdPrintHelp(state);
  return OK_SILENT;
}

static cliExRes_t curtainDownFunction(cmdState_t *state)
{
    21f4:	ff 92       	push	r15
    21f6:	0f 93       	push	r16
    21f8:	1f 93       	push	r17
    21fa:	cf 93       	push	r28
    21fc:	df 93       	push	r29
    21fe:	ec 01       	movw	r28, r24
  uint8_t nrRolety;
  uint8_t nrSterownika;
  uint8_t wartosc;
  
  nrSterownika = cmdlineGetArgInt(1, state);
    2200:	81 e0       	ldi	r24, 0x01	; 1
    2202:	be 01       	movw	r22, r28
    2204:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    2208:	06 2f       	mov	r16, r22
  nrRolety = cmdlineGetArgInt(2, state);
    220a:	82 e0       	ldi	r24, 0x02	; 2
    220c:	be 01       	movw	r22, r28
    220e:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    2212:	16 2f       	mov	r17, r22
  nrRolety &= 0x01;
    2214:	11 70       	andi	r17, 0x01	; 1
  wartosc = cmdlineGetArgInt(3, state);
    2216:	83 e0       	ldi	r24, 0x03	; 3
    2218:	be 01       	movw	r22, r28
    221a:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    221e:	f6 2e       	mov	r15, r22

  fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
    2220:	2d b7       	in	r18, 0x3d	; 61
    2222:	3e b7       	in	r19, 0x3e	; 62
    2224:	28 50       	subi	r18, 0x08	; 8
    2226:	30 40       	sbci	r19, 0x00	; 0
    2228:	2d bf       	out	0x3d, r18	; 61
    222a:	3e bf       	out	0x3e, r19	; 62
    222c:	ed b7       	in	r30, 0x3d	; 61
    222e:	fe b7       	in	r31, 0x3e	; 62
    2230:	31 96       	adiw	r30, 0x01	; 1
    2232:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2234:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2236:	ad b7       	in	r26, 0x3d	; 61
    2238:	be b7       	in	r27, 0x3e	; 62
    223a:	11 96       	adiw	r26, 0x01	; 1
    223c:	8d 93       	st	X+, r24
    223e:	9c 93       	st	X, r25
    2240:	12 97       	sbiw	r26, 0x02	; 2
    2242:	8a e3       	ldi	r24, 0x3A	; 58
    2244:	95 e0       	ldi	r25, 0x05	; 5
    2246:	82 83       	std	Z+2, r24	; 0x02
    2248:	93 83       	std	Z+3, r25	; 0x03
    224a:	04 83       	std	Z+4, r16	; 0x04
    224c:	15 82       	std	Z+5, r1	; 0x05
    224e:	21 2f       	mov	r18, r17
    2250:	30 e0       	ldi	r19, 0x00	; 0
    2252:	2f 5f       	subi	r18, 0xFF	; 255
    2254:	3f 4f       	sbci	r19, 0xFF	; 255
    2256:	26 83       	std	Z+6, r18	; 0x06
    2258:	37 83       	std	Z+7, r19	; 0x07
    225a:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>

  if ((wartosc > 0) && (wartosc <=100))
    225e:	8f 2d       	mov	r24, r15
    2260:	81 50       	subi	r24, 0x01	; 1
    2262:	2d b7       	in	r18, 0x3d	; 61
    2264:	3e b7       	in	r19, 0x3e	; 62
    2266:	28 5f       	subi	r18, 0xF8	; 248
    2268:	3f 4f       	sbci	r19, 0xFF	; 255
    226a:	2d bf       	out	0x3d, r18	; 61
    226c:	3e bf       	out	0x3e, r19	; 62
    226e:	84 36       	cpi	r24, 0x64	; 100
    2270:	d8 f4       	brcc	.+54     	; 0x22a8 <curtainDownFunction+0xb4>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    2272:	00 d0       	rcall	.+0      	; 0x2274 <curtainDownFunction+0x80>
    2274:	00 d0       	rcall	.+0      	; 0x2276 <curtainDownFunction+0x82>
    2276:	ed b7       	in	r30, 0x3d	; 61
    2278:	fe b7       	in	r31, 0x3e	; 62
    227a:	31 96       	adiw	r30, 0x01	; 1
    227c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    227e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2280:	ad b7       	in	r26, 0x3d	; 61
    2282:	be b7       	in	r27, 0x3e	; 62
    2284:	11 96       	adiw	r26, 0x01	; 1
    2286:	8d 93       	st	X+, r24
    2288:	9c 93       	st	X, r25
    228a:	12 97       	sbiw	r26, 0x02	; 2
    228c:	2d e6       	ldi	r18, 0x6D	; 109
    228e:	35 e0       	ldi	r19, 0x05	; 5
    2290:	22 83       	std	Z+2, r18	; 0x02
    2292:	33 83       	std	Z+3, r19	; 0x03
    2294:	f4 82       	std	Z+4, r15	; 0x04
    2296:	15 82       	std	Z+5, r1	; 0x05
    2298:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    229c:	2d b7       	in	r18, 0x3d	; 61
    229e:	3e b7       	in	r19, 0x3e	; 62
    22a0:	2a 5f       	subi	r18, 0xFA	; 250
    22a2:	3f 4f       	sbci	r19, 0xFF	; 255
    22a4:	2d bf       	out	0x3d, r18	; 61
    22a6:	3e bf       	out	0x3e, r19	; 62

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
    22a8:	80 2f       	mov	r24, r16
    22aa:	61 2f       	mov	r22, r17
    22ac:	4f 2d       	mov	r20, r15
    22ae:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <rs485curtainDown>
  
  if (result == 0)
    22b2:	88 23       	and	r24, r24
    22b4:	19 f4       	brne	.+6      	; 0x22bc <curtainDownFunction+0xc8>
    return OK_INFORM;
    22b6:	21 e0       	ldi	r18, 0x01	; 1
    22b8:	30 e0       	ldi	r19, 0x00	; 0
    22ba:	02 c0       	rjmp	.+4      	; 0x22c0 <curtainDownFunction+0xcc>
  
  return ERROR_SILENT;
    22bc:	23 e0       	ldi	r18, 0x03	; 3
    22be:	30 e0       	ldi	r19, 0x00	; 0
}
    22c0:	c9 01       	movw	r24, r18
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	ff 90       	pop	r15
    22cc:	08 95       	ret

000022ce <curtainUpFunction>:

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
    22ce:	ff 92       	push	r15
    22d0:	0f 93       	push	r16
    22d2:	1f 93       	push	r17
    22d4:	cf 93       	push	r28
    22d6:	df 93       	push	r29
    22d8:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    22da:	89 8d       	ldd	r24, Y+25	; 0x19
    22dc:	82 30       	cpi	r24, 0x02	; 2
    22de:	08 f4       	brcc	.+2      	; 0x22e2 <curtainUpFunction+0x14>
    22e0:	65 c0       	rjmp	.+202    	; 0x23ac <curtainUpFunction+0xde>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	be 01       	movw	r22, r28
    22e6:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    22ea:	06 2f       	mov	r16, r22
    22ec:	0f 73       	andi	r16, 0x3F	; 63
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
    22ee:	82 e0       	ldi	r24, 0x02	; 2
    22f0:	be 01       	movw	r22, r28
    22f2:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    22f6:	16 2f       	mov	r17, r22
    22f8:	11 70       	andi	r17, 0x01	; 1
  uint8_t wartosc = 255;
  if (state->argc > 2)
    22fa:	89 8d       	ldd	r24, Y+25	; 0x19
    22fc:	83 30       	cpi	r24, 0x03	; 3
    22fe:	30 f0       	brcs	.+12     	; 0x230c <curtainUpFunction+0x3e>
    wartosc = cmdlineGetArgInt(3, state);
    2300:	83 e0       	ldi	r24, 0x03	; 3
    2302:	be 01       	movw	r22, r28
    2304:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    2308:	f6 2e       	mov	r15, r22
    230a:	02 c0       	rjmp	.+4      	; 0x2310 <curtainUpFunction+0x42>
  if (state->argc < 2)
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
  uint8_t wartosc = 255;
    230c:	ff 24       	eor	r15, r15
    230e:	fa 94       	dec	r15
  if (state->argc > 2)
    wartosc = cmdlineGetArgInt(3, state);

  fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
    2310:	2d b7       	in	r18, 0x3d	; 61
    2312:	3e b7       	in	r19, 0x3e	; 62
    2314:	28 50       	subi	r18, 0x08	; 8
    2316:	30 40       	sbci	r19, 0x00	; 0
    2318:	2d bf       	out	0x3d, r18	; 61
    231a:	3e bf       	out	0x3e, r19	; 62
    231c:	ed b7       	in	r30, 0x3d	; 61
    231e:	fe b7       	in	r31, 0x3e	; 62
    2320:	31 96       	adiw	r30, 0x01	; 1
    2322:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2324:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2326:	ad b7       	in	r26, 0x3d	; 61
    2328:	be b7       	in	r27, 0x3e	; 62
    232a:	11 96       	adiw	r26, 0x01	; 1
    232c:	8d 93       	st	X+, r24
    232e:	9c 93       	st	X, r25
    2330:	12 97       	sbiw	r26, 0x02	; 2
    2332:	87 e0       	ldi	r24, 0x07	; 7
    2334:	95 e0       	ldi	r25, 0x05	; 5
    2336:	82 83       	std	Z+2, r24	; 0x02
    2338:	93 83       	std	Z+3, r25	; 0x03
    233a:	04 83       	std	Z+4, r16	; 0x04
    233c:	15 82       	std	Z+5, r1	; 0x05
    233e:	21 2f       	mov	r18, r17
    2340:	30 e0       	ldi	r19, 0x00	; 0
    2342:	2f 5f       	subi	r18, 0xFF	; 255
    2344:	3f 4f       	sbci	r19, 0xFF	; 255
    2346:	26 83       	std	Z+6, r18	; 0x06
    2348:	37 83       	std	Z+7, r19	; 0x07
    234a:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  if ((wartosc > 0) && (wartosc <=100))
    234e:	8f 2d       	mov	r24, r15
    2350:	81 50       	subi	r24, 0x01	; 1
    2352:	2d b7       	in	r18, 0x3d	; 61
    2354:	3e b7       	in	r19, 0x3e	; 62
    2356:	28 5f       	subi	r18, 0xF8	; 248
    2358:	3f 4f       	sbci	r19, 0xFF	; 255
    235a:	2d bf       	out	0x3d, r18	; 61
    235c:	3e bf       	out	0x3e, r19	; 62
    235e:	84 36       	cpi	r24, 0x64	; 100
    2360:	d8 f4       	brcc	.+54     	; 0x2398 <curtainUpFunction+0xca>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    2362:	00 d0       	rcall	.+0      	; 0x2364 <curtainUpFunction+0x96>
    2364:	00 d0       	rcall	.+0      	; 0x2366 <curtainUpFunction+0x98>
    2366:	ed b7       	in	r30, 0x3d	; 61
    2368:	fe b7       	in	r31, 0x3e	; 62
    236a:	31 96       	adiw	r30, 0x01	; 1
    236c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    236e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2370:	ad b7       	in	r26, 0x3d	; 61
    2372:	be b7       	in	r27, 0x3e	; 62
    2374:	11 96       	adiw	r26, 0x01	; 1
    2376:	8d 93       	st	X+, r24
    2378:	9c 93       	st	X, r25
    237a:	12 97       	sbiw	r26, 0x02	; 2
    237c:	2d e6       	ldi	r18, 0x6D	; 109
    237e:	35 e0       	ldi	r19, 0x05	; 5
    2380:	22 83       	std	Z+2, r18	; 0x02
    2382:	33 83       	std	Z+3, r19	; 0x03
    2384:	f4 82       	std	Z+4, r15	; 0x04
    2386:	15 82       	std	Z+5, r1	; 0x05
    2388:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    238c:	2d b7       	in	r18, 0x3d	; 61
    238e:	3e b7       	in	r19, 0x3e	; 62
    2390:	2a 5f       	subi	r18, 0xFA	; 250
    2392:	3f 4f       	sbci	r19, 0xFF	; 255
    2394:	2d bf       	out	0x3d, r18	; 61
    2396:	3e bf       	out	0x3e, r19	; 62

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
    2398:	80 2f       	mov	r24, r16
    239a:	61 2f       	mov	r22, r17
    239c:	4f 2d       	mov	r20, r15
    239e:	0e 94 b7 44 	call	0x896e	; 0x896e <rs485curtainUp>
  
  if (result == 0)
    23a2:	88 23       	and	r24, r24
    23a4:	31 f4       	brne	.+12     	; 0x23b2 <curtainUpFunction+0xe4>
    return OK_INFORM;
    23a6:	21 e0       	ldi	r18, 0x01	; 1
    23a8:	30 e0       	ldi	r19, 0x00	; 0
    23aa:	05 c0       	rjmp	.+10     	; 0x23b6 <curtainUpFunction+0xe8>
}

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
  if (state->argc < 2)
    return SYNTAX_ERROR;
    23ac:	22 e0       	ldi	r18, 0x02	; 2
    23ae:	30 e0       	ldi	r19, 0x00	; 0
    23b0:	02 c0       	rjmp	.+4      	; 0x23b6 <curtainUpFunction+0xe8>
  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
  
  if (result == 0)
    return OK_INFORM;
  
  return ERROR_SILENT;
    23b2:	23 e0       	ldi	r18, 0x03	; 3
    23b4:	30 e0       	ldi	r19, 0x00	; 0
}
    23b6:	c9 01       	movw	r24, r18
    23b8:	df 91       	pop	r29
    23ba:	cf 91       	pop	r28
    23bc:	1f 91       	pop	r17
    23be:	0f 91       	pop	r16
    23c0:	ff 90       	pop	r15
    23c2:	08 95       	ret

000023c4 <goXmodemWyslijFunction>:

  return OK_SILENT;
}

static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
{
    23c4:	0f 93       	push	r16
    23c6:	1f 93       	push	r17
    23c8:	cf 93       	push	r28
    23ca:	df 93       	push	r29
    23cc:	ec 01       	movw	r28, r24
  fprintf_P(state->myStdInOut, xwyslijStartStr);
    23ce:	00 d0       	rcall	.+0      	; 0x23d0 <goXmodemWyslijFunction+0xc>
    23d0:	0f 92       	push	r0
    23d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23d4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    23d6:	ad b7       	in	r26, 0x3d	; 61
    23d8:	be b7       	in	r27, 0x3e	; 62
    23da:	11 96       	adiw	r26, 0x01	; 1
    23dc:	8d 93       	st	X+, r24
    23de:	9c 93       	st	X, r25
    23e0:	12 97       	sbiw	r26, 0x02	; 2
    23e2:	8a ee       	ldi	r24, 0xEA	; 234
    23e4:	94 e0       	ldi	r25, 0x04	; 4
    23e6:	13 96       	adiw	r26, 0x03	; 3
    23e8:	8d 93       	st	X+, r24
    23ea:	9c 93       	st	X, r25
    23ec:	14 97       	sbiw	r26, 0x04	; 4
    23ee:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    23f2:	0f 90       	pop	r0
    23f4:	0f 90       	pop	r0
    23f6:	0f 90       	pop	r0
    23f8:	0f 90       	pop	r0
    23fa:	81 e0       	ldi	r24, 0x01	; 1
    23fc:	be 01       	movw	r22, r28
    23fe:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    2402:	64 ec       	ldi	r22, 0xC4	; 196
    2404:	72 e3       	ldi	r23, 0x32	; 50
    2406:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <ramDyskOtworzPlik>
    240a:	88 23       	and	r24, r24
    240c:	09 f1       	breq	.+66     	; 0x2450 <goXmodemWyslijFunction+0x8c>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    240e:	0a 8d       	ldd	r16, Y+26	; 0x1a
    2410:	1b 8d       	ldd	r17, Y+27	; 0x1b
    2412:	81 e0       	ldi	r24, 0x01	; 1
    2414:	be 01       	movw	r22, r28
    2416:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    241a:	00 d0       	rcall	.+0      	; 0x241c <goXmodemWyslijFunction+0x58>
    241c:	00 d0       	rcall	.+0      	; 0x241e <goXmodemWyslijFunction+0x5a>
    241e:	ed b7       	in	r30, 0x3d	; 61
    2420:	fe b7       	in	r31, 0x3e	; 62
    2422:	31 96       	adiw	r30, 0x01	; 1
    2424:	ad b7       	in	r26, 0x3d	; 61
    2426:	be b7       	in	r27, 0x3e	; 62
    2428:	11 96       	adiw	r26, 0x01	; 1
    242a:	0d 93       	st	X+, r16
    242c:	1c 93       	st	X, r17
    242e:	12 97       	sbiw	r26, 0x02	; 2
    2430:	2a ee       	ldi	r18, 0xEA	; 234
    2432:	32 e0       	ldi	r19, 0x02	; 2
    2434:	22 83       	std	Z+2, r18	; 0x02
    2436:	33 83       	std	Z+3, r19	; 0x03
    2438:	84 83       	std	Z+4, r24	; 0x04
    243a:	95 83       	std	Z+5, r25	; 0x05
    243c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    return ERROR_INFORM;
    2440:	ed b7       	in	r30, 0x3d	; 61
    2442:	fe b7       	in	r31, 0x3e	; 62
    2444:	36 96       	adiw	r30, 0x06	; 6
    2446:	ed bf       	out	0x3d, r30	; 61
    2448:	fe bf       	out	0x3e, r31	; 62
    244a:	24 e0       	ldi	r18, 0x04	; 4
    244c:	30 e0       	ldi	r19, 0x00	; 0
    244e:	02 c0       	rjmp	.+4      	; 0x2454 <goXmodemWyslijFunction+0x90>
  }
  return OK_SILENT;
    2450:	20 e0       	ldi	r18, 0x00	; 0
    2452:	30 e0       	ldi	r19, 0x00	; 0
}
    2454:	c9 01       	movw	r24, r18
    2456:	df 91       	pop	r29
    2458:	cf 91       	pop	r28
    245a:	1f 91       	pop	r17
    245c:	0f 91       	pop	r16
    245e:	08 95       	ret

00002460 <editRamFileFunction>:
  ramDyskDir(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t editRamFileFunction(cmdState_t *state)
{
    2460:	ef 92       	push	r14
    2462:	ff 92       	push	r15
    2464:	0f 93       	push	r16
    2466:	1f 93       	push	r17
    2468:	df 93       	push	r29
    246a:	cf 93       	push	r28
    246c:	0f 92       	push	r0
    246e:	cd b7       	in	r28, 0x3d	; 61
    2470:	de b7       	in	r29, 0x3e	; 62
    2472:	8c 01       	movw	r16, r24
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    2474:	81 e0       	ldi	r24, 0x01	; 1
    2476:	b8 01       	movw	r22, r16
    2478:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    247c:	64 ec       	ldi	r22, 0xC4	; 196
    247e:	72 e3       	ldi	r23, 0x32	; 50
    2480:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <ramDyskOtworzPlik>
    2484:	88 23       	and	r24, r24
    2486:	21 f1       	breq	.+72     	; 0x24d0 <editRamFileFunction+0x70>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2488:	d8 01       	movw	r26, r16
    248a:	5a 96       	adiw	r26, 0x1a	; 26
    248c:	ed 90       	ld	r14, X+
    248e:	fc 90       	ld	r15, X
    2490:	5b 97       	sbiw	r26, 0x1b	; 27
    2492:	81 e0       	ldi	r24, 0x01	; 1
    2494:	b8 01       	movw	r22, r16
    2496:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    249a:	00 d0       	rcall	.+0      	; 0x249c <editRamFileFunction+0x3c>
    249c:	00 d0       	rcall	.+0      	; 0x249e <editRamFileFunction+0x3e>
    249e:	ed b7       	in	r30, 0x3d	; 61
    24a0:	fe b7       	in	r31, 0x3e	; 62
    24a2:	31 96       	adiw	r30, 0x01	; 1
    24a4:	ad b7       	in	r26, 0x3d	; 61
    24a6:	be b7       	in	r27, 0x3e	; 62
    24a8:	11 96       	adiw	r26, 0x01	; 1
    24aa:	ed 92       	st	X+, r14
    24ac:	fc 92       	st	X, r15
    24ae:	12 97       	sbiw	r26, 0x02	; 2
    24b0:	2a ee       	ldi	r18, 0xEA	; 234
    24b2:	32 e0       	ldi	r19, 0x02	; 2
    24b4:	22 83       	std	Z+2, r18	; 0x02
    24b6:	33 83       	std	Z+3, r19	; 0x03
    24b8:	84 83       	std	Z+4, r24	; 0x04
    24ba:	95 83       	std	Z+5, r25	; 0x05
    24bc:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    return ERROR_INFORM;
    24c0:	ed b7       	in	r30, 0x3d	; 61
    24c2:	fe b7       	in	r31, 0x3e	; 62
    24c4:	36 96       	adiw	r30, 0x06	; 6
    24c6:	ed bf       	out	0x3d, r30	; 61
    24c8:	fe bf       	out	0x3e, r31	; 62
    24ca:	24 e0       	ldi	r18, 0x04	; 4
    24cc:	30 e0       	ldi	r19, 0x00	; 0
    24ce:	3a c0       	rjmp	.+116    	; 0x2544 <editRamFileFunction+0xe4>
  }
  ramDyskUstawWskaznikNaKoniec(&fdVty);
    24d0:	84 ec       	ldi	r24, 0xC4	; 196
    24d2:	92 e3       	ldi	r25, 0x32	; 50
    24d4:	0e 94 2f 20 	call	0x405e	; 0x405e <ramDyskUstawWskaznikNaKoniec>
  uint8_t znak = 0;
    24d8:	19 82       	std	Y+1, r1	; 0x01
  fprintf_P(state->myStdInOut, editRamFileIntroStr);
    24da:	00 d0       	rcall	.+0      	; 0x24dc <editRamFileFunction+0x7c>
    24dc:	0f 92       	push	r0
    24de:	d8 01       	movw	r26, r16
    24e0:	5a 96       	adiw	r26, 0x1a	; 26
    24e2:	8d 91       	ld	r24, X+
    24e4:	9c 91       	ld	r25, X
    24e6:	5b 97       	sbiw	r26, 0x1b	; 27
    24e8:	ed b7       	in	r30, 0x3d	; 61
    24ea:	fe b7       	in	r31, 0x3e	; 62
    24ec:	81 83       	std	Z+1, r24	; 0x01
    24ee:	92 83       	std	Z+2, r25	; 0x02
    24f0:	80 eb       	ldi	r24, 0xB0	; 176
    24f2:	94 e0       	ldi	r25, 0x04	; 4
    24f4:	83 83       	std	Z+3, r24	; 0x03
    24f6:	94 83       	std	Z+4, r25	; 0x04
    24f8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    24fc:	0f 90       	pop	r0
    24fe:	0f 90       	pop	r0
    2500:	0f 90       	pop	r0
    2502:	0f 90       	pop	r0
  while(1)
  {
    if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
    2504:	8e 01       	movw	r16, r28
    2506:	0f 5f       	subi	r16, 0xFF	; 255
    2508:	1f 4f       	sbci	r17, 0xFF	; 255
    250a:	80 91 0d 32 	lds	r24, 0x320D
    250e:	90 91 0e 32 	lds	r25, 0x320E
    2512:	b8 01       	movw	r22, r16
    2514:	4f ef       	ldi	r20, 0xFF	; 255
    2516:	5f ef       	ldi	r21, 0xFF	; 255
    2518:	20 e0       	ldi	r18, 0x00	; 0
    251a:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    251e:	88 23       	and	r24, r24
    2520:	a1 f3       	breq	.-24     	; 0x250a <editRamFileFunction+0xaa>
      continue;

    if (znak == 0x03)                                       // ^C
    2522:	89 81       	ldd	r24, Y+1	; 0x01
    2524:	83 30       	cpi	r24, 0x03	; 3
    2526:	41 f0       	breq	.+16     	; 0x2538 <editRamFileFunction+0xd8>
      break;

    uartVtySendByte(znak);                                  //Echo
    2528:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
    ramDyskZapiszBajtDoPliku(&fdVty, znak);
    252c:	84 ec       	ldi	r24, 0xC4	; 196
    252e:	92 e3       	ldi	r25, 0x32	; 50
    2530:	69 81       	ldd	r22, Y+1	; 0x01
    2532:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <ramDyskZapiszBajtDoPliku>
    2536:	e9 cf       	rjmp	.-46     	; 0x250a <editRamFileFunction+0xaa>
  }
  ramDyskZamknijPlik(&fdVty);
    2538:	84 ec       	ldi	r24, 0xC4	; 196
    253a:	92 e3       	ldi	r25, 0x32	; 50
    253c:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ramDyskZamknijPlik>
  return OK_SILENT;
    2540:	20 e0       	ldi	r18, 0x00	; 0
    2542:	30 e0       	ldi	r19, 0x00	; 0
}
    2544:	c9 01       	movw	r24, r18
    2546:	0f 90       	pop	r0
    2548:	cf 91       	pop	r28
    254a:	df 91       	pop	r29
    254c:	1f 91       	pop	r17
    254e:	0f 91       	pop	r16
    2550:	ff 90       	pop	r15
    2552:	ef 90       	pop	r14
    2554:	08 95       	ret

00002556 <goXmodemOdbierzFunction>:
  }
  return OK_SILENT;
}

static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
{
    2556:	2f 92       	push	r2
    2558:	3f 92       	push	r3
    255a:	4f 92       	push	r4
    255c:	5f 92       	push	r5
    255e:	6f 92       	push	r6
    2560:	7f 92       	push	r7
    2562:	8f 92       	push	r8
    2564:	9f 92       	push	r9
    2566:	af 92       	push	r10
    2568:	bf 92       	push	r11
    256a:	cf 92       	push	r12
    256c:	df 92       	push	r13
    256e:	ef 92       	push	r14
    2570:	ff 92       	push	r15
    2572:	0f 93       	push	r16
    2574:	1f 93       	push	r17
    2576:	df 93       	push	r29
    2578:	cf 93       	push	r28
    257a:	cd b7       	in	r28, 0x3d	; 61
    257c:	de b7       	in	r29, 0x3e	; 62
    257e:	27 97       	sbiw	r28, 0x07	; 7
    2580:	cd bf       	out	0x3d, r28	; 61
    2582:	de bf       	out	0x3e, r29	; 62
    2584:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
    2586:	00 d0       	rcall	.+0      	; 0x2588 <goXmodemOdbierzFunction+0x32>
    2588:	0f 92       	push	r0
    258a:	dc 01       	movw	r26, r24
    258c:	5a 96       	adiw	r26, 0x1a	; 26
    258e:	8d 91       	ld	r24, X+
    2590:	9c 91       	ld	r25, X
    2592:	5b 97       	sbiw	r26, 0x1b	; 27
    2594:	ed b7       	in	r30, 0x3d	; 61
    2596:	fe b7       	in	r31, 0x3e	; 62
    2598:	81 83       	std	Z+1, r24	; 0x01
    259a:	92 83       	std	Z+2, r25	; 0x02
    259c:	8f e3       	ldi	r24, 0x3F	; 63
    259e:	97 e0       	ldi	r25, 0x07	; 7
    25a0:	83 83       	std	Z+3, r24	; 0x03
    25a2:	94 83       	std	Z+4, r25	; 0x04
    25a4:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    25a8:	0f 90       	pop	r0
    25aa:	0f 90       	pop	r0
    25ac:	0f 90       	pop	r0
    25ae:	0f 90       	pop	r0
    25b0:	81 e0       	ldi	r24, 0x01	; 1
    25b2:	b8 01       	movw	r22, r16
    25b4:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    25b8:	64 ec       	ldi	r22, 0xC4	; 196
    25ba:	72 e3       	ldi	r23, 0x32	; 50
    25bc:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <ramDyskOtworzPlik>
    25c0:	88 23       	and	r24, r24
    25c2:	11 f1       	breq	.+68     	; 0x2608 <goXmodemOdbierzFunction+0xb2>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    25c4:	d8 01       	movw	r26, r16
    25c6:	5a 96       	adiw	r26, 0x1a	; 26
    25c8:	ed 90       	ld	r14, X+
    25ca:	fc 90       	ld	r15, X
    25cc:	5b 97       	sbiw	r26, 0x1b	; 27
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	b8 01       	movw	r22, r16
    25d2:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    25d6:	00 d0       	rcall	.+0      	; 0x25d8 <goXmodemOdbierzFunction+0x82>
    25d8:	00 d0       	rcall	.+0      	; 0x25da <goXmodemOdbierzFunction+0x84>
    25da:	ed b7       	in	r30, 0x3d	; 61
    25dc:	fe b7       	in	r31, 0x3e	; 62
    25de:	31 96       	adiw	r30, 0x01	; 1
    25e0:	ad b7       	in	r26, 0x3d	; 61
    25e2:	be b7       	in	r27, 0x3e	; 62
    25e4:	11 96       	adiw	r26, 0x01	; 1
    25e6:	ed 92       	st	X+, r14
    25e8:	fc 92       	st	X, r15
    25ea:	12 97       	sbiw	r26, 0x02	; 2
    25ec:	2a ee       	ldi	r18, 0xEA	; 234
    25ee:	32 e0       	ldi	r19, 0x02	; 2
    25f0:	22 83       	std	Z+2, r18	; 0x02
    25f2:	33 83       	std	Z+3, r19	; 0x03
    25f4:	84 83       	std	Z+4, r24	; 0x04
    25f6:	95 83       	std	Z+5, r25	; 0x05
    25f8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    return ERROR_INFORM;
    25fc:	ed b7       	in	r30, 0x3d	; 61
    25fe:	fe b7       	in	r31, 0x3e	; 62
    2600:	36 96       	adiw	r30, 0x06	; 6
    2602:	ed bf       	out	0x3d, r30	; 61
    2604:	fe bf       	out	0x3e, r31	; 62
    2606:	32 c0       	rjmp	.+100    	; 0x266c <goXmodemOdbierzFunction+0x116>
  uint8_t nrBlokuZdalnyNeg;

  uint8_t crcHi;
  uint8_t crcLo;

  state->err1=0;
    2608:	d8 01       	movw	r26, r16
    260a:	5d 96       	adiw	r26, 0x1d	; 29
    260c:	1d 92       	st	X+, r1
    260e:	1c 92       	st	X, r1
    2610:	5e 97       	sbiw	r26, 0x1e	; 30
  state->err2=0;
    2612:	5f 96       	adiw	r26, 0x1f	; 31
    2614:	1c 92       	st	X, r1
  liczbaProb = 20;
    2616:	84 e1       	ldi	r24, 0x14	; 20
    2618:	d8 2e       	mov	r13, r24
  {
    fputc('C'              , state->myStdInOut);
   // while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
//od usartD0
    while(!(USARTD0.STATUS & USART_TXCIF_bm));
    if(xQueueReceive(xVtyRec, &c, 100))
    261a:	b2 e0       	ldi	r27, 0x02	; 2
    261c:	eb 2e       	mov	r14, r27
    261e:	f1 2c       	mov	r15, r1
    2620:	ec 0e       	add	r14, r28
    2622:	fd 1e       	adc	r15, r29
  state->err1=0;
  state->err2=0;
  liczbaProb = 20;
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    2624:	f8 01       	movw	r30, r16
    2626:	62 8d       	ldd	r22, Z+26	; 0x1a
    2628:	73 8d       	ldd	r23, Z+27	; 0x1b
    262a:	83 e4       	ldi	r24, 0x43	; 67
    262c:	90 e0       	ldi	r25, 0x00	; 0
    262e:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
   // while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
//od usartD0
    while(!(USARTD0.STATUS & USART_TXCIF_bm));
    2632:	80 91 a1 09 	lds	r24, 0x09A1
    2636:	86 ff       	sbrs	r24, 6
    2638:	fc cf       	rjmp	.-8      	; 0x2632 <goXmodemOdbierzFunction+0xdc>
    if(xQueueReceive(xVtyRec, &c, 100))
    263a:	80 91 0d 32 	lds	r24, 0x320D
    263e:	90 91 0e 32 	lds	r25, 0x320E
    2642:	b7 01       	movw	r22, r14
    2644:	44 e6       	ldi	r20, 0x64	; 100
    2646:	50 e0       	ldi	r21, 0x00	; 0
    2648:	20 e0       	ldi	r18, 0x00	; 0
    264a:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    264e:	88 23       	and	r24, r24
    2650:	19 f0       	breq	.+6      	; 0x2658 <goXmodemOdbierzFunction+0x102>
      if (c == SOH)
    2652:	8a 81       	ldd	r24, Y+2	; 0x02
    2654:	81 30       	cpi	r24, 0x01	; 1
    2656:	69 f0       	breq	.+26     	; 0x2672 <goXmodemOdbierzFunction+0x11c>
        break;                                                   //Rozpoczynamy transmisje

    liczbaProb--;
    2658:	da 94       	dec	r13
    if (liczbaProb == 0)
    265a:	21 f7       	brne	.-56     	; 0x2624 <goXmodemOdbierzFunction+0xce>
    {
      ramDyskZamknijPlik(&fdVty);
    265c:	84 ec       	ldi	r24, 0xC4	; 196
    265e:	92 e3       	ldi	r25, 0x32	; 50
    2660:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ramDyskZamknijPlik>
      state->errno = (uint8_t)(AllOK);
    2664:	d8 01       	movw	r26, r16
    2666:	5c 96       	adiw	r26, 0x1c	; 28
    2668:	1c 92       	st	X, r1
    266a:	5c 97       	sbiw	r26, 0x1c	; 28
      return ERROR_INFORM;
    266c:	24 e0       	ldi	r18, 0x04	; 4
    266e:	30 e0       	ldi	r19, 0x00	; 0
    2670:	4e c1       	rjmp	.+668    	; 0x290e <goXmodemOdbierzFunction+0x3b8>
  }
  
  nrBloku = 1;
  liczbaProb = 10;

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2672:	84 ec       	ldi	r24, 0xC4	; 196
    2674:	92 e3       	ldi	r25, 0x32	; 50
    2676:	61 e0       	ldi	r22, 0x01	; 1
    2678:	70 e0       	ldi	r23, 0x00	; 0
    267a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <ramDyskDodajBlokXmodem>
    267e:	6c 01       	movw	r12, r24
      state->errno = (uint8_t)(AllOK);
      return ERROR_INFORM;
    }
  }
  
  nrBloku = 1;
    2680:	ee 24       	eor	r14, r14
    2682:	e3 94       	inc	r14
  liczbaProb = 10;
    2684:	aa e0       	ldi	r26, 0x0A	; 10
    2686:	ba 2e       	mov	r11, r26

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    2688:	f3 e0       	ldi	r31, 0x03	; 3
    268a:	4f 2e       	mov	r4, r31
    268c:	51 2c       	mov	r5, r1
    268e:	4c 0e       	add	r4, r28
    2690:	5d 1e       	adc	r5, r29
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    2692:	e4 e0       	ldi	r30, 0x04	; 4
    2694:	2e 2e       	mov	r2, r30
    2696:	31 2c       	mov	r3, r1
    2698:	2c 0e       	add	r2, r28
    269a:	3d 1e       	adc	r3, r29
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    269c:	73 e0       	ldi	r23, 0x03	; 3
    269e:	a7 2e       	mov	r10, r23
      state->err2 = nrBloku;
      state->errno = (uint8_t)(xModemWrongFrameNo);
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    26a0:	3e 01       	movw	r6, r28
    26a2:	08 94       	sec
    26a4:	61 1c       	adc	r6, r1
    26a6:	71 1c       	adc	r7, r1

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    26a8:	80 91 0d 32 	lds	r24, 0x320D
    26ac:	90 91 0e 32 	lds	r25, 0x320E
    26b0:	b2 01       	movw	r22, r4
    26b2:	44 e6       	ldi	r20, 0x64	; 100
    26b4:	50 e0       	ldi	r21, 0x00	; 0
    26b6:	20 e0       	ldi	r18, 0x00	; 0
    26b8:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    26bc:	88 23       	and	r24, r24
    26be:	19 f4       	brne	.+6      	; 0x26c6 <goXmodemOdbierzFunction+0x170>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    26c0:	82 e0       	ldi	r24, 0x02	; 2
    26c2:	f8 01       	movw	r30, r16
    26c4:	cc c0       	rjmp	.+408    	; 0x285e <goXmodemOdbierzFunction+0x308>
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    26c6:	80 91 0d 32 	lds	r24, 0x320D
    26ca:	90 91 0e 32 	lds	r25, 0x320E
    26ce:	b1 01       	movw	r22, r2
    26d0:	41 e0       	ldi	r20, 0x01	; 1
    26d2:	50 e0       	ldi	r21, 0x00	; 0
    26d4:	20 e0       	ldi	r18, 0x00	; 0
    26d6:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    26da:	88 23       	and	r24, r24
    26dc:	11 f4       	brne	.+4      	; 0x26e2 <goXmodemOdbierzFunction+0x18c>
    {
      state->errno = (uint8_t)(xModemByteSendTimeout);
    26de:	83 e0       	ldi	r24, 0x03	; 3
    26e0:	cd c0       	rjmp	.+410    	; 0x287c <goXmodemOdbierzFunction+0x326>
      break; 
    }
  
    //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
    c = 255-nrBlokuZdalnyNeg;
    26e2:	8c 81       	ldd	r24, Y+4	; 0x04
    26e4:	98 2f       	mov	r25, r24
    26e6:	90 95       	com	r25
    26e8:	9a 83       	std	Y+2, r25	; 0x02
    if (nrBlokuZdalny != c)
    26ea:	fb 80       	ldd	r15, Y+3	; 0x03
    26ec:	f9 16       	cp	r15, r25
    26ee:	39 f0       	breq	.+14     	; 0x26fe <goXmodemOdbierzFunction+0x1a8>
    {
      state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
    26f0:	95 e0       	ldi	r25, 0x05	; 5
    26f2:	f8 01       	movw	r30, r16
    26f4:	94 8f       	std	Z+28, r25	; 0x1c
      state->err1 = nrBlokuZdalny;
    26f6:	f5 8e       	std	Z+29, r15	; 0x1d
    26f8:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBlokuZdalnyNeg;
    26fa:	87 8f       	std	Z+31, r24	; 0x1f
      break;
    26fc:	02 c1       	rjmp	.+516    	; 0x2902 <goXmodemOdbierzFunction+0x3ac>
    }
    
    //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od bloku 0
    c = nrBloku-1;
    26fe:	8e 2d       	mov	r24, r14
    2700:	81 50       	subi	r24, 0x01	; 1
    2702:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny == c)
    2704:	f8 16       	cp	r15, r24
    2706:	41 f4       	brne	.+16     	; 0x2718 <goXmodemOdbierzFunction+0x1c2>
    {
      nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2708:	84 ec       	ldi	r24, 0xC4	; 196
    270a:	92 e3       	ldi	r25, 0x32	; 50
    270c:	6f 2d       	mov	r22, r15
    270e:	70 e0       	ldi	r23, 0x00	; 0
    2710:	0e 94 51 20 	call	0x40a2	; 0x40a2 <ramDyskDodajBlokXmodem>
    2714:	6c 01       	movw	r12, r24
    2716:	ef 2c       	mov	r14, r15
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    2718:	fb 80       	ldd	r15, Y+3	; 0x03
    271a:	fe 14       	cp	r15, r14
    271c:	81 f0       	breq	.+32     	; 0x273e <goXmodemOdbierzFunction+0x1e8>
    {
      state->errno = (uint8_t)(xModemWrongFrameNo);
    271e:	84 e0       	ldi	r24, 0x04	; 4
    2720:	d8 01       	movw	r26, r16
    2722:	5c 96       	adiw	r26, 0x1c	; 28
    2724:	8c 93       	st	X, r24
    2726:	5c 97       	sbiw	r26, 0x1c	; 28
      state->err1 = nrBlokuZdalnyNeg;
    2728:	8c 81       	ldd	r24, Y+4	; 0x04
    272a:	5d 96       	adiw	r26, 0x1d	; 29
    272c:	8c 93       	st	X, r24
    272e:	5d 97       	sbiw	r26, 0x1d	; 29
    2730:	5e 96       	adiw	r26, 0x1e	; 30
    2732:	1c 92       	st	X, r1
    2734:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    2736:	5f 96       	adiw	r26, 0x1f	; 31
    2738:	ec 92       	st	X, r14
    273a:	5f 97       	sbiw	r26, 0x1f	; 31
      break;
    273c:	e2 c0       	rjmp	.+452    	; 0x2902 <goXmodemOdbierzFunction+0x3ac>
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    273e:	8c 2c       	mov	r8, r12
    2740:	9d 2c       	mov	r9, r13
    2742:	30 e0       	ldi	r19, 0x00	; 0
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    {
      if(xQueueReceive(xVtyRec, &c, 10))
    2744:	80 91 0d 32 	lds	r24, 0x320D
    2748:	90 91 0e 32 	lds	r25, 0x320E
    274c:	be 01       	movw	r22, r28
    274e:	6e 5f       	subi	r22, 0xFE	; 254
    2750:	7f 4f       	sbci	r23, 0xFF	; 255
    2752:	4a e0       	ldi	r20, 0x0A	; 10
    2754:	50 e0       	ldi	r21, 0x00	; 0
    2756:	20 e0       	ldi	r18, 0x00	; 0
    2758:	3f 83       	std	Y+7, r19	; 0x07
    275a:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    275e:	3f 81       	ldd	r19, Y+7	; 0x07
    2760:	88 23       	and	r24, r24
    2762:	41 f0       	breq	.+16     	; 0x2774 <goXmodemOdbierzFunction+0x21e>
        *(zapPtr++) = c;
    2764:	8a 81       	ldd	r24, Y+2	; 0x02
    2766:	f4 01       	movw	r30, r8
    2768:	81 93       	st	Z+, r24
    276a:	4f 01       	movw	r8, r30
      state->err1 = nrBlokuZdalnyNeg;
      state->err2 = nrBloku;
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    276c:	3f 5f       	subi	r19, 0xFF	; 255
    276e:	30 38       	cpi	r19, 0x80	; 128
    2770:	49 f7       	brne	.-46     	; 0x2744 <goXmodemOdbierzFunction+0x1ee>
    2772:	03 c0       	rjmp	.+6      	; 0x277a <goXmodemOdbierzFunction+0x224>
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2774:	d8 01       	movw	r26, r16
    2776:	5c 96       	adiw	r26, 0x1c	; 28
    2778:	ac 92       	st	X, r10
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    277a:	80 91 0d 32 	lds	r24, 0x320D
    277e:	90 91 0e 32 	lds	r25, 0x320E
    2782:	be 01       	movw	r22, r28
    2784:	6b 5f       	subi	r22, 0xFB	; 251
    2786:	7f 4f       	sbci	r23, 0xFF	; 255
    2788:	4a e0       	ldi	r20, 0x0A	; 10
    278a:	50 e0       	ldi	r21, 0x00	; 0
    278c:	20 e0       	ldi	r18, 0x00	; 0
    278e:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    2792:	88 23       	and	r24, r24
    2794:	41 f4       	brne	.+16     	; 0x27a6 <goXmodemOdbierzFunction+0x250>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2796:	86 e0       	ldi	r24, 0x06	; 6
    2798:	f8 01       	movw	r30, r16
    279a:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 2;
    279c:	82 e0       	ldi	r24, 0x02	; 2
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	85 8f       	std	Z+29, r24	; 0x1d
    27a2:	96 8f       	std	Z+30, r25	; 0x1e
        break;      
    27a4:	ae c0       	rjmp	.+348    	; 0x2902 <goXmodemOdbierzFunction+0x3ac>
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    27a6:	80 91 0d 32 	lds	r24, 0x320D
    27aa:	90 91 0e 32 	lds	r25, 0x320E
    27ae:	be 01       	movw	r22, r28
    27b0:	6a 5f       	subi	r22, 0xFA	; 250
    27b2:	7f 4f       	sbci	r23, 0xFF	; 255
    27b4:	4a e0       	ldi	r20, 0x0A	; 10
    27b6:	50 e0       	ldi	r21, 0x00	; 0
    27b8:	20 e0       	ldi	r18, 0x00	; 0
    27ba:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    27be:	88 23       	and	r24, r24
    27c0:	61 f4       	brne	.+24     	; 0x27da <goXmodemOdbierzFunction+0x284>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    27c2:	86 e0       	ldi	r24, 0x06	; 6
    27c4:	d8 01       	movw	r26, r16
    27c6:	5c 96       	adiw	r26, 0x1c	; 28
    27c8:	8c 93       	st	X, r24
    27ca:	5c 97       	sbiw	r26, 0x1c	; 28
        state->err1 = 1;
    27cc:	81 e0       	ldi	r24, 0x01	; 1
    27ce:	90 e0       	ldi	r25, 0x00	; 0
    27d0:	5d 96       	adiw	r26, 0x1d	; 29
    27d2:	8d 93       	st	X+, r24
    27d4:	9c 93       	st	X, r25
    27d6:	5e 97       	sbiw	r26, 0x1e	; 30
        break;      
    27d8:	94 c0       	rjmp	.+296    	; 0x2902 <goXmodemOdbierzFunction+0x3ac>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
        state->err1 = 2;
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    27da:	ec 2d       	mov	r30, r12
    27dc:	fd 2d       	mov	r31, r13
    27de:	80 e0       	ldi	r24, 0x00	; 0
    27e0:	90 e0       	ldi	r25, 0x00	; 0
    27e2:	20 e0       	ldi	r18, 0x00	; 0
    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
    27e4:	31 91       	ld	r19, Z+
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    27e6:	93 27       	eor	r25, r19
    27e8:	09 2e       	mov	r0, r25
    27ea:	02 94       	swap	r0
    27ec:	30 2d       	mov	r19, r0
    27ee:	3f 70       	andi	r19, 0x0F	; 15
    27f0:	39 27       	eor	r19, r25
    27f2:	49 2f       	mov	r20, r25
    27f4:	40 25       	eor	r20, r0
    27f6:	44 0f       	add	r20, r20
    27f8:	40 7e       	andi	r20, 0xE0	; 224
    27fa:	34 27       	eor	r19, r20
    27fc:	40 2d       	mov	r20, r0
    27fe:	49 27       	eor	r20, r25
    2800:	40 7f       	andi	r20, 0xF0	; 240
    2802:	46 95       	lsr	r20
    2804:	09 2e       	mov	r0, r25
    2806:	00 0c       	add	r0, r0
    2808:	44 1f       	adc	r20, r20
    280a:	96 95       	lsr	r25
    280c:	96 95       	lsr	r25
    280e:	96 95       	lsr	r25
    2810:	9f 71       	andi	r25, 0x1F	; 31
    2812:	94 27       	eor	r25, r20
    2814:	98 27       	eor	r25, r24
    2816:	83 2f       	mov	r24, r19

    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    2818:	2f 5f       	subi	r18, 0xFF	; 255
    281a:	20 38       	cpi	r18, 0x80	; 128
    281c:	19 f7       	brne	.-58     	; 0x27e4 <goXmodemOdbierzFunction+0x28e>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    281e:	4d 81       	ldd	r20, Y+5	; 0x05
    2820:	50 e0       	ldi	r21, 0x00	; 0
    2822:	29 2f       	mov	r18, r25
    2824:	33 27       	eor	r19, r19
    2826:	42 17       	cp	r20, r18
    2828:	53 07       	cpc	r21, r19
    282a:	61 f4       	brne	.+24     	; 0x2844 <goXmodemOdbierzFunction+0x2ee>
    282c:	2e 81       	ldd	r18, Y+6	; 0x06
    282e:	30 e0       	ldi	r19, 0x00	; 0
    2830:	90 70       	andi	r25, 0x00	; 0
    2832:	28 17       	cp	r18, r24
    2834:	39 07       	cpc	r19, r25
    2836:	31 f4       	brne	.+12     	; 0x2844 <goXmodemOdbierzFunction+0x2ee>
    {
      liczbaProb = 10;
      uartVtySendByte(ACK);      
    2838:	86 e0       	ldi	r24, 0x06	; 6
    283a:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    {
      liczbaProb = 10;
    283e:	3a e0       	ldi	r19, 0x0A	; 10
    2840:	b3 2e       	mov	r11, r19
    2842:	0f c0       	rjmp	.+30     	; 0x2862 <goXmodemOdbierzFunction+0x30c>
      uartVtySendByte(ACK);      
    }
    else
    {
      liczbaProb--;
    2844:	ba 94       	dec	r11
      nrBloku--;
    2846:	fa 94       	dec	r15
      uartVtySendByte(NAK);   
    2848:	85 e1       	ldi	r24, 0x15	; 21
    284a:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
    }
    
    if (liczbaProb == 0)
    284e:	bb 20       	and	r11, r11
    2850:	41 f4       	brne	.+16     	; 0x2862 <goXmodemOdbierzFunction+0x30c>
    {
      state->err1 = nrBlokuZdalny;
    2852:	8b 81       	ldd	r24, Y+3	; 0x03
    2854:	f8 01       	movw	r30, r16
    2856:	85 8f       	std	Z+29, r24	; 0x1d
    2858:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBloku;
    285a:	f7 8e       	std	Z+31, r15	; 0x1f
      state->errno = (uint8_t)(xModemWrongFrameNo);
    285c:	84 e0       	ldi	r24, 0x04	; 4
    285e:	84 8f       	std	Z+28, r24	; 0x1c
      break; 
    2860:	50 c0       	rjmp	.+160    	; 0x2902 <goXmodemOdbierzFunction+0x3ac>
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    2862:	80 91 0d 32 	lds	r24, 0x320D
    2866:	90 91 0e 32 	lds	r25, 0x320E
    286a:	b3 01       	movw	r22, r6
    286c:	44 e6       	ldi	r20, 0x64	; 100
    286e:	50 e0       	ldi	r21, 0x00	; 0
    2870:	20 e0       	ldi	r18, 0x00	; 0
    2872:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    2876:	88 23       	and	r24, r24
    2878:	31 f4       	brne	.+12     	; 0x2886 <goXmodemOdbierzFunction+0x330>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    287a:	82 e0       	ldi	r24, 0x02	; 2
    287c:	d8 01       	movw	r26, r16
    287e:	5c 96       	adiw	r26, 0x1c	; 28
    2880:	8c 93       	st	X, r24
    2882:	5c 97       	sbiw	r26, 0x1c	; 28
      break;
    2884:	3e c0       	rjmp	.+124    	; 0x2902 <goXmodemOdbierzFunction+0x3ac>
    }
    
    if (temp1 == SOH)
    2886:	89 81       	ldd	r24, Y+1	; 0x01
    2888:	81 30       	cpi	r24, 0x01	; 1
    288a:	61 f4       	brne	.+24     	; 0x28a4 <goXmodemOdbierzFunction+0x34e>
    {
      nrBloku++;
    288c:	ef 2c       	mov	r14, r15
    288e:	e3 94       	inc	r14
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2890:	84 ec       	ldi	r24, 0xC4	; 196
    2892:	92 e3       	ldi	r25, 0x32	; 50
    2894:	6e 2d       	mov	r22, r14
    2896:	70 e0       	ldi	r23, 0x00	; 0
    2898:	0e 94 51 20 	call	0x40a2	; 0x40a2 <ramDyskDodajBlokXmodem>
    289c:	6c 01       	movw	r12, r24
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
    289e:	f8 01       	movw	r30, r16
    28a0:	14 8e       	std	Z+28, r1	; 0x1c
      break;
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    state->err1 = temp1;
    break;
  }
    28a2:	02 cf       	rjmp	.-508    	; 0x26a8 <goXmodemOdbierzFunction+0x152>
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
      continue;
    }

    if (temp1 == CAN)
    28a4:	88 31       	cpi	r24, 0x18	; 24
    28a6:	49 f4       	brne	.+18     	; 0x28ba <goXmodemOdbierzFunction+0x364>
    {
      state->err1 = nrBloku;
    28a8:	d8 01       	movw	r26, r16
    28aa:	5d 96       	adiw	r26, 0x1d	; 29
    28ac:	fc 92       	st	X, r15
    28ae:	5d 97       	sbiw	r26, 0x1d	; 29
    28b0:	5e 96       	adiw	r26, 0x1e	; 30
    28b2:	1c 92       	st	X, r1
    28b4:	5e 97       	sbiw	r26, 0x1e	; 30
      state->errno = (uint8_t)(xModemRemoteSideCan);
    28b6:	87 e0       	ldi	r24, 0x07	; 7
    28b8:	e2 cf       	rjmp	.-60     	; 0x287e <goXmodemOdbierzFunction+0x328>
      break;
    }
    if (temp1 == EOT)
    28ba:	84 30       	cpi	r24, 0x04	; 4
    28bc:	c1 f4       	brne	.+48     	; 0x28ee <goXmodemOdbierzFunction+0x398>
    {
      uartVtySendByte(NAK);
    28be:	85 e1       	ldi	r24, 0x15	; 21
    28c0:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
      if (xQueueReceive(xVtyRec, &temp1, 10))
    28c4:	80 91 0d 32 	lds	r24, 0x320D
    28c8:	90 91 0e 32 	lds	r25, 0x320E
    28cc:	b3 01       	movw	r22, r6
    28ce:	4a e0       	ldi	r20, 0x0A	; 10
    28d0:	50 e0       	ldi	r21, 0x00	; 0
    28d2:	20 e0       	ldi	r18, 0x00	; 0
    28d4:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    28d8:	88 23       	and	r24, r24
    28da:	31 f0       	breq	.+12     	; 0x28e8 <goXmodemOdbierzFunction+0x392>
      {
        if (temp1 == EOT)
    28dc:	89 81       	ldd	r24, Y+1	; 0x01
    28de:	84 30       	cpi	r24, 0x04	; 4
    28e0:	19 f4       	brne	.+6      	; 0x28e8 <goXmodemOdbierzFunction+0x392>
          uartVtySendByte(ACK);  
    28e2:	86 e0       	ldi	r24, 0x06	; 6
    28e4:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
      }
      state->errno = (uint8_t)(AllOK);
    28e8:	f8 01       	movw	r30, r16
    28ea:	14 8e       	std	Z+28, r1	; 0x1c
      break;
    28ec:	0a c0       	rjmp	.+20     	; 0x2902 <goXmodemOdbierzFunction+0x3ac>
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    28ee:	98 e0       	ldi	r25, 0x08	; 8
    28f0:	d8 01       	movw	r26, r16
    28f2:	5c 96       	adiw	r26, 0x1c	; 28
    28f4:	9c 93       	st	X, r25
    28f6:	5c 97       	sbiw	r26, 0x1c	; 28
    state->err1 = temp1;
    28f8:	5d 96       	adiw	r26, 0x1d	; 29
    28fa:	8c 93       	st	X, r24
    28fc:	5d 97       	sbiw	r26, 0x1d	; 29
    28fe:	5e 96       	adiw	r26, 0x1e	; 30
    2900:	1c 92       	st	X, r1
    break;
  }
  ramDyskZamknijPlik(&fdVty);
    2902:	84 ec       	ldi	r24, 0xC4	; 196
    2904:	92 e3       	ldi	r25, 0x32	; 50
    2906:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ramDyskZamknijPlik>
  return OK_SILENT;
    290a:	20 e0       	ldi	r18, 0x00	; 0
    290c:	30 e0       	ldi	r19, 0x00	; 0
}
    290e:	c9 01       	movw	r24, r18
    2910:	27 96       	adiw	r28, 0x07	; 7
    2912:	cd bf       	out	0x3d, r28	; 61
    2914:	de bf       	out	0x3e, r29	; 62
    2916:	cf 91       	pop	r28
    2918:	df 91       	pop	r29
    291a:	1f 91       	pop	r17
    291c:	0f 91       	pop	r16
    291e:	ff 90       	pop	r15
    2920:	ef 90       	pop	r14
    2922:	df 90       	pop	r13
    2924:	cf 90       	pop	r12
    2926:	bf 90       	pop	r11
    2928:	af 90       	pop	r10
    292a:	9f 90       	pop	r9
    292c:	8f 90       	pop	r8
    292e:	7f 90       	pop	r7
    2930:	6f 90       	pop	r6
    2932:	5f 90       	pop	r5
    2934:	4f 90       	pop	r4
    2936:	3f 90       	pop	r3
    2938:	2f 90       	pop	r2
    293a:	08 95       	ret

0000293c <debugFunction>:
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
  return OK_SILENT;
}

static cliExRes_t debugFunction          (cmdState_t *state)
{
    293c:	ff 92       	push	r15
    293e:	0f 93       	push	r16
    2940:	1f 93       	push	r17
    2942:	cf 93       	push	r28
    2944:	df 93       	push	r29
    2946:	8c 01       	movw	r16, r24
  if (state->argc < 2)
    2948:	dc 01       	movw	r26, r24
    294a:	59 96       	adiw	r26, 0x19	; 25
    294c:	8c 91       	ld	r24, X
    294e:	59 97       	sbiw	r26, 0x19	; 25
    2950:	82 30       	cpi	r24, 0x02	; 2
    2952:	08 f4       	brcc	.+2      	; 0x2956 <debugFunction+0x1a>
    2954:	e2 c0       	rjmp	.+452    	; 0x2b1a <debugFunction+0x1de>
    return SYNTAX_ERROR;

  uint8_t level = cmdlineGetArgInt(2, state);
    2956:	82 e0       	ldi	r24, 0x02	; 2
    2958:	b8 01       	movw	r22, r16
    295a:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    295e:	f6 2e       	mov	r15, r22
  const char *str = (const char*)cmdlineGetArgStr(1, state);
    2960:	81 e0       	ldi	r24, 0x01	; 1
    2962:	b8 01       	movw	r22, r16
    2964:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    2968:	ec 01       	movw	r28, r24
  if (level == 0)
    296a:	ff 20       	and	r15, r15
    296c:	09 f0       	breq	.+2      	; 0x2970 <debugFunction+0x34>
    296e:	5d c0       	rjmp	.+186    	; 0x2a2a <debugFunction+0xee>
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2970:	63 e8       	ldi	r22, 0x83	; 131
    2972:	77 e0       	ldi	r23, 0x07	; 7
    2974:	43 e0       	ldi	r20, 0x03	; 3
    2976:	50 e0       	ldi	r21, 0x00	; 0
    2978:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    297c:	00 97       	sbiw	r24, 0x00	; 0
    297e:	31 f4       	brne	.+12     	; 0x298c <debugFunction+0x50>
    {
      setArpDebug(NULL, 0);
    2980:	80 e0       	ldi	r24, 0x00	; 0
    2982:	90 e0       	ldi	r25, 0x00	; 0
    2984:	60 e0       	ldi	r22, 0x00	; 0
    2986:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <setArpDebug>
    298a:	3c c0       	rjmp	.+120    	; 0x2a04 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    298c:	ce 01       	movw	r24, r28
    298e:	60 e8       	ldi	r22, 0x80	; 128
    2990:	77 e0       	ldi	r23, 0x07	; 7
    2992:	42 e0       	ldi	r20, 0x02	; 2
    2994:	50 e0       	ldi	r21, 0x00	; 0
    2996:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    299a:	00 97       	sbiw	r24, 0x00	; 0
    299c:	31 f4       	brne	.+12     	; 0x29aa <debugFunction+0x6e>
    {
      setIpDebug(NULL, 0);
    299e:	80 e0       	ldi	r24, 0x00	; 0
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	60 e0       	ldi	r22, 0x00	; 0
    29a4:	0e 94 af 32 	call	0x655e	; 0x655e <setIpDebug>
    29a8:	2d c0       	rjmp	.+90     	; 0x2a04 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    29aa:	ce 01       	movw	r24, r28
    29ac:	6b e7       	ldi	r22, 0x7B	; 123
    29ae:	77 e0       	ldi	r23, 0x07	; 7
    29b0:	42 e0       	ldi	r20, 0x02	; 2
    29b2:	50 e0       	ldi	r21, 0x00	; 0
    29b4:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    29b8:	00 97       	sbiw	r24, 0x00	; 0
    29ba:	31 f4       	brne	.+12     	; 0x29c8 <debugFunction+0x8c>
    {
      setIcmpDebug(NULL, 0);
    29bc:	80 e0       	ldi	r24, 0x00	; 0
    29be:	90 e0       	ldi	r25, 0x00	; 0
    29c0:	60 e0       	ldi	r22, 0x00	; 0
    29c2:	0e 94 7e 34 	call	0x68fc	; 0x68fc <setIcmpDebug>
    29c6:	1e c0       	rjmp	.+60     	; 0x2a04 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    29c8:	ce 01       	movw	r24, r28
    29ca:	67 e7       	ldi	r22, 0x77	; 119
    29cc:	77 e0       	ldi	r23, 0x07	; 7
    29ce:	42 e0       	ldi	r20, 0x02	; 2
    29d0:	50 e0       	ldi	r21, 0x00	; 0
    29d2:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    29d6:	00 97       	sbiw	r24, 0x00	; 0
    29d8:	31 f4       	brne	.+12     	; 0x29e6 <debugFunction+0xaa>
    {
      setTcpDebug(NULL, 0);
    29da:	80 e0       	ldi	r24, 0x00	; 0
    29dc:	90 e0       	ldi	r25, 0x00	; 0
    29de:	60 e0       	ldi	r22, 0x00	; 0
    29e0:	0e 94 b1 3c 	call	0x7962	; 0x7962 <setTcpDebug>
    29e4:	0f c0       	rjmp	.+30     	; 0x2a04 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    29e6:	ce 01       	movw	r24, r28
    29e8:	63 e7       	ldi	r22, 0x73	; 115
    29ea:	77 e0       	ldi	r23, 0x07	; 7
    29ec:	42 e0       	ldi	r20, 0x02	; 2
    29ee:	50 e0       	ldi	r21, 0x00	; 0
    29f0:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    29f4:	00 97       	sbiw	r24, 0x00	; 0
    29f6:	09 f0       	breq	.+2      	; 0x29fa <debugFunction+0xbe>
    29f8:	90 c0       	rjmp	.+288    	; 0x2b1a <debugFunction+0x1de>
    {
      setUdpDebug(NULL, 0);
    29fa:	80 e0       	ldi	r24, 0x00	; 0
    29fc:	90 e0       	ldi	r25, 0x00	; 0
    29fe:	60 e0       	ldi	r22, 0x00	; 0
    2a00:	0e 94 fe 3c 	call	0x79fc	; 0x79fc <setUdpDebug>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
    2a04:	00 d0       	rcall	.+0      	; 0x2a06 <debugFunction+0xca>
    2a06:	00 d0       	rcall	.+0      	; 0x2a08 <debugFunction+0xcc>
    2a08:	ed b7       	in	r30, 0x3d	; 61
    2a0a:	fe b7       	in	r31, 0x3e	; 62
    2a0c:	31 96       	adiw	r30, 0x01	; 1
    2a0e:	d8 01       	movw	r26, r16
    2a10:	5a 96       	adiw	r26, 0x1a	; 26
    2a12:	8d 91       	ld	r24, X+
    2a14:	9c 91       	ld	r25, X
    2a16:	5b 97       	sbiw	r26, 0x1b	; 27
    2a18:	ad b7       	in	r26, 0x3d	; 61
    2a1a:	be b7       	in	r27, 0x3e	; 62
    2a1c:	11 96       	adiw	r26, 0x01	; 1
    2a1e:	8d 93       	st	X+, r24
    2a20:	9c 93       	st	X, r25
    2a22:	12 97       	sbiw	r26, 0x02	; 2
    2a24:	80 e9       	ldi	r24, 0x90	; 144
    2a26:	95 e0       	ldi	r25, 0x05	; 5
    2a28:	6a c0       	rjmp	.+212    	; 0x2afe <debugFunction+0x1c2>


  }
  else                   //level > 0
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2a2a:	6f e6       	ldi	r22, 0x6F	; 111
    2a2c:	77 e0       	ldi	r23, 0x07	; 7
    2a2e:	43 e0       	ldi	r20, 0x03	; 3
    2a30:	50 e0       	ldi	r21, 0x00	; 0
    2a32:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    2a36:	00 97       	sbiw	r24, 0x00	; 0
    2a38:	49 f4       	brne	.+18     	; 0x2a4c <debugFunction+0x110>
    {
      setArpDebug(state->myStdInOut, level);
    2a3a:	d8 01       	movw	r26, r16
    2a3c:	5a 96       	adiw	r26, 0x1a	; 26
    2a3e:	8d 91       	ld	r24, X+
    2a40:	9c 91       	ld	r25, X
    2a42:	5b 97       	sbiw	r26, 0x1b	; 27
    2a44:	6f 2d       	mov	r22, r15
    2a46:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <setArpDebug>
    2a4a:	47 c0       	rjmp	.+142    	; 0x2ada <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }   
    
    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2a4c:	ce 01       	movw	r24, r28
    2a4e:	6c e6       	ldi	r22, 0x6C	; 108
    2a50:	77 e0       	ldi	r23, 0x07	; 7
    2a52:	42 e0       	ldi	r20, 0x02	; 2
    2a54:	50 e0       	ldi	r21, 0x00	; 0
    2a56:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    2a5a:	00 97       	sbiw	r24, 0x00	; 0
    2a5c:	49 f4       	brne	.+18     	; 0x2a70 <debugFunction+0x134>
    {
      setIpDebug(state->myStdInOut, level);
    2a5e:	d8 01       	movw	r26, r16
    2a60:	5a 96       	adiw	r26, 0x1a	; 26
    2a62:	8d 91       	ld	r24, X+
    2a64:	9c 91       	ld	r25, X
    2a66:	5b 97       	sbiw	r26, 0x1b	; 27
    2a68:	6f 2d       	mov	r22, r15
    2a6a:	0e 94 af 32 	call	0x655e	; 0x655e <setIpDebug>
    2a6e:	35 c0       	rjmp	.+106    	; 0x2ada <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2a70:	ce 01       	movw	r24, r28
    2a72:	67 e6       	ldi	r22, 0x67	; 103
    2a74:	77 e0       	ldi	r23, 0x07	; 7
    2a76:	42 e0       	ldi	r20, 0x02	; 2
    2a78:	50 e0       	ldi	r21, 0x00	; 0
    2a7a:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    2a7e:	00 97       	sbiw	r24, 0x00	; 0
    2a80:	49 f4       	brne	.+18     	; 0x2a94 <debugFunction+0x158>
    {
      setIcmpDebug(state->myStdInOut, level);
    2a82:	d8 01       	movw	r26, r16
    2a84:	5a 96       	adiw	r26, 0x1a	; 26
    2a86:	8d 91       	ld	r24, X+
    2a88:	9c 91       	ld	r25, X
    2a8a:	5b 97       	sbiw	r26, 0x1b	; 27
    2a8c:	6f 2d       	mov	r22, r15
    2a8e:	0e 94 7e 34 	call	0x68fc	; 0x68fc <setIcmpDebug>
    2a92:	23 c0       	rjmp	.+70     	; 0x2ada <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2a94:	ce 01       	movw	r24, r28
    2a96:	63 e6       	ldi	r22, 0x63	; 99
    2a98:	77 e0       	ldi	r23, 0x07	; 7
    2a9a:	42 e0       	ldi	r20, 0x02	; 2
    2a9c:	50 e0       	ldi	r21, 0x00	; 0
    2a9e:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    2aa2:	00 97       	sbiw	r24, 0x00	; 0
    2aa4:	49 f4       	brne	.+18     	; 0x2ab8 <debugFunction+0x17c>
    {
      setTcpDebug(state->myStdInOut, level);
    2aa6:	d8 01       	movw	r26, r16
    2aa8:	5a 96       	adiw	r26, 0x1a	; 26
    2aaa:	8d 91       	ld	r24, X+
    2aac:	9c 91       	ld	r25, X
    2aae:	5b 97       	sbiw	r26, 0x1b	; 27
    2ab0:	6f 2d       	mov	r22, r15
    2ab2:	0e 94 b1 3c 	call	0x7962	; 0x7962 <setTcpDebug>
    2ab6:	11 c0       	rjmp	.+34     	; 0x2ada <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }
    
    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2ab8:	ce 01       	movw	r24, r28
    2aba:	6f e5       	ldi	r22, 0x5F	; 95
    2abc:	77 e0       	ldi	r23, 0x07	; 7
    2abe:	42 e0       	ldi	r20, 0x02	; 2
    2ac0:	50 e0       	ldi	r21, 0x00	; 0
    2ac2:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    2ac6:	00 97       	sbiw	r24, 0x00	; 0
    2ac8:	41 f5       	brne	.+80     	; 0x2b1a <debugFunction+0x1de>
    {
      setUdpDebug(state->myStdInOut, level);
    2aca:	d8 01       	movw	r26, r16
    2acc:	5a 96       	adiw	r26, 0x1a	; 26
    2ace:	8d 91       	ld	r24, X+
    2ad0:	9c 91       	ld	r25, X
    2ad2:	5b 97       	sbiw	r26, 0x1b	; 27
    2ad4:	6f 2d       	mov	r22, r15
    2ad6:	0e 94 fe 3c 	call	0x79fc	; 0x79fc <setUdpDebug>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
    2ada:	00 d0       	rcall	.+0      	; 0x2adc <debugFunction+0x1a0>
    2adc:	00 d0       	rcall	.+0      	; 0x2ade <debugFunction+0x1a2>
    2ade:	ed b7       	in	r30, 0x3d	; 61
    2ae0:	fe b7       	in	r31, 0x3e	; 62
    2ae2:	31 96       	adiw	r30, 0x01	; 1
    2ae4:	d8 01       	movw	r26, r16
    2ae6:	5a 96       	adiw	r26, 0x1a	; 26
    2ae8:	8d 91       	ld	r24, X+
    2aea:	9c 91       	ld	r25, X
    2aec:	5b 97       	sbiw	r26, 0x1b	; 27
    2aee:	ad b7       	in	r26, 0x3d	; 61
    2af0:	be b7       	in	r27, 0x3e	; 62
    2af2:	11 96       	adiw	r26, 0x01	; 1
    2af4:	8d 93       	st	X+, r24
    2af6:	9c 93       	st	X, r25
    2af8:	12 97       	sbiw	r26, 0x02	; 2
    2afa:	8d e7       	ldi	r24, 0x7D	; 125
    2afc:	95 e0       	ldi	r25, 0x05	; 5
    2afe:	82 83       	std	Z+2, r24	; 0x02
    2b00:	93 83       	std	Z+3, r25	; 0x03
    2b02:	c4 83       	std	Z+4, r28	; 0x04
    2b04:	d5 83       	std	Z+5, r29	; 0x05
    2b06:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      return OK_SILENT;  
    2b0a:	ed b7       	in	r30, 0x3d	; 61
    2b0c:	fe b7       	in	r31, 0x3e	; 62
    2b0e:	36 96       	adiw	r30, 0x06	; 6
    2b10:	ed bf       	out	0x3d, r30	; 61
    2b12:	fe bf       	out	0x3e, r31	; 62
    2b14:	20 e0       	ldi	r18, 0x00	; 0
    2b16:	30 e0       	ldi	r19, 0x00	; 0
    2b18:	02 c0       	rjmp	.+4      	; 0x2b1e <debugFunction+0x1e2>
    }
  }
  
  return SYNTAX_ERROR;
    2b1a:	22 e0       	ldi	r18, 0x02	; 2
    2b1c:	30 e0       	ldi	r19, 0x00	; 0
}
    2b1e:	c9 01       	movw	r24, r18
    2b20:	df 91       	pop	r29
    2b22:	cf 91       	pop	r28
    2b24:	1f 91       	pop	r17
    2b26:	0f 91       	pop	r16
    2b28:	ff 90       	pop	r15
    2b2a:	08 95       	ret

00002b2c <statusEncFunction>:
  return OK_SILENT; 
}

static cliExRes_t statusEncFunction(cmdState_t *state)
{
  nicRegDump(state->myStdInOut);
    2b2c:	fc 01       	movw	r30, r24
    2b2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b30:	93 8d       	ldd	r25, Z+27	; 0x1b
    2b32:	0e 94 f4 2c 	call	0x59e8	; 0x59e8 <nicRegDump>
  return OK_SILENT;
}
    2b36:	80 e0       	ldi	r24, 0x00	; 0
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	08 95       	ret

00002b3c <readRamFIleFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
{
    2b3c:	df 92       	push	r13
    2b3e:	ef 92       	push	r14
    2b40:	ff 92       	push	r15
    2b42:	0f 93       	push	r16
    2b44:	1f 93       	push	r17
    2b46:	df 93       	push	r29
    2b48:	cf 93       	push	r28
    2b4a:	0f 92       	push	r0
    2b4c:	cd b7       	in	r28, 0x3d	; 61
    2b4e:	de b7       	in	r29, 0x3e	; 62
    2b50:	8c 01       	movw	r16, r24
  uint8_t rezultat;
  uint8_t znak = ' ';
    2b52:	80 e2       	ldi	r24, 0x20	; 32
    2b54:	89 83       	std	Y+1, r24	; 0x01
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
    2b56:	81 e0       	ldi	r24, 0x01	; 1
    2b58:	b8 01       	movw	r22, r16
    2b5a:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    2b5e:	64 ec       	ldi	r22, 0xC4	; 196
    2b60:	72 e3       	ldi	r23, 0x32	; 50
    2b62:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <ramDyskOtworzPlik>
    2b66:	d8 01       	movw	r26, r16
    2b68:	5a 96       	adiw	r26, 0x1a	; 26
    2b6a:	ed 90       	ld	r14, X+
    2b6c:	fc 90       	ld	r15, X
    2b6e:	5b 97       	sbiw	r26, 0x1b	; 27
    2b70:	88 23       	and	r24, r24
    2b72:	f9 f0       	breq	.+62     	; 0x2bb2 <readRamFIleFunction+0x76>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2b74:	81 e0       	ldi	r24, 0x01	; 1
    2b76:	b8 01       	movw	r22, r16
    2b78:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    2b7c:	00 d0       	rcall	.+0      	; 0x2b7e <readRamFIleFunction+0x42>
    2b7e:	00 d0       	rcall	.+0      	; 0x2b80 <readRamFIleFunction+0x44>
    2b80:	ed b7       	in	r30, 0x3d	; 61
    2b82:	fe b7       	in	r31, 0x3e	; 62
    2b84:	31 96       	adiw	r30, 0x01	; 1
    2b86:	ad b7       	in	r26, 0x3d	; 61
    2b88:	be b7       	in	r27, 0x3e	; 62
    2b8a:	11 96       	adiw	r26, 0x01	; 1
    2b8c:	ed 92       	st	X+, r14
    2b8e:	fc 92       	st	X, r15
    2b90:	12 97       	sbiw	r26, 0x02	; 2
    2b92:	2a ee       	ldi	r18, 0xEA	; 234
    2b94:	32 e0       	ldi	r19, 0x02	; 2
    2b96:	22 83       	std	Z+2, r18	; 0x02
    2b98:	33 83       	std	Z+3, r19	; 0x03
    2b9a:	84 83       	std	Z+4, r24	; 0x04
    2b9c:	95 83       	std	Z+5, r25	; 0x05
    2b9e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    return ERROR_INFORM;
    2ba2:	ed b7       	in	r30, 0x3d	; 61
    2ba4:	fe b7       	in	r31, 0x3e	; 62
    2ba6:	36 96       	adiw	r30, 0x06	; 6
    2ba8:	ed bf       	out	0x3d, r30	; 61
    2baa:	fe bf       	out	0x3e, r31	; 62
    2bac:	24 e0       	ldi	r18, 0x04	; 4
    2bae:	30 e0       	ldi	r19, 0x00	; 0
    2bb0:	54 c0       	rjmp	.+168    	; 0x2c5a <readRamFIleFunction+0x11e>
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    2bb2:	a0 91 c8 32 	lds	r26, 0x32C8
    2bb6:	b0 91 c9 32 	lds	r27, 0x32C9
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    2bba:	00 d0       	rcall	.+0      	; 0x2bbc <readRamFIleFunction+0x80>
    2bbc:	00 d0       	rcall	.+0      	; 0x2bbe <readRamFIleFunction+0x82>
    2bbe:	4d b7       	in	r20, 0x3d	; 61
    2bc0:	5e b7       	in	r21, 0x3e	; 62
    2bc2:	4f 5f       	subi	r20, 0xFF	; 255
    2bc4:	5f 4f       	sbci	r21, 0xFF	; 255
    2bc6:	ed b7       	in	r30, 0x3d	; 61
    2bc8:	fe b7       	in	r31, 0x3e	; 62
    2bca:	e1 82       	std	Z+1, r14	; 0x01
    2bcc:	f2 82       	std	Z+2, r15	; 0x02
    2bce:	88 ed       	ldi	r24, 0xD8	; 216
    2bd0:	94 e0       	ldi	r25, 0x04	; 4
    2bd2:	fa 01       	movw	r30, r20
    2bd4:	82 83       	std	Z+2, r24	; 0x02
    2bd6:	93 83       	std	Z+3, r25	; 0x03
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    2bd8:	12 96       	adiw	r26, 0x02	; 2
    2bda:	9c 91       	ld	r25, X
    2bdc:	12 97       	sbiw	r26, 0x02	; 2
    2bde:	80 e0       	ldi	r24, 0x00	; 0
    2be0:	11 96       	adiw	r26, 0x01	; 1
    2be2:	2c 91       	ld	r18, X
    2be4:	82 0f       	add	r24, r18
    2be6:	91 1d       	adc	r25, r1
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    2be8:	84 83       	std	Z+4, r24	; 0x04
    2bea:	95 83       	std	Z+5, r25	; 0x05
    2bec:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    2bf0:	8d b7       	in	r24, 0x3d	; 61
    2bf2:	9e b7       	in	r25, 0x3e	; 62
    2bf4:	06 96       	adiw	r24, 0x06	; 6
    2bf6:	8d bf       	out	0x3d, r24	; 61
    2bf8:	9e bf       	out	0x3e, r25	; 62
  while (rezultat == 0)
  {
    rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
    2bfa:	7e 01       	movw	r14, r28
    2bfc:	08 94       	sec
    2bfe:	e1 1c       	adc	r14, r1
    2c00:	f1 1c       	adc	r15, r1
    2c02:	84 ec       	ldi	r24, 0xC4	; 196
    2c04:	92 e3       	ldi	r25, 0x32	; 50
    2c06:	b7 01       	movw	r22, r14
    2c08:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <ramDyskCzytajBajtZPliku>
    2c0c:	d8 2e       	mov	r13, r24
    
    uartVtySendByte(znak);
    2c0e:	89 81       	ldd	r24, Y+1	; 0x01
    2c10:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
    if (znak == '\r')
    2c14:	89 81       	ldd	r24, Y+1	; 0x01
    2c16:	8d 30       	cpi	r24, 0x0D	; 13
    2c18:	19 f4       	brne	.+6      	; 0x2c20 <readRamFIleFunction+0xe4>
      uartVtySendByte('\n');
    2c1a:	8a e0       	ldi	r24, 0x0A	; 10
    2c1c:	0e 94 cb 0a 	call	0x1596	; 0x1596 <uartVtySendByte>
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
  while (rezultat == 0)
    2c20:	dd 20       	and	r13, r13
    2c22:	79 f3       	breq	.-34     	; 0x2c02 <readRamFIleFunction+0xc6>
    
    uartVtySendByte(znak);
    if (znak == '\r')
      uartVtySendByte('\n');
  }
  fprintf_P(state->myStdInOut, nlStr);
    2c24:	00 d0       	rcall	.+0      	; 0x2c26 <readRamFIleFunction+0xea>
    2c26:	0f 92       	push	r0
    2c28:	d8 01       	movw	r26, r16
    2c2a:	5a 96       	adiw	r26, 0x1a	; 26
    2c2c:	8d 91       	ld	r24, X+
    2c2e:	9c 91       	ld	r25, X
    2c30:	5b 97       	sbiw	r26, 0x1b	; 27
    2c32:	ed b7       	in	r30, 0x3d	; 61
    2c34:	fe b7       	in	r31, 0x3e	; 62
    2c36:	81 83       	std	Z+1, r24	; 0x01
    2c38:	92 83       	std	Z+2, r25	; 0x02
    2c3a:	83 e5       	ldi	r24, 0x53	; 83
    2c3c:	96 e0       	ldi	r25, 0x06	; 6
    2c3e:	83 83       	std	Z+3, r24	; 0x03
    2c40:	94 83       	std	Z+4, r25	; 0x04
    2c42:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  ramDyskZamknijPlik(&fdVty);
    2c46:	0f 90       	pop	r0
    2c48:	0f 90       	pop	r0
    2c4a:	0f 90       	pop	r0
    2c4c:	0f 90       	pop	r0
    2c4e:	84 ec       	ldi	r24, 0xC4	; 196
    2c50:	92 e3       	ldi	r25, 0x32	; 50
    2c52:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ramDyskZamknijPlik>
  return OK_SILENT;
    2c56:	20 e0       	ldi	r18, 0x00	; 0
    2c58:	30 e0       	ldi	r19, 0x00	; 0
}
    2c5a:	c9 01       	movw	r24, r18
    2c5c:	0f 90       	pop	r0
    2c5e:	cf 91       	pop	r28
    2c60:	df 91       	pop	r29
    2c62:	1f 91       	pop	r17
    2c64:	0f 91       	pop	r16
    2c66:	ff 90       	pop	r15
    2c68:	ef 90       	pop	r14
    2c6a:	df 90       	pop	r13
    2c6c:	08 95       	ret

00002c6e <writeRamFileFunction>:
  return ERROR_INFORM;
}

static cliExRes_t writeRamFileFunction(cmdState_t *state)
{
  ramDyskDir(state->myStdInOut);
    2c6e:	fc 01       	movw	r30, r24
    2c70:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c72:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c74:	0e 94 bc 20 	call	0x4178	; 0x4178 <ramDyskDir>
  return OK_SILENT;
}
    2c78:	80 e0       	ldi	r24, 0x00	; 0
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	08 95       	ret

00002c7e <pokazCzasFunction>:
  nicRegDump(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
    2c7e:	cf 93       	push	r28
    2c80:	df 93       	push	r29
    2c82:	ec 01       	movw	r28, r24
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
    2c84:	85 e1       	ldi	r24, 0x15	; 21
    2c86:	92 e3       	ldi	r25, 0x32	; 50
    2c88:	0e 94 ab 27 	call	0x4f56	; 0x4f56 <readTimeDecoded>
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    2c8c:	40 91 17 32 	lds	r20, 0x3217
    2c90:	46 95       	lsr	r20
    2c92:	46 95       	lsr	r20
    2c94:	46 95       	lsr	r20
    2c96:	70 91 17 32 	lds	r23, 0x3217
    2c9a:	7f 70       	andi	r23, 0x0F	; 15
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2c9c:	30 91 16 32 	lds	r19, 0x3216
    2ca0:	36 95       	lsr	r19
    2ca2:	36 95       	lsr	r19
    2ca4:	36 95       	lsr	r19
    2ca6:	60 91 16 32 	lds	r22, 0x3216
    2caa:	6f 70       	andi	r22, 0x0F	; 15
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    2cac:	20 91 15 32 	lds	r18, 0x3215
    2cb0:	26 95       	lsr	r18
    2cb2:	26 95       	lsr	r18
    2cb4:	26 95       	lsr	r18
    2cb6:	50 91 15 32 	lds	r21, 0x3215
    2cba:	5f 70       	andi	r21, 0x0F	; 15
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2cbc:	8d b7       	in	r24, 0x3d	; 61
    2cbe:	9e b7       	in	r25, 0x3e	; 62
    2cc0:	0a 97       	sbiw	r24, 0x0a	; 10
    2cc2:	8d bf       	out	0x3d, r24	; 61
    2cc4:	9e bf       	out	0x3e, r25	; 62
    2cc6:	ed b7       	in	r30, 0x3d	; 61
    2cc8:	fe b7       	in	r31, 0x3e	; 62
    2cca:	31 96       	adiw	r30, 0x01	; 1
    2ccc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2cce:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2cd0:	ad b7       	in	r26, 0x3d	; 61
    2cd2:	be b7       	in	r27, 0x3e	; 62
    2cd4:	11 96       	adiw	r26, 0x01	; 1
    2cd6:	8d 93       	st	X+, r24
    2cd8:	9c 93       	st	X, r25
    2cda:	12 97       	sbiw	r26, 0x02	; 2
    2cdc:	87 e8       	ldi	r24, 0x87	; 135
    2cde:	97 e0       	ldi	r25, 0x07	; 7
    2ce0:	82 83       	std	Z+2, r24	; 0x02
    2ce2:	93 83       	std	Z+3, r25	; 0x03
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    2ce4:	46 70       	andi	r20, 0x06	; 6
    2ce6:	84 2f       	mov	r24, r20
    2ce8:	88 0f       	add	r24, r24
    2cea:	88 0f       	add	r24, r24
    2cec:	84 0f       	add	r24, r20
    2cee:	87 0f       	add	r24, r23
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2cf0:	84 83       	std	Z+4, r24	; 0x04
    2cf2:	15 82       	std	Z+5, r1	; 0x05

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2cf4:	3e 70       	andi	r19, 0x0E	; 14
    2cf6:	83 2f       	mov	r24, r19
    2cf8:	88 0f       	add	r24, r24
    2cfa:	88 0f       	add	r24, r24
    2cfc:	83 0f       	add	r24, r19
    2cfe:	86 0f       	add	r24, r22
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2d00:	86 83       	std	Z+6, r24	; 0x06
    2d02:	17 82       	std	Z+7, r1	; 0x07
static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    2d04:	2e 70       	andi	r18, 0x0E	; 14
    2d06:	82 2f       	mov	r24, r18
    2d08:	88 0f       	add	r24, r24
    2d0a:	88 0f       	add	r24, r24
    2d0c:	82 0f       	add	r24, r18
    2d0e:	85 0f       	add	r24, r21
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2d10:	80 87       	std	Z+8, r24	; 0x08
    2d12:	11 86       	std	Z+9, r1	; 0x09
    2d14:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    2d18:	8d b7       	in	r24, 0x3d	; 61
    2d1a:	9e b7       	in	r25, 0x3e	; 62
    2d1c:	0a 96       	adiw	r24, 0x0a	; 10
    2d1e:	8d bf       	out	0x3d, r24	; 61
    2d20:	9e bf       	out	0x3e, r25	; 62
  return OK_SILENT;
}
    2d22:	80 e0       	ldi	r24, 0x00	; 0
    2d24:	90 e0       	ldi	r25, 0x00	; 0
    2d26:	df 91       	pop	r29
    2d28:	cf 91       	pop	r28
    2d2a:	08 95       	ret

00002d2c <helpFunction>:
  return OK_SILENT;
}

static cliExRes_t helpFunction(cmdState_t *state)
{
  cmdPrintHelp(state);
    2d2c:	0e 94 73 26 	call	0x4ce6	; 0x4ce6 <cmdPrintHelp>
  return OK_SILENT;
}
    2d30:	80 e0       	ldi	r24, 0x00	; 0
    2d32:	90 e0       	ldi	r25, 0x00	; 0
    2d34:	08 95       	ret

00002d36 <VtyInit>:
  {cmd_disable,      cmd_help_disable,      disableFunction},
  {NULL, NULL, NULL}
};

void VtyInit(cmdState_t* state, FILE *stream)
{
    2d36:	ef 92       	push	r14
    2d38:	0f 93       	push	r16
    2d3a:	1f 93       	push	r17
    2d3c:	9b 01       	movw	r18, r22
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
    2d3e:	60 e0       	ldi	r22, 0x00	; 0
    2d40:	78 e2       	ldi	r23, 0x28	; 40
    2d42:	40 e0       	ldi	r20, 0x00	; 0
    2d44:	51 e0       	ldi	r21, 0x01	; 1
    2d46:	08 e9       	ldi	r16, 0x98	; 152
    2d48:	16 e0       	ldi	r17, 0x06	; 6
    2d4a:	ee 24       	eor	r14, r14
    2d4c:	0e 94 88 22 	call	0x4510	; 0x4510 <cmdStateConfigure>
}
    2d50:	1f 91       	pop	r17
    2d52:	0f 91       	pop	r16
    2d54:	ef 90       	pop	r14
    2d56:	08 95       	ret

00002d58 <printErrorInfo>:

void printErrorInfo(cmdState_t *state)
{
    2d58:	cf 93       	push	r28
    2d5a:	df 93       	push	r29
    2d5c:	ec 01       	movw	r28, r24
  if (state->errno != 0)
    2d5e:	ec 8d       	ldd	r30, Y+28	; 0x1c
    2d60:	ee 23       	and	r30, r30
    2d62:	49 f1       	breq	.+82     	; 0x2db6 <printErrorInfo+0x5e>
  {
    fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->err1, state->err2);
    2d64:	f0 e0       	ldi	r31, 0x00	; 0
    2d66:	ee 0f       	add	r30, r30
    2d68:	ff 1f       	adc	r31, r31
    2d6a:	e0 58       	subi	r30, 0x80	; 128
    2d6c:	f9 4f       	sbci	r31, 0xF9	; 249
    2d6e:	85 91       	lpm	r24, Z+
    2d70:	94 91       	lpm	r25, Z+
    2d72:	2d b7       	in	r18, 0x3d	; 61
    2d74:	3e b7       	in	r19, 0x3e	; 62
    2d76:	28 50       	subi	r18, 0x08	; 8
    2d78:	30 40       	sbci	r19, 0x00	; 0
    2d7a:	2d bf       	out	0x3d, r18	; 61
    2d7c:	3e bf       	out	0x3e, r19	; 62
    2d7e:	ed b7       	in	r30, 0x3d	; 61
    2d80:	fe b7       	in	r31, 0x3e	; 62
    2d82:	31 96       	adiw	r30, 0x01	; 1
    2d84:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2d86:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2d88:	ad b7       	in	r26, 0x3d	; 61
    2d8a:	be b7       	in	r27, 0x3e	; 62
    2d8c:	11 96       	adiw	r26, 0x01	; 1
    2d8e:	2d 93       	st	X+, r18
    2d90:	3c 93       	st	X, r19
    2d92:	12 97       	sbiw	r26, 0x02	; 2
    2d94:	82 83       	std	Z+2, r24	; 0x02
    2d96:	93 83       	std	Z+3, r25	; 0x03
    2d98:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2d9a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2d9c:	84 83       	std	Z+4, r24	; 0x04
    2d9e:	95 83       	std	Z+5, r25	; 0x05
    2da0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2da2:	86 83       	std	Z+6, r24	; 0x06
    2da4:	17 82       	std	Z+7, r1	; 0x07
    2da6:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    2daa:	2d b7       	in	r18, 0x3d	; 61
    2dac:	3e b7       	in	r19, 0x3e	; 62
    2dae:	28 5f       	subi	r18, 0xF8	; 248
    2db0:	3f 4f       	sbci	r19, 0xFF	; 255
    2db2:	2d bf       	out	0x3d, r18	; 61
    2db4:	3e bf       	out	0x3e, r19	; 62
  }
  state->errno = 0;
    2db6:	1c 8e       	std	Y+28, r1	; 0x1c
  state->err1 = 0;
    2db8:	1d 8e       	std	Y+29, r1	; 0x1d
    2dba:	1e 8e       	std	Y+30, r1	; 0x1e
  state->err2 = 0;
    2dbc:	1f 8e       	std	Y+31, r1	; 0x1f
}
    2dbe:	df 91       	pop	r29
    2dc0:	cf 91       	pop	r28
    2dc2:	08 95       	ret

00002dc4 <eraseRamFileFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
    2dc4:	cf 93       	push	r28
    2dc6:	df 93       	push	r29
    2dc8:	ec 01       	movw	r28, r24
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    2dca:	81 e0       	ldi	r24, 0x01	; 1
    2dcc:	be 01       	movw	r22, r28
    2dce:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    2dd2:	0e 94 c7 1d 	call	0x3b8e	; 0x3b8e <ramDyskUsunPlik>
    2dd6:	88 23       	and	r24, r24
    2dd8:	31 f0       	breq	.+12     	; 0x2de6 <eraseRamFileFunction+0x22>
    return OK_INFORM;

  printErrorInfo(state);
    2dda:	ce 01       	movw	r24, r28
    2ddc:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <printErrorInfo>
  return ERROR_INFORM;
    2de0:	24 e0       	ldi	r18, 0x04	; 4
    2de2:	30 e0       	ldi	r19, 0x00	; 0
    2de4:	02 c0       	rjmp	.+4      	; 0x2dea <eraseRamFileFunction+0x26>
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    return OK_INFORM;
    2de6:	21 e0       	ldi	r18, 0x01	; 1
    2de8:	30 e0       	ldi	r19, 0x00	; 0

  printErrorInfo(state);
  return ERROR_INFORM;
}
    2dea:	c9 01       	movw	r24, r18
    2dec:	df 91       	pop	r29
    2dee:	cf 91       	pop	r28
    2df0:	08 95       	ret

00002df2 <dodajRamPlikFunction>:

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
    2df2:	cf 93       	push	r28
    2df4:	df 93       	push	r29
    2df6:	ec 01       	movw	r28, r24
  if (state->argc != 1)
    2df8:	89 8d       	ldd	r24, Y+25	; 0x19
    2dfa:	81 30       	cpi	r24, 0x01	; 1
    2dfc:	69 f4       	brne	.+26     	; 0x2e18 <dodajRamPlikFunction+0x26>
    return SYNTAX_ERROR;

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
    2dfe:	be 01       	movw	r22, r28
    2e00:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    2e04:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <ramDyskUtworzPlik>
    2e08:	88 23       	and	r24, r24
    2e0a:	49 f0       	breq	.+18     	; 0x2e1e <dodajRamPlikFunction+0x2c>
  {
    return OK_INFORM;
  }
  printErrorInfo(state);
    2e0c:	ce 01       	movw	r24, r28
    2e0e:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <printErrorInfo>
  return ERROR_INFORM;
    2e12:	24 e0       	ldi	r18, 0x04	; 4
    2e14:	30 e0       	ldi	r19, 0x00	; 0
    2e16:	05 c0       	rjmp	.+10     	; 0x2e22 <dodajRamPlikFunction+0x30>
}

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
  if (state->argc != 1)
    return SYNTAX_ERROR;
    2e18:	22 e0       	ldi	r18, 0x02	; 2
    2e1a:	30 e0       	ldi	r19, 0x00	; 0
    2e1c:	02 c0       	rjmp	.+4      	; 0x2e22 <dodajRamPlikFunction+0x30>

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
  {
    return OK_INFORM;
    2e1e:	21 e0       	ldi	r18, 0x01	; 1
    2e20:	30 e0       	ldi	r19, 0x00	; 0
  }
  printErrorInfo(state);
  return ERROR_INFORM;
}
    2e22:	c9 01       	movw	r24, r18
    2e24:	df 91       	pop	r29
    2e26:	cf 91       	pop	r28
    2e28:	08 95       	ret

00002e2a <flashExModuleFunction>:
  return OK_SILENT;
}


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
    2e2a:	ff 92       	push	r15
    2e2c:	0f 93       	push	r16
    2e2e:	1f 93       	push	r17
    2e30:	cf 93       	push	r28
    2e32:	df 93       	push	r29
    2e34:	ec 01       	movw	r28, r24
  if (state->argc != 2)
    2e36:	89 8d       	ldd	r24, Y+25	; 0x19
    2e38:	82 30       	cpi	r24, 0x02	; 2
    2e3a:	09 f0       	breq	.+2      	; 0x2e3e <flashExModuleFunction+0x14>
    2e3c:	46 c0       	rjmp	.+140    	; 0x2eca <flashExModuleFunction+0xa0>
    return SYNTAX_ERROR;
  
  uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
    2e3e:	81 e0       	ldi	r24, 0x01	; 1
    2e40:	be 01       	movw	r22, r28
    2e42:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
    2e46:	f6 2e       	mov	r15, r22
  char *nazwaPliku      = cmdlineGetArgStr(2, state);
    2e48:	82 e0       	ldi	r24, 0x02	; 2
    2e4a:	be 01       	movw	r22, r28
    2e4c:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    2e50:	8c 01       	movw	r16, r24
  uint8_t  blad;
  
  // Sprawdzanie, czy moduł wykonawczy odpowiada
  if (rs485ping(nrUrzadzenia) != 0)
    2e52:	8f 2d       	mov	r24, r15
    2e54:	0e 94 59 40 	call	0x80b2	; 0x80b2 <rs485ping>
    2e58:	88 23       	and	r24, r24
    2e5a:	31 f0       	breq	.+12     	; 0x2e68 <flashExModuleFunction+0x3e>
  {
    state->errno = noRemoteDevice;
    2e5c:	89 e0       	ldi	r24, 0x09	; 9
    2e5e:	8c 8f       	std	Y+28, r24	; 0x1c
    printErrorInfo(state);
    2e60:	ce 01       	movw	r24, r28
    2e62:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <printErrorInfo>
    2e66:	2e c0       	rjmp	.+92     	; 0x2ec4 <flashExModuleFunction+0x9a>
    return ERROR_INFORM;
  }
  
  //Sprawdzanie, czy istnieje odpowiedni plik z firmware
  if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
    2e68:	c8 01       	movw	r24, r16
    2e6a:	64 ec       	ldi	r22, 0xC4	; 196
    2e6c:	72 e3       	ldi	r23, 0x32	; 50
    2e6e:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <ramDyskOtworzPlik>
    2e72:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2e74:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2e76:	88 23       	and	r24, r24
    2e78:	c9 f0       	breq	.+50     	; 0x2eac <flashExModuleFunction+0x82>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
    2e7a:	00 d0       	rcall	.+0      	; 0x2e7c <flashExModuleFunction+0x52>
    2e7c:	00 d0       	rcall	.+0      	; 0x2e7e <flashExModuleFunction+0x54>
    2e7e:	ed b7       	in	r30, 0x3d	; 61
    2e80:	fe b7       	in	r31, 0x3e	; 62
    2e82:	31 96       	adiw	r30, 0x01	; 1
    2e84:	ad b7       	in	r26, 0x3d	; 61
    2e86:	be b7       	in	r27, 0x3e	; 62
    2e88:	11 96       	adiw	r26, 0x01	; 1
    2e8a:	4d 93       	st	X+, r20
    2e8c:	5c 93       	st	X, r21
    2e8e:	12 97       	sbiw	r26, 0x02	; 2
    2e90:	8a ee       	ldi	r24, 0xEA	; 234
    2e92:	92 e0       	ldi	r25, 0x02	; 2
    2e94:	82 83       	std	Z+2, r24	; 0x02
    2e96:	93 83       	std	Z+3, r25	; 0x03
    2e98:	04 83       	std	Z+4, r16	; 0x04
    2e9a:	15 83       	std	Z+5, r17	; 0x05
    2e9c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    return ERROR_INFORM;
    2ea0:	8d b7       	in	r24, 0x3d	; 61
    2ea2:	9e b7       	in	r25, 0x3e	; 62
    2ea4:	06 96       	adiw	r24, 0x06	; 6
    2ea6:	8d bf       	out	0x3d, r24	; 61
    2ea8:	9e bf       	out	0x3e, r25	; 62
    2eaa:	0c c0       	rjmp	.+24     	; 0x2ec4 <flashExModuleFunction+0x9a>
  }
  
  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
    2eac:	84 ec       	ldi	r24, 0xC4	; 196
    2eae:	92 e3       	ldi	r25, 0x32	; 50
    2eb0:	6f 2d       	mov	r22, r15
    2eb2:	0e 94 69 42 	call	0x84d2	; 0x84d2 <rs485xModemFlash>
    2eb6:	08 2f       	mov	r16, r24

  ramDyskZamknijPlik(&fdVty);
    2eb8:	84 ec       	ldi	r24, 0xC4	; 196
    2eba:	92 e3       	ldi	r25, 0x32	; 50
    2ebc:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ramDyskZamknijPlik>
  
  if (blad != 0)
    2ec0:	00 23       	and	r16, r16
    2ec2:	31 f0       	breq	.+12     	; 0x2ed0 <flashExModuleFunction+0xa6>
    return ERROR_INFORM;
    2ec4:	24 e0       	ldi	r18, 0x04	; 4
    2ec6:	30 e0       	ldi	r19, 0x00	; 0
    2ec8:	05 c0       	rjmp	.+10     	; 0x2ed4 <flashExModuleFunction+0xaa>


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
  if (state->argc != 2)
    return SYNTAX_ERROR;
    2eca:	22 e0       	ldi	r18, 0x02	; 2
    2ecc:	30 e0       	ldi	r19, 0x00	; 0
    2ece:	02 c0       	rjmp	.+4      	; 0x2ed4 <flashExModuleFunction+0xaa>
  ramDyskZamknijPlik(&fdVty);
  
  if (blad != 0)
    return ERROR_INFORM;

  return OK_SILENT;
    2ed0:	20 e0       	ldi	r18, 0x00	; 0
    2ed2:	30 e0       	ldi	r19, 0x00	; 0
}
    2ed4:	c9 01       	movw	r24, r18
    2ed6:	df 91       	pop	r29
    2ed8:	cf 91       	pop	r28
    2eda:	1f 91       	pop	r17
    2edc:	0f 91       	pop	r16
    2ede:	ff 90       	pop	r15
    2ee0:	08 95       	ret

00002ee2 <rpingFunction>:
  
  return OK_SILENT;
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
    2ee2:	0f 93       	push	r16
    2ee4:	1f 93       	push	r17
    2ee6:	df 93       	push	r29
    2ee8:	cf 93       	push	r28
    2eea:	0f 92       	push	r0
    2eec:	cd b7       	in	r28, 0x3d	; 61
    2eee:	de b7       	in	r29, 0x3e	; 62
    2ef0:	8c 01       	movw	r16, r24
  if (state->argc < 1)
    2ef2:	fc 01       	movw	r30, r24
    2ef4:	81 8d       	ldd	r24, Z+25	; 0x19
    2ef6:	88 23       	and	r24, r24
    2ef8:	b9 f0       	breq	.+46     	; 0x2f28 <rpingFunction+0x46>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	b8 01       	movw	r22, r16
    2efe:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <cmdlineGetArgInt>
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    2f02:	86 2f       	mov	r24, r22
    2f04:	69 83       	std	Y+1, r22	; 0x01
    2f06:	0e 94 59 40 	call	0x80b2	; 0x80b2 <rs485ping>
    2f0a:	f8 01       	movw	r30, r16
    2f0c:	87 8f       	std	Z+31, r24	; 0x1f
    2f0e:	69 81       	ldd	r22, Y+1	; 0x01
    2f10:	88 23       	and	r24, r24
    2f12:	69 f0       	breq	.+26     	; 0x2f2e <rpingFunction+0x4c>
    return OK_INFORM;

  state->errno = noRemoteDevice;
    2f14:	89 e0       	ldi	r24, 0x09	; 9
    2f16:	84 8f       	std	Z+28, r24	; 0x1c
  state->err1 = nrSterownika;
    2f18:	65 8f       	std	Z+29, r22	; 0x1d
    2f1a:	16 8e       	std	Z+30, r1	; 0x1e
  printErrorInfo(state);
    2f1c:	c8 01       	movw	r24, r16
    2f1e:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <printErrorInfo>
  return OK_SILENT;
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	30 e0       	ldi	r19, 0x00	; 0
    2f26:	05 c0       	rjmp	.+10     	; 0x2f32 <rpingFunction+0x50>
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    2f28:	22 e0       	ldi	r18, 0x02	; 2
    2f2a:	30 e0       	ldi	r19, 0x00	; 0
    2f2c:	02 c0       	rjmp	.+4      	; 0x2f32 <rpingFunction+0x50>
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    return OK_INFORM;
    2f2e:	21 e0       	ldi	r18, 0x01	; 1
    2f30:	30 e0       	ldi	r19, 0x00	; 0

  state->errno = noRemoteDevice;
  state->err1 = nrSterownika;
  printErrorInfo(state);
  return OK_SILENT;
}
    2f32:	c9 01       	movw	r24, r18
    2f34:	0f 90       	pop	r0
    2f36:	cf 91       	pop	r28
    2f38:	df 91       	pop	r29
    2f3a:	1f 91       	pop	r17
    2f3c:	0f 91       	pop	r16
    2f3e:	08 95       	ret

00002f40 <printStatus>:
  return ERROR_OPERATION_NOT_ALLOWED;
}

// ************************** VTY API ***************************************************************************************
void printStatus(FILE *stream)
{
    2f40:	cf 93       	push	r28
    2f42:	df 93       	push	r29
    2f44:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
    2f46:	00 d0       	rcall	.+0      	; 0x2f48 <printStatus+0x8>
    2f48:	0f 92       	push	r0
    2f4a:	ad b7       	in	r26, 0x3d	; 61
    2f4c:	be b7       	in	r27, 0x3e	; 62
    2f4e:	11 96       	adiw	r26, 0x01	; 1
    2f50:	8d 93       	st	X+, r24
    2f52:	9c 93       	st	X, r25
    2f54:	12 97       	sbiw	r26, 0x02	; 2
    2f56:	8c ea       	ldi	r24, 0xAC	; 172
    2f58:	97 e0       	ldi	r25, 0x07	; 7
    2f5a:	13 96       	adiw	r26, 0x03	; 3
    2f5c:	8d 93       	st	X+, r24
    2f5e:	9c 93       	st	X, r25
    2f60:	14 97       	sbiw	r26, 0x04	; 4
    2f62:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  //Print system state
  fprintf_P(stream, systemStateStr);
    2f66:	ed b7       	in	r30, 0x3d	; 61
    2f68:	fe b7       	in	r31, 0x3e	; 62
    2f6a:	c1 83       	std	Z+1, r28	; 0x01
    2f6c:	d2 83       	std	Z+2, r29	; 0x02
    2f6e:	8f ef       	ldi	r24, 0xFF	; 255
    2f70:	92 e0       	ldi	r25, 0x02	; 2
    2f72:	83 83       	std	Z+3, r24	; 0x03
    2f74:	94 83       	std	Z+4, r25	; 0x04
    2f76:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
    2f7a:	0f 90       	pop	r0
    2f7c:	0f 90       	pop	r0
    2f7e:	0f 90       	pop	r0
    2f80:	0f 90       	pop	r0
    2f82:	0e 94 e3 48 	call	0x91c6	; 0x91c6 <uxTaskGetNumberOfTasks>
    2f86:	00 d0       	rcall	.+0      	; 0x2f88 <printStatus+0x48>
    2f88:	00 d0       	rcall	.+0      	; 0x2f8a <printStatus+0x4a>
    2f8a:	ed b7       	in	r30, 0x3d	; 61
    2f8c:	fe b7       	in	r31, 0x3e	; 62
    2f8e:	31 96       	adiw	r30, 0x01	; 1
    2f90:	ad b7       	in	r26, 0x3d	; 61
    2f92:	be b7       	in	r27, 0x3e	; 62
    2f94:	11 96       	adiw	r26, 0x01	; 1
    2f96:	cd 93       	st	X+, r28
    2f98:	dc 93       	st	X, r29
    2f9a:	12 97       	sbiw	r26, 0x02	; 2
    2f9c:	2f e0       	ldi	r18, 0x0F	; 15
    2f9e:	33 e0       	ldi	r19, 0x03	; 3
    2fa0:	22 83       	std	Z+2, r18	; 0x02
    2fa2:	33 83       	std	Z+3, r19	; 0x03
    2fa4:	84 83       	std	Z+4, r24	; 0x04
    2fa6:	15 82       	std	Z+5, r1	; 0x05
    2fa8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
    2fac:	ed b7       	in	r30, 0x3d	; 61
    2fae:	fe b7       	in	r31, 0x3e	; 62
    2fb0:	36 96       	adiw	r30, 0x06	; 6
    2fb2:	ed bf       	out	0x3d, r30	; 61
    2fb4:	fe bf       	out	0x3e, r31	; 62
    2fb6:	0e 94 93 52 	call	0xa526	; 0xa526 <xPortGetFreeHeapSize>
    2fba:	2d b7       	in	r18, 0x3d	; 61
    2fbc:	3e b7       	in	r19, 0x3e	; 62
    2fbe:	28 50       	subi	r18, 0x08	; 8
    2fc0:	30 40       	sbci	r19, 0x00	; 0
    2fc2:	2d bf       	out	0x3d, r18	; 61
    2fc4:	3e bf       	out	0x3e, r19	; 62
    2fc6:	ed b7       	in	r30, 0x3d	; 61
    2fc8:	fe b7       	in	r31, 0x3e	; 62
    2fca:	31 96       	adiw	r30, 0x01	; 1
    2fcc:	ad b7       	in	r26, 0x3d	; 61
    2fce:	be b7       	in	r27, 0x3e	; 62
    2fd0:	11 96       	adiw	r26, 0x01	; 1
    2fd2:	cd 93       	st	X+, r28
    2fd4:	dc 93       	st	X, r29
    2fd6:	12 97       	sbiw	r26, 0x02	; 2
    2fd8:	28 e2       	ldi	r18, 0x28	; 40
    2fda:	33 e0       	ldi	r19, 0x03	; 3
    2fdc:	22 83       	std	Z+2, r18	; 0x02
    2fde:	33 83       	std	Z+3, r19	; 0x03
    2fe0:	84 83       	std	Z+4, r24	; 0x04
    2fe2:	95 83       	std	Z+5, r25	; 0x05
    2fe4:	88 eb       	ldi	r24, 0xB8	; 184
    2fe6:	9b e0       	ldi	r25, 0x0B	; 11
    2fe8:	86 83       	std	Z+6, r24	; 0x06
    2fea:	97 83       	std	Z+7, r25	; 0x07
    2fec:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
    2ff0:	ed b7       	in	r30, 0x3d	; 61
    2ff2:	fe b7       	in	r31, 0x3e	; 62
    2ff4:	38 96       	adiw	r30, 0x08	; 8
    2ff6:	ed bf       	out	0x3d, r30	; 61
    2ff8:	fe bf       	out	0x3e, r31	; 62
    2ffa:	0e 94 29 1c 	call	0x3852	; 0x3852 <xmallocAvailable>
    2ffe:	2d b7       	in	r18, 0x3d	; 61
    3000:	3e b7       	in	r19, 0x3e	; 62
    3002:	28 50       	subi	r18, 0x08	; 8
    3004:	30 40       	sbci	r19, 0x00	; 0
    3006:	2d bf       	out	0x3d, r18	; 61
    3008:	3e bf       	out	0x3e, r19	; 62
    300a:	ed b7       	in	r30, 0x3d	; 61
    300c:	fe b7       	in	r31, 0x3e	; 62
    300e:	31 96       	adiw	r30, 0x01	; 1
    3010:	ad b7       	in	r26, 0x3d	; 61
    3012:	be b7       	in	r27, 0x3e	; 62
    3014:	11 96       	adiw	r26, 0x01	; 1
    3016:	cd 93       	st	X+, r28
    3018:	dc 93       	st	X, r29
    301a:	12 97       	sbiw	r26, 0x02	; 2
    301c:	22 e5       	ldi	r18, 0x52	; 82
    301e:	33 e0       	ldi	r19, 0x03	; 3
    3020:	22 83       	std	Z+2, r18	; 0x02
    3022:	33 83       	std	Z+3, r19	; 0x03
    3024:	84 83       	std	Z+4, r24	; 0x04
    3026:	95 83       	std	Z+5, r25	; 0x05
    3028:	80 e0       	ldi	r24, 0x00	; 0
    302a:	97 e1       	ldi	r25, 0x17	; 23
    302c:	86 83       	std	Z+6, r24	; 0x06
    302e:	97 83       	std	Z+7, r25	; 0x07
    3030:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, statusTemperatureStr, temperature); 
    3034:	20 91 04 32 	lds	r18, 0x3204
    3038:	0f 90       	pop	r0
    303a:	0f 90       	pop	r0
    303c:	ed b7       	in	r30, 0x3d	; 61
    303e:	fe b7       	in	r31, 0x3e	; 62
    3040:	31 96       	adiw	r30, 0x01	; 1
    3042:	ad b7       	in	r26, 0x3d	; 61
    3044:	be b7       	in	r27, 0x3e	; 62
    3046:	11 96       	adiw	r26, 0x01	; 1
    3048:	cd 93       	st	X+, r28
    304a:	dc 93       	st	X, r29
    304c:	12 97       	sbiw	r26, 0x02	; 2
    304e:	89 ea       	ldi	r24, 0xA9	; 169
    3050:	93 e0       	ldi	r25, 0x03	; 3
    3052:	82 83       	std	Z+2, r24	; 0x02
    3054:	93 83       	std	Z+3, r25	; 0x03
    3056:	24 83       	std	Z+4, r18	; 0x04
    3058:	15 82       	std	Z+5, r1	; 0x05
    305a:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, statusVoltageStr, voltage); 
    305e:	20 91 0c 32 	lds	r18, 0x320C
    3062:	ed b7       	in	r30, 0x3d	; 61
    3064:	fe b7       	in	r31, 0x3e	; 62
    3066:	31 96       	adiw	r30, 0x01	; 1
    3068:	ad b7       	in	r26, 0x3d	; 61
    306a:	be b7       	in	r27, 0x3e	; 62
    306c:	11 96       	adiw	r26, 0x01	; 1
    306e:	cd 93       	st	X+, r28
    3070:	dc 93       	st	X, r29
    3072:	12 97       	sbiw	r26, 0x02	; 2
    3074:	84 ec       	ldi	r24, 0xC4	; 196
    3076:	93 e0       	ldi	r25, 0x03	; 3
    3078:	82 83       	std	Z+2, r24	; 0x02
    307a:	93 83       	std	Z+3, r25	; 0x03
    307c:	24 83       	std	Z+4, r18	; 0x04
    307e:	15 82       	std	Z+5, r1	; 0x05
    3080:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>

  uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
    3084:	ed b7       	in	r30, 0x3d	; 61
    3086:	fe b7       	in	r31, 0x3e	; 62
    3088:	36 96       	adiw	r30, 0x06	; 6
    308a:	ed bf       	out	0x3d, r30	; 61
    308c:	fe bf       	out	0x3e, r31	; 62
    308e:	0e 94 4b 21 	call	0x4296	; 0x4296 <ramDyskLiczbaWolnychKlastrow>
  fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
    3092:	2d b7       	in	r18, 0x3d	; 61
    3094:	3e b7       	in	r19, 0x3e	; 62
    3096:	28 50       	subi	r18, 0x08	; 8
    3098:	30 40       	sbci	r19, 0x00	; 0
    309a:	2d bf       	out	0x3d, r18	; 61
    309c:	3e bf       	out	0x3e, r19	; 62
    309e:	ed b7       	in	r30, 0x3d	; 61
    30a0:	fe b7       	in	r31, 0x3e	; 62
    30a2:	31 96       	adiw	r30, 0x01	; 1
    30a4:	ad b7       	in	r26, 0x3d	; 61
    30a6:	be b7       	in	r27, 0x3e	; 62
    30a8:	11 96       	adiw	r26, 0x01	; 1
    30aa:	cd 93       	st	X+, r28
    30ac:	dc 93       	st	X, r29
    30ae:	12 97       	sbiw	r26, 0x02	; 2
    30b0:	2c e7       	ldi	r18, 0x7C	; 124
    30b2:	33 e0       	ldi	r19, 0x03	; 3
    30b4:	22 83       	std	Z+2, r18	; 0x02
    30b6:	33 83       	std	Z+3, r19	; 0x03
    30b8:	84 83       	std	Z+4, r24	; 0x04
    30ba:	15 82       	std	Z+5, r1	; 0x05
    30bc:	80 e8       	ldi	r24, 0x80	; 128
    30be:	90 e0       	ldi	r25, 0x00	; 0
    30c0:	86 83       	std	Z+6, r24	; 0x06
    30c2:	97 83       	std	Z+7, r25	; 0x07
    30c4:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
//  printErrorInfo(state); //TODO fix and uncomment
  
  //Print system configuration
  fprintf_P(stream, systemRamConfigStr);
    30c8:	0f 90       	pop	r0
    30ca:	0f 90       	pop	r0
    30cc:	0f 90       	pop	r0
    30ce:	0f 90       	pop	r0
    30d0:	ed b7       	in	r30, 0x3d	; 61
    30d2:	fe b7       	in	r31, 0x3e	; 62
    30d4:	c1 83       	std	Z+1, r28	; 0x01
    30d6:	d2 83       	std	Z+2, r29	; 0x02
    30d8:	8f ed       	ldi	r24, 0xDF	; 223
    30da:	93 e0       	ldi	r25, 0x03	; 3
    30dc:	83 83       	std	Z+3, r24	; 0x03
    30de:	94 83       	std	Z+4, r25	; 0x04
    30e0:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>

  fprintf_P(stream, statusMacStr);
    30e4:	ad b7       	in	r26, 0x3d	; 61
    30e6:	be b7       	in	r27, 0x3e	; 62
    30e8:	11 96       	adiw	r26, 0x01	; 1
    30ea:	cd 93       	st	X+, r28
    30ec:	dc 93       	st	X, r29
    30ee:	12 97       	sbiw	r26, 0x02	; 2
    30f0:	82 ef       	ldi	r24, 0xF2	; 242
    30f2:	93 e0       	ldi	r25, 0x03	; 3
    30f4:	13 96       	adiw	r26, 0x03	; 3
    30f6:	8d 93       	st	X+, r24
    30f8:	9c 93       	st	X, r25
    30fa:	14 97       	sbiw	r26, 0x04	; 4
    30fc:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    3100:	0f 90       	pop	r0
    3102:	0f 90       	pop	r0
    3104:	0f 90       	pop	r0
    3106:	0f 90       	pop	r0
    3108:	ce 01       	movw	r24, r28
    310a:	6e ed       	ldi	r22, 0xDE	; 222
    310c:	71 e3       	ldi	r23, 0x31	; 49
    310e:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3112:	00 d0       	rcall	.+0      	; 0x3114 <printStatus+0x1d4>
    3114:	0f 92       	push	r0
    3116:	ed b7       	in	r30, 0x3d	; 61
    3118:	fe b7       	in	r31, 0x3e	; 62
    311a:	c1 83       	std	Z+1, r28	; 0x01
    311c:	d2 83       	std	Z+2, r29	; 0x02
    311e:	89 ea       	ldi	r24, 0xA9	; 169
    3120:	97 e0       	ldi	r25, 0x07	; 7
    3122:	83 83       	std	Z+3, r24	; 0x03
    3124:	94 83       	std	Z+4, r25	; 0x04
    3126:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  
  fprintf_P(stream, statusIpStr);
    312a:	ad b7       	in	r26, 0x3d	; 61
    312c:	be b7       	in	r27, 0x3e	; 62
    312e:	11 96       	adiw	r26, 0x01	; 1
    3130:	cd 93       	st	X+, r28
    3132:	dc 93       	st	X, r29
    3134:	12 97       	sbiw	r26, 0x02	; 2
    3136:	87 e0       	ldi	r24, 0x07	; 7
    3138:	94 e0       	ldi	r25, 0x04	; 4
    313a:	13 96       	adiw	r26, 0x03	; 3
    313c:	8d 93       	st	X+, r24
    313e:	9c 93       	st	X, r25
    3140:	14 97       	sbiw	r26, 0x04	; 4
    3142:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->ip);
    3146:	0f 90       	pop	r0
    3148:	0f 90       	pop	r0
    314a:	0f 90       	pop	r0
    314c:	0f 90       	pop	r0
    314e:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <ipGetConfig>
    3152:	fc 01       	movw	r30, r24
    3154:	40 81       	ld	r20, Z
    3156:	51 81       	ldd	r21, Z+1	; 0x01
    3158:	62 81       	ldd	r22, Z+2	; 0x02
    315a:	73 81       	ldd	r23, Z+3	; 0x03
    315c:	ce 01       	movw	r24, r28
    315e:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3162:	00 d0       	rcall	.+0      	; 0x3164 <printStatus+0x224>
    3164:	0f 92       	push	r0
    3166:	ad b7       	in	r26, 0x3d	; 61
    3168:	be b7       	in	r27, 0x3e	; 62
    316a:	11 96       	adiw	r26, 0x01	; 1
    316c:	cd 93       	st	X+, r28
    316e:	dc 93       	st	X, r29
    3170:	12 97       	sbiw	r26, 0x02	; 2
    3172:	86 ea       	ldi	r24, 0xA6	; 166
    3174:	97 e0       	ldi	r25, 0x07	; 7
    3176:	13 96       	adiw	r26, 0x03	; 3
    3178:	8d 93       	st	X+, r24
    317a:	9c 93       	st	X, r25
    317c:	14 97       	sbiw	r26, 0x04	; 4
    317e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>

  fprintf_P(stream, statusIpMaskStr);
    3182:	ed b7       	in	r30, 0x3d	; 61
    3184:	fe b7       	in	r31, 0x3e	; 62
    3186:	c1 83       	std	Z+1, r28	; 0x01
    3188:	d2 83       	std	Z+2, r29	; 0x02
    318a:	8c e1       	ldi	r24, 0x1C	; 28
    318c:	94 e0       	ldi	r25, 0x04	; 4
    318e:	83 83       	std	Z+3, r24	; 0x03
    3190:	94 83       	std	Z+4, r25	; 0x04
    3192:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->netmask);
    3196:	0f 90       	pop	r0
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	0f 90       	pop	r0
    319e:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <ipGetConfig>
    31a2:	dc 01       	movw	r26, r24
    31a4:	14 96       	adiw	r26, 0x04	; 4
    31a6:	4d 91       	ld	r20, X+
    31a8:	5d 91       	ld	r21, X+
    31aa:	6d 91       	ld	r22, X+
    31ac:	7c 91       	ld	r23, X
    31ae:	17 97       	sbiw	r26, 0x07	; 7
    31b0:	ce 01       	movw	r24, r28
    31b2:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    31b6:	00 d0       	rcall	.+0      	; 0x31b8 <printStatus+0x278>
    31b8:	0f 92       	push	r0
    31ba:	ed b7       	in	r30, 0x3d	; 61
    31bc:	fe b7       	in	r31, 0x3e	; 62
    31be:	c1 83       	std	Z+1, r28	; 0x01
    31c0:	d2 83       	std	Z+2, r29	; 0x02
    31c2:	83 ea       	ldi	r24, 0xA3	; 163
    31c4:	97 e0       	ldi	r25, 0x07	; 7
    31c6:	83 83       	std	Z+3, r24	; 0x03
    31c8:	94 83       	std	Z+4, r25	; 0x04
    31ca:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  
  fprintf_P(stream, statusIpGwStr);
    31ce:	ad b7       	in	r26, 0x3d	; 61
    31d0:	be b7       	in	r27, 0x3e	; 62
    31d2:	11 96       	adiw	r26, 0x01	; 1
    31d4:	cd 93       	st	X+, r28
    31d6:	dc 93       	st	X, r29
    31d8:	12 97       	sbiw	r26, 0x02	; 2
    31da:	81 e3       	ldi	r24, 0x31	; 49
    31dc:	94 e0       	ldi	r25, 0x04	; 4
    31de:	13 96       	adiw	r26, 0x03	; 3
    31e0:	8d 93       	st	X+, r24
    31e2:	9c 93       	st	X, r25
    31e4:	14 97       	sbiw	r26, 0x04	; 4
    31e6:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->gateway);
    31ea:	0f 90       	pop	r0
    31ec:	0f 90       	pop	r0
    31ee:	0f 90       	pop	r0
    31f0:	0f 90       	pop	r0
    31f2:	0e 94 f8 32 	call	0x65f0	; 0x65f0 <ipGetConfig>
    31f6:	fc 01       	movw	r30, r24
    31f8:	40 85       	ldd	r20, Z+8	; 0x08
    31fa:	51 85       	ldd	r21, Z+9	; 0x09
    31fc:	62 85       	ldd	r22, Z+10	; 0x0a
    31fe:	73 85       	ldd	r23, Z+11	; 0x0b
    3200:	ce 01       	movw	r24, r28
    3202:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3206:	00 d0       	rcall	.+0      	; 0x3208 <printStatus+0x2c8>
    3208:	0f 92       	push	r0
    320a:	ad b7       	in	r26, 0x3d	; 61
    320c:	be b7       	in	r27, 0x3e	; 62
    320e:	11 96       	adiw	r26, 0x01	; 1
    3210:	cd 93       	st	X+, r28
    3212:	dc 93       	st	X, r29
    3214:	12 97       	sbiw	r26, 0x02	; 2
    3216:	80 ea       	ldi	r24, 0xA0	; 160
    3218:	97 e0       	ldi	r25, 0x07	; 7
    321a:	13 96       	adiw	r26, 0x03	; 3
    321c:	8d 93       	st	X+, r24
    321e:	9c 93       	st	X, r25
    3220:	14 97       	sbiw	r26, 0x04	; 4
    3222:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  
  //Print Rs485 Execitive modules
  fprintf_P(stream, statusRs485listStr);
    3226:	ed b7       	in	r30, 0x3d	; 61
    3228:	fe b7       	in	r31, 0x3e	; 62
    322a:	c1 83       	std	Z+1, r28	; 0x01
    322c:	d2 83       	std	Z+2, r29	; 0x02
    322e:	86 e4       	ldi	r24, 0x46	; 70
    3230:	94 e0       	ldi	r25, 0x04	; 4
    3232:	83 83       	std	Z+3, r24	; 0x03
    3234:	94 83       	std	Z+4, r25	; 0x04
    3236:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  tmp = printRs485devices(stream);
    323a:	0f 90       	pop	r0
    323c:	0f 90       	pop	r0
    323e:	0f 90       	pop	r0
    3240:	0f 90       	pop	r0
    3242:	ce 01       	movw	r24, r28
    3244:	0e 94 ef 3f 	call	0x7fde	; 0x7fde <printRs485devices>
  if (tmp == 0)
    3248:	88 23       	and	r24, r24
    324a:	a1 f4       	brne	.+40     	; 0x3274 <printStatus+0x334>
    fprintf_P(stream, statusNoRs485Dev);  
    324c:	00 d0       	rcall	.+0      	; 0x324e <printStatus+0x30e>
    324e:	0f 92       	push	r0
    3250:	ad b7       	in	r26, 0x3d	; 61
    3252:	be b7       	in	r27, 0x3e	; 62
    3254:	11 96       	adiw	r26, 0x01	; 1
    3256:	cd 93       	st	X+, r28
    3258:	dc 93       	st	X, r29
    325a:	12 97       	sbiw	r26, 0x02	; 2
    325c:	81 e6       	ldi	r24, 0x61	; 97
    325e:	94 e0       	ldi	r25, 0x04	; 4
    3260:	13 96       	adiw	r26, 0x03	; 3
    3262:	8d 93       	st	X+, r24
    3264:	9c 93       	st	X, r25
    3266:	14 97       	sbiw	r26, 0x04	; 4
    3268:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    326c:	0f 90       	pop	r0
    326e:	0f 90       	pop	r0
    3270:	0f 90       	pop	r0
    3272:	0f 90       	pop	r0
  
  //Print locker sensors
  fprintf_P(stream, statusLockerSensorsStr);
    3274:	00 d0       	rcall	.+0      	; 0x3276 <printStatus+0x336>
    3276:	0f 92       	push	r0
    3278:	ed b7       	in	r30, 0x3d	; 61
    327a:	fe b7       	in	r31, 0x3e	; 62
    327c:	c1 83       	std	Z+1, r28	; 0x01
    327e:	d2 83       	std	Z+2, r29	; 0x02
    3280:	8b e7       	ldi	r24, 0x7B	; 123
    3282:	94 e0       	ldi	r25, 0x04	; 4
    3284:	83 83       	std	Z+3, r24	; 0x03
    3286:	94 83       	std	Z+4, r25	; 0x04
    3288:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  tmp = printLockers(stream);
    328c:	0f 90       	pop	r0
    328e:	0f 90       	pop	r0
    3290:	0f 90       	pop	r0
    3292:	0f 90       	pop	r0
    3294:	ce 01       	movw	r24, r28
    3296:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <printLockers>
  if (tmp == 0)
    329a:	88 23       	and	r24, r24
    329c:	a1 f4       	brne	.+40     	; 0x32c6 <printStatus+0x386>
    fprintf_P(stream, statusLockerSensorsDisStr);
    329e:	00 d0       	rcall	.+0      	; 0x32a0 <printStatus+0x360>
    32a0:	0f 92       	push	r0
    32a2:	ad b7       	in	r26, 0x3d	; 61
    32a4:	be b7       	in	r27, 0x3e	; 62
    32a6:	11 96       	adiw	r26, 0x01	; 1
    32a8:	cd 93       	st	X+, r28
    32aa:	dc 93       	st	X, r29
    32ac:	12 97       	sbiw	r26, 0x02	; 2
    32ae:	84 e9       	ldi	r24, 0x94	; 148
    32b0:	94 e0       	ldi	r25, 0x04	; 4
    32b2:	13 96       	adiw	r26, 0x03	; 3
    32b4:	8d 93       	st	X+, r24
    32b6:	9c 93       	st	X, r25
    32b8:	14 97       	sbiw	r26, 0x04	; 4
    32ba:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    32be:	0f 90       	pop	r0
    32c0:	0f 90       	pop	r0
    32c2:	0f 90       	pop	r0
    32c4:	0f 90       	pop	r0
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    32c6:	ce 01       	movw	r24, r28
    32c8:	0e 94 ba 3e 	call	0x7d74	; 0x7d74 <udpPrintStatus>
//  arpPrintTable(stream);
}
    32cc:	df 91       	pop	r29
    32ce:	cf 91       	pop	r28
    32d0:	08 95       	ret

000032d2 <statusFunction>:


// ************************** CLI Functions *********************************************************************************

static cliExRes_t statusFunction(cmdState_t *state)
{
    32d2:	ef 92       	push	r14
    32d4:	ff 92       	push	r15
    32d6:	0f 93       	push	r16
    32d8:	1f 93       	push	r17
    32da:	df 93       	push	r29
    32dc:	cf 93       	push	r28
    32de:	cd b7       	in	r28, 0x3d	; 61
    32e0:	de b7       	in	r29, 0x3e	; 62
    32e2:	2e 97       	sbiw	r28, 0x0e	; 14
    32e4:	cd bf       	out	0x3d, r28	; 61
    32e6:	de bf       	out	0x3e, r29	; 62
    32e8:	7c 01       	movw	r14, r24
  if (state->argc < 1)
    32ea:	dc 01       	movw	r26, r24
    32ec:	59 96       	adiw	r26, 0x19	; 25
    32ee:	8c 91       	ld	r24, X
    32f0:	59 97       	sbiw	r26, 0x19	; 25
    32f2:	88 23       	and	r24, r24
    32f4:	39 f4       	brne	.+14     	; 0x3304 <statusFunction+0x32>
  {
    printStatus(state->myStdInOut);
    32f6:	5a 96       	adiw	r26, 0x1a	; 26
    32f8:	8d 91       	ld	r24, X+
    32fa:	9c 91       	ld	r25, X
    32fc:	5b 97       	sbiw	r26, 0x1b	; 27
    32fe:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <printStatus>
    3302:	37 c0       	rjmp	.+110    	; 0x3372 <statusFunction+0xa0>
    return OK_SILENT; 
  }
  
  FILE stream;
  if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
    3304:	81 e0       	ldi	r24, 0x01	; 1
    3306:	b7 01       	movw	r22, r14
    3308:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    330c:	64 ec       	ldi	r22, 0xC4	; 196
    330e:	72 e3       	ldi	r23, 0x32	; 50
    3310:	8e 01       	movw	r16, r28
    3312:	0f 5f       	subi	r16, 0xFF	; 255
    3314:	1f 4f       	sbci	r17, 0xFF	; 255
    3316:	a8 01       	movw	r20, r16
    3318:	23 e0       	ldi	r18, 0x03	; 3
    331a:	0e 94 57 21 	call	0x42ae	; 0x42ae <ramDyskOtworzPlikStdIo>
    331e:	88 23       	and	r24, r24
    3320:	11 f1       	breq	.+68     	; 0x3366 <statusFunction+0x94>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    3322:	f7 01       	movw	r30, r14
    3324:	02 8d       	ldd	r16, Z+26	; 0x1a
    3326:	13 8d       	ldd	r17, Z+27	; 0x1b
    3328:	81 e0       	ldi	r24, 0x01	; 1
    332a:	b7 01       	movw	r22, r14
    332c:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    3330:	00 d0       	rcall	.+0      	; 0x3332 <statusFunction+0x60>
    3332:	00 d0       	rcall	.+0      	; 0x3334 <statusFunction+0x62>
    3334:	ed b7       	in	r30, 0x3d	; 61
    3336:	fe b7       	in	r31, 0x3e	; 62
    3338:	31 96       	adiw	r30, 0x01	; 1
    333a:	ad b7       	in	r26, 0x3d	; 61
    333c:	be b7       	in	r27, 0x3e	; 62
    333e:	11 96       	adiw	r26, 0x01	; 1
    3340:	0d 93       	st	X+, r16
    3342:	1c 93       	st	X, r17
    3344:	12 97       	sbiw	r26, 0x02	; 2
    3346:	2a ee       	ldi	r18, 0xEA	; 234
    3348:	32 e0       	ldi	r19, 0x02	; 2
    334a:	22 83       	std	Z+2, r18	; 0x02
    334c:	33 83       	std	Z+3, r19	; 0x03
    334e:	84 83       	std	Z+4, r24	; 0x04
    3350:	95 83       	std	Z+5, r25	; 0x05
    3352:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    return ERROR_INFORM;
    3356:	ed b7       	in	r30, 0x3d	; 61
    3358:	fe b7       	in	r31, 0x3e	; 62
    335a:	36 96       	adiw	r30, 0x06	; 6
    335c:	ed bf       	out	0x3d, r30	; 61
    335e:	fe bf       	out	0x3e, r31	; 62
    3360:	24 e0       	ldi	r18, 0x04	; 4
    3362:	30 e0       	ldi	r19, 0x00	; 0
    3364:	08 c0       	rjmp	.+16     	; 0x3376 <statusFunction+0xa4>
  }

  printStatus(&stream);
    3366:	c8 01       	movw	r24, r16
    3368:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <printStatus>
  ramDyskZamknijPlikStdIo(&stream);
    336c:	c8 01       	movw	r24, r16
    336e:	0e 94 7c 21 	call	0x42f8	; 0x42f8 <ramDyskZamknijPlikStdIo>
  return OK_SILENT; 
    3372:	20 e0       	ldi	r18, 0x00	; 0
    3374:	30 e0       	ldi	r19, 0x00	; 0
}
    3376:	c9 01       	movw	r24, r18
    3378:	2e 96       	adiw	r28, 0x0e	; 14
    337a:	cd bf       	out	0x3d, r28	; 61
    337c:	de bf       	out	0x3e, r29	; 62
    337e:	cf 91       	pop	r28
    3380:	df 91       	pop	r29
    3382:	1f 91       	pop	r17
    3384:	0f 91       	pop	r16
    3386:	ff 90       	pop	r15
    3388:	ef 90       	pop	r14
    338a:	08 95       	ret

0000338c <encTask>:
//   return 0;
// }


void encTask ( void *pvParameters )
{
    338c:	ef 92       	push	r14
    338e:	ff 92       	push	r15
    3390:	0f 93       	push	r16
    3392:	1f 93       	push	r17
    3394:	cf 93       	push	r28
    3396:	df 93       	push	r29
  FILE *netstackDebug = (FILE *) pvParameters;
    3398:	e8 2e       	mov	r14, r24
    339a:	e7 01       	movw	r28, r14
    339c:	7e 01       	movw	r14, r28
    339e:	f9 2e       	mov	r15, r25
    33a0:	e7 01       	movw	r28, r14
  uint16_t plen;

  nicInit();
    33a2:	0e 94 0d 2e 	call	0x5c1a	; 0x5c1a <nicInit>
  ipInit();
    33a6:	0e 94 a1 31 	call	0x6342	; 0x6342 <ipInit>
  arpInit();
    33aa:	0e 94 12 36 	call	0x6c24	; 0x6c24 <arpInit>
  icmpInit();
    33ae:	0e 94 77 34 	call	0x68ee	; 0x68ee <icmpInit>
    }
    else
    {
      if (netstackDebug != NULL)
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    33b2:	0e ed       	ldi	r16, 0xDE	; 222
    33b4:	17 e0       	ldi	r17, 0x07	; 7
  //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);
  
  
  for ( ; ; )
  {
    vTaskDelay ( 0 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwolniony po odebrzeniu przerwania od ENC
    33b6:	80 e0       	ldi	r24, 0x00	; 0
    33b8:	90 e0       	ldi	r25, 0x00	; 0
    33ba:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    
    // get the next new packet:
    plen = nicPoll();
    33be:	0e 94 16 2b 	call	0x562c	; 0x562c <nicPoll>
    /*plen will ne unequal to zero if there is a valid
    * packet (without crc error) */
    if ( plen==0 )
    33c2:	00 97       	sbiw	r24, 0x00	; 0
    33c4:	29 f4       	brne	.+10     	; 0x33d0 <encTask+0x44>
    {
      flushUdpQueues();
    33c6:	0e 94 69 3e 	call	0x7cd2	; 0x7cd2 <flushUdpQueues>
      flushTcpQueues();
    33ca:	0e 94 b8 3c 	call	0x7970	; 0x7970 <flushTcpQueues>
      //flush HTTP long file queue 
      continue;
    33ce:	f3 cf       	rjmp	.-26     	; 0x33b6 <encTask+0x2a>
    }
    
    if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
    33d0:	e0 91 e4 31 	lds	r30, 0x31E4
    33d4:	f0 91 e5 31 	lds	r31, 0x31E5
    33d8:	e4 84       	ldd	r14, Z+12	; 0x0c
    33da:	f5 84       	ldd	r15, Z+13	; 0x0d
    33dc:	80 e0       	ldi	r24, 0x00	; 0
    33de:	98 e0       	ldi	r25, 0x08	; 8
    33e0:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    33e4:	e8 16       	cp	r14, r24
    33e6:	f9 06       	cpc	r15, r25
    33e8:	29 f4       	brne	.+10     	; 0x33f4 <encTask+0x68>
    {
      arpIpIn();
    33ea:	0e 94 94 36 	call	0x6d28	; 0x6d28 <arpIpIn>
      netstackIPv4Process();
    33ee:	0e 94 f1 31 	call	0x63e2	; 0x63e2 <netstackIPv4Process>
    33f2:	e1 cf       	rjmp	.-62     	; 0x33b6 <encTask+0x2a>
    }
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
    33f4:	e0 91 e4 31 	lds	r30, 0x31E4
    33f8:	f0 91 e5 31 	lds	r31, 0x31E5
    33fc:	e4 84       	ldd	r14, Z+12	; 0x0c
    33fe:	f5 84       	ldd	r15, Z+13	; 0x0d
    3400:	86 e0       	ldi	r24, 0x06	; 6
    3402:	98 e0       	ldi	r25, 0x08	; 8
    3404:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    3408:	e8 16       	cp	r14, r24
    340a:	f9 06       	cpc	r15, r25
    340c:	19 f4       	brne	.+6      	; 0x3414 <encTask+0x88>
    {
      arpArpIn();
    340e:	0e 94 4b 38 	call	0x7096	; 0x7096 <arpArpIn>
    3412:	d1 cf       	rjmp	.-94     	; 0x33b6 <encTask+0x2a>
    }
    else
    {
      if (netstackDebug != NULL)
    3414:	20 97       	sbiw	r28, 0x00	; 0
    3416:	79 f2       	breq	.-98     	; 0x33b6 <encTask+0x2a>
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    3418:	00 d0       	rcall	.+0      	; 0x341a <encTask+0x8e>
    341a:	0f 92       	push	r0
    341c:	ed b7       	in	r30, 0x3d	; 61
    341e:	fe b7       	in	r31, 0x3e	; 62
    3420:	c1 83       	std	Z+1, r28	; 0x01
    3422:	d2 83       	std	Z+2, r29	; 0x02
    3424:	03 83       	std	Z+3, r16	; 0x03
    3426:	14 83       	std	Z+4, r17	; 0x04
    3428:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    342c:	0f 90       	pop	r0
    342e:	0f 90       	pop	r0
    3430:	0f 90       	pop	r0
    3432:	0f 90       	pop	r0
    3434:	c0 cf       	rjmp	.-128    	; 0x33b6 <encTask+0x2a>

00003436 <vTaskVTYusb>:
#include "cli_task.h"

void vTaskVTYusb(void *cliStatePtr)
{
    3436:	ef 92       	push	r14
    3438:	ff 92       	push	r15
    343a:	0f 93       	push	r16
    343c:	1f 93       	push	r17
    343e:	df 93       	push	r29
    3440:	cf 93       	push	r28
    3442:	0f 92       	push	r0
    3444:	cd b7       	in	r28, 0x3d	; 61
    3446:	de b7       	in	r29, 0x3e	; 62
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    3448:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Restart\r\n"));
    344a:	00 d0       	rcall	.+0      	; 0x344c <vTaskVTYusb+0x16>
    344c:	0f 92       	push	r0
    344e:	fc 01       	movw	r30, r24
    3450:	82 8d       	ldd	r24, Z+26	; 0x1a
    3452:	93 8d       	ldd	r25, Z+27	; 0x1b
    3454:	ed b7       	in	r30, 0x3d	; 61
    3456:	fe b7       	in	r31, 0x3e	; 62
    3458:	81 83       	std	Z+1, r24	; 0x01
    345a:	92 83       	std	Z+2, r25	; 0x02
    345c:	8f ee       	ldi	r24, 0xEF	; 239
    345e:	97 e0       	ldi	r25, 0x07	; 7
    3460:	83 83       	std	Z+3, r24	; 0x03
    3462:	94 83       	std	Z+4, r25	; 0x04
    3464:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  cmdlineInputFunc('\r', state);
    3468:	0f 90       	pop	r0
    346a:	0f 90       	pop	r0
    346c:	0f 90       	pop	r0
    346e:	0f 90       	pop	r0
    3470:	8d e0       	ldi	r24, 0x0D	; 13
    3472:	b8 01       	movw	r22, r16
    3474:	0e 94 cc 22 	call	0x4598	; 0x4598 <cmdlineInputFunc>
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    3478:	7e 01       	movw	r14, r28
    347a:	08 94       	sec
    347c:	e1 1c       	adc	r14, r1
    347e:	f1 1c       	adc	r15, r1
    3480:	80 91 0d 32 	lds	r24, 0x320D
    3484:	90 91 0e 32 	lds	r25, 0x320E
    3488:	b7 01       	movw	r22, r14
    348a:	4f ef       	ldi	r20, 0xFF	; 255
    348c:	5f ef       	ldi	r21, 0xFF	; 255
    348e:	20 e0       	ldi	r18, 0x00	; 0
    3490:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    3494:	88 23       	and	r24, r24
    3496:	a1 f3       	breq	.-24     	; 0x3480 <vTaskVTYusb+0x4a>
    {
      cmdlineInputFunc((char)znak, state);
    3498:	89 81       	ldd	r24, Y+1	; 0x01
    349a:	b8 01       	movw	r22, r16
    349c:	0e 94 cc 22 	call	0x4598	; 0x4598 <cmdlineInputFunc>
      cmdlineMainLoop(state);
    34a0:	c8 01       	movw	r24, r16
    34a2:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <cmdlineMainLoop>
    34a6:	ec cf       	rjmp	.-40     	; 0x3480 <vTaskVTYusb+0x4a>

000034a8 <vTaskUSB>:
    }  
  }
}
void vTaskUSB(void *cliStatePtr)
{
    34a8:	1f 93       	push	r17
 //nullptr (cliStatePtr); 
 for(;;)
 {
  vTaskDelay(200);
  USARTD0.DATA='a';
    34aa:	11 e6       	ldi	r17, 0x61	; 97
void vTaskUSB(void *cliStatePtr)
{
 //nullptr (cliStatePtr); 
 for(;;)
 {
  vTaskDelay(200);
    34ac:	88 ec       	ldi	r24, 0xC8	; 200
    34ae:	90 e0       	ldi	r25, 0x00	; 0
    34b0:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
  USARTD0.DATA='a';
    34b4:	10 93 a0 09 	sts	0x09A0, r17
    34b8:	f9 cf       	rjmp	.-14     	; 0x34ac <vTaskUSB+0x4>

000034ba <vTaskVTYsocket>:
 }
}

void vTaskVTYsocket(void *cliStatePtr)
{
    34ba:	ef 92       	push	r14
    34bc:	ff 92       	push	r15
    34be:	cf 93       	push	r28
    34c0:	df 93       	push	r29
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    34c2:	e8 2e       	mov	r14, r24
    34c4:	e7 01       	movw	r28, r14
    34c6:	7e 01       	movw	r14, r28
    34c8:	f9 2e       	mov	r15, r25
    34ca:	e7 01       	movw	r28, r14
  
  char znak;
  for( ;; )
  {
    znak = 0;
    znak = fgetc(state->myStdInOut);
    34cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    34ce:	9b 8d       	ldd	r25, Y+27	; 0x1b
    34d0:	0e 94 32 57 	call	0xae64	; 0xae64 <fgetc>
    cmdlineInputFunc((char)znak, state);
    34d4:	be 01       	movw	r22, r28
    34d6:	0e 94 cc 22 	call	0x4598	; 0x4598 <cmdlineInputFunc>
    cmdlineMainLoop(state);
    34da:	ce 01       	movw	r24, r28
    34dc:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <cmdlineMainLoop>
    34e0:	f5 cf       	rjmp	.-22     	; 0x34cc <vTaskVTYsocket+0x12>

000034e2 <odwroc>:
#include<lcd.h>
// PB5 D4, PB2 D7
unsigned char odwroc(unsigned char dana)
{
	unsigned char pomoc=0xFF;
	if(dana&0x01) pomoc|=0x80;
    34e2:	98 2f       	mov	r25, r24
    34e4:	80 ff       	sbrs	r24, 0
    34e6:	02 c0       	rjmp	.+4      	; 0x34ec <odwroc+0xa>
    34e8:	2f ef       	ldi	r18, 0xFF	; 255
    34ea:	01 c0       	rjmp	.+2      	; 0x34ee <odwroc+0xc>
	else pomoc&=~0x80;
    34ec:	2f e7       	ldi	r18, 0x7F	; 127
	if(dana&0x02) pomoc|=0x40;
    34ee:	91 ff       	sbrs	r25, 1
    34f0:	02 c0       	rjmp	.+4      	; 0x34f6 <odwroc+0x14>
    34f2:	20 64       	ori	r18, 0x40	; 64
    34f4:	01 c0       	rjmp	.+2      	; 0x34f8 <odwroc+0x16>
	else pomoc|=~0x40;
    34f6:	2f 6b       	ori	r18, 0xBF	; 191
	if(dana&0x04) pomoc|=0x20;
    34f8:	92 ff       	sbrs	r25, 2
    34fa:	02 c0       	rjmp	.+4      	; 0x3500 <odwroc+0x1e>
    34fc:	20 62       	ori	r18, 0x20	; 32
    34fe:	01 c0       	rjmp	.+2      	; 0x3502 <odwroc+0x20>
	else pomoc&=~0x20;
    3500:	2f 7d       	andi	r18, 0xDF	; 223
	if(dana&0x08) pomoc|=0x10;
    3502:	93 ff       	sbrs	r25, 3
    3504:	02 c0       	rjmp	.+4      	; 0x350a <odwroc+0x28>
    3506:	20 61       	ori	r18, 0x10	; 16
    3508:	01 c0       	rjmp	.+2      	; 0x350c <odwroc+0x2a>
	else pomoc&=~0x10;
    350a:	2f 7e       	andi	r18, 0xEF	; 239
	if(dana&0x10) pomoc|=0x08;
    350c:	94 ff       	sbrs	r25, 4
    350e:	02 c0       	rjmp	.+4      	; 0x3514 <odwroc+0x32>
    3510:	28 60       	ori	r18, 0x08	; 8
    3512:	01 c0       	rjmp	.+2      	; 0x3516 <odwroc+0x34>
	else pomoc&=~0x08;
    3514:	27 7f       	andi	r18, 0xF7	; 247
	if(dana&0x20) pomoc|=0x04;
    3516:	95 ff       	sbrs	r25, 5
    3518:	02 c0       	rjmp	.+4      	; 0x351e <odwroc+0x3c>
    351a:	24 60       	ori	r18, 0x04	; 4
    351c:	01 c0       	rjmp	.+2      	; 0x3520 <odwroc+0x3e>
	else pomoc&=~0x04;
    351e:	2b 7f       	andi	r18, 0xFB	; 251
	if(dana&0x40) pomoc|=0x02;
    3520:	96 ff       	sbrs	r25, 6
    3522:	03 c0       	rjmp	.+6      	; 0x352a <odwroc+0x48>
    3524:	92 2f       	mov	r25, r18
    3526:	92 60       	ori	r25, 0x02	; 2
    3528:	02 c0       	rjmp	.+4      	; 0x352e <odwroc+0x4c>
	else pomoc&=~0x02;
    352a:	92 2f       	mov	r25, r18
    352c:	9d 7f       	andi	r25, 0xFD	; 253
	if(dana&0x80) pomoc|=0x01;
    352e:	87 ff       	sbrs	r24, 7
    3530:	03 c0       	rjmp	.+6      	; 0x3538 <odwroc+0x56>
    3532:	89 2f       	mov	r24, r25
    3534:	81 60       	ori	r24, 0x01	; 1
    3536:	08 95       	ret
	else pomoc&=~0x01;
    3538:	89 2f       	mov	r24, r25
    353a:	8e 7f       	andi	r24, 0xFE	; 254

	return pomoc;	
}
    353c:	08 95       	ret

0000353e <polbajt>:
void polbajt(unsigned char data)
{
  if(data&0x01)
    353e:	80 ff       	sbrs	r24, 0
    3540:	04 c0       	rjmp	.+8      	; 0x354a <polbajt+0xc>
  {
	  PORTB.OUT|=LCD_D4;
    3542:	20 91 24 06 	lds	r18, 0x0624
    3546:	20 62       	ori	r18, 0x20	; 32
    3548:	03 c0       	rjmp	.+6      	; 0x3550 <polbajt+0x12>
  }
  else
  {
	  PORTB.OUT&=~LCD_D4;
    354a:	20 91 24 06 	lds	r18, 0x0624
    354e:	2f 7d       	andi	r18, 0xDF	; 223
    3550:	e0 e2       	ldi	r30, 0x20	; 32
    3552:	f6 e0       	ldi	r31, 0x06	; 6
    3554:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x02)
    3556:	81 ff       	sbrs	r24, 1
    3558:	04 c0       	rjmp	.+8      	; 0x3562 <polbajt+0x24>
  {
	  PORTB.OUT|=LCD_D5;
    355a:	20 91 24 06 	lds	r18, 0x0624
    355e:	20 61       	ori	r18, 0x10	; 16
    3560:	03 c0       	rjmp	.+6      	; 0x3568 <polbajt+0x2a>
  }
  else
  {
	  PORTB.OUT&=~LCD_D5;
    3562:	20 91 24 06 	lds	r18, 0x0624
    3566:	2f 7e       	andi	r18, 0xEF	; 239
    3568:	e0 e2       	ldi	r30, 0x20	; 32
    356a:	f6 e0       	ldi	r31, 0x06	; 6
    356c:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x04)
    356e:	82 ff       	sbrs	r24, 2
    3570:	04 c0       	rjmp	.+8      	; 0x357a <polbajt+0x3c>
  {
	  PORTB.OUT|=LCD_D6;
    3572:	20 91 24 06 	lds	r18, 0x0624
    3576:	28 60       	ori	r18, 0x08	; 8
    3578:	03 c0       	rjmp	.+6      	; 0x3580 <polbajt+0x42>
  }
  else
  {
	  PORTB.OUT&=~LCD_D6;
    357a:	20 91 24 06 	lds	r18, 0x0624
    357e:	27 7f       	andi	r18, 0xF7	; 247
    3580:	e0 e2       	ldi	r30, 0x20	; 32
    3582:	f6 e0       	ldi	r31, 0x06	; 6
    3584:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x08)
    3586:	83 ff       	sbrs	r24, 3
    3588:	04 c0       	rjmp	.+8      	; 0x3592 <polbajt+0x54>
  {
	  PORTB.OUT|=LCD_D7;
    358a:	80 91 24 06 	lds	r24, 0x0624
    358e:	84 60       	ori	r24, 0x04	; 4
    3590:	03 c0       	rjmp	.+6      	; 0x3598 <polbajt+0x5a>
  }
  else
  {
	  PORTB.OUT&=~LCD_D7;
    3592:	80 91 24 06 	lds	r24, 0x0624
    3596:	8b 7f       	andi	r24, 0xFB	; 251
    3598:	e0 e2       	ldi	r30, 0x20	; 32
    359a:	f6 e0       	ldi	r31, 0x06	; 6
    359c:	84 83       	std	Z+4, r24	; 0x04
    359e:	08 95       	ret

000035a0 <lcdWrite>:
{
LCD_RS_clear;
lcdWrite(command);
}
void lcdWrite(unsigned char data)
{
    35a0:	0f 93       	push	r16
    35a2:	1f 93       	push	r17
    35a4:	cf 93       	push	r28
    35a6:	df 93       	push	r29
    35a8:	18 2f       	mov	r17, r24
uint8_t pomoc=odwroc(data>>4);
    35aa:	82 95       	swap	r24
    35ac:	8f 70       	andi	r24, 0x0F	; 15
    35ae:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <odwroc>
    35b2:	08 2f       	mov	r16, r24
data=odwroc(data);
    35b4:	81 2f       	mov	r24, r17
    35b6:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <odwroc>
    35ba:	18 2f       	mov	r17, r24
LCD_E_set;
    35bc:	c0 e0       	ldi	r28, 0x00	; 0
    35be:	d6 e0       	ldi	r29, 0x06	; 6
    35c0:	8c 81       	ldd	r24, Y+4	; 0x04
    35c2:	83 60       	ori	r24, 0x03	; 3
    35c4:	8c 83       	std	Y+4, r24	; 0x04
polbajt(pomoc);
    35c6:	80 2f       	mov	r24, r16
    35c8:	0e 94 9f 1a 	call	0x353e	; 0x353e <polbajt>
LCD_E_clear;
    35cc:	8c 81       	ldd	r24, Y+4	; 0x04
    35ce:	8d 7f       	andi	r24, 0xFD	; 253
    35d0:	8c 83       	std	Y+4, r24	; 0x04
LCD_E_set;
    35d2:	8c 81       	ldd	r24, Y+4	; 0x04
    35d4:	83 60       	ori	r24, 0x03	; 3
    35d6:	8c 83       	std	Y+4, r24	; 0x04
polbajt(data);
    35d8:	81 2f       	mov	r24, r17
    35da:	0e 94 9f 1a 	call	0x353e	; 0x353e <polbajt>
LCD_E_clear;
    35de:	8c 81       	ldd	r24, Y+4	; 0x04
    35e0:	8d 7f       	andi	r24, 0xFD	; 253
    35e2:	8c 83       	std	Y+4, r24	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    35e4:	87 ec       	ldi	r24, 0xC7	; 199
    35e6:	90 e0       	ldi	r25, 0x00	; 0
    35e8:	01 97       	sbiw	r24, 0x01	; 1
    35ea:	f1 f7       	brne	.-4      	; 0x35e8 <lcdWrite+0x48>
    35ec:	00 c0       	rjmp	.+0      	; 0x35ee <lcdWrite+0x4e>
    35ee:	00 00       	nop
_delay_us(50);
}
    35f0:	df 91       	pop	r29
    35f2:	cf 91       	pop	r28
    35f4:	1f 91       	pop	r17
    35f6:	0f 91       	pop	r16
    35f8:	08 95       	ret

000035fa <lcdwritecommand>:
	  PORTB.OUT&=~LCD_D7;
  }
}
void lcdwritecommand(unsigned char command)
{
LCD_RS_clear;
    35fa:	e0 e0       	ldi	r30, 0x00	; 0
    35fc:	f6 e0       	ldi	r31, 0x06	; 6
    35fe:	94 81       	ldd	r25, Z+4	; 0x04
    3600:	9b 7f       	andi	r25, 0xFB	; 251
    3602:	94 83       	std	Z+4, r25	; 0x04
lcdWrite(command);
    3604:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <lcdWrite>
}
    3608:	08 95       	ret

0000360a <lcdsend>:
LCD_E_clear;
_delay_us(50);
}
void lcdsend(unsigned char data)
{
LCD_RS_set;
    360a:	e0 e0       	ldi	r30, 0x00	; 0
    360c:	f6 e0       	ldi	r31, 0x06	; 6
    360e:	94 81       	ldd	r25, Z+4	; 0x04
    3610:	94 60       	ori	r25, 0x04	; 4
    3612:	94 83       	std	Z+4, r25	; 0x04
lcdWrite(data);
    3614:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <lcdWrite>
}
    3618:	08 95       	ret

0000361a <lcdclear>:
void lcdclear(void)
{
lcdwritecommand(0x01);
    361a:	81 e0       	ldi	r24, 0x01	; 1
    361c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <lcdwritecommand>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3620:	8f e3       	ldi	r24, 0x3F	; 63
    3622:	9f e1       	ldi	r25, 0x1F	; 31
    3624:	01 97       	sbiw	r24, 0x01	; 1
    3626:	f1 f7       	brne	.-4      	; 0x3624 <lcdclear+0xa>
    3628:	00 c0       	rjmp	.+0      	; 0x362a <lcdclear+0x10>
    362a:	00 00       	nop
_delay_ms(2);
}
    362c:	08 95       	ret

0000362e <lcdinit>:
void lcdinit(void)
{// PB5 D4, PB2 D7
    362e:	cf 93       	push	r28
    3630:	df 93       	push	r29

	PORTB.DIR|=(PIN5_bm|PIN4_bm|PIN3_bm|PIN2_bm);
    3632:	80 91 20 06 	lds	r24, 0x0620
    3636:	8c 63       	ori	r24, 0x3C	; 60
    3638:	80 93 20 06 	sts	0x0620, r24
	PORTA.DIR|=(PIN1_bm|PIN2_bm);
    363c:	e0 e0       	ldi	r30, 0x00	; 0
    363e:	f6 e0       	ldi	r31, 0x06	; 6
    3640:	80 91 00 06 	lds	r24, 0x0600
    3644:	86 60       	ori	r24, 0x06	; 6
    3646:	80 93 00 06 	sts	0x0600, r24
	LCD_E_set;
    364a:	80 91 04 06 	lds	r24, 0x0604
    364e:	83 60       	ori	r24, 0x03	; 3
    3650:	84 83       	std	Z+4, r24	; 0x04
	LCD_RS_set;
    3652:	80 91 04 06 	lds	r24, 0x0604
    3656:	84 60       	ori	r24, 0x04	; 4
    3658:	84 83       	std	Z+4, r24	; 0x04
    365a:	8f e5       	ldi	r24, 0x5F	; 95
    365c:	9a ee       	ldi	r25, 0xEA	; 234
    365e:	01 97       	sbiw	r24, 0x01	; 1
    3660:	f1 f7       	brne	.-4      	; 0x365e <lcdinit+0x30>
    3662:	00 c0       	rjmp	.+0      	; 0x3664 <lcdinit+0x36>
    3664:	00 00       	nop
	_delay_ms(15);
	LCD_RS_clear;
    3666:	80 91 04 06 	lds	r24, 0x0604
    366a:	8b 7f       	andi	r24, 0xFB	; 251
    366c:	84 83       	std	Z+4, r24	; 0x04
	LCD_E_clear;
    366e:	80 91 04 06 	lds	r24, 0x0604
    3672:	8d 7f       	andi	r24, 0xFD	; 253
    3674:	84 83       	std	Z+4, r24	; 0x04
    3676:	83 e0       	ldi	r24, 0x03	; 3
    3678:	90 e0       	ldi	r25, 0x00	; 0
	for(int i = 0; i < 3; i++) 
	{
	   LCD_E_set;
	   PORTB.OUT&=0xF3;
    367a:	40 e2       	ldi	r20, 0x20	; 32
    367c:	56 e0       	ldi	r21, 0x06	; 6
	_delay_ms(15);
	LCD_RS_clear;
	LCD_E_clear;
	for(int i = 0; i < 3; i++) 
	{
	   LCD_E_set;
    367e:	c0 e0       	ldi	r28, 0x00	; 0
    3680:	d6 e0       	ldi	r29, 0x06	; 6
    3682:	20 91 04 06 	lds	r18, 0x0604
    3686:	23 60       	ori	r18, 0x03	; 3
    3688:	24 83       	std	Z+4, r18	; 0x04
	   PORTB.OUT&=0xF3;
    368a:	20 91 24 06 	lds	r18, 0x0624
    368e:	23 7f       	andi	r18, 0xF3	; 243
    3690:	da 01       	movw	r26, r20
    3692:	14 96       	adiw	r26, 0x04	; 4
    3694:	2c 93       	st	X, r18
    3696:	14 97       	sbiw	r26, 0x04	; 4
	   LCD_E_clear;	
    3698:	20 91 04 06 	lds	r18, 0x0604
    369c:	2d 7f       	andi	r18, 0xFD	; 253
    369e:	24 83       	std	Z+4, r18	; 0x04
    36a0:	af e1       	ldi	r26, 0x1F	; 31
    36a2:	be e4       	ldi	r27, 0x4E	; 78
    36a4:	11 97       	sbiw	r26, 0x01	; 1
    36a6:	f1 f7       	brne	.-4      	; 0x36a4 <lcdinit+0x76>
    36a8:	00 c0       	rjmp	.+0      	; 0x36aa <lcdinit+0x7c>
    36aa:	00 00       	nop
    36ac:	01 97       	sbiw	r24, 0x01	; 1
	LCD_E_set;
	LCD_RS_set;
	_delay_ms(15);
	LCD_RS_clear;
	LCD_E_clear;
	for(int i = 0; i < 3; i++) 
    36ae:	39 f7       	brne	.-50     	; 0x367e <lcdinit+0x50>
	   LCD_E_set;
	   PORTB.OUT&=0xF3;
	   LCD_E_clear;	
	   _delay_ms(5); // czekaj 5ms
	}
	LCD_E_set;
    36b0:	80 91 04 06 	lds	r24, 0x0604
    36b4:	83 60       	ori	r24, 0x03	; 3
    36b6:	8c 83       	std	Y+4, r24	; 0x04
	polbajt(0x02); //tryb 4 bitowy
    36b8:	82 e0       	ldi	r24, 0x02	; 2
    36ba:	0e 94 9f 1a 	call	0x353e	; 0x353e <polbajt>
	LCD_E_clear;
    36be:	80 91 04 06 	lds	r24, 0x0604
    36c2:	8d 7f       	andi	r24, 0xFD	; 253
    36c4:	8c 83       	std	Y+4, r24	; 0x04
    36c6:	8f e9       	ldi	r24, 0x9F	; 159
    36c8:	9f e0       	ldi	r25, 0x0F	; 15
    36ca:	01 97       	sbiw	r24, 0x01	; 1
    36cc:	f1 f7       	brne	.-4      	; 0x36ca <lcdinit+0x9c>
    36ce:	00 c0       	rjmp	.+0      	; 0x36d0 <lcdinit+0xa2>
    36d0:	00 00       	nop
	_delay_ms(1); // czekaj 1ms 
	lcdwritecommand(0x20|0|8|0);
    36d2:	88 e2       	ldi	r24, 0x28	; 40
    36d4:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <lcdwritecommand>
	lcdwritecommand(0x80|0);
    36d8:	80 e8       	ldi	r24, 0x80	; 128
    36da:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <lcdwritecommand>
	lcdwritecommand(0x01);
    36de:	81 e0       	ldi	r24, 0x01	; 1
    36e0:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <lcdwritecommand>
    36e4:	af e3       	ldi	r26, 0x3F	; 63
    36e6:	bf e1       	ldi	r27, 0x1F	; 31
    36e8:	11 97       	sbiw	r26, 0x01	; 1
    36ea:	f1 f7       	brne	.-4      	; 0x36e8 <lcdinit+0xba>
    36ec:	00 c0       	rjmp	.+0      	; 0x36ee <lcdinit+0xc0>
    36ee:	00 00       	nop
	_delay_ms(2); // czekaj 2ms 
	lcdwritecommand(0x04|0|2);
    36f0:	86 e0       	ldi	r24, 0x06	; 6
    36f2:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <lcdwritecommand>
	lcdwritecommand(0x08|4|2|1);	
    36f6:	8f e0       	ldi	r24, 0x0F	; 15
    36f8:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <lcdwritecommand>
}
    36fc:	df 91       	pop	r29
    36fe:	cf 91       	pop	r28
    3700:	08 95       	ret

00003702 <spiInit>:
#include "semphr.h"


void spiInit(void (*disableAllSpiDevicesFun)(void))
{
  disableAllSpiDevicesFun();
    3702:	fc 01       	movw	r30, r24
    3704:	19 95       	eicall
  portENTER_CRITICAL();
    3706:	0f b6       	in	r0, 0x3f	; 63
    3708:	f8 94       	cli
    370a:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    370c:	81 e0       	ldi	r24, 0x01	; 1
    370e:	60 e0       	ldi	r22, 0x00	; 0
    3710:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    3714:	80 93 20 32 	sts	0x3220, r24
    3718:	90 93 21 32 	sts	0x3221, r25
    371c:	00 97       	sbiw	r24, 0x00	; 0
    371e:	39 f0       	breq	.+14     	; 0x372e <spiInit+0x2c>
    3720:	60 e0       	ldi	r22, 0x00	; 0
    3722:	70 e0       	ldi	r23, 0x00	; 0
    3724:	40 e0       	ldi	r20, 0x00	; 0
    3726:	50 e0       	ldi	r21, 0x00	; 0
    3728:	20 e0       	ldi	r18, 0x00	; 0
    372a:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>

  //SPCR  = (1<<SPE)|(1<<MSTR)|(1<<SPIE);  //TODO Adam: użyć odpowiednich nazw rejestrów
  //SPSR |= (1<<SPI2X);
  SPID.CTRL=(1<<SPI_ENABLE_bp)|(1<<SPI_MASTER_bp);
    372e:	80 e5       	ldi	r24, 0x50	; 80
    3730:	80 93 c0 09 	sts	0x09C0, r24
  SPID.INTCTRL|=(1<<SPI_INTLVL1_bp);//0x01;
    3734:	80 91 c1 09 	lds	r24, 0x09C1
    3738:	82 60       	ori	r24, 0x02	; 2
    373a:	e0 ec       	ldi	r30, 0xC0	; 192
    373c:	f9 e0       	ldi	r31, 0x09	; 9
    373e:	81 83       	std	Z+1, r24	; 0x01
  SPID.CTRL|=(1<<SPI_CLK2X_bp);
    3740:	80 91 c0 09 	lds	r24, 0x09C0
    3744:	80 68       	ori	r24, 0x80	; 128
    3746:	80 93 c0 09 	sts	0x09C0, r24
  portEXIT_CRITICAL();
    374a:	0f 90       	pop	r0
    374c:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    374e:	08 95       	ret

00003750 <spiInitENC>:
void spiInitENC(void (*disableAllSpiDevicesFun)(void)) // PORTC
{
  disableAllSpiDevicesFun();
    3750:	fc 01       	movw	r30, r24
    3752:	19 95       	eicall
  portENTER_CRITICAL();
    3754:	0f b6       	in	r0, 0x3f	; 63
    3756:	f8 94       	cli
    3758:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    375a:	81 e0       	ldi	r24, 0x01	; 1
    375c:	60 e0       	ldi	r22, 0x00	; 0
    375e:	0e 94 be 4c 	call	0x997c	; 0x997c <xQueueCreate>
    3762:	80 93 20 32 	sts	0x3220, r24
    3766:	90 93 21 32 	sts	0x3221, r25
    376a:	00 97       	sbiw	r24, 0x00	; 0
    376c:	39 f0       	breq	.+14     	; 0x377c <spiInitENC+0x2c>
    376e:	60 e0       	ldi	r22, 0x00	; 0
    3770:	70 e0       	ldi	r23, 0x00	; 0
    3772:	40 e0       	ldi	r20, 0x00	; 0
    3774:	50 e0       	ldi	r21, 0x00	; 0
    3776:	20 e0       	ldi	r18, 0x00	; 0
    3778:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>

  //SPCR  = (1<<SPE)|(1<<MSTR)|(1<<SPIE);  //TODO Adam: użyć odpowiednich nazw rejestrów
  //SPSR |= (1<<SPI2X);
  SPIC.CTRL=(1<<SPI_ENABLE_bp)|(1<<SPI_MASTER_bp);
    377c:	80 e5       	ldi	r24, 0x50	; 80
    377e:	80 93 c0 08 	sts	0x08C0, r24
  SPIC.INTCTRL|=(1<<SPI_INTLVL1_bp);//0x01;
    3782:	80 91 c1 08 	lds	r24, 0x08C1
    3786:	82 60       	ori	r24, 0x02	; 2
    3788:	e0 ec       	ldi	r30, 0xC0	; 192
    378a:	f8 e0       	ldi	r31, 0x08	; 8
    378c:	81 83       	std	Z+1, r24	; 0x01
  SPIC.CTRL|=(1<<SPI_CLK2X_bp);
    378e:	80 91 c0 08 	lds	r24, 0x08C0
    3792:	80 68       	ori	r24, 0x80	; 128
    3794:	80 93 c0 08 	sts	0x08C0, r24
  portEXIT_CRITICAL();
    3798:	0f 90       	pop	r0
    379a:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    379c:	08 95       	ret

0000379e <spiSetCPHA>:

void spiSetCPHA(void)
{
  //SPCR |= (1<<CPHA);
  SPID.CTRL|=(1<<SPI_MODE_gp);
    379e:	e0 ec       	ldi	r30, 0xC0	; 192
    37a0:	f9 e0       	ldi	r31, 0x09	; 9
    37a2:	80 81       	ld	r24, Z
    37a4:	84 60       	ori	r24, 0x04	; 4
    37a6:	80 83       	st	Z, r24
}
    37a8:	08 95       	ret

000037aa <spiSetCPHAENC>:
void spiSetCPHAENC(void)
{
  //SPCR |= (1<<CPHA);
  SPIC.CTRL|=(1<<SPI_MODE_gp);
    37aa:	e0 ec       	ldi	r30, 0xC0	; 192
    37ac:	f8 e0       	ldi	r31, 0x08	; 8
    37ae:	80 81       	ld	r24, Z
    37b0:	84 60       	ori	r24, 0x04	; 4
    37b2:	80 83       	st	Z, r24
}
    37b4:	08 95       	ret

000037b6 <spiClearCPHA>:

void spiClearCPHA(void)
{
  //SPCR &= ~(1<<CPHA);
  SPID.CTRL&=~(1<<SPI_MODE_gp);
    37b6:	e0 ec       	ldi	r30, 0xC0	; 192
    37b8:	f9 e0       	ldi	r31, 0x09	; 9
    37ba:	80 81       	ld	r24, Z
    37bc:	8b 7f       	andi	r24, 0xFB	; 251
    37be:	80 83       	st	Z, r24
}
    37c0:	08 95       	ret

000037c2 <spiClearCPHAENC>:
void spiClearCPHAENC(void)
{
  //SPCR &= ~(1<<CPHA);
  SPIC.CTRL&=~(1<<SPI_MODE_gp);
    37c2:	e0 ec       	ldi	r30, 0xC0	; 192
    37c4:	f8 e0       	ldi	r31, 0x08	; 8
    37c6:	80 81       	ld	r24, Z
    37c8:	8b 7f       	andi	r24, 0xFB	; 251
    37ca:	80 83       	st	Z, r24
}
    37cc:	08 95       	ret

000037ce <spiSetCPOL>:


void spiSetCPOL(void)
{
  //SPCR |= (1<<CPOL);
  SPID.CTRL|=(1<<SPI_MODE1_bp);
    37ce:	e0 ec       	ldi	r30, 0xC0	; 192
    37d0:	f9 e0       	ldi	r31, 0x09	; 9
    37d2:	80 81       	ld	r24, Z
    37d4:	88 60       	ori	r24, 0x08	; 8
    37d6:	80 83       	st	Z, r24
}
    37d8:	08 95       	ret

000037da <spiSetCPOLENC>:
void spiSetCPOLENC(void)
{
  //SPCR |= (1<<CPOL);
  SPIC.CTRL|=(1<<SPI_MODE1_bp);
    37da:	e0 ec       	ldi	r30, 0xC0	; 192
    37dc:	f8 e0       	ldi	r31, 0x08	; 8
    37de:	80 81       	ld	r24, Z
    37e0:	88 60       	ori	r24, 0x08	; 8
    37e2:	80 83       	st	Z, r24
}
    37e4:	08 95       	ret

000037e6 <spiClearCPOL>:

void spiClearCPOL(void)
{
  //SPCR &= ~(1<<CPOL);
   SPID.CTRL&=~(1<<SPI_MODE1_bp);
    37e6:	e0 ec       	ldi	r30, 0xC0	; 192
    37e8:	f9 e0       	ldi	r31, 0x09	; 9
    37ea:	80 81       	ld	r24, Z
    37ec:	87 7f       	andi	r24, 0xF7	; 247
    37ee:	80 83       	st	Z, r24
}
    37f0:	08 95       	ret

000037f2 <spiClearCPOLENC>:
void spiClearCPOLENC(void)
{
  //SPCR &= ~(1<<CPOL);
   SPID.CTRL&=~(1<<SPI_MODE1_bp);
    37f2:	e0 ec       	ldi	r30, 0xC0	; 192
    37f4:	f9 e0       	ldi	r31, 0x09	; 9
    37f6:	80 81       	ld	r24, Z
    37f8:	87 7f       	andi	r24, 0xF7	; 247
    37fa:	80 83       	st	Z, r24
}
    37fc:	08 95       	ret

000037fe <spiTake>:

void spiTake(void)
{
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
    37fe:	80 91 20 32 	lds	r24, 0x3220
    3802:	90 91 21 32 	lds	r25, 0x3221
    3806:	60 e0       	ldi	r22, 0x00	; 0
    3808:	70 e0       	ldi	r23, 0x00	; 0
    380a:	4f ef       	ldi	r20, 0xFF	; 255
    380c:	5f ef       	ldi	r21, 0xFF	; 255
    380e:	20 e0       	ldi	r18, 0x00	; 0
    3810:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
}
    3814:	08 95       	ret

00003816 <spiGive>:

void spiGive(void)
{
  xSemaphoreGive(xSemaphoreSpiSS);
    3816:	80 91 20 32 	lds	r24, 0x3220
    381a:	90 91 21 32 	lds	r25, 0x3221
    381e:	60 e0       	ldi	r22, 0x00	; 0
    3820:	70 e0       	ldi	r23, 0x00	; 0
    3822:	40 e0       	ldi	r20, 0x00	; 0
    3824:	50 e0       	ldi	r21, 0x00	; 0
    3826:	20 e0       	ldi	r18, 0x00	; 0
    3828:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>
}
    382c:	08 95       	ret
    382e:	80 e0       	ldi	r24, 0x00	; 0
    3830:	08 95       	ret
    3832:	80 e0       	ldi	r24, 0x00	; 0
    3834:	08 95       	ret

00003836 <xmalloc>:
#include "hardwareConfig.h"

char *heapEnd = HEAP_BEGIN;

void *xmalloc(size_t size)
{
    3836:	cf 93       	push	r28
    3838:	df 93       	push	r29
    383a:	ec 01       	movw	r28, r24
  void *result = malloc(size);
    383c:	0e 94 3e 54 	call	0xa87c	; 0xa87c <malloc>
  
  heapEnd = (char *)(result);
  heapEnd += size;
    3840:	c8 0f       	add	r28, r24
    3842:	d9 1f       	adc	r29, r25
    3844:	c0 93 b3 24 	sts	0x24B3, r28
    3848:	d0 93 b4 24 	sts	0x24B4, r29
  
  return result;
}
    384c:	df 91       	pop	r29
    384e:	cf 91       	pop	r28
    3850:	08 95       	ret

00003852 <xmallocAvailable>:

size_t xmallocAvailable(void)
{
  return __malloc_heap_end - heapEnd + 1;
    3852:	20 91 44 25 	lds	r18, 0x2544
    3856:	30 91 45 25 	lds	r19, 0x2545
    385a:	2f 5f       	subi	r18, 0xFF	; 255
    385c:	3f 4f       	sbci	r19, 0xFF	; 255
    385e:	80 91 b3 24 	lds	r24, 0x24B3
    3862:	90 91 b4 24 	lds	r25, 0x24B4
    3866:	28 1b       	sub	r18, r24
    3868:	39 0b       	sbc	r19, r25
    386a:	c9 01       	movw	r24, r18
    386c:	08 95       	ret

0000386e <uaktualnijRozmiarPliku>:

  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
    386e:	fc 01       	movw	r30, r24
  if (fd->wpis->rozmiarHi == fd->IndHi)
    3870:	a4 81       	ldd	r26, Z+4	; 0x04
    3872:	b5 81       	ldd	r27, Z+5	; 0x05
    3874:	12 96       	adiw	r26, 0x02	; 2
    3876:	9c 91       	ld	r25, X
    3878:	12 97       	sbiw	r26, 0x02	; 2
    387a:	83 81       	ldd	r24, Z+3	; 0x03
    387c:	98 17       	cp	r25, r24
    387e:	41 f4       	brne	.+16     	; 0x3890 <uaktualnijRozmiarPliku+0x22>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    3880:	82 81       	ldd	r24, Z+2	; 0x02
    3882:	11 96       	adiw	r26, 0x01	; 1
    3884:	9c 91       	ld	r25, X
    3886:	11 97       	sbiw	r26, 0x01	; 1
    3888:	98 17       	cp	r25, r24
    388a:	10 f4       	brcc	.+4      	; 0x3890 <uaktualnijRozmiarPliku+0x22>
      fd->wpis->rozmiarLo = fd->IndLo;
    388c:	11 96       	adiw	r26, 0x01	; 1
    388e:	8c 93       	st	X, r24
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    3890:	a4 81       	ldd	r26, Z+4	; 0x04
    3892:	b5 81       	ldd	r27, Z+5	; 0x05
    3894:	12 96       	adiw	r26, 0x02	; 2
    3896:	9c 91       	ld	r25, X
    3898:	12 97       	sbiw	r26, 0x02	; 2
    389a:	83 81       	ldd	r24, Z+3	; 0x03
    389c:	98 17       	cp	r25, r24
    389e:	48 f4       	brcc	.+18     	; 0x38b2 <uaktualnijRozmiarPliku+0x44>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    38a0:	82 81       	ldd	r24, Z+2	; 0x02
    38a2:	11 96       	adiw	r26, 0x01	; 1
    38a4:	8c 93       	st	X, r24
      fd->wpis->rozmiarHi = fd->IndHi;    
    38a6:	a4 81       	ldd	r26, Z+4	; 0x04
    38a8:	b5 81       	ldd	r27, Z+5	; 0x05
    38aa:	83 81       	ldd	r24, Z+3	; 0x03
    38ac:	12 96       	adiw	r26, 0x02	; 2
    38ae:	8c 93       	st	X, r24
    38b0:	12 97       	sbiw	r26, 0x02	; 2
    38b2:	08 95       	ret

000038b4 <czyscKlaster>:
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    38b4:	e0 e0       	ldi	r30, 0x00	; 0
    38b6:	f8 2f       	mov	r31, r24
    38b8:	f0 58       	subi	r31, 0x80	; 128
    38ba:	80 e0       	ldi	r24, 0x00	; 0
    38bc:	91 e0       	ldi	r25, 0x01	; 1
    38be:	df 01       	movw	r26, r30
    38c0:	9c 01       	movw	r18, r24
    38c2:	1d 92       	st	X+, r1
    38c4:	21 50       	subi	r18, 0x01	; 1
    38c6:	30 40       	sbci	r19, 0x00	; 0
    38c8:	e1 f7       	brne	.-8      	; 0x38c2 <czyscKlaster+0xe>
}
    38ca:	08 95       	ret

000038cc <znajdzWolnyKlaster>:
      fd->wpis->rozmiarHi = fd->IndHi;    
  }
}

static uint8_t znajdzWolnyKlaster(void)
{
    38cc:	1f 93       	push	r17
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    38ce:	11 e0       	ldi	r17, 0x01	; 1
  {                                        //Może być rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    38d0:	e1 2f       	mov	r30, r17
    38d2:	f0 e0       	ldi	r31, 0x00	; 0
    38d4:	e5 5d       	subi	r30, 0xD5	; 213
    38d6:	fd 4c       	sbci	r31, 0xCD	; 205
    38d8:	80 81       	ld	r24, Z
    38da:	88 23       	and	r24, r24
    38dc:	29 f4       	brne	.+10     	; 0x38e8 <znajdzWolnyKlaster+0x1c>
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
    38de:	10 83       	st	Z, r17
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
    38e0:	81 2f       	mov	r24, r17
    38e2:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <czyscKlaster>
      return i;
    38e6:	04 c0       	rjmp	.+8      	; 0x38f0 <znajdzWolnyKlaster+0x24>
}

static uint8_t znajdzWolnyKlaster(void)
{
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    38e8:	1f 5f       	subi	r17, 0xFF	; 255
    38ea:	10 38       	cpi	r17, 0x80	; 128
    38ec:	89 f7       	brne	.-30     	; 0x38d0 <znajdzWolnyKlaster+0x4>
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
      return i;
    }
  }
  return 0;
    38ee:	10 e0       	ldi	r17, 0x00	; 0
}
    38f0:	81 2f       	mov	r24, r17
    38f2:	1f 91       	pop	r17
    38f4:	08 95       	ret

000038f6 <nastepnyKlaster>:

static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
    38f6:	1f 93       	push	r17
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
    38f8:	28 2f       	mov	r18, r24
    38fa:	30 e0       	ldi	r19, 0x00	; 0
    38fc:	f9 01       	movw	r30, r18
    38fe:	e5 5d       	subi	r30, 0xD5	; 213
    3900:	fd 4c       	sbci	r31, 0xCD	; 205
    3902:	10 81       	ld	r17, Z
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
    3904:	18 17       	cp	r17, r24
    3906:	b9 f4       	brne	.+46     	; 0x3936 <nastepnyKlaster+0x40>
    3908:	11 e0       	ldi	r17, 0x01	; 1
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma wolnego klastra
      if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, że jest on pusty
    390a:	e1 2f       	mov	r30, r17
    390c:	f0 e0       	ldi	r31, 0x00	; 0
    390e:	e5 5d       	subi	r30, 0xD5	; 213
    3910:	fd 4c       	sbci	r31, 0xCD	; 205
    3912:	80 81       	ld	r24, Z
    3914:	88 23       	and	r24, r24
    3916:	19 f0       	breq	.+6      	; 0x391e <nastepnyKlaster+0x28>
static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    3918:	1f 5f       	subi	r17, 0xFF	; 255
    391a:	10 38       	cpi	r17, 0x80	; 128
    391c:	b1 f7       	brne	.-20     	; 0x390a <nastepnyKlaster+0x14>
        break;                             //Wtedy można przerwać szukanie kolejnych klastrów dla klastra
    }                                      //Taka implementacja z założenia powoduje defragmentację.
    
    if (temp != 0)                         //Znaleziono jakiś wolny klaster
    {
      klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku kolejnego klastra
    391e:	25 5d       	subi	r18, 0xD5	; 213
    3920:	3d 4c       	sbci	r19, 0xCD	; 205
    3922:	f9 01       	movw	r30, r18
    3924:	10 83       	st	Z, r17
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
    3926:	e1 2f       	mov	r30, r17
    3928:	f0 e0       	ldi	r31, 0x00	; 0
    392a:	e5 5d       	subi	r30, 0xD5	; 213
    392c:	fd 4c       	sbci	r31, 0xCD	; 205
    392e:	10 83       	st	Z, r17
      czyscKlaster(temp);                  //Czyszczenie klastra
    3930:	81 2f       	mov	r24, r17
    3932:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <czyscKlaster>
    }
  }
  return temp;
}
    3936:	81 2f       	mov	r24, r17
    3938:	1f 91       	pop	r17
    393a:	08 95       	ret

0000393c <znajdzKlasterN>:

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
    393c:	1f 93       	push	r17
    393e:	df 93       	push	r29
    3940:	cf 93       	push	r28
    3942:	0f 92       	push	r0
    3944:	cd b7       	in	r28, 0x3d	; 61
    3946:	de b7       	in	r29, 0x3e	; 62
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3948:	10 e0       	ldi	r17, 0x00	; 0
    394a:	07 c0       	rjmp	.+14     	; 0x395a <znajdzKlasterN+0x1e>
  {
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    394c:	69 83       	std	Y+1, r22	; 0x01
    394e:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <nastepnyKlaster>
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
    3952:	69 81       	ldd	r22, Y+1	; 0x01
    3954:	88 23       	and	r24, r24
    3956:	19 f0       	breq	.+6      	; 0x395e <znajdzKlasterN+0x22>

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3958:	1f 5f       	subi	r17, 0xFF	; 255
    395a:	16 17       	cp	r17, r22
    395c:	b8 f3       	brcs	.-18     	; 0x394c <znajdzKlasterN+0x10>
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
      break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany na początek tablicy plików
  }
  return wynik;
}
    395e:	0f 90       	pop	r0
    3960:	cf 91       	pop	r28
    3962:	df 91       	pop	r29
    3964:	1f 91       	pop	r17
    3966:	08 95       	ret

00003968 <znajdzPlik>:
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
{
    3968:	8f 92       	push	r8
    396a:	9f 92       	push	r9
    396c:	af 92       	push	r10
    396e:	bf 92       	push	r11
    3970:	df 92       	push	r13
    3972:	ef 92       	push	r14
    3974:	ff 92       	push	r15
    3976:	0f 93       	push	r16
    3978:	1f 93       	push	r17
    397a:	df 93       	push	r29
    397c:	cf 93       	push	r28
    397e:	0f 92       	push	r0
    3980:	cd b7       	in	r28, 0x3d	; 61
    3982:	de b7       	in	r29, 0x3e	; 62
    3984:	8c 01       	movw	r16, r24
  uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
    3986:	dc 01       	movw	r26, r24
    3988:	0d 90       	ld	r0, X+
    398a:	00 20       	and	r0, r0
    398c:	e9 f7       	brne	.-6      	; 0x3988 <znajdzPlik+0x20>
    398e:	9d 01       	movw	r18, r26
    3990:	21 50       	subi	r18, 0x01	; 1
    3992:	30 40       	sbci	r19, 0x00	; 0
    3994:	28 1b       	sub	r18, r24
    3996:	29 30       	cpi	r18, 0x09	; 9
    3998:	08 f0       	brcs	.+2      	; 0x399c <znajdzPlik+0x34>
    399a:	28 e0       	ldi	r18, 0x08	; 8
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  
  if (nazwa[dlNazwy-1] == 0)
    399c:	f8 01       	movw	r30, r16
    399e:	e2 0f       	add	r30, r18
    39a0:	f1 1d       	adc	r31, r1
    39a2:	31 97       	sbiw	r30, 0x01	; 1
    39a4:	80 81       	ld	r24, Z
    39a6:	88 23       	and	r24, r24
    39a8:	09 f4       	brne	.+2      	; 0x39ac <znajdzPlik+0x44>
    dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
    39aa:	21 50       	subi	r18, 0x01	; 1
  klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
    39ac:	f8 01       	movw	r30, r16
    39ae:	31 96       	adiw	r30, 0x01	; 1
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    39b0:	81 e0       	ldi	r24, 0x01	; 1
    39b2:	04 c0       	rjmp	.+8      	; 0x39bc <znajdzPlik+0x54>
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    39b4:	91 91       	ld	r25, Z+
    39b6:	90 32       	cpi	r25, 0x20	; 32
    39b8:	31 f0       	breq	.+12     	; 0x39c6 <znajdzPlik+0x5e>
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    39ba:	8f 5f       	subi	r24, 0xFF	; 255
    39bc:	82 17       	cp	r24, r18
    39be:	d0 f3       	brcs	.-12     	; 0x39b4 <znajdzPlik+0x4c>
    {
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    39c0:	22 23       	and	r18, r18
    39c2:	59 f1       	breq	.+86     	; 0x3a1a <znajdzPlik+0xb2>
    39c4:	01 c0       	rjmp	.+2      	; 0x39c8 <znajdzPlik+0x60>
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    39c6:	28 2f       	mov	r18, r24
    39c8:	dd 24       	eor	r13, r13
    39ca:	01 c0       	rjmp	.+2      	; 0x39ce <znajdzPlik+0x66>
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    39cc:	d8 2e       	mov	r13, r24
  if (dlNazwy == 0)
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    39ce:	ed 2c       	mov	r14, r13
    39d0:	ff 24       	eor	r15, r15
    39d2:	c7 01       	movw	r24, r14
    39d4:	80 58       	subi	r24, 0x80	; 128
    39d6:	9f 4f       	sbci	r25, 0xFF	; 255
    39d8:	98 2e       	mov	r9, r24
    39da:	88 24       	eor	r8, r8
  klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
    39dc:	80 ef       	ldi	r24, 0xF0	; 240
    39de:	a8 2e       	mov	r10, r24
    39e0:	b1 2c       	mov	r11, r1
    39e2:	a8 0c       	add	r10, r8
    39e4:	b9 1c       	adc	r11, r9
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    39e6:	b4 01       	movw	r22, r8
    39e8:	6c 5f       	subi	r22, 0xFC	; 252
    39ea:	7f 4f       	sbci	r23, 0xFF	; 255
    39ec:	c8 01       	movw	r24, r16
    39ee:	42 2f       	mov	r20, r18
    39f0:	50 e0       	ldi	r21, 0x00	; 0
    39f2:	29 83       	std	Y+1, r18	; 0x01
    39f4:	0e 94 eb 56 	call	0xadd6	; 0xadd6 <strncmp>
    39f8:	29 81       	ldd	r18, Y+1	; 0x01
    39fa:	00 97       	sbiw	r24, 0x00	; 0
    39fc:	81 f0       	breq	.+32     	; 0x3a1e <znajdzPlik+0xb6>
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    39fe:	8a 14       	cp	r8, r10
    3a00:	9b 04       	cpc	r9, r11
    3a02:	29 f0       	breq	.+10     	; 0x3a0e <znajdzPlik+0xa6>
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    3a04:	e0 e1       	ldi	r30, 0x10	; 16
    3a06:	f0 e0       	ldi	r31, 0x00	; 0
    3a08:	8e 0e       	add	r8, r30
    3a0a:	9f 1e       	adc	r9, r31
    3a0c:	ec cf       	rjmp	.-40     	; 0x39e6 <znajdzPlik+0x7e>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3a0e:	f7 01       	movw	r30, r14
    3a10:	e5 5d       	subi	r30, 0xD5	; 213
    3a12:	fd 4c       	sbci	r31, 0xCD	; 205
    3a14:	80 81       	ld	r24, Z
  }
  while (tempKlaster2 != tempKlaster);
    3a16:	d8 16       	cp	r13, r24
    3a18:	c9 f6       	brne	.-78     	; 0x39cc <znajdzPlik+0x64>
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    return NULL;
    3a1a:	88 24       	eor	r8, r8
    3a1c:	99 24       	eor	r9, r9
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
  }
  while (tempKlaster2 != tempKlaster);
  return NULL;
}
    3a1e:	c4 01       	movw	r24, r8
    3a20:	0f 90       	pop	r0
    3a22:	cf 91       	pop	r28
    3a24:	df 91       	pop	r29
    3a26:	1f 91       	pop	r17
    3a28:	0f 91       	pop	r16
    3a2a:	ff 90       	pop	r15
    3a2c:	ef 90       	pop	r14
    3a2e:	df 90       	pop	r13
    3a30:	bf 90       	pop	r11
    3a32:	af 90       	pop	r10
    3a34:	9f 90       	pop	r9
    3a36:	8f 90       	pop	r8
    3a38:	08 95       	ret

00003a3a <ramDyskInit>:
}


void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
    3a3a:	80 e8       	ldi	r24, 0x80	; 128
    3a3c:	eb e2       	ldi	r30, 0x2B	; 43
    3a3e:	f2 e3       	ldi	r31, 0x32	; 50
    3a40:	df 01       	movw	r26, r30
    3a42:	1d 92       	st	X+, r1
    3a44:	8a 95       	dec	r24
    3a46:	e9 f7       	brne	.-6      	; 0x3a42 <ramDyskInit+0x8>
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
    3a48:	80 e0       	ldi	r24, 0x00	; 0
    3a4a:	91 e0       	ldi	r25, 0x01	; 1
    3a4c:	e0 e0       	ldi	r30, 0x00	; 0
    3a4e:	f0 e8       	ldi	r31, 0x80	; 128
    3a50:	df 01       	movw	r26, r30
    3a52:	9c 01       	movw	r18, r24
    3a54:	1d 92       	st	X+, r1
    3a56:	21 50       	subi	r18, 0x01	; 1
    3a58:	30 40       	sbci	r19, 0x00	; 0
    3a5a:	e1 f7       	brne	.-8      	; 0x3a54 <ramDyskInit+0x1a>
}
    3a5c:	08 95       	ret

00003a5e <ramDyskUtworzPlik>:
uint8_t ramDyskUtworzPlik(const char *nazwa)
{                                        //Nowo utworzony plik nie zajmuje żadnego klastra
    3a5e:	cf 92       	push	r12
    3a60:	df 92       	push	r13
    3a62:	ef 92       	push	r14
    3a64:	ff 92       	push	r15
    3a66:	0f 93       	push	r16
    3a68:	1f 93       	push	r17
    3a6a:	cf 93       	push	r28
    3a6c:	df 93       	push	r29
    3a6e:	f8 2e       	mov	r15, r24
    3a70:	09 2f       	mov	r16, r25
  uint8_t dlNazwy = strlen(nazwa);
    3a72:	e8 2f       	mov	r30, r24
    3a74:	f9 2f       	mov	r31, r25
    3a76:	df 01       	movw	r26, r30
    3a78:	0d 90       	ld	r0, X+
    3a7a:	00 20       	and	r0, r0
    3a7c:	e9 f7       	brne	.-6      	; 0x3a78 <ramDyskUtworzPlik+0x1a>
    3a7e:	11 97       	sbiw	r26, 0x01	; 1
    3a80:	1a 2f       	mov	r17, r26
    3a82:	18 1b       	sub	r17, r24
    3a84:	19 30       	cpi	r17, 0x09	; 9
    3a86:	08 f0       	brcs	.+2      	; 0x3a8a <ramDyskUtworzPlik+0x2c>
    3a88:	18 e0       	ldi	r17, 0x08	; 8
    3a8a:	2f 2d       	mov	r18, r15
    3a8c:	30 2f       	mov	r19, r16
    3a8e:	f9 01       	movw	r30, r18
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    3a90:	80 e0       	ldi	r24, 0x00	; 0
    3a92:	04 c0       	rjmp	.+8      	; 0x3a9c <ramDyskUtworzPlik+0x3e>
  {  if (nazwa[i] == ' ')
    3a94:	91 91       	ld	r25, Z+
    3a96:	90 32       	cpi	r25, 0x20	; 32
    3a98:	21 f0       	breq	.+8      	; 0x3aa2 <ramDyskUtworzPlik+0x44>
  uint8_t dlNazwy = strlen(nazwa);
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    3a9a:	8f 5f       	subi	r24, 0xFF	; 255
    3a9c:	81 17       	cp	r24, r17
    3a9e:	d0 f3       	brcs	.-12     	; 0x3a94 <ramDyskUtworzPlik+0x36>
    3aa0:	01 c0       	rjmp	.+2      	; 0x3aa4 <ramDyskUtworzPlik+0x46>
  {  if (nazwa[i] == ' ')
    3aa2:	18 2f       	mov	r17, r24
     {
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    3aa4:	11 23       	and	r17, r17
    3aa6:	09 f4       	brne	.+2      	; 0x3aaa <ramDyskUtworzPlik+0x4c>
    3aa8:	47 c0       	rjmp	.+142    	; 0x3b38 <ramDyskUtworzPlik+0xda>
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    3aaa:	8f 2d       	mov	r24, r15
    3aac:	90 2f       	mov	r25, r16
    3aae:	0e 94 b4 1c 	call	0x3968	; 0x3968 <znajdzPlik>
    3ab2:	00 97       	sbiw	r24, 0x00	; 0
    3ab4:	09 f0       	breq	.+2      	; 0x3ab8 <ramDyskUtworzPlik+0x5a>
    3ab6:	40 c0       	rjmp	.+128    	; 0x3b38 <ramDyskUtworzPlik+0xda>
    3ab8:	ee 24       	eor	r14, r14
    3aba:	01 c0       	rjmp	.+2      	; 0x3abe <ramDyskUtworzPlik+0x60>
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3abc:	e8 2e       	mov	r14, r24
  uint8_t temp;
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    3abe:	8e 2d       	mov	r24, r14
    3ac0:	90 e0       	ldi	r25, 0x00	; 0
    3ac2:	ec 01       	movw	r28, r24
    3ac4:	c0 58       	subi	r28, 0x80	; 128
    3ac6:	df 4f       	sbci	r29, 0xFF	; 255
    3ac8:	dc 2f       	mov	r29, r28
    3aca:	cc 27       	eor	r28, r28
void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
}
uint8_t ramDyskUtworzPlik(const char *nazwa)
    3acc:	9e 01       	movw	r18, r28
    3ace:	20 51       	subi	r18, 0x10	; 16
    3ad0:	3f 4f       	sbci	r19, 0xFF	; 255
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (plik->nazwa[0] == 0)
    3ad2:	4c 81       	ldd	r20, Y+4	; 0x04
    3ad4:	44 23       	and	r20, r20
    3ad6:	d1 f0       	breq	.+52     	; 0x3b0c <ramDyskUtworzPlik+0xae>
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    3ad8:	c2 17       	cp	r28, r18
    3ada:	d3 07       	cpc	r29, r19
    3adc:	11 f0       	breq	.+4      	; 0x3ae2 <ramDyskUtworzPlik+0x84>
    {
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    3ade:	60 96       	adiw	r28, 0x10	; 16
    3ae0:	f8 cf       	rjmp	.-16     	; 0x3ad2 <ramDyskUtworzPlik+0x74>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3ae2:	85 5d       	subi	r24, 0xD5	; 213
    3ae4:	9d 4c       	sbci	r25, 0xCD	; 205
    3ae6:	dc 01       	movw	r26, r24
    3ae8:	8c 91       	ld	r24, X
  }
  while (tempKlaster2 != tempKlaster);
    3aea:	e8 16       	cp	r14, r24
    3aec:	39 f7       	brne	.-50     	; 0x3abc <ramDyskUtworzPlik+0x5e>
  
  klastry[tempKlaster] = znajdzWolnyKlaster();
    3aee:	0e 94 66 1c 	call	0x38cc	; 0x38cc <znajdzWolnyKlaster>
    3af2:	ee 2d       	mov	r30, r14
    3af4:	f0 e0       	ldi	r31, 0x00	; 0
    3af6:	e5 5d       	subi	r30, 0xD5	; 213
    3af8:	fd 4c       	sbci	r31, 0xCD	; 205
    3afa:	80 83       	st	Z, r24
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    3afc:	88 23       	and	r24, r24
    3afe:	f1 f0       	breq	.+60     	; 0x3b3c <ramDyskUtworzPlik+0xde>
    plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
    3b00:	c8 2f       	mov	r28, r24
    3b02:	d0 e0       	ldi	r29, 0x00	; 0
    3b04:	c0 58       	subi	r28, 0x80	; 128
    3b06:	df 4f       	sbci	r29, 0xFF	; 255
    3b08:	dc 2f       	mov	r29, r28
    3b0a:	cc 27       	eor	r28, r28
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
  }
  
  if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym pliku
    3b0c:	20 97       	sbiw	r28, 0x00	; 0
    3b0e:	b1 f0       	breq	.+44     	; 0x3b3c <ramDyskUtworzPlik+0xde>
  {
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    3b10:	6e 01       	movw	r12, r28
    3b12:	ec 2f       	mov	r30, r28
    3b14:	fd 2d       	mov	r31, r13
    3b16:	8c e0       	ldi	r24, 0x0C	; 12
    3b18:	df 01       	movw	r26, r30
    3b1a:	1d 92       	st	X+, r1
    3b1c:	8a 95       	dec	r24
    3b1e:	e9 f7       	brne	.-6      	; 0x3b1a <ramDyskUtworzPlik+0xbc>
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    3b20:	ce 01       	movw	r24, r28
    3b22:	04 96       	adiw	r24, 0x04	; 4
    3b24:	6f 2d       	mov	r22, r15
    3b26:	70 2f       	mov	r23, r16
    3b28:	41 2f       	mov	r20, r17
    3b2a:	50 e0       	ldi	r21, 0x00	; 0
    3b2c:	0e 94 f9 56 	call	0xadf2	; 0xadf2 <strncpy>
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    3b30:	1c 86       	std	Y+12, r1	; 0x0c
    3b32:	1d 86       	std	Y+13, r1	; 0x0d
    3b34:	1e 86       	std	Y+14, r1	; 0x0e
    3b36:	1f 86       	std	Y+15, r1	; 0x0f
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
    3b38:	80 e0       	ldi	r24, 0x00	; 0
    3b3a:	01 c0       	rjmp	.+2      	; 0x3b3e <ramDyskUtworzPlik+0xe0>
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    return 0;                            
  }
  return 1;
    3b3c:	81 e0       	ldi	r24, 0x01	; 1
}
    3b3e:	df 91       	pop	r29
    3b40:	cf 91       	pop	r28
    3b42:	1f 91       	pop	r17
    3b44:	0f 91       	pop	r16
    3b46:	ff 90       	pop	r15
    3b48:	ef 90       	pop	r14
    3b4a:	df 90       	pop	r13
    3b4c:	cf 90       	pop	r12
    3b4e:	08 95       	ret

00003b50 <ramDyskOtworzPlik>:

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
    3b50:	ef 92       	push	r14
    3b52:	ff 92       	push	r15
    3b54:	cf 93       	push	r28
    3b56:	df 93       	push	r29
    3b58:	eb 01       	movw	r28, r22
  uint8_t wynik = 1;
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    3b5a:	0e 94 b4 1c 	call	0x3968	; 0x3968 <znajdzPlik>
    3b5e:	fc 01       	movw	r30, r24
    3b60:	00 97       	sbiw	r24, 0x00	; 0
    3b62:	79 f0       	breq	.+30     	; 0x3b82 <ramDyskOtworzPlik+0x32>
  {
    memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
    3b64:	7e 01       	movw	r14, r28
    3b66:	2c 2f       	mov	r18, r28
    3b68:	3f 2d       	mov	r19, r15
    3b6a:	83 e0       	ldi	r24, 0x03	; 3
    3b6c:	d9 01       	movw	r26, r18
    3b6e:	1d 92       	st	X+, r1
    3b70:	8a 95       	dec	r24
    3b72:	e9 f7       	brne	.-6      	; 0x3b6e <ramDyskOtworzPlik+0x1e>
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    3b74:	ec 83       	std	Y+4, r30	; 0x04
    3b76:	fd 83       	std	Y+5, r31	; 0x05
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    3b78:	83 81       	ldd	r24, Z+3	; 0x03
    3b7a:	8f 5f       	subi	r24, 0xFF	; 255
    3b7c:	83 83       	std	Z+3, r24	; 0x03
    wynik = 0;
    3b7e:	80 e0       	ldi	r24, 0x00	; 0
    3b80:	01 c0       	rjmp	.+2      	; 0x3b84 <ramDyskOtworzPlik+0x34>
  return 1;
}

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
  uint8_t wynik = 1;
    3b82:	81 e0       	ldi	r24, 0x01	; 1
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    wynik = 0;
  }
  return wynik;
}
    3b84:	df 91       	pop	r29
    3b86:	cf 91       	pop	r28
    3b88:	ff 90       	pop	r15
    3b8a:	ef 90       	pop	r14
    3b8c:	08 95       	ret

00003b8e <ramDyskUsunPlik>:

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    3b8e:	0e 94 b4 1c 	call	0x3968	; 0x3968 <znajdzPlik>
    3b92:	fc 01       	movw	r30, r24
    3b94:	00 97       	sbiw	r24, 0x00	; 0
    3b96:	e1 f0       	breq	.+56     	; 0x3bd0 <ramDyskUsunPlik+0x42>
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    3b98:	83 81       	ldd	r24, Z+3	; 0x03
    3b9a:	88 23       	and	r24, r24
    3b9c:	81 f0       	breq	.+32     	; 0x3bbe <ramDyskUsunPlik+0x30>
    3b9e:	1a c0       	rjmp	.+52     	; 0x3bd4 <ramDyskUsunPlik+0x46>
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
  {
    usuwanyKlaster = plik->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3ba0:	82 2f       	mov	r24, r18
    3ba2:	90 e0       	ldi	r25, 0x00	; 0
    3ba4:	dc 01       	movw	r26, r24
    3ba6:	a5 5d       	subi	r26, 0xD5	; 213
    3ba8:	bd 4c       	sbci	r27, 0xCD	; 205
    3baa:	3c 91       	ld	r19, X
    3bac:	32 17       	cp	r19, r18
    3bae:	11 f4       	brne	.+4      	; 0x3bb4 <ramDyskUsunPlik+0x26>
      plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3bb0:	10 82       	st	Z, r1
    3bb2:	01 c0       	rjmp	.+2      	; 0x3bb6 <ramDyskUsunPlik+0x28>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3bb4:	30 83       	st	Z, r19
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
    3bb6:	85 5d       	subi	r24, 0xD5	; 213
    3bb8:	9d 4c       	sbci	r25, 0xCD	; 205
    3bba:	dc 01       	movw	r26, r24
    3bbc:	1c 92       	st	X, r1
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3bbe:	20 81       	ld	r18, Z
    3bc0:	22 23       	and	r18, r18
    3bc2:	71 f7       	brne	.-36     	; 0x3ba0 <ramDyskUsunPlik+0x12>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
    3bc4:	80 e1       	ldi	r24, 0x10	; 16
    3bc6:	11 92       	st	Z+, r1
    3bc8:	8a 95       	dec	r24
    3bca:	e9 f7       	brne	.-6      	; 0x3bc6 <ramDyskUsunPlik+0x38>
//relokacjaTablicyWpisow()
  return 0;
    3bcc:	80 e0       	ldi	r24, 0x00	; 0
    3bce:	08 95       	ret

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    return 1;                                              //Nie znaleziono pliku
    3bd0:	81 e0       	ldi	r24, 0x01	; 1
    3bd2:	08 95       	ret
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
    3bd4:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
//relokacjaTablicyWpisow()
  return 0;
}
    3bd6:	08 95       	ret

00003bd8 <ramDyskZamknijPlik>:

void ramDyskZamknijPlik(struct ramPlikFd *fd)
{
  if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest poprawny
    3bd8:	dc 01       	movw	r26, r24
    3bda:	14 96       	adiw	r26, 0x04	; 4
    3bdc:	ed 91       	ld	r30, X+
    3bde:	fc 91       	ld	r31, X
    3be0:	15 97       	sbiw	r26, 0x05	; 5
    3be2:	23 81       	ldd	r18, Z+3	; 0x03
    3be4:	22 23       	and	r18, r18
    3be6:	31 f0       	breq	.+12     	; 0x3bf4 <ramDyskZamknijPlik+0x1c>
  {
    fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
    3be8:	21 50       	subi	r18, 0x01	; 1
    3bea:	23 83       	std	Z+3, r18	; 0x03
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
    3bec:	86 e0       	ldi	r24, 0x06	; 6
    3bee:	1d 92       	st	X+, r1
    3bf0:	8a 95       	dec	r24
    3bf2:	e9 f7       	brne	.-6      	; 0x3bee <ramDyskZamknijPlik+0x16>
    3bf4:	08 95       	ret

00003bf6 <ramDyskCzyscPlik>:
  }
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
    3bf6:	cf 93       	push	r28
    3bf8:	df 93       	push	r29
    3bfa:	fc 01       	movw	r30, r24
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3bfc:	0f c0       	rjmp	.+30     	; 0x3c1c <ramDyskCzyscPlik+0x26>
  {
    usuwanyKlaster = fd->wpis->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3bfe:	82 2f       	mov	r24, r18
    3c00:	90 e0       	ldi	r25, 0x00	; 0
    3c02:	ec 01       	movw	r28, r24
    3c04:	c5 5d       	subi	r28, 0xD5	; 213
    3c06:	dd 4c       	sbci	r29, 0xCD	; 205
    3c08:	38 81       	ld	r19, Y
    3c0a:	32 17       	cp	r19, r18
    3c0c:	11 f4       	brne	.+4      	; 0x3c12 <ramDyskCzyscPlik+0x1c>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3c0e:	1c 92       	st	X, r1
    3c10:	01 c0       	rjmp	.+2      	; 0x3c14 <ramDyskCzyscPlik+0x1e>
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3c12:	3c 93       	st	X, r19
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
    3c14:	85 5d       	subi	r24, 0xD5	; 213
    3c16:	9d 4c       	sbci	r25, 0xCD	; 205
    3c18:	dc 01       	movw	r26, r24
    3c1a:	1c 92       	st	X, r1
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3c1c:	a4 81       	ldd	r26, Z+4	; 0x04
    3c1e:	b5 81       	ldd	r27, Z+5	; 0x05
    3c20:	2c 91       	ld	r18, X
    3c22:	22 23       	and	r18, r18
    3c24:	61 f7       	brne	.-40     	; 0x3bfe <ramDyskCzyscPlik+0x8>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
  }
  fd->wpis->rozmiarLo       = 0;
    3c26:	11 96       	adiw	r26, 0x01	; 1
    3c28:	1c 92       	st	X, r1
  fd->wpis->rozmiarHi       = 0;
    3c2a:	a4 81       	ldd	r26, Z+4	; 0x04
    3c2c:	b5 81       	ldd	r27, Z+5	; 0x05
    3c2e:	12 96       	adiw	r26, 0x02	; 2
    3c30:	1c 92       	st	X, r1
  fd->wpis->dataMod         = systemTime();
    3c32:	a4 81       	ldd	r26, Z+4	; 0x04
    3c34:	b5 81       	ldd	r27, Z+5	; 0x05
    3c36:	1c 96       	adiw	r26, 0x0c	; 12
    3c38:	1d 92       	st	X+, r1
    3c3a:	1d 92       	st	X+, r1
    3c3c:	1d 92       	st	X+, r1
    3c3e:	1c 92       	st	X, r1
    3c40:	1f 97       	sbiw	r26, 0x0f	; 15
  memset (fd, 0, 4);
    3c42:	10 82       	st	Z, r1
    3c44:	11 82       	std	Z+1, r1	; 0x01
    3c46:	12 82       	std	Z+2, r1	; 0x02
    3c48:	13 82       	std	Z+3, r1	; 0x03
  return 0;
}
    3c4a:	80 e0       	ldi	r24, 0x00	; 0
    3c4c:	df 91       	pop	r29
    3c4e:	cf 91       	pop	r28
    3c50:	08 95       	ret

00003c52 <ramDyskZapiszBajtDoPliku>:

uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
{
    3c52:	1f 93       	push	r17
    3c54:	cf 93       	push	r28
    3c56:	df 93       	push	r29
    3c58:	ec 01       	movw	r28, r24
    3c5a:	16 2f       	mov	r17, r22
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
    3c5c:	ec 81       	ldd	r30, Y+4	; 0x04
    3c5e:	fd 81       	ldd	r31, Y+5	; 0x05
    3c60:	80 81       	ld	r24, Z
    3c62:	88 23       	and	r24, r24
    3c64:	39 f4       	brne	.+14     	; 0x3c74 <ramDyskZapiszBajtDoPliku+0x22>
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
    3c66:	0e 94 66 1c 	call	0x38cc	; 0x38cc <znajdzWolnyKlaster>
    3c6a:	88 23       	and	r24, r24
    3c6c:	49 f1       	breq	.+82     	; 0x3cc0 <ramDyskZapiszBajtDoPliku+0x6e>
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    fd->wpis->pierwszyKlaster = tmpKlaster;
    3c6e:	ec 81       	ldd	r30, Y+4	; 0x04
    3c70:	fd 81       	ldd	r31, Y+5	; 0x05
    3c72:	80 83       	st	Z, r24
  }
  if (fd->IndLo == 0)
    3c74:	8a 81       	ldd	r24, Y+2	; 0x02
    3c76:	88 23       	and	r24, r24
    3c78:	69 f4       	brne	.+26     	; 0x3c94 <ramDyskZapiszBajtDoPliku+0x42>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    3c7a:	ec 81       	ldd	r30, Y+4	; 0x04
    3c7c:	fd 81       	ldd	r31, Y+5	; 0x05
    3c7e:	80 81       	ld	r24, Z
    3c80:	6b 81       	ldd	r22, Y+3	; 0x03
    3c82:	0e 94 9e 1c 	call	0x393c	; 0x393c <znajdzKlasterN>
    if (tmpKlaster == 0)
    3c86:	88 23       	and	r24, r24
    3c88:	e9 f0       	breq	.+58     	; 0x3cc4 <ramDyskZapiszBajtDoPliku+0x72>
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    }
    fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego klastra
    3c8a:	90 e0       	ldi	r25, 0x00	; 0
    3c8c:	80 58       	subi	r24, 0x80	; 128
    3c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    3c90:	18 82       	st	Y, r1
    3c92:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
    3c94:	e8 81       	ld	r30, Y
    3c96:	f9 81       	ldd	r31, Y+1	; 0x01
    3c98:	10 83       	st	Z, r17

  fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
    3c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c9c:	8f 5f       	subi	r24, 0xFF	; 255
    3c9e:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, że czły klaster jest zapisany
    3ca0:	88 23       	and	r24, r24
    3ca2:	21 f4       	brne	.+8      	; 0x3cac <ramDyskZapiszBajtDoPliku+0x5a>
    fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt indeksu. Nie utworzono nowego klastra, zatem nie uaktualniamy wskaźnika
    3ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca6:	8f 5f       	subi	r24, 0xFF	; 255
    3ca8:	8b 83       	std	Y+3, r24	; 0x03
    3caa:	05 c0       	rjmp	.+10     	; 0x3cb6 <ramDyskZapiszBajtDoPliku+0x64>
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    3cac:	88 81       	ld	r24, Y
    3cae:	99 81       	ldd	r25, Y+1	; 0x01
    3cb0:	01 96       	adiw	r24, 0x01	; 1
    3cb2:	88 83       	st	Y, r24
    3cb4:	99 83       	std	Y+1, r25	; 0x01
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
    3cb6:	ce 01       	movw	r24, r28
    3cb8:	0e 94 37 1c 	call	0x386e	; 0x386e <uaktualnijRozmiarPliku>
  return 0;
    3cbc:	80 e0       	ldi	r24, 0x00	; 0
    3cbe:	03 c0       	rjmp	.+6      	; 0x3cc6 <ramDyskZapiszBajtDoPliku+0x74>
{
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    3cc0:	81 e0       	ldi	r24, 0x01	; 1
    3cc2:	01 c0       	rjmp	.+2      	; 0x3cc6 <ramDyskZapiszBajtDoPliku+0x74>
  if (fd->IndLo == 0)
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    if (tmpKlaster == 0)
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    3cc4:	82 e0       	ldi	r24, 0x02	; 2
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}
    3cc6:	df 91       	pop	r29
    3cc8:	cf 91       	pop	r28
    3cca:	1f 91       	pop	r17
    3ccc:	08 95       	ret

00003cce <putSTD>:
    return wynik;
  return EOF;
}

static int putSTD(char c, FILE *stream)
{
    3cce:	28 2f       	mov	r18, r24
    3cd0:	fb 01       	movw	r30, r22
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
    3cd2:	84 85       	ldd	r24, Z+12	; 0x0c
    3cd4:	95 85       	ldd	r25, Z+13	; 0x0d
    3cd6:	62 2f       	mov	r22, r18
    3cd8:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <ramDyskZapiszBajtDoPliku>
}
    3cdc:	90 e0       	ldi	r25, 0x00	; 0
    3cde:	08 95       	ret

00003ce0 <ramDyskCzytajBajtZPliku>:
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
    3ce0:	0f 93       	push	r16
    3ce2:	1f 93       	push	r17
    3ce4:	cf 93       	push	r28
    3ce6:	df 93       	push	r29
    3ce8:	ec 01       	movw	r28, r24
    3cea:	8b 01       	movw	r16, r22
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3cec:	ec 81       	ldd	r30, Y+4	; 0x04
    3cee:	fd 81       	ldd	r31, Y+5	; 0x05
    3cf0:	82 81       	ldd	r24, Z+2	; 0x02
    3cf2:	6b 81       	ldd	r22, Y+3	; 0x03
    3cf4:	68 17       	cp	r22, r24
    3cf6:	30 f0       	brcs	.+12     	; 0x3d04 <ramDyskCzytajBajtZPliku+0x24>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3cf8:	86 17       	cp	r24, r22
    3cfa:	21 f5       	brne	.+72     	; 0x3d44 <ramDyskCzytajBajtZPliku+0x64>
    3cfc:	91 81       	ldd	r25, Z+1	; 0x01
    3cfe:	8a 81       	ldd	r24, Y+2	; 0x02
    3d00:	98 17       	cp	r25, r24
    3d02:	00 f1       	brcs	.+64     	; 0x3d44 <ramDyskCzytajBajtZPliku+0x64>
uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof

  if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku nowego klastra
    3d04:	8a 81       	ldd	r24, Y+2	; 0x02
    3d06:	88 23       	and	r24, r24
    3d08:	41 f4       	brne	.+16     	; 0x3d1a <ramDyskCzytajBajtZPliku+0x3a>
  {
    uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    3d0a:	80 81       	ld	r24, Z
    3d0c:	0e 94 9e 1c 	call	0x393c	; 0x393c <znajdzKlasterN>
    fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego klastra
    3d10:	90 e0       	ldi	r25, 0x00	; 0
    3d12:	80 58       	subi	r24, 0x80	; 128
    3d14:	9f 4f       	sbci	r25, 0xFF	; 255
    3d16:	18 82       	st	Y, r1
    3d18:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *bajt = *(fd->Wsk);                                 //Odczyt z pliku
    3d1a:	e8 81       	ld	r30, Y
    3d1c:	f9 81       	ldd	r31, Y+1	; 0x01
    3d1e:	80 81       	ld	r24, Z
    3d20:	f8 01       	movw	r30, r16
    3d22:	80 83       	st	Z, r24
  fd->IndLo++;                                        //Zwiększenie indeksu o 1
    3d24:	8a 81       	ldd	r24, Y+2	; 0x02
    3d26:	8f 5f       	subi	r24, 0xFF	; 255
    3d28:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    3d2a:	88 23       	and	r24, r24
    3d2c:	21 f4       	brne	.+8      	; 0x3d36 <ramDyskCzytajBajtZPliku+0x56>
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
    3d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d30:	8f 5f       	subi	r24, 0xFF	; 255
    3d32:	8b 83       	std	Y+3, r24	; 0x03
    3d34:	05 c0       	rjmp	.+10     	; 0x3d40 <ramDyskCzytajBajtZPliku+0x60>
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
    3d36:	88 81       	ld	r24, Y
    3d38:	99 81       	ldd	r25, Y+1	; 0x01
    3d3a:	01 96       	adiw	r24, 0x01	; 1
    3d3c:	88 83       	st	Y, r24
    3d3e:	99 83       	std	Y+1, r25	; 0x01
  return 0;
    3d40:	80 e0       	ldi	r24, 0x00	; 0
    3d42:	01 c0       	rjmp	.+2      	; 0x3d46 <ramDyskCzytajBajtZPliku+0x66>
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof
    3d44:	81 e0       	ldi	r24, 0x01	; 1
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}
    3d46:	df 91       	pop	r29
    3d48:	cf 91       	pop	r28
    3d4a:	1f 91       	pop	r17
    3d4c:	0f 91       	pop	r16
    3d4e:	08 95       	ret

00003d50 <getSTD>:
  return wynik;
}


static int getSTD(FILE *stream)
{
    3d50:	df 93       	push	r29
    3d52:	cf 93       	push	r28
    3d54:	0f 92       	push	r0
    3d56:	cd b7       	in	r28, 0x3d	; 61
    3d58:	de b7       	in	r29, 0x3e	; 62
  uint8_t wynik;
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  
  if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
    3d5a:	fc 01       	movw	r30, r24
    3d5c:	84 85       	ldd	r24, Z+12	; 0x0c
    3d5e:	95 85       	ldd	r25, Z+13	; 0x0d
    3d60:	be 01       	movw	r22, r28
    3d62:	6f 5f       	subi	r22, 0xFF	; 255
    3d64:	7f 4f       	sbci	r23, 0xFF	; 255
    3d66:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <ramDyskCzytajBajtZPliku>
    3d6a:	88 23       	and	r24, r24
    3d6c:	19 f4       	brne	.+6      	; 0x3d74 <getSTD+0x24>
    return wynik;
    3d6e:	29 81       	ldd	r18, Y+1	; 0x01
    3d70:	30 e0       	ldi	r19, 0x00	; 0
    3d72:	02 c0       	rjmp	.+4      	; 0x3d78 <getSTD+0x28>
  return EOF;
    3d74:	2f ef       	ldi	r18, 0xFF	; 255
    3d76:	3f ef       	ldi	r19, 0xFF	; 255
}
    3d78:	c9 01       	movw	r24, r18
    3d7a:	0f 90       	pop	r0
    3d7c:	cf 91       	pop	r28
    3d7e:	df 91       	pop	r29
    3d80:	08 95       	ret

00003d82 <ramDyskZapiszBlokDoPliku>:
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}

uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3d82:	8f 92       	push	r8
    3d84:	9f 92       	push	r9
    3d86:	af 92       	push	r10
    3d88:	bf 92       	push	r11
    3d8a:	df 92       	push	r13
    3d8c:	ef 92       	push	r14
    3d8e:	ff 92       	push	r15
    3d90:	0f 93       	push	r16
    3d92:	1f 93       	push	r17
    3d94:	cf 93       	push	r28
    3d96:	df 93       	push	r29
    3d98:	ec 01       	movw	r28, r24
    3d9a:	4b 01       	movw	r8, r22
    3d9c:	5a 01       	movw	r10, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3d9e:	0c 81       	ldd	r16, Y+4	; 0x04
    3da0:	1d 81       	ldd	r17, Y+5	; 0x05
    3da2:	f8 01       	movw	r30, r16
    3da4:	80 81       	ld	r24, Z
    3da6:	88 23       	and	r24, r24
    3da8:	21 f4       	brne	.+8      	; 0x3db2 <ramDyskZapiszBlokDoPliku+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    3daa:	0e 94 66 1c 	call	0x38cc	; 0x38cc <znajdzWolnyKlaster>
    3dae:	f8 01       	movw	r30, r16
    3db0:	80 83       	st	Z, r24
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
    3db2:	8a 81       	ldd	r24, Y+2	; 0x02
    3db4:	00 e0       	ldi	r16, 0x00	; 0
    3db6:	11 e0       	ldi	r17, 0x01	; 1
    3db8:	08 1b       	sub	r16, r24
    3dba:	11 09       	sbc	r17, r1
  uint16_t doZapisu = *dlugosc;
    3dbc:	f5 01       	movw	r30, r10
    3dbe:	e0 80       	ld	r14, Z
    3dc0:	f1 80       	ldd	r15, Z+1	; 0x01
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
    3dc2:	10 82       	st	Z, r1
    3dc4:	11 82       	std	Z+1, r1	; 0x01
  uint8_t tmpKlaster = 0;
    3dc6:	dd 24       	eor	r13, r13
  while (doZapisu > 0)
    3dc8:	4e c0       	rjmp	.+156    	; 0x3e66 <ramDyskZapiszBlokDoPliku+0xe4>
  {
    if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to należy odczytać jego numer oraz ustawić na niego wskaźnik
    3dca:	8a 81       	ldd	r24, Y+2	; 0x02
    3dcc:	88 23       	and	r24, r24
    3dce:	a9 f4       	brne	.+42     	; 0x3dfa <ramDyskZapiszBlokDoPliku+0x78>
    {
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
    3dd0:	dd 20       	and	r13, r13
    3dd2:	39 f4       	brne	.+14     	; 0x3de2 <ramDyskZapiszBlokDoPliku+0x60>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
    3dd4:	ec 81       	ldd	r30, Y+4	; 0x04
    3dd6:	fd 81       	ldd	r31, Y+5	; 0x05
    3dd8:	80 81       	ld	r24, Z
    3dda:	6b 81       	ldd	r22, Y+3	; 0x03
    3ddc:	0e 94 9e 1c 	call	0x393c	; 0x393c <znajdzKlasterN>
    3de0:	03 c0       	rjmp	.+6      	; 0x3de8 <ramDyskZapiszBlokDoPliku+0x66>
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
    3de2:	8d 2d       	mov	r24, r13
    3de4:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <nastepnyKlaster>
    3de8:	d8 2e       	mov	r13, r24
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
    3dea:	88 23       	and	r24, r24
    3dec:	09 f4       	brne	.+2      	; 0x3df0 <ramDyskZapiszBlokDoPliku+0x6e>
    3dee:	44 c0       	rjmp	.+136    	; 0x3e78 <ramDyskZapiszBlokDoPliku+0xf6>
        return 1;                                 //1 - Brak wolnego klastra

      fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Teraz można do niego już pisać
    3df0:	90 e0       	ldi	r25, 0x00	; 0
    3df2:	80 58       	subi	r24, 0x80	; 128
    3df4:	9f 4f       	sbci	r25, 0xFF	; 255
    3df6:	18 82       	st	Y, r1
    3df8:	89 83       	std	Y+1, r24	; 0x01
    3dfa:	88 81       	ld	r24, Y
    3dfc:	99 81       	ldd	r25, Y+1	; 0x01
    }
    if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w bieżącym klastrze
    3dfe:	0e 15       	cp	r16, r14
    3e00:	1f 05       	cpc	r17, r15
    3e02:	b0 f4       	brcc	.+44     	; 0x3e30 <ramDyskZapiszBlokDoPliku+0xae>
    {                                             //Nie uda się, teraz zapiszemy cały klastr do końca
      memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
    3e04:	b4 01       	movw	r22, r8
    3e06:	a8 01       	movw	r20, r16
    3e08:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
      znaki +=dlBloku;                      
    3e0c:	80 0e       	add	r8, r16
    3e0e:	91 1e       	adc	r9, r17
      fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na początek nowego klastra. Kolejna iteracja go utworzy
    3e10:	1a 82       	std	Y+2, r1	; 0x02
      doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka pozostałą do zapisujemy
    3e12:	e0 1a       	sub	r14, r16
    3e14:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych danych
    3e16:	f5 01       	movw	r30, r10
    3e18:	80 81       	ld	r24, Z
    3e1a:	91 81       	ldd	r25, Z+1	; 0x01
    3e1c:	80 0f       	add	r24, r16
    3e1e:	91 1f       	adc	r25, r17
    3e20:	80 83       	st	Z, r24
    3e22:	91 83       	std	Z+1, r25	; 0x01
      fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. Oznacza to przejście do kolejnego klastra
    3e24:	8b 81       	ldd	r24, Y+3	; 0x03
    3e26:	8f 5f       	subi	r24, 0xFF	; 255
    3e28:	8b 83       	std	Y+3, r24	; 0x03
      dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 bajtów
    3e2a:	00 e0       	ldi	r16, 0x00	; 0
    3e2c:	11 e0       	ldi	r17, 0x01	; 1
    3e2e:	1b c0       	rjmp	.+54     	; 0x3e66 <ramDyskZapiszBlokDoPliku+0xe4>
    }
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
    3e30:	b4 01       	movw	r22, r8
    3e32:	a7 01       	movw	r20, r14
    3e34:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
    3e38:	8a 81       	ldd	r24, Y+2	; 0x02
    3e3a:	8e 0d       	add	r24, r14
    3e3c:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
    3e3e:	f5 01       	movw	r30, r10
    3e40:	80 81       	ld	r24, Z
    3e42:	91 81       	ldd	r25, Z+1	; 0x01
    3e44:	8e 0d       	add	r24, r14
    3e46:	9f 1d       	adc	r25, r15
    3e48:	80 83       	st	Z, r24
    3e4a:	91 83       	std	Z+1, r25	; 0x01
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    3e4c:	8d 2d       	mov	r24, r13
    3e4e:	90 e0       	ldi	r25, 0x00	; 0
    3e50:	80 58       	subi	r24, 0x80	; 128
    3e52:	9f 4f       	sbci	r25, 0xFF	; 255
    3e54:	98 2f       	mov	r25, r24
    3e56:	88 27       	eor	r24, r24
    3e58:	2a 81       	ldd	r18, Y+2	; 0x02
    3e5a:	82 0f       	add	r24, r18
    3e5c:	91 1d       	adc	r25, r1
    3e5e:	88 83       	st	Y, r24
    3e60:	99 83       	std	Y+1, r25	; 0x01
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
    3e62:	ee 24       	eor	r14, r14
    3e64:	ff 24       	eor	r15, r15
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
  uint16_t doZapisu = *dlugosc;
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
    3e66:	e1 14       	cp	r14, r1
    3e68:	f1 04       	cpc	r15, r1
    3e6a:	09 f0       	breq	.+2      	; 0x3e6e <ramDyskZapiszBlokDoPliku+0xec>
    3e6c:	ae cf       	rjmp	.-164    	; 0x3dca <ramDyskZapiszBlokDoPliku+0x48>
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
    3e6e:	ce 01       	movw	r24, r28
    3e70:	0e 94 37 1c 	call	0x386e	; 0x386e <uaktualnijRozmiarPliku>
  return 0;
    3e74:	80 e0       	ldi	r24, 0x00	; 0
    3e76:	01 c0       	rjmp	.+2      	; 0x3e7a <ramDyskZapiszBlokDoPliku+0xf8>
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
        return 1;                                 //1 - Brak wolnego klastra
    3e78:	81 e0       	ldi	r24, 0x01	; 1
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}
    3e7a:	df 91       	pop	r29
    3e7c:	cf 91       	pop	r28
    3e7e:	1f 91       	pop	r17
    3e80:	0f 91       	pop	r16
    3e82:	ff 90       	pop	r15
    3e84:	ef 90       	pop	r14
    3e86:	df 90       	pop	r13
    3e88:	bf 90       	pop	r11
    3e8a:	af 90       	pop	r10
    3e8c:	9f 90       	pop	r9
    3e8e:	8f 90       	pop	r8
    3e90:	08 95       	ret

00003e92 <ramDyskCzytajBlokZPliku>:

uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3e92:	8f 92       	push	r8
    3e94:	9f 92       	push	r9
    3e96:	bf 92       	push	r11
    3e98:	cf 92       	push	r12
    3e9a:	df 92       	push	r13
    3e9c:	ef 92       	push	r14
    3e9e:	ff 92       	push	r15
    3ea0:	0f 93       	push	r16
    3ea2:	1f 93       	push	r17
    3ea4:	cf 93       	push	r28
    3ea6:	df 93       	push	r29
    3ea8:	ec 01       	movw	r28, r24
    3eaa:	4b 01       	movw	r8, r22
    3eac:	6a 01       	movw	r12, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3eae:	ec 81       	ldd	r30, Y+4	; 0x04
    3eb0:	fd 81       	ldd	r31, Y+5	; 0x05
    3eb2:	80 81       	ld	r24, Z
    3eb4:	88 23       	and	r24, r24
    3eb6:	29 f4       	brne	.+10     	; 0x3ec2 <ramDyskCzytajBlokZPliku+0x30>
  {
    *dlugosc = 0;
    3eb8:	fa 01       	movw	r30, r20
    3eba:	10 82       	st	Z, r1
    3ebc:	11 82       	std	Z+1, r1	; 0x01
    return 1;                         //1 - Plik jest pusty
    3ebe:	81 e0       	ldi	r24, 0x01	; 1
    3ec0:	78 c0       	rjmp	.+240    	; 0x3fb2 <ramDyskCzytajBlokZPliku+0x120>
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3ec2:	22 81       	ldd	r18, Z+2	; 0x02
    3ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec6:	82 17       	cp	r24, r18
    3ec8:	40 f0       	brcs	.+16     	; 0x3eda <ramDyskCzytajBlokZPliku+0x48>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3eca:	28 17       	cp	r18, r24
    3ecc:	09 f0       	breq	.+2      	; 0x3ed0 <ramDyskCzytajBlokZPliku+0x3e>
    3ece:	7d c0       	rjmp	.+250    	; 0x3fca <ramDyskCzytajBlokZPliku+0x138>
    3ed0:	31 81       	ldd	r19, Z+1	; 0x01
    3ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed4:	39 17       	cp	r19, r25
    3ed6:	08 f4       	brcc	.+2      	; 0x3eda <ramDyskCzytajBlokZPliku+0x48>
    3ed8:	78 c0       	rjmp	.+240    	; 0x3fca <ramDyskCzytajBlokZPliku+0x138>
  {
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
    3eda:	30 e0       	ldi	r19, 0x00	; 0
    3edc:	28 1b       	sub	r18, r24
    3ede:	31 09       	sbc	r19, r1
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3ee0:	81 81       	ldd	r24, Z+1	; 0x01
    3ee2:	90 e0       	ldi	r25, 0x00	; 0
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
    3ee4:	4a 81       	ldd	r20, Y+2	; 0x02
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3ee6:	84 1b       	sub	r24, r20
    3ee8:	91 09       	sbc	r25, r1
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
    3eea:	82 0f       	add	r24, r18
    3eec:	93 1f       	adc	r25, r19
  
  uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i określenie ile bajtów zdoła się odczytać
    3eee:	f6 01       	movw	r30, r12
    3ef0:	00 81       	ld	r16, Z
    3ef2:	11 81       	ldd	r17, Z+1	; 0x01
    3ef4:	80 17       	cp	r24, r16
    3ef6:	91 07       	cpc	r25, r17
    3ef8:	08 f4       	brcc	.+2      	; 0x3efc <ramDyskCzytajBlokZPliku+0x6a>
    3efa:	8c 01       	movw	r16, r24
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
    3efc:	f6 01       	movw	r30, r12
    3efe:	10 82       	st	Z, r1
    3f00:	11 82       	std	Z+1, r1	; 0x01
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
    3f02:	8a 81       	ldd	r24, Y+2	; 0x02
    3f04:	e1 2c       	mov	r14, r1
    3f06:	e1 e0       	ldi	r30, 0x01	; 1
    3f08:	fe 2e       	mov	r15, r30
    3f0a:	e8 1a       	sub	r14, r24
    3f0c:	f1 08       	sbc	r15, r1
  uint8_t tmpKlaster = 0;
    3f0e:	bb 24       	eor	r11, r11
  while (doOdczytania > 0)
    3f10:	49 c0       	rjmp	.+146    	; 0x3fa4 <ramDyskCzytajBlokZPliku+0x112>
  {
    if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, że wskaźnik nie jest jeszcze ustawiony
    3f12:	8a 81       	ldd	r24, Y+2	; 0x02
    3f14:	88 23       	and	r24, r24
    3f16:	a1 f4       	brne	.+40     	; 0x3f40 <ramDyskCzytajBlokZPliku+0xae>
    {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (od początkowego) należy się przesunąć do przodu
      if (tmpKlaster == 0)
    3f18:	bb 20       	and	r11, r11
    3f1a:	39 f4       	brne	.+14     	; 0x3f2a <ramDyskCzytajBlokZPliku+0x98>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
    3f1c:	ec 81       	ldd	r30, Y+4	; 0x04
    3f1e:	fd 81       	ldd	r31, Y+5	; 0x05
    3f20:	80 81       	ld	r24, Z
    3f22:	6b 81       	ldd	r22, Y+3	; 0x03
    3f24:	0e 94 9e 1c 	call	0x393c	; 0x393c <znajdzKlasterN>
    3f28:	03 c0       	rjmp	.+6      	; 0x3f30 <ramDyskCzytajBlokZPliku+0x9e>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
    3f2a:	8b 2d       	mov	r24, r11
    3f2c:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <nastepnyKlaster>
    3f30:	b8 2e       	mov	r11, r24
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
    3f32:	88 23       	and	r24, r24
    3f34:	e9 f1       	breq	.+122    	; 0x3fb0 <ramDyskCzytajBlokZPliku+0x11e>
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
    3f36:	90 e0       	ldi	r25, 0x00	; 0
    3f38:	80 58       	subi	r24, 0x80	; 128
    3f3a:	9f 4f       	sbci	r25, 0xFF	; 255
    3f3c:	18 82       	st	Y, r1
    3f3e:	89 83       	std	Y+1, r24	; 0x01
    3f40:	68 81       	ld	r22, Y
    3f42:	79 81       	ldd	r23, Y+1	; 0x01
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    }
    
    if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
    3f44:	e0 16       	cp	r14, r16
    3f46:	f1 06       	cpc	r15, r17
    3f48:	b8 f4       	brcc	.+46     	; 0x3f78 <ramDyskCzytajBlokZPliku+0xe6>
    {                                  //dlBloku określa ile zostało jeszcze bajtów do końca klasrta
      memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
    3f4a:	c4 01       	movw	r24, r8
    3f4c:	a7 01       	movw	r20, r14
    3f4e:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
      znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy odczytane bajty
    3f52:	8e 0c       	add	r8, r14
    3f54:	9f 1c       	adc	r9, r15
      fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
    3f56:	1a 82       	std	Y+2, r1	; 0x02
      fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz nie ma potrzeby ustawienia wskaźnika odczytu na jego początek
    3f58:	8b 81       	ldd	r24, Y+3	; 0x03
    3f5a:	8f 5f       	subi	r24, 0xFF	; 255
    3f5c:	8b 83       	std	Y+3, r24	; 0x03
      doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
    3f5e:	0e 19       	sub	r16, r14
    3f60:	1f 09       	sbc	r17, r15
      *dlugosc += dlBloku;             //Uaktualnienie 
    3f62:	f6 01       	movw	r30, r12
    3f64:	80 81       	ld	r24, Z
    3f66:	91 81       	ldd	r25, Z+1	; 0x01
    3f68:	8e 0d       	add	r24, r14
    3f6a:	9f 1d       	adc	r25, r15
    3f6c:	80 83       	st	Z, r24
    3f6e:	91 83       	std	Z+1, r25	; 0x01
      dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całego klastra.
    3f70:	e1 2c       	mov	r14, r1
    3f72:	71 e0       	ldi	r23, 0x01	; 1
    3f74:	f7 2e       	mov	r15, r23
    3f76:	16 c0       	rjmp	.+44     	; 0x3fa4 <ramDyskCzytajBlokZPliku+0x112>
    }
    else                               //Ostatnia operacja odczytu
    {
      memcpy(znaki, fd->Wsk, doOdczytania);
    3f78:	c4 01       	movw	r24, r8
    3f7a:	a8 01       	movw	r20, r16
    3f7c:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
      fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym samym klastrze, zatem trzeba teraz uaktualnić wzkaźnik
    3f80:	88 81       	ld	r24, Y
    3f82:	99 81       	ldd	r25, Y+1	; 0x01
    3f84:	80 0f       	add	r24, r16
    3f86:	91 1f       	adc	r25, r17
    3f88:	88 83       	st	Y, r24
    3f8a:	99 83       	std	Y+1, r25	; 0x01
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
    3f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f8e:	80 0f       	add	r24, r16
    3f90:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
    3f92:	f6 01       	movw	r30, r12
    3f94:	80 81       	ld	r24, Z
    3f96:	91 81       	ldd	r25, Z+1	; 0x01
    3f98:	80 0f       	add	r24, r16
    3f9a:	91 1f       	adc	r25, r17
    3f9c:	80 83       	st	Z, r24
    3f9e:	91 83       	std	Z+1, r25	; 0x01
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    3fa0:	00 e0       	ldi	r16, 0x00	; 0
    3fa2:	10 e0       	ldi	r17, 0x00	; 0
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
    3fa4:	01 15       	cp	r16, r1
    3fa6:	11 05       	cpc	r17, r1
    3fa8:	09 f0       	breq	.+2      	; 0x3fac <ramDyskCzytajBlokZPliku+0x11a>
    3faa:	b3 cf       	rjmp	.-154    	; 0x3f12 <ramDyskCzytajBlokZPliku+0x80>
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
    3fac:	80 e0       	ldi	r24, 0x00	; 0
    3fae:	01 c0       	rjmp	.+2      	; 0x3fb2 <ramDyskCzytajBlokZPliku+0x120>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    3fb0:	83 e0       	ldi	r24, 0x03	; 3
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
}
    3fb2:	df 91       	pop	r29
    3fb4:	cf 91       	pop	r28
    3fb6:	1f 91       	pop	r17
    3fb8:	0f 91       	pop	r16
    3fba:	ff 90       	pop	r15
    3fbc:	ef 90       	pop	r14
    3fbe:	df 90       	pop	r13
    3fc0:	cf 90       	pop	r12
    3fc2:	bf 90       	pop	r11
    3fc4:	9f 90       	pop	r9
    3fc6:	8f 90       	pop	r8
    3fc8:	08 95       	ret
    *dlugosc = 0;
    return 1;                         //1 - Plik jest pusty
  }
  if (wObrebiePliku(fd) != 0)
  {
    *dlugosc = 0;
    3fca:	f6 01       	movw	r30, r12
    3fcc:	10 82       	st	Z, r1
    3fce:	11 82       	std	Z+1, r1	; 0x01
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
    3fd0:	82 e0       	ldi	r24, 0x02	; 2
    3fd2:	ef cf       	rjmp	.-34     	; 0x3fb2 <ramDyskCzytajBlokZPliku+0x120>

00003fd4 <ramDyskUstawWskaznik>:
  }
  return 0;
}

uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
{
    3fd4:	ef 92       	push	r14
    3fd6:	ff 92       	push	r15
    3fd8:	0f 93       	push	r16
    3fda:	1f 93       	push	r17
    3fdc:	cf 93       	push	r28
    3fde:	df 93       	push	r29
    3fe0:	ec 01       	movw	r28, r24
  if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje na początek pliku.
    3fe2:	61 15       	cp	r22, r1
    3fe4:	71 05       	cpc	r23, r1
    3fe6:	19 f4       	brne	.+6      	; 0x3fee <ramDyskUstawWskaznik+0x1a>
  {                                                       //Jeśli tak, to nie ma potzeby tworzenia klastrów. Plik może nadal nei mieć żadnego klastra.
    fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bardziej znaczącego bajtu)
    3fe8:	1a 82       	std	Y+2, r1	; 0x02
    fd->IndHi = 0;
    3fea:	1b 82       	std	Y+3, r1	; 0x03
    3fec:	2e c0       	rjmp	.+92     	; 0x404a <__stack+0x4b>
    return 0;
  }
  indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio ustawić rozmair pliku.
    3fee:	8b 01       	movw	r16, r22
    3ff0:	01 50       	subi	r16, 0x01	; 1
    3ff2:	10 40       	sbci	r17, 0x00	; 0
                                                          //Jeśli indeks jest większy niż rozmiar pliku, to plik zostanie rozciągnięty do zadanej wartości indeksu -1
  
  if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydzielony pierwszy klaster
    3ff4:	ec 80       	ldd	r14, Y+4	; 0x04
    3ff6:	fd 80       	ldd	r15, Y+5	; 0x05
    3ff8:	f7 01       	movw	r30, r14
    3ffa:	80 81       	ld	r24, Z
    3ffc:	88 23       	and	r24, r24
    3ffe:	21 f4       	brne	.+8      	; 0x4008 <__stack+0x9>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pliku. Jest to konieczne, ponieważ klaster ma wartość niezerową
    4000:	0e 94 66 1c 	call	0x38cc	; 0x38cc <znajdzWolnyKlaster>
    4004:	f7 01       	movw	r30, r14
    4006:	80 83       	st	Z, r24

  uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką należy dodać do pierwszego klastra`

  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
    4008:	0a 83       	std	Y+2, r16	; 0x02
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
    400a:	1b 83       	std	Y+3, r17	; 0x03
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
    400c:	ec 81       	ldd	r30, Y+4	; 0x04
    400e:	fd 81       	ldd	r31, Y+5	; 0x05
    4010:	80 81       	ld	r24, Z
    4012:	61 2f       	mov	r22, r17
    4014:	0e 94 9e 1c 	call	0x393c	; 0x393c <znajdzKlasterN>
    4018:	08 2f       	mov	r16, r24
  if (nrKlastra == 0)
    401a:	88 23       	and	r24, r24
    401c:	c1 f0       	breq	.+48     	; 0x404e <__stack+0x4f>
    return 1;                                             //Brak klastrów

  uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
    401e:	ce 01       	movw	r24, r28
    4020:	0e 94 37 1c 	call	0x386e	; 0x386e <uaktualnijRozmiarPliku>

  fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
    4024:	2a 81       	ldd	r18, Y+2	; 0x02
    4026:	2f 5f       	subi	r18, 0xFF	; 255
    4028:	2a 83       	std	Y+2, r18	; 0x02
  if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, to jeszcze on nie iestnieje
    402a:	22 23       	and	r18, r18
    402c:	21 f4       	brne	.+8      	; 0x4036 <__stack+0x37>
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
    402e:	8b 81       	ldd	r24, Y+3	; 0x03
    4030:	8f 5f       	subi	r24, 0xFF	; 255
    4032:	8b 83       	std	Y+3, r24	; 0x03
    4034:	0a c0       	rjmp	.+20     	; 0x404a <__stack+0x4b>
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra
    4036:	80 2f       	mov	r24, r16
    4038:	90 e0       	ldi	r25, 0x00	; 0
    403a:	80 58       	subi	r24, 0x80	; 128
    403c:	9f 4f       	sbci	r25, 0xFF	; 255
    403e:	98 2f       	mov	r25, r24
    4040:	88 27       	eor	r24, r24
    4042:	82 0f       	add	r24, r18
    4044:	91 1d       	adc	r25, r1
    4046:	88 83       	st	Y, r24
    4048:	99 83       	std	Y+1, r25	; 0x01

  return 0; 
    404a:	80 e0       	ldi	r24, 0x00	; 0
    404c:	01 c0       	rjmp	.+2      	; 0x4050 <__stack+0x51>
  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
  if (nrKlastra == 0)
    return 1;                                             //Brak klastrów
    404e:	81 e0       	ldi	r24, 0x01	; 1
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra

  return 0; 
}
    4050:	df 91       	pop	r29
    4052:	cf 91       	pop	r28
    4054:	1f 91       	pop	r17
    4056:	0f 91       	pop	r16
    4058:	ff 90       	pop	r15
    405a:	ef 90       	pop	r14
    405c:	08 95       	ret

0000405e <ramDyskUstawWskaznikNaKoniec>:

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
    405e:	cf 93       	push	r28
    4060:	df 93       	push	r29
    4062:	ec 01       	movw	r28, r24
  if (fd == NULL)
    4064:	00 97       	sbiw	r24, 0x00	; 0
    4066:	b9 f0       	breq	.+46     	; 0x4096 <ramDyskUstawWskaznikNaKoniec+0x38>
    return 1;
  fd->IndLo = fd->wpis->rozmiarLo;
    4068:	ec 81       	ldd	r30, Y+4	; 0x04
    406a:	fd 81       	ldd	r31, Y+5	; 0x05
    406c:	81 81       	ldd	r24, Z+1	; 0x01
    406e:	8a 83       	std	Y+2, r24	; 0x02
  fd->IndHi = fd->wpis->rozmiarHi;
    4070:	92 81       	ldd	r25, Z+2	; 0x02
    4072:	9b 83       	std	Y+3, r25	; 0x03
//  fd->IndLo++;
  uint8_t tmpKlaster = 0;
  if (fd->IndLo != 0)
    4074:	88 23       	and	r24, r24
    4076:	89 f0       	breq	.+34     	; 0x409a <ramDyskUstawWskaznikNaKoniec+0x3c>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    4078:	80 81       	ld	r24, Z
    407a:	62 81       	ldd	r22, Z+2	; 0x02
    407c:	0e 94 9e 1c 	call	0x393c	; 0x393c <znajdzKlasterN>
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
    4080:	90 e0       	ldi	r25, 0x00	; 0
    4082:	80 58       	subi	r24, 0x80	; 128
    4084:	9f 4f       	sbci	r25, 0xFF	; 255
    4086:	98 2f       	mov	r25, r24
    4088:	88 27       	eor	r24, r24
    408a:	2a 81       	ldd	r18, Y+2	; 0x02
    408c:	82 0f       	add	r24, r18
    408e:	91 1d       	adc	r25, r1
    4090:	88 83       	st	Y, r24
    4092:	99 83       	std	Y+1, r25	; 0x01
    4094:	02 c0       	rjmp	.+4      	; 0x409a <ramDyskUstawWskaznikNaKoniec+0x3c>
}

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
  if (fd == NULL)
    return 1;
    4096:	81 e0       	ldi	r24, 0x01	; 1
    4098:	01 c0       	rjmp	.+2      	; 0x409c <ramDyskUstawWskaznikNaKoniec+0x3e>
  if (fd->IndLo != 0)
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
  }  
  return 0;
    409a:	80 e0       	ldi	r24, 0x00	; 0
}
    409c:	df 91       	pop	r29
    409e:	cf 91       	pop	r28
    40a0:	08 95       	ret

000040a2 <ramDyskDodajBlokXmodem>:

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
    40a2:	bf 92       	push	r11
    40a4:	cf 92       	push	r12
    40a6:	df 92       	push	r13
    40a8:	ef 92       	push	r14
    40aa:	ff 92       	push	r15
    40ac:	0f 93       	push	r16
    40ae:	1f 93       	push	r17
    40b0:	cf 93       	push	r28
    40b2:	df 93       	push	r29
    40b4:	8c 01       	movw	r16, r24
    40b6:	6b 01       	movw	r12, r22
  if (nrBloku == 0)
    40b8:	61 15       	cp	r22, r1
    40ba:	71 05       	cpc	r23, r1
    40bc:	09 f4       	brne	.+2      	; 0x40c0 <ramDyskDodajBlokXmodem+0x1e>
    40be:	4f c0       	rjmp	.+158    	; 0x415e <ramDyskDodajBlokXmodem+0xbc>
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
  uint8_t indLo = 0;
  uint8_t *wynik;
  
  if (fd->wpis->pierwszyKlaster == 0)
    40c0:	dc 01       	movw	r26, r24
    40c2:	14 96       	adiw	r26, 0x04	; 4
    40c4:	ed 90       	ld	r14, X+
    40c6:	fc 90       	ld	r15, X
    40c8:	15 97       	sbiw	r26, 0x05	; 5
    40ca:	f7 01       	movw	r30, r14
    40cc:	80 81       	ld	r24, Z
    40ce:	88 23       	and	r24, r24
    40d0:	21 f4       	brne	.+8      	; 0x40da <ramDyskDodajBlokXmodem+0x38>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    40d2:	0e 94 66 1c 	call	0x38cc	; 0x38cc <znajdzWolnyKlaster>
    40d6:	d7 01       	movw	r26, r14
    40d8:	8c 93       	st	X, r24
  if (fd->wpis->pierwszyKlaster == 0)
    40da:	d8 01       	movw	r26, r16
    40dc:	14 96       	adiw	r26, 0x04	; 4
    40de:	ed 91       	ld	r30, X+
    40e0:	fc 91       	ld	r31, X
    40e2:	15 97       	sbiw	r26, 0x05	; 5
    40e4:	80 81       	ld	r24, Z
    40e6:	88 23       	and	r24, r24
    40e8:	d1 f1       	breq	.+116    	; 0x415e <ramDyskDodajBlokXmodem+0xbc>

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
  if (nrBloku == 0)
    return NULL;
  nrBloku --;
    40ea:	08 94       	sec
    40ec:	c1 08       	sbc	r12, r1
    40ee:	d1 08       	sbc	r13, r1
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
    40f0:	76 01       	movw	r14, r12
    40f2:	f6 94       	lsr	r15
    40f4:	e7 94       	ror	r14
    40f6:	be 2c       	mov	r11, r14
  if (fd->wpis->pierwszyKlaster == 0)
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
    40f8:	6e 2d       	mov	r22, r14
    40fa:	0e 94 9e 1c 	call	0x393c	; 0x393c <znajdzKlasterN>
  if (tmpKlaster == 0)
    40fe:	88 23       	and	r24, r24
    4100:	71 f1       	breq	.+92     	; 0x415e <ramDyskDodajBlokXmodem+0xbc>
    4102:	d8 01       	movw	r26, r16
    4104:	14 96       	adiw	r26, 0x04	; 4
    4106:	ed 91       	ld	r30, X+
    4108:	fc 91       	ld	r31, X
    410a:	15 97       	sbiw	r26, 0x05	; 5
    return NULL;
  if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
    410c:	c0 fe       	sbrs	r12, 0
    410e:	0f c0       	rjmp	.+30     	; 0x412e <ramDyskDodajBlokXmodem+0x8c>
  {
    indLo = 128;
    if (fd->wpis->rozmiarHi <= indHi)
    4110:	92 81       	ldd	r25, Z+2	; 0x02
    4112:	e9 16       	cp	r14, r25
    4114:	38 f0       	brcs	.+14     	; 0x4124 <ramDyskDodajBlokXmodem+0x82>
    {
      fd->wpis->rozmiarHi = indHi+1;
    4116:	b3 94       	inc	r11
    4118:	b2 82       	std	Z+2, r11	; 0x02
      fd->wpis->rozmiarLo = 0;
    411a:	14 96       	adiw	r26, 0x04	; 4
    411c:	ed 91       	ld	r30, X+
    411e:	fc 91       	ld	r31, X
    4120:	15 97       	sbiw	r26, 0x05	; 5
    4122:	11 82       	std	Z+1, r1	; 0x01
    }
    wynik=dataPtr(tmpKlaster, 128);
    4124:	80 e0       	ldi	r24, 0x00	; 0
    4126:	ec 01       	movw	r28, r24
    4128:	c0 58       	subi	r28, 0x80	; 128
    412a:	df 47       	sbci	r29, 0x7F	; 127
    412c:	1a c0       	rjmp	.+52     	; 0x4162 <ramDyskDodajBlokXmodem+0xc0>
  }
  else
  {
    if (fd->wpis->rozmiarHi < indHi)
    412e:	92 81       	ldd	r25, Z+2	; 0x02
    4130:	9e 15       	cp	r25, r14
    4132:	38 f4       	brcc	.+14     	; 0x4142 <ramDyskDodajBlokXmodem+0xa0>
    {
      fd->wpis->rozmiarHi = indHi;
    4134:	e2 82       	std	Z+2, r14	; 0x02
      fd->wpis->rozmiarLo = 128;
    4136:	d8 01       	movw	r26, r16
    4138:	14 96       	adiw	r26, 0x04	; 4
    413a:	ed 91       	ld	r30, X+
    413c:	fc 91       	ld	r31, X
    413e:	15 97       	sbiw	r26, 0x05	; 5
    4140:	05 c0       	rjmp	.+10     	; 0x414c <ramDyskDodajBlokXmodem+0xaa>
    }
    else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
    4142:	9e 15       	cp	r25, r14
    4144:	29 f4       	brne	.+10     	; 0x4150 <ramDyskDodajBlokXmodem+0xae>
    4146:	91 81       	ldd	r25, Z+1	; 0x01
    4148:	97 fd       	sbrc	r25, 7
    414a:	02 c0       	rjmp	.+4      	; 0x4150 <ramDyskDodajBlokXmodem+0xae>
      fd->wpis->rozmiarLo = 128;
    414c:	90 e8       	ldi	r25, 0x80	; 128
    414e:	91 83       	std	Z+1, r25	; 0x01
    
    wynik=dataPtr(tmpKlaster, 0);
    4150:	c8 2f       	mov	r28, r24
    4152:	d0 e0       	ldi	r29, 0x00	; 0
    4154:	c0 58       	subi	r28, 0x80	; 128
    4156:	df 4f       	sbci	r29, 0xFF	; 255
    4158:	dc 2f       	mov	r29, r28
    415a:	cc 27       	eor	r28, r28
    415c:	02 c0       	rjmp	.+4      	; 0x4162 <ramDyskDodajBlokXmodem+0xc0>
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
  if (tmpKlaster == 0)
    return NULL;
    415e:	c0 e0       	ldi	r28, 0x00	; 0
    4160:	d0 e0       	ldi	r29, 0x00	; 0
      fd->wpis->rozmiarLo = 128;
    
    wynik=dataPtr(tmpKlaster, 0);
  }
  return wynik;
}
    4162:	ce 01       	movw	r24, r28
    4164:	df 91       	pop	r29
    4166:	cf 91       	pop	r28
    4168:	1f 91       	pop	r17
    416a:	0f 91       	pop	r16
    416c:	ff 90       	pop	r15
    416e:	ef 90       	pop	r14
    4170:	df 90       	pop	r13
    4172:	cf 90       	pop	r12
    4174:	bf 90       	pop	r11
    4176:	08 95       	ret

00004178 <ramDyskDir>:

void ramDyskDir(FILE *ostream)
{
    4178:	2f 92       	push	r2
    417a:	3f 92       	push	r3
    417c:	4f 92       	push	r4
    417e:	5f 92       	push	r5
    4180:	6f 92       	push	r6
    4182:	7f 92       	push	r7
    4184:	9f 92       	push	r9
    4186:	af 92       	push	r10
    4188:	bf 92       	push	r11
    418a:	cf 92       	push	r12
    418c:	df 92       	push	r13
    418e:	ef 92       	push	r14
    4190:	ff 92       	push	r15
    4192:	0f 93       	push	r16
    4194:	1f 93       	push	r17
    4196:	cf 93       	push	r28
    4198:	df 93       	push	r29
    419a:	8c 01       	movw	r16, r24
  fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
    419c:	85 eb       	ldi	r24, 0xB5	; 181
    419e:	94 e2       	ldi	r25, 0x24	; 36
    41a0:	b8 01       	movw	r22, r16
    41a2:	0e 94 cb 57 	call	0xaf96	; 0xaf96 <fputs>
  struct ramPlik *plik;
  uint8_t tmpKlaster = 0;
    41a6:	aa 24       	eor	r10, r10
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    41a8:	4e ec       	ldi	r20, 0xCE	; 206
    41aa:	24 2e       	mov	r2, r20
    41ac:	44 e2       	ldi	r20, 0x24	; 36
    41ae:	34 2e       	mov	r3, r20
    41b0:	01 c0       	rjmp	.+2      	; 0x41b4 <ramDyskDir+0x3c>
      plik++;
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    41b2:	a8 2e       	mov	r10, r24
  uint8_t tmpKlaster = 0;
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    41b4:	ca 2c       	mov	r12, r10
    41b6:	dd 24       	eor	r13, r13
    41b8:	e6 01       	movw	r28, r12
    41ba:	c0 58       	subi	r28, 0x80	; 128
    41bc:	df 4f       	sbci	r29, 0xFF	; 255
    41be:	dc 2f       	mov	r29, r28
    41c0:	cc 27       	eor	r28, r28
    wynik=dataPtr(tmpKlaster, 0);
  }
  return wynik;
}

void ramDyskDir(FILE *ostream)
    41c2:	20 ef       	ldi	r18, 0xF0	; 240
    41c4:	62 2e       	mov	r6, r18
    41c6:	71 2c       	mov	r7, r1
    41c8:	6c 0e       	add	r6, r28
    41ca:	7d 1e       	adc	r7, r29
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    {
      tmp3=plik->nazwa[0];
    41cc:	bc 80       	ldd	r11, Y+4	; 0x04
      if (tmp3 == 0)
    41ce:	bb 20       	and	r11, r11
    41d0:	09 f4       	brne	.+2      	; 0x41d4 <ramDyskDir+0x5c>
    41d2:	48 c0       	rjmp	.+144    	; 0x4264 <ramDyskDir+0xec>
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
    41d4:	8b 2d       	mov	r24, r11
    41d6:	90 e0       	ldi	r25, 0x00	; 0
    41d8:	b8 01       	movw	r22, r16
    41da:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    41de:	7e 01       	movw	r14, r28
      for (tmp2=1; tmp2<8; tmp2++)
    41e0:	99 24       	eor	r9, r9
    41e2:	93 94       	inc	r9
      {
        if (tmp3 != 0)
    41e4:	bb 20       	and	r11, r11
    41e6:	61 f0       	breq	.+24     	; 0x4200 <ramDyskDir+0x88>
          tmp3=plik->nazwa[tmp2];
    41e8:	d7 01       	movw	r26, r14
    41ea:	15 96       	adiw	r26, 0x05	; 5
    41ec:	bc 90       	ld	r11, X
    41ee:	15 97       	sbiw	r26, 0x05	; 5

        if (tmp3 != 0)
    41f0:	bb 20       	and	r11, r11
    41f2:	31 f0       	breq	.+12     	; 0x4200 <ramDyskDir+0x88>
          fputc(tmp3     , ostream);
    41f4:	8b 2d       	mov	r24, r11
    41f6:	90 e0       	ldi	r25, 0x00	; 0
    41f8:	b8 01       	movw	r22, r16
    41fa:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    41fe:	06 c0       	rjmp	.+12     	; 0x420c <ramDyskDir+0x94>
        else
          fputc(' '      , ostream);
    4200:	80 e2       	ldi	r24, 0x20	; 32
    4202:	90 e0       	ldi	r25, 0x00	; 0
    4204:	b8 01       	movw	r22, r16
    4206:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    420a:	bb 24       	eor	r11, r11
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
    420c:	93 94       	inc	r9
    420e:	08 94       	sec
    4210:	e1 1c       	adc	r14, r1
    4212:	f1 1c       	adc	r15, r1
    4214:	b9 2d       	mov	r27, r9
    4216:	b8 30       	cpi	r27, 0x08	; 8
    4218:	29 f7       	brne	.-54     	; 0x41e4 <ramDyskDir+0x6c>
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    421a:	ed b7       	in	r30, 0x3d	; 61
    421c:	fe b7       	in	r31, 0x3e	; 62
    421e:	38 97       	sbiw	r30, 0x08	; 8
    4220:	ed bf       	out	0x3d, r30	; 61
    4222:	fe bf       	out	0x3e, r31	; 62
    4224:	31 96       	adiw	r30, 0x01	; 1
    4226:	ad b7       	in	r26, 0x3d	; 61
    4228:	be b7       	in	r27, 0x3e	; 62
    422a:	11 96       	adiw	r26, 0x01	; 1
    422c:	0d 93       	st	X+, r16
    422e:	1c 93       	st	X, r17
    4230:	12 97       	sbiw	r26, 0x02	; 2
    4232:	22 82       	std	Z+2, r2	; 0x02
    4234:	33 82       	std	Z+3, r3	; 0x03
    4236:	5a 80       	ldd	r5, Y+2	; 0x02
    4238:	44 24       	eor	r4, r4
    423a:	89 81       	ldd	r24, Y+1	; 0x01
    423c:	92 01       	movw	r18, r4
    423e:	28 0f       	add	r18, r24
    4240:	31 1d       	adc	r19, r1
    4242:	24 83       	std	Z+4, r18	; 0x04
    4244:	35 83       	std	Z+5, r19	; 0x05
    4246:	8b 81       	ldd	r24, Y+3	; 0x03
    4248:	86 83       	std	Z+6, r24	; 0x06
    424a:	17 82       	std	Z+7, r1	; 0x07
    424c:	0e 94 72 57 	call	0xaee4	; 0xaee4 <fprintf>
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    4250:	8d b7       	in	r24, 0x3d	; 61
    4252:	9e b7       	in	r25, 0x3e	; 62
    4254:	08 96       	adiw	r24, 0x08	; 8
    4256:	8d bf       	out	0x3d, r24	; 61
    4258:	9e bf       	out	0x3e, r25	; 62
    425a:	c6 15       	cp	r28, r6
    425c:	d7 05       	cpc	r29, r7
    425e:	11 f0       	breq	.+4      	; 0x4264 <ramDyskDir+0xec>
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
      plik++;
    4260:	60 96       	adiw	r28, 0x10	; 16
    4262:	b4 cf       	rjmp	.-152    	; 0x41cc <ramDyskDir+0x54>
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    4264:	f6 01       	movw	r30, r12
    4266:	e5 5d       	subi	r30, 0xD5	; 213
    4268:	fd 4c       	sbci	r31, 0xCD	; 205
    426a:	80 81       	ld	r24, Z
  }
  while (tmpKlaster != tmpKlaster2);
    426c:	8a 15       	cp	r24, r10
    426e:	09 f0       	breq	.+2      	; 0x4272 <ramDyskDir+0xfa>
    4270:	a0 cf       	rjmp	.-192    	; 0x41b2 <ramDyskDir+0x3a>
}
    4272:	df 91       	pop	r29
    4274:	cf 91       	pop	r28
    4276:	1f 91       	pop	r17
    4278:	0f 91       	pop	r16
    427a:	ff 90       	pop	r15
    427c:	ef 90       	pop	r14
    427e:	df 90       	pop	r13
    4280:	cf 90       	pop	r12
    4282:	bf 90       	pop	r11
    4284:	af 90       	pop	r10
    4286:	9f 90       	pop	r9
    4288:	7f 90       	pop	r7
    428a:	6f 90       	pop	r6
    428c:	5f 90       	pop	r5
    428e:	4f 90       	pop	r4
    4290:	3f 90       	pop	r3
    4292:	2f 90       	pop	r2
    4294:	08 95       	ret

00004296 <ramDyskLiczbaWolnychKlastrow>:

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
    4296:	eb ea       	ldi	r30, 0xAB	; 171
    4298:	f2 e3       	ldi	r31, 0x32	; 50
    429a:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    if (klastry[temp] == 0)
    429c:	92 91       	ld	r25, -Z
    429e:	99 23       	and	r25, r25
    42a0:	09 f4       	brne	.+2      	; 0x42a4 <ramDyskLiczbaWolnychKlastrow+0xe>
      wynik++;
    42a2:	8f 5f       	subi	r24, 0xFF	; 255

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    42a4:	92 e3       	ldi	r25, 0x32	; 50
    42a6:	ec 32       	cpi	r30, 0x2C	; 44
    42a8:	f9 07       	cpc	r31, r25
    42aa:	c1 f7       	brne	.-16     	; 0x429c <ramDyskLiczbaWolnychKlastrow+0x6>
    if (klastry[temp] == 0)
      wynik++;
  return wynik;
}
    42ac:	08 95       	ret

000042ae <ramDyskOtworzPlikStdIo>:
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
}

uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags)
{
    42ae:	ef 92       	push	r14
    42b0:	ff 92       	push	r15
    42b2:	0f 93       	push	r16
    42b4:	1f 93       	push	r17
    42b6:	df 93       	push	r29
    42b8:	cf 93       	push	r28
    42ba:	0f 92       	push	r0
    42bc:	cd b7       	in	r28, 0x3d	; 61
    42be:	de b7       	in	r29, 0x3e	; 62
    42c0:	8b 01       	movw	r16, r22
    42c2:	7a 01       	movw	r14, r20
  uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
    42c4:	29 83       	std	Y+1, r18	; 0x01
    42c6:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <ramDyskOtworzPlik>
  if (wynik != 0)
    42ca:	29 81       	ldd	r18, Y+1	; 0x01
    42cc:	88 23       	and	r24, r24
    42ce:	61 f4       	brne	.+24     	; 0x42e8 <ramDyskOtworzPlikStdIo+0x3a>
    return wynik;
  
  fdev_setup_stream(stream, putSTD, getSTD, flags);
    42d0:	47 e6       	ldi	r20, 0x67	; 103
    42d2:	5e e1       	ldi	r21, 0x1E	; 30
    42d4:	f7 01       	movw	r30, r14
    42d6:	40 87       	std	Z+8, r20	; 0x08
    42d8:	51 87       	std	Z+9, r21	; 0x09
    42da:	48 ea       	ldi	r20, 0xA8	; 168
    42dc:	5e e1       	ldi	r21, 0x1E	; 30
    42de:	42 87       	std	Z+10, r20	; 0x0a
    42e0:	53 87       	std	Z+11, r21	; 0x0b
    42e2:	23 83       	std	Z+3, r18	; 0x03
  fdev_set_udata(stream, fd);
    42e4:	04 87       	std	Z+12, r16	; 0x0c
    42e6:	15 87       	std	Z+13, r17	; 0x0d
  return 0;
}
    42e8:	0f 90       	pop	r0
    42ea:	cf 91       	pop	r28
    42ec:	df 91       	pop	r29
    42ee:	1f 91       	pop	r17
    42f0:	0f 91       	pop	r16
    42f2:	ff 90       	pop	r15
    42f4:	ef 90       	pop	r14
    42f6:	08 95       	ret

000042f8 <ramDyskZamknijPlikStdIo>:

uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
{
    42f8:	0f 93       	push	r16
    42fa:	1f 93       	push	r17
    42fc:	cf 93       	push	r28
    42fe:	df 93       	push	r29
    4300:	8c 01       	movw	r16, r24
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
    4302:	fc 01       	movw	r30, r24
    4304:	c4 85       	ldd	r28, Z+12	; 0x0c
    4306:	d5 85       	ldd	r29, Z+13	; 0x0d
  ramDyskZamknijPlik(fd);
    4308:	ce 01       	movw	r24, r28
    430a:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <ramDyskZamknijPlik>
  fclose(stream);
    430e:	c8 01       	movw	r24, r16
    4310:	0e 94 08 57 	call	0xae10	; 0xae10 <fclose>
  return fd->wpis->lAktOtw;
    4314:	ec 81       	ldd	r30, Y+4	; 0x04
    4316:	fd 81       	ldd	r31, Y+5	; 0x05
}
    4318:	83 81       	ldd	r24, Z+3	; 0x03
    431a:	df 91       	pop	r29
    431c:	cf 91       	pop	r28
    431e:	1f 91       	pop	r17
    4320:	0f 91       	pop	r16
    4322:	08 95       	ret

00004324 <cmdlinePrintPrompt>:
    cmdlinePrintPrompt(state);                  // output new prompt
  }
}

void cmdlinePrintPrompt(cmdState_t *state)
{
    4324:	0f 93       	push	r16
    4326:	1f 93       	push	r17
    4328:	cf 93       	push	r28
    432a:	df 93       	push	r29
    432c:	8c 01       	movw	r16, r24
  const char* ptr;
  // print a new command prompt
  switch (state->cliMode)
    432e:	dc 01       	movw	r26, r24
    4330:	90 96       	adiw	r26, 0x20	; 32
    4332:	ec 91       	ld	r30, X
    4334:	90 97       	sbiw	r26, 0x20	; 32
    4336:	e3 30       	cpi	r30, 0x03	; 3
    4338:	40 f4       	brcc	.+16     	; 0x434a <cmdlinePrintPrompt+0x26>
    433a:	f0 e0       	ldi	r31, 0x00	; 0
    433c:	ee 0f       	add	r30, r30
    433e:	ff 1f       	adc	r31, r31
    4340:	e9 52       	subi	r30, 0x29	; 41
    4342:	fb 4d       	sbci	r31, 0xDB	; 219
    4344:	c0 81       	ld	r28, Z
    4346:	d1 81       	ldd	r29, Z+1	; 0x01
    4348:	0e c0       	rjmp	.+28     	; 0x4366 <cmdlinePrintPrompt+0x42>
    434a:	c9 ef       	ldi	r28, 0xF9	; 249
    434c:	d7 e0       	ldi	r29, 0x07	; 7
    434e:	0b c0       	rjmp	.+22     	; 0x4366 <cmdlinePrintPrompt+0x42>
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4350:	21 96       	adiw	r28, 0x01	; 1
    4352:	fc 01       	movw	r30, r24
    4354:	84 91       	lpm	r24, Z+
    4356:	d8 01       	movw	r26, r16
    4358:	5a 96       	adiw	r26, 0x1a	; 26
    435a:	6d 91       	ld	r22, X+
    435c:	7c 91       	ld	r23, X
    435e:	5b 97       	sbiw	r26, 0x1b	; 27
    4360:	90 e0       	ldi	r25, 0x00	; 0
    4362:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    4366:	ce 01       	movw	r24, r28
      break;
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    4368:	fe 01       	movw	r30, r28
    436a:	24 91       	lpm	r18, Z+
    436c:	22 23       	and	r18, r18
    436e:	81 f7       	brne	.-32     	; 0x4350 <cmdlinePrintPrompt+0x2c>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
}
    4370:	df 91       	pop	r29
    4372:	cf 91       	pop	r28
    4374:	1f 91       	pop	r17
    4376:	0f 91       	pop	r16
    4378:	08 95       	ret

0000437a <cmdlineRepaint>:
    state->CmdlineInputVT100State = 1;
  }
}

void cmdlineRepaint(cmdState_t *state, char *buf)
{
    437a:	ff 92       	push	r15
    437c:	0f 93       	push	r16
    437e:	1f 93       	push	r17
    4380:	cf 93       	push	r28
    4382:	df 93       	push	r29
    4384:	ec 01       	movw	r28, r24
    4386:	8b 01       	movw	r16, r22
  uint8_t i;

  // carriage return
  fputc(ASCII_CR         , state->myStdInOut);
    4388:	6a 8d       	ldd	r22, Y+26	; 0x1a
    438a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    438c:	8d e0       	ldi	r24, 0x0D	; 13
    438e:	90 e0       	ldi	r25, 0x00	; 0
    4390:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
  // print fresh prompt
  cmdlinePrintPrompt(state);
    4394:	ce 01       	movw	r24, r28
    4396:	0e 94 92 21 	call	0x4324	; 0x4324 <cmdlinePrintPrompt>
  // print the new command line buffer
  i = state->CmdlineBufferLength;
    439a:	fd 84       	ldd	r15, Y+13	; 0x0d
  while(i--) 
    439c:	0b c0       	rjmp	.+22     	; 0x43b4 <cmdlineRepaint+0x3a>
    fputc(*buf++         , state->myStdInOut);
    439e:	f8 01       	movw	r30, r16
    43a0:	81 91       	ld	r24, Z+
    43a2:	8f 01       	movw	r16, r30
    43a4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    43a6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    43a8:	99 27       	eor	r25, r25
    43aa:	87 fd       	sbrc	r24, 7
    43ac:	90 95       	com	r25
    43ae:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    43b2:	fa 94       	dec	r15
  fputc(ASCII_CR         , state->myStdInOut);
  // print fresh prompt
  cmdlinePrintPrompt(state);
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    43b4:	ff 20       	and	r15, r15
    43b6:	99 f7       	brne	.-26     	; 0x439e <cmdlineRepaint+0x24>
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    43b8:	0c 85       	ldd	r16, Y+12	; 0x0c
    43ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    43bc:	08 1b       	sub	r16, r24
  while (i--)
    43be:	07 c0       	rjmp	.+14     	; 0x43ce <cmdlineRepaint+0x54>
    fputc(' ', state->myStdInOut);
    43c0:	6a 8d       	ldd	r22, Y+26	; 0x1a
    43c2:	7b 8d       	ldd	r23, Y+27	; 0x1b
    43c4:	80 e2       	ldi	r24, 0x20	; 32
    43c6:	90 e0       	ldi	r25, 0x00	; 0
    43c8:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    43cc:	01 50       	subi	r16, 0x01	; 1
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    43ce:	00 23       	and	r16, r16
    43d0:	b9 f7       	brne	.-18     	; 0x43c0 <cmdlineRepaint+0x46>
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    43d2:	0c 85       	ldd	r16, Y+12	; 0x0c
    43d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    43d6:	08 1b       	sub	r16, r24
  while (i--)
    43d8:	07 c0       	rjmp	.+14     	; 0x43e8 <cmdlineRepaint+0x6e>
    fputc(ASCII_BS,  state->myStdInOut);
    43da:	6a 8d       	ldd	r22, Y+26	; 0x1a
    43dc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    43de:	88 e0       	ldi	r24, 0x08	; 8
    43e0:	90 e0       	ldi	r25, 0x00	; 0
    43e2:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    43e6:	01 50       	subi	r16, 0x01	; 1
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    43e8:	00 23       	and	r16, r16
    43ea:	b9 f7       	brne	.-18     	; 0x43da <cmdlineRepaint+0x60>
    fputc(ASCII_BS,  state->myStdInOut);
}
    43ec:	df 91       	pop	r29
    43ee:	cf 91       	pop	r28
    43f0:	1f 91       	pop	r17
    43f2:	0f 91       	pop	r16
    43f4:	ff 90       	pop	r15
    43f6:	08 95       	ret

000043f8 <cmdlineDoHistory>:
  state->historyDepthIdx = 0;
  state->bufferHistoryState = COPIED;
}

void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
{
    43f8:	ef 92       	push	r14
    43fa:	ff 92       	push	r15
    43fc:	cf 93       	push	r28
    43fe:	df 93       	push	r29
    4400:	fb 01       	movw	r30, r22
  uint8_t historyReadIdx;
  switch(action)
    4402:	81 30       	cpi	r24, 0x01	; 1
    4404:	f9 f0       	breq	.+62     	; 0x4444 <cmdlineDoHistory+0x4c>
    4406:	81 30       	cpi	r24, 0x01	; 1
    4408:	20 f0       	brcs	.+8      	; 0x4412 <cmdlineDoHistory+0x1a>
    440a:	82 30       	cpi	r24, 0x02	; 2
    440c:	09 f0       	breq	.+2      	; 0x4410 <cmdlineDoHistory+0x18>
    440e:	55 c0       	rjmp	.+170    	; 0x44ba <cmdlineDoHistory+0xc2>
    4410:	32 c0       	rjmp	.+100    	; 0x4476 <cmdlineDoHistory+0x7e>
  {
  case CMDLINE_HISTORY_SAVE:
    // copy CmdlineBuffer to history if not null string
    state->CmdlineBufferLength  = 0;
    4412:	15 86       	std	Z+13, r1	; 0x0d
    state->CmdlineBufferEditPos = 0;     
    4414:	16 86       	std	Z+14, r1	; 0x0e
    state->bufferHistoryState   = NOT_COPIED;
    4416:	11 8a       	std	Z+17, r1	; 0x11

    if( strlen(state->CmdlineBuffer) )
    4418:	a0 81       	ld	r26, Z
    441a:	b1 81       	ldd	r27, Z+1	; 0x01
    441c:	8c 91       	ld	r24, X
    441e:	88 23       	and	r24, r24
    4420:	09 f4       	brne	.+2      	; 0x4424 <cmdlineDoHistory+0x2c>
    4422:	4b c0       	rjmp	.+150    	; 0x44ba <cmdlineDoHistory+0xc2>
    {
      state->historyWrIdx++;
    4424:	a7 85       	ldd	r26, Z+15	; 0x0f
    4426:	af 5f       	subi	r26, 0xFF	; 255
      state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
    4428:	a3 70       	andi	r26, 0x03	; 3
    442a:	a7 87       	std	Z+15, r26	; 0x0f
      
      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    442c:	b0 e0       	ldi	r27, 0x00	; 0
    442e:	12 96       	adiw	r26, 0x02	; 2
    4430:	aa 0f       	add	r26, r26
    4432:	bb 1f       	adc	r27, r27
    4434:	a6 0f       	add	r26, r22
    4436:	b7 1f       	adc	r27, r23
    4438:	8d 91       	ld	r24, X+
    443a:	9c 91       	ld	r25, X
    443c:	11 97       	sbiw	r26, 0x01	; 1
    443e:	80 83       	st	Z, r24
    4440:	91 83       	std	Z+1, r25	; 0x01
    4442:	3b c0       	rjmp	.+118    	; 0x44ba <cmdlineDoHistory+0xc2>
    }
    break;
  case CMDLINE_HISTORY_PREV:
    if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
    4444:	80 89       	ldd	r24, Z+16	; 0x10
    4446:	83 30       	cpi	r24, 0x03	; 3
    4448:	c1 f1       	breq	.+112    	; 0x44ba <cmdlineDoHistory+0xc2>
      break;                                               //We are on the end of the history list
    
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
    444a:	a7 85       	ldd	r26, Z+15	; 0x0f
    444c:	a1 50       	subi	r26, 0x01	; 1
    444e:	a8 1b       	sub	r26, r24
    4450:	a3 70       	andi	r26, 0x03	; 3
    
    if (state->CmdlineHistory[historyReadIdx][0] == 0)
    4452:	b0 e0       	ldi	r27, 0x00	; 0
    4454:	12 96       	adiw	r26, 0x02	; 2
    4456:	aa 0f       	add	r26, r26
    4458:	bb 1f       	adc	r27, r27
    445a:	a6 0f       	add	r26, r22
    445c:	b7 1f       	adc	r27, r23
    445e:	6d 91       	ld	r22, X+
    4460:	7c 91       	ld	r23, X
    4462:	db 01       	movw	r26, r22
    4464:	9c 91       	ld	r25, X
    4466:	99 23       	and	r25, r25
    4468:	41 f1       	breq	.+80     	; 0x44ba <cmdlineDoHistory+0xc2>
      break;
    
    state->historyDepthIdx++;
    446a:	8f 5f       	subi	r24, 0xFF	; 255
    state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
    446c:	83 70       	andi	r24, 0x03	; 3
    446e:	80 8b       	std	Z+16, r24	; 0x10
    
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    4470:	e6 2e       	mov	r14, r22
    4472:	e7 01       	movw	r28, r14
    4474:	13 c0       	rjmp	.+38     	; 0x449c <cmdlineDoHistory+0xa4>
    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    
    break;
  case CMDLINE_HISTORY_NEXT:      
    if (state->historyDepthIdx == 0)
    4476:	80 89       	ldd	r24, Z+16	; 0x10
    4478:	88 23       	and	r24, r24
    447a:	f9 f0       	breq	.+62     	; 0x44ba <cmdlineDoHistory+0xc2>
      break;                                               //We are on the begining of the history list

    state->historyDepthIdx --;
    447c:	81 50       	subi	r24, 0x01	; 1
    447e:	80 8b       	std	Z+16, r24	; 0x10
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    4480:	a7 85       	ldd	r26, Z+15	; 0x0f
    4482:	a8 1b       	sub	r26, r24
    4484:	a3 70       	andi	r26, 0x03	; 3
   
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    4486:	b0 e0       	ldi	r27, 0x00	; 0
    4488:	12 96       	adiw	r26, 0x02	; 2
    448a:	aa 0f       	add	r26, r26
    448c:	bb 1f       	adc	r27, r27
    448e:	a6 0f       	add	r26, r22
    4490:	b7 1f       	adc	r27, r23
    4492:	6c 91       	ld	r22, X
    4494:	11 96       	adiw	r26, 0x01	; 1
    4496:	7c 91       	ld	r23, X
    4498:	a6 2f       	mov	r26, r22
    449a:	ed 01       	movw	r28, r26
    449c:	7e 01       	movw	r14, r28
    449e:	f7 2e       	mov	r15, r23
    44a0:	d7 01       	movw	r26, r14
    44a2:	0d 90       	ld	r0, X+
    44a4:	00 20       	and	r0, r0
    44a6:	e9 f7       	brne	.-6      	; 0x44a2 <cmdlineDoHistory+0xaa>
    44a8:	11 97       	sbiw	r26, 0x01	; 1
    44aa:	ae 19       	sub	r26, r14
    44ac:	bf 09       	sbc	r27, r15
    44ae:	a5 87       	std	Z+13, r26	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    44b0:	a6 87       	std	Z+14, r26	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    44b2:	11 8a       	std	Z+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    44b4:	cf 01       	movw	r24, r30
    44b6:	0e 94 bd 21 	call	0x437a	; 0x437a <cmdlineRepaint>
    break;
  }
}
    44ba:	df 91       	pop	r29
    44bc:	cf 91       	pop	r28
    44be:	ff 90       	pop	r15
    44c0:	ef 90       	pop	r14
    44c2:	08 95       	ret

000044c4 <cmdHistoryCopy>:
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
}

void cmdHistoryCopy(cmdState_t *state)
{
    44c4:	1f 93       	push	r17
    44c6:	cf 93       	push	r28
    44c8:	df 93       	push	r29
    44ca:	ec 01       	movw	r28, r24
  if (state->historyDepthIdx != 0)
    44cc:	88 89       	ldd	r24, Y+16	; 0x10
    44ce:	88 23       	and	r24, r24
    44d0:	c1 f0       	breq	.+48     	; 0x4502 <cmdHistoryCopy+0x3e>
  {
    uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    44d2:	1f 85       	ldd	r17, Y+15	; 0x0f
    44d4:	18 1b       	sub	r17, r24
    44d6:	13 70       	andi	r17, 0x03	; 3
    memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
    44d8:	4c 85       	ldd	r20, Y+12	; 0x0c
    44da:	88 81       	ld	r24, Y
    44dc:	99 81       	ldd	r25, Y+1	; 0x01
    44de:	60 e0       	ldi	r22, 0x00	; 0
    44e0:	70 e0       	ldi	r23, 0x00	; 0
    44e2:	50 e0       	ldi	r21, 0x00	; 0
    44e4:	0e 94 d2 56 	call	0xada4	; 0xada4 <memset>
    strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
    44e8:	e1 2f       	mov	r30, r17
    44ea:	f0 e0       	ldi	r31, 0x00	; 0
    44ec:	32 96       	adiw	r30, 0x02	; 2
    44ee:	ee 0f       	add	r30, r30
    44f0:	ff 1f       	adc	r31, r31
    44f2:	ec 0f       	add	r30, r28
    44f4:	fd 1f       	adc	r31, r29
    44f6:	60 81       	ld	r22, Z
    44f8:	71 81       	ldd	r23, Z+1	; 0x01
    44fa:	88 81       	ld	r24, Y
    44fc:	99 81       	ldd	r25, Y+1	; 0x01
    44fe:	0e 94 e4 56 	call	0xadc8	; 0xadc8 <strcpy>
  }
  
  state->historyDepthIdx = 0;
    4502:	18 8a       	std	Y+16, r1	; 0x10
  state->bufferHistoryState = COPIED;
    4504:	81 e0       	ldi	r24, 0x01	; 1
    4506:	89 8b       	std	Y+17, r24	; 0x11
}
    4508:	df 91       	pop	r29
    450a:	cf 91       	pop	r28
    450c:	1f 91       	pop	r17
    450e:	08 95       	ret

00004510 <cmdStateConfigure>:
static void cmdHistoryCopy            (cmdState_t *state);
static void cmdHistoryMove            (cmdState_t *state);


void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, const command_t *commands, enum cliModeState mode)
{
    4510:	6f 92       	push	r6
    4512:	7f 92       	push	r7
    4514:	8f 92       	push	r8
    4516:	9f 92       	push	r9
    4518:	af 92       	push	r10
    451a:	bf 92       	push	r11
    451c:	cf 92       	push	r12
    451e:	df 92       	push	r13
    4520:	ef 92       	push	r14
    4522:	0f 93       	push	r16
    4524:	1f 93       	push	r17
    4526:	cf 93       	push	r28
    4528:	df 93       	push	r29
    452a:	ec 01       	movw	r28, r24
    452c:	6b 01       	movw	r12, r22
    452e:	5a 01       	movw	r10, r20
    4530:	49 01       	movw	r8, r18
  memset(state, 0, sizeof(cmdState_t));
    4532:	83 e2       	ldi	r24, 0x23	; 35
    4534:	de 01       	movw	r26, r28
    4536:	1d 92       	st	X+, r1
    4538:	8a 95       	dec	r24
    453a:	e9 f7       	brne	.-6      	; 0x4536 <cmdStateConfigure+0x26>
  memset(buffPtr, 0, bufferTotalSize);
    453c:	cb 01       	movw	r24, r22
    453e:	60 e0       	ldi	r22, 0x00	; 0
    4540:	70 e0       	ldi	r23, 0x00	; 0
    4542:	0e 94 d2 56 	call	0xada4	; 0xada4 <memset>
    
  state->CmdlineBuffer = buffPtr;
    4546:	c8 82       	st	Y, r12
    4548:	d9 82       	std	Y+1, r13	; 0x01
  state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
    454a:	b6 94       	lsr	r11
    454c:	a7 94       	ror	r10
    454e:	b6 94       	lsr	r11
    4550:	a7 94       	ror	r10
    4552:	ac 86       	std	Y+12, r10	; 0x0c

  state->cliMode = mode;
    4554:	e8 a2       	std	Y+32, r14	; 0x20
  state->cmdList = commands;
    4556:	09 a3       	std	Y+33, r16	; 0x21
    4558:	1a a3       	std	Y+34, r17	; 0x22
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    455a:	cc 82       	std	Y+4, r12	; 0x04
    455c:	dd 82       	std	Y+5, r13	; 0x05
    tmpPtr += state->bufferMaxSize;
    455e:	bb 24       	eor	r11, r11
    4560:	ca 0c       	add	r12, r10
    4562:	db 1c       	adc	r13, r11
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    4564:	ce 82       	std	Y+6, r12	; 0x06
    4566:	df 82       	std	Y+7, r13	; 0x07
    tmpPtr += state->bufferMaxSize;
    4568:	ca 0c       	add	r12, r10
    456a:	db 1c       	adc	r13, r11
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    456c:	c8 86       	std	Y+8, r12	; 0x08
    456e:	d9 86       	std	Y+9, r13	; 0x09
    tmpPtr += state->bufferMaxSize;
    4570:	ac 0c       	add	r10, r12
    4572:	bd 1c       	adc	r11, r13
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    4574:	aa 86       	std	Y+10, r10	; 0x0a
    4576:	bb 86       	std	Y+11, r11	; 0x0b
    tmpPtr += state->bufferMaxSize;
  }
  state->myStdInOut = stream;
    4578:	8a 8e       	std	Y+26, r8	; 0x1a
    457a:	9b 8e       	std	Y+27, r9	; 0x1b
}
    457c:	df 91       	pop	r29
    457e:	cf 91       	pop	r28
    4580:	1f 91       	pop	r17
    4582:	0f 91       	pop	r16
    4584:	ef 90       	pop	r14
    4586:	df 90       	pop	r13
    4588:	cf 90       	pop	r12
    458a:	bf 90       	pop	r11
    458c:	af 90       	pop	r10
    458e:	9f 90       	pop	r9
    4590:	8f 90       	pop	r8
    4592:	7f 90       	pop	r7
    4594:	6f 90       	pop	r6
    4596:	08 95       	ret

00004598 <cmdlineInputFunc>:
  // initialize executing function
  state->CmdlineExecFunction = 0;
}

void cmdlineInputFunc(char c, cmdState_t *state)
{
    4598:	8f 92       	push	r8
    459a:	9f 92       	push	r9
    459c:	af 92       	push	r10
    459e:	bf 92       	push	r11
    45a0:	cf 92       	push	r12
    45a2:	df 92       	push	r13
    45a4:	ef 92       	push	r14
    45a6:	ff 92       	push	r15
    45a8:	0f 93       	push	r16
    45aa:	1f 93       	push	r17
    45ac:	df 93       	push	r29
    45ae:	cf 93       	push	r28
    45b0:	00 d0       	rcall	.+0      	; 0x45b2 <cmdlineInputFunc+0x1a>
    45b2:	00 d0       	rcall	.+0      	; 0x45b4 <cmdlineInputFunc+0x1c>
    45b4:	cd b7       	in	r28, 0x3d	; 61
    45b6:	de b7       	in	r29, 0x3e	; 62
    45b8:	08 2f       	mov	r16, r24
    45ba:	7b 01       	movw	r14, r22
  uint8_t i;
  // process the received character

  // VT100 handling
  // are we processing a VT100 command?
  if(state->CmdlineInputVT100State == 2)
    45bc:	db 01       	movw	r26, r22
    45be:	52 96       	adiw	r26, 0x12	; 18
    45c0:	8c 91       	ld	r24, X
    45c2:	52 97       	sbiw	r26, 0x12	; 18
    45c4:	82 30       	cpi	r24, 0x02	; 2
    45c6:	09 f0       	breq	.+2      	; 0x45ca <cmdlineInputFunc+0x32>
    45c8:	5e c0       	rjmp	.+188    	; 0x4686 <cmdlineInputFunc+0xee>
  {
    // we have already received ESC and [
    // now process the vt100 codeCmdlineExcBuffer
    switch(c)
    45ca:	02 34       	cpi	r16, 0x42	; 66
    45cc:	71 f0       	breq	.+28     	; 0x45ea <cmdlineInputFunc+0x52>
    45ce:	03 34       	cpi	r16, 0x43	; 67
    45d0:	24 f4       	brge	.+8      	; 0x45da <cmdlineInputFunc+0x42>
    45d2:	01 34       	cpi	r16, 0x41	; 65
    45d4:	09 f0       	breq	.+2      	; 0x45d8 <cmdlineInputFunc+0x40>
    45d6:	54 c0       	rjmp	.+168    	; 0x4680 <cmdlineInputFunc+0xe8>
    45d8:	06 c0       	rjmp	.+12     	; 0x45e6 <cmdlineInputFunc+0x4e>
    45da:	03 34       	cpi	r16, 0x43	; 67
    45dc:	59 f0       	breq	.+22     	; 0x45f4 <cmdlineInputFunc+0x5c>
    45de:	04 34       	cpi	r16, 0x44	; 68
    45e0:	09 f0       	breq	.+2      	; 0x45e4 <cmdlineInputFunc+0x4c>
    45e2:	4e c0       	rjmp	.+156    	; 0x4680 <cmdlineInputFunc+0xe8>
    45e4:	31 c0       	rjmp	.+98     	; 0x4648 <cmdlineInputFunc+0xb0>
    {
    case VT100_ARROWUP:
      cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
    45e6:	81 e0       	ldi	r24, 0x01	; 1
    45e8:	01 c0       	rjmp	.+2      	; 0x45ec <cmdlineInputFunc+0x54>
      break;
    case VT100_ARROWDOWN:
      cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
    45ea:	82 e0       	ldi	r24, 0x02	; 2
    45ec:	b7 01       	movw	r22, r14
    45ee:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <cmdlineDoHistory>
      break;
    45f2:	46 c0       	rjmp	.+140    	; 0x4680 <cmdlineInputFunc+0xe8>
    case VT100_ARROWRIGHT:
      if (state->bufferHistoryState == NOT_COPIED)
    45f4:	fb 01       	movw	r30, r22
    45f6:	81 89       	ldd	r24, Z+17	; 0x11
    45f8:	88 23       	and	r24, r24
    45fa:	19 f4       	brne	.+6      	; 0x4602 <cmdlineInputFunc+0x6a>
        cmdHistoryCopy(state);
    45fc:	cb 01       	movw	r24, r22
    45fe:	0e 94 62 22 	call	0x44c4	; 0x44c4 <cmdHistoryCopy>
      // if the edit position less than current string length
      if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
    4602:	d7 01       	movw	r26, r14
    4604:	1e 96       	adiw	r26, 0x0e	; 14
    4606:	8c 91       	ld	r24, X
    4608:	1e 97       	sbiw	r26, 0x0e	; 14
    460a:	1d 96       	adiw	r26, 0x0d	; 13
    460c:	9c 91       	ld	r25, X
    460e:	1d 97       	sbiw	r26, 0x0d	; 13
    4610:	5a 96       	adiw	r26, 0x1a	; 26
    4612:	6d 91       	ld	r22, X+
    4614:	7c 91       	ld	r23, X
    4616:	5b 97       	sbiw	r26, 0x1b	; 27
    4618:	89 17       	cp	r24, r25
    461a:	70 f5       	brcc	.+92     	; 0x4678 <cmdlineInputFunc+0xe0>
      {
        // increment the edit position
        state->CmdlineBufferEditPos++;
    461c:	8f 5f       	subi	r24, 0xFF	; 255
    461e:	1e 96       	adiw	r26, 0x0e	; 14
    4620:	8c 93       	st	X, r24
        // move cursor forward one space (no erase)
        fputc(ASCII_ESC        , state->myStdInOut);
    4622:	8b e1       	ldi	r24, 0x1B	; 27
    4624:	90 e0       	ldi	r25, 0x00	; 0
    4626:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        fputc('['              , state->myStdInOut);
    462a:	f7 01       	movw	r30, r14
    462c:	62 8d       	ldd	r22, Z+26	; 0x1a
    462e:	73 8d       	ldd	r23, Z+27	; 0x1b
    4630:	8b e5       	ldi	r24, 0x5B	; 91
    4632:	90 e0       	ldi	r25, 0x00	; 0
    4634:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        fputc(VT100_ARROWRIGHT , state->myStdInOut);
    4638:	d7 01       	movw	r26, r14
    463a:	5a 96       	adiw	r26, 0x1a	; 26
    463c:	6d 91       	ld	r22, X+
    463e:	7c 91       	ld	r23, X
    4640:	5b 97       	sbiw	r26, 0x1b	; 27
    4642:	83 e4       	ldi	r24, 0x43	; 67
    4644:	90 e0       	ldi	r25, 0x00	; 0
    4646:	1a c0       	rjmp	.+52     	; 0x467c <cmdlineInputFunc+0xe4>
        fputc(ASCII_BEL        , state->myStdInOut);
      }
      break;
    case VT100_ARROWLEFT:
      // if the edit position is non-zero
      if (state->bufferHistoryState == NOT_COPIED)
    4648:	fb 01       	movw	r30, r22
    464a:	81 89       	ldd	r24, Z+17	; 0x11
    464c:	88 23       	and	r24, r24
    464e:	19 f4       	brne	.+6      	; 0x4656 <cmdlineInputFunc+0xbe>
        cmdHistoryCopy(state);
    4650:	cb 01       	movw	r24, r22
    4652:	0e 94 62 22 	call	0x44c4	; 0x44c4 <cmdHistoryCopy>
      
      if(state->CmdlineBufferEditPos)
    4656:	d7 01       	movw	r26, r14
    4658:	1e 96       	adiw	r26, 0x0e	; 14
    465a:	8c 91       	ld	r24, X
    465c:	1e 97       	sbiw	r26, 0x0e	; 14
    465e:	5a 96       	adiw	r26, 0x1a	; 26
    4660:	6d 91       	ld	r22, X+
    4662:	7c 91       	ld	r23, X
    4664:	5b 97       	sbiw	r26, 0x1b	; 27
    4666:	88 23       	and	r24, r24
    4668:	39 f0       	breq	.+14     	; 0x4678 <cmdlineInputFunc+0xe0>
      {
        // decrement the edit position
        state->CmdlineBufferEditPos--;
    466a:	81 50       	subi	r24, 0x01	; 1
    466c:	1e 96       	adiw	r26, 0x0e	; 14
    466e:	8c 93       	st	X, r24
    4670:	1e 97       	sbiw	r26, 0x0e	; 14
        // move cursor back one space (no erase)
        fputc(ASCII_BS         , state->myStdInOut);
    4672:	88 e0       	ldi	r24, 0x08	; 8
    4674:	90 e0       	ldi	r25, 0x00	; 0
    4676:	02 c0       	rjmp	.+4      	; 0x467c <cmdlineInputFunc+0xe4>
      }
      else
      {
        // else, ring the bell
        fputc(ASCII_BEL        , state->myStdInOut);
    4678:	87 e0       	ldi	r24, 0x07	; 7
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
      break;
    default:
      break;
    }
    // done, reset state
    state->CmdlineInputVT100State = 0;
    4680:	f7 01       	movw	r30, r14
    4682:	12 8a       	std	Z+18, r1	; 0x12
    return;
    4684:	27 c2       	rjmp	.+1102   	; 0x4ad4 <cmdlineInputFunc+0x53c>
  }
  else if(state->CmdlineInputVT100State == 1)
    4686:	81 30       	cpi	r24, 0x01	; 1
    4688:	39 f4       	brne	.+14     	; 0x4698 <cmdlineInputFunc+0x100>
  {
    // we last received [ESC]
    if(c == '[')
    468a:	0b 35       	cpi	r16, 0x5B	; 91
    468c:	11 f4       	brne	.+4      	; 0x4692 <cmdlineInputFunc+0xfa>
    {
      state->CmdlineInputVT100State = 2;
    468e:	82 e0       	ldi	r24, 0x02	; 2
    4690:	1d c2       	rjmp	.+1082   	; 0x4acc <cmdlineInputFunc+0x534>
      return;
    }
    else
      state->CmdlineInputVT100State = 0;
    4692:	fb 01       	movw	r30, r22
    4694:	12 8a       	std	Z+18, r1	; 0x12
    4696:	04 c0       	rjmp	.+8      	; 0x46a0 <cmdlineInputFunc+0x108>
  }
  else
  {
    // anything else, reset state
    state->CmdlineInputVT100State = 0;
    4698:	db 01       	movw	r26, r22
    469a:	52 96       	adiw	r26, 0x12	; 18
    469c:	1c 92       	st	X, r1
    469e:	52 97       	sbiw	r26, 0x12	; 18
  }

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
    46a0:	f7 01       	movw	r30, r14
    46a2:	85 85       	ldd	r24, Z+13	; 0x0d
    46a4:	94 85       	ldd	r25, Z+12	; 0x0c
    46a6:	89 17       	cp	r24, r25
    46a8:	91 f4       	brne	.+36     	; 0x46ce <cmdlineInputFunc+0x136>
  {
    state->CmdlineBufferLength--;
    46aa:	81 50       	subi	r24, 0x01	; 1
    46ac:	85 87       	std	Z+13, r24	; 0x0d
    for (i=1; i < state->bufferMaxSize; i++)
    46ae:	81 e0       	ldi	r24, 0x01	; 1
    46b0:	0a c0       	rjmp	.+20     	; 0x46c6 <cmdlineInputFunc+0x12e>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    46b2:	d7 01       	movw	r26, r14
    46b4:	ed 91       	ld	r30, X+
    46b6:	fc 91       	ld	r31, X
    46b8:	e8 0f       	add	r30, r24
    46ba:	f1 1d       	adc	r31, r1
    46bc:	df 01       	movw	r26, r30
    46be:	11 97       	sbiw	r26, 0x01	; 1
    46c0:	90 81       	ld	r25, Z
    46c2:	9c 93       	st	X, r25
  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    for (i=1; i < state->bufferMaxSize; i++)
    46c4:	8f 5f       	subi	r24, 0xFF	; 255
    46c6:	f7 01       	movw	r30, r14
    46c8:	94 85       	ldd	r25, Z+12	; 0x0c
    46ca:	89 17       	cp	r24, r25
    46cc:	90 f3       	brcs	.-28     	; 0x46b2 <cmdlineInputFunc+0x11a>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    }
  }
  
  if( (c >= 0x20) && (c < 0x7F) )
    46ce:	80 2f       	mov	r24, r16
    46d0:	80 52       	subi	r24, 0x20	; 32
    46d2:	8f 35       	cpi	r24, 0x5F	; 95
    46d4:	08 f0       	brcs	.+2      	; 0x46d8 <cmdlineInputFunc+0x140>
    46d6:	5b c0       	rjmp	.+182    	; 0x478e <cmdlineInputFunc+0x1f6>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    46d8:	d7 01       	movw	r26, r14
    46da:	51 96       	adiw	r26, 0x11	; 17
    46dc:	8c 91       	ld	r24, X
    46de:	51 97       	sbiw	r26, 0x11	; 17
    46e0:	88 23       	and	r24, r24
    46e2:	19 f4       	brne	.+6      	; 0x46ea <cmdlineInputFunc+0x152>
      cmdHistoryCopy(state);
    46e4:	c7 01       	movw	r24, r14
    46e6:	0e 94 62 22 	call	0x44c4	; 0x44c4 <cmdHistoryCopy>
    // character is printable
    // is this a simple append
    if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    46ea:	f7 01       	movw	r30, r14
    46ec:	85 85       	ldd	r24, Z+13	; 0x0d
    46ee:	96 85       	ldd	r25, Z+14	; 0x0e
    46f0:	98 17       	cp	r25, r24
    46f2:	f1 f4       	brne	.+60     	; 0x4730 <cmdlineInputFunc+0x198>
    {
      // echo character to the output
      fputc(c                , state->myStdInOut);
    46f4:	62 8d       	ldd	r22, Z+26	; 0x1a
    46f6:	73 8d       	ldd	r23, Z+27	; 0x1b
    46f8:	80 2f       	mov	r24, r16
    46fa:	99 27       	eor	r25, r25
    46fc:	87 fd       	sbrc	r24, 7
    46fe:	90 95       	com	r25
    4700:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
      // add it to the command line buffer
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4704:	d7 01       	movw	r26, r14
    4706:	1e 96       	adiw	r26, 0x0e	; 14
    4708:	8c 91       	ld	r24, X
    470a:	1e 97       	sbiw	r26, 0x0e	; 14
    470c:	ed 91       	ld	r30, X+
    470e:	fc 91       	ld	r31, X
    4710:	11 97       	sbiw	r26, 0x01	; 1
    4712:	e8 0f       	add	r30, r24
    4714:	f1 1d       	adc	r31, r1
    4716:	00 83       	st	Z, r16
    4718:	8f 5f       	subi	r24, 0xFF	; 255
    471a:	1e 96       	adiw	r26, 0x0e	; 14
    471c:	8c 93       	st	X, r24
    471e:	1e 97       	sbiw	r26, 0x0e	; 14
      // update buffer length
      state->CmdlineBufferLength++;
    4720:	1d 96       	adiw	r26, 0x0d	; 13
    4722:	8c 91       	ld	r24, X
    4724:	1d 97       	sbiw	r26, 0x0d	; 13
    4726:	8f 5f       	subi	r24, 0xFF	; 255
    4728:	1d 96       	adiw	r26, 0x0d	; 13
    472a:	8c 93       	st	X, r24
    472c:	1d 97       	sbiw	r26, 0x0d	; 13
    472e:	d2 c1       	rjmp	.+932    	; 0x4ad4 <cmdlineInputFunc+0x53c>
    else
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
    4730:	8f 5f       	subi	r24, 0xFF	; 255
    4732:	f7 01       	movw	r30, r14
    4734:	85 87       	std	Z+13, r24	; 0x0d
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    4736:	08 c0       	rjmp	.+16     	; 0x4748 <cmdlineInputFunc+0x1b0>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
    4738:	68 0f       	add	r22, r24
    473a:	71 1d       	adc	r23, r1
    473c:	fb 01       	movw	r30, r22
    473e:	31 97       	sbiw	r30, 0x01	; 1
    4740:	90 81       	ld	r25, Z
    4742:	db 01       	movw	r26, r22
    4744:	9c 93       	st	X, r25
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    4746:	81 50       	subi	r24, 0x01	; 1
    4748:	f7 01       	movw	r30, r14
    474a:	96 85       	ldd	r25, Z+14	; 0x0e
    474c:	60 81       	ld	r22, Z
    474e:	71 81       	ldd	r23, Z+1	; 0x01
    4750:	98 17       	cp	r25, r24
    4752:	90 f3       	brcs	.-28     	; 0x4738 <cmdlineInputFunc+0x1a0>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4754:	69 0f       	add	r22, r25
    4756:	71 1d       	adc	r23, r1
    4758:	db 01       	movw	r26, r22
    475a:	0c 93       	st	X, r16
    475c:	9f 5f       	subi	r25, 0xFF	; 255
    475e:	96 87       	std	Z+14, r25	; 0x0e
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
    4760:	60 81       	ld	r22, Z
    4762:	71 81       	ldd	r23, Z+1	; 0x01
    4764:	c7 01       	movw	r24, r14
    4766:	0e 94 bd 21 	call	0x437a	; 0x437a <cmdlineRepaint>
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    476a:	f7 01       	movw	r30, r14
    476c:	06 85       	ldd	r16, Z+14	; 0x0e
    476e:	0a c0       	rjmp	.+20     	; 0x4784 <cmdlineInputFunc+0x1ec>
        fputc(ASCII_BS         , state->myStdInOut);
    4770:	d7 01       	movw	r26, r14
    4772:	5a 96       	adiw	r26, 0x1a	; 26
    4774:	6d 91       	ld	r22, X+
    4776:	7c 91       	ld	r23, X
    4778:	5b 97       	sbiw	r26, 0x1b	; 27
    477a:	88 e0       	ldi	r24, 0x08	; 8
    477c:	90 e0       	ldi	r25, 0x00	; 0
    477e:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4782:	0f 5f       	subi	r16, 0xFF	; 255
    4784:	f7 01       	movw	r30, r14
    4786:	85 85       	ldd	r24, Z+13	; 0x0d
    4788:	08 17       	cp	r16, r24
    478a:	90 f3       	brcs	.-28     	; 0x4770 <cmdlineInputFunc+0x1d8>
    478c:	a3 c1       	rjmp	.+838    	; 0x4ad4 <cmdlineInputFunc+0x53c>
        fputc(ASCII_BS         , state->myStdInOut);
    }
  }
  // handle special characters
  else if(c == ASCII_CR)
    478e:	0d 30       	cpi	r16, 0x0D	; 13
    4790:	09 f0       	breq	.+2      	; 0x4794 <cmdlineInputFunc+0x1fc>
    4792:	27 c1       	rjmp	.+590    	; 0x49e2 <cmdlineInputFunc+0x44a>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    4794:	d7 01       	movw	r26, r14
    4796:	51 96       	adiw	r26, 0x11	; 17
    4798:	8c 91       	ld	r24, X
    479a:	51 97       	sbiw	r26, 0x11	; 17
    479c:	88 23       	and	r24, r24
    479e:	09 f0       	breq	.+2      	; 0x47a2 <cmdlineInputFunc+0x20a>
    47a0:	49 c0       	rjmp	.+146    	; 0x4834 <cmdlineInputFunc+0x29c>
  state->bufferHistoryState = COPIED;
}

void cmdHistoryMove(cmdState_t *state)
{
  uint8_t i=state->historyDepthIdx;
    47a2:	50 96       	adiw	r26, 0x10	; 16
    47a4:	4c 91       	ld	r20, X
    47a6:	50 97       	sbiw	r26, 0x10	; 16

  if (state->historyDepthIdx != 0)
    47a8:	44 23       	and	r20, r20
    47aa:	79 f1       	breq	.+94     	; 0x480a <cmdlineInputFunc+0x272>
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    47ac:	1f 96       	adiw	r26, 0x0f	; 15
    47ae:	8c 91       	ld	r24, X
    47b0:	1f 97       	sbiw	r26, 0x0f	; 15
    47b2:	90 e0       	ldi	r25, 0x00	; 0
    47b4:	fc 01       	movw	r30, r24
    47b6:	e4 1b       	sub	r30, r20
    47b8:	f1 09       	sbc	r31, r1
    47ba:	e3 70       	andi	r30, 0x03	; 3
    47bc:	f0 70       	andi	r31, 0x00	; 0
    47be:	32 96       	adiw	r30, 0x02	; 2
    47c0:	ee 0f       	add	r30, r30
    47c2:	ff 1f       	adc	r31, r31
    47c4:	ee 0d       	add	r30, r14
    47c6:	ff 1d       	adc	r31, r15
    47c8:	20 81       	ld	r18, Z
    47ca:	31 81       	ldd	r19, Z+1	; 0x01
    47cc:	2d 93       	st	X+, r18
    47ce:	3c 93       	st	X, r19
    47d0:	11 97       	sbiw	r26, 0x01	; 1
    47d2:	19 c0       	rjmp	.+50     	; 0x4806 <cmdlineInputFunc+0x26e>
    for ( ; i<CMD_STATE_HISTORY; i++)
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    47d4:	fc 01       	movw	r30, r24
    47d6:	e4 1b       	sub	r30, r20
    47d8:	f1 09       	sbc	r31, r1
    47da:	df 01       	movw	r26, r30
    47dc:	a3 70       	andi	r26, 0x03	; 3
    47de:	b0 70       	andi	r27, 0x00	; 0
    47e0:	12 96       	adiw	r26, 0x02	; 2
    47e2:	aa 0f       	add	r26, r26
    47e4:	bb 1f       	adc	r27, r27
    47e6:	ae 0d       	add	r26, r14
    47e8:	bf 1d       	adc	r27, r15
    47ea:	31 97       	sbiw	r30, 0x01	; 1
    47ec:	e3 70       	andi	r30, 0x03	; 3
    47ee:	f0 70       	andi	r31, 0x00	; 0
    47f0:	32 96       	adiw	r30, 0x02	; 2
    47f2:	ee 0f       	add	r30, r30
    47f4:	ff 1f       	adc	r31, r31
    47f6:	ee 0d       	add	r30, r14
    47f8:	ff 1d       	adc	r31, r15
    47fa:	20 81       	ld	r18, Z
    47fc:	31 81       	ldd	r19, Z+1	; 0x01
    47fe:	2d 93       	st	X+, r18
    4800:	3c 93       	st	X, r19
    4802:	11 97       	sbiw	r26, 0x01	; 1
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    for ( ; i<CMD_STATE_HISTORY; i++)
    4804:	4f 5f       	subi	r20, 0xFF	; 255
    4806:	44 30       	cpi	r20, 0x04	; 4
    4808:	28 f3       	brcs	.-54     	; 0x47d4 <cmdlineInputFunc+0x23c>
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    }
  }
  state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
    480a:	d7 01       	movw	r26, r14
    480c:	1f 96       	adiw	r26, 0x0f	; 15
    480e:	ec 91       	ld	r30, X
    4810:	1f 97       	sbiw	r26, 0x0f	; 15
    4812:	f0 e0       	ldi	r31, 0x00	; 0
    4814:	32 96       	adiw	r30, 0x02	; 2
    4816:	ee 0f       	add	r30, r30
    4818:	ff 1f       	adc	r31, r31
    481a:	ee 0d       	add	r30, r14
    481c:	ff 1d       	adc	r31, r15
    481e:	8d 91       	ld	r24, X+
    4820:	9c 91       	ld	r25, X
    4822:	11 97       	sbiw	r26, 0x01	; 1
    4824:	80 83       	st	Z, r24
    4826:	91 83       	std	Z+1, r25	; 0x01

  state->historyDepthIdx = 0;
    4828:	50 96       	adiw	r26, 0x10	; 16
    482a:	1c 92       	st	X, r1
    482c:	50 97       	sbiw	r26, 0x10	; 16
  state->bufferHistoryState = COPIED;
    482e:	81 e0       	ldi	r24, 0x01	; 1
    4830:	51 96       	adiw	r26, 0x11	; 17
    4832:	8c 93       	st	X, r24
    if (state->bufferHistoryState == NOT_COPIED)
      cmdHistoryMove(state);
    
    // user pressed [ENTER]
    // echo CR and LF to terminal
    fputc(ASCII_CR         , state->myStdInOut);
    4834:	f7 01       	movw	r30, r14
    4836:	62 8d       	ldd	r22, Z+26	; 0x1a
    4838:	73 8d       	ldd	r23, Z+27	; 0x1b
    483a:	8d e0       	ldi	r24, 0x0D	; 13
    483c:	90 e0       	ldi	r25, 0x00	; 0
    483e:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    fputc(ASCII_LF         , state->myStdInOut);
    4842:	d7 01       	movw	r26, r14
    4844:	5a 96       	adiw	r26, 0x1a	; 26
    4846:	6d 91       	ld	r22, X+
    4848:	7c 91       	ld	r23, X
    484a:	5b 97       	sbiw	r26, 0x1b	; 27
    484c:	8a e0       	ldi	r24, 0x0A	; 10
    484e:	90 e0       	ldi	r25, 0x00	; 0
    4850:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    // add null termination to command
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    4854:	f7 01       	movw	r30, r14
    4856:	85 85       	ldd	r24, Z+13	; 0x0d
    4858:	01 90       	ld	r0, Z+
    485a:	f0 81       	ld	r31, Z
    485c:	e0 2d       	mov	r30, r0
    485e:	e8 0f       	add	r30, r24
    4860:	f1 1d       	adc	r31, r1
    4862:	10 82       	st	Z, r1
    4864:	8f 5f       	subi	r24, 0xFF	; 255
    4866:	d7 01       	movw	r26, r14
    4868:	1d 96       	adiw	r26, 0x0d	; 13
    486a:	8c 93       	st	X, r24
    486c:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos++;
    486e:	1e 96       	adiw	r26, 0x0e	; 14
    4870:	8c 91       	ld	r24, X
    4872:	1e 97       	sbiw	r26, 0x0e	; 14
    4874:	8f 5f       	subi	r24, 0xFF	; 255
    4876:	1e 96       	adiw	r26, 0x0e	; 14
    4878:	8c 93       	st	X, r24
    487a:	1e 97       	sbiw	r26, 0x0e	; 14
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments
    487c:	8d 91       	ld	r24, X+
    487e:	9c 91       	ld	r25, X
    4880:	11 97       	sbiw	r26, 0x01	; 1
    4882:	12 96       	adiw	r26, 0x02	; 2
    4884:	8d 93       	st	X+, r24
    4886:	9c 93       	st	X, r25
    4888:	13 97       	sbiw	r26, 0x03	; 3
  }
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
    488a:	20 e0       	ldi	r18, 0x00	; 0
    488c:	01 c0       	rjmp	.+2      	; 0x4890 <cmdlineInputFunc+0x2f8>
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length
    488e:	2f 5f       	subi	r18, 0xFF	; 255
void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    4890:	a2 2e       	mov	r10, r18
    4892:	bb 24       	eor	r11, r11
    4894:	fc 01       	movw	r30, r24
    4896:	ea 0d       	add	r30, r10
    4898:	fb 1d       	adc	r31, r11
    489a:	30 81       	ld	r19, Z
    489c:	30 32       	cpi	r19, 0x20	; 32
    489e:	11 f0       	breq	.+4      	; 0x48a4 <cmdlineInputFunc+0x30c>
    48a0:	33 23       	and	r19, r19
    48a2:	a9 f7       	brne	.-22     	; 0x488e <cmdlineInputFunc+0x2f6>
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length

  if(!i)                                                              // command was null or empty
    48a4:	22 23       	and	r18, r18
    48a6:	09 f4       	brne	.+2      	; 0x48aa <cmdlineInputFunc+0x312>
    48a8:	91 c0       	rjmp	.+290    	; 0x49cc <cmdlineInputFunc+0x434>
  {
    cmdlinePrintPrompt(state);                                        // output a new prompt
    return;
  }

  const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The list depends of the cli mode
    48aa:	f7 01       	movw	r30, r14
    48ac:	c1 a0       	ldd	r12, Z+33	; 0x21
    48ae:	d2 a0       	ldd	r13, Z+34	; 0x22
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.
    48b0:	8e 01       	movw	r16, r28
    48b2:	0f 5f       	subi	r16, 0xFF	; 255
    48b4:	1f 4f       	sbci	r17, 0xFF	; 255
    48b6:	c8 01       	movw	r24, r16
    48b8:	b6 01       	movw	r22, r12
    48ba:	46 e0       	ldi	r20, 0x06	; 6
    48bc:	50 e0       	ldi	r21, 0x00	; 0
    48be:	0e 94 b2 56 	call	0xad64	; 0xad64 <memcpy_P>
      state->command_help_str    = tmp.commandHelpStr;
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
      return;
    }
    tmpPtr++;                                                         // Next command
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    48c2:	90 2e       	mov	r9, r16
    48c4:	81 2e       	mov	r8, r17
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.

  do                                                                  // search command list for match with entered command
  {
    if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command matched a command in the list
    48c6:	09 81       	ldd	r16, Y+1	; 0x01
    48c8:	1a 81       	ldd	r17, Y+2	; 0x02
    48ca:	d7 01       	movw	r26, r14
    48cc:	12 96       	adiw	r26, 0x02	; 2
    48ce:	8d 91       	ld	r24, X+
    48d0:	9c 91       	ld	r25, X
    48d2:	13 97       	sbiw	r26, 0x03	; 3
    48d4:	b8 01       	movw	r22, r16
    48d6:	a5 01       	movw	r20, r10
    48d8:	0e 94 bb 56 	call	0xad76	; 0xad76 <strncmp_P>
    48dc:	00 97       	sbiw	r24, 0x00	; 0
    48de:	81 f4       	brne	.+32     	; 0x4900 <cmdlineInputFunc+0x368>
    {                                                                 // 
      state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
    48e0:	8d 81       	ldd	r24, Y+5	; 0x05
    48e2:	9e 81       	ldd	r25, Y+6	; 0x06
    48e4:	f7 01       	movw	r30, r14
    48e6:	87 8b       	std	Z+23, r24	; 0x17
    48e8:	90 8f       	std	Z+24, r25	; 0x18
      state->command_str         = tmp.commandStr;
    48ea:	03 8b       	std	Z+19, r16	; 0x13
    48ec:	14 8b       	std	Z+20, r17	; 0x14
      state->command_help_str    = tmp.commandHelpStr;
    48ee:	8b 81       	ldd	r24, Y+3	; 0x03
    48f0:	9c 81       	ldd	r25, Y+4	; 0x04
    48f2:	85 8b       	std	Z+21, r24	; 0x15
    48f4:	96 8b       	std	Z+22, r25	; 0x16
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
    48f6:	80 e0       	ldi	r24, 0x00	; 0
    48f8:	b7 01       	movw	r22, r14
    48fa:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <cmdlineDoHistory>
    48fe:	69 c0       	rjmp	.+210    	; 0x49d2 <cmdlineInputFunc+0x43a>
      return;
    }
    tmpPtr++;                                                         // Next command
    4900:	86 e0       	ldi	r24, 0x06	; 6
    4902:	90 e0       	ldi	r25, 0x00	; 0
    4904:	c8 0e       	add	r12, r24
    4906:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    4908:	89 2d       	mov	r24, r9
    490a:	98 2d       	mov	r25, r8
    490c:	b6 01       	movw	r22, r12
    490e:	46 e0       	ldi	r20, 0x06	; 6
    4910:	50 e0       	ldi	r21, 0x00	; 0
    4912:	0e 94 b2 56 	call	0xad64	; 0xad64 <memcpy_P>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
    4916:	89 81       	ldd	r24, Y+1	; 0x01
    4918:	9a 81       	ldd	r25, Y+2	; 0x02
    491a:	00 97       	sbiw	r24, 0x00	; 0
    491c:	a1 f6       	brne	.-88     	; 0x48c6 <cmdlineInputFunc+0x32e>
    491e:	0e e0       	ldi	r16, 0x0E	; 14
    4920:	18 e0       	ldi	r17, 0x08	; 8
    4922:	0c c0       	rjmp	.+24     	; 0x493c <cmdlineInputFunc+0x3a4>

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4924:	0f 5f       	subi	r16, 0xFF	; 255
    4926:	1f 4f       	sbci	r17, 0xFF	; 255
    4928:	fc 01       	movw	r30, r24
    492a:	84 91       	lpm	r24, Z+
    492c:	d7 01       	movw	r26, r14
    492e:	5a 96       	adiw	r26, 0x1a	; 26
    4930:	6d 91       	ld	r22, X+
    4932:	7c 91       	ld	r23, X
    4934:	5b 97       	sbiw	r26, 0x1b	; 27
    4936:	90 e0       	ldi	r25, 0x00	; 0
    4938:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    493c:	c8 01       	movw	r24, r16
  char * ptr;

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    493e:	f8 01       	movw	r30, r16
    4940:	24 91       	lpm	r18, Z+
    4942:	22 23       	and	r18, r18
    4944:	79 f7       	brne	.-34     	; 0x4924 <cmdlineInputFunc+0x38c>
    4946:	d7 01       	movw	r26, r14
    4948:	0d 91       	ld	r16, X+
    494a:	1c 91       	ld	r17, X
    494c:	11 97       	sbiw	r26, 0x01	; 1
    494e:	08 c0       	rjmp	.+16     	; 0x4960 <cmdlineInputFunc+0x3c8>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    fputc(*ptr++    , state->myStdInOut);
    4950:	f7 01       	movw	r30, r14
    4952:	62 8d       	ldd	r22, Z+26	; 0x1a
    4954:	73 8d       	ldd	r23, Z+27	; 0x1b
    4956:	99 27       	eor	r25, r25
    4958:	87 fd       	sbrc	r24, 7
    495a:	90 95       	com	r25
    495c:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    4960:	d8 01       	movw	r26, r16
    4962:	8d 91       	ld	r24, X+
    4964:	8d 01       	movw	r16, r26
    4966:	88 23       	and	r24, r24
    4968:	11 f0       	breq	.+4      	; 0x496e <cmdlineInputFunc+0x3d6>
    496a:	80 32       	cpi	r24, 0x20	; 32
    496c:	89 f7       	brne	.-30     	; 0x4950 <cmdlineInputFunc+0x3b8>
    fputc(*ptr++    , state->myStdInOut);

  fputc(':'         , state->myStdInOut);
    496e:	f7 01       	movw	r30, r14
    4970:	62 8d       	ldd	r22, Z+26	; 0x1a
    4972:	73 8d       	ldd	r23, Z+27	; 0x1b
    4974:	8a e3       	ldi	r24, 0x3A	; 58
    4976:	90 e0       	ldi	r25, 0x00	; 0
    4978:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
  fputc(' '         , state->myStdInOut);
    497c:	d7 01       	movw	r26, r14
    497e:	5a 96       	adiw	r26, 0x1a	; 26
    4980:	6d 91       	ld	r22, X+
    4982:	7c 91       	ld	r23, X
    4984:	5b 97       	sbiw	r26, 0x1b	; 27
    4986:	80 e2       	ldi	r24, 0x20	; 32
    4988:	90 e0       	ldi	r25, 0x00	; 0
    498a:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
    498e:	08 e1       	ldi	r16, 0x18	; 24
    4990:	18 e0       	ldi	r17, 0x08	; 8
    4992:	07 c0       	rjmp	.+14     	; 0x49a2 <cmdlineInputFunc+0x40a>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4994:	0f 5f       	subi	r16, 0xFF	; 255
    4996:	1f 4f       	sbci	r17, 0xFF	; 255
    4998:	fc 01       	movw	r30, r24
    499a:	84 91       	lpm	r24, Z+
    499c:	90 e0       	ldi	r25, 0x00	; 0
    499e:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    49a2:	c8 01       	movw	r24, r16
  fputc(' '         , state->myStdInOut);

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    49a4:	f8 01       	movw	r30, r16
    49a6:	24 91       	lpm	r18, Z+
    49a8:	d7 01       	movw	r26, r14
    49aa:	5a 96       	adiw	r26, 0x1a	; 26
    49ac:	6d 91       	ld	r22, X+
    49ae:	7c 91       	ld	r23, X
    49b0:	5b 97       	sbiw	r26, 0x1b	; 27
    49b2:	22 23       	and	r18, r18
    49b4:	79 f7       	brne	.-34     	; 0x4994 <cmdlineInputFunc+0x3fc>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);

  fputc('\r'        , state->myStdInOut);
    49b6:	8d e0       	ldi	r24, 0x0D	; 13
    49b8:	90 e0       	ldi	r25, 0x00	; 0
    49ba:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
  fputc('\n'        , state->myStdInOut);
    49be:	f7 01       	movw	r30, r14
    49c0:	62 8d       	ldd	r22, Z+26	; 0x1a
    49c2:	73 8d       	ldd	r23, Z+27	; 0x1b
    49c4:	8a e0       	ldi	r24, 0x0A	; 10
    49c6:	90 e0       	ldi	r25, 0x00	; 0
    49c8:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
  
  // if we did not get a match
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
    49cc:	c7 01       	movw	r24, r14
    49ce:	0e 94 92 21 	call	0x4324	; 0x4324 <cmdlinePrintPrompt>
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    state->CmdlineBufferEditPos++;
    // command is complete, process it
    cmdlineProcessInputString(state);
    // reset buffer
    state->CmdlineBufferLength = 0;
    49d2:	d7 01       	movw	r26, r14
    49d4:	1d 96       	adiw	r26, 0x0d	; 13
    49d6:	1c 92       	st	X, r1
    49d8:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = 0;
    49da:	1e 96       	adiw	r26, 0x0e	; 14
    49dc:	1c 92       	st	X, r1
    49de:	1e 97       	sbiw	r26, 0x0e	; 14
    49e0:	79 c0       	rjmp	.+242    	; 0x4ad4 <cmdlineInputFunc+0x53c>
  }
  else if(c == ASCII_BS)
    49e2:	08 30       	cpi	r16, 0x08	; 8
    49e4:	09 f0       	breq	.+2      	; 0x49e8 <cmdlineInputFunc+0x450>
    49e6:	6d c0       	rjmp	.+218    	; 0x4ac2 <cmdlineInputFunc+0x52a>
  {
    if(state->CmdlineBufferEditPos)
    49e8:	f7 01       	movw	r30, r14
    49ea:	86 85       	ldd	r24, Z+14	; 0x0e
    49ec:	88 23       	and	r24, r24
    49ee:	09 f4       	brne	.+2      	; 0x49f2 <cmdlineInputFunc+0x45a>
    49f0:	60 c0       	rjmp	.+192    	; 0x4ab2 <cmdlineInputFunc+0x51a>
    {
      // is this a simple delete (off the end of the line)
      if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    49f2:	95 85       	ldd	r25, Z+13	; 0x0d
    49f4:	89 17       	cp	r24, r25
    49f6:	31 f5       	brne	.+76     	; 0x4a44 <cmdlineInputFunc+0x4ac>
      {
        // destructive backspace
        // echo backspace-space-backspace
        fputc(ASCII_BS         , state->myStdInOut);
    49f8:	62 8d       	ldd	r22, Z+26	; 0x1a
    49fa:	73 8d       	ldd	r23, Z+27	; 0x1b
    49fc:	88 e0       	ldi	r24, 0x08	; 8
    49fe:	90 e0       	ldi	r25, 0x00	; 0
    4a00:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        fputc(' '              , state->myStdInOut);
    4a04:	d7 01       	movw	r26, r14
    4a06:	5a 96       	adiw	r26, 0x1a	; 26
    4a08:	6d 91       	ld	r22, X+
    4a0a:	7c 91       	ld	r23, X
    4a0c:	5b 97       	sbiw	r26, 0x1b	; 27
    4a0e:	80 e2       	ldi	r24, 0x20	; 32
    4a10:	90 e0       	ldi	r25, 0x00	; 0
    4a12:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        fputc(ASCII_BS         , state->myStdInOut);
    4a16:	f7 01       	movw	r30, r14
    4a18:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a1a:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a1c:	88 e0       	ldi	r24, 0x08	; 8
    4a1e:	90 e0       	ldi	r25, 0x00	; 0
    4a20:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        // decrement our buffer length and edit position
        state->CmdlineBufferLength--;
    4a24:	d7 01       	movw	r26, r14
    4a26:	1d 96       	adiw	r26, 0x0d	; 13
    4a28:	8c 91       	ld	r24, X
    4a2a:	1d 97       	sbiw	r26, 0x0d	; 13
    4a2c:	81 50       	subi	r24, 0x01	; 1
    4a2e:	1d 96       	adiw	r26, 0x0d	; 13
    4a30:	8c 93       	st	X, r24
    4a32:	1d 97       	sbiw	r26, 0x0d	; 13
        state->CmdlineBufferEditPos--;
    4a34:	1e 96       	adiw	r26, 0x0e	; 14
    4a36:	8c 91       	ld	r24, X
    4a38:	1e 97       	sbiw	r26, 0x0e	; 14
    4a3a:	81 50       	subi	r24, 0x01	; 1
    4a3c:	1e 96       	adiw	r26, 0x0e	; 14
    4a3e:	8c 93       	st	X, r24
    4a40:	1e 97       	sbiw	r26, 0x0e	; 14
    4a42:	48 c0       	rjmp	.+144    	; 0x4ad4 <cmdlineInputFunc+0x53c>
      else
      {
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
    4a44:	91 50       	subi	r25, 0x01	; 1
    4a46:	f7 01       	movw	r30, r14
    4a48:	95 87       	std	Z+13, r25	; 0x0d
        state->CmdlineBufferEditPos--;
    4a4a:	81 50       	subi	r24, 0x01	; 1
    4a4c:	86 87       	std	Z+14, r24	; 0x0e
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4a4e:	06 c0       	rjmp	.+12     	; 0x4a5c <cmdlineInputFunc+0x4c4>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
    4a50:	fb 01       	movw	r30, r22
    4a52:	e8 0f       	add	r30, r24
    4a54:	f1 1d       	adc	r31, r1
    4a56:	91 81       	ldd	r25, Z+1	; 0x01
    4a58:	90 83       	st	Z, r25
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
        state->CmdlineBufferEditPos--;
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4a5a:	8f 5f       	subi	r24, 0xFF	; 255
    4a5c:	d7 01       	movw	r26, r14
    4a5e:	1d 96       	adiw	r26, 0x0d	; 13
    4a60:	9c 91       	ld	r25, X
    4a62:	1d 97       	sbiw	r26, 0x0d	; 13
    4a64:	6d 91       	ld	r22, X+
    4a66:	7c 91       	ld	r23, X
    4a68:	11 97       	sbiw	r26, 0x01	; 1
    4a6a:	89 17       	cp	r24, r25
    4a6c:	88 f3       	brcs	.-30     	; 0x4a50 <cmdlineInputFunc+0x4b8>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
    4a6e:	c7 01       	movw	r24, r14
    4a70:	0e 94 bd 21 	call	0x437a	; 0x437a <cmdlineRepaint>
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
    4a74:	f7 01       	movw	r30, r14
    4a76:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a78:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a7a:	80 e2       	ldi	r24, 0x20	; 32
    4a7c:	90 e0       	ldi	r25, 0x00	; 0
    4a7e:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4a82:	d7 01       	movw	r26, r14
    4a84:	1e 96       	adiw	r26, 0x0e	; 14
    4a86:	0c 91       	ld	r16, X
    4a88:	1e 97       	sbiw	r26, 0x0e	; 14
    4a8a:	08 c0       	rjmp	.+16     	; 0x4a9c <cmdlineInputFunc+0x504>
          fputc(ASCII_BS       , state->myStdInOut);
    4a8c:	f7 01       	movw	r30, r14
    4a8e:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a90:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a92:	88 e0       	ldi	r24, 0x08	; 8
    4a94:	90 e0       	ldi	r25, 0x00	; 0
    4a96:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4a9a:	0f 5f       	subi	r16, 0xFF	; 255
    4a9c:	d7 01       	movw	r26, r14
    4a9e:	1d 96       	adiw	r26, 0x0d	; 13
    4aa0:	2c 91       	ld	r18, X
    4aa2:	1d 97       	sbiw	r26, 0x0d	; 13
    4aa4:	30 e0       	ldi	r19, 0x00	; 0
    4aa6:	80 2f       	mov	r24, r16
    4aa8:	90 e0       	ldi	r25, 0x00	; 0
    4aaa:	28 17       	cp	r18, r24
    4aac:	39 07       	cpc	r19, r25
    4aae:	74 f7       	brge	.-36     	; 0x4a8c <cmdlineInputFunc+0x4f4>
    4ab0:	11 c0       	rjmp	.+34     	; 0x4ad4 <cmdlineInputFunc+0x53c>
      }
    }
    else
    {
      // else, ring the bell
      fputc(ASCII_BEL          , state->myStdInOut);
    4ab2:	f7 01       	movw	r30, r14
    4ab4:	62 8d       	ldd	r22, Z+26	; 0x1a
    4ab6:	73 8d       	ldd	r23, Z+27	; 0x1b
    4ab8:	87 e0       	ldi	r24, 0x07	; 7
    4aba:	90 e0       	ldi	r25, 0x00	; 0
    4abc:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    4ac0:	09 c0       	rjmp	.+18     	; 0x4ad4 <cmdlineInputFunc+0x53c>
    }
  }
  else if(c == ASCII_DEL)
    4ac2:	0f 37       	cpi	r16, 0x7F	; 127
    4ac4:	39 f0       	breq	.+14     	; 0x4ad4 <cmdlineInputFunc+0x53c>
  {
    // not yet handled
  }
  else if(c == ASCII_ESC)
    4ac6:	0b 31       	cpi	r16, 0x1B	; 27
    4ac8:	29 f4       	brne	.+10     	; 0x4ad4 <cmdlineInputFunc+0x53c>
  {
    state->CmdlineInputVT100State = 1;
    4aca:	81 e0       	ldi	r24, 0x01	; 1
    4acc:	d7 01       	movw	r26, r14
    4ace:	52 96       	adiw	r26, 0x12	; 18
    4ad0:	8c 93       	st	X, r24
    4ad2:	52 97       	sbiw	r26, 0x12	; 18
  }
}
    4ad4:	26 96       	adiw	r28, 0x06	; 6
    4ad6:	cd bf       	out	0x3d, r28	; 61
    4ad8:	de bf       	out	0x3e, r29	; 62
    4ada:	cf 91       	pop	r28
    4adc:	df 91       	pop	r29
    4ade:	1f 91       	pop	r17
    4ae0:	0f 91       	pop	r16
    4ae2:	ff 90       	pop	r15
    4ae4:	ef 90       	pop	r14
    4ae6:	df 90       	pop	r13
    4ae8:	cf 90       	pop	r12
    4aea:	bf 90       	pop	r11
    4aec:	af 90       	pop	r10
    4aee:	9f 90       	pop	r9
    4af0:	8f 90       	pop	r8
    4af2:	08 95       	ret

00004af4 <cmdLineGetLastArgIdx>:
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
    4af4:	dc 01       	movw	r26, r24
    4af6:	12 96       	adiw	r26, 0x02	; 2
    4af8:	ed 91       	ld	r30, X+
    4afa:	fc 91       	ld	r31, X
    4afc:	13 97       	sbiw	r26, 0x03	; 3
  uint8_t lastWhite = 1;
    4afe:	91 e0       	ldi	r25, 0x01	; 1
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
    4b00:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    4b02:	09 c0       	rjmp	.+18     	; 0x4b16 <cmdLineGetLastArgIdx+0x22>
  {
    if (*str == ' ')
    4b04:	20 32       	cpi	r18, 0x20	; 32
    4b06:	21 f4       	brne	.+8      	; 0x4b10 <cmdLineGetLastArgIdx+0x1c>
    {
      if (lastWhite == 0)
    4b08:	99 23       	and	r25, r25
    4b0a:	21 f4       	brne	.+8      	; 0x4b14 <cmdLineGetLastArgIdx+0x20>
        result++;
    4b0c:	8f 5f       	subi	r24, 0xFF	; 255
    4b0e:	02 c0       	rjmp	.+4      	; 0x4b14 <cmdLineGetLastArgIdx+0x20>
      lastWhite = 1;
    }
    else
      lastWhite = 0;
    4b10:	90 e0       	ldi	r25, 0x00	; 0
    4b12:	01 c0       	rjmp	.+2      	; 0x4b16 <cmdLineGetLastArgIdx+0x22>
  {
    if (*str == ' ')
    {
      if (lastWhite == 0)
        result++;
      lastWhite = 1;
    4b14:	91 e0       	ldi	r25, 0x01	; 1
uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    4b16:	21 91       	ld	r18, Z+
    4b18:	22 23       	and	r18, r18
    4b1a:	a1 f7       	brne	.-24     	; 0x4b04 <cmdLineGetLastArgIdx+0x10>
    else
      lastWhite = 0;
    str++;
  }
  return result;
}
    4b1c:	08 95       	ret

00004b1e <cmdlineMainLoop>:
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
}

void cmdlineMainLoop(cmdState_t *state)
{
    4b1e:	0f 93       	push	r16
    4b20:	1f 93       	push	r17
    4b22:	cf 93       	push	r28
    4b24:	df 93       	push	r29
    4b26:	ec 01       	movw	r28, r24
  cliExRes_t result;
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
    4b28:	0f 89       	ldd	r16, Y+23	; 0x17
    4b2a:	18 8d       	ldd	r17, Y+24	; 0x18
    4b2c:	01 15       	cp	r16, r1
    4b2e:	11 05       	cpc	r17, r1
    4b30:	09 f4       	brne	.+2      	; 0x4b34 <cmdlineMainLoop+0x16>
    4b32:	86 c0       	rjmp	.+268    	; 0x4c40 <cmdlineMainLoop+0x122>
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    4b34:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <cmdLineGetLastArgIdx>
    4b38:	89 8f       	std	Y+25, r24	; 0x19
    result = state->CmdlineExecFunction(state); // run it
    4b3a:	ce 01       	movw	r24, r28
    4b3c:	f8 01       	movw	r30, r16
    4b3e:	19 95       	eicall
    
    switch(result)
    4b40:	82 30       	cpi	r24, 0x02	; 2
    4b42:	91 05       	cpc	r25, r1
    4b44:	e1 f0       	breq	.+56     	; 0x4b7e <cmdlineMainLoop+0x60>
    4b46:	83 30       	cpi	r24, 0x03	; 3
    4b48:	91 05       	cpc	r25, r1
    4b4a:	28 f4       	brcc	.+10     	; 0x4b56 <cmdlineMainLoop+0x38>
    4b4c:	81 30       	cpi	r24, 0x01	; 1
    4b4e:	91 05       	cpc	r25, r1
    4b50:	09 f0       	breq	.+2      	; 0x4b54 <cmdlineMainLoop+0x36>
    4b52:	6d c0       	rjmp	.+218    	; 0x4c2e <cmdlineMainLoop+0x110>
    4b54:	09 c0       	rjmp	.+18     	; 0x4b68 <cmdlineMainLoop+0x4a>
    4b56:	84 30       	cpi	r24, 0x04	; 4
    4b58:	91 05       	cpc	r25, r1
    4b5a:	09 f4       	brne	.+2      	; 0x4b5e <cmdlineMainLoop+0x40>
    4b5c:	4b c0       	rjmp	.+150    	; 0x4bf4 <cmdlineMainLoop+0xd6>
    4b5e:	85 30       	cpi	r24, 0x05	; 5
    4b60:	91 05       	cpc	r25, r1
    4b62:	09 f0       	breq	.+2      	; 0x4b66 <cmdlineMainLoop+0x48>
    4b64:	64 c0       	rjmp	.+200    	; 0x4c2e <cmdlineMainLoop+0x110>
    4b66:	51 c0       	rjmp	.+162    	; 0x4c0a <cmdlineMainLoop+0xec>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
    4b68:	00 d0       	rcall	.+0      	; 0x4b6a <cmdlineMainLoop+0x4c>
    4b6a:	0f 92       	push	r0
    4b6c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4b6e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4b70:	ed b7       	in	r30, 0x3d	; 61
    4b72:	fe b7       	in	r31, 0x3e	; 62
    4b74:	81 83       	std	Z+1, r24	; 0x01
    4b76:	92 83       	std	Z+2, r25	; 0x02
    4b78:	86 e6       	ldi	r24, 0x66	; 102
    4b7a:	98 e0       	ldi	r25, 0x08	; 8
    4b7c:	50 c0       	rjmp	.+160    	; 0x4c1e <cmdlineMainLoop+0x100>
        break;
      case SYNTAX_ERROR:
        fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
    4b7e:	00 d0       	rcall	.+0      	; 0x4b80 <cmdlineMainLoop+0x62>
    4b80:	0f 92       	push	r0
    4b82:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4b84:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4b86:	ed b7       	in	r30, 0x3d	; 61
    4b88:	fe b7       	in	r31, 0x3e	; 62
    4b8a:	81 83       	std	Z+1, r24	; 0x01
    4b8c:	92 83       	std	Z+2, r25	; 0x02
    4b8e:	82 e5       	ldi	r24, 0x52	; 82
    4b90:	98 e0       	ldi	r25, 0x08	; 8
    4b92:	83 83       	std	Z+3, r24	; 0x03
    4b94:	94 83       	std	Z+4, r25	; 0x04
    4b96:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_str);
    4b9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4b9c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4b9e:	ed b7       	in	r30, 0x3d	; 61
    4ba0:	fe b7       	in	r31, 0x3e	; 62
    4ba2:	81 83       	std	Z+1, r24	; 0x01
    4ba4:	92 83       	std	Z+2, r25	; 0x02
    4ba6:	8b 89       	ldd	r24, Y+19	; 0x13
    4ba8:	9c 89       	ldd	r25, Y+20	; 0x14
    4baa:	83 83       	std	Z+3, r24	; 0x03
    4bac:	94 83       	std	Z+4, r25	; 0x04
    4bae:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR(" "));
    4bb2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4bb4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4bb6:	ed b7       	in	r30, 0x3d	; 61
    4bb8:	fe b7       	in	r31, 0x3e	; 62
    4bba:	81 83       	std	Z+1, r24	; 0x01
    4bbc:	92 83       	std	Z+2, r25	; 0x02
    4bbe:	80 e5       	ldi	r24, 0x50	; 80
    4bc0:	98 e0       	ldi	r25, 0x08	; 8
    4bc2:	83 83       	std	Z+3, r24	; 0x03
    4bc4:	94 83       	std	Z+4, r25	; 0x04
    4bc6:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_help_str);
    4bca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4bcc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4bce:	ed b7       	in	r30, 0x3d	; 61
    4bd0:	fe b7       	in	r31, 0x3e	; 62
    4bd2:	81 83       	std	Z+1, r24	; 0x01
    4bd4:	92 83       	std	Z+2, r25	; 0x02
    4bd6:	8d 89       	ldd	r24, Y+21	; 0x15
    4bd8:	9e 89       	ldd	r25, Y+22	; 0x16
    4bda:	83 83       	std	Z+3, r24	; 0x03
    4bdc:	94 83       	std	Z+4, r25	; 0x04
    4bde:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4be2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4be4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4be6:	ed b7       	in	r30, 0x3d	; 61
    4be8:	fe b7       	in	r31, 0x3e	; 62
    4bea:	81 83       	std	Z+1, r24	; 0x01
    4bec:	92 83       	std	Z+2, r25	; 0x02
    4bee:	8d e4       	ldi	r24, 0x4D	; 77
    4bf0:	98 e0       	ldi	r25, 0x08	; 8
    4bf2:	15 c0       	rjmp	.+42     	; 0x4c1e <cmdlineMainLoop+0x100>
        break;
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
    4bf4:	00 d0       	rcall	.+0      	; 0x4bf6 <cmdlineMainLoop+0xd8>
    4bf6:	0f 92       	push	r0
    4bf8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4bfa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4bfc:	ed b7       	in	r30, 0x3d	; 61
    4bfe:	fe b7       	in	r31, 0x3e	; 62
    4c00:	81 83       	std	Z+1, r24	; 0x01
    4c02:	92 83       	std	Z+2, r25	; 0x02
    4c04:	8a e3       	ldi	r24, 0x3A	; 58
    4c06:	98 e0       	ldi	r25, 0x08	; 8
    4c08:	0a c0       	rjmp	.+20     	; 0x4c1e <cmdlineMainLoop+0x100>
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    4c0a:	00 d0       	rcall	.+0      	; 0x4c0c <cmdlineMainLoop+0xee>
    4c0c:	0f 92       	push	r0
    4c0e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c10:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c12:	ed b7       	in	r30, 0x3d	; 61
    4c14:	fe b7       	in	r31, 0x3e	; 62
    4c16:	81 83       	std	Z+1, r24	; 0x01
    4c18:	92 83       	std	Z+2, r25	; 0x02
    4c1a:	82 e2       	ldi	r24, 0x22	; 34
    4c1c:	98 e0       	ldi	r25, 0x08	; 8
    4c1e:	83 83       	std	Z+3, r24	; 0x03
    4c20:	94 83       	std	Z+4, r25	; 0x04
    4c22:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
        break;
    4c26:	0f 90       	pop	r0
    4c28:	0f 90       	pop	r0
    4c2a:	0f 90       	pop	r0
    4c2c:	0f 90       	pop	r0
      default:
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    4c2e:	1f 8a       	std	Y+23, r1	; 0x17
    4c30:	18 8e       	std	Y+24, r1	; 0x18
    state->command_str         = NULL;
    4c32:	1b 8a       	std	Y+19, r1	; 0x13
    4c34:	1c 8a       	std	Y+20, r1	; 0x14
    state->command_help_str    = NULL;
    4c36:	1d 8a       	std	Y+21, r1	; 0x15
    4c38:	1e 8a       	std	Y+22, r1	; 0x16
    cmdlinePrintPrompt(state);                  // output new prompt
    4c3a:	ce 01       	movw	r24, r28
    4c3c:	0e 94 92 21 	call	0x4324	; 0x4324 <cmdlinePrintPrompt>
  }
}
    4c40:	df 91       	pop	r29
    4c42:	cf 91       	pop	r28
    4c44:	1f 91       	pop	r17
    4c46:	0f 91       	pop	r16
    4c48:	08 95       	ret

00004c4a <cmdlineGetArgStr>:
  // find the offset of argument number [argnum]
  uint8_t idx=0;
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4c4a:	fb 01       	movw	r30, r22
    4c4c:	22 81       	ldd	r18, Z+2	; 0x02
    4c4e:	33 81       	ldd	r19, Z+3	; 0x03
}

char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
{
  // find the offset of argument number [argnum]
  uint8_t idx=0;
    4c50:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4c52:	01 c0       	rjmp	.+2      	; 0x4c56 <cmdlineGetArgStr+0xc>
    4c54:	9f 5f       	subi	r25, 0xFF	; 255
    4c56:	f9 01       	movw	r30, r18
    4c58:	e9 0f       	add	r30, r25
    4c5a:	f1 1d       	adc	r31, r1
    4c5c:	40 81       	ld	r20, Z
    4c5e:	40 32       	cpi	r20, 0x20	; 32
    4c60:	c9 f3       	breq	.-14     	; 0x4c54 <cmdlineGetArgStr+0xa>
    4c62:	40 e0       	ldi	r20, 0x00	; 0
    4c64:	12 c0       	rjmp	.+36     	; 0x4c8a <cmdlineGetArgStr+0x40>
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
  {
    // find the next whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    4c66:	9f 5f       	subi	r25, 0xFF	; 255
    4c68:	f9 01       	movw	r30, r18
    4c6a:	e9 0f       	add	r30, r25
    4c6c:	f1 1d       	adc	r31, r1
    4c6e:	50 81       	ld	r21, Z
    4c70:	55 23       	and	r21, r21
    4c72:	21 f0       	breq	.+8      	; 0x4c7c <cmdlineGetArgStr+0x32>
    4c74:	50 32       	cpi	r21, 0x20	; 32
    4c76:	b9 f7       	brne	.-18     	; 0x4c66 <cmdlineGetArgStr+0x1c>
    4c78:	01 c0       	rjmp	.+2      	; 0x4c7c <cmdlineGetArgStr+0x32>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4c7a:	9f 5f       	subi	r25, 0xFF	; 255
    4c7c:	f9 01       	movw	r30, r18
    4c7e:	e9 0f       	add	r30, r25
    4c80:	f1 1d       	adc	r31, r1
    4c82:	50 81       	ld	r21, Z
    4c84:	50 32       	cpi	r21, 0x20	; 32
    4c86:	c9 f3       	breq	.-14     	; 0x4c7a <cmdlineGetArgStr+0x30>
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    4c88:	4f 5f       	subi	r20, 0xFF	; 255
    4c8a:	48 17       	cp	r20, r24
    4c8c:	68 f3       	brcs	.-38     	; 0x4c68 <cmdlineGetArgStr+0x1e>
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  }
  // we are at the requested argument or the end of the buffer
  return &state->CmdlineExcBuffer[idx];
    4c8e:	29 0f       	add	r18, r25
    4c90:	31 1d       	adc	r19, r1
}
    4c92:	c9 01       	movw	r24, r18
    4c94:	08 95       	ret

00004c96 <cmdlineGetArgInt>:

// return argument [argnum] interpreted as a decimal integer
long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
{
    4c96:	df 93       	push	r29
    4c98:	cf 93       	push	r28
    4c9a:	0f 92       	push	r0
    4c9c:	0f 92       	push	r0
    4c9e:	cd b7       	in	r28, 0x3d	; 61
    4ca0:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
    4ca2:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    4ca6:	be 01       	movw	r22, r28
    4ca8:	6f 5f       	subi	r22, 0xFF	; 255
    4caa:	7f 4f       	sbci	r23, 0xFF	; 255
    4cac:	4a e0       	ldi	r20, 0x0A	; 10
    4cae:	50 e0       	ldi	r21, 0x00	; 0
    4cb0:	0e 94 6d 55 	call	0xaada	; 0xaada <strtol>
}
    4cb4:	0f 90       	pop	r0
    4cb6:	0f 90       	pop	r0
    4cb8:	cf 91       	pop	r28
    4cba:	df 91       	pop	r29
    4cbc:	08 95       	ret

00004cbe <cmdlineGetArgHex>:

// return argument [argnum] interpreted as a hex integer
long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
{
    4cbe:	df 93       	push	r29
    4cc0:	cf 93       	push	r28
    4cc2:	0f 92       	push	r0
    4cc4:	0f 92       	push	r0
    4cc6:	cd b7       	in	r28, 0x3d	; 61
    4cc8:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
    4cca:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <cmdlineGetArgStr>
    4cce:	be 01       	movw	r22, r28
    4cd0:	6f 5f       	subi	r22, 0xFF	; 255
    4cd2:	7f 4f       	sbci	r23, 0xFF	; 255
    4cd4:	40 e1       	ldi	r20, 0x10	; 16
    4cd6:	50 e0       	ldi	r21, 0x00	; 0
    4cd8:	0e 94 6d 55 	call	0xaada	; 0xaada <strtol>
}
    4cdc:	0f 90       	pop	r0
    4cde:	0f 90       	pop	r0
    4ce0:	cf 91       	pop	r28
    4ce2:	df 91       	pop	r29
    4ce4:	08 95       	ret

00004ce6 <cmdPrintHelp>:

void cmdPrintHelp(cmdState_t *state)
{
    4ce6:	8f 92       	push	r8
    4ce8:	9f 92       	push	r9
    4cea:	af 92       	push	r10
    4cec:	bf 92       	push	r11
    4cee:	cf 92       	push	r12
    4cf0:	df 92       	push	r13
    4cf2:	ef 92       	push	r14
    4cf4:	ff 92       	push	r15
    4cf6:	0f 93       	push	r16
    4cf8:	1f 93       	push	r17
    4cfa:	df 93       	push	r29
    4cfc:	cf 93       	push	r28
    4cfe:	00 d0       	rcall	.+0      	; 0x4d00 <cmdPrintHelp+0x1a>
    4d00:	00 d0       	rcall	.+0      	; 0x4d02 <cmdPrintHelp+0x1c>
    4d02:	cd b7       	in	r28, 0x3d	; 61
    4d04:	de b7       	in	r29, 0x3e	; 62
    4d06:	8c 01       	movw	r16, r24
  command_t  tmp;
  const command_t *tmpPtr = state->cmdList;
    4d08:	fc 01       	movw	r30, r24
    4d0a:	e1 a0       	ldd	r14, Z+33	; 0x21
    4d0c:	f2 a0       	ldd	r15, Z+34	; 0x22
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4d0e:	6e 01       	movw	r12, r28
    4d10:	08 94       	sec
    4d12:	c1 1c       	adc	r12, r1
    4d14:	d1 1c       	adc	r13, r1
    4d16:	c6 01       	movw	r24, r12
    4d18:	b7 01       	movw	r22, r14
    4d1a:	46 e0       	ldi	r20, 0x06	; 6
    4d1c:	50 e0       	ldi	r21, 0x00	; 0
    4d1e:	0e 94 b2 56 	call	0xad64	; 0xad64 <memcpy_P>
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4d22:	90 e2       	ldi	r25, 0x20	; 32
    4d24:	a9 2e       	mov	r10, r25
    4d26:	98 e0       	ldi	r25, 0x08	; 8
    4d28:	b9 2e       	mov	r11, r25
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4d2a:	8d e1       	ldi	r24, 0x1D	; 29
    4d2c:	88 2e       	mov	r8, r24
    4d2e:	88 e0       	ldi	r24, 0x08	; 8
    4d30:	98 2e       	mov	r9, r24

    tmpPtr++;
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4d32:	c6 01       	movw	r24, r12
    4d34:	dc 2c       	mov	r13, r12
    4d36:	c9 2e       	mov	r12, r25
  const command_t *tmpPtr = state->cmdList;
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    4d38:	00 d0       	rcall	.+0      	; 0x4d3a <cmdPrintHelp+0x54>
    4d3a:	0f 92       	push	r0
    4d3c:	f8 01       	movw	r30, r16
    4d3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d40:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d42:	ed b7       	in	r30, 0x3d	; 61
    4d44:	fe b7       	in	r31, 0x3e	; 62
    4d46:	81 83       	std	Z+1, r24	; 0x01
    4d48:	92 83       	std	Z+2, r25	; 0x02
    4d4a:	89 81       	ldd	r24, Y+1	; 0x01
    4d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d4e:	83 83       	std	Z+3, r24	; 0x03
    4d50:	94 83       	std	Z+4, r25	; 0x04
    4d52:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4d56:	f8 01       	movw	r30, r16
    4d58:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d5a:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d5c:	ed b7       	in	r30, 0x3d	; 61
    4d5e:	fe b7       	in	r31, 0x3e	; 62
    4d60:	81 83       	std	Z+1, r24	; 0x01
    4d62:	92 83       	std	Z+2, r25	; 0x02
    4d64:	a3 82       	std	Z+3, r10	; 0x03
    4d66:	b4 82       	std	Z+4, r11	; 0x04
    4d68:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    4d6c:	f8 01       	movw	r30, r16
    4d6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d70:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d72:	ed b7       	in	r30, 0x3d	; 61
    4d74:	fe b7       	in	r31, 0x3e	; 62
    4d76:	81 83       	std	Z+1, r24	; 0x01
    4d78:	92 83       	std	Z+2, r25	; 0x02
    4d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    4d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    4d7e:	83 83       	std	Z+3, r24	; 0x03
    4d80:	94 83       	std	Z+4, r25	; 0x04
    4d82:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4d86:	f8 01       	movw	r30, r16
    4d88:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d8a:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d8c:	ed b7       	in	r30, 0x3d	; 61
    4d8e:	fe b7       	in	r31, 0x3e	; 62
    4d90:	81 83       	std	Z+1, r24	; 0x01
    4d92:	92 83       	std	Z+2, r25	; 0x02
    4d94:	83 82       	std	Z+3, r8	; 0x03
    4d96:	94 82       	std	Z+4, r9	; 0x04
    4d98:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>

    tmpPtr++;
    4d9c:	86 e0       	ldi	r24, 0x06	; 6
    4d9e:	90 e0       	ldi	r25, 0x00	; 0
    4da0:	e8 0e       	add	r14, r24
    4da2:	f9 1e       	adc	r15, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4da4:	0f 90       	pop	r0
    4da6:	0f 90       	pop	r0
    4da8:	0f 90       	pop	r0
    4daa:	0f 90       	pop	r0
    4dac:	8d 2d       	mov	r24, r13
    4dae:	9c 2d       	mov	r25, r12
    4db0:	b7 01       	movw	r22, r14
    4db2:	46 e0       	ldi	r20, 0x06	; 6
    4db4:	50 e0       	ldi	r21, 0x00	; 0
    4db6:	0e 94 b2 56 	call	0xad64	; 0xad64 <memcpy_P>
  }
  while (tmp.commandFun != NULL);
    4dba:	8d 81       	ldd	r24, Y+5	; 0x05
    4dbc:	9e 81       	ldd	r25, Y+6	; 0x06
    4dbe:	00 97       	sbiw	r24, 0x00	; 0
    4dc0:	09 f0       	breq	.+2      	; 0x4dc4 <cmdPrintHelp+0xde>
    4dc2:	ba cf       	rjmp	.-140    	; 0x4d38 <cmdPrintHelp+0x52>
}
    4dc4:	26 96       	adiw	r28, 0x06	; 6
    4dc6:	cd bf       	out	0x3d, r28	; 61
    4dc8:	de bf       	out	0x3e, r29	; 62
    4dca:	cf 91       	pop	r28
    4dcc:	df 91       	pop	r29
    4dce:	1f 91       	pop	r17
    4dd0:	0f 91       	pop	r16
    4dd2:	ff 90       	pop	r15
    4dd4:	ef 90       	pop	r14
    4dd6:	df 90       	pop	r13
    4dd8:	cf 90       	pop	r12
    4dda:	bf 90       	pop	r11
    4ddc:	af 90       	pop	r10
    4dde:	9f 90       	pop	r9
    4de0:	8f 90       	pop	r8
    4de2:	08 95       	ret

00004de4 <vt100Init>:
void vt100Init(cmdState_t *state)
{
  // initializes terminal to "power-on" settings
  // ESC c

 fprintf_P(state->myStdInOut, "\x1B\x63");
    4de4:	00 d0       	rcall	.+0      	; 0x4de6 <vt100Init+0x2>
    4de6:	0f 92       	push	r0
    4de8:	fc 01       	movw	r30, r24
    4dea:	82 8d       	ldd	r24, Z+26	; 0x1a
    4dec:	93 8d       	ldd	r25, Z+27	; 0x1b
    4dee:	ed b7       	in	r30, 0x3d	; 61
    4df0:	fe b7       	in	r31, 0x3e	; 62
    4df2:	81 83       	std	Z+1, r24	; 0x01
    4df4:	92 83       	std	Z+2, r25	; 0x02
    4df6:	8d ed       	ldi	r24, 0xDD	; 221
    4df8:	94 e2       	ldi	r25, 0x24	; 36
    4dfa:	83 83       	std	Z+3, r24	; 0x03
    4dfc:	94 83       	std	Z+4, r25	; 0x04
    4dfe:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    4e02:	0f 90       	pop	r0
    4e04:	0f 90       	pop	r0
    4e06:	0f 90       	pop	r0
    4e08:	0f 90       	pop	r0
}
    4e0a:	08 95       	ret

00004e0c <vt100ClearScreen>:

void vt100ClearScreen(cmdState_t *state)
{
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
    4e0c:	00 d0       	rcall	.+0      	; 0x4e0e <vt100ClearScreen+0x2>
    4e0e:	0f 92       	push	r0
    4e10:	fc 01       	movw	r30, r24
    4e12:	82 8d       	ldd	r24, Z+26	; 0x1a
    4e14:	93 8d       	ldd	r25, Z+27	; 0x1b
    4e16:	ed b7       	in	r30, 0x3d	; 61
    4e18:	fe b7       	in	r31, 0x3e	; 62
    4e1a:	81 83       	std	Z+1, r24	; 0x01
    4e1c:	92 83       	std	Z+2, r25	; 0x02
    4e1e:	80 ee       	ldi	r24, 0xE0	; 224
    4e20:	94 e2       	ldi	r25, 0x24	; 36
    4e22:	83 83       	std	Z+3, r24	; 0x03
    4e24:	94 83       	std	Z+4, r25	; 0x04
    4e26:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    4e2a:	0f 90       	pop	r0
    4e2c:	0f 90       	pop	r0
    4e2e:	0f 90       	pop	r0
    4e30:	0f 90       	pop	r0
}
    4e32:	08 95       	ret

00004e34 <vt100SetAttr>:

void vt100SetAttr(uint8_t attr, cmdState_t *state)
{
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
    4e34:	00 d0       	rcall	.+0      	; 0x4e36 <vt100SetAttr+0x2>
    4e36:	00 d0       	rcall	.+0      	; 0x4e38 <vt100SetAttr+0x4>
    4e38:	ed b7       	in	r30, 0x3d	; 61
    4e3a:	fe b7       	in	r31, 0x3e	; 62
    4e3c:	31 96       	adiw	r30, 0x01	; 1
    4e3e:	db 01       	movw	r26, r22
    4e40:	5a 96       	adiw	r26, 0x1a	; 26
    4e42:	2d 91       	ld	r18, X+
    4e44:	3c 91       	ld	r19, X
    4e46:	5b 97       	sbiw	r26, 0x1b	; 27
    4e48:	ad b7       	in	r26, 0x3d	; 61
    4e4a:	be b7       	in	r27, 0x3e	; 62
    4e4c:	11 96       	adiw	r26, 0x01	; 1
    4e4e:	2d 93       	st	X+, r18
    4e50:	3c 93       	st	X, r19
    4e52:	12 97       	sbiw	r26, 0x02	; 2
    4e54:	25 ee       	ldi	r18, 0xE5	; 229
    4e56:	34 e2       	ldi	r19, 0x24	; 36
    4e58:	22 83       	std	Z+2, r18	; 0x02
    4e5a:	33 83       	std	Z+3, r19	; 0x03
    4e5c:	84 83       	std	Z+4, r24	; 0x04
    4e5e:	15 82       	std	Z+5, r1	; 0x05
    4e60:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    4e64:	8d b7       	in	r24, 0x3d	; 61
    4e66:	9e b7       	in	r25, 0x3e	; 62
    4e68:	06 96       	adiw	r24, 0x06	; 6
    4e6a:	8d bf       	out	0x3d, r24	; 61
    4e6c:	9e bf       	out	0x3e, r25	; 62
}
    4e6e:	08 95       	ret

00004e70 <vt100SetCursorMode>:

void vt100SetCursorMode(uint8_t visible, cmdState_t *state)
{
    4e70:	fb 01       	movw	r30, r22
    4e72:	22 8d       	ldd	r18, Z+26	; 0x1a
    4e74:	33 8d       	ldd	r19, Z+27	; 0x1b
  if(visible)
    4e76:	88 23       	and	r24, r24
    4e78:	49 f0       	breq	.+18     	; 0x4e8c <vt100SetCursorMode+0x1c>
  // ESC [ ? 25 h
    fprintf_P(state->myStdInOut, "\x1B[?25h");
    4e7a:	00 d0       	rcall	.+0      	; 0x4e7c <vt100SetCursorMode+0xc>
    4e7c:	0f 92       	push	r0
    4e7e:	ed b7       	in	r30, 0x3d	; 61
    4e80:	fe b7       	in	r31, 0x3e	; 62
    4e82:	21 83       	std	Z+1, r18	; 0x01
    4e84:	32 83       	std	Z+2, r19	; 0x02
    4e86:	8b ee       	ldi	r24, 0xEB	; 235
    4e88:	94 e2       	ldi	r25, 0x24	; 36
    4e8a:	08 c0       	rjmp	.+16     	; 0x4e9c <vt100SetCursorMode+0x2c>
  else
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
    4e8c:	00 d0       	rcall	.+0      	; 0x4e8e <vt100SetCursorMode+0x1e>
    4e8e:	0f 92       	push	r0
    4e90:	ed b7       	in	r30, 0x3d	; 61
    4e92:	fe b7       	in	r31, 0x3e	; 62
    4e94:	21 83       	std	Z+1, r18	; 0x01
    4e96:	32 83       	std	Z+2, r19	; 0x02
    4e98:	82 ef       	ldi	r24, 0xF2	; 242
    4e9a:	94 e2       	ldi	r25, 0x24	; 36
    4e9c:	83 83       	std	Z+3, r24	; 0x03
    4e9e:	94 83       	std	Z+4, r25	; 0x04
    4ea0:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    4ea4:	0f 90       	pop	r0
    4ea6:	0f 90       	pop	r0
    4ea8:	0f 90       	pop	r0
    4eaa:	0f 90       	pop	r0
    4eac:	08 95       	ret

00004eae <vt100SetCursorPos>:
}

void vt100SetCursorPos(uint8_t line, uint8_t col, cmdState_t *state)
{
  // ESC [ Pl ; Pc H
  fprintf_P(state->myStdInOut, "\x1B[%d;%dH",line,col);
    4eae:	2d b7       	in	r18, 0x3d	; 61
    4eb0:	3e b7       	in	r19, 0x3e	; 62
    4eb2:	28 50       	subi	r18, 0x08	; 8
    4eb4:	30 40       	sbci	r19, 0x00	; 0
    4eb6:	2d bf       	out	0x3d, r18	; 61
    4eb8:	3e bf       	out	0x3e, r19	; 62
    4eba:	ed b7       	in	r30, 0x3d	; 61
    4ebc:	fe b7       	in	r31, 0x3e	; 62
    4ebe:	31 96       	adiw	r30, 0x01	; 1
    4ec0:	da 01       	movw	r26, r20
    4ec2:	5a 96       	adiw	r26, 0x1a	; 26
    4ec4:	2d 91       	ld	r18, X+
    4ec6:	3c 91       	ld	r19, X
    4ec8:	5b 97       	sbiw	r26, 0x1b	; 27
    4eca:	ad b7       	in	r26, 0x3d	; 61
    4ecc:	be b7       	in	r27, 0x3e	; 62
    4ece:	11 96       	adiw	r26, 0x01	; 1
    4ed0:	2d 93       	st	X+, r18
    4ed2:	3c 93       	st	X, r19
    4ed4:	12 97       	sbiw	r26, 0x02	; 2
    4ed6:	29 ef       	ldi	r18, 0xF9	; 249
    4ed8:	34 e2       	ldi	r19, 0x24	; 36
    4eda:	22 83       	std	Z+2, r18	; 0x02
    4edc:	33 83       	std	Z+3, r19	; 0x03
    4ede:	84 83       	std	Z+4, r24	; 0x04
    4ee0:	15 82       	std	Z+5, r1	; 0x05
    4ee2:	66 83       	std	Z+6, r22	; 0x06
    4ee4:	17 82       	std	Z+7, r1	; 0x07
    4ee6:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    4eea:	2d b7       	in	r18, 0x3d	; 61
    4eec:	3e b7       	in	r19, 0x3e	; 62
    4eee:	28 5f       	subi	r18, 0xF8	; 248
    4ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ef2:	2d bf       	out	0x3d, r18	; 61
    4ef4:	3e bf       	out	0x3e, r19	; 62
}
    4ef6:	08 95       	ret
    4ef8:	08 95       	ret
    4efa:	08 95       	ret

00004efc <readTimeBCD>:
void spiEnableDS1305(void)  {};
void spiDisableDS1305(void) {};


void readTimeBCD(timeBCD_t *time)
{
    4efc:	ef 92       	push	r14
    4efe:	ff 92       	push	r15
    4f00:	1f 93       	push	r17
    4f02:	df 93       	push	r29
    4f04:	cf 93       	push	r28
    4f06:	0f 92       	push	r0
    4f08:	0f 92       	push	r0
    4f0a:	cd b7       	in	r28, 0x3d	; 61
    4f0c:	de b7       	in	r29, 0x3e	; 62
  spiTake();
    4f0e:	89 83       	std	Y+1, r24	; 0x01
    4f10:	9a 83       	std	Y+2, r25	; 0x02
    4f12:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  spiEnableDS1305();
    4f16:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    4f1a:	89 81       	ldd	r24, Y+1	; 0x01
    4f1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f1e:	48 2f       	mov	r20, r24
    4f20:	59 2f       	mov	r21, r25
    4f22:	7a 01       	movw	r14, r20
  uint8_t i;
  
  spiSend(0x00);
    4f24:	80 e0       	ldi	r24, 0x00	; 0
    4f26:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>

  for (i=0; i<sizeof(timeBCD_t); i++)
    4f2a:	10 e0       	ldi	r17, 0x00	; 0
  {
    *ptr = spiSend(i);
    4f2c:	81 2f       	mov	r24, r17
    4f2e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    4f32:	f7 01       	movw	r30, r14
    4f34:	81 93       	st	Z+, r24
    4f36:	7f 01       	movw	r14, r30
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);

  for (i=0; i<sizeof(timeBCD_t); i++)
    4f38:	1f 5f       	subi	r17, 0xFF	; 255
    4f3a:	17 30       	cpi	r17, 0x07	; 7
    4f3c:	b9 f7       	brne	.-18     	; 0x4f2c <readTimeBCD+0x30>
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
    4f3e:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <spiDisableDS1305>
  spiGive();
    4f42:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    4f46:	0f 90       	pop	r0
    4f48:	0f 90       	pop	r0
    4f4a:	cf 91       	pop	r28
    4f4c:	df 91       	pop	r29
    4f4e:	1f 91       	pop	r17
    4f50:	ff 90       	pop	r15
    4f52:	ef 90       	pop	r14
    4f54:	08 95       	ret

00004f56 <readTimeDecoded>:

#if USE_DECODED_TIME_STRUCT
void readTimeDecoded(timeDecoded_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4f56:	0e 94 7e 27 	call	0x4efc	; 0x4efc <readTimeBCD>
}
    4f5a:	08 95       	ret

00004f5c <readTime>:
void readTime (time_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4f5c:	0e 94 7e 27 	call	0x4efc	; 0x4efc <readTimeBCD>
}
    4f60:	08 95       	ret

00004f62 <setTimeBCD>:
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
{
    4f62:	ef 92       	push	r14
    4f64:	ff 92       	push	r15
    4f66:	0f 93       	push	r16
    4f68:	1f 93       	push	r17
    4f6a:	df 93       	push	r29
    4f6c:	cf 93       	push	r28
    4f6e:	0f 92       	push	r0
    4f70:	0f 92       	push	r0
    4f72:	cd b7       	in	r28, 0x3d	; 61
    4f74:	de b7       	in	r29, 0x3e	; 62
  spiTake();
    4f76:	89 83       	std	Y+1, r24	; 0x01
    4f78:	9a 83       	std	Y+2, r25	; 0x02
    4f7a:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  spiEnableDS1305();
    4f7e:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    4f82:	89 81       	ldd	r24, Y+1	; 0x01
    4f84:	48 2f       	mov	r20, r24
    4f86:	9a 81       	ldd	r25, Y+2	; 0x02
    4f88:	59 2f       	mov	r21, r25
    4f8a:	7a 01       	movw	r14, r20
  uint8_t i;
  spiSend(0x80);
    4f8c:	80 e8       	ldi	r24, 0x80	; 128
    4f8e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  readTimeBCD((timeBCD_t *)(time));
}
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
    4f92:	87 01       	movw	r16, r14
    4f94:	09 5f       	subi	r16, 0xF9	; 249
    4f96:	1f 4f       	sbci	r17, 0xFF	; 255
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    spiSend(*ptr);
    4f98:	f7 01       	movw	r30, r14
    4f9a:	81 91       	ld	r24, Z+
    4f9c:	7f 01       	movw	r14, r30
    4f9e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiEnableDS1305();
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
    4fa2:	e0 16       	cp	r14, r16
    4fa4:	f1 06       	cpc	r15, r17
    4fa6:	c1 f7       	brne	.-16     	; 0x4f98 <setTimeBCD+0x36>
  {
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
    4fa8:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <spiDisableDS1305>
  spiGive();
    4fac:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    4fb0:	0f 90       	pop	r0
    4fb2:	0f 90       	pop	r0
    4fb4:	cf 91       	pop	r28
    4fb6:	df 91       	pop	r29
    4fb8:	1f 91       	pop	r17
    4fba:	0f 91       	pop	r16
    4fbc:	ff 90       	pop	r15
    4fbe:	ef 90       	pop	r14
    4fc0:	08 95       	ret

00004fc2 <setTimeDecoded>:

#if USE_DECODED_TIME_STRUCT
void setTimeDecoded(timeDecoded_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    4fc2:	0e 94 b1 27 	call	0x4f62	; 0x4f62 <setTimeBCD>
}
    4fc6:	08 95       	ret

00004fc8 <setTime>:
void setTime(time_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    4fc8:	0e 94 b1 27 	call	0x4f62	; 0x4f62 <setTimeBCD>
}
    4fcc:	08 95       	ret

00004fce <ds1305start>:
#endif /* USE_DECODED_TIME_STRUCT */

void ds1305start(void)
{  
  spiTake();
    4fce:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  spiEnableDS1305();
    4fd2:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <spiEnableDS1305>

  spiSend(0x8F);
    4fd6:	8f e8       	ldi	r24, 0x8F	; 143
    4fd8:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(0x00);
    4fdc:	80 e0       	ldi	r24, 0x00	; 0
    4fde:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  
  spiDisableDS1305();  
    4fe2:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <spiDisableDS1305>
  spiGive();
    4fe6:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>

  return;
}
    4fea:	08 95       	ret

00004fec <ds1305writeMem>:


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
    4fec:	ef 92       	push	r14
    4fee:	ff 92       	push	r15
    4ff0:	1f 93       	push	r17
    4ff2:	df 93       	push	r29
    4ff4:	cf 93       	push	r28
    4ff6:	0f 92       	push	r0
    4ff8:	cd b7       	in	r28, 0x3d	; 61
    4ffa:	de b7       	in	r29, 0x3e	; 62
    4ffc:	16 2f       	mov	r17, r22
    4ffe:	7a 01       	movw	r14, r20
  if (addr > 95)
    5000:	80 36       	cpi	r24, 0x60	; 96
    5002:	f8 f4       	brcc	.+62     	; 0x5042 <ds1305writeMem+0x56>
    return 1;
  if (addr + length > 95)
    5004:	28 2f       	mov	r18, r24
    5006:	30 e0       	ldi	r19, 0x00	; 0
    5008:	26 0f       	add	r18, r22
    500a:	31 1d       	adc	r19, r1
    500c:	20 36       	cpi	r18, 0x60	; 96
    500e:	31 05       	cpc	r19, r1
    5010:	d4 f4       	brge	.+52     	; 0x5046 <ds1305writeMem+0x5a>
    return 2;

  addr += 0xA0;
  
  spiTake();
    5012:	89 83       	std	Y+1, r24	; 0x01
    5014:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  spiEnableDS1305();
    5018:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <spiEnableDS1305>

  spiSend(addr);
    501c:	89 81       	ldd	r24, Y+1	; 0x01
    501e:	80 56       	subi	r24, 0x60	; 96
    5020:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  while (length > 0)
    5024:	06 c0       	rjmp	.+12     	; 0x5032 <ds1305writeMem+0x46>
  {
    spiSend(*data);
    5026:	f7 01       	movw	r30, r14
    5028:	81 91       	ld	r24, Z+
    502a:	7f 01       	movw	r14, r30
    502c:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    data++;
    length--;
    5030:	11 50       	subi	r17, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    5032:	11 23       	and	r17, r17
    5034:	c1 f7       	brne	.-16     	; 0x5026 <ds1305writeMem+0x3a>
    spiSend(*data);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    5036:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <spiDisableDS1305>
  spiGive();
    503a:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
  return 0;
    503e:	80 e0       	ldi	r24, 0x00	; 0
    5040:	03 c0       	rjmp	.+6      	; 0x5048 <ds1305writeMem+0x5c>


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr > 95)
    return 1;
    5042:	81 e0       	ldi	r24, 0x01	; 1
    5044:	01 c0       	rjmp	.+2      	; 0x5048 <ds1305writeMem+0x5c>
  if (addr + length > 95)
    return 2;
    5046:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    5048:	0f 90       	pop	r0
    504a:	cf 91       	pop	r28
    504c:	df 91       	pop	r29
    504e:	1f 91       	pop	r17
    5050:	ff 90       	pop	r15
    5052:	ef 90       	pop	r14
    5054:	08 95       	ret

00005056 <ds1305readMem>:
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
    5056:	ef 92       	push	r14
    5058:	ff 92       	push	r15
    505a:	1f 93       	push	r17
    505c:	df 93       	push	r29
    505e:	cf 93       	push	r28
    5060:	0f 92       	push	r0
    5062:	cd b7       	in	r28, 0x3d	; 61
    5064:	de b7       	in	r29, 0x3e	; 62
    5066:	16 2f       	mov	r17, r22
    5068:	7a 01       	movw	r14, r20
  if (addr >95)
    506a:	80 36       	cpi	r24, 0x60	; 96
    506c:	00 f5       	brcc	.+64     	; 0x50ae <ds1305readMem+0x58>
    return 1;
  if (addr + length > 95)
    506e:	28 2f       	mov	r18, r24
    5070:	30 e0       	ldi	r19, 0x00	; 0
    5072:	26 0f       	add	r18, r22
    5074:	31 1d       	adc	r19, r1
    5076:	20 36       	cpi	r18, 0x60	; 96
    5078:	31 05       	cpc	r19, r1
    507a:	dc f4       	brge	.+54     	; 0x50b2 <ds1305readMem+0x5c>
    return 2;
  
  addr += 0x20;
  
  spiTake();
    507c:	89 83       	std	Y+1, r24	; 0x01
    507e:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  spiEnableDS1305();
    5082:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <spiEnableDS1305>

  spiSend(addr);
    5086:	89 81       	ldd	r24, Y+1	; 0x01
    5088:	80 5e       	subi	r24, 0xE0	; 224
    508a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  while (length > 0)
    508e:	07 c0       	rjmp	.+14     	; 0x509e <ds1305readMem+0x48>
  {
    *data = spiSend(0);
    5090:	80 e0       	ldi	r24, 0x00	; 0
    5092:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    5096:	f7 01       	movw	r30, r14
    5098:	81 93       	st	Z+, r24
    509a:	7f 01       	movw	r14, r30
    data++;
    length--;
    509c:	11 50       	subi	r17, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    509e:	11 23       	and	r17, r17
    50a0:	b9 f7       	brne	.-18     	; 0x5090 <ds1305readMem+0x3a>
    *data = spiSend(0);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    50a2:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <spiDisableDS1305>
  spiGive();
    50a6:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
  return 0;
    50aa:	80 e0       	ldi	r24, 0x00	; 0
    50ac:	03 c0       	rjmp	.+6      	; 0x50b4 <ds1305readMem+0x5e>
  return 0;
}
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr >95)
    return 1;
    50ae:	81 e0       	ldi	r24, 0x01	; 1
    50b0:	01 c0       	rjmp	.+2      	; 0x50b4 <ds1305readMem+0x5e>
  if (addr + length > 95)
    return 2;
    50b2:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    50b4:	0f 90       	pop	r0
    50b6:	cf 91       	pop	r28
    50b8:	df 91       	pop	r29
    50ba:	1f 91       	pop	r17
    50bc:	ff 90       	pop	r15
    50be:	ef 90       	pop	r14
    50c0:	08 95       	ret
    50c2:	08 95       	ret
    50c4:	08 95       	ret

000050c6 <MPC23s17SetDirA>:
void enableSpiMPC23S17(void)  {}
void disableSpiMPC23S17(void) {}


void MPC23s17SetDirA(uint8_t portAdir, uint8_t addr)
{
    50c6:	1f 93       	push	r17
    50c8:	df 93       	push	r29
    50ca:	cf 93       	push	r28
    50cc:	0f 92       	push	r0
    50ce:	cd b7       	in	r28, 0x3d	; 61
    50d0:	de b7       	in	r29, 0x3e	; 62
    50d2:	18 2f       	mov	r17, r24
  addr = addr<<1;
    50d4:	66 0f       	add	r22, r22
  addr &= 0x0E;
    50d6:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    50d8:	69 83       	std	Y+1, r22	; 0x01
    50da:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17(); 
    50de:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  spiSend(addr);
    50e2:	69 81       	ldd	r22, Y+1	; 0x01
    50e4:	86 2f       	mov	r24, r22
    50e6:	80 64       	ori	r24, 0x40	; 64
    50e8:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_IODIRA);
    50ec:	80 e0       	ldi	r24, 0x00	; 0
    50ee:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portAdir);  
    50f2:	81 2f       	mov	r24, r17
    50f4:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  
  disableSpiMPC23S17();
    50f8:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    50fc:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    5100:	0f 90       	pop	r0
    5102:	cf 91       	pop	r28
    5104:	df 91       	pop	r29
    5106:	1f 91       	pop	r17
    5108:	08 95       	ret

0000510a <MPC23s17SetDirB>:

void MPC23s17SetDirB(uint8_t portBdir, uint8_t addr)
{
    510a:	1f 93       	push	r17
    510c:	df 93       	push	r29
    510e:	cf 93       	push	r28
    5110:	0f 92       	push	r0
    5112:	cd b7       	in	r28, 0x3d	; 61
    5114:	de b7       	in	r29, 0x3e	; 62
    5116:	18 2f       	mov	r17, r24
  addr = addr<<1;
    5118:	66 0f       	add	r22, r22
  addr &= 0x0E;
    511a:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    511c:	69 83       	std	Y+1, r22	; 0x01
    511e:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    5122:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  
  spiSend(addr);
    5126:	69 81       	ldd	r22, Y+1	; 0x01
    5128:	86 2f       	mov	r24, r22
    512a:	80 64       	ori	r24, 0x40	; 64
    512c:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_IODIRB);
    5130:	81 e0       	ldi	r24, 0x01	; 1
    5132:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portBdir);  
    5136:	81 2f       	mov	r24, r17
    5138:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  
  disableSpiMPC23S17();
    513c:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    5140:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    5144:	0f 90       	pop	r0
    5146:	cf 91       	pop	r28
    5148:	df 91       	pop	r29
    514a:	1f 91       	pop	r17
    514c:	08 95       	ret

0000514e <MPC23s17SetPortA>:

void MPC23s17SetPortA(uint8_t portAout, uint8_t addr)
{
    514e:	1f 93       	push	r17
    5150:	df 93       	push	r29
    5152:	cf 93       	push	r28
    5154:	0f 92       	push	r0
    5156:	cd b7       	in	r28, 0x3d	; 61
    5158:	de b7       	in	r29, 0x3e	; 62
    515a:	18 2f       	mov	r17, r24
  addr = addr<<1;
    515c:	66 0f       	add	r22, r22
  addr &= 0x0E;
    515e:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    5160:	69 83       	std	Y+1, r22	; 0x01
    5162:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    5166:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  portA = portAout;  
    516a:	10 93 24 32 	sts	0x3224, r17
  spiSend(addr);
    516e:	69 81       	ldd	r22, Y+1	; 0x01
    5170:	86 2f       	mov	r24, r22
    5172:	80 64       	ori	r24, 0x40	; 64
    5174:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_OLATA);
    5178:	84 e1       	ldi	r24, 0x14	; 20
    517a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portA);  
    517e:	80 91 24 32 	lds	r24, 0x3224
    5182:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>

  disableSpiMPC23S17();
    5186:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    518a:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    518e:	0f 90       	pop	r0
    5190:	cf 91       	pop	r28
    5192:	df 91       	pop	r29
    5194:	1f 91       	pop	r17
    5196:	08 95       	ret

00005198 <MPC23s17SetBitsOnPortA>:

void MPC23s17SetBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    5198:	df 93       	push	r29
    519a:	cf 93       	push	r28
    519c:	0f 92       	push	r0
    519e:	cd b7       	in	r28, 0x3d	; 61
    51a0:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    51a2:	66 0f       	add	r22, r22
  addr &= 0x0E;
    51a4:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA |= portAout;  
    51a6:	90 91 24 32 	lds	r25, 0x3224
    51aa:	98 2b       	or	r25, r24
    51ac:	90 93 24 32 	sts	0x3224, r25

  spiTake();
    51b0:	69 83       	std	Y+1, r22	; 0x01
    51b2:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    51b6:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  spiSend(addr);
    51ba:	69 81       	ldd	r22, Y+1	; 0x01
    51bc:	86 2f       	mov	r24, r22
    51be:	80 64       	ori	r24, 0x40	; 64
    51c0:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_OLATA);
    51c4:	84 e1       	ldi	r24, 0x14	; 20
    51c6:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portA);  
    51ca:	80 91 24 32 	lds	r24, 0x3224
    51ce:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  disableSpiMPC23S17();
    51d2:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    51d6:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    51da:	0f 90       	pop	r0
    51dc:	cf 91       	pop	r28
    51de:	df 91       	pop	r29
    51e0:	08 95       	ret

000051e2 <MPC23s17ClearBitsOnPortA>:

void MPC23s17ClearBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    51e2:	df 93       	push	r29
    51e4:	cf 93       	push	r28
    51e6:	0f 92       	push	r0
    51e8:	cd b7       	in	r28, 0x3d	; 61
    51ea:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    51ec:	66 0f       	add	r22, r22
  addr &= 0x0E;
    51ee:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA &= (~portAout);
    51f0:	90 91 24 32 	lds	r25, 0x3224
    51f4:	80 95       	com	r24
    51f6:	89 23       	and	r24, r25
    51f8:	80 93 24 32 	sts	0x3224, r24

  spiTake();
    51fc:	69 83       	std	Y+1, r22	; 0x01
    51fe:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    5202:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  spiSend(addr);
    5206:	69 81       	ldd	r22, Y+1	; 0x01
    5208:	86 2f       	mov	r24, r22
    520a:	80 64       	ori	r24, 0x40	; 64
    520c:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_OLATA);
    5210:	84 e1       	ldi	r24, 0x14	; 20
    5212:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portA);  
    5216:	80 91 24 32 	lds	r24, 0x3224
    521a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  disableSpiMPC23S17();
    521e:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    5222:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    5226:	0f 90       	pop	r0
    5228:	cf 91       	pop	r28
    522a:	df 91       	pop	r29
    522c:	08 95       	ret

0000522e <MPC23s17SetPortB>:

void MPC23s17SetPortB(uint8_t portBout, uint8_t addr)
{
    522e:	df 93       	push	r29
    5230:	cf 93       	push	r28
    5232:	0f 92       	push	r0
    5234:	cd b7       	in	r28, 0x3d	; 61
    5236:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5238:	66 0f       	add	r22, r22
  addr &= 0x0E;
    523a:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB = portBout;
    523c:	80 93 d7 31 	sts	0x31D7, r24

  spiTake();
    5240:	69 83       	std	Y+1, r22	; 0x01
    5242:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    5246:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  spiSend(addr);
    524a:	69 81       	ldd	r22, Y+1	; 0x01
    524c:	86 2f       	mov	r24, r22
    524e:	80 64       	ori	r24, 0x40	; 64
    5250:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_OLATB);
    5254:	85 e1       	ldi	r24, 0x15	; 21
    5256:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portB);  
    525a:	80 91 d7 31 	lds	r24, 0x31D7
    525e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  disableSpiMPC23S17();
    5262:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    5266:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    526a:	0f 90       	pop	r0
    526c:	cf 91       	pop	r28
    526e:	df 91       	pop	r29
    5270:	08 95       	ret

00005272 <MPC23s17SetBitsOnPortB>:

void MPC23s17SetBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5272:	df 93       	push	r29
    5274:	cf 93       	push	r28
    5276:	0f 92       	push	r0
    5278:	cd b7       	in	r28, 0x3d	; 61
    527a:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    527c:	66 0f       	add	r22, r22
  addr &= 0x0E;
    527e:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB |= portBout;
    5280:	90 91 d7 31 	lds	r25, 0x31D7
    5284:	98 2b       	or	r25, r24
    5286:	90 93 d7 31 	sts	0x31D7, r25

  spiTake();
    528a:	69 83       	std	Y+1, r22	; 0x01
    528c:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    5290:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  spiSend(addr);
    5294:	69 81       	ldd	r22, Y+1	; 0x01
    5296:	86 2f       	mov	r24, r22
    5298:	80 64       	ori	r24, 0x40	; 64
    529a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_OLATB);
    529e:	85 e1       	ldi	r24, 0x15	; 21
    52a0:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portB);  
    52a4:	80 91 d7 31 	lds	r24, 0x31D7
    52a8:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  disableSpiMPC23S17();
    52ac:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    52b0:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    52b4:	0f 90       	pop	r0
    52b6:	cf 91       	pop	r28
    52b8:	df 91       	pop	r29
    52ba:	08 95       	ret

000052bc <MPC23s17ClearBitsOnPortB>:

void MPC23s17ClearBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    52bc:	df 93       	push	r29
    52be:	cf 93       	push	r28
    52c0:	0f 92       	push	r0
    52c2:	cd b7       	in	r28, 0x3d	; 61
    52c4:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    52c6:	66 0f       	add	r22, r22
  addr &= 0x0E;
    52c8:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB &= (~portBout);
    52ca:	90 91 d7 31 	lds	r25, 0x31D7
    52ce:	80 95       	com	r24
    52d0:	89 23       	and	r24, r25
    52d2:	80 93 d7 31 	sts	0x31D7, r24

  spiTake();
    52d6:	69 83       	std	Y+1, r22	; 0x01
    52d8:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    52dc:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>
  spiSend(addr);
    52e0:	69 81       	ldd	r22, Y+1	; 0x01
    52e2:	86 2f       	mov	r24, r22
    52e4:	80 64       	ori	r24, 0x40	; 64
    52e6:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_OLATB);
    52ea:	85 e1       	ldi	r24, 0x15	; 21
    52ec:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(portB);  
    52f0:	80 91 d7 31 	lds	r24, 0x31D7
    52f4:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>

  disableSpiMPC23S17();
    52f8:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    52fc:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    5300:	0f 90       	pop	r0
    5302:	cf 91       	pop	r28
    5304:	df 91       	pop	r29
    5306:	08 95       	ret

00005308 <MPC23s17ReadPortA>:

uint8_t MPC23s17ReadPortA(uint8_t addr)
{
    5308:	1f 93       	push	r17
    530a:	df 93       	push	r29
    530c:	cf 93       	push	r28
    530e:	0f 92       	push	r0
    5310:	cd b7       	in	r28, 0x3d	; 61
    5312:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5314:	18 2f       	mov	r17, r24
    5316:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5318:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    531a:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    531c:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    5320:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>

  spiSend(addr);
    5324:	81 2f       	mov	r24, r17
    5326:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_GPIOA);
    532a:	82 e1       	ldi	r24, 0x12	; 18
    532c:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  uint8_t result = spiSend(addr);  
    5330:	81 2f       	mov	r24, r17
    5332:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>

  disableSpiMPC23S17();
    5336:	89 83       	std	Y+1, r24	; 0x01
    5338:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    533c:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>

  return result; 
}
    5340:	89 81       	ldd	r24, Y+1	; 0x01
    5342:	0f 90       	pop	r0
    5344:	cf 91       	pop	r28
    5346:	df 91       	pop	r29
    5348:	1f 91       	pop	r17
    534a:	08 95       	ret

0000534c <MPC23s17ReadPortB>:

uint8_t MPC23s17ReadPortB(uint8_t addr)
{
    534c:	1f 93       	push	r17
    534e:	df 93       	push	r29
    5350:	cf 93       	push	r28
    5352:	0f 92       	push	r0
    5354:	cd b7       	in	r28, 0x3d	; 61
    5356:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5358:	18 2f       	mov	r17, r24
    535a:	11 0f       	add	r17, r17
  addr &= 0x0E;
    535c:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    535e:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    5360:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMPC23S17();
    5364:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <enableSpiMPC23S17>

  spiSend(addr);
    5368:	81 2f       	mov	r24, r17
    536a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(B0_GPIOB);
    536e:	83 e1       	ldi	r24, 0x13	; 19
    5370:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  uint8_t result = spiSend(addr);  
    5374:	81 2f       	mov	r24, r17
    5376:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>

  disableSpiMPC23S17();
    537a:	89 83       	std	Y+1, r24	; 0x01
    537c:	0e 94 67 0d 	call	0x1ace	; 0x1ace <disableSpiMPC23S17>
  spiGive();
    5380:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>

  return result; 
}
    5384:	89 81       	ldd	r24, Y+1	; 0x01
    5386:	0f 90       	pop	r0
    5388:	cf 91       	pop	r28
    538a:	df 91       	pop	r29
    538c:	1f 91       	pop	r17
    538e:	08 95       	ret
    5390:	08 95       	ret
    5392:	08 95       	ret

00005394 <MCP3008_getSampleDiff>:
void enableSpiMCP3008(void)   {};
void disableSpiMCP3008(void)  {};


uint16_t MCP3008_getSampleDiff(uint8_t inputNo)
{
    5394:	1f 93       	push	r17
    5396:	df 93       	push	r29
    5398:	cf 93       	push	r28
    539a:	0f 92       	push	r0
    539c:	cd b7       	in	r28, 0x3d	; 61
    539e:	de b7       	in	r29, 0x3e	; 62
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    53a0:	18 2f       	mov	r17, r24
    53a2:	12 95       	swap	r17
    53a4:	10 7f       	andi	r17, 0xF0	; 240
  inputNo &= 0x70;
  
  spiTake();
    53a6:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMCP3008();
    53aa:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <enableSpiMCP3008>
  
  spiSend(0x01);                               //Start
    53ae:	81 e0       	ldi	r24, 0x01	; 1
    53b0:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    53b4:	81 2f       	mov	r24, r17
    53b6:	80 77       	andi	r24, 0x70	; 112
    53b8:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    53bc:	18 2f       	mov	r17, r24
  resultLo = spiSend(0);        //X X X X X X X X
    53be:	80 e0       	ldi	r24, 0x00	; 0
    53c0:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  
  disableSpiMCP3008(); 
    53c4:	89 83       	std	Y+1, r24	; 0x01
    53c6:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <disableSpiMCP3008>
  spiGive();
    53ca:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
    53ce:	51 2f       	mov	r21, r17
    53d0:	53 70       	andi	r21, 0x03	; 3
    53d2:	40 e0       	ldi	r20, 0x00	; 0
    53d4:	89 81       	ldd	r24, Y+1	; 0x01
    53d6:	28 2f       	mov	r18, r24
    53d8:	30 e0       	ldi	r19, 0x00	; 0
    53da:	24 2b       	or	r18, r20
    53dc:	35 2b       	or	r19, r21
}
    53de:	c9 01       	movw	r24, r18
    53e0:	0f 90       	pop	r0
    53e2:	cf 91       	pop	r28
    53e4:	df 91       	pop	r29
    53e6:	1f 91       	pop	r17
    53e8:	08 95       	ret

000053ea <MCP3008_getSampleSingle>:

uint16_t MCP3008_getSampleSingle(uint8_t inputNo)
{
    53ea:	1f 93       	push	r17
    53ec:	df 93       	push	r29
    53ee:	cf 93       	push	r28
    53f0:	0f 92       	push	r0
    53f2:	cd b7       	in	r28, 0x3d	; 61
    53f4:	de b7       	in	r29, 0x3e	; 62
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    53f6:	18 2f       	mov	r17, r24
    53f8:	12 95       	swap	r17
  inputNo &= 0x70;
    53fa:	10 77       	andi	r17, 0x70	; 112
  inputNo |= 0x80;
  
  spiTake();
    53fc:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMCP3008();
    5400:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <enableSpiMCP3008>
  
  spiSend(0x01);                //Start
    5404:	81 e0       	ldi	r24, 0x01	; 1
    5406:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    540a:	81 2f       	mov	r24, r17
    540c:	80 68       	ori	r24, 0x80	; 128
    540e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    5412:	18 2f       	mov	r17, r24
  resultLo = spiSend(0);        //X X X X X X X X
    5414:	80 e0       	ldi	r24, 0x00	; 0
    5416:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  
  disableSpiMCP3008(); 
    541a:	89 83       	std	Y+1, r24	; 0x01
    541c:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <disableSpiMCP3008>
  spiGive();
    5420:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
    5424:	51 2f       	mov	r21, r17
    5426:	53 70       	andi	r21, 0x03	; 3
    5428:	40 e0       	ldi	r20, 0x00	; 0
    542a:	89 81       	ldd	r24, Y+1	; 0x01
    542c:	28 2f       	mov	r18, r24
    542e:	30 e0       	ldi	r19, 0x00	; 0
    5430:	24 2b       	or	r18, r20
    5432:	35 2b       	or	r19, r21
}
    5434:	c9 01       	movw	r24, r18
    5436:	0f 90       	pop	r0
    5438:	cf 91       	pop	r28
    543a:	df 91       	pop	r29
    543c:	1f 91       	pop	r17
    543e:	08 95       	ret
    5440:	08 95       	ret
    5442:	08 95       	ret

00005444 <MCP4150_setValue>:
/**
 * Ustawia wartość rezystancji
 * @param inputNo - WARTOŚĆ OD 0 DO 255.
 */
void MCP4150_setValue(uint8_t value)
{  
    5444:	1f 93       	push	r17
    5446:	18 2f       	mov	r17, r24
  spiTake();
    5448:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  enableSpiMCP4150();
    544c:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <enableSpiMCP4150>
  
  spiSend(0x11);  
    5450:	81 e1       	ldi	r24, 0x11	; 17
    5452:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(value);
    5456:	81 2f       	mov	r24, r17
    5458:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  
  disableSpiMCP4150(); 
    545c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <disableSpiMCP4150>
  spiGive();
    5460:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    5464:	1f 91       	pop	r17
    5466:	08 95       	ret
    5468:	08 95       	ret
    546a:	08 95       	ret

0000546c <enc28j60WriteOp>:
  spiGive();
  return result; 
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
    546c:	1f 93       	push	r17
    546e:	df 93       	push	r29
    5470:	cf 93       	push	r28
    5472:	0f 92       	push	r0
    5474:	0f 92       	push	r0
    5476:	cd b7       	in	r28, 0x3d	; 61
    5478:	de b7       	in	r29, 0x3e	; 62
    547a:	18 2f       	mov	r17, r24
  spiTake();
    547c:	4a 83       	std	Y+2, r20	; 0x02
    547e:	69 83       	std	Y+1, r22	; 0x01
    5480:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  spiEnableEnc28j60();
    5484:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <spiEnableEnc28j60>
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSend(op | (address & ADDR_MASK));
    5488:	69 81       	ldd	r22, Y+1	; 0x01
    548a:	86 2f       	mov	r24, r22
    548c:	8f 71       	andi	r24, 0x1F	; 31
    548e:	81 2b       	or	r24, r17
    5490:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiSend(data);
    5494:	4a 81       	ldd	r20, Y+2	; 0x02
    5496:	84 2f       	mov	r24, r20
    5498:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  spiDisableEnc28j60();
    549c:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <spiDisableEnc28j60>
  spiGive();
    54a0:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
}
    54a4:	0f 90       	pop	r0
    54a6:	0f 90       	pop	r0
    54a8:	cf 91       	pop	r28
    54aa:	df 91       	pop	r29
    54ac:	1f 91       	pop	r17
    54ae:	08 95       	ret

000054b0 <enc28j60SetBank>:
//   spiGive();
// }


void enc28j60SetBank(uint8_t address)
{
    54b0:	1f 93       	push	r17
    54b2:	cf 93       	push	r28
    54b4:	df 93       	push	r29
    54b6:	18 2f       	mov	r17, r24
  // set the bank (if needed)
  if((address & BANK_MASK) != Enc28j60Bank)
    54b8:	c8 2f       	mov	r28, r24
    54ba:	d0 e0       	ldi	r29, 0x00	; 0
    54bc:	c0 76       	andi	r28, 0x60	; 96
    54be:	d0 70       	andi	r29, 0x00	; 0
    54c0:	20 91 52 25 	lds	r18, 0x2552
    54c4:	30 e0       	ldi	r19, 0x00	; 0
    54c6:	c2 17       	cp	r28, r18
    54c8:	d3 07       	cpc	r29, r19
    54ca:	91 f0       	breq	.+36     	; 0x54f0 <enc28j60SetBank+0x40>
  {
    // set the bank
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    54cc:	80 ea       	ldi	r24, 0xA0	; 160
    54ce:	6f e1       	ldi	r22, 0x1F	; 31
    54d0:	43 e0       	ldi	r20, 0x03	; 3
    54d2:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    54d6:	ae 01       	movw	r20, r28
    54d8:	85 e0       	ldi	r24, 0x05	; 5
    54da:	55 95       	asr	r21
    54dc:	47 95       	ror	r20
    54de:	8a 95       	dec	r24
    54e0:	e1 f7       	brne	.-8      	; 0x54da <enc28j60SetBank+0x2a>
    54e2:	80 e8       	ldi	r24, 0x80	; 128
    54e4:	6f e1       	ldi	r22, 0x1F	; 31
    54e6:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    Enc28j60Bank = (address & BANK_MASK);
    54ea:	10 76       	andi	r17, 0x60	; 96
    54ec:	10 93 52 25 	sts	0x2552, r17
  }
}
    54f0:	df 91       	pop	r29
    54f2:	cf 91       	pop	r28
    54f4:	1f 91       	pop	r17
    54f6:	08 95       	ret

000054f8 <enc28j60Write>:

  return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    54f8:	1f 93       	push	r17
    54fa:	df 93       	push	r29
    54fc:	cf 93       	push	r28
    54fe:	0f 92       	push	r0
    5500:	cd b7       	in	r28, 0x3d	; 61
    5502:	de b7       	in	r29, 0x3e	; 62
    5504:	18 2f       	mov	r17, r24
  // set the bank
  enc28j60SetBank(address);
    5506:	69 83       	std	Y+1, r22	; 0x01
    5508:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <enc28j60SetBank>
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    550c:	80 e4       	ldi	r24, 0x40	; 64
    550e:	61 2f       	mov	r22, r17
    5510:	49 81       	ldd	r20, Y+1	; 0x01
    5512:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
}
    5516:	0f 90       	pop	r0
    5518:	cf 91       	pop	r28
    551a:	df 91       	pop	r29
    551c:	1f 91       	pop	r17
    551e:	08 95       	ret

00005520 <enc28j60ReadOp>:
    enc28j60PhyWrite    (PHLCON, 0x476);
    vTaskDelay          (2);
}

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
    5520:	1f 93       	push	r17
    5522:	df 93       	push	r29
    5524:	cf 93       	push	r28
    5526:	0f 92       	push	r0
    5528:	cd b7       	in	r28, 0x3d	; 61
    552a:	de b7       	in	r29, 0x3e	; 62
    552c:	16 2f       	mov	r17, r22
  uint8_t result;
  spiTake();
    552e:	89 83       	std	Y+1, r24	; 0x01
    5530:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
  spiEnableEnc28j60();
    5534:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <spiEnableEnc28j60>
  
  // issue read command
  spiSend(op | (address & ADDR_MASK));
    5538:	91 2f       	mov	r25, r17
    553a:	9f 71       	andi	r25, 0x1F	; 31
    553c:	89 81       	ldd	r24, Y+1	; 0x01
    553e:	89 2b       	or	r24, r25
    5540:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>

  // read data
  result = spiSend(0x00);
    5544:	80 e0       	ldi	r24, 0x00	; 0
    5546:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>

  // do dummy read if needed (for mac and mii, see datasheet page 29)
  if(address & 0x80)
    554a:	17 ff       	sbrs	r17, 7
    554c:	03 c0       	rjmp	.+6      	; 0x5554 <enc28j60ReadOp+0x34>
  {
    result = spiSend(0x00);
    554e:	80 e0       	ldi	r24, 0x00	; 0
    5550:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
  }

  spiDisableEnc28j60();
    5554:	89 83       	std	Y+1, r24	; 0x01
    5556:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <spiDisableEnc28j60>
  spiGive();
    555a:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
  return result; 
}
    555e:	89 81       	ldd	r24, Y+1	; 0x01
    5560:	0f 90       	pop	r0
    5562:	cf 91       	pop	r28
    5564:	df 91       	pop	r29
    5566:	1f 91       	pop	r17
    5568:	08 95       	ret

0000556a <enc28j60Read>:
    Enc28j60Bank = (address & BANK_MASK);
  }
}

uint8_t enc28j60Read(uint8_t address)
{
    556a:	df 93       	push	r29
    556c:	cf 93       	push	r28
    556e:	0f 92       	push	r0
    5570:	cd b7       	in	r28, 0x3d	; 61
    5572:	de b7       	in	r29, 0x3e	; 62
    5574:	68 2f       	mov	r22, r24
  // set the bank
  enc28j60SetBank(address);
    5576:	69 83       	std	Y+1, r22	; 0x01
    5578:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <enc28j60SetBank>
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    557c:	80 e0       	ldi	r24, 0x00	; 0
    557e:	69 81       	ldd	r22, Y+1	; 0x01
    5580:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
  return result;
}
    5584:	0f 90       	pop	r0
    5586:	cf 91       	pop	r28
    5588:	df 91       	pop	r29
    558a:	08 95       	ret

0000558c <enc28j60hasRxPkt>:
}

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
  if( enc28j60Read(EPKTCNT) ==0 )
    558c:	89 e3       	ldi	r24, 0x39	; 57
    558e:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
  {
    return(0);
    5592:	91 e0       	ldi	r25, 0x01	; 1
    5594:	88 23       	and	r24, r24
    5596:	09 f4       	brne	.+2      	; 0x559a <enc28j60hasRxPkt+0xe>
    5598:	90 e0       	ldi	r25, 0x00	; 0
  }
  return(1);
}
    559a:	89 2f       	mov	r24, r25
    559c:	08 95       	ret

0000559e <enc28j60linkup>:

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
  // Set the right address and start the register read operation
  enc28j60Write(MIREGADR, address);
    559e:	84 ed       	ldi	r24, 0xD4	; 212
    55a0:	61 e1       	ldi	r22, 0x11	; 17
    55a2:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
  enc28j60Write(MICMD, MICMD_MIIRD);
    55a6:	82 ed       	ldi	r24, 0xD2	; 210
    55a8:	61 e0       	ldi	r22, 0x01	; 1
    55aa:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie
    55ae:	80 e0       	ldi	r24, 0x00	; 0
    55b0:	90 e0       	ldi	r25, 0x00	; 0
    55b2:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
  enc28j60Write(MICMD, MICMD_MIIRD);
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    55b6:	8a ee       	ldi	r24, 0xEA	; 234
    55b8:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    55bc:	80 fd       	sbrc	r24, 0
    55be:	f7 cf       	rjmp	.-18     	; 0x55ae <enc28j60linkup+0x10>
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie

  // reset reading bit
  enc28j60Write(MICMD, 0x00);
    55c0:	82 ed       	ldi	r24, 0xD2	; 210
    55c2:	60 e0       	ldi	r22, 0x00	; 0
    55c4:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>

  return (enc28j60Read(MIRDH));
    55c8:	89 ed       	ldi	r24, 0xD9	; 217
    55ca:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>

// link status
uint8_t enc28j60linkup(void)
{
  // bit 10 (= bit 3 in upper reg)
  return(enc28j60PhyReadH(PHSTAT2) && 4);
    55ce:	91 e0       	ldi	r25, 0x01	; 1
    55d0:	88 23       	and	r24, r24
    55d2:	09 f4       	brne	.+2      	; 0x55d6 <enc28j60linkup+0x38>
    55d4:	90 e0       	ldi	r25, 0x00	; 0
}
    55d6:	89 2f       	mov	r24, r25
    55d8:	08 95       	ret

000055da <enc28j60getrev>:
}

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
  return(enc28j60Read(EREVID));
    55da:	82 e7       	ldi	r24, 0x72	; 114
    55dc:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
}
    55e0:	08 95       	ret

000055e2 <enc28j60PhyWrite>:
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    55e2:	1f 93       	push	r17
    55e4:	df 93       	push	r29
    55e6:	cf 93       	push	r28
    55e8:	0f 92       	push	r0
    55ea:	cd b7       	in	r28, 0x3d	; 61
    55ec:	de b7       	in	r29, 0x3e	; 62
    55ee:	98 2f       	mov	r25, r24
    55f0:	16 2f       	mov	r17, r22
  // set the PHY register address
  enc28j60Write(MIREGADR, address);
    55f2:	84 ed       	ldi	r24, 0xD4	; 212
    55f4:	69 2f       	mov	r22, r25
    55f6:	79 83       	std	Y+1, r23	; 0x01
    55f8:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
  // write the PHY data
  enc28j60Write(MIWRL, data);
    55fc:	86 ed       	ldi	r24, 0xD6	; 214
    55fe:	61 2f       	mov	r22, r17
    5600:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
  enc28j60Write(MIWRH, data>>8);
    5604:	87 ed       	ldi	r24, 0xD7	; 215
    5606:	79 81       	ldd	r23, Y+1	; 0x01
    5608:	67 2f       	mov	r22, r23
    560a:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    560e:	04 c0       	rjmp	.+8      	; 0x5618 <enc28j60PhyWrite+0x36>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
    5610:	80 e0       	ldi	r24, 0x00	; 0
    5612:	90 e0       	ldi	r25, 0x00	; 0
    5614:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
  // write the PHY data
  enc28j60Write(MIWRL, data);
  enc28j60Write(MIWRH, data>>8);
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    5618:	8a ee       	ldi	r24, 0xEA	; 234
    561a:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    561e:	80 fd       	sbrc	r24, 0
    5620:	f7 cf       	rjmp	.-18     	; 0x5610 <enc28j60PhyWrite+0x2e>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
  }
}
    5622:	0f 90       	pop	r0
    5624:	cf 91       	pop	r28
    5626:	df 91       	pop	r29
    5628:	1f 91       	pop	r17
    562a:	08 95       	ret

0000562c <nicPoll>:
    562c:	cf 92       	push	r12
    562e:	df 92       	push	r13
    5630:	ef 92       	push	r14
    5632:	ff 92       	push	r15
    5634:	0f 93       	push	r16
    5636:	1f 93       	push	r17
    5638:	cf 93       	push	r28
    563a:	df 93       	push	r29
    563c:	89 e3       	ldi	r24, 0x39	; 57
    563e:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    5642:	88 23       	and	r24, r24
    5644:	09 f4       	brne	.+2      	; 0x5648 <nicPoll+0x1c>
    5646:	9e c0       	rjmp	.+316    	; 0x5784 <nicPoll+0x158>
    5648:	80 e0       	ldi	r24, 0x00	; 0
    564a:	60 91 53 25 	lds	r22, 0x2553
    564e:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5652:	60 91 54 25 	lds	r22, 0x2554
    5656:	81 e0       	ldi	r24, 0x01	; 1
    5658:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    565c:	8a e3       	ldi	r24, 0x3A	; 58
    565e:	60 e0       	ldi	r22, 0x00	; 0
    5660:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
    5664:	c8 2f       	mov	r28, r24
    5666:	d0 e0       	ldi	r29, 0x00	; 0
    5668:	c0 93 53 25 	sts	0x2553, r28
    566c:	d0 93 54 25 	sts	0x2554, r29
    5670:	8a e3       	ldi	r24, 0x3A	; 58
    5672:	60 e0       	ldi	r22, 0x00	; 0
    5674:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
    5678:	38 2f       	mov	r19, r24
    567a:	20 e0       	ldi	r18, 0x00	; 0
    567c:	c2 2b       	or	r28, r18
    567e:	d3 2b       	or	r29, r19
    5680:	c0 93 53 25 	sts	0x2553, r28
    5684:	d0 93 54 25 	sts	0x2554, r29
    5688:	8a e3       	ldi	r24, 0x3A	; 58
    568a:	60 e0       	ldi	r22, 0x00	; 0
    568c:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
    5690:	c8 2e       	mov	r12, r24
    5692:	8a e3       	ldi	r24, 0x3A	; 58
    5694:	60 e0       	ldi	r22, 0x00	; 0
    5696:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
    569a:	e8 2e       	mov	r14, r24
    569c:	8a e3       	ldi	r24, 0x3A	; 58
    569e:	60 e0       	ldi	r22, 0x00	; 0
    56a0:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
    56a4:	08 2f       	mov	r16, r24
    56a6:	10 e0       	ldi	r17, 0x00	; 0
    56a8:	8a e3       	ldi	r24, 0x3A	; 58
    56aa:	60 e0       	ldi	r22, 0x00	; 0
    56ac:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
    56b0:	40 91 dc 31 	lds	r20, 0x31DC
    56b4:	50 91 dd 31 	lds	r21, 0x31DD
    56b8:	38 2f       	mov	r19, r24
    56ba:	20 e0       	ldi	r18, 0x00	; 0
    56bc:	02 2b       	or	r16, r18
    56be:	13 2b       	or	r17, r19
    56c0:	07 ff       	sbrs	r16, 7
    56c2:	2f c0       	rjmp	.+94     	; 0x5722 <nicPoll+0xf6>
    56c4:	cc 2d       	mov	r28, r12
    56c6:	d0 e0       	ldi	r29, 0x00	; 0
    56c8:	3e 2d       	mov	r19, r14
    56ca:	20 e0       	ldi	r18, 0x00	; 0
    56cc:	c2 2b       	or	r28, r18
    56ce:	d3 2b       	or	r29, r19
    56d0:	41 50       	subi	r20, 0x01	; 1
    56d2:	50 40       	sbci	r21, 0x00	; 0
    56d4:	24 97       	sbiw	r28, 0x04	; 4
    56d6:	4c 17       	cp	r20, r28
    56d8:	5d 07       	cpc	r21, r29
    56da:	08 f4       	brcc	.+2      	; 0x56de <nicPoll+0xb2>
    56dc:	ea 01       	movw	r28, r20
    56de:	c0 90 e4 31 	lds	r12, 0x31E4
    56e2:	d0 90 e5 31 	lds	r13, 0x31E5
    56e6:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
    56ea:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <spiEnableEnc28j60>
    56ee:	8a e3       	ldi	r24, 0x3A	; 58
    56f0:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    56f4:	76 01       	movw	r14, r12
    56f6:	8e 01       	movw	r16, r28
    56f8:	08 c0       	rjmp	.+16     	; 0x570a <nicPoll+0xde>
    56fa:	01 50       	subi	r16, 0x01	; 1
    56fc:	10 40       	sbci	r17, 0x00	; 0
    56fe:	80 e0       	ldi	r24, 0x00	; 0
    5700:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    5704:	f7 01       	movw	r30, r14
    5706:	81 93       	st	Z+, r24
    5708:	7f 01       	movw	r14, r30
    570a:	01 15       	cp	r16, r1
    570c:	11 05       	cpc	r17, r1
    570e:	a9 f7       	brne	.-22     	; 0x56fa <nicPoll+0xce>
    5710:	f6 01       	movw	r30, r12
    5712:	ec 0f       	add	r30, r28
    5714:	fd 1f       	adc	r31, r29
    5716:	10 82       	st	Z, r1
    5718:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <spiDisableEnc28j60>
    571c:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
    5720:	02 c0       	rjmp	.+4      	; 0x5726 <nicPoll+0xfa>
    5722:	c0 e0       	ldi	r28, 0x00	; 0
    5724:	d0 e0       	ldi	r29, 0x00	; 0
    5726:	8c e0       	ldi	r24, 0x0C	; 12
    5728:	60 91 53 25 	lds	r22, 0x2553
    572c:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5730:	60 91 54 25 	lds	r22, 0x2554
    5734:	8d e0       	ldi	r24, 0x0D	; 13
    5736:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    573a:	60 91 53 25 	lds	r22, 0x2553
    573e:	70 91 54 25 	lds	r23, 0x2554
    5742:	cb 01       	movw	r24, r22
    5744:	01 97       	sbiw	r24, 0x01	; 1
    5746:	f9 e1       	ldi	r31, 0x19	; 25
    5748:	8f 3f       	cpi	r24, 0xFF	; 255
    574a:	9f 07       	cpc	r25, r31
    574c:	38 f0       	brcs	.+14     	; 0x575c <nicPoll+0x130>
    574e:	8c e0       	ldi	r24, 0x0C	; 12
    5750:	6e ef       	ldi	r22, 0xFE	; 254
    5752:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5756:	8d e0       	ldi	r24, 0x0D	; 13
    5758:	69 e1       	ldi	r22, 0x19	; 25
    575a:	0c c0       	rjmp	.+24     	; 0x5774 <nicPoll+0x148>
    575c:	61 50       	subi	r22, 0x01	; 1
    575e:	8c e0       	ldi	r24, 0x0C	; 12
    5760:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5764:	20 91 53 25 	lds	r18, 0x2553
    5768:	30 91 54 25 	lds	r19, 0x2554
    576c:	21 50       	subi	r18, 0x01	; 1
    576e:	30 40       	sbci	r19, 0x00	; 0
    5770:	8d e0       	ldi	r24, 0x0D	; 13
    5772:	63 2f       	mov	r22, r19
    5774:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5778:	80 e8       	ldi	r24, 0x80	; 128
    577a:	6e e1       	ldi	r22, 0x1E	; 30
    577c:	40 e4       	ldi	r20, 0x40	; 64
    577e:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    5782:	02 c0       	rjmp	.+4      	; 0x5788 <nicPoll+0x15c>
    5784:	c0 e0       	ldi	r28, 0x00	; 0
    5786:	d0 e0       	ldi	r29, 0x00	; 0
    5788:	ce 01       	movw	r24, r28
    578a:	df 91       	pop	r29
    578c:	cf 91       	pop	r28
    578e:	1f 91       	pop	r17
    5790:	0f 91       	pop	r16
    5792:	ff 90       	pop	r15
    5794:	ef 90       	pop	r14
    5796:	df 90       	pop	r13
    5798:	cf 90       	pop	r12
    579a:	08 95       	ret

0000579c <nicSend>:
    579c:	0f 93       	push	r16
    579e:	1f 93       	push	r17
    57a0:	cf 93       	push	r28
    57a2:	df 93       	push	r29
    57a4:	ec 01       	movw	r28, r24
    57a6:	13 c0       	rjmp	.+38     	; 0x57ce <nicSend+0x32>
    57a8:	8c e1       	ldi	r24, 0x1C	; 28
    57aa:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    57ae:	81 ff       	sbrs	r24, 1
    57b0:	0a c0       	rjmp	.+20     	; 0x57c6 <nicSend+0x2a>
    57b2:	80 e8       	ldi	r24, 0x80	; 128
    57b4:	6f e1       	ldi	r22, 0x1F	; 31
    57b6:	40 e8       	ldi	r20, 0x80	; 128
    57b8:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    57bc:	80 ea       	ldi	r24, 0xA0	; 160
    57be:	6f e1       	ldi	r22, 0x1F	; 31
    57c0:	40 e8       	ldi	r20, 0x80	; 128
    57c2:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    57c6:	80 e0       	ldi	r24, 0x00	; 0
    57c8:	90 e0       	ldi	r25, 0x00	; 0
    57ca:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    57ce:	80 e0       	ldi	r24, 0x00	; 0
    57d0:	6f e1       	ldi	r22, 0x1F	; 31
    57d2:	0e 94 90 2a 	call	0x5520	; 0x5520 <enc28j60ReadOp>
    57d6:	83 fd       	sbrc	r24, 3
    57d8:	e7 cf       	rjmp	.-50     	; 0x57a8 <nicSend+0xc>
    57da:	82 e0       	ldi	r24, 0x02	; 2
    57dc:	6f ef       	ldi	r22, 0xFF	; 255
    57de:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    57e2:	83 e0       	ldi	r24, 0x03	; 3
    57e4:	69 e1       	ldi	r22, 0x19	; 25
    57e6:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    57ea:	ce 01       	movw	r24, r28
    57ec:	81 50       	subi	r24, 0x01	; 1
    57ee:	68 2f       	mov	r22, r24
    57f0:	86 e0       	ldi	r24, 0x06	; 6
    57f2:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    57f6:	9e 01       	movw	r18, r28
    57f8:	21 50       	subi	r18, 0x01	; 1
    57fa:	36 4e       	sbci	r19, 0xE6	; 230
    57fc:	87 e0       	ldi	r24, 0x07	; 7
    57fe:	63 2f       	mov	r22, r19
    5800:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5804:	8a e7       	ldi	r24, 0x7A	; 122
    5806:	60 e0       	ldi	r22, 0x00	; 0
    5808:	40 e0       	ldi	r20, 0x00	; 0
    580a:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    580e:	00 91 e4 31 	lds	r16, 0x31E4
    5812:	10 91 e5 31 	lds	r17, 0x31E5
    5816:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <spiTake>
    581a:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <spiEnableEnc28j60>
    581e:	8a e7       	ldi	r24, 0x7A	; 122
    5820:	04 c0       	rjmp	.+8      	; 0x582a <nicSend+0x8e>
    5822:	21 97       	sbiw	r28, 0x01	; 1
    5824:	f8 01       	movw	r30, r16
    5826:	81 91       	ld	r24, Z+
    5828:	8f 01       	movw	r16, r30
    582a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <spiSend>
    582e:	20 97       	sbiw	r28, 0x00	; 0
    5830:	c1 f7       	brne	.-16     	; 0x5822 <nicSend+0x86>
    5832:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <spiDisableEnc28j60>
    5836:	0e 94 0b 1c 	call	0x3816	; 0x3816 <spiGive>
    583a:	80 e8       	ldi	r24, 0x80	; 128
    583c:	6f e1       	ldi	r22, 0x1F	; 31
    583e:	48 e0       	ldi	r20, 0x08	; 8
    5840:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    5844:	df 91       	pop	r29
    5846:	cf 91       	pop	r28
    5848:	1f 91       	pop	r17
    584a:	0f 91       	pop	r16
    584c:	08 95       	ret

0000584e <nicSetMacAddress>:
    584e:	cf 93       	push	r28
    5850:	df 93       	push	r29
    5852:	ec 01       	movw	r28, r24
    5854:	84 ee       	ldi	r24, 0xE4	; 228
    5856:	68 81       	ld	r22, Y
    5858:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    585c:	85 ee       	ldi	r24, 0xE5	; 229
    585e:	69 81       	ldd	r22, Y+1	; 0x01
    5860:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5864:	82 ee       	ldi	r24, 0xE2	; 226
    5866:	6a 81       	ldd	r22, Y+2	; 0x02
    5868:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    586c:	83 ee       	ldi	r24, 0xE3	; 227
    586e:	6b 81       	ldd	r22, Y+3	; 0x03
    5870:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5874:	80 ee       	ldi	r24, 0xE0	; 224
    5876:	6c 81       	ldd	r22, Y+4	; 0x04
    5878:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    587c:	81 ee       	ldi	r24, 0xE1	; 225
    587e:	6d 81       	ldd	r22, Y+5	; 0x05
    5880:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5884:	df 91       	pop	r29
    5886:	cf 91       	pop	r28
    5888:	08 95       	ret

0000588a <nicMacInit>:
    588a:	85 e0       	ldi	r24, 0x05	; 5
    588c:	90 e0       	ldi	r25, 0x00	; 0
    588e:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    5892:	85 e0       	ldi	r24, 0x05	; 5
    5894:	90 e0       	ldi	r25, 0x00	; 0
    5896:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    589a:	85 e0       	ldi	r24, 0x05	; 5
    589c:	90 e0       	ldi	r25, 0x00	; 0
    589e:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    58a2:	10 92 53 25 	sts	0x2553, r1
    58a6:	10 92 54 25 	sts	0x2554, r1
    58aa:	88 e0       	ldi	r24, 0x08	; 8
    58ac:	60 e0       	ldi	r22, 0x00	; 0
    58ae:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58b2:	89 e0       	ldi	r24, 0x09	; 9
    58b4:	60 e0       	ldi	r22, 0x00	; 0
    58b6:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58ba:	8c e0       	ldi	r24, 0x0C	; 12
    58bc:	60 e0       	ldi	r22, 0x00	; 0
    58be:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58c2:	8d e0       	ldi	r24, 0x0D	; 13
    58c4:	60 e0       	ldi	r22, 0x00	; 0
    58c6:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58ca:	8a e0       	ldi	r24, 0x0A	; 10
    58cc:	6e ef       	ldi	r22, 0xFE	; 254
    58ce:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58d2:	8b e0       	ldi	r24, 0x0B	; 11
    58d4:	69 e1       	ldi	r22, 0x19	; 25
    58d6:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58da:	84 e0       	ldi	r24, 0x04	; 4
    58dc:	6f ef       	ldi	r22, 0xFF	; 255
    58de:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58e2:	85 e0       	ldi	r24, 0x05	; 5
    58e4:	69 e1       	ldi	r22, 0x19	; 25
    58e6:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58ea:	86 e0       	ldi	r24, 0x06	; 6
    58ec:	6f ef       	ldi	r22, 0xFF	; 255
    58ee:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58f2:	87 e0       	ldi	r24, 0x07	; 7
    58f4:	6f e1       	ldi	r22, 0x1F	; 31
    58f6:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    58fa:	88 e3       	ldi	r24, 0x38	; 56
    58fc:	62 eb       	ldi	r22, 0xB2	; 178
    58fe:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5902:	88 e2       	ldi	r24, 0x28	; 40
    5904:	6f e3       	ldi	r22, 0x3F	; 63
    5906:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    590a:	89 e2       	ldi	r24, 0x29	; 41
    590c:	60 e3       	ldi	r22, 0x30	; 48
    590e:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5912:	80 e3       	ldi	r24, 0x30	; 48
    5914:	69 ef       	ldi	r22, 0xF9	; 249
    5916:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    591a:	81 e3       	ldi	r24, 0x31	; 49
    591c:	67 ef       	ldi	r22, 0xF7	; 247
    591e:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5922:	80 ec       	ldi	r24, 0xC0	; 192
    5924:	6d e0       	ldi	r22, 0x0D	; 13
    5926:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    592a:	81 ec       	ldi	r24, 0xC1	; 193
    592c:	60 e0       	ldi	r22, 0x00	; 0
    592e:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5932:	80 e8       	ldi	r24, 0x80	; 128
    5934:	62 ec       	ldi	r22, 0xC2	; 194
    5936:	42 e3       	ldi	r20, 0x32	; 50
    5938:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    593c:	86 ec       	ldi	r24, 0xC6	; 198
    593e:	62 e1       	ldi	r22, 0x12	; 18
    5940:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5944:	87 ec       	ldi	r24, 0xC7	; 199
    5946:	6c e0       	ldi	r22, 0x0C	; 12
    5948:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    594c:	84 ec       	ldi	r24, 0xC4	; 196
    594e:	62 e1       	ldi	r22, 0x12	; 18
    5950:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5954:	8a ec       	ldi	r24, 0xCA	; 202
    5956:	6c ed       	ldi	r22, 0xDC	; 220
    5958:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    595c:	8b ec       	ldi	r24, 0xCB	; 203
    595e:	65 e0       	ldi	r22, 0x05	; 5
    5960:	0e 94 7c 2a 	call	0x54f8	; 0x54f8 <enc28j60Write>
    5964:	8e ed       	ldi	r24, 0xDE	; 222
    5966:	91 e3       	ldi	r25, 0x31	; 49
    5968:	0e 94 27 2c 	call	0x584e	; 0x584e <nicSetMacAddress>
    596c:	80 e1       	ldi	r24, 0x10	; 16
    596e:	60 e0       	ldi	r22, 0x00	; 0
    5970:	71 e0       	ldi	r23, 0x01	; 1
    5972:	0e 94 f1 2a 	call	0x55e2	; 0x55e2 <enc28j60PhyWrite>
    5976:	8f e1       	ldi	r24, 0x1F	; 31
    5978:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <enc28j60SetBank>
    597c:	80 e8       	ldi	r24, 0x80	; 128
    597e:	6b e1       	ldi	r22, 0x1B	; 27
    5980:	40 ec       	ldi	r20, 0xC0	; 192
    5982:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    5986:	80 e8       	ldi	r24, 0x80	; 128
    5988:	6f e1       	ldi	r22, 0x1F	; 31
    598a:	44 e0       	ldi	r20, 0x04	; 4
    598c:	0e 94 36 2a 	call	0x546c	; 0x546c <enc28j60WriteOp>
    5990:	85 e0       	ldi	r24, 0x05	; 5
    5992:	90 e0       	ldi	r25, 0x00	; 0
    5994:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    5998:	84 e1       	ldi	r24, 0x14	; 20
    599a:	66 e7       	ldi	r22, 0x76	; 118
    599c:	74 e0       	ldi	r23, 0x04	; 4
    599e:	0e 94 f1 2a 	call	0x55e2	; 0x55e2 <enc28j60PhyWrite>
    59a2:	82 e0       	ldi	r24, 0x02	; 2
    59a4:	90 e0       	ldi	r25, 0x00	; 0
    59a6:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
    59aa:	08 95       	ret

000059ac <nicGetMacAddress>:
    59ac:	cf 93       	push	r28
    59ae:	df 93       	push	r29
    59b0:	ec 01       	movw	r28, r24
    59b2:	81 ee       	ldi	r24, 0xE1	; 225
    59b4:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    59b8:	8d 83       	std	Y+5, r24	; 0x05
    59ba:	80 ee       	ldi	r24, 0xE0	; 224
    59bc:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    59c0:	8c 83       	std	Y+4, r24	; 0x04
    59c2:	83 ee       	ldi	r24, 0xE3	; 227
    59c4:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    59c8:	8b 83       	std	Y+3, r24	; 0x03
    59ca:	82 ee       	ldi	r24, 0xE2	; 226
    59cc:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    59d0:	8a 83       	std	Y+2, r24	; 0x02
    59d2:	85 ee       	ldi	r24, 0xE5	; 229
    59d4:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    59d8:	89 83       	std	Y+1, r24	; 0x01
    59da:	84 ee       	ldi	r24, 0xE4	; 228
    59dc:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    59e0:	88 83       	st	Y, r24
    59e2:	df 91       	pop	r29
    59e4:	cf 91       	pop	r28
    59e6:	08 95       	ret

000059e8 <nicRegDump>:
    59e8:	cf 93       	push	r28
    59ea:	df 93       	push	r29
    59ec:	ec 01       	movw	r28, r24
    59ee:	00 d0       	rcall	.+0      	; 0x59f0 <nicRegDump+0x8>
    59f0:	0f 92       	push	r0
    59f2:	ad b7       	in	r26, 0x3d	; 61
    59f4:	be b7       	in	r27, 0x3e	; 62
    59f6:	11 96       	adiw	r26, 0x01	; 1
    59f8:	8d 93       	st	X+, r24
    59fa:	9c 93       	st	X, r25
    59fc:	12 97       	sbiw	r26, 0x02	; 2
    59fe:	85 ec       	ldi	r24, 0xC5	; 197
    5a00:	98 e0       	ldi	r25, 0x08	; 8
    5a02:	13 96       	adiw	r26, 0x03	; 3
    5a04:	8d 93       	st	X+, r24
    5a06:	9c 93       	st	X, r25
    5a08:	14 97       	sbiw	r26, 0x04	; 4
    5a0a:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5a0e:	0f 90       	pop	r0
    5a10:	0f 90       	pop	r0
    5a12:	0f 90       	pop	r0
    5a14:	0f 90       	pop	r0
    5a16:	81 ee       	ldi	r24, 0xE1	; 225
    5a18:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    5a1c:	00 d0       	rcall	.+0      	; 0x5a1e <nicRegDump+0x36>
    5a1e:	00 d0       	rcall	.+0      	; 0x5a20 <nicRegDump+0x38>
    5a20:	ed b7       	in	r30, 0x3d	; 61
    5a22:	fe b7       	in	r31, 0x3e	; 62
    5a24:	31 96       	adiw	r30, 0x01	; 1
    5a26:	ad b7       	in	r26, 0x3d	; 61
    5a28:	be b7       	in	r27, 0x3e	; 62
    5a2a:	11 96       	adiw	r26, 0x01	; 1
    5a2c:	cd 93       	st	X+, r28
    5a2e:	dc 93       	st	X, r29
    5a30:	12 97       	sbiw	r26, 0x02	; 2
    5a32:	26 eb       	ldi	r18, 0xB6	; 182
    5a34:	38 e0       	ldi	r19, 0x08	; 8
    5a36:	22 83       	std	Z+2, r18	; 0x02
    5a38:	33 83       	std	Z+3, r19	; 0x03
    5a3a:	84 83       	std	Z+4, r24	; 0x04
    5a3c:	15 82       	std	Z+5, r1	; 0x05
    5a3e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5a42:	ed b7       	in	r30, 0x3d	; 61
    5a44:	fe b7       	in	r31, 0x3e	; 62
    5a46:	36 96       	adiw	r30, 0x06	; 6
    5a48:	ed bf       	out	0x3d, r30	; 61
    5a4a:	fe bf       	out	0x3e, r31	; 62
    5a4c:	80 ee       	ldi	r24, 0xE0	; 224
    5a4e:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    5a52:	00 d0       	rcall	.+0      	; 0x5a54 <nicRegDump+0x6c>
    5a54:	00 d0       	rcall	.+0      	; 0x5a56 <nicRegDump+0x6e>
    5a56:	ed b7       	in	r30, 0x3d	; 61
    5a58:	fe b7       	in	r31, 0x3e	; 62
    5a5a:	31 96       	adiw	r30, 0x01	; 1
    5a5c:	ad b7       	in	r26, 0x3d	; 61
    5a5e:	be b7       	in	r27, 0x3e	; 62
    5a60:	11 96       	adiw	r26, 0x01	; 1
    5a62:	cd 93       	st	X+, r28
    5a64:	dc 93       	st	X, r29
    5a66:	12 97       	sbiw	r26, 0x02	; 2
    5a68:	27 ea       	ldi	r18, 0xA7	; 167
    5a6a:	38 e0       	ldi	r19, 0x08	; 8
    5a6c:	22 83       	std	Z+2, r18	; 0x02
    5a6e:	33 83       	std	Z+3, r19	; 0x03
    5a70:	84 83       	std	Z+4, r24	; 0x04
    5a72:	15 82       	std	Z+5, r1	; 0x05
    5a74:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5a78:	ed b7       	in	r30, 0x3d	; 61
    5a7a:	fe b7       	in	r31, 0x3e	; 62
    5a7c:	36 96       	adiw	r30, 0x06	; 6
    5a7e:	ed bf       	out	0x3d, r30	; 61
    5a80:	fe bf       	out	0x3e, r31	; 62
    5a82:	83 ee       	ldi	r24, 0xE3	; 227
    5a84:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    5a88:	00 d0       	rcall	.+0      	; 0x5a8a <nicRegDump+0xa2>
    5a8a:	00 d0       	rcall	.+0      	; 0x5a8c <nicRegDump+0xa4>
    5a8c:	ed b7       	in	r30, 0x3d	; 61
    5a8e:	fe b7       	in	r31, 0x3e	; 62
    5a90:	31 96       	adiw	r30, 0x01	; 1
    5a92:	ad b7       	in	r26, 0x3d	; 61
    5a94:	be b7       	in	r27, 0x3e	; 62
    5a96:	11 96       	adiw	r26, 0x01	; 1
    5a98:	cd 93       	st	X+, r28
    5a9a:	dc 93       	st	X, r29
    5a9c:	12 97       	sbiw	r26, 0x02	; 2
    5a9e:	28 e9       	ldi	r18, 0x98	; 152
    5aa0:	38 e0       	ldi	r19, 0x08	; 8
    5aa2:	22 83       	std	Z+2, r18	; 0x02
    5aa4:	33 83       	std	Z+3, r19	; 0x03
    5aa6:	84 83       	std	Z+4, r24	; 0x04
    5aa8:	15 82       	std	Z+5, r1	; 0x05
    5aaa:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5aae:	ed b7       	in	r30, 0x3d	; 61
    5ab0:	fe b7       	in	r31, 0x3e	; 62
    5ab2:	36 96       	adiw	r30, 0x06	; 6
    5ab4:	ed bf       	out	0x3d, r30	; 61
    5ab6:	fe bf       	out	0x3e, r31	; 62
    5ab8:	82 ee       	ldi	r24, 0xE2	; 226
    5aba:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    5abe:	00 d0       	rcall	.+0      	; 0x5ac0 <nicRegDump+0xd8>
    5ac0:	00 d0       	rcall	.+0      	; 0x5ac2 <nicRegDump+0xda>
    5ac2:	ed b7       	in	r30, 0x3d	; 61
    5ac4:	fe b7       	in	r31, 0x3e	; 62
    5ac6:	31 96       	adiw	r30, 0x01	; 1
    5ac8:	ad b7       	in	r26, 0x3d	; 61
    5aca:	be b7       	in	r27, 0x3e	; 62
    5acc:	11 96       	adiw	r26, 0x01	; 1
    5ace:	cd 93       	st	X+, r28
    5ad0:	dc 93       	st	X, r29
    5ad2:	12 97       	sbiw	r26, 0x02	; 2
    5ad4:	29 e8       	ldi	r18, 0x89	; 137
    5ad6:	38 e0       	ldi	r19, 0x08	; 8
    5ad8:	22 83       	std	Z+2, r18	; 0x02
    5ada:	33 83       	std	Z+3, r19	; 0x03
    5adc:	84 83       	std	Z+4, r24	; 0x04
    5ade:	15 82       	std	Z+5, r1	; 0x05
    5ae0:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5ae4:	ed b7       	in	r30, 0x3d	; 61
    5ae6:	fe b7       	in	r31, 0x3e	; 62
    5ae8:	36 96       	adiw	r30, 0x06	; 6
    5aea:	ed bf       	out	0x3d, r30	; 61
    5aec:	fe bf       	out	0x3e, r31	; 62
    5aee:	85 ee       	ldi	r24, 0xE5	; 229
    5af0:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    5af4:	00 d0       	rcall	.+0      	; 0x5af6 <nicRegDump+0x10e>
    5af6:	00 d0       	rcall	.+0      	; 0x5af8 <nicRegDump+0x110>
    5af8:	ed b7       	in	r30, 0x3d	; 61
    5afa:	fe b7       	in	r31, 0x3e	; 62
    5afc:	31 96       	adiw	r30, 0x01	; 1
    5afe:	ad b7       	in	r26, 0x3d	; 61
    5b00:	be b7       	in	r27, 0x3e	; 62
    5b02:	11 96       	adiw	r26, 0x01	; 1
    5b04:	cd 93       	st	X+, r28
    5b06:	dc 93       	st	X, r29
    5b08:	12 97       	sbiw	r26, 0x02	; 2
    5b0a:	2a e7       	ldi	r18, 0x7A	; 122
    5b0c:	38 e0       	ldi	r19, 0x08	; 8
    5b0e:	22 83       	std	Z+2, r18	; 0x02
    5b10:	33 83       	std	Z+3, r19	; 0x03
    5b12:	84 83       	std	Z+4, r24	; 0x04
    5b14:	15 82       	std	Z+5, r1	; 0x05
    5b16:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5b1a:	ed b7       	in	r30, 0x3d	; 61
    5b1c:	fe b7       	in	r31, 0x3e	; 62
    5b1e:	36 96       	adiw	r30, 0x06	; 6
    5b20:	ed bf       	out	0x3d, r30	; 61
    5b22:	fe bf       	out	0x3e, r31	; 62
    5b24:	84 ee       	ldi	r24, 0xE4	; 228
    5b26:	0e 94 b5 2a 	call	0x556a	; 0x556a <enc28j60Read>
    5b2a:	00 d0       	rcall	.+0      	; 0x5b2c <nicRegDump+0x144>
    5b2c:	00 d0       	rcall	.+0      	; 0x5b2e <nicRegDump+0x146>
    5b2e:	ed b7       	in	r30, 0x3d	; 61
    5b30:	fe b7       	in	r31, 0x3e	; 62
    5b32:	31 96       	adiw	r30, 0x01	; 1
    5b34:	ad b7       	in	r26, 0x3d	; 61
    5b36:	be b7       	in	r27, 0x3e	; 62
    5b38:	11 96       	adiw	r26, 0x01	; 1
    5b3a:	cd 93       	st	X+, r28
    5b3c:	dc 93       	st	X, r29
    5b3e:	12 97       	sbiw	r26, 0x02	; 2
    5b40:	2b e6       	ldi	r18, 0x6B	; 107
    5b42:	38 e0       	ldi	r19, 0x08	; 8
    5b44:	22 83       	std	Z+2, r18	; 0x02
    5b46:	33 83       	std	Z+3, r19	; 0x03
    5b48:	84 83       	std	Z+4, r24	; 0x04
    5b4a:	15 82       	std	Z+5, r1	; 0x05
    5b4c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5b50:	ed b7       	in	r30, 0x3d	; 61
    5b52:	fe b7       	in	r31, 0x3e	; 62
    5b54:	36 96       	adiw	r30, 0x06	; 6
    5b56:	ed bf       	out	0x3d, r30	; 61
    5b58:	fe bf       	out	0x3e, r31	; 62
    5b5a:	df 91       	pop	r29
    5b5c:	cf 91       	pop	r28
    5b5e:	08 95       	ret

00005b60 <streamQueueInputFun>:
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
  return 0;
}

static int streamQueueInputFun(FILE *istream)
{
    5b60:	df 93       	push	r29
    5b62:	cf 93       	push	r28
    5b64:	0f 92       	push	r0
    5b66:	cd b7       	in	r28, 0x3d	; 61
    5b68:	de b7       	in	r29, 0x3e	; 62
  char c;
  streamBuffers_t *strBuf = (streamBuffers_t *) istream->udata;
  xQueueReceive(strBuf->Rx, &c, portMAX_DELAY);
    5b6a:	dc 01       	movw	r26, r24
    5b6c:	1c 96       	adiw	r26, 0x0c	; 12
    5b6e:	ed 91       	ld	r30, X+
    5b70:	fc 91       	ld	r31, X
    5b72:	1d 97       	sbiw	r26, 0x0d	; 13
    5b74:	80 81       	ld	r24, Z
    5b76:	91 81       	ldd	r25, Z+1	; 0x01
    5b78:	be 01       	movw	r22, r28
    5b7a:	6f 5f       	subi	r22, 0xFF	; 255
    5b7c:	7f 4f       	sbci	r23, 0xFF	; 255
    5b7e:	4f ef       	ldi	r20, 0xFF	; 255
    5b80:	5f ef       	ldi	r21, 0xFF	; 255
    5b82:	20 e0       	ldi	r18, 0x00	; 0
    5b84:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
  return c;
    5b88:	89 81       	ldd	r24, Y+1	; 0x01
    5b8a:	28 2f       	mov	r18, r24
    5b8c:	33 27       	eor	r19, r19
    5b8e:	27 fd       	sbrc	r18, 7
    5b90:	30 95       	com	r19
}
    5b92:	93 2f       	mov	r25, r19
    5b94:	0f 90       	pop	r0
    5b96:	cf 91       	pop	r28
    5b98:	df 91       	pop	r29
    5b9a:	08 95       	ret

00005b9c <streamQueueOutputFun>:
  buffer->Tx = Tx;
  return;
}

static int streamQueueOutputFun(char c, FILE *ostream)
{
    5b9c:	df 93       	push	r29
    5b9e:	cf 93       	push	r28
    5ba0:	0f 92       	push	r0
    5ba2:	cd b7       	in	r28, 0x3d	; 61
    5ba4:	de b7       	in	r29, 0x3e	; 62
    5ba6:	89 83       	std	Y+1, r24	; 0x01
/*  if (xQueueSend( strBuf->Tx, &c, strBuf->tx_timeout))
  {
    return EOF;
  }
  else*/
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
    5ba8:	db 01       	movw	r26, r22
    5baa:	1c 96       	adiw	r26, 0x0c	; 12
    5bac:	ed 91       	ld	r30, X+
    5bae:	fc 91       	ld	r31, X
    5bb0:	1d 97       	sbiw	r26, 0x0d	; 13
    5bb2:	82 81       	ldd	r24, Z+2	; 0x02
    5bb4:	93 81       	ldd	r25, Z+3	; 0x03
    5bb6:	be 01       	movw	r22, r28
    5bb8:	6f 5f       	subi	r22, 0xFF	; 255
    5bba:	7f 4f       	sbci	r23, 0xFF	; 255
    5bbc:	4f ef       	ldi	r20, 0xFF	; 255
    5bbe:	5f ef       	ldi	r21, 0xFF	; 255
    5bc0:	20 e0       	ldi	r18, 0x00	; 0
    5bc2:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>
  return 0;
}
    5bc6:	80 e0       	ldi	r24, 0x00	; 0
    5bc8:	90 e0       	ldi	r25, 0x00	; 0
    5bca:	0f 90       	pop	r0
    5bcc:	cf 91       	pop	r28
    5bce:	df 91       	pop	r29
    5bd0:	08 95       	ret

00005bd2 <initQueueStream>:

static int streamQueueOutputFun(char c, FILE *ostream);
static int streamQueueInputFun(FILE *istream);

void initQueueStream(FILE *stream, streamBuffers_t *buffer, xQueueHandle Rx, xQueueHandle Tx)
{
    5bd2:	fc 01       	movw	r30, r24
    5bd4:	db 01       	movw	r26, r22
  fdev_setup_stream(stream, streamQueueOutputFun, streamQueueInputFun, _FDEV_SETUP_RW);
    5bd6:	8e ec       	ldi	r24, 0xCE	; 206
    5bd8:	9d e2       	ldi	r25, 0x2D	; 45
    5bda:	80 87       	std	Z+8, r24	; 0x08
    5bdc:	91 87       	std	Z+9, r25	; 0x09
    5bde:	80 eb       	ldi	r24, 0xB0	; 176
    5be0:	9d e2       	ldi	r25, 0x2D	; 45
    5be2:	82 87       	std	Z+10, r24	; 0x0a
    5be4:	93 87       	std	Z+11, r25	; 0x0b
    5be6:	83 e0       	ldi	r24, 0x03	; 3
    5be8:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, (void *)buffer);
    5bea:	64 87       	std	Z+12, r22	; 0x0c
    5bec:	75 87       	std	Z+13, r23	; 0x0d
  buffer->Rx = Rx;
    5bee:	4d 93       	st	X+, r20
    5bf0:	5c 93       	st	X, r21
    5bf2:	11 97       	sbiw	r26, 0x01	; 1
  buffer->Tx = Tx;
    5bf4:	12 96       	adiw	r26, 0x02	; 2
    5bf6:	2d 93       	st	X+, r18
    5bf8:	3c 93       	st	X, r19
    5bfa:	13 97       	sbiw	r26, 0x03	; 3
  return;
}
    5bfc:	08 95       	ret
    5bfe:	08 95       	ret
    5c00:	08 95       	ret
    5c02:	80 e0       	ldi	r24, 0x00	; 0
    5c04:	90 e0       	ldi	r25, 0x00	; 0
    5c06:	08 95       	ret

00005c08 <saveNic>:
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
}

void saveNic(void)
{
  eeprom_update_block(&nicState.mac.addr, mymac_eep, 6);
    5c08:	8e ed       	ldi	r24, 0xDE	; 222
    5c0a:	91 e3       	ldi	r25, 0x31	; 49
    5c0c:	68 e1       	ldi	r22, 0x18	; 24
    5c0e:	70 e0       	ldi	r23, 0x00	; 0
    5c10:	46 e0       	ldi	r20, 0x06	; 6
    5c12:	50 e0       	ldi	r21, 0x00	; 0
    5c14:	0e 94 33 5a 	call	0xb466	; 0xb466 <__eeupd_block_x128a1>
}
    5c18:	08 95       	ret

00005c1a <nicInit>:
unsigned int nicPoll(void)                                       { return 0; }


static void nicBufferInit(void)
{
  nicState.bufferSize  = NETWORK_STACK_BUF_SIZE;
    5c1a:	80 e0       	ldi	r24, 0x00	; 0
    5c1c:	96 e0       	ldi	r25, 0x06	; 6
    5c1e:	80 93 dc 31 	sts	0x31DC, r24
    5c22:	90 93 dd 31 	sts	0x31DD, r25
  nicState.layer2.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR);
    5c26:	e0 e0       	ldi	r30, 0x00	; 0
    5c28:	fa e7       	ldi	r31, 0x7A	; 122
    5c2a:	e0 93 e4 31 	sts	0x31E4, r30
    5c2e:	f0 93 e5 31 	sts	0x31E5, r31
  nicState.layer3.ip   = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
    5c32:	2e e0       	ldi	r18, 0x0E	; 14
    5c34:	3a e7       	ldi	r19, 0x7A	; 122
    5c36:	20 93 e6 31 	sts	0x31E6, r18
    5c3a:	30 93 e7 31 	sts	0x31E7, r19
  nicState.layer4.icmp = (struct  netIcmpHeader *)(NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN + IP_HEADER_LEN);
    5c3e:	22 e2       	ldi	r18, 0x22	; 34
    5c40:	3a e7       	ldi	r19, 0x7A	; 122
    5c42:	20 93 e8 31 	sts	0x31E8, r18
    5c46:	30 93 e9 31 	sts	0x31E9, r19
  #if IPV6_SUPPORT
  nicState.layer3.ipv6 = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  nicState.layer3.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  //nicState.layer4.icmpv6  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  #endif /*IPV6_SUPPORT*/
  memset(nicState.layer2.buf, 0, nicState.bufferSize);
    5c4a:	df 01       	movw	r26, r30
    5c4c:	9c 01       	movw	r18, r24
    5c4e:	1d 92       	st	X+, r1
    5c50:	21 50       	subi	r18, 0x01	; 1
    5c52:	30 40       	sbci	r19, 0x00	; 0
    5c54:	e1 f7       	brne	.-8      	; 0x5c4e <nicInit+0x34>
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
    5c56:	8e ed       	ldi	r24, 0xDE	; 222
    5c58:	91 e3       	ldi	r25, 0x31	; 49
    5c5a:	68 e1       	ldi	r22, 0x18	; 24
    5c5c:	70 e0       	ldi	r23, 0x00	; 0
    5c5e:	46 e0       	ldi	r20, 0x06	; 6
    5c60:	50 e0       	ldi	r21, 0x00	; 0
    5c62:	0e 94 1b 5a 	call	0xb436	; 0xb436 <__eerd_block_x128a1>
}

void nicInit()
{
  nicBufferInit();
  nicMacInit();
    5c66:	0e 94 45 2c 	call	0x588a	; 0x588a <nicMacInit>
}
    5c6a:	08 95       	ret
    5c6c:	6e ed       	ldi	r22, 0xDE	; 222
    5c6e:	71 e3       	ldi	r23, 0x31	; 49
    5c70:	46 e0       	ldi	r20, 0x06	; 6
    5c72:	50 e0       	ldi	r21, 0x00	; 0
    5c74:	0e 94 f9 56 	call	0xadf2	; 0xadf2 <strncpy>
    5c78:	08 95       	ret
    5c7a:	bc 01       	movw	r22, r24
    5c7c:	8e ed       	ldi	r24, 0xDE	; 222
    5c7e:	91 e3       	ldi	r25, 0x31	; 49
    5c80:	46 e0       	ldi	r20, 0x06	; 6
    5c82:	50 e0       	ldi	r21, 0x00	; 0
    5c84:	0e 94 f9 56 	call	0xadf2	; 0xadf2 <strncpy>
    5c88:	0e 94 45 2c 	call	0x588a	; 0x588a <nicMacInit>
    5c8c:	08 95       	ret
    5c8e:	00 d0       	rcall	.+0      	; 0x5c90 <nicInit+0x76>
    5c90:	0f 92       	push	r0
    5c92:	ed b7       	in	r30, 0x3d	; 61
    5c94:	fe b7       	in	r31, 0x3e	; 62
    5c96:	81 83       	std	Z+1, r24	; 0x01
    5c98:	92 83       	std	Z+2, r25	; 0x02
    5c9a:	80 ee       	ldi	r24, 0xE0	; 224
    5c9c:	98 e0       	ldi	r25, 0x08	; 8
    5c9e:	83 83       	std	Z+3, r24	; 0x03
    5ca0:	94 83       	std	Z+4, r25	; 0x04
    5ca2:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5ca6:	0f 90       	pop	r0
    5ca8:	0f 90       	pop	r0
    5caa:	0f 90       	pop	r0
    5cac:	0f 90       	pop	r0
    5cae:	08 95       	ret

00005cb0 <htons>:
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5cb0:	38 2f       	mov	r19, r24
    5cb2:	29 2f       	mov	r18, r25
}
    5cb4:	c9 01       	movw	r24, r18
    5cb6:	08 95       	ret

00005cb8 <htonl>:
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5cb8:	36 2f       	mov	r19, r22
    5cba:	27 2f       	mov	r18, r23
}

uint32_t htonl(uint32_t val)
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
    5cbc:	40 e0       	ldi	r20, 0x00	; 0
    5cbe:	50 e0       	ldi	r21, 0x00	; 0
    5cc0:	a9 01       	movw	r20, r18
    5cc2:	33 27       	eor	r19, r19
    5cc4:	22 27       	eor	r18, r18
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5cc6:	98 27       	eor	r25, r24
    5cc8:	89 27       	eor	r24, r25
    5cca:	98 27       	eor	r25, r24
}

uint32_t htonl(uint32_t val)
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
    5ccc:	a0 e0       	ldi	r26, 0x00	; 0
    5cce:	b0 e0       	ldi	r27, 0x00	; 0
    5cd0:	28 2b       	or	r18, r24
    5cd2:	39 2b       	or	r19, r25
    5cd4:	4a 2b       	or	r20, r26
    5cd6:	5b 2b       	or	r21, r27
}
    5cd8:	b9 01       	movw	r22, r18
    5cda:	ca 01       	movw	r24, r20
    5cdc:	08 95       	ret

00005cde <netChecksum>:


uint16_t netChecksum(uint8_t *data, uint16_t len)
{
    5cde:	ef 92       	push	r14
    5ce0:	ff 92       	push	r15
    5ce2:	0f 93       	push	r16
    5ce4:	1f 93       	push	r17
    5ce6:	fb 01       	movw	r30, r22
    5ce8:	dc 01       	movw	r26, r24
  register uint32_t sum = 0;
    5cea:	20 e0       	ldi	r18, 0x00	; 0
    5cec:	30 e0       	ldi	r19, 0x00	; 0
    5cee:	a9 01       	movw	r20, r18

  for (;;) 
  {
    if (len < 2)
    5cf0:	e2 30       	cpi	r30, 0x02	; 2
    5cf2:	f1 05       	cpc	r31, r1
    5cf4:	50 f0       	brcs	.+20     	; 0x5d0a <netChecksum+0x2c>
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    5cf6:	ed 90       	ld	r14, X+
    5cf8:	fd 90       	ld	r15, X+
    5cfa:	00 e0       	ldi	r16, 0x00	; 0
    5cfc:	10 e0       	ldi	r17, 0x00	; 0
    5cfe:	2e 0d       	add	r18, r14
    5d00:	3f 1d       	adc	r19, r15
    5d02:	40 1f       	adc	r20, r16
    5d04:	51 1f       	adc	r21, r17
    data+=2;
    len -= 2;
    5d06:	32 97       	sbiw	r30, 0x02	; 2
  }
    5d08:	f3 cf       	rjmp	.-26     	; 0x5cf0 <netChecksum+0x12>
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
}


uint16_t netChecksum(uint8_t *data, uint16_t len)
    5d0a:	fb 01       	movw	r30, r22
    5d0c:	ee 7f       	andi	r30, 0xFE	; 254
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    data+=2;
    len -= 2;
  }
    5d0e:	e8 0f       	add	r30, r24
    5d10:	f9 1f       	adc	r31, r25
  if (len)
    5d12:	60 ff       	sbrs	r22, 0
    5d14:	0a c0       	rjmp	.+20     	; 0x5d2a <netChecksum+0x4c>
    sum += *(uint8_t *) data;
    5d16:	80 81       	ld	r24, Z
    5d18:	28 0f       	add	r18, r24
    5d1a:	31 1d       	adc	r19, r1
    5d1c:	41 1d       	adc	r20, r1
    5d1e:	51 1d       	adc	r21, r1
    5d20:	04 c0       	rjmp	.+8      	; 0x5d2a <netChecksum+0x4c>

  while ((len = (uint16_t) (sum >> 16)) != 0)
    sum = (uint16_t) sum + len;
    5d22:	28 0f       	add	r18, r24
    5d24:	39 1f       	adc	r19, r25
    5d26:	40 e0       	ldi	r20, 0x00	; 0
    5d28:	50 e0       	ldi	r21, 0x00	; 0
    len -= 2;
  }
  if (len)
    sum += *(uint8_t *) data;

  while ((len = (uint16_t) (sum >> 16)) != 0)
    5d2a:	ca 01       	movw	r24, r20
    5d2c:	00 97       	sbiw	r24, 0x00	; 0
    5d2e:	c9 f7       	brne	.-14     	; 0x5d22 <netChecksum+0x44>
    sum = (uint16_t) sum + len;

  return (uint16_t) sum ^ 0xFFFF;
    5d30:	20 95       	com	r18
    5d32:	30 95       	com	r19
}
    5d34:	c9 01       	movw	r24, r18
    5d36:	1f 91       	pop	r17
    5d38:	0f 91       	pop	r16
    5d3a:	ff 90       	pop	r15
    5d3c:	ef 90       	pop	r14
    5d3e:	08 95       	ret

00005d40 <netPrintEthAddr>:

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
    5d40:	cf 93       	push	r28
    5d42:	df 93       	push	r29
    5d44:	db 01       	movw	r26, r22
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    5d46:	2d b7       	in	r18, 0x3d	; 61
    5d48:	3e b7       	in	r19, 0x3e	; 62
    5d4a:	20 51       	subi	r18, 0x10	; 16
    5d4c:	30 40       	sbci	r19, 0x00	; 0
    5d4e:	2d bf       	out	0x3d, r18	; 61
    5d50:	3e bf       	out	0x3e, r19	; 62
    5d52:	ed b7       	in	r30, 0x3d	; 61
    5d54:	fe b7       	in	r31, 0x3e	; 62
    5d56:	31 96       	adiw	r30, 0x01	; 1
    5d58:	cd b7       	in	r28, 0x3d	; 61
    5d5a:	de b7       	in	r29, 0x3e	; 62
    5d5c:	89 83       	std	Y+1, r24	; 0x01
    5d5e:	9a 83       	std	Y+2, r25	; 0x02
    5d60:	8b e2       	ldi	r24, 0x2B	; 43
    5d62:	9a e0       	ldi	r25, 0x0A	; 10
    5d64:	82 83       	std	Z+2, r24	; 0x02
    5d66:	93 83       	std	Z+3, r25	; 0x03
    5d68:	8c 91       	ld	r24, X
    5d6a:	84 83       	std	Z+4, r24	; 0x04
    5d6c:	15 82       	std	Z+5, r1	; 0x05
    5d6e:	11 96       	adiw	r26, 0x01	; 1
    5d70:	8c 91       	ld	r24, X
    5d72:	11 97       	sbiw	r26, 0x01	; 1
    5d74:	86 83       	std	Z+6, r24	; 0x06
    5d76:	17 82       	std	Z+7, r1	; 0x07
    5d78:	12 96       	adiw	r26, 0x02	; 2
    5d7a:	8c 91       	ld	r24, X
    5d7c:	12 97       	sbiw	r26, 0x02	; 2
    5d7e:	80 87       	std	Z+8, r24	; 0x08
    5d80:	11 86       	std	Z+9, r1	; 0x09
    5d82:	13 96       	adiw	r26, 0x03	; 3
    5d84:	8c 91       	ld	r24, X
    5d86:	13 97       	sbiw	r26, 0x03	; 3
    5d88:	82 87       	std	Z+10, r24	; 0x0a
    5d8a:	13 86       	std	Z+11, r1	; 0x0b
    5d8c:	14 96       	adiw	r26, 0x04	; 4
    5d8e:	8c 91       	ld	r24, X
    5d90:	14 97       	sbiw	r26, 0x04	; 4
    5d92:	84 87       	std	Z+12, r24	; 0x0c
    5d94:	15 86       	std	Z+13, r1	; 0x0d
    5d96:	15 96       	adiw	r26, 0x05	; 5
    5d98:	8c 91       	ld	r24, X
    5d9a:	86 87       	std	Z+14, r24	; 0x0e
    5d9c:	17 86       	std	Z+15, r1	; 0x0f
    5d9e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5da2:	2d b7       	in	r18, 0x3d	; 61
    5da4:	3e b7       	in	r19, 0x3e	; 62
    5da6:	20 5f       	subi	r18, 0xF0	; 240
    5da8:	3f 4f       	sbci	r19, 0xFF	; 255
    5daa:	2d bf       	out	0x3d, r18	; 61
    5dac:	3e bf       	out	0x3e, r19	; 62
}
    5dae:	df 91       	pop	r29
    5db0:	cf 91       	pop	r28
    5db2:	08 95       	ret

00005db4 <netPrintIPAddr>:

void netPrintIPAddr(FILE *stream, uint32_t ipaddr)
{
    5db4:	df 93       	push	r29
    5db6:	cf 93       	push	r28
    5db8:	00 d0       	rcall	.+0      	; 0x5dba <netPrintIPAddr+0x6>
    5dba:	0f 92       	push	r0
    5dbc:	cd b7       	in	r28, 0x3d	; 61
    5dbe:	de b7       	in	r29, 0x3e	; 62
    5dc0:	49 83       	std	Y+1, r20	; 0x01
    5dc2:	5a 83       	std	Y+2, r21	; 0x02
    5dc4:	6b 83       	std	Y+3, r22	; 0x03
    5dc6:	7c 83       	std	Y+4, r23	; 0x04
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
    5dc8:	ae 01       	movw	r20, r28
    5dca:	4f 5f       	subi	r20, 0xFF	; 255
    5dcc:	5f 4f       	sbci	r21, 0xFF	; 255
    5dce:	2d b7       	in	r18, 0x3d	; 61
    5dd0:	3e b7       	in	r19, 0x3e	; 62
    5dd2:	2c 50       	subi	r18, 0x0C	; 12
    5dd4:	30 40       	sbci	r19, 0x00	; 0
    5dd6:	2d bf       	out	0x3d, r18	; 61
    5dd8:	3e bf       	out	0x3e, r19	; 62
    5dda:	ed b7       	in	r30, 0x3d	; 61
    5ddc:	fe b7       	in	r31, 0x3e	; 62
    5dde:	31 96       	adiw	r30, 0x01	; 1
    5de0:	ad b7       	in	r26, 0x3d	; 61
    5de2:	be b7       	in	r27, 0x3e	; 62
    5de4:	11 96       	adiw	r26, 0x01	; 1
    5de6:	8d 93       	st	X+, r24
    5de8:	9c 93       	st	X, r25
    5dea:	12 97       	sbiw	r26, 0x02	; 2
    5dec:	8f e1       	ldi	r24, 0x1F	; 31
    5dee:	9a e0       	ldi	r25, 0x0A	; 10
    5df0:	82 83       	std	Z+2, r24	; 0x02
    5df2:	93 83       	std	Z+3, r25	; 0x03
    5df4:	89 81       	ldd	r24, Y+1	; 0x01
    5df6:	84 83       	std	Z+4, r24	; 0x04
    5df8:	15 82       	std	Z+5, r1	; 0x05
    5dfa:	da 01       	movw	r26, r20
    5dfc:	11 96       	adiw	r26, 0x01	; 1
    5dfe:	8c 91       	ld	r24, X
    5e00:	11 97       	sbiw	r26, 0x01	; 1
    5e02:	86 83       	std	Z+6, r24	; 0x06
    5e04:	17 82       	std	Z+7, r1	; 0x07
    5e06:	12 96       	adiw	r26, 0x02	; 2
    5e08:	8c 91       	ld	r24, X
    5e0a:	12 97       	sbiw	r26, 0x02	; 2
    5e0c:	80 87       	std	Z+8, r24	; 0x08
    5e0e:	11 86       	std	Z+9, r1	; 0x09
    5e10:	13 96       	adiw	r26, 0x03	; 3
    5e12:	8c 91       	ld	r24, X
    5e14:	82 87       	std	Z+10, r24	; 0x0a
    5e16:	13 86       	std	Z+11, r1	; 0x0b
    5e18:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5e1c:	2d b7       	in	r18, 0x3d	; 61
    5e1e:	3e b7       	in	r19, 0x3e	; 62
    5e20:	24 5f       	subi	r18, 0xF4	; 244
    5e22:	3f 4f       	sbci	r19, 0xFF	; 255
    5e24:	2d bf       	out	0x3d, r18	; 61
    5e26:	3e bf       	out	0x3e, r19	; 62
}
    5e28:	24 96       	adiw	r28, 0x04	; 4
    5e2a:	cd bf       	out	0x3d, r28	; 61
    5e2c:	de bf       	out	0x3e, r29	; 62
    5e2e:	cf 91       	pop	r28
    5e30:	df 91       	pop	r29
    5e32:	08 95       	ret

00005e34 <netPrintEthHeader>:

void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
    5e34:	0f 93       	push	r16
    5e36:	1f 93       	push	r17
    5e38:	cf 93       	push	r28
    5e3a:	df 93       	push	r29
    5e3c:	ec 01       	movw	r28, r24
    5e3e:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
    5e40:	00 d0       	rcall	.+0      	; 0x5e42 <netPrintEthHeader+0xe>
    5e42:	00 d0       	rcall	.+0      	; 0x5e44 <netPrintEthHeader+0x10>
    5e44:	ed b7       	in	r30, 0x3d	; 61
    5e46:	fe b7       	in	r31, 0x3e	; 62
    5e48:	31 96       	adiw	r30, 0x01	; 1
    5e4a:	ad b7       	in	r26, 0x3d	; 61
    5e4c:	be b7       	in	r27, 0x3e	; 62
    5e4e:	11 96       	adiw	r26, 0x01	; 1
    5e50:	8d 93       	st	X+, r24
    5e52:	9c 93       	st	X, r25
    5e54:	12 97       	sbiw	r26, 0x02	; 2
    5e56:	89 e0       	ldi	r24, 0x09	; 9
    5e58:	9a e0       	ldi	r25, 0x0A	; 10
    5e5a:	82 83       	std	Z+2, r24	; 0x02
    5e5c:	93 83       	std	Z+3, r25	; 0x03
    5e5e:	db 01       	movw	r26, r22
    5e60:	1c 96       	adiw	r26, 0x0c	; 12
    5e62:	8d 91       	ld	r24, X+
    5e64:	9c 91       	ld	r25, X
    5e66:	1d 97       	sbiw	r26, 0x0d	; 13
    5e68:	84 83       	std	Z+4, r24	; 0x04
    5e6a:	95 83       	std	Z+5, r25	; 0x05
    5e6c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR(" SRC:"));
    5e70:	0f 90       	pop	r0
    5e72:	0f 90       	pop	r0
    5e74:	ed b7       	in	r30, 0x3d	; 61
    5e76:	fe b7       	in	r31, 0x3e	; 62
    5e78:	c1 83       	std	Z+1, r28	; 0x01
    5e7a:	d2 83       	std	Z+2, r29	; 0x02
    5e7c:	83 e0       	ldi	r24, 0x03	; 3
    5e7e:	9a e0       	ldi	r25, 0x0A	; 10
    5e80:	83 83       	std	Z+3, r24	; 0x03
    5e82:	94 83       	std	Z+4, r25	; 0x04
    5e84:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->src);
    5e88:	0f 90       	pop	r0
    5e8a:	0f 90       	pop	r0
    5e8c:	0f 90       	pop	r0
    5e8e:	0f 90       	pop	r0
    5e90:	b8 01       	movw	r22, r16
    5e92:	6a 5f       	subi	r22, 0xFA	; 250
    5e94:	7f 4f       	sbci	r23, 0xFF	; 255
    5e96:	ce 01       	movw	r24, r28
    5e98:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
  fprintf_P(stream, PSTR("->DST:"));
    5e9c:	00 d0       	rcall	.+0      	; 0x5e9e <netPrintEthHeader+0x6a>
    5e9e:	0f 92       	push	r0
    5ea0:	ad b7       	in	r26, 0x3d	; 61
    5ea2:	be b7       	in	r27, 0x3e	; 62
    5ea4:	11 96       	adiw	r26, 0x01	; 1
    5ea6:	cd 93       	st	X+, r28
    5ea8:	dc 93       	st	X, r29
    5eaa:	12 97       	sbiw	r26, 0x02	; 2
    5eac:	8c ef       	ldi	r24, 0xFC	; 252
    5eae:	99 e0       	ldi	r25, 0x09	; 9
    5eb0:	13 96       	adiw	r26, 0x03	; 3
    5eb2:	8d 93       	st	X+, r24
    5eb4:	9c 93       	st	X, r25
    5eb6:	14 97       	sbiw	r26, 0x04	; 4
    5eb8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->dest);
    5ebc:	0f 90       	pop	r0
    5ebe:	0f 90       	pop	r0
    5ec0:	0f 90       	pop	r0
    5ec2:	0f 90       	pop	r0
    5ec4:	ce 01       	movw	r24, r28
    5ec6:	b8 01       	movw	r22, r16
    5ec8:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
}
    5ecc:	df 91       	pop	r29
    5ece:	cf 91       	pop	r28
    5ed0:	1f 91       	pop	r17
    5ed2:	0f 91       	pop	r16
    5ed4:	08 95       	ret

00005ed6 <netPrintIpHeader>:

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
    5ed6:	0f 93       	push	r16
    5ed8:	1f 93       	push	r17
    5eda:	cf 93       	push	r28
    5edc:	df 93       	push	r29
    5ede:	ec 01       	movw	r28, r24
    5ee0:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Header\r\n"));
    5ee2:	00 d0       	rcall	.+0      	; 0x5ee4 <netPrintIpHeader+0xe>
    5ee4:	0f 92       	push	r0
    5ee6:	ad b7       	in	r26, 0x3d	; 61
    5ee8:	be b7       	in	r27, 0x3e	; 62
    5eea:	11 96       	adiw	r26, 0x01	; 1
    5eec:	8d 93       	st	X+, r24
    5eee:	9c 93       	st	X, r25
    5ef0:	12 97       	sbiw	r26, 0x02	; 2
    5ef2:	80 ef       	ldi	r24, 0xF0	; 240
    5ef4:	99 e0       	ldi	r25, 0x09	; 9
    5ef6:	13 96       	adiw	r26, 0x03	; 3
    5ef8:	8d 93       	st	X+, r24
    5efa:	9c 93       	st	X, r25
    5efc:	14 97       	sbiw	r26, 0x04	; 4
    5efe:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
    5f02:	0f 92       	push	r0
    5f04:	0f 92       	push	r0
    5f06:	ed b7       	in	r30, 0x3d	; 61
    5f08:	fe b7       	in	r31, 0x3e	; 62
    5f0a:	31 96       	adiw	r30, 0x01	; 1
    5f0c:	ad b7       	in	r26, 0x3d	; 61
    5f0e:	be b7       	in	r27, 0x3e	; 62
    5f10:	11 96       	adiw	r26, 0x01	; 1
    5f12:	cd 93       	st	X+, r28
    5f14:	dc 93       	st	X, r29
    5f16:	12 97       	sbiw	r26, 0x02	; 2
    5f18:	81 ee       	ldi	r24, 0xE1	; 225
    5f1a:	99 e0       	ldi	r25, 0x09	; 9
    5f1c:	82 83       	std	Z+2, r24	; 0x02
    5f1e:	93 83       	std	Z+3, r25	; 0x03
    5f20:	d8 01       	movw	r26, r16
    5f22:	8c 91       	ld	r24, X
    5f24:	82 95       	swap	r24
    5f26:	8f 70       	andi	r24, 0x0F	; 15
    5f28:	84 83       	std	Z+4, r24	; 0x04
    5f2a:	15 82       	std	Z+5, r1	; 0x05
    5f2c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5f30:	ed b7       	in	r30, 0x3d	; 61
    5f32:	fe b7       	in	r31, 0x3e	; 62
    5f34:	31 96       	adiw	r30, 0x01	; 1
    5f36:	ad b7       	in	r26, 0x3d	; 61
    5f38:	be b7       	in	r27, 0x3e	; 62
    5f3a:	11 96       	adiw	r26, 0x01	; 1
    5f3c:	cd 93       	st	X+, r28
    5f3e:	dc 93       	st	X, r29
    5f40:	12 97       	sbiw	r26, 0x02	; 2
    5f42:	82 ed       	ldi	r24, 0xD2	; 210
    5f44:	99 e0       	ldi	r25, 0x09	; 9
    5f46:	82 83       	std	Z+2, r24	; 0x02
    5f48:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5f4a:	d8 01       	movw	r26, r16
    5f4c:	12 96       	adiw	r26, 0x02	; 2
    5f4e:	8d 91       	ld	r24, X+
    5f50:	9c 91       	ld	r25, X
    5f52:	13 97       	sbiw	r26, 0x03	; 3
    5f54:	98 27       	eor	r25, r24
    5f56:	89 27       	eor	r24, r25
    5f58:	98 27       	eor	r25, r24

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
  fprintf_P(stream, PSTR("IP Header\r\n"));
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5f5a:	84 83       	std	Z+4, r24	; 0x04
    5f5c:	95 83       	std	Z+5, r25	; 0x05
    5f5e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  if(ipheader->proto == IP_PROTO_ICMP)
    5f62:	f8 01       	movw	r30, r16
    5f64:	21 85       	ldd	r18, Z+9	; 0x09
    5f66:	8d b7       	in	r24, 0x3d	; 61
    5f68:	9e b7       	in	r25, 0x3e	; 62
    5f6a:	06 96       	adiw	r24, 0x06	; 6
    5f6c:	8d bf       	out	0x3d, r24	; 61
    5f6e:	9e bf       	out	0x3e, r25	; 62
    5f70:	21 30       	cpi	r18, 0x01	; 1
    5f72:	59 f4       	brne	.+22     	; 0x5f8a <netPrintIpHeader+0xb4>
    fprintf_P(stream, PSTR("Protocol: ICMP\r\n"));
    5f74:	00 d0       	rcall	.+0      	; 0x5f76 <netPrintIpHeader+0xa0>
    5f76:	0f 92       	push	r0
    5f78:	ad b7       	in	r26, 0x3d	; 61
    5f7a:	be b7       	in	r27, 0x3e	; 62
    5f7c:	11 96       	adiw	r26, 0x01	; 1
    5f7e:	cd 93       	st	X+, r28
    5f80:	dc 93       	st	X, r29
    5f82:	12 97       	sbiw	r26, 0x02	; 2
    5f84:	81 ec       	ldi	r24, 0xC1	; 193
    5f86:	99 e0       	ldi	r25, 0x09	; 9
    5f88:	1f c0       	rjmp	.+62     	; 0x5fc8 <netPrintIpHeader+0xf2>
  else if(ipheader->proto == IP_PROTO_TCP)
    5f8a:	26 30       	cpi	r18, 0x06	; 6
    5f8c:	89 f4       	brne	.+34     	; 0x5fb0 <netPrintIpHeader+0xda>
    fprintf_P(stream, PSTR("Protocol: TCP\r\n"));
    5f8e:	00 d0       	rcall	.+0      	; 0x5f90 <netPrintIpHeader+0xba>
    5f90:	0f 92       	push	r0
    5f92:	ed b7       	in	r30, 0x3d	; 61
    5f94:	fe b7       	in	r31, 0x3e	; 62
    5f96:	c1 83       	std	Z+1, r28	; 0x01
    5f98:	d2 83       	std	Z+2, r29	; 0x02
    5f9a:	81 eb       	ldi	r24, 0xB1	; 177
    5f9c:	99 e0       	ldi	r25, 0x09	; 9
    5f9e:	83 83       	std	Z+3, r24	; 0x03
    5fa0:	94 83       	std	Z+4, r25	; 0x04
    5fa2:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5fa6:	0f 90       	pop	r0
    5fa8:	0f 90       	pop	r0
    5faa:	0f 90       	pop	r0
    5fac:	0f 90       	pop	r0
    5fae:	29 c0       	rjmp	.+82     	; 0x6002 <netPrintIpHeader+0x12c>
  else if(ipheader->proto == IP_PROTO_UDP)
    5fb0:	21 31       	cpi	r18, 0x11	; 17
    5fb2:	79 f4       	brne	.+30     	; 0x5fd2 <netPrintIpHeader+0xfc>
    fprintf_P(stream, PSTR("Protocol: UDP\r\n"));
    5fb4:	00 d0       	rcall	.+0      	; 0x5fb6 <netPrintIpHeader+0xe0>
    5fb6:	0f 92       	push	r0
    5fb8:	ad b7       	in	r26, 0x3d	; 61
    5fba:	be b7       	in	r27, 0x3e	; 62
    5fbc:	11 96       	adiw	r26, 0x01	; 1
    5fbe:	cd 93       	st	X+, r28
    5fc0:	dc 93       	st	X, r29
    5fc2:	12 97       	sbiw	r26, 0x02	; 2
    5fc4:	81 ea       	ldi	r24, 0xA1	; 161
    5fc6:	99 e0       	ldi	r25, 0x09	; 9
    5fc8:	13 96       	adiw	r26, 0x03	; 3
    5fca:	8d 93       	st	X+, r24
    5fcc:	9c 93       	st	X, r25
    5fce:	14 97       	sbiw	r26, 0x04	; 4
    5fd0:	e8 cf       	rjmp	.-48     	; 0x5fa2 <netPrintIpHeader+0xcc>
  else
    fprintf_P(stream, PSTR("Protocol: %d\r\n"), ipheader->proto);
    5fd2:	00 d0       	rcall	.+0      	; 0x5fd4 <netPrintIpHeader+0xfe>
    5fd4:	00 d0       	rcall	.+0      	; 0x5fd6 <netPrintIpHeader+0x100>
    5fd6:	ed b7       	in	r30, 0x3d	; 61
    5fd8:	fe b7       	in	r31, 0x3e	; 62
    5fda:	31 96       	adiw	r30, 0x01	; 1
    5fdc:	ad b7       	in	r26, 0x3d	; 61
    5fde:	be b7       	in	r27, 0x3e	; 62
    5fe0:	11 96       	adiw	r26, 0x01	; 1
    5fe2:	cd 93       	st	X+, r28
    5fe4:	dc 93       	st	X, r29
    5fe6:	12 97       	sbiw	r26, 0x02	; 2
    5fe8:	82 e9       	ldi	r24, 0x92	; 146
    5fea:	99 e0       	ldi	r25, 0x09	; 9
    5fec:	82 83       	std	Z+2, r24	; 0x02
    5fee:	93 83       	std	Z+3, r25	; 0x03
    5ff0:	24 83       	std	Z+4, r18	; 0x04
    5ff2:	15 82       	std	Z+5, r1	; 0x05
    5ff4:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    5ff8:	ed b7       	in	r30, 0x3d	; 61
    5ffa:	fe b7       	in	r31, 0x3e	; 62
    5ffc:	36 96       	adiw	r30, 0x06	; 6
    5ffe:	ed bf       	out	0x3d, r30	; 61
    6000:	fe bf       	out	0x3e, r31	; 62

  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
    6002:	00 d0       	rcall	.+0      	; 0x6004 <netPrintIpHeader+0x12e>
    6004:	0f 92       	push	r0
    6006:	ad b7       	in	r26, 0x3d	; 61
    6008:	be b7       	in	r27, 0x3e	; 62
    600a:	11 96       	adiw	r26, 0x01	; 1
    600c:	cd 93       	st	X+, r28
    600e:	dc 93       	st	X, r29
    6010:	12 97       	sbiw	r26, 0x02	; 2
    6012:	87 e8       	ldi	r24, 0x87	; 135
    6014:	99 e0       	ldi	r25, 0x09	; 9
    6016:	13 96       	adiw	r26, 0x03	; 3
    6018:	8d 93       	st	X+, r24
    601a:	9c 93       	st	X, r25
    601c:	14 97       	sbiw	r26, 0x04	; 4
    601e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6022:	0f 90       	pop	r0
    6024:	0f 90       	pop	r0
    6026:	0f 90       	pop	r0
    6028:	0f 90       	pop	r0
    602a:	f8 01       	movw	r30, r16
    602c:	64 85       	ldd	r22, Z+12	; 0x0c
    602e:	75 85       	ldd	r23, Z+13	; 0x0d
    6030:	86 85       	ldd	r24, Z+14	; 0x0e
    6032:	97 85       	ldd	r25, Z+15	; 0x0f
    6034:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <htonl>
    6038:	ab 01       	movw	r20, r22
    603a:	bc 01       	movw	r22, r24
    603c:	ce 01       	movw	r24, r28
    603e:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    6042:	00 d0       	rcall	.+0      	; 0x6044 <netPrintIpHeader+0x16e>
    6044:	0f 92       	push	r0
    6046:	ad b7       	in	r26, 0x3d	; 61
    6048:	be b7       	in	r27, 0x3e	; 62
    604a:	11 96       	adiw	r26, 0x01	; 1
    604c:	cd 93       	st	X+, r28
    604e:	dc 93       	st	X, r29
    6050:	12 97       	sbiw	r26, 0x02	; 2
    6052:	84 e8       	ldi	r24, 0x84	; 132
    6054:	99 e0       	ldi	r25, 0x09	; 9
    6056:	13 96       	adiw	r26, 0x03	; 3
    6058:	8d 93       	st	X+, r24
    605a:	9c 93       	st	X, r25
    605c:	14 97       	sbiw	r26, 0x04	; 4
    605e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
    6062:	ed b7       	in	r30, 0x3d	; 61
    6064:	fe b7       	in	r31, 0x3e	; 62
    6066:	c1 83       	std	Z+1, r28	; 0x01
    6068:	d2 83       	std	Z+2, r29	; 0x02
    606a:	89 e7       	ldi	r24, 0x79	; 121
    606c:	99 e0       	ldi	r25, 0x09	; 9
    606e:	83 83       	std	Z+3, r24	; 0x03
    6070:	94 83       	std	Z+4, r25	; 0x04
    6072:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6076:	0f 90       	pop	r0
    6078:	0f 90       	pop	r0
    607a:	0f 90       	pop	r0
    607c:	0f 90       	pop	r0
    607e:	d8 01       	movw	r26, r16
    6080:	50 96       	adiw	r26, 0x10	; 16
    6082:	6d 91       	ld	r22, X+
    6084:	7d 91       	ld	r23, X+
    6086:	8d 91       	ld	r24, X+
    6088:	9c 91       	ld	r25, X
    608a:	53 97       	sbiw	r26, 0x13	; 19
    608c:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <htonl>
    6090:	ab 01       	movw	r20, r22
    6092:	bc 01       	movw	r22, r24
    6094:	ce 01       	movw	r24, r28
    6096:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    609a:	00 d0       	rcall	.+0      	; 0x609c <netPrintIpHeader+0x1c6>
    609c:	0f 92       	push	r0
    609e:	ed b7       	in	r30, 0x3d	; 61
    60a0:	fe b7       	in	r31, 0x3e	; 62
    60a2:	c1 83       	std	Z+1, r28	; 0x01
    60a4:	d2 83       	std	Z+2, r29	; 0x02
    60a6:	86 e7       	ldi	r24, 0x76	; 118
    60a8:	99 e0       	ldi	r25, 0x09	; 9
    60aa:	83 83       	std	Z+3, r24	; 0x03
    60ac:	94 83       	std	Z+4, r25	; 0x04
    60ae:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    60b2:	0f 90       	pop	r0
    60b4:	0f 90       	pop	r0
    60b6:	0f 90       	pop	r0
    60b8:	0f 90       	pop	r0
}
    60ba:	df 91       	pop	r29
    60bc:	cf 91       	pop	r28
    60be:	1f 91       	pop	r17
    60c0:	0f 91       	pop	r16
    60c2:	08 95       	ret

000060c4 <netPrintTcpHeader>:

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
    60c4:	0f 93       	push	r16
    60c6:	1f 93       	push	r17
    60c8:	cf 93       	push	r28
    60ca:	df 93       	push	r29
    60cc:	ec 01       	movw	r28, r24
    60ce:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("TCP Header\r\n"));
    60d0:	00 d0       	rcall	.+0      	; 0x60d2 <netPrintTcpHeader+0xe>
    60d2:	0f 92       	push	r0
    60d4:	ad b7       	in	r26, 0x3d	; 61
    60d6:	be b7       	in	r27, 0x3e	; 62
    60d8:	11 96       	adiw	r26, 0x01	; 1
    60da:	8d 93       	st	X+, r24
    60dc:	9c 93       	st	X, r25
    60de:	12 97       	sbiw	r26, 0x02	; 2
    60e0:	89 e6       	ldi	r24, 0x69	; 105
    60e2:	99 e0       	ldi	r25, 0x09	; 9
    60e4:	13 96       	adiw	r26, 0x03	; 3
    60e6:	8d 93       	st	X+, r24
    60e8:	9c 93       	st	X, r25
    60ea:	14 97       	sbiw	r26, 0x04	; 4
    60ec:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    60f0:	0f 92       	push	r0
    60f2:	0f 92       	push	r0
    60f4:	ed b7       	in	r30, 0x3d	; 61
    60f6:	fe b7       	in	r31, 0x3e	; 62
    60f8:	31 96       	adiw	r30, 0x01	; 1
    60fa:	ad b7       	in	r26, 0x3d	; 61
    60fc:	be b7       	in	r27, 0x3e	; 62
    60fe:	11 96       	adiw	r26, 0x01	; 1
    6100:	cd 93       	st	X+, r28
    6102:	dc 93       	st	X, r29
    6104:	12 97       	sbiw	r26, 0x02	; 2
    6106:	8a e5       	ldi	r24, 0x5A	; 90
    6108:	99 e0       	ldi	r25, 0x09	; 9
    610a:	82 83       	std	Z+2, r24	; 0x02
    610c:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    610e:	d8 01       	movw	r26, r16
    6110:	8d 91       	ld	r24, X+
    6112:	9c 91       	ld	r25, X
    6114:	98 27       	eor	r25, r24
    6116:	89 27       	eor	r24, r25
    6118:	98 27       	eor	r25, r24
}

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    611a:	84 83       	std	Z+4, r24	; 0x04
    611c:	95 83       	std	Z+5, r25	; 0x05
    611e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    6122:	ed b7       	in	r30, 0x3d	; 61
    6124:	fe b7       	in	r31, 0x3e	; 62
    6126:	31 96       	adiw	r30, 0x01	; 1
    6128:	ad b7       	in	r26, 0x3d	; 61
    612a:	be b7       	in	r27, 0x3e	; 62
    612c:	11 96       	adiw	r26, 0x01	; 1
    612e:	cd 93       	st	X+, r28
    6130:	dc 93       	st	X, r29
    6132:	12 97       	sbiw	r26, 0x02	; 2
    6134:	8b e4       	ldi	r24, 0x4B	; 75
    6136:	99 e0       	ldi	r25, 0x09	; 9
    6138:	82 83       	std	Z+2, r24	; 0x02
    613a:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    613c:	d8 01       	movw	r26, r16
    613e:	12 96       	adiw	r26, 0x02	; 2
    6140:	8d 91       	ld	r24, X+
    6142:	9c 91       	ld	r25, X
    6144:	13 97       	sbiw	r26, 0x03	; 3
    6146:	98 27       	eor	r25, r24
    6148:	89 27       	eor	r24, r25
    614a:	98 27       	eor	r25, r24

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    614c:	84 83       	std	Z+4, r24	; 0x04
    614e:	95 83       	std	Z+5, r25	; 0x05
    6150:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Seq Num : 0x%x"), htonl(tcpheader->seqno));
    6154:	ed b7       	in	r30, 0x3d	; 61
    6156:	fe b7       	in	r31, 0x3e	; 62
    6158:	36 96       	adiw	r30, 0x06	; 6
    615a:	ed bf       	out	0x3d, r30	; 61
    615c:	fe bf       	out	0x3e, r31	; 62
    615e:	d8 01       	movw	r26, r16
    6160:	14 96       	adiw	r26, 0x04	; 4
    6162:	6d 91       	ld	r22, X+
    6164:	7d 91       	ld	r23, X+
    6166:	8d 91       	ld	r24, X+
    6168:	9c 91       	ld	r25, X
    616a:	17 97       	sbiw	r26, 0x07	; 7
    616c:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <htonl>
    6170:	ed b7       	in	r30, 0x3d	; 61
    6172:	fe b7       	in	r31, 0x3e	; 62
    6174:	38 97       	sbiw	r30, 0x08	; 8
    6176:	ed bf       	out	0x3d, r30	; 61
    6178:	fe bf       	out	0x3e, r31	; 62
    617a:	31 96       	adiw	r30, 0x01	; 1
    617c:	ad b7       	in	r26, 0x3d	; 61
    617e:	be b7       	in	r27, 0x3e	; 62
    6180:	11 96       	adiw	r26, 0x01	; 1
    6182:	cd 93       	st	X+, r28
    6184:	dc 93       	st	X, r29
    6186:	12 97       	sbiw	r26, 0x02	; 2
    6188:	2c e3       	ldi	r18, 0x3C	; 60
    618a:	39 e0       	ldi	r19, 0x09	; 9
    618c:	22 83       	std	Z+2, r18	; 0x02
    618e:	33 83       	std	Z+3, r19	; 0x03
    6190:	64 83       	std	Z+4, r22	; 0x04
    6192:	75 83       	std	Z+5, r23	; 0x05
    6194:	86 83       	std	Z+6, r24	; 0x06
    6196:	97 83       	std	Z+7, r25	; 0x07
    6198:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Ack Num : 0x%x\r\n"), htonl(tcpheader->ackno));
    619c:	ed b7       	in	r30, 0x3d	; 61
    619e:	fe b7       	in	r31, 0x3e	; 62
    61a0:	38 96       	adiw	r30, 0x08	; 8
    61a2:	ed bf       	out	0x3d, r30	; 61
    61a4:	fe bf       	out	0x3e, r31	; 62
    61a6:	d8 01       	movw	r26, r16
    61a8:	18 96       	adiw	r26, 0x08	; 8
    61aa:	6d 91       	ld	r22, X+
    61ac:	7d 91       	ld	r23, X+
    61ae:	8d 91       	ld	r24, X+
    61b0:	9c 91       	ld	r25, X
    61b2:	1b 97       	sbiw	r26, 0x0b	; 11
    61b4:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <htonl>
    61b8:	ed b7       	in	r30, 0x3d	; 61
    61ba:	fe b7       	in	r31, 0x3e	; 62
    61bc:	38 97       	sbiw	r30, 0x08	; 8
    61be:	ed bf       	out	0x3d, r30	; 61
    61c0:	fe bf       	out	0x3e, r31	; 62
    61c2:	31 96       	adiw	r30, 0x01	; 1
    61c4:	ad b7       	in	r26, 0x3d	; 61
    61c6:	be b7       	in	r27, 0x3e	; 62
    61c8:	11 96       	adiw	r26, 0x01	; 1
    61ca:	cd 93       	st	X+, r28
    61cc:	dc 93       	st	X, r29
    61ce:	12 97       	sbiw	r26, 0x02	; 2
    61d0:	2b e2       	ldi	r18, 0x2B	; 43
    61d2:	39 e0       	ldi	r19, 0x09	; 9
    61d4:	22 83       	std	Z+2, r18	; 0x02
    61d6:	33 83       	std	Z+3, r19	; 0x03
    61d8:	64 83       	std	Z+4, r22	; 0x04
    61da:	75 83       	std	Z+5, r23	; 0x05
    61dc:	86 83       	std	Z+6, r24	; 0x06
    61de:	97 83       	std	Z+7, r25	; 0x07
    61e0:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Flags   : "));
    61e4:	0f 90       	pop	r0
    61e6:	0f 90       	pop	r0
    61e8:	0f 90       	pop	r0
    61ea:	0f 90       	pop	r0
    61ec:	ed b7       	in	r30, 0x3d	; 61
    61ee:	fe b7       	in	r31, 0x3e	; 62
    61f0:	c1 83       	std	Z+1, r28	; 0x01
    61f2:	d2 83       	std	Z+2, r29	; 0x02
    61f4:	80 e2       	ldi	r24, 0x20	; 32
    61f6:	99 e0       	ldi	r25, 0x09	; 9
    61f8:	83 83       	std	Z+3, r24	; 0x03
    61fa:	94 83       	std	Z+4, r25	; 0x04
    61fc:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  if(tcpheader->flags & TCP_FLAGS_FIN)
    6200:	d8 01       	movw	r26, r16
    6202:	1d 96       	adiw	r26, 0x0d	; 13
    6204:	8c 91       	ld	r24, X
    6206:	1d 97       	sbiw	r26, 0x0d	; 13
    6208:	0f 90       	pop	r0
    620a:	0f 90       	pop	r0
    620c:	0f 90       	pop	r0
    620e:	0f 90       	pop	r0
    6210:	80 ff       	sbrs	r24, 0
    6212:	10 c0       	rjmp	.+32     	; 0x6234 <netPrintTcpHeader+0x170>
    fprintf_P(stream, PSTR("FIN "));
    6214:	00 d0       	rcall	.+0      	; 0x6216 <netPrintTcpHeader+0x152>
    6216:	0f 92       	push	r0
    6218:	ed b7       	in	r30, 0x3d	; 61
    621a:	fe b7       	in	r31, 0x3e	; 62
    621c:	c1 83       	std	Z+1, r28	; 0x01
    621e:	d2 83       	std	Z+2, r29	; 0x02
    6220:	8b e1       	ldi	r24, 0x1B	; 27
    6222:	99 e0       	ldi	r25, 0x09	; 9
    6224:	83 83       	std	Z+3, r24	; 0x03
    6226:	94 83       	std	Z+4, r25	; 0x04
    6228:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    622c:	0f 90       	pop	r0
    622e:	0f 90       	pop	r0
    6230:	0f 90       	pop	r0
    6232:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_SYN)
    6234:	d8 01       	movw	r26, r16
    6236:	1d 96       	adiw	r26, 0x0d	; 13
    6238:	8c 91       	ld	r24, X
    623a:	1d 97       	sbiw	r26, 0x0d	; 13
    623c:	81 ff       	sbrs	r24, 1
    623e:	10 c0       	rjmp	.+32     	; 0x6260 <netPrintTcpHeader+0x19c>
    fprintf_P(stream, PSTR("SYN "));
    6240:	00 d0       	rcall	.+0      	; 0x6242 <netPrintTcpHeader+0x17e>
    6242:	0f 92       	push	r0
    6244:	ed b7       	in	r30, 0x3d	; 61
    6246:	fe b7       	in	r31, 0x3e	; 62
    6248:	c1 83       	std	Z+1, r28	; 0x01
    624a:	d2 83       	std	Z+2, r29	; 0x02
    624c:	86 e1       	ldi	r24, 0x16	; 22
    624e:	99 e0       	ldi	r25, 0x09	; 9
    6250:	83 83       	std	Z+3, r24	; 0x03
    6252:	94 83       	std	Z+4, r25	; 0x04
    6254:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6258:	0f 90       	pop	r0
    625a:	0f 90       	pop	r0
    625c:	0f 90       	pop	r0
    625e:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_RST)
    6260:	d8 01       	movw	r26, r16
    6262:	1d 96       	adiw	r26, 0x0d	; 13
    6264:	8c 91       	ld	r24, X
    6266:	1d 97       	sbiw	r26, 0x0d	; 13
    6268:	82 ff       	sbrs	r24, 2
    626a:	10 c0       	rjmp	.+32     	; 0x628c <netPrintTcpHeader+0x1c8>
    fprintf_P(stream, PSTR("RST "));
    626c:	00 d0       	rcall	.+0      	; 0x626e <netPrintTcpHeader+0x1aa>
    626e:	0f 92       	push	r0
    6270:	ed b7       	in	r30, 0x3d	; 61
    6272:	fe b7       	in	r31, 0x3e	; 62
    6274:	c1 83       	std	Z+1, r28	; 0x01
    6276:	d2 83       	std	Z+2, r29	; 0x02
    6278:	81 e1       	ldi	r24, 0x11	; 17
    627a:	99 e0       	ldi	r25, 0x09	; 9
    627c:	83 83       	std	Z+3, r24	; 0x03
    627e:	94 83       	std	Z+4, r25	; 0x04
    6280:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6284:	0f 90       	pop	r0
    6286:	0f 90       	pop	r0
    6288:	0f 90       	pop	r0
    628a:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_PSH)
    628c:	d8 01       	movw	r26, r16
    628e:	1d 96       	adiw	r26, 0x0d	; 13
    6290:	8c 91       	ld	r24, X
    6292:	1d 97       	sbiw	r26, 0x0d	; 13
    6294:	83 ff       	sbrs	r24, 3
    6296:	10 c0       	rjmp	.+32     	; 0x62b8 <netPrintTcpHeader+0x1f4>
    fprintf_P(stream, PSTR("PSH "));
    6298:	00 d0       	rcall	.+0      	; 0x629a <netPrintTcpHeader+0x1d6>
    629a:	0f 92       	push	r0
    629c:	ed b7       	in	r30, 0x3d	; 61
    629e:	fe b7       	in	r31, 0x3e	; 62
    62a0:	c1 83       	std	Z+1, r28	; 0x01
    62a2:	d2 83       	std	Z+2, r29	; 0x02
    62a4:	8c e0       	ldi	r24, 0x0C	; 12
    62a6:	99 e0       	ldi	r25, 0x09	; 9
    62a8:	83 83       	std	Z+3, r24	; 0x03
    62aa:	94 83       	std	Z+4, r25	; 0x04
    62ac:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    62b0:	0f 90       	pop	r0
    62b2:	0f 90       	pop	r0
    62b4:	0f 90       	pop	r0
    62b6:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_ACK)
    62b8:	d8 01       	movw	r26, r16
    62ba:	1d 96       	adiw	r26, 0x0d	; 13
    62bc:	8c 91       	ld	r24, X
    62be:	1d 97       	sbiw	r26, 0x0d	; 13
    62c0:	84 ff       	sbrs	r24, 4
    62c2:	10 c0       	rjmp	.+32     	; 0x62e4 <netPrintTcpHeader+0x220>
    fprintf_P(stream, PSTR("ACK "));
    62c4:	00 d0       	rcall	.+0      	; 0x62c6 <netPrintTcpHeader+0x202>
    62c6:	0f 92       	push	r0
    62c8:	ed b7       	in	r30, 0x3d	; 61
    62ca:	fe b7       	in	r31, 0x3e	; 62
    62cc:	c1 83       	std	Z+1, r28	; 0x01
    62ce:	d2 83       	std	Z+2, r29	; 0x02
    62d0:	87 e0       	ldi	r24, 0x07	; 7
    62d2:	99 e0       	ldi	r25, 0x09	; 9
    62d4:	83 83       	std	Z+3, r24	; 0x03
    62d6:	94 83       	std	Z+4, r25	; 0x04
    62d8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    62dc:	0f 90       	pop	r0
    62de:	0f 90       	pop	r0
    62e0:	0f 90       	pop	r0
    62e2:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_URG)
    62e4:	d8 01       	movw	r26, r16
    62e6:	1d 96       	adiw	r26, 0x0d	; 13
    62e8:	8c 91       	ld	r24, X
    62ea:	1d 97       	sbiw	r26, 0x0d	; 13
    62ec:	85 ff       	sbrs	r24, 5
    62ee:	10 c0       	rjmp	.+32     	; 0x6310 <netPrintTcpHeader+0x24c>
    fprintf_P(stream, PSTR("URG "));
    62f0:	00 d0       	rcall	.+0      	; 0x62f2 <netPrintTcpHeader+0x22e>
    62f2:	0f 92       	push	r0
    62f4:	ed b7       	in	r30, 0x3d	; 61
    62f6:	fe b7       	in	r31, 0x3e	; 62
    62f8:	c1 83       	std	Z+1, r28	; 0x01
    62fa:	d2 83       	std	Z+2, r29	; 0x02
    62fc:	82 e0       	ldi	r24, 0x02	; 2
    62fe:	99 e0       	ldi	r25, 0x09	; 9
    6300:	83 83       	std	Z+3, r24	; 0x03
    6302:	94 83       	std	Z+4, r25	; 0x04
    6304:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6308:	0f 90       	pop	r0
    630a:	0f 90       	pop	r0
    630c:	0f 90       	pop	r0
    630e:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    6310:	00 d0       	rcall	.+0      	; 0x6312 <netPrintTcpHeader+0x24e>
    6312:	0f 92       	push	r0
    6314:	ad b7       	in	r26, 0x3d	; 61
    6316:	be b7       	in	r27, 0x3e	; 62
    6318:	11 96       	adiw	r26, 0x01	; 1
    631a:	cd 93       	st	X+, r28
    631c:	dc 93       	st	X, r29
    631e:	12 97       	sbiw	r26, 0x02	; 2
    6320:	8f ef       	ldi	r24, 0xFF	; 255
    6322:	98 e0       	ldi	r25, 0x08	; 8
    6324:	13 96       	adiw	r26, 0x03	; 3
    6326:	8d 93       	st	X+, r24
    6328:	9c 93       	st	X, r25
    632a:	14 97       	sbiw	r26, 0x04	; 4
    632c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6330:	0f 90       	pop	r0
    6332:	0f 90       	pop	r0
    6334:	0f 90       	pop	r0
    6336:	0f 90       	pop	r0
}
    6338:	df 91       	pop	r29
    633a:	cf 91       	pop	r28
    633c:	1f 91       	pop	r17
    633e:	0f 91       	pop	r16
    6340:	08 95       	ret

00006342 <ipInit>:
static uint32_t mask_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_MASK4 << 24) + ((uint32_t)MY_MASK3 <<16) + ((uint32_t)MY_MASK2 <<8) + MY_MASK1;
static uint32_t defGw_eep   __attribute__((section (".eeprom"))) = ((uint32_t)MY_GW4   << 24) + ((uint32_t)MY_GW3   <<16) + ((uint32_t)MY_GW2   <<8) + MY_GW1;

void ipInit(void)
{
  IpMyConfig.ip      = eeprom_read_dword(&myip_eep);
    6342:	8e e1       	ldi	r24, 0x1E	; 30
    6344:	90 e0       	ldi	r25, 0x00	; 0
    6346:	0e 94 27 5a 	call	0xb44e	; 0xb44e <__eerd_dword_x128a1>
    634a:	60 93 b0 32 	sts	0x32B0, r22
    634e:	70 93 b1 32 	sts	0x32B1, r23
    6352:	80 93 b2 32 	sts	0x32B2, r24
    6356:	90 93 b3 32 	sts	0x32B3, r25
  IpMyConfig.netmask = eeprom_read_dword(&mask_eep);
    635a:	82 e2       	ldi	r24, 0x22	; 34
    635c:	90 e0       	ldi	r25, 0x00	; 0
    635e:	0e 94 27 5a 	call	0xb44e	; 0xb44e <__eerd_dword_x128a1>
    6362:	60 93 b4 32 	sts	0x32B4, r22
    6366:	70 93 b5 32 	sts	0x32B5, r23
    636a:	80 93 b6 32 	sts	0x32B6, r24
    636e:	90 93 b7 32 	sts	0x32B7, r25
  IpMyConfig.gateway = eeprom_read_dword(&defGw_eep);
    6372:	86 e2       	ldi	r24, 0x26	; 38
    6374:	90 e0       	ldi	r25, 0x00	; 0
    6376:	0e 94 27 5a 	call	0xb44e	; 0xb44e <__eerd_dword_x128a1>
    637a:	60 93 b8 32 	sts	0x32B8, r22
    637e:	70 93 b9 32 	sts	0x32B9, r23
    6382:	80 93 ba 32 	sts	0x32BA, r24
    6386:	90 93 bb 32 	sts	0x32BB, r25
#if IP_DEBUG
  IpMyConfig.dbgLevel = 0;
    638a:	10 92 be 32 	sts	0x32BE, r1
  IpMyConfig.dbgStream = NULL;
    638e:	10 92 bc 32 	sts	0x32BC, r1
    6392:	10 92 bd 32 	sts	0x32BD, r1
#endif
}
    6396:	08 95       	ret

00006398 <ipSaveConfig>:

void ipSaveConfig(void)
{
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
    6398:	40 91 b0 32 	lds	r20, 0x32B0
    639c:	50 91 b1 32 	lds	r21, 0x32B1
    63a0:	60 91 b2 32 	lds	r22, 0x32B2
    63a4:	70 91 b3 32 	lds	r23, 0x32B3
    63a8:	8e e1       	ldi	r24, 0x1E	; 30
    63aa:	90 e0       	ldi	r25, 0x00	; 0
    63ac:	0e 94 4e 5a 	call	0xb49c	; 0xb49c <__eeupd_dword_x128a1>
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
    63b0:	40 91 b4 32 	lds	r20, 0x32B4
    63b4:	50 91 b5 32 	lds	r21, 0x32B5
    63b8:	60 91 b6 32 	lds	r22, 0x32B6
    63bc:	70 91 b7 32 	lds	r23, 0x32B7
    63c0:	82 e2       	ldi	r24, 0x22	; 34
    63c2:	90 e0       	ldi	r25, 0x00	; 0
    63c4:	0e 94 4e 5a 	call	0xb49c	; 0xb49c <__eeupd_dword_x128a1>
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    63c8:	40 91 b8 32 	lds	r20, 0x32B8
    63cc:	50 91 b9 32 	lds	r21, 0x32B9
    63d0:	60 91 ba 32 	lds	r22, 0x32BA
    63d4:	70 91 bb 32 	lds	r23, 0x32BB
    63d8:	86 e2       	ldi	r24, 0x26	; 38
    63da:	90 e0       	ldi	r25, 0x00	; 0
    63dc:	0e 94 4e 5a 	call	0xb49c	; 0xb49c <__eeupd_dword_x128a1>
}
    63e0:	08 95       	ret

000063e2 <netstackIPv4Process>:

inline void netstackIPv4Process(void)
{
    63e2:	ef 92       	push	r14
    63e4:	ff 92       	push	r15
    63e6:	0f 93       	push	r16
    63e8:	1f 93       	push	r17
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    63ea:	e0 91 e6 31 	lds	r30, 0x31E6
    63ee:	f0 91 e7 31 	lds	r31, 0x31E7
    63f2:	80 89       	ldd	r24, Z+16	; 0x10
    63f4:	91 89       	ldd	r25, Z+17	; 0x11
    63f6:	a2 89       	ldd	r26, Z+18	; 0x12
    63f8:	b3 89       	ldd	r27, Z+19	; 0x13
    63fa:	e0 90 b0 32 	lds	r14, 0x32B0
    63fe:	f0 90 b1 32 	lds	r15, 0x32B1
    6402:	00 91 b2 32 	lds	r16, 0x32B2
    6406:	10 91 b3 32 	lds	r17, 0x32B3
    640a:	8e 15       	cp	r24, r14
    640c:	9f 05       	cpc	r25, r15
    640e:	a0 07       	cpc	r26, r16
    6410:	b1 07       	cpc	r27, r17
    6412:	d1 f0       	breq	.+52     	; 0x6448 <netstackIPv4Process+0x66>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    6414:	20 91 b4 32 	lds	r18, 0x32B4
    6418:	30 91 b5 32 	lds	r19, 0x32B5
    641c:	40 91 b6 32 	lds	r20, 0x32B6
    6420:	50 91 b7 32 	lds	r21, 0x32B7
    6424:	2e 29       	or	r18, r14
    6426:	3f 29       	or	r19, r15
    6428:	40 2b       	or	r20, r16
    642a:	51 2b       	or	r21, r17
}

inline void netstackIPv4Process(void)
{
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    642c:	82 17       	cp	r24, r18
    642e:	93 07       	cpc	r25, r19
    6430:	a4 07       	cpc	r26, r20
    6432:	b5 07       	cpc	r27, r21
    6434:	49 f0       	breq	.+18     	; 0x6448 <netstackIPv4Process+0x66>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    6436:	8f 3f       	cpi	r24, 0xFF	; 255
    6438:	2f ef       	ldi	r18, 0xFF	; 255
    643a:	92 07       	cpc	r25, r18
    643c:	2f ef       	ldi	r18, 0xFF	; 255
    643e:	a2 07       	cpc	r26, r18
    6440:	2f ef       	ldi	r18, 0xFF	; 255
    6442:	b2 07       	cpc	r27, r18
    6444:	09 f0       	breq	.+2      	; 0x6448 <netstackIPv4Process+0x66>
    6446:	86 c0       	rjmp	.+268    	; 0x6554 <netstackIPv4Process+0x172>
      (nicState.layer3.ip->destipaddr != 0xFFFFFFFF)) 
    return;

// handle ICMP packet
  if(nicState.layer3.ip->proto == IP_PROTO_ICMP)
    6448:	21 85       	ldd	r18, Z+9	; 0x09
    644a:	21 30       	cpi	r18, 0x01	; 1
    644c:	79 f5       	brne	.+94     	; 0x64ac <netstackIPv4Process+0xca>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    644e:	80 91 bc 32 	lds	r24, 0x32BC
    6452:	90 91 bd 32 	lds	r25, 0x32BD
    6456:	00 97       	sbiw	r24, 0x00	; 0
    6458:	31 f1       	breq	.+76     	; 0x64a6 <netstackIPv4Process+0xc4>
    {
      if (IpMyConfig.dbgLevel > 0)
    645a:	20 91 be 32 	lds	r18, 0x32BE
    645e:	22 23       	and	r18, r18
    6460:	81 f0       	breq	.+32     	; 0x6482 <netstackIPv4Process+0xa0>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
    6462:	00 d0       	rcall	.+0      	; 0x6464 <netstackIPv4Process+0x82>
    6464:	0f 92       	push	r0
    6466:	ed b7       	in	r30, 0x3d	; 61
    6468:	fe b7       	in	r31, 0x3e	; 62
    646a:	81 83       	std	Z+1, r24	; 0x01
    646c:	92 83       	std	Z+2, r25	; 0x02
    646e:	8c e6       	ldi	r24, 0x6C	; 108
    6470:	9b e0       	ldi	r25, 0x0B	; 11
    6472:	83 83       	std	Z+3, r24	; 0x03
    6474:	94 83       	std	Z+4, r25	; 0x04
    6476:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    647a:	0f 90       	pop	r0
    647c:	0f 90       	pop	r0
    647e:	0f 90       	pop	r0
    6480:	0f 90       	pop	r0
      if (IpMyConfig.dbgLevel > 2)
    6482:	80 91 be 32 	lds	r24, 0x32BE
    6486:	83 30       	cpi	r24, 0x03	; 3
    6488:	70 f0       	brcs	.+28     	; 0x64a6 <netstackIPv4Process+0xc4>
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    648a:	60 91 e6 31 	lds	r22, 0x31E6
    648e:	70 91 e7 31 	lds	r23, 0x31E7
    6492:	40 91 e8 31 	lds	r20, 0x31E8
    6496:	50 91 e9 31 	lds	r21, 0x31E9
    649a:	80 91 bc 32 	lds	r24, 0x32BC
    649e:	90 91 bd 32 	lds	r25, 0x32BD
    64a2:	0e 94 85 34 	call	0x690a	; 0x690a <icmpPrintHeader>
    }
#endif /*IP_DEBUG*/
    icmpIpIn();
    64a6:	0e 94 e0 35 	call	0x6bc0	; 0x6bc0 <icmpIpIn>
    return;
    64aa:	54 c0       	rjmp	.+168    	; 0x6554 <netstackIPv4Process+0x172>
  }
  if( nicState.layer3.ip->proto == IP_PROTO_UDP )
    64ac:	21 31       	cpi	r18, 0x11	; 17
    64ae:	e9 f4       	brne	.+58     	; 0x64ea <netstackIPv4Process+0x108>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    64b0:	80 91 bc 32 	lds	r24, 0x32BC
    64b4:	90 91 bd 32 	lds	r25, 0x32BD
    64b8:	00 97       	sbiw	r24, 0x00	; 0
    64ba:	a1 f0       	breq	.+40     	; 0x64e4 <netstackIPv4Process+0x102>
    {
      if (IpMyConfig.dbgLevel > 0)
    64bc:	20 91 be 32 	lds	r18, 0x32BE
    64c0:	22 23       	and	r18, r18
    64c2:	81 f0       	breq	.+32     	; 0x64e4 <netstackIPv4Process+0x102>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    64c4:	00 d0       	rcall	.+0      	; 0x64c6 <netstackIPv4Process+0xe4>
    64c6:	0f 92       	push	r0
    64c8:	ed b7       	in	r30, 0x3d	; 61
    64ca:	fe b7       	in	r31, 0x3e	; 62
    64cc:	81 83       	std	Z+1, r24	; 0x01
    64ce:	92 83       	std	Z+2, r25	; 0x02
    64d0:	84 e5       	ldi	r24, 0x54	; 84
    64d2:	9b e0       	ldi	r25, 0x0B	; 11
    64d4:	83 83       	std	Z+3, r24	; 0x03
    64d6:	94 83       	std	Z+4, r25	; 0x04
    64d8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    64dc:	0f 90       	pop	r0
    64de:	0f 90       	pop	r0
    64e0:	0f 90       	pop	r0
    64e2:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackUDPIPProcess();
    64e4:	0e 94 6f 3d 	call	0x7ade	; 0x7ade <netstackUDPIPProcess>
    return;
    64e8:	35 c0       	rjmp	.+106    	; 0x6554 <netstackIPv4Process+0x172>
    64ea:	80 91 bc 32 	lds	r24, 0x32BC
    64ee:	90 91 bd 32 	lds	r25, 0x32BD
  }
  if( nicState.layer3.ip->proto == IP_PROTO_TCP )
    64f2:	26 30       	cpi	r18, 0x06	; 6
    64f4:	c9 f4       	brne	.+50     	; 0x6528 <netstackIPv4Process+0x146>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    64f6:	00 97       	sbiw	r24, 0x00	; 0
    64f8:	a1 f0       	breq	.+40     	; 0x6522 <netstackIPv4Process+0x140>
    {
      if (IpMyConfig.dbgLevel > 0)
    64fa:	20 91 be 32 	lds	r18, 0x32BE
    64fe:	22 23       	and	r18, r18
    6500:	81 f0       	breq	.+32     	; 0x6522 <netstackIPv4Process+0x140>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: TCP/IP packet\r\n"));
    6502:	00 d0       	rcall	.+0      	; 0x6504 <netstackIPv4Process+0x122>
    6504:	0f 92       	push	r0
    6506:	ed b7       	in	r30, 0x3d	; 61
    6508:	fe b7       	in	r31, 0x3e	; 62
    650a:	81 83       	std	Z+1, r24	; 0x01
    650c:	92 83       	std	Z+2, r25	; 0x02
    650e:	8c e3       	ldi	r24, 0x3C	; 60
    6510:	9b e0       	ldi	r25, 0x0B	; 11
    6512:	83 83       	std	Z+3, r24	; 0x03
    6514:	94 83       	std	Z+4, r25	; 0x04
    6516:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    651a:	0f 90       	pop	r0
    651c:	0f 90       	pop	r0
    651e:	0f 90       	pop	r0
    6520:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackTCPIPProcess();
    6522:	0e 94 86 3c 	call	0x790c	; 0x790c <netstackTCPIPProcess>
    return;
    6526:	16 c0       	rjmp	.+44     	; 0x6554 <netstackIPv4Process+0x172>
  }
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6528:	00 97       	sbiw	r24, 0x00	; 0
    652a:	a1 f0       	breq	.+40     	; 0x6554 <netstackIPv4Process+0x172>
  {
    if (IpMyConfig.dbgLevel > 0)
    652c:	20 91 be 32 	lds	r18, 0x32BE
    6530:	22 23       	and	r18, r18
    6532:	81 f0       	breq	.+32     	; 0x6554 <netstackIPv4Process+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
    6534:	00 d0       	rcall	.+0      	; 0x6536 <netstackIPv4Process+0x154>
    6536:	0f 92       	push	r0
    6538:	ed b7       	in	r30, 0x3d	; 61
    653a:	fe b7       	in	r31, 0x3e	; 62
    653c:	81 83       	std	Z+1, r24	; 0x01
    653e:	92 83       	std	Z+2, r25	; 0x02
    6540:	80 e2       	ldi	r24, 0x20	; 32
    6542:	9b e0       	ldi	r25, 0x0B	; 11
    6544:	83 83       	std	Z+3, r24	; 0x03
    6546:	94 83       	std	Z+4, r25	; 0x04
    6548:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    654c:	0f 90       	pop	r0
    654e:	0f 90       	pop	r0
    6550:	0f 90       	pop	r0
    6552:	0f 90       	pop	r0
  }
#endif /*IP_DEBUG*/
}
    6554:	1f 91       	pop	r17
    6556:	0f 91       	pop	r16
    6558:	ff 90       	pop	r15
    655a:	ef 90       	pop	r14
    655c:	08 95       	ret

0000655e <setIpDebug>:

#if IP_DEBUG
void setIpDebug(FILE *stream, uint8_t level)
{
  IpMyConfig.dbgStream = stream;
    655e:	80 93 bc 32 	sts	0x32BC, r24
    6562:	90 93 bd 32 	sts	0x32BD, r25
  IpMyConfig.dbgLevel = level;
    6566:	60 93 be 32 	sts	0x32BE, r22
  if (level == 0)
    656a:	66 23       	and	r22, r22
    656c:	21 f4       	brne	.+8      	; 0x6576 <setIpDebug+0x18>
    IpMyConfig.dbgStream = NULL;
    656e:	10 92 bc 32 	sts	0x32BC, r1
    6572:	10 92 bd 32 	sts	0x32BD, r1
    6576:	08 95       	ret

00006578 <ipSetConfig>:
}
#endif

void ipSetConfig(uint32_t myIp, uint32_t netmask, uint32_t gatewayIp)
{
    6578:	ef 92       	push	r14
    657a:	ff 92       	push	r15
    657c:	0f 93       	push	r16
    657e:	1f 93       	push	r17
  // set local addressing
  IpMyConfig.ip = myIp;
    6580:	60 93 b0 32 	sts	0x32B0, r22
    6584:	70 93 b1 32 	sts	0x32B1, r23
    6588:	80 93 b2 32 	sts	0x32B2, r24
    658c:	90 93 b3 32 	sts	0x32B3, r25
  IpMyConfig.netmask = netmask;
    6590:	20 93 b4 32 	sts	0x32B4, r18
    6594:	30 93 b5 32 	sts	0x32B5, r19
    6598:	40 93 b6 32 	sts	0x32B6, r20
    659c:	50 93 b7 32 	sts	0x32B7, r21
  IpMyConfig.gateway = gatewayIp;
    65a0:	e0 92 b8 32 	sts	0x32B8, r14
    65a4:	f0 92 b9 32 	sts	0x32B9, r15
    65a8:	00 93 ba 32 	sts	0x32BA, r16
    65ac:	10 93 bb 32 	sts	0x32BB, r17
}
    65b0:	1f 91       	pop	r17
    65b2:	0f 91       	pop	r16
    65b4:	ff 90       	pop	r15
    65b6:	ef 90       	pop	r14
    65b8:	08 95       	ret

000065ba <ipSetConfigIp>:

void ipSetConfigIp(uint32_t myIp)
{
  // set local addressing
  IpMyConfig.ip = myIp; 
    65ba:	60 93 b0 32 	sts	0x32B0, r22
    65be:	70 93 b1 32 	sts	0x32B1, r23
    65c2:	80 93 b2 32 	sts	0x32B2, r24
    65c6:	90 93 b3 32 	sts	0x32B3, r25
}
    65ca:	08 95       	ret

000065cc <ipSetConfigMask>:

void ipSetConfigMask(uint32_t netmask)
{
  IpMyConfig.netmask = netmask;
    65cc:	60 93 b4 32 	sts	0x32B4, r22
    65d0:	70 93 b5 32 	sts	0x32B5, r23
    65d4:	80 93 b6 32 	sts	0x32B6, r24
    65d8:	90 93 b7 32 	sts	0x32B7, r25
}
    65dc:	08 95       	ret

000065de <ipSetConfigGw>:

void ipSetConfigGw(uint32_t gatewayIp)
{
  IpMyConfig.gateway = gatewayIp;
    65de:	60 93 b8 32 	sts	0x32B8, r22
    65e2:	70 93 b9 32 	sts	0x32B9, r23
    65e6:	80 93 ba 32 	sts	0x32BA, r24
    65ea:	90 93 bb 32 	sts	0x32BB, r25
}
    65ee:	08 95       	ret

000065f0 <ipGetConfig>:


struct ipConfig* ipGetConfig(void)
{
  return &IpMyConfig;
}
    65f0:	80 eb       	ldi	r24, 0xB0	; 176
    65f2:	92 e3       	ldi	r25, 0x32	; 50
    65f4:	08 95       	ret

000065f6 <ipSend>:

void ipSend(uint32_t dstIp, uint8_t protocol, uint16_t len)
{
    65f6:	af 92       	push	r10
    65f8:	bf 92       	push	r11
    65fa:	cf 92       	push	r12
    65fc:	df 92       	push	r13
    65fe:	ef 92       	push	r14
    6600:	ff 92       	push	r15
    6602:	0f 93       	push	r16
    6604:	1f 93       	push	r17
    6606:	df 93       	push	r29
    6608:	cf 93       	push	r28
    660a:	0f 92       	push	r0
    660c:	cd b7       	in	r28, 0x3d	; 61
    660e:	de b7       	in	r29, 0x3e	; 62
    6610:	6b 01       	movw	r12, r22
    6612:	7c 01       	movw	r14, r24
    6614:	89 01       	movw	r16, r18
// make pointer to ethernet/IP header
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6616:	80 91 bc 32 	lds	r24, 0x32BC
    661a:	90 91 bd 32 	lds	r25, 0x32BD
    661e:	00 97       	sbiw	r24, 0x00	; 0
    6620:	b1 f0       	breq	.+44     	; 0x664e <ipSend+0x58>
  {  
    if (IpMyConfig.dbgLevel > 2)
    6622:	20 91 be 32 	lds	r18, 0x32BE
    6626:	23 30       	cpi	r18, 0x03	; 3
    6628:	90 f0       	brcs	.+36     	; 0x664e <ipSend+0x58>
      fprintf_P(IpMyConfig.dbgStream, "Sending Ip packet\r\n");
    662a:	00 d0       	rcall	.+0      	; 0x662c <ipSend+0x36>
    662c:	0f 92       	push	r0
    662e:	ed b7       	in	r30, 0x3d	; 61
    6630:	fe b7       	in	r31, 0x3e	; 62
    6632:	81 83       	std	Z+1, r24	; 0x01
    6634:	92 83       	std	Z+2, r25	; 0x02
    6636:	82 e0       	ldi	r24, 0x02	; 2
    6638:	95 e2       	ldi	r25, 0x25	; 37
    663a:	83 83       	std	Z+3, r24	; 0x03
    663c:	94 83       	std	Z+4, r25	; 0x04
    663e:	49 83       	std	Y+1, r20	; 0x01
    6640:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6644:	0f 90       	pop	r0
    6646:	0f 90       	pop	r0
    6648:	0f 90       	pop	r0
    664a:	0f 90       	pop	r0
    664c:	49 81       	ldd	r20, Y+1	; 0x01
  }
#endif

// adjust length to add IP header
  len += IP_HEADER_LEN;
    664e:	0c 5e       	subi	r16, 0xEC	; 236
    6650:	1f 4f       	sbci	r17, 0xFF	; 255

// fill IP header
  nicState.layer3.ip->destipaddr = dstIp;
    6652:	e0 91 e6 31 	lds	r30, 0x31E6
    6656:	f0 91 e7 31 	lds	r31, 0x31E7
    665a:	c0 8a       	std	Z+16, r12	; 0x10
    665c:	d1 8a       	std	Z+17, r13	; 0x11
    665e:	e2 8a       	std	Z+18, r14	; 0x12
    6660:	f3 8a       	std	Z+19, r15	; 0x13
  nicState.layer3.ip->srcipaddr  = IpMyConfig.ip;
    6662:	80 91 b0 32 	lds	r24, 0x32B0
    6666:	90 91 b1 32 	lds	r25, 0x32B1
    666a:	a0 91 b2 32 	lds	r26, 0x32B2
    666e:	b0 91 b3 32 	lds	r27, 0x32B3
    6672:	84 87       	std	Z+12, r24	; 0x0c
    6674:	95 87       	std	Z+13, r25	; 0x0d
    6676:	a6 87       	std	Z+14, r26	; 0x0e
    6678:	b7 87       	std	Z+15, r27	; 0x0f
  nicState.layer3.ip->proto      = protocol;
    667a:	41 87       	std	Z+9, r20	; 0x09
  nicState.layer3.ip->len        = htons(len);
    667c:	a0 90 e6 31 	lds	r10, 0x31E6
    6680:	b0 90 e7 31 	lds	r11, 0x31E7
    6684:	c8 01       	movw	r24, r16
    6686:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    668a:	f5 01       	movw	r30, r10
    668c:	82 83       	std	Z+2, r24	; 0x02
    668e:	93 83       	std	Z+3, r25	; 0x03
  nicState.layer3.ip->vhl        = 0x45;
    6690:	e0 91 e6 31 	lds	r30, 0x31E6
    6694:	f0 91 e7 31 	lds	r31, 0x31E7
    6698:	85 e4       	ldi	r24, 0x45	; 69
    669a:	80 83       	st	Z, r24
  nicState.layer3.ip->tos        = 0;
    669c:	e0 91 e6 31 	lds	r30, 0x31E6
    66a0:	f0 91 e7 31 	lds	r31, 0x31E7
    66a4:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ip->ipid       = 0;
    66a6:	e0 91 e6 31 	lds	r30, 0x31E6
    66aa:	f0 91 e7 31 	lds	r31, 0x31E7
    66ae:	14 82       	std	Z+4, r1	; 0x04
    66b0:	15 82       	std	Z+5, r1	; 0x05
  nicState.layer3.ip->ipoffset   = 0;
    66b2:	e0 91 e6 31 	lds	r30, 0x31E6
    66b6:	f0 91 e7 31 	lds	r31, 0x31E7
    66ba:	16 82       	std	Z+6, r1	; 0x06
    66bc:	17 82       	std	Z+7, r1	; 0x07
  nicState.layer3.ip->ttl        = IP_TIME_TO_LIVE;
    66be:	e0 91 e6 31 	lds	r30, 0x31E6
    66c2:	f0 91 e7 31 	lds	r31, 0x31E7
    66c6:	80 e8       	ldi	r24, 0x80	; 128
    66c8:	80 87       	std	Z+8, r24	; 0x08
  nicState.layer3.ip->ipchksum   = 0;
    66ca:	e0 91 e6 31 	lds	r30, 0x31E6
    66ce:	f0 91 e7 31 	lds	r31, 0x31E7
    66d2:	12 86       	std	Z+10, r1	; 0x0a
    66d4:	13 86       	std	Z+11, r1	; 0x0b

// calculate and apply IP checksum
// DO THIS ONLY AFTER ALL CHANGES HAVE BEEN MADE TO IP HEADER
  nicState.layer3.ip->ipchksum   = netChecksum((uint8_t *)(nicState.layer3.ip), IP_HEADER_LEN);
    66d6:	a0 90 e6 31 	lds	r10, 0x31E6
    66da:	b0 90 e7 31 	lds	r11, 0x31E7
    66de:	c5 01       	movw	r24, r10
    66e0:	64 e1       	ldi	r22, 0x14	; 20
    66e2:	70 e0       	ldi	r23, 0x00	; 0
    66e4:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <netChecksum>
    66e8:	f5 01       	movw	r30, r10
    66ea:	82 87       	std	Z+10, r24	; 0x0a
    66ec:	93 87       	std	Z+11, r25	; 0x0b

// add ethernet routing
// check if we need to send to gateway
  if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    66ee:	80 91 b0 32 	lds	r24, 0x32B0
    66f2:	90 91 b1 32 	lds	r25, 0x32B1
    66f6:	a0 91 b2 32 	lds	r26, 0x32B2
    66fa:	b0 91 b3 32 	lds	r27, 0x32B3
    66fe:	8c 25       	eor	r24, r12
    6700:	9d 25       	eor	r25, r13
    6702:	ae 25       	eor	r26, r14
    6704:	bf 25       	eor	r27, r15
    6706:	20 91 b4 32 	lds	r18, 0x32B4
    670a:	30 91 b5 32 	lds	r19, 0x32B5
    670e:	40 91 b6 32 	lds	r20, 0x32B6
    6712:	50 91 b7 32 	lds	r21, 0x32B7
    6716:	82 23       	and	r24, r18
    6718:	93 23       	and	r25, r19
    671a:	a4 23       	and	r26, r20
    671c:	b5 23       	and	r27, r21
    671e:	00 97       	sbiw	r24, 0x00	; 0
    6720:	a1 05       	cpc	r26, r1
    6722:	b1 05       	cpc	r27, r1
    6724:	a1 f4       	brne	.+40     	; 0x674e <ipSend+0x158>
  {
    arpIpOut(0);  // local send
    6726:	60 e0       	ldi	r22, 0x00	; 0
    6728:	70 e0       	ldi	r23, 0x00	; 0
    672a:	cb 01       	movw	r24, r22
    672c:	0e 94 42 36 	call	0x6c84	; 0x6c84 <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6730:	80 91 bc 32 	lds	r24, 0x32BC
    6734:	90 91 bd 32 	lds	r25, 0x32BD
    6738:	00 97       	sbiw	r24, 0x00	; 0
    673a:	49 f1       	breq	.+82     	; 0x678e <ipSend+0x198>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet on local net\r\n"));
    673c:	00 d0       	rcall	.+0      	; 0x673e <ipSend+0x148>
    673e:	0f 92       	push	r0
    6740:	ed b7       	in	r30, 0x3d	; 61
    6742:	fe b7       	in	r31, 0x3e	; 62
    6744:	81 83       	std	Z+1, r24	; 0x01
    6746:	92 83       	std	Z+2, r25	; 0x02
    6748:	8f ef       	ldi	r24, 0xFF	; 255
    674a:	9a e0       	ldi	r25, 0x0A	; 10
    674c:	18 c0       	rjmp	.+48     	; 0x677e <ipSend+0x188>
#endif
  }
  else
  {
    arpIpOut(IpMyConfig.gateway);  // gateway send
    674e:	60 91 b8 32 	lds	r22, 0x32B8
    6752:	70 91 b9 32 	lds	r23, 0x32B9
    6756:	80 91 ba 32 	lds	r24, 0x32BA
    675a:	90 91 bb 32 	lds	r25, 0x32BB
    675e:	0e 94 42 36 	call	0x6c84	; 0x6c84 <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6762:	80 91 bc 32 	lds	r24, 0x32BC
    6766:	90 91 bd 32 	lds	r25, 0x32BD
    676a:	00 97       	sbiw	r24, 0x00	; 0
    676c:	81 f0       	breq	.+32     	; 0x678e <ipSend+0x198>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet to gateway\r\n"));
    676e:	00 d0       	rcall	.+0      	; 0x6770 <ipSend+0x17a>
    6770:	0f 92       	push	r0
    6772:	ed b7       	in	r30, 0x3d	; 61
    6774:	fe b7       	in	r31, 0x3e	; 62
    6776:	81 83       	std	Z+1, r24	; 0x01
    6778:	92 83       	std	Z+2, r25	; 0x02
    677a:	80 ee       	ldi	r24, 0xE0	; 224
    677c:	9a e0       	ldi	r25, 0x0A	; 10
    677e:	83 83       	std	Z+3, r24	; 0x03
    6780:	94 83       	std	Z+4, r25	; 0x04
    6782:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6786:	0f 90       	pop	r0
    6788:	0f 90       	pop	r0
    678a:	0f 90       	pop	r0
    678c:	0f 90       	pop	r0
#endif
  }

// adjust length to add ethernet header
  len += ETH_HEADER_LEN;
    678e:	02 5f       	subi	r16, 0xF2	; 242
    6790:	1f 4f       	sbci	r17, 0xFF	; 255

#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6792:	80 91 bc 32 	lds	r24, 0x32BC
    6796:	90 91 bd 32 	lds	r25, 0x32BD
    679a:	00 97       	sbiw	r24, 0x00	; 0
    679c:	11 f1       	breq	.+68     	; 0x67e2 <ipSend+0x1ec>
  {
    if (IpMyConfig.dbgLevel > 3)
    679e:	20 91 be 32 	lds	r18, 0x32BE
    67a2:	24 30       	cpi	r18, 0x04	; 4
    67a4:	f0 f0       	brcs	.+60     	; 0x67e2 <ipSend+0x1ec>
    {
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(ETH_HEADER_LEN, &data[0]);"));
    67a6:	00 d0       	rcall	.+0      	; 0x67a8 <ipSend+0x1b2>
    67a8:	0f 92       	push	r0
    67aa:	ed b7       	in	r30, 0x3d	; 61
    67ac:	fe b7       	in	r31, 0x3e	; 62
    67ae:	81 83       	std	Z+1, r24	; 0x01
    67b0:	92 83       	std	Z+2, r25	; 0x02
    67b2:	82 eb       	ldi	r24, 0xB2	; 178
    67b4:	9a e0       	ldi	r25, 0x0A	; 10
    67b6:	83 83       	std	Z+3, r24	; 0x03
    67b8:	94 83       	std	Z+4, r25	; 0x04
    67ba:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    67be:	80 91 bc 32 	lds	r24, 0x32BC
    67c2:	90 91 bd 32 	lds	r25, 0x32BD
    67c6:	ed b7       	in	r30, 0x3d	; 61
    67c8:	fe b7       	in	r31, 0x3e	; 62
    67ca:	81 83       	std	Z+1, r24	; 0x01
    67cc:	92 83       	std	Z+2, r25	; 0x02
    67ce:	83 e7       	ldi	r24, 0x73	; 115
    67d0:	9a e0       	ldi	r25, 0x0A	; 10
    67d2:	83 83       	std	Z+3, r24	; 0x03
    67d4:	94 83       	std	Z+4, r25	; 0x04
    67d6:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    67da:	0f 90       	pop	r0
    67dc:	0f 90       	pop	r0
    67de:	0f 90       	pop	r0
    67e0:	0f 90       	pop	r0
    }
  }
#endif
// send it
  nicSend(len);
    67e2:	c8 01       	movw	r24, r16
    67e4:	0e 94 ce 2b 	call	0x579c	; 0x579c <nicSend>
}
    67e8:	0f 90       	pop	r0
    67ea:	cf 91       	pop	r28
    67ec:	df 91       	pop	r29
    67ee:	1f 91       	pop	r17
    67f0:	0f 91       	pop	r16
    67f2:	ff 90       	pop	r15
    67f4:	ef 90       	pop	r14
    67f6:	df 90       	pop	r13
    67f8:	cf 90       	pop	r12
    67fa:	bf 90       	pop	r11
    67fc:	af 90       	pop	r10
    67fe:	08 95       	ret

00006800 <ipPrintConfig>:

void ipPrintConfig(FILE *stream, struct ipConfig* config)
{
    6800:	0f 93       	push	r16
    6802:	1f 93       	push	r17
    6804:	cf 93       	push	r28
    6806:	df 93       	push	r29
    6808:	ec 01       	movw	r28, r24
    680a:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Addr : ")); netPrintIPAddr(stream, config->ip);        fprintf_P(stream, PSTR("\r\n"));
    680c:	00 d0       	rcall	.+0      	; 0x680e <ipPrintConfig+0xe>
    680e:	0f 92       	push	r0
    6810:	ed b7       	in	r30, 0x3d	; 61
    6812:	fe b7       	in	r31, 0x3e	; 62
    6814:	81 83       	std	Z+1, r24	; 0x01
    6816:	92 83       	std	Z+2, r25	; 0x02
    6818:	88 e6       	ldi	r24, 0x68	; 104
    681a:	9a e0       	ldi	r25, 0x0A	; 10
    681c:	83 83       	std	Z+3, r24	; 0x03
    681e:	94 83       	std	Z+4, r25	; 0x04
    6820:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6824:	0f 90       	pop	r0
    6826:	0f 90       	pop	r0
    6828:	0f 90       	pop	r0
    682a:	0f 90       	pop	r0
    682c:	f8 01       	movw	r30, r16
    682e:	40 81       	ld	r20, Z
    6830:	51 81       	ldd	r21, Z+1	; 0x01
    6832:	62 81       	ldd	r22, Z+2	; 0x02
    6834:	73 81       	ldd	r23, Z+3	; 0x03
    6836:	ce 01       	movw	r24, r28
    6838:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    683c:	00 d0       	rcall	.+0      	; 0x683e <ipPrintConfig+0x3e>
    683e:	0f 92       	push	r0
    6840:	ed b7       	in	r30, 0x3d	; 61
    6842:	fe b7       	in	r31, 0x3e	; 62
    6844:	c1 83       	std	Z+1, r28	; 0x01
    6846:	d2 83       	std	Z+2, r29	; 0x02
    6848:	85 e6       	ldi	r24, 0x65	; 101
    684a:	9a e0       	ldi	r25, 0x0A	; 10
    684c:	83 83       	std	Z+3, r24	; 0x03
    684e:	94 83       	std	Z+4, r25	; 0x04
    6850:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Netmask : ")); netPrintIPAddr(stream, config->netmask);   fprintf_P(stream, PSTR("\r\n"));
    6854:	ed b7       	in	r30, 0x3d	; 61
    6856:	fe b7       	in	r31, 0x3e	; 62
    6858:	c1 83       	std	Z+1, r28	; 0x01
    685a:	d2 83       	std	Z+2, r29	; 0x02
    685c:	8a e5       	ldi	r24, 0x5A	; 90
    685e:	9a e0       	ldi	r25, 0x0A	; 10
    6860:	83 83       	std	Z+3, r24	; 0x03
    6862:	94 83       	std	Z+4, r25	; 0x04
    6864:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6868:	0f 90       	pop	r0
    686a:	0f 90       	pop	r0
    686c:	0f 90       	pop	r0
    686e:	0f 90       	pop	r0
    6870:	f8 01       	movw	r30, r16
    6872:	44 81       	ldd	r20, Z+4	; 0x04
    6874:	55 81       	ldd	r21, Z+5	; 0x05
    6876:	66 81       	ldd	r22, Z+6	; 0x06
    6878:	77 81       	ldd	r23, Z+7	; 0x07
    687a:	ce 01       	movw	r24, r28
    687c:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    6880:	00 d0       	rcall	.+0      	; 0x6882 <ipPrintConfig+0x82>
    6882:	0f 92       	push	r0
    6884:	ed b7       	in	r30, 0x3d	; 61
    6886:	fe b7       	in	r31, 0x3e	; 62
    6888:	c1 83       	std	Z+1, r28	; 0x01
    688a:	d2 83       	std	Z+2, r29	; 0x02
    688c:	87 e5       	ldi	r24, 0x57	; 87
    688e:	9a e0       	ldi	r25, 0x0A	; 10
    6890:	83 83       	std	Z+3, r24	; 0x03
    6892:	94 83       	std	Z+4, r25	; 0x04
    6894:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("Gateway : ")); netPrintIPAddr(stream, config->gateway);   fprintf_P(stream, PSTR("\r\n"));
    6898:	ed b7       	in	r30, 0x3d	; 61
    689a:	fe b7       	in	r31, 0x3e	; 62
    689c:	c1 83       	std	Z+1, r28	; 0x01
    689e:	d2 83       	std	Z+2, r29	; 0x02
    68a0:	8c e4       	ldi	r24, 0x4C	; 76
    68a2:	9a e0       	ldi	r25, 0x0A	; 10
    68a4:	83 83       	std	Z+3, r24	; 0x03
    68a6:	94 83       	std	Z+4, r25	; 0x04
    68a8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    68ac:	0f 90       	pop	r0
    68ae:	0f 90       	pop	r0
    68b0:	0f 90       	pop	r0
    68b2:	0f 90       	pop	r0
    68b4:	f8 01       	movw	r30, r16
    68b6:	40 85       	ldd	r20, Z+8	; 0x08
    68b8:	51 85       	ldd	r21, Z+9	; 0x09
    68ba:	62 85       	ldd	r22, Z+10	; 0x0a
    68bc:	73 85       	ldd	r23, Z+11	; 0x0b
    68be:	ce 01       	movw	r24, r28
    68c0:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    68c4:	00 d0       	rcall	.+0      	; 0x68c6 <ipPrintConfig+0xc6>
    68c6:	0f 92       	push	r0
    68c8:	ed b7       	in	r30, 0x3d	; 61
    68ca:	fe b7       	in	r31, 0x3e	; 62
    68cc:	c1 83       	std	Z+1, r28	; 0x01
    68ce:	d2 83       	std	Z+2, r29	; 0x02
    68d0:	89 e4       	ldi	r24, 0x49	; 73
    68d2:	9a e0       	ldi	r25, 0x0A	; 10
    68d4:	83 83       	std	Z+3, r24	; 0x03
    68d6:	94 83       	std	Z+4, r25	; 0x04
    68d8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    68dc:	0f 90       	pop	r0
    68de:	0f 90       	pop	r0
    68e0:	0f 90       	pop	r0
    68e2:	0f 90       	pop	r0
}
    68e4:	df 91       	pop	r29
    68e6:	cf 91       	pop	r28
    68e8:	1f 91       	pop	r17
    68ea:	0f 91       	pop	r16
    68ec:	08 95       	ret

000068ee <icmpInit>:


// functions
void icmpInit(void)
{
  icmpDebug = NULL;
    68ee:	10 92 0a 32 	sts	0x320A, r1
    68f2:	10 92 0b 32 	sts	0x320B, r1
  icmpDebugLevel = 0;
    68f6:	10 92 ad 32 	sts	0x32AD, r1
}
    68fa:	08 95       	ret

000068fc <setIcmpDebug>:
}

#if ICMP_DEBUG
void setIcmpDebug(FILE *stream, uint8_t level)
{
  icmpDebug = stream;
    68fc:	80 93 0a 32 	sts	0x320A, r24
    6900:	90 93 0b 32 	sts	0x320B, r25
  icmpDebugLevel = level;
    6904:	60 93 ad 32 	sts	0x32AD, r22
}
    6908:	08 95       	ret

0000690a <icmpPrintHeader>:
#endif

void icmpPrintHeader(FILE *stream, struct netIpHeader *ipPacket, struct netIcmpHeader *icmpPacket)
{
    690a:	ef 92       	push	r14
    690c:	ff 92       	push	r15
    690e:	0f 93       	push	r16
    6910:	1f 93       	push	r17
    6912:	cf 93       	push	r28
    6914:	df 93       	push	r29
    6916:	ec 01       	movw	r28, r24
    6918:	8b 01       	movw	r16, r22
    691a:	7a 01       	movw	r14, r20
  fprintf_P(stream, PSTR("ICMP Packet:\r\n"));
    691c:	00 d0       	rcall	.+0      	; 0x691e <icmpPrintHeader+0x14>
    691e:	0f 92       	push	r0
    6920:	ad b7       	in	r26, 0x3d	; 61
    6922:	be b7       	in	r27, 0x3e	; 62
    6924:	11 96       	adiw	r26, 0x01	; 1
    6926:	8d 93       	st	X+, r24
    6928:	9c 93       	st	X, r25
    692a:	12 97       	sbiw	r26, 0x02	; 2
    692c:	88 ed       	ldi	r24, 0xD8	; 216
    692e:	9b e0       	ldi	r25, 0x0B	; 11
    6930:	13 96       	adiw	r26, 0x03	; 3
    6932:	8d 93       	st	X+, r24
    6934:	9c 93       	st	X, r25
    6936:	14 97       	sbiw	r26, 0x04	; 4
    6938:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print source IP address
  fprintf_P(stream, PSTR("SrcIpAddr: "));  netPrintIPAddr(stream, ipPacket->srcipaddr);  fprintf_P(stream, PSTR("\r\n"));
    693c:	ed b7       	in	r30, 0x3d	; 61
    693e:	fe b7       	in	r31, 0x3e	; 62
    6940:	c1 83       	std	Z+1, r28	; 0x01
    6942:	d2 83       	std	Z+2, r29	; 0x02
    6944:	8c ec       	ldi	r24, 0xCC	; 204
    6946:	9b e0       	ldi	r25, 0x0B	; 11
    6948:	83 83       	std	Z+3, r24	; 0x03
    694a:	94 83       	std	Z+4, r25	; 0x04
    694c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6950:	0f 90       	pop	r0
    6952:	0f 90       	pop	r0
    6954:	0f 90       	pop	r0
    6956:	0f 90       	pop	r0
    6958:	d8 01       	movw	r26, r16
    695a:	1c 96       	adiw	r26, 0x0c	; 12
    695c:	4d 91       	ld	r20, X+
    695e:	5d 91       	ld	r21, X+
    6960:	6d 91       	ld	r22, X+
    6962:	7c 91       	ld	r23, X
    6964:	1f 97       	sbiw	r26, 0x0f	; 15
    6966:	ce 01       	movw	r24, r28
    6968:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    696c:	00 d0       	rcall	.+0      	; 0x696e <icmpPrintHeader+0x64>
    696e:	0f 92       	push	r0
    6970:	ed b7       	in	r30, 0x3d	; 61
    6972:	fe b7       	in	r31, 0x3e	; 62
    6974:	c1 83       	std	Z+1, r28	; 0x01
    6976:	d2 83       	std	Z+2, r29	; 0x02
    6978:	89 ec       	ldi	r24, 0xC9	; 201
    697a:	9b e0       	ldi	r25, 0x0B	; 11
    697c:	83 83       	std	Z+3, r24	; 0x03
    697e:	94 83       	std	Z+4, r25	; 0x04
    6980:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print dest IP address
  fprintf_P(stream, PSTR("DstIpAddr: "));  netPrintIPAddr(stream, ipPacket->destipaddr); fprintf_P(stream, PSTR("\r\n"));
    6984:	ad b7       	in	r26, 0x3d	; 61
    6986:	be b7       	in	r27, 0x3e	; 62
    6988:	11 96       	adiw	r26, 0x01	; 1
    698a:	cd 93       	st	X+, r28
    698c:	dc 93       	st	X, r29
    698e:	12 97       	sbiw	r26, 0x02	; 2
    6990:	8d eb       	ldi	r24, 0xBD	; 189
    6992:	9b e0       	ldi	r25, 0x0B	; 11
    6994:	13 96       	adiw	r26, 0x03	; 3
    6996:	8d 93       	st	X+, r24
    6998:	9c 93       	st	X, r25
    699a:	14 97       	sbiw	r26, 0x04	; 4
    699c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    69a0:	0f 90       	pop	r0
    69a2:	0f 90       	pop	r0
    69a4:	0f 90       	pop	r0
    69a6:	0f 90       	pop	r0
    69a8:	f8 01       	movw	r30, r16
    69aa:	40 89       	ldd	r20, Z+16	; 0x10
    69ac:	51 89       	ldd	r21, Z+17	; 0x11
    69ae:	62 89       	ldd	r22, Z+18	; 0x12
    69b0:	73 89       	ldd	r23, Z+19	; 0x13
    69b2:	ce 01       	movw	r24, r28
    69b4:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    69b8:	00 d0       	rcall	.+0      	; 0x69ba <icmpPrintHeader+0xb0>
    69ba:	0f 92       	push	r0
    69bc:	ad b7       	in	r26, 0x3d	; 61
    69be:	be b7       	in	r27, 0x3e	; 62
    69c0:	11 96       	adiw	r26, 0x01	; 1
    69c2:	cd 93       	st	X+, r28
    69c4:	dc 93       	st	X, r29
    69c6:	12 97       	sbiw	r26, 0x02	; 2
    69c8:	8a eb       	ldi	r24, 0xBA	; 186
    69ca:	9b e0       	ldi	r25, 0x0B	; 11
    69cc:	13 96       	adiw	r26, 0x03	; 3
    69ce:	8d 93       	st	X+, r24
    69d0:	9c 93       	st	X, r25
    69d2:	14 97       	sbiw	r26, 0x04	; 4
    69d4:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print type
  fprintf_P(stream, PSTR("Type   : "));
    69d8:	ed b7       	in	r30, 0x3d	; 61
    69da:	fe b7       	in	r31, 0x3e	; 62
    69dc:	c1 83       	std	Z+1, r28	; 0x01
    69de:	d2 83       	std	Z+2, r29	; 0x02
    69e0:	80 eb       	ldi	r24, 0xB0	; 176
    69e2:	9b e0       	ldi	r25, 0x0B	; 11
    69e4:	83 83       	std	Z+3, r24	; 0x03
    69e6:	94 83       	std	Z+4, r25	; 0x04
    69e8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  switch(icmpPacket->type)
    69ec:	0f 90       	pop	r0
    69ee:	0f 90       	pop	r0
    69f0:	0f 90       	pop	r0
    69f2:	0f 90       	pop	r0
    69f4:	d7 01       	movw	r26, r14
    69f6:	8c 91       	ld	r24, X
    69f8:	88 23       	and	r24, r24
    69fa:	59 f0       	breq	.+22     	; 0x6a12 <icmpPrintHeader+0x108>
    69fc:	88 30       	cpi	r24, 0x08	; 8
    69fe:	c1 f4       	brne	.+48     	; 0x6a30 <icmpPrintHeader+0x126>
  {
    case ICMP_TYPE_ECHOREQUEST:
      fprintf_P(stream, PSTR("ECHO REQUEST"));
    6a00:	00 d0       	rcall	.+0      	; 0x6a02 <icmpPrintHeader+0xf8>
    6a02:	0f 92       	push	r0
    6a04:	ed b7       	in	r30, 0x3d	; 61
    6a06:	fe b7       	in	r31, 0x3e	; 62
    6a08:	c1 83       	std	Z+1, r28	; 0x01
    6a0a:	d2 83       	std	Z+2, r29	; 0x02
    6a0c:	83 ea       	ldi	r24, 0xA3	; 163
    6a0e:	9b e0       	ldi	r25, 0x0B	; 11
    6a10:	17 c0       	rjmp	.+46     	; 0x6a40 <icmpPrintHeader+0x136>
      break;
    case ICMP_TYPE_ECHOREPLY:
      fprintf_P(stream, PSTR("ECHO REPLY"));
    6a12:	00 d0       	rcall	.+0      	; 0x6a14 <icmpPrintHeader+0x10a>
    6a14:	0f 92       	push	r0
    6a16:	ad b7       	in	r26, 0x3d	; 61
    6a18:	be b7       	in	r27, 0x3e	; 62
    6a1a:	11 96       	adiw	r26, 0x01	; 1
    6a1c:	cd 93       	st	X+, r28
    6a1e:	dc 93       	st	X, r29
    6a20:	12 97       	sbiw	r26, 0x02	; 2
    6a22:	88 e9       	ldi	r24, 0x98	; 152
    6a24:	9b e0       	ldi	r25, 0x0B	; 11
    6a26:	13 96       	adiw	r26, 0x03	; 3
    6a28:	8d 93       	st	X+, r24
    6a2a:	9c 93       	st	X, r25
    6a2c:	14 97       	sbiw	r26, 0x04	; 4
    6a2e:	0a c0       	rjmp	.+20     	; 0x6a44 <icmpPrintHeader+0x13a>
      break;
    default:
      fprintf_P(stream, ("UNKNOWN"));
    6a30:	00 d0       	rcall	.+0      	; 0x6a32 <icmpPrintHeader+0x128>
    6a32:	0f 92       	push	r0
    6a34:	ed b7       	in	r30, 0x3d	; 61
    6a36:	fe b7       	in	r31, 0x3e	; 62
    6a38:	c1 83       	std	Z+1, r28	; 0x01
    6a3a:	d2 83       	std	Z+2, r29	; 0x02
    6a3c:	86 e1       	ldi	r24, 0x16	; 22
    6a3e:	95 e2       	ldi	r25, 0x25	; 37
    6a40:	83 83       	std	Z+3, r24	; 0x03
    6a42:	94 83       	std	Z+4, r25	; 0x04
    6a44:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      break;
  }
  fprintf_P(stream, PSTR("\r\n"));
    6a48:	ad b7       	in	r26, 0x3d	; 61
    6a4a:	be b7       	in	r27, 0x3e	; 62
    6a4c:	11 96       	adiw	r26, 0x01	; 1
    6a4e:	cd 93       	st	X+, r28
    6a50:	dc 93       	st	X, r29
    6a52:	12 97       	sbiw	r26, 0x02	; 2
    6a54:	85 e9       	ldi	r24, 0x95	; 149
    6a56:	9b e0       	ldi	r25, 0x0B	; 11
    6a58:	13 96       	adiw	r26, 0x03	; 3
    6a5a:	8d 93       	st	X+, r24
    6a5c:	9c 93       	st	X, r25
    6a5e:	14 97       	sbiw	r26, 0x04	; 4
    6a60:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print code
  fprintf_P(stream, PSTR("Code   : 0x%x\r\n"), icmpPacket->icode);
    6a64:	0f 92       	push	r0
    6a66:	0f 92       	push	r0
    6a68:	ed b7       	in	r30, 0x3d	; 61
    6a6a:	fe b7       	in	r31, 0x3e	; 62
    6a6c:	31 96       	adiw	r30, 0x01	; 1
    6a6e:	ad b7       	in	r26, 0x3d	; 61
    6a70:	be b7       	in	r27, 0x3e	; 62
    6a72:	11 96       	adiw	r26, 0x01	; 1
    6a74:	cd 93       	st	X+, r28
    6a76:	dc 93       	st	X, r29
    6a78:	12 97       	sbiw	r26, 0x02	; 2
    6a7a:	85 e8       	ldi	r24, 0x85	; 133
    6a7c:	9b e0       	ldi	r25, 0x0B	; 11
    6a7e:	82 83       	std	Z+2, r24	; 0x02
    6a80:	93 83       	std	Z+3, r25	; 0x03
    6a82:	d7 01       	movw	r26, r14
    6a84:	11 96       	adiw	r26, 0x01	; 1
    6a86:	8c 91       	ld	r24, X
    6a88:	84 83       	std	Z+4, r24	; 0x04
    6a8a:	15 82       	std	Z+5, r1	; 0x05
    6a8c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6a90:	ed b7       	in	r30, 0x3d	; 61
    6a92:	fe b7       	in	r31, 0x3e	; 62
    6a94:	36 96       	adiw	r30, 0x06	; 6
    6a96:	ed bf       	out	0x3d, r30	; 61
    6a98:	fe bf       	out	0x3e, r31	; 62
}
    6a9a:	df 91       	pop	r29
    6a9c:	cf 91       	pop	r28
    6a9e:	1f 91       	pop	r17
    6aa0:	0f 91       	pop	r16
    6aa2:	ff 90       	pop	r15
    6aa4:	ef 90       	pop	r14
    6aa6:	08 95       	ret

00006aa8 <icmpEchoRequest>:
      break;
  }
}

void icmpEchoRequest(void)
{
    6aa8:	cf 93       	push	r28
    6aaa:	df 93       	push	r29
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6aac:	80 91 0a 32 	lds	r24, 0x320A
    6ab0:	90 91 0b 32 	lds	r25, 0x320B
    6ab4:	00 97       	sbiw	r24, 0x00	; 0
    6ab6:	a1 f0       	breq	.+40     	; 0x6ae0 <icmpEchoRequest+0x38>
  {
    if (icmpDebugLevel > 1)
    6ab8:	20 91 ad 32 	lds	r18, 0x32AD
    6abc:	22 30       	cpi	r18, 0x02	; 2
    6abe:	80 f0       	brcs	.+32     	; 0x6ae0 <icmpEchoRequest+0x38>
      fprintf_P(icmpDebug, PSTR("Received ICMP request: "));
    6ac0:	00 d0       	rcall	.+0      	; 0x6ac2 <icmpEchoRequest+0x1a>
    6ac2:	0f 92       	push	r0
    6ac4:	ed b7       	in	r30, 0x3d	; 61
    6ac6:	fe b7       	in	r31, 0x3e	; 62
    6ac8:	81 83       	std	Z+1, r24	; 0x01
    6aca:	92 83       	std	Z+2, r25	; 0x02
    6acc:	8b ef       	ldi	r24, 0xFB	; 251
    6ace:	9b e0       	ldi	r25, 0x0B	; 11
    6ad0:	83 83       	std	Z+3, r24	; 0x03
    6ad2:	94 83       	std	Z+4, r25	; 0x04
    6ad4:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6ad8:	0f 90       	pop	r0
    6ada:	0f 90       	pop	r0
    6adc:	0f 90       	pop	r0
    6ade:	0f 90       	pop	r0
  }
#endif
  uint32_t tempIp;

  // change type to reply
  nicState.layer4.icmp->type = ICMP_TYPE_ECHOREPLY;
    6ae0:	e0 91 e8 31 	lds	r30, 0x31E8
    6ae4:	f0 91 e9 31 	lds	r31, 0x31E9
    6ae8:	10 82       	st	Z, r1
  // recalculate checksum
  nicState.layer4.icmp->icmpchksum = 0;
    6aea:	e0 91 e8 31 	lds	r30, 0x31E8
    6aee:	f0 91 e9 31 	lds	r31, 0x31E9
    6af2:	12 82       	std	Z+2, r1	; 0x02
    6af4:	13 82       	std	Z+3, r1	; 0x03
  nicState.layer4.icmp->icmpchksum = netChecksum((uint8_t*)(nicState.layer4.icmp), htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
    6af6:	c0 91 e8 31 	lds	r28, 0x31E8
    6afa:	d0 91 e9 31 	lds	r29, 0x31E9
    6afe:	e0 91 e6 31 	lds	r30, 0x31E6
    6b02:	f0 91 e7 31 	lds	r31, 0x31E7
    6b06:	82 81       	ldd	r24, Z+2	; 0x02
    6b08:	93 81       	ldd	r25, Z+3	; 0x03
    6b0a:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    6b0e:	bc 01       	movw	r22, r24
    6b10:	64 51       	subi	r22, 0x14	; 20
    6b12:	70 40       	sbci	r23, 0x00	; 0
    6b14:	ce 01       	movw	r24, r28
    6b16:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <netChecksum>
    6b1a:	8a 83       	std	Y+2, r24	; 0x02
    6b1c:	9b 83       	std	Y+3, r25	; 0x03
  // return to sender
  tempIp = nicState.layer3.ip->destipaddr;
    6b1e:	e0 91 e6 31 	lds	r30, 0x31E6
    6b22:	f0 91 e7 31 	lds	r31, 0x31E7
    6b26:	80 89       	ldd	r24, Z+16	; 0x10
    6b28:	91 89       	ldd	r25, Z+17	; 0x11
    6b2a:	a2 89       	ldd	r26, Z+18	; 0x12
    6b2c:	b3 89       	ldd	r27, Z+19	; 0x13
  nicState.layer3.ip->destipaddr = nicState.layer3.ip->srcipaddr;
    6b2e:	24 85       	ldd	r18, Z+12	; 0x0c
    6b30:	35 85       	ldd	r19, Z+13	; 0x0d
    6b32:	46 85       	ldd	r20, Z+14	; 0x0e
    6b34:	57 85       	ldd	r21, Z+15	; 0x0f
    6b36:	20 8b       	std	Z+16, r18	; 0x10
    6b38:	31 8b       	std	Z+17, r19	; 0x11
    6b3a:	42 8b       	std	Z+18, r20	; 0x12
    6b3c:	53 8b       	std	Z+19, r21	; 0x13
  nicState.layer3.ip->srcipaddr = tempIp;
    6b3e:	84 87       	std	Z+12, r24	; 0x0c
    6b40:	95 87       	std	Z+13, r25	; 0x0d
    6b42:	a6 87       	std	Z+14, r26	; 0x0e
    6b44:	b7 87       	std	Z+15, r27	; 0x0f
  // add ethernet routing
  arpIpOut(0);
    6b46:	60 e0       	ldi	r22, 0x00	; 0
    6b48:	70 e0       	ldi	r23, 0x00	; 0
    6b4a:	cb 01       	movw	r24, r22
    6b4c:	0e 94 42 36 	call	0x6c84	; 0x6c84 <arpIpOut>

  // debugging
  if (icmpDebug != NULL)
    6b50:	80 91 0a 32 	lds	r24, 0x320A
    6b54:	90 91 0b 32 	lds	r25, 0x320B
    6b58:	00 97       	sbiw	r24, 0x00	; 0
    6b5a:	51 f0       	breq	.+20     	; 0x6b70 <icmpEchoRequest+0xc8>
    icmpPrintHeader(icmpDebug, nicState.layer3.ip, nicState.layer4.icmp);
    6b5c:	60 91 e6 31 	lds	r22, 0x31E6
    6b60:	70 91 e7 31 	lds	r23, 0x31E7
    6b64:	40 91 e8 31 	lds	r20, 0x31E8
    6b68:	50 91 e9 31 	lds	r21, 0x31E9
    6b6c:	0e 94 85 34 	call	0x690a	; 0x690a <icmpPrintHeader>
  //debugPrintHexTable(htons(packet->ip.len), (uint8_t*)packet);

  // send it (packet->ip.len+ETH_HEADER_LEN
  nicSend(htons(nicState.layer3.ip->len) + ETH_HEADER_LEN);
    6b70:	e0 91 e6 31 	lds	r30, 0x31E6
    6b74:	f0 91 e7 31 	lds	r31, 0x31E7
    6b78:	82 81       	ldd	r24, Z+2	; 0x02
    6b7a:	93 81       	ldd	r25, Z+3	; 0x03
    6b7c:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    6b80:	0e 96       	adiw	r24, 0x0e	; 14
    6b82:	0e 94 ce 2b 	call	0x579c	; 0x579c <nicSend>
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6b86:	80 91 0a 32 	lds	r24, 0x320A
    6b8a:	90 91 0b 32 	lds	r25, 0x320B
    6b8e:	00 97       	sbiw	r24, 0x00	; 0
    6b90:	a1 f0       	breq	.+40     	; 0x6bba <icmpEchoRequest+0x112>
  {
    if (icmpDebugLevel > 1)
    6b92:	20 91 ad 32 	lds	r18, 0x32AD
    6b96:	22 30       	cpi	r18, 0x02	; 2
    6b98:	80 f0       	brcs	.+32     	; 0x6bba <icmpEchoRequest+0x112>
      fprintf_P(icmpDebug, PSTR("Sending ICMP PONG\r\n"));
    6b9a:	00 d0       	rcall	.+0      	; 0x6b9c <icmpEchoRequest+0xf4>
    6b9c:	0f 92       	push	r0
    6b9e:	ed b7       	in	r30, 0x3d	; 61
    6ba0:	fe b7       	in	r31, 0x3e	; 62
    6ba2:	81 83       	std	Z+1, r24	; 0x01
    6ba4:	92 83       	std	Z+2, r25	; 0x02
    6ba6:	87 ee       	ldi	r24, 0xE7	; 231
    6ba8:	9b e0       	ldi	r25, 0x0B	; 11
    6baa:	83 83       	std	Z+3, r24	; 0x03
    6bac:	94 83       	std	Z+4, r25	; 0x04
    6bae:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6bb2:	0f 90       	pop	r0
    6bb4:	0f 90       	pop	r0
    6bb6:	0f 90       	pop	r0
    6bb8:	0f 90       	pop	r0
  }
#endif
}
    6bba:	df 91       	pop	r29
    6bbc:	cf 91       	pop	r28
    6bbe:	08 95       	ret

00006bc0 <icmpIpIn>:
}

void icmpIpIn(void)
{
  // check ICMP type
  switch(nicState.layer4.icmp->type)
    6bc0:	e0 91 e8 31 	lds	r30, 0x31E8
    6bc4:	f0 91 e9 31 	lds	r31, 0x31E9
    6bc8:	80 81       	ld	r24, Z
    6bca:	88 30       	cpi	r24, 0x08	; 8
    6bcc:	19 f4       	brne	.+6      	; 0x6bd4 <icmpIpIn+0x14>
  {
    case ICMP_TYPE_ECHOREQUEST:
      icmpEchoRequest();       // echo request
    6bce:	0e 94 54 35 	call	0x6aa8	; 0x6aa8 <icmpEchoRequest>
      break;
    6bd2:	08 95       	ret
    default:
#if ICMP_DEBUG
      if (icmpDebug != NULL)
    6bd4:	80 91 0a 32 	lds	r24, 0x320A
    6bd8:	90 91 0b 32 	lds	r25, 0x320B
    6bdc:	00 97       	sbiw	r24, 0x00	; 0
    6bde:	a1 f0       	breq	.+40     	; 0x6c08 <icmpIpIn+0x48>
      {
        if (icmpDebugLevel > 0)
    6be0:	20 91 ad 32 	lds	r18, 0x32AD
    6be4:	22 23       	and	r18, r18
    6be6:	81 f0       	breq	.+32     	; 0x6c08 <icmpIpIn+0x48>
          fprintf_P(icmpDebug, PSTR("Unknown ICMP typeReceived ICMP request: "));
    6be8:	00 d0       	rcall	.+0      	; 0x6bea <icmpIpIn+0x2a>
    6bea:	0f 92       	push	r0
    6bec:	ed b7       	in	r30, 0x3d	; 61
    6bee:	fe b7       	in	r31, 0x3e	; 62
    6bf0:	81 83       	std	Z+1, r24	; 0x01
    6bf2:	92 83       	std	Z+2, r25	; 0x02
    6bf4:	83 e1       	ldi	r24, 0x13	; 19
    6bf6:	9c e0       	ldi	r25, 0x0C	; 12
    6bf8:	83 83       	std	Z+3, r24	; 0x03
    6bfa:	94 83       	std	Z+4, r25	; 0x04
    6bfc:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6c00:	0f 90       	pop	r0
    6c02:	0f 90       	pop	r0
    6c04:	0f 90       	pop	r0
    6c06:	0f 90       	pop	r0
    6c08:	08 95       	ret

00006c0a <setArpDebug>:

#ifdef ARP_DEBUG

void setArpDebug(FILE *stream, uint8_t level)
{
  arpDebug = stream;
    6c0a:	80 93 ec 31 	sts	0x31EC, r24
    6c0e:	90 93 ed 31 	sts	0x31ED, r25
  arpDebugLevel = level;
    6c12:	60 93 bf 32 	sts	0x32BF, r22
  if (level == 0)
    6c16:	66 23       	and	r22, r22
    6c18:	21 f4       	brne	.+8      	; 0x6c22 <setArpDebug+0x18>
    arpDebug = NULL;
    6c1a:	10 92 ec 31 	sts	0x31EC, r1
    6c1e:	10 92 ed 31 	sts	0x31ED, r1
    6c22:	08 95       	ret

00006c24 <arpInit>:
#endif /*ARP_DEBUG*/

void arpInit()
{

  memset(ArpTable, 0, sizeof(ArpTable));
    6c24:	8e e6       	ldi	r24, 0x6E	; 110
    6c26:	ea ec       	ldi	r30, 0xCA	; 202
    6c28:	f2 e3       	ldi	r31, 0x32	; 50
    6c2a:	df 01       	movw	r26, r30
    6c2c:	1d 92       	st	X+, r1
    6c2e:	8a 95       	dec	r24
    6c30:	e9 f7       	brne	.-6      	; 0x6c2c <arpInit+0x8>
  arpDebug = NULL;
    6c32:	10 92 ec 31 	sts	0x31EC, r1
    6c36:	10 92 ed 31 	sts	0x31ED, r1
}
    6c3a:	08 95       	ret

00006c3c <arpTimer>:
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}

void arpTimer(void)
{
    6c3c:	e4 ed       	ldi	r30, 0xD4	; 212
    6c3e:	f2 e3       	ldi	r31, 0x32	; 50
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time)
    6c40:	80 81       	ld	r24, Z
    6c42:	88 23       	and	r24, r24
    6c44:	11 f0       	breq	.+4      	; 0x6c4a <arpTimer+0xe>
      ArpTable[index].time--;
    6c46:	81 50       	subi	r24, 0x01	; 1
    6c48:	80 83       	st	Z, r24
    6c4a:	3b 96       	adiw	r30, 0x0b	; 11
{
  int index;
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6c4c:	83 e3       	ldi	r24, 0x33	; 51
    6c4e:	e2 34       	cpi	r30, 0x42	; 66
    6c50:	f8 07       	cpc	r31, r24
    6c52:	b1 f7       	brne	.-20     	; 0x6c40 <arpTimer+0x4>
  {
    if(ArpTable[index].time)
      ArpTable[index].time--;
  }
}
    6c54:	08 95       	ret

00006c56 <arpMatchIp>:
      return i;
    }
  }

// no match
  return -1;
    6c56:	aa ec       	ldi	r26, 0xCA	; 202
    6c58:	b2 e3       	ldi	r27, 0x32	; 50
      ArpTable[index].time--;
  }
}

int arpMatchIp(uint32_t ipaddr)
{
    6c5a:	e0 e0       	ldi	r30, 0x00	; 0
    6c5c:	f0 e0       	ldi	r31, 0x00	; 0
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    6c5e:	2d 91       	ld	r18, X+
    6c60:	3d 91       	ld	r19, X+
    6c62:	4d 91       	ld	r20, X+
    6c64:	5c 91       	ld	r21, X
    6c66:	13 97       	sbiw	r26, 0x03	; 3
    6c68:	26 17       	cp	r18, r22
    6c6a:	37 07       	cpc	r19, r23
    6c6c:	48 07       	cpc	r20, r24
    6c6e:	59 07       	cpc	r21, r25
    6c70:	39 f0       	breq	.+14     	; 0x6c80 <arpMatchIp+0x2a>
    6c72:	31 96       	adiw	r30, 0x01	; 1
    6c74:	1b 96       	adiw	r26, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    6c76:	ea 30       	cpi	r30, 0x0A	; 10
    6c78:	f1 05       	cpc	r31, r1
    6c7a:	89 f7       	brne	.-30     	; 0x6c5e <arpMatchIp+0x8>
      return i;
    }
  }

// no match
  return -1;
    6c7c:	ef ef       	ldi	r30, 0xFF	; 255
    6c7e:	ff ef       	ldi	r31, 0xFF	; 255
}
    6c80:	cf 01       	movw	r24, r30
    6c82:	08 95       	ret

00006c84 <arpIpOut>:
void arpIpOut(uint32_t phyDstIp)
{
  int index;
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    6c84:	61 15       	cp	r22, r1
    6c86:	71 05       	cpc	r23, r1
    6c88:	81 05       	cpc	r24, r1
    6c8a:	91 05       	cpc	r25, r1
    6c8c:	41 f4       	brne	.+16     	; 0x6c9e <arpIpOut+0x1a>
    index = arpMatchIp(phyDstIp);
  else
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
    6c8e:	e0 91 e6 31 	lds	r30, 0x31E6
    6c92:	f0 91 e7 31 	lds	r31, 0x31E7
    6c96:	60 89       	ldd	r22, Z+16	; 0x10
    6c98:	71 89       	ldd	r23, Z+17	; 0x11
    6c9a:	82 89       	ldd	r24, Z+18	; 0x12
    6c9c:	93 89       	ldd	r25, Z+19	; 0x13
    6c9e:	0e 94 2b 36 	call	0x6c56	; 0x6c56 <arpMatchIp>
    6ca2:	a0 91 e4 31 	lds	r26, 0x31E4
    6ca6:	b0 91 e5 31 	lds	r27, 0x31E5
// fill in ethernet info
  if(index != -1)
    6caa:	2f ef       	ldi	r18, 0xFF	; 255
    6cac:	8f 3f       	cpi	r24, 0xFF	; 255
    6cae:	92 07       	cpc	r25, r18
    6cb0:	01 f1       	breq	.+64     	; 0x6cf2 <arpIpOut+0x6e>
  {
// ARP entry present, fill eth address(es)
    nicState.layer2.ethHeader->src      = nicState.mac;
    6cb2:	16 96       	adiw	r26, 0x06	; 6
    6cb4:	ee ed       	ldi	r30, 0xDE	; 222
    6cb6:	f1 e3       	ldi	r31, 0x31	; 49
    6cb8:	26 e0       	ldi	r18, 0x06	; 6
    6cba:	01 90       	ld	r0, Z+
    6cbc:	0d 92       	st	X+, r0
    6cbe:	21 50       	subi	r18, 0x01	; 1
    6cc0:	e1 f7       	brne	.-8      	; 0x6cba <arpIpOut+0x36>
    nicState.layer2.ethHeader->dest     = ArpTable[index].ethaddr;
    6cc2:	2b e0       	ldi	r18, 0x0B	; 11
    6cc4:	30 e0       	ldi	r19, 0x00	; 0
    6cc6:	82 9f       	mul	r24, r18
    6cc8:	f0 01       	movw	r30, r0
    6cca:	83 9f       	mul	r24, r19
    6ccc:	f0 0d       	add	r31, r0
    6cce:	92 9f       	mul	r25, r18
    6cd0:	f0 0d       	add	r31, r0
    6cd2:	11 24       	eor	r1, r1
    6cd4:	30 91 e4 31 	lds	r19, 0x31E4
    6cd8:	20 91 e5 31 	lds	r18, 0x31E5
    6cdc:	83 2f       	mov	r24, r19
    6cde:	92 2f       	mov	r25, r18
    6ce0:	dc 01       	movw	r26, r24
    6ce2:	e2 53       	subi	r30, 0x32	; 50
    6ce4:	fd 4c       	sbci	r31, 0xCD	; 205
    6ce6:	86 e0       	ldi	r24, 0x06	; 6
    6ce8:	01 90       	ld	r0, Z+
    6cea:	0d 92       	st	X+, r0
    6cec:	81 50       	subi	r24, 0x01	; 1
    6cee:	e1 f7       	brne	.-8      	; 0x6ce8 <arpIpOut+0x64>
    6cf0:	12 c0       	rjmp	.+36     	; 0x6d16 <arpIpOut+0x92>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
  }
  else
  {
// not in table, must send ARP request
    nicState.layer2.ethHeader->src      = nicState.mac;
    6cf2:	16 96       	adiw	r26, 0x06	; 6
    6cf4:	ee ed       	ldi	r30, 0xDE	; 222
    6cf6:	f1 e3       	ldi	r31, 0x31	; 49
    6cf8:	86 e0       	ldi	r24, 0x06	; 6
    6cfa:	01 90       	ld	r0, Z+
    6cfc:	0d 92       	st	X+, r0
    6cfe:	81 50       	subi	r24, 0x01	; 1
    6d00:	e1 f7       	brne	.-8      	; 0x6cfa <arpIpOut+0x76>
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    6d02:	80 91 e4 31 	lds	r24, 0x31E4
    6d06:	90 91 e5 31 	lds	r25, 0x31E5
    6d0a:	6f ef       	ldi	r22, 0xFF	; 255
    6d0c:	70 e0       	ldi	r23, 0x00	; 0
    6d0e:	46 e0       	ldi	r20, 0x06	; 6
    6d10:	50 e0       	ldi	r21, 0x00	; 0
    6d12:	0e 94 d2 56 	call	0xada4	; 0xada4 <memset>
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
    6d16:	e0 91 e4 31 	lds	r30, 0x31E4
    6d1a:	f0 91 e5 31 	lds	r31, 0x31E5
    6d1e:	88 e0       	ldi	r24, 0x08	; 8
    6d20:	90 e0       	ldi	r25, 0x00	; 0
    6d22:	84 87       	std	Z+12, r24	; 0x0c
    6d24:	95 87       	std	Z+13, r25	; 0x0d
    6d26:	08 95       	ret

00006d28 <arpIpIn>:
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
  }
}

void arpIpIn(void)
{
    6d28:	cf 93       	push	r28
    6d2a:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    6d2c:	80 91 ec 31 	lds	r24, 0x31EC
    6d30:	90 91 ed 31 	lds	r25, 0x31ED
    6d34:	00 97       	sbiw	r24, 0x00	; 0
    6d36:	09 f4       	brne	.+2      	; 0x6d3a <arpIpIn+0x12>
    6d38:	57 c0       	rjmp	.+174    	; 0x6de8 <arpIpIn+0xc0>
  {
    if (arpDebugLevel > 0)
    6d3a:	20 91 bf 32 	lds	r18, 0x32BF
    6d3e:	22 23       	and	r18, r18
    6d40:	09 f4       	brne	.+2      	; 0x6d44 <arpIpIn+0x1c>
    6d42:	52 c0       	rjmp	.+164    	; 0x6de8 <arpIpIn+0xc0>
    {
      fprintf_P(arpDebug, PSTR("ARP IP in MAC: "));
    6d44:	00 d0       	rcall	.+0      	; 0x6d46 <arpIpIn+0x1e>
    6d46:	0f 92       	push	r0
    6d48:	ed b7       	in	r30, 0x3d	; 61
    6d4a:	fe b7       	in	r31, 0x3e	; 62
    6d4c:	81 83       	std	Z+1, r24	; 0x01
    6d4e:	92 83       	std	Z+2, r25	; 0x02
    6d50:	86 e2       	ldi	r24, 0x26	; 38
    6d52:	9d e0       	ldi	r25, 0x0D	; 13
    6d54:	83 83       	std	Z+3, r24	; 0x03
    6d56:	94 83       	std	Z+4, r25	; 0x04
    6d58:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      netPrintEthAddr(arpDebug, &nicState.layer2.ethHeader->src);
    6d5c:	0f 90       	pop	r0
    6d5e:	0f 90       	pop	r0
    6d60:	0f 90       	pop	r0
    6d62:	0f 90       	pop	r0
    6d64:	60 91 e4 31 	lds	r22, 0x31E4
    6d68:	70 91 e5 31 	lds	r23, 0x31E5
    6d6c:	6a 5f       	subi	r22, 0xFA	; 250
    6d6e:	7f 4f       	sbci	r23, 0xFF	; 255
    6d70:	80 91 ec 31 	lds	r24, 0x31EC
    6d74:	90 91 ed 31 	lds	r25, 0x31ED
    6d78:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
      fprintf_P(arpDebug, PSTR(" IP: "));
    6d7c:	00 d0       	rcall	.+0      	; 0x6d7e <arpIpIn+0x56>
    6d7e:	0f 92       	push	r0
    6d80:	80 91 ec 31 	lds	r24, 0x31EC
    6d84:	90 91 ed 31 	lds	r25, 0x31ED
    6d88:	ed b7       	in	r30, 0x3d	; 61
    6d8a:	fe b7       	in	r31, 0x3e	; 62
    6d8c:	81 83       	std	Z+1, r24	; 0x01
    6d8e:	92 83       	std	Z+2, r25	; 0x02
    6d90:	80 e2       	ldi	r24, 0x20	; 32
    6d92:	9d e0       	ldi	r25, 0x0D	; 13
    6d94:	83 83       	std	Z+3, r24	; 0x03
    6d96:	94 83       	std	Z+4, r25	; 0x04
    6d98:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      netPrintIPAddr(arpDebug, nicState.layer3.ip->srcipaddr);
    6d9c:	0f 90       	pop	r0
    6d9e:	0f 90       	pop	r0
    6da0:	0f 90       	pop	r0
    6da2:	0f 90       	pop	r0
    6da4:	e0 91 e6 31 	lds	r30, 0x31E6
    6da8:	f0 91 e7 31 	lds	r31, 0x31E7
    6dac:	44 85       	ldd	r20, Z+12	; 0x0c
    6dae:	55 85       	ldd	r21, Z+13	; 0x0d
    6db0:	66 85       	ldd	r22, Z+14	; 0x0e
    6db2:	77 85       	ldd	r23, Z+15	; 0x0f
    6db4:	80 91 ec 31 	lds	r24, 0x31EC
    6db8:	90 91 ed 31 	lds	r25, 0x31ED
    6dbc:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
      fprintf_P(arpDebug, PSTR("\r\n"));
    6dc0:	00 d0       	rcall	.+0      	; 0x6dc2 <arpIpIn+0x9a>
    6dc2:	0f 92       	push	r0
    6dc4:	80 91 ec 31 	lds	r24, 0x31EC
    6dc8:	90 91 ed 31 	lds	r25, 0x31ED
    6dcc:	ed b7       	in	r30, 0x3d	; 61
    6dce:	fe b7       	in	r31, 0x3e	; 62
    6dd0:	81 83       	std	Z+1, r24	; 0x01
    6dd2:	92 83       	std	Z+2, r25	; 0x02
    6dd4:	8d e1       	ldi	r24, 0x1D	; 29
    6dd6:	9d e0       	ldi	r25, 0x0D	; 13
    6dd8:	83 83       	std	Z+3, r24	; 0x03
    6dda:	94 83       	std	Z+4, r25	; 0x04
    6ddc:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6de0:	0f 90       	pop	r0
    6de2:	0f 90       	pop	r0
    6de4:	0f 90       	pop	r0
    6de6:	0f 90       	pop	r0
  }
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
    6de8:	c0 91 e6 31 	lds	r28, 0x31E6
    6dec:	d0 91 e7 31 	lds	r29, 0x31E7
    6df0:	6c 85       	ldd	r22, Y+12	; 0x0c
    6df2:	7d 85       	ldd	r23, Y+13	; 0x0d
    6df4:	8e 85       	ldd	r24, Y+14	; 0x0e
    6df6:	9f 85       	ldd	r25, Y+15	; 0x0f
    6df8:	0e 94 2b 36 	call	0x6c56	; 0x6c56 <arpMatchIp>
  if(index != -1)
    6dfc:	8f 3f       	cpi	r24, 0xFF	; 255
    6dfe:	21 f1       	breq	.+72     	; 0x6e48 <arpIpIn+0x120>
  {
// sender's IP address found, update ARP entry
    ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6e00:	99 27       	eor	r25, r25
    6e02:	87 fd       	sbrc	r24, 7
    6e04:	90 95       	com	r25
    6e06:	2b e0       	ldi	r18, 0x0B	; 11
    6e08:	30 e0       	ldi	r19, 0x00	; 0
    6e0a:	82 9f       	mul	r24, r18
    6e0c:	d0 01       	movw	r26, r0
    6e0e:	83 9f       	mul	r24, r19
    6e10:	b0 0d       	add	r27, r0
    6e12:	92 9f       	mul	r25, r18
    6e14:	b0 0d       	add	r27, r0
    6e16:	11 24       	eor	r1, r1
    6e18:	e0 91 e4 31 	lds	r30, 0x31E4
    6e1c:	f0 91 e5 31 	lds	r31, 0x31E5
    6e20:	a2 53       	subi	r26, 0x32	; 50
    6e22:	bd 4c       	sbci	r27, 0xCD	; 205
    6e24:	36 96       	adiw	r30, 0x06	; 6
    6e26:	26 e0       	ldi	r18, 0x06	; 6
    6e28:	01 90       	ld	r0, Z+
    6e2a:	0d 92       	st	X+, r0
    6e2c:	21 50       	subi	r18, 0x01	; 1
    6e2e:	e1 f7       	brne	.-8      	; 0x6e28 <arpIpIn+0x100>
    ArpTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    6e30:	2b e0       	ldi	r18, 0x0B	; 11
    6e32:	30 e0       	ldi	r19, 0x00	; 0
    6e34:	82 9f       	mul	r24, r18
    6e36:	f0 01       	movw	r30, r0
    6e38:	83 9f       	mul	r24, r19
    6e3a:	f0 0d       	add	r31, r0
    6e3c:	92 9f       	mul	r25, r18
    6e3e:	f0 0d       	add	r31, r0
    6e40:	11 24       	eor	r1, r1
    6e42:	e6 53       	subi	r30, 0x36	; 54
    6e44:	fd 4c       	sbci	r31, 0xCD	; 205
    6e46:	2f c0       	rjmp	.+94     	; 0x6ea6 <arpIpIn+0x17e>
// and we're done
    return;
    6e48:	e4 ed       	ldi	r30, 0xD4	; 212
    6e4a:	f2 e3       	ldi	r31, 0x32	; 50
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
  if(index != -1)
    6e4c:	80 e0       	ldi	r24, 0x00	; 0
    6e4e:	90 e0       	ldi	r25, 0x00	; 0

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time == 0)
    6e50:	20 81       	ld	r18, Z
    6e52:	22 23       	and	r18, r18
    6e54:	59 f5       	brne	.+86     	; 0x6eac <arpIpIn+0x184>
    {
// write entry
      ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6e56:	2b e0       	ldi	r18, 0x0B	; 11
    6e58:	30 e0       	ldi	r19, 0x00	; 0
    6e5a:	82 9f       	mul	r24, r18
    6e5c:	d0 01       	movw	r26, r0
    6e5e:	83 9f       	mul	r24, r19
    6e60:	b0 0d       	add	r27, r0
    6e62:	92 9f       	mul	r25, r18
    6e64:	b0 0d       	add	r27, r0
    6e66:	11 24       	eor	r1, r1
    6e68:	e0 91 e4 31 	lds	r30, 0x31E4
    6e6c:	f0 91 e5 31 	lds	r31, 0x31E5
    6e70:	a2 53       	subi	r26, 0x32	; 50
    6e72:	bd 4c       	sbci	r27, 0xCD	; 205
    6e74:	36 96       	adiw	r30, 0x06	; 6
    6e76:	26 e0       	ldi	r18, 0x06	; 6
    6e78:	01 90       	ld	r0, Z+
    6e7a:	0d 92       	st	X+, r0
    6e7c:	21 50       	subi	r18, 0x01	; 1
    6e7e:	e1 f7       	brne	.-8      	; 0x6e78 <arpIpIn+0x150>
      ArpTable[index].ipaddr  = nicState.layer3.ip->srcipaddr;
    6e80:	2b e0       	ldi	r18, 0x0B	; 11
    6e82:	30 e0       	ldi	r19, 0x00	; 0
    6e84:	82 9f       	mul	r24, r18
    6e86:	f0 01       	movw	r30, r0
    6e88:	83 9f       	mul	r24, r19
    6e8a:	f0 0d       	add	r31, r0
    6e8c:	92 9f       	mul	r25, r18
    6e8e:	f0 0d       	add	r31, r0
    6e90:	11 24       	eor	r1, r1
    6e92:	e6 53       	subi	r30, 0x36	; 54
    6e94:	fd 4c       	sbci	r31, 0xCD	; 205
    6e96:	8c 85       	ldd	r24, Y+12	; 0x0c
    6e98:	9d 85       	ldd	r25, Y+13	; 0x0d
    6e9a:	ae 85       	ldd	r26, Y+14	; 0x0e
    6e9c:	bf 85       	ldd	r27, Y+15	; 0x0f
    6e9e:	80 83       	st	Z, r24
    6ea0:	91 83       	std	Z+1, r25	; 0x01
    6ea2:	a2 83       	std	Z+2, r26	; 0x02
    6ea4:	b3 83       	std	Z+3, r27	; 0x03
      ArpTable[index].time    = ARP_CACHE_TIME_TO_LIVE;
    6ea6:	80 e8       	ldi	r24, 0x80	; 128
    6ea8:	82 87       	std	Z+10, r24	; 0x0a
// and we're done
      return;
    6eaa:	05 c0       	rjmp	.+10     	; 0x6eb6 <arpIpIn+0x18e>
    6eac:	01 96       	adiw	r24, 0x01	; 1
    6eae:	3b 96       	adiw	r30, 0x0b	; 11
    return;
  }

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6eb0:	8a 30       	cpi	r24, 0x0A	; 10
    6eb2:	91 05       	cpc	r25, r1
    6eb4:	69 f6       	brne	.-102    	; 0x6e50 <arpIpIn+0x128>
// and we're done
      return;
    }
  }
// no space in table, we give up
}
    6eb6:	df 91       	pop	r29
    6eb8:	cf 91       	pop	r28
    6eba:	08 95       	ret

00006ebc <arpPrintHeader>:
  return -1;
}

#if ARP_DEBUG
void arpPrintHeader(FILE *stream, struct netArpHeader* packet)
{
    6ebc:	ef 92       	push	r14
    6ebe:	ff 92       	push	r15
    6ec0:	0f 93       	push	r16
    6ec2:	1f 93       	push	r17
    6ec4:	cf 93       	push	r28
    6ec6:	df 93       	push	r29
    6ec8:	ec 01       	movw	r28, r24
    6eca:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("ARP Packet:\r\n"));
    6ecc:	00 d0       	rcall	.+0      	; 0x6ece <arpPrintHeader+0x12>
    6ece:	0f 92       	push	r0
    6ed0:	ed b7       	in	r30, 0x3d	; 61
    6ed2:	fe b7       	in	r31, 0x3e	; 62
    6ed4:	81 83       	std	Z+1, r24	; 0x01
    6ed6:	92 83       	std	Z+2, r25	; 0x02
    6ed8:	8f e0       	ldi	r24, 0x0F	; 15
    6eda:	9d e0       	ldi	r25, 0x0D	; 13
    6edc:	83 83       	std	Z+3, r24	; 0x03
    6ede:	94 83       	std	Z+4, r25	; 0x04
    6ee0:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  //debugPrintHexTable(60, (unsigned char*)&packet);
  // print operation type
  fprintf_P(stream, PSTR("Operation   : "));
    6ee4:	ed b7       	in	r30, 0x3d	; 61
    6ee6:	fe b7       	in	r31, 0x3e	; 62
    6ee8:	c1 83       	std	Z+1, r28	; 0x01
    6eea:	d2 83       	std	Z+2, r29	; 0x02
    6eec:	80 e0       	ldi	r24, 0x00	; 0
    6eee:	9d e0       	ldi	r25, 0x0D	; 13
    6ef0:	83 83       	std	Z+3, r24	; 0x03
    6ef2:	94 83       	std	Z+4, r25	; 0x04
    6ef4:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  if(packet->opcode == htons(ARP_OPCODE_REQUEST))
    6ef8:	f8 01       	movw	r30, r16
    6efa:	e6 80       	ldd	r14, Z+6	; 0x06
    6efc:	f7 80       	ldd	r15, Z+7	; 0x07
    6efe:	0f 90       	pop	r0
    6f00:	0f 90       	pop	r0
    6f02:	0f 90       	pop	r0
    6f04:	0f 90       	pop	r0
    6f06:	81 e0       	ldi	r24, 0x01	; 1
    6f08:	90 e0       	ldi	r25, 0x00	; 0
    6f0a:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    6f0e:	e8 16       	cp	r14, r24
    6f10:	f9 06       	cpc	r15, r25
    6f12:	49 f4       	brne	.+18     	; 0x6f26 <arpPrintHeader+0x6a>
    fprintf_P(stream, PSTR("REQUEST"));
    6f14:	00 d0       	rcall	.+0      	; 0x6f16 <arpPrintHeader+0x5a>
    6f16:	0f 92       	push	r0
    6f18:	ed b7       	in	r30, 0x3d	; 61
    6f1a:	fe b7       	in	r31, 0x3e	; 62
    6f1c:	c1 83       	std	Z+1, r28	; 0x01
    6f1e:	d2 83       	std	Z+2, r29	; 0x02
    6f20:	88 ef       	ldi	r24, 0xF8	; 248
    6f22:	9c e0       	ldi	r25, 0x0C	; 12
    6f24:	1b c0       	rjmp	.+54     	; 0x6f5c <arpPrintHeader+0xa0>
  else if(packet->opcode == htons(ARP_OPCODE_REPLY))
    6f26:	f8 01       	movw	r30, r16
    6f28:	e6 80       	ldd	r14, Z+6	; 0x06
    6f2a:	f7 80       	ldd	r15, Z+7	; 0x07
    6f2c:	82 e0       	ldi	r24, 0x02	; 2
    6f2e:	90 e0       	ldi	r25, 0x00	; 0
    6f30:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    6f34:	e8 16       	cp	r14, r24
    6f36:	f9 06       	cpc	r15, r25
    6f38:	49 f4       	brne	.+18     	; 0x6f4c <arpPrintHeader+0x90>
    fprintf_P(stream, PSTR("REPLY"));
    6f3a:	00 d0       	rcall	.+0      	; 0x6f3c <arpPrintHeader+0x80>
    6f3c:	0f 92       	push	r0
    6f3e:	ed b7       	in	r30, 0x3d	; 61
    6f40:	fe b7       	in	r31, 0x3e	; 62
    6f42:	c1 83       	std	Z+1, r28	; 0x01
    6f44:	d2 83       	std	Z+2, r29	; 0x02
    6f46:	82 ef       	ldi	r24, 0xF2	; 242
    6f48:	9c e0       	ldi	r25, 0x0C	; 12
    6f4a:	08 c0       	rjmp	.+16     	; 0x6f5c <arpPrintHeader+0xa0>
  else
    fprintf_P(stream, PSTR("UNKNOWN"));
    6f4c:	00 d0       	rcall	.+0      	; 0x6f4e <arpPrintHeader+0x92>
    6f4e:	0f 92       	push	r0
    6f50:	ed b7       	in	r30, 0x3d	; 61
    6f52:	fe b7       	in	r31, 0x3e	; 62
    6f54:	c1 83       	std	Z+1, r28	; 0x01
    6f56:	d2 83       	std	Z+2, r29	; 0x02
    6f58:	8a ee       	ldi	r24, 0xEA	; 234
    6f5a:	9c e0       	ldi	r25, 0x0C	; 12
    6f5c:	83 83       	std	Z+3, r24	; 0x03
    6f5e:	94 83       	std	Z+4, r25	; 0x04
    6f60:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n"));
    6f64:	ed b7       	in	r30, 0x3d	; 61
    6f66:	fe b7       	in	r31, 0x3e	; 62
    6f68:	c1 83       	std	Z+1, r28	; 0x01
    6f6a:	d2 83       	std	Z+2, r29	; 0x02
    6f6c:	87 ee       	ldi	r24, 0xE7	; 231
    6f6e:	9c e0       	ldi	r25, 0x0C	; 12
    6f70:	83 83       	std	Z+3, r24	; 0x03
    6f72:	94 83       	std	Z+4, r25	; 0x04
    6f74:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print source hardware address
  fprintf_P(stream, PSTR("SrcHwAddr   : "));  netPrintEthAddr(stream, &packet->shwaddr);   fprintf_P(stream, PSTR("\r\n"));
    6f78:	ed b7       	in	r30, 0x3d	; 61
    6f7a:	fe b7       	in	r31, 0x3e	; 62
    6f7c:	c1 83       	std	Z+1, r28	; 0x01
    6f7e:	d2 83       	std	Z+2, r29	; 0x02
    6f80:	88 ed       	ldi	r24, 0xD8	; 216
    6f82:	9c e0       	ldi	r25, 0x0C	; 12
    6f84:	83 83       	std	Z+3, r24	; 0x03
    6f86:	94 83       	std	Z+4, r25	; 0x04
    6f88:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6f8c:	0f 90       	pop	r0
    6f8e:	0f 90       	pop	r0
    6f90:	0f 90       	pop	r0
    6f92:	0f 90       	pop	r0
    6f94:	b8 01       	movw	r22, r16
    6f96:	68 5f       	subi	r22, 0xF8	; 248
    6f98:	7f 4f       	sbci	r23, 0xFF	; 255
    6f9a:	ce 01       	movw	r24, r28
    6f9c:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
    6fa0:	00 d0       	rcall	.+0      	; 0x6fa2 <arpPrintHeader+0xe6>
    6fa2:	0f 92       	push	r0
    6fa4:	ed b7       	in	r30, 0x3d	; 61
    6fa6:	fe b7       	in	r31, 0x3e	; 62
    6fa8:	c1 83       	std	Z+1, r28	; 0x01
    6faa:	d2 83       	std	Z+2, r29	; 0x02
    6fac:	85 ed       	ldi	r24, 0xD5	; 213
    6fae:	9c e0       	ldi	r25, 0x0C	; 12
    6fb0:	83 83       	std	Z+3, r24	; 0x03
    6fb2:	94 83       	std	Z+4, r25	; 0x04
    6fb4:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print source protocol address
  fprintf_P(stream, PSTR("SrcProtoAddr: "));  netPrintIPAddr(stream, packet->sipaddr);     fprintf_P(stream, PSTR("\r\n"));
    6fb8:	ed b7       	in	r30, 0x3d	; 61
    6fba:	fe b7       	in	r31, 0x3e	; 62
    6fbc:	c1 83       	std	Z+1, r28	; 0x01
    6fbe:	d2 83       	std	Z+2, r29	; 0x02
    6fc0:	86 ec       	ldi	r24, 0xC6	; 198
    6fc2:	9c e0       	ldi	r25, 0x0C	; 12
    6fc4:	83 83       	std	Z+3, r24	; 0x03
    6fc6:	94 83       	std	Z+4, r25	; 0x04
    6fc8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    6fcc:	0f 90       	pop	r0
    6fce:	0f 90       	pop	r0
    6fd0:	0f 90       	pop	r0
    6fd2:	0f 90       	pop	r0
    6fd4:	f8 01       	movw	r30, r16
    6fd6:	46 85       	ldd	r20, Z+14	; 0x0e
    6fd8:	57 85       	ldd	r21, Z+15	; 0x0f
    6fda:	60 89       	ldd	r22, Z+16	; 0x10
    6fdc:	71 89       	ldd	r23, Z+17	; 0x11
    6fde:	ce 01       	movw	r24, r28
    6fe0:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    6fe4:	00 d0       	rcall	.+0      	; 0x6fe6 <arpPrintHeader+0x12a>
    6fe6:	0f 92       	push	r0
    6fe8:	ed b7       	in	r30, 0x3d	; 61
    6fea:	fe b7       	in	r31, 0x3e	; 62
    6fec:	c1 83       	std	Z+1, r28	; 0x01
    6fee:	d2 83       	std	Z+2, r29	; 0x02
    6ff0:	83 ec       	ldi	r24, 0xC3	; 195
    6ff2:	9c e0       	ldi	r25, 0x0C	; 12
    6ff4:	83 83       	std	Z+3, r24	; 0x03
    6ff6:	94 83       	std	Z+4, r25	; 0x04
    6ff8:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print target hardware address
  fprintf_P(stream, PSTR("DstHwAddr   : "));  netPrintEthAddr(stream, &packet->dhwaddr);   fprintf_P(stream, PSTR("\r\n"));
    6ffc:	ed b7       	in	r30, 0x3d	; 61
    6ffe:	fe b7       	in	r31, 0x3e	; 62
    7000:	c1 83       	std	Z+1, r28	; 0x01
    7002:	d2 83       	std	Z+2, r29	; 0x02
    7004:	84 eb       	ldi	r24, 0xB4	; 180
    7006:	9c e0       	ldi	r25, 0x0C	; 12
    7008:	83 83       	std	Z+3, r24	; 0x03
    700a:	94 83       	std	Z+4, r25	; 0x04
    700c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7010:	0f 90       	pop	r0
    7012:	0f 90       	pop	r0
    7014:	0f 90       	pop	r0
    7016:	0f 90       	pop	r0
    7018:	b8 01       	movw	r22, r16
    701a:	6e 5e       	subi	r22, 0xEE	; 238
    701c:	7f 4f       	sbci	r23, 0xFF	; 255
    701e:	ce 01       	movw	r24, r28
    7020:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
    7024:	00 d0       	rcall	.+0      	; 0x7026 <arpPrintHeader+0x16a>
    7026:	0f 92       	push	r0
    7028:	ed b7       	in	r30, 0x3d	; 61
    702a:	fe b7       	in	r31, 0x3e	; 62
    702c:	c1 83       	std	Z+1, r28	; 0x01
    702e:	d2 83       	std	Z+2, r29	; 0x02
    7030:	81 eb       	ldi	r24, 0xB1	; 177
    7032:	9c e0       	ldi	r25, 0x0C	; 12
    7034:	83 83       	std	Z+3, r24	; 0x03
    7036:	94 83       	std	Z+4, r25	; 0x04
    7038:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
// print target protocol address
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
    703c:	ed b7       	in	r30, 0x3d	; 61
    703e:	fe b7       	in	r31, 0x3e	; 62
    7040:	c1 83       	std	Z+1, r28	; 0x01
    7042:	d2 83       	std	Z+2, r29	; 0x02
    7044:	82 ea       	ldi	r24, 0xA2	; 162
    7046:	9c e0       	ldi	r25, 0x0C	; 12
    7048:	83 83       	std	Z+3, r24	; 0x03
    704a:	94 83       	std	Z+4, r25	; 0x04
    704c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7050:	0f 90       	pop	r0
    7052:	0f 90       	pop	r0
    7054:	0f 90       	pop	r0
    7056:	0f 90       	pop	r0
    7058:	f8 01       	movw	r30, r16
    705a:	40 8d       	ldd	r20, Z+24	; 0x18
    705c:	51 8d       	ldd	r21, Z+25	; 0x19
    705e:	62 8d       	ldd	r22, Z+26	; 0x1a
    7060:	73 8d       	ldd	r23, Z+27	; 0x1b
    7062:	ce 01       	movw	r24, r28
    7064:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    7068:	00 d0       	rcall	.+0      	; 0x706a <arpPrintHeader+0x1ae>
    706a:	0f 92       	push	r0
    706c:	ed b7       	in	r30, 0x3d	; 61
    706e:	fe b7       	in	r31, 0x3e	; 62
    7070:	c1 83       	std	Z+1, r28	; 0x01
    7072:	d2 83       	std	Z+2, r29	; 0x02
    7074:	8f e9       	ldi	r24, 0x9F	; 159
    7076:	9c e0       	ldi	r25, 0x0C	; 12
    7078:	83 83       	std	Z+3, r24	; 0x03
    707a:	94 83       	std	Z+4, r25	; 0x04
    707c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7080:	0f 90       	pop	r0
    7082:	0f 90       	pop	r0
    7084:	0f 90       	pop	r0
    7086:	0f 90       	pop	r0
}
    7088:	df 91       	pop	r29
    708a:	cf 91       	pop	r28
    708c:	1f 91       	pop	r17
    708e:	0f 91       	pop	r16
    7090:	ff 90       	pop	r15
    7092:	ef 90       	pop	r14
    7094:	08 95       	ret

00007096 <arpArpIn>:
  memset(ArpTable, 0, sizeof(ArpTable));
  arpDebug = NULL;
}

void arpArpIn(void)
{
    7096:	cf 93       	push	r28
    7098:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    709a:	80 91 ec 31 	lds	r24, 0x31EC
    709e:	90 91 ed 31 	lds	r25, 0x31ED
    70a2:	00 97       	sbiw	r24, 0x00	; 0
    70a4:	11 f1       	breq	.+68     	; 0x70ea <arpArpIn+0x54>
  {
    if (arpDebugLevel > 1)
    70a6:	20 91 bf 32 	lds	r18, 0x32BF
    70aa:	22 30       	cpi	r18, 0x02	; 2
    70ac:	80 f0       	brcs	.+32     	; 0x70ce <arpArpIn+0x38>
      fprintf_P(arpDebug, PSTR("Received ARP Request\r\n"));
    70ae:	00 d0       	rcall	.+0      	; 0x70b0 <arpArpIn+0x1a>
    70b0:	0f 92       	push	r0
    70b2:	ed b7       	in	r30, 0x3d	; 61
    70b4:	fe b7       	in	r31, 0x3e	; 62
    70b6:	81 83       	std	Z+1, r24	; 0x01
    70b8:	92 83       	std	Z+2, r25	; 0x02
    70ba:	8a e4       	ldi	r24, 0x4A	; 74
    70bc:	9d e0       	ldi	r25, 0x0D	; 13
    70be:	83 83       	std	Z+3, r24	; 0x03
    70c0:	94 83       	std	Z+4, r25	; 0x04
    70c2:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    70c6:	0f 90       	pop	r0
    70c8:	0f 90       	pop	r0
    70ca:	0f 90       	pop	r0
    70cc:	0f 90       	pop	r0
    if (arpDebugLevel > 2)
    70ce:	80 91 bf 32 	lds	r24, 0x32BF
    70d2:	83 30       	cpi	r24, 0x03	; 3
    70d4:	50 f0       	brcs	.+20     	; 0x70ea <arpArpIn+0x54>
      arpPrintHeader(arpDebug, nicState.layer3.arp);   
    70d6:	60 91 e6 31 	lds	r22, 0x31E6
    70da:	70 91 e7 31 	lds	r23, 0x31E7
    70de:	80 91 ec 31 	lds	r24, 0x31EC
    70e2:	90 91 ed 31 	lds	r25, 0x31ED
    70e6:	0e 94 5e 37 	call	0x6ebc	; 0x6ebc <arpPrintHeader>
  }
#endif

// for now, we just reply to requests
// need to add ARP cache
  if((nicState.layer3.arp->dipaddr == IpMyConfig.ip) && (nicState.layer3.arp->opcode == htons(ARP_OPCODE_REQUEST)) )
    70ea:	e0 91 e6 31 	lds	r30, 0x31E6
    70ee:	f0 91 e7 31 	lds	r31, 0x31E7
    70f2:	20 8d       	ldd	r18, Z+24	; 0x18
    70f4:	31 8d       	ldd	r19, Z+25	; 0x19
    70f6:	42 8d       	ldd	r20, Z+26	; 0x1a
    70f8:	53 8d       	ldd	r21, Z+27	; 0x1b
    70fa:	80 91 b0 32 	lds	r24, 0x32B0
    70fe:	90 91 b1 32 	lds	r25, 0x32B1
    7102:	a0 91 b2 32 	lds	r26, 0x32B2
    7106:	b0 91 b3 32 	lds	r27, 0x32B3
    710a:	28 17       	cp	r18, r24
    710c:	39 07       	cpc	r19, r25
    710e:	4a 07       	cpc	r20, r26
    7110:	5b 07       	cpc	r21, r27
    7112:	09 f0       	breq	.+2      	; 0x7116 <arpArpIn+0x80>
    7114:	80 c0       	rjmp	.+256    	; 0x7216 <arpArpIn+0x180>
    7116:	c6 81       	ldd	r28, Z+6	; 0x06
    7118:	d7 81       	ldd	r29, Z+7	; 0x07
    711a:	81 e0       	ldi	r24, 0x01	; 1
    711c:	90 e0       	ldi	r25, 0x00	; 0
    711e:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    7122:	c8 17       	cp	r28, r24
    7124:	d9 07       	cpc	r29, r25
    7126:	09 f0       	breq	.+2      	; 0x712a <arpArpIn+0x94>
    7128:	76 c0       	rjmp	.+236    	; 0x7216 <arpArpIn+0x180>
  {
// in ARP header
// copy sender's address info to dest. fields
    nicState.layer3.arp->dhwaddr = nicState.layer3.arp->shwaddr;
    712a:	e0 91 e6 31 	lds	r30, 0x31E6
    712e:	f0 91 e7 31 	lds	r31, 0x31E7
    7132:	ef 01       	movw	r28, r30
    7134:	62 96       	adiw	r28, 0x12	; 18
    7136:	df 01       	movw	r26, r30
    7138:	18 96       	adiw	r26, 0x08	; 8
    713a:	86 e0       	ldi	r24, 0x06	; 6
    713c:	0d 90       	ld	r0, X+
    713e:	09 92       	st	Y+, r0
    7140:	81 50       	subi	r24, 0x01	; 1
    7142:	e1 f7       	brne	.-8      	; 0x713c <arpArpIn+0xa6>
    nicState.layer3.arp->dipaddr = nicState.layer3.arp->sipaddr;
    7144:	86 85       	ldd	r24, Z+14	; 0x0e
    7146:	97 85       	ldd	r25, Z+15	; 0x0f
    7148:	a0 89       	ldd	r26, Z+16	; 0x10
    714a:	b1 89       	ldd	r27, Z+17	; 0x11
    714c:	80 8f       	std	Z+24, r24	; 0x18
    714e:	91 8f       	std	Z+25, r25	; 0x19
    7150:	a2 8f       	std	Z+26, r26	; 0x1a
    7152:	b3 8f       	std	Z+27, r27	; 0x1b
// fill in our information
    nicState.layer3.arp->shwaddr =  nicState.mac;
    7154:	38 96       	adiw	r30, 0x08	; 8
    7156:	ae ed       	ldi	r26, 0xDE	; 222
    7158:	b1 e3       	ldi	r27, 0x31	; 49
    715a:	86 e0       	ldi	r24, 0x06	; 6
    715c:	0d 90       	ld	r0, X+
    715e:	01 92       	st	Z+, r0
    7160:	81 50       	subi	r24, 0x01	; 1
    7162:	e1 f7       	brne	.-8      	; 0x715c <arpArpIn+0xc6>
    nicState.layer3.arp->sipaddr =  IpMyConfig.ip;
    7164:	c0 91 e6 31 	lds	r28, 0x31E6
    7168:	d0 91 e7 31 	lds	r29, 0x31E7
    716c:	80 91 b0 32 	lds	r24, 0x32B0
    7170:	90 91 b1 32 	lds	r25, 0x32B1
    7174:	a0 91 b2 32 	lds	r26, 0x32B2
    7178:	b0 91 b3 32 	lds	r27, 0x32B3
    717c:	8e 87       	std	Y+14, r24	; 0x0e
    717e:	9f 87       	std	Y+15, r25	; 0x0f
    7180:	a8 8b       	std	Y+16, r26	; 0x10
    7182:	b9 8b       	std	Y+17, r27	; 0x11
// change op to reply
    nicState.layer3.arp->opcode = htons(ARP_OPCODE_REPLY);
    7184:	82 e0       	ldi	r24, 0x02	; 2
    7186:	90 e0       	ldi	r25, 0x00	; 0
    7188:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    718c:	8e 83       	std	Y+6, r24	; 0x06
    718e:	9f 83       	std	Y+7, r25	; 0x07

// in ethernet header
    nicState.layer2.ethHeader->dest = nicState.layer2.ethHeader->src;
    7190:	e0 91 e4 31 	lds	r30, 0x31E4
    7194:	f0 91 e5 31 	lds	r31, 0x31E5
    7198:	df 01       	movw	r26, r30
    719a:	16 96       	adiw	r26, 0x06	; 6
    719c:	86 e0       	ldi	r24, 0x06	; 6
    719e:	0d 90       	ld	r0, X+
    71a0:	01 92       	st	Z+, r0
    71a2:	81 50       	subi	r24, 0x01	; 1
    71a4:	e1 f7       	brne	.-8      	; 0x719e <arpArpIn+0x108>
    nicState.layer2.ethHeader->src  = nicState.mac;
    71a6:	e0 91 e4 31 	lds	r30, 0x31E4
    71aa:	f0 91 e5 31 	lds	r31, 0x31E5
    71ae:	36 96       	adiw	r30, 0x06	; 6
    71b0:	ae ed       	ldi	r26, 0xDE	; 222
    71b2:	b1 e3       	ldi	r27, 0x31	; 49
    71b4:	86 e0       	ldi	r24, 0x06	; 6
    71b6:	0d 90       	ld	r0, X+
    71b8:	01 92       	st	Z+, r0
    71ba:	81 50       	subi	r24, 0x01	; 1
    71bc:	e1 f7       	brne	.-8      	; 0x71b6 <arpArpIn+0x120>

#ifdef ARP_DEBUG
    if (arpDebug != NULL)
    71be:	80 91 ec 31 	lds	r24, 0x31EC
    71c2:	90 91 ed 31 	lds	r25, 0x31ED
    71c6:	00 97       	sbiw	r24, 0x00	; 0
    71c8:	11 f1       	breq	.+68     	; 0x720e <arpArpIn+0x178>
    {
      if (arpDebugLevel > 0)
    71ca:	20 91 bf 32 	lds	r18, 0x32BF
    71ce:	22 23       	and	r18, r18
    71d0:	81 f0       	breq	.+32     	; 0x71f2 <arpArpIn+0x15c>
        fprintf_P(arpDebug, PSTR("Sending ARP Reply\r\n"));
    71d2:	00 d0       	rcall	.+0      	; 0x71d4 <arpArpIn+0x13e>
    71d4:	0f 92       	push	r0
    71d6:	ed b7       	in	r30, 0x3d	; 61
    71d8:	fe b7       	in	r31, 0x3e	; 62
    71da:	81 83       	std	Z+1, r24	; 0x01
    71dc:	92 83       	std	Z+2, r25	; 0x02
    71de:	86 e3       	ldi	r24, 0x36	; 54
    71e0:	9d e0       	ldi	r25, 0x0D	; 13
    71e2:	83 83       	std	Z+3, r24	; 0x03
    71e4:	94 83       	std	Z+4, r25	; 0x04
    71e6:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    71ea:	0f 90       	pop	r0
    71ec:	0f 90       	pop	r0
    71ee:	0f 90       	pop	r0
    71f0:	0f 90       	pop	r0
      if (arpDebugLevel > 2)
    71f2:	80 91 bf 32 	lds	r24, 0x32BF
    71f6:	83 30       	cpi	r24, 0x03	; 3
    71f8:	50 f0       	brcs	.+20     	; 0x720e <arpArpIn+0x178>
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    71fa:	60 91 e6 31 	lds	r22, 0x31E6
    71fe:	70 91 e7 31 	lds	r23, 0x31E7
    7202:	80 91 ec 31 	lds	r24, 0x31EC
    7206:	90 91 ed 31 	lds	r25, 0x31ED
    720a:	0e 94 5e 37 	call	0x6ebc	; 0x6ebc <arpPrintHeader>
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    720e:	8a e2       	ldi	r24, 0x2A	; 42
    7210:	90 e0       	ldi	r25, 0x00	; 0
    7212:	0e 94 ce 2b 	call	0x579c	; 0x579c <nicSend>
  }
}
    7216:	df 91       	pop	r29
    7218:	cf 91       	pop	r28
    721a:	08 95       	ret

0000721c <arpPrintTable>:
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
}
#endif /*ARP_DEBUG*/

void arpPrintTable(FILE *stream)
{
    721c:	6f 92       	push	r6
    721e:	7f 92       	push	r7
    7220:	8f 92       	push	r8
    7222:	9f 92       	push	r9
    7224:	af 92       	push	r10
    7226:	bf 92       	push	r11
    7228:	cf 92       	push	r12
    722a:	df 92       	push	r13
    722c:	ef 92       	push	r14
    722e:	ff 92       	push	r15
    7230:	0f 93       	push	r16
    7232:	1f 93       	push	r17
    7234:	cf 93       	push	r28
    7236:	df 93       	push	r29
    7238:	ec 01       	movw	r28, r24
  uint8_t i;

  // print ARP table
  fprintf_P(stream, PSTR("Time Eth Address        IP Address\r\n"));
    723a:	00 d0       	rcall	.+0      	; 0x723c <arpPrintTable+0x20>
    723c:	0f 92       	push	r0
    723e:	ad b7       	in	r26, 0x3d	; 61
    7240:	be b7       	in	r27, 0x3e	; 62
    7242:	11 96       	adiw	r26, 0x01	; 1
    7244:	8d 93       	st	X+, r24
    7246:	9c 93       	st	X, r25
    7248:	12 97       	sbiw	r26, 0x02	; 2
    724a:	8a e7       	ldi	r24, 0x7A	; 122
    724c:	9c e0       	ldi	r25, 0x0C	; 12
    724e:	13 96       	adiw	r26, 0x03	; 3
    7250:	8d 93       	st	X+, r24
    7252:	9c 93       	st	X, r25
    7254:	14 97       	sbiw	r26, 0x04	; 4
    7256:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("-----------------------------------\r\n"));
    725a:	ed b7       	in	r30, 0x3d	; 61
    725c:	fe b7       	in	r31, 0x3e	; 62
    725e:	c1 83       	std	Z+1, r28	; 0x01
    7260:	d2 83       	std	Z+2, r29	; 0x02
    7262:	84 e5       	ldi	r24, 0x54	; 84
    7264:	9c e0       	ldi	r25, 0x0C	; 12
    7266:	83 83       	std	Z+3, r24	; 0x03
    7268:	94 83       	std	Z+4, r25	; 0x04
    726a:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR(" MY  "));
    726e:	ad b7       	in	r26, 0x3d	; 61
    7270:	be b7       	in	r27, 0x3e	; 62
    7272:	11 96       	adiw	r26, 0x01	; 1
    7274:	cd 93       	st	X+, r28
    7276:	dc 93       	st	X, r29
    7278:	12 97       	sbiw	r26, 0x02	; 2
    727a:	8e e4       	ldi	r24, 0x4E	; 78
    727c:	9c e0       	ldi	r25, 0x0C	; 12
    727e:	13 96       	adiw	r26, 0x03	; 3
    7280:	8d 93       	st	X+, r24
    7282:	9c 93       	st	X, r25
    7284:	14 97       	sbiw	r26, 0x04	; 4
    7286:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    728a:	0f 90       	pop	r0
    728c:	0f 90       	pop	r0
    728e:	0f 90       	pop	r0
    7290:	0f 90       	pop	r0
    7292:	ce 01       	movw	r24, r28
    7294:	6e ed       	ldi	r22, 0xDE	; 222
    7296:	71 e3       	ldi	r23, 0x31	; 49
    7298:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
  fprintf_P(stream, PSTR("  "));
    729c:	00 d0       	rcall	.+0      	; 0x729e <arpPrintTable+0x82>
    729e:	0f 92       	push	r0
    72a0:	ed b7       	in	r30, 0x3d	; 61
    72a2:	fe b7       	in	r31, 0x3e	; 62
    72a4:	c1 83       	std	Z+1, r28	; 0x01
    72a6:	d2 83       	std	Z+2, r29	; 0x02
    72a8:	8b e4       	ldi	r24, 0x4B	; 75
    72aa:	9c e0       	ldi	r25, 0x0C	; 12
    72ac:	83 83       	std	Z+3, r24	; 0x03
    72ae:	94 83       	std	Z+4, r25	; 0x04
    72b0:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  netPrintIPAddr(stream, IpMyConfig.ip);
    72b4:	0f 90       	pop	r0
    72b6:	0f 90       	pop	r0
    72b8:	0f 90       	pop	r0
    72ba:	0f 90       	pop	r0
    72bc:	40 91 b0 32 	lds	r20, 0x32B0
    72c0:	50 91 b1 32 	lds	r21, 0x32B1
    72c4:	60 91 b2 32 	lds	r22, 0x32B2
    72c8:	70 91 b3 32 	lds	r23, 0x32B3
    72cc:	ce 01       	movw	r24, r28
    72ce:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    72d2:	00 d0       	rcall	.+0      	; 0x72d4 <arpPrintTable+0xb8>
    72d4:	0f 92       	push	r0
    72d6:	ad b7       	in	r26, 0x3d	; 61
    72d8:	be b7       	in	r27, 0x3e	; 62
    72da:	11 96       	adiw	r26, 0x01	; 1
    72dc:	cd 93       	st	X+, r28
    72de:	dc 93       	st	X, r29
    72e0:	12 97       	sbiw	r26, 0x02	; 2
    72e2:	88 e4       	ldi	r24, 0x48	; 72
    72e4:	9c e0       	ldi	r25, 0x0C	; 12
    72e6:	13 96       	adiw	r26, 0x03	; 3
    72e8:	8d 93       	st	X+, r24
    72ea:	9c 93       	st	X, r25
    72ec:	14 97       	sbiw	r26, 0x04	; 4
    72ee:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    72f2:	0a ec       	ldi	r16, 0xCA	; 202
    72f4:	12 e3       	ldi	r17, 0x32	; 50
    72f6:	0f 90       	pop	r0
    72f8:	0f 90       	pop	r0
    72fa:	0f 90       	pop	r0
    72fc:	0f 90       	pop	r0
    72fe:	ee 24       	eor	r14, r14
    7300:	ff 24       	eor	r15, r15

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    7302:	32 e4       	ldi	r19, 0x42	; 66
    7304:	c3 2e       	mov	r12, r19
    7306:	3c e0       	ldi	r19, 0x0C	; 12
    7308:	d3 2e       	mov	r13, r19
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    730a:	2b e0       	ldi	r18, 0x0B	; 11
    730c:	a2 2e       	mov	r10, r18
    730e:	b1 2c       	mov	r11, r1
    fprintf_P(stream, PSTR("  "));
    7310:	9f e3       	ldi	r25, 0x3F	; 63
    7312:	89 2e       	mov	r8, r25
    7314:	9c e0       	ldi	r25, 0x0C	; 12
    7316:	99 2e       	mov	r9, r25
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
    7318:	8c e3       	ldi	r24, 0x3C	; 60
    731a:	68 2e       	mov	r6, r24
    731c:	8c e0       	ldi	r24, 0x0C	; 12
    731e:	78 2e       	mov	r7, r24
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
    7320:	f8 01       	movw	r30, r16
    7322:	80 81       	ld	r24, Z
    7324:	91 81       	ldd	r25, Z+1	; 0x01
    7326:	a2 81       	ldd	r26, Z+2	; 0x02
    7328:	b3 81       	ldd	r27, Z+3	; 0x03
    732a:	00 97       	sbiw	r24, 0x00	; 0
    732c:	a1 05       	cpc	r26, r1
    732e:	b1 05       	cpc	r27, r1
    7330:	09 f4       	brne	.+2      	; 0x7334 <arpPrintTable+0x118>
    7332:	51 c0       	rjmp	.+162    	; 0x73d6 <arpPrintTable+0x1ba>
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    7334:	00 d0       	rcall	.+0      	; 0x7336 <arpPrintTable+0x11a>
    7336:	00 d0       	rcall	.+0      	; 0x7338 <arpPrintTable+0x11c>
    7338:	ed b7       	in	r30, 0x3d	; 61
    733a:	fe b7       	in	r31, 0x3e	; 62
    733c:	31 96       	adiw	r30, 0x01	; 1
    733e:	ad b7       	in	r26, 0x3d	; 61
    7340:	be b7       	in	r27, 0x3e	; 62
    7342:	11 96       	adiw	r26, 0x01	; 1
    7344:	cd 93       	st	X+, r28
    7346:	dc 93       	st	X, r29
    7348:	12 97       	sbiw	r26, 0x02	; 2
    734a:	c2 82       	std	Z+2, r12	; 0x02
    734c:	d3 82       	std	Z+3, r13	; 0x03
    734e:	d8 01       	movw	r26, r16
    7350:	1a 96       	adiw	r26, 0x0a	; 10
    7352:	8c 91       	ld	r24, X
    7354:	84 83       	std	Z+4, r24	; 0x04
    7356:	15 82       	std	Z+5, r1	; 0x05
    7358:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    735c:	ed b7       	in	r30, 0x3d	; 61
    735e:	fe b7       	in	r31, 0x3e	; 62
    7360:	36 96       	adiw	r30, 0x06	; 6
    7362:	ed bf       	out	0x3d, r30	; 61
    7364:	fe bf       	out	0x3e, r31	; 62
    7366:	ea 9c       	mul	r14, r10
    7368:	b0 01       	movw	r22, r0
    736a:	eb 9c       	mul	r14, r11
    736c:	70 0d       	add	r23, r0
    736e:	fa 9c       	mul	r15, r10
    7370:	70 0d       	add	r23, r0
    7372:	11 24       	eor	r1, r1
    7374:	62 53       	subi	r22, 0x32	; 50
    7376:	7d 4c       	sbci	r23, 0xCD	; 205
    7378:	ce 01       	movw	r24, r28
    737a:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <netPrintEthAddr>
    fprintf_P(stream, PSTR("  "));
    737e:	00 d0       	rcall	.+0      	; 0x7380 <arpPrintTable+0x164>
    7380:	0f 92       	push	r0
    7382:	ad b7       	in	r26, 0x3d	; 61
    7384:	be b7       	in	r27, 0x3e	; 62
    7386:	11 96       	adiw	r26, 0x01	; 1
    7388:	cd 93       	st	X+, r28
    738a:	dc 93       	st	X, r29
    738c:	12 97       	sbiw	r26, 0x02	; 2
    738e:	13 96       	adiw	r26, 0x03	; 3
    7390:	8d 92       	st	X+, r8
    7392:	9c 92       	st	X, r9
    7394:	14 97       	sbiw	r26, 0x04	; 4
    7396:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    739a:	0f 90       	pop	r0
    739c:	0f 90       	pop	r0
    739e:	0f 90       	pop	r0
    73a0:	0f 90       	pop	r0
    73a2:	f8 01       	movw	r30, r16
    73a4:	40 81       	ld	r20, Z
    73a6:	51 81       	ldd	r21, Z+1	; 0x01
    73a8:	62 81       	ldd	r22, Z+2	; 0x02
    73aa:	73 81       	ldd	r23, Z+3	; 0x03
    73ac:	ce 01       	movw	r24, r28
    73ae:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
    fprintf_P(stream, PSTR("\r\n"));
    73b2:	00 d0       	rcall	.+0      	; 0x73b4 <arpPrintTable+0x198>
    73b4:	0f 92       	push	r0
    73b6:	ad b7       	in	r26, 0x3d	; 61
    73b8:	be b7       	in	r27, 0x3e	; 62
    73ba:	11 96       	adiw	r26, 0x01	; 1
    73bc:	cd 93       	st	X+, r28
    73be:	dc 93       	st	X, r29
    73c0:	12 97       	sbiw	r26, 0x02	; 2
    73c2:	13 96       	adiw	r26, 0x03	; 3
    73c4:	6d 92       	st	X+, r6
    73c6:	7c 92       	st	X, r7
    73c8:	14 97       	sbiw	r26, 0x04	; 4
    73ca:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    73ce:	0f 90       	pop	r0
    73d0:	0f 90       	pop	r0
    73d2:	0f 90       	pop	r0
    73d4:	0f 90       	pop	r0
    73d6:	08 94       	sec
    73d8:	e1 1c       	adc	r14, r1
    73da:	f1 1c       	adc	r15, r1
    73dc:	05 5f       	subi	r16, 0xF5	; 245
    73de:	1f 4f       	sbci	r17, 0xFF	; 255
  netPrintEthAddr(stream, &nicState.mac);
  fprintf_P(stream, PSTR("  "));
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
    73e0:	ba e0       	ldi	r27, 0x0A	; 10
    73e2:	eb 16       	cp	r14, r27
    73e4:	f1 04       	cpc	r15, r1
    73e6:	09 f0       	breq	.+2      	; 0x73ea <arpPrintTable+0x1ce>
    73e8:	9b cf       	rjmp	.-202    	; 0x7320 <arpPrintTable+0x104>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
  }
}
    73ea:	df 91       	pop	r29
    73ec:	cf 91       	pop	r28
    73ee:	1f 91       	pop	r17
    73f0:	0f 91       	pop	r16
    73f2:	ff 90       	pop	r15
    73f4:	ef 90       	pop	r14
    73f6:	df 90       	pop	r13
    73f8:	cf 90       	pop	r12
    73fa:	bf 90       	pop	r11
    73fc:	af 90       	pop	r10
    73fe:	9f 90       	pop	r9
    7400:	8f 90       	pop	r8
    7402:	7f 90       	pop	r7
    7404:	6f 90       	pop	r6
    7406:	08 95       	ret

00007408 <socketInit>:
 * @param *sck socket
 */
static inline void tcpAcceptConn(struct TcpIpSocket *sck);

inline void socketInit(void)
{
    7408:	bf 92       	push	r11
    740a:	cf 92       	push	r12
    740c:	df 92       	push	r13
    740e:	ef 92       	push	r14
    7410:	ff 92       	push	r15
    7412:	0f 93       	push	r16
    7414:	1f 93       	push	r17
    7416:	cf 93       	push	r28
    7418:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    741a:	80 e3       	ldi	r24, 0x30	; 48
    741c:	92 e0       	ldi	r25, 0x02	; 2
    741e:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xmalloc>
    7422:	80 93 1e 32 	sts	0x321E, r24
    7426:	90 93 1f 32 	sts	0x321F, r25
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    742a:	fc 01       	movw	r30, r24
    742c:	80 e3       	ldi	r24, 0x30	; 48
    742e:	92 e0       	ldi	r25, 0x02	; 2
    7430:	df 01       	movw	r26, r30
    7432:	9c 01       	movw	r18, r24
    7434:	1d 92       	st	X+, r1
    7436:	21 50       	subi	r18, 0x01	; 1
    7438:	30 40       	sbci	r19, 0x00	; 0
    743a:	e1 f7       	brne	.-8      	; 0x7434 <socketInit+0x2c>
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    743c:	00 91 1e 32 	lds	r16, 0x321E
    7440:	10 91 1f 32 	lds	r17, 0x321F
    7444:	c8 ea       	ldi	r28, 0xA8	; 168
    7446:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7448:	8f ef       	ldi	r24, 0xFF	; 255
    744a:	c8 2e       	mov	r12, r24
    744c:	81 e1       	ldi	r24, 0x11	; 17
    744e:	d8 2e       	mov	r13, r24
    7450:	82 e2       	ldi	r24, 0x22	; 34
    7452:	e8 2e       	mov	r14, r24
    7454:	83 e3       	ldi	r24, 0x33	; 51
    7456:	f8 2e       	mov	r15, r24
    sck->state         = LISTEN;   
    7458:	bb 24       	eor	r11, r11
    745a:	b3 94       	inc	r11
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    745c:	de 01       	movw	r26, r28
    745e:	a8 5a       	subi	r26, 0xA8	; 168
    7460:	a0 31       	cpi	r26, 0x10	; 16
    7462:	20 f4       	brcc	.+8      	; 0x746c <socketInit+0x64>
    7464:	ce 01       	movw	r24, r28
    7466:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    746a:	02 c0       	rjmp	.+4      	; 0x7470 <socketInit+0x68>
    746c:	88 eb       	ldi	r24, 0xB8	; 184
    746e:	91 e6       	ldi	r25, 0x61	; 97
    7470:	f8 01       	movw	r30, r16
    7472:	85 83       	std	Z+5, r24	; 0x05
    7474:	96 83       	std	Z+6, r25	; 0x06
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7476:	d8 01       	movw	r26, r16
    7478:	1d 96       	adiw	r26, 0x0d	; 13
    747a:	cd 92       	st	X+, r12
    747c:	dd 92       	st	X+, r13
    747e:	ed 92       	st	X+, r14
    7480:	fc 92       	st	X, r15
    7482:	50 97       	sbiw	r26, 0x10	; 16
    sck->state         = LISTEN;   
    7484:	bc 92       	st	X, r11
    7486:	21 96       	adiw	r28, 0x01	; 1
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    7488:	b1 e6       	ldi	r27, 0x61	; 97
    748a:	cc 3b       	cpi	r28, 0xBC	; 188
    748c:	db 07       	cpc	r29, r27
    748e:	19 f0       	breq	.+6      	; 0x7496 <socketInit+0x8e>
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    sck->state         = LISTEN;   
    sck++;
    7490:	04 5e       	subi	r16, 0xE4	; 228
    7492:	1f 4f       	sbci	r17, 0xFF	; 255
    7494:	e3 cf       	rjmp	.-58     	; 0x745c <socketInit+0x54>
  }
}
    7496:	df 91       	pop	r29
    7498:	cf 91       	pop	r28
    749a:	1f 91       	pop	r17
    749c:	0f 91       	pop	r16
    749e:	ff 90       	pop	r15
    74a0:	ef 90       	pop	r14
    74a2:	df 90       	pop	r13
    74a4:	cf 90       	pop	r12
    74a6:	bf 90       	pop	r11
    74a8:	08 95       	ret

000074aa <calculateTcpChecksun>:
  
  return 0;
}

void calculateTcpChecksun(uint16_t tcpLen)
{
    74aa:	cf 93       	push	r28
    74ac:	df 93       	push	r29
    74ae:	bc 01       	movw	r22, r24
  nicState.layer4.tcp->tcpchksum = 0;
    74b0:	c0 91 e8 31 	lds	r28, 0x31E8
    74b4:	d0 91 e9 31 	lds	r29, 0x31E9
    74b8:	18 8a       	std	Y+16, r1	; 0x10
    74ba:	19 8a       	std	Y+17, r1	; 0x11
  nicState.layer4.tcp->tcpchksum = netChecksum(nicState.layer4.tcp, tcpLen); //TODO finish it
    74bc:	ce 01       	movw	r24, r28
    74be:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <netChecksum>
    74c2:	88 8b       	std	Y+16, r24	; 0x10
    74c4:	99 8b       	std	Y+17, r25	; 0x11
}
    74c6:	df 91       	pop	r29
    74c8:	cf 91       	pop	r28
    74ca:	08 95       	ret

000074cc <processTcpPacket>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket(void)
{
    74cc:	af 92       	push	r10
    74ce:	bf 92       	push	r11
    74d0:	cf 92       	push	r12
    74d2:	df 92       	push	r13
    74d4:	ef 92       	push	r14
    74d6:	ff 92       	push	r15
    74d8:	0f 93       	push	r16
    74da:	1f 93       	push	r17
    74dc:	cf 93       	push	r28
    74de:	df 93       	push	r29
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    74e0:	e0 91 1e 32 	lds	r30, 0x321E
    74e4:	f0 91 1f 32 	lds	r31, 0x321F
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    74e8:	00 91 e6 31 	lds	r16, 0x31E6
    74ec:	10 91 e7 31 	lds	r17, 0x31E7
    74f0:	60 91 e8 31 	lds	r22, 0x31E8
    74f4:	70 91 e9 31 	lds	r23, 0x31E9
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    74f8:	ef 01       	movw	r28, r30
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    74fa:	ee 24       	eor	r14, r14
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
    74fc:	f8 80       	ld	r15, Y
    74fe:	8f 2d       	mov	r24, r15
    7500:	82 30       	cpi	r24, 0x02	; 2
    7502:	08 f4       	brcc	.+2      	; 0x7506 <processTcpPacket+0x3a>
    7504:	47 c0       	rjmp	.+142    	; 0x7594 <processTcpPacket+0xc8>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    7506:	29 81       	ldd	r18, Y+1	; 0x01
    7508:	3a 81       	ldd	r19, Y+2	; 0x02
    750a:	4b 81       	ldd	r20, Y+3	; 0x03
    750c:	5c 81       	ldd	r21, Y+4	; 0x04
    750e:	d8 01       	movw	r26, r16
    7510:	1c 96       	adiw	r26, 0x0c	; 12
    7512:	ad 90       	ld	r10, X+
    7514:	bd 90       	ld	r11, X+
    7516:	cd 90       	ld	r12, X+
    7518:	dc 90       	ld	r13, X
    751a:	1f 97       	sbiw	r26, 0x0f	; 15
    751c:	2a 15       	cp	r18, r10
    751e:	3b 05       	cpc	r19, r11
    7520:	4c 05       	cpc	r20, r12
    7522:	5d 05       	cpc	r21, r13
    7524:	b9 f5       	brne	.+110    	; 0x7594 <processTcpPacket+0xc8>
    7526:	2d 81       	ldd	r18, Y+5	; 0x05
    7528:	3e 81       	ldd	r19, Y+6	; 0x06
    752a:	db 01       	movw	r26, r22
    752c:	12 96       	adiw	r26, 0x02	; 2
    752e:	8d 91       	ld	r24, X+
    7530:	9c 91       	ld	r25, X
    7532:	13 97       	sbiw	r26, 0x03	; 3
    7534:	28 17       	cp	r18, r24
    7536:	39 07       	cpc	r19, r25
    7538:	69 f5       	brne	.+90     	; 0x7594 <processTcpPacket+0xc8>
    753a:	2f 81       	ldd	r18, Y+7	; 0x07
    753c:	38 85       	ldd	r19, Y+8	; 0x08
    753e:	8d 91       	ld	r24, X+
    7540:	9c 91       	ld	r25, X
    7542:	11 97       	sbiw	r26, 0x01	; 1
    7544:	28 17       	cp	r18, r24
    7546:	39 07       	cpc	r19, r25
    7548:	29 f5       	brne	.+74     	; 0x7594 <processTcpPacket+0xc8>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    754a:	80 91 ae 32 	lds	r24, 0x32AE
    754e:	90 91 af 32 	lds	r25, 0x32AF
    7552:	00 97       	sbiw	r24, 0x00	; 0
    7554:	09 f4       	brne	.+2      	; 0x7558 <processTcpPacket+0x8c>
    7556:	90 c0       	rjmp	.+288    	; 0x7678 <processTcpPacket+0x1ac>
        if (tcpDebugLevel > 2)
    7558:	20 91 05 32 	lds	r18, 0x3205
    755c:	23 30       	cpi	r18, 0x03	; 3
    755e:	08 f4       	brcc	.+2      	; 0x7562 <processTcpPacket+0x96>
    7560:	8b c0       	rjmp	.+278    	; 0x7678 <processTcpPacket+0x1ac>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    7562:	00 d0       	rcall	.+0      	; 0x7564 <processTcpPacket+0x98>
    7564:	00 d0       	rcall	.+0      	; 0x7566 <processTcpPacket+0x9a>
    7566:	ed b7       	in	r30, 0x3d	; 61
    7568:	fe b7       	in	r31, 0x3e	; 62
    756a:	31 96       	adiw	r30, 0x01	; 1
    756c:	ad b7       	in	r26, 0x3d	; 61
    756e:	be b7       	in	r27, 0x3e	; 62
    7570:	11 96       	adiw	r26, 0x01	; 1
    7572:	8d 93       	st	X+, r24
    7574:	9c 93       	st	X, r25
    7576:	12 97       	sbiw	r26, 0x02	; 2
    7578:	8a eb       	ldi	r24, 0xBA	; 186
    757a:	9e e0       	ldi	r25, 0x0E	; 14
    757c:	82 83       	std	Z+2, r24	; 0x02
    757e:	93 83       	std	Z+3, r25	; 0x03
    7580:	f4 82       	std	Z+4, r15	; 0x04
    7582:	15 82       	std	Z+5, r1	; 0x05
    7584:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7588:	ed b7       	in	r30, 0x3d	; 61
    758a:	fe b7       	in	r31, 0x3e	; 62
    758c:	36 96       	adiw	r30, 0x06	; 6
    758e:	ed bf       	out	0x3d, r30	; 61
    7590:	fe bf       	out	0x3e, r31	; 62
    7592:	72 c0       	rjmp	.+228    	; 0x7678 <processTcpPacket+0x1ac>

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    7594:	e3 94       	inc	r14
    7596:	8e 2d       	mov	r24, r14
    7598:	84 31       	cpi	r24, 0x14	; 20
    759a:	11 f0       	breq	.+4      	; 0x75a0 <processTcpPacket+0xd4>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
#endif      
      return result;
    }
    result++;
    759c:	6c 96       	adiw	r28, 0x1c	; 28
    759e:	ae cf       	rjmp	.-164    	; 0x74fc <processTcpPacket+0x30>
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    75a0:	00 e0       	ldi	r16, 0x00	; 0
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    75a2:	80 81       	ld	r24, Z
    75a4:	81 30       	cpi	r24, 0x01	; 1
    75a6:	b9 f5       	brne	.+110    	; 0x7616 <processTcpPacket+0x14a>
    75a8:	45 81       	ldd	r20, Z+5	; 0x05
    75aa:	56 81       	ldd	r21, Z+6	; 0x06
    75ac:	db 01       	movw	r26, r22
    75ae:	12 96       	adiw	r26, 0x02	; 2
    75b0:	2d 91       	ld	r18, X+
    75b2:	3c 91       	ld	r19, X
    75b4:	13 97       	sbiw	r26, 0x03	; 3
    75b6:	42 17       	cp	r20, r18
    75b8:	53 07       	cpc	r21, r19
    75ba:	69 f5       	brne	.+90     	; 0x7616 <processTcpPacket+0x14a>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    75bc:	80 91 ae 32 	lds	r24, 0x32AE
    75c0:	90 91 af 32 	lds	r25, 0x32AF
    75c4:	00 97       	sbiw	r24, 0x00	; 0
    75c6:	e1 f0       	breq	.+56     	; 0x7600 <processTcpPacket+0x134>
        if (tcpDebugLevel > 2)
    75c8:	20 91 05 32 	lds	r18, 0x3205
    75cc:	23 30       	cpi	r18, 0x03	; 3
    75ce:	c0 f0       	brcs	.+48     	; 0x7600 <processTcpPacket+0x134>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    75d0:	00 d0       	rcall	.+0      	; 0x75d2 <processTcpPacket+0x106>
    75d2:	00 d0       	rcall	.+0      	; 0x75d4 <processTcpPacket+0x108>
    75d4:	ed b7       	in	r30, 0x3d	; 61
    75d6:	fe b7       	in	r31, 0x3e	; 62
    75d8:	31 96       	adiw	r30, 0x01	; 1
    75da:	ad b7       	in	r26, 0x3d	; 61
    75dc:	be b7       	in	r27, 0x3e	; 62
    75de:	11 96       	adiw	r26, 0x01	; 1
    75e0:	8d 93       	st	X+, r24
    75e2:	9c 93       	st	X, r25
    75e4:	12 97       	sbiw	r26, 0x02	; 2
    75e6:	24 e9       	ldi	r18, 0x94	; 148
    75e8:	3e e0       	ldi	r19, 0x0E	; 14
    75ea:	22 83       	std	Z+2, r18	; 0x02
    75ec:	33 83       	std	Z+3, r19	; 0x03
    75ee:	04 83       	std	Z+4, r16	; 0x04
    75f0:	15 82       	std	Z+5, r1	; 0x05
    75f2:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    75f6:	ed b7       	in	r30, 0x3d	; 61
    75f8:	fe b7       	in	r31, 0x3e	; 62
    75fa:	36 96       	adiw	r30, 0x06	; 6
    75fc:	ed bf       	out	0x3d, r30	; 61
    75fe:	fe bf       	out	0x3e, r31	; 62
#endif      
      return &sockets[i];
    7600:	8c e1       	ldi	r24, 0x1C	; 28
    7602:	08 9f       	mul	r16, r24
    7604:	c0 01       	movw	r24, r0
    7606:	11 24       	eor	r1, r1
    7608:	c0 91 1e 32 	lds	r28, 0x321E
    760c:	d0 91 1f 32 	lds	r29, 0x321F
    7610:	c8 0f       	add	r28, r24
    7612:	d9 1f       	adc	r29, r25
    7614:	31 c0       	rjmp	.+98     	; 0x7678 <processTcpPacket+0x1ac>
    }
    result++;
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    7616:	0f 5f       	subi	r16, 0xFF	; 255
    7618:	04 31       	cpi	r16, 0x14	; 20
    761a:	11 f0       	breq	.+4      	; 0x7620 <processTcpPacket+0x154>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
#endif      
      return &sockets[i];
    }
    result++;
    761c:	7c 96       	adiw	r30, 0x1c	; 28
    761e:	c1 cf       	rjmp	.-126    	; 0x75a2 <processTcpPacket+0xd6>
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    7620:	c0 91 ae 32 	lds	r28, 0x32AE
    7624:	d0 91 af 32 	lds	r29, 0x32AF
    7628:	20 97       	sbiw	r28, 0x00	; 0
    762a:	09 f4       	brne	.+2      	; 0x762e <processTcpPacket+0x162>
    762c:	5f c1       	rjmp	.+702    	; 0x78ec <processTcpPacket+0x420>
    if (tcpDebugLevel > 2)
    762e:	80 91 05 32 	lds	r24, 0x3205
    7632:	83 30       	cpi	r24, 0x03	; 3
    7634:	08 f4       	brcc	.+2      	; 0x7638 <processTcpPacket+0x16c>
    7636:	5a c1       	rjmp	.+692    	; 0x78ec <processTcpPacket+0x420>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    7638:	db 01       	movw	r26, r22
    763a:	12 96       	adiw	r26, 0x02	; 2
    763c:	8d 91       	ld	r24, X+
    763e:	9c 91       	ld	r25, X
    7640:	13 97       	sbiw	r26, 0x03	; 3
    7642:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    7646:	00 d0       	rcall	.+0      	; 0x7648 <processTcpPacket+0x17c>
    7648:	00 d0       	rcall	.+0      	; 0x764a <processTcpPacket+0x17e>
    764a:	ed b7       	in	r30, 0x3d	; 61
    764c:	fe b7       	in	r31, 0x3e	; 62
    764e:	31 96       	adiw	r30, 0x01	; 1
    7650:	ad b7       	in	r26, 0x3d	; 61
    7652:	be b7       	in	r27, 0x3e	; 62
    7654:	11 96       	adiw	r26, 0x01	; 1
    7656:	cd 93       	st	X+, r28
    7658:	dc 93       	st	X, r29
    765a:	12 97       	sbiw	r26, 0x02	; 2
    765c:	2a e6       	ldi	r18, 0x6A	; 106
    765e:	3e e0       	ldi	r19, 0x0E	; 14
    7660:	22 83       	std	Z+2, r18	; 0x02
    7662:	33 83       	std	Z+3, r19	; 0x03
    7664:	84 83       	std	Z+4, r24	; 0x04
    7666:	95 83       	std	Z+5, r25	; 0x05
    7668:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    766c:	ed b7       	in	r30, 0x3d	; 61
    766e:	fe b7       	in	r31, 0x3e	; 62
    7670:	36 96       	adiw	r30, 0x06	; 6
    7672:	ed bf       	out	0x3d, r30	; 61
    7674:	fe bf       	out	0x3e, r31	; 62
    7676:	3a c1       	rjmp	.+628    	; 0x78ec <processTcpPacket+0x420>

inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    7678:	20 97       	sbiw	r28, 0x00	; 0
    767a:	09 f4       	brne	.+2      	; 0x767e <processTcpPacket+0x1b2>
    767c:	37 c1       	rjmp	.+622    	; 0x78ec <processTcpPacket+0x420>
    return 1;
  
  
  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    767e:	e0 91 e8 31 	lds	r30, 0x31E8
    7682:	f0 91 e9 31 	lds	r31, 0x31E9
    7686:	64 81       	ldd	r22, Z+4	; 0x04
    7688:	75 81       	ldd	r23, Z+5	; 0x05
    768a:	86 81       	ldd	r24, Z+6	; 0x06
    768c:	97 81       	ldd	r25, Z+7	; 0x07
    768e:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <htonl>
    7692:	69 87       	std	Y+9, r22	; 0x09
    7694:	7a 87       	std	Y+10, r23	; 0x0a
    7696:	8b 87       	std	Y+11, r24	; 0x0b
    7698:	9c 87       	std	Y+12, r25	; 0x0c
  
  if (socket->state == LISTEN)
    769a:	88 81       	ld	r24, Y
    769c:	81 30       	cpi	r24, 0x01	; 1
    769e:	09 f0       	breq	.+2      	; 0x76a2 <processTcpPacket+0x1d6>
    76a0:	b8 c0       	rjmp	.+368    	; 0x7812 <processTcpPacket+0x346>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    76a2:	e0 91 e8 31 	lds	r30, 0x31E8
    76a6:	f0 91 e9 31 	lds	r31, 0x31E9
    76aa:	25 85       	ldd	r18, Z+13	; 0x0d
    76ac:	80 91 ae 32 	lds	r24, 0x32AE
    76b0:	90 91 af 32 	lds	r25, 0x32AF
    76b4:	21 ff       	sbrs	r18, 1
    76b6:	9a c0       	rjmp	.+308    	; 0x77ec <processTcpPacket+0x320>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    76b8:	00 97       	sbiw	r24, 0x00	; 0
    76ba:	c1 f0       	breq	.+48     	; 0x76ec <processTcpPacket+0x220>
        if (tcpDebugLevel > 2)
    76bc:	20 91 05 32 	lds	r18, 0x3205
    76c0:	23 30       	cpi	r18, 0x03	; 3
    76c2:	a0 f0       	brcs	.+40     	; 0x76ec <processTcpPacket+0x220>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    76c4:	00 d0       	rcall	.+0      	; 0x76c6 <processTcpPacket+0x1fa>
    76c6:	0f 92       	push	r0
    76c8:	ad b7       	in	r26, 0x3d	; 61
    76ca:	be b7       	in	r27, 0x3e	; 62
    76cc:	11 96       	adiw	r26, 0x01	; 1
    76ce:	8d 93       	st	X+, r24
    76d0:	9c 93       	st	X, r25
    76d2:	12 97       	sbiw	r26, 0x02	; 2
    76d4:	88 e2       	ldi	r24, 0x28	; 40
    76d6:	9e e0       	ldi	r25, 0x0E	; 14
    76d8:	13 96       	adiw	r26, 0x03	; 3
    76da:	8d 93       	st	X+, r24
    76dc:	9c 93       	st	X, r25
    76de:	14 97       	sbiw	r26, 0x04	; 4
    76e0:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    76e4:	0f 90       	pop	r0
    76e6:	0f 90       	pop	r0
    76e8:	0f 90       	pop	r0
    76ea:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    76ec:	82 e0       	ldi	r24, 0x02	; 2
    76ee:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    76f0:	e0 91 e8 31 	lds	r30, 0x31E8
    76f4:	f0 91 e9 31 	lds	r31, 0x31E9
    76f8:	20 81       	ld	r18, Z
    76fa:	31 81       	ldd	r19, Z+1	; 0x01
    76fc:	2f 83       	std	Y+7, r18	; 0x07
    76fe:	38 87       	std	Y+8, r19	; 0x08
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    7700:	e0 91 e6 31 	lds	r30, 0x31E6
    7704:	f0 91 e7 31 	lds	r31, 0x31E7
    7708:	84 85       	ldd	r24, Z+12	; 0x0c
    770a:	95 85       	ldd	r25, Z+13	; 0x0d
    770c:	a6 85       	ldd	r26, Z+14	; 0x0e
    770e:	b7 85       	ldd	r27, Z+15	; 0x0f
    7710:	89 83       	std	Y+1, r24	; 0x01
    7712:	9a 83       	std	Y+2, r25	; 0x02
    7714:	ab 83       	std	Y+3, r26	; 0x03
    7716:	bc 83       	std	Y+4, r27	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    7718:	e0 91 e8 31 	lds	r30, 0x31E8
    771c:	f0 91 e9 31 	lds	r31, 0x31E9
    7720:	8d 81       	ldd	r24, Y+5	; 0x05
    7722:	9e 81       	ldd	r25, Y+6	; 0x06
    7724:	80 83       	st	Z, r24
    7726:	91 83       	std	Z+1, r25	; 0x01
      nicState.layer4.tcp->destport  = socket->remotePort;
    7728:	e0 91 e8 31 	lds	r30, 0x31E8
    772c:	f0 91 e9 31 	lds	r31, 0x31E9
    7730:	22 83       	std	Z+2, r18	; 0x02
    7732:	33 83       	std	Z+3, r19	; 0x03
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    7734:	00 91 e8 31 	lds	r16, 0x31E8
    7738:	10 91 e9 31 	lds	r17, 0x31E9
    773c:	6d 85       	ldd	r22, Y+13	; 0x0d
    773e:	7e 85       	ldd	r23, Y+14	; 0x0e
    7740:	8f 85       	ldd	r24, Y+15	; 0x0f
    7742:	98 89       	ldd	r25, Y+16	; 0x10
    7744:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <htonl>
    7748:	f8 01       	movw	r30, r16
    774a:	64 83       	std	Z+4, r22	; 0x04
    774c:	75 83       	std	Z+5, r23	; 0x05
    774e:	86 83       	std	Z+6, r24	; 0x06
    7750:	97 83       	std	Z+7, r25	; 0x07
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    7752:	00 91 e8 31 	lds	r16, 0x31E8
    7756:	10 91 e9 31 	lds	r17, 0x31E9
    775a:	69 85       	ldd	r22, Y+9	; 0x09
    775c:	7a 85       	ldd	r23, Y+10	; 0x0a
    775e:	8b 85       	ldd	r24, Y+11	; 0x0b
    7760:	9c 85       	ldd	r25, Y+12	; 0x0c
    7762:	6f 5f       	subi	r22, 0xFF	; 255
    7764:	7f 4f       	sbci	r23, 0xFF	; 255
    7766:	8f 4f       	sbci	r24, 0xFF	; 255
    7768:	9f 4f       	sbci	r25, 0xFF	; 255
    776a:	0e 94 5c 2e 	call	0x5cb8	; 0x5cb8 <htonl>
    776e:	d8 01       	movw	r26, r16
    7770:	18 96       	adiw	r26, 0x08	; 8
    7772:	6d 93       	st	X+, r22
    7774:	7d 93       	st	X+, r23
    7776:	8d 93       	st	X+, r24
    7778:	9c 93       	st	X, r25
    777a:	1b 97       	sbiw	r26, 0x0b	; 11
      nicState.layer4.tcp->tcpoffset = 5<<4;
    777c:	e0 91 e8 31 	lds	r30, 0x31E8
    7780:	f0 91 e9 31 	lds	r31, 0x31E9
    7784:	80 e5       	ldi	r24, 0x50	; 80
    7786:	84 87       	std	Z+12, r24	; 0x0c
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    7788:	e0 91 e8 31 	lds	r30, 0x31E8
    778c:	f0 91 e9 31 	lds	r31, 0x31E9
    7790:	82 e1       	ldi	r24, 0x12	; 18
    7792:	85 87       	std	Z+13, r24	; 0x0d
      nicState.layer4.tcp->wnd       = htons(100);
    7794:	00 91 e8 31 	lds	r16, 0x31E8
    7798:	10 91 e9 31 	lds	r17, 0x31E9
    779c:	84 e6       	ldi	r24, 0x64	; 100
    779e:	90 e0       	ldi	r25, 0x00	; 0
    77a0:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    77a4:	f8 01       	movw	r30, r16
    77a6:	86 87       	std	Z+14, r24	; 0x0e
    77a8:	97 87       	std	Z+15, r25	; 0x0f
      nicState.layer4.tcp->tcpchksum = 0;
    77aa:	e0 91 e8 31 	lds	r30, 0x31E8
    77ae:	f0 91 e9 31 	lds	r31, 0x31E9
    77b2:	10 8a       	std	Z+16, r1	; 0x10
    77b4:	11 8a       	std	Z+17, r1	; 0x11
      nicState.layer4.tcp->urgp      = 0;
    77b6:	12 8a       	std	Z+18, r1	; 0x12
    77b8:	13 8a       	std	Z+19, r1	; 0x13
      calculateTcpChecksun(TCP_HEADER_LEN);
    77ba:	84 e1       	ldi	r24, 0x14	; 20
    77bc:	90 e0       	ldi	r25, 0x00	; 0
    77be:	0e 94 55 3a 	call	0x74aa	; 0x74aa <calculateTcpChecksun>

      socket->seqNoLastSent++;
    77c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    77c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    77c6:	af 85       	ldd	r26, Y+15	; 0x0f
    77c8:	b8 89       	ldd	r27, Y+16	; 0x10
    77ca:	01 96       	adiw	r24, 0x01	; 1
    77cc:	a1 1d       	adc	r26, r1
    77ce:	b1 1d       	adc	r27, r1
    77d0:	8d 87       	std	Y+13, r24	; 0x0d
    77d2:	9e 87       	std	Y+14, r25	; 0x0e
    77d4:	af 87       	std	Y+15, r26	; 0x0f
    77d6:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    77d8:	69 81       	ldd	r22, Y+1	; 0x01
    77da:	7a 81       	ldd	r23, Y+2	; 0x02
    77dc:	8b 81       	ldd	r24, Y+3	; 0x03
    77de:	9c 81       	ldd	r25, Y+4	; 0x04
    77e0:	46 e0       	ldi	r20, 0x06	; 6
    77e2:	24 e1       	ldi	r18, 0x14	; 20
    77e4:	30 e0       	ldi	r19, 0x00	; 0
    77e6:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <ipSend>
    77ea:	82 c0       	rjmp	.+260    	; 0x78f0 <processTcpPacket+0x424>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    77ec:	00 97       	sbiw	r24, 0x00	; 0
    77ee:	09 f4       	brne	.+2      	; 0x77f2 <processTcpPacket+0x326>
    77f0:	7f c0       	rjmp	.+254    	; 0x78f0 <processTcpPacket+0x424>
        if (tcpDebugLevel > 1)
    77f2:	20 91 05 32 	lds	r18, 0x3205
    77f6:	22 30       	cpi	r18, 0x02	; 2
    77f8:	08 f4       	brcc	.+2      	; 0x77fc <processTcpPacket+0x330>
    77fa:	7a c0       	rjmp	.+244    	; 0x78f0 <processTcpPacket+0x424>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    77fc:	00 d0       	rcall	.+0      	; 0x77fe <processTcpPacket+0x332>
    77fe:	0f 92       	push	r0
    7800:	ad b7       	in	r26, 0x3d	; 61
    7802:	be b7       	in	r27, 0x3e	; 62
    7804:	11 96       	adiw	r26, 0x01	; 1
    7806:	8d 93       	st	X+, r24
    7808:	9c 93       	st	X, r25
    780a:	12 97       	sbiw	r26, 0x02	; 2
    780c:	84 ef       	ldi	r24, 0xF4	; 244
    780e:	9d e0       	ldi	r25, 0x0D	; 13
    7810:	37 c0       	rjmp	.+110    	; 0x7880 <processTcpPacket+0x3b4>
    }
#endif    
    return 0;
  }
  
  if (socket->state == SYN_RECEIVED)
    7812:	82 30       	cpi	r24, 0x02	; 2
    7814:	09 f0       	breq	.+2      	; 0x7818 <processTcpPacket+0x34c>
    7816:	3f c0       	rjmp	.+126    	; 0x7896 <processTcpPacket+0x3ca>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    7818:	e0 91 e8 31 	lds	r30, 0x31E8
    781c:	f0 91 e9 31 	lds	r31, 0x31E9
    7820:	25 85       	ldd	r18, Z+13	; 0x0d
    7822:	80 91 ae 32 	lds	r24, 0x32AE
    7826:	90 91 af 32 	lds	r25, 0x32AF
    782a:	24 ff       	sbrs	r18, 4
    782c:	15 c0       	rjmp	.+42     	; 0x7858 <processTcpPacket+0x38c>
    {
      socket->state    = ESTABILISHED;
    782e:	23 e0       	ldi	r18, 0x03	; 3
    7830:	28 83       	st	Y, r18
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    7832:	00 97       	sbiw	r24, 0x00	; 0
    7834:	09 f4       	brne	.+2      	; 0x7838 <processTcpPacket+0x36c>
    7836:	5c c0       	rjmp	.+184    	; 0x78f0 <processTcpPacket+0x424>
      if (tcpDebugLevel > 2)
    7838:	20 91 05 32 	lds	r18, 0x3205
    783c:	23 30       	cpi	r18, 0x03	; 3
    783e:	08 f4       	brcc	.+2      	; 0x7842 <processTcpPacket+0x376>
    7840:	57 c0       	rjmp	.+174    	; 0x78f0 <processTcpPacket+0x424>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    7842:	00 d0       	rcall	.+0      	; 0x7844 <processTcpPacket+0x378>
    7844:	0f 92       	push	r0
    7846:	ed b7       	in	r30, 0x3d	; 61
    7848:	fe b7       	in	r31, 0x3e	; 62
    784a:	81 83       	std	Z+1, r24	; 0x01
    784c:	92 83       	std	Z+2, r25	; 0x02
    784e:	8c ea       	ldi	r24, 0xAC	; 172
    7850:	9d e0       	ldi	r25, 0x0D	; 13
    7852:	83 83       	std	Z+3, r24	; 0x03
    7854:	94 83       	std	Z+4, r25	; 0x04
    7856:	18 c0       	rjmp	.+48     	; 0x7888 <processTcpPacket+0x3bc>
#endif        

    }
    else
    {
      socket->state = LISTEN;
    7858:	21 e0       	ldi	r18, 0x01	; 1
    785a:	28 83       	st	Y, r18
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    785c:	00 97       	sbiw	r24, 0x00	; 0
    785e:	09 f4       	brne	.+2      	; 0x7862 <processTcpPacket+0x396>
    7860:	47 c0       	rjmp	.+142    	; 0x78f0 <processTcpPacket+0x424>
        if (tcpDebugLevel > 1)
    7862:	20 91 05 32 	lds	r18, 0x3205
    7866:	22 30       	cpi	r18, 0x02	; 2
    7868:	08 f4       	brcc	.+2      	; 0x786c <processTcpPacket+0x3a0>
    786a:	42 c0       	rjmp	.+132    	; 0x78f0 <processTcpPacket+0x424>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    786c:	00 d0       	rcall	.+0      	; 0x786e <processTcpPacket+0x3a2>
    786e:	0f 92       	push	r0
    7870:	ad b7       	in	r26, 0x3d	; 61
    7872:	be b7       	in	r27, 0x3e	; 62
    7874:	11 96       	adiw	r26, 0x01	; 1
    7876:	8d 93       	st	X+, r24
    7878:	9c 93       	st	X, r25
    787a:	12 97       	sbiw	r26, 0x02	; 2
    787c:	88 e7       	ldi	r24, 0x78	; 120
    787e:	9d e0       	ldi	r25, 0x0D	; 13
    7880:	13 96       	adiw	r26, 0x03	; 3
    7882:	8d 93       	st	X+, r24
    7884:	9c 93       	st	X, r25
    7886:	14 97       	sbiw	r26, 0x04	; 4
    7888:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    788c:	0f 90       	pop	r0
    788e:	0f 90       	pop	r0
    7890:	0f 90       	pop	r0
    7892:	0f 90       	pop	r0
    7894:	2d c0       	rjmp	.+90     	; 0x78f0 <processTcpPacket+0x424>
    }
    return 0;
  }
  
  
  if (socket->state == ESTABILISHED)
    7896:	83 30       	cpi	r24, 0x03	; 3
    7898:	59 f5       	brne	.+86     	; 0x78f0 <processTcpPacket+0x424>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    789a:	e0 91 e8 31 	lds	r30, 0x31E8
    789e:	f0 91 e9 31 	lds	r31, 0x31E9
    78a2:	85 85       	ldd	r24, Z+13	; 0x0d
    78a4:	80 ff       	sbrs	r24, 0
    78a6:	24 c0       	rjmp	.+72     	; 0x78f0 <processTcpPacket+0x424>
    {
      socket->timer              = timer100Hz;
    78a8:	80 91 4a 25 	lds	r24, 0x254A
    78ac:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    78ae:	80 e1       	ldi	r24, 0x10	; 16
    78b0:	85 87       	std	Z+13, r24	; 0x0d
//      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
//      {
//        dataFromBufLen++;
//        dataPtr++;
//      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    78b2:	69 81       	ldd	r22, Y+1	; 0x01
    78b4:	7a 81       	ldd	r23, Y+2	; 0x02
    78b6:	8b 81       	ldd	r24, Y+3	; 0x03
    78b8:	9c 81       	ldd	r25, Y+4	; 0x04
    78ba:	46 e0       	ldi	r20, 0x06	; 6
    78bc:	24 e1       	ldi	r18, 0x14	; 20
    78be:	30 e0       	ldi	r19, 0x00	; 0
    78c0:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <ipSend>
      socket->state    = CLOSE_WAIT;
    78c4:	84 e0       	ldi	r24, 0x04	; 4
    78c6:	88 83       	st	Y, r24
      
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    78c8:	e0 91 e8 31 	lds	r30, 0x31E8
    78cc:	f0 91 e9 31 	lds	r31, 0x31E9
    78d0:	81 e0       	ldi	r24, 0x01	; 1
    78d2:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    78d4:	69 81       	ldd	r22, Y+1	; 0x01
    78d6:	7a 81       	ldd	r23, Y+2	; 0x02
    78d8:	8b 81       	ldd	r24, Y+3	; 0x03
    78da:	9c 81       	ldd	r25, Y+4	; 0x04
    78dc:	46 e0       	ldi	r20, 0x06	; 6
    78de:	24 e1       	ldi	r18, 0x14	; 20
    78e0:	30 e0       	ldi	r19, 0x00	; 0
    78e2:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <ipSend>
      socket->state    = LAST_ACK;
    78e6:	85 e0       	ldi	r24, 0x05	; 5
    78e8:	88 83       	st	Y, r24
    78ea:	02 c0       	rjmp	.+4      	; 0x78f0 <processTcpPacket+0x424>
inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    return 1;
    78ec:	81 e0       	ldi	r24, 0x01	; 1
    78ee:	01 c0       	rjmp	.+2      	; 0x78f2 <processTcpPacket+0x426>
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
      socket->state    = LAST_ACK;
    }
    return 0;
    78f0:	80 e0       	ldi	r24, 0x00	; 0
  }

  //Read data and put into the queue
  
  return 0;
}
    78f2:	df 91       	pop	r29
    78f4:	cf 91       	pop	r28
    78f6:	1f 91       	pop	r17
    78f8:	0f 91       	pop	r16
    78fa:	ff 90       	pop	r15
    78fc:	ef 90       	pop	r14
    78fe:	df 90       	pop	r13
    7900:	cf 90       	pop	r12
    7902:	bf 90       	pop	r11
    7904:	af 90       	pop	r10
    7906:	08 95       	ret

00007908 <sendTcBuffer>:

uint8_t sendTcBuffer(uint8_t socketNo)
{
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    7908:	80 e0       	ldi	r24, 0x00	; 0
    790a:	08 95       	ret

0000790c <netstackTCPIPProcess>:

void netstackTCPIPProcess(void)
{
    790c:	cf 93       	push	r28
    790e:	df 93       	push	r29
  if (nicState.layer4.tcp->destport == htons(80))
    7910:	e0 91 e8 31 	lds	r30, 0x31E8
    7914:	f0 91 e9 31 	lds	r31, 0x31E9
    7918:	c2 81       	ldd	r28, Z+2	; 0x02
    791a:	d3 81       	ldd	r29, Z+3	; 0x03
    791c:	80 e5       	ldi	r24, 0x50	; 80
    791e:	90 e0       	ldi	r25, 0x00	; 0
    7920:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    7924:	c8 17       	cp	r28, r24
    7926:	d9 07       	cpc	r29, r25
    7928:	b9 f4       	brne	.+46     	; 0x7958 <netstackTCPIPProcess+0x4c>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    792a:	80 91 ae 32 	lds	r24, 0x32AE
    792e:	90 91 af 32 	lds	r25, 0x32AF
    7932:	00 97       	sbiw	r24, 0x00	; 0
    7934:	99 f0       	breq	.+38     	; 0x795c <netstackTCPIPProcess+0x50>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    7936:	00 d0       	rcall	.+0      	; 0x7938 <netstackTCPIPProcess+0x2c>
    7938:	0f 92       	push	r0
    793a:	ed b7       	in	r30, 0x3d	; 61
    793c:	fe b7       	in	r31, 0x3e	; 62
    793e:	81 83       	std	Z+1, r24	; 0x01
    7940:	92 83       	std	Z+2, r25	; 0x02
    7942:	81 e6       	ldi	r24, 0x61	; 97
    7944:	9d e0       	ldi	r25, 0x0D	; 13
    7946:	83 83       	std	Z+3, r24	; 0x03
    7948:	94 83       	std	Z+4, r25	; 0x04
    794a:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    794e:	0f 90       	pop	r0
    7950:	0f 90       	pop	r0
    7952:	0f 90       	pop	r0
    7954:	0f 90       	pop	r0
    7956:	02 c0       	rjmp	.+4      	; 0x795c <netstackTCPIPProcess+0x50>
#endif
    ;
  }
  else
  {
    processTcpPacket();
    7958:	0e 94 66 3a 	call	0x74cc	; 0x74cc <processTcpPacket>
  }
}
    795c:	df 91       	pop	r29
    795e:	cf 91       	pop	r28
    7960:	08 95       	ret

00007962 <setTcpDebug>:

#if TCP_DEBUG
void setTcpDebug(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    7962:	80 93 ae 32 	sts	0x32AE, r24
    7966:	90 93 af 32 	sts	0x32AF, r25
  tcpDebugLevel = level;
    796a:	60 93 05 32 	sts	0x3205, r22
}
    796e:	08 95       	ret

00007970 <flushTcpQueues>:
  for (sckNo = 0; sckNo < NUMBER_OF_SOCKETS; sckNo++)
  {
    
    sck++;
  }
}
    7970:	08 95       	ret

00007972 <httpProcess>:
          continue;  
        }
      }

#endif
    7972:	08 95       	ret

00007974 <udpInit>:
static uint32_t udpIpDst_eep   __attribute__((section (".eeprom"))) = ((uint32_t)UDP_DST_IP4   << 24) + ((uint32_t)UDP_DST_IP3   <<16) + ((uint32_t)UDP_DST_IP2   <<8) + UDP_DST_IP1;
static uint16_t udpPortDstEep  __attribute__((section (".eeprom"))) = HTONS(UDP_DST_PORT);
static uint16_t udpPortSrcEep  __attribute__((section (".eeprom"))) = HTONS(UDP_SRC_PORT);

void udpInit(void)
{
    7974:	ef 92       	push	r14
    7976:	ff 92       	push	r15
    7978:	cf 93       	push	r28
    797a:	df 93       	push	r29
#if UDP_DEBUG
  udpDbgStream         = NULL;
    797c:	10 92 22 32 	sts	0x3222, r1
    7980:	10 92 23 32 	sts	0x3223, r1
  udpDbgLevel          = 0;
    7984:	10 92 db 31 	sts	0x31DB, r1
#endif
  udpSocket = xmalloc(sizeof(UdpSocket_t));
    7988:	8e e0       	ldi	r24, 0x0E	; 14
    798a:	90 e0       	ldi	r25, 0x00	; 0
    798c:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xmalloc>
    7990:	e8 2e       	mov	r14, r24
    7992:	e7 01       	movw	r28, r14
    7994:	7e 01       	movw	r14, r28
    7996:	f9 2e       	mov	r15, r25
    7998:	e7 01       	movw	r28, r14
    799a:	e0 92 02 32 	sts	0x3202, r14
    799e:	f0 92 03 32 	sts	0x3203, r15

  udpSocket->dstIp      = eeprom_read_dword(&udpIpDst_eep);
    79a2:	8a e2       	ldi	r24, 0x2A	; 42
    79a4:	90 e0       	ldi	r25, 0x00	; 0
    79a6:	0e 94 27 5a 	call	0xb44e	; 0xb44e <__eerd_dword_x128a1>
    79aa:	6e 83       	std	Y+6, r22	; 0x06
    79ac:	7f 83       	std	Y+7, r23	; 0x07
    79ae:	88 87       	std	Y+8, r24	; 0x08
    79b0:	99 87       	std	Y+9, r25	; 0x09
  udpSocket->dstPortDef = eeprom_read_word(&udpPortDstEep);;
    79b2:	8e e2       	ldi	r24, 0x2E	; 46
    79b4:	90 e0       	ldi	r25, 0x00	; 0
    79b6:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__eerd_word_x128a1>
    79ba:	88 83       	st	Y, r24
    79bc:	99 83       	std	Y+1, r25	; 0x01
  udpSocket->srcPort    = eeprom_read_word(&udpPortSrcEep);
    79be:	80 e3       	ldi	r24, 0x30	; 48
    79c0:	90 e0       	ldi	r25, 0x00	; 0
    79c2:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__eerd_word_x128a1>
    79c6:	8c 83       	std	Y+4, r24	; 0x04
    79c8:	9d 83       	std	Y+5, r25	; 0x05
  
  udpSocket->Rx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_RX_BUF_ADDR));
    79ca:	8f ef       	ldi	r24, 0xFF	; 255
    79cc:	61 e0       	ldi	r22, 0x01	; 1
    79ce:	40 e0       	ldi	r20, 0x00	; 0
    79d0:	59 e7       	ldi	r21, 0x79	; 121
    79d2:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <xQueueCreateExternal>
    79d6:	8a 87       	std	Y+10, r24	; 0x0a
    79d8:	9b 87       	std	Y+11, r25	; 0x0b
  udpSocket->Tx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_TX_BUF_ADDR));
    79da:	c0 91 02 32 	lds	r28, 0x3202
    79de:	d0 91 03 32 	lds	r29, 0x3203
    79e2:	8f ef       	ldi	r24, 0xFF	; 255
    79e4:	61 e0       	ldi	r22, 0x01	; 1
    79e6:	40 e0       	ldi	r20, 0x00	; 0
    79e8:	58 e7       	ldi	r21, 0x78	; 120
    79ea:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <xQueueCreateExternal>
    79ee:	8c 87       	std	Y+12, r24	; 0x0c
    79f0:	9d 87       	std	Y+13, r25	; 0x0d
}
    79f2:	df 91       	pop	r29
    79f4:	cf 91       	pop	r28
    79f6:	ff 90       	pop	r15
    79f8:	ef 90       	pop	r14
    79fa:	08 95       	ret

000079fc <setUdpDebug>:

#if UDP_DEBUG
void setUdpDebug(FILE *stream, uint8_t level)
{
  udpDbgStream = stream;
    79fc:	80 93 22 32 	sts	0x3222, r24
    7a00:	90 93 23 32 	sts	0x3223, r25
  udpDbgLevel = level;
    7a04:	60 93 db 31 	sts	0x31DB, r22
}
    7a08:	08 95       	ret

00007a0a <udpSend>:
#endif

inline void udpSend(uint16_t len)
{
    7a0a:	ef 92       	push	r14
    7a0c:	ff 92       	push	r15
    7a0e:	0f 93       	push	r16
    7a10:	1f 93       	push	r17
    7a12:	cf 93       	push	r28
    7a14:	df 93       	push	r29
    7a16:	8c 01       	movw	r16, r24
// make pointer to UDP header
  nicState.layer4.udp->srcport  = udpSocket->srcPort;
    7a18:	e0 91 02 32 	lds	r30, 0x3202
    7a1c:	f0 91 03 32 	lds	r31, 0x3203
    7a20:	a0 91 e8 31 	lds	r26, 0x31E8
    7a24:	b0 91 e9 31 	lds	r27, 0x31E9
    7a28:	84 81       	ldd	r24, Z+4	; 0x04
    7a2a:	95 81       	ldd	r25, Z+5	; 0x05
    7a2c:	8d 93       	st	X+, r24
    7a2e:	9c 93       	st	X, r25
  nicState.layer4.udp->destport = (udpSocket->dstPortDef == 0)? udpSocket->dstPort : udpSocket->dstPortDef;          //data in udpSocket are stored in network order
    7a30:	a0 91 e8 31 	lds	r26, 0x31E8
    7a34:	b0 91 e9 31 	lds	r27, 0x31E9
    7a38:	80 81       	ld	r24, Z
    7a3a:	91 81       	ldd	r25, Z+1	; 0x01
    7a3c:	00 97       	sbiw	r24, 0x00	; 0
    7a3e:	11 f4       	brne	.+4      	; 0x7a44 <udpSend+0x3a>
    7a40:	82 81       	ldd	r24, Z+2	; 0x02
    7a42:	93 81       	ldd	r25, Z+3	; 0x03
    7a44:	12 96       	adiw	r26, 0x02	; 2
    7a46:	8d 93       	st	X+, r24
    7a48:	9c 93       	st	X, r25
    7a4a:	13 97       	sbiw	r26, 0x03	; 3
  
  nicState.layer4.udp->udplen = htons(len + UDP_HEADER_LEN);
    7a4c:	e0 90 e8 31 	lds	r14, 0x31E8
    7a50:	f0 90 e9 31 	lds	r15, 0x31E9
    7a54:	e8 01       	movw	r28, r16
    7a56:	28 96       	adiw	r28, 0x08	; 8
    7a58:	ce 01       	movw	r24, r28
    7a5a:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    7a5e:	d7 01       	movw	r26, r14
    7a60:	14 96       	adiw	r26, 0x04	; 4
    7a62:	8d 93       	st	X+, r24
    7a64:	9c 93       	st	X, r25
    7a66:	15 97       	sbiw	r26, 0x05	; 5
  nicState.layer4.udp->udpchksum = 0;
    7a68:	e0 91 e8 31 	lds	r30, 0x31E8
    7a6c:	f0 91 e9 31 	lds	r31, 0x31E9
    7a70:	16 82       	std	Z+6, r1	; 0x06
    7a72:	17 82       	std	Z+7, r1	; 0x07

#if UDP_DEBUG
  if (udpDbgStream != NULL)
    7a74:	80 91 22 32 	lds	r24, 0x3222
    7a78:	90 91 23 32 	lds	r25, 0x3223
    7a7c:	00 97       	sbiw	r24, 0x00	; 0
    7a7e:	e1 f0       	breq	.+56     	; 0x7ab8 <udpSend+0xae>
    if (udpDbgLevel > 1)
    7a80:	20 91 db 31 	lds	r18, 0x31DB
    7a84:	22 30       	cpi	r18, 0x02	; 2
    7a86:	c0 f0       	brcs	.+48     	; 0x7ab8 <udpSend+0xae>
      fprintf_P(udpDbgStream, PSTR("Sending UDP packet (data length %d)\r\n"), len);
    7a88:	00 d0       	rcall	.+0      	; 0x7a8a <udpSend+0x80>
    7a8a:	00 d0       	rcall	.+0      	; 0x7a8c <udpSend+0x82>
    7a8c:	ed b7       	in	r30, 0x3d	; 61
    7a8e:	fe b7       	in	r31, 0x3e	; 62
    7a90:	31 96       	adiw	r30, 0x01	; 1
    7a92:	ad b7       	in	r26, 0x3d	; 61
    7a94:	be b7       	in	r27, 0x3e	; 62
    7a96:	11 96       	adiw	r26, 0x01	; 1
    7a98:	8d 93       	st	X+, r24
    7a9a:	9c 93       	st	X, r25
    7a9c:	12 97       	sbiw	r26, 0x02	; 2
    7a9e:	8b e7       	ldi	r24, 0x7B	; 123
    7aa0:	9f e0       	ldi	r25, 0x0F	; 15
    7aa2:	82 83       	std	Z+2, r24	; 0x02
    7aa4:	93 83       	std	Z+3, r25	; 0x03
    7aa6:	04 83       	std	Z+4, r16	; 0x04
    7aa8:	15 83       	std	Z+5, r17	; 0x05
    7aaa:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7aae:	ed b7       	in	r30, 0x3d	; 61
    7ab0:	fe b7       	in	r31, 0x3e	; 62
    7ab2:	36 96       	adiw	r30, 0x06	; 6
    7ab4:	ed bf       	out	0x3d, r30	; 61
    7ab6:	fe bf       	out	0x3e, r31	; 62
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
    7ab8:	e0 91 02 32 	lds	r30, 0x3202
    7abc:	f0 91 03 32 	lds	r31, 0x3203
    7ac0:	66 81       	ldd	r22, Z+6	; 0x06
    7ac2:	77 81       	ldd	r23, Z+7	; 0x07
    7ac4:	80 85       	ldd	r24, Z+8	; 0x08
    7ac6:	91 85       	ldd	r25, Z+9	; 0x09
    7ac8:	41 e1       	ldi	r20, 0x11	; 17
    7aca:	9e 01       	movw	r18, r28
    7acc:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <ipSend>
}
    7ad0:	df 91       	pop	r29
    7ad2:	cf 91       	pop	r28
    7ad4:	1f 91       	pop	r17
    7ad6:	0f 91       	pop	r16
    7ad8:	ff 90       	pop	r15
    7ada:	ef 90       	pop	r14
    7adc:	08 95       	ret

00007ade <netstackUDPIPProcess>:

inline void netstackUDPIPProcess(void)
{
    7ade:	af 92       	push	r10
    7ae0:	bf 92       	push	r11
    7ae2:	cf 92       	push	r12
    7ae4:	df 92       	push	r13
    7ae6:	ff 92       	push	r15
    7ae8:	0f 93       	push	r16
    7aea:	1f 93       	push	r17
    7aec:	cf 93       	push	r28
    7aee:	df 93       	push	r29
  uint16_t len = (uint16_t) htons(nicState.layer4.udp->udplen);
    7af0:	e0 91 e8 31 	lds	r30, 0x31E8
    7af4:	f0 91 e9 31 	lds	r31, 0x31E9
    7af8:	84 81       	ldd	r24, Z+4	; 0x04
    7afa:	95 81       	ldd	r25, Z+5	; 0x05
    7afc:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    7b00:	8c 01       	movw	r16, r24
  uint8_t i;

  #if UDP_DEBUG
  if(udpDbgStream != NULL)
    7b02:	80 91 22 32 	lds	r24, 0x3222
    7b06:	90 91 23 32 	lds	r25, 0x3223
    7b0a:	00 97       	sbiw	r24, 0x00	; 0
    7b0c:	f1 f0       	breq	.+60     	; 0x7b4a <netstackUDPIPProcess+0x6c>
    if (udpDbgLevel > 3)
    7b0e:	20 91 db 31 	lds	r18, 0x31DB
    7b12:	24 30       	cpi	r18, 0x04	; 4
    7b14:	d0 f0       	brcs	.+52     	; 0x7b4a <netstackUDPIPProcess+0x6c>
      fprintf_P(udpDbgStream, PSTR("Proc. UDP packet (data length %d)\r\n"), len-UDP_HEADER_LEN);
    7b16:	00 d0       	rcall	.+0      	; 0x7b18 <netstackUDPIPProcess+0x3a>
    7b18:	00 d0       	rcall	.+0      	; 0x7b1a <netstackUDPIPProcess+0x3c>
    7b1a:	ed b7       	in	r30, 0x3d	; 61
    7b1c:	fe b7       	in	r31, 0x3e	; 62
    7b1e:	31 96       	adiw	r30, 0x01	; 1
    7b20:	ad b7       	in	r26, 0x3d	; 61
    7b22:	be b7       	in	r27, 0x3e	; 62
    7b24:	11 96       	adiw	r26, 0x01	; 1
    7b26:	8d 93       	st	X+, r24
    7b28:	9c 93       	st	X, r25
    7b2a:	12 97       	sbiw	r26, 0x02	; 2
    7b2c:	87 e5       	ldi	r24, 0x57	; 87
    7b2e:	9f e0       	ldi	r25, 0x0F	; 15
    7b30:	82 83       	std	Z+2, r24	; 0x02
    7b32:	93 83       	std	Z+3, r25	; 0x03
    7b34:	c8 01       	movw	r24, r16
    7b36:	08 97       	sbiw	r24, 0x08	; 8
    7b38:	84 83       	std	Z+4, r24	; 0x04
    7b3a:	95 83       	std	Z+5, r25	; 0x05
    7b3c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7b40:	ed b7       	in	r30, 0x3d	; 61
    7b42:	fe b7       	in	r31, 0x3e	; 62
    7b44:	36 96       	adiw	r30, 0x06	; 6
    7b46:	ed bf       	out	0x3d, r30	; 61
    7b48:	fe bf       	out	0x3e, r31	; 62
#endif

  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    7b4a:	a0 91 e8 31 	lds	r26, 0x31E8
    7b4e:	b0 91 e9 31 	lds	r27, 0x31E9
    7b52:	e0 91 02 32 	lds	r30, 0x3202
    7b56:	f0 91 03 32 	lds	r31, 0x3203
    7b5a:	12 96       	adiw	r26, 0x02	; 2
    7b5c:	2d 91       	ld	r18, X+
    7b5e:	3c 91       	ld	r19, X
    7b60:	13 97       	sbiw	r26, 0x03	; 3
    7b62:	84 81       	ldd	r24, Z+4	; 0x04
    7b64:	95 81       	ldd	r25, Z+5	; 0x05
    7b66:	28 17       	cp	r18, r24
    7b68:	39 07       	cpc	r19, r25
    7b6a:	09 f0       	breq	.+2      	; 0x7b6e <netstackUDPIPProcess+0x90>
    7b6c:	a8 c0       	rjmp	.+336    	; 0x7cbe <netstackUDPIPProcess+0x1e0>
    7b6e:	20 81       	ld	r18, Z
    7b70:	31 81       	ldd	r19, Z+1	; 0x01
    7b72:	8d 91       	ld	r24, X+
    7b74:	9c 91       	ld	r25, X
    7b76:	11 97       	sbiw	r26, 0x01	; 1
    7b78:	21 15       	cp	r18, r1
    7b7a:	31 05       	cpc	r19, r1
    7b7c:	39 f0       	breq	.+14     	; 0x7b8c <netstackUDPIPProcess+0xae>
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
    7b7e:	22 81       	ldd	r18, Z+2	; 0x02
    7b80:	33 81       	ldd	r19, Z+3	; 0x03
    7b82:	28 17       	cp	r18, r24
    7b84:	39 07       	cpc	r19, r25
    7b86:	09 f0       	breq	.+2      	; 0x7b8a <netstackUDPIPProcess+0xac>
    7b88:	9a c0       	rjmp	.+308    	; 0x7cbe <netstackUDPIPProcess+0x1e0>
    7b8a:	02 c0       	rjmp	.+4      	; 0x7b90 <netstackUDPIPProcess+0xb2>
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    7b8c:	82 83       	std	Z+2, r24	; 0x02
    7b8e:	93 83       	std	Z+3, r25	; 0x03
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7b90:	c0 91 e8 31 	lds	r28, 0x31E8
    7b94:	d0 91 e9 31 	lds	r29, 0x31E9
    7b98:	28 96       	adiw	r28, 0x08	; 8
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7b9a:	80 91 22 32 	lds	r24, 0x3222
    7b9e:	90 91 23 32 	lds	r25, 0x3223
    7ba2:	00 97       	sbiw	r24, 0x00	; 0
    7ba4:	c1 f0       	breq	.+48     	; 0x7bd6 <netstackUDPIPProcess+0xf8>
        if (udpDbgLevel > 4)
    7ba6:	20 91 db 31 	lds	r18, 0x31DB
    7baa:	25 30       	cpi	r18, 0x05	; 5
    7bac:	a0 f0       	brcs	.+40     	; 0x7bd6 <netstackUDPIPProcess+0xf8>
          fprintf_P(udpDbgStream, PSTR("Received data: "));
    7bae:	00 d0       	rcall	.+0      	; 0x7bb0 <netstackUDPIPProcess+0xd2>
    7bb0:	0f 92       	push	r0
    7bb2:	ad b7       	in	r26, 0x3d	; 61
    7bb4:	be b7       	in	r27, 0x3e	; 62
    7bb6:	11 96       	adiw	r26, 0x01	; 1
    7bb8:	8d 93       	st	X+, r24
    7bba:	9c 93       	st	X, r25
    7bbc:	12 97       	sbiw	r26, 0x02	; 2
    7bbe:	87 e4       	ldi	r24, 0x47	; 71
    7bc0:	9f e0       	ldi	r25, 0x0F	; 15
    7bc2:	13 96       	adiw	r26, 0x03	; 3
    7bc4:	8d 93       	st	X+, r24
    7bc6:	9c 93       	st	X, r25
    7bc8:	14 97       	sbiw	r26, 0x04	; 4
    7bca:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7bce:	0f 90       	pop	r0
    7bd0:	0f 90       	pop	r0
    7bd2:	0f 90       	pop	r0
    7bd4:	0f 90       	pop	r0
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
}

inline void netstackUDPIPProcess(void)
{
    7bd6:	28 e0       	ldi	r18, 0x08	; 8
    7bd8:	f2 2e       	mov	r15, r18
    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7bda:	9f e3       	ldi	r25, 0x3F	; 63
    7bdc:	c9 2e       	mov	r12, r25
    7bde:	9f e0       	ldi	r25, 0x0F	; 15
    7be0:	d9 2e       	mov	r13, r25
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
        if(udpDbgStream != NULL)
          if (udpDbgLevel > 0)
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7be2:	8a e2       	ldi	r24, 0x2A	; 42
    7be4:	a8 2e       	mov	r10, r24
    7be6:	8f e0       	ldi	r24, 0x0F	; 15
    7be8:	b8 2e       	mov	r11, r24
    7bea:	49 c0       	rjmp	.+146    	; 0x7c7e <netstackUDPIPProcess+0x1a0>
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7bec:	00 97       	sbiw	r24, 0x00	; 0
    7bee:	d9 f0       	breq	.+54     	; 0x7c26 <netstackUDPIPProcess+0x148>
        if (udpDbgLevel > 4)
    7bf0:	20 91 db 31 	lds	r18, 0x31DB
    7bf4:	25 30       	cpi	r18, 0x05	; 5
    7bf6:	b8 f0       	brcs	.+46     	; 0x7c26 <netstackUDPIPProcess+0x148>
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7bf8:	00 d0       	rcall	.+0      	; 0x7bfa <netstackUDPIPProcess+0x11c>
    7bfa:	00 d0       	rcall	.+0      	; 0x7bfc <netstackUDPIPProcess+0x11e>
    7bfc:	ed b7       	in	r30, 0x3d	; 61
    7bfe:	fe b7       	in	r31, 0x3e	; 62
    7c00:	31 96       	adiw	r30, 0x01	; 1
    7c02:	ad b7       	in	r26, 0x3d	; 61
    7c04:	be b7       	in	r27, 0x3e	; 62
    7c06:	11 96       	adiw	r26, 0x01	; 1
    7c08:	8d 93       	st	X+, r24
    7c0a:	9c 93       	st	X, r25
    7c0c:	12 97       	sbiw	r26, 0x02	; 2
    7c0e:	c2 82       	std	Z+2, r12	; 0x02
    7c10:	d3 82       	std	Z+3, r13	; 0x03
    7c12:	88 81       	ld	r24, Y
    7c14:	84 83       	std	Z+4, r24	; 0x04
    7c16:	15 82       	std	Z+5, r1	; 0x05
    7c18:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7c1c:	ed b7       	in	r30, 0x3d	; 61
    7c1e:	fe b7       	in	r31, 0x3e	; 62
    7c20:	36 96       	adiw	r30, 0x06	; 6
    7c22:	ed bf       	out	0x3d, r30	; 61
    7c24:	fe bf       	out	0x3e, r31	; 62
#endif
#if UDB_DEBUG
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
    7c26:	e0 91 02 32 	lds	r30, 0x3202
    7c2a:	f0 91 03 32 	lds	r31, 0x3203
    7c2e:	82 85       	ldd	r24, Z+10	; 0x0a
    7c30:	93 85       	ldd	r25, Z+11	; 0x0b
    7c32:	be 01       	movw	r22, r28
    7c34:	4a e0       	ldi	r20, 0x0A	; 10
    7c36:	50 e0       	ldi	r21, 0x00	; 0
    7c38:	20 e0       	ldi	r18, 0x00	; 0
    7c3a:	0e 94 90 4d 	call	0x9b20	; 0x9b20 <xQueueGenericSend>
    7c3e:	88 23       	and	r24, r24
    7c40:	e1 f4       	brne	.+56     	; 0x7c7a <netstackUDPIPProcess+0x19c>
        if(udpDbgStream != NULL)
    7c42:	80 91 22 32 	lds	r24, 0x3222
    7c46:	90 91 23 32 	lds	r25, 0x3223
    7c4a:	00 97       	sbiw	r24, 0x00	; 0
    7c4c:	b1 f0       	breq	.+44     	; 0x7c7a <netstackUDPIPProcess+0x19c>
          if (udpDbgLevel > 0)
    7c4e:	20 91 db 31 	lds	r18, 0x31DB
    7c52:	22 23       	and	r18, r18
    7c54:	91 f0       	breq	.+36     	; 0x7c7a <netstackUDPIPProcess+0x19c>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7c56:	00 d0       	rcall	.+0      	; 0x7c58 <netstackUDPIPProcess+0x17a>
    7c58:	0f 92       	push	r0
    7c5a:	ad b7       	in	r26, 0x3d	; 61
    7c5c:	be b7       	in	r27, 0x3e	; 62
    7c5e:	11 96       	adiw	r26, 0x01	; 1
    7c60:	8d 93       	st	X+, r24
    7c62:	9c 93       	st	X, r25
    7c64:	12 97       	sbiw	r26, 0x02	; 2
    7c66:	13 96       	adiw	r26, 0x03	; 3
    7c68:	ad 92       	st	X+, r10
    7c6a:	bc 92       	st	X, r11
    7c6c:	14 97       	sbiw	r26, 0x04	; 4
    7c6e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7c72:	0f 90       	pop	r0
    7c74:	0f 90       	pop	r0
    7c76:	0f 90       	pop	r0
    7c78:	0f 90       	pop	r0
#endif
      tmp++;
    7c7a:	21 96       	adiw	r28, 0x01	; 1
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received data: "));
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    7c7c:	f3 94       	inc	r15
    7c7e:	2f 2d       	mov	r18, r15
    7c80:	30 e0       	ldi	r19, 0x00	; 0
    7c82:	80 91 22 32 	lds	r24, 0x3222
    7c86:	90 91 23 32 	lds	r25, 0x3223
    7c8a:	20 17       	cp	r18, r16
    7c8c:	31 07       	cpc	r19, r17
    7c8e:	08 f4       	brcc	.+2      	; 0x7c92 <netstackUDPIPProcess+0x1b4>
    7c90:	ad cf       	rjmp	.-166    	; 0x7bec <netstackUDPIPProcess+0x10e>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
#endif
      tmp++;
    }
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    7c92:	00 97       	sbiw	r24, 0x00	; 0
    7c94:	a1 f0       	breq	.+40     	; 0x7cbe <netstackUDPIPProcess+0x1e0>
      if (udpDbgLevel > 4)
    7c96:	20 91 db 31 	lds	r18, 0x31DB
    7c9a:	25 30       	cpi	r18, 0x05	; 5
    7c9c:	80 f0       	brcs	.+32     	; 0x7cbe <netstackUDPIPProcess+0x1e0>
        fprintf_P(udpDbgStream, PSTR("\r\n"));
    7c9e:	00 d0       	rcall	.+0      	; 0x7ca0 <netstackUDPIPProcess+0x1c2>
    7ca0:	0f 92       	push	r0
    7ca2:	ed b7       	in	r30, 0x3d	; 61
    7ca4:	fe b7       	in	r31, 0x3e	; 62
    7ca6:	81 83       	std	Z+1, r24	; 0x01
    7ca8:	92 83       	std	Z+2, r25	; 0x02
    7caa:	87 e2       	ldi	r24, 0x27	; 39
    7cac:	9f e0       	ldi	r25, 0x0F	; 15
    7cae:	83 83       	std	Z+3, r24	; 0x03
    7cb0:	94 83       	std	Z+4, r25	; 0x04
    7cb2:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7cb6:	0f 90       	pop	r0
    7cb8:	0f 90       	pop	r0
    7cba:	0f 90       	pop	r0
    7cbc:	0f 90       	pop	r0
#endif

  }
}
    7cbe:	df 91       	pop	r29
    7cc0:	cf 91       	pop	r28
    7cc2:	1f 91       	pop	r17
    7cc4:	0f 91       	pop	r16
    7cc6:	ff 90       	pop	r15
    7cc8:	df 90       	pop	r13
    7cca:	cf 90       	pop	r12
    7ccc:	bf 90       	pop	r11
    7cce:	af 90       	pop	r10
    7cd0:	08 95       	ret

00007cd2 <flushUdpQueues>:

inline void flushUdpQueues(void)
{
    7cd2:	0f 93       	push	r16
    7cd4:	1f 93       	push	r17
    7cd6:	cf 93       	push	r28
    7cd8:	df 93       	push	r29
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
    7cda:	e0 91 02 32 	lds	r30, 0x3202
    7cde:	f0 91 03 32 	lds	r31, 0x3203
    7ce2:	84 85       	ldd	r24, Z+12	; 0x0c
    7ce4:	95 85       	ldd	r25, Z+13	; 0x0d
    7ce6:	0e 94 d4 4f 	call	0x9fa8	; 0x9fa8 <uxQueueMessagesWaiting>
    7cea:	88 23       	and	r24, r24
    7cec:	e9 f0       	breq	.+58     	; 0x7d28 <flushUdpQueues+0x56>
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7cee:	00 91 e8 31 	lds	r16, 0x31E8
    7cf2:	10 91 e9 31 	lds	r17, 0x31E9

inline void flushUdpQueues(void)
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    7cf6:	c0 e0       	ldi	r28, 0x00	; 0
    7cf8:	d0 e0       	ldi	r29, 0x00	; 0
#endif

  }
}

inline void flushUdpQueues(void)
    7cfa:	08 5f       	subi	r16, 0xF8	; 248
    7cfc:	1f 4f       	sbci	r17, 0xFF	; 255
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7cfe:	01 c0       	rjmp	.+2      	; 0x7d02 <flushUdpQueues+0x30>
    {
      data++;
      len++;
    7d00:	21 96       	adiw	r28, 0x01	; 1
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7d02:	e0 91 02 32 	lds	r30, 0x3202
    7d06:	f0 91 03 32 	lds	r31, 0x3203
#endif

  }
}

inline void flushUdpQueues(void)
    7d0a:	b8 01       	movw	r22, r16
    7d0c:	6c 0f       	add	r22, r28
    7d0e:	7d 1f       	adc	r23, r29
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7d10:	84 85       	ldd	r24, Z+12	; 0x0c
    7d12:	95 85       	ldd	r25, Z+13	; 0x0d
    7d14:	40 e0       	ldi	r20, 0x00	; 0
    7d16:	50 e0       	ldi	r21, 0x00	; 0
    7d18:	20 e0       	ldi	r18, 0x00	; 0
    7d1a:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    7d1e:	81 30       	cpi	r24, 0x01	; 1
    7d20:	79 f3       	breq	.-34     	; 0x7d00 <flushUdpQueues+0x2e>
    {
      data++;
      len++;
    }
    udpSend(len);
    7d22:	ce 01       	movw	r24, r28
    7d24:	0e 94 05 3d 	call	0x7a0a	; 0x7a0a <udpSend>
  }
}
    7d28:	df 91       	pop	r29
    7d2a:	cf 91       	pop	r28
    7d2c:	1f 91       	pop	r17
    7d2e:	0f 91       	pop	r16
    7d30:	08 95       	ret

00007d32 <udpSaveConfig>:

void udpSaveConfig(void)
{
  eeprom_update_dword(&udpIpDst_eep, udpSocket->dstIp);
    7d32:	e0 91 02 32 	lds	r30, 0x3202
    7d36:	f0 91 03 32 	lds	r31, 0x3203
    7d3a:	46 81       	ldd	r20, Z+6	; 0x06
    7d3c:	57 81       	ldd	r21, Z+7	; 0x07
    7d3e:	60 85       	ldd	r22, Z+8	; 0x08
    7d40:	71 85       	ldd	r23, Z+9	; 0x09
    7d42:	8a e2       	ldi	r24, 0x2A	; 42
    7d44:	90 e0       	ldi	r25, 0x00	; 0
    7d46:	0e 94 4e 5a 	call	0xb49c	; 0xb49c <__eeupd_dword_x128a1>
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
    7d4a:	e0 91 02 32 	lds	r30, 0x3202
    7d4e:	f0 91 03 32 	lds	r31, 0x3203
    7d52:	60 81       	ld	r22, Z
    7d54:	71 81       	ldd	r23, Z+1	; 0x01
    7d56:	8e e2       	ldi	r24, 0x2E	; 46
    7d58:	90 e0       	ldi	r25, 0x00	; 0
    7d5a:	0e 94 5a 5a 	call	0xb4b4	; 0xb4b4 <__eeupd_word_x128a1>
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
    7d5e:	e0 91 02 32 	lds	r30, 0x3202
    7d62:	f0 91 03 32 	lds	r31, 0x3203
    7d66:	64 81       	ldd	r22, Z+4	; 0x04
    7d68:	75 81       	ldd	r23, Z+5	; 0x05
    7d6a:	80 e3       	ldi	r24, 0x30	; 48
    7d6c:	90 e0       	ldi	r25, 0x00	; 0
    7d6e:	0e 94 5a 5a 	call	0xb4b4	; 0xb4b4 <__eeupd_word_x128a1>
}
    7d72:	08 95       	ret

00007d74 <udpPrintStatus>:

void udpPrintStatus(FILE *stream)
{
    7d74:	cf 93       	push	r28
    7d76:	df 93       	push	r29
    7d78:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR("UDP config:"));
    7d7a:	00 d0       	rcall	.+0      	; 0x7d7c <udpPrintStatus+0x8>
    7d7c:	0f 92       	push	r0
    7d7e:	ad b7       	in	r26, 0x3d	; 61
    7d80:	be b7       	in	r27, 0x3e	; 62
    7d82:	11 96       	adiw	r26, 0x01	; 1
    7d84:	8d 93       	st	X+, r24
    7d86:	9c 93       	st	X, r25
    7d88:	12 97       	sbiw	r26, 0x02	; 2
    7d8a:	8b e1       	ldi	r24, 0x1B	; 27
    7d8c:	9f e0       	ldi	r25, 0x0F	; 15
    7d8e:	13 96       	adiw	r26, 0x03	; 3
    7d90:	8d 93       	st	X+, r24
    7d92:	9c 93       	st	X, r25
    7d94:	14 97       	sbiw	r26, 0x04	; 4
    7d96:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n  IP          : ")); netPrintIPAddr(stream, udpSocket->dstIp);
    7d9a:	ed b7       	in	r30, 0x3d	; 61
    7d9c:	fe b7       	in	r31, 0x3e	; 62
    7d9e:	c1 83       	std	Z+1, r28	; 0x01
    7da0:	d2 83       	std	Z+2, r29	; 0x02
    7da2:	88 e0       	ldi	r24, 0x08	; 8
    7da4:	9f e0       	ldi	r25, 0x0F	; 15
    7da6:	83 83       	std	Z+3, r24	; 0x03
    7da8:	94 83       	std	Z+4, r25	; 0x04
    7daa:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7dae:	0f 90       	pop	r0
    7db0:	0f 90       	pop	r0
    7db2:	0f 90       	pop	r0
    7db4:	0f 90       	pop	r0
    7db6:	e0 91 02 32 	lds	r30, 0x3202
    7dba:	f0 91 03 32 	lds	r31, 0x3203
    7dbe:	46 81       	ldd	r20, Z+6	; 0x06
    7dc0:	57 81       	ldd	r21, Z+7	; 0x07
    7dc2:	60 85       	ldd	r22, Z+8	; 0x08
    7dc4:	71 85       	ldd	r23, Z+9	; 0x09
    7dc6:	ce 01       	movw	r24, r28
    7dc8:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n  src port    : %d\r\n  dst port    : "), htons(udpSocket->srcPort));
    7dcc:	e0 91 02 32 	lds	r30, 0x3202
    7dd0:	f0 91 03 32 	lds	r31, 0x3203
    7dd4:	84 81       	ldd	r24, Z+4	; 0x04
    7dd6:	95 81       	ldd	r25, Z+5	; 0x05
    7dd8:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    7ddc:	00 d0       	rcall	.+0      	; 0x7dde <udpPrintStatus+0x6a>
    7dde:	00 d0       	rcall	.+0      	; 0x7de0 <udpPrintStatus+0x6c>
    7de0:	ed b7       	in	r30, 0x3d	; 61
    7de2:	fe b7       	in	r31, 0x3e	; 62
    7de4:	31 96       	adiw	r30, 0x01	; 1
    7de6:	ad b7       	in	r26, 0x3d	; 61
    7de8:	be b7       	in	r27, 0x3e	; 62
    7dea:	11 96       	adiw	r26, 0x01	; 1
    7dec:	cd 93       	st	X+, r28
    7dee:	dc 93       	st	X, r29
    7df0:	12 97       	sbiw	r26, 0x02	; 2
    7df2:	21 ee       	ldi	r18, 0xE1	; 225
    7df4:	3e e0       	ldi	r19, 0x0E	; 14
    7df6:	22 83       	std	Z+2, r18	; 0x02
    7df8:	33 83       	std	Z+3, r19	; 0x03
    7dfa:	84 83       	std	Z+4, r24	; 0x04
    7dfc:	95 83       	std	Z+5, r25	; 0x05
    7dfe:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
  if (udpSocket->dstPortDef == HTONS(0))
    7e02:	e0 91 02 32 	lds	r30, 0x3202
    7e06:	f0 91 03 32 	lds	r31, 0x3203
    7e0a:	80 81       	ld	r24, Z
    7e0c:	91 81       	ldd	r25, Z+1	; 0x01
    7e0e:	ed b7       	in	r30, 0x3d	; 61
    7e10:	fe b7       	in	r31, 0x3e	; 62
    7e12:	36 96       	adiw	r30, 0x06	; 6
    7e14:	ed bf       	out	0x3d, r30	; 61
    7e16:	fe bf       	out	0x3e, r31	; 62
    7e18:	00 97       	sbiw	r24, 0x00	; 0
    7e1a:	a9 f4       	brne	.+42     	; 0x7e46 <udpPrintStatus+0xd2>
    fprintf_P(stream, PSTR("ANY\r\n"));
    7e1c:	00 d0       	rcall	.+0      	; 0x7e1e <udpPrintStatus+0xaa>
    7e1e:	0f 92       	push	r0
    7e20:	ad b7       	in	r26, 0x3d	; 61
    7e22:	be b7       	in	r27, 0x3e	; 62
    7e24:	11 96       	adiw	r26, 0x01	; 1
    7e26:	cd 93       	st	X+, r28
    7e28:	dc 93       	st	X, r29
    7e2a:	12 97       	sbiw	r26, 0x02	; 2
    7e2c:	8b ed       	ldi	r24, 0xDB	; 219
    7e2e:	9e e0       	ldi	r25, 0x0E	; 14
    7e30:	13 96       	adiw	r26, 0x03	; 3
    7e32:	8d 93       	st	X+, r24
    7e34:	9c 93       	st	X, r25
    7e36:	14 97       	sbiw	r26, 0x04	; 4
    7e38:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7e3c:	0f 90       	pop	r0
    7e3e:	0f 90       	pop	r0
    7e40:	0f 90       	pop	r0
    7e42:	0f 90       	pop	r0
    7e44:	1a c0       	rjmp	.+52     	; 0x7e7a <udpPrintStatus+0x106>
  else
    fprintf_P(stream, PSTR("%d\r\n"), htons(udpSocket->dstPortDef));    
    7e46:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <htons>
    7e4a:	00 d0       	rcall	.+0      	; 0x7e4c <udpPrintStatus+0xd8>
    7e4c:	00 d0       	rcall	.+0      	; 0x7e4e <udpPrintStatus+0xda>
    7e4e:	ed b7       	in	r30, 0x3d	; 61
    7e50:	fe b7       	in	r31, 0x3e	; 62
    7e52:	31 96       	adiw	r30, 0x01	; 1
    7e54:	ad b7       	in	r26, 0x3d	; 61
    7e56:	be b7       	in	r27, 0x3e	; 62
    7e58:	11 96       	adiw	r26, 0x01	; 1
    7e5a:	cd 93       	st	X+, r28
    7e5c:	dc 93       	st	X, r29
    7e5e:	12 97       	sbiw	r26, 0x02	; 2
    7e60:	26 ed       	ldi	r18, 0xD6	; 214
    7e62:	3e e0       	ldi	r19, 0x0E	; 14
    7e64:	22 83       	std	Z+2, r18	; 0x02
    7e66:	33 83       	std	Z+3, r19	; 0x03
    7e68:	84 83       	std	Z+4, r24	; 0x04
    7e6a:	95 83       	std	Z+5, r25	; 0x05
    7e6c:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    7e70:	ed b7       	in	r30, 0x3d	; 61
    7e72:	fe b7       	in	r31, 0x3e	; 62
    7e74:	36 96       	adiw	r30, 0x06	; 6
    7e76:	ed bf       	out	0x3d, r30	; 61
    7e78:	fe bf       	out	0x3e, r31	; 62
}
    7e7a:	df 91       	pop	r29
    7e7c:	cf 91       	pop	r28
    7e7e:	08 95       	ret

00007e80 <_crc_xmodem_update>:
    7e80:	9c 01       	movw	r18, r24
    7e82:	36 27       	eor	r19, r22
    7e84:	03 2e       	mov	r0, r19
    7e86:	02 94       	swap	r0
    7e88:	80 2d       	mov	r24, r0
    7e8a:	8f 70       	andi	r24, 0x0F	; 15
    7e8c:	83 27       	eor	r24, r19
    7e8e:	63 2f       	mov	r22, r19
    7e90:	60 25       	eor	r22, r0
    7e92:	66 0f       	add	r22, r22
    7e94:	60 7e       	andi	r22, 0xE0	; 224
    7e96:	86 27       	eor	r24, r22
    7e98:	60 2d       	mov	r22, r0
    7e9a:	63 27       	eor	r22, r19
    7e9c:	60 7f       	andi	r22, 0xF0	; 240
    7e9e:	66 95       	lsr	r22
    7ea0:	03 2e       	mov	r0, r19
    7ea2:	00 0c       	add	r0, r0
    7ea4:	66 1f       	adc	r22, r22
    7ea6:	36 95       	lsr	r19
    7ea8:	36 95       	lsr	r19
    7eaa:	36 95       	lsr	r19
    7eac:	3f 71       	andi	r19, 0x1F	; 31
    7eae:	36 27       	eor	r19, r22
    7eb0:	32 27       	eor	r19, r18
    7eb2:	28 2f       	mov	r18, r24
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
    7eb4:	c9 01       	movw	r24, r18
    7eb6:	08 95       	ret
    7eb8:	08 95       	ret
    7eba:	08 95       	ret
    7ebc:	08 95       	ret
    7ebe:	81 e0       	ldi	r24, 0x01	; 1
    7ec0:	08 95       	ret
    7ec2:	81 e0       	ldi	r24, 0x01	; 1
    7ec4:	08 95       	ret

00007ec6 <sendSettings>:



// ********************* Hiden Functions ***************************************************
void sendSettings(uint8_t addr, uint8_t value)
{
    7ec6:	ef 92       	push	r14
    7ec8:	ff 92       	push	r15
    7eca:	0f 93       	push	r16
    7ecc:	1f 93       	push	r17
    7ece:	df 93       	push	r29
    7ed0:	cf 93       	push	r28
    7ed2:	0f 92       	push	r0
    7ed4:	cd b7       	in	r28, 0x3d	; 61
    7ed6:	de b7       	in	r29, 0x3e	; 62
    7ed8:	08 2f       	mov	r16, r24
    7eda:	16 2f       	mov	r17, r22
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    7edc:	80 e0       	ldi	r24, 0x00	; 0
    7ede:	90 e0       	ldi	r25, 0x00	; 0
    7ee0:	6a e5       	ldi	r22, 0x5A	; 90
    7ee2:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7ee6:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    7ee8:	8a e5       	ldi	r24, 0x5A	; 90
    7eea:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    7eee:	c7 01       	movw	r24, r14
    7ef0:	60 2f       	mov	r22, r16
    7ef2:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7ef6:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    7ef8:	80 2f       	mov	r24, r16
    7efa:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rUstaw);
    7efe:	c7 01       	movw	r24, r14
    7f00:	60 e4       	ldi	r22, 0x40	; 64
    7f02:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7f06:	7c 01       	movw	r14, r24
  uartRs485SendByte(rUstaw);
    7f08:	80 e4       	ldi	r24, 0x40	; 64
    7f0a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 1);
    7f0e:	c7 01       	movw	r24, r14
    7f10:	61 e0       	ldi	r22, 0x01	; 1
    7f12:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7f16:	7c 01       	movw	r14, r24
  uartRs485SendByte(1);
    7f18:	81 e0       	ldi	r24, 0x01	; 1
    7f1a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, value);
    7f1e:	c7 01       	movw	r24, r14
    7f20:	61 2f       	mov	r22, r17
    7f22:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7f26:	08 2f       	mov	r16, r24
  uartRs485SendByte(value);
    7f28:	81 2f       	mov	r24, r17
    7f2a:	99 83       	std	Y+1, r25	; 0x01
    7f2c:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  uartRs485SendByte((uint8_t)(crc >> 8));
    7f30:	99 81       	ldd	r25, Y+1	; 0x01
    7f32:	89 2f       	mov	r24, r25
    7f34:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    7f38:	80 2f       	mov	r24, r16
    7f3a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
}
    7f3e:	0f 90       	pop	r0
    7f40:	cf 91       	pop	r28
    7f42:	df 91       	pop	r29
    7f44:	1f 91       	pop	r17
    7f46:	0f 91       	pop	r16
    7f48:	ff 90       	pop	r15
    7f4a:	ef 90       	pop	r14
    7f4c:	08 95       	ret

00007f4e <saveSettings>:

void saveSettings(uint8_t addr)
{
    7f4e:	ef 92       	push	r14
    7f50:	ff 92       	push	r15
    7f52:	1f 93       	push	r17
    7f54:	df 93       	push	r29
    7f56:	cf 93       	push	r28
    7f58:	0f 92       	push	r0
    7f5a:	cd b7       	in	r28, 0x3d	; 61
    7f5c:	de b7       	in	r29, 0x3e	; 62
    7f5e:	18 2f       	mov	r17, r24
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    7f60:	80 e0       	ldi	r24, 0x00	; 0
    7f62:	90 e0       	ldi	r25, 0x00	; 0
    7f64:	6a e5       	ldi	r22, 0x5A	; 90
    7f66:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7f6a:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    7f6c:	8a e5       	ldi	r24, 0x5A	; 90
    7f6e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    7f72:	c7 01       	movw	r24, r14
    7f74:	61 2f       	mov	r22, r17
    7f76:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7f7a:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    7f7c:	81 2f       	mov	r24, r17
    7f7e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rZapiszUstawienia);
    7f82:	c7 01       	movw	r24, r14
    7f84:	61 e4       	ldi	r22, 0x41	; 65
    7f86:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7f8a:	7c 01       	movw	r14, r24
  uartRs485SendByte(rZapiszUstawienia);
    7f8c:	81 e4       	ldi	r24, 0x41	; 65
    7f8e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 0);
    7f92:	c7 01       	movw	r24, r14
    7f94:	60 e0       	ldi	r22, 0x00	; 0
    7f96:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    7f9a:	18 2f       	mov	r17, r24
  uartRs485SendByte(0);
    7f9c:	80 e0       	ldi	r24, 0x00	; 0
    7f9e:	99 83       	std	Y+1, r25	; 0x01
    7fa0:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  uartRs485SendByte((uint8_t)(crc >> 8));
    7fa4:	99 81       	ldd	r25, Y+1	; 0x01
    7fa6:	89 2f       	mov	r24, r25
    7fa8:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    7fac:	81 2f       	mov	r24, r17
    7fae:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
}
    7fb2:	0f 90       	pop	r0
    7fb4:	cf 91       	pop	r28
    7fb6:	df 91       	pop	r29
    7fb8:	1f 91       	pop	r17
    7fba:	ff 90       	pop	r15
    7fbc:	ef 90       	pop	r14
    7fbe:	08 95       	ret

00007fc0 <rollersMemInit>:

// ************************ Rs485 API ************************************

void rollersMemInit(void)
{
  rollers = xmalloc(MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    7fc0:	8e e6       	ldi	r24, 0x6E	; 110
    7fc2:	90 e0       	ldi	r25, 0x00	; 0
    7fc4:	0e 94 1b 1c 	call	0x3836	; 0x3836 <xmalloc>
    7fc8:	80 93 08 32 	sts	0x3208, r24
    7fcc:	90 93 09 32 	sts	0x3209, r25
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    7fd0:	fc 01       	movw	r30, r24
    7fd2:	8e e6       	ldi	r24, 0x6E	; 110
    7fd4:	df 01       	movw	r26, r30
    7fd6:	1d 92       	st	X+, r1
    7fd8:	8a 95       	dec	r24
    7fda:	e9 f7       	brne	.-6      	; 0x7fd6 <rollersMemInit+0x16>
}
    7fdc:	08 95       	ret

00007fde <printRs485devices>:

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
    7fde:	af 92       	push	r10
    7fe0:	bf 92       	push	r11
    7fe2:	cf 92       	push	r12
    7fe4:	df 92       	push	r13
    7fe6:	ef 92       	push	r14
    7fe8:	ff 92       	push	r15
    7fea:	0f 93       	push	r16
    7fec:	1f 93       	push	r17
    7fee:	cf 93       	push	r28
    7ff0:	df 93       	push	r29
    7ff2:	8c 01       	movw	r16, r24
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
    7ff4:	c0 91 08 32 	lds	r28, 0x3208
    7ff8:	d0 91 09 32 	lds	r29, 0x3209
    7ffc:	2a e0       	ldi	r18, 0x0A	; 10
    7ffe:	a2 2e       	mov	r10, r18
}

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
  uint8_t result = 0;
    8000:	bb 24       	eor	r11, r11
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    8002:	91 ea       	ldi	r25, 0xA1	; 161
    8004:	e9 2e       	mov	r14, r25
    8006:	9f e0       	ldi	r25, 0x0F	; 15
    8008:	f9 2e       	mov	r15, r25
     // fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    800a:	8f ed       	ldi	r24, 0xDF	; 223
    800c:	c8 2e       	mov	r12, r24
    800e:	8f e0       	ldi	r24, 0x0F	; 15
    8010:	d8 2e       	mov	r13, r24
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    8012:	89 81       	ldd	r24, Y+1	; 0x01
    8014:	88 23       	and	r24, r24
    8016:	e9 f1       	breq	.+122    	; 0x8092 <printRs485devices+0xb4>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    8018:	2d b7       	in	r18, 0x3d	; 61
    801a:	3e b7       	in	r19, 0x3e	; 62
    801c:	2a 50       	subi	r18, 0x0A	; 10
    801e:	30 40       	sbci	r19, 0x00	; 0
    8020:	2d bf       	out	0x3d, r18	; 61
    8022:	3e bf       	out	0x3e, r19	; 62
    8024:	ed b7       	in	r30, 0x3d	; 61
    8026:	fe b7       	in	r31, 0x3e	; 62
    8028:	31 96       	adiw	r30, 0x01	; 1
    802a:	ad b7       	in	r26, 0x3d	; 61
    802c:	be b7       	in	r27, 0x3e	; 62
    802e:	11 96       	adiw	r26, 0x01	; 1
    8030:	0d 93       	st	X+, r16
    8032:	1c 93       	st	X, r17
    8034:	12 97       	sbiw	r26, 0x02	; 2
    8036:	e2 82       	std	Z+2, r14	; 0x02
    8038:	f3 82       	std	Z+3, r15	; 0x03
    803a:	84 83       	std	Z+4, r24	; 0x04
    803c:	15 82       	std	Z+5, r1	; 0x05
    803e:	2a 81       	ldd	r18, Y+2	; 0x02
    8040:	30 e0       	ldi	r19, 0x00	; 0
    8042:	2f 73       	andi	r18, 0x3F	; 63
    8044:	30 70       	andi	r19, 0x00	; 0
    8046:	26 83       	std	Z+6, r18	; 0x06
    8048:	37 83       	std	Z+7, r19	; 0x07
    804a:	2b 81       	ldd	r18, Y+3	; 0x03
    804c:	30 e0       	ldi	r19, 0x00	; 0
    804e:	2f 73       	andi	r18, 0x3F	; 63
    8050:	30 70       	andi	r19, 0x00	; 0
    8052:	20 87       	std	Z+8, r18	; 0x08
    8054:	31 87       	std	Z+9, r19	; 0x09
    8056:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
     // fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    805a:	0f 90       	pop	r0
    805c:	0f 90       	pop	r0
    805e:	0f 90       	pop	r0
    8060:	0f 90       	pop	r0
    8062:	ed b7       	in	r30, 0x3d	; 61
    8064:	fe b7       	in	r31, 0x3e	; 62
    8066:	31 96       	adiw	r30, 0x01	; 1
    8068:	ad b7       	in	r26, 0x3d	; 61
    806a:	be b7       	in	r27, 0x3e	; 62
    806c:	11 96       	adiw	r26, 0x01	; 1
    806e:	0d 93       	st	X+, r16
    8070:	1c 93       	st	X, r17
    8072:	12 97       	sbiw	r26, 0x02	; 2
    8074:	c2 82       	std	Z+2, r12	; 0x02
    8076:	d3 82       	std	Z+3, r13	; 0x03
    8078:	ce 01       	movw	r24, r28
    807a:	05 96       	adiw	r24, 0x05	; 5
    807c:	84 83       	std	Z+4, r24	; 0x04
    807e:	95 83       	std	Z+5, r25	; 0x05
    8080:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
      result++;
    8084:	b3 94       	inc	r11
    8086:	2d b7       	in	r18, 0x3d	; 61
    8088:	3e b7       	in	r19, 0x3e	; 62
    808a:	2a 5f       	subi	r18, 0xFA	; 250
    808c:	3f 4f       	sbci	r19, 0xFF	; 255
    808e:	2d bf       	out	0x3d, r18	; 61
    8090:	3e bf       	out	0x3e, r19	; 62
    8092:	aa 94       	dec	r10
{
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    8094:	11 f0       	breq	.+4      	; 0x809a <printRs485devices+0xbc>
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
     // fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
      result++;
    }
    rolTmp++;
    8096:	2b 96       	adiw	r28, 0x0b	; 11
    8098:	bc cf       	rjmp	.-136    	; 0x8012 <printRs485devices+0x34>
  }
  
  
  return result;
}
    809a:	8b 2d       	mov	r24, r11
    809c:	df 91       	pop	r29
    809e:	cf 91       	pop	r28
    80a0:	1f 91       	pop	r17
    80a2:	0f 91       	pop	r16
    80a4:	ff 90       	pop	r15
    80a6:	ef 90       	pop	r14
    80a8:	df 90       	pop	r13
    80aa:	cf 90       	pop	r12
    80ac:	bf 90       	pop	r11
    80ae:	af 90       	pop	r10
    80b0:	08 95       	ret

000080b2 <rs485ping>:
#endif /*PRINT_RS485_DEVICE*/

uint8_t rs485ping(uint8_t devAddr)
{
    80b2:	cf 92       	push	r12
    80b4:	df 92       	push	r13
    80b6:	ef 92       	push	r14
    80b8:	ff 92       	push	r15
    80ba:	0f 93       	push	r16
    80bc:	1f 93       	push	r17
    80be:	df 93       	push	r29
    80c0:	cf 93       	push	r28
    80c2:	00 d0       	rcall	.+0      	; 0x80c4 <rs485ping+0x12>
    80c4:	0f 92       	push	r0
    80c6:	cd b7       	in	r28, 0x3d	; 61
    80c8:	de b7       	in	r29, 0x3e	; 62
    80ca:	f8 2e       	mov	r15, r24
  takeRs485();
    80cc:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <takeRs485>
}


void sendPing(uint8_t addr, uint8_t pingLen)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    80d0:	80 e0       	ldi	r24, 0x00	; 0
    80d2:	90 e0       	ldi	r25, 0x00	; 0
    80d4:	6a e5       	ldi	r22, 0x5A	; 90
    80d6:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    80da:	8c 01       	movw	r16, r24
  uartRs485SendByte(SYNC);
    80dc:	8a e5       	ldi	r24, 0x5A	; 90
    80de:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    80e2:	c8 01       	movw	r24, r16
    80e4:	6f 2d       	mov	r22, r15
    80e6:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    80ea:	8c 01       	movw	r16, r24
  uartRs485SendByte(addr);
    80ec:	8f 2d       	mov	r24, r15
    80ee:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rPING);
    80f2:	c8 01       	movw	r24, r16
    80f4:	60 e8       	ldi	r22, 0x80	; 128
    80f6:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    80fa:	8c 01       	movw	r16, r24
  uartRs485SendByte(rPING);
    80fc:	80 e8       	ldi	r24, 0x80	; 128
    80fe:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, pingLen);
    8102:	c8 01       	movw	r24, r16
    8104:	68 e0       	ldi	r22, 0x08	; 8
    8106:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    810a:	f8 2e       	mov	r15, r24
  uartRs485SendByte(pingLen);
    810c:	88 e0       	ldi	r24, 0x08	; 8
    810e:	9c 83       	std	Y+4, r25	; 0x04
    8110:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  
  for (uint8_t i=0; i < pingLen; i++)
    8114:	00 e0       	ldi	r16, 0x00	; 0
    8116:	9c 81       	ldd	r25, Y+4	; 0x04
  {
    crc = _crc_xmodem_update(crc, i);
    8118:	8f 2d       	mov	r24, r15
    811a:	60 2f       	mov	r22, r16
    811c:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8120:	f8 2e       	mov	r15, r24
    uartRs485SendByte(i);
    8122:	80 2f       	mov	r24, r16
    8124:	9c 83       	std	Y+4, r25	; 0x04
    8126:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte(rPING);

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
  
  for (uint8_t i=0; i < pingLen; i++)
    812a:	0f 5f       	subi	r16, 0xFF	; 255
    812c:	9c 81       	ldd	r25, Y+4	; 0x04
    812e:	08 30       	cpi	r16, 0x08	; 8
    8130:	99 f7       	brne	.-26     	; 0x8118 <rs485ping+0x66>
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
  }
  uartRs485SendByte((uint8_t)(crc >> 8));
    8132:	89 2f       	mov	r24, r25
    8134:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8138:	8f 2d       	mov	r24, r15
    813a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  addr = 0;
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    813e:	8e 01       	movw	r16, r28
    8140:	0f 5f       	subi	r16, 0xFF	; 255
    8142:	1f 4f       	sbci	r17, 0xFF	; 255
    8144:	c8 01       	movw	r24, r16
    8146:	64 e1       	ldi	r22, 0x14	; 20
    8148:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    814c:	88 23       	and	r24, r24
    814e:	09 f4       	brne	.+2      	; 0x8152 <rs485ping+0xa0>
    8150:	75 c0       	rjmp	.+234    	; 0x823c <rs485ping+0x18a>
    return 1;
  
  if (data != SYNC)
    8152:	89 81       	ldd	r24, Y+1	; 0x01
    8154:	8a 35       	cpi	r24, 0x5A	; 90
    8156:	09 f0       	breq	.+2      	; 0x815a <rs485ping+0xa8>
    8158:	73 c0       	rjmp	.+230    	; 0x8240 <rs485ping+0x18e>
    return 2;
  crc = _crc_xmodem_update(0, data);
    815a:	80 e0       	ldi	r24, 0x00	; 0
    815c:	90 e0       	ldi	r25, 0x00	; 0
    815e:	6a e5       	ldi	r22, 0x5A	; 90
    8160:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8164:	7c 01       	movw	r14, r24

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    8166:	c8 01       	movw	r24, r16
    8168:	61 e0       	ldi	r22, 0x01	; 1
    816a:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    816e:	88 23       	and	r24, r24
    8170:	09 f4       	brne	.+2      	; 0x8174 <rs485ping+0xc2>
    8172:	68 c0       	rjmp	.+208    	; 0x8244 <rs485ping+0x192>
    return 3;

  if (data != 0)
    8174:	89 81       	ldd	r24, Y+1	; 0x01
    8176:	88 23       	and	r24, r24
    8178:	09 f0       	breq	.+2      	; 0x817c <rs485ping+0xca>
    817a:	66 c0       	rjmp	.+204    	; 0x8248 <rs485ping+0x196>
    return 4;
  
  crc = _crc_xmodem_update(crc, data);
    817c:	c7 01       	movw	r24, r14
    817e:	60 e0       	ldi	r22, 0x00	; 0
    8180:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8184:	7c 01       	movw	r14, r24

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    8186:	c8 01       	movw	r24, r16
    8188:	61 e0       	ldi	r22, 0x01	; 1
    818a:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    818e:	88 23       	and	r24, r24
    8190:	09 f4       	brne	.+2      	; 0x8194 <rs485ping+0xe2>
    8192:	5c c0       	rjmp	.+184    	; 0x824c <rs485ping+0x19a>
    return 5;
  if (data != rPING)
    8194:	89 81       	ldd	r24, Y+1	; 0x01
    8196:	80 38       	cpi	r24, 0x80	; 128
    8198:	09 f0       	breq	.+2      	; 0x819c <rs485ping+0xea>
    819a:	5a c0       	rjmp	.+180    	; 0x8250 <rs485ping+0x19e>
    return 6;
  crc = _crc_xmodem_update(crc, data);
    819c:	c7 01       	movw	r24, r14
    819e:	60 e8       	ldi	r22, 0x80	; 128
    81a0:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    81a4:	7c 01       	movw	r14, r24

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    81a6:	c8 01       	movw	r24, r16
    81a8:	61 e0       	ldi	r22, 0x01	; 1
    81aa:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    81ae:	88 23       	and	r24, r24
    81b0:	09 f4       	brne	.+2      	; 0x81b4 <rs485ping+0x102>
    81b2:	50 c0       	rjmp	.+160    	; 0x8254 <rs485ping+0x1a2>
    return 7;
  if (data != dataLen)
    81b4:	89 81       	ldd	r24, Y+1	; 0x01
    81b6:	88 30       	cpi	r24, 0x08	; 8
    81b8:	09 f0       	breq	.+2      	; 0x81bc <rs485ping+0x10a>
    81ba:	4e c0       	rjmp	.+156    	; 0x8258 <rs485ping+0x1a6>
    return 8;
  crc = _crc_xmodem_update(crc, data);
    81bc:	c7 01       	movw	r24, r14
    81be:	68 e0       	ldi	r22, 0x08	; 8
    81c0:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    81c4:	7c 01       	movw	r14, r24

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    81c6:	dd 24       	eor	r13, r13
  {
    if(rs485Receive(&data, 5) == pdFALSE)
    81c8:	c0 2e       	mov	r12, r16
    81ca:	01 2f       	mov	r16, r17
    81cc:	8c 2d       	mov	r24, r12
    81ce:	90 2f       	mov	r25, r16
    81d0:	65 e0       	ldi	r22, 0x05	; 5
    81d2:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    81d6:	88 23       	and	r24, r24
    81d8:	21 f4       	brne	.+8      	; 0x81e2 <rs485ping+0x130>
      return 2*temp+9;
    81da:	0d 2d       	mov	r16, r13
    81dc:	00 0f       	add	r16, r16
    81de:	07 5f       	subi	r16, 0xF7	; 247
    81e0:	44 c0       	rjmp	.+136    	; 0x826a <rs485ping+0x1b8>
    crc = _crc_xmodem_update(crc, data);
    81e2:	c7 01       	movw	r24, r14
    81e4:	69 81       	ldd	r22, Y+1	; 0x01
    81e6:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    81ea:	7c 01       	movw	r14, r24
    if (data != temp)
    81ec:	89 81       	ldd	r24, Y+1	; 0x01
    81ee:	8d 15       	cp	r24, r13
    81f0:	21 f0       	breq	.+8      	; 0x81fa <rs485ping+0x148>
      return 2*temp+10; 
    81f2:	0d 2d       	mov	r16, r13
    81f4:	00 0f       	add	r16, r16
    81f6:	06 5f       	subi	r16, 0xF6	; 246
    81f8:	38 c0       	rjmp	.+112    	; 0x826a <rs485ping+0x1b8>
    return 8;
  crc = _crc_xmodem_update(crc, data);

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    81fa:	d3 94       	inc	r13
    81fc:	8d 2d       	mov	r24, r13
    81fe:	88 30       	cpi	r24, 0x08	; 8
    8200:	29 f7       	brne	.-54     	; 0x81cc <rs485ping+0x11a>
      return 2*temp+10; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    8202:	ce 01       	movw	r24, r28
    8204:	02 96       	adiw	r24, 0x02	; 2
    8206:	61 e0       	ldi	r22, 0x01	; 1
    8208:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    820c:	81 30       	cpi	r24, 0x01	; 1
    820e:	31 f5       	brne	.+76     	; 0x825c <rs485ping+0x1aa>
    return 2*temp+11;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    8210:	80 91 fc 31 	lds	r24, 0x31FC
    8214:	90 91 fd 31 	lds	r25, 0x31FD
    8218:	be 01       	movw	r22, r28
    821a:	6d 5f       	subi	r22, 0xFD	; 253
    821c:	7f 4f       	sbci	r23, 0xFF	; 255
    821e:	41 e0       	ldi	r20, 0x01	; 1
    8220:	50 e0       	ldi	r21, 0x00	; 0
    8222:	20 e0       	ldi	r18, 0x00	; 0
    8224:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    8228:	81 30       	cpi	r24, 0x01	; 1
    822a:	d1 f4       	brne	.+52     	; 0x8260 <rs485ping+0x1ae>
    return 2*temp+12;

  if (crcHi != (uint8_t)(crc>>8))
    822c:	8a 81       	ldd	r24, Y+2	; 0x02
    822e:	8f 15       	cp	r24, r15
    8230:	c9 f4       	brne	.+50     	; 0x8264 <rs485ping+0x1b2>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    8232:	8b 81       	ldd	r24, Y+3	; 0x03
    8234:	8e 15       	cp	r24, r14
    8236:	c1 f0       	breq	.+48     	; 0x8268 <rs485ping+0x1b6>
    return 255;
    8238:	0f ef       	ldi	r16, 0xFF	; 255
    823a:	17 c0       	rjmp	.+46     	; 0x826a <rs485ping+0x1b8>
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    return 1;
    823c:	01 e0       	ldi	r16, 0x01	; 1
    823e:	15 c0       	rjmp	.+42     	; 0x826a <rs485ping+0x1b8>
  
  if (data != SYNC)
    return 2;
    8240:	02 e0       	ldi	r16, 0x02	; 2
    8242:	13 c0       	rjmp	.+38     	; 0x826a <rs485ping+0x1b8>
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    return 3;
    8244:	03 e0       	ldi	r16, 0x03	; 3
    8246:	11 c0       	rjmp	.+34     	; 0x826a <rs485ping+0x1b8>

  if (data != 0)
    return 4;
    8248:	04 e0       	ldi	r16, 0x04	; 4
    824a:	0f c0       	rjmp	.+30     	; 0x826a <rs485ping+0x1b8>
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    return 5;
    824c:	05 e0       	ldi	r16, 0x05	; 5
    824e:	0d c0       	rjmp	.+26     	; 0x826a <rs485ping+0x1b8>
  if (data != rPING)
    return 6;
    8250:	06 e0       	ldi	r16, 0x06	; 6
    8252:	0b c0       	rjmp	.+22     	; 0x826a <rs485ping+0x1b8>
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
    8254:	07 e0       	ldi	r16, 0x07	; 7
    8256:	09 c0       	rjmp	.+18     	; 0x826a <rs485ping+0x1b8>
  if (data != dataLen)
    return 8;
    8258:	08 e0       	ldi	r16, 0x08	; 8
    825a:	07 c0       	rjmp	.+14     	; 0x826a <rs485ping+0x1b8>
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    return 2*temp+11;
    825c:	0b e1       	ldi	r16, 0x1B	; 27
    825e:	05 c0       	rjmp	.+10     	; 0x826a <rs485ping+0x1b8>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    return 2*temp+12;
    8260:	0c e1       	ldi	r16, 0x1C	; 28
    8262:	03 c0       	rjmp	.+6      	; 0x826a <rs485ping+0x1b8>

  if (crcHi != (uint8_t)(crc>>8))
    return 254;
    8264:	0e ef       	ldi	r16, 0xFE	; 254
    8266:	01 c0       	rjmp	.+2      	; 0x826a <rs485ping+0x1b8>
  if (crcLo != (uint8_t)(crc & 0xFF))
    return 255;
  
  return 0; 
    8268:	00 e0       	ldi	r16, 0x00	; 0
{
  takeRs485();
  const int len = 8;    
  sendPing(devAddr, len);
  uint8_t result = receivePong(devAddr, len);
  flushRs485RecBuffer();
    826a:	0e 94 3b 0a 	call	0x1476	; 0x1476 <flushRs485RecBuffer>

  releaseRs485();
    826e:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <releaseRs485>
  return result;
}
    8272:	80 2f       	mov	r24, r16
    8274:	24 96       	adiw	r28, 0x04	; 4
    8276:	cd bf       	out	0x3d, r28	; 61
    8278:	de bf       	out	0x3e, r29	; 62
    827a:	cf 91       	pop	r28
    827c:	df 91       	pop	r29
    827e:	1f 91       	pop	r17
    8280:	0f 91       	pop	r16
    8282:	ff 90       	pop	r15
    8284:	ef 90       	pop	r14
    8286:	df 90       	pop	r13
    8288:	cf 90       	pop	r12
    828a:	08 95       	ret

0000828c <rs485rollerHello>:

uint8_t rs485rollerHello(uint8_t devAddr)
{
    828c:	cf 92       	push	r12
    828e:	df 92       	push	r13
    8290:	ef 92       	push	r14
    8292:	ff 92       	push	r15
    8294:	0f 93       	push	r16
    8296:	1f 93       	push	r17
    8298:	df 93       	push	r29
    829a:	cf 93       	push	r28
    829c:	00 d0       	rcall	.+0      	; 0x829e <rs485rollerHello+0x12>
    829e:	0f 92       	push	r0
    82a0:	cd b7       	in	r28, 0x3d	; 61
    82a2:	de b7       	in	r29, 0x3e	; 62
    82a4:	c8 2e       	mov	r12, r24
    {
      tmp->state &= (~NOT_DETECTED);
      tmp->address = devAddr;
    }
    else
      return 1;
    82a6:	e0 91 08 32 	lds	r30, 0x3208
    82aa:	f0 91 09 32 	lds	r31, 0x3209
uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    82ae:	8a e0       	ldi	r24, 0x0A	; 10
  return result;
}

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
    82b0:	00 e0       	ldi	r16, 0x00	; 0
    82b2:	10 e0       	ldi	r17, 0x00	; 0
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    82b4:	91 81       	ldd	r25, Z+1	; 0x01
    82b6:	9c 15       	cp	r25, r12
    82b8:	11 f4       	brne	.+4      	; 0x82be <rs485rollerHello+0x32>
      tmp = &rollers[i];
    82ba:	0e 2f       	mov	r16, r30
    82bc:	1f 2f       	mov	r17, r31
uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    82be:	81 50       	subi	r24, 0x01	; 1
    82c0:	3b 96       	adiw	r30, 0x0b	; 11

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    82c2:	88 23       	and	r24, r24
    82c4:	b9 f7       	brne	.-18     	; 0x82b4 <rs485rollerHello+0x28>
    if (rollers[i].address == devAddr)
      tmp = &rollers[i];
    
  if (rs485ping(devAddr)==0)
    82c6:	8c 2d       	mov	r24, r12
    82c8:	0e 94 59 40 	call	0x80b2	; 0x80b2 <rs485ping>
    82cc:	88 23       	and	r24, r24
    82ce:	f1 f4       	brne	.+60     	; 0x830c <rs485rollerHello+0x80>
  {
    if (tmp == NULL)
    82d0:	01 15       	cp	r16, r1
    82d2:	11 05       	cpc	r17, r1
    82d4:	79 f4       	brne	.+30     	; 0x82f4 <rs485rollerHello+0x68>
    82d6:	e0 91 08 32 	lds	r30, 0x3208
    82da:	f0 91 09 32 	lds	r31, 0x3209
    82de:	8f 01       	movw	r16, r30
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
      {
        if (rollers[i].address == 0)
    82e0:	91 81       	ldd	r25, Z+1	; 0x01
    82e2:	99 23       	and	r25, r25
    82e4:	11 f4       	brne	.+4      	; 0x82ea <rs485rollerHello+0x5e>
        {
          tmp = &rollers[i];
          tmp->address = devAddr;
    82e6:	c1 82       	std	Z+1, r12	; 0x01
          break;
    82e8:	05 c0       	rjmp	.+10     	; 0x82f4 <rs485rollerHello+0x68>
    
  if (rs485ping(devAddr)==0)
  {
    if (tmp == NULL)
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    82ea:	8f 5f       	subi	r24, 0xFF	; 255
    82ec:	3b 96       	adiw	r30, 0x0b	; 11
    82ee:	8a 30       	cpi	r24, 0x0A	; 10
    82f0:	b1 f7       	brne	.-20     	; 0x82de <rs485rollerHello+0x52>
    82f2:	e2 c0       	rjmp	.+452    	; 0x84b8 <rs485rollerHello+0x22c>
          tmp->address = devAddr;
          break;
        }
      }
    }
    if (tmp != NULL)
    82f4:	01 15       	cp	r16, r1
    82f6:	11 05       	cpc	r17, r1
    82f8:	09 f4       	brne	.+2      	; 0x82fc <rs485rollerHello+0x70>
    82fa:	de c0       	rjmp	.+444    	; 0x84b8 <rs485rollerHello+0x22c>
    {
      tmp->state &= (~NOT_DETECTED);
    82fc:	d8 01       	movw	r26, r16
    82fe:	8c 91       	ld	r24, X
    8300:	8e 7f       	andi	r24, 0xFE	; 254
    8302:	8c 93       	st	X, r24
      tmp->address = devAddr;
    8304:	11 96       	adiw	r26, 0x01	; 1
    8306:	cc 92       	st	X, r12
    8308:	11 97       	sbiw	r26, 0x01	; 1
    830a:	0c c0       	rjmp	.+24     	; 0x8324 <rs485rollerHello+0x98>
    else
      return 1;
  }
  else
  {
    if (tmp != NULL)
    830c:	01 15       	cp	r16, r1
    830e:	11 05       	cpc	r17, r1
    8310:	49 f0       	breq	.+18     	; 0x8324 <rs485rollerHello+0x98>
    {
      if (tmp->state & NOT_DETECTED)
    8312:	f8 01       	movw	r30, r16
    8314:	80 81       	ld	r24, Z
    8316:	80 fd       	sbrc	r24, 0
      {
        tmp->address = 0;
    8318:	11 82       	std	Z+1, r1	; 0x01
      }
      tmp->state |= NOT_DETECTED;
    831a:	81 60       	ori	r24, 0x01	; 1
    831c:	d8 01       	movw	r26, r16
    831e:	8c 93       	st	X, r24
      return 2;
    8320:	82 e0       	ldi	r24, 0x02	; 2
    8322:	cb c0       	rjmp	.+406    	; 0x84ba <rs485rollerHello+0x22e>
    }
  }
  
  takeRs485();
    8324:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <takeRs485>
  return 0; 
}

static void    sendHello(uint8_t addr)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    8328:	80 e0       	ldi	r24, 0x00	; 0
    832a:	90 e0       	ldi	r25, 0x00	; 0
    832c:	6a e5       	ldi	r22, 0x5A	; 90
    832e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8332:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    8334:	8a e5       	ldi	r24, 0x5A	; 90
    8336:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    833a:	c7 01       	movw	r24, r14
    833c:	6c 2d       	mov	r22, r12
    833e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8342:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    8344:	8c 2d       	mov	r24, r12
    8346:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rHELLO);
    834a:	c7 01       	movw	r24, r14
    834c:	62 e8       	ldi	r22, 0x82	; 130
    834e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8352:	7c 01       	movw	r14, r24
  uartRs485SendByte(rHELLO);
    8354:	82 e8       	ldi	r24, 0x82	; 130
    8356:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 0);
    835a:	c7 01       	movw	r24, r14
    835c:	60 e0       	ldi	r22, 0x00	; 0
    835e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8362:	f8 2e       	mov	r15, r24
  uartRs485SendByte(0);
    8364:	80 e0       	ldi	r24, 0x00	; 0
    8366:	9c 83       	std	Y+4, r25	; 0x04
    8368:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc >> 8));
    836c:	9c 81       	ldd	r25, Y+4	; 0x04
    836e:	89 2f       	mov	r24, r25
    8370:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8374:	8f 2d       	mov	r24, r15
    8376:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
static uint8_t receiveHello(uint8_t* response, uint8_t maxSize)
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    837a:	7e 01       	movw	r14, r28
    837c:	08 94       	sec
    837e:	e1 1c       	adc	r14, r1
    8380:	f1 1c       	adc	r15, r1
    8382:	c7 01       	movw	r24, r14
    8384:	64 e1       	ldi	r22, 0x14	; 20
    8386:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    838a:	88 23       	and	r24, r24
    838c:	09 f4       	brne	.+2      	; 0x8390 <rs485rollerHello+0x104>
    838e:	76 c0       	rjmp	.+236    	; 0x847c <rs485rollerHello+0x1f0>
    return 8;
  
  if (data != SYNC)
    8390:	89 81       	ldd	r24, Y+1	; 0x01
    8392:	8a 35       	cpi	r24, 0x5A	; 90
    8394:	09 f0       	breq	.+2      	; 0x8398 <rs485rollerHello+0x10c>
    8396:	74 c0       	rjmp	.+232    	; 0x8480 <rs485rollerHello+0x1f4>
    return 2;
  crc = _crc_xmodem_update(0, data);
    8398:	80 e0       	ldi	r24, 0x00	; 0
    839a:	90 e0       	ldi	r25, 0x00	; 0
    839c:	6a e5       	ldi	r22, 0x5A	; 90
    839e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    83a2:	6c 01       	movw	r12, r24

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    83a4:	c7 01       	movw	r24, r14
    83a6:	61 e0       	ldi	r22, 0x01	; 1
    83a8:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    83ac:	88 23       	and	r24, r24
    83ae:	09 f4       	brne	.+2      	; 0x83b2 <rs485rollerHello+0x126>
    83b0:	69 c0       	rjmp	.+210    	; 0x8484 <rs485rollerHello+0x1f8>
    return 3;

  if (data != 0)
    83b2:	89 81       	ldd	r24, Y+1	; 0x01
    83b4:	88 23       	and	r24, r24
    83b6:	09 f0       	breq	.+2      	; 0x83ba <rs485rollerHello+0x12e>
    83b8:	67 c0       	rjmp	.+206    	; 0x8488 <rs485rollerHello+0x1fc>
    return 4;
  
  crc = _crc_xmodem_update(crc, data);
    83ba:	c6 01       	movw	r24, r12
    83bc:	60 e0       	ldi	r22, 0x00	; 0
    83be:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    83c2:	6c 01       	movw	r12, r24

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    83c4:	c7 01       	movw	r24, r14
    83c6:	61 e0       	ldi	r22, 0x01	; 1
    83c8:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    83cc:	88 23       	and	r24, r24
    83ce:	09 f4       	brne	.+2      	; 0x83d2 <rs485rollerHello+0x146>
    83d0:	5d c0       	rjmp	.+186    	; 0x848c <rs485rollerHello+0x200>
    return 5;
  if (data != rHELLO)
    83d2:	89 81       	ldd	r24, Y+1	; 0x01
    83d4:	82 38       	cpi	r24, 0x82	; 130
    83d6:	09 f0       	breq	.+2      	; 0x83da <rs485rollerHello+0x14e>
    83d8:	5b c0       	rjmp	.+182    	; 0x8490 <rs485rollerHello+0x204>
    return 6;
  crc = _crc_xmodem_update(crc, data);
    83da:	c6 01       	movw	r24, r12
    83dc:	62 e8       	ldi	r22, 0x82	; 130
    83de:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    83e2:	6c 01       	movw	r12, r24

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    83e4:	c7 01       	movw	r24, r14
    83e6:	61 e0       	ldi	r22, 0x01	; 1
    83e8:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    83ec:	88 23       	and	r24, r24
    83ee:	09 f4       	brne	.+2      	; 0x83f2 <rs485rollerHello+0x166>
    83f0:	51 c0       	rjmp	.+162    	; 0x8494 <rs485rollerHello+0x208>
    return 7;
  if (data > maxSize)
    83f2:	69 81       	ldd	r22, Y+1	; 0x01
    83f4:	69 30       	cpi	r22, 0x09	; 9
    83f6:	08 f0       	brcs	.+2      	; 0x83fa <rs485rollerHello+0x16e>
    83f8:	4f c0       	rjmp	.+158    	; 0x8498 <rs485rollerHello+0x20c>
    }
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
    83fa:	0e 5f       	subi	r16, 0xFE	; 254
    83fc:	1f 4f       	sbci	r17, 0xFF	; 255
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
  if (data > maxSize)
    return 1;
  
  crc = _crc_xmodem_update(crc, data);
    83fe:	c6 01       	movw	r24, r12
    8400:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8404:	e8 2e       	mov	r14, r24
    8406:	c9 2e       	mov	r12, r25
  memset(response, 0, maxSize);
    8408:	88 e0       	ldi	r24, 0x08	; 8
    840a:	d8 01       	movw	r26, r16
    840c:	1d 92       	st	X+, r1
    840e:	8a 95       	dec	r24
    8410:	e9 f7       	brne	.-6      	; 0x840c <rs485rollerHello+0x180>
  maxSize = data;
    8412:	f9 80       	ldd	r15, Y+1	; 0x01
  
  for (data=0; data < maxSize; data++)
    8414:	19 82       	std	Y+1, r1	; 0x01
    8416:	12 c0       	rjmp	.+36     	; 0x843c <rs485rollerHello+0x1b0>
  {
    if(rs485Receive(response, 5) == pdFALSE)
    8418:	c8 01       	movw	r24, r16
    841a:	65 e0       	ldi	r22, 0x05	; 5
    841c:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    8420:	88 23       	and	r24, r24
    8422:	e1 f1       	breq	.+120    	; 0x849c <rs485rollerHello+0x210>
      return 20;
    crc = _crc_xmodem_update(crc, *((uint8_t *)(response)));
    8424:	8e 2d       	mov	r24, r14
    8426:	9c 2d       	mov	r25, r12
    8428:	f8 01       	movw	r30, r16
    842a:	61 91       	ld	r22, Z+
    842c:	8f 01       	movw	r16, r30
    842e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8432:	e8 2e       	mov	r14, r24
    8434:	c9 2e       	mov	r12, r25
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
    8436:	89 81       	ldd	r24, Y+1	; 0x01
    8438:	8f 5f       	subi	r24, 0xFF	; 255
    843a:	89 83       	std	Y+1, r24	; 0x01
    843c:	89 81       	ldd	r24, Y+1	; 0x01
    843e:	8f 15       	cp	r24, r15
    8440:	58 f3       	brcs	.-42     	; 0x8418 <rs485rollerHello+0x18c>
    response++; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    8442:	ce 01       	movw	r24, r28
    8444:	02 96       	adiw	r24, 0x02	; 2
    8446:	61 e0       	ldi	r22, 0x01	; 1
    8448:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    844c:	81 30       	cpi	r24, 0x01	; 1
    844e:	41 f5       	brne	.+80     	; 0x84a0 <rs485rollerHello+0x214>
    return 21;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    8450:	80 91 fc 31 	lds	r24, 0x31FC
    8454:	90 91 fd 31 	lds	r25, 0x31FD
    8458:	be 01       	movw	r22, r28
    845a:	6d 5f       	subi	r22, 0xFD	; 253
    845c:	7f 4f       	sbci	r23, 0xFF	; 255
    845e:	41 e0       	ldi	r20, 0x01	; 1
    8460:	50 e0       	ldi	r21, 0x00	; 0
    8462:	20 e0       	ldi	r18, 0x00	; 0
    8464:	0e 94 cb 4e 	call	0x9d96	; 0x9d96 <xQueueGenericReceive>
    8468:	81 30       	cpi	r24, 0x01	; 1
    846a:	e1 f4       	brne	.+56     	; 0x84a4 <rs485rollerHello+0x218>
    return 22;

  if (crcHi != (uint8_t)(crc>>8))
    846c:	8a 81       	ldd	r24, Y+2	; 0x02
    846e:	8c 15       	cp	r24, r12
    8470:	d9 f4       	brne	.+54     	; 0x84a8 <rs485rollerHello+0x21c>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    8472:	8b 81       	ldd	r24, Y+3	; 0x03
    8474:	8e 15       	cp	r24, r14
    8476:	d1 f0       	breq	.+52     	; 0x84ac <rs485rollerHello+0x220>
    return 255;
    8478:	8f ef       	ldi	r24, 0xFF	; 255
    847a:	19 c0       	rjmp	.+50     	; 0x84ae <rs485rollerHello+0x222>
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    return 8;
    847c:	88 e0       	ldi	r24, 0x08	; 8
    847e:	17 c0       	rjmp	.+46     	; 0x84ae <rs485rollerHello+0x222>
  
  if (data != SYNC)
    return 2;
    8480:	82 e0       	ldi	r24, 0x02	; 2
    8482:	15 c0       	rjmp	.+42     	; 0x84ae <rs485rollerHello+0x222>
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    return 3;
    8484:	83 e0       	ldi	r24, 0x03	; 3
    8486:	13 c0       	rjmp	.+38     	; 0x84ae <rs485rollerHello+0x222>

  if (data != 0)
    return 4;
    8488:	84 e0       	ldi	r24, 0x04	; 4
    848a:	11 c0       	rjmp	.+34     	; 0x84ae <rs485rollerHello+0x222>
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    return 5;
    848c:	85 e0       	ldi	r24, 0x05	; 5
    848e:	0f c0       	rjmp	.+30     	; 0x84ae <rs485rollerHello+0x222>
  if (data != rHELLO)
    return 6;
    8490:	86 e0       	ldi	r24, 0x06	; 6
    8492:	0d c0       	rjmp	.+26     	; 0x84ae <rs485rollerHello+0x222>
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
    8494:	87 e0       	ldi	r24, 0x07	; 7
    8496:	0b c0       	rjmp	.+22     	; 0x84ae <rs485rollerHello+0x222>
  if (data > maxSize)
    return 1;
    8498:	81 e0       	ldi	r24, 0x01	; 1
    849a:	09 c0       	rjmp	.+18     	; 0x84ae <rs485rollerHello+0x222>
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
  {
    if(rs485Receive(response, 5) == pdFALSE)
      return 20;
    849c:	84 e1       	ldi	r24, 0x14	; 20
    849e:	07 c0       	rjmp	.+14     	; 0x84ae <rs485rollerHello+0x222>
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    return 21;
    84a0:	85 e1       	ldi	r24, 0x15	; 21
    84a2:	05 c0       	rjmp	.+10     	; 0x84ae <rs485rollerHello+0x222>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    return 22;
    84a4:	86 e1       	ldi	r24, 0x16	; 22
    84a6:	03 c0       	rjmp	.+6      	; 0x84ae <rs485rollerHello+0x222>

  if (crcHi != (uint8_t)(crc>>8))
    return 254;
    84a8:	8e ef       	ldi	r24, 0xFE	; 254
    84aa:	01 c0       	rjmp	.+2      	; 0x84ae <rs485rollerHello+0x222>
  if (crcLo != (uint8_t)(crc & 0xFF))
    return 255;
  
  return 0; 
    84ac:	80 e0       	ldi	r24, 0x00	; 0
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
    84ae:	8c 83       	std	Y+4, r24	; 0x04
    84b0:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <releaseRs485>
  return result;
    84b4:	8c 81       	ldd	r24, Y+4	; 0x04
    84b6:	01 c0       	rjmp	.+2      	; 0x84ba <rs485rollerHello+0x22e>
    {
      tmp->state &= (~NOT_DETECTED);
      tmp->address = devAddr;
    }
    else
      return 1;
    84b8:	81 e0       	ldi	r24, 0x01	; 1
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
  return result;
}
    84ba:	24 96       	adiw	r28, 0x04	; 4
    84bc:	cd bf       	out	0x3d, r28	; 61
    84be:	de bf       	out	0x3e, r29	; 62
    84c0:	cf 91       	pop	r28
    84c2:	df 91       	pop	r29
    84c4:	1f 91       	pop	r17
    84c6:	0f 91       	pop	r16
    84c8:	ff 90       	pop	r15
    84ca:	ef 90       	pop	r14
    84cc:	df 90       	pop	r13
    84ce:	cf 90       	pop	r12
    84d0:	08 95       	ret

000084d2 <rs485xModemFlash>:


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
    84d2:	4f 92       	push	r4
    84d4:	5f 92       	push	r5
    84d6:	7f 92       	push	r7
    84d8:	8f 92       	push	r8
    84da:	9f 92       	push	r9
    84dc:	af 92       	push	r10
    84de:	bf 92       	push	r11
    84e0:	cf 92       	push	r12
    84e2:	df 92       	push	r13
    84e4:	ef 92       	push	r14
    84e6:	ff 92       	push	r15
    84e8:	0f 93       	push	r16
    84ea:	1f 93       	push	r17
    84ec:	df 93       	push	r29
    84ee:	cf 93       	push	r28
    84f0:	00 d0       	rcall	.+0      	; 0x84f2 <rs485xModemFlash+0x20>
    84f2:	cd b7       	in	r28, 0x3d	; 61
    84f4:	de b7       	in	r29, 0x3e	; 62
    84f6:	2c 01       	movw	r4, r24
    84f8:	c6 2e       	mov	r12, r22
    84fa:	8a 01       	movw	r16, r20
  uint8_t  blad = 0;
  uint8_t  data;
  uint8_t  nrBloku;
  uint8_t  lRetransmisji;
  
  takeRs485();                                  // Zajmowanie magistrali Rs485
    84fc:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <takeRs485>

  // Wysyłanie polecenia restartu
  crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    8500:	80 e0       	ldi	r24, 0x00	; 0
    8502:	90 e0       	ldi	r25, 0x00	; 0
    8504:	6a e5       	ldi	r22, 0x5A	; 90
    8506:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    850a:	7c 01       	movw	r14, r24
    850c:	8a e5       	ldi	r24, 0x5A	; 90
    850e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8512:	c7 01       	movw	r24, r14
    8514:	6c 2d       	mov	r22, r12
    8516:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    851a:	7c 01       	movw	r14, r24
    851c:	8c 2d       	mov	r24, r12
    851e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    8522:	c7 01       	movw	r24, r14
    8524:	61 e8       	ldi	r22, 0x81	; 129
    8526:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    852a:	7c 01       	movw	r14, r24
    852c:	81 e8       	ldi	r24, 0x81	; 129
    852e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    8532:	c7 01       	movw	r24, r14
    8534:	61 e0       	ldi	r22, 0x01	; 1
    8536:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    853a:	7c 01       	movw	r14, r24
    853c:	81 e0       	ldi	r24, 0x01	; 1
    853e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8542:	c7 01       	movw	r24, r14
    8544:	6c 2d       	mov	r22, r12
    8546:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    854a:	e8 2e       	mov	r14, r24
    854c:	8c 2d       	mov	r24, r12
    854e:	9b 83       	std	Y+3, r25	; 0x03
    8550:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc>>8));
    8554:	9b 81       	ldd	r25, Y+3	; 0x03
    8556:	89 2f       	mov	r24, r25
    8558:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    855c:	8e 2d       	mov	r24, r14
    855e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
 

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
    8562:	ce 01       	movw	r24, r28
    8564:	01 96       	adiw	r24, 0x01	; 1
    8566:	64 e6       	ldi	r22, 0x64	; 100
    8568:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    856c:	81 30       	cpi	r24, 0x01	; 1
    856e:	c1 f0       	breq	.+48     	; 0x85a0 <rs485xModemFlash+0xce>
  {
    blad = 1;                                  // Timeout
    if (debugStr != NULL)
    8570:	01 15       	cp	r16, r1
    8572:	11 05       	cpc	r17, r1
    8574:	b9 f0       	breq	.+46     	; 0x85a4 <rs485xModemFlash+0xd2>
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
    8576:	00 d0       	rcall	.+0      	; 0x8578 <rs485xModemFlash+0xa6>
    8578:	0f 92       	push	r0
    857a:	ad b7       	in	r26, 0x3d	; 61
    857c:	be b7       	in	r27, 0x3e	; 62
    857e:	11 96       	adiw	r26, 0x01	; 1
    8580:	0d 93       	st	X+, r16
    8582:	1c 93       	st	X, r17
    8584:	12 97       	sbiw	r26, 0x02	; 2
    8586:	86 e4       	ldi	r24, 0x46	; 70
    8588:	90 e1       	ldi	r25, 0x10	; 16
    858a:	13 96       	adiw	r26, 0x03	; 3
    858c:	8d 93       	st	X+, r24
    858e:	9c 93       	st	X, r25
    8590:	14 97       	sbiw	r26, 0x04	; 4
    8592:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    8596:	0f 90       	pop	r0
    8598:	0f 90       	pop	r0
    859a:	0f 90       	pop	r0
    859c:	0f 90       	pop	r0
    859e:	02 c0       	rjmp	.+4      	; 0x85a4 <rs485xModemFlash+0xd2>


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
  uint16_t crc;
  uint8_t  blad = 0;
    85a0:	aa 24       	eor	r10, r10
    85a2:	02 c0       	rjmp	.+4      	; 0x85a8 <rs485xModemFlash+0xd6>

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
  {
    blad = 1;                                  // Timeout
    85a4:	aa 24       	eor	r10, r10
    85a6:	a3 94       	inc	r10
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
  }
  crc = _crc_xmodem_update(0, data);
    85a8:	80 e0       	ldi	r24, 0x00	; 0
    85aa:	90 e0       	ldi	r25, 0x00	; 0
    85ac:	69 81       	ldd	r22, Y+1	; 0x01
    85ae:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    85b2:	7c 01       	movw	r14, r24
 
  if ((blad == 0) && (data == 'C'))
    85b4:	aa 20       	and	r10, r10
    85b6:	c1 f4       	brne	.+48     	; 0x85e8 <rs485xModemFlash+0x116>
    85b8:	89 81       	ldd	r24, Y+1	; 0x01
    85ba:	83 34       	cpi	r24, 0x43	; 67
    85bc:	a9 f4       	brne	.+42     	; 0x85e8 <rs485xModemFlash+0x116>
  {
    blad = 253;                                //Na urządzeniu jest wgrany tylko bootloader
    if (debugStr != NULL)
    85be:	01 15       	cp	r16, r1
    85c0:	11 05       	cpc	r17, r1
    85c2:	09 f4       	brne	.+2      	; 0x85c6 <rs485xModemFlash+0xf4>
    85c4:	8f c0       	rjmp	.+286    	; 0x86e4 <rs485xModemFlash+0x212>
      fprintf_P(debugStr, PSTR("na urzadzeniu wgrany jest tylko bootloader\r\n"));    
    85c6:	00 d0       	rcall	.+0      	; 0x85c8 <rs485xModemFlash+0xf6>
    85c8:	0f 92       	push	r0
    85ca:	ed b7       	in	r30, 0x3d	; 61
    85cc:	fe b7       	in	r31, 0x3e	; 62
    85ce:	01 83       	std	Z+1, r16	; 0x01
    85d0:	12 83       	std	Z+2, r17	; 0x02
    85d2:	89 e1       	ldi	r24, 0x19	; 25
    85d4:	90 e1       	ldi	r25, 0x10	; 16
    85d6:	83 83       	std	Z+3, r24	; 0x03
    85d8:	94 83       	std	Z+4, r25	; 0x04
    85da:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    85de:	0f 90       	pop	r0
    85e0:	0f 90       	pop	r0
    85e2:	0f 90       	pop	r0
    85e4:	0f 90       	pop	r0
    85e6:	7e c0       	rjmp	.+252    	; 0x86e4 <rs485xModemFlash+0x212>
  }
  else
  {
    if (data != SYNC)
    85e8:	89 81       	ldd	r24, Y+1	; 0x01
    85ea:	8a 35       	cpi	r24, 0x5A	; 90
    85ec:	09 f0       	breq	.+2      	; 0x85f0 <rs485xModemFlash+0x11e>
    85ee:	75 c0       	rjmp	.+234    	; 0x86da <rs485xModemFlash+0x208>
      blad = 2;
  }
 
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
    85f0:	aa 20       	and	r10, r10
    85f2:	09 f0       	breq	.+2      	; 0x85f6 <rs485xModemFlash+0x124>
    85f4:	72 c0       	rjmp	.+228    	; 0x86da <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    85f6:	ce 01       	movw	r24, r28
    85f8:	01 96       	adiw	r24, 0x01	; 1
    85fa:	61 e0       	ldi	r22, 0x01	; 1
    85fc:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    8600:	81 30       	cpi	r24, 0x01	; 1
    8602:	21 f4       	brne	.+8      	; 0x860c <rs485xModemFlash+0x13a>
      blad = 3;
    else
    {
      if (data != 0)
    8604:	89 81       	ldd	r24, Y+1	; 0x01
    8606:	88 23       	and	r24, r24
    8608:	21 f4       	brne	.+8      	; 0x8612 <rs485xModemFlash+0x140>
    860a:	05 c0       	rjmp	.+10     	; 0x8616 <rs485xModemFlash+0x144>
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 3;
    860c:	33 e0       	ldi	r19, 0x03	; 3
    860e:	a3 2e       	mov	r10, r19
    8610:	02 c0       	rjmp	.+4      	; 0x8616 <rs485xModemFlash+0x144>
    else
    {
      if (data != 0)
        blad = 4;
    8612:	24 e0       	ldi	r18, 0x04	; 4
    8614:	a2 2e       	mov	r10, r18
    }
    crc = _crc_xmodem_update(crc, data);
    8616:	c7 01       	movw	r24, r14
    8618:	69 81       	ldd	r22, Y+1	; 0x01
    861a:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    861e:	7c 01       	movw	r14, r24
  }
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
    8620:	aa 20       	and	r10, r10
    8622:	09 f0       	breq	.+2      	; 0x8626 <rs485xModemFlash+0x154>
    8624:	5a c0       	rjmp	.+180    	; 0x86da <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8626:	ce 01       	movw	r24, r28
    8628:	01 96       	adiw	r24, 0x01	; 1
    862a:	61 e0       	ldi	r22, 0x01	; 1
    862c:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    8630:	81 30       	cpi	r24, 0x01	; 1
    8632:	21 f4       	brne	.+8      	; 0x863c <rs485xModemFlash+0x16a>
      blad = 5;
    else
    {
      if (data != rFLASH)
    8634:	89 81       	ldd	r24, Y+1	; 0x01
    8636:	81 38       	cpi	r24, 0x81	; 129
    8638:	21 f4       	brne	.+8      	; 0x8642 <rs485xModemFlash+0x170>
    863a:	05 c0       	rjmp	.+10     	; 0x8646 <rs485xModemFlash+0x174>
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 5;
    863c:	95 e0       	ldi	r25, 0x05	; 5
    863e:	a9 2e       	mov	r10, r25
    8640:	02 c0       	rjmp	.+4      	; 0x8646 <rs485xModemFlash+0x174>
    else
    {
      if (data != rFLASH)
        blad = 6;
    8642:	86 e0       	ldi	r24, 0x06	; 6
    8644:	a8 2e       	mov	r10, r24
    }
    crc = _crc_xmodem_update(crc, data);
    8646:	c7 01       	movw	r24, r14
    8648:	69 81       	ldd	r22, Y+1	; 0x01
    864a:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    864e:	7c 01       	movw	r14, r24
  }
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
    8650:	aa 20       	and	r10, r10
    8652:	09 f0       	breq	.+2      	; 0x8656 <rs485xModemFlash+0x184>
    8654:	42 c0       	rjmp	.+132    	; 0x86da <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8656:	ce 01       	movw	r24, r28
    8658:	01 96       	adiw	r24, 0x01	; 1
    865a:	61 e0       	ldi	r22, 0x01	; 1
    865c:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    8660:	81 30       	cpi	r24, 0x01	; 1
    8662:	21 f4       	brne	.+8      	; 0x866c <rs485xModemFlash+0x19a>
      blad = 7;
    else
    {
      if (data != 1)
    8664:	89 81       	ldd	r24, Y+1	; 0x01
    8666:	81 30       	cpi	r24, 0x01	; 1
    8668:	21 f4       	brne	.+8      	; 0x8672 <rs485xModemFlash+0x1a0>
    866a:	05 c0       	rjmp	.+10     	; 0x8676 <rs485xModemFlash+0x1a4>
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 7;
    866c:	b7 e0       	ldi	r27, 0x07	; 7
    866e:	ab 2e       	mov	r10, r27
    8670:	02 c0       	rjmp	.+4      	; 0x8676 <rs485xModemFlash+0x1a4>
    else
    {
      if (data != 1)
        blad = 8;
    8672:	a8 e0       	ldi	r26, 0x08	; 8
    8674:	aa 2e       	mov	r10, r26
    }
    crc = _crc_xmodem_update(crc, data);
    8676:	c7 01       	movw	r24, r14
    8678:	69 81       	ldd	r22, Y+1	; 0x01
    867a:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    867e:	7c 01       	movw	r14, r24
  }
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
    8680:	aa 20       	and	r10, r10
    8682:	59 f5       	brne	.+86     	; 0x86da <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8684:	ce 01       	movw	r24, r28
    8686:	01 96       	adiw	r24, 0x01	; 1
    8688:	61 e0       	ldi	r22, 0x01	; 1
    868a:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    868e:	81 30       	cpi	r24, 0x01	; 1
    8690:	21 f4       	brne	.+8      	; 0x869a <rs485xModemFlash+0x1c8>
      blad = 9;
    else
    {
      if (data != devAddr)
    8692:	89 81       	ldd	r24, Y+1	; 0x01
    8694:	8c 15       	cp	r24, r12
    8696:	21 f4       	brne	.+8      	; 0x86a0 <rs485xModemFlash+0x1ce>
    8698:	05 c0       	rjmp	.+10     	; 0x86a4 <rs485xModemFlash+0x1d2>
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 9;
    869a:	f9 e0       	ldi	r31, 0x09	; 9
    869c:	af 2e       	mov	r10, r31
    869e:	02 c0       	rjmp	.+4      	; 0x86a4 <rs485xModemFlash+0x1d2>
    else
    {
      if (data != devAddr)
        blad = 10;
    86a0:	ea e0       	ldi	r30, 0x0A	; 10
    86a2:	ae 2e       	mov	r10, r30
    }
    crc = _crc_xmodem_update(crc, data);
    86a4:	c7 01       	movw	r24, r14
    86a6:	69 81       	ldd	r22, Y+1	; 0x01
    86a8:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    86ac:	98 2e       	mov	r9, r24
    86ae:	89 2e       	mov	r8, r25
  }
   
  //Odbieranie CRC Hi
  if (blad == 0)
    86b0:	aa 20       	and	r10, r10
    86b2:	99 f4       	brne	.+38     	; 0x86da <rs485xModemFlash+0x208>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    86b4:	72 e0       	ldi	r23, 0x02	; 2
    86b6:	e7 2e       	mov	r14, r23
    86b8:	f1 2c       	mov	r15, r1
    86ba:	ec 0e       	add	r14, r28
    86bc:	fd 1e       	adc	r15, r29
    86be:	c7 01       	movw	r24, r14
    86c0:	61 e0       	ldi	r22, 0x01	; 1
    86c2:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    86c6:	81 30       	cpi	r24, 0x01	; 1
    86c8:	41 f4       	brne	.+16     	; 0x86da <rs485xModemFlash+0x208>
      blad = 11;
    else
    {
      if ((uint8_t)(crc>>8) != nrBloku)
    86ca:	8a 81       	ldd	r24, Y+2	; 0x02
    86cc:	88 15       	cp	r24, r8
    86ce:	29 f4       	brne	.+10     	; 0x86da <rs485xModemFlash+0x208>
    86d0:	f7 c0       	rjmp	.+494    	; 0x88c0 <rs485xModemFlash+0x3ee>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
      blad = 13;
    else
    {
      if ((uint8_t)(crc & 0xFF) != nrBloku)
    86d2:	8a 81       	ldd	r24, Y+2	; 0x02
    86d4:	89 15       	cp	r24, r9
    86d6:	09 f4       	brne	.+2      	; 0x86da <rs485xModemFlash+0x208>
    86d8:	fb c0       	rjmp	.+502    	; 0x88d0 <rs485xModemFlash+0x3fe>
    }    
  }
   
  if ((blad != 0) && (blad != 253))
  {
    releaseRs485();
    86da:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <releaseRs485>
    flushRs485RecBuffer();  
    86de:	0e 94 3b 0a 	call	0x1476	; 0x1476 <flushRs485RecBuffer>
    86e2:	3c c1       	rjmp	.+632    	; 0x895c <rs485xModemFlash+0x48a>
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
    86e4:	d2 01       	movw	r26, r4
    86e6:	14 96       	adiw	r26, 0x04	; 4
    86e8:	ed 91       	ld	r30, X+
    86ea:	fc 91       	ld	r31, X
    86ec:	15 97       	sbiw	r26, 0x05	; 5
    86ee:	72 80       	ldd	r7, Z+2	; 0x02
    86f0:	77 0c       	add	r7, r7
  if (file->wpis->rozmiarLo == 128)
    86f2:	81 81       	ldd	r24, Z+1	; 0x01
    86f4:	80 38       	cpi	r24, 0x80	; 128
    86f6:	99 f4       	brne	.+38     	; 0x871e <rs485xModemFlash+0x24c>
    86f8:	11 c0       	rjmp	.+34     	; 0x871c <rs485xModemFlash+0x24a>
  if (blad != 0)
  {
    releaseRs485();
    flushRs485RecBuffer();  
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    86fa:	00 d0       	rcall	.+0      	; 0x86fc <rs485xModemFlash+0x22a>
    86fc:	0f 92       	push	r0
    86fe:	ed b7       	in	r30, 0x3d	; 61
    8700:	fe b7       	in	r31, 0x3e	; 62
    8702:	01 83       	std	Z+1, r16	; 0x01
    8704:	12 83       	std	Z+2, r17	; 0x02
    8706:	8f ee       	ldi	r24, 0xEF	; 239
    8708:	9f e0       	ldi	r25, 0x0F	; 15
    870a:	83 83       	std	Z+3, r24	; 0x03
    870c:	94 83       	std	Z+4, r25	; 0x04
    870e:	0e 94 82 57 	call	0xaf04	; 0xaf04 <fprintf_P>
    8712:	0f 90       	pop	r0
    8714:	0f 90       	pop	r0
    8716:	0f 90       	pop	r0
    8718:	0f 90       	pop	r0
    871a:	20 c1       	rjmp	.+576    	; 0x895c <rs485xModemFlash+0x48a>
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
  if (file->wpis->rozmiarLo == 128)
    liczbaBlokow++;
    871c:	73 94       	inc	r7
   
  nrBloku = 1;
    871e:	81 e0       	ldi	r24, 0x01	; 1
    8720:	8a 83       	std	Y+2, r24	; 0x02
  lRetransmisji = 0;
    8722:	88 24       	eor	r8, r8
   
  while (nrBloku <= liczbaBlokow)
    8724:	99 24       	eor	r9, r9
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    8726:	6e 01       	movw	r12, r28
    8728:	08 94       	sec
    872a:	c1 1c       	adc	r12, r1
    872c:	d1 1c       	adc	r13, r1
    if (debugStr != NULL)
    {
      if (data == NAK)
        fputc('N', debugStr);
      if (data != 0)
        fprintf(debugStr, "data 0x%x ", data);                    
    872e:	6e e1       	ldi	r22, 0x1E	; 30
    8730:	a6 2e       	mov	r10, r22
    8732:	65 e2       	ldi	r22, 0x25	; 37
    8734:	b6 2e       	mov	r11, r22
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    8736:	90 c0       	rjmp	.+288    	; 0x8858 <rs485xModemFlash+0x386>
  {
    crc = 0;
    uartRs485SendByte(SOH);
    8738:	81 e0       	ldi	r24, 0x01	; 1
    873a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    uartRs485SendByte(nrBloku);
    873e:	8a 81       	ldd	r24, Y+2	; 0x02
    8740:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    data = (uint8_t)(~nrBloku);
    8744:	8a 81       	ldd	r24, Y+2	; 0x02
    8746:	80 95       	com	r24
    8748:	89 83       	std	Y+1, r24	; 0x01
    uartRs485SendByte(data);
    874a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    874e:	99 24       	eor	r9, r9
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
  {
    crc = 0;
    8750:	ee 24       	eor	r14, r14
    8752:	ff 24       	eor	r15, r15
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    8754:	c2 01       	movw	r24, r4
    8756:	b6 01       	movw	r22, r12
    8758:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <ramDyskCzytajBajtZPliku>
    875c:	81 11       	cpse	r24, r1
        data = 0;
    875e:	19 82       	std	Y+1, r1	; 0x01
      crc = _crc_xmodem_update(crc, data);
    8760:	c7 01       	movw	r24, r14
    8762:	69 81       	ldd	r22, Y+1	; 0x01
    8764:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8768:	7c 01       	movw	r14, r24
      uartRs485SendByte(data);
    876a:	89 81       	ldd	r24, Y+1	; 0x01
    876c:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    uartRs485SendByte(SOH);
    uartRs485SendByte(nrBloku);
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    8770:	93 94       	inc	r9
    8772:	f9 2d       	mov	r31, r9
    8774:	f0 38       	cpi	r31, 0x80	; 128
    8776:	71 f7       	brne	.-36     	; 0x8754 <rs485xModemFlash+0x282>
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
        data = 0;
      crc = _crc_xmodem_update(crc, data);
      uartRs485SendByte(data);
    }
    uartRs485SendByte((uint8_t)(crc>>8));
    8778:	8f 2d       	mov	r24, r15
    877a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    877e:	8e 2d       	mov	r24, r14
    8780:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
 
    if(rs485Receive(&data, 100) != pdTRUE)
    8784:	c6 01       	movw	r24, r12
    8786:	64 e6       	ldi	r22, 0x64	; 100
    8788:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    878c:	81 30       	cpi	r24, 0x01	; 1
    878e:	59 f0       	breq	.+22     	; 0x87a6 <rs485xModemFlash+0x2d4>
    {
      blad = 250;
      if (debugStr != NULL)
    8790:	01 15       	cp	r16, r1
    8792:	11 05       	cpc	r17, r1
    8794:	29 f0       	breq	.+10     	; 0x87a0 <rs485xModemFlash+0x2ce>
        fputc('#', debugStr);
    8796:	83 e2       	ldi	r24, 0x23	; 35
    8798:	90 e0       	ldi	r25, 0x00	; 0
    879a:	b8 01       	movw	r22, r16
    879c:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
      data = 0;
    87a0:	19 82       	std	Y+1, r1	; 0x01
    uartRs485SendByte((uint8_t)(crc>>8));
    uartRs485SendByte((uint8_t)(crc & 0xFF));
 
    if(rs485Receive(&data, 100) != pdTRUE)
    {
      blad = 250;
    87a2:	5a ef       	ldi	r21, 0xFA	; 250
    87a4:	95 2e       	mov	r9, r21
      if (debugStr != NULL)
        fputc('#', debugStr);
      data = 0;
    }
     
    flushRs485RecBuffer();
    87a6:	0e 94 3b 0a 	call	0x1476	; 0x1476 <flushRs485RecBuffer>

    if (data == ACK)
    87aa:	89 81       	ldd	r24, Y+1	; 0x01
    87ac:	86 30       	cpi	r24, 0x06	; 6
    87ae:	f1 f4       	brne	.+60     	; 0x87ec <rs485xModemFlash+0x31a>
    {
      nrBloku ++;
    87b0:	8a 81       	ldd	r24, Y+2	; 0x02
    87b2:	8f 5f       	subi	r24, 0xFF	; 255
    87b4:	8a 83       	std	Y+2, r24	; 0x02
      lRetransmisji = 0;
      blad = 0;
      if (debugStr != NULL)
    87b6:	01 15       	cp	r16, r1
    87b8:	11 05       	cpc	r17, r1
    87ba:	09 f4       	brne	.+2      	; 0x87be <rs485xModemFlash+0x2ec>
    87bc:	4b c0       	rjmp	.+150    	; 0x8854 <rs485xModemFlash+0x382>
      {
        fputc('.', debugStr);
    87be:	8e e2       	ldi	r24, 0x2E	; 46
    87c0:	90 e0       	ldi	r25, 0x00	; 0
    87c2:	b8 01       	movw	r22, r16
    87c4:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
        if ((nrBloku & 0x0F) == 0)
    87c8:	8a 81       	ldd	r24, Y+2	; 0x02
    87ca:	90 e0       	ldi	r25, 0x00	; 0
    87cc:	8f 70       	andi	r24, 0x0F	; 15
    87ce:	90 70       	andi	r25, 0x00	; 0
    87d0:	00 97       	sbiw	r24, 0x00	; 0
    87d2:	09 f0       	breq	.+2      	; 0x87d6 <rs485xModemFlash+0x304>
    87d4:	3f c0       	rjmp	.+126    	; 0x8854 <rs485xModemFlash+0x382>
        {
          fputc('\r', debugStr);
    87d6:	8d e0       	ldi	r24, 0x0D	; 13
    87d8:	90 e0       	ldi	r25, 0x00	; 0
    87da:	b8 01       	movw	r22, r16
    87dc:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
          fputc('\n', debugStr);      
    87e0:	8a e0       	ldi	r24, 0x0A	; 10
    87e2:	90 e0       	ldi	r25, 0x00	; 0
    87e4:	b8 01       	movw	r22, r16
    87e6:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    87ea:	34 c0       	rjmp	.+104    	; 0x8854 <rs485xModemFlash+0x382>
        }
      }
      continue;
    }
 
    if (data == CAN)
    87ec:	88 31       	cpi	r24, 0x18	; 24
    87ee:	51 f4       	brne	.+20     	; 0x8804 <rs485xModemFlash+0x332>
    {
      if (debugStr != NULL)
    87f0:	01 15       	cp	r16, r1
    87f2:	11 05       	cpc	r17, r1
    87f4:	09 f4       	brne	.+2      	; 0x87f8 <rs485xModemFlash+0x326>
    87f6:	b5 c0       	rjmp	.+362    	; 0x8962 <rs485xModemFlash+0x490>
        fputc('C', debugStr);
    87f8:	83 e4       	ldi	r24, 0x43	; 67
    87fa:	90 e0       	ldi	r25, 0x00	; 0
    87fc:	b8 01       	movw	r22, r16
    87fe:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    8802:	af c0       	rjmp	.+350    	; 0x8962 <rs485xModemFlash+0x490>
      blad = 249;
      break;
    }
    
    if (debugStr != NULL)
    8804:	01 15       	cp	r16, r1
    8806:	11 05       	cpc	r17, r1
    8808:	01 f1       	breq	.+64     	; 0x884a <rs485xModemFlash+0x378>
    {
      if (data == NAK)
    880a:	85 31       	cpi	r24, 0x15	; 21
    880c:	29 f4       	brne	.+10     	; 0x8818 <rs485xModemFlash+0x346>
        fputc('N', debugStr);
    880e:	8e e4       	ldi	r24, 0x4E	; 78
    8810:	90 e0       	ldi	r25, 0x00	; 0
    8812:	b8 01       	movw	r22, r16
    8814:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
      if (data != 0)
    8818:	89 81       	ldd	r24, Y+1	; 0x01
    881a:	88 23       	and	r24, r24
    881c:	b1 f0       	breq	.+44     	; 0x884a <rs485xModemFlash+0x378>
        fprintf(debugStr, "data 0x%x ", data);                    
    881e:	00 d0       	rcall	.+0      	; 0x8820 <rs485xModemFlash+0x34e>
    8820:	00 d0       	rcall	.+0      	; 0x8822 <rs485xModemFlash+0x350>
    8822:	ed b7       	in	r30, 0x3d	; 61
    8824:	fe b7       	in	r31, 0x3e	; 62
    8826:	31 96       	adiw	r30, 0x01	; 1
    8828:	ad b7       	in	r26, 0x3d	; 61
    882a:	be b7       	in	r27, 0x3e	; 62
    882c:	11 96       	adiw	r26, 0x01	; 1
    882e:	0d 93       	st	X+, r16
    8830:	1c 93       	st	X, r17
    8832:	12 97       	sbiw	r26, 0x02	; 2
    8834:	a2 82       	std	Z+2, r10	; 0x02
    8836:	b3 82       	std	Z+3, r11	; 0x03
    8838:	84 83       	std	Z+4, r24	; 0x04
    883a:	15 82       	std	Z+5, r1	; 0x05
    883c:	0e 94 72 57 	call	0xaee4	; 0xaee4 <fprintf>
    8840:	ed b7       	in	r30, 0x3d	; 61
    8842:	fe b7       	in	r31, 0x3e	; 62
    8844:	36 96       	adiw	r30, 0x06	; 6
    8846:	ed bf       	out	0x3d, r30	; 61
    8848:	fe bf       	out	0x3e, r31	; 62
    }
    
    lRetransmisji ++;
    884a:	83 94       	inc	r8
     
    if (lRetransmisji == 3)
    884c:	f8 2d       	mov	r31, r8
    884e:	f3 30       	cpi	r31, 0x03	; 3
    8850:	19 f4       	brne	.+6      	; 0x8858 <rs485xModemFlash+0x386>
    8852:	8a c0       	rjmp	.+276    	; 0x8968 <rs485xModemFlash+0x496>
    flushRs485RecBuffer();

    if (data == ACK)
    {
      nrBloku ++;
      lRetransmisji = 0;
    8854:	88 24       	eor	r8, r8
      blad = 0;
    8856:	99 24       	eor	r9, r9
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    8858:	8a 81       	ldd	r24, Y+2	; 0x02
    885a:	78 16       	cp	r7, r24
    885c:	08 f0       	brcs	.+2      	; 0x8860 <rs485xModemFlash+0x38e>
    885e:	6c cf       	rjmp	.-296    	; 0x8738 <rs485xModemFlash+0x266>
      blad = 248;
      break;
    }
  }
 
  if (blad == 0)
    8860:	99 20       	and	r9, r9
    8862:	b1 f4       	brne	.+44     	; 0x8890 <rs485xModemFlash+0x3be>
  {
    uartRs485SendByte(EOT); 
    8864:	84 e0       	ldi	r24, 0x04	; 4
    8866:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    if(rs485Receive(&data, 25) == pdTRUE)
    886a:	8e 01       	movw	r16, r28
    886c:	0f 5f       	subi	r16, 0xFF	; 255
    886e:	1f 4f       	sbci	r17, 0xFF	; 255
    8870:	c8 01       	movw	r24, r16
    8872:	69 e1       	ldi	r22, 0x19	; 25
    8874:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    8878:	81 30       	cpi	r24, 0x01	; 1
    887a:	51 f4       	brne	.+20     	; 0x8890 <rs485xModemFlash+0x3be>
    {
      if (data == ACK)
    887c:	89 81       	ldd	r24, Y+1	; 0x01
    887e:	86 30       	cpi	r24, 0x06	; 6
    8880:	39 f4       	brne	.+14     	; 0x8890 <rs485xModemFlash+0x3be>
      {
        uartRs485SendByte(EOT);
    8882:	84 e0       	ldi	r24, 0x04	; 4
    8884:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
        rs485Receive(&data, 25);
    8888:	c8 01       	movw	r24, r16
    888a:	69 e1       	ldi	r22, 0x19	; 25
    888c:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
      }
    }
  }

  flushRs485RecBuffer();  
    8890:	0e 94 3b 0a 	call	0x1476	; 0x1476 <flushRs485RecBuffer>
  releaseRs485();
    8894:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <releaseRs485>
  return blad;
}
    8898:	89 2d       	mov	r24, r9
    889a:	23 96       	adiw	r28, 0x03	; 3
    889c:	cd bf       	out	0x3d, r28	; 61
    889e:	de bf       	out	0x3e, r29	; 62
    88a0:	cf 91       	pop	r28
    88a2:	df 91       	pop	r29
    88a4:	1f 91       	pop	r17
    88a6:	0f 91       	pop	r16
    88a8:	ff 90       	pop	r15
    88aa:	ef 90       	pop	r14
    88ac:	df 90       	pop	r13
    88ae:	cf 90       	pop	r12
    88b0:	bf 90       	pop	r11
    88b2:	af 90       	pop	r10
    88b4:	9f 90       	pop	r9
    88b6:	8f 90       	pop	r8
    88b8:	7f 90       	pop	r7
    88ba:	5f 90       	pop	r5
    88bc:	4f 90       	pop	r4
    88be:	08 95       	ret
  }
   
  //Odbieranie CRC Lo
  if (blad == 0)
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    88c0:	c7 01       	movw	r24, r14
    88c2:	61 e0       	ldi	r22, 0x01	; 1
    88c4:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
    88c8:	81 30       	cpi	r24, 0x01	; 1
    88ca:	09 f0       	breq	.+2      	; 0x88ce <rs485xModemFlash+0x3fc>
    88cc:	06 cf       	rjmp	.-500    	; 0x86da <rs485xModemFlash+0x208>
    88ce:	01 cf       	rjmp	.-510    	; 0x86d2 <rs485xModemFlash+0x200>
  }

// Wysyłanie polecenia do bootloadera
  if (blad == 0)
  {
    vTaskDelay(100);
    88d0:	84 e6       	ldi	r24, 0x64	; 100
    88d2:	90 e0       	ldi	r25, 0x00	; 0
    88d4:	0e 94 64 4a 	call	0x94c8	; 0x94c8 <vTaskDelay>
     
    crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    88d8:	80 e0       	ldi	r24, 0x00	; 0
    88da:	90 e0       	ldi	r25, 0x00	; 0
    88dc:	6a e5       	ldi	r22, 0x5A	; 90
    88de:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    88e2:	7c 01       	movw	r14, r24
    88e4:	8a e5       	ldi	r24, 0x5A	; 90
    88e6:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    88ea:	c7 01       	movw	r24, r14
    88ec:	6c 2d       	mov	r22, r12
    88ee:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    88f2:	7c 01       	movw	r14, r24
    88f4:	8c 2d       	mov	r24, r12
    88f6:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    88fa:	c7 01       	movw	r24, r14
    88fc:	61 e8       	ldi	r22, 0x81	; 129
    88fe:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8902:	7c 01       	movw	r14, r24
    8904:	81 e8       	ldi	r24, 0x81	; 129
    8906:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    890a:	c7 01       	movw	r24, r14
    890c:	61 e0       	ldi	r22, 0x01	; 1
    890e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8912:	7c 01       	movw	r14, r24
    8914:	81 e0       	ldi	r24, 0x01	; 1
    8916:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    891a:	c7 01       	movw	r24, r14
    891c:	6c 2d       	mov	r22, r12
    891e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8922:	e8 2e       	mov	r14, r24
    8924:	8c 2d       	mov	r24, r12
    8926:	9b 83       	std	Y+3, r25	; 0x03
    8928:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc>>8));
    892c:	9b 81       	ldd	r25, Y+3	; 0x03
    892e:	89 2f       	mov	r24, r25
    8930:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    8934:	8e 2d       	mov	r24, r14
    8936:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
 
    //Odbieranie odpowiedzi od Bootloadera
    if(rs485Receive(&data, 150) != pdTRUE)
    893a:	ce 01       	movw	r24, r28
    893c:	01 96       	adiw	r24, 0x01	; 1
    893e:	66 e9       	ldi	r22, 0x96	; 150
    8940:	0e 94 b5 09 	call	0x136a	; 0x136a <rs485Receive>
      blad = 15;

    if (data != 'C')
    8944:	89 81       	ldd	r24, Y+1	; 0x01
    8946:	83 34       	cpi	r24, 0x43	; 67
    8948:	09 f4       	brne	.+2      	; 0x894c <rs485xModemFlash+0x47a>
    894a:	cc ce       	rjmp	.-616    	; 0x86e4 <rs485xModemFlash+0x212>
    blad = 0;
  
   
  if (blad != 0)
  {
    releaseRs485();
    894c:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <releaseRs485>
    flushRs485RecBuffer();  
    8950:	0e 94 3b 0a 	call	0x1476	; 0x1476 <flushRs485RecBuffer>
    if (debugStr != NULL)
    8954:	01 15       	cp	r16, r1
    8956:	11 05       	cpc	r17, r1
    8958:	09 f0       	breq	.+2      	; 0x895c <rs485xModemFlash+0x48a>
    895a:	cf ce       	rjmp	.-610    	; 0x86fa <rs485xModemFlash+0x228>
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
    895c:	99 24       	eor	r9, r9
    895e:	93 94       	inc	r9
    8960:	9b cf       	rjmp	.-202    	; 0x8898 <rs485xModemFlash+0x3c6>
 
    if (data == CAN)
    {
      if (debugStr != NULL)
        fputc('C', debugStr);
      blad = 249;
    8962:	49 ef       	ldi	r20, 0xF9	; 249
    8964:	94 2e       	mov	r9, r20
    8966:	94 cf       	rjmp	.-216    	; 0x8890 <rs485xModemFlash+0x3be>
    
    lRetransmisji ++;
     
    if (lRetransmisji == 3)
    {
      blad = 248;
    8968:	38 ef       	ldi	r19, 0xF8	; 248
    896a:	93 2e       	mov	r9, r19
    896c:	91 cf       	rjmp	.-222    	; 0x8890 <rs485xModemFlash+0x3be>

0000896e <rs485curtainUp>:
  releaseRs485();
  return blad;
}

uint8_t rs485curtainUp(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    896e:	cf 92       	push	r12
    8970:	df 92       	push	r13
    8972:	ff 92       	push	r15
    8974:	0f 93       	push	r16
    8976:	1f 93       	push	r17
    8978:	df 93       	push	r29
    897a:	cf 93       	push	r28
    897c:	0f 92       	push	r0
    897e:	cd b7       	in	r28, 0x3d	; 61
    8980:	de b7       	in	r29, 0x3e	; 62
    8982:	18 2f       	mov	r17, r24
    8984:	06 2f       	mov	r16, r22
    8986:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
    8988:	80 e0       	ldi	r24, 0x00	; 0
    898a:	90 e0       	ldi	r25, 0x00	; 0
    898c:	6a e5       	ldi	r22, 0x5A	; 90
    898e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8992:	6c 01       	movw	r12, r24
  uartRs485SendByte(SYNC);
    8994:	8a e5       	ldi	r24, 0x5A	; 90
    8996:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, deviceAddr);
    899a:	c6 01       	movw	r24, r12
    899c:	61 2f       	mov	r22, r17
    899e:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    89a2:	6c 01       	movw	r12, r24
  uartRs485SendByte(deviceAddr);
    89a4:	81 2f       	mov	r24, r17
    89a6:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  if (curtainNo == 0)
    89aa:	00 23       	and	r16, r16
    89ac:	39 f4       	brne	.+14     	; 0x89bc <rs485curtainUp+0x4e>
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete1);
    89ae:	c6 01       	movw	r24, r12
    89b0:	60 e2       	ldi	r22, 0x20	; 32
    89b2:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    89b6:	8c 01       	movw	r16, r24
    uartRs485SendByte(rPodniesRolete1);
    89b8:	80 e2       	ldi	r24, 0x20	; 32
    89ba:	06 c0       	rjmp	.+12     	; 0x89c8 <rs485curtainUp+0x5a>
  }
  else
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete2);
    89bc:	c6 01       	movw	r24, r12
    89be:	61 e2       	ldi	r22, 0x21	; 33
    89c0:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    89c4:	8c 01       	movw	r16, r24
    uartRs485SendByte(rPodniesRolete2); 
    89c6:	81 e2       	ldi	r24, 0x21	; 33
    89c8:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  }
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    89cc:	c8 01       	movw	r24, r16
    89ce:	61 e0       	ldi	r22, 0x01	; 1
    89d0:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    89d4:	8c 01       	movw	r16, r24
    89d6:	81 e0       	ldi	r24, 0x01	; 1
    89d8:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, pos);  uartRs485SendByte(pos);
    89dc:	c8 01       	movw	r24, r16
    89de:	6f 2d       	mov	r22, r15
    89e0:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    89e4:	18 2f       	mov	r17, r24
    89e6:	8f 2d       	mov	r24, r15
    89e8:	99 83       	std	Y+1, r25	; 0x01
    89ea:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    89ee:	99 81       	ldd	r25, Y+1	; 0x01
    89f0:	89 2f       	mov	r24, r25
    89f2:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    89f6:	81 2f       	mov	r24, r17
    89f8:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  
  return 0;
}
    89fc:	80 e0       	ldi	r24, 0x00	; 0
    89fe:	0f 90       	pop	r0
    8a00:	cf 91       	pop	r28
    8a02:	df 91       	pop	r29
    8a04:	1f 91       	pop	r17
    8a06:	0f 91       	pop	r16
    8a08:	ff 90       	pop	r15
    8a0a:	df 90       	pop	r13
    8a0c:	cf 90       	pop	r12
    8a0e:	08 95       	ret

00008a10 <rs485Led>:

uint8_t rs485Led(uint8_t deviceAddr, uint8_t ledNo, uint8_t time)
{
    8a10:	cf 92       	push	r12
    8a12:	df 92       	push	r13
    8a14:	ff 92       	push	r15
    8a16:	0f 93       	push	r16
    8a18:	1f 93       	push	r17
    8a1a:	df 93       	push	r29
    8a1c:	cf 93       	push	r28
    8a1e:	0f 92       	push	r0
    8a20:	cd b7       	in	r28, 0x3d	; 61
    8a22:	de b7       	in	r29, 0x3e	; 62
    8a24:	18 2f       	mov	r17, r24
    8a26:	06 2f       	mov	r16, r22
    8a28:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
    8a2a:	80 e0       	ldi	r24, 0x00	; 0
    8a2c:	90 e0       	ldi	r25, 0x00	; 0
    8a2e:	6a e5       	ldi	r22, 0x5A	; 90
    8a30:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8a34:	6c 01       	movw	r12, r24
  uartRs485SendByte(SYNC);
    8a36:	8a e5       	ldi	r24, 0x5A	; 90
    8a38:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, deviceAddr);
    8a3c:	c6 01       	movw	r24, r12
    8a3e:	61 2f       	mov	r22, r17
    8a40:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8a44:	6c 01       	movw	r12, r24
  uartRs485SendByte(deviceAddr);
    8a46:	81 2f       	mov	r24, r17
    8a48:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, ledNo);
    8a4c:	c6 01       	movw	r24, r12
    8a4e:	60 2f       	mov	r22, r16
    8a50:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    8a54:	61 e0       	ldi	r22, 0x01	; 1
    8a56:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8a5a:	8c 01       	movw	r16, r24
    8a5c:	81 e0       	ldi	r24, 0x01	; 1
    8a5e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, time);  uartRs485SendByte(time);
    8a62:	c8 01       	movw	r24, r16
    8a64:	6f 2d       	mov	r22, r15
    8a66:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8a6a:	18 2f       	mov	r17, r24
    8a6c:	8f 2d       	mov	r24, r15
    8a6e:	99 83       	std	Y+1, r25	; 0x01
    8a70:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8a74:	99 81       	ldd	r25, Y+1	; 0x01
    8a76:	89 2f       	mov	r24, r25
    8a78:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8a7c:	81 2f       	mov	r24, r17
    8a7e:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  
  return 0;
}
    8a82:	80 e0       	ldi	r24, 0x00	; 0
    8a84:	0f 90       	pop	r0
    8a86:	cf 91       	pop	r28
    8a88:	df 91       	pop	r29
    8a8a:	1f 91       	pop	r17
    8a8c:	0f 91       	pop	r16
    8a8e:	ff 90       	pop	r15
    8a90:	df 90       	pop	r13
    8a92:	cf 90       	pop	r12
    8a94:	08 95       	ret

00008a96 <rs485curtainDown>:


uint8_t rs485curtainDown(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    8a96:	cf 92       	push	r12
    8a98:	df 92       	push	r13
    8a9a:	ff 92       	push	r15
    8a9c:	0f 93       	push	r16
    8a9e:	1f 93       	push	r17
    8aa0:	df 93       	push	r29
    8aa2:	cf 93       	push	r28
    8aa4:	0f 92       	push	r0
    8aa6:	cd b7       	in	r28, 0x3d	; 61
    8aa8:	de b7       	in	r29, 0x3e	; 62
    8aaa:	18 2f       	mov	r17, r24
    8aac:	06 2f       	mov	r16, r22
    8aae:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);            uartRs485SendByte(SYNC);
    8ab0:	80 e0       	ldi	r24, 0x00	; 0
    8ab2:	90 e0       	ldi	r25, 0x00	; 0
    8ab4:	6a e5       	ldi	r22, 0x5A	; 90
    8ab6:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8aba:	6c 01       	movw	r12, r24
    8abc:	8a e5       	ldi	r24, 0x5A	; 90
    8abe:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, deviceAddr);    uartRs485SendByte(deviceAddr);
    8ac2:	c6 01       	movw	r24, r12
    8ac4:	61 2f       	mov	r22, r17
    8ac6:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8aca:	6c 01       	movw	r12, r24
    8acc:	81 2f       	mov	r24, r17
    8ace:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  if (curtainNo == 0)
    8ad2:	00 23       	and	r16, r16
    8ad4:	39 f4       	brne	.+14     	; 0x8ae4 <rs485curtainDown+0x4e>
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete1); uartRs485SendByte(rOpuscRolete1);
    8ad6:	c6 01       	movw	r24, r12
    8ad8:	60 e1       	ldi	r22, 0x10	; 16
    8ada:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8ade:	8c 01       	movw	r16, r24
    8ae0:	80 e1       	ldi	r24, 0x10	; 16
    8ae2:	06 c0       	rjmp	.+12     	; 0x8af0 <rs485curtainDown+0x5a>
  }
  else
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete2); uartRs485SendByte(rOpuscRolete2); 
    8ae4:	c6 01       	movw	r24, r12
    8ae6:	61 e1       	ldi	r22, 0x11	; 17
    8ae8:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8aec:	8c 01       	movw	r16, r24
    8aee:	81 e1       	ldi	r24, 0x11	; 17
    8af0:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  }

  crc = _crc_xmodem_update(crc, 1);               uartRs485SendByte(1);
    8af4:	c8 01       	movw	r24, r16
    8af6:	61 e0       	ldi	r22, 0x01	; 1
    8af8:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8afc:	8c 01       	movw	r16, r24
    8afe:	81 e0       	ldi	r24, 0x01	; 1
    8b00:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, pos);         uartRs485SendByte(pos);
    8b04:	c8 01       	movw	r24, r16
    8b06:	6f 2d       	mov	r22, r15
    8b08:	0e 94 40 3f 	call	0x7e80	; 0x7e80 <_crc_xmodem_update>
    8b0c:	18 2f       	mov	r17, r24
    8b0e:	8f 2d       	mov	r24, r15
    8b10:	99 83       	std	Y+1, r25	; 0x01
    8b12:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8b16:	99 81       	ldd	r25, Y+1	; 0x01
    8b18:	89 2f       	mov	r24, r25
    8b1a:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8b1e:	81 2f       	mov	r24, r17
    8b20:	0e 94 9a 09 	call	0x1334	; 0x1334 <uartRs485SendByte>

  return 0;
}
    8b24:	80 e0       	ldi	r24, 0x00	; 0
    8b26:	0f 90       	pop	r0
    8b28:	cf 91       	pop	r28
    8b2a:	df 91       	pop	r29
    8b2c:	1f 91       	pop	r17
    8b2e:	0f 91       	pop	r16
    8b30:	ff 90       	pop	r15
    8b32:	df 90       	pop	r13
    8b34:	cf 90       	pop	r12
    8b36:	08 95       	ret

00008b38 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
    8b38:	4f 92       	push	r4
    8b3a:	5f 92       	push	r5
    8b3c:	6f 92       	push	r6
    8b3e:	7f 92       	push	r7
    8b40:	8f 92       	push	r8
    8b42:	9f 92       	push	r9
    8b44:	af 92       	push	r10
    8b46:	bf 92       	push	r11
    8b48:	cf 92       	push	r12
    8b4a:	df 92       	push	r13
    8b4c:	ef 92       	push	r14
    8b4e:	ff 92       	push	r15
    8b50:	0f 93       	push	r16
    8b52:	1f 93       	push	r17
    8b54:	cf 93       	push	r28
    8b56:	df 93       	push	r29
    8b58:	2c 01       	movw	r4, r24
    8b5a:	eb 01       	movw	r28, r22
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    8b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    8b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    8b60:	02 80       	ldd	r0, Z+2	; 0x02
    8b62:	f3 81       	ldd	r31, Z+3	; 0x03
    8b64:	e0 2d       	mov	r30, r0
    8b66:	e9 83       	std	Y+1, r30	; 0x01
    8b68:	fa 83       	std	Y+2, r31	; 0x02
    8b6a:	cb 01       	movw	r24, r22
    8b6c:	03 96       	adiw	r24, 0x03	; 3
    8b6e:	e8 17       	cp	r30, r24
    8b70:	f9 07       	cpc	r31, r25
    8b72:	21 f4       	brne	.+8      	; 0x8b7c <prvListTaskWithinSingleList+0x44>
    8b74:	82 81       	ldd	r24, Z+2	; 0x02
    8b76:	93 81       	ldd	r25, Z+3	; 0x03
    8b78:	89 83       	std	Y+1, r24	; 0x01
    8b7a:	9a 83       	std	Y+2, r25	; 0x02
    8b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    8b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    8b80:	a6 80       	ldd	r10, Z+6	; 0x06
    8b82:	b7 80       	ldd	r11, Z+7	; 0x07
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    8b84:	23 e0       	ldi	r18, 0x03	; 3
    8b86:	e2 2e       	mov	r14, r18
    8b88:	f1 2c       	mov	r15, r1
    8b8a:	ec 0e       	add	r14, r28
    8b8c:	fd 1e       	adc	r15, r29
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    8b8e:	97 e9       	ldi	r25, 0x97	; 151
    8b90:	c9 2e       	mov	r12, r25
    8b92:	95 e2       	ldi	r25, 0x25	; 37
    8b94:	d9 2e       	mov	r13, r25
    8b96:	89 e2       	ldi	r24, 0x29	; 41
    8b98:	88 2e       	mov	r8, r24
    8b9a:	85 e2       	ldi	r24, 0x25	; 37
    8b9c:	98 2e       	mov	r9, r24
    8b9e:	64 2e       	mov	r6, r20
    8ba0:	77 24       	eor	r7, r7
    8ba2:	67 fc       	sbrc	r6, 7
    8ba4:	70 94       	com	r7

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    8ba6:	e9 81       	ldd	r30, Y+1	; 0x01
    8ba8:	fa 81       	ldd	r31, Y+2	; 0x02
    8baa:	82 81       	ldd	r24, Z+2	; 0x02
    8bac:	93 81       	ldd	r25, Z+3	; 0x03
    8bae:	89 83       	std	Y+1, r24	; 0x01
    8bb0:	9a 83       	std	Y+2, r25	; 0x02
    8bb2:	8e 15       	cp	r24, r14
    8bb4:	9f 05       	cpc	r25, r15
    8bb6:	39 f4       	brne	.+14     	; 0x8bc6 <prvListTaskWithinSingleList+0x8e>
    8bb8:	d7 01       	movw	r26, r14
    8bba:	12 96       	adiw	r26, 0x02	; 2
    8bbc:	8d 91       	ld	r24, X+
    8bbe:	9c 91       	ld	r25, X
    8bc0:	13 97       	sbiw	r26, 0x03	; 3
    8bc2:	89 83       	std	Y+1, r24	; 0x01
    8bc4:	9a 83       	std	Y+2, r25	; 0x02
    8bc6:	e9 81       	ldd	r30, Y+1	; 0x01
    8bc8:	fa 81       	ldd	r31, Y+2	; 0x02
    8bca:	06 81       	ldd	r16, Z+6	; 0x06
    8bcc:	17 81       	ldd	r17, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
    8bce:	d8 01       	movw	r26, r16
    8bd0:	57 96       	adiw	r26, 0x17	; 23
    8bd2:	ed 91       	ld	r30, X+
    8bd4:	fc 91       	ld	r31, X
    8bd6:	58 97       	sbiw	r26, 0x18	; 24

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;
    8bd8:	80 e0       	ldi	r24, 0x00	; 0
    8bda:	90 e0       	ldi	r25, 0x00	; 0
    8bdc:	01 c0       	rjmp	.+2      	; 0x8be0 <prvListTaskWithinSingleList+0xa8>

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    8bde:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    8be0:	21 91       	ld	r18, Z+
    8be2:	25 3a       	cpi	r18, 0xA5	; 165
    8be4:	e1 f3       	breq	.-8      	; 0x8bde <prvListTaskWithinSingleList+0xa6>
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    8be6:	98 01       	movw	r18, r16
    8be8:	27 5e       	subi	r18, 0xE7	; 231
    8bea:	3f 4f       	sbci	r19, 0xFF	; 255
    8bec:	f8 01       	movw	r30, r16
    8bee:	56 89       	ldd	r21, Z+22	; 0x16
    8bf0:	43 a1       	ldd	r20, Z+35	; 0x23
    8bf2:	6d b7       	in	r22, 0x3d	; 61
    8bf4:	7e b7       	in	r23, 0x3e	; 62
    8bf6:	6e 50       	subi	r22, 0x0E	; 14
    8bf8:	70 40       	sbci	r23, 0x00	; 0
    8bfa:	6d bf       	out	0x3d, r22	; 61
    8bfc:	7e bf       	out	0x3e, r23	; 62
    8bfe:	ed b7       	in	r30, 0x3d	; 61
    8c00:	fe b7       	in	r31, 0x3e	; 62
    8c02:	31 96       	adiw	r30, 0x01	; 1
    8c04:	ad b7       	in	r26, 0x3d	; 61
    8c06:	be b7       	in	r27, 0x3e	; 62
    8c08:	11 96       	adiw	r26, 0x01	; 1
    8c0a:	cd 92       	st	X+, r12
    8c0c:	dc 92       	st	X, r13
    8c0e:	12 97       	sbiw	r26, 0x02	; 2
    8c10:	82 82       	std	Z+2, r8	; 0x02
    8c12:	93 82       	std	Z+3, r9	; 0x03
    8c14:	24 83       	std	Z+4, r18	; 0x04
    8c16:	35 83       	std	Z+5, r19	; 0x05
    8c18:	66 82       	std	Z+6, r6	; 0x06
    8c1a:	77 82       	std	Z+7, r7	; 0x07
    8c1c:	50 87       	std	Z+8, r21	; 0x08
    8c1e:	11 86       	std	Z+9, r1	; 0x09
    8c20:	82 87       	std	Z+10, r24	; 0x0a
    8c22:	93 87       	std	Z+11, r25	; 0x0b
    8c24:	44 87       	std	Z+12, r20	; 0x0c
    8c26:	15 86       	std	Z+13, r1	; 0x0d
    8c28:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
    8c2c:	ed b7       	in	r30, 0x3d	; 61
    8c2e:	fe b7       	in	r31, 0x3e	; 62
    8c30:	3e 96       	adiw	r30, 0x0e	; 14
    8c32:	ed bf       	out	0x3d, r30	; 61
    8c34:	fe bf       	out	0x3e, r31	; 62
    8c36:	c2 01       	movw	r24, r4
    8c38:	b6 01       	movw	r22, r12
    8c3a:	0e 94 d9 56 	call	0xadb2	; 0xadb2 <strcat>

		} while( pxNextTCB != pxFirstTCB );
    8c3e:	0a 15       	cp	r16, r10
    8c40:	1b 05       	cpc	r17, r11
    8c42:	09 f0       	breq	.+2      	; 0x8c46 <prvListTaskWithinSingleList+0x10e>
    8c44:	b0 cf       	rjmp	.-160    	; 0x8ba6 <prvListTaskWithinSingleList+0x6e>
	}
    8c46:	df 91       	pop	r29
    8c48:	cf 91       	pop	r28
    8c4a:	1f 91       	pop	r17
    8c4c:	0f 91       	pop	r16
    8c4e:	ff 90       	pop	r15
    8c50:	ef 90       	pop	r14
    8c52:	df 90       	pop	r13
    8c54:	cf 90       	pop	r12
    8c56:	bf 90       	pop	r11
    8c58:	af 90       	pop	r10
    8c5a:	9f 90       	pop	r9
    8c5c:	8f 90       	pop	r8
    8c5e:	7f 90       	pop	r7
    8c60:	6f 90       	pop	r6
    8c62:	5f 90       	pop	r5
    8c64:	4f 90       	pop	r4
    8c66:	08 95       	ret

00008c68 <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    8c68:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
    8c6c:	fd cf       	rjmp	.-6      	; 0x8c68 <prvIdleTask>

00008c6e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    8c6e:	2f 92       	push	r2
    8c70:	3f 92       	push	r3
    8c72:	4f 92       	push	r4
    8c74:	5f 92       	push	r5
    8c76:	6f 92       	push	r6
    8c78:	7f 92       	push	r7
    8c7a:	8f 92       	push	r8
    8c7c:	9f 92       	push	r9
    8c7e:	af 92       	push	r10
    8c80:	bf 92       	push	r11
    8c82:	cf 92       	push	r12
    8c84:	df 92       	push	r13
    8c86:	ef 92       	push	r14
    8c88:	ff 92       	push	r15
    8c8a:	0f 93       	push	r16
    8c8c:	1f 93       	push	r17
    8c8e:	cf 93       	push	r28
    8c90:	df 93       	push	r29
    8c92:	1c 01       	movw	r2, r24
    8c94:	3b 01       	movw	r6, r22
    8c96:	5a 01       	movw	r10, r20
    8c98:	29 01       	movw	r4, r18
    8c9a:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    8c9c:	84 e2       	ldi	r24, 0x24	; 36
    8c9e:	90 e0       	ldi	r25, 0x00	; 0
    8ca0:	0e 94 64 52 	call	0xa4c8	; 0xa4c8 <pvPortMalloc>
    8ca4:	e8 2e       	mov	r14, r24
    8ca6:	e7 01       	movw	r28, r14
    8ca8:	7e 01       	movw	r14, r28
    8caa:	f9 2e       	mov	r15, r25
    8cac:	e7 01       	movw	r28, r14

	if( pxNewTCB != NULL )
    8cae:	20 97       	sbiw	r28, 0x00	; 0
    8cb0:	09 f4       	brne	.+2      	; 0x8cb4 <xTaskGenericCreate+0x46>
    8cb2:	c9 c0       	rjmp	.+402    	; 0x8e46 <xTaskGenericCreate+0x1d8>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    8cb4:	c1 14       	cp	r12, r1
    8cb6:	d1 04       	cpc	r13, r1
    8cb8:	29 f4       	brne	.+10     	; 0x8cc4 <xTaskGenericCreate+0x56>
    8cba:	c5 01       	movw	r24, r10
    8cbc:	0e 94 64 52 	call	0xa4c8	; 0xa4c8 <pvPortMalloc>
    8cc0:	c8 2e       	mov	r12, r24
    8cc2:	d9 2e       	mov	r13, r25
    8cc4:	cf 8a       	std	Y+23, r12	; 0x17
    8cc6:	d8 8e       	std	Y+24, r13	; 0x18

		if( pxNewTCB->pxStack == NULL )
    8cc8:	c1 14       	cp	r12, r1
    8cca:	d1 04       	cpc	r13, r1
    8ccc:	21 f4       	brne	.+8      	; 0x8cd6 <xTaskGenericCreate+0x68>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    8cce:	ce 01       	movw	r24, r28
    8cd0:	0e 94 8d 52 	call	0xa51a	; 0xa51a <vPortFree>
    8cd4:	b8 c0       	rjmp	.+368    	; 0x8e46 <xTaskGenericCreate+0x1d8>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    8cd6:	c6 01       	movw	r24, r12
    8cd8:	65 ea       	ldi	r22, 0xA5	; 165
    8cda:	70 e0       	ldi	r23, 0x00	; 0
    8cdc:	a5 01       	movw	r20, r10
    8cde:	0e 94 d2 56 	call	0xada4	; 0xada4 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    8ce2:	08 94       	sec
    8ce4:	a1 08       	sbc	r10, r1
    8ce6:	b1 08       	sbc	r11, r1
    8ce8:	ef 88       	ldd	r14, Y+23	; 0x17
    8cea:	f8 8c       	ldd	r15, Y+24	; 0x18
    8cec:	ea 0c       	add	r14, r10
    8cee:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    8cf0:	ce 01       	movw	r24, r28
    8cf2:	49 96       	adiw	r24, 0x19	; 25
    8cf4:	b3 01       	movw	r22, r6
    8cf6:	4a e0       	ldi	r20, 0x0A	; 10
    8cf8:	50 e0       	ldi	r21, 0x00	; 0
    8cfa:	0e 94 f9 56 	call	0xadf2	; 0xadf2 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    8cfe:	1a a2       	std	Y+34, r1	; 0x22
    8d00:	10 2f       	mov	r17, r16
    8d02:	03 30       	cpi	r16, 0x03	; 3
    8d04:	08 f0       	brcs	.+2      	; 0x8d08 <xTaskGenericCreate+0x9a>
    8d06:	12 e0       	ldi	r17, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    8d08:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    8d0a:	72 e0       	ldi	r23, 0x02	; 2
    8d0c:	a7 2e       	mov	r10, r23
    8d0e:	b1 2c       	mov	r11, r1
    8d10:	ac 0e       	add	r10, r28
    8d12:	bd 1e       	adc	r11, r29
    8d14:	c5 01       	movw	r24, r10
    8d16:	0e 94 07 50 	call	0xa00e	; 0xa00e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    8d1a:	ce 01       	movw	r24, r28
    8d1c:	0c 96       	adiw	r24, 0x0c	; 12
    8d1e:	0e 94 07 50 	call	0xa00e	; 0xa00e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    8d22:	c8 87       	std	Y+8, r28	; 0x08
    8d24:	d9 87       	std	Y+9, r29	; 0x09

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    8d26:	83 e0       	ldi	r24, 0x03	; 3
    8d28:	90 e0       	ldi	r25, 0x00	; 0
    8d2a:	81 1b       	sub	r24, r17
    8d2c:	91 09       	sbc	r25, r1
    8d2e:	8c 87       	std	Y+12, r24	; 0x0c
    8d30:	9d 87       	std	Y+13, r25	; 0x0d
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    8d32:	ca 8b       	std	Y+18, r28	; 0x12
    8d34:	db 8b       	std	Y+19, r29	; 0x13
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    8d36:	c7 01       	movw	r24, r14
    8d38:	b1 01       	movw	r22, r2
    8d3a:	a2 01       	movw	r20, r4
    8d3c:	0e 94 9d 52 	call	0xa53a	; 0xa53a <pxPortInitialiseStack>
    8d40:	88 83       	st	Y, r24
    8d42:	99 83       	std	Y+1, r25	; 0x01
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    8d44:	0f b6       	in	r0, 0x3f	; 63
    8d46:	f8 94       	cli
    8d48:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    8d4a:	80 91 c9 25 	lds	r24, 0x25C9
    8d4e:	8f 5f       	subi	r24, 0xFF	; 255
    8d50:	80 93 c9 25 	sts	0x25C9, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    8d54:	80 91 c9 25 	lds	r24, 0x25C9
    8d58:	81 30       	cpi	r24, 0x01	; 1
    8d5a:	79 f5       	brne	.+94     	; 0x8dba <xTaskGenericCreate+0x14c>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    8d5c:	c0 93 55 25 	sts	0x2555, r28
    8d60:	d0 93 56 25 	sts	0x2556, r29
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    8d64:	8d e5       	ldi	r24, 0x5D	; 93
    8d66:	95 e2       	ldi	r25, 0x25	; 37
    8d68:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
    8d6c:	86 e6       	ldi	r24, 0x66	; 102
    8d6e:	95 e2       	ldi	r25, 0x25	; 37
    8d70:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
    8d74:	8f e6       	ldi	r24, 0x6F	; 111
    8d76:	95 e2       	ldi	r25, 0x25	; 37
    8d78:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    8d7c:	6c ec       	ldi	r22, 0xCC	; 204
    8d7e:	e6 2e       	mov	r14, r22
    8d80:	65 e2       	ldi	r22, 0x25	; 37
    8d82:	f6 2e       	mov	r15, r22
    8d84:	c7 01       	movw	r24, r14
    8d86:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    8d8a:	55 ed       	ldi	r21, 0xD5	; 213
    8d8c:	c5 2e       	mov	r12, r21
    8d8e:	55 e2       	ldi	r21, 0x25	; 37
    8d90:	d5 2e       	mov	r13, r21
    8d92:	c6 01       	movw	r24, r12
    8d94:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    8d98:	88 e7       	ldi	r24, 0x78	; 120
    8d9a:	95 e2       	ldi	r25, 0x25	; 37
    8d9c:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    8da0:	81 e8       	ldi	r24, 0x81	; 129
    8da2:	95 e2       	ldi	r25, 0x25	; 37
    8da4:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    8da8:	e0 92 8c 25 	sts	0x258C, r14
    8dac:	f0 92 8d 25 	sts	0x258D, r15
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    8db0:	c0 92 8a 25 	sts	0x258A, r12
    8db4:	d0 92 8b 25 	sts	0x258B, r13
    8db8:	0f c0       	rjmp	.+30     	; 0x8dd8 <xTaskGenericCreate+0x16a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    8dba:	80 91 ca 25 	lds	r24, 0x25CA
    8dbe:	88 23       	and	r24, r24
    8dc0:	59 f4       	brne	.+22     	; 0x8dd8 <xTaskGenericCreate+0x16a>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    8dc2:	e0 91 55 25 	lds	r30, 0x2555
    8dc6:	f0 91 56 25 	lds	r31, 0x2556
    8dca:	86 89       	ldd	r24, Z+22	; 0x16
    8dcc:	08 17       	cp	r16, r24
    8dce:	20 f0       	brcs	.+8      	; 0x8dd8 <xTaskGenericCreate+0x16a>
					{
						pxCurrentTCB = pxNewTCB;
    8dd0:	c0 93 55 25 	sts	0x2555, r28
    8dd4:	d0 93 56 25 	sts	0x2556, r29
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    8dd8:	2e 89       	ldd	r18, Y+22	; 0x16
    8dda:	80 91 96 25 	lds	r24, 0x2596
    8dde:	82 17       	cp	r24, r18
    8de0:	10 f4       	brcc	.+4      	; 0x8de6 <xTaskGenericCreate+0x178>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    8de2:	20 93 96 25 	sts	0x2596, r18
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    8de6:	80 91 cb 25 	lds	r24, 0x25CB
    8dea:	8b a3       	std	Y+35, r24	; 0x23
			}
			#endif
			uxTaskNumber++;
    8dec:	8f 5f       	subi	r24, 0xFF	; 255
    8dee:	80 93 cb 25 	sts	0x25CB, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    8df2:	80 91 5c 25 	lds	r24, 0x255C
    8df6:	82 17       	cp	r24, r18
    8df8:	10 f4       	brcc	.+4      	; 0x8dfe <xTaskGenericCreate+0x190>
    8dfa:	20 93 5c 25 	sts	0x255C, r18
    8dfe:	30 e0       	ldi	r19, 0x00	; 0
    8e00:	c9 01       	movw	r24, r18
    8e02:	43 e0       	ldi	r20, 0x03	; 3
    8e04:	88 0f       	add	r24, r24
    8e06:	99 1f       	adc	r25, r25
    8e08:	4a 95       	dec	r20
    8e0a:	e1 f7       	brne	.-8      	; 0x8e04 <xTaskGenericCreate+0x196>
    8e0c:	82 0f       	add	r24, r18
    8e0e:	93 1f       	adc	r25, r19
    8e10:	83 5a       	subi	r24, 0xA3	; 163
    8e12:	9a 4d       	sbci	r25, 0xDA	; 218
    8e14:	b5 01       	movw	r22, r10
    8e16:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    8e1a:	0f 90       	pop	r0
    8e1c:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    8e1e:	81 14       	cp	r8, r1
    8e20:	91 04       	cpc	r9, r1
    8e22:	19 f0       	breq	.+6      	; 0x8e2a <xTaskGenericCreate+0x1bc>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    8e24:	f4 01       	movw	r30, r8
    8e26:	c0 83       	st	Z, r28
    8e28:	d1 83       	std	Z+1, r29	; 0x01
		}

		if( xSchedulerRunning != pdFALSE )
    8e2a:	80 91 ca 25 	lds	r24, 0x25CA
    8e2e:	88 23       	and	r24, r24
    8e30:	61 f0       	breq	.+24     	; 0x8e4a <xTaskGenericCreate+0x1dc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    8e32:	e0 91 55 25 	lds	r30, 0x2555
    8e36:	f0 91 56 25 	lds	r31, 0x2556
    8e3a:	86 89       	ldd	r24, Z+22	; 0x16
    8e3c:	80 17       	cp	r24, r16
    8e3e:	28 f4       	brcc	.+10     	; 0x8e4a <xTaskGenericCreate+0x1dc>
			{
				portYIELD_WITHIN_API();
    8e40:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
    8e44:	02 c0       	rjmp	.+4      	; 0x8e4a <xTaskGenericCreate+0x1dc>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    8e46:	8f ef       	ldi	r24, 0xFF	; 255
    8e48:	01 c0       	rjmp	.+2      	; 0x8e4c <xTaskGenericCreate+0x1de>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    8e4a:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    8e4c:	df 91       	pop	r29
    8e4e:	cf 91       	pop	r28
    8e50:	1f 91       	pop	r17
    8e52:	0f 91       	pop	r16
    8e54:	ff 90       	pop	r15
    8e56:	ef 90       	pop	r14
    8e58:	df 90       	pop	r13
    8e5a:	cf 90       	pop	r12
    8e5c:	bf 90       	pop	r11
    8e5e:	af 90       	pop	r10
    8e60:	9f 90       	pop	r9
    8e62:	8f 90       	pop	r8
    8e64:	7f 90       	pop	r7
    8e66:	6f 90       	pop	r6
    8e68:	5f 90       	pop	r5
    8e6a:	4f 90       	pop	r4
    8e6c:	3f 90       	pop	r3
    8e6e:	2f 90       	pop	r2
    8e70:	08 95       	ret

00008e72 <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		portENTER_CRITICAL();
    8e72:	0f b6       	in	r0, 0x3f	; 63
    8e74:	f8 94       	cli
    8e76:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8e78:	00 97       	sbiw	r24, 0x00	; 0
    8e7a:	29 f4       	brne	.+10     	; 0x8e86 <uxTaskPriorityGet+0x14>
    8e7c:	e0 91 55 25 	lds	r30, 0x2555
    8e80:	f0 91 56 25 	lds	r31, 0x2556
    8e84:	01 c0       	rjmp	.+2      	; 0x8e88 <uxTaskPriorityGet+0x16>
    8e86:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portEXIT_CRITICAL();
    8e88:	0f 90       	pop	r0
    8e8a:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    8e8c:	86 89       	ldd	r24, Z+22	; 0x16
    8e8e:	08 95       	ret

00008e90 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    8e90:	ef 92       	push	r14
    8e92:	ff 92       	push	r15
    8e94:	0f 93       	push	r16
    8e96:	1f 93       	push	r17
    8e98:	df 93       	push	r29
    8e9a:	cf 93       	push	r28
    8e9c:	0f 92       	push	r0
    8e9e:	cd b7       	in	r28, 0x3d	; 61
    8ea0:	de b7       	in	r29, 0x3e	; 62
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8ea2:	63 30       	cpi	r22, 0x03	; 3
    8ea4:	08 f0       	brcs	.+2      	; 0x8ea8 <vTaskPrioritySet+0x18>
    8ea6:	62 e0       	ldi	r22, 0x02	; 2
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		portENTER_CRITICAL();
    8ea8:	0f b6       	in	r0, 0x3f	; 63
    8eaa:	f8 94       	cli
    8eac:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    8eae:	20 91 55 25 	lds	r18, 0x2555
    8eb2:	30 91 56 25 	lds	r19, 0x2556
    8eb6:	82 17       	cp	r24, r18
    8eb8:	93 07       	cpc	r25, r19
    8eba:	11 f0       	breq	.+4      	; 0x8ec0 <vTaskPrioritySet+0x30>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8ebc:	00 97       	sbiw	r24, 0x00	; 0
    8ebe:	39 f4       	brne	.+14     	; 0x8ece <vTaskPrioritySet+0x3e>
    8ec0:	e0 90 55 25 	lds	r14, 0x2555
    8ec4:	f0 90 56 25 	lds	r15, 0x2556
    8ec8:	80 e0       	ldi	r24, 0x00	; 0
    8eca:	90 e0       	ldi	r25, 0x00	; 0
    8ecc:	01 c0       	rjmp	.+2      	; 0x8ed0 <vTaskPrioritySet+0x40>
    8ece:	7c 01       	movw	r14, r24
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    8ed0:	f7 01       	movw	r30, r14
    8ed2:	36 89       	ldd	r19, Z+22	; 0x16
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    8ed4:	36 17       	cp	r19, r22
    8ed6:	09 f4       	brne	.+2      	; 0x8eda <vTaskPrioritySet+0x4a>
    8ed8:	41 c0       	rjmp	.+130    	; 0x8f5c <vTaskPrioritySet+0xcc>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    8eda:	36 17       	cp	r19, r22
    8edc:	20 f4       	brcc	.+8      	; 0x8ee6 <vTaskPrioritySet+0x56>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    8ede:	21 e0       	ldi	r18, 0x01	; 1
    8ee0:	00 97       	sbiw	r24, 0x00	; 0
    8ee2:	29 f4       	brne	.+10     	; 0x8eee <vTaskPrioritySet+0x5e>
    8ee4:	03 c0       	rjmp	.+6      	; 0x8eec <vTaskPrioritySet+0x5c>
    8ee6:	21 e0       	ldi	r18, 0x01	; 1
    8ee8:	00 97       	sbiw	r24, 0x00	; 0
    8eea:	09 f0       	breq	.+2      	; 0x8eee <vTaskPrioritySet+0x5e>
    8eec:	20 e0       	ldi	r18, 0x00	; 0
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    8eee:	f7 01       	movw	r30, r14
    8ef0:	66 8b       	std	Z+22, r22	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    8ef2:	43 e0       	ldi	r20, 0x03	; 3
    8ef4:	50 e0       	ldi	r21, 0x00	; 0
    8ef6:	46 1b       	sub	r20, r22
    8ef8:	51 09       	sbc	r21, r1
    8efa:	44 87       	std	Z+12, r20	; 0x0c
    8efc:	55 87       	std	Z+13, r21	; 0x0d

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    8efe:	89 e0       	ldi	r24, 0x09	; 9
    8f00:	38 9f       	mul	r19, r24
    8f02:	c0 01       	movw	r24, r0
    8f04:	11 24       	eor	r1, r1
    8f06:	83 5a       	subi	r24, 0xA3	; 163
    8f08:	9a 4d       	sbci	r25, 0xDA	; 218
    8f0a:	42 85       	ldd	r20, Z+10	; 0x0a
    8f0c:	53 85       	ldd	r21, Z+11	; 0x0b
    8f0e:	48 17       	cp	r20, r24
    8f10:	59 07       	cpc	r21, r25
    8f12:	01 f5       	brne	.+64     	; 0x8f54 <vTaskPrioritySet+0xc4>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    8f14:	87 01       	movw	r16, r14
    8f16:	0e 5f       	subi	r16, 0xFE	; 254
    8f18:	1f 4f       	sbci	r17, 0xFF	; 255
    8f1a:	c8 01       	movw	r24, r16
    8f1c:	29 83       	std	Y+1, r18	; 0x01
    8f1e:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    8f22:	f7 01       	movw	r30, r14
    8f24:	46 89       	ldd	r20, Z+22	; 0x16
    8f26:	80 91 5c 25 	lds	r24, 0x255C
    8f2a:	29 81       	ldd	r18, Y+1	; 0x01
    8f2c:	84 17       	cp	r24, r20
    8f2e:	10 f4       	brcc	.+4      	; 0x8f34 <vTaskPrioritySet+0xa4>
    8f30:	40 93 5c 25 	sts	0x255C, r20
    8f34:	50 e0       	ldi	r21, 0x00	; 0
    8f36:	ca 01       	movw	r24, r20
    8f38:	e3 e0       	ldi	r30, 0x03	; 3
    8f3a:	88 0f       	add	r24, r24
    8f3c:	99 1f       	adc	r25, r25
    8f3e:	ea 95       	dec	r30
    8f40:	e1 f7       	brne	.-8      	; 0x8f3a <vTaskPrioritySet+0xaa>
    8f42:	84 0f       	add	r24, r20
    8f44:	95 1f       	adc	r25, r21
    8f46:	83 5a       	subi	r24, 0xA3	; 163
    8f48:	9a 4d       	sbci	r25, 0xDA	; 218
    8f4a:	b8 01       	movw	r22, r16
    8f4c:	29 83       	std	Y+1, r18	; 0x01
    8f4e:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
    8f52:	29 81       	ldd	r18, Y+1	; 0x01
				}

				if( xYieldRequired == pdTRUE )
    8f54:	21 30       	cpi	r18, 0x01	; 1
    8f56:	11 f4       	brne	.+4      	; 0x8f5c <vTaskPrioritySet+0xcc>
				{
					portYIELD_WITHIN_API();
    8f58:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
				}
			}
		}
		portEXIT_CRITICAL();
    8f5c:	0f 90       	pop	r0
    8f5e:	0f be       	out	0x3f, r0	; 63
	}
    8f60:	0f 90       	pop	r0
    8f62:	cf 91       	pop	r28
    8f64:	df 91       	pop	r29
    8f66:	1f 91       	pop	r17
    8f68:	0f 91       	pop	r16
    8f6a:	ff 90       	pop	r15
    8f6c:	ef 90       	pop	r14
    8f6e:	08 95       	ret

00008f70 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    8f70:	ef 92       	push	r14
    8f72:	ff 92       	push	r15
    8f74:	0f 93       	push	r16
    8f76:	1f 93       	push	r17
    8f78:	cf 93       	push	r28
    8f7a:	df 93       	push	r29
    8f7c:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    8f7e:	0f b6       	in	r0, 0x3f	; 63
    8f80:	f8 94       	cli
    8f82:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    8f84:	80 91 55 25 	lds	r24, 0x2555
    8f88:	90 91 56 25 	lds	r25, 0x2556
    8f8c:	c8 17       	cp	r28, r24
    8f8e:	d9 07       	cpc	r29, r25
    8f90:	11 f0       	breq	.+4      	; 0x8f96 <vTaskSuspend+0x26>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    8f92:	20 97       	sbiw	r28, 0x00	; 0
    8f94:	39 f4       	brne	.+14     	; 0x8fa4 <vTaskSuspend+0x34>
    8f96:	00 91 55 25 	lds	r16, 0x2555
    8f9a:	10 91 56 25 	lds	r17, 0x2556
    8f9e:	c0 e0       	ldi	r28, 0x00	; 0
    8fa0:	d0 e0       	ldi	r29, 0x00	; 0
    8fa2:	01 c0       	rjmp	.+2      	; 0x8fa6 <vTaskSuspend+0x36>
    8fa4:	8e 01       	movw	r16, r28

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    8fa6:	f2 e0       	ldi	r31, 0x02	; 2
    8fa8:	ef 2e       	mov	r14, r31
    8faa:	f1 2c       	mov	r15, r1
    8fac:	e0 0e       	add	r14, r16
    8fae:	f1 1e       	adc	r15, r17
    8fb0:	c7 01       	movw	r24, r14
    8fb2:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    8fb6:	f8 01       	movw	r30, r16
    8fb8:	84 89       	ldd	r24, Z+20	; 0x14
    8fba:	95 89       	ldd	r25, Z+21	; 0x15
    8fbc:	00 97       	sbiw	r24, 0x00	; 0
    8fbe:	21 f0       	breq	.+8      	; 0x8fc8 <vTaskSuspend+0x58>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    8fc0:	c8 01       	movw	r24, r16
    8fc2:	0c 96       	adiw	r24, 0x0c	; 12
    8fc4:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    8fc8:	81 e8       	ldi	r24, 0x81	; 129
    8fca:	95 e2       	ldi	r25, 0x25	; 37
    8fcc:	b7 01       	movw	r22, r14
    8fce:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    8fd2:	0f 90       	pop	r0
    8fd4:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    8fd6:	20 97       	sbiw	r28, 0x00	; 0
    8fd8:	11 f4       	brne	.+4      	; 0x8fde <vTaskSuspend+0x6e>
		{
			portYIELD_WITHIN_API();
    8fda:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
		}
	}
    8fde:	df 91       	pop	r29
    8fe0:	cf 91       	pop	r28
    8fe2:	1f 91       	pop	r17
    8fe4:	0f 91       	pop	r16
    8fe6:	ff 90       	pop	r15
    8fe8:	ef 90       	pop	r14
    8fea:	08 95       	ret

00008fec <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    8fec:	fc 01       	movw	r30, r24

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    8fee:	82 85       	ldd	r24, Z+10	; 0x0a
    8ff0:	93 85       	ldd	r25, Z+11	; 0x0b
    8ff2:	25 e2       	ldi	r18, 0x25	; 37
    8ff4:	81 38       	cpi	r24, 0x81	; 129
    8ff6:	92 07       	cpc	r25, r18
    8ff8:	51 f4       	brne	.+20     	; 0x900e <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    8ffa:	24 89       	ldd	r18, Z+20	; 0x14
    8ffc:	35 89       	ldd	r19, Z+21	; 0x15
    8ffe:	85 e2       	ldi	r24, 0x25	; 37
    9000:	28 37       	cpi	r18, 0x78	; 120
    9002:	38 07       	cpc	r19, r24
    9004:	31 f0       	breq	.+12     	; 0x9012 <xTaskIsTaskSuspended+0x26>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    9006:	81 e0       	ldi	r24, 0x01	; 1
    9008:	21 15       	cp	r18, r1
    900a:	31 05       	cpc	r19, r1
    900c:	19 f0       	breq	.+6      	; 0x9014 <xTaskIsTaskSuspended+0x28>
    900e:	80 e0       	ldi	r24, 0x00	; 0
    9010:	08 95       	ret
    9012:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    9014:	08 95       	ret

00009016 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    9016:	ef 92       	push	r14
    9018:	ff 92       	push	r15
    901a:	0f 93       	push	r16
    901c:	1f 93       	push	r17
    901e:	cf 93       	push	r28
    9020:	df 93       	push	r29
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    9022:	e8 2e       	mov	r14, r24
    9024:	e7 01       	movw	r28, r14
    9026:	7e 01       	movw	r14, r28
    9028:	f9 2e       	mov	r15, r25
    902a:	e7 01       	movw	r28, r14

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    902c:	20 97       	sbiw	r28, 0x00	; 0
    902e:	b1 f1       	breq	.+108    	; 0x909c <vTaskResume+0x86>
    9030:	80 91 55 25 	lds	r24, 0x2555
    9034:	90 91 56 25 	lds	r25, 0x2556
    9038:	e8 16       	cp	r14, r24
    903a:	f9 06       	cpc	r15, r25
    903c:	79 f1       	breq	.+94     	; 0x909c <vTaskResume+0x86>
		{
			portENTER_CRITICAL();
    903e:	0f b6       	in	r0, 0x3f	; 63
    9040:	f8 94       	cli
    9042:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    9044:	c7 01       	movw	r24, r14
    9046:	0e 94 f6 47 	call	0x8fec	; 0x8fec <xTaskIsTaskSuspended>
    904a:	81 30       	cpi	r24, 0x01	; 1
    904c:	29 f5       	brne	.+74     	; 0x9098 <vTaskResume+0x82>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    904e:	87 01       	movw	r16, r14
    9050:	0e 5f       	subi	r16, 0xFE	; 254
    9052:	1f 4f       	sbci	r17, 0xFF	; 255
    9054:	c8 01       	movw	r24, r16
    9056:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    905a:	2e 89       	ldd	r18, Y+22	; 0x16
    905c:	80 91 5c 25 	lds	r24, 0x255C
    9060:	82 17       	cp	r24, r18
    9062:	10 f4       	brcc	.+4      	; 0x9068 <vTaskResume+0x52>
    9064:	20 93 5c 25 	sts	0x255C, r18
    9068:	30 e0       	ldi	r19, 0x00	; 0
    906a:	c9 01       	movw	r24, r18
    906c:	a3 e0       	ldi	r26, 0x03	; 3
    906e:	88 0f       	add	r24, r24
    9070:	99 1f       	adc	r25, r25
    9072:	aa 95       	dec	r26
    9074:	e1 f7       	brne	.-8      	; 0x906e <vTaskResume+0x58>
    9076:	82 0f       	add	r24, r18
    9078:	93 1f       	adc	r25, r19
    907a:	83 5a       	subi	r24, 0xA3	; 163
    907c:	9a 4d       	sbci	r25, 0xDA	; 218
    907e:	b8 01       	movw	r22, r16
    9080:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9084:	e0 91 55 25 	lds	r30, 0x2555
    9088:	f0 91 56 25 	lds	r31, 0x2556
    908c:	9e 89       	ldd	r25, Y+22	; 0x16
    908e:	86 89       	ldd	r24, Z+22	; 0x16
    9090:	98 17       	cp	r25, r24
    9092:	10 f0       	brcs	.+4      	; 0x9098 <vTaskResume+0x82>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    9094:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    9098:	0f 90       	pop	r0
    909a:	0f be       	out	0x3f, r0	; 63
		}
	}
    909c:	df 91       	pop	r29
    909e:	cf 91       	pop	r28
    90a0:	1f 91       	pop	r17
    90a2:	0f 91       	pop	r16
    90a4:	ff 90       	pop	r15
    90a6:	ef 90       	pop	r14
    90a8:	08 95       	ret

000090aa <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    90aa:	ef 92       	push	r14
    90ac:	ff 92       	push	r15
    90ae:	0f 93       	push	r16
    90b0:	1f 93       	push	r17
    90b2:	cf 93       	push	r28
    90b4:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
    90b6:	e8 2e       	mov	r14, r24
    90b8:	e7 01       	movw	r28, r14
    90ba:	7e 01       	movw	r14, r28
    90bc:	f9 2e       	mov	r15, r25
    90be:	e7 01       	movw	r28, r14

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    90c0:	c7 01       	movw	r24, r14
    90c2:	0e 94 f6 47 	call	0x8fec	; 0x8fec <xTaskIsTaskSuspended>
    90c6:	81 30       	cpi	r24, 0x01	; 1
    90c8:	99 f5       	brne	.+102    	; 0x9130 <xTaskResumeFromISR+0x86>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    90ca:	80 91 5b 25 	lds	r24, 0x255B
    90ce:	88 23       	and	r24, r24
    90d0:	41 f5       	brne	.+80     	; 0x9122 <xTaskResumeFromISR+0x78>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    90d2:	e0 91 55 25 	lds	r30, 0x2555
    90d6:	f0 91 56 25 	lds	r31, 0x2556
    90da:	ff 24       	eor	r15, r15
    90dc:	f3 94       	inc	r15
    90de:	9e 89       	ldd	r25, Y+22	; 0x16
    90e0:	86 89       	ldd	r24, Z+22	; 0x16
    90e2:	98 17       	cp	r25, r24
    90e4:	08 f4       	brcc	.+2      	; 0x90e8 <xTaskResumeFromISR+0x3e>
    90e6:	ff 24       	eor	r15, r15
				vListRemove(  &( pxTCB->xGenericListItem ) );
    90e8:	8e 01       	movw	r16, r28
    90ea:	0e 5f       	subi	r16, 0xFE	; 254
    90ec:	1f 4f       	sbci	r17, 0xFF	; 255
    90ee:	c8 01       	movw	r24, r16
    90f0:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    90f4:	4e 89       	ldd	r20, Y+22	; 0x16
    90f6:	80 91 5c 25 	lds	r24, 0x255C
    90fa:	84 17       	cp	r24, r20
    90fc:	10 f4       	brcc	.+4      	; 0x9102 <xTaskResumeFromISR+0x58>
    90fe:	40 93 5c 25 	sts	0x255C, r20
    9102:	50 e0       	ldi	r21, 0x00	; 0
    9104:	9a 01       	movw	r18, r20
    9106:	b3 e0       	ldi	r27, 0x03	; 3
    9108:	22 0f       	add	r18, r18
    910a:	33 1f       	adc	r19, r19
    910c:	ba 95       	dec	r27
    910e:	e1 f7       	brne	.-8      	; 0x9108 <xTaskResumeFromISR+0x5e>
    9110:	24 0f       	add	r18, r20
    9112:	35 1f       	adc	r19, r21
    9114:	c9 01       	movw	r24, r18
    9116:	83 5a       	subi	r24, 0xA3	; 163
    9118:	9a 4d       	sbci	r25, 0xDA	; 218
    911a:	b8 01       	movw	r22, r16
    911c:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
    9120:	08 c0       	rjmp	.+16     	; 0x9132 <xTaskResumeFromISR+0x88>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    9122:	b7 01       	movw	r22, r14
    9124:	64 5f       	subi	r22, 0xF4	; 244
    9126:	7f 4f       	sbci	r23, 0xFF	; 255
    9128:	88 e7       	ldi	r24, 0x78	; 120
    912a:	95 e2       	ldi	r25, 0x25	; 37
    912c:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    9130:	ff 24       	eor	r15, r15
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
			}
		}

		return xYieldRequired;
	}
    9132:	8f 2d       	mov	r24, r15
    9134:	df 91       	pop	r29
    9136:	cf 91       	pop	r28
    9138:	1f 91       	pop	r17
    913a:	0f 91       	pop	r16
    913c:	ff 90       	pop	r15
    913e:	ef 90       	pop	r14
    9140:	08 95       	ret

00009142 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    9142:	af 92       	push	r10
    9144:	bf 92       	push	r11
    9146:	cf 92       	push	r12
    9148:	df 92       	push	r13
    914a:	ef 92       	push	r14
    914c:	ff 92       	push	r15
    914e:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    9150:	84 e3       	ldi	r24, 0x34	; 52
    9152:	96 e4       	ldi	r25, 0x46	; 70
    9154:	6b e3       	ldi	r22, 0x3B	; 59
    9156:	75 e2       	ldi	r23, 0x25	; 37
    9158:	46 e9       	ldi	r20, 0x96	; 150
    915a:	50 e0       	ldi	r21, 0x00	; 0
    915c:	20 e0       	ldi	r18, 0x00	; 0
    915e:	30 e0       	ldi	r19, 0x00	; 0
    9160:	00 e0       	ldi	r16, 0x00	; 0
    9162:	ee 24       	eor	r14, r14
    9164:	ff 24       	eor	r15, r15
    9166:	cc 24       	eor	r12, r12
    9168:	dd 24       	eor	r13, r13
    916a:	aa 24       	eor	r10, r10
    916c:	bb 24       	eor	r11, r11
    916e:	0e 94 37 46 	call	0x8c6e	; 0x8c6e <xTaskGenericCreate>

	if( xReturn == pdPASS )
    9172:	81 30       	cpi	r24, 0x01	; 1
    9174:	49 f4       	brne	.+18     	; 0x9188 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    9176:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    9178:	80 93 ca 25 	sts	0x25CA, r24
		xTickCount = ( portTickType ) 0;
    917c:	10 92 59 25 	sts	0x2559, r1
    9180:	10 92 5a 25 	sts	0x255A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    9184:	0e 94 f5 52 	call	0xa5ea	; 0xa5ea <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    9188:	0f 91       	pop	r16
    918a:	ff 90       	pop	r15
    918c:	ef 90       	pop	r14
    918e:	df 90       	pop	r13
    9190:	cf 90       	pop	r12
    9192:	bf 90       	pop	r11
    9194:	af 90       	pop	r10
    9196:	08 95       	ret

00009198 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    9198:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    919a:	10 92 ca 25 	sts	0x25CA, r1
	vPortEndScheduler();
    919e:	0e 94 3f 53 	call	0xa67e	; 0xa67e <vPortEndScheduler>
}
    91a2:	08 95       	ret

000091a4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    91a4:	80 91 5b 25 	lds	r24, 0x255B
    91a8:	8f 5f       	subi	r24, 0xFF	; 255
    91aa:	80 93 5b 25 	sts	0x255B, r24
}
    91ae:	08 95       	ret

000091b0 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    91b0:	0f b6       	in	r0, 0x3f	; 63
    91b2:	f8 94       	cli
    91b4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    91b6:	20 91 59 25 	lds	r18, 0x2559
    91ba:	30 91 5a 25 	lds	r19, 0x255A
	}
	portEXIT_CRITICAL();
    91be:	0f 90       	pop	r0
    91c0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    91c2:	c9 01       	movw	r24, r18
    91c4:	08 95       	ret

000091c6 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    91c6:	80 91 c9 25 	lds	r24, 0x25C9
}
    91ca:	08 95       	ret

000091cc <vTaskStartTrace>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
	{
		portENTER_CRITICAL();
    91cc:	0f b6       	in	r0, 0x3f	; 63
    91ce:	f8 94       	cli
    91d0:	0f 92       	push	r0
		{
			pcTraceBuffer = ( signed char * )pcBuffer;
    91d2:	80 93 8f 25 	sts	0x258F, r24
    91d6:	90 93 90 25 	sts	0x2590, r25
			pcTraceBufferStart = pcBuffer;
    91da:	80 93 94 25 	sts	0x2594, r24
    91de:	90 93 95 25 	sts	0x2595, r25
			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
    91e2:	48 50       	subi	r20, 0x08	; 8
    91e4:	50 40       	sbci	r21, 0x00	; 0
    91e6:	48 0f       	add	r20, r24
    91e8:	59 1f       	adc	r21, r25
    91ea:	40 93 91 25 	sts	0x2591, r20
    91ee:	50 93 92 25 	sts	0x2592, r21
			xTracing = pdTRUE;
    91f2:	81 e0       	ldi	r24, 0x01	; 1
    91f4:	80 93 8e 25 	sts	0x258E, r24
		}
		portEXIT_CRITICAL();
    91f8:	0f 90       	pop	r0
    91fa:	0f be       	out	0x3f, r0	; 63
	}
    91fc:	08 95       	ret

000091fe <ulTaskEndTrace>:

	unsigned long ulTaskEndTrace( void )
	{
	unsigned long ulBufferLength;

		portENTER_CRITICAL();
    91fe:	0f b6       	in	r0, 0x3f	; 63
    9200:	f8 94       	cli
    9202:	0f 92       	push	r0
			xTracing = pdFALSE;
    9204:	10 92 8e 25 	sts	0x258E, r1
		portEXIT_CRITICAL();
    9208:	0f 90       	pop	r0
    920a:	0f be       	out	0x3f, r0	; 63

		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
    920c:	20 91 8f 25 	lds	r18, 0x258F
    9210:	30 91 90 25 	lds	r19, 0x2590
    9214:	80 91 94 25 	lds	r24, 0x2594
    9218:	90 91 95 25 	lds	r25, 0x2595
    921c:	28 1b       	sub	r18, r24
    921e:	39 0b       	sbc	r19, r25
    9220:	44 27       	eor	r20, r20
    9222:	37 fd       	sbrc	r19, 7
    9224:	40 95       	com	r20
    9226:	54 2f       	mov	r21, r20

		return ulBufferLength;
	}
    9228:	b9 01       	movw	r22, r18
    922a:	ca 01       	movw	r24, r20
    922c:	08 95       	ret

0000922e <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    922e:	0f 93       	push	r16
    9230:	1f 93       	push	r17
    9232:	cf 93       	push	r28
    9234:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9236:	80 91 5b 25 	lds	r24, 0x255B
    923a:	88 23       	and	r24, r24
    923c:	09 f0       	breq	.+2      	; 0x9240 <vTaskIncrementTick+0x12>
    923e:	65 c0       	rjmp	.+202    	; 0x930a <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
    9240:	80 91 59 25 	lds	r24, 0x2559
    9244:	90 91 5a 25 	lds	r25, 0x255A
    9248:	01 96       	adiw	r24, 0x01	; 1
    924a:	80 93 59 25 	sts	0x2559, r24
    924e:	90 93 5a 25 	sts	0x255A, r25
		if( xTickCount == ( portTickType ) 0 )
    9252:	80 91 59 25 	lds	r24, 0x2559
    9256:	90 91 5a 25 	lds	r25, 0x255A
    925a:	00 97       	sbiw	r24, 0x00	; 0
    925c:	09 f0       	breq	.+2      	; 0x9260 <vTaskIncrementTick+0x32>
    925e:	42 c0       	rjmp	.+132    	; 0x92e4 <vTaskIncrementTick+0xb6>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    9260:	80 91 8c 25 	lds	r24, 0x258C
    9264:	90 91 8d 25 	lds	r25, 0x258D
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    9268:	20 91 8a 25 	lds	r18, 0x258A
    926c:	30 91 8b 25 	lds	r19, 0x258B
    9270:	20 93 8c 25 	sts	0x258C, r18
    9274:	30 93 8d 25 	sts	0x258D, r19
			pxOverflowDelayedTaskList = pxTemp;
    9278:	80 93 8a 25 	sts	0x258A, r24
    927c:	90 93 8b 25 	sts	0x258B, r25
			xNumOfOverflows++;
    9280:	80 91 58 25 	lds	r24, 0x2558
    9284:	8f 5f       	subi	r24, 0xFF	; 255
    9286:	80 93 58 25 	sts	0x2558, r24
    928a:	2c c0       	rjmp	.+88     	; 0x92e4 <vTaskIncrementTick+0xb6>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    928c:	20 91 59 25 	lds	r18, 0x2559
    9290:	30 91 5a 25 	lds	r19, 0x255A
    9294:	8a 81       	ldd	r24, Y+2	; 0x02
    9296:	9b 81       	ldd	r25, Y+3	; 0x03
    9298:	28 17       	cp	r18, r24
    929a:	39 07       	cpc	r19, r25
    929c:	d8 f1       	brcs	.+118    	; 0x9314 <vTaskIncrementTick+0xe6>
    929e:	8e 01       	movw	r16, r28
    92a0:	0e 5f       	subi	r16, 0xFE	; 254
    92a2:	1f 4f       	sbci	r17, 0xFF	; 255
    92a4:	c8 01       	movw	r24, r16
    92a6:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
    92aa:	8c 89       	ldd	r24, Y+20	; 0x14
    92ac:	9d 89       	ldd	r25, Y+21	; 0x15
    92ae:	00 97       	sbiw	r24, 0x00	; 0
    92b0:	21 f0       	breq	.+8      	; 0x92ba <vTaskIncrementTick+0x8c>
    92b2:	ce 01       	movw	r24, r28
    92b4:	0c 96       	adiw	r24, 0x0c	; 12
    92b6:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
    92ba:	2e 89       	ldd	r18, Y+22	; 0x16
    92bc:	80 91 5c 25 	lds	r24, 0x255C
    92c0:	82 17       	cp	r24, r18
    92c2:	10 f4       	brcc	.+4      	; 0x92c8 <vTaskIncrementTick+0x9a>
    92c4:	20 93 5c 25 	sts	0x255C, r18
    92c8:	30 e0       	ldi	r19, 0x00	; 0
    92ca:	c9 01       	movw	r24, r18
    92cc:	43 e0       	ldi	r20, 0x03	; 3
    92ce:	88 0f       	add	r24, r24
    92d0:	99 1f       	adc	r25, r25
    92d2:	4a 95       	dec	r20
    92d4:	e1 f7       	brne	.-8      	; 0x92ce <vTaskIncrementTick+0xa0>
    92d6:	82 0f       	add	r24, r18
    92d8:	93 1f       	adc	r25, r19
    92da:	83 5a       	subi	r24, 0xA3	; 163
    92dc:	9a 4d       	sbci	r25, 0xDA	; 218
    92de:	b8 01       	movw	r22, r16
    92e0:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
    92e4:	e0 91 8c 25 	lds	r30, 0x258C
    92e8:	f0 91 8d 25 	lds	r31, 0x258D
    92ec:	80 81       	ld	r24, Z
    92ee:	88 23       	and	r24, r24
    92f0:	89 f0       	breq	.+34     	; 0x9314 <vTaskIncrementTick+0xe6>
    92f2:	e0 91 8c 25 	lds	r30, 0x258C
    92f6:	f0 91 8d 25 	lds	r31, 0x258D
    92fa:	05 80       	ldd	r0, Z+5	; 0x05
    92fc:	f6 81       	ldd	r31, Z+6	; 0x06
    92fe:	e0 2d       	mov	r30, r0
    9300:	c6 81       	ldd	r28, Z+6	; 0x06
    9302:	d7 81       	ldd	r29, Z+7	; 0x07
    9304:	20 97       	sbiw	r28, 0x00	; 0
    9306:	11 f6       	brne	.-124    	; 0x928c <vTaskIncrementTick+0x5e>
    9308:	05 c0       	rjmp	.+10     	; 0x9314 <vTaskIncrementTick+0xe6>
	}
	else
	{
		++uxMissedTicks;
    930a:	80 91 93 25 	lds	r24, 0x2593
    930e:	8f 5f       	subi	r24, 0xFF	; 255
    9310:	80 93 93 25 	sts	0x2593, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    9314:	df 91       	pop	r29
    9316:	cf 91       	pop	r28
    9318:	1f 91       	pop	r17
    931a:	0f 91       	pop	r16
    931c:	08 95       	ret

0000931e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    931e:	ef 92       	push	r14
    9320:	ff 92       	push	r15
    9322:	0f 93       	push	r16
    9324:	1f 93       	push	r17
    9326:	df 93       	push	r29
    9328:	cf 93       	push	r28
    932a:	0f 92       	push	r0
    932c:	cd b7       	in	r28, 0x3d	; 61
    932e:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    9330:	0f b6       	in	r0, 0x3f	; 63
    9332:	f8 94       	cli
    9334:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    9336:	80 91 5b 25 	lds	r24, 0x255B
    933a:	81 50       	subi	r24, 0x01	; 1
    933c:	80 93 5b 25 	sts	0x255B, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9340:	80 91 5b 25 	lds	r24, 0x255B
    9344:	88 23       	and	r24, r24
    9346:	09 f0       	breq	.+2      	; 0x934a <xTaskResumeAll+0x2c>
    9348:	60 c0       	rjmp	.+192    	; 0x940a <xTaskResumeAll+0xec>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    934a:	80 91 c9 25 	lds	r24, 0x25C9
    934e:	88 23       	and	r24, r24
    9350:	09 f4       	brne	.+2      	; 0x9354 <xTaskResumeAll+0x36>
    9352:	5b c0       	rjmp	.+182    	; 0x940a <xTaskResumeAll+0xec>
    9354:	19 82       	std	Y+1, r1	; 0x01
    9356:	2f c0       	rjmp	.+94     	; 0x93b6 <xTaskResumeAll+0x98>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    9358:	c7 01       	movw	r24, r14
    935a:	0c 96       	adiw	r24, 0x0c	; 12
    935c:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    9360:	87 01       	movw	r16, r14
    9362:	0e 5f       	subi	r16, 0xFE	; 254
    9364:	1f 4f       	sbci	r17, 0xFF	; 255
    9366:	c8 01       	movw	r24, r16
    9368:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    936c:	d7 01       	movw	r26, r14
    936e:	56 96       	adiw	r26, 0x16	; 22
    9370:	2c 91       	ld	r18, X
    9372:	56 97       	sbiw	r26, 0x16	; 22
    9374:	80 91 5c 25 	lds	r24, 0x255C
    9378:	82 17       	cp	r24, r18
    937a:	10 f4       	brcc	.+4      	; 0x9380 <xTaskResumeAll+0x62>
    937c:	20 93 5c 25 	sts	0x255C, r18
    9380:	30 e0       	ldi	r19, 0x00	; 0
    9382:	c9 01       	movw	r24, r18
    9384:	53 e0       	ldi	r21, 0x03	; 3
    9386:	88 0f       	add	r24, r24
    9388:	99 1f       	adc	r25, r25
    938a:	5a 95       	dec	r21
    938c:	e1 f7       	brne	.-8      	; 0x9386 <xTaskResumeAll+0x68>
    938e:	82 0f       	add	r24, r18
    9390:	93 1f       	adc	r25, r19
    9392:	83 5a       	subi	r24, 0xA3	; 163
    9394:	9a 4d       	sbci	r25, 0xDA	; 218
    9396:	b8 01       	movw	r22, r16
    9398:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    939c:	e0 91 55 25 	lds	r30, 0x2555
    93a0:	f0 91 56 25 	lds	r31, 0x2556
    93a4:	d7 01       	movw	r26, r14
    93a6:	56 96       	adiw	r26, 0x16	; 22
    93a8:	9c 91       	ld	r25, X
    93aa:	56 97       	sbiw	r26, 0x16	; 22
    93ac:	86 89       	ldd	r24, Z+22	; 0x16
    93ae:	98 17       	cp	r25, r24
    93b0:	10 f0       	brcs	.+4      	; 0x93b6 <xTaskResumeAll+0x98>
					{
						xYieldRequired = pdTRUE;
    93b2:	b1 e0       	ldi	r27, 0x01	; 1
    93b4:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    93b6:	80 91 78 25 	lds	r24, 0x2578
    93ba:	88 23       	and	r24, r24
    93bc:	49 f0       	breq	.+18     	; 0x93d0 <xTaskResumeAll+0xb2>
    93be:	e0 91 7d 25 	lds	r30, 0x257D
    93c2:	f0 91 7e 25 	lds	r31, 0x257E
    93c6:	e6 80       	ldd	r14, Z+6	; 0x06
    93c8:	f7 80       	ldd	r15, Z+7	; 0x07
    93ca:	e1 14       	cp	r14, r1
    93cc:	f1 04       	cpc	r15, r1
    93ce:	21 f6       	brne	.-120    	; 0x9358 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    93d0:	80 91 93 25 	lds	r24, 0x2593
    93d4:	88 23       	and	r24, r24
    93d6:	41 f4       	brne	.+16     	; 0x93e8 <xTaskResumeAll+0xca>
    93d8:	0b c0       	rjmp	.+22     	; 0x93f0 <xTaskResumeAll+0xd2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    93da:	0e 94 17 49 	call	0x922e	; 0x922e <vTaskIncrementTick>
						--uxMissedTicks;
    93de:	80 91 93 25 	lds	r24, 0x2593
    93e2:	81 50       	subi	r24, 0x01	; 1
    93e4:	80 93 93 25 	sts	0x2593, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    93e8:	80 91 93 25 	lds	r24, 0x2593
    93ec:	88 23       	and	r24, r24
    93ee:	a9 f7       	brne	.-22     	; 0x93da <xTaskResumeAll+0xbc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    93f0:	e9 81       	ldd	r30, Y+1	; 0x01
    93f2:	e1 30       	cpi	r30, 0x01	; 1
    93f4:	21 f0       	breq	.+8      	; 0x93fe <xTaskResumeAll+0xe0>
    93f6:	80 91 57 25 	lds	r24, 0x2557
    93fa:	81 30       	cpi	r24, 0x01	; 1
    93fc:	31 f4       	brne	.+12     	; 0x940a <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    93fe:	10 92 57 25 	sts	0x2557, r1
					portYIELD_WITHIN_API();
    9402:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    9406:	81 e0       	ldi	r24, 0x01	; 1
    9408:	01 c0       	rjmp	.+2      	; 0x940c <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    940a:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
    940c:	0f 90       	pop	r0
    940e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    9410:	0f 90       	pop	r0
    9412:	cf 91       	pop	r28
    9414:	df 91       	pop	r29
    9416:	1f 91       	pop	r17
    9418:	0f 91       	pop	r16
    941a:	ff 90       	pop	r15
    941c:	ef 90       	pop	r14
    941e:	08 95       	ret

00009420 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
    9420:	1f 93       	push	r17
    9422:	cf 93       	push	r28
    9424:	df 93       	push	r29
    9426:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
    9428:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <vTaskSuspendAll>
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
    942c:	18 82       	st	Y, r1
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
    942e:	ce 01       	movw	r24, r28
    9430:	60 e4       	ldi	r22, 0x40	; 64
    9432:	75 e2       	ldi	r23, 0x25	; 37
    9434:	0e 94 d9 56 	call	0xadb2	; 0xadb2 <strcat>

			uxQueue = uxTopUsedPriority + 1;
    9438:	10 91 96 25 	lds	r17, 0x2596
    943c:	1f 5f       	subi	r17, 0xFF	; 255

			do
			{
				uxQueue--;
    943e:	11 50       	subi	r17, 0x01	; 1

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    9440:	81 2f       	mov	r24, r17
    9442:	90 e0       	ldi	r25, 0x00	; 0
    9444:	bc 01       	movw	r22, r24
    9446:	e3 e0       	ldi	r30, 0x03	; 3
    9448:	66 0f       	add	r22, r22
    944a:	77 1f       	adc	r23, r23
    944c:	ea 95       	dec	r30
    944e:	e1 f7       	brne	.-8      	; 0x9448 <vTaskList+0x28>
    9450:	68 0f       	add	r22, r24
    9452:	79 1f       	adc	r23, r25
    9454:	63 5a       	subi	r22, 0xA3	; 163
    9456:	7a 4d       	sbci	r23, 0xDA	; 218
    9458:	fb 01       	movw	r30, r22
    945a:	80 81       	ld	r24, Z
    945c:	88 23       	and	r24, r24
    945e:	21 f0       	breq	.+8      	; 0x9468 <vTaskList+0x48>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
    9460:	ce 01       	movw	r24, r28
    9462:	42 e5       	ldi	r20, 0x52	; 82
    9464:	0e 94 9c 45 	call	0x8b38	; 0x8b38 <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
    9468:	11 23       	and	r17, r17
    946a:	49 f7       	brne	.-46     	; 0x943e <vTaskList+0x1e>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
    946c:	e0 91 8c 25 	lds	r30, 0x258C
    9470:	f0 91 8d 25 	lds	r31, 0x258D
    9474:	80 81       	ld	r24, Z
    9476:	88 23       	and	r24, r24
    9478:	41 f0       	breq	.+16     	; 0x948a <vTaskList+0x6a>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
    947a:	60 91 8c 25 	lds	r22, 0x258C
    947e:	70 91 8d 25 	lds	r23, 0x258D
    9482:	ce 01       	movw	r24, r28
    9484:	42 e4       	ldi	r20, 0x42	; 66
    9486:	0e 94 9c 45 	call	0x8b38	; 0x8b38 <prvListTaskWithinSingleList>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
    948a:	e0 91 8a 25 	lds	r30, 0x258A
    948e:	f0 91 8b 25 	lds	r31, 0x258B
    9492:	80 81       	ld	r24, Z
    9494:	88 23       	and	r24, r24
    9496:	41 f0       	breq	.+16     	; 0x94a8 <vTaskList+0x88>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
    9498:	60 91 8a 25 	lds	r22, 0x258A
    949c:	70 91 8b 25 	lds	r23, 0x258B
    94a0:	ce 01       	movw	r24, r28
    94a2:	42 e4       	ldi	r20, 0x42	; 66
    94a4:	0e 94 9c 45 	call	0x8b38	; 0x8b38 <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
    94a8:	80 91 81 25 	lds	r24, 0x2581
    94ac:	88 23       	and	r24, r24
    94ae:	31 f0       	breq	.+12     	; 0x94bc <vTaskList+0x9c>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
    94b0:	ce 01       	movw	r24, r28
    94b2:	61 e8       	ldi	r22, 0x81	; 129
    94b4:	75 e2       	ldi	r23, 0x25	; 37
    94b6:	43 e5       	ldi	r20, 0x53	; 83
    94b8:	0e 94 9c 45 	call	0x8b38	; 0x8b38 <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
    94bc:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
	}
    94c0:	df 91       	pop	r29
    94c2:	cf 91       	pop	r28
    94c4:	1f 91       	pop	r17
    94c6:	08 95       	ret

000094c8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    94c8:	0f 93       	push	r16
    94ca:	1f 93       	push	r17
    94cc:	cf 93       	push	r28
    94ce:	df 93       	push	r29
    94d0:	8c 01       	movw	r16, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    94d2:	00 97       	sbiw	r24, 0x00	; 0
    94d4:	89 f1       	breq	.+98     	; 0x9538 <vTaskDelay+0x70>
		{
			vTaskSuspendAll();
    94d6:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    94da:	c0 91 59 25 	lds	r28, 0x2559
    94de:	d0 91 5a 25 	lds	r29, 0x255A
    94e2:	c0 0f       	add	r28, r16
    94e4:	d1 1f       	adc	r29, r17

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    94e6:	80 91 55 25 	lds	r24, 0x2555
    94ea:	90 91 56 25 	lds	r25, 0x2556
    94ee:	02 96       	adiw	r24, 0x02	; 2
    94f0:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    94f4:	e0 91 55 25 	lds	r30, 0x2555
    94f8:	f0 91 56 25 	lds	r31, 0x2556
    94fc:	c2 83       	std	Z+2, r28	; 0x02
    94fe:	d3 83       	std	Z+3, r29	; 0x03

				if( xTimeToWake < xTickCount )
    9500:	80 91 59 25 	lds	r24, 0x2559
    9504:	90 91 5a 25 	lds	r25, 0x255A
    9508:	c8 17       	cp	r28, r24
    950a:	d9 07       	cpc	r29, r25
    950c:	28 f4       	brcc	.+10     	; 0x9518 <vTaskDelay+0x50>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    950e:	80 91 8a 25 	lds	r24, 0x258A
    9512:	90 91 8b 25 	lds	r25, 0x258B
    9516:	04 c0       	rjmp	.+8      	; 0x9520 <vTaskDelay+0x58>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9518:	80 91 8c 25 	lds	r24, 0x258C
    951c:	90 91 8d 25 	lds	r25, 0x258D
    9520:	60 91 55 25 	lds	r22, 0x2555
    9524:	70 91 56 25 	lds	r23, 0x2556
    9528:	6e 5f       	subi	r22, 0xFE	; 254
    952a:	7f 4f       	sbci	r23, 0xFF	; 255
    952c:	0e 94 30 50 	call	0xa060	; 0xa060 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    9530:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    9534:	88 23       	and	r24, r24
    9536:	11 f4       	brne	.+4      	; 0x953c <vTaskDelay+0x74>
		{
			portYIELD_WITHIN_API();
    9538:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
		}
	}
    953c:	df 91       	pop	r29
    953e:	cf 91       	pop	r28
    9540:	1f 91       	pop	r17
    9542:	0f 91       	pop	r16
    9544:	08 95       	ret

00009546 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    9546:	0f 93       	push	r16
    9548:	1f 93       	push	r17
    954a:	cf 93       	push	r28
    954c:	df 93       	push	r29
    954e:	8c 01       	movw	r16, r24
    9550:	eb 01       	movw	r28, r22
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
    9552:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    9556:	f8 01       	movw	r30, r16
    9558:	80 81       	ld	r24, Z
    955a:	91 81       	ldd	r25, Z+1	; 0x01
    955c:	c8 0f       	add	r28, r24
    955e:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    9560:	20 91 59 25 	lds	r18, 0x2559
    9564:	30 91 5a 25 	lds	r19, 0x255A
    9568:	28 17       	cp	r18, r24
    956a:	39 07       	cpc	r19, r25
    956c:	20 f4       	brcc	.+8      	; 0x9576 <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    956e:	c8 17       	cp	r28, r24
    9570:	d9 07       	cpc	r29, r25
    9572:	60 f4       	brcc	.+24     	; 0x958c <vTaskDelayUntil+0x46>
    9574:	03 c0       	rjmp	.+6      	; 0x957c <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    9576:	c8 17       	cp	r28, r24
    9578:	d9 07       	cpc	r29, r25
    957a:	50 f0       	brcs	.+20     	; 0x9590 <vTaskDelayUntil+0x4a>
    957c:	80 91 59 25 	lds	r24, 0x2559
    9580:	90 91 5a 25 	lds	r25, 0x255A
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    9584:	21 e0       	ldi	r18, 0x01	; 1
    9586:	8c 17       	cp	r24, r28
    9588:	9d 07       	cpc	r25, r29
    958a:	18 f0       	brcs	.+6      	; 0x9592 <vTaskDelayUntil+0x4c>
    958c:	20 e0       	ldi	r18, 0x00	; 0
    958e:	01 c0       	rjmp	.+2      	; 0x9592 <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    9590:	21 e0       	ldi	r18, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    9592:	f8 01       	movw	r30, r16
    9594:	c0 83       	st	Z, r28
    9596:	d1 83       	std	Z+1, r29	; 0x01

			if( xShouldDelay )
    9598:	22 23       	and	r18, r18
    959a:	29 f1       	breq	.+74     	; 0x95e6 <vTaskDelayUntil+0xa0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    959c:	80 91 55 25 	lds	r24, 0x2555
    95a0:	90 91 56 25 	lds	r25, 0x2556
    95a4:	02 96       	adiw	r24, 0x02	; 2
    95a6:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    95aa:	e0 91 55 25 	lds	r30, 0x2555
    95ae:	f0 91 56 25 	lds	r31, 0x2556
    95b2:	c2 83       	std	Z+2, r28	; 0x02
    95b4:	d3 83       	std	Z+3, r29	; 0x03

				if( xTimeToWake < xTickCount )
    95b6:	80 91 59 25 	lds	r24, 0x2559
    95ba:	90 91 5a 25 	lds	r25, 0x255A
    95be:	c8 17       	cp	r28, r24
    95c0:	d9 07       	cpc	r29, r25
    95c2:	28 f4       	brcc	.+10     	; 0x95ce <vTaskDelayUntil+0x88>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    95c4:	80 91 8a 25 	lds	r24, 0x258A
    95c8:	90 91 8b 25 	lds	r25, 0x258B
    95cc:	04 c0       	rjmp	.+8      	; 0x95d6 <vTaskDelayUntil+0x90>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    95ce:	80 91 8c 25 	lds	r24, 0x258C
    95d2:	90 91 8d 25 	lds	r25, 0x258D
    95d6:	60 91 55 25 	lds	r22, 0x2555
    95da:	70 91 56 25 	lds	r23, 0x2556
    95de:	6e 5f       	subi	r22, 0xFE	; 254
    95e0:	7f 4f       	sbci	r23, 0xFF	; 255
    95e2:	0e 94 30 50 	call	0xa060	; 0xa060 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    95e6:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    95ea:	88 23       	and	r24, r24
    95ec:	11 f4       	brne	.+4      	; 0x95f2 <vTaskDelayUntil+0xac>
		{
			portYIELD_WITHIN_API();
    95ee:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
		}
	}
    95f2:	df 91       	pop	r29
    95f4:	cf 91       	pop	r28
    95f6:	1f 91       	pop	r17
    95f8:	0f 91       	pop	r16
    95fa:	08 95       	ret

000095fc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    95fc:	80 91 5b 25 	lds	r24, 0x255B
    9600:	88 23       	and	r24, r24
    9602:	49 f0       	breq	.+18     	; 0x9616 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    9604:	81 e0       	ldi	r24, 0x01	; 1
    9606:	80 93 57 25 	sts	0x2557, r24
		return;
    960a:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    960c:	80 91 5c 25 	lds	r24, 0x255C
    9610:	81 50       	subi	r24, 0x01	; 1
    9612:	80 93 5c 25 	sts	0x255C, r24

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    9616:	80 91 5c 25 	lds	r24, 0x255C
    961a:	90 e0       	ldi	r25, 0x00	; 0
    961c:	fc 01       	movw	r30, r24
    961e:	23 e0       	ldi	r18, 0x03	; 3
    9620:	ee 0f       	add	r30, r30
    9622:	ff 1f       	adc	r31, r31
    9624:	2a 95       	dec	r18
    9626:	e1 f7       	brne	.-8      	; 0x9620 <vTaskSwitchContext+0x24>
    9628:	e8 0f       	add	r30, r24
    962a:	f9 1f       	adc	r31, r25
    962c:	e3 5a       	subi	r30, 0xA3	; 163
    962e:	fa 4d       	sbci	r31, 0xDA	; 218
    9630:	80 81       	ld	r24, Z
    9632:	88 23       	and	r24, r24
    9634:	59 f3       	breq	.-42     	; 0x960c <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    9636:	80 91 5c 25 	lds	r24, 0x255C
    963a:	90 e0       	ldi	r25, 0x00	; 0
    963c:	9c 01       	movw	r18, r24
    963e:	b3 e0       	ldi	r27, 0x03	; 3
    9640:	22 0f       	add	r18, r18
    9642:	33 1f       	adc	r19, r19
    9644:	ba 95       	dec	r27
    9646:	e1 f7       	brne	.-8      	; 0x9640 <vTaskSwitchContext+0x44>
    9648:	28 0f       	add	r18, r24
    964a:	39 1f       	adc	r19, r25
    964c:	f9 01       	movw	r30, r18
    964e:	e3 5a       	subi	r30, 0xA3	; 163
    9650:	fa 4d       	sbci	r31, 0xDA	; 218
    9652:	a1 81       	ldd	r26, Z+1	; 0x01
    9654:	b2 81       	ldd	r27, Z+2	; 0x02
    9656:	12 96       	adiw	r26, 0x02	; 2
    9658:	0d 90       	ld	r0, X+
    965a:	bc 91       	ld	r27, X
    965c:	a0 2d       	mov	r26, r0
    965e:	a1 83       	std	Z+1, r26	; 0x01
    9660:	b2 83       	std	Z+2, r27	; 0x02
    9662:	20 5a       	subi	r18, 0xA0	; 160
    9664:	3a 4d       	sbci	r19, 0xDA	; 218
    9666:	a2 17       	cp	r26, r18
    9668:	b3 07       	cpc	r27, r19
    966a:	31 f4       	brne	.+12     	; 0x9678 <vTaskSwitchContext+0x7c>
    966c:	12 96       	adiw	r26, 0x02	; 2
    966e:	2d 91       	ld	r18, X+
    9670:	3c 91       	ld	r19, X
    9672:	13 97       	sbiw	r26, 0x03	; 3
    9674:	21 83       	std	Z+1, r18	; 0x01
    9676:	32 83       	std	Z+2, r19	; 0x02
    9678:	fc 01       	movw	r30, r24
    967a:	a3 e0       	ldi	r26, 0x03	; 3
    967c:	ee 0f       	add	r30, r30
    967e:	ff 1f       	adc	r31, r31
    9680:	aa 95       	dec	r26
    9682:	e1 f7       	brne	.-8      	; 0x967c <vTaskSwitchContext+0x80>
    9684:	e8 0f       	add	r30, r24
    9686:	f9 1f       	adc	r31, r25
    9688:	e3 5a       	subi	r30, 0xA3	; 163
    968a:	fa 4d       	sbci	r31, 0xDA	; 218
    968c:	01 80       	ldd	r0, Z+1	; 0x01
    968e:	f2 81       	ldd	r31, Z+2	; 0x02
    9690:	e0 2d       	mov	r30, r0
    9692:	86 81       	ldd	r24, Z+6	; 0x06
    9694:	97 81       	ldd	r25, Z+7	; 0x07
    9696:	80 93 55 25 	sts	0x2555, r24
    969a:	90 93 56 25 	sts	0x2556, r25

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
    969e:	80 91 8e 25 	lds	r24, 0x258E
    96a2:	88 23       	and	r24, r24
    96a4:	09 f4       	brne	.+2      	; 0x96a8 <vTaskSwitchContext+0xac>
    96a6:	4c c0       	rjmp	.+152    	; 0x9740 <vTaskSwitchContext+0x144>
    96a8:	e0 91 55 25 	lds	r30, 0x2555
    96ac:	f0 91 56 25 	lds	r31, 0x2556
    96b0:	90 91 43 25 	lds	r25, 0x2543
    96b4:	83 a1       	ldd	r24, Z+35	; 0x23
    96b6:	98 17       	cp	r25, r24
    96b8:	09 f4       	brne	.+2      	; 0x96bc <vTaskSwitchContext+0xc0>
    96ba:	42 c0       	rjmp	.+132    	; 0x9740 <vTaskSwitchContext+0x144>
    96bc:	80 91 8f 25 	lds	r24, 0x258F
    96c0:	90 91 90 25 	lds	r25, 0x2590
    96c4:	08 96       	adiw	r24, 0x08	; 8
    96c6:	20 91 91 25 	lds	r18, 0x2591
    96ca:	30 91 92 25 	lds	r19, 0x2592
    96ce:	82 17       	cp	r24, r18
    96d0:	93 07       	cpc	r25, r19
    96d2:	a0 f5       	brcc	.+104    	; 0x973c <vTaskSwitchContext+0x140>
    96d4:	e0 91 55 25 	lds	r30, 0x2555
    96d8:	f0 91 56 25 	lds	r31, 0x2556
    96dc:	83 a1       	ldd	r24, Z+35	; 0x23
    96de:	80 93 43 25 	sts	0x2543, r24
    96e2:	e0 91 8f 25 	lds	r30, 0x258F
    96e6:	f0 91 90 25 	lds	r31, 0x2590
    96ea:	20 91 59 25 	lds	r18, 0x2559
    96ee:	30 91 5a 25 	lds	r19, 0x255A
    96f2:	40 e0       	ldi	r20, 0x00	; 0
    96f4:	50 e0       	ldi	r21, 0x00	; 0
    96f6:	20 83       	st	Z, r18
    96f8:	31 83       	std	Z+1, r19	; 0x01
    96fa:	42 83       	std	Z+2, r20	; 0x02
    96fc:	53 83       	std	Z+3, r21	; 0x03
    96fe:	20 91 8f 25 	lds	r18, 0x258F
    9702:	30 91 90 25 	lds	r19, 0x2590
    9706:	2c 5f       	subi	r18, 0xFC	; 252
    9708:	3f 4f       	sbci	r19, 0xFF	; 255
    970a:	20 93 8f 25 	sts	0x258F, r18
    970e:	30 93 90 25 	sts	0x2590, r19
    9712:	e0 91 8f 25 	lds	r30, 0x258F
    9716:	f0 91 90 25 	lds	r31, 0x2590
    971a:	90 e0       	ldi	r25, 0x00	; 0
    971c:	a0 e0       	ldi	r26, 0x00	; 0
    971e:	b0 e0       	ldi	r27, 0x00	; 0
    9720:	80 83       	st	Z, r24
    9722:	91 83       	std	Z+1, r25	; 0x01
    9724:	a2 83       	std	Z+2, r26	; 0x02
    9726:	b3 83       	std	Z+3, r27	; 0x03
    9728:	80 91 8f 25 	lds	r24, 0x258F
    972c:	90 91 90 25 	lds	r25, 0x2590
    9730:	04 96       	adiw	r24, 0x04	; 4
    9732:	80 93 8f 25 	sts	0x258F, r24
    9736:	90 93 90 25 	sts	0x2590, r25
    973a:	08 95       	ret
    973c:	10 92 8e 25 	sts	0x258E, r1
    9740:	08 95       	ret

00009742 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    9742:	cf 93       	push	r28
    9744:	df 93       	push	r29
    9746:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    9748:	60 91 55 25 	lds	r22, 0x2555
    974c:	70 91 56 25 	lds	r23, 0x2556
    9750:	64 5f       	subi	r22, 0xF4	; 244
    9752:	7f 4f       	sbci	r23, 0xFF	; 255
    9754:	0e 94 30 50 	call	0xa060	; 0xa060 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9758:	80 91 55 25 	lds	r24, 0x2555
    975c:	90 91 56 25 	lds	r25, 0x2556
    9760:	02 96       	adiw	r24, 0x02	; 2
    9762:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    9766:	8f ef       	ldi	r24, 0xFF	; 255
    9768:	cf 3f       	cpi	r28, 0xFF	; 255
    976a:	d8 07       	cpc	r29, r24
    976c:	59 f4       	brne	.+22     	; 0x9784 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    976e:	60 91 55 25 	lds	r22, 0x2555
    9772:	70 91 56 25 	lds	r23, 0x2556
    9776:	6e 5f       	subi	r22, 0xFE	; 254
    9778:	7f 4f       	sbci	r23, 0xFF	; 255
    977a:	81 e8       	ldi	r24, 0x81	; 129
    977c:	95 e2       	ldi	r25, 0x25	; 37
    977e:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
    9782:	24 c0       	rjmp	.+72     	; 0x97cc <vTaskPlaceOnEventList+0x8a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    9784:	80 91 59 25 	lds	r24, 0x2559
    9788:	90 91 5a 25 	lds	r25, 0x255A
    978c:	8c 0f       	add	r24, r28
    978e:	9d 1f       	adc	r25, r29

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    9790:	e0 91 55 25 	lds	r30, 0x2555
    9794:	f0 91 56 25 	lds	r31, 0x2556
    9798:	82 83       	std	Z+2, r24	; 0x02
    979a:	93 83       	std	Z+3, r25	; 0x03

			if( xTimeToWake < xTickCount )
    979c:	20 91 59 25 	lds	r18, 0x2559
    97a0:	30 91 5a 25 	lds	r19, 0x255A
    97a4:	82 17       	cp	r24, r18
    97a6:	93 07       	cpc	r25, r19
    97a8:	28 f4       	brcc	.+10     	; 0x97b4 <vTaskPlaceOnEventList+0x72>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    97aa:	80 91 8a 25 	lds	r24, 0x258A
    97ae:	90 91 8b 25 	lds	r25, 0x258B
    97b2:	04 c0       	rjmp	.+8      	; 0x97bc <vTaskPlaceOnEventList+0x7a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    97b4:	80 91 8c 25 	lds	r24, 0x258C
    97b8:	90 91 8d 25 	lds	r25, 0x258D
    97bc:	60 91 55 25 	lds	r22, 0x2555
    97c0:	70 91 56 25 	lds	r23, 0x2556
    97c4:	6e 5f       	subi	r22, 0xFE	; 254
    97c6:	7f 4f       	sbci	r23, 0xFF	; 255
    97c8:	0e 94 30 50 	call	0xa060	; 0xa060 <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    97cc:	df 91       	pop	r29
    97ce:	cf 91       	pop	r28
    97d0:	08 95       	ret

000097d2 <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    97d2:	0f 93       	push	r16
    97d4:	1f 93       	push	r17
    97d6:	cf 93       	push	r28
    97d8:	df 93       	push	r29
    97da:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    97dc:	80 81       	ld	r24, Z
    97de:	88 23       	and	r24, r24
    97e0:	31 f0       	breq	.+12     	; 0x97ee <xTaskRemoveFromEventList+0x1c>
    97e2:	05 80       	ldd	r0, Z+5	; 0x05
    97e4:	f6 81       	ldd	r31, Z+6	; 0x06
    97e6:	e0 2d       	mov	r30, r0
    97e8:	c6 81       	ldd	r28, Z+6	; 0x06
    97ea:	d7 81       	ldd	r29, Z+7	; 0x07
    97ec:	02 c0       	rjmp	.+4      	; 0x97f2 <xTaskRemoveFromEventList+0x20>
    97ee:	c0 e0       	ldi	r28, 0x00	; 0
    97f0:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    97f2:	8e 01       	movw	r16, r28
    97f4:	04 5f       	subi	r16, 0xF4	; 244
    97f6:	1f 4f       	sbci	r17, 0xFF	; 255
    97f8:	c8 01       	movw	r24, r16
    97fa:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    97fe:	80 91 5b 25 	lds	r24, 0x255B
    9802:	88 23       	and	r24, r24
    9804:	c9 f4       	brne	.+50     	; 0x9838 <xTaskRemoveFromEventList+0x66>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    9806:	8e 01       	movw	r16, r28
    9808:	0e 5f       	subi	r16, 0xFE	; 254
    980a:	1f 4f       	sbci	r17, 0xFF	; 255
    980c:	c8 01       	movw	r24, r16
    980e:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    9812:	2e 89       	ldd	r18, Y+22	; 0x16
    9814:	80 91 5c 25 	lds	r24, 0x255C
    9818:	82 17       	cp	r24, r18
    981a:	10 f4       	brcc	.+4      	; 0x9820 <xTaskRemoveFromEventList+0x4e>
    981c:	20 93 5c 25 	sts	0x255C, r18
    9820:	30 e0       	ldi	r19, 0x00	; 0
    9822:	c9 01       	movw	r24, r18
    9824:	43 e0       	ldi	r20, 0x03	; 3
    9826:	88 0f       	add	r24, r24
    9828:	99 1f       	adc	r25, r25
    982a:	4a 95       	dec	r20
    982c:	e1 f7       	brne	.-8      	; 0x9826 <xTaskRemoveFromEventList+0x54>
    982e:	82 0f       	add	r24, r18
    9830:	93 1f       	adc	r25, r19
    9832:	83 5a       	subi	r24, 0xA3	; 163
    9834:	9a 4d       	sbci	r25, 0xDA	; 218
    9836:	02 c0       	rjmp	.+4      	; 0x983c <xTaskRemoveFromEventList+0x6a>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    9838:	88 e7       	ldi	r24, 0x78	; 120
    983a:	95 e2       	ldi	r25, 0x25	; 37
    983c:	b8 01       	movw	r22, r16
    983e:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9842:	e0 91 55 25 	lds	r30, 0x2555
    9846:	f0 91 56 25 	lds	r31, 0x2556
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    984a:	81 e0       	ldi	r24, 0x01	; 1
    984c:	2e 89       	ldd	r18, Y+22	; 0x16
    984e:	96 89       	ldd	r25, Z+22	; 0x16
    9850:	29 17       	cp	r18, r25
    9852:	08 f4       	brcc	.+2      	; 0x9856 <xTaskRemoveFromEventList+0x84>
    9854:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    9856:	df 91       	pop	r29
    9858:	cf 91       	pop	r28
    985a:	1f 91       	pop	r17
    985c:	0f 91       	pop	r16
    985e:	08 95       	ret

00009860 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    9860:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    9862:	80 91 58 25 	lds	r24, 0x2558
    9866:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    9868:	80 91 59 25 	lds	r24, 0x2559
    986c:	90 91 5a 25 	lds	r25, 0x255A
    9870:	81 83       	std	Z+1, r24	; 0x01
    9872:	92 83       	std	Z+2, r25	; 0x02
}
    9874:	08 95       	ret

00009876 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    9876:	fc 01       	movw	r30, r24
    9878:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    987a:	0f b6       	in	r0, 0x3f	; 63
    987c:	f8 94       	cli
    987e:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    9880:	2d 91       	ld	r18, X+
    9882:	3c 91       	ld	r19, X
    9884:	11 97       	sbiw	r26, 0x01	; 1
    9886:	8f ef       	ldi	r24, 0xFF	; 255
    9888:	2f 3f       	cpi	r18, 0xFF	; 255
    988a:	38 07       	cpc	r19, r24
    988c:	69 f1       	breq	.+90     	; 0x98e8 <xTaskCheckForTimeOut+0x72>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    988e:	90 91 58 25 	lds	r25, 0x2558
    9892:	80 81       	ld	r24, Z
    9894:	98 17       	cp	r25, r24
    9896:	49 f0       	breq	.+18     	; 0x98aa <xTaskCheckForTimeOut+0x34>
    9898:	40 91 59 25 	lds	r20, 0x2559
    989c:	50 91 5a 25 	lds	r21, 0x255A
    98a0:	81 81       	ldd	r24, Z+1	; 0x01
    98a2:	92 81       	ldd	r25, Z+2	; 0x02
    98a4:	48 17       	cp	r20, r24
    98a6:	59 07       	cpc	r21, r25
    98a8:	08 f5       	brcc	.+66     	; 0x98ec <xTaskCheckForTimeOut+0x76>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    98aa:	40 91 59 25 	lds	r20, 0x2559
    98ae:	50 91 5a 25 	lds	r21, 0x255A
    98b2:	81 81       	ldd	r24, Z+1	; 0x01
    98b4:	92 81       	ldd	r25, Z+2	; 0x02
    98b6:	48 1b       	sub	r20, r24
    98b8:	59 0b       	sbc	r21, r25
    98ba:	42 17       	cp	r20, r18
    98bc:	53 07       	cpc	r21, r19
    98be:	b0 f4       	brcc	.+44     	; 0x98ec <xTaskCheckForTimeOut+0x76>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    98c0:	40 91 59 25 	lds	r20, 0x2559
    98c4:	50 91 5a 25 	lds	r21, 0x255A
    98c8:	84 1b       	sub	r24, r20
    98ca:	95 0b       	sbc	r25, r21
    98cc:	82 0f       	add	r24, r18
    98ce:	93 1f       	adc	r25, r19
    98d0:	8d 93       	st	X+, r24
    98d2:	9c 93       	st	X, r25
    98d4:	11 97       	sbiw	r26, 0x01	; 1
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    98d6:	80 91 58 25 	lds	r24, 0x2558
    98da:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    98dc:	80 91 59 25 	lds	r24, 0x2559
    98e0:	90 91 5a 25 	lds	r25, 0x255A
    98e4:	81 83       	std	Z+1, r24	; 0x01
    98e6:	92 83       	std	Z+2, r25	; 0x02
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    98e8:	80 e0       	ldi	r24, 0x00	; 0
    98ea:	01 c0       	rjmp	.+2      	; 0x98ee <xTaskCheckForTimeOut+0x78>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    98ec:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portEXIT_CRITICAL();
    98ee:	0f 90       	pop	r0
    98f0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    98f2:	08 95       	ret

000098f4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    98f4:	81 e0       	ldi	r24, 0x01	; 1
    98f6:	80 93 57 25 	sts	0x2557, r24
}
    98fa:	08 95       	ret

000098fc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    98fc:	0f 93       	push	r16
    98fe:	1f 93       	push	r17
    9900:	cf 93       	push	r28
    9902:	df 93       	push	r29
    9904:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    9906:	0f b6       	in	r0, 0x3f	; 63
    9908:	f8 94       	cli
    990a:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    990c:	8c 01       	movw	r16, r24
    990e:	0f 5e       	subi	r16, 0xEF	; 239
    9910:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    9912:	0d c0       	rjmp	.+26     	; 0x992e <prvUnlockQueue+0x32>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9914:	89 89       	ldd	r24, Y+17	; 0x11
    9916:	88 23       	and	r24, r24
    9918:	69 f0       	breq	.+26     	; 0x9934 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    991a:	c8 01       	movw	r24, r16
    991c:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <xTaskRemoveFromEventList>
    9920:	88 23       	and	r24, r24
    9922:	11 f0       	breq	.+4      	; 0x9928 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    9924:	0e 94 7a 4c 	call	0x98f4	; 0x98f4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    9928:	8e 8d       	ldd	r24, Y+30	; 0x1e
    992a:	81 50       	subi	r24, 0x01	; 1
    992c:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    992e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9930:	18 16       	cp	r1, r24
    9932:	84 f3       	brlt	.-32     	; 0x9914 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    9934:	8f ef       	ldi	r24, 0xFF	; 255
    9936:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    9938:	0f 90       	pop	r0
    993a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    993c:	0f b6       	in	r0, 0x3f	; 63
    993e:	f8 94       	cli
    9940:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    9942:	8e 01       	movw	r16, r28
    9944:	08 5f       	subi	r16, 0xF8	; 248
    9946:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    9948:	0d c0       	rjmp	.+26     	; 0x9964 <prvUnlockQueue+0x68>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    994a:	88 85       	ldd	r24, Y+8	; 0x08
    994c:	88 23       	and	r24, r24
    994e:	69 f0       	breq	.+26     	; 0x996a <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    9950:	c8 01       	movw	r24, r16
    9952:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <xTaskRemoveFromEventList>
    9956:	88 23       	and	r24, r24
    9958:	11 f0       	breq	.+4      	; 0x995e <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    995a:	0e 94 7a 4c 	call	0x98f4	; 0x98f4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    995e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    9960:	81 50       	subi	r24, 0x01	; 1
    9962:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    9964:	8d 8d       	ldd	r24, Y+29	; 0x1d
    9966:	18 16       	cp	r1, r24
    9968:	84 f3       	brlt	.-32     	; 0x994a <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    996a:	8f ef       	ldi	r24, 0xFF	; 255
    996c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    996e:	0f 90       	pop	r0
    9970:	0f be       	out	0x3f, r0	; 63
}
    9972:	df 91       	pop	r29
    9974:	cf 91       	pop	r28
    9976:	1f 91       	pop	r17
    9978:	0f 91       	pop	r16
    997a:	08 95       	ret

0000997c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    997c:	af 92       	push	r10
    997e:	bf 92       	push	r11
    9980:	cf 92       	push	r12
    9982:	df 92       	push	r13
    9984:	ef 92       	push	r14
    9986:	ff 92       	push	r15
    9988:	0f 93       	push	r16
    998a:	1f 93       	push	r17
    998c:	cf 93       	push	r28
    998e:	df 93       	push	r29
    9990:	b8 2e       	mov	r11, r24
    9992:	a6 2e       	mov	r10, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    9994:	88 23       	and	r24, r24
    9996:	09 f4       	brne	.+2      	; 0x999a <xQueueCreate+0x1e>
    9998:	43 c0       	rjmp	.+134    	; 0x9a20 <xQueueCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    999a:	8f e1       	ldi	r24, 0x1F	; 31
    999c:	90 e0       	ldi	r25, 0x00	; 0
    999e:	0e 94 64 52 	call	0xa4c8	; 0xa4c8 <pvPortMalloc>
    99a2:	e8 2e       	mov	r14, r24
    99a4:	e7 01       	movw	r28, r14
    99a6:	7e 01       	movw	r14, r28
    99a8:	f9 2e       	mov	r15, r25
    99aa:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
    99ac:	20 97       	sbiw	r28, 0x00	; 0
    99ae:	d1 f1       	breq	.+116    	; 0x9a24 <xQueueCreate+0xa8>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    99b0:	0b 2d       	mov	r16, r11
    99b2:	10 e0       	ldi	r17, 0x00	; 0
    99b4:	ca 2c       	mov	r12, r10
    99b6:	dd 24       	eor	r13, r13
    99b8:	c0 9e       	mul	r12, r16
    99ba:	70 01       	movw	r14, r0
    99bc:	c1 9e       	mul	r12, r17
    99be:	f0 0c       	add	r15, r0
    99c0:	d0 9e       	mul	r13, r16
    99c2:	f0 0c       	add	r15, r0
    99c4:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    99c6:	c7 01       	movw	r24, r14
    99c8:	01 96       	adiw	r24, 0x01	; 1
    99ca:	0e 94 64 52 	call	0xa4c8	; 0xa4c8 <pvPortMalloc>
    99ce:	88 83       	st	Y, r24
    99d0:	99 83       	std	Y+1, r25	; 0x01
			if( pxNewQueue->pcHead != NULL )
    99d2:	00 97       	sbiw	r24, 0x00	; 0
    99d4:	11 f1       	breq	.+68     	; 0x9a1a <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    99d6:	e8 0e       	add	r14, r24
    99d8:	f9 1e       	adc	r15, r25
    99da:	ea 82       	std	Y+2, r14	; 0x02
    99dc:	fb 82       	std	Y+3, r15	; 0x03
				pxNewQueue->uxMessagesWaiting = 0;
    99de:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    99e0:	8c 83       	std	Y+4, r24	; 0x04
    99e2:	9d 83       	std	Y+5, r25	; 0x05
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    99e4:	01 50       	subi	r16, 0x01	; 1
    99e6:	10 40       	sbci	r17, 0x00	; 0
    99e8:	0c 9d       	mul	r16, r12
    99ea:	a0 01       	movw	r20, r0
    99ec:	0d 9d       	mul	r16, r13
    99ee:	50 0d       	add	r21, r0
    99f0:	1c 9d       	mul	r17, r12
    99f2:	50 0d       	add	r21, r0
    99f4:	11 24       	eor	r1, r1
    99f6:	48 0f       	add	r20, r24
    99f8:	59 1f       	adc	r21, r25
    99fa:	4e 83       	std	Y+6, r20	; 0x06
    99fc:	5f 83       	std	Y+7, r21	; 0x07
				pxNewQueue->uxLength = uxQueueLength;
    99fe:	bb 8e       	std	Y+27, r11	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    9a00:	ac 8e       	std	Y+28, r10	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    9a02:	8f ef       	ldi	r24, 0xFF	; 255
    9a04:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    9a06:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    9a08:	ce 01       	movw	r24, r28
    9a0a:	08 96       	adiw	r24, 0x08	; 8
    9a0c:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    9a10:	ce 01       	movw	r24, r28
    9a12:	41 96       	adiw	r24, 0x11	; 17
    9a14:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    9a18:	05 c0       	rjmp	.+10     	; 0x9a24 <xQueueCreate+0xa8>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    9a1a:	ce 01       	movw	r24, r28
    9a1c:	0e 94 8d 52 	call	0xa51a	; 0xa51a <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    9a20:	c0 e0       	ldi	r28, 0x00	; 0
    9a22:	d0 e0       	ldi	r29, 0x00	; 0
}
    9a24:	ce 01       	movw	r24, r28
    9a26:	df 91       	pop	r29
    9a28:	cf 91       	pop	r28
    9a2a:	1f 91       	pop	r17
    9a2c:	0f 91       	pop	r16
    9a2e:	ff 90       	pop	r15
    9a30:	ef 90       	pop	r14
    9a32:	df 90       	pop	r13
    9a34:	cf 90       	pop	r12
    9a36:	bf 90       	pop	r11
    9a38:	af 90       	pop	r10
    9a3a:	08 95       	ret

00009a3c <xQueueCreateExternal>:

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    9a3c:	cf 92       	push	r12
    9a3e:	df 92       	push	r13
    9a40:	ef 92       	push	r14
    9a42:	ff 92       	push	r15
    9a44:	1f 93       	push	r17
    9a46:	df 93       	push	r29
    9a48:	cf 93       	push	r28
    9a4a:	00 d0       	rcall	.+0      	; 0x9a4c <xQueueCreateExternal+0x10>
    9a4c:	cd b7       	in	r28, 0x3d	; 61
    9a4e:	de b7       	in	r29, 0x3e	; 62
    9a50:	18 2f       	mov	r17, r24
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    9a52:	88 23       	and	r24, r24
    9a54:	09 f4       	brne	.+2      	; 0x9a58 <xQueueCreateExternal+0x1c>
    9a56:	56 c0       	rjmp	.+172    	; 0x9b04 <xQueueCreateExternal+0xc8>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    9a58:	8f e1       	ldi	r24, 0x1F	; 31
    9a5a:	90 e0       	ldi	r25, 0x00	; 0
    9a5c:	4a 83       	std	Y+2, r20	; 0x02
    9a5e:	5b 83       	std	Y+3, r21	; 0x03
    9a60:	69 83       	std	Y+1, r22	; 0x01
    9a62:	0e 94 64 52 	call	0xa4c8	; 0xa4c8 <pvPortMalloc>
    9a66:	c8 2e       	mov	r12, r24
    9a68:	d9 2e       	mov	r13, r25
		if( pxNewQueue != NULL )
    9a6a:	4a 81       	ldd	r20, Y+2	; 0x02
    9a6c:	5b 81       	ldd	r21, Y+3	; 0x03
    9a6e:	69 81       	ldd	r22, Y+1	; 0x01
    9a70:	c1 14       	cp	r12, r1
    9a72:	d1 04       	cpc	r13, r1
    9a74:	09 f4       	brne	.+2      	; 0x9a78 <xQueueCreateExternal+0x3c>
    9a76:	48 c0       	rjmp	.+144    	; 0x9b08 <xQueueCreateExternal+0xcc>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    9a78:	9a 01       	movw	r18, r20
    9a7a:	d6 01       	movw	r26, r12
    9a7c:	2d 93       	st	X+, r18
    9a7e:	3c 93       	st	X, r19
    9a80:	11 97       	sbiw	r26, 0x01	; 1
			if( pxNewQueue->pcHead != NULL )
    9a82:	21 15       	cp	r18, r1
    9a84:	31 05       	cpc	r19, r1
    9a86:	d9 f1       	breq	.+118    	; 0x9afe <xQueueCreateExternal+0xc2>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    9a88:	e1 2f       	mov	r30, r17
    9a8a:	f0 e0       	ldi	r31, 0x00	; 0
    9a8c:	86 2f       	mov	r24, r22
    9a8e:	90 e0       	ldi	r25, 0x00	; 0
    9a90:	8e 9f       	mul	r24, r30
    9a92:	a0 01       	movw	r20, r0
    9a94:	8f 9f       	mul	r24, r31
    9a96:	50 0d       	add	r21, r0
    9a98:	9e 9f       	mul	r25, r30
    9a9a:	50 0d       	add	r21, r0
    9a9c:	11 24       	eor	r1, r1
    9a9e:	42 0f       	add	r20, r18
    9aa0:	53 1f       	adc	r21, r19
    9aa2:	12 96       	adiw	r26, 0x02	; 2
    9aa4:	4d 93       	st	X+, r20
    9aa6:	5c 93       	st	X, r21
    9aa8:	13 97       	sbiw	r26, 0x03	; 3
				pxNewQueue->uxMessagesWaiting = 0;
    9aaa:	5a 96       	adiw	r26, 0x1a	; 26
    9aac:	1c 92       	st	X, r1
    9aae:	5a 97       	sbiw	r26, 0x1a	; 26
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    9ab0:	14 96       	adiw	r26, 0x04	; 4
    9ab2:	2d 93       	st	X+, r18
    9ab4:	3c 93       	st	X, r19
    9ab6:	15 97       	sbiw	r26, 0x05	; 5
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    9ab8:	31 97       	sbiw	r30, 0x01	; 1
    9aba:	e8 9f       	mul	r30, r24
    9abc:	a0 01       	movw	r20, r0
    9abe:	e9 9f       	mul	r30, r25
    9ac0:	50 0d       	add	r21, r0
    9ac2:	f8 9f       	mul	r31, r24
    9ac4:	50 0d       	add	r21, r0
    9ac6:	11 24       	eor	r1, r1
    9ac8:	42 0f       	add	r20, r18
    9aca:	53 1f       	adc	r21, r19
    9acc:	16 96       	adiw	r26, 0x06	; 6
    9ace:	4d 93       	st	X+, r20
    9ad0:	5c 93       	st	X, r21
    9ad2:	17 97       	sbiw	r26, 0x07	; 7
				pxNewQueue->uxLength = uxQueueLength;
    9ad4:	5b 96       	adiw	r26, 0x1b	; 27
    9ad6:	1c 93       	st	X, r17
    9ad8:	5b 97       	sbiw	r26, 0x1b	; 27
				pxNewQueue->uxItemSize = uxItemSize;
    9ada:	5c 96       	adiw	r26, 0x1c	; 28
    9adc:	6c 93       	st	X, r22
    9ade:	5c 97       	sbiw	r26, 0x1c	; 28
				pxNewQueue->xRxLock = queueUNLOCKED;
    9ae0:	8f ef       	ldi	r24, 0xFF	; 255
    9ae2:	5d 96       	adiw	r26, 0x1d	; 29
    9ae4:	8c 93       	st	X, r24
    9ae6:	5d 97       	sbiw	r26, 0x1d	; 29
				pxNewQueue->xTxLock = queueUNLOCKED;
    9ae8:	5e 96       	adiw	r26, 0x1e	; 30
    9aea:	8c 93       	st	X, r24

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    9aec:	c6 01       	movw	r24, r12
    9aee:	08 96       	adiw	r24, 0x08	; 8
    9af0:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    9af4:	c6 01       	movw	r24, r12
    9af6:	41 96       	adiw	r24, 0x11	; 17
    9af8:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    9afc:	05 c0       	rjmp	.+10     	; 0x9b08 <xQueueCreateExternal+0xcc>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    9afe:	c6 01       	movw	r24, r12
    9b00:	0e 94 8d 52 	call	0xa51a	; 0xa51a <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    9b04:	cc 24       	eor	r12, r12
    9b06:	dd 24       	eor	r13, r13
}
    9b08:	c6 01       	movw	r24, r12
    9b0a:	23 96       	adiw	r28, 0x03	; 3
    9b0c:	cd bf       	out	0x3d, r28	; 61
    9b0e:	de bf       	out	0x3e, r29	; 62
    9b10:	cf 91       	pop	r28
    9b12:	df 91       	pop	r29
    9b14:	1f 91       	pop	r17
    9b16:	ff 90       	pop	r15
    9b18:	ef 90       	pop	r14
    9b1a:	df 90       	pop	r13
    9b1c:	cf 90       	pop	r12
    9b1e:	08 95       	ret

00009b20 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    9b20:	7f 92       	push	r7
    9b22:	8f 92       	push	r8
    9b24:	9f 92       	push	r9
    9b26:	af 92       	push	r10
    9b28:	bf 92       	push	r11
    9b2a:	cf 92       	push	r12
    9b2c:	df 92       	push	r13
    9b2e:	ef 92       	push	r14
    9b30:	ff 92       	push	r15
    9b32:	0f 93       	push	r16
    9b34:	1f 93       	push	r17
    9b36:	df 93       	push	r29
    9b38:	cf 93       	push	r28
    9b3a:	cd b7       	in	r28, 0x3d	; 61
    9b3c:	de b7       	in	r29, 0x3e	; 62
    9b3e:	25 97       	sbiw	r28, 0x05	; 5
    9b40:	cd bf       	out	0x3d, r28	; 61
    9b42:	de bf       	out	0x3e, r29	; 62
    9b44:	8c 01       	movw	r16, r24
    9b46:	6b 01       	movw	r12, r22
    9b48:	4c 83       	std	Y+4, r20	; 0x04
    9b4a:	5d 83       	std	Y+5, r21	; 0x05
    9b4c:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    9b4e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9b50:	7e 01       	movw	r14, r28
    9b52:	08 94       	sec
    9b54:	e1 1c       	adc	r14, r1
    9b56:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9b58:	94 e0       	ldi	r25, 0x04	; 4
    9b5a:	a9 2e       	mov	r10, r25
    9b5c:	b1 2c       	mov	r11, r1
    9b5e:	ac 0e       	add	r10, r28
    9b60:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    9b62:	88 e0       	ldi	r24, 0x08	; 8
    9b64:	88 2e       	mov	r8, r24
    9b66:	91 2c       	mov	r9, r1
    9b68:	80 0e       	add	r8, r16
    9b6a:	91 1e       	adc	r9, r17
    9b6c:	01 c0       	rjmp	.+2      	; 0x9b70 <xQueueGenericSend+0x50>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    9b6e:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    9b70:	0f b6       	in	r0, 0x3f	; 63
    9b72:	f8 94       	cli
    9b74:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    9b76:	f8 01       	movw	r30, r16
    9b78:	92 8d       	ldd	r25, Z+26	; 0x1a
    9b7a:	83 8d       	ldd	r24, Z+27	; 0x1b
    9b7c:	98 17       	cp	r25, r24
    9b7e:	08 f0       	brcs	.+2      	; 0x9b82 <xQueueGenericSend+0x62>
    9b80:	4e c0       	rjmp	.+156    	; 0x9c1e <xQueueGenericSend+0xfe>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    9b82:	44 8d       	ldd	r20, Z+28	; 0x1c
    9b84:	44 23       	and	r20, r20
    9b86:	c1 f1       	breq	.+112    	; 0x9bf8 <xQueueGenericSend+0xd8>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    9b88:	77 20       	and	r7, r7
    9b8a:	c1 f4       	brne	.+48     	; 0x9bbc <xQueueGenericSend+0x9c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9b8c:	84 81       	ldd	r24, Z+4	; 0x04
    9b8e:	95 81       	ldd	r25, Z+5	; 0x05
    9b90:	b6 01       	movw	r22, r12
    9b92:	50 e0       	ldi	r21, 0x00	; 0
    9b94:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    9b98:	f8 01       	movw	r30, r16
    9b9a:	24 8d       	ldd	r18, Z+28	; 0x1c
    9b9c:	84 81       	ldd	r24, Z+4	; 0x04
    9b9e:	95 81       	ldd	r25, Z+5	; 0x05
    9ba0:	82 0f       	add	r24, r18
    9ba2:	91 1d       	adc	r25, r1
    9ba4:	84 83       	std	Z+4, r24	; 0x04
    9ba6:	95 83       	std	Z+5, r25	; 0x05
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    9ba8:	22 81       	ldd	r18, Z+2	; 0x02
    9baa:	33 81       	ldd	r19, Z+3	; 0x03
    9bac:	82 17       	cp	r24, r18
    9bae:	93 07       	cpc	r25, r19
    9bb0:	18 f1       	brcs	.+70     	; 0x9bf8 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    9bb2:	80 81       	ld	r24, Z
    9bb4:	91 81       	ldd	r25, Z+1	; 0x01
    9bb6:	84 83       	std	Z+4, r24	; 0x04
    9bb8:	95 83       	std	Z+5, r25	; 0x05
    9bba:	1e c0       	rjmp	.+60     	; 0x9bf8 <xQueueGenericSend+0xd8>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9bbc:	f8 01       	movw	r30, r16
    9bbe:	86 81       	ldd	r24, Z+6	; 0x06
    9bc0:	97 81       	ldd	r25, Z+7	; 0x07
    9bc2:	b6 01       	movw	r22, r12
    9bc4:	50 e0       	ldi	r21, 0x00	; 0
    9bc6:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    9bca:	f8 01       	movw	r30, r16
    9bcc:	24 8d       	ldd	r18, Z+28	; 0x1c
    9bce:	30 e0       	ldi	r19, 0x00	; 0
    9bd0:	30 95       	com	r19
    9bd2:	21 95       	neg	r18
    9bd4:	3f 4f       	sbci	r19, 0xFF	; 255
    9bd6:	86 81       	ldd	r24, Z+6	; 0x06
    9bd8:	97 81       	ldd	r25, Z+7	; 0x07
    9bda:	82 0f       	add	r24, r18
    9bdc:	93 1f       	adc	r25, r19
    9bde:	86 83       	std	Z+6, r24	; 0x06
    9be0:	97 83       	std	Z+7, r25	; 0x07
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    9be2:	40 81       	ld	r20, Z
    9be4:	51 81       	ldd	r21, Z+1	; 0x01
    9be6:	84 17       	cp	r24, r20
    9be8:	95 07       	cpc	r25, r21
    9bea:	30 f4       	brcc	.+12     	; 0x9bf8 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    9bec:	82 81       	ldd	r24, Z+2	; 0x02
    9bee:	93 81       	ldd	r25, Z+3	; 0x03
    9bf0:	82 0f       	add	r24, r18
    9bf2:	93 1f       	adc	r25, r19
    9bf4:	86 83       	std	Z+6, r24	; 0x06
    9bf6:	97 83       	std	Z+7, r25	; 0x07
		}
	}

	++( pxQueue->uxMessagesWaiting );
    9bf8:	f8 01       	movw	r30, r16
    9bfa:	82 8d       	ldd	r24, Z+26	; 0x1a
    9bfc:	8f 5f       	subi	r24, 0xFF	; 255
    9bfe:	82 8f       	std	Z+26, r24	; 0x1a
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    9c00:	81 89       	ldd	r24, Z+17	; 0x11
    9c02:	88 23       	and	r24, r24
    9c04:	41 f0       	breq	.+16     	; 0x9c16 <xQueueGenericSend+0xf6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    9c06:	c8 01       	movw	r24, r16
    9c08:	41 96       	adiw	r24, 0x11	; 17
    9c0a:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <xTaskRemoveFromEventList>
    9c0e:	81 30       	cpi	r24, 0x01	; 1
    9c10:	11 f4       	brne	.+4      	; 0x9c16 <xQueueGenericSend+0xf6>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    9c12:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    9c16:	0f 90       	pop	r0
    9c18:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    9c1a:	81 e0       	ldi	r24, 0x01	; 1
    9c1c:	4c c0       	rjmp	.+152    	; 0x9cb6 <xQueueGenericSend+0x196>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    9c1e:	8c 81       	ldd	r24, Y+4	; 0x04
    9c20:	9d 81       	ldd	r25, Y+5	; 0x05
    9c22:	00 97       	sbiw	r24, 0x00	; 0
    9c24:	19 f4       	brne	.+6      	; 0x9c2c <xQueueGenericSend+0x10c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    9c26:	0f 90       	pop	r0
    9c28:	0f be       	out	0x3f, r0	; 63
    9c2a:	44 c0       	rjmp	.+136    	; 0x9cb4 <xQueueGenericSend+0x194>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    9c2c:	22 23       	and	r18, r18
    9c2e:	19 f4       	brne	.+6      	; 0x9c36 <xQueueGenericSend+0x116>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9c30:	c7 01       	movw	r24, r14
    9c32:	0e 94 30 4c 	call	0x9860	; 0x9860 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    9c36:	0f 90       	pop	r0
    9c38:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    9c3a:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    9c3e:	0f b6       	in	r0, 0x3f	; 63
    9c40:	f8 94       	cli
    9c42:	0f 92       	push	r0
    9c44:	f8 01       	movw	r30, r16
    9c46:	85 8d       	ldd	r24, Z+29	; 0x1d
    9c48:	8f 3f       	cpi	r24, 0xFF	; 255
    9c4a:	09 f4       	brne	.+2      	; 0x9c4e <xQueueGenericSend+0x12e>
    9c4c:	15 8e       	std	Z+29, r1	; 0x1d
    9c4e:	f8 01       	movw	r30, r16
    9c50:	86 8d       	ldd	r24, Z+30	; 0x1e
    9c52:	8f 3f       	cpi	r24, 0xFF	; 255
    9c54:	09 f4       	brne	.+2      	; 0x9c58 <xQueueGenericSend+0x138>
    9c56:	16 8e       	std	Z+30, r1	; 0x1e
    9c58:	0f 90       	pop	r0
    9c5a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9c5c:	c7 01       	movw	r24, r14
    9c5e:	b5 01       	movw	r22, r10
    9c60:	0e 94 3b 4c 	call	0x9876	; 0x9876 <xTaskCheckForTimeOut>
    9c64:	88 23       	and	r24, r24
    9c66:	09 f5       	brne	.+66     	; 0x9caa <xQueueGenericSend+0x18a>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    9c68:	0f b6       	in	r0, 0x3f	; 63
    9c6a:	f8 94       	cli
    9c6c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    9c6e:	f8 01       	movw	r30, r16
    9c70:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9c72:	0f 90       	pop	r0
    9c74:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    9c76:	f8 01       	movw	r30, r16
    9c78:	83 8d       	ldd	r24, Z+27	; 0x1b
    9c7a:	98 17       	cp	r25, r24
    9c7c:	81 f4       	brne	.+32     	; 0x9c9e <xQueueGenericSend+0x17e>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    9c7e:	6c 81       	ldd	r22, Y+4	; 0x04
    9c80:	7d 81       	ldd	r23, Y+5	; 0x05
    9c82:	c4 01       	movw	r24, r8
    9c84:	0e 94 a1 4b 	call	0x9742	; 0x9742 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    9c88:	c8 01       	movw	r24, r16
    9c8a:	0e 94 7e 4c 	call	0x98fc	; 0x98fc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    9c8e:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
    9c92:	88 23       	and	r24, r24
    9c94:	09 f0       	breq	.+2      	; 0x9c98 <xQueueGenericSend+0x178>
    9c96:	6b cf       	rjmp	.-298    	; 0x9b6e <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    9c98:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
    9c9c:	68 cf       	rjmp	.-304    	; 0x9b6e <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    9c9e:	c8 01       	movw	r24, r16
    9ca0:	0e 94 7e 4c 	call	0x98fc	; 0x98fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    9ca4:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
    9ca8:	62 cf       	rjmp	.-316    	; 0x9b6e <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    9caa:	c8 01       	movw	r24, r16
    9cac:	0e 94 7e 4c 	call	0x98fc	; 0x98fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    9cb0:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    9cb4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    9cb6:	25 96       	adiw	r28, 0x05	; 5
    9cb8:	cd bf       	out	0x3d, r28	; 61
    9cba:	de bf       	out	0x3e, r29	; 62
    9cbc:	cf 91       	pop	r28
    9cbe:	df 91       	pop	r29
    9cc0:	1f 91       	pop	r17
    9cc2:	0f 91       	pop	r16
    9cc4:	ff 90       	pop	r15
    9cc6:	ef 90       	pop	r14
    9cc8:	df 90       	pop	r13
    9cca:	cf 90       	pop	r12
    9ccc:	bf 90       	pop	r11
    9cce:	af 90       	pop	r10
    9cd0:	9f 90       	pop	r9
    9cd2:	8f 90       	pop	r8
    9cd4:	7f 90       	pop	r7
    9cd6:	08 95       	ret

00009cd8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    9cd8:	0f 93       	push	r16
    9cda:	1f 93       	push	r17
    9cdc:	cf 93       	push	r28
    9cde:	df 93       	push	r29
    9ce0:	ec 01       	movw	r28, r24
    9ce2:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    9ce4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9ce6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    9ce8:	98 17       	cp	r25, r24
    9cea:	08 f0       	brcs	.+2      	; 0x9cee <xQueueGenericSendFromISR+0x16>
    9cec:	4c c0       	rjmp	.+152    	; 0x9d86 <xQueueGenericSendFromISR+0xae>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    9cee:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9cf0:	44 23       	and	r20, r20
    9cf2:	99 f1       	breq	.+102    	; 0x9d5a <xQueueGenericSendFromISR+0x82>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    9cf4:	22 23       	and	r18, r18
    9cf6:	b1 f4       	brne	.+44     	; 0x9d24 <xQueueGenericSendFromISR+0x4c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9cf8:	8c 81       	ldd	r24, Y+4	; 0x04
    9cfa:	9d 81       	ldd	r25, Y+5	; 0x05
    9cfc:	50 e0       	ldi	r21, 0x00	; 0
    9cfe:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    9d02:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9d04:	8c 81       	ldd	r24, Y+4	; 0x04
    9d06:	9d 81       	ldd	r25, Y+5	; 0x05
    9d08:	82 0f       	add	r24, r18
    9d0a:	91 1d       	adc	r25, r1
    9d0c:	8c 83       	std	Y+4, r24	; 0x04
    9d0e:	9d 83       	std	Y+5, r25	; 0x05
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    9d10:	2a 81       	ldd	r18, Y+2	; 0x02
    9d12:	3b 81       	ldd	r19, Y+3	; 0x03
    9d14:	82 17       	cp	r24, r18
    9d16:	93 07       	cpc	r25, r19
    9d18:	00 f1       	brcs	.+64     	; 0x9d5a <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    9d1a:	88 81       	ld	r24, Y
    9d1c:	99 81       	ldd	r25, Y+1	; 0x01
    9d1e:	8c 83       	std	Y+4, r24	; 0x04
    9d20:	9d 83       	std	Y+5, r25	; 0x05
    9d22:	1b c0       	rjmp	.+54     	; 0x9d5a <xQueueGenericSendFromISR+0x82>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9d24:	8e 81       	ldd	r24, Y+6	; 0x06
    9d26:	9f 81       	ldd	r25, Y+7	; 0x07
    9d28:	50 e0       	ldi	r21, 0x00	; 0
    9d2a:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    9d2e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9d30:	30 e0       	ldi	r19, 0x00	; 0
    9d32:	30 95       	com	r19
    9d34:	21 95       	neg	r18
    9d36:	3f 4f       	sbci	r19, 0xFF	; 255
    9d38:	8e 81       	ldd	r24, Y+6	; 0x06
    9d3a:	9f 81       	ldd	r25, Y+7	; 0x07
    9d3c:	82 0f       	add	r24, r18
    9d3e:	93 1f       	adc	r25, r19
    9d40:	8e 83       	std	Y+6, r24	; 0x06
    9d42:	9f 83       	std	Y+7, r25	; 0x07
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    9d44:	48 81       	ld	r20, Y
    9d46:	59 81       	ldd	r21, Y+1	; 0x01
    9d48:	84 17       	cp	r24, r20
    9d4a:	95 07       	cpc	r25, r21
    9d4c:	30 f4       	brcc	.+12     	; 0x9d5a <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    9d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    9d50:	9b 81       	ldd	r25, Y+3	; 0x03
    9d52:	82 0f       	add	r24, r18
    9d54:	93 1f       	adc	r25, r19
    9d56:	8e 83       	std	Y+6, r24	; 0x06
    9d58:	9f 83       	std	Y+7, r25	; 0x07
		}
	}

	++( pxQueue->uxMessagesWaiting );
    9d5a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9d5c:	8f 5f       	subi	r24, 0xFF	; 255
    9d5e:	8a 8f       	std	Y+26, r24	; 0x1a

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    9d60:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9d62:	8f 3f       	cpi	r24, 0xFF	; 255
    9d64:	69 f4       	brne	.+26     	; 0x9d80 <xQueueGenericSendFromISR+0xa8>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9d66:	89 89       	ldd	r24, Y+17	; 0x11
    9d68:	88 23       	and	r24, r24
    9d6a:	79 f0       	breq	.+30     	; 0x9d8a <xQueueGenericSendFromISR+0xb2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    9d6c:	ce 01       	movw	r24, r28
    9d6e:	41 96       	adiw	r24, 0x11	; 17
    9d70:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <xTaskRemoveFromEventList>
    9d74:	88 23       	and	r24, r24
    9d76:	49 f0       	breq	.+18     	; 0x9d8a <xQueueGenericSendFromISR+0xb2>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    9d78:	81 e0       	ldi	r24, 0x01	; 1
    9d7a:	f8 01       	movw	r30, r16
    9d7c:	80 83       	st	Z, r24
    9d7e:	06 c0       	rjmp	.+12     	; 0x9d8c <xQueueGenericSendFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    9d80:	8f 5f       	subi	r24, 0xFF	; 255
    9d82:	8e 8f       	std	Y+30, r24	; 0x1e
    9d84:	02 c0       	rjmp	.+4      	; 0x9d8a <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    9d86:	80 e0       	ldi	r24, 0x00	; 0
    9d88:	01 c0       	rjmp	.+2      	; 0x9d8c <xQueueGenericSendFromISR+0xb4>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    9d8a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    9d8c:	df 91       	pop	r29
    9d8e:	cf 91       	pop	r28
    9d90:	1f 91       	pop	r17
    9d92:	0f 91       	pop	r16
    9d94:	08 95       	ret

00009d96 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    9d96:	7f 92       	push	r7
    9d98:	8f 92       	push	r8
    9d9a:	9f 92       	push	r9
    9d9c:	af 92       	push	r10
    9d9e:	bf 92       	push	r11
    9da0:	cf 92       	push	r12
    9da2:	df 92       	push	r13
    9da4:	ef 92       	push	r14
    9da6:	ff 92       	push	r15
    9da8:	0f 93       	push	r16
    9daa:	1f 93       	push	r17
    9dac:	df 93       	push	r29
    9dae:	cf 93       	push	r28
    9db0:	cd b7       	in	r28, 0x3d	; 61
    9db2:	de b7       	in	r29, 0x3e	; 62
    9db4:	25 97       	sbiw	r28, 0x05	; 5
    9db6:	cd bf       	out	0x3d, r28	; 61
    9db8:	de bf       	out	0x3e, r29	; 62
    9dba:	8c 01       	movw	r16, r24
    9dbc:	86 2e       	mov	r8, r22
    9dbe:	77 2e       	mov	r7, r23
    9dc0:	4c 83       	std	Y+4, r20	; 0x04
    9dc2:	5d 83       	std	Y+5, r21	; 0x05
    9dc4:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    9dc6:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9dc8:	7e 01       	movw	r14, r28
    9dca:	08 94       	sec
    9dcc:	e1 1c       	adc	r14, r1
    9dce:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9dd0:	44 e0       	ldi	r20, 0x04	; 4
    9dd2:	c4 2e       	mov	r12, r20
    9dd4:	d1 2c       	mov	r13, r1
    9dd6:	cc 0e       	add	r12, r28
    9dd8:	dd 1e       	adc	r13, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    9dda:	31 e1       	ldi	r19, 0x11	; 17
    9ddc:	a3 2e       	mov	r10, r19
    9dde:	b1 2c       	mov	r11, r1
    9de0:	a8 0e       	add	r10, r24
    9de2:	b9 1e       	adc	r11, r25
    9de4:	01 c0       	rjmp	.+2      	; 0x9de8 <xQueueGenericReceive+0x52>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    9de6:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    9de8:	0f b6       	in	r0, 0x3f	; 63
    9dea:	f8 94       	cli
    9dec:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    9dee:	f8 01       	movw	r30, r16
    9df0:	82 8d       	ldd	r24, Z+26	; 0x1a
    9df2:	88 23       	and	r24, r24
    9df4:	09 f4       	brne	.+2      	; 0x9df8 <xQueueGenericReceive+0x62>
    9df6:	3d c0       	rjmp	.+122    	; 0x9e72 <xQueueGenericReceive+0xdc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    9df8:	e6 80       	ldd	r14, Z+6	; 0x06
    9dfa:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    9dfc:	80 81       	ld	r24, Z
    9dfe:	91 81       	ldd	r25, Z+1	; 0x01
    9e00:	00 97       	sbiw	r24, 0x00	; 0
    9e02:	a9 f0       	breq	.+42     	; 0x9e2e <xQueueGenericReceive+0x98>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    9e04:	44 8d       	ldd	r20, Z+28	; 0x1c
    9e06:	97 01       	movw	r18, r14
    9e08:	24 0f       	add	r18, r20
    9e0a:	31 1d       	adc	r19, r1
    9e0c:	26 83       	std	Z+6, r18	; 0x06
    9e0e:	37 83       	std	Z+7, r19	; 0x07
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    9e10:	62 81       	ldd	r22, Z+2	; 0x02
    9e12:	73 81       	ldd	r23, Z+3	; 0x03
    9e14:	26 17       	cp	r18, r22
    9e16:	37 07       	cpc	r19, r23
    9e18:	10 f0       	brcs	.+4      	; 0x9e1e <xQueueGenericReceive+0x88>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    9e1a:	86 83       	std	Z+6, r24	; 0x06
    9e1c:	97 83       	std	Z+7, r25	; 0x07
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    9e1e:	f8 01       	movw	r30, r16
    9e20:	66 81       	ldd	r22, Z+6	; 0x06
    9e22:	77 81       	ldd	r23, Z+7	; 0x07
    9e24:	88 2d       	mov	r24, r8
    9e26:	97 2d       	mov	r25, r7
    9e28:	50 e0       	ldi	r21, 0x00	; 0
    9e2a:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    9e2e:	99 20       	and	r9, r9
    9e30:	71 f4       	brne	.+28     	; 0x9e4e <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    9e32:	f8 01       	movw	r30, r16
    9e34:	82 8d       	ldd	r24, Z+26	; 0x1a
    9e36:	81 50       	subi	r24, 0x01	; 1
    9e38:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    9e3a:	80 85       	ldd	r24, Z+8	; 0x08
    9e3c:	88 23       	and	r24, r24
    9e3e:	a9 f0       	breq	.+42     	; 0x9e6a <xQueueGenericReceive+0xd4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    9e40:	c8 01       	movw	r24, r16
    9e42:	08 96       	adiw	r24, 0x08	; 8
    9e44:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <xTaskRemoveFromEventList>
    9e48:	81 30       	cpi	r24, 0x01	; 1
    9e4a:	79 f4       	brne	.+30     	; 0x9e6a <xQueueGenericReceive+0xd4>
    9e4c:	0c c0       	rjmp	.+24     	; 0x9e66 <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    9e4e:	f8 01       	movw	r30, r16
    9e50:	e6 82       	std	Z+6, r14	; 0x06
    9e52:	f7 82       	std	Z+7, r15	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9e54:	81 89       	ldd	r24, Z+17	; 0x11
    9e56:	88 23       	and	r24, r24
    9e58:	41 f0       	breq	.+16     	; 0x9e6a <xQueueGenericReceive+0xd4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    9e5a:	c8 01       	movw	r24, r16
    9e5c:	41 96       	adiw	r24, 0x11	; 17
    9e5e:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <xTaskRemoveFromEventList>
    9e62:	88 23       	and	r24, r24
    9e64:	11 f0       	breq	.+4      	; 0x9e6a <xQueueGenericReceive+0xd4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    9e66:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    9e6a:	0f 90       	pop	r0
    9e6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    9e6e:	81 e0       	ldi	r24, 0x01	; 1
    9e70:	4a c0       	rjmp	.+148    	; 0x9f06 <xQueueGenericReceive+0x170>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    9e72:	8c 81       	ldd	r24, Y+4	; 0x04
    9e74:	9d 81       	ldd	r25, Y+5	; 0x05
    9e76:	00 97       	sbiw	r24, 0x00	; 0
    9e78:	19 f4       	brne	.+6      	; 0x9e80 <xQueueGenericReceive+0xea>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    9e7a:	0f 90       	pop	r0
    9e7c:	0f be       	out	0x3f, r0	; 63
    9e7e:	42 c0       	rjmp	.+132    	; 0x9f04 <xQueueGenericReceive+0x16e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    9e80:	22 23       	and	r18, r18
    9e82:	19 f4       	brne	.+6      	; 0x9e8a <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9e84:	c7 01       	movw	r24, r14
    9e86:	0e 94 30 4c 	call	0x9860	; 0x9860 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    9e8a:	0f 90       	pop	r0
    9e8c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    9e8e:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    9e92:	0f b6       	in	r0, 0x3f	; 63
    9e94:	f8 94       	cli
    9e96:	0f 92       	push	r0
    9e98:	f8 01       	movw	r30, r16
    9e9a:	85 8d       	ldd	r24, Z+29	; 0x1d
    9e9c:	8f 3f       	cpi	r24, 0xFF	; 255
    9e9e:	09 f4       	brne	.+2      	; 0x9ea2 <xQueueGenericReceive+0x10c>
    9ea0:	15 8e       	std	Z+29, r1	; 0x1d
    9ea2:	f8 01       	movw	r30, r16
    9ea4:	86 8d       	ldd	r24, Z+30	; 0x1e
    9ea6:	8f 3f       	cpi	r24, 0xFF	; 255
    9ea8:	09 f4       	brne	.+2      	; 0x9eac <xQueueGenericReceive+0x116>
    9eaa:	16 8e       	std	Z+30, r1	; 0x1e
    9eac:	0f 90       	pop	r0
    9eae:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9eb0:	c7 01       	movw	r24, r14
    9eb2:	b6 01       	movw	r22, r12
    9eb4:	0e 94 3b 4c 	call	0x9876	; 0x9876 <xTaskCheckForTimeOut>
    9eb8:	88 23       	and	r24, r24
    9eba:	f9 f4       	brne	.+62     	; 0x9efa <xQueueGenericReceive+0x164>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    9ebc:	0f b6       	in	r0, 0x3f	; 63
    9ebe:	f8 94       	cli
    9ec0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    9ec2:	f8 01       	movw	r30, r16
    9ec4:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9ec6:	0f 90       	pop	r0
    9ec8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    9eca:	88 23       	and	r24, r24
    9ecc:	81 f4       	brne	.+32     	; 0x9eee <xQueueGenericReceive+0x158>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    9ece:	6c 81       	ldd	r22, Y+4	; 0x04
    9ed0:	7d 81       	ldd	r23, Y+5	; 0x05
    9ed2:	c5 01       	movw	r24, r10
    9ed4:	0e 94 a1 4b 	call	0x9742	; 0x9742 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    9ed8:	c8 01       	movw	r24, r16
    9eda:	0e 94 7e 4c 	call	0x98fc	; 0x98fc <prvUnlockQueue>
				if( !xTaskResumeAll() )
    9ede:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
    9ee2:	88 23       	and	r24, r24
    9ee4:	09 f0       	breq	.+2      	; 0x9ee8 <xQueueGenericReceive+0x152>
    9ee6:	7f cf       	rjmp	.-258    	; 0x9de6 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    9ee8:	0e 94 40 53 	call	0xa680	; 0xa680 <vPortYield>
    9eec:	7c cf       	rjmp	.-264    	; 0x9de6 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    9eee:	c8 01       	movw	r24, r16
    9ef0:	0e 94 7e 4c 	call	0x98fc	; 0x98fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    9ef4:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
    9ef8:	76 cf       	rjmp	.-276    	; 0x9de6 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    9efa:	c8 01       	movw	r24, r16
    9efc:	0e 94 7e 4c 	call	0x98fc	; 0x98fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    9f00:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    9f04:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    9f06:	25 96       	adiw	r28, 0x05	; 5
    9f08:	cd bf       	out	0x3d, r28	; 61
    9f0a:	de bf       	out	0x3e, r29	; 62
    9f0c:	cf 91       	pop	r28
    9f0e:	df 91       	pop	r29
    9f10:	1f 91       	pop	r17
    9f12:	0f 91       	pop	r16
    9f14:	ff 90       	pop	r15
    9f16:	ef 90       	pop	r14
    9f18:	df 90       	pop	r13
    9f1a:	cf 90       	pop	r12
    9f1c:	bf 90       	pop	r11
    9f1e:	af 90       	pop	r10
    9f20:	9f 90       	pop	r9
    9f22:	8f 90       	pop	r8
    9f24:	7f 90       	pop	r7
    9f26:	08 95       	ret

00009f28 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    9f28:	0f 93       	push	r16
    9f2a:	1f 93       	push	r17
    9f2c:	cf 93       	push	r28
    9f2e:	df 93       	push	r29
    9f30:	ec 01       	movw	r28, r24
    9f32:	cb 01       	movw	r24, r22
    9f34:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    9f36:	2a 8d       	ldd	r18, Y+26	; 0x1a
    9f38:	22 23       	and	r18, r18
    9f3a:	71 f1       	breq	.+92     	; 0x9f98 <xQueueReceiveFromISR+0x70>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    9f3c:	e8 81       	ld	r30, Y
    9f3e:	f9 81       	ldd	r31, Y+1	; 0x01
    9f40:	30 97       	sbiw	r30, 0x00	; 0
    9f42:	a1 f0       	breq	.+40     	; 0x9f6c <xQueueReceiveFromISR+0x44>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    9f44:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9f46:	2e 81       	ldd	r18, Y+6	; 0x06
    9f48:	3f 81       	ldd	r19, Y+7	; 0x07
    9f4a:	24 0f       	add	r18, r20
    9f4c:	31 1d       	adc	r19, r1
    9f4e:	2e 83       	std	Y+6, r18	; 0x06
    9f50:	3f 83       	std	Y+7, r19	; 0x07
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    9f52:	aa 81       	ldd	r26, Y+2	; 0x02
    9f54:	bb 81       	ldd	r27, Y+3	; 0x03
    9f56:	2a 17       	cp	r18, r26
    9f58:	3b 07       	cpc	r19, r27
    9f5a:	10 f0       	brcs	.+4      	; 0x9f60 <xQueueReceiveFromISR+0x38>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    9f5c:	ee 83       	std	Y+6, r30	; 0x06
    9f5e:	ff 83       	std	Y+7, r31	; 0x07
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    9f60:	6e 81       	ldd	r22, Y+6	; 0x06
    9f62:	2f 81       	ldd	r18, Y+7	; 0x07
    9f64:	72 2f       	mov	r23, r18
    9f66:	50 e0       	ldi	r21, 0x00	; 0
    9f68:	0e 94 c9 56 	call	0xad92	; 0xad92 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    9f6c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9f6e:	81 50       	subi	r24, 0x01	; 1
    9f70:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    9f72:	8d 8d       	ldd	r24, Y+29	; 0x1d
    9f74:	8f 3f       	cpi	r24, 0xFF	; 255
    9f76:	69 f4       	brne	.+26     	; 0x9f92 <xQueueReceiveFromISR+0x6a>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    9f78:	88 85       	ldd	r24, Y+8	; 0x08
    9f7a:	88 23       	and	r24, r24
    9f7c:	79 f0       	breq	.+30     	; 0x9f9c <xQueueReceiveFromISR+0x74>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    9f7e:	ce 01       	movw	r24, r28
    9f80:	08 96       	adiw	r24, 0x08	; 8
    9f82:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <xTaskRemoveFromEventList>
    9f86:	88 23       	and	r24, r24
    9f88:	49 f0       	breq	.+18     	; 0x9f9c <xQueueReceiveFromISR+0x74>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    9f8a:	81 e0       	ldi	r24, 0x01	; 1
    9f8c:	f8 01       	movw	r30, r16
    9f8e:	80 83       	st	Z, r24
    9f90:	06 c0       	rjmp	.+12     	; 0x9f9e <xQueueReceiveFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    9f92:	8f 5f       	subi	r24, 0xFF	; 255
    9f94:	8d 8f       	std	Y+29, r24	; 0x1d
    9f96:	02 c0       	rjmp	.+4      	; 0x9f9c <xQueueReceiveFromISR+0x74>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    9f98:	80 e0       	ldi	r24, 0x00	; 0
    9f9a:	01 c0       	rjmp	.+2      	; 0x9f9e <xQueueReceiveFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    9f9c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    9f9e:	df 91       	pop	r29
    9fa0:	cf 91       	pop	r28
    9fa2:	1f 91       	pop	r17
    9fa4:	0f 91       	pop	r16
    9fa6:	08 95       	ret

00009fa8 <uxQueueMessagesWaiting>:

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    9fa8:	0f b6       	in	r0, 0x3f	; 63
    9faa:	f8 94       	cli
    9fac:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    9fae:	fc 01       	movw	r30, r24
    9fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9fb2:	0f 90       	pop	r0
    9fb4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    9fb6:	08 95       	ret

00009fb8 <uxQueueMessagesWaitingFromISR>:

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    9fb8:	fc 01       	movw	r30, r24
    9fba:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    9fbc:	08 95       	ret

00009fbe <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    9fbe:	cf 93       	push	r28
    9fc0:	df 93       	push	r29
    9fc2:	ec 01       	movw	r28, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    9fc4:	88 81       	ld	r24, Y
    9fc6:	99 81       	ldd	r25, Y+1	; 0x01
    9fc8:	0e 94 8d 52 	call	0xa51a	; 0xa51a <vPortFree>
	vPortFree( pxQueue );
    9fcc:	ce 01       	movw	r24, r28
    9fce:	0e 94 8d 52 	call	0xa51a	; 0xa51a <vPortFree>
}
    9fd2:	df 91       	pop	r29
    9fd4:	cf 91       	pop	r28
    9fd6:	08 95       	ret

00009fd8 <xQueueIsQueueEmptyFromISR>:

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    9fd8:	fc 01       	movw	r30, r24
    9fda:	92 8d       	ldd	r25, Z+26	; 0x1a
    9fdc:	81 e0       	ldi	r24, 0x01	; 1
    9fde:	91 11       	cpse	r25, r1
    9fe0:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    9fe2:	08 95       	ret

00009fe4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    9fe4:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    9fe6:	22 8d       	ldd	r18, Z+26	; 0x1a
    9fe8:	81 e0       	ldi	r24, 0x01	; 1
    9fea:	93 8d       	ldd	r25, Z+27	; 0x1b
    9fec:	29 13       	cpse	r18, r25
    9fee:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    9ff0:	08 95       	ret

00009ff2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    9ff2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    9ff4:	03 96       	adiw	r24, 0x03	; 3
    9ff6:	81 83       	std	Z+1, r24	; 0x01
    9ff8:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    9ffa:	2f ef       	ldi	r18, 0xFF	; 255
    9ffc:	3f ef       	ldi	r19, 0xFF	; 255
    9ffe:	23 83       	std	Z+3, r18	; 0x03
    a000:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    a002:	85 83       	std	Z+5, r24	; 0x05
    a004:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    a006:	87 83       	std	Z+7, r24	; 0x07
    a008:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = 0;
    a00a:	10 82       	st	Z, r1
}
    a00c:	08 95       	ret

0000a00e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    a00e:	fc 01       	movw	r30, r24
    a010:	10 86       	std	Z+8, r1	; 0x08
    a012:	11 86       	std	Z+9, r1	; 0x09
}
    a014:	08 95       	ret

0000a016 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    a016:	cf 93       	push	r28
    a018:	df 93       	push	r29
    a01a:	fc 01       	movw	r30, r24
    a01c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    a01e:	21 81       	ldd	r18, Z+1	; 0x01
    a020:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    a022:	e9 01       	movw	r28, r18
    a024:	8a 81       	ldd	r24, Y+2	; 0x02
    a026:	9b 81       	ldd	r25, Y+3	; 0x03
    a028:	12 96       	adiw	r26, 0x02	; 2
    a02a:	8d 93       	st	X+, r24
    a02c:	9c 93       	st	X, r25
    a02e:	13 97       	sbiw	r26, 0x03	; 3
	pxNewListItem->pxPrevious = pxList->pxIndex;
    a030:	14 96       	adiw	r26, 0x04	; 4
    a032:	2d 93       	st	X+, r18
    a034:	3c 93       	st	X, r19
    a036:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a038:	8a 81       	ldd	r24, Y+2	; 0x02
    a03a:	9b 81       	ldd	r25, Y+3	; 0x03
    a03c:	ec 01       	movw	r28, r24
    a03e:	6c 83       	std	Y+4, r22	; 0x04
    a040:	7d 83       	std	Y+5, r23	; 0x05
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    a042:	e9 01       	movw	r28, r18
    a044:	6a 83       	std	Y+2, r22	; 0x02
    a046:	7b 83       	std	Y+3, r23	; 0x03
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    a048:	61 83       	std	Z+1, r22	; 0x01
    a04a:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a04c:	18 96       	adiw	r26, 0x08	; 8
    a04e:	ed 93       	st	X+, r30
    a050:	fc 93       	st	X, r31
    a052:	19 97       	sbiw	r26, 0x09	; 9

	( pxList->uxNumberOfItems )++;
    a054:	80 81       	ld	r24, Z
    a056:	8f 5f       	subi	r24, 0xFF	; 255
    a058:	80 83       	st	Z, r24
}
    a05a:	df 91       	pop	r29
    a05c:	cf 91       	pop	r28
    a05e:	08 95       	ret

0000a060 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    a060:	cf 93       	push	r28
    a062:	df 93       	push	r29
    a064:	ac 01       	movw	r20, r24
    a066:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    a068:	88 81       	ld	r24, Y
    a06a:	99 81       	ldd	r25, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    a06c:	2f ef       	ldi	r18, 0xFF	; 255
    a06e:	8f 3f       	cpi	r24, 0xFF	; 255
    a070:	92 07       	cpc	r25, r18
    a072:	21 f4       	brne	.+8      	; 0xa07c <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    a074:	fa 01       	movw	r30, r20
    a076:	a7 81       	ldd	r26, Z+7	; 0x07
    a078:	b0 85       	ldd	r27, Z+8	; 0x08
    a07a:	11 c0       	rjmp	.+34     	; 0xa09e <vListInsert+0x3e>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    a07c:	da 01       	movw	r26, r20
    a07e:	13 96       	adiw	r26, 0x03	; 3
    a080:	04 c0       	rjmp	.+8      	; 0xa08a <vListInsert+0x2a>
    a082:	12 96       	adiw	r26, 0x02	; 2
    a084:	0d 90       	ld	r0, X+
    a086:	bc 91       	ld	r27, X
    a088:	a0 2d       	mov	r26, r0
    a08a:	12 96       	adiw	r26, 0x02	; 2
    a08c:	2d 91       	ld	r18, X+
    a08e:	3c 91       	ld	r19, X
    a090:	13 97       	sbiw	r26, 0x03	; 3
    a092:	f9 01       	movw	r30, r18
    a094:	20 81       	ld	r18, Z
    a096:	31 81       	ldd	r19, Z+1	; 0x01
    a098:	82 17       	cp	r24, r18
    a09a:	93 07       	cpc	r25, r19
    a09c:	90 f7       	brcc	.-28     	; 0xa082 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    a09e:	12 96       	adiw	r26, 0x02	; 2
    a0a0:	8d 91       	ld	r24, X+
    a0a2:	9c 91       	ld	r25, X
    a0a4:	13 97       	sbiw	r26, 0x03	; 3
    a0a6:	8a 83       	std	Y+2, r24	; 0x02
    a0a8:	9b 83       	std	Y+3, r25	; 0x03
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a0aa:	fc 01       	movw	r30, r24
    a0ac:	c4 83       	std	Z+4, r28	; 0x04
    a0ae:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    a0b0:	ac 83       	std	Y+4, r26	; 0x04
    a0b2:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    a0b4:	12 96       	adiw	r26, 0x02	; 2
    a0b6:	cd 93       	st	X+, r28
    a0b8:	dc 93       	st	X, r29
    a0ba:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a0bc:	48 87       	std	Y+8, r20	; 0x08
    a0be:	59 87       	std	Y+9, r21	; 0x09

	( pxList->uxNumberOfItems )++;
    a0c0:	fa 01       	movw	r30, r20
    a0c2:	80 81       	ld	r24, Z
    a0c4:	8f 5f       	subi	r24, 0xFF	; 255
    a0c6:	80 83       	st	Z, r24
}
    a0c8:	df 91       	pop	r29
    a0ca:	cf 91       	pop	r28
    a0cc:	08 95       	ret

0000a0ce <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    a0ce:	cf 93       	push	r28
    a0d0:	df 93       	push	r29
    a0d2:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    a0d4:	a2 81       	ldd	r26, Z+2	; 0x02
    a0d6:	b3 81       	ldd	r27, Z+3	; 0x03
    a0d8:	84 81       	ldd	r24, Z+4	; 0x04
    a0da:	95 81       	ldd	r25, Z+5	; 0x05
    a0dc:	14 96       	adiw	r26, 0x04	; 4
    a0de:	8d 93       	st	X+, r24
    a0e0:	9c 93       	st	X, r25
    a0e2:	15 97       	sbiw	r26, 0x05	; 5
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    a0e4:	c4 81       	ldd	r28, Z+4	; 0x04
    a0e6:	d5 81       	ldd	r29, Z+5	; 0x05
    a0e8:	aa 83       	std	Y+2, r26	; 0x02
    a0ea:	bb 83       	std	Y+3, r27	; 0x03
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    a0ec:	a0 85       	ldd	r26, Z+8	; 0x08
    a0ee:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    a0f0:	11 96       	adiw	r26, 0x01	; 1
    a0f2:	8d 91       	ld	r24, X+
    a0f4:	9c 91       	ld	r25, X
    a0f6:	12 97       	sbiw	r26, 0x02	; 2
    a0f8:	8e 17       	cp	r24, r30
    a0fa:	9f 07       	cpc	r25, r31
    a0fc:	21 f4       	brne	.+8      	; 0xa106 <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    a0fe:	11 96       	adiw	r26, 0x01	; 1
    a100:	cd 93       	st	X+, r28
    a102:	dc 93       	st	X, r29
    a104:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    a106:	10 86       	std	Z+8, r1	; 0x08
    a108:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    a10a:	8c 91       	ld	r24, X
    a10c:	81 50       	subi	r24, 0x01	; 1
    a10e:	8c 93       	st	X, r24
}
    a110:	df 91       	pop	r29
    a112:	cf 91       	pop	r28
    a114:	08 95       	ret

0000a116 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    a116:	bf 92       	push	r11
    a118:	cf 92       	push	r12
    a11a:	df 92       	push	r13
    a11c:	ef 92       	push	r14
    a11e:	ff 92       	push	r15
    a120:	0f 93       	push	r16
    a122:	1f 93       	push	r17
    a124:	cf 93       	push	r28
    a126:	df 93       	push	r29
    a128:	6c 01       	movw	r12, r24
    a12a:	b4 2e       	mov	r11, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    a12c:	8a e1       	ldi	r24, 0x1A	; 26
    a12e:	90 e0       	ldi	r25, 0x00	; 0
    a130:	0e 94 64 52 	call	0xa4c8	; 0xa4c8 <pvPortMalloc>
    a134:	e8 2e       	mov	r14, r24
    a136:	e7 01       	movw	r28, r14
    a138:	7e 01       	movw	r14, r28
    a13a:	f9 2e       	mov	r15, r25
    a13c:	e7 01       	movw	r28, r14
	if( pxCoRoutine )
    a13e:	20 97       	sbiw	r28, 0x00	; 0
    a140:	09 f4       	brne	.+2      	; 0xa144 <xCoRoutineCreate+0x2e>
    a142:	54 c0       	rjmp	.+168    	; 0xa1ec <xCoRoutineCreate+0xd6>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    a144:	80 91 de 25 	lds	r24, 0x25DE
    a148:	90 91 df 25 	lds	r25, 0x25DF
    a14c:	00 97       	sbiw	r24, 0x00	; 0
    a14e:	01 f5       	brne	.+64     	; 0xa190 <xCoRoutineCreate+0x7a>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    a150:	e0 92 de 25 	sts	0x25DE, r14
    a154:	f0 92 df 25 	sts	0x25DF, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    a158:	8a ee       	ldi	r24, 0xEA	; 234
    a15a:	95 e2       	ldi	r25, 0x25	; 37
    a15c:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    a160:	5d ef       	ldi	r21, 0xFD	; 253
    a162:	e5 2e       	mov	r14, r21
    a164:	55 e2       	ldi	r21, 0x25	; 37
    a166:	f5 2e       	mov	r15, r21
    a168:	c7 01       	movw	r24, r14
    a16a:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    a16e:	06 e0       	ldi	r16, 0x06	; 6
    a170:	16 e2       	ldi	r17, 0x26	; 38
    a172:	c8 01       	movw	r24, r16
    a174:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    a178:	80 ee       	ldi	r24, 0xE0	; 224
    a17a:	95 e2       	ldi	r25, 0x25	; 37
    a17c:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    a180:	e0 92 f9 25 	sts	0x25F9, r14
    a184:	f0 92 fa 25 	sts	0x25FA, r15
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    a188:	00 93 fb 25 	sts	0x25FB, r16
    a18c:	10 93 fc 25 	sts	0x25FC, r17
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    a190:	18 8e       	std	Y+24, r1	; 0x18
    a192:	19 8e       	std	Y+25, r1	; 0x19
		pxCoRoutine->uxPriority = uxPriority;
    a194:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    a196:	bf 8a       	std	Y+23, r11	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    a198:	fe 01       	movw	r30, r28
    a19a:	c1 92       	st	Z+, r12
    a19c:	d1 92       	st	Z+, r13
    a19e:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    a1a0:	cf 01       	movw	r24, r30
    a1a2:	0e 94 07 50 	call	0xa00e	; 0xa00e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    a1a6:	ce 01       	movw	r24, r28
    a1a8:	0c 96       	adiw	r24, 0x0c	; 12
    a1aa:	0e 94 07 50 	call	0xa00e	; 0xa00e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    a1ae:	c8 87       	std	Y+8, r28	; 0x08
    a1b0:	d9 87       	std	Y+9, r29	; 0x09
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    a1b2:	ca 8b       	std	Y+18, r28	; 0x12
    a1b4:	db 8b       	std	Y+19, r29	; 0x13
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    a1b6:	83 e0       	ldi	r24, 0x03	; 3
    a1b8:	90 e0       	ldi	r25, 0x00	; 0
    a1ba:	8c 87       	std	Y+12, r24	; 0x0c
    a1bc:	9d 87       	std	Y+13, r25	; 0x0d
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    a1be:	2e 89       	ldd	r18, Y+22	; 0x16
    a1c0:	80 91 e9 25 	lds	r24, 0x25E9
    a1c4:	82 17       	cp	r24, r18
    a1c6:	10 f4       	brcc	.+4      	; 0xa1cc <xCoRoutineCreate+0xb6>
    a1c8:	20 93 e9 25 	sts	0x25E9, r18
    a1cc:	30 e0       	ldi	r19, 0x00	; 0
    a1ce:	c9 01       	movw	r24, r18
    a1d0:	43 e0       	ldi	r20, 0x03	; 3
    a1d2:	88 0f       	add	r24, r24
    a1d4:	99 1f       	adc	r25, r25
    a1d6:	4a 95       	dec	r20
    a1d8:	e1 f7       	brne	.-8      	; 0xa1d2 <xCoRoutineCreate+0xbc>
    a1da:	82 0f       	add	r24, r18
    a1dc:	93 1f       	adc	r25, r19
    a1de:	86 51       	subi	r24, 0x16	; 22
    a1e0:	9a 4d       	sbci	r25, 0xDA	; 218
    a1e2:	b8 01       	movw	r22, r16
    a1e4:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>

		xReturn = pdPASS;
    a1e8:	81 e0       	ldi	r24, 0x01	; 1
    a1ea:	01 c0       	rjmp	.+2      	; 0xa1ee <xCoRoutineCreate+0xd8>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    a1ec:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    a1ee:	df 91       	pop	r29
    a1f0:	cf 91       	pop	r28
    a1f2:	1f 91       	pop	r17
    a1f4:	0f 91       	pop	r16
    a1f6:	ff 90       	pop	r15
    a1f8:	ef 90       	pop	r14
    a1fa:	df 90       	pop	r13
    a1fc:	cf 90       	pop	r12
    a1fe:	bf 90       	pop	r11
    a200:	08 95       	ret

0000a202 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    a202:	0f 93       	push	r16
    a204:	1f 93       	push	r17
    a206:	cf 93       	push	r28
    a208:	df 93       	push	r29
    a20a:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    a20c:	00 91 f7 25 	lds	r16, 0x25F7
    a210:	10 91 f8 25 	lds	r17, 0x25F8
    a214:	08 0f       	add	r16, r24
    a216:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a218:	80 91 de 25 	lds	r24, 0x25DE
    a21c:	90 91 df 25 	lds	r25, 0x25DF
    a220:	02 96       	adiw	r24, 0x02	; 2
    a222:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    a226:	60 91 de 25 	lds	r22, 0x25DE
    a22a:	70 91 df 25 	lds	r23, 0x25DF
    a22e:	fb 01       	movw	r30, r22
    a230:	02 83       	std	Z+2, r16	; 0x02
    a232:	13 83       	std	Z+3, r17	; 0x03

	if( xTimeToWake < xCoRoutineTickCount )
    a234:	80 91 f7 25 	lds	r24, 0x25F7
    a238:	90 91 f8 25 	lds	r25, 0x25F8
    a23c:	6e 5f       	subi	r22, 0xFE	; 254
    a23e:	7f 4f       	sbci	r23, 0xFF	; 255
    a240:	08 17       	cp	r16, r24
    a242:	19 07       	cpc	r17, r25
    a244:	28 f4       	brcc	.+10     	; 0xa250 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a246:	80 91 fb 25 	lds	r24, 0x25FB
    a24a:	90 91 fc 25 	lds	r25, 0x25FC
    a24e:	04 c0       	rjmp	.+8      	; 0xa258 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a250:	80 91 f9 25 	lds	r24, 0x25F9
    a254:	90 91 fa 25 	lds	r25, 0x25FA
    a258:	0e 94 30 50 	call	0xa060	; 0xa060 <vListInsert>
	}

	if( pxEventList )
    a25c:	20 97       	sbiw	r28, 0x00	; 0
    a25e:	49 f0       	breq	.+18     	; 0xa272 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    a260:	60 91 de 25 	lds	r22, 0x25DE
    a264:	70 91 df 25 	lds	r23, 0x25DF
    a268:	64 5f       	subi	r22, 0xF4	; 244
    a26a:	7f 4f       	sbci	r23, 0xFF	; 255
    a26c:	ce 01       	movw	r24, r28
    a26e:	0e 94 30 50 	call	0xa060	; 0xa060 <vListInsert>
	}
}
    a272:	df 91       	pop	r29
    a274:	cf 91       	pop	r28
    a276:	1f 91       	pop	r17
    a278:	0f 91       	pop	r16
    a27a:	08 95       	ret

0000a27c <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    a27c:	0f 93       	push	r16
    a27e:	1f 93       	push	r17
    a280:	cf 93       	push	r28
    a282:	df 93       	push	r29
    a284:	2e c0       	rjmp	.+92     	; 0xa2e2 <vCoRoutineSchedule+0x66>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    a286:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    a288:	80 91 e0 25 	lds	r24, 0x25E0
    a28c:	88 23       	and	r24, r24
    a28e:	39 f0       	breq	.+14     	; 0xa29e <vCoRoutineSchedule+0x22>
    a290:	e0 91 e5 25 	lds	r30, 0x25E5
    a294:	f0 91 e6 25 	lds	r31, 0x25E6
    a298:	c6 81       	ldd	r28, Z+6	; 0x06
    a29a:	d7 81       	ldd	r29, Z+7	; 0x07
    a29c:	02 c0       	rjmp	.+4      	; 0xa2a2 <vCoRoutineSchedule+0x26>
    a29e:	c0 e0       	ldi	r28, 0x00	; 0
    a2a0:	d0 e0       	ldi	r29, 0x00	; 0
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a2a2:	ce 01       	movw	r24, r28
    a2a4:	0c 96       	adiw	r24, 0x0c	; 12
    a2a6:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
		}
		portENABLE_INTERRUPTS();
    a2aa:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    a2ac:	8e 01       	movw	r16, r28
    a2ae:	0e 5f       	subi	r16, 0xFE	; 254
    a2b0:	1f 4f       	sbci	r17, 0xFF	; 255
    a2b2:	c8 01       	movw	r24, r16
    a2b4:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    a2b8:	2e 89       	ldd	r18, Y+22	; 0x16
    a2ba:	80 91 e9 25 	lds	r24, 0x25E9
    a2be:	82 17       	cp	r24, r18
    a2c0:	10 f4       	brcc	.+4      	; 0xa2c6 <vCoRoutineSchedule+0x4a>
    a2c2:	20 93 e9 25 	sts	0x25E9, r18
    a2c6:	30 e0       	ldi	r19, 0x00	; 0
    a2c8:	c9 01       	movw	r24, r18
    a2ca:	f3 e0       	ldi	r31, 0x03	; 3
    a2cc:	88 0f       	add	r24, r24
    a2ce:	99 1f       	adc	r25, r25
    a2d0:	fa 95       	dec	r31
    a2d2:	e1 f7       	brne	.-8      	; 0xa2cc <vCoRoutineSchedule+0x50>
    a2d4:	82 0f       	add	r24, r18
    a2d6:	93 1f       	adc	r25, r19
    a2d8:	86 51       	subi	r24, 0x16	; 22
    a2da:	9a 4d       	sbci	r25, 0xDA	; 218
    a2dc:	b8 01       	movw	r22, r16
    a2de:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    a2e2:	80 91 e0 25 	lds	r24, 0x25E0
    a2e6:	88 23       	and	r24, r24
    a2e8:	71 f6       	brne	.-100    	; 0xa286 <vCoRoutineSchedule+0xa>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    a2ea:	0e 94 d8 48 	call	0x91b0	; 0x91b0 <xTaskGetTickCount>
    a2ee:	20 91 f3 25 	lds	r18, 0x25F3
    a2f2:	30 91 f4 25 	lds	r19, 0x25F4
    a2f6:	82 1b       	sub	r24, r18
    a2f8:	93 0b       	sbc	r25, r19
    a2fa:	80 93 f5 25 	sts	0x25F5, r24
    a2fe:	90 93 f6 25 	sts	0x25F6, r25
    a302:	5b c0       	rjmp	.+182    	; 0xa3ba <vCoRoutineSchedule+0x13e>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    a304:	01 96       	adiw	r24, 0x01	; 1
    a306:	80 93 f7 25 	sts	0x25F7, r24
    a30a:	90 93 f8 25 	sts	0x25F8, r25
		xPassedTicks--;
    a30e:	21 50       	subi	r18, 0x01	; 1
    a310:	30 40       	sbci	r19, 0x00	; 0
    a312:	20 93 f5 25 	sts	0x25F5, r18
    a316:	30 93 f6 25 	sts	0x25F6, r19

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    a31a:	00 97       	sbiw	r24, 0x00	; 0
    a31c:	09 f0       	breq	.+2      	; 0xa320 <vCoRoutineSchedule+0xa4>
    a31e:	3f c0       	rjmp	.+126    	; 0xa39e <vCoRoutineSchedule+0x122>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    a320:	80 91 f9 25 	lds	r24, 0x25F9
    a324:	90 91 fa 25 	lds	r25, 0x25FA
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    a328:	20 91 fb 25 	lds	r18, 0x25FB
    a32c:	30 91 fc 25 	lds	r19, 0x25FC
    a330:	20 93 f9 25 	sts	0x25F9, r18
    a334:	30 93 fa 25 	sts	0x25FA, r19
			pxOverflowDelayedCoRoutineList = pxTemp;
    a338:	80 93 fb 25 	sts	0x25FB, r24
    a33c:	90 93 fc 25 	sts	0x25FC, r25
    a340:	2e c0       	rjmp	.+92     	; 0xa39e <vCoRoutineSchedule+0x122>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    a342:	20 91 f7 25 	lds	r18, 0x25F7
    a346:	30 91 f8 25 	lds	r19, 0x25F8
    a34a:	8a 81       	ldd	r24, Y+2	; 0x02
    a34c:	9b 81       	ldd	r25, Y+3	; 0x03
    a34e:	28 17       	cp	r18, r24
    a350:	39 07       	cpc	r19, r25
    a352:	98 f1       	brcs	.+102    	; 0xa3ba <vCoRoutineSchedule+0x13e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    a354:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    a356:	8e 01       	movw	r16, r28
    a358:	0e 5f       	subi	r16, 0xFE	; 254
    a35a:	1f 4f       	sbci	r17, 0xFF	; 255
    a35c:	c8 01       	movw	r24, r16
    a35e:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    a362:	8c 89       	ldd	r24, Y+20	; 0x14
    a364:	9d 89       	ldd	r25, Y+21	; 0x15
    a366:	00 97       	sbiw	r24, 0x00	; 0
    a368:	21 f0       	breq	.+8      	; 0xa372 <vCoRoutineSchedule+0xf6>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    a36a:	ce 01       	movw	r24, r28
    a36c:	0c 96       	adiw	r24, 0x0c	; 12
    a36e:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    a372:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    a374:	2e 89       	ldd	r18, Y+22	; 0x16
    a376:	80 91 e9 25 	lds	r24, 0x25E9
    a37a:	82 17       	cp	r24, r18
    a37c:	10 f4       	brcc	.+4      	; 0xa382 <vCoRoutineSchedule+0x106>
    a37e:	20 93 e9 25 	sts	0x25E9, r18
    a382:	30 e0       	ldi	r19, 0x00	; 0
    a384:	c9 01       	movw	r24, r18
    a386:	e3 e0       	ldi	r30, 0x03	; 3
    a388:	88 0f       	add	r24, r24
    a38a:	99 1f       	adc	r25, r25
    a38c:	ea 95       	dec	r30
    a38e:	e1 f7       	brne	.-8      	; 0xa388 <vCoRoutineSchedule+0x10c>
    a390:	82 0f       	add	r24, r18
    a392:	93 1f       	adc	r25, r19
    a394:	86 51       	subi	r24, 0x16	; 22
    a396:	9a 4d       	sbci	r25, 0xDA	; 218
    a398:	b8 01       	movw	r22, r16
    a39a:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    a39e:	e0 91 f9 25 	lds	r30, 0x25F9
    a3a2:	f0 91 fa 25 	lds	r31, 0x25FA
    a3a6:	80 81       	ld	r24, Z
    a3a8:	88 23       	and	r24, r24
    a3aa:	39 f0       	breq	.+14     	; 0xa3ba <vCoRoutineSchedule+0x13e>
    a3ac:	05 80       	ldd	r0, Z+5	; 0x05
    a3ae:	f6 81       	ldd	r31, Z+6	; 0x06
    a3b0:	e0 2d       	mov	r30, r0
    a3b2:	c6 81       	ldd	r28, Z+6	; 0x06
    a3b4:	d7 81       	ldd	r29, Z+7	; 0x07
    a3b6:	20 97       	sbiw	r28, 0x00	; 0
    a3b8:	21 f6       	brne	.-120    	; 0xa342 <vCoRoutineSchedule+0xc6>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    a3ba:	20 91 f5 25 	lds	r18, 0x25F5
    a3be:	30 91 f6 25 	lds	r19, 0x25F6
    a3c2:	80 91 f7 25 	lds	r24, 0x25F7
    a3c6:	90 91 f8 25 	lds	r25, 0x25F8
    a3ca:	21 15       	cp	r18, r1
    a3cc:	31 05       	cpc	r19, r1
    a3ce:	09 f0       	breq	.+2      	; 0xa3d2 <vCoRoutineSchedule+0x156>
    a3d0:	99 cf       	rjmp	.-206    	; 0xa304 <vCoRoutineSchedule+0x88>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    a3d2:	80 93 f3 25 	sts	0x25F3, r24
    a3d6:	90 93 f4 25 	sts	0x25F4, r25
    a3da:	40 91 e9 25 	lds	r20, 0x25E9

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a3de:	06 c0       	rjmp	.+12     	; 0xa3ec <vCoRoutineSchedule+0x170>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    a3e0:	44 23       	and	r20, r20
    a3e2:	19 f4       	brne	.+6      	; 0xa3ea <vCoRoutineSchedule+0x16e>
    a3e4:	10 92 e9 25 	sts	0x25E9, r1
    a3e8:	40 c0       	rjmp	.+128    	; 0xa46a <vCoRoutineSchedule+0x1ee>
    a3ea:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a3ec:	84 2f       	mov	r24, r20
    a3ee:	90 e0       	ldi	r25, 0x00	; 0
    a3f0:	9c 01       	movw	r18, r24
    a3f2:	73 e0       	ldi	r23, 0x03	; 3
    a3f4:	22 0f       	add	r18, r18
    a3f6:	33 1f       	adc	r19, r19
    a3f8:	7a 95       	dec	r23
    a3fa:	e1 f7       	brne	.-8      	; 0xa3f4 <vCoRoutineSchedule+0x178>
    a3fc:	28 0f       	add	r18, r24
    a3fe:	39 1f       	adc	r19, r25
    a400:	f9 01       	movw	r30, r18
    a402:	e6 51       	subi	r30, 0x16	; 22
    a404:	fa 4d       	sbci	r31, 0xDA	; 218
    a406:	50 81       	ld	r21, Z
    a408:	55 23       	and	r21, r21
    a40a:	51 f3       	breq	.-44     	; 0xa3e0 <vCoRoutineSchedule+0x164>
    a40c:	40 93 e9 25 	sts	0x25E9, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    a410:	a1 81       	ldd	r26, Z+1	; 0x01
    a412:	b2 81       	ldd	r27, Z+2	; 0x02
    a414:	12 96       	adiw	r26, 0x02	; 2
    a416:	0d 90       	ld	r0, X+
    a418:	bc 91       	ld	r27, X
    a41a:	a0 2d       	mov	r26, r0
    a41c:	a1 83       	std	Z+1, r26	; 0x01
    a41e:	b2 83       	std	Z+2, r27	; 0x02
    a420:	23 51       	subi	r18, 0x13	; 19
    a422:	3a 4d       	sbci	r19, 0xDA	; 218
    a424:	a2 17       	cp	r26, r18
    a426:	b3 07       	cpc	r27, r19
    a428:	31 f4       	brne	.+12     	; 0xa436 <vCoRoutineSchedule+0x1ba>
    a42a:	12 96       	adiw	r26, 0x02	; 2
    a42c:	2d 91       	ld	r18, X+
    a42e:	3c 91       	ld	r19, X
    a430:	13 97       	sbiw	r26, 0x03	; 3
    a432:	21 83       	std	Z+1, r18	; 0x01
    a434:	32 83       	std	Z+2, r19	; 0x02
    a436:	fc 01       	movw	r30, r24
    a438:	63 e0       	ldi	r22, 0x03	; 3
    a43a:	ee 0f       	add	r30, r30
    a43c:	ff 1f       	adc	r31, r31
    a43e:	6a 95       	dec	r22
    a440:	e1 f7       	brne	.-8      	; 0xa43a <vCoRoutineSchedule+0x1be>
    a442:	e8 0f       	add	r30, r24
    a444:	f9 1f       	adc	r31, r25
    a446:	e6 51       	subi	r30, 0x16	; 22
    a448:	fa 4d       	sbci	r31, 0xDA	; 218
    a44a:	01 80       	ldd	r0, Z+1	; 0x01
    a44c:	f2 81       	ldd	r31, Z+2	; 0x02
    a44e:	e0 2d       	mov	r30, r0
    a450:	a6 81       	ldd	r26, Z+6	; 0x06
    a452:	b7 81       	ldd	r27, Z+7	; 0x07
    a454:	a0 93 de 25 	sts	0x25DE, r26
    a458:	b0 93 df 25 	sts	0x25DF, r27

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    a45c:	ed 91       	ld	r30, X+
    a45e:	fc 91       	ld	r31, X
    a460:	11 97       	sbiw	r26, 0x01	; 1
    a462:	cd 01       	movw	r24, r26
    a464:	57 96       	adiw	r26, 0x17	; 23
    a466:	6c 91       	ld	r22, X
    a468:	19 95       	eicall

	return;
}
    a46a:	df 91       	pop	r29
    a46c:	cf 91       	pop	r28
    a46e:	1f 91       	pop	r17
    a470:	0f 91       	pop	r16
    a472:	08 95       	ret

0000a474 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    a474:	0f 93       	push	r16
    a476:	1f 93       	push	r17
    a478:	cf 93       	push	r28
    a47a:	df 93       	push	r29
    a47c:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    a47e:	80 81       	ld	r24, Z
    a480:	88 23       	and	r24, r24
    a482:	31 f0       	breq	.+12     	; 0xa490 <xCoRoutineRemoveFromEventList+0x1c>
    a484:	05 80       	ldd	r0, Z+5	; 0x05
    a486:	f6 81       	ldd	r31, Z+6	; 0x06
    a488:	e0 2d       	mov	r30, r0
    a48a:	c6 81       	ldd	r28, Z+6	; 0x06
    a48c:	d7 81       	ldd	r29, Z+7	; 0x07
    a48e:	02 c0       	rjmp	.+4      	; 0xa494 <xCoRoutineRemoveFromEventList+0x20>
    a490:	c0 e0       	ldi	r28, 0x00	; 0
    a492:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a494:	8e 01       	movw	r16, r28
    a496:	04 5f       	subi	r16, 0xF4	; 244
    a498:	1f 4f       	sbci	r17, 0xFF	; 255
    a49a:	c8 01       	movw	r24, r16
    a49c:	0e 94 67 50 	call	0xa0ce	; 0xa0ce <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    a4a0:	80 ee       	ldi	r24, 0xE0	; 224
    a4a2:	95 e2       	ldi	r25, 0x25	; 37
    a4a4:	b8 01       	movw	r22, r16
    a4a6:	0e 94 0b 50 	call	0xa016	; 0xa016 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    a4aa:	e0 91 de 25 	lds	r30, 0x25DE
    a4ae:	f0 91 df 25 	lds	r31, 0x25DF
	{
		xReturn = pdTRUE;
    a4b2:	81 e0       	ldi	r24, 0x01	; 1
    a4b4:	2e 89       	ldd	r18, Y+22	; 0x16
    a4b6:	96 89       	ldd	r25, Z+22	; 0x16
    a4b8:	29 17       	cp	r18, r25
    a4ba:	08 f4       	brcc	.+2      	; 0xa4be <xCoRoutineRemoveFromEventList+0x4a>
    a4bc:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    a4be:	df 91       	pop	r29
    a4c0:	cf 91       	pop	r28
    a4c2:	1f 91       	pop	r17
    a4c4:	0f 91       	pop	r16
    a4c6:	08 95       	ret

0000a4c8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    a4c8:	ef 92       	push	r14
    a4ca:	ff 92       	push	r15
    a4cc:	0f 93       	push	r16
    a4ce:	1f 93       	push	r17
    a4d0:	cf 93       	push	r28
    a4d2:	df 93       	push	r29
    a4d4:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    a4d6:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    a4da:	c0 91 0f 26 	lds	r28, 0x260F
    a4de:	d0 91 10 26 	lds	r29, 0x2610
    a4e2:	0c 0f       	add	r16, r28
    a4e4:	1d 1f       	adc	r17, r29
    a4e6:	2b e0       	ldi	r18, 0x0B	; 11
    a4e8:	08 3b       	cpi	r16, 0xB8	; 184
    a4ea:	12 07       	cpc	r17, r18
    a4ec:	50 f4       	brcc	.+20     	; 0xa502 <pvPortMalloc+0x3a>
    a4ee:	c0 17       	cp	r28, r16
    a4f0:	d1 07       	cpc	r29, r17
    a4f2:	38 f4       	brcc	.+14     	; 0xa502 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    a4f4:	cf 5e       	subi	r28, 0xEF	; 239
    a4f6:	d9 4d       	sbci	r29, 0xD9	; 217
			xNextFreeByte += xWantedSize;			
    a4f8:	00 93 0f 26 	sts	0x260F, r16
    a4fc:	10 93 10 26 	sts	0x2610, r17
    a500:	02 c0       	rjmp	.+4      	; 0xa506 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    a502:	c0 e0       	ldi	r28, 0x00	; 0
    a504:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    a506:	0e 94 8f 49 	call	0x931e	; 0x931e <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    a50a:	ce 01       	movw	r24, r28
    a50c:	df 91       	pop	r29
    a50e:	cf 91       	pop	r28
    a510:	1f 91       	pop	r17
    a512:	0f 91       	pop	r16
    a514:	ff 90       	pop	r15
    a516:	ef 90       	pop	r14
    a518:	08 95       	ret

0000a51a <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    a51a:	08 95       	ret

0000a51c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    a51c:	10 92 0f 26 	sts	0x260F, r1
    a520:	10 92 10 26 	sts	0x2610, r1
}
    a524:	08 95       	ret

0000a526 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    a526:	28 eb       	ldi	r18, 0xB8	; 184
    a528:	3b e0       	ldi	r19, 0x0B	; 11
    a52a:	80 91 0f 26 	lds	r24, 0x260F
    a52e:	90 91 10 26 	lds	r25, 0x2610
    a532:	28 1b       	sub	r18, r24
    a534:	39 0b       	sbc	r19, r25
}
    a536:	c9 01       	movw	r24, r18
    a538:	08 95       	ret

0000a53a <pxPortInitialiseStack>:
  uint32_t usAddress;
/**
 * Place a few bytes of known values on the bottom of the stack.
 * This is just useful for debugging.
 */ //TODO Adam: zrobi? kompilacj? warunkow? wy??czaj?c? to debugowanie 
  *pxTopOfStack = 0x11;
    a53a:	31 e1       	ldi	r19, 0x11	; 17
    a53c:	fc 01       	movw	r30, r24
    a53e:	30 83       	st	Z, r19
  pxTopOfStack--;
  *pxTopOfStack = 0x22;
    a540:	22 e2       	ldi	r18, 0x22	; 34
    a542:	22 93       	st	-Z, r18
  pxTopOfStack--;
  *pxTopOfStack = 0x33;
    a544:	83 e3       	ldi	r24, 0x33	; 51
    a546:	82 93       	st	-Z, r24
	/* end of original code block */

	/* The way it should be done for xmega with probably  more than 128K program memory.
	 * Warning is OK here - type incompatibility does not matter - usAddress is only
	 * used as temporary storage */
  usAddress = ( uint32_t ) pxCode;
    a548:	88 27       	eor	r24, r24
    a54a:	77 fd       	sbrc	r23, 7
    a54c:	80 95       	com	r24
    a54e:	98 2f       	mov	r25, r24

  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff );
    a550:	62 93       	st	-Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff ); //tu powinno byc chyba 000000FF
	pxTopOfStack--;
	usAddress >>= 8;
#endif*/

  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff ); //tu powinno byc chyba 000000FF
    a552:	72 93       	st	-Z, r23
/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
  portSAVE_CONTEXT places the flags on the stack immediately after r0
  to ensure the interrupts get disabled as soon as possible, and so ensuring
  the stack use is minimal should a context switch interrupt occur. */

  *pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    a554:	12 92       	st	-Z, r1
  pxTopOfStack--;
  *pxTopOfStack = portFLAGS_INT_ENABLED;
    a556:	80 e8       	ldi	r24, 0x80	; 128
    a558:	82 93       	st	-Z, r24
  pxTopOfStack--;


/* Now the remaining registers.   The compiler expects R1 to be 0. */

  *pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    a55a:	12 92       	st	-Z, r1
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    a55c:	82 e0       	ldi	r24, 0x02	; 2
    a55e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    a560:	83 e0       	ldi	r24, 0x03	; 3
    a562:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    a564:	84 e0       	ldi	r24, 0x04	; 4
    a566:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    a568:	85 e0       	ldi	r24, 0x05	; 5
    a56a:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    a56c:	86 e0       	ldi	r24, 0x06	; 6
    a56e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    a570:	87 e0       	ldi	r24, 0x07	; 7
    a572:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    a574:	88 e0       	ldi	r24, 0x08	; 8
    a576:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    a578:	89 e0       	ldi	r24, 0x09	; 9
    a57a:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    a57c:	80 e1       	ldi	r24, 0x10	; 16
    a57e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    a580:	32 93       	st	-Z, r19
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    a582:	82 e1       	ldi	r24, 0x12	; 18
    a584:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    a586:	83 e1       	ldi	r24, 0x13	; 19
    a588:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    a58a:	84 e1       	ldi	r24, 0x14	; 20
    a58c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    a58e:	85 e1       	ldi	r24, 0x15	; 21
    a590:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    a592:	86 e1       	ldi	r24, 0x16	; 22
    a594:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    a596:	87 e1       	ldi	r24, 0x17	; 23
    a598:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    a59a:	88 e1       	ldi	r24, 0x18	; 24
    a59c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    a59e:	89 e1       	ldi	r24, 0x19	; 25
    a5a0:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    a5a2:	80 e2       	ldi	r24, 0x20	; 32
    a5a4:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    a5a6:	81 e2       	ldi	r24, 0x21	; 33
    a5a8:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    a5aa:	22 93       	st	-Z, r18
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    a5ac:	83 e2       	ldi	r24, 0x23	; 35
    a5ae:	82 93       	st	-Z, r24
  pxTopOfStack--;
	/* Place the parameter on the stack in the expected location. */
  usAddress = ( unsigned short ) pvParameters;
  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    a5b0:	42 93       	st	-Z, r20
  pxTopOfStack--;

  usAddress >>= 8;
  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    a5b2:	52 93       	st	-Z, r21
  pxTopOfStack--;

  *pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    a5b4:	86 e2       	ldi	r24, 0x26	; 38
    a5b6:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    a5b8:	87 e2       	ldi	r24, 0x27	; 39
    a5ba:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    a5bc:	88 e2       	ldi	r24, 0x28	; 40
    a5be:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    a5c0:	89 e2       	ldi	r24, 0x29	; 41
    a5c2:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    a5c4:	80 e3       	ldi	r24, 0x30	; 48
    a5c6:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x31;	/* R31 */
    a5c8:	81 e3       	ldi	r24, 0x31	; 49
    a5ca:	82 93       	st	-Z, r24
  pxTopOfStack--;
/* these registers are also part of execution context
 * Corresponing registars are saved and restored in saveCONTEXT and restoreCONTEXT
 * TODO  See datasheet for explanation
 */
  *pxTopOfStack = ( portSTACK_TYPE ) 0x38;	/* 38 RAMPD */
    a5cc:	88 e3       	ldi	r24, 0x38	; 56
    a5ce:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x39;	/* 39 RAMPX */
    a5d0:	89 e3       	ldi	r24, 0x39	; 57
    a5d2:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3a;	/* 3a RAMPY */
    a5d4:	8a e3       	ldi	r24, 0x3A	; 58
    a5d6:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3b;	/* 3b RAMPZ */
    a5d8:	8b e3       	ldi	r24, 0x3B	; 59
    a5da:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3c;	/* 3c EIND */
    a5dc:	8c e3       	ldi	r24, 0x3C	; 60
    a5de:	82 93       	st	-Z, r24
  pxTopOfStack--;
    a5e0:	9f 01       	movw	r18, r30
    a5e2:	21 50       	subi	r18, 0x01	; 1
    a5e4:	30 40       	sbci	r19, 0x00	; 0

/*lint +e950 +e611 +e923 */

  return pxTopOfStack;
}
    a5e6:	c9 01       	movw	r24, r18
    a5e8:	08 95       	ret

0000a5ea <xPortStartScheduler>:
0110 DIV256 Prescaler clk/256
0111 DIV1024 Prescaler clk/1024
1xxx EVCHn event chanerl n, n=[0...7]
*/
///select the clock source and pre-scale by 64	
  TCC0.CTRLA= ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_DIV64_gc;
    a5ea:	e0 e0       	ldi	r30, 0x00	; 0
    a5ec:	f8 e0       	ldi	r31, 0x08	; 8
    a5ee:	80 81       	ld	r24, Z
    a5f0:	80 7f       	andi	r24, 0xF0	; 240
    a5f2:	85 60       	ori	r24, 0x05	; 5
    a5f4:	80 83       	st	Z, r24
  TC_CLKSEL_EVCH5_gc =   (0x0D<<0),   // Event Channel 5 
  TC_CLKSEL_EVCH6_gc =   (0x0E<<0),   // Event Channel 6 
  TC_CLKSEL_EVCH7_gc =   (0x0F<<0),   // Event Channel 7 
*/
/// set period of counter
  TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ/64-1; // tu zmienic 16Mhz/1000/
    a5f6:	89 ef       	ldi	r24, 0xF9	; 249
    a5f8:	90 e0       	ldi	r25, 0x00	; 0
    a5fa:	86 a3       	std	Z+38, r24	; 0x26
    a5fc:	97 a3       	std	Z+39, r25	; 0x27
	+---+---+---+---+---+---+---+---+
	|    PER [7:0]                  | 
	+---+---+---+---+---+---+---+---+
*/
/// enable interrupt and set low level	
  TCC0.INTCTRLA = ( TCC0.INTCTRLA & ~TC0_OVFINTLVL_gm ) | TC_OVFINTLVL_LO_gc;
    a5fe:	86 81       	ldd	r24, Z+6	; 0x06
    a600:	8c 7f       	andi	r24, 0xFC	; 252
    a602:	81 60       	ori	r24, 0x01	; 1
    a604:	86 83       	std	Z+6, r24	; 0x06
+---+---+---+---+--------+--------+--------+--------+
| - | - | - | - | ERRINTLVL[1:0]  | OVFINTLVL [1:0] |
+---+---+---+---+--------+--------+--------+--------+
*/
/// enable low level interrupts   
  PMIC.CTRL |= PMIC_LOLVLEN_bm;
    a606:	e0 ea       	ldi	r30, 0xA0	; 160
    a608:	f0 e0       	ldi	r31, 0x00	; 0
    a60a:	82 81       	ldd	r24, Z+2	; 0x02
    a60c:	81 60       	ori	r24, 0x01	; 1
    a60e:	82 83       	std	Z+2, r24	; 0x02
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();


	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    a610:	a0 91 55 25 	lds	r26, 0x2555
    a614:	b0 91 56 25 	lds	r27, 0x2556
    a618:	cd 91       	ld	r28, X+
    a61a:	cd bf       	out	0x3d, r28	; 61
    a61c:	dd 91       	ld	r29, X+
    a61e:	de bf       	out	0x3e, r29	; 62
    a620:	0f 91       	pop	r16
    a622:	0c bf       	out	0x3c, r16	; 60
    a624:	0f 91       	pop	r16
    a626:	0b bf       	out	0x3b, r16	; 59
    a628:	0f 91       	pop	r16
    a62a:	0a bf       	out	0x3a, r16	; 58
    a62c:	0f 91       	pop	r16
    a62e:	09 bf       	out	0x39, r16	; 57
    a630:	0f 91       	pop	r16
    a632:	08 bf       	out	0x38, r16	; 56
    a634:	ff 91       	pop	r31
    a636:	ef 91       	pop	r30
    a638:	df 91       	pop	r29
    a63a:	cf 91       	pop	r28
    a63c:	bf 91       	pop	r27
    a63e:	af 91       	pop	r26
    a640:	9f 91       	pop	r25
    a642:	8f 91       	pop	r24
    a644:	7f 91       	pop	r23
    a646:	6f 91       	pop	r22
    a648:	5f 91       	pop	r21
    a64a:	4f 91       	pop	r20
    a64c:	3f 91       	pop	r19
    a64e:	2f 91       	pop	r18
    a650:	1f 91       	pop	r17
    a652:	0f 91       	pop	r16
    a654:	ff 90       	pop	r15
    a656:	ef 90       	pop	r14
    a658:	df 90       	pop	r13
    a65a:	cf 90       	pop	r12
    a65c:	bf 90       	pop	r11
    a65e:	af 90       	pop	r10
    a660:	9f 90       	pop	r9
    a662:	8f 90       	pop	r8
    a664:	7f 90       	pop	r7
    a666:	6f 90       	pop	r6
    a668:	5f 90       	pop	r5
    a66a:	4f 90       	pop	r4
    a66c:	3f 90       	pop	r3
    a66e:	2f 90       	pop	r2
    a670:	1f 90       	pop	r1
    a672:	0f 90       	pop	r0
    a674:	0f be       	out	0x3f, r0	; 63
    a676:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    a678:	08 95       	ret


	/* Should not get here. */
	return pdTRUE;
}
    a67a:	81 e0       	ldi	r24, 0x01	; 1
    a67c:	08 95       	ret

0000a67e <vPortEndScheduler>:
void vPortEndScheduler( void )
{
/* 
 * It is unlikely that the AVR port will get stopped.  If required simply
 * disable the tick interrupt here. */
}
    a67e:	08 95       	ret

0000a680 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
  portSAVE_CONTEXT();
    a680:	0f 92       	push	r0
    a682:	0f b6       	in	r0, 0x3f	; 63
    a684:	f8 94       	cli
    a686:	0f 92       	push	r0
    a688:	1f 92       	push	r1
    a68a:	11 24       	eor	r1, r1
    a68c:	2f 92       	push	r2
    a68e:	3f 92       	push	r3
    a690:	4f 92       	push	r4
    a692:	5f 92       	push	r5
    a694:	6f 92       	push	r6
    a696:	7f 92       	push	r7
    a698:	8f 92       	push	r8
    a69a:	9f 92       	push	r9
    a69c:	af 92       	push	r10
    a69e:	bf 92       	push	r11
    a6a0:	cf 92       	push	r12
    a6a2:	df 92       	push	r13
    a6a4:	ef 92       	push	r14
    a6a6:	ff 92       	push	r15
    a6a8:	0f 93       	push	r16
    a6aa:	1f 93       	push	r17
    a6ac:	2f 93       	push	r18
    a6ae:	3f 93       	push	r19
    a6b0:	4f 93       	push	r20
    a6b2:	5f 93       	push	r21
    a6b4:	6f 93       	push	r22
    a6b6:	7f 93       	push	r23
    a6b8:	8f 93       	push	r24
    a6ba:	9f 93       	push	r25
    a6bc:	af 93       	push	r26
    a6be:	bf 93       	push	r27
    a6c0:	cf 93       	push	r28
    a6c2:	df 93       	push	r29
    a6c4:	ef 93       	push	r30
    a6c6:	ff 93       	push	r31
    a6c8:	08 b7       	in	r16, 0x38	; 56
    a6ca:	0f 93       	push	r16
    a6cc:	09 b7       	in	r16, 0x39	; 57
    a6ce:	0f 93       	push	r16
    a6d0:	0a b7       	in	r16, 0x3a	; 58
    a6d2:	0f 93       	push	r16
    a6d4:	0b b7       	in	r16, 0x3b	; 59
    a6d6:	0f 93       	push	r16
    a6d8:	0c b7       	in	r16, 0x3c	; 60
    a6da:	0f 93       	push	r16
    a6dc:	a0 91 55 25 	lds	r26, 0x2555
    a6e0:	b0 91 56 25 	lds	r27, 0x2556
    a6e4:	0d b6       	in	r0, 0x3d	; 61
    a6e6:	0d 92       	st	X+, r0
    a6e8:	0e b6       	in	r0, 0x3e	; 62
    a6ea:	0d 92       	st	X+, r0
  vTaskSwitchContext();
    a6ec:	0e 94 fe 4a 	call	0x95fc	; 0x95fc <vTaskSwitchContext>
  portRESTORE_CONTEXT();
    a6f0:	a0 91 55 25 	lds	r26, 0x2555
    a6f4:	b0 91 56 25 	lds	r27, 0x2556
    a6f8:	cd 91       	ld	r28, X+
    a6fa:	cd bf       	out	0x3d, r28	; 61
    a6fc:	dd 91       	ld	r29, X+
    a6fe:	de bf       	out	0x3e, r29	; 62
    a700:	0f 91       	pop	r16
    a702:	0c bf       	out	0x3c, r16	; 60
    a704:	0f 91       	pop	r16
    a706:	0b bf       	out	0x3b, r16	; 59
    a708:	0f 91       	pop	r16
    a70a:	0a bf       	out	0x3a, r16	; 58
    a70c:	0f 91       	pop	r16
    a70e:	09 bf       	out	0x39, r16	; 57
    a710:	0f 91       	pop	r16
    a712:	08 bf       	out	0x38, r16	; 56
    a714:	ff 91       	pop	r31
    a716:	ef 91       	pop	r30
    a718:	df 91       	pop	r29
    a71a:	cf 91       	pop	r28
    a71c:	bf 91       	pop	r27
    a71e:	af 91       	pop	r26
    a720:	9f 91       	pop	r25
    a722:	8f 91       	pop	r24
    a724:	7f 91       	pop	r23
    a726:	6f 91       	pop	r22
    a728:	5f 91       	pop	r21
    a72a:	4f 91       	pop	r20
    a72c:	3f 91       	pop	r19
    a72e:	2f 91       	pop	r18
    a730:	1f 91       	pop	r17
    a732:	0f 91       	pop	r16
    a734:	ff 90       	pop	r15
    a736:	ef 90       	pop	r14
    a738:	df 90       	pop	r13
    a73a:	cf 90       	pop	r12
    a73c:	bf 90       	pop	r11
    a73e:	af 90       	pop	r10
    a740:	9f 90       	pop	r9
    a742:	8f 90       	pop	r8
    a744:	7f 90       	pop	r7
    a746:	6f 90       	pop	r6
    a748:	5f 90       	pop	r5
    a74a:	4f 90       	pop	r4
    a74c:	3f 90       	pop	r3
    a74e:	2f 90       	pop	r2
    a750:	1f 90       	pop	r1
    a752:	0f 90       	pop	r0
    a754:	0f be       	out	0x3f, r0	; 63
    a756:	0f 90       	pop	r0

  asm volatile ( "ret" );
    a758:	08 95       	ret

0000a75a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
  portSAVE_CONTEXT();
    a75a:	0f 92       	push	r0
    a75c:	0f b6       	in	r0, 0x3f	; 63
    a75e:	f8 94       	cli
    a760:	0f 92       	push	r0
    a762:	1f 92       	push	r1
    a764:	11 24       	eor	r1, r1
    a766:	2f 92       	push	r2
    a768:	3f 92       	push	r3
    a76a:	4f 92       	push	r4
    a76c:	5f 92       	push	r5
    a76e:	6f 92       	push	r6
    a770:	7f 92       	push	r7
    a772:	8f 92       	push	r8
    a774:	9f 92       	push	r9
    a776:	af 92       	push	r10
    a778:	bf 92       	push	r11
    a77a:	cf 92       	push	r12
    a77c:	df 92       	push	r13
    a77e:	ef 92       	push	r14
    a780:	ff 92       	push	r15
    a782:	0f 93       	push	r16
    a784:	1f 93       	push	r17
    a786:	2f 93       	push	r18
    a788:	3f 93       	push	r19
    a78a:	4f 93       	push	r20
    a78c:	5f 93       	push	r21
    a78e:	6f 93       	push	r22
    a790:	7f 93       	push	r23
    a792:	8f 93       	push	r24
    a794:	9f 93       	push	r25
    a796:	af 93       	push	r26
    a798:	bf 93       	push	r27
    a79a:	cf 93       	push	r28
    a79c:	df 93       	push	r29
    a79e:	ef 93       	push	r30
    a7a0:	ff 93       	push	r31
    a7a2:	08 b7       	in	r16, 0x38	; 56
    a7a4:	0f 93       	push	r16
    a7a6:	09 b7       	in	r16, 0x39	; 57
    a7a8:	0f 93       	push	r16
    a7aa:	0a b7       	in	r16, 0x3a	; 58
    a7ac:	0f 93       	push	r16
    a7ae:	0b b7       	in	r16, 0x3b	; 59
    a7b0:	0f 93       	push	r16
    a7b2:	0c b7       	in	r16, 0x3c	; 60
    a7b4:	0f 93       	push	r16
    a7b6:	a0 91 55 25 	lds	r26, 0x2555
    a7ba:	b0 91 56 25 	lds	r27, 0x2556
    a7be:	0d b6       	in	r0, 0x3d	; 61
    a7c0:	0d 92       	st	X+, r0
    a7c2:	0e b6       	in	r0, 0x3e	; 62
    a7c4:	0d 92       	st	X+, r0
  vTaskIncrementTick();
    a7c6:	0e 94 17 49 	call	0x922e	; 0x922e <vTaskIncrementTick>
  vTaskSwitchContext();
    a7ca:	0e 94 fe 4a 	call	0x95fc	; 0x95fc <vTaskSwitchContext>
  portRESTORE_CONTEXT();
    a7ce:	a0 91 55 25 	lds	r26, 0x2555
    a7d2:	b0 91 56 25 	lds	r27, 0x2556
    a7d6:	cd 91       	ld	r28, X+
    a7d8:	cd bf       	out	0x3d, r28	; 61
    a7da:	dd 91       	ld	r29, X+
    a7dc:	de bf       	out	0x3e, r29	; 62
    a7de:	0f 91       	pop	r16
    a7e0:	0c bf       	out	0x3c, r16	; 60
    a7e2:	0f 91       	pop	r16
    a7e4:	0b bf       	out	0x3b, r16	; 59
    a7e6:	0f 91       	pop	r16
    a7e8:	0a bf       	out	0x3a, r16	; 58
    a7ea:	0f 91       	pop	r16
    a7ec:	09 bf       	out	0x39, r16	; 57
    a7ee:	0f 91       	pop	r16
    a7f0:	08 bf       	out	0x38, r16	; 56
    a7f2:	ff 91       	pop	r31
    a7f4:	ef 91       	pop	r30
    a7f6:	df 91       	pop	r29
    a7f8:	cf 91       	pop	r28
    a7fa:	bf 91       	pop	r27
    a7fc:	af 91       	pop	r26
    a7fe:	9f 91       	pop	r25
    a800:	8f 91       	pop	r24
    a802:	7f 91       	pop	r23
    a804:	6f 91       	pop	r22
    a806:	5f 91       	pop	r21
    a808:	4f 91       	pop	r20
    a80a:	3f 91       	pop	r19
    a80c:	2f 91       	pop	r18
    a80e:	1f 91       	pop	r17
    a810:	0f 91       	pop	r16
    a812:	ff 90       	pop	r15
    a814:	ef 90       	pop	r14
    a816:	df 90       	pop	r13
    a818:	cf 90       	pop	r12
    a81a:	bf 90       	pop	r11
    a81c:	af 90       	pop	r10
    a81e:	9f 90       	pop	r9
    a820:	8f 90       	pop	r8
    a822:	7f 90       	pop	r7
    a824:	6f 90       	pop	r6
    a826:	5f 90       	pop	r5
    a828:	4f 90       	pop	r4
    a82a:	3f 90       	pop	r3
    a82c:	2f 90       	pop	r2
    a82e:	1f 90       	pop	r1
    a830:	0f 90       	pop	r0
    a832:	0f be       	out	0x3f, r0	; 63
    a834:	0f 90       	pop	r0

  asm volatile ( "ret" );
    a836:	08 95       	ret

0000a838 <__vector_14>:
 * tick count.  We don't need to switch context, this can only be done by
 * manual calls to taskYIELD();
 */
ISR (TCC0_OVF_vect, ISR_NAKED)
{
  vTaskIncrementTick();
    a838:	0e 94 17 49 	call	0x922e	; 0x922e <vTaskIncrementTick>

0000a83c <__udivmodqi4>:
}
    a83c:	99 1b       	sub	r25, r25
    a83e:	79 e0       	ldi	r23, 0x09	; 9
    a840:	04 c0       	rjmp	.+8      	; 0xa84a <__udivmodqi4_ep>

0000a842 <__udivmodqi4_loop>:
    a842:	99 1f       	adc	r25, r25
    a844:	96 17       	cp	r25, r22
    a846:	08 f0       	brcs	.+2      	; 0xa84a <__udivmodqi4_ep>
    a848:	96 1b       	sub	r25, r22

0000a84a <__udivmodqi4_ep>:
    a84a:	88 1f       	adc	r24, r24
    a84c:	7a 95       	dec	r23
    a84e:	c9 f7       	brne	.-14     	; 0xa842 <__udivmodqi4_loop>
    a850:	80 95       	com	r24
    a852:	08 95       	ret

0000a854 <__udivmodhi4>:
    a854:	aa 1b       	sub	r26, r26
    a856:	bb 1b       	sub	r27, r27
    a858:	51 e1       	ldi	r21, 0x11	; 17
    a85a:	07 c0       	rjmp	.+14     	; 0xa86a <__udivmodhi4_ep>

0000a85c <__udivmodhi4_loop>:
    a85c:	aa 1f       	adc	r26, r26
    a85e:	bb 1f       	adc	r27, r27
    a860:	a6 17       	cp	r26, r22
    a862:	b7 07       	cpc	r27, r23
    a864:	10 f0       	brcs	.+4      	; 0xa86a <__udivmodhi4_ep>
    a866:	a6 1b       	sub	r26, r22
    a868:	b7 0b       	sbc	r27, r23

0000a86a <__udivmodhi4_ep>:
    a86a:	88 1f       	adc	r24, r24
    a86c:	99 1f       	adc	r25, r25
    a86e:	5a 95       	dec	r21
    a870:	a9 f7       	brne	.-22     	; 0xa85c <__udivmodhi4_loop>
    a872:	80 95       	com	r24
    a874:	90 95       	com	r25
    a876:	bc 01       	movw	r22, r24
    a878:	cd 01       	movw	r24, r26
    a87a:	08 95       	ret

0000a87c <malloc>:
    a87c:	cf 93       	push	r28
    a87e:	df 93       	push	r29
    a880:	ac 01       	movw	r20, r24
    a882:	82 30       	cpi	r24, 0x02	; 2
    a884:	91 05       	cpc	r25, r1
    a886:	10 f4       	brcc	.+4      	; 0xa88c <malloc+0x10>
    a888:	42 e0       	ldi	r20, 0x02	; 2
    a88a:	50 e0       	ldi	r21, 0x00	; 0
    a88c:	e0 91 3a 33 	lds	r30, 0x333A
    a890:	f0 91 3b 33 	lds	r31, 0x333B
    a894:	20 e0       	ldi	r18, 0x00	; 0
    a896:	30 e0       	ldi	r19, 0x00	; 0
    a898:	a0 e0       	ldi	r26, 0x00	; 0
    a89a:	b0 e0       	ldi	r27, 0x00	; 0
    a89c:	24 c0       	rjmp	.+72     	; 0xa8e6 <malloc+0x6a>
    a89e:	80 81       	ld	r24, Z
    a8a0:	91 81       	ldd	r25, Z+1	; 0x01
    a8a2:	84 17       	cp	r24, r20
    a8a4:	95 07       	cpc	r25, r21
    a8a6:	d0 f0       	brcs	.+52     	; 0xa8dc <malloc+0x60>
    a8a8:	84 17       	cp	r24, r20
    a8aa:	95 07       	cpc	r25, r21
    a8ac:	71 f4       	brne	.+28     	; 0xa8ca <malloc+0x4e>
    a8ae:	82 81       	ldd	r24, Z+2	; 0x02
    a8b0:	93 81       	ldd	r25, Z+3	; 0x03
    a8b2:	10 97       	sbiw	r26, 0x00	; 0
    a8b4:	29 f0       	breq	.+10     	; 0xa8c0 <malloc+0x44>
    a8b6:	12 96       	adiw	r26, 0x02	; 2
    a8b8:	8d 93       	st	X+, r24
    a8ba:	9c 93       	st	X, r25
    a8bc:	13 97       	sbiw	r26, 0x03	; 3
    a8be:	2c c0       	rjmp	.+88     	; 0xa918 <malloc+0x9c>
    a8c0:	80 93 3a 33 	sts	0x333A, r24
    a8c4:	90 93 3b 33 	sts	0x333B, r25
    a8c8:	27 c0       	rjmp	.+78     	; 0xa918 <malloc+0x9c>
    a8ca:	21 15       	cp	r18, r1
    a8cc:	31 05       	cpc	r19, r1
    a8ce:	19 f0       	breq	.+6      	; 0xa8d6 <malloc+0x5a>
    a8d0:	82 17       	cp	r24, r18
    a8d2:	93 07       	cpc	r25, r19
    a8d4:	18 f4       	brcc	.+6      	; 0xa8dc <malloc+0x60>
    a8d6:	9c 01       	movw	r18, r24
    a8d8:	bd 01       	movw	r22, r26
    a8da:	ef 01       	movw	r28, r30
    a8dc:	92 81       	ldd	r25, Z+2	; 0x02
    a8de:	83 81       	ldd	r24, Z+3	; 0x03
    a8e0:	df 01       	movw	r26, r30
    a8e2:	e9 2f       	mov	r30, r25
    a8e4:	f8 2f       	mov	r31, r24
    a8e6:	30 97       	sbiw	r30, 0x00	; 0
    a8e8:	d1 f6       	brne	.-76     	; 0xa89e <malloc+0x22>
    a8ea:	21 15       	cp	r18, r1
    a8ec:	31 05       	cpc	r19, r1
    a8ee:	f9 f0       	breq	.+62     	; 0xa92e <malloc+0xb2>
    a8f0:	c9 01       	movw	r24, r18
    a8f2:	84 1b       	sub	r24, r20
    a8f4:	95 0b       	sbc	r25, r21
    a8f6:	84 30       	cpi	r24, 0x04	; 4
    a8f8:	91 05       	cpc	r25, r1
    a8fa:	80 f4       	brcc	.+32     	; 0xa91c <malloc+0xa0>
    a8fc:	8a 81       	ldd	r24, Y+2	; 0x02
    a8fe:	9b 81       	ldd	r25, Y+3	; 0x03
    a900:	61 15       	cp	r22, r1
    a902:	71 05       	cpc	r23, r1
    a904:	21 f0       	breq	.+8      	; 0xa90e <malloc+0x92>
    a906:	fb 01       	movw	r30, r22
    a908:	82 83       	std	Z+2, r24	; 0x02
    a90a:	93 83       	std	Z+3, r25	; 0x03
    a90c:	04 c0       	rjmp	.+8      	; 0xa916 <malloc+0x9a>
    a90e:	80 93 3a 33 	sts	0x333A, r24
    a912:	90 93 3b 33 	sts	0x333B, r25
    a916:	fe 01       	movw	r30, r28
    a918:	32 96       	adiw	r30, 0x02	; 2
    a91a:	42 c0       	rjmp	.+132    	; 0xa9a0 <malloc+0x124>
    a91c:	fe 01       	movw	r30, r28
    a91e:	e8 0f       	add	r30, r24
    a920:	f9 1f       	adc	r31, r25
    a922:	41 93       	st	Z+, r20
    a924:	51 93       	st	Z+, r21
    a926:	02 97       	sbiw	r24, 0x02	; 2
    a928:	88 83       	st	Y, r24
    a92a:	99 83       	std	Y+1, r25	; 0x01
    a92c:	39 c0       	rjmp	.+114    	; 0xa9a0 <malloc+0x124>
    a92e:	80 91 38 33 	lds	r24, 0x3338
    a932:	90 91 39 33 	lds	r25, 0x3339
    a936:	00 97       	sbiw	r24, 0x00	; 0
    a938:	41 f4       	brne	.+16     	; 0xa94a <malloc+0xce>
    a93a:	80 91 46 25 	lds	r24, 0x2546
    a93e:	90 91 47 25 	lds	r25, 0x2547
    a942:	80 93 38 33 	sts	0x3338, r24
    a946:	90 93 39 33 	sts	0x3339, r25
    a94a:	20 91 44 25 	lds	r18, 0x2544
    a94e:	30 91 45 25 	lds	r19, 0x2545
    a952:	21 15       	cp	r18, r1
    a954:	31 05       	cpc	r19, r1
    a956:	41 f4       	brne	.+16     	; 0xa968 <malloc+0xec>
    a958:	2d b7       	in	r18, 0x3d	; 61
    a95a:	3e b7       	in	r19, 0x3e	; 62
    a95c:	80 91 48 25 	lds	r24, 0x2548
    a960:	90 91 49 25 	lds	r25, 0x2549
    a964:	28 1b       	sub	r18, r24
    a966:	39 0b       	sbc	r19, r25
    a968:	e0 91 38 33 	lds	r30, 0x3338
    a96c:	f0 91 39 33 	lds	r31, 0x3339
    a970:	e2 17       	cp	r30, r18
    a972:	f3 07       	cpc	r31, r19
    a974:	98 f4       	brcc	.+38     	; 0xa99c <malloc+0x120>
    a976:	2e 1b       	sub	r18, r30
    a978:	3f 0b       	sbc	r19, r31
    a97a:	24 17       	cp	r18, r20
    a97c:	35 07       	cpc	r19, r21
    a97e:	70 f0       	brcs	.+28     	; 0xa99c <malloc+0x120>
    a980:	ca 01       	movw	r24, r20
    a982:	02 96       	adiw	r24, 0x02	; 2
    a984:	28 17       	cp	r18, r24
    a986:	39 07       	cpc	r19, r25
    a988:	48 f0       	brcs	.+18     	; 0xa99c <malloc+0x120>
    a98a:	8e 0f       	add	r24, r30
    a98c:	9f 1f       	adc	r25, r31
    a98e:	80 93 38 33 	sts	0x3338, r24
    a992:	90 93 39 33 	sts	0x3339, r25
    a996:	41 93       	st	Z+, r20
    a998:	51 93       	st	Z+, r21
    a99a:	02 c0       	rjmp	.+4      	; 0xa9a0 <malloc+0x124>
    a99c:	e0 e0       	ldi	r30, 0x00	; 0
    a99e:	f0 e0       	ldi	r31, 0x00	; 0
    a9a0:	cf 01       	movw	r24, r30
    a9a2:	df 91       	pop	r29
    a9a4:	cf 91       	pop	r28
    a9a6:	08 95       	ret

0000a9a8 <free>:
    a9a8:	0f 93       	push	r16
    a9aa:	1f 93       	push	r17
    a9ac:	cf 93       	push	r28
    a9ae:	df 93       	push	r29
    a9b0:	9c 01       	movw	r18, r24
    a9b2:	00 97       	sbiw	r24, 0x00	; 0
    a9b4:	09 f4       	brne	.+2      	; 0xa9b8 <free+0x10>
    a9b6:	8c c0       	rjmp	.+280    	; 0xaad0 <free+0x128>
    a9b8:	dc 01       	movw	r26, r24
    a9ba:	12 97       	sbiw	r26, 0x02	; 2
    a9bc:	12 96       	adiw	r26, 0x02	; 2
    a9be:	1d 92       	st	X+, r1
    a9c0:	1c 92       	st	X, r1
    a9c2:	13 97       	sbiw	r26, 0x03	; 3
    a9c4:	60 91 3a 33 	lds	r22, 0x333A
    a9c8:	70 91 3b 33 	lds	r23, 0x333B
    a9cc:	61 15       	cp	r22, r1
    a9ce:	71 05       	cpc	r23, r1
    a9d0:	89 f4       	brne	.+34     	; 0xa9f4 <free+0x4c>
    a9d2:	8d 91       	ld	r24, X+
    a9d4:	9c 91       	ld	r25, X
    a9d6:	11 97       	sbiw	r26, 0x01	; 1
    a9d8:	82 0f       	add	r24, r18
    a9da:	93 1f       	adc	r25, r19
    a9dc:	20 91 38 33 	lds	r18, 0x3338
    a9e0:	30 91 39 33 	lds	r19, 0x3339
    a9e4:	28 17       	cp	r18, r24
    a9e6:	39 07       	cpc	r19, r25
    a9e8:	69 f5       	brne	.+90     	; 0xaa44 <free+0x9c>
    a9ea:	a0 93 38 33 	sts	0x3338, r26
    a9ee:	b0 93 39 33 	sts	0x3339, r27
    a9f2:	6e c0       	rjmp	.+220    	; 0xaad0 <free+0x128>
    a9f4:	fb 01       	movw	r30, r22
    a9f6:	40 e0       	ldi	r20, 0x00	; 0
    a9f8:	50 e0       	ldi	r21, 0x00	; 0
    a9fa:	01 c0       	rjmp	.+2      	; 0xa9fe <free+0x56>
    a9fc:	fc 01       	movw	r30, r24
    a9fe:	ea 17       	cp	r30, r26
    aa00:	fb 07       	cpc	r31, r27
    aa02:	30 f4       	brcc	.+12     	; 0xaa10 <free+0x68>
    aa04:	82 81       	ldd	r24, Z+2	; 0x02
    aa06:	93 81       	ldd	r25, Z+3	; 0x03
    aa08:	af 01       	movw	r20, r30
    aa0a:	00 97       	sbiw	r24, 0x00	; 0
    aa0c:	b9 f7       	brne	.-18     	; 0xa9fc <free+0x54>
    aa0e:	1f c0       	rjmp	.+62     	; 0xaa4e <free+0xa6>
    aa10:	e9 01       	movw	r28, r18
    aa12:	22 97       	sbiw	r28, 0x02	; 2
    aa14:	ea 83       	std	Y+2, r30	; 0x02
    aa16:	fb 83       	std	Y+3, r31	; 0x03
    aa18:	08 81       	ld	r16, Y
    aa1a:	19 81       	ldd	r17, Y+1	; 0x01
    aa1c:	c9 01       	movw	r24, r18
    aa1e:	80 0f       	add	r24, r16
    aa20:	91 1f       	adc	r25, r17
    aa22:	8e 17       	cp	r24, r30
    aa24:	9f 07       	cpc	r25, r31
    aa26:	59 f4       	brne	.+22     	; 0xaa3e <free+0x96>
    aa28:	80 81       	ld	r24, Z
    aa2a:	91 81       	ldd	r25, Z+1	; 0x01
    aa2c:	80 0f       	add	r24, r16
    aa2e:	91 1f       	adc	r25, r17
    aa30:	02 96       	adiw	r24, 0x02	; 2
    aa32:	88 83       	st	Y, r24
    aa34:	99 83       	std	Y+1, r25	; 0x01
    aa36:	82 81       	ldd	r24, Z+2	; 0x02
    aa38:	93 81       	ldd	r25, Z+3	; 0x03
    aa3a:	8a 83       	std	Y+2, r24	; 0x02
    aa3c:	9b 83       	std	Y+3, r25	; 0x03
    aa3e:	41 15       	cp	r20, r1
    aa40:	51 05       	cpc	r21, r1
    aa42:	29 f4       	brne	.+10     	; 0xaa4e <free+0xa6>
    aa44:	a0 93 3a 33 	sts	0x333A, r26
    aa48:	b0 93 3b 33 	sts	0x333B, r27
    aa4c:	41 c0       	rjmp	.+130    	; 0xaad0 <free+0x128>
    aa4e:	fa 01       	movw	r30, r20
    aa50:	a2 83       	std	Z+2, r26	; 0x02
    aa52:	b3 83       	std	Z+3, r27	; 0x03
    aa54:	c1 91       	ld	r28, Z+
    aa56:	d1 91       	ld	r29, Z+
    aa58:	ec 0f       	add	r30, r28
    aa5a:	fd 1f       	adc	r31, r29
    aa5c:	ae 17       	cp	r26, r30
    aa5e:	bf 07       	cpc	r27, r31
    aa60:	81 f4       	brne	.+32     	; 0xaa82 <free+0xda>
    aa62:	f9 01       	movw	r30, r18
    aa64:	92 91       	ld	r25, -Z
    aa66:	82 91       	ld	r24, -Z
    aa68:	8c 0f       	add	r24, r28
    aa6a:	9d 1f       	adc	r25, r29
    aa6c:	02 96       	adiw	r24, 0x02	; 2
    aa6e:	da 01       	movw	r26, r20
    aa70:	8d 93       	st	X+, r24
    aa72:	9c 93       	st	X, r25
    aa74:	11 97       	sbiw	r26, 0x01	; 1
    aa76:	82 81       	ldd	r24, Z+2	; 0x02
    aa78:	93 81       	ldd	r25, Z+3	; 0x03
    aa7a:	12 96       	adiw	r26, 0x02	; 2
    aa7c:	8d 93       	st	X+, r24
    aa7e:	9c 93       	st	X, r25
    aa80:	13 97       	sbiw	r26, 0x03	; 3
    aa82:	e0 e0       	ldi	r30, 0x00	; 0
    aa84:	f0 e0       	ldi	r31, 0x00	; 0
    aa86:	02 c0       	rjmp	.+4      	; 0xaa8c <free+0xe4>
    aa88:	fb 01       	movw	r30, r22
    aa8a:	bc 01       	movw	r22, r24
    aa8c:	db 01       	movw	r26, r22
    aa8e:	12 96       	adiw	r26, 0x02	; 2
    aa90:	8d 91       	ld	r24, X+
    aa92:	9c 91       	ld	r25, X
    aa94:	13 97       	sbiw	r26, 0x03	; 3
    aa96:	00 97       	sbiw	r24, 0x00	; 0
    aa98:	b9 f7       	brne	.-18     	; 0xaa88 <free+0xe0>
    aa9a:	cb 01       	movw	r24, r22
    aa9c:	02 96       	adiw	r24, 0x02	; 2
    aa9e:	2d 91       	ld	r18, X+
    aaa0:	3c 91       	ld	r19, X
    aaa2:	11 97       	sbiw	r26, 0x01	; 1
    aaa4:	82 0f       	add	r24, r18
    aaa6:	93 1f       	adc	r25, r19
    aaa8:	20 91 38 33 	lds	r18, 0x3338
    aaac:	30 91 39 33 	lds	r19, 0x3339
    aab0:	28 17       	cp	r18, r24
    aab2:	39 07       	cpc	r19, r25
    aab4:	69 f4       	brne	.+26     	; 0xaad0 <free+0x128>
    aab6:	30 97       	sbiw	r30, 0x00	; 0
    aab8:	29 f4       	brne	.+10     	; 0xaac4 <free+0x11c>
    aaba:	10 92 3a 33 	sts	0x333A, r1
    aabe:	10 92 3b 33 	sts	0x333B, r1
    aac2:	02 c0       	rjmp	.+4      	; 0xaac8 <free+0x120>
    aac4:	12 82       	std	Z+2, r1	; 0x02
    aac6:	13 82       	std	Z+3, r1	; 0x03
    aac8:	60 93 38 33 	sts	0x3338, r22
    aacc:	70 93 39 33 	sts	0x3339, r23
    aad0:	df 91       	pop	r29
    aad2:	cf 91       	pop	r28
    aad4:	1f 91       	pop	r17
    aad6:	0f 91       	pop	r16
    aad8:	08 95       	ret

0000aada <strtol>:
    aada:	2f 92       	push	r2
    aadc:	3f 92       	push	r3
    aade:	4f 92       	push	r4
    aae0:	5f 92       	push	r5
    aae2:	6f 92       	push	r6
    aae4:	7f 92       	push	r7
    aae6:	8f 92       	push	r8
    aae8:	9f 92       	push	r9
    aaea:	bf 92       	push	r11
    aaec:	cf 92       	push	r12
    aaee:	df 92       	push	r13
    aaf0:	ef 92       	push	r14
    aaf2:	ff 92       	push	r15
    aaf4:	0f 93       	push	r16
    aaf6:	1f 93       	push	r17
    aaf8:	cf 93       	push	r28
    aafa:	df 93       	push	r29
    aafc:	3b 01       	movw	r6, r22
    aafe:	8a 01       	movw	r16, r20
    ab00:	61 15       	cp	r22, r1
    ab02:	71 05       	cpc	r23, r1
    ab04:	19 f0       	breq	.+6      	; 0xab0c <strtol+0x32>
    ab06:	fb 01       	movw	r30, r22
    ab08:	80 83       	st	Z, r24
    ab0a:	91 83       	std	Z+1, r25	; 0x01
    ab0c:	01 15       	cp	r16, r1
    ab0e:	11 05       	cpc	r17, r1
    ab10:	39 f0       	breq	.+14     	; 0xab20 <strtol+0x46>
    ab12:	98 01       	movw	r18, r16
    ab14:	22 50       	subi	r18, 0x02	; 2
    ab16:	30 40       	sbci	r19, 0x00	; 0
    ab18:	23 32       	cpi	r18, 0x23	; 35
    ab1a:	31 05       	cpc	r19, r1
    ab1c:	08 f0       	brcs	.+2      	; 0xab20 <strtol+0x46>
    ab1e:	03 c1       	rjmp	.+518    	; 0xad26 <strtol+0x24c>
    ab20:	6c 01       	movw	r12, r24
    ab22:	76 01       	movw	r14, r12
    ab24:	08 94       	sec
    ab26:	c1 1c       	adc	r12, r1
    ab28:	d1 1c       	adc	r13, r1
    ab2a:	f7 01       	movw	r30, r14
    ab2c:	c0 81       	ld	r28, Z
    ab2e:	46 01       	movw	r8, r12
    ab30:	8c 2f       	mov	r24, r28
    ab32:	90 e0       	ldi	r25, 0x00	; 0
    ab34:	0e 94 aa 56 	call	0xad54	; 0xad54 <isspace>
    ab38:	00 97       	sbiw	r24, 0x00	; 0
    ab3a:	99 f7       	brne	.-26     	; 0xab22 <strtol+0x48>
    ab3c:	cd 32       	cpi	r28, 0x2D	; 45
    ab3e:	49 f4       	brne	.+18     	; 0xab52 <strtol+0x78>
    ab40:	f7 01       	movw	r30, r14
    ab42:	c1 81       	ldd	r28, Z+1	; 0x01
    ab44:	b2 e0       	ldi	r27, 0x02	; 2
    ab46:	8b 2e       	mov	r8, r27
    ab48:	91 2c       	mov	r9, r1
    ab4a:	8e 0c       	add	r8, r14
    ab4c:	9f 1c       	adc	r9, r15
    ab4e:	d1 e0       	ldi	r29, 0x01	; 1
    ab50:	0a c0       	rjmp	.+20     	; 0xab66 <strtol+0x8c>
    ab52:	cb 32       	cpi	r28, 0x2B	; 43
    ab54:	39 f4       	brne	.+14     	; 0xab64 <strtol+0x8a>
    ab56:	f7 01       	movw	r30, r14
    ab58:	c1 81       	ldd	r28, Z+1	; 0x01
    ab5a:	a2 e0       	ldi	r26, 0x02	; 2
    ab5c:	8a 2e       	mov	r8, r26
    ab5e:	91 2c       	mov	r9, r1
    ab60:	8e 0c       	add	r8, r14
    ab62:	9f 1c       	adc	r9, r15
    ab64:	d0 e0       	ldi	r29, 0x00	; 0
    ab66:	01 15       	cp	r16, r1
    ab68:	11 05       	cpc	r17, r1
    ab6a:	19 f0       	breq	.+6      	; 0xab72 <strtol+0x98>
    ab6c:	00 31       	cpi	r16, 0x10	; 16
    ab6e:	11 05       	cpc	r17, r1
    ab70:	c1 f4       	brne	.+48     	; 0xaba2 <strtol+0xc8>
    ab72:	c0 33       	cpi	r28, 0x30	; 48
    ab74:	81 f4       	brne	.+32     	; 0xab96 <strtol+0xbc>
    ab76:	f4 01       	movw	r30, r8
    ab78:	80 81       	ld	r24, Z
    ab7a:	88 37       	cpi	r24, 0x78	; 120
    ab7c:	11 f0       	breq	.+4      	; 0xab82 <strtol+0xa8>
    ab7e:	88 35       	cpi	r24, 0x58	; 88
    ab80:	51 f4       	brne	.+20     	; 0xab96 <strtol+0xbc>
    ab82:	f4 01       	movw	r30, r8
    ab84:	c1 81       	ldd	r28, Z+1	; 0x01
    ab86:	82 e0       	ldi	r24, 0x02	; 2
    ab88:	90 e0       	ldi	r25, 0x00	; 0
    ab8a:	88 0e       	add	r8, r24
    ab8c:	99 1e       	adc	r9, r25
    ab8e:	d2 60       	ori	r29, 0x02	; 2
    ab90:	00 e1       	ldi	r16, 0x10	; 16
    ab92:	10 e0       	ldi	r17, 0x00	; 0
    ab94:	06 c0       	rjmp	.+12     	; 0xaba2 <strtol+0xc8>
    ab96:	01 15       	cp	r16, r1
    ab98:	11 05       	cpc	r17, r1
    ab9a:	19 f4       	brne	.+6      	; 0xaba2 <strtol+0xc8>
    ab9c:	c0 33       	cpi	r28, 0x30	; 48
    ab9e:	c1 f4       	brne	.+48     	; 0xabd0 <strtol+0xf6>
    aba0:	22 c0       	rjmp	.+68     	; 0xabe6 <strtol+0x10c>
    aba2:	08 30       	cpi	r16, 0x08	; 8
    aba4:	11 05       	cpc	r17, r1
    aba6:	f9 f0       	breq	.+62     	; 0xabe6 <strtol+0x10c>
    aba8:	09 30       	cpi	r16, 0x09	; 9
    abaa:	11 05       	cpc	r17, r1
    abac:	24 f4       	brge	.+8      	; 0xabb6 <strtol+0xdc>
    abae:	02 30       	cpi	r16, 0x02	; 2
    abb0:	11 05       	cpc	r17, r1
    abb2:	09 f5       	brne	.+66     	; 0xabf6 <strtol+0x11c>
    abb4:	07 c0       	rjmp	.+14     	; 0xabc4 <strtol+0xea>
    abb6:	0a 30       	cpi	r16, 0x0A	; 10
    abb8:	11 05       	cpc	r17, r1
    abba:	51 f0       	breq	.+20     	; 0xabd0 <strtol+0xf6>
    abbc:	00 31       	cpi	r16, 0x10	; 16
    abbe:	11 05       	cpc	r17, r1
    abc0:	d1 f4       	brne	.+52     	; 0xabf6 <strtol+0x11c>
    abc2:	27 c0       	rjmp	.+78     	; 0xac12 <strtol+0x138>
    abc4:	c1 2c       	mov	r12, r1
    abc6:	d1 2c       	mov	r13, r1
    abc8:	e1 2c       	mov	r14, r1
    abca:	70 e4       	ldi	r23, 0x40	; 64
    abcc:	f7 2e       	mov	r15, r23
    abce:	26 c0       	rjmp	.+76     	; 0xac1c <strtol+0x142>
    abd0:	0a e0       	ldi	r16, 0x0A	; 10
    abd2:	10 e0       	ldi	r17, 0x00	; 0
    abd4:	6c ec       	ldi	r22, 0xCC	; 204
    abd6:	c6 2e       	mov	r12, r22
    abd8:	6c ec       	ldi	r22, 0xCC	; 204
    abda:	d6 2e       	mov	r13, r22
    abdc:	6c ec       	ldi	r22, 0xCC	; 204
    abde:	e6 2e       	mov	r14, r22
    abe0:	6c e0       	ldi	r22, 0x0C	; 12
    abe2:	f6 2e       	mov	r15, r22
    abe4:	1b c0       	rjmp	.+54     	; 0xac1c <strtol+0x142>
    abe6:	08 e0       	ldi	r16, 0x08	; 8
    abe8:	10 e0       	ldi	r17, 0x00	; 0
    abea:	c1 2c       	mov	r12, r1
    abec:	d1 2c       	mov	r13, r1
    abee:	e1 2c       	mov	r14, r1
    abf0:	50 e1       	ldi	r21, 0x10	; 16
    abf2:	f5 2e       	mov	r15, r21
    abf4:	13 c0       	rjmp	.+38     	; 0xac1c <strtol+0x142>
    abf6:	98 01       	movw	r18, r16
    abf8:	44 27       	eor	r20, r20
    abfa:	37 fd       	sbrc	r19, 7
    abfc:	40 95       	com	r20
    abfe:	54 2f       	mov	r21, r20
    ac00:	60 e0       	ldi	r22, 0x00	; 0
    ac02:	70 e0       	ldi	r23, 0x00	; 0
    ac04:	80 e0       	ldi	r24, 0x00	; 0
    ac06:	90 e8       	ldi	r25, 0x80	; 128
    ac08:	0e 94 29 5b 	call	0xb652	; 0xb652 <__udivmodsi4>
    ac0c:	69 01       	movw	r12, r18
    ac0e:	7a 01       	movw	r14, r20
    ac10:	05 c0       	rjmp	.+10     	; 0xac1c <strtol+0x142>
    ac12:	c1 2c       	mov	r12, r1
    ac14:	d1 2c       	mov	r13, r1
    ac16:	e1 2c       	mov	r14, r1
    ac18:	48 e0       	ldi	r20, 0x08	; 8
    ac1a:	f4 2e       	mov	r15, r20
    ac1c:	20 e0       	ldi	r18, 0x00	; 0
    ac1e:	40 e0       	ldi	r20, 0x00	; 0
    ac20:	50 e0       	ldi	r21, 0x00	; 0
    ac22:	ba 01       	movw	r22, r20
    ac24:	18 01       	movw	r2, r16
    ac26:	44 24       	eor	r4, r4
    ac28:	37 fc       	sbrc	r3, 7
    ac2a:	40 94       	com	r4
    ac2c:	54 2c       	mov	r5, r4
    ac2e:	30 ed       	ldi	r19, 0xD0	; 208
    ac30:	b3 2e       	mov	r11, r19
    ac32:	bc 0e       	add	r11, r28
    ac34:	99 e0       	ldi	r25, 0x09	; 9
    ac36:	9b 15       	cp	r25, r11
    ac38:	70 f4       	brcc	.+28     	; 0xac56 <strtol+0x17c>
    ac3a:	8c 2f       	mov	r24, r28
    ac3c:	81 54       	subi	r24, 0x41	; 65
    ac3e:	8a 31       	cpi	r24, 0x1A	; 26
    ac40:	18 f4       	brcc	.+6      	; 0xac48 <strtol+0x16e>
    ac42:	99 ec       	ldi	r25, 0xC9	; 201
    ac44:	b9 2e       	mov	r11, r25
    ac46:	06 c0       	rjmp	.+12     	; 0xac54 <strtol+0x17a>
    ac48:	8c 2f       	mov	r24, r28
    ac4a:	81 56       	subi	r24, 0x61	; 97
    ac4c:	8a 31       	cpi	r24, 0x1A	; 26
    ac4e:	50 f5       	brcc	.+84     	; 0xaca4 <strtol+0x1ca>
    ac50:	89 ea       	ldi	r24, 0xA9	; 169
    ac52:	b8 2e       	mov	r11, r24
    ac54:	bc 0e       	add	r11, r28
    ac56:	8b 2d       	mov	r24, r11
    ac58:	90 e0       	ldi	r25, 0x00	; 0
    ac5a:	80 17       	cp	r24, r16
    ac5c:	91 07       	cpc	r25, r17
    ac5e:	14 f5       	brge	.+68     	; 0xaca4 <strtol+0x1ca>
    ac60:	27 fd       	sbrc	r18, 7
    ac62:	1c c0       	rjmp	.+56     	; 0xac9c <strtol+0x1c2>
    ac64:	c4 16       	cp	r12, r20
    ac66:	d5 06       	cpc	r13, r21
    ac68:	e6 06       	cpc	r14, r22
    ac6a:	f7 06       	cpc	r15, r23
    ac6c:	a0 f0       	brcs	.+40     	; 0xac96 <strtol+0x1bc>
    ac6e:	cb 01       	movw	r24, r22
    ac70:	ba 01       	movw	r22, r20
    ac72:	a2 01       	movw	r20, r4
    ac74:	91 01       	movw	r18, r2
    ac76:	0e 94 0a 5b 	call	0xb614	; 0xb614 <__mulsi3>
    ac7a:	ab 01       	movw	r20, r22
    ac7c:	bc 01       	movw	r22, r24
    ac7e:	4b 0d       	add	r20, r11
    ac80:	51 1d       	adc	r21, r1
    ac82:	61 1d       	adc	r22, r1
    ac84:	71 1d       	adc	r23, r1
    ac86:	41 30       	cpi	r20, 0x01	; 1
    ac88:	e0 e0       	ldi	r30, 0x00	; 0
    ac8a:	5e 07       	cpc	r21, r30
    ac8c:	e0 e0       	ldi	r30, 0x00	; 0
    ac8e:	6e 07       	cpc	r22, r30
    ac90:	e0 e8       	ldi	r30, 0x80	; 128
    ac92:	7e 07       	cpc	r23, r30
    ac94:	10 f0       	brcs	.+4      	; 0xac9a <strtol+0x1c0>
    ac96:	2f ef       	ldi	r18, 0xFF	; 255
    ac98:	01 c0       	rjmp	.+2      	; 0xac9c <strtol+0x1c2>
    ac9a:	21 e0       	ldi	r18, 0x01	; 1
    ac9c:	f4 01       	movw	r30, r8
    ac9e:	c1 91       	ld	r28, Z+
    aca0:	4f 01       	movw	r8, r30
    aca2:	c5 cf       	rjmp	.-118    	; 0xac2e <strtol+0x154>
    aca4:	61 14       	cp	r6, r1
    aca6:	71 04       	cpc	r7, r1
    aca8:	89 f0       	breq	.+34     	; 0xaccc <strtol+0x1f2>
    acaa:	22 23       	and	r18, r18
    acac:	39 f0       	breq	.+14     	; 0xacbc <strtol+0x1e2>
    acae:	08 94       	sec
    acb0:	81 08       	sbc	r8, r1
    acb2:	91 08       	sbc	r9, r1
    acb4:	f3 01       	movw	r30, r6
    acb6:	80 82       	st	Z, r8
    acb8:	91 82       	std	Z+1, r9	; 0x01
    acba:	08 c0       	rjmp	.+16     	; 0xaccc <strtol+0x1f2>
    acbc:	d1 ff       	sbrs	r29, 1
    acbe:	1a c0       	rjmp	.+52     	; 0xacf4 <strtol+0x21a>
    acc0:	c4 01       	movw	r24, r8
    acc2:	02 97       	sbiw	r24, 0x02	; 2
    acc4:	f3 01       	movw	r30, r6
    acc6:	80 83       	st	Z, r24
    acc8:	91 83       	std	Z+1, r25	; 0x01
    acca:	14 c0       	rjmp	.+40     	; 0xacf4 <strtol+0x21a>
    accc:	27 ff       	sbrs	r18, 7
    acce:	12 c0       	rjmp	.+36     	; 0xacf4 <strtol+0x21a>
    acd0:	d0 ff       	sbrs	r29, 0
    acd2:	05 c0       	rjmp	.+10     	; 0xacde <strtol+0x204>
    acd4:	40 e0       	ldi	r20, 0x00	; 0
    acd6:	50 e0       	ldi	r21, 0x00	; 0
    acd8:	60 e0       	ldi	r22, 0x00	; 0
    acda:	70 e8       	ldi	r23, 0x80	; 128
    acdc:	04 c0       	rjmp	.+8      	; 0xace6 <strtol+0x20c>
    acde:	4f ef       	ldi	r20, 0xFF	; 255
    ace0:	5f ef       	ldi	r21, 0xFF	; 255
    ace2:	6f ef       	ldi	r22, 0xFF	; 255
    ace4:	7f e7       	ldi	r23, 0x7F	; 127
    ace6:	82 e2       	ldi	r24, 0x22	; 34
    ace8:	90 e0       	ldi	r25, 0x00	; 0
    acea:	80 93 42 33 	sts	0x3342, r24
    acee:	90 93 43 33 	sts	0x3343, r25
    acf2:	16 c0       	rjmp	.+44     	; 0xad20 <strtol+0x246>
    acf4:	d0 ff       	sbrs	r29, 0
    acf6:	08 c0       	rjmp	.+16     	; 0xad08 <strtol+0x22e>
    acf8:	70 95       	com	r23
    acfa:	60 95       	com	r22
    acfc:	50 95       	com	r21
    acfe:	41 95       	neg	r20
    ad00:	5f 4f       	sbci	r21, 0xFF	; 255
    ad02:	6f 4f       	sbci	r22, 0xFF	; 255
    ad04:	7f 4f       	sbci	r23, 0xFF	; 255
    ad06:	0c c0       	rjmp	.+24     	; 0xad20 <strtol+0x246>
    ad08:	77 ff       	sbrs	r23, 7
    ad0a:	0a c0       	rjmp	.+20     	; 0xad20 <strtol+0x246>
    ad0c:	82 e2       	ldi	r24, 0x22	; 34
    ad0e:	90 e0       	ldi	r25, 0x00	; 0
    ad10:	80 93 42 33 	sts	0x3342, r24
    ad14:	90 93 43 33 	sts	0x3343, r25
    ad18:	4f ef       	ldi	r20, 0xFF	; 255
    ad1a:	5f ef       	ldi	r21, 0xFF	; 255
    ad1c:	6f ef       	ldi	r22, 0xFF	; 255
    ad1e:	7f e7       	ldi	r23, 0x7F	; 127
    ad20:	8a 01       	movw	r16, r20
    ad22:	9b 01       	movw	r18, r22
    ad24:	03 c0       	rjmp	.+6      	; 0xad2c <strtol+0x252>
    ad26:	00 e0       	ldi	r16, 0x00	; 0
    ad28:	10 e0       	ldi	r17, 0x00	; 0
    ad2a:	98 01       	movw	r18, r16
    ad2c:	b8 01       	movw	r22, r16
    ad2e:	c9 01       	movw	r24, r18
    ad30:	df 91       	pop	r29
    ad32:	cf 91       	pop	r28
    ad34:	1f 91       	pop	r17
    ad36:	0f 91       	pop	r16
    ad38:	ff 90       	pop	r15
    ad3a:	ef 90       	pop	r14
    ad3c:	df 90       	pop	r13
    ad3e:	cf 90       	pop	r12
    ad40:	bf 90       	pop	r11
    ad42:	9f 90       	pop	r9
    ad44:	8f 90       	pop	r8
    ad46:	7f 90       	pop	r7
    ad48:	6f 90       	pop	r6
    ad4a:	5f 90       	pop	r5
    ad4c:	4f 90       	pop	r4
    ad4e:	3f 90       	pop	r3
    ad50:	2f 90       	pop	r2
    ad52:	08 95       	ret

0000ad54 <isspace>:
    ad54:	91 11       	cpse	r25, r1
    ad56:	e7 c3       	rjmp	.+1998   	; 0xb526 <__ctype_isfalse>
    ad58:	80 32       	cpi	r24, 0x20	; 32
    ad5a:	19 f0       	breq	.+6      	; 0xad62 <isspace+0xe>
    ad5c:	89 50       	subi	r24, 0x09	; 9
    ad5e:	85 50       	subi	r24, 0x05	; 5
    ad60:	d0 f7       	brcc	.-12     	; 0xad56 <isspace+0x2>
    ad62:	08 95       	ret

0000ad64 <memcpy_P>:
    ad64:	fb 01       	movw	r30, r22
    ad66:	dc 01       	movw	r26, r24
    ad68:	02 c0       	rjmp	.+4      	; 0xad6e <memcpy_P+0xa>
    ad6a:	05 90       	lpm	r0, Z+
    ad6c:	0d 92       	st	X+, r0
    ad6e:	41 50       	subi	r20, 0x01	; 1
    ad70:	50 40       	sbci	r21, 0x00	; 0
    ad72:	d8 f7       	brcc	.-10     	; 0xad6a <memcpy_P+0x6>
    ad74:	08 95       	ret

0000ad76 <strncmp_P>:
    ad76:	fb 01       	movw	r30, r22
    ad78:	dc 01       	movw	r26, r24
    ad7a:	41 50       	subi	r20, 0x01	; 1
    ad7c:	50 40       	sbci	r21, 0x00	; 0
    ad7e:	30 f0       	brcs	.+12     	; 0xad8c <strncmp_P+0x16>
    ad80:	8d 91       	ld	r24, X+
    ad82:	05 90       	lpm	r0, Z+
    ad84:	80 19       	sub	r24, r0
    ad86:	19 f4       	brne	.+6      	; 0xad8e <strncmp_P+0x18>
    ad88:	00 20       	and	r0, r0
    ad8a:	b9 f7       	brne	.-18     	; 0xad7a <strncmp_P+0x4>
    ad8c:	88 1b       	sub	r24, r24
    ad8e:	99 0b       	sbc	r25, r25
    ad90:	08 95       	ret

0000ad92 <memcpy>:
    ad92:	fb 01       	movw	r30, r22
    ad94:	dc 01       	movw	r26, r24
    ad96:	02 c0       	rjmp	.+4      	; 0xad9c <memcpy+0xa>
    ad98:	01 90       	ld	r0, Z+
    ad9a:	0d 92       	st	X+, r0
    ad9c:	41 50       	subi	r20, 0x01	; 1
    ad9e:	50 40       	sbci	r21, 0x00	; 0
    ada0:	d8 f7       	brcc	.-10     	; 0xad98 <memcpy+0x6>
    ada2:	08 95       	ret

0000ada4 <memset>:
    ada4:	dc 01       	movw	r26, r24
    ada6:	01 c0       	rjmp	.+2      	; 0xadaa <memset+0x6>
    ada8:	6d 93       	st	X+, r22
    adaa:	41 50       	subi	r20, 0x01	; 1
    adac:	50 40       	sbci	r21, 0x00	; 0
    adae:	e0 f7       	brcc	.-8      	; 0xada8 <memset+0x4>
    adb0:	08 95       	ret

0000adb2 <strcat>:
    adb2:	fb 01       	movw	r30, r22
    adb4:	dc 01       	movw	r26, r24
    adb6:	0d 90       	ld	r0, X+
    adb8:	00 20       	and	r0, r0
    adba:	e9 f7       	brne	.-6      	; 0xadb6 <strcat+0x4>
    adbc:	11 97       	sbiw	r26, 0x01	; 1
    adbe:	01 90       	ld	r0, Z+
    adc0:	0d 92       	st	X+, r0
    adc2:	00 20       	and	r0, r0
    adc4:	e1 f7       	brne	.-8      	; 0xadbe <strcat+0xc>
    adc6:	08 95       	ret

0000adc8 <strcpy>:
    adc8:	fb 01       	movw	r30, r22
    adca:	dc 01       	movw	r26, r24
    adcc:	01 90       	ld	r0, Z+
    adce:	0d 92       	st	X+, r0
    add0:	00 20       	and	r0, r0
    add2:	e1 f7       	brne	.-8      	; 0xadcc <strcpy+0x4>
    add4:	08 95       	ret

0000add6 <strncmp>:
    add6:	fb 01       	movw	r30, r22
    add8:	dc 01       	movw	r26, r24
    adda:	41 50       	subi	r20, 0x01	; 1
    addc:	50 40       	sbci	r21, 0x00	; 0
    adde:	30 f0       	brcs	.+12     	; 0xadec <strncmp+0x16>
    ade0:	8d 91       	ld	r24, X+
    ade2:	01 90       	ld	r0, Z+
    ade4:	80 19       	sub	r24, r0
    ade6:	19 f4       	brne	.+6      	; 0xadee <strncmp+0x18>
    ade8:	00 20       	and	r0, r0
    adea:	b9 f7       	brne	.-18     	; 0xadda <strncmp+0x4>
    adec:	88 1b       	sub	r24, r24
    adee:	99 0b       	sbc	r25, r25
    adf0:	08 95       	ret

0000adf2 <strncpy>:
    adf2:	fb 01       	movw	r30, r22
    adf4:	dc 01       	movw	r26, r24
    adf6:	41 50       	subi	r20, 0x01	; 1
    adf8:	50 40       	sbci	r21, 0x00	; 0
    adfa:	48 f0       	brcs	.+18     	; 0xae0e <strncpy+0x1c>
    adfc:	01 90       	ld	r0, Z+
    adfe:	0d 92       	st	X+, r0
    ae00:	00 20       	and	r0, r0
    ae02:	c9 f7       	brne	.-14     	; 0xadf6 <strncpy+0x4>
    ae04:	01 c0       	rjmp	.+2      	; 0xae08 <strncpy+0x16>
    ae06:	1d 92       	st	X+, r1
    ae08:	41 50       	subi	r20, 0x01	; 1
    ae0a:	50 40       	sbci	r21, 0x00	; 0
    ae0c:	e0 f7       	brcc	.-8      	; 0xae06 <strncpy+0x14>
    ae0e:	08 95       	ret

0000ae10 <fclose>:
    ae10:	fc 01       	movw	r30, r24
    ae12:	23 81       	ldd	r18, Z+3	; 0x03
    ae14:	27 ff       	sbrs	r18, 7
    ae16:	23 c0       	rjmp	.+70     	; 0xae5e <fclose+0x4e>
    ae18:	20 91 3c 33 	lds	r18, 0x333C
    ae1c:	30 91 3d 33 	lds	r19, 0x333D
    ae20:	28 17       	cp	r18, r24
    ae22:	39 07       	cpc	r19, r25
    ae24:	21 f4       	brne	.+8      	; 0xae2e <fclose+0x1e>
    ae26:	10 92 3c 33 	sts	0x333C, r1
    ae2a:	10 92 3d 33 	sts	0x333D, r1
    ae2e:	20 91 3e 33 	lds	r18, 0x333E
    ae32:	30 91 3f 33 	lds	r19, 0x333F
    ae36:	28 17       	cp	r18, r24
    ae38:	39 07       	cpc	r19, r25
    ae3a:	21 f4       	brne	.+8      	; 0xae44 <fclose+0x34>
    ae3c:	10 92 3e 33 	sts	0x333E, r1
    ae40:	10 92 3f 33 	sts	0x333F, r1
    ae44:	20 91 40 33 	lds	r18, 0x3340
    ae48:	30 91 41 33 	lds	r19, 0x3341
    ae4c:	28 17       	cp	r18, r24
    ae4e:	39 07       	cpc	r19, r25
    ae50:	21 f4       	brne	.+8      	; 0xae5a <fclose+0x4a>
    ae52:	10 92 40 33 	sts	0x3340, r1
    ae56:	10 92 41 33 	sts	0x3341, r1
    ae5a:	0e 94 d4 54 	call	0xa9a8	; 0xa9a8 <free>
    ae5e:	80 e0       	ldi	r24, 0x00	; 0
    ae60:	90 e0       	ldi	r25, 0x00	; 0
    ae62:	08 95       	ret

0000ae64 <fgetc>:
    ae64:	cf 93       	push	r28
    ae66:	df 93       	push	r29
    ae68:	ec 01       	movw	r28, r24
    ae6a:	2b 81       	ldd	r18, Y+3	; 0x03
    ae6c:	20 ff       	sbrs	r18, 0
    ae6e:	35 c0       	rjmp	.+106    	; 0xaeda <fgetc+0x76>
    ae70:	26 ff       	sbrs	r18, 6
    ae72:	09 c0       	rjmp	.+18     	; 0xae86 <fgetc+0x22>
    ae74:	2f 7b       	andi	r18, 0xBF	; 191
    ae76:	2b 83       	std	Y+3, r18	; 0x03
    ae78:	8e 81       	ldd	r24, Y+6	; 0x06
    ae7a:	9f 81       	ldd	r25, Y+7	; 0x07
    ae7c:	01 96       	adiw	r24, 0x01	; 1
    ae7e:	8e 83       	std	Y+6, r24	; 0x06
    ae80:	9f 83       	std	Y+7, r25	; 0x07
    ae82:	8a 81       	ldd	r24, Y+2	; 0x02
    ae84:	28 c0       	rjmp	.+80     	; 0xaed6 <fgetc+0x72>
    ae86:	22 ff       	sbrs	r18, 2
    ae88:	0f c0       	rjmp	.+30     	; 0xaea8 <fgetc+0x44>
    ae8a:	e8 81       	ld	r30, Y
    ae8c:	f9 81       	ldd	r31, Y+1	; 0x01
    ae8e:	80 81       	ld	r24, Z
    ae90:	99 27       	eor	r25, r25
    ae92:	87 fd       	sbrc	r24, 7
    ae94:	90 95       	com	r25
    ae96:	00 97       	sbiw	r24, 0x00	; 0
    ae98:	19 f4       	brne	.+6      	; 0xaea0 <fgetc+0x3c>
    ae9a:	20 62       	ori	r18, 0x20	; 32
    ae9c:	2b 83       	std	Y+3, r18	; 0x03
    ae9e:	1d c0       	rjmp	.+58     	; 0xaeda <fgetc+0x76>
    aea0:	31 96       	adiw	r30, 0x01	; 1
    aea2:	e8 83       	st	Y, r30
    aea4:	f9 83       	std	Y+1, r31	; 0x01
    aea6:	11 c0       	rjmp	.+34     	; 0xaeca <fgetc+0x66>
    aea8:	ea 85       	ldd	r30, Y+10	; 0x0a
    aeaa:	fb 85       	ldd	r31, Y+11	; 0x0b
    aeac:	ce 01       	movw	r24, r28
    aeae:	19 95       	eicall
    aeb0:	97 ff       	sbrs	r25, 7
    aeb2:	0b c0       	rjmp	.+22     	; 0xaeca <fgetc+0x66>
    aeb4:	2b 81       	ldd	r18, Y+3	; 0x03
    aeb6:	3f ef       	ldi	r19, 0xFF	; 255
    aeb8:	8f 3f       	cpi	r24, 0xFF	; 255
    aeba:	93 07       	cpc	r25, r19
    aebc:	11 f4       	brne	.+4      	; 0xaec2 <fgetc+0x5e>
    aebe:	80 e1       	ldi	r24, 0x10	; 16
    aec0:	01 c0       	rjmp	.+2      	; 0xaec4 <fgetc+0x60>
    aec2:	80 e2       	ldi	r24, 0x20	; 32
    aec4:	82 2b       	or	r24, r18
    aec6:	8b 83       	std	Y+3, r24	; 0x03
    aec8:	08 c0       	rjmp	.+16     	; 0xaeda <fgetc+0x76>
    aeca:	2e 81       	ldd	r18, Y+6	; 0x06
    aecc:	3f 81       	ldd	r19, Y+7	; 0x07
    aece:	2f 5f       	subi	r18, 0xFF	; 255
    aed0:	3f 4f       	sbci	r19, 0xFF	; 255
    aed2:	2e 83       	std	Y+6, r18	; 0x06
    aed4:	3f 83       	std	Y+7, r19	; 0x07
    aed6:	90 e0       	ldi	r25, 0x00	; 0
    aed8:	02 c0       	rjmp	.+4      	; 0xaede <fgetc+0x7a>
    aeda:	8f ef       	ldi	r24, 0xFF	; 255
    aedc:	9f ef       	ldi	r25, 0xFF	; 255
    aede:	df 91       	pop	r29
    aee0:	cf 91       	pop	r28
    aee2:	08 95       	ret

0000aee4 <fprintf>:
    aee4:	cf 93       	push	r28
    aee6:	df 93       	push	r29
    aee8:	cd b7       	in	r28, 0x3d	; 61
    aeea:	de b7       	in	r29, 0x3e	; 62
    aeec:	ae 01       	movw	r20, r28
    aeee:	46 5f       	subi	r20, 0xF6	; 246
    aef0:	5f 4f       	sbci	r21, 0xFF	; 255
    aef2:	8e 81       	ldd	r24, Y+6	; 0x06
    aef4:	9f 81       	ldd	r25, Y+7	; 0x07
    aef6:	68 85       	ldd	r22, Y+8	; 0x08
    aef8:	79 85       	ldd	r23, Y+9	; 0x09
    aefa:	0e 94 1a 58 	call	0xb034	; 0xb034 <vfprintf>
    aefe:	df 91       	pop	r29
    af00:	cf 91       	pop	r28
    af02:	08 95       	ret

0000af04 <fprintf_P>:
    af04:	0f 93       	push	r16
    af06:	1f 93       	push	r17
    af08:	cf 93       	push	r28
    af0a:	df 93       	push	r29
    af0c:	cd b7       	in	r28, 0x3d	; 61
    af0e:	de b7       	in	r29, 0x3e	; 62
    af10:	08 85       	ldd	r16, Y+8	; 0x08
    af12:	19 85       	ldd	r17, Y+9	; 0x09
    af14:	ae 01       	movw	r20, r28
    af16:	44 5f       	subi	r20, 0xF4	; 244
    af18:	5f 4f       	sbci	r21, 0xFF	; 255
    af1a:	f8 01       	movw	r30, r16
    af1c:	83 81       	ldd	r24, Z+3	; 0x03
    af1e:	88 60       	ori	r24, 0x08	; 8
    af20:	83 83       	std	Z+3, r24	; 0x03
    af22:	c8 01       	movw	r24, r16
    af24:	6a 85       	ldd	r22, Y+10	; 0x0a
    af26:	7b 85       	ldd	r23, Y+11	; 0x0b
    af28:	0e 94 1a 58 	call	0xb034	; 0xb034 <vfprintf>
    af2c:	f8 01       	movw	r30, r16
    af2e:	23 81       	ldd	r18, Z+3	; 0x03
    af30:	27 7f       	andi	r18, 0xF7	; 247
    af32:	23 83       	std	Z+3, r18	; 0x03
    af34:	df 91       	pop	r29
    af36:	cf 91       	pop	r28
    af38:	1f 91       	pop	r17
    af3a:	0f 91       	pop	r16
    af3c:	08 95       	ret

0000af3e <fputc>:
    af3e:	0f 93       	push	r16
    af40:	1f 93       	push	r17
    af42:	cf 93       	push	r28
    af44:	df 93       	push	r29
    af46:	8c 01       	movw	r16, r24
    af48:	eb 01       	movw	r28, r22
    af4a:	8b 81       	ldd	r24, Y+3	; 0x03
    af4c:	81 ff       	sbrs	r24, 1
    af4e:	1b c0       	rjmp	.+54     	; 0xaf86 <fputc+0x48>
    af50:	82 ff       	sbrs	r24, 2
    af52:	0d c0       	rjmp	.+26     	; 0xaf6e <fputc+0x30>
    af54:	2e 81       	ldd	r18, Y+6	; 0x06
    af56:	3f 81       	ldd	r19, Y+7	; 0x07
    af58:	8c 81       	ldd	r24, Y+4	; 0x04
    af5a:	9d 81       	ldd	r25, Y+5	; 0x05
    af5c:	28 17       	cp	r18, r24
    af5e:	39 07       	cpc	r19, r25
    af60:	64 f4       	brge	.+24     	; 0xaf7a <fputc+0x3c>
    af62:	e8 81       	ld	r30, Y
    af64:	f9 81       	ldd	r31, Y+1	; 0x01
    af66:	01 93       	st	Z+, r16
    af68:	e8 83       	st	Y, r30
    af6a:	f9 83       	std	Y+1, r31	; 0x01
    af6c:	06 c0       	rjmp	.+12     	; 0xaf7a <fputc+0x3c>
    af6e:	e8 85       	ldd	r30, Y+8	; 0x08
    af70:	f9 85       	ldd	r31, Y+9	; 0x09
    af72:	80 2f       	mov	r24, r16
    af74:	19 95       	eicall
    af76:	00 97       	sbiw	r24, 0x00	; 0
    af78:	31 f4       	brne	.+12     	; 0xaf86 <fputc+0x48>
    af7a:	8e 81       	ldd	r24, Y+6	; 0x06
    af7c:	9f 81       	ldd	r25, Y+7	; 0x07
    af7e:	01 96       	adiw	r24, 0x01	; 1
    af80:	8e 83       	std	Y+6, r24	; 0x06
    af82:	9f 83       	std	Y+7, r25	; 0x07
    af84:	02 c0       	rjmp	.+4      	; 0xaf8a <fputc+0x4c>
    af86:	0f ef       	ldi	r16, 0xFF	; 255
    af88:	1f ef       	ldi	r17, 0xFF	; 255
    af8a:	c8 01       	movw	r24, r16
    af8c:	df 91       	pop	r29
    af8e:	cf 91       	pop	r28
    af90:	1f 91       	pop	r17
    af92:	0f 91       	pop	r16
    af94:	08 95       	ret

0000af96 <fputs>:
    af96:	ef 92       	push	r14
    af98:	ff 92       	push	r15
    af9a:	0f 93       	push	r16
    af9c:	1f 93       	push	r17
    af9e:	cf 93       	push	r28
    afa0:	df 93       	push	r29
    afa2:	7c 01       	movw	r14, r24
    afa4:	eb 01       	movw	r28, r22
    afa6:	8b 81       	ldd	r24, Y+3	; 0x03
    afa8:	81 ff       	sbrs	r24, 1
    afaa:	11 c0       	rjmp	.+34     	; 0xafce <fputs+0x38>
    afac:	00 e0       	ldi	r16, 0x00	; 0
    afae:	10 e0       	ldi	r17, 0x00	; 0
    afb0:	08 c0       	rjmp	.+16     	; 0xafc2 <fputs+0x2c>
    afb2:	e8 85       	ldd	r30, Y+8	; 0x08
    afb4:	f9 85       	ldd	r31, Y+9	; 0x09
    afb6:	be 01       	movw	r22, r28
    afb8:	19 95       	eicall
    afba:	00 97       	sbiw	r24, 0x00	; 0
    afbc:	11 f0       	breq	.+4      	; 0xafc2 <fputs+0x2c>
    afbe:	0f ef       	ldi	r16, 0xFF	; 255
    afc0:	1f ef       	ldi	r17, 0xFF	; 255
    afc2:	f7 01       	movw	r30, r14
    afc4:	81 91       	ld	r24, Z+
    afc6:	7f 01       	movw	r14, r30
    afc8:	88 23       	and	r24, r24
    afca:	99 f7       	brne	.-26     	; 0xafb2 <fputs+0x1c>
    afcc:	02 c0       	rjmp	.+4      	; 0xafd2 <fputs+0x3c>
    afce:	0f ef       	ldi	r16, 0xFF	; 255
    afd0:	1f ef       	ldi	r17, 0xFF	; 255
    afd2:	c8 01       	movw	r24, r16
    afd4:	df 91       	pop	r29
    afd6:	cf 91       	pop	r28
    afd8:	1f 91       	pop	r17
    afda:	0f 91       	pop	r16
    afdc:	ff 90       	pop	r15
    afde:	ef 90       	pop	r14
    afe0:	08 95       	ret

0000afe2 <sprintf>:
    afe2:	0f 93       	push	r16
    afe4:	1f 93       	push	r17
    afe6:	cf 93       	push	r28
    afe8:	df 93       	push	r29
    afea:	cd b7       	in	r28, 0x3d	; 61
    afec:	de b7       	in	r29, 0x3e	; 62
    afee:	2e 97       	sbiw	r28, 0x0e	; 14
    aff0:	cd bf       	out	0x3d, r28	; 61
    aff2:	de bf       	out	0x3e, r29	; 62
    aff4:	0e 89       	ldd	r16, Y+22	; 0x16
    aff6:	1f 89       	ldd	r17, Y+23	; 0x17
    aff8:	86 e0       	ldi	r24, 0x06	; 6
    affa:	8c 83       	std	Y+4, r24	; 0x04
    affc:	09 83       	std	Y+1, r16	; 0x01
    affe:	1a 83       	std	Y+2, r17	; 0x02
    b000:	8f ef       	ldi	r24, 0xFF	; 255
    b002:	9f e7       	ldi	r25, 0x7F	; 127
    b004:	8d 83       	std	Y+5, r24	; 0x05
    b006:	9e 83       	std	Y+6, r25	; 0x06
    b008:	ae 01       	movw	r20, r28
    b00a:	46 5e       	subi	r20, 0xE6	; 230
    b00c:	5f 4f       	sbci	r21, 0xFF	; 255
    b00e:	ce 01       	movw	r24, r28
    b010:	01 96       	adiw	r24, 0x01	; 1
    b012:	68 8d       	ldd	r22, Y+24	; 0x18
    b014:	79 8d       	ldd	r23, Y+25	; 0x19
    b016:	0e 94 1a 58 	call	0xb034	; 0xb034 <vfprintf>
    b01a:	ef 81       	ldd	r30, Y+7	; 0x07
    b01c:	f8 85       	ldd	r31, Y+8	; 0x08
    b01e:	e0 0f       	add	r30, r16
    b020:	f1 1f       	adc	r31, r17
    b022:	10 82       	st	Z, r1
    b024:	2e 96       	adiw	r28, 0x0e	; 14
    b026:	cd bf       	out	0x3d, r28	; 61
    b028:	de bf       	out	0x3e, r29	; 62
    b02a:	df 91       	pop	r29
    b02c:	cf 91       	pop	r28
    b02e:	1f 91       	pop	r17
    b030:	0f 91       	pop	r16
    b032:	08 95       	ret

0000b034 <vfprintf>:
    b034:	2f 92       	push	r2
    b036:	3f 92       	push	r3
    b038:	4f 92       	push	r4
    b03a:	5f 92       	push	r5
    b03c:	6f 92       	push	r6
    b03e:	7f 92       	push	r7
    b040:	8f 92       	push	r8
    b042:	9f 92       	push	r9
    b044:	af 92       	push	r10
    b046:	bf 92       	push	r11
    b048:	cf 92       	push	r12
    b04a:	df 92       	push	r13
    b04c:	ef 92       	push	r14
    b04e:	ff 92       	push	r15
    b050:	0f 93       	push	r16
    b052:	1f 93       	push	r17
    b054:	cf 93       	push	r28
    b056:	df 93       	push	r29
    b058:	cd b7       	in	r28, 0x3d	; 61
    b05a:	de b7       	in	r29, 0x3e	; 62
    b05c:	2d 97       	sbiw	r28, 0x0d	; 13
    b05e:	cd bf       	out	0x3d, r28	; 61
    b060:	de bf       	out	0x3e, r29	; 62
    b062:	3c 01       	movw	r6, r24
    b064:	6c 87       	std	Y+12, r22	; 0x0c
    b066:	7d 87       	std	Y+13, r23	; 0x0d
    b068:	5a 01       	movw	r10, r20
    b06a:	fc 01       	movw	r30, r24
    b06c:	16 82       	std	Z+6, r1	; 0x06
    b06e:	17 82       	std	Z+7, r1	; 0x07
    b070:	83 81       	ldd	r24, Z+3	; 0x03
    b072:	81 ff       	sbrs	r24, 1
    b074:	c8 c1       	rjmp	.+912    	; 0xb406 <vfprintf+0x3d2>
    b076:	2e 01       	movw	r4, r28
    b078:	08 94       	sec
    b07a:	41 1c       	adc	r4, r1
    b07c:	51 1c       	adc	r5, r1
    b07e:	f3 01       	movw	r30, r6
    b080:	93 81       	ldd	r25, Z+3	; 0x03
    b082:	ec 85       	ldd	r30, Y+12	; 0x0c
    b084:	fd 85       	ldd	r31, Y+13	; 0x0d
    b086:	93 fd       	sbrc	r25, 3
    b088:	85 91       	lpm	r24, Z+
    b08a:	93 ff       	sbrs	r25, 3
    b08c:	81 91       	ld	r24, Z+
    b08e:	ec 87       	std	Y+12, r30	; 0x0c
    b090:	fd 87       	std	Y+13, r31	; 0x0d
    b092:	88 23       	and	r24, r24
    b094:	09 f4       	brne	.+2      	; 0xb098 <vfprintf+0x64>
    b096:	b3 c1       	rjmp	.+870    	; 0xb3fe <vfprintf+0x3ca>
    b098:	85 32       	cpi	r24, 0x25	; 37
    b09a:	41 f4       	brne	.+16     	; 0xb0ac <vfprintf+0x78>
    b09c:	93 fd       	sbrc	r25, 3
    b09e:	85 91       	lpm	r24, Z+
    b0a0:	93 ff       	sbrs	r25, 3
    b0a2:	81 91       	ld	r24, Z+
    b0a4:	ec 87       	std	Y+12, r30	; 0x0c
    b0a6:	fd 87       	std	Y+13, r31	; 0x0d
    b0a8:	85 32       	cpi	r24, 0x25	; 37
    b0aa:	29 f4       	brne	.+10     	; 0xb0b6 <vfprintf+0x82>
    b0ac:	90 e0       	ldi	r25, 0x00	; 0
    b0ae:	b3 01       	movw	r22, r6
    b0b0:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b0b4:	e4 cf       	rjmp	.-56     	; 0xb07e <vfprintf+0x4a>
    b0b6:	ff 24       	eor	r15, r15
    b0b8:	ee 24       	eor	r14, r14
    b0ba:	10 e0       	ldi	r17, 0x00	; 0
    b0bc:	10 32       	cpi	r17, 0x20	; 32
    b0be:	b0 f4       	brcc	.+44     	; 0xb0ec <vfprintf+0xb8>
    b0c0:	8b 32       	cpi	r24, 0x2B	; 43
    b0c2:	69 f0       	breq	.+26     	; 0xb0de <vfprintf+0xaa>
    b0c4:	8c 32       	cpi	r24, 0x2C	; 44
    b0c6:	28 f4       	brcc	.+10     	; 0xb0d2 <vfprintf+0x9e>
    b0c8:	80 32       	cpi	r24, 0x20	; 32
    b0ca:	51 f0       	breq	.+20     	; 0xb0e0 <vfprintf+0xac>
    b0cc:	83 32       	cpi	r24, 0x23	; 35
    b0ce:	71 f4       	brne	.+28     	; 0xb0ec <vfprintf+0xb8>
    b0d0:	0b c0       	rjmp	.+22     	; 0xb0e8 <vfprintf+0xb4>
    b0d2:	8d 32       	cpi	r24, 0x2D	; 45
    b0d4:	39 f0       	breq	.+14     	; 0xb0e4 <vfprintf+0xb0>
    b0d6:	80 33       	cpi	r24, 0x30	; 48
    b0d8:	49 f4       	brne	.+18     	; 0xb0ec <vfprintf+0xb8>
    b0da:	11 60       	ori	r17, 0x01	; 1
    b0dc:	2c c0       	rjmp	.+88     	; 0xb136 <vfprintf+0x102>
    b0de:	12 60       	ori	r17, 0x02	; 2
    b0e0:	14 60       	ori	r17, 0x04	; 4
    b0e2:	29 c0       	rjmp	.+82     	; 0xb136 <vfprintf+0x102>
    b0e4:	18 60       	ori	r17, 0x08	; 8
    b0e6:	27 c0       	rjmp	.+78     	; 0xb136 <vfprintf+0x102>
    b0e8:	10 61       	ori	r17, 0x10	; 16
    b0ea:	25 c0       	rjmp	.+74     	; 0xb136 <vfprintf+0x102>
    b0ec:	17 fd       	sbrc	r17, 7
    b0ee:	2e c0       	rjmp	.+92     	; 0xb14c <vfprintf+0x118>
    b0f0:	28 2f       	mov	r18, r24
    b0f2:	20 53       	subi	r18, 0x30	; 48
    b0f4:	2a 30       	cpi	r18, 0x0A	; 10
    b0f6:	98 f4       	brcc	.+38     	; 0xb11e <vfprintf+0xea>
    b0f8:	16 ff       	sbrs	r17, 6
    b0fa:	08 c0       	rjmp	.+16     	; 0xb10c <vfprintf+0xd8>
    b0fc:	8f 2d       	mov	r24, r15
    b0fe:	88 0f       	add	r24, r24
    b100:	f8 2e       	mov	r15, r24
    b102:	ff 0c       	add	r15, r15
    b104:	ff 0c       	add	r15, r15
    b106:	f8 0e       	add	r15, r24
    b108:	f2 0e       	add	r15, r18
    b10a:	15 c0       	rjmp	.+42     	; 0xb136 <vfprintf+0x102>
    b10c:	8e 2d       	mov	r24, r14
    b10e:	88 0f       	add	r24, r24
    b110:	e8 2e       	mov	r14, r24
    b112:	ee 0c       	add	r14, r14
    b114:	ee 0c       	add	r14, r14
    b116:	e8 0e       	add	r14, r24
    b118:	e2 0e       	add	r14, r18
    b11a:	10 62       	ori	r17, 0x20	; 32
    b11c:	0c c0       	rjmp	.+24     	; 0xb136 <vfprintf+0x102>
    b11e:	8e 32       	cpi	r24, 0x2E	; 46
    b120:	21 f4       	brne	.+8      	; 0xb12a <vfprintf+0xf6>
    b122:	16 fd       	sbrc	r17, 6
    b124:	6c c1       	rjmp	.+728    	; 0xb3fe <vfprintf+0x3ca>
    b126:	10 64       	ori	r17, 0x40	; 64
    b128:	06 c0       	rjmp	.+12     	; 0xb136 <vfprintf+0x102>
    b12a:	8c 36       	cpi	r24, 0x6C	; 108
    b12c:	11 f4       	brne	.+4      	; 0xb132 <vfprintf+0xfe>
    b12e:	10 68       	ori	r17, 0x80	; 128
    b130:	02 c0       	rjmp	.+4      	; 0xb136 <vfprintf+0x102>
    b132:	88 36       	cpi	r24, 0x68	; 104
    b134:	59 f4       	brne	.+22     	; 0xb14c <vfprintf+0x118>
    b136:	ec 85       	ldd	r30, Y+12	; 0x0c
    b138:	fd 85       	ldd	r31, Y+13	; 0x0d
    b13a:	93 fd       	sbrc	r25, 3
    b13c:	85 91       	lpm	r24, Z+
    b13e:	93 ff       	sbrs	r25, 3
    b140:	81 91       	ld	r24, Z+
    b142:	ec 87       	std	Y+12, r30	; 0x0c
    b144:	fd 87       	std	Y+13, r31	; 0x0d
    b146:	88 23       	and	r24, r24
    b148:	09 f0       	breq	.+2      	; 0xb14c <vfprintf+0x118>
    b14a:	b8 cf       	rjmp	.-144    	; 0xb0bc <vfprintf+0x88>
    b14c:	98 2f       	mov	r25, r24
    b14e:	95 54       	subi	r25, 0x45	; 69
    b150:	93 30       	cpi	r25, 0x03	; 3
    b152:	18 f0       	brcs	.+6      	; 0xb15a <vfprintf+0x126>
    b154:	90 52       	subi	r25, 0x20	; 32
    b156:	93 30       	cpi	r25, 0x03	; 3
    b158:	38 f4       	brcc	.+14     	; 0xb168 <vfprintf+0x134>
    b15a:	24 e0       	ldi	r18, 0x04	; 4
    b15c:	30 e0       	ldi	r19, 0x00	; 0
    b15e:	a2 0e       	add	r10, r18
    b160:	b3 1e       	adc	r11, r19
    b162:	3f e3       	ldi	r19, 0x3F	; 63
    b164:	39 83       	std	Y+1, r19	; 0x01
    b166:	0f c0       	rjmp	.+30     	; 0xb186 <vfprintf+0x152>
    b168:	83 36       	cpi	r24, 0x63	; 99
    b16a:	31 f0       	breq	.+12     	; 0xb178 <vfprintf+0x144>
    b16c:	83 37       	cpi	r24, 0x73	; 115
    b16e:	81 f0       	breq	.+32     	; 0xb190 <vfprintf+0x15c>
    b170:	83 35       	cpi	r24, 0x53	; 83
    b172:	09 f0       	breq	.+2      	; 0xb176 <vfprintf+0x142>
    b174:	5a c0       	rjmp	.+180    	; 0xb22a <vfprintf+0x1f6>
    b176:	22 c0       	rjmp	.+68     	; 0xb1bc <vfprintf+0x188>
    b178:	f5 01       	movw	r30, r10
    b17a:	80 81       	ld	r24, Z
    b17c:	89 83       	std	Y+1, r24	; 0x01
    b17e:	22 e0       	ldi	r18, 0x02	; 2
    b180:	30 e0       	ldi	r19, 0x00	; 0
    b182:	a2 0e       	add	r10, r18
    b184:	b3 1e       	adc	r11, r19
    b186:	21 e0       	ldi	r18, 0x01	; 1
    b188:	c2 2e       	mov	r12, r18
    b18a:	d1 2c       	mov	r13, r1
    b18c:	42 01       	movw	r8, r4
    b18e:	14 c0       	rjmp	.+40     	; 0xb1b8 <vfprintf+0x184>
    b190:	92 e0       	ldi	r25, 0x02	; 2
    b192:	29 2e       	mov	r2, r25
    b194:	31 2c       	mov	r3, r1
    b196:	2a 0c       	add	r2, r10
    b198:	3b 1c       	adc	r3, r11
    b19a:	f5 01       	movw	r30, r10
    b19c:	80 80       	ld	r8, Z
    b19e:	91 80       	ldd	r9, Z+1	; 0x01
    b1a0:	16 ff       	sbrs	r17, 6
    b1a2:	03 c0       	rjmp	.+6      	; 0xb1aa <vfprintf+0x176>
    b1a4:	6f 2d       	mov	r22, r15
    b1a6:	70 e0       	ldi	r23, 0x00	; 0
    b1a8:	02 c0       	rjmp	.+4      	; 0xb1ae <vfprintf+0x17a>
    b1aa:	6f ef       	ldi	r22, 0xFF	; 255
    b1ac:	7f ef       	ldi	r23, 0xFF	; 255
    b1ae:	c4 01       	movw	r24, r8
    b1b0:	0e 94 a1 5a 	call	0xb542	; 0xb542 <strnlen>
    b1b4:	6c 01       	movw	r12, r24
    b1b6:	51 01       	movw	r10, r2
    b1b8:	1f 77       	andi	r17, 0x7F	; 127
    b1ba:	15 c0       	rjmp	.+42     	; 0xb1e6 <vfprintf+0x1b2>
    b1bc:	82 e0       	ldi	r24, 0x02	; 2
    b1be:	28 2e       	mov	r2, r24
    b1c0:	31 2c       	mov	r3, r1
    b1c2:	2a 0c       	add	r2, r10
    b1c4:	3b 1c       	adc	r3, r11
    b1c6:	f5 01       	movw	r30, r10
    b1c8:	80 80       	ld	r8, Z
    b1ca:	91 80       	ldd	r9, Z+1	; 0x01
    b1cc:	16 ff       	sbrs	r17, 6
    b1ce:	03 c0       	rjmp	.+6      	; 0xb1d6 <vfprintf+0x1a2>
    b1d0:	6f 2d       	mov	r22, r15
    b1d2:	70 e0       	ldi	r23, 0x00	; 0
    b1d4:	02 c0       	rjmp	.+4      	; 0xb1da <vfprintf+0x1a6>
    b1d6:	6f ef       	ldi	r22, 0xFF	; 255
    b1d8:	7f ef       	ldi	r23, 0xFF	; 255
    b1da:	c4 01       	movw	r24, r8
    b1dc:	0e 94 96 5a 	call	0xb52c	; 0xb52c <strnlen_P>
    b1e0:	6c 01       	movw	r12, r24
    b1e2:	10 68       	ori	r17, 0x80	; 128
    b1e4:	51 01       	movw	r10, r2
    b1e6:	13 fd       	sbrc	r17, 3
    b1e8:	1c c0       	rjmp	.+56     	; 0xb222 <vfprintf+0x1ee>
    b1ea:	06 c0       	rjmp	.+12     	; 0xb1f8 <vfprintf+0x1c4>
    b1ec:	80 e2       	ldi	r24, 0x20	; 32
    b1ee:	90 e0       	ldi	r25, 0x00	; 0
    b1f0:	b3 01       	movw	r22, r6
    b1f2:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b1f6:	ea 94       	dec	r14
    b1f8:	8e 2d       	mov	r24, r14
    b1fa:	90 e0       	ldi	r25, 0x00	; 0
    b1fc:	c8 16       	cp	r12, r24
    b1fe:	d9 06       	cpc	r13, r25
    b200:	a8 f3       	brcs	.-22     	; 0xb1ec <vfprintf+0x1b8>
    b202:	0f c0       	rjmp	.+30     	; 0xb222 <vfprintf+0x1ee>
    b204:	f4 01       	movw	r30, r8
    b206:	17 fd       	sbrc	r17, 7
    b208:	85 91       	lpm	r24, Z+
    b20a:	17 ff       	sbrs	r17, 7
    b20c:	81 91       	ld	r24, Z+
    b20e:	4f 01       	movw	r8, r30
    b210:	90 e0       	ldi	r25, 0x00	; 0
    b212:	b3 01       	movw	r22, r6
    b214:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b218:	e1 10       	cpse	r14, r1
    b21a:	ea 94       	dec	r14
    b21c:	08 94       	sec
    b21e:	c1 08       	sbc	r12, r1
    b220:	d1 08       	sbc	r13, r1
    b222:	c1 14       	cp	r12, r1
    b224:	d1 04       	cpc	r13, r1
    b226:	71 f7       	brne	.-36     	; 0xb204 <vfprintf+0x1d0>
    b228:	e7 c0       	rjmp	.+462    	; 0xb3f8 <vfprintf+0x3c4>
    b22a:	84 36       	cpi	r24, 0x64	; 100
    b22c:	11 f0       	breq	.+4      	; 0xb232 <vfprintf+0x1fe>
    b22e:	89 36       	cpi	r24, 0x69	; 105
    b230:	51 f5       	brne	.+84     	; 0xb286 <vfprintf+0x252>
    b232:	f5 01       	movw	r30, r10
    b234:	17 ff       	sbrs	r17, 7
    b236:	07 c0       	rjmp	.+14     	; 0xb246 <vfprintf+0x212>
    b238:	80 81       	ld	r24, Z
    b23a:	91 81       	ldd	r25, Z+1	; 0x01
    b23c:	a2 81       	ldd	r26, Z+2	; 0x02
    b23e:	b3 81       	ldd	r27, Z+3	; 0x03
    b240:	24 e0       	ldi	r18, 0x04	; 4
    b242:	30 e0       	ldi	r19, 0x00	; 0
    b244:	08 c0       	rjmp	.+16     	; 0xb256 <vfprintf+0x222>
    b246:	80 81       	ld	r24, Z
    b248:	91 81       	ldd	r25, Z+1	; 0x01
    b24a:	aa 27       	eor	r26, r26
    b24c:	97 fd       	sbrc	r25, 7
    b24e:	a0 95       	com	r26
    b250:	ba 2f       	mov	r27, r26
    b252:	22 e0       	ldi	r18, 0x02	; 2
    b254:	30 e0       	ldi	r19, 0x00	; 0
    b256:	a2 0e       	add	r10, r18
    b258:	b3 1e       	adc	r11, r19
    b25a:	01 2f       	mov	r16, r17
    b25c:	0f 76       	andi	r16, 0x6F	; 111
    b25e:	b7 ff       	sbrs	r27, 7
    b260:	08 c0       	rjmp	.+16     	; 0xb272 <vfprintf+0x23e>
    b262:	b0 95       	com	r27
    b264:	a0 95       	com	r26
    b266:	90 95       	com	r25
    b268:	81 95       	neg	r24
    b26a:	9f 4f       	sbci	r25, 0xFF	; 255
    b26c:	af 4f       	sbci	r26, 0xFF	; 255
    b26e:	bf 4f       	sbci	r27, 0xFF	; 255
    b270:	00 68       	ori	r16, 0x80	; 128
    b272:	bc 01       	movw	r22, r24
    b274:	cd 01       	movw	r24, r26
    b276:	a2 01       	movw	r20, r4
    b278:	2a e0       	ldi	r18, 0x0A	; 10
    b27a:	30 e0       	ldi	r19, 0x00	; 0
    b27c:	0e 94 ac 5a 	call	0xb558	; 0xb558 <__ultoa_invert>
    b280:	d8 2e       	mov	r13, r24
    b282:	d4 18       	sub	r13, r4
    b284:	3f c0       	rjmp	.+126    	; 0xb304 <vfprintf+0x2d0>
    b286:	85 37       	cpi	r24, 0x75	; 117
    b288:	21 f4       	brne	.+8      	; 0xb292 <vfprintf+0x25e>
    b28a:	1f 7e       	andi	r17, 0xEF	; 239
    b28c:	2a e0       	ldi	r18, 0x0A	; 10
    b28e:	30 e0       	ldi	r19, 0x00	; 0
    b290:	20 c0       	rjmp	.+64     	; 0xb2d2 <vfprintf+0x29e>
    b292:	19 7f       	andi	r17, 0xF9	; 249
    b294:	8f 36       	cpi	r24, 0x6F	; 111
    b296:	a9 f0       	breq	.+42     	; 0xb2c2 <vfprintf+0x28e>
    b298:	80 37       	cpi	r24, 0x70	; 112
    b29a:	20 f4       	brcc	.+8      	; 0xb2a4 <vfprintf+0x270>
    b29c:	88 35       	cpi	r24, 0x58	; 88
    b29e:	09 f0       	breq	.+2      	; 0xb2a2 <vfprintf+0x26e>
    b2a0:	ae c0       	rjmp	.+348    	; 0xb3fe <vfprintf+0x3ca>
    b2a2:	0b c0       	rjmp	.+22     	; 0xb2ba <vfprintf+0x286>
    b2a4:	80 37       	cpi	r24, 0x70	; 112
    b2a6:	21 f0       	breq	.+8      	; 0xb2b0 <vfprintf+0x27c>
    b2a8:	88 37       	cpi	r24, 0x78	; 120
    b2aa:	09 f0       	breq	.+2      	; 0xb2ae <vfprintf+0x27a>
    b2ac:	a8 c0       	rjmp	.+336    	; 0xb3fe <vfprintf+0x3ca>
    b2ae:	01 c0       	rjmp	.+2      	; 0xb2b2 <vfprintf+0x27e>
    b2b0:	10 61       	ori	r17, 0x10	; 16
    b2b2:	14 ff       	sbrs	r17, 4
    b2b4:	09 c0       	rjmp	.+18     	; 0xb2c8 <vfprintf+0x294>
    b2b6:	14 60       	ori	r17, 0x04	; 4
    b2b8:	07 c0       	rjmp	.+14     	; 0xb2c8 <vfprintf+0x294>
    b2ba:	14 ff       	sbrs	r17, 4
    b2bc:	08 c0       	rjmp	.+16     	; 0xb2ce <vfprintf+0x29a>
    b2be:	16 60       	ori	r17, 0x06	; 6
    b2c0:	06 c0       	rjmp	.+12     	; 0xb2ce <vfprintf+0x29a>
    b2c2:	28 e0       	ldi	r18, 0x08	; 8
    b2c4:	30 e0       	ldi	r19, 0x00	; 0
    b2c6:	05 c0       	rjmp	.+10     	; 0xb2d2 <vfprintf+0x29e>
    b2c8:	20 e1       	ldi	r18, 0x10	; 16
    b2ca:	30 e0       	ldi	r19, 0x00	; 0
    b2cc:	02 c0       	rjmp	.+4      	; 0xb2d2 <vfprintf+0x29e>
    b2ce:	20 e1       	ldi	r18, 0x10	; 16
    b2d0:	32 e0       	ldi	r19, 0x02	; 2
    b2d2:	f5 01       	movw	r30, r10
    b2d4:	17 ff       	sbrs	r17, 7
    b2d6:	07 c0       	rjmp	.+14     	; 0xb2e6 <vfprintf+0x2b2>
    b2d8:	60 81       	ld	r22, Z
    b2da:	71 81       	ldd	r23, Z+1	; 0x01
    b2dc:	82 81       	ldd	r24, Z+2	; 0x02
    b2de:	93 81       	ldd	r25, Z+3	; 0x03
    b2e0:	44 e0       	ldi	r20, 0x04	; 4
    b2e2:	50 e0       	ldi	r21, 0x00	; 0
    b2e4:	06 c0       	rjmp	.+12     	; 0xb2f2 <vfprintf+0x2be>
    b2e6:	60 81       	ld	r22, Z
    b2e8:	71 81       	ldd	r23, Z+1	; 0x01
    b2ea:	80 e0       	ldi	r24, 0x00	; 0
    b2ec:	90 e0       	ldi	r25, 0x00	; 0
    b2ee:	42 e0       	ldi	r20, 0x02	; 2
    b2f0:	50 e0       	ldi	r21, 0x00	; 0
    b2f2:	a4 0e       	add	r10, r20
    b2f4:	b5 1e       	adc	r11, r21
    b2f6:	a2 01       	movw	r20, r4
    b2f8:	0e 94 ac 5a 	call	0xb558	; 0xb558 <__ultoa_invert>
    b2fc:	d8 2e       	mov	r13, r24
    b2fe:	d4 18       	sub	r13, r4
    b300:	01 2f       	mov	r16, r17
    b302:	0f 77       	andi	r16, 0x7F	; 127
    b304:	06 ff       	sbrs	r16, 6
    b306:	09 c0       	rjmp	.+18     	; 0xb31a <vfprintf+0x2e6>
    b308:	0e 7f       	andi	r16, 0xFE	; 254
    b30a:	df 14       	cp	r13, r15
    b30c:	30 f4       	brcc	.+12     	; 0xb31a <vfprintf+0x2e6>
    b30e:	04 ff       	sbrs	r16, 4
    b310:	06 c0       	rjmp	.+12     	; 0xb31e <vfprintf+0x2ea>
    b312:	02 fd       	sbrc	r16, 2
    b314:	04 c0       	rjmp	.+8      	; 0xb31e <vfprintf+0x2ea>
    b316:	0f 7e       	andi	r16, 0xEF	; 239
    b318:	02 c0       	rjmp	.+4      	; 0xb31e <vfprintf+0x2ea>
    b31a:	1d 2d       	mov	r17, r13
    b31c:	01 c0       	rjmp	.+2      	; 0xb320 <vfprintf+0x2ec>
    b31e:	1f 2d       	mov	r17, r15
    b320:	80 2f       	mov	r24, r16
    b322:	90 e0       	ldi	r25, 0x00	; 0
    b324:	04 ff       	sbrs	r16, 4
    b326:	0c c0       	rjmp	.+24     	; 0xb340 <vfprintf+0x30c>
    b328:	fe 01       	movw	r30, r28
    b32a:	ed 0d       	add	r30, r13
    b32c:	f1 1d       	adc	r31, r1
    b32e:	20 81       	ld	r18, Z
    b330:	20 33       	cpi	r18, 0x30	; 48
    b332:	11 f4       	brne	.+4      	; 0xb338 <vfprintf+0x304>
    b334:	09 7e       	andi	r16, 0xE9	; 233
    b336:	09 c0       	rjmp	.+18     	; 0xb34a <vfprintf+0x316>
    b338:	02 ff       	sbrs	r16, 2
    b33a:	06 c0       	rjmp	.+12     	; 0xb348 <vfprintf+0x314>
    b33c:	1e 5f       	subi	r17, 0xFE	; 254
    b33e:	05 c0       	rjmp	.+10     	; 0xb34a <vfprintf+0x316>
    b340:	86 78       	andi	r24, 0x86	; 134
    b342:	90 70       	andi	r25, 0x00	; 0
    b344:	00 97       	sbiw	r24, 0x00	; 0
    b346:	09 f0       	breq	.+2      	; 0xb34a <vfprintf+0x316>
    b348:	1f 5f       	subi	r17, 0xFF	; 255
    b34a:	80 2e       	mov	r8, r16
    b34c:	99 24       	eor	r9, r9
    b34e:	03 fd       	sbrc	r16, 3
    b350:	12 c0       	rjmp	.+36     	; 0xb376 <vfprintf+0x342>
    b352:	00 ff       	sbrs	r16, 0
    b354:	0d c0       	rjmp	.+26     	; 0xb370 <vfprintf+0x33c>
    b356:	fd 2c       	mov	r15, r13
    b358:	1e 15       	cp	r17, r14
    b35a:	50 f4       	brcc	.+20     	; 0xb370 <vfprintf+0x33c>
    b35c:	fe 0c       	add	r15, r14
    b35e:	f1 1a       	sub	r15, r17
    b360:	1e 2d       	mov	r17, r14
    b362:	06 c0       	rjmp	.+12     	; 0xb370 <vfprintf+0x33c>
    b364:	80 e2       	ldi	r24, 0x20	; 32
    b366:	90 e0       	ldi	r25, 0x00	; 0
    b368:	b3 01       	movw	r22, r6
    b36a:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b36e:	1f 5f       	subi	r17, 0xFF	; 255
    b370:	1e 15       	cp	r17, r14
    b372:	c0 f3       	brcs	.-16     	; 0xb364 <vfprintf+0x330>
    b374:	04 c0       	rjmp	.+8      	; 0xb37e <vfprintf+0x34a>
    b376:	1e 15       	cp	r17, r14
    b378:	10 f4       	brcc	.+4      	; 0xb37e <vfprintf+0x34a>
    b37a:	e1 1a       	sub	r14, r17
    b37c:	01 c0       	rjmp	.+2      	; 0xb380 <vfprintf+0x34c>
    b37e:	ee 24       	eor	r14, r14
    b380:	84 fe       	sbrs	r8, 4
    b382:	0f c0       	rjmp	.+30     	; 0xb3a2 <vfprintf+0x36e>
    b384:	80 e3       	ldi	r24, 0x30	; 48
    b386:	90 e0       	ldi	r25, 0x00	; 0
    b388:	b3 01       	movw	r22, r6
    b38a:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b38e:	82 fe       	sbrs	r8, 2
    b390:	1f c0       	rjmp	.+62     	; 0xb3d0 <vfprintf+0x39c>
    b392:	81 fe       	sbrs	r8, 1
    b394:	03 c0       	rjmp	.+6      	; 0xb39c <vfprintf+0x368>
    b396:	88 e5       	ldi	r24, 0x58	; 88
    b398:	90 e0       	ldi	r25, 0x00	; 0
    b39a:	10 c0       	rjmp	.+32     	; 0xb3bc <vfprintf+0x388>
    b39c:	88 e7       	ldi	r24, 0x78	; 120
    b39e:	90 e0       	ldi	r25, 0x00	; 0
    b3a0:	0d c0       	rjmp	.+26     	; 0xb3bc <vfprintf+0x388>
    b3a2:	c4 01       	movw	r24, r8
    b3a4:	86 78       	andi	r24, 0x86	; 134
    b3a6:	90 70       	andi	r25, 0x00	; 0
    b3a8:	00 97       	sbiw	r24, 0x00	; 0
    b3aa:	91 f0       	breq	.+36     	; 0xb3d0 <vfprintf+0x39c>
    b3ac:	81 fc       	sbrc	r8, 1
    b3ae:	02 c0       	rjmp	.+4      	; 0xb3b4 <vfprintf+0x380>
    b3b0:	80 e2       	ldi	r24, 0x20	; 32
    b3b2:	01 c0       	rjmp	.+2      	; 0xb3b6 <vfprintf+0x382>
    b3b4:	8b e2       	ldi	r24, 0x2B	; 43
    b3b6:	07 fd       	sbrc	r16, 7
    b3b8:	8d e2       	ldi	r24, 0x2D	; 45
    b3ba:	90 e0       	ldi	r25, 0x00	; 0
    b3bc:	b3 01       	movw	r22, r6
    b3be:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b3c2:	06 c0       	rjmp	.+12     	; 0xb3d0 <vfprintf+0x39c>
    b3c4:	80 e3       	ldi	r24, 0x30	; 48
    b3c6:	90 e0       	ldi	r25, 0x00	; 0
    b3c8:	b3 01       	movw	r22, r6
    b3ca:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b3ce:	fa 94       	dec	r15
    b3d0:	df 14       	cp	r13, r15
    b3d2:	c0 f3       	brcs	.-16     	; 0xb3c4 <vfprintf+0x390>
    b3d4:	da 94       	dec	r13
    b3d6:	f2 01       	movw	r30, r4
    b3d8:	ed 0d       	add	r30, r13
    b3da:	f1 1d       	adc	r31, r1
    b3dc:	80 81       	ld	r24, Z
    b3de:	90 e0       	ldi	r25, 0x00	; 0
    b3e0:	b3 01       	movw	r22, r6
    b3e2:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b3e6:	dd 20       	and	r13, r13
    b3e8:	a9 f7       	brne	.-22     	; 0xb3d4 <vfprintf+0x3a0>
    b3ea:	06 c0       	rjmp	.+12     	; 0xb3f8 <vfprintf+0x3c4>
    b3ec:	80 e2       	ldi	r24, 0x20	; 32
    b3ee:	90 e0       	ldi	r25, 0x00	; 0
    b3f0:	b3 01       	movw	r22, r6
    b3f2:	0e 94 9f 57 	call	0xaf3e	; 0xaf3e <fputc>
    b3f6:	ea 94       	dec	r14
    b3f8:	ee 20       	and	r14, r14
    b3fa:	c1 f7       	brne	.-16     	; 0xb3ec <vfprintf+0x3b8>
    b3fc:	40 ce       	rjmp	.-896    	; 0xb07e <vfprintf+0x4a>
    b3fe:	f3 01       	movw	r30, r6
    b400:	86 81       	ldd	r24, Z+6	; 0x06
    b402:	97 81       	ldd	r25, Z+7	; 0x07
    b404:	02 c0       	rjmp	.+4      	; 0xb40a <vfprintf+0x3d6>
    b406:	8f ef       	ldi	r24, 0xFF	; 255
    b408:	9f ef       	ldi	r25, 0xFF	; 255
    b40a:	2d 96       	adiw	r28, 0x0d	; 13
    b40c:	cd bf       	out	0x3d, r28	; 61
    b40e:	de bf       	out	0x3e, r29	; 62
    b410:	df 91       	pop	r29
    b412:	cf 91       	pop	r28
    b414:	1f 91       	pop	r17
    b416:	0f 91       	pop	r16
    b418:	ff 90       	pop	r15
    b41a:	ef 90       	pop	r14
    b41c:	df 90       	pop	r13
    b41e:	cf 90       	pop	r12
    b420:	bf 90       	pop	r11
    b422:	af 90       	pop	r10
    b424:	9f 90       	pop	r9
    b426:	8f 90       	pop	r8
    b428:	7f 90       	pop	r7
    b42a:	6f 90       	pop	r6
    b42c:	5f 90       	pop	r5
    b42e:	4f 90       	pop	r4
    b430:	3f 90       	pop	r3
    b432:	2f 90       	pop	r2
    b434:	08 95       	ret

0000b436 <__eerd_block_x128a1>:
    b436:	e0 ec       	ldi	r30, 0xC0	; 192
    b438:	f1 e0       	ldi	r31, 0x01	; 1
    b43a:	a7 85       	ldd	r26, Z+15	; 0x0f
    b43c:	a7 fd       	sbrc	r26, 7
    b43e:	fd cf       	rjmp	.-6      	; 0xb43a <__eerd_block_x128a1+0x4>
    b440:	a4 85       	ldd	r26, Z+12	; 0x0c
    b442:	a8 60       	ori	r26, 0x08	; 8
    b444:	a4 87       	std	Z+12, r26	; 0x0c
    b446:	60 50       	subi	r22, 0x00	; 0
    b448:	70 4f       	sbci	r23, 0xF0	; 240
    b44a:	0c 94 c9 56 	jmp	0xad92	; 0xad92 <memcpy>

0000b44e <__eerd_dword_x128a1>:
    b44e:	0e 94 87 5a 	call	0xb50e	; 0xb50e <eeprom_mapen>
    b452:	60 81       	ld	r22, Z
    b454:	71 81       	ldd	r23, Z+1	; 0x01
    b456:	82 81       	ldd	r24, Z+2	; 0x02
    b458:	93 81       	ldd	r25, Z+3	; 0x03
    b45a:	08 95       	ret

0000b45c <__eerd_word_x128a1>:
    b45c:	0e 94 87 5a 	call	0xb50e	; 0xb50e <eeprom_mapen>
    b460:	80 81       	ld	r24, Z
    b462:	91 81       	ldd	r25, Z+1	; 0x01
    b464:	08 95       	ret

0000b466 <__eeupd_block_x128a1>:
    b466:	dc 01       	movw	r26, r24
    b468:	a4 0f       	add	r26, r20
    b46a:	b5 1f       	adc	r27, r21
    b46c:	41 50       	subi	r20, 0x01	; 1
    b46e:	50 40       	sbci	r21, 0x00	; 0
    b470:	48 f0       	brcs	.+18     	; 0xb484 <__eeupd_block_x128a1+0x1e>
    b472:	cb 01       	movw	r24, r22
    b474:	84 0f       	add	r24, r20
    b476:	95 1f       	adc	r25, r21
    b478:	2e 91       	ld	r18, -X
    b47a:	0e 94 44 5a 	call	0xb488	; 0xb488 <__eeupd_r18_x128a1>
    b47e:	41 50       	subi	r20, 0x01	; 1
    b480:	50 40       	sbci	r21, 0x00	; 0
    b482:	d0 f7       	brcc	.-12     	; 0xb478 <__eeupd_block_x128a1+0x12>
    b484:	08 95       	ret

0000b486 <__eeupd_byte_x128a1>:
    b486:	26 2f       	mov	r18, r22

0000b488 <__eeupd_r18_x128a1>:
    b488:	0e 94 87 5a 	call	0xb50e	; 0xb50e <eeprom_mapen>
    b48c:	00 80       	ld	r0, Z
    b48e:	02 16       	cp	r0, r18
    b490:	19 f0       	breq	.+6      	; 0xb498 <__eeupd_r18_x128a1+0x10>
    b492:	0e 94 61 5a 	call	0xb4c2	; 0xb4c2 <__eewr_r18_x128a1>
    b496:	01 97       	sbiw	r24, 0x01	; 1
    b498:	01 97       	sbiw	r24, 0x01	; 1
    b49a:	08 95       	ret

0000b49c <__eeupd_dword_x128a1>:
    b49c:	03 96       	adiw	r24, 0x03	; 3
    b49e:	27 2f       	mov	r18, r23
    b4a0:	0e 94 44 5a 	call	0xb488	; 0xb488 <__eeupd_r18_x128a1>
    b4a4:	0e 94 43 5a 	call	0xb486	; 0xb486 <__eeupd_byte_x128a1>
    b4a8:	25 2f       	mov	r18, r21
    b4aa:	0e 94 44 5a 	call	0xb488	; 0xb488 <__eeupd_r18_x128a1>
    b4ae:	24 2f       	mov	r18, r20
    b4b0:	0c 94 44 5a 	jmp	0xb488	; 0xb488 <__eeupd_r18_x128a1>

0000b4b4 <__eeupd_word_x128a1>:
    b4b4:	01 96       	adiw	r24, 0x01	; 1
    b4b6:	27 2f       	mov	r18, r23
    b4b8:	0e 94 44 5a 	call	0xb488	; 0xb488 <__eeupd_r18_x128a1>
    b4bc:	0c 94 43 5a 	jmp	0xb486	; 0xb486 <__eeupd_byte_x128a1>

0000b4c0 <__eewr_byte_x128a1>:
    b4c0:	26 2f       	mov	r18, r22

0000b4c2 <__eewr_r18_x128a1>:
    b4c2:	e0 ec       	ldi	r30, 0xC0	; 192
    b4c4:	f1 e0       	ldi	r31, 0x01	; 1
    b4c6:	37 85       	ldd	r19, Z+15	; 0x0f
    b4c8:	37 fd       	sbrc	r19, 7
    b4ca:	fd cf       	rjmp	.-6      	; 0xb4c6 <__eewr_r18_x128a1+0x4>
    b4cc:	34 85       	ldd	r19, Z+12	; 0x0c
    b4ce:	37 7f       	andi	r19, 0xF7	; 247
    b4d0:	34 87       	std	Z+12, r19	; 0x0c
    b4d2:	37 85       	ldd	r19, Z+15	; 0x0f
    b4d4:	31 ff       	sbrs	r19, 1
    b4d6:	09 c0       	rjmp	.+18     	; 0xb4ea <__eewr_r18_x128a1+0x28>
    b4d8:	36 e3       	ldi	r19, 0x36	; 54
    b4da:	32 87       	std	Z+10, r19	; 0x0a
    b4dc:	38 ed       	ldi	r19, 0xD8	; 216
    b4de:	34 bf       	out	0x34, r19	; 52
    b4e0:	31 e0       	ldi	r19, 0x01	; 1
    b4e2:	33 87       	std	Z+11, r19	; 0x0b
    b4e4:	37 85       	ldd	r19, Z+15	; 0x0f
    b4e6:	37 fd       	sbrc	r19, 7
    b4e8:	fd cf       	rjmp	.-6      	; 0xb4e4 <__eewr_r18_x128a1+0x22>
    b4ea:	33 e3       	ldi	r19, 0x33	; 51
    b4ec:	32 87       	std	Z+10, r19	; 0x0a
    b4ee:	80 83       	st	Z, r24
    b4f0:	91 83       	std	Z+1, r25	; 0x01
    b4f2:	12 82       	std	Z+2, r1	; 0x02
    b4f4:	24 83       	std	Z+4, r18	; 0x04
    b4f6:	25 e3       	ldi	r18, 0x35	; 53
    b4f8:	22 87       	std	Z+10, r18	; 0x0a
    b4fa:	28 ed       	ldi	r18, 0xD8	; 216
    b4fc:	31 e0       	ldi	r19, 0x01	; 1
    b4fe:	24 bf       	out	0x34, r18	; 52
    b500:	33 87       	std	Z+11, r19	; 0x0b
    b502:	01 96       	adiw	r24, 0x01	; 1
    b504:	08 95       	ret

0000b506 <__eerd_byte_x128a1u>:
    b506:	03 d0       	rcall	.+6      	; 0xb50e <eeprom_mapen>
    b508:	80 81       	ld	r24, Z
    b50a:	99 27       	eor	r25, r25
    b50c:	08 95       	ret

0000b50e <eeprom_mapen>:
    b50e:	e0 ec       	ldi	r30, 0xC0	; 192
    b510:	f1 e0       	ldi	r31, 0x01	; 1
    b512:	37 85       	ldd	r19, Z+15	; 0x0f
    b514:	37 fd       	sbrc	r19, 7
    b516:	fd cf       	rjmp	.-6      	; 0xb512 <eeprom_mapen+0x4>
    b518:	34 85       	ldd	r19, Z+12	; 0x0c
    b51a:	38 60       	ori	r19, 0x08	; 8
    b51c:	34 87       	std	Z+12, r19	; 0x0c
    b51e:	fc 01       	movw	r30, r24
    b520:	e0 50       	subi	r30, 0x00	; 0
    b522:	f0 4f       	sbci	r31, 0xF0	; 240
    b524:	08 95       	ret

0000b526 <__ctype_isfalse>:
    b526:	99 27       	eor	r25, r25
    b528:	88 27       	eor	r24, r24

0000b52a <__ctype_istrue>:
    b52a:	08 95       	ret

0000b52c <strnlen_P>:
    b52c:	fc 01       	movw	r30, r24
    b52e:	05 90       	lpm	r0, Z+
    b530:	61 50       	subi	r22, 0x01	; 1
    b532:	70 40       	sbci	r23, 0x00	; 0
    b534:	01 10       	cpse	r0, r1
    b536:	d8 f7       	brcc	.-10     	; 0xb52e <strnlen_P+0x2>
    b538:	80 95       	com	r24
    b53a:	90 95       	com	r25
    b53c:	8e 0f       	add	r24, r30
    b53e:	9f 1f       	adc	r25, r31
    b540:	08 95       	ret

0000b542 <strnlen>:
    b542:	fc 01       	movw	r30, r24
    b544:	61 50       	subi	r22, 0x01	; 1
    b546:	70 40       	sbci	r23, 0x00	; 0
    b548:	01 90       	ld	r0, Z+
    b54a:	01 10       	cpse	r0, r1
    b54c:	d8 f7       	brcc	.-10     	; 0xb544 <strnlen+0x2>
    b54e:	80 95       	com	r24
    b550:	90 95       	com	r25
    b552:	8e 0f       	add	r24, r30
    b554:	9f 1f       	adc	r25, r31
    b556:	08 95       	ret

0000b558 <__ultoa_invert>:
    b558:	fa 01       	movw	r30, r20
    b55a:	aa 27       	eor	r26, r26
    b55c:	28 30       	cpi	r18, 0x08	; 8
    b55e:	51 f1       	breq	.+84     	; 0xb5b4 <__ultoa_invert+0x5c>
    b560:	20 31       	cpi	r18, 0x10	; 16
    b562:	81 f1       	breq	.+96     	; 0xb5c4 <__ultoa_invert+0x6c>
    b564:	e8 94       	clt
    b566:	6f 93       	push	r22
    b568:	6e 7f       	andi	r22, 0xFE	; 254
    b56a:	6e 5f       	subi	r22, 0xFE	; 254
    b56c:	7f 4f       	sbci	r23, 0xFF	; 255
    b56e:	8f 4f       	sbci	r24, 0xFF	; 255
    b570:	9f 4f       	sbci	r25, 0xFF	; 255
    b572:	af 4f       	sbci	r26, 0xFF	; 255
    b574:	b1 e0       	ldi	r27, 0x01	; 1
    b576:	3e d0       	rcall	.+124    	; 0xb5f4 <__ultoa_invert+0x9c>
    b578:	b4 e0       	ldi	r27, 0x04	; 4
    b57a:	3c d0       	rcall	.+120    	; 0xb5f4 <__ultoa_invert+0x9c>
    b57c:	67 0f       	add	r22, r23
    b57e:	78 1f       	adc	r23, r24
    b580:	89 1f       	adc	r24, r25
    b582:	9a 1f       	adc	r25, r26
    b584:	a1 1d       	adc	r26, r1
    b586:	68 0f       	add	r22, r24
    b588:	79 1f       	adc	r23, r25
    b58a:	8a 1f       	adc	r24, r26
    b58c:	91 1d       	adc	r25, r1
    b58e:	a1 1d       	adc	r26, r1
    b590:	6a 0f       	add	r22, r26
    b592:	71 1d       	adc	r23, r1
    b594:	81 1d       	adc	r24, r1
    b596:	91 1d       	adc	r25, r1
    b598:	a1 1d       	adc	r26, r1
    b59a:	20 d0       	rcall	.+64     	; 0xb5dc <__ultoa_invert+0x84>
    b59c:	09 f4       	brne	.+2      	; 0xb5a0 <__ultoa_invert+0x48>
    b59e:	68 94       	set
    b5a0:	3f 91       	pop	r19
    b5a2:	2a e0       	ldi	r18, 0x0A	; 10
    b5a4:	26 9f       	mul	r18, r22
    b5a6:	11 24       	eor	r1, r1
    b5a8:	30 19       	sub	r19, r0
    b5aa:	30 5d       	subi	r19, 0xD0	; 208
    b5ac:	31 93       	st	Z+, r19
    b5ae:	de f6       	brtc	.-74     	; 0xb566 <__ultoa_invert+0xe>
    b5b0:	cf 01       	movw	r24, r30
    b5b2:	08 95       	ret
    b5b4:	46 2f       	mov	r20, r22
    b5b6:	47 70       	andi	r20, 0x07	; 7
    b5b8:	40 5d       	subi	r20, 0xD0	; 208
    b5ba:	41 93       	st	Z+, r20
    b5bc:	b3 e0       	ldi	r27, 0x03	; 3
    b5be:	0f d0       	rcall	.+30     	; 0xb5de <__ultoa_invert+0x86>
    b5c0:	c9 f7       	brne	.-14     	; 0xb5b4 <__ultoa_invert+0x5c>
    b5c2:	f6 cf       	rjmp	.-20     	; 0xb5b0 <__ultoa_invert+0x58>
    b5c4:	46 2f       	mov	r20, r22
    b5c6:	4f 70       	andi	r20, 0x0F	; 15
    b5c8:	40 5d       	subi	r20, 0xD0	; 208
    b5ca:	4a 33       	cpi	r20, 0x3A	; 58
    b5cc:	18 f0       	brcs	.+6      	; 0xb5d4 <__ultoa_invert+0x7c>
    b5ce:	49 5d       	subi	r20, 0xD9	; 217
    b5d0:	31 fd       	sbrc	r19, 1
    b5d2:	40 52       	subi	r20, 0x20	; 32
    b5d4:	41 93       	st	Z+, r20
    b5d6:	02 d0       	rcall	.+4      	; 0xb5dc <__ultoa_invert+0x84>
    b5d8:	a9 f7       	brne	.-22     	; 0xb5c4 <__ultoa_invert+0x6c>
    b5da:	ea cf       	rjmp	.-44     	; 0xb5b0 <__ultoa_invert+0x58>
    b5dc:	b4 e0       	ldi	r27, 0x04	; 4
    b5de:	a6 95       	lsr	r26
    b5e0:	97 95       	ror	r25
    b5e2:	87 95       	ror	r24
    b5e4:	77 95       	ror	r23
    b5e6:	67 95       	ror	r22
    b5e8:	ba 95       	dec	r27
    b5ea:	c9 f7       	brne	.-14     	; 0xb5de <__ultoa_invert+0x86>
    b5ec:	00 97       	sbiw	r24, 0x00	; 0
    b5ee:	61 05       	cpc	r22, r1
    b5f0:	71 05       	cpc	r23, r1
    b5f2:	08 95       	ret
    b5f4:	9b 01       	movw	r18, r22
    b5f6:	ac 01       	movw	r20, r24
    b5f8:	0a 2e       	mov	r0, r26
    b5fa:	06 94       	lsr	r0
    b5fc:	57 95       	ror	r21
    b5fe:	47 95       	ror	r20
    b600:	37 95       	ror	r19
    b602:	27 95       	ror	r18
    b604:	ba 95       	dec	r27
    b606:	c9 f7       	brne	.-14     	; 0xb5fa <__ultoa_invert+0xa2>
    b608:	62 0f       	add	r22, r18
    b60a:	73 1f       	adc	r23, r19
    b60c:	84 1f       	adc	r24, r20
    b60e:	95 1f       	adc	r25, r21
    b610:	a0 1d       	adc	r26, r0
    b612:	08 95       	ret

0000b614 <__mulsi3>:
    b614:	62 9f       	mul	r22, r18
    b616:	d0 01       	movw	r26, r0
    b618:	73 9f       	mul	r23, r19
    b61a:	f0 01       	movw	r30, r0
    b61c:	82 9f       	mul	r24, r18
    b61e:	e0 0d       	add	r30, r0
    b620:	f1 1d       	adc	r31, r1
    b622:	64 9f       	mul	r22, r20
    b624:	e0 0d       	add	r30, r0
    b626:	f1 1d       	adc	r31, r1
    b628:	92 9f       	mul	r25, r18
    b62a:	f0 0d       	add	r31, r0
    b62c:	83 9f       	mul	r24, r19
    b62e:	f0 0d       	add	r31, r0
    b630:	74 9f       	mul	r23, r20
    b632:	f0 0d       	add	r31, r0
    b634:	65 9f       	mul	r22, r21
    b636:	f0 0d       	add	r31, r0
    b638:	99 27       	eor	r25, r25
    b63a:	72 9f       	mul	r23, r18
    b63c:	b0 0d       	add	r27, r0
    b63e:	e1 1d       	adc	r30, r1
    b640:	f9 1f       	adc	r31, r25
    b642:	63 9f       	mul	r22, r19
    b644:	b0 0d       	add	r27, r0
    b646:	e1 1d       	adc	r30, r1
    b648:	f9 1f       	adc	r31, r25
    b64a:	bd 01       	movw	r22, r26
    b64c:	cf 01       	movw	r24, r30
    b64e:	11 24       	eor	r1, r1
    b650:	08 95       	ret

0000b652 <__udivmodsi4>:
    b652:	a1 e2       	ldi	r26, 0x21	; 33
    b654:	1a 2e       	mov	r1, r26
    b656:	aa 1b       	sub	r26, r26
    b658:	bb 1b       	sub	r27, r27
    b65a:	fd 01       	movw	r30, r26
    b65c:	0d c0       	rjmp	.+26     	; 0xb678 <__udivmodsi4_ep>

0000b65e <__udivmodsi4_loop>:
    b65e:	aa 1f       	adc	r26, r26
    b660:	bb 1f       	adc	r27, r27
    b662:	ee 1f       	adc	r30, r30
    b664:	ff 1f       	adc	r31, r31
    b666:	a2 17       	cp	r26, r18
    b668:	b3 07       	cpc	r27, r19
    b66a:	e4 07       	cpc	r30, r20
    b66c:	f5 07       	cpc	r31, r21
    b66e:	20 f0       	brcs	.+8      	; 0xb678 <__udivmodsi4_ep>
    b670:	a2 1b       	sub	r26, r18
    b672:	b3 0b       	sbc	r27, r19
    b674:	e4 0b       	sbc	r30, r20
    b676:	f5 0b       	sbc	r31, r21

0000b678 <__udivmodsi4_ep>:
    b678:	66 1f       	adc	r22, r22
    b67a:	77 1f       	adc	r23, r23
    b67c:	88 1f       	adc	r24, r24
    b67e:	99 1f       	adc	r25, r25
    b680:	1a 94       	dec	r1
    b682:	69 f7       	brne	.-38     	; 0xb65e <__udivmodsi4_loop>
    b684:	60 95       	com	r22
    b686:	70 95       	com	r23
    b688:	80 95       	com	r24
    b68a:	90 95       	com	r25
    b68c:	9b 01       	movw	r18, r22
    b68e:	ac 01       	movw	r20, r24
    b690:	bd 01       	movw	r22, r26
    b692:	cf 01       	movw	r24, r30
    b694:	08 95       	ret

0000b696 <_exit>:
    b696:	f8 94       	cli

0000b698 <__stop_program>:
    b698:	ff cf       	rjmp	.-2      	; 0xb698 <__stop_program>
