
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000b688  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000054a  00802000  0000b688  0000b73c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000dfa  0080254a  0080254a  0000bc86  2**0
                  ALLOC
  3 .eeprom       00000032  00810000  00810000  0000bc86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00019bfc  00000000  00000000  0000bcb8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00014ce1  00000000  00000000  000258b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2c 08 	jmp	0x1058	; 0x1058 <__ctors_end>
       4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
       8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
       c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      10:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      14:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      18:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      1c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      20:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      24:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      28:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      2c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      30:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      34:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      38:	0c 94 13 54 	jmp	0xa826	; 0xa826 <__vector_14>
      3c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      40:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      44:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      48:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      4c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      50:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      54:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      58:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      5c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      60:	0c 94 ae 0d 	jmp	0x1b5c	; 0x1b5c <__vector_24>
      64:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      68:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      6c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      70:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      74:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      78:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      7c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      80:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      84:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      88:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      8c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      90:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      94:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      98:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      9c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      ac:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      bc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      cc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      dc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      ec:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      fc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     100:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     104:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     108:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     10c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     110:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     114:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     118:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     11c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     120:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     124:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     128:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     12c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     130:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     134:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     138:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     13c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     140:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     144:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     148:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     14c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     150:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     154:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     158:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     15c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     160:	0c 94 7d 0a 	jmp	0x14fa	; 0x14fa <__vector_88>
     164:	0c 94 ed 0a 	jmp	0x15da	; 0x15da <__vector_89>
     168:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     16c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     170:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     174:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     178:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     17c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     180:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     184:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     188:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     18c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     190:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     194:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     198:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     19c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1ac:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1bc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1cc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1dc:	0c 94 4c 09 	jmp	0x1298	; 0x1298 <__vector_119>
     1e0:	0c 94 c3 09 	jmp	0x1386	; 0x1386 <__vector_120>
     1e4:	0c 94 19 0a 	jmp	0x1432	; 0x1432 <__vector_121>
     1e8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1ec:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1f0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>

000001f4 <statusLockerSensDescStr>:
     1f4:	20 6c 6f 63 6b 65 72 20 25 64 00                     locker %d.

000001ff <statusLockerOpenStr>:
     1ff:	20 6f 70 65 6e 20 20 20 00                           open   .

00000208 <statusLockerCloseStr>:
     208:	20 6c 6f 63 6b 65 64 20 00                           locked .

00000211 <statusLockerSensAdditionalDescStr>:
     211:	20 28 74 68 72 65 73 68 6f 6c 64 20 25 64 2c 20      (threshold %d, 
     221:	41 43 20 76 61 6c 75 65 20 25 64 29 0d 0a 00        AC value %d)...

00000230 <errorOK>:
     230:	41 6c 6c 20 4f 4b 0d 0a 00                          All OK...

00000239 <errorNoFile>:
     239:	4e 6f 20 46 69 6c 65 0d 0a 00                       No File...

00000243 <errorxModemFrameStartTimeout>:
     243:	0d 0a 00                                            ...

00000246 <errorxModemByteSendTimeout>:
     246:	0d 0a 00                                            ...

00000249 <errorxModemWrongFrameNo>:
     249:	0d 0a 00                                            ...

0000024c <errorxModemFrameFrameNoCorrectionNotMatch>:
     24c:	0d 0a 00                                            ...

0000024f <errorxModemFrameCrc>:
     24f:	78 4d 6f 64 65 6d 20 43 52 43 20 65 72 72 6f 72     xModem CRC error
     25f:	0d 0a 00                                            ...

00000262 <errorxModemRemoteSideCan>:
     262:	52 65 6d 6f 74 65 20 73 69 64 65 20 63 61 6e 63     Remote side canc
     272:	65 6c 6c 65 64 20 61 74 20 66 72 61 6d 65 20 6e     elled at frame n
     282:	6f 20 25 64 0d 0a 00                                o %d...

00000289 <errorxModemUnknownResponse>:
     289:	78 4d 6f 64 65 6d 20 75 6e 6b 6e 6f 77 6e 20 72     xModem unknown r
     299:	65 73 70 6f 6e 73 65 20 30 78 25 78 0d 0a 00        esponse 0x%x...

000002a8 <errorNoRemoteDevice>:
     2a8:	44 65 76 69 63 65 20 25 64 20 69 73 20 6e 6f 74     Device %d is not
     2b8:	20 72 65 73 70 6f 6e 64 69 6e 67 20 28 25 64 29      responding (%d)
     2c8:	0d 0a 00                                            ...

000002cb <errorBootloaderNotResponding>:
     2cb:	42 6f 6f 74 6c 6f 61 64 65 72 20 69 73 20 6e 6f     Bootloader is no
     2db:	74 20 72 65 73 70 6f 6e 64 69 6e 67 0d 0a 00        t responding...

000002ea <errorOpenFile>:
     2ea:	43 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 20     Can't open file 
     2fa:	25 73 0d 0a 00                                      %s...

000002ff <systemStateStr>:
     2ff:	53 79 73 74 65 6d 20 73 74 61 74 65 3a 0d 0a 00     System state:...

0000030f <statusNumberOfTasksStr>:
     30f:	20 20 4e 75 6d 62 65 72 20 6f 66 20 74 61 73 6b       Number of task
     31f:	73 20 3a 20 25 64 0d 0a 00                          s : %d...

00000328 <statusStaticHeapStateStr>:
     328:	20 20 46 72 65 65 52 74 6f 73 20 68 65 61 70 20       FreeRtos heap 
     338:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     348:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000352 <statusDynamicHeapStateStr>:
     352:	20 20 4d 61 6c 6c 6f 63 20 68 65 61 70 20 20 20       Malloc heap   
     362:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     372:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

0000037c <statusRamDiskStateStr>:
     37c:	20 20 52 61 6d 20 64 69 73 63 20 73 70 61 63 65       Ram disc space
     38c:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     39c:	64 20 63 6c 75 73 74 65 72 73 0d 0a 00              d clusters...

000003a9 <statusTemperatureStr>:
     3a9:	20 20 54 65 6d 70 65 72 61 74 75 72 65 20 20 20       Temperature   
     3b9:	20 20 3a 20 25 64 20 43 0d 0a 00                      : %d C...

000003c4 <statusVoltageStr>:
     3c4:	20 20 56 6f 6c 74 61 67 65 20 20 20 20 20 20 20       Voltage       
     3d4:	20 20 3a 20 25 64 20 56 0d 0a 00                      : %d V...

000003df <systemRamConfigStr>:
     3df:	53 79 73 74 65 6d 20 73 65 74 74 69 6e 67 73 3a     System settings:
     3ef:	0d 0a 00                                            ...

000003f2 <statusMacStr>:
     3f2:	20 20 4d 61 63 20 61 64 64 72 65 73 73 20 20 20       Mac address   
     402:	20 20 3a 20 00                                        : .

00000407 <statusIpStr>:
     407:	20 20 49 50 20 61 64 64 72 65 73 73 20 20 20 20       IP address    
     417:	20 20 3a 20 00                                        : .

0000041c <statusIpMaskStr>:
     41c:	20 20 6d 61 73 6b 20 20 20 20 20 20 20 20 20 20       mask          
     42c:	20 20 3a 20 00                                        : .

00000431 <statusIpGwStr>:
     431:	20 20 67 61 74 65 77 61 79 20 20 20 20 20 20 20       gateway       
     441:	20 20 3a 20 00                                        : .

00000446 <statusRs485listStr>:
     446:	44 65 74 65 63 74 65 64 20 52 53 20 34 38 35 20     Detected RS 485 
     456:	64 65 76 69 63 65 73 3a 0d 0a 00                    devices:...

00000461 <statusNoRs485Dev>:
     461:	20 20 43 61 6e 27 74 20 66 69 6e 64 20 61 6e 79       Can't find any
     471:	20 64 65 76 69 63 65 0d 0a 00                        device...

0000047b <statusLockerSensorsStr>:
     47b:	4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73 20 73     Locker sensors s
     48b:	74 61 74 65 73 3a 0d 0a 00                          tates:...

00000494 <statusLockerSensorsDisStr>:
     494:	20 20 4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73       Locker sensors
     4a4:	20 64 69 73 61 62 6c 65 64 0d 0a 00                  disabled...

000004b0 <editRamFileIntroStr>:
     4b0:	57 72 69 74 69 6e 67 20 74 6f 20 66 69 6c 65 2e     Writing to file.
     4c0:	20 50 72 65 73 73 20 43 54 52 4c 2b 43 20 74 6f      Press CTRL+C to
     4d0:	20 71 75 69 74 0d 0a 00                              quit...

000004d8 <readRamFIleLenStr>:
     4d8:	46 69 6c 65 20 6c 65 6e 67 74 68 3a 20 25 64 0d     File length: %d.
     4e8:	0a 00                                               ..

000004ea <xwyslijStartStr>:
     4ea:	58 6d 6f 64 65 6d 3a 20 54 72 61 6e 73 6d 69 73     Xmodem: Transmis
     4fa:	73 69 6f 6e 20 73 74 61 72 74 0d 0a 00              sion start...

00000507 <movingCurtainUpStr>:
     507:	50 6f 64 6e 6f 73 7a 65 6e 69 65 20 72 6f 6c 65     Podnoszenie role
     517:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     527:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     537:	0d 0a 00                                            ...

0000053a <movingCurtainDownStr>:
     53a:	4f 70 75 73 7a 63 7a 61 6e 69 65 20 72 6f 6c 65     Opuszczanie role
     54a:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     55a:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     56a:	0d 0a 00                                            ...

0000056d <movingCurtainPosStr>:
     56d:	09 70 6f 7a 79 63 6a 61 20 20 20 25 64 0d 0a 00     .pozycja   %d...

0000057d <debugEnabledInfoStr>:
     57d:	45 6e 61 62 6c 65 64 20 25 73 20 64 65 62 75 67     Enabled %s debug
     58d:	0d 0a 00                                            ...

00000590 <debugDisabledInfoStr>:
     590:	44 69 73 61 62 6c 65 64 20 25 73 20 64 65 62 75     Disabled %s debu
     5a0:	67 0d 0a 00                                         g...

000005a4 <cmd_help>:
     5a4:	68 65 6c 70 00                                      help.

000005a9 <cmd_status>:
     5a9:	73 74 61 74 75 73 00                                status.

000005b0 <cmd_enc_stat>:
     5b0:	65 6e 63 73 74 61 74 00                             encstat.

000005b8 <cmd_time>:
     5b8:	74 69 6d 65 00                                      time.

000005bd <cmd_net_dbg>:
     5bd:	64 65 62 75 67 00                                   debug.

000005c3 <cmd_rping>:
     5c3:	72 70 69 6e 67 00                                   rping.

000005c9 <cmd_ping>:
     5c9:	70 69 6e 67 00                                      ping.

000005ce <cmd_xRec>:
     5ce:	78 72 65 63 00                                      xrec.

000005d3 <cmd_xSend>:
     5d3:	78 73 65 6e 64 00                                   xsend.

000005d9 <cmd_xflash>:
     5d9:	78 66 6c 61 73 68 00                                xflash.

000005e0 <cmd_dir_rf>:
     5e0:	64 69 72 72 66 00                                   dirrf.

000005e6 <cmd_create_rf>:
     5e6:	63 72 66 00                                         crf.

000005ea <cmd_erase_rf>:
     5ea:	65 72 61 73 65 72 66 00                             eraserf.

000005f2 <cmd_edit_rf>:
     5f2:	65 64 69 74 72 66 00                                editrf.

000005f9 <cmd_read_rf>:
     5f9:	72 65 61 64 72 66 00                                readrf.

00000600 <cmd_up>:
     600:	75 70 00                                            up.

00000603 <cmd_down>:
     603:	64 6f 77 6e 00                                      down.

00000608 <cmd_spa>:
     608:	73 70 61 00                                         spa.

0000060c <cmd_spb>:
     60c:	73 70 62 00                                         spb.

00000610 <cmd_settime>:
     610:	73 65 74 74 69 6d 65 00                             settime.

00000618 <cmd_ac>:
     618:	61 63 00                                            ac.

0000061b <cmd_enable>:
     61b:	65 6e 61 62 6c 65 00                                enable.

00000622 <cmd_disable>:
     622:	64 69 73 61 62 6c 65 00                             disable.

0000062a <cmd_configure>:
     62a:	63 6f 6e 66 69 67 00                                config.

00000631 <cmd_conf_ip>:
     631:	69 70 00                                            ip.

00000634 <cmd_conf_udp>:
     634:	75 64 70 00                                         udp.

00000638 <cmd_conf_ip_mask>:
     638:	6d 61 73 6b 00                                      mask.

0000063d <cmd_conf_ip_gw>:
     63d:	67 77 00                                            gw.

00000640 <cmd_conf_mac>:
     640:	6d 61 63 00                                         mac.

00000644 <cmd_conf_save>:
     644:	73 61 76 65 00                                      save.

00000649 <cmd_ustawR>:
     649:	73 65 74 72 00                                      setr.

0000064e <okStr>:
     64e:	4f 4b 0d 0a 00                                      OK...

00000653 <nlStr>:
     653:	0d 0a 00                                            ...

00000656 <BladBuforaPozostaloBajtowStr>:
     656:	21 21 21 20 57 20 62 75 64 6f 72 7a 65 20 52 73     !!! W budorze Rs
     666:	34 38 35 20 70 6f 7a 6f 73 74 61 6c 6f 20 25 64     485 pozostalo %d
     676:	20 62 61 6a 74 6f 77 0d 0a 00                        bajtow...

00000680 <errorStrings>:
     680:	30 02 39 02 43 02 46 02 49 02 4c 02 4f 02 62 02     0.9.C.F.I.L.O.b.
     690:	89 02 a8 02 cb 02 ea 02                             ........

00000698 <cmdListNormal>:
     698:	a4 05 03 20 95 16 a9 05 15 20 68 19 b8 05 66 20     ... ..... h...f 
     6a8:	3e 16 c3 05 ba 20 70 17 c9 05 e0 20 a2 0e e0 05     >.... p.... ....
     6b8:	92 21 36 16 f9 05 11 22 9d 15 1b 06 f1 22 38 0e     .!6...."....."8.
     6c8:	00 00 00 00 00 00                                   ......

000006ce <cmdListConfigure>:
     6ce:	a4 05 03 20 95 16 a9 05 15 20 68 19 b8 05 66 20     ... ..... h...f 
     6de:	3e 16 10 06 af 22 58 10 31 06 16 23 c2 0f 38 06     >...."X.1..#..8.
     6ee:	87 23 a3 0f 3d 06 97 23 49 0f 34 06 39 23 c1 0e     .#..=..#I.4.9#..
     6fe:	40 06 bf 23 6b 0e 44 06 ed 23 66 0e 1b 06 f1 22     @..#k.D..#f...."
     70e:	38 0e 22 06 fd 22 49 0e 00 00 00 00 00 00           8.".."I.......

0000071c <__c.5350>:
     71c:	57 61 72 74 6f 73 63 20 70 72 6f 62 6b 69 20 6e     Wartosc probki n
     72c:	61 20 77 65 6a 73 63 69 75 20 25 64 3a 20 25 64     a wejsciu %d: %d
     73c:	0d 0a 00                                            ...

0000073f <__c.5401>:
     73f:	58 6d 6f 64 65 6d 3a 20 72 6f 7a 70 6f 63 7a 79     Xmodem: rozpoczy
     74f:	6e 61 6e 69 65 20 6f 64 62 69 6f 72 75 0d 0a 00     nanie odbioru...

0000075f <__c.5315>:
     75f:	75 64 70 00                                         udp.

00000763 <__c.5313>:
     763:	74 63 70 00                                         tcp.

00000767 <__c.5311>:
     767:	69 63 6d 70 00                                      icmp.

0000076c <__c.5309>:
     76c:	69 70 00                                            ip.

0000076f <__c.5307>:
     76f:	61 72 70 00                                         arp.

00000773 <__c.5305>:
     773:	75 64 70 00                                         udp.

00000777 <__c.5303>:
     777:	74 63 70 00                                         tcp.

0000077b <__c.5301>:
     77b:	69 63 6d 70 00                                      icmp.

00000780 <__c.5299>:
     780:	69 70 00                                            ip.

00000783 <__c.5297>:
     783:	61 72 70 00                                         arp.

00000787 <__c.5290>:
     787:	41 6b 74 75 61 6c 6e 79 20 63 7a 61 73 20 25 64     Aktualny czas %d
     797:	3a 25 64 3a 25 64 0d 0a 00                          :%d:%d...

000007a0 <__c.5275>:
     7a0:	0d 0a 00                                            ...

000007a3 <__c.5273>:
     7a3:	0d 0a 00                                            ...

000007a6 <__c.5271>:
     7a6:	0d 0a 00                                            ...

000007a9 <__c.5269>:
     7a9:	0d 0a 00                                            ...

000007ac <__c.5266>:
     7ac:	46 72 65 65 52 74 6f 73 2b 20 76 65 72 20 30 2e     FreeRtos+ ver 0.
     7bc:	33 31 20 62 75 69 6c 64 3a 20 41 70 72 20 31 34     31 build: Apr 14
     7cc:	20 32 30 31 33 2c 20 32 30 3a 32 38 3a 32 31 0d      2013, 20:28:21.
     7dc:	0a 00                                               ..

000007de <__c.5076>:
     7de:	55 6e 6b 6e 6f 77 6e 20 70 61 63 6b 65 74 0d 0a     Unknown packet..
	...

000007ef <__c.3756>:
     7ef:	52 65 73 74 61 72 74 0d 0a 00                       Restart...

000007f9 <CmdlinePromptNormal>:
     7f9:	44 6f 6d 4f 73 3e 00                                DomOs>.

00000800 <CmdlinePromptEnable>:
     800:	44 6f 6d 4f 73 23 00                                DomOs#.

00000807 <CmdlinePromptConfigure>:
     807:	44 6f 6d 4f 73 40 00                                DomOs@.

0000080e <CmdlineNotice>:
     80e:	63 6d 64 6c 69 6e 65 3a 20 00                       cmdline: .

00000818 <CmdlineCmdNotFound>:
     818:	23 20 6e 6b 00                                      # nk.

0000081d <__c.5303>:
     81d:	0d 0a 00                                            ...

00000820 <__c.5301>:
     820:	09 00                                               ..

00000822 <__c.5213>:
     822:	4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 61 6c     Operation not al
     832:	6c 6f 77 65 64 0d 0a 00                             lowed...

0000083a <__c.5210>:
     83a:	4f 70 65 72 61 74 69 6f 6e 20 66 61 69 6c 65 64     Operation failed
     84a:	0d 0a 00                                            ...

0000084d <__c.5207>:
     84d:	0d 0a 00                                            ...

00000850 <__c.5205>:
     850:	20 00                                                .

00000852 <__c.5203>:
     852:	53 79 6e 74 61 78 20 45 72 72 6f 72 2e 20 55 73     Syntax Error. Us
     862:	65 3a 20 00                                         e: .

00000866 <__c.5199>:
     866:	4f 4b 0d 0a 00                                      OK...

0000086b <__c.5207>:
     86b:	09 4d 41 41 44 52 35 20 30 78 25 78 0d 0a 00        .MAADR5 0x%x...

0000087a <__c.5205>:
     87a:	09 4d 41 41 44 52 34 20 30 78 25 78 0d 0a 00        .MAADR4 0x%x...

00000889 <__c.5203>:
     889:	09 4d 41 41 44 52 33 20 30 78 25 78 0d 0a 00        .MAADR3 0x%x...

00000898 <__c.5201>:
     898:	09 4d 41 41 44 52 32 20 30 78 25 78 0d 0a 00        .MAADR2 0x%x...

000008a7 <__c.5199>:
     8a7:	09 4d 41 41 44 52 31 20 30 78 25 78 0d 0a 00        .MAADR1 0x%x...

000008b6 <__c.5197>:
     8b6:	09 4d 41 41 44 52 30 20 30 78 25 78 0d 0a 00        .MAADR0 0x%x...

000008c5 <__c.5195>:
     8c5:	45 4e 43 32 38 6a 36 30 20 73 74 61 6e 20 72 65     ENC28j60 stan re
     8d5:	6a 65 73 74 72 6f 77 3a 0d 0a 00                    jestrow:...

000008e0 <__c.3740>:
     8e0:	4e 49 43 20 72 65 67 20 64 75 6d 70 20 6e 6f 74     NIC reg dump not
     8f0:	20 69 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00         implemented...

000008ff <__c.3601>:
     8ff:	0d 0a 00                                            ...

00000902 <__c.3599>:
     902:	55 52 47 20 00                                      URG .

00000907 <__c.3597>:
     907:	41 43 4b 20 00                                      ACK .

0000090c <__c.3595>:
     90c:	50 53 48 20 00                                      PSH .

00000911 <__c.3593>:
     911:	52 53 54 20 00                                      RST .

00000916 <__c.3591>:
     916:	53 59 4e 20 00                                      SYN .

0000091b <__c.3589>:
     91b:	46 49 4e 20 00                                      FIN .

00000920 <__c.3587>:
     920:	46 6c 61 67 73 20 20 20 3a 20 00                    Flags   : .

0000092b <__c.3585>:
     92b:	41 63 6b 20 4e 75 6d 20 3a 20 30 78 25 78 0d 0a     Ack Num : 0x%x..
	...

0000093c <__c.3583>:
     93c:	53 65 71 20 4e 75 6d 20 3a 20 30 78 25 78 00        Seq Num : 0x%x.

0000094b <__c.3581>:
     94b:	44 73 74 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Dst Port: %d...

0000095a <__c.3579>:
     95a:	53 72 63 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Src Port: %d...

00000969 <__c.3577>:
     969:	54 43 50 20 48 65 61 64 65 72 0d 0a 00              TCP Header...

00000976 <__c.3571>:
     976:	0d 0a 00                                            ...

00000979 <__c.3569>:
     979:	44 65 73 74 20 20 49 50 3a 20 00                    Dest  IP: .

00000984 <__c.3567>:
     984:	0d 0a 00                                            ...

00000987 <__c.3565>:
     987:	53 6f 75 72 63 65 49 50 3a 20 00                    SourceIP: .

00000992 <__c.3563>:
     992:	50 72 6f 74 6f 63 6f 6c 3a 20 25 64 0d 0a 00        Protocol: %d...

000009a1 <__c.3561>:
     9a1:	50 72 6f 74 6f 63 6f 6c 3a 20 55 44 50 0d 0a 00     Protocol: UDP...

000009b1 <__c.3559>:
     9b1:	50 72 6f 74 6f 63 6f 6c 3a 20 54 43 50 0d 0a 00     Protocol: TCP...

000009c1 <__c.3557>:
     9c1:	50 72 6f 74 6f 63 6f 6c 3a 20 49 43 4d 50 0d 0a     Protocol: ICMP..
	...

000009d2 <__c.3555>:
     9d2:	4c 65 6e 67 74 68 20 20 3a 20 25 64 0d 0a 00        Length  : %d...

000009e1 <__c.3553>:
     9e1:	56 65 72 20 20 20 20 20 3a 20 25 64 0d 0a 00        Ver     : %d...

000009f0 <__c.3551>:
     9f0:	49 50 20 48 65 61 64 65 72 0d 0a 00                 IP Header...

000009fc <__c.3545>:
     9fc:	2d 3e 44 53 54 3a 00                                ->DST:.

00000a03 <__c.3543>:
     a03:	20 53 52 43 3a 00                                    SRC:.

00000a09 <__c.3541>:
     a09:	45 74 68 20 50 61 63 6b 65 74 20 54 79 70 65 3a     Eth Packet Type:
     a19:	20 30 78 25 78 00                                    0x%x.

00000a1f <__c.3535>:
     a1f:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

00000a2b <__c.3529>:
     a2b:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
     a3b:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

00000a49 <__c.4280>:
     a49:	0d 0a 00                                            ...

00000a4c <__c.4278>:
     a4c:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00000a57 <__c.4276>:
     a57:	0d 0a 00                                            ...

00000a5a <__c.4274>:
     a5a:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00000a65 <__c.4272>:
     a65:	0d 0a 00                                            ...

00000a68 <__c.4270>:
     a68:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00000a73 <__c.4264>:
     a73:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     a83:	6c 65 28 6c 65 6e 2d 45 54 48 5f 48 45 41 44 45     le(len-ETH_HEADE
     a93:	52 5f 4c 45 4e 2c 20 26 64 61 74 61 5b 45 54 48     R_LEN, &data[ETH
     aa3:	5f 48 45 41 44 45 52 5f 4c 45 4e 5d 29 3b 00        _HEADER_LEN]);.

00000ab2 <__c.4262>:
     ab2:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     ac2:	6c 65 28 45 54 48 5f 48 45 41 44 45 52 5f 4c 45     le(ETH_HEADER_LE
     ad2:	4e 2c 20 26 64 61 74 61 5b 30 5d 29 3b 00           N, &data[0]);.

00000ae0 <__c.4260>:
     ae0:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     af0:	74 20 74 6f 20 67 61 74 65 77 61 79 0d 0a 00        t to gateway...

00000aff <__c.4258>:
     aff:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     b0f:	74 20 6f 6e 20 6c 6f 63 61 6c 20 6e 65 74 0d 0a     t on local net..
	...

00000b20 <__c.4230>:
     b20:	4e 45 54 20 52 78 3a 20 55 6e 6b 6e 6f 77 6e 20     NET Rx: Unknown 
     b30:	49 50 20 70 61 63 6b 65 74 0d 0a 00                 IP packet...

00000b3c <__c.4228>:
     b3c:	4e 45 54 20 52 78 3a 20 54 43 50 2f 49 50 20 70     NET Rx: TCP/IP p
     b4c:	61 63 6b 65 74 0d 0a 00                             acket...

00000b54 <__c.4226>:
     b54:	4e 45 54 20 52 78 3a 20 55 44 50 2f 49 50 20 70     NET Rx: UDP/IP p
     b64:	61 63 6b 65 74 0d 0a 00                             acket...

00000b6c <__c.4224>:
     b6c:	4e 45 54 20 52 78 3a 20 49 43 4d 50 2f 49 50 20     NET Rx: ICMP/IP 
     b7c:	70 61 63 6b 65 74 0d 0a 00                          packet...

00000b85 <__c.4262>:
     b85:	43 6f 64 65 20 20 20 3a 20 30 78 25 78 0d 0a 00     Code   : 0x%x...

00000b95 <__c.4260>:
     b95:	0d 0a 00                                            ...

00000b98 <__c.4257>:
     b98:	45 43 48 4f 20 52 45 50 4c 59 00                    ECHO REPLY.

00000ba3 <__c.4253>:
     ba3:	45 43 48 4f 20 52 45 51 55 45 53 54 00              ECHO REQUEST.

00000bb0 <__c.4250>:
     bb0:	54 79 70 65 20 20 20 3a 20 00                       Type   : .

00000bba <__c.4248>:
     bba:	0d 0a 00                                            ...

00000bbd <__c.4246>:
     bbd:	44 73 74 49 70 41 64 64 72 3a 20 00                 DstIpAddr: .

00000bc9 <__c.4244>:
     bc9:	0d 0a 00                                            ...

00000bcc <__c.4242>:
     bcc:	53 72 63 49 70 41 64 64 72 3a 20 00                 SrcIpAddr: .

00000bd8 <__c.4240>:
     bd8:	49 43 4d 50 20 50 61 63 6b 65 74 3a 0d 0a 00        ICMP Packet:...

00000be7 <__c.4229>:
     be7:	53 65 6e 64 69 6e 67 20 49 43 4d 50 20 50 4f 4e     Sending ICMP PON
     bf7:	47 0d 0a 00                                         G...

00000bfb <__c.4226>:
     bfb:	52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72 65     Received ICMP re
     c0b:	71 75 65 73 74 3a 20 00                             quest: .

00000c13 <__c.4221>:
     c13:	55 6e 6b 6e 6f 77 6e 20 49 43 4d 50 20 74 79 70     Unknown ICMP typ
     c23:	65 52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72     eReceived ICMP r
     c33:	65 71 75 65 73 74 3a 20 00                          equest: .

00000c3c <__c.4312>:
     c3c:	0d 0a 00                                            ...

00000c3f <__c.4310>:
     c3f:	20 20 00                                              .

00000c42 <__c.4308>:
     c42:	25 33 64 20 20 00                                   %3d  .

00000c48 <__c.4305>:
     c48:	0d 0a 00                                            ...

00000c4b <__c.4303>:
     c4b:	20 20 00                                              .

00000c4e <__c.4301>:
     c4e:	20 4d 59 20 20 00                                    MY  .

00000c54 <__c.4299>:
     c54:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     c64:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     c74:	2d 2d 2d 0d 0a 00                                   ---...

00000c7a <__c.4297>:
     c7a:	54 69 6d 65 20 45 74 68 20 41 64 64 72 65 73 73     Time Eth Address
     c8a:	20 20 20 20 20 20 20 20 49 50 20 41 64 64 72 65             IP Addre
     c9a:	73 73 0d 0a 00                                      ss...

00000c9f <__c.4291>:
     c9f:	0d 0a 00                                            ...

00000ca2 <__c.4289>:
     ca2:	44 73 74 50 72 6f 74 6f 41 64 64 72 3a 20 00        DstProtoAddr: .

00000cb1 <__c.4287>:
     cb1:	0d 0a 00                                            ...

00000cb4 <__c.4285>:
     cb4:	44 73 74 48 77 41 64 64 72 20 20 20 3a 20 00        DstHwAddr   : .

00000cc3 <__c.4283>:
     cc3:	0d 0a 00                                            ...

00000cc6 <__c.4281>:
     cc6:	53 72 63 50 72 6f 74 6f 41 64 64 72 3a 20 00        SrcProtoAddr: .

00000cd5 <__c.4279>:
     cd5:	0d 0a 00                                            ...

00000cd8 <__c.4277>:
     cd8:	53 72 63 48 77 41 64 64 72 20 20 20 3a 20 00        SrcHwAddr   : .

00000ce7 <__c.4275>:
     ce7:	0d 0a 00                                            ...

00000cea <__c.4273>:
     cea:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

00000cf2 <__c.4271>:
     cf2:	52 45 50 4c 59 00                                   REPLY.

00000cf8 <__c.4269>:
     cf8:	52 45 51 55 45 53 54 00                             REQUEST.

00000d00 <__c.4267>:
     d00:	4f 70 65 72 61 74 69 6f 6e 20 20 20 3a 20 00        Operation   : .

00000d0f <__c.4265>:
     d0f:	41 52 50 20 50 61 63 6b 65 74 3a 0d 0a 00           ARP Packet:...

00000d1d <__c.4237>:
     d1d:	0d 0a 00                                            ...

00000d20 <__c.4235>:
     d20:	20 49 50 3a 20 00                                    IP: .

00000d26 <__c.4233>:
     d26:	41 52 50 20 49 50 20 69 6e 20 4d 41 43 3a 20 00     ARP IP in MAC: .

00000d36 <__c.4228>:
     d36:	53 65 6e 64 69 6e 67 20 41 52 50 20 52 65 70 6c     Sending ARP Repl
     d46:	79 0d 0a 00                                         y...

00000d4a <__c.4226>:
     d4a:	52 65 63 65 69 76 65 64 20 41 52 50 20 52 65 71     Received ARP Req
     d5a:	75 65 73 74 0d 0a 00                                uest...

00000d61 <__c.4269>:
     d61:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
     d71:	6e 74 65 64 0d 0a 00                                nted...

00000d78 <__c.4255>:
     d78:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     d88:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
     d98:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
     da8:	74 0d 0a 00                                         t...

00000dac <__c.4253>:
     dac:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     dbc:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
     dcc:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
     ddc:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
     dec:	49 53 48 45 44 0d 0a 00                             ISHED...

00000df4 <__c.4251>:
     df4:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     e04:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
     e14:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
     e24:	74 0d 0a 00                                         t...

00000e28 <__c.4249>:
     e28:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     e38:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
     e48:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
     e58:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
     e68:	0a 00                                               ..

00000e6a <__c.4240>:
     e6a:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
     e7a:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
     e8a:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

00000e94 <__c.4235>:
     e94:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
     ea4:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
     eb4:	54 45 4e 0d 0a 00                                   TEN...

00000eba <__c.4230>:
     eba:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
     eca:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

00000ed6 <__c.4268>:
     ed6:	25 64 0d 0a 00                                      %d...

00000edb <__c.4266>:
     edb:	41 4e 59 0d 0a 00                                   ANY...

00000ee1 <__c.4264>:
     ee1:	0d 0a 20 20 73 72 63 20 70 6f 72 74 20 20 20 20     ..  src port    
     ef1:	3a 20 25 64 0d 0a 20 20 64 73 74 20 70 6f 72 74     : %d..  dst port
     f01:	20 20 20 20 3a 20 00                                    : .

00000f08 <__c.4262>:
     f08:	0d 0a 20 20 49 50 20 20 20 20 20 20 20 20 20 20     ..  IP          
     f18:	3a 20 00                                            : .

00000f1b <__c.4260>:
     f1b:	55 44 50 20 63 6f 6e 66 69 67 3a 00                 UDP config:.

00000f27 <__c.4244>:
     f27:	0d 0a 00                                            ...

00000f2a <__c.4239>:
     f2a:	55 44 50 20 54 58 20 62 75 66 66 65 72 20 62 75     UDP TX buffer bu
     f3a:	73 79 0d 0a 00                                      sy...

00000f3f <__c.4237>:
     f3f:	30 78 25 32 78 0d 0a 00                             0x%2x...

00000f47 <__c.4235>:
     f47:	52 65 63 65 69 76 65 64 20 64 61 74 61 3a 20 00     Received data: .

00000f57 <__c.4232>:
     f57:	50 72 6f 63 2e 20 55 44 50 20 70 61 63 6b 65 74     Proc. UDP packet
     f67:	20 28 64 61 74 61 20 6c 65 6e 67 74 68 20 25 64      (data length %d
     f77:	29 0d 0a 00                                         )...

00000f7b <__c.4225>:
     f7b:	53 65 6e 64 69 6e 67 20 55 44 50 20 70 61 63 6b     Sending UDP pack
     f8b:	65 74 20 28 64 61 74 61 20 6c 65 6e 67 74 68 20     et (data length 
     f9b:	25 64 29 0d 0a 00                                   %d)...

00000fa1 <statusRollerDescStr>:
     fa1:	20 25 64 20 72 6f 6c 6c 65 72 20 64 72 69 76 65      %d roller drive
     fb1:	72 3a 20 72 6f 6c 6c 65 72 20 31 20 70 6f 73 69     r: roller 1 posi
     fc1:	74 69 6f 6e 20 25 64 2c 20 72 6f 6c 6c 65 72 20     tion %d, roller 
     fd1:	32 20 70 6f 73 69 74 69 6f 6e 20 25 64 00           2 position %d.

00000fdf <statusRollerDescStr2>:
     fdf:	2c 20 66 69 72 6d 77 61 72 65 20 25 73 0d 0a 00     , firmware %s...

00000fef <__c.5187>:
     fef:	62 6f 6f 74 6c 6f 61 64 65 72 20 6e 69 65 20 72     bootloader nie r
     fff:	6f 7a 70 6f 63 7a 61 6c 20 6f 64 62 69 6f 72 75     ozpoczal odbioru
    100f:	20 64 61 6e 79 63 68 0d 0a 00                        danych...

00001019 <__c.5185>:
    1019:	6e 61 20 75 72 7a 61 64 7a 65 6e 69 75 20 77 67     na urzadzeniu wg
    1029:	72 61 6e 79 20 6a 65 73 74 20 74 79 6c 6b 6f 20     rany jest tylko 
    1039:	62 6f 6f 74 6c 6f 61 64 65 72 0d 0a 00              bootloader...

00001046 <__c.5183>:
    1046:	72 46 4c 41 53 48 20 74 69 6d 65 6f 75 74 0d 0a     rFLASH timeout..
	...

00001058 <__ctors_end>:
    1058:	11 24       	eor	r1, r1
    105a:	1f be       	out	0x3f, r1	; 63
    105c:	cf ef       	ldi	r28, 0xFF	; 255
    105e:	df e3       	ldi	r29, 0x3F	; 63
    1060:	de bf       	out	0x3e, r29	; 62
    1062:	cd bf       	out	0x3d, r28	; 61
    1064:	00 e0       	ldi	r16, 0x00	; 0
    1066:	0c bf       	out	0x3c, r16	; 60
    1068:	18 be       	out	0x38, r1	; 56
    106a:	19 be       	out	0x39, r1	; 57
    106c:	1a be       	out	0x3a, r1	; 58
    106e:	1b be       	out	0x3b, r1	; 59

00001070 <__do_copy_data>:
    1070:	15 e2       	ldi	r17, 0x25	; 37
    1072:	a0 e0       	ldi	r26, 0x00	; 0
    1074:	b0 e2       	ldi	r27, 0x20	; 32
    1076:	e8 e8       	ldi	r30, 0x88	; 136
    1078:	f6 eb       	ldi	r31, 0xB6	; 182
    107a:	00 e0       	ldi	r16, 0x00	; 0
    107c:	0b bf       	out	0x3b, r16	; 59
    107e:	02 c0       	rjmp	.+4      	; 0x1084 <__do_copy_data+0x14>
    1080:	07 90       	elpm	r0, Z+
    1082:	0d 92       	st	X+, r0
    1084:	aa 34       	cpi	r26, 0x4A	; 74
    1086:	b1 07       	cpc	r27, r17
    1088:	d9 f7       	brne	.-10     	; 0x1080 <__do_copy_data+0x10>

0000108a <__do_clear_bss>:
    108a:	13 e3       	ldi	r17, 0x33	; 51
    108c:	aa e4       	ldi	r26, 0x4A	; 74
    108e:	b5 e2       	ldi	r27, 0x25	; 37
    1090:	01 c0       	rjmp	.+2      	; 0x1094 <.do_clear_bss_start>

00001092 <.do_clear_bss_loop>:
    1092:	1d 92       	st	X+, r1

00001094 <.do_clear_bss_start>:
    1094:	a4 34       	cpi	r26, 0x44	; 68
    1096:	b1 07       	cpc	r27, r17
    1098:	e1 f7       	brne	.-8      	; 0x1092 <.do_clear_bss_loop>
    109a:	0e 94 53 08 	call	0x10a6	; 0x10a6 <main>
    109e:	0c 94 42 5b 	jmp	0xb684	; 0xb684 <_exit>

000010a2 <__bad_interrupt>:
    10a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000010a6 <main>:
FILE udpStream;

streamBuffers_t udpBuffers;

portSHORT main( void )
{
    10a6:	af 92       	push	r10
    10a8:	bf 92       	push	r11
    10aa:	cf 92       	push	r12
    10ac:	df 92       	push	r13
    10ae:	ef 92       	push	r14
    10b0:	ff 92       	push	r15
    10b2:	0f 93       	push	r16
  //ramDyskInit();              //Inicjalizacja Ram dysku
  //hardwareInit();
  //spiInit(disableAllSpiDevices);
  // MOJE
  /* konfiguracja zewnętrznego kwarcu, bez PLL, Pres ABCD=1*/
	OSC.XOSCCTRL=0b1101011;
    10b4:	8b e6       	ldi	r24, 0x6B	; 107
    10b6:	e0 e5       	ldi	r30, 0x50	; 80
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	82 83       	std	Z+2, r24	; 0x02
	OSC.CTRL=0b00001000;
    10bc:	88 e0       	ldi	r24, 0x08	; 8
    10be:	80 93 50 00 	sts	0x0050, r24
	while(!(OSC.STATUS & OSC_XOSCEN_bm));
    10c2:	80 91 51 00 	lds	r24, 0x0051
    10c6:	83 ff       	sbrs	r24, 3
    10c8:	fc cf       	rjmp	.-8      	; 0x10c2 <main+0x1c>
	CCP = CCP_IOREG_gc;
    10ca:	88 ed       	ldi	r24, 0xD8	; 216
    10cc:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL=CLK_SCLKSEL_XOSC_gc;
    10ce:	83 e0       	ldi	r24, 0x03	; 3
    10d0:	80 93 40 00 	sts	0x0040, r24
	// Koniec konfuguracji, Zew kwarc 16MHz
	PORTD.OUT=0xFF; //ok
    10d4:	e0 e6       	ldi	r30, 0x60	; 96
    10d6:	f6 e0       	ldi	r31, 0x06	; 6
    10d8:	9f ef       	ldi	r25, 0xFF	; 255
    10da:	94 83       	std	Z+4, r25	; 0x04
	PORTD.DIR=PIN3_bm;//ok
    10dc:	98 e0       	ldi	r25, 0x08	; 8
    10de:	90 93 60 06 	sts	0x0660, r25
	PORTD.DIRCLR = PIN2_bm;//ok
    10e2:	94 e0       	ldi	r25, 0x04	; 4
    10e4:	92 83       	std	Z+2, r25	; 0x02
	USARTD0.CTRLC=0b00000011;//ok
    10e6:	e0 ea       	ldi	r30, 0xA0	; 160
    10e8:	f9 e0       	ldi	r31, 0x09	; 9
    10ea:	85 83       	std	Z+5, r24	; 0x05
	USARTD0.CTRLA|=(USART_RXCINTLVL_LO_gc)|(USART_TXCINTLVL_LO_gc);
    10ec:	80 91 a3 09 	lds	r24, 0x09A3
    10f0:	84 61       	ori	r24, 0x14	; 20
    10f2:	83 83       	std	Z+3, r24	; 0x03
	USARTD0.BAUDCTRLA=0b01100111;//12;
    10f4:	87 e6       	ldi	r24, 0x67	; 103
    10f6:	86 83       	std	Z+6, r24	; 0x06
	USARTD0.BAUDCTRLB=0;//(0 << USART_BSCALE0_bp)|(12 >> 8);
    10f8:	17 82       	std	Z+7, r1	; 0x07
	USARTD0.CTRLB=0b00011000;
    10fa:	88 e1       	ldi	r24, 0x18	; 24
    10fc:	84 83       	std	Z+4, r24	; 0x04
	lcdinit();
    10fe:	0e 94 1e 1b 	call	0x363c	; 0x363c <lcdinit>
  //MOJE
// VTY on serial  
  //xSerialPortInitMinimal(); 
  CLIStateSerialUsb  = xmalloc(sizeof(cmdState_t));
    1102:	83 e2       	ldi	r24, 0x23	; 35
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	0e 94 22 1c 	call	0x3844	; 0x3844 <xmalloc>
    110a:	80 93 fe 31 	sts	0x31FE, r24
    110e:	90 93 ff 31 	sts	0x31FF, r25
  CLIStateSerialUdp  = xmalloc(sizeof(cmdState_t));
    1112:	83 e2       	ldi	r24, 0x23	; 35
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	0e 94 22 1c 	call	0x3844	; 0x3844 <xmalloc>
    111a:	80 93 c0 32 	sts	0x32C0, r24
    111e:	90 93 c1 32 	sts	0x32C1, r25
 // socketInit();
 // initQueueStream(&udpStream, &udpBuffers, udpSocket->Rx, udpSocket->Tx);
 // VtyInit(CLIStateSerialUdp, &udpStream);
  
//xTaskCreate(encTask,        NULL /*"ENC"    */, STACK_SIZE_ENC,       (void *)CLIStateSerialUsb->myStdInOut,  0, &xHandleEnc);
  xTaskCreate(vTaskVTYusb,    NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUsb),            1, &xHandleVTY_USB);
    1122:	20 91 fe 31 	lds	r18, 0x31FE
    1126:	30 91 ff 31 	lds	r19, 0x31FF
    112a:	8a e1       	ldi	r24, 0x1A	; 26
    112c:	9a e1       	ldi	r25, 0x1A	; 26
    112e:	60 e0       	ldi	r22, 0x00	; 0
    1130:	70 e0       	ldi	r23, 0x00	; 0
    1132:	4c eb       	ldi	r20, 0xBC	; 188
    1134:	52 e0       	ldi	r21, 0x02	; 2
    1136:	01 e0       	ldi	r16, 0x01	; 1
    1138:	fc e1       	ldi	r31, 0x1C	; 28
    113a:	ef 2e       	mov	r14, r31
    113c:	f2 e3       	ldi	r31, 0x32	; 50
    113e:	ff 2e       	mov	r15, r31
    1140:	cc 24       	eor	r12, r12
    1142:	dd 24       	eor	r13, r13
    1144:	aa 24       	eor	r10, r10
    1146:	bb 24       	eor	r11, r11
    1148:	0e 94 2e 46 	call	0x8c5c	; 0x8c5c <xTaskGenericCreate>
//xTaskCreate(vTaskVTYsocket, NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUdp),            1, &xHandleVTY_UDP);
//xTaskCreate(sensorsTask,    NULL /*"Sensors"*/, STACK_SIZE_SENSORS,   NULL,                                   1, &xHandleSensors);
  xTaskCreate(vTaskUSB,NULL,100,NULL,0,&xHandleUSB);
    114c:	83 e5       	ldi	r24, 0x53	; 83
    114e:	9a e1       	ldi	r25, 0x1A	; 26
    1150:	60 e0       	ldi	r22, 0x00	; 0
    1152:	70 e0       	ldi	r23, 0x00	; 0
    1154:	44 e6       	ldi	r20, 0x64	; 100
    1156:	50 e0       	ldi	r21, 0x00	; 0
    1158:	20 e0       	ldi	r18, 0x00	; 0
    115a:	30 e0       	ldi	r19, 0x00	; 0
    115c:	00 e0       	ldi	r16, 0x00	; 0
    115e:	ea ee       	ldi	r30, 0xEA	; 234
    1160:	ee 2e       	mov	r14, r30
    1162:	e1 e3       	ldi	r30, 0x31	; 49
    1164:	fe 2e       	mov	r15, r30
    1166:	0e 94 2e 46 	call	0x8c5c	; 0x8c5c <xTaskGenericCreate>
  vTaskStartScheduler();
    116a:	0e 94 98 48 	call	0x9130	; 0x9130 <vTaskStartScheduler>
  return 0;
}
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	0f 91       	pop	r16
    1174:	ff 90       	pop	r15
    1176:	ef 90       	pop	r14
    1178:	df 90       	pop	r13
    117a:	cf 90       	pop	r12
    117c:	bf 90       	pop	r11
    117e:	af 90       	pop	r10
    1180:	08 95       	ret

00001182 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
    1182:	0e 94 35 51 	call	0xa26a	; 0xa26a <vCoRoutineSchedule>
    1186:	fd cf       	rjmp	.-6      	; 0x1182 <vApplicationIdleHook>

00001188 <vApplicationTickHook>:
}

void vApplicationTickHook( void )
{
  static uint16_t tickCntr = configTICK_RATE_HZ;
  if (--tickCntr == 0)
    1188:	80 91 00 20 	lds	r24, 0x2000
    118c:	90 91 01 20 	lds	r25, 0x2001
    1190:	01 97       	sbiw	r24, 0x01	; 1
    1192:	80 93 00 20 	sts	0x2000, r24
    1196:	90 93 01 20 	sts	0x2001, r25
    119a:	00 97       	sbiw	r24, 0x00	; 0
    119c:	41 f4       	brne	.+16     	; 0x11ae <vApplicationTickHook+0x26>
  {
    tickCntr = configTICK_RATE_HZ;
    119e:	88 ee       	ldi	r24, 0xE8	; 232
    11a0:	93 e0       	ldi	r25, 0x03	; 3
    11a2:	80 93 00 20 	sts	0x2000, r24
    11a6:	90 93 01 20 	sts	0x2001, r25
    arpTimer();    
    11aa:	0e 94 15 36 	call	0x6c2a	; 0x6c2a <arpTimer>
    11ae:	08 95       	ret

000011b0 <loadConfiguration>:
                                                                                       {LOCK_SENS_3_ENA, LOCK_SENS_3_THR, 0, 0},
                                                                                       {LOCK_SENS_4_ENA, LOCK_SENS_4_THR, 0, 0}};

void loadConfiguration(void)
{
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
    11b0:	80 91 00 32 	lds	r24, 0x3200
    11b4:	90 91 01 32 	lds	r25, 0x3201
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	70 e0       	ldi	r23, 0x00	; 0
    11bc:	48 e1       	ldi	r20, 0x18	; 24
    11be:	50 e0       	ldi	r21, 0x00	; 0
    11c0:	0e 94 12 5a 	call	0xb424	; 0xb424 <__eerd_block_x128a1>
}
    11c4:	08 95       	ret

000011c6 <saveConfiguration>:

void saveConfiguration(void)
{
  saveNic();
    11c6:	0e 94 fb 2d 	call	0x5bf6	; 0x5bf6 <saveNic>
  ipSaveConfig();
    11ca:	0e 94 c3 31 	call	0x6386	; 0x6386 <ipSaveConfig>
  udpSaveConfig();
    11ce:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <udpSaveConfig>
}
    11d2:	08 95       	ret

000011d4 <VtyGetChar>:
  fdev_set_udata(stream, NULL);
  return;
}

int VtyGetChar(FILE *stream)
{
    11d4:	df 93       	push	r29
    11d6:	cf 93       	push	r28
    11d8:	0f 92       	push	r0
    11da:	cd b7       	in	r28, 0x3d	; 61
    11dc:	de b7       	in	r29, 0x3e	; 62
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    11de:	80 91 0d 32 	lds	r24, 0x320D
    11e2:	90 91 0e 32 	lds	r25, 0x320E
    11e6:	be 01       	movw	r22, r28
    11e8:	6f 5f       	subi	r22, 0xFF	; 255
    11ea:	7f 4f       	sbci	r23, 0xFF	; 255
    11ec:	4f ef       	ldi	r20, 0xFF	; 255
    11ee:	5f ef       	ldi	r21, 0xFF	; 255
    11f0:	20 e0       	ldi	r18, 0x00	; 0
    11f2:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    11f6:	88 23       	and	r24, r24
    11f8:	19 f0       	breq	.+6      	; 0x1200 <VtyGetChar+0x2c>
    return EOF;
  return c;
    11fa:	29 81       	ldd	r18, Y+1	; 0x01
    11fc:	30 e0       	ldi	r19, 0x00	; 0
    11fe:	02 c0       	rjmp	.+4      	; 0x1204 <VtyGetChar+0x30>
int VtyGetChar(FILE *stream)
{
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    return EOF;
    1200:	2f ef       	ldi	r18, 0xFF	; 255
    1202:	3f ef       	ldi	r19, 0xFF	; 255
  return c;
}
    1204:	c9 01       	movw	r24, r18
    1206:	0f 90       	pop	r0
    1208:	cf 91       	pop	r28
    120a:	df 91       	pop	r29
    120c:	08 95       	ret

0000120e <initQueueStreamUSB>:
#define debug 1

/*-----------------------------------------------------------*/

void initQueueStreamUSB(FILE *stream)
{
    120e:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
    1210:	88 ee       	ldi	r24, 0xE8	; 232
    1212:	9a e0       	ldi	r25, 0x0A	; 10
    1214:	80 87       	std	Z+8, r24	; 0x08
    1216:	91 87       	std	Z+9, r25	; 0x09
    1218:	8a ee       	ldi	r24, 0xEA	; 234
    121a:	98 e0       	ldi	r25, 0x08	; 8
    121c:	82 87       	std	Z+10, r24	; 0x0a
    121e:	93 87       	std	Z+11, r25	; 0x0b
    1220:	83 e0       	ldi	r24, 0x03	; 3
    1222:	83 83       	std	Z+3, r24	; 0x03
    1224:	14 86       	std	Z+12, r1	; 0x0c
    1226:	15 86       	std	Z+13, r1	; 0x0d
  fdev_set_udata(stream, NULL);
  return;
}
    1228:	08 95       	ret

0000122a <xSerialPortInitMinimal>:
  return 0;
}

void xSerialPortInitMinimal(void)
{
  portENTER_CRITICAL();
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	f8 94       	cli
    122e:	0f 92       	push	r0
  {
    xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1230:	80 e4       	ldi	r24, 0x40	; 64
    1232:	61 e0       	ldi	r22, 0x01	; 1
    1234:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    1238:	80 93 0d 32 	sts	0x320D, r24
    123c:	90 93 0e 32 	sts	0x320E, r25
    xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1240:	80 e2       	ldi	r24, 0x20	; 32
    1242:	61 e0       	ldi	r22, 0x01	; 1
    1244:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    1248:	80 93 d9 31 	sts	0x31D9, r24
    124c:	90 93 da 31 	sts	0x31DA, r25
    xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1250:	80 e1       	ldi	r24, 0x10	; 16
    1252:	61 e0       	ldi	r22, 0x01	; 1
    1254:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    1258:	80 93 fc 31 	sts	0x31FC, r24
    125c:	90 93 fd 31 	sts	0x31FD, r25
    xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1260:	84 e0       	ldi	r24, 0x04	; 4
    1262:	61 e0       	ldi	r22, 0x01	; 1
    1264:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    1268:	80 93 25 32 	sts	0x3225, r24
    126c:	90 93 26 32 	sts	0x3226, r25
    
    vSemaphoreCreateBinary(xSemaphoreRs485); 
    1270:	81 e0       	ldi	r24, 0x01	; 1
    1272:	60 e0       	ldi	r22, 0x00	; 0
    1274:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    1278:	80 93 0f 32 	sts	0x320F, r24
    127c:	90 93 10 32 	sts	0x3210, r25
    1280:	00 97       	sbiw	r24, 0x00	; 0
    1282:	39 f0       	breq	.+14     	; 0x1292 <xSerialPortInitMinimal+0x68>
    1284:	60 e0       	ldi	r22, 0x00	; 0
    1286:	70 e0       	ldi	r23, 0x00	; 0
    1288:	40 e0       	ldi	r20, 0x00	; 0
    128a:	50 e0       	ldi	r21, 0x00	; 0
    128c:	20 e0       	ldi	r18, 0x00	; 0
    128e:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
    1292:	0f 90       	pop	r0
    1294:	0f be       	out	0x3f, r0	; 63
  UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );      Set the data bits to 8. */
  //UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
  //UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );      Set the data bits to 8. */
  
  return;
}
    1296:	08 95       	ret

00001298 <__vector_119>:

/*-----------------------------------------------------------*/
ISR(USARTF0_RXC_vect)
{
    1298:	1f 92       	push	r1
    129a:	0f 92       	push	r0
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	0f 92       	push	r0
    12a0:	08 b6       	in	r0, 0x38	; 56
    12a2:	0f 92       	push	r0
    12a4:	09 b6       	in	r0, 0x39	; 57
    12a6:	0f 92       	push	r0
    12a8:	0b b6       	in	r0, 0x3b	; 59
    12aa:	0f 92       	push	r0
    12ac:	11 24       	eor	r1, r1
    12ae:	18 be       	out	0x38, r1	; 56
    12b0:	19 be       	out	0x39, r1	; 57
    12b2:	1b be       	out	0x3b, r1	; 59
    12b4:	2f 93       	push	r18
    12b6:	3f 93       	push	r19
    12b8:	4f 93       	push	r20
    12ba:	5f 93       	push	r21
    12bc:	6f 93       	push	r22
    12be:	7f 93       	push	r23
    12c0:	8f 93       	push	r24
    12c2:	9f 93       	push	r25
    12c4:	af 93       	push	r26
    12c6:	bf 93       	push	r27
    12c8:	ef 93       	push	r30
    12ca:	ff 93       	push	r31
    12cc:	df 93       	push	r29
    12ce:	cf 93       	push	r28
    12d0:	0f 92       	push	r0
    12d2:	cd b7       	in	r28, 0x3d	; 61
    12d4:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  signed portCHAR cChar;

  cChar = USARTF0.DATA;//UDR0;
    12d6:	80 91 a0 0b 	lds	r24, 0x0BA0
    12da:	89 83       	std	Y+1, r24	; 0x01

  xHigherPriorityTaskWoken = pdFALSE;
    12dc:	10 92 02 20 	sts	0x2002, r1

//  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
    12e0:	80 91 fc 31 	lds	r24, 0x31FC
    12e4:	90 91 fd 31 	lds	r25, 0x31FD
    12e8:	be 01       	movw	r22, r28
    12ea:	6f 5f       	subi	r22, 0xFF	; 255
    12ec:	7f 4f       	sbci	r23, 0xFF	; 255
    12ee:	42 e0       	ldi	r20, 0x02	; 2
    12f0:	50 e2       	ldi	r21, 0x20	; 32
    12f2:	20 e0       	ldi	r18, 0x00	; 0
    12f4:	0e 94 63 4e 	call	0x9cc6	; 0x9cc6 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    12f8:	80 91 02 20 	lds	r24, 0x2002
    12fc:	88 23       	and	r24, r24
    12fe:	11 f0       	breq	.+4      	; 0x1304 <__vector_119+0x6c>
  {
    taskYIELD();
    1300:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
  }
}
    1304:	0f 90       	pop	r0
    1306:	cf 91       	pop	r28
    1308:	df 91       	pop	r29
    130a:	ff 91       	pop	r31
    130c:	ef 91       	pop	r30
    130e:	bf 91       	pop	r27
    1310:	af 91       	pop	r26
    1312:	9f 91       	pop	r25
    1314:	8f 91       	pop	r24
    1316:	7f 91       	pop	r23
    1318:	6f 91       	pop	r22
    131a:	5f 91       	pop	r21
    131c:	4f 91       	pop	r20
    131e:	3f 91       	pop	r19
    1320:	2f 91       	pop	r18
    1322:	0f 90       	pop	r0
    1324:	0b be       	out	0x3b, r0	; 59
    1326:	0f 90       	pop	r0
    1328:	09 be       	out	0x39, r0	; 57
    132a:	0f 90       	pop	r0
    132c:	08 be       	out	0x38, r0	; 56
    132e:	0f 90       	pop	r0
    1330:	0f be       	out	0x3f, r0	; 63
    1332:	0f 90       	pop	r0
    1334:	1f 90       	pop	r1
    1336:	18 95       	reti

00001338 <uartRs485SendByte>:
    1338:	df 93       	push	r29
    133a:	cf 93       	push	r28
    133c:	0f 92       	push	r0
    133e:	cd b7       	in	r28, 0x3d	; 61
    1340:	de b7       	in	r29, 0x3e	; 62
    1342:	89 83       	std	Y+1, r24	; 0x01
    1344:	80 91 25 32 	lds	r24, 0x3225
    1348:	90 91 26 32 	lds	r25, 0x3226
    134c:	be 01       	movw	r22, r28
    134e:	6f 5f       	subi	r22, 0xFF	; 255
    1350:	7f 4f       	sbci	r23, 0xFF	; 255
    1352:	4f ef       	ldi	r20, 0xFF	; 255
    1354:	5f ef       	ldi	r21, 0xFF	; 255
    1356:	20 e0       	ldi	r18, 0x00	; 0
    1358:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>
    135c:	e0 ea       	ldi	r30, 0xA0	; 160
    135e:	fb e0       	ldi	r31, 0x0B	; 11
    1360:	81 81       	ldd	r24, Z+1	; 0x01
    1362:	80 62       	ori	r24, 0x20	; 32
    1364:	81 83       	std	Z+1, r24	; 0x01
    1366:	0f 90       	pop	r0
    1368:	cf 91       	pop	r28
    136a:	df 91       	pop	r29
    136c:	08 95       	ret

0000136e <rs485Receive>:
    136e:	9c 01       	movw	r18, r24
    1370:	46 2f       	mov	r20, r22
    1372:	80 91 fc 31 	lds	r24, 0x31FC
    1376:	90 91 fd 31 	lds	r25, 0x31FD
    137a:	b9 01       	movw	r22, r18
    137c:	50 e0       	ldi	r21, 0x00	; 0
    137e:	20 e0       	ldi	r18, 0x00	; 0
    1380:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    1384:	08 95       	ret

00001386 <__vector_120>:
{
  return xQueueReceive(xRs485Rec, c, timeout);
}

ISR(USARTF0_DRE_vect) //   USART0_UDRE_vect
{
    1386:	1f 92       	push	r1
    1388:	0f 92       	push	r0
    138a:	0f b6       	in	r0, 0x3f	; 63
    138c:	0f 92       	push	r0
    138e:	08 b6       	in	r0, 0x38	; 56
    1390:	0f 92       	push	r0
    1392:	09 b6       	in	r0, 0x39	; 57
    1394:	0f 92       	push	r0
    1396:	0b b6       	in	r0, 0x3b	; 59
    1398:	0f 92       	push	r0
    139a:	11 24       	eor	r1, r1
    139c:	18 be       	out	0x38, r1	; 56
    139e:	19 be       	out	0x39, r1	; 57
    13a0:	1b be       	out	0x3b, r1	; 59
    13a2:	2f 93       	push	r18
    13a4:	3f 93       	push	r19
    13a6:	4f 93       	push	r20
    13a8:	5f 93       	push	r21
    13aa:	6f 93       	push	r22
    13ac:	7f 93       	push	r23
    13ae:	8f 93       	push	r24
    13b0:	9f 93       	push	r25
    13b2:	af 93       	push	r26
    13b4:	bf 93       	push	r27
    13b6:	ef 93       	push	r30
    13b8:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
    13ba:	80 91 25 32 	lds	r24, 0x3225
    13be:	90 91 26 32 	lds	r25, 0x3226
    13c2:	6e e4       	ldi	r22, 0x4E	; 78
    13c4:	75 e2       	ldi	r23, 0x25	; 37
    13c6:	4f e4       	ldi	r20, 0x4F	; 79
    13c8:	55 e2       	ldi	r21, 0x25	; 37
    13ca:	0e 94 8b 4f 	call	0x9f16	; 0x9f16 <xQueueReceiveFromISR>
    13ce:	81 30       	cpi	r24, 0x01	; 1
    13d0:	59 f4       	brne	.+22     	; 0x13e8 <__vector_120+0x62>
  {
    Rs485TxStart();
    13d2:	80 91 a4 06 	lds	r24, 0x06A4
    13d6:	80 62       	ori	r24, 0x20	; 32
    13d8:	e0 ea       	ldi	r30, 0xA0	; 160
    13da:	f6 e0       	ldi	r31, 0x06	; 6
    13dc:	84 83       	std	Z+4, r24	; 0x04
    USARTF0.DATA = data; 
    13de:	80 91 4e 25 	lds	r24, 0x254E
    13e2:	80 93 a0 0b 	sts	0x0BA0, r24
    13e6:	08 c0       	rjmp	.+16     	; 0x13f8 <__vector_120+0x72>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    13e8:	10 92 4f 25 	sts	0x254F, r1
    vInterruptRs485Off();
    13ec:	80 91 a1 0b 	lds	r24, 0x0BA1
    13f0:	8f 7d       	andi	r24, 0xDF	; 223
    13f2:	e0 ea       	ldi	r30, 0xA0	; 160
    13f4:	fb e0       	ldi	r31, 0x0B	; 11
    13f6:	81 83       	std	Z+1, r24	; 0x01
  }
  if( xHigherPriorityTaskWoken )
    13f8:	80 91 4f 25 	lds	r24, 0x254F
    13fc:	88 23       	and	r24, r24
    13fe:	11 f0       	breq	.+4      	; 0x1404 <__vector_120+0x7e>
  {
    taskYIELD();
    1400:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
  }
}
    1404:	ff 91       	pop	r31
    1406:	ef 91       	pop	r30
    1408:	bf 91       	pop	r27
    140a:	af 91       	pop	r26
    140c:	9f 91       	pop	r25
    140e:	8f 91       	pop	r24
    1410:	7f 91       	pop	r23
    1412:	6f 91       	pop	r22
    1414:	5f 91       	pop	r21
    1416:	4f 91       	pop	r20
    1418:	3f 91       	pop	r19
    141a:	2f 91       	pop	r18
    141c:	0f 90       	pop	r0
    141e:	0b be       	out	0x3b, r0	; 59
    1420:	0f 90       	pop	r0
    1422:	09 be       	out	0x39, r0	; 57
    1424:	0f 90       	pop	r0
    1426:	08 be       	out	0x38, r0	; 56
    1428:	0f 90       	pop	r0
    142a:	0f be       	out	0x3f, r0	; 63
    142c:	0f 90       	pop	r0
    142e:	1f 90       	pop	r1
    1430:	18 95       	reti

00001432 <__vector_121>:

ISR(USARTF0_TXC_vect) //  USART0_TX_vect
{
    1432:	1f 92       	push	r1
    1434:	0f 92       	push	r0
    1436:	0f b6       	in	r0, 0x3f	; 63
    1438:	0f 92       	push	r0
    143a:	08 b6       	in	r0, 0x38	; 56
    143c:	0f 92       	push	r0
    143e:	0b b6       	in	r0, 0x3b	; 59
    1440:	0f 92       	push	r0
    1442:	11 24       	eor	r1, r1
    1444:	18 be       	out	0x38, r1	; 56
    1446:	1b be       	out	0x3b, r1	; 59
    1448:	8f 93       	push	r24
    144a:	ef 93       	push	r30
    144c:	ff 93       	push	r31
  if (!vIsInterruptRs485On())
    144e:	80 91 a1 0b 	lds	r24, 0x0BA1
    1452:	85 fd       	sbrc	r24, 5
    1454:	06 c0       	rjmp	.+12     	; 0x1462 <__vector_121+0x30>
    Rs485TxStop();
    1456:	80 91 a4 06 	lds	r24, 0x06A4
    145a:	8f 7d       	andi	r24, 0xDF	; 223
    145c:	e0 ea       	ldi	r30, 0xA0	; 160
    145e:	f6 e0       	ldi	r31, 0x06	; 6
    1460:	84 83       	std	Z+4, r24	; 0x04
}
    1462:	ff 91       	pop	r31
    1464:	ef 91       	pop	r30
    1466:	8f 91       	pop	r24
    1468:	0f 90       	pop	r0
    146a:	0b be       	out	0x3b, r0	; 59
    146c:	0f 90       	pop	r0
    146e:	08 be       	out	0x38, r0	; 56
    1470:	0f 90       	pop	r0
    1472:	0f be       	out	0x3f, r0	; 63
    1474:	0f 90       	pop	r0
    1476:	1f 90       	pop	r1
    1478:	18 95       	reti

0000147a <flushRs485RecBuffer>:
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	df 93       	push	r29
    1482:	cf 93       	push	r28
    1484:	0f 92       	push	r0
    1486:	cd b7       	in	r28, 0x3d	; 61
    1488:	de b7       	in	r29, 0x3e	; 62
    148a:	ff 24       	eor	r15, r15
    148c:	8e 01       	movw	r16, r28
    148e:	0f 5f       	subi	r16, 0xFF	; 255
    1490:	1f 4f       	sbci	r17, 0xFF	; 255
    1492:	01 c0       	rjmp	.+2      	; 0x1496 <flushRs485RecBuffer+0x1c>
    1494:	f3 94       	inc	r15
    1496:	80 91 fc 31 	lds	r24, 0x31FC
    149a:	90 91 fd 31 	lds	r25, 0x31FD
    149e:	b8 01       	movw	r22, r16
    14a0:	4a e0       	ldi	r20, 0x0A	; 10
    14a2:	50 e0       	ldi	r21, 0x00	; 0
    14a4:	20 e0       	ldi	r18, 0x00	; 0
    14a6:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    14aa:	81 30       	cpi	r24, 0x01	; 1
    14ac:	99 f3       	breq	.-26     	; 0x1494 <flushRs485RecBuffer+0x1a>
    14ae:	8f 2d       	mov	r24, r15
    14b0:	0f 90       	pop	r0
    14b2:	cf 91       	pop	r28
    14b4:	df 91       	pop	r29
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	ff 90       	pop	r15
    14bc:	08 95       	ret

000014be <takeRs485>:
    14be:	80 91 0f 32 	lds	r24, 0x320F
    14c2:	90 91 10 32 	lds	r25, 0x3210
    14c6:	60 e0       	ldi	r22, 0x00	; 0
    14c8:	70 e0       	ldi	r23, 0x00	; 0
    14ca:	4f ef       	ldi	r20, 0xFF	; 255
    14cc:	5f ef       	ldi	r21, 0xFF	; 255
    14ce:	20 e0       	ldi	r18, 0x00	; 0
    14d0:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    14d4:	08 95       	ret

000014d6 <releaseRs485>:
    14d6:	80 91 0f 32 	lds	r24, 0x320F
    14da:	90 91 10 32 	lds	r25, 0x3210
    14de:	60 e0       	ldi	r22, 0x00	; 0
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	40 e0       	ldi	r20, 0x00	; 0
    14e4:	50 e0       	ldi	r21, 0x00	; 0
    14e6:	20 e0       	ldi	r18, 0x00	; 0
    14e8:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>
    14ec:	08 95       	ret

000014ee <InterruptVtyOn>:
}

void InterruptVtyOn(void)
{                                  
  unsigned portCHAR ucByte;                                       
  ucByte = USARTD0.STATUS;//UCSR1B;                 
    14ee:	e0 ea       	ldi	r30, 0xA0	; 160
    14f0:	f9 e0       	ldi	r31, 0x09	; 9
    14f2:	81 81       	ldd	r24, Z+1	; 0x01
  ucByte |= serDATA_INT_ENABLE;    
    14f4:	80 62       	ori	r24, 0x20	; 32
 // UCSR1B = ucByte;       
  USARTD0.STATUS=ucByte;
    14f6:	81 83       	std	Z+1, r24	; 0x01
}
    14f8:	08 95       	ret

000014fa <__vector_88>:

/*-----------------------------------------------------------*/
ISR(USARTD0_RXC_vect)//  USART1_RX_vect
{
    14fa:	1f 92       	push	r1
    14fc:	0f 92       	push	r0
    14fe:	0f b6       	in	r0, 0x3f	; 63
    1500:	0f 92       	push	r0
    1502:	08 b6       	in	r0, 0x38	; 56
    1504:	0f 92       	push	r0
    1506:	09 b6       	in	r0, 0x39	; 57
    1508:	0f 92       	push	r0
    150a:	0b b6       	in	r0, 0x3b	; 59
    150c:	0f 92       	push	r0
    150e:	11 24       	eor	r1, r1
    1510:	18 be       	out	0x38, r1	; 56
    1512:	19 be       	out	0x39, r1	; 57
    1514:	1b be       	out	0x3b, r1	; 59
    1516:	2f 93       	push	r18
    1518:	3f 93       	push	r19
    151a:	4f 93       	push	r20
    151c:	5f 93       	push	r21
    151e:	6f 93       	push	r22
    1520:	7f 93       	push	r23
    1522:	8f 93       	push	r24
    1524:	9f 93       	push	r25
    1526:	af 93       	push	r26
    1528:	bf 93       	push	r27
    152a:	ef 93       	push	r30
    152c:	ff 93       	push	r31
    152e:	df 93       	push	r29
    1530:	cf 93       	push	r28
    1532:	0f 92       	push	r0
    1534:	cd b7       	in	r28, 0x3d	; 61
    1536:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  signed portCHAR cChar;

  cChar = USARTD0.DATA;//UDR1;
    1538:	80 91 a0 09 	lds	r24, 0x09A0
    153c:	89 83       	std	Y+1, r24	; 0x01
//  xQueueSendFromISR(xVtyRec, &cChar, NULL);

  xHigherPriorityTaskWoken = pdFALSE;
    153e:	10 92 4d 25 	sts	0x254D, r1
  xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
    1542:	80 91 0d 32 	lds	r24, 0x320D
    1546:	90 91 0e 32 	lds	r25, 0x320E
    154a:	be 01       	movw	r22, r28
    154c:	6f 5f       	subi	r22, 0xFF	; 255
    154e:	7f 4f       	sbci	r23, 0xFF	; 255
    1550:	4d e4       	ldi	r20, 0x4D	; 77
    1552:	55 e2       	ldi	r21, 0x25	; 37
    1554:	20 e0       	ldi	r18, 0x00	; 0
    1556:	0e 94 63 4e 	call	0x9cc6	; 0x9cc6 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    155a:	80 91 4d 25 	lds	r24, 0x254D
    155e:	88 23       	and	r24, r24
    1560:	11 f0       	breq	.+4      	; 0x1566 <__vector_88+0x6c>
  {
    taskYIELD();
    1562:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
  }
}
    1566:	0f 90       	pop	r0
    1568:	cf 91       	pop	r28
    156a:	df 91       	pop	r29
    156c:	ff 91       	pop	r31
    156e:	ef 91       	pop	r30
    1570:	bf 91       	pop	r27
    1572:	af 91       	pop	r26
    1574:	9f 91       	pop	r25
    1576:	8f 91       	pop	r24
    1578:	7f 91       	pop	r23
    157a:	6f 91       	pop	r22
    157c:	5f 91       	pop	r21
    157e:	4f 91       	pop	r20
    1580:	3f 91       	pop	r19
    1582:	2f 91       	pop	r18
    1584:	0f 90       	pop	r0
    1586:	0b be       	out	0x3b, r0	; 59
    1588:	0f 90       	pop	r0
    158a:	09 be       	out	0x39, r0	; 57
    158c:	0f 90       	pop	r0
    158e:	08 be       	out	0x38, r0	; 56
    1590:	0f 90       	pop	r0
    1592:	0f be       	out	0x3f, r0	; 63
    1594:	0f 90       	pop	r0
    1596:	1f 90       	pop	r1
    1598:	18 95       	reti

0000159a <uartVtySendByte>:

void uartVtySendByte(uint8_t data)
{
    159a:	df 93       	push	r29
    159c:	cf 93       	push	r28
    159e:	0f 92       	push	r0
    15a0:	cd b7       	in	r28, 0x3d	; 61
    15a2:	de b7       	in	r29, 0x3e	; 62
    15a4:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
    15a6:	80 91 d9 31 	lds	r24, 0x31D9
    15aa:	90 91 da 31 	lds	r25, 0x31DA
    15ae:	be 01       	movw	r22, r28
    15b0:	6f 5f       	subi	r22, 0xFF	; 255
    15b2:	7f 4f       	sbci	r23, 0xFF	; 255
    15b4:	4f ef       	ldi	r20, 0xFF	; 255
    15b6:	5f ef       	ldi	r21, 0xFF	; 255
    15b8:	20 e0       	ldi	r18, 0x00	; 0
    15ba:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>
  vInterruptVtyOn();
    15be:	e0 ea       	ldi	r30, 0xA0	; 160
    15c0:	f9 e0       	ldi	r31, 0x09	; 9
    15c2:	81 81       	ldd	r24, Z+1	; 0x01
    15c4:	80 62       	ori	r24, 0x20	; 32
    15c6:	81 83       	std	Z+1, r24	; 0x01
}
    15c8:	0f 90       	pop	r0
    15ca:	cf 91       	pop	r28
    15cc:	df 91       	pop	r29
    15ce:	08 95       	ret

000015d0 <VtyPutChar>:
}

int VtyPutChar(char c, FILE *stream)
{
  stream = NULL;
  uartVtySendByte(c);
    15d0:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
  return 0;
}
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	08 95       	ret

000015da <__vector_89>:
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
  vInterruptVtyOn();
}

ISR(USARTD0_DRE_vect) // USART1_UDRE_vect
{
    15da:	1f 92       	push	r1
    15dc:	0f 92       	push	r0
    15de:	0f b6       	in	r0, 0x3f	; 63
    15e0:	0f 92       	push	r0
    15e2:	08 b6       	in	r0, 0x38	; 56
    15e4:	0f 92       	push	r0
    15e6:	09 b6       	in	r0, 0x39	; 57
    15e8:	0f 92       	push	r0
    15ea:	0b b6       	in	r0, 0x3b	; 59
    15ec:	0f 92       	push	r0
    15ee:	11 24       	eor	r1, r1
    15f0:	18 be       	out	0x38, r1	; 56
    15f2:	19 be       	out	0x39, r1	; 57
    15f4:	1b be       	out	0x3b, r1	; 59
    15f6:	2f 93       	push	r18
    15f8:	3f 93       	push	r19
    15fa:	4f 93       	push	r20
    15fc:	5f 93       	push	r21
    15fe:	6f 93       	push	r22
    1600:	7f 93       	push	r23
    1602:	8f 93       	push	r24
    1604:	9f 93       	push	r25
    1606:	af 93       	push	r26
    1608:	bf 93       	push	r27
    160a:	ef 93       	push	r30
    160c:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
    160e:	80 91 d9 31 	lds	r24, 0x31D9
    1612:	90 91 da 31 	lds	r25, 0x31DA
    1616:	6b e4       	ldi	r22, 0x4B	; 75
    1618:	75 e2       	ldi	r23, 0x25	; 37
    161a:	4c e4       	ldi	r20, 0x4C	; 76
    161c:	55 e2       	ldi	r21, 0x25	; 37
    161e:	0e 94 8b 4f 	call	0x9f16	; 0x9f16 <xQueueReceiveFromISR>
    1622:	81 30       	cpi	r24, 0x01	; 1
    1624:	29 f4       	brne	.+10     	; 0x1630 <__vector_89+0x56>
  {
    USARTD0.DATA = data; 
    1626:	80 91 4b 25 	lds	r24, 0x254B
    162a:	80 93 a0 09 	sts	0x09A0, r24
    162e:	08 c0       	rjmp	.+16     	; 0x1640 <__vector_89+0x66>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    1630:	10 92 4c 25 	sts	0x254C, r1
    vInterruptVtyOff();
    1634:	80 91 a1 09 	lds	r24, 0x09A1
    1638:	8f 7d       	andi	r24, 0xDF	; 223
    163a:	e0 ea       	ldi	r30, 0xA0	; 160
    163c:	f9 e0       	ldi	r31, 0x09	; 9
    163e:	81 83       	std	Z+1, r24	; 0x01
  }
  if( xHigherPriorityTaskWoken )
    1640:	80 91 4c 25 	lds	r24, 0x254C
    1644:	88 23       	and	r24, r24
    1646:	11 f0       	breq	.+4      	; 0x164c <__vector_89+0x72>
  {
    taskYIELD();
    1648:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
  }
}
    164c:	ff 91       	pop	r31
    164e:	ef 91       	pop	r30
    1650:	bf 91       	pop	r27
    1652:	af 91       	pop	r26
    1654:	9f 91       	pop	r25
    1656:	8f 91       	pop	r24
    1658:	7f 91       	pop	r23
    165a:	6f 91       	pop	r22
    165c:	5f 91       	pop	r21
    165e:	4f 91       	pop	r20
    1660:	3f 91       	pop	r19
    1662:	2f 91       	pop	r18
    1664:	0f 90       	pop	r0
    1666:	0b be       	out	0x3b, r0	; 59
    1668:	0f 90       	pop	r0
    166a:	09 be       	out	0x39, r0	; 57
    166c:	0f 90       	pop	r0
    166e:	08 be       	out	0x38, r0	; 56
    1670:	0f 90       	pop	r0
    1672:	0f be       	out	0x3f, r0	; 63
    1674:	0f 90       	pop	r0
    1676:	1f 90       	pop	r1
    1678:	18 95       	reti

0000167a <hardwareInit>:
xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisję do czasu zakończenia wysyłania poprzedniego bajtu

void hardwareInit(void)
{
  //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	f8 94       	cli
    167e:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	61 e0       	ldi	r22, 0x01	; 1
    1684:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    1688:	80 93 c2 32 	sts	0x32C2, r24
    168c:	90 93 c3 32 	sts	0x32C3, r25
  portEXIT_CRITICAL();
    1690:	0f 90       	pop	r0
    1692:	0f be       	out	0x3f, r0	; 63

 //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	61 e0       	ldi	r22, 0x01	; 1
    169e:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    16a2:	80 93 c2 32 	sts	0x32C2, r24
    16a6:	90 93 c3 32 	sts	0x32C3, r25
  portEXIT_CRITICAL();
    16aa:	0f 90       	pop	r0
    16ac:	0f be       	out	0x3f, r0	; 63
5- JTAG TDI
4- JTAG TMS
5:2 - LCD D4:D7
0 - ENC28J60 CS
*/
PORTB.DIR=0x01;
    16ae:	81 e0       	ldi	r24, 0x01	; 1
    16b0:	80 93 20 06 	sts	0x0620, r24
4- SD_card CS
3- ST2378 OE
1- I2C SCL
0- I2C SDA
*/
PORTC.DIR=0xA0;
    16b4:	80 ea       	ldi	r24, 0xA0	; 160
    16b6:	80 93 40 06 	sts	0x0640, r24
3- FT232 TXT-WY
2- FT232 RXT-WE
1- ENC28J60 RST
0- ENC28J60 INT
*/
PORTD.DIR=0xBA;
    16ba:	8a eb       	ldi	r24, 0xBA	; 186
    16bc:	80 93 60 06 	sts	0x0660, r24
/* PORTE
7:0- ZL SPI A7:A0
*/
PORTE.DIR=0xFF;
    16c0:	8f ef       	ldi	r24, 0xFF	; 255
    16c2:	80 93 80 06 	sts	0x0680, r24
5- RS485 DE/RE
4- INT
3- RS485 TXD
2- RS485 RXD
*/
PORTF.DIR=0x28;
    16c6:	98 e2       	ldi	r25, 0x28	; 40
    16c8:	90 93 a0 06 	sts	0x06A0, r25
6:4- EBI A18:A16
2-   EBI ALE
1-   EBI RE
0-   EBI WE
*/
PORTH.DIR=0xFF;
    16cc:	80 93 e0 06 	sts	0x06E0, r24
/* PORTJ
7:0- EBI D7:D0/A0:A7
*/
PORTJ.DIR=0xFF;
    16d0:	80 93 00 07 	sts	0x0700, r24
/* PORTK
7:0- EBI A8:A15
*/
PORTK.DIR=0xFF;
    16d4:	80 93 20 07 	sts	0x0720, r24
}
    16d8:	08 95       	ret

000016da <LockersMemInit>:

void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
    16da:	88 e1       	ldi	r24, 0x18	; 24
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	0e 94 22 1c 	call	0x3844	; 0x3844 <xmalloc>
    16e2:	80 93 00 32 	sts	0x3200, r24
    16e6:	90 93 01 32 	sts	0x3201, r25
}
    16ea:	08 95       	ret

000016ec <printLockers>:

uint8_t printLockers(FILE *stream)
{
    16ec:	4f 92       	push	r4
    16ee:	5f 92       	push	r5
    16f0:	6f 92       	push	r6
    16f2:	7f 92       	push	r7
    16f4:	9f 92       	push	r9
    16f6:	af 92       	push	r10
    16f8:	bf 92       	push	r11
    16fa:	cf 92       	push	r12
    16fc:	df 92       	push	r13
    16fe:	ef 92       	push	r14
    1700:	ff 92       	push	r15
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	7c 01       	movw	r14, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
    170c:	c0 91 00 32 	lds	r28, 0x3200
    1710:	d0 91 01 32 	lds	r29, 0x3201
    1714:	00 e0       	ldi	r16, 0x00	; 0
    1716:	10 e0       	ldi	r17, 0x00	; 0
}

uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
    1718:	99 24       	eor	r9, r9
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    171a:	34 ef       	ldi	r19, 0xF4	; 244
    171c:	c3 2e       	mov	r12, r19
    171e:	31 e0       	ldi	r19, 0x01	; 1
    1720:	d3 2e       	mov	r13, r19
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1722:	21 e1       	ldi	r18, 0x11	; 17
    1724:	a2 2e       	mov	r10, r18
    1726:	22 e0       	ldi	r18, 0x02	; 2
    1728:	b2 2e       	mov	r11, r18
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
    172a:	98 e0       	ldi	r25, 0x08	; 8
    172c:	69 2e       	mov	r6, r25
    172e:	92 e0       	ldi	r25, 0x02	; 2
    1730:	79 2e       	mov	r7, r25
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
    1732:	8f ef       	ldi	r24, 0xFF	; 255
    1734:	48 2e       	mov	r4, r24
    1736:	81 e0       	ldi	r24, 0x01	; 1
    1738:	58 2e       	mov	r5, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    173a:	88 81       	ld	r24, Y
    173c:	88 23       	and	r24, r24
    173e:	09 f4       	brne	.+2      	; 0x1742 <printLockers+0x56>
    1740:	5a c0       	rjmp	.+180    	; 0x17f6 <printLockers+0x10a>
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1742:	00 d0       	rcall	.+0      	; 0x1744 <printLockers+0x58>
    1744:	00 d0       	rcall	.+0      	; 0x1746 <printLockers+0x5a>
    1746:	ed b7       	in	r30, 0x3d	; 61
    1748:	fe b7       	in	r31, 0x3e	; 62
    174a:	31 96       	adiw	r30, 0x01	; 1
    174c:	ad b7       	in	r26, 0x3d	; 61
    174e:	be b7       	in	r27, 0x3e	; 62
    1750:	11 96       	adiw	r26, 0x01	; 1
    1752:	ed 92       	st	X+, r14
    1754:	fc 92       	st	X, r15
    1756:	12 97       	sbiw	r26, 0x02	; 2
    1758:	c2 82       	std	Z+2, r12	; 0x02
    175a:	d3 82       	std	Z+3, r13	; 0x03
void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
}

uint8_t printLockers(FILE *stream)
    175c:	c8 01       	movw	r24, r16
    175e:	01 96       	adiw	r24, 0x01	; 1
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1760:	84 83       	std	Z+4, r24	; 0x04
    1762:	95 83       	std	Z+5, r25	; 0x05
    1764:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      if (tmpLock->threshold > tmpLock->acVal)
    1768:	ed b7       	in	r30, 0x3d	; 61
    176a:	fe b7       	in	r31, 0x3e	; 62
    176c:	36 96       	adiw	r30, 0x06	; 6
    176e:	ed bf       	out	0x3d, r30	; 61
    1770:	fe bf       	out	0x3e, r31	; 62
    1772:	29 81       	ldd	r18, Y+1	; 0x01
    1774:	3a 81       	ldd	r19, Y+2	; 0x02
    1776:	8b 81       	ldd	r24, Y+3	; 0x03
    1778:	9c 81       	ldd	r25, Y+4	; 0x04
    177a:	82 17       	cp	r24, r18
    177c:	93 07       	cpc	r25, r19
    177e:	68 f4       	brcc	.+26     	; 0x179a <printLockers+0xae>
        fprintf_P(stream, statusLockerOpenStr);
    1780:	00 d0       	rcall	.+0      	; 0x1782 <printLockers+0x96>
    1782:	0f 92       	push	r0
    1784:	ad b7       	in	r26, 0x3d	; 61
    1786:	be b7       	in	r27, 0x3e	; 62
    1788:	11 96       	adiw	r26, 0x01	; 1
    178a:	ed 92       	st	X+, r14
    178c:	fc 92       	st	X, r15
    178e:	12 97       	sbiw	r26, 0x02	; 2
    1790:	13 96       	adiw	r26, 0x03	; 3
    1792:	4d 92       	st	X+, r4
    1794:	5c 92       	st	X, r5
    1796:	14 97       	sbiw	r26, 0x04	; 4
    1798:	08 c0       	rjmp	.+16     	; 0x17aa <printLockers+0xbe>
      else
        fprintf_P(stream, statusLockerCloseStr);
    179a:	00 d0       	rcall	.+0      	; 0x179c <printLockers+0xb0>
    179c:	0f 92       	push	r0
    179e:	ed b7       	in	r30, 0x3d	; 61
    17a0:	fe b7       	in	r31, 0x3e	; 62
    17a2:	e1 82       	std	Z+1, r14	; 0x01
    17a4:	f2 82       	std	Z+2, r15	; 0x02
    17a6:	63 82       	std	Z+3, r6	; 0x03
    17a8:	74 82       	std	Z+4, r7	; 0x04
    17aa:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    17ae:	0f 90       	pop	r0
    17b0:	0f 90       	pop	r0
    17b2:	0f 90       	pop	r0
    17b4:	0f 90       	pop	r0
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    17b6:	8d b7       	in	r24, 0x3d	; 61
    17b8:	9e b7       	in	r25, 0x3e	; 62
    17ba:	08 97       	sbiw	r24, 0x08	; 8
    17bc:	8d bf       	out	0x3d, r24	; 61
    17be:	9e bf       	out	0x3e, r25	; 62
    17c0:	ed b7       	in	r30, 0x3d	; 61
    17c2:	fe b7       	in	r31, 0x3e	; 62
    17c4:	31 96       	adiw	r30, 0x01	; 1
    17c6:	ad b7       	in	r26, 0x3d	; 61
    17c8:	be b7       	in	r27, 0x3e	; 62
    17ca:	11 96       	adiw	r26, 0x01	; 1
    17cc:	ed 92       	st	X+, r14
    17ce:	fc 92       	st	X, r15
    17d0:	12 97       	sbiw	r26, 0x02	; 2
    17d2:	a2 82       	std	Z+2, r10	; 0x02
    17d4:	b3 82       	std	Z+3, r11	; 0x03
    17d6:	89 81       	ldd	r24, Y+1	; 0x01
    17d8:	9a 81       	ldd	r25, Y+2	; 0x02
    17da:	84 83       	std	Z+4, r24	; 0x04
    17dc:	95 83       	std	Z+5, r25	; 0x05
    17de:	8b 81       	ldd	r24, Y+3	; 0x03
    17e0:	9c 81       	ldd	r25, Y+4	; 0x04
    17e2:	86 83       	std	Z+6, r24	; 0x06
    17e4:	97 83       	std	Z+7, r25	; 0x07
    17e6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      result++;
    17ea:	93 94       	inc	r9
    17ec:	ed b7       	in	r30, 0x3d	; 61
    17ee:	fe b7       	in	r31, 0x3e	; 62
    17f0:	38 96       	adiw	r30, 0x08	; 8
    17f2:	ed bf       	out	0x3d, r30	; 61
    17f4:	fe bf       	out	0x3e, r31	; 62
    17f6:	0f 5f       	subi	r16, 0xFF	; 255
    17f8:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
    17fa:	04 30       	cpi	r16, 0x04	; 4
    17fc:	11 05       	cpc	r17, r1
    17fe:	11 f0       	breq	.+4      	; 0x1804 <printLockers+0x118>
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
      result++;
    }
    tmpLock++;
    1800:	26 96       	adiw	r28, 0x06	; 6
    1802:	9b cf       	rjmp	.-202    	; 0x173a <printLockers+0x4e>
  }
  return result;
}
    1804:	89 2d       	mov	r24, r9
    1806:	df 91       	pop	r29
    1808:	cf 91       	pop	r28
    180a:	1f 91       	pop	r17
    180c:	0f 91       	pop	r16
    180e:	ff 90       	pop	r15
    1810:	ef 90       	pop	r14
    1812:	df 90       	pop	r13
    1814:	cf 90       	pop	r12
    1816:	bf 90       	pop	r11
    1818:	af 90       	pop	r10
    181a:	9f 90       	pop	r9
    181c:	7f 90       	pop	r7
    181e:	6f 90       	pop	r6
    1820:	5f 90       	pop	r5
    1822:	4f 90       	pop	r4
    1824:	08 95       	ret

00001826 <checkLockerSensors>:

void checkLockerSensors(void)
{
    1826:	cf 93       	push	r28
    1828:	df 93       	push	r29
  if (lockSensors[0].enabled)
    182a:	e0 91 00 32 	lds	r30, 0x3200
    182e:	f0 91 01 32 	lds	r31, 0x3201
    1832:	80 81       	ld	r24, Z
    1834:	88 23       	and	r24, r24
    1836:	39 f1       	breq	.+78     	; 0x1886 <checkLockerSensors+0x60>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1838:	80 e4       	ldi	r24, 0x40	; 64
    183a:	60 e0       	ldi	r22, 0x00	; 0
    183c:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1840:	8e e1       	ldi	r24, 0x1E	; 30
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
    1848:	c0 91 00 32 	lds	r28, 0x3200
    184c:	d0 91 01 32 	lds	r29, 0x3201
    1850:	84 e0       	ldi	r24, 0x04	; 4
    1852:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <MCP3008_getSampleSingle>
    1856:	8b 83       	std	Y+3, r24	; 0x03
    1858:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    185a:	80 e4       	ldi	r24, 0x40	; 64
    185c:	60 e0       	ldi	r22, 0x00	; 0
    185e:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <MPC23s17ClearBitsOnPortA>
    lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
    1862:	e0 91 00 32 	lds	r30, 0x3200
    1866:	f0 91 01 32 	lds	r31, 0x3201
    186a:	41 e0       	ldi	r20, 0x01	; 1
    186c:	23 81       	ldd	r18, Z+3	; 0x03
    186e:	34 81       	ldd	r19, Z+4	; 0x04
    1870:	81 81       	ldd	r24, Z+1	; 0x01
    1872:	92 81       	ldd	r25, Z+2	; 0x02
    1874:	82 17       	cp	r24, r18
    1876:	93 07       	cpc	r25, r19
    1878:	08 f0       	brcs	.+2      	; 0x187c <checkLockerSensors+0x56>
    187a:	40 e0       	ldi	r20, 0x00	; 0
    187c:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    187e:	8a e0       	ldi	r24, 0x0A	; 10
    1880:	90 e0       	ldi	r25, 0x00	; 0
    1882:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
  }
  
  if (lockSensors[1].enabled)
    1886:	e0 91 00 32 	lds	r30, 0x3200
    188a:	f0 91 01 32 	lds	r31, 0x3201
    188e:	86 81       	ldd	r24, Z+6	; 0x06
    1890:	88 23       	and	r24, r24
    1892:	49 f1       	breq	.+82     	; 0x18e6 <checkLockerSensors+0xc0>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1894:	80 e2       	ldi	r24, 0x20	; 32
    1896:	60 e0       	ldi	r22, 0x00	; 0
    1898:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    189c:	8e e1       	ldi	r24, 0x1E	; 30
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
    18a4:	c0 91 00 32 	lds	r28, 0x3200
    18a8:	d0 91 01 32 	lds	r29, 0x3201
    18ac:	26 96       	adiw	r28, 0x06	; 6
    18ae:	85 e0       	ldi	r24, 0x05	; 5
    18b0:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <MCP3008_getSampleSingle>
    18b4:	8b 83       	std	Y+3, r24	; 0x03
    18b6:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    18b8:	80 e2       	ldi	r24, 0x20	; 32
    18ba:	60 e0       	ldi	r22, 0x00	; 0
    18bc:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <MPC23s17ClearBitsOnPortA>
    lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
    18c0:	e0 91 00 32 	lds	r30, 0x3200
    18c4:	f0 91 01 32 	lds	r31, 0x3201
    18c8:	36 96       	adiw	r30, 0x06	; 6
    18ca:	41 e0       	ldi	r20, 0x01	; 1
    18cc:	23 81       	ldd	r18, Z+3	; 0x03
    18ce:	34 81       	ldd	r19, Z+4	; 0x04
    18d0:	81 81       	ldd	r24, Z+1	; 0x01
    18d2:	92 81       	ldd	r25, Z+2	; 0x02
    18d4:	82 17       	cp	r24, r18
    18d6:	93 07       	cpc	r25, r19
    18d8:	08 f0       	brcs	.+2      	; 0x18dc <checkLockerSensors+0xb6>
    18da:	40 e0       	ldi	r20, 0x00	; 0
    18dc:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    18de:	8a e0       	ldi	r24, 0x0A	; 10
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
  }
  
  if (lockSensors[2].enabled)
    18e6:	e0 91 00 32 	lds	r30, 0x3200
    18ea:	f0 91 01 32 	lds	r31, 0x3201
    18ee:	84 85       	ldd	r24, Z+12	; 0x0c
    18f0:	88 23       	and	r24, r24
    18f2:	49 f1       	breq	.+82     	; 0x1946 <checkLockerSensors+0x120>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    18f4:	80 e1       	ldi	r24, 0x10	; 16
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    18fc:	8e e1       	ldi	r24, 0x1E	; 30
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
    1904:	c0 91 00 32 	lds	r28, 0x3200
    1908:	d0 91 01 32 	lds	r29, 0x3201
    190c:	2c 96       	adiw	r28, 0x0c	; 12
    190e:	86 e0       	ldi	r24, 0x06	; 6
    1910:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <MCP3008_getSampleSingle>
    1914:	8b 83       	std	Y+3, r24	; 0x03
    1916:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1918:	80 e1       	ldi	r24, 0x10	; 16
    191a:	60 e0       	ldi	r22, 0x00	; 0
    191c:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <MPC23s17ClearBitsOnPortA>
    lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
    1920:	e0 91 00 32 	lds	r30, 0x3200
    1924:	f0 91 01 32 	lds	r31, 0x3201
    1928:	3c 96       	adiw	r30, 0x0c	; 12
    192a:	41 e0       	ldi	r20, 0x01	; 1
    192c:	23 81       	ldd	r18, Z+3	; 0x03
    192e:	34 81       	ldd	r19, Z+4	; 0x04
    1930:	81 81       	ldd	r24, Z+1	; 0x01
    1932:	92 81       	ldd	r25, Z+2	; 0x02
    1934:	82 17       	cp	r24, r18
    1936:	93 07       	cpc	r25, r19
    1938:	08 f0       	brcs	.+2      	; 0x193c <checkLockerSensors+0x116>
    193a:	40 e0       	ldi	r20, 0x00	; 0
    193c:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    193e:	8a e0       	ldi	r24, 0x0A	; 10
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
  }
  
  if (lockSensors[3].enabled)
    1946:	e0 91 00 32 	lds	r30, 0x3200
    194a:	f0 91 01 32 	lds	r31, 0x3201
    194e:	82 89       	ldd	r24, Z+18	; 0x12
    1950:	88 23       	and	r24, r24
    1952:	49 f1       	breq	.+82     	; 0x19a6 <checkLockerSensors+0x180>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1954:	88 e0       	ldi	r24, 0x08	; 8
    1956:	60 e0       	ldi	r22, 0x00	; 0
    1958:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    195c:	8e e1       	ldi	r24, 0x1E	; 30
    195e:	90 e0       	ldi	r25, 0x00	; 0
    1960:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    1964:	c0 91 00 32 	lds	r28, 0x3200
    1968:	d0 91 01 32 	lds	r29, 0x3201
    196c:	62 96       	adiw	r28, 0x12	; 18
    196e:	87 e0       	ldi	r24, 0x07	; 7
    1970:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <MCP3008_getSampleSingle>
    1974:	8b 83       	std	Y+3, r24	; 0x03
    1976:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1978:	88 e0       	ldi	r24, 0x08	; 8
    197a:	60 e0       	ldi	r22, 0x00	; 0
    197c:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <MPC23s17ClearBitsOnPortA>
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    1980:	e0 91 00 32 	lds	r30, 0x3200
    1984:	f0 91 01 32 	lds	r31, 0x3201
    1988:	72 96       	adiw	r30, 0x12	; 18
    198a:	41 e0       	ldi	r20, 0x01	; 1
    198c:	23 81       	ldd	r18, Z+3	; 0x03
    198e:	34 81       	ldd	r19, Z+4	; 0x04
    1990:	81 81       	ldd	r24, Z+1	; 0x01
    1992:	92 81       	ldd	r25, Z+2	; 0x02
    1994:	82 17       	cp	r24, r18
    1996:	93 07       	cpc	r25, r19
    1998:	08 f0       	brcs	.+2      	; 0x199c <checkLockerSensors+0x176>
    199a:	40 e0       	ldi	r20, 0x00	; 0
    199c:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    199e:	8a e0       	ldi	r24, 0x0A	; 10
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
  }
}
    19a6:	df 91       	pop	r29
    19a8:	cf 91       	pop	r28
    19aa:	08 95       	ret

000019ac <spiSend>:
    19ac:	df 93       	push	r29
    19ae:	cf 93       	push	r28
    19b0:	0f 92       	push	r0
    19b2:	cd b7       	in	r28, 0x3d	; 61
    19b4:	de b7       	in	r29, 0x3e	; 62
    19b6:	e0 ec       	ldi	r30, 0xC0	; 192
    19b8:	f9 e0       	ldi	r31, 0x09	; 9
    19ba:	83 83       	std	Z+3, r24	; 0x03
    19bc:	80 91 c2 32 	lds	r24, 0x32C2
    19c0:	90 91 c3 32 	lds	r25, 0x32C3
    19c4:	be 01       	movw	r22, r28
    19c6:	6f 5f       	subi	r22, 0xFF	; 255
    19c8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ca:	4a e0       	ldi	r20, 0x0A	; 10
    19cc:	50 e0       	ldi	r21, 0x00	; 0
    19ce:	20 e0       	ldi	r18, 0x00	; 0
    19d0:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    19d4:	89 81       	ldd	r24, Y+1	; 0x01
    19d6:	0f 90       	pop	r0
    19d8:	cf 91       	pop	r28
    19da:	df 91       	pop	r29
    19dc:	08 95       	ret

000019de <spiSendENC>:
  SPID.DATA = data; 
  xQueueReceive(xSpiRx, &result, 10); 
  return result;
}
uint8_t spiSendENC(uint8_t data)
{
    19de:	df 93       	push	r29
    19e0:	cf 93       	push	r28
    19e2:	0f 92       	push	r0
    19e4:	cd b7       	in	r28, 0x3d	; 61
    19e6:	de b7       	in	r29, 0x3e	; 62
  uint8_t result; 
  SPIC.DATA = data;
    19e8:	e0 ec       	ldi	r30, 0xC0	; 192
    19ea:	f8 e0       	ldi	r31, 0x08	; 8
    19ec:	83 83       	std	Z+3, r24	; 0x03
  //SPID.DATA = data; 
  xQueueReceive(xSpiRx, &result, 10); 
    19ee:	80 91 c2 32 	lds	r24, 0x32C2
    19f2:	90 91 c3 32 	lds	r25, 0x32C3
    19f6:	be 01       	movw	r22, r28
    19f8:	6f 5f       	subi	r22, 0xFF	; 255
    19fa:	7f 4f       	sbci	r23, 0xFF	; 255
    19fc:	4a e0       	ldi	r20, 0x0A	; 10
    19fe:	50 e0       	ldi	r21, 0x00	; 0
    1a00:	20 e0       	ldi	r18, 0x00	; 0
    1a02:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
  return result;
}
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
    1a08:	0f 90       	pop	r0
    1a0a:	cf 91       	pop	r28
    1a0c:	df 91       	pop	r29
    1a0e:	08 95       	ret

00001a10 <spiSendSpinBlock>:
    1a10:	80 91 c2 09 	lds	r24, 0x09C2
    1a14:	87 ff       	sbrs	r24, 7
    1a16:	fc cf       	rjmp	.-8      	; 0x1a10 <spiSendSpinBlock>
    1a18:	80 91 c3 09 	lds	r24, 0x09C3
    1a1c:	80 91 c3 09 	lds	r24, 0x09C3
    1a20:	90 91 c1 09 	lds	r25, 0x09C1
    1a24:	91 60       	ori	r25, 0x01	; 1
    1a26:	e0 ec       	ldi	r30, 0xC0	; 192
    1a28:	f9 e0       	ldi	r31, 0x09	; 9
    1a2a:	91 83       	std	Z+1, r25	; 0x01
    1a2c:	08 95       	ret

00001a2e <spiSendSpinBlockENC>:
  return data;                     
}
uint8_t spiSendSpinBlockENC(uint8_t data)
{
  //SPDR = data;
  SPIC.DATA=data;
    1a2e:	e0 ec       	ldi	r30, 0xC0	; 192
    1a30:	f8 e0       	ldi	r31, 0x08	; 8
    1a32:	83 83       	std	Z+3, r24	; 0x03
  //SPCR &= ~(1<<SPIE);                
  SPIC.INTCTRL=0x00; //Disable SPI interrupt
    1a34:	11 82       	std	Z+1, r1	; 0x01
  while(!(SPIC.STATUS&(0x80))); //(SPSR&(1<<SPIF)));
    1a36:	80 91 c2 08 	lds	r24, 0x08C2
    1a3a:	87 ff       	sbrs	r24, 7
    1a3c:	fc cf       	rjmp	.-8      	; 0x1a36 <spiSendSpinBlockENC+0x8>
  data = SPIC.DATA;//SPSR;                       Clearing interrupt flag
    1a3e:	80 91 c3 08 	lds	r24, 0x08C3
  data = SPIC.DATA; //SPDR;                      Resfing DPI buffer register
    1a42:	80 91 c3 08 	lds	r24, 0x08C3
  //SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
  SPIC.INTCTRL|=0x01; //low level
    1a46:	90 91 c1 08 	lds	r25, 0x08C1
    1a4a:	91 60       	ori	r25, 0x01	; 1
    1a4c:	e0 ec       	ldi	r30, 0xC0	; 192
    1a4e:	f8 e0       	ldi	r31, 0x08	; 8
    1a50:	91 83       	std	Z+1, r25	; 0x01
  return data;                     
}
    1a52:	08 95       	ret

00001a54 <disableAllSpiDevices>:
{ 
#if disableSpiPORTA_OR !=0
  PORTA.OUT |= disableSpiPORTA_OR;
#endif
#if disableSpiPORTB_AND !=0xFF
  PORTA.OUT &= disableSpiPORTB_AND;
    1a54:	e0 e0       	ldi	r30, 0x00	; 0
    1a56:	f6 e0       	ldi	r31, 0x06	; 6
    1a58:	84 81       	ldd	r24, Z+4	; 0x04
    1a5a:	8e 7f       	andi	r24, 0xFE	; 254
    1a5c:	84 83       	std	Z+4, r24	; 0x04
#endif
  
#if disableSpiPORTB_OR != 0
  PORTB.OUT |= disableSpiPORTB_OR;
    1a5e:	e0 e2       	ldi	r30, 0x20	; 32
    1a60:	f6 e0       	ldi	r31, 0x06	; 6
    1a62:	84 81       	ldd	r24, Z+4	; 0x04
    1a64:	81 60       	ori	r24, 0x01	; 1
    1a66:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTB_AND != 0xFF 
  PORTB.OUT &= disableSpiPORTB_AND;
    1a68:	84 81       	ldd	r24, Z+4	; 0x04
    1a6a:	8e 7f       	andi	r24, 0xFE	; 254
    1a6c:	84 83       	std	Z+4, r24	; 0x04
#endif
  
#if disableSpiPORTC_OR !=0
  PORTC.OUT |= disableSpiPORTC_OR;
    1a6e:	e0 e4       	ldi	r30, 0x40	; 64
    1a70:	f6 e0       	ldi	r31, 0x06	; 6
    1a72:	84 81       	ldd	r24, Z+4	; 0x04
    1a74:	80 61       	ori	r24, 0x10	; 16
    1a76:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTC_AND !=0xFF
  PORTC.OUT |= disableSpiPORTC_AND;
    1a78:	84 81       	ldd	r24, Z+4	; 0x04
    1a7a:	8f 6e       	ori	r24, 0xEF	; 239
    1a7c:	84 83       	std	Z+4, r24	; 0x04
#if disableSpiPORTD_AND != 0xFF
  PORTD.OUT &= disableSpiPORTD_AND;
#endif
  
#if disableSpiPORTE_OR != 0
  PORTE.OUT |= disableSpiPORTE_OR;
    1a7e:	e0 e8       	ldi	r30, 0x80	; 128
    1a80:	f6 e0       	ldi	r31, 0x06	; 6
    1a82:	84 81       	ldd	r24, Z+4	; 0x04
    1a84:	80 6c       	ori	r24, 0xC0	; 192
    1a86:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTE_AND != 0xFF
  PORTE.OUT &= disableSpiPORTE_AND;
    1a88:	84 81       	ldd	r24, Z+4	; 0x04
    1a8a:	8f 7d       	andi	r24, 0xDF	; 223
    1a8c:	84 83       	std	Z+4, r24	; 0x04
#if disableSpiPORTH_AND != 0xFF
#error Port H is memory bus
  PORTH.OUT &= disableSpiPORTG_AND;
#endif

}
    1a8e:	08 95       	ret

00001a90 <spiEnableEnc28j60>:
    1a90:	e0 e2       	ldi	r30, 0x20	; 32
    1a92:	f6 e0       	ldi	r31, 0x06	; 6
    1a94:	84 81       	ldd	r24, Z+4	; 0x04
    1a96:	8e 7f       	andi	r24, 0xFE	; 254
    1a98:	84 83       	std	Z+4, r24	; 0x04
    1a9a:	08 95       	ret

00001a9c <spiDisableEnc28j60>:
    1a9c:	e0 e2       	ldi	r30, 0x20	; 32
    1a9e:	f6 e0       	ldi	r31, 0x06	; 6
    1aa0:	84 81       	ldd	r24, Z+4	; 0x04
    1aa2:	81 60       	ori	r24, 0x01	; 1
    1aa4:	84 83       	std	Z+4, r24	; 0x04
    1aa6:	08 95       	ret

00001aa8 <enableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
    1aa8:	e0 e4       	ldi	r30, 0x40	; 64
    1aaa:	f6 e0       	ldi	r31, 0x06	; 6
    1aac:	84 81       	ldd	r24, Z+4	; 0x04
    1aae:	8f 7e       	andi	r24, 0xEF	; 239
    1ab0:	84 83       	std	Z+4, r24	; 0x04
#endif   
}
    1ab2:	08 95       	ret

00001ab4 <disableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
    1ab4:	e0 e4       	ldi	r30, 0x40	; 64
    1ab6:	f6 e0       	ldi	r31, 0x06	; 6
    1ab8:	84 81       	ldd	r24, Z+4	; 0x04
    1aba:	80 61       	ori	r24, 0x10	; 16
    1abc:	84 83       	std	Z+4, r24	; 0x04
#endif  
}
    1abe:	08 95       	ret

00001ac0 <enableSpiMPC23S17>:
    1ac0:	e0 e8       	ldi	r30, 0x80	; 128
    1ac2:	f6 e0       	ldi	r31, 0x06	; 6
    1ac4:	84 81       	ldd	r24, Z+4	; 0x04
    1ac6:	8f 77       	andi	r24, 0x7F	; 127
    1ac8:	84 83       	std	Z+4, r24	; 0x04
    1aca:	08 95       	ret

00001acc <disableSpiMPC23S17>:
    1acc:	e0 e8       	ldi	r30, 0x80	; 128
    1ace:	f6 e0       	ldi	r31, 0x06	; 6
    1ad0:	84 81       	ldd	r24, Z+4	; 0x04
    1ad2:	80 68       	ori	r24, 0x80	; 128
    1ad4:	84 83       	std	Z+4, r24	; 0x04
    1ad6:	08 95       	ret

00001ad8 <enableSpiMCP3008>:
    1ad8:	e0 ec       	ldi	r30, 0xC0	; 192
    1ada:	f9 e0       	ldi	r31, 0x09	; 9
    1adc:	80 81       	ld	r24, Z
    1ade:	83 60       	ori	r24, 0x03	; 3
    1ae0:	80 83       	st	Z, r24
    1ae2:	e0 e8       	ldi	r30, 0x80	; 128
    1ae4:	f6 e0       	ldi	r31, 0x06	; 6
    1ae6:	84 81       	ldd	r24, Z+4	; 0x04
    1ae8:	8f 7b       	andi	r24, 0xBF	; 191
    1aea:	84 83       	std	Z+4, r24	; 0x04
    1aec:	08 95       	ret

00001aee <disableSpiMCP3008>:
    1aee:	e0 ec       	ldi	r30, 0xC0	; 192
    1af0:	f9 e0       	ldi	r31, 0x09	; 9
    1af2:	80 81       	ld	r24, Z
    1af4:	8c 7f       	andi	r24, 0xFC	; 252
    1af6:	80 83       	st	Z, r24
    1af8:	e0 e8       	ldi	r30, 0x80	; 128
    1afa:	f6 e0       	ldi	r31, 0x06	; 6
    1afc:	84 81       	ldd	r24, Z+4	; 0x04
    1afe:	80 64       	ori	r24, 0x40	; 64
    1b00:	84 83       	std	Z+4, r24	; 0x04
    1b02:	08 95       	ret

00001b04 <enableSpiMCP4150>:
    1b04:	e0 ec       	ldi	r30, 0xC0	; 192
    1b06:	f9 e0       	ldi	r31, 0x09	; 9
    1b08:	80 81       	ld	r24, Z
    1b0a:	83 60       	ori	r24, 0x03	; 3
    1b0c:	80 83       	st	Z, r24
    1b0e:	e0 e8       	ldi	r30, 0x80	; 128
    1b10:	f6 e0       	ldi	r31, 0x06	; 6
    1b12:	84 81       	ldd	r24, Z+4	; 0x04
    1b14:	8f 7b       	andi	r24, 0xBF	; 191
    1b16:	84 83       	std	Z+4, r24	; 0x04
    1b18:	08 95       	ret

00001b1a <disableSpiMCP4150>:
    1b1a:	e0 ec       	ldi	r30, 0xC0	; 192
    1b1c:	f9 e0       	ldi	r31, 0x09	; 9
    1b1e:	80 81       	ld	r24, Z
    1b20:	8c 7f       	andi	r24, 0xFC	; 252
    1b22:	80 83       	st	Z, r24
    1b24:	e0 e8       	ldi	r30, 0x80	; 128
    1b26:	f6 e0       	ldi	r31, 0x06	; 6
    1b28:	84 81       	ldd	r24, Z+4	; 0x04
    1b2a:	80 64       	ori	r24, 0x40	; 64
    1b2c:	84 83       	std	Z+4, r24	; 0x04
    1b2e:	08 95       	ret

00001b30 <spiEnableDS1305>:
    1b30:	e0 ec       	ldi	r30, 0xC0	; 192
    1b32:	f9 e0       	ldi	r31, 0x09	; 9
    1b34:	80 81       	ld	r24, Z
    1b36:	85 60       	ori	r24, 0x05	; 5
    1b38:	80 83       	st	Z, r24
    1b3a:	e0 e8       	ldi	r30, 0x80	; 128
    1b3c:	f6 e0       	ldi	r31, 0x06	; 6
    1b3e:	84 81       	ldd	r24, Z+4	; 0x04
    1b40:	80 62       	ori	r24, 0x20	; 32
    1b42:	84 83       	std	Z+4, r24	; 0x04
    1b44:	08 95       	ret

00001b46 <spiDisableDS1305>:
    1b46:	e0 ec       	ldi	r30, 0xC0	; 192
    1b48:	f9 e0       	ldi	r31, 0x09	; 9
    1b4a:	80 81       	ld	r24, Z
    1b4c:	8a 7f       	andi	r24, 0xFA	; 250
    1b4e:	80 83       	st	Z, r24
    1b50:	e0 e8       	ldi	r30, 0x80	; 128
    1b52:	f6 e0       	ldi	r31, 0x06	; 6
    1b54:	84 81       	ldd	r24, Z+4	; 0x04
    1b56:	8f 7d       	andi	r24, 0xDF	; 223
    1b58:	84 83       	std	Z+4, r24	; 0x04
    1b5a:	08 95       	ret

00001b5c <__vector_24>:
  }
  
  //clear SPI interrupt SPI |= 1;
}*/
ISR(SPIC_INT_vect)
{
    1b5c:	1f 92       	push	r1
    1b5e:	0f 92       	push	r0
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	0f 92       	push	r0
    1b64:	08 b6       	in	r0, 0x38	; 56
    1b66:	0f 92       	push	r0
    1b68:	09 b6       	in	r0, 0x39	; 57
    1b6a:	0f 92       	push	r0
    1b6c:	0b b6       	in	r0, 0x3b	; 59
    1b6e:	0f 92       	push	r0
    1b70:	11 24       	eor	r1, r1
    1b72:	18 be       	out	0x38, r1	; 56
    1b74:	19 be       	out	0x39, r1	; 57
    1b76:	1b be       	out	0x3b, r1	; 59
    1b78:	2f 93       	push	r18
    1b7a:	3f 93       	push	r19
    1b7c:	4f 93       	push	r20
    1b7e:	5f 93       	push	r21
    1b80:	6f 93       	push	r22
    1b82:	7f 93       	push	r23
    1b84:	8f 93       	push	r24
    1b86:	9f 93       	push	r25
    1b88:	af 93       	push	r26
    1b8a:	bf 93       	push	r27
    1b8c:	ef 93       	push	r30
    1b8e:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 

  static uint8_t data;
  data = SPIC.DATA;//SPDR;
    1b90:	80 91 c3 08 	lds	r24, 0x08C3
    1b94:	80 93 50 25 	sts	0x2550, r24
  
  xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
    1b98:	80 91 c2 32 	lds	r24, 0x32C2
    1b9c:	90 91 c3 32 	lds	r25, 0x32C3
    1ba0:	60 e5       	ldi	r22, 0x50	; 80
    1ba2:	75 e2       	ldi	r23, 0x25	; 37
    1ba4:	41 e5       	ldi	r20, 0x51	; 81
    1ba6:	55 e2       	ldi	r21, 0x25	; 37
    1ba8:	20 e0       	ldi	r18, 0x00	; 0
    1baa:	0e 94 63 4e 	call	0x9cc6	; 0x9cc6 <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    1bae:	80 91 51 25 	lds	r24, 0x2551
    1bb2:	88 23       	and	r24, r24
    1bb4:	11 f0       	breq	.+4      	; 0x1bba <__vector_24+0x5e>
  {
    taskYIELD();
    1bb6:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
  }
  
  //clear SPI interrupt SPI |= 1;
}
    1bba:	ff 91       	pop	r31
    1bbc:	ef 91       	pop	r30
    1bbe:	bf 91       	pop	r27
    1bc0:	af 91       	pop	r26
    1bc2:	9f 91       	pop	r25
    1bc4:	8f 91       	pop	r24
    1bc6:	7f 91       	pop	r23
    1bc8:	6f 91       	pop	r22
    1bca:	5f 91       	pop	r21
    1bcc:	4f 91       	pop	r20
    1bce:	3f 91       	pop	r19
    1bd0:	2f 91       	pop	r18
    1bd2:	0f 90       	pop	r0
    1bd4:	0b be       	out	0x3b, r0	; 59
    1bd6:	0f 90       	pop	r0
    1bd8:	09 be       	out	0x39, r0	; 57
    1bda:	0f 90       	pop	r0
    1bdc:	08 be       	out	0x38, r0	; 56
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63
    1be2:	0f 90       	pop	r0
    1be4:	1f 90       	pop	r1
    1be6:	18 95       	reti

00001be8 <sensorsTaskInit>:



void sensorsTaskInit(void)
{
  LockersMemInit();
    1be8:	0e 94 6d 0b 	call	0x16da	; 0x16da <LockersMemInit>
  rollersMemInit();
    1bec:	0e 94 d7 3f 	call	0x7fae	; 0x7fae <rollersMemInit>
}
    1bf0:	08 95       	ret

00001bf2 <sensorsTask>:

void sensorsTask(void* pvParameters)
{
    1bf2:	1f 93       	push	r17
    1bf4:	cf 93       	push	r28
    1bf6:	df 93       	push	r29
  pvParameters = NULL;
  uint8_t addr = 255;
//  uint8_t i;

  MPC23s17SetDirA(0x00, 0);
    1bf8:	80 e0       	ldi	r24, 0x00	; 0
    1bfa:	60 e0       	ldi	r22, 0x00	; 0
    1bfc:	0e 94 6a 28 	call	0x50d4	; 0x50d4 <MPC23s17SetDirA>
  
  MPC23s17SetDirB(0x00, 0);
    1c00:	80 e0       	ldi	r24, 0x00	; 0
    1c02:	60 e0       	ldi	r22, 0x00	; 0
    1c04:	0e 94 8c 28 	call	0x5118	; 0x5118 <MPC23s17SetDirB>
    vTaskDelay(10);
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    tmp *=10;
    temperature = (uint8_t)(tmp / 24);
    1c08:	c8 e1       	ldi	r28, 0x18	; 24
    1c0a:	d0 e0       	ldi	r29, 0x00	; 0

  for( ; ; )
  {
    uint16_t tmp;
    //Read power suply voltage
    tmp = MCP3008_getSampleSingle(0);
    1c0c:	80 e0       	ldi	r24, 0x00	; 0
    1c0e:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <MCP3008_getSampleSingle>
    voltage = (uint8_t)(tmp>>5);
    1c12:	65 e0       	ldi	r22, 0x05	; 5
    1c14:	96 95       	lsr	r25
    1c16:	87 95       	ror	r24
    1c18:	6a 95       	dec	r22
    1c1a:	e1 f7       	brne	.-8      	; 0x1c14 <sensorsTask+0x22>
    1c1c:	80 93 0c 32 	sts	0x320C, r24
    vTaskDelay(10);
    1c20:	8a e0       	ldi	r24, 0x0A	; 10
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <MCP3008_getSampleSingle>
    tmp *=10;
    1c2e:	9c 01       	movw	r18, r24
    1c30:	88 0f       	add	r24, r24
    1c32:	99 1f       	adc	r25, r25
    1c34:	43 e0       	ldi	r20, 0x03	; 3
    1c36:	22 0f       	add	r18, r18
    1c38:	33 1f       	adc	r19, r19
    1c3a:	4a 95       	dec	r20
    1c3c:	e1 f7       	brne	.-8      	; 0x1c36 <sensorsTask+0x44>
    1c3e:	82 0f       	add	r24, r18
    1c40:	93 1f       	adc	r25, r19
    temperature = (uint8_t)(tmp / 24);
    1c42:	be 01       	movw	r22, r28
    1c44:	0e 94 21 54 	call	0xa842	; 0xa842 <__udivmodhi4>
    1c48:	60 93 04 32 	sts	0x3204, r22
    vTaskDelay(10);
    1c4c:	8a e0       	ldi	r24, 0x0A	; 10
    1c4e:	90 e0       	ldi	r25, 0x00	; 0
    1c50:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
      
    //read lock
    checkLockerSensors();
    1c54:	0e 94 13 0c 	call	0x1826	; 0x1826 <checkLockerSensors>

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1c58:	11 e0       	ldi	r17, 0x01	; 1
    {
      rs485rollerHello(addr);
    1c5a:	81 2f       	mov	r24, r17
    1c5c:	0e 94 3d 41 	call	0x827a	; 0x827a <rs485rollerHello>
      vTaskDelay(10);
    1c60:	8a e0       	ldi	r24, 0x0A	; 10
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    vTaskDelay(10);
      
    //read lock
    checkLockerSensors();

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1c68:	1f 5f       	subi	r17, 0xFF	; 255
    1c6a:	10 32       	cpi	r17, 0x20	; 32
    1c6c:	b1 f7       	brne	.-20     	; 0x1c5a <sensorsTask+0x68>
    1c6e:	ce cf       	rjmp	.-100    	; 0x1c0c <sensorsTask+0x1a>

00001c70 <enableFunction>:
  state->err1 = 0;
  state->err2 = 0;
}

static cliExRes_t enableFunction(cmdState_t *state)
{
    1c70:	fc 01       	movw	r30, r24
  if (state->cliMode != RESTRICTED_NORMAL)
    1c72:	80 a1       	ldd	r24, Z+32	; 0x20
    1c74:	83 30       	cpi	r24, 0x03	; 3
    1c76:	49 f0       	breq	.+18     	; 0x1c8a <enableFunction+0x1a>
  {
    state->cmdList = cmdListEnable;
    1c78:	8d e1       	ldi	r24, 0x1D	; 29
    1c7a:	94 e2       	ldi	r25, 0x24	; 36
    1c7c:	81 a3       	std	Z+33, r24	; 0x21
    1c7e:	92 a3       	std	Z+34, r25	; 0x22
    state->cliMode = NR_ENABLE;
    1c80:	81 e0       	ldi	r24, 0x01	; 1
    1c82:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1c84:	20 e0       	ldi	r18, 0x00	; 0
    1c86:	30 e0       	ldi	r19, 0x00	; 0
    1c88:	02 c0       	rjmp	.+4      	; 0x1c8e <enableFunction+0x1e>
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1c8a:	25 e0       	ldi	r18, 0x05	; 5
    1c8c:	30 e0       	ldi	r19, 0x00	; 0
}
    1c8e:	c9 01       	movw	r24, r18
    1c90:	08 95       	ret

00001c92 <disableFunction>:
static cliExRes_t disableFunction(cmdState_t *state)
{
    1c92:	fc 01       	movw	r30, r24
  state->cmdList = cmdListNormal;
    1c94:	88 e9       	ldi	r24, 0x98	; 152
    1c96:	96 e0       	ldi	r25, 0x06	; 6
    1c98:	81 a3       	std	Z+33, r24	; 0x21
    1c9a:	92 a3       	std	Z+34, r25	; 0x22
  if (state->cliMode != RESTRICTED_NORMAL)
    1c9c:	80 a1       	ldd	r24, Z+32	; 0x20
    1c9e:	83 30       	cpi	r24, 0x03	; 3
    1ca0:	09 f0       	breq	.+2      	; 0x1ca4 <disableFunction+0x12>
  {
    state->cliMode = NR_NORMAL;
    1ca2:	10 a2       	std	Z+32, r1	; 0x20
  }
  return OK_SILENT;
}
    1ca4:	80 e0       	ldi	r24, 0x00	; 0
    1ca6:	90 e0       	ldi	r25, 0x00	; 0
    1ca8:	08 95       	ret

00001caa <configureModeFunction>:
static cliExRes_t configureModeFunction(cmdState_t *state)
{
    1caa:	fc 01       	movw	r30, r24
  if (state->cliMode == NR_ENABLE)
    1cac:	80 a1       	ldd	r24, Z+32	; 0x20
    1cae:	81 30       	cpi	r24, 0x01	; 1
    1cb0:	49 f4       	brne	.+18     	; 0x1cc4 <configureModeFunction+0x1a>
  {
    state->cmdList = cmdListConfigure;
    1cb2:	8e ec       	ldi	r24, 0xCE	; 206
    1cb4:	96 e0       	ldi	r25, 0x06	; 6
    1cb6:	81 a3       	std	Z+33, r24	; 0x21
    1cb8:	92 a3       	std	Z+34, r25	; 0x22
    state->cliMode = NR_CONFIGURE;
    1cba:	82 e0       	ldi	r24, 0x02	; 2
    1cbc:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1cbe:	20 e0       	ldi	r18, 0x00	; 0
    1cc0:	30 e0       	ldi	r19, 0x00	; 0
    1cc2:	02 c0       	rjmp	.+4      	; 0x1cc8 <configureModeFunction+0x1e>
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1cc4:	25 e0       	ldi	r18, 0x05	; 5
    1cc6:	30 e0       	ldi	r19, 0x00	; 0
}
    1cc8:	c9 01       	movw	r24, r18
    1cca:	08 95       	ret

00001ccc <saveConfigFunction>:
}

static cliExRes_t saveConfigFunction(cmdState_t *state)
{
  state = NULL;
  saveConfiguration();
    1ccc:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <saveConfiguration>
  return OK_SILENT;
}
    1cd0:	80 e0       	ldi	r24, 0x00	; 0
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	08 95       	ret

00001cd6 <setMacAddrFunction>:
  ipSetConfigGw(gw);
  return OK_SILENT;
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
    1cd6:	cf 93       	push	r28
    1cd8:	df 93       	push	r29
    1cda:	ec 01       	movw	r28, r24
  if (state->argc < 6)
    1cdc:	89 8d       	ldd	r24, Y+25	; 0x19
    1cde:	86 30       	cpi	r24, 0x06	; 6
    1ce0:	58 f1       	brcs	.+86     	; 0x1d38 <setMacAddrFunction+0x62>
    return SYNTAX_ERROR;  
  
  nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
    1ce2:	81 e0       	ldi	r24, 0x01	; 1
    1ce4:	be 01       	movw	r22, r28
    1ce6:	0e 94 66 26 	call	0x4ccc	; 0x4ccc <cmdlineGetArgHex>
    1cea:	60 93 de 31 	sts	0x31DE, r22
  nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
    1cee:	82 e0       	ldi	r24, 0x02	; 2
    1cf0:	be 01       	movw	r22, r28
    1cf2:	0e 94 66 26 	call	0x4ccc	; 0x4ccc <cmdlineGetArgHex>
    1cf6:	60 93 df 31 	sts	0x31DF, r22
  nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
    1cfa:	83 e0       	ldi	r24, 0x03	; 3
    1cfc:	be 01       	movw	r22, r28
    1cfe:	0e 94 66 26 	call	0x4ccc	; 0x4ccc <cmdlineGetArgHex>
    1d02:	60 93 e0 31 	sts	0x31E0, r22
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
    1d06:	84 e0       	ldi	r24, 0x04	; 4
    1d08:	be 01       	movw	r22, r28
    1d0a:	0e 94 66 26 	call	0x4ccc	; 0x4ccc <cmdlineGetArgHex>
    1d0e:	60 93 e1 31 	sts	0x31E1, r22
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
    1d12:	85 e0       	ldi	r24, 0x05	; 5
    1d14:	be 01       	movw	r22, r28
    1d16:	0e 94 66 26 	call	0x4ccc	; 0x4ccc <cmdlineGetArgHex>
    1d1a:	60 93 e2 31 	sts	0x31E2, r22
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
    1d1e:	86 e0       	ldi	r24, 0x06	; 6
    1d20:	be 01       	movw	r22, r28
    1d22:	0e 94 66 26 	call	0x4ccc	; 0x4ccc <cmdlineGetArgHex>
    1d26:	60 93 e3 31 	sts	0x31E3, r22
  nicSetMacAddress(nicState.mac.addr);
    1d2a:	8e ed       	ldi	r24, 0xDE	; 222
    1d2c:	91 e3       	ldi	r25, 0x31	; 49
    1d2e:	0e 94 1e 2c 	call	0x583c	; 0x583c <nicSetMacAddress>
  return OK_SILENT;
    1d32:	20 e0       	ldi	r18, 0x00	; 0
    1d34:	30 e0       	ldi	r19, 0x00	; 0
    1d36:	02 c0       	rjmp	.+4      	; 0x1d3c <setMacAddrFunction+0x66>
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
  if (state->argc < 6)
    return SYNTAX_ERROR;  
    1d38:	22 e0       	ldi	r18, 0x02	; 2
    1d3a:	30 e0       	ldi	r19, 0x00	; 0
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}
    1d3c:	c9 01       	movw	r24, r18
    1d3e:	df 91       	pop	r29
    1d40:	cf 91       	pop	r28
    1d42:	08 95       	ret

00001d44 <pingFunction>:
  printErrorInfo(state);
  return OK_SILENT;
}

static cliExRes_t pingFunction(cmdState_t *state)
{
    1d44:	cf 93       	push	r28
    1d46:	df 93       	push	r29
    1d48:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1d4a:	89 8d       	ldd	r24, Y+25	; 0x19
    1d4c:	84 30       	cpi	r24, 0x04	; 4
    1d4e:	98 f0       	brcs	.+38     	; 0x1d76 <pingFunction+0x32>
    return SYNTAX_ERROR;
  
  uint8_t ip[4];
  ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
    1d50:	81 e0       	ldi	r24, 0x01	; 1
    1d52:	be 01       	movw	r22, r28
    1d54:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
  ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
    1d58:	82 e0       	ldi	r24, 0x02	; 2
    1d5a:	be 01       	movw	r22, r28
    1d5c:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
  ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
    1d60:	83 e0       	ldi	r24, 0x03	; 3
    1d62:	be 01       	movw	r22, r28
    1d64:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
    1d68:	84 e0       	ldi	r24, 0x04	; 4
    1d6a:	be 01       	movw	r22, r28
    1d6c:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
    1d70:	20 e0       	ldi	r18, 0x00	; 0
    1d72:	30 e0       	ldi	r19, 0x00	; 0
    1d74:	02 c0       	rjmp	.+4      	; 0x1d7a <pingFunction+0x36>
}

static cliExRes_t pingFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    1d76:	22 e0       	ldi	r18, 0x02	; 2
    1d78:	30 e0       	ldi	r19, 0x00	; 0
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
}
    1d7a:	c9 01       	movw	r24, r18
    1d7c:	df 91       	pop	r29
    1d7e:	cf 91       	pop	r28
    1d80:	08 95       	ret

00001d82 <setUdpFunction>:
  ipSetConfigIp(ip);
  return OK_SILENT;
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
    1d82:	2f 92       	push	r2
    1d84:	3f 92       	push	r3
    1d86:	4f 92       	push	r4
    1d88:	5f 92       	push	r5
    1d8a:	6f 92       	push	r6
    1d8c:	7f 92       	push	r7
    1d8e:	8f 92       	push	r8
    1d90:	9f 92       	push	r9
    1d92:	af 92       	push	r10
    1d94:	bf 92       	push	r11
    1d96:	cf 92       	push	r12
    1d98:	df 92       	push	r13
    1d9a:	ef 92       	push	r14
    1d9c:	ff 92       	push	r15
    1d9e:	0f 93       	push	r16
    1da0:	1f 93       	push	r17
    1da2:	cf 93       	push	r28
    1da4:	df 93       	push	r29
    1da6:	ec 01       	movw	r28, r24
  if (state->argc < 5)
    1da8:	89 8d       	ldd	r24, Y+25	; 0x19
    1daa:	85 30       	cpi	r24, 0x05	; 5
    1dac:	08 f4       	brcc	.+2      	; 0x1db0 <setUdpFunction+0x2e>
    1dae:	58 c0       	rjmp	.+176    	; 0x1e60 <setUdpFunction+0xde>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	be 01       	movw	r22, r28
    1db4:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1db8:	1b 01       	movw	r2, r22
    1dba:	2c 01       	movw	r4, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1dbc:	82 e0       	ldi	r24, 0x02	; 2
    1dbe:	be 01       	movw	r22, r28
    1dc0:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1dc4:	5b 01       	movw	r10, r22
    1dc6:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1dc8:	83 e0       	ldi	r24, 0x03	; 3
    1dca:	be 01       	movw	r22, r28
    1dcc:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1dd0:	3b 01       	movw	r6, r22
    1dd2:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1dd4:	84 e0       	ldi	r24, 0x04	; 4
    1dd6:	be 01       	movw	r22, r28
    1dd8:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1ddc:	7b 01       	movw	r14, r22
    1dde:	8c 01       	movw	r16, r24
  udpSocket->dstIp = ip;
    1de0:	e0 91 02 32 	lds	r30, 0x3202
    1de4:	f0 91 03 32 	lds	r31, 0x3203
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1de8:	bc 2d       	mov	r27, r12
    1dea:	ab 2d       	mov	r26, r11
    1dec:	9a 2d       	mov	r25, r10
    1dee:	88 27       	eor	r24, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1df0:	a3 01       	movw	r20, r6
    1df2:	33 27       	eor	r19, r19
    1df4:	22 27       	eor	r18, r18
static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1df6:	82 0f       	add	r24, r18
    1df8:	93 1f       	adc	r25, r19
    1dfa:	a4 1f       	adc	r26, r20
    1dfc:	b5 1f       	adc	r27, r21
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1dfe:	82 0d       	add	r24, r2
    1e00:	93 1d       	adc	r25, r3
    1e02:	a4 1d       	adc	r26, r4
    1e04:	b5 1d       	adc	r27, r5
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1e06:	1e 2d       	mov	r17, r14
    1e08:	00 27       	eor	r16, r16
    1e0a:	ff 24       	eor	r15, r15
    1e0c:	ee 24       	eor	r14, r14
static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1e0e:	8e 0d       	add	r24, r14
    1e10:	9f 1d       	adc	r25, r15
    1e12:	a0 1f       	adc	r26, r16
    1e14:	b1 1f       	adc	r27, r17
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  udpSocket->dstIp = ip;
    1e16:	86 83       	std	Z+6, r24	; 0x06
    1e18:	97 83       	std	Z+7, r25	; 0x07
    1e1a:	a0 87       	std	Z+8, r26	; 0x08
    1e1c:	b1 87       	std	Z+9, r27	; 0x09
  
  uint16_t port = cmdlineGetArgInt(5, state);
    1e1e:	85 e0       	ldi	r24, 0x05	; 5
    1e20:	be 01       	movw	r22, r28
    1e22:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1e26:	dc 01       	movw	r26, r24
    1e28:	cb 01       	movw	r24, r22
  udpSocket->srcPort = htons(port);
    1e2a:	e0 90 02 32 	lds	r14, 0x3202
    1e2e:	f0 90 03 32 	lds	r15, 0x3203
    1e32:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    1e36:	f7 01       	movw	r30, r14
    1e38:	84 83       	std	Z+4, r24	; 0x04
    1e3a:	95 83       	std	Z+5, r25	; 0x05
  
  if (state->argc > 5)
    1e3c:	89 8d       	ldd	r24, Y+25	; 0x19
    1e3e:	86 30       	cpi	r24, 0x06	; 6
    1e40:	90 f0       	brcs	.+36     	; 0x1e66 <setUdpFunction+0xe4>
  {
    port = cmdlineGetArgInt(6, state);
    1e42:	86 e0       	ldi	r24, 0x06	; 6
    1e44:	be 01       	movw	r22, r28
    1e46:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1e4a:	dc 01       	movw	r26, r24
    1e4c:	cb 01       	movw	r24, r22
    udpSocket->dstPort = htons(port);    
    1e4e:	c0 91 02 32 	lds	r28, 0x3202
    1e52:	d0 91 03 32 	lds	r29, 0x3203
    1e56:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    1e5a:	8a 83       	std	Y+2, r24	; 0x02
    1e5c:	9b 83       	std	Y+3, r25	; 0x03
    1e5e:	03 c0       	rjmp	.+6      	; 0x1e66 <setUdpFunction+0xe4>
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
    1e60:	22 e0       	ldi	r18, 0x02	; 2
    1e62:	30 e0       	ldi	r19, 0x00	; 0
    1e64:	02 c0       	rjmp	.+4      	; 0x1e6a <setUdpFunction+0xe8>
  if (state->argc > 5)
  {
    port = cmdlineGetArgInt(6, state);
    udpSocket->dstPort = htons(port);    
  }
  return OK_SILENT;
    1e66:	20 e0       	ldi	r18, 0x00	; 0
    1e68:	30 e0       	ldi	r19, 0x00	; 0
}
    1e6a:	c9 01       	movw	r24, r18
    1e6c:	df 91       	pop	r29
    1e6e:	cf 91       	pop	r28
    1e70:	1f 91       	pop	r17
    1e72:	0f 91       	pop	r16
    1e74:	ff 90       	pop	r15
    1e76:	ef 90       	pop	r14
    1e78:	df 90       	pop	r13
    1e7a:	cf 90       	pop	r12
    1e7c:	bf 90       	pop	r11
    1e7e:	af 90       	pop	r10
    1e80:	9f 90       	pop	r9
    1e82:	8f 90       	pop	r8
    1e84:	7f 90       	pop	r7
    1e86:	6f 90       	pop	r6
    1e88:	5f 90       	pop	r5
    1e8a:	4f 90       	pop	r4
    1e8c:	3f 90       	pop	r3
    1e8e:	2f 90       	pop	r2
    1e90:	08 95       	ret

00001e92 <setIpGwFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
    1e92:	6f 92       	push	r6
    1e94:	7f 92       	push	r7
    1e96:	8f 92       	push	r8
    1e98:	9f 92       	push	r9
    1e9a:	af 92       	push	r10
    1e9c:	bf 92       	push	r11
    1e9e:	cf 92       	push	r12
    1ea0:	df 92       	push	r13
    1ea2:	ef 92       	push	r14
    1ea4:	ff 92       	push	r15
    1ea6:	0f 93       	push	r16
    1ea8:	1f 93       	push	r17
    1eaa:	cf 93       	push	r28
    1eac:	df 93       	push	r29
    1eae:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1eb0:	89 8d       	ldd	r24, Y+25	; 0x19
    1eb2:	84 30       	cpi	r24, 0x04	; 4
    1eb4:	b0 f1       	brcs	.+108    	; 0x1f22 <setIpGwFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1eb6:	81 e0       	ldi	r24, 0x01	; 1
    1eb8:	be 01       	movw	r22, r28
    1eba:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1ebe:	3b 01       	movw	r6, r22
    1ec0:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1ec2:	82 e0       	ldi	r24, 0x02	; 2
    1ec4:	be 01       	movw	r22, r28
    1ec6:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1eca:	7b 01       	movw	r14, r22
    1ecc:	8c 01       	movw	r16, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    1ece:	83 e0       	ldi	r24, 0x03	; 3
    1ed0:	be 01       	movw	r22, r28
    1ed2:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1ed6:	5b 01       	movw	r10, r22
    1ed8:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1eda:	84 e0       	ldi	r24, 0x04	; 4
    1edc:	be 01       	movw	r22, r28
    1ede:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1ee2:	dc 01       	movw	r26, r24
    1ee4:	cb 01       	movw	r24, r22
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1ee6:	10 2f       	mov	r17, r16
    1ee8:	0f 2d       	mov	r16, r15
    1eea:	fe 2c       	mov	r15, r14
    1eec:	ee 24       	eor	r14, r14
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    1eee:	65 01       	movw	r12, r10
    1ef0:	bb 24       	eor	r11, r11
    1ef2:	aa 24       	eor	r10, r10
static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1ef4:	ea 0c       	add	r14, r10
    1ef6:	fb 1c       	adc	r15, r11
    1ef8:	0c 1d       	adc	r16, r12
    1efa:	1d 1d       	adc	r17, r13
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1efc:	e6 0c       	add	r14, r6
    1efe:	f7 1c       	adc	r15, r7
    1f00:	08 1d       	adc	r16, r8
    1f02:	19 1d       	adc	r17, r9
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1f04:	b8 2f       	mov	r27, r24
    1f06:	aa 27       	eor	r26, r26
    1f08:	99 27       	eor	r25, r25
    1f0a:	88 27       	eor	r24, r24
static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1f0c:	e8 0e       	add	r14, r24
    1f0e:	f9 1e       	adc	r15, r25
    1f10:	0a 1f       	adc	r16, r26
    1f12:	1b 1f       	adc	r17, r27
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  ipSetConfigGw(gw);
    1f14:	c8 01       	movw	r24, r16
    1f16:	b7 01       	movw	r22, r14
    1f18:	0e 94 e6 32 	call	0x65cc	; 0x65cc <ipSetConfigGw>
  return OK_SILENT;
    1f1c:	20 e0       	ldi	r18, 0x00	; 0
    1f1e:	30 e0       	ldi	r19, 0x00	; 0
    1f20:	02 c0       	rjmp	.+4      	; 0x1f26 <setIpGwFunction+0x94>


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    1f22:	22 e0       	ldi	r18, 0x02	; 2
    1f24:	30 e0       	ldi	r19, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  ipSetConfigGw(gw);
  return OK_SILENT;
}
    1f26:	c9 01       	movw	r24, r18
    1f28:	df 91       	pop	r29
    1f2a:	cf 91       	pop	r28
    1f2c:	1f 91       	pop	r17
    1f2e:	0f 91       	pop	r16
    1f30:	ff 90       	pop	r15
    1f32:	ef 90       	pop	r14
    1f34:	df 90       	pop	r13
    1f36:	cf 90       	pop	r12
    1f38:	bf 90       	pop	r11
    1f3a:	af 90       	pop	r10
    1f3c:	9f 90       	pop	r9
    1f3e:	8f 90       	pop	r8
    1f40:	7f 90       	pop	r7
    1f42:	6f 90       	pop	r6
    1f44:	08 95       	ret

00001f46 <setIpMaskFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
    1f46:	bc 01       	movw	r22, r24
  if (state->argc < 1)
    1f48:	fc 01       	movw	r30, r24
    1f4a:	81 8d       	ldd	r24, Z+25	; 0x19
    1f4c:	88 23       	and	r24, r24
    1f4e:	b1 f0       	breq	.+44     	; 0x1f7c <setIpMaskFunction+0x36>
    return SYNTAX_ERROR;
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1f56:	20 e2       	ldi	r18, 0x20	; 32
    1f58:	30 e0       	ldi	r19, 0x00	; 0
    1f5a:	26 1b       	sub	r18, r22
    1f5c:	37 0b       	sbc	r19, r23
    1f5e:	6f ef       	ldi	r22, 0xFF	; 255
    1f60:	7f ef       	ldi	r23, 0xFF	; 255
    1f62:	cb 01       	movw	r24, r22
    1f64:	04 c0       	rjmp	.+8      	; 0x1f6e <setIpMaskFunction+0x28>
    1f66:	96 95       	lsr	r25
    1f68:	87 95       	ror	r24
    1f6a:	77 95       	ror	r23
    1f6c:	67 95       	ror	r22
    1f6e:	2a 95       	dec	r18
    1f70:	d2 f7       	brpl	.-12     	; 0x1f66 <setIpMaskFunction+0x20>
  
  ipSetConfigMask(mask);
    1f72:	0e 94 dd 32 	call	0x65ba	; 0x65ba <ipSetConfigMask>
  return OK_SILENT;
    1f76:	20 e0       	ldi	r18, 0x00	; 0
    1f78:	30 e0       	ldi	r19, 0x00	; 0
    1f7a:	02 c0       	rjmp	.+4      	; 0x1f80 <setIpMaskFunction+0x3a>


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    1f7c:	22 e0       	ldi	r18, 0x02	; 2
    1f7e:	30 e0       	ldi	r19, 0x00	; 0
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
  
  ipSetConfigMask(mask);
  return OK_SILENT;
}
    1f80:	c9 01       	movw	r24, r18
    1f82:	08 95       	ret

00001f84 <setIpFunction>:
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
  return OK_SILENT;
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
    1f84:	6f 92       	push	r6
    1f86:	7f 92       	push	r7
    1f88:	8f 92       	push	r8
    1f8a:	9f 92       	push	r9
    1f8c:	af 92       	push	r10
    1f8e:	bf 92       	push	r11
    1f90:	cf 92       	push	r12
    1f92:	df 92       	push	r13
    1f94:	ef 92       	push	r14
    1f96:	ff 92       	push	r15
    1f98:	0f 93       	push	r16
    1f9a:	1f 93       	push	r17
    1f9c:	cf 93       	push	r28
    1f9e:	df 93       	push	r29
    1fa0:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1fa2:	89 8d       	ldd	r24, Y+25	; 0x19
    1fa4:	84 30       	cpi	r24, 0x04	; 4
    1fa6:	b0 f1       	brcs	.+108    	; 0x2014 <setIpFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1fa8:	81 e0       	ldi	r24, 0x01	; 1
    1faa:	be 01       	movw	r22, r28
    1fac:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1fb0:	3b 01       	movw	r6, r22
    1fb2:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1fb4:	82 e0       	ldi	r24, 0x02	; 2
    1fb6:	be 01       	movw	r22, r28
    1fb8:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1fbc:	7b 01       	movw	r14, r22
    1fbe:	8c 01       	movw	r16, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1fc0:	83 e0       	ldi	r24, 0x03	; 3
    1fc2:	be 01       	movw	r22, r28
    1fc4:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1fc8:	5b 01       	movw	r10, r22
    1fca:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1fcc:	84 e0       	ldi	r24, 0x04	; 4
    1fce:	be 01       	movw	r22, r28
    1fd0:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    1fd4:	dc 01       	movw	r26, r24
    1fd6:	cb 01       	movw	r24, r22
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1fd8:	10 2f       	mov	r17, r16
    1fda:	0f 2d       	mov	r16, r15
    1fdc:	fe 2c       	mov	r15, r14
    1fde:	ee 24       	eor	r14, r14
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1fe0:	65 01       	movw	r12, r10
    1fe2:	bb 24       	eor	r11, r11
    1fe4:	aa 24       	eor	r10, r10
static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1fe6:	ea 0c       	add	r14, r10
    1fe8:	fb 1c       	adc	r15, r11
    1fea:	0c 1d       	adc	r16, r12
    1fec:	1d 1d       	adc	r17, r13
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1fee:	e6 0c       	add	r14, r6
    1ff0:	f7 1c       	adc	r15, r7
    1ff2:	08 1d       	adc	r16, r8
    1ff4:	19 1d       	adc	r17, r9
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1ff6:	b8 2f       	mov	r27, r24
    1ff8:	aa 27       	eor	r26, r26
    1ffa:	99 27       	eor	r25, r25
    1ffc:	88 27       	eor	r24, r24
static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1ffe:	e8 0e       	add	r14, r24
    2000:	f9 1e       	adc	r15, r25
    2002:	0a 1f       	adc	r16, r26
    2004:	1b 1f       	adc	r17, r27
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  
  ipSetConfigIp(ip);
    2006:	c8 01       	movw	r24, r16
    2008:	b7 01       	movw	r22, r14
    200a:	0e 94 d4 32 	call	0x65a8	; 0x65a8 <ipSetConfigIp>
  return OK_SILENT;
    200e:	20 e0       	ldi	r18, 0x00	; 0
    2010:	30 e0       	ldi	r19, 0x00	; 0
    2012:	02 c0       	rjmp	.+4      	; 0x2018 <setIpFunction+0x94>
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    2014:	22 e0       	ldi	r18, 0x02	; 2
    2016:	30 e0       	ldi	r19, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  
  ipSetConfigIp(ip);
  return OK_SILENT;
}
    2018:	c9 01       	movw	r24, r18
    201a:	df 91       	pop	r29
    201c:	cf 91       	pop	r28
    201e:	1f 91       	pop	r17
    2020:	0f 91       	pop	r16
    2022:	ff 90       	pop	r15
    2024:	ef 90       	pop	r14
    2026:	df 90       	pop	r13
    2028:	cf 90       	pop	r12
    202a:	bf 90       	pop	r11
    202c:	af 90       	pop	r10
    202e:	9f 90       	pop	r9
    2030:	8f 90       	pop	r8
    2032:	7f 90       	pop	r7
    2034:	6f 90       	pop	r6
    2036:	08 95       	ret

00002038 <czytajAC_Function>:
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}

static cliExRes_t czytajAC_Function(cmdState_t *state)
{
    2038:	0f 93       	push	r16
    203a:	1f 93       	push	r17
    203c:	df 93       	push	r29
    203e:	cf 93       	push	r28
    2040:	0f 92       	push	r0
    2042:	cd b7       	in	r28, 0x3d	; 61
    2044:	de b7       	in	r29, 0x3e	; 62
    2046:	8c 01       	movw	r16, r24
  uint8_t nrWejscia = cmdlineGetArgInt(1, state);
    2048:	81 e0       	ldi	r24, 0x01	; 1
    204a:	b8 01       	movw	r22, r16
    204c:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
  uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
    2050:	86 2f       	mov	r24, r22
    2052:	69 83       	std	Y+1, r22	; 0x01
    2054:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <MCP3008_getSampleSingle>
  fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
    2058:	2d b7       	in	r18, 0x3d	; 61
    205a:	3e b7       	in	r19, 0x3e	; 62
    205c:	28 50       	subi	r18, 0x08	; 8
    205e:	30 40       	sbci	r19, 0x00	; 0
    2060:	2d bf       	out	0x3d, r18	; 61
    2062:	3e bf       	out	0x3e, r19	; 62
    2064:	ed b7       	in	r30, 0x3d	; 61
    2066:	fe b7       	in	r31, 0x3e	; 62
    2068:	31 96       	adiw	r30, 0x01	; 1
    206a:	d8 01       	movw	r26, r16
    206c:	5a 96       	adiw	r26, 0x1a	; 26
    206e:	2d 91       	ld	r18, X+
    2070:	3c 91       	ld	r19, X
    2072:	5b 97       	sbiw	r26, 0x1b	; 27
    2074:	ad b7       	in	r26, 0x3d	; 61
    2076:	be b7       	in	r27, 0x3e	; 62
    2078:	11 96       	adiw	r26, 0x01	; 1
    207a:	2d 93       	st	X+, r18
    207c:	3c 93       	st	X, r19
    207e:	12 97       	sbiw	r26, 0x02	; 2
    2080:	2c e1       	ldi	r18, 0x1C	; 28
    2082:	37 e0       	ldi	r19, 0x07	; 7
    2084:	22 83       	std	Z+2, r18	; 0x02
    2086:	33 83       	std	Z+3, r19	; 0x03
    2088:	69 81       	ldd	r22, Y+1	; 0x01
    208a:	64 83       	std	Z+4, r22	; 0x04
    208c:	15 82       	std	Z+5, r1	; 0x05
    208e:	86 83       	std	Z+6, r24	; 0x06
    2090:	97 83       	std	Z+7, r25	; 0x07
    2092:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    2096:	ed b7       	in	r30, 0x3d	; 61
    2098:	fe b7       	in	r31, 0x3e	; 62
    209a:	38 96       	adiw	r30, 0x08	; 8
    209c:	ed bf       	out	0x3d, r30	; 61
    209e:	fe bf       	out	0x3e, r31	; 62
  return OK_SILENT;
}
    20a0:	80 e0       	ldi	r24, 0x00	; 0
    20a2:	90 e0       	ldi	r25, 0x00	; 0
    20a4:	0f 90       	pop	r0
    20a6:	cf 91       	pop	r28
    20a8:	df 91       	pop	r29
    20aa:	1f 91       	pop	r17
    20ac:	0f 91       	pop	r16
    20ae:	08 95       	ret

000020b0 <setTimeFunction>:
  return SYNTAX_ERROR;
}


static cliExRes_t setTimeFunction(cmdState_t *state)
{
    20b0:	ff 92       	push	r15
    20b2:	0f 93       	push	r16
    20b4:	1f 93       	push	r17
    20b6:	cf 93       	push	r28
    20b8:	df 93       	push	r29
    20ba:	ec 01       	movw	r28, r24
  uint8_t godzina =  cmdlineGetArgInt(1, state);
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	be 01       	movw	r22, r28
    20c0:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    20c4:	f6 2e       	mov	r15, r22
  uint8_t minuta  =  cmdlineGetArgInt(2, state);
    20c6:	82 e0       	ldi	r24, 0x02	; 2
    20c8:	be 01       	movw	r22, r28
    20ca:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    20ce:	06 2f       	mov	r16, r22
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
    20d0:	83 e0       	ldi	r24, 0x03	; 3
    20d2:	be 01       	movw	r22, r28
    20d4:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    20d8:	16 2f       	mov	r17, r22
  
  ds1305start();
    20da:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <ds1305start>

  uint8_t cDzies = godzina/10;
    20de:	5a e0       	ldi	r21, 0x0A	; 10
    20e0:	8f 2d       	mov	r24, r15
    20e2:	65 2f       	mov	r22, r21
    20e4:	0e 94 15 54 	call	0xa82a	; 0xa82a <__udivmodqi4>
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
    20e8:	48 2f       	mov	r20, r24
    20ea:	43 70       	andi	r20, 0x03	; 3
    20ec:	27 e1       	ldi	r18, 0x17	; 23
    20ee:	32 e3       	ldi	r19, 0x32	; 50
    20f0:	42 95       	swap	r20
    20f2:	40 7f       	andi	r20, 0xF0	; 240
    20f4:	90 91 17 32 	lds	r25, 0x3217
    20f8:	9f 7c       	andi	r25, 0xCF	; 207
    20fa:	94 2b       	or	r25, r20
    20fc:	90 93 17 32 	sts	0x3217, r25
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
  
  ds1305start();

  uint8_t cDzies = godzina/10;
  uint8_t cJedn = godzina - cDzies*10;
    2100:	46 ef       	ldi	r20, 0xF6	; 246
    2102:	84 9f       	mul	r24, r20
    2104:	80 2d       	mov	r24, r0
    2106:	11 24       	eor	r1, r1
    2108:	8f 0d       	add	r24, r15
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;
    210a:	8f 70       	andi	r24, 0x0F	; 15
    210c:	90 91 17 32 	lds	r25, 0x3217
    2110:	90 7f       	andi	r25, 0xF0	; 240
    2112:	98 2b       	or	r25, r24
    2114:	90 93 17 32 	sts	0x3217, r25
  
  cDzies = minuta/10;
    2118:	80 2f       	mov	r24, r16
    211a:	0e 94 15 54 	call	0xa82a	; 0xa82a <__udivmodqi4>
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
    211e:	68 2f       	mov	r22, r24
    2120:	67 70       	andi	r22, 0x07	; 7
    2122:	f9 01       	movw	r30, r18
    2124:	62 95       	swap	r22
    2126:	60 7f       	andi	r22, 0xF0	; 240
    2128:	92 91       	ld	r25, -Z
    212a:	9f 78       	andi	r25, 0x8F	; 143
    212c:	96 2b       	or	r25, r22
    212e:	90 83       	st	Z, r25
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;
  
  cDzies = minuta/10;
  cJedn = minuta - cDzies * 10;
    2130:	84 9f       	mul	r24, r20
    2132:	80 2d       	mov	r24, r0
    2134:	11 24       	eor	r1, r1
    2136:	80 0f       	add	r24, r16
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;
    2138:	8f 70       	andi	r24, 0x0F	; 15
    213a:	90 81       	ld	r25, Z
    213c:	90 7f       	andi	r25, 0xF0	; 240
    213e:	98 2b       	or	r25, r24
    2140:	90 83       	st	Z, r25
  
  cDzies = sekunda/10;
    2142:	81 2f       	mov	r24, r17
    2144:	65 2f       	mov	r22, r21
    2146:	0e 94 15 54 	call	0xa82a	; 0xa82a <__udivmodqi4>
  cJedn  = sekunda - cDzies * 10;
  czasRtc.seconds.cDzies = cDzies;
    214a:	58 2f       	mov	r21, r24
    214c:	57 70       	andi	r21, 0x07	; 7
    214e:	f9 01       	movw	r30, r18
    2150:	32 97       	sbiw	r30, 0x02	; 2
    2152:	52 95       	swap	r21
    2154:	50 7f       	andi	r21, 0xF0	; 240
    2156:	90 81       	ld	r25, Z
    2158:	9f 78       	andi	r25, 0x8F	; 143
    215a:	95 2b       	or	r25, r21
    215c:	90 83       	st	Z, r25
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;
  
  cDzies = sekunda/10;
  cJedn  = sekunda - cDzies * 10;
    215e:	84 9f       	mul	r24, r20
    2160:	40 2d       	mov	r20, r0
    2162:	11 24       	eor	r1, r1
    2164:	41 0f       	add	r20, r17
  czasRtc.seconds.cDzies = cDzies;
  czasRtc.seconds.cJedn  = cJedn;
    2166:	4f 70       	andi	r20, 0x0F	; 15
    2168:	90 81       	ld	r25, Z
    216a:	90 7f       	andi	r25, 0xF0	; 240
    216c:	94 2b       	or	r25, r20
    216e:	90 83       	st	Z, r25
  
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
    2170:	cf 01       	movw	r24, r30
    2172:	0e 94 e8 27 	call	0x4fd0	; 0x4fd0 <setTimeDecoded>
  return OK_SILENT;
}
    2176:	80 e0       	ldi	r24, 0x00	; 0
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	df 91       	pop	r29
    217c:	cf 91       	pop	r28
    217e:	1f 91       	pop	r17
    2180:	0f 91       	pop	r16
    2182:	ff 90       	pop	r15
    2184:	08 95       	ret

00002186 <ustawPortRezystor>:
  MPC23s17SetPortB(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
    2186:	bc 01       	movw	r22, r24
  if (state->argc < 1)
    2188:	fc 01       	movw	r30, r24
    218a:	81 8d       	ldd	r24, Z+25	; 0x19
    218c:	88 23       	and	r24, r24
    218e:	49 f0       	breq	.+18     	; 0x21a2 <ustawPortRezystor+0x1c>
    return SYNTAX_ERROR;

  uint8_t wartosc = cmdlineGetArgInt(1, state);
    2190:	81 e0       	ldi	r24, 0x01	; 1
    2192:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    2196:	86 2f       	mov	r24, r22
  
  MCP4150_setValue(wartosc);
    2198:	0e 94 29 2a 	call	0x5452	; 0x5452 <MCP4150_setValue>
  
  return OK_SILENT;
    219c:	20 e0       	ldi	r18, 0x00	; 0
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	02 c0       	rjmp	.+4      	; 0x21a6 <ustawPortRezystor+0x20>
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    21a2:	22 e0       	ldi	r18, 0x02	; 2
    21a4:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t wartosc = cmdlineGetArgInt(1, state);
  
  MCP4150_setValue(wartosc);
  
  return OK_SILENT;
}
    21a6:	c9 01       	movw	r24, r18
    21a8:	08 95       	ret

000021aa <ustawPortExtBFunction>:
  MPC23s17SetPortA(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
{
    21aa:	1f 93       	push	r17
    21ac:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    21ae:	81 e0       	ldi	r24, 0x01	; 1
    21b0:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    21b4:	16 2f       	mov	r17, r22
  MPC23s17SetDirB(0x00, 0);
    21b6:	80 e0       	ldi	r24, 0x00	; 0
    21b8:	60 e0       	ldi	r22, 0x00	; 0
    21ba:	0e 94 8c 28 	call	0x5118	; 0x5118 <MPC23s17SetDirB>
  MPC23s17SetPortB(wyjscie, 0);
    21be:	81 2f       	mov	r24, r17
    21c0:	60 e0       	ldi	r22, 0x00	; 0
    21c2:	0e 94 1e 29 	call	0x523c	; 0x523c <MPC23s17SetPortB>
  return OK_SILENT;
}
    21c6:	80 e0       	ldi	r24, 0x00	; 0
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	1f 91       	pop	r17
    21cc:	08 95       	ret

000021ce <ustawPortExtAFunction>:
  
  return ERROR_SILENT;
}

static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
{
    21ce:	1f 93       	push	r17
    21d0:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    21d2:	81 e0       	ldi	r24, 0x01	; 1
    21d4:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    21d8:	16 2f       	mov	r17, r22
  MPC23s17SetDirA(0x00, 0);
    21da:	80 e0       	ldi	r24, 0x00	; 0
    21dc:	60 e0       	ldi	r22, 0x00	; 0
    21de:	0e 94 6a 28 	call	0x50d4	; 0x50d4 <MPC23s17SetDirA>
  MPC23s17SetPortA(wyjscie, 0);
    21e2:	81 2f       	mov	r24, r17
    21e4:	60 e0       	ldi	r22, 0x00	; 0
    21e6:	0e 94 ae 28 	call	0x515c	; 0x515c <MPC23s17SetPortA>
  return OK_SILENT;
}
    21ea:	80 e0       	ldi	r24, 0x00	; 0
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	1f 91       	pop	r17
    21f0:	08 95       	ret

000021f2 <curtainDownFunction>:
  cmdPrintHelp(state);
  return OK_SILENT;
}

static cliExRes_t curtainDownFunction(cmdState_t *state)
{
    21f2:	ff 92       	push	r15
    21f4:	0f 93       	push	r16
    21f6:	1f 93       	push	r17
    21f8:	cf 93       	push	r28
    21fa:	df 93       	push	r29
    21fc:	ec 01       	movw	r28, r24
  uint8_t nrRolety;
  uint8_t nrSterownika;
  uint8_t wartosc;
  
  nrSterownika = cmdlineGetArgInt(1, state);
    21fe:	81 e0       	ldi	r24, 0x01	; 1
    2200:	be 01       	movw	r22, r28
    2202:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    2206:	06 2f       	mov	r16, r22
  nrRolety = cmdlineGetArgInt(2, state);
    2208:	82 e0       	ldi	r24, 0x02	; 2
    220a:	be 01       	movw	r22, r28
    220c:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    2210:	16 2f       	mov	r17, r22
  nrRolety &= 0x01;
    2212:	11 70       	andi	r17, 0x01	; 1
  wartosc = cmdlineGetArgInt(3, state);
    2214:	83 e0       	ldi	r24, 0x03	; 3
    2216:	be 01       	movw	r22, r28
    2218:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    221c:	f6 2e       	mov	r15, r22

  fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
    221e:	2d b7       	in	r18, 0x3d	; 61
    2220:	3e b7       	in	r19, 0x3e	; 62
    2222:	28 50       	subi	r18, 0x08	; 8
    2224:	30 40       	sbci	r19, 0x00	; 0
    2226:	2d bf       	out	0x3d, r18	; 61
    2228:	3e bf       	out	0x3e, r19	; 62
    222a:	ed b7       	in	r30, 0x3d	; 61
    222c:	fe b7       	in	r31, 0x3e	; 62
    222e:	31 96       	adiw	r30, 0x01	; 1
    2230:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2232:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2234:	ad b7       	in	r26, 0x3d	; 61
    2236:	be b7       	in	r27, 0x3e	; 62
    2238:	11 96       	adiw	r26, 0x01	; 1
    223a:	8d 93       	st	X+, r24
    223c:	9c 93       	st	X, r25
    223e:	12 97       	sbiw	r26, 0x02	; 2
    2240:	8a e3       	ldi	r24, 0x3A	; 58
    2242:	95 e0       	ldi	r25, 0x05	; 5
    2244:	82 83       	std	Z+2, r24	; 0x02
    2246:	93 83       	std	Z+3, r25	; 0x03
    2248:	04 83       	std	Z+4, r16	; 0x04
    224a:	15 82       	std	Z+5, r1	; 0x05
    224c:	21 2f       	mov	r18, r17
    224e:	30 e0       	ldi	r19, 0x00	; 0
    2250:	2f 5f       	subi	r18, 0xFF	; 255
    2252:	3f 4f       	sbci	r19, 0xFF	; 255
    2254:	26 83       	std	Z+6, r18	; 0x06
    2256:	37 83       	std	Z+7, r19	; 0x07
    2258:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>

  if ((wartosc > 0) && (wartosc <=100))
    225c:	8f 2d       	mov	r24, r15
    225e:	81 50       	subi	r24, 0x01	; 1
    2260:	2d b7       	in	r18, 0x3d	; 61
    2262:	3e b7       	in	r19, 0x3e	; 62
    2264:	28 5f       	subi	r18, 0xF8	; 248
    2266:	3f 4f       	sbci	r19, 0xFF	; 255
    2268:	2d bf       	out	0x3d, r18	; 61
    226a:	3e bf       	out	0x3e, r19	; 62
    226c:	84 36       	cpi	r24, 0x64	; 100
    226e:	d8 f4       	brcc	.+54     	; 0x22a6 <curtainDownFunction+0xb4>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    2270:	00 d0       	rcall	.+0      	; 0x2272 <curtainDownFunction+0x80>
    2272:	00 d0       	rcall	.+0      	; 0x2274 <curtainDownFunction+0x82>
    2274:	ed b7       	in	r30, 0x3d	; 61
    2276:	fe b7       	in	r31, 0x3e	; 62
    2278:	31 96       	adiw	r30, 0x01	; 1
    227a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    227c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    227e:	ad b7       	in	r26, 0x3d	; 61
    2280:	be b7       	in	r27, 0x3e	; 62
    2282:	11 96       	adiw	r26, 0x01	; 1
    2284:	8d 93       	st	X+, r24
    2286:	9c 93       	st	X, r25
    2288:	12 97       	sbiw	r26, 0x02	; 2
    228a:	2d e6       	ldi	r18, 0x6D	; 109
    228c:	35 e0       	ldi	r19, 0x05	; 5
    228e:	22 83       	std	Z+2, r18	; 0x02
    2290:	33 83       	std	Z+3, r19	; 0x03
    2292:	f4 82       	std	Z+4, r15	; 0x04
    2294:	15 82       	std	Z+5, r1	; 0x05
    2296:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    229a:	2d b7       	in	r18, 0x3d	; 61
    229c:	3e b7       	in	r19, 0x3e	; 62
    229e:	2a 5f       	subi	r18, 0xFA	; 250
    22a0:	3f 4f       	sbci	r19, 0xFF	; 255
    22a2:	2d bf       	out	0x3d, r18	; 61
    22a4:	3e bf       	out	0x3e, r19	; 62

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
    22a6:	80 2f       	mov	r24, r16
    22a8:	61 2f       	mov	r22, r17
    22aa:	4f 2d       	mov	r20, r15
    22ac:	0e 94 42 45 	call	0x8a84	; 0x8a84 <rs485curtainDown>
  
  if (result == 0)
    22b0:	88 23       	and	r24, r24
    22b2:	19 f4       	brne	.+6      	; 0x22ba <curtainDownFunction+0xc8>
    return OK_INFORM;
    22b4:	21 e0       	ldi	r18, 0x01	; 1
    22b6:	30 e0       	ldi	r19, 0x00	; 0
    22b8:	02 c0       	rjmp	.+4      	; 0x22be <curtainDownFunction+0xcc>
  
  return ERROR_SILENT;
    22ba:	23 e0       	ldi	r18, 0x03	; 3
    22bc:	30 e0       	ldi	r19, 0x00	; 0
}
    22be:	c9 01       	movw	r24, r18
    22c0:	df 91       	pop	r29
    22c2:	cf 91       	pop	r28
    22c4:	1f 91       	pop	r17
    22c6:	0f 91       	pop	r16
    22c8:	ff 90       	pop	r15
    22ca:	08 95       	ret

000022cc <curtainUpFunction>:

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
    22cc:	ff 92       	push	r15
    22ce:	0f 93       	push	r16
    22d0:	1f 93       	push	r17
    22d2:	cf 93       	push	r28
    22d4:	df 93       	push	r29
    22d6:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    22d8:	89 8d       	ldd	r24, Y+25	; 0x19
    22da:	82 30       	cpi	r24, 0x02	; 2
    22dc:	08 f4       	brcc	.+2      	; 0x22e0 <curtainUpFunction+0x14>
    22de:	65 c0       	rjmp	.+202    	; 0x23aa <curtainUpFunction+0xde>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
    22e0:	81 e0       	ldi	r24, 0x01	; 1
    22e2:	be 01       	movw	r22, r28
    22e4:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    22e8:	06 2f       	mov	r16, r22
    22ea:	0f 73       	andi	r16, 0x3F	; 63
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
    22ec:	82 e0       	ldi	r24, 0x02	; 2
    22ee:	be 01       	movw	r22, r28
    22f0:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    22f4:	16 2f       	mov	r17, r22
    22f6:	11 70       	andi	r17, 0x01	; 1
  uint8_t wartosc = 255;
  if (state->argc > 2)
    22f8:	89 8d       	ldd	r24, Y+25	; 0x19
    22fa:	83 30       	cpi	r24, 0x03	; 3
    22fc:	30 f0       	brcs	.+12     	; 0x230a <curtainUpFunction+0x3e>
    wartosc = cmdlineGetArgInt(3, state);
    22fe:	83 e0       	ldi	r24, 0x03	; 3
    2300:	be 01       	movw	r22, r28
    2302:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    2306:	f6 2e       	mov	r15, r22
    2308:	02 c0       	rjmp	.+4      	; 0x230e <curtainUpFunction+0x42>
  if (state->argc < 2)
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
  uint8_t wartosc = 255;
    230a:	ff 24       	eor	r15, r15
    230c:	fa 94       	dec	r15
  if (state->argc > 2)
    wartosc = cmdlineGetArgInt(3, state);

  fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
    230e:	2d b7       	in	r18, 0x3d	; 61
    2310:	3e b7       	in	r19, 0x3e	; 62
    2312:	28 50       	subi	r18, 0x08	; 8
    2314:	30 40       	sbci	r19, 0x00	; 0
    2316:	2d bf       	out	0x3d, r18	; 61
    2318:	3e bf       	out	0x3e, r19	; 62
    231a:	ed b7       	in	r30, 0x3d	; 61
    231c:	fe b7       	in	r31, 0x3e	; 62
    231e:	31 96       	adiw	r30, 0x01	; 1
    2320:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2322:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2324:	ad b7       	in	r26, 0x3d	; 61
    2326:	be b7       	in	r27, 0x3e	; 62
    2328:	11 96       	adiw	r26, 0x01	; 1
    232a:	8d 93       	st	X+, r24
    232c:	9c 93       	st	X, r25
    232e:	12 97       	sbiw	r26, 0x02	; 2
    2330:	87 e0       	ldi	r24, 0x07	; 7
    2332:	95 e0       	ldi	r25, 0x05	; 5
    2334:	82 83       	std	Z+2, r24	; 0x02
    2336:	93 83       	std	Z+3, r25	; 0x03
    2338:	04 83       	std	Z+4, r16	; 0x04
    233a:	15 82       	std	Z+5, r1	; 0x05
    233c:	21 2f       	mov	r18, r17
    233e:	30 e0       	ldi	r19, 0x00	; 0
    2340:	2f 5f       	subi	r18, 0xFF	; 255
    2342:	3f 4f       	sbci	r19, 0xFF	; 255
    2344:	26 83       	std	Z+6, r18	; 0x06
    2346:	37 83       	std	Z+7, r19	; 0x07
    2348:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  if ((wartosc > 0) && (wartosc <=100))
    234c:	8f 2d       	mov	r24, r15
    234e:	81 50       	subi	r24, 0x01	; 1
    2350:	2d b7       	in	r18, 0x3d	; 61
    2352:	3e b7       	in	r19, 0x3e	; 62
    2354:	28 5f       	subi	r18, 0xF8	; 248
    2356:	3f 4f       	sbci	r19, 0xFF	; 255
    2358:	2d bf       	out	0x3d, r18	; 61
    235a:	3e bf       	out	0x3e, r19	; 62
    235c:	84 36       	cpi	r24, 0x64	; 100
    235e:	d8 f4       	brcc	.+54     	; 0x2396 <curtainUpFunction+0xca>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    2360:	00 d0       	rcall	.+0      	; 0x2362 <curtainUpFunction+0x96>
    2362:	00 d0       	rcall	.+0      	; 0x2364 <curtainUpFunction+0x98>
    2364:	ed b7       	in	r30, 0x3d	; 61
    2366:	fe b7       	in	r31, 0x3e	; 62
    2368:	31 96       	adiw	r30, 0x01	; 1
    236a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    236c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    236e:	ad b7       	in	r26, 0x3d	; 61
    2370:	be b7       	in	r27, 0x3e	; 62
    2372:	11 96       	adiw	r26, 0x01	; 1
    2374:	8d 93       	st	X+, r24
    2376:	9c 93       	st	X, r25
    2378:	12 97       	sbiw	r26, 0x02	; 2
    237a:	2d e6       	ldi	r18, 0x6D	; 109
    237c:	35 e0       	ldi	r19, 0x05	; 5
    237e:	22 83       	std	Z+2, r18	; 0x02
    2380:	33 83       	std	Z+3, r19	; 0x03
    2382:	f4 82       	std	Z+4, r15	; 0x04
    2384:	15 82       	std	Z+5, r1	; 0x05
    2386:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    238a:	2d b7       	in	r18, 0x3d	; 61
    238c:	3e b7       	in	r19, 0x3e	; 62
    238e:	2a 5f       	subi	r18, 0xFA	; 250
    2390:	3f 4f       	sbci	r19, 0xFF	; 255
    2392:	2d bf       	out	0x3d, r18	; 61
    2394:	3e bf       	out	0x3e, r19	; 62

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
    2396:	80 2f       	mov	r24, r16
    2398:	61 2f       	mov	r22, r17
    239a:	4f 2d       	mov	r20, r15
    239c:	0e 94 ae 44 	call	0x895c	; 0x895c <rs485curtainUp>
  
  if (result == 0)
    23a0:	88 23       	and	r24, r24
    23a2:	31 f4       	brne	.+12     	; 0x23b0 <curtainUpFunction+0xe4>
    return OK_INFORM;
    23a4:	21 e0       	ldi	r18, 0x01	; 1
    23a6:	30 e0       	ldi	r19, 0x00	; 0
    23a8:	05 c0       	rjmp	.+10     	; 0x23b4 <curtainUpFunction+0xe8>
}

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
  if (state->argc < 2)
    return SYNTAX_ERROR;
    23aa:	22 e0       	ldi	r18, 0x02	; 2
    23ac:	30 e0       	ldi	r19, 0x00	; 0
    23ae:	02 c0       	rjmp	.+4      	; 0x23b4 <curtainUpFunction+0xe8>
  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
  
  if (result == 0)
    return OK_INFORM;
  
  return ERROR_SILENT;
    23b0:	23 e0       	ldi	r18, 0x03	; 3
    23b2:	30 e0       	ldi	r19, 0x00	; 0
}
    23b4:	c9 01       	movw	r24, r18
    23b6:	df 91       	pop	r29
    23b8:	cf 91       	pop	r28
    23ba:	1f 91       	pop	r17
    23bc:	0f 91       	pop	r16
    23be:	ff 90       	pop	r15
    23c0:	08 95       	ret

000023c2 <goXmodemWyslijFunction>:

  return OK_SILENT;
}

static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
{
    23c2:	0f 93       	push	r16
    23c4:	1f 93       	push	r17
    23c6:	cf 93       	push	r28
    23c8:	df 93       	push	r29
    23ca:	ec 01       	movw	r28, r24
  fprintf_P(state->myStdInOut, xwyslijStartStr);
    23cc:	00 d0       	rcall	.+0      	; 0x23ce <goXmodemWyslijFunction+0xc>
    23ce:	0f 92       	push	r0
    23d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    23d4:	ad b7       	in	r26, 0x3d	; 61
    23d6:	be b7       	in	r27, 0x3e	; 62
    23d8:	11 96       	adiw	r26, 0x01	; 1
    23da:	8d 93       	st	X+, r24
    23dc:	9c 93       	st	X, r25
    23de:	12 97       	sbiw	r26, 0x02	; 2
    23e0:	8a ee       	ldi	r24, 0xEA	; 234
    23e2:	94 e0       	ldi	r25, 0x04	; 4
    23e4:	13 96       	adiw	r26, 0x03	; 3
    23e6:	8d 93       	st	X+, r24
    23e8:	9c 93       	st	X, r25
    23ea:	14 97       	sbiw	r26, 0x04	; 4
    23ec:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    23f0:	0f 90       	pop	r0
    23f2:	0f 90       	pop	r0
    23f4:	0f 90       	pop	r0
    23f6:	0f 90       	pop	r0
    23f8:	81 e0       	ldi	r24, 0x01	; 1
    23fa:	be 01       	movw	r22, r28
    23fc:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2400:	64 ec       	ldi	r22, 0xC4	; 196
    2402:	72 e3       	ldi	r23, 0x32	; 50
    2404:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <ramDyskOtworzPlik>
    2408:	88 23       	and	r24, r24
    240a:	09 f1       	breq	.+66     	; 0x244e <goXmodemWyslijFunction+0x8c>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    240c:	0a 8d       	ldd	r16, Y+26	; 0x1a
    240e:	1b 8d       	ldd	r17, Y+27	; 0x1b
    2410:	81 e0       	ldi	r24, 0x01	; 1
    2412:	be 01       	movw	r22, r28
    2414:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2418:	00 d0       	rcall	.+0      	; 0x241a <goXmodemWyslijFunction+0x58>
    241a:	00 d0       	rcall	.+0      	; 0x241c <goXmodemWyslijFunction+0x5a>
    241c:	ed b7       	in	r30, 0x3d	; 61
    241e:	fe b7       	in	r31, 0x3e	; 62
    2420:	31 96       	adiw	r30, 0x01	; 1
    2422:	ad b7       	in	r26, 0x3d	; 61
    2424:	be b7       	in	r27, 0x3e	; 62
    2426:	11 96       	adiw	r26, 0x01	; 1
    2428:	0d 93       	st	X+, r16
    242a:	1c 93       	st	X, r17
    242c:	12 97       	sbiw	r26, 0x02	; 2
    242e:	2a ee       	ldi	r18, 0xEA	; 234
    2430:	32 e0       	ldi	r19, 0x02	; 2
    2432:	22 83       	std	Z+2, r18	; 0x02
    2434:	33 83       	std	Z+3, r19	; 0x03
    2436:	84 83       	std	Z+4, r24	; 0x04
    2438:	95 83       	std	Z+5, r25	; 0x05
    243a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    return ERROR_INFORM;
    243e:	ed b7       	in	r30, 0x3d	; 61
    2440:	fe b7       	in	r31, 0x3e	; 62
    2442:	36 96       	adiw	r30, 0x06	; 6
    2444:	ed bf       	out	0x3d, r30	; 61
    2446:	fe bf       	out	0x3e, r31	; 62
    2448:	24 e0       	ldi	r18, 0x04	; 4
    244a:	30 e0       	ldi	r19, 0x00	; 0
    244c:	02 c0       	rjmp	.+4      	; 0x2452 <goXmodemWyslijFunction+0x90>
  }
  return OK_SILENT;
    244e:	20 e0       	ldi	r18, 0x00	; 0
    2450:	30 e0       	ldi	r19, 0x00	; 0
}
    2452:	c9 01       	movw	r24, r18
    2454:	df 91       	pop	r29
    2456:	cf 91       	pop	r28
    2458:	1f 91       	pop	r17
    245a:	0f 91       	pop	r16
    245c:	08 95       	ret

0000245e <editRamFileFunction>:
  ramDyskDir(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t editRamFileFunction(cmdState_t *state)
{
    245e:	ef 92       	push	r14
    2460:	ff 92       	push	r15
    2462:	0f 93       	push	r16
    2464:	1f 93       	push	r17
    2466:	df 93       	push	r29
    2468:	cf 93       	push	r28
    246a:	0f 92       	push	r0
    246c:	cd b7       	in	r28, 0x3d	; 61
    246e:	de b7       	in	r29, 0x3e	; 62
    2470:	8c 01       	movw	r16, r24
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    2472:	81 e0       	ldi	r24, 0x01	; 1
    2474:	b8 01       	movw	r22, r16
    2476:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    247a:	64 ec       	ldi	r22, 0xC4	; 196
    247c:	72 e3       	ldi	r23, 0x32	; 50
    247e:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <ramDyskOtworzPlik>
    2482:	88 23       	and	r24, r24
    2484:	21 f1       	breq	.+72     	; 0x24ce <editRamFileFunction+0x70>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2486:	d8 01       	movw	r26, r16
    2488:	5a 96       	adiw	r26, 0x1a	; 26
    248a:	ed 90       	ld	r14, X+
    248c:	fc 90       	ld	r15, X
    248e:	5b 97       	sbiw	r26, 0x1b	; 27
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	b8 01       	movw	r22, r16
    2494:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2498:	00 d0       	rcall	.+0      	; 0x249a <editRamFileFunction+0x3c>
    249a:	00 d0       	rcall	.+0      	; 0x249c <editRamFileFunction+0x3e>
    249c:	ed b7       	in	r30, 0x3d	; 61
    249e:	fe b7       	in	r31, 0x3e	; 62
    24a0:	31 96       	adiw	r30, 0x01	; 1
    24a2:	ad b7       	in	r26, 0x3d	; 61
    24a4:	be b7       	in	r27, 0x3e	; 62
    24a6:	11 96       	adiw	r26, 0x01	; 1
    24a8:	ed 92       	st	X+, r14
    24aa:	fc 92       	st	X, r15
    24ac:	12 97       	sbiw	r26, 0x02	; 2
    24ae:	2a ee       	ldi	r18, 0xEA	; 234
    24b0:	32 e0       	ldi	r19, 0x02	; 2
    24b2:	22 83       	std	Z+2, r18	; 0x02
    24b4:	33 83       	std	Z+3, r19	; 0x03
    24b6:	84 83       	std	Z+4, r24	; 0x04
    24b8:	95 83       	std	Z+5, r25	; 0x05
    24ba:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    return ERROR_INFORM;
    24be:	ed b7       	in	r30, 0x3d	; 61
    24c0:	fe b7       	in	r31, 0x3e	; 62
    24c2:	36 96       	adiw	r30, 0x06	; 6
    24c4:	ed bf       	out	0x3d, r30	; 61
    24c6:	fe bf       	out	0x3e, r31	; 62
    24c8:	24 e0       	ldi	r18, 0x04	; 4
    24ca:	30 e0       	ldi	r19, 0x00	; 0
    24cc:	3a c0       	rjmp	.+116    	; 0x2542 <editRamFileFunction+0xe4>
  }
  ramDyskUstawWskaznikNaKoniec(&fdVty);
    24ce:	84 ec       	ldi	r24, 0xC4	; 196
    24d0:	92 e3       	ldi	r25, 0x32	; 50
    24d2:	0e 94 36 20 	call	0x406c	; 0x406c <ramDyskUstawWskaznikNaKoniec>
  uint8_t znak = 0;
    24d6:	19 82       	std	Y+1, r1	; 0x01
  fprintf_P(state->myStdInOut, editRamFileIntroStr);
    24d8:	00 d0       	rcall	.+0      	; 0x24da <editRamFileFunction+0x7c>
    24da:	0f 92       	push	r0
    24dc:	d8 01       	movw	r26, r16
    24de:	5a 96       	adiw	r26, 0x1a	; 26
    24e0:	8d 91       	ld	r24, X+
    24e2:	9c 91       	ld	r25, X
    24e4:	5b 97       	sbiw	r26, 0x1b	; 27
    24e6:	ed b7       	in	r30, 0x3d	; 61
    24e8:	fe b7       	in	r31, 0x3e	; 62
    24ea:	81 83       	std	Z+1, r24	; 0x01
    24ec:	92 83       	std	Z+2, r25	; 0x02
    24ee:	80 eb       	ldi	r24, 0xB0	; 176
    24f0:	94 e0       	ldi	r25, 0x04	; 4
    24f2:	83 83       	std	Z+3, r24	; 0x03
    24f4:	94 83       	std	Z+4, r25	; 0x04
    24f6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    24fa:	0f 90       	pop	r0
    24fc:	0f 90       	pop	r0
    24fe:	0f 90       	pop	r0
    2500:	0f 90       	pop	r0
  while(1)
  {
    if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
    2502:	8e 01       	movw	r16, r28
    2504:	0f 5f       	subi	r16, 0xFF	; 255
    2506:	1f 4f       	sbci	r17, 0xFF	; 255
    2508:	80 91 0d 32 	lds	r24, 0x320D
    250c:	90 91 0e 32 	lds	r25, 0x320E
    2510:	b8 01       	movw	r22, r16
    2512:	4f ef       	ldi	r20, 0xFF	; 255
    2514:	5f ef       	ldi	r21, 0xFF	; 255
    2516:	20 e0       	ldi	r18, 0x00	; 0
    2518:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    251c:	88 23       	and	r24, r24
    251e:	a1 f3       	breq	.-24     	; 0x2508 <editRamFileFunction+0xaa>
      continue;

    if (znak == 0x03)                                       // ^C
    2520:	89 81       	ldd	r24, Y+1	; 0x01
    2522:	83 30       	cpi	r24, 0x03	; 3
    2524:	41 f0       	breq	.+16     	; 0x2536 <editRamFileFunction+0xd8>
      break;

    uartVtySendByte(znak);                                  //Echo
    2526:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    ramDyskZapiszBajtDoPliku(&fdVty, znak);
    252a:	84 ec       	ldi	r24, 0xC4	; 196
    252c:	92 e3       	ldi	r25, 0x32	; 50
    252e:	69 81       	ldd	r22, Y+1	; 0x01
    2530:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <ramDyskZapiszBajtDoPliku>
    2534:	e9 cf       	rjmp	.-46     	; 0x2508 <editRamFileFunction+0xaa>
  }
  ramDyskZamknijPlik(&fdVty);
    2536:	84 ec       	ldi	r24, 0xC4	; 196
    2538:	92 e3       	ldi	r25, 0x32	; 50
    253a:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <ramDyskZamknijPlik>
  return OK_SILENT;
    253e:	20 e0       	ldi	r18, 0x00	; 0
    2540:	30 e0       	ldi	r19, 0x00	; 0
}
    2542:	c9 01       	movw	r24, r18
    2544:	0f 90       	pop	r0
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	1f 91       	pop	r17
    254c:	0f 91       	pop	r16
    254e:	ff 90       	pop	r15
    2550:	ef 90       	pop	r14
    2552:	08 95       	ret

00002554 <goXmodemOdbierzFunction>:
  }
  return OK_SILENT;
}

static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
{
    2554:	2f 92       	push	r2
    2556:	3f 92       	push	r3
    2558:	4f 92       	push	r4
    255a:	5f 92       	push	r5
    255c:	6f 92       	push	r6
    255e:	7f 92       	push	r7
    2560:	8f 92       	push	r8
    2562:	9f 92       	push	r9
    2564:	af 92       	push	r10
    2566:	bf 92       	push	r11
    2568:	cf 92       	push	r12
    256a:	df 92       	push	r13
    256c:	ef 92       	push	r14
    256e:	ff 92       	push	r15
    2570:	0f 93       	push	r16
    2572:	1f 93       	push	r17
    2574:	df 93       	push	r29
    2576:	cf 93       	push	r28
    2578:	cd b7       	in	r28, 0x3d	; 61
    257a:	de b7       	in	r29, 0x3e	; 62
    257c:	27 97       	sbiw	r28, 0x07	; 7
    257e:	cd bf       	out	0x3d, r28	; 61
    2580:	de bf       	out	0x3e, r29	; 62
    2582:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
    2584:	00 d0       	rcall	.+0      	; 0x2586 <goXmodemOdbierzFunction+0x32>
    2586:	0f 92       	push	r0
    2588:	dc 01       	movw	r26, r24
    258a:	5a 96       	adiw	r26, 0x1a	; 26
    258c:	8d 91       	ld	r24, X+
    258e:	9c 91       	ld	r25, X
    2590:	5b 97       	sbiw	r26, 0x1b	; 27
    2592:	ed b7       	in	r30, 0x3d	; 61
    2594:	fe b7       	in	r31, 0x3e	; 62
    2596:	81 83       	std	Z+1, r24	; 0x01
    2598:	92 83       	std	Z+2, r25	; 0x02
    259a:	8f e3       	ldi	r24, 0x3F	; 63
    259c:	97 e0       	ldi	r25, 0x07	; 7
    259e:	83 83       	std	Z+3, r24	; 0x03
    25a0:	94 83       	std	Z+4, r25	; 0x04
    25a2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    25a6:	0f 90       	pop	r0
    25a8:	0f 90       	pop	r0
    25aa:	0f 90       	pop	r0
    25ac:	0f 90       	pop	r0
    25ae:	81 e0       	ldi	r24, 0x01	; 1
    25b0:	b8 01       	movw	r22, r16
    25b2:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    25b6:	64 ec       	ldi	r22, 0xC4	; 196
    25b8:	72 e3       	ldi	r23, 0x32	; 50
    25ba:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <ramDyskOtworzPlik>
    25be:	88 23       	and	r24, r24
    25c0:	11 f1       	breq	.+68     	; 0x2606 <goXmodemOdbierzFunction+0xb2>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    25c2:	d8 01       	movw	r26, r16
    25c4:	5a 96       	adiw	r26, 0x1a	; 26
    25c6:	ed 90       	ld	r14, X+
    25c8:	fc 90       	ld	r15, X
    25ca:	5b 97       	sbiw	r26, 0x1b	; 27
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	b8 01       	movw	r22, r16
    25d0:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    25d4:	00 d0       	rcall	.+0      	; 0x25d6 <goXmodemOdbierzFunction+0x82>
    25d6:	00 d0       	rcall	.+0      	; 0x25d8 <goXmodemOdbierzFunction+0x84>
    25d8:	ed b7       	in	r30, 0x3d	; 61
    25da:	fe b7       	in	r31, 0x3e	; 62
    25dc:	31 96       	adiw	r30, 0x01	; 1
    25de:	ad b7       	in	r26, 0x3d	; 61
    25e0:	be b7       	in	r27, 0x3e	; 62
    25e2:	11 96       	adiw	r26, 0x01	; 1
    25e4:	ed 92       	st	X+, r14
    25e6:	fc 92       	st	X, r15
    25e8:	12 97       	sbiw	r26, 0x02	; 2
    25ea:	2a ee       	ldi	r18, 0xEA	; 234
    25ec:	32 e0       	ldi	r19, 0x02	; 2
    25ee:	22 83       	std	Z+2, r18	; 0x02
    25f0:	33 83       	std	Z+3, r19	; 0x03
    25f2:	84 83       	std	Z+4, r24	; 0x04
    25f4:	95 83       	std	Z+5, r25	; 0x05
    25f6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    return ERROR_INFORM;
    25fa:	ed b7       	in	r30, 0x3d	; 61
    25fc:	fe b7       	in	r31, 0x3e	; 62
    25fe:	36 96       	adiw	r30, 0x06	; 6
    2600:	ed bf       	out	0x3d, r30	; 61
    2602:	fe bf       	out	0x3e, r31	; 62
    2604:	32 c0       	rjmp	.+100    	; 0x266a <goXmodemOdbierzFunction+0x116>
  uint8_t nrBlokuZdalnyNeg;

  uint8_t crcHi;
  uint8_t crcLo;

  state->err1=0;
    2606:	d8 01       	movw	r26, r16
    2608:	5d 96       	adiw	r26, 0x1d	; 29
    260a:	1d 92       	st	X+, r1
    260c:	1c 92       	st	X, r1
    260e:	5e 97       	sbiw	r26, 0x1e	; 30
  state->err2=0;
    2610:	5f 96       	adiw	r26, 0x1f	; 31
    2612:	1c 92       	st	X, r1
  liczbaProb = 20;
    2614:	84 e1       	ldi	r24, 0x14	; 20
    2616:	d8 2e       	mov	r13, r24
  {
    fputc('C'              , state->myStdInOut);
   // while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
//od usartD0
    while(!(USARTD0.STATUS & USART_TXCIF_bm));
    if(xQueueReceive(xVtyRec, &c, 100))
    2618:	b2 e0       	ldi	r27, 0x02	; 2
    261a:	eb 2e       	mov	r14, r27
    261c:	f1 2c       	mov	r15, r1
    261e:	ec 0e       	add	r14, r28
    2620:	fd 1e       	adc	r15, r29
  state->err1=0;
  state->err2=0;
  liczbaProb = 20;
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    2622:	f8 01       	movw	r30, r16
    2624:	62 8d       	ldd	r22, Z+26	; 0x1a
    2626:	73 8d       	ldd	r23, Z+27	; 0x1b
    2628:	83 e4       	ldi	r24, 0x43	; 67
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
   // while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
//od usartD0
    while(!(USARTD0.STATUS & USART_TXCIF_bm));
    2630:	80 91 a1 09 	lds	r24, 0x09A1
    2634:	86 ff       	sbrs	r24, 6
    2636:	fc cf       	rjmp	.-8      	; 0x2630 <goXmodemOdbierzFunction+0xdc>
    if(xQueueReceive(xVtyRec, &c, 100))
    2638:	80 91 0d 32 	lds	r24, 0x320D
    263c:	90 91 0e 32 	lds	r25, 0x320E
    2640:	b7 01       	movw	r22, r14
    2642:	44 e6       	ldi	r20, 0x64	; 100
    2644:	50 e0       	ldi	r21, 0x00	; 0
    2646:	20 e0       	ldi	r18, 0x00	; 0
    2648:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    264c:	88 23       	and	r24, r24
    264e:	19 f0       	breq	.+6      	; 0x2656 <goXmodemOdbierzFunction+0x102>
      if (c == SOH)
    2650:	8a 81       	ldd	r24, Y+2	; 0x02
    2652:	81 30       	cpi	r24, 0x01	; 1
    2654:	69 f0       	breq	.+26     	; 0x2670 <goXmodemOdbierzFunction+0x11c>
        break;                                                   //Rozpoczynamy transmisje

    liczbaProb--;
    2656:	da 94       	dec	r13
    if (liczbaProb == 0)
    2658:	21 f7       	brne	.-56     	; 0x2622 <goXmodemOdbierzFunction+0xce>
    {
      ramDyskZamknijPlik(&fdVty);
    265a:	84 ec       	ldi	r24, 0xC4	; 196
    265c:	92 e3       	ldi	r25, 0x32	; 50
    265e:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <ramDyskZamknijPlik>
      state->errno = (uint8_t)(AllOK);
    2662:	d8 01       	movw	r26, r16
    2664:	5c 96       	adiw	r26, 0x1c	; 28
    2666:	1c 92       	st	X, r1
    2668:	5c 97       	sbiw	r26, 0x1c	; 28
      return ERROR_INFORM;
    266a:	24 e0       	ldi	r18, 0x04	; 4
    266c:	30 e0       	ldi	r19, 0x00	; 0
    266e:	4e c1       	rjmp	.+668    	; 0x290c <goXmodemOdbierzFunction+0x3b8>
  }
  
  nrBloku = 1;
  liczbaProb = 10;

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2670:	84 ec       	ldi	r24, 0xC4	; 196
    2672:	92 e3       	ldi	r25, 0x32	; 50
    2674:	61 e0       	ldi	r22, 0x01	; 1
    2676:	70 e0       	ldi	r23, 0x00	; 0
    2678:	0e 94 58 20 	call	0x40b0	; 0x40b0 <ramDyskDodajBlokXmodem>
    267c:	6c 01       	movw	r12, r24
      state->errno = (uint8_t)(AllOK);
      return ERROR_INFORM;
    }
  }
  
  nrBloku = 1;
    267e:	ee 24       	eor	r14, r14
    2680:	e3 94       	inc	r14
  liczbaProb = 10;
    2682:	aa e0       	ldi	r26, 0x0A	; 10
    2684:	ba 2e       	mov	r11, r26

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    2686:	f3 e0       	ldi	r31, 0x03	; 3
    2688:	4f 2e       	mov	r4, r31
    268a:	51 2c       	mov	r5, r1
    268c:	4c 0e       	add	r4, r28
    268e:	5d 1e       	adc	r5, r29
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    2690:	e4 e0       	ldi	r30, 0x04	; 4
    2692:	2e 2e       	mov	r2, r30
    2694:	31 2c       	mov	r3, r1
    2696:	2c 0e       	add	r2, r28
    2698:	3d 1e       	adc	r3, r29
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    269a:	73 e0       	ldi	r23, 0x03	; 3
    269c:	a7 2e       	mov	r10, r23
      state->err2 = nrBloku;
      state->errno = (uint8_t)(xModemWrongFrameNo);
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    269e:	3e 01       	movw	r6, r28
    26a0:	08 94       	sec
    26a2:	61 1c       	adc	r6, r1
    26a4:	71 1c       	adc	r7, r1

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    26a6:	80 91 0d 32 	lds	r24, 0x320D
    26aa:	90 91 0e 32 	lds	r25, 0x320E
    26ae:	b2 01       	movw	r22, r4
    26b0:	44 e6       	ldi	r20, 0x64	; 100
    26b2:	50 e0       	ldi	r21, 0x00	; 0
    26b4:	20 e0       	ldi	r18, 0x00	; 0
    26b6:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    26ba:	88 23       	and	r24, r24
    26bc:	19 f4       	brne	.+6      	; 0x26c4 <goXmodemOdbierzFunction+0x170>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    26be:	82 e0       	ldi	r24, 0x02	; 2
    26c0:	f8 01       	movw	r30, r16
    26c2:	cc c0       	rjmp	.+408    	; 0x285c <goXmodemOdbierzFunction+0x308>
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    26c4:	80 91 0d 32 	lds	r24, 0x320D
    26c8:	90 91 0e 32 	lds	r25, 0x320E
    26cc:	b1 01       	movw	r22, r2
    26ce:	41 e0       	ldi	r20, 0x01	; 1
    26d0:	50 e0       	ldi	r21, 0x00	; 0
    26d2:	20 e0       	ldi	r18, 0x00	; 0
    26d4:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    26d8:	88 23       	and	r24, r24
    26da:	11 f4       	brne	.+4      	; 0x26e0 <goXmodemOdbierzFunction+0x18c>
    {
      state->errno = (uint8_t)(xModemByteSendTimeout);
    26dc:	83 e0       	ldi	r24, 0x03	; 3
    26de:	cd c0       	rjmp	.+410    	; 0x287a <goXmodemOdbierzFunction+0x326>
      break; 
    }
  
    //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
    c = 255-nrBlokuZdalnyNeg;
    26e0:	8c 81       	ldd	r24, Y+4	; 0x04
    26e2:	98 2f       	mov	r25, r24
    26e4:	90 95       	com	r25
    26e6:	9a 83       	std	Y+2, r25	; 0x02
    if (nrBlokuZdalny != c)
    26e8:	fb 80       	ldd	r15, Y+3	; 0x03
    26ea:	f9 16       	cp	r15, r25
    26ec:	39 f0       	breq	.+14     	; 0x26fc <goXmodemOdbierzFunction+0x1a8>
    {
      state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
    26ee:	95 e0       	ldi	r25, 0x05	; 5
    26f0:	f8 01       	movw	r30, r16
    26f2:	94 8f       	std	Z+28, r25	; 0x1c
      state->err1 = nrBlokuZdalny;
    26f4:	f5 8e       	std	Z+29, r15	; 0x1d
    26f6:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBlokuZdalnyNeg;
    26f8:	87 8f       	std	Z+31, r24	; 0x1f
      break;
    26fa:	02 c1       	rjmp	.+516    	; 0x2900 <goXmodemOdbierzFunction+0x3ac>
    }
    
    //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od bloku 0
    c = nrBloku-1;
    26fc:	8e 2d       	mov	r24, r14
    26fe:	81 50       	subi	r24, 0x01	; 1
    2700:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny == c)
    2702:	f8 16       	cp	r15, r24
    2704:	41 f4       	brne	.+16     	; 0x2716 <goXmodemOdbierzFunction+0x1c2>
    {
      nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2706:	84 ec       	ldi	r24, 0xC4	; 196
    2708:	92 e3       	ldi	r25, 0x32	; 50
    270a:	6f 2d       	mov	r22, r15
    270c:	70 e0       	ldi	r23, 0x00	; 0
    270e:	0e 94 58 20 	call	0x40b0	; 0x40b0 <ramDyskDodajBlokXmodem>
    2712:	6c 01       	movw	r12, r24
    2714:	ef 2c       	mov	r14, r15
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    2716:	fb 80       	ldd	r15, Y+3	; 0x03
    2718:	fe 14       	cp	r15, r14
    271a:	81 f0       	breq	.+32     	; 0x273c <goXmodemOdbierzFunction+0x1e8>
    {
      state->errno = (uint8_t)(xModemWrongFrameNo);
    271c:	84 e0       	ldi	r24, 0x04	; 4
    271e:	d8 01       	movw	r26, r16
    2720:	5c 96       	adiw	r26, 0x1c	; 28
    2722:	8c 93       	st	X, r24
    2724:	5c 97       	sbiw	r26, 0x1c	; 28
      state->err1 = nrBlokuZdalnyNeg;
    2726:	8c 81       	ldd	r24, Y+4	; 0x04
    2728:	5d 96       	adiw	r26, 0x1d	; 29
    272a:	8c 93       	st	X, r24
    272c:	5d 97       	sbiw	r26, 0x1d	; 29
    272e:	5e 96       	adiw	r26, 0x1e	; 30
    2730:	1c 92       	st	X, r1
    2732:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    2734:	5f 96       	adiw	r26, 0x1f	; 31
    2736:	ec 92       	st	X, r14
    2738:	5f 97       	sbiw	r26, 0x1f	; 31
      break;
    273a:	e2 c0       	rjmp	.+452    	; 0x2900 <goXmodemOdbierzFunction+0x3ac>
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    273c:	8c 2c       	mov	r8, r12
    273e:	9d 2c       	mov	r9, r13
    2740:	30 e0       	ldi	r19, 0x00	; 0
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    {
      if(xQueueReceive(xVtyRec, &c, 10))
    2742:	80 91 0d 32 	lds	r24, 0x320D
    2746:	90 91 0e 32 	lds	r25, 0x320E
    274a:	be 01       	movw	r22, r28
    274c:	6e 5f       	subi	r22, 0xFE	; 254
    274e:	7f 4f       	sbci	r23, 0xFF	; 255
    2750:	4a e0       	ldi	r20, 0x0A	; 10
    2752:	50 e0       	ldi	r21, 0x00	; 0
    2754:	20 e0       	ldi	r18, 0x00	; 0
    2756:	3f 83       	std	Y+7, r19	; 0x07
    2758:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    275c:	3f 81       	ldd	r19, Y+7	; 0x07
    275e:	88 23       	and	r24, r24
    2760:	41 f0       	breq	.+16     	; 0x2772 <goXmodemOdbierzFunction+0x21e>
        *(zapPtr++) = c;
    2762:	8a 81       	ldd	r24, Y+2	; 0x02
    2764:	f4 01       	movw	r30, r8
    2766:	81 93       	st	Z+, r24
    2768:	4f 01       	movw	r8, r30
      state->err1 = nrBlokuZdalnyNeg;
      state->err2 = nrBloku;
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    276a:	3f 5f       	subi	r19, 0xFF	; 255
    276c:	30 38       	cpi	r19, 0x80	; 128
    276e:	49 f7       	brne	.-46     	; 0x2742 <goXmodemOdbierzFunction+0x1ee>
    2770:	03 c0       	rjmp	.+6      	; 0x2778 <goXmodemOdbierzFunction+0x224>
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2772:	d8 01       	movw	r26, r16
    2774:	5c 96       	adiw	r26, 0x1c	; 28
    2776:	ac 92       	st	X, r10
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    2778:	80 91 0d 32 	lds	r24, 0x320D
    277c:	90 91 0e 32 	lds	r25, 0x320E
    2780:	be 01       	movw	r22, r28
    2782:	6b 5f       	subi	r22, 0xFB	; 251
    2784:	7f 4f       	sbci	r23, 0xFF	; 255
    2786:	4a e0       	ldi	r20, 0x0A	; 10
    2788:	50 e0       	ldi	r21, 0x00	; 0
    278a:	20 e0       	ldi	r18, 0x00	; 0
    278c:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    2790:	88 23       	and	r24, r24
    2792:	41 f4       	brne	.+16     	; 0x27a4 <goXmodemOdbierzFunction+0x250>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2794:	86 e0       	ldi	r24, 0x06	; 6
    2796:	f8 01       	movw	r30, r16
    2798:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 2;
    279a:	82 e0       	ldi	r24, 0x02	; 2
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	85 8f       	std	Z+29, r24	; 0x1d
    27a0:	96 8f       	std	Z+30, r25	; 0x1e
        break;      
    27a2:	ae c0       	rjmp	.+348    	; 0x2900 <goXmodemOdbierzFunction+0x3ac>
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    27a4:	80 91 0d 32 	lds	r24, 0x320D
    27a8:	90 91 0e 32 	lds	r25, 0x320E
    27ac:	be 01       	movw	r22, r28
    27ae:	6a 5f       	subi	r22, 0xFA	; 250
    27b0:	7f 4f       	sbci	r23, 0xFF	; 255
    27b2:	4a e0       	ldi	r20, 0x0A	; 10
    27b4:	50 e0       	ldi	r21, 0x00	; 0
    27b6:	20 e0       	ldi	r18, 0x00	; 0
    27b8:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    27bc:	88 23       	and	r24, r24
    27be:	61 f4       	brne	.+24     	; 0x27d8 <goXmodemOdbierzFunction+0x284>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    27c0:	86 e0       	ldi	r24, 0x06	; 6
    27c2:	d8 01       	movw	r26, r16
    27c4:	5c 96       	adiw	r26, 0x1c	; 28
    27c6:	8c 93       	st	X, r24
    27c8:	5c 97       	sbiw	r26, 0x1c	; 28
        state->err1 = 1;
    27ca:	81 e0       	ldi	r24, 0x01	; 1
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	5d 96       	adiw	r26, 0x1d	; 29
    27d0:	8d 93       	st	X+, r24
    27d2:	9c 93       	st	X, r25
    27d4:	5e 97       	sbiw	r26, 0x1e	; 30
        break;      
    27d6:	94 c0       	rjmp	.+296    	; 0x2900 <goXmodemOdbierzFunction+0x3ac>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
        state->err1 = 2;
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    27d8:	ec 2d       	mov	r30, r12
    27da:	fd 2d       	mov	r31, r13
    27dc:	80 e0       	ldi	r24, 0x00	; 0
    27de:	90 e0       	ldi	r25, 0x00	; 0
    27e0:	20 e0       	ldi	r18, 0x00	; 0
    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
    27e2:	31 91       	ld	r19, Z+
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    27e4:	93 27       	eor	r25, r19
    27e6:	09 2e       	mov	r0, r25
    27e8:	02 94       	swap	r0
    27ea:	30 2d       	mov	r19, r0
    27ec:	3f 70       	andi	r19, 0x0F	; 15
    27ee:	39 27       	eor	r19, r25
    27f0:	49 2f       	mov	r20, r25
    27f2:	40 25       	eor	r20, r0
    27f4:	44 0f       	add	r20, r20
    27f6:	40 7e       	andi	r20, 0xE0	; 224
    27f8:	34 27       	eor	r19, r20
    27fa:	40 2d       	mov	r20, r0
    27fc:	49 27       	eor	r20, r25
    27fe:	40 7f       	andi	r20, 0xF0	; 240
    2800:	46 95       	lsr	r20
    2802:	09 2e       	mov	r0, r25
    2804:	00 0c       	add	r0, r0
    2806:	44 1f       	adc	r20, r20
    2808:	96 95       	lsr	r25
    280a:	96 95       	lsr	r25
    280c:	96 95       	lsr	r25
    280e:	9f 71       	andi	r25, 0x1F	; 31
    2810:	94 27       	eor	r25, r20
    2812:	98 27       	eor	r25, r24
    2814:	83 2f       	mov	r24, r19

    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    2816:	2f 5f       	subi	r18, 0xFF	; 255
    2818:	20 38       	cpi	r18, 0x80	; 128
    281a:	19 f7       	brne	.-58     	; 0x27e2 <goXmodemOdbierzFunction+0x28e>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    281c:	4d 81       	ldd	r20, Y+5	; 0x05
    281e:	50 e0       	ldi	r21, 0x00	; 0
    2820:	29 2f       	mov	r18, r25
    2822:	33 27       	eor	r19, r19
    2824:	42 17       	cp	r20, r18
    2826:	53 07       	cpc	r21, r19
    2828:	61 f4       	brne	.+24     	; 0x2842 <goXmodemOdbierzFunction+0x2ee>
    282a:	2e 81       	ldd	r18, Y+6	; 0x06
    282c:	30 e0       	ldi	r19, 0x00	; 0
    282e:	90 70       	andi	r25, 0x00	; 0
    2830:	28 17       	cp	r18, r24
    2832:	39 07       	cpc	r19, r25
    2834:	31 f4       	brne	.+12     	; 0x2842 <goXmodemOdbierzFunction+0x2ee>
    {
      liczbaProb = 10;
      uartVtySendByte(ACK);      
    2836:	86 e0       	ldi	r24, 0x06	; 6
    2838:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    {
      liczbaProb = 10;
    283c:	3a e0       	ldi	r19, 0x0A	; 10
    283e:	b3 2e       	mov	r11, r19
    2840:	0f c0       	rjmp	.+30     	; 0x2860 <goXmodemOdbierzFunction+0x30c>
      uartVtySendByte(ACK);      
    }
    else
    {
      liczbaProb--;
    2842:	ba 94       	dec	r11
      nrBloku--;
    2844:	fa 94       	dec	r15
      uartVtySendByte(NAK);   
    2846:	85 e1       	ldi	r24, 0x15	; 21
    2848:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    }
    
    if (liczbaProb == 0)
    284c:	bb 20       	and	r11, r11
    284e:	41 f4       	brne	.+16     	; 0x2860 <goXmodemOdbierzFunction+0x30c>
    {
      state->err1 = nrBlokuZdalny;
    2850:	8b 81       	ldd	r24, Y+3	; 0x03
    2852:	f8 01       	movw	r30, r16
    2854:	85 8f       	std	Z+29, r24	; 0x1d
    2856:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBloku;
    2858:	f7 8e       	std	Z+31, r15	; 0x1f
      state->errno = (uint8_t)(xModemWrongFrameNo);
    285a:	84 e0       	ldi	r24, 0x04	; 4
    285c:	84 8f       	std	Z+28, r24	; 0x1c
      break; 
    285e:	50 c0       	rjmp	.+160    	; 0x2900 <goXmodemOdbierzFunction+0x3ac>
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    2860:	80 91 0d 32 	lds	r24, 0x320D
    2864:	90 91 0e 32 	lds	r25, 0x320E
    2868:	b3 01       	movw	r22, r6
    286a:	44 e6       	ldi	r20, 0x64	; 100
    286c:	50 e0       	ldi	r21, 0x00	; 0
    286e:	20 e0       	ldi	r18, 0x00	; 0
    2870:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    2874:	88 23       	and	r24, r24
    2876:	31 f4       	brne	.+12     	; 0x2884 <goXmodemOdbierzFunction+0x330>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    2878:	82 e0       	ldi	r24, 0x02	; 2
    287a:	d8 01       	movw	r26, r16
    287c:	5c 96       	adiw	r26, 0x1c	; 28
    287e:	8c 93       	st	X, r24
    2880:	5c 97       	sbiw	r26, 0x1c	; 28
      break;
    2882:	3e c0       	rjmp	.+124    	; 0x2900 <goXmodemOdbierzFunction+0x3ac>
    }
    
    if (temp1 == SOH)
    2884:	89 81       	ldd	r24, Y+1	; 0x01
    2886:	81 30       	cpi	r24, 0x01	; 1
    2888:	61 f4       	brne	.+24     	; 0x28a2 <goXmodemOdbierzFunction+0x34e>
    {
      nrBloku++;
    288a:	ef 2c       	mov	r14, r15
    288c:	e3 94       	inc	r14
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    288e:	84 ec       	ldi	r24, 0xC4	; 196
    2890:	92 e3       	ldi	r25, 0x32	; 50
    2892:	6e 2d       	mov	r22, r14
    2894:	70 e0       	ldi	r23, 0x00	; 0
    2896:	0e 94 58 20 	call	0x40b0	; 0x40b0 <ramDyskDodajBlokXmodem>
    289a:	6c 01       	movw	r12, r24
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
    289c:	f8 01       	movw	r30, r16
    289e:	14 8e       	std	Z+28, r1	; 0x1c
      break;
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    state->err1 = temp1;
    break;
  }
    28a0:	02 cf       	rjmp	.-508    	; 0x26a6 <goXmodemOdbierzFunction+0x152>
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
      continue;
    }

    if (temp1 == CAN)
    28a2:	88 31       	cpi	r24, 0x18	; 24
    28a4:	49 f4       	brne	.+18     	; 0x28b8 <goXmodemOdbierzFunction+0x364>
    {
      state->err1 = nrBloku;
    28a6:	d8 01       	movw	r26, r16
    28a8:	5d 96       	adiw	r26, 0x1d	; 29
    28aa:	fc 92       	st	X, r15
    28ac:	5d 97       	sbiw	r26, 0x1d	; 29
    28ae:	5e 96       	adiw	r26, 0x1e	; 30
    28b0:	1c 92       	st	X, r1
    28b2:	5e 97       	sbiw	r26, 0x1e	; 30
      state->errno = (uint8_t)(xModemRemoteSideCan);
    28b4:	87 e0       	ldi	r24, 0x07	; 7
    28b6:	e2 cf       	rjmp	.-60     	; 0x287c <goXmodemOdbierzFunction+0x328>
      break;
    }
    if (temp1 == EOT)
    28b8:	84 30       	cpi	r24, 0x04	; 4
    28ba:	c1 f4       	brne	.+48     	; 0x28ec <goXmodemOdbierzFunction+0x398>
    {
      uartVtySendByte(NAK);
    28bc:	85 e1       	ldi	r24, 0x15	; 21
    28be:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
      if (xQueueReceive(xVtyRec, &temp1, 10))
    28c2:	80 91 0d 32 	lds	r24, 0x320D
    28c6:	90 91 0e 32 	lds	r25, 0x320E
    28ca:	b3 01       	movw	r22, r6
    28cc:	4a e0       	ldi	r20, 0x0A	; 10
    28ce:	50 e0       	ldi	r21, 0x00	; 0
    28d0:	20 e0       	ldi	r18, 0x00	; 0
    28d2:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    28d6:	88 23       	and	r24, r24
    28d8:	31 f0       	breq	.+12     	; 0x28e6 <goXmodemOdbierzFunction+0x392>
      {
        if (temp1 == EOT)
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	84 30       	cpi	r24, 0x04	; 4
    28de:	19 f4       	brne	.+6      	; 0x28e6 <goXmodemOdbierzFunction+0x392>
          uartVtySendByte(ACK);  
    28e0:	86 e0       	ldi	r24, 0x06	; 6
    28e2:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
      }
      state->errno = (uint8_t)(AllOK);
    28e6:	f8 01       	movw	r30, r16
    28e8:	14 8e       	std	Z+28, r1	; 0x1c
      break;
    28ea:	0a c0       	rjmp	.+20     	; 0x2900 <goXmodemOdbierzFunction+0x3ac>
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    28ec:	98 e0       	ldi	r25, 0x08	; 8
    28ee:	d8 01       	movw	r26, r16
    28f0:	5c 96       	adiw	r26, 0x1c	; 28
    28f2:	9c 93       	st	X, r25
    28f4:	5c 97       	sbiw	r26, 0x1c	; 28
    state->err1 = temp1;
    28f6:	5d 96       	adiw	r26, 0x1d	; 29
    28f8:	8c 93       	st	X, r24
    28fa:	5d 97       	sbiw	r26, 0x1d	; 29
    28fc:	5e 96       	adiw	r26, 0x1e	; 30
    28fe:	1c 92       	st	X, r1
    break;
  }
  ramDyskZamknijPlik(&fdVty);
    2900:	84 ec       	ldi	r24, 0xC4	; 196
    2902:	92 e3       	ldi	r25, 0x32	; 50
    2904:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <ramDyskZamknijPlik>
  return OK_SILENT;
    2908:	20 e0       	ldi	r18, 0x00	; 0
    290a:	30 e0       	ldi	r19, 0x00	; 0
}
    290c:	c9 01       	movw	r24, r18
    290e:	27 96       	adiw	r28, 0x07	; 7
    2910:	cd bf       	out	0x3d, r28	; 61
    2912:	de bf       	out	0x3e, r29	; 62
    2914:	cf 91       	pop	r28
    2916:	df 91       	pop	r29
    2918:	1f 91       	pop	r17
    291a:	0f 91       	pop	r16
    291c:	ff 90       	pop	r15
    291e:	ef 90       	pop	r14
    2920:	df 90       	pop	r13
    2922:	cf 90       	pop	r12
    2924:	bf 90       	pop	r11
    2926:	af 90       	pop	r10
    2928:	9f 90       	pop	r9
    292a:	8f 90       	pop	r8
    292c:	7f 90       	pop	r7
    292e:	6f 90       	pop	r6
    2930:	5f 90       	pop	r5
    2932:	4f 90       	pop	r4
    2934:	3f 90       	pop	r3
    2936:	2f 90       	pop	r2
    2938:	08 95       	ret

0000293a <debugFunction>:
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
  return OK_SILENT;
}

static cliExRes_t debugFunction          (cmdState_t *state)
{
    293a:	ff 92       	push	r15
    293c:	0f 93       	push	r16
    293e:	1f 93       	push	r17
    2940:	cf 93       	push	r28
    2942:	df 93       	push	r29
    2944:	8c 01       	movw	r16, r24
  if (state->argc < 2)
    2946:	dc 01       	movw	r26, r24
    2948:	59 96       	adiw	r26, 0x19	; 25
    294a:	8c 91       	ld	r24, X
    294c:	59 97       	sbiw	r26, 0x19	; 25
    294e:	82 30       	cpi	r24, 0x02	; 2
    2950:	08 f4       	brcc	.+2      	; 0x2954 <debugFunction+0x1a>
    2952:	e2 c0       	rjmp	.+452    	; 0x2b18 <debugFunction+0x1de>
    return SYNTAX_ERROR;

  uint8_t level = cmdlineGetArgInt(2, state);
    2954:	82 e0       	ldi	r24, 0x02	; 2
    2956:	b8 01       	movw	r22, r16
    2958:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    295c:	f6 2e       	mov	r15, r22
  const char *str = (const char*)cmdlineGetArgStr(1, state);
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	b8 01       	movw	r22, r16
    2962:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2966:	ec 01       	movw	r28, r24
  if (level == 0)
    2968:	ff 20       	and	r15, r15
    296a:	09 f0       	breq	.+2      	; 0x296e <debugFunction+0x34>
    296c:	5d c0       	rjmp	.+186    	; 0x2a28 <debugFunction+0xee>
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    296e:	63 e8       	ldi	r22, 0x83	; 131
    2970:	77 e0       	ldi	r23, 0x07	; 7
    2972:	43 e0       	ldi	r20, 0x03	; 3
    2974:	50 e0       	ldi	r21, 0x00	; 0
    2976:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    297a:	00 97       	sbiw	r24, 0x00	; 0
    297c:	31 f4       	brne	.+12     	; 0x298a <debugFunction+0x50>
    {
      setArpDebug(NULL, 0);
    297e:	80 e0       	ldi	r24, 0x00	; 0
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	60 e0       	ldi	r22, 0x00	; 0
    2984:	0e 94 fc 35 	call	0x6bf8	; 0x6bf8 <setArpDebug>
    2988:	3c c0       	rjmp	.+120    	; 0x2a02 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    298a:	ce 01       	movw	r24, r28
    298c:	60 e8       	ldi	r22, 0x80	; 128
    298e:	77 e0       	ldi	r23, 0x07	; 7
    2990:	42 e0       	ldi	r20, 0x02	; 2
    2992:	50 e0       	ldi	r21, 0x00	; 0
    2994:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    2998:	00 97       	sbiw	r24, 0x00	; 0
    299a:	31 f4       	brne	.+12     	; 0x29a8 <debugFunction+0x6e>
    {
      setIpDebug(NULL, 0);
    299c:	80 e0       	ldi	r24, 0x00	; 0
    299e:	90 e0       	ldi	r25, 0x00	; 0
    29a0:	60 e0       	ldi	r22, 0x00	; 0
    29a2:	0e 94 a6 32 	call	0x654c	; 0x654c <setIpDebug>
    29a6:	2d c0       	rjmp	.+90     	; 0x2a02 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    29a8:	ce 01       	movw	r24, r28
    29aa:	6b e7       	ldi	r22, 0x7B	; 123
    29ac:	77 e0       	ldi	r23, 0x07	; 7
    29ae:	42 e0       	ldi	r20, 0x02	; 2
    29b0:	50 e0       	ldi	r21, 0x00	; 0
    29b2:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    29b6:	00 97       	sbiw	r24, 0x00	; 0
    29b8:	31 f4       	brne	.+12     	; 0x29c6 <debugFunction+0x8c>
    {
      setIcmpDebug(NULL, 0);
    29ba:	80 e0       	ldi	r24, 0x00	; 0
    29bc:	90 e0       	ldi	r25, 0x00	; 0
    29be:	60 e0       	ldi	r22, 0x00	; 0
    29c0:	0e 94 75 34 	call	0x68ea	; 0x68ea <setIcmpDebug>
    29c4:	1e c0       	rjmp	.+60     	; 0x2a02 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    29c6:	ce 01       	movw	r24, r28
    29c8:	67 e7       	ldi	r22, 0x77	; 119
    29ca:	77 e0       	ldi	r23, 0x07	; 7
    29cc:	42 e0       	ldi	r20, 0x02	; 2
    29ce:	50 e0       	ldi	r21, 0x00	; 0
    29d0:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    29d4:	00 97       	sbiw	r24, 0x00	; 0
    29d6:	31 f4       	brne	.+12     	; 0x29e4 <debugFunction+0xaa>
    {
      setTcpDebug(NULL, 0);
    29d8:	80 e0       	ldi	r24, 0x00	; 0
    29da:	90 e0       	ldi	r25, 0x00	; 0
    29dc:	60 e0       	ldi	r22, 0x00	; 0
    29de:	0e 94 a8 3c 	call	0x7950	; 0x7950 <setTcpDebug>
    29e2:	0f c0       	rjmp	.+30     	; 0x2a02 <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    29e4:	ce 01       	movw	r24, r28
    29e6:	63 e7       	ldi	r22, 0x73	; 115
    29e8:	77 e0       	ldi	r23, 0x07	; 7
    29ea:	42 e0       	ldi	r20, 0x02	; 2
    29ec:	50 e0       	ldi	r21, 0x00	; 0
    29ee:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    29f2:	00 97       	sbiw	r24, 0x00	; 0
    29f4:	09 f0       	breq	.+2      	; 0x29f8 <debugFunction+0xbe>
    29f6:	90 c0       	rjmp	.+288    	; 0x2b18 <debugFunction+0x1de>
    {
      setUdpDebug(NULL, 0);
    29f8:	80 e0       	ldi	r24, 0x00	; 0
    29fa:	90 e0       	ldi	r25, 0x00	; 0
    29fc:	60 e0       	ldi	r22, 0x00	; 0
    29fe:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <setUdpDebug>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
    2a02:	00 d0       	rcall	.+0      	; 0x2a04 <debugFunction+0xca>
    2a04:	00 d0       	rcall	.+0      	; 0x2a06 <debugFunction+0xcc>
    2a06:	ed b7       	in	r30, 0x3d	; 61
    2a08:	fe b7       	in	r31, 0x3e	; 62
    2a0a:	31 96       	adiw	r30, 0x01	; 1
    2a0c:	d8 01       	movw	r26, r16
    2a0e:	5a 96       	adiw	r26, 0x1a	; 26
    2a10:	8d 91       	ld	r24, X+
    2a12:	9c 91       	ld	r25, X
    2a14:	5b 97       	sbiw	r26, 0x1b	; 27
    2a16:	ad b7       	in	r26, 0x3d	; 61
    2a18:	be b7       	in	r27, 0x3e	; 62
    2a1a:	11 96       	adiw	r26, 0x01	; 1
    2a1c:	8d 93       	st	X+, r24
    2a1e:	9c 93       	st	X, r25
    2a20:	12 97       	sbiw	r26, 0x02	; 2
    2a22:	80 e9       	ldi	r24, 0x90	; 144
    2a24:	95 e0       	ldi	r25, 0x05	; 5
    2a26:	6a c0       	rjmp	.+212    	; 0x2afc <debugFunction+0x1c2>


  }
  else                   //level > 0
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2a28:	6f e6       	ldi	r22, 0x6F	; 111
    2a2a:	77 e0       	ldi	r23, 0x07	; 7
    2a2c:	43 e0       	ldi	r20, 0x03	; 3
    2a2e:	50 e0       	ldi	r21, 0x00	; 0
    2a30:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    2a34:	00 97       	sbiw	r24, 0x00	; 0
    2a36:	49 f4       	brne	.+18     	; 0x2a4a <debugFunction+0x110>
    {
      setArpDebug(state->myStdInOut, level);
    2a38:	d8 01       	movw	r26, r16
    2a3a:	5a 96       	adiw	r26, 0x1a	; 26
    2a3c:	8d 91       	ld	r24, X+
    2a3e:	9c 91       	ld	r25, X
    2a40:	5b 97       	sbiw	r26, 0x1b	; 27
    2a42:	6f 2d       	mov	r22, r15
    2a44:	0e 94 fc 35 	call	0x6bf8	; 0x6bf8 <setArpDebug>
    2a48:	47 c0       	rjmp	.+142    	; 0x2ad8 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }   
    
    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2a4a:	ce 01       	movw	r24, r28
    2a4c:	6c e6       	ldi	r22, 0x6C	; 108
    2a4e:	77 e0       	ldi	r23, 0x07	; 7
    2a50:	42 e0       	ldi	r20, 0x02	; 2
    2a52:	50 e0       	ldi	r21, 0x00	; 0
    2a54:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    2a58:	00 97       	sbiw	r24, 0x00	; 0
    2a5a:	49 f4       	brne	.+18     	; 0x2a6e <debugFunction+0x134>
    {
      setIpDebug(state->myStdInOut, level);
    2a5c:	d8 01       	movw	r26, r16
    2a5e:	5a 96       	adiw	r26, 0x1a	; 26
    2a60:	8d 91       	ld	r24, X+
    2a62:	9c 91       	ld	r25, X
    2a64:	5b 97       	sbiw	r26, 0x1b	; 27
    2a66:	6f 2d       	mov	r22, r15
    2a68:	0e 94 a6 32 	call	0x654c	; 0x654c <setIpDebug>
    2a6c:	35 c0       	rjmp	.+106    	; 0x2ad8 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2a6e:	ce 01       	movw	r24, r28
    2a70:	67 e6       	ldi	r22, 0x67	; 103
    2a72:	77 e0       	ldi	r23, 0x07	; 7
    2a74:	42 e0       	ldi	r20, 0x02	; 2
    2a76:	50 e0       	ldi	r21, 0x00	; 0
    2a78:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    2a7c:	00 97       	sbiw	r24, 0x00	; 0
    2a7e:	49 f4       	brne	.+18     	; 0x2a92 <debugFunction+0x158>
    {
      setIcmpDebug(state->myStdInOut, level);
    2a80:	d8 01       	movw	r26, r16
    2a82:	5a 96       	adiw	r26, 0x1a	; 26
    2a84:	8d 91       	ld	r24, X+
    2a86:	9c 91       	ld	r25, X
    2a88:	5b 97       	sbiw	r26, 0x1b	; 27
    2a8a:	6f 2d       	mov	r22, r15
    2a8c:	0e 94 75 34 	call	0x68ea	; 0x68ea <setIcmpDebug>
    2a90:	23 c0       	rjmp	.+70     	; 0x2ad8 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2a92:	ce 01       	movw	r24, r28
    2a94:	63 e6       	ldi	r22, 0x63	; 99
    2a96:	77 e0       	ldi	r23, 0x07	; 7
    2a98:	42 e0       	ldi	r20, 0x02	; 2
    2a9a:	50 e0       	ldi	r21, 0x00	; 0
    2a9c:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    2aa0:	00 97       	sbiw	r24, 0x00	; 0
    2aa2:	49 f4       	brne	.+18     	; 0x2ab6 <debugFunction+0x17c>
    {
      setTcpDebug(state->myStdInOut, level);
    2aa4:	d8 01       	movw	r26, r16
    2aa6:	5a 96       	adiw	r26, 0x1a	; 26
    2aa8:	8d 91       	ld	r24, X+
    2aaa:	9c 91       	ld	r25, X
    2aac:	5b 97       	sbiw	r26, 0x1b	; 27
    2aae:	6f 2d       	mov	r22, r15
    2ab0:	0e 94 a8 3c 	call	0x7950	; 0x7950 <setTcpDebug>
    2ab4:	11 c0       	rjmp	.+34     	; 0x2ad8 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }
    
    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2ab6:	ce 01       	movw	r24, r28
    2ab8:	6f e5       	ldi	r22, 0x5F	; 95
    2aba:	77 e0       	ldi	r23, 0x07	; 7
    2abc:	42 e0       	ldi	r20, 0x02	; 2
    2abe:	50 e0       	ldi	r21, 0x00	; 0
    2ac0:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    2ac4:	00 97       	sbiw	r24, 0x00	; 0
    2ac6:	41 f5       	brne	.+80     	; 0x2b18 <debugFunction+0x1de>
    {
      setUdpDebug(state->myStdInOut, level);
    2ac8:	d8 01       	movw	r26, r16
    2aca:	5a 96       	adiw	r26, 0x1a	; 26
    2acc:	8d 91       	ld	r24, X+
    2ace:	9c 91       	ld	r25, X
    2ad0:	5b 97       	sbiw	r26, 0x1b	; 27
    2ad2:	6f 2d       	mov	r22, r15
    2ad4:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <setUdpDebug>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
    2ad8:	00 d0       	rcall	.+0      	; 0x2ada <debugFunction+0x1a0>
    2ada:	00 d0       	rcall	.+0      	; 0x2adc <debugFunction+0x1a2>
    2adc:	ed b7       	in	r30, 0x3d	; 61
    2ade:	fe b7       	in	r31, 0x3e	; 62
    2ae0:	31 96       	adiw	r30, 0x01	; 1
    2ae2:	d8 01       	movw	r26, r16
    2ae4:	5a 96       	adiw	r26, 0x1a	; 26
    2ae6:	8d 91       	ld	r24, X+
    2ae8:	9c 91       	ld	r25, X
    2aea:	5b 97       	sbiw	r26, 0x1b	; 27
    2aec:	ad b7       	in	r26, 0x3d	; 61
    2aee:	be b7       	in	r27, 0x3e	; 62
    2af0:	11 96       	adiw	r26, 0x01	; 1
    2af2:	8d 93       	st	X+, r24
    2af4:	9c 93       	st	X, r25
    2af6:	12 97       	sbiw	r26, 0x02	; 2
    2af8:	8d e7       	ldi	r24, 0x7D	; 125
    2afa:	95 e0       	ldi	r25, 0x05	; 5
    2afc:	82 83       	std	Z+2, r24	; 0x02
    2afe:	93 83       	std	Z+3, r25	; 0x03
    2b00:	c4 83       	std	Z+4, r28	; 0x04
    2b02:	d5 83       	std	Z+5, r29	; 0x05
    2b04:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      return OK_SILENT;  
    2b08:	ed b7       	in	r30, 0x3d	; 61
    2b0a:	fe b7       	in	r31, 0x3e	; 62
    2b0c:	36 96       	adiw	r30, 0x06	; 6
    2b0e:	ed bf       	out	0x3d, r30	; 61
    2b10:	fe bf       	out	0x3e, r31	; 62
    2b12:	20 e0       	ldi	r18, 0x00	; 0
    2b14:	30 e0       	ldi	r19, 0x00	; 0
    2b16:	02 c0       	rjmp	.+4      	; 0x2b1c <debugFunction+0x1e2>
    }
  }
  
  return SYNTAX_ERROR;
    2b18:	22 e0       	ldi	r18, 0x02	; 2
    2b1a:	30 e0       	ldi	r19, 0x00	; 0
}
    2b1c:	c9 01       	movw	r24, r18
    2b1e:	df 91       	pop	r29
    2b20:	cf 91       	pop	r28
    2b22:	1f 91       	pop	r17
    2b24:	0f 91       	pop	r16
    2b26:	ff 90       	pop	r15
    2b28:	08 95       	ret

00002b2a <statusEncFunction>:
  return OK_SILENT; 
}

static cliExRes_t statusEncFunction(cmdState_t *state)
{
  nicRegDump(state->myStdInOut);
    2b2a:	fc 01       	movw	r30, r24
    2b2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b2e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2b30:	0e 94 eb 2c 	call	0x59d6	; 0x59d6 <nicRegDump>
  return OK_SILENT;
}
    2b34:	80 e0       	ldi	r24, 0x00	; 0
    2b36:	90 e0       	ldi	r25, 0x00	; 0
    2b38:	08 95       	ret

00002b3a <readRamFIleFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
{
    2b3a:	df 92       	push	r13
    2b3c:	ef 92       	push	r14
    2b3e:	ff 92       	push	r15
    2b40:	0f 93       	push	r16
    2b42:	1f 93       	push	r17
    2b44:	df 93       	push	r29
    2b46:	cf 93       	push	r28
    2b48:	0f 92       	push	r0
    2b4a:	cd b7       	in	r28, 0x3d	; 61
    2b4c:	de b7       	in	r29, 0x3e	; 62
    2b4e:	8c 01       	movw	r16, r24
  uint8_t rezultat;
  uint8_t znak = ' ';
    2b50:	80 e2       	ldi	r24, 0x20	; 32
    2b52:	89 83       	std	Y+1, r24	; 0x01
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
    2b54:	81 e0       	ldi	r24, 0x01	; 1
    2b56:	b8 01       	movw	r22, r16
    2b58:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2b5c:	64 ec       	ldi	r22, 0xC4	; 196
    2b5e:	72 e3       	ldi	r23, 0x32	; 50
    2b60:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <ramDyskOtworzPlik>
    2b64:	d8 01       	movw	r26, r16
    2b66:	5a 96       	adiw	r26, 0x1a	; 26
    2b68:	ed 90       	ld	r14, X+
    2b6a:	fc 90       	ld	r15, X
    2b6c:	5b 97       	sbiw	r26, 0x1b	; 27
    2b6e:	88 23       	and	r24, r24
    2b70:	f9 f0       	breq	.+62     	; 0x2bb0 <readRamFIleFunction+0x76>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2b72:	81 e0       	ldi	r24, 0x01	; 1
    2b74:	b8 01       	movw	r22, r16
    2b76:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2b7a:	00 d0       	rcall	.+0      	; 0x2b7c <readRamFIleFunction+0x42>
    2b7c:	00 d0       	rcall	.+0      	; 0x2b7e <readRamFIleFunction+0x44>
    2b7e:	ed b7       	in	r30, 0x3d	; 61
    2b80:	fe b7       	in	r31, 0x3e	; 62
    2b82:	31 96       	adiw	r30, 0x01	; 1
    2b84:	ad b7       	in	r26, 0x3d	; 61
    2b86:	be b7       	in	r27, 0x3e	; 62
    2b88:	11 96       	adiw	r26, 0x01	; 1
    2b8a:	ed 92       	st	X+, r14
    2b8c:	fc 92       	st	X, r15
    2b8e:	12 97       	sbiw	r26, 0x02	; 2
    2b90:	2a ee       	ldi	r18, 0xEA	; 234
    2b92:	32 e0       	ldi	r19, 0x02	; 2
    2b94:	22 83       	std	Z+2, r18	; 0x02
    2b96:	33 83       	std	Z+3, r19	; 0x03
    2b98:	84 83       	std	Z+4, r24	; 0x04
    2b9a:	95 83       	std	Z+5, r25	; 0x05
    2b9c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    return ERROR_INFORM;
    2ba0:	ed b7       	in	r30, 0x3d	; 61
    2ba2:	fe b7       	in	r31, 0x3e	; 62
    2ba4:	36 96       	adiw	r30, 0x06	; 6
    2ba6:	ed bf       	out	0x3d, r30	; 61
    2ba8:	fe bf       	out	0x3e, r31	; 62
    2baa:	24 e0       	ldi	r18, 0x04	; 4
    2bac:	30 e0       	ldi	r19, 0x00	; 0
    2bae:	54 c0       	rjmp	.+168    	; 0x2c58 <readRamFIleFunction+0x11e>
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    2bb0:	a0 91 c8 32 	lds	r26, 0x32C8
    2bb4:	b0 91 c9 32 	lds	r27, 0x32C9
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    2bb8:	00 d0       	rcall	.+0      	; 0x2bba <readRamFIleFunction+0x80>
    2bba:	00 d0       	rcall	.+0      	; 0x2bbc <readRamFIleFunction+0x82>
    2bbc:	4d b7       	in	r20, 0x3d	; 61
    2bbe:	5e b7       	in	r21, 0x3e	; 62
    2bc0:	4f 5f       	subi	r20, 0xFF	; 255
    2bc2:	5f 4f       	sbci	r21, 0xFF	; 255
    2bc4:	ed b7       	in	r30, 0x3d	; 61
    2bc6:	fe b7       	in	r31, 0x3e	; 62
    2bc8:	e1 82       	std	Z+1, r14	; 0x01
    2bca:	f2 82       	std	Z+2, r15	; 0x02
    2bcc:	88 ed       	ldi	r24, 0xD8	; 216
    2bce:	94 e0       	ldi	r25, 0x04	; 4
    2bd0:	fa 01       	movw	r30, r20
    2bd2:	82 83       	std	Z+2, r24	; 0x02
    2bd4:	93 83       	std	Z+3, r25	; 0x03
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    2bd6:	12 96       	adiw	r26, 0x02	; 2
    2bd8:	9c 91       	ld	r25, X
    2bda:	12 97       	sbiw	r26, 0x02	; 2
    2bdc:	80 e0       	ldi	r24, 0x00	; 0
    2bde:	11 96       	adiw	r26, 0x01	; 1
    2be0:	2c 91       	ld	r18, X
    2be2:	82 0f       	add	r24, r18
    2be4:	91 1d       	adc	r25, r1
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    2be6:	84 83       	std	Z+4, r24	; 0x04
    2be8:	95 83       	std	Z+5, r25	; 0x05
    2bea:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    2bee:	8d b7       	in	r24, 0x3d	; 61
    2bf0:	9e b7       	in	r25, 0x3e	; 62
    2bf2:	06 96       	adiw	r24, 0x06	; 6
    2bf4:	8d bf       	out	0x3d, r24	; 61
    2bf6:	9e bf       	out	0x3e, r25	; 62
  while (rezultat == 0)
  {
    rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
    2bf8:	7e 01       	movw	r14, r28
    2bfa:	08 94       	sec
    2bfc:	e1 1c       	adc	r14, r1
    2bfe:	f1 1c       	adc	r15, r1
    2c00:	84 ec       	ldi	r24, 0xC4	; 196
    2c02:	92 e3       	ldi	r25, 0x32	; 50
    2c04:	b7 01       	movw	r22, r14
    2c06:	0e 94 77 1e 	call	0x3cee	; 0x3cee <ramDyskCzytajBajtZPliku>
    2c0a:	d8 2e       	mov	r13, r24
    
    uartVtySendByte(znak);
    2c0c:	89 81       	ldd	r24, Y+1	; 0x01
    2c0e:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    if (znak == '\r')
    2c12:	89 81       	ldd	r24, Y+1	; 0x01
    2c14:	8d 30       	cpi	r24, 0x0D	; 13
    2c16:	19 f4       	brne	.+6      	; 0x2c1e <readRamFIleFunction+0xe4>
      uartVtySendByte('\n');
    2c18:	8a e0       	ldi	r24, 0x0A	; 10
    2c1a:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
  while (rezultat == 0)
    2c1e:	dd 20       	and	r13, r13
    2c20:	79 f3       	breq	.-34     	; 0x2c00 <readRamFIleFunction+0xc6>
    
    uartVtySendByte(znak);
    if (znak == '\r')
      uartVtySendByte('\n');
  }
  fprintf_P(state->myStdInOut, nlStr);
    2c22:	00 d0       	rcall	.+0      	; 0x2c24 <readRamFIleFunction+0xea>
    2c24:	0f 92       	push	r0
    2c26:	d8 01       	movw	r26, r16
    2c28:	5a 96       	adiw	r26, 0x1a	; 26
    2c2a:	8d 91       	ld	r24, X+
    2c2c:	9c 91       	ld	r25, X
    2c2e:	5b 97       	sbiw	r26, 0x1b	; 27
    2c30:	ed b7       	in	r30, 0x3d	; 61
    2c32:	fe b7       	in	r31, 0x3e	; 62
    2c34:	81 83       	std	Z+1, r24	; 0x01
    2c36:	92 83       	std	Z+2, r25	; 0x02
    2c38:	83 e5       	ldi	r24, 0x53	; 83
    2c3a:	96 e0       	ldi	r25, 0x06	; 6
    2c3c:	83 83       	std	Z+3, r24	; 0x03
    2c3e:	94 83       	std	Z+4, r25	; 0x04
    2c40:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  ramDyskZamknijPlik(&fdVty);
    2c44:	0f 90       	pop	r0
    2c46:	0f 90       	pop	r0
    2c48:	0f 90       	pop	r0
    2c4a:	0f 90       	pop	r0
    2c4c:	84 ec       	ldi	r24, 0xC4	; 196
    2c4e:	92 e3       	ldi	r25, 0x32	; 50
    2c50:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <ramDyskZamknijPlik>
  return OK_SILENT;
    2c54:	20 e0       	ldi	r18, 0x00	; 0
    2c56:	30 e0       	ldi	r19, 0x00	; 0
}
    2c58:	c9 01       	movw	r24, r18
    2c5a:	0f 90       	pop	r0
    2c5c:	cf 91       	pop	r28
    2c5e:	df 91       	pop	r29
    2c60:	1f 91       	pop	r17
    2c62:	0f 91       	pop	r16
    2c64:	ff 90       	pop	r15
    2c66:	ef 90       	pop	r14
    2c68:	df 90       	pop	r13
    2c6a:	08 95       	ret

00002c6c <writeRamFileFunction>:
  return ERROR_INFORM;
}

static cliExRes_t writeRamFileFunction(cmdState_t *state)
{
  ramDyskDir(state->myStdInOut);
    2c6c:	fc 01       	movw	r30, r24
    2c6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c70:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c72:	0e 94 c3 20 	call	0x4186	; 0x4186 <ramDyskDir>
  return OK_SILENT;
}
    2c76:	80 e0       	ldi	r24, 0x00	; 0
    2c78:	90 e0       	ldi	r25, 0x00	; 0
    2c7a:	08 95       	ret

00002c7c <pokazCzasFunction>:
  nicRegDump(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
    2c7c:	cf 93       	push	r28
    2c7e:	df 93       	push	r29
    2c80:	ec 01       	movw	r28, r24
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
    2c82:	85 e1       	ldi	r24, 0x15	; 21
    2c84:	92 e3       	ldi	r25, 0x32	; 50
    2c86:	0e 94 b2 27 	call	0x4f64	; 0x4f64 <readTimeDecoded>
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    2c8a:	40 91 17 32 	lds	r20, 0x3217
    2c8e:	46 95       	lsr	r20
    2c90:	46 95       	lsr	r20
    2c92:	46 95       	lsr	r20
    2c94:	70 91 17 32 	lds	r23, 0x3217
    2c98:	7f 70       	andi	r23, 0x0F	; 15
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2c9a:	30 91 16 32 	lds	r19, 0x3216
    2c9e:	36 95       	lsr	r19
    2ca0:	36 95       	lsr	r19
    2ca2:	36 95       	lsr	r19
    2ca4:	60 91 16 32 	lds	r22, 0x3216
    2ca8:	6f 70       	andi	r22, 0x0F	; 15
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    2caa:	20 91 15 32 	lds	r18, 0x3215
    2cae:	26 95       	lsr	r18
    2cb0:	26 95       	lsr	r18
    2cb2:	26 95       	lsr	r18
    2cb4:	50 91 15 32 	lds	r21, 0x3215
    2cb8:	5f 70       	andi	r21, 0x0F	; 15
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2cba:	8d b7       	in	r24, 0x3d	; 61
    2cbc:	9e b7       	in	r25, 0x3e	; 62
    2cbe:	0a 97       	sbiw	r24, 0x0a	; 10
    2cc0:	8d bf       	out	0x3d, r24	; 61
    2cc2:	9e bf       	out	0x3e, r25	; 62
    2cc4:	ed b7       	in	r30, 0x3d	; 61
    2cc6:	fe b7       	in	r31, 0x3e	; 62
    2cc8:	31 96       	adiw	r30, 0x01	; 1
    2cca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ccc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2cce:	ad b7       	in	r26, 0x3d	; 61
    2cd0:	be b7       	in	r27, 0x3e	; 62
    2cd2:	11 96       	adiw	r26, 0x01	; 1
    2cd4:	8d 93       	st	X+, r24
    2cd6:	9c 93       	st	X, r25
    2cd8:	12 97       	sbiw	r26, 0x02	; 2
    2cda:	87 e8       	ldi	r24, 0x87	; 135
    2cdc:	97 e0       	ldi	r25, 0x07	; 7
    2cde:	82 83       	std	Z+2, r24	; 0x02
    2ce0:	93 83       	std	Z+3, r25	; 0x03
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    2ce2:	46 70       	andi	r20, 0x06	; 6
    2ce4:	84 2f       	mov	r24, r20
    2ce6:	88 0f       	add	r24, r24
    2ce8:	88 0f       	add	r24, r24
    2cea:	84 0f       	add	r24, r20
    2cec:	87 0f       	add	r24, r23
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2cee:	84 83       	std	Z+4, r24	; 0x04
    2cf0:	15 82       	std	Z+5, r1	; 0x05

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2cf2:	3e 70       	andi	r19, 0x0E	; 14
    2cf4:	83 2f       	mov	r24, r19
    2cf6:	88 0f       	add	r24, r24
    2cf8:	88 0f       	add	r24, r24
    2cfa:	83 0f       	add	r24, r19
    2cfc:	86 0f       	add	r24, r22
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2cfe:	86 83       	std	Z+6, r24	; 0x06
    2d00:	17 82       	std	Z+7, r1	; 0x07
static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    2d02:	2e 70       	andi	r18, 0x0E	; 14
    2d04:	82 2f       	mov	r24, r18
    2d06:	88 0f       	add	r24, r24
    2d08:	88 0f       	add	r24, r24
    2d0a:	82 0f       	add	r24, r18
    2d0c:	85 0f       	add	r24, r21
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2d0e:	80 87       	std	Z+8, r24	; 0x08
    2d10:	11 86       	std	Z+9, r1	; 0x09
    2d12:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    2d16:	8d b7       	in	r24, 0x3d	; 61
    2d18:	9e b7       	in	r25, 0x3e	; 62
    2d1a:	0a 96       	adiw	r24, 0x0a	; 10
    2d1c:	8d bf       	out	0x3d, r24	; 61
    2d1e:	9e bf       	out	0x3e, r25	; 62
  return OK_SILENT;
}
    2d20:	80 e0       	ldi	r24, 0x00	; 0
    2d22:	90 e0       	ldi	r25, 0x00	; 0
    2d24:	df 91       	pop	r29
    2d26:	cf 91       	pop	r28
    2d28:	08 95       	ret

00002d2a <helpFunction>:
  return OK_SILENT;
}

static cliExRes_t helpFunction(cmdState_t *state)
{
  cmdPrintHelp(state);
    2d2a:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <cmdPrintHelp>
  return OK_SILENT;
}
    2d2e:	80 e0       	ldi	r24, 0x00	; 0
    2d30:	90 e0       	ldi	r25, 0x00	; 0
    2d32:	08 95       	ret

00002d34 <VtyInit>:
  {cmd_disable,      cmd_help_disable,      disableFunction},
  {NULL, NULL, NULL}
};

void VtyInit(cmdState_t* state, FILE *stream)
{
    2d34:	ef 92       	push	r14
    2d36:	0f 93       	push	r16
    2d38:	1f 93       	push	r17
    2d3a:	9b 01       	movw	r18, r22
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
    2d3c:	60 e0       	ldi	r22, 0x00	; 0
    2d3e:	78 e2       	ldi	r23, 0x28	; 40
    2d40:	40 e0       	ldi	r20, 0x00	; 0
    2d42:	51 e0       	ldi	r21, 0x01	; 1
    2d44:	08 e9       	ldi	r16, 0x98	; 152
    2d46:	16 e0       	ldi	r17, 0x06	; 6
    2d48:	ee 24       	eor	r14, r14
    2d4a:	0e 94 8f 22 	call	0x451e	; 0x451e <cmdStateConfigure>
}
    2d4e:	1f 91       	pop	r17
    2d50:	0f 91       	pop	r16
    2d52:	ef 90       	pop	r14
    2d54:	08 95       	ret

00002d56 <printErrorInfo>:

void printErrorInfo(cmdState_t *state)
{
    2d56:	cf 93       	push	r28
    2d58:	df 93       	push	r29
    2d5a:	ec 01       	movw	r28, r24
  if (state->errno != 0)
    2d5c:	ec 8d       	ldd	r30, Y+28	; 0x1c
    2d5e:	ee 23       	and	r30, r30
    2d60:	49 f1       	breq	.+82     	; 0x2db4 <printErrorInfo+0x5e>
  {
    fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->err1, state->err2);
    2d62:	f0 e0       	ldi	r31, 0x00	; 0
    2d64:	ee 0f       	add	r30, r30
    2d66:	ff 1f       	adc	r31, r31
    2d68:	e0 58       	subi	r30, 0x80	; 128
    2d6a:	f9 4f       	sbci	r31, 0xF9	; 249
    2d6c:	85 91       	lpm	r24, Z+
    2d6e:	94 91       	lpm	r25, Z+
    2d70:	2d b7       	in	r18, 0x3d	; 61
    2d72:	3e b7       	in	r19, 0x3e	; 62
    2d74:	28 50       	subi	r18, 0x08	; 8
    2d76:	30 40       	sbci	r19, 0x00	; 0
    2d78:	2d bf       	out	0x3d, r18	; 61
    2d7a:	3e bf       	out	0x3e, r19	; 62
    2d7c:	ed b7       	in	r30, 0x3d	; 61
    2d7e:	fe b7       	in	r31, 0x3e	; 62
    2d80:	31 96       	adiw	r30, 0x01	; 1
    2d82:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2d84:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2d86:	ad b7       	in	r26, 0x3d	; 61
    2d88:	be b7       	in	r27, 0x3e	; 62
    2d8a:	11 96       	adiw	r26, 0x01	; 1
    2d8c:	2d 93       	st	X+, r18
    2d8e:	3c 93       	st	X, r19
    2d90:	12 97       	sbiw	r26, 0x02	; 2
    2d92:	82 83       	std	Z+2, r24	; 0x02
    2d94:	93 83       	std	Z+3, r25	; 0x03
    2d96:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2d98:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2d9a:	84 83       	std	Z+4, r24	; 0x04
    2d9c:	95 83       	std	Z+5, r25	; 0x05
    2d9e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2da0:	86 83       	std	Z+6, r24	; 0x06
    2da2:	17 82       	std	Z+7, r1	; 0x07
    2da4:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    2da8:	2d b7       	in	r18, 0x3d	; 61
    2daa:	3e b7       	in	r19, 0x3e	; 62
    2dac:	28 5f       	subi	r18, 0xF8	; 248
    2dae:	3f 4f       	sbci	r19, 0xFF	; 255
    2db0:	2d bf       	out	0x3d, r18	; 61
    2db2:	3e bf       	out	0x3e, r19	; 62
  }
  state->errno = 0;
    2db4:	1c 8e       	std	Y+28, r1	; 0x1c
  state->err1 = 0;
    2db6:	1d 8e       	std	Y+29, r1	; 0x1d
    2db8:	1e 8e       	std	Y+30, r1	; 0x1e
  state->err2 = 0;
    2dba:	1f 8e       	std	Y+31, r1	; 0x1f
}
    2dbc:	df 91       	pop	r29
    2dbe:	cf 91       	pop	r28
    2dc0:	08 95       	ret

00002dc2 <eraseRamFileFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
    2dc2:	cf 93       	push	r28
    2dc4:	df 93       	push	r29
    2dc6:	ec 01       	movw	r28, r24
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    2dc8:	81 e0       	ldi	r24, 0x01	; 1
    2dca:	be 01       	movw	r22, r28
    2dcc:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2dd0:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <ramDyskUsunPlik>
    2dd4:	88 23       	and	r24, r24
    2dd6:	31 f0       	breq	.+12     	; 0x2de4 <eraseRamFileFunction+0x22>
    return OK_INFORM;

  printErrorInfo(state);
    2dd8:	ce 01       	movw	r24, r28
    2dda:	0e 94 ab 16 	call	0x2d56	; 0x2d56 <printErrorInfo>
  return ERROR_INFORM;
    2dde:	24 e0       	ldi	r18, 0x04	; 4
    2de0:	30 e0       	ldi	r19, 0x00	; 0
    2de2:	02 c0       	rjmp	.+4      	; 0x2de8 <eraseRamFileFunction+0x26>
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    return OK_INFORM;
    2de4:	21 e0       	ldi	r18, 0x01	; 1
    2de6:	30 e0       	ldi	r19, 0x00	; 0

  printErrorInfo(state);
  return ERROR_INFORM;
}
    2de8:	c9 01       	movw	r24, r18
    2dea:	df 91       	pop	r29
    2dec:	cf 91       	pop	r28
    2dee:	08 95       	ret

00002df0 <dodajRamPlikFunction>:

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
    2df0:	cf 93       	push	r28
    2df2:	df 93       	push	r29
    2df4:	ec 01       	movw	r28, r24
  if (state->argc != 1)
    2df6:	89 8d       	ldd	r24, Y+25	; 0x19
    2df8:	81 30       	cpi	r24, 0x01	; 1
    2dfa:	69 f4       	brne	.+26     	; 0x2e16 <dodajRamPlikFunction+0x26>
    return SYNTAX_ERROR;

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
    2dfc:	be 01       	movw	r22, r28
    2dfe:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2e02:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <ramDyskUtworzPlik>
    2e06:	88 23       	and	r24, r24
    2e08:	49 f0       	breq	.+18     	; 0x2e1c <dodajRamPlikFunction+0x2c>
  {
    return OK_INFORM;
  }
  printErrorInfo(state);
    2e0a:	ce 01       	movw	r24, r28
    2e0c:	0e 94 ab 16 	call	0x2d56	; 0x2d56 <printErrorInfo>
  return ERROR_INFORM;
    2e10:	24 e0       	ldi	r18, 0x04	; 4
    2e12:	30 e0       	ldi	r19, 0x00	; 0
    2e14:	05 c0       	rjmp	.+10     	; 0x2e20 <dodajRamPlikFunction+0x30>
}

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
  if (state->argc != 1)
    return SYNTAX_ERROR;
    2e16:	22 e0       	ldi	r18, 0x02	; 2
    2e18:	30 e0       	ldi	r19, 0x00	; 0
    2e1a:	02 c0       	rjmp	.+4      	; 0x2e20 <dodajRamPlikFunction+0x30>

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
  {
    return OK_INFORM;
    2e1c:	21 e0       	ldi	r18, 0x01	; 1
    2e1e:	30 e0       	ldi	r19, 0x00	; 0
  }
  printErrorInfo(state);
  return ERROR_INFORM;
}
    2e20:	c9 01       	movw	r24, r18
    2e22:	df 91       	pop	r29
    2e24:	cf 91       	pop	r28
    2e26:	08 95       	ret

00002e28 <flashExModuleFunction>:
  return OK_SILENT;
}


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
    2e28:	ff 92       	push	r15
    2e2a:	0f 93       	push	r16
    2e2c:	1f 93       	push	r17
    2e2e:	cf 93       	push	r28
    2e30:	df 93       	push	r29
    2e32:	ec 01       	movw	r28, r24
  if (state->argc != 2)
    2e34:	89 8d       	ldd	r24, Y+25	; 0x19
    2e36:	82 30       	cpi	r24, 0x02	; 2
    2e38:	09 f0       	breq	.+2      	; 0x2e3c <flashExModuleFunction+0x14>
    2e3a:	46 c0       	rjmp	.+140    	; 0x2ec8 <flashExModuleFunction+0xa0>
    return SYNTAX_ERROR;
  
  uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
    2e3c:	81 e0       	ldi	r24, 0x01	; 1
    2e3e:	be 01       	movw	r22, r28
    2e40:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
    2e44:	f6 2e       	mov	r15, r22
  char *nazwaPliku      = cmdlineGetArgStr(2, state);
    2e46:	82 e0       	ldi	r24, 0x02	; 2
    2e48:	be 01       	movw	r22, r28
    2e4a:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    2e4e:	8c 01       	movw	r16, r24
  uint8_t  blad;
  
  // Sprawdzanie, czy moduł wykonawczy odpowiada
  if (rs485ping(nrUrzadzenia) != 0)
    2e50:	8f 2d       	mov	r24, r15
    2e52:	0e 94 50 40 	call	0x80a0	; 0x80a0 <rs485ping>
    2e56:	88 23       	and	r24, r24
    2e58:	31 f0       	breq	.+12     	; 0x2e66 <flashExModuleFunction+0x3e>
  {
    state->errno = noRemoteDevice;
    2e5a:	89 e0       	ldi	r24, 0x09	; 9
    2e5c:	8c 8f       	std	Y+28, r24	; 0x1c
    printErrorInfo(state);
    2e5e:	ce 01       	movw	r24, r28
    2e60:	0e 94 ab 16 	call	0x2d56	; 0x2d56 <printErrorInfo>
    2e64:	2e c0       	rjmp	.+92     	; 0x2ec2 <flashExModuleFunction+0x9a>
    return ERROR_INFORM;
  }
  
  //Sprawdzanie, czy istnieje odpowiedni plik z firmware
  if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
    2e66:	c8 01       	movw	r24, r16
    2e68:	64 ec       	ldi	r22, 0xC4	; 196
    2e6a:	72 e3       	ldi	r23, 0x32	; 50
    2e6c:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <ramDyskOtworzPlik>
    2e70:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2e72:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2e74:	88 23       	and	r24, r24
    2e76:	c9 f0       	breq	.+50     	; 0x2eaa <flashExModuleFunction+0x82>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
    2e78:	00 d0       	rcall	.+0      	; 0x2e7a <flashExModuleFunction+0x52>
    2e7a:	00 d0       	rcall	.+0      	; 0x2e7c <flashExModuleFunction+0x54>
    2e7c:	ed b7       	in	r30, 0x3d	; 61
    2e7e:	fe b7       	in	r31, 0x3e	; 62
    2e80:	31 96       	adiw	r30, 0x01	; 1
    2e82:	ad b7       	in	r26, 0x3d	; 61
    2e84:	be b7       	in	r27, 0x3e	; 62
    2e86:	11 96       	adiw	r26, 0x01	; 1
    2e88:	4d 93       	st	X+, r20
    2e8a:	5c 93       	st	X, r21
    2e8c:	12 97       	sbiw	r26, 0x02	; 2
    2e8e:	8a ee       	ldi	r24, 0xEA	; 234
    2e90:	92 e0       	ldi	r25, 0x02	; 2
    2e92:	82 83       	std	Z+2, r24	; 0x02
    2e94:	93 83       	std	Z+3, r25	; 0x03
    2e96:	04 83       	std	Z+4, r16	; 0x04
    2e98:	15 83       	std	Z+5, r17	; 0x05
    2e9a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    return ERROR_INFORM;
    2e9e:	8d b7       	in	r24, 0x3d	; 61
    2ea0:	9e b7       	in	r25, 0x3e	; 62
    2ea2:	06 96       	adiw	r24, 0x06	; 6
    2ea4:	8d bf       	out	0x3d, r24	; 61
    2ea6:	9e bf       	out	0x3e, r25	; 62
    2ea8:	0c c0       	rjmp	.+24     	; 0x2ec2 <flashExModuleFunction+0x9a>
  }
  
  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
    2eaa:	84 ec       	ldi	r24, 0xC4	; 196
    2eac:	92 e3       	ldi	r25, 0x32	; 50
    2eae:	6f 2d       	mov	r22, r15
    2eb0:	0e 94 60 42 	call	0x84c0	; 0x84c0 <rs485xModemFlash>
    2eb4:	08 2f       	mov	r16, r24

  ramDyskZamknijPlik(&fdVty);
    2eb6:	84 ec       	ldi	r24, 0xC4	; 196
    2eb8:	92 e3       	ldi	r25, 0x32	; 50
    2eba:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <ramDyskZamknijPlik>
  
  if (blad != 0)
    2ebe:	00 23       	and	r16, r16
    2ec0:	31 f0       	breq	.+12     	; 0x2ece <flashExModuleFunction+0xa6>
    return ERROR_INFORM;
    2ec2:	24 e0       	ldi	r18, 0x04	; 4
    2ec4:	30 e0       	ldi	r19, 0x00	; 0
    2ec6:	05 c0       	rjmp	.+10     	; 0x2ed2 <flashExModuleFunction+0xaa>


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
  if (state->argc != 2)
    return SYNTAX_ERROR;
    2ec8:	22 e0       	ldi	r18, 0x02	; 2
    2eca:	30 e0       	ldi	r19, 0x00	; 0
    2ecc:	02 c0       	rjmp	.+4      	; 0x2ed2 <flashExModuleFunction+0xaa>
  ramDyskZamknijPlik(&fdVty);
  
  if (blad != 0)
    return ERROR_INFORM;

  return OK_SILENT;
    2ece:	20 e0       	ldi	r18, 0x00	; 0
    2ed0:	30 e0       	ldi	r19, 0x00	; 0
}
    2ed2:	c9 01       	movw	r24, r18
    2ed4:	df 91       	pop	r29
    2ed6:	cf 91       	pop	r28
    2ed8:	1f 91       	pop	r17
    2eda:	0f 91       	pop	r16
    2edc:	ff 90       	pop	r15
    2ede:	08 95       	ret

00002ee0 <rpingFunction>:
  
  return OK_SILENT;
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
    2ee0:	0f 93       	push	r16
    2ee2:	1f 93       	push	r17
    2ee4:	df 93       	push	r29
    2ee6:	cf 93       	push	r28
    2ee8:	0f 92       	push	r0
    2eea:	cd b7       	in	r28, 0x3d	; 61
    2eec:	de b7       	in	r29, 0x3e	; 62
    2eee:	8c 01       	movw	r16, r24
  if (state->argc < 1)
    2ef0:	fc 01       	movw	r30, r24
    2ef2:	81 8d       	ldd	r24, Z+25	; 0x19
    2ef4:	88 23       	and	r24, r24
    2ef6:	b9 f0       	breq	.+46     	; 0x2f26 <rpingFunction+0x46>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
    2ef8:	81 e0       	ldi	r24, 0x01	; 1
    2efa:	b8 01       	movw	r22, r16
    2efc:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <cmdlineGetArgInt>
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    2f00:	86 2f       	mov	r24, r22
    2f02:	69 83       	std	Y+1, r22	; 0x01
    2f04:	0e 94 50 40 	call	0x80a0	; 0x80a0 <rs485ping>
    2f08:	f8 01       	movw	r30, r16
    2f0a:	87 8f       	std	Z+31, r24	; 0x1f
    2f0c:	69 81       	ldd	r22, Y+1	; 0x01
    2f0e:	88 23       	and	r24, r24
    2f10:	69 f0       	breq	.+26     	; 0x2f2c <rpingFunction+0x4c>
    return OK_INFORM;

  state->errno = noRemoteDevice;
    2f12:	89 e0       	ldi	r24, 0x09	; 9
    2f14:	84 8f       	std	Z+28, r24	; 0x1c
  state->err1 = nrSterownika;
    2f16:	65 8f       	std	Z+29, r22	; 0x1d
    2f18:	16 8e       	std	Z+30, r1	; 0x1e
  printErrorInfo(state);
    2f1a:	c8 01       	movw	r24, r16
    2f1c:	0e 94 ab 16 	call	0x2d56	; 0x2d56 <printErrorInfo>
  return OK_SILENT;
    2f20:	20 e0       	ldi	r18, 0x00	; 0
    2f22:	30 e0       	ldi	r19, 0x00	; 0
    2f24:	05 c0       	rjmp	.+10     	; 0x2f30 <rpingFunction+0x50>
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    2f26:	22 e0       	ldi	r18, 0x02	; 2
    2f28:	30 e0       	ldi	r19, 0x00	; 0
    2f2a:	02 c0       	rjmp	.+4      	; 0x2f30 <rpingFunction+0x50>
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    return OK_INFORM;
    2f2c:	21 e0       	ldi	r18, 0x01	; 1
    2f2e:	30 e0       	ldi	r19, 0x00	; 0

  state->errno = noRemoteDevice;
  state->err1 = nrSterownika;
  printErrorInfo(state);
  return OK_SILENT;
}
    2f30:	c9 01       	movw	r24, r18
    2f32:	0f 90       	pop	r0
    2f34:	cf 91       	pop	r28
    2f36:	df 91       	pop	r29
    2f38:	1f 91       	pop	r17
    2f3a:	0f 91       	pop	r16
    2f3c:	08 95       	ret

00002f3e <printStatus>:
  return ERROR_OPERATION_NOT_ALLOWED;
}

// ************************** VTY API ***************************************************************************************
void printStatus(FILE *stream)
{
    2f3e:	cf 93       	push	r28
    2f40:	df 93       	push	r29
    2f42:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
    2f44:	00 d0       	rcall	.+0      	; 0x2f46 <printStatus+0x8>
    2f46:	0f 92       	push	r0
    2f48:	ad b7       	in	r26, 0x3d	; 61
    2f4a:	be b7       	in	r27, 0x3e	; 62
    2f4c:	11 96       	adiw	r26, 0x01	; 1
    2f4e:	8d 93       	st	X+, r24
    2f50:	9c 93       	st	X, r25
    2f52:	12 97       	sbiw	r26, 0x02	; 2
    2f54:	8c ea       	ldi	r24, 0xAC	; 172
    2f56:	97 e0       	ldi	r25, 0x07	; 7
    2f58:	13 96       	adiw	r26, 0x03	; 3
    2f5a:	8d 93       	st	X+, r24
    2f5c:	9c 93       	st	X, r25
    2f5e:	14 97       	sbiw	r26, 0x04	; 4
    2f60:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  //Print system state
  fprintf_P(stream, systemStateStr);
    2f64:	ed b7       	in	r30, 0x3d	; 61
    2f66:	fe b7       	in	r31, 0x3e	; 62
    2f68:	c1 83       	std	Z+1, r28	; 0x01
    2f6a:	d2 83       	std	Z+2, r29	; 0x02
    2f6c:	8f ef       	ldi	r24, 0xFF	; 255
    2f6e:	92 e0       	ldi	r25, 0x02	; 2
    2f70:	83 83       	std	Z+3, r24	; 0x03
    2f72:	94 83       	std	Z+4, r25	; 0x04
    2f74:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
    2f78:	0f 90       	pop	r0
    2f7a:	0f 90       	pop	r0
    2f7c:	0f 90       	pop	r0
    2f7e:	0f 90       	pop	r0
    2f80:	0e 94 da 48 	call	0x91b4	; 0x91b4 <uxTaskGetNumberOfTasks>
    2f84:	00 d0       	rcall	.+0      	; 0x2f86 <printStatus+0x48>
    2f86:	00 d0       	rcall	.+0      	; 0x2f88 <printStatus+0x4a>
    2f88:	ed b7       	in	r30, 0x3d	; 61
    2f8a:	fe b7       	in	r31, 0x3e	; 62
    2f8c:	31 96       	adiw	r30, 0x01	; 1
    2f8e:	ad b7       	in	r26, 0x3d	; 61
    2f90:	be b7       	in	r27, 0x3e	; 62
    2f92:	11 96       	adiw	r26, 0x01	; 1
    2f94:	cd 93       	st	X+, r28
    2f96:	dc 93       	st	X, r29
    2f98:	12 97       	sbiw	r26, 0x02	; 2
    2f9a:	2f e0       	ldi	r18, 0x0F	; 15
    2f9c:	33 e0       	ldi	r19, 0x03	; 3
    2f9e:	22 83       	std	Z+2, r18	; 0x02
    2fa0:	33 83       	std	Z+3, r19	; 0x03
    2fa2:	84 83       	std	Z+4, r24	; 0x04
    2fa4:	15 82       	std	Z+5, r1	; 0x05
    2fa6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
    2faa:	ed b7       	in	r30, 0x3d	; 61
    2fac:	fe b7       	in	r31, 0x3e	; 62
    2fae:	36 96       	adiw	r30, 0x06	; 6
    2fb0:	ed bf       	out	0x3d, r30	; 61
    2fb2:	fe bf       	out	0x3e, r31	; 62
    2fb4:	0e 94 8a 52 	call	0xa514	; 0xa514 <xPortGetFreeHeapSize>
    2fb8:	2d b7       	in	r18, 0x3d	; 61
    2fba:	3e b7       	in	r19, 0x3e	; 62
    2fbc:	28 50       	subi	r18, 0x08	; 8
    2fbe:	30 40       	sbci	r19, 0x00	; 0
    2fc0:	2d bf       	out	0x3d, r18	; 61
    2fc2:	3e bf       	out	0x3e, r19	; 62
    2fc4:	ed b7       	in	r30, 0x3d	; 61
    2fc6:	fe b7       	in	r31, 0x3e	; 62
    2fc8:	31 96       	adiw	r30, 0x01	; 1
    2fca:	ad b7       	in	r26, 0x3d	; 61
    2fcc:	be b7       	in	r27, 0x3e	; 62
    2fce:	11 96       	adiw	r26, 0x01	; 1
    2fd0:	cd 93       	st	X+, r28
    2fd2:	dc 93       	st	X, r29
    2fd4:	12 97       	sbiw	r26, 0x02	; 2
    2fd6:	28 e2       	ldi	r18, 0x28	; 40
    2fd8:	33 e0       	ldi	r19, 0x03	; 3
    2fda:	22 83       	std	Z+2, r18	; 0x02
    2fdc:	33 83       	std	Z+3, r19	; 0x03
    2fde:	84 83       	std	Z+4, r24	; 0x04
    2fe0:	95 83       	std	Z+5, r25	; 0x05
    2fe2:	88 eb       	ldi	r24, 0xB8	; 184
    2fe4:	9b e0       	ldi	r25, 0x0B	; 11
    2fe6:	86 83       	std	Z+6, r24	; 0x06
    2fe8:	97 83       	std	Z+7, r25	; 0x07
    2fea:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
    2fee:	ed b7       	in	r30, 0x3d	; 61
    2ff0:	fe b7       	in	r31, 0x3e	; 62
    2ff2:	38 96       	adiw	r30, 0x08	; 8
    2ff4:	ed bf       	out	0x3d, r30	; 61
    2ff6:	fe bf       	out	0x3e, r31	; 62
    2ff8:	0e 94 30 1c 	call	0x3860	; 0x3860 <xmallocAvailable>
    2ffc:	2d b7       	in	r18, 0x3d	; 61
    2ffe:	3e b7       	in	r19, 0x3e	; 62
    3000:	28 50       	subi	r18, 0x08	; 8
    3002:	30 40       	sbci	r19, 0x00	; 0
    3004:	2d bf       	out	0x3d, r18	; 61
    3006:	3e bf       	out	0x3e, r19	; 62
    3008:	ed b7       	in	r30, 0x3d	; 61
    300a:	fe b7       	in	r31, 0x3e	; 62
    300c:	31 96       	adiw	r30, 0x01	; 1
    300e:	ad b7       	in	r26, 0x3d	; 61
    3010:	be b7       	in	r27, 0x3e	; 62
    3012:	11 96       	adiw	r26, 0x01	; 1
    3014:	cd 93       	st	X+, r28
    3016:	dc 93       	st	X, r29
    3018:	12 97       	sbiw	r26, 0x02	; 2
    301a:	22 e5       	ldi	r18, 0x52	; 82
    301c:	33 e0       	ldi	r19, 0x03	; 3
    301e:	22 83       	std	Z+2, r18	; 0x02
    3020:	33 83       	std	Z+3, r19	; 0x03
    3022:	84 83       	std	Z+4, r24	; 0x04
    3024:	95 83       	std	Z+5, r25	; 0x05
    3026:	80 e0       	ldi	r24, 0x00	; 0
    3028:	97 e1       	ldi	r25, 0x17	; 23
    302a:	86 83       	std	Z+6, r24	; 0x06
    302c:	97 83       	std	Z+7, r25	; 0x07
    302e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, statusTemperatureStr, temperature); 
    3032:	20 91 04 32 	lds	r18, 0x3204
    3036:	0f 90       	pop	r0
    3038:	0f 90       	pop	r0
    303a:	ed b7       	in	r30, 0x3d	; 61
    303c:	fe b7       	in	r31, 0x3e	; 62
    303e:	31 96       	adiw	r30, 0x01	; 1
    3040:	ad b7       	in	r26, 0x3d	; 61
    3042:	be b7       	in	r27, 0x3e	; 62
    3044:	11 96       	adiw	r26, 0x01	; 1
    3046:	cd 93       	st	X+, r28
    3048:	dc 93       	st	X, r29
    304a:	12 97       	sbiw	r26, 0x02	; 2
    304c:	89 ea       	ldi	r24, 0xA9	; 169
    304e:	93 e0       	ldi	r25, 0x03	; 3
    3050:	82 83       	std	Z+2, r24	; 0x02
    3052:	93 83       	std	Z+3, r25	; 0x03
    3054:	24 83       	std	Z+4, r18	; 0x04
    3056:	15 82       	std	Z+5, r1	; 0x05
    3058:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, statusVoltageStr, voltage); 
    305c:	20 91 0c 32 	lds	r18, 0x320C
    3060:	ed b7       	in	r30, 0x3d	; 61
    3062:	fe b7       	in	r31, 0x3e	; 62
    3064:	31 96       	adiw	r30, 0x01	; 1
    3066:	ad b7       	in	r26, 0x3d	; 61
    3068:	be b7       	in	r27, 0x3e	; 62
    306a:	11 96       	adiw	r26, 0x01	; 1
    306c:	cd 93       	st	X+, r28
    306e:	dc 93       	st	X, r29
    3070:	12 97       	sbiw	r26, 0x02	; 2
    3072:	84 ec       	ldi	r24, 0xC4	; 196
    3074:	93 e0       	ldi	r25, 0x03	; 3
    3076:	82 83       	std	Z+2, r24	; 0x02
    3078:	93 83       	std	Z+3, r25	; 0x03
    307a:	24 83       	std	Z+4, r18	; 0x04
    307c:	15 82       	std	Z+5, r1	; 0x05
    307e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>

  uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
    3082:	ed b7       	in	r30, 0x3d	; 61
    3084:	fe b7       	in	r31, 0x3e	; 62
    3086:	36 96       	adiw	r30, 0x06	; 6
    3088:	ed bf       	out	0x3d, r30	; 61
    308a:	fe bf       	out	0x3e, r31	; 62
    308c:	0e 94 52 21 	call	0x42a4	; 0x42a4 <ramDyskLiczbaWolnychKlastrow>
  fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
    3090:	2d b7       	in	r18, 0x3d	; 61
    3092:	3e b7       	in	r19, 0x3e	; 62
    3094:	28 50       	subi	r18, 0x08	; 8
    3096:	30 40       	sbci	r19, 0x00	; 0
    3098:	2d bf       	out	0x3d, r18	; 61
    309a:	3e bf       	out	0x3e, r19	; 62
    309c:	ed b7       	in	r30, 0x3d	; 61
    309e:	fe b7       	in	r31, 0x3e	; 62
    30a0:	31 96       	adiw	r30, 0x01	; 1
    30a2:	ad b7       	in	r26, 0x3d	; 61
    30a4:	be b7       	in	r27, 0x3e	; 62
    30a6:	11 96       	adiw	r26, 0x01	; 1
    30a8:	cd 93       	st	X+, r28
    30aa:	dc 93       	st	X, r29
    30ac:	12 97       	sbiw	r26, 0x02	; 2
    30ae:	2c e7       	ldi	r18, 0x7C	; 124
    30b0:	33 e0       	ldi	r19, 0x03	; 3
    30b2:	22 83       	std	Z+2, r18	; 0x02
    30b4:	33 83       	std	Z+3, r19	; 0x03
    30b6:	84 83       	std	Z+4, r24	; 0x04
    30b8:	15 82       	std	Z+5, r1	; 0x05
    30ba:	80 e8       	ldi	r24, 0x80	; 128
    30bc:	90 e0       	ldi	r25, 0x00	; 0
    30be:	86 83       	std	Z+6, r24	; 0x06
    30c0:	97 83       	std	Z+7, r25	; 0x07
    30c2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
//  printErrorInfo(state); //TODO fix and uncomment
  
  //Print system configuration
  fprintf_P(stream, systemRamConfigStr);
    30c6:	0f 90       	pop	r0
    30c8:	0f 90       	pop	r0
    30ca:	0f 90       	pop	r0
    30cc:	0f 90       	pop	r0
    30ce:	ed b7       	in	r30, 0x3d	; 61
    30d0:	fe b7       	in	r31, 0x3e	; 62
    30d2:	c1 83       	std	Z+1, r28	; 0x01
    30d4:	d2 83       	std	Z+2, r29	; 0x02
    30d6:	8f ed       	ldi	r24, 0xDF	; 223
    30d8:	93 e0       	ldi	r25, 0x03	; 3
    30da:	83 83       	std	Z+3, r24	; 0x03
    30dc:	94 83       	std	Z+4, r25	; 0x04
    30de:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>

  fprintf_P(stream, statusMacStr);
    30e2:	ad b7       	in	r26, 0x3d	; 61
    30e4:	be b7       	in	r27, 0x3e	; 62
    30e6:	11 96       	adiw	r26, 0x01	; 1
    30e8:	cd 93       	st	X+, r28
    30ea:	dc 93       	st	X, r29
    30ec:	12 97       	sbiw	r26, 0x02	; 2
    30ee:	82 ef       	ldi	r24, 0xF2	; 242
    30f0:	93 e0       	ldi	r25, 0x03	; 3
    30f2:	13 96       	adiw	r26, 0x03	; 3
    30f4:	8d 93       	st	X+, r24
    30f6:	9c 93       	st	X, r25
    30f8:	14 97       	sbiw	r26, 0x04	; 4
    30fa:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    30fe:	0f 90       	pop	r0
    3100:	0f 90       	pop	r0
    3102:	0f 90       	pop	r0
    3104:	0f 90       	pop	r0
    3106:	ce 01       	movw	r24, r28
    3108:	6e ed       	ldi	r22, 0xDE	; 222
    310a:	71 e3       	ldi	r23, 0x31	; 49
    310c:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3110:	00 d0       	rcall	.+0      	; 0x3112 <printStatus+0x1d4>
    3112:	0f 92       	push	r0
    3114:	ed b7       	in	r30, 0x3d	; 61
    3116:	fe b7       	in	r31, 0x3e	; 62
    3118:	c1 83       	std	Z+1, r28	; 0x01
    311a:	d2 83       	std	Z+2, r29	; 0x02
    311c:	89 ea       	ldi	r24, 0xA9	; 169
    311e:	97 e0       	ldi	r25, 0x07	; 7
    3120:	83 83       	std	Z+3, r24	; 0x03
    3122:	94 83       	std	Z+4, r25	; 0x04
    3124:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  
  fprintf_P(stream, statusIpStr);
    3128:	ad b7       	in	r26, 0x3d	; 61
    312a:	be b7       	in	r27, 0x3e	; 62
    312c:	11 96       	adiw	r26, 0x01	; 1
    312e:	cd 93       	st	X+, r28
    3130:	dc 93       	st	X, r29
    3132:	12 97       	sbiw	r26, 0x02	; 2
    3134:	87 e0       	ldi	r24, 0x07	; 7
    3136:	94 e0       	ldi	r25, 0x04	; 4
    3138:	13 96       	adiw	r26, 0x03	; 3
    313a:	8d 93       	st	X+, r24
    313c:	9c 93       	st	X, r25
    313e:	14 97       	sbiw	r26, 0x04	; 4
    3140:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->ip);
    3144:	0f 90       	pop	r0
    3146:	0f 90       	pop	r0
    3148:	0f 90       	pop	r0
    314a:	0f 90       	pop	r0
    314c:	0e 94 ef 32 	call	0x65de	; 0x65de <ipGetConfig>
    3150:	fc 01       	movw	r30, r24
    3152:	40 81       	ld	r20, Z
    3154:	51 81       	ldd	r21, Z+1	; 0x01
    3156:	62 81       	ldd	r22, Z+2	; 0x02
    3158:	73 81       	ldd	r23, Z+3	; 0x03
    315a:	ce 01       	movw	r24, r28
    315c:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3160:	00 d0       	rcall	.+0      	; 0x3162 <printStatus+0x224>
    3162:	0f 92       	push	r0
    3164:	ad b7       	in	r26, 0x3d	; 61
    3166:	be b7       	in	r27, 0x3e	; 62
    3168:	11 96       	adiw	r26, 0x01	; 1
    316a:	cd 93       	st	X+, r28
    316c:	dc 93       	st	X, r29
    316e:	12 97       	sbiw	r26, 0x02	; 2
    3170:	86 ea       	ldi	r24, 0xA6	; 166
    3172:	97 e0       	ldi	r25, 0x07	; 7
    3174:	13 96       	adiw	r26, 0x03	; 3
    3176:	8d 93       	st	X+, r24
    3178:	9c 93       	st	X, r25
    317a:	14 97       	sbiw	r26, 0x04	; 4
    317c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>

  fprintf_P(stream, statusIpMaskStr);
    3180:	ed b7       	in	r30, 0x3d	; 61
    3182:	fe b7       	in	r31, 0x3e	; 62
    3184:	c1 83       	std	Z+1, r28	; 0x01
    3186:	d2 83       	std	Z+2, r29	; 0x02
    3188:	8c e1       	ldi	r24, 0x1C	; 28
    318a:	94 e0       	ldi	r25, 0x04	; 4
    318c:	83 83       	std	Z+3, r24	; 0x03
    318e:	94 83       	std	Z+4, r25	; 0x04
    3190:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->netmask);
    3194:	0f 90       	pop	r0
    3196:	0f 90       	pop	r0
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	0e 94 ef 32 	call	0x65de	; 0x65de <ipGetConfig>
    31a0:	dc 01       	movw	r26, r24
    31a2:	14 96       	adiw	r26, 0x04	; 4
    31a4:	4d 91       	ld	r20, X+
    31a6:	5d 91       	ld	r21, X+
    31a8:	6d 91       	ld	r22, X+
    31aa:	7c 91       	ld	r23, X
    31ac:	17 97       	sbiw	r26, 0x07	; 7
    31ae:	ce 01       	movw	r24, r28
    31b0:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    31b4:	00 d0       	rcall	.+0      	; 0x31b6 <printStatus+0x278>
    31b6:	0f 92       	push	r0
    31b8:	ed b7       	in	r30, 0x3d	; 61
    31ba:	fe b7       	in	r31, 0x3e	; 62
    31bc:	c1 83       	std	Z+1, r28	; 0x01
    31be:	d2 83       	std	Z+2, r29	; 0x02
    31c0:	83 ea       	ldi	r24, 0xA3	; 163
    31c2:	97 e0       	ldi	r25, 0x07	; 7
    31c4:	83 83       	std	Z+3, r24	; 0x03
    31c6:	94 83       	std	Z+4, r25	; 0x04
    31c8:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  
  fprintf_P(stream, statusIpGwStr);
    31cc:	ad b7       	in	r26, 0x3d	; 61
    31ce:	be b7       	in	r27, 0x3e	; 62
    31d0:	11 96       	adiw	r26, 0x01	; 1
    31d2:	cd 93       	st	X+, r28
    31d4:	dc 93       	st	X, r29
    31d6:	12 97       	sbiw	r26, 0x02	; 2
    31d8:	81 e3       	ldi	r24, 0x31	; 49
    31da:	94 e0       	ldi	r25, 0x04	; 4
    31dc:	13 96       	adiw	r26, 0x03	; 3
    31de:	8d 93       	st	X+, r24
    31e0:	9c 93       	st	X, r25
    31e2:	14 97       	sbiw	r26, 0x04	; 4
    31e4:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->gateway);
    31e8:	0f 90       	pop	r0
    31ea:	0f 90       	pop	r0
    31ec:	0f 90       	pop	r0
    31ee:	0f 90       	pop	r0
    31f0:	0e 94 ef 32 	call	0x65de	; 0x65de <ipGetConfig>
    31f4:	fc 01       	movw	r30, r24
    31f6:	40 85       	ldd	r20, Z+8	; 0x08
    31f8:	51 85       	ldd	r21, Z+9	; 0x09
    31fa:	62 85       	ldd	r22, Z+10	; 0x0a
    31fc:	73 85       	ldd	r23, Z+11	; 0x0b
    31fe:	ce 01       	movw	r24, r28
    3200:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3204:	00 d0       	rcall	.+0      	; 0x3206 <printStatus+0x2c8>
    3206:	0f 92       	push	r0
    3208:	ad b7       	in	r26, 0x3d	; 61
    320a:	be b7       	in	r27, 0x3e	; 62
    320c:	11 96       	adiw	r26, 0x01	; 1
    320e:	cd 93       	st	X+, r28
    3210:	dc 93       	st	X, r29
    3212:	12 97       	sbiw	r26, 0x02	; 2
    3214:	80 ea       	ldi	r24, 0xA0	; 160
    3216:	97 e0       	ldi	r25, 0x07	; 7
    3218:	13 96       	adiw	r26, 0x03	; 3
    321a:	8d 93       	st	X+, r24
    321c:	9c 93       	st	X, r25
    321e:	14 97       	sbiw	r26, 0x04	; 4
    3220:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  
  //Print Rs485 Execitive modules
  fprintf_P(stream, statusRs485listStr);
    3224:	ed b7       	in	r30, 0x3d	; 61
    3226:	fe b7       	in	r31, 0x3e	; 62
    3228:	c1 83       	std	Z+1, r28	; 0x01
    322a:	d2 83       	std	Z+2, r29	; 0x02
    322c:	86 e4       	ldi	r24, 0x46	; 70
    322e:	94 e0       	ldi	r25, 0x04	; 4
    3230:	83 83       	std	Z+3, r24	; 0x03
    3232:	94 83       	std	Z+4, r25	; 0x04
    3234:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  tmp = printRs485devices(stream);
    3238:	0f 90       	pop	r0
    323a:	0f 90       	pop	r0
    323c:	0f 90       	pop	r0
    323e:	0f 90       	pop	r0
    3240:	ce 01       	movw	r24, r28
    3242:	0e 94 e6 3f 	call	0x7fcc	; 0x7fcc <printRs485devices>
  if (tmp == 0)
    3246:	88 23       	and	r24, r24
    3248:	a1 f4       	brne	.+40     	; 0x3272 <printStatus+0x334>
    fprintf_P(stream, statusNoRs485Dev);  
    324a:	00 d0       	rcall	.+0      	; 0x324c <printStatus+0x30e>
    324c:	0f 92       	push	r0
    324e:	ad b7       	in	r26, 0x3d	; 61
    3250:	be b7       	in	r27, 0x3e	; 62
    3252:	11 96       	adiw	r26, 0x01	; 1
    3254:	cd 93       	st	X+, r28
    3256:	dc 93       	st	X, r29
    3258:	12 97       	sbiw	r26, 0x02	; 2
    325a:	81 e6       	ldi	r24, 0x61	; 97
    325c:	94 e0       	ldi	r25, 0x04	; 4
    325e:	13 96       	adiw	r26, 0x03	; 3
    3260:	8d 93       	st	X+, r24
    3262:	9c 93       	st	X, r25
    3264:	14 97       	sbiw	r26, 0x04	; 4
    3266:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    326a:	0f 90       	pop	r0
    326c:	0f 90       	pop	r0
    326e:	0f 90       	pop	r0
    3270:	0f 90       	pop	r0
  
  //Print locker sensors
  fprintf_P(stream, statusLockerSensorsStr);
    3272:	00 d0       	rcall	.+0      	; 0x3274 <printStatus+0x336>
    3274:	0f 92       	push	r0
    3276:	ed b7       	in	r30, 0x3d	; 61
    3278:	fe b7       	in	r31, 0x3e	; 62
    327a:	c1 83       	std	Z+1, r28	; 0x01
    327c:	d2 83       	std	Z+2, r29	; 0x02
    327e:	8b e7       	ldi	r24, 0x7B	; 123
    3280:	94 e0       	ldi	r25, 0x04	; 4
    3282:	83 83       	std	Z+3, r24	; 0x03
    3284:	94 83       	std	Z+4, r25	; 0x04
    3286:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  tmp = printLockers(stream);
    328a:	0f 90       	pop	r0
    328c:	0f 90       	pop	r0
    328e:	0f 90       	pop	r0
    3290:	0f 90       	pop	r0
    3292:	ce 01       	movw	r24, r28
    3294:	0e 94 76 0b 	call	0x16ec	; 0x16ec <printLockers>
  if (tmp == 0)
    3298:	88 23       	and	r24, r24
    329a:	a1 f4       	brne	.+40     	; 0x32c4 <printStatus+0x386>
    fprintf_P(stream, statusLockerSensorsDisStr);
    329c:	00 d0       	rcall	.+0      	; 0x329e <printStatus+0x360>
    329e:	0f 92       	push	r0
    32a0:	ad b7       	in	r26, 0x3d	; 61
    32a2:	be b7       	in	r27, 0x3e	; 62
    32a4:	11 96       	adiw	r26, 0x01	; 1
    32a6:	cd 93       	st	X+, r28
    32a8:	dc 93       	st	X, r29
    32aa:	12 97       	sbiw	r26, 0x02	; 2
    32ac:	84 e9       	ldi	r24, 0x94	; 148
    32ae:	94 e0       	ldi	r25, 0x04	; 4
    32b0:	13 96       	adiw	r26, 0x03	; 3
    32b2:	8d 93       	st	X+, r24
    32b4:	9c 93       	st	X, r25
    32b6:	14 97       	sbiw	r26, 0x04	; 4
    32b8:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    32bc:	0f 90       	pop	r0
    32be:	0f 90       	pop	r0
    32c0:	0f 90       	pop	r0
    32c2:	0f 90       	pop	r0
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    32c4:	ce 01       	movw	r24, r28
    32c6:	0e 94 b1 3e 	call	0x7d62	; 0x7d62 <udpPrintStatus>
//  arpPrintTable(stream);
}
    32ca:	df 91       	pop	r29
    32cc:	cf 91       	pop	r28
    32ce:	08 95       	ret

000032d0 <statusFunction>:


// ************************** CLI Functions *********************************************************************************

static cliExRes_t statusFunction(cmdState_t *state)
{
    32d0:	ef 92       	push	r14
    32d2:	ff 92       	push	r15
    32d4:	0f 93       	push	r16
    32d6:	1f 93       	push	r17
    32d8:	df 93       	push	r29
    32da:	cf 93       	push	r28
    32dc:	cd b7       	in	r28, 0x3d	; 61
    32de:	de b7       	in	r29, 0x3e	; 62
    32e0:	2e 97       	sbiw	r28, 0x0e	; 14
    32e2:	cd bf       	out	0x3d, r28	; 61
    32e4:	de bf       	out	0x3e, r29	; 62
    32e6:	7c 01       	movw	r14, r24
  if (state->argc < 1)
    32e8:	dc 01       	movw	r26, r24
    32ea:	59 96       	adiw	r26, 0x19	; 25
    32ec:	8c 91       	ld	r24, X
    32ee:	59 97       	sbiw	r26, 0x19	; 25
    32f0:	88 23       	and	r24, r24
    32f2:	39 f4       	brne	.+14     	; 0x3302 <statusFunction+0x32>
  {
    printStatus(state->myStdInOut);
    32f4:	5a 96       	adiw	r26, 0x1a	; 26
    32f6:	8d 91       	ld	r24, X+
    32f8:	9c 91       	ld	r25, X
    32fa:	5b 97       	sbiw	r26, 0x1b	; 27
    32fc:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <printStatus>
    3300:	37 c0       	rjmp	.+110    	; 0x3370 <statusFunction+0xa0>
    return OK_SILENT; 
  }
  
  FILE stream;
  if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
    3302:	81 e0       	ldi	r24, 0x01	; 1
    3304:	b7 01       	movw	r22, r14
    3306:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    330a:	64 ec       	ldi	r22, 0xC4	; 196
    330c:	72 e3       	ldi	r23, 0x32	; 50
    330e:	8e 01       	movw	r16, r28
    3310:	0f 5f       	subi	r16, 0xFF	; 255
    3312:	1f 4f       	sbci	r17, 0xFF	; 255
    3314:	a8 01       	movw	r20, r16
    3316:	23 e0       	ldi	r18, 0x03	; 3
    3318:	0e 94 5e 21 	call	0x42bc	; 0x42bc <ramDyskOtworzPlikStdIo>
    331c:	88 23       	and	r24, r24
    331e:	11 f1       	breq	.+68     	; 0x3364 <statusFunction+0x94>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    3320:	f7 01       	movw	r30, r14
    3322:	02 8d       	ldd	r16, Z+26	; 0x1a
    3324:	13 8d       	ldd	r17, Z+27	; 0x1b
    3326:	81 e0       	ldi	r24, 0x01	; 1
    3328:	b7 01       	movw	r22, r14
    332a:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    332e:	00 d0       	rcall	.+0      	; 0x3330 <statusFunction+0x60>
    3330:	00 d0       	rcall	.+0      	; 0x3332 <statusFunction+0x62>
    3332:	ed b7       	in	r30, 0x3d	; 61
    3334:	fe b7       	in	r31, 0x3e	; 62
    3336:	31 96       	adiw	r30, 0x01	; 1
    3338:	ad b7       	in	r26, 0x3d	; 61
    333a:	be b7       	in	r27, 0x3e	; 62
    333c:	11 96       	adiw	r26, 0x01	; 1
    333e:	0d 93       	st	X+, r16
    3340:	1c 93       	st	X, r17
    3342:	12 97       	sbiw	r26, 0x02	; 2
    3344:	2a ee       	ldi	r18, 0xEA	; 234
    3346:	32 e0       	ldi	r19, 0x02	; 2
    3348:	22 83       	std	Z+2, r18	; 0x02
    334a:	33 83       	std	Z+3, r19	; 0x03
    334c:	84 83       	std	Z+4, r24	; 0x04
    334e:	95 83       	std	Z+5, r25	; 0x05
    3350:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    return ERROR_INFORM;
    3354:	ed b7       	in	r30, 0x3d	; 61
    3356:	fe b7       	in	r31, 0x3e	; 62
    3358:	36 96       	adiw	r30, 0x06	; 6
    335a:	ed bf       	out	0x3d, r30	; 61
    335c:	fe bf       	out	0x3e, r31	; 62
    335e:	24 e0       	ldi	r18, 0x04	; 4
    3360:	30 e0       	ldi	r19, 0x00	; 0
    3362:	08 c0       	rjmp	.+16     	; 0x3374 <statusFunction+0xa4>
  }

  printStatus(&stream);
    3364:	c8 01       	movw	r24, r16
    3366:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <printStatus>
  ramDyskZamknijPlikStdIo(&stream);
    336a:	c8 01       	movw	r24, r16
    336c:	0e 94 83 21 	call	0x4306	; 0x4306 <ramDyskZamknijPlikStdIo>
  return OK_SILENT; 
    3370:	20 e0       	ldi	r18, 0x00	; 0
    3372:	30 e0       	ldi	r19, 0x00	; 0
}
    3374:	c9 01       	movw	r24, r18
    3376:	2e 96       	adiw	r28, 0x0e	; 14
    3378:	cd bf       	out	0x3d, r28	; 61
    337a:	de bf       	out	0x3e, r29	; 62
    337c:	cf 91       	pop	r28
    337e:	df 91       	pop	r29
    3380:	1f 91       	pop	r17
    3382:	0f 91       	pop	r16
    3384:	ff 90       	pop	r15
    3386:	ef 90       	pop	r14
    3388:	08 95       	ret

0000338a <encTask>:
//   return 0;
// }


void encTask ( void *pvParameters )
{
    338a:	ef 92       	push	r14
    338c:	ff 92       	push	r15
    338e:	0f 93       	push	r16
    3390:	1f 93       	push	r17
    3392:	cf 93       	push	r28
    3394:	df 93       	push	r29
  FILE *netstackDebug = (FILE *) pvParameters;
    3396:	e8 2e       	mov	r14, r24
    3398:	e7 01       	movw	r28, r14
    339a:	7e 01       	movw	r14, r28
    339c:	f9 2e       	mov	r15, r25
    339e:	e7 01       	movw	r28, r14
  uint16_t plen;

  nicInit();
    33a0:	0e 94 04 2e 	call	0x5c08	; 0x5c08 <nicInit>
  ipInit();
    33a4:	0e 94 98 31 	call	0x6330	; 0x6330 <ipInit>
  arpInit();
    33a8:	0e 94 09 36 	call	0x6c12	; 0x6c12 <arpInit>
  icmpInit();
    33ac:	0e 94 6e 34 	call	0x68dc	; 0x68dc <icmpInit>
    }
    else
    {
      if (netstackDebug != NULL)
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    33b0:	0e ed       	ldi	r16, 0xDE	; 222
    33b2:	17 e0       	ldi	r17, 0x07	; 7
  //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);
  
  
  for ( ; ; )
  {
    vTaskDelay ( 0 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwolniony po odebrzeniu przerwania od ENC
    33b4:	80 e0       	ldi	r24, 0x00	; 0
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    
    // get the next new packet:
    plen = nicPoll();
    33bc:	0e 94 15 2b 	call	0x562a	; 0x562a <nicPoll>
    /*plen will ne unequal to zero if there is a valid
    * packet (without crc error) */
    if ( plen==0 )
    33c0:	00 97       	sbiw	r24, 0x00	; 0
    33c2:	29 f4       	brne	.+10     	; 0x33ce <encTask+0x44>
    {
      flushUdpQueues();
    33c4:	0e 94 60 3e 	call	0x7cc0	; 0x7cc0 <flushUdpQueues>
      flushTcpQueues();
    33c8:	0e 94 af 3c 	call	0x795e	; 0x795e <flushTcpQueues>
      //flush HTTP long file queue 
      continue;
    33cc:	f3 cf       	rjmp	.-26     	; 0x33b4 <encTask+0x2a>
    }
    
    if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
    33ce:	e0 91 e4 31 	lds	r30, 0x31E4
    33d2:	f0 91 e5 31 	lds	r31, 0x31E5
    33d6:	e4 84       	ldd	r14, Z+12	; 0x0c
    33d8:	f5 84       	ldd	r15, Z+13	; 0x0d
    33da:	80 e0       	ldi	r24, 0x00	; 0
    33dc:	98 e0       	ldi	r25, 0x08	; 8
    33de:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    33e2:	e8 16       	cp	r14, r24
    33e4:	f9 06       	cpc	r15, r25
    33e6:	29 f4       	brne	.+10     	; 0x33f2 <encTask+0x68>
    {
      arpIpIn();
    33e8:	0e 94 8b 36 	call	0x6d16	; 0x6d16 <arpIpIn>
      netstackIPv4Process();
    33ec:	0e 94 e8 31 	call	0x63d0	; 0x63d0 <netstackIPv4Process>
    33f0:	e1 cf       	rjmp	.-62     	; 0x33b4 <encTask+0x2a>
    }
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
    33f2:	e0 91 e4 31 	lds	r30, 0x31E4
    33f6:	f0 91 e5 31 	lds	r31, 0x31E5
    33fa:	e4 84       	ldd	r14, Z+12	; 0x0c
    33fc:	f5 84       	ldd	r15, Z+13	; 0x0d
    33fe:	86 e0       	ldi	r24, 0x06	; 6
    3400:	98 e0       	ldi	r25, 0x08	; 8
    3402:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    3406:	e8 16       	cp	r14, r24
    3408:	f9 06       	cpc	r15, r25
    340a:	19 f4       	brne	.+6      	; 0x3412 <encTask+0x88>
    {
      arpArpIn();
    340c:	0e 94 42 38 	call	0x7084	; 0x7084 <arpArpIn>
    3410:	d1 cf       	rjmp	.-94     	; 0x33b4 <encTask+0x2a>
    }
    else
    {
      if (netstackDebug != NULL)
    3412:	20 97       	sbiw	r28, 0x00	; 0
    3414:	79 f2       	breq	.-98     	; 0x33b4 <encTask+0x2a>
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    3416:	00 d0       	rcall	.+0      	; 0x3418 <encTask+0x8e>
    3418:	0f 92       	push	r0
    341a:	ed b7       	in	r30, 0x3d	; 61
    341c:	fe b7       	in	r31, 0x3e	; 62
    341e:	c1 83       	std	Z+1, r28	; 0x01
    3420:	d2 83       	std	Z+2, r29	; 0x02
    3422:	03 83       	std	Z+3, r16	; 0x03
    3424:	14 83       	std	Z+4, r17	; 0x04
    3426:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	0f 90       	pop	r0
    3430:	0f 90       	pop	r0
    3432:	c0 cf       	rjmp	.-128    	; 0x33b4 <encTask+0x2a>

00003434 <vTaskVTYusb>:
#include "cli_task.h"

void vTaskVTYusb(void *cliStatePtr)
{
    3434:	ef 92       	push	r14
    3436:	ff 92       	push	r15
    3438:	0f 93       	push	r16
    343a:	1f 93       	push	r17
    343c:	df 93       	push	r29
    343e:	cf 93       	push	r28
    3440:	0f 92       	push	r0
    3442:	cd b7       	in	r28, 0x3d	; 61
    3444:	de b7       	in	r29, 0x3e	; 62
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    3446:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Restart\r\n"));
    3448:	00 d0       	rcall	.+0      	; 0x344a <vTaskVTYusb+0x16>
    344a:	0f 92       	push	r0
    344c:	fc 01       	movw	r30, r24
    344e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3450:	93 8d       	ldd	r25, Z+27	; 0x1b
    3452:	ed b7       	in	r30, 0x3d	; 61
    3454:	fe b7       	in	r31, 0x3e	; 62
    3456:	81 83       	std	Z+1, r24	; 0x01
    3458:	92 83       	std	Z+2, r25	; 0x02
    345a:	8f ee       	ldi	r24, 0xEF	; 239
    345c:	97 e0       	ldi	r25, 0x07	; 7
    345e:	83 83       	std	Z+3, r24	; 0x03
    3460:	94 83       	std	Z+4, r25	; 0x04
    3462:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  cmdlineInputFunc('\r', state);
    3466:	0f 90       	pop	r0
    3468:	0f 90       	pop	r0
    346a:	0f 90       	pop	r0
    346c:	0f 90       	pop	r0
    346e:	8d e0       	ldi	r24, 0x0D	; 13
    3470:	b8 01       	movw	r22, r16
    3472:	0e 94 d3 22 	call	0x45a6	; 0x45a6 <cmdlineInputFunc>
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    3476:	7e 01       	movw	r14, r28
    3478:	08 94       	sec
    347a:	e1 1c       	adc	r14, r1
    347c:	f1 1c       	adc	r15, r1
    347e:	80 91 0d 32 	lds	r24, 0x320D
    3482:	90 91 0e 32 	lds	r25, 0x320E
    3486:	b7 01       	movw	r22, r14
    3488:	4f ef       	ldi	r20, 0xFF	; 255
    348a:	5f ef       	ldi	r21, 0xFF	; 255
    348c:	20 e0       	ldi	r18, 0x00	; 0
    348e:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    3492:	88 23       	and	r24, r24
    3494:	a1 f3       	breq	.-24     	; 0x347e <vTaskVTYusb+0x4a>
    {
      cmdlineInputFunc((char)znak, state);
    3496:	89 81       	ldd	r24, Y+1	; 0x01
    3498:	b8 01       	movw	r22, r16
    349a:	0e 94 d3 22 	call	0x45a6	; 0x45a6 <cmdlineInputFunc>
      cmdlineMainLoop(state);
    349e:	c8 01       	movw	r24, r16
    34a0:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <cmdlineMainLoop>
    34a4:	ec cf       	rjmp	.-40     	; 0x347e <vTaskVTYusb+0x4a>

000034a6 <vTaskUSB>:
    }  
  }
}
void vTaskUSB(void *cliStatePtr)
{
    34a6:	1f 93       	push	r17
(void) cliStatePtr;; 
 for(;;)
 {
  vTaskDelay(200);
  USARTD0.DATA='a';
    34a8:	11 e6       	ldi	r17, 0x61	; 97
void vTaskUSB(void *cliStatePtr)
{
(void) cliStatePtr;; 
 for(;;)
 {
  vTaskDelay(200);
    34aa:	88 ec       	ldi	r24, 0xC8	; 200
    34ac:	90 e0       	ldi	r25, 0x00	; 0
    34ae:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
  USARTD0.DATA='a';
    34b2:	10 93 a0 09 	sts	0x09A0, r17
    34b6:	f9 cf       	rjmp	.-14     	; 0x34aa <vTaskUSB+0x4>

000034b8 <vTaskVTYsocket>:
 }
}

void vTaskVTYsocket(void *cliStatePtr)
{
    34b8:	ef 92       	push	r14
    34ba:	ff 92       	push	r15
    34bc:	cf 93       	push	r28
    34be:	df 93       	push	r29
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    34c0:	e8 2e       	mov	r14, r24
    34c2:	e7 01       	movw	r28, r14
    34c4:	7e 01       	movw	r14, r28
    34c6:	f9 2e       	mov	r15, r25
    34c8:	e7 01       	movw	r28, r14
  
  char znak;
  for( ;; )
  {
    znak = 0;
    znak = fgetc(state->myStdInOut);
    34ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    34cc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    34ce:	0e 94 29 57 	call	0xae52	; 0xae52 <fgetc>
    cmdlineInputFunc((char)znak, state);
    34d2:	be 01       	movw	r22, r28
    34d4:	0e 94 d3 22 	call	0x45a6	; 0x45a6 <cmdlineInputFunc>
    cmdlineMainLoop(state);
    34d8:	ce 01       	movw	r24, r28
    34da:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <cmdlineMainLoop>
    34de:	f5 cf       	rjmp	.-22     	; 0x34ca <vTaskVTYsocket+0x12>

000034e0 <vTasklcd>:
void vTasklcd(void *cliStatePtr)
{
    
    for(;;)
    {
      vTaskDelay(100);
    34e0:	84 e6       	ldi	r24, 0x64	; 100
    34e2:	90 e0       	ldi	r25, 0x00	; 0
    34e4:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
      lcdWrite('a');
    34e8:	81 e6       	ldi	r24, 0x61	; 97
    34ea:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <lcdWrite>
    34ee:	f8 cf       	rjmp	.-16     	; 0x34e0 <vTasklcd>

000034f0 <odwroc>:
#include<lcd.h>
// PB5 D4, PB2 D7
unsigned char odwroc(unsigned char dana)
{
	unsigned char pomoc=0xFF;
	if(dana&0x01) pomoc|=0x80;
    34f0:	98 2f       	mov	r25, r24
    34f2:	80 ff       	sbrs	r24, 0
    34f4:	02 c0       	rjmp	.+4      	; 0x34fa <odwroc+0xa>
    34f6:	2f ef       	ldi	r18, 0xFF	; 255
    34f8:	01 c0       	rjmp	.+2      	; 0x34fc <odwroc+0xc>
	else pomoc&=~0x80;
    34fa:	2f e7       	ldi	r18, 0x7F	; 127
	if(dana&0x02) pomoc|=0x40;
    34fc:	91 ff       	sbrs	r25, 1
    34fe:	02 c0       	rjmp	.+4      	; 0x3504 <odwroc+0x14>
    3500:	20 64       	ori	r18, 0x40	; 64
    3502:	01 c0       	rjmp	.+2      	; 0x3506 <odwroc+0x16>
	else pomoc|=~0x40;
    3504:	2f 6b       	ori	r18, 0xBF	; 191
	if(dana&0x04) pomoc|=0x20;
    3506:	92 ff       	sbrs	r25, 2
    3508:	02 c0       	rjmp	.+4      	; 0x350e <odwroc+0x1e>
    350a:	20 62       	ori	r18, 0x20	; 32
    350c:	01 c0       	rjmp	.+2      	; 0x3510 <odwroc+0x20>
	else pomoc&=~0x20;
    350e:	2f 7d       	andi	r18, 0xDF	; 223
	if(dana&0x08) pomoc|=0x10;
    3510:	93 ff       	sbrs	r25, 3
    3512:	02 c0       	rjmp	.+4      	; 0x3518 <odwroc+0x28>
    3514:	20 61       	ori	r18, 0x10	; 16
    3516:	01 c0       	rjmp	.+2      	; 0x351a <odwroc+0x2a>
	else pomoc&=~0x10;
    3518:	2f 7e       	andi	r18, 0xEF	; 239
	if(dana&0x10) pomoc|=0x08;
    351a:	94 ff       	sbrs	r25, 4
    351c:	02 c0       	rjmp	.+4      	; 0x3522 <odwroc+0x32>
    351e:	28 60       	ori	r18, 0x08	; 8
    3520:	01 c0       	rjmp	.+2      	; 0x3524 <odwroc+0x34>
	else pomoc&=~0x08;
    3522:	27 7f       	andi	r18, 0xF7	; 247
	if(dana&0x20) pomoc|=0x04;
    3524:	95 ff       	sbrs	r25, 5
    3526:	02 c0       	rjmp	.+4      	; 0x352c <odwroc+0x3c>
    3528:	24 60       	ori	r18, 0x04	; 4
    352a:	01 c0       	rjmp	.+2      	; 0x352e <odwroc+0x3e>
	else pomoc&=~0x04;
    352c:	2b 7f       	andi	r18, 0xFB	; 251
	if(dana&0x40) pomoc|=0x02;
    352e:	96 ff       	sbrs	r25, 6
    3530:	03 c0       	rjmp	.+6      	; 0x3538 <odwroc+0x48>
    3532:	92 2f       	mov	r25, r18
    3534:	92 60       	ori	r25, 0x02	; 2
    3536:	02 c0       	rjmp	.+4      	; 0x353c <odwroc+0x4c>
	else pomoc&=~0x02;
    3538:	92 2f       	mov	r25, r18
    353a:	9d 7f       	andi	r25, 0xFD	; 253
	if(dana&0x80) pomoc|=0x01;
    353c:	87 ff       	sbrs	r24, 7
    353e:	03 c0       	rjmp	.+6      	; 0x3546 <odwroc+0x56>
    3540:	89 2f       	mov	r24, r25
    3542:	81 60       	ori	r24, 0x01	; 1
    3544:	08 95       	ret
	else pomoc&=~0x01;
    3546:	89 2f       	mov	r24, r25
    3548:	8e 7f       	andi	r24, 0xFE	; 254

	return pomoc;	
}
    354a:	08 95       	ret

0000354c <polbajt>:
void polbajt(unsigned char data)
{
  if(data&0x01)
    354c:	80 ff       	sbrs	r24, 0
    354e:	04 c0       	rjmp	.+8      	; 0x3558 <polbajt+0xc>
  {
	  PORTB.OUT|=LCD_D4;
    3550:	20 91 24 06 	lds	r18, 0x0624
    3554:	20 62       	ori	r18, 0x20	; 32
    3556:	03 c0       	rjmp	.+6      	; 0x355e <polbajt+0x12>
  }
  else
  {
	  PORTB.OUT&=~LCD_D4;
    3558:	20 91 24 06 	lds	r18, 0x0624
    355c:	2f 7d       	andi	r18, 0xDF	; 223
    355e:	e0 e2       	ldi	r30, 0x20	; 32
    3560:	f6 e0       	ldi	r31, 0x06	; 6
    3562:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x02)
    3564:	81 ff       	sbrs	r24, 1
    3566:	04 c0       	rjmp	.+8      	; 0x3570 <polbajt+0x24>
  {
	  PORTB.OUT|=LCD_D5;
    3568:	20 91 24 06 	lds	r18, 0x0624
    356c:	20 61       	ori	r18, 0x10	; 16
    356e:	03 c0       	rjmp	.+6      	; 0x3576 <polbajt+0x2a>
  }
  else
  {
	  PORTB.OUT&=~LCD_D5;
    3570:	20 91 24 06 	lds	r18, 0x0624
    3574:	2f 7e       	andi	r18, 0xEF	; 239
    3576:	e0 e2       	ldi	r30, 0x20	; 32
    3578:	f6 e0       	ldi	r31, 0x06	; 6
    357a:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x04)
    357c:	82 ff       	sbrs	r24, 2
    357e:	04 c0       	rjmp	.+8      	; 0x3588 <polbajt+0x3c>
  {
	  PORTB.OUT|=LCD_D6;
    3580:	20 91 24 06 	lds	r18, 0x0624
    3584:	28 60       	ori	r18, 0x08	; 8
    3586:	03 c0       	rjmp	.+6      	; 0x358e <polbajt+0x42>
  }
  else
  {
	  PORTB.OUT&=~LCD_D6;
    3588:	20 91 24 06 	lds	r18, 0x0624
    358c:	27 7f       	andi	r18, 0xF7	; 247
    358e:	e0 e2       	ldi	r30, 0x20	; 32
    3590:	f6 e0       	ldi	r31, 0x06	; 6
    3592:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x08)
    3594:	83 ff       	sbrs	r24, 3
    3596:	04 c0       	rjmp	.+8      	; 0x35a0 <polbajt+0x54>
  {
	  PORTB.OUT|=LCD_D7;
    3598:	80 91 24 06 	lds	r24, 0x0624
    359c:	84 60       	ori	r24, 0x04	; 4
    359e:	03 c0       	rjmp	.+6      	; 0x35a6 <polbajt+0x5a>
  }
  else
  {
	  PORTB.OUT&=~LCD_D7;
    35a0:	80 91 24 06 	lds	r24, 0x0624
    35a4:	8b 7f       	andi	r24, 0xFB	; 251
    35a6:	e0 e2       	ldi	r30, 0x20	; 32
    35a8:	f6 e0       	ldi	r31, 0x06	; 6
    35aa:	84 83       	std	Z+4, r24	; 0x04
    35ac:	08 95       	ret

000035ae <lcdWrite>:
{
LCD_RS_clear;
lcdWrite(command);
}
void lcdWrite(unsigned char data)
{
    35ae:	0f 93       	push	r16
    35b0:	1f 93       	push	r17
    35b2:	cf 93       	push	r28
    35b4:	df 93       	push	r29
    35b6:	18 2f       	mov	r17, r24
uint8_t pomoc=odwroc(data>>4);
    35b8:	82 95       	swap	r24
    35ba:	8f 70       	andi	r24, 0x0F	; 15
    35bc:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <odwroc>
    35c0:	08 2f       	mov	r16, r24
data=odwroc(data);
    35c2:	81 2f       	mov	r24, r17
    35c4:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <odwroc>
    35c8:	18 2f       	mov	r17, r24
LCD_E_set;
    35ca:	c0 e0       	ldi	r28, 0x00	; 0
    35cc:	d6 e0       	ldi	r29, 0x06	; 6
    35ce:	8c 81       	ldd	r24, Y+4	; 0x04
    35d0:	83 60       	ori	r24, 0x03	; 3
    35d2:	8c 83       	std	Y+4, r24	; 0x04
polbajt(pomoc);
    35d4:	80 2f       	mov	r24, r16
    35d6:	0e 94 a6 1a 	call	0x354c	; 0x354c <polbajt>
LCD_E_clear;
    35da:	8c 81       	ldd	r24, Y+4	; 0x04
    35dc:	8d 7f       	andi	r24, 0xFD	; 253
    35de:	8c 83       	std	Y+4, r24	; 0x04
LCD_E_set;
    35e0:	8c 81       	ldd	r24, Y+4	; 0x04
    35e2:	83 60       	ori	r24, 0x03	; 3
    35e4:	8c 83       	std	Y+4, r24	; 0x04
polbajt(data);
    35e6:	81 2f       	mov	r24, r17
    35e8:	0e 94 a6 1a 	call	0x354c	; 0x354c <polbajt>
LCD_E_clear;
    35ec:	8c 81       	ldd	r24, Y+4	; 0x04
    35ee:	8d 7f       	andi	r24, 0xFD	; 253
    35f0:	8c 83       	std	Y+4, r24	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    35f2:	87 ec       	ldi	r24, 0xC7	; 199
    35f4:	90 e0       	ldi	r25, 0x00	; 0
    35f6:	01 97       	sbiw	r24, 0x01	; 1
    35f8:	f1 f7       	brne	.-4      	; 0x35f6 <lcdWrite+0x48>
    35fa:	00 c0       	rjmp	.+0      	; 0x35fc <lcdWrite+0x4e>
    35fc:	00 00       	nop
_delay_us(50);
}
    35fe:	df 91       	pop	r29
    3600:	cf 91       	pop	r28
    3602:	1f 91       	pop	r17
    3604:	0f 91       	pop	r16
    3606:	08 95       	ret

00003608 <lcdwritecommand>:
	  PORTB.OUT&=~LCD_D7;
  }
}
void lcdwritecommand(unsigned char command)
{
LCD_RS_clear;
    3608:	e0 e0       	ldi	r30, 0x00	; 0
    360a:	f6 e0       	ldi	r31, 0x06	; 6
    360c:	94 81       	ldd	r25, Z+4	; 0x04
    360e:	9b 7f       	andi	r25, 0xFB	; 251
    3610:	94 83       	std	Z+4, r25	; 0x04
lcdWrite(command);
    3612:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <lcdWrite>
}
    3616:	08 95       	ret

00003618 <lcdsend>:
LCD_E_clear;
_delay_us(50);
}
void lcdsend(unsigned char data)
{
LCD_RS_set;
    3618:	e0 e0       	ldi	r30, 0x00	; 0
    361a:	f6 e0       	ldi	r31, 0x06	; 6
    361c:	94 81       	ldd	r25, Z+4	; 0x04
    361e:	94 60       	ori	r25, 0x04	; 4
    3620:	94 83       	std	Z+4, r25	; 0x04
lcdWrite(data);
    3622:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <lcdWrite>
}
    3626:	08 95       	ret

00003628 <lcdclear>:
void lcdclear(void)
{
lcdwritecommand(0x01);
    3628:	81 e0       	ldi	r24, 0x01	; 1
    362a:	0e 94 04 1b 	call	0x3608	; 0x3608 <lcdwritecommand>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    362e:	8f e3       	ldi	r24, 0x3F	; 63
    3630:	9f e1       	ldi	r25, 0x1F	; 31
    3632:	01 97       	sbiw	r24, 0x01	; 1
    3634:	f1 f7       	brne	.-4      	; 0x3632 <lcdclear+0xa>
    3636:	00 c0       	rjmp	.+0      	; 0x3638 <lcdclear+0x10>
    3638:	00 00       	nop
_delay_ms(2);
}
    363a:	08 95       	ret

0000363c <lcdinit>:
void lcdinit(void)
{// PB5 D4, PB2 D7
    363c:	cf 93       	push	r28
    363e:	df 93       	push	r29

	PORTB.DIR|=(PIN5_bm|PIN4_bm|PIN3_bm|PIN2_bm);
    3640:	80 91 20 06 	lds	r24, 0x0620
    3644:	8c 63       	ori	r24, 0x3C	; 60
    3646:	80 93 20 06 	sts	0x0620, r24
	PORTA.DIR|=(PIN1_bm|PIN2_bm);
    364a:	e0 e0       	ldi	r30, 0x00	; 0
    364c:	f6 e0       	ldi	r31, 0x06	; 6
    364e:	80 91 00 06 	lds	r24, 0x0600
    3652:	86 60       	ori	r24, 0x06	; 6
    3654:	80 93 00 06 	sts	0x0600, r24
	LCD_E_set;
    3658:	80 91 04 06 	lds	r24, 0x0604
    365c:	83 60       	ori	r24, 0x03	; 3
    365e:	84 83       	std	Z+4, r24	; 0x04
	LCD_RS_set;
    3660:	80 91 04 06 	lds	r24, 0x0604
    3664:	84 60       	ori	r24, 0x04	; 4
    3666:	84 83       	std	Z+4, r24	; 0x04
    3668:	8f e5       	ldi	r24, 0x5F	; 95
    366a:	9a ee       	ldi	r25, 0xEA	; 234
    366c:	01 97       	sbiw	r24, 0x01	; 1
    366e:	f1 f7       	brne	.-4      	; 0x366c <lcdinit+0x30>
    3670:	00 c0       	rjmp	.+0      	; 0x3672 <lcdinit+0x36>
    3672:	00 00       	nop
	_delay_ms(15);
	LCD_RS_clear;
    3674:	80 91 04 06 	lds	r24, 0x0604
    3678:	8b 7f       	andi	r24, 0xFB	; 251
    367a:	84 83       	std	Z+4, r24	; 0x04
	LCD_E_clear;
    367c:	80 91 04 06 	lds	r24, 0x0604
    3680:	8d 7f       	andi	r24, 0xFD	; 253
    3682:	84 83       	std	Z+4, r24	; 0x04
    3684:	83 e0       	ldi	r24, 0x03	; 3
    3686:	90 e0       	ldi	r25, 0x00	; 0
	for(int i = 0; i < 3; i++) 
	{
	   LCD_E_set;
	   PORTB.OUT&=0xF3;
    3688:	40 e2       	ldi	r20, 0x20	; 32
    368a:	56 e0       	ldi	r21, 0x06	; 6
	_delay_ms(15);
	LCD_RS_clear;
	LCD_E_clear;
	for(int i = 0; i < 3; i++) 
	{
	   LCD_E_set;
    368c:	c0 e0       	ldi	r28, 0x00	; 0
    368e:	d6 e0       	ldi	r29, 0x06	; 6
    3690:	20 91 04 06 	lds	r18, 0x0604
    3694:	23 60       	ori	r18, 0x03	; 3
    3696:	24 83       	std	Z+4, r18	; 0x04
	   PORTB.OUT&=0xF3;
    3698:	20 91 24 06 	lds	r18, 0x0624
    369c:	23 7f       	andi	r18, 0xF3	; 243
    369e:	da 01       	movw	r26, r20
    36a0:	14 96       	adiw	r26, 0x04	; 4
    36a2:	2c 93       	st	X, r18
    36a4:	14 97       	sbiw	r26, 0x04	; 4
	   LCD_E_clear;	
    36a6:	20 91 04 06 	lds	r18, 0x0604
    36aa:	2d 7f       	andi	r18, 0xFD	; 253
    36ac:	24 83       	std	Z+4, r18	; 0x04
    36ae:	af e1       	ldi	r26, 0x1F	; 31
    36b0:	be e4       	ldi	r27, 0x4E	; 78
    36b2:	11 97       	sbiw	r26, 0x01	; 1
    36b4:	f1 f7       	brne	.-4      	; 0x36b2 <lcdinit+0x76>
    36b6:	00 c0       	rjmp	.+0      	; 0x36b8 <lcdinit+0x7c>
    36b8:	00 00       	nop
    36ba:	01 97       	sbiw	r24, 0x01	; 1
	LCD_E_set;
	LCD_RS_set;
	_delay_ms(15);
	LCD_RS_clear;
	LCD_E_clear;
	for(int i = 0; i < 3; i++) 
    36bc:	39 f7       	brne	.-50     	; 0x368c <lcdinit+0x50>
	   LCD_E_set;
	   PORTB.OUT&=0xF3;
	   LCD_E_clear;	
	   _delay_ms(5); // czekaj 5ms
	}
	LCD_E_set;
    36be:	80 91 04 06 	lds	r24, 0x0604
    36c2:	83 60       	ori	r24, 0x03	; 3
    36c4:	8c 83       	std	Y+4, r24	; 0x04
	polbajt(0x02); //tryb 4 bitowy
    36c6:	82 e0       	ldi	r24, 0x02	; 2
    36c8:	0e 94 a6 1a 	call	0x354c	; 0x354c <polbajt>
	LCD_E_clear;
    36cc:	80 91 04 06 	lds	r24, 0x0604
    36d0:	8d 7f       	andi	r24, 0xFD	; 253
    36d2:	8c 83       	std	Y+4, r24	; 0x04
    36d4:	8f e9       	ldi	r24, 0x9F	; 159
    36d6:	9f e0       	ldi	r25, 0x0F	; 15
    36d8:	01 97       	sbiw	r24, 0x01	; 1
    36da:	f1 f7       	brne	.-4      	; 0x36d8 <lcdinit+0x9c>
    36dc:	00 c0       	rjmp	.+0      	; 0x36de <lcdinit+0xa2>
    36de:	00 00       	nop
	_delay_ms(1); // czekaj 1ms 
	lcdwritecommand(0x20|0|8|0);
    36e0:	88 e2       	ldi	r24, 0x28	; 40
    36e2:	0e 94 04 1b 	call	0x3608	; 0x3608 <lcdwritecommand>
	lcdwritecommand(0x80|0);
    36e6:	80 e8       	ldi	r24, 0x80	; 128
    36e8:	0e 94 04 1b 	call	0x3608	; 0x3608 <lcdwritecommand>
	lcdwritecommand(0x01);
    36ec:	81 e0       	ldi	r24, 0x01	; 1
    36ee:	0e 94 04 1b 	call	0x3608	; 0x3608 <lcdwritecommand>
    36f2:	af e3       	ldi	r26, 0x3F	; 63
    36f4:	bf e1       	ldi	r27, 0x1F	; 31
    36f6:	11 97       	sbiw	r26, 0x01	; 1
    36f8:	f1 f7       	brne	.-4      	; 0x36f6 <lcdinit+0xba>
    36fa:	00 c0       	rjmp	.+0      	; 0x36fc <lcdinit+0xc0>
    36fc:	00 00       	nop
	_delay_ms(2); // czekaj 2ms 
	lcdwritecommand(0x04|0|2);
    36fe:	86 e0       	ldi	r24, 0x06	; 6
    3700:	0e 94 04 1b 	call	0x3608	; 0x3608 <lcdwritecommand>
	lcdwritecommand(0x08|4|2|1);	
    3704:	8f e0       	ldi	r24, 0x0F	; 15
    3706:	0e 94 04 1b 	call	0x3608	; 0x3608 <lcdwritecommand>
}
    370a:	df 91       	pop	r29
    370c:	cf 91       	pop	r28
    370e:	08 95       	ret

00003710 <spiInit>:
#include "semphr.h"


void spiInit(void (*disableAllSpiDevicesFun)(void))
{
  disableAllSpiDevicesFun();
    3710:	fc 01       	movw	r30, r24
    3712:	19 95       	eicall
  portENTER_CRITICAL();
    3714:	0f b6       	in	r0, 0x3f	; 63
    3716:	f8 94       	cli
    3718:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    371a:	81 e0       	ldi	r24, 0x01	; 1
    371c:	60 e0       	ldi	r22, 0x00	; 0
    371e:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    3722:	80 93 20 32 	sts	0x3220, r24
    3726:	90 93 21 32 	sts	0x3221, r25
    372a:	00 97       	sbiw	r24, 0x00	; 0
    372c:	39 f0       	breq	.+14     	; 0x373c <spiInit+0x2c>
    372e:	60 e0       	ldi	r22, 0x00	; 0
    3730:	70 e0       	ldi	r23, 0x00	; 0
    3732:	40 e0       	ldi	r20, 0x00	; 0
    3734:	50 e0       	ldi	r21, 0x00	; 0
    3736:	20 e0       	ldi	r18, 0x00	; 0
    3738:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>

  //SPCR  = (1<<SPE)|(1<<MSTR)|(1<<SPIE);  //TODO Adam: użyć odpowiednich nazw rejestrów
  //SPSR |= (1<<SPI2X);
  SPID.CTRL=(1<<SPI_ENABLE_bp)|(1<<SPI_MASTER_bp);
    373c:	80 e5       	ldi	r24, 0x50	; 80
    373e:	80 93 c0 09 	sts	0x09C0, r24
  SPID.INTCTRL|=(1<<SPI_INTLVL1_bp);//0x01;
    3742:	80 91 c1 09 	lds	r24, 0x09C1
    3746:	82 60       	ori	r24, 0x02	; 2
    3748:	e0 ec       	ldi	r30, 0xC0	; 192
    374a:	f9 e0       	ldi	r31, 0x09	; 9
    374c:	81 83       	std	Z+1, r24	; 0x01
  SPID.CTRL|=(1<<SPI_CLK2X_bp);
    374e:	80 91 c0 09 	lds	r24, 0x09C0
    3752:	80 68       	ori	r24, 0x80	; 128
    3754:	80 93 c0 09 	sts	0x09C0, r24
  portEXIT_CRITICAL();
    3758:	0f 90       	pop	r0
    375a:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    375c:	08 95       	ret

0000375e <spiInitENC>:
void spiInitENC(void (*disableAllSpiDevicesFun)(void)) // PORTC
{
  disableAllSpiDevicesFun();
    375e:	fc 01       	movw	r30, r24
    3760:	19 95       	eicall
  portENTER_CRITICAL();
    3762:	0f b6       	in	r0, 0x3f	; 63
    3764:	f8 94       	cli
    3766:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    3768:	81 e0       	ldi	r24, 0x01	; 1
    376a:	60 e0       	ldi	r22, 0x00	; 0
    376c:	0e 94 b5 4c 	call	0x996a	; 0x996a <xQueueCreate>
    3770:	80 93 20 32 	sts	0x3220, r24
    3774:	90 93 21 32 	sts	0x3221, r25
    3778:	00 97       	sbiw	r24, 0x00	; 0
    377a:	39 f0       	breq	.+14     	; 0x378a <spiInitENC+0x2c>
    377c:	60 e0       	ldi	r22, 0x00	; 0
    377e:	70 e0       	ldi	r23, 0x00	; 0
    3780:	40 e0       	ldi	r20, 0x00	; 0
    3782:	50 e0       	ldi	r21, 0x00	; 0
    3784:	20 e0       	ldi	r18, 0x00	; 0
    3786:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>

  //SPCR  = (1<<SPE)|(1<<MSTR)|(1<<SPIE);  //TODO Adam: użyć odpowiednich nazw rejestrów
  //SPSR |= (1<<SPI2X);
  SPIC.CTRL=(1<<SPI_ENABLE_bp)|(1<<SPI_MASTER_bp);
    378a:	80 e5       	ldi	r24, 0x50	; 80
    378c:	80 93 c0 08 	sts	0x08C0, r24
  SPIC.INTCTRL|=(1<<SPI_INTLVL1_bp);//0x01;
    3790:	80 91 c1 08 	lds	r24, 0x08C1
    3794:	82 60       	ori	r24, 0x02	; 2
    3796:	e0 ec       	ldi	r30, 0xC0	; 192
    3798:	f8 e0       	ldi	r31, 0x08	; 8
    379a:	81 83       	std	Z+1, r24	; 0x01
  SPIC.CTRL|=(1<<SPI_CLK2X_bp);
    379c:	80 91 c0 08 	lds	r24, 0x08C0
    37a0:	80 68       	ori	r24, 0x80	; 128
    37a2:	80 93 c0 08 	sts	0x08C0, r24
  portEXIT_CRITICAL();
    37a6:	0f 90       	pop	r0
    37a8:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    37aa:	08 95       	ret

000037ac <spiSetCPHA>:

void spiSetCPHA(void)
{
  //SPCR |= (1<<CPHA);
  SPID.CTRL|=(1<<SPI_MODE_gp);
    37ac:	e0 ec       	ldi	r30, 0xC0	; 192
    37ae:	f9 e0       	ldi	r31, 0x09	; 9
    37b0:	80 81       	ld	r24, Z
    37b2:	84 60       	ori	r24, 0x04	; 4
    37b4:	80 83       	st	Z, r24
}
    37b6:	08 95       	ret

000037b8 <spiSetCPHAENC>:
void spiSetCPHAENC(void)
{
  //SPCR |= (1<<CPHA);
  SPIC.CTRL|=(1<<SPI_MODE_gp);
    37b8:	e0 ec       	ldi	r30, 0xC0	; 192
    37ba:	f8 e0       	ldi	r31, 0x08	; 8
    37bc:	80 81       	ld	r24, Z
    37be:	84 60       	ori	r24, 0x04	; 4
    37c0:	80 83       	st	Z, r24
}
    37c2:	08 95       	ret

000037c4 <spiClearCPHA>:

void spiClearCPHA(void)
{
  //SPCR &= ~(1<<CPHA);
  SPID.CTRL&=~(1<<SPI_MODE_gp);
    37c4:	e0 ec       	ldi	r30, 0xC0	; 192
    37c6:	f9 e0       	ldi	r31, 0x09	; 9
    37c8:	80 81       	ld	r24, Z
    37ca:	8b 7f       	andi	r24, 0xFB	; 251
    37cc:	80 83       	st	Z, r24
}
    37ce:	08 95       	ret

000037d0 <spiClearCPHAENC>:
void spiClearCPHAENC(void)
{
  //SPCR &= ~(1<<CPHA);
  SPIC.CTRL&=~(1<<SPI_MODE_gp);
    37d0:	e0 ec       	ldi	r30, 0xC0	; 192
    37d2:	f8 e0       	ldi	r31, 0x08	; 8
    37d4:	80 81       	ld	r24, Z
    37d6:	8b 7f       	andi	r24, 0xFB	; 251
    37d8:	80 83       	st	Z, r24
}
    37da:	08 95       	ret

000037dc <spiSetCPOL>:


void spiSetCPOL(void)
{
  //SPCR |= (1<<CPOL);
  SPID.CTRL|=(1<<SPI_MODE1_bp);
    37dc:	e0 ec       	ldi	r30, 0xC0	; 192
    37de:	f9 e0       	ldi	r31, 0x09	; 9
    37e0:	80 81       	ld	r24, Z
    37e2:	88 60       	ori	r24, 0x08	; 8
    37e4:	80 83       	st	Z, r24
}
    37e6:	08 95       	ret

000037e8 <spiSetCPOLENC>:
void spiSetCPOLENC(void)
{
  //SPCR |= (1<<CPOL);
  SPIC.CTRL|=(1<<SPI_MODE1_bp);
    37e8:	e0 ec       	ldi	r30, 0xC0	; 192
    37ea:	f8 e0       	ldi	r31, 0x08	; 8
    37ec:	80 81       	ld	r24, Z
    37ee:	88 60       	ori	r24, 0x08	; 8
    37f0:	80 83       	st	Z, r24
}
    37f2:	08 95       	ret

000037f4 <spiClearCPOL>:

void spiClearCPOL(void)
{
  //SPCR &= ~(1<<CPOL);
   SPID.CTRL&=~(1<<SPI_MODE1_bp);
    37f4:	e0 ec       	ldi	r30, 0xC0	; 192
    37f6:	f9 e0       	ldi	r31, 0x09	; 9
    37f8:	80 81       	ld	r24, Z
    37fa:	87 7f       	andi	r24, 0xF7	; 247
    37fc:	80 83       	st	Z, r24
}
    37fe:	08 95       	ret

00003800 <spiClearCPOLENC>:
void spiClearCPOLENC(void)
{
  //SPCR &= ~(1<<CPOL);
   SPID.CTRL&=~(1<<SPI_MODE1_bp);
    3800:	e0 ec       	ldi	r30, 0xC0	; 192
    3802:	f9 e0       	ldi	r31, 0x09	; 9
    3804:	80 81       	ld	r24, Z
    3806:	87 7f       	andi	r24, 0xF7	; 247
    3808:	80 83       	st	Z, r24
}
    380a:	08 95       	ret

0000380c <spiTake>:

void spiTake(void)
{
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
    380c:	80 91 20 32 	lds	r24, 0x3220
    3810:	90 91 21 32 	lds	r25, 0x3221
    3814:	60 e0       	ldi	r22, 0x00	; 0
    3816:	70 e0       	ldi	r23, 0x00	; 0
    3818:	4f ef       	ldi	r20, 0xFF	; 255
    381a:	5f ef       	ldi	r21, 0xFF	; 255
    381c:	20 e0       	ldi	r18, 0x00	; 0
    381e:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
}
    3822:	08 95       	ret

00003824 <spiGive>:

void spiGive(void)
{
  xSemaphoreGive(xSemaphoreSpiSS);
    3824:	80 91 20 32 	lds	r24, 0x3220
    3828:	90 91 21 32 	lds	r25, 0x3221
    382c:	60 e0       	ldi	r22, 0x00	; 0
    382e:	70 e0       	ldi	r23, 0x00	; 0
    3830:	40 e0       	ldi	r20, 0x00	; 0
    3832:	50 e0       	ldi	r21, 0x00	; 0
    3834:	20 e0       	ldi	r18, 0x00	; 0
    3836:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>
}
    383a:	08 95       	ret
    383c:	80 e0       	ldi	r24, 0x00	; 0
    383e:	08 95       	ret
    3840:	80 e0       	ldi	r24, 0x00	; 0
    3842:	08 95       	ret

00003844 <xmalloc>:
#include "hardwareConfig.h"

char *heapEnd = HEAP_BEGIN;

void *xmalloc(size_t size)
{
    3844:	cf 93       	push	r28
    3846:	df 93       	push	r29
    3848:	ec 01       	movw	r28, r24
  void *result = malloc(size);
    384a:	0e 94 35 54 	call	0xa86a	; 0xa86a <malloc>
  
  heapEnd = (char *)(result);
  heapEnd += size;
    384e:	c8 0f       	add	r28, r24
    3850:	d9 1f       	adc	r29, r25
    3852:	c0 93 b3 24 	sts	0x24B3, r28
    3856:	d0 93 b4 24 	sts	0x24B4, r29
  
  return result;
}
    385a:	df 91       	pop	r29
    385c:	cf 91       	pop	r28
    385e:	08 95       	ret

00003860 <xmallocAvailable>:

size_t xmallocAvailable(void)
{
  return __malloc_heap_end - heapEnd + 1;
    3860:	20 91 44 25 	lds	r18, 0x2544
    3864:	30 91 45 25 	lds	r19, 0x2545
    3868:	2f 5f       	subi	r18, 0xFF	; 255
    386a:	3f 4f       	sbci	r19, 0xFF	; 255
    386c:	80 91 b3 24 	lds	r24, 0x24B3
    3870:	90 91 b4 24 	lds	r25, 0x24B4
    3874:	28 1b       	sub	r18, r24
    3876:	39 0b       	sbc	r19, r25
    3878:	c9 01       	movw	r24, r18
    387a:	08 95       	ret

0000387c <uaktualnijRozmiarPliku>:

  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
    387c:	fc 01       	movw	r30, r24
  if (fd->wpis->rozmiarHi == fd->IndHi)
    387e:	a4 81       	ldd	r26, Z+4	; 0x04
    3880:	b5 81       	ldd	r27, Z+5	; 0x05
    3882:	12 96       	adiw	r26, 0x02	; 2
    3884:	9c 91       	ld	r25, X
    3886:	12 97       	sbiw	r26, 0x02	; 2
    3888:	83 81       	ldd	r24, Z+3	; 0x03
    388a:	98 17       	cp	r25, r24
    388c:	41 f4       	brne	.+16     	; 0x389e <uaktualnijRozmiarPliku+0x22>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    388e:	82 81       	ldd	r24, Z+2	; 0x02
    3890:	11 96       	adiw	r26, 0x01	; 1
    3892:	9c 91       	ld	r25, X
    3894:	11 97       	sbiw	r26, 0x01	; 1
    3896:	98 17       	cp	r25, r24
    3898:	10 f4       	brcc	.+4      	; 0x389e <uaktualnijRozmiarPliku+0x22>
      fd->wpis->rozmiarLo = fd->IndLo;
    389a:	11 96       	adiw	r26, 0x01	; 1
    389c:	8c 93       	st	X, r24
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    389e:	a4 81       	ldd	r26, Z+4	; 0x04
    38a0:	b5 81       	ldd	r27, Z+5	; 0x05
    38a2:	12 96       	adiw	r26, 0x02	; 2
    38a4:	9c 91       	ld	r25, X
    38a6:	12 97       	sbiw	r26, 0x02	; 2
    38a8:	83 81       	ldd	r24, Z+3	; 0x03
    38aa:	98 17       	cp	r25, r24
    38ac:	48 f4       	brcc	.+18     	; 0x38c0 <uaktualnijRozmiarPliku+0x44>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    38ae:	82 81       	ldd	r24, Z+2	; 0x02
    38b0:	11 96       	adiw	r26, 0x01	; 1
    38b2:	8c 93       	st	X, r24
      fd->wpis->rozmiarHi = fd->IndHi;    
    38b4:	a4 81       	ldd	r26, Z+4	; 0x04
    38b6:	b5 81       	ldd	r27, Z+5	; 0x05
    38b8:	83 81       	ldd	r24, Z+3	; 0x03
    38ba:	12 96       	adiw	r26, 0x02	; 2
    38bc:	8c 93       	st	X, r24
    38be:	12 97       	sbiw	r26, 0x02	; 2
    38c0:	08 95       	ret

000038c2 <czyscKlaster>:
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    38c2:	e0 e0       	ldi	r30, 0x00	; 0
    38c4:	f8 2f       	mov	r31, r24
    38c6:	f0 58       	subi	r31, 0x80	; 128
    38c8:	80 e0       	ldi	r24, 0x00	; 0
    38ca:	91 e0       	ldi	r25, 0x01	; 1
    38cc:	df 01       	movw	r26, r30
    38ce:	9c 01       	movw	r18, r24
    38d0:	1d 92       	st	X+, r1
    38d2:	21 50       	subi	r18, 0x01	; 1
    38d4:	30 40       	sbci	r19, 0x00	; 0
    38d6:	e1 f7       	brne	.-8      	; 0x38d0 <czyscKlaster+0xe>
}
    38d8:	08 95       	ret

000038da <znajdzWolnyKlaster>:
      fd->wpis->rozmiarHi = fd->IndHi;    
  }
}

static uint8_t znajdzWolnyKlaster(void)
{
    38da:	1f 93       	push	r17
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    38dc:	11 e0       	ldi	r17, 0x01	; 1
  {                                        //Może być rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    38de:	e1 2f       	mov	r30, r17
    38e0:	f0 e0       	ldi	r31, 0x00	; 0
    38e2:	e5 5d       	subi	r30, 0xD5	; 213
    38e4:	fd 4c       	sbci	r31, 0xCD	; 205
    38e6:	80 81       	ld	r24, Z
    38e8:	88 23       	and	r24, r24
    38ea:	29 f4       	brne	.+10     	; 0x38f6 <znajdzWolnyKlaster+0x1c>
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
    38ec:	10 83       	st	Z, r17
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
    38ee:	81 2f       	mov	r24, r17
    38f0:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <czyscKlaster>
      return i;
    38f4:	04 c0       	rjmp	.+8      	; 0x38fe <znajdzWolnyKlaster+0x24>
}

static uint8_t znajdzWolnyKlaster(void)
{
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    38f6:	1f 5f       	subi	r17, 0xFF	; 255
    38f8:	10 38       	cpi	r17, 0x80	; 128
    38fa:	89 f7       	brne	.-30     	; 0x38de <znajdzWolnyKlaster+0x4>
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
      return i;
    }
  }
  return 0;
    38fc:	10 e0       	ldi	r17, 0x00	; 0
}
    38fe:	81 2f       	mov	r24, r17
    3900:	1f 91       	pop	r17
    3902:	08 95       	ret

00003904 <nastepnyKlaster>:

static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
    3904:	1f 93       	push	r17
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
    3906:	28 2f       	mov	r18, r24
    3908:	30 e0       	ldi	r19, 0x00	; 0
    390a:	f9 01       	movw	r30, r18
    390c:	e5 5d       	subi	r30, 0xD5	; 213
    390e:	fd 4c       	sbci	r31, 0xCD	; 205
    3910:	10 81       	ld	r17, Z
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
    3912:	18 17       	cp	r17, r24
    3914:	b9 f4       	brne	.+46     	; 0x3944 <nastepnyKlaster+0x40>
    3916:	11 e0       	ldi	r17, 0x01	; 1
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma wolnego klastra
      if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, że jest on pusty
    3918:	e1 2f       	mov	r30, r17
    391a:	f0 e0       	ldi	r31, 0x00	; 0
    391c:	e5 5d       	subi	r30, 0xD5	; 213
    391e:	fd 4c       	sbci	r31, 0xCD	; 205
    3920:	80 81       	ld	r24, Z
    3922:	88 23       	and	r24, r24
    3924:	19 f0       	breq	.+6      	; 0x392c <nastepnyKlaster+0x28>
static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    3926:	1f 5f       	subi	r17, 0xFF	; 255
    3928:	10 38       	cpi	r17, 0x80	; 128
    392a:	b1 f7       	brne	.-20     	; 0x3918 <nastepnyKlaster+0x14>
        break;                             //Wtedy można przerwać szukanie kolejnych klastrów dla klastra
    }                                      //Taka implementacja z założenia powoduje defragmentację.
    
    if (temp != 0)                         //Znaleziono jakiś wolny klaster
    {
      klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku kolejnego klastra
    392c:	25 5d       	subi	r18, 0xD5	; 213
    392e:	3d 4c       	sbci	r19, 0xCD	; 205
    3930:	f9 01       	movw	r30, r18
    3932:	10 83       	st	Z, r17
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
    3934:	e1 2f       	mov	r30, r17
    3936:	f0 e0       	ldi	r31, 0x00	; 0
    3938:	e5 5d       	subi	r30, 0xD5	; 213
    393a:	fd 4c       	sbci	r31, 0xCD	; 205
    393c:	10 83       	st	Z, r17
      czyscKlaster(temp);                  //Czyszczenie klastra
    393e:	81 2f       	mov	r24, r17
    3940:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <czyscKlaster>
    }
  }
  return temp;
}
    3944:	81 2f       	mov	r24, r17
    3946:	1f 91       	pop	r17
    3948:	08 95       	ret

0000394a <znajdzKlasterN>:

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
    394a:	1f 93       	push	r17
    394c:	df 93       	push	r29
    394e:	cf 93       	push	r28
    3950:	0f 92       	push	r0
    3952:	cd b7       	in	r28, 0x3d	; 61
    3954:	de b7       	in	r29, 0x3e	; 62
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3956:	10 e0       	ldi	r17, 0x00	; 0
    3958:	07 c0       	rjmp	.+14     	; 0x3968 <znajdzKlasterN+0x1e>
  {
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    395a:	69 83       	std	Y+1, r22	; 0x01
    395c:	0e 94 82 1c 	call	0x3904	; 0x3904 <nastepnyKlaster>
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
    3960:	69 81       	ldd	r22, Y+1	; 0x01
    3962:	88 23       	and	r24, r24
    3964:	19 f0       	breq	.+6      	; 0x396c <znajdzKlasterN+0x22>

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3966:	1f 5f       	subi	r17, 0xFF	; 255
    3968:	16 17       	cp	r17, r22
    396a:	b8 f3       	brcs	.-18     	; 0x395a <znajdzKlasterN+0x10>
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
      break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany na początek tablicy plików
  }
  return wynik;
}
    396c:	0f 90       	pop	r0
    396e:	cf 91       	pop	r28
    3970:	df 91       	pop	r29
    3972:	1f 91       	pop	r17
    3974:	08 95       	ret

00003976 <znajdzPlik>:
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
{
    3976:	8f 92       	push	r8
    3978:	9f 92       	push	r9
    397a:	af 92       	push	r10
    397c:	bf 92       	push	r11
    397e:	df 92       	push	r13
    3980:	ef 92       	push	r14
    3982:	ff 92       	push	r15
    3984:	0f 93       	push	r16
    3986:	1f 93       	push	r17
    3988:	df 93       	push	r29
    398a:	cf 93       	push	r28
    398c:	0f 92       	push	r0
    398e:	cd b7       	in	r28, 0x3d	; 61
    3990:	de b7       	in	r29, 0x3e	; 62
    3992:	8c 01       	movw	r16, r24
  uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
    3994:	dc 01       	movw	r26, r24
    3996:	0d 90       	ld	r0, X+
    3998:	00 20       	and	r0, r0
    399a:	e9 f7       	brne	.-6      	; 0x3996 <znajdzPlik+0x20>
    399c:	9d 01       	movw	r18, r26
    399e:	21 50       	subi	r18, 0x01	; 1
    39a0:	30 40       	sbci	r19, 0x00	; 0
    39a2:	28 1b       	sub	r18, r24
    39a4:	29 30       	cpi	r18, 0x09	; 9
    39a6:	08 f0       	brcs	.+2      	; 0x39aa <znajdzPlik+0x34>
    39a8:	28 e0       	ldi	r18, 0x08	; 8
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  
  if (nazwa[dlNazwy-1] == 0)
    39aa:	f8 01       	movw	r30, r16
    39ac:	e2 0f       	add	r30, r18
    39ae:	f1 1d       	adc	r31, r1
    39b0:	31 97       	sbiw	r30, 0x01	; 1
    39b2:	80 81       	ld	r24, Z
    39b4:	88 23       	and	r24, r24
    39b6:	09 f4       	brne	.+2      	; 0x39ba <znajdzPlik+0x44>
    dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
    39b8:	21 50       	subi	r18, 0x01	; 1
  klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
    39ba:	f8 01       	movw	r30, r16
    39bc:	31 96       	adiw	r30, 0x01	; 1
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    39be:	81 e0       	ldi	r24, 0x01	; 1
    39c0:	04 c0       	rjmp	.+8      	; 0x39ca <znajdzPlik+0x54>
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    39c2:	91 91       	ld	r25, Z+
    39c4:	90 32       	cpi	r25, 0x20	; 32
    39c6:	31 f0       	breq	.+12     	; 0x39d4 <znajdzPlik+0x5e>
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    39c8:	8f 5f       	subi	r24, 0xFF	; 255
    39ca:	82 17       	cp	r24, r18
    39cc:	d0 f3       	brcs	.-12     	; 0x39c2 <znajdzPlik+0x4c>
    {
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    39ce:	22 23       	and	r18, r18
    39d0:	59 f1       	breq	.+86     	; 0x3a28 <znajdzPlik+0xb2>
    39d2:	01 c0       	rjmp	.+2      	; 0x39d6 <znajdzPlik+0x60>
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    39d4:	28 2f       	mov	r18, r24
    39d6:	dd 24       	eor	r13, r13
    39d8:	01 c0       	rjmp	.+2      	; 0x39dc <znajdzPlik+0x66>
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    39da:	d8 2e       	mov	r13, r24
  if (dlNazwy == 0)
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    39dc:	ed 2c       	mov	r14, r13
    39de:	ff 24       	eor	r15, r15
    39e0:	c7 01       	movw	r24, r14
    39e2:	80 58       	subi	r24, 0x80	; 128
    39e4:	9f 4f       	sbci	r25, 0xFF	; 255
    39e6:	98 2e       	mov	r9, r24
    39e8:	88 24       	eor	r8, r8
  klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
    39ea:	80 ef       	ldi	r24, 0xF0	; 240
    39ec:	a8 2e       	mov	r10, r24
    39ee:	b1 2c       	mov	r11, r1
    39f0:	a8 0c       	add	r10, r8
    39f2:	b9 1c       	adc	r11, r9
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    39f4:	b4 01       	movw	r22, r8
    39f6:	6c 5f       	subi	r22, 0xFC	; 252
    39f8:	7f 4f       	sbci	r23, 0xFF	; 255
    39fa:	c8 01       	movw	r24, r16
    39fc:	42 2f       	mov	r20, r18
    39fe:	50 e0       	ldi	r21, 0x00	; 0
    3a00:	29 83       	std	Y+1, r18	; 0x01
    3a02:	0e 94 e2 56 	call	0xadc4	; 0xadc4 <strncmp>
    3a06:	29 81       	ldd	r18, Y+1	; 0x01
    3a08:	00 97       	sbiw	r24, 0x00	; 0
    3a0a:	81 f0       	breq	.+32     	; 0x3a2c <znajdzPlik+0xb6>
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    3a0c:	8a 14       	cp	r8, r10
    3a0e:	9b 04       	cpc	r9, r11
    3a10:	29 f0       	breq	.+10     	; 0x3a1c <znajdzPlik+0xa6>
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    3a12:	e0 e1       	ldi	r30, 0x10	; 16
    3a14:	f0 e0       	ldi	r31, 0x00	; 0
    3a16:	8e 0e       	add	r8, r30
    3a18:	9f 1e       	adc	r9, r31
    3a1a:	ec cf       	rjmp	.-40     	; 0x39f4 <znajdzPlik+0x7e>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3a1c:	f7 01       	movw	r30, r14
    3a1e:	e5 5d       	subi	r30, 0xD5	; 213
    3a20:	fd 4c       	sbci	r31, 0xCD	; 205
    3a22:	80 81       	ld	r24, Z
  }
  while (tempKlaster2 != tempKlaster);
    3a24:	d8 16       	cp	r13, r24
    3a26:	c9 f6       	brne	.-78     	; 0x39da <znajdzPlik+0x64>
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    return NULL;
    3a28:	88 24       	eor	r8, r8
    3a2a:	99 24       	eor	r9, r9
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
  }
  while (tempKlaster2 != tempKlaster);
  return NULL;
}
    3a2c:	c4 01       	movw	r24, r8
    3a2e:	0f 90       	pop	r0
    3a30:	cf 91       	pop	r28
    3a32:	df 91       	pop	r29
    3a34:	1f 91       	pop	r17
    3a36:	0f 91       	pop	r16
    3a38:	ff 90       	pop	r15
    3a3a:	ef 90       	pop	r14
    3a3c:	df 90       	pop	r13
    3a3e:	bf 90       	pop	r11
    3a40:	af 90       	pop	r10
    3a42:	9f 90       	pop	r9
    3a44:	8f 90       	pop	r8
    3a46:	08 95       	ret

00003a48 <ramDyskInit>:
}


void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
    3a48:	80 e8       	ldi	r24, 0x80	; 128
    3a4a:	eb e2       	ldi	r30, 0x2B	; 43
    3a4c:	f2 e3       	ldi	r31, 0x32	; 50
    3a4e:	df 01       	movw	r26, r30
    3a50:	1d 92       	st	X+, r1
    3a52:	8a 95       	dec	r24
    3a54:	e9 f7       	brne	.-6      	; 0x3a50 <ramDyskInit+0x8>
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
    3a56:	80 e0       	ldi	r24, 0x00	; 0
    3a58:	91 e0       	ldi	r25, 0x01	; 1
    3a5a:	e0 e0       	ldi	r30, 0x00	; 0
    3a5c:	f0 e8       	ldi	r31, 0x80	; 128
    3a5e:	df 01       	movw	r26, r30
    3a60:	9c 01       	movw	r18, r24
    3a62:	1d 92       	st	X+, r1
    3a64:	21 50       	subi	r18, 0x01	; 1
    3a66:	30 40       	sbci	r19, 0x00	; 0
    3a68:	e1 f7       	brne	.-8      	; 0x3a62 <ramDyskInit+0x1a>
}
    3a6a:	08 95       	ret

00003a6c <ramDyskUtworzPlik>:
uint8_t ramDyskUtworzPlik(const char *nazwa)
{                                        //Nowo utworzony plik nie zajmuje żadnego klastra
    3a6c:	cf 92       	push	r12
    3a6e:	df 92       	push	r13
    3a70:	ef 92       	push	r14
    3a72:	ff 92       	push	r15
    3a74:	0f 93       	push	r16
    3a76:	1f 93       	push	r17
    3a78:	cf 93       	push	r28
    3a7a:	df 93       	push	r29
    3a7c:	f8 2e       	mov	r15, r24
    3a7e:	09 2f       	mov	r16, r25
  uint8_t dlNazwy = strlen(nazwa);
    3a80:	e8 2f       	mov	r30, r24
    3a82:	f9 2f       	mov	r31, r25
    3a84:	df 01       	movw	r26, r30
    3a86:	0d 90       	ld	r0, X+
    3a88:	00 20       	and	r0, r0
    3a8a:	e9 f7       	brne	.-6      	; 0x3a86 <ramDyskUtworzPlik+0x1a>
    3a8c:	11 97       	sbiw	r26, 0x01	; 1
    3a8e:	1a 2f       	mov	r17, r26
    3a90:	18 1b       	sub	r17, r24
    3a92:	19 30       	cpi	r17, 0x09	; 9
    3a94:	08 f0       	brcs	.+2      	; 0x3a98 <ramDyskUtworzPlik+0x2c>
    3a96:	18 e0       	ldi	r17, 0x08	; 8
    3a98:	2f 2d       	mov	r18, r15
    3a9a:	30 2f       	mov	r19, r16
    3a9c:	f9 01       	movw	r30, r18
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    3a9e:	80 e0       	ldi	r24, 0x00	; 0
    3aa0:	04 c0       	rjmp	.+8      	; 0x3aaa <ramDyskUtworzPlik+0x3e>
  {  if (nazwa[i] == ' ')
    3aa2:	91 91       	ld	r25, Z+
    3aa4:	90 32       	cpi	r25, 0x20	; 32
    3aa6:	21 f0       	breq	.+8      	; 0x3ab0 <ramDyskUtworzPlik+0x44>
  uint8_t dlNazwy = strlen(nazwa);
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    3aa8:	8f 5f       	subi	r24, 0xFF	; 255
    3aaa:	81 17       	cp	r24, r17
    3aac:	d0 f3       	brcs	.-12     	; 0x3aa2 <ramDyskUtworzPlik+0x36>
    3aae:	01 c0       	rjmp	.+2      	; 0x3ab2 <ramDyskUtworzPlik+0x46>
  {  if (nazwa[i] == ' ')
    3ab0:	18 2f       	mov	r17, r24
     {
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    3ab2:	11 23       	and	r17, r17
    3ab4:	09 f4       	brne	.+2      	; 0x3ab8 <ramDyskUtworzPlik+0x4c>
    3ab6:	47 c0       	rjmp	.+142    	; 0x3b46 <ramDyskUtworzPlik+0xda>
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    3ab8:	8f 2d       	mov	r24, r15
    3aba:	90 2f       	mov	r25, r16
    3abc:	0e 94 bb 1c 	call	0x3976	; 0x3976 <znajdzPlik>
    3ac0:	00 97       	sbiw	r24, 0x00	; 0
    3ac2:	09 f0       	breq	.+2      	; 0x3ac6 <ramDyskUtworzPlik+0x5a>
    3ac4:	40 c0       	rjmp	.+128    	; 0x3b46 <ramDyskUtworzPlik+0xda>
    3ac6:	ee 24       	eor	r14, r14
    3ac8:	01 c0       	rjmp	.+2      	; 0x3acc <ramDyskUtworzPlik+0x60>
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3aca:	e8 2e       	mov	r14, r24
  uint8_t temp;
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    3acc:	8e 2d       	mov	r24, r14
    3ace:	90 e0       	ldi	r25, 0x00	; 0
    3ad0:	ec 01       	movw	r28, r24
    3ad2:	c0 58       	subi	r28, 0x80	; 128
    3ad4:	df 4f       	sbci	r29, 0xFF	; 255
    3ad6:	dc 2f       	mov	r29, r28
    3ad8:	cc 27       	eor	r28, r28
void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
}
uint8_t ramDyskUtworzPlik(const char *nazwa)
    3ada:	9e 01       	movw	r18, r28
    3adc:	20 51       	subi	r18, 0x10	; 16
    3ade:	3f 4f       	sbci	r19, 0xFF	; 255
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (plik->nazwa[0] == 0)
    3ae0:	4c 81       	ldd	r20, Y+4	; 0x04
    3ae2:	44 23       	and	r20, r20
    3ae4:	d1 f0       	breq	.+52     	; 0x3b1a <ramDyskUtworzPlik+0xae>
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    3ae6:	c2 17       	cp	r28, r18
    3ae8:	d3 07       	cpc	r29, r19
    3aea:	11 f0       	breq	.+4      	; 0x3af0 <ramDyskUtworzPlik+0x84>
    {
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    3aec:	60 96       	adiw	r28, 0x10	; 16
    3aee:	f8 cf       	rjmp	.-16     	; 0x3ae0 <ramDyskUtworzPlik+0x74>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3af0:	85 5d       	subi	r24, 0xD5	; 213
    3af2:	9d 4c       	sbci	r25, 0xCD	; 205
    3af4:	dc 01       	movw	r26, r24
    3af6:	8c 91       	ld	r24, X
  }
  while (tempKlaster2 != tempKlaster);
    3af8:	e8 16       	cp	r14, r24
    3afa:	39 f7       	brne	.-50     	; 0x3aca <ramDyskUtworzPlik+0x5e>
  
  klastry[tempKlaster] = znajdzWolnyKlaster();
    3afc:	0e 94 6d 1c 	call	0x38da	; 0x38da <znajdzWolnyKlaster>
    3b00:	ee 2d       	mov	r30, r14
    3b02:	f0 e0       	ldi	r31, 0x00	; 0
    3b04:	e5 5d       	subi	r30, 0xD5	; 213
    3b06:	fd 4c       	sbci	r31, 0xCD	; 205
    3b08:	80 83       	st	Z, r24
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    3b0a:	88 23       	and	r24, r24
    3b0c:	f1 f0       	breq	.+60     	; 0x3b4a <ramDyskUtworzPlik+0xde>
    plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
    3b0e:	c8 2f       	mov	r28, r24
    3b10:	d0 e0       	ldi	r29, 0x00	; 0
    3b12:	c0 58       	subi	r28, 0x80	; 128
    3b14:	df 4f       	sbci	r29, 0xFF	; 255
    3b16:	dc 2f       	mov	r29, r28
    3b18:	cc 27       	eor	r28, r28
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
  }
  
  if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym pliku
    3b1a:	20 97       	sbiw	r28, 0x00	; 0
    3b1c:	b1 f0       	breq	.+44     	; 0x3b4a <ramDyskUtworzPlik+0xde>
  {
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    3b1e:	6e 01       	movw	r12, r28
    3b20:	ec 2f       	mov	r30, r28
    3b22:	fd 2d       	mov	r31, r13
    3b24:	8c e0       	ldi	r24, 0x0C	; 12
    3b26:	df 01       	movw	r26, r30
    3b28:	1d 92       	st	X+, r1
    3b2a:	8a 95       	dec	r24
    3b2c:	e9 f7       	brne	.-6      	; 0x3b28 <ramDyskUtworzPlik+0xbc>
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    3b2e:	ce 01       	movw	r24, r28
    3b30:	04 96       	adiw	r24, 0x04	; 4
    3b32:	6f 2d       	mov	r22, r15
    3b34:	70 2f       	mov	r23, r16
    3b36:	41 2f       	mov	r20, r17
    3b38:	50 e0       	ldi	r21, 0x00	; 0
    3b3a:	0e 94 f0 56 	call	0xade0	; 0xade0 <strncpy>
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    3b3e:	1c 86       	std	Y+12, r1	; 0x0c
    3b40:	1d 86       	std	Y+13, r1	; 0x0d
    3b42:	1e 86       	std	Y+14, r1	; 0x0e
    3b44:	1f 86       	std	Y+15, r1	; 0x0f
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
    3b46:	80 e0       	ldi	r24, 0x00	; 0
    3b48:	01 c0       	rjmp	.+2      	; 0x3b4c <ramDyskUtworzPlik+0xe0>
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    return 0;                            
  }
  return 1;
    3b4a:	81 e0       	ldi	r24, 0x01	; 1
}
    3b4c:	df 91       	pop	r29
    3b4e:	cf 91       	pop	r28
    3b50:	1f 91       	pop	r17
    3b52:	0f 91       	pop	r16
    3b54:	ff 90       	pop	r15
    3b56:	ef 90       	pop	r14
    3b58:	df 90       	pop	r13
    3b5a:	cf 90       	pop	r12
    3b5c:	08 95       	ret

00003b5e <ramDyskOtworzPlik>:

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
    3b5e:	ef 92       	push	r14
    3b60:	ff 92       	push	r15
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	eb 01       	movw	r28, r22
  uint8_t wynik = 1;
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    3b68:	0e 94 bb 1c 	call	0x3976	; 0x3976 <znajdzPlik>
    3b6c:	fc 01       	movw	r30, r24
    3b6e:	00 97       	sbiw	r24, 0x00	; 0
    3b70:	79 f0       	breq	.+30     	; 0x3b90 <ramDyskOtworzPlik+0x32>
  {
    memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
    3b72:	7e 01       	movw	r14, r28
    3b74:	2c 2f       	mov	r18, r28
    3b76:	3f 2d       	mov	r19, r15
    3b78:	83 e0       	ldi	r24, 0x03	; 3
    3b7a:	d9 01       	movw	r26, r18
    3b7c:	1d 92       	st	X+, r1
    3b7e:	8a 95       	dec	r24
    3b80:	e9 f7       	brne	.-6      	; 0x3b7c <ramDyskOtworzPlik+0x1e>
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    3b82:	ec 83       	std	Y+4, r30	; 0x04
    3b84:	fd 83       	std	Y+5, r31	; 0x05
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    3b86:	83 81       	ldd	r24, Z+3	; 0x03
    3b88:	8f 5f       	subi	r24, 0xFF	; 255
    3b8a:	83 83       	std	Z+3, r24	; 0x03
    wynik = 0;
    3b8c:	80 e0       	ldi	r24, 0x00	; 0
    3b8e:	01 c0       	rjmp	.+2      	; 0x3b92 <ramDyskOtworzPlik+0x34>
  return 1;
}

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
  uint8_t wynik = 1;
    3b90:	81 e0       	ldi	r24, 0x01	; 1
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    wynik = 0;
  }
  return wynik;
}
    3b92:	df 91       	pop	r29
    3b94:	cf 91       	pop	r28
    3b96:	ff 90       	pop	r15
    3b98:	ef 90       	pop	r14
    3b9a:	08 95       	ret

00003b9c <ramDyskUsunPlik>:

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    3b9c:	0e 94 bb 1c 	call	0x3976	; 0x3976 <znajdzPlik>
    3ba0:	fc 01       	movw	r30, r24
    3ba2:	00 97       	sbiw	r24, 0x00	; 0
    3ba4:	e1 f0       	breq	.+56     	; 0x3bde <ramDyskUsunPlik+0x42>
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    3ba6:	83 81       	ldd	r24, Z+3	; 0x03
    3ba8:	88 23       	and	r24, r24
    3baa:	81 f0       	breq	.+32     	; 0x3bcc <ramDyskUsunPlik+0x30>
    3bac:	1a c0       	rjmp	.+52     	; 0x3be2 <ramDyskUsunPlik+0x46>
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
  {
    usuwanyKlaster = plik->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3bae:	82 2f       	mov	r24, r18
    3bb0:	90 e0       	ldi	r25, 0x00	; 0
    3bb2:	dc 01       	movw	r26, r24
    3bb4:	a5 5d       	subi	r26, 0xD5	; 213
    3bb6:	bd 4c       	sbci	r27, 0xCD	; 205
    3bb8:	3c 91       	ld	r19, X
    3bba:	32 17       	cp	r19, r18
    3bbc:	11 f4       	brne	.+4      	; 0x3bc2 <ramDyskUsunPlik+0x26>
      plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3bbe:	10 82       	st	Z, r1
    3bc0:	01 c0       	rjmp	.+2      	; 0x3bc4 <ramDyskUsunPlik+0x28>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3bc2:	30 83       	st	Z, r19
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
    3bc4:	85 5d       	subi	r24, 0xD5	; 213
    3bc6:	9d 4c       	sbci	r25, 0xCD	; 205
    3bc8:	dc 01       	movw	r26, r24
    3bca:	1c 92       	st	X, r1
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3bcc:	20 81       	ld	r18, Z
    3bce:	22 23       	and	r18, r18
    3bd0:	71 f7       	brne	.-36     	; 0x3bae <ramDyskUsunPlik+0x12>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
    3bd2:	80 e1       	ldi	r24, 0x10	; 16
    3bd4:	11 92       	st	Z+, r1
    3bd6:	8a 95       	dec	r24
    3bd8:	e9 f7       	brne	.-6      	; 0x3bd4 <ramDyskUsunPlik+0x38>
//relokacjaTablicyWpisow()
  return 0;
    3bda:	80 e0       	ldi	r24, 0x00	; 0
    3bdc:	08 95       	ret

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    return 1;                                              //Nie znaleziono pliku
    3bde:	81 e0       	ldi	r24, 0x01	; 1
    3be0:	08 95       	ret
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
    3be2:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
//relokacjaTablicyWpisow()
  return 0;
}
    3be4:	08 95       	ret

00003be6 <ramDyskZamknijPlik>:

void ramDyskZamknijPlik(struct ramPlikFd *fd)
{
  if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest poprawny
    3be6:	dc 01       	movw	r26, r24
    3be8:	14 96       	adiw	r26, 0x04	; 4
    3bea:	ed 91       	ld	r30, X+
    3bec:	fc 91       	ld	r31, X
    3bee:	15 97       	sbiw	r26, 0x05	; 5
    3bf0:	23 81       	ldd	r18, Z+3	; 0x03
    3bf2:	22 23       	and	r18, r18
    3bf4:	31 f0       	breq	.+12     	; 0x3c02 <ramDyskZamknijPlik+0x1c>
  {
    fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
    3bf6:	21 50       	subi	r18, 0x01	; 1
    3bf8:	23 83       	std	Z+3, r18	; 0x03
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
    3bfa:	86 e0       	ldi	r24, 0x06	; 6
    3bfc:	1d 92       	st	X+, r1
    3bfe:	8a 95       	dec	r24
    3c00:	e9 f7       	brne	.-6      	; 0x3bfc <ramDyskZamknijPlik+0x16>
    3c02:	08 95       	ret

00003c04 <ramDyskCzyscPlik>:
  }
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
    3c04:	cf 93       	push	r28
    3c06:	df 93       	push	r29
    3c08:	fc 01       	movw	r30, r24
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3c0a:	0f c0       	rjmp	.+30     	; 0x3c2a <ramDyskCzyscPlik+0x26>
  {
    usuwanyKlaster = fd->wpis->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3c0c:	82 2f       	mov	r24, r18
    3c0e:	90 e0       	ldi	r25, 0x00	; 0
    3c10:	ec 01       	movw	r28, r24
    3c12:	c5 5d       	subi	r28, 0xD5	; 213
    3c14:	dd 4c       	sbci	r29, 0xCD	; 205
    3c16:	38 81       	ld	r19, Y
    3c18:	32 17       	cp	r19, r18
    3c1a:	11 f4       	brne	.+4      	; 0x3c20 <ramDyskCzyscPlik+0x1c>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3c1c:	1c 92       	st	X, r1
    3c1e:	01 c0       	rjmp	.+2      	; 0x3c22 <ramDyskCzyscPlik+0x1e>
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3c20:	3c 93       	st	X, r19
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
    3c22:	85 5d       	subi	r24, 0xD5	; 213
    3c24:	9d 4c       	sbci	r25, 0xCD	; 205
    3c26:	dc 01       	movw	r26, r24
    3c28:	1c 92       	st	X, r1
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3c2a:	a4 81       	ldd	r26, Z+4	; 0x04
    3c2c:	b5 81       	ldd	r27, Z+5	; 0x05
    3c2e:	2c 91       	ld	r18, X
    3c30:	22 23       	and	r18, r18
    3c32:	61 f7       	brne	.-40     	; 0x3c0c <ramDyskCzyscPlik+0x8>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
  }
  fd->wpis->rozmiarLo       = 0;
    3c34:	11 96       	adiw	r26, 0x01	; 1
    3c36:	1c 92       	st	X, r1
  fd->wpis->rozmiarHi       = 0;
    3c38:	a4 81       	ldd	r26, Z+4	; 0x04
    3c3a:	b5 81       	ldd	r27, Z+5	; 0x05
    3c3c:	12 96       	adiw	r26, 0x02	; 2
    3c3e:	1c 92       	st	X, r1
  fd->wpis->dataMod         = systemTime();
    3c40:	a4 81       	ldd	r26, Z+4	; 0x04
    3c42:	b5 81       	ldd	r27, Z+5	; 0x05
    3c44:	1c 96       	adiw	r26, 0x0c	; 12
    3c46:	1d 92       	st	X+, r1
    3c48:	1d 92       	st	X+, r1
    3c4a:	1d 92       	st	X+, r1
    3c4c:	1c 92       	st	X, r1
    3c4e:	1f 97       	sbiw	r26, 0x0f	; 15
  memset (fd, 0, 4);
    3c50:	10 82       	st	Z, r1
    3c52:	11 82       	std	Z+1, r1	; 0x01
    3c54:	12 82       	std	Z+2, r1	; 0x02
    3c56:	13 82       	std	Z+3, r1	; 0x03
  return 0;
}
    3c58:	80 e0       	ldi	r24, 0x00	; 0
    3c5a:	df 91       	pop	r29
    3c5c:	cf 91       	pop	r28
    3c5e:	08 95       	ret

00003c60 <ramDyskZapiszBajtDoPliku>:

uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
{
    3c60:	1f 93       	push	r17
    3c62:	cf 93       	push	r28
    3c64:	df 93       	push	r29
    3c66:	ec 01       	movw	r28, r24
    3c68:	16 2f       	mov	r17, r22
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
    3c6a:	ec 81       	ldd	r30, Y+4	; 0x04
    3c6c:	fd 81       	ldd	r31, Y+5	; 0x05
    3c6e:	80 81       	ld	r24, Z
    3c70:	88 23       	and	r24, r24
    3c72:	39 f4       	brne	.+14     	; 0x3c82 <ramDyskZapiszBajtDoPliku+0x22>
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
    3c74:	0e 94 6d 1c 	call	0x38da	; 0x38da <znajdzWolnyKlaster>
    3c78:	88 23       	and	r24, r24
    3c7a:	49 f1       	breq	.+82     	; 0x3cce <ramDyskZapiszBajtDoPliku+0x6e>
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    fd->wpis->pierwszyKlaster = tmpKlaster;
    3c7c:	ec 81       	ldd	r30, Y+4	; 0x04
    3c7e:	fd 81       	ldd	r31, Y+5	; 0x05
    3c80:	80 83       	st	Z, r24
  }
  if (fd->IndLo == 0)
    3c82:	8a 81       	ldd	r24, Y+2	; 0x02
    3c84:	88 23       	and	r24, r24
    3c86:	69 f4       	brne	.+26     	; 0x3ca2 <ramDyskZapiszBajtDoPliku+0x42>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    3c88:	ec 81       	ldd	r30, Y+4	; 0x04
    3c8a:	fd 81       	ldd	r31, Y+5	; 0x05
    3c8c:	80 81       	ld	r24, Z
    3c8e:	6b 81       	ldd	r22, Y+3	; 0x03
    3c90:	0e 94 a5 1c 	call	0x394a	; 0x394a <znajdzKlasterN>
    if (tmpKlaster == 0)
    3c94:	88 23       	and	r24, r24
    3c96:	e9 f0       	breq	.+58     	; 0x3cd2 <ramDyskZapiszBajtDoPliku+0x72>
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    }
    fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego klastra
    3c98:	90 e0       	ldi	r25, 0x00	; 0
    3c9a:	80 58       	subi	r24, 0x80	; 128
    3c9c:	9f 4f       	sbci	r25, 0xFF	; 255
    3c9e:	18 82       	st	Y, r1
    3ca0:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
    3ca2:	e8 81       	ld	r30, Y
    3ca4:	f9 81       	ldd	r31, Y+1	; 0x01
    3ca6:	10 83       	st	Z, r17

  fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
    3ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    3caa:	8f 5f       	subi	r24, 0xFF	; 255
    3cac:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, że czły klaster jest zapisany
    3cae:	88 23       	and	r24, r24
    3cb0:	21 f4       	brne	.+8      	; 0x3cba <ramDyskZapiszBajtDoPliku+0x5a>
    fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt indeksu. Nie utworzono nowego klastra, zatem nie uaktualniamy wskaźnika
    3cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb4:	8f 5f       	subi	r24, 0xFF	; 255
    3cb6:	8b 83       	std	Y+3, r24	; 0x03
    3cb8:	05 c0       	rjmp	.+10     	; 0x3cc4 <ramDyskZapiszBajtDoPliku+0x64>
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    3cba:	88 81       	ld	r24, Y
    3cbc:	99 81       	ldd	r25, Y+1	; 0x01
    3cbe:	01 96       	adiw	r24, 0x01	; 1
    3cc0:	88 83       	st	Y, r24
    3cc2:	99 83       	std	Y+1, r25	; 0x01
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
    3cc4:	ce 01       	movw	r24, r28
    3cc6:	0e 94 3e 1c 	call	0x387c	; 0x387c <uaktualnijRozmiarPliku>
  return 0;
    3cca:	80 e0       	ldi	r24, 0x00	; 0
    3ccc:	03 c0       	rjmp	.+6      	; 0x3cd4 <ramDyskZapiszBajtDoPliku+0x74>
{
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    3cce:	81 e0       	ldi	r24, 0x01	; 1
    3cd0:	01 c0       	rjmp	.+2      	; 0x3cd4 <ramDyskZapiszBajtDoPliku+0x74>
  if (fd->IndLo == 0)
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    if (tmpKlaster == 0)
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    3cd2:	82 e0       	ldi	r24, 0x02	; 2
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}
    3cd4:	df 91       	pop	r29
    3cd6:	cf 91       	pop	r28
    3cd8:	1f 91       	pop	r17
    3cda:	08 95       	ret

00003cdc <putSTD>:
    return wynik;
  return EOF;
}

static int putSTD(char c, FILE *stream)
{
    3cdc:	28 2f       	mov	r18, r24
    3cde:	fb 01       	movw	r30, r22
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
    3ce0:	84 85       	ldd	r24, Z+12	; 0x0c
    3ce2:	95 85       	ldd	r25, Z+13	; 0x0d
    3ce4:	62 2f       	mov	r22, r18
    3ce6:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <ramDyskZapiszBajtDoPliku>
}
    3cea:	90 e0       	ldi	r25, 0x00	; 0
    3cec:	08 95       	ret

00003cee <ramDyskCzytajBajtZPliku>:
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
    3cee:	0f 93       	push	r16
    3cf0:	1f 93       	push	r17
    3cf2:	cf 93       	push	r28
    3cf4:	df 93       	push	r29
    3cf6:	ec 01       	movw	r28, r24
    3cf8:	8b 01       	movw	r16, r22
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3cfa:	ec 81       	ldd	r30, Y+4	; 0x04
    3cfc:	fd 81       	ldd	r31, Y+5	; 0x05
    3cfe:	82 81       	ldd	r24, Z+2	; 0x02
    3d00:	6b 81       	ldd	r22, Y+3	; 0x03
    3d02:	68 17       	cp	r22, r24
    3d04:	30 f0       	brcs	.+12     	; 0x3d12 <ramDyskCzytajBajtZPliku+0x24>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3d06:	86 17       	cp	r24, r22
    3d08:	21 f5       	brne	.+72     	; 0x3d52 <ramDyskCzytajBajtZPliku+0x64>
    3d0a:	91 81       	ldd	r25, Z+1	; 0x01
    3d0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d0e:	98 17       	cp	r25, r24
    3d10:	00 f1       	brcs	.+64     	; 0x3d52 <ramDyskCzytajBajtZPliku+0x64>
uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof

  if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku nowego klastra
    3d12:	8a 81       	ldd	r24, Y+2	; 0x02
    3d14:	88 23       	and	r24, r24
    3d16:	41 f4       	brne	.+16     	; 0x3d28 <ramDyskCzytajBajtZPliku+0x3a>
  {
    uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    3d18:	80 81       	ld	r24, Z
    3d1a:	0e 94 a5 1c 	call	0x394a	; 0x394a <znajdzKlasterN>
    fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego klastra
    3d1e:	90 e0       	ldi	r25, 0x00	; 0
    3d20:	80 58       	subi	r24, 0x80	; 128
    3d22:	9f 4f       	sbci	r25, 0xFF	; 255
    3d24:	18 82       	st	Y, r1
    3d26:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *bajt = *(fd->Wsk);                                 //Odczyt z pliku
    3d28:	e8 81       	ld	r30, Y
    3d2a:	f9 81       	ldd	r31, Y+1	; 0x01
    3d2c:	80 81       	ld	r24, Z
    3d2e:	f8 01       	movw	r30, r16
    3d30:	80 83       	st	Z, r24
  fd->IndLo++;                                        //Zwiększenie indeksu o 1
    3d32:	8a 81       	ldd	r24, Y+2	; 0x02
    3d34:	8f 5f       	subi	r24, 0xFF	; 255
    3d36:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    3d38:	88 23       	and	r24, r24
    3d3a:	21 f4       	brne	.+8      	; 0x3d44 <ramDyskCzytajBajtZPliku+0x56>
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
    3d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d3e:	8f 5f       	subi	r24, 0xFF	; 255
    3d40:	8b 83       	std	Y+3, r24	; 0x03
    3d42:	05 c0       	rjmp	.+10     	; 0x3d4e <ramDyskCzytajBajtZPliku+0x60>
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
    3d44:	88 81       	ld	r24, Y
    3d46:	99 81       	ldd	r25, Y+1	; 0x01
    3d48:	01 96       	adiw	r24, 0x01	; 1
    3d4a:	88 83       	st	Y, r24
    3d4c:	99 83       	std	Y+1, r25	; 0x01
  return 0;
    3d4e:	80 e0       	ldi	r24, 0x00	; 0
    3d50:	01 c0       	rjmp	.+2      	; 0x3d54 <ramDyskCzytajBajtZPliku+0x66>
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof
    3d52:	81 e0       	ldi	r24, 0x01	; 1
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}
    3d54:	df 91       	pop	r29
    3d56:	cf 91       	pop	r28
    3d58:	1f 91       	pop	r17
    3d5a:	0f 91       	pop	r16
    3d5c:	08 95       	ret

00003d5e <getSTD>:
  return wynik;
}


static int getSTD(FILE *stream)
{
    3d5e:	df 93       	push	r29
    3d60:	cf 93       	push	r28
    3d62:	0f 92       	push	r0
    3d64:	cd b7       	in	r28, 0x3d	; 61
    3d66:	de b7       	in	r29, 0x3e	; 62
  uint8_t wynik;
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  
  if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
    3d68:	fc 01       	movw	r30, r24
    3d6a:	84 85       	ldd	r24, Z+12	; 0x0c
    3d6c:	95 85       	ldd	r25, Z+13	; 0x0d
    3d6e:	be 01       	movw	r22, r28
    3d70:	6f 5f       	subi	r22, 0xFF	; 255
    3d72:	7f 4f       	sbci	r23, 0xFF	; 255
    3d74:	0e 94 77 1e 	call	0x3cee	; 0x3cee <ramDyskCzytajBajtZPliku>
    3d78:	88 23       	and	r24, r24
    3d7a:	19 f4       	brne	.+6      	; 0x3d82 <getSTD+0x24>
    return wynik;
    3d7c:	29 81       	ldd	r18, Y+1	; 0x01
    3d7e:	30 e0       	ldi	r19, 0x00	; 0
    3d80:	02 c0       	rjmp	.+4      	; 0x3d86 <getSTD+0x28>
  return EOF;
    3d82:	2f ef       	ldi	r18, 0xFF	; 255
    3d84:	3f ef       	ldi	r19, 0xFF	; 255
}
    3d86:	c9 01       	movw	r24, r18
    3d88:	0f 90       	pop	r0
    3d8a:	cf 91       	pop	r28
    3d8c:	df 91       	pop	r29
    3d8e:	08 95       	ret

00003d90 <ramDyskZapiszBlokDoPliku>:
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}

uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3d90:	8f 92       	push	r8
    3d92:	9f 92       	push	r9
    3d94:	af 92       	push	r10
    3d96:	bf 92       	push	r11
    3d98:	df 92       	push	r13
    3d9a:	ef 92       	push	r14
    3d9c:	ff 92       	push	r15
    3d9e:	0f 93       	push	r16
    3da0:	1f 93       	push	r17
    3da2:	cf 93       	push	r28
    3da4:	df 93       	push	r29
    3da6:	ec 01       	movw	r28, r24
    3da8:	4b 01       	movw	r8, r22
    3daa:	5a 01       	movw	r10, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3dac:	0c 81       	ldd	r16, Y+4	; 0x04
    3dae:	1d 81       	ldd	r17, Y+5	; 0x05
    3db0:	f8 01       	movw	r30, r16
    3db2:	80 81       	ld	r24, Z
    3db4:	88 23       	and	r24, r24
    3db6:	21 f4       	brne	.+8      	; 0x3dc0 <ramDyskZapiszBlokDoPliku+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    3db8:	0e 94 6d 1c 	call	0x38da	; 0x38da <znajdzWolnyKlaster>
    3dbc:	f8 01       	movw	r30, r16
    3dbe:	80 83       	st	Z, r24
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
    3dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc2:	00 e0       	ldi	r16, 0x00	; 0
    3dc4:	11 e0       	ldi	r17, 0x01	; 1
    3dc6:	08 1b       	sub	r16, r24
    3dc8:	11 09       	sbc	r17, r1
  uint16_t doZapisu = *dlugosc;
    3dca:	f5 01       	movw	r30, r10
    3dcc:	e0 80       	ld	r14, Z
    3dce:	f1 80       	ldd	r15, Z+1	; 0x01
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
    3dd0:	10 82       	st	Z, r1
    3dd2:	11 82       	std	Z+1, r1	; 0x01
  uint8_t tmpKlaster = 0;
    3dd4:	dd 24       	eor	r13, r13
  while (doZapisu > 0)
    3dd6:	4e c0       	rjmp	.+156    	; 0x3e74 <ramDyskZapiszBlokDoPliku+0xe4>
  {
    if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to należy odczytać jego numer oraz ustawić na niego wskaźnik
    3dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dda:	88 23       	and	r24, r24
    3ddc:	a9 f4       	brne	.+42     	; 0x3e08 <ramDyskZapiszBlokDoPliku+0x78>
    {
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
    3dde:	dd 20       	and	r13, r13
    3de0:	39 f4       	brne	.+14     	; 0x3df0 <ramDyskZapiszBlokDoPliku+0x60>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
    3de2:	ec 81       	ldd	r30, Y+4	; 0x04
    3de4:	fd 81       	ldd	r31, Y+5	; 0x05
    3de6:	80 81       	ld	r24, Z
    3de8:	6b 81       	ldd	r22, Y+3	; 0x03
    3dea:	0e 94 a5 1c 	call	0x394a	; 0x394a <znajdzKlasterN>
    3dee:	03 c0       	rjmp	.+6      	; 0x3df6 <ramDyskZapiszBlokDoPliku+0x66>
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
    3df0:	8d 2d       	mov	r24, r13
    3df2:	0e 94 82 1c 	call	0x3904	; 0x3904 <nastepnyKlaster>
    3df6:	d8 2e       	mov	r13, r24
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
    3df8:	88 23       	and	r24, r24
    3dfa:	09 f4       	brne	.+2      	; 0x3dfe <ramDyskZapiszBlokDoPliku+0x6e>
    3dfc:	44 c0       	rjmp	.+136    	; 0x3e86 <ramDyskZapiszBlokDoPliku+0xf6>
        return 1;                                 //1 - Brak wolnego klastra

      fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Teraz można do niego już pisać
    3dfe:	90 e0       	ldi	r25, 0x00	; 0
    3e00:	80 58       	subi	r24, 0x80	; 128
    3e02:	9f 4f       	sbci	r25, 0xFF	; 255
    3e04:	18 82       	st	Y, r1
    3e06:	89 83       	std	Y+1, r24	; 0x01
    3e08:	88 81       	ld	r24, Y
    3e0a:	99 81       	ldd	r25, Y+1	; 0x01
    }
    if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w bieżącym klastrze
    3e0c:	0e 15       	cp	r16, r14
    3e0e:	1f 05       	cpc	r17, r15
    3e10:	b0 f4       	brcc	.+44     	; 0x3e3e <ramDyskZapiszBlokDoPliku+0xae>
    {                                             //Nie uda się, teraz zapiszemy cały klastr do końca
      memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
    3e12:	b4 01       	movw	r22, r8
    3e14:	a8 01       	movw	r20, r16
    3e16:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
      znaki +=dlBloku;                      
    3e1a:	80 0e       	add	r8, r16
    3e1c:	91 1e       	adc	r9, r17
      fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na początek nowego klastra. Kolejna iteracja go utworzy
    3e1e:	1a 82       	std	Y+2, r1	; 0x02
      doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka pozostałą do zapisujemy
    3e20:	e0 1a       	sub	r14, r16
    3e22:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych danych
    3e24:	f5 01       	movw	r30, r10
    3e26:	80 81       	ld	r24, Z
    3e28:	91 81       	ldd	r25, Z+1	; 0x01
    3e2a:	80 0f       	add	r24, r16
    3e2c:	91 1f       	adc	r25, r17
    3e2e:	80 83       	st	Z, r24
    3e30:	91 83       	std	Z+1, r25	; 0x01
      fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. Oznacza to przejście do kolejnego klastra
    3e32:	8b 81       	ldd	r24, Y+3	; 0x03
    3e34:	8f 5f       	subi	r24, 0xFF	; 255
    3e36:	8b 83       	std	Y+3, r24	; 0x03
      dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 bajtów
    3e38:	00 e0       	ldi	r16, 0x00	; 0
    3e3a:	11 e0       	ldi	r17, 0x01	; 1
    3e3c:	1b c0       	rjmp	.+54     	; 0x3e74 <ramDyskZapiszBlokDoPliku+0xe4>
    }
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
    3e3e:	b4 01       	movw	r22, r8
    3e40:	a7 01       	movw	r20, r14
    3e42:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
    3e46:	8a 81       	ldd	r24, Y+2	; 0x02
    3e48:	8e 0d       	add	r24, r14
    3e4a:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
    3e4c:	f5 01       	movw	r30, r10
    3e4e:	80 81       	ld	r24, Z
    3e50:	91 81       	ldd	r25, Z+1	; 0x01
    3e52:	8e 0d       	add	r24, r14
    3e54:	9f 1d       	adc	r25, r15
    3e56:	80 83       	st	Z, r24
    3e58:	91 83       	std	Z+1, r25	; 0x01
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    3e5a:	8d 2d       	mov	r24, r13
    3e5c:	90 e0       	ldi	r25, 0x00	; 0
    3e5e:	80 58       	subi	r24, 0x80	; 128
    3e60:	9f 4f       	sbci	r25, 0xFF	; 255
    3e62:	98 2f       	mov	r25, r24
    3e64:	88 27       	eor	r24, r24
    3e66:	2a 81       	ldd	r18, Y+2	; 0x02
    3e68:	82 0f       	add	r24, r18
    3e6a:	91 1d       	adc	r25, r1
    3e6c:	88 83       	st	Y, r24
    3e6e:	99 83       	std	Y+1, r25	; 0x01
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
    3e70:	ee 24       	eor	r14, r14
    3e72:	ff 24       	eor	r15, r15
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
  uint16_t doZapisu = *dlugosc;
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
    3e74:	e1 14       	cp	r14, r1
    3e76:	f1 04       	cpc	r15, r1
    3e78:	09 f0       	breq	.+2      	; 0x3e7c <ramDyskZapiszBlokDoPliku+0xec>
    3e7a:	ae cf       	rjmp	.-164    	; 0x3dd8 <ramDyskZapiszBlokDoPliku+0x48>
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
    3e7c:	ce 01       	movw	r24, r28
    3e7e:	0e 94 3e 1c 	call	0x387c	; 0x387c <uaktualnijRozmiarPliku>
  return 0;
    3e82:	80 e0       	ldi	r24, 0x00	; 0
    3e84:	01 c0       	rjmp	.+2      	; 0x3e88 <ramDyskZapiszBlokDoPliku+0xf8>
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
        return 1;                                 //1 - Brak wolnego klastra
    3e86:	81 e0       	ldi	r24, 0x01	; 1
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}
    3e88:	df 91       	pop	r29
    3e8a:	cf 91       	pop	r28
    3e8c:	1f 91       	pop	r17
    3e8e:	0f 91       	pop	r16
    3e90:	ff 90       	pop	r15
    3e92:	ef 90       	pop	r14
    3e94:	df 90       	pop	r13
    3e96:	bf 90       	pop	r11
    3e98:	af 90       	pop	r10
    3e9a:	9f 90       	pop	r9
    3e9c:	8f 90       	pop	r8
    3e9e:	08 95       	ret

00003ea0 <ramDyskCzytajBlokZPliku>:

uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3ea0:	8f 92       	push	r8
    3ea2:	9f 92       	push	r9
    3ea4:	bf 92       	push	r11
    3ea6:	cf 92       	push	r12
    3ea8:	df 92       	push	r13
    3eaa:	ef 92       	push	r14
    3eac:	ff 92       	push	r15
    3eae:	0f 93       	push	r16
    3eb0:	1f 93       	push	r17
    3eb2:	cf 93       	push	r28
    3eb4:	df 93       	push	r29
    3eb6:	ec 01       	movw	r28, r24
    3eb8:	4b 01       	movw	r8, r22
    3eba:	6a 01       	movw	r12, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3ebc:	ec 81       	ldd	r30, Y+4	; 0x04
    3ebe:	fd 81       	ldd	r31, Y+5	; 0x05
    3ec0:	80 81       	ld	r24, Z
    3ec2:	88 23       	and	r24, r24
    3ec4:	29 f4       	brne	.+10     	; 0x3ed0 <ramDyskCzytajBlokZPliku+0x30>
  {
    *dlugosc = 0;
    3ec6:	fa 01       	movw	r30, r20
    3ec8:	10 82       	st	Z, r1
    3eca:	11 82       	std	Z+1, r1	; 0x01
    return 1;                         //1 - Plik jest pusty
    3ecc:	81 e0       	ldi	r24, 0x01	; 1
    3ece:	78 c0       	rjmp	.+240    	; 0x3fc0 <ramDyskCzytajBlokZPliku+0x120>
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3ed0:	22 81       	ldd	r18, Z+2	; 0x02
    3ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed4:	82 17       	cp	r24, r18
    3ed6:	40 f0       	brcs	.+16     	; 0x3ee8 <ramDyskCzytajBlokZPliku+0x48>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3ed8:	28 17       	cp	r18, r24
    3eda:	09 f0       	breq	.+2      	; 0x3ede <ramDyskCzytajBlokZPliku+0x3e>
    3edc:	7d c0       	rjmp	.+250    	; 0x3fd8 <ramDyskCzytajBlokZPliku+0x138>
    3ede:	31 81       	ldd	r19, Z+1	; 0x01
    3ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee2:	39 17       	cp	r19, r25
    3ee4:	08 f4       	brcc	.+2      	; 0x3ee8 <ramDyskCzytajBlokZPliku+0x48>
    3ee6:	78 c0       	rjmp	.+240    	; 0x3fd8 <ramDyskCzytajBlokZPliku+0x138>
  {
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
    3ee8:	30 e0       	ldi	r19, 0x00	; 0
    3eea:	28 1b       	sub	r18, r24
    3eec:	31 09       	sbc	r19, r1
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3eee:	81 81       	ldd	r24, Z+1	; 0x01
    3ef0:	90 e0       	ldi	r25, 0x00	; 0
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
    3ef2:	4a 81       	ldd	r20, Y+2	; 0x02
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3ef4:	84 1b       	sub	r24, r20
    3ef6:	91 09       	sbc	r25, r1
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
    3ef8:	82 0f       	add	r24, r18
    3efa:	93 1f       	adc	r25, r19
  
  uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i określenie ile bajtów zdoła się odczytać
    3efc:	f6 01       	movw	r30, r12
    3efe:	00 81       	ld	r16, Z
    3f00:	11 81       	ldd	r17, Z+1	; 0x01
    3f02:	80 17       	cp	r24, r16
    3f04:	91 07       	cpc	r25, r17
    3f06:	08 f4       	brcc	.+2      	; 0x3f0a <ramDyskCzytajBlokZPliku+0x6a>
    3f08:	8c 01       	movw	r16, r24
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
    3f0a:	f6 01       	movw	r30, r12
    3f0c:	10 82       	st	Z, r1
    3f0e:	11 82       	std	Z+1, r1	; 0x01
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
    3f10:	8a 81       	ldd	r24, Y+2	; 0x02
    3f12:	e1 2c       	mov	r14, r1
    3f14:	e1 e0       	ldi	r30, 0x01	; 1
    3f16:	fe 2e       	mov	r15, r30
    3f18:	e8 1a       	sub	r14, r24
    3f1a:	f1 08       	sbc	r15, r1
  uint8_t tmpKlaster = 0;
    3f1c:	bb 24       	eor	r11, r11
  while (doOdczytania > 0)
    3f1e:	49 c0       	rjmp	.+146    	; 0x3fb2 <ramDyskCzytajBlokZPliku+0x112>
  {
    if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, że wskaźnik nie jest jeszcze ustawiony
    3f20:	8a 81       	ldd	r24, Y+2	; 0x02
    3f22:	88 23       	and	r24, r24
    3f24:	a1 f4       	brne	.+40     	; 0x3f4e <ramDyskCzytajBlokZPliku+0xae>
    {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (od początkowego) należy się przesunąć do przodu
      if (tmpKlaster == 0)
    3f26:	bb 20       	and	r11, r11
    3f28:	39 f4       	brne	.+14     	; 0x3f38 <ramDyskCzytajBlokZPliku+0x98>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
    3f2a:	ec 81       	ldd	r30, Y+4	; 0x04
    3f2c:	fd 81       	ldd	r31, Y+5	; 0x05
    3f2e:	80 81       	ld	r24, Z
    3f30:	6b 81       	ldd	r22, Y+3	; 0x03
    3f32:	0e 94 a5 1c 	call	0x394a	; 0x394a <znajdzKlasterN>
    3f36:	03 c0       	rjmp	.+6      	; 0x3f3e <ramDyskCzytajBlokZPliku+0x9e>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
    3f38:	8b 2d       	mov	r24, r11
    3f3a:	0e 94 82 1c 	call	0x3904	; 0x3904 <nastepnyKlaster>
    3f3e:	b8 2e       	mov	r11, r24
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
    3f40:	88 23       	and	r24, r24
    3f42:	e9 f1       	breq	.+122    	; 0x3fbe <ramDyskCzytajBlokZPliku+0x11e>
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
    3f44:	90 e0       	ldi	r25, 0x00	; 0
    3f46:	80 58       	subi	r24, 0x80	; 128
    3f48:	9f 4f       	sbci	r25, 0xFF	; 255
    3f4a:	18 82       	st	Y, r1
    3f4c:	89 83       	std	Y+1, r24	; 0x01
    3f4e:	68 81       	ld	r22, Y
    3f50:	79 81       	ldd	r23, Y+1	; 0x01
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    }
    
    if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
    3f52:	e0 16       	cp	r14, r16
    3f54:	f1 06       	cpc	r15, r17
    3f56:	b8 f4       	brcc	.+46     	; 0x3f86 <ramDyskCzytajBlokZPliku+0xe6>
    {                                  //dlBloku określa ile zostało jeszcze bajtów do końca klasrta
      memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
    3f58:	c4 01       	movw	r24, r8
    3f5a:	a7 01       	movw	r20, r14
    3f5c:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
      znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy odczytane bajty
    3f60:	8e 0c       	add	r8, r14
    3f62:	9f 1c       	adc	r9, r15
      fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
    3f64:	1a 82       	std	Y+2, r1	; 0x02
      fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz nie ma potrzeby ustawienia wskaźnika odczytu na jego początek
    3f66:	8b 81       	ldd	r24, Y+3	; 0x03
    3f68:	8f 5f       	subi	r24, 0xFF	; 255
    3f6a:	8b 83       	std	Y+3, r24	; 0x03
      doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
    3f6c:	0e 19       	sub	r16, r14
    3f6e:	1f 09       	sbc	r17, r15
      *dlugosc += dlBloku;             //Uaktualnienie 
    3f70:	f6 01       	movw	r30, r12
    3f72:	80 81       	ld	r24, Z
    3f74:	91 81       	ldd	r25, Z+1	; 0x01
    3f76:	8e 0d       	add	r24, r14
    3f78:	9f 1d       	adc	r25, r15
    3f7a:	80 83       	st	Z, r24
    3f7c:	91 83       	std	Z+1, r25	; 0x01
      dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całego klastra.
    3f7e:	e1 2c       	mov	r14, r1
    3f80:	71 e0       	ldi	r23, 0x01	; 1
    3f82:	f7 2e       	mov	r15, r23
    3f84:	16 c0       	rjmp	.+44     	; 0x3fb2 <ramDyskCzytajBlokZPliku+0x112>
    }
    else                               //Ostatnia operacja odczytu
    {
      memcpy(znaki, fd->Wsk, doOdczytania);
    3f86:	c4 01       	movw	r24, r8
    3f88:	a8 01       	movw	r20, r16
    3f8a:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
      fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym samym klastrze, zatem trzeba teraz uaktualnić wzkaźnik
    3f8e:	88 81       	ld	r24, Y
    3f90:	99 81       	ldd	r25, Y+1	; 0x01
    3f92:	80 0f       	add	r24, r16
    3f94:	91 1f       	adc	r25, r17
    3f96:	88 83       	st	Y, r24
    3f98:	99 83       	std	Y+1, r25	; 0x01
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
    3f9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f9c:	80 0f       	add	r24, r16
    3f9e:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
    3fa0:	f6 01       	movw	r30, r12
    3fa2:	80 81       	ld	r24, Z
    3fa4:	91 81       	ldd	r25, Z+1	; 0x01
    3fa6:	80 0f       	add	r24, r16
    3fa8:	91 1f       	adc	r25, r17
    3faa:	80 83       	st	Z, r24
    3fac:	91 83       	std	Z+1, r25	; 0x01
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    3fae:	00 e0       	ldi	r16, 0x00	; 0
    3fb0:	10 e0       	ldi	r17, 0x00	; 0
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
    3fb2:	01 15       	cp	r16, r1
    3fb4:	11 05       	cpc	r17, r1
    3fb6:	09 f0       	breq	.+2      	; 0x3fba <ramDyskCzytajBlokZPliku+0x11a>
    3fb8:	b3 cf       	rjmp	.-154    	; 0x3f20 <ramDyskCzytajBlokZPliku+0x80>
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
    3fba:	80 e0       	ldi	r24, 0x00	; 0
    3fbc:	01 c0       	rjmp	.+2      	; 0x3fc0 <ramDyskCzytajBlokZPliku+0x120>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    3fbe:	83 e0       	ldi	r24, 0x03	; 3
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
}
    3fc0:	df 91       	pop	r29
    3fc2:	cf 91       	pop	r28
    3fc4:	1f 91       	pop	r17
    3fc6:	0f 91       	pop	r16
    3fc8:	ff 90       	pop	r15
    3fca:	ef 90       	pop	r14
    3fcc:	df 90       	pop	r13
    3fce:	cf 90       	pop	r12
    3fd0:	bf 90       	pop	r11
    3fd2:	9f 90       	pop	r9
    3fd4:	8f 90       	pop	r8
    3fd6:	08 95       	ret
    *dlugosc = 0;
    return 1;                         //1 - Plik jest pusty
  }
  if (wObrebiePliku(fd) != 0)
  {
    *dlugosc = 0;
    3fd8:	f6 01       	movw	r30, r12
    3fda:	10 82       	st	Z, r1
    3fdc:	11 82       	std	Z+1, r1	; 0x01
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
    3fde:	82 e0       	ldi	r24, 0x02	; 2
    3fe0:	ef cf       	rjmp	.-34     	; 0x3fc0 <ramDyskCzytajBlokZPliku+0x120>

00003fe2 <ramDyskUstawWskaznik>:
  }
  return 0;
}

uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
{
    3fe2:	ef 92       	push	r14
    3fe4:	ff 92       	push	r15
    3fe6:	0f 93       	push	r16
    3fe8:	1f 93       	push	r17
    3fea:	cf 93       	push	r28
    3fec:	df 93       	push	r29
    3fee:	ec 01       	movw	r28, r24
  if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje na początek pliku.
    3ff0:	61 15       	cp	r22, r1
    3ff2:	71 05       	cpc	r23, r1
    3ff4:	19 f4       	brne	.+6      	; 0x3ffc <ramDyskUstawWskaznik+0x1a>
  {                                                       //Jeśli tak, to nie ma potzeby tworzenia klastrów. Plik może nadal nei mieć żadnego klastra.
    fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bardziej znaczącego bajtu)
    3ff6:	1a 82       	std	Y+2, r1	; 0x02
    fd->IndHi = 0;
    3ff8:	1b 82       	std	Y+3, r1	; 0x03
    3ffa:	2e c0       	rjmp	.+92     	; 0x4058 <__stack+0x59>
    return 0;
  }
  indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio ustawić rozmair pliku.
    3ffc:	8b 01       	movw	r16, r22
    3ffe:	01 50       	subi	r16, 0x01	; 1
    4000:	10 40       	sbci	r17, 0x00	; 0
                                                          //Jeśli indeks jest większy niż rozmiar pliku, to plik zostanie rozciągnięty do zadanej wartości indeksu -1
  
  if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydzielony pierwszy klaster
    4002:	ec 80       	ldd	r14, Y+4	; 0x04
    4004:	fd 80       	ldd	r15, Y+5	; 0x05
    4006:	f7 01       	movw	r30, r14
    4008:	80 81       	ld	r24, Z
    400a:	88 23       	and	r24, r24
    400c:	21 f4       	brne	.+8      	; 0x4016 <__stack+0x17>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pliku. Jest to konieczne, ponieważ klaster ma wartość niezerową
    400e:	0e 94 6d 1c 	call	0x38da	; 0x38da <znajdzWolnyKlaster>
    4012:	f7 01       	movw	r30, r14
    4014:	80 83       	st	Z, r24

  uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką należy dodać do pierwszego klastra`

  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
    4016:	0a 83       	std	Y+2, r16	; 0x02
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
    4018:	1b 83       	std	Y+3, r17	; 0x03
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
    401a:	ec 81       	ldd	r30, Y+4	; 0x04
    401c:	fd 81       	ldd	r31, Y+5	; 0x05
    401e:	80 81       	ld	r24, Z
    4020:	61 2f       	mov	r22, r17
    4022:	0e 94 a5 1c 	call	0x394a	; 0x394a <znajdzKlasterN>
    4026:	08 2f       	mov	r16, r24
  if (nrKlastra == 0)
    4028:	88 23       	and	r24, r24
    402a:	c1 f0       	breq	.+48     	; 0x405c <__stack+0x5d>
    return 1;                                             //Brak klastrów

  uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
    402c:	ce 01       	movw	r24, r28
    402e:	0e 94 3e 1c 	call	0x387c	; 0x387c <uaktualnijRozmiarPliku>

  fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
    4032:	2a 81       	ldd	r18, Y+2	; 0x02
    4034:	2f 5f       	subi	r18, 0xFF	; 255
    4036:	2a 83       	std	Y+2, r18	; 0x02
  if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, to jeszcze on nie iestnieje
    4038:	22 23       	and	r18, r18
    403a:	21 f4       	brne	.+8      	; 0x4044 <__stack+0x45>
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
    403c:	8b 81       	ldd	r24, Y+3	; 0x03
    403e:	8f 5f       	subi	r24, 0xFF	; 255
    4040:	8b 83       	std	Y+3, r24	; 0x03
    4042:	0a c0       	rjmp	.+20     	; 0x4058 <__stack+0x59>
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra
    4044:	80 2f       	mov	r24, r16
    4046:	90 e0       	ldi	r25, 0x00	; 0
    4048:	80 58       	subi	r24, 0x80	; 128
    404a:	9f 4f       	sbci	r25, 0xFF	; 255
    404c:	98 2f       	mov	r25, r24
    404e:	88 27       	eor	r24, r24
    4050:	82 0f       	add	r24, r18
    4052:	91 1d       	adc	r25, r1
    4054:	88 83       	st	Y, r24
    4056:	99 83       	std	Y+1, r25	; 0x01

  return 0; 
    4058:	80 e0       	ldi	r24, 0x00	; 0
    405a:	01 c0       	rjmp	.+2      	; 0x405e <__stack+0x5f>
  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
  if (nrKlastra == 0)
    return 1;                                             //Brak klastrów
    405c:	81 e0       	ldi	r24, 0x01	; 1
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra

  return 0; 
}
    405e:	df 91       	pop	r29
    4060:	cf 91       	pop	r28
    4062:	1f 91       	pop	r17
    4064:	0f 91       	pop	r16
    4066:	ff 90       	pop	r15
    4068:	ef 90       	pop	r14
    406a:	08 95       	ret

0000406c <ramDyskUstawWskaznikNaKoniec>:

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
    406c:	cf 93       	push	r28
    406e:	df 93       	push	r29
    4070:	ec 01       	movw	r28, r24
  if (fd == NULL)
    4072:	00 97       	sbiw	r24, 0x00	; 0
    4074:	b9 f0       	breq	.+46     	; 0x40a4 <ramDyskUstawWskaznikNaKoniec+0x38>
    return 1;
  fd->IndLo = fd->wpis->rozmiarLo;
    4076:	ec 81       	ldd	r30, Y+4	; 0x04
    4078:	fd 81       	ldd	r31, Y+5	; 0x05
    407a:	81 81       	ldd	r24, Z+1	; 0x01
    407c:	8a 83       	std	Y+2, r24	; 0x02
  fd->IndHi = fd->wpis->rozmiarHi;
    407e:	92 81       	ldd	r25, Z+2	; 0x02
    4080:	9b 83       	std	Y+3, r25	; 0x03
//  fd->IndLo++;
  uint8_t tmpKlaster = 0;
  if (fd->IndLo != 0)
    4082:	88 23       	and	r24, r24
    4084:	89 f0       	breq	.+34     	; 0x40a8 <ramDyskUstawWskaznikNaKoniec+0x3c>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    4086:	80 81       	ld	r24, Z
    4088:	62 81       	ldd	r22, Z+2	; 0x02
    408a:	0e 94 a5 1c 	call	0x394a	; 0x394a <znajdzKlasterN>
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
    408e:	90 e0       	ldi	r25, 0x00	; 0
    4090:	80 58       	subi	r24, 0x80	; 128
    4092:	9f 4f       	sbci	r25, 0xFF	; 255
    4094:	98 2f       	mov	r25, r24
    4096:	88 27       	eor	r24, r24
    4098:	2a 81       	ldd	r18, Y+2	; 0x02
    409a:	82 0f       	add	r24, r18
    409c:	91 1d       	adc	r25, r1
    409e:	88 83       	st	Y, r24
    40a0:	99 83       	std	Y+1, r25	; 0x01
    40a2:	02 c0       	rjmp	.+4      	; 0x40a8 <ramDyskUstawWskaznikNaKoniec+0x3c>
}

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
  if (fd == NULL)
    return 1;
    40a4:	81 e0       	ldi	r24, 0x01	; 1
    40a6:	01 c0       	rjmp	.+2      	; 0x40aa <ramDyskUstawWskaznikNaKoniec+0x3e>
  if (fd->IndLo != 0)
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
  }  
  return 0;
    40a8:	80 e0       	ldi	r24, 0x00	; 0
}
    40aa:	df 91       	pop	r29
    40ac:	cf 91       	pop	r28
    40ae:	08 95       	ret

000040b0 <ramDyskDodajBlokXmodem>:

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
    40b0:	bf 92       	push	r11
    40b2:	cf 92       	push	r12
    40b4:	df 92       	push	r13
    40b6:	ef 92       	push	r14
    40b8:	ff 92       	push	r15
    40ba:	0f 93       	push	r16
    40bc:	1f 93       	push	r17
    40be:	cf 93       	push	r28
    40c0:	df 93       	push	r29
    40c2:	8c 01       	movw	r16, r24
    40c4:	6b 01       	movw	r12, r22
  if (nrBloku == 0)
    40c6:	61 15       	cp	r22, r1
    40c8:	71 05       	cpc	r23, r1
    40ca:	09 f4       	brne	.+2      	; 0x40ce <ramDyskDodajBlokXmodem+0x1e>
    40cc:	4f c0       	rjmp	.+158    	; 0x416c <ramDyskDodajBlokXmodem+0xbc>
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
  uint8_t indLo = 0;
  uint8_t *wynik;
  
  if (fd->wpis->pierwszyKlaster == 0)
    40ce:	dc 01       	movw	r26, r24
    40d0:	14 96       	adiw	r26, 0x04	; 4
    40d2:	ed 90       	ld	r14, X+
    40d4:	fc 90       	ld	r15, X
    40d6:	15 97       	sbiw	r26, 0x05	; 5
    40d8:	f7 01       	movw	r30, r14
    40da:	80 81       	ld	r24, Z
    40dc:	88 23       	and	r24, r24
    40de:	21 f4       	brne	.+8      	; 0x40e8 <ramDyskDodajBlokXmodem+0x38>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    40e0:	0e 94 6d 1c 	call	0x38da	; 0x38da <znajdzWolnyKlaster>
    40e4:	d7 01       	movw	r26, r14
    40e6:	8c 93       	st	X, r24
  if (fd->wpis->pierwszyKlaster == 0)
    40e8:	d8 01       	movw	r26, r16
    40ea:	14 96       	adiw	r26, 0x04	; 4
    40ec:	ed 91       	ld	r30, X+
    40ee:	fc 91       	ld	r31, X
    40f0:	15 97       	sbiw	r26, 0x05	; 5
    40f2:	80 81       	ld	r24, Z
    40f4:	88 23       	and	r24, r24
    40f6:	d1 f1       	breq	.+116    	; 0x416c <ramDyskDodajBlokXmodem+0xbc>

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
  if (nrBloku == 0)
    return NULL;
  nrBloku --;
    40f8:	08 94       	sec
    40fa:	c1 08       	sbc	r12, r1
    40fc:	d1 08       	sbc	r13, r1
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
    40fe:	76 01       	movw	r14, r12
    4100:	f6 94       	lsr	r15
    4102:	e7 94       	ror	r14
    4104:	be 2c       	mov	r11, r14
  if (fd->wpis->pierwszyKlaster == 0)
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
    4106:	6e 2d       	mov	r22, r14
    4108:	0e 94 a5 1c 	call	0x394a	; 0x394a <znajdzKlasterN>
  if (tmpKlaster == 0)
    410c:	88 23       	and	r24, r24
    410e:	71 f1       	breq	.+92     	; 0x416c <ramDyskDodajBlokXmodem+0xbc>
    4110:	d8 01       	movw	r26, r16
    4112:	14 96       	adiw	r26, 0x04	; 4
    4114:	ed 91       	ld	r30, X+
    4116:	fc 91       	ld	r31, X
    4118:	15 97       	sbiw	r26, 0x05	; 5
    return NULL;
  if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
    411a:	c0 fe       	sbrs	r12, 0
    411c:	0f c0       	rjmp	.+30     	; 0x413c <ramDyskDodajBlokXmodem+0x8c>
  {
    indLo = 128;
    if (fd->wpis->rozmiarHi <= indHi)
    411e:	92 81       	ldd	r25, Z+2	; 0x02
    4120:	e9 16       	cp	r14, r25
    4122:	38 f0       	brcs	.+14     	; 0x4132 <ramDyskDodajBlokXmodem+0x82>
    {
      fd->wpis->rozmiarHi = indHi+1;
    4124:	b3 94       	inc	r11
    4126:	b2 82       	std	Z+2, r11	; 0x02
      fd->wpis->rozmiarLo = 0;
    4128:	14 96       	adiw	r26, 0x04	; 4
    412a:	ed 91       	ld	r30, X+
    412c:	fc 91       	ld	r31, X
    412e:	15 97       	sbiw	r26, 0x05	; 5
    4130:	11 82       	std	Z+1, r1	; 0x01
    }
    wynik=dataPtr(tmpKlaster, 128);
    4132:	80 e0       	ldi	r24, 0x00	; 0
    4134:	ec 01       	movw	r28, r24
    4136:	c0 58       	subi	r28, 0x80	; 128
    4138:	df 47       	sbci	r29, 0x7F	; 127
    413a:	1a c0       	rjmp	.+52     	; 0x4170 <ramDyskDodajBlokXmodem+0xc0>
  }
  else
  {
    if (fd->wpis->rozmiarHi < indHi)
    413c:	92 81       	ldd	r25, Z+2	; 0x02
    413e:	9e 15       	cp	r25, r14
    4140:	38 f4       	brcc	.+14     	; 0x4150 <ramDyskDodajBlokXmodem+0xa0>
    {
      fd->wpis->rozmiarHi = indHi;
    4142:	e2 82       	std	Z+2, r14	; 0x02
      fd->wpis->rozmiarLo = 128;
    4144:	d8 01       	movw	r26, r16
    4146:	14 96       	adiw	r26, 0x04	; 4
    4148:	ed 91       	ld	r30, X+
    414a:	fc 91       	ld	r31, X
    414c:	15 97       	sbiw	r26, 0x05	; 5
    414e:	05 c0       	rjmp	.+10     	; 0x415a <ramDyskDodajBlokXmodem+0xaa>
    }
    else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
    4150:	9e 15       	cp	r25, r14
    4152:	29 f4       	brne	.+10     	; 0x415e <ramDyskDodajBlokXmodem+0xae>
    4154:	91 81       	ldd	r25, Z+1	; 0x01
    4156:	97 fd       	sbrc	r25, 7
    4158:	02 c0       	rjmp	.+4      	; 0x415e <ramDyskDodajBlokXmodem+0xae>
      fd->wpis->rozmiarLo = 128;
    415a:	90 e8       	ldi	r25, 0x80	; 128
    415c:	91 83       	std	Z+1, r25	; 0x01
    
    wynik=dataPtr(tmpKlaster, 0);
    415e:	c8 2f       	mov	r28, r24
    4160:	d0 e0       	ldi	r29, 0x00	; 0
    4162:	c0 58       	subi	r28, 0x80	; 128
    4164:	df 4f       	sbci	r29, 0xFF	; 255
    4166:	dc 2f       	mov	r29, r28
    4168:	cc 27       	eor	r28, r28
    416a:	02 c0       	rjmp	.+4      	; 0x4170 <ramDyskDodajBlokXmodem+0xc0>
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
  if (tmpKlaster == 0)
    return NULL;
    416c:	c0 e0       	ldi	r28, 0x00	; 0
    416e:	d0 e0       	ldi	r29, 0x00	; 0
      fd->wpis->rozmiarLo = 128;
    
    wynik=dataPtr(tmpKlaster, 0);
  }
  return wynik;
}
    4170:	ce 01       	movw	r24, r28
    4172:	df 91       	pop	r29
    4174:	cf 91       	pop	r28
    4176:	1f 91       	pop	r17
    4178:	0f 91       	pop	r16
    417a:	ff 90       	pop	r15
    417c:	ef 90       	pop	r14
    417e:	df 90       	pop	r13
    4180:	cf 90       	pop	r12
    4182:	bf 90       	pop	r11
    4184:	08 95       	ret

00004186 <ramDyskDir>:

void ramDyskDir(FILE *ostream)
{
    4186:	2f 92       	push	r2
    4188:	3f 92       	push	r3
    418a:	4f 92       	push	r4
    418c:	5f 92       	push	r5
    418e:	6f 92       	push	r6
    4190:	7f 92       	push	r7
    4192:	9f 92       	push	r9
    4194:	af 92       	push	r10
    4196:	bf 92       	push	r11
    4198:	cf 92       	push	r12
    419a:	df 92       	push	r13
    419c:	ef 92       	push	r14
    419e:	ff 92       	push	r15
    41a0:	0f 93       	push	r16
    41a2:	1f 93       	push	r17
    41a4:	cf 93       	push	r28
    41a6:	df 93       	push	r29
    41a8:	8c 01       	movw	r16, r24
  fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
    41aa:	85 eb       	ldi	r24, 0xB5	; 181
    41ac:	94 e2       	ldi	r25, 0x24	; 36
    41ae:	b8 01       	movw	r22, r16
    41b0:	0e 94 c2 57 	call	0xaf84	; 0xaf84 <fputs>
  struct ramPlik *plik;
  uint8_t tmpKlaster = 0;
    41b4:	aa 24       	eor	r10, r10
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    41b6:	4e ec       	ldi	r20, 0xCE	; 206
    41b8:	24 2e       	mov	r2, r20
    41ba:	44 e2       	ldi	r20, 0x24	; 36
    41bc:	34 2e       	mov	r3, r20
    41be:	01 c0       	rjmp	.+2      	; 0x41c2 <ramDyskDir+0x3c>
      plik++;
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    41c0:	a8 2e       	mov	r10, r24
  uint8_t tmpKlaster = 0;
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    41c2:	ca 2c       	mov	r12, r10
    41c4:	dd 24       	eor	r13, r13
    41c6:	e6 01       	movw	r28, r12
    41c8:	c0 58       	subi	r28, 0x80	; 128
    41ca:	df 4f       	sbci	r29, 0xFF	; 255
    41cc:	dc 2f       	mov	r29, r28
    41ce:	cc 27       	eor	r28, r28
    wynik=dataPtr(tmpKlaster, 0);
  }
  return wynik;
}

void ramDyskDir(FILE *ostream)
    41d0:	20 ef       	ldi	r18, 0xF0	; 240
    41d2:	62 2e       	mov	r6, r18
    41d4:	71 2c       	mov	r7, r1
    41d6:	6c 0e       	add	r6, r28
    41d8:	7d 1e       	adc	r7, r29
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    {
      tmp3=plik->nazwa[0];
    41da:	bc 80       	ldd	r11, Y+4	; 0x04
      if (tmp3 == 0)
    41dc:	bb 20       	and	r11, r11
    41de:	09 f4       	brne	.+2      	; 0x41e2 <ramDyskDir+0x5c>
    41e0:	48 c0       	rjmp	.+144    	; 0x4272 <ramDyskDir+0xec>
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
    41e2:	8b 2d       	mov	r24, r11
    41e4:	90 e0       	ldi	r25, 0x00	; 0
    41e6:	b8 01       	movw	r22, r16
    41e8:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    41ec:	7e 01       	movw	r14, r28
      for (tmp2=1; tmp2<8; tmp2++)
    41ee:	99 24       	eor	r9, r9
    41f0:	93 94       	inc	r9
      {
        if (tmp3 != 0)
    41f2:	bb 20       	and	r11, r11
    41f4:	61 f0       	breq	.+24     	; 0x420e <ramDyskDir+0x88>
          tmp3=plik->nazwa[tmp2];
    41f6:	d7 01       	movw	r26, r14
    41f8:	15 96       	adiw	r26, 0x05	; 5
    41fa:	bc 90       	ld	r11, X
    41fc:	15 97       	sbiw	r26, 0x05	; 5

        if (tmp3 != 0)
    41fe:	bb 20       	and	r11, r11
    4200:	31 f0       	breq	.+12     	; 0x420e <ramDyskDir+0x88>
          fputc(tmp3     , ostream);
    4202:	8b 2d       	mov	r24, r11
    4204:	90 e0       	ldi	r25, 0x00	; 0
    4206:	b8 01       	movw	r22, r16
    4208:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    420c:	06 c0       	rjmp	.+12     	; 0x421a <ramDyskDir+0x94>
        else
          fputc(' '      , ostream);
    420e:	80 e2       	ldi	r24, 0x20	; 32
    4210:	90 e0       	ldi	r25, 0x00	; 0
    4212:	b8 01       	movw	r22, r16
    4214:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    4218:	bb 24       	eor	r11, r11
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
    421a:	93 94       	inc	r9
    421c:	08 94       	sec
    421e:	e1 1c       	adc	r14, r1
    4220:	f1 1c       	adc	r15, r1
    4222:	b9 2d       	mov	r27, r9
    4224:	b8 30       	cpi	r27, 0x08	; 8
    4226:	29 f7       	brne	.-54     	; 0x41f2 <ramDyskDir+0x6c>
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    4228:	ed b7       	in	r30, 0x3d	; 61
    422a:	fe b7       	in	r31, 0x3e	; 62
    422c:	38 97       	sbiw	r30, 0x08	; 8
    422e:	ed bf       	out	0x3d, r30	; 61
    4230:	fe bf       	out	0x3e, r31	; 62
    4232:	31 96       	adiw	r30, 0x01	; 1
    4234:	ad b7       	in	r26, 0x3d	; 61
    4236:	be b7       	in	r27, 0x3e	; 62
    4238:	11 96       	adiw	r26, 0x01	; 1
    423a:	0d 93       	st	X+, r16
    423c:	1c 93       	st	X, r17
    423e:	12 97       	sbiw	r26, 0x02	; 2
    4240:	22 82       	std	Z+2, r2	; 0x02
    4242:	33 82       	std	Z+3, r3	; 0x03
    4244:	5a 80       	ldd	r5, Y+2	; 0x02
    4246:	44 24       	eor	r4, r4
    4248:	89 81       	ldd	r24, Y+1	; 0x01
    424a:	92 01       	movw	r18, r4
    424c:	28 0f       	add	r18, r24
    424e:	31 1d       	adc	r19, r1
    4250:	24 83       	std	Z+4, r18	; 0x04
    4252:	35 83       	std	Z+5, r19	; 0x05
    4254:	8b 81       	ldd	r24, Y+3	; 0x03
    4256:	86 83       	std	Z+6, r24	; 0x06
    4258:	17 82       	std	Z+7, r1	; 0x07
    425a:	0e 94 69 57 	call	0xaed2	; 0xaed2 <fprintf>
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    425e:	8d b7       	in	r24, 0x3d	; 61
    4260:	9e b7       	in	r25, 0x3e	; 62
    4262:	08 96       	adiw	r24, 0x08	; 8
    4264:	8d bf       	out	0x3d, r24	; 61
    4266:	9e bf       	out	0x3e, r25	; 62
    4268:	c6 15       	cp	r28, r6
    426a:	d7 05       	cpc	r29, r7
    426c:	11 f0       	breq	.+4      	; 0x4272 <ramDyskDir+0xec>
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
      plik++;
    426e:	60 96       	adiw	r28, 0x10	; 16
    4270:	b4 cf       	rjmp	.-152    	; 0x41da <ramDyskDir+0x54>
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    4272:	f6 01       	movw	r30, r12
    4274:	e5 5d       	subi	r30, 0xD5	; 213
    4276:	fd 4c       	sbci	r31, 0xCD	; 205
    4278:	80 81       	ld	r24, Z
  }
  while (tmpKlaster != tmpKlaster2);
    427a:	8a 15       	cp	r24, r10
    427c:	09 f0       	breq	.+2      	; 0x4280 <ramDyskDir+0xfa>
    427e:	a0 cf       	rjmp	.-192    	; 0x41c0 <ramDyskDir+0x3a>
}
    4280:	df 91       	pop	r29
    4282:	cf 91       	pop	r28
    4284:	1f 91       	pop	r17
    4286:	0f 91       	pop	r16
    4288:	ff 90       	pop	r15
    428a:	ef 90       	pop	r14
    428c:	df 90       	pop	r13
    428e:	cf 90       	pop	r12
    4290:	bf 90       	pop	r11
    4292:	af 90       	pop	r10
    4294:	9f 90       	pop	r9
    4296:	7f 90       	pop	r7
    4298:	6f 90       	pop	r6
    429a:	5f 90       	pop	r5
    429c:	4f 90       	pop	r4
    429e:	3f 90       	pop	r3
    42a0:	2f 90       	pop	r2
    42a2:	08 95       	ret

000042a4 <ramDyskLiczbaWolnychKlastrow>:

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
    42a4:	eb ea       	ldi	r30, 0xAB	; 171
    42a6:	f2 e3       	ldi	r31, 0x32	; 50
    42a8:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    if (klastry[temp] == 0)
    42aa:	92 91       	ld	r25, -Z
    42ac:	99 23       	and	r25, r25
    42ae:	09 f4       	brne	.+2      	; 0x42b2 <ramDyskLiczbaWolnychKlastrow+0xe>
      wynik++;
    42b0:	8f 5f       	subi	r24, 0xFF	; 255

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    42b2:	92 e3       	ldi	r25, 0x32	; 50
    42b4:	ec 32       	cpi	r30, 0x2C	; 44
    42b6:	f9 07       	cpc	r31, r25
    42b8:	c1 f7       	brne	.-16     	; 0x42aa <ramDyskLiczbaWolnychKlastrow+0x6>
    if (klastry[temp] == 0)
      wynik++;
  return wynik;
}
    42ba:	08 95       	ret

000042bc <ramDyskOtworzPlikStdIo>:
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
}

uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags)
{
    42bc:	ef 92       	push	r14
    42be:	ff 92       	push	r15
    42c0:	0f 93       	push	r16
    42c2:	1f 93       	push	r17
    42c4:	df 93       	push	r29
    42c6:	cf 93       	push	r28
    42c8:	0f 92       	push	r0
    42ca:	cd b7       	in	r28, 0x3d	; 61
    42cc:	de b7       	in	r29, 0x3e	; 62
    42ce:	8b 01       	movw	r16, r22
    42d0:	7a 01       	movw	r14, r20
  uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
    42d2:	29 83       	std	Y+1, r18	; 0x01
    42d4:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <ramDyskOtworzPlik>
  if (wynik != 0)
    42d8:	29 81       	ldd	r18, Y+1	; 0x01
    42da:	88 23       	and	r24, r24
    42dc:	61 f4       	brne	.+24     	; 0x42f6 <ramDyskOtworzPlikStdIo+0x3a>
    return wynik;
  
  fdev_setup_stream(stream, putSTD, getSTD, flags);
    42de:	4e e6       	ldi	r20, 0x6E	; 110
    42e0:	5e e1       	ldi	r21, 0x1E	; 30
    42e2:	f7 01       	movw	r30, r14
    42e4:	40 87       	std	Z+8, r20	; 0x08
    42e6:	51 87       	std	Z+9, r21	; 0x09
    42e8:	4f ea       	ldi	r20, 0xAF	; 175
    42ea:	5e e1       	ldi	r21, 0x1E	; 30
    42ec:	42 87       	std	Z+10, r20	; 0x0a
    42ee:	53 87       	std	Z+11, r21	; 0x0b
    42f0:	23 83       	std	Z+3, r18	; 0x03
  fdev_set_udata(stream, fd);
    42f2:	04 87       	std	Z+12, r16	; 0x0c
    42f4:	15 87       	std	Z+13, r17	; 0x0d
  return 0;
}
    42f6:	0f 90       	pop	r0
    42f8:	cf 91       	pop	r28
    42fa:	df 91       	pop	r29
    42fc:	1f 91       	pop	r17
    42fe:	0f 91       	pop	r16
    4300:	ff 90       	pop	r15
    4302:	ef 90       	pop	r14
    4304:	08 95       	ret

00004306 <ramDyskZamknijPlikStdIo>:

uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
{
    4306:	0f 93       	push	r16
    4308:	1f 93       	push	r17
    430a:	cf 93       	push	r28
    430c:	df 93       	push	r29
    430e:	8c 01       	movw	r16, r24
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
    4310:	fc 01       	movw	r30, r24
    4312:	c4 85       	ldd	r28, Z+12	; 0x0c
    4314:	d5 85       	ldd	r29, Z+13	; 0x0d
  ramDyskZamknijPlik(fd);
    4316:	ce 01       	movw	r24, r28
    4318:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <ramDyskZamknijPlik>
  fclose(stream);
    431c:	c8 01       	movw	r24, r16
    431e:	0e 94 ff 56 	call	0xadfe	; 0xadfe <fclose>
  return fd->wpis->lAktOtw;
    4322:	ec 81       	ldd	r30, Y+4	; 0x04
    4324:	fd 81       	ldd	r31, Y+5	; 0x05
}
    4326:	83 81       	ldd	r24, Z+3	; 0x03
    4328:	df 91       	pop	r29
    432a:	cf 91       	pop	r28
    432c:	1f 91       	pop	r17
    432e:	0f 91       	pop	r16
    4330:	08 95       	ret

00004332 <cmdlinePrintPrompt>:
    cmdlinePrintPrompt(state);                  // output new prompt
  }
}

void cmdlinePrintPrompt(cmdState_t *state)
{
    4332:	0f 93       	push	r16
    4334:	1f 93       	push	r17
    4336:	cf 93       	push	r28
    4338:	df 93       	push	r29
    433a:	8c 01       	movw	r16, r24
  const char* ptr;
  // print a new command prompt
  switch (state->cliMode)
    433c:	dc 01       	movw	r26, r24
    433e:	90 96       	adiw	r26, 0x20	; 32
    4340:	ec 91       	ld	r30, X
    4342:	90 97       	sbiw	r26, 0x20	; 32
    4344:	e3 30       	cpi	r30, 0x03	; 3
    4346:	40 f4       	brcc	.+16     	; 0x4358 <cmdlinePrintPrompt+0x26>
    4348:	f0 e0       	ldi	r31, 0x00	; 0
    434a:	ee 0f       	add	r30, r30
    434c:	ff 1f       	adc	r31, r31
    434e:	e9 52       	subi	r30, 0x29	; 41
    4350:	fb 4d       	sbci	r31, 0xDB	; 219
    4352:	c0 81       	ld	r28, Z
    4354:	d1 81       	ldd	r29, Z+1	; 0x01
    4356:	0e c0       	rjmp	.+28     	; 0x4374 <cmdlinePrintPrompt+0x42>
    4358:	c9 ef       	ldi	r28, 0xF9	; 249
    435a:	d7 e0       	ldi	r29, 0x07	; 7
    435c:	0b c0       	rjmp	.+22     	; 0x4374 <cmdlinePrintPrompt+0x42>
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    435e:	21 96       	adiw	r28, 0x01	; 1
    4360:	fc 01       	movw	r30, r24
    4362:	84 91       	lpm	r24, Z+
    4364:	d8 01       	movw	r26, r16
    4366:	5a 96       	adiw	r26, 0x1a	; 26
    4368:	6d 91       	ld	r22, X+
    436a:	7c 91       	ld	r23, X
    436c:	5b 97       	sbiw	r26, 0x1b	; 27
    436e:	90 e0       	ldi	r25, 0x00	; 0
    4370:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    4374:	ce 01       	movw	r24, r28
      break;
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    4376:	fe 01       	movw	r30, r28
    4378:	24 91       	lpm	r18, Z+
    437a:	22 23       	and	r18, r18
    437c:	81 f7       	brne	.-32     	; 0x435e <cmdlinePrintPrompt+0x2c>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
}
    437e:	df 91       	pop	r29
    4380:	cf 91       	pop	r28
    4382:	1f 91       	pop	r17
    4384:	0f 91       	pop	r16
    4386:	08 95       	ret

00004388 <cmdlineRepaint>:
    state->CmdlineInputVT100State = 1;
  }
}

void cmdlineRepaint(cmdState_t *state, char *buf)
{
    4388:	ff 92       	push	r15
    438a:	0f 93       	push	r16
    438c:	1f 93       	push	r17
    438e:	cf 93       	push	r28
    4390:	df 93       	push	r29
    4392:	ec 01       	movw	r28, r24
    4394:	8b 01       	movw	r16, r22
  uint8_t i;

  // carriage return
  fputc(ASCII_CR         , state->myStdInOut);
    4396:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4398:	7b 8d       	ldd	r23, Y+27	; 0x1b
    439a:	8d e0       	ldi	r24, 0x0D	; 13
    439c:	90 e0       	ldi	r25, 0x00	; 0
    439e:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
  // print fresh prompt
  cmdlinePrintPrompt(state);
    43a2:	ce 01       	movw	r24, r28
    43a4:	0e 94 99 21 	call	0x4332	; 0x4332 <cmdlinePrintPrompt>
  // print the new command line buffer
  i = state->CmdlineBufferLength;
    43a8:	fd 84       	ldd	r15, Y+13	; 0x0d
  while(i--) 
    43aa:	0b c0       	rjmp	.+22     	; 0x43c2 <cmdlineRepaint+0x3a>
    fputc(*buf++         , state->myStdInOut);
    43ac:	f8 01       	movw	r30, r16
    43ae:	81 91       	ld	r24, Z+
    43b0:	8f 01       	movw	r16, r30
    43b2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    43b4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    43b6:	99 27       	eor	r25, r25
    43b8:	87 fd       	sbrc	r24, 7
    43ba:	90 95       	com	r25
    43bc:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    43c0:	fa 94       	dec	r15
  fputc(ASCII_CR         , state->myStdInOut);
  // print fresh prompt
  cmdlinePrintPrompt(state);
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    43c2:	ff 20       	and	r15, r15
    43c4:	99 f7       	brne	.-26     	; 0x43ac <cmdlineRepaint+0x24>
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    43c6:	0c 85       	ldd	r16, Y+12	; 0x0c
    43c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    43ca:	08 1b       	sub	r16, r24
  while (i--)
    43cc:	07 c0       	rjmp	.+14     	; 0x43dc <cmdlineRepaint+0x54>
    fputc(' ', state->myStdInOut);
    43ce:	6a 8d       	ldd	r22, Y+26	; 0x1a
    43d0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    43d2:	80 e2       	ldi	r24, 0x20	; 32
    43d4:	90 e0       	ldi	r25, 0x00	; 0
    43d6:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    43da:	01 50       	subi	r16, 0x01	; 1
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    43dc:	00 23       	and	r16, r16
    43de:	b9 f7       	brne	.-18     	; 0x43ce <cmdlineRepaint+0x46>
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    43e0:	0c 85       	ldd	r16, Y+12	; 0x0c
    43e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    43e4:	08 1b       	sub	r16, r24
  while (i--)
    43e6:	07 c0       	rjmp	.+14     	; 0x43f6 <cmdlineRepaint+0x6e>
    fputc(ASCII_BS,  state->myStdInOut);
    43e8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    43ea:	7b 8d       	ldd	r23, Y+27	; 0x1b
    43ec:	88 e0       	ldi	r24, 0x08	; 8
    43ee:	90 e0       	ldi	r25, 0x00	; 0
    43f0:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    43f4:	01 50       	subi	r16, 0x01	; 1
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    43f6:	00 23       	and	r16, r16
    43f8:	b9 f7       	brne	.-18     	; 0x43e8 <cmdlineRepaint+0x60>
    fputc(ASCII_BS,  state->myStdInOut);
}
    43fa:	df 91       	pop	r29
    43fc:	cf 91       	pop	r28
    43fe:	1f 91       	pop	r17
    4400:	0f 91       	pop	r16
    4402:	ff 90       	pop	r15
    4404:	08 95       	ret

00004406 <cmdlineDoHistory>:
  state->historyDepthIdx = 0;
  state->bufferHistoryState = COPIED;
}

void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
{
    4406:	ef 92       	push	r14
    4408:	ff 92       	push	r15
    440a:	cf 93       	push	r28
    440c:	df 93       	push	r29
    440e:	fb 01       	movw	r30, r22
  uint8_t historyReadIdx;
  switch(action)
    4410:	81 30       	cpi	r24, 0x01	; 1
    4412:	f9 f0       	breq	.+62     	; 0x4452 <cmdlineDoHistory+0x4c>
    4414:	81 30       	cpi	r24, 0x01	; 1
    4416:	20 f0       	brcs	.+8      	; 0x4420 <cmdlineDoHistory+0x1a>
    4418:	82 30       	cpi	r24, 0x02	; 2
    441a:	09 f0       	breq	.+2      	; 0x441e <cmdlineDoHistory+0x18>
    441c:	55 c0       	rjmp	.+170    	; 0x44c8 <cmdlineDoHistory+0xc2>
    441e:	32 c0       	rjmp	.+100    	; 0x4484 <cmdlineDoHistory+0x7e>
  {
  case CMDLINE_HISTORY_SAVE:
    // copy CmdlineBuffer to history if not null string
    state->CmdlineBufferLength  = 0;
    4420:	15 86       	std	Z+13, r1	; 0x0d
    state->CmdlineBufferEditPos = 0;     
    4422:	16 86       	std	Z+14, r1	; 0x0e
    state->bufferHistoryState   = NOT_COPIED;
    4424:	11 8a       	std	Z+17, r1	; 0x11

    if( strlen(state->CmdlineBuffer) )
    4426:	a0 81       	ld	r26, Z
    4428:	b1 81       	ldd	r27, Z+1	; 0x01
    442a:	8c 91       	ld	r24, X
    442c:	88 23       	and	r24, r24
    442e:	09 f4       	brne	.+2      	; 0x4432 <cmdlineDoHistory+0x2c>
    4430:	4b c0       	rjmp	.+150    	; 0x44c8 <cmdlineDoHistory+0xc2>
    {
      state->historyWrIdx++;
    4432:	a7 85       	ldd	r26, Z+15	; 0x0f
    4434:	af 5f       	subi	r26, 0xFF	; 255
      state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
    4436:	a3 70       	andi	r26, 0x03	; 3
    4438:	a7 87       	std	Z+15, r26	; 0x0f
      
      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    443a:	b0 e0       	ldi	r27, 0x00	; 0
    443c:	12 96       	adiw	r26, 0x02	; 2
    443e:	aa 0f       	add	r26, r26
    4440:	bb 1f       	adc	r27, r27
    4442:	a6 0f       	add	r26, r22
    4444:	b7 1f       	adc	r27, r23
    4446:	8d 91       	ld	r24, X+
    4448:	9c 91       	ld	r25, X
    444a:	11 97       	sbiw	r26, 0x01	; 1
    444c:	80 83       	st	Z, r24
    444e:	91 83       	std	Z+1, r25	; 0x01
    4450:	3b c0       	rjmp	.+118    	; 0x44c8 <cmdlineDoHistory+0xc2>
    }
    break;
  case CMDLINE_HISTORY_PREV:
    if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
    4452:	80 89       	ldd	r24, Z+16	; 0x10
    4454:	83 30       	cpi	r24, 0x03	; 3
    4456:	c1 f1       	breq	.+112    	; 0x44c8 <cmdlineDoHistory+0xc2>
      break;                                               //We are on the end of the history list
    
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
    4458:	a7 85       	ldd	r26, Z+15	; 0x0f
    445a:	a1 50       	subi	r26, 0x01	; 1
    445c:	a8 1b       	sub	r26, r24
    445e:	a3 70       	andi	r26, 0x03	; 3
    
    if (state->CmdlineHistory[historyReadIdx][0] == 0)
    4460:	b0 e0       	ldi	r27, 0x00	; 0
    4462:	12 96       	adiw	r26, 0x02	; 2
    4464:	aa 0f       	add	r26, r26
    4466:	bb 1f       	adc	r27, r27
    4468:	a6 0f       	add	r26, r22
    446a:	b7 1f       	adc	r27, r23
    446c:	6d 91       	ld	r22, X+
    446e:	7c 91       	ld	r23, X
    4470:	db 01       	movw	r26, r22
    4472:	9c 91       	ld	r25, X
    4474:	99 23       	and	r25, r25
    4476:	41 f1       	breq	.+80     	; 0x44c8 <cmdlineDoHistory+0xc2>
      break;
    
    state->historyDepthIdx++;
    4478:	8f 5f       	subi	r24, 0xFF	; 255
    state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
    447a:	83 70       	andi	r24, 0x03	; 3
    447c:	80 8b       	std	Z+16, r24	; 0x10
    
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    447e:	e6 2e       	mov	r14, r22
    4480:	e7 01       	movw	r28, r14
    4482:	13 c0       	rjmp	.+38     	; 0x44aa <cmdlineDoHistory+0xa4>
    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    
    break;
  case CMDLINE_HISTORY_NEXT:      
    if (state->historyDepthIdx == 0)
    4484:	80 89       	ldd	r24, Z+16	; 0x10
    4486:	88 23       	and	r24, r24
    4488:	f9 f0       	breq	.+62     	; 0x44c8 <cmdlineDoHistory+0xc2>
      break;                                               //We are on the begining of the history list

    state->historyDepthIdx --;
    448a:	81 50       	subi	r24, 0x01	; 1
    448c:	80 8b       	std	Z+16, r24	; 0x10
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    448e:	a7 85       	ldd	r26, Z+15	; 0x0f
    4490:	a8 1b       	sub	r26, r24
    4492:	a3 70       	andi	r26, 0x03	; 3
   
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    4494:	b0 e0       	ldi	r27, 0x00	; 0
    4496:	12 96       	adiw	r26, 0x02	; 2
    4498:	aa 0f       	add	r26, r26
    449a:	bb 1f       	adc	r27, r27
    449c:	a6 0f       	add	r26, r22
    449e:	b7 1f       	adc	r27, r23
    44a0:	6c 91       	ld	r22, X
    44a2:	11 96       	adiw	r26, 0x01	; 1
    44a4:	7c 91       	ld	r23, X
    44a6:	a6 2f       	mov	r26, r22
    44a8:	ed 01       	movw	r28, r26
    44aa:	7e 01       	movw	r14, r28
    44ac:	f7 2e       	mov	r15, r23
    44ae:	d7 01       	movw	r26, r14
    44b0:	0d 90       	ld	r0, X+
    44b2:	00 20       	and	r0, r0
    44b4:	e9 f7       	brne	.-6      	; 0x44b0 <cmdlineDoHistory+0xaa>
    44b6:	11 97       	sbiw	r26, 0x01	; 1
    44b8:	ae 19       	sub	r26, r14
    44ba:	bf 09       	sbc	r27, r15
    44bc:	a5 87       	std	Z+13, r26	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    44be:	a6 87       	std	Z+14, r26	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    44c0:	11 8a       	std	Z+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    44c2:	cf 01       	movw	r24, r30
    44c4:	0e 94 c4 21 	call	0x4388	; 0x4388 <cmdlineRepaint>
    break;
  }
}
    44c8:	df 91       	pop	r29
    44ca:	cf 91       	pop	r28
    44cc:	ff 90       	pop	r15
    44ce:	ef 90       	pop	r14
    44d0:	08 95       	ret

000044d2 <cmdHistoryCopy>:
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
}

void cmdHistoryCopy(cmdState_t *state)
{
    44d2:	1f 93       	push	r17
    44d4:	cf 93       	push	r28
    44d6:	df 93       	push	r29
    44d8:	ec 01       	movw	r28, r24
  if (state->historyDepthIdx != 0)
    44da:	88 89       	ldd	r24, Y+16	; 0x10
    44dc:	88 23       	and	r24, r24
    44de:	c1 f0       	breq	.+48     	; 0x4510 <cmdHistoryCopy+0x3e>
  {
    uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    44e0:	1f 85       	ldd	r17, Y+15	; 0x0f
    44e2:	18 1b       	sub	r17, r24
    44e4:	13 70       	andi	r17, 0x03	; 3
    memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
    44e6:	4c 85       	ldd	r20, Y+12	; 0x0c
    44e8:	88 81       	ld	r24, Y
    44ea:	99 81       	ldd	r25, Y+1	; 0x01
    44ec:	60 e0       	ldi	r22, 0x00	; 0
    44ee:	70 e0       	ldi	r23, 0x00	; 0
    44f0:	50 e0       	ldi	r21, 0x00	; 0
    44f2:	0e 94 c9 56 	call	0xad92	; 0xad92 <memset>
    strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
    44f6:	e1 2f       	mov	r30, r17
    44f8:	f0 e0       	ldi	r31, 0x00	; 0
    44fa:	32 96       	adiw	r30, 0x02	; 2
    44fc:	ee 0f       	add	r30, r30
    44fe:	ff 1f       	adc	r31, r31
    4500:	ec 0f       	add	r30, r28
    4502:	fd 1f       	adc	r31, r29
    4504:	60 81       	ld	r22, Z
    4506:	71 81       	ldd	r23, Z+1	; 0x01
    4508:	88 81       	ld	r24, Y
    450a:	99 81       	ldd	r25, Y+1	; 0x01
    450c:	0e 94 db 56 	call	0xadb6	; 0xadb6 <strcpy>
  }
  
  state->historyDepthIdx = 0;
    4510:	18 8a       	std	Y+16, r1	; 0x10
  state->bufferHistoryState = COPIED;
    4512:	81 e0       	ldi	r24, 0x01	; 1
    4514:	89 8b       	std	Y+17, r24	; 0x11
}
    4516:	df 91       	pop	r29
    4518:	cf 91       	pop	r28
    451a:	1f 91       	pop	r17
    451c:	08 95       	ret

0000451e <cmdStateConfigure>:
static void cmdHistoryCopy            (cmdState_t *state);
static void cmdHistoryMove            (cmdState_t *state);


void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, const command_t *commands, enum cliModeState mode)
{
    451e:	6f 92       	push	r6
    4520:	7f 92       	push	r7
    4522:	8f 92       	push	r8
    4524:	9f 92       	push	r9
    4526:	af 92       	push	r10
    4528:	bf 92       	push	r11
    452a:	cf 92       	push	r12
    452c:	df 92       	push	r13
    452e:	ef 92       	push	r14
    4530:	0f 93       	push	r16
    4532:	1f 93       	push	r17
    4534:	cf 93       	push	r28
    4536:	df 93       	push	r29
    4538:	ec 01       	movw	r28, r24
    453a:	6b 01       	movw	r12, r22
    453c:	5a 01       	movw	r10, r20
    453e:	49 01       	movw	r8, r18
  memset(state, 0, sizeof(cmdState_t));
    4540:	83 e2       	ldi	r24, 0x23	; 35
    4542:	de 01       	movw	r26, r28
    4544:	1d 92       	st	X+, r1
    4546:	8a 95       	dec	r24
    4548:	e9 f7       	brne	.-6      	; 0x4544 <cmdStateConfigure+0x26>
  memset(buffPtr, 0, bufferTotalSize);
    454a:	cb 01       	movw	r24, r22
    454c:	60 e0       	ldi	r22, 0x00	; 0
    454e:	70 e0       	ldi	r23, 0x00	; 0
    4550:	0e 94 c9 56 	call	0xad92	; 0xad92 <memset>
    
  state->CmdlineBuffer = buffPtr;
    4554:	c8 82       	st	Y, r12
    4556:	d9 82       	std	Y+1, r13	; 0x01
  state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
    4558:	b6 94       	lsr	r11
    455a:	a7 94       	ror	r10
    455c:	b6 94       	lsr	r11
    455e:	a7 94       	ror	r10
    4560:	ac 86       	std	Y+12, r10	; 0x0c

  state->cliMode = mode;
    4562:	e8 a2       	std	Y+32, r14	; 0x20
  state->cmdList = commands;
    4564:	09 a3       	std	Y+33, r16	; 0x21
    4566:	1a a3       	std	Y+34, r17	; 0x22
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    4568:	cc 82       	std	Y+4, r12	; 0x04
    456a:	dd 82       	std	Y+5, r13	; 0x05
    tmpPtr += state->bufferMaxSize;
    456c:	bb 24       	eor	r11, r11
    456e:	ca 0c       	add	r12, r10
    4570:	db 1c       	adc	r13, r11
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    4572:	ce 82       	std	Y+6, r12	; 0x06
    4574:	df 82       	std	Y+7, r13	; 0x07
    tmpPtr += state->bufferMaxSize;
    4576:	ca 0c       	add	r12, r10
    4578:	db 1c       	adc	r13, r11
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    457a:	c8 86       	std	Y+8, r12	; 0x08
    457c:	d9 86       	std	Y+9, r13	; 0x09
    tmpPtr += state->bufferMaxSize;
    457e:	ac 0c       	add	r10, r12
    4580:	bd 1c       	adc	r11, r13
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    4582:	aa 86       	std	Y+10, r10	; 0x0a
    4584:	bb 86       	std	Y+11, r11	; 0x0b
    tmpPtr += state->bufferMaxSize;
  }
  state->myStdInOut = stream;
    4586:	8a 8e       	std	Y+26, r8	; 0x1a
    4588:	9b 8e       	std	Y+27, r9	; 0x1b
}
    458a:	df 91       	pop	r29
    458c:	cf 91       	pop	r28
    458e:	1f 91       	pop	r17
    4590:	0f 91       	pop	r16
    4592:	ef 90       	pop	r14
    4594:	df 90       	pop	r13
    4596:	cf 90       	pop	r12
    4598:	bf 90       	pop	r11
    459a:	af 90       	pop	r10
    459c:	9f 90       	pop	r9
    459e:	8f 90       	pop	r8
    45a0:	7f 90       	pop	r7
    45a2:	6f 90       	pop	r6
    45a4:	08 95       	ret

000045a6 <cmdlineInputFunc>:
  // initialize executing function
  state->CmdlineExecFunction = 0;
}

void cmdlineInputFunc(char c, cmdState_t *state)
{
    45a6:	8f 92       	push	r8
    45a8:	9f 92       	push	r9
    45aa:	af 92       	push	r10
    45ac:	bf 92       	push	r11
    45ae:	cf 92       	push	r12
    45b0:	df 92       	push	r13
    45b2:	ef 92       	push	r14
    45b4:	ff 92       	push	r15
    45b6:	0f 93       	push	r16
    45b8:	1f 93       	push	r17
    45ba:	df 93       	push	r29
    45bc:	cf 93       	push	r28
    45be:	00 d0       	rcall	.+0      	; 0x45c0 <cmdlineInputFunc+0x1a>
    45c0:	00 d0       	rcall	.+0      	; 0x45c2 <cmdlineInputFunc+0x1c>
    45c2:	cd b7       	in	r28, 0x3d	; 61
    45c4:	de b7       	in	r29, 0x3e	; 62
    45c6:	08 2f       	mov	r16, r24
    45c8:	7b 01       	movw	r14, r22
  uint8_t i;
  // process the received character

  // VT100 handling
  // are we processing a VT100 command?
  if(state->CmdlineInputVT100State == 2)
    45ca:	db 01       	movw	r26, r22
    45cc:	52 96       	adiw	r26, 0x12	; 18
    45ce:	8c 91       	ld	r24, X
    45d0:	52 97       	sbiw	r26, 0x12	; 18
    45d2:	82 30       	cpi	r24, 0x02	; 2
    45d4:	09 f0       	breq	.+2      	; 0x45d8 <cmdlineInputFunc+0x32>
    45d6:	5e c0       	rjmp	.+188    	; 0x4694 <cmdlineInputFunc+0xee>
  {
    // we have already received ESC and [
    // now process the vt100 codeCmdlineExcBuffer
    switch(c)
    45d8:	02 34       	cpi	r16, 0x42	; 66
    45da:	71 f0       	breq	.+28     	; 0x45f8 <cmdlineInputFunc+0x52>
    45dc:	03 34       	cpi	r16, 0x43	; 67
    45de:	24 f4       	brge	.+8      	; 0x45e8 <cmdlineInputFunc+0x42>
    45e0:	01 34       	cpi	r16, 0x41	; 65
    45e2:	09 f0       	breq	.+2      	; 0x45e6 <cmdlineInputFunc+0x40>
    45e4:	54 c0       	rjmp	.+168    	; 0x468e <cmdlineInputFunc+0xe8>
    45e6:	06 c0       	rjmp	.+12     	; 0x45f4 <cmdlineInputFunc+0x4e>
    45e8:	03 34       	cpi	r16, 0x43	; 67
    45ea:	59 f0       	breq	.+22     	; 0x4602 <cmdlineInputFunc+0x5c>
    45ec:	04 34       	cpi	r16, 0x44	; 68
    45ee:	09 f0       	breq	.+2      	; 0x45f2 <cmdlineInputFunc+0x4c>
    45f0:	4e c0       	rjmp	.+156    	; 0x468e <cmdlineInputFunc+0xe8>
    45f2:	31 c0       	rjmp	.+98     	; 0x4656 <cmdlineInputFunc+0xb0>
    {
    case VT100_ARROWUP:
      cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
    45f4:	81 e0       	ldi	r24, 0x01	; 1
    45f6:	01 c0       	rjmp	.+2      	; 0x45fa <cmdlineInputFunc+0x54>
      break;
    case VT100_ARROWDOWN:
      cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
    45f8:	82 e0       	ldi	r24, 0x02	; 2
    45fa:	b7 01       	movw	r22, r14
    45fc:	0e 94 03 22 	call	0x4406	; 0x4406 <cmdlineDoHistory>
      break;
    4600:	46 c0       	rjmp	.+140    	; 0x468e <cmdlineInputFunc+0xe8>
    case VT100_ARROWRIGHT:
      if (state->bufferHistoryState == NOT_COPIED)
    4602:	fb 01       	movw	r30, r22
    4604:	81 89       	ldd	r24, Z+17	; 0x11
    4606:	88 23       	and	r24, r24
    4608:	19 f4       	brne	.+6      	; 0x4610 <cmdlineInputFunc+0x6a>
        cmdHistoryCopy(state);
    460a:	cb 01       	movw	r24, r22
    460c:	0e 94 69 22 	call	0x44d2	; 0x44d2 <cmdHistoryCopy>
      // if the edit position less than current string length
      if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
    4610:	d7 01       	movw	r26, r14
    4612:	1e 96       	adiw	r26, 0x0e	; 14
    4614:	8c 91       	ld	r24, X
    4616:	1e 97       	sbiw	r26, 0x0e	; 14
    4618:	1d 96       	adiw	r26, 0x0d	; 13
    461a:	9c 91       	ld	r25, X
    461c:	1d 97       	sbiw	r26, 0x0d	; 13
    461e:	5a 96       	adiw	r26, 0x1a	; 26
    4620:	6d 91       	ld	r22, X+
    4622:	7c 91       	ld	r23, X
    4624:	5b 97       	sbiw	r26, 0x1b	; 27
    4626:	89 17       	cp	r24, r25
    4628:	70 f5       	brcc	.+92     	; 0x4686 <cmdlineInputFunc+0xe0>
      {
        // increment the edit position
        state->CmdlineBufferEditPos++;
    462a:	8f 5f       	subi	r24, 0xFF	; 255
    462c:	1e 96       	adiw	r26, 0x0e	; 14
    462e:	8c 93       	st	X, r24
        // move cursor forward one space (no erase)
        fputc(ASCII_ESC        , state->myStdInOut);
    4630:	8b e1       	ldi	r24, 0x1B	; 27
    4632:	90 e0       	ldi	r25, 0x00	; 0
    4634:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        fputc('['              , state->myStdInOut);
    4638:	f7 01       	movw	r30, r14
    463a:	62 8d       	ldd	r22, Z+26	; 0x1a
    463c:	73 8d       	ldd	r23, Z+27	; 0x1b
    463e:	8b e5       	ldi	r24, 0x5B	; 91
    4640:	90 e0       	ldi	r25, 0x00	; 0
    4642:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        fputc(VT100_ARROWRIGHT , state->myStdInOut);
    4646:	d7 01       	movw	r26, r14
    4648:	5a 96       	adiw	r26, 0x1a	; 26
    464a:	6d 91       	ld	r22, X+
    464c:	7c 91       	ld	r23, X
    464e:	5b 97       	sbiw	r26, 0x1b	; 27
    4650:	83 e4       	ldi	r24, 0x43	; 67
    4652:	90 e0       	ldi	r25, 0x00	; 0
    4654:	1a c0       	rjmp	.+52     	; 0x468a <cmdlineInputFunc+0xe4>
        fputc(ASCII_BEL        , state->myStdInOut);
      }
      break;
    case VT100_ARROWLEFT:
      // if the edit position is non-zero
      if (state->bufferHistoryState == NOT_COPIED)
    4656:	fb 01       	movw	r30, r22
    4658:	81 89       	ldd	r24, Z+17	; 0x11
    465a:	88 23       	and	r24, r24
    465c:	19 f4       	brne	.+6      	; 0x4664 <cmdlineInputFunc+0xbe>
        cmdHistoryCopy(state);
    465e:	cb 01       	movw	r24, r22
    4660:	0e 94 69 22 	call	0x44d2	; 0x44d2 <cmdHistoryCopy>
      
      if(state->CmdlineBufferEditPos)
    4664:	d7 01       	movw	r26, r14
    4666:	1e 96       	adiw	r26, 0x0e	; 14
    4668:	8c 91       	ld	r24, X
    466a:	1e 97       	sbiw	r26, 0x0e	; 14
    466c:	5a 96       	adiw	r26, 0x1a	; 26
    466e:	6d 91       	ld	r22, X+
    4670:	7c 91       	ld	r23, X
    4672:	5b 97       	sbiw	r26, 0x1b	; 27
    4674:	88 23       	and	r24, r24
    4676:	39 f0       	breq	.+14     	; 0x4686 <cmdlineInputFunc+0xe0>
      {
        // decrement the edit position
        state->CmdlineBufferEditPos--;
    4678:	81 50       	subi	r24, 0x01	; 1
    467a:	1e 96       	adiw	r26, 0x0e	; 14
    467c:	8c 93       	st	X, r24
    467e:	1e 97       	sbiw	r26, 0x0e	; 14
        // move cursor back one space (no erase)
        fputc(ASCII_BS         , state->myStdInOut);
    4680:	88 e0       	ldi	r24, 0x08	; 8
    4682:	90 e0       	ldi	r25, 0x00	; 0
    4684:	02 c0       	rjmp	.+4      	; 0x468a <cmdlineInputFunc+0xe4>
      }
      else
      {
        // else, ring the bell
        fputc(ASCII_BEL        , state->myStdInOut);
    4686:	87 e0       	ldi	r24, 0x07	; 7
    4688:	90 e0       	ldi	r25, 0x00	; 0
    468a:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
      break;
    default:
      break;
    }
    // done, reset state
    state->CmdlineInputVT100State = 0;
    468e:	f7 01       	movw	r30, r14
    4690:	12 8a       	std	Z+18, r1	; 0x12
    return;
    4692:	27 c2       	rjmp	.+1102   	; 0x4ae2 <cmdlineInputFunc+0x53c>
  }
  else if(state->CmdlineInputVT100State == 1)
    4694:	81 30       	cpi	r24, 0x01	; 1
    4696:	39 f4       	brne	.+14     	; 0x46a6 <cmdlineInputFunc+0x100>
  {
    // we last received [ESC]
    if(c == '[')
    4698:	0b 35       	cpi	r16, 0x5B	; 91
    469a:	11 f4       	brne	.+4      	; 0x46a0 <cmdlineInputFunc+0xfa>
    {
      state->CmdlineInputVT100State = 2;
    469c:	82 e0       	ldi	r24, 0x02	; 2
    469e:	1d c2       	rjmp	.+1082   	; 0x4ada <cmdlineInputFunc+0x534>
      return;
    }
    else
      state->CmdlineInputVT100State = 0;
    46a0:	fb 01       	movw	r30, r22
    46a2:	12 8a       	std	Z+18, r1	; 0x12
    46a4:	04 c0       	rjmp	.+8      	; 0x46ae <cmdlineInputFunc+0x108>
  }
  else
  {
    // anything else, reset state
    state->CmdlineInputVT100State = 0;
    46a6:	db 01       	movw	r26, r22
    46a8:	52 96       	adiw	r26, 0x12	; 18
    46aa:	1c 92       	st	X, r1
    46ac:	52 97       	sbiw	r26, 0x12	; 18
  }

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
    46ae:	f7 01       	movw	r30, r14
    46b0:	85 85       	ldd	r24, Z+13	; 0x0d
    46b2:	94 85       	ldd	r25, Z+12	; 0x0c
    46b4:	89 17       	cp	r24, r25
    46b6:	91 f4       	brne	.+36     	; 0x46dc <cmdlineInputFunc+0x136>
  {
    state->CmdlineBufferLength--;
    46b8:	81 50       	subi	r24, 0x01	; 1
    46ba:	85 87       	std	Z+13, r24	; 0x0d
    for (i=1; i < state->bufferMaxSize; i++)
    46bc:	81 e0       	ldi	r24, 0x01	; 1
    46be:	0a c0       	rjmp	.+20     	; 0x46d4 <cmdlineInputFunc+0x12e>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    46c0:	d7 01       	movw	r26, r14
    46c2:	ed 91       	ld	r30, X+
    46c4:	fc 91       	ld	r31, X
    46c6:	e8 0f       	add	r30, r24
    46c8:	f1 1d       	adc	r31, r1
    46ca:	df 01       	movw	r26, r30
    46cc:	11 97       	sbiw	r26, 0x01	; 1
    46ce:	90 81       	ld	r25, Z
    46d0:	9c 93       	st	X, r25
  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    for (i=1; i < state->bufferMaxSize; i++)
    46d2:	8f 5f       	subi	r24, 0xFF	; 255
    46d4:	f7 01       	movw	r30, r14
    46d6:	94 85       	ldd	r25, Z+12	; 0x0c
    46d8:	89 17       	cp	r24, r25
    46da:	90 f3       	brcs	.-28     	; 0x46c0 <cmdlineInputFunc+0x11a>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    }
  }
  
  if( (c >= 0x20) && (c < 0x7F) )
    46dc:	80 2f       	mov	r24, r16
    46de:	80 52       	subi	r24, 0x20	; 32
    46e0:	8f 35       	cpi	r24, 0x5F	; 95
    46e2:	08 f0       	brcs	.+2      	; 0x46e6 <cmdlineInputFunc+0x140>
    46e4:	5b c0       	rjmp	.+182    	; 0x479c <cmdlineInputFunc+0x1f6>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    46e6:	d7 01       	movw	r26, r14
    46e8:	51 96       	adiw	r26, 0x11	; 17
    46ea:	8c 91       	ld	r24, X
    46ec:	51 97       	sbiw	r26, 0x11	; 17
    46ee:	88 23       	and	r24, r24
    46f0:	19 f4       	brne	.+6      	; 0x46f8 <cmdlineInputFunc+0x152>
      cmdHistoryCopy(state);
    46f2:	c7 01       	movw	r24, r14
    46f4:	0e 94 69 22 	call	0x44d2	; 0x44d2 <cmdHistoryCopy>
    // character is printable
    // is this a simple append
    if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    46f8:	f7 01       	movw	r30, r14
    46fa:	85 85       	ldd	r24, Z+13	; 0x0d
    46fc:	96 85       	ldd	r25, Z+14	; 0x0e
    46fe:	98 17       	cp	r25, r24
    4700:	f1 f4       	brne	.+60     	; 0x473e <cmdlineInputFunc+0x198>
    {
      // echo character to the output
      fputc(c                , state->myStdInOut);
    4702:	62 8d       	ldd	r22, Z+26	; 0x1a
    4704:	73 8d       	ldd	r23, Z+27	; 0x1b
    4706:	80 2f       	mov	r24, r16
    4708:	99 27       	eor	r25, r25
    470a:	87 fd       	sbrc	r24, 7
    470c:	90 95       	com	r25
    470e:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
      // add it to the command line buffer
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4712:	d7 01       	movw	r26, r14
    4714:	1e 96       	adiw	r26, 0x0e	; 14
    4716:	8c 91       	ld	r24, X
    4718:	1e 97       	sbiw	r26, 0x0e	; 14
    471a:	ed 91       	ld	r30, X+
    471c:	fc 91       	ld	r31, X
    471e:	11 97       	sbiw	r26, 0x01	; 1
    4720:	e8 0f       	add	r30, r24
    4722:	f1 1d       	adc	r31, r1
    4724:	00 83       	st	Z, r16
    4726:	8f 5f       	subi	r24, 0xFF	; 255
    4728:	1e 96       	adiw	r26, 0x0e	; 14
    472a:	8c 93       	st	X, r24
    472c:	1e 97       	sbiw	r26, 0x0e	; 14
      // update buffer length
      state->CmdlineBufferLength++;
    472e:	1d 96       	adiw	r26, 0x0d	; 13
    4730:	8c 91       	ld	r24, X
    4732:	1d 97       	sbiw	r26, 0x0d	; 13
    4734:	8f 5f       	subi	r24, 0xFF	; 255
    4736:	1d 96       	adiw	r26, 0x0d	; 13
    4738:	8c 93       	st	X, r24
    473a:	1d 97       	sbiw	r26, 0x0d	; 13
    473c:	d2 c1       	rjmp	.+932    	; 0x4ae2 <cmdlineInputFunc+0x53c>
    else
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
    473e:	8f 5f       	subi	r24, 0xFF	; 255
    4740:	f7 01       	movw	r30, r14
    4742:	85 87       	std	Z+13, r24	; 0x0d
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    4744:	08 c0       	rjmp	.+16     	; 0x4756 <cmdlineInputFunc+0x1b0>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
    4746:	68 0f       	add	r22, r24
    4748:	71 1d       	adc	r23, r1
    474a:	fb 01       	movw	r30, r22
    474c:	31 97       	sbiw	r30, 0x01	; 1
    474e:	90 81       	ld	r25, Z
    4750:	db 01       	movw	r26, r22
    4752:	9c 93       	st	X, r25
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    4754:	81 50       	subi	r24, 0x01	; 1
    4756:	f7 01       	movw	r30, r14
    4758:	96 85       	ldd	r25, Z+14	; 0x0e
    475a:	60 81       	ld	r22, Z
    475c:	71 81       	ldd	r23, Z+1	; 0x01
    475e:	98 17       	cp	r25, r24
    4760:	90 f3       	brcs	.-28     	; 0x4746 <cmdlineInputFunc+0x1a0>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4762:	69 0f       	add	r22, r25
    4764:	71 1d       	adc	r23, r1
    4766:	db 01       	movw	r26, r22
    4768:	0c 93       	st	X, r16
    476a:	9f 5f       	subi	r25, 0xFF	; 255
    476c:	96 87       	std	Z+14, r25	; 0x0e
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
    476e:	60 81       	ld	r22, Z
    4770:	71 81       	ldd	r23, Z+1	; 0x01
    4772:	c7 01       	movw	r24, r14
    4774:	0e 94 c4 21 	call	0x4388	; 0x4388 <cmdlineRepaint>
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4778:	f7 01       	movw	r30, r14
    477a:	06 85       	ldd	r16, Z+14	; 0x0e
    477c:	0a c0       	rjmp	.+20     	; 0x4792 <cmdlineInputFunc+0x1ec>
        fputc(ASCII_BS         , state->myStdInOut);
    477e:	d7 01       	movw	r26, r14
    4780:	5a 96       	adiw	r26, 0x1a	; 26
    4782:	6d 91       	ld	r22, X+
    4784:	7c 91       	ld	r23, X
    4786:	5b 97       	sbiw	r26, 0x1b	; 27
    4788:	88 e0       	ldi	r24, 0x08	; 8
    478a:	90 e0       	ldi	r25, 0x00	; 0
    478c:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4790:	0f 5f       	subi	r16, 0xFF	; 255
    4792:	f7 01       	movw	r30, r14
    4794:	85 85       	ldd	r24, Z+13	; 0x0d
    4796:	08 17       	cp	r16, r24
    4798:	90 f3       	brcs	.-28     	; 0x477e <cmdlineInputFunc+0x1d8>
    479a:	a3 c1       	rjmp	.+838    	; 0x4ae2 <cmdlineInputFunc+0x53c>
        fputc(ASCII_BS         , state->myStdInOut);
    }
  }
  // handle special characters
  else if(c == ASCII_CR)
    479c:	0d 30       	cpi	r16, 0x0D	; 13
    479e:	09 f0       	breq	.+2      	; 0x47a2 <cmdlineInputFunc+0x1fc>
    47a0:	27 c1       	rjmp	.+590    	; 0x49f0 <cmdlineInputFunc+0x44a>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    47a2:	d7 01       	movw	r26, r14
    47a4:	51 96       	adiw	r26, 0x11	; 17
    47a6:	8c 91       	ld	r24, X
    47a8:	51 97       	sbiw	r26, 0x11	; 17
    47aa:	88 23       	and	r24, r24
    47ac:	09 f0       	breq	.+2      	; 0x47b0 <cmdlineInputFunc+0x20a>
    47ae:	49 c0       	rjmp	.+146    	; 0x4842 <cmdlineInputFunc+0x29c>
  state->bufferHistoryState = COPIED;
}

void cmdHistoryMove(cmdState_t *state)
{
  uint8_t i=state->historyDepthIdx;
    47b0:	50 96       	adiw	r26, 0x10	; 16
    47b2:	4c 91       	ld	r20, X
    47b4:	50 97       	sbiw	r26, 0x10	; 16

  if (state->historyDepthIdx != 0)
    47b6:	44 23       	and	r20, r20
    47b8:	79 f1       	breq	.+94     	; 0x4818 <cmdlineInputFunc+0x272>
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    47ba:	1f 96       	adiw	r26, 0x0f	; 15
    47bc:	8c 91       	ld	r24, X
    47be:	1f 97       	sbiw	r26, 0x0f	; 15
    47c0:	90 e0       	ldi	r25, 0x00	; 0
    47c2:	fc 01       	movw	r30, r24
    47c4:	e4 1b       	sub	r30, r20
    47c6:	f1 09       	sbc	r31, r1
    47c8:	e3 70       	andi	r30, 0x03	; 3
    47ca:	f0 70       	andi	r31, 0x00	; 0
    47cc:	32 96       	adiw	r30, 0x02	; 2
    47ce:	ee 0f       	add	r30, r30
    47d0:	ff 1f       	adc	r31, r31
    47d2:	ee 0d       	add	r30, r14
    47d4:	ff 1d       	adc	r31, r15
    47d6:	20 81       	ld	r18, Z
    47d8:	31 81       	ldd	r19, Z+1	; 0x01
    47da:	2d 93       	st	X+, r18
    47dc:	3c 93       	st	X, r19
    47de:	11 97       	sbiw	r26, 0x01	; 1
    47e0:	19 c0       	rjmp	.+50     	; 0x4814 <cmdlineInputFunc+0x26e>
    for ( ; i<CMD_STATE_HISTORY; i++)
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    47e2:	fc 01       	movw	r30, r24
    47e4:	e4 1b       	sub	r30, r20
    47e6:	f1 09       	sbc	r31, r1
    47e8:	df 01       	movw	r26, r30
    47ea:	a3 70       	andi	r26, 0x03	; 3
    47ec:	b0 70       	andi	r27, 0x00	; 0
    47ee:	12 96       	adiw	r26, 0x02	; 2
    47f0:	aa 0f       	add	r26, r26
    47f2:	bb 1f       	adc	r27, r27
    47f4:	ae 0d       	add	r26, r14
    47f6:	bf 1d       	adc	r27, r15
    47f8:	31 97       	sbiw	r30, 0x01	; 1
    47fa:	e3 70       	andi	r30, 0x03	; 3
    47fc:	f0 70       	andi	r31, 0x00	; 0
    47fe:	32 96       	adiw	r30, 0x02	; 2
    4800:	ee 0f       	add	r30, r30
    4802:	ff 1f       	adc	r31, r31
    4804:	ee 0d       	add	r30, r14
    4806:	ff 1d       	adc	r31, r15
    4808:	20 81       	ld	r18, Z
    480a:	31 81       	ldd	r19, Z+1	; 0x01
    480c:	2d 93       	st	X+, r18
    480e:	3c 93       	st	X, r19
    4810:	11 97       	sbiw	r26, 0x01	; 1
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    for ( ; i<CMD_STATE_HISTORY; i++)
    4812:	4f 5f       	subi	r20, 0xFF	; 255
    4814:	44 30       	cpi	r20, 0x04	; 4
    4816:	28 f3       	brcs	.-54     	; 0x47e2 <cmdlineInputFunc+0x23c>
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    }
  }
  state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
    4818:	d7 01       	movw	r26, r14
    481a:	1f 96       	adiw	r26, 0x0f	; 15
    481c:	ec 91       	ld	r30, X
    481e:	1f 97       	sbiw	r26, 0x0f	; 15
    4820:	f0 e0       	ldi	r31, 0x00	; 0
    4822:	32 96       	adiw	r30, 0x02	; 2
    4824:	ee 0f       	add	r30, r30
    4826:	ff 1f       	adc	r31, r31
    4828:	ee 0d       	add	r30, r14
    482a:	ff 1d       	adc	r31, r15
    482c:	8d 91       	ld	r24, X+
    482e:	9c 91       	ld	r25, X
    4830:	11 97       	sbiw	r26, 0x01	; 1
    4832:	80 83       	st	Z, r24
    4834:	91 83       	std	Z+1, r25	; 0x01

  state->historyDepthIdx = 0;
    4836:	50 96       	adiw	r26, 0x10	; 16
    4838:	1c 92       	st	X, r1
    483a:	50 97       	sbiw	r26, 0x10	; 16
  state->bufferHistoryState = COPIED;
    483c:	81 e0       	ldi	r24, 0x01	; 1
    483e:	51 96       	adiw	r26, 0x11	; 17
    4840:	8c 93       	st	X, r24
    if (state->bufferHistoryState == NOT_COPIED)
      cmdHistoryMove(state);
    
    // user pressed [ENTER]
    // echo CR and LF to terminal
    fputc(ASCII_CR         , state->myStdInOut);
    4842:	f7 01       	movw	r30, r14
    4844:	62 8d       	ldd	r22, Z+26	; 0x1a
    4846:	73 8d       	ldd	r23, Z+27	; 0x1b
    4848:	8d e0       	ldi	r24, 0x0D	; 13
    484a:	90 e0       	ldi	r25, 0x00	; 0
    484c:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    fputc(ASCII_LF         , state->myStdInOut);
    4850:	d7 01       	movw	r26, r14
    4852:	5a 96       	adiw	r26, 0x1a	; 26
    4854:	6d 91       	ld	r22, X+
    4856:	7c 91       	ld	r23, X
    4858:	5b 97       	sbiw	r26, 0x1b	; 27
    485a:	8a e0       	ldi	r24, 0x0A	; 10
    485c:	90 e0       	ldi	r25, 0x00	; 0
    485e:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    // add null termination to command
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    4862:	f7 01       	movw	r30, r14
    4864:	85 85       	ldd	r24, Z+13	; 0x0d
    4866:	01 90       	ld	r0, Z+
    4868:	f0 81       	ld	r31, Z
    486a:	e0 2d       	mov	r30, r0
    486c:	e8 0f       	add	r30, r24
    486e:	f1 1d       	adc	r31, r1
    4870:	10 82       	st	Z, r1
    4872:	8f 5f       	subi	r24, 0xFF	; 255
    4874:	d7 01       	movw	r26, r14
    4876:	1d 96       	adiw	r26, 0x0d	; 13
    4878:	8c 93       	st	X, r24
    487a:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos++;
    487c:	1e 96       	adiw	r26, 0x0e	; 14
    487e:	8c 91       	ld	r24, X
    4880:	1e 97       	sbiw	r26, 0x0e	; 14
    4882:	8f 5f       	subi	r24, 0xFF	; 255
    4884:	1e 96       	adiw	r26, 0x0e	; 14
    4886:	8c 93       	st	X, r24
    4888:	1e 97       	sbiw	r26, 0x0e	; 14
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments
    488a:	8d 91       	ld	r24, X+
    488c:	9c 91       	ld	r25, X
    488e:	11 97       	sbiw	r26, 0x01	; 1
    4890:	12 96       	adiw	r26, 0x02	; 2
    4892:	8d 93       	st	X+, r24
    4894:	9c 93       	st	X, r25
    4896:	13 97       	sbiw	r26, 0x03	; 3
  }
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
    4898:	20 e0       	ldi	r18, 0x00	; 0
    489a:	01 c0       	rjmp	.+2      	; 0x489e <cmdlineInputFunc+0x2f8>
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length
    489c:	2f 5f       	subi	r18, 0xFF	; 255
void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    489e:	a2 2e       	mov	r10, r18
    48a0:	bb 24       	eor	r11, r11
    48a2:	fc 01       	movw	r30, r24
    48a4:	ea 0d       	add	r30, r10
    48a6:	fb 1d       	adc	r31, r11
    48a8:	30 81       	ld	r19, Z
    48aa:	30 32       	cpi	r19, 0x20	; 32
    48ac:	11 f0       	breq	.+4      	; 0x48b2 <cmdlineInputFunc+0x30c>
    48ae:	33 23       	and	r19, r19
    48b0:	a9 f7       	brne	.-22     	; 0x489c <cmdlineInputFunc+0x2f6>
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length

  if(!i)                                                              // command was null or empty
    48b2:	22 23       	and	r18, r18
    48b4:	09 f4       	brne	.+2      	; 0x48b8 <cmdlineInputFunc+0x312>
    48b6:	91 c0       	rjmp	.+290    	; 0x49da <cmdlineInputFunc+0x434>
  {
    cmdlinePrintPrompt(state);                                        // output a new prompt
    return;
  }

  const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The list depends of the cli mode
    48b8:	f7 01       	movw	r30, r14
    48ba:	c1 a0       	ldd	r12, Z+33	; 0x21
    48bc:	d2 a0       	ldd	r13, Z+34	; 0x22
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.
    48be:	8e 01       	movw	r16, r28
    48c0:	0f 5f       	subi	r16, 0xFF	; 255
    48c2:	1f 4f       	sbci	r17, 0xFF	; 255
    48c4:	c8 01       	movw	r24, r16
    48c6:	b6 01       	movw	r22, r12
    48c8:	46 e0       	ldi	r20, 0x06	; 6
    48ca:	50 e0       	ldi	r21, 0x00	; 0
    48cc:	0e 94 a9 56 	call	0xad52	; 0xad52 <memcpy_P>
      state->command_help_str    = tmp.commandHelpStr;
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
      return;
    }
    tmpPtr++;                                                         // Next command
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    48d0:	90 2e       	mov	r9, r16
    48d2:	81 2e       	mov	r8, r17
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.

  do                                                                  // search command list for match with entered command
  {
    if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command matched a command in the list
    48d4:	09 81       	ldd	r16, Y+1	; 0x01
    48d6:	1a 81       	ldd	r17, Y+2	; 0x02
    48d8:	d7 01       	movw	r26, r14
    48da:	12 96       	adiw	r26, 0x02	; 2
    48dc:	8d 91       	ld	r24, X+
    48de:	9c 91       	ld	r25, X
    48e0:	13 97       	sbiw	r26, 0x03	; 3
    48e2:	b8 01       	movw	r22, r16
    48e4:	a5 01       	movw	r20, r10
    48e6:	0e 94 b2 56 	call	0xad64	; 0xad64 <strncmp_P>
    48ea:	00 97       	sbiw	r24, 0x00	; 0
    48ec:	81 f4       	brne	.+32     	; 0x490e <cmdlineInputFunc+0x368>
    {                                                                 // 
      state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
    48ee:	8d 81       	ldd	r24, Y+5	; 0x05
    48f0:	9e 81       	ldd	r25, Y+6	; 0x06
    48f2:	f7 01       	movw	r30, r14
    48f4:	87 8b       	std	Z+23, r24	; 0x17
    48f6:	90 8f       	std	Z+24, r25	; 0x18
      state->command_str         = tmp.commandStr;
    48f8:	03 8b       	std	Z+19, r16	; 0x13
    48fa:	14 8b       	std	Z+20, r17	; 0x14
      state->command_help_str    = tmp.commandHelpStr;
    48fc:	8b 81       	ldd	r24, Y+3	; 0x03
    48fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4900:	85 8b       	std	Z+21, r24	; 0x15
    4902:	96 8b       	std	Z+22, r25	; 0x16
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
    4904:	80 e0       	ldi	r24, 0x00	; 0
    4906:	b7 01       	movw	r22, r14
    4908:	0e 94 03 22 	call	0x4406	; 0x4406 <cmdlineDoHistory>
    490c:	69 c0       	rjmp	.+210    	; 0x49e0 <cmdlineInputFunc+0x43a>
      return;
    }
    tmpPtr++;                                                         // Next command
    490e:	86 e0       	ldi	r24, 0x06	; 6
    4910:	90 e0       	ldi	r25, 0x00	; 0
    4912:	c8 0e       	add	r12, r24
    4914:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    4916:	89 2d       	mov	r24, r9
    4918:	98 2d       	mov	r25, r8
    491a:	b6 01       	movw	r22, r12
    491c:	46 e0       	ldi	r20, 0x06	; 6
    491e:	50 e0       	ldi	r21, 0x00	; 0
    4920:	0e 94 a9 56 	call	0xad52	; 0xad52 <memcpy_P>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
    4924:	89 81       	ldd	r24, Y+1	; 0x01
    4926:	9a 81       	ldd	r25, Y+2	; 0x02
    4928:	00 97       	sbiw	r24, 0x00	; 0
    492a:	a1 f6       	brne	.-88     	; 0x48d4 <cmdlineInputFunc+0x32e>
    492c:	0e e0       	ldi	r16, 0x0E	; 14
    492e:	18 e0       	ldi	r17, 0x08	; 8
    4930:	0c c0       	rjmp	.+24     	; 0x494a <cmdlineInputFunc+0x3a4>

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4932:	0f 5f       	subi	r16, 0xFF	; 255
    4934:	1f 4f       	sbci	r17, 0xFF	; 255
    4936:	fc 01       	movw	r30, r24
    4938:	84 91       	lpm	r24, Z+
    493a:	d7 01       	movw	r26, r14
    493c:	5a 96       	adiw	r26, 0x1a	; 26
    493e:	6d 91       	ld	r22, X+
    4940:	7c 91       	ld	r23, X
    4942:	5b 97       	sbiw	r26, 0x1b	; 27
    4944:	90 e0       	ldi	r25, 0x00	; 0
    4946:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    494a:	c8 01       	movw	r24, r16
  char * ptr;

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    494c:	f8 01       	movw	r30, r16
    494e:	24 91       	lpm	r18, Z+
    4950:	22 23       	and	r18, r18
    4952:	79 f7       	brne	.-34     	; 0x4932 <cmdlineInputFunc+0x38c>
    4954:	d7 01       	movw	r26, r14
    4956:	0d 91       	ld	r16, X+
    4958:	1c 91       	ld	r17, X
    495a:	11 97       	sbiw	r26, 0x01	; 1
    495c:	08 c0       	rjmp	.+16     	; 0x496e <cmdlineInputFunc+0x3c8>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    fputc(*ptr++    , state->myStdInOut);
    495e:	f7 01       	movw	r30, r14
    4960:	62 8d       	ldd	r22, Z+26	; 0x1a
    4962:	73 8d       	ldd	r23, Z+27	; 0x1b
    4964:	99 27       	eor	r25, r25
    4966:	87 fd       	sbrc	r24, 7
    4968:	90 95       	com	r25
    496a:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    496e:	d8 01       	movw	r26, r16
    4970:	8d 91       	ld	r24, X+
    4972:	8d 01       	movw	r16, r26
    4974:	88 23       	and	r24, r24
    4976:	11 f0       	breq	.+4      	; 0x497c <cmdlineInputFunc+0x3d6>
    4978:	80 32       	cpi	r24, 0x20	; 32
    497a:	89 f7       	brne	.-30     	; 0x495e <cmdlineInputFunc+0x3b8>
    fputc(*ptr++    , state->myStdInOut);

  fputc(':'         , state->myStdInOut);
    497c:	f7 01       	movw	r30, r14
    497e:	62 8d       	ldd	r22, Z+26	; 0x1a
    4980:	73 8d       	ldd	r23, Z+27	; 0x1b
    4982:	8a e3       	ldi	r24, 0x3A	; 58
    4984:	90 e0       	ldi	r25, 0x00	; 0
    4986:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
  fputc(' '         , state->myStdInOut);
    498a:	d7 01       	movw	r26, r14
    498c:	5a 96       	adiw	r26, 0x1a	; 26
    498e:	6d 91       	ld	r22, X+
    4990:	7c 91       	ld	r23, X
    4992:	5b 97       	sbiw	r26, 0x1b	; 27
    4994:	80 e2       	ldi	r24, 0x20	; 32
    4996:	90 e0       	ldi	r25, 0x00	; 0
    4998:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
    499c:	08 e1       	ldi	r16, 0x18	; 24
    499e:	18 e0       	ldi	r17, 0x08	; 8
    49a0:	07 c0       	rjmp	.+14     	; 0x49b0 <cmdlineInputFunc+0x40a>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    49a2:	0f 5f       	subi	r16, 0xFF	; 255
    49a4:	1f 4f       	sbci	r17, 0xFF	; 255
    49a6:	fc 01       	movw	r30, r24
    49a8:	84 91       	lpm	r24, Z+
    49aa:	90 e0       	ldi	r25, 0x00	; 0
    49ac:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    49b0:	c8 01       	movw	r24, r16
  fputc(' '         , state->myStdInOut);

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    49b2:	f8 01       	movw	r30, r16
    49b4:	24 91       	lpm	r18, Z+
    49b6:	d7 01       	movw	r26, r14
    49b8:	5a 96       	adiw	r26, 0x1a	; 26
    49ba:	6d 91       	ld	r22, X+
    49bc:	7c 91       	ld	r23, X
    49be:	5b 97       	sbiw	r26, 0x1b	; 27
    49c0:	22 23       	and	r18, r18
    49c2:	79 f7       	brne	.-34     	; 0x49a2 <cmdlineInputFunc+0x3fc>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);

  fputc('\r'        , state->myStdInOut);
    49c4:	8d e0       	ldi	r24, 0x0D	; 13
    49c6:	90 e0       	ldi	r25, 0x00	; 0
    49c8:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
  fputc('\n'        , state->myStdInOut);
    49cc:	f7 01       	movw	r30, r14
    49ce:	62 8d       	ldd	r22, Z+26	; 0x1a
    49d0:	73 8d       	ldd	r23, Z+27	; 0x1b
    49d2:	8a e0       	ldi	r24, 0x0A	; 10
    49d4:	90 e0       	ldi	r25, 0x00	; 0
    49d6:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
  
  // if we did not get a match
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
    49da:	c7 01       	movw	r24, r14
    49dc:	0e 94 99 21 	call	0x4332	; 0x4332 <cmdlinePrintPrompt>
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    state->CmdlineBufferEditPos++;
    // command is complete, process it
    cmdlineProcessInputString(state);
    // reset buffer
    state->CmdlineBufferLength = 0;
    49e0:	d7 01       	movw	r26, r14
    49e2:	1d 96       	adiw	r26, 0x0d	; 13
    49e4:	1c 92       	st	X, r1
    49e6:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = 0;
    49e8:	1e 96       	adiw	r26, 0x0e	; 14
    49ea:	1c 92       	st	X, r1
    49ec:	1e 97       	sbiw	r26, 0x0e	; 14
    49ee:	79 c0       	rjmp	.+242    	; 0x4ae2 <cmdlineInputFunc+0x53c>
  }
  else if(c == ASCII_BS)
    49f0:	08 30       	cpi	r16, 0x08	; 8
    49f2:	09 f0       	breq	.+2      	; 0x49f6 <cmdlineInputFunc+0x450>
    49f4:	6d c0       	rjmp	.+218    	; 0x4ad0 <cmdlineInputFunc+0x52a>
  {
    if(state->CmdlineBufferEditPos)
    49f6:	f7 01       	movw	r30, r14
    49f8:	86 85       	ldd	r24, Z+14	; 0x0e
    49fa:	88 23       	and	r24, r24
    49fc:	09 f4       	brne	.+2      	; 0x4a00 <cmdlineInputFunc+0x45a>
    49fe:	60 c0       	rjmp	.+192    	; 0x4ac0 <cmdlineInputFunc+0x51a>
    {
      // is this a simple delete (off the end of the line)
      if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    4a00:	95 85       	ldd	r25, Z+13	; 0x0d
    4a02:	89 17       	cp	r24, r25
    4a04:	31 f5       	brne	.+76     	; 0x4a52 <cmdlineInputFunc+0x4ac>
      {
        // destructive backspace
        // echo backspace-space-backspace
        fputc(ASCII_BS         , state->myStdInOut);
    4a06:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a08:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a0a:	88 e0       	ldi	r24, 0x08	; 8
    4a0c:	90 e0       	ldi	r25, 0x00	; 0
    4a0e:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        fputc(' '              , state->myStdInOut);
    4a12:	d7 01       	movw	r26, r14
    4a14:	5a 96       	adiw	r26, 0x1a	; 26
    4a16:	6d 91       	ld	r22, X+
    4a18:	7c 91       	ld	r23, X
    4a1a:	5b 97       	sbiw	r26, 0x1b	; 27
    4a1c:	80 e2       	ldi	r24, 0x20	; 32
    4a1e:	90 e0       	ldi	r25, 0x00	; 0
    4a20:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        fputc(ASCII_BS         , state->myStdInOut);
    4a24:	f7 01       	movw	r30, r14
    4a26:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a28:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a2a:	88 e0       	ldi	r24, 0x08	; 8
    4a2c:	90 e0       	ldi	r25, 0x00	; 0
    4a2e:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        // decrement our buffer length and edit position
        state->CmdlineBufferLength--;
    4a32:	d7 01       	movw	r26, r14
    4a34:	1d 96       	adiw	r26, 0x0d	; 13
    4a36:	8c 91       	ld	r24, X
    4a38:	1d 97       	sbiw	r26, 0x0d	; 13
    4a3a:	81 50       	subi	r24, 0x01	; 1
    4a3c:	1d 96       	adiw	r26, 0x0d	; 13
    4a3e:	8c 93       	st	X, r24
    4a40:	1d 97       	sbiw	r26, 0x0d	; 13
        state->CmdlineBufferEditPos--;
    4a42:	1e 96       	adiw	r26, 0x0e	; 14
    4a44:	8c 91       	ld	r24, X
    4a46:	1e 97       	sbiw	r26, 0x0e	; 14
    4a48:	81 50       	subi	r24, 0x01	; 1
    4a4a:	1e 96       	adiw	r26, 0x0e	; 14
    4a4c:	8c 93       	st	X, r24
    4a4e:	1e 97       	sbiw	r26, 0x0e	; 14
    4a50:	48 c0       	rjmp	.+144    	; 0x4ae2 <cmdlineInputFunc+0x53c>
      else
      {
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
    4a52:	91 50       	subi	r25, 0x01	; 1
    4a54:	f7 01       	movw	r30, r14
    4a56:	95 87       	std	Z+13, r25	; 0x0d
        state->CmdlineBufferEditPos--;
    4a58:	81 50       	subi	r24, 0x01	; 1
    4a5a:	86 87       	std	Z+14, r24	; 0x0e
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4a5c:	06 c0       	rjmp	.+12     	; 0x4a6a <cmdlineInputFunc+0x4c4>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
    4a5e:	fb 01       	movw	r30, r22
    4a60:	e8 0f       	add	r30, r24
    4a62:	f1 1d       	adc	r31, r1
    4a64:	91 81       	ldd	r25, Z+1	; 0x01
    4a66:	90 83       	st	Z, r25
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
        state->CmdlineBufferEditPos--;
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4a68:	8f 5f       	subi	r24, 0xFF	; 255
    4a6a:	d7 01       	movw	r26, r14
    4a6c:	1d 96       	adiw	r26, 0x0d	; 13
    4a6e:	9c 91       	ld	r25, X
    4a70:	1d 97       	sbiw	r26, 0x0d	; 13
    4a72:	6d 91       	ld	r22, X+
    4a74:	7c 91       	ld	r23, X
    4a76:	11 97       	sbiw	r26, 0x01	; 1
    4a78:	89 17       	cp	r24, r25
    4a7a:	88 f3       	brcs	.-30     	; 0x4a5e <cmdlineInputFunc+0x4b8>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
    4a7c:	c7 01       	movw	r24, r14
    4a7e:	0e 94 c4 21 	call	0x4388	; 0x4388 <cmdlineRepaint>
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
    4a82:	f7 01       	movw	r30, r14
    4a84:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a86:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a88:	80 e2       	ldi	r24, 0x20	; 32
    4a8a:	90 e0       	ldi	r25, 0x00	; 0
    4a8c:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4a90:	d7 01       	movw	r26, r14
    4a92:	1e 96       	adiw	r26, 0x0e	; 14
    4a94:	0c 91       	ld	r16, X
    4a96:	1e 97       	sbiw	r26, 0x0e	; 14
    4a98:	08 c0       	rjmp	.+16     	; 0x4aaa <cmdlineInputFunc+0x504>
          fputc(ASCII_BS       , state->myStdInOut);
    4a9a:	f7 01       	movw	r30, r14
    4a9c:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a9e:	73 8d       	ldd	r23, Z+27	; 0x1b
    4aa0:	88 e0       	ldi	r24, 0x08	; 8
    4aa2:	90 e0       	ldi	r25, 0x00	; 0
    4aa4:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4aa8:	0f 5f       	subi	r16, 0xFF	; 255
    4aaa:	d7 01       	movw	r26, r14
    4aac:	1d 96       	adiw	r26, 0x0d	; 13
    4aae:	2c 91       	ld	r18, X
    4ab0:	1d 97       	sbiw	r26, 0x0d	; 13
    4ab2:	30 e0       	ldi	r19, 0x00	; 0
    4ab4:	80 2f       	mov	r24, r16
    4ab6:	90 e0       	ldi	r25, 0x00	; 0
    4ab8:	28 17       	cp	r18, r24
    4aba:	39 07       	cpc	r19, r25
    4abc:	74 f7       	brge	.-36     	; 0x4a9a <cmdlineInputFunc+0x4f4>
    4abe:	11 c0       	rjmp	.+34     	; 0x4ae2 <cmdlineInputFunc+0x53c>
      }
    }
    else
    {
      // else, ring the bell
      fputc(ASCII_BEL          , state->myStdInOut);
    4ac0:	f7 01       	movw	r30, r14
    4ac2:	62 8d       	ldd	r22, Z+26	; 0x1a
    4ac4:	73 8d       	ldd	r23, Z+27	; 0x1b
    4ac6:	87 e0       	ldi	r24, 0x07	; 7
    4ac8:	90 e0       	ldi	r25, 0x00	; 0
    4aca:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    4ace:	09 c0       	rjmp	.+18     	; 0x4ae2 <cmdlineInputFunc+0x53c>
    }
  }
  else if(c == ASCII_DEL)
    4ad0:	0f 37       	cpi	r16, 0x7F	; 127
    4ad2:	39 f0       	breq	.+14     	; 0x4ae2 <cmdlineInputFunc+0x53c>
  {
    // not yet handled
  }
  else if(c == ASCII_ESC)
    4ad4:	0b 31       	cpi	r16, 0x1B	; 27
    4ad6:	29 f4       	brne	.+10     	; 0x4ae2 <cmdlineInputFunc+0x53c>
  {
    state->CmdlineInputVT100State = 1;
    4ad8:	81 e0       	ldi	r24, 0x01	; 1
    4ada:	d7 01       	movw	r26, r14
    4adc:	52 96       	adiw	r26, 0x12	; 18
    4ade:	8c 93       	st	X, r24
    4ae0:	52 97       	sbiw	r26, 0x12	; 18
  }
}
    4ae2:	26 96       	adiw	r28, 0x06	; 6
    4ae4:	cd bf       	out	0x3d, r28	; 61
    4ae6:	de bf       	out	0x3e, r29	; 62
    4ae8:	cf 91       	pop	r28
    4aea:	df 91       	pop	r29
    4aec:	1f 91       	pop	r17
    4aee:	0f 91       	pop	r16
    4af0:	ff 90       	pop	r15
    4af2:	ef 90       	pop	r14
    4af4:	df 90       	pop	r13
    4af6:	cf 90       	pop	r12
    4af8:	bf 90       	pop	r11
    4afa:	af 90       	pop	r10
    4afc:	9f 90       	pop	r9
    4afe:	8f 90       	pop	r8
    4b00:	08 95       	ret

00004b02 <cmdLineGetLastArgIdx>:
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
    4b02:	dc 01       	movw	r26, r24
    4b04:	12 96       	adiw	r26, 0x02	; 2
    4b06:	ed 91       	ld	r30, X+
    4b08:	fc 91       	ld	r31, X
    4b0a:	13 97       	sbiw	r26, 0x03	; 3
  uint8_t lastWhite = 1;
    4b0c:	91 e0       	ldi	r25, 0x01	; 1
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
    4b0e:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    4b10:	09 c0       	rjmp	.+18     	; 0x4b24 <cmdLineGetLastArgIdx+0x22>
  {
    if (*str == ' ')
    4b12:	20 32       	cpi	r18, 0x20	; 32
    4b14:	21 f4       	brne	.+8      	; 0x4b1e <cmdLineGetLastArgIdx+0x1c>
    {
      if (lastWhite == 0)
    4b16:	99 23       	and	r25, r25
    4b18:	21 f4       	brne	.+8      	; 0x4b22 <cmdLineGetLastArgIdx+0x20>
        result++;
    4b1a:	8f 5f       	subi	r24, 0xFF	; 255
    4b1c:	02 c0       	rjmp	.+4      	; 0x4b22 <cmdLineGetLastArgIdx+0x20>
      lastWhite = 1;
    }
    else
      lastWhite = 0;
    4b1e:	90 e0       	ldi	r25, 0x00	; 0
    4b20:	01 c0       	rjmp	.+2      	; 0x4b24 <cmdLineGetLastArgIdx+0x22>
  {
    if (*str == ' ')
    {
      if (lastWhite == 0)
        result++;
      lastWhite = 1;
    4b22:	91 e0       	ldi	r25, 0x01	; 1
uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    4b24:	21 91       	ld	r18, Z+
    4b26:	22 23       	and	r18, r18
    4b28:	a1 f7       	brne	.-24     	; 0x4b12 <cmdLineGetLastArgIdx+0x10>
    else
      lastWhite = 0;
    str++;
  }
  return result;
}
    4b2a:	08 95       	ret

00004b2c <cmdlineMainLoop>:
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
}

void cmdlineMainLoop(cmdState_t *state)
{
    4b2c:	0f 93       	push	r16
    4b2e:	1f 93       	push	r17
    4b30:	cf 93       	push	r28
    4b32:	df 93       	push	r29
    4b34:	ec 01       	movw	r28, r24
  cliExRes_t result;
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
    4b36:	0f 89       	ldd	r16, Y+23	; 0x17
    4b38:	18 8d       	ldd	r17, Y+24	; 0x18
    4b3a:	01 15       	cp	r16, r1
    4b3c:	11 05       	cpc	r17, r1
    4b3e:	09 f4       	brne	.+2      	; 0x4b42 <cmdlineMainLoop+0x16>
    4b40:	86 c0       	rjmp	.+268    	; 0x4c4e <cmdlineMainLoop+0x122>
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    4b42:	0e 94 81 25 	call	0x4b02	; 0x4b02 <cmdLineGetLastArgIdx>
    4b46:	89 8f       	std	Y+25, r24	; 0x19
    result = state->CmdlineExecFunction(state); // run it
    4b48:	ce 01       	movw	r24, r28
    4b4a:	f8 01       	movw	r30, r16
    4b4c:	19 95       	eicall
    
    switch(result)
    4b4e:	82 30       	cpi	r24, 0x02	; 2
    4b50:	91 05       	cpc	r25, r1
    4b52:	e1 f0       	breq	.+56     	; 0x4b8c <cmdlineMainLoop+0x60>
    4b54:	83 30       	cpi	r24, 0x03	; 3
    4b56:	91 05       	cpc	r25, r1
    4b58:	28 f4       	brcc	.+10     	; 0x4b64 <cmdlineMainLoop+0x38>
    4b5a:	81 30       	cpi	r24, 0x01	; 1
    4b5c:	91 05       	cpc	r25, r1
    4b5e:	09 f0       	breq	.+2      	; 0x4b62 <cmdlineMainLoop+0x36>
    4b60:	6d c0       	rjmp	.+218    	; 0x4c3c <cmdlineMainLoop+0x110>
    4b62:	09 c0       	rjmp	.+18     	; 0x4b76 <cmdlineMainLoop+0x4a>
    4b64:	84 30       	cpi	r24, 0x04	; 4
    4b66:	91 05       	cpc	r25, r1
    4b68:	09 f4       	brne	.+2      	; 0x4b6c <cmdlineMainLoop+0x40>
    4b6a:	4b c0       	rjmp	.+150    	; 0x4c02 <cmdlineMainLoop+0xd6>
    4b6c:	85 30       	cpi	r24, 0x05	; 5
    4b6e:	91 05       	cpc	r25, r1
    4b70:	09 f0       	breq	.+2      	; 0x4b74 <cmdlineMainLoop+0x48>
    4b72:	64 c0       	rjmp	.+200    	; 0x4c3c <cmdlineMainLoop+0x110>
    4b74:	51 c0       	rjmp	.+162    	; 0x4c18 <cmdlineMainLoop+0xec>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
    4b76:	00 d0       	rcall	.+0      	; 0x4b78 <cmdlineMainLoop+0x4c>
    4b78:	0f 92       	push	r0
    4b7a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4b7c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4b7e:	ed b7       	in	r30, 0x3d	; 61
    4b80:	fe b7       	in	r31, 0x3e	; 62
    4b82:	81 83       	std	Z+1, r24	; 0x01
    4b84:	92 83       	std	Z+2, r25	; 0x02
    4b86:	86 e6       	ldi	r24, 0x66	; 102
    4b88:	98 e0       	ldi	r25, 0x08	; 8
    4b8a:	50 c0       	rjmp	.+160    	; 0x4c2c <cmdlineMainLoop+0x100>
        break;
      case SYNTAX_ERROR:
        fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
    4b8c:	00 d0       	rcall	.+0      	; 0x4b8e <cmdlineMainLoop+0x62>
    4b8e:	0f 92       	push	r0
    4b90:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4b92:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4b94:	ed b7       	in	r30, 0x3d	; 61
    4b96:	fe b7       	in	r31, 0x3e	; 62
    4b98:	81 83       	std	Z+1, r24	; 0x01
    4b9a:	92 83       	std	Z+2, r25	; 0x02
    4b9c:	82 e5       	ldi	r24, 0x52	; 82
    4b9e:	98 e0       	ldi	r25, 0x08	; 8
    4ba0:	83 83       	std	Z+3, r24	; 0x03
    4ba2:	94 83       	std	Z+4, r25	; 0x04
    4ba4:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_str);
    4ba8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4baa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4bac:	ed b7       	in	r30, 0x3d	; 61
    4bae:	fe b7       	in	r31, 0x3e	; 62
    4bb0:	81 83       	std	Z+1, r24	; 0x01
    4bb2:	92 83       	std	Z+2, r25	; 0x02
    4bb4:	8b 89       	ldd	r24, Y+19	; 0x13
    4bb6:	9c 89       	ldd	r25, Y+20	; 0x14
    4bb8:	83 83       	std	Z+3, r24	; 0x03
    4bba:	94 83       	std	Z+4, r25	; 0x04
    4bbc:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR(" "));
    4bc0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4bc2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4bc4:	ed b7       	in	r30, 0x3d	; 61
    4bc6:	fe b7       	in	r31, 0x3e	; 62
    4bc8:	81 83       	std	Z+1, r24	; 0x01
    4bca:	92 83       	std	Z+2, r25	; 0x02
    4bcc:	80 e5       	ldi	r24, 0x50	; 80
    4bce:	98 e0       	ldi	r25, 0x08	; 8
    4bd0:	83 83       	std	Z+3, r24	; 0x03
    4bd2:	94 83       	std	Z+4, r25	; 0x04
    4bd4:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_help_str);
    4bd8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4bda:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4bdc:	ed b7       	in	r30, 0x3d	; 61
    4bde:	fe b7       	in	r31, 0x3e	; 62
    4be0:	81 83       	std	Z+1, r24	; 0x01
    4be2:	92 83       	std	Z+2, r25	; 0x02
    4be4:	8d 89       	ldd	r24, Y+21	; 0x15
    4be6:	9e 89       	ldd	r25, Y+22	; 0x16
    4be8:	83 83       	std	Z+3, r24	; 0x03
    4bea:	94 83       	std	Z+4, r25	; 0x04
    4bec:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4bf0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4bf2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4bf4:	ed b7       	in	r30, 0x3d	; 61
    4bf6:	fe b7       	in	r31, 0x3e	; 62
    4bf8:	81 83       	std	Z+1, r24	; 0x01
    4bfa:	92 83       	std	Z+2, r25	; 0x02
    4bfc:	8d e4       	ldi	r24, 0x4D	; 77
    4bfe:	98 e0       	ldi	r25, 0x08	; 8
    4c00:	15 c0       	rjmp	.+42     	; 0x4c2c <cmdlineMainLoop+0x100>
        break;
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
    4c02:	00 d0       	rcall	.+0      	; 0x4c04 <cmdlineMainLoop+0xd8>
    4c04:	0f 92       	push	r0
    4c06:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c08:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c0a:	ed b7       	in	r30, 0x3d	; 61
    4c0c:	fe b7       	in	r31, 0x3e	; 62
    4c0e:	81 83       	std	Z+1, r24	; 0x01
    4c10:	92 83       	std	Z+2, r25	; 0x02
    4c12:	8a e3       	ldi	r24, 0x3A	; 58
    4c14:	98 e0       	ldi	r25, 0x08	; 8
    4c16:	0a c0       	rjmp	.+20     	; 0x4c2c <cmdlineMainLoop+0x100>
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    4c18:	00 d0       	rcall	.+0      	; 0x4c1a <cmdlineMainLoop+0xee>
    4c1a:	0f 92       	push	r0
    4c1c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c1e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c20:	ed b7       	in	r30, 0x3d	; 61
    4c22:	fe b7       	in	r31, 0x3e	; 62
    4c24:	81 83       	std	Z+1, r24	; 0x01
    4c26:	92 83       	std	Z+2, r25	; 0x02
    4c28:	82 e2       	ldi	r24, 0x22	; 34
    4c2a:	98 e0       	ldi	r25, 0x08	; 8
    4c2c:	83 83       	std	Z+3, r24	; 0x03
    4c2e:	94 83       	std	Z+4, r25	; 0x04
    4c30:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
        break;
    4c34:	0f 90       	pop	r0
    4c36:	0f 90       	pop	r0
    4c38:	0f 90       	pop	r0
    4c3a:	0f 90       	pop	r0
      default:
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    4c3c:	1f 8a       	std	Y+23, r1	; 0x17
    4c3e:	18 8e       	std	Y+24, r1	; 0x18
    state->command_str         = NULL;
    4c40:	1b 8a       	std	Y+19, r1	; 0x13
    4c42:	1c 8a       	std	Y+20, r1	; 0x14
    state->command_help_str    = NULL;
    4c44:	1d 8a       	std	Y+21, r1	; 0x15
    4c46:	1e 8a       	std	Y+22, r1	; 0x16
    cmdlinePrintPrompt(state);                  // output new prompt
    4c48:	ce 01       	movw	r24, r28
    4c4a:	0e 94 99 21 	call	0x4332	; 0x4332 <cmdlinePrintPrompt>
  }
}
    4c4e:	df 91       	pop	r29
    4c50:	cf 91       	pop	r28
    4c52:	1f 91       	pop	r17
    4c54:	0f 91       	pop	r16
    4c56:	08 95       	ret

00004c58 <cmdlineGetArgStr>:
  // find the offset of argument number [argnum]
  uint8_t idx=0;
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4c58:	fb 01       	movw	r30, r22
    4c5a:	22 81       	ldd	r18, Z+2	; 0x02
    4c5c:	33 81       	ldd	r19, Z+3	; 0x03
}

char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
{
  // find the offset of argument number [argnum]
  uint8_t idx=0;
    4c5e:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4c60:	01 c0       	rjmp	.+2      	; 0x4c64 <cmdlineGetArgStr+0xc>
    4c62:	9f 5f       	subi	r25, 0xFF	; 255
    4c64:	f9 01       	movw	r30, r18
    4c66:	e9 0f       	add	r30, r25
    4c68:	f1 1d       	adc	r31, r1
    4c6a:	40 81       	ld	r20, Z
    4c6c:	40 32       	cpi	r20, 0x20	; 32
    4c6e:	c9 f3       	breq	.-14     	; 0x4c62 <cmdlineGetArgStr+0xa>
    4c70:	40 e0       	ldi	r20, 0x00	; 0
    4c72:	12 c0       	rjmp	.+36     	; 0x4c98 <cmdlineGetArgStr+0x40>
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
  {
    // find the next whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    4c74:	9f 5f       	subi	r25, 0xFF	; 255
    4c76:	f9 01       	movw	r30, r18
    4c78:	e9 0f       	add	r30, r25
    4c7a:	f1 1d       	adc	r31, r1
    4c7c:	50 81       	ld	r21, Z
    4c7e:	55 23       	and	r21, r21
    4c80:	21 f0       	breq	.+8      	; 0x4c8a <cmdlineGetArgStr+0x32>
    4c82:	50 32       	cpi	r21, 0x20	; 32
    4c84:	b9 f7       	brne	.-18     	; 0x4c74 <cmdlineGetArgStr+0x1c>
    4c86:	01 c0       	rjmp	.+2      	; 0x4c8a <cmdlineGetArgStr+0x32>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4c88:	9f 5f       	subi	r25, 0xFF	; 255
    4c8a:	f9 01       	movw	r30, r18
    4c8c:	e9 0f       	add	r30, r25
    4c8e:	f1 1d       	adc	r31, r1
    4c90:	50 81       	ld	r21, Z
    4c92:	50 32       	cpi	r21, 0x20	; 32
    4c94:	c9 f3       	breq	.-14     	; 0x4c88 <cmdlineGetArgStr+0x30>
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    4c96:	4f 5f       	subi	r20, 0xFF	; 255
    4c98:	48 17       	cp	r20, r24
    4c9a:	68 f3       	brcs	.-38     	; 0x4c76 <cmdlineGetArgStr+0x1e>
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  }
  // we are at the requested argument or the end of the buffer
  return &state->CmdlineExcBuffer[idx];
    4c9c:	29 0f       	add	r18, r25
    4c9e:	31 1d       	adc	r19, r1
}
    4ca0:	c9 01       	movw	r24, r18
    4ca2:	08 95       	ret

00004ca4 <cmdlineGetArgInt>:

// return argument [argnum] interpreted as a decimal integer
long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
{
    4ca4:	df 93       	push	r29
    4ca6:	cf 93       	push	r28
    4ca8:	0f 92       	push	r0
    4caa:	0f 92       	push	r0
    4cac:	cd b7       	in	r28, 0x3d	; 61
    4cae:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
    4cb0:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    4cb4:	be 01       	movw	r22, r28
    4cb6:	6f 5f       	subi	r22, 0xFF	; 255
    4cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    4cba:	4a e0       	ldi	r20, 0x0A	; 10
    4cbc:	50 e0       	ldi	r21, 0x00	; 0
    4cbe:	0e 94 64 55 	call	0xaac8	; 0xaac8 <strtol>
}
    4cc2:	0f 90       	pop	r0
    4cc4:	0f 90       	pop	r0
    4cc6:	cf 91       	pop	r28
    4cc8:	df 91       	pop	r29
    4cca:	08 95       	ret

00004ccc <cmdlineGetArgHex>:

// return argument [argnum] interpreted as a hex integer
long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
{
    4ccc:	df 93       	push	r29
    4cce:	cf 93       	push	r28
    4cd0:	0f 92       	push	r0
    4cd2:	0f 92       	push	r0
    4cd4:	cd b7       	in	r28, 0x3d	; 61
    4cd6:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
    4cd8:	0e 94 2c 26 	call	0x4c58	; 0x4c58 <cmdlineGetArgStr>
    4cdc:	be 01       	movw	r22, r28
    4cde:	6f 5f       	subi	r22, 0xFF	; 255
    4ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    4ce2:	40 e1       	ldi	r20, 0x10	; 16
    4ce4:	50 e0       	ldi	r21, 0x00	; 0
    4ce6:	0e 94 64 55 	call	0xaac8	; 0xaac8 <strtol>
}
    4cea:	0f 90       	pop	r0
    4cec:	0f 90       	pop	r0
    4cee:	cf 91       	pop	r28
    4cf0:	df 91       	pop	r29
    4cf2:	08 95       	ret

00004cf4 <cmdPrintHelp>:

void cmdPrintHelp(cmdState_t *state)
{
    4cf4:	8f 92       	push	r8
    4cf6:	9f 92       	push	r9
    4cf8:	af 92       	push	r10
    4cfa:	bf 92       	push	r11
    4cfc:	cf 92       	push	r12
    4cfe:	df 92       	push	r13
    4d00:	ef 92       	push	r14
    4d02:	ff 92       	push	r15
    4d04:	0f 93       	push	r16
    4d06:	1f 93       	push	r17
    4d08:	df 93       	push	r29
    4d0a:	cf 93       	push	r28
    4d0c:	00 d0       	rcall	.+0      	; 0x4d0e <cmdPrintHelp+0x1a>
    4d0e:	00 d0       	rcall	.+0      	; 0x4d10 <cmdPrintHelp+0x1c>
    4d10:	cd b7       	in	r28, 0x3d	; 61
    4d12:	de b7       	in	r29, 0x3e	; 62
    4d14:	8c 01       	movw	r16, r24
  command_t  tmp;
  const command_t *tmpPtr = state->cmdList;
    4d16:	fc 01       	movw	r30, r24
    4d18:	e1 a0       	ldd	r14, Z+33	; 0x21
    4d1a:	f2 a0       	ldd	r15, Z+34	; 0x22
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4d1c:	6e 01       	movw	r12, r28
    4d1e:	08 94       	sec
    4d20:	c1 1c       	adc	r12, r1
    4d22:	d1 1c       	adc	r13, r1
    4d24:	c6 01       	movw	r24, r12
    4d26:	b7 01       	movw	r22, r14
    4d28:	46 e0       	ldi	r20, 0x06	; 6
    4d2a:	50 e0       	ldi	r21, 0x00	; 0
    4d2c:	0e 94 a9 56 	call	0xad52	; 0xad52 <memcpy_P>
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4d30:	90 e2       	ldi	r25, 0x20	; 32
    4d32:	a9 2e       	mov	r10, r25
    4d34:	98 e0       	ldi	r25, 0x08	; 8
    4d36:	b9 2e       	mov	r11, r25
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4d38:	8d e1       	ldi	r24, 0x1D	; 29
    4d3a:	88 2e       	mov	r8, r24
    4d3c:	88 e0       	ldi	r24, 0x08	; 8
    4d3e:	98 2e       	mov	r9, r24

    tmpPtr++;
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4d40:	c6 01       	movw	r24, r12
    4d42:	dc 2c       	mov	r13, r12
    4d44:	c9 2e       	mov	r12, r25
  const command_t *tmpPtr = state->cmdList;
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    4d46:	00 d0       	rcall	.+0      	; 0x4d48 <cmdPrintHelp+0x54>
    4d48:	0f 92       	push	r0
    4d4a:	f8 01       	movw	r30, r16
    4d4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d4e:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d50:	ed b7       	in	r30, 0x3d	; 61
    4d52:	fe b7       	in	r31, 0x3e	; 62
    4d54:	81 83       	std	Z+1, r24	; 0x01
    4d56:	92 83       	std	Z+2, r25	; 0x02
    4d58:	89 81       	ldd	r24, Y+1	; 0x01
    4d5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d5c:	83 83       	std	Z+3, r24	; 0x03
    4d5e:	94 83       	std	Z+4, r25	; 0x04
    4d60:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4d64:	f8 01       	movw	r30, r16
    4d66:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d68:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d6a:	ed b7       	in	r30, 0x3d	; 61
    4d6c:	fe b7       	in	r31, 0x3e	; 62
    4d6e:	81 83       	std	Z+1, r24	; 0x01
    4d70:	92 83       	std	Z+2, r25	; 0x02
    4d72:	a3 82       	std	Z+3, r10	; 0x03
    4d74:	b4 82       	std	Z+4, r11	; 0x04
    4d76:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    4d7a:	f8 01       	movw	r30, r16
    4d7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d7e:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d80:	ed b7       	in	r30, 0x3d	; 61
    4d82:	fe b7       	in	r31, 0x3e	; 62
    4d84:	81 83       	std	Z+1, r24	; 0x01
    4d86:	92 83       	std	Z+2, r25	; 0x02
    4d88:	8b 81       	ldd	r24, Y+3	; 0x03
    4d8a:	9c 81       	ldd	r25, Y+4	; 0x04
    4d8c:	83 83       	std	Z+3, r24	; 0x03
    4d8e:	94 83       	std	Z+4, r25	; 0x04
    4d90:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4d94:	f8 01       	movw	r30, r16
    4d96:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d98:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d9a:	ed b7       	in	r30, 0x3d	; 61
    4d9c:	fe b7       	in	r31, 0x3e	; 62
    4d9e:	81 83       	std	Z+1, r24	; 0x01
    4da0:	92 83       	std	Z+2, r25	; 0x02
    4da2:	83 82       	std	Z+3, r8	; 0x03
    4da4:	94 82       	std	Z+4, r9	; 0x04
    4da6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>

    tmpPtr++;
    4daa:	86 e0       	ldi	r24, 0x06	; 6
    4dac:	90 e0       	ldi	r25, 0x00	; 0
    4dae:	e8 0e       	add	r14, r24
    4db0:	f9 1e       	adc	r15, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4db2:	0f 90       	pop	r0
    4db4:	0f 90       	pop	r0
    4db6:	0f 90       	pop	r0
    4db8:	0f 90       	pop	r0
    4dba:	8d 2d       	mov	r24, r13
    4dbc:	9c 2d       	mov	r25, r12
    4dbe:	b7 01       	movw	r22, r14
    4dc0:	46 e0       	ldi	r20, 0x06	; 6
    4dc2:	50 e0       	ldi	r21, 0x00	; 0
    4dc4:	0e 94 a9 56 	call	0xad52	; 0xad52 <memcpy_P>
  }
  while (tmp.commandFun != NULL);
    4dc8:	8d 81       	ldd	r24, Y+5	; 0x05
    4dca:	9e 81       	ldd	r25, Y+6	; 0x06
    4dcc:	00 97       	sbiw	r24, 0x00	; 0
    4dce:	09 f0       	breq	.+2      	; 0x4dd2 <cmdPrintHelp+0xde>
    4dd0:	ba cf       	rjmp	.-140    	; 0x4d46 <cmdPrintHelp+0x52>
}
    4dd2:	26 96       	adiw	r28, 0x06	; 6
    4dd4:	cd bf       	out	0x3d, r28	; 61
    4dd6:	de bf       	out	0x3e, r29	; 62
    4dd8:	cf 91       	pop	r28
    4dda:	df 91       	pop	r29
    4ddc:	1f 91       	pop	r17
    4dde:	0f 91       	pop	r16
    4de0:	ff 90       	pop	r15
    4de2:	ef 90       	pop	r14
    4de4:	df 90       	pop	r13
    4de6:	cf 90       	pop	r12
    4de8:	bf 90       	pop	r11
    4dea:	af 90       	pop	r10
    4dec:	9f 90       	pop	r9
    4dee:	8f 90       	pop	r8
    4df0:	08 95       	ret

00004df2 <vt100Init>:
void vt100Init(cmdState_t *state)
{
  // initializes terminal to "power-on" settings
  // ESC c

 fprintf_P(state->myStdInOut, "\x1B\x63");
    4df2:	00 d0       	rcall	.+0      	; 0x4df4 <vt100Init+0x2>
    4df4:	0f 92       	push	r0
    4df6:	fc 01       	movw	r30, r24
    4df8:	82 8d       	ldd	r24, Z+26	; 0x1a
    4dfa:	93 8d       	ldd	r25, Z+27	; 0x1b
    4dfc:	ed b7       	in	r30, 0x3d	; 61
    4dfe:	fe b7       	in	r31, 0x3e	; 62
    4e00:	81 83       	std	Z+1, r24	; 0x01
    4e02:	92 83       	std	Z+2, r25	; 0x02
    4e04:	8d ed       	ldi	r24, 0xDD	; 221
    4e06:	94 e2       	ldi	r25, 0x24	; 36
    4e08:	83 83       	std	Z+3, r24	; 0x03
    4e0a:	94 83       	std	Z+4, r25	; 0x04
    4e0c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    4e10:	0f 90       	pop	r0
    4e12:	0f 90       	pop	r0
    4e14:	0f 90       	pop	r0
    4e16:	0f 90       	pop	r0
}
    4e18:	08 95       	ret

00004e1a <vt100ClearScreen>:

void vt100ClearScreen(cmdState_t *state)
{
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
    4e1a:	00 d0       	rcall	.+0      	; 0x4e1c <vt100ClearScreen+0x2>
    4e1c:	0f 92       	push	r0
    4e1e:	fc 01       	movw	r30, r24
    4e20:	82 8d       	ldd	r24, Z+26	; 0x1a
    4e22:	93 8d       	ldd	r25, Z+27	; 0x1b
    4e24:	ed b7       	in	r30, 0x3d	; 61
    4e26:	fe b7       	in	r31, 0x3e	; 62
    4e28:	81 83       	std	Z+1, r24	; 0x01
    4e2a:	92 83       	std	Z+2, r25	; 0x02
    4e2c:	80 ee       	ldi	r24, 0xE0	; 224
    4e2e:	94 e2       	ldi	r25, 0x24	; 36
    4e30:	83 83       	std	Z+3, r24	; 0x03
    4e32:	94 83       	std	Z+4, r25	; 0x04
    4e34:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    4e38:	0f 90       	pop	r0
    4e3a:	0f 90       	pop	r0
    4e3c:	0f 90       	pop	r0
    4e3e:	0f 90       	pop	r0
}
    4e40:	08 95       	ret

00004e42 <vt100SetAttr>:

void vt100SetAttr(uint8_t attr, cmdState_t *state)
{
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
    4e42:	00 d0       	rcall	.+0      	; 0x4e44 <vt100SetAttr+0x2>
    4e44:	00 d0       	rcall	.+0      	; 0x4e46 <vt100SetAttr+0x4>
    4e46:	ed b7       	in	r30, 0x3d	; 61
    4e48:	fe b7       	in	r31, 0x3e	; 62
    4e4a:	31 96       	adiw	r30, 0x01	; 1
    4e4c:	db 01       	movw	r26, r22
    4e4e:	5a 96       	adiw	r26, 0x1a	; 26
    4e50:	2d 91       	ld	r18, X+
    4e52:	3c 91       	ld	r19, X
    4e54:	5b 97       	sbiw	r26, 0x1b	; 27
    4e56:	ad b7       	in	r26, 0x3d	; 61
    4e58:	be b7       	in	r27, 0x3e	; 62
    4e5a:	11 96       	adiw	r26, 0x01	; 1
    4e5c:	2d 93       	st	X+, r18
    4e5e:	3c 93       	st	X, r19
    4e60:	12 97       	sbiw	r26, 0x02	; 2
    4e62:	25 ee       	ldi	r18, 0xE5	; 229
    4e64:	34 e2       	ldi	r19, 0x24	; 36
    4e66:	22 83       	std	Z+2, r18	; 0x02
    4e68:	33 83       	std	Z+3, r19	; 0x03
    4e6a:	84 83       	std	Z+4, r24	; 0x04
    4e6c:	15 82       	std	Z+5, r1	; 0x05
    4e6e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    4e72:	8d b7       	in	r24, 0x3d	; 61
    4e74:	9e b7       	in	r25, 0x3e	; 62
    4e76:	06 96       	adiw	r24, 0x06	; 6
    4e78:	8d bf       	out	0x3d, r24	; 61
    4e7a:	9e bf       	out	0x3e, r25	; 62
}
    4e7c:	08 95       	ret

00004e7e <vt100SetCursorMode>:

void vt100SetCursorMode(uint8_t visible, cmdState_t *state)
{
    4e7e:	fb 01       	movw	r30, r22
    4e80:	22 8d       	ldd	r18, Z+26	; 0x1a
    4e82:	33 8d       	ldd	r19, Z+27	; 0x1b
  if(visible)
    4e84:	88 23       	and	r24, r24
    4e86:	49 f0       	breq	.+18     	; 0x4e9a <vt100SetCursorMode+0x1c>
  // ESC [ ? 25 h
    fprintf_P(state->myStdInOut, "\x1B[?25h");
    4e88:	00 d0       	rcall	.+0      	; 0x4e8a <vt100SetCursorMode+0xc>
    4e8a:	0f 92       	push	r0
    4e8c:	ed b7       	in	r30, 0x3d	; 61
    4e8e:	fe b7       	in	r31, 0x3e	; 62
    4e90:	21 83       	std	Z+1, r18	; 0x01
    4e92:	32 83       	std	Z+2, r19	; 0x02
    4e94:	8b ee       	ldi	r24, 0xEB	; 235
    4e96:	94 e2       	ldi	r25, 0x24	; 36
    4e98:	08 c0       	rjmp	.+16     	; 0x4eaa <vt100SetCursorMode+0x2c>
  else
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
    4e9a:	00 d0       	rcall	.+0      	; 0x4e9c <vt100SetCursorMode+0x1e>
    4e9c:	0f 92       	push	r0
    4e9e:	ed b7       	in	r30, 0x3d	; 61
    4ea0:	fe b7       	in	r31, 0x3e	; 62
    4ea2:	21 83       	std	Z+1, r18	; 0x01
    4ea4:	32 83       	std	Z+2, r19	; 0x02
    4ea6:	82 ef       	ldi	r24, 0xF2	; 242
    4ea8:	94 e2       	ldi	r25, 0x24	; 36
    4eaa:	83 83       	std	Z+3, r24	; 0x03
    4eac:	94 83       	std	Z+4, r25	; 0x04
    4eae:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    4eb2:	0f 90       	pop	r0
    4eb4:	0f 90       	pop	r0
    4eb6:	0f 90       	pop	r0
    4eb8:	0f 90       	pop	r0
    4eba:	08 95       	ret

00004ebc <vt100SetCursorPos>:
}

void vt100SetCursorPos(uint8_t line, uint8_t col, cmdState_t *state)
{
  // ESC [ Pl ; Pc H
  fprintf_P(state->myStdInOut, "\x1B[%d;%dH",line,col);
    4ebc:	2d b7       	in	r18, 0x3d	; 61
    4ebe:	3e b7       	in	r19, 0x3e	; 62
    4ec0:	28 50       	subi	r18, 0x08	; 8
    4ec2:	30 40       	sbci	r19, 0x00	; 0
    4ec4:	2d bf       	out	0x3d, r18	; 61
    4ec6:	3e bf       	out	0x3e, r19	; 62
    4ec8:	ed b7       	in	r30, 0x3d	; 61
    4eca:	fe b7       	in	r31, 0x3e	; 62
    4ecc:	31 96       	adiw	r30, 0x01	; 1
    4ece:	da 01       	movw	r26, r20
    4ed0:	5a 96       	adiw	r26, 0x1a	; 26
    4ed2:	2d 91       	ld	r18, X+
    4ed4:	3c 91       	ld	r19, X
    4ed6:	5b 97       	sbiw	r26, 0x1b	; 27
    4ed8:	ad b7       	in	r26, 0x3d	; 61
    4eda:	be b7       	in	r27, 0x3e	; 62
    4edc:	11 96       	adiw	r26, 0x01	; 1
    4ede:	2d 93       	st	X+, r18
    4ee0:	3c 93       	st	X, r19
    4ee2:	12 97       	sbiw	r26, 0x02	; 2
    4ee4:	29 ef       	ldi	r18, 0xF9	; 249
    4ee6:	34 e2       	ldi	r19, 0x24	; 36
    4ee8:	22 83       	std	Z+2, r18	; 0x02
    4eea:	33 83       	std	Z+3, r19	; 0x03
    4eec:	84 83       	std	Z+4, r24	; 0x04
    4eee:	15 82       	std	Z+5, r1	; 0x05
    4ef0:	66 83       	std	Z+6, r22	; 0x06
    4ef2:	17 82       	std	Z+7, r1	; 0x07
    4ef4:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    4ef8:	2d b7       	in	r18, 0x3d	; 61
    4efa:	3e b7       	in	r19, 0x3e	; 62
    4efc:	28 5f       	subi	r18, 0xF8	; 248
    4efe:	3f 4f       	sbci	r19, 0xFF	; 255
    4f00:	2d bf       	out	0x3d, r18	; 61
    4f02:	3e bf       	out	0x3e, r19	; 62
}
    4f04:	08 95       	ret
    4f06:	08 95       	ret
    4f08:	08 95       	ret

00004f0a <readTimeBCD>:
void spiEnableDS1305(void)  {};
void spiDisableDS1305(void) {};


void readTimeBCD(timeBCD_t *time)
{
    4f0a:	ef 92       	push	r14
    4f0c:	ff 92       	push	r15
    4f0e:	1f 93       	push	r17
    4f10:	df 93       	push	r29
    4f12:	cf 93       	push	r28
    4f14:	0f 92       	push	r0
    4f16:	0f 92       	push	r0
    4f18:	cd b7       	in	r28, 0x3d	; 61
    4f1a:	de b7       	in	r29, 0x3e	; 62
  spiTake();
    4f1c:	89 83       	std	Y+1, r24	; 0x01
    4f1e:	9a 83       	std	Y+2, r25	; 0x02
    4f20:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  spiEnableDS1305();
    4f24:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    4f28:	89 81       	ldd	r24, Y+1	; 0x01
    4f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f2c:	48 2f       	mov	r20, r24
    4f2e:	59 2f       	mov	r21, r25
    4f30:	7a 01       	movw	r14, r20
  uint8_t i;
  
  spiSend(0x00);
    4f32:	80 e0       	ldi	r24, 0x00	; 0
    4f34:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  for (i=0; i<sizeof(timeBCD_t); i++)
    4f38:	10 e0       	ldi	r17, 0x00	; 0
  {
    *ptr = spiSend(i);
    4f3a:	81 2f       	mov	r24, r17
    4f3c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    4f40:	f7 01       	movw	r30, r14
    4f42:	81 93       	st	Z+, r24
    4f44:	7f 01       	movw	r14, r30
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);

  for (i=0; i<sizeof(timeBCD_t); i++)
    4f46:	1f 5f       	subi	r17, 0xFF	; 255
    4f48:	17 30       	cpi	r17, 0x07	; 7
    4f4a:	b9 f7       	brne	.-18     	; 0x4f3a <readTimeBCD+0x30>
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
    4f4c:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    4f50:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    4f54:	0f 90       	pop	r0
    4f56:	0f 90       	pop	r0
    4f58:	cf 91       	pop	r28
    4f5a:	df 91       	pop	r29
    4f5c:	1f 91       	pop	r17
    4f5e:	ff 90       	pop	r15
    4f60:	ef 90       	pop	r14
    4f62:	08 95       	ret

00004f64 <readTimeDecoded>:

#if USE_DECODED_TIME_STRUCT
void readTimeDecoded(timeDecoded_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4f64:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <readTimeBCD>
}
    4f68:	08 95       	ret

00004f6a <readTime>:
void readTime (time_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4f6a:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <readTimeBCD>
}
    4f6e:	08 95       	ret

00004f70 <setTimeBCD>:
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
{
    4f70:	ef 92       	push	r14
    4f72:	ff 92       	push	r15
    4f74:	0f 93       	push	r16
    4f76:	1f 93       	push	r17
    4f78:	df 93       	push	r29
    4f7a:	cf 93       	push	r28
    4f7c:	0f 92       	push	r0
    4f7e:	0f 92       	push	r0
    4f80:	cd b7       	in	r28, 0x3d	; 61
    4f82:	de b7       	in	r29, 0x3e	; 62
  spiTake();
    4f84:	89 83       	std	Y+1, r24	; 0x01
    4f86:	9a 83       	std	Y+2, r25	; 0x02
    4f88:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  spiEnableDS1305();
    4f8c:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    4f90:	89 81       	ldd	r24, Y+1	; 0x01
    4f92:	48 2f       	mov	r20, r24
    4f94:	9a 81       	ldd	r25, Y+2	; 0x02
    4f96:	59 2f       	mov	r21, r25
    4f98:	7a 01       	movw	r14, r20
  uint8_t i;
  spiSend(0x80);
    4f9a:	80 e8       	ldi	r24, 0x80	; 128
    4f9c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  readTimeBCD((timeBCD_t *)(time));
}
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
    4fa0:	87 01       	movw	r16, r14
    4fa2:	09 5f       	subi	r16, 0xF9	; 249
    4fa4:	1f 4f       	sbci	r17, 0xFF	; 255
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    spiSend(*ptr);
    4fa6:	f7 01       	movw	r30, r14
    4fa8:	81 91       	ld	r24, Z+
    4faa:	7f 01       	movw	r14, r30
    4fac:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiEnableDS1305();
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
    4fb0:	e0 16       	cp	r14, r16
    4fb2:	f1 06       	cpc	r15, r17
    4fb4:	c1 f7       	brne	.-16     	; 0x4fa6 <setTimeBCD+0x36>
  {
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
    4fb6:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    4fba:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    4fbe:	0f 90       	pop	r0
    4fc0:	0f 90       	pop	r0
    4fc2:	cf 91       	pop	r28
    4fc4:	df 91       	pop	r29
    4fc6:	1f 91       	pop	r17
    4fc8:	0f 91       	pop	r16
    4fca:	ff 90       	pop	r15
    4fcc:	ef 90       	pop	r14
    4fce:	08 95       	ret

00004fd0 <setTimeDecoded>:

#if USE_DECODED_TIME_STRUCT
void setTimeDecoded(timeDecoded_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    4fd0:	0e 94 b8 27 	call	0x4f70	; 0x4f70 <setTimeBCD>
}
    4fd4:	08 95       	ret

00004fd6 <setTime>:
void setTime(time_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    4fd6:	0e 94 b8 27 	call	0x4f70	; 0x4f70 <setTimeBCD>
}
    4fda:	08 95       	ret

00004fdc <ds1305start>:
#endif /* USE_DECODED_TIME_STRUCT */

void ds1305start(void)
{  
  spiTake();
    4fdc:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  spiEnableDS1305();
    4fe0:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>

  spiSend(0x8F);
    4fe4:	8f e8       	ldi	r24, 0x8F	; 143
    4fe6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(0x00);
    4fea:	80 e0       	ldi	r24, 0x00	; 0
    4fec:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  spiDisableDS1305();  
    4ff0:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    4ff4:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>

  return;
}
    4ff8:	08 95       	ret

00004ffa <ds1305writeMem>:


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
    4ffa:	ef 92       	push	r14
    4ffc:	ff 92       	push	r15
    4ffe:	1f 93       	push	r17
    5000:	df 93       	push	r29
    5002:	cf 93       	push	r28
    5004:	0f 92       	push	r0
    5006:	cd b7       	in	r28, 0x3d	; 61
    5008:	de b7       	in	r29, 0x3e	; 62
    500a:	16 2f       	mov	r17, r22
    500c:	7a 01       	movw	r14, r20
  if (addr > 95)
    500e:	80 36       	cpi	r24, 0x60	; 96
    5010:	f8 f4       	brcc	.+62     	; 0x5050 <ds1305writeMem+0x56>
    return 1;
  if (addr + length > 95)
    5012:	28 2f       	mov	r18, r24
    5014:	30 e0       	ldi	r19, 0x00	; 0
    5016:	26 0f       	add	r18, r22
    5018:	31 1d       	adc	r19, r1
    501a:	20 36       	cpi	r18, 0x60	; 96
    501c:	31 05       	cpc	r19, r1
    501e:	d4 f4       	brge	.+52     	; 0x5054 <ds1305writeMem+0x5a>
    return 2;

  addr += 0xA0;
  
  spiTake();
    5020:	89 83       	std	Y+1, r24	; 0x01
    5022:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  spiEnableDS1305();
    5026:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>

  spiSend(addr);
    502a:	89 81       	ldd	r24, Y+1	; 0x01
    502c:	80 56       	subi	r24, 0x60	; 96
    502e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  while (length > 0)
    5032:	06 c0       	rjmp	.+12     	; 0x5040 <ds1305writeMem+0x46>
  {
    spiSend(*data);
    5034:	f7 01       	movw	r30, r14
    5036:	81 91       	ld	r24, Z+
    5038:	7f 01       	movw	r14, r30
    503a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    data++;
    length--;
    503e:	11 50       	subi	r17, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    5040:	11 23       	and	r17, r17
    5042:	c1 f7       	brne	.-16     	; 0x5034 <ds1305writeMem+0x3a>
    spiSend(*data);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    5044:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    5048:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
  return 0;
    504c:	80 e0       	ldi	r24, 0x00	; 0
    504e:	03 c0       	rjmp	.+6      	; 0x5056 <ds1305writeMem+0x5c>


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr > 95)
    return 1;
    5050:	81 e0       	ldi	r24, 0x01	; 1
    5052:	01 c0       	rjmp	.+2      	; 0x5056 <ds1305writeMem+0x5c>
  if (addr + length > 95)
    return 2;
    5054:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    5056:	0f 90       	pop	r0
    5058:	cf 91       	pop	r28
    505a:	df 91       	pop	r29
    505c:	1f 91       	pop	r17
    505e:	ff 90       	pop	r15
    5060:	ef 90       	pop	r14
    5062:	08 95       	ret

00005064 <ds1305readMem>:
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
    5064:	ef 92       	push	r14
    5066:	ff 92       	push	r15
    5068:	1f 93       	push	r17
    506a:	df 93       	push	r29
    506c:	cf 93       	push	r28
    506e:	0f 92       	push	r0
    5070:	cd b7       	in	r28, 0x3d	; 61
    5072:	de b7       	in	r29, 0x3e	; 62
    5074:	16 2f       	mov	r17, r22
    5076:	7a 01       	movw	r14, r20
  if (addr >95)
    5078:	80 36       	cpi	r24, 0x60	; 96
    507a:	00 f5       	brcc	.+64     	; 0x50bc <ds1305readMem+0x58>
    return 1;
  if (addr + length > 95)
    507c:	28 2f       	mov	r18, r24
    507e:	30 e0       	ldi	r19, 0x00	; 0
    5080:	26 0f       	add	r18, r22
    5082:	31 1d       	adc	r19, r1
    5084:	20 36       	cpi	r18, 0x60	; 96
    5086:	31 05       	cpc	r19, r1
    5088:	dc f4       	brge	.+54     	; 0x50c0 <ds1305readMem+0x5c>
    return 2;
  
  addr += 0x20;
  
  spiTake();
    508a:	89 83       	std	Y+1, r24	; 0x01
    508c:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  spiEnableDS1305();
    5090:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>

  spiSend(addr);
    5094:	89 81       	ldd	r24, Y+1	; 0x01
    5096:	80 5e       	subi	r24, 0xE0	; 224
    5098:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  while (length > 0)
    509c:	07 c0       	rjmp	.+14     	; 0x50ac <ds1305readMem+0x48>
  {
    *data = spiSend(0);
    509e:	80 e0       	ldi	r24, 0x00	; 0
    50a0:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    50a4:	f7 01       	movw	r30, r14
    50a6:	81 93       	st	Z+, r24
    50a8:	7f 01       	movw	r14, r30
    data++;
    length--;
    50aa:	11 50       	subi	r17, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    50ac:	11 23       	and	r17, r17
    50ae:	b9 f7       	brne	.-18     	; 0x509e <ds1305readMem+0x3a>
    *data = spiSend(0);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    50b0:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    50b4:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
  return 0;
    50b8:	80 e0       	ldi	r24, 0x00	; 0
    50ba:	03 c0       	rjmp	.+6      	; 0x50c2 <ds1305readMem+0x5e>
  return 0;
}
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr >95)
    return 1;
    50bc:	81 e0       	ldi	r24, 0x01	; 1
    50be:	01 c0       	rjmp	.+2      	; 0x50c2 <ds1305readMem+0x5e>
  if (addr + length > 95)
    return 2;
    50c0:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    50c2:	0f 90       	pop	r0
    50c4:	cf 91       	pop	r28
    50c6:	df 91       	pop	r29
    50c8:	1f 91       	pop	r17
    50ca:	ff 90       	pop	r15
    50cc:	ef 90       	pop	r14
    50ce:	08 95       	ret
    50d0:	08 95       	ret
    50d2:	08 95       	ret

000050d4 <MPC23s17SetDirA>:
void enableSpiMPC23S17(void)  {}
void disableSpiMPC23S17(void) {}


void MPC23s17SetDirA(uint8_t portAdir, uint8_t addr)
{
    50d4:	1f 93       	push	r17
    50d6:	df 93       	push	r29
    50d8:	cf 93       	push	r28
    50da:	0f 92       	push	r0
    50dc:	cd b7       	in	r28, 0x3d	; 61
    50de:	de b7       	in	r29, 0x3e	; 62
    50e0:	18 2f       	mov	r17, r24
  addr = addr<<1;
    50e2:	66 0f       	add	r22, r22
  addr &= 0x0E;
    50e4:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    50e6:	69 83       	std	Y+1, r22	; 0x01
    50e8:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17(); 
    50ec:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    50f0:	69 81       	ldd	r22, Y+1	; 0x01
    50f2:	86 2f       	mov	r24, r22
    50f4:	80 64       	ori	r24, 0x40	; 64
    50f6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_IODIRA);
    50fa:	80 e0       	ldi	r24, 0x00	; 0
    50fc:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portAdir);  
    5100:	81 2f       	mov	r24, r17
    5102:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMPC23S17();
    5106:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    510a:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    510e:	0f 90       	pop	r0
    5110:	cf 91       	pop	r28
    5112:	df 91       	pop	r29
    5114:	1f 91       	pop	r17
    5116:	08 95       	ret

00005118 <MPC23s17SetDirB>:

void MPC23s17SetDirB(uint8_t portBdir, uint8_t addr)
{
    5118:	1f 93       	push	r17
    511a:	df 93       	push	r29
    511c:	cf 93       	push	r28
    511e:	0f 92       	push	r0
    5120:	cd b7       	in	r28, 0x3d	; 61
    5122:	de b7       	in	r29, 0x3e	; 62
    5124:	18 2f       	mov	r17, r24
  addr = addr<<1;
    5126:	66 0f       	add	r22, r22
  addr &= 0x0E;
    5128:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    512a:	69 83       	std	Y+1, r22	; 0x01
    512c:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    5130:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  
  spiSend(addr);
    5134:	69 81       	ldd	r22, Y+1	; 0x01
    5136:	86 2f       	mov	r24, r22
    5138:	80 64       	ori	r24, 0x40	; 64
    513a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_IODIRB);
    513e:	81 e0       	ldi	r24, 0x01	; 1
    5140:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portBdir);  
    5144:	81 2f       	mov	r24, r17
    5146:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMPC23S17();
    514a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    514e:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    5152:	0f 90       	pop	r0
    5154:	cf 91       	pop	r28
    5156:	df 91       	pop	r29
    5158:	1f 91       	pop	r17
    515a:	08 95       	ret

0000515c <MPC23s17SetPortA>:

void MPC23s17SetPortA(uint8_t portAout, uint8_t addr)
{
    515c:	1f 93       	push	r17
    515e:	df 93       	push	r29
    5160:	cf 93       	push	r28
    5162:	0f 92       	push	r0
    5164:	cd b7       	in	r28, 0x3d	; 61
    5166:	de b7       	in	r29, 0x3e	; 62
    5168:	18 2f       	mov	r17, r24
  addr = addr<<1;
    516a:	66 0f       	add	r22, r22
  addr &= 0x0E;
    516c:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    516e:	69 83       	std	Y+1, r22	; 0x01
    5170:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    5174:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  portA = portAout;  
    5178:	10 93 24 32 	sts	0x3224, r17
  spiSend(addr);
    517c:	69 81       	ldd	r22, Y+1	; 0x01
    517e:	86 2f       	mov	r24, r22
    5180:	80 64       	ori	r24, 0x40	; 64
    5182:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATA);
    5186:	84 e1       	ldi	r24, 0x14	; 20
    5188:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portA);  
    518c:	80 91 24 32 	lds	r24, 0x3224
    5190:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    5194:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5198:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    519c:	0f 90       	pop	r0
    519e:	cf 91       	pop	r28
    51a0:	df 91       	pop	r29
    51a2:	1f 91       	pop	r17
    51a4:	08 95       	ret

000051a6 <MPC23s17SetBitsOnPortA>:

void MPC23s17SetBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    51a6:	df 93       	push	r29
    51a8:	cf 93       	push	r28
    51aa:	0f 92       	push	r0
    51ac:	cd b7       	in	r28, 0x3d	; 61
    51ae:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    51b0:	66 0f       	add	r22, r22
  addr &= 0x0E;
    51b2:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA |= portAout;  
    51b4:	90 91 24 32 	lds	r25, 0x3224
    51b8:	98 2b       	or	r25, r24
    51ba:	90 93 24 32 	sts	0x3224, r25

  spiTake();
    51be:	69 83       	std	Y+1, r22	; 0x01
    51c0:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    51c4:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    51c8:	69 81       	ldd	r22, Y+1	; 0x01
    51ca:	86 2f       	mov	r24, r22
    51cc:	80 64       	ori	r24, 0x40	; 64
    51ce:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATA);
    51d2:	84 e1       	ldi	r24, 0x14	; 20
    51d4:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portA);  
    51d8:	80 91 24 32 	lds	r24, 0x3224
    51dc:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    51e0:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    51e4:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    51e8:	0f 90       	pop	r0
    51ea:	cf 91       	pop	r28
    51ec:	df 91       	pop	r29
    51ee:	08 95       	ret

000051f0 <MPC23s17ClearBitsOnPortA>:

void MPC23s17ClearBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    51f0:	df 93       	push	r29
    51f2:	cf 93       	push	r28
    51f4:	0f 92       	push	r0
    51f6:	cd b7       	in	r28, 0x3d	; 61
    51f8:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    51fa:	66 0f       	add	r22, r22
  addr &= 0x0E;
    51fc:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA &= (~portAout);
    51fe:	90 91 24 32 	lds	r25, 0x3224
    5202:	80 95       	com	r24
    5204:	89 23       	and	r24, r25
    5206:	80 93 24 32 	sts	0x3224, r24

  spiTake();
    520a:	69 83       	std	Y+1, r22	; 0x01
    520c:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    5210:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    5214:	69 81       	ldd	r22, Y+1	; 0x01
    5216:	86 2f       	mov	r24, r22
    5218:	80 64       	ori	r24, 0x40	; 64
    521a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATA);
    521e:	84 e1       	ldi	r24, 0x14	; 20
    5220:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portA);  
    5224:	80 91 24 32 	lds	r24, 0x3224
    5228:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    522c:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5230:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    5234:	0f 90       	pop	r0
    5236:	cf 91       	pop	r28
    5238:	df 91       	pop	r29
    523a:	08 95       	ret

0000523c <MPC23s17SetPortB>:

void MPC23s17SetPortB(uint8_t portBout, uint8_t addr)
{
    523c:	df 93       	push	r29
    523e:	cf 93       	push	r28
    5240:	0f 92       	push	r0
    5242:	cd b7       	in	r28, 0x3d	; 61
    5244:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5246:	66 0f       	add	r22, r22
  addr &= 0x0E;
    5248:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB = portBout;
    524a:	80 93 d7 31 	sts	0x31D7, r24

  spiTake();
    524e:	69 83       	std	Y+1, r22	; 0x01
    5250:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    5254:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    5258:	69 81       	ldd	r22, Y+1	; 0x01
    525a:	86 2f       	mov	r24, r22
    525c:	80 64       	ori	r24, 0x40	; 64
    525e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATB);
    5262:	85 e1       	ldi	r24, 0x15	; 21
    5264:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portB);  
    5268:	80 91 d7 31 	lds	r24, 0x31D7
    526c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    5270:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5274:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    5278:	0f 90       	pop	r0
    527a:	cf 91       	pop	r28
    527c:	df 91       	pop	r29
    527e:	08 95       	ret

00005280 <MPC23s17SetBitsOnPortB>:

void MPC23s17SetBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5280:	df 93       	push	r29
    5282:	cf 93       	push	r28
    5284:	0f 92       	push	r0
    5286:	cd b7       	in	r28, 0x3d	; 61
    5288:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    528a:	66 0f       	add	r22, r22
  addr &= 0x0E;
    528c:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB |= portBout;
    528e:	90 91 d7 31 	lds	r25, 0x31D7
    5292:	98 2b       	or	r25, r24
    5294:	90 93 d7 31 	sts	0x31D7, r25

  spiTake();
    5298:	69 83       	std	Y+1, r22	; 0x01
    529a:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    529e:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    52a2:	69 81       	ldd	r22, Y+1	; 0x01
    52a4:	86 2f       	mov	r24, r22
    52a6:	80 64       	ori	r24, 0x40	; 64
    52a8:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATB);
    52ac:	85 e1       	ldi	r24, 0x15	; 21
    52ae:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portB);  
    52b2:	80 91 d7 31 	lds	r24, 0x31D7
    52b6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    52ba:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    52be:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    52c2:	0f 90       	pop	r0
    52c4:	cf 91       	pop	r28
    52c6:	df 91       	pop	r29
    52c8:	08 95       	ret

000052ca <MPC23s17ClearBitsOnPortB>:

void MPC23s17ClearBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    52ca:	df 93       	push	r29
    52cc:	cf 93       	push	r28
    52ce:	0f 92       	push	r0
    52d0:	cd b7       	in	r28, 0x3d	; 61
    52d2:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    52d4:	66 0f       	add	r22, r22
  addr &= 0x0E;
    52d6:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB &= (~portBout);
    52d8:	90 91 d7 31 	lds	r25, 0x31D7
    52dc:	80 95       	com	r24
    52de:	89 23       	and	r24, r25
    52e0:	80 93 d7 31 	sts	0x31D7, r24

  spiTake();
    52e4:	69 83       	std	Y+1, r22	; 0x01
    52e6:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    52ea:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    52ee:	69 81       	ldd	r22, Y+1	; 0x01
    52f0:	86 2f       	mov	r24, r22
    52f2:	80 64       	ori	r24, 0x40	; 64
    52f4:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATB);
    52f8:	85 e1       	ldi	r24, 0x15	; 21
    52fa:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portB);  
    52fe:	80 91 d7 31 	lds	r24, 0x31D7
    5302:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    5306:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    530a:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    530e:	0f 90       	pop	r0
    5310:	cf 91       	pop	r28
    5312:	df 91       	pop	r29
    5314:	08 95       	ret

00005316 <MPC23s17ReadPortA>:

uint8_t MPC23s17ReadPortA(uint8_t addr)
{
    5316:	1f 93       	push	r17
    5318:	df 93       	push	r29
    531a:	cf 93       	push	r28
    531c:	0f 92       	push	r0
    531e:	cd b7       	in	r28, 0x3d	; 61
    5320:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5322:	18 2f       	mov	r17, r24
    5324:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5326:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    5328:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    532a:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    532e:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>

  spiSend(addr);
    5332:	81 2f       	mov	r24, r17
    5334:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_GPIOA);
    5338:	82 e1       	ldi	r24, 0x12	; 18
    533a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  uint8_t result = spiSend(addr);  
    533e:	81 2f       	mov	r24, r17
    5340:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    5344:	89 83       	std	Y+1, r24	; 0x01
    5346:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    534a:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>

  return result; 
}
    534e:	89 81       	ldd	r24, Y+1	; 0x01
    5350:	0f 90       	pop	r0
    5352:	cf 91       	pop	r28
    5354:	df 91       	pop	r29
    5356:	1f 91       	pop	r17
    5358:	08 95       	ret

0000535a <MPC23s17ReadPortB>:

uint8_t MPC23s17ReadPortB(uint8_t addr)
{
    535a:	1f 93       	push	r17
    535c:	df 93       	push	r29
    535e:	cf 93       	push	r28
    5360:	0f 92       	push	r0
    5362:	cd b7       	in	r28, 0x3d	; 61
    5364:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5366:	18 2f       	mov	r17, r24
    5368:	11 0f       	add	r17, r17
  addr &= 0x0E;
    536a:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    536c:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    536e:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMPC23S17();
    5372:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>

  spiSend(addr);
    5376:	81 2f       	mov	r24, r17
    5378:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_GPIOB);
    537c:	83 e1       	ldi	r24, 0x13	; 19
    537e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  uint8_t result = spiSend(addr);  
    5382:	81 2f       	mov	r24, r17
    5384:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    5388:	89 83       	std	Y+1, r24	; 0x01
    538a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    538e:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>

  return result; 
}
    5392:	89 81       	ldd	r24, Y+1	; 0x01
    5394:	0f 90       	pop	r0
    5396:	cf 91       	pop	r28
    5398:	df 91       	pop	r29
    539a:	1f 91       	pop	r17
    539c:	08 95       	ret
    539e:	08 95       	ret
    53a0:	08 95       	ret

000053a2 <MCP3008_getSampleDiff>:
void enableSpiMCP3008(void)   {};
void disableSpiMCP3008(void)  {};


uint16_t MCP3008_getSampleDiff(uint8_t inputNo)
{
    53a2:	1f 93       	push	r17
    53a4:	df 93       	push	r29
    53a6:	cf 93       	push	r28
    53a8:	0f 92       	push	r0
    53aa:	cd b7       	in	r28, 0x3d	; 61
    53ac:	de b7       	in	r29, 0x3e	; 62
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    53ae:	18 2f       	mov	r17, r24
    53b0:	12 95       	swap	r17
    53b2:	10 7f       	andi	r17, 0xF0	; 240
  inputNo &= 0x70;
  
  spiTake();
    53b4:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMCP3008();
    53b8:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <enableSpiMCP3008>
  
  spiSend(0x01);                               //Start
    53bc:	81 e0       	ldi	r24, 0x01	; 1
    53be:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    53c2:	81 2f       	mov	r24, r17
    53c4:	80 77       	andi	r24, 0x70	; 112
    53c6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    53ca:	18 2f       	mov	r17, r24
  resultLo = spiSend(0);        //X X X X X X X X
    53cc:	80 e0       	ldi	r24, 0x00	; 0
    53ce:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMCP3008(); 
    53d2:	89 83       	std	Y+1, r24	; 0x01
    53d4:	0e 94 77 0d 	call	0x1aee	; 0x1aee <disableSpiMCP3008>
  spiGive();
    53d8:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
    53dc:	51 2f       	mov	r21, r17
    53de:	53 70       	andi	r21, 0x03	; 3
    53e0:	40 e0       	ldi	r20, 0x00	; 0
    53e2:	89 81       	ldd	r24, Y+1	; 0x01
    53e4:	28 2f       	mov	r18, r24
    53e6:	30 e0       	ldi	r19, 0x00	; 0
    53e8:	24 2b       	or	r18, r20
    53ea:	35 2b       	or	r19, r21
}
    53ec:	c9 01       	movw	r24, r18
    53ee:	0f 90       	pop	r0
    53f0:	cf 91       	pop	r28
    53f2:	df 91       	pop	r29
    53f4:	1f 91       	pop	r17
    53f6:	08 95       	ret

000053f8 <MCP3008_getSampleSingle>:

uint16_t MCP3008_getSampleSingle(uint8_t inputNo)
{
    53f8:	1f 93       	push	r17
    53fa:	df 93       	push	r29
    53fc:	cf 93       	push	r28
    53fe:	0f 92       	push	r0
    5400:	cd b7       	in	r28, 0x3d	; 61
    5402:	de b7       	in	r29, 0x3e	; 62
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    5404:	18 2f       	mov	r17, r24
    5406:	12 95       	swap	r17
  inputNo &= 0x70;
    5408:	10 77       	andi	r17, 0x70	; 112
  inputNo |= 0x80;
  
  spiTake();
    540a:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMCP3008();
    540e:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <enableSpiMCP3008>
  
  spiSend(0x01);                //Start
    5412:	81 e0       	ldi	r24, 0x01	; 1
    5414:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    5418:	81 2f       	mov	r24, r17
    541a:	80 68       	ori	r24, 0x80	; 128
    541c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    5420:	18 2f       	mov	r17, r24
  resultLo = spiSend(0);        //X X X X X X X X
    5422:	80 e0       	ldi	r24, 0x00	; 0
    5424:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMCP3008(); 
    5428:	89 83       	std	Y+1, r24	; 0x01
    542a:	0e 94 77 0d 	call	0x1aee	; 0x1aee <disableSpiMCP3008>
  spiGive();
    542e:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
    5432:	51 2f       	mov	r21, r17
    5434:	53 70       	andi	r21, 0x03	; 3
    5436:	40 e0       	ldi	r20, 0x00	; 0
    5438:	89 81       	ldd	r24, Y+1	; 0x01
    543a:	28 2f       	mov	r18, r24
    543c:	30 e0       	ldi	r19, 0x00	; 0
    543e:	24 2b       	or	r18, r20
    5440:	35 2b       	or	r19, r21
}
    5442:	c9 01       	movw	r24, r18
    5444:	0f 90       	pop	r0
    5446:	cf 91       	pop	r28
    5448:	df 91       	pop	r29
    544a:	1f 91       	pop	r17
    544c:	08 95       	ret
    544e:	08 95       	ret
    5450:	08 95       	ret

00005452 <MCP4150_setValue>:
/**
 * Ustawia wartość rezystancji
 * @param inputNo - WARTOŚĆ OD 0 DO 255.
 */
void MCP4150_setValue(uint8_t value)
{  
    5452:	1f 93       	push	r17
    5454:	18 2f       	mov	r17, r24
  spiTake();
    5456:	0e 94 06 1c 	call	0x380c	; 0x380c <spiTake>
  enableSpiMCP4150();
    545a:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <enableSpiMCP4150>
  
  spiSend(0x11);  
    545e:	81 e1       	ldi	r24, 0x11	; 17
    5460:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(value);
    5464:	81 2f       	mov	r24, r17
    5466:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMCP4150(); 
    546a:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <disableSpiMCP4150>
  spiGive();
    546e:	0e 94 12 1c 	call	0x3824	; 0x3824 <spiGive>
}
    5472:	1f 91       	pop	r17
    5474:	08 95       	ret
    5476:	08 95       	ret
    5478:	08 95       	ret

0000547a <enc28j60WriteOp>:
 // spiGive();
  return result; 
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
    547a:	1f 93       	push	r17
    547c:	df 93       	push	r29
    547e:	cf 93       	push	r28
    5480:	0f 92       	push	r0
    5482:	0f 92       	push	r0
    5484:	cd b7       	in	r28, 0x3d	; 61
    5486:	de b7       	in	r29, 0x3e	; 62
    5488:	18 2f       	mov	r17, r24
 // spiTake();
  spiEnableEnc28j60();
    548a:	4a 83       	std	Y+2, r20	; 0x02
    548c:	69 83       	std	Y+1, r22	; 0x01
    548e:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSend(op | (address & ADDR_MASK));
    5492:	69 81       	ldd	r22, Y+1	; 0x01
    5494:	86 2f       	mov	r24, r22
    5496:	8f 71       	andi	r24, 0x1F	; 31
    5498:	81 2b       	or	r24, r17
    549a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(data);
    549e:	4a 81       	ldd	r20, Y+2	; 0x02
    54a0:	84 2f       	mov	r24, r20
    54a2:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiDisableEnc28j60();
    54a6:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
 // spiGive();
}
    54aa:	0f 90       	pop	r0
    54ac:	0f 90       	pop	r0
    54ae:	cf 91       	pop	r28
    54b0:	df 91       	pop	r29
    54b2:	1f 91       	pop	r17
    54b4:	08 95       	ret

000054b6 <enc28j60SetBank>:
//   spiGive();
// }


void enc28j60SetBank(uint8_t address)
{
    54b6:	1f 93       	push	r17
    54b8:	cf 93       	push	r28
    54ba:	df 93       	push	r29
    54bc:	18 2f       	mov	r17, r24
  // set the bank (if needed)
  if((address & BANK_MASK) != Enc28j60Bank)
    54be:	c8 2f       	mov	r28, r24
    54c0:	d0 e0       	ldi	r29, 0x00	; 0
    54c2:	c0 76       	andi	r28, 0x60	; 96
    54c4:	d0 70       	andi	r29, 0x00	; 0
    54c6:	20 91 52 25 	lds	r18, 0x2552
    54ca:	30 e0       	ldi	r19, 0x00	; 0
    54cc:	c2 17       	cp	r28, r18
    54ce:	d3 07       	cpc	r29, r19
    54d0:	91 f0       	breq	.+36     	; 0x54f6 <enc28j60SetBank+0x40>
  {
    // set the bank
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    54d2:	80 ea       	ldi	r24, 0xA0	; 160
    54d4:	6f e1       	ldi	r22, 0x1F	; 31
    54d6:	43 e0       	ldi	r20, 0x03	; 3
    54d8:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    54dc:	ae 01       	movw	r20, r28
    54de:	85 e0       	ldi	r24, 0x05	; 5
    54e0:	55 95       	asr	r21
    54e2:	47 95       	ror	r20
    54e4:	8a 95       	dec	r24
    54e6:	e1 f7       	brne	.-8      	; 0x54e0 <enc28j60SetBank+0x2a>
    54e8:	80 e8       	ldi	r24, 0x80	; 128
    54ea:	6f e1       	ldi	r22, 0x1F	; 31
    54ec:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    Enc28j60Bank = (address & BANK_MASK);
    54f0:	10 76       	andi	r17, 0x60	; 96
    54f2:	10 93 52 25 	sts	0x2552, r17
  }
}
    54f6:	df 91       	pop	r29
    54f8:	cf 91       	pop	r28
    54fa:	1f 91       	pop	r17
    54fc:	08 95       	ret

000054fe <enc28j60Write>:

  return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    54fe:	1f 93       	push	r17
    5500:	df 93       	push	r29
    5502:	cf 93       	push	r28
    5504:	0f 92       	push	r0
    5506:	cd b7       	in	r28, 0x3d	; 61
    5508:	de b7       	in	r29, 0x3e	; 62
    550a:	18 2f       	mov	r17, r24
  // set the bank
  enc28j60SetBank(address);
    550c:	69 83       	std	Y+1, r22	; 0x01
    550e:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <enc28j60SetBank>
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    5512:	80 e4       	ldi	r24, 0x40	; 64
    5514:	61 2f       	mov	r22, r17
    5516:	49 81       	ldd	r20, Y+1	; 0x01
    5518:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
}
    551c:	0f 90       	pop	r0
    551e:	cf 91       	pop	r28
    5520:	df 91       	pop	r29
    5522:	1f 91       	pop	r17
    5524:	08 95       	ret

00005526 <enc28j60ReadOp>:
    enc28j60PhyWrite    (PHLCON, 0x476);
    vTaskDelay          (2);
}

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
    5526:	1f 93       	push	r17
    5528:	df 93       	push	r29
    552a:	cf 93       	push	r28
    552c:	0f 92       	push	r0
    552e:	cd b7       	in	r28, 0x3d	; 61
    5530:	de b7       	in	r29, 0x3e	; 62
    5532:	16 2f       	mov	r17, r22
  uint8_t result;
  //spiTake();
  spiEnableEnc28j60();
    5534:	89 83       	std	Y+1, r24	; 0x01
    5536:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
  
  // issue read command
  spiSend(op | (address & ADDR_MASK));
    553a:	91 2f       	mov	r25, r17
    553c:	9f 71       	andi	r25, 0x1F	; 31
    553e:	89 81       	ldd	r24, Y+1	; 0x01
    5540:	89 2b       	or	r24, r25
    5542:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  // read data
  result = spiSend(0x00);
    5546:	80 e0       	ldi	r24, 0x00	; 0
    5548:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  // do dummy read if needed (for mac and mii, see datasheet page 29)
  if(address & 0x80)
    554c:	17 ff       	sbrs	r17, 7
    554e:	03 c0       	rjmp	.+6      	; 0x5556 <enc28j60ReadOp+0x30>
  {
    result = spiSend(0x00);
    5550:	80 e0       	ldi	r24, 0x00	; 0
    5552:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  }

  spiDisableEnc28j60();
    5556:	89 83       	std	Y+1, r24	; 0x01
    5558:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
 // spiGive();
  return result; 
}
    555c:	89 81       	ldd	r24, Y+1	; 0x01
    555e:	0f 90       	pop	r0
    5560:	cf 91       	pop	r28
    5562:	df 91       	pop	r29
    5564:	1f 91       	pop	r17
    5566:	08 95       	ret

00005568 <enc28j60Read>:
    Enc28j60Bank = (address & BANK_MASK);
  }
}

uint8_t enc28j60Read(uint8_t address)
{
    5568:	df 93       	push	r29
    556a:	cf 93       	push	r28
    556c:	0f 92       	push	r0
    556e:	cd b7       	in	r28, 0x3d	; 61
    5570:	de b7       	in	r29, 0x3e	; 62
    5572:	68 2f       	mov	r22, r24
  // set the bank
  enc28j60SetBank(address);
    5574:	69 83       	std	Y+1, r22	; 0x01
    5576:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <enc28j60SetBank>
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    557a:	80 e0       	ldi	r24, 0x00	; 0
    557c:	69 81       	ldd	r22, Y+1	; 0x01
    557e:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
  return result;
}
    5582:	0f 90       	pop	r0
    5584:	cf 91       	pop	r28
    5586:	df 91       	pop	r29
    5588:	08 95       	ret

0000558a <enc28j60hasRxPkt>:
}

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
  if( enc28j60Read(EPKTCNT) ==0 )
    558a:	89 e3       	ldi	r24, 0x39	; 57
    558c:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
  {
    return(0);
    5590:	91 e0       	ldi	r25, 0x01	; 1
    5592:	88 23       	and	r24, r24
    5594:	09 f4       	brne	.+2      	; 0x5598 <enc28j60hasRxPkt+0xe>
    5596:	90 e0       	ldi	r25, 0x00	; 0
  }
  return(1);
}
    5598:	89 2f       	mov	r24, r25
    559a:	08 95       	ret

0000559c <enc28j60linkup>:

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
  // Set the right address and start the register read operation
  enc28j60Write(MIREGADR, address);
    559c:	84 ed       	ldi	r24, 0xD4	; 212
    559e:	61 e1       	ldi	r22, 0x11	; 17
    55a0:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
  enc28j60Write(MICMD, MICMD_MIIRD);
    55a4:	82 ed       	ldi	r24, 0xD2	; 210
    55a6:	61 e0       	ldi	r22, 0x01	; 1
    55a8:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie
    55ac:	80 e0       	ldi	r24, 0x00	; 0
    55ae:	90 e0       	ldi	r25, 0x00	; 0
    55b0:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
  enc28j60Write(MICMD, MICMD_MIIRD);
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    55b4:	8a ee       	ldi	r24, 0xEA	; 234
    55b6:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    55ba:	80 fd       	sbrc	r24, 0
    55bc:	f7 cf       	rjmp	.-18     	; 0x55ac <enc28j60linkup+0x10>
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie

  // reset reading bit
  enc28j60Write(MICMD, 0x00);
    55be:	82 ed       	ldi	r24, 0xD2	; 210
    55c0:	60 e0       	ldi	r22, 0x00	; 0
    55c2:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>

  return (enc28j60Read(MIRDH));
    55c6:	89 ed       	ldi	r24, 0xD9	; 217
    55c8:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>

// link status
uint8_t enc28j60linkup(void)
{
  // bit 10 (= bit 3 in upper reg)
  return(enc28j60PhyReadH(PHSTAT2) && 4);
    55cc:	91 e0       	ldi	r25, 0x01	; 1
    55ce:	88 23       	and	r24, r24
    55d0:	09 f4       	brne	.+2      	; 0x55d4 <enc28j60linkup+0x38>
    55d2:	90 e0       	ldi	r25, 0x00	; 0
}
    55d4:	89 2f       	mov	r24, r25
    55d6:	08 95       	ret

000055d8 <enc28j60getrev>:
}

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
  return(enc28j60Read(EREVID));
    55d8:	82 e7       	ldi	r24, 0x72	; 114
    55da:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
}
    55de:	08 95       	ret

000055e0 <enc28j60PhyWrite>:
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    55e0:	1f 93       	push	r17
    55e2:	df 93       	push	r29
    55e4:	cf 93       	push	r28
    55e6:	0f 92       	push	r0
    55e8:	cd b7       	in	r28, 0x3d	; 61
    55ea:	de b7       	in	r29, 0x3e	; 62
    55ec:	98 2f       	mov	r25, r24
    55ee:	16 2f       	mov	r17, r22
  // set the PHY register address
  enc28j60Write(MIREGADR, address);
    55f0:	84 ed       	ldi	r24, 0xD4	; 212
    55f2:	69 2f       	mov	r22, r25
    55f4:	79 83       	std	Y+1, r23	; 0x01
    55f6:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
  // write the PHY data
  enc28j60Write(MIWRL, data);
    55fa:	86 ed       	ldi	r24, 0xD6	; 214
    55fc:	61 2f       	mov	r22, r17
    55fe:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
  enc28j60Write(MIWRH, data>>8);
    5602:	87 ed       	ldi	r24, 0xD7	; 215
    5604:	79 81       	ldd	r23, Y+1	; 0x01
    5606:	67 2f       	mov	r22, r23
    5608:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    560c:	04 c0       	rjmp	.+8      	; 0x5616 <enc28j60PhyWrite+0x36>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
    560e:	80 e0       	ldi	r24, 0x00	; 0
    5610:	90 e0       	ldi	r25, 0x00	; 0
    5612:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
  // write the PHY data
  enc28j60Write(MIWRL, data);
  enc28j60Write(MIWRH, data>>8);
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    5616:	8a ee       	ldi	r24, 0xEA	; 234
    5618:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    561c:	80 fd       	sbrc	r24, 0
    561e:	f7 cf       	rjmp	.-18     	; 0x560e <enc28j60PhyWrite+0x2e>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
  }
}
    5620:	0f 90       	pop	r0
    5622:	cf 91       	pop	r28
    5624:	df 91       	pop	r29
    5626:	1f 91       	pop	r17
    5628:	08 95       	ret

0000562a <nicPoll>:
    562a:	cf 92       	push	r12
    562c:	df 92       	push	r13
    562e:	ef 92       	push	r14
    5630:	ff 92       	push	r15
    5632:	0f 93       	push	r16
    5634:	1f 93       	push	r17
    5636:	cf 93       	push	r28
    5638:	df 93       	push	r29
    563a:	89 e3       	ldi	r24, 0x39	; 57
    563c:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    5640:	88 23       	and	r24, r24
    5642:	09 f4       	brne	.+2      	; 0x5646 <nicPoll+0x1c>
    5644:	9a c0       	rjmp	.+308    	; 0x577a <nicPoll+0x150>
    5646:	80 e0       	ldi	r24, 0x00	; 0
    5648:	60 91 53 25 	lds	r22, 0x2553
    564c:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5650:	60 91 54 25 	lds	r22, 0x2554
    5654:	81 e0       	ldi	r24, 0x01	; 1
    5656:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    565a:	8a e3       	ldi	r24, 0x3A	; 58
    565c:	60 e0       	ldi	r22, 0x00	; 0
    565e:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
    5662:	c8 2f       	mov	r28, r24
    5664:	d0 e0       	ldi	r29, 0x00	; 0
    5666:	c0 93 53 25 	sts	0x2553, r28
    566a:	d0 93 54 25 	sts	0x2554, r29
    566e:	8a e3       	ldi	r24, 0x3A	; 58
    5670:	60 e0       	ldi	r22, 0x00	; 0
    5672:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
    5676:	38 2f       	mov	r19, r24
    5678:	20 e0       	ldi	r18, 0x00	; 0
    567a:	c2 2b       	or	r28, r18
    567c:	d3 2b       	or	r29, r19
    567e:	c0 93 53 25 	sts	0x2553, r28
    5682:	d0 93 54 25 	sts	0x2554, r29
    5686:	8a e3       	ldi	r24, 0x3A	; 58
    5688:	60 e0       	ldi	r22, 0x00	; 0
    568a:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
    568e:	c8 2e       	mov	r12, r24
    5690:	8a e3       	ldi	r24, 0x3A	; 58
    5692:	60 e0       	ldi	r22, 0x00	; 0
    5694:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
    5698:	e8 2e       	mov	r14, r24
    569a:	8a e3       	ldi	r24, 0x3A	; 58
    569c:	60 e0       	ldi	r22, 0x00	; 0
    569e:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
    56a2:	08 2f       	mov	r16, r24
    56a4:	10 e0       	ldi	r17, 0x00	; 0
    56a6:	8a e3       	ldi	r24, 0x3A	; 58
    56a8:	60 e0       	ldi	r22, 0x00	; 0
    56aa:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
    56ae:	40 91 dc 31 	lds	r20, 0x31DC
    56b2:	50 91 dd 31 	lds	r21, 0x31DD
    56b6:	38 2f       	mov	r19, r24
    56b8:	20 e0       	ldi	r18, 0x00	; 0
    56ba:	02 2b       	or	r16, r18
    56bc:	13 2b       	or	r17, r19
    56be:	07 ff       	sbrs	r16, 7
    56c0:	2b c0       	rjmp	.+86     	; 0x5718 <nicPoll+0xee>
    56c2:	cc 2d       	mov	r28, r12
    56c4:	d0 e0       	ldi	r29, 0x00	; 0
    56c6:	3e 2d       	mov	r19, r14
    56c8:	20 e0       	ldi	r18, 0x00	; 0
    56ca:	c2 2b       	or	r28, r18
    56cc:	d3 2b       	or	r29, r19
    56ce:	41 50       	subi	r20, 0x01	; 1
    56d0:	50 40       	sbci	r21, 0x00	; 0
    56d2:	24 97       	sbiw	r28, 0x04	; 4
    56d4:	4c 17       	cp	r20, r28
    56d6:	5d 07       	cpc	r21, r29
    56d8:	08 f4       	brcc	.+2      	; 0x56dc <nicPoll+0xb2>
    56da:	ea 01       	movw	r28, r20
    56dc:	c0 90 e4 31 	lds	r12, 0x31E4
    56e0:	d0 90 e5 31 	lds	r13, 0x31E5
    56e4:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
    56e8:	8a e3       	ldi	r24, 0x3A	; 58
    56ea:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    56ee:	76 01       	movw	r14, r12
    56f0:	8e 01       	movw	r16, r28
    56f2:	08 c0       	rjmp	.+16     	; 0x5704 <nicPoll+0xda>
    56f4:	01 50       	subi	r16, 0x01	; 1
    56f6:	10 40       	sbci	r17, 0x00	; 0
    56f8:	80 e0       	ldi	r24, 0x00	; 0
    56fa:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    56fe:	f7 01       	movw	r30, r14
    5700:	81 93       	st	Z+, r24
    5702:	7f 01       	movw	r14, r30
    5704:	01 15       	cp	r16, r1
    5706:	11 05       	cpc	r17, r1
    5708:	a9 f7       	brne	.-22     	; 0x56f4 <nicPoll+0xca>
    570a:	f6 01       	movw	r30, r12
    570c:	ec 0f       	add	r30, r28
    570e:	fd 1f       	adc	r31, r29
    5710:	10 82       	st	Z, r1
    5712:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
    5716:	02 c0       	rjmp	.+4      	; 0x571c <nicPoll+0xf2>
    5718:	c0 e0       	ldi	r28, 0x00	; 0
    571a:	d0 e0       	ldi	r29, 0x00	; 0
    571c:	8c e0       	ldi	r24, 0x0C	; 12
    571e:	60 91 53 25 	lds	r22, 0x2553
    5722:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5726:	60 91 54 25 	lds	r22, 0x2554
    572a:	8d e0       	ldi	r24, 0x0D	; 13
    572c:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5730:	60 91 53 25 	lds	r22, 0x2553
    5734:	70 91 54 25 	lds	r23, 0x2554
    5738:	cb 01       	movw	r24, r22
    573a:	01 97       	sbiw	r24, 0x01	; 1
    573c:	f9 e1       	ldi	r31, 0x19	; 25
    573e:	8f 3f       	cpi	r24, 0xFF	; 255
    5740:	9f 07       	cpc	r25, r31
    5742:	38 f0       	brcs	.+14     	; 0x5752 <nicPoll+0x128>
    5744:	8c e0       	ldi	r24, 0x0C	; 12
    5746:	6e ef       	ldi	r22, 0xFE	; 254
    5748:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    574c:	8d e0       	ldi	r24, 0x0D	; 13
    574e:	69 e1       	ldi	r22, 0x19	; 25
    5750:	0c c0       	rjmp	.+24     	; 0x576a <nicPoll+0x140>
    5752:	61 50       	subi	r22, 0x01	; 1
    5754:	8c e0       	ldi	r24, 0x0C	; 12
    5756:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    575a:	20 91 53 25 	lds	r18, 0x2553
    575e:	30 91 54 25 	lds	r19, 0x2554
    5762:	21 50       	subi	r18, 0x01	; 1
    5764:	30 40       	sbci	r19, 0x00	; 0
    5766:	8d e0       	ldi	r24, 0x0D	; 13
    5768:	63 2f       	mov	r22, r19
    576a:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    576e:	80 e8       	ldi	r24, 0x80	; 128
    5770:	6e e1       	ldi	r22, 0x1E	; 30
    5772:	40 e4       	ldi	r20, 0x40	; 64
    5774:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    5778:	02 c0       	rjmp	.+4      	; 0x577e <nicPoll+0x154>
    577a:	c0 e0       	ldi	r28, 0x00	; 0
    577c:	d0 e0       	ldi	r29, 0x00	; 0
    577e:	ce 01       	movw	r24, r28
    5780:	df 91       	pop	r29
    5782:	cf 91       	pop	r28
    5784:	1f 91       	pop	r17
    5786:	0f 91       	pop	r16
    5788:	ff 90       	pop	r15
    578a:	ef 90       	pop	r14
    578c:	df 90       	pop	r13
    578e:	cf 90       	pop	r12
    5790:	08 95       	ret

00005792 <nicSend>:
    5792:	0f 93       	push	r16
    5794:	1f 93       	push	r17
    5796:	cf 93       	push	r28
    5798:	df 93       	push	r29
    579a:	ec 01       	movw	r28, r24
    579c:	13 c0       	rjmp	.+38     	; 0x57c4 <nicSend+0x32>
    579e:	8c e1       	ldi	r24, 0x1C	; 28
    57a0:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    57a4:	81 ff       	sbrs	r24, 1
    57a6:	0a c0       	rjmp	.+20     	; 0x57bc <nicSend+0x2a>
    57a8:	80 e8       	ldi	r24, 0x80	; 128
    57aa:	6f e1       	ldi	r22, 0x1F	; 31
    57ac:	40 e8       	ldi	r20, 0x80	; 128
    57ae:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    57b2:	80 ea       	ldi	r24, 0xA0	; 160
    57b4:	6f e1       	ldi	r22, 0x1F	; 31
    57b6:	40 e8       	ldi	r20, 0x80	; 128
    57b8:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    57bc:	80 e0       	ldi	r24, 0x00	; 0
    57be:	90 e0       	ldi	r25, 0x00	; 0
    57c0:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    57c4:	80 e0       	ldi	r24, 0x00	; 0
    57c6:	6f e1       	ldi	r22, 0x1F	; 31
    57c8:	0e 94 93 2a 	call	0x5526	; 0x5526 <enc28j60ReadOp>
    57cc:	83 fd       	sbrc	r24, 3
    57ce:	e7 cf       	rjmp	.-50     	; 0x579e <nicSend+0xc>
    57d0:	82 e0       	ldi	r24, 0x02	; 2
    57d2:	6f ef       	ldi	r22, 0xFF	; 255
    57d4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    57d8:	83 e0       	ldi	r24, 0x03	; 3
    57da:	69 e1       	ldi	r22, 0x19	; 25
    57dc:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    57e0:	ce 01       	movw	r24, r28
    57e2:	81 50       	subi	r24, 0x01	; 1
    57e4:	68 2f       	mov	r22, r24
    57e6:	86 e0       	ldi	r24, 0x06	; 6
    57e8:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    57ec:	9e 01       	movw	r18, r28
    57ee:	21 50       	subi	r18, 0x01	; 1
    57f0:	36 4e       	sbci	r19, 0xE6	; 230
    57f2:	87 e0       	ldi	r24, 0x07	; 7
    57f4:	63 2f       	mov	r22, r19
    57f6:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    57fa:	8a e7       	ldi	r24, 0x7A	; 122
    57fc:	60 e0       	ldi	r22, 0x00	; 0
    57fe:	40 e0       	ldi	r20, 0x00	; 0
    5800:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    5804:	00 91 e4 31 	lds	r16, 0x31E4
    5808:	10 91 e5 31 	lds	r17, 0x31E5
    580c:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
    5810:	8a e7       	ldi	r24, 0x7A	; 122
    5812:	04 c0       	rjmp	.+8      	; 0x581c <nicSend+0x8a>
    5814:	21 97       	sbiw	r28, 0x01	; 1
    5816:	f8 01       	movw	r30, r16
    5818:	81 91       	ld	r24, Z+
    581a:	8f 01       	movw	r16, r30
    581c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    5820:	20 97       	sbiw	r28, 0x00	; 0
    5822:	c1 f7       	brne	.-16     	; 0x5814 <nicSend+0x82>
    5824:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
    5828:	80 e8       	ldi	r24, 0x80	; 128
    582a:	6f e1       	ldi	r22, 0x1F	; 31
    582c:	48 e0       	ldi	r20, 0x08	; 8
    582e:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    5832:	df 91       	pop	r29
    5834:	cf 91       	pop	r28
    5836:	1f 91       	pop	r17
    5838:	0f 91       	pop	r16
    583a:	08 95       	ret

0000583c <nicSetMacAddress>:
    583c:	cf 93       	push	r28
    583e:	df 93       	push	r29
    5840:	ec 01       	movw	r28, r24
    5842:	84 ee       	ldi	r24, 0xE4	; 228
    5844:	68 81       	ld	r22, Y
    5846:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    584a:	85 ee       	ldi	r24, 0xE5	; 229
    584c:	69 81       	ldd	r22, Y+1	; 0x01
    584e:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5852:	82 ee       	ldi	r24, 0xE2	; 226
    5854:	6a 81       	ldd	r22, Y+2	; 0x02
    5856:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    585a:	83 ee       	ldi	r24, 0xE3	; 227
    585c:	6b 81       	ldd	r22, Y+3	; 0x03
    585e:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5862:	80 ee       	ldi	r24, 0xE0	; 224
    5864:	6c 81       	ldd	r22, Y+4	; 0x04
    5866:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    586a:	81 ee       	ldi	r24, 0xE1	; 225
    586c:	6d 81       	ldd	r22, Y+5	; 0x05
    586e:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5872:	df 91       	pop	r29
    5874:	cf 91       	pop	r28
    5876:	08 95       	ret

00005878 <nicMacInit>:
    5878:	85 e0       	ldi	r24, 0x05	; 5
    587a:	90 e0       	ldi	r25, 0x00	; 0
    587c:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    5880:	85 e0       	ldi	r24, 0x05	; 5
    5882:	90 e0       	ldi	r25, 0x00	; 0
    5884:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    5888:	85 e0       	ldi	r24, 0x05	; 5
    588a:	90 e0       	ldi	r25, 0x00	; 0
    588c:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    5890:	10 92 53 25 	sts	0x2553, r1
    5894:	10 92 54 25 	sts	0x2554, r1
    5898:	88 e0       	ldi	r24, 0x08	; 8
    589a:	60 e0       	ldi	r22, 0x00	; 0
    589c:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58a0:	89 e0       	ldi	r24, 0x09	; 9
    58a2:	60 e0       	ldi	r22, 0x00	; 0
    58a4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58a8:	8c e0       	ldi	r24, 0x0C	; 12
    58aa:	60 e0       	ldi	r22, 0x00	; 0
    58ac:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58b0:	8d e0       	ldi	r24, 0x0D	; 13
    58b2:	60 e0       	ldi	r22, 0x00	; 0
    58b4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58b8:	8a e0       	ldi	r24, 0x0A	; 10
    58ba:	6e ef       	ldi	r22, 0xFE	; 254
    58bc:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58c0:	8b e0       	ldi	r24, 0x0B	; 11
    58c2:	69 e1       	ldi	r22, 0x19	; 25
    58c4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58c8:	84 e0       	ldi	r24, 0x04	; 4
    58ca:	6f ef       	ldi	r22, 0xFF	; 255
    58cc:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58d0:	85 e0       	ldi	r24, 0x05	; 5
    58d2:	69 e1       	ldi	r22, 0x19	; 25
    58d4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58d8:	86 e0       	ldi	r24, 0x06	; 6
    58da:	6f ef       	ldi	r22, 0xFF	; 255
    58dc:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58e0:	87 e0       	ldi	r24, 0x07	; 7
    58e2:	6f e1       	ldi	r22, 0x1F	; 31
    58e4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58e8:	88 e3       	ldi	r24, 0x38	; 56
    58ea:	62 eb       	ldi	r22, 0xB2	; 178
    58ec:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58f0:	88 e2       	ldi	r24, 0x28	; 40
    58f2:	6f e3       	ldi	r22, 0x3F	; 63
    58f4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    58f8:	89 e2       	ldi	r24, 0x29	; 41
    58fa:	60 e3       	ldi	r22, 0x30	; 48
    58fc:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5900:	80 e3       	ldi	r24, 0x30	; 48
    5902:	69 ef       	ldi	r22, 0xF9	; 249
    5904:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5908:	81 e3       	ldi	r24, 0x31	; 49
    590a:	67 ef       	ldi	r22, 0xF7	; 247
    590c:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5910:	80 ec       	ldi	r24, 0xC0	; 192
    5912:	6d e0       	ldi	r22, 0x0D	; 13
    5914:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5918:	81 ec       	ldi	r24, 0xC1	; 193
    591a:	60 e0       	ldi	r22, 0x00	; 0
    591c:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5920:	80 e8       	ldi	r24, 0x80	; 128
    5922:	62 ec       	ldi	r22, 0xC2	; 194
    5924:	42 e3       	ldi	r20, 0x32	; 50
    5926:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    592a:	86 ec       	ldi	r24, 0xC6	; 198
    592c:	62 e1       	ldi	r22, 0x12	; 18
    592e:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5932:	87 ec       	ldi	r24, 0xC7	; 199
    5934:	6c e0       	ldi	r22, 0x0C	; 12
    5936:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    593a:	84 ec       	ldi	r24, 0xC4	; 196
    593c:	62 e1       	ldi	r22, 0x12	; 18
    593e:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5942:	8a ec       	ldi	r24, 0xCA	; 202
    5944:	6c ed       	ldi	r22, 0xDC	; 220
    5946:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    594a:	8b ec       	ldi	r24, 0xCB	; 203
    594c:	65 e0       	ldi	r22, 0x05	; 5
    594e:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <enc28j60Write>
    5952:	8e ed       	ldi	r24, 0xDE	; 222
    5954:	91 e3       	ldi	r25, 0x31	; 49
    5956:	0e 94 1e 2c 	call	0x583c	; 0x583c <nicSetMacAddress>
    595a:	80 e1       	ldi	r24, 0x10	; 16
    595c:	60 e0       	ldi	r22, 0x00	; 0
    595e:	71 e0       	ldi	r23, 0x01	; 1
    5960:	0e 94 f0 2a 	call	0x55e0	; 0x55e0 <enc28j60PhyWrite>
    5964:	8f e1       	ldi	r24, 0x1F	; 31
    5966:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <enc28j60SetBank>
    596a:	80 e8       	ldi	r24, 0x80	; 128
    596c:	6b e1       	ldi	r22, 0x1B	; 27
    596e:	40 ec       	ldi	r20, 0xC0	; 192
    5970:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    5974:	80 e8       	ldi	r24, 0x80	; 128
    5976:	6f e1       	ldi	r22, 0x1F	; 31
    5978:	44 e0       	ldi	r20, 0x04	; 4
    597a:	0e 94 3d 2a 	call	0x547a	; 0x547a <enc28j60WriteOp>
    597e:	85 e0       	ldi	r24, 0x05	; 5
    5980:	90 e0       	ldi	r25, 0x00	; 0
    5982:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    5986:	84 e1       	ldi	r24, 0x14	; 20
    5988:	66 e7       	ldi	r22, 0x76	; 118
    598a:	74 e0       	ldi	r23, 0x04	; 4
    598c:	0e 94 f0 2a 	call	0x55e0	; 0x55e0 <enc28j60PhyWrite>
    5990:	82 e0       	ldi	r24, 0x02	; 2
    5992:	90 e0       	ldi	r25, 0x00	; 0
    5994:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
    5998:	08 95       	ret

0000599a <nicGetMacAddress>:
    599a:	cf 93       	push	r28
    599c:	df 93       	push	r29
    599e:	ec 01       	movw	r28, r24
    59a0:	81 ee       	ldi	r24, 0xE1	; 225
    59a2:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    59a6:	8d 83       	std	Y+5, r24	; 0x05
    59a8:	80 ee       	ldi	r24, 0xE0	; 224
    59aa:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    59ae:	8c 83       	std	Y+4, r24	; 0x04
    59b0:	83 ee       	ldi	r24, 0xE3	; 227
    59b2:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    59b6:	8b 83       	std	Y+3, r24	; 0x03
    59b8:	82 ee       	ldi	r24, 0xE2	; 226
    59ba:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    59be:	8a 83       	std	Y+2, r24	; 0x02
    59c0:	85 ee       	ldi	r24, 0xE5	; 229
    59c2:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    59c6:	89 83       	std	Y+1, r24	; 0x01
    59c8:	84 ee       	ldi	r24, 0xE4	; 228
    59ca:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    59ce:	88 83       	st	Y, r24
    59d0:	df 91       	pop	r29
    59d2:	cf 91       	pop	r28
    59d4:	08 95       	ret

000059d6 <nicRegDump>:
    59d6:	cf 93       	push	r28
    59d8:	df 93       	push	r29
    59da:	ec 01       	movw	r28, r24
    59dc:	00 d0       	rcall	.+0      	; 0x59de <nicRegDump+0x8>
    59de:	0f 92       	push	r0
    59e0:	ad b7       	in	r26, 0x3d	; 61
    59e2:	be b7       	in	r27, 0x3e	; 62
    59e4:	11 96       	adiw	r26, 0x01	; 1
    59e6:	8d 93       	st	X+, r24
    59e8:	9c 93       	st	X, r25
    59ea:	12 97       	sbiw	r26, 0x02	; 2
    59ec:	85 ec       	ldi	r24, 0xC5	; 197
    59ee:	98 e0       	ldi	r25, 0x08	; 8
    59f0:	13 96       	adiw	r26, 0x03	; 3
    59f2:	8d 93       	st	X+, r24
    59f4:	9c 93       	st	X, r25
    59f6:	14 97       	sbiw	r26, 0x04	; 4
    59f8:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    59fc:	0f 90       	pop	r0
    59fe:	0f 90       	pop	r0
    5a00:	0f 90       	pop	r0
    5a02:	0f 90       	pop	r0
    5a04:	81 ee       	ldi	r24, 0xE1	; 225
    5a06:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    5a0a:	00 d0       	rcall	.+0      	; 0x5a0c <nicRegDump+0x36>
    5a0c:	00 d0       	rcall	.+0      	; 0x5a0e <nicRegDump+0x38>
    5a0e:	ed b7       	in	r30, 0x3d	; 61
    5a10:	fe b7       	in	r31, 0x3e	; 62
    5a12:	31 96       	adiw	r30, 0x01	; 1
    5a14:	ad b7       	in	r26, 0x3d	; 61
    5a16:	be b7       	in	r27, 0x3e	; 62
    5a18:	11 96       	adiw	r26, 0x01	; 1
    5a1a:	cd 93       	st	X+, r28
    5a1c:	dc 93       	st	X, r29
    5a1e:	12 97       	sbiw	r26, 0x02	; 2
    5a20:	26 eb       	ldi	r18, 0xB6	; 182
    5a22:	38 e0       	ldi	r19, 0x08	; 8
    5a24:	22 83       	std	Z+2, r18	; 0x02
    5a26:	33 83       	std	Z+3, r19	; 0x03
    5a28:	84 83       	std	Z+4, r24	; 0x04
    5a2a:	15 82       	std	Z+5, r1	; 0x05
    5a2c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5a30:	ed b7       	in	r30, 0x3d	; 61
    5a32:	fe b7       	in	r31, 0x3e	; 62
    5a34:	36 96       	adiw	r30, 0x06	; 6
    5a36:	ed bf       	out	0x3d, r30	; 61
    5a38:	fe bf       	out	0x3e, r31	; 62
    5a3a:	80 ee       	ldi	r24, 0xE0	; 224
    5a3c:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    5a40:	00 d0       	rcall	.+0      	; 0x5a42 <nicRegDump+0x6c>
    5a42:	00 d0       	rcall	.+0      	; 0x5a44 <nicRegDump+0x6e>
    5a44:	ed b7       	in	r30, 0x3d	; 61
    5a46:	fe b7       	in	r31, 0x3e	; 62
    5a48:	31 96       	adiw	r30, 0x01	; 1
    5a4a:	ad b7       	in	r26, 0x3d	; 61
    5a4c:	be b7       	in	r27, 0x3e	; 62
    5a4e:	11 96       	adiw	r26, 0x01	; 1
    5a50:	cd 93       	st	X+, r28
    5a52:	dc 93       	st	X, r29
    5a54:	12 97       	sbiw	r26, 0x02	; 2
    5a56:	27 ea       	ldi	r18, 0xA7	; 167
    5a58:	38 e0       	ldi	r19, 0x08	; 8
    5a5a:	22 83       	std	Z+2, r18	; 0x02
    5a5c:	33 83       	std	Z+3, r19	; 0x03
    5a5e:	84 83       	std	Z+4, r24	; 0x04
    5a60:	15 82       	std	Z+5, r1	; 0x05
    5a62:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5a66:	ed b7       	in	r30, 0x3d	; 61
    5a68:	fe b7       	in	r31, 0x3e	; 62
    5a6a:	36 96       	adiw	r30, 0x06	; 6
    5a6c:	ed bf       	out	0x3d, r30	; 61
    5a6e:	fe bf       	out	0x3e, r31	; 62
    5a70:	83 ee       	ldi	r24, 0xE3	; 227
    5a72:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    5a76:	00 d0       	rcall	.+0      	; 0x5a78 <nicRegDump+0xa2>
    5a78:	00 d0       	rcall	.+0      	; 0x5a7a <nicRegDump+0xa4>
    5a7a:	ed b7       	in	r30, 0x3d	; 61
    5a7c:	fe b7       	in	r31, 0x3e	; 62
    5a7e:	31 96       	adiw	r30, 0x01	; 1
    5a80:	ad b7       	in	r26, 0x3d	; 61
    5a82:	be b7       	in	r27, 0x3e	; 62
    5a84:	11 96       	adiw	r26, 0x01	; 1
    5a86:	cd 93       	st	X+, r28
    5a88:	dc 93       	st	X, r29
    5a8a:	12 97       	sbiw	r26, 0x02	; 2
    5a8c:	28 e9       	ldi	r18, 0x98	; 152
    5a8e:	38 e0       	ldi	r19, 0x08	; 8
    5a90:	22 83       	std	Z+2, r18	; 0x02
    5a92:	33 83       	std	Z+3, r19	; 0x03
    5a94:	84 83       	std	Z+4, r24	; 0x04
    5a96:	15 82       	std	Z+5, r1	; 0x05
    5a98:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5a9c:	ed b7       	in	r30, 0x3d	; 61
    5a9e:	fe b7       	in	r31, 0x3e	; 62
    5aa0:	36 96       	adiw	r30, 0x06	; 6
    5aa2:	ed bf       	out	0x3d, r30	; 61
    5aa4:	fe bf       	out	0x3e, r31	; 62
    5aa6:	82 ee       	ldi	r24, 0xE2	; 226
    5aa8:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    5aac:	00 d0       	rcall	.+0      	; 0x5aae <nicRegDump+0xd8>
    5aae:	00 d0       	rcall	.+0      	; 0x5ab0 <nicRegDump+0xda>
    5ab0:	ed b7       	in	r30, 0x3d	; 61
    5ab2:	fe b7       	in	r31, 0x3e	; 62
    5ab4:	31 96       	adiw	r30, 0x01	; 1
    5ab6:	ad b7       	in	r26, 0x3d	; 61
    5ab8:	be b7       	in	r27, 0x3e	; 62
    5aba:	11 96       	adiw	r26, 0x01	; 1
    5abc:	cd 93       	st	X+, r28
    5abe:	dc 93       	st	X, r29
    5ac0:	12 97       	sbiw	r26, 0x02	; 2
    5ac2:	29 e8       	ldi	r18, 0x89	; 137
    5ac4:	38 e0       	ldi	r19, 0x08	; 8
    5ac6:	22 83       	std	Z+2, r18	; 0x02
    5ac8:	33 83       	std	Z+3, r19	; 0x03
    5aca:	84 83       	std	Z+4, r24	; 0x04
    5acc:	15 82       	std	Z+5, r1	; 0x05
    5ace:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5ad2:	ed b7       	in	r30, 0x3d	; 61
    5ad4:	fe b7       	in	r31, 0x3e	; 62
    5ad6:	36 96       	adiw	r30, 0x06	; 6
    5ad8:	ed bf       	out	0x3d, r30	; 61
    5ada:	fe bf       	out	0x3e, r31	; 62
    5adc:	85 ee       	ldi	r24, 0xE5	; 229
    5ade:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    5ae2:	00 d0       	rcall	.+0      	; 0x5ae4 <nicRegDump+0x10e>
    5ae4:	00 d0       	rcall	.+0      	; 0x5ae6 <nicRegDump+0x110>
    5ae6:	ed b7       	in	r30, 0x3d	; 61
    5ae8:	fe b7       	in	r31, 0x3e	; 62
    5aea:	31 96       	adiw	r30, 0x01	; 1
    5aec:	ad b7       	in	r26, 0x3d	; 61
    5aee:	be b7       	in	r27, 0x3e	; 62
    5af0:	11 96       	adiw	r26, 0x01	; 1
    5af2:	cd 93       	st	X+, r28
    5af4:	dc 93       	st	X, r29
    5af6:	12 97       	sbiw	r26, 0x02	; 2
    5af8:	2a e7       	ldi	r18, 0x7A	; 122
    5afa:	38 e0       	ldi	r19, 0x08	; 8
    5afc:	22 83       	std	Z+2, r18	; 0x02
    5afe:	33 83       	std	Z+3, r19	; 0x03
    5b00:	84 83       	std	Z+4, r24	; 0x04
    5b02:	15 82       	std	Z+5, r1	; 0x05
    5b04:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5b08:	ed b7       	in	r30, 0x3d	; 61
    5b0a:	fe b7       	in	r31, 0x3e	; 62
    5b0c:	36 96       	adiw	r30, 0x06	; 6
    5b0e:	ed bf       	out	0x3d, r30	; 61
    5b10:	fe bf       	out	0x3e, r31	; 62
    5b12:	84 ee       	ldi	r24, 0xE4	; 228
    5b14:	0e 94 b4 2a 	call	0x5568	; 0x5568 <enc28j60Read>
    5b18:	00 d0       	rcall	.+0      	; 0x5b1a <nicRegDump+0x144>
    5b1a:	00 d0       	rcall	.+0      	; 0x5b1c <nicRegDump+0x146>
    5b1c:	ed b7       	in	r30, 0x3d	; 61
    5b1e:	fe b7       	in	r31, 0x3e	; 62
    5b20:	31 96       	adiw	r30, 0x01	; 1
    5b22:	ad b7       	in	r26, 0x3d	; 61
    5b24:	be b7       	in	r27, 0x3e	; 62
    5b26:	11 96       	adiw	r26, 0x01	; 1
    5b28:	cd 93       	st	X+, r28
    5b2a:	dc 93       	st	X, r29
    5b2c:	12 97       	sbiw	r26, 0x02	; 2
    5b2e:	2b e6       	ldi	r18, 0x6B	; 107
    5b30:	38 e0       	ldi	r19, 0x08	; 8
    5b32:	22 83       	std	Z+2, r18	; 0x02
    5b34:	33 83       	std	Z+3, r19	; 0x03
    5b36:	84 83       	std	Z+4, r24	; 0x04
    5b38:	15 82       	std	Z+5, r1	; 0x05
    5b3a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5b3e:	ed b7       	in	r30, 0x3d	; 61
    5b40:	fe b7       	in	r31, 0x3e	; 62
    5b42:	36 96       	adiw	r30, 0x06	; 6
    5b44:	ed bf       	out	0x3d, r30	; 61
    5b46:	fe bf       	out	0x3e, r31	; 62
    5b48:	df 91       	pop	r29
    5b4a:	cf 91       	pop	r28
    5b4c:	08 95       	ret

00005b4e <streamQueueInputFun>:
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
  return 0;
}

static int streamQueueInputFun(FILE *istream)
{
    5b4e:	df 93       	push	r29
    5b50:	cf 93       	push	r28
    5b52:	0f 92       	push	r0
    5b54:	cd b7       	in	r28, 0x3d	; 61
    5b56:	de b7       	in	r29, 0x3e	; 62
  char c;
  streamBuffers_t *strBuf = (streamBuffers_t *) istream->udata;
  xQueueReceive(strBuf->Rx, &c, portMAX_DELAY);
    5b58:	dc 01       	movw	r26, r24
    5b5a:	1c 96       	adiw	r26, 0x0c	; 12
    5b5c:	ed 91       	ld	r30, X+
    5b5e:	fc 91       	ld	r31, X
    5b60:	1d 97       	sbiw	r26, 0x0d	; 13
    5b62:	80 81       	ld	r24, Z
    5b64:	91 81       	ldd	r25, Z+1	; 0x01
    5b66:	be 01       	movw	r22, r28
    5b68:	6f 5f       	subi	r22, 0xFF	; 255
    5b6a:	7f 4f       	sbci	r23, 0xFF	; 255
    5b6c:	4f ef       	ldi	r20, 0xFF	; 255
    5b6e:	5f ef       	ldi	r21, 0xFF	; 255
    5b70:	20 e0       	ldi	r18, 0x00	; 0
    5b72:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
  return c;
    5b76:	89 81       	ldd	r24, Y+1	; 0x01
    5b78:	28 2f       	mov	r18, r24
    5b7a:	33 27       	eor	r19, r19
    5b7c:	27 fd       	sbrc	r18, 7
    5b7e:	30 95       	com	r19
}
    5b80:	93 2f       	mov	r25, r19
    5b82:	0f 90       	pop	r0
    5b84:	cf 91       	pop	r28
    5b86:	df 91       	pop	r29
    5b88:	08 95       	ret

00005b8a <streamQueueOutputFun>:
  buffer->Tx = Tx;
  return;
}

static int streamQueueOutputFun(char c, FILE *ostream)
{
    5b8a:	df 93       	push	r29
    5b8c:	cf 93       	push	r28
    5b8e:	0f 92       	push	r0
    5b90:	cd b7       	in	r28, 0x3d	; 61
    5b92:	de b7       	in	r29, 0x3e	; 62
    5b94:	89 83       	std	Y+1, r24	; 0x01
/*  if (xQueueSend( strBuf->Tx, &c, strBuf->tx_timeout))
  {
    return EOF;
  }
  else*/
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
    5b96:	db 01       	movw	r26, r22
    5b98:	1c 96       	adiw	r26, 0x0c	; 12
    5b9a:	ed 91       	ld	r30, X+
    5b9c:	fc 91       	ld	r31, X
    5b9e:	1d 97       	sbiw	r26, 0x0d	; 13
    5ba0:	82 81       	ldd	r24, Z+2	; 0x02
    5ba2:	93 81       	ldd	r25, Z+3	; 0x03
    5ba4:	be 01       	movw	r22, r28
    5ba6:	6f 5f       	subi	r22, 0xFF	; 255
    5ba8:	7f 4f       	sbci	r23, 0xFF	; 255
    5baa:	4f ef       	ldi	r20, 0xFF	; 255
    5bac:	5f ef       	ldi	r21, 0xFF	; 255
    5bae:	20 e0       	ldi	r18, 0x00	; 0
    5bb0:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>
  return 0;
}
    5bb4:	80 e0       	ldi	r24, 0x00	; 0
    5bb6:	90 e0       	ldi	r25, 0x00	; 0
    5bb8:	0f 90       	pop	r0
    5bba:	cf 91       	pop	r28
    5bbc:	df 91       	pop	r29
    5bbe:	08 95       	ret

00005bc0 <initQueueStream>:

static int streamQueueOutputFun(char c, FILE *ostream);
static int streamQueueInputFun(FILE *istream);

void initQueueStream(FILE *stream, streamBuffers_t *buffer, xQueueHandle Rx, xQueueHandle Tx)
{
    5bc0:	fc 01       	movw	r30, r24
    5bc2:	db 01       	movw	r26, r22
  fdev_setup_stream(stream, streamQueueOutputFun, streamQueueInputFun, _FDEV_SETUP_RW);
    5bc4:	85 ec       	ldi	r24, 0xC5	; 197
    5bc6:	9d e2       	ldi	r25, 0x2D	; 45
    5bc8:	80 87       	std	Z+8, r24	; 0x08
    5bca:	91 87       	std	Z+9, r25	; 0x09
    5bcc:	87 ea       	ldi	r24, 0xA7	; 167
    5bce:	9d e2       	ldi	r25, 0x2D	; 45
    5bd0:	82 87       	std	Z+10, r24	; 0x0a
    5bd2:	93 87       	std	Z+11, r25	; 0x0b
    5bd4:	83 e0       	ldi	r24, 0x03	; 3
    5bd6:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, (void *)buffer);
    5bd8:	64 87       	std	Z+12, r22	; 0x0c
    5bda:	75 87       	std	Z+13, r23	; 0x0d
  buffer->Rx = Rx;
    5bdc:	4d 93       	st	X+, r20
    5bde:	5c 93       	st	X, r21
    5be0:	11 97       	sbiw	r26, 0x01	; 1
  buffer->Tx = Tx;
    5be2:	12 96       	adiw	r26, 0x02	; 2
    5be4:	2d 93       	st	X+, r18
    5be6:	3c 93       	st	X, r19
    5be8:	13 97       	sbiw	r26, 0x03	; 3
  return;
}
    5bea:	08 95       	ret
    5bec:	08 95       	ret
    5bee:	08 95       	ret
    5bf0:	80 e0       	ldi	r24, 0x00	; 0
    5bf2:	90 e0       	ldi	r25, 0x00	; 0
    5bf4:	08 95       	ret

00005bf6 <saveNic>:
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
}

void saveNic(void)
{
  eeprom_update_block(&nicState.mac.addr, mymac_eep, 6);
    5bf6:	8e ed       	ldi	r24, 0xDE	; 222
    5bf8:	91 e3       	ldi	r25, 0x31	; 49
    5bfa:	68 e1       	ldi	r22, 0x18	; 24
    5bfc:	70 e0       	ldi	r23, 0x00	; 0
    5bfe:	46 e0       	ldi	r20, 0x06	; 6
    5c00:	50 e0       	ldi	r21, 0x00	; 0
    5c02:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__eeupd_block_x128a1>
}
    5c06:	08 95       	ret

00005c08 <nicInit>:
unsigned int nicPoll(void)                                       { return 0; }


static void nicBufferInit(void)
{
  nicState.bufferSize  = NETWORK_STACK_BUF_SIZE;
    5c08:	80 e0       	ldi	r24, 0x00	; 0
    5c0a:	96 e0       	ldi	r25, 0x06	; 6
    5c0c:	80 93 dc 31 	sts	0x31DC, r24
    5c10:	90 93 dd 31 	sts	0x31DD, r25
  nicState.layer2.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR);
    5c14:	e0 e0       	ldi	r30, 0x00	; 0
    5c16:	fa e7       	ldi	r31, 0x7A	; 122
    5c18:	e0 93 e4 31 	sts	0x31E4, r30
    5c1c:	f0 93 e5 31 	sts	0x31E5, r31
  nicState.layer3.ip   = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
    5c20:	2e e0       	ldi	r18, 0x0E	; 14
    5c22:	3a e7       	ldi	r19, 0x7A	; 122
    5c24:	20 93 e6 31 	sts	0x31E6, r18
    5c28:	30 93 e7 31 	sts	0x31E7, r19
  nicState.layer4.icmp = (struct  netIcmpHeader *)(NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN + IP_HEADER_LEN);
    5c2c:	22 e2       	ldi	r18, 0x22	; 34
    5c2e:	3a e7       	ldi	r19, 0x7A	; 122
    5c30:	20 93 e8 31 	sts	0x31E8, r18
    5c34:	30 93 e9 31 	sts	0x31E9, r19
  #if IPV6_SUPPORT
  nicState.layer3.ipv6 = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  nicState.layer3.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  //nicState.layer4.icmpv6  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  #endif /*IPV6_SUPPORT*/
  memset(nicState.layer2.buf, 0, nicState.bufferSize);
    5c38:	df 01       	movw	r26, r30
    5c3a:	9c 01       	movw	r18, r24
    5c3c:	1d 92       	st	X+, r1
    5c3e:	21 50       	subi	r18, 0x01	; 1
    5c40:	30 40       	sbci	r19, 0x00	; 0
    5c42:	e1 f7       	brne	.-8      	; 0x5c3c <nicInit+0x34>
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
    5c44:	8e ed       	ldi	r24, 0xDE	; 222
    5c46:	91 e3       	ldi	r25, 0x31	; 49
    5c48:	68 e1       	ldi	r22, 0x18	; 24
    5c4a:	70 e0       	ldi	r23, 0x00	; 0
    5c4c:	46 e0       	ldi	r20, 0x06	; 6
    5c4e:	50 e0       	ldi	r21, 0x00	; 0
    5c50:	0e 94 12 5a 	call	0xb424	; 0xb424 <__eerd_block_x128a1>
}

void nicInit()
{
  nicBufferInit();
  nicMacInit();
    5c54:	0e 94 3c 2c 	call	0x5878	; 0x5878 <nicMacInit>
}
    5c58:	08 95       	ret
    5c5a:	6e ed       	ldi	r22, 0xDE	; 222
    5c5c:	71 e3       	ldi	r23, 0x31	; 49
    5c5e:	46 e0       	ldi	r20, 0x06	; 6
    5c60:	50 e0       	ldi	r21, 0x00	; 0
    5c62:	0e 94 f0 56 	call	0xade0	; 0xade0 <strncpy>
    5c66:	08 95       	ret
    5c68:	bc 01       	movw	r22, r24
    5c6a:	8e ed       	ldi	r24, 0xDE	; 222
    5c6c:	91 e3       	ldi	r25, 0x31	; 49
    5c6e:	46 e0       	ldi	r20, 0x06	; 6
    5c70:	50 e0       	ldi	r21, 0x00	; 0
    5c72:	0e 94 f0 56 	call	0xade0	; 0xade0 <strncpy>
    5c76:	0e 94 3c 2c 	call	0x5878	; 0x5878 <nicMacInit>
    5c7a:	08 95       	ret
    5c7c:	00 d0       	rcall	.+0      	; 0x5c7e <nicInit+0x76>
    5c7e:	0f 92       	push	r0
    5c80:	ed b7       	in	r30, 0x3d	; 61
    5c82:	fe b7       	in	r31, 0x3e	; 62
    5c84:	81 83       	std	Z+1, r24	; 0x01
    5c86:	92 83       	std	Z+2, r25	; 0x02
    5c88:	80 ee       	ldi	r24, 0xE0	; 224
    5c8a:	98 e0       	ldi	r25, 0x08	; 8
    5c8c:	83 83       	std	Z+3, r24	; 0x03
    5c8e:	94 83       	std	Z+4, r25	; 0x04
    5c90:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5c94:	0f 90       	pop	r0
    5c96:	0f 90       	pop	r0
    5c98:	0f 90       	pop	r0
    5c9a:	0f 90       	pop	r0
    5c9c:	08 95       	ret

00005c9e <htons>:
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5c9e:	38 2f       	mov	r19, r24
    5ca0:	29 2f       	mov	r18, r25
}
    5ca2:	c9 01       	movw	r24, r18
    5ca4:	08 95       	ret

00005ca6 <htonl>:
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5ca6:	36 2f       	mov	r19, r22
    5ca8:	27 2f       	mov	r18, r23
}

uint32_t htonl(uint32_t val)
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
    5caa:	40 e0       	ldi	r20, 0x00	; 0
    5cac:	50 e0       	ldi	r21, 0x00	; 0
    5cae:	a9 01       	movw	r20, r18
    5cb0:	33 27       	eor	r19, r19
    5cb2:	22 27       	eor	r18, r18
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5cb4:	98 27       	eor	r25, r24
    5cb6:	89 27       	eor	r24, r25
    5cb8:	98 27       	eor	r25, r24
}

uint32_t htonl(uint32_t val)
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
    5cba:	a0 e0       	ldi	r26, 0x00	; 0
    5cbc:	b0 e0       	ldi	r27, 0x00	; 0
    5cbe:	28 2b       	or	r18, r24
    5cc0:	39 2b       	or	r19, r25
    5cc2:	4a 2b       	or	r20, r26
    5cc4:	5b 2b       	or	r21, r27
}
    5cc6:	b9 01       	movw	r22, r18
    5cc8:	ca 01       	movw	r24, r20
    5cca:	08 95       	ret

00005ccc <netChecksum>:


uint16_t netChecksum(uint8_t *data, uint16_t len)
{
    5ccc:	ef 92       	push	r14
    5cce:	ff 92       	push	r15
    5cd0:	0f 93       	push	r16
    5cd2:	1f 93       	push	r17
    5cd4:	fb 01       	movw	r30, r22
    5cd6:	dc 01       	movw	r26, r24
  register uint32_t sum = 0;
    5cd8:	20 e0       	ldi	r18, 0x00	; 0
    5cda:	30 e0       	ldi	r19, 0x00	; 0
    5cdc:	a9 01       	movw	r20, r18

  for (;;) 
  {
    if (len < 2)
    5cde:	e2 30       	cpi	r30, 0x02	; 2
    5ce0:	f1 05       	cpc	r31, r1
    5ce2:	50 f0       	brcs	.+20     	; 0x5cf8 <netChecksum+0x2c>
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    5ce4:	ed 90       	ld	r14, X+
    5ce6:	fd 90       	ld	r15, X+
    5ce8:	00 e0       	ldi	r16, 0x00	; 0
    5cea:	10 e0       	ldi	r17, 0x00	; 0
    5cec:	2e 0d       	add	r18, r14
    5cee:	3f 1d       	adc	r19, r15
    5cf0:	40 1f       	adc	r20, r16
    5cf2:	51 1f       	adc	r21, r17
    data+=2;
    len -= 2;
    5cf4:	32 97       	sbiw	r30, 0x02	; 2
  }
    5cf6:	f3 cf       	rjmp	.-26     	; 0x5cde <netChecksum+0x12>
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
}


uint16_t netChecksum(uint8_t *data, uint16_t len)
    5cf8:	fb 01       	movw	r30, r22
    5cfa:	ee 7f       	andi	r30, 0xFE	; 254
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    data+=2;
    len -= 2;
  }
    5cfc:	e8 0f       	add	r30, r24
    5cfe:	f9 1f       	adc	r31, r25
  if (len)
    5d00:	60 ff       	sbrs	r22, 0
    5d02:	0a c0       	rjmp	.+20     	; 0x5d18 <netChecksum+0x4c>
    sum += *(uint8_t *) data;
    5d04:	80 81       	ld	r24, Z
    5d06:	28 0f       	add	r18, r24
    5d08:	31 1d       	adc	r19, r1
    5d0a:	41 1d       	adc	r20, r1
    5d0c:	51 1d       	adc	r21, r1
    5d0e:	04 c0       	rjmp	.+8      	; 0x5d18 <netChecksum+0x4c>

  while ((len = (uint16_t) (sum >> 16)) != 0)
    sum = (uint16_t) sum + len;
    5d10:	28 0f       	add	r18, r24
    5d12:	39 1f       	adc	r19, r25
    5d14:	40 e0       	ldi	r20, 0x00	; 0
    5d16:	50 e0       	ldi	r21, 0x00	; 0
    len -= 2;
  }
  if (len)
    sum += *(uint8_t *) data;

  while ((len = (uint16_t) (sum >> 16)) != 0)
    5d18:	ca 01       	movw	r24, r20
    5d1a:	00 97       	sbiw	r24, 0x00	; 0
    5d1c:	c9 f7       	brne	.-14     	; 0x5d10 <netChecksum+0x44>
    sum = (uint16_t) sum + len;

  return (uint16_t) sum ^ 0xFFFF;
    5d1e:	20 95       	com	r18
    5d20:	30 95       	com	r19
}
    5d22:	c9 01       	movw	r24, r18
    5d24:	1f 91       	pop	r17
    5d26:	0f 91       	pop	r16
    5d28:	ff 90       	pop	r15
    5d2a:	ef 90       	pop	r14
    5d2c:	08 95       	ret

00005d2e <netPrintEthAddr>:

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
    5d2e:	cf 93       	push	r28
    5d30:	df 93       	push	r29
    5d32:	db 01       	movw	r26, r22
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    5d34:	2d b7       	in	r18, 0x3d	; 61
    5d36:	3e b7       	in	r19, 0x3e	; 62
    5d38:	20 51       	subi	r18, 0x10	; 16
    5d3a:	30 40       	sbci	r19, 0x00	; 0
    5d3c:	2d bf       	out	0x3d, r18	; 61
    5d3e:	3e bf       	out	0x3e, r19	; 62
    5d40:	ed b7       	in	r30, 0x3d	; 61
    5d42:	fe b7       	in	r31, 0x3e	; 62
    5d44:	31 96       	adiw	r30, 0x01	; 1
    5d46:	cd b7       	in	r28, 0x3d	; 61
    5d48:	de b7       	in	r29, 0x3e	; 62
    5d4a:	89 83       	std	Y+1, r24	; 0x01
    5d4c:	9a 83       	std	Y+2, r25	; 0x02
    5d4e:	8b e2       	ldi	r24, 0x2B	; 43
    5d50:	9a e0       	ldi	r25, 0x0A	; 10
    5d52:	82 83       	std	Z+2, r24	; 0x02
    5d54:	93 83       	std	Z+3, r25	; 0x03
    5d56:	8c 91       	ld	r24, X
    5d58:	84 83       	std	Z+4, r24	; 0x04
    5d5a:	15 82       	std	Z+5, r1	; 0x05
    5d5c:	11 96       	adiw	r26, 0x01	; 1
    5d5e:	8c 91       	ld	r24, X
    5d60:	11 97       	sbiw	r26, 0x01	; 1
    5d62:	86 83       	std	Z+6, r24	; 0x06
    5d64:	17 82       	std	Z+7, r1	; 0x07
    5d66:	12 96       	adiw	r26, 0x02	; 2
    5d68:	8c 91       	ld	r24, X
    5d6a:	12 97       	sbiw	r26, 0x02	; 2
    5d6c:	80 87       	std	Z+8, r24	; 0x08
    5d6e:	11 86       	std	Z+9, r1	; 0x09
    5d70:	13 96       	adiw	r26, 0x03	; 3
    5d72:	8c 91       	ld	r24, X
    5d74:	13 97       	sbiw	r26, 0x03	; 3
    5d76:	82 87       	std	Z+10, r24	; 0x0a
    5d78:	13 86       	std	Z+11, r1	; 0x0b
    5d7a:	14 96       	adiw	r26, 0x04	; 4
    5d7c:	8c 91       	ld	r24, X
    5d7e:	14 97       	sbiw	r26, 0x04	; 4
    5d80:	84 87       	std	Z+12, r24	; 0x0c
    5d82:	15 86       	std	Z+13, r1	; 0x0d
    5d84:	15 96       	adiw	r26, 0x05	; 5
    5d86:	8c 91       	ld	r24, X
    5d88:	86 87       	std	Z+14, r24	; 0x0e
    5d8a:	17 86       	std	Z+15, r1	; 0x0f
    5d8c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5d90:	2d b7       	in	r18, 0x3d	; 61
    5d92:	3e b7       	in	r19, 0x3e	; 62
    5d94:	20 5f       	subi	r18, 0xF0	; 240
    5d96:	3f 4f       	sbci	r19, 0xFF	; 255
    5d98:	2d bf       	out	0x3d, r18	; 61
    5d9a:	3e bf       	out	0x3e, r19	; 62
}
    5d9c:	df 91       	pop	r29
    5d9e:	cf 91       	pop	r28
    5da0:	08 95       	ret

00005da2 <netPrintIPAddr>:

void netPrintIPAddr(FILE *stream, uint32_t ipaddr)
{
    5da2:	df 93       	push	r29
    5da4:	cf 93       	push	r28
    5da6:	00 d0       	rcall	.+0      	; 0x5da8 <netPrintIPAddr+0x6>
    5da8:	0f 92       	push	r0
    5daa:	cd b7       	in	r28, 0x3d	; 61
    5dac:	de b7       	in	r29, 0x3e	; 62
    5dae:	49 83       	std	Y+1, r20	; 0x01
    5db0:	5a 83       	std	Y+2, r21	; 0x02
    5db2:	6b 83       	std	Y+3, r22	; 0x03
    5db4:	7c 83       	std	Y+4, r23	; 0x04
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
    5db6:	ae 01       	movw	r20, r28
    5db8:	4f 5f       	subi	r20, 0xFF	; 255
    5dba:	5f 4f       	sbci	r21, 0xFF	; 255
    5dbc:	2d b7       	in	r18, 0x3d	; 61
    5dbe:	3e b7       	in	r19, 0x3e	; 62
    5dc0:	2c 50       	subi	r18, 0x0C	; 12
    5dc2:	30 40       	sbci	r19, 0x00	; 0
    5dc4:	2d bf       	out	0x3d, r18	; 61
    5dc6:	3e bf       	out	0x3e, r19	; 62
    5dc8:	ed b7       	in	r30, 0x3d	; 61
    5dca:	fe b7       	in	r31, 0x3e	; 62
    5dcc:	31 96       	adiw	r30, 0x01	; 1
    5dce:	ad b7       	in	r26, 0x3d	; 61
    5dd0:	be b7       	in	r27, 0x3e	; 62
    5dd2:	11 96       	adiw	r26, 0x01	; 1
    5dd4:	8d 93       	st	X+, r24
    5dd6:	9c 93       	st	X, r25
    5dd8:	12 97       	sbiw	r26, 0x02	; 2
    5dda:	8f e1       	ldi	r24, 0x1F	; 31
    5ddc:	9a e0       	ldi	r25, 0x0A	; 10
    5dde:	82 83       	std	Z+2, r24	; 0x02
    5de0:	93 83       	std	Z+3, r25	; 0x03
    5de2:	89 81       	ldd	r24, Y+1	; 0x01
    5de4:	84 83       	std	Z+4, r24	; 0x04
    5de6:	15 82       	std	Z+5, r1	; 0x05
    5de8:	da 01       	movw	r26, r20
    5dea:	11 96       	adiw	r26, 0x01	; 1
    5dec:	8c 91       	ld	r24, X
    5dee:	11 97       	sbiw	r26, 0x01	; 1
    5df0:	86 83       	std	Z+6, r24	; 0x06
    5df2:	17 82       	std	Z+7, r1	; 0x07
    5df4:	12 96       	adiw	r26, 0x02	; 2
    5df6:	8c 91       	ld	r24, X
    5df8:	12 97       	sbiw	r26, 0x02	; 2
    5dfa:	80 87       	std	Z+8, r24	; 0x08
    5dfc:	11 86       	std	Z+9, r1	; 0x09
    5dfe:	13 96       	adiw	r26, 0x03	; 3
    5e00:	8c 91       	ld	r24, X
    5e02:	82 87       	std	Z+10, r24	; 0x0a
    5e04:	13 86       	std	Z+11, r1	; 0x0b
    5e06:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5e0a:	2d b7       	in	r18, 0x3d	; 61
    5e0c:	3e b7       	in	r19, 0x3e	; 62
    5e0e:	24 5f       	subi	r18, 0xF4	; 244
    5e10:	3f 4f       	sbci	r19, 0xFF	; 255
    5e12:	2d bf       	out	0x3d, r18	; 61
    5e14:	3e bf       	out	0x3e, r19	; 62
}
    5e16:	24 96       	adiw	r28, 0x04	; 4
    5e18:	cd bf       	out	0x3d, r28	; 61
    5e1a:	de bf       	out	0x3e, r29	; 62
    5e1c:	cf 91       	pop	r28
    5e1e:	df 91       	pop	r29
    5e20:	08 95       	ret

00005e22 <netPrintEthHeader>:

void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
    5e22:	0f 93       	push	r16
    5e24:	1f 93       	push	r17
    5e26:	cf 93       	push	r28
    5e28:	df 93       	push	r29
    5e2a:	ec 01       	movw	r28, r24
    5e2c:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
    5e2e:	00 d0       	rcall	.+0      	; 0x5e30 <netPrintEthHeader+0xe>
    5e30:	00 d0       	rcall	.+0      	; 0x5e32 <netPrintEthHeader+0x10>
    5e32:	ed b7       	in	r30, 0x3d	; 61
    5e34:	fe b7       	in	r31, 0x3e	; 62
    5e36:	31 96       	adiw	r30, 0x01	; 1
    5e38:	ad b7       	in	r26, 0x3d	; 61
    5e3a:	be b7       	in	r27, 0x3e	; 62
    5e3c:	11 96       	adiw	r26, 0x01	; 1
    5e3e:	8d 93       	st	X+, r24
    5e40:	9c 93       	st	X, r25
    5e42:	12 97       	sbiw	r26, 0x02	; 2
    5e44:	89 e0       	ldi	r24, 0x09	; 9
    5e46:	9a e0       	ldi	r25, 0x0A	; 10
    5e48:	82 83       	std	Z+2, r24	; 0x02
    5e4a:	93 83       	std	Z+3, r25	; 0x03
    5e4c:	db 01       	movw	r26, r22
    5e4e:	1c 96       	adiw	r26, 0x0c	; 12
    5e50:	8d 91       	ld	r24, X+
    5e52:	9c 91       	ld	r25, X
    5e54:	1d 97       	sbiw	r26, 0x0d	; 13
    5e56:	84 83       	std	Z+4, r24	; 0x04
    5e58:	95 83       	std	Z+5, r25	; 0x05
    5e5a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR(" SRC:"));
    5e5e:	0f 90       	pop	r0
    5e60:	0f 90       	pop	r0
    5e62:	ed b7       	in	r30, 0x3d	; 61
    5e64:	fe b7       	in	r31, 0x3e	; 62
    5e66:	c1 83       	std	Z+1, r28	; 0x01
    5e68:	d2 83       	std	Z+2, r29	; 0x02
    5e6a:	83 e0       	ldi	r24, 0x03	; 3
    5e6c:	9a e0       	ldi	r25, 0x0A	; 10
    5e6e:	83 83       	std	Z+3, r24	; 0x03
    5e70:	94 83       	std	Z+4, r25	; 0x04
    5e72:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->src);
    5e76:	0f 90       	pop	r0
    5e78:	0f 90       	pop	r0
    5e7a:	0f 90       	pop	r0
    5e7c:	0f 90       	pop	r0
    5e7e:	b8 01       	movw	r22, r16
    5e80:	6a 5f       	subi	r22, 0xFA	; 250
    5e82:	7f 4f       	sbci	r23, 0xFF	; 255
    5e84:	ce 01       	movw	r24, r28
    5e86:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
  fprintf_P(stream, PSTR("->DST:"));
    5e8a:	00 d0       	rcall	.+0      	; 0x5e8c <netPrintEthHeader+0x6a>
    5e8c:	0f 92       	push	r0
    5e8e:	ad b7       	in	r26, 0x3d	; 61
    5e90:	be b7       	in	r27, 0x3e	; 62
    5e92:	11 96       	adiw	r26, 0x01	; 1
    5e94:	cd 93       	st	X+, r28
    5e96:	dc 93       	st	X, r29
    5e98:	12 97       	sbiw	r26, 0x02	; 2
    5e9a:	8c ef       	ldi	r24, 0xFC	; 252
    5e9c:	99 e0       	ldi	r25, 0x09	; 9
    5e9e:	13 96       	adiw	r26, 0x03	; 3
    5ea0:	8d 93       	st	X+, r24
    5ea2:	9c 93       	st	X, r25
    5ea4:	14 97       	sbiw	r26, 0x04	; 4
    5ea6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->dest);
    5eaa:	0f 90       	pop	r0
    5eac:	0f 90       	pop	r0
    5eae:	0f 90       	pop	r0
    5eb0:	0f 90       	pop	r0
    5eb2:	ce 01       	movw	r24, r28
    5eb4:	b8 01       	movw	r22, r16
    5eb6:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
}
    5eba:	df 91       	pop	r29
    5ebc:	cf 91       	pop	r28
    5ebe:	1f 91       	pop	r17
    5ec0:	0f 91       	pop	r16
    5ec2:	08 95       	ret

00005ec4 <netPrintIpHeader>:

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
    5ec4:	0f 93       	push	r16
    5ec6:	1f 93       	push	r17
    5ec8:	cf 93       	push	r28
    5eca:	df 93       	push	r29
    5ecc:	ec 01       	movw	r28, r24
    5ece:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Header\r\n"));
    5ed0:	00 d0       	rcall	.+0      	; 0x5ed2 <netPrintIpHeader+0xe>
    5ed2:	0f 92       	push	r0
    5ed4:	ad b7       	in	r26, 0x3d	; 61
    5ed6:	be b7       	in	r27, 0x3e	; 62
    5ed8:	11 96       	adiw	r26, 0x01	; 1
    5eda:	8d 93       	st	X+, r24
    5edc:	9c 93       	st	X, r25
    5ede:	12 97       	sbiw	r26, 0x02	; 2
    5ee0:	80 ef       	ldi	r24, 0xF0	; 240
    5ee2:	99 e0       	ldi	r25, 0x09	; 9
    5ee4:	13 96       	adiw	r26, 0x03	; 3
    5ee6:	8d 93       	st	X+, r24
    5ee8:	9c 93       	st	X, r25
    5eea:	14 97       	sbiw	r26, 0x04	; 4
    5eec:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
    5ef0:	0f 92       	push	r0
    5ef2:	0f 92       	push	r0
    5ef4:	ed b7       	in	r30, 0x3d	; 61
    5ef6:	fe b7       	in	r31, 0x3e	; 62
    5ef8:	31 96       	adiw	r30, 0x01	; 1
    5efa:	ad b7       	in	r26, 0x3d	; 61
    5efc:	be b7       	in	r27, 0x3e	; 62
    5efe:	11 96       	adiw	r26, 0x01	; 1
    5f00:	cd 93       	st	X+, r28
    5f02:	dc 93       	st	X, r29
    5f04:	12 97       	sbiw	r26, 0x02	; 2
    5f06:	81 ee       	ldi	r24, 0xE1	; 225
    5f08:	99 e0       	ldi	r25, 0x09	; 9
    5f0a:	82 83       	std	Z+2, r24	; 0x02
    5f0c:	93 83       	std	Z+3, r25	; 0x03
    5f0e:	d8 01       	movw	r26, r16
    5f10:	8c 91       	ld	r24, X
    5f12:	82 95       	swap	r24
    5f14:	8f 70       	andi	r24, 0x0F	; 15
    5f16:	84 83       	std	Z+4, r24	; 0x04
    5f18:	15 82       	std	Z+5, r1	; 0x05
    5f1a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5f1e:	ed b7       	in	r30, 0x3d	; 61
    5f20:	fe b7       	in	r31, 0x3e	; 62
    5f22:	31 96       	adiw	r30, 0x01	; 1
    5f24:	ad b7       	in	r26, 0x3d	; 61
    5f26:	be b7       	in	r27, 0x3e	; 62
    5f28:	11 96       	adiw	r26, 0x01	; 1
    5f2a:	cd 93       	st	X+, r28
    5f2c:	dc 93       	st	X, r29
    5f2e:	12 97       	sbiw	r26, 0x02	; 2
    5f30:	82 ed       	ldi	r24, 0xD2	; 210
    5f32:	99 e0       	ldi	r25, 0x09	; 9
    5f34:	82 83       	std	Z+2, r24	; 0x02
    5f36:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5f38:	d8 01       	movw	r26, r16
    5f3a:	12 96       	adiw	r26, 0x02	; 2
    5f3c:	8d 91       	ld	r24, X+
    5f3e:	9c 91       	ld	r25, X
    5f40:	13 97       	sbiw	r26, 0x03	; 3
    5f42:	98 27       	eor	r25, r24
    5f44:	89 27       	eor	r24, r25
    5f46:	98 27       	eor	r25, r24

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
  fprintf_P(stream, PSTR("IP Header\r\n"));
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5f48:	84 83       	std	Z+4, r24	; 0x04
    5f4a:	95 83       	std	Z+5, r25	; 0x05
    5f4c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  if(ipheader->proto == IP_PROTO_ICMP)
    5f50:	f8 01       	movw	r30, r16
    5f52:	21 85       	ldd	r18, Z+9	; 0x09
    5f54:	8d b7       	in	r24, 0x3d	; 61
    5f56:	9e b7       	in	r25, 0x3e	; 62
    5f58:	06 96       	adiw	r24, 0x06	; 6
    5f5a:	8d bf       	out	0x3d, r24	; 61
    5f5c:	9e bf       	out	0x3e, r25	; 62
    5f5e:	21 30       	cpi	r18, 0x01	; 1
    5f60:	59 f4       	brne	.+22     	; 0x5f78 <netPrintIpHeader+0xb4>
    fprintf_P(stream, PSTR("Protocol: ICMP\r\n"));
    5f62:	00 d0       	rcall	.+0      	; 0x5f64 <netPrintIpHeader+0xa0>
    5f64:	0f 92       	push	r0
    5f66:	ad b7       	in	r26, 0x3d	; 61
    5f68:	be b7       	in	r27, 0x3e	; 62
    5f6a:	11 96       	adiw	r26, 0x01	; 1
    5f6c:	cd 93       	st	X+, r28
    5f6e:	dc 93       	st	X, r29
    5f70:	12 97       	sbiw	r26, 0x02	; 2
    5f72:	81 ec       	ldi	r24, 0xC1	; 193
    5f74:	99 e0       	ldi	r25, 0x09	; 9
    5f76:	1f c0       	rjmp	.+62     	; 0x5fb6 <netPrintIpHeader+0xf2>
  else if(ipheader->proto == IP_PROTO_TCP)
    5f78:	26 30       	cpi	r18, 0x06	; 6
    5f7a:	89 f4       	brne	.+34     	; 0x5f9e <netPrintIpHeader+0xda>
    fprintf_P(stream, PSTR("Protocol: TCP\r\n"));
    5f7c:	00 d0       	rcall	.+0      	; 0x5f7e <netPrintIpHeader+0xba>
    5f7e:	0f 92       	push	r0
    5f80:	ed b7       	in	r30, 0x3d	; 61
    5f82:	fe b7       	in	r31, 0x3e	; 62
    5f84:	c1 83       	std	Z+1, r28	; 0x01
    5f86:	d2 83       	std	Z+2, r29	; 0x02
    5f88:	81 eb       	ldi	r24, 0xB1	; 177
    5f8a:	99 e0       	ldi	r25, 0x09	; 9
    5f8c:	83 83       	std	Z+3, r24	; 0x03
    5f8e:	94 83       	std	Z+4, r25	; 0x04
    5f90:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5f94:	0f 90       	pop	r0
    5f96:	0f 90       	pop	r0
    5f98:	0f 90       	pop	r0
    5f9a:	0f 90       	pop	r0
    5f9c:	29 c0       	rjmp	.+82     	; 0x5ff0 <netPrintIpHeader+0x12c>
  else if(ipheader->proto == IP_PROTO_UDP)
    5f9e:	21 31       	cpi	r18, 0x11	; 17
    5fa0:	79 f4       	brne	.+30     	; 0x5fc0 <netPrintIpHeader+0xfc>
    fprintf_P(stream, PSTR("Protocol: UDP\r\n"));
    5fa2:	00 d0       	rcall	.+0      	; 0x5fa4 <netPrintIpHeader+0xe0>
    5fa4:	0f 92       	push	r0
    5fa6:	ad b7       	in	r26, 0x3d	; 61
    5fa8:	be b7       	in	r27, 0x3e	; 62
    5faa:	11 96       	adiw	r26, 0x01	; 1
    5fac:	cd 93       	st	X+, r28
    5fae:	dc 93       	st	X, r29
    5fb0:	12 97       	sbiw	r26, 0x02	; 2
    5fb2:	81 ea       	ldi	r24, 0xA1	; 161
    5fb4:	99 e0       	ldi	r25, 0x09	; 9
    5fb6:	13 96       	adiw	r26, 0x03	; 3
    5fb8:	8d 93       	st	X+, r24
    5fba:	9c 93       	st	X, r25
    5fbc:	14 97       	sbiw	r26, 0x04	; 4
    5fbe:	e8 cf       	rjmp	.-48     	; 0x5f90 <netPrintIpHeader+0xcc>
  else
    fprintf_P(stream, PSTR("Protocol: %d\r\n"), ipheader->proto);
    5fc0:	00 d0       	rcall	.+0      	; 0x5fc2 <netPrintIpHeader+0xfe>
    5fc2:	00 d0       	rcall	.+0      	; 0x5fc4 <netPrintIpHeader+0x100>
    5fc4:	ed b7       	in	r30, 0x3d	; 61
    5fc6:	fe b7       	in	r31, 0x3e	; 62
    5fc8:	31 96       	adiw	r30, 0x01	; 1
    5fca:	ad b7       	in	r26, 0x3d	; 61
    5fcc:	be b7       	in	r27, 0x3e	; 62
    5fce:	11 96       	adiw	r26, 0x01	; 1
    5fd0:	cd 93       	st	X+, r28
    5fd2:	dc 93       	st	X, r29
    5fd4:	12 97       	sbiw	r26, 0x02	; 2
    5fd6:	82 e9       	ldi	r24, 0x92	; 146
    5fd8:	99 e0       	ldi	r25, 0x09	; 9
    5fda:	82 83       	std	Z+2, r24	; 0x02
    5fdc:	93 83       	std	Z+3, r25	; 0x03
    5fde:	24 83       	std	Z+4, r18	; 0x04
    5fe0:	15 82       	std	Z+5, r1	; 0x05
    5fe2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    5fe6:	ed b7       	in	r30, 0x3d	; 61
    5fe8:	fe b7       	in	r31, 0x3e	; 62
    5fea:	36 96       	adiw	r30, 0x06	; 6
    5fec:	ed bf       	out	0x3d, r30	; 61
    5fee:	fe bf       	out	0x3e, r31	; 62

  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
    5ff0:	00 d0       	rcall	.+0      	; 0x5ff2 <netPrintIpHeader+0x12e>
    5ff2:	0f 92       	push	r0
    5ff4:	ad b7       	in	r26, 0x3d	; 61
    5ff6:	be b7       	in	r27, 0x3e	; 62
    5ff8:	11 96       	adiw	r26, 0x01	; 1
    5ffa:	cd 93       	st	X+, r28
    5ffc:	dc 93       	st	X, r29
    5ffe:	12 97       	sbiw	r26, 0x02	; 2
    6000:	87 e8       	ldi	r24, 0x87	; 135
    6002:	99 e0       	ldi	r25, 0x09	; 9
    6004:	13 96       	adiw	r26, 0x03	; 3
    6006:	8d 93       	st	X+, r24
    6008:	9c 93       	st	X, r25
    600a:	14 97       	sbiw	r26, 0x04	; 4
    600c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6010:	0f 90       	pop	r0
    6012:	0f 90       	pop	r0
    6014:	0f 90       	pop	r0
    6016:	0f 90       	pop	r0
    6018:	f8 01       	movw	r30, r16
    601a:	64 85       	ldd	r22, Z+12	; 0x0c
    601c:	75 85       	ldd	r23, Z+13	; 0x0d
    601e:	86 85       	ldd	r24, Z+14	; 0x0e
    6020:	97 85       	ldd	r25, Z+15	; 0x0f
    6022:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <htonl>
    6026:	ab 01       	movw	r20, r22
    6028:	bc 01       	movw	r22, r24
    602a:	ce 01       	movw	r24, r28
    602c:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    6030:	00 d0       	rcall	.+0      	; 0x6032 <netPrintIpHeader+0x16e>
    6032:	0f 92       	push	r0
    6034:	ad b7       	in	r26, 0x3d	; 61
    6036:	be b7       	in	r27, 0x3e	; 62
    6038:	11 96       	adiw	r26, 0x01	; 1
    603a:	cd 93       	st	X+, r28
    603c:	dc 93       	st	X, r29
    603e:	12 97       	sbiw	r26, 0x02	; 2
    6040:	84 e8       	ldi	r24, 0x84	; 132
    6042:	99 e0       	ldi	r25, 0x09	; 9
    6044:	13 96       	adiw	r26, 0x03	; 3
    6046:	8d 93       	st	X+, r24
    6048:	9c 93       	st	X, r25
    604a:	14 97       	sbiw	r26, 0x04	; 4
    604c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
    6050:	ed b7       	in	r30, 0x3d	; 61
    6052:	fe b7       	in	r31, 0x3e	; 62
    6054:	c1 83       	std	Z+1, r28	; 0x01
    6056:	d2 83       	std	Z+2, r29	; 0x02
    6058:	89 e7       	ldi	r24, 0x79	; 121
    605a:	99 e0       	ldi	r25, 0x09	; 9
    605c:	83 83       	std	Z+3, r24	; 0x03
    605e:	94 83       	std	Z+4, r25	; 0x04
    6060:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6064:	0f 90       	pop	r0
    6066:	0f 90       	pop	r0
    6068:	0f 90       	pop	r0
    606a:	0f 90       	pop	r0
    606c:	d8 01       	movw	r26, r16
    606e:	50 96       	adiw	r26, 0x10	; 16
    6070:	6d 91       	ld	r22, X+
    6072:	7d 91       	ld	r23, X+
    6074:	8d 91       	ld	r24, X+
    6076:	9c 91       	ld	r25, X
    6078:	53 97       	sbiw	r26, 0x13	; 19
    607a:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <htonl>
    607e:	ab 01       	movw	r20, r22
    6080:	bc 01       	movw	r22, r24
    6082:	ce 01       	movw	r24, r28
    6084:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    6088:	00 d0       	rcall	.+0      	; 0x608a <netPrintIpHeader+0x1c6>
    608a:	0f 92       	push	r0
    608c:	ed b7       	in	r30, 0x3d	; 61
    608e:	fe b7       	in	r31, 0x3e	; 62
    6090:	c1 83       	std	Z+1, r28	; 0x01
    6092:	d2 83       	std	Z+2, r29	; 0x02
    6094:	86 e7       	ldi	r24, 0x76	; 118
    6096:	99 e0       	ldi	r25, 0x09	; 9
    6098:	83 83       	std	Z+3, r24	; 0x03
    609a:	94 83       	std	Z+4, r25	; 0x04
    609c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    60a0:	0f 90       	pop	r0
    60a2:	0f 90       	pop	r0
    60a4:	0f 90       	pop	r0
    60a6:	0f 90       	pop	r0
}
    60a8:	df 91       	pop	r29
    60aa:	cf 91       	pop	r28
    60ac:	1f 91       	pop	r17
    60ae:	0f 91       	pop	r16
    60b0:	08 95       	ret

000060b2 <netPrintTcpHeader>:

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
    60b2:	0f 93       	push	r16
    60b4:	1f 93       	push	r17
    60b6:	cf 93       	push	r28
    60b8:	df 93       	push	r29
    60ba:	ec 01       	movw	r28, r24
    60bc:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("TCP Header\r\n"));
    60be:	00 d0       	rcall	.+0      	; 0x60c0 <netPrintTcpHeader+0xe>
    60c0:	0f 92       	push	r0
    60c2:	ad b7       	in	r26, 0x3d	; 61
    60c4:	be b7       	in	r27, 0x3e	; 62
    60c6:	11 96       	adiw	r26, 0x01	; 1
    60c8:	8d 93       	st	X+, r24
    60ca:	9c 93       	st	X, r25
    60cc:	12 97       	sbiw	r26, 0x02	; 2
    60ce:	89 e6       	ldi	r24, 0x69	; 105
    60d0:	99 e0       	ldi	r25, 0x09	; 9
    60d2:	13 96       	adiw	r26, 0x03	; 3
    60d4:	8d 93       	st	X+, r24
    60d6:	9c 93       	st	X, r25
    60d8:	14 97       	sbiw	r26, 0x04	; 4
    60da:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    60de:	0f 92       	push	r0
    60e0:	0f 92       	push	r0
    60e2:	ed b7       	in	r30, 0x3d	; 61
    60e4:	fe b7       	in	r31, 0x3e	; 62
    60e6:	31 96       	adiw	r30, 0x01	; 1
    60e8:	ad b7       	in	r26, 0x3d	; 61
    60ea:	be b7       	in	r27, 0x3e	; 62
    60ec:	11 96       	adiw	r26, 0x01	; 1
    60ee:	cd 93       	st	X+, r28
    60f0:	dc 93       	st	X, r29
    60f2:	12 97       	sbiw	r26, 0x02	; 2
    60f4:	8a e5       	ldi	r24, 0x5A	; 90
    60f6:	99 e0       	ldi	r25, 0x09	; 9
    60f8:	82 83       	std	Z+2, r24	; 0x02
    60fa:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    60fc:	d8 01       	movw	r26, r16
    60fe:	8d 91       	ld	r24, X+
    6100:	9c 91       	ld	r25, X
    6102:	98 27       	eor	r25, r24
    6104:	89 27       	eor	r24, r25
    6106:	98 27       	eor	r25, r24
}

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    6108:	84 83       	std	Z+4, r24	; 0x04
    610a:	95 83       	std	Z+5, r25	; 0x05
    610c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    6110:	ed b7       	in	r30, 0x3d	; 61
    6112:	fe b7       	in	r31, 0x3e	; 62
    6114:	31 96       	adiw	r30, 0x01	; 1
    6116:	ad b7       	in	r26, 0x3d	; 61
    6118:	be b7       	in	r27, 0x3e	; 62
    611a:	11 96       	adiw	r26, 0x01	; 1
    611c:	cd 93       	st	X+, r28
    611e:	dc 93       	st	X, r29
    6120:	12 97       	sbiw	r26, 0x02	; 2
    6122:	8b e4       	ldi	r24, 0x4B	; 75
    6124:	99 e0       	ldi	r25, 0x09	; 9
    6126:	82 83       	std	Z+2, r24	; 0x02
    6128:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    612a:	d8 01       	movw	r26, r16
    612c:	12 96       	adiw	r26, 0x02	; 2
    612e:	8d 91       	ld	r24, X+
    6130:	9c 91       	ld	r25, X
    6132:	13 97       	sbiw	r26, 0x03	; 3
    6134:	98 27       	eor	r25, r24
    6136:	89 27       	eor	r24, r25
    6138:	98 27       	eor	r25, r24

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    613a:	84 83       	std	Z+4, r24	; 0x04
    613c:	95 83       	std	Z+5, r25	; 0x05
    613e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Seq Num : 0x%x"), htonl(tcpheader->seqno));
    6142:	ed b7       	in	r30, 0x3d	; 61
    6144:	fe b7       	in	r31, 0x3e	; 62
    6146:	36 96       	adiw	r30, 0x06	; 6
    6148:	ed bf       	out	0x3d, r30	; 61
    614a:	fe bf       	out	0x3e, r31	; 62
    614c:	d8 01       	movw	r26, r16
    614e:	14 96       	adiw	r26, 0x04	; 4
    6150:	6d 91       	ld	r22, X+
    6152:	7d 91       	ld	r23, X+
    6154:	8d 91       	ld	r24, X+
    6156:	9c 91       	ld	r25, X
    6158:	17 97       	sbiw	r26, 0x07	; 7
    615a:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <htonl>
    615e:	ed b7       	in	r30, 0x3d	; 61
    6160:	fe b7       	in	r31, 0x3e	; 62
    6162:	38 97       	sbiw	r30, 0x08	; 8
    6164:	ed bf       	out	0x3d, r30	; 61
    6166:	fe bf       	out	0x3e, r31	; 62
    6168:	31 96       	adiw	r30, 0x01	; 1
    616a:	ad b7       	in	r26, 0x3d	; 61
    616c:	be b7       	in	r27, 0x3e	; 62
    616e:	11 96       	adiw	r26, 0x01	; 1
    6170:	cd 93       	st	X+, r28
    6172:	dc 93       	st	X, r29
    6174:	12 97       	sbiw	r26, 0x02	; 2
    6176:	2c e3       	ldi	r18, 0x3C	; 60
    6178:	39 e0       	ldi	r19, 0x09	; 9
    617a:	22 83       	std	Z+2, r18	; 0x02
    617c:	33 83       	std	Z+3, r19	; 0x03
    617e:	64 83       	std	Z+4, r22	; 0x04
    6180:	75 83       	std	Z+5, r23	; 0x05
    6182:	86 83       	std	Z+6, r24	; 0x06
    6184:	97 83       	std	Z+7, r25	; 0x07
    6186:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Ack Num : 0x%x\r\n"), htonl(tcpheader->ackno));
    618a:	ed b7       	in	r30, 0x3d	; 61
    618c:	fe b7       	in	r31, 0x3e	; 62
    618e:	38 96       	adiw	r30, 0x08	; 8
    6190:	ed bf       	out	0x3d, r30	; 61
    6192:	fe bf       	out	0x3e, r31	; 62
    6194:	d8 01       	movw	r26, r16
    6196:	18 96       	adiw	r26, 0x08	; 8
    6198:	6d 91       	ld	r22, X+
    619a:	7d 91       	ld	r23, X+
    619c:	8d 91       	ld	r24, X+
    619e:	9c 91       	ld	r25, X
    61a0:	1b 97       	sbiw	r26, 0x0b	; 11
    61a2:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <htonl>
    61a6:	ed b7       	in	r30, 0x3d	; 61
    61a8:	fe b7       	in	r31, 0x3e	; 62
    61aa:	38 97       	sbiw	r30, 0x08	; 8
    61ac:	ed bf       	out	0x3d, r30	; 61
    61ae:	fe bf       	out	0x3e, r31	; 62
    61b0:	31 96       	adiw	r30, 0x01	; 1
    61b2:	ad b7       	in	r26, 0x3d	; 61
    61b4:	be b7       	in	r27, 0x3e	; 62
    61b6:	11 96       	adiw	r26, 0x01	; 1
    61b8:	cd 93       	st	X+, r28
    61ba:	dc 93       	st	X, r29
    61bc:	12 97       	sbiw	r26, 0x02	; 2
    61be:	2b e2       	ldi	r18, 0x2B	; 43
    61c0:	39 e0       	ldi	r19, 0x09	; 9
    61c2:	22 83       	std	Z+2, r18	; 0x02
    61c4:	33 83       	std	Z+3, r19	; 0x03
    61c6:	64 83       	std	Z+4, r22	; 0x04
    61c8:	75 83       	std	Z+5, r23	; 0x05
    61ca:	86 83       	std	Z+6, r24	; 0x06
    61cc:	97 83       	std	Z+7, r25	; 0x07
    61ce:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Flags   : "));
    61d2:	0f 90       	pop	r0
    61d4:	0f 90       	pop	r0
    61d6:	0f 90       	pop	r0
    61d8:	0f 90       	pop	r0
    61da:	ed b7       	in	r30, 0x3d	; 61
    61dc:	fe b7       	in	r31, 0x3e	; 62
    61de:	c1 83       	std	Z+1, r28	; 0x01
    61e0:	d2 83       	std	Z+2, r29	; 0x02
    61e2:	80 e2       	ldi	r24, 0x20	; 32
    61e4:	99 e0       	ldi	r25, 0x09	; 9
    61e6:	83 83       	std	Z+3, r24	; 0x03
    61e8:	94 83       	std	Z+4, r25	; 0x04
    61ea:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  if(tcpheader->flags & TCP_FLAGS_FIN)
    61ee:	d8 01       	movw	r26, r16
    61f0:	1d 96       	adiw	r26, 0x0d	; 13
    61f2:	8c 91       	ld	r24, X
    61f4:	1d 97       	sbiw	r26, 0x0d	; 13
    61f6:	0f 90       	pop	r0
    61f8:	0f 90       	pop	r0
    61fa:	0f 90       	pop	r0
    61fc:	0f 90       	pop	r0
    61fe:	80 ff       	sbrs	r24, 0
    6200:	10 c0       	rjmp	.+32     	; 0x6222 <netPrintTcpHeader+0x170>
    fprintf_P(stream, PSTR("FIN "));
    6202:	00 d0       	rcall	.+0      	; 0x6204 <netPrintTcpHeader+0x152>
    6204:	0f 92       	push	r0
    6206:	ed b7       	in	r30, 0x3d	; 61
    6208:	fe b7       	in	r31, 0x3e	; 62
    620a:	c1 83       	std	Z+1, r28	; 0x01
    620c:	d2 83       	std	Z+2, r29	; 0x02
    620e:	8b e1       	ldi	r24, 0x1B	; 27
    6210:	99 e0       	ldi	r25, 0x09	; 9
    6212:	83 83       	std	Z+3, r24	; 0x03
    6214:	94 83       	std	Z+4, r25	; 0x04
    6216:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    621a:	0f 90       	pop	r0
    621c:	0f 90       	pop	r0
    621e:	0f 90       	pop	r0
    6220:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_SYN)
    6222:	d8 01       	movw	r26, r16
    6224:	1d 96       	adiw	r26, 0x0d	; 13
    6226:	8c 91       	ld	r24, X
    6228:	1d 97       	sbiw	r26, 0x0d	; 13
    622a:	81 ff       	sbrs	r24, 1
    622c:	10 c0       	rjmp	.+32     	; 0x624e <netPrintTcpHeader+0x19c>
    fprintf_P(stream, PSTR("SYN "));
    622e:	00 d0       	rcall	.+0      	; 0x6230 <netPrintTcpHeader+0x17e>
    6230:	0f 92       	push	r0
    6232:	ed b7       	in	r30, 0x3d	; 61
    6234:	fe b7       	in	r31, 0x3e	; 62
    6236:	c1 83       	std	Z+1, r28	; 0x01
    6238:	d2 83       	std	Z+2, r29	; 0x02
    623a:	86 e1       	ldi	r24, 0x16	; 22
    623c:	99 e0       	ldi	r25, 0x09	; 9
    623e:	83 83       	std	Z+3, r24	; 0x03
    6240:	94 83       	std	Z+4, r25	; 0x04
    6242:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6246:	0f 90       	pop	r0
    6248:	0f 90       	pop	r0
    624a:	0f 90       	pop	r0
    624c:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_RST)
    624e:	d8 01       	movw	r26, r16
    6250:	1d 96       	adiw	r26, 0x0d	; 13
    6252:	8c 91       	ld	r24, X
    6254:	1d 97       	sbiw	r26, 0x0d	; 13
    6256:	82 ff       	sbrs	r24, 2
    6258:	10 c0       	rjmp	.+32     	; 0x627a <netPrintTcpHeader+0x1c8>
    fprintf_P(stream, PSTR("RST "));
    625a:	00 d0       	rcall	.+0      	; 0x625c <netPrintTcpHeader+0x1aa>
    625c:	0f 92       	push	r0
    625e:	ed b7       	in	r30, 0x3d	; 61
    6260:	fe b7       	in	r31, 0x3e	; 62
    6262:	c1 83       	std	Z+1, r28	; 0x01
    6264:	d2 83       	std	Z+2, r29	; 0x02
    6266:	81 e1       	ldi	r24, 0x11	; 17
    6268:	99 e0       	ldi	r25, 0x09	; 9
    626a:	83 83       	std	Z+3, r24	; 0x03
    626c:	94 83       	std	Z+4, r25	; 0x04
    626e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6272:	0f 90       	pop	r0
    6274:	0f 90       	pop	r0
    6276:	0f 90       	pop	r0
    6278:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_PSH)
    627a:	d8 01       	movw	r26, r16
    627c:	1d 96       	adiw	r26, 0x0d	; 13
    627e:	8c 91       	ld	r24, X
    6280:	1d 97       	sbiw	r26, 0x0d	; 13
    6282:	83 ff       	sbrs	r24, 3
    6284:	10 c0       	rjmp	.+32     	; 0x62a6 <netPrintTcpHeader+0x1f4>
    fprintf_P(stream, PSTR("PSH "));
    6286:	00 d0       	rcall	.+0      	; 0x6288 <netPrintTcpHeader+0x1d6>
    6288:	0f 92       	push	r0
    628a:	ed b7       	in	r30, 0x3d	; 61
    628c:	fe b7       	in	r31, 0x3e	; 62
    628e:	c1 83       	std	Z+1, r28	; 0x01
    6290:	d2 83       	std	Z+2, r29	; 0x02
    6292:	8c e0       	ldi	r24, 0x0C	; 12
    6294:	99 e0       	ldi	r25, 0x09	; 9
    6296:	83 83       	std	Z+3, r24	; 0x03
    6298:	94 83       	std	Z+4, r25	; 0x04
    629a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    629e:	0f 90       	pop	r0
    62a0:	0f 90       	pop	r0
    62a2:	0f 90       	pop	r0
    62a4:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_ACK)
    62a6:	d8 01       	movw	r26, r16
    62a8:	1d 96       	adiw	r26, 0x0d	; 13
    62aa:	8c 91       	ld	r24, X
    62ac:	1d 97       	sbiw	r26, 0x0d	; 13
    62ae:	84 ff       	sbrs	r24, 4
    62b0:	10 c0       	rjmp	.+32     	; 0x62d2 <netPrintTcpHeader+0x220>
    fprintf_P(stream, PSTR("ACK "));
    62b2:	00 d0       	rcall	.+0      	; 0x62b4 <netPrintTcpHeader+0x202>
    62b4:	0f 92       	push	r0
    62b6:	ed b7       	in	r30, 0x3d	; 61
    62b8:	fe b7       	in	r31, 0x3e	; 62
    62ba:	c1 83       	std	Z+1, r28	; 0x01
    62bc:	d2 83       	std	Z+2, r29	; 0x02
    62be:	87 e0       	ldi	r24, 0x07	; 7
    62c0:	99 e0       	ldi	r25, 0x09	; 9
    62c2:	83 83       	std	Z+3, r24	; 0x03
    62c4:	94 83       	std	Z+4, r25	; 0x04
    62c6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    62ca:	0f 90       	pop	r0
    62cc:	0f 90       	pop	r0
    62ce:	0f 90       	pop	r0
    62d0:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_URG)
    62d2:	d8 01       	movw	r26, r16
    62d4:	1d 96       	adiw	r26, 0x0d	; 13
    62d6:	8c 91       	ld	r24, X
    62d8:	1d 97       	sbiw	r26, 0x0d	; 13
    62da:	85 ff       	sbrs	r24, 5
    62dc:	10 c0       	rjmp	.+32     	; 0x62fe <netPrintTcpHeader+0x24c>
    fprintf_P(stream, PSTR("URG "));
    62de:	00 d0       	rcall	.+0      	; 0x62e0 <netPrintTcpHeader+0x22e>
    62e0:	0f 92       	push	r0
    62e2:	ed b7       	in	r30, 0x3d	; 61
    62e4:	fe b7       	in	r31, 0x3e	; 62
    62e6:	c1 83       	std	Z+1, r28	; 0x01
    62e8:	d2 83       	std	Z+2, r29	; 0x02
    62ea:	82 e0       	ldi	r24, 0x02	; 2
    62ec:	99 e0       	ldi	r25, 0x09	; 9
    62ee:	83 83       	std	Z+3, r24	; 0x03
    62f0:	94 83       	std	Z+4, r25	; 0x04
    62f2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    62f6:	0f 90       	pop	r0
    62f8:	0f 90       	pop	r0
    62fa:	0f 90       	pop	r0
    62fc:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    62fe:	00 d0       	rcall	.+0      	; 0x6300 <netPrintTcpHeader+0x24e>
    6300:	0f 92       	push	r0
    6302:	ad b7       	in	r26, 0x3d	; 61
    6304:	be b7       	in	r27, 0x3e	; 62
    6306:	11 96       	adiw	r26, 0x01	; 1
    6308:	cd 93       	st	X+, r28
    630a:	dc 93       	st	X, r29
    630c:	12 97       	sbiw	r26, 0x02	; 2
    630e:	8f ef       	ldi	r24, 0xFF	; 255
    6310:	98 e0       	ldi	r25, 0x08	; 8
    6312:	13 96       	adiw	r26, 0x03	; 3
    6314:	8d 93       	st	X+, r24
    6316:	9c 93       	st	X, r25
    6318:	14 97       	sbiw	r26, 0x04	; 4
    631a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    631e:	0f 90       	pop	r0
    6320:	0f 90       	pop	r0
    6322:	0f 90       	pop	r0
    6324:	0f 90       	pop	r0
}
    6326:	df 91       	pop	r29
    6328:	cf 91       	pop	r28
    632a:	1f 91       	pop	r17
    632c:	0f 91       	pop	r16
    632e:	08 95       	ret

00006330 <ipInit>:
static uint32_t mask_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_MASK4 << 24) + ((uint32_t)MY_MASK3 <<16) + ((uint32_t)MY_MASK2 <<8) + MY_MASK1;
static uint32_t defGw_eep   __attribute__((section (".eeprom"))) = ((uint32_t)MY_GW4   << 24) + ((uint32_t)MY_GW3   <<16) + ((uint32_t)MY_GW2   <<8) + MY_GW1;

void ipInit(void)
{
  IpMyConfig.ip      = eeprom_read_dword(&myip_eep);
    6330:	8e e1       	ldi	r24, 0x1E	; 30
    6332:	90 e0       	ldi	r25, 0x00	; 0
    6334:	0e 94 1e 5a 	call	0xb43c	; 0xb43c <__eerd_dword_x128a1>
    6338:	60 93 b0 32 	sts	0x32B0, r22
    633c:	70 93 b1 32 	sts	0x32B1, r23
    6340:	80 93 b2 32 	sts	0x32B2, r24
    6344:	90 93 b3 32 	sts	0x32B3, r25
  IpMyConfig.netmask = eeprom_read_dword(&mask_eep);
    6348:	82 e2       	ldi	r24, 0x22	; 34
    634a:	90 e0       	ldi	r25, 0x00	; 0
    634c:	0e 94 1e 5a 	call	0xb43c	; 0xb43c <__eerd_dword_x128a1>
    6350:	60 93 b4 32 	sts	0x32B4, r22
    6354:	70 93 b5 32 	sts	0x32B5, r23
    6358:	80 93 b6 32 	sts	0x32B6, r24
    635c:	90 93 b7 32 	sts	0x32B7, r25
  IpMyConfig.gateway = eeprom_read_dword(&defGw_eep);
    6360:	86 e2       	ldi	r24, 0x26	; 38
    6362:	90 e0       	ldi	r25, 0x00	; 0
    6364:	0e 94 1e 5a 	call	0xb43c	; 0xb43c <__eerd_dword_x128a1>
    6368:	60 93 b8 32 	sts	0x32B8, r22
    636c:	70 93 b9 32 	sts	0x32B9, r23
    6370:	80 93 ba 32 	sts	0x32BA, r24
    6374:	90 93 bb 32 	sts	0x32BB, r25
#if IP_DEBUG
  IpMyConfig.dbgLevel = 0;
    6378:	10 92 be 32 	sts	0x32BE, r1
  IpMyConfig.dbgStream = NULL;
    637c:	10 92 bc 32 	sts	0x32BC, r1
    6380:	10 92 bd 32 	sts	0x32BD, r1
#endif
}
    6384:	08 95       	ret

00006386 <ipSaveConfig>:

void ipSaveConfig(void)
{
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
    6386:	40 91 b0 32 	lds	r20, 0x32B0
    638a:	50 91 b1 32 	lds	r21, 0x32B1
    638e:	60 91 b2 32 	lds	r22, 0x32B2
    6392:	70 91 b3 32 	lds	r23, 0x32B3
    6396:	8e e1       	ldi	r24, 0x1E	; 30
    6398:	90 e0       	ldi	r25, 0x00	; 0
    639a:	0e 94 45 5a 	call	0xb48a	; 0xb48a <__eeupd_dword_x128a1>
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
    639e:	40 91 b4 32 	lds	r20, 0x32B4
    63a2:	50 91 b5 32 	lds	r21, 0x32B5
    63a6:	60 91 b6 32 	lds	r22, 0x32B6
    63aa:	70 91 b7 32 	lds	r23, 0x32B7
    63ae:	82 e2       	ldi	r24, 0x22	; 34
    63b0:	90 e0       	ldi	r25, 0x00	; 0
    63b2:	0e 94 45 5a 	call	0xb48a	; 0xb48a <__eeupd_dword_x128a1>
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    63b6:	40 91 b8 32 	lds	r20, 0x32B8
    63ba:	50 91 b9 32 	lds	r21, 0x32B9
    63be:	60 91 ba 32 	lds	r22, 0x32BA
    63c2:	70 91 bb 32 	lds	r23, 0x32BB
    63c6:	86 e2       	ldi	r24, 0x26	; 38
    63c8:	90 e0       	ldi	r25, 0x00	; 0
    63ca:	0e 94 45 5a 	call	0xb48a	; 0xb48a <__eeupd_dword_x128a1>
}
    63ce:	08 95       	ret

000063d0 <netstackIPv4Process>:

inline void netstackIPv4Process(void)
{
    63d0:	ef 92       	push	r14
    63d2:	ff 92       	push	r15
    63d4:	0f 93       	push	r16
    63d6:	1f 93       	push	r17
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    63d8:	e0 91 e6 31 	lds	r30, 0x31E6
    63dc:	f0 91 e7 31 	lds	r31, 0x31E7
    63e0:	80 89       	ldd	r24, Z+16	; 0x10
    63e2:	91 89       	ldd	r25, Z+17	; 0x11
    63e4:	a2 89       	ldd	r26, Z+18	; 0x12
    63e6:	b3 89       	ldd	r27, Z+19	; 0x13
    63e8:	e0 90 b0 32 	lds	r14, 0x32B0
    63ec:	f0 90 b1 32 	lds	r15, 0x32B1
    63f0:	00 91 b2 32 	lds	r16, 0x32B2
    63f4:	10 91 b3 32 	lds	r17, 0x32B3
    63f8:	8e 15       	cp	r24, r14
    63fa:	9f 05       	cpc	r25, r15
    63fc:	a0 07       	cpc	r26, r16
    63fe:	b1 07       	cpc	r27, r17
    6400:	d1 f0       	breq	.+52     	; 0x6436 <netstackIPv4Process+0x66>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    6402:	20 91 b4 32 	lds	r18, 0x32B4
    6406:	30 91 b5 32 	lds	r19, 0x32B5
    640a:	40 91 b6 32 	lds	r20, 0x32B6
    640e:	50 91 b7 32 	lds	r21, 0x32B7
    6412:	2e 29       	or	r18, r14
    6414:	3f 29       	or	r19, r15
    6416:	40 2b       	or	r20, r16
    6418:	51 2b       	or	r21, r17
}

inline void netstackIPv4Process(void)
{
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    641a:	82 17       	cp	r24, r18
    641c:	93 07       	cpc	r25, r19
    641e:	a4 07       	cpc	r26, r20
    6420:	b5 07       	cpc	r27, r21
    6422:	49 f0       	breq	.+18     	; 0x6436 <netstackIPv4Process+0x66>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    6424:	8f 3f       	cpi	r24, 0xFF	; 255
    6426:	2f ef       	ldi	r18, 0xFF	; 255
    6428:	92 07       	cpc	r25, r18
    642a:	2f ef       	ldi	r18, 0xFF	; 255
    642c:	a2 07       	cpc	r26, r18
    642e:	2f ef       	ldi	r18, 0xFF	; 255
    6430:	b2 07       	cpc	r27, r18
    6432:	09 f0       	breq	.+2      	; 0x6436 <netstackIPv4Process+0x66>
    6434:	86 c0       	rjmp	.+268    	; 0x6542 <netstackIPv4Process+0x172>
      (nicState.layer3.ip->destipaddr != 0xFFFFFFFF)) 
    return;

// handle ICMP packet
  if(nicState.layer3.ip->proto == IP_PROTO_ICMP)
    6436:	21 85       	ldd	r18, Z+9	; 0x09
    6438:	21 30       	cpi	r18, 0x01	; 1
    643a:	79 f5       	brne	.+94     	; 0x649a <netstackIPv4Process+0xca>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    643c:	80 91 bc 32 	lds	r24, 0x32BC
    6440:	90 91 bd 32 	lds	r25, 0x32BD
    6444:	00 97       	sbiw	r24, 0x00	; 0
    6446:	31 f1       	breq	.+76     	; 0x6494 <netstackIPv4Process+0xc4>
    {
      if (IpMyConfig.dbgLevel > 0)
    6448:	20 91 be 32 	lds	r18, 0x32BE
    644c:	22 23       	and	r18, r18
    644e:	81 f0       	breq	.+32     	; 0x6470 <netstackIPv4Process+0xa0>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
    6450:	00 d0       	rcall	.+0      	; 0x6452 <netstackIPv4Process+0x82>
    6452:	0f 92       	push	r0
    6454:	ed b7       	in	r30, 0x3d	; 61
    6456:	fe b7       	in	r31, 0x3e	; 62
    6458:	81 83       	std	Z+1, r24	; 0x01
    645a:	92 83       	std	Z+2, r25	; 0x02
    645c:	8c e6       	ldi	r24, 0x6C	; 108
    645e:	9b e0       	ldi	r25, 0x0B	; 11
    6460:	83 83       	std	Z+3, r24	; 0x03
    6462:	94 83       	std	Z+4, r25	; 0x04
    6464:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6468:	0f 90       	pop	r0
    646a:	0f 90       	pop	r0
    646c:	0f 90       	pop	r0
    646e:	0f 90       	pop	r0
      if (IpMyConfig.dbgLevel > 2)
    6470:	80 91 be 32 	lds	r24, 0x32BE
    6474:	83 30       	cpi	r24, 0x03	; 3
    6476:	70 f0       	brcs	.+28     	; 0x6494 <netstackIPv4Process+0xc4>
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    6478:	60 91 e6 31 	lds	r22, 0x31E6
    647c:	70 91 e7 31 	lds	r23, 0x31E7
    6480:	40 91 e8 31 	lds	r20, 0x31E8
    6484:	50 91 e9 31 	lds	r21, 0x31E9
    6488:	80 91 bc 32 	lds	r24, 0x32BC
    648c:	90 91 bd 32 	lds	r25, 0x32BD
    6490:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <icmpPrintHeader>
    }
#endif /*IP_DEBUG*/
    icmpIpIn();
    6494:	0e 94 d7 35 	call	0x6bae	; 0x6bae <icmpIpIn>
    return;
    6498:	54 c0       	rjmp	.+168    	; 0x6542 <netstackIPv4Process+0x172>
  }
  if( nicState.layer3.ip->proto == IP_PROTO_UDP )
    649a:	21 31       	cpi	r18, 0x11	; 17
    649c:	e9 f4       	brne	.+58     	; 0x64d8 <netstackIPv4Process+0x108>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    649e:	80 91 bc 32 	lds	r24, 0x32BC
    64a2:	90 91 bd 32 	lds	r25, 0x32BD
    64a6:	00 97       	sbiw	r24, 0x00	; 0
    64a8:	a1 f0       	breq	.+40     	; 0x64d2 <netstackIPv4Process+0x102>
    {
      if (IpMyConfig.dbgLevel > 0)
    64aa:	20 91 be 32 	lds	r18, 0x32BE
    64ae:	22 23       	and	r18, r18
    64b0:	81 f0       	breq	.+32     	; 0x64d2 <netstackIPv4Process+0x102>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    64b2:	00 d0       	rcall	.+0      	; 0x64b4 <netstackIPv4Process+0xe4>
    64b4:	0f 92       	push	r0
    64b6:	ed b7       	in	r30, 0x3d	; 61
    64b8:	fe b7       	in	r31, 0x3e	; 62
    64ba:	81 83       	std	Z+1, r24	; 0x01
    64bc:	92 83       	std	Z+2, r25	; 0x02
    64be:	84 e5       	ldi	r24, 0x54	; 84
    64c0:	9b e0       	ldi	r25, 0x0B	; 11
    64c2:	83 83       	std	Z+3, r24	; 0x03
    64c4:	94 83       	std	Z+4, r25	; 0x04
    64c6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    64ca:	0f 90       	pop	r0
    64cc:	0f 90       	pop	r0
    64ce:	0f 90       	pop	r0
    64d0:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackUDPIPProcess();
    64d2:	0e 94 66 3d 	call	0x7acc	; 0x7acc <netstackUDPIPProcess>
    return;
    64d6:	35 c0       	rjmp	.+106    	; 0x6542 <netstackIPv4Process+0x172>
    64d8:	80 91 bc 32 	lds	r24, 0x32BC
    64dc:	90 91 bd 32 	lds	r25, 0x32BD
  }
  if( nicState.layer3.ip->proto == IP_PROTO_TCP )
    64e0:	26 30       	cpi	r18, 0x06	; 6
    64e2:	c9 f4       	brne	.+50     	; 0x6516 <netstackIPv4Process+0x146>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    64e4:	00 97       	sbiw	r24, 0x00	; 0
    64e6:	a1 f0       	breq	.+40     	; 0x6510 <netstackIPv4Process+0x140>
    {
      if (IpMyConfig.dbgLevel > 0)
    64e8:	20 91 be 32 	lds	r18, 0x32BE
    64ec:	22 23       	and	r18, r18
    64ee:	81 f0       	breq	.+32     	; 0x6510 <netstackIPv4Process+0x140>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: TCP/IP packet\r\n"));
    64f0:	00 d0       	rcall	.+0      	; 0x64f2 <netstackIPv4Process+0x122>
    64f2:	0f 92       	push	r0
    64f4:	ed b7       	in	r30, 0x3d	; 61
    64f6:	fe b7       	in	r31, 0x3e	; 62
    64f8:	81 83       	std	Z+1, r24	; 0x01
    64fa:	92 83       	std	Z+2, r25	; 0x02
    64fc:	8c e3       	ldi	r24, 0x3C	; 60
    64fe:	9b e0       	ldi	r25, 0x0B	; 11
    6500:	83 83       	std	Z+3, r24	; 0x03
    6502:	94 83       	std	Z+4, r25	; 0x04
    6504:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6508:	0f 90       	pop	r0
    650a:	0f 90       	pop	r0
    650c:	0f 90       	pop	r0
    650e:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackTCPIPProcess();
    6510:	0e 94 7d 3c 	call	0x78fa	; 0x78fa <netstackTCPIPProcess>
    return;
    6514:	16 c0       	rjmp	.+44     	; 0x6542 <netstackIPv4Process+0x172>
  }
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6516:	00 97       	sbiw	r24, 0x00	; 0
    6518:	a1 f0       	breq	.+40     	; 0x6542 <netstackIPv4Process+0x172>
  {
    if (IpMyConfig.dbgLevel > 0)
    651a:	20 91 be 32 	lds	r18, 0x32BE
    651e:	22 23       	and	r18, r18
    6520:	81 f0       	breq	.+32     	; 0x6542 <netstackIPv4Process+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
    6522:	00 d0       	rcall	.+0      	; 0x6524 <netstackIPv4Process+0x154>
    6524:	0f 92       	push	r0
    6526:	ed b7       	in	r30, 0x3d	; 61
    6528:	fe b7       	in	r31, 0x3e	; 62
    652a:	81 83       	std	Z+1, r24	; 0x01
    652c:	92 83       	std	Z+2, r25	; 0x02
    652e:	80 e2       	ldi	r24, 0x20	; 32
    6530:	9b e0       	ldi	r25, 0x0B	; 11
    6532:	83 83       	std	Z+3, r24	; 0x03
    6534:	94 83       	std	Z+4, r25	; 0x04
    6536:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    653a:	0f 90       	pop	r0
    653c:	0f 90       	pop	r0
    653e:	0f 90       	pop	r0
    6540:	0f 90       	pop	r0
  }
#endif /*IP_DEBUG*/
}
    6542:	1f 91       	pop	r17
    6544:	0f 91       	pop	r16
    6546:	ff 90       	pop	r15
    6548:	ef 90       	pop	r14
    654a:	08 95       	ret

0000654c <setIpDebug>:

#if IP_DEBUG
void setIpDebug(FILE *stream, uint8_t level)
{
  IpMyConfig.dbgStream = stream;
    654c:	80 93 bc 32 	sts	0x32BC, r24
    6550:	90 93 bd 32 	sts	0x32BD, r25
  IpMyConfig.dbgLevel = level;
    6554:	60 93 be 32 	sts	0x32BE, r22
  if (level == 0)
    6558:	66 23       	and	r22, r22
    655a:	21 f4       	brne	.+8      	; 0x6564 <setIpDebug+0x18>
    IpMyConfig.dbgStream = NULL;
    655c:	10 92 bc 32 	sts	0x32BC, r1
    6560:	10 92 bd 32 	sts	0x32BD, r1
    6564:	08 95       	ret

00006566 <ipSetConfig>:
}
#endif

void ipSetConfig(uint32_t myIp, uint32_t netmask, uint32_t gatewayIp)
{
    6566:	ef 92       	push	r14
    6568:	ff 92       	push	r15
    656a:	0f 93       	push	r16
    656c:	1f 93       	push	r17
  // set local addressing
  IpMyConfig.ip = myIp;
    656e:	60 93 b0 32 	sts	0x32B0, r22
    6572:	70 93 b1 32 	sts	0x32B1, r23
    6576:	80 93 b2 32 	sts	0x32B2, r24
    657a:	90 93 b3 32 	sts	0x32B3, r25
  IpMyConfig.netmask = netmask;
    657e:	20 93 b4 32 	sts	0x32B4, r18
    6582:	30 93 b5 32 	sts	0x32B5, r19
    6586:	40 93 b6 32 	sts	0x32B6, r20
    658a:	50 93 b7 32 	sts	0x32B7, r21
  IpMyConfig.gateway = gatewayIp;
    658e:	e0 92 b8 32 	sts	0x32B8, r14
    6592:	f0 92 b9 32 	sts	0x32B9, r15
    6596:	00 93 ba 32 	sts	0x32BA, r16
    659a:	10 93 bb 32 	sts	0x32BB, r17
}
    659e:	1f 91       	pop	r17
    65a0:	0f 91       	pop	r16
    65a2:	ff 90       	pop	r15
    65a4:	ef 90       	pop	r14
    65a6:	08 95       	ret

000065a8 <ipSetConfigIp>:

void ipSetConfigIp(uint32_t myIp)
{
  // set local addressing
  IpMyConfig.ip = myIp; 
    65a8:	60 93 b0 32 	sts	0x32B0, r22
    65ac:	70 93 b1 32 	sts	0x32B1, r23
    65b0:	80 93 b2 32 	sts	0x32B2, r24
    65b4:	90 93 b3 32 	sts	0x32B3, r25
}
    65b8:	08 95       	ret

000065ba <ipSetConfigMask>:

void ipSetConfigMask(uint32_t netmask)
{
  IpMyConfig.netmask = netmask;
    65ba:	60 93 b4 32 	sts	0x32B4, r22
    65be:	70 93 b5 32 	sts	0x32B5, r23
    65c2:	80 93 b6 32 	sts	0x32B6, r24
    65c6:	90 93 b7 32 	sts	0x32B7, r25
}
    65ca:	08 95       	ret

000065cc <ipSetConfigGw>:

void ipSetConfigGw(uint32_t gatewayIp)
{
  IpMyConfig.gateway = gatewayIp;
    65cc:	60 93 b8 32 	sts	0x32B8, r22
    65d0:	70 93 b9 32 	sts	0x32B9, r23
    65d4:	80 93 ba 32 	sts	0x32BA, r24
    65d8:	90 93 bb 32 	sts	0x32BB, r25
}
    65dc:	08 95       	ret

000065de <ipGetConfig>:


struct ipConfig* ipGetConfig(void)
{
  return &IpMyConfig;
}
    65de:	80 eb       	ldi	r24, 0xB0	; 176
    65e0:	92 e3       	ldi	r25, 0x32	; 50
    65e2:	08 95       	ret

000065e4 <ipSend>:

void ipSend(uint32_t dstIp, uint8_t protocol, uint16_t len)
{
    65e4:	af 92       	push	r10
    65e6:	bf 92       	push	r11
    65e8:	cf 92       	push	r12
    65ea:	df 92       	push	r13
    65ec:	ef 92       	push	r14
    65ee:	ff 92       	push	r15
    65f0:	0f 93       	push	r16
    65f2:	1f 93       	push	r17
    65f4:	df 93       	push	r29
    65f6:	cf 93       	push	r28
    65f8:	0f 92       	push	r0
    65fa:	cd b7       	in	r28, 0x3d	; 61
    65fc:	de b7       	in	r29, 0x3e	; 62
    65fe:	6b 01       	movw	r12, r22
    6600:	7c 01       	movw	r14, r24
    6602:	89 01       	movw	r16, r18
// make pointer to ethernet/IP header
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6604:	80 91 bc 32 	lds	r24, 0x32BC
    6608:	90 91 bd 32 	lds	r25, 0x32BD
    660c:	00 97       	sbiw	r24, 0x00	; 0
    660e:	b1 f0       	breq	.+44     	; 0x663c <ipSend+0x58>
  {  
    if (IpMyConfig.dbgLevel > 2)
    6610:	20 91 be 32 	lds	r18, 0x32BE
    6614:	23 30       	cpi	r18, 0x03	; 3
    6616:	90 f0       	brcs	.+36     	; 0x663c <ipSend+0x58>
      fprintf_P(IpMyConfig.dbgStream, "Sending Ip packet\r\n");
    6618:	00 d0       	rcall	.+0      	; 0x661a <ipSend+0x36>
    661a:	0f 92       	push	r0
    661c:	ed b7       	in	r30, 0x3d	; 61
    661e:	fe b7       	in	r31, 0x3e	; 62
    6620:	81 83       	std	Z+1, r24	; 0x01
    6622:	92 83       	std	Z+2, r25	; 0x02
    6624:	82 e0       	ldi	r24, 0x02	; 2
    6626:	95 e2       	ldi	r25, 0x25	; 37
    6628:	83 83       	std	Z+3, r24	; 0x03
    662a:	94 83       	std	Z+4, r25	; 0x04
    662c:	49 83       	std	Y+1, r20	; 0x01
    662e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6632:	0f 90       	pop	r0
    6634:	0f 90       	pop	r0
    6636:	0f 90       	pop	r0
    6638:	0f 90       	pop	r0
    663a:	49 81       	ldd	r20, Y+1	; 0x01
  }
#endif

// adjust length to add IP header
  len += IP_HEADER_LEN;
    663c:	0c 5e       	subi	r16, 0xEC	; 236
    663e:	1f 4f       	sbci	r17, 0xFF	; 255

// fill IP header
  nicState.layer3.ip->destipaddr = dstIp;
    6640:	e0 91 e6 31 	lds	r30, 0x31E6
    6644:	f0 91 e7 31 	lds	r31, 0x31E7
    6648:	c0 8a       	std	Z+16, r12	; 0x10
    664a:	d1 8a       	std	Z+17, r13	; 0x11
    664c:	e2 8a       	std	Z+18, r14	; 0x12
    664e:	f3 8a       	std	Z+19, r15	; 0x13
  nicState.layer3.ip->srcipaddr  = IpMyConfig.ip;
    6650:	80 91 b0 32 	lds	r24, 0x32B0
    6654:	90 91 b1 32 	lds	r25, 0x32B1
    6658:	a0 91 b2 32 	lds	r26, 0x32B2
    665c:	b0 91 b3 32 	lds	r27, 0x32B3
    6660:	84 87       	std	Z+12, r24	; 0x0c
    6662:	95 87       	std	Z+13, r25	; 0x0d
    6664:	a6 87       	std	Z+14, r26	; 0x0e
    6666:	b7 87       	std	Z+15, r27	; 0x0f
  nicState.layer3.ip->proto      = protocol;
    6668:	41 87       	std	Z+9, r20	; 0x09
  nicState.layer3.ip->len        = htons(len);
    666a:	a0 90 e6 31 	lds	r10, 0x31E6
    666e:	b0 90 e7 31 	lds	r11, 0x31E7
    6672:	c8 01       	movw	r24, r16
    6674:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    6678:	f5 01       	movw	r30, r10
    667a:	82 83       	std	Z+2, r24	; 0x02
    667c:	93 83       	std	Z+3, r25	; 0x03
  nicState.layer3.ip->vhl        = 0x45;
    667e:	e0 91 e6 31 	lds	r30, 0x31E6
    6682:	f0 91 e7 31 	lds	r31, 0x31E7
    6686:	85 e4       	ldi	r24, 0x45	; 69
    6688:	80 83       	st	Z, r24
  nicState.layer3.ip->tos        = 0;
    668a:	e0 91 e6 31 	lds	r30, 0x31E6
    668e:	f0 91 e7 31 	lds	r31, 0x31E7
    6692:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ip->ipid       = 0;
    6694:	e0 91 e6 31 	lds	r30, 0x31E6
    6698:	f0 91 e7 31 	lds	r31, 0x31E7
    669c:	14 82       	std	Z+4, r1	; 0x04
    669e:	15 82       	std	Z+5, r1	; 0x05
  nicState.layer3.ip->ipoffset   = 0;
    66a0:	e0 91 e6 31 	lds	r30, 0x31E6
    66a4:	f0 91 e7 31 	lds	r31, 0x31E7
    66a8:	16 82       	std	Z+6, r1	; 0x06
    66aa:	17 82       	std	Z+7, r1	; 0x07
  nicState.layer3.ip->ttl        = IP_TIME_TO_LIVE;
    66ac:	e0 91 e6 31 	lds	r30, 0x31E6
    66b0:	f0 91 e7 31 	lds	r31, 0x31E7
    66b4:	80 e8       	ldi	r24, 0x80	; 128
    66b6:	80 87       	std	Z+8, r24	; 0x08
  nicState.layer3.ip->ipchksum   = 0;
    66b8:	e0 91 e6 31 	lds	r30, 0x31E6
    66bc:	f0 91 e7 31 	lds	r31, 0x31E7
    66c0:	12 86       	std	Z+10, r1	; 0x0a
    66c2:	13 86       	std	Z+11, r1	; 0x0b

// calculate and apply IP checksum
// DO THIS ONLY AFTER ALL CHANGES HAVE BEEN MADE TO IP HEADER
  nicState.layer3.ip->ipchksum   = netChecksum((uint8_t *)(nicState.layer3.ip), IP_HEADER_LEN);
    66c4:	a0 90 e6 31 	lds	r10, 0x31E6
    66c8:	b0 90 e7 31 	lds	r11, 0x31E7
    66cc:	c5 01       	movw	r24, r10
    66ce:	64 e1       	ldi	r22, 0x14	; 20
    66d0:	70 e0       	ldi	r23, 0x00	; 0
    66d2:	0e 94 66 2e 	call	0x5ccc	; 0x5ccc <netChecksum>
    66d6:	f5 01       	movw	r30, r10
    66d8:	82 87       	std	Z+10, r24	; 0x0a
    66da:	93 87       	std	Z+11, r25	; 0x0b

// add ethernet routing
// check if we need to send to gateway
  if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    66dc:	80 91 b0 32 	lds	r24, 0x32B0
    66e0:	90 91 b1 32 	lds	r25, 0x32B1
    66e4:	a0 91 b2 32 	lds	r26, 0x32B2
    66e8:	b0 91 b3 32 	lds	r27, 0x32B3
    66ec:	8c 25       	eor	r24, r12
    66ee:	9d 25       	eor	r25, r13
    66f0:	ae 25       	eor	r26, r14
    66f2:	bf 25       	eor	r27, r15
    66f4:	20 91 b4 32 	lds	r18, 0x32B4
    66f8:	30 91 b5 32 	lds	r19, 0x32B5
    66fc:	40 91 b6 32 	lds	r20, 0x32B6
    6700:	50 91 b7 32 	lds	r21, 0x32B7
    6704:	82 23       	and	r24, r18
    6706:	93 23       	and	r25, r19
    6708:	a4 23       	and	r26, r20
    670a:	b5 23       	and	r27, r21
    670c:	00 97       	sbiw	r24, 0x00	; 0
    670e:	a1 05       	cpc	r26, r1
    6710:	b1 05       	cpc	r27, r1
    6712:	a1 f4       	brne	.+40     	; 0x673c <ipSend+0x158>
  {
    arpIpOut(0);  // local send
    6714:	60 e0       	ldi	r22, 0x00	; 0
    6716:	70 e0       	ldi	r23, 0x00	; 0
    6718:	cb 01       	movw	r24, r22
    671a:	0e 94 39 36 	call	0x6c72	; 0x6c72 <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    671e:	80 91 bc 32 	lds	r24, 0x32BC
    6722:	90 91 bd 32 	lds	r25, 0x32BD
    6726:	00 97       	sbiw	r24, 0x00	; 0
    6728:	49 f1       	breq	.+82     	; 0x677c <ipSend+0x198>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet on local net\r\n"));
    672a:	00 d0       	rcall	.+0      	; 0x672c <ipSend+0x148>
    672c:	0f 92       	push	r0
    672e:	ed b7       	in	r30, 0x3d	; 61
    6730:	fe b7       	in	r31, 0x3e	; 62
    6732:	81 83       	std	Z+1, r24	; 0x01
    6734:	92 83       	std	Z+2, r25	; 0x02
    6736:	8f ef       	ldi	r24, 0xFF	; 255
    6738:	9a e0       	ldi	r25, 0x0A	; 10
    673a:	18 c0       	rjmp	.+48     	; 0x676c <ipSend+0x188>
#endif
  }
  else
  {
    arpIpOut(IpMyConfig.gateway);  // gateway send
    673c:	60 91 b8 32 	lds	r22, 0x32B8
    6740:	70 91 b9 32 	lds	r23, 0x32B9
    6744:	80 91 ba 32 	lds	r24, 0x32BA
    6748:	90 91 bb 32 	lds	r25, 0x32BB
    674c:	0e 94 39 36 	call	0x6c72	; 0x6c72 <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6750:	80 91 bc 32 	lds	r24, 0x32BC
    6754:	90 91 bd 32 	lds	r25, 0x32BD
    6758:	00 97       	sbiw	r24, 0x00	; 0
    675a:	81 f0       	breq	.+32     	; 0x677c <ipSend+0x198>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet to gateway\r\n"));
    675c:	00 d0       	rcall	.+0      	; 0x675e <ipSend+0x17a>
    675e:	0f 92       	push	r0
    6760:	ed b7       	in	r30, 0x3d	; 61
    6762:	fe b7       	in	r31, 0x3e	; 62
    6764:	81 83       	std	Z+1, r24	; 0x01
    6766:	92 83       	std	Z+2, r25	; 0x02
    6768:	80 ee       	ldi	r24, 0xE0	; 224
    676a:	9a e0       	ldi	r25, 0x0A	; 10
    676c:	83 83       	std	Z+3, r24	; 0x03
    676e:	94 83       	std	Z+4, r25	; 0x04
    6770:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6774:	0f 90       	pop	r0
    6776:	0f 90       	pop	r0
    6778:	0f 90       	pop	r0
    677a:	0f 90       	pop	r0
#endif
  }

// adjust length to add ethernet header
  len += ETH_HEADER_LEN;
    677c:	02 5f       	subi	r16, 0xF2	; 242
    677e:	1f 4f       	sbci	r17, 0xFF	; 255

#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    6780:	80 91 bc 32 	lds	r24, 0x32BC
    6784:	90 91 bd 32 	lds	r25, 0x32BD
    6788:	00 97       	sbiw	r24, 0x00	; 0
    678a:	11 f1       	breq	.+68     	; 0x67d0 <ipSend+0x1ec>
  {
    if (IpMyConfig.dbgLevel > 3)
    678c:	20 91 be 32 	lds	r18, 0x32BE
    6790:	24 30       	cpi	r18, 0x04	; 4
    6792:	f0 f0       	brcs	.+60     	; 0x67d0 <ipSend+0x1ec>
    {
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(ETH_HEADER_LEN, &data[0]);"));
    6794:	00 d0       	rcall	.+0      	; 0x6796 <ipSend+0x1b2>
    6796:	0f 92       	push	r0
    6798:	ed b7       	in	r30, 0x3d	; 61
    679a:	fe b7       	in	r31, 0x3e	; 62
    679c:	81 83       	std	Z+1, r24	; 0x01
    679e:	92 83       	std	Z+2, r25	; 0x02
    67a0:	82 eb       	ldi	r24, 0xB2	; 178
    67a2:	9a e0       	ldi	r25, 0x0A	; 10
    67a4:	83 83       	std	Z+3, r24	; 0x03
    67a6:	94 83       	std	Z+4, r25	; 0x04
    67a8:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    67ac:	80 91 bc 32 	lds	r24, 0x32BC
    67b0:	90 91 bd 32 	lds	r25, 0x32BD
    67b4:	ed b7       	in	r30, 0x3d	; 61
    67b6:	fe b7       	in	r31, 0x3e	; 62
    67b8:	81 83       	std	Z+1, r24	; 0x01
    67ba:	92 83       	std	Z+2, r25	; 0x02
    67bc:	83 e7       	ldi	r24, 0x73	; 115
    67be:	9a e0       	ldi	r25, 0x0A	; 10
    67c0:	83 83       	std	Z+3, r24	; 0x03
    67c2:	94 83       	std	Z+4, r25	; 0x04
    67c4:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    67c8:	0f 90       	pop	r0
    67ca:	0f 90       	pop	r0
    67cc:	0f 90       	pop	r0
    67ce:	0f 90       	pop	r0
    }
  }
#endif
// send it
  nicSend(len);
    67d0:	c8 01       	movw	r24, r16
    67d2:	0e 94 c9 2b 	call	0x5792	; 0x5792 <nicSend>
}
    67d6:	0f 90       	pop	r0
    67d8:	cf 91       	pop	r28
    67da:	df 91       	pop	r29
    67dc:	1f 91       	pop	r17
    67de:	0f 91       	pop	r16
    67e0:	ff 90       	pop	r15
    67e2:	ef 90       	pop	r14
    67e4:	df 90       	pop	r13
    67e6:	cf 90       	pop	r12
    67e8:	bf 90       	pop	r11
    67ea:	af 90       	pop	r10
    67ec:	08 95       	ret

000067ee <ipPrintConfig>:

void ipPrintConfig(FILE *stream, struct ipConfig* config)
{
    67ee:	0f 93       	push	r16
    67f0:	1f 93       	push	r17
    67f2:	cf 93       	push	r28
    67f4:	df 93       	push	r29
    67f6:	ec 01       	movw	r28, r24
    67f8:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Addr : ")); netPrintIPAddr(stream, config->ip);        fprintf_P(stream, PSTR("\r\n"));
    67fa:	00 d0       	rcall	.+0      	; 0x67fc <ipPrintConfig+0xe>
    67fc:	0f 92       	push	r0
    67fe:	ed b7       	in	r30, 0x3d	; 61
    6800:	fe b7       	in	r31, 0x3e	; 62
    6802:	81 83       	std	Z+1, r24	; 0x01
    6804:	92 83       	std	Z+2, r25	; 0x02
    6806:	88 e6       	ldi	r24, 0x68	; 104
    6808:	9a e0       	ldi	r25, 0x0A	; 10
    680a:	83 83       	std	Z+3, r24	; 0x03
    680c:	94 83       	std	Z+4, r25	; 0x04
    680e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6812:	0f 90       	pop	r0
    6814:	0f 90       	pop	r0
    6816:	0f 90       	pop	r0
    6818:	0f 90       	pop	r0
    681a:	f8 01       	movw	r30, r16
    681c:	40 81       	ld	r20, Z
    681e:	51 81       	ldd	r21, Z+1	; 0x01
    6820:	62 81       	ldd	r22, Z+2	; 0x02
    6822:	73 81       	ldd	r23, Z+3	; 0x03
    6824:	ce 01       	movw	r24, r28
    6826:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    682a:	00 d0       	rcall	.+0      	; 0x682c <ipPrintConfig+0x3e>
    682c:	0f 92       	push	r0
    682e:	ed b7       	in	r30, 0x3d	; 61
    6830:	fe b7       	in	r31, 0x3e	; 62
    6832:	c1 83       	std	Z+1, r28	; 0x01
    6834:	d2 83       	std	Z+2, r29	; 0x02
    6836:	85 e6       	ldi	r24, 0x65	; 101
    6838:	9a e0       	ldi	r25, 0x0A	; 10
    683a:	83 83       	std	Z+3, r24	; 0x03
    683c:	94 83       	std	Z+4, r25	; 0x04
    683e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Netmask : ")); netPrintIPAddr(stream, config->netmask);   fprintf_P(stream, PSTR("\r\n"));
    6842:	ed b7       	in	r30, 0x3d	; 61
    6844:	fe b7       	in	r31, 0x3e	; 62
    6846:	c1 83       	std	Z+1, r28	; 0x01
    6848:	d2 83       	std	Z+2, r29	; 0x02
    684a:	8a e5       	ldi	r24, 0x5A	; 90
    684c:	9a e0       	ldi	r25, 0x0A	; 10
    684e:	83 83       	std	Z+3, r24	; 0x03
    6850:	94 83       	std	Z+4, r25	; 0x04
    6852:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6856:	0f 90       	pop	r0
    6858:	0f 90       	pop	r0
    685a:	0f 90       	pop	r0
    685c:	0f 90       	pop	r0
    685e:	f8 01       	movw	r30, r16
    6860:	44 81       	ldd	r20, Z+4	; 0x04
    6862:	55 81       	ldd	r21, Z+5	; 0x05
    6864:	66 81       	ldd	r22, Z+6	; 0x06
    6866:	77 81       	ldd	r23, Z+7	; 0x07
    6868:	ce 01       	movw	r24, r28
    686a:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    686e:	00 d0       	rcall	.+0      	; 0x6870 <ipPrintConfig+0x82>
    6870:	0f 92       	push	r0
    6872:	ed b7       	in	r30, 0x3d	; 61
    6874:	fe b7       	in	r31, 0x3e	; 62
    6876:	c1 83       	std	Z+1, r28	; 0x01
    6878:	d2 83       	std	Z+2, r29	; 0x02
    687a:	87 e5       	ldi	r24, 0x57	; 87
    687c:	9a e0       	ldi	r25, 0x0A	; 10
    687e:	83 83       	std	Z+3, r24	; 0x03
    6880:	94 83       	std	Z+4, r25	; 0x04
    6882:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("Gateway : ")); netPrintIPAddr(stream, config->gateway);   fprintf_P(stream, PSTR("\r\n"));
    6886:	ed b7       	in	r30, 0x3d	; 61
    6888:	fe b7       	in	r31, 0x3e	; 62
    688a:	c1 83       	std	Z+1, r28	; 0x01
    688c:	d2 83       	std	Z+2, r29	; 0x02
    688e:	8c e4       	ldi	r24, 0x4C	; 76
    6890:	9a e0       	ldi	r25, 0x0A	; 10
    6892:	83 83       	std	Z+3, r24	; 0x03
    6894:	94 83       	std	Z+4, r25	; 0x04
    6896:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    689a:	0f 90       	pop	r0
    689c:	0f 90       	pop	r0
    689e:	0f 90       	pop	r0
    68a0:	0f 90       	pop	r0
    68a2:	f8 01       	movw	r30, r16
    68a4:	40 85       	ldd	r20, Z+8	; 0x08
    68a6:	51 85       	ldd	r21, Z+9	; 0x09
    68a8:	62 85       	ldd	r22, Z+10	; 0x0a
    68aa:	73 85       	ldd	r23, Z+11	; 0x0b
    68ac:	ce 01       	movw	r24, r28
    68ae:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    68b2:	00 d0       	rcall	.+0      	; 0x68b4 <ipPrintConfig+0xc6>
    68b4:	0f 92       	push	r0
    68b6:	ed b7       	in	r30, 0x3d	; 61
    68b8:	fe b7       	in	r31, 0x3e	; 62
    68ba:	c1 83       	std	Z+1, r28	; 0x01
    68bc:	d2 83       	std	Z+2, r29	; 0x02
    68be:	89 e4       	ldi	r24, 0x49	; 73
    68c0:	9a e0       	ldi	r25, 0x0A	; 10
    68c2:	83 83       	std	Z+3, r24	; 0x03
    68c4:	94 83       	std	Z+4, r25	; 0x04
    68c6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    68ca:	0f 90       	pop	r0
    68cc:	0f 90       	pop	r0
    68ce:	0f 90       	pop	r0
    68d0:	0f 90       	pop	r0
}
    68d2:	df 91       	pop	r29
    68d4:	cf 91       	pop	r28
    68d6:	1f 91       	pop	r17
    68d8:	0f 91       	pop	r16
    68da:	08 95       	ret

000068dc <icmpInit>:


// functions
void icmpInit(void)
{
  icmpDebug = NULL;
    68dc:	10 92 0a 32 	sts	0x320A, r1
    68e0:	10 92 0b 32 	sts	0x320B, r1
  icmpDebugLevel = 0;
    68e4:	10 92 ad 32 	sts	0x32AD, r1
}
    68e8:	08 95       	ret

000068ea <setIcmpDebug>:
}

#if ICMP_DEBUG
void setIcmpDebug(FILE *stream, uint8_t level)
{
  icmpDebug = stream;
    68ea:	80 93 0a 32 	sts	0x320A, r24
    68ee:	90 93 0b 32 	sts	0x320B, r25
  icmpDebugLevel = level;
    68f2:	60 93 ad 32 	sts	0x32AD, r22
}
    68f6:	08 95       	ret

000068f8 <icmpPrintHeader>:
#endif

void icmpPrintHeader(FILE *stream, struct netIpHeader *ipPacket, struct netIcmpHeader *icmpPacket)
{
    68f8:	ef 92       	push	r14
    68fa:	ff 92       	push	r15
    68fc:	0f 93       	push	r16
    68fe:	1f 93       	push	r17
    6900:	cf 93       	push	r28
    6902:	df 93       	push	r29
    6904:	ec 01       	movw	r28, r24
    6906:	8b 01       	movw	r16, r22
    6908:	7a 01       	movw	r14, r20
  fprintf_P(stream, PSTR("ICMP Packet:\r\n"));
    690a:	00 d0       	rcall	.+0      	; 0x690c <icmpPrintHeader+0x14>
    690c:	0f 92       	push	r0
    690e:	ad b7       	in	r26, 0x3d	; 61
    6910:	be b7       	in	r27, 0x3e	; 62
    6912:	11 96       	adiw	r26, 0x01	; 1
    6914:	8d 93       	st	X+, r24
    6916:	9c 93       	st	X, r25
    6918:	12 97       	sbiw	r26, 0x02	; 2
    691a:	88 ed       	ldi	r24, 0xD8	; 216
    691c:	9b e0       	ldi	r25, 0x0B	; 11
    691e:	13 96       	adiw	r26, 0x03	; 3
    6920:	8d 93       	st	X+, r24
    6922:	9c 93       	st	X, r25
    6924:	14 97       	sbiw	r26, 0x04	; 4
    6926:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print source IP address
  fprintf_P(stream, PSTR("SrcIpAddr: "));  netPrintIPAddr(stream, ipPacket->srcipaddr);  fprintf_P(stream, PSTR("\r\n"));
    692a:	ed b7       	in	r30, 0x3d	; 61
    692c:	fe b7       	in	r31, 0x3e	; 62
    692e:	c1 83       	std	Z+1, r28	; 0x01
    6930:	d2 83       	std	Z+2, r29	; 0x02
    6932:	8c ec       	ldi	r24, 0xCC	; 204
    6934:	9b e0       	ldi	r25, 0x0B	; 11
    6936:	83 83       	std	Z+3, r24	; 0x03
    6938:	94 83       	std	Z+4, r25	; 0x04
    693a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    693e:	0f 90       	pop	r0
    6940:	0f 90       	pop	r0
    6942:	0f 90       	pop	r0
    6944:	0f 90       	pop	r0
    6946:	d8 01       	movw	r26, r16
    6948:	1c 96       	adiw	r26, 0x0c	; 12
    694a:	4d 91       	ld	r20, X+
    694c:	5d 91       	ld	r21, X+
    694e:	6d 91       	ld	r22, X+
    6950:	7c 91       	ld	r23, X
    6952:	1f 97       	sbiw	r26, 0x0f	; 15
    6954:	ce 01       	movw	r24, r28
    6956:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    695a:	00 d0       	rcall	.+0      	; 0x695c <icmpPrintHeader+0x64>
    695c:	0f 92       	push	r0
    695e:	ed b7       	in	r30, 0x3d	; 61
    6960:	fe b7       	in	r31, 0x3e	; 62
    6962:	c1 83       	std	Z+1, r28	; 0x01
    6964:	d2 83       	std	Z+2, r29	; 0x02
    6966:	89 ec       	ldi	r24, 0xC9	; 201
    6968:	9b e0       	ldi	r25, 0x0B	; 11
    696a:	83 83       	std	Z+3, r24	; 0x03
    696c:	94 83       	std	Z+4, r25	; 0x04
    696e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print dest IP address
  fprintf_P(stream, PSTR("DstIpAddr: "));  netPrintIPAddr(stream, ipPacket->destipaddr); fprintf_P(stream, PSTR("\r\n"));
    6972:	ad b7       	in	r26, 0x3d	; 61
    6974:	be b7       	in	r27, 0x3e	; 62
    6976:	11 96       	adiw	r26, 0x01	; 1
    6978:	cd 93       	st	X+, r28
    697a:	dc 93       	st	X, r29
    697c:	12 97       	sbiw	r26, 0x02	; 2
    697e:	8d eb       	ldi	r24, 0xBD	; 189
    6980:	9b e0       	ldi	r25, 0x0B	; 11
    6982:	13 96       	adiw	r26, 0x03	; 3
    6984:	8d 93       	st	X+, r24
    6986:	9c 93       	st	X, r25
    6988:	14 97       	sbiw	r26, 0x04	; 4
    698a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    698e:	0f 90       	pop	r0
    6990:	0f 90       	pop	r0
    6992:	0f 90       	pop	r0
    6994:	0f 90       	pop	r0
    6996:	f8 01       	movw	r30, r16
    6998:	40 89       	ldd	r20, Z+16	; 0x10
    699a:	51 89       	ldd	r21, Z+17	; 0x11
    699c:	62 89       	ldd	r22, Z+18	; 0x12
    699e:	73 89       	ldd	r23, Z+19	; 0x13
    69a0:	ce 01       	movw	r24, r28
    69a2:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    69a6:	00 d0       	rcall	.+0      	; 0x69a8 <icmpPrintHeader+0xb0>
    69a8:	0f 92       	push	r0
    69aa:	ad b7       	in	r26, 0x3d	; 61
    69ac:	be b7       	in	r27, 0x3e	; 62
    69ae:	11 96       	adiw	r26, 0x01	; 1
    69b0:	cd 93       	st	X+, r28
    69b2:	dc 93       	st	X, r29
    69b4:	12 97       	sbiw	r26, 0x02	; 2
    69b6:	8a eb       	ldi	r24, 0xBA	; 186
    69b8:	9b e0       	ldi	r25, 0x0B	; 11
    69ba:	13 96       	adiw	r26, 0x03	; 3
    69bc:	8d 93       	st	X+, r24
    69be:	9c 93       	st	X, r25
    69c0:	14 97       	sbiw	r26, 0x04	; 4
    69c2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print type
  fprintf_P(stream, PSTR("Type   : "));
    69c6:	ed b7       	in	r30, 0x3d	; 61
    69c8:	fe b7       	in	r31, 0x3e	; 62
    69ca:	c1 83       	std	Z+1, r28	; 0x01
    69cc:	d2 83       	std	Z+2, r29	; 0x02
    69ce:	80 eb       	ldi	r24, 0xB0	; 176
    69d0:	9b e0       	ldi	r25, 0x0B	; 11
    69d2:	83 83       	std	Z+3, r24	; 0x03
    69d4:	94 83       	std	Z+4, r25	; 0x04
    69d6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  switch(icmpPacket->type)
    69da:	0f 90       	pop	r0
    69dc:	0f 90       	pop	r0
    69de:	0f 90       	pop	r0
    69e0:	0f 90       	pop	r0
    69e2:	d7 01       	movw	r26, r14
    69e4:	8c 91       	ld	r24, X
    69e6:	88 23       	and	r24, r24
    69e8:	59 f0       	breq	.+22     	; 0x6a00 <icmpPrintHeader+0x108>
    69ea:	88 30       	cpi	r24, 0x08	; 8
    69ec:	c1 f4       	brne	.+48     	; 0x6a1e <icmpPrintHeader+0x126>
  {
    case ICMP_TYPE_ECHOREQUEST:
      fprintf_P(stream, PSTR("ECHO REQUEST"));
    69ee:	00 d0       	rcall	.+0      	; 0x69f0 <icmpPrintHeader+0xf8>
    69f0:	0f 92       	push	r0
    69f2:	ed b7       	in	r30, 0x3d	; 61
    69f4:	fe b7       	in	r31, 0x3e	; 62
    69f6:	c1 83       	std	Z+1, r28	; 0x01
    69f8:	d2 83       	std	Z+2, r29	; 0x02
    69fa:	83 ea       	ldi	r24, 0xA3	; 163
    69fc:	9b e0       	ldi	r25, 0x0B	; 11
    69fe:	17 c0       	rjmp	.+46     	; 0x6a2e <icmpPrintHeader+0x136>
      break;
    case ICMP_TYPE_ECHOREPLY:
      fprintf_P(stream, PSTR("ECHO REPLY"));
    6a00:	00 d0       	rcall	.+0      	; 0x6a02 <icmpPrintHeader+0x10a>
    6a02:	0f 92       	push	r0
    6a04:	ad b7       	in	r26, 0x3d	; 61
    6a06:	be b7       	in	r27, 0x3e	; 62
    6a08:	11 96       	adiw	r26, 0x01	; 1
    6a0a:	cd 93       	st	X+, r28
    6a0c:	dc 93       	st	X, r29
    6a0e:	12 97       	sbiw	r26, 0x02	; 2
    6a10:	88 e9       	ldi	r24, 0x98	; 152
    6a12:	9b e0       	ldi	r25, 0x0B	; 11
    6a14:	13 96       	adiw	r26, 0x03	; 3
    6a16:	8d 93       	st	X+, r24
    6a18:	9c 93       	st	X, r25
    6a1a:	14 97       	sbiw	r26, 0x04	; 4
    6a1c:	0a c0       	rjmp	.+20     	; 0x6a32 <icmpPrintHeader+0x13a>
      break;
    default:
      fprintf_P(stream, ("UNKNOWN"));
    6a1e:	00 d0       	rcall	.+0      	; 0x6a20 <icmpPrintHeader+0x128>
    6a20:	0f 92       	push	r0
    6a22:	ed b7       	in	r30, 0x3d	; 61
    6a24:	fe b7       	in	r31, 0x3e	; 62
    6a26:	c1 83       	std	Z+1, r28	; 0x01
    6a28:	d2 83       	std	Z+2, r29	; 0x02
    6a2a:	86 e1       	ldi	r24, 0x16	; 22
    6a2c:	95 e2       	ldi	r25, 0x25	; 37
    6a2e:	83 83       	std	Z+3, r24	; 0x03
    6a30:	94 83       	std	Z+4, r25	; 0x04
    6a32:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      break;
  }
  fprintf_P(stream, PSTR("\r\n"));
    6a36:	ad b7       	in	r26, 0x3d	; 61
    6a38:	be b7       	in	r27, 0x3e	; 62
    6a3a:	11 96       	adiw	r26, 0x01	; 1
    6a3c:	cd 93       	st	X+, r28
    6a3e:	dc 93       	st	X, r29
    6a40:	12 97       	sbiw	r26, 0x02	; 2
    6a42:	85 e9       	ldi	r24, 0x95	; 149
    6a44:	9b e0       	ldi	r25, 0x0B	; 11
    6a46:	13 96       	adiw	r26, 0x03	; 3
    6a48:	8d 93       	st	X+, r24
    6a4a:	9c 93       	st	X, r25
    6a4c:	14 97       	sbiw	r26, 0x04	; 4
    6a4e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print code
  fprintf_P(stream, PSTR("Code   : 0x%x\r\n"), icmpPacket->icode);
    6a52:	0f 92       	push	r0
    6a54:	0f 92       	push	r0
    6a56:	ed b7       	in	r30, 0x3d	; 61
    6a58:	fe b7       	in	r31, 0x3e	; 62
    6a5a:	31 96       	adiw	r30, 0x01	; 1
    6a5c:	ad b7       	in	r26, 0x3d	; 61
    6a5e:	be b7       	in	r27, 0x3e	; 62
    6a60:	11 96       	adiw	r26, 0x01	; 1
    6a62:	cd 93       	st	X+, r28
    6a64:	dc 93       	st	X, r29
    6a66:	12 97       	sbiw	r26, 0x02	; 2
    6a68:	85 e8       	ldi	r24, 0x85	; 133
    6a6a:	9b e0       	ldi	r25, 0x0B	; 11
    6a6c:	82 83       	std	Z+2, r24	; 0x02
    6a6e:	93 83       	std	Z+3, r25	; 0x03
    6a70:	d7 01       	movw	r26, r14
    6a72:	11 96       	adiw	r26, 0x01	; 1
    6a74:	8c 91       	ld	r24, X
    6a76:	84 83       	std	Z+4, r24	; 0x04
    6a78:	15 82       	std	Z+5, r1	; 0x05
    6a7a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6a7e:	ed b7       	in	r30, 0x3d	; 61
    6a80:	fe b7       	in	r31, 0x3e	; 62
    6a82:	36 96       	adiw	r30, 0x06	; 6
    6a84:	ed bf       	out	0x3d, r30	; 61
    6a86:	fe bf       	out	0x3e, r31	; 62
}
    6a88:	df 91       	pop	r29
    6a8a:	cf 91       	pop	r28
    6a8c:	1f 91       	pop	r17
    6a8e:	0f 91       	pop	r16
    6a90:	ff 90       	pop	r15
    6a92:	ef 90       	pop	r14
    6a94:	08 95       	ret

00006a96 <icmpEchoRequest>:
      break;
  }
}

void icmpEchoRequest(void)
{
    6a96:	cf 93       	push	r28
    6a98:	df 93       	push	r29
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6a9a:	80 91 0a 32 	lds	r24, 0x320A
    6a9e:	90 91 0b 32 	lds	r25, 0x320B
    6aa2:	00 97       	sbiw	r24, 0x00	; 0
    6aa4:	a1 f0       	breq	.+40     	; 0x6ace <icmpEchoRequest+0x38>
  {
    if (icmpDebugLevel > 1)
    6aa6:	20 91 ad 32 	lds	r18, 0x32AD
    6aaa:	22 30       	cpi	r18, 0x02	; 2
    6aac:	80 f0       	brcs	.+32     	; 0x6ace <icmpEchoRequest+0x38>
      fprintf_P(icmpDebug, PSTR("Received ICMP request: "));
    6aae:	00 d0       	rcall	.+0      	; 0x6ab0 <icmpEchoRequest+0x1a>
    6ab0:	0f 92       	push	r0
    6ab2:	ed b7       	in	r30, 0x3d	; 61
    6ab4:	fe b7       	in	r31, 0x3e	; 62
    6ab6:	81 83       	std	Z+1, r24	; 0x01
    6ab8:	92 83       	std	Z+2, r25	; 0x02
    6aba:	8b ef       	ldi	r24, 0xFB	; 251
    6abc:	9b e0       	ldi	r25, 0x0B	; 11
    6abe:	83 83       	std	Z+3, r24	; 0x03
    6ac0:	94 83       	std	Z+4, r25	; 0x04
    6ac2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6ac6:	0f 90       	pop	r0
    6ac8:	0f 90       	pop	r0
    6aca:	0f 90       	pop	r0
    6acc:	0f 90       	pop	r0
  }
#endif
  uint32_t tempIp;

  // change type to reply
  nicState.layer4.icmp->type = ICMP_TYPE_ECHOREPLY;
    6ace:	e0 91 e8 31 	lds	r30, 0x31E8
    6ad2:	f0 91 e9 31 	lds	r31, 0x31E9
    6ad6:	10 82       	st	Z, r1
  // recalculate checksum
  nicState.layer4.icmp->icmpchksum = 0;
    6ad8:	e0 91 e8 31 	lds	r30, 0x31E8
    6adc:	f0 91 e9 31 	lds	r31, 0x31E9
    6ae0:	12 82       	std	Z+2, r1	; 0x02
    6ae2:	13 82       	std	Z+3, r1	; 0x03
  nicState.layer4.icmp->icmpchksum = netChecksum((uint8_t*)(nicState.layer4.icmp), htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
    6ae4:	c0 91 e8 31 	lds	r28, 0x31E8
    6ae8:	d0 91 e9 31 	lds	r29, 0x31E9
    6aec:	e0 91 e6 31 	lds	r30, 0x31E6
    6af0:	f0 91 e7 31 	lds	r31, 0x31E7
    6af4:	82 81       	ldd	r24, Z+2	; 0x02
    6af6:	93 81       	ldd	r25, Z+3	; 0x03
    6af8:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    6afc:	bc 01       	movw	r22, r24
    6afe:	64 51       	subi	r22, 0x14	; 20
    6b00:	70 40       	sbci	r23, 0x00	; 0
    6b02:	ce 01       	movw	r24, r28
    6b04:	0e 94 66 2e 	call	0x5ccc	; 0x5ccc <netChecksum>
    6b08:	8a 83       	std	Y+2, r24	; 0x02
    6b0a:	9b 83       	std	Y+3, r25	; 0x03
  // return to sender
  tempIp = nicState.layer3.ip->destipaddr;
    6b0c:	e0 91 e6 31 	lds	r30, 0x31E6
    6b10:	f0 91 e7 31 	lds	r31, 0x31E7
    6b14:	80 89       	ldd	r24, Z+16	; 0x10
    6b16:	91 89       	ldd	r25, Z+17	; 0x11
    6b18:	a2 89       	ldd	r26, Z+18	; 0x12
    6b1a:	b3 89       	ldd	r27, Z+19	; 0x13
  nicState.layer3.ip->destipaddr = nicState.layer3.ip->srcipaddr;
    6b1c:	24 85       	ldd	r18, Z+12	; 0x0c
    6b1e:	35 85       	ldd	r19, Z+13	; 0x0d
    6b20:	46 85       	ldd	r20, Z+14	; 0x0e
    6b22:	57 85       	ldd	r21, Z+15	; 0x0f
    6b24:	20 8b       	std	Z+16, r18	; 0x10
    6b26:	31 8b       	std	Z+17, r19	; 0x11
    6b28:	42 8b       	std	Z+18, r20	; 0x12
    6b2a:	53 8b       	std	Z+19, r21	; 0x13
  nicState.layer3.ip->srcipaddr = tempIp;
    6b2c:	84 87       	std	Z+12, r24	; 0x0c
    6b2e:	95 87       	std	Z+13, r25	; 0x0d
    6b30:	a6 87       	std	Z+14, r26	; 0x0e
    6b32:	b7 87       	std	Z+15, r27	; 0x0f
  // add ethernet routing
  arpIpOut(0);
    6b34:	60 e0       	ldi	r22, 0x00	; 0
    6b36:	70 e0       	ldi	r23, 0x00	; 0
    6b38:	cb 01       	movw	r24, r22
    6b3a:	0e 94 39 36 	call	0x6c72	; 0x6c72 <arpIpOut>

  // debugging
  if (icmpDebug != NULL)
    6b3e:	80 91 0a 32 	lds	r24, 0x320A
    6b42:	90 91 0b 32 	lds	r25, 0x320B
    6b46:	00 97       	sbiw	r24, 0x00	; 0
    6b48:	51 f0       	breq	.+20     	; 0x6b5e <icmpEchoRequest+0xc8>
    icmpPrintHeader(icmpDebug, nicState.layer3.ip, nicState.layer4.icmp);
    6b4a:	60 91 e6 31 	lds	r22, 0x31E6
    6b4e:	70 91 e7 31 	lds	r23, 0x31E7
    6b52:	40 91 e8 31 	lds	r20, 0x31E8
    6b56:	50 91 e9 31 	lds	r21, 0x31E9
    6b5a:	0e 94 7c 34 	call	0x68f8	; 0x68f8 <icmpPrintHeader>
  //debugPrintHexTable(htons(packet->ip.len), (uint8_t*)packet);

  // send it (packet->ip.len+ETH_HEADER_LEN
  nicSend(htons(nicState.layer3.ip->len) + ETH_HEADER_LEN);
    6b5e:	e0 91 e6 31 	lds	r30, 0x31E6
    6b62:	f0 91 e7 31 	lds	r31, 0x31E7
    6b66:	82 81       	ldd	r24, Z+2	; 0x02
    6b68:	93 81       	ldd	r25, Z+3	; 0x03
    6b6a:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    6b6e:	0e 96       	adiw	r24, 0x0e	; 14
    6b70:	0e 94 c9 2b 	call	0x5792	; 0x5792 <nicSend>
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6b74:	80 91 0a 32 	lds	r24, 0x320A
    6b78:	90 91 0b 32 	lds	r25, 0x320B
    6b7c:	00 97       	sbiw	r24, 0x00	; 0
    6b7e:	a1 f0       	breq	.+40     	; 0x6ba8 <icmpEchoRequest+0x112>
  {
    if (icmpDebugLevel > 1)
    6b80:	20 91 ad 32 	lds	r18, 0x32AD
    6b84:	22 30       	cpi	r18, 0x02	; 2
    6b86:	80 f0       	brcs	.+32     	; 0x6ba8 <icmpEchoRequest+0x112>
      fprintf_P(icmpDebug, PSTR("Sending ICMP PONG\r\n"));
    6b88:	00 d0       	rcall	.+0      	; 0x6b8a <icmpEchoRequest+0xf4>
    6b8a:	0f 92       	push	r0
    6b8c:	ed b7       	in	r30, 0x3d	; 61
    6b8e:	fe b7       	in	r31, 0x3e	; 62
    6b90:	81 83       	std	Z+1, r24	; 0x01
    6b92:	92 83       	std	Z+2, r25	; 0x02
    6b94:	87 ee       	ldi	r24, 0xE7	; 231
    6b96:	9b e0       	ldi	r25, 0x0B	; 11
    6b98:	83 83       	std	Z+3, r24	; 0x03
    6b9a:	94 83       	std	Z+4, r25	; 0x04
    6b9c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6ba0:	0f 90       	pop	r0
    6ba2:	0f 90       	pop	r0
    6ba4:	0f 90       	pop	r0
    6ba6:	0f 90       	pop	r0
  }
#endif
}
    6ba8:	df 91       	pop	r29
    6baa:	cf 91       	pop	r28
    6bac:	08 95       	ret

00006bae <icmpIpIn>:
}

void icmpIpIn(void)
{
  // check ICMP type
  switch(nicState.layer4.icmp->type)
    6bae:	e0 91 e8 31 	lds	r30, 0x31E8
    6bb2:	f0 91 e9 31 	lds	r31, 0x31E9
    6bb6:	80 81       	ld	r24, Z
    6bb8:	88 30       	cpi	r24, 0x08	; 8
    6bba:	19 f4       	brne	.+6      	; 0x6bc2 <icmpIpIn+0x14>
  {
    case ICMP_TYPE_ECHOREQUEST:
      icmpEchoRequest();       // echo request
    6bbc:	0e 94 4b 35 	call	0x6a96	; 0x6a96 <icmpEchoRequest>
      break;
    6bc0:	08 95       	ret
    default:
#if ICMP_DEBUG
      if (icmpDebug != NULL)
    6bc2:	80 91 0a 32 	lds	r24, 0x320A
    6bc6:	90 91 0b 32 	lds	r25, 0x320B
    6bca:	00 97       	sbiw	r24, 0x00	; 0
    6bcc:	a1 f0       	breq	.+40     	; 0x6bf6 <icmpIpIn+0x48>
      {
        if (icmpDebugLevel > 0)
    6bce:	20 91 ad 32 	lds	r18, 0x32AD
    6bd2:	22 23       	and	r18, r18
    6bd4:	81 f0       	breq	.+32     	; 0x6bf6 <icmpIpIn+0x48>
          fprintf_P(icmpDebug, PSTR("Unknown ICMP typeReceived ICMP request: "));
    6bd6:	00 d0       	rcall	.+0      	; 0x6bd8 <icmpIpIn+0x2a>
    6bd8:	0f 92       	push	r0
    6bda:	ed b7       	in	r30, 0x3d	; 61
    6bdc:	fe b7       	in	r31, 0x3e	; 62
    6bde:	81 83       	std	Z+1, r24	; 0x01
    6be0:	92 83       	std	Z+2, r25	; 0x02
    6be2:	83 e1       	ldi	r24, 0x13	; 19
    6be4:	9c e0       	ldi	r25, 0x0C	; 12
    6be6:	83 83       	std	Z+3, r24	; 0x03
    6be8:	94 83       	std	Z+4, r25	; 0x04
    6bea:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6bee:	0f 90       	pop	r0
    6bf0:	0f 90       	pop	r0
    6bf2:	0f 90       	pop	r0
    6bf4:	0f 90       	pop	r0
    6bf6:	08 95       	ret

00006bf8 <setArpDebug>:

#ifdef ARP_DEBUG

void setArpDebug(FILE *stream, uint8_t level)
{
  arpDebug = stream;
    6bf8:	80 93 ec 31 	sts	0x31EC, r24
    6bfc:	90 93 ed 31 	sts	0x31ED, r25
  arpDebugLevel = level;
    6c00:	60 93 bf 32 	sts	0x32BF, r22
  if (level == 0)
    6c04:	66 23       	and	r22, r22
    6c06:	21 f4       	brne	.+8      	; 0x6c10 <setArpDebug+0x18>
    arpDebug = NULL;
    6c08:	10 92 ec 31 	sts	0x31EC, r1
    6c0c:	10 92 ed 31 	sts	0x31ED, r1
    6c10:	08 95       	ret

00006c12 <arpInit>:
#endif /*ARP_DEBUG*/

void arpInit()
{

  memset(ArpTable, 0, sizeof(ArpTable));
    6c12:	8e e6       	ldi	r24, 0x6E	; 110
    6c14:	ea ec       	ldi	r30, 0xCA	; 202
    6c16:	f2 e3       	ldi	r31, 0x32	; 50
    6c18:	df 01       	movw	r26, r30
    6c1a:	1d 92       	st	X+, r1
    6c1c:	8a 95       	dec	r24
    6c1e:	e9 f7       	brne	.-6      	; 0x6c1a <arpInit+0x8>
  arpDebug = NULL;
    6c20:	10 92 ec 31 	sts	0x31EC, r1
    6c24:	10 92 ed 31 	sts	0x31ED, r1
}
    6c28:	08 95       	ret

00006c2a <arpTimer>:
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}

void arpTimer(void)
{
    6c2a:	e4 ed       	ldi	r30, 0xD4	; 212
    6c2c:	f2 e3       	ldi	r31, 0x32	; 50
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time)
    6c2e:	80 81       	ld	r24, Z
    6c30:	88 23       	and	r24, r24
    6c32:	11 f0       	breq	.+4      	; 0x6c38 <arpTimer+0xe>
      ArpTable[index].time--;
    6c34:	81 50       	subi	r24, 0x01	; 1
    6c36:	80 83       	st	Z, r24
    6c38:	3b 96       	adiw	r30, 0x0b	; 11
{
  int index;
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6c3a:	83 e3       	ldi	r24, 0x33	; 51
    6c3c:	e2 34       	cpi	r30, 0x42	; 66
    6c3e:	f8 07       	cpc	r31, r24
    6c40:	b1 f7       	brne	.-20     	; 0x6c2e <arpTimer+0x4>
  {
    if(ArpTable[index].time)
      ArpTable[index].time--;
  }
}
    6c42:	08 95       	ret

00006c44 <arpMatchIp>:
      return i;
    }
  }

// no match
  return -1;
    6c44:	aa ec       	ldi	r26, 0xCA	; 202
    6c46:	b2 e3       	ldi	r27, 0x32	; 50
      ArpTable[index].time--;
  }
}

int arpMatchIp(uint32_t ipaddr)
{
    6c48:	e0 e0       	ldi	r30, 0x00	; 0
    6c4a:	f0 e0       	ldi	r31, 0x00	; 0
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    6c4c:	2d 91       	ld	r18, X+
    6c4e:	3d 91       	ld	r19, X+
    6c50:	4d 91       	ld	r20, X+
    6c52:	5c 91       	ld	r21, X
    6c54:	13 97       	sbiw	r26, 0x03	; 3
    6c56:	26 17       	cp	r18, r22
    6c58:	37 07       	cpc	r19, r23
    6c5a:	48 07       	cpc	r20, r24
    6c5c:	59 07       	cpc	r21, r25
    6c5e:	39 f0       	breq	.+14     	; 0x6c6e <arpMatchIp+0x2a>
    6c60:	31 96       	adiw	r30, 0x01	; 1
    6c62:	1b 96       	adiw	r26, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    6c64:	ea 30       	cpi	r30, 0x0A	; 10
    6c66:	f1 05       	cpc	r31, r1
    6c68:	89 f7       	brne	.-30     	; 0x6c4c <arpMatchIp+0x8>
      return i;
    }
  }

// no match
  return -1;
    6c6a:	ef ef       	ldi	r30, 0xFF	; 255
    6c6c:	ff ef       	ldi	r31, 0xFF	; 255
}
    6c6e:	cf 01       	movw	r24, r30
    6c70:	08 95       	ret

00006c72 <arpIpOut>:
void arpIpOut(uint32_t phyDstIp)
{
  int index;
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    6c72:	61 15       	cp	r22, r1
    6c74:	71 05       	cpc	r23, r1
    6c76:	81 05       	cpc	r24, r1
    6c78:	91 05       	cpc	r25, r1
    6c7a:	41 f4       	brne	.+16     	; 0x6c8c <arpIpOut+0x1a>
    index = arpMatchIp(phyDstIp);
  else
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
    6c7c:	e0 91 e6 31 	lds	r30, 0x31E6
    6c80:	f0 91 e7 31 	lds	r31, 0x31E7
    6c84:	60 89       	ldd	r22, Z+16	; 0x10
    6c86:	71 89       	ldd	r23, Z+17	; 0x11
    6c88:	82 89       	ldd	r24, Z+18	; 0x12
    6c8a:	93 89       	ldd	r25, Z+19	; 0x13
    6c8c:	0e 94 22 36 	call	0x6c44	; 0x6c44 <arpMatchIp>
    6c90:	a0 91 e4 31 	lds	r26, 0x31E4
    6c94:	b0 91 e5 31 	lds	r27, 0x31E5
// fill in ethernet info
  if(index != -1)
    6c98:	2f ef       	ldi	r18, 0xFF	; 255
    6c9a:	8f 3f       	cpi	r24, 0xFF	; 255
    6c9c:	92 07       	cpc	r25, r18
    6c9e:	01 f1       	breq	.+64     	; 0x6ce0 <arpIpOut+0x6e>
  {
// ARP entry present, fill eth address(es)
    nicState.layer2.ethHeader->src      = nicState.mac;
    6ca0:	16 96       	adiw	r26, 0x06	; 6
    6ca2:	ee ed       	ldi	r30, 0xDE	; 222
    6ca4:	f1 e3       	ldi	r31, 0x31	; 49
    6ca6:	26 e0       	ldi	r18, 0x06	; 6
    6ca8:	01 90       	ld	r0, Z+
    6caa:	0d 92       	st	X+, r0
    6cac:	21 50       	subi	r18, 0x01	; 1
    6cae:	e1 f7       	brne	.-8      	; 0x6ca8 <arpIpOut+0x36>
    nicState.layer2.ethHeader->dest     = ArpTable[index].ethaddr;
    6cb0:	2b e0       	ldi	r18, 0x0B	; 11
    6cb2:	30 e0       	ldi	r19, 0x00	; 0
    6cb4:	82 9f       	mul	r24, r18
    6cb6:	f0 01       	movw	r30, r0
    6cb8:	83 9f       	mul	r24, r19
    6cba:	f0 0d       	add	r31, r0
    6cbc:	92 9f       	mul	r25, r18
    6cbe:	f0 0d       	add	r31, r0
    6cc0:	11 24       	eor	r1, r1
    6cc2:	30 91 e4 31 	lds	r19, 0x31E4
    6cc6:	20 91 e5 31 	lds	r18, 0x31E5
    6cca:	83 2f       	mov	r24, r19
    6ccc:	92 2f       	mov	r25, r18
    6cce:	dc 01       	movw	r26, r24
    6cd0:	e2 53       	subi	r30, 0x32	; 50
    6cd2:	fd 4c       	sbci	r31, 0xCD	; 205
    6cd4:	86 e0       	ldi	r24, 0x06	; 6
    6cd6:	01 90       	ld	r0, Z+
    6cd8:	0d 92       	st	X+, r0
    6cda:	81 50       	subi	r24, 0x01	; 1
    6cdc:	e1 f7       	brne	.-8      	; 0x6cd6 <arpIpOut+0x64>
    6cde:	12 c0       	rjmp	.+36     	; 0x6d04 <arpIpOut+0x92>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
  }
  else
  {
// not in table, must send ARP request
    nicState.layer2.ethHeader->src      = nicState.mac;
    6ce0:	16 96       	adiw	r26, 0x06	; 6
    6ce2:	ee ed       	ldi	r30, 0xDE	; 222
    6ce4:	f1 e3       	ldi	r31, 0x31	; 49
    6ce6:	86 e0       	ldi	r24, 0x06	; 6
    6ce8:	01 90       	ld	r0, Z+
    6cea:	0d 92       	st	X+, r0
    6cec:	81 50       	subi	r24, 0x01	; 1
    6cee:	e1 f7       	brne	.-8      	; 0x6ce8 <arpIpOut+0x76>
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    6cf0:	80 91 e4 31 	lds	r24, 0x31E4
    6cf4:	90 91 e5 31 	lds	r25, 0x31E5
    6cf8:	6f ef       	ldi	r22, 0xFF	; 255
    6cfa:	70 e0       	ldi	r23, 0x00	; 0
    6cfc:	46 e0       	ldi	r20, 0x06	; 6
    6cfe:	50 e0       	ldi	r21, 0x00	; 0
    6d00:	0e 94 c9 56 	call	0xad92	; 0xad92 <memset>
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
    6d04:	e0 91 e4 31 	lds	r30, 0x31E4
    6d08:	f0 91 e5 31 	lds	r31, 0x31E5
    6d0c:	88 e0       	ldi	r24, 0x08	; 8
    6d0e:	90 e0       	ldi	r25, 0x00	; 0
    6d10:	84 87       	std	Z+12, r24	; 0x0c
    6d12:	95 87       	std	Z+13, r25	; 0x0d
    6d14:	08 95       	ret

00006d16 <arpIpIn>:
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
  }
}

void arpIpIn(void)
{
    6d16:	cf 93       	push	r28
    6d18:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    6d1a:	80 91 ec 31 	lds	r24, 0x31EC
    6d1e:	90 91 ed 31 	lds	r25, 0x31ED
    6d22:	00 97       	sbiw	r24, 0x00	; 0
    6d24:	09 f4       	brne	.+2      	; 0x6d28 <arpIpIn+0x12>
    6d26:	57 c0       	rjmp	.+174    	; 0x6dd6 <arpIpIn+0xc0>
  {
    if (arpDebugLevel > 0)
    6d28:	20 91 bf 32 	lds	r18, 0x32BF
    6d2c:	22 23       	and	r18, r18
    6d2e:	09 f4       	brne	.+2      	; 0x6d32 <arpIpIn+0x1c>
    6d30:	52 c0       	rjmp	.+164    	; 0x6dd6 <arpIpIn+0xc0>
    {
      fprintf_P(arpDebug, PSTR("ARP IP in MAC: "));
    6d32:	00 d0       	rcall	.+0      	; 0x6d34 <arpIpIn+0x1e>
    6d34:	0f 92       	push	r0
    6d36:	ed b7       	in	r30, 0x3d	; 61
    6d38:	fe b7       	in	r31, 0x3e	; 62
    6d3a:	81 83       	std	Z+1, r24	; 0x01
    6d3c:	92 83       	std	Z+2, r25	; 0x02
    6d3e:	86 e2       	ldi	r24, 0x26	; 38
    6d40:	9d e0       	ldi	r25, 0x0D	; 13
    6d42:	83 83       	std	Z+3, r24	; 0x03
    6d44:	94 83       	std	Z+4, r25	; 0x04
    6d46:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      netPrintEthAddr(arpDebug, &nicState.layer2.ethHeader->src);
    6d4a:	0f 90       	pop	r0
    6d4c:	0f 90       	pop	r0
    6d4e:	0f 90       	pop	r0
    6d50:	0f 90       	pop	r0
    6d52:	60 91 e4 31 	lds	r22, 0x31E4
    6d56:	70 91 e5 31 	lds	r23, 0x31E5
    6d5a:	6a 5f       	subi	r22, 0xFA	; 250
    6d5c:	7f 4f       	sbci	r23, 0xFF	; 255
    6d5e:	80 91 ec 31 	lds	r24, 0x31EC
    6d62:	90 91 ed 31 	lds	r25, 0x31ED
    6d66:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
      fprintf_P(arpDebug, PSTR(" IP: "));
    6d6a:	00 d0       	rcall	.+0      	; 0x6d6c <arpIpIn+0x56>
    6d6c:	0f 92       	push	r0
    6d6e:	80 91 ec 31 	lds	r24, 0x31EC
    6d72:	90 91 ed 31 	lds	r25, 0x31ED
    6d76:	ed b7       	in	r30, 0x3d	; 61
    6d78:	fe b7       	in	r31, 0x3e	; 62
    6d7a:	81 83       	std	Z+1, r24	; 0x01
    6d7c:	92 83       	std	Z+2, r25	; 0x02
    6d7e:	80 e2       	ldi	r24, 0x20	; 32
    6d80:	9d e0       	ldi	r25, 0x0D	; 13
    6d82:	83 83       	std	Z+3, r24	; 0x03
    6d84:	94 83       	std	Z+4, r25	; 0x04
    6d86:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      netPrintIPAddr(arpDebug, nicState.layer3.ip->srcipaddr);
    6d8a:	0f 90       	pop	r0
    6d8c:	0f 90       	pop	r0
    6d8e:	0f 90       	pop	r0
    6d90:	0f 90       	pop	r0
    6d92:	e0 91 e6 31 	lds	r30, 0x31E6
    6d96:	f0 91 e7 31 	lds	r31, 0x31E7
    6d9a:	44 85       	ldd	r20, Z+12	; 0x0c
    6d9c:	55 85       	ldd	r21, Z+13	; 0x0d
    6d9e:	66 85       	ldd	r22, Z+14	; 0x0e
    6da0:	77 85       	ldd	r23, Z+15	; 0x0f
    6da2:	80 91 ec 31 	lds	r24, 0x31EC
    6da6:	90 91 ed 31 	lds	r25, 0x31ED
    6daa:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
      fprintf_P(arpDebug, PSTR("\r\n"));
    6dae:	00 d0       	rcall	.+0      	; 0x6db0 <arpIpIn+0x9a>
    6db0:	0f 92       	push	r0
    6db2:	80 91 ec 31 	lds	r24, 0x31EC
    6db6:	90 91 ed 31 	lds	r25, 0x31ED
    6dba:	ed b7       	in	r30, 0x3d	; 61
    6dbc:	fe b7       	in	r31, 0x3e	; 62
    6dbe:	81 83       	std	Z+1, r24	; 0x01
    6dc0:	92 83       	std	Z+2, r25	; 0x02
    6dc2:	8d e1       	ldi	r24, 0x1D	; 29
    6dc4:	9d e0       	ldi	r25, 0x0D	; 13
    6dc6:	83 83       	std	Z+3, r24	; 0x03
    6dc8:	94 83       	std	Z+4, r25	; 0x04
    6dca:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6dce:	0f 90       	pop	r0
    6dd0:	0f 90       	pop	r0
    6dd2:	0f 90       	pop	r0
    6dd4:	0f 90       	pop	r0
  }
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
    6dd6:	c0 91 e6 31 	lds	r28, 0x31E6
    6dda:	d0 91 e7 31 	lds	r29, 0x31E7
    6dde:	6c 85       	ldd	r22, Y+12	; 0x0c
    6de0:	7d 85       	ldd	r23, Y+13	; 0x0d
    6de2:	8e 85       	ldd	r24, Y+14	; 0x0e
    6de4:	9f 85       	ldd	r25, Y+15	; 0x0f
    6de6:	0e 94 22 36 	call	0x6c44	; 0x6c44 <arpMatchIp>
  if(index != -1)
    6dea:	8f 3f       	cpi	r24, 0xFF	; 255
    6dec:	21 f1       	breq	.+72     	; 0x6e36 <arpIpIn+0x120>
  {
// sender's IP address found, update ARP entry
    ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6dee:	99 27       	eor	r25, r25
    6df0:	87 fd       	sbrc	r24, 7
    6df2:	90 95       	com	r25
    6df4:	2b e0       	ldi	r18, 0x0B	; 11
    6df6:	30 e0       	ldi	r19, 0x00	; 0
    6df8:	82 9f       	mul	r24, r18
    6dfa:	d0 01       	movw	r26, r0
    6dfc:	83 9f       	mul	r24, r19
    6dfe:	b0 0d       	add	r27, r0
    6e00:	92 9f       	mul	r25, r18
    6e02:	b0 0d       	add	r27, r0
    6e04:	11 24       	eor	r1, r1
    6e06:	e0 91 e4 31 	lds	r30, 0x31E4
    6e0a:	f0 91 e5 31 	lds	r31, 0x31E5
    6e0e:	a2 53       	subi	r26, 0x32	; 50
    6e10:	bd 4c       	sbci	r27, 0xCD	; 205
    6e12:	36 96       	adiw	r30, 0x06	; 6
    6e14:	26 e0       	ldi	r18, 0x06	; 6
    6e16:	01 90       	ld	r0, Z+
    6e18:	0d 92       	st	X+, r0
    6e1a:	21 50       	subi	r18, 0x01	; 1
    6e1c:	e1 f7       	brne	.-8      	; 0x6e16 <arpIpIn+0x100>
    ArpTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    6e1e:	2b e0       	ldi	r18, 0x0B	; 11
    6e20:	30 e0       	ldi	r19, 0x00	; 0
    6e22:	82 9f       	mul	r24, r18
    6e24:	f0 01       	movw	r30, r0
    6e26:	83 9f       	mul	r24, r19
    6e28:	f0 0d       	add	r31, r0
    6e2a:	92 9f       	mul	r25, r18
    6e2c:	f0 0d       	add	r31, r0
    6e2e:	11 24       	eor	r1, r1
    6e30:	e6 53       	subi	r30, 0x36	; 54
    6e32:	fd 4c       	sbci	r31, 0xCD	; 205
    6e34:	2f c0       	rjmp	.+94     	; 0x6e94 <arpIpIn+0x17e>
// and we're done
    return;
    6e36:	e4 ed       	ldi	r30, 0xD4	; 212
    6e38:	f2 e3       	ldi	r31, 0x32	; 50
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
  if(index != -1)
    6e3a:	80 e0       	ldi	r24, 0x00	; 0
    6e3c:	90 e0       	ldi	r25, 0x00	; 0

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time == 0)
    6e3e:	20 81       	ld	r18, Z
    6e40:	22 23       	and	r18, r18
    6e42:	59 f5       	brne	.+86     	; 0x6e9a <arpIpIn+0x184>
    {
// write entry
      ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6e44:	2b e0       	ldi	r18, 0x0B	; 11
    6e46:	30 e0       	ldi	r19, 0x00	; 0
    6e48:	82 9f       	mul	r24, r18
    6e4a:	d0 01       	movw	r26, r0
    6e4c:	83 9f       	mul	r24, r19
    6e4e:	b0 0d       	add	r27, r0
    6e50:	92 9f       	mul	r25, r18
    6e52:	b0 0d       	add	r27, r0
    6e54:	11 24       	eor	r1, r1
    6e56:	e0 91 e4 31 	lds	r30, 0x31E4
    6e5a:	f0 91 e5 31 	lds	r31, 0x31E5
    6e5e:	a2 53       	subi	r26, 0x32	; 50
    6e60:	bd 4c       	sbci	r27, 0xCD	; 205
    6e62:	36 96       	adiw	r30, 0x06	; 6
    6e64:	26 e0       	ldi	r18, 0x06	; 6
    6e66:	01 90       	ld	r0, Z+
    6e68:	0d 92       	st	X+, r0
    6e6a:	21 50       	subi	r18, 0x01	; 1
    6e6c:	e1 f7       	brne	.-8      	; 0x6e66 <arpIpIn+0x150>
      ArpTable[index].ipaddr  = nicState.layer3.ip->srcipaddr;
    6e6e:	2b e0       	ldi	r18, 0x0B	; 11
    6e70:	30 e0       	ldi	r19, 0x00	; 0
    6e72:	82 9f       	mul	r24, r18
    6e74:	f0 01       	movw	r30, r0
    6e76:	83 9f       	mul	r24, r19
    6e78:	f0 0d       	add	r31, r0
    6e7a:	92 9f       	mul	r25, r18
    6e7c:	f0 0d       	add	r31, r0
    6e7e:	11 24       	eor	r1, r1
    6e80:	e6 53       	subi	r30, 0x36	; 54
    6e82:	fd 4c       	sbci	r31, 0xCD	; 205
    6e84:	8c 85       	ldd	r24, Y+12	; 0x0c
    6e86:	9d 85       	ldd	r25, Y+13	; 0x0d
    6e88:	ae 85       	ldd	r26, Y+14	; 0x0e
    6e8a:	bf 85       	ldd	r27, Y+15	; 0x0f
    6e8c:	80 83       	st	Z, r24
    6e8e:	91 83       	std	Z+1, r25	; 0x01
    6e90:	a2 83       	std	Z+2, r26	; 0x02
    6e92:	b3 83       	std	Z+3, r27	; 0x03
      ArpTable[index].time    = ARP_CACHE_TIME_TO_LIVE;
    6e94:	80 e8       	ldi	r24, 0x80	; 128
    6e96:	82 87       	std	Z+10, r24	; 0x0a
// and we're done
      return;
    6e98:	05 c0       	rjmp	.+10     	; 0x6ea4 <arpIpIn+0x18e>
    6e9a:	01 96       	adiw	r24, 0x01	; 1
    6e9c:	3b 96       	adiw	r30, 0x0b	; 11
    return;
  }

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6e9e:	8a 30       	cpi	r24, 0x0A	; 10
    6ea0:	91 05       	cpc	r25, r1
    6ea2:	69 f6       	brne	.-102    	; 0x6e3e <arpIpIn+0x128>
// and we're done
      return;
    }
  }
// no space in table, we give up
}
    6ea4:	df 91       	pop	r29
    6ea6:	cf 91       	pop	r28
    6ea8:	08 95       	ret

00006eaa <arpPrintHeader>:
  return -1;
}

#if ARP_DEBUG
void arpPrintHeader(FILE *stream, struct netArpHeader* packet)
{
    6eaa:	ef 92       	push	r14
    6eac:	ff 92       	push	r15
    6eae:	0f 93       	push	r16
    6eb0:	1f 93       	push	r17
    6eb2:	cf 93       	push	r28
    6eb4:	df 93       	push	r29
    6eb6:	ec 01       	movw	r28, r24
    6eb8:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("ARP Packet:\r\n"));
    6eba:	00 d0       	rcall	.+0      	; 0x6ebc <arpPrintHeader+0x12>
    6ebc:	0f 92       	push	r0
    6ebe:	ed b7       	in	r30, 0x3d	; 61
    6ec0:	fe b7       	in	r31, 0x3e	; 62
    6ec2:	81 83       	std	Z+1, r24	; 0x01
    6ec4:	92 83       	std	Z+2, r25	; 0x02
    6ec6:	8f e0       	ldi	r24, 0x0F	; 15
    6ec8:	9d e0       	ldi	r25, 0x0D	; 13
    6eca:	83 83       	std	Z+3, r24	; 0x03
    6ecc:	94 83       	std	Z+4, r25	; 0x04
    6ece:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  //debugPrintHexTable(60, (unsigned char*)&packet);
  // print operation type
  fprintf_P(stream, PSTR("Operation   : "));
    6ed2:	ed b7       	in	r30, 0x3d	; 61
    6ed4:	fe b7       	in	r31, 0x3e	; 62
    6ed6:	c1 83       	std	Z+1, r28	; 0x01
    6ed8:	d2 83       	std	Z+2, r29	; 0x02
    6eda:	80 e0       	ldi	r24, 0x00	; 0
    6edc:	9d e0       	ldi	r25, 0x0D	; 13
    6ede:	83 83       	std	Z+3, r24	; 0x03
    6ee0:	94 83       	std	Z+4, r25	; 0x04
    6ee2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  if(packet->opcode == htons(ARP_OPCODE_REQUEST))
    6ee6:	f8 01       	movw	r30, r16
    6ee8:	e6 80       	ldd	r14, Z+6	; 0x06
    6eea:	f7 80       	ldd	r15, Z+7	; 0x07
    6eec:	0f 90       	pop	r0
    6eee:	0f 90       	pop	r0
    6ef0:	0f 90       	pop	r0
    6ef2:	0f 90       	pop	r0
    6ef4:	81 e0       	ldi	r24, 0x01	; 1
    6ef6:	90 e0       	ldi	r25, 0x00	; 0
    6ef8:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    6efc:	e8 16       	cp	r14, r24
    6efe:	f9 06       	cpc	r15, r25
    6f00:	49 f4       	brne	.+18     	; 0x6f14 <arpPrintHeader+0x6a>
    fprintf_P(stream, PSTR("REQUEST"));
    6f02:	00 d0       	rcall	.+0      	; 0x6f04 <arpPrintHeader+0x5a>
    6f04:	0f 92       	push	r0
    6f06:	ed b7       	in	r30, 0x3d	; 61
    6f08:	fe b7       	in	r31, 0x3e	; 62
    6f0a:	c1 83       	std	Z+1, r28	; 0x01
    6f0c:	d2 83       	std	Z+2, r29	; 0x02
    6f0e:	88 ef       	ldi	r24, 0xF8	; 248
    6f10:	9c e0       	ldi	r25, 0x0C	; 12
    6f12:	1b c0       	rjmp	.+54     	; 0x6f4a <arpPrintHeader+0xa0>
  else if(packet->opcode == htons(ARP_OPCODE_REPLY))
    6f14:	f8 01       	movw	r30, r16
    6f16:	e6 80       	ldd	r14, Z+6	; 0x06
    6f18:	f7 80       	ldd	r15, Z+7	; 0x07
    6f1a:	82 e0       	ldi	r24, 0x02	; 2
    6f1c:	90 e0       	ldi	r25, 0x00	; 0
    6f1e:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    6f22:	e8 16       	cp	r14, r24
    6f24:	f9 06       	cpc	r15, r25
    6f26:	49 f4       	brne	.+18     	; 0x6f3a <arpPrintHeader+0x90>
    fprintf_P(stream, PSTR("REPLY"));
    6f28:	00 d0       	rcall	.+0      	; 0x6f2a <arpPrintHeader+0x80>
    6f2a:	0f 92       	push	r0
    6f2c:	ed b7       	in	r30, 0x3d	; 61
    6f2e:	fe b7       	in	r31, 0x3e	; 62
    6f30:	c1 83       	std	Z+1, r28	; 0x01
    6f32:	d2 83       	std	Z+2, r29	; 0x02
    6f34:	82 ef       	ldi	r24, 0xF2	; 242
    6f36:	9c e0       	ldi	r25, 0x0C	; 12
    6f38:	08 c0       	rjmp	.+16     	; 0x6f4a <arpPrintHeader+0xa0>
  else
    fprintf_P(stream, PSTR("UNKNOWN"));
    6f3a:	00 d0       	rcall	.+0      	; 0x6f3c <arpPrintHeader+0x92>
    6f3c:	0f 92       	push	r0
    6f3e:	ed b7       	in	r30, 0x3d	; 61
    6f40:	fe b7       	in	r31, 0x3e	; 62
    6f42:	c1 83       	std	Z+1, r28	; 0x01
    6f44:	d2 83       	std	Z+2, r29	; 0x02
    6f46:	8a ee       	ldi	r24, 0xEA	; 234
    6f48:	9c e0       	ldi	r25, 0x0C	; 12
    6f4a:	83 83       	std	Z+3, r24	; 0x03
    6f4c:	94 83       	std	Z+4, r25	; 0x04
    6f4e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n"));
    6f52:	ed b7       	in	r30, 0x3d	; 61
    6f54:	fe b7       	in	r31, 0x3e	; 62
    6f56:	c1 83       	std	Z+1, r28	; 0x01
    6f58:	d2 83       	std	Z+2, r29	; 0x02
    6f5a:	87 ee       	ldi	r24, 0xE7	; 231
    6f5c:	9c e0       	ldi	r25, 0x0C	; 12
    6f5e:	83 83       	std	Z+3, r24	; 0x03
    6f60:	94 83       	std	Z+4, r25	; 0x04
    6f62:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print source hardware address
  fprintf_P(stream, PSTR("SrcHwAddr   : "));  netPrintEthAddr(stream, &packet->shwaddr);   fprintf_P(stream, PSTR("\r\n"));
    6f66:	ed b7       	in	r30, 0x3d	; 61
    6f68:	fe b7       	in	r31, 0x3e	; 62
    6f6a:	c1 83       	std	Z+1, r28	; 0x01
    6f6c:	d2 83       	std	Z+2, r29	; 0x02
    6f6e:	88 ed       	ldi	r24, 0xD8	; 216
    6f70:	9c e0       	ldi	r25, 0x0C	; 12
    6f72:	83 83       	std	Z+3, r24	; 0x03
    6f74:	94 83       	std	Z+4, r25	; 0x04
    6f76:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6f7a:	0f 90       	pop	r0
    6f7c:	0f 90       	pop	r0
    6f7e:	0f 90       	pop	r0
    6f80:	0f 90       	pop	r0
    6f82:	b8 01       	movw	r22, r16
    6f84:	68 5f       	subi	r22, 0xF8	; 248
    6f86:	7f 4f       	sbci	r23, 0xFF	; 255
    6f88:	ce 01       	movw	r24, r28
    6f8a:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
    6f8e:	00 d0       	rcall	.+0      	; 0x6f90 <arpPrintHeader+0xe6>
    6f90:	0f 92       	push	r0
    6f92:	ed b7       	in	r30, 0x3d	; 61
    6f94:	fe b7       	in	r31, 0x3e	; 62
    6f96:	c1 83       	std	Z+1, r28	; 0x01
    6f98:	d2 83       	std	Z+2, r29	; 0x02
    6f9a:	85 ed       	ldi	r24, 0xD5	; 213
    6f9c:	9c e0       	ldi	r25, 0x0C	; 12
    6f9e:	83 83       	std	Z+3, r24	; 0x03
    6fa0:	94 83       	std	Z+4, r25	; 0x04
    6fa2:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print source protocol address
  fprintf_P(stream, PSTR("SrcProtoAddr: "));  netPrintIPAddr(stream, packet->sipaddr);     fprintf_P(stream, PSTR("\r\n"));
    6fa6:	ed b7       	in	r30, 0x3d	; 61
    6fa8:	fe b7       	in	r31, 0x3e	; 62
    6faa:	c1 83       	std	Z+1, r28	; 0x01
    6fac:	d2 83       	std	Z+2, r29	; 0x02
    6fae:	86 ec       	ldi	r24, 0xC6	; 198
    6fb0:	9c e0       	ldi	r25, 0x0C	; 12
    6fb2:	83 83       	std	Z+3, r24	; 0x03
    6fb4:	94 83       	std	Z+4, r25	; 0x04
    6fb6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6fba:	0f 90       	pop	r0
    6fbc:	0f 90       	pop	r0
    6fbe:	0f 90       	pop	r0
    6fc0:	0f 90       	pop	r0
    6fc2:	f8 01       	movw	r30, r16
    6fc4:	46 85       	ldd	r20, Z+14	; 0x0e
    6fc6:	57 85       	ldd	r21, Z+15	; 0x0f
    6fc8:	60 89       	ldd	r22, Z+16	; 0x10
    6fca:	71 89       	ldd	r23, Z+17	; 0x11
    6fcc:	ce 01       	movw	r24, r28
    6fce:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    6fd2:	00 d0       	rcall	.+0      	; 0x6fd4 <arpPrintHeader+0x12a>
    6fd4:	0f 92       	push	r0
    6fd6:	ed b7       	in	r30, 0x3d	; 61
    6fd8:	fe b7       	in	r31, 0x3e	; 62
    6fda:	c1 83       	std	Z+1, r28	; 0x01
    6fdc:	d2 83       	std	Z+2, r29	; 0x02
    6fde:	83 ec       	ldi	r24, 0xC3	; 195
    6fe0:	9c e0       	ldi	r25, 0x0C	; 12
    6fe2:	83 83       	std	Z+3, r24	; 0x03
    6fe4:	94 83       	std	Z+4, r25	; 0x04
    6fe6:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print target hardware address
  fprintf_P(stream, PSTR("DstHwAddr   : "));  netPrintEthAddr(stream, &packet->dhwaddr);   fprintf_P(stream, PSTR("\r\n"));
    6fea:	ed b7       	in	r30, 0x3d	; 61
    6fec:	fe b7       	in	r31, 0x3e	; 62
    6fee:	c1 83       	std	Z+1, r28	; 0x01
    6ff0:	d2 83       	std	Z+2, r29	; 0x02
    6ff2:	84 eb       	ldi	r24, 0xB4	; 180
    6ff4:	9c e0       	ldi	r25, 0x0C	; 12
    6ff6:	83 83       	std	Z+3, r24	; 0x03
    6ff8:	94 83       	std	Z+4, r25	; 0x04
    6ffa:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    6ffe:	0f 90       	pop	r0
    7000:	0f 90       	pop	r0
    7002:	0f 90       	pop	r0
    7004:	0f 90       	pop	r0
    7006:	b8 01       	movw	r22, r16
    7008:	6e 5e       	subi	r22, 0xEE	; 238
    700a:	7f 4f       	sbci	r23, 0xFF	; 255
    700c:	ce 01       	movw	r24, r28
    700e:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
    7012:	00 d0       	rcall	.+0      	; 0x7014 <arpPrintHeader+0x16a>
    7014:	0f 92       	push	r0
    7016:	ed b7       	in	r30, 0x3d	; 61
    7018:	fe b7       	in	r31, 0x3e	; 62
    701a:	c1 83       	std	Z+1, r28	; 0x01
    701c:	d2 83       	std	Z+2, r29	; 0x02
    701e:	81 eb       	ldi	r24, 0xB1	; 177
    7020:	9c e0       	ldi	r25, 0x0C	; 12
    7022:	83 83       	std	Z+3, r24	; 0x03
    7024:	94 83       	std	Z+4, r25	; 0x04
    7026:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
// print target protocol address
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
    702a:	ed b7       	in	r30, 0x3d	; 61
    702c:	fe b7       	in	r31, 0x3e	; 62
    702e:	c1 83       	std	Z+1, r28	; 0x01
    7030:	d2 83       	std	Z+2, r29	; 0x02
    7032:	82 ea       	ldi	r24, 0xA2	; 162
    7034:	9c e0       	ldi	r25, 0x0C	; 12
    7036:	83 83       	std	Z+3, r24	; 0x03
    7038:	94 83       	std	Z+4, r25	; 0x04
    703a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    703e:	0f 90       	pop	r0
    7040:	0f 90       	pop	r0
    7042:	0f 90       	pop	r0
    7044:	0f 90       	pop	r0
    7046:	f8 01       	movw	r30, r16
    7048:	40 8d       	ldd	r20, Z+24	; 0x18
    704a:	51 8d       	ldd	r21, Z+25	; 0x19
    704c:	62 8d       	ldd	r22, Z+26	; 0x1a
    704e:	73 8d       	ldd	r23, Z+27	; 0x1b
    7050:	ce 01       	movw	r24, r28
    7052:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    7056:	00 d0       	rcall	.+0      	; 0x7058 <arpPrintHeader+0x1ae>
    7058:	0f 92       	push	r0
    705a:	ed b7       	in	r30, 0x3d	; 61
    705c:	fe b7       	in	r31, 0x3e	; 62
    705e:	c1 83       	std	Z+1, r28	; 0x01
    7060:	d2 83       	std	Z+2, r29	; 0x02
    7062:	8f e9       	ldi	r24, 0x9F	; 159
    7064:	9c e0       	ldi	r25, 0x0C	; 12
    7066:	83 83       	std	Z+3, r24	; 0x03
    7068:	94 83       	std	Z+4, r25	; 0x04
    706a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    706e:	0f 90       	pop	r0
    7070:	0f 90       	pop	r0
    7072:	0f 90       	pop	r0
    7074:	0f 90       	pop	r0
}
    7076:	df 91       	pop	r29
    7078:	cf 91       	pop	r28
    707a:	1f 91       	pop	r17
    707c:	0f 91       	pop	r16
    707e:	ff 90       	pop	r15
    7080:	ef 90       	pop	r14
    7082:	08 95       	ret

00007084 <arpArpIn>:
  memset(ArpTable, 0, sizeof(ArpTable));
  arpDebug = NULL;
}

void arpArpIn(void)
{
    7084:	cf 93       	push	r28
    7086:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    7088:	80 91 ec 31 	lds	r24, 0x31EC
    708c:	90 91 ed 31 	lds	r25, 0x31ED
    7090:	00 97       	sbiw	r24, 0x00	; 0
    7092:	11 f1       	breq	.+68     	; 0x70d8 <arpArpIn+0x54>
  {
    if (arpDebugLevel > 1)
    7094:	20 91 bf 32 	lds	r18, 0x32BF
    7098:	22 30       	cpi	r18, 0x02	; 2
    709a:	80 f0       	brcs	.+32     	; 0x70bc <arpArpIn+0x38>
      fprintf_P(arpDebug, PSTR("Received ARP Request\r\n"));
    709c:	00 d0       	rcall	.+0      	; 0x709e <arpArpIn+0x1a>
    709e:	0f 92       	push	r0
    70a0:	ed b7       	in	r30, 0x3d	; 61
    70a2:	fe b7       	in	r31, 0x3e	; 62
    70a4:	81 83       	std	Z+1, r24	; 0x01
    70a6:	92 83       	std	Z+2, r25	; 0x02
    70a8:	8a e4       	ldi	r24, 0x4A	; 74
    70aa:	9d e0       	ldi	r25, 0x0D	; 13
    70ac:	83 83       	std	Z+3, r24	; 0x03
    70ae:	94 83       	std	Z+4, r25	; 0x04
    70b0:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    70b4:	0f 90       	pop	r0
    70b6:	0f 90       	pop	r0
    70b8:	0f 90       	pop	r0
    70ba:	0f 90       	pop	r0
    if (arpDebugLevel > 2)
    70bc:	80 91 bf 32 	lds	r24, 0x32BF
    70c0:	83 30       	cpi	r24, 0x03	; 3
    70c2:	50 f0       	brcs	.+20     	; 0x70d8 <arpArpIn+0x54>
      arpPrintHeader(arpDebug, nicState.layer3.arp);   
    70c4:	60 91 e6 31 	lds	r22, 0x31E6
    70c8:	70 91 e7 31 	lds	r23, 0x31E7
    70cc:	80 91 ec 31 	lds	r24, 0x31EC
    70d0:	90 91 ed 31 	lds	r25, 0x31ED
    70d4:	0e 94 55 37 	call	0x6eaa	; 0x6eaa <arpPrintHeader>
  }
#endif

// for now, we just reply to requests
// need to add ARP cache
  if((nicState.layer3.arp->dipaddr == IpMyConfig.ip) && (nicState.layer3.arp->opcode == htons(ARP_OPCODE_REQUEST)) )
    70d8:	e0 91 e6 31 	lds	r30, 0x31E6
    70dc:	f0 91 e7 31 	lds	r31, 0x31E7
    70e0:	20 8d       	ldd	r18, Z+24	; 0x18
    70e2:	31 8d       	ldd	r19, Z+25	; 0x19
    70e4:	42 8d       	ldd	r20, Z+26	; 0x1a
    70e6:	53 8d       	ldd	r21, Z+27	; 0x1b
    70e8:	80 91 b0 32 	lds	r24, 0x32B0
    70ec:	90 91 b1 32 	lds	r25, 0x32B1
    70f0:	a0 91 b2 32 	lds	r26, 0x32B2
    70f4:	b0 91 b3 32 	lds	r27, 0x32B3
    70f8:	28 17       	cp	r18, r24
    70fa:	39 07       	cpc	r19, r25
    70fc:	4a 07       	cpc	r20, r26
    70fe:	5b 07       	cpc	r21, r27
    7100:	09 f0       	breq	.+2      	; 0x7104 <arpArpIn+0x80>
    7102:	80 c0       	rjmp	.+256    	; 0x7204 <arpArpIn+0x180>
    7104:	c6 81       	ldd	r28, Z+6	; 0x06
    7106:	d7 81       	ldd	r29, Z+7	; 0x07
    7108:	81 e0       	ldi	r24, 0x01	; 1
    710a:	90 e0       	ldi	r25, 0x00	; 0
    710c:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7110:	c8 17       	cp	r28, r24
    7112:	d9 07       	cpc	r29, r25
    7114:	09 f0       	breq	.+2      	; 0x7118 <arpArpIn+0x94>
    7116:	76 c0       	rjmp	.+236    	; 0x7204 <arpArpIn+0x180>
  {
// in ARP header
// copy sender's address info to dest. fields
    nicState.layer3.arp->dhwaddr = nicState.layer3.arp->shwaddr;
    7118:	e0 91 e6 31 	lds	r30, 0x31E6
    711c:	f0 91 e7 31 	lds	r31, 0x31E7
    7120:	ef 01       	movw	r28, r30
    7122:	62 96       	adiw	r28, 0x12	; 18
    7124:	df 01       	movw	r26, r30
    7126:	18 96       	adiw	r26, 0x08	; 8
    7128:	86 e0       	ldi	r24, 0x06	; 6
    712a:	0d 90       	ld	r0, X+
    712c:	09 92       	st	Y+, r0
    712e:	81 50       	subi	r24, 0x01	; 1
    7130:	e1 f7       	brne	.-8      	; 0x712a <arpArpIn+0xa6>
    nicState.layer3.arp->dipaddr = nicState.layer3.arp->sipaddr;
    7132:	86 85       	ldd	r24, Z+14	; 0x0e
    7134:	97 85       	ldd	r25, Z+15	; 0x0f
    7136:	a0 89       	ldd	r26, Z+16	; 0x10
    7138:	b1 89       	ldd	r27, Z+17	; 0x11
    713a:	80 8f       	std	Z+24, r24	; 0x18
    713c:	91 8f       	std	Z+25, r25	; 0x19
    713e:	a2 8f       	std	Z+26, r26	; 0x1a
    7140:	b3 8f       	std	Z+27, r27	; 0x1b
// fill in our information
    nicState.layer3.arp->shwaddr =  nicState.mac;
    7142:	38 96       	adiw	r30, 0x08	; 8
    7144:	ae ed       	ldi	r26, 0xDE	; 222
    7146:	b1 e3       	ldi	r27, 0x31	; 49
    7148:	86 e0       	ldi	r24, 0x06	; 6
    714a:	0d 90       	ld	r0, X+
    714c:	01 92       	st	Z+, r0
    714e:	81 50       	subi	r24, 0x01	; 1
    7150:	e1 f7       	brne	.-8      	; 0x714a <arpArpIn+0xc6>
    nicState.layer3.arp->sipaddr =  IpMyConfig.ip;
    7152:	c0 91 e6 31 	lds	r28, 0x31E6
    7156:	d0 91 e7 31 	lds	r29, 0x31E7
    715a:	80 91 b0 32 	lds	r24, 0x32B0
    715e:	90 91 b1 32 	lds	r25, 0x32B1
    7162:	a0 91 b2 32 	lds	r26, 0x32B2
    7166:	b0 91 b3 32 	lds	r27, 0x32B3
    716a:	8e 87       	std	Y+14, r24	; 0x0e
    716c:	9f 87       	std	Y+15, r25	; 0x0f
    716e:	a8 8b       	std	Y+16, r26	; 0x10
    7170:	b9 8b       	std	Y+17, r27	; 0x11
// change op to reply
    nicState.layer3.arp->opcode = htons(ARP_OPCODE_REPLY);
    7172:	82 e0       	ldi	r24, 0x02	; 2
    7174:	90 e0       	ldi	r25, 0x00	; 0
    7176:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    717a:	8e 83       	std	Y+6, r24	; 0x06
    717c:	9f 83       	std	Y+7, r25	; 0x07

// in ethernet header
    nicState.layer2.ethHeader->dest = nicState.layer2.ethHeader->src;
    717e:	e0 91 e4 31 	lds	r30, 0x31E4
    7182:	f0 91 e5 31 	lds	r31, 0x31E5
    7186:	df 01       	movw	r26, r30
    7188:	16 96       	adiw	r26, 0x06	; 6
    718a:	86 e0       	ldi	r24, 0x06	; 6
    718c:	0d 90       	ld	r0, X+
    718e:	01 92       	st	Z+, r0
    7190:	81 50       	subi	r24, 0x01	; 1
    7192:	e1 f7       	brne	.-8      	; 0x718c <arpArpIn+0x108>
    nicState.layer2.ethHeader->src  = nicState.mac;
    7194:	e0 91 e4 31 	lds	r30, 0x31E4
    7198:	f0 91 e5 31 	lds	r31, 0x31E5
    719c:	36 96       	adiw	r30, 0x06	; 6
    719e:	ae ed       	ldi	r26, 0xDE	; 222
    71a0:	b1 e3       	ldi	r27, 0x31	; 49
    71a2:	86 e0       	ldi	r24, 0x06	; 6
    71a4:	0d 90       	ld	r0, X+
    71a6:	01 92       	st	Z+, r0
    71a8:	81 50       	subi	r24, 0x01	; 1
    71aa:	e1 f7       	brne	.-8      	; 0x71a4 <arpArpIn+0x120>

#ifdef ARP_DEBUG
    if (arpDebug != NULL)
    71ac:	80 91 ec 31 	lds	r24, 0x31EC
    71b0:	90 91 ed 31 	lds	r25, 0x31ED
    71b4:	00 97       	sbiw	r24, 0x00	; 0
    71b6:	11 f1       	breq	.+68     	; 0x71fc <arpArpIn+0x178>
    {
      if (arpDebugLevel > 0)
    71b8:	20 91 bf 32 	lds	r18, 0x32BF
    71bc:	22 23       	and	r18, r18
    71be:	81 f0       	breq	.+32     	; 0x71e0 <arpArpIn+0x15c>
        fprintf_P(arpDebug, PSTR("Sending ARP Reply\r\n"));
    71c0:	00 d0       	rcall	.+0      	; 0x71c2 <arpArpIn+0x13e>
    71c2:	0f 92       	push	r0
    71c4:	ed b7       	in	r30, 0x3d	; 61
    71c6:	fe b7       	in	r31, 0x3e	; 62
    71c8:	81 83       	std	Z+1, r24	; 0x01
    71ca:	92 83       	std	Z+2, r25	; 0x02
    71cc:	86 e3       	ldi	r24, 0x36	; 54
    71ce:	9d e0       	ldi	r25, 0x0D	; 13
    71d0:	83 83       	std	Z+3, r24	; 0x03
    71d2:	94 83       	std	Z+4, r25	; 0x04
    71d4:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    71d8:	0f 90       	pop	r0
    71da:	0f 90       	pop	r0
    71dc:	0f 90       	pop	r0
    71de:	0f 90       	pop	r0
      if (arpDebugLevel > 2)
    71e0:	80 91 bf 32 	lds	r24, 0x32BF
    71e4:	83 30       	cpi	r24, 0x03	; 3
    71e6:	50 f0       	brcs	.+20     	; 0x71fc <arpArpIn+0x178>
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    71e8:	60 91 e6 31 	lds	r22, 0x31E6
    71ec:	70 91 e7 31 	lds	r23, 0x31E7
    71f0:	80 91 ec 31 	lds	r24, 0x31EC
    71f4:	90 91 ed 31 	lds	r25, 0x31ED
    71f8:	0e 94 55 37 	call	0x6eaa	; 0x6eaa <arpPrintHeader>
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    71fc:	8a e2       	ldi	r24, 0x2A	; 42
    71fe:	90 e0       	ldi	r25, 0x00	; 0
    7200:	0e 94 c9 2b 	call	0x5792	; 0x5792 <nicSend>
  }
}
    7204:	df 91       	pop	r29
    7206:	cf 91       	pop	r28
    7208:	08 95       	ret

0000720a <arpPrintTable>:
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
}
#endif /*ARP_DEBUG*/

void arpPrintTable(FILE *stream)
{
    720a:	6f 92       	push	r6
    720c:	7f 92       	push	r7
    720e:	8f 92       	push	r8
    7210:	9f 92       	push	r9
    7212:	af 92       	push	r10
    7214:	bf 92       	push	r11
    7216:	cf 92       	push	r12
    7218:	df 92       	push	r13
    721a:	ef 92       	push	r14
    721c:	ff 92       	push	r15
    721e:	0f 93       	push	r16
    7220:	1f 93       	push	r17
    7222:	cf 93       	push	r28
    7224:	df 93       	push	r29
    7226:	ec 01       	movw	r28, r24
  uint8_t i;

  // print ARP table
  fprintf_P(stream, PSTR("Time Eth Address        IP Address\r\n"));
    7228:	00 d0       	rcall	.+0      	; 0x722a <arpPrintTable+0x20>
    722a:	0f 92       	push	r0
    722c:	ad b7       	in	r26, 0x3d	; 61
    722e:	be b7       	in	r27, 0x3e	; 62
    7230:	11 96       	adiw	r26, 0x01	; 1
    7232:	8d 93       	st	X+, r24
    7234:	9c 93       	st	X, r25
    7236:	12 97       	sbiw	r26, 0x02	; 2
    7238:	8a e7       	ldi	r24, 0x7A	; 122
    723a:	9c e0       	ldi	r25, 0x0C	; 12
    723c:	13 96       	adiw	r26, 0x03	; 3
    723e:	8d 93       	st	X+, r24
    7240:	9c 93       	st	X, r25
    7242:	14 97       	sbiw	r26, 0x04	; 4
    7244:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("-----------------------------------\r\n"));
    7248:	ed b7       	in	r30, 0x3d	; 61
    724a:	fe b7       	in	r31, 0x3e	; 62
    724c:	c1 83       	std	Z+1, r28	; 0x01
    724e:	d2 83       	std	Z+2, r29	; 0x02
    7250:	84 e5       	ldi	r24, 0x54	; 84
    7252:	9c e0       	ldi	r25, 0x0C	; 12
    7254:	83 83       	std	Z+3, r24	; 0x03
    7256:	94 83       	std	Z+4, r25	; 0x04
    7258:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR(" MY  "));
    725c:	ad b7       	in	r26, 0x3d	; 61
    725e:	be b7       	in	r27, 0x3e	; 62
    7260:	11 96       	adiw	r26, 0x01	; 1
    7262:	cd 93       	st	X+, r28
    7264:	dc 93       	st	X, r29
    7266:	12 97       	sbiw	r26, 0x02	; 2
    7268:	8e e4       	ldi	r24, 0x4E	; 78
    726a:	9c e0       	ldi	r25, 0x0C	; 12
    726c:	13 96       	adiw	r26, 0x03	; 3
    726e:	8d 93       	st	X+, r24
    7270:	9c 93       	st	X, r25
    7272:	14 97       	sbiw	r26, 0x04	; 4
    7274:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    7278:	0f 90       	pop	r0
    727a:	0f 90       	pop	r0
    727c:	0f 90       	pop	r0
    727e:	0f 90       	pop	r0
    7280:	ce 01       	movw	r24, r28
    7282:	6e ed       	ldi	r22, 0xDE	; 222
    7284:	71 e3       	ldi	r23, 0x31	; 49
    7286:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
  fprintf_P(stream, PSTR("  "));
    728a:	00 d0       	rcall	.+0      	; 0x728c <arpPrintTable+0x82>
    728c:	0f 92       	push	r0
    728e:	ed b7       	in	r30, 0x3d	; 61
    7290:	fe b7       	in	r31, 0x3e	; 62
    7292:	c1 83       	std	Z+1, r28	; 0x01
    7294:	d2 83       	std	Z+2, r29	; 0x02
    7296:	8b e4       	ldi	r24, 0x4B	; 75
    7298:	9c e0       	ldi	r25, 0x0C	; 12
    729a:	83 83       	std	Z+3, r24	; 0x03
    729c:	94 83       	std	Z+4, r25	; 0x04
    729e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  netPrintIPAddr(stream, IpMyConfig.ip);
    72a2:	0f 90       	pop	r0
    72a4:	0f 90       	pop	r0
    72a6:	0f 90       	pop	r0
    72a8:	0f 90       	pop	r0
    72aa:	40 91 b0 32 	lds	r20, 0x32B0
    72ae:	50 91 b1 32 	lds	r21, 0x32B1
    72b2:	60 91 b2 32 	lds	r22, 0x32B2
    72b6:	70 91 b3 32 	lds	r23, 0x32B3
    72ba:	ce 01       	movw	r24, r28
    72bc:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    72c0:	00 d0       	rcall	.+0      	; 0x72c2 <arpPrintTable+0xb8>
    72c2:	0f 92       	push	r0
    72c4:	ad b7       	in	r26, 0x3d	; 61
    72c6:	be b7       	in	r27, 0x3e	; 62
    72c8:	11 96       	adiw	r26, 0x01	; 1
    72ca:	cd 93       	st	X+, r28
    72cc:	dc 93       	st	X, r29
    72ce:	12 97       	sbiw	r26, 0x02	; 2
    72d0:	88 e4       	ldi	r24, 0x48	; 72
    72d2:	9c e0       	ldi	r25, 0x0C	; 12
    72d4:	13 96       	adiw	r26, 0x03	; 3
    72d6:	8d 93       	st	X+, r24
    72d8:	9c 93       	st	X, r25
    72da:	14 97       	sbiw	r26, 0x04	; 4
    72dc:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    72e0:	0a ec       	ldi	r16, 0xCA	; 202
    72e2:	12 e3       	ldi	r17, 0x32	; 50
    72e4:	0f 90       	pop	r0
    72e6:	0f 90       	pop	r0
    72e8:	0f 90       	pop	r0
    72ea:	0f 90       	pop	r0
    72ec:	ee 24       	eor	r14, r14
    72ee:	ff 24       	eor	r15, r15

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    72f0:	32 e4       	ldi	r19, 0x42	; 66
    72f2:	c3 2e       	mov	r12, r19
    72f4:	3c e0       	ldi	r19, 0x0C	; 12
    72f6:	d3 2e       	mov	r13, r19
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    72f8:	2b e0       	ldi	r18, 0x0B	; 11
    72fa:	a2 2e       	mov	r10, r18
    72fc:	b1 2c       	mov	r11, r1
    fprintf_P(stream, PSTR("  "));
    72fe:	9f e3       	ldi	r25, 0x3F	; 63
    7300:	89 2e       	mov	r8, r25
    7302:	9c e0       	ldi	r25, 0x0C	; 12
    7304:	99 2e       	mov	r9, r25
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
    7306:	8c e3       	ldi	r24, 0x3C	; 60
    7308:	68 2e       	mov	r6, r24
    730a:	8c e0       	ldi	r24, 0x0C	; 12
    730c:	78 2e       	mov	r7, r24
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
    730e:	f8 01       	movw	r30, r16
    7310:	80 81       	ld	r24, Z
    7312:	91 81       	ldd	r25, Z+1	; 0x01
    7314:	a2 81       	ldd	r26, Z+2	; 0x02
    7316:	b3 81       	ldd	r27, Z+3	; 0x03
    7318:	00 97       	sbiw	r24, 0x00	; 0
    731a:	a1 05       	cpc	r26, r1
    731c:	b1 05       	cpc	r27, r1
    731e:	09 f4       	brne	.+2      	; 0x7322 <arpPrintTable+0x118>
    7320:	51 c0       	rjmp	.+162    	; 0x73c4 <arpPrintTable+0x1ba>
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    7322:	00 d0       	rcall	.+0      	; 0x7324 <arpPrintTable+0x11a>
    7324:	00 d0       	rcall	.+0      	; 0x7326 <arpPrintTable+0x11c>
    7326:	ed b7       	in	r30, 0x3d	; 61
    7328:	fe b7       	in	r31, 0x3e	; 62
    732a:	31 96       	adiw	r30, 0x01	; 1
    732c:	ad b7       	in	r26, 0x3d	; 61
    732e:	be b7       	in	r27, 0x3e	; 62
    7330:	11 96       	adiw	r26, 0x01	; 1
    7332:	cd 93       	st	X+, r28
    7334:	dc 93       	st	X, r29
    7336:	12 97       	sbiw	r26, 0x02	; 2
    7338:	c2 82       	std	Z+2, r12	; 0x02
    733a:	d3 82       	std	Z+3, r13	; 0x03
    733c:	d8 01       	movw	r26, r16
    733e:	1a 96       	adiw	r26, 0x0a	; 10
    7340:	8c 91       	ld	r24, X
    7342:	84 83       	std	Z+4, r24	; 0x04
    7344:	15 82       	std	Z+5, r1	; 0x05
    7346:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    734a:	ed b7       	in	r30, 0x3d	; 61
    734c:	fe b7       	in	r31, 0x3e	; 62
    734e:	36 96       	adiw	r30, 0x06	; 6
    7350:	ed bf       	out	0x3d, r30	; 61
    7352:	fe bf       	out	0x3e, r31	; 62
    7354:	ea 9c       	mul	r14, r10
    7356:	b0 01       	movw	r22, r0
    7358:	eb 9c       	mul	r14, r11
    735a:	70 0d       	add	r23, r0
    735c:	fa 9c       	mul	r15, r10
    735e:	70 0d       	add	r23, r0
    7360:	11 24       	eor	r1, r1
    7362:	62 53       	subi	r22, 0x32	; 50
    7364:	7d 4c       	sbci	r23, 0xCD	; 205
    7366:	ce 01       	movw	r24, r28
    7368:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <netPrintEthAddr>
    fprintf_P(stream, PSTR("  "));
    736c:	00 d0       	rcall	.+0      	; 0x736e <arpPrintTable+0x164>
    736e:	0f 92       	push	r0
    7370:	ad b7       	in	r26, 0x3d	; 61
    7372:	be b7       	in	r27, 0x3e	; 62
    7374:	11 96       	adiw	r26, 0x01	; 1
    7376:	cd 93       	st	X+, r28
    7378:	dc 93       	st	X, r29
    737a:	12 97       	sbiw	r26, 0x02	; 2
    737c:	13 96       	adiw	r26, 0x03	; 3
    737e:	8d 92       	st	X+, r8
    7380:	9c 92       	st	X, r9
    7382:	14 97       	sbiw	r26, 0x04	; 4
    7384:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    7388:	0f 90       	pop	r0
    738a:	0f 90       	pop	r0
    738c:	0f 90       	pop	r0
    738e:	0f 90       	pop	r0
    7390:	f8 01       	movw	r30, r16
    7392:	40 81       	ld	r20, Z
    7394:	51 81       	ldd	r21, Z+1	; 0x01
    7396:	62 81       	ldd	r22, Z+2	; 0x02
    7398:	73 81       	ldd	r23, Z+3	; 0x03
    739a:	ce 01       	movw	r24, r28
    739c:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
    fprintf_P(stream, PSTR("\r\n"));
    73a0:	00 d0       	rcall	.+0      	; 0x73a2 <arpPrintTable+0x198>
    73a2:	0f 92       	push	r0
    73a4:	ad b7       	in	r26, 0x3d	; 61
    73a6:	be b7       	in	r27, 0x3e	; 62
    73a8:	11 96       	adiw	r26, 0x01	; 1
    73aa:	cd 93       	st	X+, r28
    73ac:	dc 93       	st	X, r29
    73ae:	12 97       	sbiw	r26, 0x02	; 2
    73b0:	13 96       	adiw	r26, 0x03	; 3
    73b2:	6d 92       	st	X+, r6
    73b4:	7c 92       	st	X, r7
    73b6:	14 97       	sbiw	r26, 0x04	; 4
    73b8:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    73bc:	0f 90       	pop	r0
    73be:	0f 90       	pop	r0
    73c0:	0f 90       	pop	r0
    73c2:	0f 90       	pop	r0
    73c4:	08 94       	sec
    73c6:	e1 1c       	adc	r14, r1
    73c8:	f1 1c       	adc	r15, r1
    73ca:	05 5f       	subi	r16, 0xF5	; 245
    73cc:	1f 4f       	sbci	r17, 0xFF	; 255
  netPrintEthAddr(stream, &nicState.mac);
  fprintf_P(stream, PSTR("  "));
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
    73ce:	ba e0       	ldi	r27, 0x0A	; 10
    73d0:	eb 16       	cp	r14, r27
    73d2:	f1 04       	cpc	r15, r1
    73d4:	09 f0       	breq	.+2      	; 0x73d8 <arpPrintTable+0x1ce>
    73d6:	9b cf       	rjmp	.-202    	; 0x730e <arpPrintTable+0x104>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
  }
}
    73d8:	df 91       	pop	r29
    73da:	cf 91       	pop	r28
    73dc:	1f 91       	pop	r17
    73de:	0f 91       	pop	r16
    73e0:	ff 90       	pop	r15
    73e2:	ef 90       	pop	r14
    73e4:	df 90       	pop	r13
    73e6:	cf 90       	pop	r12
    73e8:	bf 90       	pop	r11
    73ea:	af 90       	pop	r10
    73ec:	9f 90       	pop	r9
    73ee:	8f 90       	pop	r8
    73f0:	7f 90       	pop	r7
    73f2:	6f 90       	pop	r6
    73f4:	08 95       	ret

000073f6 <socketInit>:
 * @param *sck socket
 */
static inline void tcpAcceptConn(struct TcpIpSocket *sck);

inline void socketInit(void)
{
    73f6:	bf 92       	push	r11
    73f8:	cf 92       	push	r12
    73fa:	df 92       	push	r13
    73fc:	ef 92       	push	r14
    73fe:	ff 92       	push	r15
    7400:	0f 93       	push	r16
    7402:	1f 93       	push	r17
    7404:	cf 93       	push	r28
    7406:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    7408:	80 e3       	ldi	r24, 0x30	; 48
    740a:	92 e0       	ldi	r25, 0x02	; 2
    740c:	0e 94 22 1c 	call	0x3844	; 0x3844 <xmalloc>
    7410:	80 93 1e 32 	sts	0x321E, r24
    7414:	90 93 1f 32 	sts	0x321F, r25
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    7418:	fc 01       	movw	r30, r24
    741a:	80 e3       	ldi	r24, 0x30	; 48
    741c:	92 e0       	ldi	r25, 0x02	; 2
    741e:	df 01       	movw	r26, r30
    7420:	9c 01       	movw	r18, r24
    7422:	1d 92       	st	X+, r1
    7424:	21 50       	subi	r18, 0x01	; 1
    7426:	30 40       	sbci	r19, 0x00	; 0
    7428:	e1 f7       	brne	.-8      	; 0x7422 <socketInit+0x2c>
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    742a:	00 91 1e 32 	lds	r16, 0x321E
    742e:	10 91 1f 32 	lds	r17, 0x321F
    7432:	c8 ea       	ldi	r28, 0xA8	; 168
    7434:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7436:	8f ef       	ldi	r24, 0xFF	; 255
    7438:	c8 2e       	mov	r12, r24
    743a:	81 e1       	ldi	r24, 0x11	; 17
    743c:	d8 2e       	mov	r13, r24
    743e:	82 e2       	ldi	r24, 0x22	; 34
    7440:	e8 2e       	mov	r14, r24
    7442:	83 e3       	ldi	r24, 0x33	; 51
    7444:	f8 2e       	mov	r15, r24
    sck->state         = LISTEN;   
    7446:	bb 24       	eor	r11, r11
    7448:	b3 94       	inc	r11
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    744a:	de 01       	movw	r26, r28
    744c:	a8 5a       	subi	r26, 0xA8	; 168
    744e:	a0 31       	cpi	r26, 0x10	; 16
    7450:	20 f4       	brcc	.+8      	; 0x745a <socketInit+0x64>
    7452:	ce 01       	movw	r24, r28
    7454:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7458:	02 c0       	rjmp	.+4      	; 0x745e <socketInit+0x68>
    745a:	88 eb       	ldi	r24, 0xB8	; 184
    745c:	91 e6       	ldi	r25, 0x61	; 97
    745e:	f8 01       	movw	r30, r16
    7460:	85 83       	std	Z+5, r24	; 0x05
    7462:	96 83       	std	Z+6, r25	; 0x06
    sck->seqNoLastSent = HTONL(0xFF112233); 
    7464:	d8 01       	movw	r26, r16
    7466:	1d 96       	adiw	r26, 0x0d	; 13
    7468:	cd 92       	st	X+, r12
    746a:	dd 92       	st	X+, r13
    746c:	ed 92       	st	X+, r14
    746e:	fc 92       	st	X, r15
    7470:	50 97       	sbiw	r26, 0x10	; 16
    sck->state         = LISTEN;   
    7472:	bc 92       	st	X, r11
    7474:	21 96       	adiw	r28, 0x01	; 1
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    7476:	b1 e6       	ldi	r27, 0x61	; 97
    7478:	cc 3b       	cpi	r28, 0xBC	; 188
    747a:	db 07       	cpc	r29, r27
    747c:	19 f0       	breq	.+6      	; 0x7484 <socketInit+0x8e>
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    sck->state         = LISTEN;   
    sck++;
    747e:	04 5e       	subi	r16, 0xE4	; 228
    7480:	1f 4f       	sbci	r17, 0xFF	; 255
    7482:	e3 cf       	rjmp	.-58     	; 0x744a <socketInit+0x54>
  }
}
    7484:	df 91       	pop	r29
    7486:	cf 91       	pop	r28
    7488:	1f 91       	pop	r17
    748a:	0f 91       	pop	r16
    748c:	ff 90       	pop	r15
    748e:	ef 90       	pop	r14
    7490:	df 90       	pop	r13
    7492:	cf 90       	pop	r12
    7494:	bf 90       	pop	r11
    7496:	08 95       	ret

00007498 <calculateTcpChecksun>:
  
  return 0;
}

void calculateTcpChecksun(uint16_t tcpLen)
{
    7498:	cf 93       	push	r28
    749a:	df 93       	push	r29
    749c:	bc 01       	movw	r22, r24
  nicState.layer4.tcp->tcpchksum = 0;
    749e:	c0 91 e8 31 	lds	r28, 0x31E8
    74a2:	d0 91 e9 31 	lds	r29, 0x31E9
    74a6:	18 8a       	std	Y+16, r1	; 0x10
    74a8:	19 8a       	std	Y+17, r1	; 0x11
  nicState.layer4.tcp->tcpchksum = netChecksum(nicState.layer4.tcp, tcpLen); //TODO finish it
    74aa:	ce 01       	movw	r24, r28
    74ac:	0e 94 66 2e 	call	0x5ccc	; 0x5ccc <netChecksum>
    74b0:	88 8b       	std	Y+16, r24	; 0x10
    74b2:	99 8b       	std	Y+17, r25	; 0x11
}
    74b4:	df 91       	pop	r29
    74b6:	cf 91       	pop	r28
    74b8:	08 95       	ret

000074ba <processTcpPacket>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket(void)
{
    74ba:	af 92       	push	r10
    74bc:	bf 92       	push	r11
    74be:	cf 92       	push	r12
    74c0:	df 92       	push	r13
    74c2:	ef 92       	push	r14
    74c4:	ff 92       	push	r15
    74c6:	0f 93       	push	r16
    74c8:	1f 93       	push	r17
    74ca:	cf 93       	push	r28
    74cc:	df 93       	push	r29
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    74ce:	e0 91 1e 32 	lds	r30, 0x321E
    74d2:	f0 91 1f 32 	lds	r31, 0x321F
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    74d6:	00 91 e6 31 	lds	r16, 0x31E6
    74da:	10 91 e7 31 	lds	r17, 0x31E7
    74de:	60 91 e8 31 	lds	r22, 0x31E8
    74e2:	70 91 e9 31 	lds	r23, 0x31E9
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    74e6:	ef 01       	movw	r28, r30
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    74e8:	ee 24       	eor	r14, r14
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
    74ea:	f8 80       	ld	r15, Y
    74ec:	8f 2d       	mov	r24, r15
    74ee:	82 30       	cpi	r24, 0x02	; 2
    74f0:	08 f4       	brcc	.+2      	; 0x74f4 <processTcpPacket+0x3a>
    74f2:	47 c0       	rjmp	.+142    	; 0x7582 <processTcpPacket+0xc8>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    74f4:	29 81       	ldd	r18, Y+1	; 0x01
    74f6:	3a 81       	ldd	r19, Y+2	; 0x02
    74f8:	4b 81       	ldd	r20, Y+3	; 0x03
    74fa:	5c 81       	ldd	r21, Y+4	; 0x04
    74fc:	d8 01       	movw	r26, r16
    74fe:	1c 96       	adiw	r26, 0x0c	; 12
    7500:	ad 90       	ld	r10, X+
    7502:	bd 90       	ld	r11, X+
    7504:	cd 90       	ld	r12, X+
    7506:	dc 90       	ld	r13, X
    7508:	1f 97       	sbiw	r26, 0x0f	; 15
    750a:	2a 15       	cp	r18, r10
    750c:	3b 05       	cpc	r19, r11
    750e:	4c 05       	cpc	r20, r12
    7510:	5d 05       	cpc	r21, r13
    7512:	b9 f5       	brne	.+110    	; 0x7582 <processTcpPacket+0xc8>
    7514:	2d 81       	ldd	r18, Y+5	; 0x05
    7516:	3e 81       	ldd	r19, Y+6	; 0x06
    7518:	db 01       	movw	r26, r22
    751a:	12 96       	adiw	r26, 0x02	; 2
    751c:	8d 91       	ld	r24, X+
    751e:	9c 91       	ld	r25, X
    7520:	13 97       	sbiw	r26, 0x03	; 3
    7522:	28 17       	cp	r18, r24
    7524:	39 07       	cpc	r19, r25
    7526:	69 f5       	brne	.+90     	; 0x7582 <processTcpPacket+0xc8>
    7528:	2f 81       	ldd	r18, Y+7	; 0x07
    752a:	38 85       	ldd	r19, Y+8	; 0x08
    752c:	8d 91       	ld	r24, X+
    752e:	9c 91       	ld	r25, X
    7530:	11 97       	sbiw	r26, 0x01	; 1
    7532:	28 17       	cp	r18, r24
    7534:	39 07       	cpc	r19, r25
    7536:	29 f5       	brne	.+74     	; 0x7582 <processTcpPacket+0xc8>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    7538:	80 91 ae 32 	lds	r24, 0x32AE
    753c:	90 91 af 32 	lds	r25, 0x32AF
    7540:	00 97       	sbiw	r24, 0x00	; 0
    7542:	09 f4       	brne	.+2      	; 0x7546 <processTcpPacket+0x8c>
    7544:	90 c0       	rjmp	.+288    	; 0x7666 <processTcpPacket+0x1ac>
        if (tcpDebugLevel > 2)
    7546:	20 91 05 32 	lds	r18, 0x3205
    754a:	23 30       	cpi	r18, 0x03	; 3
    754c:	08 f4       	brcc	.+2      	; 0x7550 <processTcpPacket+0x96>
    754e:	8b c0       	rjmp	.+278    	; 0x7666 <processTcpPacket+0x1ac>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    7550:	00 d0       	rcall	.+0      	; 0x7552 <processTcpPacket+0x98>
    7552:	00 d0       	rcall	.+0      	; 0x7554 <processTcpPacket+0x9a>
    7554:	ed b7       	in	r30, 0x3d	; 61
    7556:	fe b7       	in	r31, 0x3e	; 62
    7558:	31 96       	adiw	r30, 0x01	; 1
    755a:	ad b7       	in	r26, 0x3d	; 61
    755c:	be b7       	in	r27, 0x3e	; 62
    755e:	11 96       	adiw	r26, 0x01	; 1
    7560:	8d 93       	st	X+, r24
    7562:	9c 93       	st	X, r25
    7564:	12 97       	sbiw	r26, 0x02	; 2
    7566:	8a eb       	ldi	r24, 0xBA	; 186
    7568:	9e e0       	ldi	r25, 0x0E	; 14
    756a:	82 83       	std	Z+2, r24	; 0x02
    756c:	93 83       	std	Z+3, r25	; 0x03
    756e:	f4 82       	std	Z+4, r15	; 0x04
    7570:	15 82       	std	Z+5, r1	; 0x05
    7572:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7576:	ed b7       	in	r30, 0x3d	; 61
    7578:	fe b7       	in	r31, 0x3e	; 62
    757a:	36 96       	adiw	r30, 0x06	; 6
    757c:	ed bf       	out	0x3d, r30	; 61
    757e:	fe bf       	out	0x3e, r31	; 62
    7580:	72 c0       	rjmp	.+228    	; 0x7666 <processTcpPacket+0x1ac>

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    7582:	e3 94       	inc	r14
    7584:	8e 2d       	mov	r24, r14
    7586:	84 31       	cpi	r24, 0x14	; 20
    7588:	11 f0       	breq	.+4      	; 0x758e <processTcpPacket+0xd4>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
#endif      
      return result;
    }
    result++;
    758a:	6c 96       	adiw	r28, 0x1c	; 28
    758c:	ae cf       	rjmp	.-164    	; 0x74ea <processTcpPacket+0x30>
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    758e:	00 e0       	ldi	r16, 0x00	; 0
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    7590:	80 81       	ld	r24, Z
    7592:	81 30       	cpi	r24, 0x01	; 1
    7594:	b9 f5       	brne	.+110    	; 0x7604 <processTcpPacket+0x14a>
    7596:	45 81       	ldd	r20, Z+5	; 0x05
    7598:	56 81       	ldd	r21, Z+6	; 0x06
    759a:	db 01       	movw	r26, r22
    759c:	12 96       	adiw	r26, 0x02	; 2
    759e:	2d 91       	ld	r18, X+
    75a0:	3c 91       	ld	r19, X
    75a2:	13 97       	sbiw	r26, 0x03	; 3
    75a4:	42 17       	cp	r20, r18
    75a6:	53 07       	cpc	r21, r19
    75a8:	69 f5       	brne	.+90     	; 0x7604 <processTcpPacket+0x14a>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    75aa:	80 91 ae 32 	lds	r24, 0x32AE
    75ae:	90 91 af 32 	lds	r25, 0x32AF
    75b2:	00 97       	sbiw	r24, 0x00	; 0
    75b4:	e1 f0       	breq	.+56     	; 0x75ee <processTcpPacket+0x134>
        if (tcpDebugLevel > 2)
    75b6:	20 91 05 32 	lds	r18, 0x3205
    75ba:	23 30       	cpi	r18, 0x03	; 3
    75bc:	c0 f0       	brcs	.+48     	; 0x75ee <processTcpPacket+0x134>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    75be:	00 d0       	rcall	.+0      	; 0x75c0 <processTcpPacket+0x106>
    75c0:	00 d0       	rcall	.+0      	; 0x75c2 <processTcpPacket+0x108>
    75c2:	ed b7       	in	r30, 0x3d	; 61
    75c4:	fe b7       	in	r31, 0x3e	; 62
    75c6:	31 96       	adiw	r30, 0x01	; 1
    75c8:	ad b7       	in	r26, 0x3d	; 61
    75ca:	be b7       	in	r27, 0x3e	; 62
    75cc:	11 96       	adiw	r26, 0x01	; 1
    75ce:	8d 93       	st	X+, r24
    75d0:	9c 93       	st	X, r25
    75d2:	12 97       	sbiw	r26, 0x02	; 2
    75d4:	24 e9       	ldi	r18, 0x94	; 148
    75d6:	3e e0       	ldi	r19, 0x0E	; 14
    75d8:	22 83       	std	Z+2, r18	; 0x02
    75da:	33 83       	std	Z+3, r19	; 0x03
    75dc:	04 83       	std	Z+4, r16	; 0x04
    75de:	15 82       	std	Z+5, r1	; 0x05
    75e0:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    75e4:	ed b7       	in	r30, 0x3d	; 61
    75e6:	fe b7       	in	r31, 0x3e	; 62
    75e8:	36 96       	adiw	r30, 0x06	; 6
    75ea:	ed bf       	out	0x3d, r30	; 61
    75ec:	fe bf       	out	0x3e, r31	; 62
#endif      
      return &sockets[i];
    75ee:	8c e1       	ldi	r24, 0x1C	; 28
    75f0:	08 9f       	mul	r16, r24
    75f2:	c0 01       	movw	r24, r0
    75f4:	11 24       	eor	r1, r1
    75f6:	c0 91 1e 32 	lds	r28, 0x321E
    75fa:	d0 91 1f 32 	lds	r29, 0x321F
    75fe:	c8 0f       	add	r28, r24
    7600:	d9 1f       	adc	r29, r25
    7602:	31 c0       	rjmp	.+98     	; 0x7666 <processTcpPacket+0x1ac>
    }
    result++;
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    7604:	0f 5f       	subi	r16, 0xFF	; 255
    7606:	04 31       	cpi	r16, 0x14	; 20
    7608:	11 f0       	breq	.+4      	; 0x760e <processTcpPacket+0x154>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
#endif      
      return &sockets[i];
    }
    result++;
    760a:	7c 96       	adiw	r30, 0x1c	; 28
    760c:	c1 cf       	rjmp	.-126    	; 0x7590 <processTcpPacket+0xd6>
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    760e:	c0 91 ae 32 	lds	r28, 0x32AE
    7612:	d0 91 af 32 	lds	r29, 0x32AF
    7616:	20 97       	sbiw	r28, 0x00	; 0
    7618:	09 f4       	brne	.+2      	; 0x761c <processTcpPacket+0x162>
    761a:	5f c1       	rjmp	.+702    	; 0x78da <processTcpPacket+0x420>
    if (tcpDebugLevel > 2)
    761c:	80 91 05 32 	lds	r24, 0x3205
    7620:	83 30       	cpi	r24, 0x03	; 3
    7622:	08 f4       	brcc	.+2      	; 0x7626 <processTcpPacket+0x16c>
    7624:	5a c1       	rjmp	.+692    	; 0x78da <processTcpPacket+0x420>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    7626:	db 01       	movw	r26, r22
    7628:	12 96       	adiw	r26, 0x02	; 2
    762a:	8d 91       	ld	r24, X+
    762c:	9c 91       	ld	r25, X
    762e:	13 97       	sbiw	r26, 0x03	; 3
    7630:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7634:	00 d0       	rcall	.+0      	; 0x7636 <processTcpPacket+0x17c>
    7636:	00 d0       	rcall	.+0      	; 0x7638 <processTcpPacket+0x17e>
    7638:	ed b7       	in	r30, 0x3d	; 61
    763a:	fe b7       	in	r31, 0x3e	; 62
    763c:	31 96       	adiw	r30, 0x01	; 1
    763e:	ad b7       	in	r26, 0x3d	; 61
    7640:	be b7       	in	r27, 0x3e	; 62
    7642:	11 96       	adiw	r26, 0x01	; 1
    7644:	cd 93       	st	X+, r28
    7646:	dc 93       	st	X, r29
    7648:	12 97       	sbiw	r26, 0x02	; 2
    764a:	2a e6       	ldi	r18, 0x6A	; 106
    764c:	3e e0       	ldi	r19, 0x0E	; 14
    764e:	22 83       	std	Z+2, r18	; 0x02
    7650:	33 83       	std	Z+3, r19	; 0x03
    7652:	84 83       	std	Z+4, r24	; 0x04
    7654:	95 83       	std	Z+5, r25	; 0x05
    7656:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    765a:	ed b7       	in	r30, 0x3d	; 61
    765c:	fe b7       	in	r31, 0x3e	; 62
    765e:	36 96       	adiw	r30, 0x06	; 6
    7660:	ed bf       	out	0x3d, r30	; 61
    7662:	fe bf       	out	0x3e, r31	; 62
    7664:	3a c1       	rjmp	.+628    	; 0x78da <processTcpPacket+0x420>

inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    7666:	20 97       	sbiw	r28, 0x00	; 0
    7668:	09 f4       	brne	.+2      	; 0x766c <processTcpPacket+0x1b2>
    766a:	37 c1       	rjmp	.+622    	; 0x78da <processTcpPacket+0x420>
    return 1;
  
  
  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    766c:	e0 91 e8 31 	lds	r30, 0x31E8
    7670:	f0 91 e9 31 	lds	r31, 0x31E9
    7674:	64 81       	ldd	r22, Z+4	; 0x04
    7676:	75 81       	ldd	r23, Z+5	; 0x05
    7678:	86 81       	ldd	r24, Z+6	; 0x06
    767a:	97 81       	ldd	r25, Z+7	; 0x07
    767c:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <htonl>
    7680:	69 87       	std	Y+9, r22	; 0x09
    7682:	7a 87       	std	Y+10, r23	; 0x0a
    7684:	8b 87       	std	Y+11, r24	; 0x0b
    7686:	9c 87       	std	Y+12, r25	; 0x0c
  
  if (socket->state == LISTEN)
    7688:	88 81       	ld	r24, Y
    768a:	81 30       	cpi	r24, 0x01	; 1
    768c:	09 f0       	breq	.+2      	; 0x7690 <processTcpPacket+0x1d6>
    768e:	b8 c0       	rjmp	.+368    	; 0x7800 <processTcpPacket+0x346>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    7690:	e0 91 e8 31 	lds	r30, 0x31E8
    7694:	f0 91 e9 31 	lds	r31, 0x31E9
    7698:	25 85       	ldd	r18, Z+13	; 0x0d
    769a:	80 91 ae 32 	lds	r24, 0x32AE
    769e:	90 91 af 32 	lds	r25, 0x32AF
    76a2:	21 ff       	sbrs	r18, 1
    76a4:	9a c0       	rjmp	.+308    	; 0x77da <processTcpPacket+0x320>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    76a6:	00 97       	sbiw	r24, 0x00	; 0
    76a8:	c1 f0       	breq	.+48     	; 0x76da <processTcpPacket+0x220>
        if (tcpDebugLevel > 2)
    76aa:	20 91 05 32 	lds	r18, 0x3205
    76ae:	23 30       	cpi	r18, 0x03	; 3
    76b0:	a0 f0       	brcs	.+40     	; 0x76da <processTcpPacket+0x220>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    76b2:	00 d0       	rcall	.+0      	; 0x76b4 <processTcpPacket+0x1fa>
    76b4:	0f 92       	push	r0
    76b6:	ad b7       	in	r26, 0x3d	; 61
    76b8:	be b7       	in	r27, 0x3e	; 62
    76ba:	11 96       	adiw	r26, 0x01	; 1
    76bc:	8d 93       	st	X+, r24
    76be:	9c 93       	st	X, r25
    76c0:	12 97       	sbiw	r26, 0x02	; 2
    76c2:	88 e2       	ldi	r24, 0x28	; 40
    76c4:	9e e0       	ldi	r25, 0x0E	; 14
    76c6:	13 96       	adiw	r26, 0x03	; 3
    76c8:	8d 93       	st	X+, r24
    76ca:	9c 93       	st	X, r25
    76cc:	14 97       	sbiw	r26, 0x04	; 4
    76ce:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    76d2:	0f 90       	pop	r0
    76d4:	0f 90       	pop	r0
    76d6:	0f 90       	pop	r0
    76d8:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    76da:	82 e0       	ldi	r24, 0x02	; 2
    76dc:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    76de:	e0 91 e8 31 	lds	r30, 0x31E8
    76e2:	f0 91 e9 31 	lds	r31, 0x31E9
    76e6:	20 81       	ld	r18, Z
    76e8:	31 81       	ldd	r19, Z+1	; 0x01
    76ea:	2f 83       	std	Y+7, r18	; 0x07
    76ec:	38 87       	std	Y+8, r19	; 0x08
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    76ee:	e0 91 e6 31 	lds	r30, 0x31E6
    76f2:	f0 91 e7 31 	lds	r31, 0x31E7
    76f6:	84 85       	ldd	r24, Z+12	; 0x0c
    76f8:	95 85       	ldd	r25, Z+13	; 0x0d
    76fa:	a6 85       	ldd	r26, Z+14	; 0x0e
    76fc:	b7 85       	ldd	r27, Z+15	; 0x0f
    76fe:	89 83       	std	Y+1, r24	; 0x01
    7700:	9a 83       	std	Y+2, r25	; 0x02
    7702:	ab 83       	std	Y+3, r26	; 0x03
    7704:	bc 83       	std	Y+4, r27	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    7706:	e0 91 e8 31 	lds	r30, 0x31E8
    770a:	f0 91 e9 31 	lds	r31, 0x31E9
    770e:	8d 81       	ldd	r24, Y+5	; 0x05
    7710:	9e 81       	ldd	r25, Y+6	; 0x06
    7712:	80 83       	st	Z, r24
    7714:	91 83       	std	Z+1, r25	; 0x01
      nicState.layer4.tcp->destport  = socket->remotePort;
    7716:	e0 91 e8 31 	lds	r30, 0x31E8
    771a:	f0 91 e9 31 	lds	r31, 0x31E9
    771e:	22 83       	std	Z+2, r18	; 0x02
    7720:	33 83       	std	Z+3, r19	; 0x03
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    7722:	00 91 e8 31 	lds	r16, 0x31E8
    7726:	10 91 e9 31 	lds	r17, 0x31E9
    772a:	6d 85       	ldd	r22, Y+13	; 0x0d
    772c:	7e 85       	ldd	r23, Y+14	; 0x0e
    772e:	8f 85       	ldd	r24, Y+15	; 0x0f
    7730:	98 89       	ldd	r25, Y+16	; 0x10
    7732:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <htonl>
    7736:	f8 01       	movw	r30, r16
    7738:	64 83       	std	Z+4, r22	; 0x04
    773a:	75 83       	std	Z+5, r23	; 0x05
    773c:	86 83       	std	Z+6, r24	; 0x06
    773e:	97 83       	std	Z+7, r25	; 0x07
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    7740:	00 91 e8 31 	lds	r16, 0x31E8
    7744:	10 91 e9 31 	lds	r17, 0x31E9
    7748:	69 85       	ldd	r22, Y+9	; 0x09
    774a:	7a 85       	ldd	r23, Y+10	; 0x0a
    774c:	8b 85       	ldd	r24, Y+11	; 0x0b
    774e:	9c 85       	ldd	r25, Y+12	; 0x0c
    7750:	6f 5f       	subi	r22, 0xFF	; 255
    7752:	7f 4f       	sbci	r23, 0xFF	; 255
    7754:	8f 4f       	sbci	r24, 0xFF	; 255
    7756:	9f 4f       	sbci	r25, 0xFF	; 255
    7758:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <htonl>
    775c:	d8 01       	movw	r26, r16
    775e:	18 96       	adiw	r26, 0x08	; 8
    7760:	6d 93       	st	X+, r22
    7762:	7d 93       	st	X+, r23
    7764:	8d 93       	st	X+, r24
    7766:	9c 93       	st	X, r25
    7768:	1b 97       	sbiw	r26, 0x0b	; 11
      nicState.layer4.tcp->tcpoffset = 5<<4;
    776a:	e0 91 e8 31 	lds	r30, 0x31E8
    776e:	f0 91 e9 31 	lds	r31, 0x31E9
    7772:	80 e5       	ldi	r24, 0x50	; 80
    7774:	84 87       	std	Z+12, r24	; 0x0c
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    7776:	e0 91 e8 31 	lds	r30, 0x31E8
    777a:	f0 91 e9 31 	lds	r31, 0x31E9
    777e:	82 e1       	ldi	r24, 0x12	; 18
    7780:	85 87       	std	Z+13, r24	; 0x0d
      nicState.layer4.tcp->wnd       = htons(100);
    7782:	00 91 e8 31 	lds	r16, 0x31E8
    7786:	10 91 e9 31 	lds	r17, 0x31E9
    778a:	84 e6       	ldi	r24, 0x64	; 100
    778c:	90 e0       	ldi	r25, 0x00	; 0
    778e:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7792:	f8 01       	movw	r30, r16
    7794:	86 87       	std	Z+14, r24	; 0x0e
    7796:	97 87       	std	Z+15, r25	; 0x0f
      nicState.layer4.tcp->tcpchksum = 0;
    7798:	e0 91 e8 31 	lds	r30, 0x31E8
    779c:	f0 91 e9 31 	lds	r31, 0x31E9
    77a0:	10 8a       	std	Z+16, r1	; 0x10
    77a2:	11 8a       	std	Z+17, r1	; 0x11
      nicState.layer4.tcp->urgp      = 0;
    77a4:	12 8a       	std	Z+18, r1	; 0x12
    77a6:	13 8a       	std	Z+19, r1	; 0x13
      calculateTcpChecksun(TCP_HEADER_LEN);
    77a8:	84 e1       	ldi	r24, 0x14	; 20
    77aa:	90 e0       	ldi	r25, 0x00	; 0
    77ac:	0e 94 4c 3a 	call	0x7498	; 0x7498 <calculateTcpChecksun>

      socket->seqNoLastSent++;
    77b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    77b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    77b4:	af 85       	ldd	r26, Y+15	; 0x0f
    77b6:	b8 89       	ldd	r27, Y+16	; 0x10
    77b8:	01 96       	adiw	r24, 0x01	; 1
    77ba:	a1 1d       	adc	r26, r1
    77bc:	b1 1d       	adc	r27, r1
    77be:	8d 87       	std	Y+13, r24	; 0x0d
    77c0:	9e 87       	std	Y+14, r25	; 0x0e
    77c2:	af 87       	std	Y+15, r26	; 0x0f
    77c4:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    77c6:	69 81       	ldd	r22, Y+1	; 0x01
    77c8:	7a 81       	ldd	r23, Y+2	; 0x02
    77ca:	8b 81       	ldd	r24, Y+3	; 0x03
    77cc:	9c 81       	ldd	r25, Y+4	; 0x04
    77ce:	46 e0       	ldi	r20, 0x06	; 6
    77d0:	24 e1       	ldi	r18, 0x14	; 20
    77d2:	30 e0       	ldi	r19, 0x00	; 0
    77d4:	0e 94 f2 32 	call	0x65e4	; 0x65e4 <ipSend>
    77d8:	82 c0       	rjmp	.+260    	; 0x78de <processTcpPacket+0x424>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    77da:	00 97       	sbiw	r24, 0x00	; 0
    77dc:	09 f4       	brne	.+2      	; 0x77e0 <processTcpPacket+0x326>
    77de:	7f c0       	rjmp	.+254    	; 0x78de <processTcpPacket+0x424>
        if (tcpDebugLevel > 1)
    77e0:	20 91 05 32 	lds	r18, 0x3205
    77e4:	22 30       	cpi	r18, 0x02	; 2
    77e6:	08 f4       	brcc	.+2      	; 0x77ea <processTcpPacket+0x330>
    77e8:	7a c0       	rjmp	.+244    	; 0x78de <processTcpPacket+0x424>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    77ea:	00 d0       	rcall	.+0      	; 0x77ec <processTcpPacket+0x332>
    77ec:	0f 92       	push	r0
    77ee:	ad b7       	in	r26, 0x3d	; 61
    77f0:	be b7       	in	r27, 0x3e	; 62
    77f2:	11 96       	adiw	r26, 0x01	; 1
    77f4:	8d 93       	st	X+, r24
    77f6:	9c 93       	st	X, r25
    77f8:	12 97       	sbiw	r26, 0x02	; 2
    77fa:	84 ef       	ldi	r24, 0xF4	; 244
    77fc:	9d e0       	ldi	r25, 0x0D	; 13
    77fe:	37 c0       	rjmp	.+110    	; 0x786e <processTcpPacket+0x3b4>
    }
#endif    
    return 0;
  }
  
  if (socket->state == SYN_RECEIVED)
    7800:	82 30       	cpi	r24, 0x02	; 2
    7802:	09 f0       	breq	.+2      	; 0x7806 <processTcpPacket+0x34c>
    7804:	3f c0       	rjmp	.+126    	; 0x7884 <processTcpPacket+0x3ca>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    7806:	e0 91 e8 31 	lds	r30, 0x31E8
    780a:	f0 91 e9 31 	lds	r31, 0x31E9
    780e:	25 85       	ldd	r18, Z+13	; 0x0d
    7810:	80 91 ae 32 	lds	r24, 0x32AE
    7814:	90 91 af 32 	lds	r25, 0x32AF
    7818:	24 ff       	sbrs	r18, 4
    781a:	15 c0       	rjmp	.+42     	; 0x7846 <processTcpPacket+0x38c>
    {
      socket->state    = ESTABILISHED;
    781c:	23 e0       	ldi	r18, 0x03	; 3
    781e:	28 83       	st	Y, r18
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    7820:	00 97       	sbiw	r24, 0x00	; 0
    7822:	09 f4       	brne	.+2      	; 0x7826 <processTcpPacket+0x36c>
    7824:	5c c0       	rjmp	.+184    	; 0x78de <processTcpPacket+0x424>
      if (tcpDebugLevel > 2)
    7826:	20 91 05 32 	lds	r18, 0x3205
    782a:	23 30       	cpi	r18, 0x03	; 3
    782c:	08 f4       	brcc	.+2      	; 0x7830 <processTcpPacket+0x376>
    782e:	57 c0       	rjmp	.+174    	; 0x78de <processTcpPacket+0x424>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    7830:	00 d0       	rcall	.+0      	; 0x7832 <processTcpPacket+0x378>
    7832:	0f 92       	push	r0
    7834:	ed b7       	in	r30, 0x3d	; 61
    7836:	fe b7       	in	r31, 0x3e	; 62
    7838:	81 83       	std	Z+1, r24	; 0x01
    783a:	92 83       	std	Z+2, r25	; 0x02
    783c:	8c ea       	ldi	r24, 0xAC	; 172
    783e:	9d e0       	ldi	r25, 0x0D	; 13
    7840:	83 83       	std	Z+3, r24	; 0x03
    7842:	94 83       	std	Z+4, r25	; 0x04
    7844:	18 c0       	rjmp	.+48     	; 0x7876 <processTcpPacket+0x3bc>
#endif        

    }
    else
    {
      socket->state = LISTEN;
    7846:	21 e0       	ldi	r18, 0x01	; 1
    7848:	28 83       	st	Y, r18
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    784a:	00 97       	sbiw	r24, 0x00	; 0
    784c:	09 f4       	brne	.+2      	; 0x7850 <processTcpPacket+0x396>
    784e:	47 c0       	rjmp	.+142    	; 0x78de <processTcpPacket+0x424>
        if (tcpDebugLevel > 1)
    7850:	20 91 05 32 	lds	r18, 0x3205
    7854:	22 30       	cpi	r18, 0x02	; 2
    7856:	08 f4       	brcc	.+2      	; 0x785a <processTcpPacket+0x3a0>
    7858:	42 c0       	rjmp	.+132    	; 0x78de <processTcpPacket+0x424>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    785a:	00 d0       	rcall	.+0      	; 0x785c <processTcpPacket+0x3a2>
    785c:	0f 92       	push	r0
    785e:	ad b7       	in	r26, 0x3d	; 61
    7860:	be b7       	in	r27, 0x3e	; 62
    7862:	11 96       	adiw	r26, 0x01	; 1
    7864:	8d 93       	st	X+, r24
    7866:	9c 93       	st	X, r25
    7868:	12 97       	sbiw	r26, 0x02	; 2
    786a:	88 e7       	ldi	r24, 0x78	; 120
    786c:	9d e0       	ldi	r25, 0x0D	; 13
    786e:	13 96       	adiw	r26, 0x03	; 3
    7870:	8d 93       	st	X+, r24
    7872:	9c 93       	st	X, r25
    7874:	14 97       	sbiw	r26, 0x04	; 4
    7876:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    787a:	0f 90       	pop	r0
    787c:	0f 90       	pop	r0
    787e:	0f 90       	pop	r0
    7880:	0f 90       	pop	r0
    7882:	2d c0       	rjmp	.+90     	; 0x78de <processTcpPacket+0x424>
    }
    return 0;
  }
  
  
  if (socket->state == ESTABILISHED)
    7884:	83 30       	cpi	r24, 0x03	; 3
    7886:	59 f5       	brne	.+86     	; 0x78de <processTcpPacket+0x424>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    7888:	e0 91 e8 31 	lds	r30, 0x31E8
    788c:	f0 91 e9 31 	lds	r31, 0x31E9
    7890:	85 85       	ldd	r24, Z+13	; 0x0d
    7892:	80 ff       	sbrs	r24, 0
    7894:	24 c0       	rjmp	.+72     	; 0x78de <processTcpPacket+0x424>
    {
      socket->timer              = timer100Hz;
    7896:	80 91 4a 25 	lds	r24, 0x254A
    789a:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    789c:	80 e1       	ldi	r24, 0x10	; 16
    789e:	85 87       	std	Z+13, r24	; 0x0d
//      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
//      {
//        dataFromBufLen++;
//        dataPtr++;
//      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    78a0:	69 81       	ldd	r22, Y+1	; 0x01
    78a2:	7a 81       	ldd	r23, Y+2	; 0x02
    78a4:	8b 81       	ldd	r24, Y+3	; 0x03
    78a6:	9c 81       	ldd	r25, Y+4	; 0x04
    78a8:	46 e0       	ldi	r20, 0x06	; 6
    78aa:	24 e1       	ldi	r18, 0x14	; 20
    78ac:	30 e0       	ldi	r19, 0x00	; 0
    78ae:	0e 94 f2 32 	call	0x65e4	; 0x65e4 <ipSend>
      socket->state    = CLOSE_WAIT;
    78b2:	84 e0       	ldi	r24, 0x04	; 4
    78b4:	88 83       	st	Y, r24
      
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    78b6:	e0 91 e8 31 	lds	r30, 0x31E8
    78ba:	f0 91 e9 31 	lds	r31, 0x31E9
    78be:	81 e0       	ldi	r24, 0x01	; 1
    78c0:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    78c2:	69 81       	ldd	r22, Y+1	; 0x01
    78c4:	7a 81       	ldd	r23, Y+2	; 0x02
    78c6:	8b 81       	ldd	r24, Y+3	; 0x03
    78c8:	9c 81       	ldd	r25, Y+4	; 0x04
    78ca:	46 e0       	ldi	r20, 0x06	; 6
    78cc:	24 e1       	ldi	r18, 0x14	; 20
    78ce:	30 e0       	ldi	r19, 0x00	; 0
    78d0:	0e 94 f2 32 	call	0x65e4	; 0x65e4 <ipSend>
      socket->state    = LAST_ACK;
    78d4:	85 e0       	ldi	r24, 0x05	; 5
    78d6:	88 83       	st	Y, r24
    78d8:	02 c0       	rjmp	.+4      	; 0x78de <processTcpPacket+0x424>
inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    return 1;
    78da:	81 e0       	ldi	r24, 0x01	; 1
    78dc:	01 c0       	rjmp	.+2      	; 0x78e0 <processTcpPacket+0x426>
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
      socket->state    = LAST_ACK;
    }
    return 0;
    78de:	80 e0       	ldi	r24, 0x00	; 0
  }

  //Read data and put into the queue
  
  return 0;
}
    78e0:	df 91       	pop	r29
    78e2:	cf 91       	pop	r28
    78e4:	1f 91       	pop	r17
    78e6:	0f 91       	pop	r16
    78e8:	ff 90       	pop	r15
    78ea:	ef 90       	pop	r14
    78ec:	df 90       	pop	r13
    78ee:	cf 90       	pop	r12
    78f0:	bf 90       	pop	r11
    78f2:	af 90       	pop	r10
    78f4:	08 95       	ret

000078f6 <sendTcBuffer>:

uint8_t sendTcBuffer(uint8_t socketNo)
{
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    78f6:	80 e0       	ldi	r24, 0x00	; 0
    78f8:	08 95       	ret

000078fa <netstackTCPIPProcess>:

void netstackTCPIPProcess(void)
{
    78fa:	cf 93       	push	r28
    78fc:	df 93       	push	r29
  if (nicState.layer4.tcp->destport == htons(80))
    78fe:	e0 91 e8 31 	lds	r30, 0x31E8
    7902:	f0 91 e9 31 	lds	r31, 0x31E9
    7906:	c2 81       	ldd	r28, Z+2	; 0x02
    7908:	d3 81       	ldd	r29, Z+3	; 0x03
    790a:	80 e5       	ldi	r24, 0x50	; 80
    790c:	90 e0       	ldi	r25, 0x00	; 0
    790e:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7912:	c8 17       	cp	r28, r24
    7914:	d9 07       	cpc	r29, r25
    7916:	b9 f4       	brne	.+46     	; 0x7946 <netstackTCPIPProcess+0x4c>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    7918:	80 91 ae 32 	lds	r24, 0x32AE
    791c:	90 91 af 32 	lds	r25, 0x32AF
    7920:	00 97       	sbiw	r24, 0x00	; 0
    7922:	99 f0       	breq	.+38     	; 0x794a <netstackTCPIPProcess+0x50>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    7924:	00 d0       	rcall	.+0      	; 0x7926 <netstackTCPIPProcess+0x2c>
    7926:	0f 92       	push	r0
    7928:	ed b7       	in	r30, 0x3d	; 61
    792a:	fe b7       	in	r31, 0x3e	; 62
    792c:	81 83       	std	Z+1, r24	; 0x01
    792e:	92 83       	std	Z+2, r25	; 0x02
    7930:	81 e6       	ldi	r24, 0x61	; 97
    7932:	9d e0       	ldi	r25, 0x0D	; 13
    7934:	83 83       	std	Z+3, r24	; 0x03
    7936:	94 83       	std	Z+4, r25	; 0x04
    7938:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    793c:	0f 90       	pop	r0
    793e:	0f 90       	pop	r0
    7940:	0f 90       	pop	r0
    7942:	0f 90       	pop	r0
    7944:	02 c0       	rjmp	.+4      	; 0x794a <netstackTCPIPProcess+0x50>
#endif
    ;
  }
  else
  {
    processTcpPacket();
    7946:	0e 94 5d 3a 	call	0x74ba	; 0x74ba <processTcpPacket>
  }
}
    794a:	df 91       	pop	r29
    794c:	cf 91       	pop	r28
    794e:	08 95       	ret

00007950 <setTcpDebug>:

#if TCP_DEBUG
void setTcpDebug(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    7950:	80 93 ae 32 	sts	0x32AE, r24
    7954:	90 93 af 32 	sts	0x32AF, r25
  tcpDebugLevel = level;
    7958:	60 93 05 32 	sts	0x3205, r22
}
    795c:	08 95       	ret

0000795e <flushTcpQueues>:
  for (sckNo = 0; sckNo < NUMBER_OF_SOCKETS; sckNo++)
  {
    
    sck++;
  }
}
    795e:	08 95       	ret

00007960 <httpProcess>:
          continue;  
        }
      }

#endif
    7960:	08 95       	ret

00007962 <udpInit>:
static uint32_t udpIpDst_eep   __attribute__((section (".eeprom"))) = ((uint32_t)UDP_DST_IP4   << 24) + ((uint32_t)UDP_DST_IP3   <<16) + ((uint32_t)UDP_DST_IP2   <<8) + UDP_DST_IP1;
static uint16_t udpPortDstEep  __attribute__((section (".eeprom"))) = HTONS(UDP_DST_PORT);
static uint16_t udpPortSrcEep  __attribute__((section (".eeprom"))) = HTONS(UDP_SRC_PORT);

void udpInit(void)
{
    7962:	ef 92       	push	r14
    7964:	ff 92       	push	r15
    7966:	cf 93       	push	r28
    7968:	df 93       	push	r29
#if UDP_DEBUG
  udpDbgStream         = NULL;
    796a:	10 92 22 32 	sts	0x3222, r1
    796e:	10 92 23 32 	sts	0x3223, r1
  udpDbgLevel          = 0;
    7972:	10 92 db 31 	sts	0x31DB, r1
#endif
  udpSocket = xmalloc(sizeof(UdpSocket_t));
    7976:	8e e0       	ldi	r24, 0x0E	; 14
    7978:	90 e0       	ldi	r25, 0x00	; 0
    797a:	0e 94 22 1c 	call	0x3844	; 0x3844 <xmalloc>
    797e:	e8 2e       	mov	r14, r24
    7980:	e7 01       	movw	r28, r14
    7982:	7e 01       	movw	r14, r28
    7984:	f9 2e       	mov	r15, r25
    7986:	e7 01       	movw	r28, r14
    7988:	e0 92 02 32 	sts	0x3202, r14
    798c:	f0 92 03 32 	sts	0x3203, r15

  udpSocket->dstIp      = eeprom_read_dword(&udpIpDst_eep);
    7990:	8a e2       	ldi	r24, 0x2A	; 42
    7992:	90 e0       	ldi	r25, 0x00	; 0
    7994:	0e 94 1e 5a 	call	0xb43c	; 0xb43c <__eerd_dword_x128a1>
    7998:	6e 83       	std	Y+6, r22	; 0x06
    799a:	7f 83       	std	Y+7, r23	; 0x07
    799c:	88 87       	std	Y+8, r24	; 0x08
    799e:	99 87       	std	Y+9, r25	; 0x09
  udpSocket->dstPortDef = eeprom_read_word(&udpPortDstEep);;
    79a0:	8e e2       	ldi	r24, 0x2E	; 46
    79a2:	90 e0       	ldi	r25, 0x00	; 0
    79a4:	0e 94 25 5a 	call	0xb44a	; 0xb44a <__eerd_word_x128a1>
    79a8:	88 83       	st	Y, r24
    79aa:	99 83       	std	Y+1, r25	; 0x01
  udpSocket->srcPort    = eeprom_read_word(&udpPortSrcEep);
    79ac:	80 e3       	ldi	r24, 0x30	; 48
    79ae:	90 e0       	ldi	r25, 0x00	; 0
    79b0:	0e 94 25 5a 	call	0xb44a	; 0xb44a <__eerd_word_x128a1>
    79b4:	8c 83       	std	Y+4, r24	; 0x04
    79b6:	9d 83       	std	Y+5, r25	; 0x05
  
  udpSocket->Rx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_RX_BUF_ADDR));
    79b8:	8f ef       	ldi	r24, 0xFF	; 255
    79ba:	61 e0       	ldi	r22, 0x01	; 1
    79bc:	40 e0       	ldi	r20, 0x00	; 0
    79be:	59 e7       	ldi	r21, 0x79	; 121
    79c0:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <xQueueCreateExternal>
    79c4:	8a 87       	std	Y+10, r24	; 0x0a
    79c6:	9b 87       	std	Y+11, r25	; 0x0b
  udpSocket->Tx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_TX_BUF_ADDR));
    79c8:	c0 91 02 32 	lds	r28, 0x3202
    79cc:	d0 91 03 32 	lds	r29, 0x3203
    79d0:	8f ef       	ldi	r24, 0xFF	; 255
    79d2:	61 e0       	ldi	r22, 0x01	; 1
    79d4:	40 e0       	ldi	r20, 0x00	; 0
    79d6:	58 e7       	ldi	r21, 0x78	; 120
    79d8:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <xQueueCreateExternal>
    79dc:	8c 87       	std	Y+12, r24	; 0x0c
    79de:	9d 87       	std	Y+13, r25	; 0x0d
}
    79e0:	df 91       	pop	r29
    79e2:	cf 91       	pop	r28
    79e4:	ff 90       	pop	r15
    79e6:	ef 90       	pop	r14
    79e8:	08 95       	ret

000079ea <setUdpDebug>:

#if UDP_DEBUG
void setUdpDebug(FILE *stream, uint8_t level)
{
  udpDbgStream = stream;
    79ea:	80 93 22 32 	sts	0x3222, r24
    79ee:	90 93 23 32 	sts	0x3223, r25
  udpDbgLevel = level;
    79f2:	60 93 db 31 	sts	0x31DB, r22
}
    79f6:	08 95       	ret

000079f8 <udpSend>:
#endif

inline void udpSend(uint16_t len)
{
    79f8:	ef 92       	push	r14
    79fa:	ff 92       	push	r15
    79fc:	0f 93       	push	r16
    79fe:	1f 93       	push	r17
    7a00:	cf 93       	push	r28
    7a02:	df 93       	push	r29
    7a04:	8c 01       	movw	r16, r24
// make pointer to UDP header
  nicState.layer4.udp->srcport  = udpSocket->srcPort;
    7a06:	e0 91 02 32 	lds	r30, 0x3202
    7a0a:	f0 91 03 32 	lds	r31, 0x3203
    7a0e:	a0 91 e8 31 	lds	r26, 0x31E8
    7a12:	b0 91 e9 31 	lds	r27, 0x31E9
    7a16:	84 81       	ldd	r24, Z+4	; 0x04
    7a18:	95 81       	ldd	r25, Z+5	; 0x05
    7a1a:	8d 93       	st	X+, r24
    7a1c:	9c 93       	st	X, r25
  nicState.layer4.udp->destport = (udpSocket->dstPortDef == 0)? udpSocket->dstPort : udpSocket->dstPortDef;          //data in udpSocket are stored in network order
    7a1e:	a0 91 e8 31 	lds	r26, 0x31E8
    7a22:	b0 91 e9 31 	lds	r27, 0x31E9
    7a26:	80 81       	ld	r24, Z
    7a28:	91 81       	ldd	r25, Z+1	; 0x01
    7a2a:	00 97       	sbiw	r24, 0x00	; 0
    7a2c:	11 f4       	brne	.+4      	; 0x7a32 <udpSend+0x3a>
    7a2e:	82 81       	ldd	r24, Z+2	; 0x02
    7a30:	93 81       	ldd	r25, Z+3	; 0x03
    7a32:	12 96       	adiw	r26, 0x02	; 2
    7a34:	8d 93       	st	X+, r24
    7a36:	9c 93       	st	X, r25
    7a38:	13 97       	sbiw	r26, 0x03	; 3
  
  nicState.layer4.udp->udplen = htons(len + UDP_HEADER_LEN);
    7a3a:	e0 90 e8 31 	lds	r14, 0x31E8
    7a3e:	f0 90 e9 31 	lds	r15, 0x31E9
    7a42:	e8 01       	movw	r28, r16
    7a44:	28 96       	adiw	r28, 0x08	; 8
    7a46:	ce 01       	movw	r24, r28
    7a48:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7a4c:	d7 01       	movw	r26, r14
    7a4e:	14 96       	adiw	r26, 0x04	; 4
    7a50:	8d 93       	st	X+, r24
    7a52:	9c 93       	st	X, r25
    7a54:	15 97       	sbiw	r26, 0x05	; 5
  nicState.layer4.udp->udpchksum = 0;
    7a56:	e0 91 e8 31 	lds	r30, 0x31E8
    7a5a:	f0 91 e9 31 	lds	r31, 0x31E9
    7a5e:	16 82       	std	Z+6, r1	; 0x06
    7a60:	17 82       	std	Z+7, r1	; 0x07

#if UDP_DEBUG
  if (udpDbgStream != NULL)
    7a62:	80 91 22 32 	lds	r24, 0x3222
    7a66:	90 91 23 32 	lds	r25, 0x3223
    7a6a:	00 97       	sbiw	r24, 0x00	; 0
    7a6c:	e1 f0       	breq	.+56     	; 0x7aa6 <udpSend+0xae>
    if (udpDbgLevel > 1)
    7a6e:	20 91 db 31 	lds	r18, 0x31DB
    7a72:	22 30       	cpi	r18, 0x02	; 2
    7a74:	c0 f0       	brcs	.+48     	; 0x7aa6 <udpSend+0xae>
      fprintf_P(udpDbgStream, PSTR("Sending UDP packet (data length %d)\r\n"), len);
    7a76:	00 d0       	rcall	.+0      	; 0x7a78 <udpSend+0x80>
    7a78:	00 d0       	rcall	.+0      	; 0x7a7a <udpSend+0x82>
    7a7a:	ed b7       	in	r30, 0x3d	; 61
    7a7c:	fe b7       	in	r31, 0x3e	; 62
    7a7e:	31 96       	adiw	r30, 0x01	; 1
    7a80:	ad b7       	in	r26, 0x3d	; 61
    7a82:	be b7       	in	r27, 0x3e	; 62
    7a84:	11 96       	adiw	r26, 0x01	; 1
    7a86:	8d 93       	st	X+, r24
    7a88:	9c 93       	st	X, r25
    7a8a:	12 97       	sbiw	r26, 0x02	; 2
    7a8c:	8b e7       	ldi	r24, 0x7B	; 123
    7a8e:	9f e0       	ldi	r25, 0x0F	; 15
    7a90:	82 83       	std	Z+2, r24	; 0x02
    7a92:	93 83       	std	Z+3, r25	; 0x03
    7a94:	04 83       	std	Z+4, r16	; 0x04
    7a96:	15 83       	std	Z+5, r17	; 0x05
    7a98:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7a9c:	ed b7       	in	r30, 0x3d	; 61
    7a9e:	fe b7       	in	r31, 0x3e	; 62
    7aa0:	36 96       	adiw	r30, 0x06	; 6
    7aa2:	ed bf       	out	0x3d, r30	; 61
    7aa4:	fe bf       	out	0x3e, r31	; 62
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
    7aa6:	e0 91 02 32 	lds	r30, 0x3202
    7aaa:	f0 91 03 32 	lds	r31, 0x3203
    7aae:	66 81       	ldd	r22, Z+6	; 0x06
    7ab0:	77 81       	ldd	r23, Z+7	; 0x07
    7ab2:	80 85       	ldd	r24, Z+8	; 0x08
    7ab4:	91 85       	ldd	r25, Z+9	; 0x09
    7ab6:	41 e1       	ldi	r20, 0x11	; 17
    7ab8:	9e 01       	movw	r18, r28
    7aba:	0e 94 f2 32 	call	0x65e4	; 0x65e4 <ipSend>
}
    7abe:	df 91       	pop	r29
    7ac0:	cf 91       	pop	r28
    7ac2:	1f 91       	pop	r17
    7ac4:	0f 91       	pop	r16
    7ac6:	ff 90       	pop	r15
    7ac8:	ef 90       	pop	r14
    7aca:	08 95       	ret

00007acc <netstackUDPIPProcess>:

inline void netstackUDPIPProcess(void)
{
    7acc:	af 92       	push	r10
    7ace:	bf 92       	push	r11
    7ad0:	cf 92       	push	r12
    7ad2:	df 92       	push	r13
    7ad4:	ff 92       	push	r15
    7ad6:	0f 93       	push	r16
    7ad8:	1f 93       	push	r17
    7ada:	cf 93       	push	r28
    7adc:	df 93       	push	r29
  uint16_t len = (uint16_t) htons(nicState.layer4.udp->udplen);
    7ade:	e0 91 e8 31 	lds	r30, 0x31E8
    7ae2:	f0 91 e9 31 	lds	r31, 0x31E9
    7ae6:	84 81       	ldd	r24, Z+4	; 0x04
    7ae8:	95 81       	ldd	r25, Z+5	; 0x05
    7aea:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7aee:	8c 01       	movw	r16, r24
  uint8_t i;

  #if UDP_DEBUG
  if(udpDbgStream != NULL)
    7af0:	80 91 22 32 	lds	r24, 0x3222
    7af4:	90 91 23 32 	lds	r25, 0x3223
    7af8:	00 97       	sbiw	r24, 0x00	; 0
    7afa:	f1 f0       	breq	.+60     	; 0x7b38 <netstackUDPIPProcess+0x6c>
    if (udpDbgLevel > 3)
    7afc:	20 91 db 31 	lds	r18, 0x31DB
    7b00:	24 30       	cpi	r18, 0x04	; 4
    7b02:	d0 f0       	brcs	.+52     	; 0x7b38 <netstackUDPIPProcess+0x6c>
      fprintf_P(udpDbgStream, PSTR("Proc. UDP packet (data length %d)\r\n"), len-UDP_HEADER_LEN);
    7b04:	00 d0       	rcall	.+0      	; 0x7b06 <netstackUDPIPProcess+0x3a>
    7b06:	00 d0       	rcall	.+0      	; 0x7b08 <netstackUDPIPProcess+0x3c>
    7b08:	ed b7       	in	r30, 0x3d	; 61
    7b0a:	fe b7       	in	r31, 0x3e	; 62
    7b0c:	31 96       	adiw	r30, 0x01	; 1
    7b0e:	ad b7       	in	r26, 0x3d	; 61
    7b10:	be b7       	in	r27, 0x3e	; 62
    7b12:	11 96       	adiw	r26, 0x01	; 1
    7b14:	8d 93       	st	X+, r24
    7b16:	9c 93       	st	X, r25
    7b18:	12 97       	sbiw	r26, 0x02	; 2
    7b1a:	87 e5       	ldi	r24, 0x57	; 87
    7b1c:	9f e0       	ldi	r25, 0x0F	; 15
    7b1e:	82 83       	std	Z+2, r24	; 0x02
    7b20:	93 83       	std	Z+3, r25	; 0x03
    7b22:	c8 01       	movw	r24, r16
    7b24:	08 97       	sbiw	r24, 0x08	; 8
    7b26:	84 83       	std	Z+4, r24	; 0x04
    7b28:	95 83       	std	Z+5, r25	; 0x05
    7b2a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7b2e:	ed b7       	in	r30, 0x3d	; 61
    7b30:	fe b7       	in	r31, 0x3e	; 62
    7b32:	36 96       	adiw	r30, 0x06	; 6
    7b34:	ed bf       	out	0x3d, r30	; 61
    7b36:	fe bf       	out	0x3e, r31	; 62
#endif

  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    7b38:	a0 91 e8 31 	lds	r26, 0x31E8
    7b3c:	b0 91 e9 31 	lds	r27, 0x31E9
    7b40:	e0 91 02 32 	lds	r30, 0x3202
    7b44:	f0 91 03 32 	lds	r31, 0x3203
    7b48:	12 96       	adiw	r26, 0x02	; 2
    7b4a:	2d 91       	ld	r18, X+
    7b4c:	3c 91       	ld	r19, X
    7b4e:	13 97       	sbiw	r26, 0x03	; 3
    7b50:	84 81       	ldd	r24, Z+4	; 0x04
    7b52:	95 81       	ldd	r25, Z+5	; 0x05
    7b54:	28 17       	cp	r18, r24
    7b56:	39 07       	cpc	r19, r25
    7b58:	09 f0       	breq	.+2      	; 0x7b5c <netstackUDPIPProcess+0x90>
    7b5a:	a8 c0       	rjmp	.+336    	; 0x7cac <netstackUDPIPProcess+0x1e0>
    7b5c:	20 81       	ld	r18, Z
    7b5e:	31 81       	ldd	r19, Z+1	; 0x01
    7b60:	8d 91       	ld	r24, X+
    7b62:	9c 91       	ld	r25, X
    7b64:	11 97       	sbiw	r26, 0x01	; 1
    7b66:	21 15       	cp	r18, r1
    7b68:	31 05       	cpc	r19, r1
    7b6a:	39 f0       	breq	.+14     	; 0x7b7a <netstackUDPIPProcess+0xae>
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
    7b6c:	22 81       	ldd	r18, Z+2	; 0x02
    7b6e:	33 81       	ldd	r19, Z+3	; 0x03
    7b70:	28 17       	cp	r18, r24
    7b72:	39 07       	cpc	r19, r25
    7b74:	09 f0       	breq	.+2      	; 0x7b78 <netstackUDPIPProcess+0xac>
    7b76:	9a c0       	rjmp	.+308    	; 0x7cac <netstackUDPIPProcess+0x1e0>
    7b78:	02 c0       	rjmp	.+4      	; 0x7b7e <netstackUDPIPProcess+0xb2>
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    7b7a:	82 83       	std	Z+2, r24	; 0x02
    7b7c:	93 83       	std	Z+3, r25	; 0x03
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7b7e:	c0 91 e8 31 	lds	r28, 0x31E8
    7b82:	d0 91 e9 31 	lds	r29, 0x31E9
    7b86:	28 96       	adiw	r28, 0x08	; 8
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7b88:	80 91 22 32 	lds	r24, 0x3222
    7b8c:	90 91 23 32 	lds	r25, 0x3223
    7b90:	00 97       	sbiw	r24, 0x00	; 0
    7b92:	c1 f0       	breq	.+48     	; 0x7bc4 <netstackUDPIPProcess+0xf8>
        if (udpDbgLevel > 4)
    7b94:	20 91 db 31 	lds	r18, 0x31DB
    7b98:	25 30       	cpi	r18, 0x05	; 5
    7b9a:	a0 f0       	brcs	.+40     	; 0x7bc4 <netstackUDPIPProcess+0xf8>
          fprintf_P(udpDbgStream, PSTR("Received data: "));
    7b9c:	00 d0       	rcall	.+0      	; 0x7b9e <netstackUDPIPProcess+0xd2>
    7b9e:	0f 92       	push	r0
    7ba0:	ad b7       	in	r26, 0x3d	; 61
    7ba2:	be b7       	in	r27, 0x3e	; 62
    7ba4:	11 96       	adiw	r26, 0x01	; 1
    7ba6:	8d 93       	st	X+, r24
    7ba8:	9c 93       	st	X, r25
    7baa:	12 97       	sbiw	r26, 0x02	; 2
    7bac:	87 e4       	ldi	r24, 0x47	; 71
    7bae:	9f e0       	ldi	r25, 0x0F	; 15
    7bb0:	13 96       	adiw	r26, 0x03	; 3
    7bb2:	8d 93       	st	X+, r24
    7bb4:	9c 93       	st	X, r25
    7bb6:	14 97       	sbiw	r26, 0x04	; 4
    7bb8:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7bbc:	0f 90       	pop	r0
    7bbe:	0f 90       	pop	r0
    7bc0:	0f 90       	pop	r0
    7bc2:	0f 90       	pop	r0
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
}

inline void netstackUDPIPProcess(void)
{
    7bc4:	28 e0       	ldi	r18, 0x08	; 8
    7bc6:	f2 2e       	mov	r15, r18
    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7bc8:	9f e3       	ldi	r25, 0x3F	; 63
    7bca:	c9 2e       	mov	r12, r25
    7bcc:	9f e0       	ldi	r25, 0x0F	; 15
    7bce:	d9 2e       	mov	r13, r25
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
        if(udpDbgStream != NULL)
          if (udpDbgLevel > 0)
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7bd0:	8a e2       	ldi	r24, 0x2A	; 42
    7bd2:	a8 2e       	mov	r10, r24
    7bd4:	8f e0       	ldi	r24, 0x0F	; 15
    7bd6:	b8 2e       	mov	r11, r24
    7bd8:	49 c0       	rjmp	.+146    	; 0x7c6c <netstackUDPIPProcess+0x1a0>
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7bda:	00 97       	sbiw	r24, 0x00	; 0
    7bdc:	d9 f0       	breq	.+54     	; 0x7c14 <netstackUDPIPProcess+0x148>
        if (udpDbgLevel > 4)
    7bde:	20 91 db 31 	lds	r18, 0x31DB
    7be2:	25 30       	cpi	r18, 0x05	; 5
    7be4:	b8 f0       	brcs	.+46     	; 0x7c14 <netstackUDPIPProcess+0x148>
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7be6:	00 d0       	rcall	.+0      	; 0x7be8 <netstackUDPIPProcess+0x11c>
    7be8:	00 d0       	rcall	.+0      	; 0x7bea <netstackUDPIPProcess+0x11e>
    7bea:	ed b7       	in	r30, 0x3d	; 61
    7bec:	fe b7       	in	r31, 0x3e	; 62
    7bee:	31 96       	adiw	r30, 0x01	; 1
    7bf0:	ad b7       	in	r26, 0x3d	; 61
    7bf2:	be b7       	in	r27, 0x3e	; 62
    7bf4:	11 96       	adiw	r26, 0x01	; 1
    7bf6:	8d 93       	st	X+, r24
    7bf8:	9c 93       	st	X, r25
    7bfa:	12 97       	sbiw	r26, 0x02	; 2
    7bfc:	c2 82       	std	Z+2, r12	; 0x02
    7bfe:	d3 82       	std	Z+3, r13	; 0x03
    7c00:	88 81       	ld	r24, Y
    7c02:	84 83       	std	Z+4, r24	; 0x04
    7c04:	15 82       	std	Z+5, r1	; 0x05
    7c06:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7c0a:	ed b7       	in	r30, 0x3d	; 61
    7c0c:	fe b7       	in	r31, 0x3e	; 62
    7c0e:	36 96       	adiw	r30, 0x06	; 6
    7c10:	ed bf       	out	0x3d, r30	; 61
    7c12:	fe bf       	out	0x3e, r31	; 62
#endif
#if UDB_DEBUG
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
    7c14:	e0 91 02 32 	lds	r30, 0x3202
    7c18:	f0 91 03 32 	lds	r31, 0x3203
    7c1c:	82 85       	ldd	r24, Z+10	; 0x0a
    7c1e:	93 85       	ldd	r25, Z+11	; 0x0b
    7c20:	be 01       	movw	r22, r28
    7c22:	4a e0       	ldi	r20, 0x0A	; 10
    7c24:	50 e0       	ldi	r21, 0x00	; 0
    7c26:	20 e0       	ldi	r18, 0x00	; 0
    7c28:	0e 94 87 4d 	call	0x9b0e	; 0x9b0e <xQueueGenericSend>
    7c2c:	88 23       	and	r24, r24
    7c2e:	e1 f4       	brne	.+56     	; 0x7c68 <netstackUDPIPProcess+0x19c>
        if(udpDbgStream != NULL)
    7c30:	80 91 22 32 	lds	r24, 0x3222
    7c34:	90 91 23 32 	lds	r25, 0x3223
    7c38:	00 97       	sbiw	r24, 0x00	; 0
    7c3a:	b1 f0       	breq	.+44     	; 0x7c68 <netstackUDPIPProcess+0x19c>
          if (udpDbgLevel > 0)
    7c3c:	20 91 db 31 	lds	r18, 0x31DB
    7c40:	22 23       	and	r18, r18
    7c42:	91 f0       	breq	.+36     	; 0x7c68 <netstackUDPIPProcess+0x19c>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7c44:	00 d0       	rcall	.+0      	; 0x7c46 <netstackUDPIPProcess+0x17a>
    7c46:	0f 92       	push	r0
    7c48:	ad b7       	in	r26, 0x3d	; 61
    7c4a:	be b7       	in	r27, 0x3e	; 62
    7c4c:	11 96       	adiw	r26, 0x01	; 1
    7c4e:	8d 93       	st	X+, r24
    7c50:	9c 93       	st	X, r25
    7c52:	12 97       	sbiw	r26, 0x02	; 2
    7c54:	13 96       	adiw	r26, 0x03	; 3
    7c56:	ad 92       	st	X+, r10
    7c58:	bc 92       	st	X, r11
    7c5a:	14 97       	sbiw	r26, 0x04	; 4
    7c5c:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7c60:	0f 90       	pop	r0
    7c62:	0f 90       	pop	r0
    7c64:	0f 90       	pop	r0
    7c66:	0f 90       	pop	r0
#endif
      tmp++;
    7c68:	21 96       	adiw	r28, 0x01	; 1
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received data: "));
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    7c6a:	f3 94       	inc	r15
    7c6c:	2f 2d       	mov	r18, r15
    7c6e:	30 e0       	ldi	r19, 0x00	; 0
    7c70:	80 91 22 32 	lds	r24, 0x3222
    7c74:	90 91 23 32 	lds	r25, 0x3223
    7c78:	20 17       	cp	r18, r16
    7c7a:	31 07       	cpc	r19, r17
    7c7c:	08 f4       	brcc	.+2      	; 0x7c80 <netstackUDPIPProcess+0x1b4>
    7c7e:	ad cf       	rjmp	.-166    	; 0x7bda <netstackUDPIPProcess+0x10e>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
#endif
      tmp++;
    }
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    7c80:	00 97       	sbiw	r24, 0x00	; 0
    7c82:	a1 f0       	breq	.+40     	; 0x7cac <netstackUDPIPProcess+0x1e0>
      if (udpDbgLevel > 4)
    7c84:	20 91 db 31 	lds	r18, 0x31DB
    7c88:	25 30       	cpi	r18, 0x05	; 5
    7c8a:	80 f0       	brcs	.+32     	; 0x7cac <netstackUDPIPProcess+0x1e0>
        fprintf_P(udpDbgStream, PSTR("\r\n"));
    7c8c:	00 d0       	rcall	.+0      	; 0x7c8e <netstackUDPIPProcess+0x1c2>
    7c8e:	0f 92       	push	r0
    7c90:	ed b7       	in	r30, 0x3d	; 61
    7c92:	fe b7       	in	r31, 0x3e	; 62
    7c94:	81 83       	std	Z+1, r24	; 0x01
    7c96:	92 83       	std	Z+2, r25	; 0x02
    7c98:	87 e2       	ldi	r24, 0x27	; 39
    7c9a:	9f e0       	ldi	r25, 0x0F	; 15
    7c9c:	83 83       	std	Z+3, r24	; 0x03
    7c9e:	94 83       	std	Z+4, r25	; 0x04
    7ca0:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7ca4:	0f 90       	pop	r0
    7ca6:	0f 90       	pop	r0
    7ca8:	0f 90       	pop	r0
    7caa:	0f 90       	pop	r0
#endif

  }
}
    7cac:	df 91       	pop	r29
    7cae:	cf 91       	pop	r28
    7cb0:	1f 91       	pop	r17
    7cb2:	0f 91       	pop	r16
    7cb4:	ff 90       	pop	r15
    7cb6:	df 90       	pop	r13
    7cb8:	cf 90       	pop	r12
    7cba:	bf 90       	pop	r11
    7cbc:	af 90       	pop	r10
    7cbe:	08 95       	ret

00007cc0 <flushUdpQueues>:

inline void flushUdpQueues(void)
{
    7cc0:	0f 93       	push	r16
    7cc2:	1f 93       	push	r17
    7cc4:	cf 93       	push	r28
    7cc6:	df 93       	push	r29
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
    7cc8:	e0 91 02 32 	lds	r30, 0x3202
    7ccc:	f0 91 03 32 	lds	r31, 0x3203
    7cd0:	84 85       	ldd	r24, Z+12	; 0x0c
    7cd2:	95 85       	ldd	r25, Z+13	; 0x0d
    7cd4:	0e 94 cb 4f 	call	0x9f96	; 0x9f96 <uxQueueMessagesWaiting>
    7cd8:	88 23       	and	r24, r24
    7cda:	e9 f0       	breq	.+58     	; 0x7d16 <flushUdpQueues+0x56>
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7cdc:	00 91 e8 31 	lds	r16, 0x31E8
    7ce0:	10 91 e9 31 	lds	r17, 0x31E9

inline void flushUdpQueues(void)
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    7ce4:	c0 e0       	ldi	r28, 0x00	; 0
    7ce6:	d0 e0       	ldi	r29, 0x00	; 0
#endif

  }
}

inline void flushUdpQueues(void)
    7ce8:	08 5f       	subi	r16, 0xF8	; 248
    7cea:	1f 4f       	sbci	r17, 0xFF	; 255
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7cec:	01 c0       	rjmp	.+2      	; 0x7cf0 <flushUdpQueues+0x30>
    {
      data++;
      len++;
    7cee:	21 96       	adiw	r28, 0x01	; 1
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7cf0:	e0 91 02 32 	lds	r30, 0x3202
    7cf4:	f0 91 03 32 	lds	r31, 0x3203
#endif

  }
}

inline void flushUdpQueues(void)
    7cf8:	b8 01       	movw	r22, r16
    7cfa:	6c 0f       	add	r22, r28
    7cfc:	7d 1f       	adc	r23, r29
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7cfe:	84 85       	ldd	r24, Z+12	; 0x0c
    7d00:	95 85       	ldd	r25, Z+13	; 0x0d
    7d02:	40 e0       	ldi	r20, 0x00	; 0
    7d04:	50 e0       	ldi	r21, 0x00	; 0
    7d06:	20 e0       	ldi	r18, 0x00	; 0
    7d08:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    7d0c:	81 30       	cpi	r24, 0x01	; 1
    7d0e:	79 f3       	breq	.-34     	; 0x7cee <flushUdpQueues+0x2e>
    {
      data++;
      len++;
    }
    udpSend(len);
    7d10:	ce 01       	movw	r24, r28
    7d12:	0e 94 fc 3c 	call	0x79f8	; 0x79f8 <udpSend>
  }
}
    7d16:	df 91       	pop	r29
    7d18:	cf 91       	pop	r28
    7d1a:	1f 91       	pop	r17
    7d1c:	0f 91       	pop	r16
    7d1e:	08 95       	ret

00007d20 <udpSaveConfig>:

void udpSaveConfig(void)
{
  eeprom_update_dword(&udpIpDst_eep, udpSocket->dstIp);
    7d20:	e0 91 02 32 	lds	r30, 0x3202
    7d24:	f0 91 03 32 	lds	r31, 0x3203
    7d28:	46 81       	ldd	r20, Z+6	; 0x06
    7d2a:	57 81       	ldd	r21, Z+7	; 0x07
    7d2c:	60 85       	ldd	r22, Z+8	; 0x08
    7d2e:	71 85       	ldd	r23, Z+9	; 0x09
    7d30:	8a e2       	ldi	r24, 0x2A	; 42
    7d32:	90 e0       	ldi	r25, 0x00	; 0
    7d34:	0e 94 45 5a 	call	0xb48a	; 0xb48a <__eeupd_dword_x128a1>
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
    7d38:	e0 91 02 32 	lds	r30, 0x3202
    7d3c:	f0 91 03 32 	lds	r31, 0x3203
    7d40:	60 81       	ld	r22, Z
    7d42:	71 81       	ldd	r23, Z+1	; 0x01
    7d44:	8e e2       	ldi	r24, 0x2E	; 46
    7d46:	90 e0       	ldi	r25, 0x00	; 0
    7d48:	0e 94 51 5a 	call	0xb4a2	; 0xb4a2 <__eeupd_word_x128a1>
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
    7d4c:	e0 91 02 32 	lds	r30, 0x3202
    7d50:	f0 91 03 32 	lds	r31, 0x3203
    7d54:	64 81       	ldd	r22, Z+4	; 0x04
    7d56:	75 81       	ldd	r23, Z+5	; 0x05
    7d58:	80 e3       	ldi	r24, 0x30	; 48
    7d5a:	90 e0       	ldi	r25, 0x00	; 0
    7d5c:	0e 94 51 5a 	call	0xb4a2	; 0xb4a2 <__eeupd_word_x128a1>
}
    7d60:	08 95       	ret

00007d62 <udpPrintStatus>:

void udpPrintStatus(FILE *stream)
{
    7d62:	cf 93       	push	r28
    7d64:	df 93       	push	r29
    7d66:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR("UDP config:"));
    7d68:	00 d0       	rcall	.+0      	; 0x7d6a <udpPrintStatus+0x8>
    7d6a:	0f 92       	push	r0
    7d6c:	ad b7       	in	r26, 0x3d	; 61
    7d6e:	be b7       	in	r27, 0x3e	; 62
    7d70:	11 96       	adiw	r26, 0x01	; 1
    7d72:	8d 93       	st	X+, r24
    7d74:	9c 93       	st	X, r25
    7d76:	12 97       	sbiw	r26, 0x02	; 2
    7d78:	8b e1       	ldi	r24, 0x1B	; 27
    7d7a:	9f e0       	ldi	r25, 0x0F	; 15
    7d7c:	13 96       	adiw	r26, 0x03	; 3
    7d7e:	8d 93       	st	X+, r24
    7d80:	9c 93       	st	X, r25
    7d82:	14 97       	sbiw	r26, 0x04	; 4
    7d84:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n  IP          : ")); netPrintIPAddr(stream, udpSocket->dstIp);
    7d88:	ed b7       	in	r30, 0x3d	; 61
    7d8a:	fe b7       	in	r31, 0x3e	; 62
    7d8c:	c1 83       	std	Z+1, r28	; 0x01
    7d8e:	d2 83       	std	Z+2, r29	; 0x02
    7d90:	88 e0       	ldi	r24, 0x08	; 8
    7d92:	9f e0       	ldi	r25, 0x0F	; 15
    7d94:	83 83       	std	Z+3, r24	; 0x03
    7d96:	94 83       	std	Z+4, r25	; 0x04
    7d98:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7d9c:	0f 90       	pop	r0
    7d9e:	0f 90       	pop	r0
    7da0:	0f 90       	pop	r0
    7da2:	0f 90       	pop	r0
    7da4:	e0 91 02 32 	lds	r30, 0x3202
    7da8:	f0 91 03 32 	lds	r31, 0x3203
    7dac:	46 81       	ldd	r20, Z+6	; 0x06
    7dae:	57 81       	ldd	r21, Z+7	; 0x07
    7db0:	60 85       	ldd	r22, Z+8	; 0x08
    7db2:	71 85       	ldd	r23, Z+9	; 0x09
    7db4:	ce 01       	movw	r24, r28
    7db6:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n  src port    : %d\r\n  dst port    : "), htons(udpSocket->srcPort));
    7dba:	e0 91 02 32 	lds	r30, 0x3202
    7dbe:	f0 91 03 32 	lds	r31, 0x3203
    7dc2:	84 81       	ldd	r24, Z+4	; 0x04
    7dc4:	95 81       	ldd	r25, Z+5	; 0x05
    7dc6:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7dca:	00 d0       	rcall	.+0      	; 0x7dcc <udpPrintStatus+0x6a>
    7dcc:	00 d0       	rcall	.+0      	; 0x7dce <udpPrintStatus+0x6c>
    7dce:	ed b7       	in	r30, 0x3d	; 61
    7dd0:	fe b7       	in	r31, 0x3e	; 62
    7dd2:	31 96       	adiw	r30, 0x01	; 1
    7dd4:	ad b7       	in	r26, 0x3d	; 61
    7dd6:	be b7       	in	r27, 0x3e	; 62
    7dd8:	11 96       	adiw	r26, 0x01	; 1
    7dda:	cd 93       	st	X+, r28
    7ddc:	dc 93       	st	X, r29
    7dde:	12 97       	sbiw	r26, 0x02	; 2
    7de0:	21 ee       	ldi	r18, 0xE1	; 225
    7de2:	3e e0       	ldi	r19, 0x0E	; 14
    7de4:	22 83       	std	Z+2, r18	; 0x02
    7de6:	33 83       	std	Z+3, r19	; 0x03
    7de8:	84 83       	std	Z+4, r24	; 0x04
    7dea:	95 83       	std	Z+5, r25	; 0x05
    7dec:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
  if (udpSocket->dstPortDef == HTONS(0))
    7df0:	e0 91 02 32 	lds	r30, 0x3202
    7df4:	f0 91 03 32 	lds	r31, 0x3203
    7df8:	80 81       	ld	r24, Z
    7dfa:	91 81       	ldd	r25, Z+1	; 0x01
    7dfc:	ed b7       	in	r30, 0x3d	; 61
    7dfe:	fe b7       	in	r31, 0x3e	; 62
    7e00:	36 96       	adiw	r30, 0x06	; 6
    7e02:	ed bf       	out	0x3d, r30	; 61
    7e04:	fe bf       	out	0x3e, r31	; 62
    7e06:	00 97       	sbiw	r24, 0x00	; 0
    7e08:	a9 f4       	brne	.+42     	; 0x7e34 <udpPrintStatus+0xd2>
    fprintf_P(stream, PSTR("ANY\r\n"));
    7e0a:	00 d0       	rcall	.+0      	; 0x7e0c <udpPrintStatus+0xaa>
    7e0c:	0f 92       	push	r0
    7e0e:	ad b7       	in	r26, 0x3d	; 61
    7e10:	be b7       	in	r27, 0x3e	; 62
    7e12:	11 96       	adiw	r26, 0x01	; 1
    7e14:	cd 93       	st	X+, r28
    7e16:	dc 93       	st	X, r29
    7e18:	12 97       	sbiw	r26, 0x02	; 2
    7e1a:	8b ed       	ldi	r24, 0xDB	; 219
    7e1c:	9e e0       	ldi	r25, 0x0E	; 14
    7e1e:	13 96       	adiw	r26, 0x03	; 3
    7e20:	8d 93       	st	X+, r24
    7e22:	9c 93       	st	X, r25
    7e24:	14 97       	sbiw	r26, 0x04	; 4
    7e26:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7e2a:	0f 90       	pop	r0
    7e2c:	0f 90       	pop	r0
    7e2e:	0f 90       	pop	r0
    7e30:	0f 90       	pop	r0
    7e32:	1a c0       	rjmp	.+52     	; 0x7e68 <udpPrintStatus+0x106>
  else
    fprintf_P(stream, PSTR("%d\r\n"), htons(udpSocket->dstPortDef));    
    7e34:	0e 94 4f 2e 	call	0x5c9e	; 0x5c9e <htons>
    7e38:	00 d0       	rcall	.+0      	; 0x7e3a <udpPrintStatus+0xd8>
    7e3a:	00 d0       	rcall	.+0      	; 0x7e3c <udpPrintStatus+0xda>
    7e3c:	ed b7       	in	r30, 0x3d	; 61
    7e3e:	fe b7       	in	r31, 0x3e	; 62
    7e40:	31 96       	adiw	r30, 0x01	; 1
    7e42:	ad b7       	in	r26, 0x3d	; 61
    7e44:	be b7       	in	r27, 0x3e	; 62
    7e46:	11 96       	adiw	r26, 0x01	; 1
    7e48:	cd 93       	st	X+, r28
    7e4a:	dc 93       	st	X, r29
    7e4c:	12 97       	sbiw	r26, 0x02	; 2
    7e4e:	26 ed       	ldi	r18, 0xD6	; 214
    7e50:	3e e0       	ldi	r19, 0x0E	; 14
    7e52:	22 83       	std	Z+2, r18	; 0x02
    7e54:	33 83       	std	Z+3, r19	; 0x03
    7e56:	84 83       	std	Z+4, r24	; 0x04
    7e58:	95 83       	std	Z+5, r25	; 0x05
    7e5a:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    7e5e:	ed b7       	in	r30, 0x3d	; 61
    7e60:	fe b7       	in	r31, 0x3e	; 62
    7e62:	36 96       	adiw	r30, 0x06	; 6
    7e64:	ed bf       	out	0x3d, r30	; 61
    7e66:	fe bf       	out	0x3e, r31	; 62
}
    7e68:	df 91       	pop	r29
    7e6a:	cf 91       	pop	r28
    7e6c:	08 95       	ret

00007e6e <_crc_xmodem_update>:
    7e6e:	9c 01       	movw	r18, r24
    7e70:	36 27       	eor	r19, r22
    7e72:	03 2e       	mov	r0, r19
    7e74:	02 94       	swap	r0
    7e76:	80 2d       	mov	r24, r0
    7e78:	8f 70       	andi	r24, 0x0F	; 15
    7e7a:	83 27       	eor	r24, r19
    7e7c:	63 2f       	mov	r22, r19
    7e7e:	60 25       	eor	r22, r0
    7e80:	66 0f       	add	r22, r22
    7e82:	60 7e       	andi	r22, 0xE0	; 224
    7e84:	86 27       	eor	r24, r22
    7e86:	60 2d       	mov	r22, r0
    7e88:	63 27       	eor	r22, r19
    7e8a:	60 7f       	andi	r22, 0xF0	; 240
    7e8c:	66 95       	lsr	r22
    7e8e:	03 2e       	mov	r0, r19
    7e90:	00 0c       	add	r0, r0
    7e92:	66 1f       	adc	r22, r22
    7e94:	36 95       	lsr	r19
    7e96:	36 95       	lsr	r19
    7e98:	36 95       	lsr	r19
    7e9a:	3f 71       	andi	r19, 0x1F	; 31
    7e9c:	36 27       	eor	r19, r22
    7e9e:	32 27       	eor	r19, r18
    7ea0:	28 2f       	mov	r18, r24
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
    7ea2:	c9 01       	movw	r24, r18
    7ea4:	08 95       	ret
    7ea6:	08 95       	ret
    7ea8:	08 95       	ret
    7eaa:	08 95       	ret
    7eac:	81 e0       	ldi	r24, 0x01	; 1
    7eae:	08 95       	ret
    7eb0:	81 e0       	ldi	r24, 0x01	; 1
    7eb2:	08 95       	ret

00007eb4 <sendSettings>:



// ********************* Hiden Functions ***************************************************
void sendSettings(uint8_t addr, uint8_t value)
{
    7eb4:	ef 92       	push	r14
    7eb6:	ff 92       	push	r15
    7eb8:	0f 93       	push	r16
    7eba:	1f 93       	push	r17
    7ebc:	df 93       	push	r29
    7ebe:	cf 93       	push	r28
    7ec0:	0f 92       	push	r0
    7ec2:	cd b7       	in	r28, 0x3d	; 61
    7ec4:	de b7       	in	r29, 0x3e	; 62
    7ec6:	08 2f       	mov	r16, r24
    7ec8:	16 2f       	mov	r17, r22
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    7eca:	80 e0       	ldi	r24, 0x00	; 0
    7ecc:	90 e0       	ldi	r25, 0x00	; 0
    7ece:	6a e5       	ldi	r22, 0x5A	; 90
    7ed0:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7ed4:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    7ed6:	8a e5       	ldi	r24, 0x5A	; 90
    7ed8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    7edc:	c7 01       	movw	r24, r14
    7ede:	60 2f       	mov	r22, r16
    7ee0:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7ee4:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    7ee6:	80 2f       	mov	r24, r16
    7ee8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rUstaw);
    7eec:	c7 01       	movw	r24, r14
    7eee:	60 e4       	ldi	r22, 0x40	; 64
    7ef0:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7ef4:	7c 01       	movw	r14, r24
  uartRs485SendByte(rUstaw);
    7ef6:	80 e4       	ldi	r24, 0x40	; 64
    7ef8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 1);
    7efc:	c7 01       	movw	r24, r14
    7efe:	61 e0       	ldi	r22, 0x01	; 1
    7f00:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7f04:	7c 01       	movw	r14, r24
  uartRs485SendByte(1);
    7f06:	81 e0       	ldi	r24, 0x01	; 1
    7f08:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, value);
    7f0c:	c7 01       	movw	r24, r14
    7f0e:	61 2f       	mov	r22, r17
    7f10:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7f14:	08 2f       	mov	r16, r24
  uartRs485SendByte(value);
    7f16:	81 2f       	mov	r24, r17
    7f18:	99 83       	std	Y+1, r25	; 0x01
    7f1a:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  uartRs485SendByte((uint8_t)(crc >> 8));
    7f1e:	99 81       	ldd	r25, Y+1	; 0x01
    7f20:	89 2f       	mov	r24, r25
    7f22:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    7f26:	80 2f       	mov	r24, r16
    7f28:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
}
    7f2c:	0f 90       	pop	r0
    7f2e:	cf 91       	pop	r28
    7f30:	df 91       	pop	r29
    7f32:	1f 91       	pop	r17
    7f34:	0f 91       	pop	r16
    7f36:	ff 90       	pop	r15
    7f38:	ef 90       	pop	r14
    7f3a:	08 95       	ret

00007f3c <saveSettings>:

void saveSettings(uint8_t addr)
{
    7f3c:	ef 92       	push	r14
    7f3e:	ff 92       	push	r15
    7f40:	1f 93       	push	r17
    7f42:	df 93       	push	r29
    7f44:	cf 93       	push	r28
    7f46:	0f 92       	push	r0
    7f48:	cd b7       	in	r28, 0x3d	; 61
    7f4a:	de b7       	in	r29, 0x3e	; 62
    7f4c:	18 2f       	mov	r17, r24
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    7f4e:	80 e0       	ldi	r24, 0x00	; 0
    7f50:	90 e0       	ldi	r25, 0x00	; 0
    7f52:	6a e5       	ldi	r22, 0x5A	; 90
    7f54:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7f58:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    7f5a:	8a e5       	ldi	r24, 0x5A	; 90
    7f5c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    7f60:	c7 01       	movw	r24, r14
    7f62:	61 2f       	mov	r22, r17
    7f64:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7f68:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    7f6a:	81 2f       	mov	r24, r17
    7f6c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rZapiszUstawienia);
    7f70:	c7 01       	movw	r24, r14
    7f72:	61 e4       	ldi	r22, 0x41	; 65
    7f74:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7f78:	7c 01       	movw	r14, r24
  uartRs485SendByte(rZapiszUstawienia);
    7f7a:	81 e4       	ldi	r24, 0x41	; 65
    7f7c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 0);
    7f80:	c7 01       	movw	r24, r14
    7f82:	60 e0       	ldi	r22, 0x00	; 0
    7f84:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    7f88:	18 2f       	mov	r17, r24
  uartRs485SendByte(0);
    7f8a:	80 e0       	ldi	r24, 0x00	; 0
    7f8c:	99 83       	std	Y+1, r25	; 0x01
    7f8e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  uartRs485SendByte((uint8_t)(crc >> 8));
    7f92:	99 81       	ldd	r25, Y+1	; 0x01
    7f94:	89 2f       	mov	r24, r25
    7f96:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    7f9a:	81 2f       	mov	r24, r17
    7f9c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
}
    7fa0:	0f 90       	pop	r0
    7fa2:	cf 91       	pop	r28
    7fa4:	df 91       	pop	r29
    7fa6:	1f 91       	pop	r17
    7fa8:	ff 90       	pop	r15
    7faa:	ef 90       	pop	r14
    7fac:	08 95       	ret

00007fae <rollersMemInit>:

// ************************ Rs485 API ************************************

void rollersMemInit(void)
{
  rollers = xmalloc(MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    7fae:	8e e6       	ldi	r24, 0x6E	; 110
    7fb0:	90 e0       	ldi	r25, 0x00	; 0
    7fb2:	0e 94 22 1c 	call	0x3844	; 0x3844 <xmalloc>
    7fb6:	80 93 08 32 	sts	0x3208, r24
    7fba:	90 93 09 32 	sts	0x3209, r25
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    7fbe:	fc 01       	movw	r30, r24
    7fc0:	8e e6       	ldi	r24, 0x6E	; 110
    7fc2:	df 01       	movw	r26, r30
    7fc4:	1d 92       	st	X+, r1
    7fc6:	8a 95       	dec	r24
    7fc8:	e9 f7       	brne	.-6      	; 0x7fc4 <rollersMemInit+0x16>
}
    7fca:	08 95       	ret

00007fcc <printRs485devices>:

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
    7fcc:	af 92       	push	r10
    7fce:	bf 92       	push	r11
    7fd0:	cf 92       	push	r12
    7fd2:	df 92       	push	r13
    7fd4:	ef 92       	push	r14
    7fd6:	ff 92       	push	r15
    7fd8:	0f 93       	push	r16
    7fda:	1f 93       	push	r17
    7fdc:	cf 93       	push	r28
    7fde:	df 93       	push	r29
    7fe0:	8c 01       	movw	r16, r24
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
    7fe2:	c0 91 08 32 	lds	r28, 0x3208
    7fe6:	d0 91 09 32 	lds	r29, 0x3209
    7fea:	2a e0       	ldi	r18, 0x0A	; 10
    7fec:	a2 2e       	mov	r10, r18
}

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
  uint8_t result = 0;
    7fee:	bb 24       	eor	r11, r11
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    7ff0:	91 ea       	ldi	r25, 0xA1	; 161
    7ff2:	e9 2e       	mov	r14, r25
    7ff4:	9f e0       	ldi	r25, 0x0F	; 15
    7ff6:	f9 2e       	mov	r15, r25
   //   fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    7ff8:	8f ed       	ldi	r24, 0xDF	; 223
    7ffa:	c8 2e       	mov	r12, r24
    7ffc:	8f e0       	ldi	r24, 0x0F	; 15
    7ffe:	d8 2e       	mov	r13, r24
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    8000:	89 81       	ldd	r24, Y+1	; 0x01
    8002:	88 23       	and	r24, r24
    8004:	e9 f1       	breq	.+122    	; 0x8080 <printRs485devices+0xb4>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    8006:	2d b7       	in	r18, 0x3d	; 61
    8008:	3e b7       	in	r19, 0x3e	; 62
    800a:	2a 50       	subi	r18, 0x0A	; 10
    800c:	30 40       	sbci	r19, 0x00	; 0
    800e:	2d bf       	out	0x3d, r18	; 61
    8010:	3e bf       	out	0x3e, r19	; 62
    8012:	ed b7       	in	r30, 0x3d	; 61
    8014:	fe b7       	in	r31, 0x3e	; 62
    8016:	31 96       	adiw	r30, 0x01	; 1
    8018:	ad b7       	in	r26, 0x3d	; 61
    801a:	be b7       	in	r27, 0x3e	; 62
    801c:	11 96       	adiw	r26, 0x01	; 1
    801e:	0d 93       	st	X+, r16
    8020:	1c 93       	st	X, r17
    8022:	12 97       	sbiw	r26, 0x02	; 2
    8024:	e2 82       	std	Z+2, r14	; 0x02
    8026:	f3 82       	std	Z+3, r15	; 0x03
    8028:	84 83       	std	Z+4, r24	; 0x04
    802a:	15 82       	std	Z+5, r1	; 0x05
    802c:	2a 81       	ldd	r18, Y+2	; 0x02
    802e:	30 e0       	ldi	r19, 0x00	; 0
    8030:	2f 73       	andi	r18, 0x3F	; 63
    8032:	30 70       	andi	r19, 0x00	; 0
    8034:	26 83       	std	Z+6, r18	; 0x06
    8036:	37 83       	std	Z+7, r19	; 0x07
    8038:	2b 81       	ldd	r18, Y+3	; 0x03
    803a:	30 e0       	ldi	r19, 0x00	; 0
    803c:	2f 73       	andi	r18, 0x3F	; 63
    803e:	30 70       	andi	r19, 0x00	; 0
    8040:	20 87       	std	Z+8, r18	; 0x08
    8042:	31 87       	std	Z+9, r19	; 0x09
    8044:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
   //   fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    8048:	0f 90       	pop	r0
    804a:	0f 90       	pop	r0
    804c:	0f 90       	pop	r0
    804e:	0f 90       	pop	r0
    8050:	ed b7       	in	r30, 0x3d	; 61
    8052:	fe b7       	in	r31, 0x3e	; 62
    8054:	31 96       	adiw	r30, 0x01	; 1
    8056:	ad b7       	in	r26, 0x3d	; 61
    8058:	be b7       	in	r27, 0x3e	; 62
    805a:	11 96       	adiw	r26, 0x01	; 1
    805c:	0d 93       	st	X+, r16
    805e:	1c 93       	st	X, r17
    8060:	12 97       	sbiw	r26, 0x02	; 2
    8062:	c2 82       	std	Z+2, r12	; 0x02
    8064:	d3 82       	std	Z+3, r13	; 0x03
    8066:	ce 01       	movw	r24, r28
    8068:	05 96       	adiw	r24, 0x05	; 5
    806a:	84 83       	std	Z+4, r24	; 0x04
    806c:	95 83       	std	Z+5, r25	; 0x05
    806e:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
      result++;
    8072:	b3 94       	inc	r11
    8074:	2d b7       	in	r18, 0x3d	; 61
    8076:	3e b7       	in	r19, 0x3e	; 62
    8078:	2a 5f       	subi	r18, 0xFA	; 250
    807a:	3f 4f       	sbci	r19, 0xFF	; 255
    807c:	2d bf       	out	0x3d, r18	; 61
    807e:	3e bf       	out	0x3e, r19	; 62
    8080:	aa 94       	dec	r10
{
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    8082:	11 f0       	breq	.+4      	; 0x8088 <printRs485devices+0xbc>
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
   //   fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
      result++;
    }
    rolTmp++;
    8084:	2b 96       	adiw	r28, 0x0b	; 11
    8086:	bc cf       	rjmp	.-136    	; 0x8000 <printRs485devices+0x34>
  }
  
  
  return result;
}
    8088:	8b 2d       	mov	r24, r11
    808a:	df 91       	pop	r29
    808c:	cf 91       	pop	r28
    808e:	1f 91       	pop	r17
    8090:	0f 91       	pop	r16
    8092:	ff 90       	pop	r15
    8094:	ef 90       	pop	r14
    8096:	df 90       	pop	r13
    8098:	cf 90       	pop	r12
    809a:	bf 90       	pop	r11
    809c:	af 90       	pop	r10
    809e:	08 95       	ret

000080a0 <rs485ping>:
#endif /*PRINT_RS485_DEVICE*/

uint8_t rs485ping(uint8_t devAddr)
{
    80a0:	cf 92       	push	r12
    80a2:	df 92       	push	r13
    80a4:	ef 92       	push	r14
    80a6:	ff 92       	push	r15
    80a8:	0f 93       	push	r16
    80aa:	1f 93       	push	r17
    80ac:	df 93       	push	r29
    80ae:	cf 93       	push	r28
    80b0:	00 d0       	rcall	.+0      	; 0x80b2 <rs485ping+0x12>
    80b2:	0f 92       	push	r0
    80b4:	cd b7       	in	r28, 0x3d	; 61
    80b6:	de b7       	in	r29, 0x3e	; 62
    80b8:	f8 2e       	mov	r15, r24
  takeRs485();
    80ba:	0e 94 5f 0a 	call	0x14be	; 0x14be <takeRs485>
}


void sendPing(uint8_t addr, uint8_t pingLen)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    80be:	80 e0       	ldi	r24, 0x00	; 0
    80c0:	90 e0       	ldi	r25, 0x00	; 0
    80c2:	6a e5       	ldi	r22, 0x5A	; 90
    80c4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    80c8:	8c 01       	movw	r16, r24
  uartRs485SendByte(SYNC);
    80ca:	8a e5       	ldi	r24, 0x5A	; 90
    80cc:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    80d0:	c8 01       	movw	r24, r16
    80d2:	6f 2d       	mov	r22, r15
    80d4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    80d8:	8c 01       	movw	r16, r24
  uartRs485SendByte(addr);
    80da:	8f 2d       	mov	r24, r15
    80dc:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rPING);
    80e0:	c8 01       	movw	r24, r16
    80e2:	60 e8       	ldi	r22, 0x80	; 128
    80e4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    80e8:	8c 01       	movw	r16, r24
  uartRs485SendByte(rPING);
    80ea:	80 e8       	ldi	r24, 0x80	; 128
    80ec:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, pingLen);
    80f0:	c8 01       	movw	r24, r16
    80f2:	68 e0       	ldi	r22, 0x08	; 8
    80f4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    80f8:	f8 2e       	mov	r15, r24
  uartRs485SendByte(pingLen);
    80fa:	88 e0       	ldi	r24, 0x08	; 8
    80fc:	9c 83       	std	Y+4, r25	; 0x04
    80fe:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  for (uint8_t i=0; i < pingLen; i++)
    8102:	00 e0       	ldi	r16, 0x00	; 0
    8104:	9c 81       	ldd	r25, Y+4	; 0x04
  {
    crc = _crc_xmodem_update(crc, i);
    8106:	8f 2d       	mov	r24, r15
    8108:	60 2f       	mov	r22, r16
    810a:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    810e:	f8 2e       	mov	r15, r24
    uartRs485SendByte(i);
    8110:	80 2f       	mov	r24, r16
    8112:	9c 83       	std	Y+4, r25	; 0x04
    8114:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte(rPING);

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
  
  for (uint8_t i=0; i < pingLen; i++)
    8118:	0f 5f       	subi	r16, 0xFF	; 255
    811a:	9c 81       	ldd	r25, Y+4	; 0x04
    811c:	08 30       	cpi	r16, 0x08	; 8
    811e:	99 f7       	brne	.-26     	; 0x8106 <rs485ping+0x66>
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
  }
  uartRs485SendByte((uint8_t)(crc >> 8));
    8120:	89 2f       	mov	r24, r25
    8122:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8126:	8f 2d       	mov	r24, r15
    8128:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  addr = 0;
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    812c:	8e 01       	movw	r16, r28
    812e:	0f 5f       	subi	r16, 0xFF	; 255
    8130:	1f 4f       	sbci	r17, 0xFF	; 255
    8132:	c8 01       	movw	r24, r16
    8134:	64 e1       	ldi	r22, 0x14	; 20
    8136:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    813a:	88 23       	and	r24, r24
    813c:	09 f4       	brne	.+2      	; 0x8140 <rs485ping+0xa0>
    813e:	75 c0       	rjmp	.+234    	; 0x822a <rs485ping+0x18a>
    return 1;
  
  if (data != SYNC)
    8140:	89 81       	ldd	r24, Y+1	; 0x01
    8142:	8a 35       	cpi	r24, 0x5A	; 90
    8144:	09 f0       	breq	.+2      	; 0x8148 <rs485ping+0xa8>
    8146:	73 c0       	rjmp	.+230    	; 0x822e <rs485ping+0x18e>
    return 2;
  crc = _crc_xmodem_update(0, data);
    8148:	80 e0       	ldi	r24, 0x00	; 0
    814a:	90 e0       	ldi	r25, 0x00	; 0
    814c:	6a e5       	ldi	r22, 0x5A	; 90
    814e:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8152:	7c 01       	movw	r14, r24

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    8154:	c8 01       	movw	r24, r16
    8156:	61 e0       	ldi	r22, 0x01	; 1
    8158:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    815c:	88 23       	and	r24, r24
    815e:	09 f4       	brne	.+2      	; 0x8162 <rs485ping+0xc2>
    8160:	68 c0       	rjmp	.+208    	; 0x8232 <rs485ping+0x192>
    return 3;

  if (data != 0)
    8162:	89 81       	ldd	r24, Y+1	; 0x01
    8164:	88 23       	and	r24, r24
    8166:	09 f0       	breq	.+2      	; 0x816a <rs485ping+0xca>
    8168:	66 c0       	rjmp	.+204    	; 0x8236 <rs485ping+0x196>
    return 4;
  
  crc = _crc_xmodem_update(crc, data);
    816a:	c7 01       	movw	r24, r14
    816c:	60 e0       	ldi	r22, 0x00	; 0
    816e:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8172:	7c 01       	movw	r14, r24

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    8174:	c8 01       	movw	r24, r16
    8176:	61 e0       	ldi	r22, 0x01	; 1
    8178:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    817c:	88 23       	and	r24, r24
    817e:	09 f4       	brne	.+2      	; 0x8182 <rs485ping+0xe2>
    8180:	5c c0       	rjmp	.+184    	; 0x823a <rs485ping+0x19a>
    return 5;
  if (data != rPING)
    8182:	89 81       	ldd	r24, Y+1	; 0x01
    8184:	80 38       	cpi	r24, 0x80	; 128
    8186:	09 f0       	breq	.+2      	; 0x818a <rs485ping+0xea>
    8188:	5a c0       	rjmp	.+180    	; 0x823e <rs485ping+0x19e>
    return 6;
  crc = _crc_xmodem_update(crc, data);
    818a:	c7 01       	movw	r24, r14
    818c:	60 e8       	ldi	r22, 0x80	; 128
    818e:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8192:	7c 01       	movw	r14, r24

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    8194:	c8 01       	movw	r24, r16
    8196:	61 e0       	ldi	r22, 0x01	; 1
    8198:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    819c:	88 23       	and	r24, r24
    819e:	09 f4       	brne	.+2      	; 0x81a2 <rs485ping+0x102>
    81a0:	50 c0       	rjmp	.+160    	; 0x8242 <rs485ping+0x1a2>
    return 7;
  if (data != dataLen)
    81a2:	89 81       	ldd	r24, Y+1	; 0x01
    81a4:	88 30       	cpi	r24, 0x08	; 8
    81a6:	09 f0       	breq	.+2      	; 0x81aa <rs485ping+0x10a>
    81a8:	4e c0       	rjmp	.+156    	; 0x8246 <rs485ping+0x1a6>
    return 8;
  crc = _crc_xmodem_update(crc, data);
    81aa:	c7 01       	movw	r24, r14
    81ac:	68 e0       	ldi	r22, 0x08	; 8
    81ae:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    81b2:	7c 01       	movw	r14, r24

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    81b4:	dd 24       	eor	r13, r13
  {
    if(rs485Receive(&data, 5) == pdFALSE)
    81b6:	c0 2e       	mov	r12, r16
    81b8:	01 2f       	mov	r16, r17
    81ba:	8c 2d       	mov	r24, r12
    81bc:	90 2f       	mov	r25, r16
    81be:	65 e0       	ldi	r22, 0x05	; 5
    81c0:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    81c4:	88 23       	and	r24, r24
    81c6:	21 f4       	brne	.+8      	; 0x81d0 <rs485ping+0x130>
      return 2*temp+9;
    81c8:	0d 2d       	mov	r16, r13
    81ca:	00 0f       	add	r16, r16
    81cc:	07 5f       	subi	r16, 0xF7	; 247
    81ce:	44 c0       	rjmp	.+136    	; 0x8258 <rs485ping+0x1b8>
    crc = _crc_xmodem_update(crc, data);
    81d0:	c7 01       	movw	r24, r14
    81d2:	69 81       	ldd	r22, Y+1	; 0x01
    81d4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    81d8:	7c 01       	movw	r14, r24
    if (data != temp)
    81da:	89 81       	ldd	r24, Y+1	; 0x01
    81dc:	8d 15       	cp	r24, r13
    81de:	21 f0       	breq	.+8      	; 0x81e8 <rs485ping+0x148>
      return 2*temp+10; 
    81e0:	0d 2d       	mov	r16, r13
    81e2:	00 0f       	add	r16, r16
    81e4:	06 5f       	subi	r16, 0xF6	; 246
    81e6:	38 c0       	rjmp	.+112    	; 0x8258 <rs485ping+0x1b8>
    return 8;
  crc = _crc_xmodem_update(crc, data);

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    81e8:	d3 94       	inc	r13
    81ea:	8d 2d       	mov	r24, r13
    81ec:	88 30       	cpi	r24, 0x08	; 8
    81ee:	29 f7       	brne	.-54     	; 0x81ba <rs485ping+0x11a>
      return 2*temp+10; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    81f0:	ce 01       	movw	r24, r28
    81f2:	02 96       	adiw	r24, 0x02	; 2
    81f4:	61 e0       	ldi	r22, 0x01	; 1
    81f6:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    81fa:	81 30       	cpi	r24, 0x01	; 1
    81fc:	31 f5       	brne	.+76     	; 0x824a <rs485ping+0x1aa>
    return 2*temp+11;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    81fe:	80 91 fc 31 	lds	r24, 0x31FC
    8202:	90 91 fd 31 	lds	r25, 0x31FD
    8206:	be 01       	movw	r22, r28
    8208:	6d 5f       	subi	r22, 0xFD	; 253
    820a:	7f 4f       	sbci	r23, 0xFF	; 255
    820c:	41 e0       	ldi	r20, 0x01	; 1
    820e:	50 e0       	ldi	r21, 0x00	; 0
    8210:	20 e0       	ldi	r18, 0x00	; 0
    8212:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    8216:	81 30       	cpi	r24, 0x01	; 1
    8218:	d1 f4       	brne	.+52     	; 0x824e <rs485ping+0x1ae>
    return 2*temp+12;

  if (crcHi != (uint8_t)(crc>>8))
    821a:	8a 81       	ldd	r24, Y+2	; 0x02
    821c:	8f 15       	cp	r24, r15
    821e:	c9 f4       	brne	.+50     	; 0x8252 <rs485ping+0x1b2>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    8220:	8b 81       	ldd	r24, Y+3	; 0x03
    8222:	8e 15       	cp	r24, r14
    8224:	c1 f0       	breq	.+48     	; 0x8256 <rs485ping+0x1b6>
    return 255;
    8226:	0f ef       	ldi	r16, 0xFF	; 255
    8228:	17 c0       	rjmp	.+46     	; 0x8258 <rs485ping+0x1b8>
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    return 1;
    822a:	01 e0       	ldi	r16, 0x01	; 1
    822c:	15 c0       	rjmp	.+42     	; 0x8258 <rs485ping+0x1b8>
  
  if (data != SYNC)
    return 2;
    822e:	02 e0       	ldi	r16, 0x02	; 2
    8230:	13 c0       	rjmp	.+38     	; 0x8258 <rs485ping+0x1b8>
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    return 3;
    8232:	03 e0       	ldi	r16, 0x03	; 3
    8234:	11 c0       	rjmp	.+34     	; 0x8258 <rs485ping+0x1b8>

  if (data != 0)
    return 4;
    8236:	04 e0       	ldi	r16, 0x04	; 4
    8238:	0f c0       	rjmp	.+30     	; 0x8258 <rs485ping+0x1b8>
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    return 5;
    823a:	05 e0       	ldi	r16, 0x05	; 5
    823c:	0d c0       	rjmp	.+26     	; 0x8258 <rs485ping+0x1b8>
  if (data != rPING)
    return 6;
    823e:	06 e0       	ldi	r16, 0x06	; 6
    8240:	0b c0       	rjmp	.+22     	; 0x8258 <rs485ping+0x1b8>
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
    8242:	07 e0       	ldi	r16, 0x07	; 7
    8244:	09 c0       	rjmp	.+18     	; 0x8258 <rs485ping+0x1b8>
  if (data != dataLen)
    return 8;
    8246:	08 e0       	ldi	r16, 0x08	; 8
    8248:	07 c0       	rjmp	.+14     	; 0x8258 <rs485ping+0x1b8>
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    return 2*temp+11;
    824a:	0b e1       	ldi	r16, 0x1B	; 27
    824c:	05 c0       	rjmp	.+10     	; 0x8258 <rs485ping+0x1b8>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    return 2*temp+12;
    824e:	0c e1       	ldi	r16, 0x1C	; 28
    8250:	03 c0       	rjmp	.+6      	; 0x8258 <rs485ping+0x1b8>

  if (crcHi != (uint8_t)(crc>>8))
    return 254;
    8252:	0e ef       	ldi	r16, 0xFE	; 254
    8254:	01 c0       	rjmp	.+2      	; 0x8258 <rs485ping+0x1b8>
  if (crcLo != (uint8_t)(crc & 0xFF))
    return 255;
  
  return 0; 
    8256:	00 e0       	ldi	r16, 0x00	; 0
{
  takeRs485();
  const int len = 8;    
  sendPing(devAddr, len);
  uint8_t result = receivePong(devAddr, len);
  flushRs485RecBuffer();
    8258:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>

  releaseRs485();
    825c:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
  return result;
}
    8260:	80 2f       	mov	r24, r16
    8262:	24 96       	adiw	r28, 0x04	; 4
    8264:	cd bf       	out	0x3d, r28	; 61
    8266:	de bf       	out	0x3e, r29	; 62
    8268:	cf 91       	pop	r28
    826a:	df 91       	pop	r29
    826c:	1f 91       	pop	r17
    826e:	0f 91       	pop	r16
    8270:	ff 90       	pop	r15
    8272:	ef 90       	pop	r14
    8274:	df 90       	pop	r13
    8276:	cf 90       	pop	r12
    8278:	08 95       	ret

0000827a <rs485rollerHello>:

uint8_t rs485rollerHello(uint8_t devAddr)
{
    827a:	cf 92       	push	r12
    827c:	df 92       	push	r13
    827e:	ef 92       	push	r14
    8280:	ff 92       	push	r15
    8282:	0f 93       	push	r16
    8284:	1f 93       	push	r17
    8286:	df 93       	push	r29
    8288:	cf 93       	push	r28
    828a:	00 d0       	rcall	.+0      	; 0x828c <rs485rollerHello+0x12>
    828c:	0f 92       	push	r0
    828e:	cd b7       	in	r28, 0x3d	; 61
    8290:	de b7       	in	r29, 0x3e	; 62
    8292:	c8 2e       	mov	r12, r24
    {
      tmp->state &= (~NOT_DETECTED);
      tmp->address = devAddr;
    }
    else
      return 1;
    8294:	e0 91 08 32 	lds	r30, 0x3208
    8298:	f0 91 09 32 	lds	r31, 0x3209
uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    829c:	8a e0       	ldi	r24, 0x0A	; 10
  return result;
}

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
    829e:	00 e0       	ldi	r16, 0x00	; 0
    82a0:	10 e0       	ldi	r17, 0x00	; 0
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    82a2:	91 81       	ldd	r25, Z+1	; 0x01
    82a4:	9c 15       	cp	r25, r12
    82a6:	11 f4       	brne	.+4      	; 0x82ac <rs485rollerHello+0x32>
      tmp = &rollers[i];
    82a8:	0e 2f       	mov	r16, r30
    82aa:	1f 2f       	mov	r17, r31
uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    82ac:	81 50       	subi	r24, 0x01	; 1
    82ae:	3b 96       	adiw	r30, 0x0b	; 11

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    82b0:	88 23       	and	r24, r24
    82b2:	b9 f7       	brne	.-18     	; 0x82a2 <rs485rollerHello+0x28>
    if (rollers[i].address == devAddr)
      tmp = &rollers[i];
    
  if (rs485ping(devAddr)==0)
    82b4:	8c 2d       	mov	r24, r12
    82b6:	0e 94 50 40 	call	0x80a0	; 0x80a0 <rs485ping>
    82ba:	88 23       	and	r24, r24
    82bc:	f1 f4       	brne	.+60     	; 0x82fa <rs485rollerHello+0x80>
  {
    if (tmp == NULL)
    82be:	01 15       	cp	r16, r1
    82c0:	11 05       	cpc	r17, r1
    82c2:	79 f4       	brne	.+30     	; 0x82e2 <rs485rollerHello+0x68>
    82c4:	e0 91 08 32 	lds	r30, 0x3208
    82c8:	f0 91 09 32 	lds	r31, 0x3209
    82cc:	8f 01       	movw	r16, r30
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
      {
        if (rollers[i].address == 0)
    82ce:	91 81       	ldd	r25, Z+1	; 0x01
    82d0:	99 23       	and	r25, r25
    82d2:	11 f4       	brne	.+4      	; 0x82d8 <rs485rollerHello+0x5e>
        {
          tmp = &rollers[i];
          tmp->address = devAddr;
    82d4:	c1 82       	std	Z+1, r12	; 0x01
          break;
    82d6:	05 c0       	rjmp	.+10     	; 0x82e2 <rs485rollerHello+0x68>
    
  if (rs485ping(devAddr)==0)
  {
    if (tmp == NULL)
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    82d8:	8f 5f       	subi	r24, 0xFF	; 255
    82da:	3b 96       	adiw	r30, 0x0b	; 11
    82dc:	8a 30       	cpi	r24, 0x0A	; 10
    82de:	b1 f7       	brne	.-20     	; 0x82cc <rs485rollerHello+0x52>
    82e0:	e2 c0       	rjmp	.+452    	; 0x84a6 <rs485rollerHello+0x22c>
          tmp->address = devAddr;
          break;
        }
      }
    }
    if (tmp != NULL)
    82e2:	01 15       	cp	r16, r1
    82e4:	11 05       	cpc	r17, r1
    82e6:	09 f4       	brne	.+2      	; 0x82ea <rs485rollerHello+0x70>
    82e8:	de c0       	rjmp	.+444    	; 0x84a6 <rs485rollerHello+0x22c>
    {
      tmp->state &= (~NOT_DETECTED);
    82ea:	d8 01       	movw	r26, r16
    82ec:	8c 91       	ld	r24, X
    82ee:	8e 7f       	andi	r24, 0xFE	; 254
    82f0:	8c 93       	st	X, r24
      tmp->address = devAddr;
    82f2:	11 96       	adiw	r26, 0x01	; 1
    82f4:	cc 92       	st	X, r12
    82f6:	11 97       	sbiw	r26, 0x01	; 1
    82f8:	0c c0       	rjmp	.+24     	; 0x8312 <rs485rollerHello+0x98>
    else
      return 1;
  }
  else
  {
    if (tmp != NULL)
    82fa:	01 15       	cp	r16, r1
    82fc:	11 05       	cpc	r17, r1
    82fe:	49 f0       	breq	.+18     	; 0x8312 <rs485rollerHello+0x98>
    {
      if (tmp->state & NOT_DETECTED)
    8300:	f8 01       	movw	r30, r16
    8302:	80 81       	ld	r24, Z
    8304:	80 fd       	sbrc	r24, 0
      {
        tmp->address = 0;
    8306:	11 82       	std	Z+1, r1	; 0x01
      }
      tmp->state |= NOT_DETECTED;
    8308:	81 60       	ori	r24, 0x01	; 1
    830a:	d8 01       	movw	r26, r16
    830c:	8c 93       	st	X, r24
      return 2;
    830e:	82 e0       	ldi	r24, 0x02	; 2
    8310:	cb c0       	rjmp	.+406    	; 0x84a8 <rs485rollerHello+0x22e>
    }
  }
  
  takeRs485();
    8312:	0e 94 5f 0a 	call	0x14be	; 0x14be <takeRs485>
  return 0; 
}

static void    sendHello(uint8_t addr)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    8316:	80 e0       	ldi	r24, 0x00	; 0
    8318:	90 e0       	ldi	r25, 0x00	; 0
    831a:	6a e5       	ldi	r22, 0x5A	; 90
    831c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8320:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    8322:	8a e5       	ldi	r24, 0x5A	; 90
    8324:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    8328:	c7 01       	movw	r24, r14
    832a:	6c 2d       	mov	r22, r12
    832c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8330:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    8332:	8c 2d       	mov	r24, r12
    8334:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rHELLO);
    8338:	c7 01       	movw	r24, r14
    833a:	62 e8       	ldi	r22, 0x82	; 130
    833c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8340:	7c 01       	movw	r14, r24
  uartRs485SendByte(rHELLO);
    8342:	82 e8       	ldi	r24, 0x82	; 130
    8344:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 0);
    8348:	c7 01       	movw	r24, r14
    834a:	60 e0       	ldi	r22, 0x00	; 0
    834c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8350:	f8 2e       	mov	r15, r24
  uartRs485SendByte(0);
    8352:	80 e0       	ldi	r24, 0x00	; 0
    8354:	9c 83       	std	Y+4, r25	; 0x04
    8356:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc >> 8));
    835a:	9c 81       	ldd	r25, Y+4	; 0x04
    835c:	89 2f       	mov	r24, r25
    835e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8362:	8f 2d       	mov	r24, r15
    8364:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
static uint8_t receiveHello(uint8_t* response, uint8_t maxSize)
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    8368:	7e 01       	movw	r14, r28
    836a:	08 94       	sec
    836c:	e1 1c       	adc	r14, r1
    836e:	f1 1c       	adc	r15, r1
    8370:	c7 01       	movw	r24, r14
    8372:	64 e1       	ldi	r22, 0x14	; 20
    8374:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8378:	88 23       	and	r24, r24
    837a:	09 f4       	brne	.+2      	; 0x837e <rs485rollerHello+0x104>
    837c:	76 c0       	rjmp	.+236    	; 0x846a <rs485rollerHello+0x1f0>
    return 8;
  
  if (data != SYNC)
    837e:	89 81       	ldd	r24, Y+1	; 0x01
    8380:	8a 35       	cpi	r24, 0x5A	; 90
    8382:	09 f0       	breq	.+2      	; 0x8386 <rs485rollerHello+0x10c>
    8384:	74 c0       	rjmp	.+232    	; 0x846e <rs485rollerHello+0x1f4>
    return 2;
  crc = _crc_xmodem_update(0, data);
    8386:	80 e0       	ldi	r24, 0x00	; 0
    8388:	90 e0       	ldi	r25, 0x00	; 0
    838a:	6a e5       	ldi	r22, 0x5A	; 90
    838c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8390:	6c 01       	movw	r12, r24

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    8392:	c7 01       	movw	r24, r14
    8394:	61 e0       	ldi	r22, 0x01	; 1
    8396:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    839a:	88 23       	and	r24, r24
    839c:	09 f4       	brne	.+2      	; 0x83a0 <rs485rollerHello+0x126>
    839e:	69 c0       	rjmp	.+210    	; 0x8472 <rs485rollerHello+0x1f8>
    return 3;

  if (data != 0)
    83a0:	89 81       	ldd	r24, Y+1	; 0x01
    83a2:	88 23       	and	r24, r24
    83a4:	09 f0       	breq	.+2      	; 0x83a8 <rs485rollerHello+0x12e>
    83a6:	67 c0       	rjmp	.+206    	; 0x8476 <rs485rollerHello+0x1fc>
    return 4;
  
  crc = _crc_xmodem_update(crc, data);
    83a8:	c6 01       	movw	r24, r12
    83aa:	60 e0       	ldi	r22, 0x00	; 0
    83ac:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    83b0:	6c 01       	movw	r12, r24

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    83b2:	c7 01       	movw	r24, r14
    83b4:	61 e0       	ldi	r22, 0x01	; 1
    83b6:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    83ba:	88 23       	and	r24, r24
    83bc:	09 f4       	brne	.+2      	; 0x83c0 <rs485rollerHello+0x146>
    83be:	5d c0       	rjmp	.+186    	; 0x847a <rs485rollerHello+0x200>
    return 5;
  if (data != rHELLO)
    83c0:	89 81       	ldd	r24, Y+1	; 0x01
    83c2:	82 38       	cpi	r24, 0x82	; 130
    83c4:	09 f0       	breq	.+2      	; 0x83c8 <rs485rollerHello+0x14e>
    83c6:	5b c0       	rjmp	.+182    	; 0x847e <rs485rollerHello+0x204>
    return 6;
  crc = _crc_xmodem_update(crc, data);
    83c8:	c6 01       	movw	r24, r12
    83ca:	62 e8       	ldi	r22, 0x82	; 130
    83cc:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    83d0:	6c 01       	movw	r12, r24

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    83d2:	c7 01       	movw	r24, r14
    83d4:	61 e0       	ldi	r22, 0x01	; 1
    83d6:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    83da:	88 23       	and	r24, r24
    83dc:	09 f4       	brne	.+2      	; 0x83e0 <rs485rollerHello+0x166>
    83de:	51 c0       	rjmp	.+162    	; 0x8482 <rs485rollerHello+0x208>
    return 7;
  if (data > maxSize)
    83e0:	69 81       	ldd	r22, Y+1	; 0x01
    83e2:	69 30       	cpi	r22, 0x09	; 9
    83e4:	08 f0       	brcs	.+2      	; 0x83e8 <rs485rollerHello+0x16e>
    83e6:	4f c0       	rjmp	.+158    	; 0x8486 <rs485rollerHello+0x20c>
    }
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
    83e8:	0e 5f       	subi	r16, 0xFE	; 254
    83ea:	1f 4f       	sbci	r17, 0xFF	; 255
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
  if (data > maxSize)
    return 1;
  
  crc = _crc_xmodem_update(crc, data);
    83ec:	c6 01       	movw	r24, r12
    83ee:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    83f2:	e8 2e       	mov	r14, r24
    83f4:	c9 2e       	mov	r12, r25
  memset(response, 0, maxSize);
    83f6:	88 e0       	ldi	r24, 0x08	; 8
    83f8:	d8 01       	movw	r26, r16
    83fa:	1d 92       	st	X+, r1
    83fc:	8a 95       	dec	r24
    83fe:	e9 f7       	brne	.-6      	; 0x83fa <rs485rollerHello+0x180>
  maxSize = data;
    8400:	f9 80       	ldd	r15, Y+1	; 0x01
  
  for (data=0; data < maxSize; data++)
    8402:	19 82       	std	Y+1, r1	; 0x01
    8404:	12 c0       	rjmp	.+36     	; 0x842a <rs485rollerHello+0x1b0>
  {
    if(rs485Receive(response, 5) == pdFALSE)
    8406:	c8 01       	movw	r24, r16
    8408:	65 e0       	ldi	r22, 0x05	; 5
    840a:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    840e:	88 23       	and	r24, r24
    8410:	e1 f1       	breq	.+120    	; 0x848a <rs485rollerHello+0x210>
      return 20;
    crc = _crc_xmodem_update(crc, *((uint8_t *)(response)));
    8412:	8e 2d       	mov	r24, r14
    8414:	9c 2d       	mov	r25, r12
    8416:	f8 01       	movw	r30, r16
    8418:	61 91       	ld	r22, Z+
    841a:	8f 01       	movw	r16, r30
    841c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8420:	e8 2e       	mov	r14, r24
    8422:	c9 2e       	mov	r12, r25
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
    8424:	89 81       	ldd	r24, Y+1	; 0x01
    8426:	8f 5f       	subi	r24, 0xFF	; 255
    8428:	89 83       	std	Y+1, r24	; 0x01
    842a:	89 81       	ldd	r24, Y+1	; 0x01
    842c:	8f 15       	cp	r24, r15
    842e:	58 f3       	brcs	.-42     	; 0x8406 <rs485rollerHello+0x18c>
    response++; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    8430:	ce 01       	movw	r24, r28
    8432:	02 96       	adiw	r24, 0x02	; 2
    8434:	61 e0       	ldi	r22, 0x01	; 1
    8436:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    843a:	81 30       	cpi	r24, 0x01	; 1
    843c:	41 f5       	brne	.+80     	; 0x848e <rs485rollerHello+0x214>
    return 21;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    843e:	80 91 fc 31 	lds	r24, 0x31FC
    8442:	90 91 fd 31 	lds	r25, 0x31FD
    8446:	be 01       	movw	r22, r28
    8448:	6d 5f       	subi	r22, 0xFD	; 253
    844a:	7f 4f       	sbci	r23, 0xFF	; 255
    844c:	41 e0       	ldi	r20, 0x01	; 1
    844e:	50 e0       	ldi	r21, 0x00	; 0
    8450:	20 e0       	ldi	r18, 0x00	; 0
    8452:	0e 94 c2 4e 	call	0x9d84	; 0x9d84 <xQueueGenericReceive>
    8456:	81 30       	cpi	r24, 0x01	; 1
    8458:	e1 f4       	brne	.+56     	; 0x8492 <rs485rollerHello+0x218>
    return 22;

  if (crcHi != (uint8_t)(crc>>8))
    845a:	8a 81       	ldd	r24, Y+2	; 0x02
    845c:	8c 15       	cp	r24, r12
    845e:	d9 f4       	brne	.+54     	; 0x8496 <rs485rollerHello+0x21c>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    8460:	8b 81       	ldd	r24, Y+3	; 0x03
    8462:	8e 15       	cp	r24, r14
    8464:	d1 f0       	breq	.+52     	; 0x849a <rs485rollerHello+0x220>
    return 255;
    8466:	8f ef       	ldi	r24, 0xFF	; 255
    8468:	19 c0       	rjmp	.+50     	; 0x849c <rs485rollerHello+0x222>
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    return 8;
    846a:	88 e0       	ldi	r24, 0x08	; 8
    846c:	17 c0       	rjmp	.+46     	; 0x849c <rs485rollerHello+0x222>
  
  if (data != SYNC)
    return 2;
    846e:	82 e0       	ldi	r24, 0x02	; 2
    8470:	15 c0       	rjmp	.+42     	; 0x849c <rs485rollerHello+0x222>
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    return 3;
    8472:	83 e0       	ldi	r24, 0x03	; 3
    8474:	13 c0       	rjmp	.+38     	; 0x849c <rs485rollerHello+0x222>

  if (data != 0)
    return 4;
    8476:	84 e0       	ldi	r24, 0x04	; 4
    8478:	11 c0       	rjmp	.+34     	; 0x849c <rs485rollerHello+0x222>
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    return 5;
    847a:	85 e0       	ldi	r24, 0x05	; 5
    847c:	0f c0       	rjmp	.+30     	; 0x849c <rs485rollerHello+0x222>
  if (data != rHELLO)
    return 6;
    847e:	86 e0       	ldi	r24, 0x06	; 6
    8480:	0d c0       	rjmp	.+26     	; 0x849c <rs485rollerHello+0x222>
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
    8482:	87 e0       	ldi	r24, 0x07	; 7
    8484:	0b c0       	rjmp	.+22     	; 0x849c <rs485rollerHello+0x222>
  if (data > maxSize)
    return 1;
    8486:	81 e0       	ldi	r24, 0x01	; 1
    8488:	09 c0       	rjmp	.+18     	; 0x849c <rs485rollerHello+0x222>
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
  {
    if(rs485Receive(response, 5) == pdFALSE)
      return 20;
    848a:	84 e1       	ldi	r24, 0x14	; 20
    848c:	07 c0       	rjmp	.+14     	; 0x849c <rs485rollerHello+0x222>
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    return 21;
    848e:	85 e1       	ldi	r24, 0x15	; 21
    8490:	05 c0       	rjmp	.+10     	; 0x849c <rs485rollerHello+0x222>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    return 22;
    8492:	86 e1       	ldi	r24, 0x16	; 22
    8494:	03 c0       	rjmp	.+6      	; 0x849c <rs485rollerHello+0x222>

  if (crcHi != (uint8_t)(crc>>8))
    return 254;
    8496:	8e ef       	ldi	r24, 0xFE	; 254
    8498:	01 c0       	rjmp	.+2      	; 0x849c <rs485rollerHello+0x222>
  if (crcLo != (uint8_t)(crc & 0xFF))
    return 255;
  
  return 0; 
    849a:	80 e0       	ldi	r24, 0x00	; 0
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
    849c:	8c 83       	std	Y+4, r24	; 0x04
    849e:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
  return result;
    84a2:	8c 81       	ldd	r24, Y+4	; 0x04
    84a4:	01 c0       	rjmp	.+2      	; 0x84a8 <rs485rollerHello+0x22e>
    {
      tmp->state &= (~NOT_DETECTED);
      tmp->address = devAddr;
    }
    else
      return 1;
    84a6:	81 e0       	ldi	r24, 0x01	; 1
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
  return result;
}
    84a8:	24 96       	adiw	r28, 0x04	; 4
    84aa:	cd bf       	out	0x3d, r28	; 61
    84ac:	de bf       	out	0x3e, r29	; 62
    84ae:	cf 91       	pop	r28
    84b0:	df 91       	pop	r29
    84b2:	1f 91       	pop	r17
    84b4:	0f 91       	pop	r16
    84b6:	ff 90       	pop	r15
    84b8:	ef 90       	pop	r14
    84ba:	df 90       	pop	r13
    84bc:	cf 90       	pop	r12
    84be:	08 95       	ret

000084c0 <rs485xModemFlash>:


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
    84c0:	4f 92       	push	r4
    84c2:	5f 92       	push	r5
    84c4:	7f 92       	push	r7
    84c6:	8f 92       	push	r8
    84c8:	9f 92       	push	r9
    84ca:	af 92       	push	r10
    84cc:	bf 92       	push	r11
    84ce:	cf 92       	push	r12
    84d0:	df 92       	push	r13
    84d2:	ef 92       	push	r14
    84d4:	ff 92       	push	r15
    84d6:	0f 93       	push	r16
    84d8:	1f 93       	push	r17
    84da:	df 93       	push	r29
    84dc:	cf 93       	push	r28
    84de:	00 d0       	rcall	.+0      	; 0x84e0 <rs485xModemFlash+0x20>
    84e0:	cd b7       	in	r28, 0x3d	; 61
    84e2:	de b7       	in	r29, 0x3e	; 62
    84e4:	2c 01       	movw	r4, r24
    84e6:	c6 2e       	mov	r12, r22
    84e8:	8a 01       	movw	r16, r20
  uint8_t  blad = 0;
  uint8_t  data;
  uint8_t  nrBloku;
  uint8_t  lRetransmisji;
  
  takeRs485();                                  // Zajmowanie magistrali Rs485
    84ea:	0e 94 5f 0a 	call	0x14be	; 0x14be <takeRs485>

  // Wysyłanie polecenia restartu
  crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    84ee:	80 e0       	ldi	r24, 0x00	; 0
    84f0:	90 e0       	ldi	r25, 0x00	; 0
    84f2:	6a e5       	ldi	r22, 0x5A	; 90
    84f4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    84f8:	7c 01       	movw	r14, r24
    84fa:	8a e5       	ldi	r24, 0x5A	; 90
    84fc:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8500:	c7 01       	movw	r24, r14
    8502:	6c 2d       	mov	r22, r12
    8504:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8508:	7c 01       	movw	r14, r24
    850a:	8c 2d       	mov	r24, r12
    850c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    8510:	c7 01       	movw	r24, r14
    8512:	61 e8       	ldi	r22, 0x81	; 129
    8514:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8518:	7c 01       	movw	r14, r24
    851a:	81 e8       	ldi	r24, 0x81	; 129
    851c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    8520:	c7 01       	movw	r24, r14
    8522:	61 e0       	ldi	r22, 0x01	; 1
    8524:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8528:	7c 01       	movw	r14, r24
    852a:	81 e0       	ldi	r24, 0x01	; 1
    852c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8530:	c7 01       	movw	r24, r14
    8532:	6c 2d       	mov	r22, r12
    8534:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8538:	e8 2e       	mov	r14, r24
    853a:	8c 2d       	mov	r24, r12
    853c:	9b 83       	std	Y+3, r25	; 0x03
    853e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc>>8));
    8542:	9b 81       	ldd	r25, Y+3	; 0x03
    8544:	89 2f       	mov	r24, r25
    8546:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    854a:	8e 2d       	mov	r24, r14
    854c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
    8550:	ce 01       	movw	r24, r28
    8552:	01 96       	adiw	r24, 0x01	; 1
    8554:	64 e6       	ldi	r22, 0x64	; 100
    8556:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    855a:	81 30       	cpi	r24, 0x01	; 1
    855c:	c1 f0       	breq	.+48     	; 0x858e <rs485xModemFlash+0xce>
  {
    blad = 1;                                  // Timeout
    if (debugStr != NULL)
    855e:	01 15       	cp	r16, r1
    8560:	11 05       	cpc	r17, r1
    8562:	b9 f0       	breq	.+46     	; 0x8592 <rs485xModemFlash+0xd2>
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
    8564:	00 d0       	rcall	.+0      	; 0x8566 <rs485xModemFlash+0xa6>
    8566:	0f 92       	push	r0
    8568:	ad b7       	in	r26, 0x3d	; 61
    856a:	be b7       	in	r27, 0x3e	; 62
    856c:	11 96       	adiw	r26, 0x01	; 1
    856e:	0d 93       	st	X+, r16
    8570:	1c 93       	st	X, r17
    8572:	12 97       	sbiw	r26, 0x02	; 2
    8574:	86 e4       	ldi	r24, 0x46	; 70
    8576:	90 e1       	ldi	r25, 0x10	; 16
    8578:	13 96       	adiw	r26, 0x03	; 3
    857a:	8d 93       	st	X+, r24
    857c:	9c 93       	st	X, r25
    857e:	14 97       	sbiw	r26, 0x04	; 4
    8580:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    8584:	0f 90       	pop	r0
    8586:	0f 90       	pop	r0
    8588:	0f 90       	pop	r0
    858a:	0f 90       	pop	r0
    858c:	02 c0       	rjmp	.+4      	; 0x8592 <rs485xModemFlash+0xd2>


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
  uint16_t crc;
  uint8_t  blad = 0;
    858e:	aa 24       	eor	r10, r10
    8590:	02 c0       	rjmp	.+4      	; 0x8596 <rs485xModemFlash+0xd6>

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
  {
    blad = 1;                                  // Timeout
    8592:	aa 24       	eor	r10, r10
    8594:	a3 94       	inc	r10
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
  }
  crc = _crc_xmodem_update(0, data);
    8596:	80 e0       	ldi	r24, 0x00	; 0
    8598:	90 e0       	ldi	r25, 0x00	; 0
    859a:	69 81       	ldd	r22, Y+1	; 0x01
    859c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    85a0:	7c 01       	movw	r14, r24
 
  if ((blad == 0) && (data == 'C'))
    85a2:	aa 20       	and	r10, r10
    85a4:	c1 f4       	brne	.+48     	; 0x85d6 <rs485xModemFlash+0x116>
    85a6:	89 81       	ldd	r24, Y+1	; 0x01
    85a8:	83 34       	cpi	r24, 0x43	; 67
    85aa:	a9 f4       	brne	.+42     	; 0x85d6 <rs485xModemFlash+0x116>
  {
    blad = 253;                                //Na urządzeniu jest wgrany tylko bootloader
    if (debugStr != NULL)
    85ac:	01 15       	cp	r16, r1
    85ae:	11 05       	cpc	r17, r1
    85b0:	09 f4       	brne	.+2      	; 0x85b4 <rs485xModemFlash+0xf4>
    85b2:	8f c0       	rjmp	.+286    	; 0x86d2 <rs485xModemFlash+0x212>
      fprintf_P(debugStr, PSTR("na urzadzeniu wgrany jest tylko bootloader\r\n"));    
    85b4:	00 d0       	rcall	.+0      	; 0x85b6 <rs485xModemFlash+0xf6>
    85b6:	0f 92       	push	r0
    85b8:	ed b7       	in	r30, 0x3d	; 61
    85ba:	fe b7       	in	r31, 0x3e	; 62
    85bc:	01 83       	std	Z+1, r16	; 0x01
    85be:	12 83       	std	Z+2, r17	; 0x02
    85c0:	89 e1       	ldi	r24, 0x19	; 25
    85c2:	90 e1       	ldi	r25, 0x10	; 16
    85c4:	83 83       	std	Z+3, r24	; 0x03
    85c6:	94 83       	std	Z+4, r25	; 0x04
    85c8:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    85cc:	0f 90       	pop	r0
    85ce:	0f 90       	pop	r0
    85d0:	0f 90       	pop	r0
    85d2:	0f 90       	pop	r0
    85d4:	7e c0       	rjmp	.+252    	; 0x86d2 <rs485xModemFlash+0x212>
  }
  else
  {
    if (data != SYNC)
    85d6:	89 81       	ldd	r24, Y+1	; 0x01
    85d8:	8a 35       	cpi	r24, 0x5A	; 90
    85da:	09 f0       	breq	.+2      	; 0x85de <rs485xModemFlash+0x11e>
    85dc:	75 c0       	rjmp	.+234    	; 0x86c8 <rs485xModemFlash+0x208>
      blad = 2;
  }
 
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
    85de:	aa 20       	and	r10, r10
    85e0:	09 f0       	breq	.+2      	; 0x85e4 <rs485xModemFlash+0x124>
    85e2:	72 c0       	rjmp	.+228    	; 0x86c8 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    85e4:	ce 01       	movw	r24, r28
    85e6:	01 96       	adiw	r24, 0x01	; 1
    85e8:	61 e0       	ldi	r22, 0x01	; 1
    85ea:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    85ee:	81 30       	cpi	r24, 0x01	; 1
    85f0:	21 f4       	brne	.+8      	; 0x85fa <rs485xModemFlash+0x13a>
      blad = 3;
    else
    {
      if (data != 0)
    85f2:	89 81       	ldd	r24, Y+1	; 0x01
    85f4:	88 23       	and	r24, r24
    85f6:	21 f4       	brne	.+8      	; 0x8600 <rs485xModemFlash+0x140>
    85f8:	05 c0       	rjmp	.+10     	; 0x8604 <rs485xModemFlash+0x144>
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 3;
    85fa:	33 e0       	ldi	r19, 0x03	; 3
    85fc:	a3 2e       	mov	r10, r19
    85fe:	02 c0       	rjmp	.+4      	; 0x8604 <rs485xModemFlash+0x144>
    else
    {
      if (data != 0)
        blad = 4;
    8600:	24 e0       	ldi	r18, 0x04	; 4
    8602:	a2 2e       	mov	r10, r18
    }
    crc = _crc_xmodem_update(crc, data);
    8604:	c7 01       	movw	r24, r14
    8606:	69 81       	ldd	r22, Y+1	; 0x01
    8608:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    860c:	7c 01       	movw	r14, r24
  }
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
    860e:	aa 20       	and	r10, r10
    8610:	09 f0       	breq	.+2      	; 0x8614 <rs485xModemFlash+0x154>
    8612:	5a c0       	rjmp	.+180    	; 0x86c8 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8614:	ce 01       	movw	r24, r28
    8616:	01 96       	adiw	r24, 0x01	; 1
    8618:	61 e0       	ldi	r22, 0x01	; 1
    861a:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    861e:	81 30       	cpi	r24, 0x01	; 1
    8620:	21 f4       	brne	.+8      	; 0x862a <rs485xModemFlash+0x16a>
      blad = 5;
    else
    {
      if (data != rFLASH)
    8622:	89 81       	ldd	r24, Y+1	; 0x01
    8624:	81 38       	cpi	r24, 0x81	; 129
    8626:	21 f4       	brne	.+8      	; 0x8630 <rs485xModemFlash+0x170>
    8628:	05 c0       	rjmp	.+10     	; 0x8634 <rs485xModemFlash+0x174>
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 5;
    862a:	95 e0       	ldi	r25, 0x05	; 5
    862c:	a9 2e       	mov	r10, r25
    862e:	02 c0       	rjmp	.+4      	; 0x8634 <rs485xModemFlash+0x174>
    else
    {
      if (data != rFLASH)
        blad = 6;
    8630:	86 e0       	ldi	r24, 0x06	; 6
    8632:	a8 2e       	mov	r10, r24
    }
    crc = _crc_xmodem_update(crc, data);
    8634:	c7 01       	movw	r24, r14
    8636:	69 81       	ldd	r22, Y+1	; 0x01
    8638:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    863c:	7c 01       	movw	r14, r24
  }
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
    863e:	aa 20       	and	r10, r10
    8640:	09 f0       	breq	.+2      	; 0x8644 <rs485xModemFlash+0x184>
    8642:	42 c0       	rjmp	.+132    	; 0x86c8 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8644:	ce 01       	movw	r24, r28
    8646:	01 96       	adiw	r24, 0x01	; 1
    8648:	61 e0       	ldi	r22, 0x01	; 1
    864a:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    864e:	81 30       	cpi	r24, 0x01	; 1
    8650:	21 f4       	brne	.+8      	; 0x865a <rs485xModemFlash+0x19a>
      blad = 7;
    else
    {
      if (data != 1)
    8652:	89 81       	ldd	r24, Y+1	; 0x01
    8654:	81 30       	cpi	r24, 0x01	; 1
    8656:	21 f4       	brne	.+8      	; 0x8660 <rs485xModemFlash+0x1a0>
    8658:	05 c0       	rjmp	.+10     	; 0x8664 <rs485xModemFlash+0x1a4>
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 7;
    865a:	b7 e0       	ldi	r27, 0x07	; 7
    865c:	ab 2e       	mov	r10, r27
    865e:	02 c0       	rjmp	.+4      	; 0x8664 <rs485xModemFlash+0x1a4>
    else
    {
      if (data != 1)
        blad = 8;
    8660:	a8 e0       	ldi	r26, 0x08	; 8
    8662:	aa 2e       	mov	r10, r26
    }
    crc = _crc_xmodem_update(crc, data);
    8664:	c7 01       	movw	r24, r14
    8666:	69 81       	ldd	r22, Y+1	; 0x01
    8668:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    866c:	7c 01       	movw	r14, r24
  }
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
    866e:	aa 20       	and	r10, r10
    8670:	59 f5       	brne	.+86     	; 0x86c8 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    8672:	ce 01       	movw	r24, r28
    8674:	01 96       	adiw	r24, 0x01	; 1
    8676:	61 e0       	ldi	r22, 0x01	; 1
    8678:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    867c:	81 30       	cpi	r24, 0x01	; 1
    867e:	21 f4       	brne	.+8      	; 0x8688 <rs485xModemFlash+0x1c8>
      blad = 9;
    else
    {
      if (data != devAddr)
    8680:	89 81       	ldd	r24, Y+1	; 0x01
    8682:	8c 15       	cp	r24, r12
    8684:	21 f4       	brne	.+8      	; 0x868e <rs485xModemFlash+0x1ce>
    8686:	05 c0       	rjmp	.+10     	; 0x8692 <rs485xModemFlash+0x1d2>
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 9;
    8688:	f9 e0       	ldi	r31, 0x09	; 9
    868a:	af 2e       	mov	r10, r31
    868c:	02 c0       	rjmp	.+4      	; 0x8692 <rs485xModemFlash+0x1d2>
    else
    {
      if (data != devAddr)
        blad = 10;
    868e:	ea e0       	ldi	r30, 0x0A	; 10
    8690:	ae 2e       	mov	r10, r30
    }
    crc = _crc_xmodem_update(crc, data);
    8692:	c7 01       	movw	r24, r14
    8694:	69 81       	ldd	r22, Y+1	; 0x01
    8696:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    869a:	98 2e       	mov	r9, r24
    869c:	89 2e       	mov	r8, r25
  }
   
  //Odbieranie CRC Hi
  if (blad == 0)
    869e:	aa 20       	and	r10, r10
    86a0:	99 f4       	brne	.+38     	; 0x86c8 <rs485xModemFlash+0x208>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    86a2:	72 e0       	ldi	r23, 0x02	; 2
    86a4:	e7 2e       	mov	r14, r23
    86a6:	f1 2c       	mov	r15, r1
    86a8:	ec 0e       	add	r14, r28
    86aa:	fd 1e       	adc	r15, r29
    86ac:	c7 01       	movw	r24, r14
    86ae:	61 e0       	ldi	r22, 0x01	; 1
    86b0:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    86b4:	81 30       	cpi	r24, 0x01	; 1
    86b6:	41 f4       	brne	.+16     	; 0x86c8 <rs485xModemFlash+0x208>
      blad = 11;
    else
    {
      if ((uint8_t)(crc>>8) != nrBloku)
    86b8:	8a 81       	ldd	r24, Y+2	; 0x02
    86ba:	88 15       	cp	r24, r8
    86bc:	29 f4       	brne	.+10     	; 0x86c8 <rs485xModemFlash+0x208>
    86be:	f7 c0       	rjmp	.+494    	; 0x88ae <rs485xModemFlash+0x3ee>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
      blad = 13;
    else
    {
      if ((uint8_t)(crc & 0xFF) != nrBloku)
    86c0:	8a 81       	ldd	r24, Y+2	; 0x02
    86c2:	89 15       	cp	r24, r9
    86c4:	09 f4       	brne	.+2      	; 0x86c8 <rs485xModemFlash+0x208>
    86c6:	fb c0       	rjmp	.+502    	; 0x88be <rs485xModemFlash+0x3fe>
    }    
  }
   
  if ((blad != 0) && (blad != 253))
  {
    releaseRs485();
    86c8:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
    flushRs485RecBuffer();  
    86cc:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>
    86d0:	3c c1       	rjmp	.+632    	; 0x894a <rs485xModemFlash+0x48a>
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
    86d2:	d2 01       	movw	r26, r4
    86d4:	14 96       	adiw	r26, 0x04	; 4
    86d6:	ed 91       	ld	r30, X+
    86d8:	fc 91       	ld	r31, X
    86da:	15 97       	sbiw	r26, 0x05	; 5
    86dc:	72 80       	ldd	r7, Z+2	; 0x02
    86de:	77 0c       	add	r7, r7
  if (file->wpis->rozmiarLo == 128)
    86e0:	81 81       	ldd	r24, Z+1	; 0x01
    86e2:	80 38       	cpi	r24, 0x80	; 128
    86e4:	99 f4       	brne	.+38     	; 0x870c <rs485xModemFlash+0x24c>
    86e6:	11 c0       	rjmp	.+34     	; 0x870a <rs485xModemFlash+0x24a>
  if (blad != 0)
  {
    releaseRs485();
    flushRs485RecBuffer();  
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    86e8:	00 d0       	rcall	.+0      	; 0x86ea <rs485xModemFlash+0x22a>
    86ea:	0f 92       	push	r0
    86ec:	ed b7       	in	r30, 0x3d	; 61
    86ee:	fe b7       	in	r31, 0x3e	; 62
    86f0:	01 83       	std	Z+1, r16	; 0x01
    86f2:	12 83       	std	Z+2, r17	; 0x02
    86f4:	8f ee       	ldi	r24, 0xEF	; 239
    86f6:	9f e0       	ldi	r25, 0x0F	; 15
    86f8:	83 83       	std	Z+3, r24	; 0x03
    86fa:	94 83       	std	Z+4, r25	; 0x04
    86fc:	0e 94 79 57 	call	0xaef2	; 0xaef2 <fprintf_P>
    8700:	0f 90       	pop	r0
    8702:	0f 90       	pop	r0
    8704:	0f 90       	pop	r0
    8706:	0f 90       	pop	r0
    8708:	20 c1       	rjmp	.+576    	; 0x894a <rs485xModemFlash+0x48a>
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
  if (file->wpis->rozmiarLo == 128)
    liczbaBlokow++;
    870a:	73 94       	inc	r7
   
  nrBloku = 1;
    870c:	81 e0       	ldi	r24, 0x01	; 1
    870e:	8a 83       	std	Y+2, r24	; 0x02
  lRetransmisji = 0;
    8710:	88 24       	eor	r8, r8
   
  while (nrBloku <= liczbaBlokow)
    8712:	99 24       	eor	r9, r9
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    8714:	6e 01       	movw	r12, r28
    8716:	08 94       	sec
    8718:	c1 1c       	adc	r12, r1
    871a:	d1 1c       	adc	r13, r1
    if (debugStr != NULL)
    {
      if (data == NAK)
        fputc('N', debugStr);
      if (data != 0)
        fprintf(debugStr, "data 0x%x ", data);                    
    871c:	6e e1       	ldi	r22, 0x1E	; 30
    871e:	a6 2e       	mov	r10, r22
    8720:	65 e2       	ldi	r22, 0x25	; 37
    8722:	b6 2e       	mov	r11, r22
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    8724:	90 c0       	rjmp	.+288    	; 0x8846 <rs485xModemFlash+0x386>
  {
    crc = 0;
    uartRs485SendByte(SOH);
    8726:	81 e0       	ldi	r24, 0x01	; 1
    8728:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte(nrBloku);
    872c:	8a 81       	ldd	r24, Y+2	; 0x02
    872e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    data = (uint8_t)(~nrBloku);
    8732:	8a 81       	ldd	r24, Y+2	; 0x02
    8734:	80 95       	com	r24
    8736:	89 83       	std	Y+1, r24	; 0x01
    uartRs485SendByte(data);
    8738:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    873c:	99 24       	eor	r9, r9
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
  {
    crc = 0;
    873e:	ee 24       	eor	r14, r14
    8740:	ff 24       	eor	r15, r15
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    8742:	c2 01       	movw	r24, r4
    8744:	b6 01       	movw	r22, r12
    8746:	0e 94 77 1e 	call	0x3cee	; 0x3cee <ramDyskCzytajBajtZPliku>
    874a:	81 11       	cpse	r24, r1
        data = 0;
    874c:	19 82       	std	Y+1, r1	; 0x01
      crc = _crc_xmodem_update(crc, data);
    874e:	c7 01       	movw	r24, r14
    8750:	69 81       	ldd	r22, Y+1	; 0x01
    8752:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8756:	7c 01       	movw	r14, r24
      uartRs485SendByte(data);
    8758:	89 81       	ldd	r24, Y+1	; 0x01
    875a:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte(SOH);
    uartRs485SendByte(nrBloku);
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    875e:	93 94       	inc	r9
    8760:	f9 2d       	mov	r31, r9
    8762:	f0 38       	cpi	r31, 0x80	; 128
    8764:	71 f7       	brne	.-36     	; 0x8742 <rs485xModemFlash+0x282>
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
        data = 0;
      crc = _crc_xmodem_update(crc, data);
      uartRs485SendByte(data);
    }
    uartRs485SendByte((uint8_t)(crc>>8));
    8766:	8f 2d       	mov	r24, r15
    8768:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    876c:	8e 2d       	mov	r24, r14
    876e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 
    if(rs485Receive(&data, 100) != pdTRUE)
    8772:	c6 01       	movw	r24, r12
    8774:	64 e6       	ldi	r22, 0x64	; 100
    8776:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    877a:	81 30       	cpi	r24, 0x01	; 1
    877c:	59 f0       	breq	.+22     	; 0x8794 <rs485xModemFlash+0x2d4>
    {
      blad = 250;
      if (debugStr != NULL)
    877e:	01 15       	cp	r16, r1
    8780:	11 05       	cpc	r17, r1
    8782:	29 f0       	breq	.+10     	; 0x878e <rs485xModemFlash+0x2ce>
        fputc('#', debugStr);
    8784:	83 e2       	ldi	r24, 0x23	; 35
    8786:	90 e0       	ldi	r25, 0x00	; 0
    8788:	b8 01       	movw	r22, r16
    878a:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
      data = 0;
    878e:	19 82       	std	Y+1, r1	; 0x01
    uartRs485SendByte((uint8_t)(crc>>8));
    uartRs485SendByte((uint8_t)(crc & 0xFF));
 
    if(rs485Receive(&data, 100) != pdTRUE)
    {
      blad = 250;
    8790:	5a ef       	ldi	r21, 0xFA	; 250
    8792:	95 2e       	mov	r9, r21
      if (debugStr != NULL)
        fputc('#', debugStr);
      data = 0;
    }
     
    flushRs485RecBuffer();
    8794:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>

    if (data == ACK)
    8798:	89 81       	ldd	r24, Y+1	; 0x01
    879a:	86 30       	cpi	r24, 0x06	; 6
    879c:	f1 f4       	brne	.+60     	; 0x87da <rs485xModemFlash+0x31a>
    {
      nrBloku ++;
    879e:	8a 81       	ldd	r24, Y+2	; 0x02
    87a0:	8f 5f       	subi	r24, 0xFF	; 255
    87a2:	8a 83       	std	Y+2, r24	; 0x02
      lRetransmisji = 0;
      blad = 0;
      if (debugStr != NULL)
    87a4:	01 15       	cp	r16, r1
    87a6:	11 05       	cpc	r17, r1
    87a8:	09 f4       	brne	.+2      	; 0x87ac <rs485xModemFlash+0x2ec>
    87aa:	4b c0       	rjmp	.+150    	; 0x8842 <rs485xModemFlash+0x382>
      {
        fputc('.', debugStr);
    87ac:	8e e2       	ldi	r24, 0x2E	; 46
    87ae:	90 e0       	ldi	r25, 0x00	; 0
    87b0:	b8 01       	movw	r22, r16
    87b2:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
        if ((nrBloku & 0x0F) == 0)
    87b6:	8a 81       	ldd	r24, Y+2	; 0x02
    87b8:	90 e0       	ldi	r25, 0x00	; 0
    87ba:	8f 70       	andi	r24, 0x0F	; 15
    87bc:	90 70       	andi	r25, 0x00	; 0
    87be:	00 97       	sbiw	r24, 0x00	; 0
    87c0:	09 f0       	breq	.+2      	; 0x87c4 <rs485xModemFlash+0x304>
    87c2:	3f c0       	rjmp	.+126    	; 0x8842 <rs485xModemFlash+0x382>
        {
          fputc('\r', debugStr);
    87c4:	8d e0       	ldi	r24, 0x0D	; 13
    87c6:	90 e0       	ldi	r25, 0x00	; 0
    87c8:	b8 01       	movw	r22, r16
    87ca:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
          fputc('\n', debugStr);      
    87ce:	8a e0       	ldi	r24, 0x0A	; 10
    87d0:	90 e0       	ldi	r25, 0x00	; 0
    87d2:	b8 01       	movw	r22, r16
    87d4:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    87d8:	34 c0       	rjmp	.+104    	; 0x8842 <rs485xModemFlash+0x382>
        }
      }
      continue;
    }
 
    if (data == CAN)
    87da:	88 31       	cpi	r24, 0x18	; 24
    87dc:	51 f4       	brne	.+20     	; 0x87f2 <rs485xModemFlash+0x332>
    {
      if (debugStr != NULL)
    87de:	01 15       	cp	r16, r1
    87e0:	11 05       	cpc	r17, r1
    87e2:	09 f4       	brne	.+2      	; 0x87e6 <rs485xModemFlash+0x326>
    87e4:	b5 c0       	rjmp	.+362    	; 0x8950 <rs485xModemFlash+0x490>
        fputc('C', debugStr);
    87e6:	83 e4       	ldi	r24, 0x43	; 67
    87e8:	90 e0       	ldi	r25, 0x00	; 0
    87ea:	b8 01       	movw	r22, r16
    87ec:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    87f0:	af c0       	rjmp	.+350    	; 0x8950 <rs485xModemFlash+0x490>
      blad = 249;
      break;
    }
    
    if (debugStr != NULL)
    87f2:	01 15       	cp	r16, r1
    87f4:	11 05       	cpc	r17, r1
    87f6:	01 f1       	breq	.+64     	; 0x8838 <rs485xModemFlash+0x378>
    {
      if (data == NAK)
    87f8:	85 31       	cpi	r24, 0x15	; 21
    87fa:	29 f4       	brne	.+10     	; 0x8806 <rs485xModemFlash+0x346>
        fputc('N', debugStr);
    87fc:	8e e4       	ldi	r24, 0x4E	; 78
    87fe:	90 e0       	ldi	r25, 0x00	; 0
    8800:	b8 01       	movw	r22, r16
    8802:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
      if (data != 0)
    8806:	89 81       	ldd	r24, Y+1	; 0x01
    8808:	88 23       	and	r24, r24
    880a:	b1 f0       	breq	.+44     	; 0x8838 <rs485xModemFlash+0x378>
        fprintf(debugStr, "data 0x%x ", data);                    
    880c:	00 d0       	rcall	.+0      	; 0x880e <rs485xModemFlash+0x34e>
    880e:	00 d0       	rcall	.+0      	; 0x8810 <rs485xModemFlash+0x350>
    8810:	ed b7       	in	r30, 0x3d	; 61
    8812:	fe b7       	in	r31, 0x3e	; 62
    8814:	31 96       	adiw	r30, 0x01	; 1
    8816:	ad b7       	in	r26, 0x3d	; 61
    8818:	be b7       	in	r27, 0x3e	; 62
    881a:	11 96       	adiw	r26, 0x01	; 1
    881c:	0d 93       	st	X+, r16
    881e:	1c 93       	st	X, r17
    8820:	12 97       	sbiw	r26, 0x02	; 2
    8822:	a2 82       	std	Z+2, r10	; 0x02
    8824:	b3 82       	std	Z+3, r11	; 0x03
    8826:	84 83       	std	Z+4, r24	; 0x04
    8828:	15 82       	std	Z+5, r1	; 0x05
    882a:	0e 94 69 57 	call	0xaed2	; 0xaed2 <fprintf>
    882e:	ed b7       	in	r30, 0x3d	; 61
    8830:	fe b7       	in	r31, 0x3e	; 62
    8832:	36 96       	adiw	r30, 0x06	; 6
    8834:	ed bf       	out	0x3d, r30	; 61
    8836:	fe bf       	out	0x3e, r31	; 62
    }
    
    lRetransmisji ++;
    8838:	83 94       	inc	r8
     
    if (lRetransmisji == 3)
    883a:	f8 2d       	mov	r31, r8
    883c:	f3 30       	cpi	r31, 0x03	; 3
    883e:	19 f4       	brne	.+6      	; 0x8846 <rs485xModemFlash+0x386>
    8840:	8a c0       	rjmp	.+276    	; 0x8956 <rs485xModemFlash+0x496>
    flushRs485RecBuffer();

    if (data == ACK)
    {
      nrBloku ++;
      lRetransmisji = 0;
    8842:	88 24       	eor	r8, r8
      blad = 0;
    8844:	99 24       	eor	r9, r9
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    8846:	8a 81       	ldd	r24, Y+2	; 0x02
    8848:	78 16       	cp	r7, r24
    884a:	08 f0       	brcs	.+2      	; 0x884e <rs485xModemFlash+0x38e>
    884c:	6c cf       	rjmp	.-296    	; 0x8726 <rs485xModemFlash+0x266>
      blad = 248;
      break;
    }
  }
 
  if (blad == 0)
    884e:	99 20       	and	r9, r9
    8850:	b1 f4       	brne	.+44     	; 0x887e <rs485xModemFlash+0x3be>
  {
    uartRs485SendByte(EOT); 
    8852:	84 e0       	ldi	r24, 0x04	; 4
    8854:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    if(rs485Receive(&data, 25) == pdTRUE)
    8858:	8e 01       	movw	r16, r28
    885a:	0f 5f       	subi	r16, 0xFF	; 255
    885c:	1f 4f       	sbci	r17, 0xFF	; 255
    885e:	c8 01       	movw	r24, r16
    8860:	69 e1       	ldi	r22, 0x19	; 25
    8862:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8866:	81 30       	cpi	r24, 0x01	; 1
    8868:	51 f4       	brne	.+20     	; 0x887e <rs485xModemFlash+0x3be>
    {
      if (data == ACK)
    886a:	89 81       	ldd	r24, Y+1	; 0x01
    886c:	86 30       	cpi	r24, 0x06	; 6
    886e:	39 f4       	brne	.+14     	; 0x887e <rs485xModemFlash+0x3be>
      {
        uartRs485SendByte(EOT);
    8870:	84 e0       	ldi	r24, 0x04	; 4
    8872:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
        rs485Receive(&data, 25);
    8876:	c8 01       	movw	r24, r16
    8878:	69 e1       	ldi	r22, 0x19	; 25
    887a:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
      }
    }
  }

  flushRs485RecBuffer();  
    887e:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>
  releaseRs485();
    8882:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
  return blad;
}
    8886:	89 2d       	mov	r24, r9
    8888:	23 96       	adiw	r28, 0x03	; 3
    888a:	cd bf       	out	0x3d, r28	; 61
    888c:	de bf       	out	0x3e, r29	; 62
    888e:	cf 91       	pop	r28
    8890:	df 91       	pop	r29
    8892:	1f 91       	pop	r17
    8894:	0f 91       	pop	r16
    8896:	ff 90       	pop	r15
    8898:	ef 90       	pop	r14
    889a:	df 90       	pop	r13
    889c:	cf 90       	pop	r12
    889e:	bf 90       	pop	r11
    88a0:	af 90       	pop	r10
    88a2:	9f 90       	pop	r9
    88a4:	8f 90       	pop	r8
    88a6:	7f 90       	pop	r7
    88a8:	5f 90       	pop	r5
    88aa:	4f 90       	pop	r4
    88ac:	08 95       	ret
  }
   
  //Odbieranie CRC Lo
  if (blad == 0)
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    88ae:	c7 01       	movw	r24, r14
    88b0:	61 e0       	ldi	r22, 0x01	; 1
    88b2:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    88b6:	81 30       	cpi	r24, 0x01	; 1
    88b8:	09 f0       	breq	.+2      	; 0x88bc <rs485xModemFlash+0x3fc>
    88ba:	06 cf       	rjmp	.-500    	; 0x86c8 <rs485xModemFlash+0x208>
    88bc:	01 cf       	rjmp	.-510    	; 0x86c0 <rs485xModemFlash+0x200>
  }

// Wysyłanie polecenia do bootloadera
  if (blad == 0)
  {
    vTaskDelay(100);
    88be:	84 e6       	ldi	r24, 0x64	; 100
    88c0:	90 e0       	ldi	r25, 0x00	; 0
    88c2:	0e 94 5b 4a 	call	0x94b6	; 0x94b6 <vTaskDelay>
     
    crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    88c6:	80 e0       	ldi	r24, 0x00	; 0
    88c8:	90 e0       	ldi	r25, 0x00	; 0
    88ca:	6a e5       	ldi	r22, 0x5A	; 90
    88cc:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    88d0:	7c 01       	movw	r14, r24
    88d2:	8a e5       	ldi	r24, 0x5A	; 90
    88d4:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    88d8:	c7 01       	movw	r24, r14
    88da:	6c 2d       	mov	r22, r12
    88dc:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    88e0:	7c 01       	movw	r14, r24
    88e2:	8c 2d       	mov	r24, r12
    88e4:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    88e8:	c7 01       	movw	r24, r14
    88ea:	61 e8       	ldi	r22, 0x81	; 129
    88ec:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    88f0:	7c 01       	movw	r14, r24
    88f2:	81 e8       	ldi	r24, 0x81	; 129
    88f4:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    88f8:	c7 01       	movw	r24, r14
    88fa:	61 e0       	ldi	r22, 0x01	; 1
    88fc:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8900:	7c 01       	movw	r14, r24
    8902:	81 e0       	ldi	r24, 0x01	; 1
    8904:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8908:	c7 01       	movw	r24, r14
    890a:	6c 2d       	mov	r22, r12
    890c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8910:	e8 2e       	mov	r14, r24
    8912:	8c 2d       	mov	r24, r12
    8914:	9b 83       	std	Y+3, r25	; 0x03
    8916:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc>>8));
    891a:	9b 81       	ldd	r25, Y+3	; 0x03
    891c:	89 2f       	mov	r24, r25
    891e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    8922:	8e 2d       	mov	r24, r14
    8924:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 
    //Odbieranie odpowiedzi od Bootloadera
    if(rs485Receive(&data, 150) != pdTRUE)
    8928:	ce 01       	movw	r24, r28
    892a:	01 96       	adiw	r24, 0x01	; 1
    892c:	66 e9       	ldi	r22, 0x96	; 150
    892e:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
      blad = 15;

    if (data != 'C')
    8932:	89 81       	ldd	r24, Y+1	; 0x01
    8934:	83 34       	cpi	r24, 0x43	; 67
    8936:	09 f4       	brne	.+2      	; 0x893a <rs485xModemFlash+0x47a>
    8938:	cc ce       	rjmp	.-616    	; 0x86d2 <rs485xModemFlash+0x212>
    blad = 0;
  
   
  if (blad != 0)
  {
    releaseRs485();
    893a:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
    flushRs485RecBuffer();  
    893e:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>
    if (debugStr != NULL)
    8942:	01 15       	cp	r16, r1
    8944:	11 05       	cpc	r17, r1
    8946:	09 f0       	breq	.+2      	; 0x894a <rs485xModemFlash+0x48a>
    8948:	cf ce       	rjmp	.-610    	; 0x86e8 <rs485xModemFlash+0x228>
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
    894a:	99 24       	eor	r9, r9
    894c:	93 94       	inc	r9
    894e:	9b cf       	rjmp	.-202    	; 0x8886 <rs485xModemFlash+0x3c6>
 
    if (data == CAN)
    {
      if (debugStr != NULL)
        fputc('C', debugStr);
      blad = 249;
    8950:	49 ef       	ldi	r20, 0xF9	; 249
    8952:	94 2e       	mov	r9, r20
    8954:	94 cf       	rjmp	.-216    	; 0x887e <rs485xModemFlash+0x3be>
    
    lRetransmisji ++;
     
    if (lRetransmisji == 3)
    {
      blad = 248;
    8956:	38 ef       	ldi	r19, 0xF8	; 248
    8958:	93 2e       	mov	r9, r19
    895a:	91 cf       	rjmp	.-222    	; 0x887e <rs485xModemFlash+0x3be>

0000895c <rs485curtainUp>:
  releaseRs485();
  return blad;
}

uint8_t rs485curtainUp(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    895c:	cf 92       	push	r12
    895e:	df 92       	push	r13
    8960:	ff 92       	push	r15
    8962:	0f 93       	push	r16
    8964:	1f 93       	push	r17
    8966:	df 93       	push	r29
    8968:	cf 93       	push	r28
    896a:	0f 92       	push	r0
    896c:	cd b7       	in	r28, 0x3d	; 61
    896e:	de b7       	in	r29, 0x3e	; 62
    8970:	18 2f       	mov	r17, r24
    8972:	06 2f       	mov	r16, r22
    8974:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
    8976:	80 e0       	ldi	r24, 0x00	; 0
    8978:	90 e0       	ldi	r25, 0x00	; 0
    897a:	6a e5       	ldi	r22, 0x5A	; 90
    897c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8980:	6c 01       	movw	r12, r24
  uartRs485SendByte(SYNC);
    8982:	8a e5       	ldi	r24, 0x5A	; 90
    8984:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, deviceAddr);
    8988:	c6 01       	movw	r24, r12
    898a:	61 2f       	mov	r22, r17
    898c:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8990:	6c 01       	movw	r12, r24
  uartRs485SendByte(deviceAddr);
    8992:	81 2f       	mov	r24, r17
    8994:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  if (curtainNo == 0)
    8998:	00 23       	and	r16, r16
    899a:	39 f4       	brne	.+14     	; 0x89aa <rs485curtainUp+0x4e>
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete1);
    899c:	c6 01       	movw	r24, r12
    899e:	60 e2       	ldi	r22, 0x20	; 32
    89a0:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    89a4:	8c 01       	movw	r16, r24
    uartRs485SendByte(rPodniesRolete1);
    89a6:	80 e2       	ldi	r24, 0x20	; 32
    89a8:	06 c0       	rjmp	.+12     	; 0x89b6 <rs485curtainUp+0x5a>
  }
  else
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete2);
    89aa:	c6 01       	movw	r24, r12
    89ac:	61 e2       	ldi	r22, 0x21	; 33
    89ae:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    89b2:	8c 01       	movw	r16, r24
    uartRs485SendByte(rPodniesRolete2); 
    89b4:	81 e2       	ldi	r24, 0x21	; 33
    89b6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  }
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    89ba:	c8 01       	movw	r24, r16
    89bc:	61 e0       	ldi	r22, 0x01	; 1
    89be:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    89c2:	8c 01       	movw	r16, r24
    89c4:	81 e0       	ldi	r24, 0x01	; 1
    89c6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, pos);  uartRs485SendByte(pos);
    89ca:	c8 01       	movw	r24, r16
    89cc:	6f 2d       	mov	r22, r15
    89ce:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    89d2:	18 2f       	mov	r17, r24
    89d4:	8f 2d       	mov	r24, r15
    89d6:	99 83       	std	Y+1, r25	; 0x01
    89d8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    89dc:	99 81       	ldd	r25, Y+1	; 0x01
    89de:	89 2f       	mov	r24, r25
    89e0:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    89e4:	81 2f       	mov	r24, r17
    89e6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  return 0;
}
    89ea:	80 e0       	ldi	r24, 0x00	; 0
    89ec:	0f 90       	pop	r0
    89ee:	cf 91       	pop	r28
    89f0:	df 91       	pop	r29
    89f2:	1f 91       	pop	r17
    89f4:	0f 91       	pop	r16
    89f6:	ff 90       	pop	r15
    89f8:	df 90       	pop	r13
    89fa:	cf 90       	pop	r12
    89fc:	08 95       	ret

000089fe <rs485Led>:

uint8_t rs485Led(uint8_t deviceAddr, uint8_t ledNo, uint8_t time)
{
    89fe:	cf 92       	push	r12
    8a00:	df 92       	push	r13
    8a02:	ff 92       	push	r15
    8a04:	0f 93       	push	r16
    8a06:	1f 93       	push	r17
    8a08:	df 93       	push	r29
    8a0a:	cf 93       	push	r28
    8a0c:	0f 92       	push	r0
    8a0e:	cd b7       	in	r28, 0x3d	; 61
    8a10:	de b7       	in	r29, 0x3e	; 62
    8a12:	18 2f       	mov	r17, r24
    8a14:	06 2f       	mov	r16, r22
    8a16:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
    8a18:	80 e0       	ldi	r24, 0x00	; 0
    8a1a:	90 e0       	ldi	r25, 0x00	; 0
    8a1c:	6a e5       	ldi	r22, 0x5A	; 90
    8a1e:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8a22:	6c 01       	movw	r12, r24
  uartRs485SendByte(SYNC);
    8a24:	8a e5       	ldi	r24, 0x5A	; 90
    8a26:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, deviceAddr);
    8a2a:	c6 01       	movw	r24, r12
    8a2c:	61 2f       	mov	r22, r17
    8a2e:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8a32:	6c 01       	movw	r12, r24
  uartRs485SendByte(deviceAddr);
    8a34:	81 2f       	mov	r24, r17
    8a36:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, ledNo);
    8a3a:	c6 01       	movw	r24, r12
    8a3c:	60 2f       	mov	r22, r16
    8a3e:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    8a42:	61 e0       	ldi	r22, 0x01	; 1
    8a44:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8a48:	8c 01       	movw	r16, r24
    8a4a:	81 e0       	ldi	r24, 0x01	; 1
    8a4c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, time);  uartRs485SendByte(time);
    8a50:	c8 01       	movw	r24, r16
    8a52:	6f 2d       	mov	r22, r15
    8a54:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8a58:	18 2f       	mov	r17, r24
    8a5a:	8f 2d       	mov	r24, r15
    8a5c:	99 83       	std	Y+1, r25	; 0x01
    8a5e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8a62:	99 81       	ldd	r25, Y+1	; 0x01
    8a64:	89 2f       	mov	r24, r25
    8a66:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8a6a:	81 2f       	mov	r24, r17
    8a6c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  return 0;
}
    8a70:	80 e0       	ldi	r24, 0x00	; 0
    8a72:	0f 90       	pop	r0
    8a74:	cf 91       	pop	r28
    8a76:	df 91       	pop	r29
    8a78:	1f 91       	pop	r17
    8a7a:	0f 91       	pop	r16
    8a7c:	ff 90       	pop	r15
    8a7e:	df 90       	pop	r13
    8a80:	cf 90       	pop	r12
    8a82:	08 95       	ret

00008a84 <rs485curtainDown>:


uint8_t rs485curtainDown(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    8a84:	cf 92       	push	r12
    8a86:	df 92       	push	r13
    8a88:	ff 92       	push	r15
    8a8a:	0f 93       	push	r16
    8a8c:	1f 93       	push	r17
    8a8e:	df 93       	push	r29
    8a90:	cf 93       	push	r28
    8a92:	0f 92       	push	r0
    8a94:	cd b7       	in	r28, 0x3d	; 61
    8a96:	de b7       	in	r29, 0x3e	; 62
    8a98:	18 2f       	mov	r17, r24
    8a9a:	06 2f       	mov	r16, r22
    8a9c:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);            uartRs485SendByte(SYNC);
    8a9e:	80 e0       	ldi	r24, 0x00	; 0
    8aa0:	90 e0       	ldi	r25, 0x00	; 0
    8aa2:	6a e5       	ldi	r22, 0x5A	; 90
    8aa4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8aa8:	6c 01       	movw	r12, r24
    8aaa:	8a e5       	ldi	r24, 0x5A	; 90
    8aac:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, deviceAddr);    uartRs485SendByte(deviceAddr);
    8ab0:	c6 01       	movw	r24, r12
    8ab2:	61 2f       	mov	r22, r17
    8ab4:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8ab8:	6c 01       	movw	r12, r24
    8aba:	81 2f       	mov	r24, r17
    8abc:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  if (curtainNo == 0)
    8ac0:	00 23       	and	r16, r16
    8ac2:	39 f4       	brne	.+14     	; 0x8ad2 <rs485curtainDown+0x4e>
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete1); uartRs485SendByte(rOpuscRolete1);
    8ac4:	c6 01       	movw	r24, r12
    8ac6:	60 e1       	ldi	r22, 0x10	; 16
    8ac8:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8acc:	8c 01       	movw	r16, r24
    8ace:	80 e1       	ldi	r24, 0x10	; 16
    8ad0:	06 c0       	rjmp	.+12     	; 0x8ade <rs485curtainDown+0x5a>
  }
  else
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete2); uartRs485SendByte(rOpuscRolete2); 
    8ad2:	c6 01       	movw	r24, r12
    8ad4:	61 e1       	ldi	r22, 0x11	; 17
    8ad6:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8ada:	8c 01       	movw	r16, r24
    8adc:	81 e1       	ldi	r24, 0x11	; 17
    8ade:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  }

  crc = _crc_xmodem_update(crc, 1);               uartRs485SendByte(1);
    8ae2:	c8 01       	movw	r24, r16
    8ae4:	61 e0       	ldi	r22, 0x01	; 1
    8ae6:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8aea:	8c 01       	movw	r16, r24
    8aec:	81 e0       	ldi	r24, 0x01	; 1
    8aee:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, pos);         uartRs485SendByte(pos);
    8af2:	c8 01       	movw	r24, r16
    8af4:	6f 2d       	mov	r22, r15
    8af6:	0e 94 37 3f 	call	0x7e6e	; 0x7e6e <_crc_xmodem_update>
    8afa:	18 2f       	mov	r17, r24
    8afc:	8f 2d       	mov	r24, r15
    8afe:	99 83       	std	Y+1, r25	; 0x01
    8b00:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8b04:	99 81       	ldd	r25, Y+1	; 0x01
    8b06:	89 2f       	mov	r24, r25
    8b08:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8b0c:	81 2f       	mov	r24, r17
    8b0e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  return 0;
}
    8b12:	80 e0       	ldi	r24, 0x00	; 0
    8b14:	0f 90       	pop	r0
    8b16:	cf 91       	pop	r28
    8b18:	df 91       	pop	r29
    8b1a:	1f 91       	pop	r17
    8b1c:	0f 91       	pop	r16
    8b1e:	ff 90       	pop	r15
    8b20:	df 90       	pop	r13
    8b22:	cf 90       	pop	r12
    8b24:	08 95       	ret

00008b26 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
    8b26:	4f 92       	push	r4
    8b28:	5f 92       	push	r5
    8b2a:	6f 92       	push	r6
    8b2c:	7f 92       	push	r7
    8b2e:	8f 92       	push	r8
    8b30:	9f 92       	push	r9
    8b32:	af 92       	push	r10
    8b34:	bf 92       	push	r11
    8b36:	cf 92       	push	r12
    8b38:	df 92       	push	r13
    8b3a:	ef 92       	push	r14
    8b3c:	ff 92       	push	r15
    8b3e:	0f 93       	push	r16
    8b40:	1f 93       	push	r17
    8b42:	cf 93       	push	r28
    8b44:	df 93       	push	r29
    8b46:	2c 01       	movw	r4, r24
    8b48:	eb 01       	movw	r28, r22
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    8b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    8b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    8b4e:	02 80       	ldd	r0, Z+2	; 0x02
    8b50:	f3 81       	ldd	r31, Z+3	; 0x03
    8b52:	e0 2d       	mov	r30, r0
    8b54:	e9 83       	std	Y+1, r30	; 0x01
    8b56:	fa 83       	std	Y+2, r31	; 0x02
    8b58:	cb 01       	movw	r24, r22
    8b5a:	03 96       	adiw	r24, 0x03	; 3
    8b5c:	e8 17       	cp	r30, r24
    8b5e:	f9 07       	cpc	r31, r25
    8b60:	21 f4       	brne	.+8      	; 0x8b6a <prvListTaskWithinSingleList+0x44>
    8b62:	82 81       	ldd	r24, Z+2	; 0x02
    8b64:	93 81       	ldd	r25, Z+3	; 0x03
    8b66:	89 83       	std	Y+1, r24	; 0x01
    8b68:	9a 83       	std	Y+2, r25	; 0x02
    8b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    8b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    8b6e:	a6 80       	ldd	r10, Z+6	; 0x06
    8b70:	b7 80       	ldd	r11, Z+7	; 0x07
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    8b72:	23 e0       	ldi	r18, 0x03	; 3
    8b74:	e2 2e       	mov	r14, r18
    8b76:	f1 2c       	mov	r15, r1
    8b78:	ec 0e       	add	r14, r28
    8b7a:	fd 1e       	adc	r15, r29
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    8b7c:	97 e9       	ldi	r25, 0x97	; 151
    8b7e:	c9 2e       	mov	r12, r25
    8b80:	95 e2       	ldi	r25, 0x25	; 37
    8b82:	d9 2e       	mov	r13, r25
    8b84:	89 e2       	ldi	r24, 0x29	; 41
    8b86:	88 2e       	mov	r8, r24
    8b88:	85 e2       	ldi	r24, 0x25	; 37
    8b8a:	98 2e       	mov	r9, r24
    8b8c:	64 2e       	mov	r6, r20
    8b8e:	77 24       	eor	r7, r7
    8b90:	67 fc       	sbrc	r6, 7
    8b92:	70 94       	com	r7

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    8b94:	e9 81       	ldd	r30, Y+1	; 0x01
    8b96:	fa 81       	ldd	r31, Y+2	; 0x02
    8b98:	82 81       	ldd	r24, Z+2	; 0x02
    8b9a:	93 81       	ldd	r25, Z+3	; 0x03
    8b9c:	89 83       	std	Y+1, r24	; 0x01
    8b9e:	9a 83       	std	Y+2, r25	; 0x02
    8ba0:	8e 15       	cp	r24, r14
    8ba2:	9f 05       	cpc	r25, r15
    8ba4:	39 f4       	brne	.+14     	; 0x8bb4 <prvListTaskWithinSingleList+0x8e>
    8ba6:	d7 01       	movw	r26, r14
    8ba8:	12 96       	adiw	r26, 0x02	; 2
    8baa:	8d 91       	ld	r24, X+
    8bac:	9c 91       	ld	r25, X
    8bae:	13 97       	sbiw	r26, 0x03	; 3
    8bb0:	89 83       	std	Y+1, r24	; 0x01
    8bb2:	9a 83       	std	Y+2, r25	; 0x02
    8bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    8bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    8bb8:	06 81       	ldd	r16, Z+6	; 0x06
    8bba:	17 81       	ldd	r17, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
    8bbc:	d8 01       	movw	r26, r16
    8bbe:	57 96       	adiw	r26, 0x17	; 23
    8bc0:	ed 91       	ld	r30, X+
    8bc2:	fc 91       	ld	r31, X
    8bc4:	58 97       	sbiw	r26, 0x18	; 24

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;
    8bc6:	80 e0       	ldi	r24, 0x00	; 0
    8bc8:	90 e0       	ldi	r25, 0x00	; 0
    8bca:	01 c0       	rjmp	.+2      	; 0x8bce <prvListTaskWithinSingleList+0xa8>

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    8bcc:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    8bce:	21 91       	ld	r18, Z+
    8bd0:	25 3a       	cpi	r18, 0xA5	; 165
    8bd2:	e1 f3       	breq	.-8      	; 0x8bcc <prvListTaskWithinSingleList+0xa6>
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    8bd4:	98 01       	movw	r18, r16
    8bd6:	27 5e       	subi	r18, 0xE7	; 231
    8bd8:	3f 4f       	sbci	r19, 0xFF	; 255
    8bda:	f8 01       	movw	r30, r16
    8bdc:	56 89       	ldd	r21, Z+22	; 0x16
    8bde:	43 a1       	ldd	r20, Z+35	; 0x23
    8be0:	6d b7       	in	r22, 0x3d	; 61
    8be2:	7e b7       	in	r23, 0x3e	; 62
    8be4:	6e 50       	subi	r22, 0x0E	; 14
    8be6:	70 40       	sbci	r23, 0x00	; 0
    8be8:	6d bf       	out	0x3d, r22	; 61
    8bea:	7e bf       	out	0x3e, r23	; 62
    8bec:	ed b7       	in	r30, 0x3d	; 61
    8bee:	fe b7       	in	r31, 0x3e	; 62
    8bf0:	31 96       	adiw	r30, 0x01	; 1
    8bf2:	ad b7       	in	r26, 0x3d	; 61
    8bf4:	be b7       	in	r27, 0x3e	; 62
    8bf6:	11 96       	adiw	r26, 0x01	; 1
    8bf8:	cd 92       	st	X+, r12
    8bfa:	dc 92       	st	X, r13
    8bfc:	12 97       	sbiw	r26, 0x02	; 2
    8bfe:	82 82       	std	Z+2, r8	; 0x02
    8c00:	93 82       	std	Z+3, r9	; 0x03
    8c02:	24 83       	std	Z+4, r18	; 0x04
    8c04:	35 83       	std	Z+5, r19	; 0x05
    8c06:	66 82       	std	Z+6, r6	; 0x06
    8c08:	77 82       	std	Z+7, r7	; 0x07
    8c0a:	50 87       	std	Z+8, r21	; 0x08
    8c0c:	11 86       	std	Z+9, r1	; 0x09
    8c0e:	82 87       	std	Z+10, r24	; 0x0a
    8c10:	93 87       	std	Z+11, r25	; 0x0b
    8c12:	44 87       	std	Z+12, r20	; 0x0c
    8c14:	15 86       	std	Z+13, r1	; 0x0d
    8c16:	0e 94 e8 57 	call	0xafd0	; 0xafd0 <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
    8c1a:	ed b7       	in	r30, 0x3d	; 61
    8c1c:	fe b7       	in	r31, 0x3e	; 62
    8c1e:	3e 96       	adiw	r30, 0x0e	; 14
    8c20:	ed bf       	out	0x3d, r30	; 61
    8c22:	fe bf       	out	0x3e, r31	; 62
    8c24:	c2 01       	movw	r24, r4
    8c26:	b6 01       	movw	r22, r12
    8c28:	0e 94 d0 56 	call	0xada0	; 0xada0 <strcat>

		} while( pxNextTCB != pxFirstTCB );
    8c2c:	0a 15       	cp	r16, r10
    8c2e:	1b 05       	cpc	r17, r11
    8c30:	09 f0       	breq	.+2      	; 0x8c34 <prvListTaskWithinSingleList+0x10e>
    8c32:	b0 cf       	rjmp	.-160    	; 0x8b94 <prvListTaskWithinSingleList+0x6e>
	}
    8c34:	df 91       	pop	r29
    8c36:	cf 91       	pop	r28
    8c38:	1f 91       	pop	r17
    8c3a:	0f 91       	pop	r16
    8c3c:	ff 90       	pop	r15
    8c3e:	ef 90       	pop	r14
    8c40:	df 90       	pop	r13
    8c42:	cf 90       	pop	r12
    8c44:	bf 90       	pop	r11
    8c46:	af 90       	pop	r10
    8c48:	9f 90       	pop	r9
    8c4a:	8f 90       	pop	r8
    8c4c:	7f 90       	pop	r7
    8c4e:	6f 90       	pop	r6
    8c50:	5f 90       	pop	r5
    8c52:	4f 90       	pop	r4
    8c54:	08 95       	ret

00008c56 <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    8c56:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
    8c5a:	fd cf       	rjmp	.-6      	; 0x8c56 <prvIdleTask>

00008c5c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    8c5c:	2f 92       	push	r2
    8c5e:	3f 92       	push	r3
    8c60:	4f 92       	push	r4
    8c62:	5f 92       	push	r5
    8c64:	6f 92       	push	r6
    8c66:	7f 92       	push	r7
    8c68:	8f 92       	push	r8
    8c6a:	9f 92       	push	r9
    8c6c:	af 92       	push	r10
    8c6e:	bf 92       	push	r11
    8c70:	cf 92       	push	r12
    8c72:	df 92       	push	r13
    8c74:	ef 92       	push	r14
    8c76:	ff 92       	push	r15
    8c78:	0f 93       	push	r16
    8c7a:	1f 93       	push	r17
    8c7c:	cf 93       	push	r28
    8c7e:	df 93       	push	r29
    8c80:	1c 01       	movw	r2, r24
    8c82:	3b 01       	movw	r6, r22
    8c84:	5a 01       	movw	r10, r20
    8c86:	29 01       	movw	r4, r18
    8c88:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    8c8a:	84 e2       	ldi	r24, 0x24	; 36
    8c8c:	90 e0       	ldi	r25, 0x00	; 0
    8c8e:	0e 94 5b 52 	call	0xa4b6	; 0xa4b6 <pvPortMalloc>
    8c92:	e8 2e       	mov	r14, r24
    8c94:	e7 01       	movw	r28, r14
    8c96:	7e 01       	movw	r14, r28
    8c98:	f9 2e       	mov	r15, r25
    8c9a:	e7 01       	movw	r28, r14

	if( pxNewTCB != NULL )
    8c9c:	20 97       	sbiw	r28, 0x00	; 0
    8c9e:	09 f4       	brne	.+2      	; 0x8ca2 <xTaskGenericCreate+0x46>
    8ca0:	c9 c0       	rjmp	.+402    	; 0x8e34 <xTaskGenericCreate+0x1d8>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    8ca2:	c1 14       	cp	r12, r1
    8ca4:	d1 04       	cpc	r13, r1
    8ca6:	29 f4       	brne	.+10     	; 0x8cb2 <xTaskGenericCreate+0x56>
    8ca8:	c5 01       	movw	r24, r10
    8caa:	0e 94 5b 52 	call	0xa4b6	; 0xa4b6 <pvPortMalloc>
    8cae:	c8 2e       	mov	r12, r24
    8cb0:	d9 2e       	mov	r13, r25
    8cb2:	cf 8a       	std	Y+23, r12	; 0x17
    8cb4:	d8 8e       	std	Y+24, r13	; 0x18

		if( pxNewTCB->pxStack == NULL )
    8cb6:	c1 14       	cp	r12, r1
    8cb8:	d1 04       	cpc	r13, r1
    8cba:	21 f4       	brne	.+8      	; 0x8cc4 <xTaskGenericCreate+0x68>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    8cbc:	ce 01       	movw	r24, r28
    8cbe:	0e 94 84 52 	call	0xa508	; 0xa508 <vPortFree>
    8cc2:	b8 c0       	rjmp	.+368    	; 0x8e34 <xTaskGenericCreate+0x1d8>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    8cc4:	c6 01       	movw	r24, r12
    8cc6:	65 ea       	ldi	r22, 0xA5	; 165
    8cc8:	70 e0       	ldi	r23, 0x00	; 0
    8cca:	a5 01       	movw	r20, r10
    8ccc:	0e 94 c9 56 	call	0xad92	; 0xad92 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    8cd0:	08 94       	sec
    8cd2:	a1 08       	sbc	r10, r1
    8cd4:	b1 08       	sbc	r11, r1
    8cd6:	ef 88       	ldd	r14, Y+23	; 0x17
    8cd8:	f8 8c       	ldd	r15, Y+24	; 0x18
    8cda:	ea 0c       	add	r14, r10
    8cdc:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    8cde:	ce 01       	movw	r24, r28
    8ce0:	49 96       	adiw	r24, 0x19	; 25
    8ce2:	b3 01       	movw	r22, r6
    8ce4:	4a e0       	ldi	r20, 0x0A	; 10
    8ce6:	50 e0       	ldi	r21, 0x00	; 0
    8ce8:	0e 94 f0 56 	call	0xade0	; 0xade0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    8cec:	1a a2       	std	Y+34, r1	; 0x22
    8cee:	10 2f       	mov	r17, r16
    8cf0:	03 30       	cpi	r16, 0x03	; 3
    8cf2:	08 f0       	brcs	.+2      	; 0x8cf6 <xTaskGenericCreate+0x9a>
    8cf4:	12 e0       	ldi	r17, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    8cf6:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    8cf8:	72 e0       	ldi	r23, 0x02	; 2
    8cfa:	a7 2e       	mov	r10, r23
    8cfc:	b1 2c       	mov	r11, r1
    8cfe:	ac 0e       	add	r10, r28
    8d00:	bd 1e       	adc	r11, r29
    8d02:	c5 01       	movw	r24, r10
    8d04:	0e 94 fe 4f 	call	0x9ffc	; 0x9ffc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    8d08:	ce 01       	movw	r24, r28
    8d0a:	0c 96       	adiw	r24, 0x0c	; 12
    8d0c:	0e 94 fe 4f 	call	0x9ffc	; 0x9ffc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    8d10:	c8 87       	std	Y+8, r28	; 0x08
    8d12:	d9 87       	std	Y+9, r29	; 0x09

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    8d14:	83 e0       	ldi	r24, 0x03	; 3
    8d16:	90 e0       	ldi	r25, 0x00	; 0
    8d18:	81 1b       	sub	r24, r17
    8d1a:	91 09       	sbc	r25, r1
    8d1c:	8c 87       	std	Y+12, r24	; 0x0c
    8d1e:	9d 87       	std	Y+13, r25	; 0x0d
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    8d20:	ca 8b       	std	Y+18, r28	; 0x12
    8d22:	db 8b       	std	Y+19, r29	; 0x13
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    8d24:	c7 01       	movw	r24, r14
    8d26:	b1 01       	movw	r22, r2
    8d28:	a2 01       	movw	r20, r4
    8d2a:	0e 94 94 52 	call	0xa528	; 0xa528 <pxPortInitialiseStack>
    8d2e:	88 83       	st	Y, r24
    8d30:	99 83       	std	Y+1, r25	; 0x01
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    8d32:	0f b6       	in	r0, 0x3f	; 63
    8d34:	f8 94       	cli
    8d36:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    8d38:	80 91 c9 25 	lds	r24, 0x25C9
    8d3c:	8f 5f       	subi	r24, 0xFF	; 255
    8d3e:	80 93 c9 25 	sts	0x25C9, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    8d42:	80 91 c9 25 	lds	r24, 0x25C9
    8d46:	81 30       	cpi	r24, 0x01	; 1
    8d48:	79 f5       	brne	.+94     	; 0x8da8 <xTaskGenericCreate+0x14c>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    8d4a:	c0 93 55 25 	sts	0x2555, r28
    8d4e:	d0 93 56 25 	sts	0x2556, r29
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    8d52:	8d e5       	ldi	r24, 0x5D	; 93
    8d54:	95 e2       	ldi	r25, 0x25	; 37
    8d56:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
    8d5a:	86 e6       	ldi	r24, 0x66	; 102
    8d5c:	95 e2       	ldi	r25, 0x25	; 37
    8d5e:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
    8d62:	8f e6       	ldi	r24, 0x6F	; 111
    8d64:	95 e2       	ldi	r25, 0x25	; 37
    8d66:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    8d6a:	6c ec       	ldi	r22, 0xCC	; 204
    8d6c:	e6 2e       	mov	r14, r22
    8d6e:	65 e2       	ldi	r22, 0x25	; 37
    8d70:	f6 2e       	mov	r15, r22
    8d72:	c7 01       	movw	r24, r14
    8d74:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    8d78:	55 ed       	ldi	r21, 0xD5	; 213
    8d7a:	c5 2e       	mov	r12, r21
    8d7c:	55 e2       	ldi	r21, 0x25	; 37
    8d7e:	d5 2e       	mov	r13, r21
    8d80:	c6 01       	movw	r24, r12
    8d82:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    8d86:	88 e7       	ldi	r24, 0x78	; 120
    8d88:	95 e2       	ldi	r25, 0x25	; 37
    8d8a:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    8d8e:	81 e8       	ldi	r24, 0x81	; 129
    8d90:	95 e2       	ldi	r25, 0x25	; 37
    8d92:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    8d96:	e0 92 8c 25 	sts	0x258C, r14
    8d9a:	f0 92 8d 25 	sts	0x258D, r15
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    8d9e:	c0 92 8a 25 	sts	0x258A, r12
    8da2:	d0 92 8b 25 	sts	0x258B, r13
    8da6:	0f c0       	rjmp	.+30     	; 0x8dc6 <xTaskGenericCreate+0x16a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    8da8:	80 91 ca 25 	lds	r24, 0x25CA
    8dac:	88 23       	and	r24, r24
    8dae:	59 f4       	brne	.+22     	; 0x8dc6 <xTaskGenericCreate+0x16a>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    8db0:	e0 91 55 25 	lds	r30, 0x2555
    8db4:	f0 91 56 25 	lds	r31, 0x2556
    8db8:	86 89       	ldd	r24, Z+22	; 0x16
    8dba:	08 17       	cp	r16, r24
    8dbc:	20 f0       	brcs	.+8      	; 0x8dc6 <xTaskGenericCreate+0x16a>
					{
						pxCurrentTCB = pxNewTCB;
    8dbe:	c0 93 55 25 	sts	0x2555, r28
    8dc2:	d0 93 56 25 	sts	0x2556, r29
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    8dc6:	2e 89       	ldd	r18, Y+22	; 0x16
    8dc8:	80 91 96 25 	lds	r24, 0x2596
    8dcc:	82 17       	cp	r24, r18
    8dce:	10 f4       	brcc	.+4      	; 0x8dd4 <xTaskGenericCreate+0x178>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    8dd0:	20 93 96 25 	sts	0x2596, r18
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    8dd4:	80 91 cb 25 	lds	r24, 0x25CB
    8dd8:	8b a3       	std	Y+35, r24	; 0x23
			}
			#endif
			uxTaskNumber++;
    8dda:	8f 5f       	subi	r24, 0xFF	; 255
    8ddc:	80 93 cb 25 	sts	0x25CB, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    8de0:	80 91 5c 25 	lds	r24, 0x255C
    8de4:	82 17       	cp	r24, r18
    8de6:	10 f4       	brcc	.+4      	; 0x8dec <xTaskGenericCreate+0x190>
    8de8:	20 93 5c 25 	sts	0x255C, r18
    8dec:	30 e0       	ldi	r19, 0x00	; 0
    8dee:	c9 01       	movw	r24, r18
    8df0:	43 e0       	ldi	r20, 0x03	; 3
    8df2:	88 0f       	add	r24, r24
    8df4:	99 1f       	adc	r25, r25
    8df6:	4a 95       	dec	r20
    8df8:	e1 f7       	brne	.-8      	; 0x8df2 <xTaskGenericCreate+0x196>
    8dfa:	82 0f       	add	r24, r18
    8dfc:	93 1f       	adc	r25, r19
    8dfe:	83 5a       	subi	r24, 0xA3	; 163
    8e00:	9a 4d       	sbci	r25, 0xDA	; 218
    8e02:	b5 01       	movw	r22, r10
    8e04:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    8e08:	0f 90       	pop	r0
    8e0a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    8e0c:	81 14       	cp	r8, r1
    8e0e:	91 04       	cpc	r9, r1
    8e10:	19 f0       	breq	.+6      	; 0x8e18 <xTaskGenericCreate+0x1bc>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    8e12:	f4 01       	movw	r30, r8
    8e14:	c0 83       	st	Z, r28
    8e16:	d1 83       	std	Z+1, r29	; 0x01
		}

		if( xSchedulerRunning != pdFALSE )
    8e18:	80 91 ca 25 	lds	r24, 0x25CA
    8e1c:	88 23       	and	r24, r24
    8e1e:	61 f0       	breq	.+24     	; 0x8e38 <xTaskGenericCreate+0x1dc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    8e20:	e0 91 55 25 	lds	r30, 0x2555
    8e24:	f0 91 56 25 	lds	r31, 0x2556
    8e28:	86 89       	ldd	r24, Z+22	; 0x16
    8e2a:	80 17       	cp	r24, r16
    8e2c:	28 f4       	brcc	.+10     	; 0x8e38 <xTaskGenericCreate+0x1dc>
			{
				portYIELD_WITHIN_API();
    8e2e:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
    8e32:	02 c0       	rjmp	.+4      	; 0x8e38 <xTaskGenericCreate+0x1dc>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    8e34:	8f ef       	ldi	r24, 0xFF	; 255
    8e36:	01 c0       	rjmp	.+2      	; 0x8e3a <xTaskGenericCreate+0x1de>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    8e38:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    8e3a:	df 91       	pop	r29
    8e3c:	cf 91       	pop	r28
    8e3e:	1f 91       	pop	r17
    8e40:	0f 91       	pop	r16
    8e42:	ff 90       	pop	r15
    8e44:	ef 90       	pop	r14
    8e46:	df 90       	pop	r13
    8e48:	cf 90       	pop	r12
    8e4a:	bf 90       	pop	r11
    8e4c:	af 90       	pop	r10
    8e4e:	9f 90       	pop	r9
    8e50:	8f 90       	pop	r8
    8e52:	7f 90       	pop	r7
    8e54:	6f 90       	pop	r6
    8e56:	5f 90       	pop	r5
    8e58:	4f 90       	pop	r4
    8e5a:	3f 90       	pop	r3
    8e5c:	2f 90       	pop	r2
    8e5e:	08 95       	ret

00008e60 <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		portENTER_CRITICAL();
    8e60:	0f b6       	in	r0, 0x3f	; 63
    8e62:	f8 94       	cli
    8e64:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8e66:	00 97       	sbiw	r24, 0x00	; 0
    8e68:	29 f4       	brne	.+10     	; 0x8e74 <uxTaskPriorityGet+0x14>
    8e6a:	e0 91 55 25 	lds	r30, 0x2555
    8e6e:	f0 91 56 25 	lds	r31, 0x2556
    8e72:	01 c0       	rjmp	.+2      	; 0x8e76 <uxTaskPriorityGet+0x16>
    8e74:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portEXIT_CRITICAL();
    8e76:	0f 90       	pop	r0
    8e78:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    8e7a:	86 89       	ldd	r24, Z+22	; 0x16
    8e7c:	08 95       	ret

00008e7e <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    8e7e:	ef 92       	push	r14
    8e80:	ff 92       	push	r15
    8e82:	0f 93       	push	r16
    8e84:	1f 93       	push	r17
    8e86:	df 93       	push	r29
    8e88:	cf 93       	push	r28
    8e8a:	0f 92       	push	r0
    8e8c:	cd b7       	in	r28, 0x3d	; 61
    8e8e:	de b7       	in	r29, 0x3e	; 62
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8e90:	63 30       	cpi	r22, 0x03	; 3
    8e92:	08 f0       	brcs	.+2      	; 0x8e96 <vTaskPrioritySet+0x18>
    8e94:	62 e0       	ldi	r22, 0x02	; 2
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		portENTER_CRITICAL();
    8e96:	0f b6       	in	r0, 0x3f	; 63
    8e98:	f8 94       	cli
    8e9a:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    8e9c:	20 91 55 25 	lds	r18, 0x2555
    8ea0:	30 91 56 25 	lds	r19, 0x2556
    8ea4:	82 17       	cp	r24, r18
    8ea6:	93 07       	cpc	r25, r19
    8ea8:	11 f0       	breq	.+4      	; 0x8eae <vTaskPrioritySet+0x30>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8eaa:	00 97       	sbiw	r24, 0x00	; 0
    8eac:	39 f4       	brne	.+14     	; 0x8ebc <vTaskPrioritySet+0x3e>
    8eae:	e0 90 55 25 	lds	r14, 0x2555
    8eb2:	f0 90 56 25 	lds	r15, 0x2556
    8eb6:	80 e0       	ldi	r24, 0x00	; 0
    8eb8:	90 e0       	ldi	r25, 0x00	; 0
    8eba:	01 c0       	rjmp	.+2      	; 0x8ebe <vTaskPrioritySet+0x40>
    8ebc:	7c 01       	movw	r14, r24
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    8ebe:	f7 01       	movw	r30, r14
    8ec0:	36 89       	ldd	r19, Z+22	; 0x16
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    8ec2:	36 17       	cp	r19, r22
    8ec4:	09 f4       	brne	.+2      	; 0x8ec8 <vTaskPrioritySet+0x4a>
    8ec6:	41 c0       	rjmp	.+130    	; 0x8f4a <vTaskPrioritySet+0xcc>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    8ec8:	36 17       	cp	r19, r22
    8eca:	20 f4       	brcc	.+8      	; 0x8ed4 <vTaskPrioritySet+0x56>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    8ecc:	21 e0       	ldi	r18, 0x01	; 1
    8ece:	00 97       	sbiw	r24, 0x00	; 0
    8ed0:	29 f4       	brne	.+10     	; 0x8edc <vTaskPrioritySet+0x5e>
    8ed2:	03 c0       	rjmp	.+6      	; 0x8eda <vTaskPrioritySet+0x5c>
    8ed4:	21 e0       	ldi	r18, 0x01	; 1
    8ed6:	00 97       	sbiw	r24, 0x00	; 0
    8ed8:	09 f0       	breq	.+2      	; 0x8edc <vTaskPrioritySet+0x5e>
    8eda:	20 e0       	ldi	r18, 0x00	; 0
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    8edc:	f7 01       	movw	r30, r14
    8ede:	66 8b       	std	Z+22, r22	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    8ee0:	43 e0       	ldi	r20, 0x03	; 3
    8ee2:	50 e0       	ldi	r21, 0x00	; 0
    8ee4:	46 1b       	sub	r20, r22
    8ee6:	51 09       	sbc	r21, r1
    8ee8:	44 87       	std	Z+12, r20	; 0x0c
    8eea:	55 87       	std	Z+13, r21	; 0x0d

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    8eec:	89 e0       	ldi	r24, 0x09	; 9
    8eee:	38 9f       	mul	r19, r24
    8ef0:	c0 01       	movw	r24, r0
    8ef2:	11 24       	eor	r1, r1
    8ef4:	83 5a       	subi	r24, 0xA3	; 163
    8ef6:	9a 4d       	sbci	r25, 0xDA	; 218
    8ef8:	42 85       	ldd	r20, Z+10	; 0x0a
    8efa:	53 85       	ldd	r21, Z+11	; 0x0b
    8efc:	48 17       	cp	r20, r24
    8efe:	59 07       	cpc	r21, r25
    8f00:	01 f5       	brne	.+64     	; 0x8f42 <vTaskPrioritySet+0xc4>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    8f02:	87 01       	movw	r16, r14
    8f04:	0e 5f       	subi	r16, 0xFE	; 254
    8f06:	1f 4f       	sbci	r17, 0xFF	; 255
    8f08:	c8 01       	movw	r24, r16
    8f0a:	29 83       	std	Y+1, r18	; 0x01
    8f0c:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    8f10:	f7 01       	movw	r30, r14
    8f12:	46 89       	ldd	r20, Z+22	; 0x16
    8f14:	80 91 5c 25 	lds	r24, 0x255C
    8f18:	29 81       	ldd	r18, Y+1	; 0x01
    8f1a:	84 17       	cp	r24, r20
    8f1c:	10 f4       	brcc	.+4      	; 0x8f22 <vTaskPrioritySet+0xa4>
    8f1e:	40 93 5c 25 	sts	0x255C, r20
    8f22:	50 e0       	ldi	r21, 0x00	; 0
    8f24:	ca 01       	movw	r24, r20
    8f26:	e3 e0       	ldi	r30, 0x03	; 3
    8f28:	88 0f       	add	r24, r24
    8f2a:	99 1f       	adc	r25, r25
    8f2c:	ea 95       	dec	r30
    8f2e:	e1 f7       	brne	.-8      	; 0x8f28 <vTaskPrioritySet+0xaa>
    8f30:	84 0f       	add	r24, r20
    8f32:	95 1f       	adc	r25, r21
    8f34:	83 5a       	subi	r24, 0xA3	; 163
    8f36:	9a 4d       	sbci	r25, 0xDA	; 218
    8f38:	b8 01       	movw	r22, r16
    8f3a:	29 83       	std	Y+1, r18	; 0x01
    8f3c:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
    8f40:	29 81       	ldd	r18, Y+1	; 0x01
				}

				if( xYieldRequired == pdTRUE )
    8f42:	21 30       	cpi	r18, 0x01	; 1
    8f44:	11 f4       	brne	.+4      	; 0x8f4a <vTaskPrioritySet+0xcc>
				{
					portYIELD_WITHIN_API();
    8f46:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
				}
			}
		}
		portEXIT_CRITICAL();
    8f4a:	0f 90       	pop	r0
    8f4c:	0f be       	out	0x3f, r0	; 63
	}
    8f4e:	0f 90       	pop	r0
    8f50:	cf 91       	pop	r28
    8f52:	df 91       	pop	r29
    8f54:	1f 91       	pop	r17
    8f56:	0f 91       	pop	r16
    8f58:	ff 90       	pop	r15
    8f5a:	ef 90       	pop	r14
    8f5c:	08 95       	ret

00008f5e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    8f5e:	ef 92       	push	r14
    8f60:	ff 92       	push	r15
    8f62:	0f 93       	push	r16
    8f64:	1f 93       	push	r17
    8f66:	cf 93       	push	r28
    8f68:	df 93       	push	r29
    8f6a:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    8f6c:	0f b6       	in	r0, 0x3f	; 63
    8f6e:	f8 94       	cli
    8f70:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    8f72:	80 91 55 25 	lds	r24, 0x2555
    8f76:	90 91 56 25 	lds	r25, 0x2556
    8f7a:	c8 17       	cp	r28, r24
    8f7c:	d9 07       	cpc	r29, r25
    8f7e:	11 f0       	breq	.+4      	; 0x8f84 <vTaskSuspend+0x26>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    8f80:	20 97       	sbiw	r28, 0x00	; 0
    8f82:	39 f4       	brne	.+14     	; 0x8f92 <vTaskSuspend+0x34>
    8f84:	00 91 55 25 	lds	r16, 0x2555
    8f88:	10 91 56 25 	lds	r17, 0x2556
    8f8c:	c0 e0       	ldi	r28, 0x00	; 0
    8f8e:	d0 e0       	ldi	r29, 0x00	; 0
    8f90:	01 c0       	rjmp	.+2      	; 0x8f94 <vTaskSuspend+0x36>
    8f92:	8e 01       	movw	r16, r28

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    8f94:	f2 e0       	ldi	r31, 0x02	; 2
    8f96:	ef 2e       	mov	r14, r31
    8f98:	f1 2c       	mov	r15, r1
    8f9a:	e0 0e       	add	r14, r16
    8f9c:	f1 1e       	adc	r15, r17
    8f9e:	c7 01       	movw	r24, r14
    8fa0:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    8fa4:	f8 01       	movw	r30, r16
    8fa6:	84 89       	ldd	r24, Z+20	; 0x14
    8fa8:	95 89       	ldd	r25, Z+21	; 0x15
    8faa:	00 97       	sbiw	r24, 0x00	; 0
    8fac:	21 f0       	breq	.+8      	; 0x8fb6 <vTaskSuspend+0x58>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    8fae:	c8 01       	movw	r24, r16
    8fb0:	0c 96       	adiw	r24, 0x0c	; 12
    8fb2:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    8fb6:	81 e8       	ldi	r24, 0x81	; 129
    8fb8:	95 e2       	ldi	r25, 0x25	; 37
    8fba:	b7 01       	movw	r22, r14
    8fbc:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    8fc0:	0f 90       	pop	r0
    8fc2:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    8fc4:	20 97       	sbiw	r28, 0x00	; 0
    8fc6:	11 f4       	brne	.+4      	; 0x8fcc <vTaskSuspend+0x6e>
		{
			portYIELD_WITHIN_API();
    8fc8:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
		}
	}
    8fcc:	df 91       	pop	r29
    8fce:	cf 91       	pop	r28
    8fd0:	1f 91       	pop	r17
    8fd2:	0f 91       	pop	r16
    8fd4:	ff 90       	pop	r15
    8fd6:	ef 90       	pop	r14
    8fd8:	08 95       	ret

00008fda <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    8fda:	fc 01       	movw	r30, r24

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    8fdc:	82 85       	ldd	r24, Z+10	; 0x0a
    8fde:	93 85       	ldd	r25, Z+11	; 0x0b
    8fe0:	25 e2       	ldi	r18, 0x25	; 37
    8fe2:	81 38       	cpi	r24, 0x81	; 129
    8fe4:	92 07       	cpc	r25, r18
    8fe6:	51 f4       	brne	.+20     	; 0x8ffc <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    8fe8:	24 89       	ldd	r18, Z+20	; 0x14
    8fea:	35 89       	ldd	r19, Z+21	; 0x15
    8fec:	85 e2       	ldi	r24, 0x25	; 37
    8fee:	28 37       	cpi	r18, 0x78	; 120
    8ff0:	38 07       	cpc	r19, r24
    8ff2:	31 f0       	breq	.+12     	; 0x9000 <xTaskIsTaskSuspended+0x26>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    8ff4:	81 e0       	ldi	r24, 0x01	; 1
    8ff6:	21 15       	cp	r18, r1
    8ff8:	31 05       	cpc	r19, r1
    8ffa:	19 f0       	breq	.+6      	; 0x9002 <xTaskIsTaskSuspended+0x28>
    8ffc:	80 e0       	ldi	r24, 0x00	; 0
    8ffe:	08 95       	ret
    9000:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    9002:	08 95       	ret

00009004 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    9004:	ef 92       	push	r14
    9006:	ff 92       	push	r15
    9008:	0f 93       	push	r16
    900a:	1f 93       	push	r17
    900c:	cf 93       	push	r28
    900e:	df 93       	push	r29
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    9010:	e8 2e       	mov	r14, r24
    9012:	e7 01       	movw	r28, r14
    9014:	7e 01       	movw	r14, r28
    9016:	f9 2e       	mov	r15, r25
    9018:	e7 01       	movw	r28, r14

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    901a:	20 97       	sbiw	r28, 0x00	; 0
    901c:	b1 f1       	breq	.+108    	; 0x908a <vTaskResume+0x86>
    901e:	80 91 55 25 	lds	r24, 0x2555
    9022:	90 91 56 25 	lds	r25, 0x2556
    9026:	e8 16       	cp	r14, r24
    9028:	f9 06       	cpc	r15, r25
    902a:	79 f1       	breq	.+94     	; 0x908a <vTaskResume+0x86>
		{
			portENTER_CRITICAL();
    902c:	0f b6       	in	r0, 0x3f	; 63
    902e:	f8 94       	cli
    9030:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    9032:	c7 01       	movw	r24, r14
    9034:	0e 94 ed 47 	call	0x8fda	; 0x8fda <xTaskIsTaskSuspended>
    9038:	81 30       	cpi	r24, 0x01	; 1
    903a:	29 f5       	brne	.+74     	; 0x9086 <vTaskResume+0x82>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    903c:	87 01       	movw	r16, r14
    903e:	0e 5f       	subi	r16, 0xFE	; 254
    9040:	1f 4f       	sbci	r17, 0xFF	; 255
    9042:	c8 01       	movw	r24, r16
    9044:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    9048:	2e 89       	ldd	r18, Y+22	; 0x16
    904a:	80 91 5c 25 	lds	r24, 0x255C
    904e:	82 17       	cp	r24, r18
    9050:	10 f4       	brcc	.+4      	; 0x9056 <vTaskResume+0x52>
    9052:	20 93 5c 25 	sts	0x255C, r18
    9056:	30 e0       	ldi	r19, 0x00	; 0
    9058:	c9 01       	movw	r24, r18
    905a:	a3 e0       	ldi	r26, 0x03	; 3
    905c:	88 0f       	add	r24, r24
    905e:	99 1f       	adc	r25, r25
    9060:	aa 95       	dec	r26
    9062:	e1 f7       	brne	.-8      	; 0x905c <vTaskResume+0x58>
    9064:	82 0f       	add	r24, r18
    9066:	93 1f       	adc	r25, r19
    9068:	83 5a       	subi	r24, 0xA3	; 163
    906a:	9a 4d       	sbci	r25, 0xDA	; 218
    906c:	b8 01       	movw	r22, r16
    906e:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9072:	e0 91 55 25 	lds	r30, 0x2555
    9076:	f0 91 56 25 	lds	r31, 0x2556
    907a:	9e 89       	ldd	r25, Y+22	; 0x16
    907c:	86 89       	ldd	r24, Z+22	; 0x16
    907e:	98 17       	cp	r25, r24
    9080:	10 f0       	brcs	.+4      	; 0x9086 <vTaskResume+0x82>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    9082:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    9086:	0f 90       	pop	r0
    9088:	0f be       	out	0x3f, r0	; 63
		}
	}
    908a:	df 91       	pop	r29
    908c:	cf 91       	pop	r28
    908e:	1f 91       	pop	r17
    9090:	0f 91       	pop	r16
    9092:	ff 90       	pop	r15
    9094:	ef 90       	pop	r14
    9096:	08 95       	ret

00009098 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    9098:	ef 92       	push	r14
    909a:	ff 92       	push	r15
    909c:	0f 93       	push	r16
    909e:	1f 93       	push	r17
    90a0:	cf 93       	push	r28
    90a2:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
    90a4:	e8 2e       	mov	r14, r24
    90a6:	e7 01       	movw	r28, r14
    90a8:	7e 01       	movw	r14, r28
    90aa:	f9 2e       	mov	r15, r25
    90ac:	e7 01       	movw	r28, r14

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    90ae:	c7 01       	movw	r24, r14
    90b0:	0e 94 ed 47 	call	0x8fda	; 0x8fda <xTaskIsTaskSuspended>
    90b4:	81 30       	cpi	r24, 0x01	; 1
    90b6:	99 f5       	brne	.+102    	; 0x911e <xTaskResumeFromISR+0x86>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    90b8:	80 91 5b 25 	lds	r24, 0x255B
    90bc:	88 23       	and	r24, r24
    90be:	41 f5       	brne	.+80     	; 0x9110 <xTaskResumeFromISR+0x78>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    90c0:	e0 91 55 25 	lds	r30, 0x2555
    90c4:	f0 91 56 25 	lds	r31, 0x2556
    90c8:	ff 24       	eor	r15, r15
    90ca:	f3 94       	inc	r15
    90cc:	9e 89       	ldd	r25, Y+22	; 0x16
    90ce:	86 89       	ldd	r24, Z+22	; 0x16
    90d0:	98 17       	cp	r25, r24
    90d2:	08 f4       	brcc	.+2      	; 0x90d6 <xTaskResumeFromISR+0x3e>
    90d4:	ff 24       	eor	r15, r15
				vListRemove(  &( pxTCB->xGenericListItem ) );
    90d6:	8e 01       	movw	r16, r28
    90d8:	0e 5f       	subi	r16, 0xFE	; 254
    90da:	1f 4f       	sbci	r17, 0xFF	; 255
    90dc:	c8 01       	movw	r24, r16
    90de:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    90e2:	4e 89       	ldd	r20, Y+22	; 0x16
    90e4:	80 91 5c 25 	lds	r24, 0x255C
    90e8:	84 17       	cp	r24, r20
    90ea:	10 f4       	brcc	.+4      	; 0x90f0 <xTaskResumeFromISR+0x58>
    90ec:	40 93 5c 25 	sts	0x255C, r20
    90f0:	50 e0       	ldi	r21, 0x00	; 0
    90f2:	9a 01       	movw	r18, r20
    90f4:	b3 e0       	ldi	r27, 0x03	; 3
    90f6:	22 0f       	add	r18, r18
    90f8:	33 1f       	adc	r19, r19
    90fa:	ba 95       	dec	r27
    90fc:	e1 f7       	brne	.-8      	; 0x90f6 <xTaskResumeFromISR+0x5e>
    90fe:	24 0f       	add	r18, r20
    9100:	35 1f       	adc	r19, r21
    9102:	c9 01       	movw	r24, r18
    9104:	83 5a       	subi	r24, 0xA3	; 163
    9106:	9a 4d       	sbci	r25, 0xDA	; 218
    9108:	b8 01       	movw	r22, r16
    910a:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
    910e:	08 c0       	rjmp	.+16     	; 0x9120 <xTaskResumeFromISR+0x88>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    9110:	b7 01       	movw	r22, r14
    9112:	64 5f       	subi	r22, 0xF4	; 244
    9114:	7f 4f       	sbci	r23, 0xFF	; 255
    9116:	88 e7       	ldi	r24, 0x78	; 120
    9118:	95 e2       	ldi	r25, 0x25	; 37
    911a:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    911e:	ff 24       	eor	r15, r15
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
			}
		}

		return xYieldRequired;
	}
    9120:	8f 2d       	mov	r24, r15
    9122:	df 91       	pop	r29
    9124:	cf 91       	pop	r28
    9126:	1f 91       	pop	r17
    9128:	0f 91       	pop	r16
    912a:	ff 90       	pop	r15
    912c:	ef 90       	pop	r14
    912e:	08 95       	ret

00009130 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    9130:	af 92       	push	r10
    9132:	bf 92       	push	r11
    9134:	cf 92       	push	r12
    9136:	df 92       	push	r13
    9138:	ef 92       	push	r14
    913a:	ff 92       	push	r15
    913c:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    913e:	8b e2       	ldi	r24, 0x2B	; 43
    9140:	96 e4       	ldi	r25, 0x46	; 70
    9142:	6b e3       	ldi	r22, 0x3B	; 59
    9144:	75 e2       	ldi	r23, 0x25	; 37
    9146:	46 e9       	ldi	r20, 0x96	; 150
    9148:	50 e0       	ldi	r21, 0x00	; 0
    914a:	20 e0       	ldi	r18, 0x00	; 0
    914c:	30 e0       	ldi	r19, 0x00	; 0
    914e:	00 e0       	ldi	r16, 0x00	; 0
    9150:	ee 24       	eor	r14, r14
    9152:	ff 24       	eor	r15, r15
    9154:	cc 24       	eor	r12, r12
    9156:	dd 24       	eor	r13, r13
    9158:	aa 24       	eor	r10, r10
    915a:	bb 24       	eor	r11, r11
    915c:	0e 94 2e 46 	call	0x8c5c	; 0x8c5c <xTaskGenericCreate>

	if( xReturn == pdPASS )
    9160:	81 30       	cpi	r24, 0x01	; 1
    9162:	49 f4       	brne	.+18     	; 0x9176 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    9164:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    9166:	80 93 ca 25 	sts	0x25CA, r24
		xTickCount = ( portTickType ) 0;
    916a:	10 92 59 25 	sts	0x2559, r1
    916e:	10 92 5a 25 	sts	0x255A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    9172:	0e 94 ec 52 	call	0xa5d8	; 0xa5d8 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    9176:	0f 91       	pop	r16
    9178:	ff 90       	pop	r15
    917a:	ef 90       	pop	r14
    917c:	df 90       	pop	r13
    917e:	cf 90       	pop	r12
    9180:	bf 90       	pop	r11
    9182:	af 90       	pop	r10
    9184:	08 95       	ret

00009186 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    9186:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    9188:	10 92 ca 25 	sts	0x25CA, r1
	vPortEndScheduler();
    918c:	0e 94 36 53 	call	0xa66c	; 0xa66c <vPortEndScheduler>
}
    9190:	08 95       	ret

00009192 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    9192:	80 91 5b 25 	lds	r24, 0x255B
    9196:	8f 5f       	subi	r24, 0xFF	; 255
    9198:	80 93 5b 25 	sts	0x255B, r24
}
    919c:	08 95       	ret

0000919e <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    919e:	0f b6       	in	r0, 0x3f	; 63
    91a0:	f8 94       	cli
    91a2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    91a4:	20 91 59 25 	lds	r18, 0x2559
    91a8:	30 91 5a 25 	lds	r19, 0x255A
	}
	portEXIT_CRITICAL();
    91ac:	0f 90       	pop	r0
    91ae:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    91b0:	c9 01       	movw	r24, r18
    91b2:	08 95       	ret

000091b4 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    91b4:	80 91 c9 25 	lds	r24, 0x25C9
}
    91b8:	08 95       	ret

000091ba <vTaskStartTrace>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
	{
		portENTER_CRITICAL();
    91ba:	0f b6       	in	r0, 0x3f	; 63
    91bc:	f8 94       	cli
    91be:	0f 92       	push	r0
		{
			pcTraceBuffer = ( signed char * )pcBuffer;
    91c0:	80 93 8f 25 	sts	0x258F, r24
    91c4:	90 93 90 25 	sts	0x2590, r25
			pcTraceBufferStart = pcBuffer;
    91c8:	80 93 94 25 	sts	0x2594, r24
    91cc:	90 93 95 25 	sts	0x2595, r25
			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
    91d0:	48 50       	subi	r20, 0x08	; 8
    91d2:	50 40       	sbci	r21, 0x00	; 0
    91d4:	48 0f       	add	r20, r24
    91d6:	59 1f       	adc	r21, r25
    91d8:	40 93 91 25 	sts	0x2591, r20
    91dc:	50 93 92 25 	sts	0x2592, r21
			xTracing = pdTRUE;
    91e0:	81 e0       	ldi	r24, 0x01	; 1
    91e2:	80 93 8e 25 	sts	0x258E, r24
		}
		portEXIT_CRITICAL();
    91e6:	0f 90       	pop	r0
    91e8:	0f be       	out	0x3f, r0	; 63
	}
    91ea:	08 95       	ret

000091ec <ulTaskEndTrace>:

	unsigned long ulTaskEndTrace( void )
	{
	unsigned long ulBufferLength;

		portENTER_CRITICAL();
    91ec:	0f b6       	in	r0, 0x3f	; 63
    91ee:	f8 94       	cli
    91f0:	0f 92       	push	r0
			xTracing = pdFALSE;
    91f2:	10 92 8e 25 	sts	0x258E, r1
		portEXIT_CRITICAL();
    91f6:	0f 90       	pop	r0
    91f8:	0f be       	out	0x3f, r0	; 63

		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
    91fa:	20 91 8f 25 	lds	r18, 0x258F
    91fe:	30 91 90 25 	lds	r19, 0x2590
    9202:	80 91 94 25 	lds	r24, 0x2594
    9206:	90 91 95 25 	lds	r25, 0x2595
    920a:	28 1b       	sub	r18, r24
    920c:	39 0b       	sbc	r19, r25
    920e:	44 27       	eor	r20, r20
    9210:	37 fd       	sbrc	r19, 7
    9212:	40 95       	com	r20
    9214:	54 2f       	mov	r21, r20

		return ulBufferLength;
	}
    9216:	b9 01       	movw	r22, r18
    9218:	ca 01       	movw	r24, r20
    921a:	08 95       	ret

0000921c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    921c:	0f 93       	push	r16
    921e:	1f 93       	push	r17
    9220:	cf 93       	push	r28
    9222:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9224:	80 91 5b 25 	lds	r24, 0x255B
    9228:	88 23       	and	r24, r24
    922a:	09 f0       	breq	.+2      	; 0x922e <vTaskIncrementTick+0x12>
    922c:	65 c0       	rjmp	.+202    	; 0x92f8 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
    922e:	80 91 59 25 	lds	r24, 0x2559
    9232:	90 91 5a 25 	lds	r25, 0x255A
    9236:	01 96       	adiw	r24, 0x01	; 1
    9238:	80 93 59 25 	sts	0x2559, r24
    923c:	90 93 5a 25 	sts	0x255A, r25
		if( xTickCount == ( portTickType ) 0 )
    9240:	80 91 59 25 	lds	r24, 0x2559
    9244:	90 91 5a 25 	lds	r25, 0x255A
    9248:	00 97       	sbiw	r24, 0x00	; 0
    924a:	09 f0       	breq	.+2      	; 0x924e <vTaskIncrementTick+0x32>
    924c:	42 c0       	rjmp	.+132    	; 0x92d2 <vTaskIncrementTick+0xb6>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    924e:	80 91 8c 25 	lds	r24, 0x258C
    9252:	90 91 8d 25 	lds	r25, 0x258D
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    9256:	20 91 8a 25 	lds	r18, 0x258A
    925a:	30 91 8b 25 	lds	r19, 0x258B
    925e:	20 93 8c 25 	sts	0x258C, r18
    9262:	30 93 8d 25 	sts	0x258D, r19
			pxOverflowDelayedTaskList = pxTemp;
    9266:	80 93 8a 25 	sts	0x258A, r24
    926a:	90 93 8b 25 	sts	0x258B, r25
			xNumOfOverflows++;
    926e:	80 91 58 25 	lds	r24, 0x2558
    9272:	8f 5f       	subi	r24, 0xFF	; 255
    9274:	80 93 58 25 	sts	0x2558, r24
    9278:	2c c0       	rjmp	.+88     	; 0x92d2 <vTaskIncrementTick+0xb6>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    927a:	20 91 59 25 	lds	r18, 0x2559
    927e:	30 91 5a 25 	lds	r19, 0x255A
    9282:	8a 81       	ldd	r24, Y+2	; 0x02
    9284:	9b 81       	ldd	r25, Y+3	; 0x03
    9286:	28 17       	cp	r18, r24
    9288:	39 07       	cpc	r19, r25
    928a:	d8 f1       	brcs	.+118    	; 0x9302 <vTaskIncrementTick+0xe6>
    928c:	8e 01       	movw	r16, r28
    928e:	0e 5f       	subi	r16, 0xFE	; 254
    9290:	1f 4f       	sbci	r17, 0xFF	; 255
    9292:	c8 01       	movw	r24, r16
    9294:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
    9298:	8c 89       	ldd	r24, Y+20	; 0x14
    929a:	9d 89       	ldd	r25, Y+21	; 0x15
    929c:	00 97       	sbiw	r24, 0x00	; 0
    929e:	21 f0       	breq	.+8      	; 0x92a8 <vTaskIncrementTick+0x8c>
    92a0:	ce 01       	movw	r24, r28
    92a2:	0c 96       	adiw	r24, 0x0c	; 12
    92a4:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
    92a8:	2e 89       	ldd	r18, Y+22	; 0x16
    92aa:	80 91 5c 25 	lds	r24, 0x255C
    92ae:	82 17       	cp	r24, r18
    92b0:	10 f4       	brcc	.+4      	; 0x92b6 <vTaskIncrementTick+0x9a>
    92b2:	20 93 5c 25 	sts	0x255C, r18
    92b6:	30 e0       	ldi	r19, 0x00	; 0
    92b8:	c9 01       	movw	r24, r18
    92ba:	43 e0       	ldi	r20, 0x03	; 3
    92bc:	88 0f       	add	r24, r24
    92be:	99 1f       	adc	r25, r25
    92c0:	4a 95       	dec	r20
    92c2:	e1 f7       	brne	.-8      	; 0x92bc <vTaskIncrementTick+0xa0>
    92c4:	82 0f       	add	r24, r18
    92c6:	93 1f       	adc	r25, r19
    92c8:	83 5a       	subi	r24, 0xA3	; 163
    92ca:	9a 4d       	sbci	r25, 0xDA	; 218
    92cc:	b8 01       	movw	r22, r16
    92ce:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
    92d2:	e0 91 8c 25 	lds	r30, 0x258C
    92d6:	f0 91 8d 25 	lds	r31, 0x258D
    92da:	80 81       	ld	r24, Z
    92dc:	88 23       	and	r24, r24
    92de:	89 f0       	breq	.+34     	; 0x9302 <vTaskIncrementTick+0xe6>
    92e0:	e0 91 8c 25 	lds	r30, 0x258C
    92e4:	f0 91 8d 25 	lds	r31, 0x258D
    92e8:	05 80       	ldd	r0, Z+5	; 0x05
    92ea:	f6 81       	ldd	r31, Z+6	; 0x06
    92ec:	e0 2d       	mov	r30, r0
    92ee:	c6 81       	ldd	r28, Z+6	; 0x06
    92f0:	d7 81       	ldd	r29, Z+7	; 0x07
    92f2:	20 97       	sbiw	r28, 0x00	; 0
    92f4:	11 f6       	brne	.-124    	; 0x927a <vTaskIncrementTick+0x5e>
    92f6:	05 c0       	rjmp	.+10     	; 0x9302 <vTaskIncrementTick+0xe6>
	}
	else
	{
		++uxMissedTicks;
    92f8:	80 91 93 25 	lds	r24, 0x2593
    92fc:	8f 5f       	subi	r24, 0xFF	; 255
    92fe:	80 93 93 25 	sts	0x2593, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    9302:	df 91       	pop	r29
    9304:	cf 91       	pop	r28
    9306:	1f 91       	pop	r17
    9308:	0f 91       	pop	r16
    930a:	08 95       	ret

0000930c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    930c:	ef 92       	push	r14
    930e:	ff 92       	push	r15
    9310:	0f 93       	push	r16
    9312:	1f 93       	push	r17
    9314:	df 93       	push	r29
    9316:	cf 93       	push	r28
    9318:	0f 92       	push	r0
    931a:	cd b7       	in	r28, 0x3d	; 61
    931c:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    931e:	0f b6       	in	r0, 0x3f	; 63
    9320:	f8 94       	cli
    9322:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    9324:	80 91 5b 25 	lds	r24, 0x255B
    9328:	81 50       	subi	r24, 0x01	; 1
    932a:	80 93 5b 25 	sts	0x255B, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    932e:	80 91 5b 25 	lds	r24, 0x255B
    9332:	88 23       	and	r24, r24
    9334:	09 f0       	breq	.+2      	; 0x9338 <xTaskResumeAll+0x2c>
    9336:	60 c0       	rjmp	.+192    	; 0x93f8 <xTaskResumeAll+0xec>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    9338:	80 91 c9 25 	lds	r24, 0x25C9
    933c:	88 23       	and	r24, r24
    933e:	09 f4       	brne	.+2      	; 0x9342 <xTaskResumeAll+0x36>
    9340:	5b c0       	rjmp	.+182    	; 0x93f8 <xTaskResumeAll+0xec>
    9342:	19 82       	std	Y+1, r1	; 0x01
    9344:	2f c0       	rjmp	.+94     	; 0x93a4 <xTaskResumeAll+0x98>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    9346:	c7 01       	movw	r24, r14
    9348:	0c 96       	adiw	r24, 0x0c	; 12
    934a:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    934e:	87 01       	movw	r16, r14
    9350:	0e 5f       	subi	r16, 0xFE	; 254
    9352:	1f 4f       	sbci	r17, 0xFF	; 255
    9354:	c8 01       	movw	r24, r16
    9356:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    935a:	d7 01       	movw	r26, r14
    935c:	56 96       	adiw	r26, 0x16	; 22
    935e:	2c 91       	ld	r18, X
    9360:	56 97       	sbiw	r26, 0x16	; 22
    9362:	80 91 5c 25 	lds	r24, 0x255C
    9366:	82 17       	cp	r24, r18
    9368:	10 f4       	brcc	.+4      	; 0x936e <xTaskResumeAll+0x62>
    936a:	20 93 5c 25 	sts	0x255C, r18
    936e:	30 e0       	ldi	r19, 0x00	; 0
    9370:	c9 01       	movw	r24, r18
    9372:	53 e0       	ldi	r21, 0x03	; 3
    9374:	88 0f       	add	r24, r24
    9376:	99 1f       	adc	r25, r25
    9378:	5a 95       	dec	r21
    937a:	e1 f7       	brne	.-8      	; 0x9374 <xTaskResumeAll+0x68>
    937c:	82 0f       	add	r24, r18
    937e:	93 1f       	adc	r25, r19
    9380:	83 5a       	subi	r24, 0xA3	; 163
    9382:	9a 4d       	sbci	r25, 0xDA	; 218
    9384:	b8 01       	movw	r22, r16
    9386:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    938a:	e0 91 55 25 	lds	r30, 0x2555
    938e:	f0 91 56 25 	lds	r31, 0x2556
    9392:	d7 01       	movw	r26, r14
    9394:	56 96       	adiw	r26, 0x16	; 22
    9396:	9c 91       	ld	r25, X
    9398:	56 97       	sbiw	r26, 0x16	; 22
    939a:	86 89       	ldd	r24, Z+22	; 0x16
    939c:	98 17       	cp	r25, r24
    939e:	10 f0       	brcs	.+4      	; 0x93a4 <xTaskResumeAll+0x98>
					{
						xYieldRequired = pdTRUE;
    93a0:	b1 e0       	ldi	r27, 0x01	; 1
    93a2:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    93a4:	80 91 78 25 	lds	r24, 0x2578
    93a8:	88 23       	and	r24, r24
    93aa:	49 f0       	breq	.+18     	; 0x93be <xTaskResumeAll+0xb2>
    93ac:	e0 91 7d 25 	lds	r30, 0x257D
    93b0:	f0 91 7e 25 	lds	r31, 0x257E
    93b4:	e6 80       	ldd	r14, Z+6	; 0x06
    93b6:	f7 80       	ldd	r15, Z+7	; 0x07
    93b8:	e1 14       	cp	r14, r1
    93ba:	f1 04       	cpc	r15, r1
    93bc:	21 f6       	brne	.-120    	; 0x9346 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    93be:	80 91 93 25 	lds	r24, 0x2593
    93c2:	88 23       	and	r24, r24
    93c4:	41 f4       	brne	.+16     	; 0x93d6 <xTaskResumeAll+0xca>
    93c6:	0b c0       	rjmp	.+22     	; 0x93de <xTaskResumeAll+0xd2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    93c8:	0e 94 0e 49 	call	0x921c	; 0x921c <vTaskIncrementTick>
						--uxMissedTicks;
    93cc:	80 91 93 25 	lds	r24, 0x2593
    93d0:	81 50       	subi	r24, 0x01	; 1
    93d2:	80 93 93 25 	sts	0x2593, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    93d6:	80 91 93 25 	lds	r24, 0x2593
    93da:	88 23       	and	r24, r24
    93dc:	a9 f7       	brne	.-22     	; 0x93c8 <xTaskResumeAll+0xbc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    93de:	e9 81       	ldd	r30, Y+1	; 0x01
    93e0:	e1 30       	cpi	r30, 0x01	; 1
    93e2:	21 f0       	breq	.+8      	; 0x93ec <xTaskResumeAll+0xe0>
    93e4:	80 91 57 25 	lds	r24, 0x2557
    93e8:	81 30       	cpi	r24, 0x01	; 1
    93ea:	31 f4       	brne	.+12     	; 0x93f8 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    93ec:	10 92 57 25 	sts	0x2557, r1
					portYIELD_WITHIN_API();
    93f0:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    93f4:	81 e0       	ldi	r24, 0x01	; 1
    93f6:	01 c0       	rjmp	.+2      	; 0x93fa <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    93f8:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
    93fa:	0f 90       	pop	r0
    93fc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    93fe:	0f 90       	pop	r0
    9400:	cf 91       	pop	r28
    9402:	df 91       	pop	r29
    9404:	1f 91       	pop	r17
    9406:	0f 91       	pop	r16
    9408:	ff 90       	pop	r15
    940a:	ef 90       	pop	r14
    940c:	08 95       	ret

0000940e <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
    940e:	1f 93       	push	r17
    9410:	cf 93       	push	r28
    9412:	df 93       	push	r29
    9414:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
    9416:	0e 94 c9 48 	call	0x9192	; 0x9192 <vTaskSuspendAll>
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
    941a:	18 82       	st	Y, r1
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
    941c:	ce 01       	movw	r24, r28
    941e:	60 e4       	ldi	r22, 0x40	; 64
    9420:	75 e2       	ldi	r23, 0x25	; 37
    9422:	0e 94 d0 56 	call	0xada0	; 0xada0 <strcat>

			uxQueue = uxTopUsedPriority + 1;
    9426:	10 91 96 25 	lds	r17, 0x2596
    942a:	1f 5f       	subi	r17, 0xFF	; 255

			do
			{
				uxQueue--;
    942c:	11 50       	subi	r17, 0x01	; 1

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    942e:	81 2f       	mov	r24, r17
    9430:	90 e0       	ldi	r25, 0x00	; 0
    9432:	bc 01       	movw	r22, r24
    9434:	e3 e0       	ldi	r30, 0x03	; 3
    9436:	66 0f       	add	r22, r22
    9438:	77 1f       	adc	r23, r23
    943a:	ea 95       	dec	r30
    943c:	e1 f7       	brne	.-8      	; 0x9436 <vTaskList+0x28>
    943e:	68 0f       	add	r22, r24
    9440:	79 1f       	adc	r23, r25
    9442:	63 5a       	subi	r22, 0xA3	; 163
    9444:	7a 4d       	sbci	r23, 0xDA	; 218
    9446:	fb 01       	movw	r30, r22
    9448:	80 81       	ld	r24, Z
    944a:	88 23       	and	r24, r24
    944c:	21 f0       	breq	.+8      	; 0x9456 <vTaskList+0x48>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
    944e:	ce 01       	movw	r24, r28
    9450:	42 e5       	ldi	r20, 0x52	; 82
    9452:	0e 94 93 45 	call	0x8b26	; 0x8b26 <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
    9456:	11 23       	and	r17, r17
    9458:	49 f7       	brne	.-46     	; 0x942c <vTaskList+0x1e>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
    945a:	e0 91 8c 25 	lds	r30, 0x258C
    945e:	f0 91 8d 25 	lds	r31, 0x258D
    9462:	80 81       	ld	r24, Z
    9464:	88 23       	and	r24, r24
    9466:	41 f0       	breq	.+16     	; 0x9478 <vTaskList+0x6a>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
    9468:	60 91 8c 25 	lds	r22, 0x258C
    946c:	70 91 8d 25 	lds	r23, 0x258D
    9470:	ce 01       	movw	r24, r28
    9472:	42 e4       	ldi	r20, 0x42	; 66
    9474:	0e 94 93 45 	call	0x8b26	; 0x8b26 <prvListTaskWithinSingleList>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
    9478:	e0 91 8a 25 	lds	r30, 0x258A
    947c:	f0 91 8b 25 	lds	r31, 0x258B
    9480:	80 81       	ld	r24, Z
    9482:	88 23       	and	r24, r24
    9484:	41 f0       	breq	.+16     	; 0x9496 <vTaskList+0x88>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
    9486:	60 91 8a 25 	lds	r22, 0x258A
    948a:	70 91 8b 25 	lds	r23, 0x258B
    948e:	ce 01       	movw	r24, r28
    9490:	42 e4       	ldi	r20, 0x42	; 66
    9492:	0e 94 93 45 	call	0x8b26	; 0x8b26 <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
    9496:	80 91 81 25 	lds	r24, 0x2581
    949a:	88 23       	and	r24, r24
    949c:	31 f0       	breq	.+12     	; 0x94aa <vTaskList+0x9c>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
    949e:	ce 01       	movw	r24, r28
    94a0:	61 e8       	ldi	r22, 0x81	; 129
    94a2:	75 e2       	ldi	r23, 0x25	; 37
    94a4:	43 e5       	ldi	r20, 0x53	; 83
    94a6:	0e 94 93 45 	call	0x8b26	; 0x8b26 <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
    94aa:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
	}
    94ae:	df 91       	pop	r29
    94b0:	cf 91       	pop	r28
    94b2:	1f 91       	pop	r17
    94b4:	08 95       	ret

000094b6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    94b6:	0f 93       	push	r16
    94b8:	1f 93       	push	r17
    94ba:	cf 93       	push	r28
    94bc:	df 93       	push	r29
    94be:	8c 01       	movw	r16, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    94c0:	00 97       	sbiw	r24, 0x00	; 0
    94c2:	89 f1       	breq	.+98     	; 0x9526 <vTaskDelay+0x70>
		{
			vTaskSuspendAll();
    94c4:	0e 94 c9 48 	call	0x9192	; 0x9192 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    94c8:	c0 91 59 25 	lds	r28, 0x2559
    94cc:	d0 91 5a 25 	lds	r29, 0x255A
    94d0:	c0 0f       	add	r28, r16
    94d2:	d1 1f       	adc	r29, r17

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    94d4:	80 91 55 25 	lds	r24, 0x2555
    94d8:	90 91 56 25 	lds	r25, 0x2556
    94dc:	02 96       	adiw	r24, 0x02	; 2
    94de:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    94e2:	e0 91 55 25 	lds	r30, 0x2555
    94e6:	f0 91 56 25 	lds	r31, 0x2556
    94ea:	c2 83       	std	Z+2, r28	; 0x02
    94ec:	d3 83       	std	Z+3, r29	; 0x03

				if( xTimeToWake < xTickCount )
    94ee:	80 91 59 25 	lds	r24, 0x2559
    94f2:	90 91 5a 25 	lds	r25, 0x255A
    94f6:	c8 17       	cp	r28, r24
    94f8:	d9 07       	cpc	r29, r25
    94fa:	28 f4       	brcc	.+10     	; 0x9506 <vTaskDelay+0x50>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    94fc:	80 91 8a 25 	lds	r24, 0x258A
    9500:	90 91 8b 25 	lds	r25, 0x258B
    9504:	04 c0       	rjmp	.+8      	; 0x950e <vTaskDelay+0x58>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9506:	80 91 8c 25 	lds	r24, 0x258C
    950a:	90 91 8d 25 	lds	r25, 0x258D
    950e:	60 91 55 25 	lds	r22, 0x2555
    9512:	70 91 56 25 	lds	r23, 0x2556
    9516:	6e 5f       	subi	r22, 0xFE	; 254
    9518:	7f 4f       	sbci	r23, 0xFF	; 255
    951a:	0e 94 27 50 	call	0xa04e	; 0xa04e <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    951e:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    9522:	88 23       	and	r24, r24
    9524:	11 f4       	brne	.+4      	; 0x952a <vTaskDelay+0x74>
		{
			portYIELD_WITHIN_API();
    9526:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
		}
	}
    952a:	df 91       	pop	r29
    952c:	cf 91       	pop	r28
    952e:	1f 91       	pop	r17
    9530:	0f 91       	pop	r16
    9532:	08 95       	ret

00009534 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    9534:	0f 93       	push	r16
    9536:	1f 93       	push	r17
    9538:	cf 93       	push	r28
    953a:	df 93       	push	r29
    953c:	8c 01       	movw	r16, r24
    953e:	eb 01       	movw	r28, r22
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
    9540:	0e 94 c9 48 	call	0x9192	; 0x9192 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    9544:	f8 01       	movw	r30, r16
    9546:	80 81       	ld	r24, Z
    9548:	91 81       	ldd	r25, Z+1	; 0x01
    954a:	c8 0f       	add	r28, r24
    954c:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    954e:	20 91 59 25 	lds	r18, 0x2559
    9552:	30 91 5a 25 	lds	r19, 0x255A
    9556:	28 17       	cp	r18, r24
    9558:	39 07       	cpc	r19, r25
    955a:	20 f4       	brcc	.+8      	; 0x9564 <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    955c:	c8 17       	cp	r28, r24
    955e:	d9 07       	cpc	r29, r25
    9560:	60 f4       	brcc	.+24     	; 0x957a <vTaskDelayUntil+0x46>
    9562:	03 c0       	rjmp	.+6      	; 0x956a <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    9564:	c8 17       	cp	r28, r24
    9566:	d9 07       	cpc	r29, r25
    9568:	50 f0       	brcs	.+20     	; 0x957e <vTaskDelayUntil+0x4a>
    956a:	80 91 59 25 	lds	r24, 0x2559
    956e:	90 91 5a 25 	lds	r25, 0x255A
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    9572:	21 e0       	ldi	r18, 0x01	; 1
    9574:	8c 17       	cp	r24, r28
    9576:	9d 07       	cpc	r25, r29
    9578:	18 f0       	brcs	.+6      	; 0x9580 <vTaskDelayUntil+0x4c>
    957a:	20 e0       	ldi	r18, 0x00	; 0
    957c:	01 c0       	rjmp	.+2      	; 0x9580 <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    957e:	21 e0       	ldi	r18, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    9580:	f8 01       	movw	r30, r16
    9582:	c0 83       	st	Z, r28
    9584:	d1 83       	std	Z+1, r29	; 0x01

			if( xShouldDelay )
    9586:	22 23       	and	r18, r18
    9588:	29 f1       	breq	.+74     	; 0x95d4 <vTaskDelayUntil+0xa0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    958a:	80 91 55 25 	lds	r24, 0x2555
    958e:	90 91 56 25 	lds	r25, 0x2556
    9592:	02 96       	adiw	r24, 0x02	; 2
    9594:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    9598:	e0 91 55 25 	lds	r30, 0x2555
    959c:	f0 91 56 25 	lds	r31, 0x2556
    95a0:	c2 83       	std	Z+2, r28	; 0x02
    95a2:	d3 83       	std	Z+3, r29	; 0x03

				if( xTimeToWake < xTickCount )
    95a4:	80 91 59 25 	lds	r24, 0x2559
    95a8:	90 91 5a 25 	lds	r25, 0x255A
    95ac:	c8 17       	cp	r28, r24
    95ae:	d9 07       	cpc	r29, r25
    95b0:	28 f4       	brcc	.+10     	; 0x95bc <vTaskDelayUntil+0x88>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    95b2:	80 91 8a 25 	lds	r24, 0x258A
    95b6:	90 91 8b 25 	lds	r25, 0x258B
    95ba:	04 c0       	rjmp	.+8      	; 0x95c4 <vTaskDelayUntil+0x90>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    95bc:	80 91 8c 25 	lds	r24, 0x258C
    95c0:	90 91 8d 25 	lds	r25, 0x258D
    95c4:	60 91 55 25 	lds	r22, 0x2555
    95c8:	70 91 56 25 	lds	r23, 0x2556
    95cc:	6e 5f       	subi	r22, 0xFE	; 254
    95ce:	7f 4f       	sbci	r23, 0xFF	; 255
    95d0:	0e 94 27 50 	call	0xa04e	; 0xa04e <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    95d4:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    95d8:	88 23       	and	r24, r24
    95da:	11 f4       	brne	.+4      	; 0x95e0 <vTaskDelayUntil+0xac>
		{
			portYIELD_WITHIN_API();
    95dc:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
		}
	}
    95e0:	df 91       	pop	r29
    95e2:	cf 91       	pop	r28
    95e4:	1f 91       	pop	r17
    95e6:	0f 91       	pop	r16
    95e8:	08 95       	ret

000095ea <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    95ea:	80 91 5b 25 	lds	r24, 0x255B
    95ee:	88 23       	and	r24, r24
    95f0:	49 f0       	breq	.+18     	; 0x9604 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    95f2:	81 e0       	ldi	r24, 0x01	; 1
    95f4:	80 93 57 25 	sts	0x2557, r24
		return;
    95f8:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    95fa:	80 91 5c 25 	lds	r24, 0x255C
    95fe:	81 50       	subi	r24, 0x01	; 1
    9600:	80 93 5c 25 	sts	0x255C, r24

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    9604:	80 91 5c 25 	lds	r24, 0x255C
    9608:	90 e0       	ldi	r25, 0x00	; 0
    960a:	fc 01       	movw	r30, r24
    960c:	23 e0       	ldi	r18, 0x03	; 3
    960e:	ee 0f       	add	r30, r30
    9610:	ff 1f       	adc	r31, r31
    9612:	2a 95       	dec	r18
    9614:	e1 f7       	brne	.-8      	; 0x960e <vTaskSwitchContext+0x24>
    9616:	e8 0f       	add	r30, r24
    9618:	f9 1f       	adc	r31, r25
    961a:	e3 5a       	subi	r30, 0xA3	; 163
    961c:	fa 4d       	sbci	r31, 0xDA	; 218
    961e:	80 81       	ld	r24, Z
    9620:	88 23       	and	r24, r24
    9622:	59 f3       	breq	.-42     	; 0x95fa <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    9624:	80 91 5c 25 	lds	r24, 0x255C
    9628:	90 e0       	ldi	r25, 0x00	; 0
    962a:	9c 01       	movw	r18, r24
    962c:	b3 e0       	ldi	r27, 0x03	; 3
    962e:	22 0f       	add	r18, r18
    9630:	33 1f       	adc	r19, r19
    9632:	ba 95       	dec	r27
    9634:	e1 f7       	brne	.-8      	; 0x962e <vTaskSwitchContext+0x44>
    9636:	28 0f       	add	r18, r24
    9638:	39 1f       	adc	r19, r25
    963a:	f9 01       	movw	r30, r18
    963c:	e3 5a       	subi	r30, 0xA3	; 163
    963e:	fa 4d       	sbci	r31, 0xDA	; 218
    9640:	a1 81       	ldd	r26, Z+1	; 0x01
    9642:	b2 81       	ldd	r27, Z+2	; 0x02
    9644:	12 96       	adiw	r26, 0x02	; 2
    9646:	0d 90       	ld	r0, X+
    9648:	bc 91       	ld	r27, X
    964a:	a0 2d       	mov	r26, r0
    964c:	a1 83       	std	Z+1, r26	; 0x01
    964e:	b2 83       	std	Z+2, r27	; 0x02
    9650:	20 5a       	subi	r18, 0xA0	; 160
    9652:	3a 4d       	sbci	r19, 0xDA	; 218
    9654:	a2 17       	cp	r26, r18
    9656:	b3 07       	cpc	r27, r19
    9658:	31 f4       	brne	.+12     	; 0x9666 <vTaskSwitchContext+0x7c>
    965a:	12 96       	adiw	r26, 0x02	; 2
    965c:	2d 91       	ld	r18, X+
    965e:	3c 91       	ld	r19, X
    9660:	13 97       	sbiw	r26, 0x03	; 3
    9662:	21 83       	std	Z+1, r18	; 0x01
    9664:	32 83       	std	Z+2, r19	; 0x02
    9666:	fc 01       	movw	r30, r24
    9668:	a3 e0       	ldi	r26, 0x03	; 3
    966a:	ee 0f       	add	r30, r30
    966c:	ff 1f       	adc	r31, r31
    966e:	aa 95       	dec	r26
    9670:	e1 f7       	brne	.-8      	; 0x966a <vTaskSwitchContext+0x80>
    9672:	e8 0f       	add	r30, r24
    9674:	f9 1f       	adc	r31, r25
    9676:	e3 5a       	subi	r30, 0xA3	; 163
    9678:	fa 4d       	sbci	r31, 0xDA	; 218
    967a:	01 80       	ldd	r0, Z+1	; 0x01
    967c:	f2 81       	ldd	r31, Z+2	; 0x02
    967e:	e0 2d       	mov	r30, r0
    9680:	86 81       	ldd	r24, Z+6	; 0x06
    9682:	97 81       	ldd	r25, Z+7	; 0x07
    9684:	80 93 55 25 	sts	0x2555, r24
    9688:	90 93 56 25 	sts	0x2556, r25

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
    968c:	80 91 8e 25 	lds	r24, 0x258E
    9690:	88 23       	and	r24, r24
    9692:	09 f4       	brne	.+2      	; 0x9696 <vTaskSwitchContext+0xac>
    9694:	4c c0       	rjmp	.+152    	; 0x972e <vTaskSwitchContext+0x144>
    9696:	e0 91 55 25 	lds	r30, 0x2555
    969a:	f0 91 56 25 	lds	r31, 0x2556
    969e:	90 91 43 25 	lds	r25, 0x2543
    96a2:	83 a1       	ldd	r24, Z+35	; 0x23
    96a4:	98 17       	cp	r25, r24
    96a6:	09 f4       	brne	.+2      	; 0x96aa <vTaskSwitchContext+0xc0>
    96a8:	42 c0       	rjmp	.+132    	; 0x972e <vTaskSwitchContext+0x144>
    96aa:	80 91 8f 25 	lds	r24, 0x258F
    96ae:	90 91 90 25 	lds	r25, 0x2590
    96b2:	08 96       	adiw	r24, 0x08	; 8
    96b4:	20 91 91 25 	lds	r18, 0x2591
    96b8:	30 91 92 25 	lds	r19, 0x2592
    96bc:	82 17       	cp	r24, r18
    96be:	93 07       	cpc	r25, r19
    96c0:	a0 f5       	brcc	.+104    	; 0x972a <vTaskSwitchContext+0x140>
    96c2:	e0 91 55 25 	lds	r30, 0x2555
    96c6:	f0 91 56 25 	lds	r31, 0x2556
    96ca:	83 a1       	ldd	r24, Z+35	; 0x23
    96cc:	80 93 43 25 	sts	0x2543, r24
    96d0:	e0 91 8f 25 	lds	r30, 0x258F
    96d4:	f0 91 90 25 	lds	r31, 0x2590
    96d8:	20 91 59 25 	lds	r18, 0x2559
    96dc:	30 91 5a 25 	lds	r19, 0x255A
    96e0:	40 e0       	ldi	r20, 0x00	; 0
    96e2:	50 e0       	ldi	r21, 0x00	; 0
    96e4:	20 83       	st	Z, r18
    96e6:	31 83       	std	Z+1, r19	; 0x01
    96e8:	42 83       	std	Z+2, r20	; 0x02
    96ea:	53 83       	std	Z+3, r21	; 0x03
    96ec:	20 91 8f 25 	lds	r18, 0x258F
    96f0:	30 91 90 25 	lds	r19, 0x2590
    96f4:	2c 5f       	subi	r18, 0xFC	; 252
    96f6:	3f 4f       	sbci	r19, 0xFF	; 255
    96f8:	20 93 8f 25 	sts	0x258F, r18
    96fc:	30 93 90 25 	sts	0x2590, r19
    9700:	e0 91 8f 25 	lds	r30, 0x258F
    9704:	f0 91 90 25 	lds	r31, 0x2590
    9708:	90 e0       	ldi	r25, 0x00	; 0
    970a:	a0 e0       	ldi	r26, 0x00	; 0
    970c:	b0 e0       	ldi	r27, 0x00	; 0
    970e:	80 83       	st	Z, r24
    9710:	91 83       	std	Z+1, r25	; 0x01
    9712:	a2 83       	std	Z+2, r26	; 0x02
    9714:	b3 83       	std	Z+3, r27	; 0x03
    9716:	80 91 8f 25 	lds	r24, 0x258F
    971a:	90 91 90 25 	lds	r25, 0x2590
    971e:	04 96       	adiw	r24, 0x04	; 4
    9720:	80 93 8f 25 	sts	0x258F, r24
    9724:	90 93 90 25 	sts	0x2590, r25
    9728:	08 95       	ret
    972a:	10 92 8e 25 	sts	0x258E, r1
    972e:	08 95       	ret

00009730 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    9730:	cf 93       	push	r28
    9732:	df 93       	push	r29
    9734:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    9736:	60 91 55 25 	lds	r22, 0x2555
    973a:	70 91 56 25 	lds	r23, 0x2556
    973e:	64 5f       	subi	r22, 0xF4	; 244
    9740:	7f 4f       	sbci	r23, 0xFF	; 255
    9742:	0e 94 27 50 	call	0xa04e	; 0xa04e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9746:	80 91 55 25 	lds	r24, 0x2555
    974a:	90 91 56 25 	lds	r25, 0x2556
    974e:	02 96       	adiw	r24, 0x02	; 2
    9750:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    9754:	8f ef       	ldi	r24, 0xFF	; 255
    9756:	cf 3f       	cpi	r28, 0xFF	; 255
    9758:	d8 07       	cpc	r29, r24
    975a:	59 f4       	brne	.+22     	; 0x9772 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    975c:	60 91 55 25 	lds	r22, 0x2555
    9760:	70 91 56 25 	lds	r23, 0x2556
    9764:	6e 5f       	subi	r22, 0xFE	; 254
    9766:	7f 4f       	sbci	r23, 0xFF	; 255
    9768:	81 e8       	ldi	r24, 0x81	; 129
    976a:	95 e2       	ldi	r25, 0x25	; 37
    976c:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
    9770:	24 c0       	rjmp	.+72     	; 0x97ba <vTaskPlaceOnEventList+0x8a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    9772:	80 91 59 25 	lds	r24, 0x2559
    9776:	90 91 5a 25 	lds	r25, 0x255A
    977a:	8c 0f       	add	r24, r28
    977c:	9d 1f       	adc	r25, r29

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    977e:	e0 91 55 25 	lds	r30, 0x2555
    9782:	f0 91 56 25 	lds	r31, 0x2556
    9786:	82 83       	std	Z+2, r24	; 0x02
    9788:	93 83       	std	Z+3, r25	; 0x03

			if( xTimeToWake < xTickCount )
    978a:	20 91 59 25 	lds	r18, 0x2559
    978e:	30 91 5a 25 	lds	r19, 0x255A
    9792:	82 17       	cp	r24, r18
    9794:	93 07       	cpc	r25, r19
    9796:	28 f4       	brcc	.+10     	; 0x97a2 <vTaskPlaceOnEventList+0x72>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9798:	80 91 8a 25 	lds	r24, 0x258A
    979c:	90 91 8b 25 	lds	r25, 0x258B
    97a0:	04 c0       	rjmp	.+8      	; 0x97aa <vTaskPlaceOnEventList+0x7a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    97a2:	80 91 8c 25 	lds	r24, 0x258C
    97a6:	90 91 8d 25 	lds	r25, 0x258D
    97aa:	60 91 55 25 	lds	r22, 0x2555
    97ae:	70 91 56 25 	lds	r23, 0x2556
    97b2:	6e 5f       	subi	r22, 0xFE	; 254
    97b4:	7f 4f       	sbci	r23, 0xFF	; 255
    97b6:	0e 94 27 50 	call	0xa04e	; 0xa04e <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    97ba:	df 91       	pop	r29
    97bc:	cf 91       	pop	r28
    97be:	08 95       	ret

000097c0 <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    97c0:	0f 93       	push	r16
    97c2:	1f 93       	push	r17
    97c4:	cf 93       	push	r28
    97c6:	df 93       	push	r29
    97c8:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    97ca:	80 81       	ld	r24, Z
    97cc:	88 23       	and	r24, r24
    97ce:	31 f0       	breq	.+12     	; 0x97dc <xTaskRemoveFromEventList+0x1c>
    97d0:	05 80       	ldd	r0, Z+5	; 0x05
    97d2:	f6 81       	ldd	r31, Z+6	; 0x06
    97d4:	e0 2d       	mov	r30, r0
    97d6:	c6 81       	ldd	r28, Z+6	; 0x06
    97d8:	d7 81       	ldd	r29, Z+7	; 0x07
    97da:	02 c0       	rjmp	.+4      	; 0x97e0 <xTaskRemoveFromEventList+0x20>
    97dc:	c0 e0       	ldi	r28, 0x00	; 0
    97de:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    97e0:	8e 01       	movw	r16, r28
    97e2:	04 5f       	subi	r16, 0xF4	; 244
    97e4:	1f 4f       	sbci	r17, 0xFF	; 255
    97e6:	c8 01       	movw	r24, r16
    97e8:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    97ec:	80 91 5b 25 	lds	r24, 0x255B
    97f0:	88 23       	and	r24, r24
    97f2:	c9 f4       	brne	.+50     	; 0x9826 <xTaskRemoveFromEventList+0x66>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    97f4:	8e 01       	movw	r16, r28
    97f6:	0e 5f       	subi	r16, 0xFE	; 254
    97f8:	1f 4f       	sbci	r17, 0xFF	; 255
    97fa:	c8 01       	movw	r24, r16
    97fc:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    9800:	2e 89       	ldd	r18, Y+22	; 0x16
    9802:	80 91 5c 25 	lds	r24, 0x255C
    9806:	82 17       	cp	r24, r18
    9808:	10 f4       	brcc	.+4      	; 0x980e <xTaskRemoveFromEventList+0x4e>
    980a:	20 93 5c 25 	sts	0x255C, r18
    980e:	30 e0       	ldi	r19, 0x00	; 0
    9810:	c9 01       	movw	r24, r18
    9812:	43 e0       	ldi	r20, 0x03	; 3
    9814:	88 0f       	add	r24, r24
    9816:	99 1f       	adc	r25, r25
    9818:	4a 95       	dec	r20
    981a:	e1 f7       	brne	.-8      	; 0x9814 <xTaskRemoveFromEventList+0x54>
    981c:	82 0f       	add	r24, r18
    981e:	93 1f       	adc	r25, r19
    9820:	83 5a       	subi	r24, 0xA3	; 163
    9822:	9a 4d       	sbci	r25, 0xDA	; 218
    9824:	02 c0       	rjmp	.+4      	; 0x982a <xTaskRemoveFromEventList+0x6a>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    9826:	88 e7       	ldi	r24, 0x78	; 120
    9828:	95 e2       	ldi	r25, 0x25	; 37
    982a:	b8 01       	movw	r22, r16
    982c:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9830:	e0 91 55 25 	lds	r30, 0x2555
    9834:	f0 91 56 25 	lds	r31, 0x2556
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    9838:	81 e0       	ldi	r24, 0x01	; 1
    983a:	2e 89       	ldd	r18, Y+22	; 0x16
    983c:	96 89       	ldd	r25, Z+22	; 0x16
    983e:	29 17       	cp	r18, r25
    9840:	08 f4       	brcc	.+2      	; 0x9844 <xTaskRemoveFromEventList+0x84>
    9842:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    9844:	df 91       	pop	r29
    9846:	cf 91       	pop	r28
    9848:	1f 91       	pop	r17
    984a:	0f 91       	pop	r16
    984c:	08 95       	ret

0000984e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    984e:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    9850:	80 91 58 25 	lds	r24, 0x2558
    9854:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    9856:	80 91 59 25 	lds	r24, 0x2559
    985a:	90 91 5a 25 	lds	r25, 0x255A
    985e:	81 83       	std	Z+1, r24	; 0x01
    9860:	92 83       	std	Z+2, r25	; 0x02
}
    9862:	08 95       	ret

00009864 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    9864:	fc 01       	movw	r30, r24
    9866:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    9868:	0f b6       	in	r0, 0x3f	; 63
    986a:	f8 94       	cli
    986c:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    986e:	2d 91       	ld	r18, X+
    9870:	3c 91       	ld	r19, X
    9872:	11 97       	sbiw	r26, 0x01	; 1
    9874:	8f ef       	ldi	r24, 0xFF	; 255
    9876:	2f 3f       	cpi	r18, 0xFF	; 255
    9878:	38 07       	cpc	r19, r24
    987a:	69 f1       	breq	.+90     	; 0x98d6 <xTaskCheckForTimeOut+0x72>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    987c:	90 91 58 25 	lds	r25, 0x2558
    9880:	80 81       	ld	r24, Z
    9882:	98 17       	cp	r25, r24
    9884:	49 f0       	breq	.+18     	; 0x9898 <xTaskCheckForTimeOut+0x34>
    9886:	40 91 59 25 	lds	r20, 0x2559
    988a:	50 91 5a 25 	lds	r21, 0x255A
    988e:	81 81       	ldd	r24, Z+1	; 0x01
    9890:	92 81       	ldd	r25, Z+2	; 0x02
    9892:	48 17       	cp	r20, r24
    9894:	59 07       	cpc	r21, r25
    9896:	08 f5       	brcc	.+66     	; 0x98da <xTaskCheckForTimeOut+0x76>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    9898:	40 91 59 25 	lds	r20, 0x2559
    989c:	50 91 5a 25 	lds	r21, 0x255A
    98a0:	81 81       	ldd	r24, Z+1	; 0x01
    98a2:	92 81       	ldd	r25, Z+2	; 0x02
    98a4:	48 1b       	sub	r20, r24
    98a6:	59 0b       	sbc	r21, r25
    98a8:	42 17       	cp	r20, r18
    98aa:	53 07       	cpc	r21, r19
    98ac:	b0 f4       	brcc	.+44     	; 0x98da <xTaskCheckForTimeOut+0x76>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    98ae:	40 91 59 25 	lds	r20, 0x2559
    98b2:	50 91 5a 25 	lds	r21, 0x255A
    98b6:	84 1b       	sub	r24, r20
    98b8:	95 0b       	sbc	r25, r21
    98ba:	82 0f       	add	r24, r18
    98bc:	93 1f       	adc	r25, r19
    98be:	8d 93       	st	X+, r24
    98c0:	9c 93       	st	X, r25
    98c2:	11 97       	sbiw	r26, 0x01	; 1
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    98c4:	80 91 58 25 	lds	r24, 0x2558
    98c8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    98ca:	80 91 59 25 	lds	r24, 0x2559
    98ce:	90 91 5a 25 	lds	r25, 0x255A
    98d2:	81 83       	std	Z+1, r24	; 0x01
    98d4:	92 83       	std	Z+2, r25	; 0x02
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    98d6:	80 e0       	ldi	r24, 0x00	; 0
    98d8:	01 c0       	rjmp	.+2      	; 0x98dc <xTaskCheckForTimeOut+0x78>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    98da:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portEXIT_CRITICAL();
    98dc:	0f 90       	pop	r0
    98de:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    98e0:	08 95       	ret

000098e2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    98e2:	81 e0       	ldi	r24, 0x01	; 1
    98e4:	80 93 57 25 	sts	0x2557, r24
}
    98e8:	08 95       	ret

000098ea <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    98ea:	0f 93       	push	r16
    98ec:	1f 93       	push	r17
    98ee:	cf 93       	push	r28
    98f0:	df 93       	push	r29
    98f2:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    98f4:	0f b6       	in	r0, 0x3f	; 63
    98f6:	f8 94       	cli
    98f8:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    98fa:	8c 01       	movw	r16, r24
    98fc:	0f 5e       	subi	r16, 0xEF	; 239
    98fe:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    9900:	0d c0       	rjmp	.+26     	; 0x991c <prvUnlockQueue+0x32>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9902:	89 89       	ldd	r24, Y+17	; 0x11
    9904:	88 23       	and	r24, r24
    9906:	69 f0       	breq	.+26     	; 0x9922 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    9908:	c8 01       	movw	r24, r16
    990a:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <xTaskRemoveFromEventList>
    990e:	88 23       	and	r24, r24
    9910:	11 f0       	breq	.+4      	; 0x9916 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    9912:	0e 94 71 4c 	call	0x98e2	; 0x98e2 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    9916:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9918:	81 50       	subi	r24, 0x01	; 1
    991a:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    991c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    991e:	18 16       	cp	r1, r24
    9920:	84 f3       	brlt	.-32     	; 0x9902 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    9922:	8f ef       	ldi	r24, 0xFF	; 255
    9924:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    9926:	0f 90       	pop	r0
    9928:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    992a:	0f b6       	in	r0, 0x3f	; 63
    992c:	f8 94       	cli
    992e:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    9930:	8e 01       	movw	r16, r28
    9932:	08 5f       	subi	r16, 0xF8	; 248
    9934:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    9936:	0d c0       	rjmp	.+26     	; 0x9952 <prvUnlockQueue+0x68>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    9938:	88 85       	ldd	r24, Y+8	; 0x08
    993a:	88 23       	and	r24, r24
    993c:	69 f0       	breq	.+26     	; 0x9958 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    993e:	c8 01       	movw	r24, r16
    9940:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <xTaskRemoveFromEventList>
    9944:	88 23       	and	r24, r24
    9946:	11 f0       	breq	.+4      	; 0x994c <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    9948:	0e 94 71 4c 	call	0x98e2	; 0x98e2 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    994c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    994e:	81 50       	subi	r24, 0x01	; 1
    9950:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    9952:	8d 8d       	ldd	r24, Y+29	; 0x1d
    9954:	18 16       	cp	r1, r24
    9956:	84 f3       	brlt	.-32     	; 0x9938 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    9958:	8f ef       	ldi	r24, 0xFF	; 255
    995a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    995c:	0f 90       	pop	r0
    995e:	0f be       	out	0x3f, r0	; 63
}
    9960:	df 91       	pop	r29
    9962:	cf 91       	pop	r28
    9964:	1f 91       	pop	r17
    9966:	0f 91       	pop	r16
    9968:	08 95       	ret

0000996a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    996a:	af 92       	push	r10
    996c:	bf 92       	push	r11
    996e:	cf 92       	push	r12
    9970:	df 92       	push	r13
    9972:	ef 92       	push	r14
    9974:	ff 92       	push	r15
    9976:	0f 93       	push	r16
    9978:	1f 93       	push	r17
    997a:	cf 93       	push	r28
    997c:	df 93       	push	r29
    997e:	b8 2e       	mov	r11, r24
    9980:	a6 2e       	mov	r10, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    9982:	88 23       	and	r24, r24
    9984:	09 f4       	brne	.+2      	; 0x9988 <xQueueCreate+0x1e>
    9986:	43 c0       	rjmp	.+134    	; 0x9a0e <xQueueCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    9988:	8f e1       	ldi	r24, 0x1F	; 31
    998a:	90 e0       	ldi	r25, 0x00	; 0
    998c:	0e 94 5b 52 	call	0xa4b6	; 0xa4b6 <pvPortMalloc>
    9990:	e8 2e       	mov	r14, r24
    9992:	e7 01       	movw	r28, r14
    9994:	7e 01       	movw	r14, r28
    9996:	f9 2e       	mov	r15, r25
    9998:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
    999a:	20 97       	sbiw	r28, 0x00	; 0
    999c:	d1 f1       	breq	.+116    	; 0x9a12 <xQueueCreate+0xa8>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    999e:	0b 2d       	mov	r16, r11
    99a0:	10 e0       	ldi	r17, 0x00	; 0
    99a2:	ca 2c       	mov	r12, r10
    99a4:	dd 24       	eor	r13, r13
    99a6:	c0 9e       	mul	r12, r16
    99a8:	70 01       	movw	r14, r0
    99aa:	c1 9e       	mul	r12, r17
    99ac:	f0 0c       	add	r15, r0
    99ae:	d0 9e       	mul	r13, r16
    99b0:	f0 0c       	add	r15, r0
    99b2:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    99b4:	c7 01       	movw	r24, r14
    99b6:	01 96       	adiw	r24, 0x01	; 1
    99b8:	0e 94 5b 52 	call	0xa4b6	; 0xa4b6 <pvPortMalloc>
    99bc:	88 83       	st	Y, r24
    99be:	99 83       	std	Y+1, r25	; 0x01
			if( pxNewQueue->pcHead != NULL )
    99c0:	00 97       	sbiw	r24, 0x00	; 0
    99c2:	11 f1       	breq	.+68     	; 0x9a08 <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    99c4:	e8 0e       	add	r14, r24
    99c6:	f9 1e       	adc	r15, r25
    99c8:	ea 82       	std	Y+2, r14	; 0x02
    99ca:	fb 82       	std	Y+3, r15	; 0x03
				pxNewQueue->uxMessagesWaiting = 0;
    99cc:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    99ce:	8c 83       	std	Y+4, r24	; 0x04
    99d0:	9d 83       	std	Y+5, r25	; 0x05
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    99d2:	01 50       	subi	r16, 0x01	; 1
    99d4:	10 40       	sbci	r17, 0x00	; 0
    99d6:	0c 9d       	mul	r16, r12
    99d8:	a0 01       	movw	r20, r0
    99da:	0d 9d       	mul	r16, r13
    99dc:	50 0d       	add	r21, r0
    99de:	1c 9d       	mul	r17, r12
    99e0:	50 0d       	add	r21, r0
    99e2:	11 24       	eor	r1, r1
    99e4:	48 0f       	add	r20, r24
    99e6:	59 1f       	adc	r21, r25
    99e8:	4e 83       	std	Y+6, r20	; 0x06
    99ea:	5f 83       	std	Y+7, r21	; 0x07
				pxNewQueue->uxLength = uxQueueLength;
    99ec:	bb 8e       	std	Y+27, r11	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    99ee:	ac 8e       	std	Y+28, r10	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    99f0:	8f ef       	ldi	r24, 0xFF	; 255
    99f2:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    99f4:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    99f6:	ce 01       	movw	r24, r28
    99f8:	08 96       	adiw	r24, 0x08	; 8
    99fa:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    99fe:	ce 01       	movw	r24, r28
    9a00:	41 96       	adiw	r24, 0x11	; 17
    9a02:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    9a06:	05 c0       	rjmp	.+10     	; 0x9a12 <xQueueCreate+0xa8>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    9a08:	ce 01       	movw	r24, r28
    9a0a:	0e 94 84 52 	call	0xa508	; 0xa508 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    9a0e:	c0 e0       	ldi	r28, 0x00	; 0
    9a10:	d0 e0       	ldi	r29, 0x00	; 0
}
    9a12:	ce 01       	movw	r24, r28
    9a14:	df 91       	pop	r29
    9a16:	cf 91       	pop	r28
    9a18:	1f 91       	pop	r17
    9a1a:	0f 91       	pop	r16
    9a1c:	ff 90       	pop	r15
    9a1e:	ef 90       	pop	r14
    9a20:	df 90       	pop	r13
    9a22:	cf 90       	pop	r12
    9a24:	bf 90       	pop	r11
    9a26:	af 90       	pop	r10
    9a28:	08 95       	ret

00009a2a <xQueueCreateExternal>:

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    9a2a:	cf 92       	push	r12
    9a2c:	df 92       	push	r13
    9a2e:	ef 92       	push	r14
    9a30:	ff 92       	push	r15
    9a32:	1f 93       	push	r17
    9a34:	df 93       	push	r29
    9a36:	cf 93       	push	r28
    9a38:	00 d0       	rcall	.+0      	; 0x9a3a <xQueueCreateExternal+0x10>
    9a3a:	cd b7       	in	r28, 0x3d	; 61
    9a3c:	de b7       	in	r29, 0x3e	; 62
    9a3e:	18 2f       	mov	r17, r24
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    9a40:	88 23       	and	r24, r24
    9a42:	09 f4       	brne	.+2      	; 0x9a46 <xQueueCreateExternal+0x1c>
    9a44:	56 c0       	rjmp	.+172    	; 0x9af2 <xQueueCreateExternal+0xc8>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    9a46:	8f e1       	ldi	r24, 0x1F	; 31
    9a48:	90 e0       	ldi	r25, 0x00	; 0
    9a4a:	4a 83       	std	Y+2, r20	; 0x02
    9a4c:	5b 83       	std	Y+3, r21	; 0x03
    9a4e:	69 83       	std	Y+1, r22	; 0x01
    9a50:	0e 94 5b 52 	call	0xa4b6	; 0xa4b6 <pvPortMalloc>
    9a54:	c8 2e       	mov	r12, r24
    9a56:	d9 2e       	mov	r13, r25
		if( pxNewQueue != NULL )
    9a58:	4a 81       	ldd	r20, Y+2	; 0x02
    9a5a:	5b 81       	ldd	r21, Y+3	; 0x03
    9a5c:	69 81       	ldd	r22, Y+1	; 0x01
    9a5e:	c1 14       	cp	r12, r1
    9a60:	d1 04       	cpc	r13, r1
    9a62:	09 f4       	brne	.+2      	; 0x9a66 <xQueueCreateExternal+0x3c>
    9a64:	48 c0       	rjmp	.+144    	; 0x9af6 <xQueueCreateExternal+0xcc>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    9a66:	9a 01       	movw	r18, r20
    9a68:	d6 01       	movw	r26, r12
    9a6a:	2d 93       	st	X+, r18
    9a6c:	3c 93       	st	X, r19
    9a6e:	11 97       	sbiw	r26, 0x01	; 1
			if( pxNewQueue->pcHead != NULL )
    9a70:	21 15       	cp	r18, r1
    9a72:	31 05       	cpc	r19, r1
    9a74:	d9 f1       	breq	.+118    	; 0x9aec <xQueueCreateExternal+0xc2>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    9a76:	e1 2f       	mov	r30, r17
    9a78:	f0 e0       	ldi	r31, 0x00	; 0
    9a7a:	86 2f       	mov	r24, r22
    9a7c:	90 e0       	ldi	r25, 0x00	; 0
    9a7e:	8e 9f       	mul	r24, r30
    9a80:	a0 01       	movw	r20, r0
    9a82:	8f 9f       	mul	r24, r31
    9a84:	50 0d       	add	r21, r0
    9a86:	9e 9f       	mul	r25, r30
    9a88:	50 0d       	add	r21, r0
    9a8a:	11 24       	eor	r1, r1
    9a8c:	42 0f       	add	r20, r18
    9a8e:	53 1f       	adc	r21, r19
    9a90:	12 96       	adiw	r26, 0x02	; 2
    9a92:	4d 93       	st	X+, r20
    9a94:	5c 93       	st	X, r21
    9a96:	13 97       	sbiw	r26, 0x03	; 3
				pxNewQueue->uxMessagesWaiting = 0;
    9a98:	5a 96       	adiw	r26, 0x1a	; 26
    9a9a:	1c 92       	st	X, r1
    9a9c:	5a 97       	sbiw	r26, 0x1a	; 26
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    9a9e:	14 96       	adiw	r26, 0x04	; 4
    9aa0:	2d 93       	st	X+, r18
    9aa2:	3c 93       	st	X, r19
    9aa4:	15 97       	sbiw	r26, 0x05	; 5
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    9aa6:	31 97       	sbiw	r30, 0x01	; 1
    9aa8:	e8 9f       	mul	r30, r24
    9aaa:	a0 01       	movw	r20, r0
    9aac:	e9 9f       	mul	r30, r25
    9aae:	50 0d       	add	r21, r0
    9ab0:	f8 9f       	mul	r31, r24
    9ab2:	50 0d       	add	r21, r0
    9ab4:	11 24       	eor	r1, r1
    9ab6:	42 0f       	add	r20, r18
    9ab8:	53 1f       	adc	r21, r19
    9aba:	16 96       	adiw	r26, 0x06	; 6
    9abc:	4d 93       	st	X+, r20
    9abe:	5c 93       	st	X, r21
    9ac0:	17 97       	sbiw	r26, 0x07	; 7
				pxNewQueue->uxLength = uxQueueLength;
    9ac2:	5b 96       	adiw	r26, 0x1b	; 27
    9ac4:	1c 93       	st	X, r17
    9ac6:	5b 97       	sbiw	r26, 0x1b	; 27
				pxNewQueue->uxItemSize = uxItemSize;
    9ac8:	5c 96       	adiw	r26, 0x1c	; 28
    9aca:	6c 93       	st	X, r22
    9acc:	5c 97       	sbiw	r26, 0x1c	; 28
				pxNewQueue->xRxLock = queueUNLOCKED;
    9ace:	8f ef       	ldi	r24, 0xFF	; 255
    9ad0:	5d 96       	adiw	r26, 0x1d	; 29
    9ad2:	8c 93       	st	X, r24
    9ad4:	5d 97       	sbiw	r26, 0x1d	; 29
				pxNewQueue->xTxLock = queueUNLOCKED;
    9ad6:	5e 96       	adiw	r26, 0x1e	; 30
    9ad8:	8c 93       	st	X, r24

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    9ada:	c6 01       	movw	r24, r12
    9adc:	08 96       	adiw	r24, 0x08	; 8
    9ade:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    9ae2:	c6 01       	movw	r24, r12
    9ae4:	41 96       	adiw	r24, 0x11	; 17
    9ae6:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    9aea:	05 c0       	rjmp	.+10     	; 0x9af6 <xQueueCreateExternal+0xcc>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    9aec:	c6 01       	movw	r24, r12
    9aee:	0e 94 84 52 	call	0xa508	; 0xa508 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    9af2:	cc 24       	eor	r12, r12
    9af4:	dd 24       	eor	r13, r13
}
    9af6:	c6 01       	movw	r24, r12
    9af8:	23 96       	adiw	r28, 0x03	; 3
    9afa:	cd bf       	out	0x3d, r28	; 61
    9afc:	de bf       	out	0x3e, r29	; 62
    9afe:	cf 91       	pop	r28
    9b00:	df 91       	pop	r29
    9b02:	1f 91       	pop	r17
    9b04:	ff 90       	pop	r15
    9b06:	ef 90       	pop	r14
    9b08:	df 90       	pop	r13
    9b0a:	cf 90       	pop	r12
    9b0c:	08 95       	ret

00009b0e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    9b0e:	7f 92       	push	r7
    9b10:	8f 92       	push	r8
    9b12:	9f 92       	push	r9
    9b14:	af 92       	push	r10
    9b16:	bf 92       	push	r11
    9b18:	cf 92       	push	r12
    9b1a:	df 92       	push	r13
    9b1c:	ef 92       	push	r14
    9b1e:	ff 92       	push	r15
    9b20:	0f 93       	push	r16
    9b22:	1f 93       	push	r17
    9b24:	df 93       	push	r29
    9b26:	cf 93       	push	r28
    9b28:	cd b7       	in	r28, 0x3d	; 61
    9b2a:	de b7       	in	r29, 0x3e	; 62
    9b2c:	25 97       	sbiw	r28, 0x05	; 5
    9b2e:	cd bf       	out	0x3d, r28	; 61
    9b30:	de bf       	out	0x3e, r29	; 62
    9b32:	8c 01       	movw	r16, r24
    9b34:	6b 01       	movw	r12, r22
    9b36:	4c 83       	std	Y+4, r20	; 0x04
    9b38:	5d 83       	std	Y+5, r21	; 0x05
    9b3a:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    9b3c:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9b3e:	7e 01       	movw	r14, r28
    9b40:	08 94       	sec
    9b42:	e1 1c       	adc	r14, r1
    9b44:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9b46:	94 e0       	ldi	r25, 0x04	; 4
    9b48:	a9 2e       	mov	r10, r25
    9b4a:	b1 2c       	mov	r11, r1
    9b4c:	ac 0e       	add	r10, r28
    9b4e:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    9b50:	88 e0       	ldi	r24, 0x08	; 8
    9b52:	88 2e       	mov	r8, r24
    9b54:	91 2c       	mov	r9, r1
    9b56:	80 0e       	add	r8, r16
    9b58:	91 1e       	adc	r9, r17
    9b5a:	01 c0       	rjmp	.+2      	; 0x9b5e <xQueueGenericSend+0x50>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    9b5c:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    9b5e:	0f b6       	in	r0, 0x3f	; 63
    9b60:	f8 94       	cli
    9b62:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    9b64:	f8 01       	movw	r30, r16
    9b66:	92 8d       	ldd	r25, Z+26	; 0x1a
    9b68:	83 8d       	ldd	r24, Z+27	; 0x1b
    9b6a:	98 17       	cp	r25, r24
    9b6c:	08 f0       	brcs	.+2      	; 0x9b70 <xQueueGenericSend+0x62>
    9b6e:	4e c0       	rjmp	.+156    	; 0x9c0c <xQueueGenericSend+0xfe>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    9b70:	44 8d       	ldd	r20, Z+28	; 0x1c
    9b72:	44 23       	and	r20, r20
    9b74:	c1 f1       	breq	.+112    	; 0x9be6 <xQueueGenericSend+0xd8>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    9b76:	77 20       	and	r7, r7
    9b78:	c1 f4       	brne	.+48     	; 0x9baa <xQueueGenericSend+0x9c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9b7a:	84 81       	ldd	r24, Z+4	; 0x04
    9b7c:	95 81       	ldd	r25, Z+5	; 0x05
    9b7e:	b6 01       	movw	r22, r12
    9b80:	50 e0       	ldi	r21, 0x00	; 0
    9b82:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    9b86:	f8 01       	movw	r30, r16
    9b88:	24 8d       	ldd	r18, Z+28	; 0x1c
    9b8a:	84 81       	ldd	r24, Z+4	; 0x04
    9b8c:	95 81       	ldd	r25, Z+5	; 0x05
    9b8e:	82 0f       	add	r24, r18
    9b90:	91 1d       	adc	r25, r1
    9b92:	84 83       	std	Z+4, r24	; 0x04
    9b94:	95 83       	std	Z+5, r25	; 0x05
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    9b96:	22 81       	ldd	r18, Z+2	; 0x02
    9b98:	33 81       	ldd	r19, Z+3	; 0x03
    9b9a:	82 17       	cp	r24, r18
    9b9c:	93 07       	cpc	r25, r19
    9b9e:	18 f1       	brcs	.+70     	; 0x9be6 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    9ba0:	80 81       	ld	r24, Z
    9ba2:	91 81       	ldd	r25, Z+1	; 0x01
    9ba4:	84 83       	std	Z+4, r24	; 0x04
    9ba6:	95 83       	std	Z+5, r25	; 0x05
    9ba8:	1e c0       	rjmp	.+60     	; 0x9be6 <xQueueGenericSend+0xd8>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9baa:	f8 01       	movw	r30, r16
    9bac:	86 81       	ldd	r24, Z+6	; 0x06
    9bae:	97 81       	ldd	r25, Z+7	; 0x07
    9bb0:	b6 01       	movw	r22, r12
    9bb2:	50 e0       	ldi	r21, 0x00	; 0
    9bb4:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    9bb8:	f8 01       	movw	r30, r16
    9bba:	24 8d       	ldd	r18, Z+28	; 0x1c
    9bbc:	30 e0       	ldi	r19, 0x00	; 0
    9bbe:	30 95       	com	r19
    9bc0:	21 95       	neg	r18
    9bc2:	3f 4f       	sbci	r19, 0xFF	; 255
    9bc4:	86 81       	ldd	r24, Z+6	; 0x06
    9bc6:	97 81       	ldd	r25, Z+7	; 0x07
    9bc8:	82 0f       	add	r24, r18
    9bca:	93 1f       	adc	r25, r19
    9bcc:	86 83       	std	Z+6, r24	; 0x06
    9bce:	97 83       	std	Z+7, r25	; 0x07
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    9bd0:	40 81       	ld	r20, Z
    9bd2:	51 81       	ldd	r21, Z+1	; 0x01
    9bd4:	84 17       	cp	r24, r20
    9bd6:	95 07       	cpc	r25, r21
    9bd8:	30 f4       	brcc	.+12     	; 0x9be6 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    9bda:	82 81       	ldd	r24, Z+2	; 0x02
    9bdc:	93 81       	ldd	r25, Z+3	; 0x03
    9bde:	82 0f       	add	r24, r18
    9be0:	93 1f       	adc	r25, r19
    9be2:	86 83       	std	Z+6, r24	; 0x06
    9be4:	97 83       	std	Z+7, r25	; 0x07
		}
	}

	++( pxQueue->uxMessagesWaiting );
    9be6:	f8 01       	movw	r30, r16
    9be8:	82 8d       	ldd	r24, Z+26	; 0x1a
    9bea:	8f 5f       	subi	r24, 0xFF	; 255
    9bec:	82 8f       	std	Z+26, r24	; 0x1a
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    9bee:	81 89       	ldd	r24, Z+17	; 0x11
    9bf0:	88 23       	and	r24, r24
    9bf2:	41 f0       	breq	.+16     	; 0x9c04 <xQueueGenericSend+0xf6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    9bf4:	c8 01       	movw	r24, r16
    9bf6:	41 96       	adiw	r24, 0x11	; 17
    9bf8:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <xTaskRemoveFromEventList>
    9bfc:	81 30       	cpi	r24, 0x01	; 1
    9bfe:	11 f4       	brne	.+4      	; 0x9c04 <xQueueGenericSend+0xf6>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    9c00:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    9c04:	0f 90       	pop	r0
    9c06:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    9c08:	81 e0       	ldi	r24, 0x01	; 1
    9c0a:	4c c0       	rjmp	.+152    	; 0x9ca4 <xQueueGenericSend+0x196>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    9c0c:	8c 81       	ldd	r24, Y+4	; 0x04
    9c0e:	9d 81       	ldd	r25, Y+5	; 0x05
    9c10:	00 97       	sbiw	r24, 0x00	; 0
    9c12:	19 f4       	brne	.+6      	; 0x9c1a <xQueueGenericSend+0x10c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    9c14:	0f 90       	pop	r0
    9c16:	0f be       	out	0x3f, r0	; 63
    9c18:	44 c0       	rjmp	.+136    	; 0x9ca2 <xQueueGenericSend+0x194>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    9c1a:	22 23       	and	r18, r18
    9c1c:	19 f4       	brne	.+6      	; 0x9c24 <xQueueGenericSend+0x116>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9c1e:	c7 01       	movw	r24, r14
    9c20:	0e 94 27 4c 	call	0x984e	; 0x984e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    9c24:	0f 90       	pop	r0
    9c26:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    9c28:	0e 94 c9 48 	call	0x9192	; 0x9192 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    9c2c:	0f b6       	in	r0, 0x3f	; 63
    9c2e:	f8 94       	cli
    9c30:	0f 92       	push	r0
    9c32:	f8 01       	movw	r30, r16
    9c34:	85 8d       	ldd	r24, Z+29	; 0x1d
    9c36:	8f 3f       	cpi	r24, 0xFF	; 255
    9c38:	09 f4       	brne	.+2      	; 0x9c3c <xQueueGenericSend+0x12e>
    9c3a:	15 8e       	std	Z+29, r1	; 0x1d
    9c3c:	f8 01       	movw	r30, r16
    9c3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    9c40:	8f 3f       	cpi	r24, 0xFF	; 255
    9c42:	09 f4       	brne	.+2      	; 0x9c46 <xQueueGenericSend+0x138>
    9c44:	16 8e       	std	Z+30, r1	; 0x1e
    9c46:	0f 90       	pop	r0
    9c48:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9c4a:	c7 01       	movw	r24, r14
    9c4c:	b5 01       	movw	r22, r10
    9c4e:	0e 94 32 4c 	call	0x9864	; 0x9864 <xTaskCheckForTimeOut>
    9c52:	88 23       	and	r24, r24
    9c54:	09 f5       	brne	.+66     	; 0x9c98 <xQueueGenericSend+0x18a>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    9c56:	0f b6       	in	r0, 0x3f	; 63
    9c58:	f8 94       	cli
    9c5a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    9c5c:	f8 01       	movw	r30, r16
    9c5e:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9c60:	0f 90       	pop	r0
    9c62:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    9c64:	f8 01       	movw	r30, r16
    9c66:	83 8d       	ldd	r24, Z+27	; 0x1b
    9c68:	98 17       	cp	r25, r24
    9c6a:	81 f4       	brne	.+32     	; 0x9c8c <xQueueGenericSend+0x17e>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    9c6c:	6c 81       	ldd	r22, Y+4	; 0x04
    9c6e:	7d 81       	ldd	r23, Y+5	; 0x05
    9c70:	c4 01       	movw	r24, r8
    9c72:	0e 94 98 4b 	call	0x9730	; 0x9730 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    9c76:	c8 01       	movw	r24, r16
    9c78:	0e 94 75 4c 	call	0x98ea	; 0x98ea <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    9c7c:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
    9c80:	88 23       	and	r24, r24
    9c82:	09 f0       	breq	.+2      	; 0x9c86 <xQueueGenericSend+0x178>
    9c84:	6b cf       	rjmp	.-298    	; 0x9b5c <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    9c86:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
    9c8a:	68 cf       	rjmp	.-304    	; 0x9b5c <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    9c8c:	c8 01       	movw	r24, r16
    9c8e:	0e 94 75 4c 	call	0x98ea	; 0x98ea <prvUnlockQueue>
				( void ) xTaskResumeAll();
    9c92:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
    9c96:	62 cf       	rjmp	.-316    	; 0x9b5c <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    9c98:	c8 01       	movw	r24, r16
    9c9a:	0e 94 75 4c 	call	0x98ea	; 0x98ea <prvUnlockQueue>
			( void ) xTaskResumeAll();
    9c9e:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    9ca2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    9ca4:	25 96       	adiw	r28, 0x05	; 5
    9ca6:	cd bf       	out	0x3d, r28	; 61
    9ca8:	de bf       	out	0x3e, r29	; 62
    9caa:	cf 91       	pop	r28
    9cac:	df 91       	pop	r29
    9cae:	1f 91       	pop	r17
    9cb0:	0f 91       	pop	r16
    9cb2:	ff 90       	pop	r15
    9cb4:	ef 90       	pop	r14
    9cb6:	df 90       	pop	r13
    9cb8:	cf 90       	pop	r12
    9cba:	bf 90       	pop	r11
    9cbc:	af 90       	pop	r10
    9cbe:	9f 90       	pop	r9
    9cc0:	8f 90       	pop	r8
    9cc2:	7f 90       	pop	r7
    9cc4:	08 95       	ret

00009cc6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    9cc6:	0f 93       	push	r16
    9cc8:	1f 93       	push	r17
    9cca:	cf 93       	push	r28
    9ccc:	df 93       	push	r29
    9cce:	ec 01       	movw	r28, r24
    9cd0:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    9cd2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9cd4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    9cd6:	98 17       	cp	r25, r24
    9cd8:	08 f0       	brcs	.+2      	; 0x9cdc <xQueueGenericSendFromISR+0x16>
    9cda:	4c c0       	rjmp	.+152    	; 0x9d74 <xQueueGenericSendFromISR+0xae>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    9cdc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9cde:	44 23       	and	r20, r20
    9ce0:	99 f1       	breq	.+102    	; 0x9d48 <xQueueGenericSendFromISR+0x82>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    9ce2:	22 23       	and	r18, r18
    9ce4:	b1 f4       	brne	.+44     	; 0x9d12 <xQueueGenericSendFromISR+0x4c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9ce6:	8c 81       	ldd	r24, Y+4	; 0x04
    9ce8:	9d 81       	ldd	r25, Y+5	; 0x05
    9cea:	50 e0       	ldi	r21, 0x00	; 0
    9cec:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    9cf0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9cf2:	8c 81       	ldd	r24, Y+4	; 0x04
    9cf4:	9d 81       	ldd	r25, Y+5	; 0x05
    9cf6:	82 0f       	add	r24, r18
    9cf8:	91 1d       	adc	r25, r1
    9cfa:	8c 83       	std	Y+4, r24	; 0x04
    9cfc:	9d 83       	std	Y+5, r25	; 0x05
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    9cfe:	2a 81       	ldd	r18, Y+2	; 0x02
    9d00:	3b 81       	ldd	r19, Y+3	; 0x03
    9d02:	82 17       	cp	r24, r18
    9d04:	93 07       	cpc	r25, r19
    9d06:	00 f1       	brcs	.+64     	; 0x9d48 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    9d08:	88 81       	ld	r24, Y
    9d0a:	99 81       	ldd	r25, Y+1	; 0x01
    9d0c:	8c 83       	std	Y+4, r24	; 0x04
    9d0e:	9d 83       	std	Y+5, r25	; 0x05
    9d10:	1b c0       	rjmp	.+54     	; 0x9d48 <xQueueGenericSendFromISR+0x82>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9d12:	8e 81       	ldd	r24, Y+6	; 0x06
    9d14:	9f 81       	ldd	r25, Y+7	; 0x07
    9d16:	50 e0       	ldi	r21, 0x00	; 0
    9d18:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    9d1c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9d1e:	30 e0       	ldi	r19, 0x00	; 0
    9d20:	30 95       	com	r19
    9d22:	21 95       	neg	r18
    9d24:	3f 4f       	sbci	r19, 0xFF	; 255
    9d26:	8e 81       	ldd	r24, Y+6	; 0x06
    9d28:	9f 81       	ldd	r25, Y+7	; 0x07
    9d2a:	82 0f       	add	r24, r18
    9d2c:	93 1f       	adc	r25, r19
    9d2e:	8e 83       	std	Y+6, r24	; 0x06
    9d30:	9f 83       	std	Y+7, r25	; 0x07
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    9d32:	48 81       	ld	r20, Y
    9d34:	59 81       	ldd	r21, Y+1	; 0x01
    9d36:	84 17       	cp	r24, r20
    9d38:	95 07       	cpc	r25, r21
    9d3a:	30 f4       	brcc	.+12     	; 0x9d48 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    9d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    9d3e:	9b 81       	ldd	r25, Y+3	; 0x03
    9d40:	82 0f       	add	r24, r18
    9d42:	93 1f       	adc	r25, r19
    9d44:	8e 83       	std	Y+6, r24	; 0x06
    9d46:	9f 83       	std	Y+7, r25	; 0x07
		}
	}

	++( pxQueue->uxMessagesWaiting );
    9d48:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9d4a:	8f 5f       	subi	r24, 0xFF	; 255
    9d4c:	8a 8f       	std	Y+26, r24	; 0x1a

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    9d4e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9d50:	8f 3f       	cpi	r24, 0xFF	; 255
    9d52:	69 f4       	brne	.+26     	; 0x9d6e <xQueueGenericSendFromISR+0xa8>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9d54:	89 89       	ldd	r24, Y+17	; 0x11
    9d56:	88 23       	and	r24, r24
    9d58:	79 f0       	breq	.+30     	; 0x9d78 <xQueueGenericSendFromISR+0xb2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    9d5a:	ce 01       	movw	r24, r28
    9d5c:	41 96       	adiw	r24, 0x11	; 17
    9d5e:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <xTaskRemoveFromEventList>
    9d62:	88 23       	and	r24, r24
    9d64:	49 f0       	breq	.+18     	; 0x9d78 <xQueueGenericSendFromISR+0xb2>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    9d66:	81 e0       	ldi	r24, 0x01	; 1
    9d68:	f8 01       	movw	r30, r16
    9d6a:	80 83       	st	Z, r24
    9d6c:	06 c0       	rjmp	.+12     	; 0x9d7a <xQueueGenericSendFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    9d6e:	8f 5f       	subi	r24, 0xFF	; 255
    9d70:	8e 8f       	std	Y+30, r24	; 0x1e
    9d72:	02 c0       	rjmp	.+4      	; 0x9d78 <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    9d74:	80 e0       	ldi	r24, 0x00	; 0
    9d76:	01 c0       	rjmp	.+2      	; 0x9d7a <xQueueGenericSendFromISR+0xb4>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    9d78:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    9d7a:	df 91       	pop	r29
    9d7c:	cf 91       	pop	r28
    9d7e:	1f 91       	pop	r17
    9d80:	0f 91       	pop	r16
    9d82:	08 95       	ret

00009d84 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    9d84:	7f 92       	push	r7
    9d86:	8f 92       	push	r8
    9d88:	9f 92       	push	r9
    9d8a:	af 92       	push	r10
    9d8c:	bf 92       	push	r11
    9d8e:	cf 92       	push	r12
    9d90:	df 92       	push	r13
    9d92:	ef 92       	push	r14
    9d94:	ff 92       	push	r15
    9d96:	0f 93       	push	r16
    9d98:	1f 93       	push	r17
    9d9a:	df 93       	push	r29
    9d9c:	cf 93       	push	r28
    9d9e:	cd b7       	in	r28, 0x3d	; 61
    9da0:	de b7       	in	r29, 0x3e	; 62
    9da2:	25 97       	sbiw	r28, 0x05	; 5
    9da4:	cd bf       	out	0x3d, r28	; 61
    9da6:	de bf       	out	0x3e, r29	; 62
    9da8:	8c 01       	movw	r16, r24
    9daa:	86 2e       	mov	r8, r22
    9dac:	77 2e       	mov	r7, r23
    9dae:	4c 83       	std	Y+4, r20	; 0x04
    9db0:	5d 83       	std	Y+5, r21	; 0x05
    9db2:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    9db4:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9db6:	7e 01       	movw	r14, r28
    9db8:	08 94       	sec
    9dba:	e1 1c       	adc	r14, r1
    9dbc:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9dbe:	44 e0       	ldi	r20, 0x04	; 4
    9dc0:	c4 2e       	mov	r12, r20
    9dc2:	d1 2c       	mov	r13, r1
    9dc4:	cc 0e       	add	r12, r28
    9dc6:	dd 1e       	adc	r13, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    9dc8:	31 e1       	ldi	r19, 0x11	; 17
    9dca:	a3 2e       	mov	r10, r19
    9dcc:	b1 2c       	mov	r11, r1
    9dce:	a8 0e       	add	r10, r24
    9dd0:	b9 1e       	adc	r11, r25
    9dd2:	01 c0       	rjmp	.+2      	; 0x9dd6 <xQueueGenericReceive+0x52>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    9dd4:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    9dd6:	0f b6       	in	r0, 0x3f	; 63
    9dd8:	f8 94       	cli
    9dda:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    9ddc:	f8 01       	movw	r30, r16
    9dde:	82 8d       	ldd	r24, Z+26	; 0x1a
    9de0:	88 23       	and	r24, r24
    9de2:	09 f4       	brne	.+2      	; 0x9de6 <xQueueGenericReceive+0x62>
    9de4:	3d c0       	rjmp	.+122    	; 0x9e60 <xQueueGenericReceive+0xdc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    9de6:	e6 80       	ldd	r14, Z+6	; 0x06
    9de8:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    9dea:	80 81       	ld	r24, Z
    9dec:	91 81       	ldd	r25, Z+1	; 0x01
    9dee:	00 97       	sbiw	r24, 0x00	; 0
    9df0:	a9 f0       	breq	.+42     	; 0x9e1c <xQueueGenericReceive+0x98>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    9df2:	44 8d       	ldd	r20, Z+28	; 0x1c
    9df4:	97 01       	movw	r18, r14
    9df6:	24 0f       	add	r18, r20
    9df8:	31 1d       	adc	r19, r1
    9dfa:	26 83       	std	Z+6, r18	; 0x06
    9dfc:	37 83       	std	Z+7, r19	; 0x07
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    9dfe:	62 81       	ldd	r22, Z+2	; 0x02
    9e00:	73 81       	ldd	r23, Z+3	; 0x03
    9e02:	26 17       	cp	r18, r22
    9e04:	37 07       	cpc	r19, r23
    9e06:	10 f0       	brcs	.+4      	; 0x9e0c <xQueueGenericReceive+0x88>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    9e08:	86 83       	std	Z+6, r24	; 0x06
    9e0a:	97 83       	std	Z+7, r25	; 0x07
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    9e0c:	f8 01       	movw	r30, r16
    9e0e:	66 81       	ldd	r22, Z+6	; 0x06
    9e10:	77 81       	ldd	r23, Z+7	; 0x07
    9e12:	88 2d       	mov	r24, r8
    9e14:	97 2d       	mov	r25, r7
    9e16:	50 e0       	ldi	r21, 0x00	; 0
    9e18:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    9e1c:	99 20       	and	r9, r9
    9e1e:	71 f4       	brne	.+28     	; 0x9e3c <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    9e20:	f8 01       	movw	r30, r16
    9e22:	82 8d       	ldd	r24, Z+26	; 0x1a
    9e24:	81 50       	subi	r24, 0x01	; 1
    9e26:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    9e28:	80 85       	ldd	r24, Z+8	; 0x08
    9e2a:	88 23       	and	r24, r24
    9e2c:	a9 f0       	breq	.+42     	; 0x9e58 <xQueueGenericReceive+0xd4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    9e2e:	c8 01       	movw	r24, r16
    9e30:	08 96       	adiw	r24, 0x08	; 8
    9e32:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <xTaskRemoveFromEventList>
    9e36:	81 30       	cpi	r24, 0x01	; 1
    9e38:	79 f4       	brne	.+30     	; 0x9e58 <xQueueGenericReceive+0xd4>
    9e3a:	0c c0       	rjmp	.+24     	; 0x9e54 <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    9e3c:	f8 01       	movw	r30, r16
    9e3e:	e6 82       	std	Z+6, r14	; 0x06
    9e40:	f7 82       	std	Z+7, r15	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9e42:	81 89       	ldd	r24, Z+17	; 0x11
    9e44:	88 23       	and	r24, r24
    9e46:	41 f0       	breq	.+16     	; 0x9e58 <xQueueGenericReceive+0xd4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    9e48:	c8 01       	movw	r24, r16
    9e4a:	41 96       	adiw	r24, 0x11	; 17
    9e4c:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <xTaskRemoveFromEventList>
    9e50:	88 23       	and	r24, r24
    9e52:	11 f0       	breq	.+4      	; 0x9e58 <xQueueGenericReceive+0xd4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    9e54:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    9e58:	0f 90       	pop	r0
    9e5a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    9e5c:	81 e0       	ldi	r24, 0x01	; 1
    9e5e:	4a c0       	rjmp	.+148    	; 0x9ef4 <xQueueGenericReceive+0x170>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    9e60:	8c 81       	ldd	r24, Y+4	; 0x04
    9e62:	9d 81       	ldd	r25, Y+5	; 0x05
    9e64:	00 97       	sbiw	r24, 0x00	; 0
    9e66:	19 f4       	brne	.+6      	; 0x9e6e <xQueueGenericReceive+0xea>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    9e68:	0f 90       	pop	r0
    9e6a:	0f be       	out	0x3f, r0	; 63
    9e6c:	42 c0       	rjmp	.+132    	; 0x9ef2 <xQueueGenericReceive+0x16e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    9e6e:	22 23       	and	r18, r18
    9e70:	19 f4       	brne	.+6      	; 0x9e78 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9e72:	c7 01       	movw	r24, r14
    9e74:	0e 94 27 4c 	call	0x984e	; 0x984e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    9e78:	0f 90       	pop	r0
    9e7a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    9e7c:	0e 94 c9 48 	call	0x9192	; 0x9192 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    9e80:	0f b6       	in	r0, 0x3f	; 63
    9e82:	f8 94       	cli
    9e84:	0f 92       	push	r0
    9e86:	f8 01       	movw	r30, r16
    9e88:	85 8d       	ldd	r24, Z+29	; 0x1d
    9e8a:	8f 3f       	cpi	r24, 0xFF	; 255
    9e8c:	09 f4       	brne	.+2      	; 0x9e90 <xQueueGenericReceive+0x10c>
    9e8e:	15 8e       	std	Z+29, r1	; 0x1d
    9e90:	f8 01       	movw	r30, r16
    9e92:	86 8d       	ldd	r24, Z+30	; 0x1e
    9e94:	8f 3f       	cpi	r24, 0xFF	; 255
    9e96:	09 f4       	brne	.+2      	; 0x9e9a <xQueueGenericReceive+0x116>
    9e98:	16 8e       	std	Z+30, r1	; 0x1e
    9e9a:	0f 90       	pop	r0
    9e9c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9e9e:	c7 01       	movw	r24, r14
    9ea0:	b6 01       	movw	r22, r12
    9ea2:	0e 94 32 4c 	call	0x9864	; 0x9864 <xTaskCheckForTimeOut>
    9ea6:	88 23       	and	r24, r24
    9ea8:	f9 f4       	brne	.+62     	; 0x9ee8 <xQueueGenericReceive+0x164>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    9eaa:	0f b6       	in	r0, 0x3f	; 63
    9eac:	f8 94       	cli
    9eae:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    9eb0:	f8 01       	movw	r30, r16
    9eb2:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9eb4:	0f 90       	pop	r0
    9eb6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    9eb8:	88 23       	and	r24, r24
    9eba:	81 f4       	brne	.+32     	; 0x9edc <xQueueGenericReceive+0x158>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    9ebc:	6c 81       	ldd	r22, Y+4	; 0x04
    9ebe:	7d 81       	ldd	r23, Y+5	; 0x05
    9ec0:	c5 01       	movw	r24, r10
    9ec2:	0e 94 98 4b 	call	0x9730	; 0x9730 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    9ec6:	c8 01       	movw	r24, r16
    9ec8:	0e 94 75 4c 	call	0x98ea	; 0x98ea <prvUnlockQueue>
				if( !xTaskResumeAll() )
    9ecc:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
    9ed0:	88 23       	and	r24, r24
    9ed2:	09 f0       	breq	.+2      	; 0x9ed6 <xQueueGenericReceive+0x152>
    9ed4:	7f cf       	rjmp	.-258    	; 0x9dd4 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    9ed6:	0e 94 37 53 	call	0xa66e	; 0xa66e <vPortYield>
    9eda:	7c cf       	rjmp	.-264    	; 0x9dd4 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    9edc:	c8 01       	movw	r24, r16
    9ede:	0e 94 75 4c 	call	0x98ea	; 0x98ea <prvUnlockQueue>
				( void ) xTaskResumeAll();
    9ee2:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
    9ee6:	76 cf       	rjmp	.-276    	; 0x9dd4 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    9ee8:	c8 01       	movw	r24, r16
    9eea:	0e 94 75 4c 	call	0x98ea	; 0x98ea <prvUnlockQueue>
			( void ) xTaskResumeAll();
    9eee:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    9ef2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    9ef4:	25 96       	adiw	r28, 0x05	; 5
    9ef6:	cd bf       	out	0x3d, r28	; 61
    9ef8:	de bf       	out	0x3e, r29	; 62
    9efa:	cf 91       	pop	r28
    9efc:	df 91       	pop	r29
    9efe:	1f 91       	pop	r17
    9f00:	0f 91       	pop	r16
    9f02:	ff 90       	pop	r15
    9f04:	ef 90       	pop	r14
    9f06:	df 90       	pop	r13
    9f08:	cf 90       	pop	r12
    9f0a:	bf 90       	pop	r11
    9f0c:	af 90       	pop	r10
    9f0e:	9f 90       	pop	r9
    9f10:	8f 90       	pop	r8
    9f12:	7f 90       	pop	r7
    9f14:	08 95       	ret

00009f16 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    9f16:	0f 93       	push	r16
    9f18:	1f 93       	push	r17
    9f1a:	cf 93       	push	r28
    9f1c:	df 93       	push	r29
    9f1e:	ec 01       	movw	r28, r24
    9f20:	cb 01       	movw	r24, r22
    9f22:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    9f24:	2a 8d       	ldd	r18, Y+26	; 0x1a
    9f26:	22 23       	and	r18, r18
    9f28:	71 f1       	breq	.+92     	; 0x9f86 <xQueueReceiveFromISR+0x70>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    9f2a:	e8 81       	ld	r30, Y
    9f2c:	f9 81       	ldd	r31, Y+1	; 0x01
    9f2e:	30 97       	sbiw	r30, 0x00	; 0
    9f30:	a1 f0       	breq	.+40     	; 0x9f5a <xQueueReceiveFromISR+0x44>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    9f32:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9f34:	2e 81       	ldd	r18, Y+6	; 0x06
    9f36:	3f 81       	ldd	r19, Y+7	; 0x07
    9f38:	24 0f       	add	r18, r20
    9f3a:	31 1d       	adc	r19, r1
    9f3c:	2e 83       	std	Y+6, r18	; 0x06
    9f3e:	3f 83       	std	Y+7, r19	; 0x07
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    9f40:	aa 81       	ldd	r26, Y+2	; 0x02
    9f42:	bb 81       	ldd	r27, Y+3	; 0x03
    9f44:	2a 17       	cp	r18, r26
    9f46:	3b 07       	cpc	r19, r27
    9f48:	10 f0       	brcs	.+4      	; 0x9f4e <xQueueReceiveFromISR+0x38>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    9f4a:	ee 83       	std	Y+6, r30	; 0x06
    9f4c:	ff 83       	std	Y+7, r31	; 0x07
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    9f4e:	6e 81       	ldd	r22, Y+6	; 0x06
    9f50:	2f 81       	ldd	r18, Y+7	; 0x07
    9f52:	72 2f       	mov	r23, r18
    9f54:	50 e0       	ldi	r21, 0x00	; 0
    9f56:	0e 94 c0 56 	call	0xad80	; 0xad80 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    9f5a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9f5c:	81 50       	subi	r24, 0x01	; 1
    9f5e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    9f60:	8d 8d       	ldd	r24, Y+29	; 0x1d
    9f62:	8f 3f       	cpi	r24, 0xFF	; 255
    9f64:	69 f4       	brne	.+26     	; 0x9f80 <xQueueReceiveFromISR+0x6a>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    9f66:	88 85       	ldd	r24, Y+8	; 0x08
    9f68:	88 23       	and	r24, r24
    9f6a:	79 f0       	breq	.+30     	; 0x9f8a <xQueueReceiveFromISR+0x74>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    9f6c:	ce 01       	movw	r24, r28
    9f6e:	08 96       	adiw	r24, 0x08	; 8
    9f70:	0e 94 e0 4b 	call	0x97c0	; 0x97c0 <xTaskRemoveFromEventList>
    9f74:	88 23       	and	r24, r24
    9f76:	49 f0       	breq	.+18     	; 0x9f8a <xQueueReceiveFromISR+0x74>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    9f78:	81 e0       	ldi	r24, 0x01	; 1
    9f7a:	f8 01       	movw	r30, r16
    9f7c:	80 83       	st	Z, r24
    9f7e:	06 c0       	rjmp	.+12     	; 0x9f8c <xQueueReceiveFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    9f80:	8f 5f       	subi	r24, 0xFF	; 255
    9f82:	8d 8f       	std	Y+29, r24	; 0x1d
    9f84:	02 c0       	rjmp	.+4      	; 0x9f8a <xQueueReceiveFromISR+0x74>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    9f86:	80 e0       	ldi	r24, 0x00	; 0
    9f88:	01 c0       	rjmp	.+2      	; 0x9f8c <xQueueReceiveFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    9f8a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    9f8c:	df 91       	pop	r29
    9f8e:	cf 91       	pop	r28
    9f90:	1f 91       	pop	r17
    9f92:	0f 91       	pop	r16
    9f94:	08 95       	ret

00009f96 <uxQueueMessagesWaiting>:

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    9f96:	0f b6       	in	r0, 0x3f	; 63
    9f98:	f8 94       	cli
    9f9a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    9f9c:	fc 01       	movw	r30, r24
    9f9e:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9fa0:	0f 90       	pop	r0
    9fa2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    9fa4:	08 95       	ret

00009fa6 <uxQueueMessagesWaitingFromISR>:

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    9fa6:	fc 01       	movw	r30, r24
    9fa8:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    9faa:	08 95       	ret

00009fac <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    9fac:	cf 93       	push	r28
    9fae:	df 93       	push	r29
    9fb0:	ec 01       	movw	r28, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    9fb2:	88 81       	ld	r24, Y
    9fb4:	99 81       	ldd	r25, Y+1	; 0x01
    9fb6:	0e 94 84 52 	call	0xa508	; 0xa508 <vPortFree>
	vPortFree( pxQueue );
    9fba:	ce 01       	movw	r24, r28
    9fbc:	0e 94 84 52 	call	0xa508	; 0xa508 <vPortFree>
}
    9fc0:	df 91       	pop	r29
    9fc2:	cf 91       	pop	r28
    9fc4:	08 95       	ret

00009fc6 <xQueueIsQueueEmptyFromISR>:

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    9fc6:	fc 01       	movw	r30, r24
    9fc8:	92 8d       	ldd	r25, Z+26	; 0x1a
    9fca:	81 e0       	ldi	r24, 0x01	; 1
    9fcc:	91 11       	cpse	r25, r1
    9fce:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    9fd0:	08 95       	ret

00009fd2 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    9fd2:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    9fd4:	22 8d       	ldd	r18, Z+26	; 0x1a
    9fd6:	81 e0       	ldi	r24, 0x01	; 1
    9fd8:	93 8d       	ldd	r25, Z+27	; 0x1b
    9fda:	29 13       	cpse	r18, r25
    9fdc:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    9fde:	08 95       	ret

00009fe0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    9fe0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    9fe2:	03 96       	adiw	r24, 0x03	; 3
    9fe4:	81 83       	std	Z+1, r24	; 0x01
    9fe6:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    9fe8:	2f ef       	ldi	r18, 0xFF	; 255
    9fea:	3f ef       	ldi	r19, 0xFF	; 255
    9fec:	23 83       	std	Z+3, r18	; 0x03
    9fee:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    9ff0:	85 83       	std	Z+5, r24	; 0x05
    9ff2:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    9ff4:	87 83       	std	Z+7, r24	; 0x07
    9ff6:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = 0;
    9ff8:	10 82       	st	Z, r1
}
    9ffa:	08 95       	ret

00009ffc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    9ffc:	fc 01       	movw	r30, r24
    9ffe:	10 86       	std	Z+8, r1	; 0x08
    a000:	11 86       	std	Z+9, r1	; 0x09
}
    a002:	08 95       	ret

0000a004 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    a004:	cf 93       	push	r28
    a006:	df 93       	push	r29
    a008:	fc 01       	movw	r30, r24
    a00a:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    a00c:	21 81       	ldd	r18, Z+1	; 0x01
    a00e:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    a010:	e9 01       	movw	r28, r18
    a012:	8a 81       	ldd	r24, Y+2	; 0x02
    a014:	9b 81       	ldd	r25, Y+3	; 0x03
    a016:	12 96       	adiw	r26, 0x02	; 2
    a018:	8d 93       	st	X+, r24
    a01a:	9c 93       	st	X, r25
    a01c:	13 97       	sbiw	r26, 0x03	; 3
	pxNewListItem->pxPrevious = pxList->pxIndex;
    a01e:	14 96       	adiw	r26, 0x04	; 4
    a020:	2d 93       	st	X+, r18
    a022:	3c 93       	st	X, r19
    a024:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a026:	8a 81       	ldd	r24, Y+2	; 0x02
    a028:	9b 81       	ldd	r25, Y+3	; 0x03
    a02a:	ec 01       	movw	r28, r24
    a02c:	6c 83       	std	Y+4, r22	; 0x04
    a02e:	7d 83       	std	Y+5, r23	; 0x05
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    a030:	e9 01       	movw	r28, r18
    a032:	6a 83       	std	Y+2, r22	; 0x02
    a034:	7b 83       	std	Y+3, r23	; 0x03
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    a036:	61 83       	std	Z+1, r22	; 0x01
    a038:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a03a:	18 96       	adiw	r26, 0x08	; 8
    a03c:	ed 93       	st	X+, r30
    a03e:	fc 93       	st	X, r31
    a040:	19 97       	sbiw	r26, 0x09	; 9

	( pxList->uxNumberOfItems )++;
    a042:	80 81       	ld	r24, Z
    a044:	8f 5f       	subi	r24, 0xFF	; 255
    a046:	80 83       	st	Z, r24
}
    a048:	df 91       	pop	r29
    a04a:	cf 91       	pop	r28
    a04c:	08 95       	ret

0000a04e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    a04e:	cf 93       	push	r28
    a050:	df 93       	push	r29
    a052:	ac 01       	movw	r20, r24
    a054:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    a056:	88 81       	ld	r24, Y
    a058:	99 81       	ldd	r25, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    a05a:	2f ef       	ldi	r18, 0xFF	; 255
    a05c:	8f 3f       	cpi	r24, 0xFF	; 255
    a05e:	92 07       	cpc	r25, r18
    a060:	21 f4       	brne	.+8      	; 0xa06a <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    a062:	fa 01       	movw	r30, r20
    a064:	a7 81       	ldd	r26, Z+7	; 0x07
    a066:	b0 85       	ldd	r27, Z+8	; 0x08
    a068:	11 c0       	rjmp	.+34     	; 0xa08c <vListInsert+0x3e>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    a06a:	da 01       	movw	r26, r20
    a06c:	13 96       	adiw	r26, 0x03	; 3
    a06e:	04 c0       	rjmp	.+8      	; 0xa078 <vListInsert+0x2a>
    a070:	12 96       	adiw	r26, 0x02	; 2
    a072:	0d 90       	ld	r0, X+
    a074:	bc 91       	ld	r27, X
    a076:	a0 2d       	mov	r26, r0
    a078:	12 96       	adiw	r26, 0x02	; 2
    a07a:	2d 91       	ld	r18, X+
    a07c:	3c 91       	ld	r19, X
    a07e:	13 97       	sbiw	r26, 0x03	; 3
    a080:	f9 01       	movw	r30, r18
    a082:	20 81       	ld	r18, Z
    a084:	31 81       	ldd	r19, Z+1	; 0x01
    a086:	82 17       	cp	r24, r18
    a088:	93 07       	cpc	r25, r19
    a08a:	90 f7       	brcc	.-28     	; 0xa070 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    a08c:	12 96       	adiw	r26, 0x02	; 2
    a08e:	8d 91       	ld	r24, X+
    a090:	9c 91       	ld	r25, X
    a092:	13 97       	sbiw	r26, 0x03	; 3
    a094:	8a 83       	std	Y+2, r24	; 0x02
    a096:	9b 83       	std	Y+3, r25	; 0x03
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a098:	fc 01       	movw	r30, r24
    a09a:	c4 83       	std	Z+4, r28	; 0x04
    a09c:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    a09e:	ac 83       	std	Y+4, r26	; 0x04
    a0a0:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    a0a2:	12 96       	adiw	r26, 0x02	; 2
    a0a4:	cd 93       	st	X+, r28
    a0a6:	dc 93       	st	X, r29
    a0a8:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a0aa:	48 87       	std	Y+8, r20	; 0x08
    a0ac:	59 87       	std	Y+9, r21	; 0x09

	( pxList->uxNumberOfItems )++;
    a0ae:	fa 01       	movw	r30, r20
    a0b0:	80 81       	ld	r24, Z
    a0b2:	8f 5f       	subi	r24, 0xFF	; 255
    a0b4:	80 83       	st	Z, r24
}
    a0b6:	df 91       	pop	r29
    a0b8:	cf 91       	pop	r28
    a0ba:	08 95       	ret

0000a0bc <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    a0bc:	cf 93       	push	r28
    a0be:	df 93       	push	r29
    a0c0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    a0c2:	a2 81       	ldd	r26, Z+2	; 0x02
    a0c4:	b3 81       	ldd	r27, Z+3	; 0x03
    a0c6:	84 81       	ldd	r24, Z+4	; 0x04
    a0c8:	95 81       	ldd	r25, Z+5	; 0x05
    a0ca:	14 96       	adiw	r26, 0x04	; 4
    a0cc:	8d 93       	st	X+, r24
    a0ce:	9c 93       	st	X, r25
    a0d0:	15 97       	sbiw	r26, 0x05	; 5
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    a0d2:	c4 81       	ldd	r28, Z+4	; 0x04
    a0d4:	d5 81       	ldd	r29, Z+5	; 0x05
    a0d6:	aa 83       	std	Y+2, r26	; 0x02
    a0d8:	bb 83       	std	Y+3, r27	; 0x03
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    a0da:	a0 85       	ldd	r26, Z+8	; 0x08
    a0dc:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    a0de:	11 96       	adiw	r26, 0x01	; 1
    a0e0:	8d 91       	ld	r24, X+
    a0e2:	9c 91       	ld	r25, X
    a0e4:	12 97       	sbiw	r26, 0x02	; 2
    a0e6:	8e 17       	cp	r24, r30
    a0e8:	9f 07       	cpc	r25, r31
    a0ea:	21 f4       	brne	.+8      	; 0xa0f4 <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    a0ec:	11 96       	adiw	r26, 0x01	; 1
    a0ee:	cd 93       	st	X+, r28
    a0f0:	dc 93       	st	X, r29
    a0f2:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    a0f4:	10 86       	std	Z+8, r1	; 0x08
    a0f6:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    a0f8:	8c 91       	ld	r24, X
    a0fa:	81 50       	subi	r24, 0x01	; 1
    a0fc:	8c 93       	st	X, r24
}
    a0fe:	df 91       	pop	r29
    a100:	cf 91       	pop	r28
    a102:	08 95       	ret

0000a104 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    a104:	bf 92       	push	r11
    a106:	cf 92       	push	r12
    a108:	df 92       	push	r13
    a10a:	ef 92       	push	r14
    a10c:	ff 92       	push	r15
    a10e:	0f 93       	push	r16
    a110:	1f 93       	push	r17
    a112:	cf 93       	push	r28
    a114:	df 93       	push	r29
    a116:	6c 01       	movw	r12, r24
    a118:	b4 2e       	mov	r11, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    a11a:	8a e1       	ldi	r24, 0x1A	; 26
    a11c:	90 e0       	ldi	r25, 0x00	; 0
    a11e:	0e 94 5b 52 	call	0xa4b6	; 0xa4b6 <pvPortMalloc>
    a122:	e8 2e       	mov	r14, r24
    a124:	e7 01       	movw	r28, r14
    a126:	7e 01       	movw	r14, r28
    a128:	f9 2e       	mov	r15, r25
    a12a:	e7 01       	movw	r28, r14
	if( pxCoRoutine )
    a12c:	20 97       	sbiw	r28, 0x00	; 0
    a12e:	09 f4       	brne	.+2      	; 0xa132 <xCoRoutineCreate+0x2e>
    a130:	54 c0       	rjmp	.+168    	; 0xa1da <xCoRoutineCreate+0xd6>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    a132:	80 91 de 25 	lds	r24, 0x25DE
    a136:	90 91 df 25 	lds	r25, 0x25DF
    a13a:	00 97       	sbiw	r24, 0x00	; 0
    a13c:	01 f5       	brne	.+64     	; 0xa17e <xCoRoutineCreate+0x7a>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    a13e:	e0 92 de 25 	sts	0x25DE, r14
    a142:	f0 92 df 25 	sts	0x25DF, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    a146:	8a ee       	ldi	r24, 0xEA	; 234
    a148:	95 e2       	ldi	r25, 0x25	; 37
    a14a:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    a14e:	5d ef       	ldi	r21, 0xFD	; 253
    a150:	e5 2e       	mov	r14, r21
    a152:	55 e2       	ldi	r21, 0x25	; 37
    a154:	f5 2e       	mov	r15, r21
    a156:	c7 01       	movw	r24, r14
    a158:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    a15c:	06 e0       	ldi	r16, 0x06	; 6
    a15e:	16 e2       	ldi	r17, 0x26	; 38
    a160:	c8 01       	movw	r24, r16
    a162:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    a166:	80 ee       	ldi	r24, 0xE0	; 224
    a168:	95 e2       	ldi	r25, 0x25	; 37
    a16a:	0e 94 f0 4f 	call	0x9fe0	; 0x9fe0 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    a16e:	e0 92 f9 25 	sts	0x25F9, r14
    a172:	f0 92 fa 25 	sts	0x25FA, r15
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    a176:	00 93 fb 25 	sts	0x25FB, r16
    a17a:	10 93 fc 25 	sts	0x25FC, r17
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    a17e:	18 8e       	std	Y+24, r1	; 0x18
    a180:	19 8e       	std	Y+25, r1	; 0x19
		pxCoRoutine->uxPriority = uxPriority;
    a182:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    a184:	bf 8a       	std	Y+23, r11	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    a186:	fe 01       	movw	r30, r28
    a188:	c1 92       	st	Z+, r12
    a18a:	d1 92       	st	Z+, r13
    a18c:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    a18e:	cf 01       	movw	r24, r30
    a190:	0e 94 fe 4f 	call	0x9ffc	; 0x9ffc <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    a194:	ce 01       	movw	r24, r28
    a196:	0c 96       	adiw	r24, 0x0c	; 12
    a198:	0e 94 fe 4f 	call	0x9ffc	; 0x9ffc <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    a19c:	c8 87       	std	Y+8, r28	; 0x08
    a19e:	d9 87       	std	Y+9, r29	; 0x09
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    a1a0:	ca 8b       	std	Y+18, r28	; 0x12
    a1a2:	db 8b       	std	Y+19, r29	; 0x13
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    a1a4:	83 e0       	ldi	r24, 0x03	; 3
    a1a6:	90 e0       	ldi	r25, 0x00	; 0
    a1a8:	8c 87       	std	Y+12, r24	; 0x0c
    a1aa:	9d 87       	std	Y+13, r25	; 0x0d
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    a1ac:	2e 89       	ldd	r18, Y+22	; 0x16
    a1ae:	80 91 e9 25 	lds	r24, 0x25E9
    a1b2:	82 17       	cp	r24, r18
    a1b4:	10 f4       	brcc	.+4      	; 0xa1ba <xCoRoutineCreate+0xb6>
    a1b6:	20 93 e9 25 	sts	0x25E9, r18
    a1ba:	30 e0       	ldi	r19, 0x00	; 0
    a1bc:	c9 01       	movw	r24, r18
    a1be:	43 e0       	ldi	r20, 0x03	; 3
    a1c0:	88 0f       	add	r24, r24
    a1c2:	99 1f       	adc	r25, r25
    a1c4:	4a 95       	dec	r20
    a1c6:	e1 f7       	brne	.-8      	; 0xa1c0 <xCoRoutineCreate+0xbc>
    a1c8:	82 0f       	add	r24, r18
    a1ca:	93 1f       	adc	r25, r19
    a1cc:	86 51       	subi	r24, 0x16	; 22
    a1ce:	9a 4d       	sbci	r25, 0xDA	; 218
    a1d0:	b8 01       	movw	r22, r16
    a1d2:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>

		xReturn = pdPASS;
    a1d6:	81 e0       	ldi	r24, 0x01	; 1
    a1d8:	01 c0       	rjmp	.+2      	; 0xa1dc <xCoRoutineCreate+0xd8>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    a1da:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    a1dc:	df 91       	pop	r29
    a1de:	cf 91       	pop	r28
    a1e0:	1f 91       	pop	r17
    a1e2:	0f 91       	pop	r16
    a1e4:	ff 90       	pop	r15
    a1e6:	ef 90       	pop	r14
    a1e8:	df 90       	pop	r13
    a1ea:	cf 90       	pop	r12
    a1ec:	bf 90       	pop	r11
    a1ee:	08 95       	ret

0000a1f0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    a1f0:	0f 93       	push	r16
    a1f2:	1f 93       	push	r17
    a1f4:	cf 93       	push	r28
    a1f6:	df 93       	push	r29
    a1f8:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    a1fa:	00 91 f7 25 	lds	r16, 0x25F7
    a1fe:	10 91 f8 25 	lds	r17, 0x25F8
    a202:	08 0f       	add	r16, r24
    a204:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a206:	80 91 de 25 	lds	r24, 0x25DE
    a20a:	90 91 df 25 	lds	r25, 0x25DF
    a20e:	02 96       	adiw	r24, 0x02	; 2
    a210:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    a214:	60 91 de 25 	lds	r22, 0x25DE
    a218:	70 91 df 25 	lds	r23, 0x25DF
    a21c:	fb 01       	movw	r30, r22
    a21e:	02 83       	std	Z+2, r16	; 0x02
    a220:	13 83       	std	Z+3, r17	; 0x03

	if( xTimeToWake < xCoRoutineTickCount )
    a222:	80 91 f7 25 	lds	r24, 0x25F7
    a226:	90 91 f8 25 	lds	r25, 0x25F8
    a22a:	6e 5f       	subi	r22, 0xFE	; 254
    a22c:	7f 4f       	sbci	r23, 0xFF	; 255
    a22e:	08 17       	cp	r16, r24
    a230:	19 07       	cpc	r17, r25
    a232:	28 f4       	brcc	.+10     	; 0xa23e <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a234:	80 91 fb 25 	lds	r24, 0x25FB
    a238:	90 91 fc 25 	lds	r25, 0x25FC
    a23c:	04 c0       	rjmp	.+8      	; 0xa246 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a23e:	80 91 f9 25 	lds	r24, 0x25F9
    a242:	90 91 fa 25 	lds	r25, 0x25FA
    a246:	0e 94 27 50 	call	0xa04e	; 0xa04e <vListInsert>
	}

	if( pxEventList )
    a24a:	20 97       	sbiw	r28, 0x00	; 0
    a24c:	49 f0       	breq	.+18     	; 0xa260 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    a24e:	60 91 de 25 	lds	r22, 0x25DE
    a252:	70 91 df 25 	lds	r23, 0x25DF
    a256:	64 5f       	subi	r22, 0xF4	; 244
    a258:	7f 4f       	sbci	r23, 0xFF	; 255
    a25a:	ce 01       	movw	r24, r28
    a25c:	0e 94 27 50 	call	0xa04e	; 0xa04e <vListInsert>
	}
}
    a260:	df 91       	pop	r29
    a262:	cf 91       	pop	r28
    a264:	1f 91       	pop	r17
    a266:	0f 91       	pop	r16
    a268:	08 95       	ret

0000a26a <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    a26a:	0f 93       	push	r16
    a26c:	1f 93       	push	r17
    a26e:	cf 93       	push	r28
    a270:	df 93       	push	r29
    a272:	2e c0       	rjmp	.+92     	; 0xa2d0 <vCoRoutineSchedule+0x66>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    a274:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    a276:	80 91 e0 25 	lds	r24, 0x25E0
    a27a:	88 23       	and	r24, r24
    a27c:	39 f0       	breq	.+14     	; 0xa28c <vCoRoutineSchedule+0x22>
    a27e:	e0 91 e5 25 	lds	r30, 0x25E5
    a282:	f0 91 e6 25 	lds	r31, 0x25E6
    a286:	c6 81       	ldd	r28, Z+6	; 0x06
    a288:	d7 81       	ldd	r29, Z+7	; 0x07
    a28a:	02 c0       	rjmp	.+4      	; 0xa290 <vCoRoutineSchedule+0x26>
    a28c:	c0 e0       	ldi	r28, 0x00	; 0
    a28e:	d0 e0       	ldi	r29, 0x00	; 0
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a290:	ce 01       	movw	r24, r28
    a292:	0c 96       	adiw	r24, 0x0c	; 12
    a294:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
		}
		portENABLE_INTERRUPTS();
    a298:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    a29a:	8e 01       	movw	r16, r28
    a29c:	0e 5f       	subi	r16, 0xFE	; 254
    a29e:	1f 4f       	sbci	r17, 0xFF	; 255
    a2a0:	c8 01       	movw	r24, r16
    a2a2:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    a2a6:	2e 89       	ldd	r18, Y+22	; 0x16
    a2a8:	80 91 e9 25 	lds	r24, 0x25E9
    a2ac:	82 17       	cp	r24, r18
    a2ae:	10 f4       	brcc	.+4      	; 0xa2b4 <vCoRoutineSchedule+0x4a>
    a2b0:	20 93 e9 25 	sts	0x25E9, r18
    a2b4:	30 e0       	ldi	r19, 0x00	; 0
    a2b6:	c9 01       	movw	r24, r18
    a2b8:	f3 e0       	ldi	r31, 0x03	; 3
    a2ba:	88 0f       	add	r24, r24
    a2bc:	99 1f       	adc	r25, r25
    a2be:	fa 95       	dec	r31
    a2c0:	e1 f7       	brne	.-8      	; 0xa2ba <vCoRoutineSchedule+0x50>
    a2c2:	82 0f       	add	r24, r18
    a2c4:	93 1f       	adc	r25, r19
    a2c6:	86 51       	subi	r24, 0x16	; 22
    a2c8:	9a 4d       	sbci	r25, 0xDA	; 218
    a2ca:	b8 01       	movw	r22, r16
    a2cc:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    a2d0:	80 91 e0 25 	lds	r24, 0x25E0
    a2d4:	88 23       	and	r24, r24
    a2d6:	71 f6       	brne	.-100    	; 0xa274 <vCoRoutineSchedule+0xa>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    a2d8:	0e 94 cf 48 	call	0x919e	; 0x919e <xTaskGetTickCount>
    a2dc:	20 91 f3 25 	lds	r18, 0x25F3
    a2e0:	30 91 f4 25 	lds	r19, 0x25F4
    a2e4:	82 1b       	sub	r24, r18
    a2e6:	93 0b       	sbc	r25, r19
    a2e8:	80 93 f5 25 	sts	0x25F5, r24
    a2ec:	90 93 f6 25 	sts	0x25F6, r25
    a2f0:	5b c0       	rjmp	.+182    	; 0xa3a8 <vCoRoutineSchedule+0x13e>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    a2f2:	01 96       	adiw	r24, 0x01	; 1
    a2f4:	80 93 f7 25 	sts	0x25F7, r24
    a2f8:	90 93 f8 25 	sts	0x25F8, r25
		xPassedTicks--;
    a2fc:	21 50       	subi	r18, 0x01	; 1
    a2fe:	30 40       	sbci	r19, 0x00	; 0
    a300:	20 93 f5 25 	sts	0x25F5, r18
    a304:	30 93 f6 25 	sts	0x25F6, r19

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    a308:	00 97       	sbiw	r24, 0x00	; 0
    a30a:	09 f0       	breq	.+2      	; 0xa30e <vCoRoutineSchedule+0xa4>
    a30c:	3f c0       	rjmp	.+126    	; 0xa38c <vCoRoutineSchedule+0x122>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    a30e:	80 91 f9 25 	lds	r24, 0x25F9
    a312:	90 91 fa 25 	lds	r25, 0x25FA
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    a316:	20 91 fb 25 	lds	r18, 0x25FB
    a31a:	30 91 fc 25 	lds	r19, 0x25FC
    a31e:	20 93 f9 25 	sts	0x25F9, r18
    a322:	30 93 fa 25 	sts	0x25FA, r19
			pxOverflowDelayedCoRoutineList = pxTemp;
    a326:	80 93 fb 25 	sts	0x25FB, r24
    a32a:	90 93 fc 25 	sts	0x25FC, r25
    a32e:	2e c0       	rjmp	.+92     	; 0xa38c <vCoRoutineSchedule+0x122>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    a330:	20 91 f7 25 	lds	r18, 0x25F7
    a334:	30 91 f8 25 	lds	r19, 0x25F8
    a338:	8a 81       	ldd	r24, Y+2	; 0x02
    a33a:	9b 81       	ldd	r25, Y+3	; 0x03
    a33c:	28 17       	cp	r18, r24
    a33e:	39 07       	cpc	r19, r25
    a340:	98 f1       	brcs	.+102    	; 0xa3a8 <vCoRoutineSchedule+0x13e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    a342:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    a344:	8e 01       	movw	r16, r28
    a346:	0e 5f       	subi	r16, 0xFE	; 254
    a348:	1f 4f       	sbci	r17, 0xFF	; 255
    a34a:	c8 01       	movw	r24, r16
    a34c:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    a350:	8c 89       	ldd	r24, Y+20	; 0x14
    a352:	9d 89       	ldd	r25, Y+21	; 0x15
    a354:	00 97       	sbiw	r24, 0x00	; 0
    a356:	21 f0       	breq	.+8      	; 0xa360 <vCoRoutineSchedule+0xf6>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    a358:	ce 01       	movw	r24, r28
    a35a:	0c 96       	adiw	r24, 0x0c	; 12
    a35c:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    a360:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    a362:	2e 89       	ldd	r18, Y+22	; 0x16
    a364:	80 91 e9 25 	lds	r24, 0x25E9
    a368:	82 17       	cp	r24, r18
    a36a:	10 f4       	brcc	.+4      	; 0xa370 <vCoRoutineSchedule+0x106>
    a36c:	20 93 e9 25 	sts	0x25E9, r18
    a370:	30 e0       	ldi	r19, 0x00	; 0
    a372:	c9 01       	movw	r24, r18
    a374:	e3 e0       	ldi	r30, 0x03	; 3
    a376:	88 0f       	add	r24, r24
    a378:	99 1f       	adc	r25, r25
    a37a:	ea 95       	dec	r30
    a37c:	e1 f7       	brne	.-8      	; 0xa376 <vCoRoutineSchedule+0x10c>
    a37e:	82 0f       	add	r24, r18
    a380:	93 1f       	adc	r25, r19
    a382:	86 51       	subi	r24, 0x16	; 22
    a384:	9a 4d       	sbci	r25, 0xDA	; 218
    a386:	b8 01       	movw	r22, r16
    a388:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    a38c:	e0 91 f9 25 	lds	r30, 0x25F9
    a390:	f0 91 fa 25 	lds	r31, 0x25FA
    a394:	80 81       	ld	r24, Z
    a396:	88 23       	and	r24, r24
    a398:	39 f0       	breq	.+14     	; 0xa3a8 <vCoRoutineSchedule+0x13e>
    a39a:	05 80       	ldd	r0, Z+5	; 0x05
    a39c:	f6 81       	ldd	r31, Z+6	; 0x06
    a39e:	e0 2d       	mov	r30, r0
    a3a0:	c6 81       	ldd	r28, Z+6	; 0x06
    a3a2:	d7 81       	ldd	r29, Z+7	; 0x07
    a3a4:	20 97       	sbiw	r28, 0x00	; 0
    a3a6:	21 f6       	brne	.-120    	; 0xa330 <vCoRoutineSchedule+0xc6>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    a3a8:	20 91 f5 25 	lds	r18, 0x25F5
    a3ac:	30 91 f6 25 	lds	r19, 0x25F6
    a3b0:	80 91 f7 25 	lds	r24, 0x25F7
    a3b4:	90 91 f8 25 	lds	r25, 0x25F8
    a3b8:	21 15       	cp	r18, r1
    a3ba:	31 05       	cpc	r19, r1
    a3bc:	09 f0       	breq	.+2      	; 0xa3c0 <vCoRoutineSchedule+0x156>
    a3be:	99 cf       	rjmp	.-206    	; 0xa2f2 <vCoRoutineSchedule+0x88>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    a3c0:	80 93 f3 25 	sts	0x25F3, r24
    a3c4:	90 93 f4 25 	sts	0x25F4, r25
    a3c8:	40 91 e9 25 	lds	r20, 0x25E9

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a3cc:	06 c0       	rjmp	.+12     	; 0xa3da <vCoRoutineSchedule+0x170>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    a3ce:	44 23       	and	r20, r20
    a3d0:	19 f4       	brne	.+6      	; 0xa3d8 <vCoRoutineSchedule+0x16e>
    a3d2:	10 92 e9 25 	sts	0x25E9, r1
    a3d6:	40 c0       	rjmp	.+128    	; 0xa458 <vCoRoutineSchedule+0x1ee>
    a3d8:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a3da:	84 2f       	mov	r24, r20
    a3dc:	90 e0       	ldi	r25, 0x00	; 0
    a3de:	9c 01       	movw	r18, r24
    a3e0:	73 e0       	ldi	r23, 0x03	; 3
    a3e2:	22 0f       	add	r18, r18
    a3e4:	33 1f       	adc	r19, r19
    a3e6:	7a 95       	dec	r23
    a3e8:	e1 f7       	brne	.-8      	; 0xa3e2 <vCoRoutineSchedule+0x178>
    a3ea:	28 0f       	add	r18, r24
    a3ec:	39 1f       	adc	r19, r25
    a3ee:	f9 01       	movw	r30, r18
    a3f0:	e6 51       	subi	r30, 0x16	; 22
    a3f2:	fa 4d       	sbci	r31, 0xDA	; 218
    a3f4:	50 81       	ld	r21, Z
    a3f6:	55 23       	and	r21, r21
    a3f8:	51 f3       	breq	.-44     	; 0xa3ce <vCoRoutineSchedule+0x164>
    a3fa:	40 93 e9 25 	sts	0x25E9, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    a3fe:	a1 81       	ldd	r26, Z+1	; 0x01
    a400:	b2 81       	ldd	r27, Z+2	; 0x02
    a402:	12 96       	adiw	r26, 0x02	; 2
    a404:	0d 90       	ld	r0, X+
    a406:	bc 91       	ld	r27, X
    a408:	a0 2d       	mov	r26, r0
    a40a:	a1 83       	std	Z+1, r26	; 0x01
    a40c:	b2 83       	std	Z+2, r27	; 0x02
    a40e:	23 51       	subi	r18, 0x13	; 19
    a410:	3a 4d       	sbci	r19, 0xDA	; 218
    a412:	a2 17       	cp	r26, r18
    a414:	b3 07       	cpc	r27, r19
    a416:	31 f4       	brne	.+12     	; 0xa424 <vCoRoutineSchedule+0x1ba>
    a418:	12 96       	adiw	r26, 0x02	; 2
    a41a:	2d 91       	ld	r18, X+
    a41c:	3c 91       	ld	r19, X
    a41e:	13 97       	sbiw	r26, 0x03	; 3
    a420:	21 83       	std	Z+1, r18	; 0x01
    a422:	32 83       	std	Z+2, r19	; 0x02
    a424:	fc 01       	movw	r30, r24
    a426:	63 e0       	ldi	r22, 0x03	; 3
    a428:	ee 0f       	add	r30, r30
    a42a:	ff 1f       	adc	r31, r31
    a42c:	6a 95       	dec	r22
    a42e:	e1 f7       	brne	.-8      	; 0xa428 <vCoRoutineSchedule+0x1be>
    a430:	e8 0f       	add	r30, r24
    a432:	f9 1f       	adc	r31, r25
    a434:	e6 51       	subi	r30, 0x16	; 22
    a436:	fa 4d       	sbci	r31, 0xDA	; 218
    a438:	01 80       	ldd	r0, Z+1	; 0x01
    a43a:	f2 81       	ldd	r31, Z+2	; 0x02
    a43c:	e0 2d       	mov	r30, r0
    a43e:	a6 81       	ldd	r26, Z+6	; 0x06
    a440:	b7 81       	ldd	r27, Z+7	; 0x07
    a442:	a0 93 de 25 	sts	0x25DE, r26
    a446:	b0 93 df 25 	sts	0x25DF, r27

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    a44a:	ed 91       	ld	r30, X+
    a44c:	fc 91       	ld	r31, X
    a44e:	11 97       	sbiw	r26, 0x01	; 1
    a450:	cd 01       	movw	r24, r26
    a452:	57 96       	adiw	r26, 0x17	; 23
    a454:	6c 91       	ld	r22, X
    a456:	19 95       	eicall

	return;
}
    a458:	df 91       	pop	r29
    a45a:	cf 91       	pop	r28
    a45c:	1f 91       	pop	r17
    a45e:	0f 91       	pop	r16
    a460:	08 95       	ret

0000a462 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    a462:	0f 93       	push	r16
    a464:	1f 93       	push	r17
    a466:	cf 93       	push	r28
    a468:	df 93       	push	r29
    a46a:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    a46c:	80 81       	ld	r24, Z
    a46e:	88 23       	and	r24, r24
    a470:	31 f0       	breq	.+12     	; 0xa47e <xCoRoutineRemoveFromEventList+0x1c>
    a472:	05 80       	ldd	r0, Z+5	; 0x05
    a474:	f6 81       	ldd	r31, Z+6	; 0x06
    a476:	e0 2d       	mov	r30, r0
    a478:	c6 81       	ldd	r28, Z+6	; 0x06
    a47a:	d7 81       	ldd	r29, Z+7	; 0x07
    a47c:	02 c0       	rjmp	.+4      	; 0xa482 <xCoRoutineRemoveFromEventList+0x20>
    a47e:	c0 e0       	ldi	r28, 0x00	; 0
    a480:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a482:	8e 01       	movw	r16, r28
    a484:	04 5f       	subi	r16, 0xF4	; 244
    a486:	1f 4f       	sbci	r17, 0xFF	; 255
    a488:	c8 01       	movw	r24, r16
    a48a:	0e 94 5e 50 	call	0xa0bc	; 0xa0bc <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    a48e:	80 ee       	ldi	r24, 0xE0	; 224
    a490:	95 e2       	ldi	r25, 0x25	; 37
    a492:	b8 01       	movw	r22, r16
    a494:	0e 94 02 50 	call	0xa004	; 0xa004 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    a498:	e0 91 de 25 	lds	r30, 0x25DE
    a49c:	f0 91 df 25 	lds	r31, 0x25DF
	{
		xReturn = pdTRUE;
    a4a0:	81 e0       	ldi	r24, 0x01	; 1
    a4a2:	2e 89       	ldd	r18, Y+22	; 0x16
    a4a4:	96 89       	ldd	r25, Z+22	; 0x16
    a4a6:	29 17       	cp	r18, r25
    a4a8:	08 f4       	brcc	.+2      	; 0xa4ac <xCoRoutineRemoveFromEventList+0x4a>
    a4aa:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    a4ac:	df 91       	pop	r29
    a4ae:	cf 91       	pop	r28
    a4b0:	1f 91       	pop	r17
    a4b2:	0f 91       	pop	r16
    a4b4:	08 95       	ret

0000a4b6 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    a4b6:	ef 92       	push	r14
    a4b8:	ff 92       	push	r15
    a4ba:	0f 93       	push	r16
    a4bc:	1f 93       	push	r17
    a4be:	cf 93       	push	r28
    a4c0:	df 93       	push	r29
    a4c2:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    a4c4:	0e 94 c9 48 	call	0x9192	; 0x9192 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    a4c8:	c0 91 0f 26 	lds	r28, 0x260F
    a4cc:	d0 91 10 26 	lds	r29, 0x2610
    a4d0:	0c 0f       	add	r16, r28
    a4d2:	1d 1f       	adc	r17, r29
    a4d4:	2b e0       	ldi	r18, 0x0B	; 11
    a4d6:	08 3b       	cpi	r16, 0xB8	; 184
    a4d8:	12 07       	cpc	r17, r18
    a4da:	50 f4       	brcc	.+20     	; 0xa4f0 <pvPortMalloc+0x3a>
    a4dc:	c0 17       	cp	r28, r16
    a4de:	d1 07       	cpc	r29, r17
    a4e0:	38 f4       	brcc	.+14     	; 0xa4f0 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    a4e2:	cf 5e       	subi	r28, 0xEF	; 239
    a4e4:	d9 4d       	sbci	r29, 0xD9	; 217
			xNextFreeByte += xWantedSize;			
    a4e6:	00 93 0f 26 	sts	0x260F, r16
    a4ea:	10 93 10 26 	sts	0x2610, r17
    a4ee:	02 c0       	rjmp	.+4      	; 0xa4f4 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    a4f0:	c0 e0       	ldi	r28, 0x00	; 0
    a4f2:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    a4f4:	0e 94 86 49 	call	0x930c	; 0x930c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    a4f8:	ce 01       	movw	r24, r28
    a4fa:	df 91       	pop	r29
    a4fc:	cf 91       	pop	r28
    a4fe:	1f 91       	pop	r17
    a500:	0f 91       	pop	r16
    a502:	ff 90       	pop	r15
    a504:	ef 90       	pop	r14
    a506:	08 95       	ret

0000a508 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    a508:	08 95       	ret

0000a50a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    a50a:	10 92 0f 26 	sts	0x260F, r1
    a50e:	10 92 10 26 	sts	0x2610, r1
}
    a512:	08 95       	ret

0000a514 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    a514:	28 eb       	ldi	r18, 0xB8	; 184
    a516:	3b e0       	ldi	r19, 0x0B	; 11
    a518:	80 91 0f 26 	lds	r24, 0x260F
    a51c:	90 91 10 26 	lds	r25, 0x2610
    a520:	28 1b       	sub	r18, r24
    a522:	39 0b       	sbc	r19, r25
}
    a524:	c9 01       	movw	r24, r18
    a526:	08 95       	ret

0000a528 <pxPortInitialiseStack>:
  uint32_t usAddress;
/**
 * Place a few bytes of known values on the bottom of the stack.
 * This is just useful for debugging.
 */ //TODO Adam: zrobi? kompilacj? warunkow? wy??czaj?c? to debugowanie 
  *pxTopOfStack = 0x11;
    a528:	31 e1       	ldi	r19, 0x11	; 17
    a52a:	fc 01       	movw	r30, r24
    a52c:	30 83       	st	Z, r19
  pxTopOfStack--;
  *pxTopOfStack = 0x22;
    a52e:	22 e2       	ldi	r18, 0x22	; 34
    a530:	22 93       	st	-Z, r18
  pxTopOfStack--;
  *pxTopOfStack = 0x33;
    a532:	83 e3       	ldi	r24, 0x33	; 51
    a534:	82 93       	st	-Z, r24
	/* end of original code block */

	/* The way it should be done for xmega with probably  more than 128K program memory.
	 * Warning is OK here - type incompatibility does not matter - usAddress is only
	 * used as temporary storage */
  usAddress = ( uint32_t ) pxCode;
    a536:	88 27       	eor	r24, r24
    a538:	77 fd       	sbrc	r23, 7
    a53a:	80 95       	com	r24
    a53c:	98 2f       	mov	r25, r24

  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff );
    a53e:	62 93       	st	-Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff ); //tu powinno byc chyba 000000FF
	pxTopOfStack--;
	usAddress >>= 8;
#endif*/

  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff ); //tu powinno byc chyba 000000FF
    a540:	72 93       	st	-Z, r23
/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
  portSAVE_CONTEXT places the flags on the stack immediately after r0
  to ensure the interrupts get disabled as soon as possible, and so ensuring
  the stack use is minimal should a context switch interrupt occur. */

  *pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    a542:	12 92       	st	-Z, r1
  pxTopOfStack--;
  *pxTopOfStack = portFLAGS_INT_ENABLED;
    a544:	80 e8       	ldi	r24, 0x80	; 128
    a546:	82 93       	st	-Z, r24
  pxTopOfStack--;


/* Now the remaining registers.   The compiler expects R1 to be 0. */

  *pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    a548:	12 92       	st	-Z, r1
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    a54a:	82 e0       	ldi	r24, 0x02	; 2
    a54c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    a54e:	83 e0       	ldi	r24, 0x03	; 3
    a550:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    a552:	84 e0       	ldi	r24, 0x04	; 4
    a554:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    a556:	85 e0       	ldi	r24, 0x05	; 5
    a558:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    a55a:	86 e0       	ldi	r24, 0x06	; 6
    a55c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    a55e:	87 e0       	ldi	r24, 0x07	; 7
    a560:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    a562:	88 e0       	ldi	r24, 0x08	; 8
    a564:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    a566:	89 e0       	ldi	r24, 0x09	; 9
    a568:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    a56a:	80 e1       	ldi	r24, 0x10	; 16
    a56c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    a56e:	32 93       	st	-Z, r19
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    a570:	82 e1       	ldi	r24, 0x12	; 18
    a572:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    a574:	83 e1       	ldi	r24, 0x13	; 19
    a576:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    a578:	84 e1       	ldi	r24, 0x14	; 20
    a57a:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    a57c:	85 e1       	ldi	r24, 0x15	; 21
    a57e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    a580:	86 e1       	ldi	r24, 0x16	; 22
    a582:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    a584:	87 e1       	ldi	r24, 0x17	; 23
    a586:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    a588:	88 e1       	ldi	r24, 0x18	; 24
    a58a:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    a58c:	89 e1       	ldi	r24, 0x19	; 25
    a58e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    a590:	80 e2       	ldi	r24, 0x20	; 32
    a592:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    a594:	81 e2       	ldi	r24, 0x21	; 33
    a596:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    a598:	22 93       	st	-Z, r18
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    a59a:	83 e2       	ldi	r24, 0x23	; 35
    a59c:	82 93       	st	-Z, r24
  pxTopOfStack--;
	/* Place the parameter on the stack in the expected location. */
  usAddress = ( unsigned short ) pvParameters;
  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    a59e:	42 93       	st	-Z, r20
  pxTopOfStack--;

  usAddress >>= 8;
  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    a5a0:	52 93       	st	-Z, r21
  pxTopOfStack--;

  *pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    a5a2:	86 e2       	ldi	r24, 0x26	; 38
    a5a4:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    a5a6:	87 e2       	ldi	r24, 0x27	; 39
    a5a8:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    a5aa:	88 e2       	ldi	r24, 0x28	; 40
    a5ac:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    a5ae:	89 e2       	ldi	r24, 0x29	; 41
    a5b0:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    a5b2:	80 e3       	ldi	r24, 0x30	; 48
    a5b4:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x31;	/* R31 */
    a5b6:	81 e3       	ldi	r24, 0x31	; 49
    a5b8:	82 93       	st	-Z, r24
  pxTopOfStack--;
/* these registers are also part of execution context
 * Corresponing registars are saved and restored in saveCONTEXT and restoreCONTEXT
 * TODO  See datasheet for explanation
 */
  *pxTopOfStack = ( portSTACK_TYPE ) 0x38;	/* 38 RAMPD */
    a5ba:	88 e3       	ldi	r24, 0x38	; 56
    a5bc:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x39;	/* 39 RAMPX */
    a5be:	89 e3       	ldi	r24, 0x39	; 57
    a5c0:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3a;	/* 3a RAMPY */
    a5c2:	8a e3       	ldi	r24, 0x3A	; 58
    a5c4:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3b;	/* 3b RAMPZ */
    a5c6:	8b e3       	ldi	r24, 0x3B	; 59
    a5c8:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3c;	/* 3c EIND */
    a5ca:	8c e3       	ldi	r24, 0x3C	; 60
    a5cc:	82 93       	st	-Z, r24
  pxTopOfStack--;
    a5ce:	9f 01       	movw	r18, r30
    a5d0:	21 50       	subi	r18, 0x01	; 1
    a5d2:	30 40       	sbci	r19, 0x00	; 0

/*lint +e950 +e611 +e923 */

  return pxTopOfStack;
}
    a5d4:	c9 01       	movw	r24, r18
    a5d6:	08 95       	ret

0000a5d8 <xPortStartScheduler>:
0110 DIV256 Prescaler clk/256
0111 DIV1024 Prescaler clk/1024
1xxx EVCHn event chanerl n, n=[0...7]
*/
///select the clock source and pre-scale by 64	
  TCC0.CTRLA= ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_DIV64_gc;
    a5d8:	e0 e0       	ldi	r30, 0x00	; 0
    a5da:	f8 e0       	ldi	r31, 0x08	; 8
    a5dc:	80 81       	ld	r24, Z
    a5de:	80 7f       	andi	r24, 0xF0	; 240
    a5e0:	85 60       	ori	r24, 0x05	; 5
    a5e2:	80 83       	st	Z, r24
  TC_CLKSEL_EVCH5_gc =   (0x0D<<0),   // Event Channel 5 
  TC_CLKSEL_EVCH6_gc =   (0x0E<<0),   // Event Channel 6 
  TC_CLKSEL_EVCH7_gc =   (0x0F<<0),   // Event Channel 7 
*/
/// set period of counter
  TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ/64-1; // tu zmienic 16Mhz/1000/
    a5e4:	89 ef       	ldi	r24, 0xF9	; 249
    a5e6:	90 e0       	ldi	r25, 0x00	; 0
    a5e8:	86 a3       	std	Z+38, r24	; 0x26
    a5ea:	97 a3       	std	Z+39, r25	; 0x27
	+---+---+---+---+---+---+---+---+
	|    PER [7:0]                  | 
	+---+---+---+---+---+---+---+---+
*/
/// enable interrupt and set low level	
  TCC0.INTCTRLA = ( TCC0.INTCTRLA & ~TC0_OVFINTLVL_gm ) | TC_OVFINTLVL_LO_gc;
    a5ec:	86 81       	ldd	r24, Z+6	; 0x06
    a5ee:	8c 7f       	andi	r24, 0xFC	; 252
    a5f0:	81 60       	ori	r24, 0x01	; 1
    a5f2:	86 83       	std	Z+6, r24	; 0x06
+---+---+---+---+--------+--------+--------+--------+
| - | - | - | - | ERRINTLVL[1:0]  | OVFINTLVL [1:0] |
+---+---+---+---+--------+--------+--------+--------+
*/
/// enable low level interrupts   
  PMIC.CTRL |= PMIC_LOLVLEN_bm;
    a5f4:	e0 ea       	ldi	r30, 0xA0	; 160
    a5f6:	f0 e0       	ldi	r31, 0x00	; 0
    a5f8:	82 81       	ldd	r24, Z+2	; 0x02
    a5fa:	81 60       	ori	r24, 0x01	; 1
    a5fc:	82 83       	std	Z+2, r24	; 0x02
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();


	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    a5fe:	a0 91 55 25 	lds	r26, 0x2555
    a602:	b0 91 56 25 	lds	r27, 0x2556
    a606:	cd 91       	ld	r28, X+
    a608:	cd bf       	out	0x3d, r28	; 61
    a60a:	dd 91       	ld	r29, X+
    a60c:	de bf       	out	0x3e, r29	; 62
    a60e:	0f 91       	pop	r16
    a610:	0c bf       	out	0x3c, r16	; 60
    a612:	0f 91       	pop	r16
    a614:	0b bf       	out	0x3b, r16	; 59
    a616:	0f 91       	pop	r16
    a618:	0a bf       	out	0x3a, r16	; 58
    a61a:	0f 91       	pop	r16
    a61c:	09 bf       	out	0x39, r16	; 57
    a61e:	0f 91       	pop	r16
    a620:	08 bf       	out	0x38, r16	; 56
    a622:	ff 91       	pop	r31
    a624:	ef 91       	pop	r30
    a626:	df 91       	pop	r29
    a628:	cf 91       	pop	r28
    a62a:	bf 91       	pop	r27
    a62c:	af 91       	pop	r26
    a62e:	9f 91       	pop	r25
    a630:	8f 91       	pop	r24
    a632:	7f 91       	pop	r23
    a634:	6f 91       	pop	r22
    a636:	5f 91       	pop	r21
    a638:	4f 91       	pop	r20
    a63a:	3f 91       	pop	r19
    a63c:	2f 91       	pop	r18
    a63e:	1f 91       	pop	r17
    a640:	0f 91       	pop	r16
    a642:	ff 90       	pop	r15
    a644:	ef 90       	pop	r14
    a646:	df 90       	pop	r13
    a648:	cf 90       	pop	r12
    a64a:	bf 90       	pop	r11
    a64c:	af 90       	pop	r10
    a64e:	9f 90       	pop	r9
    a650:	8f 90       	pop	r8
    a652:	7f 90       	pop	r7
    a654:	6f 90       	pop	r6
    a656:	5f 90       	pop	r5
    a658:	4f 90       	pop	r4
    a65a:	3f 90       	pop	r3
    a65c:	2f 90       	pop	r2
    a65e:	1f 90       	pop	r1
    a660:	0f 90       	pop	r0
    a662:	0f be       	out	0x3f, r0	; 63
    a664:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    a666:	08 95       	ret


	/* Should not get here. */
	return pdTRUE;
}
    a668:	81 e0       	ldi	r24, 0x01	; 1
    a66a:	08 95       	ret

0000a66c <vPortEndScheduler>:
void vPortEndScheduler( void )
{
/* 
 * It is unlikely that the AVR port will get stopped.  If required simply
 * disable the tick interrupt here. */
}
    a66c:	08 95       	ret

0000a66e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
  portSAVE_CONTEXT();
    a66e:	0f 92       	push	r0
    a670:	0f b6       	in	r0, 0x3f	; 63
    a672:	f8 94       	cli
    a674:	0f 92       	push	r0
    a676:	1f 92       	push	r1
    a678:	11 24       	eor	r1, r1
    a67a:	2f 92       	push	r2
    a67c:	3f 92       	push	r3
    a67e:	4f 92       	push	r4
    a680:	5f 92       	push	r5
    a682:	6f 92       	push	r6
    a684:	7f 92       	push	r7
    a686:	8f 92       	push	r8
    a688:	9f 92       	push	r9
    a68a:	af 92       	push	r10
    a68c:	bf 92       	push	r11
    a68e:	cf 92       	push	r12
    a690:	df 92       	push	r13
    a692:	ef 92       	push	r14
    a694:	ff 92       	push	r15
    a696:	0f 93       	push	r16
    a698:	1f 93       	push	r17
    a69a:	2f 93       	push	r18
    a69c:	3f 93       	push	r19
    a69e:	4f 93       	push	r20
    a6a0:	5f 93       	push	r21
    a6a2:	6f 93       	push	r22
    a6a4:	7f 93       	push	r23
    a6a6:	8f 93       	push	r24
    a6a8:	9f 93       	push	r25
    a6aa:	af 93       	push	r26
    a6ac:	bf 93       	push	r27
    a6ae:	cf 93       	push	r28
    a6b0:	df 93       	push	r29
    a6b2:	ef 93       	push	r30
    a6b4:	ff 93       	push	r31
    a6b6:	08 b7       	in	r16, 0x38	; 56
    a6b8:	0f 93       	push	r16
    a6ba:	09 b7       	in	r16, 0x39	; 57
    a6bc:	0f 93       	push	r16
    a6be:	0a b7       	in	r16, 0x3a	; 58
    a6c0:	0f 93       	push	r16
    a6c2:	0b b7       	in	r16, 0x3b	; 59
    a6c4:	0f 93       	push	r16
    a6c6:	0c b7       	in	r16, 0x3c	; 60
    a6c8:	0f 93       	push	r16
    a6ca:	a0 91 55 25 	lds	r26, 0x2555
    a6ce:	b0 91 56 25 	lds	r27, 0x2556
    a6d2:	0d b6       	in	r0, 0x3d	; 61
    a6d4:	0d 92       	st	X+, r0
    a6d6:	0e b6       	in	r0, 0x3e	; 62
    a6d8:	0d 92       	st	X+, r0
  vTaskSwitchContext();
    a6da:	0e 94 f5 4a 	call	0x95ea	; 0x95ea <vTaskSwitchContext>
  portRESTORE_CONTEXT();
    a6de:	a0 91 55 25 	lds	r26, 0x2555
    a6e2:	b0 91 56 25 	lds	r27, 0x2556
    a6e6:	cd 91       	ld	r28, X+
    a6e8:	cd bf       	out	0x3d, r28	; 61
    a6ea:	dd 91       	ld	r29, X+
    a6ec:	de bf       	out	0x3e, r29	; 62
    a6ee:	0f 91       	pop	r16
    a6f0:	0c bf       	out	0x3c, r16	; 60
    a6f2:	0f 91       	pop	r16
    a6f4:	0b bf       	out	0x3b, r16	; 59
    a6f6:	0f 91       	pop	r16
    a6f8:	0a bf       	out	0x3a, r16	; 58
    a6fa:	0f 91       	pop	r16
    a6fc:	09 bf       	out	0x39, r16	; 57
    a6fe:	0f 91       	pop	r16
    a700:	08 bf       	out	0x38, r16	; 56
    a702:	ff 91       	pop	r31
    a704:	ef 91       	pop	r30
    a706:	df 91       	pop	r29
    a708:	cf 91       	pop	r28
    a70a:	bf 91       	pop	r27
    a70c:	af 91       	pop	r26
    a70e:	9f 91       	pop	r25
    a710:	8f 91       	pop	r24
    a712:	7f 91       	pop	r23
    a714:	6f 91       	pop	r22
    a716:	5f 91       	pop	r21
    a718:	4f 91       	pop	r20
    a71a:	3f 91       	pop	r19
    a71c:	2f 91       	pop	r18
    a71e:	1f 91       	pop	r17
    a720:	0f 91       	pop	r16
    a722:	ff 90       	pop	r15
    a724:	ef 90       	pop	r14
    a726:	df 90       	pop	r13
    a728:	cf 90       	pop	r12
    a72a:	bf 90       	pop	r11
    a72c:	af 90       	pop	r10
    a72e:	9f 90       	pop	r9
    a730:	8f 90       	pop	r8
    a732:	7f 90       	pop	r7
    a734:	6f 90       	pop	r6
    a736:	5f 90       	pop	r5
    a738:	4f 90       	pop	r4
    a73a:	3f 90       	pop	r3
    a73c:	2f 90       	pop	r2
    a73e:	1f 90       	pop	r1
    a740:	0f 90       	pop	r0
    a742:	0f be       	out	0x3f, r0	; 63
    a744:	0f 90       	pop	r0

  asm volatile ( "ret" );
    a746:	08 95       	ret

0000a748 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
  portSAVE_CONTEXT();
    a748:	0f 92       	push	r0
    a74a:	0f b6       	in	r0, 0x3f	; 63
    a74c:	f8 94       	cli
    a74e:	0f 92       	push	r0
    a750:	1f 92       	push	r1
    a752:	11 24       	eor	r1, r1
    a754:	2f 92       	push	r2
    a756:	3f 92       	push	r3
    a758:	4f 92       	push	r4
    a75a:	5f 92       	push	r5
    a75c:	6f 92       	push	r6
    a75e:	7f 92       	push	r7
    a760:	8f 92       	push	r8
    a762:	9f 92       	push	r9
    a764:	af 92       	push	r10
    a766:	bf 92       	push	r11
    a768:	cf 92       	push	r12
    a76a:	df 92       	push	r13
    a76c:	ef 92       	push	r14
    a76e:	ff 92       	push	r15
    a770:	0f 93       	push	r16
    a772:	1f 93       	push	r17
    a774:	2f 93       	push	r18
    a776:	3f 93       	push	r19
    a778:	4f 93       	push	r20
    a77a:	5f 93       	push	r21
    a77c:	6f 93       	push	r22
    a77e:	7f 93       	push	r23
    a780:	8f 93       	push	r24
    a782:	9f 93       	push	r25
    a784:	af 93       	push	r26
    a786:	bf 93       	push	r27
    a788:	cf 93       	push	r28
    a78a:	df 93       	push	r29
    a78c:	ef 93       	push	r30
    a78e:	ff 93       	push	r31
    a790:	08 b7       	in	r16, 0x38	; 56
    a792:	0f 93       	push	r16
    a794:	09 b7       	in	r16, 0x39	; 57
    a796:	0f 93       	push	r16
    a798:	0a b7       	in	r16, 0x3a	; 58
    a79a:	0f 93       	push	r16
    a79c:	0b b7       	in	r16, 0x3b	; 59
    a79e:	0f 93       	push	r16
    a7a0:	0c b7       	in	r16, 0x3c	; 60
    a7a2:	0f 93       	push	r16
    a7a4:	a0 91 55 25 	lds	r26, 0x2555
    a7a8:	b0 91 56 25 	lds	r27, 0x2556
    a7ac:	0d b6       	in	r0, 0x3d	; 61
    a7ae:	0d 92       	st	X+, r0
    a7b0:	0e b6       	in	r0, 0x3e	; 62
    a7b2:	0d 92       	st	X+, r0
  vTaskIncrementTick();
    a7b4:	0e 94 0e 49 	call	0x921c	; 0x921c <vTaskIncrementTick>
  vTaskSwitchContext();
    a7b8:	0e 94 f5 4a 	call	0x95ea	; 0x95ea <vTaskSwitchContext>
  portRESTORE_CONTEXT();
    a7bc:	a0 91 55 25 	lds	r26, 0x2555
    a7c0:	b0 91 56 25 	lds	r27, 0x2556
    a7c4:	cd 91       	ld	r28, X+
    a7c6:	cd bf       	out	0x3d, r28	; 61
    a7c8:	dd 91       	ld	r29, X+
    a7ca:	de bf       	out	0x3e, r29	; 62
    a7cc:	0f 91       	pop	r16
    a7ce:	0c bf       	out	0x3c, r16	; 60
    a7d0:	0f 91       	pop	r16
    a7d2:	0b bf       	out	0x3b, r16	; 59
    a7d4:	0f 91       	pop	r16
    a7d6:	0a bf       	out	0x3a, r16	; 58
    a7d8:	0f 91       	pop	r16
    a7da:	09 bf       	out	0x39, r16	; 57
    a7dc:	0f 91       	pop	r16
    a7de:	08 bf       	out	0x38, r16	; 56
    a7e0:	ff 91       	pop	r31
    a7e2:	ef 91       	pop	r30
    a7e4:	df 91       	pop	r29
    a7e6:	cf 91       	pop	r28
    a7e8:	bf 91       	pop	r27
    a7ea:	af 91       	pop	r26
    a7ec:	9f 91       	pop	r25
    a7ee:	8f 91       	pop	r24
    a7f0:	7f 91       	pop	r23
    a7f2:	6f 91       	pop	r22
    a7f4:	5f 91       	pop	r21
    a7f6:	4f 91       	pop	r20
    a7f8:	3f 91       	pop	r19
    a7fa:	2f 91       	pop	r18
    a7fc:	1f 91       	pop	r17
    a7fe:	0f 91       	pop	r16
    a800:	ff 90       	pop	r15
    a802:	ef 90       	pop	r14
    a804:	df 90       	pop	r13
    a806:	cf 90       	pop	r12
    a808:	bf 90       	pop	r11
    a80a:	af 90       	pop	r10
    a80c:	9f 90       	pop	r9
    a80e:	8f 90       	pop	r8
    a810:	7f 90       	pop	r7
    a812:	6f 90       	pop	r6
    a814:	5f 90       	pop	r5
    a816:	4f 90       	pop	r4
    a818:	3f 90       	pop	r3
    a81a:	2f 90       	pop	r2
    a81c:	1f 90       	pop	r1
    a81e:	0f 90       	pop	r0
    a820:	0f be       	out	0x3f, r0	; 63
    a822:	0f 90       	pop	r0

  asm volatile ( "ret" );
    a824:	08 95       	ret

0000a826 <__vector_14>:
 * tick count.  We don't need to switch context, this can only be done by
 * manual calls to taskYIELD();
 */
ISR (TCC0_OVF_vect, ISR_NAKED)
{
  vTaskIncrementTick();
    a826:	0e 94 0e 49 	call	0x921c	; 0x921c <vTaskIncrementTick>

0000a82a <__udivmodqi4>:
}
    a82a:	99 1b       	sub	r25, r25
    a82c:	79 e0       	ldi	r23, 0x09	; 9
    a82e:	04 c0       	rjmp	.+8      	; 0xa838 <__udivmodqi4_ep>

0000a830 <__udivmodqi4_loop>:
    a830:	99 1f       	adc	r25, r25
    a832:	96 17       	cp	r25, r22
    a834:	08 f0       	brcs	.+2      	; 0xa838 <__udivmodqi4_ep>
    a836:	96 1b       	sub	r25, r22

0000a838 <__udivmodqi4_ep>:
    a838:	88 1f       	adc	r24, r24
    a83a:	7a 95       	dec	r23
    a83c:	c9 f7       	brne	.-14     	; 0xa830 <__udivmodqi4_loop>
    a83e:	80 95       	com	r24
    a840:	08 95       	ret

0000a842 <__udivmodhi4>:
    a842:	aa 1b       	sub	r26, r26
    a844:	bb 1b       	sub	r27, r27
    a846:	51 e1       	ldi	r21, 0x11	; 17
    a848:	07 c0       	rjmp	.+14     	; 0xa858 <__udivmodhi4_ep>

0000a84a <__udivmodhi4_loop>:
    a84a:	aa 1f       	adc	r26, r26
    a84c:	bb 1f       	adc	r27, r27
    a84e:	a6 17       	cp	r26, r22
    a850:	b7 07       	cpc	r27, r23
    a852:	10 f0       	brcs	.+4      	; 0xa858 <__udivmodhi4_ep>
    a854:	a6 1b       	sub	r26, r22
    a856:	b7 0b       	sbc	r27, r23

0000a858 <__udivmodhi4_ep>:
    a858:	88 1f       	adc	r24, r24
    a85a:	99 1f       	adc	r25, r25
    a85c:	5a 95       	dec	r21
    a85e:	a9 f7       	brne	.-22     	; 0xa84a <__udivmodhi4_loop>
    a860:	80 95       	com	r24
    a862:	90 95       	com	r25
    a864:	bc 01       	movw	r22, r24
    a866:	cd 01       	movw	r24, r26
    a868:	08 95       	ret

0000a86a <malloc>:
    a86a:	cf 93       	push	r28
    a86c:	df 93       	push	r29
    a86e:	ac 01       	movw	r20, r24
    a870:	82 30       	cpi	r24, 0x02	; 2
    a872:	91 05       	cpc	r25, r1
    a874:	10 f4       	brcc	.+4      	; 0xa87a <malloc+0x10>
    a876:	42 e0       	ldi	r20, 0x02	; 2
    a878:	50 e0       	ldi	r21, 0x00	; 0
    a87a:	e0 91 3a 33 	lds	r30, 0x333A
    a87e:	f0 91 3b 33 	lds	r31, 0x333B
    a882:	20 e0       	ldi	r18, 0x00	; 0
    a884:	30 e0       	ldi	r19, 0x00	; 0
    a886:	a0 e0       	ldi	r26, 0x00	; 0
    a888:	b0 e0       	ldi	r27, 0x00	; 0
    a88a:	24 c0       	rjmp	.+72     	; 0xa8d4 <malloc+0x6a>
    a88c:	80 81       	ld	r24, Z
    a88e:	91 81       	ldd	r25, Z+1	; 0x01
    a890:	84 17       	cp	r24, r20
    a892:	95 07       	cpc	r25, r21
    a894:	d0 f0       	brcs	.+52     	; 0xa8ca <malloc+0x60>
    a896:	84 17       	cp	r24, r20
    a898:	95 07       	cpc	r25, r21
    a89a:	71 f4       	brne	.+28     	; 0xa8b8 <malloc+0x4e>
    a89c:	82 81       	ldd	r24, Z+2	; 0x02
    a89e:	93 81       	ldd	r25, Z+3	; 0x03
    a8a0:	10 97       	sbiw	r26, 0x00	; 0
    a8a2:	29 f0       	breq	.+10     	; 0xa8ae <malloc+0x44>
    a8a4:	12 96       	adiw	r26, 0x02	; 2
    a8a6:	8d 93       	st	X+, r24
    a8a8:	9c 93       	st	X, r25
    a8aa:	13 97       	sbiw	r26, 0x03	; 3
    a8ac:	2c c0       	rjmp	.+88     	; 0xa906 <malloc+0x9c>
    a8ae:	80 93 3a 33 	sts	0x333A, r24
    a8b2:	90 93 3b 33 	sts	0x333B, r25
    a8b6:	27 c0       	rjmp	.+78     	; 0xa906 <malloc+0x9c>
    a8b8:	21 15       	cp	r18, r1
    a8ba:	31 05       	cpc	r19, r1
    a8bc:	19 f0       	breq	.+6      	; 0xa8c4 <malloc+0x5a>
    a8be:	82 17       	cp	r24, r18
    a8c0:	93 07       	cpc	r25, r19
    a8c2:	18 f4       	brcc	.+6      	; 0xa8ca <malloc+0x60>
    a8c4:	9c 01       	movw	r18, r24
    a8c6:	bd 01       	movw	r22, r26
    a8c8:	ef 01       	movw	r28, r30
    a8ca:	92 81       	ldd	r25, Z+2	; 0x02
    a8cc:	83 81       	ldd	r24, Z+3	; 0x03
    a8ce:	df 01       	movw	r26, r30
    a8d0:	e9 2f       	mov	r30, r25
    a8d2:	f8 2f       	mov	r31, r24
    a8d4:	30 97       	sbiw	r30, 0x00	; 0
    a8d6:	d1 f6       	brne	.-76     	; 0xa88c <malloc+0x22>
    a8d8:	21 15       	cp	r18, r1
    a8da:	31 05       	cpc	r19, r1
    a8dc:	f9 f0       	breq	.+62     	; 0xa91c <malloc+0xb2>
    a8de:	c9 01       	movw	r24, r18
    a8e0:	84 1b       	sub	r24, r20
    a8e2:	95 0b       	sbc	r25, r21
    a8e4:	84 30       	cpi	r24, 0x04	; 4
    a8e6:	91 05       	cpc	r25, r1
    a8e8:	80 f4       	brcc	.+32     	; 0xa90a <malloc+0xa0>
    a8ea:	8a 81       	ldd	r24, Y+2	; 0x02
    a8ec:	9b 81       	ldd	r25, Y+3	; 0x03
    a8ee:	61 15       	cp	r22, r1
    a8f0:	71 05       	cpc	r23, r1
    a8f2:	21 f0       	breq	.+8      	; 0xa8fc <malloc+0x92>
    a8f4:	fb 01       	movw	r30, r22
    a8f6:	82 83       	std	Z+2, r24	; 0x02
    a8f8:	93 83       	std	Z+3, r25	; 0x03
    a8fa:	04 c0       	rjmp	.+8      	; 0xa904 <malloc+0x9a>
    a8fc:	80 93 3a 33 	sts	0x333A, r24
    a900:	90 93 3b 33 	sts	0x333B, r25
    a904:	fe 01       	movw	r30, r28
    a906:	32 96       	adiw	r30, 0x02	; 2
    a908:	42 c0       	rjmp	.+132    	; 0xa98e <malloc+0x124>
    a90a:	fe 01       	movw	r30, r28
    a90c:	e8 0f       	add	r30, r24
    a90e:	f9 1f       	adc	r31, r25
    a910:	41 93       	st	Z+, r20
    a912:	51 93       	st	Z+, r21
    a914:	02 97       	sbiw	r24, 0x02	; 2
    a916:	88 83       	st	Y, r24
    a918:	99 83       	std	Y+1, r25	; 0x01
    a91a:	39 c0       	rjmp	.+114    	; 0xa98e <malloc+0x124>
    a91c:	80 91 38 33 	lds	r24, 0x3338
    a920:	90 91 39 33 	lds	r25, 0x3339
    a924:	00 97       	sbiw	r24, 0x00	; 0
    a926:	41 f4       	brne	.+16     	; 0xa938 <malloc+0xce>
    a928:	80 91 46 25 	lds	r24, 0x2546
    a92c:	90 91 47 25 	lds	r25, 0x2547
    a930:	80 93 38 33 	sts	0x3338, r24
    a934:	90 93 39 33 	sts	0x3339, r25
    a938:	20 91 44 25 	lds	r18, 0x2544
    a93c:	30 91 45 25 	lds	r19, 0x2545
    a940:	21 15       	cp	r18, r1
    a942:	31 05       	cpc	r19, r1
    a944:	41 f4       	brne	.+16     	; 0xa956 <malloc+0xec>
    a946:	2d b7       	in	r18, 0x3d	; 61
    a948:	3e b7       	in	r19, 0x3e	; 62
    a94a:	80 91 48 25 	lds	r24, 0x2548
    a94e:	90 91 49 25 	lds	r25, 0x2549
    a952:	28 1b       	sub	r18, r24
    a954:	39 0b       	sbc	r19, r25
    a956:	e0 91 38 33 	lds	r30, 0x3338
    a95a:	f0 91 39 33 	lds	r31, 0x3339
    a95e:	e2 17       	cp	r30, r18
    a960:	f3 07       	cpc	r31, r19
    a962:	98 f4       	brcc	.+38     	; 0xa98a <malloc+0x120>
    a964:	2e 1b       	sub	r18, r30
    a966:	3f 0b       	sbc	r19, r31
    a968:	24 17       	cp	r18, r20
    a96a:	35 07       	cpc	r19, r21
    a96c:	70 f0       	brcs	.+28     	; 0xa98a <malloc+0x120>
    a96e:	ca 01       	movw	r24, r20
    a970:	02 96       	adiw	r24, 0x02	; 2
    a972:	28 17       	cp	r18, r24
    a974:	39 07       	cpc	r19, r25
    a976:	48 f0       	brcs	.+18     	; 0xa98a <malloc+0x120>
    a978:	8e 0f       	add	r24, r30
    a97a:	9f 1f       	adc	r25, r31
    a97c:	80 93 38 33 	sts	0x3338, r24
    a980:	90 93 39 33 	sts	0x3339, r25
    a984:	41 93       	st	Z+, r20
    a986:	51 93       	st	Z+, r21
    a988:	02 c0       	rjmp	.+4      	; 0xa98e <malloc+0x124>
    a98a:	e0 e0       	ldi	r30, 0x00	; 0
    a98c:	f0 e0       	ldi	r31, 0x00	; 0
    a98e:	cf 01       	movw	r24, r30
    a990:	df 91       	pop	r29
    a992:	cf 91       	pop	r28
    a994:	08 95       	ret

0000a996 <free>:
    a996:	0f 93       	push	r16
    a998:	1f 93       	push	r17
    a99a:	cf 93       	push	r28
    a99c:	df 93       	push	r29
    a99e:	9c 01       	movw	r18, r24
    a9a0:	00 97       	sbiw	r24, 0x00	; 0
    a9a2:	09 f4       	brne	.+2      	; 0xa9a6 <free+0x10>
    a9a4:	8c c0       	rjmp	.+280    	; 0xaabe <free+0x128>
    a9a6:	dc 01       	movw	r26, r24
    a9a8:	12 97       	sbiw	r26, 0x02	; 2
    a9aa:	12 96       	adiw	r26, 0x02	; 2
    a9ac:	1d 92       	st	X+, r1
    a9ae:	1c 92       	st	X, r1
    a9b0:	13 97       	sbiw	r26, 0x03	; 3
    a9b2:	60 91 3a 33 	lds	r22, 0x333A
    a9b6:	70 91 3b 33 	lds	r23, 0x333B
    a9ba:	61 15       	cp	r22, r1
    a9bc:	71 05       	cpc	r23, r1
    a9be:	89 f4       	brne	.+34     	; 0xa9e2 <free+0x4c>
    a9c0:	8d 91       	ld	r24, X+
    a9c2:	9c 91       	ld	r25, X
    a9c4:	11 97       	sbiw	r26, 0x01	; 1
    a9c6:	82 0f       	add	r24, r18
    a9c8:	93 1f       	adc	r25, r19
    a9ca:	20 91 38 33 	lds	r18, 0x3338
    a9ce:	30 91 39 33 	lds	r19, 0x3339
    a9d2:	28 17       	cp	r18, r24
    a9d4:	39 07       	cpc	r19, r25
    a9d6:	69 f5       	brne	.+90     	; 0xaa32 <free+0x9c>
    a9d8:	a0 93 38 33 	sts	0x3338, r26
    a9dc:	b0 93 39 33 	sts	0x3339, r27
    a9e0:	6e c0       	rjmp	.+220    	; 0xaabe <free+0x128>
    a9e2:	fb 01       	movw	r30, r22
    a9e4:	40 e0       	ldi	r20, 0x00	; 0
    a9e6:	50 e0       	ldi	r21, 0x00	; 0
    a9e8:	01 c0       	rjmp	.+2      	; 0xa9ec <free+0x56>
    a9ea:	fc 01       	movw	r30, r24
    a9ec:	ea 17       	cp	r30, r26
    a9ee:	fb 07       	cpc	r31, r27
    a9f0:	30 f4       	brcc	.+12     	; 0xa9fe <free+0x68>
    a9f2:	82 81       	ldd	r24, Z+2	; 0x02
    a9f4:	93 81       	ldd	r25, Z+3	; 0x03
    a9f6:	af 01       	movw	r20, r30
    a9f8:	00 97       	sbiw	r24, 0x00	; 0
    a9fa:	b9 f7       	brne	.-18     	; 0xa9ea <free+0x54>
    a9fc:	1f c0       	rjmp	.+62     	; 0xaa3c <free+0xa6>
    a9fe:	e9 01       	movw	r28, r18
    aa00:	22 97       	sbiw	r28, 0x02	; 2
    aa02:	ea 83       	std	Y+2, r30	; 0x02
    aa04:	fb 83       	std	Y+3, r31	; 0x03
    aa06:	08 81       	ld	r16, Y
    aa08:	19 81       	ldd	r17, Y+1	; 0x01
    aa0a:	c9 01       	movw	r24, r18
    aa0c:	80 0f       	add	r24, r16
    aa0e:	91 1f       	adc	r25, r17
    aa10:	8e 17       	cp	r24, r30
    aa12:	9f 07       	cpc	r25, r31
    aa14:	59 f4       	brne	.+22     	; 0xaa2c <free+0x96>
    aa16:	80 81       	ld	r24, Z
    aa18:	91 81       	ldd	r25, Z+1	; 0x01
    aa1a:	80 0f       	add	r24, r16
    aa1c:	91 1f       	adc	r25, r17
    aa1e:	02 96       	adiw	r24, 0x02	; 2
    aa20:	88 83       	st	Y, r24
    aa22:	99 83       	std	Y+1, r25	; 0x01
    aa24:	82 81       	ldd	r24, Z+2	; 0x02
    aa26:	93 81       	ldd	r25, Z+3	; 0x03
    aa28:	8a 83       	std	Y+2, r24	; 0x02
    aa2a:	9b 83       	std	Y+3, r25	; 0x03
    aa2c:	41 15       	cp	r20, r1
    aa2e:	51 05       	cpc	r21, r1
    aa30:	29 f4       	brne	.+10     	; 0xaa3c <free+0xa6>
    aa32:	a0 93 3a 33 	sts	0x333A, r26
    aa36:	b0 93 3b 33 	sts	0x333B, r27
    aa3a:	41 c0       	rjmp	.+130    	; 0xaabe <free+0x128>
    aa3c:	fa 01       	movw	r30, r20
    aa3e:	a2 83       	std	Z+2, r26	; 0x02
    aa40:	b3 83       	std	Z+3, r27	; 0x03
    aa42:	c1 91       	ld	r28, Z+
    aa44:	d1 91       	ld	r29, Z+
    aa46:	ec 0f       	add	r30, r28
    aa48:	fd 1f       	adc	r31, r29
    aa4a:	ae 17       	cp	r26, r30
    aa4c:	bf 07       	cpc	r27, r31
    aa4e:	81 f4       	brne	.+32     	; 0xaa70 <free+0xda>
    aa50:	f9 01       	movw	r30, r18
    aa52:	92 91       	ld	r25, -Z
    aa54:	82 91       	ld	r24, -Z
    aa56:	8c 0f       	add	r24, r28
    aa58:	9d 1f       	adc	r25, r29
    aa5a:	02 96       	adiw	r24, 0x02	; 2
    aa5c:	da 01       	movw	r26, r20
    aa5e:	8d 93       	st	X+, r24
    aa60:	9c 93       	st	X, r25
    aa62:	11 97       	sbiw	r26, 0x01	; 1
    aa64:	82 81       	ldd	r24, Z+2	; 0x02
    aa66:	93 81       	ldd	r25, Z+3	; 0x03
    aa68:	12 96       	adiw	r26, 0x02	; 2
    aa6a:	8d 93       	st	X+, r24
    aa6c:	9c 93       	st	X, r25
    aa6e:	13 97       	sbiw	r26, 0x03	; 3
    aa70:	e0 e0       	ldi	r30, 0x00	; 0
    aa72:	f0 e0       	ldi	r31, 0x00	; 0
    aa74:	02 c0       	rjmp	.+4      	; 0xaa7a <free+0xe4>
    aa76:	fb 01       	movw	r30, r22
    aa78:	bc 01       	movw	r22, r24
    aa7a:	db 01       	movw	r26, r22
    aa7c:	12 96       	adiw	r26, 0x02	; 2
    aa7e:	8d 91       	ld	r24, X+
    aa80:	9c 91       	ld	r25, X
    aa82:	13 97       	sbiw	r26, 0x03	; 3
    aa84:	00 97       	sbiw	r24, 0x00	; 0
    aa86:	b9 f7       	brne	.-18     	; 0xaa76 <free+0xe0>
    aa88:	cb 01       	movw	r24, r22
    aa8a:	02 96       	adiw	r24, 0x02	; 2
    aa8c:	2d 91       	ld	r18, X+
    aa8e:	3c 91       	ld	r19, X
    aa90:	11 97       	sbiw	r26, 0x01	; 1
    aa92:	82 0f       	add	r24, r18
    aa94:	93 1f       	adc	r25, r19
    aa96:	20 91 38 33 	lds	r18, 0x3338
    aa9a:	30 91 39 33 	lds	r19, 0x3339
    aa9e:	28 17       	cp	r18, r24
    aaa0:	39 07       	cpc	r19, r25
    aaa2:	69 f4       	brne	.+26     	; 0xaabe <free+0x128>
    aaa4:	30 97       	sbiw	r30, 0x00	; 0
    aaa6:	29 f4       	brne	.+10     	; 0xaab2 <free+0x11c>
    aaa8:	10 92 3a 33 	sts	0x333A, r1
    aaac:	10 92 3b 33 	sts	0x333B, r1
    aab0:	02 c0       	rjmp	.+4      	; 0xaab6 <free+0x120>
    aab2:	12 82       	std	Z+2, r1	; 0x02
    aab4:	13 82       	std	Z+3, r1	; 0x03
    aab6:	60 93 38 33 	sts	0x3338, r22
    aaba:	70 93 39 33 	sts	0x3339, r23
    aabe:	df 91       	pop	r29
    aac0:	cf 91       	pop	r28
    aac2:	1f 91       	pop	r17
    aac4:	0f 91       	pop	r16
    aac6:	08 95       	ret

0000aac8 <strtol>:
    aac8:	2f 92       	push	r2
    aaca:	3f 92       	push	r3
    aacc:	4f 92       	push	r4
    aace:	5f 92       	push	r5
    aad0:	6f 92       	push	r6
    aad2:	7f 92       	push	r7
    aad4:	8f 92       	push	r8
    aad6:	9f 92       	push	r9
    aad8:	bf 92       	push	r11
    aada:	cf 92       	push	r12
    aadc:	df 92       	push	r13
    aade:	ef 92       	push	r14
    aae0:	ff 92       	push	r15
    aae2:	0f 93       	push	r16
    aae4:	1f 93       	push	r17
    aae6:	cf 93       	push	r28
    aae8:	df 93       	push	r29
    aaea:	3b 01       	movw	r6, r22
    aaec:	8a 01       	movw	r16, r20
    aaee:	61 15       	cp	r22, r1
    aaf0:	71 05       	cpc	r23, r1
    aaf2:	19 f0       	breq	.+6      	; 0xaafa <strtol+0x32>
    aaf4:	fb 01       	movw	r30, r22
    aaf6:	80 83       	st	Z, r24
    aaf8:	91 83       	std	Z+1, r25	; 0x01
    aafa:	01 15       	cp	r16, r1
    aafc:	11 05       	cpc	r17, r1
    aafe:	39 f0       	breq	.+14     	; 0xab0e <strtol+0x46>
    ab00:	98 01       	movw	r18, r16
    ab02:	22 50       	subi	r18, 0x02	; 2
    ab04:	30 40       	sbci	r19, 0x00	; 0
    ab06:	23 32       	cpi	r18, 0x23	; 35
    ab08:	31 05       	cpc	r19, r1
    ab0a:	08 f0       	brcs	.+2      	; 0xab0e <strtol+0x46>
    ab0c:	03 c1       	rjmp	.+518    	; 0xad14 <strtol+0x24c>
    ab0e:	6c 01       	movw	r12, r24
    ab10:	76 01       	movw	r14, r12
    ab12:	08 94       	sec
    ab14:	c1 1c       	adc	r12, r1
    ab16:	d1 1c       	adc	r13, r1
    ab18:	f7 01       	movw	r30, r14
    ab1a:	c0 81       	ld	r28, Z
    ab1c:	46 01       	movw	r8, r12
    ab1e:	8c 2f       	mov	r24, r28
    ab20:	90 e0       	ldi	r25, 0x00	; 0
    ab22:	0e 94 a1 56 	call	0xad42	; 0xad42 <isspace>
    ab26:	00 97       	sbiw	r24, 0x00	; 0
    ab28:	99 f7       	brne	.-26     	; 0xab10 <strtol+0x48>
    ab2a:	cd 32       	cpi	r28, 0x2D	; 45
    ab2c:	49 f4       	brne	.+18     	; 0xab40 <strtol+0x78>
    ab2e:	f7 01       	movw	r30, r14
    ab30:	c1 81       	ldd	r28, Z+1	; 0x01
    ab32:	b2 e0       	ldi	r27, 0x02	; 2
    ab34:	8b 2e       	mov	r8, r27
    ab36:	91 2c       	mov	r9, r1
    ab38:	8e 0c       	add	r8, r14
    ab3a:	9f 1c       	adc	r9, r15
    ab3c:	d1 e0       	ldi	r29, 0x01	; 1
    ab3e:	0a c0       	rjmp	.+20     	; 0xab54 <strtol+0x8c>
    ab40:	cb 32       	cpi	r28, 0x2B	; 43
    ab42:	39 f4       	brne	.+14     	; 0xab52 <strtol+0x8a>
    ab44:	f7 01       	movw	r30, r14
    ab46:	c1 81       	ldd	r28, Z+1	; 0x01
    ab48:	a2 e0       	ldi	r26, 0x02	; 2
    ab4a:	8a 2e       	mov	r8, r26
    ab4c:	91 2c       	mov	r9, r1
    ab4e:	8e 0c       	add	r8, r14
    ab50:	9f 1c       	adc	r9, r15
    ab52:	d0 e0       	ldi	r29, 0x00	; 0
    ab54:	01 15       	cp	r16, r1
    ab56:	11 05       	cpc	r17, r1
    ab58:	19 f0       	breq	.+6      	; 0xab60 <strtol+0x98>
    ab5a:	00 31       	cpi	r16, 0x10	; 16
    ab5c:	11 05       	cpc	r17, r1
    ab5e:	c1 f4       	brne	.+48     	; 0xab90 <strtol+0xc8>
    ab60:	c0 33       	cpi	r28, 0x30	; 48
    ab62:	81 f4       	brne	.+32     	; 0xab84 <strtol+0xbc>
    ab64:	f4 01       	movw	r30, r8
    ab66:	80 81       	ld	r24, Z
    ab68:	88 37       	cpi	r24, 0x78	; 120
    ab6a:	11 f0       	breq	.+4      	; 0xab70 <strtol+0xa8>
    ab6c:	88 35       	cpi	r24, 0x58	; 88
    ab6e:	51 f4       	brne	.+20     	; 0xab84 <strtol+0xbc>
    ab70:	f4 01       	movw	r30, r8
    ab72:	c1 81       	ldd	r28, Z+1	; 0x01
    ab74:	82 e0       	ldi	r24, 0x02	; 2
    ab76:	90 e0       	ldi	r25, 0x00	; 0
    ab78:	88 0e       	add	r8, r24
    ab7a:	99 1e       	adc	r9, r25
    ab7c:	d2 60       	ori	r29, 0x02	; 2
    ab7e:	00 e1       	ldi	r16, 0x10	; 16
    ab80:	10 e0       	ldi	r17, 0x00	; 0
    ab82:	06 c0       	rjmp	.+12     	; 0xab90 <strtol+0xc8>
    ab84:	01 15       	cp	r16, r1
    ab86:	11 05       	cpc	r17, r1
    ab88:	19 f4       	brne	.+6      	; 0xab90 <strtol+0xc8>
    ab8a:	c0 33       	cpi	r28, 0x30	; 48
    ab8c:	c1 f4       	brne	.+48     	; 0xabbe <strtol+0xf6>
    ab8e:	22 c0       	rjmp	.+68     	; 0xabd4 <strtol+0x10c>
    ab90:	08 30       	cpi	r16, 0x08	; 8
    ab92:	11 05       	cpc	r17, r1
    ab94:	f9 f0       	breq	.+62     	; 0xabd4 <strtol+0x10c>
    ab96:	09 30       	cpi	r16, 0x09	; 9
    ab98:	11 05       	cpc	r17, r1
    ab9a:	24 f4       	brge	.+8      	; 0xaba4 <strtol+0xdc>
    ab9c:	02 30       	cpi	r16, 0x02	; 2
    ab9e:	11 05       	cpc	r17, r1
    aba0:	09 f5       	brne	.+66     	; 0xabe4 <strtol+0x11c>
    aba2:	07 c0       	rjmp	.+14     	; 0xabb2 <strtol+0xea>
    aba4:	0a 30       	cpi	r16, 0x0A	; 10
    aba6:	11 05       	cpc	r17, r1
    aba8:	51 f0       	breq	.+20     	; 0xabbe <strtol+0xf6>
    abaa:	00 31       	cpi	r16, 0x10	; 16
    abac:	11 05       	cpc	r17, r1
    abae:	d1 f4       	brne	.+52     	; 0xabe4 <strtol+0x11c>
    abb0:	27 c0       	rjmp	.+78     	; 0xac00 <strtol+0x138>
    abb2:	c1 2c       	mov	r12, r1
    abb4:	d1 2c       	mov	r13, r1
    abb6:	e1 2c       	mov	r14, r1
    abb8:	70 e4       	ldi	r23, 0x40	; 64
    abba:	f7 2e       	mov	r15, r23
    abbc:	26 c0       	rjmp	.+76     	; 0xac0a <strtol+0x142>
    abbe:	0a e0       	ldi	r16, 0x0A	; 10
    abc0:	10 e0       	ldi	r17, 0x00	; 0
    abc2:	6c ec       	ldi	r22, 0xCC	; 204
    abc4:	c6 2e       	mov	r12, r22
    abc6:	6c ec       	ldi	r22, 0xCC	; 204
    abc8:	d6 2e       	mov	r13, r22
    abca:	6c ec       	ldi	r22, 0xCC	; 204
    abcc:	e6 2e       	mov	r14, r22
    abce:	6c e0       	ldi	r22, 0x0C	; 12
    abd0:	f6 2e       	mov	r15, r22
    abd2:	1b c0       	rjmp	.+54     	; 0xac0a <strtol+0x142>
    abd4:	08 e0       	ldi	r16, 0x08	; 8
    abd6:	10 e0       	ldi	r17, 0x00	; 0
    abd8:	c1 2c       	mov	r12, r1
    abda:	d1 2c       	mov	r13, r1
    abdc:	e1 2c       	mov	r14, r1
    abde:	50 e1       	ldi	r21, 0x10	; 16
    abe0:	f5 2e       	mov	r15, r21
    abe2:	13 c0       	rjmp	.+38     	; 0xac0a <strtol+0x142>
    abe4:	98 01       	movw	r18, r16
    abe6:	44 27       	eor	r20, r20
    abe8:	37 fd       	sbrc	r19, 7
    abea:	40 95       	com	r20
    abec:	54 2f       	mov	r21, r20
    abee:	60 e0       	ldi	r22, 0x00	; 0
    abf0:	70 e0       	ldi	r23, 0x00	; 0
    abf2:	80 e0       	ldi	r24, 0x00	; 0
    abf4:	90 e8       	ldi	r25, 0x80	; 128
    abf6:	0e 94 20 5b 	call	0xb640	; 0xb640 <__udivmodsi4>
    abfa:	69 01       	movw	r12, r18
    abfc:	7a 01       	movw	r14, r20
    abfe:	05 c0       	rjmp	.+10     	; 0xac0a <strtol+0x142>
    ac00:	c1 2c       	mov	r12, r1
    ac02:	d1 2c       	mov	r13, r1
    ac04:	e1 2c       	mov	r14, r1
    ac06:	48 e0       	ldi	r20, 0x08	; 8
    ac08:	f4 2e       	mov	r15, r20
    ac0a:	20 e0       	ldi	r18, 0x00	; 0
    ac0c:	40 e0       	ldi	r20, 0x00	; 0
    ac0e:	50 e0       	ldi	r21, 0x00	; 0
    ac10:	ba 01       	movw	r22, r20
    ac12:	18 01       	movw	r2, r16
    ac14:	44 24       	eor	r4, r4
    ac16:	37 fc       	sbrc	r3, 7
    ac18:	40 94       	com	r4
    ac1a:	54 2c       	mov	r5, r4
    ac1c:	30 ed       	ldi	r19, 0xD0	; 208
    ac1e:	b3 2e       	mov	r11, r19
    ac20:	bc 0e       	add	r11, r28
    ac22:	99 e0       	ldi	r25, 0x09	; 9
    ac24:	9b 15       	cp	r25, r11
    ac26:	70 f4       	brcc	.+28     	; 0xac44 <strtol+0x17c>
    ac28:	8c 2f       	mov	r24, r28
    ac2a:	81 54       	subi	r24, 0x41	; 65
    ac2c:	8a 31       	cpi	r24, 0x1A	; 26
    ac2e:	18 f4       	brcc	.+6      	; 0xac36 <strtol+0x16e>
    ac30:	99 ec       	ldi	r25, 0xC9	; 201
    ac32:	b9 2e       	mov	r11, r25
    ac34:	06 c0       	rjmp	.+12     	; 0xac42 <strtol+0x17a>
    ac36:	8c 2f       	mov	r24, r28
    ac38:	81 56       	subi	r24, 0x61	; 97
    ac3a:	8a 31       	cpi	r24, 0x1A	; 26
    ac3c:	50 f5       	brcc	.+84     	; 0xac92 <strtol+0x1ca>
    ac3e:	89 ea       	ldi	r24, 0xA9	; 169
    ac40:	b8 2e       	mov	r11, r24
    ac42:	bc 0e       	add	r11, r28
    ac44:	8b 2d       	mov	r24, r11
    ac46:	90 e0       	ldi	r25, 0x00	; 0
    ac48:	80 17       	cp	r24, r16
    ac4a:	91 07       	cpc	r25, r17
    ac4c:	14 f5       	brge	.+68     	; 0xac92 <strtol+0x1ca>
    ac4e:	27 fd       	sbrc	r18, 7
    ac50:	1c c0       	rjmp	.+56     	; 0xac8a <strtol+0x1c2>
    ac52:	c4 16       	cp	r12, r20
    ac54:	d5 06       	cpc	r13, r21
    ac56:	e6 06       	cpc	r14, r22
    ac58:	f7 06       	cpc	r15, r23
    ac5a:	a0 f0       	brcs	.+40     	; 0xac84 <strtol+0x1bc>
    ac5c:	cb 01       	movw	r24, r22
    ac5e:	ba 01       	movw	r22, r20
    ac60:	a2 01       	movw	r20, r4
    ac62:	91 01       	movw	r18, r2
    ac64:	0e 94 01 5b 	call	0xb602	; 0xb602 <__mulsi3>
    ac68:	ab 01       	movw	r20, r22
    ac6a:	bc 01       	movw	r22, r24
    ac6c:	4b 0d       	add	r20, r11
    ac6e:	51 1d       	adc	r21, r1
    ac70:	61 1d       	adc	r22, r1
    ac72:	71 1d       	adc	r23, r1
    ac74:	41 30       	cpi	r20, 0x01	; 1
    ac76:	e0 e0       	ldi	r30, 0x00	; 0
    ac78:	5e 07       	cpc	r21, r30
    ac7a:	e0 e0       	ldi	r30, 0x00	; 0
    ac7c:	6e 07       	cpc	r22, r30
    ac7e:	e0 e8       	ldi	r30, 0x80	; 128
    ac80:	7e 07       	cpc	r23, r30
    ac82:	10 f0       	brcs	.+4      	; 0xac88 <strtol+0x1c0>
    ac84:	2f ef       	ldi	r18, 0xFF	; 255
    ac86:	01 c0       	rjmp	.+2      	; 0xac8a <strtol+0x1c2>
    ac88:	21 e0       	ldi	r18, 0x01	; 1
    ac8a:	f4 01       	movw	r30, r8
    ac8c:	c1 91       	ld	r28, Z+
    ac8e:	4f 01       	movw	r8, r30
    ac90:	c5 cf       	rjmp	.-118    	; 0xac1c <strtol+0x154>
    ac92:	61 14       	cp	r6, r1
    ac94:	71 04       	cpc	r7, r1
    ac96:	89 f0       	breq	.+34     	; 0xacba <strtol+0x1f2>
    ac98:	22 23       	and	r18, r18
    ac9a:	39 f0       	breq	.+14     	; 0xacaa <strtol+0x1e2>
    ac9c:	08 94       	sec
    ac9e:	81 08       	sbc	r8, r1
    aca0:	91 08       	sbc	r9, r1
    aca2:	f3 01       	movw	r30, r6
    aca4:	80 82       	st	Z, r8
    aca6:	91 82       	std	Z+1, r9	; 0x01
    aca8:	08 c0       	rjmp	.+16     	; 0xacba <strtol+0x1f2>
    acaa:	d1 ff       	sbrs	r29, 1
    acac:	1a c0       	rjmp	.+52     	; 0xace2 <strtol+0x21a>
    acae:	c4 01       	movw	r24, r8
    acb0:	02 97       	sbiw	r24, 0x02	; 2
    acb2:	f3 01       	movw	r30, r6
    acb4:	80 83       	st	Z, r24
    acb6:	91 83       	std	Z+1, r25	; 0x01
    acb8:	14 c0       	rjmp	.+40     	; 0xace2 <strtol+0x21a>
    acba:	27 ff       	sbrs	r18, 7
    acbc:	12 c0       	rjmp	.+36     	; 0xace2 <strtol+0x21a>
    acbe:	d0 ff       	sbrs	r29, 0
    acc0:	05 c0       	rjmp	.+10     	; 0xaccc <strtol+0x204>
    acc2:	40 e0       	ldi	r20, 0x00	; 0
    acc4:	50 e0       	ldi	r21, 0x00	; 0
    acc6:	60 e0       	ldi	r22, 0x00	; 0
    acc8:	70 e8       	ldi	r23, 0x80	; 128
    acca:	04 c0       	rjmp	.+8      	; 0xacd4 <strtol+0x20c>
    accc:	4f ef       	ldi	r20, 0xFF	; 255
    acce:	5f ef       	ldi	r21, 0xFF	; 255
    acd0:	6f ef       	ldi	r22, 0xFF	; 255
    acd2:	7f e7       	ldi	r23, 0x7F	; 127
    acd4:	82 e2       	ldi	r24, 0x22	; 34
    acd6:	90 e0       	ldi	r25, 0x00	; 0
    acd8:	80 93 42 33 	sts	0x3342, r24
    acdc:	90 93 43 33 	sts	0x3343, r25
    ace0:	16 c0       	rjmp	.+44     	; 0xad0e <strtol+0x246>
    ace2:	d0 ff       	sbrs	r29, 0
    ace4:	08 c0       	rjmp	.+16     	; 0xacf6 <strtol+0x22e>
    ace6:	70 95       	com	r23
    ace8:	60 95       	com	r22
    acea:	50 95       	com	r21
    acec:	41 95       	neg	r20
    acee:	5f 4f       	sbci	r21, 0xFF	; 255
    acf0:	6f 4f       	sbci	r22, 0xFF	; 255
    acf2:	7f 4f       	sbci	r23, 0xFF	; 255
    acf4:	0c c0       	rjmp	.+24     	; 0xad0e <strtol+0x246>
    acf6:	77 ff       	sbrs	r23, 7
    acf8:	0a c0       	rjmp	.+20     	; 0xad0e <strtol+0x246>
    acfa:	82 e2       	ldi	r24, 0x22	; 34
    acfc:	90 e0       	ldi	r25, 0x00	; 0
    acfe:	80 93 42 33 	sts	0x3342, r24
    ad02:	90 93 43 33 	sts	0x3343, r25
    ad06:	4f ef       	ldi	r20, 0xFF	; 255
    ad08:	5f ef       	ldi	r21, 0xFF	; 255
    ad0a:	6f ef       	ldi	r22, 0xFF	; 255
    ad0c:	7f e7       	ldi	r23, 0x7F	; 127
    ad0e:	8a 01       	movw	r16, r20
    ad10:	9b 01       	movw	r18, r22
    ad12:	03 c0       	rjmp	.+6      	; 0xad1a <strtol+0x252>
    ad14:	00 e0       	ldi	r16, 0x00	; 0
    ad16:	10 e0       	ldi	r17, 0x00	; 0
    ad18:	98 01       	movw	r18, r16
    ad1a:	b8 01       	movw	r22, r16
    ad1c:	c9 01       	movw	r24, r18
    ad1e:	df 91       	pop	r29
    ad20:	cf 91       	pop	r28
    ad22:	1f 91       	pop	r17
    ad24:	0f 91       	pop	r16
    ad26:	ff 90       	pop	r15
    ad28:	ef 90       	pop	r14
    ad2a:	df 90       	pop	r13
    ad2c:	cf 90       	pop	r12
    ad2e:	bf 90       	pop	r11
    ad30:	9f 90       	pop	r9
    ad32:	8f 90       	pop	r8
    ad34:	7f 90       	pop	r7
    ad36:	6f 90       	pop	r6
    ad38:	5f 90       	pop	r5
    ad3a:	4f 90       	pop	r4
    ad3c:	3f 90       	pop	r3
    ad3e:	2f 90       	pop	r2
    ad40:	08 95       	ret

0000ad42 <isspace>:
    ad42:	91 11       	cpse	r25, r1
    ad44:	e7 c3       	rjmp	.+1998   	; 0xb514 <__ctype_isfalse>
    ad46:	80 32       	cpi	r24, 0x20	; 32
    ad48:	19 f0       	breq	.+6      	; 0xad50 <isspace+0xe>
    ad4a:	89 50       	subi	r24, 0x09	; 9
    ad4c:	85 50       	subi	r24, 0x05	; 5
    ad4e:	d0 f7       	brcc	.-12     	; 0xad44 <isspace+0x2>
    ad50:	08 95       	ret

0000ad52 <memcpy_P>:
    ad52:	fb 01       	movw	r30, r22
    ad54:	dc 01       	movw	r26, r24
    ad56:	02 c0       	rjmp	.+4      	; 0xad5c <memcpy_P+0xa>
    ad58:	05 90       	lpm	r0, Z+
    ad5a:	0d 92       	st	X+, r0
    ad5c:	41 50       	subi	r20, 0x01	; 1
    ad5e:	50 40       	sbci	r21, 0x00	; 0
    ad60:	d8 f7       	brcc	.-10     	; 0xad58 <memcpy_P+0x6>
    ad62:	08 95       	ret

0000ad64 <strncmp_P>:
    ad64:	fb 01       	movw	r30, r22
    ad66:	dc 01       	movw	r26, r24
    ad68:	41 50       	subi	r20, 0x01	; 1
    ad6a:	50 40       	sbci	r21, 0x00	; 0
    ad6c:	30 f0       	brcs	.+12     	; 0xad7a <strncmp_P+0x16>
    ad6e:	8d 91       	ld	r24, X+
    ad70:	05 90       	lpm	r0, Z+
    ad72:	80 19       	sub	r24, r0
    ad74:	19 f4       	brne	.+6      	; 0xad7c <strncmp_P+0x18>
    ad76:	00 20       	and	r0, r0
    ad78:	b9 f7       	brne	.-18     	; 0xad68 <strncmp_P+0x4>
    ad7a:	88 1b       	sub	r24, r24
    ad7c:	99 0b       	sbc	r25, r25
    ad7e:	08 95       	ret

0000ad80 <memcpy>:
    ad80:	fb 01       	movw	r30, r22
    ad82:	dc 01       	movw	r26, r24
    ad84:	02 c0       	rjmp	.+4      	; 0xad8a <memcpy+0xa>
    ad86:	01 90       	ld	r0, Z+
    ad88:	0d 92       	st	X+, r0
    ad8a:	41 50       	subi	r20, 0x01	; 1
    ad8c:	50 40       	sbci	r21, 0x00	; 0
    ad8e:	d8 f7       	brcc	.-10     	; 0xad86 <memcpy+0x6>
    ad90:	08 95       	ret

0000ad92 <memset>:
    ad92:	dc 01       	movw	r26, r24
    ad94:	01 c0       	rjmp	.+2      	; 0xad98 <memset+0x6>
    ad96:	6d 93       	st	X+, r22
    ad98:	41 50       	subi	r20, 0x01	; 1
    ad9a:	50 40       	sbci	r21, 0x00	; 0
    ad9c:	e0 f7       	brcc	.-8      	; 0xad96 <memset+0x4>
    ad9e:	08 95       	ret

0000ada0 <strcat>:
    ada0:	fb 01       	movw	r30, r22
    ada2:	dc 01       	movw	r26, r24
    ada4:	0d 90       	ld	r0, X+
    ada6:	00 20       	and	r0, r0
    ada8:	e9 f7       	brne	.-6      	; 0xada4 <strcat+0x4>
    adaa:	11 97       	sbiw	r26, 0x01	; 1
    adac:	01 90       	ld	r0, Z+
    adae:	0d 92       	st	X+, r0
    adb0:	00 20       	and	r0, r0
    adb2:	e1 f7       	brne	.-8      	; 0xadac <strcat+0xc>
    adb4:	08 95       	ret

0000adb6 <strcpy>:
    adb6:	fb 01       	movw	r30, r22
    adb8:	dc 01       	movw	r26, r24
    adba:	01 90       	ld	r0, Z+
    adbc:	0d 92       	st	X+, r0
    adbe:	00 20       	and	r0, r0
    adc0:	e1 f7       	brne	.-8      	; 0xadba <strcpy+0x4>
    adc2:	08 95       	ret

0000adc4 <strncmp>:
    adc4:	fb 01       	movw	r30, r22
    adc6:	dc 01       	movw	r26, r24
    adc8:	41 50       	subi	r20, 0x01	; 1
    adca:	50 40       	sbci	r21, 0x00	; 0
    adcc:	30 f0       	brcs	.+12     	; 0xadda <strncmp+0x16>
    adce:	8d 91       	ld	r24, X+
    add0:	01 90       	ld	r0, Z+
    add2:	80 19       	sub	r24, r0
    add4:	19 f4       	brne	.+6      	; 0xaddc <strncmp+0x18>
    add6:	00 20       	and	r0, r0
    add8:	b9 f7       	brne	.-18     	; 0xadc8 <strncmp+0x4>
    adda:	88 1b       	sub	r24, r24
    addc:	99 0b       	sbc	r25, r25
    adde:	08 95       	ret

0000ade0 <strncpy>:
    ade0:	fb 01       	movw	r30, r22
    ade2:	dc 01       	movw	r26, r24
    ade4:	41 50       	subi	r20, 0x01	; 1
    ade6:	50 40       	sbci	r21, 0x00	; 0
    ade8:	48 f0       	brcs	.+18     	; 0xadfc <strncpy+0x1c>
    adea:	01 90       	ld	r0, Z+
    adec:	0d 92       	st	X+, r0
    adee:	00 20       	and	r0, r0
    adf0:	c9 f7       	brne	.-14     	; 0xade4 <strncpy+0x4>
    adf2:	01 c0       	rjmp	.+2      	; 0xadf6 <strncpy+0x16>
    adf4:	1d 92       	st	X+, r1
    adf6:	41 50       	subi	r20, 0x01	; 1
    adf8:	50 40       	sbci	r21, 0x00	; 0
    adfa:	e0 f7       	brcc	.-8      	; 0xadf4 <strncpy+0x14>
    adfc:	08 95       	ret

0000adfe <fclose>:
    adfe:	fc 01       	movw	r30, r24
    ae00:	23 81       	ldd	r18, Z+3	; 0x03
    ae02:	27 ff       	sbrs	r18, 7
    ae04:	23 c0       	rjmp	.+70     	; 0xae4c <fclose+0x4e>
    ae06:	20 91 3c 33 	lds	r18, 0x333C
    ae0a:	30 91 3d 33 	lds	r19, 0x333D
    ae0e:	28 17       	cp	r18, r24
    ae10:	39 07       	cpc	r19, r25
    ae12:	21 f4       	brne	.+8      	; 0xae1c <fclose+0x1e>
    ae14:	10 92 3c 33 	sts	0x333C, r1
    ae18:	10 92 3d 33 	sts	0x333D, r1
    ae1c:	20 91 3e 33 	lds	r18, 0x333E
    ae20:	30 91 3f 33 	lds	r19, 0x333F
    ae24:	28 17       	cp	r18, r24
    ae26:	39 07       	cpc	r19, r25
    ae28:	21 f4       	brne	.+8      	; 0xae32 <fclose+0x34>
    ae2a:	10 92 3e 33 	sts	0x333E, r1
    ae2e:	10 92 3f 33 	sts	0x333F, r1
    ae32:	20 91 40 33 	lds	r18, 0x3340
    ae36:	30 91 41 33 	lds	r19, 0x3341
    ae3a:	28 17       	cp	r18, r24
    ae3c:	39 07       	cpc	r19, r25
    ae3e:	21 f4       	brne	.+8      	; 0xae48 <fclose+0x4a>
    ae40:	10 92 40 33 	sts	0x3340, r1
    ae44:	10 92 41 33 	sts	0x3341, r1
    ae48:	0e 94 cb 54 	call	0xa996	; 0xa996 <free>
    ae4c:	80 e0       	ldi	r24, 0x00	; 0
    ae4e:	90 e0       	ldi	r25, 0x00	; 0
    ae50:	08 95       	ret

0000ae52 <fgetc>:
    ae52:	cf 93       	push	r28
    ae54:	df 93       	push	r29
    ae56:	ec 01       	movw	r28, r24
    ae58:	2b 81       	ldd	r18, Y+3	; 0x03
    ae5a:	20 ff       	sbrs	r18, 0
    ae5c:	35 c0       	rjmp	.+106    	; 0xaec8 <fgetc+0x76>
    ae5e:	26 ff       	sbrs	r18, 6
    ae60:	09 c0       	rjmp	.+18     	; 0xae74 <fgetc+0x22>
    ae62:	2f 7b       	andi	r18, 0xBF	; 191
    ae64:	2b 83       	std	Y+3, r18	; 0x03
    ae66:	8e 81       	ldd	r24, Y+6	; 0x06
    ae68:	9f 81       	ldd	r25, Y+7	; 0x07
    ae6a:	01 96       	adiw	r24, 0x01	; 1
    ae6c:	8e 83       	std	Y+6, r24	; 0x06
    ae6e:	9f 83       	std	Y+7, r25	; 0x07
    ae70:	8a 81       	ldd	r24, Y+2	; 0x02
    ae72:	28 c0       	rjmp	.+80     	; 0xaec4 <fgetc+0x72>
    ae74:	22 ff       	sbrs	r18, 2
    ae76:	0f c0       	rjmp	.+30     	; 0xae96 <fgetc+0x44>
    ae78:	e8 81       	ld	r30, Y
    ae7a:	f9 81       	ldd	r31, Y+1	; 0x01
    ae7c:	80 81       	ld	r24, Z
    ae7e:	99 27       	eor	r25, r25
    ae80:	87 fd       	sbrc	r24, 7
    ae82:	90 95       	com	r25
    ae84:	00 97       	sbiw	r24, 0x00	; 0
    ae86:	19 f4       	brne	.+6      	; 0xae8e <fgetc+0x3c>
    ae88:	20 62       	ori	r18, 0x20	; 32
    ae8a:	2b 83       	std	Y+3, r18	; 0x03
    ae8c:	1d c0       	rjmp	.+58     	; 0xaec8 <fgetc+0x76>
    ae8e:	31 96       	adiw	r30, 0x01	; 1
    ae90:	e8 83       	st	Y, r30
    ae92:	f9 83       	std	Y+1, r31	; 0x01
    ae94:	11 c0       	rjmp	.+34     	; 0xaeb8 <fgetc+0x66>
    ae96:	ea 85       	ldd	r30, Y+10	; 0x0a
    ae98:	fb 85       	ldd	r31, Y+11	; 0x0b
    ae9a:	ce 01       	movw	r24, r28
    ae9c:	19 95       	eicall
    ae9e:	97 ff       	sbrs	r25, 7
    aea0:	0b c0       	rjmp	.+22     	; 0xaeb8 <fgetc+0x66>
    aea2:	2b 81       	ldd	r18, Y+3	; 0x03
    aea4:	3f ef       	ldi	r19, 0xFF	; 255
    aea6:	8f 3f       	cpi	r24, 0xFF	; 255
    aea8:	93 07       	cpc	r25, r19
    aeaa:	11 f4       	brne	.+4      	; 0xaeb0 <fgetc+0x5e>
    aeac:	80 e1       	ldi	r24, 0x10	; 16
    aeae:	01 c0       	rjmp	.+2      	; 0xaeb2 <fgetc+0x60>
    aeb0:	80 e2       	ldi	r24, 0x20	; 32
    aeb2:	82 2b       	or	r24, r18
    aeb4:	8b 83       	std	Y+3, r24	; 0x03
    aeb6:	08 c0       	rjmp	.+16     	; 0xaec8 <fgetc+0x76>
    aeb8:	2e 81       	ldd	r18, Y+6	; 0x06
    aeba:	3f 81       	ldd	r19, Y+7	; 0x07
    aebc:	2f 5f       	subi	r18, 0xFF	; 255
    aebe:	3f 4f       	sbci	r19, 0xFF	; 255
    aec0:	2e 83       	std	Y+6, r18	; 0x06
    aec2:	3f 83       	std	Y+7, r19	; 0x07
    aec4:	90 e0       	ldi	r25, 0x00	; 0
    aec6:	02 c0       	rjmp	.+4      	; 0xaecc <fgetc+0x7a>
    aec8:	8f ef       	ldi	r24, 0xFF	; 255
    aeca:	9f ef       	ldi	r25, 0xFF	; 255
    aecc:	df 91       	pop	r29
    aece:	cf 91       	pop	r28
    aed0:	08 95       	ret

0000aed2 <fprintf>:
    aed2:	cf 93       	push	r28
    aed4:	df 93       	push	r29
    aed6:	cd b7       	in	r28, 0x3d	; 61
    aed8:	de b7       	in	r29, 0x3e	; 62
    aeda:	ae 01       	movw	r20, r28
    aedc:	46 5f       	subi	r20, 0xF6	; 246
    aede:	5f 4f       	sbci	r21, 0xFF	; 255
    aee0:	8e 81       	ldd	r24, Y+6	; 0x06
    aee2:	9f 81       	ldd	r25, Y+7	; 0x07
    aee4:	68 85       	ldd	r22, Y+8	; 0x08
    aee6:	79 85       	ldd	r23, Y+9	; 0x09
    aee8:	0e 94 11 58 	call	0xb022	; 0xb022 <vfprintf>
    aeec:	df 91       	pop	r29
    aeee:	cf 91       	pop	r28
    aef0:	08 95       	ret

0000aef2 <fprintf_P>:
    aef2:	0f 93       	push	r16
    aef4:	1f 93       	push	r17
    aef6:	cf 93       	push	r28
    aef8:	df 93       	push	r29
    aefa:	cd b7       	in	r28, 0x3d	; 61
    aefc:	de b7       	in	r29, 0x3e	; 62
    aefe:	08 85       	ldd	r16, Y+8	; 0x08
    af00:	19 85       	ldd	r17, Y+9	; 0x09
    af02:	ae 01       	movw	r20, r28
    af04:	44 5f       	subi	r20, 0xF4	; 244
    af06:	5f 4f       	sbci	r21, 0xFF	; 255
    af08:	f8 01       	movw	r30, r16
    af0a:	83 81       	ldd	r24, Z+3	; 0x03
    af0c:	88 60       	ori	r24, 0x08	; 8
    af0e:	83 83       	std	Z+3, r24	; 0x03
    af10:	c8 01       	movw	r24, r16
    af12:	6a 85       	ldd	r22, Y+10	; 0x0a
    af14:	7b 85       	ldd	r23, Y+11	; 0x0b
    af16:	0e 94 11 58 	call	0xb022	; 0xb022 <vfprintf>
    af1a:	f8 01       	movw	r30, r16
    af1c:	23 81       	ldd	r18, Z+3	; 0x03
    af1e:	27 7f       	andi	r18, 0xF7	; 247
    af20:	23 83       	std	Z+3, r18	; 0x03
    af22:	df 91       	pop	r29
    af24:	cf 91       	pop	r28
    af26:	1f 91       	pop	r17
    af28:	0f 91       	pop	r16
    af2a:	08 95       	ret

0000af2c <fputc>:
    af2c:	0f 93       	push	r16
    af2e:	1f 93       	push	r17
    af30:	cf 93       	push	r28
    af32:	df 93       	push	r29
    af34:	8c 01       	movw	r16, r24
    af36:	eb 01       	movw	r28, r22
    af38:	8b 81       	ldd	r24, Y+3	; 0x03
    af3a:	81 ff       	sbrs	r24, 1
    af3c:	1b c0       	rjmp	.+54     	; 0xaf74 <fputc+0x48>
    af3e:	82 ff       	sbrs	r24, 2
    af40:	0d c0       	rjmp	.+26     	; 0xaf5c <fputc+0x30>
    af42:	2e 81       	ldd	r18, Y+6	; 0x06
    af44:	3f 81       	ldd	r19, Y+7	; 0x07
    af46:	8c 81       	ldd	r24, Y+4	; 0x04
    af48:	9d 81       	ldd	r25, Y+5	; 0x05
    af4a:	28 17       	cp	r18, r24
    af4c:	39 07       	cpc	r19, r25
    af4e:	64 f4       	brge	.+24     	; 0xaf68 <fputc+0x3c>
    af50:	e8 81       	ld	r30, Y
    af52:	f9 81       	ldd	r31, Y+1	; 0x01
    af54:	01 93       	st	Z+, r16
    af56:	e8 83       	st	Y, r30
    af58:	f9 83       	std	Y+1, r31	; 0x01
    af5a:	06 c0       	rjmp	.+12     	; 0xaf68 <fputc+0x3c>
    af5c:	e8 85       	ldd	r30, Y+8	; 0x08
    af5e:	f9 85       	ldd	r31, Y+9	; 0x09
    af60:	80 2f       	mov	r24, r16
    af62:	19 95       	eicall
    af64:	00 97       	sbiw	r24, 0x00	; 0
    af66:	31 f4       	brne	.+12     	; 0xaf74 <fputc+0x48>
    af68:	8e 81       	ldd	r24, Y+6	; 0x06
    af6a:	9f 81       	ldd	r25, Y+7	; 0x07
    af6c:	01 96       	adiw	r24, 0x01	; 1
    af6e:	8e 83       	std	Y+6, r24	; 0x06
    af70:	9f 83       	std	Y+7, r25	; 0x07
    af72:	02 c0       	rjmp	.+4      	; 0xaf78 <fputc+0x4c>
    af74:	0f ef       	ldi	r16, 0xFF	; 255
    af76:	1f ef       	ldi	r17, 0xFF	; 255
    af78:	c8 01       	movw	r24, r16
    af7a:	df 91       	pop	r29
    af7c:	cf 91       	pop	r28
    af7e:	1f 91       	pop	r17
    af80:	0f 91       	pop	r16
    af82:	08 95       	ret

0000af84 <fputs>:
    af84:	ef 92       	push	r14
    af86:	ff 92       	push	r15
    af88:	0f 93       	push	r16
    af8a:	1f 93       	push	r17
    af8c:	cf 93       	push	r28
    af8e:	df 93       	push	r29
    af90:	7c 01       	movw	r14, r24
    af92:	eb 01       	movw	r28, r22
    af94:	8b 81       	ldd	r24, Y+3	; 0x03
    af96:	81 ff       	sbrs	r24, 1
    af98:	11 c0       	rjmp	.+34     	; 0xafbc <fputs+0x38>
    af9a:	00 e0       	ldi	r16, 0x00	; 0
    af9c:	10 e0       	ldi	r17, 0x00	; 0
    af9e:	08 c0       	rjmp	.+16     	; 0xafb0 <fputs+0x2c>
    afa0:	e8 85       	ldd	r30, Y+8	; 0x08
    afa2:	f9 85       	ldd	r31, Y+9	; 0x09
    afa4:	be 01       	movw	r22, r28
    afa6:	19 95       	eicall
    afa8:	00 97       	sbiw	r24, 0x00	; 0
    afaa:	11 f0       	breq	.+4      	; 0xafb0 <fputs+0x2c>
    afac:	0f ef       	ldi	r16, 0xFF	; 255
    afae:	1f ef       	ldi	r17, 0xFF	; 255
    afb0:	f7 01       	movw	r30, r14
    afb2:	81 91       	ld	r24, Z+
    afb4:	7f 01       	movw	r14, r30
    afb6:	88 23       	and	r24, r24
    afb8:	99 f7       	brne	.-26     	; 0xafa0 <fputs+0x1c>
    afba:	02 c0       	rjmp	.+4      	; 0xafc0 <fputs+0x3c>
    afbc:	0f ef       	ldi	r16, 0xFF	; 255
    afbe:	1f ef       	ldi	r17, 0xFF	; 255
    afc0:	c8 01       	movw	r24, r16
    afc2:	df 91       	pop	r29
    afc4:	cf 91       	pop	r28
    afc6:	1f 91       	pop	r17
    afc8:	0f 91       	pop	r16
    afca:	ff 90       	pop	r15
    afcc:	ef 90       	pop	r14
    afce:	08 95       	ret

0000afd0 <sprintf>:
    afd0:	0f 93       	push	r16
    afd2:	1f 93       	push	r17
    afd4:	cf 93       	push	r28
    afd6:	df 93       	push	r29
    afd8:	cd b7       	in	r28, 0x3d	; 61
    afda:	de b7       	in	r29, 0x3e	; 62
    afdc:	2e 97       	sbiw	r28, 0x0e	; 14
    afde:	cd bf       	out	0x3d, r28	; 61
    afe0:	de bf       	out	0x3e, r29	; 62
    afe2:	0e 89       	ldd	r16, Y+22	; 0x16
    afe4:	1f 89       	ldd	r17, Y+23	; 0x17
    afe6:	86 e0       	ldi	r24, 0x06	; 6
    afe8:	8c 83       	std	Y+4, r24	; 0x04
    afea:	09 83       	std	Y+1, r16	; 0x01
    afec:	1a 83       	std	Y+2, r17	; 0x02
    afee:	8f ef       	ldi	r24, 0xFF	; 255
    aff0:	9f e7       	ldi	r25, 0x7F	; 127
    aff2:	8d 83       	std	Y+5, r24	; 0x05
    aff4:	9e 83       	std	Y+6, r25	; 0x06
    aff6:	ae 01       	movw	r20, r28
    aff8:	46 5e       	subi	r20, 0xE6	; 230
    affa:	5f 4f       	sbci	r21, 0xFF	; 255
    affc:	ce 01       	movw	r24, r28
    affe:	01 96       	adiw	r24, 0x01	; 1
    b000:	68 8d       	ldd	r22, Y+24	; 0x18
    b002:	79 8d       	ldd	r23, Y+25	; 0x19
    b004:	0e 94 11 58 	call	0xb022	; 0xb022 <vfprintf>
    b008:	ef 81       	ldd	r30, Y+7	; 0x07
    b00a:	f8 85       	ldd	r31, Y+8	; 0x08
    b00c:	e0 0f       	add	r30, r16
    b00e:	f1 1f       	adc	r31, r17
    b010:	10 82       	st	Z, r1
    b012:	2e 96       	adiw	r28, 0x0e	; 14
    b014:	cd bf       	out	0x3d, r28	; 61
    b016:	de bf       	out	0x3e, r29	; 62
    b018:	df 91       	pop	r29
    b01a:	cf 91       	pop	r28
    b01c:	1f 91       	pop	r17
    b01e:	0f 91       	pop	r16
    b020:	08 95       	ret

0000b022 <vfprintf>:
    b022:	2f 92       	push	r2
    b024:	3f 92       	push	r3
    b026:	4f 92       	push	r4
    b028:	5f 92       	push	r5
    b02a:	6f 92       	push	r6
    b02c:	7f 92       	push	r7
    b02e:	8f 92       	push	r8
    b030:	9f 92       	push	r9
    b032:	af 92       	push	r10
    b034:	bf 92       	push	r11
    b036:	cf 92       	push	r12
    b038:	df 92       	push	r13
    b03a:	ef 92       	push	r14
    b03c:	ff 92       	push	r15
    b03e:	0f 93       	push	r16
    b040:	1f 93       	push	r17
    b042:	cf 93       	push	r28
    b044:	df 93       	push	r29
    b046:	cd b7       	in	r28, 0x3d	; 61
    b048:	de b7       	in	r29, 0x3e	; 62
    b04a:	2d 97       	sbiw	r28, 0x0d	; 13
    b04c:	cd bf       	out	0x3d, r28	; 61
    b04e:	de bf       	out	0x3e, r29	; 62
    b050:	3c 01       	movw	r6, r24
    b052:	6c 87       	std	Y+12, r22	; 0x0c
    b054:	7d 87       	std	Y+13, r23	; 0x0d
    b056:	5a 01       	movw	r10, r20
    b058:	fc 01       	movw	r30, r24
    b05a:	16 82       	std	Z+6, r1	; 0x06
    b05c:	17 82       	std	Z+7, r1	; 0x07
    b05e:	83 81       	ldd	r24, Z+3	; 0x03
    b060:	81 ff       	sbrs	r24, 1
    b062:	c8 c1       	rjmp	.+912    	; 0xb3f4 <vfprintf+0x3d2>
    b064:	2e 01       	movw	r4, r28
    b066:	08 94       	sec
    b068:	41 1c       	adc	r4, r1
    b06a:	51 1c       	adc	r5, r1
    b06c:	f3 01       	movw	r30, r6
    b06e:	93 81       	ldd	r25, Z+3	; 0x03
    b070:	ec 85       	ldd	r30, Y+12	; 0x0c
    b072:	fd 85       	ldd	r31, Y+13	; 0x0d
    b074:	93 fd       	sbrc	r25, 3
    b076:	85 91       	lpm	r24, Z+
    b078:	93 ff       	sbrs	r25, 3
    b07a:	81 91       	ld	r24, Z+
    b07c:	ec 87       	std	Y+12, r30	; 0x0c
    b07e:	fd 87       	std	Y+13, r31	; 0x0d
    b080:	88 23       	and	r24, r24
    b082:	09 f4       	brne	.+2      	; 0xb086 <vfprintf+0x64>
    b084:	b3 c1       	rjmp	.+870    	; 0xb3ec <vfprintf+0x3ca>
    b086:	85 32       	cpi	r24, 0x25	; 37
    b088:	41 f4       	brne	.+16     	; 0xb09a <vfprintf+0x78>
    b08a:	93 fd       	sbrc	r25, 3
    b08c:	85 91       	lpm	r24, Z+
    b08e:	93 ff       	sbrs	r25, 3
    b090:	81 91       	ld	r24, Z+
    b092:	ec 87       	std	Y+12, r30	; 0x0c
    b094:	fd 87       	std	Y+13, r31	; 0x0d
    b096:	85 32       	cpi	r24, 0x25	; 37
    b098:	29 f4       	brne	.+10     	; 0xb0a4 <vfprintf+0x82>
    b09a:	90 e0       	ldi	r25, 0x00	; 0
    b09c:	b3 01       	movw	r22, r6
    b09e:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b0a2:	e4 cf       	rjmp	.-56     	; 0xb06c <vfprintf+0x4a>
    b0a4:	ff 24       	eor	r15, r15
    b0a6:	ee 24       	eor	r14, r14
    b0a8:	10 e0       	ldi	r17, 0x00	; 0
    b0aa:	10 32       	cpi	r17, 0x20	; 32
    b0ac:	b0 f4       	brcc	.+44     	; 0xb0da <vfprintf+0xb8>
    b0ae:	8b 32       	cpi	r24, 0x2B	; 43
    b0b0:	69 f0       	breq	.+26     	; 0xb0cc <vfprintf+0xaa>
    b0b2:	8c 32       	cpi	r24, 0x2C	; 44
    b0b4:	28 f4       	brcc	.+10     	; 0xb0c0 <vfprintf+0x9e>
    b0b6:	80 32       	cpi	r24, 0x20	; 32
    b0b8:	51 f0       	breq	.+20     	; 0xb0ce <vfprintf+0xac>
    b0ba:	83 32       	cpi	r24, 0x23	; 35
    b0bc:	71 f4       	brne	.+28     	; 0xb0da <vfprintf+0xb8>
    b0be:	0b c0       	rjmp	.+22     	; 0xb0d6 <vfprintf+0xb4>
    b0c0:	8d 32       	cpi	r24, 0x2D	; 45
    b0c2:	39 f0       	breq	.+14     	; 0xb0d2 <vfprintf+0xb0>
    b0c4:	80 33       	cpi	r24, 0x30	; 48
    b0c6:	49 f4       	brne	.+18     	; 0xb0da <vfprintf+0xb8>
    b0c8:	11 60       	ori	r17, 0x01	; 1
    b0ca:	2c c0       	rjmp	.+88     	; 0xb124 <vfprintf+0x102>
    b0cc:	12 60       	ori	r17, 0x02	; 2
    b0ce:	14 60       	ori	r17, 0x04	; 4
    b0d0:	29 c0       	rjmp	.+82     	; 0xb124 <vfprintf+0x102>
    b0d2:	18 60       	ori	r17, 0x08	; 8
    b0d4:	27 c0       	rjmp	.+78     	; 0xb124 <vfprintf+0x102>
    b0d6:	10 61       	ori	r17, 0x10	; 16
    b0d8:	25 c0       	rjmp	.+74     	; 0xb124 <vfprintf+0x102>
    b0da:	17 fd       	sbrc	r17, 7
    b0dc:	2e c0       	rjmp	.+92     	; 0xb13a <vfprintf+0x118>
    b0de:	28 2f       	mov	r18, r24
    b0e0:	20 53       	subi	r18, 0x30	; 48
    b0e2:	2a 30       	cpi	r18, 0x0A	; 10
    b0e4:	98 f4       	brcc	.+38     	; 0xb10c <vfprintf+0xea>
    b0e6:	16 ff       	sbrs	r17, 6
    b0e8:	08 c0       	rjmp	.+16     	; 0xb0fa <vfprintf+0xd8>
    b0ea:	8f 2d       	mov	r24, r15
    b0ec:	88 0f       	add	r24, r24
    b0ee:	f8 2e       	mov	r15, r24
    b0f0:	ff 0c       	add	r15, r15
    b0f2:	ff 0c       	add	r15, r15
    b0f4:	f8 0e       	add	r15, r24
    b0f6:	f2 0e       	add	r15, r18
    b0f8:	15 c0       	rjmp	.+42     	; 0xb124 <vfprintf+0x102>
    b0fa:	8e 2d       	mov	r24, r14
    b0fc:	88 0f       	add	r24, r24
    b0fe:	e8 2e       	mov	r14, r24
    b100:	ee 0c       	add	r14, r14
    b102:	ee 0c       	add	r14, r14
    b104:	e8 0e       	add	r14, r24
    b106:	e2 0e       	add	r14, r18
    b108:	10 62       	ori	r17, 0x20	; 32
    b10a:	0c c0       	rjmp	.+24     	; 0xb124 <vfprintf+0x102>
    b10c:	8e 32       	cpi	r24, 0x2E	; 46
    b10e:	21 f4       	brne	.+8      	; 0xb118 <vfprintf+0xf6>
    b110:	16 fd       	sbrc	r17, 6
    b112:	6c c1       	rjmp	.+728    	; 0xb3ec <vfprintf+0x3ca>
    b114:	10 64       	ori	r17, 0x40	; 64
    b116:	06 c0       	rjmp	.+12     	; 0xb124 <vfprintf+0x102>
    b118:	8c 36       	cpi	r24, 0x6C	; 108
    b11a:	11 f4       	brne	.+4      	; 0xb120 <vfprintf+0xfe>
    b11c:	10 68       	ori	r17, 0x80	; 128
    b11e:	02 c0       	rjmp	.+4      	; 0xb124 <vfprintf+0x102>
    b120:	88 36       	cpi	r24, 0x68	; 104
    b122:	59 f4       	brne	.+22     	; 0xb13a <vfprintf+0x118>
    b124:	ec 85       	ldd	r30, Y+12	; 0x0c
    b126:	fd 85       	ldd	r31, Y+13	; 0x0d
    b128:	93 fd       	sbrc	r25, 3
    b12a:	85 91       	lpm	r24, Z+
    b12c:	93 ff       	sbrs	r25, 3
    b12e:	81 91       	ld	r24, Z+
    b130:	ec 87       	std	Y+12, r30	; 0x0c
    b132:	fd 87       	std	Y+13, r31	; 0x0d
    b134:	88 23       	and	r24, r24
    b136:	09 f0       	breq	.+2      	; 0xb13a <vfprintf+0x118>
    b138:	b8 cf       	rjmp	.-144    	; 0xb0aa <vfprintf+0x88>
    b13a:	98 2f       	mov	r25, r24
    b13c:	95 54       	subi	r25, 0x45	; 69
    b13e:	93 30       	cpi	r25, 0x03	; 3
    b140:	18 f0       	brcs	.+6      	; 0xb148 <vfprintf+0x126>
    b142:	90 52       	subi	r25, 0x20	; 32
    b144:	93 30       	cpi	r25, 0x03	; 3
    b146:	38 f4       	brcc	.+14     	; 0xb156 <vfprintf+0x134>
    b148:	24 e0       	ldi	r18, 0x04	; 4
    b14a:	30 e0       	ldi	r19, 0x00	; 0
    b14c:	a2 0e       	add	r10, r18
    b14e:	b3 1e       	adc	r11, r19
    b150:	3f e3       	ldi	r19, 0x3F	; 63
    b152:	39 83       	std	Y+1, r19	; 0x01
    b154:	0f c0       	rjmp	.+30     	; 0xb174 <vfprintf+0x152>
    b156:	83 36       	cpi	r24, 0x63	; 99
    b158:	31 f0       	breq	.+12     	; 0xb166 <vfprintf+0x144>
    b15a:	83 37       	cpi	r24, 0x73	; 115
    b15c:	81 f0       	breq	.+32     	; 0xb17e <vfprintf+0x15c>
    b15e:	83 35       	cpi	r24, 0x53	; 83
    b160:	09 f0       	breq	.+2      	; 0xb164 <vfprintf+0x142>
    b162:	5a c0       	rjmp	.+180    	; 0xb218 <vfprintf+0x1f6>
    b164:	22 c0       	rjmp	.+68     	; 0xb1aa <vfprintf+0x188>
    b166:	f5 01       	movw	r30, r10
    b168:	80 81       	ld	r24, Z
    b16a:	89 83       	std	Y+1, r24	; 0x01
    b16c:	22 e0       	ldi	r18, 0x02	; 2
    b16e:	30 e0       	ldi	r19, 0x00	; 0
    b170:	a2 0e       	add	r10, r18
    b172:	b3 1e       	adc	r11, r19
    b174:	21 e0       	ldi	r18, 0x01	; 1
    b176:	c2 2e       	mov	r12, r18
    b178:	d1 2c       	mov	r13, r1
    b17a:	42 01       	movw	r8, r4
    b17c:	14 c0       	rjmp	.+40     	; 0xb1a6 <vfprintf+0x184>
    b17e:	92 e0       	ldi	r25, 0x02	; 2
    b180:	29 2e       	mov	r2, r25
    b182:	31 2c       	mov	r3, r1
    b184:	2a 0c       	add	r2, r10
    b186:	3b 1c       	adc	r3, r11
    b188:	f5 01       	movw	r30, r10
    b18a:	80 80       	ld	r8, Z
    b18c:	91 80       	ldd	r9, Z+1	; 0x01
    b18e:	16 ff       	sbrs	r17, 6
    b190:	03 c0       	rjmp	.+6      	; 0xb198 <vfprintf+0x176>
    b192:	6f 2d       	mov	r22, r15
    b194:	70 e0       	ldi	r23, 0x00	; 0
    b196:	02 c0       	rjmp	.+4      	; 0xb19c <vfprintf+0x17a>
    b198:	6f ef       	ldi	r22, 0xFF	; 255
    b19a:	7f ef       	ldi	r23, 0xFF	; 255
    b19c:	c4 01       	movw	r24, r8
    b19e:	0e 94 98 5a 	call	0xb530	; 0xb530 <strnlen>
    b1a2:	6c 01       	movw	r12, r24
    b1a4:	51 01       	movw	r10, r2
    b1a6:	1f 77       	andi	r17, 0x7F	; 127
    b1a8:	15 c0       	rjmp	.+42     	; 0xb1d4 <vfprintf+0x1b2>
    b1aa:	82 e0       	ldi	r24, 0x02	; 2
    b1ac:	28 2e       	mov	r2, r24
    b1ae:	31 2c       	mov	r3, r1
    b1b0:	2a 0c       	add	r2, r10
    b1b2:	3b 1c       	adc	r3, r11
    b1b4:	f5 01       	movw	r30, r10
    b1b6:	80 80       	ld	r8, Z
    b1b8:	91 80       	ldd	r9, Z+1	; 0x01
    b1ba:	16 ff       	sbrs	r17, 6
    b1bc:	03 c0       	rjmp	.+6      	; 0xb1c4 <vfprintf+0x1a2>
    b1be:	6f 2d       	mov	r22, r15
    b1c0:	70 e0       	ldi	r23, 0x00	; 0
    b1c2:	02 c0       	rjmp	.+4      	; 0xb1c8 <vfprintf+0x1a6>
    b1c4:	6f ef       	ldi	r22, 0xFF	; 255
    b1c6:	7f ef       	ldi	r23, 0xFF	; 255
    b1c8:	c4 01       	movw	r24, r8
    b1ca:	0e 94 8d 5a 	call	0xb51a	; 0xb51a <strnlen_P>
    b1ce:	6c 01       	movw	r12, r24
    b1d0:	10 68       	ori	r17, 0x80	; 128
    b1d2:	51 01       	movw	r10, r2
    b1d4:	13 fd       	sbrc	r17, 3
    b1d6:	1c c0       	rjmp	.+56     	; 0xb210 <vfprintf+0x1ee>
    b1d8:	06 c0       	rjmp	.+12     	; 0xb1e6 <vfprintf+0x1c4>
    b1da:	80 e2       	ldi	r24, 0x20	; 32
    b1dc:	90 e0       	ldi	r25, 0x00	; 0
    b1de:	b3 01       	movw	r22, r6
    b1e0:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b1e4:	ea 94       	dec	r14
    b1e6:	8e 2d       	mov	r24, r14
    b1e8:	90 e0       	ldi	r25, 0x00	; 0
    b1ea:	c8 16       	cp	r12, r24
    b1ec:	d9 06       	cpc	r13, r25
    b1ee:	a8 f3       	brcs	.-22     	; 0xb1da <vfprintf+0x1b8>
    b1f0:	0f c0       	rjmp	.+30     	; 0xb210 <vfprintf+0x1ee>
    b1f2:	f4 01       	movw	r30, r8
    b1f4:	17 fd       	sbrc	r17, 7
    b1f6:	85 91       	lpm	r24, Z+
    b1f8:	17 ff       	sbrs	r17, 7
    b1fa:	81 91       	ld	r24, Z+
    b1fc:	4f 01       	movw	r8, r30
    b1fe:	90 e0       	ldi	r25, 0x00	; 0
    b200:	b3 01       	movw	r22, r6
    b202:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b206:	e1 10       	cpse	r14, r1
    b208:	ea 94       	dec	r14
    b20a:	08 94       	sec
    b20c:	c1 08       	sbc	r12, r1
    b20e:	d1 08       	sbc	r13, r1
    b210:	c1 14       	cp	r12, r1
    b212:	d1 04       	cpc	r13, r1
    b214:	71 f7       	brne	.-36     	; 0xb1f2 <vfprintf+0x1d0>
    b216:	e7 c0       	rjmp	.+462    	; 0xb3e6 <vfprintf+0x3c4>
    b218:	84 36       	cpi	r24, 0x64	; 100
    b21a:	11 f0       	breq	.+4      	; 0xb220 <vfprintf+0x1fe>
    b21c:	89 36       	cpi	r24, 0x69	; 105
    b21e:	51 f5       	brne	.+84     	; 0xb274 <vfprintf+0x252>
    b220:	f5 01       	movw	r30, r10
    b222:	17 ff       	sbrs	r17, 7
    b224:	07 c0       	rjmp	.+14     	; 0xb234 <vfprintf+0x212>
    b226:	80 81       	ld	r24, Z
    b228:	91 81       	ldd	r25, Z+1	; 0x01
    b22a:	a2 81       	ldd	r26, Z+2	; 0x02
    b22c:	b3 81       	ldd	r27, Z+3	; 0x03
    b22e:	24 e0       	ldi	r18, 0x04	; 4
    b230:	30 e0       	ldi	r19, 0x00	; 0
    b232:	08 c0       	rjmp	.+16     	; 0xb244 <vfprintf+0x222>
    b234:	80 81       	ld	r24, Z
    b236:	91 81       	ldd	r25, Z+1	; 0x01
    b238:	aa 27       	eor	r26, r26
    b23a:	97 fd       	sbrc	r25, 7
    b23c:	a0 95       	com	r26
    b23e:	ba 2f       	mov	r27, r26
    b240:	22 e0       	ldi	r18, 0x02	; 2
    b242:	30 e0       	ldi	r19, 0x00	; 0
    b244:	a2 0e       	add	r10, r18
    b246:	b3 1e       	adc	r11, r19
    b248:	01 2f       	mov	r16, r17
    b24a:	0f 76       	andi	r16, 0x6F	; 111
    b24c:	b7 ff       	sbrs	r27, 7
    b24e:	08 c0       	rjmp	.+16     	; 0xb260 <vfprintf+0x23e>
    b250:	b0 95       	com	r27
    b252:	a0 95       	com	r26
    b254:	90 95       	com	r25
    b256:	81 95       	neg	r24
    b258:	9f 4f       	sbci	r25, 0xFF	; 255
    b25a:	af 4f       	sbci	r26, 0xFF	; 255
    b25c:	bf 4f       	sbci	r27, 0xFF	; 255
    b25e:	00 68       	ori	r16, 0x80	; 128
    b260:	bc 01       	movw	r22, r24
    b262:	cd 01       	movw	r24, r26
    b264:	a2 01       	movw	r20, r4
    b266:	2a e0       	ldi	r18, 0x0A	; 10
    b268:	30 e0       	ldi	r19, 0x00	; 0
    b26a:	0e 94 a3 5a 	call	0xb546	; 0xb546 <__ultoa_invert>
    b26e:	d8 2e       	mov	r13, r24
    b270:	d4 18       	sub	r13, r4
    b272:	3f c0       	rjmp	.+126    	; 0xb2f2 <vfprintf+0x2d0>
    b274:	85 37       	cpi	r24, 0x75	; 117
    b276:	21 f4       	brne	.+8      	; 0xb280 <vfprintf+0x25e>
    b278:	1f 7e       	andi	r17, 0xEF	; 239
    b27a:	2a e0       	ldi	r18, 0x0A	; 10
    b27c:	30 e0       	ldi	r19, 0x00	; 0
    b27e:	20 c0       	rjmp	.+64     	; 0xb2c0 <vfprintf+0x29e>
    b280:	19 7f       	andi	r17, 0xF9	; 249
    b282:	8f 36       	cpi	r24, 0x6F	; 111
    b284:	a9 f0       	breq	.+42     	; 0xb2b0 <vfprintf+0x28e>
    b286:	80 37       	cpi	r24, 0x70	; 112
    b288:	20 f4       	brcc	.+8      	; 0xb292 <vfprintf+0x270>
    b28a:	88 35       	cpi	r24, 0x58	; 88
    b28c:	09 f0       	breq	.+2      	; 0xb290 <vfprintf+0x26e>
    b28e:	ae c0       	rjmp	.+348    	; 0xb3ec <vfprintf+0x3ca>
    b290:	0b c0       	rjmp	.+22     	; 0xb2a8 <vfprintf+0x286>
    b292:	80 37       	cpi	r24, 0x70	; 112
    b294:	21 f0       	breq	.+8      	; 0xb29e <vfprintf+0x27c>
    b296:	88 37       	cpi	r24, 0x78	; 120
    b298:	09 f0       	breq	.+2      	; 0xb29c <vfprintf+0x27a>
    b29a:	a8 c0       	rjmp	.+336    	; 0xb3ec <vfprintf+0x3ca>
    b29c:	01 c0       	rjmp	.+2      	; 0xb2a0 <vfprintf+0x27e>
    b29e:	10 61       	ori	r17, 0x10	; 16
    b2a0:	14 ff       	sbrs	r17, 4
    b2a2:	09 c0       	rjmp	.+18     	; 0xb2b6 <vfprintf+0x294>
    b2a4:	14 60       	ori	r17, 0x04	; 4
    b2a6:	07 c0       	rjmp	.+14     	; 0xb2b6 <vfprintf+0x294>
    b2a8:	14 ff       	sbrs	r17, 4
    b2aa:	08 c0       	rjmp	.+16     	; 0xb2bc <vfprintf+0x29a>
    b2ac:	16 60       	ori	r17, 0x06	; 6
    b2ae:	06 c0       	rjmp	.+12     	; 0xb2bc <vfprintf+0x29a>
    b2b0:	28 e0       	ldi	r18, 0x08	; 8
    b2b2:	30 e0       	ldi	r19, 0x00	; 0
    b2b4:	05 c0       	rjmp	.+10     	; 0xb2c0 <vfprintf+0x29e>
    b2b6:	20 e1       	ldi	r18, 0x10	; 16
    b2b8:	30 e0       	ldi	r19, 0x00	; 0
    b2ba:	02 c0       	rjmp	.+4      	; 0xb2c0 <vfprintf+0x29e>
    b2bc:	20 e1       	ldi	r18, 0x10	; 16
    b2be:	32 e0       	ldi	r19, 0x02	; 2
    b2c0:	f5 01       	movw	r30, r10
    b2c2:	17 ff       	sbrs	r17, 7
    b2c4:	07 c0       	rjmp	.+14     	; 0xb2d4 <vfprintf+0x2b2>
    b2c6:	60 81       	ld	r22, Z
    b2c8:	71 81       	ldd	r23, Z+1	; 0x01
    b2ca:	82 81       	ldd	r24, Z+2	; 0x02
    b2cc:	93 81       	ldd	r25, Z+3	; 0x03
    b2ce:	44 e0       	ldi	r20, 0x04	; 4
    b2d0:	50 e0       	ldi	r21, 0x00	; 0
    b2d2:	06 c0       	rjmp	.+12     	; 0xb2e0 <vfprintf+0x2be>
    b2d4:	60 81       	ld	r22, Z
    b2d6:	71 81       	ldd	r23, Z+1	; 0x01
    b2d8:	80 e0       	ldi	r24, 0x00	; 0
    b2da:	90 e0       	ldi	r25, 0x00	; 0
    b2dc:	42 e0       	ldi	r20, 0x02	; 2
    b2de:	50 e0       	ldi	r21, 0x00	; 0
    b2e0:	a4 0e       	add	r10, r20
    b2e2:	b5 1e       	adc	r11, r21
    b2e4:	a2 01       	movw	r20, r4
    b2e6:	0e 94 a3 5a 	call	0xb546	; 0xb546 <__ultoa_invert>
    b2ea:	d8 2e       	mov	r13, r24
    b2ec:	d4 18       	sub	r13, r4
    b2ee:	01 2f       	mov	r16, r17
    b2f0:	0f 77       	andi	r16, 0x7F	; 127
    b2f2:	06 ff       	sbrs	r16, 6
    b2f4:	09 c0       	rjmp	.+18     	; 0xb308 <vfprintf+0x2e6>
    b2f6:	0e 7f       	andi	r16, 0xFE	; 254
    b2f8:	df 14       	cp	r13, r15
    b2fa:	30 f4       	brcc	.+12     	; 0xb308 <vfprintf+0x2e6>
    b2fc:	04 ff       	sbrs	r16, 4
    b2fe:	06 c0       	rjmp	.+12     	; 0xb30c <vfprintf+0x2ea>
    b300:	02 fd       	sbrc	r16, 2
    b302:	04 c0       	rjmp	.+8      	; 0xb30c <vfprintf+0x2ea>
    b304:	0f 7e       	andi	r16, 0xEF	; 239
    b306:	02 c0       	rjmp	.+4      	; 0xb30c <vfprintf+0x2ea>
    b308:	1d 2d       	mov	r17, r13
    b30a:	01 c0       	rjmp	.+2      	; 0xb30e <vfprintf+0x2ec>
    b30c:	1f 2d       	mov	r17, r15
    b30e:	80 2f       	mov	r24, r16
    b310:	90 e0       	ldi	r25, 0x00	; 0
    b312:	04 ff       	sbrs	r16, 4
    b314:	0c c0       	rjmp	.+24     	; 0xb32e <vfprintf+0x30c>
    b316:	fe 01       	movw	r30, r28
    b318:	ed 0d       	add	r30, r13
    b31a:	f1 1d       	adc	r31, r1
    b31c:	20 81       	ld	r18, Z
    b31e:	20 33       	cpi	r18, 0x30	; 48
    b320:	11 f4       	brne	.+4      	; 0xb326 <vfprintf+0x304>
    b322:	09 7e       	andi	r16, 0xE9	; 233
    b324:	09 c0       	rjmp	.+18     	; 0xb338 <vfprintf+0x316>
    b326:	02 ff       	sbrs	r16, 2
    b328:	06 c0       	rjmp	.+12     	; 0xb336 <vfprintf+0x314>
    b32a:	1e 5f       	subi	r17, 0xFE	; 254
    b32c:	05 c0       	rjmp	.+10     	; 0xb338 <vfprintf+0x316>
    b32e:	86 78       	andi	r24, 0x86	; 134
    b330:	90 70       	andi	r25, 0x00	; 0
    b332:	00 97       	sbiw	r24, 0x00	; 0
    b334:	09 f0       	breq	.+2      	; 0xb338 <vfprintf+0x316>
    b336:	1f 5f       	subi	r17, 0xFF	; 255
    b338:	80 2e       	mov	r8, r16
    b33a:	99 24       	eor	r9, r9
    b33c:	03 fd       	sbrc	r16, 3
    b33e:	12 c0       	rjmp	.+36     	; 0xb364 <vfprintf+0x342>
    b340:	00 ff       	sbrs	r16, 0
    b342:	0d c0       	rjmp	.+26     	; 0xb35e <vfprintf+0x33c>
    b344:	fd 2c       	mov	r15, r13
    b346:	1e 15       	cp	r17, r14
    b348:	50 f4       	brcc	.+20     	; 0xb35e <vfprintf+0x33c>
    b34a:	fe 0c       	add	r15, r14
    b34c:	f1 1a       	sub	r15, r17
    b34e:	1e 2d       	mov	r17, r14
    b350:	06 c0       	rjmp	.+12     	; 0xb35e <vfprintf+0x33c>
    b352:	80 e2       	ldi	r24, 0x20	; 32
    b354:	90 e0       	ldi	r25, 0x00	; 0
    b356:	b3 01       	movw	r22, r6
    b358:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b35c:	1f 5f       	subi	r17, 0xFF	; 255
    b35e:	1e 15       	cp	r17, r14
    b360:	c0 f3       	brcs	.-16     	; 0xb352 <vfprintf+0x330>
    b362:	04 c0       	rjmp	.+8      	; 0xb36c <vfprintf+0x34a>
    b364:	1e 15       	cp	r17, r14
    b366:	10 f4       	brcc	.+4      	; 0xb36c <vfprintf+0x34a>
    b368:	e1 1a       	sub	r14, r17
    b36a:	01 c0       	rjmp	.+2      	; 0xb36e <vfprintf+0x34c>
    b36c:	ee 24       	eor	r14, r14
    b36e:	84 fe       	sbrs	r8, 4
    b370:	0f c0       	rjmp	.+30     	; 0xb390 <vfprintf+0x36e>
    b372:	80 e3       	ldi	r24, 0x30	; 48
    b374:	90 e0       	ldi	r25, 0x00	; 0
    b376:	b3 01       	movw	r22, r6
    b378:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b37c:	82 fe       	sbrs	r8, 2
    b37e:	1f c0       	rjmp	.+62     	; 0xb3be <vfprintf+0x39c>
    b380:	81 fe       	sbrs	r8, 1
    b382:	03 c0       	rjmp	.+6      	; 0xb38a <vfprintf+0x368>
    b384:	88 e5       	ldi	r24, 0x58	; 88
    b386:	90 e0       	ldi	r25, 0x00	; 0
    b388:	10 c0       	rjmp	.+32     	; 0xb3aa <vfprintf+0x388>
    b38a:	88 e7       	ldi	r24, 0x78	; 120
    b38c:	90 e0       	ldi	r25, 0x00	; 0
    b38e:	0d c0       	rjmp	.+26     	; 0xb3aa <vfprintf+0x388>
    b390:	c4 01       	movw	r24, r8
    b392:	86 78       	andi	r24, 0x86	; 134
    b394:	90 70       	andi	r25, 0x00	; 0
    b396:	00 97       	sbiw	r24, 0x00	; 0
    b398:	91 f0       	breq	.+36     	; 0xb3be <vfprintf+0x39c>
    b39a:	81 fc       	sbrc	r8, 1
    b39c:	02 c0       	rjmp	.+4      	; 0xb3a2 <vfprintf+0x380>
    b39e:	80 e2       	ldi	r24, 0x20	; 32
    b3a0:	01 c0       	rjmp	.+2      	; 0xb3a4 <vfprintf+0x382>
    b3a2:	8b e2       	ldi	r24, 0x2B	; 43
    b3a4:	07 fd       	sbrc	r16, 7
    b3a6:	8d e2       	ldi	r24, 0x2D	; 45
    b3a8:	90 e0       	ldi	r25, 0x00	; 0
    b3aa:	b3 01       	movw	r22, r6
    b3ac:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b3b0:	06 c0       	rjmp	.+12     	; 0xb3be <vfprintf+0x39c>
    b3b2:	80 e3       	ldi	r24, 0x30	; 48
    b3b4:	90 e0       	ldi	r25, 0x00	; 0
    b3b6:	b3 01       	movw	r22, r6
    b3b8:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b3bc:	fa 94       	dec	r15
    b3be:	df 14       	cp	r13, r15
    b3c0:	c0 f3       	brcs	.-16     	; 0xb3b2 <vfprintf+0x390>
    b3c2:	da 94       	dec	r13
    b3c4:	f2 01       	movw	r30, r4
    b3c6:	ed 0d       	add	r30, r13
    b3c8:	f1 1d       	adc	r31, r1
    b3ca:	80 81       	ld	r24, Z
    b3cc:	90 e0       	ldi	r25, 0x00	; 0
    b3ce:	b3 01       	movw	r22, r6
    b3d0:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b3d4:	dd 20       	and	r13, r13
    b3d6:	a9 f7       	brne	.-22     	; 0xb3c2 <vfprintf+0x3a0>
    b3d8:	06 c0       	rjmp	.+12     	; 0xb3e6 <vfprintf+0x3c4>
    b3da:	80 e2       	ldi	r24, 0x20	; 32
    b3dc:	90 e0       	ldi	r25, 0x00	; 0
    b3de:	b3 01       	movw	r22, r6
    b3e0:	0e 94 96 57 	call	0xaf2c	; 0xaf2c <fputc>
    b3e4:	ea 94       	dec	r14
    b3e6:	ee 20       	and	r14, r14
    b3e8:	c1 f7       	brne	.-16     	; 0xb3da <vfprintf+0x3b8>
    b3ea:	40 ce       	rjmp	.-896    	; 0xb06c <vfprintf+0x4a>
    b3ec:	f3 01       	movw	r30, r6
    b3ee:	86 81       	ldd	r24, Z+6	; 0x06
    b3f0:	97 81       	ldd	r25, Z+7	; 0x07
    b3f2:	02 c0       	rjmp	.+4      	; 0xb3f8 <vfprintf+0x3d6>
    b3f4:	8f ef       	ldi	r24, 0xFF	; 255
    b3f6:	9f ef       	ldi	r25, 0xFF	; 255
    b3f8:	2d 96       	adiw	r28, 0x0d	; 13
    b3fa:	cd bf       	out	0x3d, r28	; 61
    b3fc:	de bf       	out	0x3e, r29	; 62
    b3fe:	df 91       	pop	r29
    b400:	cf 91       	pop	r28
    b402:	1f 91       	pop	r17
    b404:	0f 91       	pop	r16
    b406:	ff 90       	pop	r15
    b408:	ef 90       	pop	r14
    b40a:	df 90       	pop	r13
    b40c:	cf 90       	pop	r12
    b40e:	bf 90       	pop	r11
    b410:	af 90       	pop	r10
    b412:	9f 90       	pop	r9
    b414:	8f 90       	pop	r8
    b416:	7f 90       	pop	r7
    b418:	6f 90       	pop	r6
    b41a:	5f 90       	pop	r5
    b41c:	4f 90       	pop	r4
    b41e:	3f 90       	pop	r3
    b420:	2f 90       	pop	r2
    b422:	08 95       	ret

0000b424 <__eerd_block_x128a1>:
    b424:	e0 ec       	ldi	r30, 0xC0	; 192
    b426:	f1 e0       	ldi	r31, 0x01	; 1
    b428:	a7 85       	ldd	r26, Z+15	; 0x0f
    b42a:	a7 fd       	sbrc	r26, 7
    b42c:	fd cf       	rjmp	.-6      	; 0xb428 <__eerd_block_x128a1+0x4>
    b42e:	a4 85       	ldd	r26, Z+12	; 0x0c
    b430:	a8 60       	ori	r26, 0x08	; 8
    b432:	a4 87       	std	Z+12, r26	; 0x0c
    b434:	60 50       	subi	r22, 0x00	; 0
    b436:	70 4f       	sbci	r23, 0xF0	; 240
    b438:	0c 94 c0 56 	jmp	0xad80	; 0xad80 <memcpy>

0000b43c <__eerd_dword_x128a1>:
    b43c:	0e 94 7e 5a 	call	0xb4fc	; 0xb4fc <eeprom_mapen>
    b440:	60 81       	ld	r22, Z
    b442:	71 81       	ldd	r23, Z+1	; 0x01
    b444:	82 81       	ldd	r24, Z+2	; 0x02
    b446:	93 81       	ldd	r25, Z+3	; 0x03
    b448:	08 95       	ret

0000b44a <__eerd_word_x128a1>:
    b44a:	0e 94 7e 5a 	call	0xb4fc	; 0xb4fc <eeprom_mapen>
    b44e:	80 81       	ld	r24, Z
    b450:	91 81       	ldd	r25, Z+1	; 0x01
    b452:	08 95       	ret

0000b454 <__eeupd_block_x128a1>:
    b454:	dc 01       	movw	r26, r24
    b456:	a4 0f       	add	r26, r20
    b458:	b5 1f       	adc	r27, r21
    b45a:	41 50       	subi	r20, 0x01	; 1
    b45c:	50 40       	sbci	r21, 0x00	; 0
    b45e:	48 f0       	brcs	.+18     	; 0xb472 <__eeupd_block_x128a1+0x1e>
    b460:	cb 01       	movw	r24, r22
    b462:	84 0f       	add	r24, r20
    b464:	95 1f       	adc	r25, r21
    b466:	2e 91       	ld	r18, -X
    b468:	0e 94 3b 5a 	call	0xb476	; 0xb476 <__eeupd_r18_x128a1>
    b46c:	41 50       	subi	r20, 0x01	; 1
    b46e:	50 40       	sbci	r21, 0x00	; 0
    b470:	d0 f7       	brcc	.-12     	; 0xb466 <__eeupd_block_x128a1+0x12>
    b472:	08 95       	ret

0000b474 <__eeupd_byte_x128a1>:
    b474:	26 2f       	mov	r18, r22

0000b476 <__eeupd_r18_x128a1>:
    b476:	0e 94 7e 5a 	call	0xb4fc	; 0xb4fc <eeprom_mapen>
    b47a:	00 80       	ld	r0, Z
    b47c:	02 16       	cp	r0, r18
    b47e:	19 f0       	breq	.+6      	; 0xb486 <__eeupd_r18_x128a1+0x10>
    b480:	0e 94 58 5a 	call	0xb4b0	; 0xb4b0 <__eewr_r18_x128a1>
    b484:	01 97       	sbiw	r24, 0x01	; 1
    b486:	01 97       	sbiw	r24, 0x01	; 1
    b488:	08 95       	ret

0000b48a <__eeupd_dword_x128a1>:
    b48a:	03 96       	adiw	r24, 0x03	; 3
    b48c:	27 2f       	mov	r18, r23
    b48e:	0e 94 3b 5a 	call	0xb476	; 0xb476 <__eeupd_r18_x128a1>
    b492:	0e 94 3a 5a 	call	0xb474	; 0xb474 <__eeupd_byte_x128a1>
    b496:	25 2f       	mov	r18, r21
    b498:	0e 94 3b 5a 	call	0xb476	; 0xb476 <__eeupd_r18_x128a1>
    b49c:	24 2f       	mov	r18, r20
    b49e:	0c 94 3b 5a 	jmp	0xb476	; 0xb476 <__eeupd_r18_x128a1>

0000b4a2 <__eeupd_word_x128a1>:
    b4a2:	01 96       	adiw	r24, 0x01	; 1
    b4a4:	27 2f       	mov	r18, r23
    b4a6:	0e 94 3b 5a 	call	0xb476	; 0xb476 <__eeupd_r18_x128a1>
    b4aa:	0c 94 3a 5a 	jmp	0xb474	; 0xb474 <__eeupd_byte_x128a1>

0000b4ae <__eewr_byte_x128a1>:
    b4ae:	26 2f       	mov	r18, r22

0000b4b0 <__eewr_r18_x128a1>:
    b4b0:	e0 ec       	ldi	r30, 0xC0	; 192
    b4b2:	f1 e0       	ldi	r31, 0x01	; 1
    b4b4:	37 85       	ldd	r19, Z+15	; 0x0f
    b4b6:	37 fd       	sbrc	r19, 7
    b4b8:	fd cf       	rjmp	.-6      	; 0xb4b4 <__eewr_r18_x128a1+0x4>
    b4ba:	34 85       	ldd	r19, Z+12	; 0x0c
    b4bc:	37 7f       	andi	r19, 0xF7	; 247
    b4be:	34 87       	std	Z+12, r19	; 0x0c
    b4c0:	37 85       	ldd	r19, Z+15	; 0x0f
    b4c2:	31 ff       	sbrs	r19, 1
    b4c4:	09 c0       	rjmp	.+18     	; 0xb4d8 <__eewr_r18_x128a1+0x28>
    b4c6:	36 e3       	ldi	r19, 0x36	; 54
    b4c8:	32 87       	std	Z+10, r19	; 0x0a
    b4ca:	38 ed       	ldi	r19, 0xD8	; 216
    b4cc:	34 bf       	out	0x34, r19	; 52
    b4ce:	31 e0       	ldi	r19, 0x01	; 1
    b4d0:	33 87       	std	Z+11, r19	; 0x0b
    b4d2:	37 85       	ldd	r19, Z+15	; 0x0f
    b4d4:	37 fd       	sbrc	r19, 7
    b4d6:	fd cf       	rjmp	.-6      	; 0xb4d2 <__eewr_r18_x128a1+0x22>
    b4d8:	33 e3       	ldi	r19, 0x33	; 51
    b4da:	32 87       	std	Z+10, r19	; 0x0a
    b4dc:	80 83       	st	Z, r24
    b4de:	91 83       	std	Z+1, r25	; 0x01
    b4e0:	12 82       	std	Z+2, r1	; 0x02
    b4e2:	24 83       	std	Z+4, r18	; 0x04
    b4e4:	25 e3       	ldi	r18, 0x35	; 53
    b4e6:	22 87       	std	Z+10, r18	; 0x0a
    b4e8:	28 ed       	ldi	r18, 0xD8	; 216
    b4ea:	31 e0       	ldi	r19, 0x01	; 1
    b4ec:	24 bf       	out	0x34, r18	; 52
    b4ee:	33 87       	std	Z+11, r19	; 0x0b
    b4f0:	01 96       	adiw	r24, 0x01	; 1
    b4f2:	08 95       	ret

0000b4f4 <__eerd_byte_x128a1u>:
    b4f4:	03 d0       	rcall	.+6      	; 0xb4fc <eeprom_mapen>
    b4f6:	80 81       	ld	r24, Z
    b4f8:	99 27       	eor	r25, r25
    b4fa:	08 95       	ret

0000b4fc <eeprom_mapen>:
    b4fc:	e0 ec       	ldi	r30, 0xC0	; 192
    b4fe:	f1 e0       	ldi	r31, 0x01	; 1
    b500:	37 85       	ldd	r19, Z+15	; 0x0f
    b502:	37 fd       	sbrc	r19, 7
    b504:	fd cf       	rjmp	.-6      	; 0xb500 <eeprom_mapen+0x4>
    b506:	34 85       	ldd	r19, Z+12	; 0x0c
    b508:	38 60       	ori	r19, 0x08	; 8
    b50a:	34 87       	std	Z+12, r19	; 0x0c
    b50c:	fc 01       	movw	r30, r24
    b50e:	e0 50       	subi	r30, 0x00	; 0
    b510:	f0 4f       	sbci	r31, 0xF0	; 240
    b512:	08 95       	ret

0000b514 <__ctype_isfalse>:
    b514:	99 27       	eor	r25, r25
    b516:	88 27       	eor	r24, r24

0000b518 <__ctype_istrue>:
    b518:	08 95       	ret

0000b51a <strnlen_P>:
    b51a:	fc 01       	movw	r30, r24
    b51c:	05 90       	lpm	r0, Z+
    b51e:	61 50       	subi	r22, 0x01	; 1
    b520:	70 40       	sbci	r23, 0x00	; 0
    b522:	01 10       	cpse	r0, r1
    b524:	d8 f7       	brcc	.-10     	; 0xb51c <strnlen_P+0x2>
    b526:	80 95       	com	r24
    b528:	90 95       	com	r25
    b52a:	8e 0f       	add	r24, r30
    b52c:	9f 1f       	adc	r25, r31
    b52e:	08 95       	ret

0000b530 <strnlen>:
    b530:	fc 01       	movw	r30, r24
    b532:	61 50       	subi	r22, 0x01	; 1
    b534:	70 40       	sbci	r23, 0x00	; 0
    b536:	01 90       	ld	r0, Z+
    b538:	01 10       	cpse	r0, r1
    b53a:	d8 f7       	brcc	.-10     	; 0xb532 <strnlen+0x2>
    b53c:	80 95       	com	r24
    b53e:	90 95       	com	r25
    b540:	8e 0f       	add	r24, r30
    b542:	9f 1f       	adc	r25, r31
    b544:	08 95       	ret

0000b546 <__ultoa_invert>:
    b546:	fa 01       	movw	r30, r20
    b548:	aa 27       	eor	r26, r26
    b54a:	28 30       	cpi	r18, 0x08	; 8
    b54c:	51 f1       	breq	.+84     	; 0xb5a2 <__ultoa_invert+0x5c>
    b54e:	20 31       	cpi	r18, 0x10	; 16
    b550:	81 f1       	breq	.+96     	; 0xb5b2 <__ultoa_invert+0x6c>
    b552:	e8 94       	clt
    b554:	6f 93       	push	r22
    b556:	6e 7f       	andi	r22, 0xFE	; 254
    b558:	6e 5f       	subi	r22, 0xFE	; 254
    b55a:	7f 4f       	sbci	r23, 0xFF	; 255
    b55c:	8f 4f       	sbci	r24, 0xFF	; 255
    b55e:	9f 4f       	sbci	r25, 0xFF	; 255
    b560:	af 4f       	sbci	r26, 0xFF	; 255
    b562:	b1 e0       	ldi	r27, 0x01	; 1
    b564:	3e d0       	rcall	.+124    	; 0xb5e2 <__ultoa_invert+0x9c>
    b566:	b4 e0       	ldi	r27, 0x04	; 4
    b568:	3c d0       	rcall	.+120    	; 0xb5e2 <__ultoa_invert+0x9c>
    b56a:	67 0f       	add	r22, r23
    b56c:	78 1f       	adc	r23, r24
    b56e:	89 1f       	adc	r24, r25
    b570:	9a 1f       	adc	r25, r26
    b572:	a1 1d       	adc	r26, r1
    b574:	68 0f       	add	r22, r24
    b576:	79 1f       	adc	r23, r25
    b578:	8a 1f       	adc	r24, r26
    b57a:	91 1d       	adc	r25, r1
    b57c:	a1 1d       	adc	r26, r1
    b57e:	6a 0f       	add	r22, r26
    b580:	71 1d       	adc	r23, r1
    b582:	81 1d       	adc	r24, r1
    b584:	91 1d       	adc	r25, r1
    b586:	a1 1d       	adc	r26, r1
    b588:	20 d0       	rcall	.+64     	; 0xb5ca <__ultoa_invert+0x84>
    b58a:	09 f4       	brne	.+2      	; 0xb58e <__ultoa_invert+0x48>
    b58c:	68 94       	set
    b58e:	3f 91       	pop	r19
    b590:	2a e0       	ldi	r18, 0x0A	; 10
    b592:	26 9f       	mul	r18, r22
    b594:	11 24       	eor	r1, r1
    b596:	30 19       	sub	r19, r0
    b598:	30 5d       	subi	r19, 0xD0	; 208
    b59a:	31 93       	st	Z+, r19
    b59c:	de f6       	brtc	.-74     	; 0xb554 <__ultoa_invert+0xe>
    b59e:	cf 01       	movw	r24, r30
    b5a0:	08 95       	ret
    b5a2:	46 2f       	mov	r20, r22
    b5a4:	47 70       	andi	r20, 0x07	; 7
    b5a6:	40 5d       	subi	r20, 0xD0	; 208
    b5a8:	41 93       	st	Z+, r20
    b5aa:	b3 e0       	ldi	r27, 0x03	; 3
    b5ac:	0f d0       	rcall	.+30     	; 0xb5cc <__ultoa_invert+0x86>
    b5ae:	c9 f7       	brne	.-14     	; 0xb5a2 <__ultoa_invert+0x5c>
    b5b0:	f6 cf       	rjmp	.-20     	; 0xb59e <__ultoa_invert+0x58>
    b5b2:	46 2f       	mov	r20, r22
    b5b4:	4f 70       	andi	r20, 0x0F	; 15
    b5b6:	40 5d       	subi	r20, 0xD0	; 208
    b5b8:	4a 33       	cpi	r20, 0x3A	; 58
    b5ba:	18 f0       	brcs	.+6      	; 0xb5c2 <__ultoa_invert+0x7c>
    b5bc:	49 5d       	subi	r20, 0xD9	; 217
    b5be:	31 fd       	sbrc	r19, 1
    b5c0:	40 52       	subi	r20, 0x20	; 32
    b5c2:	41 93       	st	Z+, r20
    b5c4:	02 d0       	rcall	.+4      	; 0xb5ca <__ultoa_invert+0x84>
    b5c6:	a9 f7       	brne	.-22     	; 0xb5b2 <__ultoa_invert+0x6c>
    b5c8:	ea cf       	rjmp	.-44     	; 0xb59e <__ultoa_invert+0x58>
    b5ca:	b4 e0       	ldi	r27, 0x04	; 4
    b5cc:	a6 95       	lsr	r26
    b5ce:	97 95       	ror	r25
    b5d0:	87 95       	ror	r24
    b5d2:	77 95       	ror	r23
    b5d4:	67 95       	ror	r22
    b5d6:	ba 95       	dec	r27
    b5d8:	c9 f7       	brne	.-14     	; 0xb5cc <__ultoa_invert+0x86>
    b5da:	00 97       	sbiw	r24, 0x00	; 0
    b5dc:	61 05       	cpc	r22, r1
    b5de:	71 05       	cpc	r23, r1
    b5e0:	08 95       	ret
    b5e2:	9b 01       	movw	r18, r22
    b5e4:	ac 01       	movw	r20, r24
    b5e6:	0a 2e       	mov	r0, r26
    b5e8:	06 94       	lsr	r0
    b5ea:	57 95       	ror	r21
    b5ec:	47 95       	ror	r20
    b5ee:	37 95       	ror	r19
    b5f0:	27 95       	ror	r18
    b5f2:	ba 95       	dec	r27
    b5f4:	c9 f7       	brne	.-14     	; 0xb5e8 <__ultoa_invert+0xa2>
    b5f6:	62 0f       	add	r22, r18
    b5f8:	73 1f       	adc	r23, r19
    b5fa:	84 1f       	adc	r24, r20
    b5fc:	95 1f       	adc	r25, r21
    b5fe:	a0 1d       	adc	r26, r0
    b600:	08 95       	ret

0000b602 <__mulsi3>:
    b602:	62 9f       	mul	r22, r18
    b604:	d0 01       	movw	r26, r0
    b606:	73 9f       	mul	r23, r19
    b608:	f0 01       	movw	r30, r0
    b60a:	82 9f       	mul	r24, r18
    b60c:	e0 0d       	add	r30, r0
    b60e:	f1 1d       	adc	r31, r1
    b610:	64 9f       	mul	r22, r20
    b612:	e0 0d       	add	r30, r0
    b614:	f1 1d       	adc	r31, r1
    b616:	92 9f       	mul	r25, r18
    b618:	f0 0d       	add	r31, r0
    b61a:	83 9f       	mul	r24, r19
    b61c:	f0 0d       	add	r31, r0
    b61e:	74 9f       	mul	r23, r20
    b620:	f0 0d       	add	r31, r0
    b622:	65 9f       	mul	r22, r21
    b624:	f0 0d       	add	r31, r0
    b626:	99 27       	eor	r25, r25
    b628:	72 9f       	mul	r23, r18
    b62a:	b0 0d       	add	r27, r0
    b62c:	e1 1d       	adc	r30, r1
    b62e:	f9 1f       	adc	r31, r25
    b630:	63 9f       	mul	r22, r19
    b632:	b0 0d       	add	r27, r0
    b634:	e1 1d       	adc	r30, r1
    b636:	f9 1f       	adc	r31, r25
    b638:	bd 01       	movw	r22, r26
    b63a:	cf 01       	movw	r24, r30
    b63c:	11 24       	eor	r1, r1
    b63e:	08 95       	ret

0000b640 <__udivmodsi4>:
    b640:	a1 e2       	ldi	r26, 0x21	; 33
    b642:	1a 2e       	mov	r1, r26
    b644:	aa 1b       	sub	r26, r26
    b646:	bb 1b       	sub	r27, r27
    b648:	fd 01       	movw	r30, r26
    b64a:	0d c0       	rjmp	.+26     	; 0xb666 <__udivmodsi4_ep>

0000b64c <__udivmodsi4_loop>:
    b64c:	aa 1f       	adc	r26, r26
    b64e:	bb 1f       	adc	r27, r27
    b650:	ee 1f       	adc	r30, r30
    b652:	ff 1f       	adc	r31, r31
    b654:	a2 17       	cp	r26, r18
    b656:	b3 07       	cpc	r27, r19
    b658:	e4 07       	cpc	r30, r20
    b65a:	f5 07       	cpc	r31, r21
    b65c:	20 f0       	brcs	.+8      	; 0xb666 <__udivmodsi4_ep>
    b65e:	a2 1b       	sub	r26, r18
    b660:	b3 0b       	sbc	r27, r19
    b662:	e4 0b       	sbc	r30, r20
    b664:	f5 0b       	sbc	r31, r21

0000b666 <__udivmodsi4_ep>:
    b666:	66 1f       	adc	r22, r22
    b668:	77 1f       	adc	r23, r23
    b66a:	88 1f       	adc	r24, r24
    b66c:	99 1f       	adc	r25, r25
    b66e:	1a 94       	dec	r1
    b670:	69 f7       	brne	.-38     	; 0xb64c <__udivmodsi4_loop>
    b672:	60 95       	com	r22
    b674:	70 95       	com	r23
    b676:	80 95       	com	r24
    b678:	90 95       	com	r25
    b67a:	9b 01       	movw	r18, r22
    b67c:	ac 01       	movw	r20, r24
    b67e:	bd 01       	movw	r22, r26
    b680:	cf 01       	movw	r24, r30
    b682:	08 95       	ret

0000b684 <_exit>:
    b684:	f8 94       	cli

0000b686 <__stop_program>:
    b686:	ff cf       	rjmp	.-2      	; 0xb686 <__stop_program>
