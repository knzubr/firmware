   1               		.file	"vty.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 254               	enableFunction:
 255               		.stabd	46,0,0
   1:vty.c         **** #include "main.h"
   2:vty.c         **** #include "vty.h"
   3:vty.c         **** #include "ramdysk.h"
   4:vty.c         **** #include "protocol1.h"
   5:vty.c         **** #include "mpc23s17.h"
   6:vty.c         **** #include "mcp3008.h"
   7:vty.c         **** #include "ds1305.h"
   8:vty.c         **** #include "hardwareConfig.h"
   9:vty.c         **** #include "configuration.h"
  10:vty.c         **** #include "Rs485_prot.h"
  11:vty.c         **** #include "net.h"
  12:vty.c         **** #include "ip.h"
  13:vty.c         **** #include "arp.h"
  14:vty.c         **** #include "softwareConfig.h"
  15:vty.c         **** #include "mcp4150.h"
  16:vty.c         **** 
  17:vty.c         **** #if LANG_EN
  18:vty.c         **** #include "vty_en.h"
  19:vty.c         **** #endif
  20:vty.c         **** 
  21:vty.c         **** #if LANG_PL
  22:vty.c         **** #include "vty_pl.h"
  23:vty.c         **** #endif
  24:vty.c         **** 
  25:vty.c         **** #ifndef LANG_VTY
  26:vty.c         **** #error "Vty Language not defined"
  27:vty.c         **** #endif
  28:vty.c         **** 
  29:vty.c         **** 
  30:vty.c         **** static cliExRes_t helpFunction           (cmdState_t *state);
  31:vty.c         **** static cliExRes_t statusFunction         (cmdState_t *state);
  32:vty.c         **** static cliExRes_t statusEncFunction      (cmdState_t *state);
  33:vty.c         **** static cliExRes_t curtainDownFunction    (cmdState_t *state);
  34:vty.c         **** static cliExRes_t curtainUpFunction      (cmdState_t *state);
  35:vty.c         **** static cliExRes_t rpingFunction          (cmdState_t *state);
  36:vty.c         **** static cliExRes_t pingFunction           (cmdState_t *state);
  37:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state);
  38:vty.c         **** static cliExRes_t goXmodemWyslijFunction (cmdState_t *state);
  39:vty.c         **** static cliExRes_t dodajRamPlikFunction   (cmdState_t *state);
  40:vty.c         **** static cliExRes_t eraseRamFileFunction   (cmdState_t *state);
  41:vty.c         **** static cliExRes_t flashExModuleFunction  (cmdState_t *state);
  42:vty.c         **** static cliExRes_t writeRamFileFunction   (cmdState_t *state);
  43:vty.c         **** static cliExRes_t editRamFileFunction    (cmdState_t *state);
  44:vty.c         **** static cliExRes_t readRamFIleFunction    (cmdState_t *state);
  45:vty.c         **** 
  46:vty.c         **** static cliExRes_t ustawPortExtAFunction  (cmdState_t *state);
  47:vty.c         **** static cliExRes_t ustawPortExtBFunction  (cmdState_t *state);
  48:vty.c         **** static cliExRes_t ustawPortRezystor      (cmdState_t *state);
  49:vty.c         **** 
  50:vty.c         **** static cliExRes_t pokazCzasFunction      (cmdState_t *state);
  51:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state);
  52:vty.c         **** static cliExRes_t czytajAC_Function      (cmdState_t *state);
  53:vty.c         **** 
  54:vty.c         **** static cliExRes_t enableFunction         (cmdState_t *state);
  55:vty.c         **** static cliExRes_t disableFunction        (cmdState_t *state);
  56:vty.c         **** static cliExRes_t configureModeFunction  (cmdState_t *state);
  57:vty.c         **** 
  58:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state);
  59:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state);
  60:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state);
  61:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state);
  62:vty.c         **** 
  63:vty.c         **** static cliExRes_t setMacAddrFunction     (cmdState_t *state);
  64:vty.c         **** static cliExRes_t setTimeFunction        (cmdState_t *state);
  65:vty.c         **** 
  66:vty.c         **** static cliExRes_t saveConfigFunction     (cmdState_t *state);
  67:vty.c         **** 
  68:vty.c         **** #ifdef testZewPamiec
  69:vty.c         **** static cliExRes_t testPamZewFunction     (cmdState_t *state);
  70:vty.c         **** #endif
  71:vty.c         **** 
  72:vty.c         **** struct ramPlikFd    fdVty;  //TODO move it to CLI struct
  73:vty.c         **** 
  74:vty.c         **** prog_char okStr[] = "OK\r\n";
  75:vty.c         **** prog_char nlStr[] = "\r\n";
  76:vty.c         **** prog_char BladBuforaPozostaloBajtowStr[]           = "!!! W budorze Rs485 pozostalo %d bajtow\r\n";
  77:vty.c         **** 
  78:vty.c         **** 
  79:vty.c         **** prog_char __ATTR_PROGMEM__ *errorStrings[] = {
  80:vty.c         ****   errorOK,
  81:vty.c         ****   errorNoFile,
  82:vty.c         ****   errorxModemFrameStartTimeout,
  83:vty.c         ****   errorxModemByteSendTimeout,
  84:vty.c         ****   errorxModemWrongFrameNo,
  85:vty.c         ****   errorxModemFrameFrameNoCorrectionNotMatch,
  86:vty.c         ****   errorxModemFrameCrc,
  87:vty.c         ****   errorxModemRemoteSideCan,
  88:vty.c         ****   errorxModemUnknownResponse,
  89:vty.c         ****   errorNoRemoteDevice,
  90:vty.c         ****   errorBootloaderNotResponding,
  91:vty.c         ****   errorOpenFile
  92:vty.c         **** };
  93:vty.c         **** 
  94:vty.c         **** command_t __ATTR_PROGMEM__ cmdListNormal[] =
  95:vty.c         **** {
  96:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
  97:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
  98:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},  
  99:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 100:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 101:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 102:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 103:vty.c         ****   {cmd_enable,    cmd_help_enable,    enableFunction},
 104:vty.c         ****   {NULL, NULL, NULL}
 105:vty.c         **** };
 106:vty.c         **** 
 107:vty.c         **** command_t __ATTR_PROGMEM__ cmdListEnable[] =
 108:vty.c         **** {
 109:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
 110:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
 111:vty.c         ****   {cmd_enc_stat,  cmd_help_enc_stat,  statusEncFunction},
 112:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},
 113:vty.c         ****   {cmd_net_dbg,   cmd_help_net_dbg,   debugFunction},
 114:vty.c         ****   
 115:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 116:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 117:vty.c         ****   {cmd_xRec,      cmd_help_xRec,      goXmodemOdbierzFunction},
 118:vty.c         ****   {cmd_xSend,     cmd_help_xSend,     goXmodemWyslijFunction},
 119:vty.c         ****   {cmd_xflash,    cmd_help_xflash,    flashExModuleFunction},
 120:vty.c         **** #ifdef testZewPamiec
 121:vty.c         ****   {cmd_rtest,     cmd_help_rtest,     testPamZewFunction},
 122:vty.c         **** #endif
 123:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 124:vty.c         ****   {cmd_create_rf, cmd_help_create_rf, dodajRamPlikFunction},
 125:vty.c         ****   {cmd_erase_rf,  cmd_help_erase_rf,  eraseRamFileFunction},
 126:vty.c         ****   {cmd_edit_rf,   cmd_help_edit_rf,   editRamFileFunction},
 127:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 128:vty.c         **** 
 129:vty.c         ****   {cmd_up,        cmd_help_up,        curtainUpFunction},
 130:vty.c         ****   {cmd_down,      cmd_help_down,      curtainDownFunction},
 131:vty.c         **** 
 132:vty.c         ****   {cmd_spa,       cmd_help_spa,       ustawPortExtAFunction},
 133:vty.c         ****   {cmd_spb,       cmd_help_spb,       ustawPortExtBFunction},
 134:vty.c         ****   {cmd_ustawR,    cmd_help_ustawR,    ustawPortRezystor},
 135:vty.c         ****   {cmd_settime,   cmd_help_settime,   setTimeFunction},
 136:vty.c         ****   {cmd_ac,        cmd_help_ac,        czytajAC_Function},
 137:vty.c         ****   {cmd_disable,   cmd_help_disable,   disableFunction},
 138:vty.c         ****   {cmd_configure, cmd_help_configure, configureModeFunction},
 139:vty.c         ****   {NULL, NULL, NULL}
 140:vty.c         **** };
 141:vty.c         **** 
 142:vty.c         **** command_t __ATTR_PROGMEM__ cmdListConfigure[] =
 143:vty.c         **** {
 144:vty.c         ****   {cmd_help,         cmd_help_help,         helpFunction},
 145:vty.c         ****   {cmd_status,       cmd_help_status,       statusFunction},
 146:vty.c         ****   {cmd_time,         cmd_help_time,         pokazCzasFunction},
 147:vty.c         ****   {cmd_settime,      cmd_help_settime,      setTimeFunction},
 148:vty.c         ****   {cmd_conf_ip,      cmd_help_conf_ip,      setIpFunction},
 149:vty.c         ****   {cmd_conf_ip_mask, cmd_conf_ip_mask_help, setIpMaskFunction},
 150:vty.c         ****   {cmd_conf_ip_gw,   cmd_conf_ip_gw_help,   setIpGwFunction},
 151:vty.c         ****   {cmd_conf_udp,     cmd_help_conf_udp,     setUdpFunction},
 152:vty.c         ****   {cmd_conf_mac,     cmd_help_conf_mac,     setMacAddrFunction},
 153:vty.c         ****   {cmd_conf_save,    cmd_help_conf_save,    saveConfigFunction},
 154:vty.c         ****   {cmd_enable,       cmd_help_enable,       enableFunction},
 155:vty.c         ****   {cmd_disable,      cmd_help_disable,      disableFunction},
 156:vty.c         ****   {NULL, NULL, NULL}
 157:vty.c         **** };
 158:vty.c         **** 
 159:vty.c         **** void VtyInit(cmdState_t* state, FILE *stream)
 160:vty.c         **** {
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 162:vty.c         **** }
 163:vty.c         **** 
 164:vty.c         **** void printErrorInfo(cmdState_t *state)
 165:vty.c         **** {
 166:vty.c         ****   if (state->errno != 0)
 167:vty.c         ****   {
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 169:vty.c         ****   }
 170:vty.c         ****   state->errno = 0;
 171:vty.c         ****   state->err1 = 0;
 172:vty.c         ****   state->err2 = 0;
 173:vty.c         **** }
 174:vty.c         **** 
 175:vty.c         **** static cliExRes_t enableFunction(cmdState_t *state)
 176:vty.c         **** {
 257               	.LM0:
 258               	.LFBB1:
 259               	/* prologue: function */
 260               	/* frame size = 0 */
 261 0000 FC01      		movw r30,r24
 177:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 263               	.LM1:
 264 0002 80A1      		ldd r24,Z+32
 265 0004 8330      		cpi r24,lo8(3)
 266 0006 01F4      		brne .L2
 267 0008 25E0      		ldi r18,lo8(5)
 268 000a 30E0      		ldi r19,hi8(5)
 269 000c 00C0      		rjmp .L3
 270               	.L2:
 178:vty.c         ****   {
 179:vty.c         ****     state->cmdList = cmdListEnable;
 272               	.LM2:
 273 000e 80E0      		ldi r24,lo8(cmdListEnable)
 274 0010 90E0      		ldi r25,hi8(cmdListEnable)
 275 0012 92A3      		std Z+34,r25
 276 0014 81A3      		std Z+33,r24
 180:vty.c         ****     state->cliMode = NR_ENABLE;
 278               	.LM3:
 279 0016 81E0      		ldi r24,lo8(1)
 280 0018 80A3      		std Z+32,r24
 281 001a 20E0      		ldi r18,lo8(0)
 282 001c 30E0      		ldi r19,hi8(0)
 283               	.L3:
 181:vty.c         ****     return OK_SILENT;
 182:vty.c         ****   }
 183:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 184:vty.c         **** }
 285               	.LM4:
 286 001e C901      		movw r24,r18
 287               	/* epilogue start */
 288 0020 0895      		ret
 290               	.Lscope1:
 292               		.stabd	78,0,0
 296               	disableFunction:
 297               		.stabd	46,0,0
 185:vty.c         **** static cliExRes_t disableFunction(cmdState_t *state)
 186:vty.c         **** {
 299               	.LM5:
 300               	.LFBB2:
 301               	/* prologue: function */
 302               	/* frame size = 0 */
 303 0022 FC01      		movw r30,r24
 187:vty.c         ****   state->cmdList = cmdListNormal;
 305               	.LM6:
 306 0024 80E0      		ldi r24,lo8(cmdListNormal)
 307 0026 90E0      		ldi r25,hi8(cmdListNormal)
 308 0028 92A3      		std Z+34,r25
 309 002a 81A3      		std Z+33,r24
 188:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 311               	.LM7:
 312 002c 80A1      		ldd r24,Z+32
 313 002e 8330      		cpi r24,lo8(3)
 314 0030 01F0      		breq .L6
 189:vty.c         ****   {
 190:vty.c         ****     state->cliMode = NR_NORMAL;
 316               	.LM8:
 317 0032 10A2      		std Z+32,__zero_reg__
 318               	.L6:
 191:vty.c         ****   }
 192:vty.c         ****   return OK_SILENT;
 193:vty.c         **** }
 320               	.LM9:
 321 0034 80E0      		ldi r24,lo8(0)
 322 0036 90E0      		ldi r25,hi8(0)
 323               	/* epilogue start */
 324 0038 0895      		ret
 326               	.Lscope2:
 328               		.stabd	78,0,0
 332               	configureModeFunction:
 333               		.stabd	46,0,0
 194:vty.c         **** static cliExRes_t configureModeFunction(cmdState_t *state)
 195:vty.c         **** {
 335               	.LM10:
 336               	.LFBB3:
 337               	/* prologue: function */
 338               	/* frame size = 0 */
 339 003a FC01      		movw r30,r24
 196:vty.c         ****   if (state->cliMode == NR_ENABLE)
 341               	.LM11:
 342 003c 80A1      		ldd r24,Z+32
 343 003e 8130      		cpi r24,lo8(1)
 344 0040 01F0      		breq .L9
 345 0042 25E0      		ldi r18,lo8(5)
 346 0044 30E0      		ldi r19,hi8(5)
 347 0046 00C0      		rjmp .L10
 348               	.L9:
 197:vty.c         ****   {
 198:vty.c         ****     state->cmdList = cmdListConfigure;
 350               	.LM12:
 351 0048 80E0      		ldi r24,lo8(cmdListConfigure)
 352 004a 90E0      		ldi r25,hi8(cmdListConfigure)
 353 004c 92A3      		std Z+34,r25
 354 004e 81A3      		std Z+33,r24
 199:vty.c         ****     state->cliMode = NR_CONFIGURE;
 356               	.LM13:
 357 0050 82E0      		ldi r24,lo8(2)
 358 0052 80A3      		std Z+32,r24
 359 0054 20E0      		ldi r18,lo8(0)
 360 0056 30E0      		ldi r19,hi8(0)
 361               	.L10:
 200:vty.c         ****     return OK_SILENT;
 201:vty.c         ****   }
 202:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 203:vty.c         **** }
 363               	.LM14:
 364 0058 C901      		movw r24,r18
 365               	/* epilogue start */
 366 005a 0895      		ret
 368               	.Lscope3:
 370               		.stabd	78,0,0
 374               	saveConfigFunction:
 375               		.stabd	46,0,0
 204:vty.c         **** 
 205:vty.c         **** // ************************** VTY API *************************************************************
 206:vty.c         **** void printStatus(FILE *stream)
 207:vty.c         **** {
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 209:vty.c         ****   //Print system state
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 216:vty.c         **** 
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 219:vty.c         **** //  printErrorInfo(state); //TODO fix and uncomment
 220:vty.c         ****   
 221:vty.c         ****   //Print system configuration
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 223:vty.c         **** 
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 227:vty.c         ****   
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 231:vty.c         **** 
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 235:vty.c         ****   
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 239:vty.c         ****   
 240:vty.c         ****   //Print Rs485 Execitive modules
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 242:vty.c         ****   tmp = printRs485devices(stream);
 243:vty.c         ****   if (tmp == 0)
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 245:vty.c         ****   
 246:vty.c         ****   //Print locker sensors
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 248:vty.c         ****   tmp = printLockers(stream);
 249:vty.c         ****   if (tmp == 0)
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 251:vty.c         ****   
 252:vty.c         ****   //Print time FIXME deadlock problem
 253:vty.c         **** /*  readTimeDecoded((timeDecoded_t *)(&czasRtc));
 254:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 255:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 256:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 257:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/
 258:vty.c         **** 
 259:vty.c         ****   udpPrintStatus(stream);
 260:vty.c         **** //  arpPrintTable(stream);
 261:vty.c         **** }
 262:vty.c         **** 
 263:vty.c         **** 
 264:vty.c         **** // ************************** CLI Functions *******************************************************
 265:vty.c         **** 
 266:vty.c         **** static cliExRes_t statusFunction(cmdState_t *state)
 267:vty.c         **** {
 268:vty.c         ****   if (state->argc < 1)
 269:vty.c         ****   {
 270:vty.c         ****     printStatus(state->myStdInOut);
 271:vty.c         ****     return OK_SILENT; 
 272:vty.c         ****   }
 273:vty.c         ****   
 274:vty.c         ****   FILE stream;
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 276:vty.c         ****   {
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 278:vty.c         ****     return ERROR_INFORM;
 279:vty.c         ****   }
 280:vty.c         **** 
 281:vty.c         ****   printStatus(&stream);
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 283:vty.c         ****   return OK_SILENT; 
 284:vty.c         **** }
 285:vty.c         **** 
 286:vty.c         **** static cliExRes_t statusEncFunction(cmdState_t *state)
 287:vty.c         **** {
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 289:vty.c         ****   return OK_SILENT;
 290:vty.c         **** }
 291:vty.c         **** 
 292:vty.c         **** static cliExRes_t pokazCzasFunction(cmdState_t *state)
 293:vty.c         **** {
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 299:vty.c         ****   return OK_SILENT;
 300:vty.c         **** }
 301:vty.c         **** 
 302:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state)
 303:vty.c         **** {
 304:vty.c         ****   if (state->argc < 2)
 305:vty.c         ****     return SYNTAX_ERROR;
 306:vty.c         **** 
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 309:vty.c         ****   if (level == 0)
 310:vty.c         ****   {
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 312:vty.c         ****     {
 313:vty.c         ****       setArpDebug(NULL, 0);
 314:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 315:vty.c         ****       return OK_SILENT;  
 316:vty.c         ****     }    
 317:vty.c         **** 
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 319:vty.c         ****     {
 320:vty.c         ****       setIpDebug(NULL, 0);
 321:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 322:vty.c         ****       return OK_SILENT;  
 323:vty.c         ****     }    
 324:vty.c         **** 
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 326:vty.c         ****     {
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 328:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 329:vty.c         ****       return OK_SILENT;  
 330:vty.c         ****     }    
 331:vty.c         **** 
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 333:vty.c         ****     {
 334:vty.c         ****       setTcpDebug(NULL, 0);
 335:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 336:vty.c         ****       return OK_SILENT;  
 337:vty.c         ****     }    
 338:vty.c         **** 
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 340:vty.c         ****     {
 341:vty.c         ****       setUdpDebug(NULL, 0);
 342:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 343:vty.c         ****       return OK_SILENT;  
 344:vty.c         ****     }    
 345:vty.c         **** 
 346:vty.c         **** 
 347:vty.c         ****   }
 348:vty.c         ****   else                   //level > 0
 349:vty.c         ****   {
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 351:vty.c         ****     {
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 353:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 354:vty.c         ****       return OK_SILENT;  
 355:vty.c         ****     }   
 356:vty.c         ****     
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 358:vty.c         ****     {
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 360:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 361:vty.c         ****       return OK_SILENT;  
 362:vty.c         ****     }
 363:vty.c         **** 
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 365:vty.c         ****     {
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 367:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 368:vty.c         ****       return OK_SILENT;  
 369:vty.c         ****     }
 370:vty.c         **** 
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 372:vty.c         ****     {
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 374:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 375:vty.c         ****       return OK_SILENT;  
 376:vty.c         ****     }
 377:vty.c         ****     
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 379:vty.c         ****     {
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 381:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 382:vty.c         ****       return OK_SILENT;  
 383:vty.c         ****     }
 384:vty.c         ****   }
 385:vty.c         ****   
 386:vty.c         ****   return SYNTAX_ERROR;
 387:vty.c         **** }
 388:vty.c         **** 
 389:vty.c         **** 
 390:vty.c         **** static cliExRes_t setTimeFunction(cmdState_t *state)
 391:vty.c         **** {
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 395:vty.c         ****   
 396:vty.c         ****   ds1305start();
 397:vty.c         **** 
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 399:vty.c         ****   uint8_t cJedn = godzina - cDzies*10;
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 402:vty.c         ****   
 403:vty.c         ****   cDzies = minuta/10;
 404:vty.c         ****   cJedn = minuta - cDzies * 10;
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 407:vty.c         ****   
 408:vty.c         ****   cDzies = sekunda/10;
 409:vty.c         ****   cJedn  = sekunda - cDzies * 10;
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 412:vty.c         ****   
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 414:vty.c         ****   return OK_SILENT;
 415:vty.c         **** }
 416:vty.c         **** 
 417:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state)
 418:vty.c         **** {
 419:vty.c         ****   if (state->argc < 4)
 420:vty.c         ****     return SYNTAX_ERROR;
 421:vty.c         ****   
 422:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 423:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 424:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 426:vty.c         ****   
 427:vty.c         ****   ipSetConfigIp(ip);
 428:vty.c         ****   return OK_SILENT;
 429:vty.c         **** }
 430:vty.c         **** 
 431:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state)
 432:vty.c         **** {
 433:vty.c         ****   if (state->argc < 5)
 434:vty.c         ****     return SYNTAX_ERROR;
 435:vty.c         ****   
 436:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 437:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 438:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 440:vty.c         ****   udpSocket->dstIp = ip;
 441:vty.c         ****   
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 444:vty.c         ****   
 445:vty.c         ****   if (state->argc > 5)
 446:vty.c         ****   {
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 449:vty.c         ****   }
 450:vty.c         ****   return OK_SILENT;
 451:vty.c         **** }
 452:vty.c         **** 
 453:vty.c         **** 
 454:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state)
 455:vty.c         **** {
 456:vty.c         ****   if (state->argc < 1)
 457:vty.c         ****     return SYNTAX_ERROR;
 458:vty.c         ****   
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 460:vty.c         ****   
 461:vty.c         ****   ipSetConfigMask(mask);
 462:vty.c         ****   return OK_SILENT;
 463:vty.c         **** }
 464:vty.c         **** 
 465:vty.c         **** 
 466:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state)
 467:vty.c         **** {
 468:vty.c         ****   if (state->argc < 4)
 469:vty.c         ****     return SYNTAX_ERROR;
 470:vty.c         ****   
 471:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) + 
 472:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 473:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 475:vty.c         ****   ipSetConfigGw(gw);
 476:vty.c         ****   return OK_SILENT;
 477:vty.c         **** }
 478:vty.c         **** 
 479:vty.c         **** static cliExRes_t setMacAddrFunction(cmdState_t *state)
 480:vty.c         **** {
 481:vty.c         ****   if (state->argc < 6)
 482:vty.c         ****     return SYNTAX_ERROR;  
 483:vty.c         ****   
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 491:vty.c         ****   return OK_SILENT;
 492:vty.c         **** }
 493:vty.c         **** 
 494:vty.c         **** static cliExRes_t czytajAC_Function(cmdState_t *state)
 495:vty.c         **** {
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 499:vty.c         ****   return OK_SILENT;
 500:vty.c         **** }
 501:vty.c         **** 
 502:vty.c         **** static cliExRes_t helpFunction(cmdState_t *state)
 503:vty.c         **** {
 504:vty.c         ****   cmdPrintHelp(state);
 505:vty.c         ****   return OK_SILENT;
 506:vty.c         **** }
 507:vty.c         **** 
 508:vty.c         **** static cliExRes_t curtainDownFunction(cmdState_t *state)
 509:vty.c         **** {
 510:vty.c         ****   uint8_t nrRolety;
 511:vty.c         ****   uint8_t nrSterownika;
 512:vty.c         ****   uint8_t wartosc;
 513:vty.c         ****   
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 516:vty.c         ****   nrRolety &= 0x01;
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 518:vty.c         **** 
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 520:vty.c         **** 
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 523:vty.c         **** 
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 525:vty.c         ****   
 526:vty.c         ****   if (result == 0)
 527:vty.c         ****     return OK_INFORM;
 528:vty.c         ****   
 529:vty.c         ****   return ERROR_SILENT;
 530:vty.c         **** }
 531:vty.c         **** 
 532:vty.c         **** static cliExRes_t curtainUpFunction(cmdState_t *state)
 533:vty.c         **** {
 534:vty.c         ****   if (state->argc < 2)
 535:vty.c         ****     return SYNTAX_ERROR;
 536:vty.c         ****   
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 539:vty.c         ****   uint8_t wartosc = 255;
 540:vty.c         ****   if (state->argc > 2)
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 542:vty.c         **** 
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 546:vty.c         **** 
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 548:vty.c         ****   
 549:vty.c         ****   if (result == 0)
 550:vty.c         ****     return OK_INFORM;
 551:vty.c         ****   
 552:vty.c         ****   return ERROR_SILENT;
 553:vty.c         **** }
 554:vty.c         **** 
 555:vty.c         **** static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
 556:vty.c         **** {
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 560:vty.c         ****   return OK_SILENT;
 561:vty.c         **** }
 562:vty.c         **** 
 563:vty.c         **** static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
 564:vty.c         **** {
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 568:vty.c         ****   return OK_SILENT;
 569:vty.c         **** }
 570:vty.c         **** 
 571:vty.c         **** static cliExRes_t ustawPortRezystor(cmdState_t *state)
 572:vty.c         **** {
 573:vty.c         ****   if (state->argc < 1)
 574:vty.c         ****     return SYNTAX_ERROR;
 575:vty.c         **** 
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 577:vty.c         ****   
 578:vty.c         ****   MCP4150_setValue(wartosc);
 579:vty.c         ****   
 580:vty.c         ****   return OK_SILENT;
 581:vty.c         **** }
 582:vty.c         **** 
 583:vty.c         **** static cliExRes_t rpingFunction(cmdState_t *state)
 584:vty.c         **** {
 585:vty.c         ****   if (state->argc < 1)
 586:vty.c         ****     return SYNTAX_ERROR;
 587:vty.c         ****   
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 590:vty.c         ****     return OK_INFORM;
 591:vty.c         **** 
 592:vty.c         ****   state->errno = noRemoteDevice;
 593:vty.c         ****   state->err1 = nrSterownika;
 594:vty.c         ****   printErrorInfo(state);
 595:vty.c         ****   return OK_SILENT;
 596:vty.c         **** }
 597:vty.c         **** 
 598:vty.c         **** static cliExRes_t pingFunction(cmdState_t *state)
 599:vty.c         **** {
 600:vty.c         ****   if (state->argc < 4)
 601:vty.c         ****     return SYNTAX_ERROR;
 602:vty.c         ****   
 603:vty.c         ****   uint8_t ip[4];
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 608:vty.c         **** 
 609:vty.c         **** //  Ipv4Ping(*((uint32_t *)(ip)));
 610:vty.c         ****   
 611:vty.c         ****   return OK_SILENT;
 612:vty.c         **** }
 613:vty.c         **** 
 614:vty.c         **** 
 615:vty.c         **** static cliExRes_t flashExModuleFunction(cmdState_t *state)
 616:vty.c         **** {
 617:vty.c         ****   if (state->argc != 2)
 618:vty.c         ****     return SYNTAX_ERROR;
 619:vty.c         ****   
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 622:vty.c         ****   uint8_t  blad;
 623:vty.c         ****   
 624:vty.c         ****   // Sprawdzanie, czy moduł wykonawczy odpowiada
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 626:vty.c         ****   {
 627:vty.c         ****     state->errno = noRemoteDevice;
 628:vty.c         ****     printErrorInfo(state);
 629:vty.c         ****     return ERROR_INFORM;
 630:vty.c         ****   }
 631:vty.c         ****   
 632:vty.c         ****   //Sprawdzanie, czy istnieje odpowiedni plik z firmware
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 634:vty.c         ****   {
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 636:vty.c         ****     return ERROR_INFORM;
 637:vty.c         ****   }
 638:vty.c         ****   
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 640:vty.c         **** 
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 642:vty.c         ****   
 643:vty.c         ****   if (blad != 0)
 644:vty.c         ****     return ERROR_INFORM;
 645:vty.c         **** 
 646:vty.c         ****   return OK_SILENT;
 647:vty.c         **** }
 648:vty.c         **** 
 649:vty.c         **** static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
 650:vty.c         **** {
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 653:vty.c         ****   {
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 655:vty.c         ****     return ERROR_INFORM;
 656:vty.c         ****   }
 657:vty.c         ****   return OK_SILENT;
 658:vty.c         **** }
 659:vty.c         **** 
 660:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
 661:vty.c         **** {
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 664:vty.c         ****   {
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 666:vty.c         ****     return ERROR_INFORM;
 667:vty.c         ****   }
 668:vty.c         ****    
 669:vty.c         ****   uint8_t  i = 25;
 670:vty.c         **** 
 671:vty.c         ****   uint8_t  temp1;
 672:vty.c         **** //  uint8_t  temp2;
 673:vty.c         **** 
 674:vty.c         ****   uint8_t  c;
 675:vty.c         ****   uint8_t  liczbaProb;
 676:vty.c         ****   uint8_t  *zapPtr;
 677:vty.c         ****   uint8_t  *zapPtrKopia;
 678:vty.c         ****  
 679:vty.c         ****   uint16_t crcLokalne;
 680:vty.c         ****   uint8_t nrBloku;
 681:vty.c         **** 
 682:vty.c         ****   uint8_t nrBlokuZdalny;
 683:vty.c         ****   uint8_t nrBlokuZdalnyNeg;
 684:vty.c         **** 
 685:vty.c         ****   uint8_t crcHi;
 686:vty.c         ****   uint8_t crcLo;
 687:vty.c         **** 
 688:vty.c         ****   state->err1=0;
 689:vty.c         ****   state->err2=0;
 690:vty.c         ****   liczbaProb = 20;
 691:vty.c         ****   for ( ; ; )
 692:vty.c         ****   {
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 694:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 695:vty.c         **** 
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 697:vty.c         ****       if (c == SOH)
 698:vty.c         ****         break;                                                   //Rozpoczynamy transmisje
 699:vty.c         **** 
 700:vty.c         ****     liczbaProb--;
 701:vty.c         ****     if (liczbaProb == 0)
 702:vty.c         ****     {
 703:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 704:vty.c         ****       state->errno = (uint8_t)(AllOK);
 705:vty.c         ****       return ERROR_INFORM;
 706:vty.c         ****     }
 707:vty.c         ****   }
 708:vty.c         ****   
 709:vty.c         ****   nrBloku = 1;
 710:vty.c         ****   liczbaProb = 10;
 711:vty.c         **** 
 712:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 713:vty.c         ****   zapPtrKopia     = zapPtr;
 714:vty.c         ****   for ( ; ; )
 715:vty.c         ****   {
 716:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 717:vty.c         ****     {
 718:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 719:vty.c         ****       break; 
 720:vty.c         ****     }
 721:vty.c         ****     
 722:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 723:vty.c         ****     {
 724:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 725:vty.c         ****       break; 
 726:vty.c         ****     }
 727:vty.c         ****   
 728:vty.c         ****     //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
 729:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 730:vty.c         ****     if (nrBlokuZdalny != c)
 731:vty.c         ****     {
 732:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 733:vty.c         ****       state->err1 = nrBlokuZdalny;
 734:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 735:vty.c         ****       break;
 736:vty.c         ****     }
 737:vty.c         ****     
 738:vty.c         ****     //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od b
 739:vty.c         ****     c = nrBloku-1;
 740:vty.c         ****     if (nrBlokuZdalny == c)
 741:vty.c         ****     {
 742:vty.c         ****       nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
 743:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 744:vty.c         ****       zapPtrKopia = zapPtr;
 745:vty.c         ****     }
 746:vty.c         ****     
 747:vty.c         ****     //2 Sprawdzanie, czy pasuje numer bloku
 748:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 749:vty.c         ****     {
 750:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 751:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 752:vty.c         ****       state->err2 = nrBloku;
 753:vty.c         ****       break;
 754:vty.c         ****     }
 755:vty.c         ****         
 756:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 757:vty.c         ****     {
 758:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 759:vty.c         ****         *(zapPtr++) = c;
 760:vty.c         ****       else
 761:vty.c         ****       {
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 763:vty.c         ****         break;
 764:vty.c         ****       }
 765:vty.c         ****     }
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 767:vty.c         ****     {
 768:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 769:vty.c         ****         state->err1 = 2;
 770:vty.c         ****         break;      
 771:vty.c         ****     }
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 773:vty.c         ****     {
 774:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 775:vty.c         ****         state->err1 = 1;
 776:vty.c         ****         break;      
 777:vty.c         ****     }
 778:vty.c         **** 
 779:vty.c         ****     //3 Zerowanie CRC
 780:vty.c         ****     crcLokalne=0; 
 781:vty.c         ****     
 782:vty.c         ****     //4 Obliczanie CRC
 783:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 784:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 785:vty.c         ****      
 786:vty.c         ****     //5 Srawdzanie CRC
 787:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 788:vty.c         ****     {
 789:vty.c         ****       liczbaProb = 10;
 790:vty.c         ****       uartVtySendByte(ACK);      
 791:vty.c         ****     }
 792:vty.c         ****     else
 793:vty.c         ****     {
 794:vty.c         ****       liczbaProb--;
 795:vty.c         ****       nrBloku--;
 796:vty.c         ****       uartVtySendByte(NAK);   
 797:vty.c         ****     }
 798:vty.c         ****     
 799:vty.c         ****     if (liczbaProb == 0)
 800:vty.c         ****     {
 801:vty.c         ****       state->err1 = nrBlokuZdalny;
 802:vty.c         ****       state->err2 = nrBloku;
 803:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 804:vty.c         ****       break; 
 805:vty.c         ****     }
 806:vty.c         **** 
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 808:vty.c         ****     {
 809:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 810:vty.c         ****       break;
 811:vty.c         ****     }
 812:vty.c         ****     
 813:vty.c         ****     if (temp1 == SOH)
 814:vty.c         ****     {
 815:vty.c         ****       nrBloku++;
 816:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 817:vty.c         ****       zapPtrKopia = zapPtr;
 818:vty.c         ****       state->errno = (uint8_t)(AllOK);
 819:vty.c         ****       continue;
 820:vty.c         ****     }
 821:vty.c         **** 
 822:vty.c         ****     if (temp1 == CAN)
 823:vty.c         ****     {
 824:vty.c         ****       state->err1 = nrBloku;
 825:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 826:vty.c         ****       break;
 827:vty.c         ****     }
 828:vty.c         ****     if (temp1 == EOT)
 829:vty.c         ****     {
 830:vty.c         ****       uartVtySendByte(NAK);
 831:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 832:vty.c         ****       {
 833:vty.c         ****         if (temp1 == EOT)
 834:vty.c         ****           uartVtySendByte(ACK);  
 835:vty.c         ****       }
 836:vty.c         ****       state->errno = (uint8_t)(AllOK);
 837:vty.c         ****       break;
 838:vty.c         ****     }
 839:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 840:vty.c         ****     state->err1 = temp1;
 841:vty.c         ****     break;
 842:vty.c         ****   }
 843:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 844:vty.c         ****   return OK_SILENT;
 845:vty.c         **** }
 846:vty.c         **** 
 847:vty.c         **** static cliExRes_t eraseRamFileFunction(cmdState_t *state)
 848:vty.c         **** {
 849:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 850:vty.c         ****     return OK_INFORM;
 851:vty.c         **** 
 852:vty.c         ****   printErrorInfo(state);
 853:vty.c         ****   return ERROR_INFORM;
 854:vty.c         **** }
 855:vty.c         **** 
 856:vty.c         **** static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
 857:vty.c         **** {
 858:vty.c         ****   if (state->argc != 1)
 859:vty.c         ****     return SYNTAX_ERROR;
 860:vty.c         **** 
 861:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 862:vty.c         ****   {
 863:vty.c         ****     return OK_INFORM;
 864:vty.c         ****   }
 865:vty.c         ****   printErrorInfo(state);
 866:vty.c         ****   return ERROR_INFORM;
 867:vty.c         **** }
 868:vty.c         **** 
 869:vty.c         **** static cliExRes_t writeRamFileFunction(cmdState_t *state)
 870:vty.c         **** {
 871:vty.c         ****   ramDyskDir(state->myStdInOut);
 872:vty.c         ****   return OK_SILENT;
 873:vty.c         **** }
 874:vty.c         **** 
 875:vty.c         **** static cliExRes_t editRamFileFunction(cmdState_t *state)
 876:vty.c         **** {
 877:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 878:vty.c         ****   {
 879:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 880:vty.c         ****     return ERROR_INFORM;
 881:vty.c         ****   }
 882:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 883:vty.c         ****   uint8_t znak = 0;
 884:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 885:vty.c         ****   while(1)
 886:vty.c         ****   {
 887:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 888:vty.c         ****       continue;
 889:vty.c         **** 
 890:vty.c         ****     if (znak == 0x03)                                       // ^C
 891:vty.c         ****       break;
 892:vty.c         **** 
 893:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 894:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 895:vty.c         ****   }
 896:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 897:vty.c         ****   return OK_SILENT;
 898:vty.c         **** }
 899:vty.c         **** 
 900:vty.c         **** static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
 901:vty.c         **** {
 902:vty.c         ****   uint8_t rezultat;
 903:vty.c         ****   uint8_t znak = ' ';
 904:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 905:vty.c         ****   {
 906:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 907:vty.c         ****     return ERROR_INFORM;
 908:vty.c         ****   }
 909:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 910:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 911:vty.c         ****   while (rezultat == 0)
 912:vty.c         ****   {
 913:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 914:vty.c         ****     
 915:vty.c         ****     uartVtySendByte(znak);
 916:vty.c         ****     if (znak == '\r')
 917:vty.c         ****       uartVtySendByte('\n');
 918:vty.c         ****   }
 919:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 920:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 921:vty.c         ****   return OK_SILENT;
 922:vty.c         **** }
 923:vty.c         **** 
 924:vty.c         **** static cliExRes_t saveConfigFunction(cmdState_t *state)
 925:vty.c         **** {
 377               	.LM15:
 378               	.LFBB4:
 379               	/* prologue: function */
 380               	/* frame size = 0 */
 926:vty.c         ****   state = NULL;
 927:vty.c         ****   saveConfiguration();
 382               	.LM16:
 383 005c 0E94 0000 		call saveConfiguration
 928:vty.c         ****   return OK_SILENT;
 929:vty.c         **** }
 385               	.LM17:
 386 0060 80E0      		ldi r24,lo8(0)
 387 0062 90E0      		ldi r25,hi8(0)
 388               	/* epilogue start */
 389 0064 0895      		ret
 391               	.Lscope4:
 393               		.stabd	78,0,0
 397               	setMacAddrFunction:
 398               		.stabd	46,0,0
 480:vty.c         **** {
 400               	.LM18:
 401               	.LFBB5:
 402 0066 CF93      		push r28
 403 0068 DF93      		push r29
 404               	/* prologue: function */
 405               	/* frame size = 0 */
 406 006a EC01      		movw r28,r24
 481:vty.c         ****   if (state->argc < 6)
 408               	.LM19:
 409 006c 898D      		ldd r24,Y+25
 410 006e 8630      		cpi r24,lo8(6)
 411 0070 00F4      		brsh .L15
 412 0072 22E0      		ldi r18,lo8(2)
 413 0074 30E0      		ldi r19,hi8(2)
 414 0076 00C0      		rjmp .L16
 415               	.L15:
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 417               	.LM20:
 418 0078 81E0      		ldi r24,lo8(1)
 419 007a BE01      		movw r22,r28
 420 007c 0E94 0000 		call cmdlineGetArgHex
 421 0080 6093 0000 		sts nicState+2,r22
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 423               	.LM21:
 424 0084 82E0      		ldi r24,lo8(2)
 425 0086 BE01      		movw r22,r28
 426 0088 0E94 0000 		call cmdlineGetArgHex
 427 008c 6093 0000 		sts nicState+3,r22
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 429               	.LM22:
 430 0090 83E0      		ldi r24,lo8(3)
 431 0092 BE01      		movw r22,r28
 432 0094 0E94 0000 		call cmdlineGetArgHex
 433 0098 6093 0000 		sts nicState+4,r22
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 435               	.LM23:
 436 009c 84E0      		ldi r24,lo8(4)
 437 009e BE01      		movw r22,r28
 438 00a0 0E94 0000 		call cmdlineGetArgHex
 439 00a4 6093 0000 		sts nicState+5,r22
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 441               	.LM24:
 442 00a8 85E0      		ldi r24,lo8(5)
 443 00aa BE01      		movw r22,r28
 444 00ac 0E94 0000 		call cmdlineGetArgHex
 445 00b0 6093 0000 		sts nicState+6,r22
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 447               	.LM25:
 448 00b4 86E0      		ldi r24,lo8(6)
 449 00b6 BE01      		movw r22,r28
 450 00b8 0E94 0000 		call cmdlineGetArgHex
 451 00bc 6093 0000 		sts nicState+7,r22
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 453               	.LM26:
 454 00c0 80E0      		ldi r24,lo8(nicState+2)
 455 00c2 90E0      		ldi r25,hi8(nicState+2)
 456 00c4 0E94 0000 		call nicSetMacAddress
 457 00c8 20E0      		ldi r18,lo8(0)
 458 00ca 30E0      		ldi r19,hi8(0)
 459               	.L16:
 492:vty.c         **** }
 461               	.LM27:
 462 00cc C901      		movw r24,r18
 463               	/* epilogue start */
 464 00ce DF91      		pop r29
 465 00d0 CF91      		pop r28
 466 00d2 0895      		ret
 468               	.Lscope5:
 470               		.stabd	78,0,0
 474               	pingFunction:
 475               		.stabd	46,0,0
 599:vty.c         **** {
 477               	.LM28:
 478               	.LFBB6:
 479 00d4 CF93      		push r28
 480 00d6 DF93      		push r29
 481               	/* prologue: function */
 482               	/* frame size = 0 */
 483 00d8 EC01      		movw r28,r24
 600:vty.c         ****   if (state->argc < 4)
 485               	.LM29:
 486 00da 898D      		ldd r24,Y+25
 487 00dc 8430      		cpi r24,lo8(4)
 488 00de 00F4      		brsh .L19
 489 00e0 22E0      		ldi r18,lo8(2)
 490 00e2 30E0      		ldi r19,hi8(2)
 491 00e4 00C0      		rjmp .L20
 492               	.L19:
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 494               	.LM30:
 495 00e6 81E0      		ldi r24,lo8(1)
 496 00e8 BE01      		movw r22,r28
 497 00ea 0E94 0000 		call cmdlineGetArgInt
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 499               	.LM31:
 500 00ee 82E0      		ldi r24,lo8(2)
 501 00f0 BE01      		movw r22,r28
 502 00f2 0E94 0000 		call cmdlineGetArgInt
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 504               	.LM32:
 505 00f6 83E0      		ldi r24,lo8(3)
 506 00f8 BE01      		movw r22,r28
 507 00fa 0E94 0000 		call cmdlineGetArgInt
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 509               	.LM33:
 510 00fe 84E0      		ldi r24,lo8(4)
 511 0100 BE01      		movw r22,r28
 512 0102 0E94 0000 		call cmdlineGetArgInt
 513 0106 20E0      		ldi r18,lo8(0)
 514 0108 30E0      		ldi r19,hi8(0)
 515               	.L20:
 612:vty.c         **** }
 517               	.LM34:
 518 010a C901      		movw r24,r18
 519               	/* epilogue start */
 520 010c DF91      		pop r29
 521 010e CF91      		pop r28
 522 0110 0895      		ret
 524               	.Lscope6:
 526               		.stabd	78,0,0
 530               	setUdpFunction:
 531               		.stabd	46,0,0
 432:vty.c         **** {
 533               	.LM35:
 534               	.LFBB7:
 535 0112 6F92      		push r6
 536 0114 7F92      		push r7
 537 0116 8F92      		push r8
 538 0118 9F92      		push r9
 539 011a AF92      		push r10
 540 011c BF92      		push r11
 541 011e CF92      		push r12
 542 0120 DF92      		push r13
 543 0122 EF92      		push r14
 544 0124 FF92      		push r15
 545 0126 0F93      		push r16
 546 0128 1F93      		push r17
 547 012a CF93      		push r28
 548 012c DF93      		push r29
 549               	/* prologue: function */
 550               	/* frame size = 0 */
 551 012e EC01      		movw r28,r24
 433:vty.c         ****   if (state->argc < 5)
 553               	.LM36:
 554 0130 898D      		ldd r24,Y+25
 555 0132 8530      		cpi r24,lo8(5)
 556 0134 00F4      		brsh .L23
 557 0136 22E0      		ldi r18,lo8(2)
 558 0138 30E0      		ldi r19,hi8(2)
 559 013a 00C0      		rjmp .L24
 560               	.L23:
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 562               	.LM37:
 563 013c 81E0      		ldi r24,lo8(1)
 564 013e BE01      		movw r22,r28
 565 0140 0E94 0000 		call cmdlineGetArgInt
 566 0144 3B01      		movw r6,r22
 567 0146 4C01      		movw r8,r24
 568 0148 82E0      		ldi r24,lo8(2)
 569 014a BE01      		movw r22,r28
 570 014c 0E94 0000 		call cmdlineGetArgInt
 571 0150 7B01      		movw r14,r22
 572 0152 8C01      		movw r16,r24
 573 0154 83E0      		ldi r24,lo8(3)
 574 0156 BE01      		movw r22,r28
 575 0158 0E94 0000 		call cmdlineGetArgInt
 576 015c 5B01      		movw r10,r22
 577 015e 6C01      		movw r12,r24
 578 0160 84E0      		ldi r24,lo8(4)
 579 0162 BE01      		movw r22,r28
 580 0164 0E94 0000 		call cmdlineGetArgInt
 440:vty.c         ****   udpSocket->dstIp = ip;
 582               	.LM38:
 583 0168 E091 0000 		lds r30,udpSocket
 584 016c F091 0000 		lds r31,(udpSocket)+1
 585 0170 102F      		mov r17,r16
 586 0172 0F2D      		mov r16,r15
 587 0174 FE2C      		mov r15,r14
 588 0176 EE24      		clr r14
 589 0178 6501      		movw r12,r10
 590 017a BB24      		clr r11
 591 017c AA24      		clr r10
 592 017e EA0C      		add r14,r10
 593 0180 FB1C      		adc r15,r11
 594 0182 0C1D      		adc r16,r12
 595 0184 1D1D      		adc r17,r13
 596 0186 E60C      		add r14,r6
 597 0188 F71C      		adc r15,r7
 598 018a 081D      		adc r16,r8
 599 018c 191D      		adc r17,r9
 600 018e 962F      		mov r25,r22
 601 0190 8827      		clr r24
 602 0192 7727      		clr r23
 603 0194 6627      		clr r22
 604 0196 E60E      		add r14,r22
 605 0198 F71E      		adc r15,r23
 606 019a 081F      		adc r16,r24
 607 019c 191F      		adc r17,r25
 608 019e E682      		std Z+6,r14
 609 01a0 F782      		std Z+7,r15
 610 01a2 0087      		std Z+8,r16
 611 01a4 1187      		std Z+9,r17
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 613               	.LM39:
 614 01a6 85E0      		ldi r24,lo8(5)
 615 01a8 BE01      		movw r22,r28
 616 01aa 0E94 0000 		call cmdlineGetArgInt
 617 01ae DC01      		movw r26,r24
 618 01b0 CB01      		movw r24,r22
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 620               	.LM40:
 621 01b2 0091 0000 		lds r16,udpSocket
 622 01b6 1091 0000 		lds r17,(udpSocket)+1
 623 01ba 0E94 0000 		call htons
 624 01be F801      		movw r30,r16
 625 01c0 9583      		std Z+5,r25
 626 01c2 8483      		std Z+4,r24
 445:vty.c         ****   if (state->argc > 5)
 628               	.LM41:
 629 01c4 898D      		ldd r24,Y+25
 630 01c6 8630      		cpi r24,lo8(6)
 631 01c8 00F0      		brlo .L27
 632               	.L25:
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 634               	.LM42:
 635 01ca 86E0      		ldi r24,lo8(6)
 636 01cc BE01      		movw r22,r28
 637 01ce 0E94 0000 		call cmdlineGetArgInt
 638 01d2 DC01      		movw r26,r24
 639 01d4 CB01      		movw r24,r22
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 641               	.LM43:
 642 01d6 0091 0000 		lds r16,udpSocket
 643 01da 1091 0000 		lds r17,(udpSocket)+1
 644 01de 0E94 0000 		call htons
 645 01e2 F801      		movw r30,r16
 646 01e4 9383      		std Z+3,r25
 647 01e6 8283      		std Z+2,r24
 648               	.L27:
 649 01e8 20E0      		ldi r18,lo8(0)
 650 01ea 30E0      		ldi r19,hi8(0)
 651               	.L24:
 451:vty.c         **** }
 653               	.LM44:
 654 01ec C901      		movw r24,r18
 655               	/* epilogue start */
 656 01ee DF91      		pop r29
 657 01f0 CF91      		pop r28
 658 01f2 1F91      		pop r17
 659 01f4 0F91      		pop r16
 660 01f6 FF90      		pop r15
 661 01f8 EF90      		pop r14
 662 01fa DF90      		pop r13
 663 01fc CF90      		pop r12
 664 01fe BF90      		pop r11
 665 0200 AF90      		pop r10
 666 0202 9F90      		pop r9
 667 0204 8F90      		pop r8
 668 0206 7F90      		pop r7
 669 0208 6F90      		pop r6
 670 020a 0895      		ret
 672               	.Lscope7:
 674               		.stabd	78,0,0
 678               	setIpGwFunction:
 679               		.stabd	46,0,0
 467:vty.c         **** {
 681               	.LM45:
 682               	.LFBB8:
 683 020c 6F92      		push r6
 684 020e 7F92      		push r7
 685 0210 8F92      		push r8
 686 0212 9F92      		push r9
 687 0214 AF92      		push r10
 688 0216 BF92      		push r11
 689 0218 CF92      		push r12
 690 021a DF92      		push r13
 691 021c EF92      		push r14
 692 021e FF92      		push r15
 693 0220 0F93      		push r16
 694 0222 1F93      		push r17
 695 0224 CF93      		push r28
 696 0226 DF93      		push r29
 697               	/* prologue: function */
 698               	/* frame size = 0 */
 699 0228 EC01      		movw r28,r24
 468:vty.c         ****   if (state->argc < 4)
 701               	.LM46:
 702 022a 898D      		ldd r24,Y+25
 703 022c 8430      		cpi r24,lo8(4)
 704 022e 00F4      		brsh .L29
 705 0230 22E0      		ldi r18,lo8(2)
 706 0232 30E0      		ldi r19,hi8(2)
 707 0234 00C0      		rjmp .L30
 708               	.L29:
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 710               	.LM47:
 711 0236 81E0      		ldi r24,lo8(1)
 712 0238 BE01      		movw r22,r28
 713 023a 0E94 0000 		call cmdlineGetArgInt
 714 023e 3B01      		movw r6,r22
 715 0240 4C01      		movw r8,r24
 716 0242 82E0      		ldi r24,lo8(2)
 717 0244 BE01      		movw r22,r28
 718 0246 0E94 0000 		call cmdlineGetArgInt
 719 024a 7B01      		movw r14,r22
 720 024c 8C01      		movw r16,r24
 721 024e 83E0      		ldi r24,lo8(3)
 722 0250 BE01      		movw r22,r28
 723 0252 0E94 0000 		call cmdlineGetArgInt
 724 0256 5B01      		movw r10,r22
 725 0258 6C01      		movw r12,r24
 726 025a 84E0      		ldi r24,lo8(4)
 727 025c BE01      		movw r22,r28
 728 025e 0E94 0000 		call cmdlineGetArgInt
 475:vty.c         ****   ipSetConfigGw(gw);
 730               	.LM48:
 731 0262 102F      		mov r17,r16
 732 0264 0F2D      		mov r16,r15
 733 0266 FE2C      		mov r15,r14
 734 0268 EE24      		clr r14
 735 026a 6501      		movw r12,r10
 736 026c BB24      		clr r11
 737 026e AA24      		clr r10
 738 0270 EA0C      		add r14,r10
 739 0272 FB1C      		adc r15,r11
 740 0274 0C1D      		adc r16,r12
 741 0276 1D1D      		adc r17,r13
 742 0278 E60C      		add r14,r6
 743 027a F71C      		adc r15,r7
 744 027c 081D      		adc r16,r8
 745 027e 191D      		adc r17,r9
 746 0280 962F      		mov r25,r22
 747 0282 8827      		clr r24
 748 0284 7727      		clr r23
 749 0286 6627      		clr r22
 750 0288 E60E      		add r14,r22
 751 028a F71E      		adc r15,r23
 752 028c 081F      		adc r16,r24
 753 028e 191F      		adc r17,r25
 754 0290 C801      		movw r24,r16
 755 0292 B701      		movw r22,r14
 756 0294 0E94 0000 		call ipSetConfigGw
 757 0298 20E0      		ldi r18,lo8(0)
 758 029a 30E0      		ldi r19,hi8(0)
 759               	.L30:
 477:vty.c         **** }
 761               	.LM49:
 762 029c C901      		movw r24,r18
 763               	/* epilogue start */
 764 029e DF91      		pop r29
 765 02a0 CF91      		pop r28
 766 02a2 1F91      		pop r17
 767 02a4 0F91      		pop r16
 768 02a6 FF90      		pop r15
 769 02a8 EF90      		pop r14
 770 02aa DF90      		pop r13
 771 02ac CF90      		pop r12
 772 02ae BF90      		pop r11
 773 02b0 AF90      		pop r10
 774 02b2 9F90      		pop r9
 775 02b4 8F90      		pop r8
 776 02b6 7F90      		pop r7
 777 02b8 6F90      		pop r6
 778 02ba 0895      		ret
 780               	.Lscope8:
 782               		.stabd	78,0,0
 786               	setIpMaskFunction:
 787               		.stabd	46,0,0
 455:vty.c         **** {
 789               	.LM50:
 790               	.LFBB9:
 791               	/* prologue: function */
 792               	/* frame size = 0 */
 793 02bc FC01      		movw r30,r24
 456:vty.c         ****   if (state->argc < 1)
 795               	.LM51:
 796 02be 818D      		ldd r24,Z+25
 797 02c0 8823      		tst r24
 798 02c2 01F4      		brne .L33
 799 02c4 22E0      		ldi r18,lo8(2)
 800 02c6 30E0      		ldi r19,hi8(2)
 801 02c8 00C0      		rjmp .L34
 802               	.L33:
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 804               	.LM52:
 805 02ca 81E0      		ldi r24,lo8(1)
 806 02cc BF01      		movw r22,r30
 807 02ce 0E94 0000 		call cmdlineGetArgInt
 461:vty.c         ****   ipSetConfigMask(mask);
 809               	.LM53:
 810 02d2 20E2      		ldi r18,lo8(32)
 811 02d4 30E0      		ldi r19,hi8(32)
 812 02d6 261B      		sub r18,r22
 813 02d8 370B      		sbc r19,r23
 814 02da 6FEF      		ldi r22,lo8(-1)
 815 02dc 7FEF      		ldi r23,hi8(-1)
 816 02de 8FEF      		ldi r24,hlo8(-1)
 817 02e0 9FEF      		ldi r25,hhi8(-1)
 818 02e2 00C0      		rjmp 2f
 819 02e4 9695      	1:	lsr r25
 820 02e6 8795      		ror r24
 821 02e8 7795      		ror r23
 822 02ea 6795      		ror r22
 823 02ec 2A95      	2:	dec r18
 824 02ee 02F4      		brpl 1b
 825 02f0 0E94 0000 		call ipSetConfigMask
 826 02f4 20E0      		ldi r18,lo8(0)
 827 02f6 30E0      		ldi r19,hi8(0)
 828               	.L34:
 463:vty.c         **** }
 830               	.LM54:
 831 02f8 C901      		movw r24,r18
 832               	/* epilogue start */
 833 02fa 0895      		ret
 835               	.Lscope9:
 837               		.stabd	78,0,0
 841               	setIpFunction:
 842               		.stabd	46,0,0
 418:vty.c         **** {
 844               	.LM55:
 845               	.LFBB10:
 846 02fc 6F92      		push r6
 847 02fe 7F92      		push r7
 848 0300 8F92      		push r8
 849 0302 9F92      		push r9
 850 0304 AF92      		push r10
 851 0306 BF92      		push r11
 852 0308 CF92      		push r12
 853 030a DF92      		push r13
 854 030c EF92      		push r14
 855 030e FF92      		push r15
 856 0310 0F93      		push r16
 857 0312 1F93      		push r17
 858 0314 CF93      		push r28
 859 0316 DF93      		push r29
 860               	/* prologue: function */
 861               	/* frame size = 0 */
 862 0318 EC01      		movw r28,r24
 419:vty.c         ****   if (state->argc < 4)
 864               	.LM56:
 865 031a 898D      		ldd r24,Y+25
 866 031c 8430      		cpi r24,lo8(4)
 867 031e 00F4      		brsh .L37
 868 0320 22E0      		ldi r18,lo8(2)
 869 0322 30E0      		ldi r19,hi8(2)
 870 0324 00C0      		rjmp .L38
 871               	.L37:
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 873               	.LM57:
 874 0326 81E0      		ldi r24,lo8(1)
 875 0328 BE01      		movw r22,r28
 876 032a 0E94 0000 		call cmdlineGetArgInt
 877 032e 3B01      		movw r6,r22
 878 0330 4C01      		movw r8,r24
 879 0332 82E0      		ldi r24,lo8(2)
 880 0334 BE01      		movw r22,r28
 881 0336 0E94 0000 		call cmdlineGetArgInt
 882 033a 7B01      		movw r14,r22
 883 033c 8C01      		movw r16,r24
 884 033e 83E0      		ldi r24,lo8(3)
 885 0340 BE01      		movw r22,r28
 886 0342 0E94 0000 		call cmdlineGetArgInt
 887 0346 5B01      		movw r10,r22
 888 0348 6C01      		movw r12,r24
 889 034a 84E0      		ldi r24,lo8(4)
 890 034c BE01      		movw r22,r28
 891 034e 0E94 0000 		call cmdlineGetArgInt
 427:vty.c         ****   ipSetConfigIp(ip);
 893               	.LM58:
 894 0352 102F      		mov r17,r16
 895 0354 0F2D      		mov r16,r15
 896 0356 FE2C      		mov r15,r14
 897 0358 EE24      		clr r14
 898 035a 6501      		movw r12,r10
 899 035c BB24      		clr r11
 900 035e AA24      		clr r10
 901 0360 EA0C      		add r14,r10
 902 0362 FB1C      		adc r15,r11
 903 0364 0C1D      		adc r16,r12
 904 0366 1D1D      		adc r17,r13
 905 0368 E60C      		add r14,r6
 906 036a F71C      		adc r15,r7
 907 036c 081D      		adc r16,r8
 908 036e 191D      		adc r17,r9
 909 0370 962F      		mov r25,r22
 910 0372 8827      		clr r24
 911 0374 7727      		clr r23
 912 0376 6627      		clr r22
 913 0378 E60E      		add r14,r22
 914 037a F71E      		adc r15,r23
 915 037c 081F      		adc r16,r24
 916 037e 191F      		adc r17,r25
 917 0380 C801      		movw r24,r16
 918 0382 B701      		movw r22,r14
 919 0384 0E94 0000 		call ipSetConfigIp
 920 0388 20E0      		ldi r18,lo8(0)
 921 038a 30E0      		ldi r19,hi8(0)
 922               	.L38:
 429:vty.c         **** }
 924               	.LM59:
 925 038c C901      		movw r24,r18
 926               	/* epilogue start */
 927 038e DF91      		pop r29
 928 0390 CF91      		pop r28
 929 0392 1F91      		pop r17
 930 0394 0F91      		pop r16
 931 0396 FF90      		pop r15
 932 0398 EF90      		pop r14
 933 039a DF90      		pop r13
 934 039c CF90      		pop r12
 935 039e BF90      		pop r11
 936 03a0 AF90      		pop r10
 937 03a2 9F90      		pop r9
 938 03a4 8F90      		pop r8
 939 03a6 7F90      		pop r7
 940 03a8 6F90      		pop r6
 941 03aa 0895      		ret
 943               	.Lscope10:
 945               		.stabd	78,0,0
 949               	czytajAC_Function:
 950               		.stabd	46,0,0
 495:vty.c         **** {
 952               	.LM60:
 953               	.LFBB11:
 954 03ac FF92      		push r15
 955 03ae 0F93      		push r16
 956 03b0 1F93      		push r17
 957               	/* prologue: function */
 958               	/* frame size = 0 */
 959 03b2 8C01      		movw r16,r24
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 961               	.LM61:
 962 03b4 81E0      		ldi r24,lo8(1)
 963 03b6 B801      		movw r22,r16
 964 03b8 0E94 0000 		call cmdlineGetArgInt
 965 03bc F62E      		mov r15,r22
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 967               	.LM62:
 968 03be 862F      		mov r24,r22
 969 03c0 0E94 0000 		call MCP3008_getSampleSingle
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 971               	.LM63:
 972 03c4 2DB7      		in r18,__SP_L__
 973 03c6 3EB7      		in r19,__SP_H__
 974 03c8 2850      		subi r18,lo8(-(-8))
 975 03ca 3040      		sbci r19,hi8(-(-8))
 976 03cc 0FB6      		in __tmp_reg__,__SREG__
 977 03ce F894      		cli
 978 03d0 3EBF      		out __SP_H__,r19
 979 03d2 0FBE      		out __SREG__,__tmp_reg__
 980 03d4 2DBF      		out __SP_L__,r18
 981 03d6 EDB7      		in r30,__SP_L__
 982 03d8 FEB7      		in r31,__SP_H__
 983 03da 3196      		adiw r30,1
 984 03dc D801      		movw r26,r16
 985 03de 5A96      		adiw r26,26
 986 03e0 2D91      		ld r18,X+
 987 03e2 3C91      		ld r19,X
 988 03e4 5B97      		sbiw r26,26+1
 989 03e6 ADB7      		in r26,__SP_L__
 990 03e8 BEB7      		in r27,__SP_H__
 991 03ea 1296      		adiw r26,1+1
 992 03ec 3C93      		st X,r19
 993 03ee 2E93      		st -X,r18
 994 03f0 1197      		sbiw r26,1
 995 03f2 20E0      		ldi r18,lo8(__c.3417)
 996 03f4 30E0      		ldi r19,hi8(__c.3417)
 997 03f6 3383      		std Z+3,r19
 998 03f8 2283      		std Z+2,r18
 999 03fa F482      		std Z+4,r15
 1000 03fc 1582      		std Z+5,__zero_reg__
 1001 03fe 9783      		std Z+7,r25
 1002 0400 8683      		std Z+6,r24
 1003 0402 0E94 0000 		call fprintf_P
 1004 0406 2DB7      		in r18,__SP_L__
 1005 0408 3EB7      		in r19,__SP_H__
 1006 040a 285F      		subi r18,lo8(-(8))
 1007 040c 3F4F      		sbci r19,hi8(-(8))
 1008 040e 0FB6      		in __tmp_reg__,__SREG__
 1009 0410 F894      		cli
 1010 0412 3EBF      		out __SP_H__,r19
 1011 0414 0FBE      		out __SREG__,__tmp_reg__
 1012 0416 2DBF      		out __SP_L__,r18
 500:vty.c         **** }
 1014               	.LM64:
 1015 0418 80E0      		ldi r24,lo8(0)
 1016 041a 90E0      		ldi r25,hi8(0)
 1017               	/* epilogue start */
 1018 041c 1F91      		pop r17
 1019 041e 0F91      		pop r16
 1020 0420 FF90      		pop r15
 1021 0422 0895      		ret
 1023               	.Lscope11:
 1025               		.stabd	78,0,0
 1028               	.global	printErrorInfo
 1030               	printErrorInfo:
 1031               		.stabd	46,0,0
 165:vty.c         **** {
 1033               	.LM65:
 1034               	.LFBB12:
 1035 0424 CF93      		push r28
 1036 0426 DF93      		push r29
 1037               	/* prologue: function */
 1038               	/* frame size = 0 */
 1039 0428 EC01      		movw r28,r24
 166:vty.c         ****   if (state->errno != 0)
 1041               	.LM66:
 1042 042a 8C8D      		ldd r24,Y+28
 1043 042c 8823      		tst r24
 1044 042e 01F0      		breq .L43
 1045               	.LBB5:
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 1047               	.LM67:
 1048 0430 E82F      		mov r30,r24
 1049 0432 F0E0      		ldi r31,lo8(0)
 1050 0434 EE0F      		lsl r30
 1051 0436 FF1F      		rol r31
 1052 0438 E050      		subi r30,lo8(-(errorStrings))
 1053 043a F040      		sbci r31,hi8(-(errorStrings))
 1054               	/* #APP */
 1055               	 ;  168 "vty.c" 1
 1056 043c 2591      		lpm r18, Z+
 1057 043e 3491      		lpm r19, Z
 1058               		
 1059               	 ;  0 "" 2
 1060               	/* #NOAPP */
 1061               	.LBE5:
 1062 0440 8DB7      		in r24,__SP_L__
 1063 0442 9EB7      		in r25,__SP_H__
 1064 0444 0897      		sbiw r24,8
 1065 0446 0FB6      		in __tmp_reg__,__SREG__
 1066 0448 F894      		cli
 1067 044a 9EBF      		out __SP_H__,r25
 1068 044c 0FBE      		out __SREG__,__tmp_reg__
 1069 044e 8DBF      		out __SP_L__,r24
 1070 0450 EDB7      		in r30,__SP_L__
 1071 0452 FEB7      		in r31,__SP_H__
 1072 0454 3196      		adiw r30,1
 1073 0456 8A8D      		ldd r24,Y+26
 1074 0458 9B8D      		ldd r25,Y+27
 1075 045a ADB7      		in r26,__SP_L__
 1076 045c BEB7      		in r27,__SP_H__
 1077 045e 1296      		adiw r26,1+1
 1078 0460 9C93      		st X,r25
 1079 0462 8E93      		st -X,r24
 1080 0464 1197      		sbiw r26,1
 1081 0466 3383      		std Z+3,r19
 1082 0468 2283      		std Z+2,r18
 1083 046a 8D8D      		ldd r24,Y+29
 1084 046c 9E8D      		ldd r25,Y+30
 1085 046e 9583      		std Z+5,r25
 1086 0470 8483      		std Z+4,r24
 1087 0472 8F8D      		ldd r24,Y+31
 1088 0474 8683      		std Z+6,r24
 1089 0476 1782      		std Z+7,__zero_reg__
 1090 0478 0E94 0000 		call fprintf_P
 1091 047c 8DB7      		in r24,__SP_L__
 1092 047e 9EB7      		in r25,__SP_H__
 1093 0480 0896      		adiw r24,8
 1094 0482 0FB6      		in __tmp_reg__,__SREG__
 1095 0484 F894      		cli
 1096 0486 9EBF      		out __SP_H__,r25
 1097 0488 0FBE      		out __SREG__,__tmp_reg__
 1098 048a 8DBF      		out __SP_L__,r24
 1099               	.L43:
 170:vty.c         ****   state->errno = 0;
 1101               	.LM68:
 1102 048c 1C8E      		std Y+28,__zero_reg__
 171:vty.c         ****   state->err1 = 0;
 1104               	.LM69:
 1105 048e 1E8E      		std Y+30,__zero_reg__
 1106 0490 1D8E      		std Y+29,__zero_reg__
 172:vty.c         ****   state->err2 = 0;
 1108               	.LM70:
 1109 0492 1F8E      		std Y+31,__zero_reg__
 1110               	/* epilogue start */
 173:vty.c         **** }
 1112               	.LM71:
 1113 0494 DF91      		pop r29
 1114 0496 CF91      		pop r28
 1115 0498 0895      		ret
 1121               	.Lscope12:
 1123               		.stabd	78,0,0
 1127               	setTimeFunction:
 1128               		.stabd	46,0,0
 391:vty.c         **** {
 1130               	.LM72:
 1131               	.LFBB13:
 1132 049a EF92      		push r14
 1133 049c FF92      		push r15
 1134 049e 0F93      		push r16
 1135 04a0 1F93      		push r17
 1136               	/* prologue: function */
 1137               	/* frame size = 0 */
 1138 04a2 8C01      		movw r16,r24
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 1140               	.LM73:
 1141 04a4 81E0      		ldi r24,lo8(1)
 1142 04a6 B801      		movw r22,r16
 1143 04a8 0E94 0000 		call cmdlineGetArgInt
 1144 04ac F62E      		mov r15,r22
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 1146               	.LM74:
 1147 04ae 82E0      		ldi r24,lo8(2)
 1148 04b0 B801      		movw r22,r16
 1149 04b2 0E94 0000 		call cmdlineGetArgInt
 1150 04b6 E62E      		mov r14,r22
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 1152               	.LM75:
 1153 04b8 83E0      		ldi r24,lo8(3)
 1154 04ba B801      		movw r22,r16
 1155 04bc 0E94 0000 		call cmdlineGetArgInt
 1156 04c0 162F      		mov r17,r22
 396:vty.c         ****   ds1305start();
 1158               	.LM76:
 1159 04c2 0E94 0000 		call ds1305start
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 1161               	.LM77:
 1162 04c6 8F2D      		mov r24,r15
 1163 04c8 6AE0      		ldi r22,lo8(10)
 1164 04ca 0E94 0000 		call __udivmodqi4
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 1166               	.LM78:
 1167 04ce 282F      		mov r18,r24
 1168 04d0 2370      		andi r18,lo8(3)
 1169 04d2 A0E0      		ldi r26,lo8(czasRtc+2)
 1170 04d4 B0E0      		ldi r27,hi8(czasRtc+2)
 1171 04d6 2295      		swap r18
 1172 04d8 207F      		andi r18,lo8(-16)
 1173 04da 9091 0000 		lds r25,czasRtc+2
 1174 04de 9F7C      		andi r25,lo8(-49)
 1175 04e0 922B      		or r25,r18
 1176 04e2 9093 0000 		sts czasRtc+2,r25
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 1178               	.LM79:
 1179 04e6 46EF      		ldi r20,lo8(-10)
 1180 04e8 5FEF      		ldi r21,hi8(-10)
 1181 04ea 849F      		mul r24,r20
 1182 04ec 802D      		mov r24,r0
 1183 04ee 1124      		clr r1
 1184 04f0 8F0D      		add r24,r15
 1185 04f2 8F70      		andi r24,lo8(15)
 1186 04f4 9091 0000 		lds r25,czasRtc+2
 1187 04f8 907F      		andi r25,lo8(-16)
 1188 04fa 982B      		or r25,r24
 1189 04fc 9093 0000 		sts czasRtc+2,r25
 403:vty.c         ****   cDzies = minuta/10;
 1191               	.LM80:
 1192 0500 8E2D      		mov r24,r14
 1193 0502 0E94 0000 		call __udivmodqi4
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 1195               	.LM81:
 1196 0506 282F      		mov r18,r24
 1197 0508 2770      		andi r18,lo8(7)
 1198 050a FD01      		movw r30,r26
 1199 050c 2295      		swap r18
 1200 050e 207F      		andi r18,lo8(-16)
 1201 0510 9291      		ld r25,-Z
 1202 0512 9F78      		andi r25,lo8(-113)
 1203 0514 922B      		or r25,r18
 1204 0516 9083      		st Z,r25
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 1206               	.LM82:
 1207 0518 849F      		mul r24,r20
 1208 051a 802D      		mov r24,r0
 1209 051c 1124      		clr r1
 1210 051e 8E0D      		add r24,r14
 1211 0520 8F70      		andi r24,lo8(15)
 1212 0522 9081      		ld r25,Z
 1213 0524 907F      		andi r25,lo8(-16)
 1214 0526 982B      		or r25,r24
 1215 0528 9083      		st Z,r25
 408:vty.c         ****   cDzies = sekunda/10;
 1217               	.LM83:
 1218 052a 812F      		mov r24,r17
 1219 052c 0E94 0000 		call __udivmodqi4
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 1221               	.LM84:
 1222 0530 282F      		mov r18,r24
 1223 0532 2770      		andi r18,lo8(7)
 1224 0534 1297      		sbiw r26,2
 1225 0536 2295      		swap r18
 1226 0538 207F      		andi r18,lo8(-16)
 1227 053a 9C91      		ld r25,X
 1228 053c 9F78      		andi r25,lo8(-113)
 1229 053e 922B      		or r25,r18
 1230 0540 9C93      		st X,r25
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 1232               	.LM85:
 1233 0542 849F      		mul r24,r20
 1234 0544 802D      		mov r24,r0
 1235 0546 1124      		clr r1
 1236 0548 810F      		add r24,r17
 1237 054a 8F70      		andi r24,lo8(15)
 1238 054c 9C91      		ld r25,X
 1239 054e 907F      		andi r25,lo8(-16)
 1240 0550 982B      		or r25,r24
 1241 0552 9C93      		st X,r25
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 1243               	.LM86:
 1244 0554 CD01      		movw r24,r26
 1245 0556 0E94 0000 		call setTimeDecoded
 415:vty.c         **** }
 1247               	.LM87:
 1248 055a 80E0      		ldi r24,lo8(0)
 1249 055c 90E0      		ldi r25,hi8(0)
 1250               	/* epilogue start */
 1251 055e 1F91      		pop r17
 1252 0560 0F91      		pop r16
 1253 0562 FF90      		pop r15
 1254 0564 EF90      		pop r14
 1255 0566 0895      		ret
 1257               	.Lscope13:
 1259               		.stabd	78,0,0
 1263               	ustawPortRezystor:
 1264               		.stabd	46,0,0
 572:vty.c         **** {
 1266               	.LM88:
 1267               	.LFBB14:
 1268               	/* prologue: function */
 1269               	/* frame size = 0 */
 1270 0568 FC01      		movw r30,r24
 573:vty.c         ****   if (state->argc < 1)
 1272               	.LM89:
 1273 056a 818D      		ldd r24,Z+25
 1274 056c 8823      		tst r24
 1275 056e 01F4      		brne .L48
 1276 0570 22E0      		ldi r18,lo8(2)
 1277 0572 30E0      		ldi r19,hi8(2)
 1278 0574 00C0      		rjmp .L49
 1279               	.L48:
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 1281               	.LM90:
 1282 0576 81E0      		ldi r24,lo8(1)
 1283 0578 BF01      		movw r22,r30
 1284 057a 0E94 0000 		call cmdlineGetArgInt
 1285 057e 862F      		mov r24,r22
 578:vty.c         ****   MCP4150_setValue(wartosc);
 1287               	.LM91:
 1288 0580 0E94 0000 		call MCP4150_setValue
 1289 0584 20E0      		ldi r18,lo8(0)
 1290 0586 30E0      		ldi r19,hi8(0)
 1291               	.L49:
 581:vty.c         **** }
 1293               	.LM92:
 1294 0588 C901      		movw r24,r18
 1295               	/* epilogue start */
 1296 058a 0895      		ret
 1298               	.Lscope14:
 1300               		.stabd	78,0,0
 1304               	ustawPortExtBFunction:
 1305               		.stabd	46,0,0
 564:vty.c         **** {
 1307               	.LM93:
 1308               	.LFBB15:
 1309 058c 1F93      		push r17
 1310               	/* prologue: function */
 1311               	/* frame size = 0 */
 1312 058e BC01      		movw r22,r24
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1314               	.LM94:
 1315 0590 81E0      		ldi r24,lo8(1)
 1316 0592 0E94 0000 		call cmdlineGetArgInt
 1317 0596 162F      		mov r17,r22
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 1319               	.LM95:
 1320 0598 80E0      		ldi r24,lo8(0)
 1321 059a 60E0      		ldi r22,lo8(0)
 1322 059c 0E94 0000 		call MPC23s17SetDirB
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 1324               	.LM96:
 1325 05a0 812F      		mov r24,r17
 1326 05a2 60E0      		ldi r22,lo8(0)
 1327 05a4 0E94 0000 		call MPC23s17SetPortB
 569:vty.c         **** }
 1329               	.LM97:
 1330 05a8 80E0      		ldi r24,lo8(0)
 1331 05aa 90E0      		ldi r25,hi8(0)
 1332               	/* epilogue start */
 1333 05ac 1F91      		pop r17
 1334 05ae 0895      		ret
 1336               	.Lscope15:
 1338               		.stabd	78,0,0
 1342               	ustawPortExtAFunction:
 1343               		.stabd	46,0,0
 556:vty.c         **** {
 1345               	.LM98:
 1346               	.LFBB16:
 1347 05b0 1F93      		push r17
 1348               	/* prologue: function */
 1349               	/* frame size = 0 */
 1350 05b2 BC01      		movw r22,r24
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1352               	.LM99:
 1353 05b4 81E0      		ldi r24,lo8(1)
 1354 05b6 0E94 0000 		call cmdlineGetArgInt
 1355 05ba 162F      		mov r17,r22
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 1357               	.LM100:
 1358 05bc 80E0      		ldi r24,lo8(0)
 1359 05be 60E0      		ldi r22,lo8(0)
 1360 05c0 0E94 0000 		call MPC23s17SetDirA
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 1362               	.LM101:
 1363 05c4 812F      		mov r24,r17
 1364 05c6 60E0      		ldi r22,lo8(0)
 1365 05c8 0E94 0000 		call MPC23s17SetPortA
 561:vty.c         **** }
 1367               	.LM102:
 1368 05cc 80E0      		ldi r24,lo8(0)
 1369 05ce 90E0      		ldi r25,hi8(0)
 1370               	/* epilogue start */
 1371 05d0 1F91      		pop r17
 1372 05d2 0895      		ret
 1374               	.Lscope16:
 1376               		.stabd	78,0,0
 1380               	curtainDownFunction:
 1381               		.stabd	46,0,0
 509:vty.c         **** {
 1383               	.LM103:
 1384               	.LFBB17:
 1385 05d4 FF92      		push r15
 1386 05d6 0F93      		push r16
 1387 05d8 1F93      		push r17
 1388 05da CF93      		push r28
 1389 05dc DF93      		push r29
 1390               	/* prologue: function */
 1391               	/* frame size = 0 */
 1392 05de EC01      		movw r28,r24
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 1394               	.LM104:
 1395 05e0 81E0      		ldi r24,lo8(1)
 1396 05e2 BE01      		movw r22,r28
 1397 05e4 0E94 0000 		call cmdlineGetArgInt
 1398 05e8 F62E      		mov r15,r22
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 1400               	.LM105:
 1401 05ea 82E0      		ldi r24,lo8(2)
 1402 05ec BE01      		movw r22,r28
 1403 05ee 0E94 0000 		call cmdlineGetArgInt
 1404 05f2 162F      		mov r17,r22
 516:vty.c         ****   nrRolety &= 0x01;
 1406               	.LM106:
 1407 05f4 1170      		andi r17,lo8(1)
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 1409               	.LM107:
 1410 05f6 83E0      		ldi r24,lo8(3)
 1411 05f8 BE01      		movw r22,r28
 1412 05fa 0E94 0000 		call cmdlineGetArgInt
 1413 05fe 062F      		mov r16,r22
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 1415               	.LM108:
 1416 0600 2DB7      		in r18,__SP_L__
 1417 0602 3EB7      		in r19,__SP_H__
 1418 0604 2850      		subi r18,lo8(-(-8))
 1419 0606 3040      		sbci r19,hi8(-(-8))
 1420 0608 0FB6      		in __tmp_reg__,__SREG__
 1421 060a F894      		cli
 1422 060c 3EBF      		out __SP_H__,r19
 1423 060e 0FBE      		out __SREG__,__tmp_reg__
 1424 0610 2DBF      		out __SP_L__,r18
 1425 0612 EDB7      		in r30,__SP_L__
 1426 0614 FEB7      		in r31,__SP_H__
 1427 0616 3196      		adiw r30,1
 1428 0618 8A8D      		ldd r24,Y+26
 1429 061a 9B8D      		ldd r25,Y+27
 1430 061c ADB7      		in r26,__SP_L__
 1431 061e BEB7      		in r27,__SP_H__
 1432 0620 1296      		adiw r26,1+1
 1433 0622 9C93      		st X,r25
 1434 0624 8E93      		st -X,r24
 1435 0626 1197      		sbiw r26,1
 1436 0628 80E0      		ldi r24,lo8(movingCurtainDownStr)
 1437 062a 90E0      		ldi r25,hi8(movingCurtainDownStr)
 1438 062c 9383      		std Z+3,r25
 1439 062e 8283      		std Z+2,r24
 1440 0630 F482      		std Z+4,r15
 1441 0632 1582      		std Z+5,__zero_reg__
 1442 0634 812F      		mov r24,r17
 1443 0636 90E0      		ldi r25,lo8(0)
 1444 0638 0196      		adiw r24,1
 1445 063a 9783      		std Z+7,r25
 1446 063c 8683      		std Z+6,r24
 1447 063e 0E94 0000 		call fprintf_P
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1449               	.LM109:
 1450 0642 802F      		mov r24,r16
 1451 0644 8150      		subi r24,lo8(-(-1))
 1452 0646 2DB7      		in r18,__SP_L__
 1453 0648 3EB7      		in r19,__SP_H__
 1454 064a 285F      		subi r18,lo8(-(8))
 1455 064c 3F4F      		sbci r19,hi8(-(8))
 1456 064e 0FB6      		in __tmp_reg__,__SREG__
 1457 0650 F894      		cli
 1458 0652 3EBF      		out __SP_H__,r19
 1459 0654 0FBE      		out __SREG__,__tmp_reg__
 1460 0656 2DBF      		out __SP_L__,r18
 1461 0658 8436      		cpi r24,lo8(100)
 1462 065a 00F4      		brsh .L56
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1464               	.LM110:
 1465 065c 00D0      		rcall .
 1466 065e 00D0      		rcall .
 1467 0660 00D0      		rcall .
 1468 0662 EDB7      		in r30,__SP_L__
 1469 0664 FEB7      		in r31,__SP_H__
 1470 0666 3196      		adiw r30,1
 1471 0668 8A8D      		ldd r24,Y+26
 1472 066a 9B8D      		ldd r25,Y+27
 1473 066c ADB7      		in r26,__SP_L__
 1474 066e BEB7      		in r27,__SP_H__
 1475 0670 1296      		adiw r26,1+1
 1476 0672 9C93      		st X,r25
 1477 0674 8E93      		st -X,r24
 1478 0676 1197      		sbiw r26,1
 1479 0678 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1480 067a 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1481 067c 9383      		std Z+3,r25
 1482 067e 8283      		std Z+2,r24
 1483 0680 0483      		std Z+4,r16
 1484 0682 1582      		std Z+5,__zero_reg__
 1485 0684 0E94 0000 		call fprintf_P
 1486 0688 2DB7      		in r18,__SP_L__
 1487 068a 3EB7      		in r19,__SP_H__
 1488 068c 2A5F      		subi r18,lo8(-(6))
 1489 068e 3F4F      		sbci r19,hi8(-(6))
 1490 0690 0FB6      		in __tmp_reg__,__SREG__
 1491 0692 F894      		cli
 1492 0694 3EBF      		out __SP_H__,r19
 1493 0696 0FBE      		out __SREG__,__tmp_reg__
 1494 0698 2DBF      		out __SP_L__,r18
 1495               	.L56:
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 1497               	.LM111:
 1498 069a 8F2D      		mov r24,r15
 1499 069c 612F      		mov r22,r17
 1500 069e 402F      		mov r20,r16
 1501 06a0 0E94 0000 		call rs485curtainDown
 526:vty.c         ****   if (result == 0)
 1503               	.LM112:
 1504 06a4 8823      		tst r24
 1505 06a6 01F0      		breq .L57
 1506 06a8 23E0      		ldi r18,lo8(3)
 1507 06aa 30E0      		ldi r19,hi8(3)
 1508 06ac 00C0      		rjmp .L58
 1509               	.L57:
 1510 06ae 21E0      		ldi r18,lo8(1)
 1511 06b0 30E0      		ldi r19,hi8(1)
 1512               	.L58:
 530:vty.c         **** }
 1514               	.LM113:
 1515 06b2 C901      		movw r24,r18
 1516               	/* epilogue start */
 1517 06b4 DF91      		pop r29
 1518 06b6 CF91      		pop r28
 1519 06b8 1F91      		pop r17
 1520 06ba 0F91      		pop r16
 1521 06bc FF90      		pop r15
 1522 06be 0895      		ret
 1528               	.Lscope17:
 1530               		.stabd	78,0,0
 1534               	curtainUpFunction:
 1535               		.stabd	46,0,0
 533:vty.c         **** {
 1537               	.LM114:
 1538               	.LFBB18:
 1539 06c0 FF92      		push r15
 1540 06c2 0F93      		push r16
 1541 06c4 1F93      		push r17
 1542 06c6 CF93      		push r28
 1543 06c8 DF93      		push r29
 1544               	/* prologue: function */
 1545               	/* frame size = 0 */
 1546 06ca EC01      		movw r28,r24
 534:vty.c         ****   if (state->argc < 2)
 1548               	.LM115:
 1549 06cc 898D      		ldd r24,Y+25
 1550 06ce 8230      		cpi r24,lo8(2)
 1551 06d0 00F4      		brsh .L61
 1552 06d2 22E0      		ldi r18,lo8(2)
 1553 06d4 30E0      		ldi r19,hi8(2)
 1554 06d6 00C0      		rjmp .L62
 1555               	.L61:
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 1557               	.LM116:
 1558 06d8 81E0      		ldi r24,lo8(1)
 1559 06da BE01      		movw r22,r28
 1560 06dc 0E94 0000 		call cmdlineGetArgInt
 1561 06e0 F62E      		mov r15,r22
 1562 06e2 2FE3      		ldi r18,lo8(63)
 1563 06e4 F222      		and r15,r18
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 1565               	.LM117:
 1566 06e6 82E0      		ldi r24,lo8(2)
 1567 06e8 BE01      		movw r22,r28
 1568 06ea 0E94 0000 		call cmdlineGetArgInt
 1569 06ee 062F      		mov r16,r22
 1570 06f0 0170      		andi r16,lo8(1)
 540:vty.c         ****   if (state->argc > 2)
 1572               	.LM118:
 1573 06f2 898D      		ldd r24,Y+25
 1574 06f4 8330      		cpi r24,lo8(3)
 1575 06f6 00F4      		brsh .L63
 1576 06f8 1FEF      		ldi r17,lo8(-1)
 1577 06fa 00C0      		rjmp .L64
 1578               	.L63:
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 1580               	.LM119:
 1581 06fc 83E0      		ldi r24,lo8(3)
 1582 06fe BE01      		movw r22,r28
 1583 0700 0E94 0000 		call cmdlineGetArgInt
 1584 0704 162F      		mov r17,r22
 1585               	.L64:
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 1587               	.LM120:
 1588 0706 8DB7      		in r24,__SP_L__
 1589 0708 9EB7      		in r25,__SP_H__
 1590 070a 0897      		sbiw r24,8
 1591 070c 0FB6      		in __tmp_reg__,__SREG__
 1592 070e F894      		cli
 1593 0710 9EBF      		out __SP_H__,r25
 1594 0712 0FBE      		out __SREG__,__tmp_reg__
 1595 0714 8DBF      		out __SP_L__,r24
 1596 0716 EDB7      		in r30,__SP_L__
 1597 0718 FEB7      		in r31,__SP_H__
 1598 071a 3196      		adiw r30,1
 1599 071c 8A8D      		ldd r24,Y+26
 1600 071e 9B8D      		ldd r25,Y+27
 1601 0720 ADB7      		in r26,__SP_L__
 1602 0722 BEB7      		in r27,__SP_H__
 1603 0724 1296      		adiw r26,1+1
 1604 0726 9C93      		st X,r25
 1605 0728 8E93      		st -X,r24
 1606 072a 1197      		sbiw r26,1
 1607 072c 80E0      		ldi r24,lo8(movingCurtainUpStr)
 1608 072e 90E0      		ldi r25,hi8(movingCurtainUpStr)
 1609 0730 9383      		std Z+3,r25
 1610 0732 8283      		std Z+2,r24
 1611 0734 F482      		std Z+4,r15
 1612 0736 1582      		std Z+5,__zero_reg__
 1613 0738 802F      		mov r24,r16
 1614 073a 90E0      		ldi r25,lo8(0)
 1615 073c 0196      		adiw r24,1
 1616 073e 9783      		std Z+7,r25
 1617 0740 8683      		std Z+6,r24
 1618 0742 0E94 0000 		call fprintf_P
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1620               	.LM121:
 1621 0746 812F      		mov r24,r17
 1622 0748 8150      		subi r24,lo8(-(-1))
 1623 074a 2DB7      		in r18,__SP_L__
 1624 074c 3EB7      		in r19,__SP_H__
 1625 074e 285F      		subi r18,lo8(-(8))
 1626 0750 3F4F      		sbci r19,hi8(-(8))
 1627 0752 0FB6      		in __tmp_reg__,__SREG__
 1628 0754 F894      		cli
 1629 0756 3EBF      		out __SP_H__,r19
 1630 0758 0FBE      		out __SREG__,__tmp_reg__
 1631 075a 2DBF      		out __SP_L__,r18
 1632 075c 8436      		cpi r24,lo8(100)
 1633 075e 00F4      		brsh .L65
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1635               	.LM122:
 1636 0760 00D0      		rcall .
 1637 0762 00D0      		rcall .
 1638 0764 00D0      		rcall .
 1639 0766 EDB7      		in r30,__SP_L__
 1640 0768 FEB7      		in r31,__SP_H__
 1641 076a 3196      		adiw r30,1
 1642 076c 8A8D      		ldd r24,Y+26
 1643 076e 9B8D      		ldd r25,Y+27
 1644 0770 ADB7      		in r26,__SP_L__
 1645 0772 BEB7      		in r27,__SP_H__
 1646 0774 1296      		adiw r26,1+1
 1647 0776 9C93      		st X,r25
 1648 0778 8E93      		st -X,r24
 1649 077a 1197      		sbiw r26,1
 1650 077c 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1651 077e 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1652 0780 9383      		std Z+3,r25
 1653 0782 8283      		std Z+2,r24
 1654 0784 1483      		std Z+4,r17
 1655 0786 1582      		std Z+5,__zero_reg__
 1656 0788 0E94 0000 		call fprintf_P
 1657 078c 2DB7      		in r18,__SP_L__
 1658 078e 3EB7      		in r19,__SP_H__
 1659 0790 2A5F      		subi r18,lo8(-(6))
 1660 0792 3F4F      		sbci r19,hi8(-(6))
 1661 0794 0FB6      		in __tmp_reg__,__SREG__
 1662 0796 F894      		cli
 1663 0798 3EBF      		out __SP_H__,r19
 1664 079a 0FBE      		out __SREG__,__tmp_reg__
 1665 079c 2DBF      		out __SP_L__,r18
 1666               	.L65:
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 1668               	.LM123:
 1669 079e 8F2D      		mov r24,r15
 1670 07a0 602F      		mov r22,r16
 1671 07a2 412F      		mov r20,r17
 1672 07a4 0E94 0000 		call rs485curtainUp
 549:vty.c         ****   if (result == 0)
 1674               	.LM124:
 1675 07a8 8823      		tst r24
 1676 07aa 01F0      		breq .L66
 1677 07ac 23E0      		ldi r18,lo8(3)
 1678 07ae 30E0      		ldi r19,hi8(3)
 1679 07b0 00C0      		rjmp .L62
 1680               	.L66:
 1681 07b2 21E0      		ldi r18,lo8(1)
 1682 07b4 30E0      		ldi r19,hi8(1)
 1683               	.L62:
 553:vty.c         **** }
 1685               	.LM125:
 1686 07b6 C901      		movw r24,r18
 1687               	/* epilogue start */
 1688 07b8 DF91      		pop r29
 1689 07ba CF91      		pop r28
 1690 07bc 1F91      		pop r17
 1691 07be 0F91      		pop r16
 1692 07c0 FF90      		pop r15
 1693 07c2 0895      		ret
 1700               	.Lscope18:
 1702               		.stabd	78,0,0
 1706               	goXmodemWyslijFunction:
 1707               		.stabd	46,0,0
 650:vty.c         **** {
 1709               	.LM126:
 1710               	.LFBB19:
 1711 07c4 0F93      		push r16
 1712 07c6 1F93      		push r17
 1713 07c8 CF93      		push r28
 1714 07ca DF93      		push r29
 1715               	/* prologue: function */
 1716               	/* frame size = 0 */
 1717 07cc EC01      		movw r28,r24
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 1719               	.LM127:
 1720 07ce 00D0      		rcall .
 1721 07d0 00D0      		rcall .
 1722 07d2 8A8D      		ldd r24,Y+26
 1723 07d4 9B8D      		ldd r25,Y+27
 1724 07d6 ADB7      		in r26,__SP_L__
 1725 07d8 BEB7      		in r27,__SP_H__
 1726 07da 1296      		adiw r26,1+1
 1727 07dc 9C93      		st X,r25
 1728 07de 8E93      		st -X,r24
 1729 07e0 1197      		sbiw r26,1
 1730 07e2 80E0      		ldi r24,lo8(xwyslijStartStr)
 1731 07e4 90E0      		ldi r25,hi8(xwyslijStartStr)
 1732 07e6 1496      		adiw r26,3+1
 1733 07e8 9C93      		st X,r25
 1734 07ea 8E93      		st -X,r24
 1735 07ec 1397      		sbiw r26,3
 1736 07ee 0E94 0000 		call fprintf_P
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1738               	.LM128:
 1739 07f2 0F90      		pop __tmp_reg__
 1740 07f4 0F90      		pop __tmp_reg__
 1741 07f6 0F90      		pop __tmp_reg__
 1742 07f8 0F90      		pop __tmp_reg__
 1743 07fa 81E0      		ldi r24,lo8(1)
 1744 07fc BE01      		movw r22,r28
 1745 07fe 0E94 0000 		call cmdlineGetArgStr
 1746 0802 60E0      		ldi r22,lo8(fdVty)
 1747 0804 70E0      		ldi r23,hi8(fdVty)
 1748 0806 0E94 0000 		call ramDyskOtworzPlik
 1749 080a 8823      		tst r24
 1750 080c 01F4      		brne .L69
 1751 080e 20E0      		ldi r18,lo8(0)
 1752 0810 30E0      		ldi r19,hi8(0)
 1753 0812 00C0      		rjmp .L70
 1754               	.L69:
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 1756               	.LM129:
 1757 0814 0A8D      		ldd r16,Y+26
 1758 0816 1B8D      		ldd r17,Y+27
 1759 0818 81E0      		ldi r24,lo8(1)
 1760 081a BE01      		movw r22,r28
 1761 081c 0E94 0000 		call cmdlineGetArgStr
 1762 0820 00D0      		rcall .
 1763 0822 00D0      		rcall .
 1764 0824 00D0      		rcall .
 1765 0826 EDB7      		in r30,__SP_L__
 1766 0828 FEB7      		in r31,__SP_H__
 1767 082a 3196      		adiw r30,1
 1768 082c ADB7      		in r26,__SP_L__
 1769 082e BEB7      		in r27,__SP_H__
 1770 0830 1296      		adiw r26,1+1
 1771 0832 1C93      		st X,r17
 1772 0834 0E93      		st -X,r16
 1773 0836 1197      		sbiw r26,1
 1774 0838 20E0      		ldi r18,lo8(errorOpenFile)
 1775 083a 30E0      		ldi r19,hi8(errorOpenFile)
 1776 083c 3383      		std Z+3,r19
 1777 083e 2283      		std Z+2,r18
 1778 0840 9583      		std Z+5,r25
 1779 0842 8483      		std Z+4,r24
 1780 0844 0E94 0000 		call fprintf_P
 1781 0848 24E0      		ldi r18,lo8(4)
 1782 084a 30E0      		ldi r19,hi8(4)
 1783 084c EDB7      		in r30,__SP_L__
 1784 084e FEB7      		in r31,__SP_H__
 1785 0850 3696      		adiw r30,6
 1786 0852 0FB6      		in __tmp_reg__,__SREG__
 1787 0854 F894      		cli
 1788 0856 FEBF      		out __SP_H__,r31
 1789 0858 0FBE      		out __SREG__,__tmp_reg__
 1790 085a EDBF      		out __SP_L__,r30
 1791               	.L70:
 658:vty.c         **** }
 1793               	.LM130:
 1794 085c C901      		movw r24,r18
 1795               	/* epilogue start */
 1796 085e DF91      		pop r29
 1797 0860 CF91      		pop r28
 1798 0862 1F91      		pop r17
 1799 0864 0F91      		pop r16
 1800 0866 0895      		ret
 1802               	.Lscope19:
 1804               		.stabd	78,0,0
 1808               	editRamFileFunction:
 1809               		.stabd	46,0,0
 876:vty.c         **** {
 1811               	.LM131:
 1812               	.LFBB20:
 1813 0868 EF92      		push r14
 1814 086a FF92      		push r15
 1815 086c 0F93      		push r16
 1816 086e 1F93      		push r17
 1817 0870 DF93      		push r29
 1818 0872 CF93      		push r28
 1819 0874 0F92      		push __tmp_reg__
 1820 0876 CDB7      		in r28,__SP_L__
 1821 0878 DEB7      		in r29,__SP_H__
 1822               	/* prologue: function */
 1823               	/* frame size = 1 */
 1824 087a 7C01      		movw r14,r24
 877:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1826               	.LM132:
 1827 087c 81E0      		ldi r24,lo8(1)
 1828 087e B701      		movw r22,r14
 1829 0880 0E94 0000 		call cmdlineGetArgStr
 1830 0884 60E0      		ldi r22,lo8(fdVty)
 1831 0886 70E0      		ldi r23,hi8(fdVty)
 1832 0888 0E94 0000 		call ramDyskOtworzPlik
 1833 088c 8823      		tst r24
 1834 088e 01F0      		breq .L73
 879:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 1836               	.LM133:
 1837 0890 D701      		movw r26,r14
 1838 0892 5A96      		adiw r26,26
 1839 0894 0D91      		ld r16,X+
 1840 0896 1C91      		ld r17,X
 1841 0898 5B97      		sbiw r26,26+1
 1842 089a 81E0      		ldi r24,lo8(1)
 1843 089c B701      		movw r22,r14
 1844 089e 0E94 0000 		call cmdlineGetArgStr
 1845 08a2 00D0      		rcall .
 1846 08a4 00D0      		rcall .
 1847 08a6 00D0      		rcall .
 1848 08a8 EDB7      		in r30,__SP_L__
 1849 08aa FEB7      		in r31,__SP_H__
 1850 08ac 3196      		adiw r30,1
 1851 08ae ADB7      		in r26,__SP_L__
 1852 08b0 BEB7      		in r27,__SP_H__
 1853 08b2 1296      		adiw r26,1+1
 1854 08b4 1C93      		st X,r17
 1855 08b6 0E93      		st -X,r16
 1856 08b8 1197      		sbiw r26,1
 1857 08ba 20E0      		ldi r18,lo8(errorOpenFile)
 1858 08bc 30E0      		ldi r19,hi8(errorOpenFile)
 1859 08be 3383      		std Z+3,r19
 1860 08c0 2283      		std Z+2,r18
 1861 08c2 9583      		std Z+5,r25
 1862 08c4 8483      		std Z+4,r24
 1863 08c6 0E94 0000 		call fprintf_P
 1864 08ca 24E0      		ldi r18,lo8(4)
 1865 08cc 30E0      		ldi r19,hi8(4)
 1866 08ce EDB7      		in r30,__SP_L__
 1867 08d0 FEB7      		in r31,__SP_H__
 1868 08d2 3696      		adiw r30,6
 1869 08d4 0FB6      		in __tmp_reg__,__SREG__
 1870 08d6 F894      		cli
 1871 08d8 FEBF      		out __SP_H__,r31
 1872 08da 0FBE      		out __SREG__,__tmp_reg__
 1873 08dc EDBF      		out __SP_L__,r30
 1874 08de 00C0      		rjmp .L74
 1875               	.L73:
 882:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 1877               	.LM134:
 1878 08e0 80E0      		ldi r24,lo8(fdVty)
 1879 08e2 90E0      		ldi r25,hi8(fdVty)
 1880 08e4 0E94 0000 		call ramDyskUstawWskaznikNaKoniec
 883:vty.c         ****   uint8_t znak = 0;
 1882               	.LM135:
 1883 08e8 1982      		std Y+1,__zero_reg__
 884:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 1885               	.LM136:
 1886 08ea 00D0      		rcall .
 1887 08ec 00D0      		rcall .
 1888 08ee D701      		movw r26,r14
 1889 08f0 5A96      		adiw r26,26
 1890 08f2 8D91      		ld r24,X+
 1891 08f4 9C91      		ld r25,X
 1892 08f6 5B97      		sbiw r26,26+1
 1893 08f8 EDB7      		in r30,__SP_L__
 1894 08fa FEB7      		in r31,__SP_H__
 1895 08fc 9283      		std Z+2,r25
 1896 08fe 8183      		std Z+1,r24
 1897 0900 80E0      		ldi r24,lo8(editRamFileIntroStr)
 1898 0902 90E0      		ldi r25,hi8(editRamFileIntroStr)
 1899 0904 9483      		std Z+4,r25
 1900 0906 8383      		std Z+3,r24
 1901 0908 0E94 0000 		call fprintf_P
 1902 090c 0F90      		pop __tmp_reg__
 1903 090e 0F90      		pop __tmp_reg__
 1904 0910 0F90      		pop __tmp_reg__
 1905 0912 0F90      		pop __tmp_reg__
 887:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 1907               	.LM137:
 1908 0914 7E01      		movw r14,r28
 1909 0916 0894      		sec
 1910 0918 E11C      		adc r14,__zero_reg__
 1911 091a F11C      		adc r15,__zero_reg__
 1912               	.L80:
 1913 091c 8091 0000 		lds r24,xVtyRec
 1914 0920 9091 0000 		lds r25,(xVtyRec)+1
 1915 0924 B701      		movw r22,r14
 1916 0926 4FEF      		ldi r20,lo8(-1)
 1917 0928 5FEF      		ldi r21,hi8(-1)
 1918 092a 20E0      		ldi r18,lo8(0)
 1919 092c 0E94 0000 		call xQueueGenericReceive
 1920 0930 8823      		tst r24
 1921 0932 01F0      		breq .L80
 890:vty.c         ****     if (znak == 0x03)                                       // ^C
 1923               	.LM138:
 1924 0934 8981      		ldd r24,Y+1
 1925 0936 8330      		cpi r24,lo8(3)
 1926 0938 01F0      		breq .L76
 893:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 1928               	.LM139:
 1929 093a 0E94 0000 		call uartVtySendByte
 894:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 1931               	.LM140:
 1932 093e 80E0      		ldi r24,lo8(fdVty)
 1933 0940 90E0      		ldi r25,hi8(fdVty)
 1934 0942 6981      		ldd r22,Y+1
 1935 0944 0E94 0000 		call ramDyskZapiszBajtDoPliku
 1936 0948 00C0      		rjmp .L80
 1937               	.L76:
 896:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 1939               	.LM141:
 1940 094a 80E0      		ldi r24,lo8(fdVty)
 1941 094c 90E0      		ldi r25,hi8(fdVty)
 1942 094e 0E94 0000 		call ramDyskZamknijPlik
 1943 0952 20E0      		ldi r18,lo8(0)
 1944 0954 30E0      		ldi r19,hi8(0)
 1945               	.L74:
 898:vty.c         **** }
 1947               	.LM142:
 1948 0956 C901      		movw r24,r18
 1949               	/* epilogue start */
 1950 0958 0F90      		pop __tmp_reg__
 1951 095a CF91      		pop r28
 1952 095c DF91      		pop r29
 1953 095e 1F91      		pop r17
 1954 0960 0F91      		pop r16
 1955 0962 FF90      		pop r15
 1956 0964 EF90      		pop r14
 1957 0966 0895      		ret
 1962               	.Lscope20:
 1964               		.stabd	78,0,0
 1968               	eraseRamFileFunction:
 1969               		.stabd	46,0,0
 848:vty.c         **** {
 1971               	.LM143:
 1972               	.LFBB21:
 1973 0968 CF93      		push r28
 1974 096a DF93      		push r29
 1975               	/* prologue: function */
 1976               	/* frame size = 0 */
 1977 096c EC01      		movw r28,r24
 849:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 1979               	.LM144:
 1980 096e 81E0      		ldi r24,lo8(1)
 1981 0970 BE01      		movw r22,r28
 1982 0972 0E94 0000 		call cmdlineGetArgStr
 1983 0976 0E94 0000 		call ramDyskUsunPlik
 1984 097a 8823      		tst r24
 1985 097c 01F4      		brne .L82
 1986 097e 21E0      		ldi r18,lo8(1)
 1987 0980 30E0      		ldi r19,hi8(1)
 1988 0982 00C0      		rjmp .L83
 1989               	.L82:
 852:vty.c         ****   printErrorInfo(state);
 1991               	.LM145:
 1992 0984 CE01      		movw r24,r28
 1993 0986 0E94 0000 		call printErrorInfo
 1994 098a 24E0      		ldi r18,lo8(4)
 1995 098c 30E0      		ldi r19,hi8(4)
 1996               	.L83:
 854:vty.c         **** }
 1998               	.LM146:
 1999 098e C901      		movw r24,r18
 2000               	/* epilogue start */
 2001 0990 DF91      		pop r29
 2002 0992 CF91      		pop r28
 2003 0994 0895      		ret
 2005               	.Lscope21:
 2007               		.stabd	78,0,0
 2011               	dodajRamPlikFunction:
 2012               		.stabd	46,0,0
 857:vty.c         **** {
 2014               	.LM147:
 2015               	.LFBB22:
 2016 0996 CF93      		push r28
 2017 0998 DF93      		push r29
 2018               	/* prologue: function */
 2019               	/* frame size = 0 */
 2020 099a EC01      		movw r28,r24
 858:vty.c         ****   if (state->argc != 1)
 2022               	.LM148:
 2023 099c 898D      		ldd r24,Y+25
 2024 099e 8130      		cpi r24,lo8(1)
 2025 09a0 01F0      		breq .L86
 2026 09a2 22E0      		ldi r18,lo8(2)
 2027 09a4 30E0      		ldi r19,hi8(2)
 2028 09a6 00C0      		rjmp .L87
 2029               	.L86:
 861:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 2031               	.LM149:
 2032 09a8 81E0      		ldi r24,lo8(1)
 2033 09aa BE01      		movw r22,r28
 2034 09ac 0E94 0000 		call cmdlineGetArgStr
 2035 09b0 0E94 0000 		call ramDyskUtworzPlik
 2036 09b4 8823      		tst r24
 2037 09b6 01F4      		brne .L88
 2038 09b8 21E0      		ldi r18,lo8(1)
 2039 09ba 30E0      		ldi r19,hi8(1)
 2040 09bc 00C0      		rjmp .L87
 2041               	.L88:
 865:vty.c         ****   printErrorInfo(state);
 2043               	.LM150:
 2044 09be CE01      		movw r24,r28
 2045 09c0 0E94 0000 		call printErrorInfo
 2046 09c4 24E0      		ldi r18,lo8(4)
 2047 09c6 30E0      		ldi r19,hi8(4)
 2048               	.L87:
 867:vty.c         **** }
 2050               	.LM151:
 2051 09c8 C901      		movw r24,r18
 2052               	/* epilogue start */
 2053 09ca DF91      		pop r29
 2054 09cc CF91      		pop r28
 2055 09ce 0895      		ret
 2057               	.Lscope22:
 2059               		.stabd	78,0,0
 2063               	rpingFunction:
 2064               		.stabd	46,0,0
 584:vty.c         **** {
 2066               	.LM152:
 2067               	.LFBB23:
 2068 09d0 1F93      		push r17
 2069 09d2 CF93      		push r28
 2070 09d4 DF93      		push r29
 2071               	/* prologue: function */
 2072               	/* frame size = 0 */
 2073 09d6 EC01      		movw r28,r24
 585:vty.c         ****   if (state->argc < 1)
 2075               	.LM153:
 2076 09d8 898D      		ldd r24,Y+25
 2077 09da 8823      		tst r24
 2078 09dc 01F4      		brne .L91
 2079 09de 22E0      		ldi r18,lo8(2)
 2080 09e0 30E0      		ldi r19,hi8(2)
 2081 09e2 00C0      		rjmp .L92
 2082               	.L91:
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 2084               	.LM154:
 2085 09e4 81E0      		ldi r24,lo8(1)
 2086 09e6 BE01      		movw r22,r28
 2087 09e8 0E94 0000 		call cmdlineGetArgInt
 2088 09ec 162F      		mov r17,r22
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 2090               	.LM155:
 2091 09ee 862F      		mov r24,r22
 2092 09f0 0E94 0000 		call rs485ping
 2093 09f4 8F8F      		std Y+31,r24
 2094 09f6 8823      		tst r24
 2095 09f8 01F4      		brne .L93
 2096 09fa 21E0      		ldi r18,lo8(1)
 2097 09fc 30E0      		ldi r19,hi8(1)
 2098 09fe 00C0      		rjmp .L92
 2099               	.L93:
 592:vty.c         ****   state->errno = noRemoteDevice;
 2101               	.LM156:
 2102 0a00 89E0      		ldi r24,lo8(9)
 2103 0a02 8C8F      		std Y+28,r24
 593:vty.c         ****   state->err1 = nrSterownika;
 2105               	.LM157:
 2106 0a04 1D8F      		std Y+29,r17
 2107 0a06 1E8E      		std Y+30,__zero_reg__
 594:vty.c         ****   printErrorInfo(state);
 2109               	.LM158:
 2110 0a08 CE01      		movw r24,r28
 2111 0a0a 0E94 0000 		call printErrorInfo
 2112 0a0e 20E0      		ldi r18,lo8(0)
 2113 0a10 30E0      		ldi r19,hi8(0)
 2114               	.L92:
 596:vty.c         **** }
 2116               	.LM159:
 2117 0a12 C901      		movw r24,r18
 2118               	/* epilogue start */
 2119 0a14 DF91      		pop r29
 2120 0a16 CF91      		pop r28
 2121 0a18 1F91      		pop r17
 2122 0a1a 0895      		ret
 2124               	.Lscope23:
 2126               		.stabd	78,0,0
 2130               	flashExModuleFunction:
 2131               		.stabd	46,0,0
 616:vty.c         **** {
 2133               	.LM160:
 2134               	.LFBB24:
 2135 0a1c FF92      		push r15
 2136 0a1e 0F93      		push r16
 2137 0a20 1F93      		push r17
 2138 0a22 CF93      		push r28
 2139 0a24 DF93      		push r29
 2140               	/* prologue: function */
 2141               	/* frame size = 0 */
 2142 0a26 EC01      		movw r28,r24
 617:vty.c         ****   if (state->argc != 2)
 2144               	.LM161:
 2145 0a28 898D      		ldd r24,Y+25
 2146 0a2a 8230      		cpi r24,lo8(2)
 2147 0a2c 01F0      		breq .L96
 2148 0a2e 22E0      		ldi r18,lo8(2)
 2149 0a30 30E0      		ldi r19,hi8(2)
 2150 0a32 00C0      		rjmp .L97
 2151               	.L96:
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 2153               	.LM162:
 2154 0a34 81E0      		ldi r24,lo8(1)
 2155 0a36 BE01      		movw r22,r28
 2156 0a38 0E94 0000 		call cmdlineGetArgInt
 2157 0a3c F62E      		mov r15,r22
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 2159               	.LM163:
 2160 0a3e 82E0      		ldi r24,lo8(2)
 2161 0a40 BE01      		movw r22,r28
 2162 0a42 0E94 0000 		call cmdlineGetArgStr
 2163 0a46 8C01      		movw r16,r24
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 2165               	.LM164:
 2166 0a48 8F2D      		mov r24,r15
 2167 0a4a 0E94 0000 		call rs485ping
 2168 0a4e 8823      		tst r24
 2169 0a50 01F0      		breq .L98
 627:vty.c         ****     state->errno = noRemoteDevice;
 2171               	.LM165:
 2172 0a52 89E0      		ldi r24,lo8(9)
 2173 0a54 8C8F      		std Y+28,r24
 628:vty.c         ****     printErrorInfo(state);
 2175               	.LM166:
 2176 0a56 CE01      		movw r24,r28
 2177 0a58 0E94 0000 		call printErrorInfo
 2178 0a5c 00C0      		rjmp .L100
 2179               	.L98:
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 2181               	.LM167:
 2182 0a5e C801      		movw r24,r16
 2183 0a60 60E0      		ldi r22,lo8(fdVty)
 2184 0a62 70E0      		ldi r23,hi8(fdVty)
 2185 0a64 0E94 0000 		call ramDyskOtworzPlik
 2186 0a68 4A8D      		ldd r20,Y+26
 2187 0a6a 5B8D      		ldd r21,Y+27
 2188 0a6c 8823      		tst r24
 2189 0a6e 01F0      		breq .L99
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 2191               	.LM168:
 2192 0a70 00D0      		rcall .
 2193 0a72 00D0      		rcall .
 2194 0a74 00D0      		rcall .
 2195 0a76 EDB7      		in r30,__SP_L__
 2196 0a78 FEB7      		in r31,__SP_H__
 2197 0a7a 3196      		adiw r30,1
 2198 0a7c ADB7      		in r26,__SP_L__
 2199 0a7e BEB7      		in r27,__SP_H__
 2200 0a80 1296      		adiw r26,1+1
 2201 0a82 5C93      		st X,r21
 2202 0a84 4E93      		st -X,r20
 2203 0a86 1197      		sbiw r26,1
 2204 0a88 80E0      		ldi r24,lo8(errorOpenFile)
 2205 0a8a 90E0      		ldi r25,hi8(errorOpenFile)
 2206 0a8c 9383      		std Z+3,r25
 2207 0a8e 8283      		std Z+2,r24
 2208 0a90 1583      		std Z+5,r17
 2209 0a92 0483      		std Z+4,r16
 2210 0a94 0E94 0000 		call fprintf_P
 2211 0a98 24E0      		ldi r18,lo8(4)
 2212 0a9a 30E0      		ldi r19,hi8(4)
 2213 0a9c 8DB7      		in r24,__SP_L__
 2214 0a9e 9EB7      		in r25,__SP_H__
 2215 0aa0 0696      		adiw r24,6
 2216 0aa2 0FB6      		in __tmp_reg__,__SREG__
 2217 0aa4 F894      		cli
 2218 0aa6 9EBF      		out __SP_H__,r25
 2219 0aa8 0FBE      		out __SREG__,__tmp_reg__
 2220 0aaa 8DBF      		out __SP_L__,r24
 2221 0aac 00C0      		rjmp .L97
 2222               	.L99:
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 2224               	.LM169:
 2225 0aae 80E0      		ldi r24,lo8(fdVty)
 2226 0ab0 90E0      		ldi r25,hi8(fdVty)
 2227 0ab2 6F2D      		mov r22,r15
 2228 0ab4 0E94 0000 		call rs485xModemFlash
 2229 0ab8 182F      		mov r17,r24
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2231               	.LM170:
 2232 0aba 80E0      		ldi r24,lo8(fdVty)
 2233 0abc 90E0      		ldi r25,hi8(fdVty)
 2234 0abe 0E94 0000 		call ramDyskZamknijPlik
 643:vty.c         ****   if (blad != 0)
 2236               	.LM171:
 2237 0ac2 1123      		tst r17
 2238 0ac4 01F4      		brne .L100
 2239 0ac6 20E0      		ldi r18,lo8(0)
 2240 0ac8 30E0      		ldi r19,hi8(0)
 2241 0aca 00C0      		rjmp .L97
 2242               	.L100:
 2243 0acc 24E0      		ldi r18,lo8(4)
 2244 0ace 30E0      		ldi r19,hi8(4)
 2245               	.L97:
 647:vty.c         **** }
 2247               	.LM172:
 2248 0ad0 C901      		movw r24,r18
 2249               	/* epilogue start */
 2250 0ad2 DF91      		pop r29
 2251 0ad4 CF91      		pop r28
 2252 0ad6 1F91      		pop r17
 2253 0ad8 0F91      		pop r16
 2254 0ada FF90      		pop r15
 2255 0adc 0895      		ret
 2261               	.Lscope24:
 2263               		.stabd	78,0,0
 2267               	goXmodemOdbierzFunction:
 2268               		.stabd	46,0,0
 661:vty.c         **** {
 2270               	.LM173:
 2271               	.LFBB25:
 2272 0ade 2F92      		push r2
 2273 0ae0 3F92      		push r3
 2274 0ae2 4F92      		push r4
 2275 0ae4 5F92      		push r5
 2276 0ae6 6F92      		push r6
 2277 0ae8 7F92      		push r7
 2278 0aea 8F92      		push r8
 2279 0aec 9F92      		push r9
 2280 0aee AF92      		push r10
 2281 0af0 BF92      		push r11
 2282 0af2 CF92      		push r12
 2283 0af4 DF92      		push r13
 2284 0af6 EF92      		push r14
 2285 0af8 FF92      		push r15
 2286 0afa 0F93      		push r16
 2287 0afc 1F93      		push r17
 2288 0afe DF93      		push r29
 2289 0b00 CF93      		push r28
 2290 0b02 00D0      		rcall .
 2291 0b04 00D0      		rcall .
 2292 0b06 00D0      		rcall .
 2293 0b08 CDB7      		in r28,__SP_L__
 2294 0b0a DEB7      		in r29,__SP_H__
 2295               	/* prologue: function */
 2296               	/* frame size = 6 */
 2297 0b0c 7C01      		movw r14,r24
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 2299               	.LM174:
 2300 0b0e 00D0      		rcall .
 2301 0b10 00D0      		rcall .
 2302 0b12 DC01      		movw r26,r24
 2303 0b14 5A96      		adiw r26,26
 2304 0b16 8D91      		ld r24,X+
 2305 0b18 9C91      		ld r25,X
 2306 0b1a 5B97      		sbiw r26,26+1
 2307 0b1c EDB7      		in r30,__SP_L__
 2308 0b1e FEB7      		in r31,__SP_H__
 2309 0b20 9283      		std Z+2,r25
 2310 0b22 8183      		std Z+1,r24
 2311 0b24 80E0      		ldi r24,lo8(__c.3535)
 2312 0b26 90E0      		ldi r25,hi8(__c.3535)
 2313 0b28 9483      		std Z+4,r25
 2314 0b2a 8383      		std Z+3,r24
 2315 0b2c 0E94 0000 		call fprintf_P
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 2317               	.LM175:
 2318 0b30 0F90      		pop __tmp_reg__
 2319 0b32 0F90      		pop __tmp_reg__
 2320 0b34 0F90      		pop __tmp_reg__
 2321 0b36 0F90      		pop __tmp_reg__
 2322 0b38 81E0      		ldi r24,lo8(1)
 2323 0b3a B701      		movw r22,r14
 2324 0b3c 0E94 0000 		call cmdlineGetArgStr
 2325 0b40 60E0      		ldi r22,lo8(fdVty)
 2326 0b42 70E0      		ldi r23,hi8(fdVty)
 2327 0b44 0E94 0000 		call ramDyskOtworzPlik
 2328 0b48 8823      		tst r24
 2329 0b4a 01F0      		breq .L103
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 2331               	.LM176:
 2332 0b4c D701      		movw r26,r14
 2333 0b4e 5A96      		adiw r26,26
 2334 0b50 0D91      		ld r16,X+
 2335 0b52 1C91      		ld r17,X
 2336 0b54 5B97      		sbiw r26,26+1
 2337 0b56 81E0      		ldi r24,lo8(1)
 2338 0b58 B701      		movw r22,r14
 2339 0b5a 0E94 0000 		call cmdlineGetArgStr
 2340 0b5e 00D0      		rcall .
 2341 0b60 00D0      		rcall .
 2342 0b62 00D0      		rcall .
 2343 0b64 EDB7      		in r30,__SP_L__
 2344 0b66 FEB7      		in r31,__SP_H__
 2345 0b68 3196      		adiw r30,1
 2346 0b6a ADB7      		in r26,__SP_L__
 2347 0b6c BEB7      		in r27,__SP_H__
 2348 0b6e 1296      		adiw r26,1+1
 2349 0b70 1C93      		st X,r17
 2350 0b72 0E93      		st -X,r16
 2351 0b74 1197      		sbiw r26,1
 2352 0b76 20E0      		ldi r18,lo8(errorOpenFile)
 2353 0b78 30E0      		ldi r19,hi8(errorOpenFile)
 2354 0b7a 3383      		std Z+3,r19
 2355 0b7c 2283      		std Z+2,r18
 2356 0b7e 9583      		std Z+5,r25
 2357 0b80 8483      		std Z+4,r24
 2358 0b82 0E94 0000 		call fprintf_P
 2359 0b86 24E0      		ldi r18,lo8(4)
 2360 0b88 30E0      		ldi r19,hi8(4)
 2361 0b8a EDB7      		in r30,__SP_L__
 2362 0b8c FEB7      		in r31,__SP_H__
 2363 0b8e 3696      		adiw r30,6
 2364 0b90 0FB6      		in __tmp_reg__,__SREG__
 2365 0b92 F894      		cli
 2366 0b94 FEBF      		out __SP_H__,r31
 2367 0b96 0FBE      		out __SREG__,__tmp_reg__
 2368 0b98 EDBF      		out __SP_L__,r30
 2369 0b9a 00C0      		rjmp .L104
 2370               	.L103:
 688:vty.c         ****   state->err1=0;
 2372               	.LM177:
 2373 0b9c D701      		movw r26,r14
 2374 0b9e 5E96      		adiw r26,29+1
 2375 0ba0 1C92      		st X,__zero_reg__
 2376 0ba2 1E92      		st -X,__zero_reg__
 2377 0ba4 5D97      		sbiw r26,29
 689:vty.c         ****   state->err2=0;
 2379               	.LM178:
 2380 0ba6 5F96      		adiw r26,31
 2381 0ba8 1C92      		st X,__zero_reg__
 2382 0baa 04E1      		ldi r16,lo8(20)
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2384               	.LM179:
 2385 0bac B2E0      		ldi r27,lo8(2)
 2386 0bae CB2E      		mov r12,r27
 2387 0bb0 D12C      		mov r13,__zero_reg__
 2388 0bb2 CC0E      		add r12,r28
 2389 0bb4 DD1E      		adc r13,r29
 2390               	.L108:
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 2392               	.LM180:
 2393 0bb6 F701      		movw r30,r14
 2394 0bb8 628D      		ldd r22,Z+26
 2395 0bba 738D      		ldd r23,Z+27
 2396 0bbc 83E4      		ldi r24,lo8(67)
 2397 0bbe 90E0      		ldi r25,hi8(67)
 2398 0bc0 0E94 0000 		call fputc
 2399               	.L105:
 694:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 2401               	.LM181:
 2402 0bc4 8091 9B00 		lds r24,155
 2403 0bc8 86FF      		sbrs r24,6
 2404 0bca 00C0      		rjmp .L105
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2406               	.LM182:
 2407 0bcc 8091 0000 		lds r24,xVtyRec
 2408 0bd0 9091 0000 		lds r25,(xVtyRec)+1
 2409 0bd4 B601      		movw r22,r12
 2410 0bd6 44E6      		ldi r20,lo8(100)
 2411 0bd8 50E0      		ldi r21,hi8(100)
 2412 0bda 20E0      		ldi r18,lo8(0)
 2413 0bdc 0E94 0000 		call xQueueGenericReceive
 2414 0be0 8823      		tst r24
 2415 0be2 01F0      		breq .L106
 697:vty.c         ****       if (c == SOH)
 2417               	.LM183:
 2418 0be4 8A81      		ldd r24,Y+2
 2419 0be6 8130      		cpi r24,lo8(1)
 2420 0be8 01F0      		breq .L107
 2421               	.L106:
 700:vty.c         ****     liczbaProb--;
 2423               	.LM184:
 2424 0bea 0150      		subi r16,lo8(-(-1))
 701:vty.c         ****     if (liczbaProb == 0)
 2426               	.LM185:
 2427 0bec 01F4      		brne .L108
 703:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 2429               	.LM186:
 2430 0bee 80E0      		ldi r24,lo8(fdVty)
 2431 0bf0 90E0      		ldi r25,hi8(fdVty)
 2432 0bf2 0E94 0000 		call ramDyskZamknijPlik
 704:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2434               	.LM187:
 2435 0bf6 D701      		movw r26,r14
 2436 0bf8 5C96      		adiw r26,28
 2437 0bfa 1C92      		st X,__zero_reg__
 2438 0bfc 24E0      		ldi r18,lo8(4)
 2439 0bfe 30E0      		ldi r19,hi8(4)
 2440 0c00 00C0      		rjmp .L104
 2441               	.L107:
 712:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2443               	.LM188:
 2444 0c02 80E0      		ldi r24,lo8(fdVty)
 2445 0c04 90E0      		ldi r25,hi8(fdVty)
 2446 0c06 61E0      		ldi r22,lo8(1)
 2447 0c08 70E0      		ldi r23,hi8(1)
 2448 0c0a 0E94 0000 		call ramDyskDodajBlokXmodem
 2449 0c0e 6C01      		movw r12,r24
 2450 0c10 5C01      		movw r10,r24
 2451 0c12 AAE0      		ldi r26,lo8(10)
 2452 0c14 9A2E      		mov r9,r26
 2453 0c16 11E0      		ldi r17,lo8(1)
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2455               	.LM189:
 2456 0c18 F3E0      		ldi r31,lo8(3)
 2457 0c1a 8F2E      		mov r8,r31
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 2459               	.LM190:
 2460 0c1c E5E0      		ldi r30,lo8(5)
 2461 0c1e 2E2E      		mov r2,r30
 2462 0c20 312C      		mov r3,__zero_reg__
 2463 0c22 2C0E      		add r2,r28
 2464 0c24 3D1E      		adc r3,r29
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2466               	.LM191:
 2467 0c26 76E0      		ldi r23,lo8(6)
 2468 0c28 472E      		mov r4,r23
 2469 0c2a 512C      		mov r5,__zero_reg__
 2470 0c2c 4C0E      		add r4,r28
 2471 0c2e 5D1E      		adc r5,r29
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2473               	.LM192:
 2474 0c30 3E01      		movw r6,r28
 2475 0c32 0894      		sec
 2476 0c34 611C      		adc r6,__zero_reg__
 2477 0c36 711C      		adc r7,__zero_reg__
 2478               	.L126:
 716:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 2480               	.LM193:
 2481 0c38 8091 0000 		lds r24,xVtyRec
 2482 0c3c 9091 0000 		lds r25,(xVtyRec)+1
 2483 0c40 BE01      		movw r22,r28
 2484 0c42 6D5F      		subi r22,lo8(-(3))
 2485 0c44 7F4F      		sbci r23,hi8(-(3))
 2486 0c46 44E6      		ldi r20,lo8(100)
 2487 0c48 50E0      		ldi r21,hi8(100)
 2488 0c4a 20E0      		ldi r18,lo8(0)
 2489 0c4c 0E94 0000 		call xQueueGenericReceive
 2490 0c50 8823      		tst r24
 2491 0c52 01F4      		brne .+2
 2492 0c54 00C0      		rjmp .L135
 2493               	.L109:
 722:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 2495               	.LM194:
 2496 0c56 8091 0000 		lds r24,xVtyRec
 2497 0c5a 9091 0000 		lds r25,(xVtyRec)+1
 2498 0c5e BE01      		movw r22,r28
 2499 0c60 6C5F      		subi r22,lo8(-(4))
 2500 0c62 7F4F      		sbci r23,hi8(-(4))
 2501 0c64 41E0      		ldi r20,lo8(1)
 2502 0c66 50E0      		ldi r21,hi8(1)
 2503 0c68 20E0      		ldi r18,lo8(0)
 2504 0c6a 0E94 0000 		call xQueueGenericReceive
 2505 0c6e 8823      		tst r24
 2506 0c70 01F4      		brne .L111
 724:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 2508               	.LM195:
 2509 0c72 83E0      		ldi r24,lo8(3)
 2510 0c74 D701      		movw r26,r14
 2511 0c76 00C0      		rjmp .L136
 2512               	.L111:
 729:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 2514               	.LM196:
 2515 0c78 9C81      		ldd r25,Y+4
 2516 0c7a 892F      		mov r24,r25
 2517 0c7c 8095      		com r24
 2518 0c7e 8A83      		std Y+2,r24
 730:vty.c         ****     if (nrBlokuZdalny != c)
 2520               	.LM197:
 2521 0c80 0B81      		ldd r16,Y+3
 2522 0c82 0817      		cp r16,r24
 2523 0c84 01F0      		breq .L112
 732:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 2525               	.LM198:
 2526 0c86 85E0      		ldi r24,lo8(5)
 2527 0c88 F701      		movw r30,r14
 2528 0c8a 848F      		std Z+28,r24
 733:vty.c         ****       state->err1 = nrBlokuZdalny;
 2530               	.LM199:
 2531 0c8c 058F      		std Z+29,r16
 2532 0c8e 168E      		std Z+30,__zero_reg__
 734:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 2534               	.LM200:
 2535 0c90 978F      		std Z+31,r25
 2536 0c92 00C0      		rjmp .L110
 2537               	.L112:
 739:vty.c         ****     c = nrBloku-1;
 2539               	.LM201:
 2540 0c94 812F      		mov r24,r17
 2541 0c96 8150      		subi r24,lo8(-(-1))
 2542 0c98 8A83      		std Y+2,r24
 740:vty.c         ****     if (nrBlokuZdalny == c)
 2544               	.LM202:
 2545 0c9a 0817      		cp r16,r24
 2546 0c9c 01F0      		breq .L113
 2547 0c9e 012F      		mov r16,r17
 2548 0ca0 00C0      		rjmp .L114
 2549               	.L113:
 743:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2551               	.LM203:
 2552 0ca2 80E0      		ldi r24,lo8(fdVty)
 2553 0ca4 90E0      		ldi r25,hi8(fdVty)
 2554 0ca6 602F      		mov r22,r16
 2555 0ca8 70E0      		ldi r23,lo8(0)
 2556 0caa 0E94 0000 		call ramDyskDodajBlokXmodem
 2557 0cae 6C01      		movw r12,r24
 2558 0cb0 5C01      		movw r10,r24
 2559               	.L114:
 748:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 2561               	.LM204:
 2562 0cb2 1B81      		ldd r17,Y+3
 2563 0cb4 1017      		cp r17,r16
 2564 0cb6 01F0      		breq .L115
 750:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2566               	.LM205:
 2567 0cb8 84E0      		ldi r24,lo8(4)
 2568 0cba D701      		movw r26,r14
 2569 0cbc 5C96      		adiw r26,28
 2570 0cbe 8C93      		st X,r24
 2571 0cc0 5C97      		sbiw r26,28
 751:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 2573               	.LM206:
 2574 0cc2 8C81      		ldd r24,Y+4
 2575 0cc4 5D96      		adiw r26,29
 2576 0cc6 8C93      		st X,r24
 2577 0cc8 5D97      		sbiw r26,29
 2578 0cca 5E96      		adiw r26,30
 2579 0ccc 1C92      		st X,__zero_reg__
 2580 0cce 5E97      		sbiw r26,30
 752:vty.c         ****       state->err2 = nrBloku;
 2582               	.LM207:
 2583 0cd0 5F96      		adiw r26,31
 2584 0cd2 0C93      		st X,r16
 2585 0cd4 00C0      		rjmp .L110
 2586               	.L115:
 753:vty.c         ****       break;
 2588               	.LM208:
 2589 0cd6 00E0      		ldi r16,lo8(0)
 2590               	.L117:
 758:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 2592               	.LM209:
 2593 0cd8 8091 0000 		lds r24,xVtyRec
 2594 0cdc 9091 0000 		lds r25,(xVtyRec)+1
 2595 0ce0 BE01      		movw r22,r28
 2596 0ce2 6E5F      		subi r22,lo8(-(2))
 2597 0ce4 7F4F      		sbci r23,hi8(-(2))
 2598 0ce6 4AE0      		ldi r20,lo8(10)
 2599 0ce8 50E0      		ldi r21,hi8(10)
 2600 0cea 20E0      		ldi r18,lo8(0)
 2601 0cec 0E94 0000 		call xQueueGenericReceive
 2602 0cf0 8823      		tst r24
 2603 0cf2 01F0      		breq .L116
 759:vty.c         ****         *(zapPtr++) = c;
 2605               	.LM210:
 2606 0cf4 8A81      		ldd r24,Y+2
 2607 0cf6 F601      		movw r30,r12
 2608 0cf8 8193      		st Z+,r24
 2609 0cfa 6F01      		movw r12,r30
 756:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2611               	.LM211:
 2612 0cfc 0F5F      		subi r16,lo8(-(1))
 2613 0cfe 0038      		cpi r16,lo8(-128)
 2614 0d00 01F4      		brne .L117
 2615 0d02 00C0      		rjmp .L118
 2616               	.L116:
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2618               	.LM212:
 2619 0d04 D701      		movw r26,r14
 2620 0d06 5C96      		adiw r26,28
 2621 0d08 8C92      		st X,r8
 2622               	.L118:
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 2624               	.LM213:
 2625 0d0a 8091 0000 		lds r24,xVtyRec
 2626 0d0e 9091 0000 		lds r25,(xVtyRec)+1
 2627 0d12 B101      		movw r22,r2
 2628 0d14 4AE0      		ldi r20,lo8(10)
 2629 0d16 50E0      		ldi r21,hi8(10)
 2630 0d18 20E0      		ldi r18,lo8(0)
 2631 0d1a 0E94 0000 		call xQueueGenericReceive
 2632 0d1e 8823      		tst r24
 2633 0d20 01F4      		brne .L119
 768:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2635               	.LM214:
 2636 0d22 86E0      		ldi r24,lo8(6)
 2637 0d24 F701      		movw r30,r14
 2638 0d26 848F      		std Z+28,r24
 769:vty.c         ****         state->err1 = 2;
 2640               	.LM215:
 2641 0d28 82E0      		ldi r24,lo8(2)
 2642 0d2a 90E0      		ldi r25,hi8(2)
 2643 0d2c 968F      		std Z+30,r25
 2644 0d2e 858F      		std Z+29,r24
 2645 0d30 00C0      		rjmp .L110
 2646               	.L119:
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2648               	.LM216:
 2649 0d32 8091 0000 		lds r24,xVtyRec
 2650 0d36 9091 0000 		lds r25,(xVtyRec)+1
 2651 0d3a B201      		movw r22,r4
 2652 0d3c 4AE0      		ldi r20,lo8(10)
 2653 0d3e 50E0      		ldi r21,hi8(10)
 2654 0d40 20E0      		ldi r18,lo8(0)
 2655 0d42 0E94 0000 		call xQueueGenericReceive
 2656 0d46 8823      		tst r24
 2657 0d48 01F4      		brne .L120
 774:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2659               	.LM217:
 2660 0d4a 86E0      		ldi r24,lo8(6)
 2661 0d4c D701      		movw r26,r14
 2662 0d4e 5C96      		adiw r26,28
 2663 0d50 8C93      		st X,r24
 2664 0d52 5C97      		sbiw r26,28
 775:vty.c         ****         state->err1 = 1;
 2666               	.LM218:
 2667 0d54 81E0      		ldi r24,lo8(1)
 2668 0d56 90E0      		ldi r25,hi8(1)
 2669 0d58 5E96      		adiw r26,29+1
 2670 0d5a 9C93      		st X,r25
 2671 0d5c 8E93      		st -X,r24
 2672 0d5e 5D97      		sbiw r26,29
 2673 0d60 00C0      		rjmp .L110
 2674               	.L120:
 776:vty.c         ****         break;      
 2676               	.LM219:
 2677 0d62 90E0      		ldi r25,lo8(0)
 2678 0d64 40E0      		ldi r20,lo8(0)
 2679 0d66 50E0      		ldi r21,hi8(0)
 2680               	.L121:
 784:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 2682               	.LM220:
 2683 0d68 F501      		movw r30,r10
 2684 0d6a 8191      		ld r24,Z+
 2685 0d6c 5F01      		movw r10,r30
 2686               	.LBB6:
 2687               	.LBB7:
 2689               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
   5:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
   8:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  11:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  16:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  20:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  32:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /* $Id: crc16.h,v 1.4 2007/01/23 15:32:48 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  34:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  35:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  36:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  37:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #include <stdint.h>
  38:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  39:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \file */
  40:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  41:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  42:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  43:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  44:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  45:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  46:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par References:
  47:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  48:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par
  49:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  50:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  51:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  52:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  53:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  54:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par
  55:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  56:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  57:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  58:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  59:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     obtain a copy.
  60:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  61:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     A typical application would look like:
  62:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  63:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
  64:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     // Dallas iButton test vector.
  65:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  66:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  67:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     int
  68:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     checkcrc(void)
  69:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
  70:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  71:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  72:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  73:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  74:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  75:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return crc; // must be 0
  76:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
  77:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode
  78:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** */
  79:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  80:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
  81:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  82:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  83:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  84:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Initial value: 0xffff
  85:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  86:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  87:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  88:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  89:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  90:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
  91:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t
  92:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  93:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
  94:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	int i;
  95:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  96:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	crc ^= a;
  97:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
  98:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	{
  99:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    if (crc & 1)
 100:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 101:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    else
 102:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1);
 103:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	}
 104:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 105:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return crc;
 106:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
 107:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 108:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode */
 109:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 110:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 111:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 112:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** {
 113:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint8_t __tmp;
 114:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint16_t __ret;
 115:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 116:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 117:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 118:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 119:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 120:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 121:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 122:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 123:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 124:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 125:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 126:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 127:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 128:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 129:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 130:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 131:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 132:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 133:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 134:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 135:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 136:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 137:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 138:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 139:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%1"
 140:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 141:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 142:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "r0"
 143:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	);
 144:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return __ret;
 145:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** }
 146:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 147:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
 148:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 149:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 150:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 151:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Initial value: 0x0
 152:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 153:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 154:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 155:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 156:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 157:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
 158:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t
 159:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 160:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
 161:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         int i;
 162:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 163:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 164:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 165:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         {
 166:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****             if (crc & 0x8000)
 167:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 168:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****             else
 169:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                 crc <<= 1;
 170:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         }
 171:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 172:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         return crc;
 173:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
 174:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode */
 175:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 176:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 177:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 178:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** {
 179:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 180:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 181:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 182:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                                 /* %3  __data */
 183:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 184:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     __asm__ __volatile__ (
 2691               	.LM221:
 2692               	/* #APP */
 2693               	 ;  184 "/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h" 1
 2694 0d6e 5827      		eor    r21,r24
 2695 0d70 052E      		mov    __tmp_reg__,r21
 2696 0d72 0294      		swap   __tmp_reg__
 2697 0d74 802D      		mov    r24,__tmp_reg__
 2698 0d76 8F70      		andi   r24,0x0f
 2699 0d78 8527      		eor    r24,r21
 2700 0d7a 252F      		mov    r18,r21
 2701 0d7c 2025      		eor    r18,__tmp_reg__
 2702 0d7e 220F      		lsl    r18
 2703 0d80 207E      		andi   r18,0xe0
 2704 0d82 8227      		eor    r24,r18
 2705 0d84 202D      		mov    r18,__tmp_reg__
 2706 0d86 2527      		eor    r18,r21
 2707 0d88 207F      		andi   r18,0xf0
 2708 0d8a 2695      		lsr    r18
 2709 0d8c 052E      		mov    __tmp_reg__,r21
 2710 0d8e 000C      		lsl    __tmp_reg__
 2711 0d90 221F      		rol    r18
 2712 0d92 5695      		lsr    r21
 2713 0d94 5695      		lsr    r21
 2714 0d96 5695      		lsr    r21
 2715 0d98 5F71      		andi   r21,0x1f
 2716 0d9a 5227      		eor    r21,r18
 2717 0d9c 5427      		eor    r21,r20
 2718 0d9e 482F      		mov    r20,r24
 2719               		
 2720               	 ;  0 "" 2
 2721               	/* #NOAPP */
 2722               	.LBE7:
 2723               	.LBE6:
 2725               	.Ltext2:
 783:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2727               	.LM222:
 2728 0da0 9F5F      		subi r25,lo8(-(1))
 2729 0da2 9038      		cpi r25,lo8(-128)
 2730 0da4 01F4      		brne .L121
 787:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 2732               	.LM223:
 2733 0da6 8D81      		ldd r24,Y+5
 2734 0da8 90E0      		ldi r25,lo8(0)
 2735 0daa 252F      		mov r18,r21
 2736 0dac 3327      		clr r19
 2737 0dae 8217      		cp r24,r18
 2738 0db0 9307      		cpc r25,r19
 2739 0db2 01F4      		brne .L122
 2740 0db4 8E81      		ldd r24,Y+6
 2741 0db6 90E0      		ldi r25,lo8(0)
 2742 0db8 5070      		andi r21,hi8(255)
 2743 0dba 8417      		cp r24,r20
 2744 0dbc 9507      		cpc r25,r21
 2745 0dbe 01F4      		brne .L122
 790:vty.c         ****       uartVtySendByte(ACK);      
 2747               	.LM224:
 2748 0dc0 86E0      		ldi r24,lo8(6)
 2749 0dc2 0E94 0000 		call uartVtySendByte
 2750 0dc6 4AE0      		ldi r20,lo8(10)
 2751 0dc8 942E      		mov r9,r20
 2752 0dca 00C0      		rjmp .L123
 2753               	.L122:
 794:vty.c         ****       liczbaProb--;
 2755               	.LM225:
 2756 0dcc 9A94      		dec r9
 795:vty.c         ****       nrBloku--;
 2758               	.LM226:
 2759 0dce 1150      		subi r17,lo8(-(-1))
 796:vty.c         ****       uartVtySendByte(NAK);   
 2761               	.LM227:
 2762 0dd0 85E1      		ldi r24,lo8(21)
 2763 0dd2 0E94 0000 		call uartVtySendByte
 799:vty.c         ****     if (liczbaProb == 0)
 2765               	.LM228:
 2766 0dd6 9920      		tst r9
 2767 0dd8 01F4      		brne .L123
 801:vty.c         ****       state->err1 = nrBlokuZdalny;
 2769               	.LM229:
 2770 0dda 8B81      		ldd r24,Y+3
 2771 0ddc D701      		movw r26,r14
 2772 0dde 5D96      		adiw r26,29
 2773 0de0 8C93      		st X,r24
 2774 0de2 5D97      		sbiw r26,29
 2775 0de4 5E96      		adiw r26,30
 2776 0de6 1C92      		st X,__zero_reg__
 2777 0de8 5E97      		sbiw r26,30
 802:vty.c         ****       state->err2 = nrBloku;
 2779               	.LM230:
 2780 0dea 5F96      		adiw r26,31
 2781 0dec 1C93      		st X,r17
 2782 0dee 5F97      		sbiw r26,31
 803:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2784               	.LM231:
 2785 0df0 84E0      		ldi r24,lo8(4)
 2786               	.L136:
 2787 0df2 5C96      		adiw r26,28
 2788 0df4 8C93      		st X,r24
 2789 0df6 00C0      		rjmp .L110
 2790               	.L123:
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2792               	.LM232:
 2793 0df8 8091 0000 		lds r24,xVtyRec
 2794 0dfc 9091 0000 		lds r25,(xVtyRec)+1
 2795 0e00 B301      		movw r22,r6
 2796 0e02 44E6      		ldi r20,lo8(100)
 2797 0e04 50E0      		ldi r21,hi8(100)
 2798 0e06 20E0      		ldi r18,lo8(0)
 2799 0e08 0E94 0000 		call xQueueGenericReceive
 2800 0e0c 8823      		tst r24
 2801 0e0e 01F4      		brne .L124
 2802               	.L135:
 809:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 2804               	.LM233:
 2805 0e10 82E0      		ldi r24,lo8(2)
 2806 0e12 F701      		movw r30,r14
 2807 0e14 00C0      		rjmp .L137
 2808               	.L124:
 813:vty.c         ****     if (temp1 == SOH)
 2810               	.LM234:
 2811 0e16 9981      		ldd r25,Y+1
 2812 0e18 9130      		cpi r25,lo8(1)
 2813 0e1a 01F4      		brne .L125
 815:vty.c         ****       nrBloku++;
 2815               	.LM235:
 2816 0e1c 1F5F      		subi r17,lo8(-(1))
 816:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2818               	.LM236:
 2819 0e1e 80E0      		ldi r24,lo8(fdVty)
 2820 0e20 90E0      		ldi r25,hi8(fdVty)
 2821 0e22 612F      		mov r22,r17
 2822 0e24 70E0      		ldi r23,lo8(0)
 2823 0e26 0E94 0000 		call ramDyskDodajBlokXmodem
 2824 0e2a 6C01      		movw r12,r24
 818:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2826               	.LM237:
 2827 0e2c D701      		movw r26,r14
 2828 0e2e 5C96      		adiw r26,28
 2829 0e30 1C92      		st X,__zero_reg__
 2830 0e32 5C01      		movw r10,r24
 2831 0e34 00C0      		rjmp .L126
 2832               	.L125:
 822:vty.c         ****     if (temp1 == CAN)
 2834               	.LM238:
 2835 0e36 9831      		cpi r25,lo8(24)
 2836 0e38 01F4      		brne .L127
 824:vty.c         ****       state->err1 = nrBloku;
 2838               	.LM239:
 2839 0e3a F701      		movw r30,r14
 2840 0e3c 158F      		std Z+29,r17
 2841 0e3e 168E      		std Z+30,__zero_reg__
 825:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 2843               	.LM240:
 2844 0e40 87E0      		ldi r24,lo8(7)
 2845               	.L137:
 2846 0e42 848F      		std Z+28,r24
 2847 0e44 00C0      		rjmp .L110
 2848               	.L127:
 828:vty.c         ****     if (temp1 == EOT)
 2850               	.LM241:
 2851 0e46 9430      		cpi r25,lo8(4)
 2852 0e48 01F4      		brne .L128
 830:vty.c         ****       uartVtySendByte(NAK);
 2854               	.LM242:
 2855 0e4a 85E1      		ldi r24,lo8(21)
 2856 0e4c 0E94 0000 		call uartVtySendByte
 831:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 2858               	.LM243:
 2859 0e50 8091 0000 		lds r24,xVtyRec
 2860 0e54 9091 0000 		lds r25,(xVtyRec)+1
 2861 0e58 B301      		movw r22,r6
 2862 0e5a 4AE0      		ldi r20,lo8(10)
 2863 0e5c 50E0      		ldi r21,hi8(10)
 2864 0e5e 20E0      		ldi r18,lo8(0)
 2865 0e60 0E94 0000 		call xQueueGenericReceive
 2866 0e64 8823      		tst r24
 2867 0e66 01F0      		breq .L129
 833:vty.c         ****         if (temp1 == EOT)
 2869               	.LM244:
 2870 0e68 8981      		ldd r24,Y+1
 2871 0e6a 8430      		cpi r24,lo8(4)
 2872 0e6c 01F4      		brne .L129
 834:vty.c         ****           uartVtySendByte(ACK);  
 2874               	.LM245:
 2875 0e6e 86E0      		ldi r24,lo8(6)
 2876 0e70 0E94 0000 		call uartVtySendByte
 2877               	.L129:
 836:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2879               	.LM246:
 2880 0e74 D701      		movw r26,r14
 2881 0e76 5C96      		adiw r26,28
 2882 0e78 1C92      		st X,__zero_reg__
 2883 0e7a 00C0      		rjmp .L110
 2884               	.L128:
 839:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 2886               	.LM247:
 2887 0e7c 88E0      		ldi r24,lo8(8)
 2888 0e7e F701      		movw r30,r14
 2889 0e80 848F      		std Z+28,r24
 840:vty.c         ****     state->err1 = temp1;
 2891               	.LM248:
 2892 0e82 958F      		std Z+29,r25
 2893 0e84 168E      		std Z+30,__zero_reg__
 2894               	.L110:
 843:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2896               	.LM249:
 2897 0e86 80E0      		ldi r24,lo8(fdVty)
 2898 0e88 90E0      		ldi r25,hi8(fdVty)
 2899 0e8a 0E94 0000 		call ramDyskZamknijPlik
 2900 0e8e 20E0      		ldi r18,lo8(0)
 2901 0e90 30E0      		ldi r19,hi8(0)
 2902               	.L104:
 845:vty.c         **** }
 2904               	.LM250:
 2905 0e92 C901      		movw r24,r18
 2906               	/* epilogue start */
 2907 0e94 2696      		adiw r28,6
 2908 0e96 0FB6      		in __tmp_reg__,__SREG__
 2909 0e98 F894      		cli
 2910 0e9a DEBF      		out __SP_H__,r29
 2911 0e9c 0FBE      		out __SREG__,__tmp_reg__
 2912 0e9e CDBF      		out __SP_L__,r28
 2913 0ea0 CF91      		pop r28
 2914 0ea2 DF91      		pop r29
 2915 0ea4 1F91      		pop r17
 2916 0ea6 0F91      		pop r16
 2917 0ea8 FF90      		pop r15
 2918 0eaa EF90      		pop r14
 2919 0eac DF90      		pop r13
 2920 0eae CF90      		pop r12
 2921 0eb0 BF90      		pop r11
 2922 0eb2 AF90      		pop r10
 2923 0eb4 9F90      		pop r9
 2924 0eb6 8F90      		pop r8
 2925 0eb8 7F90      		pop r7
 2926 0eba 6F90      		pop r6
 2927 0ebc 5F90      		pop r5
 2928 0ebe 4F90      		pop r4
 2929 0ec0 3F90      		pop r3
 2930 0ec2 2F90      		pop r2
 2931 0ec4 0895      		ret
 2947               	.Lscope25:
 2949               		.stabd	78,0,0
 2953               	debugFunction:
 2954               		.stabd	46,0,0
 303:vty.c         **** {
 2956               	.LM251:
 2957               	.LFBB26:
 2958 0ec6 FF92      		push r15
 2959 0ec8 0F93      		push r16
 2960 0eca 1F93      		push r17
 2961 0ecc CF93      		push r28
 2962 0ece DF93      		push r29
 2963               	/* prologue: function */
 2964               	/* frame size = 0 */
 2965 0ed0 EC01      		movw r28,r24
 304:vty.c         ****   if (state->argc < 2)
 2967               	.LM252:
 2968 0ed2 898D      		ldd r24,Y+25
 2969 0ed4 8230      		cpi r24,lo8(2)
 2970 0ed6 00F4      		brsh .+2
 2971 0ed8 00C0      		rjmp .L139
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 2973               	.LM253:
 2974 0eda 82E0      		ldi r24,lo8(2)
 2975 0edc BE01      		movw r22,r28
 2976 0ede 0E94 0000 		call cmdlineGetArgInt
 2977 0ee2 F62E      		mov r15,r22
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 2979               	.LM254:
 2980 0ee4 81E0      		ldi r24,lo8(1)
 2981 0ee6 BE01      		movw r22,r28
 2982 0ee8 0E94 0000 		call cmdlineGetArgStr
 2983 0eec 8C01      		movw r16,r24
 309:vty.c         ****   if (level == 0)
 2985               	.LM255:
 2986 0eee FF20      		tst r15
 2987 0ef0 01F0      		breq .+2
 2988 0ef2 00C0      		rjmp .L140
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 2990               	.LM256:
 2991 0ef4 60E0      		ldi r22,lo8(__c.3269)
 2992 0ef6 70E0      		ldi r23,hi8(__c.3269)
 2993 0ef8 43E0      		ldi r20,lo8(3)
 2994 0efa 50E0      		ldi r21,hi8(3)
 2995 0efc 0E94 0000 		call strncmp_P
 2996 0f00 892B      		or r24,r25
 2997 0f02 01F4      		brne .L141
 313:vty.c         ****       setArpDebug(NULL, 0);
 2999               	.LM257:
 3000 0f04 80E0      		ldi r24,lo8(0)
 3001 0f06 90E0      		ldi r25,hi8(0)
 3002 0f08 60E0      		ldi r22,lo8(0)
 3003 0f0a 0E94 0000 		call setArpDebug
 3004 0f0e 00C0      		rjmp .L152
 3005               	.L141:
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3007               	.LM258:
 3008 0f10 C801      		movw r24,r16
 3009 0f12 60E0      		ldi r22,lo8(__c.3271)
 3010 0f14 70E0      		ldi r23,hi8(__c.3271)
 3011 0f16 42E0      		ldi r20,lo8(2)
 3012 0f18 50E0      		ldi r21,hi8(2)
 3013 0f1a 0E94 0000 		call strncmp_P
 3014 0f1e 892B      		or r24,r25
 3015 0f20 01F4      		brne .L143
 320:vty.c         ****       setIpDebug(NULL, 0);
 3017               	.LM259:
 3018 0f22 80E0      		ldi r24,lo8(0)
 3019 0f24 90E0      		ldi r25,hi8(0)
 3020 0f26 60E0      		ldi r22,lo8(0)
 3021 0f28 0E94 0000 		call setIpDebug
 3022 0f2c 00C0      		rjmp .L152
 3023               	.L143:
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3025               	.LM260:
 3026 0f2e C801      		movw r24,r16
 3027 0f30 60E0      		ldi r22,lo8(__c.3273)
 3028 0f32 70E0      		ldi r23,hi8(__c.3273)
 3029 0f34 42E0      		ldi r20,lo8(2)
 3030 0f36 50E0      		ldi r21,hi8(2)
 3031 0f38 0E94 0000 		call strncmp_P
 3032 0f3c 892B      		or r24,r25
 3033 0f3e 01F4      		brne .L144
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 3035               	.LM261:
 3036 0f40 80E0      		ldi r24,lo8(0)
 3037 0f42 90E0      		ldi r25,hi8(0)
 3038 0f44 60E0      		ldi r22,lo8(0)
 3039 0f46 0E94 0000 		call setIcmpDebug
 3040 0f4a 00C0      		rjmp .L152
 3041               	.L144:
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3043               	.LM262:
 3044 0f4c C801      		movw r24,r16
 3045 0f4e 60E0      		ldi r22,lo8(__c.3275)
 3046 0f50 70E0      		ldi r23,hi8(__c.3275)
 3047 0f52 42E0      		ldi r20,lo8(2)
 3048 0f54 50E0      		ldi r21,hi8(2)
 3049 0f56 0E94 0000 		call strncmp_P
 3050 0f5a 892B      		or r24,r25
 3051 0f5c 01F4      		brne .L145
 334:vty.c         ****       setTcpDebug(NULL, 0);
 3053               	.LM263:
 3054 0f5e 80E0      		ldi r24,lo8(0)
 3055 0f60 90E0      		ldi r25,hi8(0)
 3056 0f62 60E0      		ldi r22,lo8(0)
 3057 0f64 0E94 0000 		call setTcpDebug
 3058               	.L152:
 335:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 3060               	.LM264:
 3061 0f68 00D0      		rcall .
 3062 0f6a 00D0      		rcall .
 3063 0f6c 00D0      		rcall .
 3064 0f6e EDB7      		in r30,__SP_L__
 3065 0f70 FEB7      		in r31,__SP_H__
 3066 0f72 3196      		adiw r30,1
 3067 0f74 8A8D      		ldd r24,Y+26
 3068 0f76 9B8D      		ldd r25,Y+27
 3069 0f78 ADB7      		in r26,__SP_L__
 3070 0f7a BEB7      		in r27,__SP_H__
 3071 0f7c 1296      		adiw r26,1+1
 3072 0f7e 9C93      		st X,r25
 3073 0f80 8E93      		st -X,r24
 3074 0f82 1197      		sbiw r26,1
 3075 0f84 80E0      		ldi r24,lo8(debugDisabledInfoStr)
 3076 0f86 90E0      		ldi r25,hi8(debugDisabledInfoStr)
 3077 0f88 00C0      		rjmp .L151
 3078               	.L145:
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3080               	.LM265:
 3081 0f8a C801      		movw r24,r16
 3082 0f8c 60E0      		ldi r22,lo8(__c.3277)
 3083 0f8e 70E0      		ldi r23,hi8(__c.3277)
 3084 0f90 42E0      		ldi r20,lo8(2)
 3085 0f92 50E0      		ldi r21,hi8(2)
 3086 0f94 0E94 0000 		call strncmp_P
 3087 0f98 892B      		or r24,r25
 3088 0f9a 01F0      		breq .+2
 3089 0f9c 00C0      		rjmp .L139
 341:vty.c         ****       setUdpDebug(NULL, 0);
 3091               	.LM266:
 3092 0f9e 80E0      		ldi r24,lo8(0)
 3093 0fa0 90E0      		ldi r25,hi8(0)
 3094 0fa2 60E0      		ldi r22,lo8(0)
 3095 0fa4 0E94 0000 		call setUdpDebug
 3096 0fa8 00C0      		rjmp .L152
 3097               	.L140:
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 3099               	.LM267:
 3100 0faa 60E0      		ldi r22,lo8(__c.3279)
 3101 0fac 70E0      		ldi r23,hi8(__c.3279)
 3102 0fae 43E0      		ldi r20,lo8(3)
 3103 0fb0 50E0      		ldi r21,hi8(3)
 3104 0fb2 0E94 0000 		call strncmp_P
 3105 0fb6 892B      		or r24,r25
 3106 0fb8 01F4      		brne .L146
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 3108               	.LM268:
 3109 0fba 8A8D      		ldd r24,Y+26
 3110 0fbc 9B8D      		ldd r25,Y+27
 3111 0fbe 6F2D      		mov r22,r15
 3112 0fc0 0E94 0000 		call setArpDebug
 3113 0fc4 00C0      		rjmp .L153
 3114               	.L146:
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3116               	.LM269:
 3117 0fc6 C801      		movw r24,r16
 3118 0fc8 60E0      		ldi r22,lo8(__c.3281)
 3119 0fca 70E0      		ldi r23,hi8(__c.3281)
 3120 0fcc 42E0      		ldi r20,lo8(2)
 3121 0fce 50E0      		ldi r21,hi8(2)
 3122 0fd0 0E94 0000 		call strncmp_P
 3123 0fd4 892B      		or r24,r25
 3124 0fd6 01F4      		brne .L147
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 3126               	.LM270:
 3127 0fd8 8A8D      		ldd r24,Y+26
 3128 0fda 9B8D      		ldd r25,Y+27
 3129 0fdc 6F2D      		mov r22,r15
 3130 0fde 0E94 0000 		call setIpDebug
 3131 0fe2 00C0      		rjmp .L153
 3132               	.L147:
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3134               	.LM271:
 3135 0fe4 C801      		movw r24,r16
 3136 0fe6 60E0      		ldi r22,lo8(__c.3283)
 3137 0fe8 70E0      		ldi r23,hi8(__c.3283)
 3138 0fea 42E0      		ldi r20,lo8(2)
 3139 0fec 50E0      		ldi r21,hi8(2)
 3140 0fee 0E94 0000 		call strncmp_P
 3141 0ff2 892B      		or r24,r25
 3142 0ff4 01F4      		brne .L148
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 3144               	.LM272:
 3145 0ff6 8A8D      		ldd r24,Y+26
 3146 0ff8 9B8D      		ldd r25,Y+27
 3147 0ffa 6F2D      		mov r22,r15
 3148 0ffc 0E94 0000 		call setIcmpDebug
 3149 1000 00C0      		rjmp .L153
 3150               	.L148:
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3152               	.LM273:
 3153 1002 C801      		movw r24,r16
 3154 1004 60E0      		ldi r22,lo8(__c.3285)
 3155 1006 70E0      		ldi r23,hi8(__c.3285)
 3156 1008 42E0      		ldi r20,lo8(2)
 3157 100a 50E0      		ldi r21,hi8(2)
 3158 100c 0E94 0000 		call strncmp_P
 3159 1010 892B      		or r24,r25
 3160 1012 01F4      		brne .L149
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 3162               	.LM274:
 3163 1014 8A8D      		ldd r24,Y+26
 3164 1016 9B8D      		ldd r25,Y+27
 3165 1018 6F2D      		mov r22,r15
 3166 101a 0E94 0000 		call setTcpDebug
 3167               	.L153:
 374:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 3169               	.LM275:
 3170 101e 00D0      		rcall .
 3171 1020 00D0      		rcall .
 3172 1022 00D0      		rcall .
 3173 1024 EDB7      		in r30,__SP_L__
 3174 1026 FEB7      		in r31,__SP_H__
 3175 1028 3196      		adiw r30,1
 3176 102a 8A8D      		ldd r24,Y+26
 3177 102c 9B8D      		ldd r25,Y+27
 3178 102e ADB7      		in r26,__SP_L__
 3179 1030 BEB7      		in r27,__SP_H__
 3180 1032 1296      		adiw r26,1+1
 3181 1034 9C93      		st X,r25
 3182 1036 8E93      		st -X,r24
 3183 1038 1197      		sbiw r26,1
 3184 103a 80E0      		ldi r24,lo8(debugEnabledInfoStr)
 3185 103c 90E0      		ldi r25,hi8(debugEnabledInfoStr)
 3186               	.L151:
 3187 103e 9383      		std Z+3,r25
 3188 1040 8283      		std Z+2,r24
 3189 1042 1583      		std Z+5,r17
 3190 1044 0483      		std Z+4,r16
 3191 1046 0E94 0000 		call fprintf_P
 3192 104a 20E0      		ldi r18,lo8(0)
 3193 104c 30E0      		ldi r19,hi8(0)
 3194 104e 8DB7      		in r24,__SP_L__
 3195 1050 9EB7      		in r25,__SP_H__
 3196 1052 0696      		adiw r24,6
 3197 1054 0FB6      		in __tmp_reg__,__SREG__
 3198 1056 F894      		cli
 3199 1058 9EBF      		out __SP_H__,r25
 3200 105a 0FBE      		out __SREG__,__tmp_reg__
 3201 105c 8DBF      		out __SP_L__,r24
 3202 105e 00C0      		rjmp .L142
 3203               	.L149:
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3205               	.LM276:
 3206 1060 C801      		movw r24,r16
 3207 1062 60E0      		ldi r22,lo8(__c.3287)
 3208 1064 70E0      		ldi r23,hi8(__c.3287)
 3209 1066 42E0      		ldi r20,lo8(2)
 3210 1068 50E0      		ldi r21,hi8(2)
 3211 106a 0E94 0000 		call strncmp_P
 3212 106e 892B      		or r24,r25
 3213 1070 01F4      		brne .L139
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 3215               	.LM277:
 3216 1072 8A8D      		ldd r24,Y+26
 3217 1074 9B8D      		ldd r25,Y+27
 3218 1076 6F2D      		mov r22,r15
 3219 1078 0E94 0000 		call setUdpDebug
 3220 107c 00C0      		rjmp .L153
 3221               	.L139:
 382:vty.c         ****       return OK_SILENT;  
 3223               	.LM278:
 3224 107e 22E0      		ldi r18,lo8(2)
 3225 1080 30E0      		ldi r19,hi8(2)
 3226               	.L142:
 387:vty.c         **** }
 3228               	.LM279:
 3229 1082 C901      		movw r24,r18
 3230               	/* epilogue start */
 3231 1084 DF91      		pop r29
 3232 1086 CF91      		pop r28
 3233 1088 1F91      		pop r17
 3234 108a 0F91      		pop r16
 3235 108c FF90      		pop r15
 3236 108e 0895      		ret
 3238               	.Lscope26:
 3240               		.stabd	78,0,0
 3244               	statusEncFunction:
 3245               		.stabd	46,0,0
 287:vty.c         **** {
 3247               	.LM280:
 3248               	.LFBB27:
 3249               	/* prologue: function */
 3250               	/* frame size = 0 */
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 3252               	.LM281:
 3253 1090 FC01      		movw r30,r24
 3254 1092 828D      		ldd r24,Z+26
 3255 1094 938D      		ldd r25,Z+27
 3256 1096 0E94 0000 		call nicRegDump
 290:vty.c         **** }
 3258               	.LM282:
 3259 109a 80E0      		ldi r24,lo8(0)
 3260 109c 90E0      		ldi r25,hi8(0)
 3261               	/* epilogue start */
 3262 109e 0895      		ret
 3264               	.Lscope27:
 3266               		.stabd	78,0,0
 3270               	readRamFIleFunction:
 3271               		.stabd	46,0,0
 901:vty.c         **** {
 3273               	.LM283:
 3274               	.LFBB28:
 3275 10a0 CF92      		push r12
 3276 10a2 DF92      		push r13
 3277 10a4 EF92      		push r14
 3278 10a6 FF92      		push r15
 3279 10a8 0F93      		push r16
 3280 10aa 1F93      		push r17
 3281 10ac DF93      		push r29
 3282 10ae CF93      		push r28
 3283 10b0 0F92      		push __tmp_reg__
 3284 10b2 CDB7      		in r28,__SP_L__
 3285 10b4 DEB7      		in r29,__SP_H__
 3286               	/* prologue: function */
 3287               	/* frame size = 1 */
 3288 10b6 8C01      		movw r16,r24
 903:vty.c         ****   uint8_t znak = ' ';
 3290               	.LM284:
 3291 10b8 80E2      		ldi r24,lo8(32)
 3292 10ba 8983      		std Y+1,r24
 904:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 3294               	.LM285:
 3295 10bc 81E0      		ldi r24,lo8(1)
 3296 10be B801      		movw r22,r16
 3297 10c0 0E94 0000 		call cmdlineGetArgStr
 3298 10c4 60E0      		ldi r22,lo8(fdVty)
 3299 10c6 70E0      		ldi r23,hi8(fdVty)
 3300 10c8 0E94 0000 		call ramDyskOtworzPlik
 3301 10cc D801      		movw r26,r16
 3302 10ce 5A96      		adiw r26,26
 3303 10d0 ED90      		ld r14,X+
 3304 10d2 FC90      		ld r15,X
 3305 10d4 5B97      		sbiw r26,26+1
 3306 10d6 8823      		tst r24
 3307 10d8 01F0      		breq .L157
 906:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 3309               	.LM286:
 3310 10da 81E0      		ldi r24,lo8(1)
 3311 10dc B801      		movw r22,r16
 3312 10de 0E94 0000 		call cmdlineGetArgStr
 3313 10e2 00D0      		rcall .
 3314 10e4 00D0      		rcall .
 3315 10e6 00D0      		rcall .
 3316 10e8 EDB7      		in r30,__SP_L__
 3317 10ea FEB7      		in r31,__SP_H__
 3318 10ec 3196      		adiw r30,1
 3319 10ee ADB7      		in r26,__SP_L__
 3320 10f0 BEB7      		in r27,__SP_H__
 3321 10f2 1296      		adiw r26,1+1
 3322 10f4 FC92      		st X,r15
 3323 10f6 EE92      		st -X,r14
 3324 10f8 1197      		sbiw r26,1
 3325 10fa 20E0      		ldi r18,lo8(errorOpenFile)
 3326 10fc 30E0      		ldi r19,hi8(errorOpenFile)
 3327 10fe 3383      		std Z+3,r19
 3328 1100 2283      		std Z+2,r18
 3329 1102 9583      		std Z+5,r25
 3330 1104 8483      		std Z+4,r24
 3331 1106 0E94 0000 		call fprintf_P
 3332 110a 24E0      		ldi r18,lo8(4)
 3333 110c 30E0      		ldi r19,hi8(4)
 3334 110e EDB7      		in r30,__SP_L__
 3335 1110 FEB7      		in r31,__SP_H__
 3336 1112 3696      		adiw r30,6
 3337 1114 0FB6      		in __tmp_reg__,__SREG__
 3338 1116 F894      		cli
 3339 1118 FEBF      		out __SP_H__,r31
 3340 111a 0FBE      		out __SREG__,__tmp_reg__
 3341 111c EDBF      		out __SP_L__,r30
 3342 111e 00C0      		rjmp .L158
 3343               	.L157:
 909:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 3345               	.LM287:
 3346 1120 2091 0000 		lds r18,fdVty+4
 3347 1124 3091 0000 		lds r19,(fdVty+4)+1
 910:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 3349               	.LM288:
 3350 1128 00D0      		rcall .
 3351 112a 00D0      		rcall .
 3352 112c 00D0      		rcall .
 3353 112e ADB7      		in r26,__SP_L__
 3354 1130 BEB7      		in r27,__SP_H__
 3355 1132 1196      		adiw r26,1
 3356 1134 EDB7      		in r30,__SP_L__
 3357 1136 FEB7      		in r31,__SP_H__
 3358 1138 F282      		std Z+2,r15
 3359 113a E182      		std Z+1,r14
 3360 113c 80E0      		ldi r24,lo8(readRamFIleLenStr)
 3361 113e 90E0      		ldi r25,hi8(readRamFIleLenStr)
 3362 1140 1396      		adiw r26,2+1
 3363 1142 9C93      		st X,r25
 3364 1144 8E93      		st -X,r24
 3365 1146 1297      		sbiw r26,2
 3366 1148 F901      		movw r30,r18
 3367 114a 9281      		ldd r25,Z+2
 3368 114c 80E0      		ldi r24,lo8(0)
 3369 114e 2181      		ldd r18,Z+1
 3370 1150 820F      		add r24,r18
 3371 1152 911D      		adc r25,__zero_reg__
 3372 1154 1596      		adiw r26,4+1
 3373 1156 9C93      		st X,r25
 3374 1158 8E93      		st -X,r24
 3375 115a 1497      		sbiw r26,4
 3376 115c 0E94 0000 		call fprintf_P
 3377 1160 8DB7      		in r24,__SP_L__
 3378 1162 9EB7      		in r25,__SP_H__
 3379 1164 0696      		adiw r24,6
 3380 1166 0FB6      		in __tmp_reg__,__SREG__
 3381 1168 F894      		cli
 3382 116a 9EBF      		out __SP_H__,r25
 3383 116c 0FBE      		out __SREG__,__tmp_reg__
 3384 116e 8DBF      		out __SP_L__,r24
 913:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 3386               	.LM289:
 3387 1170 6E01      		movw r12,r28
 3388 1172 0894      		sec
 3389 1174 C11C      		adc r12,__zero_reg__
 3390 1176 D11C      		adc r13,__zero_reg__
 3391               	.L160:
 3392 1178 80E0      		ldi r24,lo8(fdVty)
 3393 117a 90E0      		ldi r25,hi8(fdVty)
 3394 117c B601      		movw r22,r12
 3395 117e 0E94 0000 		call ramDyskCzytajBajtZPliku
 3396 1182 F82E      		mov r15,r24
 915:vty.c         ****     uartVtySendByte(znak);
 3398               	.LM290:
 3399 1184 8981      		ldd r24,Y+1
 3400 1186 0E94 0000 		call uartVtySendByte
 916:vty.c         ****     if (znak == '\r')
 3402               	.LM291:
 3403 118a 8981      		ldd r24,Y+1
 3404 118c 8D30      		cpi r24,lo8(13)
 3405 118e 01F4      		brne .L159
 917:vty.c         ****       uartVtySendByte('\n');
 3407               	.LM292:
 3408 1190 8AE0      		ldi r24,lo8(10)
 3409 1192 0E94 0000 		call uartVtySendByte
 3410               	.L159:
 911:vty.c         ****   while (rezultat == 0)
 3412               	.LM293:
 3413 1196 FF20      		tst r15
 3414 1198 01F0      		breq .L160
 919:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 3416               	.LM294:
 3417 119a 00D0      		rcall .
 3418 119c 00D0      		rcall .
 3419 119e D801      		movw r26,r16
 3420 11a0 5A96      		adiw r26,26
 3421 11a2 8D91      		ld r24,X+
 3422 11a4 9C91      		ld r25,X
 3423 11a6 5B97      		sbiw r26,26+1
 3424 11a8 EDB7      		in r30,__SP_L__
 3425 11aa FEB7      		in r31,__SP_H__
 3426 11ac 9283      		std Z+2,r25
 3427 11ae 8183      		std Z+1,r24
 3428 11b0 80E0      		ldi r24,lo8(nlStr)
 3429 11b2 90E0      		ldi r25,hi8(nlStr)
 3430 11b4 9483      		std Z+4,r25
 3431 11b6 8383      		std Z+3,r24
 3432 11b8 0E94 0000 		call fprintf_P
 920:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 3434               	.LM295:
 3435 11bc 0F90      		pop __tmp_reg__
 3436 11be 0F90      		pop __tmp_reg__
 3437 11c0 0F90      		pop __tmp_reg__
 3438 11c2 0F90      		pop __tmp_reg__
 3439 11c4 80E0      		ldi r24,lo8(fdVty)
 3440 11c6 90E0      		ldi r25,hi8(fdVty)
 3441 11c8 0E94 0000 		call ramDyskZamknijPlik
 3442 11cc 20E0      		ldi r18,lo8(0)
 3443 11ce 30E0      		ldi r19,hi8(0)
 3444               	.L158:
 922:vty.c         **** }
 3446               	.LM296:
 3447 11d0 C901      		movw r24,r18
 3448               	/* epilogue start */
 3449 11d2 0F90      		pop __tmp_reg__
 3450 11d4 CF91      		pop r28
 3451 11d6 DF91      		pop r29
 3452 11d8 1F91      		pop r17
 3453 11da 0F91      		pop r16
 3454 11dc FF90      		pop r15
 3455 11de EF90      		pop r14
 3456 11e0 DF90      		pop r13
 3457 11e2 CF90      		pop r12
 3458 11e4 0895      		ret
 3463               	.Lscope28:
 3465               		.stabd	78,0,0
 3469               	writeRamFileFunction:
 3470               		.stabd	46,0,0
 870:vty.c         **** {
 3472               	.LM297:
 3473               	.LFBB29:
 3474               	/* prologue: function */
 3475               	/* frame size = 0 */
 871:vty.c         ****   ramDyskDir(state->myStdInOut);
 3477               	.LM298:
 3478 11e6 FC01      		movw r30,r24
 3479 11e8 828D      		ldd r24,Z+26
 3480 11ea 938D      		ldd r25,Z+27
 3481 11ec 0E94 0000 		call ramDyskDir
 873:vty.c         **** }
 3483               	.LM299:
 3484 11f0 80E0      		ldi r24,lo8(0)
 3485 11f2 90E0      		ldi r25,hi8(0)
 3486               	/* epilogue start */
 3487 11f4 0895      		ret
 3489               	.Lscope29:
 3491               		.stabd	78,0,0
 3495               	pokazCzasFunction:
 3496               		.stabd	46,0,0
 293:vty.c         **** {
 3498               	.LM300:
 3499               	.LFBB30:
 3500 11f6 0F93      		push r16
 3501 11f8 1F93      		push r17
 3502 11fa CF93      		push r28
 3503 11fc DF93      		push r29
 3504               	/* prologue: function */
 3505               	/* frame size = 0 */
 3506 11fe 8C01      		movw r16,r24
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 3508               	.LM301:
 3509 1200 80E0      		ldi r24,lo8(czasRtc)
 3510 1202 90E0      		ldi r25,hi8(czasRtc)
 3511 1204 0E94 0000 		call readTimeDecoded
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 3513               	.LM302:
 3514 1208 2091 0000 		lds r18,czasRtc+2
 3515 120c 2295      		swap r18
 3516 120e 2F70      		andi r18,lo8(15)
 3517 1210 4091 0000 		lds r20,czasRtc+2
 3518 1214 4F70      		andi r20,lo8(15)
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 3520               	.LM303:
 3521 1216 7091 0000 		lds r23,czasRtc+1
 3522 121a 7295      		swap r23
 3523 121c 7F70      		andi r23,lo8(15)
 3524 121e 5091 0000 		lds r21,czasRtc+1
 3525 1222 5F70      		andi r21,lo8(15)
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 3527               	.LM304:
 3528 1224 A091 0000 		lds r26,czasRtc
 3529 1228 A295      		swap r26
 3530 122a AF70      		andi r26,lo8(15)
 3531 122c 6091 0000 		lds r22,czasRtc
 3532 1230 6F70      		andi r22,lo8(15)
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 3534               	.LM305:
 3535 1232 8DB7      		in r24,__SP_L__
 3536 1234 9EB7      		in r25,__SP_H__
 3537 1236 0A97      		sbiw r24,10
 3538 1238 0FB6      		in __tmp_reg__,__SREG__
 3539 123a F894      		cli
 3540 123c 9EBF      		out __SP_H__,r25
 3541 123e 0FBE      		out __SREG__,__tmp_reg__
 3542 1240 8DBF      		out __SP_L__,r24
 3543 1242 EDB7      		in r30,__SP_L__
 3544 1244 FEB7      		in r31,__SP_H__
 3545 1246 3196      		adiw r30,1
 3546 1248 E801      		movw r28,r16
 3547 124a 8A8D      		ldd r24,Y+26
 3548 124c 9B8D      		ldd r25,Y+27
 3549 124e CDB7      		in r28,__SP_L__
 3550 1250 DEB7      		in r29,__SP_H__
 3551 1252 9A83      		std Y+2,r25
 3552 1254 8983      		std Y+1,r24
 3553 1256 80E0      		ldi r24,lo8(__c.3239)
 3554 1258 90E0      		ldi r25,hi8(__c.3239)
 3555 125a 9383      		std Z+3,r25
 3556 125c 8283      		std Z+2,r24
 3557 125e 822F      		mov r24,r18
 3558 1260 8370      		andi r24,lo8(3)
 3559 1262 90E0      		ldi r25,lo8(0)
 3560 1264 9C01      		movw r18,r24
 3561 1266 13E0      		ldi r17,3
 3562 1268 220F      	1:	lsl r18
 3563 126a 331F      		rol r19
 3564 126c 1A95      		dec r17
 3565 126e 01F4      		brne 1b
 3566 1270 880F      		lsl r24
 3567 1272 991F      		rol r25
 3568 1274 280F      		add r18,r24
 3569 1276 391F      		adc r19,r25
 3570 1278 420F      		add r20,r18
 3571 127a 4483      		std Z+4,r20
 3572 127c 1582      		std Z+5,__zero_reg__
 3573 127e 872F      		mov r24,r23
 3574 1280 8770      		andi r24,lo8(7)
 3575 1282 90E0      		ldi r25,lo8(0)
 3576 1284 9C01      		movw r18,r24
 3577 1286 73E0      		ldi r23,3
 3578 1288 220F      	1:	lsl r18
 3579 128a 331F      		rol r19
 3580 128c 7A95      		dec r23
 3581 128e 01F4      		brne 1b
 3582 1290 880F      		lsl r24
 3583 1292 991F      		rol r25
 3584 1294 280F      		add r18,r24
 3585 1296 391F      		adc r19,r25
 3586 1298 520F      		add r21,r18
 3587 129a 5683      		std Z+6,r21
 3588 129c 1782      		std Z+7,__zero_reg__
 3589 129e 8A2F      		mov r24,r26
 3590 12a0 8770      		andi r24,lo8(7)
 3591 12a2 90E0      		ldi r25,lo8(0)
 3592 12a4 9C01      		movw r18,r24
 3593 12a6 03E0      		ldi r16,3
 3594 12a8 220F      	1:	lsl r18
 3595 12aa 331F      		rol r19
 3596 12ac 0A95      		dec r16
 3597 12ae 01F4      		brne 1b
 3598 12b0 880F      		lsl r24
 3599 12b2 991F      		rol r25
 3600 12b4 280F      		add r18,r24
 3601 12b6 391F      		adc r19,r25
 3602 12b8 620F      		add r22,r18
 3603 12ba 6087      		std Z+8,r22
 3604 12bc 1186      		std Z+9,__zero_reg__
 3605 12be 0E94 0000 		call fprintf_P
 3606 12c2 8DB7      		in r24,__SP_L__
 3607 12c4 9EB7      		in r25,__SP_H__
 3608 12c6 0A96      		adiw r24,10
 3609 12c8 0FB6      		in __tmp_reg__,__SREG__
 3610 12ca F894      		cli
 3611 12cc 9EBF      		out __SP_H__,r25
 3612 12ce 0FBE      		out __SREG__,__tmp_reg__
 3613 12d0 8DBF      		out __SP_L__,r24
 300:vty.c         **** }
 3615               	.LM306:
 3616 12d2 80E0      		ldi r24,lo8(0)
 3617 12d4 90E0      		ldi r25,hi8(0)
 3618               	/* epilogue start */
 3619 12d6 DF91      		pop r29
 3620 12d8 CF91      		pop r28
 3621 12da 1F91      		pop r17
 3622 12dc 0F91      		pop r16
 3623 12de 0895      		ret
 3625               	.Lscope30:
 3627               		.stabd	78,0,0
 3631               	helpFunction:
 3632               		.stabd	46,0,0
 503:vty.c         **** {
 3634               	.LM307:
 3635               	.LFBB31:
 3636               	/* prologue: function */
 3637               	/* frame size = 0 */
 504:vty.c         ****   cmdPrintHelp(state);
 3639               	.LM308:
 3640 12e0 0E94 0000 		call cmdPrintHelp
 506:vty.c         **** }
 3642               	.LM309:
 3643 12e4 80E0      		ldi r24,lo8(0)
 3644 12e6 90E0      		ldi r25,hi8(0)
 3645               	/* epilogue start */
 3646 12e8 0895      		ret
 3648               	.Lscope31:
 3650               		.stabd	78,0,0
 3653               	.global	printStatus
 3655               	printStatus:
 3656               		.stabd	46,0,0
 207:vty.c         **** {
 3658               	.LM310:
 3659               	.LFBB32:
 3660 12ea CF93      		push r28
 3661 12ec DF93      		push r29
 3662               	/* prologue: function */
 3663               	/* frame size = 0 */
 3664 12ee EC01      		movw r28,r24
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 3666               	.LM311:
 3667 12f0 00D0      		rcall .
 3668 12f2 00D0      		rcall .
 3669 12f4 ADB7      		in r26,__SP_L__
 3670 12f6 BEB7      		in r27,__SP_H__
 3671 12f8 1296      		adiw r26,1+1
 3672 12fa 9C93      		st X,r25
 3673 12fc 8E93      		st -X,r24
 3674 12fe 1197      		sbiw r26,1
 3675 1300 80E0      		ldi r24,lo8(__c.3189)
 3676 1302 90E0      		ldi r25,hi8(__c.3189)
 3677 1304 1496      		adiw r26,3+1
 3678 1306 9C93      		st X,r25
 3679 1308 8E93      		st -X,r24
 3680 130a 1397      		sbiw r26,3
 3681 130c 0E94 0000 		call fprintf_P
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 3683               	.LM312:
 3684 1310 EDB7      		in r30,__SP_L__
 3685 1312 FEB7      		in r31,__SP_H__
 3686 1314 D283      		std Z+2,r29
 3687 1316 C183      		std Z+1,r28
 3688 1318 80E0      		ldi r24,lo8(systemStateStr)
 3689 131a 90E0      		ldi r25,hi8(systemStateStr)
 3690 131c 9483      		std Z+4,r25
 3691 131e 8383      		std Z+3,r24
 3692 1320 0E94 0000 		call fprintf_P
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 3694               	.LM313:
 3695 1324 0F90      		pop __tmp_reg__
 3696 1326 0F90      		pop __tmp_reg__
 3697 1328 0F90      		pop __tmp_reg__
 3698 132a 0F90      		pop __tmp_reg__
 3699 132c 0E94 0000 		call uxTaskGetNumberOfTasks
 3700 1330 00D0      		rcall .
 3701 1332 00D0      		rcall .
 3702 1334 00D0      		rcall .
 3703 1336 EDB7      		in r30,__SP_L__
 3704 1338 FEB7      		in r31,__SP_H__
 3705 133a 3196      		adiw r30,1
 3706 133c ADB7      		in r26,__SP_L__
 3707 133e BEB7      		in r27,__SP_H__
 3708 1340 1296      		adiw r26,1+1
 3709 1342 DC93      		st X,r29
 3710 1344 CE93      		st -X,r28
 3711 1346 1197      		sbiw r26,1
 3712 1348 20E0      		ldi r18,lo8(statusNumberOfTasksStr)
 3713 134a 30E0      		ldi r19,hi8(statusNumberOfTasksStr)
 3714 134c 3383      		std Z+3,r19
 3715 134e 2283      		std Z+2,r18
 3716 1350 8483      		std Z+4,r24
 3717 1352 1582      		std Z+5,__zero_reg__
 3718 1354 0E94 0000 		call fprintf_P
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 3720               	.LM314:
 3721 1358 EDB7      		in r30,__SP_L__
 3722 135a FEB7      		in r31,__SP_H__
 3723 135c 3696      		adiw r30,6
 3724 135e 0FB6      		in __tmp_reg__,__SREG__
 3725 1360 F894      		cli
 3726 1362 FEBF      		out __SP_H__,r31
 3727 1364 0FBE      		out __SREG__,__tmp_reg__
 3728 1366 EDBF      		out __SP_L__,r30
 3729 1368 0E94 0000 		call xPortGetFreeHeapSize
 3730 136c 2DB7      		in r18,__SP_L__
 3731 136e 3EB7      		in r19,__SP_H__
 3732 1370 2850      		subi r18,lo8(-(-8))
 3733 1372 3040      		sbci r19,hi8(-(-8))
 3734 1374 0FB6      		in __tmp_reg__,__SREG__
 3735 1376 F894      		cli
 3736 1378 3EBF      		out __SP_H__,r19
 3737 137a 0FBE      		out __SREG__,__tmp_reg__
 3738 137c 2DBF      		out __SP_L__,r18
 3739 137e EDB7      		in r30,__SP_L__
 3740 1380 FEB7      		in r31,__SP_H__
 3741 1382 3196      		adiw r30,1
 3742 1384 ADB7      		in r26,__SP_L__
 3743 1386 BEB7      		in r27,__SP_H__
 3744 1388 1296      		adiw r26,1+1
 3745 138a DC93      		st X,r29
 3746 138c CE93      		st -X,r28
 3747 138e 1197      		sbiw r26,1
 3748 1390 20E0      		ldi r18,lo8(statusStaticHeapStateStr)
 3749 1392 30E0      		ldi r19,hi8(statusStaticHeapStateStr)
 3750 1394 3383      		std Z+3,r19
 3751 1396 2283      		std Z+2,r18
 3752 1398 9583      		std Z+5,r25
 3753 139a 8483      		std Z+4,r24
 3754 139c 8CE1      		ldi r24,lo8(3100)
 3755 139e 9CE0      		ldi r25,hi8(3100)
 3756 13a0 9783      		std Z+7,r25
 3757 13a2 8683      		std Z+6,r24
 3758 13a4 0E94 0000 		call fprintf_P
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 3760               	.LM315:
 3761 13a8 EDB7      		in r30,__SP_L__
 3762 13aa FEB7      		in r31,__SP_H__
 3763 13ac 3896      		adiw r30,8
 3764 13ae 0FB6      		in __tmp_reg__,__SREG__
 3765 13b0 F894      		cli
 3766 13b2 FEBF      		out __SP_H__,r31
 3767 13b4 0FBE      		out __SREG__,__tmp_reg__
 3768 13b6 EDBF      		out __SP_L__,r30
 3769 13b8 0E94 0000 		call xmallocAvailable
 3770 13bc 2DB7      		in r18,__SP_L__
 3771 13be 3EB7      		in r19,__SP_H__
 3772 13c0 2850      		subi r18,lo8(-(-8))
 3773 13c2 3040      		sbci r19,hi8(-(-8))
 3774 13c4 0FB6      		in __tmp_reg__,__SREG__
 3775 13c6 F894      		cli
 3776 13c8 3EBF      		out __SP_H__,r19
 3777 13ca 0FBE      		out __SREG__,__tmp_reg__
 3778 13cc 2DBF      		out __SP_L__,r18
 3779 13ce EDB7      		in r30,__SP_L__
 3780 13d0 FEB7      		in r31,__SP_H__
 3781 13d2 3196      		adiw r30,1
 3782 13d4 ADB7      		in r26,__SP_L__
 3783 13d6 BEB7      		in r27,__SP_H__
 3784 13d8 1296      		adiw r26,1+1
 3785 13da DC93      		st X,r29
 3786 13dc CE93      		st -X,r28
 3787 13de 1197      		sbiw r26,1
 3788 13e0 20E0      		ldi r18,lo8(statusDynamicHeapStateStr)
 3789 13e2 30E0      		ldi r19,hi8(statusDynamicHeapStateStr)
 3790 13e4 3383      		std Z+3,r19
 3791 13e6 2283      		std Z+2,r18
 3792 13e8 9583      		std Z+5,r25
 3793 13ea 8483      		std Z+4,r24
 3794 13ec 80E0      		ldi r24,lo8(5888)
 3795 13ee 97E1      		ldi r25,hi8(5888)
 3796 13f0 9783      		std Z+7,r25
 3797 13f2 8683      		std Z+6,r24
 3798 13f4 0E94 0000 		call fprintf_P
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 3800               	.LM316:
 3801 13f8 2091 0000 		lds r18,temperature
 3802 13fc 0F90      		pop __tmp_reg__
 3803 13fe 0F90      		pop __tmp_reg__
 3804 1400 EDB7      		in r30,__SP_L__
 3805 1402 FEB7      		in r31,__SP_H__
 3806 1404 3196      		adiw r30,1
 3807 1406 ADB7      		in r26,__SP_L__
 3808 1408 BEB7      		in r27,__SP_H__
 3809 140a 1296      		adiw r26,1+1
 3810 140c DC93      		st X,r29
 3811 140e CE93      		st -X,r28
 3812 1410 1197      		sbiw r26,1
 3813 1412 80E0      		ldi r24,lo8(statusTemperatureStr)
 3814 1414 90E0      		ldi r25,hi8(statusTemperatureStr)
 3815 1416 9383      		std Z+3,r25
 3816 1418 8283      		std Z+2,r24
 3817 141a 2483      		std Z+4,r18
 3818 141c 1582      		std Z+5,__zero_reg__
 3819 141e 0E94 0000 		call fprintf_P
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 3821               	.LM317:
 3822 1422 2091 0000 		lds r18,voltage
 3823 1426 EDB7      		in r30,__SP_L__
 3824 1428 FEB7      		in r31,__SP_H__
 3825 142a 3196      		adiw r30,1
 3826 142c ADB7      		in r26,__SP_L__
 3827 142e BEB7      		in r27,__SP_H__
 3828 1430 1296      		adiw r26,1+1
 3829 1432 DC93      		st X,r29
 3830 1434 CE93      		st -X,r28
 3831 1436 1197      		sbiw r26,1
 3832 1438 80E0      		ldi r24,lo8(statusVoltageStr)
 3833 143a 90E0      		ldi r25,hi8(statusVoltageStr)
 3834 143c 9383      		std Z+3,r25
 3835 143e 8283      		std Z+2,r24
 3836 1440 2483      		std Z+4,r18
 3837 1442 1582      		std Z+5,__zero_reg__
 3838 1444 0E94 0000 		call fprintf_P
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 3840               	.LM318:
 3841 1448 EDB7      		in r30,__SP_L__
 3842 144a FEB7      		in r31,__SP_H__
 3843 144c 3696      		adiw r30,6
 3844 144e 0FB6      		in __tmp_reg__,__SREG__
 3845 1450 F894      		cli
 3846 1452 FEBF      		out __SP_H__,r31
 3847 1454 0FBE      		out __SREG__,__tmp_reg__
 3848 1456 EDBF      		out __SP_L__,r30
 3849 1458 0E94 0000 		call ramDyskLiczbaWolnychKlastrow
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 3851               	.LM319:
 3852 145c 2DB7      		in r18,__SP_L__
 3853 145e 3EB7      		in r19,__SP_H__
 3854 1460 2850      		subi r18,lo8(-(-8))
 3855 1462 3040      		sbci r19,hi8(-(-8))
 3856 1464 0FB6      		in __tmp_reg__,__SREG__
 3857 1466 F894      		cli
 3858 1468 3EBF      		out __SP_H__,r19
 3859 146a 0FBE      		out __SREG__,__tmp_reg__
 3860 146c 2DBF      		out __SP_L__,r18
 3861 146e EDB7      		in r30,__SP_L__
 3862 1470 FEB7      		in r31,__SP_H__
 3863 1472 3196      		adiw r30,1
 3864 1474 ADB7      		in r26,__SP_L__
 3865 1476 BEB7      		in r27,__SP_H__
 3866 1478 1296      		adiw r26,1+1
 3867 147a DC93      		st X,r29
 3868 147c CE93      		st -X,r28
 3869 147e 1197      		sbiw r26,1
 3870 1480 20E0      		ldi r18,lo8(statusRamDiskStateStr)
 3871 1482 30E0      		ldi r19,hi8(statusRamDiskStateStr)
 3872 1484 3383      		std Z+3,r19
 3873 1486 2283      		std Z+2,r18
 3874 1488 8483      		std Z+4,r24
 3875 148a 1582      		std Z+5,__zero_reg__
 3876 148c 80E8      		ldi r24,lo8(128)
 3877 148e 90E0      		ldi r25,hi8(128)
 3878 1490 9783      		std Z+7,r25
 3879 1492 8683      		std Z+6,r24
 3880 1494 0E94 0000 		call fprintf_P
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 3882               	.LM320:
 3883 1498 0F90      		pop __tmp_reg__
 3884 149a 0F90      		pop __tmp_reg__
 3885 149c 0F90      		pop __tmp_reg__
 3886 149e 0F90      		pop __tmp_reg__
 3887 14a0 EDB7      		in r30,__SP_L__
 3888 14a2 FEB7      		in r31,__SP_H__
 3889 14a4 D283      		std Z+2,r29
 3890 14a6 C183      		std Z+1,r28
 3891 14a8 80E0      		ldi r24,lo8(systemRamConfigStr)
 3892 14aa 90E0      		ldi r25,hi8(systemRamConfigStr)
 3893 14ac 9483      		std Z+4,r25
 3894 14ae 8383      		std Z+3,r24
 3895 14b0 0E94 0000 		call fprintf_P
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 3897               	.LM321:
 3898 14b4 ADB7      		in r26,__SP_L__
 3899 14b6 BEB7      		in r27,__SP_H__
 3900 14b8 1296      		adiw r26,1+1
 3901 14ba DC93      		st X,r29
 3902 14bc CE93      		st -X,r28
 3903 14be 1197      		sbiw r26,1
 3904 14c0 80E0      		ldi r24,lo8(statusMacStr)
 3905 14c2 90E0      		ldi r25,hi8(statusMacStr)
 3906 14c4 1496      		adiw r26,3+1
 3907 14c6 9C93      		st X,r25
 3908 14c8 8E93      		st -X,r24
 3909 14ca 1397      		sbiw r26,3
 3910 14cc 0E94 0000 		call fprintf_P
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 3912               	.LM322:
 3913 14d0 0F90      		pop __tmp_reg__
 3914 14d2 0F90      		pop __tmp_reg__
 3915 14d4 0F90      		pop __tmp_reg__
 3916 14d6 0F90      		pop __tmp_reg__
 3917 14d8 CE01      		movw r24,r28
 3918 14da 60E0      		ldi r22,lo8(nicState+2)
 3919 14dc 70E0      		ldi r23,hi8(nicState+2)
 3920 14de 0E94 0000 		call netPrintEthAddr
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3922               	.LM323:
 3923 14e2 00D0      		rcall .
 3924 14e4 00D0      		rcall .
 3925 14e6 EDB7      		in r30,__SP_L__
 3926 14e8 FEB7      		in r31,__SP_H__
 3927 14ea D283      		std Z+2,r29
 3928 14ec C183      		std Z+1,r28
 3929 14ee 80E0      		ldi r24,lo8(__c.3192)
 3930 14f0 90E0      		ldi r25,hi8(__c.3192)
 3931 14f2 9483      		std Z+4,r25
 3932 14f4 8383      		std Z+3,r24
 3933 14f6 0E94 0000 		call fprintf_P
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 3935               	.LM324:
 3936 14fa ADB7      		in r26,__SP_L__
 3937 14fc BEB7      		in r27,__SP_H__
 3938 14fe 1296      		adiw r26,1+1
 3939 1500 DC93      		st X,r29
 3940 1502 CE93      		st -X,r28
 3941 1504 1197      		sbiw r26,1
 3942 1506 80E0      		ldi r24,lo8(statusIpStr)
 3943 1508 90E0      		ldi r25,hi8(statusIpStr)
 3944 150a 1496      		adiw r26,3+1
 3945 150c 9C93      		st X,r25
 3946 150e 8E93      		st -X,r24
 3947 1510 1397      		sbiw r26,3
 3948 1512 0E94 0000 		call fprintf_P
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 3950               	.LM325:
 3951 1516 0F90      		pop __tmp_reg__
 3952 1518 0F90      		pop __tmp_reg__
 3953 151a 0F90      		pop __tmp_reg__
 3954 151c 0F90      		pop __tmp_reg__
 3955 151e 0E94 0000 		call ipGetConfig
 3956 1522 FC01      		movw r30,r24
 3957 1524 4081      		ld r20,Z
 3958 1526 5181      		ldd r21,Z+1
 3959 1528 6281      		ldd r22,Z+2
 3960 152a 7381      		ldd r23,Z+3
 3961 152c CE01      		movw r24,r28
 3962 152e 0E94 0000 		call netPrintIPAddr
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3964               	.LM326:
 3965 1532 00D0      		rcall .
 3966 1534 00D0      		rcall .
 3967 1536 EDB7      		in r30,__SP_L__
 3968 1538 FEB7      		in r31,__SP_H__
 3969 153a D283      		std Z+2,r29
 3970 153c C183      		std Z+1,r28
 3971 153e 80E0      		ldi r24,lo8(__c.3194)
 3972 1540 90E0      		ldi r25,hi8(__c.3194)
 3973 1542 9483      		std Z+4,r25
 3974 1544 8383      		std Z+3,r24
 3975 1546 0E94 0000 		call fprintf_P
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 3977               	.LM327:
 3978 154a ADB7      		in r26,__SP_L__
 3979 154c BEB7      		in r27,__SP_H__
 3980 154e 1296      		adiw r26,1+1
 3981 1550 DC93      		st X,r29
 3982 1552 CE93      		st -X,r28
 3983 1554 1197      		sbiw r26,1
 3984 1556 80E0      		ldi r24,lo8(statusIpMaskStr)
 3985 1558 90E0      		ldi r25,hi8(statusIpMaskStr)
 3986 155a 1496      		adiw r26,3+1
 3987 155c 9C93      		st X,r25
 3988 155e 8E93      		st -X,r24
 3989 1560 1397      		sbiw r26,3
 3990 1562 0E94 0000 		call fprintf_P
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 3992               	.LM328:
 3993 1566 0F90      		pop __tmp_reg__
 3994 1568 0F90      		pop __tmp_reg__
 3995 156a 0F90      		pop __tmp_reg__
 3996 156c 0F90      		pop __tmp_reg__
 3997 156e 0E94 0000 		call ipGetConfig
 3998 1572 FC01      		movw r30,r24
 3999 1574 4481      		ldd r20,Z+4
 4000 1576 5581      		ldd r21,Z+5
 4001 1578 6681      		ldd r22,Z+6
 4002 157a 7781      		ldd r23,Z+7
 4003 157c CE01      		movw r24,r28
 4004 157e 0E94 0000 		call netPrintIPAddr
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4006               	.LM329:
 4007 1582 00D0      		rcall .
 4008 1584 00D0      		rcall .
 4009 1586 ADB7      		in r26,__SP_L__
 4010 1588 BEB7      		in r27,__SP_H__
 4011 158a 1296      		adiw r26,1+1
 4012 158c DC93      		st X,r29
 4013 158e CE93      		st -X,r28
 4014 1590 1197      		sbiw r26,1
 4015 1592 80E0      		ldi r24,lo8(__c.3196)
 4016 1594 90E0      		ldi r25,hi8(__c.3196)
 4017 1596 1496      		adiw r26,3+1
 4018 1598 9C93      		st X,r25
 4019 159a 8E93      		st -X,r24
 4020 159c 1397      		sbiw r26,3
 4021 159e 0E94 0000 		call fprintf_P
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 4023               	.LM330:
 4024 15a2 EDB7      		in r30,__SP_L__
 4025 15a4 FEB7      		in r31,__SP_H__
 4026 15a6 D283      		std Z+2,r29
 4027 15a8 C183      		std Z+1,r28
 4028 15aa 80E0      		ldi r24,lo8(statusIpGwStr)
 4029 15ac 90E0      		ldi r25,hi8(statusIpGwStr)
 4030 15ae 9483      		std Z+4,r25
 4031 15b0 8383      		std Z+3,r24
 4032 15b2 0E94 0000 		call fprintf_P
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 4034               	.LM331:
 4035 15b6 0F90      		pop __tmp_reg__
 4036 15b8 0F90      		pop __tmp_reg__
 4037 15ba 0F90      		pop __tmp_reg__
 4038 15bc 0F90      		pop __tmp_reg__
 4039 15be 0E94 0000 		call ipGetConfig
 4040 15c2 DC01      		movw r26,r24
 4041 15c4 1896      		adiw r26,8
 4042 15c6 4D91      		ld r20,X+
 4043 15c8 5D91      		ld r21,X+
 4044 15ca 6D91      		ld r22,X+
 4045 15cc 7C91      		ld r23,X
 4046 15ce 1B97      		sbiw r26,8+3
 4047 15d0 CE01      		movw r24,r28
 4048 15d2 0E94 0000 		call netPrintIPAddr
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4050               	.LM332:
 4051 15d6 00D0      		rcall .
 4052 15d8 00D0      		rcall .
 4053 15da EDB7      		in r30,__SP_L__
 4054 15dc FEB7      		in r31,__SP_H__
 4055 15de D283      		std Z+2,r29
 4056 15e0 C183      		std Z+1,r28
 4057 15e2 80E0      		ldi r24,lo8(__c.3198)
 4058 15e4 90E0      		ldi r25,hi8(__c.3198)
 4059 15e6 9483      		std Z+4,r25
 4060 15e8 8383      		std Z+3,r24
 4061 15ea 0E94 0000 		call fprintf_P
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 4063               	.LM333:
 4064 15ee ADB7      		in r26,__SP_L__
 4065 15f0 BEB7      		in r27,__SP_H__
 4066 15f2 1296      		adiw r26,1+1
 4067 15f4 DC93      		st X,r29
 4068 15f6 CE93      		st -X,r28
 4069 15f8 1197      		sbiw r26,1
 4070 15fa 80E0      		ldi r24,lo8(statusRs485listStr)
 4071 15fc 90E0      		ldi r25,hi8(statusRs485listStr)
 4072 15fe 1496      		adiw r26,3+1
 4073 1600 9C93      		st X,r25
 4074 1602 8E93      		st -X,r24
 4075 1604 1397      		sbiw r26,3
 4076 1606 0E94 0000 		call fprintf_P
 242:vty.c         ****   tmp = printRs485devices(stream);
 4078               	.LM334:
 4079 160a 0F90      		pop __tmp_reg__
 4080 160c 0F90      		pop __tmp_reg__
 4081 160e 0F90      		pop __tmp_reg__
 4082 1610 0F90      		pop __tmp_reg__
 4083 1612 CE01      		movw r24,r28
 4084 1614 0E94 0000 		call printRs485devices
 243:vty.c         ****   if (tmp == 0)
 4086               	.LM335:
 4087 1618 8823      		tst r24
 4088 161a 01F4      		brne .L170
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 4090               	.LM336:
 4091 161c 00D0      		rcall .
 4092 161e 00D0      		rcall .
 4093 1620 EDB7      		in r30,__SP_L__
 4094 1622 FEB7      		in r31,__SP_H__
 4095 1624 D283      		std Z+2,r29
 4096 1626 C183      		std Z+1,r28
 4097 1628 80E0      		ldi r24,lo8(statusNoRs485Dev)
 4098 162a 90E0      		ldi r25,hi8(statusNoRs485Dev)
 4099 162c 9483      		std Z+4,r25
 4100 162e 8383      		std Z+3,r24
 4101 1630 0E94 0000 		call fprintf_P
 4102 1634 0F90      		pop __tmp_reg__
 4103 1636 0F90      		pop __tmp_reg__
 4104 1638 0F90      		pop __tmp_reg__
 4105 163a 0F90      		pop __tmp_reg__
 4106               	.L170:
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 4108               	.LM337:
 4109 163c 00D0      		rcall .
 4110 163e 00D0      		rcall .
 4111 1640 ADB7      		in r26,__SP_L__
 4112 1642 BEB7      		in r27,__SP_H__
 4113 1644 1296      		adiw r26,1+1
 4114 1646 DC93      		st X,r29
 4115 1648 CE93      		st -X,r28
 4116 164a 1197      		sbiw r26,1
 4117 164c 80E0      		ldi r24,lo8(statusLockerSensorsStr)
 4118 164e 90E0      		ldi r25,hi8(statusLockerSensorsStr)
 4119 1650 1496      		adiw r26,3+1
 4120 1652 9C93      		st X,r25
 4121 1654 8E93      		st -X,r24
 4122 1656 1397      		sbiw r26,3
 4123 1658 0E94 0000 		call fprintf_P
 248:vty.c         ****   tmp = printLockers(stream);
 4125               	.LM338:
 4126 165c 0F90      		pop __tmp_reg__
 4127 165e 0F90      		pop __tmp_reg__
 4128 1660 0F90      		pop __tmp_reg__
 4129 1662 0F90      		pop __tmp_reg__
 4130 1664 CE01      		movw r24,r28
 4131 1666 0E94 0000 		call printLockers
 249:vty.c         ****   if (tmp == 0)
 4133               	.LM339:
 4134 166a 8823      		tst r24
 4135 166c 01F4      		brne .L171
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 4137               	.LM340:
 4138 166e 00D0      		rcall .
 4139 1670 00D0      		rcall .
 4140 1672 EDB7      		in r30,__SP_L__
 4141 1674 FEB7      		in r31,__SP_H__
 4142 1676 D283      		std Z+2,r29
 4143 1678 C183      		std Z+1,r28
 4144 167a 80E0      		ldi r24,lo8(statusLockerSensorsDisStr)
 4145 167c 90E0      		ldi r25,hi8(statusLockerSensorsDisStr)
 4146 167e 9483      		std Z+4,r25
 4147 1680 8383      		std Z+3,r24
 4148 1682 0E94 0000 		call fprintf_P
 4149 1686 0F90      		pop __tmp_reg__
 4150 1688 0F90      		pop __tmp_reg__
 4151 168a 0F90      		pop __tmp_reg__
 4152 168c 0F90      		pop __tmp_reg__
 4153               	.L171:
 259:vty.c         ****   udpPrintStatus(stream);
 4155               	.LM341:
 4156 168e CE01      		movw r24,r28
 4157 1690 0E94 0000 		call udpPrintStatus
 4158               	/* epilogue start */
 261:vty.c         **** }
 4160               	.LM342:
 4161 1694 DF91      		pop r29
 4162 1696 CF91      		pop r28
 4163 1698 0895      		ret
 4165               	.Lscope32:
 4167               		.stabd	78,0,0
 4171               	statusFunction:
 4172               		.stabd	46,0,0
 267:vty.c         **** {
 4174               	.LM343:
 4175               	.LFBB33:
 4176 169a EF92      		push r14
 4177 169c FF92      		push r15
 4178 169e 0F93      		push r16
 4179 16a0 1F93      		push r17
 4180 16a2 DF93      		push r29
 4181 16a4 CF93      		push r28
 4182 16a6 CDB7      		in r28,__SP_L__
 4183 16a8 DEB7      		in r29,__SP_H__
 4184 16aa 2E97      		sbiw r28,14
 4185 16ac 0FB6      		in __tmp_reg__,__SREG__
 4186 16ae F894      		cli
 4187 16b0 DEBF      		out __SP_H__,r29
 4188 16b2 0FBE      		out __SREG__,__tmp_reg__
 4189 16b4 CDBF      		out __SP_L__,r28
 4190               	/* prologue: function */
 4191               	/* frame size = 14 */
 4192 16b6 7C01      		movw r14,r24
 268:vty.c         ****   if (state->argc < 1)
 4194               	.LM344:
 4195 16b8 DC01      		movw r26,r24
 4196 16ba 5996      		adiw r26,25
 4197 16bc 8C91      		ld r24,X
 4198 16be 5997      		sbiw r26,25
 4199 16c0 8823      		tst r24
 4200 16c2 01F4      		brne .L174
 270:vty.c         ****     printStatus(state->myStdInOut);
 4202               	.LM345:
 4203 16c4 5A96      		adiw r26,26
 4204 16c6 8D91      		ld r24,X+
 4205 16c8 9C91      		ld r25,X
 4206 16ca 5B97      		sbiw r26,26+1
 4207 16cc 0E94 0000 		call printStatus
 4208 16d0 00C0      		rjmp .L178
 4209               	.L174:
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 4211               	.LM346:
 4212 16d2 81E0      		ldi r24,lo8(1)
 4213 16d4 B701      		movw r22,r14
 4214 16d6 0E94 0000 		call cmdlineGetArgStr
 4215 16da 60E0      		ldi r22,lo8(fdVty)
 4216 16dc 70E0      		ldi r23,hi8(fdVty)
 4217 16de 8E01      		movw r16,r28
 4218 16e0 0F5F      		subi r16,lo8(-(1))
 4219 16e2 1F4F      		sbci r17,hi8(-(1))
 4220 16e4 A801      		movw r20,r16
 4221 16e6 23E0      		ldi r18,lo8(3)
 4222 16e8 0E94 0000 		call ramDyskOtworzPlikStdIo
 4223 16ec 8823      		tst r24
 4224 16ee 01F0      		breq .L176
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 4226               	.LM347:
 4227 16f0 F701      		movw r30,r14
 4228 16f2 028D      		ldd r16,Z+26
 4229 16f4 138D      		ldd r17,Z+27
 4230 16f6 81E0      		ldi r24,lo8(1)
 4231 16f8 B701      		movw r22,r14
 4232 16fa 0E94 0000 		call cmdlineGetArgStr
 4233 16fe 00D0      		rcall .
 4234 1700 00D0      		rcall .
 4235 1702 00D0      		rcall .
 4236 1704 EDB7      		in r30,__SP_L__
 4237 1706 FEB7      		in r31,__SP_H__
 4238 1708 3196      		adiw r30,1
 4239 170a ADB7      		in r26,__SP_L__
 4240 170c BEB7      		in r27,__SP_H__
 4241 170e 1296      		adiw r26,1+1
 4242 1710 1C93      		st X,r17
 4243 1712 0E93      		st -X,r16
 4244 1714 1197      		sbiw r26,1
 4245 1716 20E0      		ldi r18,lo8(errorOpenFile)
 4246 1718 30E0      		ldi r19,hi8(errorOpenFile)
 4247 171a 3383      		std Z+3,r19
 4248 171c 2283      		std Z+2,r18
 4249 171e 9583      		std Z+5,r25
 4250 1720 8483      		std Z+4,r24
 4251 1722 0E94 0000 		call fprintf_P
 4252 1726 24E0      		ldi r18,lo8(4)
 4253 1728 30E0      		ldi r19,hi8(4)
 4254 172a EDB7      		in r30,__SP_L__
 4255 172c FEB7      		in r31,__SP_H__
 4256 172e 3696      		adiw r30,6
 4257 1730 0FB6      		in __tmp_reg__,__SREG__
 4258 1732 F894      		cli
 4259 1734 FEBF      		out __SP_H__,r31
 4260 1736 0FBE      		out __SREG__,__tmp_reg__
 4261 1738 EDBF      		out __SP_L__,r30
 4262 173a 00C0      		rjmp .L175
 4263               	.L176:
 281:vty.c         ****   printStatus(&stream);
 4265               	.LM348:
 4266 173c C801      		movw r24,r16
 4267 173e 0E94 0000 		call printStatus
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 4269               	.LM349:
 4270 1742 C801      		movw r24,r16
 4271 1744 0E94 0000 		call ramDyskZamknijPlikStdIo
 4272               	.L178:
 4273 1748 20E0      		ldi r18,lo8(0)
 4274 174a 30E0      		ldi r19,hi8(0)
 4275               	.L175:
 284:vty.c         **** }
 4277               	.LM350:
 4278 174c C901      		movw r24,r18
 4279               	/* epilogue start */
 4280 174e 2E96      		adiw r28,14
 4281 1750 0FB6      		in __tmp_reg__,__SREG__
 4282 1752 F894      		cli
 4283 1754 DEBF      		out __SP_H__,r29
 4284 1756 0FBE      		out __SREG__,__tmp_reg__
 4285 1758 CDBF      		out __SP_L__,r28
 4286 175a CF91      		pop r28
 4287 175c DF91      		pop r29
 4288 175e 1F91      		pop r17
 4289 1760 0F91      		pop r16
 4290 1762 FF90      		pop r15
 4291 1764 EF90      		pop r14
 4292 1766 0895      		ret
 4297               	.Lscope33:
 4299               		.stabd	78,0,0
 4303               	.global	VtyInit
 4305               	VtyInit:
 4306               		.stabd	46,0,0
 160:vty.c         **** {
 4308               	.LM351:
 4309               	.LFBB34:
 4310 1768 EF92      		push r14
 4311 176a 0F93      		push r16
 4312 176c 1F93      		push r17
 4313               	/* prologue: function */
 4314               	/* frame size = 0 */
 4315 176e 9B01      		movw r18,r22
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 4317               	.LM352:
 4318 1770 60E0      		ldi r22,lo8(10240)
 4319 1772 78E2      		ldi r23,hi8(10240)
 4320 1774 40E0      		ldi r20,lo8(256)
 4321 1776 51E0      		ldi r21,hi8(256)
 4322 1778 00E0      		ldi r16,lo8(cmdListNormal)
 4323 177a 10E0      		ldi r17,hi8(cmdListNormal)
 4324 177c EE24      		clr r14
 4325 177e 0E94 0000 		call cmdStateConfigure
 4326               	/* epilogue start */
 162:vty.c         **** }
 4328               	.LM353:
 4329 1782 1F91      		pop r17
 4330 1784 0F91      		pop r16
 4331 1786 EF90      		pop r14
 4332 1788 0895      		ret
 4334               	.Lscope34:
 4336               		.stabd	78,0,0
 4337               	.global	errorOK
 4338               		.section	.progmem.data,"a",@progbits
 4341               	errorOK:
 4342 0000 416C 6C20 		.string	"All OK\r\n"
 4342      4F4B 0D0A 
 4342      00
 4343               	.global	errorNoFile
 4346               	errorNoFile:
 4347 0009 4E6F 2046 		.string	"No File\r\n"
 4347      696C 650D 
 4347      0A00 
 4348               	.global	errorxModemFrameStartTimeout
 4351               	errorxModemFrameStartTimeout:
 4352 0013 0D0A 00   		.string	"\r\n"
 4353               	.global	errorxModemByteSendTimeout
 4356               	errorxModemByteSendTimeout:
 4357 0016 0D0A 00   		.string	"\r\n"
 4358               	.global	errorxModemWrongFrameNo
 4361               	errorxModemWrongFrameNo:
 4362 0019 0D0A 00   		.string	"\r\n"
 4363               	.global	errorxModemFrameFrameNoCorrectionNotMatch
 4366               	errorxModemFrameFrameNoCorrectionNotMatch:
 4367 001c 0D0A 00   		.string	"\r\n"
 4368               	.global	errorxModemFrameCrc
 4371               	errorxModemFrameCrc:
 4372 001f 784D 6F64 		.string	"xModem CRC error\r\n"
 4372      656D 2043 
 4372      5243 2065 
 4372      7272 6F72 
 4372      0D0A 00
 4373               	.global	errorxModemRemoteSideCan
 4376               	errorxModemRemoteSideCan:
 4377 0032 5265 6D6F 		.string	"Remote side cancelled at frame no %d\r\n"
 4377      7465 2073 
 4377      6964 6520 
 4377      6361 6E63 
 4377      656C 6C65 
 4378               	.global	errorxModemUnknownResponse
 4381               	errorxModemUnknownResponse:
 4382 0059 784D 6F64 		.string	"xModem unknown response 0x%x\r\n"
 4382      656D 2075 
 4382      6E6B 6E6F 
 4382      776E 2072 
 4382      6573 706F 
 4383               	.global	errorNoRemoteDevice
 4386               	errorNoRemoteDevice:
 4387 0078 4465 7669 		.string	"Device %d is not responding (%d)\r\n"
 4387      6365 2025 
 4387      6420 6973 
 4387      206E 6F74 
 4387      2072 6573 
 4388               	.global	errorBootloaderNotResponding
 4391               	errorBootloaderNotResponding:
 4392 009b 426F 6F74 		.string	"Bootloader is not responding\r\n"
 4392      6C6F 6164 
 4392      6572 2069 
 4392      7320 6E6F 
 4392      7420 7265 
 4393               	.global	errorOpenFile
 4396               	errorOpenFile:
 4397 00ba 4361 6E27 		.string	"Can't open file %s\r\n"
 4397      7420 6F70 
 4397      656E 2066 
 4397      696C 6520 
 4397      2573 0D0A 
 4398               	.global	systemStateStr
 4401               	systemStateStr:
 4402 00cf 5379 7374 		.string	"System state:\r\n"
 4402      656D 2073 
 4402      7461 7465 
 4402      3A0D 0A00 
 4403               	.global	statusNumberOfTasksStr
 4406               	statusNumberOfTasksStr:
 4407 00df 2020 4E75 		.string	"  Number of tasks : %d\r\n"
 4407      6D62 6572 
 4407      206F 6620 
 4407      7461 736B 
 4407      7320 3A20 
 4408               	.global	statusStaticHeapStateStr
 4411               	statusStaticHeapStateStr:
 4412 00f8 2020 4672 		.string	"  FreeRtos heap   : %d free of %d bytes\r\n"
 4412      6565 5274 
 4412      6F73 2068 
 4412      6561 7020 
 4412      2020 3A20 
 4413               	.global	statusDynamicHeapStateStr
 4416               	statusDynamicHeapStateStr:
 4417 0122 2020 4D61 		.string	"  Malloc heap     : %d free of %d bytes\r\n"
 4417      6C6C 6F63 
 4417      2068 6561 
 4417      7020 2020 
 4417      2020 3A20 
 4418               	.global	statusRamDiskStateStr
 4421               	statusRamDiskStateStr:
 4422 014c 2020 5261 		.string	"  Ram disc space  : %d free of %d clusters\r\n"
 4422      6D20 6469 
 4422      7363 2073 
 4422      7061 6365 
 4422      2020 3A20 
 4423               	.global	statusTemperatureStr
 4426               	statusTemperatureStr:
 4427 0179 2020 5465 		.string	"  Temperature     : %d C\r\n"
 4427      6D70 6572 
 4427      6174 7572 
 4427      6520 2020 
 4427      2020 3A20 
 4428               	.global	statusVoltageStr
 4431               	statusVoltageStr:
 4432 0194 2020 566F 		.string	"  Voltage         : %d V\r\n"
 4432      6C74 6167 
 4432      6520 2020 
 4432      2020 2020 
 4432      2020 3A20 
 4433               	.global	systemRamConfigStr
 4436               	systemRamConfigStr:
 4437 01af 5379 7374 		.string	"System settings:\r\n"
 4437      656D 2073 
 4437      6574 7469 
 4437      6E67 733A 
 4437      0D0A 00
 4438               	.global	statusMacStr
 4441               	statusMacStr:
 4442 01c2 2020 4D61 		.string	"  Mac address     : "
 4442      6320 6164 
 4442      6472 6573 
 4442      7320 2020 
 4442      2020 3A20 
 4443               	.global	statusIpStr
 4446               	statusIpStr:
 4447 01d7 2020 4950 		.string	"  IP address      : "
 4447      2061 6464 
 4447      7265 7373 
 4447      2020 2020 
 4447      2020 3A20 
 4448               	.global	statusIpMaskStr
 4451               	statusIpMaskStr:
 4452 01ec 2020 6D61 		.string	"  mask            : "
 4452      736B 2020 
 4452      2020 2020 
 4452      2020 2020 
 4452      2020 3A20 
 4453               	.global	statusIpGwStr
 4456               	statusIpGwStr:
 4457 0201 2020 6761 		.string	"  gateway         : "
 4457      7465 7761 
 4457      7920 2020 
 4457      2020 2020 
 4457      2020 3A20 
 4458               	.global	statusRs485listStr
 4461               	statusRs485listStr:
 4462 0216 4465 7465 		.string	"Detected RS 485 devices:\r\n"
 4462      6374 6564 
 4462      2052 5320 
 4462      3438 3520 
 4462      6465 7669 
 4463               	.global	statusNoRs485Dev
 4466               	statusNoRs485Dev:
 4467 0231 2020 4361 		.string	"  Can't find any device\r\n"
 4467      6E27 7420 
 4467      6669 6E64 
 4467      2061 6E79 
 4467      2064 6576 
 4468               	.global	statusLockerSensorsStr
 4471               	statusLockerSensorsStr:
 4472 024b 4C6F 636B 		.string	"Locker sensors states:\r\n"
 4472      6572 2073 
 4472      656E 736F 
 4472      7273 2073 
 4472      7461 7465 
 4473               	.global	statusLockerSensorsDisStr
 4476               	statusLockerSensorsDisStr:
 4477 0264 2020 4C6F 		.string	"  Locker sensors disabled\r\n"
 4477      636B 6572 
 4477      2073 656E 
 4477      736F 7273 
 4477      2064 6973 
 4478               	.global	editRamFileIntroStr
 4481               	editRamFileIntroStr:
 4482 0280 5772 6974 		.string	"Writing to file. Press CTRL+C to quit\r\n"
 4482      696E 6720 
 4482      746F 2066 
 4482      696C 652E 
 4482      2050 7265 
 4483               	.global	readRamFIleLenStr
 4486               	readRamFIleLenStr:
 4487 02a8 4669 6C65 		.string	"File length: %d\r\n"
 4487      206C 656E 
 4487      6774 683A 
 4487      2025 640D 
 4487      0A00 
 4488               	.global	xwyslijStartStr
 4491               	xwyslijStartStr:
 4492 02ba 586D 6F64 		.string	"Xmodem: Transmission start\r\n"
 4492      656D 3A20 
 4492      5472 616E 
 4492      736D 6973 
 4492      7369 6F6E 
 4493               	.global	movingCurtainUpStr
 4496               	movingCurtainUpStr:
 4497 02d7 506F 646E 		.string	"Podnoszenie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4497      6F73 7A65 
 4497      6E69 6520 
 4497      726F 6C65 
 4497      7479 0D0A 
 4498               	.global	movingCurtainDownStr
 4501               	movingCurtainDownStr:
 4502 030a 4F70 7573 		.string	"Opuszczanie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4502      7A63 7A61 
 4502      6E69 6520 
 4502      726F 6C65 
 4502      7479 0D0A 
 4503               	.global	movingCurtainPosStr
 4506               	movingCurtainPosStr:
 4507 033d 0970 6F7A 		.string	"\tpozycja   %d\r\n"
 4507      7963 6A61 
 4507      2020 2025 
 4507      640D 0A00 
 4508               	.global	debugEnabledInfoStr
 4511               	debugEnabledInfoStr:
 4512 034d 456E 6162 		.string	"Enabled %s debug\r\n"
 4512      6C65 6420 
 4512      2573 2064 
 4512      6562 7567 
 4512      0D0A 00
 4513               	.global	debugDisabledInfoStr
 4516               	debugDisabledInfoStr:
 4517 0360 4469 7361 		.string	"Disabled %s debug\r\n"
 4517      626C 6564 
 4517      2025 7320 
 4517      6465 6275 
 4517      670D 0A00 
 4518               	.global	cmd_help
 4521               	cmd_help:
 4522 0374 6865 6C70 		.string	"help"
 4522      00
 4523               	.global	cmd_help_help
 4526               	cmd_help_help:
 4527 0379 5072 696E 		.string	"Print help string"
 4527      7420 6865 
 4527      6C70 2073 
 4527      7472 696E 
 4527      6700 
 4528               	.global	cmd_status
 4531               	cmd_status:
 4532 038b 7374 6174 		.string	"status"
 4532      7573 00
 4533               	.global	cmd_help_status
 4536               	cmd_help_status:
 4537 0392 7B66 696C 		.string	"{filename} Print device status on VTY or write to file"
 4537      656E 616D 
 4537      657D 2050 
 4537      7269 6E74 
 4537      2064 6576 
 4538               	.global	cmd_enc_stat
 4541               	cmd_enc_stat:
 4542 03c9 656E 6373 		.string	"encstat"
 4542      7461 7400 
 4543               	.global	cmd_help_enc_stat
 4546               	cmd_help_enc_stat:
 4547 03d1 5072 696E 		.string	"Print Enc 28j60 registers"
 4547      7420 456E 
 4547      6320 3238 
 4547      6A36 3020 
 4547      7265 6769 
 4548               	.global	cmd_time
 4551               	cmd_time:
 4552 03eb 7469 6D65 		.string	"time"
 4552      00
 4553               	.global	cmd_help_time
 4556               	cmd_help_time:
 4557 03f0 5072 696E 		.string	"Print time"
 4557      7420 7469 
 4557      6D65 00
 4558               	.global	cmd_net_dbg
 4561               	cmd_net_dbg:
 4562 03fb 6465 6275 		.string	"debug"
 4562      6700 
 4563               	.global	cmd_help_net_dbg
 4566               	cmd_help_net_dbg:
 4567 0401 5B61 7270 		.ascii	"[arp|icm"
 4567      7C69 636D 
 4568 0409 707C 6970 		.string	"p|ip|tcp|udp] [level] write debug info. Level 0 disable debuging"
 4568      7C74 6370 
 4568      7C75 6470 
 4568      5D20 5B6C 
 4568      6576 656C 
 4569               	.global	cmd_rping
 4572               	cmd_rping:
 4573 044a 7270 696E 		.string	"rping"
 4573      6700 
 4574               	.global	cmd_help_rping
 4577               	cmd_help_rping:
 4578 0450 5B44 6576 		.string	"[Device no] Send ping to Rs485 device"
 4578      6963 6520 
 4578      6E6F 5D20 
 4578      5365 6E64 
 4578      2070 696E 
 4579               	.global	cmd_ping
 4582               	cmd_ping:
 4583 0476 7069 6E67 		.string	"ping"
 4583      00
 4584               	.global	cmd_help_ping
 4587               	cmd_help_ping:
 4588 047b 5B41 315D 		.string	"[A1] [A2] [A3] [A4] Sends ping throught ethernet"
 4588      205B 4132 
 4588      5D20 5B41 
 4588      335D 205B 
 4588      4134 5D20 
 4589               	.global	cmd_xRec
 4592               	cmd_xRec:
 4593 04ac 7872 6563 		.string	"xrec"
 4593      00
 4594               	.global	cmd_help_xRec
 4597               	cmd_help_xRec:
 4598 04b1 5B66 696C 		.string	"[file name] receive file using xModem"
 4598      6520 6E61 
 4598      6D65 5D20 
 4598      7265 6365 
 4598      6976 6520 
 4599               	.global	cmd_xSend
 4602               	cmd_xSend:
 4603 04d7 7873 656E 		.string	"xsend"
 4603      6400 
 4604               	.global	cmd_help_xSend
 4607               	cmd_help_xSend:
 4608 04dd 5B66 696C 		.string	"[file name] send file using xModem"
 4608      6520 6E61 
 4608      6D65 5D20 
 4608      7365 6E64 
 4608      2066 696C 
 4609               	.global	cmd_xflash
 4612               	cmd_xflash:
 4613 0500 7866 6C61 		.string	"xflash"
 4613      7368 00
 4614               	.global	cmd_help_xflash
 4617               	cmd_help_xflash:
 4618 0507 5B64 6576 		.string	"[device no] [file name] flash device connected to Rs485"
 4618      6963 6520 
 4618      6E6F 5D20 
 4618      5B66 696C 
 4618      6520 6E61 
 4619               	.global	cmd_dir_rf
 4622               	cmd_dir_rf:
 4623 053f 6469 7272 		.string	"dirrf"
 4623      6600 
 4624               	.global	cmd_help_dir_rf
 4627               	cmd_help_dir_rf:
 4628 0545 5072 696E 		.string	"Print ramdisk files"
 4628      7420 7261 
 4628      6D64 6973 
 4628      6B20 6669 
 4628      6C65 7300 
 4629               	.global	cmd_create_rf
 4632               	cmd_create_rf:
 4633 0559 6372 6600 		.string	"crf"
 4634               	.global	cmd_help_create_rf
 4637               	cmd_help_create_rf:
 4638 055d 5B66 696C 		.string	"[file name] create ram file"
 4638      6520 6E61 
 4638      6D65 5D20 
 4638      6372 6561 
 4638      7465 2072 
 4639               	.global	cmd_erase_rf
 4642               	cmd_erase_rf:
 4643 0579 6572 6173 		.string	"eraserf"
 4643      6572 6600 
 4644               	.global	cmd_help_erase_rf
 4647               	cmd_help_erase_rf:
 4648 0581 5B66 696C 		.string	"[file name] erase file from ram disk"
 4648      6520 6E61 
 4648      6D65 5D20 
 4648      6572 6173 
 4648      6520 6669 
 4649               	.global	cmd_edit_rf
 4652               	cmd_edit_rf:
 4653 05a6 6564 6974 		.string	"editrf"
 4653      7266 00
 4654               	.global	cmd_help_edit_rf
 4657               	cmd_help_edit_rf:
 4658 05ad 5B66 696C 		.string	"[file name] edit file located on ram disk"
 4658      6520 6E61 
 4658      6D65 5D20 
 4658      6564 6974 
 4658      2066 696C 
 4659               	.global	cmd_read_rf
 4662               	cmd_read_rf:
 4663 05d7 7265 6164 		.string	"readrf"
 4663      7266 00
 4664               	.global	cmd_help_read_rf
 4667               	cmd_help_read_rf:
 4668 05de 5B66 696C 		.string	"[file name] read file located on ram disk"
 4668      6520 6E61 
 4668      6D65 5D20 
 4668      7265 6164 
 4668      2066 696C 
 4669               	.global	cmd_up
 4672               	cmd_up:
 4673 0608 7570 00   		.string	"up"
 4674               	.global	cmd_help_up
 4677               	cmd_help_up:
 4678 060b 5B64 7269 		.string	"[driver no] [channel] {value} move up"
 4678      7665 7220 
 4678      6E6F 5D20 
 4678      5B63 6861 
 4678      6E6E 656C 
 4679               	.global	cmd_down
 4682               	cmd_down:
 4683 0631 646F 776E 		.string	"down"
 4683      00
 4684               	.global	cmd_help_down
 4687               	cmd_help_down:
 4688 0636 5B64 7269 		.string	"[driver no] [channel] {value} move down"
 4688      7665 7220 
 4688      6E6F 5D20 
 4688      5B63 6861 
 4688      6E6E 656C 
 4689               	.global	cmd_spa
 4692               	cmd_spa:
 4693 065e 7370 6100 		.string	"spa"
 4694               	.global	cmd_help_spa
 4697               	cmd_help_spa:
 4698 0662 5B76 616C 		.string	"[value] set port A"
 4698      7565 5D20 
 4698      7365 7420 
 4698      706F 7274 
 4698      2041 00
 4699               	.global	cmd_spb
 4702               	cmd_spb:
 4703 0675 7370 6200 		.string	"spb"
 4704               	.global	cmd_help_spb
 4707               	cmd_help_spb:
 4708 0679 5B76 616C 		.string	"[value] set port B"
 4708      7565 5D20 
 4708      7365 7420 
 4708      706F 7274 
 4708      2042 00
 4709               	.global	cmd_settime
 4712               	cmd_settime:
 4713 068c 7365 7474 		.string	"settime"
 4713      696D 6500 
 4714               	.global	cmd_help_settime
 4717               	cmd_help_settime:
 4718 0694 5B68 5D20 		.string	"[h] [m] [s] set time (24h format)"
 4718      5B6D 5D20 
 4718      5B73 5D20 
 4718      7365 7420 
 4718      7469 6D65 
 4719               	.global	cmd_ac
 4722               	cmd_ac:
 4723 06b6 6163 00   		.string	"ac"
 4724               	.global	cmd_help_ac
 4727               	cmd_help_ac:
 4728 06b9 5B63 6861 		.string	"[channel 0-7] read analog value"
 4728      6E6E 656C 
 4728      2030 2D37 
 4728      5D20 7265 
 4728      6164 2061 
 4729               	.global	cmd_enable
 4732               	cmd_enable:
 4733 06d9 656E 6162 		.string	"enable"
 4733      6C65 00
 4734               	.global	cmd_help_enable
 4737               	cmd_help_enable:
 4738 06e0 456E 6162 		.string	"Enable mode"
 4738      6C65 206D 
 4738      6F64 6500 
 4739               	.global	cmd_disable
 4742               	cmd_disable:
 4743 06ec 6469 7361 		.string	"disable"
 4743      626C 6500 
 4744               	.global	cmd_help_disable
 4747               	cmd_help_disable:
 4748 06f4 5669 6577 		.string	"View mode"
 4748      206D 6F64 
 4748      6500 
 4749               	.global	cmd_configure
 4752               	cmd_configure:
 4753 06fe 636F 6E66 		.string	"config"
 4753      6967 00
 4754               	.global	cmd_help_configure
 4757               	cmd_help_configure:
 4758 0705 436F 6E66 		.string	"Configure mode"
 4758      6967 7572 
 4758      6520 6D6F 
 4758      6465 00
 4759               	.global	cmd_conf_ip
 4762               	cmd_conf_ip:
 4763 0714 6970 00   		.string	"ip"
 4764               	.global	cmd_help_conf_ip
 4767               	cmd_help_conf_ip:
 4768 0717 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set IP address"
 4768      205B 4132 
 4768      5D20 5B41 
 4768      335D 205B 
 4768      4134 5D20 
 4769               	.global	cmd_conf_udp
 4772               	cmd_conf_udp:
 4773 073a 7564 7000 		.string	"udp"
 4774               	.global	cmd_help_conf_udp
 4777               	cmd_help_conf_udp:
 4778 073e 5B41 315D 		.ascii	"[A1] [A2] [A3"
 4778      205B 4132 
 4778      5D20 5B41 
 4778      33
 4779 074b 5D20 5B41 		.string	"] [A4] [src port] {dst port} set udp client IP address and ports"
 4779      345D 205B 
 4779      7372 6320 
 4779      706F 7274 
 4779      5D20 7B64 
 4780               	.global	cmd_conf_ip_mask
 4783               	cmd_conf_ip_mask:
 4784 078c 6D61 736B 		.string	"mask"
 4784      00
 4785               	.global	cmd_conf_ip_mask_help
 4788               	cmd_conf_ip_mask_help:
 4789 0791 5B6D 6173 		.string	"[mask] set mask"
 4789      6B5D 2073 
 4789      6574 206D 
 4789      6173 6B00 
 4790               	.global	cmd_conf_ip_gw
 4793               	cmd_conf_ip_gw:
 4794 07a1 6777 00   		.string	"gw"
 4795               	.global	cmd_conf_ip_gw_help
 4798               	cmd_conf_ip_gw_help:
 4799 07a4 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set default gateway"
 4799      205B 4132 
 4799      5D20 5B41 
 4799      335D 205B 
 4799      4134 5D20 
 4800               	.global	cmd_conf_mac
 4803               	cmd_conf_mac:
 4804 07cc 6D61 6300 		.string	"mac"
 4805               	.global	cmd_help_conf_mac
 4808               	cmd_help_conf_mac:
 4809 07d0 5B41 315D 		.string	"[A1] [A2] [A3] [A4] [A5] [A6] set MAC address"
 4809      205B 4132 
 4809      5D20 5B41 
 4809      335D 205B 
 4809      4134 5D20 
 4810               	.global	cmd_conf_save
 4813               	cmd_conf_save:
 4814 07fe 7361 7665 		.string	"save"
 4814      00
 4815               	.global	cmd_help_conf_save
 4818               	cmd_help_conf_save:
 4819 0803 5361 7665 		.string	"Save configuration"
 4819      2063 6F6E 
 4819      6669 6775 
 4819      7261 7469 
 4819      6F6E 00
 4820               	.global	cmd_ustawR
 4823               	cmd_ustawR:
 4824 0816 7365 7472 		.string	"setr"
 4824      00
 4825               	.global	cmd_help_ustawR
 4828               	cmd_help_ustawR:
 4829 081b 5B76 616C 		.string	"[value] set resistance value"
 4829      7565 5D20 
 4829      7365 7420 
 4829      7265 7369 
 4829      7374 616E 
 4830               	.global	okStr
 4833               	okStr:
 4834 0838 4F4B 0D0A 		.string	"OK\r\n"
 4834      00
 4835               	.global	nlStr
 4838               	nlStr:
 4839 083d 0D0A 00   		.string	"\r\n"
 4840               	.global	BladBuforaPozostaloBajtowStr
 4843               	BladBuforaPozostaloBajtowStr:
 4844 0840 2121 2120 		.string	"!!! W budorze Rs485 pozostalo %d bajtow\r\n"
 4844      5720 6275 
 4844      646F 727A 
 4844      6520 5273 
 4844      3438 3520 
 4845               	.global	errorStrings
 4848               	errorStrings:
 4849 086a 0000      		.word	errorOK
 4850 086c 0000      		.word	errorNoFile
 4851 086e 0000      		.word	errorxModemFrameStartTimeout
 4852 0870 0000      		.word	errorxModemByteSendTimeout
 4853 0872 0000      		.word	errorxModemWrongFrameNo
 4854 0874 0000      		.word	errorxModemFrameFrameNoCorrectionNotMatch
 4855 0876 0000      		.word	errorxModemFrameCrc
 4856 0878 0000      		.word	errorxModemRemoteSideCan
 4857 087a 0000      		.word	errorxModemUnknownResponse
 4858 087c 0000      		.word	errorNoRemoteDevice
 4859 087e 0000      		.word	errorBootloaderNotResponding
 4860 0880 0000      		.word	errorOpenFile
 4861               	.global	cmdListNormal
 4864               	cmdListNormal:
 4865 0882 0000      		.word	cmd_help
 4866 0884 0000      		.word	cmd_help_help
 4867 0886 0000      		.word	gs(helpFunction)
 4868 0888 0000      		.word	cmd_status
 4869 088a 0000      		.word	cmd_help_status
 4870 088c 0000      		.word	gs(statusFunction)
 4871 088e 0000      		.word	cmd_time
 4872 0890 0000      		.word	cmd_help_time
 4873 0892 0000      		.word	gs(pokazCzasFunction)
 4874 0894 0000      		.word	cmd_rping
 4875 0896 0000      		.word	cmd_help_rping
 4876 0898 0000      		.word	gs(rpingFunction)
 4877 089a 0000      		.word	cmd_ping
 4878 089c 0000      		.word	cmd_help_ping
 4879 089e 0000      		.word	gs(pingFunction)
 4880 08a0 0000      		.word	cmd_dir_rf
 4881 08a2 0000      		.word	cmd_help_dir_rf
 4882 08a4 0000      		.word	gs(writeRamFileFunction)
 4883 08a6 0000      		.word	cmd_read_rf
 4884 08a8 0000      		.word	cmd_help_read_rf
 4885 08aa 0000      		.word	gs(readRamFIleFunction)
 4886 08ac 0000      		.word	cmd_enable
 4887 08ae 0000      		.word	cmd_help_enable
 4888 08b0 0000      		.word	gs(enableFunction)
 4889 08b2 0000      		.word	0
 4890 08b4 0000      		.word	0
 4891 08b6 0000      		.word	0
 4892               	.global	cmdListEnable
 4895               	cmdListEnable:
 4896 08b8 0000      		.word	cmd_help
 4897 08ba 0000      		.word	cmd_help_help
 4898 08bc 0000      		.word	gs(helpFunction)
 4899 08be 0000      		.word	cmd_status
 4900 08c0 0000      		.word	cmd_help_status
 4901 08c2 0000      		.word	gs(statusFunction)
 4902 08c4 0000      		.word	cmd_enc_stat
 4903 08c6 0000      		.word	cmd_help_enc_stat
 4904 08c8 0000      		.word	gs(statusEncFunction)
 4905 08ca 0000      		.word	cmd_time
 4906 08cc 0000      		.word	cmd_help_time
 4907 08ce 0000      		.word	gs(pokazCzasFunction)
 4908 08d0 0000      		.word	cmd_net_dbg
 4909 08d2 0000      		.word	cmd_help_net_dbg
 4910 08d4 0000      		.word	gs(debugFunction)
 4911 08d6 0000      		.word	cmd_rping
 4912 08d8 0000      		.word	cmd_help_rping
 4913 08da 0000      		.word	gs(rpingFunction)
 4914 08dc 0000      		.word	cmd_ping
 4915 08de 0000      		.word	cmd_help_ping
 4916 08e0 0000      		.word	gs(pingFunction)
 4917 08e2 0000      		.word	cmd_xRec
 4918 08e4 0000      		.word	cmd_help_xRec
 4919 08e6 0000      		.word	gs(goXmodemOdbierzFunction)
 4920 08e8 0000      		.word	cmd_xSend
 4921 08ea 0000      		.word	cmd_help_xSend
 4922 08ec 0000      		.word	gs(goXmodemWyslijFunction)
 4923 08ee 0000      		.word	cmd_xflash
 4924 08f0 0000      		.word	cmd_help_xflash
 4925 08f2 0000      		.word	gs(flashExModuleFunction)
 4926 08f4 0000      		.word	cmd_dir_rf
 4927 08f6 0000      		.word	cmd_help_dir_rf
 4928 08f8 0000      		.word	gs(writeRamFileFunction)
 4929 08fa 0000      		.word	cmd_create_rf
 4930 08fc 0000      		.word	cmd_help_create_rf
 4931 08fe 0000      		.word	gs(dodajRamPlikFunction)
 4932 0900 0000      		.word	cmd_erase_rf
 4933 0902 0000      		.word	cmd_help_erase_rf
 4934 0904 0000      		.word	gs(eraseRamFileFunction)
 4935 0906 0000      		.word	cmd_edit_rf
 4936 0908 0000      		.word	cmd_help_edit_rf
 4937 090a 0000      		.word	gs(editRamFileFunction)
 4938 090c 0000      		.word	cmd_read_rf
 4939 090e 0000      		.word	cmd_help_read_rf
 4940 0910 0000      		.word	gs(readRamFIleFunction)
 4941 0912 0000      		.word	cmd_up
 4942 0914 0000      		.word	cmd_help_up
 4943 0916 0000      		.word	gs(curtainUpFunction)
 4944 0918 0000      		.word	cmd_down
 4945 091a 0000      		.word	cmd_help_down
 4946 091c 0000      		.word	gs(curtainDownFunction)
 4947 091e 0000      		.word	cmd_spa
 4948 0920 0000      		.word	cmd_help_spa
 4949 0922 0000      		.word	gs(ustawPortExtAFunction)
 4950 0924 0000      		.word	cmd_spb
 4951 0926 0000      		.word	cmd_help_spb
 4952 0928 0000      		.word	gs(ustawPortExtBFunction)
 4953 092a 0000      		.word	cmd_ustawR
 4954 092c 0000      		.word	cmd_help_ustawR
 4955 092e 0000      		.word	gs(ustawPortRezystor)
 4956 0930 0000      		.word	cmd_settime
 4957 0932 0000      		.word	cmd_help_settime
 4958 0934 0000      		.word	gs(setTimeFunction)
 4959 0936 0000      		.word	cmd_ac
 4960 0938 0000      		.word	cmd_help_ac
 4961 093a 0000      		.word	gs(czytajAC_Function)
 4962 093c 0000      		.word	cmd_disable
 4963 093e 0000      		.word	cmd_help_disable
 4964 0940 0000      		.word	gs(disableFunction)
 4965 0942 0000      		.word	cmd_configure
 4966 0944 0000      		.word	cmd_help_configure
 4967 0946 0000      		.word	gs(configureModeFunction)
 4968 0948 0000      		.word	0
 4969 094a 0000      		.word	0
 4970 094c 0000      		.word	0
 4971               	.global	cmdListConfigure
 4974               	cmdListConfigure:
 4975 094e 0000      		.word	cmd_help
 4976 0950 0000      		.word	cmd_help_help
 4977 0952 0000      		.word	gs(helpFunction)
 4978 0954 0000      		.word	cmd_status
 4979 0956 0000      		.word	cmd_help_status
 4980 0958 0000      		.word	gs(statusFunction)
 4981 095a 0000      		.word	cmd_time
 4982 095c 0000      		.word	cmd_help_time
 4983 095e 0000      		.word	gs(pokazCzasFunction)
 4984 0960 0000      		.word	cmd_settime
 4985 0962 0000      		.word	cmd_help_settime
 4986 0964 0000      		.word	gs(setTimeFunction)
 4987 0966 0000      		.word	cmd_conf_ip
 4988 0968 0000      		.word	cmd_help_conf_ip
 4989 096a 0000      		.word	gs(setIpFunction)
 4990 096c 0000      		.word	cmd_conf_ip_mask
 4991 096e 0000      		.word	cmd_conf_ip_mask_help
 4992 0970 0000      		.word	gs(setIpMaskFunction)
 4993 0972 0000      		.word	cmd_conf_ip_gw
 4994 0974 0000      		.word	cmd_conf_ip_gw_help
 4995 0976 0000      		.word	gs(setIpGwFunction)
 4996 0978 0000      		.word	cmd_conf_udp
 4997 097a 0000      		.word	cmd_help_conf_udp
 4998 097c 0000      		.word	gs(setUdpFunction)
 4999 097e 0000      		.word	cmd_conf_mac
 5000 0980 0000      		.word	cmd_help_conf_mac
 5001 0982 0000      		.word	gs(setMacAddrFunction)
 5002 0984 0000      		.word	cmd_conf_save
 5003 0986 0000      		.word	cmd_help_conf_save
 5004 0988 0000      		.word	gs(saveConfigFunction)
 5005 098a 0000      		.word	cmd_enable
 5006 098c 0000      		.word	cmd_help_enable
 5007 098e 0000      		.word	gs(enableFunction)
 5008 0990 0000      		.word	cmd_disable
 5009 0992 0000      		.word	cmd_help_disable
 5010 0994 0000      		.word	gs(disableFunction)
 5011 0996 0000      		.word	0
 5012 0998 0000      		.word	0
 5013 099a 0000      		.word	0
 5016               	__c.3417:
 5017 099c 5761 7274 		.string	"Wartosc probki na wejsciu %d: %d\r\n"
 5017      6F73 6320 
 5017      7072 6F62 
 5017      6B69 206E 
 5017      6120 7765 
 5020               	__c.3535:
 5021 09bf 586D 6F64 		.string	"Xmodem: rozpoczynanie odbioru\r\n"
 5021      656D 3A20 
 5021      726F 7A70 
 5021      6F63 7A79 
 5021      6E61 6E69 
 5024               	__c.3287:
 5025 09df 7564 7000 		.string	"udp"
 5028               	__c.3285:
 5029 09e3 7463 7000 		.string	"tcp"
 5032               	__c.3283:
 5033 09e7 6963 6D70 		.string	"icmp"
 5033      00
 5036               	__c.3281:
 5037 09ec 6970 00   		.string	"ip"
 5040               	__c.3279:
 5041 09ef 6172 7000 		.string	"arp"
 5044               	__c.3277:
 5045 09f3 7564 7000 		.string	"udp"
 5048               	__c.3275:
 5049 09f7 7463 7000 		.string	"tcp"
 5052               	__c.3273:
 5053 09fb 6963 6D70 		.string	"icmp"
 5053      00
 5056               	__c.3271:
 5057 0a00 6970 00   		.string	"ip"
 5060               	__c.3269:
 5061 0a03 6172 7000 		.string	"arp"
 5064               	__c.3239:
 5065 0a07 416B 7475 		.string	"Aktualny czas %d:%d:%d\r\n"
 5065      616C 6E79 
 5065      2063 7A61 
 5065      7320 2564 
 5065      3A25 643A 
 5068               	__c.3198:
 5069 0a20 0D0A 00   		.string	"\r\n"
 5072               	__c.3196:
 5073 0a23 0D0A 00   		.string	"\r\n"
 5076               	__c.3194:
 5077 0a26 0D0A 00   		.string	"\r\n"
 5080               	__c.3192:
 5081 0a29 0D0A 00   		.string	"\r\n"
 5084               	__c.3189:
 5085 0a2c 4672 6565 		.string	"FreeRtos+ ver 0.31 build: Jul 17 2011, 18:37:49\r\n"
 5085      5274 6F73 
 5085      2B20 7665 
 5085      7220 302E 
 5085      3331 2062 
 5086               		.comm klastry,128,1
 5087               		.comm wwwport,1,1
 5088               		.comm rollers,2,1
 5089               		.comm xSemaphoreSpiSS,2,1
 5090               		.comm portA,1,1
 5091               		.comm portB,1,1
 5092               		.comm lockSensors,2,1
 5093               		.comm xSemaphoreRs485,2,1
 5094               		.comm nicState,14,1
 5095               		.comm IpMyConfig,15,1
 5096               		.comm arpDebug,2,1
 5097               		.comm arpDebugLevel,1,1
 5098               		.comm icmpDebug,2,1
 5099               		.comm icmpDebugLevel,1,1
 5100               		.comm udpSocket,2,1
 5101               		.comm udpDbgStream,2,1
 5102               		.comm udpDbgLevel,1,1
 5103               		.comm tcpDebugStream,2,1
 5104               		.comm tcpDebugLevel,1,1
 5105               		.comm sockets,2,1
 5106               		.comm czasRtc,7,1
 5107               		.comm fdVty,6,1
 5253               		.weak	nicRegDump
 5254               		.weak	nicSetMacAddress
 5255               		.text
 5257               	.Letext0:
 5258               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 vty.c
     /tmp/cc9SmhaC.s:2      *ABS*:0000003f __SREG__
     /tmp/cc9SmhaC.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc9SmhaC.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc9SmhaC.s:5      *ABS*:00000034 __CCP__
     /tmp/cc9SmhaC.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc9SmhaC.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc9SmhaC.s:254    .text:00000000 enableFunction
     /tmp/cc9SmhaC.s:4895   .progmem.data:000008b8 cmdListEnable
     /tmp/cc9SmhaC.s:296    .text:00000022 disableFunction
     /tmp/cc9SmhaC.s:4864   .progmem.data:00000882 cmdListNormal
     /tmp/cc9SmhaC.s:332    .text:0000003a configureModeFunction
     /tmp/cc9SmhaC.s:4974   .progmem.data:0000094e cmdListConfigure
     /tmp/cc9SmhaC.s:374    .text:0000005c saveConfigFunction
     /tmp/cc9SmhaC.s:397    .text:00000066 setMacAddrFunction
                            *COM*:0000000e nicState
     /tmp/cc9SmhaC.s:474    .text:000000d4 pingFunction
     /tmp/cc9SmhaC.s:530    .text:00000112 setUdpFunction
                            *COM*:00000002 udpSocket
     /tmp/cc9SmhaC.s:678    .text:0000020c setIpGwFunction
     /tmp/cc9SmhaC.s:786    .text:000002bc setIpMaskFunction
     /tmp/cc9SmhaC.s:841    .text:000002fc setIpFunction
     /tmp/cc9SmhaC.s:949    .text:000003ac czytajAC_Function
     /tmp/cc9SmhaC.s:5016   .progmem.data:0000099c __c.3417
     /tmp/cc9SmhaC.s:1030   .text:00000424 printErrorInfo
     /tmp/cc9SmhaC.s:4848   .progmem.data:0000086a errorStrings
     /tmp/cc9SmhaC.s:1127   .text:0000049a setTimeFunction
                            *COM*:00000007 czasRtc
     /tmp/cc9SmhaC.s:1263   .text:00000568 ustawPortRezystor
     /tmp/cc9SmhaC.s:1304   .text:0000058c ustawPortExtBFunction
     /tmp/cc9SmhaC.s:1342   .text:000005b0 ustawPortExtAFunction
     /tmp/cc9SmhaC.s:1380   .text:000005d4 curtainDownFunction
     /tmp/cc9SmhaC.s:4501   .progmem.data:0000030a movingCurtainDownStr
     /tmp/cc9SmhaC.s:4506   .progmem.data:0000033d movingCurtainPosStr
     /tmp/cc9SmhaC.s:1534   .text:000006c0 curtainUpFunction
     /tmp/cc9SmhaC.s:4496   .progmem.data:000002d7 movingCurtainUpStr
     /tmp/cc9SmhaC.s:1706   .text:000007c4 goXmodemWyslijFunction
     /tmp/cc9SmhaC.s:4491   .progmem.data:000002ba xwyslijStartStr
                            *COM*:00000006 fdVty
     /tmp/cc9SmhaC.s:4396   .progmem.data:000000ba errorOpenFile
     /tmp/cc9SmhaC.s:1808   .text:00000868 editRamFileFunction
     /tmp/cc9SmhaC.s:4481   .progmem.data:00000280 editRamFileIntroStr
     /tmp/cc9SmhaC.s:1968   .text:00000968 eraseRamFileFunction
     /tmp/cc9SmhaC.s:2011   .text:00000996 dodajRamPlikFunction
     /tmp/cc9SmhaC.s:2063   .text:000009d0 rpingFunction
     /tmp/cc9SmhaC.s:2130   .text:00000a1c flashExModuleFunction
     /tmp/cc9SmhaC.s:2267   .text:00000ade goXmodemOdbierzFunction
     /tmp/cc9SmhaC.s:5020   .progmem.data:000009bf __c.3535
     /tmp/cc9SmhaC.s:2953   .text:00000ec6 debugFunction
     /tmp/cc9SmhaC.s:5060   .progmem.data:00000a03 __c.3269
     /tmp/cc9SmhaC.s:5056   .progmem.data:00000a00 __c.3271
     /tmp/cc9SmhaC.s:5052   .progmem.data:000009fb __c.3273
     /tmp/cc9SmhaC.s:5048   .progmem.data:000009f7 __c.3275
     /tmp/cc9SmhaC.s:4516   .progmem.data:00000360 debugDisabledInfoStr
     /tmp/cc9SmhaC.s:5044   .progmem.data:000009f3 __c.3277
     /tmp/cc9SmhaC.s:5040   .progmem.data:000009ef __c.3279
     /tmp/cc9SmhaC.s:5036   .progmem.data:000009ec __c.3281
     /tmp/cc9SmhaC.s:5032   .progmem.data:000009e7 __c.3283
     /tmp/cc9SmhaC.s:5028   .progmem.data:000009e3 __c.3285
     /tmp/cc9SmhaC.s:4511   .progmem.data:0000034d debugEnabledInfoStr
     /tmp/cc9SmhaC.s:5024   .progmem.data:000009df __c.3287
     /tmp/cc9SmhaC.s:3244   .text:00001090 statusEncFunction
     /tmp/cc9SmhaC.s:3270   .text:000010a0 readRamFIleFunction
     /tmp/cc9SmhaC.s:4486   .progmem.data:000002a8 readRamFIleLenStr
     /tmp/cc9SmhaC.s:4838   .progmem.data:0000083d nlStr
     /tmp/cc9SmhaC.s:3469   .text:000011e6 writeRamFileFunction
     /tmp/cc9SmhaC.s:3495   .text:000011f6 pokazCzasFunction
     /tmp/cc9SmhaC.s:5064   .progmem.data:00000a07 __c.3239
     /tmp/cc9SmhaC.s:3631   .text:000012e0 helpFunction
     /tmp/cc9SmhaC.s:3655   .text:000012ea printStatus
     /tmp/cc9SmhaC.s:5084   .progmem.data:00000a2c __c.3189
     /tmp/cc9SmhaC.s:4401   .progmem.data:000000cf systemStateStr
     /tmp/cc9SmhaC.s:4406   .progmem.data:000000df statusNumberOfTasksStr
     /tmp/cc9SmhaC.s:4411   .progmem.data:000000f8 statusStaticHeapStateStr
     /tmp/cc9SmhaC.s:4416   .progmem.data:00000122 statusDynamicHeapStateStr
     /tmp/cc9SmhaC.s:4426   .progmem.data:00000179 statusTemperatureStr
     /tmp/cc9SmhaC.s:4431   .progmem.data:00000194 statusVoltageStr
     /tmp/cc9SmhaC.s:4421   .progmem.data:0000014c statusRamDiskStateStr
     /tmp/cc9SmhaC.s:4436   .progmem.data:000001af systemRamConfigStr
     /tmp/cc9SmhaC.s:4441   .progmem.data:000001c2 statusMacStr
     /tmp/cc9SmhaC.s:5080   .progmem.data:00000a29 __c.3192
     /tmp/cc9SmhaC.s:4446   .progmem.data:000001d7 statusIpStr
     /tmp/cc9SmhaC.s:5076   .progmem.data:00000a26 __c.3194
     /tmp/cc9SmhaC.s:4451   .progmem.data:000001ec statusIpMaskStr
     /tmp/cc9SmhaC.s:5072   .progmem.data:00000a23 __c.3196
     /tmp/cc9SmhaC.s:4456   .progmem.data:00000201 statusIpGwStr
     /tmp/cc9SmhaC.s:5068   .progmem.data:00000a20 __c.3198
     /tmp/cc9SmhaC.s:4461   .progmem.data:00000216 statusRs485listStr
     /tmp/cc9SmhaC.s:4466   .progmem.data:00000231 statusNoRs485Dev
     /tmp/cc9SmhaC.s:4471   .progmem.data:0000024b statusLockerSensorsStr
     /tmp/cc9SmhaC.s:4476   .progmem.data:00000264 statusLockerSensorsDisStr
     /tmp/cc9SmhaC.s:4171   .text:0000169a statusFunction
     /tmp/cc9SmhaC.s:4305   .text:00001768 VtyInit
     /tmp/cc9SmhaC.s:4341   .progmem.data:00000000 errorOK
     /tmp/cc9SmhaC.s:4346   .progmem.data:00000009 errorNoFile
     /tmp/cc9SmhaC.s:4351   .progmem.data:00000013 errorxModemFrameStartTimeout
     /tmp/cc9SmhaC.s:4356   .progmem.data:00000016 errorxModemByteSendTimeout
     /tmp/cc9SmhaC.s:4361   .progmem.data:00000019 errorxModemWrongFrameNo
     /tmp/cc9SmhaC.s:4366   .progmem.data:0000001c errorxModemFrameFrameNoCorrectionNotMatch
     /tmp/cc9SmhaC.s:4371   .progmem.data:0000001f errorxModemFrameCrc
     /tmp/cc9SmhaC.s:4376   .progmem.data:00000032 errorxModemRemoteSideCan
     /tmp/cc9SmhaC.s:4381   .progmem.data:00000059 errorxModemUnknownResponse
     /tmp/cc9SmhaC.s:4386   .progmem.data:00000078 errorNoRemoteDevice
     /tmp/cc9SmhaC.s:4391   .progmem.data:0000009b errorBootloaderNotResponding
     /tmp/cc9SmhaC.s:4521   .progmem.data:00000374 cmd_help
     /tmp/cc9SmhaC.s:4526   .progmem.data:00000379 cmd_help_help
     /tmp/cc9SmhaC.s:4531   .progmem.data:0000038b cmd_status
     /tmp/cc9SmhaC.s:4536   .progmem.data:00000392 cmd_help_status
     /tmp/cc9SmhaC.s:4541   .progmem.data:000003c9 cmd_enc_stat
     /tmp/cc9SmhaC.s:4546   .progmem.data:000003d1 cmd_help_enc_stat
     /tmp/cc9SmhaC.s:4551   .progmem.data:000003eb cmd_time
     /tmp/cc9SmhaC.s:4556   .progmem.data:000003f0 cmd_help_time
     /tmp/cc9SmhaC.s:4561   .progmem.data:000003fb cmd_net_dbg
     /tmp/cc9SmhaC.s:4566   .progmem.data:00000401 cmd_help_net_dbg
     /tmp/cc9SmhaC.s:4572   .progmem.data:0000044a cmd_rping
     /tmp/cc9SmhaC.s:4577   .progmem.data:00000450 cmd_help_rping
     /tmp/cc9SmhaC.s:4582   .progmem.data:00000476 cmd_ping
     /tmp/cc9SmhaC.s:4587   .progmem.data:0000047b cmd_help_ping
     /tmp/cc9SmhaC.s:4592   .progmem.data:000004ac cmd_xRec
     /tmp/cc9SmhaC.s:4597   .progmem.data:000004b1 cmd_help_xRec
     /tmp/cc9SmhaC.s:4602   .progmem.data:000004d7 cmd_xSend
     /tmp/cc9SmhaC.s:4607   .progmem.data:000004dd cmd_help_xSend
     /tmp/cc9SmhaC.s:4612   .progmem.data:00000500 cmd_xflash
     /tmp/cc9SmhaC.s:4617   .progmem.data:00000507 cmd_help_xflash
     /tmp/cc9SmhaC.s:4622   .progmem.data:0000053f cmd_dir_rf
     /tmp/cc9SmhaC.s:4627   .progmem.data:00000545 cmd_help_dir_rf
     /tmp/cc9SmhaC.s:4632   .progmem.data:00000559 cmd_create_rf
     /tmp/cc9SmhaC.s:4637   .progmem.data:0000055d cmd_help_create_rf
     /tmp/cc9SmhaC.s:4642   .progmem.data:00000579 cmd_erase_rf
     /tmp/cc9SmhaC.s:4647   .progmem.data:00000581 cmd_help_erase_rf
     /tmp/cc9SmhaC.s:4652   .progmem.data:000005a6 cmd_edit_rf
     /tmp/cc9SmhaC.s:4657   .progmem.data:000005ad cmd_help_edit_rf
     /tmp/cc9SmhaC.s:4662   .progmem.data:000005d7 cmd_read_rf
     /tmp/cc9SmhaC.s:4667   .progmem.data:000005de cmd_help_read_rf
     /tmp/cc9SmhaC.s:4672   .progmem.data:00000608 cmd_up
     /tmp/cc9SmhaC.s:4677   .progmem.data:0000060b cmd_help_up
     /tmp/cc9SmhaC.s:4682   .progmem.data:00000631 cmd_down
     /tmp/cc9SmhaC.s:4687   .progmem.data:00000636 cmd_help_down
     /tmp/cc9SmhaC.s:4692   .progmem.data:0000065e cmd_spa
     /tmp/cc9SmhaC.s:4697   .progmem.data:00000662 cmd_help_spa
     /tmp/cc9SmhaC.s:4702   .progmem.data:00000675 cmd_spb
     /tmp/cc9SmhaC.s:4707   .progmem.data:00000679 cmd_help_spb
     /tmp/cc9SmhaC.s:4712   .progmem.data:0000068c cmd_settime
     /tmp/cc9SmhaC.s:4717   .progmem.data:00000694 cmd_help_settime
     /tmp/cc9SmhaC.s:4722   .progmem.data:000006b6 cmd_ac
     /tmp/cc9SmhaC.s:4727   .progmem.data:000006b9 cmd_help_ac
     /tmp/cc9SmhaC.s:4732   .progmem.data:000006d9 cmd_enable
     /tmp/cc9SmhaC.s:4737   .progmem.data:000006e0 cmd_help_enable
     /tmp/cc9SmhaC.s:4742   .progmem.data:000006ec cmd_disable
     /tmp/cc9SmhaC.s:4747   .progmem.data:000006f4 cmd_help_disable
     /tmp/cc9SmhaC.s:4752   .progmem.data:000006fe cmd_configure
     /tmp/cc9SmhaC.s:4757   .progmem.data:00000705 cmd_help_configure
     /tmp/cc9SmhaC.s:4762   .progmem.data:00000714 cmd_conf_ip
     /tmp/cc9SmhaC.s:4767   .progmem.data:00000717 cmd_help_conf_ip
     /tmp/cc9SmhaC.s:4772   .progmem.data:0000073a cmd_conf_udp
     /tmp/cc9SmhaC.s:4777   .progmem.data:0000073e cmd_help_conf_udp
     /tmp/cc9SmhaC.s:4783   .progmem.data:0000078c cmd_conf_ip_mask
     /tmp/cc9SmhaC.s:4788   .progmem.data:00000791 cmd_conf_ip_mask_help
     /tmp/cc9SmhaC.s:4793   .progmem.data:000007a1 cmd_conf_ip_gw
     /tmp/cc9SmhaC.s:4798   .progmem.data:000007a4 cmd_conf_ip_gw_help
     /tmp/cc9SmhaC.s:4803   .progmem.data:000007cc cmd_conf_mac
     /tmp/cc9SmhaC.s:4808   .progmem.data:000007d0 cmd_help_conf_mac
     /tmp/cc9SmhaC.s:4813   .progmem.data:000007fe cmd_conf_save
     /tmp/cc9SmhaC.s:4818   .progmem.data:00000803 cmd_help_conf_save
     /tmp/cc9SmhaC.s:4823   .progmem.data:00000816 cmd_ustawR
     /tmp/cc9SmhaC.s:4828   .progmem.data:0000081b cmd_help_ustawR
     /tmp/cc9SmhaC.s:4833   .progmem.data:00000838 okStr
     /tmp/cc9SmhaC.s:4843   .progmem.data:00000840 BladBuforaPozostaloBajtowStr
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets

UNDEFINED SYMBOLS
saveConfiguration
cmdlineGetArgHex
nicSetMacAddress
cmdlineGetArgInt
htons
ipSetConfigGw
ipSetConfigMask
ipSetConfigIp
MCP3008_getSampleSingle
fprintf_P
ds1305start
__udivmodqi4
setTimeDecoded
MCP4150_setValue
MPC23s17SetDirB
MPC23s17SetPortB
MPC23s17SetDirA
MPC23s17SetPortA
rs485curtainDown
rs485curtainUp
cmdlineGetArgStr
ramDyskOtworzPlik
ramDyskUstawWskaznikNaKoniec
xVtyRec
xQueueGenericReceive
uartVtySendByte
ramDyskZapiszBajtDoPliku
ramDyskZamknijPlik
ramDyskUsunPlik
ramDyskUtworzPlik
rs485ping
rs485xModemFlash
fputc
ramDyskDodajBlokXmodem
strncmp_P
setArpDebug
setIpDebug
setIcmpDebug
setTcpDebug
setUdpDebug
nicRegDump
ramDyskCzytajBajtZPliku
ramDyskDir
readTimeDecoded
cmdPrintHelp
uxTaskGetNumberOfTasks
xPortGetFreeHeapSize
xmallocAvailable
temperature
voltage
ramDyskLiczbaWolnychKlastrow
netPrintEthAddr
ipGetConfig
netPrintIPAddr
printRs485devices
printLockers
udpPrintStatus
ramDyskOtworzPlikStdIo
ramDyskZamknijPlikStdIo
cmdStateConfigure
__do_clear_bss
