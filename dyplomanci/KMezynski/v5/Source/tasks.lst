   1               		.file	"tasks.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 122               	.global	uxTaskPriorityGet
 124               	uxTaskPriorityGet:
 125               		.stabd	46,0,0
   1:Source/tasks.c **** /*
   2:Source/tasks.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:Source/tasks.c **** 
   4:Source/tasks.c ****     ***************************************************************************
   5:Source/tasks.c ****     *                                                                         *
   6:Source/tasks.c ****     * If you are:                                                             *
   7:Source/tasks.c ****     *                                                                         *
   8:Source/tasks.c ****     *    + New to FreeRTOS,                                                   *
   9:Source/tasks.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:Source/tasks.c ****     *    + Looking for basic training,                                        *
  11:Source/tasks.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:Source/tasks.c ****     *                                                                         *
  13:Source/tasks.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:Source/tasks.c ****     *                                                                         *
  15:Source/tasks.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:Source/tasks.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:Source/tasks.c ****     *                                                                         *
  18:Source/tasks.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:Source/tasks.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:Source/tasks.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:Source/tasks.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:Source/tasks.c ****     *                                                                         *
  23:Source/tasks.c ****     ***************************************************************************
  24:Source/tasks.c **** 
  25:Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:Source/tasks.c **** 
  27:Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:Source/tasks.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:Source/tasks.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:Source/tasks.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:Source/tasks.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:Source/tasks.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:Source/tasks.c ****     more details. You should have received a copy of the GNU General Public 
  37:Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:Source/tasks.c ****     FreeRTOS WEB site.
  41:Source/tasks.c **** 
  42:Source/tasks.c ****     1 tab == 4 spaces!
  43:Source/tasks.c **** 
  44:Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:Source/tasks.c ****     contact details.
  46:Source/tasks.c **** 
  47:Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:Source/tasks.c ****     critical systems.
  49:Source/tasks.c **** 
  50:Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:Source/tasks.c ****     licensing and training services.
  52:Source/tasks.c **** */
  53:Source/tasks.c **** 
  54:Source/tasks.c **** 
  55:Source/tasks.c **** #include <stdio.h>
  56:Source/tasks.c **** #include <stdlib.h>
  57:Source/tasks.c **** #include <string.h>
  58:Source/tasks.c **** 
  59:Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:Source/tasks.c **** task.h is included from an application file. */
  62:Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:Source/tasks.c **** 
  64:Source/tasks.c **** #include "FreeRTOS.h"
  65:Source/tasks.c **** #include "task.h"
  66:Source/tasks.c **** #include "StackMacros.h"
  67:Source/tasks.c **** 
  68:Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  69:Source/tasks.c **** 
  70:Source/tasks.c **** /*
  71:Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  72:Source/tasks.c ****  */
  73:Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  74:Source/tasks.c **** 
  75:Source/tasks.c **** /*
  76:Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  77:Source/tasks.c ****  * and stores the context of the task.
  78:Source/tasks.c ****  */
  79:Source/tasks.c **** typedef struct tskTaskControlBlock
  80:Source/tasks.c **** {
  81:Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  82:Source/tasks.c **** 
  83:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  84:Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  85:Source/tasks.c **** 	#endif	
  86:Source/tasks.c **** 	
  87:Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  88:Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  89:Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  90:Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  91:Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  92:Source/tasks.c **** 
  93:Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  94:Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  95:Source/tasks.c **** 	#endif
  96:Source/tasks.c **** 
  97:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  98:Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
  99:Source/tasks.c **** 	#endif
 100:Source/tasks.c **** 
 101:Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 102:Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 103:Source/tasks.c **** 	#endif
 104:Source/tasks.c **** 
 105:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 106:Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 107:Source/tasks.c **** 	#endif
 108:Source/tasks.c **** 
 109:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 110:Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 111:Source/tasks.c **** 	#endif
 112:Source/tasks.c **** 
 113:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 114:Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 115:Source/tasks.c **** 	#endif
 116:Source/tasks.c **** 
 117:Source/tasks.c **** } tskTCB;
 118:Source/tasks.c **** 
 119:Source/tasks.c **** 
 120:Source/tasks.c **** /*
 121:Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 122:Source/tasks.c ****  * than file scope.
 123:Source/tasks.c ****  */
 124:Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 125:Source/tasks.c **** 	#define static
 126:Source/tasks.c **** #endif
 127:Source/tasks.c **** 
 128:Source/tasks.c **** /*lint -e956 */
 129:Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 130:Source/tasks.c **** 
 131:Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 132:Source/tasks.c **** 
 133:Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 134:Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 135:Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 136:Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 137:Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 138:Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 139:Source/tasks.c **** 
 140:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 141:Source/tasks.c **** 
 142:Source/tasks.c **** 	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted 
 143:Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 144:Source/tasks.c **** 
 145:Source/tasks.c **** #endif
 146:Source/tasks.c **** 
 147:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 148:Source/tasks.c **** 
 149:Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 150:Source/tasks.c **** 
 151:Source/tasks.c **** #endif
 152:Source/tasks.c **** 
 153:Source/tasks.c **** /* File private variables. --------------------------------*/
 154:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 155:Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
 156:Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 157:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 158:Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 159:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 160:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 161:Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 162:Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 163:Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
 164:Source/tasks.c **** 
 165:Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 166:Source/tasks.c **** 
 167:Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 168:Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 169:Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 170:Source/tasks.c **** 
 171:Source/tasks.c **** #endif
 172:Source/tasks.c **** 
 173:Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 174:Source/tasks.c **** 
 175:Source/tasks.c **** /*
 176:Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 177:Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 178:Source/tasks.c ****  */
 179:Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5 )
 180:Source/tasks.c **** 
 181:Source/tasks.c **** /*
 182:Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 183:Source/tasks.c ****  */
 184:Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 185:Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 186:Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 187:Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 188:Source/tasks.c **** 
 189:Source/tasks.c **** /*
 190:Source/tasks.c ****  * Macros and private variables used by the trace facility.
 191:Source/tasks.c ****  */
 192:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 193:Source/tasks.c **** 
 194:Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 195:Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 196:Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 197:Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 198:Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 199:Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255;
 200:Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 201:Source/tasks.c **** 
 202:Source/tasks.c **** #endif
 203:Source/tasks.c **** 
 204:Source/tasks.c **** /*-----------------------------------------------------------*/
 205:Source/tasks.c **** 
 206:Source/tasks.c **** /*
 207:Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 208:Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 209:Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 210:Source/tasks.c ****  * it if not using the facility.
 211:Source/tasks.c ****  */
 212:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 213:Source/tasks.c **** 
 214:Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 215:Source/tasks.c **** 	{																								\
 216:Source/tasks.c **** 		if( xTracing )																				\
 217:Source/tasks.c **** 		{																							\
 218:Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 219:Source/tasks.c **** 			{																						\
 220:Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 221:Source/tasks.c **** 				{																					\
 222:Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 223:Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;		\
 224:Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 225:Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;	\
 226:Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 227:Source/tasks.c **** 				}																					\
 228:Source/tasks.c **** 				else																				\
 229:Source/tasks.c **** 				{																					\
 230:Source/tasks.c **** 					xTracing = pdFALSE;																\
 231:Source/tasks.c **** 				}																					\
 232:Source/tasks.c **** 			}																						\
 233:Source/tasks.c **** 		}																							\
 234:Source/tasks.c **** 	}
 235:Source/tasks.c **** 
 236:Source/tasks.c **** #else
 237:Source/tasks.c **** 
 238:Source/tasks.c **** 	#define vWriteTraceToBuffer()
 239:Source/tasks.c **** 
 240:Source/tasks.c **** #endif
 241:Source/tasks.c **** /*-----------------------------------------------------------*/
 242:Source/tasks.c **** 
 243:Source/tasks.c **** /*
 244:Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 245:Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 246:Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 247:Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 248:Source/tasks.c ****  * executing task has been rescheduled.
 249:Source/tasks.c ****  */
 250:Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																			\
 251:Source/tasks.c **** {																												\
 252:Source/tasks.c **** 	if( pxTCB->uxPriority > uxTopReadyPriority )																\
 253:Source/tasks.c **** 	{																											\
 254:Source/tasks.c **** 		uxTopReadyPriority = pxTCB->uxPriority;																	\
 255:Source/tasks.c **** 	}																											\
 256:Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListIte
 257:Source/tasks.c **** }
 258:Source/tasks.c **** /*-----------------------------------------------------------*/
 259:Source/tasks.c **** 
 260:Source/tasks.c **** /*
 261:Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 262:Source/tasks.c ****  * any require waking.
 263:Source/tasks.c ****  *
 264:Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 265:Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 266:Source/tasks.c ****  * any further down the list.
 267:Source/tasks.c ****  */
 268:Source/tasks.c **** #define prvCheckDelayedTasks()																						\
 269:Source/tasks.c **** {																													\
 270:Source/tasks.c **** register tskTCB *pxTCB;																								\
 271:Source/tasks.c **** 																													\
 272:Source/tasks.c **** 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
 273:Source/tasks.c **** 	{																												\
 274:Source/tasks.c **** 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
 275:Source/tasks.c **** 		{																											\
 276:Source/tasks.c **** 			break;																									\
 277:Source/tasks.c **** 		}																											\
 278:Source/tasks.c **** 		vListRemove( &( pxTCB->xGenericListItem ) );																\
 279:Source/tasks.c **** 		/* Is the task waiting on an event also? */																	\
 280:Source/tasks.c **** 		if( pxTCB->xEventListItem.pvContainer )																		\
 281:Source/tasks.c **** 		{																											\
 282:Source/tasks.c **** 			vListRemove( &( pxTCB->xEventListItem ) );																\
 283:Source/tasks.c **** 		}																											\
 284:Source/tasks.c **** 		prvAddTaskToReadyQueue( pxTCB );																			\
 285:Source/tasks.c **** 	}																												\
 286:Source/tasks.c **** }
 287:Source/tasks.c **** /*-----------------------------------------------------------*/
 288:Source/tasks.c **** 
 289:Source/tasks.c **** /*
 290:Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 291:Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 292:Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 293:Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 294:Source/tasks.c ****  */
 295:Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskT
 296:Source/tasks.c **** 
 297:Source/tasks.c **** 
 298:Source/tasks.c **** /* File private functions. --------------------------------*/
 299:Source/tasks.c **** 
 300:Source/tasks.c **** /*
 301:Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 302:Source/tasks.c ****  * into the TCB structure.
 303:Source/tasks.c ****  */
 304:Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 305:Source/tasks.c **** 
 306:Source/tasks.c **** /*
 307:Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 308:Source/tasks.c ****  * automatically upon the creation of the first task.
 309:Source/tasks.c ****  */
 310:Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 311:Source/tasks.c **** 
 312:Source/tasks.c **** /*
 313:Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 314:Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 315:Source/tasks.c ****  * creation of the first user task.
 316:Source/tasks.c ****  *
 317:Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 318:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 319:Source/tasks.c ****  *
 320:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 321:Source/tasks.c ****  *
 322:Source/tasks.c ****  */
 323:Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 324:Source/tasks.c **** 
 325:Source/tasks.c **** /*
 326:Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 327:Source/tasks.c ****  * including the stack pointed to by the TCB.
 328:Source/tasks.c ****  *
 329:Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 330:Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 331:Source/tasks.c ****  */
 332:Source/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
 333:Source/tasks.c **** 
 334:Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 335:Source/tasks.c **** 
 336:Source/tasks.c **** #endif
 337:Source/tasks.c **** 
 338:Source/tasks.c **** /*
 339:Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 340:Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 341:Source/tasks.c ****  * and its TCB deleted.
 342:Source/tasks.c ****  */
 343:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 344:Source/tasks.c **** 
 345:Source/tasks.c **** /*
 346:Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 347:Source/tasks.c ****  * allocation was successful.
 348:Source/tasks.c ****  */
 349:Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 350:Source/tasks.c **** 
 351:Source/tasks.c **** /*
 352:Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 353:Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 354:Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 355:Source/tasks.c ****  * within just that list.
 356:Source/tasks.c ****  *
 357:Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 358:Source/tasks.c ****  * NORMAL APPLICATION CODE.
 359:Source/tasks.c ****  */
 360:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 361:Source/tasks.c **** 
 362:Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 363:Source/tasks.c **** 
 364:Source/tasks.c **** #endif
 365:Source/tasks.c **** 
 366:Source/tasks.c **** /*
 367:Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 368:Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 369:Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 370:Source/tasks.c ****  */
 371:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 372:Source/tasks.c **** 
 373:Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 374:Source/tasks.c **** 
 375:Source/tasks.c **** #endif
 376:Source/tasks.c **** 
 377:Source/tasks.c **** 
 378:Source/tasks.c **** /*lint +e956 */
 379:Source/tasks.c **** 
 380:Source/tasks.c **** 
 381:Source/tasks.c **** 
 382:Source/tasks.c **** /*-----------------------------------------------------------
 383:Source/tasks.c ****  * TASK CREATION API documented in task.h
 384:Source/tasks.c ****  *----------------------------------------------------------*/
 385:Source/tasks.c **** 
 386:Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 387:Source/tasks.c **** {
 388:Source/tasks.c **** signed portBASE_TYPE xReturn;
 389:Source/tasks.c **** tskTCB * pxNewTCB;
 390:Source/tasks.c **** 
 391:Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 392:Source/tasks.c **** 	checking that the allocation was successful. */
 393:Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 394:Source/tasks.c **** 
 395:Source/tasks.c **** 	if( pxNewTCB != NULL )
 396:Source/tasks.c **** 	{
 397:Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 398:Source/tasks.c **** 
 399:Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 400:Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 401:Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 402:Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
 403:Source/tasks.c **** 			{
 404:Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 405:Source/tasks.c **** 			}
 406:Source/tasks.c **** 			else
 407:Source/tasks.c **** 			{
 408:Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 409:Source/tasks.c **** 			}
 410:Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 411:Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 412:Source/tasks.c **** 
 413:Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 414:Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 415:Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 416:Source/tasks.c **** 		required by the port. */
 417:Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 418:Source/tasks.c **** 		{
 419:Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 420:Source/tasks.c **** //			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long )
 421:Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( uint16_t ) pxTopOfStack ) & ( ( uint16_t ) ~portBYTE_A
 422:Source/tasks.c **** 		}
 423:Source/tasks.c **** 		#else
 424:Source/tasks.c **** 		{
 425:Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 426:Source/tasks.c **** 
 427:Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 428:Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 429:Source/tasks.c **** 			other extreme of the stack space. */
 430:Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 431:Source/tasks.c **** 		}
 432:Source/tasks.c **** 		#endif
 433:Source/tasks.c **** 
 434:Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 435:Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 436:Source/tasks.c **** 
 437:Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 438:Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 439:Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 440:Source/tasks.c **** 		the	top of stack variable is updated. */
 441:Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 442:Source/tasks.c **** 		{
 443:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 444:Source/tasks.c **** 		}
 445:Source/tasks.c **** 		#else
 446:Source/tasks.c **** 		{
 447:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 448:Source/tasks.c **** 		}
 449:Source/tasks.c **** 		#endif
 450:Source/tasks.c **** 
 451:Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 452:Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 453:Source/tasks.c **** 		portENTER_CRITICAL();
 454:Source/tasks.c **** 		{
 455:Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 456:Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 457:Source/tasks.c **** 			{
 458:Source/tasks.c **** 				/* As this is the first task it must also be the current task. */
 459:Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 460:Source/tasks.c **** 
 461:Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
 462:Source/tasks.c **** 				initialisation required.  We will not recover if this call
 463:Source/tasks.c **** 				fails, but we will report the failure. */
 464:Source/tasks.c **** 				prvInitialiseTaskLists();
 465:Source/tasks.c **** 			}
 466:Source/tasks.c **** 			else
 467:Source/tasks.c **** 			{
 468:Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 469:Source/tasks.c **** 				current task if it is the highest priority task to be created
 470:Source/tasks.c **** 				so far. */
 471:Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 472:Source/tasks.c **** 				{
 473:Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 474:Source/tasks.c **** 					{
 475:Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 476:Source/tasks.c **** 					}
 477:Source/tasks.c **** 				}
 478:Source/tasks.c **** 			}
 479:Source/tasks.c **** 
 480:Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 481:Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 482:Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 483:Source/tasks.c **** 			{
 484:Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 485:Source/tasks.c **** 			}
 486:Source/tasks.c **** 
 487:Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 488:Source/tasks.c **** 			{
 489:Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 490:Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 491:Source/tasks.c **** 			}
 492:Source/tasks.c **** 			#endif
 493:Source/tasks.c **** 			uxTaskNumber++;
 494:Source/tasks.c **** 
 495:Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 496:Source/tasks.c **** 
 497:Source/tasks.c **** 			xReturn = pdPASS;
 498:Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 499:Source/tasks.c **** 		}
 500:Source/tasks.c **** 		portEXIT_CRITICAL();
 501:Source/tasks.c **** 	}
 502:Source/tasks.c **** 	else
 503:Source/tasks.c **** 	{
 504:Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 505:Source/tasks.c **** 		traceTASK_CREATE_FAILED( pxNewTCB );
 506:Source/tasks.c **** 	}
 507:Source/tasks.c **** 
 508:Source/tasks.c **** 	if( xReturn == pdPASS )
 509:Source/tasks.c **** 	{
 510:Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 511:Source/tasks.c **** 		{
 512:Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 513:Source/tasks.c **** 			task can use this as a handle to delete the task later if
 514:Source/tasks.c **** 			required.*/
 515:Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 516:Source/tasks.c **** 		}
 517:Source/tasks.c **** 
 518:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 519:Source/tasks.c **** 		{
 520:Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 521:Source/tasks.c **** 			then it should run now. */
 522:Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 523:Source/tasks.c **** 			{
 524:Source/tasks.c **** 				portYIELD_WITHIN_API();
 525:Source/tasks.c **** 			}
 526:Source/tasks.c **** 		}
 527:Source/tasks.c **** 	}
 528:Source/tasks.c **** 
 529:Source/tasks.c **** 	return xReturn;
 530:Source/tasks.c **** }
 531:Source/tasks.c **** /*-----------------------------------------------------------*/
 532:Source/tasks.c **** 
 533:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 534:Source/tasks.c **** 
 535:Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 536:Source/tasks.c **** 	{
 537:Source/tasks.c **** 	tskTCB *pxTCB;
 538:Source/tasks.c **** 
 539:Source/tasks.c **** 		portENTER_CRITICAL();
 540:Source/tasks.c **** 		{
 541:Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 542:Source/tasks.c **** 			deleted. */
 543:Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 544:Source/tasks.c **** 			{
 545:Source/tasks.c **** 				pxTaskToDelete = NULL;
 546:Source/tasks.c **** 			}
 547:Source/tasks.c **** 
 548:Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 549:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 550:Source/tasks.c **** 
 551:Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 552:Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 553:Source/tasks.c **** 			the termination list and free up any memory allocated by the
 554:Source/tasks.c **** 			scheduler for the TCB and stack. */
 555:Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 556:Source/tasks.c **** 
 557:Source/tasks.c **** 			/* Is the task waiting on an event also? */
 558:Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 559:Source/tasks.c **** 			{
 560:Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 561:Source/tasks.c **** 			}
 562:Source/tasks.c **** 
 563:Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 564:Source/tasks.c **** 
 565:Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 566:Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 567:Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 568:Source/tasks.c **** 			++uxTasksDeleted;
 569:Source/tasks.c **** 
 570:Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 571:Source/tasks.c **** 			can detect that the task lists need re-generating. */
 572:Source/tasks.c **** 			uxTaskNumber++;
 573:Source/tasks.c **** 
 574:Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 575:Source/tasks.c **** 		}
 576:Source/tasks.c **** 		portEXIT_CRITICAL();
 577:Source/tasks.c **** 
 578:Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 579:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 580:Source/tasks.c **** 		{
 581:Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 582:Source/tasks.c **** 			{
 583:Source/tasks.c **** 				portYIELD_WITHIN_API();
 584:Source/tasks.c **** 			}
 585:Source/tasks.c **** 		}
 586:Source/tasks.c **** 	}
 587:Source/tasks.c **** 
 588:Source/tasks.c **** #endif
 589:Source/tasks.c **** 
 590:Source/tasks.c **** 
 591:Source/tasks.c **** 
 592:Source/tasks.c **** 
 593:Source/tasks.c **** 
 594:Source/tasks.c **** 
 595:Source/tasks.c **** /*-----------------------------------------------------------
 596:Source/tasks.c ****  * TASK CONTROL API documented in task.h
 597:Source/tasks.c ****  *----------------------------------------------------------*/
 598:Source/tasks.c **** 
 599:Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 600:Source/tasks.c **** 
 601:Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 602:Source/tasks.c **** 	{
 603:Source/tasks.c **** 	portTickType xTimeToWake;
 604:Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 605:Source/tasks.c **** 
 606:Source/tasks.c **** 		vTaskSuspendAll();
 607:Source/tasks.c **** 		{
 608:Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 609:Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 610:Source/tasks.c **** 
 611:Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 612:Source/tasks.c **** 			{
 613:Source/tasks.c **** 				/* The tick count has overflowed since this function was
 614:Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 615:Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 616:Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 617:Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 618:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 619:Source/tasks.c **** 				{
 620:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 621:Source/tasks.c **** 				}
 622:Source/tasks.c **** 			}
 623:Source/tasks.c **** 			else
 624:Source/tasks.c **** 			{
 625:Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 626:Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 627:Source/tasks.c **** 				tick time is less than the wake time. */
 628:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 629:Source/tasks.c **** 				{
 630:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 631:Source/tasks.c **** 				}
 632:Source/tasks.c **** 			}
 633:Source/tasks.c **** 
 634:Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 635:Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 636:Source/tasks.c **** 
 637:Source/tasks.c **** 			if( xShouldDelay )
 638:Source/tasks.c **** 			{
 639:Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 640:Source/tasks.c **** 
 641:Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 642:Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 643:Source/tasks.c **** 				both lists. */
 644:Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 645:Source/tasks.c **** 
 646:Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 647:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 648:Source/tasks.c **** 
 649:Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 650:Source/tasks.c **** 				{
 651:Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 652:Source/tasks.c **** 					overflow list. */
 653:Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 654:Source/tasks.c **** 				}
 655:Source/tasks.c **** 				else
 656:Source/tasks.c **** 				{
 657:Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 658:Source/tasks.c **** 					current block list. */
 659:Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 660:Source/tasks.c **** 				}
 661:Source/tasks.c **** 			}
 662:Source/tasks.c **** 		}
 663:Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 664:Source/tasks.c **** 
 665:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 666:Source/tasks.c **** 		have put ourselves to sleep. */
 667:Source/tasks.c **** 		if( !xAlreadyYielded )
 668:Source/tasks.c **** 		{
 669:Source/tasks.c **** 			portYIELD_WITHIN_API();
 670:Source/tasks.c **** 		}
 671:Source/tasks.c **** 	}
 672:Source/tasks.c **** 
 673:Source/tasks.c **** #endif
 674:Source/tasks.c **** /*-----------------------------------------------------------*/
 675:Source/tasks.c **** 
 676:Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 677:Source/tasks.c **** 
 678:Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 679:Source/tasks.c **** 	{
 680:Source/tasks.c **** 	portTickType xTimeToWake;
 681:Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 682:Source/tasks.c **** 
 683:Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 684:Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 685:Source/tasks.c **** 		{
 686:Source/tasks.c **** 			vTaskSuspendAll();
 687:Source/tasks.c **** 			{
 688:Source/tasks.c **** 				traceTASK_DELAY();
 689:Source/tasks.c **** 
 690:Source/tasks.c **** 				/* A task that is removed from the event list while the
 691:Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 692:Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 693:Source/tasks.c **** 				is resumed.
 694:Source/tasks.c **** 
 695:Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 696:Source/tasks.c **** 				executing task. */
 697:Source/tasks.c **** 
 698:Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 699:Source/tasks.c **** 				not a problem. */
 700:Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 701:Source/tasks.c **** 
 702:Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 703:Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 704:Source/tasks.c **** 				both lists. */
 705:Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 706:Source/tasks.c **** 
 707:Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 708:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 709:Source/tasks.c **** 
 710:Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 711:Source/tasks.c **** 				{
 712:Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 713:Source/tasks.c **** 					overflow list. */
 714:Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 715:Source/tasks.c **** 				}
 716:Source/tasks.c **** 				else
 717:Source/tasks.c **** 				{
 718:Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 719:Source/tasks.c **** 					current block list. */
 720:Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 721:Source/tasks.c **** 				}
 722:Source/tasks.c **** 			}
 723:Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 724:Source/tasks.c **** 		}
 725:Source/tasks.c **** 
 726:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 727:Source/tasks.c **** 		have put ourselves to sleep. */
 728:Source/tasks.c **** 		if( !xAlreadyYielded )
 729:Source/tasks.c **** 		{
 730:Source/tasks.c **** 			portYIELD_WITHIN_API();
 731:Source/tasks.c **** 		}
 732:Source/tasks.c **** 	}
 733:Source/tasks.c **** 
 734:Source/tasks.c **** #endif
 735:Source/tasks.c **** /*-----------------------------------------------------------*/
 736:Source/tasks.c **** 
 737:Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 738:Source/tasks.c **** 
 739:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 740:Source/tasks.c **** 	{
 127               	.LM0:
 128               	.LFBB1:
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 741:Source/tasks.c **** 	tskTCB *pxTCB;
 742:Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 743:Source/tasks.c **** 
 744:Source/tasks.c **** 		portENTER_CRITICAL();
 132               	.LM1:
 133               	/* #APP */
 134               	 ;  744 "Source/tasks.c" 1
 135 0000 0FB6      		in		__tmp_reg__, __SREG__
 136               	 ;  0 "" 2
 137               	 ;  744 "Source/tasks.c" 1
 138 0002 F894      		cli
 139               	 ;  0 "" 2
 140               	 ;  744 "Source/tasks.c" 1
 141 0004 0F92      		push	__tmp_reg__
 142               	 ;  0 "" 2
 745:Source/tasks.c **** 		{
 746:Source/tasks.c **** 			/* If null is passed in here then we are changing the
 747:Source/tasks.c **** 			priority of the calling function. */
 748:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 144               	.LM2:
 145               	/* #NOAPP */
 146 0006 0097      		sbiw r24,0
 147 0008 01F4      		brne .L2
 148 000a E091 0000 		lds r30,pxCurrentTCB
 149 000e F091 0000 		lds r31,(pxCurrentTCB)+1
 150 0012 00C0      		rjmp .L3
 151               	.L2:
 152 0014 FC01      		movw r30,r24
 153               	.L3:
 749:Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 750:Source/tasks.c **** 		}
 751:Source/tasks.c **** 		portEXIT_CRITICAL();
 155               	.LM3:
 156               	/* #APP */
 157               	 ;  751 "Source/tasks.c" 1
 158 0016 0F90      		pop		__tmp_reg__
 159               	 ;  0 "" 2
 160               	 ;  751 "Source/tasks.c" 1
 161 0018 0FBE      		out		__SREG__, __tmp_reg__
 162               	 ;  0 "" 2
 752:Source/tasks.c **** 
 753:Source/tasks.c **** 		return uxReturn;
 754:Source/tasks.c **** 	}
 164               	.LM4:
 165               	/* #NOAPP */
 166 001a 8689      		ldd r24,Z+22
 167               	/* epilogue start */
 168 001c 0895      		ret
 173               	.Lscope1:
 175               		.stabd	78,0,0
 177               	.global	xTaskIsTaskSuspended
 179               	xTaskIsTaskSuspended:
 180               		.stabd	46,0,0
 755:Source/tasks.c **** 
 756:Source/tasks.c **** #endif
 757:Source/tasks.c **** /*-----------------------------------------------------------*/
 758:Source/tasks.c **** 
 759:Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 760:Source/tasks.c **** 
 761:Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 762:Source/tasks.c **** 	{
 763:Source/tasks.c **** 	tskTCB *pxTCB;
 764:Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
 765:Source/tasks.c **** 
 766:Source/tasks.c **** 		/* Ensure the new priority is valid. */
 767:Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 768:Source/tasks.c **** 		{
 769:Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - 1;
 770:Source/tasks.c **** 		}
 771:Source/tasks.c **** 
 772:Source/tasks.c **** 		portENTER_CRITICAL();
 773:Source/tasks.c **** 		{
 774:Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 775:Source/tasks.c **** 			{
 776:Source/tasks.c **** 				pxTask = NULL;
 777:Source/tasks.c **** 			}
 778:Source/tasks.c **** 
 779:Source/tasks.c **** 			/* If null is passed in here then we are changing the
 780:Source/tasks.c **** 			priority of the calling function. */
 781:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 782:Source/tasks.c **** 
 783:Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 784:Source/tasks.c **** 
 785:Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 786:Source/tasks.c **** 			{
 787:Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 788:Source/tasks.c **** 			}
 789:Source/tasks.c **** 			#else
 790:Source/tasks.c **** 			{
 791:Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 792:Source/tasks.c **** 			}
 793:Source/tasks.c **** 			#endif
 794:Source/tasks.c **** 
 795:Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 796:Source/tasks.c **** 			{
 797:Source/tasks.c **** 				/* The priority change may have readied a task of higher
 798:Source/tasks.c **** 				priority than the calling task. */
 799:Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 800:Source/tasks.c **** 				{
 801:Source/tasks.c **** 					if( pxTask != NULL )
 802:Source/tasks.c **** 					{
 803:Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 804:Source/tasks.c **** 						were raising the priority of the currently running task
 805:Source/tasks.c **** 						there would be no need to switch as it must have already
 806:Source/tasks.c **** 						been the highest priority task. */
 807:Source/tasks.c **** 						xYieldRequired = pdTRUE;
 808:Source/tasks.c **** 					}
 809:Source/tasks.c **** 				}
 810:Source/tasks.c **** 				else if( pxTask == NULL )
 811:Source/tasks.c **** 				{
 812:Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 813:Source/tasks.c **** 					task of higher priority that is ready to execute. */
 814:Source/tasks.c **** 					xYieldRequired = pdTRUE;
 815:Source/tasks.c **** 				}
 816:Source/tasks.c **** 
 817:Source/tasks.c **** 
 818:Source/tasks.c **** 
 819:Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 820:Source/tasks.c **** 				{
 821:Source/tasks.c **** 					/* Only change the priority being used if the task is not
 822:Source/tasks.c **** 					currently using an inherited priority. */
 823:Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 824:Source/tasks.c **** 					{
 825:Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 826:Source/tasks.c **** 					}
 827:Source/tasks.c **** 
 828:Source/tasks.c **** 					/* The base priority gets set whatever. */
 829:Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 830:Source/tasks.c **** 				}
 831:Source/tasks.c **** 				#else
 832:Source/tasks.c **** 				{
 833:Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 834:Source/tasks.c **** 				}
 835:Source/tasks.c **** 				#endif
 836:Source/tasks.c **** 
 837:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 838:Source/tasks.c **** 
 839:Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 840:Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 841:Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 842:Source/tasks.c **** 				in the queue appropriate to its new priority. */
 843:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 844:Source/tasks.c **** 				{
 845:Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 846:Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 847:Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 848:Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 849:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 850:Source/tasks.c **** 				}
 851:Source/tasks.c **** 
 852:Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 853:Source/tasks.c **** 				{
 854:Source/tasks.c **** 					portYIELD_WITHIN_API();
 855:Source/tasks.c **** 				}
 856:Source/tasks.c **** 			}
 857:Source/tasks.c **** 		}
 858:Source/tasks.c **** 		portEXIT_CRITICAL();
 859:Source/tasks.c **** 	}
 860:Source/tasks.c **** 
 861:Source/tasks.c **** #endif
 862:Source/tasks.c **** /*-----------------------------------------------------------*/
 863:Source/tasks.c **** 
 864:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 865:Source/tasks.c **** 
 866:Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 867:Source/tasks.c **** 	{
 868:Source/tasks.c **** 	tskTCB *pxTCB;
 869:Source/tasks.c **** 
 870:Source/tasks.c **** 		portENTER_CRITICAL();
 871:Source/tasks.c **** 		{
 872:Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 873:Source/tasks.c **** 			suspended. */
 874:Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 875:Source/tasks.c **** 			{
 876:Source/tasks.c **** 				pxTaskToSuspend = NULL;
 877:Source/tasks.c **** 			}
 878:Source/tasks.c **** 
 879:Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 880:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 881:Source/tasks.c **** 
 882:Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 883:Source/tasks.c **** 
 884:Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 885:Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 886:Source/tasks.c **** 
 887:Source/tasks.c **** 			/* Is the task waiting on an event also? */
 888:Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 889:Source/tasks.c **** 			{
 890:Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 891:Source/tasks.c **** 			}
 892:Source/tasks.c **** 
 893:Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 894:Source/tasks.c **** 		}
 895:Source/tasks.c **** 		portEXIT_CRITICAL();
 896:Source/tasks.c **** 
 897:Source/tasks.c **** 		/* We may have just suspended the current task. */
 898:Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 899:Source/tasks.c **** 		{
 900:Source/tasks.c **** 			portYIELD_WITHIN_API();
 901:Source/tasks.c **** 		}
 902:Source/tasks.c **** 	}
 903:Source/tasks.c **** 
 904:Source/tasks.c **** #endif
 905:Source/tasks.c **** /*-----------------------------------------------------------*/
 906:Source/tasks.c **** 
 907:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 908:Source/tasks.c **** 
 909:Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 910:Source/tasks.c **** 	{
 182               	.LM5:
 183               	.LFBB2:
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 911:Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 912:Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 187               	.LM6:
 188 001e FC01      		movw r30,r24
 913:Source/tasks.c **** 
 914:Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 915:Source/tasks.c **** 		suspended list? */
 916:Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 190               	.LM7:
 191 0020 8285      		ldd r24,Z+10
 192 0022 9385      		ldd r25,Z+11
 193 0024 8050      		subi r24,lo8(xSuspendedTaskList)
 194 0026 9040      		sbci r25,hi8(xSuspendedTaskList)
 195 0028 01F4      		brne .L6
 917:Source/tasks.c **** 		{
 918:Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 919:Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 197               	.LM8:
 198 002a 8489      		ldd r24,Z+20
 199 002c 9589      		ldd r25,Z+21
 200 002e 20E0      		ldi r18,hi8(xPendingReadyList)
 201 0030 8030      		cpi r24,lo8(xPendingReadyList)
 202 0032 9207      		cpc r25,r18
 203 0034 01F0      		breq .L6
 204 0036 20E0      		ldi r18,lo8(0)
 205 0038 892B      		or r24,r25
 206 003a 01F4      		brne .L8
 207 003c 21E0      		ldi r18,lo8(1)
 208 003e 00C0      		rjmp .L8
 209               	.L6:
 210 0040 20E0      		ldi r18,lo8(0)
 211               	.L8:
 920:Source/tasks.c **** 			{
 921:Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 922:Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 923:Source/tasks.c **** 				list because it is blocked on a task with no timeout
 924:Source/tasks.c **** 				specified. */
 925:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 926:Source/tasks.c **** 				{
 927:Source/tasks.c **** 					xReturn = pdTRUE;
 928:Source/tasks.c **** 				}
 929:Source/tasks.c **** 			}
 930:Source/tasks.c **** 		}
 931:Source/tasks.c **** 
 932:Source/tasks.c **** 		return xReturn;
 933:Source/tasks.c **** 	}
 213               	.LM9:
 214 0042 822F      		mov r24,r18
 215               	/* epilogue start */
 216 0044 0895      		ret
 221               	.Lscope2:
 223               		.stabd	78,0,0
 225               	.global	vTaskSuspendAll
 227               	vTaskSuspendAll:
 228               		.stabd	46,0,0
 934:Source/tasks.c **** 
 935:Source/tasks.c **** #endif
 936:Source/tasks.c **** /*-----------------------------------------------------------*/
 937:Source/tasks.c **** 
 938:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 939:Source/tasks.c **** 
 940:Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 941:Source/tasks.c **** 	{
 942:Source/tasks.c **** 	tskTCB *pxTCB;
 943:Source/tasks.c **** 
 944:Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 945:Source/tasks.c **** 		it in the ready list. */
 946:Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 947:Source/tasks.c **** 
 948:Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 949:Source/tasks.c **** 		currently executing task. */
 950:Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 951:Source/tasks.c **** 		{
 952:Source/tasks.c **** 			portENTER_CRITICAL();
 953:Source/tasks.c **** 			{
 954:Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 955:Source/tasks.c **** 				{
 956:Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
 957:Source/tasks.c **** 
 958:Source/tasks.c **** 					/* As we are in a critical section we can access the ready
 959:Source/tasks.c **** 					lists even if the scheduler is suspended. */
 960:Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 961:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 962:Source/tasks.c **** 
 963:Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
 964:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 965:Source/tasks.c **** 					{
 966:Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 967:Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 968:Source/tasks.c **** 						portYIELD_WITHIN_API();
 969:Source/tasks.c **** 					}
 970:Source/tasks.c **** 				}
 971:Source/tasks.c **** 			}
 972:Source/tasks.c **** 			portEXIT_CRITICAL();
 973:Source/tasks.c **** 		}
 974:Source/tasks.c **** 	}
 975:Source/tasks.c **** 
 976:Source/tasks.c **** #endif
 977:Source/tasks.c **** 
 978:Source/tasks.c **** /*-----------------------------------------------------------*/
 979:Source/tasks.c **** 
 980:Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 981:Source/tasks.c **** 
 982:Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 983:Source/tasks.c **** 	{
 984:Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 985:Source/tasks.c **** 	tskTCB *pxTCB;
 986:Source/tasks.c **** 
 987:Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 988:Source/tasks.c **** 
 989:Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 990:Source/tasks.c **** 		{
 991:Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
 992:Source/tasks.c **** 
 993:Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 994:Source/tasks.c **** 			{
 995:Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 996:Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 997:Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 998:Source/tasks.c **** 			}
 999:Source/tasks.c **** 			else
1000:Source/tasks.c **** 			{
1001:Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1002:Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1003:Source/tasks.c **** 				yield will be performed if necessary. */
1004:Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1005:Source/tasks.c **** 			}
1006:Source/tasks.c **** 		}
1007:Source/tasks.c **** 
1008:Source/tasks.c **** 		return xYieldRequired;
1009:Source/tasks.c **** 	}
1010:Source/tasks.c **** 
1011:Source/tasks.c **** #endif
1012:Source/tasks.c **** 
1013:Source/tasks.c **** 
1014:Source/tasks.c **** 
1015:Source/tasks.c **** 
1016:Source/tasks.c **** /*-----------------------------------------------------------
1017:Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1018:Source/tasks.c ****  *----------------------------------------------------------*/
1019:Source/tasks.c **** 
1020:Source/tasks.c **** 
1021:Source/tasks.c **** void vTaskStartScheduler( void )
1022:Source/tasks.c **** {
1023:Source/tasks.c **** portBASE_TYPE xReturn;
1024:Source/tasks.c **** 
1025:Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1026:Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
1027:Source/tasks.c **** 
1028:Source/tasks.c **** 	if( xReturn == pdPASS )
1029:Source/tasks.c **** 	{
1030:Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1031:Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1032:Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1033:Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1034:Source/tasks.c **** 		starts to run.
1035:Source/tasks.c **** 
1036:Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1037:Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1038:Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1039:Source/tasks.c **** 
1040:Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1041:Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
1042:Source/tasks.c **** 
1043:Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1044:Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1045:Source/tasks.c **** 		the run time counter time base. */
1046:Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1047:Source/tasks.c **** 
1048:Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1049:Source/tasks.c **** 		portable interface. */
1050:Source/tasks.c **** 		if( xPortStartScheduler() )
1051:Source/tasks.c **** 		{
1052:Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1053:Source/tasks.c **** 			function will not return. */
1054:Source/tasks.c **** 		}
1055:Source/tasks.c **** 		else
1056:Source/tasks.c **** 		{
1057:Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1058:Source/tasks.c **** 		}
1059:Source/tasks.c **** 	}
1060:Source/tasks.c **** }
1061:Source/tasks.c **** /*-----------------------------------------------------------*/
1062:Source/tasks.c **** 
1063:Source/tasks.c **** void vTaskEndScheduler( void )
1064:Source/tasks.c **** {
1065:Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1066:Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1067:Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1068:Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1069:Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1070:Source/tasks.c **** 	vPortEndScheduler();
1071:Source/tasks.c **** }
1072:Source/tasks.c **** /*----------------------------------------------------------*/
1073:Source/tasks.c **** 
1074:Source/tasks.c **** void vTaskSuspendAll( void )
1075:Source/tasks.c **** {
 230               	.LM10:
 231               	.LFBB3:
 232               	/* prologue: function */
 233               	/* frame size = 0 */
1076:Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1077:Source/tasks.c **** 	portBASE_TYPE. */
1078:Source/tasks.c **** 	++uxSchedulerSuspended;
 235               	.LM11:
 236 0046 8091 0000 		lds r24,uxSchedulerSuspended
 237 004a 8F5F      		subi r24,lo8(-(1))
 238 004c 8093 0000 		sts uxSchedulerSuspended,r24
 239               	/* epilogue start */
1079:Source/tasks.c **** }
 241               	.LM12:
 242 0050 0895      		ret
 244               	.Lscope3:
 246               		.stabd	78,0,0
 248               	.global	xTaskGetTickCount
 250               	xTaskGetTickCount:
 251               		.stabd	46,0,0
1080:Source/tasks.c **** /*----------------------------------------------------------*/
1081:Source/tasks.c **** 
1082:Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1083:Source/tasks.c **** {
1084:Source/tasks.c **** register tskTCB *pxTCB;
1085:Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1086:Source/tasks.c **** 
1087:Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1088:Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1089:Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1090:Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1091:Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1092:Source/tasks.c **** 	portENTER_CRITICAL();
1093:Source/tasks.c **** 	{
1094:Source/tasks.c **** 		--uxSchedulerSuspended;
1095:Source/tasks.c **** 
1096:Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1097:Source/tasks.c **** 		{
1098:Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
1099:Source/tasks.c **** 			{
1100:Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1101:Source/tasks.c **** 
1102:Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1103:Source/tasks.c **** 				appropriate ready list. */
1104:Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
1105:Source/tasks.c **** 				{
1106:Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1107:Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1108:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1109:Source/tasks.c **** 
1110:Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1111:Source/tasks.c **** 					the current task then we should yield. */
1112:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1113:Source/tasks.c **** 					{
1114:Source/tasks.c **** 						xYieldRequired = pdTRUE;
1115:Source/tasks.c **** 					}
1116:Source/tasks.c **** 				}
1117:Source/tasks.c **** 
1118:Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1119:Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1120:Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1121:Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1122:Source/tasks.c **** 				{
1123:Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1124:Source/tasks.c **** 					{
1125:Source/tasks.c **** 						vTaskIncrementTick();
1126:Source/tasks.c **** 						--uxMissedTicks;
1127:Source/tasks.c **** 					}
1128:Source/tasks.c **** 
1129:Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1130:Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1131:Source/tasks.c **** 					the task actually running. */
1132:Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1133:Source/tasks.c **** 					{
1134:Source/tasks.c **** 						xYieldRequired = pdTRUE;
1135:Source/tasks.c **** 					}
1136:Source/tasks.c **** 					#endif
1137:Source/tasks.c **** 				}
1138:Source/tasks.c **** 
1139:Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1140:Source/tasks.c **** 				{
1141:Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1142:Source/tasks.c **** 					xMissedYield = pdFALSE;
1143:Source/tasks.c **** 					portYIELD_WITHIN_API();
1144:Source/tasks.c **** 				}
1145:Source/tasks.c **** 			}
1146:Source/tasks.c **** 		}
1147:Source/tasks.c **** 	}
1148:Source/tasks.c **** 	portEXIT_CRITICAL();
1149:Source/tasks.c **** 
1150:Source/tasks.c **** 	return xAlreadyYielded;
1151:Source/tasks.c **** }
1152:Source/tasks.c **** 
1153:Source/tasks.c **** 
1154:Source/tasks.c **** 
1155:Source/tasks.c **** 
1156:Source/tasks.c **** 
1157:Source/tasks.c **** 
1158:Source/tasks.c **** /*-----------------------------------------------------------
1159:Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1160:Source/tasks.c ****  *----------------------------------------------------------*/
1161:Source/tasks.c **** 
1162:Source/tasks.c **** 
1163:Source/tasks.c **** 
1164:Source/tasks.c **** portTickType xTaskGetTickCount( void )
1165:Source/tasks.c **** {
 253               	.LM13:
 254               	.LFBB4:
 255               	/* prologue: function */
 256               	/* frame size = 0 */
1166:Source/tasks.c **** portTickType xTicks;
1167:Source/tasks.c **** 
1168:Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1169:Source/tasks.c **** 	portENTER_CRITICAL();
 258               	.LM14:
 259               	/* #APP */
 260               	 ;  1169 "Source/tasks.c" 1
 261 0052 0FB6      		in		__tmp_reg__, __SREG__
 262               	 ;  0 "" 2
 263               	 ;  1169 "Source/tasks.c" 1
 264 0054 F894      		cli
 265               	 ;  0 "" 2
 266               	 ;  1169 "Source/tasks.c" 1
 267 0056 0F92      		push	__tmp_reg__
 268               	 ;  0 "" 2
1170:Source/tasks.c **** 	{
1171:Source/tasks.c **** 		xTicks = xTickCount;
 270               	.LM15:
 271               	/* #NOAPP */
 272 0058 2091 0000 		lds r18,xTickCount
 273 005c 3091 0000 		lds r19,(xTickCount)+1
1172:Source/tasks.c **** 	}
1173:Source/tasks.c **** 	portEXIT_CRITICAL();
 275               	.LM16:
 276               	/* #APP */
 277               	 ;  1173 "Source/tasks.c" 1
 278 0060 0F90      		pop		__tmp_reg__
 279               	 ;  0 "" 2
 280               	 ;  1173 "Source/tasks.c" 1
 281 0062 0FBE      		out		__SREG__, __tmp_reg__
 282               	 ;  0 "" 2
1174:Source/tasks.c **** 
1175:Source/tasks.c **** 	return xTicks;
1176:Source/tasks.c **** }
 284               	.LM17:
 285               	/* #NOAPP */
 286 0064 C901      		movw r24,r18
 287               	/* epilogue start */
 288 0066 0895      		ret
 293               	.Lscope4:
 295               		.stabd	78,0,0
 297               	.global	uxTaskGetNumberOfTasks
 299               	uxTaskGetNumberOfTasks:
 300               		.stabd	46,0,0
1177:Source/tasks.c **** /*-----------------------------------------------------------*/
1178:Source/tasks.c **** 
1179:Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1180:Source/tasks.c **** {
 302               	.LM18:
 303               	.LFBB5:
 304               	/* prologue: function */
 305               	/* frame size = 0 */
1181:Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1182:Source/tasks.c **** 	portBASE_TYPE. */
1183:Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 307               	.LM19:
 308 0068 8091 0000 		lds r24,uxCurrentNumberOfTasks
 309               	/* epilogue start */
1184:Source/tasks.c **** }
 311               	.LM20:
 312 006c 0895      		ret
 314               	.Lscope5:
 316               		.stabd	78,0,0
 320               	.global	vTaskStartTrace
 322               	vTaskStartTrace:
 323               		.stabd	46,0,0
1185:Source/tasks.c **** /*-----------------------------------------------------------*/
1186:Source/tasks.c **** 
1187:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1188:Source/tasks.c **** 
1189:Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1190:Source/tasks.c **** 	{
1191:Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1192:Source/tasks.c **** 
1193:Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1194:Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1195:Source/tasks.c **** 
1196:Source/tasks.c **** 		vTaskSuspendAll();
1197:Source/tasks.c **** 		{
1198:Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1199:Source/tasks.c **** 			report the task name, state and stack high water mark. */
1200:Source/tasks.c **** 
1201:Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1202:Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1203:Source/tasks.c **** 
1204:Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1205:Source/tasks.c **** 
1206:Source/tasks.c **** 			do
1207:Source/tasks.c **** 			{
1208:Source/tasks.c **** 				uxQueue--;
1209:Source/tasks.c **** 
1210:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1211:Source/tasks.c **** 				{
1212:Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1213:Source/tasks.c **** 				}
1214:Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1215:Source/tasks.c **** 
1216:Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1217:Source/tasks.c **** 			{
1218:Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1219:Source/tasks.c **** 			}
1220:Source/tasks.c **** 
1221:Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1222:Source/tasks.c **** 			{
1223:Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1224:Source/tasks.c **** 			}
1225:Source/tasks.c **** 
1226:Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1227:Source/tasks.c **** 			{
1228:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1229:Source/tasks.c **** 				{
1230:Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
1231:Source/tasks.c **** 				}
1232:Source/tasks.c **** 			}
1233:Source/tasks.c **** 			#endif
1234:Source/tasks.c **** 
1235:Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1236:Source/tasks.c **** 			{
1237:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1238:Source/tasks.c **** 				{
1239:Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
1240:Source/tasks.c **** 				}
1241:Source/tasks.c **** 			}
1242:Source/tasks.c **** 			#endif
1243:Source/tasks.c **** 		}
1244:Source/tasks.c **** 		xTaskResumeAll();
1245:Source/tasks.c **** 	}
1246:Source/tasks.c **** 
1247:Source/tasks.c **** #endif
1248:Source/tasks.c **** /*----------------------------------------------------------*/
1249:Source/tasks.c **** 
1250:Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1251:Source/tasks.c **** 
1252:Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1253:Source/tasks.c **** 	{
1254:Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1255:Source/tasks.c **** 	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1256:Source/tasks.c **** 
1257:Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1258:Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1259:Source/tasks.c **** 
1260:Source/tasks.c **** 		vTaskSuspendAll();
1261:Source/tasks.c **** 		{
1262:Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1263:Source/tasks.c **** 			generating a table of run timer percentages in the provided
1264:Source/tasks.c **** 			buffer. */
1265:Source/tasks.c **** 
1266:Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1267:Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1268:Source/tasks.c **** 
1269:Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1270:Source/tasks.c **** 
1271:Source/tasks.c **** 			do
1272:Source/tasks.c **** 			{
1273:Source/tasks.c **** 				uxQueue--;
1274:Source/tasks.c **** 
1275:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1276:Source/tasks.c **** 				{
1277:Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1278:Source/tasks.c **** 				}
1279:Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1280:Source/tasks.c **** 
1281:Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1282:Source/tasks.c **** 			{
1283:Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1284:Source/tasks.c **** 			}
1285:Source/tasks.c **** 
1286:Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1287:Source/tasks.c **** 			{
1288:Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1289:Source/tasks.c **** 			}
1290:Source/tasks.c **** 
1291:Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1292:Source/tasks.c **** 			{
1293:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1294:Source/tasks.c **** 				{
1295:Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, u
1296:Source/tasks.c **** 				}
1297:Source/tasks.c **** 			}
1298:Source/tasks.c **** 			#endif
1299:Source/tasks.c **** 
1300:Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1301:Source/tasks.c **** 			{
1302:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1303:Source/tasks.c **** 				{
1304:Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotal
1305:Source/tasks.c **** 				}
1306:Source/tasks.c **** 			}
1307:Source/tasks.c **** 			#endif
1308:Source/tasks.c **** 		}
1309:Source/tasks.c **** 		xTaskResumeAll();
1310:Source/tasks.c **** 	}
1311:Source/tasks.c **** 
1312:Source/tasks.c **** #endif
1313:Source/tasks.c **** /*----------------------------------------------------------*/
1314:Source/tasks.c **** 
1315:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1316:Source/tasks.c **** 
1317:Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1318:Source/tasks.c **** 	{
 325               	.LM21:
 326               	.LFBB6:
 327               	/* prologue: function */
 328               	/* frame size = 0 */
1319:Source/tasks.c **** 		portENTER_CRITICAL();
 330               	.LM22:
 331               	/* #APP */
 332               	 ;  1319 "Source/tasks.c" 1
 333 006e 0FB6      		in		__tmp_reg__, __SREG__
 334               	 ;  0 "" 2
 335               	 ;  1319 "Source/tasks.c" 1
 336 0070 F894      		cli
 337               	 ;  0 "" 2
 338               	 ;  1319 "Source/tasks.c" 1
 339 0072 0F92      		push	__tmp_reg__
 340               	 ;  0 "" 2
1320:Source/tasks.c **** 		{
1321:Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
 342               	.LM23:
 343               	/* #NOAPP */
 344 0074 9093 0000 		sts (pcTraceBuffer)+1,r25
 345 0078 8093 0000 		sts pcTraceBuffer,r24
1322:Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
 347               	.LM24:
 348 007c 9093 0000 		sts (pcTraceBufferStart)+1,r25
 349 0080 8093 0000 		sts pcTraceBufferStart,r24
1323:Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
 351               	.LM25:
 352 0084 4850      		subi r20,lo8(-(-8))
 353 0086 5040      		sbci r21,hi8(-(-8))
 354 0088 480F      		add r20,r24
 355 008a 591F      		adc r21,r25
 356 008c 5093 0000 		sts (pcTraceBufferEnd)+1,r21
 357 0090 4093 0000 		sts pcTraceBufferEnd,r20
1324:Source/tasks.c **** 			xTracing = pdTRUE;
 359               	.LM26:
 360 0094 81E0      		ldi r24,lo8(1)
 361 0096 8093 0000 		sts xTracing,r24
1325:Source/tasks.c **** 		}
1326:Source/tasks.c **** 		portEXIT_CRITICAL();
 363               	.LM27:
 364               	/* #APP */
 365               	 ;  1326 "Source/tasks.c" 1
 366 009a 0F90      		pop		__tmp_reg__
 367               	 ;  0 "" 2
 368               	 ;  1326 "Source/tasks.c" 1
 369 009c 0FBE      		out		__SREG__, __tmp_reg__
 370               	 ;  0 "" 2
 371               	/* epilogue start */
1327:Source/tasks.c **** 	}
 373               	.LM28:
 374               	/* #NOAPP */
 375 009e 0895      		ret
 377               	.Lscope6:
 379               		.stabd	78,0,0
 381               	.global	ulTaskEndTrace
 383               	ulTaskEndTrace:
 384               		.stabd	46,0,0
1328:Source/tasks.c **** 
1329:Source/tasks.c **** #endif
1330:Source/tasks.c **** /*----------------------------------------------------------*/
1331:Source/tasks.c **** 
1332:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1333:Source/tasks.c **** 
1334:Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1335:Source/tasks.c **** 	{
 386               	.LM29:
 387               	.LFBB7:
 388               	/* prologue: function */
 389               	/* frame size = 0 */
1336:Source/tasks.c **** 	unsigned long ulBufferLength;
1337:Source/tasks.c **** 
1338:Source/tasks.c **** 		portENTER_CRITICAL();
 391               	.LM30:
 392               	/* #APP */
 393               	 ;  1338 "Source/tasks.c" 1
 394 00a0 0FB6      		in		__tmp_reg__, __SREG__
 395               	 ;  0 "" 2
 396               	 ;  1338 "Source/tasks.c" 1
 397 00a2 F894      		cli
 398               	 ;  0 "" 2
 399               	 ;  1338 "Source/tasks.c" 1
 400 00a4 0F92      		push	__tmp_reg__
 401               	 ;  0 "" 2
1339:Source/tasks.c **** 			xTracing = pdFALSE;
 403               	.LM31:
 404               	/* #NOAPP */
 405 00a6 1092 0000 		sts xTracing,__zero_reg__
1340:Source/tasks.c **** 		portEXIT_CRITICAL();
 407               	.LM32:
 408               	/* #APP */
 409               	 ;  1340 "Source/tasks.c" 1
 410 00aa 0F90      		pop		__tmp_reg__
 411               	 ;  0 "" 2
 412               	 ;  1340 "Source/tasks.c" 1
 413 00ac 0FBE      		out		__SREG__, __tmp_reg__
 414               	 ;  0 "" 2
1341:Source/tasks.c **** 
1342:Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
 416               	.LM33:
 417               	/* #NOAPP */
 418 00ae 2091 0000 		lds r18,pcTraceBuffer
 419 00b2 3091 0000 		lds r19,(pcTraceBuffer)+1
 420 00b6 8091 0000 		lds r24,pcTraceBufferStart
 421 00ba 9091 0000 		lds r25,(pcTraceBufferStart)+1
 422 00be 281B      		sub r18,r24
 423 00c0 390B      		sbc r19,r25
 424 00c2 4427      		clr r20
 425 00c4 37FD      		sbrc r19,7
 426 00c6 4095      		com r20
 427 00c8 542F      		mov r21,r20
1343:Source/tasks.c **** 
1344:Source/tasks.c **** 		return ulBufferLength;
1345:Source/tasks.c **** 	}
 429               	.LM34:
 430 00ca B901      		movw r22,r18
 431 00cc CA01      		movw r24,r20
 432               	/* epilogue start */
 433 00ce 0895      		ret
 435               	.Lscope7:
 437               		.stabd	78,0,0
 439               	.global	vTaskSwitchContext
 441               	vTaskSwitchContext:
 442               		.stabd	46,0,0
1346:Source/tasks.c **** 
1347:Source/tasks.c **** #endif
1348:Source/tasks.c **** 
1349:Source/tasks.c **** 
1350:Source/tasks.c **** 
1351:Source/tasks.c **** /*-----------------------------------------------------------
1352:Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1353:Source/tasks.c ****  * documented in task.h
1354:Source/tasks.c ****  *----------------------------------------------------------*/
1355:Source/tasks.c **** 
1356:Source/tasks.c **** 
1357:Source/tasks.c **** void vTaskIncrementTick( void )
1358:Source/tasks.c **** {
1359:Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1360:Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1361:Source/tasks.c **** 	tasks to be unblocked. */
1362:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1363:Source/tasks.c **** 	{
1364:Source/tasks.c **** 		++xTickCount;
1365:Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
1366:Source/tasks.c **** 		{
1367:Source/tasks.c **** 			xList *pxTemp;
1368:Source/tasks.c **** 
1369:Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1370:Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1371:Source/tasks.c **** 			an error! */
1372:Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1373:Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1374:Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1375:Source/tasks.c **** 			xNumOfOverflows++;
1376:Source/tasks.c **** 		}
1377:Source/tasks.c **** 
1378:Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1379:Source/tasks.c **** 		prvCheckDelayedTasks();
1380:Source/tasks.c **** 	}
1381:Source/tasks.c **** 	else
1382:Source/tasks.c **** 	{
1383:Source/tasks.c **** 		++uxMissedTicks;
1384:Source/tasks.c **** 
1385:Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1386:Source/tasks.c **** 		scheduler is locked. */
1387:Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1388:Source/tasks.c **** 		{
1389:Source/tasks.c **** 			extern void vApplicationTickHook( void );
1390:Source/tasks.c **** 
1391:Source/tasks.c **** 			vApplicationTickHook();
1392:Source/tasks.c **** 		}
1393:Source/tasks.c **** 		#endif
1394:Source/tasks.c **** 	}
1395:Source/tasks.c **** 
1396:Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1397:Source/tasks.c **** 	{
1398:Source/tasks.c **** 		extern void vApplicationTickHook( void );
1399:Source/tasks.c **** 
1400:Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1401:Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1402:Source/tasks.c **** 		if( uxMissedTicks == 0 )
1403:Source/tasks.c **** 		{
1404:Source/tasks.c **** 			vApplicationTickHook();
1405:Source/tasks.c **** 		}
1406:Source/tasks.c **** 	}
1407:Source/tasks.c **** 	#endif
1408:Source/tasks.c **** 
1409:Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1410:Source/tasks.c **** }
1411:Source/tasks.c **** /*-----------------------------------------------------------*/
1412:Source/tasks.c **** 
1413:Source/tasks.c **** #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1414:Source/tasks.c **** 
1415:Source/tasks.c **** 	void vTaskCleanUpResources( void )
1416:Source/tasks.c **** 	{
1417:Source/tasks.c **** 	unsigned short usQueue;
1418:Source/tasks.c **** 	volatile tskTCB *pxTCB;
1419:Source/tasks.c **** 
1420:Source/tasks.c **** 		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
1421:Source/tasks.c **** 
1422:Source/tasks.c **** 		/* Remove any TCB's from the ready queues. */
1423:Source/tasks.c **** 		do
1424:Source/tasks.c **** 		{
1425:Source/tasks.c **** 			usQueue--;
1426:Source/tasks.c **** 
1427:Source/tasks.c **** 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
1428:Source/tasks.c **** 			{
1429:Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
1430:Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1431:Source/tasks.c **** 
1432:Source/tasks.c **** 				prvDeleteTCB( ( tskTCB * ) pxTCB );
1433:Source/tasks.c **** 			}
1434:Source/tasks.c **** 		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
1435:Source/tasks.c **** 
1436:Source/tasks.c **** 		/* Remove any TCB's from the delayed queue. */
1437:Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
1438:Source/tasks.c **** 		{
1439:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
1440:Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1441:Source/tasks.c **** 
1442:Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1443:Source/tasks.c **** 		}
1444:Source/tasks.c **** 
1445:Source/tasks.c **** 		/* Remove any TCB's from the overflow delayed queue. */
1446:Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
1447:Source/tasks.c **** 		{
1448:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
1449:Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1450:Source/tasks.c **** 
1451:Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1452:Source/tasks.c **** 		}
1453:Source/tasks.c **** 
1454:Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1455:Source/tasks.c **** 		{
1456:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
1457:Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1458:Source/tasks.c **** 
1459:Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1460:Source/tasks.c **** 		}
1461:Source/tasks.c **** 	}
1462:Source/tasks.c **** 
1463:Source/tasks.c **** #endif
1464:Source/tasks.c **** /*-----------------------------------------------------------*/
1465:Source/tasks.c **** 
1466:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1467:Source/tasks.c **** 
1468:Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
1469:Source/tasks.c **** 	{
1470:Source/tasks.c **** 	tskTCB *xTCB;
1471:Source/tasks.c **** 
1472:Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1473:Source/tasks.c **** 		if( xTask == NULL )
1474:Source/tasks.c **** 		{
1475:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1476:Source/tasks.c **** 		}
1477:Source/tasks.c **** 		else
1478:Source/tasks.c **** 		{
1479:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1480:Source/tasks.c **** 		}
1481:Source/tasks.c **** 
1482:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1483:Source/tasks.c **** 		the value can be accessed from an interrupt. */
1484:Source/tasks.c **** 		portENTER_CRITICAL();
1485:Source/tasks.c **** 			xTCB->pxTaskTag = pxTagValue;
1486:Source/tasks.c **** 		portEXIT_CRITICAL();
1487:Source/tasks.c **** 	}
1488:Source/tasks.c **** 
1489:Source/tasks.c **** #endif
1490:Source/tasks.c **** /*-----------------------------------------------------------*/
1491:Source/tasks.c **** 
1492:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1493:Source/tasks.c **** 
1494:Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1495:Source/tasks.c **** 	{
1496:Source/tasks.c **** 	tskTCB *xTCB;
1497:Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1498:Source/tasks.c **** 
1499:Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1500:Source/tasks.c **** 		if( xTask == NULL )
1501:Source/tasks.c **** 		{
1502:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1503:Source/tasks.c **** 		}
1504:Source/tasks.c **** 		else
1505:Source/tasks.c **** 		{
1506:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1507:Source/tasks.c **** 		}
1508:Source/tasks.c **** 
1509:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1510:Source/tasks.c **** 		the value can be accessed from an interrupt. */
1511:Source/tasks.c **** 		portENTER_CRITICAL();
1512:Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1513:Source/tasks.c **** 		portEXIT_CRITICAL();
1514:Source/tasks.c **** 
1515:Source/tasks.c **** 		return xReturn;
1516:Source/tasks.c **** 	}
1517:Source/tasks.c **** 
1518:Source/tasks.c **** #endif
1519:Source/tasks.c **** /*-----------------------------------------------------------*/
1520:Source/tasks.c **** 
1521:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1522:Source/tasks.c **** 
1523:Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1524:Source/tasks.c **** 	{
1525:Source/tasks.c **** 	tskTCB *xTCB;
1526:Source/tasks.c **** 	portBASE_TYPE xReturn;
1527:Source/tasks.c **** 
1528:Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1529:Source/tasks.c **** 		if( xTask == NULL )
1530:Source/tasks.c **** 		{
1531:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1532:Source/tasks.c **** 		}
1533:Source/tasks.c **** 		else
1534:Source/tasks.c **** 		{
1535:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1536:Source/tasks.c **** 		}
1537:Source/tasks.c **** 
1538:Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1539:Source/tasks.c **** 		{
1540:Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1541:Source/tasks.c **** 		}
1542:Source/tasks.c **** 		else
1543:Source/tasks.c **** 		{
1544:Source/tasks.c **** 			xReturn = pdFAIL;
1545:Source/tasks.c **** 		}
1546:Source/tasks.c **** 
1547:Source/tasks.c **** 		return xReturn;
1548:Source/tasks.c **** 	}
1549:Source/tasks.c **** 
1550:Source/tasks.c **** #endif
1551:Source/tasks.c **** /*-----------------------------------------------------------*/
1552:Source/tasks.c **** 
1553:Source/tasks.c **** void vTaskSwitchContext( void )
1554:Source/tasks.c **** {
 444               	.LM35:
 445               	.LFBB8:
 446               	/* prologue: function */
 447               	/* frame size = 0 */
1555:Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 449               	.LM36:
 450 00d0 8091 0000 		lds r24,uxSchedulerSuspended
 451 00d4 8823      		tst r24
 452 00d6 01F0      		breq .L21
1556:Source/tasks.c **** 	{
1557:Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1558:Source/tasks.c **** 		switch. */
1559:Source/tasks.c **** 		xMissedYield = pdTRUE;
 454               	.LM37:
 455 00d8 81E0      		ldi r24,lo8(1)
 456 00da 8093 0000 		sts xMissedYield,r24
 457 00de 0895      		ret
 458               	.L23:
1560:Source/tasks.c **** 		return;
1561:Source/tasks.c **** 	}
1562:Source/tasks.c **** 
1563:Source/tasks.c **** 	traceTASK_SWITCHED_OUT();
1564:Source/tasks.c **** 
1565:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1566:Source/tasks.c **** 	{
1567:Source/tasks.c **** 		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1568:Source/tasks.c **** 
1569:Source/tasks.c **** 			/* Add the amount of time the task has been running to the accumulated
1570:Source/tasks.c **** 			time so far.  The time the task started running was stored in
1571:Source/tasks.c **** 			ulTaskSwitchedInTime.  Note that there is no overflow protection here
1572:Source/tasks.c **** 			so count values are only valid until the timer overflows.  Generally
1573:Source/tasks.c **** 			this will be about 1 hour assuming a 1uS timer increment. */
1574:Source/tasks.c **** 			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1575:Source/tasks.c **** 			ulTaskSwitchedInTime = ulTempCounter;
1576:Source/tasks.c **** 	}
1577:Source/tasks.c **** 	#endif
1578:Source/tasks.c **** 
1579:Source/tasks.c **** 	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1580:Source/tasks.c **** 	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1581:Source/tasks.c **** 
1582:Source/tasks.c **** 	/* Find the highest priority queue that contains ready tasks. */
1583:Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1584:Source/tasks.c **** 	{
1585:Source/tasks.c **** 		--uxTopReadyPriority;
 460               	.LM38:
 461 00e0 8091 0000 		lds r24,uxTopReadyPriority
 462 00e4 8150      		subi r24,lo8(-(-1))
 463 00e6 8093 0000 		sts uxTopReadyPriority,r24
 464 00ea 00C0      		rjmp .L27
 465               	.L21:
1583:Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 467               	.LM39:
 468 00ec 99E0      		ldi r25,lo8(9)
 469               	.L27:
 470 00ee E091 0000 		lds r30,uxTopReadyPriority
 471 00f2 E99F      		mul r30,r25
 472 00f4 F001      		movw r30,r0
 473 00f6 1124      		clr r1
 474 00f8 E050      		subi r30,lo8(-(pxReadyTasksLists))
 475 00fa F040      		sbci r31,hi8(-(pxReadyTasksLists))
 476 00fc 8081      		ld r24,Z
 477 00fe 8823      		tst r24
 478 0100 01F0      		breq .L23
 479               	.LBB27:
1586:Source/tasks.c **** 	}
1587:Source/tasks.c **** 
1588:Source/tasks.c **** 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1589:Source/tasks.c **** 	same priority get an equal share of the processor time. */
1590:Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 481               	.LM40:
 482 0102 9091 0000 		lds r25,uxTopReadyPriority
 483 0106 89E0      		ldi r24,lo8(9)
 484 0108 989F      		mul r25,r24
 485 010a D001      		movw r26,r0
 486 010c 1124      		clr r1
 487 010e A050      		subi r26,lo8(-(pxReadyTasksLists))
 488 0110 B040      		sbci r27,hi8(-(pxReadyTasksLists))
 489 0112 1196      		adiw r26,1
 490 0114 ED91      		ld r30,X+
 491 0116 FC91      		ld r31,X
 492 0118 1297      		sbiw r26,1+1
 493 011a 0280      		ldd __tmp_reg__,Z+2
 494 011c F381      		ldd r31,Z+3
 495 011e E02D      		mov r30,__tmp_reg__
 496 0120 1296      		adiw r26,1+1
 497 0122 FC93      		st X,r31
 498 0124 EE93      		st -X,r30
 499 0126 1197      		sbiw r26,1
 500 0128 CD01      		movw r24,r26
 501 012a 0396      		adiw r24,3
 502 012c E817      		cp r30,r24
 503 012e F907      		cpc r31,r25
 504 0130 01F4      		brne .L24
 505 0132 8281      		ldd r24,Z+2
 506 0134 9381      		ldd r25,Z+3
 507 0136 1296      		adiw r26,1+1
 508 0138 9C93      		st X,r25
 509 013a 8E93      		st -X,r24
 510 013c 1197      		sbiw r26,1
 511               	.L24:
 512 013e 1196      		adiw r26,1
 513 0140 ED91      		ld r30,X+
 514 0142 FC91      		ld r31,X
 515 0144 1297      		sbiw r26,1+1
 516 0146 8681      		ldd r24,Z+6
 517 0148 9781      		ldd r25,Z+7
 518 014a 9093 0000 		sts (pxCurrentTCB)+1,r25
 519 014e 8093 0000 		sts pxCurrentTCB,r24
 520               	.LBE27:
1591:Source/tasks.c **** 
1592:Source/tasks.c **** 	traceTASK_SWITCHED_IN();
1593:Source/tasks.c **** 	vWriteTraceToBuffer();
 522               	.LM41:
 523 0152 8091 0000 		lds r24,xTracing
 524 0156 8823      		tst r24
 525 0158 01F4      		brne .+2
 526 015a 00C0      		rjmp .L26
 527 015c E091 0000 		lds r30,pxCurrentTCB
 528 0160 F091 0000 		lds r31,(pxCurrentTCB)+1
 529 0164 9091 0000 		lds r25,uxPreviousTask
 530 0168 83A1      		ldd r24,Z+35
 531 016a 9817      		cp r25,r24
 532 016c 01F4      		brne .+2
 533 016e 00C0      		rjmp .L26
 534 0170 8091 0000 		lds r24,pcTraceBuffer
 535 0174 9091 0000 		lds r25,(pcTraceBuffer)+1
 536 0178 0896      		adiw r24,8
 537 017a 2091 0000 		lds r18,pcTraceBufferEnd
 538 017e 3091 0000 		lds r19,(pcTraceBufferEnd)+1
 539 0182 8217      		cp r24,r18
 540 0184 9307      		cpc r25,r19
 541 0186 00F4      		brsh .L25
 542 0188 E091 0000 		lds r30,pxCurrentTCB
 543 018c F091 0000 		lds r31,(pxCurrentTCB)+1
 544 0190 23A1      		ldd r18,Z+35
 545 0192 2093 0000 		sts uxPreviousTask,r18
 546 0196 E091 0000 		lds r30,pcTraceBuffer
 547 019a F091 0000 		lds r31,(pcTraceBuffer)+1
 548 019e 8091 0000 		lds r24,xTickCount
 549 01a2 9091 0000 		lds r25,(xTickCount)+1
 550 01a6 A0E0      		ldi r26,lo8(0)
 551 01a8 B0E0      		ldi r27,hi8(0)
 552 01aa 8083      		st Z,r24
 553 01ac 9183      		std Z+1,r25
 554 01ae A283      		std Z+2,r26
 555 01b0 B383      		std Z+3,r27
 556 01b2 8091 0000 		lds r24,pcTraceBuffer
 557 01b6 9091 0000 		lds r25,(pcTraceBuffer)+1
 558 01ba 0496      		adiw r24,4
 559 01bc 9093 0000 		sts (pcTraceBuffer)+1,r25
 560 01c0 8093 0000 		sts pcTraceBuffer,r24
 561 01c4 E091 0000 		lds r30,pcTraceBuffer
 562 01c8 F091 0000 		lds r31,(pcTraceBuffer)+1
 563 01cc 30E0      		ldi r19,lo8(0)
 564 01ce 40E0      		ldi r20,lo8(0)
 565 01d0 50E0      		ldi r21,hi8(0)
 566 01d2 2083      		st Z,r18
 567 01d4 3183      		std Z+1,r19
 568 01d6 4283      		std Z+2,r20
 569 01d8 5383      		std Z+3,r21
 570 01da 8091 0000 		lds r24,pcTraceBuffer
 571 01de 9091 0000 		lds r25,(pcTraceBuffer)+1
 572 01e2 0496      		adiw r24,4
 573 01e4 9093 0000 		sts (pcTraceBuffer)+1,r25
 574 01e8 8093 0000 		sts pcTraceBuffer,r24
 575 01ec 0895      		ret
 576               	.L25:
 577 01ee 1092 0000 		sts xTracing,__zero_reg__
 578               	.L26:
 579 01f2 0895      		ret
 584               	.Lscope8:
 586               		.stabd	78,0,0
 589               	.global	vTaskSetTimeOutState
 591               	vTaskSetTimeOutState:
 592               		.stabd	46,0,0
1594:Source/tasks.c **** }
1595:Source/tasks.c **** /*-----------------------------------------------------------*/
1596:Source/tasks.c **** 
1597:Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1598:Source/tasks.c **** {
1599:Source/tasks.c **** portTickType xTimeToWake;
1600:Source/tasks.c **** 
1601:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1602:Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1603:Source/tasks.c **** 
1604:Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1605:Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1606:Source/tasks.c **** 	is the first to be woken by the event. */
1607:Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1608:Source/tasks.c **** 
1609:Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1610:Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1611:Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1612:Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1613:Source/tasks.c **** 
1614:Source/tasks.c **** 
1615:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1616:Source/tasks.c **** 	{
1617:Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1618:Source/tasks.c **** 		{
1619:Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1620:Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1621:Source/tasks.c **** 			indefinitely. */
1622:Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1623:Source/tasks.c **** 		}
1624:Source/tasks.c **** 		else
1625:Source/tasks.c **** 		{
1626:Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1627:Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1628:Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1629:Source/tasks.c **** 
1630:Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1631:Source/tasks.c **** 
1632:Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1633:Source/tasks.c **** 			{
1634:Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1635:Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1636:Source/tasks.c **** 			}
1637:Source/tasks.c **** 			else
1638:Source/tasks.c **** 			{
1639:Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1640:Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1641:Source/tasks.c **** 			}
1642:Source/tasks.c **** 		}
1643:Source/tasks.c **** 	}
1644:Source/tasks.c **** 	#else
1645:Source/tasks.c **** 	{
1646:Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1647:Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1648:Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1649:Source/tasks.c **** 
1650:Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1651:Source/tasks.c **** 
1652:Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1653:Source/tasks.c **** 			{
1654:Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1655:Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1656:Source/tasks.c **** 			}
1657:Source/tasks.c **** 			else
1658:Source/tasks.c **** 			{
1659:Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1660:Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1661:Source/tasks.c **** 			}
1662:Source/tasks.c **** 	}
1663:Source/tasks.c **** 	#endif
1664:Source/tasks.c **** }
1665:Source/tasks.c **** /*-----------------------------------------------------------*/
1666:Source/tasks.c **** 
1667:Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1668:Source/tasks.c **** {
1669:Source/tasks.c **** tskTCB *pxUnblockedTCB;
1670:Source/tasks.c **** portBASE_TYPE xReturn;
1671:Source/tasks.c **** 
1672:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1673:Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1674:Source/tasks.c **** 
1675:Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1676:Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1677:Source/tasks.c **** 	it to the ready list.
1678:Source/tasks.c **** 
1679:Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1680:Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1681:Source/tasks.c **** 	means we can always expect exclusive access to the event list here. */
1682:Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1683:Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1684:Source/tasks.c **** 
1685:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1686:Source/tasks.c **** 	{
1687:Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1688:Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1689:Source/tasks.c **** 	}
1690:Source/tasks.c **** 	else
1691:Source/tasks.c **** 	{
1692:Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1693:Source/tasks.c **** 		task pending until the scheduler is resumed. */
1694:Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1695:Source/tasks.c **** 	}
1696:Source/tasks.c **** 
1697:Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1698:Source/tasks.c **** 	{
1699:Source/tasks.c **** 		/* Return true if the task removed from the event list has
1700:Source/tasks.c **** 		a higher priority than the calling task.  This allows
1701:Source/tasks.c **** 		the calling task to know if it should force a context
1702:Source/tasks.c **** 		switch now. */
1703:Source/tasks.c **** 		xReturn = pdTRUE;
1704:Source/tasks.c **** 	}
1705:Source/tasks.c **** 	else
1706:Source/tasks.c **** 	{
1707:Source/tasks.c **** 		xReturn = pdFALSE;
1708:Source/tasks.c **** 	}
1709:Source/tasks.c **** 
1710:Source/tasks.c **** 	return xReturn;
1711:Source/tasks.c **** }
1712:Source/tasks.c **** /*-----------------------------------------------------------*/
1713:Source/tasks.c **** 
1714:Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1715:Source/tasks.c **** {
 594               	.LM42:
 595               	.LFBB9:
 596               	/* prologue: function */
 597               	/* frame size = 0 */
 598 01f4 FC01      		movw r30,r24
1716:Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 600               	.LM43:
 601 01f6 8091 0000 		lds r24,xNumOfOverflows
 602 01fa 8083      		st Z,r24
1717:Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 604               	.LM44:
 605 01fc 8091 0000 		lds r24,xTickCount
 606 0200 9091 0000 		lds r25,(xTickCount)+1
 607 0204 9283      		std Z+2,r25
 608 0206 8183      		std Z+1,r24
 609               	/* epilogue start */
1718:Source/tasks.c **** }
 611               	.LM45:
 612 0208 0895      		ret
 614               	.Lscope9:
 616               		.stabd	78,0,0
 620               	.global	xTaskCheckForTimeOut
 622               	xTaskCheckForTimeOut:
 623               		.stabd	46,0,0
1719:Source/tasks.c **** /*-----------------------------------------------------------*/
1720:Source/tasks.c **** 
1721:Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1722:Source/tasks.c **** {
 625               	.LM46:
 626               	.LFBB10:
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 629 020a FC01      		movw r30,r24
 630 020c DB01      		movw r26,r22
1723:Source/tasks.c **** portBASE_TYPE xReturn;
1724:Source/tasks.c **** 
1725:Source/tasks.c **** 	portENTER_CRITICAL();
 632               	.LM47:
 633               	/* #APP */
 634               	 ;  1725 "Source/tasks.c" 1
 635 020e 0FB6      		in		__tmp_reg__, __SREG__
 636               	 ;  0 "" 2
 637               	 ;  1725 "Source/tasks.c" 1
 638 0210 F894      		cli
 639               	 ;  0 "" 2
 640               	 ;  1725 "Source/tasks.c" 1
 641 0212 0F92      		push	__tmp_reg__
 642               	 ;  0 "" 2
1726:Source/tasks.c **** 	{
1727:Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1728:Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1729:Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1730:Source/tasks.c **** 			therefore never time out. */
1731:Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 644               	.LM48:
 645               	/* #NOAPP */
 646 0214 4D91      		ld r20,X+
 647 0216 5C91      		ld r21,X
 648 0218 1197      		sbiw r26,1
 649 021a 8FEF      		ldi r24,hi8(-1)
 650 021c 4F3F      		cpi r20,lo8(-1)
 651 021e 5807      		cpc r21,r24
 652 0220 01F0      		breq .L36
 653               	.L31:
1732:Source/tasks.c **** 			{
1733:Source/tasks.c **** 				xReturn = pdFALSE;
1734:Source/tasks.c **** 			}
1735:Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1736:Source/tasks.c **** 		#endif
1737:Source/tasks.c **** 
1738:Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 655               	.LM49:
 656 0222 9091 0000 		lds r25,xNumOfOverflows
 657 0226 8081      		ld r24,Z
 658 0228 9817      		cp r25,r24
 659 022a 01F0      		breq .L33
 660 022c 2091 0000 		lds r18,xTickCount
 661 0230 3091 0000 		lds r19,(xTickCount)+1
 662 0234 8181      		ldd r24,Z+1
 663 0236 9281      		ldd r25,Z+2
 664 0238 2817      		cp r18,r24
 665 023a 3907      		cpc r19,r25
 666 023c 00F4      		brsh .L34
 667               	.L33:
1739:Source/tasks.c **** 		{
1740:Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1741:Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1742:Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1743:Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1744:Source/tasks.c **** 			xReturn = pdTRUE;
1745:Source/tasks.c **** 		}
1746:Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 669               	.LM50:
 670 023e 8091 0000 		lds r24,xTickCount
 671 0242 9091 0000 		lds r25,(xTickCount)+1
 672 0246 2181      		ldd r18,Z+1
 673 0248 3281      		ldd r19,Z+2
 674 024a 821B      		sub r24,r18
 675 024c 930B      		sbc r25,r19
 676 024e 8417      		cp r24,r20
 677 0250 9507      		cpc r25,r21
 678 0252 00F4      		brsh .L34
1747:Source/tasks.c **** 		{
1748:Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1749:Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 680               	.LM51:
 681 0254 8091 0000 		lds r24,xTickCount
 682 0258 9091 0000 		lds r25,(xTickCount)+1
 683 025c 281B      		sub r18,r24
 684 025e 390B      		sbc r19,r25
 685 0260 240F      		add r18,r20
 686 0262 351F      		adc r19,r21
 687 0264 2D93      		st X+,r18
 688 0266 3C93      		st X,r19
 689               	.LBB28:
 690               	.LBB29:
1716:Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 692               	.LM52:
 693 0268 8091 0000 		lds r24,xNumOfOverflows
 694 026c 8083      		st Z,r24
1717:Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 696               	.LM53:
 697 026e 8091 0000 		lds r24,xTickCount
 698 0272 9091 0000 		lds r25,(xTickCount)+1
 699 0276 9283      		std Z+2,r25
 700 0278 8183      		std Z+1,r24
 701               	.L36:
 702 027a 80E0      		ldi r24,lo8(0)
 703 027c 00C0      		rjmp .L32
 704               	.L34:
 705 027e 81E0      		ldi r24,lo8(1)
 706               	.L32:
 707               	.LBE29:
 708               	.LBE28:
1750:Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1751:Source/tasks.c **** 			xReturn = pdFALSE;
1752:Source/tasks.c **** 		}
1753:Source/tasks.c **** 		else
1754:Source/tasks.c **** 		{
1755:Source/tasks.c **** 			xReturn = pdTRUE;
1756:Source/tasks.c **** 		}
1757:Source/tasks.c **** 	}
1758:Source/tasks.c **** 	portEXIT_CRITICAL();
 710               	.LM54:
 711               	/* #APP */
 712               	 ;  1758 "Source/tasks.c" 1
 713 0280 0F90      		pop		__tmp_reg__
 714               	 ;  0 "" 2
 715               	 ;  1758 "Source/tasks.c" 1
 716 0282 0FBE      		out		__SREG__, __tmp_reg__
 717               	 ;  0 "" 2
 718               	/* epilogue start */
1759:Source/tasks.c **** 
1760:Source/tasks.c **** 	return xReturn;
1761:Source/tasks.c **** }
 720               	.LM55:
 721               	/* #NOAPP */
 722 0284 0895      		ret
 727               	.Lscope10:
 729               		.stabd	78,0,0
 731               	.global	vTaskMissedYield
 733               	vTaskMissedYield:
 734               		.stabd	46,0,0
1762:Source/tasks.c **** /*-----------------------------------------------------------*/
1763:Source/tasks.c **** 
1764:Source/tasks.c **** void vTaskMissedYield( void )
1765:Source/tasks.c **** {
 736               	.LM56:
 737               	.LFBB11:
 738               	/* prologue: function */
 739               	/* frame size = 0 */
1766:Source/tasks.c **** 	xMissedYield = pdTRUE;
 741               	.LM57:
 742 0286 81E0      		ldi r24,lo8(1)
 743 0288 8093 0000 		sts xMissedYield,r24
 744               	/* epilogue start */
1767:Source/tasks.c **** }
 746               	.LM58:
 747 028c 0895      		ret
 749               	.Lscope11:
 751               		.stabd	78,0,0
 754               	.global	xTaskRemoveFromEventList
 756               	xTaskRemoveFromEventList:
 757               		.stabd	46,0,0
1668:Source/tasks.c **** {
 759               	.LM59:
 760               	.LFBB12:
 761 028e 0F93      		push r16
 762 0290 1F93      		push r17
 763 0292 CF93      		push r28
 764 0294 DF93      		push r29
 765               	/* prologue: function */
 766               	/* frame size = 0 */
 767 0296 FC01      		movw r30,r24
1682:Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 769               	.LM60:
 770 0298 8081      		ld r24,Z
 771 029a 8823      		tst r24
 772 029c 01F4      		brne .L40
 773 029e C0E0      		ldi r28,lo8(0)
 774 02a0 D0E0      		ldi r29,hi8(0)
 775 02a2 00C0      		rjmp .L41
 776               	.L40:
 777 02a4 0580      		ldd __tmp_reg__,Z+5
 778 02a6 F681      		ldd r31,Z+6
 779 02a8 E02D      		mov r30,__tmp_reg__
 780 02aa C681      		ldd r28,Z+6
 781 02ac D781      		ldd r29,Z+7
 782               	.L41:
1683:Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 784               	.LM61:
 785 02ae 8E01      		movw r16,r28
 786 02b0 045F      		subi r16,lo8(-(12))
 787 02b2 1F4F      		sbci r17,hi8(-(12))
 788 02b4 C801      		movw r24,r16
 789 02b6 0E94 0000 		call vListRemove
1685:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 791               	.LM62:
 792 02ba 8091 0000 		lds r24,uxSchedulerSuspended
 793 02be 8823      		tst r24
 794 02c0 01F4      		brne .L42
1687:Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 796               	.LM63:
 797 02c2 8E01      		movw r16,r28
 798 02c4 0E5F      		subi r16,lo8(-(2))
 799 02c6 1F4F      		sbci r17,hi8(-(2))
 800 02c8 C801      		movw r24,r16
 801 02ca 0E94 0000 		call vListRemove
1688:Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 803               	.LM64:
 804 02ce 9E89      		ldd r25,Y+22
 805 02d0 8091 0000 		lds r24,uxTopReadyPriority
 806 02d4 8917      		cp r24,r25
 807 02d6 00F4      		brsh .L43
 808 02d8 9093 0000 		sts uxTopReadyPriority,r25
 809               	.L43:
 810 02dc 89E0      		ldi r24,lo8(9)
 811 02de 989F      		mul r25,r24
 812 02e0 C001      		movw r24,r0
 813 02e2 1124      		clr r1
 814 02e4 8050      		subi r24,lo8(-(pxReadyTasksLists))
 815 02e6 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 816 02e8 00C0      		rjmp .L47
 817               	.L42:
1694:Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 819               	.LM65:
 820 02ea 80E0      		ldi r24,lo8(xPendingReadyList)
 821 02ec 90E0      		ldi r25,hi8(xPendingReadyList)
 822               	.L47:
 823 02ee B801      		movw r22,r16
 824 02f0 0E94 0000 		call vListInsertEnd
1697:Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 826               	.LM66:
 827 02f4 E091 0000 		lds r30,pxCurrentTCB
 828 02f8 F091 0000 		lds r31,(pxCurrentTCB)+1
 829 02fc 20E0      		ldi r18,lo8(0)
 830 02fe 9E89      		ldd r25,Y+22
 831 0300 8689      		ldd r24,Z+22
 832 0302 9817      		cp r25,r24
 833 0304 00F0      		brlo .L45
 834 0306 21E0      		ldi r18,lo8(1)
 835               	.L45:
1711:Source/tasks.c **** }
 837               	.LM67:
 838 0308 822F      		mov r24,r18
 839               	/* epilogue start */
 840 030a DF91      		pop r29
 841 030c CF91      		pop r28
 842 030e 1F91      		pop r17
 843 0310 0F91      		pop r16
 844 0312 0895      		ret
 849               	.Lscope12:
 851               		.stabd	78,0,0
 853               	.global	xTaskResumeFromISR
 855               	xTaskResumeFromISR:
 856               		.stabd	46,0,0
 983:Source/tasks.c **** 	{
 858               	.LM68:
 859               	.LFBB13:
 860 0314 DF92      		push r13
 861 0316 EF92      		push r14
 862 0318 FF92      		push r15
 863 031a 0F93      		push r16
 864 031c 1F93      		push r17
 865 031e CF93      		push r28
 866 0320 DF93      		push r29
 867               	/* prologue: function */
 868               	/* frame size = 0 */
 987:Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 870               	.LM69:
 871 0322 EC01      		movw r28,r24
 872               	.LBB30:
 873               	.LBB31:
 916:Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 875               	.LM70:
 876 0324 8A85      		ldd r24,Y+10
 877 0326 9B85      		ldd r25,Y+11
 878 0328 8050      		subi r24,lo8(xSuspendedTaskList)
 879 032a 9040      		sbci r25,hi8(xSuspendedTaskList)
 880 032c 01F4      		brne .L49
 919:Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 882               	.LM71:
 883 032e 8C89      		ldd r24,Y+20
 884 0330 9D89      		ldd r25,Y+21
 885 0332 20E0      		ldi r18,hi8(xPendingReadyList)
 886 0334 8030      		cpi r24,lo8(xPendingReadyList)
 887 0336 9207      		cpc r25,r18
 888 0338 01F0      		breq .L49
 925:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 890               	.LM72:
 891 033a 892B      		or r24,r25
 892 033c 01F4      		brne .L49
 893 033e 00C0      		rjmp .L58
 894               	.L54:
 895               	.LBE31:
 896               	.LBE30:
 995:Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 898               	.LM73:
 899 0340 DE88      		ldd r13,Y+22
 900 0342 E091 0000 		lds r30,pxCurrentTCB
 901 0346 F091 0000 		lds r31,(pxCurrentTCB)+1
 902 034a 0689      		ldd r16,Z+22
 996:Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 904               	.LM74:
 905 034c 82E0      		ldi r24,lo8(2)
 906 034e E82E      		mov r14,r24
 907 0350 F12C      		mov r15,__zero_reg__
 908 0352 EC0E      		add r14,r28
 909 0354 FD1E      		adc r15,r29
 910 0356 C701      		movw r24,r14
 911 0358 0E94 0000 		call vListRemove
 997:Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 913               	.LM75:
 914 035c 6E89      		ldd r22,Y+22
 915 035e 8091 0000 		lds r24,uxTopReadyPriority
 916 0362 8617      		cp r24,r22
 917 0364 00F4      		brsh .L51
 918 0366 6093 0000 		sts uxTopReadyPriority,r22
 919               	.L51:
 995:Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 921               	.LM76:
 922 036a 10E0      		ldi r17,lo8(0)
 923 036c D016      		cp r13,r16
 924 036e 00F0      		brlo .L52
 925 0370 11E0      		ldi r17,lo8(1)
 926               	.L52:
 997:Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 928               	.LM77:
 929 0372 89E0      		ldi r24,lo8(9)
 930 0374 689F      		mul r22,r24
 931 0376 C001      		movw r24,r0
 932 0378 1124      		clr r1
 933 037a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 934 037c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 935 037e B701      		movw r22,r14
 936 0380 0E94 0000 		call vListInsertEnd
 937 0384 00C0      		rjmp .L53
 938               	.L59:
1004:Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 940               	.LM78:
 941 0386 2C96      		adiw r28,12
 942 0388 80E0      		ldi r24,lo8(xPendingReadyList)
 943 038a 90E0      		ldi r25,hi8(xPendingReadyList)
 944 038c BE01      		movw r22,r28
 945 038e 0E94 0000 		call vListInsertEnd
 946               	.L49:
 947 0392 10E0      		ldi r17,lo8(0)
 948               	.L53:
1009:Source/tasks.c **** 	}
 950               	.LM79:
 951 0394 812F      		mov r24,r17
 952               	/* epilogue start */
 953 0396 DF91      		pop r29
 954 0398 CF91      		pop r28
 955 039a 1F91      		pop r17
 956 039c 0F91      		pop r16
 957 039e FF90      		pop r15
 958 03a0 EF90      		pop r14
 959 03a2 DF90      		pop r13
 960 03a4 0895      		ret
 961               	.L58:
 993:Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 963               	.LM80:
 964 03a6 8091 0000 		lds r24,uxSchedulerSuspended
 965 03aa 8823      		tst r24
 966 03ac 01F0      		breq .L54
 967 03ae 00C0      		rjmp .L59
 972               	.Lscope13:
 974               		.stabd	78,0,0
 978               	.global	vTaskPlaceOnEventList
 980               	vTaskPlaceOnEventList:
 981               		.stabd	46,0,0
1598:Source/tasks.c **** {
 983               	.LM81:
 984               	.LFBB14:
 985 03b0 CF93      		push r28
 986 03b2 DF93      		push r29
 987               	/* prologue: function */
 988               	/* frame size = 0 */
 989 03b4 EB01      		movw r28,r22
1607:Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 991               	.LM82:
 992 03b6 6091 0000 		lds r22,pxCurrentTCB
 993 03ba 7091 0000 		lds r23,(pxCurrentTCB)+1
 994 03be 645F      		subi r22,lo8(-(12))
 995 03c0 7F4F      		sbci r23,hi8(-(12))
 996 03c2 0E94 0000 		call vListInsert
1612:Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 998               	.LM83:
 999 03c6 8091 0000 		lds r24,pxCurrentTCB
 1000 03ca 9091 0000 		lds r25,(pxCurrentTCB)+1
 1001 03ce 0296      		adiw r24,2
 1002 03d0 0E94 0000 		call vListRemove
1617:Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 1004               	.LM84:
 1005 03d4 8FEF      		ldi r24,hi8(-1)
 1006 03d6 CF3F      		cpi r28,lo8(-1)
 1007 03d8 D807      		cpc r29,r24
 1008 03da 01F4      		brne .L61
1622:Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 1010               	.LM85:
 1011 03dc 6091 0000 		lds r22,pxCurrentTCB
 1012 03e0 7091 0000 		lds r23,(pxCurrentTCB)+1
 1013 03e4 6E5F      		subi r22,lo8(-(2))
 1014 03e6 7F4F      		sbci r23,hi8(-(2))
 1015 03e8 80E0      		ldi r24,lo8(xSuspendedTaskList)
 1016 03ea 90E0      		ldi r25,hi8(xSuspendedTaskList)
 1017 03ec 0E94 0000 		call vListInsertEnd
 1018 03f0 00C0      		rjmp .L64
 1019               	.L61:
1628:Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 1021               	.LM86:
 1022 03f2 8091 0000 		lds r24,xTickCount
 1023 03f6 9091 0000 		lds r25,(xTickCount)+1
 1024 03fa 8C0F      		add r24,r28
 1025 03fc 9D1F      		adc r25,r29
1630:Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 1027               	.LM87:
 1028 03fe E091 0000 		lds r30,pxCurrentTCB
 1029 0402 F091 0000 		lds r31,(pxCurrentTCB)+1
 1030 0406 9383      		std Z+3,r25
 1031 0408 8283      		std Z+2,r24
1632:Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 1033               	.LM88:
 1034 040a 2091 0000 		lds r18,xTickCount
 1035 040e 3091 0000 		lds r19,(xTickCount)+1
 1036 0412 8217      		cp r24,r18
 1037 0414 9307      		cpc r25,r19
 1038 0416 00F4      		brsh .L63
1635:Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 1040               	.LM89:
 1041 0418 8091 0000 		lds r24,pxOverflowDelayedTaskList
 1042 041c 9091 0000 		lds r25,(pxOverflowDelayedTaskList)+1
 1043 0420 00C0      		rjmp .L65
 1044               	.L63:
1640:Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 1046               	.LM90:
 1047 0422 8091 0000 		lds r24,pxDelayedTaskList
 1048 0426 9091 0000 		lds r25,(pxDelayedTaskList)+1
 1049               	.L65:
 1050 042a 6091 0000 		lds r22,pxCurrentTCB
 1051 042e 7091 0000 		lds r23,(pxCurrentTCB)+1
 1052 0432 6E5F      		subi r22,lo8(-(2))
 1053 0434 7F4F      		sbci r23,hi8(-(2))
 1054 0436 0E94 0000 		call vListInsert
 1055               	.L64:
 1056               	/* epilogue start */
1664:Source/tasks.c **** }
 1058               	.LM91:
 1059 043a DF91      		pop r29
 1060 043c CF91      		pop r28
 1061 043e 0895      		ret
 1066               	.Lscope14:
 1068               		.stabd	78,0,0
 1070               	.global	vTaskIncrementTick
 1072               	vTaskIncrementTick:
 1073               		.stabd	46,0,0
1358:Source/tasks.c **** {
 1075               	.LM92:
 1076               	.LFBB15:
 1077 0440 FF92      		push r15
 1078 0442 0F93      		push r16
 1079 0444 1F93      		push r17
 1080 0446 CF93      		push r28
 1081 0448 DF93      		push r29
 1082               	/* prologue: function */
 1083               	/* frame size = 0 */
1362:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1085               	.LM93:
 1086 044a 8091 0000 		lds r24,uxSchedulerSuspended
 1087 044e 8823      		tst r24
 1088 0450 01F0      		breq .+2
 1089 0452 00C0      		rjmp .L67
1364:Source/tasks.c **** 		++xTickCount;
 1091               	.LM94:
 1092 0454 8091 0000 		lds r24,xTickCount
 1093 0458 9091 0000 		lds r25,(xTickCount)+1
 1094 045c 0196      		adiw r24,1
 1095 045e 9093 0000 		sts (xTickCount)+1,r25
 1096 0462 8093 0000 		sts xTickCount,r24
1365:Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
 1098               	.LM95:
 1099 0466 8091 0000 		lds r24,xTickCount
 1100 046a 9091 0000 		lds r25,(xTickCount)+1
 1101 046e 892B      		or r24,r25
 1102 0470 01F4      		brne .L68
 1103               	.LBB32:
1372:Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1105               	.LM96:
 1106 0472 8091 0000 		lds r24,pxDelayedTaskList
 1107 0476 9091 0000 		lds r25,(pxDelayedTaskList)+1
1373:Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1109               	.LM97:
 1110 047a 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1111 047e 3091 0000 		lds r19,(pxOverflowDelayedTaskList)+1
 1112 0482 3093 0000 		sts (pxDelayedTaskList)+1,r19
 1113 0486 2093 0000 		sts pxDelayedTaskList,r18
1374:Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1115               	.LM98:
 1116 048a 9093 0000 		sts (pxOverflowDelayedTaskList)+1,r25
 1117 048e 8093 0000 		sts pxOverflowDelayedTaskList,r24
1375:Source/tasks.c **** 			xNumOfOverflows++;
 1119               	.LM99:
 1120 0492 8091 0000 		lds r24,xNumOfOverflows
 1121 0496 8F5F      		subi r24,lo8(-(1))
 1122 0498 8093 0000 		sts xNumOfOverflows,r24
 1123 049c 00C0      		rjmp .L68
 1124               	.L72:
 1125               	.LBE32:
 1126               	.LBB33:
1379:Source/tasks.c **** 		prvCheckDelayedTasks();
 1128               	.LM100:
 1129 049e 2091 0000 		lds r18,xTickCount
 1130 04a2 3091 0000 		lds r19,(xTickCount)+1
 1131 04a6 8A81      		ldd r24,Y+2
 1132 04a8 9B81      		ldd r25,Y+3
 1133 04aa 2817      		cp r18,r24
 1134 04ac 3907      		cpc r19,r25
 1135 04ae 00F0      		brlo .L69
 1136 04b0 8E01      		movw r16,r28
 1137 04b2 0E5F      		subi r16,lo8(-(2))
 1138 04b4 1F4F      		sbci r17,hi8(-(2))
 1139 04b6 C801      		movw r24,r16
 1140 04b8 0E94 0000 		call vListRemove
 1141 04bc 8C89      		ldd r24,Y+20
 1142 04be 9D89      		ldd r25,Y+21
 1143 04c0 892B      		or r24,r25
 1144 04c2 01F0      		breq .L70
 1145 04c4 CE01      		movw r24,r28
 1146 04c6 0C96      		adiw r24,12
 1147 04c8 0E94 0000 		call vListRemove
 1148               	.L70:
 1149 04cc 9E89      		ldd r25,Y+22
 1150 04ce 8091 0000 		lds r24,uxTopReadyPriority
 1151 04d2 8917      		cp r24,r25
 1152 04d4 00F4      		brsh .L71
 1153 04d6 9093 0000 		sts uxTopReadyPriority,r25
 1154               	.L71:
 1155 04da 9F9D      		mul r25,r15
 1156 04dc C001      		movw r24,r0
 1157 04de 1124      		clr r1
 1158 04e0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1159 04e2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1160 04e4 B801      		movw r22,r16
 1161 04e6 0E94 0000 		call vListInsertEnd
 1162 04ea 00C0      		rjmp .L75
 1163               	.L68:
 1164 04ec 99E0      		ldi r25,lo8(9)
 1165 04ee F92E      		mov r15,r25
 1166               	.L75:
 1167 04f0 E091 0000 		lds r30,pxDelayedTaskList
 1168 04f4 F091 0000 		lds r31,(pxDelayedTaskList)+1
 1169 04f8 8081      		ld r24,Z
 1170 04fa 8823      		tst r24
 1171 04fc 01F0      		breq .L69
 1172 04fe E091 0000 		lds r30,pxDelayedTaskList
 1173 0502 F091 0000 		lds r31,(pxDelayedTaskList)+1
 1174 0506 0580      		ldd __tmp_reg__,Z+5
 1175 0508 F681      		ldd r31,Z+6
 1176 050a E02D      		mov r30,__tmp_reg__
 1177 050c C681      		ldd r28,Z+6
 1178 050e D781      		ldd r29,Z+7
 1179 0510 2097      		sbiw r28,0
 1180 0512 01F4      		brne .L72
 1181 0514 00C0      		rjmp .L69
 1182               	.L67:
 1183               	.LBE33:
1383:Source/tasks.c **** 		++uxMissedTicks;
 1185               	.LM101:
 1186 0516 8091 0000 		lds r24,uxMissedTicks
 1187 051a 8F5F      		subi r24,lo8(-(1))
 1188 051c 8093 0000 		sts uxMissedTicks,r24
1391:Source/tasks.c **** 			vApplicationTickHook();
 1190               	.LM102:
 1191 0520 0E94 0000 		call vApplicationTickHook
 1192               	.L69:
1402:Source/tasks.c **** 		if( uxMissedTicks == 0 )
 1194               	.LM103:
 1195 0524 8091 0000 		lds r24,uxMissedTicks
 1196 0528 8823      		tst r24
 1197 052a 01F4      		brne .L74
1404:Source/tasks.c **** 			vApplicationTickHook();
 1199               	.LM104:
 1200 052c 0E94 0000 		call vApplicationTickHook
 1201               	.L74:
 1202               	/* epilogue start */
1410:Source/tasks.c **** }
 1204               	.LM105:
 1205 0530 DF91      		pop r29
 1206 0532 CF91      		pop r28
 1207 0534 1F91      		pop r17
 1208 0536 0F91      		pop r16
 1209 0538 FF90      		pop r15
 1210 053a 0895      		ret
 1218               	.Lscope15:
 1220               		.stabd	78,0,0
 1221               		.data
 1222               	.LC0:
 1223 0000 2573 0909 		.string	"%s\t\t%c\t%u\t%u\t%u\r\n"
 1223      2563 0925 
 1223      7509 2575 
 1223      0925 750D 
 1223      0A00 
 1224               		.text
 1230               	prvListTaskWithinSingleList:
 1231               		.stabd	46,0,0
1768:Source/tasks.c **** 
1769:Source/tasks.c **** /*
1770:Source/tasks.c ****  * -----------------------------------------------------------
1771:Source/tasks.c ****  * The Idle task.
1772:Source/tasks.c ****  * ----------------------------------------------------------
1773:Source/tasks.c ****  *
1774:Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1775:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1776:Source/tasks.c ****  *
1777:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1778:Source/tasks.c ****  *
1779:Source/tasks.c ****  */
1780:Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1781:Source/tasks.c **** {
1782:Source/tasks.c **** 	/* Stop warnings. */
1783:Source/tasks.c **** 	( void ) pvParameters;
1784:Source/tasks.c **** 
1785:Source/tasks.c **** 	for( ;; )
1786:Source/tasks.c **** 	{
1787:Source/tasks.c **** 		/* See if any tasks have been deleted. */
1788:Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1789:Source/tasks.c **** 
1790:Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1791:Source/tasks.c **** 		{
1792:Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1793:Source/tasks.c **** 			see if any other task has become available.  If we are using
1794:Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1795:Source/tasks.c **** 			will automatically get the processor anyway. */
1796:Source/tasks.c **** 			taskYIELD();
1797:Source/tasks.c **** 		}
1798:Source/tasks.c **** 		#endif
1799:Source/tasks.c **** 
1800:Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1801:Source/tasks.c **** 		{
1802:Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1803:Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1804:Source/tasks.c **** 			to run then the idle task should yield before the end of the
1805:Source/tasks.c **** 			timeslice.
1806:Source/tasks.c **** 
1807:Source/tasks.c **** 			A critical region is not required here as we are just reading from
1808:Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1809:Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1810:Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1811:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1812:Source/tasks.c **** 			{
1813:Source/tasks.c **** 				taskYIELD();
1814:Source/tasks.c **** 			}
1815:Source/tasks.c **** 		}
1816:Source/tasks.c **** 		#endif
1817:Source/tasks.c **** 
1818:Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1819:Source/tasks.c **** 		{
1820:Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1821:Source/tasks.c **** 
1822:Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1823:Source/tasks.c **** 			allows the application designer to add background functionality
1824:Source/tasks.c **** 			without the overhead of a separate task.
1825:Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1826:Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1827:Source/tasks.c **** 			vApplicationIdleHook();
1828:Source/tasks.c **** 		}
1829:Source/tasks.c **** 		#endif
1830:Source/tasks.c **** 	}
1831:Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1832:Source/tasks.c **** 
1833:Source/tasks.c **** 
1834:Source/tasks.c **** 
1835:Source/tasks.c **** 
1836:Source/tasks.c **** 
1837:Source/tasks.c **** 
1838:Source/tasks.c **** 
1839:Source/tasks.c **** /*-----------------------------------------------------------
1840:Source/tasks.c ****  * File private functions documented at the top of the file.
1841:Source/tasks.c ****  *----------------------------------------------------------*/
1842:Source/tasks.c **** 
1843:Source/tasks.c **** 
1844:Source/tasks.c **** 
1845:Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1846:Source/tasks.c **** {
1847:Source/tasks.c **** 	/* Store the function name in the TCB. */
1848:Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1849:Source/tasks.c **** 	{
1850:Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1851:Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1852:Source/tasks.c **** 	}
1853:Source/tasks.c **** 	#endif
1854:Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
1855:Source/tasks.c **** 
1856:Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1857:Source/tasks.c **** 	remove the privilege bit if one is present. */
1858:Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1859:Source/tasks.c **** 	{
1860:Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - 1;
1861:Source/tasks.c **** 	}
1862:Source/tasks.c **** 
1863:Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
1864:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1865:Source/tasks.c **** 	{
1866:Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
1867:Source/tasks.c **** 	}
1868:Source/tasks.c **** 	#endif
1869:Source/tasks.c **** 
1870:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
1871:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
1872:Source/tasks.c **** 
1873:Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1874:Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1875:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
1876:Source/tasks.c **** 
1877:Source/tasks.c **** 	/* Event lists are always in priority order. */
1878:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
1879:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
1880:Source/tasks.c **** 
1881:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1882:Source/tasks.c **** 	{
1883:Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
1884:Source/tasks.c **** 	}
1885:Source/tasks.c **** 	#endif
1886:Source/tasks.c **** 
1887:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1888:Source/tasks.c **** 	{
1889:Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1890:Source/tasks.c **** 	}
1891:Source/tasks.c **** 	#endif
1892:Source/tasks.c **** 
1893:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1894:Source/tasks.c **** 	{
1895:Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1896:Source/tasks.c **** 	}
1897:Source/tasks.c **** 	#endif
1898:Source/tasks.c **** 
1899:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1900:Source/tasks.c **** 	{
1901:Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1902:Source/tasks.c **** 	}
1903:Source/tasks.c **** 	#else
1904:Source/tasks.c **** 	{
1905:Source/tasks.c **** 		( void ) xRegions;
1906:Source/tasks.c **** 		( void ) usStackDepth;
1907:Source/tasks.c **** 	}
1908:Source/tasks.c **** 	#endif
1909:Source/tasks.c **** }
1910:Source/tasks.c **** /*-----------------------------------------------------------*/
1911:Source/tasks.c **** 
1912:Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
1913:Source/tasks.c **** 
1914:Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
1915:Source/tasks.c **** 	{
1916:Source/tasks.c **** 	tskTCB *pxTCB;
1917:Source/tasks.c **** 	
1918:Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
1919:Source/tasks.c **** 		{
1920:Source/tasks.c **** 			xTaskToModify = NULL;
1921:Source/tasks.c **** 		}
1922:Source/tasks.c **** 
1923:Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
1924:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
1925:Source/tasks.c **** 
1926:Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
1927:Source/tasks.c **** 	}
1928:Source/tasks.c **** 	/*-----------------------------------------------------------*/
1929:Source/tasks.c **** #endif
1930:Source/tasks.c **** 
1931:Source/tasks.c **** static void prvInitialiseTaskLists( void )
1932:Source/tasks.c **** {
1933:Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
1934:Source/tasks.c **** 
1935:Source/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
1936:Source/tasks.c **** 	{
1937:Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
1938:Source/tasks.c **** 	}
1939:Source/tasks.c **** 
1940:Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
1941:Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
1942:Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
1943:Source/tasks.c **** 
1944:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1945:Source/tasks.c **** 	{
1946:Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
1947:Source/tasks.c **** 	}
1948:Source/tasks.c **** 	#endif
1949:Source/tasks.c **** 
1950:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1951:Source/tasks.c **** 	{
1952:Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
1953:Source/tasks.c **** 	}
1954:Source/tasks.c **** 	#endif
1955:Source/tasks.c **** 
1956:Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
1957:Source/tasks.c **** 	using list2. */
1958:Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
1959:Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
1960:Source/tasks.c **** }
1961:Source/tasks.c **** /*-----------------------------------------------------------*/
1962:Source/tasks.c **** 
1963:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
1964:Source/tasks.c **** {
1965:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1966:Source/tasks.c **** 	{
1967:Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
1968:Source/tasks.c **** 
1969:Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
1970:Source/tasks.c **** 		too often in the idle task. */
1971:Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
1972:Source/tasks.c **** 		{
1973:Source/tasks.c **** 			vTaskSuspendAll();
1974:Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
1975:Source/tasks.c **** 			xTaskResumeAll();
1976:Source/tasks.c **** 
1977:Source/tasks.c **** 			if( !xListIsEmpty )
1978:Source/tasks.c **** 			{
1979:Source/tasks.c **** 				tskTCB *pxTCB;
1980:Source/tasks.c **** 
1981:Source/tasks.c **** 				portENTER_CRITICAL();
1982:Source/tasks.c **** 				{
1983:Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
1984:Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1985:Source/tasks.c **** 					--uxCurrentNumberOfTasks;
1986:Source/tasks.c **** 					--uxTasksDeleted;
1987:Source/tasks.c **** 				}
1988:Source/tasks.c **** 				portEXIT_CRITICAL();
1989:Source/tasks.c **** 
1990:Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1991:Source/tasks.c **** 			}
1992:Source/tasks.c **** 		}
1993:Source/tasks.c **** 	}
1994:Source/tasks.c **** 	#endif
1995:Source/tasks.c **** }
1996:Source/tasks.c **** /*-----------------------------------------------------------*/
1997:Source/tasks.c **** 
1998:Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
1999:Source/tasks.c **** {
2000:Source/tasks.c **** tskTCB *pxNewTCB;
2001:Source/tasks.c **** 
2002:Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2003:Source/tasks.c **** 	the implementation of the port malloc function. */
2004:Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2005:Source/tasks.c **** 
2006:Source/tasks.c **** 	if( pxNewTCB != NULL )
2007:Source/tasks.c **** 	{
2008:Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2009:Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2010:Source/tasks.c **** 		be deleted later if required. */
2011:Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2012:Source/tasks.c **** 
2013:Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
2014:Source/tasks.c **** 		{
2015:Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2016:Source/tasks.c **** 			vPortFree( pxNewTCB );
2017:Source/tasks.c **** 			pxNewTCB = NULL;
2018:Source/tasks.c **** 		}
2019:Source/tasks.c **** 		else
2020:Source/tasks.c **** 		{
2021:Source/tasks.c **** 			/* Just to help debugging. */
2022:Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
2023:Source/tasks.c **** 		}
2024:Source/tasks.c **** 	}
2025:Source/tasks.c **** 
2026:Source/tasks.c **** 	return pxNewTCB;
2027:Source/tasks.c **** }
2028:Source/tasks.c **** /*-----------------------------------------------------------*/
2029:Source/tasks.c **** 
2030:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2031:Source/tasks.c **** 
2032:Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2033:Source/tasks.c **** 	{
 1233               	.LM106:
 1234               	.LFBB16:
 1235 053c 4F92      		push r4
 1236 053e 5F92      		push r5
 1237 0540 6F92      		push r6
 1238 0542 7F92      		push r7
 1239 0544 8F92      		push r8
 1240 0546 9F92      		push r9
 1241 0548 AF92      		push r10
 1242 054a BF92      		push r11
 1243 054c CF92      		push r12
 1244 054e DF92      		push r13
 1245 0550 EF92      		push r14
 1246 0552 FF92      		push r15
 1247 0554 0F93      		push r16
 1248 0556 1F93      		push r17
 1249 0558 CF93      		push r28
 1250 055a DF93      		push r29
 1251               	/* prologue: function */
 1252               	/* frame size = 0 */
 1253 055c 4C01      		movw r8,r24
 1254 055e 8B01      		movw r16,r22
 1255               	.LBB34:
2034:Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2035:Source/tasks.c **** 	unsigned short usStackRemaining;
2036:Source/tasks.c **** 
2037:Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2038:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 1257               	.LM107:
 1258 0560 DB01      		movw r26,r22
 1259 0562 1196      		adiw r26,1
 1260 0564 ED91      		ld r30,X+
 1261 0566 FC91      		ld r31,X
 1262 0568 1297      		sbiw r26,1+1
 1263 056a 0280      		ldd __tmp_reg__,Z+2
 1264 056c F381      		ldd r31,Z+3
 1265 056e E02D      		mov r30,__tmp_reg__
 1266 0570 1296      		adiw r26,1+1
 1267 0572 FC93      		st X,r31
 1268 0574 EE93      		st -X,r30
 1269 0576 1197      		sbiw r26,1
 1270 0578 CB01      		movw r24,r22
 1271 057a 0396      		adiw r24,3
 1272 057c E817      		cp r30,r24
 1273 057e F907      		cpc r31,r25
 1274 0580 01F4      		brne .L77
 1275 0582 8281      		ldd r24,Z+2
 1276 0584 9381      		ldd r25,Z+3
 1277 0586 1296      		adiw r26,1+1
 1278 0588 9C93      		st X,r25
 1279 058a 8E93      		st -X,r24
 1280 058c 1197      		sbiw r26,1
 1281               	.L77:
 1282 058e D801      		movw r26,r16
 1283 0590 1196      		adiw r26,1
 1284 0592 ED91      		ld r30,X+
 1285 0594 FC91      		ld r31,X
 1286 0596 1297      		sbiw r26,1+1
 1287 0598 A680      		ldd r10,Z+6
 1288 059a B780      		ldd r11,Z+7
 1289               	.LBE34:
 1290               	.LBB35:
2039:Source/tasks.c **** 		do
2040:Source/tasks.c **** 		{
2041:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 1292               	.LM108:
 1293 059c 53E0      		ldi r21,lo8(3)
 1294 059e E52E      		mov r14,r21
 1295 05a0 F12C      		mov r15,__zero_reg__
 1296 05a2 E00E      		add r14,r16
 1297 05a4 F11E      		adc r15,r17
 1298               	.LBE35:
2042:Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2043:Source/tasks.c **** 			{
2044:Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2045:Source/tasks.c **** 			}
2046:Source/tasks.c **** 			#else
2047:Source/tasks.c **** 			{
2048:Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2049:Source/tasks.c **** 			}
2050:Source/tasks.c **** 			#endif			
2051:Source/tasks.c **** 			
2052:Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 1300               	.LM109:
 1301 05a6 30E0      		ldi r19,lo8(pcStatusString)
 1302 05a8 632E      		mov r6,r19
 1303 05aa 30E0      		ldi r19,hi8(pcStatusString)
 1304 05ac 732E      		mov r7,r19
 1305 05ae 20E0      		ldi r18,lo8(.LC0)
 1306 05b0 422E      		mov r4,r18
 1307 05b2 20E0      		ldi r18,hi8(.LC0)
 1308 05b4 522E      		mov r5,r18
 1309 05b6 C42E      		mov r12,r20
 1310 05b8 DD24      		clr r13
 1311 05ba C7FC      		sbrc r12,7
 1312 05bc D094      		com r13
 1313               	.L81:
 1314               	.LBB36:
2041:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 1316               	.LM110:
 1317 05be D801      		movw r26,r16
 1318 05c0 1196      		adiw r26,1
 1319 05c2 ED91      		ld r30,X+
 1320 05c4 FC91      		ld r31,X
 1321 05c6 1297      		sbiw r26,1+1
 1322 05c8 8281      		ldd r24,Z+2
 1323 05ca 9381      		ldd r25,Z+3
 1324 05cc 1296      		adiw r26,1+1
 1325 05ce 9C93      		st X,r25
 1326 05d0 8E93      		st -X,r24
 1327 05d2 1197      		sbiw r26,1
 1328 05d4 8E15      		cp r24,r14
 1329 05d6 9F05      		cpc r25,r15
 1330 05d8 01F4      		brne .L78
 1331 05da F701      		movw r30,r14
 1332 05dc 8281      		ldd r24,Z+2
 1333 05de 9381      		ldd r25,Z+3
 1334 05e0 1296      		adiw r26,1+1
 1335 05e2 9C93      		st X,r25
 1336 05e4 8E93      		st -X,r24
 1337 05e6 1197      		sbiw r26,1
 1338               	.L78:
 1339 05e8 D801      		movw r26,r16
 1340 05ea 1196      		adiw r26,1
 1341 05ec ED91      		ld r30,X+
 1342 05ee FC91      		ld r31,X
 1343 05f0 1297      		sbiw r26,1+1
 1344 05f2 C681      		ldd r28,Z+6
 1345 05f4 D781      		ldd r29,Z+7
 1346               	.LBE36:
2048:Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 1348               	.LM111:
 1349 05f6 EF89      		ldd r30,Y+23
 1350 05f8 F88D      		ldd r31,Y+24
 1351 05fa 20E0      		ldi r18,lo8(0)
 1352 05fc 30E0      		ldi r19,hi8(0)
 1353 05fe 00C0      		rjmp .L79
 1354               	.L80:
 1355               	.LBB37:
 1356               	.LBB38:
2053:Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2054:Source/tasks.c **** 
2055:Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2056:Source/tasks.c **** 	}
2057:Source/tasks.c **** 
2058:Source/tasks.c **** #endif
2059:Source/tasks.c **** /*-----------------------------------------------------------*/
2060:Source/tasks.c **** 
2061:Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2062:Source/tasks.c **** 
2063:Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2064:Source/tasks.c **** 	{
2065:Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2066:Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2067:Source/tasks.c **** 
2068:Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2069:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2070:Source/tasks.c **** 		do
2071:Source/tasks.c **** 		{
2072:Source/tasks.c **** 			/* Get next TCB in from the list. */
2073:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2074:Source/tasks.c **** 
2075:Source/tasks.c **** 			/* Divide by zero check. */
2076:Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2077:Source/tasks.c **** 			{
2078:Source/tasks.c **** 				/* Has the task run at all? */
2079:Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0 )
2080:Source/tasks.c **** 				{
2081:Source/tasks.c **** 					/* The task has used no CPU time at all. */
2082:Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2083:Source/tasks.c **** 				}
2084:Source/tasks.c **** 				else
2085:Source/tasks.c **** 				{
2086:Source/tasks.c **** 					/* What percentage of the total run time as the task used?
2087:Source/tasks.c **** 					This will always be rounded down to the nearest integer. */
2088:Source/tasks.c **** 					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
2089:Source/tasks.c **** 
2090:Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2091:Source/tasks.c **** 					{
2092:Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2093:Source/tasks.c **** 					}
2094:Source/tasks.c **** 					else
2095:Source/tasks.c **** 					{
2096:Source/tasks.c **** 						/* If the percentage is zero here then the task has
2097:Source/tasks.c **** 						consumed less than 1% of the total run time. */
2098:Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2099:Source/tasks.c **** 					}
2100:Source/tasks.c **** 				}
2101:Source/tasks.c **** 
2102:Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2103:Source/tasks.c **** 			}
2104:Source/tasks.c **** 
2105:Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2106:Source/tasks.c **** 	}
2107:Source/tasks.c **** 
2108:Source/tasks.c **** #endif
2109:Source/tasks.c **** /*-----------------------------------------------------------*/
2110:Source/tasks.c **** 
2111:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2112:Source/tasks.c **** 
2113:Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2114:Source/tasks.c **** 	{
2115:Source/tasks.c **** 	register unsigned short usCount = 0;
2116:Source/tasks.c **** 
2117:Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2118:Source/tasks.c **** 		{
2119:Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 1358               	.LM112:
 1359 0600 3196      		adiw r30,1
2120:Source/tasks.c **** 			usCount++;
 1361               	.LM113:
 1362 0602 2F5F      		subi r18,lo8(-(1))
 1363 0604 3F4F      		sbci r19,hi8(-(1))
 1364               	.L79:
2117:Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 1366               	.LM114:
 1367 0606 8081      		ld r24,Z
 1368 0608 853A      		cpi r24,lo8(-91)
 1369 060a 01F0      		breq .L80
 1370               	.LBE38:
 1371               	.LBE37:
2052:Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 1373               	.LM115:
 1374 060c 8E89      		ldd r24,Y+22
 1375 060e 9BA1      		ldd r25,Y+35
 1376 0610 EDB7      		in r30,__SP_L__
 1377 0612 FEB7      		in r31,__SP_H__
 1378 0614 3E97      		sbiw r30,14
 1379 0616 0FB6      		in __tmp_reg__,__SREG__
 1380 0618 F894      		cli
 1381 061a FEBF      		out __SP_H__,r31
 1382 061c 0FBE      		out __SREG__,__tmp_reg__
 1383 061e EDBF      		out __SP_L__,r30
 1384 0620 3196      		adiw r30,1
 1385 0622 ADB7      		in r26,__SP_L__
 1386 0624 BEB7      		in r27,__SP_H__
 1387 0626 1296      		adiw r26,1+1
 1388 0628 7C92      		st X,r7
 1389 062a 6E92      		st -X,r6
 1390 062c 1197      		sbiw r26,1
 1391 062e 5382      		std Z+3,r5
 1392 0630 4282      		std Z+2,r4
 1393 0632 6996      		adiw r28,25
 1394 0634 D583      		std Z+5,r29
 1395 0636 C483      		std Z+4,r28
 1396 0638 6997      		sbiw r28,25
 1397 063a D782      		std Z+7,r13
 1398 063c C682      		std Z+6,r12
 1399 063e 8087      		std Z+8,r24
 1400 0640 1186      		std Z+9,__zero_reg__
 1401 0642 3387      		std Z+11,r19
 1402 0644 2287      		std Z+10,r18
 1403 0646 9487      		std Z+12,r25
 1404 0648 1586      		std Z+13,__zero_reg__
 1405 064a 0E94 0000 		call sprintf
2053:Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 1407               	.LM116:
 1408 064e EDB7      		in r30,__SP_L__
 1409 0650 FEB7      		in r31,__SP_H__
 1410 0652 3E96      		adiw r30,14
 1411 0654 0FB6      		in __tmp_reg__,__SREG__
 1412 0656 F894      		cli
 1413 0658 FEBF      		out __SP_H__,r31
 1414 065a 0FBE      		out __SREG__,__tmp_reg__
 1415 065c EDBF      		out __SP_L__,r30
 1416 065e C401      		movw r24,r8
 1417 0660 B301      		movw r22,r6
 1418 0662 0E94 0000 		call strcat
2055:Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 1420               	.LM117:
 1421 0666 CA15      		cp r28,r10
 1422 0668 DB05      		cpc r29,r11
 1423 066a 01F0      		breq .+2
 1424 066c 00C0      		rjmp .L81
 1425               	/* epilogue start */
2056:Source/tasks.c **** 	}
 1427               	.LM118:
 1428 066e DF91      		pop r29
 1429 0670 CF91      		pop r28
 1430 0672 1F91      		pop r17
 1431 0674 0F91      		pop r16
 1432 0676 FF90      		pop r15
 1433 0678 EF90      		pop r14
 1434 067a DF90      		pop r13
 1435 067c CF90      		pop r12
 1436 067e BF90      		pop r11
 1437 0680 AF90      		pop r10
 1438 0682 9F90      		pop r9
 1439 0684 8F90      		pop r8
 1440 0686 7F90      		pop r7
 1441 0688 6F90      		pop r6
 1442 068a 5F90      		pop r5
 1443 068c 4F90      		pop r4
 1444 068e 0895      		ret
 1454               	.Lscope16:
 1456               		.stabd	78,0,0
 1458               	.global	xTaskResumeAll
 1460               	xTaskResumeAll:
 1461               		.stabd	46,0,0
1083:Source/tasks.c **** {
 1463               	.LM119:
 1464               	.LFBB17:
 1465 0690 CF92      		push r12
 1466 0692 DF92      		push r13
 1467 0694 FF92      		push r15
 1468 0696 0F93      		push r16
 1469 0698 1F93      		push r17
 1470 069a DF93      		push r29
 1471 069c CF93      		push r28
 1472 069e 0F92      		push __tmp_reg__
 1473 06a0 CDB7      		in r28,__SP_L__
 1474 06a2 DEB7      		in r29,__SP_H__
 1475               	/* prologue: function */
 1476               	/* frame size = 1 */
1092:Source/tasks.c **** 	portENTER_CRITICAL();
 1478               	.LM120:
 1479               	/* #APP */
 1480               	 ;  1092 "Source/tasks.c" 1
 1481 06a4 0FB6      		in		__tmp_reg__, __SREG__
 1482               	 ;  0 "" 2
 1483               	 ;  1092 "Source/tasks.c" 1
 1484 06a6 F894      		cli
 1485               	 ;  0 "" 2
 1486               	 ;  1092 "Source/tasks.c" 1
 1487 06a8 0F92      		push	__tmp_reg__
 1488               	 ;  0 "" 2
1094:Source/tasks.c **** 		--uxSchedulerSuspended;
 1490               	.LM121:
 1491               	/* #NOAPP */
 1492 06aa 8091 0000 		lds r24,uxSchedulerSuspended
 1493 06ae 8150      		subi r24,lo8(-(-1))
 1494 06b0 8093 0000 		sts uxSchedulerSuspended,r24
1096:Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1496               	.LM122:
 1497 06b4 8091 0000 		lds r24,uxSchedulerSuspended
 1498 06b8 8823      		tst r24
 1499 06ba 01F0      		breq .+2
 1500 06bc 00C0      		rjmp .L85
1098:Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 1502               	.LM123:
 1503 06be 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1504 06c2 8823      		tst r24
 1505 06c4 01F4      		brne .+2
 1506 06c6 00C0      		rjmp .L85
 1507 06c8 1982      		std Y+1,__zero_reg__
 1508               	.LBB39:
1108:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1510               	.LM124:
 1511 06ca 69E0      		ldi r22,lo8(9)
 1512 06cc F62E      		mov r15,r22
 1513 06ce 00C0      		rjmp .L99
 1514               	.L89:
1106:Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1516               	.LM125:
 1517 06d0 C601      		movw r24,r12
 1518 06d2 0C96      		adiw r24,12
 1519 06d4 0E94 0000 		call vListRemove
1107:Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1521               	.LM126:
 1522 06d8 8601      		movw r16,r12
 1523 06da 0E5F      		subi r16,lo8(-(2))
 1524 06dc 1F4F      		sbci r17,hi8(-(2))
 1525 06de C801      		movw r24,r16
 1526 06e0 0E94 0000 		call vListRemove
1108:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1528               	.LM127:
 1529 06e4 D601      		movw r26,r12
 1530 06e6 5696      		adiw r26,22
 1531 06e8 9C91      		ld r25,X
 1532 06ea 8091 0000 		lds r24,uxTopReadyPriority
 1533 06ee 8917      		cp r24,r25
 1534 06f0 00F4      		brsh .L87
 1535 06f2 9093 0000 		sts uxTopReadyPriority,r25
 1536               	.L87:
 1537 06f6 9F9D      		mul r25,r15
 1538 06f8 C001      		movw r24,r0
 1539 06fa 1124      		clr r1
 1540 06fc 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1541 06fe 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1542 0700 B801      		movw r22,r16
 1543 0702 0E94 0000 		call vListInsertEnd
1112:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1545               	.LM128:
 1546 0706 E091 0000 		lds r30,pxCurrentTCB
 1547 070a F091 0000 		lds r31,(pxCurrentTCB)+1
 1548 070e D601      		movw r26,r12
 1549 0710 5696      		adiw r26,22
 1550 0712 9C91      		ld r25,X
 1551 0714 8689      		ldd r24,Z+22
 1552 0716 9817      		cp r25,r24
 1553 0718 00F0      		brlo .L99
 1554 071a B1E0      		ldi r27,lo8(1)
 1555 071c B983      		std Y+1,r27
 1556               	.L99:
1104:Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 1558               	.LM129:
 1559 071e 8091 0000 		lds r24,xPendingReadyList
 1560 0722 8823      		tst r24
 1561 0724 01F0      		breq .L88
 1562 0726 E091 0000 		lds r30,xPendingReadyList+5
 1563 072a F091 0000 		lds r31,(xPendingReadyList+5)+1
 1564 072e C680      		ldd r12,Z+6
 1565 0730 D780      		ldd r13,Z+7
 1566 0732 C114      		cp r12,__zero_reg__
 1567 0734 D104      		cpc r13,__zero_reg__
 1568 0736 01F4      		brne .L89
 1569               	.L88:
1121:Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1571               	.LM130:
 1572 0738 8091 0000 		lds r24,uxMissedTicks
 1573 073c 8823      		tst r24
 1574 073e 01F4      		brne .L98
 1575 0740 00C0      		rjmp .L91
 1576               	.L92:
1125:Source/tasks.c **** 						vTaskIncrementTick();
 1578               	.LM131:
 1579 0742 0E94 0000 		call vTaskIncrementTick
1126:Source/tasks.c **** 						--uxMissedTicks;
 1581               	.LM132:
 1582 0746 8091 0000 		lds r24,uxMissedTicks
 1583 074a 8150      		subi r24,lo8(-(-1))
 1584 074c 8093 0000 		sts uxMissedTicks,r24
 1585               	.L98:
1123:Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1587               	.LM133:
 1588 0750 8091 0000 		lds r24,uxMissedTicks
 1589 0754 8823      		tst r24
 1590 0756 01F4      		brne .L92
 1591               	.L91:
1139:Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1593               	.LM134:
 1594 0758 E981      		ldd r30,Y+1
 1595 075a E130      		cpi r30,lo8(1)
 1596 075c 01F0      		breq .L93
 1597 075e 8091 0000 		lds r24,xMissedYield
 1598 0762 8130      		cpi r24,lo8(1)
 1599 0764 01F4      		brne .L85
 1600               	.L93:
1142:Source/tasks.c **** 					xMissedYield = pdFALSE;
 1602               	.LM135:
 1603 0766 1092 0000 		sts xMissedYield,__zero_reg__
1143:Source/tasks.c **** 					portYIELD_WITHIN_API();
 1605               	.LM136:
 1606 076a 0E94 0000 		call vPortYield
 1607 076e 81E0      		ldi r24,lo8(1)
 1608 0770 00C0      		rjmp .L94
 1609               	.L85:
 1610 0772 80E0      		ldi r24,lo8(0)
 1611               	.L94:
 1612               	.LBE39:
1148:Source/tasks.c **** 	portEXIT_CRITICAL();
 1614               	.LM137:
 1615               	/* #APP */
 1616               	 ;  1148 "Source/tasks.c" 1
 1617 0774 0F90      		pop		__tmp_reg__
 1618               	 ;  0 "" 2
 1619               	 ;  1148 "Source/tasks.c" 1
 1620 0776 0FBE      		out		__SREG__, __tmp_reg__
 1621               	 ;  0 "" 2
 1622               	/* epilogue start */
1151:Source/tasks.c **** }
 1624               	.LM138:
 1625               	/* #NOAPP */
 1626 0778 0F90      		pop __tmp_reg__
 1627 077a CF91      		pop r28
 1628 077c DF91      		pop r29
 1629 077e 1F91      		pop r17
 1630 0780 0F91      		pop r16
 1631 0782 FF90      		pop r15
 1632 0784 DF90      		pop r13
 1633 0786 CF90      		pop r12
 1634 0788 0895      		ret
 1643               	.Lscope17:
 1645               		.stabd	78,0,0
 1646               		.data
 1647               	.LC1:
 1648 0012 0D0A 00   		.string	"\r\n"
 1649               		.text
 1652               	.global	vTaskList
 1654               	vTaskList:
 1655               		.stabd	46,0,0
1190:Source/tasks.c **** 	{
 1657               	.LM139:
 1658               	.LFBB18:
 1659 078a 0F93      		push r16
 1660 078c 1F93      		push r17
 1661 078e CF93      		push r28
 1662 0790 DF93      		push r29
 1663               	/* prologue: function */
 1664               	/* frame size = 0 */
 1665 0792 EC01      		movw r28,r24
 1666               	.LBB40:
 1667               	.LBB41:
1078:Source/tasks.c **** 	++uxSchedulerSuspended;
 1669               	.LM140:
 1670 0794 8091 0000 		lds r24,uxSchedulerSuspended
 1671 0798 8F5F      		subi r24,lo8(-(1))
 1672 079a 8093 0000 		sts uxSchedulerSuspended,r24
 1673               	.LBE41:
 1674               	.LBE40:
1201:Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
 1676               	.LM141:
 1677 079e 1882      		st Y,__zero_reg__
1202:Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1679               	.LM142:
 1680 07a0 CE01      		movw r24,r28
 1681 07a2 60E0      		ldi r22,lo8(.LC1)
 1682 07a4 70E0      		ldi r23,hi8(.LC1)
 1683 07a6 0E94 0000 		call strcat
1204:Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
 1685               	.LM143:
 1686 07aa 1091 0000 		lds r17,uxTopUsedPriority
 1687 07ae 1F5F      		subi r17,lo8(-(1))
1210:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 1689               	.LM144:
 1690 07b0 09E0      		ldi r16,lo8(9)
 1691               	.L102:
1208:Source/tasks.c **** 				uxQueue--;
 1693               	.LM145:
 1694 07b2 1150      		subi r17,lo8(-(-1))
1210:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 1696               	.LM146:
 1697 07b4 109F      		mul r17,r16
 1698 07b6 F001      		movw r30,r0
 1699 07b8 1124      		clr r1
 1700 07ba E050      		subi r30,lo8(-(pxReadyTasksLists))
 1701 07bc F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1702 07be 8081      		ld r24,Z
 1703 07c0 8823      		tst r24
 1704 07c2 01F0      		breq .L101
1212:Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 1706               	.LM147:
 1707 07c4 CE01      		movw r24,r28
 1708 07c6 BF01      		movw r22,r30
 1709 07c8 42E5      		ldi r20,lo8(82)
 1710 07ca 0E94 0000 		call prvListTaskWithinSingleList
 1711               	.L101:
1214:Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1713               	.LM148:
 1714 07ce 1123      		tst r17
 1715 07d0 01F4      		brne .L102
1216:Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
 1717               	.LM149:
 1718 07d2 E091 0000 		lds r30,pxDelayedTaskList
 1719 07d6 F091 0000 		lds r31,(pxDelayedTaskList)+1
 1720 07da 8081      		ld r24,Z
 1721 07dc 8823      		tst r24
 1722 07de 01F0      		breq .L103
1218:Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 1724               	.LM150:
 1725 07e0 6091 0000 		lds r22,pxDelayedTaskList
 1726 07e4 7091 0000 		lds r23,(pxDelayedTaskList)+1
 1727 07e8 CE01      		movw r24,r28
 1728 07ea 42E4      		ldi r20,lo8(66)
 1729 07ec 0E94 0000 		call prvListTaskWithinSingleList
 1730               	.L103:
1221:Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
 1732               	.LM151:
 1733 07f0 E091 0000 		lds r30,pxOverflowDelayedTaskList
 1734 07f4 F091 0000 		lds r31,(pxOverflowDelayedTaskList)+1
 1735 07f8 8081      		ld r24,Z
 1736 07fa 8823      		tst r24
 1737 07fc 01F0      		breq .L104
1223:Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 1739               	.LM152:
 1740 07fe 6091 0000 		lds r22,pxOverflowDelayedTaskList
 1741 0802 7091 0000 		lds r23,(pxOverflowDelayedTaskList)+1
 1742 0806 CE01      		movw r24,r28
 1743 0808 42E4      		ldi r20,lo8(66)
 1744 080a 0E94 0000 		call prvListTaskWithinSingleList
 1745               	.L104:
1237:Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
 1747               	.LM153:
 1748 080e 8091 0000 		lds r24,xSuspendedTaskList
 1749 0812 8823      		tst r24
 1750 0814 01F0      		breq .L105
1239:Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
 1752               	.LM154:
 1753 0816 CE01      		movw r24,r28
 1754 0818 60E0      		ldi r22,lo8(xSuspendedTaskList)
 1755 081a 70E0      		ldi r23,hi8(xSuspendedTaskList)
 1756 081c 43E5      		ldi r20,lo8(83)
 1757 081e 0E94 0000 		call prvListTaskWithinSingleList
 1758               	.L105:
1244:Source/tasks.c **** 		xTaskResumeAll();
 1760               	.LM155:
 1761 0822 0E94 0000 		call xTaskResumeAll
 1762               	/* epilogue start */
1245:Source/tasks.c **** 	}
 1764               	.LM156:
 1765 0826 DF91      		pop r29
 1766 0828 CF91      		pop r28
 1767 082a 1F91      		pop r17
 1768 082c 0F91      		pop r16
 1769 082e 0895      		ret
 1774               	.Lscope18:
 1776               		.stabd	78,0,0
 1780               	prvIdleTask:
 1781               		.stabd	46,0,0
1781:Source/tasks.c **** {
 1783               	.LM157:
 1784               	.LFBB19:
 1785               	/* prologue: function */
 1786               	/* frame size = 0 */
 1787               	.L109:
1796:Source/tasks.c **** 			taskYIELD();
 1789               	.LM158:
 1790 0830 0E94 0000 		call vPortYield
 1791 0834 00C0      		rjmp .L109
 1793               	.Lscope19:
 1795               		.stabd	78,0,0
 1797               	.global	vTaskResume
 1799               	vTaskResume:
 1800               		.stabd	46,0,0
 941:Source/tasks.c **** 	{
 1802               	.LM159:
 1803               	.LFBB20:
 1804 0836 0F93      		push r16
 1805 0838 1F93      		push r17
 1806 083a CF93      		push r28
 1807 083c DF93      		push r29
 1808               	/* prologue: function */
 1809               	/* frame size = 0 */
 946:Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1811               	.LM160:
 1812 083e EC01      		movw r28,r24
 950:Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1814               	.LM161:
 1815 0840 0097      		sbiw r24,0
 1816 0842 01F4      		brne .+2
 1817 0844 00C0      		rjmp .L117
 1818 0846 8091 0000 		lds r24,pxCurrentTCB
 1819 084a 9091 0000 		lds r25,(pxCurrentTCB)+1
 1820 084e C817      		cp r28,r24
 1821 0850 D907      		cpc r29,r25
 1822 0852 01F0      		breq .L117
 952:Source/tasks.c **** 			portENTER_CRITICAL();
 1824               	.LM162:
 1825               	/* #APP */
 1826               	 ;  952 "Source/tasks.c" 1
 1827 0854 0FB6      		in		__tmp_reg__, __SREG__
 1828               	 ;  0 "" 2
 1829               	 ;  952 "Source/tasks.c" 1
 1830 0856 F894      		cli
 1831               	 ;  0 "" 2
 1832               	 ;  952 "Source/tasks.c" 1
 1833 0858 0F92      		push	__tmp_reg__
 1834               	 ;  0 "" 2
 1835               	/* #NOAPP */
 1836               	.LBB42:
 1837               	.LBB43:
 916:Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1839               	.LM163:
 1840 085a 8A85      		ldd r24,Y+10
 1841 085c 9B85      		ldd r25,Y+11
 1842 085e 8050      		subi r24,lo8(xSuspendedTaskList)
 1843 0860 9040      		sbci r25,hi8(xSuspendedTaskList)
 1844 0862 01F4      		brne .L113
 919:Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1846               	.LM164:
 1847 0864 8C89      		ldd r24,Y+20
 1848 0866 9D89      		ldd r25,Y+21
 1849 0868 20E0      		ldi r18,hi8(xPendingReadyList)
 1850 086a 8030      		cpi r24,lo8(xPendingReadyList)
 1851 086c 9207      		cpc r25,r18
 1852 086e 01F0      		breq .L113
 925:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1854               	.LM165:
 1855 0870 892B      		or r24,r25
 1856 0872 01F4      		brne .L113
 1857 0874 00C0      		rjmp .L118
 1858               	.L115:
 1859               	.LBE43:
 1860               	.LBE42:
 961:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1862               	.LM166:
 1863 0876 9093 0000 		sts uxTopReadyPriority,r25
 1864               	.L116:
 1865 087a 89E0      		ldi r24,lo8(9)
 1866 087c 989F      		mul r25,r24
 1867 087e C001      		movw r24,r0
 1868 0880 1124      		clr r1
 1869 0882 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1870 0884 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1871 0886 B801      		movw r22,r16
 1872 0888 0E94 0000 		call vListInsertEnd
 964:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1874               	.LM167:
 1875 088c E091 0000 		lds r30,pxCurrentTCB
 1876 0890 F091 0000 		lds r31,(pxCurrentTCB)+1
 1877 0894 9E89      		ldd r25,Y+22
 1878 0896 8689      		ldd r24,Z+22
 1879 0898 9817      		cp r25,r24
 1880 089a 00F0      		brlo .L113
 968:Source/tasks.c **** 						portYIELD_WITHIN_API();
 1882               	.LM168:
 1883 089c 0E94 0000 		call vPortYield
 1884               	.L113:
 972:Source/tasks.c **** 			portEXIT_CRITICAL();
 1886               	.LM169:
 1887               	/* #APP */
 1888               	 ;  972 "Source/tasks.c" 1
 1889 08a0 0F90      		pop		__tmp_reg__
 1890               	 ;  0 "" 2
 1891               	 ;  972 "Source/tasks.c" 1
 1892 08a2 0FBE      		out		__SREG__, __tmp_reg__
 1893               	 ;  0 "" 2
 1894               	/* #NOAPP */
 1895 08a4 00C0      		rjmp .L117
 1896               	.L118:
 960:Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1898               	.LM170:
 1899 08a6 8E01      		movw r16,r28
 1900 08a8 0E5F      		subi r16,lo8(-(2))
 1901 08aa 1F4F      		sbci r17,hi8(-(2))
 1902 08ac C801      		movw r24,r16
 1903 08ae 0E94 0000 		call vListRemove
 961:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1905               	.LM171:
 1906 08b2 9E89      		ldd r25,Y+22
 1907 08b4 8091 0000 		lds r24,uxTopReadyPriority
 1908 08b8 8917      		cp r24,r25
 1909 08ba 00F0      		brlo .L115
 1910 08bc 00C0      		rjmp .L116
 1911               	.L117:
 1912               	/* epilogue start */
 974:Source/tasks.c **** 	}
 1914               	.LM172:
 1915 08be DF91      		pop r29
 1916 08c0 CF91      		pop r28
 1917 08c2 1F91      		pop r17
 1918 08c4 0F91      		pop r16
 1919 08c6 0895      		ret
 1921               	.Lscope20:
 1923               		.stabd	78,0,0
 1926               	.global	vTaskSuspend
 1928               	vTaskSuspend:
 1929               		.stabd	46,0,0
 867:Source/tasks.c **** 	{
 1931               	.LM173:
 1932               	.LFBB21:
 1933 08c8 EF92      		push r14
 1934 08ca FF92      		push r15
 1935 08cc 0F93      		push r16
 1936 08ce 1F93      		push r17
 1937 08d0 CF93      		push r28
 1938 08d2 DF93      		push r29
 1939               	/* prologue: function */
 1940               	/* frame size = 0 */
 1941 08d4 8C01      		movw r16,r24
 870:Source/tasks.c **** 		portENTER_CRITICAL();
 1943               	.LM174:
 1944               	/* #APP */
 1945               	 ;  870 "Source/tasks.c" 1
 1946 08d6 0FB6      		in		__tmp_reg__, __SREG__
 1947               	 ;  0 "" 2
 1948               	 ;  870 "Source/tasks.c" 1
 1949 08d8 F894      		cli
 1950               	 ;  0 "" 2
 1951               	 ;  870 "Source/tasks.c" 1
 1952 08da 0F92      		push	__tmp_reg__
 1953               	 ;  0 "" 2
 874:Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1955               	.LM175:
 1956               	/* #NOAPP */
 1957 08dc 8091 0000 		lds r24,pxCurrentTCB
 1958 08e0 9091 0000 		lds r25,(pxCurrentTCB)+1
 1959 08e4 0817      		cp r16,r24
 1960 08e6 1907      		cpc r17,r25
 1961 08e8 01F4      		brne .L120
 1962 08ea 00E0      		ldi r16,lo8(0)
 1963 08ec 10E0      		ldi r17,hi8(0)
 1964 08ee 00C0      		rjmp .L121
 1965               	.L120:
 880:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1967               	.LM176:
 1968 08f0 0115      		cp r16,__zero_reg__
 1969 08f2 1105      		cpc r17,__zero_reg__
 1970 08f4 01F4      		brne .L122
 1971               	.L121:
 1972 08f6 C091 0000 		lds r28,pxCurrentTCB
 1973 08fa D091 0000 		lds r29,(pxCurrentTCB)+1
 1974 08fe 00C0      		rjmp .L123
 1975               	.L122:
 1976 0900 E801      		movw r28,r16
 1977               	.L123:
 885:Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1979               	.LM177:
 1980 0902 72E0      		ldi r23,lo8(2)
 1981 0904 E72E      		mov r14,r23
 1982 0906 F12C      		mov r15,__zero_reg__
 1983 0908 EC0E      		add r14,r28
 1984 090a FD1E      		adc r15,r29
 1985 090c C701      		movw r24,r14
 1986 090e 0E94 0000 		call vListRemove
 888:Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 1988               	.LM178:
 1989 0912 8C89      		ldd r24,Y+20
 1990 0914 9D89      		ldd r25,Y+21
 1991 0916 892B      		or r24,r25
 1992 0918 01F0      		breq .L124
 890:Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1994               	.LM179:
 1995 091a CE01      		movw r24,r28
 1996 091c 0C96      		adiw r24,12
 1997 091e 0E94 0000 		call vListRemove
 1998               	.L124:
 893:Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 2000               	.LM180:
 2001 0922 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2002 0924 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2003 0926 B701      		movw r22,r14
 2004 0928 0E94 0000 		call vListInsertEnd
 895:Source/tasks.c **** 		portEXIT_CRITICAL();
 2006               	.LM181:
 2007               	/* #APP */
 2008               	 ;  895 "Source/tasks.c" 1
 2009 092c 0F90      		pop		__tmp_reg__
 2010               	 ;  0 "" 2
 2011               	 ;  895 "Source/tasks.c" 1
 2012 092e 0FBE      		out		__SREG__, __tmp_reg__
 2013               	 ;  0 "" 2
 898:Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 2015               	.LM182:
 2016               	/* #NOAPP */
 2017 0930 012B      		or r16,r17
 2018 0932 01F4      		brne .L126
 900:Source/tasks.c **** 			portYIELD_WITHIN_API();
 2020               	.LM183:
 2021 0934 0E94 0000 		call vPortYield
 2022               	.L126:
 2023               	/* epilogue start */
 902:Source/tasks.c **** 	}
 2025               	.LM184:
 2026 0938 DF91      		pop r29
 2027 093a CF91      		pop r28
 2028 093c 1F91      		pop r17
 2029 093e 0F91      		pop r16
 2030 0940 FF90      		pop r15
 2031 0942 EF90      		pop r14
 2032 0944 0895      		ret
 2037               	.Lscope21:
 2039               		.stabd	78,0,0
 2043               	.global	vTaskPrioritySet
 2045               	vTaskPrioritySet:
 2046               		.stabd	46,0,0
 762:Source/tasks.c **** 	{
 2048               	.LM185:
 2049               	.LFBB22:
 2050 0946 EF92      		push r14
 2051 0948 FF92      		push r15
 2052 094a 0F93      		push r16
 2053 094c 1F93      		push r17
 2054 094e DF93      		push r29
 2055 0950 CF93      		push r28
 2056 0952 0F92      		push __tmp_reg__
 2057 0954 CDB7      		in r28,__SP_L__
 2058 0956 DEB7      		in r29,__SP_H__
 2059               	/* prologue: function */
 2060               	/* frame size = 1 */
 2061 0958 9C01      		movw r18,r24
 762:Source/tasks.c **** 	{
 2063               	.LM186:
 2064 095a 6330      		cpi r22,lo8(3)
 2065 095c 00F0      		brlo .L128
 2066 095e 62E0      		ldi r22,lo8(2)
 2067               	.L128:
 772:Source/tasks.c **** 		portENTER_CRITICAL();
 2069               	.LM187:
 2070               	/* #APP */
 2071               	 ;  772 "Source/tasks.c" 1
 2072 0960 0FB6      		in		__tmp_reg__, __SREG__
 2073               	 ;  0 "" 2
 2074               	 ;  772 "Source/tasks.c" 1
 2075 0962 F894      		cli
 2076               	 ;  0 "" 2
 2077               	 ;  772 "Source/tasks.c" 1
 2078 0964 0F92      		push	__tmp_reg__
 2079               	 ;  0 "" 2
 774:Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 2081               	.LM188:
 2082               	/* #NOAPP */
 2083 0966 8091 0000 		lds r24,pxCurrentTCB
 2084 096a 9091 0000 		lds r25,(pxCurrentTCB)+1
 2085 096e 2817      		cp r18,r24
 2086 0970 3907      		cpc r19,r25
 2087 0972 01F4      		brne .L129
 2088 0974 20E0      		ldi r18,lo8(0)
 2089 0976 30E0      		ldi r19,hi8(0)
 2090 0978 00C0      		rjmp .L130
 2091               	.L129:
 781:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 2093               	.LM189:
 2094 097a 2115      		cp r18,__zero_reg__
 2095 097c 3105      		cpc r19,__zero_reg__
 2096 097e 01F4      		brne .L131
 2097               	.L130:
 2098 0980 E090 0000 		lds r14,pxCurrentTCB
 2099 0984 F090 0000 		lds r15,(pxCurrentTCB)+1
 2100 0988 00C0      		rjmp .L132
 2101               	.L131:
 2102 098a 7901      		movw r14,r18
 2103               	.L132:
 791:Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 2105               	.LM190:
 2106 098c F701      		movw r30,r14
 2107 098e 4689      		ldd r20,Z+22
 795:Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 2109               	.LM191:
 2110 0990 4617      		cp r20,r22
 2111 0992 01F0      		breq .L133
 799:Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 2113               	.LM192:
 2114 0994 4617      		cp r20,r22
 2115 0996 00F4      		brsh .L134
 2116 0998 1982      		std Y+1,__zero_reg__
 2117 099a 232B      		or r18,r19
 2118 099c 01F0      		breq .L136
 2119 099e F1E0      		ldi r31,lo8(1)
 2120 09a0 F983      		std Y+1,r31
 2121 09a2 00C0      		rjmp .L136
 2122               	.L134:
 2123 09a4 1982      		std Y+1,__zero_reg__
 2124 09a6 232B      		or r18,r19
 2125 09a8 01F4      		brne .L136
 2126 09aa 81E0      		ldi r24,lo8(1)
 2127 09ac 8983      		std Y+1,r24
 2128               	.L136:
 833:Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 2130               	.LM193:
 2131 09ae F701      		movw r30,r14
 2132 09b0 668B      		std Z+22,r22
 837:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 2134               	.LM194:
 2135 09b2 83E0      		ldi r24,lo8(3)
 2136 09b4 90E0      		ldi r25,hi8(3)
 2137 09b6 861B      		sub r24,r22
 2138 09b8 9109      		sbc r25,__zero_reg__
 2139 09ba 9587      		std Z+13,r25
 2140 09bc 8487      		std Z+12,r24
 843:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 2142               	.LM195:
 2143 09be 89E0      		ldi r24,lo8(9)
 2144 09c0 489F      		mul r20,r24
 2145 09c2 C001      		movw r24,r0
 2146 09c4 1124      		clr r1
 2147 09c6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2148 09c8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2149 09ca 2285      		ldd r18,Z+10
 2150 09cc 3385      		ldd r19,Z+11
 2151 09ce 2817      		cp r18,r24
 2152 09d0 3907      		cpc r19,r25
 2153 09d2 01F4      		brne .L138
 848:Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 2155               	.LM196:
 2156 09d4 8701      		movw r16,r14
 2157 09d6 0E5F      		subi r16,lo8(-(2))
 2158 09d8 1F4F      		sbci r17,hi8(-(2))
 2159 09da C801      		movw r24,r16
 2160 09dc 0E94 0000 		call vListRemove
 849:Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2162               	.LM197:
 2163 09e0 F701      		movw r30,r14
 2164 09e2 9689      		ldd r25,Z+22
 2165 09e4 8091 0000 		lds r24,uxTopReadyPriority
 2166 09e8 8917      		cp r24,r25
 2167 09ea 00F4      		brsh .L139
 2168 09ec 9093 0000 		sts uxTopReadyPriority,r25
 2169               	.L139:
 2170 09f0 89E0      		ldi r24,lo8(9)
 2171 09f2 989F      		mul r25,r24
 2172 09f4 C001      		movw r24,r0
 2173 09f6 1124      		clr r1
 2174 09f8 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2175 09fa 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2176 09fc B801      		movw r22,r16
 2177 09fe 0E94 0000 		call vListInsertEnd
 2178               	.L138:
 852:Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 2180               	.LM198:
 2181 0a02 F981      		ldd r31,Y+1
 2182 0a04 F130      		cpi r31,lo8(1)
 2183 0a06 01F4      		brne .L133
 854:Source/tasks.c **** 					portYIELD_WITHIN_API();
 2185               	.LM199:
 2186 0a08 0E94 0000 		call vPortYield
 2187               	.L133:
 858:Source/tasks.c **** 		portEXIT_CRITICAL();
 2189               	.LM200:
 2190               	/* #APP */
 2191               	 ;  858 "Source/tasks.c" 1
 2192 0a0c 0F90      		pop		__tmp_reg__
 2193               	 ;  0 "" 2
 2194               	 ;  858 "Source/tasks.c" 1
 2195 0a0e 0FBE      		out		__SREG__, __tmp_reg__
 2196               	 ;  0 "" 2
 2197               	/* epilogue start */
 859:Source/tasks.c **** 	}
 2199               	.LM201:
 2200               	/* #NOAPP */
 2201 0a10 0F90      		pop __tmp_reg__
 2202 0a12 CF91      		pop r28
 2203 0a14 DF91      		pop r29
 2204 0a16 1F91      		pop r17
 2205 0a18 0F91      		pop r16
 2206 0a1a FF90      		pop r15
 2207 0a1c EF90      		pop r14
 2208 0a1e 0895      		ret
 2215               	.Lscope22:
 2217               		.stabd	78,0,0
 2220               	.global	vTaskDelay
 2222               	vTaskDelay:
 2223               		.stabd	46,0,0
 679:Source/tasks.c **** 	{
 2225               	.LM202:
 2226               	.LFBB23:
 2227 0a20 0F93      		push r16
 2228 0a22 1F93      		push r17
 2229               	/* prologue: function */
 2230               	/* frame size = 0 */
 2231 0a24 9C01      		movw r18,r24
 684:Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 2233               	.LM203:
 2234 0a26 0097      		sbiw r24,0
 2235 0a28 01F0      		breq .L142
 2236               	.LBB44:
 2237               	.LBB45:
1078:Source/tasks.c **** 	++uxSchedulerSuspended;
 2239               	.LM204:
 2240 0a2a 8091 0000 		lds r24,uxSchedulerSuspended
 2241 0a2e 8F5F      		subi r24,lo8(-(1))
 2242 0a30 8093 0000 		sts uxSchedulerSuspended,r24
 2243               	.LBE45:
 2244               	.LBE44:
 700:Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 2246               	.LM205:
 2247 0a34 0091 0000 		lds r16,xTickCount
 2248 0a38 1091 0000 		lds r17,(xTickCount)+1
 2249 0a3c 020F      		add r16,r18
 2250 0a3e 131F      		adc r17,r19
 705:Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2252               	.LM206:
 2253 0a40 8091 0000 		lds r24,pxCurrentTCB
 2254 0a44 9091 0000 		lds r25,(pxCurrentTCB)+1
 2255 0a48 0296      		adiw r24,2
 2256 0a4a 0E94 0000 		call vListRemove
 708:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2258               	.LM207:
 2259 0a4e E091 0000 		lds r30,pxCurrentTCB
 2260 0a52 F091 0000 		lds r31,(pxCurrentTCB)+1
 2261 0a56 1383      		std Z+3,r17
 2262 0a58 0283      		std Z+2,r16
 710:Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2264               	.LM208:
 2265 0a5a 8091 0000 		lds r24,xTickCount
 2266 0a5e 9091 0000 		lds r25,(xTickCount)+1
 2267 0a62 0817      		cp r16,r24
 2268 0a64 1907      		cpc r17,r25
 2269 0a66 00F4      		brsh .L143
 714:Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2271               	.LM209:
 2272 0a68 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2273 0a6c 9091 0000 		lds r25,(pxOverflowDelayedTaskList)+1
 2274 0a70 00C0      		rjmp .L147
 2275               	.L143:
 720:Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2277               	.LM210:
 2278 0a72 8091 0000 		lds r24,pxDelayedTaskList
 2279 0a76 9091 0000 		lds r25,(pxDelayedTaskList)+1
 2280               	.L147:
 2281 0a7a 6091 0000 		lds r22,pxCurrentTCB
 2282 0a7e 7091 0000 		lds r23,(pxCurrentTCB)+1
 2283 0a82 6E5F      		subi r22,lo8(-(2))
 2284 0a84 7F4F      		sbci r23,hi8(-(2))
 2285 0a86 0E94 0000 		call vListInsert
 723:Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 2287               	.LM211:
 2288 0a8a 0E94 0000 		call xTaskResumeAll
 728:Source/tasks.c **** 		if( !xAlreadyYielded )
 2290               	.LM212:
 2291 0a8e 8823      		tst r24
 2292 0a90 01F4      		brne .L146
 2293               	.L142:
 730:Source/tasks.c **** 			portYIELD_WITHIN_API();
 2295               	.LM213:
 2296 0a92 0E94 0000 		call vPortYield
 2297               	.L146:
 2298               	/* epilogue start */
 732:Source/tasks.c **** 	}
 2300               	.LM214:
 2301 0a96 1F91      		pop r17
 2302 0a98 0F91      		pop r16
 2303 0a9a 0895      		ret
 2308               	.Lscope23:
 2310               		.stabd	78,0,0
 2314               	.global	vTaskDelayUntil
 2316               	vTaskDelayUntil:
 2317               		.stabd	46,0,0
 602:Source/tasks.c **** 	{
 2319               	.LM215:
 2320               	.LFBB24:
 2321 0a9c CF93      		push r28
 2322 0a9e DF93      		push r29
 2323               	/* prologue: function */
 2324               	/* frame size = 0 */
 2325 0aa0 FC01      		movw r30,r24
 2326 0aa2 EB01      		movw r28,r22
 2327               	.LBB46:
 2328               	.LBB47:
1078:Source/tasks.c **** 	++uxSchedulerSuspended;
 2330               	.LM216:
 2331 0aa4 8091 0000 		lds r24,uxSchedulerSuspended
 2332 0aa8 8F5F      		subi r24,lo8(-(1))
 2333 0aaa 8093 0000 		sts uxSchedulerSuspended,r24
 2334               	.LBE47:
 2335               	.LBE46:
 609:Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 2337               	.LM217:
 2338 0aae 2081      		ld r18,Z
 2339 0ab0 3181      		ldd r19,Z+1
 2340 0ab2 C20F      		add r28,r18
 2341 0ab4 D31F      		adc r29,r19
 611:Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 2343               	.LM218:
 2344 0ab6 8091 0000 		lds r24,xTickCount
 2345 0aba 9091 0000 		lds r25,(xTickCount)+1
 2346 0abe 8217      		cp r24,r18
 2347 0ac0 9307      		cpc r25,r19
 2348 0ac2 00F4      		brsh .L149
 618:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 2350               	.LM219:
 2351 0ac4 C217      		cp r28,r18
 2352 0ac6 D307      		cpc r29,r19
 2353 0ac8 00F0      		brlo .L153
 2354 0aca 20E0      		ldi r18,lo8(0)
 2355 0acc 00C0      		rjmp .L151
 2356               	.L149:
 628:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 2358               	.LM220:
 2359 0ace C217      		cp r28,r18
 2360 0ad0 D307      		cpc r29,r19
 2361 0ad2 00F0      		brlo .L159
 2362               	.L153:
 2363 0ad4 8091 0000 		lds r24,xTickCount
 2364 0ad8 9091 0000 		lds r25,(xTickCount)+1
 2365 0adc 20E0      		ldi r18,lo8(0)
 2366 0ade 8C17      		cp r24,r28
 2367 0ae0 9D07      		cpc r25,r29
 2368 0ae2 00F4      		brsh .L151
 2369               	.L159:
 2370 0ae4 21E0      		ldi r18,lo8(1)
 2371               	.L151:
 635:Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 2373               	.LM221:
 2374 0ae6 D183      		std Z+1,r29
 2375 0ae8 C083      		st Z,r28
 637:Source/tasks.c **** 			if( xShouldDelay )
 2377               	.LM222:
 2378 0aea 2223      		tst r18
 2379 0aec 01F0      		breq .L155
 644:Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2381               	.LM223:
 2382 0aee 8091 0000 		lds r24,pxCurrentTCB
 2383 0af2 9091 0000 		lds r25,(pxCurrentTCB)+1
 2384 0af6 0296      		adiw r24,2
 2385 0af8 0E94 0000 		call vListRemove
 647:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2387               	.LM224:
 2388 0afc E091 0000 		lds r30,pxCurrentTCB
 2389 0b00 F091 0000 		lds r31,(pxCurrentTCB)+1
 2390 0b04 D383      		std Z+3,r29
 2391 0b06 C283      		std Z+2,r28
 649:Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2393               	.LM225:
 2394 0b08 8091 0000 		lds r24,xTickCount
 2395 0b0c 9091 0000 		lds r25,(xTickCount)+1
 2396 0b10 C817      		cp r28,r24
 2397 0b12 D907      		cpc r29,r25
 2398 0b14 00F4      		brsh .L156
 653:Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2400               	.LM226:
 2401 0b16 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2402 0b1a 9091 0000 		lds r25,(pxOverflowDelayedTaskList)+1
 2403 0b1e 00C0      		rjmp .L160
 2404               	.L156:
 659:Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2406               	.LM227:
 2407 0b20 8091 0000 		lds r24,pxDelayedTaskList
 2408 0b24 9091 0000 		lds r25,(pxDelayedTaskList)+1
 2409               	.L160:
 2410 0b28 6091 0000 		lds r22,pxCurrentTCB
 2411 0b2c 7091 0000 		lds r23,(pxCurrentTCB)+1
 2412 0b30 6E5F      		subi r22,lo8(-(2))
 2413 0b32 7F4F      		sbci r23,hi8(-(2))
 2414 0b34 0E94 0000 		call vListInsert
 2415               	.L155:
 663:Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 2417               	.LM228:
 2418 0b38 0E94 0000 		call xTaskResumeAll
 667:Source/tasks.c **** 		if( !xAlreadyYielded )
 2420               	.LM229:
 2421 0b3c 8823      		tst r24
 2422 0b3e 01F4      		brne .L158
 669:Source/tasks.c **** 			portYIELD_WITHIN_API();
 2424               	.LM230:
 2425 0b40 0E94 0000 		call vPortYield
 2426               	.L158:
 2427               	/* epilogue start */
 671:Source/tasks.c **** 	}
 2429               	.LM231:
 2430 0b44 DF91      		pop r29
 2431 0b46 CF91      		pop r28
 2432 0b48 0895      		ret
 2438               	.Lscope24:
 2440               		.stabd	78,0,0
 2442               	.global	vTaskEndScheduler
 2444               	vTaskEndScheduler:
 2445               		.stabd	46,0,0
1064:Source/tasks.c **** {
 2447               	.LM232:
 2448               	.LFBB25:
 2449               	/* prologue: function */
 2450               	/* frame size = 0 */
1068:Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 2452               	.LM233:
 2453               	/* #APP */
 2454               	 ;  1068 "Source/tasks.c" 1
 2455 0b4a F894      		cli
 2456               	 ;  0 "" 2
1069:Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 2458               	.LM234:
 2459               	/* #NOAPP */
 2460 0b4c 1092 0000 		sts xSchedulerRunning,__zero_reg__
1070:Source/tasks.c **** 	vPortEndScheduler();
 2462               	.LM235:
 2463 0b50 0E94 0000 		call vPortEndScheduler
 2464               	/* epilogue start */
1071:Source/tasks.c **** }
 2466               	.LM236:
 2467 0b54 0895      		ret
 2469               	.Lscope25:
 2471               		.stabd	78,0,0
 2481               	.global	xTaskGenericCreate
 2483               	xTaskGenericCreate:
 2484               		.stabd	46,0,0
 387:Source/tasks.c **** {
 2486               	.LM237:
 2487               	.LFBB26:
 2488 0b56 2F92      		push r2
 2489 0b58 3F92      		push r3
 2490 0b5a 4F92      		push r4
 2491 0b5c 5F92      		push r5
 2492 0b5e 7F92      		push r7
 2493 0b60 8F92      		push r8
 2494 0b62 9F92      		push r9
 2495 0b64 AF92      		push r10
 2496 0b66 BF92      		push r11
 2497 0b68 CF92      		push r12
 2498 0b6a DF92      		push r13
 2499 0b6c EF92      		push r14
 2500 0b6e FF92      		push r15
 2501 0b70 0F93      		push r16
 2502 0b72 1F93      		push r17
 2503 0b74 DF93      		push r29
 2504 0b76 CF93      		push r28
 2505 0b78 00D0      		rcall .
 2506 0b7a 00D0      		rcall .
 2507 0b7c CDB7      		in r28,__SP_L__
 2508 0b7e DEB7      		in r29,__SP_H__
 2509               	/* prologue: function */
 2510               	/* frame size = 4 */
 2511 0b80 1C01      		movw r2,r24
 2512 0b82 4B01      		movw r8,r22
 2513 0b84 5A01      		movw r10,r20
 2514 0b86 2901      		movw r4,r18
 2515 0b88 702E      		mov r7,r16
 2516 0b8a FA82      		std Y+2,r15
 2517 0b8c E982      		std Y+1,r14
 2518               	.LBB48:
2004:Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 2520               	.LM238:
 2521 0b8e 84E2      		ldi r24,lo8(36)
 2522 0b90 90E0      		ldi r25,hi8(36)
 2523 0b92 0E94 0000 		call pvPortMalloc
 2524               	.LBB49:
 2525 0b96 8B83      		std Y+3,r24
 2526 0b98 9C83      		std Y+4,r25
2006:Source/tasks.c **** 	if( pxNewTCB != NULL )
 2528               	.LM239:
 2529 0b9a 8B81      		ldd r24,Y+3
 2530 0b9c 9C81      		ldd r25,Y+4
 2531 0b9e 892B      		or r24,r25
 2532 0ba0 01F0      		breq .L176
 2533               	.L164:
2011:Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 2535               	.LM240:
 2536 0ba2 C114      		cp r12,__zero_reg__
 2537 0ba4 D104      		cpc r13,__zero_reg__
 2538 0ba6 01F4      		brne .L166
 2539               	.LBE49:
 2540 0ba8 C501      		movw r24,r10
 2541 0baa 0E94 0000 		call pvPortMalloc
 2542               	.LBB50:
 2543 0bae 6C01      		movw r12,r24
 2544               	.L166:
 2545 0bb0 EB81      		ldd r30,Y+3
 2546 0bb2 FC81      		ldd r31,Y+4
 2547 0bb4 D08E      		std Z+24,r13
 2548 0bb6 C78A      		std Z+23,r12
2013:Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 2550               	.LM241:
 2551 0bb8 C114      		cp r12,__zero_reg__
 2552 0bba D104      		cpc r13,__zero_reg__
 2553 0bbc 01F4      		brne .L167
2016:Source/tasks.c **** 			vPortFree( pxNewTCB );
 2555               	.LM242:
 2556 0bbe CF01      		movw r24,r30
 2557 0bc0 0E94 0000 		call vPortFree
 2558               	.L176:
 2559 0bc4 8FEF      		ldi r24,lo8(-1)
 2560 0bc6 00C0      		rjmp .L165
 2561               	.L167:
2022:Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 2563               	.LM243:
 2564 0bc8 C601      		movw r24,r12
 2565 0bca 65EA      		ldi r22,lo8(165)
 2566 0bcc 70E0      		ldi r23,hi8(165)
 2567 0bce A501      		movw r20,r10
 2568 0bd0 0E94 0000 		call memset
 2569               	.LBE50:
 2570               	.LBE48:
 2571               	.LBB51:
 419:Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 2573               	.LM244:
 2574 0bd4 0894      		sec
 2575 0bd6 A108      		sbc r10,__zero_reg__
 2576 0bd8 B108      		sbc r11,__zero_reg__
 2577 0bda EB81      		ldd r30,Y+3
 2578 0bdc FC81      		ldd r31,Y+4
 2579 0bde E788      		ldd r14,Z+23
 2580 0be0 F08C      		ldd r15,Z+24
 2581 0be2 EA0C      		add r14,r10
 2582 0be4 FB1C      		adc r15,r11
 2583               	.LBB52:
 2584               	.LBB53:
1851:Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2586               	.LM245:
 2587 0be6 CF01      		movw r24,r30
 2588 0be8 4996      		adiw r24,25
 2589 0bea B401      		movw r22,r8
 2590 0bec 4AE0      		ldi r20,lo8(10)
 2591 0bee 50E0      		ldi r21,hi8(10)
 2592 0bf0 0E94 0000 		call strncpy
1854:Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 2594               	.LM246:
 2595 0bf4 EB81      		ldd r30,Y+3
 2596 0bf6 FC81      		ldd r31,Y+4
 2597 0bf8 12A2      		std Z+34,__zero_reg__
 2598 0bfa 072D      		mov r16,r7
 2599 0bfc F2E0      		ldi r31,lo8(2)
 2600 0bfe F715      		cp r31,r7
 2601 0c00 00F4      		brsh .L168
 2602 0c02 02E0      		ldi r16,lo8(2)
 2603               	.L168:
1863:Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2605               	.LM247:
 2606 0c04 EB81      		ldd r30,Y+3
 2607 0c06 FC81      		ldd r31,Y+4
 2608 0c08 068B      		std Z+22,r16
1870:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2610               	.LM248:
 2611 0c0a A2E0      		ldi r26,lo8(2)
 2612 0c0c CA2E      		mov r12,r26
 2613 0c0e D12C      		mov r13,__zero_reg__
 2614 0c10 CE0E      		add r12,r30
 2615 0c12 DF1E      		adc r13,r31
 2616 0c14 C601      		movw r24,r12
 2617 0c16 0E94 0000 		call vListInitialiseItem
1871:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2619               	.LM249:
 2620 0c1a 8B81      		ldd r24,Y+3
 2621 0c1c 9C81      		ldd r25,Y+4
 2622 0c1e 0C96      		adiw r24,12
 2623 0c20 0E94 0000 		call vListInitialiseItem
1875:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2625               	.LM250:
 2626 0c24 8B81      		ldd r24,Y+3
 2627 0c26 9C81      		ldd r25,Y+4
 2628 0c28 FC01      		movw r30,r24
 2629 0c2a 9187      		std Z+9,r25
 2630 0c2c 8087      		std Z+8,r24
1878:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 2632               	.LM251:
 2633 0c2e 83E0      		ldi r24,lo8(3)
 2634 0c30 90E0      		ldi r25,hi8(3)
 2635 0c32 801B      		sub r24,r16
 2636 0c34 9109      		sbc r25,__zero_reg__
 2637 0c36 9587      		std Z+13,r25
 2638 0c38 8487      		std Z+12,r24
1879:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2640               	.LM252:
 2641 0c3a F38B      		std Z+19,r31
 2642 0c3c E28B      		std Z+18,r30
 2643               	.LBE53:
 2644               	.LBE52:
 447:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 2646               	.LM253:
 2647 0c3e C701      		movw r24,r14
 2648 0c40 B101      		movw r22,r2
 2649 0c42 A201      		movw r20,r4
 2650 0c44 0E94 0000 		call pxPortInitialiseStack
 2651 0c48 EB81      		ldd r30,Y+3
 2652 0c4a FC81      		ldd r31,Y+4
 2653 0c4c 9183      		std Z+1,r25
 2654 0c4e 8083      		st Z,r24
 453:Source/tasks.c **** 		portENTER_CRITICAL();
 2656               	.LM254:
 2657               	/* #APP */
 2658               	 ;  453 "Source/tasks.c" 1
 2659 0c50 0FB6      		in		__tmp_reg__, __SREG__
 2660               	 ;  0 "" 2
 2661               	 ;  453 "Source/tasks.c" 1
 2662 0c52 F894      		cli
 2663               	 ;  0 "" 2
 2664               	 ;  453 "Source/tasks.c" 1
 2665 0c54 0F92      		push	__tmp_reg__
 2666               	 ;  0 "" 2
 455:Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 2668               	.LM255:
 2669               	/* #NOAPP */
 2670 0c56 8091 0000 		lds r24,uxCurrentNumberOfTasks
 2671 0c5a 8F5F      		subi r24,lo8(-(1))
 2672 0c5c 8093 0000 		sts uxCurrentNumberOfTasks,r24
 456:Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 2674               	.LM256:
 2675 0c60 8091 0000 		lds r24,uxCurrentNumberOfTasks
 2676 0c64 8130      		cpi r24,lo8(1)
 2677 0c66 01F4      		brne .L169
 459:Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 2679               	.LM257:
 2680 0c68 F093 0000 		sts (pxCurrentTCB)+1,r31
 2681 0c6c E093 0000 		sts pxCurrentTCB,r30
 2682               	.LBB54:
 2683               	.LBB55:
1937:Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 2685               	.LM258:
 2686 0c70 80E0      		ldi r24,lo8(pxReadyTasksLists)
 2687 0c72 90E0      		ldi r25,hi8(pxReadyTasksLists)
 2688 0c74 0E94 0000 		call vListInitialise
 2689 0c78 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 2690 0c7a 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 2691 0c7c 0E94 0000 		call vListInitialise
 2692 0c80 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 2693 0c82 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 2694 0c84 0E94 0000 		call vListInitialise
1940:Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 2696               	.LM259:
 2697 0c88 E0E0      		ldi r30,lo8(xDelayedTaskList1)
 2698 0c8a EE2E      		mov r14,r30
 2699 0c8c E0E0      		ldi r30,hi8(xDelayedTaskList1)
 2700 0c8e FE2E      		mov r15,r30
 2701 0c90 C701      		movw r24,r14
 2702 0c92 0E94 0000 		call vListInitialise
1941:Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 2704               	.LM260:
 2705 0c96 00E0      		ldi r16,lo8(xDelayedTaskList2)
 2706 0c98 10E0      		ldi r17,hi8(xDelayedTaskList2)
 2707 0c9a C801      		movw r24,r16
 2708 0c9c 0E94 0000 		call vListInitialise
1942:Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 2710               	.LM261:
 2711 0ca0 80E0      		ldi r24,lo8(xPendingReadyList)
 2712 0ca2 90E0      		ldi r25,hi8(xPendingReadyList)
 2713 0ca4 0E94 0000 		call vListInitialise
1952:Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 2715               	.LM262:
 2716 0ca8 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2717 0caa 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2718 0cac 0E94 0000 		call vListInitialise
1958:Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 2720               	.LM263:
 2721 0cb0 F092 0000 		sts (pxDelayedTaskList)+1,r15
 2722 0cb4 E092 0000 		sts pxDelayedTaskList,r14
1959:Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 2724               	.LM264:
 2725 0cb8 1093 0000 		sts (pxOverflowDelayedTaskList)+1,r17
 2726 0cbc 0093 0000 		sts pxOverflowDelayedTaskList,r16
 2727 0cc0 00C0      		rjmp .L170
 2728               	.L169:
 2729               	.LBE55:
 2730               	.LBE54:
 471:Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 2732               	.LM265:
 2733 0cc2 8091 0000 		lds r24,xSchedulerRunning
 2734 0cc6 8823      		tst r24
 2735 0cc8 01F4      		brne .L170
 473:Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 2737               	.LM266:
 2738 0cca E091 0000 		lds r30,pxCurrentTCB
 2739 0cce F091 0000 		lds r31,(pxCurrentTCB)+1
 2740 0cd2 8689      		ldd r24,Z+22
 2741 0cd4 7816      		cp r7,r24
 2742 0cd6 00F0      		brlo .L170
 475:Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 2744               	.LM267:
 2745 0cd8 8B81      		ldd r24,Y+3
 2746 0cda 9C81      		ldd r25,Y+4
 2747 0cdc 9093 0000 		sts (pxCurrentTCB)+1,r25
 2748 0ce0 8093 0000 		sts pxCurrentTCB,r24
 2749               	.L170:
 482:Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 2751               	.LM268:
 2752 0ce4 EB81      		ldd r30,Y+3
 2753 0ce6 FC81      		ldd r31,Y+4
 2754 0ce8 9689      		ldd r25,Z+22
 2755 0cea 8091 0000 		lds r24,uxTopUsedPriority
 2756 0cee 8917      		cp r24,r25
 2757 0cf0 00F4      		brsh .L171
 484:Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 2759               	.LM269:
 2760 0cf2 9093 0000 		sts uxTopUsedPriority,r25
 2761               	.L171:
 490:Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 2763               	.LM270:
 2764 0cf6 8091 0000 		lds r24,uxTaskNumber
 2765 0cfa EB81      		ldd r30,Y+3
 2766 0cfc FC81      		ldd r31,Y+4
 2767 0cfe 83A3      		std Z+35,r24
 493:Source/tasks.c **** 			uxTaskNumber++;
 2769               	.LM271:
 2770 0d00 8091 0000 		lds r24,uxTaskNumber
 2771 0d04 8F5F      		subi r24,lo8(-(1))
 2772 0d06 8093 0000 		sts uxTaskNumber,r24
 495:Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 2774               	.LM272:
 2775 0d0a 9689      		ldd r25,Z+22
 2776 0d0c 8091 0000 		lds r24,uxTopReadyPriority
 2777 0d10 8917      		cp r24,r25
 2778 0d12 00F4      		brsh .L172
 2779 0d14 9093 0000 		sts uxTopReadyPriority,r25
 2780               	.L172:
 2781 0d18 EB81      		ldd r30,Y+3
 2782 0d1a FC81      		ldd r31,Y+4
 2783 0d1c 8689      		ldd r24,Z+22
 2784 0d1e 29E0      		ldi r18,lo8(9)
 2785 0d20 829F      		mul r24,r18
 2786 0d22 C001      		movw r24,r0
 2787 0d24 1124      		clr r1
 2788 0d26 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2789 0d28 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2790 0d2a B601      		movw r22,r12
 2791 0d2c 0E94 0000 		call vListInsertEnd
 500:Source/tasks.c **** 		portEXIT_CRITICAL();
 2793               	.LM273:
 2794               	/* #APP */
 2795               	 ;  500 "Source/tasks.c" 1
 2796 0d30 0F90      		pop		__tmp_reg__
 2797               	 ;  0 "" 2
 2798               	 ;  500 "Source/tasks.c" 1
 2799 0d32 0FBE      		out		__SREG__, __tmp_reg__
 2800               	 ;  0 "" 2
 2801               	/* #NOAPP */
 2802               	.LBE51:
 510:Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 2804               	.LM274:
 2805 0d34 8981      		ldd r24,Y+1
 2806 0d36 9A81      		ldd r25,Y+2
 2807 0d38 892B      		or r24,r25
 2808 0d3a 01F0      		breq .L173
 515:Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 2810               	.LM275:
 2811 0d3c 8B81      		ldd r24,Y+3
 2812 0d3e 9C81      		ldd r25,Y+4
 2813 0d40 E981      		ldd r30,Y+1
 2814 0d42 FA81      		ldd r31,Y+2
 2815 0d44 9183      		std Z+1,r25
 2816 0d46 8083      		st Z,r24
 2817               	.L173:
 518:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 2819               	.LM276:
 2820 0d48 8091 0000 		lds r24,xSchedulerRunning
 2821 0d4c 8823      		tst r24
 2822 0d4e 01F0      		breq .L174
 522:Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 2824               	.LM277:
 2825 0d50 E091 0000 		lds r30,pxCurrentTCB
 2826 0d54 F091 0000 		lds r31,(pxCurrentTCB)+1
 2827 0d58 8689      		ldd r24,Z+22
 2828 0d5a 8715      		cp r24,r7
 2829 0d5c 00F4      		brsh .L174
 524:Source/tasks.c **** 				portYIELD_WITHIN_API();
 2831               	.LM278:
 2832 0d5e 0E94 0000 		call vPortYield
 2833               	.L174:
 2834 0d62 81E0      		ldi r24,lo8(1)
 2835               	.L165:
 2836               	/* epilogue start */
 530:Source/tasks.c **** }
 2838               	.LM279:
 2839 0d64 0F90      		pop __tmp_reg__
 2840 0d66 0F90      		pop __tmp_reg__
 2841 0d68 0F90      		pop __tmp_reg__
 2842 0d6a 0F90      		pop __tmp_reg__
 2843 0d6c CF91      		pop r28
 2844 0d6e DF91      		pop r29
 2845 0d70 1F91      		pop r17
 2846 0d72 0F91      		pop r16
 2847 0d74 FF90      		pop r15
 2848 0d76 EF90      		pop r14
 2849 0d78 DF90      		pop r13
 2850 0d7a CF90      		pop r12
 2851 0d7c BF90      		pop r11
 2852 0d7e AF90      		pop r10
 2853 0d80 9F90      		pop r9
 2854 0d82 8F90      		pop r8
 2855 0d84 7F90      		pop r7
 2856 0d86 5F90      		pop r5
 2857 0d88 4F90      		pop r4
 2858 0d8a 3F90      		pop r3
 2859 0d8c 2F90      		pop r2
 2860 0d8e 0895      		ret
 2868               	.Lscope26:
 2870               		.stabd	78,0,0
 2871               		.data
 2872               	.LC2:
 2873 0015 4944 4C45 		.string	"IDLE"
 2873      00
 2874               		.text
 2876               	.global	vTaskStartScheduler
 2878               	vTaskStartScheduler:
 2879               		.stabd	46,0,0
1022:Source/tasks.c **** {
 2881               	.LM280:
 2882               	.LFBB27:
 2883 0d90 AF92      		push r10
 2884 0d92 BF92      		push r11
 2885 0d94 CF92      		push r12
 2886 0d96 DF92      		push r13
 2887 0d98 EF92      		push r14
 2888 0d9a FF92      		push r15
 2889 0d9c 0F93      		push r16
 2890               	/* prologue: function */
 2891               	/* frame size = 0 */
1026:Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 2893               	.LM281:
 2894 0d9e 80E0      		ldi r24,lo8(gs(prvIdleTask))
 2895 0da0 90E0      		ldi r25,hi8(gs(prvIdleTask))
 2896 0da2 60E0      		ldi r22,lo8(.LC2)
 2897 0da4 70E0      		ldi r23,hi8(.LC2)
 2898 0da6 44E6      		ldi r20,lo8(100)
 2899 0da8 50E0      		ldi r21,hi8(100)
 2900 0daa 20E0      		ldi r18,lo8(0)
 2901 0dac 30E0      		ldi r19,hi8(0)
 2902 0dae 00E0      		ldi r16,lo8(0)
 2903 0db0 EE24      		clr r14
 2904 0db2 FF24      		clr r15
 2905 0db4 CC24      		clr r12
 2906 0db6 DD24      		clr r13
 2907 0db8 AA24      		clr r10
 2908 0dba BB24      		clr r11
 2909 0dbc 0E94 0000 		call xTaskGenericCreate
1028:Source/tasks.c **** 	if( xReturn == pdPASS )
 2911               	.LM282:
 2912 0dc0 8130      		cpi r24,lo8(1)
 2913 0dc2 01F4      		brne .L179
1038:Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 2915               	.LM283:
 2916               	/* #APP */
 2917               	 ;  1038 "Source/tasks.c" 1
 2918 0dc4 F894      		cli
 2919               	 ;  0 "" 2
1040:Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 2921               	.LM284:
 2922               	/* #NOAPP */
 2923 0dc6 8093 0000 		sts xSchedulerRunning,r24
1041:Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
 2925               	.LM285:
 2926 0dca 1092 0000 		sts (xTickCount)+1,__zero_reg__
 2927 0dce 1092 0000 		sts xTickCount,__zero_reg__
1050:Source/tasks.c **** 		if( xPortStartScheduler() )
 2929               	.LM286:
 2930 0dd2 0E94 0000 		call xPortStartScheduler
 2931               	.L179:
 2932               	/* epilogue start */
1060:Source/tasks.c **** }
 2934               	.LM287:
 2935 0dd6 0F91      		pop r16
 2936 0dd8 FF90      		pop r15
 2937 0dda EF90      		pop r14
 2938 0ddc DF90      		pop r13
 2939 0dde CF90      		pop r12
 2940 0de0 BF90      		pop r11
 2941 0de2 AF90      		pop r10
 2942 0de4 0895      		ret
 2944               	.Lscope27:
 2946               		.stabd	78,0,0
 2947               	.global	pxCurrentTCB
 2948               	.global	pxCurrentTCB
 2949               		.section .bss
 2952               	pxCurrentTCB:
 2953 0000 0000      		.skip 2,0
 2954               		.lcomm xMissedYield,1
 2955               		.lcomm xNumOfOverflows,1
 2956               		.lcomm xTickCount,2
 2957               		.lcomm uxSchedulerSuspended,1
 2958               		.lcomm uxTopReadyPriority,1
 2959               		.lcomm xTracing,1
 2960               		.data
 2963               	uxPreviousTask:
 2964 001a FF        		.byte	-1
 2965               		.lcomm uxMissedTicks,1
 2966               		.lcomm uxTopUsedPriority,1
 2967               		.lcomm uxCurrentNumberOfTasks,1
 2968               		.lcomm xSchedulerRunning,1
 2969               		.lcomm uxTaskNumber,1
 2970               		.lcomm pxReadyTasksLists,27
 2971               		.lcomm xDelayedTaskList1,9
 2972               		.lcomm xDelayedTaskList2,9
 2973               		.lcomm pxDelayedTaskList,2
 2974               		.lcomm pxOverflowDelayedTaskList,2
 2975               		.lcomm xPendingReadyList,9
 2976               		.lcomm xSuspendedTaskList,9
 2977               		.lcomm pcTraceBuffer,2
 2978               		.lcomm pcTraceBufferStart,2
 2979               		.lcomm pcTraceBufferEnd,2
 2980               		.lcomm pcStatusString,50
 3005               		.text
 3007               	.Letext0:
 3008               	.global __do_copy_data
 3009               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccmWiebN.s:2      *ABS*:0000003f __SREG__
     /tmp/ccmWiebN.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccmWiebN.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccmWiebN.s:5      *ABS*:00000034 __CCP__
     /tmp/ccmWiebN.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccmWiebN.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccmWiebN.s:124    .text:00000000 uxTaskPriorityGet
     /tmp/ccmWiebN.s:2952   .bss:00000000 pxCurrentTCB
     /tmp/ccmWiebN.s:179    .text:0000001e xTaskIsTaskSuspended
     /tmp/ccmWiebN.s:2975   .bss:00000048 xSuspendedTaskList
     /tmp/ccmWiebN.s:2974   .bss:0000003f xPendingReadyList
     /tmp/ccmWiebN.s:227    .text:00000046 vTaskSuspendAll
     /tmp/ccmWiebN.s:2956   .bss:00000006 uxSchedulerSuspended
     /tmp/ccmWiebN.s:250    .text:00000052 xTaskGetTickCount
     /tmp/ccmWiebN.s:2955   .bss:00000004 xTickCount
     /tmp/ccmWiebN.s:299    .text:00000068 uxTaskGetNumberOfTasks
     /tmp/ccmWiebN.s:2966   .bss:0000000b uxCurrentNumberOfTasks
     /tmp/ccmWiebN.s:322    .text:0000006e vTaskStartTrace
     /tmp/ccmWiebN.s:2976   .bss:00000051 pcTraceBuffer
     /tmp/ccmWiebN.s:2977   .bss:00000053 pcTraceBufferStart
     /tmp/ccmWiebN.s:2978   .bss:00000055 pcTraceBufferEnd
     /tmp/ccmWiebN.s:2958   .bss:00000008 xTracing
     /tmp/ccmWiebN.s:383    .text:000000a0 ulTaskEndTrace
     /tmp/ccmWiebN.s:441    .text:000000d0 vTaskSwitchContext
                             .bss:00000002 xMissedYield
     /tmp/ccmWiebN.s:2957   .bss:00000007 uxTopReadyPriority
     /tmp/ccmWiebN.s:2969   .bss:0000000e pxReadyTasksLists
     /tmp/ccmWiebN.s:2963   .data:0000001a uxPreviousTask
     /tmp/ccmWiebN.s:591    .text:000001f4 vTaskSetTimeOutState
     /tmp/ccmWiebN.s:2954   .bss:00000003 xNumOfOverflows
     /tmp/ccmWiebN.s:622    .text:0000020a xTaskCheckForTimeOut
     /tmp/ccmWiebN.s:733    .text:00000286 vTaskMissedYield
     /tmp/ccmWiebN.s:756    .text:0000028e xTaskRemoveFromEventList
     /tmp/ccmWiebN.s:855    .text:00000314 xTaskResumeFromISR
     /tmp/ccmWiebN.s:980    .text:000003b0 vTaskPlaceOnEventList
     /tmp/ccmWiebN.s:2973   .bss:0000003d pxOverflowDelayedTaskList
     /tmp/ccmWiebN.s:2972   .bss:0000003b pxDelayedTaskList
     /tmp/ccmWiebN.s:1072   .text:00000440 vTaskIncrementTick
     /tmp/ccmWiebN.s:2959   .bss:00000009 uxMissedTicks
     /tmp/ccmWiebN.s:1230   .text:0000053c prvListTaskWithinSingleList
     /tmp/ccmWiebN.s:2979   .bss:00000057 pcStatusString
     /tmp/ccmWiebN.s:1460   .text:00000690 xTaskResumeAll
     /tmp/ccmWiebN.s:1654   .text:0000078a vTaskList
     /tmp/ccmWiebN.s:2965   .bss:0000000a uxTopUsedPriority
     /tmp/ccmWiebN.s:1780   .text:00000830 prvIdleTask
     /tmp/ccmWiebN.s:1799   .text:00000836 vTaskResume
     /tmp/ccmWiebN.s:1928   .text:000008c8 vTaskSuspend
     /tmp/ccmWiebN.s:2045   .text:00000946 vTaskPrioritySet
     /tmp/ccmWiebN.s:2222   .text:00000a20 vTaskDelay
     /tmp/ccmWiebN.s:2316   .text:00000a9c vTaskDelayUntil
     /tmp/ccmWiebN.s:2444   .text:00000b4a vTaskEndScheduler
     /tmp/ccmWiebN.s:2967   .bss:0000000c xSchedulerRunning
     /tmp/ccmWiebN.s:2483   .text:00000b56 xTaskGenericCreate
     /tmp/ccmWiebN.s:2970   .bss:00000029 xDelayedTaskList1
     /tmp/ccmWiebN.s:2971   .bss:00000032 xDelayedTaskList2
     /tmp/ccmWiebN.s:2968   .bss:0000000d uxTaskNumber
     /tmp/ccmWiebN.s:2878   .text:00000d90 vTaskStartScheduler

UNDEFINED SYMBOLS
vListRemove
vListInsertEnd
vListInsert
vApplicationTickHook
sprintf
strcat
vPortYield
vPortEndScheduler
pvPortMalloc
vPortFree
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
xPortStartScheduler
__do_copy_data
__do_clear_bss
