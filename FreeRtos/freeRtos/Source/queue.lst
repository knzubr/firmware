   1               		.file	"queue.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 448               	prvUnlockQueue:
 449               		.stabd	46,0,0
   1:../../freeRtos/Source/queue.c **** /*
   2:../../freeRtos/Source/queue.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/Source/queue.c **** 
   4:../../freeRtos/Source/queue.c ****     ***************************************************************************
   5:../../freeRtos/Source/queue.c ****     *                                                                         *
   6:../../freeRtos/Source/queue.c ****     * If you are:                                                             *
   7:../../freeRtos/Source/queue.c ****     *                                                                         *
   8:../../freeRtos/Source/queue.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/Source/queue.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/Source/queue.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/Source/queue.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/Source/queue.c ****     *                                                                         *
  13:../../freeRtos/Source/queue.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/Source/queue.c ****     *                                                                         *
  15:../../freeRtos/Source/queue.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/Source/queue.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/Source/queue.c ****     *                                                                         *
  18:../../freeRtos/Source/queue.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/Source/queue.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/Source/queue.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/Source/queue.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/Source/queue.c ****     *                                                                         *
  23:../../freeRtos/Source/queue.c ****     ***************************************************************************
  24:../../freeRtos/Source/queue.c **** 
  25:../../freeRtos/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/Source/queue.c **** 
  27:../../freeRtos/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/Source/queue.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/Source/queue.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/Source/queue.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/Source/queue.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/Source/queue.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/Source/queue.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/Source/queue.c ****     FreeRTOS WEB site.
  41:../../freeRtos/Source/queue.c **** 
  42:../../freeRtos/Source/queue.c ****     1 tab == 4 spaces!
  43:../../freeRtos/Source/queue.c **** 
  44:../../freeRtos/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/Source/queue.c ****     contact details.
  46:../../freeRtos/Source/queue.c **** 
  47:../../freeRtos/Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/Source/queue.c ****     critical systems.
  49:../../freeRtos/Source/queue.c **** 
  50:../../freeRtos/Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/Source/queue.c ****     licensing and training services.
  52:../../freeRtos/Source/queue.c **** */
  53:../../freeRtos/Source/queue.c **** 
  54:../../freeRtos/Source/queue.c **** #include <stdlib.h>
  55:../../freeRtos/Source/queue.c **** #include <string.h>
  56:../../freeRtos/Source/queue.c **** 
  57:../../freeRtos/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../../freeRtos/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../../freeRtos/Source/queue.c **** task.h is included from an application file. */
  60:../../freeRtos/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../../freeRtos/Source/queue.c **** 
  62:../../freeRtos/Source/queue.c **** #include "FreeRTOS.h"
  63:../../freeRtos/Source/queue.c **** #include "task.h"
  64:../../freeRtos/Source/queue.c **** #include "croutine.h"
  65:../../freeRtos/Source/queue.c **** 
  66:../../freeRtos/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  67:../../freeRtos/Source/queue.c **** 
  68:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------
  69:../../freeRtos/Source/queue.c ****  * PUBLIC LIST API documented in list.h
  70:../../freeRtos/Source/queue.c ****  *----------------------------------------------------------*/
  71:../../freeRtos/Source/queue.c **** 
  72:../../freeRtos/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  73:../../freeRtos/Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  74:../../freeRtos/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  75:../../freeRtos/Source/queue.c **** 
  76:../../freeRtos/Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  77:../../freeRtos/Source/queue.c **** 
  78:../../freeRtos/Source/queue.c **** /* For internal use only. */
  79:../../freeRtos/Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  80:../../freeRtos/Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  81:../../freeRtos/Source/queue.c **** 
  82:../../freeRtos/Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  83:../../freeRtos/Source/queue.c **** #define pxMutexHolder					pcTail
  84:../../freeRtos/Source/queue.c **** #define uxQueueType						pcHead
  85:../../freeRtos/Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  86:../../freeRtos/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  87:../../freeRtos/Source/queue.c **** 
  88:../../freeRtos/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  89:../../freeRtos/Source/queue.c **** zero. */
  90:../../freeRtos/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( 0 )
  91:../../freeRtos/Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0 )
  92:../../freeRtos/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0 )
  93:../../freeRtos/Source/queue.c **** 
  94:../../freeRtos/Source/queue.c **** /*
  95:../../freeRtos/Source/queue.c ****  * Definition of the queue used by the scheduler.
  96:../../freeRtos/Source/queue.c ****  * Items are queued by copy, not reference.
  97:../../freeRtos/Source/queue.c ****  */
  98:../../freeRtos/Source/queue.c **** typedef struct QueueDefinition
  99:../../freeRtos/Source/queue.c **** {
 100:../../freeRtos/Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 101:../../freeRtos/Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 102:../../freeRtos/Source/queue.c **** 
 103:../../freeRtos/Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 104:../../freeRtos/Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 105:../../freeRtos/Source/queue.c **** 
 106:../../freeRtos/Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 107:../../freeRtos/Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 108:../../freeRtos/Source/queue.c **** 
 109:../../freeRtos/Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 110:../../freeRtos/Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 111:../../freeRtos/Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 112:../../freeRtos/Source/queue.c **** 
 113:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 114:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 115:../../freeRtos/Source/queue.c **** 
 116:../../freeRtos/Source/queue.c **** } xQUEUE;
 117:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 118:../../freeRtos/Source/queue.c **** 
 119:../../freeRtos/Source/queue.c **** /*
 120:../../freeRtos/Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 121:../../freeRtos/Source/queue.c ****  * To keep the definition private the API header file defines it as a
 122:../../freeRtos/Source/queue.c ****  * pointer to void.
 123:../../freeRtos/Source/queue.c ****  */
 124:../../freeRtos/Source/queue.c **** typedef xQUEUE * xQueueHandle;
 125:../../freeRtos/Source/queue.c **** 
 126:../../freeRtos/Source/queue.c **** /*
 127:../../freeRtos/Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 128:../../freeRtos/Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 129:../../freeRtos/Source/queue.c ****  * functions are documented in the API header file.
 130:../../freeRtos/Source/queue.c ****  */
 131:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 132:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxI
 133:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 134:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 135:../../freeRtos/Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 136:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 137:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 138:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 139:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
 140:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 141:../../freeRtos/Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 142:../../freeRtos/Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 143:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 144:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 145:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 146:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 147:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 148:../../freeRtos/Source/queue.c **** 
 149:../../freeRtos/Source/queue.c **** /*
 150:../../freeRtos/Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 151:../../freeRtos/Source/queue.c ****  * an optional component.
 152:../../freeRtos/Source/queue.c ****  */
 153:../../freeRtos/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 154:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 155:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 156:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 157:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 158:../../freeRtos/Source/queue.c **** #endif
 159:../../freeRtos/Source/queue.c **** 
 160:../../freeRtos/Source/queue.c **** /*
 161:../../freeRtos/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 162:../../freeRtos/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 163:../../freeRtos/Source/queue.c ****  */
 164:../../freeRtos/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 165:../../freeRtos/Source/queue.c **** 
 166:../../freeRtos/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 167:../../freeRtos/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 168:../../freeRtos/Source/queue.c **** 	more user friendly. */
 169:../../freeRtos/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 170:../../freeRtos/Source/queue.c **** 	{
 171:../../freeRtos/Source/queue.c **** 		signed char *pcQueueName;
 172:../../freeRtos/Source/queue.c **** 		xQueueHandle xHandle;
 173:../../freeRtos/Source/queue.c **** 	} xQueueRegistryItem;
 174:../../freeRtos/Source/queue.c **** 
 175:../../freeRtos/Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 176:../../freeRtos/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 177:../../freeRtos/Source/queue.c **** 	array position being vacant. */
 178:../../freeRtos/Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 179:../../freeRtos/Source/queue.c **** 
 180:../../freeRtos/Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 181:../../freeRtos/Source/queue.c **** 	member to NULL. */
 182:../../freeRtos/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 183:../../freeRtos/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 184:../../freeRtos/Source/queue.c **** #endif
 185:../../freeRtos/Source/queue.c **** 
 186:../../freeRtos/Source/queue.c **** /*
 187:../../freeRtos/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 188:../../freeRtos/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 189:../../freeRtos/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 190:../../freeRtos/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 191:../../freeRtos/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 192:../../freeRtos/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 193:../../freeRtos/Source/queue.c ****  */
 194:../../freeRtos/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 195:../../freeRtos/Source/queue.c **** 
 196:../../freeRtos/Source/queue.c **** /*
 197:../../freeRtos/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 198:../../freeRtos/Source/queue.c ****  *
 199:../../freeRtos/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 200:../../freeRtos/Source/queue.c ****  */
 201:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 202:../../freeRtos/Source/queue.c **** 
 203:../../freeRtos/Source/queue.c **** /*
 204:../../freeRtos/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 205:../../freeRtos/Source/queue.c ****  *
 206:../../freeRtos/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 207:../../freeRtos/Source/queue.c ****  */
 208:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 209:../../freeRtos/Source/queue.c **** 
 210:../../freeRtos/Source/queue.c **** /*
 211:../../freeRtos/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 212:../../freeRtos/Source/queue.c ****  * back of the queue.
 213:../../freeRtos/Source/queue.c ****  */
 214:../../freeRtos/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 215:../../freeRtos/Source/queue.c **** 
 216:../../freeRtos/Source/queue.c **** /*
 217:../../freeRtos/Source/queue.c ****  * Copies an item out of a queue.
 218:../../freeRtos/Source/queue.c ****  */
 219:../../freeRtos/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 220:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 221:../../freeRtos/Source/queue.c **** 
 222:../../freeRtos/Source/queue.c **** /*
 223:../../freeRtos/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 224:../../freeRtos/Source/queue.c ****  * accessing the queue event lists.
 225:../../freeRtos/Source/queue.c ****  */
 226:../../freeRtos/Source/queue.c **** #define prvLockQueue( pxQueue )							\
 227:../../freeRtos/Source/queue.c **** {														\
 228:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();								\
 229:../../freeRtos/Source/queue.c **** 	{													\
 230:../../freeRtos/Source/queue.c **** 		if( pxQueue->xRxLock == queueUNLOCKED )			\
 231:../../freeRtos/Source/queue.c **** 		{												\
 232:../../freeRtos/Source/queue.c **** 			pxQueue->xRxLock = queueLOCKED_UNMODIFIED;	\
 233:../../freeRtos/Source/queue.c **** 		}												\
 234:../../freeRtos/Source/queue.c **** 		if( pxQueue->xTxLock == queueUNLOCKED )			\
 235:../../freeRtos/Source/queue.c **** 		{												\
 236:../../freeRtos/Source/queue.c **** 			pxQueue->xTxLock = queueLOCKED_UNMODIFIED;	\
 237:../../freeRtos/Source/queue.c **** 		}												\
 238:../../freeRtos/Source/queue.c **** 	}													\
 239:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();								\
 240:../../freeRtos/Source/queue.c **** }
 241:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 242:../../freeRtos/Source/queue.c **** 
 243:../../freeRtos/Source/queue.c **** 
 244:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------
 245:../../freeRtos/Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 246:../../freeRtos/Source/queue.c ****  *----------------------------------------------------------*/
 247:../../freeRtos/Source/queue.c **** 
 248:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 249:../../freeRtos/Source/queue.c **** {
 250:../../freeRtos/Source/queue.c **** xQUEUE *pxNewQueue;
 251:../../freeRtos/Source/queue.c **** size_t xQueueSizeInBytes;
 252:../../freeRtos/Source/queue.c **** 
 253:../../freeRtos/Source/queue.c **** 	/* Allocate the new queue structure. */
 254:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 255:../../freeRtos/Source/queue.c **** 	{
 256:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 257:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 258:../../freeRtos/Source/queue.c **** 		{
 259:../../freeRtos/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 260:../../freeRtos/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 261:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 262:../../freeRtos/Source/queue.c **** 
 263:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 264:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 265:../../freeRtos/Source/queue.c **** 			{
 266:../../freeRtos/Source/queue.c **** 				/* Initialise the queue members as described above where the
 267:../../freeRtos/Source/queue.c **** 				queue type is defined. */
 268:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 269:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 270:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 271:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 272:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 273:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 274:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 275:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 276:../../freeRtos/Source/queue.c **** 
 277:../../freeRtos/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 278:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 279:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 280:../../freeRtos/Source/queue.c **** 
 281:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 282:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 283:../../freeRtos/Source/queue.c **** 			}
 284:../../freeRtos/Source/queue.c **** 			else
 285:../../freeRtos/Source/queue.c **** 			{
 286:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 287:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 288:../../freeRtos/Source/queue.c **** 			}
 289:../../freeRtos/Source/queue.c **** 		}
 290:../../freeRtos/Source/queue.c **** 	}
 291:../../freeRtos/Source/queue.c **** 
 292:../../freeRtos/Source/queue.c **** 	/* Will only reach here if we could not allocate enough memory or no memory
 293:../../freeRtos/Source/queue.c **** 	was required. */
 294:../../freeRtos/Source/queue.c **** 	return NULL;
 295:../../freeRtos/Source/queue.c **** }
 296:../../freeRtos/Source/queue.c **** 
 297:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxI
 298:../../freeRtos/Source/queue.c **** {
 299:../../freeRtos/Source/queue.c **** xQUEUE *pxNewQueue;
 300:../../freeRtos/Source/queue.c **** size_t xQueueSizeInBytes;
 301:../../freeRtos/Source/queue.c **** 
 302:../../freeRtos/Source/queue.c **** 	/* Allocate the new queue structure. */
 303:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 304:../../freeRtos/Source/queue.c **** 	{
 305:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 306:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 307:../../freeRtos/Source/queue.c **** 		{
 308:../../freeRtos/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 309:../../freeRtos/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 310:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 311:../../freeRtos/Source/queue.c **** 
 312:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) (address);
 313:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 314:../../freeRtos/Source/queue.c **** 			{
 315:../../freeRtos/Source/queue.c **** 				/* Initialise the queue members as described above where the
 316:../../freeRtos/Source/queue.c **** 				queue type is defined. */
 317:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 318:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 319:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 320:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 321:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 322:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 323:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 324:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 325:../../freeRtos/Source/queue.c **** 
 326:../../freeRtos/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 327:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 328:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 329:../../freeRtos/Source/queue.c **** 
 330:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 331:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 332:../../freeRtos/Source/queue.c **** 			}
 333:../../freeRtos/Source/queue.c **** 			else
 334:../../freeRtos/Source/queue.c **** 			{
 335:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 336:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 337:../../freeRtos/Source/queue.c **** 			}
 338:../../freeRtos/Source/queue.c **** 		}
 339:../../freeRtos/Source/queue.c **** 	}
 340:../../freeRtos/Source/queue.c **** 
 341:../../freeRtos/Source/queue.c **** 	/* Will only reach here if we could not allocate enough memory or no memory
 342:../../freeRtos/Source/queue.c **** 	was required. */
 343:../../freeRtos/Source/queue.c **** 	return NULL;
 344:../../freeRtos/Source/queue.c **** }
 345:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 346:../../freeRtos/Source/queue.c **** 
 347:../../freeRtos/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 348:../../freeRtos/Source/queue.c **** 
 349:../../freeRtos/Source/queue.c **** 	xQueueHandle xQueueCreateMutex( void )
 350:../../freeRtos/Source/queue.c **** 	{
 351:../../freeRtos/Source/queue.c **** 	xQUEUE *pxNewQueue;
 352:../../freeRtos/Source/queue.c **** 
 353:../../freeRtos/Source/queue.c **** 		/* Allocate the new queue structure. */
 354:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 355:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 356:../../freeRtos/Source/queue.c **** 		{
 357:../../freeRtos/Source/queue.c **** 			/* Information required for priority inheritance. */
 358:../../freeRtos/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 359:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 360:../../freeRtos/Source/queue.c **** 
 361:../../freeRtos/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 362:../../freeRtos/Source/queue.c **** 			of the queue. */
 363:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 364:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 365:../../freeRtos/Source/queue.c **** 
 366:../../freeRtos/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 367:../../freeRtos/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 368:../../freeRtos/Source/queue.c **** 			of the mutex. */
 369:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = 0;
 370:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxLength = 1;
 371:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxItemSize = 0;
 372:../../freeRtos/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 373:../../freeRtos/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 374:../../freeRtos/Source/queue.c **** 
 375:../../freeRtos/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 376:../../freeRtos/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 377:../../freeRtos/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 378:../../freeRtos/Source/queue.c **** 
 379:../../freeRtos/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 380:../../freeRtos/Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, 0, queueSEND_TO_BACK );
 381:../../freeRtos/Source/queue.c **** 
 382:../../freeRtos/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 383:../../freeRtos/Source/queue.c **** 		}
 384:../../freeRtos/Source/queue.c **** 		else
 385:../../freeRtos/Source/queue.c **** 		{
 386:../../freeRtos/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 387:../../freeRtos/Source/queue.c **** 		}
 388:../../freeRtos/Source/queue.c **** 
 389:../../freeRtos/Source/queue.c **** 		return pxNewQueue;
 390:../../freeRtos/Source/queue.c **** 	}
 391:../../freeRtos/Source/queue.c **** 
 392:../../freeRtos/Source/queue.c **** #endif /* configUSE_MUTEXES */
 393:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 394:../../freeRtos/Source/queue.c **** 
 395:../../freeRtos/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 396:../../freeRtos/Source/queue.c **** 
 397:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 398:../../freeRtos/Source/queue.c **** 	{
 399:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xReturn;
 400:../../freeRtos/Source/queue.c **** 
 401:../../freeRtos/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 402:../../freeRtos/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 403:../../freeRtos/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 404:../../freeRtos/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 405:../../freeRtos/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 406:../../freeRtos/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 407:../../freeRtos/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 408:../../freeRtos/Source/queue.c **** 		{
 409:../../freeRtos/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 410:../../freeRtos/Source/queue.c **** 
 411:../../freeRtos/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 412:../../freeRtos/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 413:../../freeRtos/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 414:../../freeRtos/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 415:../../freeRtos/Source/queue.c **** 			uxRecursiveCallCount member. */
 416:../../freeRtos/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 417:../../freeRtos/Source/queue.c **** 
 418:../../freeRtos/Source/queue.c **** 			/* Have we unwound the call count? */
 419:../../freeRtos/Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 420:../../freeRtos/Source/queue.c **** 			{
 421:../../freeRtos/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 422:../../freeRtos/Source/queue.c **** 				task that might be waiting to access the mutex. */
 423:../../freeRtos/Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 424:../../freeRtos/Source/queue.c **** 			}
 425:../../freeRtos/Source/queue.c **** 
 426:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 427:../../freeRtos/Source/queue.c **** 		}
 428:../../freeRtos/Source/queue.c **** 		else
 429:../../freeRtos/Source/queue.c **** 		{
 430:../../freeRtos/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 431:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
 432:../../freeRtos/Source/queue.c **** 
 433:../../freeRtos/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 434:../../freeRtos/Source/queue.c **** 		}
 435:../../freeRtos/Source/queue.c **** 
 436:../../freeRtos/Source/queue.c **** 		return xReturn;
 437:../../freeRtos/Source/queue.c **** 	}
 438:../../freeRtos/Source/queue.c **** 
 439:../../freeRtos/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 440:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 441:../../freeRtos/Source/queue.c **** 
 442:../../freeRtos/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 443:../../freeRtos/Source/queue.c **** 
 444:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 445:../../freeRtos/Source/queue.c **** 	{
 446:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xReturn;
 447:../../freeRtos/Source/queue.c **** 
 448:../../freeRtos/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 449:../../freeRtos/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 450:../../freeRtos/Source/queue.c **** 
 451:../../freeRtos/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 452:../../freeRtos/Source/queue.c **** 
 453:../../freeRtos/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 454:../../freeRtos/Source/queue.c **** 		{
 455:../../freeRtos/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 456:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 457:../../freeRtos/Source/queue.c **** 		}
 458:../../freeRtos/Source/queue.c **** 		else
 459:../../freeRtos/Source/queue.c **** 		{
 460:../../freeRtos/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 461:../../freeRtos/Source/queue.c **** 
 462:../../freeRtos/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 463:../../freeRtos/Source/queue.c **** 			we may have blocked to reach here. */
 464:../../freeRtos/Source/queue.c **** 			if( xReturn == pdPASS )
 465:../../freeRtos/Source/queue.c **** 			{
 466:../../freeRtos/Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 467:../../freeRtos/Source/queue.c **** 			}
 468:../../freeRtos/Source/queue.c **** 		}
 469:../../freeRtos/Source/queue.c **** 
 470:../../freeRtos/Source/queue.c **** 		return xReturn;
 471:../../freeRtos/Source/queue.c **** 	}
 472:../../freeRtos/Source/queue.c **** 
 473:../../freeRtos/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 474:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 475:../../freeRtos/Source/queue.c **** 
 476:../../freeRtos/Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 477:../../freeRtos/Source/queue.c **** 
 478:../../freeRtos/Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 479:../../freeRtos/Source/queue.c **** 	{
 480:../../freeRtos/Source/queue.c **** 	xQueueHandle pxHandle;
 481:../../freeRtos/Source/queue.c **** 
 482:../../freeRtos/Source/queue.c **** 		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGT
 483:../../freeRtos/Source/queue.c **** 
 484:../../freeRtos/Source/queue.c **** 		if( pxHandle != NULL )
 485:../../freeRtos/Source/queue.c **** 		{
 486:../../freeRtos/Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 487:../../freeRtos/Source/queue.c **** 
 488:../../freeRtos/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 489:../../freeRtos/Source/queue.c **** 		}
 490:../../freeRtos/Source/queue.c **** 		else
 491:../../freeRtos/Source/queue.c **** 		{
 492:../../freeRtos/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 493:../../freeRtos/Source/queue.c **** 		}
 494:../../freeRtos/Source/queue.c **** 
 495:../../freeRtos/Source/queue.c **** 		return pxHandle;
 496:../../freeRtos/Source/queue.c **** 	}
 497:../../freeRtos/Source/queue.c **** 
 498:../../freeRtos/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 499:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 500:../../freeRtos/Source/queue.c **** 
 501:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 502:../../freeRtos/Source/queue.c **** {
 503:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 504:../../freeRtos/Source/queue.c **** xTimeOutType xTimeOut;
 505:../../freeRtos/Source/queue.c **** 
 506:../../freeRtos/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:../../freeRtos/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 508:../../freeRtos/Source/queue.c **** 	of execution time efficiency. */
 509:../../freeRtos/Source/queue.c **** 	for( ;; )
 510:../../freeRtos/Source/queue.c **** 	{
 511:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 512:../../freeRtos/Source/queue.c **** 		{
 513:../../freeRtos/Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:../../freeRtos/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 515:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:../../freeRtos/Source/queue.c **** 			{
 517:../../freeRtos/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:../../freeRtos/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:../../freeRtos/Source/queue.c **** 
 520:../../freeRtos/Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:../../freeRtos/Source/queue.c **** 				queue then unblock it now. */
 522:../../freeRtos/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:../../freeRtos/Source/queue.c **** 				{
 524:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:../../freeRtos/Source/queue.c **** 					{
 526:../../freeRtos/Source/queue.c **** 						/* The unblocked task has a priority higher than
 527:../../freeRtos/Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:../../freeRtos/Source/queue.c **** 						this from within the critical section - the kernel
 529:../../freeRtos/Source/queue.c **** 						takes care of that. */
 530:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 531:../../freeRtos/Source/queue.c **** 					}
 532:../../freeRtos/Source/queue.c **** 				}
 533:../../freeRtos/Source/queue.c **** 
 534:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 535:../../freeRtos/Source/queue.c **** 
 536:../../freeRtos/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 537:../../freeRtos/Source/queue.c **** 				function. */
 538:../../freeRtos/Source/queue.c **** 				return pdPASS;
 539:../../freeRtos/Source/queue.c **** 			}
 540:../../freeRtos/Source/queue.c **** 			else
 541:../../freeRtos/Source/queue.c **** 			{
 542:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:../../freeRtos/Source/queue.c **** 				{
 544:../../freeRtos/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 545:../../freeRtos/Source/queue.c **** 					the block time has expired) so leave now. */
 546:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 547:../../freeRtos/Source/queue.c **** 
 548:../../freeRtos/Source/queue.c **** 					/* Return to the original privilege level before exiting
 549:../../freeRtos/Source/queue.c **** 					the function. */
 550:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:../../freeRtos/Source/queue.c **** 					return errQUEUE_FULL;
 552:../../freeRtos/Source/queue.c **** 				}
 553:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:../../freeRtos/Source/queue.c **** 				{
 555:../../freeRtos/Source/queue.c **** 					/* The queue was full and a block time was specified so
 556:../../freeRtos/Source/queue.c **** 					configure the timeout structure. */
 557:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:../../freeRtos/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:../../freeRtos/Source/queue.c **** 				}
 560:../../freeRtos/Source/queue.c **** 			}
 561:../../freeRtos/Source/queue.c **** 		}
 562:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 563:../../freeRtos/Source/queue.c **** 
 564:../../freeRtos/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:../../freeRtos/Source/queue.c **** 		now the critical section has been exited. */
 566:../../freeRtos/Source/queue.c **** 
 567:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 569:../../freeRtos/Source/queue.c **** 
 570:../../freeRtos/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:../../freeRtos/Source/queue.c **** 		{
 573:../../freeRtos/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) )
 574:../../freeRtos/Source/queue.c **** 			{
 575:../../freeRtos/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:../../freeRtos/Source/queue.c **** 
 578:../../freeRtos/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:../../freeRtos/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:../../freeRtos/Source/queue.c **** 				remove this task from the event	list again - but as the
 581:../../freeRtos/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:../../freeRtos/Source/queue.c **** 				ready last instead of the actual ready list. */
 583:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 584:../../freeRtos/Source/queue.c **** 
 585:../../freeRtos/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:../../freeRtos/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:../../freeRtos/Source/queue.c **** 				task is already in a ready list before it yields - in which
 588:../../freeRtos/Source/queue.c **** 				case the yield will not cause a context switch unless there
 589:../../freeRtos/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 591:../../freeRtos/Source/queue.c **** 				{
 592:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 593:../../freeRtos/Source/queue.c **** 				}
 594:../../freeRtos/Source/queue.c **** 			}
 595:../../freeRtos/Source/queue.c **** 			else
 596:../../freeRtos/Source/queue.c **** 			{
 597:../../freeRtos/Source/queue.c **** 				/* Try again. */
 598:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 599:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 600:../../freeRtos/Source/queue.c **** 			}
 601:../../freeRtos/Source/queue.c **** 		}
 602:../../freeRtos/Source/queue.c **** 		else
 603:../../freeRtos/Source/queue.c **** 		{
 604:../../freeRtos/Source/queue.c **** 			/* The timeout has expired. */
 605:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 606:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 607:../../freeRtos/Source/queue.c **** 
 608:../../freeRtos/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 609:../../freeRtos/Source/queue.c **** 			function. */
 610:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:../../freeRtos/Source/queue.c **** 			return errQUEUE_FULL;
 612:../../freeRtos/Source/queue.c **** 		}
 613:../../freeRtos/Source/queue.c **** 	}
 614:../../freeRtos/Source/queue.c **** }
 615:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 616:../../freeRtos/Source/queue.c **** 
 617:../../freeRtos/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:../../freeRtos/Source/queue.c **** 
 619:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:../../freeRtos/Source/queue.c **** 	{
 621:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:../../freeRtos/Source/queue.c **** 	xTimeOutType xTimeOut;
 623:../../freeRtos/Source/queue.c **** 
 624:../../freeRtos/Source/queue.c **** 		for( ;; )
 625:../../freeRtos/Source/queue.c **** 		{
 626:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 627:../../freeRtos/Source/queue.c **** 			{
 628:../../freeRtos/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 629:../../freeRtos/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 630:../../freeRtos/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 631:../../freeRtos/Source/queue.c **** 				{
 632:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 633:../../freeRtos/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 634:../../freeRtos/Source/queue.c **** 
 635:../../freeRtos/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 636:../../freeRtos/Source/queue.c **** 					queue then unblock it now. */
 637:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 638:../../freeRtos/Source/queue.c **** 					{
 639:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 640:../../freeRtos/Source/queue.c **** 						{
 641:../../freeRtos/Source/queue.c **** 							/* The unblocked task has a priority higher than
 642:../../freeRtos/Source/queue.c **** 							our own so yield immediately. */
 643:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 644:../../freeRtos/Source/queue.c **** 						}
 645:../../freeRtos/Source/queue.c **** 					}
 646:../../freeRtos/Source/queue.c **** 
 647:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 648:../../freeRtos/Source/queue.c **** 					return pdPASS;
 649:../../freeRtos/Source/queue.c **** 				}
 650:../../freeRtos/Source/queue.c **** 				else
 651:../../freeRtos/Source/queue.c **** 				{
 652:../../freeRtos/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 653:../../freeRtos/Source/queue.c **** 					{
 654:../../freeRtos/Source/queue.c **** 						taskEXIT_CRITICAL();
 655:../../freeRtos/Source/queue.c **** 						return errQUEUE_FULL;
 656:../../freeRtos/Source/queue.c **** 					}
 657:../../freeRtos/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 658:../../freeRtos/Source/queue.c **** 					{
 659:../../freeRtos/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 660:../../freeRtos/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 661:../../freeRtos/Source/queue.c **** 					}
 662:../../freeRtos/Source/queue.c **** 				}
 663:../../freeRtos/Source/queue.c **** 			}
 664:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 665:../../freeRtos/Source/queue.c **** 
 666:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 667:../../freeRtos/Source/queue.c **** 			{
 668:../../freeRtos/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 669:../../freeRtos/Source/queue.c **** 				{
 670:../../freeRtos/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) )
 671:../../freeRtos/Source/queue.c **** 					{
 672:../../freeRtos/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 673:../../freeRtos/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 674:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 675:../../freeRtos/Source/queue.c **** 					}
 676:../../freeRtos/Source/queue.c **** 				}
 677:../../freeRtos/Source/queue.c **** 				else
 678:../../freeRtos/Source/queue.c **** 				{
 679:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 680:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 681:../../freeRtos/Source/queue.c **** 					return errQUEUE_FULL;
 682:../../freeRtos/Source/queue.c **** 				}
 683:../../freeRtos/Source/queue.c **** 			}
 684:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 685:../../freeRtos/Source/queue.c **** 		}
 686:../../freeRtos/Source/queue.c **** 	}
 687:../../freeRtos/Source/queue.c **** 
 688:../../freeRtos/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 689:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 690:../../freeRtos/Source/queue.c **** 
 691:../../freeRtos/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 692:../../freeRtos/Source/queue.c **** 
 693:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 694:../../freeRtos/Source/queue.c **** 	{
 695:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 696:../../freeRtos/Source/queue.c **** 	xTimeOutType xTimeOut;
 697:../../freeRtos/Source/queue.c **** 	signed char *pcOriginalReadPosition;
 698:../../freeRtos/Source/queue.c **** 
 699:../../freeRtos/Source/queue.c **** 		for( ;; )
 700:../../freeRtos/Source/queue.c **** 		{
 701:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 702:../../freeRtos/Source/queue.c **** 			{
 703:../../freeRtos/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 704:../../freeRtos/Source/queue.c **** 				{
 705:../../freeRtos/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 706:../../freeRtos/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 707:../../freeRtos/Source/queue.c **** 
 708:../../freeRtos/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 709:../../freeRtos/Source/queue.c **** 
 710:../../freeRtos/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 711:../../freeRtos/Source/queue.c **** 					{
 712:../../freeRtos/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 713:../../freeRtos/Source/queue.c **** 
 714:../../freeRtos/Source/queue.c **** 						/* We are actually removing data. */
 715:../../freeRtos/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 716:../../freeRtos/Source/queue.c **** 
 717:../../freeRtos/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 718:../../freeRtos/Source/queue.c **** 						{
 719:../../freeRtos/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 720:../../freeRtos/Source/queue.c **** 							{
 721:../../freeRtos/Source/queue.c **** 								/* Record the information required to implement
 722:../../freeRtos/Source/queue.c **** 								priority inheritance should it become necessary. */
 723:../../freeRtos/Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 724:../../freeRtos/Source/queue.c **** 							}
 725:../../freeRtos/Source/queue.c **** 						}
 726:../../freeRtos/Source/queue.c **** 						#endif
 727:../../freeRtos/Source/queue.c **** 
 728:../../freeRtos/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 729:../../freeRtos/Source/queue.c **** 						{
 730:../../freeRtos/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 731:../../freeRtos/Source/queue.c **** 							{
 732:../../freeRtos/Source/queue.c **** 								portYIELD_WITHIN_API();
 733:../../freeRtos/Source/queue.c **** 							}
 734:../../freeRtos/Source/queue.c **** 						}
 735:../../freeRtos/Source/queue.c **** 					}
 736:../../freeRtos/Source/queue.c **** 					else
 737:../../freeRtos/Source/queue.c **** 					{
 738:../../freeRtos/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 739:../../freeRtos/Source/queue.c **** 
 740:../../freeRtos/Source/queue.c **** 						/* We are not removing the data, so reset our read
 741:../../freeRtos/Source/queue.c **** 						pointer. */
 742:../../freeRtos/Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 743:../../freeRtos/Source/queue.c **** 
 744:../../freeRtos/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 745:../../freeRtos/Source/queue.c **** 						any other tasks waiting for the data. */
 746:../../freeRtos/Source/queue.c **** 						if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 747:../../freeRtos/Source/queue.c **** 						{
 748:../../freeRtos/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 749:../../freeRtos/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 750:../../freeRtos/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 751:../../freeRtos/Source/queue.c **** 							{
 752:../../freeRtos/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 753:../../freeRtos/Source/queue.c **** 								portYIELD_WITHIN_API();
 754:../../freeRtos/Source/queue.c **** 							}
 755:../../freeRtos/Source/queue.c **** 						}
 756:../../freeRtos/Source/queue.c **** 
 757:../../freeRtos/Source/queue.c **** 					}
 758:../../freeRtos/Source/queue.c **** 
 759:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 760:../../freeRtos/Source/queue.c **** 					return pdPASS;
 761:../../freeRtos/Source/queue.c **** 				}
 762:../../freeRtos/Source/queue.c **** 				else
 763:../../freeRtos/Source/queue.c **** 				{
 764:../../freeRtos/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 765:../../freeRtos/Source/queue.c **** 					{
 766:../../freeRtos/Source/queue.c **** 						taskEXIT_CRITICAL();
 767:../../freeRtos/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 768:../../freeRtos/Source/queue.c **** 						return errQUEUE_EMPTY;
 769:../../freeRtos/Source/queue.c **** 					}
 770:../../freeRtos/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 771:../../freeRtos/Source/queue.c **** 					{
 772:../../freeRtos/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 773:../../freeRtos/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 774:../../freeRtos/Source/queue.c **** 					}
 775:../../freeRtos/Source/queue.c **** 				}
 776:../../freeRtos/Source/queue.c **** 			}
 777:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 778:../../freeRtos/Source/queue.c **** 
 779:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 780:../../freeRtos/Source/queue.c **** 			{
 781:../../freeRtos/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 782:../../freeRtos/Source/queue.c **** 				{
 783:../../freeRtos/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) )
 784:../../freeRtos/Source/queue.c **** 					{
 785:../../freeRtos/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 786:../../freeRtos/Source/queue.c **** 
 787:../../freeRtos/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 788:../../freeRtos/Source/queue.c **** 						{
 789:../../freeRtos/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 790:../../freeRtos/Source/queue.c **** 							{
 791:../../freeRtos/Source/queue.c **** 								portENTER_CRITICAL();
 792:../../freeRtos/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 793:../../freeRtos/Source/queue.c **** 								portEXIT_CRITICAL();
 794:../../freeRtos/Source/queue.c **** 							}
 795:../../freeRtos/Source/queue.c **** 						}
 796:../../freeRtos/Source/queue.c **** 						#endif
 797:../../freeRtos/Source/queue.c **** 
 798:../../freeRtos/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 799:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 800:../../freeRtos/Source/queue.c **** 					}
 801:../../freeRtos/Source/queue.c **** 				}
 802:../../freeRtos/Source/queue.c **** 				else
 803:../../freeRtos/Source/queue.c **** 				{
 804:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 805:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 806:../../freeRtos/Source/queue.c **** 					return errQUEUE_EMPTY;
 807:../../freeRtos/Source/queue.c **** 				}
 808:../../freeRtos/Source/queue.c **** 			}
 809:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 810:../../freeRtos/Source/queue.c **** 		}
 811:../../freeRtos/Source/queue.c **** 	}
 812:../../freeRtos/Source/queue.c **** 
 813:../../freeRtos/Source/queue.c **** 
 814:../../freeRtos/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 815:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 816:../../freeRtos/Source/queue.c **** 
 817:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 818:../../freeRtos/Source/queue.c **** {
 819:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
 820:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 821:../../freeRtos/Source/queue.c **** 
 822:../../freeRtos/Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 823:../../freeRtos/Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 824:../../freeRtos/Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 825:../../freeRtos/Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 826:../../freeRtos/Source/queue.c **** 	by this	post). */
 827:../../freeRtos/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 828:../../freeRtos/Source/queue.c **** 	{
 829:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 830:../../freeRtos/Source/queue.c **** 		{
 831:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 832:../../freeRtos/Source/queue.c **** 
 833:../../freeRtos/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 834:../../freeRtos/Source/queue.c **** 
 835:../../freeRtos/Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 836:../../freeRtos/Source/queue.c **** 			be done when the queue is unlocked later. */
 837:../../freeRtos/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 838:../../freeRtos/Source/queue.c **** 			{
 839:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 840:../../freeRtos/Source/queue.c **** 				{
 841:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 842:../../freeRtos/Source/queue.c **** 					{
 843:../../freeRtos/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 844:../../freeRtos/Source/queue.c **** 						context	switch is required. */
 845:../../freeRtos/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 846:../../freeRtos/Source/queue.c **** 					}
 847:../../freeRtos/Source/queue.c **** 				}
 848:../../freeRtos/Source/queue.c **** 			}
 849:../../freeRtos/Source/queue.c **** 			else
 850:../../freeRtos/Source/queue.c **** 			{
 851:../../freeRtos/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 852:../../freeRtos/Source/queue.c **** 				knows that data was posted while it was locked. */
 853:../../freeRtos/Source/queue.c **** 				++( pxQueue->xTxLock );
 854:../../freeRtos/Source/queue.c **** 			}
 855:../../freeRtos/Source/queue.c **** 
 856:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 857:../../freeRtos/Source/queue.c **** 		}
 858:../../freeRtos/Source/queue.c **** 		else
 859:../../freeRtos/Source/queue.c **** 		{
 860:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 861:../../freeRtos/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 862:../../freeRtos/Source/queue.c **** 		}
 863:../../freeRtos/Source/queue.c **** 	}
 864:../../freeRtos/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 865:../../freeRtos/Source/queue.c **** 
 866:../../freeRtos/Source/queue.c **** 	return xReturn;
 867:../../freeRtos/Source/queue.c **** }
 868:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 869:../../freeRtos/Source/queue.c **** 
 870:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 871:../../freeRtos/Source/queue.c **** {
 872:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 873:../../freeRtos/Source/queue.c **** xTimeOutType xTimeOut;
 874:../../freeRtos/Source/queue.c **** signed char *pcOriginalReadPosition;
 875:../../freeRtos/Source/queue.c **** 
 876:../../freeRtos/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 877:../../freeRtos/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 878:../../freeRtos/Source/queue.c **** 	of execution time efficiency. */
 879:../../freeRtos/Source/queue.c **** 
 880:../../freeRtos/Source/queue.c **** 	for( ;; )
 881:../../freeRtos/Source/queue.c **** 	{
 882:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 883:../../freeRtos/Source/queue.c **** 		{
 884:../../freeRtos/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 885:../../freeRtos/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 886:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 887:../../freeRtos/Source/queue.c **** 			{
 888:../../freeRtos/Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 889:../../freeRtos/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 890:../../freeRtos/Source/queue.c **** 
 891:../../freeRtos/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 892:../../freeRtos/Source/queue.c **** 
 893:../../freeRtos/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 894:../../freeRtos/Source/queue.c **** 				{
 895:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 896:../../freeRtos/Source/queue.c **** 
 897:../../freeRtos/Source/queue.c **** 					/* We are actually removing data. */
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 899:../../freeRtos/Source/queue.c **** 
 900:../../freeRtos/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 901:../../freeRtos/Source/queue.c **** 					{
 902:../../freeRtos/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 903:../../freeRtos/Source/queue.c **** 						{
 904:../../freeRtos/Source/queue.c **** 							/* Record the information required to implement
 905:../../freeRtos/Source/queue.c **** 							priority inheritance should it become necessary. */
 906:../../freeRtos/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 907:../../freeRtos/Source/queue.c **** 						}
 908:../../freeRtos/Source/queue.c **** 					}
 909:../../freeRtos/Source/queue.c **** 					#endif
 910:../../freeRtos/Source/queue.c **** 
 911:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 912:../../freeRtos/Source/queue.c **** 					{
 913:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 914:../../freeRtos/Source/queue.c **** 						{
 915:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 916:../../freeRtos/Source/queue.c **** 						}
 917:../../freeRtos/Source/queue.c **** 					}
 918:../../freeRtos/Source/queue.c **** 				}
 919:../../freeRtos/Source/queue.c **** 				else
 920:../../freeRtos/Source/queue.c **** 				{
 921:../../freeRtos/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 922:../../freeRtos/Source/queue.c **** 
 923:../../freeRtos/Source/queue.c **** 					/* We are not removing the data, so reset our read
 924:../../freeRtos/Source/queue.c **** 					pointer. */
 925:../../freeRtos/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 926:../../freeRtos/Source/queue.c **** 
 927:../../freeRtos/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 928:../../freeRtos/Source/queue.c **** 					any other tasks waiting for the data. */
 929:../../freeRtos/Source/queue.c **** 					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 930:../../freeRtos/Source/queue.c **** 					{
 931:../../freeRtos/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 932:../../freeRtos/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 933:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 934:../../freeRtos/Source/queue.c **** 						{
 935:../../freeRtos/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 936:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 937:../../freeRtos/Source/queue.c **** 						}
 938:../../freeRtos/Source/queue.c **** 					}
 939:../../freeRtos/Source/queue.c **** 
 940:../../freeRtos/Source/queue.c **** 				}
 941:../../freeRtos/Source/queue.c **** 
 942:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 943:../../freeRtos/Source/queue.c **** 				return pdPASS;
 944:../../freeRtos/Source/queue.c **** 			}
 945:../../freeRtos/Source/queue.c **** 			else
 946:../../freeRtos/Source/queue.c **** 			{
 947:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 948:../../freeRtos/Source/queue.c **** 				{
 949:../../freeRtos/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 950:../../freeRtos/Source/queue.c **** 					the block time has expired) so leave now. */
 951:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 952:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 953:../../freeRtos/Source/queue.c **** 					return errQUEUE_EMPTY;
 954:../../freeRtos/Source/queue.c **** 				}
 955:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 956:../../freeRtos/Source/queue.c **** 				{
 957:../../freeRtos/Source/queue.c **** 					/* The queue was empty and a block time was specified so
 958:../../freeRtos/Source/queue.c **** 					configure the timeout structure. */
 959:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 960:../../freeRtos/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 961:../../freeRtos/Source/queue.c **** 				}
 962:../../freeRtos/Source/queue.c **** 			}
 963:../../freeRtos/Source/queue.c **** 		}
 964:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 965:../../freeRtos/Source/queue.c **** 
 966:../../freeRtos/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 967:../../freeRtos/Source/queue.c **** 		now the critical section has been exited. */
 968:../../freeRtos/Source/queue.c **** 
 969:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 971:../../freeRtos/Source/queue.c **** 
 972:../../freeRtos/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 973:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 974:../../freeRtos/Source/queue.c **** 		{
 975:../../freeRtos/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) )
 976:../../freeRtos/Source/queue.c **** 			{
 977:../../freeRtos/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 978:../../freeRtos/Source/queue.c **** 
 979:../../freeRtos/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 980:../../freeRtos/Source/queue.c **** 				{
 981:../../freeRtos/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 982:../../freeRtos/Source/queue.c **** 					{
 983:../../freeRtos/Source/queue.c **** 						portENTER_CRITICAL();
 984:../../freeRtos/Source/queue.c **** 						{
 985:../../freeRtos/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 986:../../freeRtos/Source/queue.c **** 						}
 987:../../freeRtos/Source/queue.c **** 						portEXIT_CRITICAL();
 988:../../freeRtos/Source/queue.c **** 					}
 989:../../freeRtos/Source/queue.c **** 				}
 990:../../freeRtos/Source/queue.c **** 				#endif
 991:../../freeRtos/Source/queue.c **** 
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 993:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 994:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 995:../../freeRtos/Source/queue.c **** 				{
 996:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 997:../../freeRtos/Source/queue.c **** 				}
 998:../../freeRtos/Source/queue.c **** 			}
 999:../../freeRtos/Source/queue.c **** 			else
1000:../../freeRtos/Source/queue.c **** 			{
1001:../../freeRtos/Source/queue.c **** 				/* Try again. */
1002:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1003:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
1004:../../freeRtos/Source/queue.c **** 			}
1005:../../freeRtos/Source/queue.c **** 		}
1006:../../freeRtos/Source/queue.c **** 		else
1007:../../freeRtos/Source/queue.c **** 		{
1008:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1009:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
1010:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1011:../../freeRtos/Source/queue.c **** 			return errQUEUE_EMPTY;
1012:../../freeRtos/Source/queue.c **** 		}
1013:../../freeRtos/Source/queue.c **** 	}
1014:../../freeRtos/Source/queue.c **** }
1015:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1016:../../freeRtos/Source/queue.c **** 
1017:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1018:../../freeRtos/Source/queue.c **** {
1019:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1020:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1021:../../freeRtos/Source/queue.c **** 
1022:../../freeRtos/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1023:../../freeRtos/Source/queue.c **** 	{
1024:../../freeRtos/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1025:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1026:../../freeRtos/Source/queue.c **** 		{
1027:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1028:../../freeRtos/Source/queue.c **** 
1029:../../freeRtos/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1030:../../freeRtos/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1031:../../freeRtos/Source/queue.c **** 
1032:../../freeRtos/Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1033:../../freeRtos/Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1034:../../freeRtos/Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1035:../../freeRtos/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
1036:../../freeRtos/Source/queue.c **** 			{
1037:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
1038:../../freeRtos/Source/queue.c **** 				{
1039:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1040:../../freeRtos/Source/queue.c **** 					{
1041:../../freeRtos/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1042:../../freeRtos/Source/queue.c **** 						force a context switch. */
1043:../../freeRtos/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
1044:../../freeRtos/Source/queue.c **** 					}
1045:../../freeRtos/Source/queue.c **** 				}
1046:../../freeRtos/Source/queue.c **** 			}
1047:../../freeRtos/Source/queue.c **** 			else
1048:../../freeRtos/Source/queue.c **** 			{
1049:../../freeRtos/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1050:../../freeRtos/Source/queue.c **** 				knows that data was removed while it was locked. */
1051:../../freeRtos/Source/queue.c **** 				++( pxQueue->xRxLock );
1052:../../freeRtos/Source/queue.c **** 			}
1053:../../freeRtos/Source/queue.c **** 
1054:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
1055:../../freeRtos/Source/queue.c **** 		}
1056:../../freeRtos/Source/queue.c **** 		else
1057:../../freeRtos/Source/queue.c **** 		{
1058:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
1059:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1060:../../freeRtos/Source/queue.c **** 		}
1061:../../freeRtos/Source/queue.c **** 	}
1062:../../freeRtos/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1063:../../freeRtos/Source/queue.c **** 
1064:../../freeRtos/Source/queue.c **** 	return xReturn;
1065:../../freeRtos/Source/queue.c **** }
1066:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1067:../../freeRtos/Source/queue.c **** 
1068:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1069:../../freeRtos/Source/queue.c **** {
1070:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1071:../../freeRtos/Source/queue.c **** 
1072:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
1073:../../freeRtos/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
1074:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
1075:../../freeRtos/Source/queue.c **** 
1076:../../freeRtos/Source/queue.c **** 	return uxReturn;
1077:../../freeRtos/Source/queue.c **** }
1078:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1079:../../freeRtos/Source/queue.c **** 
1080:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1081:../../freeRtos/Source/queue.c **** {
1082:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1083:../../freeRtos/Source/queue.c **** 
1084:../../freeRtos/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1085:../../freeRtos/Source/queue.c **** 
1086:../../freeRtos/Source/queue.c **** 	return uxReturn;
1087:../../freeRtos/Source/queue.c **** }
1088:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1089:../../freeRtos/Source/queue.c **** 
1090:../../freeRtos/Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1091:../../freeRtos/Source/queue.c **** {
1092:../../freeRtos/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1093:../../freeRtos/Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1094:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
1096:../../freeRtos/Source/queue.c **** }
1097:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1098:../../freeRtos/Source/queue.c **** 
1099:../../freeRtos/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1100:../../freeRtos/Source/queue.c **** {
1101:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
1102:../../freeRtos/Source/queue.c **** 	{
1103:../../freeRtos/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1104:../../freeRtos/Source/queue.c **** 		{
1105:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1106:../../freeRtos/Source/queue.c **** 			{
1107:../../freeRtos/Source/queue.c **** 				/* The mutex is no longer being held. */
1108:../../freeRtos/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1109:../../freeRtos/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
1110:../../freeRtos/Source/queue.c **** 			}
1111:../../freeRtos/Source/queue.c **** 		}
1112:../../freeRtos/Source/queue.c **** 		#endif
1113:../../freeRtos/Source/queue.c **** 	}
1114:../../freeRtos/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
1115:../../freeRtos/Source/queue.c **** 	{
1116:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
1117:../../freeRtos/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
1118:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
1119:../../freeRtos/Source/queue.c **** 		{
1120:../../freeRtos/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
1121:../../freeRtos/Source/queue.c **** 		}
1122:../../freeRtos/Source/queue.c **** 	}
1123:../../freeRtos/Source/queue.c **** 	else
1124:../../freeRtos/Source/queue.c **** 	{
1125:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
1126:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
1127:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
1128:../../freeRtos/Source/queue.c **** 		{
1129:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
1130:../../freeRtos/Source/queue.c **** 		}
1131:../../freeRtos/Source/queue.c **** 	}
1132:../../freeRtos/Source/queue.c **** 
1133:../../freeRtos/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
1134:../../freeRtos/Source/queue.c **** }
1135:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1136:../../freeRtos/Source/queue.c **** 
1137:../../freeRtos/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1138:../../freeRtos/Source/queue.c **** {
1139:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
1140:../../freeRtos/Source/queue.c **** 	{
1141:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1142:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1143:../../freeRtos/Source/queue.c **** 		{
1144:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
1145:../../freeRtos/Source/queue.c **** 		}
1146:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1147:../../freeRtos/Source/queue.c **** 	}
1148:../../freeRtos/Source/queue.c **** }
1149:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1150:../../freeRtos/Source/queue.c **** 
1151:../../freeRtos/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1152:../../freeRtos/Source/queue.c **** {
 451               	.LM0:
 452               	.LFBB1:
 453 0000 0F93      		push r16
 454 0002 1F93      		push r17
 455 0004 CF93      		push r28
 456 0006 DF93      		push r29
 457               	/* prologue: function */
 458               	/* frame size = 0 */
 459               	/* stack size = 4 */
 460               	.L__stack_usage = 4
 461 0008 EC01      		movw r28,r24
1153:../../freeRtos/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1154:../../freeRtos/Source/queue.c **** 
1155:../../freeRtos/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1156:../../freeRtos/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1157:../../freeRtos/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1158:../../freeRtos/Source/queue.c **** 	updated. */
1159:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 463               	.LM1:
 464               	/* #APP */
 465               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 466 000a 0FB6      		in		__tmp_reg__, __SREG__
 467               	 ;  0 "" 2
 468               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 469 000c F894      		cli
 470               	 ;  0 "" 2
 471               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 472 000e 0F92      		push	__tmp_reg__
 473               	 ;  0 "" 2
1160:../../freeRtos/Source/queue.c **** 	{
1161:../../freeRtos/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1162:../../freeRtos/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
1163:../../freeRtos/Source/queue.c **** 		{
1164:../../freeRtos/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1165:../../freeRtos/Source/queue.c **** 			blocked waiting for data to become available? */
1166:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
1167:../../freeRtos/Source/queue.c **** 			{
1168:../../freeRtos/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1169:../../freeRtos/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1170:../../freeRtos/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 475               	.LM2:
 476               	/* #NOAPP */
 477 0010 8C01      		movw r16,r24
 478 0012 0F5E      		subi r16,lo8(-(17))
 479 0014 1F4F      		sbci r17,hi8(-(17))
1162:../../freeRtos/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 481               	.LM3:
 482 0016 00C0      		rjmp .L2
 483               	.L5:
1166:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 485               	.LM4:
 486 0018 8989      		ldd r24,Y+17
 487 001a 8823      		tst r24
 488 001c 01F0      		breq .L3
 490               	.LM5:
 491 001e C801      		movw r24,r16
 492 0020 0E94 0000 		call xTaskRemoveFromEventList
 493 0024 8823      		tst r24
 494 0026 01F0      		breq .L4
1171:../../freeRtos/Source/queue.c **** 				{
1172:../../freeRtos/Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1173:../../freeRtos/Source/queue.c **** 					context	switch is required. */
1174:../../freeRtos/Source/queue.c **** 					vTaskMissedYield();
 496               	.LM6:
 497 0028 0E94 0000 		call vTaskMissedYield
 498               	.L4:
1175:../../freeRtos/Source/queue.c **** 				}
1176:../../freeRtos/Source/queue.c **** 
1177:../../freeRtos/Source/queue.c **** 				--( pxQueue->xTxLock );
 500               	.LM7:
 501 002c 8E8D      		ldd r24,Y+30
 502 002e 8150      		subi r24,lo8(-(-1))
 503 0030 8E8F      		std Y+30,r24
 504               	.L2:
1162:../../freeRtos/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 506               	.LM8:
 507 0032 8E8D      		ldd r24,Y+30
 508 0034 1816      		cp __zero_reg__,r24
 509 0036 04F0      		brlt .L5
 510               	.L3:
1178:../../freeRtos/Source/queue.c **** 			}
1179:../../freeRtos/Source/queue.c **** 			else
1180:../../freeRtos/Source/queue.c **** 			{
1181:../../freeRtos/Source/queue.c **** 				break;
1182:../../freeRtos/Source/queue.c **** 			}
1183:../../freeRtos/Source/queue.c **** 		}
1184:../../freeRtos/Source/queue.c **** 
1185:../../freeRtos/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 512               	.LM9:
 513 0038 8FEF      		ldi r24,lo8(-1)
 514 003a 8E8F      		std Y+30,r24
1186:../../freeRtos/Source/queue.c **** 	}
1187:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 516               	.LM10:
 517               	/* #APP */
 518               	 ;  1187 "../../freeRtos/Source/queue.c" 1
 519 003c 0F90      		pop		__tmp_reg__
 520               	 ;  0 "" 2
 521               	 ;  1187 "../../freeRtos/Source/queue.c" 1
 522 003e 0FBE      		out		__SREG__, __tmp_reg__
 523               	 ;  0 "" 2
1188:../../freeRtos/Source/queue.c **** 
1189:../../freeRtos/Source/queue.c **** 	/* Do the same for the Rx lock. */
1190:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 525               	.LM11:
 526               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 527 0040 0FB6      		in		__tmp_reg__, __SREG__
 528               	 ;  0 "" 2
 529               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 530 0042 F894      		cli
 531               	 ;  0 "" 2
 532               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 533 0044 0F92      		push	__tmp_reg__
 534               	 ;  0 "" 2
1191:../../freeRtos/Source/queue.c **** 	{
1192:../../freeRtos/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
1193:../../freeRtos/Source/queue.c **** 		{
1194:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
1195:../../freeRtos/Source/queue.c **** 			{
1196:../../freeRtos/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 536               	.LM12:
 537               	/* #NOAPP */
 538 0046 8E01      		movw r16,r28
 539 0048 085F      		subi r16,lo8(-(8))
 540 004a 1F4F      		sbci r17,hi8(-(8))
1192:../../freeRtos/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 542               	.LM13:
 543 004c 00C0      		rjmp .L6
 544               	.L9:
1194:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 546               	.LM14:
 547 004e 8885      		ldd r24,Y+8
 548 0050 8823      		tst r24
 549 0052 01F0      		breq .L7
 551               	.LM15:
 552 0054 C801      		movw r24,r16
 553 0056 0E94 0000 		call xTaskRemoveFromEventList
 554 005a 8823      		tst r24
 555 005c 01F0      		breq .L8
1197:../../freeRtos/Source/queue.c **** 				{
1198:../../freeRtos/Source/queue.c **** 					vTaskMissedYield();
 557               	.LM16:
 558 005e 0E94 0000 		call vTaskMissedYield
 559               	.L8:
1199:../../freeRtos/Source/queue.c **** 				}
1200:../../freeRtos/Source/queue.c **** 
1201:../../freeRtos/Source/queue.c **** 				--( pxQueue->xRxLock );
 561               	.LM17:
 562 0062 8D8D      		ldd r24,Y+29
 563 0064 8150      		subi r24,lo8(-(-1))
 564 0066 8D8F      		std Y+29,r24
 565               	.L6:
1192:../../freeRtos/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 567               	.LM18:
 568 0068 8D8D      		ldd r24,Y+29
 569 006a 1816      		cp __zero_reg__,r24
 570 006c 04F0      		brlt .L9
 571               	.L7:
1202:../../freeRtos/Source/queue.c **** 			}
1203:../../freeRtos/Source/queue.c **** 			else
1204:../../freeRtos/Source/queue.c **** 			{
1205:../../freeRtos/Source/queue.c **** 				break;
1206:../../freeRtos/Source/queue.c **** 			}
1207:../../freeRtos/Source/queue.c **** 		}
1208:../../freeRtos/Source/queue.c **** 
1209:../../freeRtos/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 573               	.LM19:
 574 006e 8FEF      		ldi r24,lo8(-1)
 575 0070 8D8F      		std Y+29,r24
1210:../../freeRtos/Source/queue.c **** 	}
1211:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 577               	.LM20:
 578               	/* #APP */
 579               	 ;  1211 "../../freeRtos/Source/queue.c" 1
 580 0072 0F90      		pop		__tmp_reg__
 581               	 ;  0 "" 2
 582               	 ;  1211 "../../freeRtos/Source/queue.c" 1
 583 0074 0FBE      		out		__SREG__, __tmp_reg__
 584               	 ;  0 "" 2
 585               	/* epilogue start */
1212:../../freeRtos/Source/queue.c **** }
 587               	.LM21:
 588               	/* #NOAPP */
 589 0076 DF91      		pop r29
 590 0078 CF91      		pop r28
 591 007a 1F91      		pop r17
 592 007c 0F91      		pop r16
 593 007e 0895      		ret
 595               	.Lscope1:
 597               		.stabd	78,0,0
 601               	.global	xQueueCreate
 603               	xQueueCreate:
 604               		.stabd	46,0,0
 249:../../freeRtos/Source/queue.c **** {
 606               	.LM22:
 607               	.LFBB2:
 608 0080 AF92      		push r10
 609 0082 BF92      		push r11
 610 0084 CF92      		push r12
 611 0086 DF92      		push r13
 612 0088 EF92      		push r14
 613 008a FF92      		push r15
 614 008c 0F93      		push r16
 615 008e 1F93      		push r17
 616 0090 CF93      		push r28
 617 0092 DF93      		push r29
 618               	/* prologue: function */
 619               	/* frame size = 0 */
 620               	/* stack size = 10 */
 621               	.L__stack_usage = 10
 622 0094 B82E      		mov r11,r24
 623 0096 A62E      		mov r10,r22
 254:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 625               	.LM23:
 626 0098 8823      		tst r24
 627 009a 01F4      		brne .+2
 628 009c 00C0      		rjmp .L13
 256:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 630               	.LM24:
 631 009e 8FE1      		ldi r24,lo8(31)
 632 00a0 90E0      		ldi r25,hi8(31)
 633 00a2 0E94 0000 		call pvPortMalloc
 634 00a6 E82E      		mov r14,r24
 635 00a8 E701      		movw r28,r14
 636 00aa 7E01      		movw r14,r28
 637 00ac F92E      		mov r15,r25
 638 00ae E701      		movw r28,r14
 257:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 640               	.LM25:
 641 00b0 2097      		sbiw r28,0
 642 00b2 01F0      		breq .L11
 261:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 644               	.LM26:
 645 00b4 0B2D      		mov r16,r11
 646 00b6 10E0      		ldi r17,lo8(0)
 647 00b8 CA2C      		mov r12,r10
 648 00ba DD24      		clr r13
 649 00bc C09E      		mul r12,r16
 650 00be 7001      		movw r14,r0
 651 00c0 C19E      		mul r12,r17
 652 00c2 F00C      		add r15,r0
 653 00c4 D09E      		mul r13,r16
 654 00c6 F00C      		add r15,r0
 655 00c8 1124      		clr r1
 263:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 657               	.LM27:
 658 00ca C701      		movw r24,r14
 659 00cc 0196      		adiw r24,1
 660 00ce 0E94 0000 		call pvPortMalloc
 661 00d2 8883      		st Y,r24
 662 00d4 9983      		std Y+1,r25
 264:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 664               	.LM28:
 665 00d6 0097      		sbiw r24,0
 666 00d8 01F0      		breq .L12
 268:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 668               	.LM29:
 669 00da E80E      		add r14,r24
 670 00dc F91E      		adc r15,r25
 671 00de EA82      		std Y+2,r14
 672 00e0 FB82      		std Y+3,r15
 269:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 674               	.LM30:
 675 00e2 1A8E      		std Y+26,__zero_reg__
 270:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 677               	.LM31:
 678 00e4 8C83      		std Y+4,r24
 679 00e6 9D83      		std Y+5,r25
 271:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 681               	.LM32:
 682 00e8 0150      		subi r16,lo8(-(-1))
 683 00ea 1040      		sbci r17,hi8(-(-1))
 684 00ec 0C9D      		mul r16,r12
 685 00ee A001      		movw r20,r0
 686 00f0 0D9D      		mul r16,r13
 687 00f2 500D      		add r21,r0
 688 00f4 1C9D      		mul r17,r12
 689 00f6 500D      		add r21,r0
 690 00f8 1124      		clr r1
 691 00fa 480F      		add r20,r24
 692 00fc 591F      		adc r21,r25
 693 00fe 4E83      		std Y+6,r20
 694 0100 5F83      		std Y+7,r21
 272:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 696               	.LM33:
 697 0102 BB8E      		std Y+27,r11
 273:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 699               	.LM34:
 700 0104 AC8E      		std Y+28,r10
 274:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 702               	.LM35:
 703 0106 8FEF      		ldi r24,lo8(-1)
 704 0108 8D8F      		std Y+29,r24
 275:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 706               	.LM36:
 707 010a 8E8F      		std Y+30,r24
 278:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 709               	.LM37:
 710 010c CE01      		movw r24,r28
 711 010e 0896      		adiw r24,8
 712 0110 0E94 0000 		call vListInitialise
 279:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 714               	.LM38:
 715 0114 CE01      		movw r24,r28
 716 0116 4196      		adiw r24,17
 717 0118 0E94 0000 		call vListInitialise
 282:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 719               	.LM39:
 720 011c 00C0      		rjmp .L11
 721               	.L12:
 287:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 723               	.LM40:
 724 011e CE01      		movw r24,r28
 725 0120 0E94 0000 		call vPortFree
 726               	.L13:
 294:../../freeRtos/Source/queue.c **** 	return NULL;
 728               	.LM41:
 729 0124 C0E0      		ldi r28,lo8(0)
 730 0126 D0E0      		ldi r29,hi8(0)
 731               	.L11:
 295:../../freeRtos/Source/queue.c **** }
 733               	.LM42:
 734 0128 CE01      		movw r24,r28
 735               	/* epilogue start */
 736 012a DF91      		pop r29
 737 012c CF91      		pop r28
 738 012e 1F91      		pop r17
 739 0130 0F91      		pop r16
 740 0132 FF90      		pop r15
 741 0134 EF90      		pop r14
 742 0136 DF90      		pop r13
 743 0138 CF90      		pop r12
 744 013a BF90      		pop r11
 745 013c AF90      		pop r10
 746 013e 0895      		ret
 751               	.Lscope2:
 753               		.stabd	78,0,0
 757               	.global	xQueueCreateExternal
 759               	xQueueCreateExternal:
 760               		.stabd	46,0,0
 298:../../freeRtos/Source/queue.c **** {
 762               	.LM43:
 763               	.LFBB3:
 764 0140 CF92      		push r12
 765 0142 DF92      		push r13
 766 0144 EF92      		push r14
 767 0146 FF92      		push r15
 768 0148 1F93      		push r17
 769 014a DF93      		push r29
 770 014c CF93      		push r28
 771 014e 00D0      		rcall .
 772 0150 CDB7      		in r28,__SP_L__
 773 0152 DEB7      		in r29,__SP_H__
 774               	/* prologue: function */
 775               	/* frame size = 3 */
 776               	/* stack size = 10 */
 777               	.L__stack_usage = 10
 778 0154 182F      		mov r17,r24
 303:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 780               	.LM44:
 781 0156 8823      		tst r24
 782 0158 01F4      		brne .+2
 783 015a 00C0      		rjmp .L17
 305:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 785               	.LM45:
 786 015c 8FE1      		ldi r24,lo8(31)
 787 015e 90E0      		ldi r25,hi8(31)
 788 0160 4A83      		std Y+2,r20
 789 0162 5B83      		std Y+3,r21
 790 0164 6983      		std Y+1,r22
 791 0166 0E94 0000 		call pvPortMalloc
 792 016a C82E      		mov r12,r24
 793 016c D92E      		mov r13,r25
 306:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 795               	.LM46:
 796 016e 4A81      		ldd r20,Y+2
 797 0170 5B81      		ldd r21,Y+3
 798 0172 6981      		ldd r22,Y+1
 799 0174 C114      		cp r12,__zero_reg__
 800 0176 D104      		cpc r13,__zero_reg__
 801 0178 01F4      		brne .+2
 802 017a 00C0      		rjmp .L15
 312:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) (address);
 804               	.LM47:
 805 017c 9A01      		movw r18,r20
 806 017e D601      		movw r26,r12
 807 0180 2D93      		st X+,r18
 808 0182 3C93      		st X,r19
 809 0184 1197      		sbiw r26,1
 313:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 811               	.LM48:
 812 0186 2115      		cp r18,__zero_reg__
 813 0188 3105      		cpc r19,__zero_reg__
 814 018a 01F0      		breq .L16
 317:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 816               	.LM49:
 817 018c E12F      		mov r30,r17
 818 018e F0E0      		ldi r31,lo8(0)
 819 0190 862F      		mov r24,r22
 820 0192 90E0      		ldi r25,lo8(0)
 821 0194 8E9F      		mul r24,r30
 822 0196 A001      		movw r20,r0
 823 0198 8F9F      		mul r24,r31
 824 019a 500D      		add r21,r0
 825 019c 9E9F      		mul r25,r30
 826 019e 500D      		add r21,r0
 827 01a0 1124      		clr r1
 828 01a2 420F      		add r20,r18
 829 01a4 531F      		adc r21,r19
 830 01a6 1296      		adiw r26,2
 831 01a8 4D93      		st X+,r20
 832 01aa 5C93      		st X,r21
 833 01ac 1397      		sbiw r26,2+1
 318:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 835               	.LM50:
 836 01ae 5A96      		adiw r26,26
 837 01b0 1C92      		st X,__zero_reg__
 838 01b2 5A97      		sbiw r26,26
 319:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 840               	.LM51:
 841 01b4 1496      		adiw r26,4
 842 01b6 2D93      		st X+,r18
 843 01b8 3C93      		st X,r19
 844 01ba 1597      		sbiw r26,4+1
 320:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 846               	.LM52:
 847 01bc 3197      		sbiw r30,1
 848 01be E89F      		mul r30,r24
 849 01c0 A001      		movw r20,r0
 850 01c2 E99F      		mul r30,r25
 851 01c4 500D      		add r21,r0
 852 01c6 F89F      		mul r31,r24
 853 01c8 500D      		add r21,r0
 854 01ca 1124      		clr r1
 855 01cc 420F      		add r20,r18
 856 01ce 531F      		adc r21,r19
 857 01d0 1696      		adiw r26,6
 858 01d2 4D93      		st X+,r20
 859 01d4 5C93      		st X,r21
 860 01d6 1797      		sbiw r26,6+1
 321:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 862               	.LM53:
 863 01d8 5B96      		adiw r26,27
 864 01da 1C93      		st X,r17
 865 01dc 5B97      		sbiw r26,27
 322:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 867               	.LM54:
 868 01de 5C96      		adiw r26,28
 869 01e0 6C93      		st X,r22
 870 01e2 5C97      		sbiw r26,28
 323:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 872               	.LM55:
 873 01e4 8FEF      		ldi r24,lo8(-1)
 874 01e6 5D96      		adiw r26,29
 875 01e8 8C93      		st X,r24
 876 01ea 5D97      		sbiw r26,29
 324:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 878               	.LM56:
 879 01ec 5E96      		adiw r26,30
 880 01ee 8C93      		st X,r24
 327:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 882               	.LM57:
 883 01f0 C601      		movw r24,r12
 884 01f2 0896      		adiw r24,8
 885 01f4 0E94 0000 		call vListInitialise
 328:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 887               	.LM58:
 888 01f8 C601      		movw r24,r12
 889 01fa 4196      		adiw r24,17
 890 01fc 0E94 0000 		call vListInitialise
 331:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 892               	.LM59:
 893 0200 00C0      		rjmp .L15
 894               	.L16:
 336:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 896               	.LM60:
 897 0202 C601      		movw r24,r12
 898 0204 0E94 0000 		call vPortFree
 899               	.L17:
 343:../../freeRtos/Source/queue.c **** 	return NULL;
 901               	.LM61:
 902 0208 CC24      		clr r12
 903 020a DD24      		clr r13
 904               	.L15:
 344:../../freeRtos/Source/queue.c **** }
 906               	.LM62:
 907 020c C601      		movw r24,r12
 908               	/* epilogue start */
 909 020e 2396      		adiw r28,3
 910 0210 CDBF      		out __SP_L__,r28
 911 0212 DEBF      		out __SP_H__,r29
 912 0214 CF91      		pop r28
 913 0216 DF91      		pop r29
 914 0218 1F91      		pop r17
 915 021a FF90      		pop r15
 916 021c EF90      		pop r14
 917 021e DF90      		pop r13
 918 0220 CF90      		pop r12
 919 0222 0895      		ret
 924               	.Lscope3:
 926               		.stabd	78,0,0
 931               	.global	xQueueGenericSend
 933               	xQueueGenericSend:
 934               		.stabd	46,0,0
 502:../../freeRtos/Source/queue.c **** {
 936               	.LM63:
 937               	.LFBB4:
 938 0224 7F92      		push r7
 939 0226 8F92      		push r8
 940 0228 9F92      		push r9
 941 022a AF92      		push r10
 942 022c BF92      		push r11
 943 022e CF92      		push r12
 944 0230 DF92      		push r13
 945 0232 EF92      		push r14
 946 0234 FF92      		push r15
 947 0236 0F93      		push r16
 948 0238 1F93      		push r17
 949 023a DF93      		push r29
 950 023c CF93      		push r28
 951 023e CDB7      		in r28,__SP_L__
 952 0240 DEB7      		in r29,__SP_H__
 953 0242 2597      		sbiw r28,5
 954 0244 CDBF      		out __SP_L__,r28
 955 0246 DEBF      		out __SP_H__,r29
 956               	/* prologue: function */
 957               	/* frame size = 5 */
 958               	/* stack size = 18 */
 959               	.L__stack_usage = 18
 960 0248 8C01      		movw r16,r24
 961 024a 6B01      		movw r12,r22
 962 024c 4C83      		std Y+4,r20
 963 024e 5D83      		std Y+5,r21
 964 0250 722E      		mov r7,r18
 503:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 966               	.LM64:
 967 0252 20E0      		ldi r18,lo8(0)
 557:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 969               	.LM65:
 970 0254 7E01      		movw r14,r28
 971 0256 0894      		sec
 972 0258 E11C      		adc r14,__zero_reg__
 973 025a F11C      		adc r15,__zero_reg__
 571:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 975               	.LM66:
 976 025c 94E0      		ldi r25,lo8(4)
 977 025e A92E      		mov r10,r25
 978 0260 B12C      		mov r11,__zero_reg__
 979 0262 AC0E      		add r10,r28
 980 0264 BD1E      		adc r11,r29
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 982               	.LM67:
 983 0266 88E0      		ldi r24,lo8(8)
 984 0268 882E      		mov r8,r24
 985 026a 912C      		mov r9,__zero_reg__
 986 026c 800E      		add r8,r16
 987 026e 911E      		adc r9,r17
 988 0270 00C0      		rjmp .L19
 989               	.L33:
 611:../../freeRtos/Source/queue.c **** 			return errQUEUE_FULL;
 991               	.LM68:
 992 0272 21E0      		ldi r18,lo8(1)
 993               	.L19:
 511:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 995               	.LM69:
 996               	/* #APP */
 997               	 ;  511 "../../freeRtos/Source/queue.c" 1
 998 0274 0FB6      		in		__tmp_reg__, __SREG__
 999               	 ;  0 "" 2
 1000               	 ;  511 "../../freeRtos/Source/queue.c" 1
 1001 0276 F894      		cli
 1002               	 ;  0 "" 2
 1003               	 ;  511 "../../freeRtos/Source/queue.c" 1
 1004 0278 0F92      		push	__tmp_reg__
 1005               	 ;  0 "" 2
 515:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 1007               	.LM70:
 1008               	/* #NOAPP */
 1009 027a F801      		movw r30,r16
 1010 027c 928D      		ldd r25,Z+26
 1011 027e 838D      		ldd r24,Z+27
 1012 0280 9817      		cp r25,r24
 1013 0282 00F0      		brlo .+2
 1014 0284 00C0      		rjmp .L20
 1015               	.LBB14:
 1016               	.LBB15:
1101:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1018               	.LM71:
 1019 0286 448D      		ldd r20,Z+28
 1020 0288 4423      		tst r20
 1021 028a 01F0      		breq .L21
1114:../../freeRtos/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1023               	.LM72:
 1024 028c 7720      		tst r7
 1025 028e 01F4      		brne .L22
1116:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1027               	.LM73:
 1028 0290 8481      		ldd r24,Z+4
 1029 0292 9581      		ldd r25,Z+5
 1030 0294 B601      		movw r22,r12
 1031 0296 50E0      		ldi r21,lo8(0)
 1032 0298 0E94 0000 		call memcpy
1117:../../freeRtos/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1034               	.LM74:
 1035 029c F801      		movw r30,r16
 1036 029e 248D      		ldd r18,Z+28
 1037 02a0 8481      		ldd r24,Z+4
 1038 02a2 9581      		ldd r25,Z+5
 1039 02a4 820F      		add r24,r18
 1040 02a6 911D      		adc r25,__zero_reg__
 1041 02a8 8483      		std Z+4,r24
 1042 02aa 9583      		std Z+5,r25
1118:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1044               	.LM75:
 1045 02ac 2281      		ldd r18,Z+2
 1046 02ae 3381      		ldd r19,Z+3
 1047 02b0 8217      		cp r24,r18
 1048 02b2 9307      		cpc r25,r19
 1049 02b4 00F0      		brlo .L21
1120:../../freeRtos/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1051               	.LM76:
 1052 02b6 8081      		ld r24,Z
 1053 02b8 9181      		ldd r25,Z+1
 1054 02ba 8483      		std Z+4,r24
 1055 02bc 9583      		std Z+5,r25
 1056 02be 00C0      		rjmp .L21
 1057               	.L22:
1125:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1059               	.LM77:
 1060 02c0 F801      		movw r30,r16
 1061 02c2 8681      		ldd r24,Z+6
 1062 02c4 9781      		ldd r25,Z+7
 1063 02c6 B601      		movw r22,r12
 1064 02c8 50E0      		ldi r21,lo8(0)
 1065 02ca 0E94 0000 		call memcpy
1126:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1067               	.LM78:
 1068 02ce F801      		movw r30,r16
 1069 02d0 248D      		ldd r18,Z+28
 1070 02d2 30E0      		ldi r19,lo8(0)
 1071 02d4 3095      		com r19
 1072 02d6 2195      		neg r18
 1073 02d8 3F4F      		sbci r19,lo8(-1)
 1074 02da 8681      		ldd r24,Z+6
 1075 02dc 9781      		ldd r25,Z+7
 1076 02de 820F      		add r24,r18
 1077 02e0 931F      		adc r25,r19
 1078 02e2 8683      		std Z+6,r24
 1079 02e4 9783      		std Z+7,r25
1127:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1081               	.LM79:
 1082 02e6 4081      		ld r20,Z
 1083 02e8 5181      		ldd r21,Z+1
 1084 02ea 8417      		cp r24,r20
 1085 02ec 9507      		cpc r25,r21
 1086 02ee 00F4      		brsh .L21
1129:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1088               	.LM80:
 1089 02f0 8281      		ldd r24,Z+2
 1090 02f2 9381      		ldd r25,Z+3
 1091 02f4 820F      		add r24,r18
 1092 02f6 931F      		adc r25,r19
 1093 02f8 8683      		std Z+6,r24
 1094 02fa 9783      		std Z+7,r25
 1095               	.L21:
1133:../../freeRtos/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1097               	.LM81:
 1098 02fc F801      		movw r30,r16
 1099 02fe 828D      		ldd r24,Z+26
 1100 0300 8F5F      		subi r24,lo8(-(1))
 1101 0302 828F      		std Z+26,r24
 1102               	.LBE15:
 1103               	.LBE14:
 522:../../freeRtos/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1105               	.LM82:
 1106 0304 8189      		ldd r24,Z+17
 1107 0306 8823      		tst r24
 1108 0308 01F0      		breq .L25
 524:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 1110               	.LM83:
 1111 030a C801      		movw r24,r16
 1112 030c 4196      		adiw r24,17
 1113 030e 0E94 0000 		call xTaskRemoveFromEventList
 1114 0312 8130      		cpi r24,lo8(1)
 1115 0314 01F4      		brne .L25
 530:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 1117               	.LM84:
 1118 0316 0E94 0000 		call vPortYield
 1119               	.L25:
 534:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 1121               	.LM85:
 1122               	/* #APP */
 1123               	 ;  534 "../../freeRtos/Source/queue.c" 1
 1124 031a 0F90      		pop		__tmp_reg__
 1125               	 ;  0 "" 2
 1126               	 ;  534 "../../freeRtos/Source/queue.c" 1
 1127 031c 0FBE      		out		__SREG__, __tmp_reg__
 1128               	 ;  0 "" 2
 538:../../freeRtos/Source/queue.c **** 				return pdPASS;
 1130               	.LM86:
 1131               	/* #NOAPP */
 1132 031e 81E0      		ldi r24,lo8(1)
 1133 0320 00C0      		rjmp .L26
 1134               	.L20:
 542:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1136               	.LM87:
 1137 0322 8C81      		ldd r24,Y+4
 1138 0324 9D81      		ldd r25,Y+5
 1139 0326 0097      		sbiw r24,0
 1140 0328 01F4      		brne .L27
 546:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 1142               	.LM88:
 1143               	/* #APP */
 1144               	 ;  546 "../../freeRtos/Source/queue.c" 1
 1145 032a 0F90      		pop		__tmp_reg__
 1146               	 ;  0 "" 2
 1147               	 ;  546 "../../freeRtos/Source/queue.c" 1
 1148 032c 0FBE      		out		__SREG__, __tmp_reg__
 1149               	 ;  0 "" 2
 1150               	/* #NOAPP */
 1151 032e 00C0      		rjmp .L34
 1152               	.L27:
 553:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1154               	.LM89:
 1155 0330 2223      		tst r18
 1156 0332 01F4      		brne .L28
 557:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1158               	.LM90:
 1159 0334 C701      		movw r24,r14
 1160 0336 0E94 0000 		call vTaskSetTimeOutState
 1161               	.L28:
 562:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 1163               	.LM91:
 1164               	/* #APP */
 1165               	 ;  562 "../../freeRtos/Source/queue.c" 1
 1166 033a 0F90      		pop		__tmp_reg__
 1167               	 ;  0 "" 2
 1168               	 ;  562 "../../freeRtos/Source/queue.c" 1
 1169 033c 0FBE      		out		__SREG__, __tmp_reg__
 1170               	 ;  0 "" 2
 567:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 1172               	.LM92:
 1173               	/* #NOAPP */
 1174 033e 0E94 0000 		call vTaskSuspendAll
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1176               	.LM93:
 1177               	/* #APP */
 1178               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1179 0342 0FB6      		in		__tmp_reg__, __SREG__
 1180               	 ;  0 "" 2
 1181               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1182 0344 F894      		cli
 1183               	 ;  0 "" 2
 1184               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1185 0346 0F92      		push	__tmp_reg__
 1186               	 ;  0 "" 2
 1187               	/* #NOAPP */
 1188 0348 F801      		movw r30,r16
 1189 034a 858D      		ldd r24,Z+29
 1190 034c 8F3F      		cpi r24,lo8(-1)
 1191 034e 01F4      		brne .L29
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1193               	.LM94:
 1194 0350 158E      		std Z+29,__zero_reg__
 1195               	.L29:
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1197               	.LM95:
 1198 0352 F801      		movw r30,r16
 1199 0354 868D      		ldd r24,Z+30
 1200 0356 8F3F      		cpi r24,lo8(-1)
 1201 0358 01F4      		brne .L30
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1203               	.LM96:
 1204 035a 168E      		std Z+30,__zero_reg__
 1205               	.L30:
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1207               	.LM97:
 1208               	/* #APP */
 1209               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1210 035c 0F90      		pop		__tmp_reg__
 1211               	 ;  0 "" 2
 1212               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1213 035e 0FBE      		out		__SREG__, __tmp_reg__
 1214               	 ;  0 "" 2
 571:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1216               	.LM98:
 1217               	/* #NOAPP */
 1218 0360 C701      		movw r24,r14
 1219 0362 B501      		movw r22,r10
 1220 0364 0E94 0000 		call xTaskCheckForTimeOut
 1221 0368 8823      		tst r24
 1222 036a 01F4      		brne .L31
 1223               	.LBB16:
 1224               	.LBB17:
1213:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1214:../../freeRtos/Source/queue.c **** 
1215:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1216:../../freeRtos/Source/queue.c **** {
1217:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1218:../../freeRtos/Source/queue.c **** 
1219:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
1220:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
1221:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
1222:../../freeRtos/Source/queue.c **** 
1223:../../freeRtos/Source/queue.c **** 	return xReturn;
1224:../../freeRtos/Source/queue.c **** }
1225:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1226:../../freeRtos/Source/queue.c **** 
1227:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1228:../../freeRtos/Source/queue.c **** {
1229:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1230:../../freeRtos/Source/queue.c **** 
1231:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
1232:../../freeRtos/Source/queue.c **** 
1233:../../freeRtos/Source/queue.c **** 	return xReturn;
1234:../../freeRtos/Source/queue.c **** }
1235:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1236:../../freeRtos/Source/queue.c **** 
1237:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1238:../../freeRtos/Source/queue.c **** {
1239:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1240:../../freeRtos/Source/queue.c **** 
1241:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 1226               	.LM99:
 1227               	/* #APP */
 1228               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 1229 036c 0FB6      		in		__tmp_reg__, __SREG__
 1230               	 ;  0 "" 2
 1231               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 1232 036e F894      		cli
 1233               	 ;  0 "" 2
 1234               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 1235 0370 0F92      		push	__tmp_reg__
 1236               	 ;  0 "" 2
1242:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1238               	.LM100:
 1239               	/* #NOAPP */
 1240 0372 F801      		movw r30,r16
 1241 0374 928D      		ldd r25,Z+26
1243:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 1243               	.LM101:
 1244               	/* #APP */
 1245               	 ;  1243 "../../freeRtos/Source/queue.c" 1
 1246 0376 0F90      		pop		__tmp_reg__
 1247               	 ;  0 "" 2
 1248               	 ;  1243 "../../freeRtos/Source/queue.c" 1
 1249 0378 0FBE      		out		__SREG__, __tmp_reg__
 1250               	 ;  0 "" 2
 1251               	/* #NOAPP */
 1252               	.LBE17:
 1253               	.LBE16:
 573:../../freeRtos/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) )
 1255               	.LM102:
 1256 037a F801      		movw r30,r16
 1257 037c 838D      		ldd r24,Z+27
 1258 037e 9817      		cp r25,r24
 1259 0380 01F4      		brne .L32
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1261               	.LM103:
 1262 0382 6C81      		ldd r22,Y+4
 1263 0384 7D81      		ldd r23,Y+5
 1264 0386 C401      		movw r24,r8
 1265 0388 0E94 0000 		call vTaskPlaceOnEventList
 583:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1267               	.LM104:
 1268 038c C801      		movw r24,r16
 1269 038e 0E94 0000 		call prvUnlockQueue
 590:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 1271               	.LM105:
 1272 0392 0E94 0000 		call xTaskResumeAll
 1273 0396 8823      		tst r24
 1274 0398 01F0      		breq .+2
 1275 039a 00C0      		rjmp .L33
 592:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 1277               	.LM106:
 1278 039c 0E94 0000 		call vPortYield
 1279 03a0 00C0      		rjmp .L33
 1280               	.L32:
 598:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1282               	.LM107:
 1283 03a2 C801      		movw r24,r16
 1284 03a4 0E94 0000 		call prvUnlockQueue
 599:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 1286               	.LM108:
 1287 03a8 0E94 0000 		call xTaskResumeAll
 1288 03ac 00C0      		rjmp .L33
 1289               	.L31:
 605:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1291               	.LM109:
 1292 03ae C801      		movw r24,r16
 1293 03b0 0E94 0000 		call prvUnlockQueue
 606:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 1295               	.LM110:
 1296 03b4 0E94 0000 		call xTaskResumeAll
 1297               	.L34:
 611:../../freeRtos/Source/queue.c **** 			return errQUEUE_FULL;
 1299               	.LM111:
 1300 03b8 80E0      		ldi r24,lo8(0)
 1301               	.L26:
 1302               	/* epilogue start */
 614:../../freeRtos/Source/queue.c **** }
 1304               	.LM112:
 1305 03ba 2596      		adiw r28,5
 1306 03bc CDBF      		out __SP_L__,r28
 1307 03be DEBF      		out __SP_H__,r29
 1308 03c0 CF91      		pop r28
 1309 03c2 DF91      		pop r29
 1310 03c4 1F91      		pop r17
 1311 03c6 0F91      		pop r16
 1312 03c8 FF90      		pop r15
 1313 03ca EF90      		pop r14
 1314 03cc DF90      		pop r13
 1315 03ce CF90      		pop r12
 1316 03d0 BF90      		pop r11
 1317 03d2 AF90      		pop r10
 1318 03d4 9F90      		pop r9
 1319 03d6 8F90      		pop r8
 1320 03d8 7F90      		pop r7
 1321 03da 0895      		ret
 1327               	.Lscope4:
 1329               		.stabd	78,0,0
 1334               	.global	xQueueGenericSendFromISR
 1336               	xQueueGenericSendFromISR:
 1337               		.stabd	46,0,0
 818:../../freeRtos/Source/queue.c **** {
 1339               	.LM113:
 1340               	.LFBB5:
 1341 03dc 0F93      		push r16
 1342 03de 1F93      		push r17
 1343 03e0 CF93      		push r28
 1344 03e2 DF93      		push r29
 1345               	/* prologue: function */
 1346               	/* frame size = 0 */
 1347               	/* stack size = 4 */
 1348               	.L__stack_usage = 4
 1349 03e4 EC01      		movw r28,r24
 1350 03e6 8A01      		movw r16,r20
 829:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 1352               	.LM114:
 1353 03e8 9A8D      		ldd r25,Y+26
 1354 03ea 8B8D      		ldd r24,Y+27
 1355 03ec 9817      		cp r25,r24
 1356 03ee 00F0      		brlo .+2
 1357 03f0 00C0      		rjmp .L42
 1358               	.LBB18:
 1359               	.LBB19:
1101:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1361               	.LM115:
 1362 03f2 4C8D      		ldd r20,Y+28
 1363 03f4 4423      		tst r20
 1364 03f6 01F0      		breq .L37
1114:../../freeRtos/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1366               	.LM116:
 1367 03f8 2223      		tst r18
 1368 03fa 01F4      		brne .L38
1116:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1370               	.LM117:
 1371 03fc 8C81      		ldd r24,Y+4
 1372 03fe 9D81      		ldd r25,Y+5
 1373 0400 50E0      		ldi r21,lo8(0)
 1374 0402 0E94 0000 		call memcpy
1117:../../freeRtos/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1376               	.LM118:
 1377 0406 2C8D      		ldd r18,Y+28
 1378 0408 8C81      		ldd r24,Y+4
 1379 040a 9D81      		ldd r25,Y+5
 1380 040c 820F      		add r24,r18
 1381 040e 911D      		adc r25,__zero_reg__
 1382 0410 8C83      		std Y+4,r24
 1383 0412 9D83      		std Y+5,r25
1118:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1385               	.LM119:
 1386 0414 2A81      		ldd r18,Y+2
 1387 0416 3B81      		ldd r19,Y+3
 1388 0418 8217      		cp r24,r18
 1389 041a 9307      		cpc r25,r19
 1390 041c 00F0      		brlo .L37
1120:../../freeRtos/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1392               	.LM120:
 1393 041e 8881      		ld r24,Y
 1394 0420 9981      		ldd r25,Y+1
 1395 0422 8C83      		std Y+4,r24
 1396 0424 9D83      		std Y+5,r25
 1397 0426 00C0      		rjmp .L37
 1398               	.L38:
1125:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1400               	.LM121:
 1401 0428 8E81      		ldd r24,Y+6
 1402 042a 9F81      		ldd r25,Y+7
 1403 042c 50E0      		ldi r21,lo8(0)
 1404 042e 0E94 0000 		call memcpy
1126:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1406               	.LM122:
 1407 0432 2C8D      		ldd r18,Y+28
 1408 0434 30E0      		ldi r19,lo8(0)
 1409 0436 3095      		com r19
 1410 0438 2195      		neg r18
 1411 043a 3F4F      		sbci r19,lo8(-1)
 1412 043c 8E81      		ldd r24,Y+6
 1413 043e 9F81      		ldd r25,Y+7
 1414 0440 820F      		add r24,r18
 1415 0442 931F      		adc r25,r19
 1416 0444 8E83      		std Y+6,r24
 1417 0446 9F83      		std Y+7,r25
1127:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1419               	.LM123:
 1420 0448 4881      		ld r20,Y
 1421 044a 5981      		ldd r21,Y+1
 1422 044c 8417      		cp r24,r20
 1423 044e 9507      		cpc r25,r21
 1424 0450 00F4      		brsh .L37
1129:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1426               	.LM124:
 1427 0452 8A81      		ldd r24,Y+2
 1428 0454 9B81      		ldd r25,Y+3
 1429 0456 820F      		add r24,r18
 1430 0458 931F      		adc r25,r19
 1431 045a 8E83      		std Y+6,r24
 1432 045c 9F83      		std Y+7,r25
 1433               	.L37:
1133:../../freeRtos/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1435               	.LM125:
 1436 045e 8A8D      		ldd r24,Y+26
 1437 0460 8F5F      		subi r24,lo8(-(1))
 1438 0462 8A8F      		std Y+26,r24
 1439               	.LBE19:
 1440               	.LBE18:
 837:../../freeRtos/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 1442               	.LM126:
 1443 0464 8E8D      		ldd r24,Y+30
 1444 0466 8F3F      		cpi r24,lo8(-1)
 1445 0468 01F4      		brne .L41
 839:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 1447               	.LM127:
 1448 046a 8989      		ldd r24,Y+17
 1449 046c 8823      		tst r24
 1450 046e 01F0      		breq .L44
 841:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1452               	.LM128:
 1453 0470 CE01      		movw r24,r28
 1454 0472 4196      		adiw r24,17
 1455 0474 0E94 0000 		call xTaskRemoveFromEventList
 1456 0478 8823      		tst r24
 1457 047a 01F0      		breq .L44
 845:../../freeRtos/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 1459               	.LM129:
 1460 047c 81E0      		ldi r24,lo8(1)
 1461 047e F801      		movw r30,r16
 1462 0480 8083      		st Z,r24
 1463 0482 00C0      		rjmp .L36
 1464               	.L41:
 853:../../freeRtos/Source/queue.c **** 				++( pxQueue->xTxLock );
 1466               	.LM130:
 1467 0484 8F5F      		subi r24,lo8(-(1))
 1468 0486 8E8F      		std Y+30,r24
 1469 0488 00C0      		rjmp .L44
 1470               	.L42:
 861:../../freeRtos/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1472               	.LM131:
 1473 048a 80E0      		ldi r24,lo8(0)
 1474 048c 00C0      		rjmp .L36
 1475               	.L44:
 856:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 1477               	.LM132:
 1478 048e 81E0      		ldi r24,lo8(1)
 1479               	.L36:
 1480               	/* epilogue start */
 867:../../freeRtos/Source/queue.c **** }
 1482               	.LM133:
 1483 0490 DF91      		pop r29
 1484 0492 CF91      		pop r28
 1485 0494 1F91      		pop r17
 1486 0496 0F91      		pop r16
 1487 0498 0895      		ret
 1492               	.Lscope5:
 1494               		.stabd	78,0,0
 1499               	.global	xQueueGenericReceive
 1501               	xQueueGenericReceive:
 1502               		.stabd	46,0,0
 871:../../freeRtos/Source/queue.c **** {
 1504               	.LM134:
 1505               	.LFBB6:
 1506 049a 7F92      		push r7
 1507 049c 8F92      		push r8
 1508 049e 9F92      		push r9
 1509 04a0 AF92      		push r10
 1510 04a2 BF92      		push r11
 1511 04a4 CF92      		push r12
 1512 04a6 DF92      		push r13
 1513 04a8 EF92      		push r14
 1514 04aa FF92      		push r15
 1515 04ac 0F93      		push r16
 1516 04ae 1F93      		push r17
 1517 04b0 DF93      		push r29
 1518 04b2 CF93      		push r28
 1519 04b4 CDB7      		in r28,__SP_L__
 1520 04b6 DEB7      		in r29,__SP_H__
 1521 04b8 2597      		sbiw r28,5
 1522 04ba CDBF      		out __SP_L__,r28
 1523 04bc DEBF      		out __SP_H__,r29
 1524               	/* prologue: function */
 1525               	/* frame size = 5 */
 1526               	/* stack size = 18 */
 1527               	.L__stack_usage = 18
 1528 04be 8C01      		movw r16,r24
 1529 04c0 862E      		mov r8,r22
 1530 04c2 772E      		mov r7,r23
 1531 04c4 4C83      		std Y+4,r20
 1532 04c6 5D83      		std Y+5,r21
 1533 04c8 922E      		mov r9,r18
 872:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 1535               	.LM135:
 1536 04ca 20E0      		ldi r18,lo8(0)
 959:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1538               	.LM136:
 1539 04cc 7E01      		movw r14,r28
 1540 04ce 0894      		sec
 1541 04d0 E11C      		adc r14,__zero_reg__
 1542 04d2 F11C      		adc r15,__zero_reg__
 973:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1544               	.LM137:
 1545 04d4 44E0      		ldi r20,lo8(4)
 1546 04d6 C42E      		mov r12,r20
 1547 04d8 D12C      		mov r13,__zero_reg__
 1548 04da CC0E      		add r12,r28
 1549 04dc DD1E      		adc r13,r29
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1551               	.LM138:
 1552 04de 31E1      		ldi r19,lo8(17)
 1553 04e0 A32E      		mov r10,r19
 1554 04e2 B12C      		mov r11,__zero_reg__
 1555 04e4 A80E      		add r10,r24
 1556 04e6 B91E      		adc r11,r25
 1557 04e8 00C0      		rjmp .L46
 1558               	.L60:
1011:../../freeRtos/Source/queue.c **** 			return errQUEUE_EMPTY;
 1560               	.LM139:
 1561 04ea 21E0      		ldi r18,lo8(1)
 1562               	.L46:
 882:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 1564               	.LM140:
 1565               	/* #APP */
 1566               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1567 04ec 0FB6      		in		__tmp_reg__, __SREG__
 1568               	 ;  0 "" 2
 1569               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1570 04ee F894      		cli
 1571               	 ;  0 "" 2
 1572               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1573 04f0 0F92      		push	__tmp_reg__
 1574               	 ;  0 "" 2
 886:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1576               	.LM141:
 1577               	/* #NOAPP */
 1578 04f2 F801      		movw r30,r16
 1579 04f4 828D      		ldd r24,Z+26
 1580 04f6 8823      		tst r24
 1581 04f8 01F4      		brne .+2
 1582 04fa 00C0      		rjmp .L47
 889:../../freeRtos/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 1584               	.LM142:
 1585 04fc E680      		ldd r14,Z+6
 1586 04fe F780      		ldd r15,Z+7
 1587               	.LBB20:
 1588               	.LBB21:
1139:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1590               	.LM143:
 1591 0500 8081      		ld r24,Z
 1592 0502 9181      		ldd r25,Z+1
 1593 0504 0097      		sbiw r24,0
 1594 0506 01F0      		breq .L48
1141:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1596               	.LM144:
 1597 0508 448D      		ldd r20,Z+28
 1598 050a 9701      		movw r18,r14
 1599 050c 240F      		add r18,r20
 1600 050e 311D      		adc r19,__zero_reg__
 1601 0510 2683      		std Z+6,r18
 1602 0512 3783      		std Z+7,r19
1142:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1604               	.LM145:
 1605 0514 6281      		ldd r22,Z+2
 1606 0516 7381      		ldd r23,Z+3
 1607 0518 2617      		cp r18,r22
 1608 051a 3707      		cpc r19,r23
 1609 051c 00F0      		brlo .L49
1144:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1611               	.LM146:
 1612 051e 8683      		std Z+6,r24
 1613 0520 9783      		std Z+7,r25
 1614               	.L49:
1146:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1616               	.LM147:
 1617 0522 F801      		movw r30,r16
 1618 0524 6681      		ldd r22,Z+6
 1619 0526 7781      		ldd r23,Z+7
 1620 0528 882D      		mov r24,r8
 1621 052a 972D      		mov r25,r7
 1622 052c 50E0      		ldi r21,lo8(0)
 1623 052e 0E94 0000 		call memcpy
 1624               	.L48:
 1625               	.LBE21:
 1626               	.LBE20:
 893:../../freeRtos/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1628               	.LM148:
 1629 0532 9920      		tst r9
 1630 0534 01F4      		brne .L51
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1632               	.LM149:
 1633 0536 F801      		movw r30,r16
 1634 0538 828D      		ldd r24,Z+26
 1635 053a 8150      		subi r24,lo8(-(-1))
 1636 053c 828F      		std Z+26,r24
 911:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1638               	.LM150:
 1639 053e 8085      		ldd r24,Z+8
 1640 0540 8823      		tst r24
 1641 0542 01F0      		breq .L52
 913:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1643               	.LM151:
 1644 0544 C801      		movw r24,r16
 1645 0546 0896      		adiw r24,8
 1646 0548 0E94 0000 		call xTaskRemoveFromEventList
 1647 054c 8130      		cpi r24,lo8(1)
 1648 054e 01F4      		brne .L52
 1649 0550 00C0      		rjmp .L61
 1650               	.L51:
 925:../../freeRtos/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 1652               	.LM152:
 1653 0552 F801      		movw r30,r16
 1654 0554 E682      		std Z+6,r14
 1655 0556 F782      		std Z+7,r15
 929:../../freeRtos/Source/queue.c **** 					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 1657               	.LM153:
 1658 0558 8189      		ldd r24,Z+17
 1659 055a 8823      		tst r24
 1660 055c 01F0      		breq .L52
 933:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1662               	.LM154:
 1663 055e C801      		movw r24,r16
 1664 0560 4196      		adiw r24,17
 1665 0562 0E94 0000 		call xTaskRemoveFromEventList
 1666 0566 8823      		tst r24
 1667 0568 01F0      		breq .L52
 1668               	.L61:
 936:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 1670               	.LM155:
 1671 056a 0E94 0000 		call vPortYield
 1672               	.L52:
 942:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 1674               	.LM156:
 1675               	/* #APP */
 1676               	 ;  942 "../../freeRtos/Source/queue.c" 1
 1677 056e 0F90      		pop		__tmp_reg__
 1678               	 ;  0 "" 2
 1679               	 ;  942 "../../freeRtos/Source/queue.c" 1
 1680 0570 0FBE      		out		__SREG__, __tmp_reg__
 1681               	 ;  0 "" 2
 943:../../freeRtos/Source/queue.c **** 				return pdPASS;
 1683               	.LM157:
 1684               	/* #NOAPP */
 1685 0572 81E0      		ldi r24,lo8(1)
 1686 0574 00C0      		rjmp .L53
 1687               	.L47:
 947:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1689               	.LM158:
 1690 0576 8C81      		ldd r24,Y+4
 1691 0578 9D81      		ldd r25,Y+5
 1692 057a 0097      		sbiw r24,0
 1693 057c 01F4      		brne .L54
 951:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 1695               	.LM159:
 1696               	/* #APP */
 1697               	 ;  951 "../../freeRtos/Source/queue.c" 1
 1698 057e 0F90      		pop		__tmp_reg__
 1699               	 ;  0 "" 2
 1700               	 ;  951 "../../freeRtos/Source/queue.c" 1
 1701 0580 0FBE      		out		__SREG__, __tmp_reg__
 1702               	 ;  0 "" 2
 1703               	/* #NOAPP */
 1704 0582 00C0      		rjmp .L62
 1705               	.L54:
 955:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1707               	.LM160:
 1708 0584 2223      		tst r18
 1709 0586 01F4      		brne .L55
 959:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1711               	.LM161:
 1712 0588 C701      		movw r24,r14
 1713 058a 0E94 0000 		call vTaskSetTimeOutState
 1714               	.L55:
 964:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 1716               	.LM162:
 1717               	/* #APP */
 1718               	 ;  964 "../../freeRtos/Source/queue.c" 1
 1719 058e 0F90      		pop		__tmp_reg__
 1720               	 ;  0 "" 2
 1721               	 ;  964 "../../freeRtos/Source/queue.c" 1
 1722 0590 0FBE      		out		__SREG__, __tmp_reg__
 1723               	 ;  0 "" 2
 969:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 1725               	.LM163:
 1726               	/* #NOAPP */
 1727 0592 0E94 0000 		call vTaskSuspendAll
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1729               	.LM164:
 1730               	/* #APP */
 1731               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1732 0596 0FB6      		in		__tmp_reg__, __SREG__
 1733               	 ;  0 "" 2
 1734               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1735 0598 F894      		cli
 1736               	 ;  0 "" 2
 1737               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1738 059a 0F92      		push	__tmp_reg__
 1739               	 ;  0 "" 2
 1740               	/* #NOAPP */
 1741 059c F801      		movw r30,r16
 1742 059e 858D      		ldd r24,Z+29
 1743 05a0 8F3F      		cpi r24,lo8(-1)
 1744 05a2 01F4      		brne .L56
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1746               	.LM165:
 1747 05a4 158E      		std Z+29,__zero_reg__
 1748               	.L56:
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1750               	.LM166:
 1751 05a6 F801      		movw r30,r16
 1752 05a8 868D      		ldd r24,Z+30
 1753 05aa 8F3F      		cpi r24,lo8(-1)
 1754 05ac 01F4      		brne .L57
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1756               	.LM167:
 1757 05ae 168E      		std Z+30,__zero_reg__
 1758               	.L57:
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1760               	.LM168:
 1761               	/* #APP */
 1762               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1763 05b0 0F90      		pop		__tmp_reg__
 1764               	 ;  0 "" 2
 1765               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1766 05b2 0FBE      		out		__SREG__, __tmp_reg__
 1767               	 ;  0 "" 2
 973:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1769               	.LM169:
 1770               	/* #NOAPP */
 1771 05b4 C701      		movw r24,r14
 1772 05b6 B601      		movw r22,r12
 1773 05b8 0E94 0000 		call xTaskCheckForTimeOut
 1774 05bc 8823      		tst r24
 1775 05be 01F4      		brne .L58
 1776               	.LBB22:
 1777               	.LBB23:
1219:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 1779               	.LM170:
 1780               	/* #APP */
 1781               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1782 05c0 0FB6      		in		__tmp_reg__, __SREG__
 1783               	 ;  0 "" 2
 1784               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1785 05c2 F894      		cli
 1786               	 ;  0 "" 2
 1787               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1788 05c4 0F92      		push	__tmp_reg__
 1789               	 ;  0 "" 2
1220:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1791               	.LM171:
 1792               	/* #NOAPP */
 1793 05c6 F801      		movw r30,r16
 1794 05c8 828D      		ldd r24,Z+26
1221:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 1796               	.LM172:
 1797               	/* #APP */
 1798               	 ;  1221 "../../freeRtos/Source/queue.c" 1
 1799 05ca 0F90      		pop		__tmp_reg__
 1800               	 ;  0 "" 2
 1801               	 ;  1221 "../../freeRtos/Source/queue.c" 1
 1802 05cc 0FBE      		out		__SREG__, __tmp_reg__
 1803               	 ;  0 "" 2
 1804               	/* #NOAPP */
 1805               	.LBE23:
 1806               	.LBE22:
 975:../../freeRtos/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) )
 1808               	.LM173:
 1809 05ce 8823      		tst r24
 1810 05d0 01F4      		brne .L59
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1812               	.LM174:
 1813 05d2 6C81      		ldd r22,Y+4
 1814 05d4 7D81      		ldd r23,Y+5
 1815 05d6 C501      		movw r24,r10
 1816 05d8 0E94 0000 		call vTaskPlaceOnEventList
 993:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1818               	.LM175:
 1819 05dc C801      		movw r24,r16
 1820 05de 0E94 0000 		call prvUnlockQueue
 994:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 1822               	.LM176:
 1823 05e2 0E94 0000 		call xTaskResumeAll
 1824 05e6 8823      		tst r24
 1825 05e8 01F0      		breq .+2
 1826 05ea 00C0      		rjmp .L60
 996:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 1828               	.LM177:
 1829 05ec 0E94 0000 		call vPortYield
 1830 05f0 00C0      		rjmp .L60
 1831               	.L59:
1002:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1833               	.LM178:
 1834 05f2 C801      		movw r24,r16
 1835 05f4 0E94 0000 		call prvUnlockQueue
1003:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 1837               	.LM179:
 1838 05f8 0E94 0000 		call xTaskResumeAll
 1839 05fc 00C0      		rjmp .L60
 1840               	.L58:
1008:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1842               	.LM180:
 1843 05fe C801      		movw r24,r16
 1844 0600 0E94 0000 		call prvUnlockQueue
1009:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 1846               	.LM181:
 1847 0604 0E94 0000 		call xTaskResumeAll
 1848               	.L62:
1011:../../freeRtos/Source/queue.c **** 			return errQUEUE_EMPTY;
 1850               	.LM182:
 1851 0608 80E0      		ldi r24,lo8(0)
 1852               	.L53:
 1853               	/* epilogue start */
1014:../../freeRtos/Source/queue.c **** }
 1855               	.LM183:
 1856 060a 2596      		adiw r28,5
 1857 060c CDBF      		out __SP_L__,r28
 1858 060e DEBF      		out __SP_H__,r29
 1859 0610 CF91      		pop r28
 1860 0612 DF91      		pop r29
 1861 0614 1F91      		pop r17
 1862 0616 0F91      		pop r16
 1863 0618 FF90      		pop r15
 1864 061a EF90      		pop r14
 1865 061c DF90      		pop r13
 1866 061e CF90      		pop r12
 1867 0620 BF90      		pop r11
 1868 0622 AF90      		pop r10
 1869 0624 9F90      		pop r9
 1870 0626 8F90      		pop r8
 1871 0628 7F90      		pop r7
 1872 062a 0895      		ret
 1879               	.Lscope6:
 1881               		.stabd	78,0,0
 1885               	.global	xQueueReceiveFromISR
 1887               	xQueueReceiveFromISR:
 1888               		.stabd	46,0,0
1018:../../freeRtos/Source/queue.c **** {
 1890               	.LM184:
 1891               	.LFBB7:
 1892 062c 0F93      		push r16
 1893 062e 1F93      		push r17
 1894 0630 CF93      		push r28
 1895 0632 DF93      		push r29
 1896               	/* prologue: function */
 1897               	/* frame size = 0 */
 1898               	/* stack size = 4 */
 1899               	.L__stack_usage = 4
 1900 0634 EC01      		movw r28,r24
 1901 0636 CB01      		movw r24,r22
 1902 0638 8A01      		movw r16,r20
1025:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1904               	.LM185:
 1905 063a 2A8D      		ldd r18,Y+26
 1906 063c 2223      		tst r18
 1907 063e 01F0      		breq .L69
 1908               	.LBB24:
 1909               	.LBB25:
1139:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1911               	.LM186:
 1912 0640 E881      		ld r30,Y
 1913 0642 F981      		ldd r31,Y+1
 1914 0644 3097      		sbiw r30,0
 1915 0646 01F0      		breq .L65
1141:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1917               	.LM187:
 1918 0648 4C8D      		ldd r20,Y+28
 1919 064a 2E81      		ldd r18,Y+6
 1920 064c 3F81      		ldd r19,Y+7
 1921 064e 240F      		add r18,r20
 1922 0650 311D      		adc r19,__zero_reg__
 1923 0652 2E83      		std Y+6,r18
 1924 0654 3F83      		std Y+7,r19
1142:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1926               	.LM188:
 1927 0656 AA81      		ldd r26,Y+2
 1928 0658 BB81      		ldd r27,Y+3
 1929 065a 2A17      		cp r18,r26
 1930 065c 3B07      		cpc r19,r27
 1931 065e 00F0      		brlo .L66
1144:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1933               	.LM189:
 1934 0660 EE83      		std Y+6,r30
 1935 0662 FF83      		std Y+7,r31
 1936               	.L66:
1146:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1938               	.LM190:
 1939 0664 6E81      		ldd r22,Y+6
 1940 0666 2F81      		ldd r18,Y+7
 1941 0668 722F      		mov r23,r18
 1942 066a 50E0      		ldi r21,lo8(0)
 1943 066c 0E94 0000 		call memcpy
 1944               	.L65:
 1945               	.LBE25:
 1946               	.LBE24:
1030:../../freeRtos/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1948               	.LM191:
 1949 0670 8A8D      		ldd r24,Y+26
 1950 0672 8150      		subi r24,lo8(-(-1))
 1951 0674 8A8F      		std Y+26,r24
1035:../../freeRtos/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1953               	.LM192:
 1954 0676 8D8D      		ldd r24,Y+29
 1955 0678 8F3F      		cpi r24,lo8(-1)
 1956 067a 01F4      		brne .L68
1037:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 1958               	.LM193:
 1959 067c 8885      		ldd r24,Y+8
 1960 067e 8823      		tst r24
 1961 0680 01F0      		breq .L71
1039:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1963               	.LM194:
 1964 0682 CE01      		movw r24,r28
 1965 0684 0896      		adiw r24,8
 1966 0686 0E94 0000 		call xTaskRemoveFromEventList
 1967 068a 8823      		tst r24
 1968 068c 01F0      		breq .L71
1043:../../freeRtos/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 1970               	.LM195:
 1971 068e 81E0      		ldi r24,lo8(1)
 1972 0690 F801      		movw r30,r16
 1973 0692 8083      		st Z,r24
 1974 0694 00C0      		rjmp .L64
 1975               	.L68:
1051:../../freeRtos/Source/queue.c **** 				++( pxQueue->xRxLock );
 1977               	.LM196:
 1978 0696 8F5F      		subi r24,lo8(-(1))
 1979 0698 8D8F      		std Y+29,r24
 1980 069a 00C0      		rjmp .L71
 1981               	.L69:
1058:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
 1983               	.LM197:
 1984 069c 80E0      		ldi r24,lo8(0)
 1985 069e 00C0      		rjmp .L64
 1986               	.L71:
1054:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 1988               	.LM198:
 1989 06a0 81E0      		ldi r24,lo8(1)
 1990               	.L64:
 1991               	/* epilogue start */
1065:../../freeRtos/Source/queue.c **** }
 1993               	.LM199:
 1994 06a2 DF91      		pop r29
 1995 06a4 CF91      		pop r28
 1996 06a6 1F91      		pop r17
 1997 06a8 0F91      		pop r16
 1998 06aa 0895      		ret
 2003               	.Lscope7:
 2005               		.stabd	78,0,0
 2008               	.global	uxQueueMessagesWaiting
 2010               	uxQueueMessagesWaiting:
 2011               		.stabd	46,0,0
1069:../../freeRtos/Source/queue.c **** {
 2013               	.LM200:
 2014               	.LFBB8:
 2015               	/* prologue: function */
 2016               	/* frame size = 0 */
 2017               	/* stack size = 0 */
 2018               	.L__stack_usage = 0
1072:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 2020               	.LM201:
 2021               	/* #APP */
 2022               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 2023 06ac 0FB6      		in		__tmp_reg__, __SREG__
 2024               	 ;  0 "" 2
 2025               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 2026 06ae F894      		cli
 2027               	 ;  0 "" 2
 2028               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 2029 06b0 0F92      		push	__tmp_reg__
 2030               	 ;  0 "" 2
1073:../../freeRtos/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 2032               	.LM202:
 2033               	/* #NOAPP */
 2034 06b2 FC01      		movw r30,r24
 2035 06b4 828D      		ldd r24,Z+26
1074:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 2037               	.LM203:
 2038               	/* #APP */
 2039               	 ;  1074 "../../freeRtos/Source/queue.c" 1
 2040 06b6 0F90      		pop		__tmp_reg__
 2041               	 ;  0 "" 2
 2042               	 ;  1074 "../../freeRtos/Source/queue.c" 1
 2043 06b8 0FBE      		out		__SREG__, __tmp_reg__
 2044               	 ;  0 "" 2
 2045               	/* epilogue start */
1077:../../freeRtos/Source/queue.c **** }
 2047               	.LM204:
 2048               	/* #NOAPP */
 2049 06ba 0895      		ret
 2054               	.Lscope8:
 2056               		.stabd	78,0,0
 2059               	.global	uxQueueMessagesWaitingFromISR
 2061               	uxQueueMessagesWaitingFromISR:
 2062               		.stabd	46,0,0
1081:../../freeRtos/Source/queue.c **** {
 2064               	.LM205:
 2065               	.LFBB9:
 2066               	/* prologue: function */
 2067               	/* frame size = 0 */
 2068               	/* stack size = 0 */
 2069               	.L__stack_usage = 0
1084:../../freeRtos/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 2071               	.LM206:
 2072 06bc FC01      		movw r30,r24
 2073 06be 828D      		ldd r24,Z+26
 2074               	/* epilogue start */
1087:../../freeRtos/Source/queue.c **** }
 2076               	.LM207:
 2077 06c0 0895      		ret
 2082               	.Lscope9:
 2084               		.stabd	78,0,0
 2087               	.global	vQueueDelete
 2089               	vQueueDelete:
 2090               		.stabd	46,0,0
1091:../../freeRtos/Source/queue.c **** {
 2092               	.LM208:
 2093               	.LFBB10:
 2094 06c2 CF93      		push r28
 2095 06c4 DF93      		push r29
 2096               	/* prologue: function */
 2097               	/* frame size = 0 */
 2098               	/* stack size = 2 */
 2099               	.L__stack_usage = 2
 2100 06c6 EC01      		movw r28,r24
1094:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 2102               	.LM209:
 2103 06c8 8881      		ld r24,Y
 2104 06ca 9981      		ldd r25,Y+1
 2105 06cc 0E94 0000 		call vPortFree
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
 2107               	.LM210:
 2108 06d0 CE01      		movw r24,r28
 2109 06d2 0E94 0000 		call vPortFree
 2110               	/* epilogue start */
1096:../../freeRtos/Source/queue.c **** }
 2112               	.LM211:
 2113 06d6 DF91      		pop r29
 2114 06d8 CF91      		pop r28
 2115 06da 0895      		ret
 2117               	.Lscope10:
 2119               		.stabd	78,0,0
 2122               	.global	xQueueIsQueueEmptyFromISR
 2124               	xQueueIsQueueEmptyFromISR:
 2125               		.stabd	46,0,0
1228:../../freeRtos/Source/queue.c **** {
 2127               	.LM212:
 2128               	.LFBB11:
 2129               	/* prologue: function */
 2130               	/* frame size = 0 */
 2131               	/* stack size = 0 */
 2132               	.L__stack_usage = 0
1231:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 2134               	.LM213:
 2135 06dc FC01      		movw r30,r24
 2136 06de 928D      		ldd r25,Z+26
 2137 06e0 81E0      		ldi r24,lo8(1)
 2138 06e2 9111      		cpse r25,__zero_reg__
 2139 06e4 80E0      		ldi r24,lo8(0)
 2140               	.L76:
1234:../../freeRtos/Source/queue.c **** }
 2142               	.LM214:
 2143 06e6 0895      		ret
 2145               	.Lscope11:
 2147               		.stabd	78,0,0
 2150               	.global	xQueueIsQueueFullFromISR
 2152               	xQueueIsQueueFullFromISR:
 2153               		.stabd	46,0,0
1244:../../freeRtos/Source/queue.c **** 
1245:../../freeRtos/Source/queue.c **** 	return xReturn;
1246:../../freeRtos/Source/queue.c **** }
1247:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1248:../../freeRtos/Source/queue.c **** 
1249:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1250:../../freeRtos/Source/queue.c **** {
 2155               	.LM215:
 2156               	.LFBB12:
 2157               	/* prologue: function */
 2158               	/* frame size = 0 */
 2159               	/* stack size = 0 */
 2160               	.L__stack_usage = 0
 2161 06e8 FC01      		movw r30,r24
1251:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1252:../../freeRtos/Source/queue.c **** 
1253:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 2163               	.LM216:
 2164 06ea 228D      		ldd r18,Z+26
 2165 06ec 81E0      		ldi r24,lo8(1)
 2166 06ee 938D      		ldd r25,Z+27
 2167 06f0 2913      		cpse r18,r25
 2168 06f2 80E0      		ldi r24,lo8(0)
 2169               	.L78:
1254:../../freeRtos/Source/queue.c **** 
1255:../../freeRtos/Source/queue.c **** 	return xReturn;
1256:../../freeRtos/Source/queue.c **** }
 2171               	.LM217:
 2172 06f4 0895      		ret
 2174               	.Lscope12:
 2176               		.stabd	78,0,0
 2178               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/cc947KNx.s:2      *ABS*:0000003f __SREG__
     /tmp/cc947KNx.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc947KNx.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc947KNx.s:5      *ABS*:00000034 __CCP__
     /tmp/cc947KNx.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc947KNx.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc947KNx.s:448    .text:00000000 prvUnlockQueue
     /tmp/cc947KNx.s:603    .text:00000080 xQueueCreate
     /tmp/cc947KNx.s:759    .text:00000140 xQueueCreateExternal
     /tmp/cc947KNx.s:933    .text:00000224 xQueueGenericSend
     /tmp/cc947KNx.s:1336   .text:000003dc xQueueGenericSendFromISR
     /tmp/cc947KNx.s:1501   .text:0000049a xQueueGenericReceive
     /tmp/cc947KNx.s:1887   .text:0000062c xQueueReceiveFromISR
     /tmp/cc947KNx.s:2010   .text:000006ac uxQueueMessagesWaiting
     /tmp/cc947KNx.s:2061   .text:000006bc uxQueueMessagesWaitingFromISR
     /tmp/cc947KNx.s:2089   .text:000006c2 vQueueDelete
     /tmp/cc947KNx.s:2124   .text:000006dc xQueueIsQueueEmptyFromISR
     /tmp/cc947KNx.s:2152   .text:000006e8 xQueueIsQueueFullFromISR

UNDEFINED SYMBOLS
xTaskRemoveFromEventList
vTaskMissedYield
pvPortMalloc
vListInitialise
vPortFree
memcpy
vPortYield
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
