   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__RAMPY__ = 0x3a
   7               	__RAMPX__ = 0x39
   8               	__RAMPD__ = 0x38
   9               	__CCP__ = 0x34
  10               	__tmp_reg__ = 0
  11               	__zero_reg__ = 1
  14               		.text
  15               	.Ltext0:
 486               	prvCopyDataToQueue:
 487               		.stabd	46,0,0
   1:../../freeRtos/Source/queue.c **** /*
   2:../../freeRtos/Source/queue.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/Source/queue.c **** 
   4:../../freeRtos/Source/queue.c ****     ***************************************************************************
   5:../../freeRtos/Source/queue.c ****     *                                                                         *
   6:../../freeRtos/Source/queue.c ****     * If you are:                                                             *
   7:../../freeRtos/Source/queue.c ****     *                                                                         *
   8:../../freeRtos/Source/queue.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/Source/queue.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/Source/queue.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/Source/queue.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/Source/queue.c ****     *                                                                         *
  13:../../freeRtos/Source/queue.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/Source/queue.c ****     *                                                                         *
  15:../../freeRtos/Source/queue.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/Source/queue.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/Source/queue.c ****     *                                                                         *
  18:../../freeRtos/Source/queue.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/Source/queue.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/Source/queue.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/Source/queue.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/Source/queue.c ****     *                                                                         *
  23:../../freeRtos/Source/queue.c ****     ***************************************************************************
  24:../../freeRtos/Source/queue.c **** 
  25:../../freeRtos/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/Source/queue.c **** 
  27:../../freeRtos/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/Source/queue.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/Source/queue.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/Source/queue.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/Source/queue.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/Source/queue.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/Source/queue.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/Source/queue.c ****     FreeRTOS WEB site.
  41:../../freeRtos/Source/queue.c **** 
  42:../../freeRtos/Source/queue.c ****     1 tab == 4 spaces!
  43:../../freeRtos/Source/queue.c **** 
  44:../../freeRtos/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/Source/queue.c ****     contact details.
  46:../../freeRtos/Source/queue.c **** 
  47:../../freeRtos/Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/Source/queue.c ****     critical systems.
  49:../../freeRtos/Source/queue.c **** 
  50:../../freeRtos/Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/Source/queue.c ****     licensing and training services.
  52:../../freeRtos/Source/queue.c **** */
  53:../../freeRtos/Source/queue.c **** 
  54:../../freeRtos/Source/queue.c **** #include <stdlib.h>
  55:../../freeRtos/Source/queue.c **** #include <string.h>
  56:../../freeRtos/Source/queue.c **** 
  57:../../freeRtos/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../../freeRtos/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../../freeRtos/Source/queue.c **** task.h is included from an application file. */
  60:../../freeRtos/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../../freeRtos/Source/queue.c **** 
  62:../../freeRtos/Source/queue.c **** #include "FreeRTOS.h"
  63:../../freeRtos/Source/queue.c **** #include "task.h"
  64:../../freeRtos/Source/queue.c **** #include "croutine.h"
  65:../../freeRtos/Source/queue.c **** 
  66:../../freeRtos/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  67:../../freeRtos/Source/queue.c **** 
  68:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------
  69:../../freeRtos/Source/queue.c ****  * PUBLIC LIST API documented in list.h
  70:../../freeRtos/Source/queue.c ****  *----------------------------------------------------------*/
  71:../../freeRtos/Source/queue.c **** 
  72:../../freeRtos/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  73:../../freeRtos/Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  74:../../freeRtos/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  75:../../freeRtos/Source/queue.c **** 
  76:../../freeRtos/Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  77:../../freeRtos/Source/queue.c **** 
  78:../../freeRtos/Source/queue.c **** /* For internal use only. */
  79:../../freeRtos/Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  80:../../freeRtos/Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  81:../../freeRtos/Source/queue.c **** 
  82:../../freeRtos/Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  83:../../freeRtos/Source/queue.c **** #define pxMutexHolder					pcTail
  84:../../freeRtos/Source/queue.c **** #define uxQueueType						pcHead
  85:../../freeRtos/Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  86:../../freeRtos/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  87:../../freeRtos/Source/queue.c **** 
  88:../../freeRtos/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  89:../../freeRtos/Source/queue.c **** zero. */
  90:../../freeRtos/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( 0 )
  91:../../freeRtos/Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0 )
  92:../../freeRtos/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0 )
  93:../../freeRtos/Source/queue.c **** 
  94:../../freeRtos/Source/queue.c **** /*
  95:../../freeRtos/Source/queue.c ****  * Definition of the queue used by the scheduler.
  96:../../freeRtos/Source/queue.c ****  * Items are queued by copy, not reference.
  97:../../freeRtos/Source/queue.c ****  */
  98:../../freeRtos/Source/queue.c **** typedef struct QueueDefinition
  99:../../freeRtos/Source/queue.c **** {
 100:../../freeRtos/Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 101:../../freeRtos/Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 102:../../freeRtos/Source/queue.c **** 
 103:../../freeRtos/Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 104:../../freeRtos/Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 105:../../freeRtos/Source/queue.c **** 
 106:../../freeRtos/Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 107:../../freeRtos/Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 108:../../freeRtos/Source/queue.c **** 
 109:../../freeRtos/Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 110:../../freeRtos/Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 111:../../freeRtos/Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 112:../../freeRtos/Source/queue.c **** 
 113:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 114:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 115:../../freeRtos/Source/queue.c **** 
 116:../../freeRtos/Source/queue.c **** } xQUEUE;
 117:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 118:../../freeRtos/Source/queue.c **** 
 119:../../freeRtos/Source/queue.c **** /*
 120:../../freeRtos/Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 121:../../freeRtos/Source/queue.c ****  * To keep the definition private the API header file defines it as a
 122:../../freeRtos/Source/queue.c ****  * pointer to void.
 123:../../freeRtos/Source/queue.c ****  */
 124:../../freeRtos/Source/queue.c **** typedef xQUEUE * xQueueHandle;
 125:../../freeRtos/Source/queue.c **** 
 126:../../freeRtos/Source/queue.c **** /*
 127:../../freeRtos/Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 128:../../freeRtos/Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 129:../../freeRtos/Source/queue.c ****  * functions are documented in the API header file.
 130:../../freeRtos/Source/queue.c ****  */
 131:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 132:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxI
 133:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 134:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 135:../../freeRtos/Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 136:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 137:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 138:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 139:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
 140:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 141:../../freeRtos/Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 142:../../freeRtos/Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 143:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 144:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 145:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 146:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 147:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 148:../../freeRtos/Source/queue.c **** 
 149:../../freeRtos/Source/queue.c **** /*
 150:../../freeRtos/Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 151:../../freeRtos/Source/queue.c ****  * an optional component.
 152:../../freeRtos/Source/queue.c ****  */
 153:../../freeRtos/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 154:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 155:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 156:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 157:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 158:../../freeRtos/Source/queue.c **** #endif
 159:../../freeRtos/Source/queue.c **** 
 160:../../freeRtos/Source/queue.c **** /*
 161:../../freeRtos/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 162:../../freeRtos/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 163:../../freeRtos/Source/queue.c ****  */
 164:../../freeRtos/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 165:../../freeRtos/Source/queue.c **** 
 166:../../freeRtos/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 167:../../freeRtos/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 168:../../freeRtos/Source/queue.c **** 	more user friendly. */
 169:../../freeRtos/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 170:../../freeRtos/Source/queue.c **** 	{
 171:../../freeRtos/Source/queue.c **** 		signed char *pcQueueName;
 172:../../freeRtos/Source/queue.c **** 		xQueueHandle xHandle;
 173:../../freeRtos/Source/queue.c **** 	} xQueueRegistryItem;
 174:../../freeRtos/Source/queue.c **** 
 175:../../freeRtos/Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 176:../../freeRtos/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 177:../../freeRtos/Source/queue.c **** 	array position being vacant. */
 178:../../freeRtos/Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 179:../../freeRtos/Source/queue.c **** 
 180:../../freeRtos/Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 181:../../freeRtos/Source/queue.c **** 	member to NULL. */
 182:../../freeRtos/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 183:../../freeRtos/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 184:../../freeRtos/Source/queue.c **** #endif
 185:../../freeRtos/Source/queue.c **** 
 186:../../freeRtos/Source/queue.c **** /*
 187:../../freeRtos/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 188:../../freeRtos/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 189:../../freeRtos/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 190:../../freeRtos/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 191:../../freeRtos/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 192:../../freeRtos/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 193:../../freeRtos/Source/queue.c ****  */
 194:../../freeRtos/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 195:../../freeRtos/Source/queue.c **** 
 196:../../freeRtos/Source/queue.c **** /*
 197:../../freeRtos/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 198:../../freeRtos/Source/queue.c ****  *
 199:../../freeRtos/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 200:../../freeRtos/Source/queue.c ****  */
 201:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 202:../../freeRtos/Source/queue.c **** 
 203:../../freeRtos/Source/queue.c **** /*
 204:../../freeRtos/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 205:../../freeRtos/Source/queue.c ****  *
 206:../../freeRtos/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 207:../../freeRtos/Source/queue.c ****  */
 208:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 209:../../freeRtos/Source/queue.c **** 
 210:../../freeRtos/Source/queue.c **** /*
 211:../../freeRtos/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 212:../../freeRtos/Source/queue.c ****  * back of the queue.
 213:../../freeRtos/Source/queue.c ****  */
 214:../../freeRtos/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 215:../../freeRtos/Source/queue.c **** 
 216:../../freeRtos/Source/queue.c **** /*
 217:../../freeRtos/Source/queue.c ****  * Copies an item out of a queue.
 218:../../freeRtos/Source/queue.c ****  */
 219:../../freeRtos/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 220:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 221:../../freeRtos/Source/queue.c **** 
 222:../../freeRtos/Source/queue.c **** /*
 223:../../freeRtos/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 224:../../freeRtos/Source/queue.c ****  * accessing the queue event lists.
 225:../../freeRtos/Source/queue.c ****  */
 226:../../freeRtos/Source/queue.c **** #define prvLockQueue( pxQueue )							\
 227:../../freeRtos/Source/queue.c **** {														\
 228:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();								\
 229:../../freeRtos/Source/queue.c **** 	{													\
 230:../../freeRtos/Source/queue.c **** 		if( pxQueue->xRxLock == queueUNLOCKED )			\
 231:../../freeRtos/Source/queue.c **** 		{												\
 232:../../freeRtos/Source/queue.c **** 			pxQueue->xRxLock = queueLOCKED_UNMODIFIED;	\
 233:../../freeRtos/Source/queue.c **** 		}												\
 234:../../freeRtos/Source/queue.c **** 		if( pxQueue->xTxLock == queueUNLOCKED )			\
 235:../../freeRtos/Source/queue.c **** 		{												\
 236:../../freeRtos/Source/queue.c **** 			pxQueue->xTxLock = queueLOCKED_UNMODIFIED;	\
 237:../../freeRtos/Source/queue.c **** 		}												\
 238:../../freeRtos/Source/queue.c **** 	}													\
 239:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();								\
 240:../../freeRtos/Source/queue.c **** }
 241:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 242:../../freeRtos/Source/queue.c **** 
 243:../../freeRtos/Source/queue.c **** 
 244:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------
 245:../../freeRtos/Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 246:../../freeRtos/Source/queue.c ****  *----------------------------------------------------------*/
 247:../../freeRtos/Source/queue.c **** 
 248:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 249:../../freeRtos/Source/queue.c **** {
 250:../../freeRtos/Source/queue.c **** xQUEUE *pxNewQueue;
 251:../../freeRtos/Source/queue.c **** size_t xQueueSizeInBytes;
 252:../../freeRtos/Source/queue.c **** 
 253:../../freeRtos/Source/queue.c **** 	/* Allocate the new queue structure. */
 254:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 255:../../freeRtos/Source/queue.c **** 	{
 256:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 257:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 258:../../freeRtos/Source/queue.c **** 		{
 259:../../freeRtos/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 260:../../freeRtos/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 261:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 262:../../freeRtos/Source/queue.c **** 
 263:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 264:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 265:../../freeRtos/Source/queue.c **** 			{
 266:../../freeRtos/Source/queue.c **** 				/* Initialise the queue members as described above where the
 267:../../freeRtos/Source/queue.c **** 				queue type is defined. */
 268:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 269:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 270:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 271:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 272:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 273:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 274:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 275:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 276:../../freeRtos/Source/queue.c **** 
 277:../../freeRtos/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 278:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 279:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 280:../../freeRtos/Source/queue.c **** 
 281:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 282:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 283:../../freeRtos/Source/queue.c **** 			}
 284:../../freeRtos/Source/queue.c **** 			else
 285:../../freeRtos/Source/queue.c **** 			{
 286:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 287:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 288:../../freeRtos/Source/queue.c **** 			}
 289:../../freeRtos/Source/queue.c **** 		}
 290:../../freeRtos/Source/queue.c **** 	}
 291:../../freeRtos/Source/queue.c **** 
 292:../../freeRtos/Source/queue.c **** 	/* Will only reach here if we could not allocate enough memory or no memory
 293:../../freeRtos/Source/queue.c **** 	was required. */
 294:../../freeRtos/Source/queue.c **** 	return NULL;
 295:../../freeRtos/Source/queue.c **** }
 296:../../freeRtos/Source/queue.c **** 
 297:../../freeRtos/Source/queue.c **** xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxI
 298:../../freeRtos/Source/queue.c **** {
 299:../../freeRtos/Source/queue.c **** xQUEUE *pxNewQueue;
 300:../../freeRtos/Source/queue.c **** size_t xQueueSizeInBytes;
 301:../../freeRtos/Source/queue.c **** 
 302:../../freeRtos/Source/queue.c **** 	/* Allocate the new queue structure. */
 303:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 304:../../freeRtos/Source/queue.c **** 	{
 305:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 306:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 307:../../freeRtos/Source/queue.c **** 		{
 308:../../freeRtos/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 309:../../freeRtos/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 310:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 311:../../freeRtos/Source/queue.c **** 
 312:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) (address);
 313:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 314:../../freeRtos/Source/queue.c **** 			{
 315:../../freeRtos/Source/queue.c **** 				/* Initialise the queue members as described above where the
 316:../../freeRtos/Source/queue.c **** 				queue type is defined. */
 317:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 318:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 319:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 320:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 321:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 322:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 323:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 324:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 325:../../freeRtos/Source/queue.c **** 
 326:../../freeRtos/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 327:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 328:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 329:../../freeRtos/Source/queue.c **** 
 330:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 331:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 332:../../freeRtos/Source/queue.c **** 			}
 333:../../freeRtos/Source/queue.c **** 			else
 334:../../freeRtos/Source/queue.c **** 			{
 335:../../freeRtos/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 336:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 337:../../freeRtos/Source/queue.c **** 			}
 338:../../freeRtos/Source/queue.c **** 		}
 339:../../freeRtos/Source/queue.c **** 	}
 340:../../freeRtos/Source/queue.c **** 
 341:../../freeRtos/Source/queue.c **** 	/* Will only reach here if we could not allocate enough memory or no memory
 342:../../freeRtos/Source/queue.c **** 	was required. */
 343:../../freeRtos/Source/queue.c **** 	return NULL;
 344:../../freeRtos/Source/queue.c **** }
 345:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 346:../../freeRtos/Source/queue.c **** 
 347:../../freeRtos/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 348:../../freeRtos/Source/queue.c **** 
 349:../../freeRtos/Source/queue.c **** 	xQueueHandle xQueueCreateMutex( void )
 350:../../freeRtos/Source/queue.c **** 	{
 351:../../freeRtos/Source/queue.c **** 	xQUEUE *pxNewQueue;
 352:../../freeRtos/Source/queue.c **** 
 353:../../freeRtos/Source/queue.c **** 		/* Allocate the new queue structure. */
 354:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 355:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 356:../../freeRtos/Source/queue.c **** 		{
 357:../../freeRtos/Source/queue.c **** 			/* Information required for priority inheritance. */
 358:../../freeRtos/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 359:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 360:../../freeRtos/Source/queue.c **** 
 361:../../freeRtos/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 362:../../freeRtos/Source/queue.c **** 			of the queue. */
 363:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 364:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 365:../../freeRtos/Source/queue.c **** 
 366:../../freeRtos/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 367:../../freeRtos/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 368:../../freeRtos/Source/queue.c **** 			of the mutex. */
 369:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = 0;
 370:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxLength = 1;
 371:../../freeRtos/Source/queue.c **** 			pxNewQueue->uxItemSize = 0;
 372:../../freeRtos/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 373:../../freeRtos/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 374:../../freeRtos/Source/queue.c **** 
 375:../../freeRtos/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 376:../../freeRtos/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 377:../../freeRtos/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 378:../../freeRtos/Source/queue.c **** 
 379:../../freeRtos/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 380:../../freeRtos/Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, 0, queueSEND_TO_BACK );
 381:../../freeRtos/Source/queue.c **** 
 382:../../freeRtos/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 383:../../freeRtos/Source/queue.c **** 		}
 384:../../freeRtos/Source/queue.c **** 		else
 385:../../freeRtos/Source/queue.c **** 		{
 386:../../freeRtos/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 387:../../freeRtos/Source/queue.c **** 		}
 388:../../freeRtos/Source/queue.c **** 
 389:../../freeRtos/Source/queue.c **** 		return pxNewQueue;
 390:../../freeRtos/Source/queue.c **** 	}
 391:../../freeRtos/Source/queue.c **** 
 392:../../freeRtos/Source/queue.c **** #endif /* configUSE_MUTEXES */
 393:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 394:../../freeRtos/Source/queue.c **** 
 395:../../freeRtos/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 396:../../freeRtos/Source/queue.c **** 
 397:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 398:../../freeRtos/Source/queue.c **** 	{
 399:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xReturn;
 400:../../freeRtos/Source/queue.c **** 
 401:../../freeRtos/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 402:../../freeRtos/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 403:../../freeRtos/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 404:../../freeRtos/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 405:../../freeRtos/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 406:../../freeRtos/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 407:../../freeRtos/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 408:../../freeRtos/Source/queue.c **** 		{
 409:../../freeRtos/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 410:../../freeRtos/Source/queue.c **** 
 411:../../freeRtos/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 412:../../freeRtos/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 413:../../freeRtos/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 414:../../freeRtos/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 415:../../freeRtos/Source/queue.c **** 			uxRecursiveCallCount member. */
 416:../../freeRtos/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 417:../../freeRtos/Source/queue.c **** 
 418:../../freeRtos/Source/queue.c **** 			/* Have we unwound the call count? */
 419:../../freeRtos/Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 420:../../freeRtos/Source/queue.c **** 			{
 421:../../freeRtos/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 422:../../freeRtos/Source/queue.c **** 				task that might be waiting to access the mutex. */
 423:../../freeRtos/Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 424:../../freeRtos/Source/queue.c **** 			}
 425:../../freeRtos/Source/queue.c **** 
 426:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 427:../../freeRtos/Source/queue.c **** 		}
 428:../../freeRtos/Source/queue.c **** 		else
 429:../../freeRtos/Source/queue.c **** 		{
 430:../../freeRtos/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 431:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
 432:../../freeRtos/Source/queue.c **** 
 433:../../freeRtos/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 434:../../freeRtos/Source/queue.c **** 		}
 435:../../freeRtos/Source/queue.c **** 
 436:../../freeRtos/Source/queue.c **** 		return xReturn;
 437:../../freeRtos/Source/queue.c **** 	}
 438:../../freeRtos/Source/queue.c **** 
 439:../../freeRtos/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 440:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 441:../../freeRtos/Source/queue.c **** 
 442:../../freeRtos/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 443:../../freeRtos/Source/queue.c **** 
 444:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 445:../../freeRtos/Source/queue.c **** 	{
 446:../../freeRtos/Source/queue.c **** 	portBASE_TYPE xReturn;
 447:../../freeRtos/Source/queue.c **** 
 448:../../freeRtos/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 449:../../freeRtos/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 450:../../freeRtos/Source/queue.c **** 
 451:../../freeRtos/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 452:../../freeRtos/Source/queue.c **** 
 453:../../freeRtos/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 454:../../freeRtos/Source/queue.c **** 		{
 455:../../freeRtos/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 456:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 457:../../freeRtos/Source/queue.c **** 		}
 458:../../freeRtos/Source/queue.c **** 		else
 459:../../freeRtos/Source/queue.c **** 		{
 460:../../freeRtos/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 461:../../freeRtos/Source/queue.c **** 
 462:../../freeRtos/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 463:../../freeRtos/Source/queue.c **** 			we may have blocked to reach here. */
 464:../../freeRtos/Source/queue.c **** 			if( xReturn == pdPASS )
 465:../../freeRtos/Source/queue.c **** 			{
 466:../../freeRtos/Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 467:../../freeRtos/Source/queue.c **** 			}
 468:../../freeRtos/Source/queue.c **** 		}
 469:../../freeRtos/Source/queue.c **** 
 470:../../freeRtos/Source/queue.c **** 		return xReturn;
 471:../../freeRtos/Source/queue.c **** 	}
 472:../../freeRtos/Source/queue.c **** 
 473:../../freeRtos/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 474:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 475:../../freeRtos/Source/queue.c **** 
 476:../../freeRtos/Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 477:../../freeRtos/Source/queue.c **** 
 478:../../freeRtos/Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 479:../../freeRtos/Source/queue.c **** 	{
 480:../../freeRtos/Source/queue.c **** 	xQueueHandle pxHandle;
 481:../../freeRtos/Source/queue.c **** 
 482:../../freeRtos/Source/queue.c **** 		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGT
 483:../../freeRtos/Source/queue.c **** 
 484:../../freeRtos/Source/queue.c **** 		if( pxHandle != NULL )
 485:../../freeRtos/Source/queue.c **** 		{
 486:../../freeRtos/Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 487:../../freeRtos/Source/queue.c **** 
 488:../../freeRtos/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 489:../../freeRtos/Source/queue.c **** 		}
 490:../../freeRtos/Source/queue.c **** 		else
 491:../../freeRtos/Source/queue.c **** 		{
 492:../../freeRtos/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 493:../../freeRtos/Source/queue.c **** 		}
 494:../../freeRtos/Source/queue.c **** 
 495:../../freeRtos/Source/queue.c **** 		return pxHandle;
 496:../../freeRtos/Source/queue.c **** 	}
 497:../../freeRtos/Source/queue.c **** 
 498:../../freeRtos/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 499:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 500:../../freeRtos/Source/queue.c **** 
 501:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 502:../../freeRtos/Source/queue.c **** {
 503:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 504:../../freeRtos/Source/queue.c **** xTimeOutType xTimeOut;
 505:../../freeRtos/Source/queue.c **** 
 506:../../freeRtos/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:../../freeRtos/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 508:../../freeRtos/Source/queue.c **** 	of execution time efficiency. */
 509:../../freeRtos/Source/queue.c **** 	for( ;; )
 510:../../freeRtos/Source/queue.c **** 	{
 511:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 512:../../freeRtos/Source/queue.c **** 		{
 513:../../freeRtos/Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:../../freeRtos/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 515:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:../../freeRtos/Source/queue.c **** 			{
 517:../../freeRtos/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:../../freeRtos/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:../../freeRtos/Source/queue.c **** 
 520:../../freeRtos/Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:../../freeRtos/Source/queue.c **** 				queue then unblock it now. */
 522:../../freeRtos/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:../../freeRtos/Source/queue.c **** 				{
 524:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:../../freeRtos/Source/queue.c **** 					{
 526:../../freeRtos/Source/queue.c **** 						/* The unblocked task has a priority higher than
 527:../../freeRtos/Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:../../freeRtos/Source/queue.c **** 						this from within the critical section - the kernel
 529:../../freeRtos/Source/queue.c **** 						takes care of that. */
 530:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 531:../../freeRtos/Source/queue.c **** 					}
 532:../../freeRtos/Source/queue.c **** 				}
 533:../../freeRtos/Source/queue.c **** 
 534:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 535:../../freeRtos/Source/queue.c **** 
 536:../../freeRtos/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 537:../../freeRtos/Source/queue.c **** 				function. */
 538:../../freeRtos/Source/queue.c **** 				return pdPASS;
 539:../../freeRtos/Source/queue.c **** 			}
 540:../../freeRtos/Source/queue.c **** 			else
 541:../../freeRtos/Source/queue.c **** 			{
 542:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:../../freeRtos/Source/queue.c **** 				{
 544:../../freeRtos/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 545:../../freeRtos/Source/queue.c **** 					the block time has expired) so leave now. */
 546:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 547:../../freeRtos/Source/queue.c **** 
 548:../../freeRtos/Source/queue.c **** 					/* Return to the original privilege level before exiting
 549:../../freeRtos/Source/queue.c **** 					the function. */
 550:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:../../freeRtos/Source/queue.c **** 					return errQUEUE_FULL;
 552:../../freeRtos/Source/queue.c **** 				}
 553:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:../../freeRtos/Source/queue.c **** 				{
 555:../../freeRtos/Source/queue.c **** 					/* The queue was full and a block time was specified so
 556:../../freeRtos/Source/queue.c **** 					configure the timeout structure. */
 557:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:../../freeRtos/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:../../freeRtos/Source/queue.c **** 				}
 560:../../freeRtos/Source/queue.c **** 			}
 561:../../freeRtos/Source/queue.c **** 		}
 562:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 563:../../freeRtos/Source/queue.c **** 
 564:../../freeRtos/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:../../freeRtos/Source/queue.c **** 		now the critical section has been exited. */
 566:../../freeRtos/Source/queue.c **** 
 567:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 569:../../freeRtos/Source/queue.c **** 
 570:../../freeRtos/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:../../freeRtos/Source/queue.c **** 		{
 573:../../freeRtos/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) )
 574:../../freeRtos/Source/queue.c **** 			{
 575:../../freeRtos/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:../../freeRtos/Source/queue.c **** 
 578:../../freeRtos/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:../../freeRtos/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:../../freeRtos/Source/queue.c **** 				remove this task from the event	list again - but as the
 581:../../freeRtos/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:../../freeRtos/Source/queue.c **** 				ready last instead of the actual ready list. */
 583:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 584:../../freeRtos/Source/queue.c **** 
 585:../../freeRtos/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:../../freeRtos/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:../../freeRtos/Source/queue.c **** 				task is already in a ready list before it yields - in which
 588:../../freeRtos/Source/queue.c **** 				case the yield will not cause a context switch unless there
 589:../../freeRtos/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 591:../../freeRtos/Source/queue.c **** 				{
 592:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 593:../../freeRtos/Source/queue.c **** 				}
 594:../../freeRtos/Source/queue.c **** 			}
 595:../../freeRtos/Source/queue.c **** 			else
 596:../../freeRtos/Source/queue.c **** 			{
 597:../../freeRtos/Source/queue.c **** 				/* Try again. */
 598:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 599:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 600:../../freeRtos/Source/queue.c **** 			}
 601:../../freeRtos/Source/queue.c **** 		}
 602:../../freeRtos/Source/queue.c **** 		else
 603:../../freeRtos/Source/queue.c **** 		{
 604:../../freeRtos/Source/queue.c **** 			/* The timeout has expired. */
 605:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 606:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 607:../../freeRtos/Source/queue.c **** 
 608:../../freeRtos/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 609:../../freeRtos/Source/queue.c **** 			function. */
 610:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:../../freeRtos/Source/queue.c **** 			return errQUEUE_FULL;
 612:../../freeRtos/Source/queue.c **** 		}
 613:../../freeRtos/Source/queue.c **** 	}
 614:../../freeRtos/Source/queue.c **** }
 615:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 616:../../freeRtos/Source/queue.c **** 
 617:../../freeRtos/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:../../freeRtos/Source/queue.c **** 
 619:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:../../freeRtos/Source/queue.c **** 	{
 621:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:../../freeRtos/Source/queue.c **** 	xTimeOutType xTimeOut;
 623:../../freeRtos/Source/queue.c **** 
 624:../../freeRtos/Source/queue.c **** 		for( ;; )
 625:../../freeRtos/Source/queue.c **** 		{
 626:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 627:../../freeRtos/Source/queue.c **** 			{
 628:../../freeRtos/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 629:../../freeRtos/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 630:../../freeRtos/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 631:../../freeRtos/Source/queue.c **** 				{
 632:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 633:../../freeRtos/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 634:../../freeRtos/Source/queue.c **** 
 635:../../freeRtos/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 636:../../freeRtos/Source/queue.c **** 					queue then unblock it now. */
 637:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 638:../../freeRtos/Source/queue.c **** 					{
 639:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 640:../../freeRtos/Source/queue.c **** 						{
 641:../../freeRtos/Source/queue.c **** 							/* The unblocked task has a priority higher than
 642:../../freeRtos/Source/queue.c **** 							our own so yield immediately. */
 643:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 644:../../freeRtos/Source/queue.c **** 						}
 645:../../freeRtos/Source/queue.c **** 					}
 646:../../freeRtos/Source/queue.c **** 
 647:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 648:../../freeRtos/Source/queue.c **** 					return pdPASS;
 649:../../freeRtos/Source/queue.c **** 				}
 650:../../freeRtos/Source/queue.c **** 				else
 651:../../freeRtos/Source/queue.c **** 				{
 652:../../freeRtos/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 653:../../freeRtos/Source/queue.c **** 					{
 654:../../freeRtos/Source/queue.c **** 						taskEXIT_CRITICAL();
 655:../../freeRtos/Source/queue.c **** 						return errQUEUE_FULL;
 656:../../freeRtos/Source/queue.c **** 					}
 657:../../freeRtos/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 658:../../freeRtos/Source/queue.c **** 					{
 659:../../freeRtos/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 660:../../freeRtos/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 661:../../freeRtos/Source/queue.c **** 					}
 662:../../freeRtos/Source/queue.c **** 				}
 663:../../freeRtos/Source/queue.c **** 			}
 664:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 665:../../freeRtos/Source/queue.c **** 
 666:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 667:../../freeRtos/Source/queue.c **** 			{
 668:../../freeRtos/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 669:../../freeRtos/Source/queue.c **** 				{
 670:../../freeRtos/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) )
 671:../../freeRtos/Source/queue.c **** 					{
 672:../../freeRtos/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 673:../../freeRtos/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 674:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 675:../../freeRtos/Source/queue.c **** 					}
 676:../../freeRtos/Source/queue.c **** 				}
 677:../../freeRtos/Source/queue.c **** 				else
 678:../../freeRtos/Source/queue.c **** 				{
 679:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 680:../../freeRtos/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 681:../../freeRtos/Source/queue.c **** 					return errQUEUE_FULL;
 682:../../freeRtos/Source/queue.c **** 				}
 683:../../freeRtos/Source/queue.c **** 			}
 684:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 685:../../freeRtos/Source/queue.c **** 		}
 686:../../freeRtos/Source/queue.c **** 	}
 687:../../freeRtos/Source/queue.c **** 
 688:../../freeRtos/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 689:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 690:../../freeRtos/Source/queue.c **** 
 691:../../freeRtos/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 692:../../freeRtos/Source/queue.c **** 
 693:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 694:../../freeRtos/Source/queue.c **** 	{
 695:../../freeRtos/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 696:../../freeRtos/Source/queue.c **** 	xTimeOutType xTimeOut;
 697:../../freeRtos/Source/queue.c **** 	signed char *pcOriginalReadPosition;
 698:../../freeRtos/Source/queue.c **** 
 699:../../freeRtos/Source/queue.c **** 		for( ;; )
 700:../../freeRtos/Source/queue.c **** 		{
 701:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 702:../../freeRtos/Source/queue.c **** 			{
 703:../../freeRtos/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 704:../../freeRtos/Source/queue.c **** 				{
 705:../../freeRtos/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 706:../../freeRtos/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 707:../../freeRtos/Source/queue.c **** 
 708:../../freeRtos/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 709:../../freeRtos/Source/queue.c **** 
 710:../../freeRtos/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 711:../../freeRtos/Source/queue.c **** 					{
 712:../../freeRtos/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 713:../../freeRtos/Source/queue.c **** 
 714:../../freeRtos/Source/queue.c **** 						/* We are actually removing data. */
 715:../../freeRtos/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 716:../../freeRtos/Source/queue.c **** 
 717:../../freeRtos/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 718:../../freeRtos/Source/queue.c **** 						{
 719:../../freeRtos/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 720:../../freeRtos/Source/queue.c **** 							{
 721:../../freeRtos/Source/queue.c **** 								/* Record the information required to implement
 722:../../freeRtos/Source/queue.c **** 								priority inheritance should it become necessary. */
 723:../../freeRtos/Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 724:../../freeRtos/Source/queue.c **** 							}
 725:../../freeRtos/Source/queue.c **** 						}
 726:../../freeRtos/Source/queue.c **** 						#endif
 727:../../freeRtos/Source/queue.c **** 
 728:../../freeRtos/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 729:../../freeRtos/Source/queue.c **** 						{
 730:../../freeRtos/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 731:../../freeRtos/Source/queue.c **** 							{
 732:../../freeRtos/Source/queue.c **** 								portYIELD_WITHIN_API();
 733:../../freeRtos/Source/queue.c **** 							}
 734:../../freeRtos/Source/queue.c **** 						}
 735:../../freeRtos/Source/queue.c **** 					}
 736:../../freeRtos/Source/queue.c **** 					else
 737:../../freeRtos/Source/queue.c **** 					{
 738:../../freeRtos/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 739:../../freeRtos/Source/queue.c **** 
 740:../../freeRtos/Source/queue.c **** 						/* We are not removing the data, so reset our read
 741:../../freeRtos/Source/queue.c **** 						pointer. */
 742:../../freeRtos/Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 743:../../freeRtos/Source/queue.c **** 
 744:../../freeRtos/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 745:../../freeRtos/Source/queue.c **** 						any other tasks waiting for the data. */
 746:../../freeRtos/Source/queue.c **** 						if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 747:../../freeRtos/Source/queue.c **** 						{
 748:../../freeRtos/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 749:../../freeRtos/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 750:../../freeRtos/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 751:../../freeRtos/Source/queue.c **** 							{
 752:../../freeRtos/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 753:../../freeRtos/Source/queue.c **** 								portYIELD_WITHIN_API();
 754:../../freeRtos/Source/queue.c **** 							}
 755:../../freeRtos/Source/queue.c **** 						}
 756:../../freeRtos/Source/queue.c **** 
 757:../../freeRtos/Source/queue.c **** 					}
 758:../../freeRtos/Source/queue.c **** 
 759:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 760:../../freeRtos/Source/queue.c **** 					return pdPASS;
 761:../../freeRtos/Source/queue.c **** 				}
 762:../../freeRtos/Source/queue.c **** 				else
 763:../../freeRtos/Source/queue.c **** 				{
 764:../../freeRtos/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 765:../../freeRtos/Source/queue.c **** 					{
 766:../../freeRtos/Source/queue.c **** 						taskEXIT_CRITICAL();
 767:../../freeRtos/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 768:../../freeRtos/Source/queue.c **** 						return errQUEUE_EMPTY;
 769:../../freeRtos/Source/queue.c **** 					}
 770:../../freeRtos/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 771:../../freeRtos/Source/queue.c **** 					{
 772:../../freeRtos/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 773:../../freeRtos/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 774:../../freeRtos/Source/queue.c **** 					}
 775:../../freeRtos/Source/queue.c **** 				}
 776:../../freeRtos/Source/queue.c **** 			}
 777:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 778:../../freeRtos/Source/queue.c **** 
 779:../../freeRtos/Source/queue.c **** 			taskENTER_CRITICAL();
 780:../../freeRtos/Source/queue.c **** 			{
 781:../../freeRtos/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 782:../../freeRtos/Source/queue.c **** 				{
 783:../../freeRtos/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) )
 784:../../freeRtos/Source/queue.c **** 					{
 785:../../freeRtos/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 786:../../freeRtos/Source/queue.c **** 
 787:../../freeRtos/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 788:../../freeRtos/Source/queue.c **** 						{
 789:../../freeRtos/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 790:../../freeRtos/Source/queue.c **** 							{
 791:../../freeRtos/Source/queue.c **** 								portENTER_CRITICAL();
 792:../../freeRtos/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 793:../../freeRtos/Source/queue.c **** 								portEXIT_CRITICAL();
 794:../../freeRtos/Source/queue.c **** 							}
 795:../../freeRtos/Source/queue.c **** 						}
 796:../../freeRtos/Source/queue.c **** 						#endif
 797:../../freeRtos/Source/queue.c **** 
 798:../../freeRtos/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 799:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 800:../../freeRtos/Source/queue.c **** 					}
 801:../../freeRtos/Source/queue.c **** 				}
 802:../../freeRtos/Source/queue.c **** 				else
 803:../../freeRtos/Source/queue.c **** 				{
 804:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 805:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 806:../../freeRtos/Source/queue.c **** 					return errQUEUE_EMPTY;
 807:../../freeRtos/Source/queue.c **** 				}
 808:../../freeRtos/Source/queue.c **** 			}
 809:../../freeRtos/Source/queue.c **** 			taskEXIT_CRITICAL();
 810:../../freeRtos/Source/queue.c **** 		}
 811:../../freeRtos/Source/queue.c **** 	}
 812:../../freeRtos/Source/queue.c **** 
 813:../../freeRtos/Source/queue.c **** 
 814:../../freeRtos/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 815:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 816:../../freeRtos/Source/queue.c **** 
 817:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 818:../../freeRtos/Source/queue.c **** {
 819:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
 820:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 821:../../freeRtos/Source/queue.c **** 
 822:../../freeRtos/Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 823:../../freeRtos/Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 824:../../freeRtos/Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 825:../../freeRtos/Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 826:../../freeRtos/Source/queue.c **** 	by this	post). */
 827:../../freeRtos/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 828:../../freeRtos/Source/queue.c **** 	{
 829:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 830:../../freeRtos/Source/queue.c **** 		{
 831:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 832:../../freeRtos/Source/queue.c **** 
 833:../../freeRtos/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 834:../../freeRtos/Source/queue.c **** 
 835:../../freeRtos/Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 836:../../freeRtos/Source/queue.c **** 			be done when the queue is unlocked later. */
 837:../../freeRtos/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 838:../../freeRtos/Source/queue.c **** 			{
 839:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 840:../../freeRtos/Source/queue.c **** 				{
 841:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 842:../../freeRtos/Source/queue.c **** 					{
 843:../../freeRtos/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 844:../../freeRtos/Source/queue.c **** 						context	switch is required. */
 845:../../freeRtos/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 846:../../freeRtos/Source/queue.c **** 					}
 847:../../freeRtos/Source/queue.c **** 				}
 848:../../freeRtos/Source/queue.c **** 			}
 849:../../freeRtos/Source/queue.c **** 			else
 850:../../freeRtos/Source/queue.c **** 			{
 851:../../freeRtos/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 852:../../freeRtos/Source/queue.c **** 				knows that data was posted while it was locked. */
 853:../../freeRtos/Source/queue.c **** 				++( pxQueue->xTxLock );
 854:../../freeRtos/Source/queue.c **** 			}
 855:../../freeRtos/Source/queue.c **** 
 856:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 857:../../freeRtos/Source/queue.c **** 		}
 858:../../freeRtos/Source/queue.c **** 		else
 859:../../freeRtos/Source/queue.c **** 		{
 860:../../freeRtos/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 861:../../freeRtos/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 862:../../freeRtos/Source/queue.c **** 		}
 863:../../freeRtos/Source/queue.c **** 	}
 864:../../freeRtos/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 865:../../freeRtos/Source/queue.c **** 
 866:../../freeRtos/Source/queue.c **** 	return xReturn;
 867:../../freeRtos/Source/queue.c **** }
 868:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
 869:../../freeRtos/Source/queue.c **** 
 870:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 871:../../freeRtos/Source/queue.c **** {
 872:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 873:../../freeRtos/Source/queue.c **** xTimeOutType xTimeOut;
 874:../../freeRtos/Source/queue.c **** signed char *pcOriginalReadPosition;
 875:../../freeRtos/Source/queue.c **** 
 876:../../freeRtos/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 877:../../freeRtos/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 878:../../freeRtos/Source/queue.c **** 	of execution time efficiency. */
 879:../../freeRtos/Source/queue.c **** 
 880:../../freeRtos/Source/queue.c **** 	for( ;; )
 881:../../freeRtos/Source/queue.c **** 	{
 882:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 883:../../freeRtos/Source/queue.c **** 		{
 884:../../freeRtos/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 885:../../freeRtos/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 886:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 887:../../freeRtos/Source/queue.c **** 			{
 888:../../freeRtos/Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 889:../../freeRtos/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 890:../../freeRtos/Source/queue.c **** 
 891:../../freeRtos/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 892:../../freeRtos/Source/queue.c **** 
 893:../../freeRtos/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 894:../../freeRtos/Source/queue.c **** 				{
 895:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 896:../../freeRtos/Source/queue.c **** 
 897:../../freeRtos/Source/queue.c **** 					/* We are actually removing data. */
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 899:../../freeRtos/Source/queue.c **** 
 900:../../freeRtos/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 901:../../freeRtos/Source/queue.c **** 					{
 902:../../freeRtos/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 903:../../freeRtos/Source/queue.c **** 						{
 904:../../freeRtos/Source/queue.c **** 							/* Record the information required to implement
 905:../../freeRtos/Source/queue.c **** 							priority inheritance should it become necessary. */
 906:../../freeRtos/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 907:../../freeRtos/Source/queue.c **** 						}
 908:../../freeRtos/Source/queue.c **** 					}
 909:../../freeRtos/Source/queue.c **** 					#endif
 910:../../freeRtos/Source/queue.c **** 
 911:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 912:../../freeRtos/Source/queue.c **** 					{
 913:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 914:../../freeRtos/Source/queue.c **** 						{
 915:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 916:../../freeRtos/Source/queue.c **** 						}
 917:../../freeRtos/Source/queue.c **** 					}
 918:../../freeRtos/Source/queue.c **** 				}
 919:../../freeRtos/Source/queue.c **** 				else
 920:../../freeRtos/Source/queue.c **** 				{
 921:../../freeRtos/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 922:../../freeRtos/Source/queue.c **** 
 923:../../freeRtos/Source/queue.c **** 					/* We are not removing the data, so reset our read
 924:../../freeRtos/Source/queue.c **** 					pointer. */
 925:../../freeRtos/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 926:../../freeRtos/Source/queue.c **** 
 927:../../freeRtos/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 928:../../freeRtos/Source/queue.c **** 					any other tasks waiting for the data. */
 929:../../freeRtos/Source/queue.c **** 					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 930:../../freeRtos/Source/queue.c **** 					{
 931:../../freeRtos/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 932:../../freeRtos/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 933:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 934:../../freeRtos/Source/queue.c **** 						{
 935:../../freeRtos/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 936:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 937:../../freeRtos/Source/queue.c **** 						}
 938:../../freeRtos/Source/queue.c **** 					}
 939:../../freeRtos/Source/queue.c **** 
 940:../../freeRtos/Source/queue.c **** 				}
 941:../../freeRtos/Source/queue.c **** 
 942:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 943:../../freeRtos/Source/queue.c **** 				return pdPASS;
 944:../../freeRtos/Source/queue.c **** 			}
 945:../../freeRtos/Source/queue.c **** 			else
 946:../../freeRtos/Source/queue.c **** 			{
 947:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 948:../../freeRtos/Source/queue.c **** 				{
 949:../../freeRtos/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 950:../../freeRtos/Source/queue.c **** 					the block time has expired) so leave now. */
 951:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 952:../../freeRtos/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 953:../../freeRtos/Source/queue.c **** 					return errQUEUE_EMPTY;
 954:../../freeRtos/Source/queue.c **** 				}
 955:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 956:../../freeRtos/Source/queue.c **** 				{
 957:../../freeRtos/Source/queue.c **** 					/* The queue was empty and a block time was specified so
 958:../../freeRtos/Source/queue.c **** 					configure the timeout structure. */
 959:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 960:../../freeRtos/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 961:../../freeRtos/Source/queue.c **** 				}
 962:../../freeRtos/Source/queue.c **** 			}
 963:../../freeRtos/Source/queue.c **** 		}
 964:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 965:../../freeRtos/Source/queue.c **** 
 966:../../freeRtos/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 967:../../freeRtos/Source/queue.c **** 		now the critical section has been exited. */
 968:../../freeRtos/Source/queue.c **** 
 969:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 971:../../freeRtos/Source/queue.c **** 
 972:../../freeRtos/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 973:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 974:../../freeRtos/Source/queue.c **** 		{
 975:../../freeRtos/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) )
 976:../../freeRtos/Source/queue.c **** 			{
 977:../../freeRtos/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 978:../../freeRtos/Source/queue.c **** 
 979:../../freeRtos/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 980:../../freeRtos/Source/queue.c **** 				{
 981:../../freeRtos/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 982:../../freeRtos/Source/queue.c **** 					{
 983:../../freeRtos/Source/queue.c **** 						portENTER_CRITICAL();
 984:../../freeRtos/Source/queue.c **** 						{
 985:../../freeRtos/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 986:../../freeRtos/Source/queue.c **** 						}
 987:../../freeRtos/Source/queue.c **** 						portEXIT_CRITICAL();
 988:../../freeRtos/Source/queue.c **** 					}
 989:../../freeRtos/Source/queue.c **** 				}
 990:../../freeRtos/Source/queue.c **** 				#endif
 991:../../freeRtos/Source/queue.c **** 
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 993:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 994:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 995:../../freeRtos/Source/queue.c **** 				{
 996:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 997:../../freeRtos/Source/queue.c **** 				}
 998:../../freeRtos/Source/queue.c **** 			}
 999:../../freeRtos/Source/queue.c **** 			else
1000:../../freeRtos/Source/queue.c **** 			{
1001:../../freeRtos/Source/queue.c **** 				/* Try again. */
1002:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1003:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
1004:../../freeRtos/Source/queue.c **** 			}
1005:../../freeRtos/Source/queue.c **** 		}
1006:../../freeRtos/Source/queue.c **** 		else
1007:../../freeRtos/Source/queue.c **** 		{
1008:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1009:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
1010:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1011:../../freeRtos/Source/queue.c **** 			return errQUEUE_EMPTY;
1012:../../freeRtos/Source/queue.c **** 		}
1013:../../freeRtos/Source/queue.c **** 	}
1014:../../freeRtos/Source/queue.c **** }
1015:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1016:../../freeRtos/Source/queue.c **** 
1017:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1018:../../freeRtos/Source/queue.c **** {
1019:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1020:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1021:../../freeRtos/Source/queue.c **** 
1022:../../freeRtos/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1023:../../freeRtos/Source/queue.c **** 	{
1024:../../freeRtos/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1025:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1026:../../freeRtos/Source/queue.c **** 		{
1027:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1028:../../freeRtos/Source/queue.c **** 
1029:../../freeRtos/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1030:../../freeRtos/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1031:../../freeRtos/Source/queue.c **** 
1032:../../freeRtos/Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1033:../../freeRtos/Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1034:../../freeRtos/Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1035:../../freeRtos/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
1036:../../freeRtos/Source/queue.c **** 			{
1037:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
1038:../../freeRtos/Source/queue.c **** 				{
1039:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1040:../../freeRtos/Source/queue.c **** 					{
1041:../../freeRtos/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1042:../../freeRtos/Source/queue.c **** 						force a context switch. */
1043:../../freeRtos/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
1044:../../freeRtos/Source/queue.c **** 					}
1045:../../freeRtos/Source/queue.c **** 				}
1046:../../freeRtos/Source/queue.c **** 			}
1047:../../freeRtos/Source/queue.c **** 			else
1048:../../freeRtos/Source/queue.c **** 			{
1049:../../freeRtos/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1050:../../freeRtos/Source/queue.c **** 				knows that data was removed while it was locked. */
1051:../../freeRtos/Source/queue.c **** 				++( pxQueue->xRxLock );
1052:../../freeRtos/Source/queue.c **** 			}
1053:../../freeRtos/Source/queue.c **** 
1054:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
1055:../../freeRtos/Source/queue.c **** 		}
1056:../../freeRtos/Source/queue.c **** 		else
1057:../../freeRtos/Source/queue.c **** 		{
1058:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
1059:../../freeRtos/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1060:../../freeRtos/Source/queue.c **** 		}
1061:../../freeRtos/Source/queue.c **** 	}
1062:../../freeRtos/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1063:../../freeRtos/Source/queue.c **** 
1064:../../freeRtos/Source/queue.c **** 	return xReturn;
1065:../../freeRtos/Source/queue.c **** }
1066:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1067:../../freeRtos/Source/queue.c **** 
1068:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1069:../../freeRtos/Source/queue.c **** {
1070:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1071:../../freeRtos/Source/queue.c **** 
1072:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
1073:../../freeRtos/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
1074:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
1075:../../freeRtos/Source/queue.c **** 
1076:../../freeRtos/Source/queue.c **** 	return uxReturn;
1077:../../freeRtos/Source/queue.c **** }
1078:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1079:../../freeRtos/Source/queue.c **** 
1080:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1081:../../freeRtos/Source/queue.c **** {
1082:../../freeRtos/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1083:../../freeRtos/Source/queue.c **** 
1084:../../freeRtos/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1085:../../freeRtos/Source/queue.c **** 
1086:../../freeRtos/Source/queue.c **** 	return uxReturn;
1087:../../freeRtos/Source/queue.c **** }
1088:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1089:../../freeRtos/Source/queue.c **** 
1090:../../freeRtos/Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1091:../../freeRtos/Source/queue.c **** {
1092:../../freeRtos/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1093:../../freeRtos/Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1094:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
1096:../../freeRtos/Source/queue.c **** }
1097:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1098:../../freeRtos/Source/queue.c **** 
1099:../../freeRtos/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1100:../../freeRtos/Source/queue.c **** {
 489               	.LM0:
 490               	.LFBB1:
 491 0000 CF93      		push r28
 492 0002 DF93      		push r29
 493               	/* prologue: function */
 494               	/* frame size = 0 */
 495               	/* stack size = 2 */
 496               	.L__stack_usage = 2
 497 0004 EC01      		movw r28,r24
 498 0006 942F      		mov r25,r20
1101:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 500               	.LM1:
 501 0008 8C8D      		ldd r24,Y+28
 502 000a 8823      		tst r24
 503 000c 01F0      		breq .L3
 504 000e 482F      		mov r20,r24
 505 0010 50E0      		ldi r21,0
1102:../../freeRtos/Source/queue.c **** 	{
1103:../../freeRtos/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1104:../../freeRtos/Source/queue.c **** 		{
1105:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1106:../../freeRtos/Source/queue.c **** 			{
1107:../../freeRtos/Source/queue.c **** 				/* The mutex is no longer being held. */
1108:../../freeRtos/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1109:../../freeRtos/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
1110:../../freeRtos/Source/queue.c **** 			}
1111:../../freeRtos/Source/queue.c **** 		}
1112:../../freeRtos/Source/queue.c **** 		#endif
1113:../../freeRtos/Source/queue.c **** 	}
1114:../../freeRtos/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 507               	.LM2:
 508 0012 9111      		cpse r25,__zero_reg__
 509 0014 00C0      		rjmp .L4
1115:../../freeRtos/Source/queue.c **** 	{
1116:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 511               	.LM3:
 512 0016 8C81      		ldd r24,Y+4
 513 0018 9D81      		ldd r25,Y+5
 514 001a 0E94 0000 		call memcpy
1117:../../freeRtos/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 516               	.LM4:
 517 001e 2C8D      		ldd r18,Y+28
 518 0020 8C81      		ldd r24,Y+4
 519 0022 9D81      		ldd r25,Y+5
 520 0024 820F      		add r24,r18
 521 0026 911D      		adc r25,__zero_reg__
 522 0028 8C83      		std Y+4,r24
 523 002a 9D83      		std Y+5,r25
1118:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 525               	.LM5:
 526 002c 2A81      		ldd r18,Y+2
 527 002e 3B81      		ldd r19,Y+3
 528 0030 8217      		cp r24,r18
 529 0032 9307      		cpc r25,r19
 530 0034 00F0      		brlo .L3
1119:../../freeRtos/Source/queue.c **** 		{
1120:../../freeRtos/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 532               	.LM6:
 533 0036 8881      		ld r24,Y
 534 0038 9981      		ldd r25,Y+1
 535 003a 8C83      		std Y+4,r24
 536 003c 9D83      		std Y+5,r25
 537 003e 00C0      		rjmp .L3
 538               	.L4:
1121:../../freeRtos/Source/queue.c **** 		}
1122:../../freeRtos/Source/queue.c **** 	}
1123:../../freeRtos/Source/queue.c **** 	else
1124:../../freeRtos/Source/queue.c **** 	{
1125:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 540               	.LM7:
 541 0040 8E81      		ldd r24,Y+6
 542 0042 9F81      		ldd r25,Y+7
 543 0044 0E94 0000 		call memcpy
1126:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 545               	.LM8:
 546 0048 2C8D      		ldd r18,Y+28
 547 004a 30E0      		ldi r19,0
 548 004c 3195      		neg r19
 549 004e 2195      		neg r18
 550 0050 3109      		sbc r19,__zero_reg__
 551 0052 8E81      		ldd r24,Y+6
 552 0054 9F81      		ldd r25,Y+7
 553 0056 820F      		add r24,r18
 554 0058 931F      		adc r25,r19
 555 005a 8E83      		std Y+6,r24
 556 005c 9F83      		std Y+7,r25
1127:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 558               	.LM9:
 559 005e 4881      		ld r20,Y
 560 0060 5981      		ldd r21,Y+1
 561 0062 8417      		cp r24,r20
 562 0064 9507      		cpc r25,r21
 563 0066 00F4      		brsh .L3
1128:../../freeRtos/Source/queue.c **** 		{
1129:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 565               	.LM10:
 566 0068 8A81      		ldd r24,Y+2
 567 006a 9B81      		ldd r25,Y+3
 568 006c 820F      		add r24,r18
 569 006e 931F      		adc r25,r19
 570 0070 8E83      		std Y+6,r24
 571 0072 9F83      		std Y+7,r25
 572               	.L3:
1130:../../freeRtos/Source/queue.c **** 		}
1131:../../freeRtos/Source/queue.c **** 	}
1132:../../freeRtos/Source/queue.c **** 
1133:../../freeRtos/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 574               	.LM11:
 575 0074 8A8D      		ldd r24,Y+26
 576 0076 8F5F      		subi r24,lo8(-(1))
 577 0078 8A8F      		std Y+26,r24
 578               	/* epilogue start */
1134:../../freeRtos/Source/queue.c **** }
 580               	.LM12:
 581 007a DF91      		pop r29
 582 007c CF91      		pop r28
 583 007e 0895      		ret
 585               	.Lscope1:
 587               		.stabd	78,0,0
 592               	prvCopyDataFromQueue:
 593               		.stabd	46,0,0
1135:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1136:../../freeRtos/Source/queue.c **** 
1137:../../freeRtos/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1138:../../freeRtos/Source/queue.c **** {
 595               	.LM13:
 596               	.LFBB2:
 597               	/* prologue: function */
 598               	/* frame size = 0 */
 599               	/* stack size = 0 */
 600               	.L__stack_usage = 0
 601 0080 FC01      		movw r30,r24
 602 0082 CB01      		movw r24,r22
1139:../../freeRtos/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 604               	.LM14:
 605 0084 A081      		ld r26,Z
 606 0086 B181      		ldd r27,Z+1
 607 0088 1097      		sbiw r26,0
 608 008a 01F0      		breq .L7
1140:../../freeRtos/Source/queue.c **** 	{
1141:../../freeRtos/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 610               	.LM15:
 611 008c 448D      		ldd r20,Z+28
 612 008e 50E0      		ldi r21,0
 613 0090 2681      		ldd r18,Z+6
 614 0092 3781      		ldd r19,Z+7
 615 0094 240F      		add r18,r20
 616 0096 351F      		adc r19,r21
 617 0098 2683      		std Z+6,r18
 618 009a 3783      		std Z+7,r19
1142:../../freeRtos/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 620               	.LM16:
 621 009c 6281      		ldd r22,Z+2
 622 009e 7381      		ldd r23,Z+3
 623 00a0 2617      		cp r18,r22
 624 00a2 3707      		cpc r19,r23
 625 00a4 00F0      		brlo .L9
1143:../../freeRtos/Source/queue.c **** 		{
1144:../../freeRtos/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 627               	.LM17:
 628 00a6 A683      		std Z+6,r26
 629 00a8 B783      		std Z+7,r27
 630               	.L9:
1145:../../freeRtos/Source/queue.c **** 		}
1146:../../freeRtos/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 632               	.LM18:
 633 00aa 6681      		ldd r22,Z+6
 634 00ac 7781      		ldd r23,Z+7
 635 00ae 0C94 0000 		jmp memcpy
 636               	.L7:
 637 00b2 0895      		ret
 639               	.Lscope2:
 641               		.stabd	78,0,0
 645               	prvUnlockQueue:
 646               		.stabd	46,0,0
1147:../../freeRtos/Source/queue.c **** 	}
1148:../../freeRtos/Source/queue.c **** }
1149:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1150:../../freeRtos/Source/queue.c **** 
1151:../../freeRtos/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1152:../../freeRtos/Source/queue.c **** {
 648               	.LM19:
 649               	.LFBB3:
 650 00b4 0F93      		push r16
 651 00b6 1F93      		push r17
 652 00b8 CF93      		push r28
 653 00ba DF93      		push r29
 654               	/* prologue: function */
 655               	/* frame size = 0 */
 656               	/* stack size = 4 */
 657               	.L__stack_usage = 4
 658 00bc EC01      		movw r28,r24
1153:../../freeRtos/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1154:../../freeRtos/Source/queue.c **** 
1155:../../freeRtos/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1156:../../freeRtos/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1157:../../freeRtos/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1158:../../freeRtos/Source/queue.c **** 	updated. */
1159:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 660               	.LM20:
 661               	/* #APP */
 662               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 663 00be 0FB6      		in		__tmp_reg__, __SREG__
 664               	 ;  0 "" 2
 665               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 666 00c0 F894      		cli
 667               	 ;  0 "" 2
 668               	 ;  1159 "../../freeRtos/Source/queue.c" 1
 669 00c2 0F92      		push	__tmp_reg__
 670               	 ;  0 "" 2
1160:../../freeRtos/Source/queue.c **** 	{
1161:../../freeRtos/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1162:../../freeRtos/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
1163:../../freeRtos/Source/queue.c **** 		{
1164:../../freeRtos/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1165:../../freeRtos/Source/queue.c **** 			blocked waiting for data to become available? */
1166:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
1167:../../freeRtos/Source/queue.c **** 			{
1168:../../freeRtos/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1169:../../freeRtos/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1170:../../freeRtos/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 672               	.LM21:
 673               	/* #NOAPP */
 674 00c4 8C01      		movw r16,r24
 675 00c6 0F5E      		subi r16,-17
 676 00c8 1F4F      		sbci r17,-1
 677               	.L11:
1162:../../freeRtos/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 679               	.LM22:
 680 00ca 8E8D      		ldd r24,Y+30
 681 00cc 1816      		cp __zero_reg__,r24
 682 00ce 04F4      		brge .L12
1166:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 684               	.LM23:
 685 00d0 8989      		ldd r24,Y+17
 686 00d2 8823      		tst r24
 687 00d4 01F0      		breq .L12
 689               	.LM24:
 690 00d6 C801      		movw r24,r16
 691 00d8 0E94 0000 		call xTaskRemoveFromEventList
 692 00dc 8111      		cpse r24,__zero_reg__
1171:../../freeRtos/Source/queue.c **** 				{
1172:../../freeRtos/Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1173:../../freeRtos/Source/queue.c **** 					context	switch is required. */
1174:../../freeRtos/Source/queue.c **** 					vTaskMissedYield();
 694               	.LM25:
 695 00de 0E94 0000 		call vTaskMissedYield
 696               	.L13:
1175:../../freeRtos/Source/queue.c **** 				}
1176:../../freeRtos/Source/queue.c **** 
1177:../../freeRtos/Source/queue.c **** 				--( pxQueue->xTxLock );
 698               	.LM26:
 699 00e2 8E8D      		ldd r24,Y+30
 700 00e4 8150      		subi r24,lo8(-(-1))
 701 00e6 8E8F      		std Y+30,r24
 702 00e8 00C0      		rjmp .L11
 703               	.L12:
1178:../../freeRtos/Source/queue.c **** 			}
1179:../../freeRtos/Source/queue.c **** 			else
1180:../../freeRtos/Source/queue.c **** 			{
1181:../../freeRtos/Source/queue.c **** 				break;
1182:../../freeRtos/Source/queue.c **** 			}
1183:../../freeRtos/Source/queue.c **** 		}
1184:../../freeRtos/Source/queue.c **** 
1185:../../freeRtos/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 705               	.LM27:
 706 00ea 8FEF      		ldi r24,lo8(-1)
 707 00ec 8E8F      		std Y+30,r24
1186:../../freeRtos/Source/queue.c **** 	}
1187:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 709               	.LM28:
 710               	/* #APP */
 711               	 ;  1187 "../../freeRtos/Source/queue.c" 1
 712 00ee 0F90      		pop		__tmp_reg__
 713               	 ;  0 "" 2
 714               	 ;  1187 "../../freeRtos/Source/queue.c" 1
 715 00f0 0FBE      		out		__SREG__, __tmp_reg__
 716               	 ;  0 "" 2
1188:../../freeRtos/Source/queue.c **** 
1189:../../freeRtos/Source/queue.c **** 	/* Do the same for the Rx lock. */
1190:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 718               	.LM29:
 719               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 720 00f2 0FB6      		in		__tmp_reg__, __SREG__
 721               	 ;  0 "" 2
 722               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 723 00f4 F894      		cli
 724               	 ;  0 "" 2
 725               	 ;  1190 "../../freeRtos/Source/queue.c" 1
 726 00f6 0F92      		push	__tmp_reg__
 727               	 ;  0 "" 2
1191:../../freeRtos/Source/queue.c **** 	{
1192:../../freeRtos/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
1193:../../freeRtos/Source/queue.c **** 		{
1194:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
1195:../../freeRtos/Source/queue.c **** 			{
1196:../../freeRtos/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 729               	.LM30:
 730               	/* #NOAPP */
 731 00f8 8E01      		movw r16,r28
 732 00fa 085F      		subi r16,-8
 733 00fc 1F4F      		sbci r17,-1
 734               	.L15:
1192:../../freeRtos/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 736               	.LM31:
 737 00fe 8D8D      		ldd r24,Y+29
 738 0100 1816      		cp __zero_reg__,r24
 739 0102 04F4      		brge .L16
1194:../../freeRtos/Source/queue.c **** 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 741               	.LM32:
 742 0104 8885      		ldd r24,Y+8
 743 0106 8823      		tst r24
 744 0108 01F0      		breq .L16
 746               	.LM33:
 747 010a C801      		movw r24,r16
 748 010c 0E94 0000 		call xTaskRemoveFromEventList
 749 0110 8111      		cpse r24,__zero_reg__
1197:../../freeRtos/Source/queue.c **** 				{
1198:../../freeRtos/Source/queue.c **** 					vTaskMissedYield();
 751               	.LM34:
 752 0112 0E94 0000 		call vTaskMissedYield
 753               	.L17:
1199:../../freeRtos/Source/queue.c **** 				}
1200:../../freeRtos/Source/queue.c **** 
1201:../../freeRtos/Source/queue.c **** 				--( pxQueue->xRxLock );
 755               	.LM35:
 756 0116 8D8D      		ldd r24,Y+29
 757 0118 8150      		subi r24,lo8(-(-1))
 758 011a 8D8F      		std Y+29,r24
 759 011c 00C0      		rjmp .L15
 760               	.L16:
1202:../../freeRtos/Source/queue.c **** 			}
1203:../../freeRtos/Source/queue.c **** 			else
1204:../../freeRtos/Source/queue.c **** 			{
1205:../../freeRtos/Source/queue.c **** 				break;
1206:../../freeRtos/Source/queue.c **** 			}
1207:../../freeRtos/Source/queue.c **** 		}
1208:../../freeRtos/Source/queue.c **** 
1209:../../freeRtos/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 762               	.LM36:
 763 011e 8FEF      		ldi r24,lo8(-1)
 764 0120 8D8F      		std Y+29,r24
1210:../../freeRtos/Source/queue.c **** 	}
1211:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 766               	.LM37:
 767               	/* #APP */
 768               	 ;  1211 "../../freeRtos/Source/queue.c" 1
 769 0122 0F90      		pop		__tmp_reg__
 770               	 ;  0 "" 2
 771               	 ;  1211 "../../freeRtos/Source/queue.c" 1
 772 0124 0FBE      		out		__SREG__, __tmp_reg__
 773               	 ;  0 "" 2
 774               	/* epilogue start */
1212:../../freeRtos/Source/queue.c **** }
 776               	.LM38:
 777               	/* #NOAPP */
 778 0126 DF91      		pop r29
 779 0128 CF91      		pop r28
 780 012a 1F91      		pop r17
 781 012c 0F91      		pop r16
 782 012e 0895      		ret
 784               	.Lscope3:
 786               		.stabd	78,0,0
 790               	.global	xQueueCreate
 792               	xQueueCreate:
 793               		.stabd	46,0,0
 249:../../freeRtos/Source/queue.c **** {
 795               	.LM39:
 796               	.LFBB4:
 797 0130 CF92      		push r12
 798 0132 DF92      		push r13
 799 0134 EF92      		push r14
 800 0136 FF92      		push r15
 801 0138 0F93      		push r16
 802 013a 1F93      		push r17
 803 013c CF93      		push r28
 804 013e DF93      		push r29
 805               	/* prologue: function */
 806               	/* frame size = 0 */
 807               	/* stack size = 8 */
 808               	.L__stack_usage = 8
 809 0140 D82E      		mov r13,r24
 810 0142 C62E      		mov r12,r22
 254:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 812               	.LM40:
 813 0144 8823      		tst r24
 814 0146 01F0      		breq .L39
 256:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 816               	.LM41:
 817 0148 8FE1      		ldi r24,lo8(31)
 818 014a 90E0      		ldi r25,0
 819 014c 0E94 0000 		call pvPortMalloc
 820 0150 EC01      		movw r28,r24
 257:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 822               	.LM42:
 823 0152 0097      		sbiw r24,0
 824 0154 01F0      		breq .L39
 261:../../freeRtos/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 826               	.LM43:
 827 0156 EC2C      		mov r14,r12
 828 0158 F12C      		mov r15,__zero_reg__
 829 015a DC9C      		mul r13,r12
 830 015c 8001      		movw r16,r0
 831 015e 1124      		clr __zero_reg__
 263:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 833               	.LM44:
 834 0160 C801      		movw r24,r16
 835 0162 0196      		adiw r24,1
 836 0164 0E94 0000 		call pvPortMalloc
 837 0168 8883      		st Y,r24
 838 016a 9983      		std Y+1,r25
 264:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 840               	.LM45:
 841 016c 0097      		sbiw r24,0
 842 016e 01F0      		breq .L35
 268:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 844               	.LM46:
 845 0170 9C01      		movw r18,r24
 846 0172 200F      		add r18,r16
 847 0174 311F      		adc r19,r17
 848 0176 2A83      		std Y+2,r18
 849 0178 3B83      		std Y+3,r19
 269:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 851               	.LM47:
 852 017a 1A8E      		std Y+26,__zero_reg__
 270:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 854               	.LM48:
 855 017c 8C83      		std Y+4,r24
 856 017e 9D83      		std Y+5,r25
 271:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 858               	.LM49:
 859 0180 0E19      		sub r16,r14
 860 0182 1F09      		sbc r17,r15
 861 0184 080F      		add r16,r24
 862 0186 191F      		adc r17,r25
 863 0188 0E83      		std Y+6,r16
 864 018a 1F83      		std Y+7,r17
 272:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 866               	.LM50:
 867 018c DB8E      		std Y+27,r13
 273:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 869               	.LM51:
 870 018e CC8E      		std Y+28,r12
 274:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 872               	.LM52:
 873 0190 8FEF      		ldi r24,lo8(-1)
 874 0192 8D8F      		std Y+29,r24
 275:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 876               	.LM53:
 877 0194 8E8F      		std Y+30,r24
 278:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 879               	.LM54:
 880 0196 CE01      		movw r24,r28
 881 0198 0896      		adiw r24,8
 882 019a 0E94 0000 		call vListInitialise
 279:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 884               	.LM55:
 885 019e CE01      		movw r24,r28
 886 01a0 4196      		adiw r24,17
 887 01a2 0E94 0000 		call vListInitialise
 282:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 889               	.LM56:
 890 01a6 CE01      		movw r24,r28
 891 01a8 00C0      		rjmp .L33
 892               	.L35:
 287:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 894               	.LM57:
 895 01aa CE01      		movw r24,r28
 896 01ac 0E94 0000 		call vPortFree
 897               	.L39:
 294:../../freeRtos/Source/queue.c **** 	return NULL;
 899               	.LM58:
 900 01b0 80E0      		ldi r24,0
 901 01b2 90E0      		ldi r25,0
 902               	.L33:
 903               	/* epilogue start */
 295:../../freeRtos/Source/queue.c **** }
 905               	.LM59:
 906 01b4 DF91      		pop r29
 907 01b6 CF91      		pop r28
 908 01b8 1F91      		pop r17
 909 01ba 0F91      		pop r16
 910 01bc FF90      		pop r15
 911 01be EF90      		pop r14
 912 01c0 DF90      		pop r13
 913 01c2 CF90      		pop r12
 914 01c4 0895      		ret
 919               	.Lscope4:
 921               		.stabd	78,0,0
 926               	.global	xQueueCreateExternal
 928               	xQueueCreateExternal:
 929               		.stabd	46,0,0
 298:../../freeRtos/Source/queue.c **** {
 931               	.LM60:
 932               	.LFBB5:
 933 01c6 CF92      		push r12
 934 01c8 DF92      		push r13
 935 01ca FF92      		push r15
 936 01cc 0F93      		push r16
 937 01ce 1F93      		push r17
 938 01d0 CF93      		push r28
 939 01d2 DF93      		push r29
 940 01d4 1F92      		push __zero_reg__
 941 01d6 CDB7      		in r28,__SP_L__
 942 01d8 DEB7      		in r29,__SP_H__
 943               	/* prologue: function */
 944               	/* frame size = 1 */
 945               	/* stack size = 8 */
 946               	.L__stack_usage = 8
 947 01da F82E      		mov r15,r24
 948 01dc 8A01      		movw r16,r20
 303:../../freeRtos/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 950               	.LM61:
 951 01de 8823      		tst r24
 952 01e0 01F0      		breq .L48
 305:../../freeRtos/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 954               	.LM62:
 955 01e2 8FE1      		ldi r24,lo8(31)
 956 01e4 90E0      		ldi r25,0
 957 01e6 6983      		std Y+1,r22
 958 01e8 0E94 0000 		call pvPortMalloc
 959 01ec 6C01      		movw r12,r24
 306:../../freeRtos/Source/queue.c **** 		if( pxNewQueue != NULL )
 961               	.LM63:
 962 01ee 6981      		ldd r22,Y+1
 963 01f0 0097      		sbiw r24,0
 964 01f2 01F0      		breq .L48
 312:../../freeRtos/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) (address);
 966               	.LM64:
 967 01f4 FC01      		movw r30,r24
 968 01f6 0083      		st Z,r16
 969 01f8 1183      		std Z+1,r17
 313:../../freeRtos/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 971               	.LM65:
 972 01fa 0115      		cp r16,__zero_reg__
 973 01fc 1105      		cpc r17,__zero_reg__
 974 01fe 01F0      		breq .L44
 317:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 976               	.LM66:
 977 0200 F69E      		mul r15,r22
 978 0202 9001      		movw r18,r0
 979 0204 1124      		clr __zero_reg__
 980 0206 A801      		movw r20,r16
 981 0208 420F      		add r20,r18
 982 020a 531F      		adc r21,r19
 983 020c 4283      		std Z+2,r20
 984 020e 5383      		std Z+3,r21
 318:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = 0;
 986               	.LM67:
 987 0210 128E      		std Z+26,__zero_reg__
 319:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 989               	.LM68:
 990 0212 0483      		std Z+4,r16
 991 0214 1583      		std Z+5,r17
 320:../../freeRtos/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
 993               	.LM69:
 994 0216 261B      		sub r18,r22
 995 0218 3109      		sbc r19,__zero_reg__
 996 021a 200F      		add r18,r16
 997 021c 311F      		adc r19,r17
 998 021e 2683      		std Z+6,r18
 999 0220 3783      		std Z+7,r19
 321:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 1001               	.LM70:
 1002 0222 F38E      		std Z+27,r15
 322:../../freeRtos/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 1004               	.LM71:
 1005 0224 648F      		std Z+28,r22
 323:../../freeRtos/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 1007               	.LM72:
 1008 0226 8FEF      		ldi r24,lo8(-1)
 1009 0228 858F      		std Z+29,r24
 324:../../freeRtos/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 1011               	.LM73:
 1012 022a 868F      		std Z+30,r24
 327:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 1014               	.LM74:
 1015 022c C601      		movw r24,r12
 1016 022e 0896      		adiw r24,8
 1017 0230 0E94 0000 		call vListInitialise
 328:../../freeRtos/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 1019               	.LM75:
 1020 0234 C601      		movw r24,r12
 1021 0236 4196      		adiw r24,17
 1022 0238 0E94 0000 		call vListInitialise
 331:../../freeRtos/Source/queue.c **** 				return  pxNewQueue;
 1024               	.LM76:
 1025 023c C601      		movw r24,r12
 1026 023e 00C0      		rjmp .L42
 1027               	.L44:
 336:../../freeRtos/Source/queue.c **** 				vPortFree( pxNewQueue );
 1029               	.LM77:
 1030 0240 0E94 0000 		call vPortFree
 1031               	.L48:
 343:../../freeRtos/Source/queue.c **** 	return NULL;
 1033               	.LM78:
 1034 0244 80E0      		ldi r24,0
 1035 0246 90E0      		ldi r25,0
 1036               	.L42:
 1037               	/* epilogue start */
 344:../../freeRtos/Source/queue.c **** }
 1039               	.LM79:
 1040 0248 0F90      		pop __tmp_reg__
 1041 024a DF91      		pop r29
 1042 024c CF91      		pop r28
 1043 024e 1F91      		pop r17
 1044 0250 0F91      		pop r16
 1045 0252 FF90      		pop r15
 1046 0254 DF90      		pop r13
 1047 0256 CF90      		pop r12
 1048 0258 0895      		ret
 1053               	.Lscope5:
 1055               		.stabd	78,0,0
 1061               	.global	xQueueGenericSend
 1063               	xQueueGenericSend:
 1064               		.stabd	46,0,0
 502:../../freeRtos/Source/queue.c **** {
 1066               	.LM80:
 1067               	.LFBB6:
 1068 025a BF92      		push r11
 1069 025c CF92      		push r12
 1070 025e DF92      		push r13
 1071 0260 EF92      		push r14
 1072 0262 FF92      		push r15
 1073 0264 0F93      		push r16
 1074 0266 1F93      		push r17
 1075 0268 CF93      		push r28
 1076 026a DF93      		push r29
 1077 026c CDB7      		in r28,__SP_L__
 1078 026e DEB7      		in r29,__SP_H__
 1079 0270 2597      		sbiw r28,5
 1080 0272 CDBF      		out __SP_L__,r28
 1081 0274 DEBF      		out __SP_H__,r29
 1082               	/* prologue: function */
 1083               	/* frame size = 5 */
 1084               	/* stack size = 14 */
 1085               	.L__stack_usage = 14
 1086 0276 8C01      		movw r16,r24
 1087 0278 6B01      		movw r12,r22
 1088 027a 4C83      		std Y+4,r20
 1089 027c 5D83      		std Y+5,r21
 1090 027e B22E      		mov r11,r18
 503:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 1092               	.LM81:
 1093 0280 30E0      		ldi r19,0
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1095               	.LM82:
 1096 0282 7C01      		movw r14,r24
 1097 0284 88E0      		ldi r24,8
 1098 0286 E80E      		add r14,r24
 1099 0288 F11C      		adc r15,__zero_reg__
 1100               	.L50:
 511:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 1102               	.LM83:
 1103               	/* #APP */
 1104               	 ;  511 "../../freeRtos/Source/queue.c" 1
 1105 028a 0FB6      		in		__tmp_reg__, __SREG__
 1106               	 ;  0 "" 2
 1107               	 ;  511 "../../freeRtos/Source/queue.c" 1
 1108 028c F894      		cli
 1109               	 ;  0 "" 2
 1110               	 ;  511 "../../freeRtos/Source/queue.c" 1
 1111 028e 0F92      		push	__tmp_reg__
 1112               	 ;  0 "" 2
 515:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 1114               	.LM84:
 1115               	/* #NOAPP */
 1116 0290 F801      		movw r30,r16
 1117 0292 928D      		ldd r25,Z+26
 1118 0294 838D      		ldd r24,Z+27
 1119 0296 9817      		cp r25,r24
 1120 0298 00F4      		brsh .L51
 518:../../freeRtos/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1122               	.LM85:
 1123 029a 4B2D      		mov r20,r11
 1124 029c B601      		movw r22,r12
 1125 029e C801      		movw r24,r16
 1126 02a0 0E94 0000 		call prvCopyDataToQueue
 522:../../freeRtos/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1128               	.LM86:
 1129 02a4 F801      		movw r30,r16
 1130 02a6 8189      		ldd r24,Z+17
 1131 02a8 8823      		tst r24
 1132 02aa 01F0      		breq .L53
 524:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 1134               	.LM87:
 1135 02ac C801      		movw r24,r16
 1136 02ae 4196      		adiw r24,17
 1137 02b0 0E94 0000 		call xTaskRemoveFromEventList
 1138 02b4 8130      		cpi r24,lo8(1)
 1139 02b6 01F4      		brne .L53
 530:../../freeRtos/Source/queue.c **** 						portYIELD_WITHIN_API();
 1141               	.LM88:
 1142 02b8 0E94 0000 		call vPortYield
 1143               	.L53:
 534:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 1145               	.LM89:
 1146               	/* #APP */
 1147               	 ;  534 "../../freeRtos/Source/queue.c" 1
 1148 02bc 0F90      		pop		__tmp_reg__
 1149               	 ;  0 "" 2
 1150               	 ;  534 "../../freeRtos/Source/queue.c" 1
 1151 02be 0FBE      		out		__SREG__, __tmp_reg__
 1152               	 ;  0 "" 2
 538:../../freeRtos/Source/queue.c **** 				return pdPASS;
 1154               	.LM90:
 1155               	/* #NOAPP */
 1156 02c0 81E0      		ldi r24,lo8(1)
 1157 02c2 00C0      		rjmp .L55
 1158               	.L51:
 542:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1160               	.LM91:
 1161 02c4 8C81      		ldd r24,Y+4
 1162 02c6 9D81      		ldd r25,Y+5
 1163 02c8 892B      		or r24,r25
 1164 02ca 01F4      		brne .L56
 546:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 1166               	.LM92:
 1167               	/* #APP */
 1168               	 ;  546 "../../freeRtos/Source/queue.c" 1
 1169 02cc 0F90      		pop		__tmp_reg__
 1170               	 ;  0 "" 2
 1171               	 ;  546 "../../freeRtos/Source/queue.c" 1
 1172 02ce 0FBE      		out		__SREG__, __tmp_reg__
 1173               	 ;  0 "" 2
 1174               	/* #NOAPP */
 1175 02d0 00C0      		rjmp .L63
 1176               	.L56:
 553:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1178               	.LM93:
 1179 02d2 3111      		cpse r19,__zero_reg__
 1180 02d4 00C0      		rjmp .L57
 557:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1182               	.LM94:
 1183 02d6 CE01      		movw r24,r28
 1184 02d8 0196      		adiw r24,1
 1185 02da 0E94 0000 		call vTaskSetTimeOutState
 1186               	.L57:
 562:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 1188               	.LM95:
 1189               	/* #APP */
 1190               	 ;  562 "../../freeRtos/Source/queue.c" 1
 1191 02de 0F90      		pop		__tmp_reg__
 1192               	 ;  0 "" 2
 1193               	 ;  562 "../../freeRtos/Source/queue.c" 1
 1194 02e0 0FBE      		out		__SREG__, __tmp_reg__
 1195               	 ;  0 "" 2
 567:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 1197               	.LM96:
 1198               	/* #NOAPP */
 1199 02e2 0E94 0000 		call vTaskSuspendAll
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1201               	.LM97:
 1202               	/* #APP */
 1203               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1204 02e6 0FB6      		in		__tmp_reg__, __SREG__
 1205               	 ;  0 "" 2
 1206               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1207 02e8 F894      		cli
 1208               	 ;  0 "" 2
 1209               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1210 02ea 0F92      		push	__tmp_reg__
 1211               	 ;  0 "" 2
 1212               	/* #NOAPP */
 1213 02ec F801      		movw r30,r16
 1214 02ee 858D      		ldd r24,Z+29
 1215 02f0 8F3F      		cpi r24,lo8(-1)
 1216 02f2 01F4      		brne .L58
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1218               	.LM98:
 1219 02f4 158E      		std Z+29,__zero_reg__
 1220               	.L58:
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1222               	.LM99:
 1223 02f6 F801      		movw r30,r16
 1224 02f8 868D      		ldd r24,Z+30
 1225 02fa 8F3F      		cpi r24,lo8(-1)
 1226 02fc 01F4      		brne .L59
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1228               	.LM100:
 1229 02fe 168E      		std Z+30,__zero_reg__
 1230               	.L59:
 568:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1232               	.LM101:
 1233               	/* #APP */
 1234               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1235 0300 0F90      		pop		__tmp_reg__
 1236               	 ;  0 "" 2
 1237               	 ;  568 "../../freeRtos/Source/queue.c" 1
 1238 0302 0FBE      		out		__SREG__, __tmp_reg__
 1239               	 ;  0 "" 2
 571:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1241               	.LM102:
 1242               	/* #NOAPP */
 1243 0304 BE01      		movw r22,r28
 1244 0306 6C5F      		subi r22,-4
 1245 0308 7F4F      		sbci r23,-1
 1246 030a CE01      		movw r24,r28
 1247 030c 0196      		adiw r24,1
 1248 030e 0E94 0000 		call xTaskCheckForTimeOut
 1249 0312 8111      		cpse r24,__zero_reg__
 1250 0314 00C0      		rjmp .L60
 1251               	.LBB4:
 1252               	.LBB5:
1213:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1214:../../freeRtos/Source/queue.c **** 
1215:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1216:../../freeRtos/Source/queue.c **** {
1217:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1218:../../freeRtos/Source/queue.c **** 
1219:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
1220:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
1221:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
1222:../../freeRtos/Source/queue.c **** 
1223:../../freeRtos/Source/queue.c **** 	return xReturn;
1224:../../freeRtos/Source/queue.c **** }
1225:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1226:../../freeRtos/Source/queue.c **** 
1227:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1228:../../freeRtos/Source/queue.c **** {
1229:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1230:../../freeRtos/Source/queue.c **** 
1231:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
1232:../../freeRtos/Source/queue.c **** 
1233:../../freeRtos/Source/queue.c **** 	return xReturn;
1234:../../freeRtos/Source/queue.c **** }
1235:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1236:../../freeRtos/Source/queue.c **** 
1237:../../freeRtos/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1238:../../freeRtos/Source/queue.c **** {
1239:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1240:../../freeRtos/Source/queue.c **** 
1241:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 1254               	.LM103:
 1255               	/* #APP */
 1256               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 1257 0316 0FB6      		in		__tmp_reg__, __SREG__
 1258               	 ;  0 "" 2
 1259               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 1260 0318 F894      		cli
 1261               	 ;  0 "" 2
 1262               	 ;  1241 "../../freeRtos/Source/queue.c" 1
 1263 031a 0F92      		push	__tmp_reg__
 1264               	 ;  0 "" 2
1242:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1266               	.LM104:
 1267               	/* #NOAPP */
 1268 031c F801      		movw r30,r16
 1269 031e 928D      		ldd r25,Z+26
1243:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 1271               	.LM105:
 1272               	/* #APP */
 1273               	 ;  1243 "../../freeRtos/Source/queue.c" 1
 1274 0320 0F90      		pop		__tmp_reg__
 1275               	 ;  0 "" 2
 1276               	 ;  1243 "../../freeRtos/Source/queue.c" 1
 1277 0322 0FBE      		out		__SREG__, __tmp_reg__
 1278               	 ;  0 "" 2
 1279               	/* #NOAPP */
 1280               	.LBE5:
 1281               	.LBE4:
 573:../../freeRtos/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) )
 1283               	.LM106:
 1284 0324 F801      		movw r30,r16
 1285 0326 838D      		ldd r24,Z+27
 1286 0328 9813      		cpse r25,r24
 1287 032a 00C0      		rjmp .L61
 576:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1289               	.LM107:
 1290 032c 6C81      		ldd r22,Y+4
 1291 032e 7D81      		ldd r23,Y+5
 1292 0330 C701      		movw r24,r14
 1293 0332 0E94 0000 		call vTaskPlaceOnEventList
 583:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1295               	.LM108:
 1296 0336 C801      		movw r24,r16
 1297 0338 0E94 0000 		call prvUnlockQueue
 590:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 1299               	.LM109:
 1300 033c 0E94 0000 		call xTaskResumeAll
 1301 0340 8823      		tst r24
 1302 0342 01F0      		breq .L64
 1303               	.L62:
 1304 0344 31E0      		ldi r19,lo8(1)
 1305 0346 00C0      		rjmp .L50
 1306               	.L64:
 592:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 1308               	.LM110:
 1309 0348 0E94 0000 		call vPortYield
 1310 034c 00C0      		rjmp .L62
 1311               	.L61:
 598:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1313               	.LM111:
 1314 034e C801      		movw r24,r16
 1315 0350 0E94 0000 		call prvUnlockQueue
 599:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 1317               	.LM112:
 1318 0354 0E94 0000 		call xTaskResumeAll
 1319 0358 00C0      		rjmp .L62
 1320               	.L60:
 605:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1322               	.LM113:
 1323 035a C801      		movw r24,r16
 1324 035c 0E94 0000 		call prvUnlockQueue
 606:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 1326               	.LM114:
 1327 0360 0E94 0000 		call xTaskResumeAll
 1328               	.L63:
 611:../../freeRtos/Source/queue.c **** 			return errQUEUE_FULL;
 1330               	.LM115:
 1331 0364 80E0      		ldi r24,0
 1332               	.L55:
 1333               	/* epilogue start */
 614:../../freeRtos/Source/queue.c **** }
 1335               	.LM116:
 1336 0366 2596      		adiw r28,5
 1337 0368 CDBF      		out __SP_L__,r28
 1338 036a DEBF      		out __SP_H__,r29
 1339 036c DF91      		pop r29
 1340 036e CF91      		pop r28
 1341 0370 1F91      		pop r17
 1342 0372 0F91      		pop r16
 1343 0374 FF90      		pop r15
 1344 0376 EF90      		pop r14
 1345 0378 DF90      		pop r13
 1346 037a CF90      		pop r12
 1347 037c BF90      		pop r11
 1348 037e 0895      		ret
 1354               	.Lscope6:
 1356               		.stabd	78,0,0
 1362               	.global	xQueueGenericSendFromISR
 1364               	xQueueGenericSendFromISR:
 1365               		.stabd	46,0,0
 818:../../freeRtos/Source/queue.c **** {
 1367               	.LM117:
 1368               	.LFBB7:
 1369 0380 0F93      		push r16
 1370 0382 1F93      		push r17
 1371 0384 CF93      		push r28
 1372 0386 DF93      		push r29
 1373               	/* prologue: function */
 1374               	/* frame size = 0 */
 1375               	/* stack size = 4 */
 1376               	.L__stack_usage = 4
 1377 0388 EC01      		movw r28,r24
 1378 038a 8A01      		movw r16,r20
 829:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 1380               	.LM118:
 1381 038c 9A8D      		ldd r25,Y+26
 1382 038e 8B8D      		ldd r24,Y+27
 1383 0390 9817      		cp r25,r24
 1384 0392 00F4      		brsh .L70
 833:../../freeRtos/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1386               	.LM119:
 1387 0394 422F      		mov r20,r18
 1388 0396 CE01      		movw r24,r28
 1389 0398 0E94 0000 		call prvCopyDataToQueue
 837:../../freeRtos/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 1391               	.LM120:
 1392 039c 8E8D      		ldd r24,Y+30
 1393 039e 8F3F      		cpi r24,lo8(-1)
 1394 03a0 01F4      		brne .L67
 839:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 1396               	.LM121:
 1397 03a2 8989      		ldd r24,Y+17
 1398 03a4 8823      		tst r24
 1399 03a6 01F0      		breq .L74
 841:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1401               	.LM122:
 1402 03a8 CE01      		movw r24,r28
 1403 03aa 4196      		adiw r24,17
 1404 03ac 0E94 0000 		call xTaskRemoveFromEventList
 1405 03b0 8823      		tst r24
 1406 03b2 01F0      		breq .L74
 845:../../freeRtos/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 1408               	.LM123:
 1409 03b4 81E0      		ldi r24,lo8(1)
 1410 03b6 F801      		movw r30,r16
 1411 03b8 8083      		st Z,r24
 1412 03ba 00C0      		rjmp .L66
 1413               	.L67:
 853:../../freeRtos/Source/queue.c **** 				++( pxQueue->xTxLock );
 1415               	.LM124:
 1416 03bc 8F5F      		subi r24,lo8(-(1))
 1417 03be 8E8F      		std Y+30,r24
 1418               	.L74:
 856:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 1420               	.LM125:
 1421 03c0 81E0      		ldi r24,lo8(1)
 1422 03c2 00C0      		rjmp .L66
 1423               	.L70:
 861:../../freeRtos/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1425               	.LM126:
 1426 03c4 80E0      		ldi r24,0
 1427               	.L66:
 1428               	/* epilogue start */
 867:../../freeRtos/Source/queue.c **** }
 1430               	.LM127:
 1431 03c6 DF91      		pop r29
 1432 03c8 CF91      		pop r28
 1433 03ca 1F91      		pop r17
 1434 03cc 0F91      		pop r16
 1435 03ce 0895      		ret
 1440               	.Lscope7:
 1442               		.stabd	78,0,0
 1448               	.global	xQueueGenericReceive
 1450               	xQueueGenericReceive:
 1451               		.stabd	46,0,0
 871:../../freeRtos/Source/queue.c **** {
 1453               	.LM128:
 1454               	.LFBB8:
 1455 03d0 BF92      		push r11
 1456 03d2 CF92      		push r12
 1457 03d4 DF92      		push r13
 1458 03d6 EF92      		push r14
 1459 03d8 FF92      		push r15
 1460 03da 0F93      		push r16
 1461 03dc 1F93      		push r17
 1462 03de CF93      		push r28
 1463 03e0 DF93      		push r29
 1464 03e2 CDB7      		in r28,__SP_L__
 1465 03e4 DEB7      		in r29,__SP_H__
 1466 03e6 2597      		sbiw r28,5
 1467 03e8 CDBF      		out __SP_L__,r28
 1468 03ea DEBF      		out __SP_H__,r29
 1469               	/* prologue: function */
 1470               	/* frame size = 5 */
 1471               	/* stack size = 14 */
 1472               	.L__stack_usage = 14
 1473 03ec 8C01      		movw r16,r24
 1474 03ee 6B01      		movw r12,r22
 1475 03f0 4C83      		std Y+4,r20
 1476 03f2 5D83      		std Y+5,r21
 1477 03f4 B22E      		mov r11,r18
 872:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 1479               	.LM129:
 1480 03f6 30E0      		ldi r19,0
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1482               	.LM130:
 1483 03f8 7C01      		movw r14,r24
 1484 03fa 81E1      		ldi r24,17
 1485 03fc E80E      		add r14,r24
 1486 03fe F11C      		adc r15,__zero_reg__
 1487               	.L76:
 882:../../freeRtos/Source/queue.c **** 		taskENTER_CRITICAL();
 1489               	.LM131:
 1490               	/* #APP */
 1491               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1492 0400 0FB6      		in		__tmp_reg__, __SREG__
 1493               	 ;  0 "" 2
 1494               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1495 0402 F894      		cli
 1496               	 ;  0 "" 2
 1497               	 ;  882 "../../freeRtos/Source/queue.c" 1
 1498 0404 0F92      		push	__tmp_reg__
 1499               	 ;  0 "" 2
 886:../../freeRtos/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1501               	.LM132:
 1502               	/* #NOAPP */
 1503 0406 F801      		movw r30,r16
 1504 0408 828D      		ldd r24,Z+26
 1505 040a 8823      		tst r24
 1506 040c 01F0      		breq .L77
 889:../../freeRtos/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 1508               	.LM133:
 1509 040e E680      		ldd r14,Z+6
 1510 0410 F780      		ldd r15,Z+7
 891:../../freeRtos/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1512               	.LM134:
 1513 0412 B601      		movw r22,r12
 1514 0414 C801      		movw r24,r16
 1515 0416 0E94 0000 		call prvCopyDataFromQueue
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1517               	.LM135:
 1518 041a F801      		movw r30,r16
 893:../../freeRtos/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1520               	.LM136:
 1521 041c B110      		cpse r11,__zero_reg__
 1522 041e 00C0      		rjmp .L78
 898:../../freeRtos/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1524               	.LM137:
 1525 0420 828D      		ldd r24,Z+26
 1526 0422 8150      		subi r24,lo8(-(-1))
 1527 0424 828F      		std Z+26,r24
 911:../../freeRtos/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1529               	.LM138:
 1530 0426 8085      		ldd r24,Z+8
 1531 0428 8823      		tst r24
 1532 042a 01F0      		breq .L80
 913:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1534               	.LM139:
 1535 042c C801      		movw r24,r16
 1536 042e 0896      		adiw r24,8
 1537 0430 0E94 0000 		call xTaskRemoveFromEventList
 1538 0434 8130      		cpi r24,lo8(1)
 1539 0436 01F4      		brne .L80
 1540               	.L82:
 915:../../freeRtos/Source/queue.c **** 							portYIELD_WITHIN_API();
 1542               	.LM140:
 1543 0438 0E94 0000 		call vPortYield
 1544 043c 00C0      		rjmp .L80
 1545               	.L78:
 925:../../freeRtos/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 1547               	.LM141:
 1548 043e E682      		std Z+6,r14
 1549 0440 F782      		std Z+7,r15
 929:../../freeRtos/Source/queue.c **** 					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 1551               	.LM142:
 1552 0442 8189      		ldd r24,Z+17
 1553 0444 8823      		tst r24
 1554 0446 01F0      		breq .L80
 933:../../freeRtos/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1556               	.LM143:
 1557 0448 C801      		movw r24,r16
 1558 044a 4196      		adiw r24,17
 1559 044c 0E94 0000 		call xTaskRemoveFromEventList
 1560 0450 8111      		cpse r24,__zero_reg__
 1561 0452 00C0      		rjmp .L82
 1562               	.L80:
 942:../../freeRtos/Source/queue.c **** 				taskEXIT_CRITICAL();
 1564               	.LM144:
 1565               	/* #APP */
 1566               	 ;  942 "../../freeRtos/Source/queue.c" 1
 1567 0454 0F90      		pop		__tmp_reg__
 1568               	 ;  0 "" 2
 1569               	 ;  942 "../../freeRtos/Source/queue.c" 1
 1570 0456 0FBE      		out		__SREG__, __tmp_reg__
 1571               	 ;  0 "" 2
 943:../../freeRtos/Source/queue.c **** 				return pdPASS;
 1573               	.LM145:
 1574               	/* #NOAPP */
 1575 0458 81E0      		ldi r24,lo8(1)
 1576 045a 00C0      		rjmp .L83
 1577               	.L77:
 947:../../freeRtos/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1579               	.LM146:
 1580 045c 8C81      		ldd r24,Y+4
 1581 045e 9D81      		ldd r25,Y+5
 1582 0460 892B      		or r24,r25
 1583 0462 01F4      		brne .L84
 951:../../freeRtos/Source/queue.c **** 					taskEXIT_CRITICAL();
 1585               	.LM147:
 1586               	/* #APP */
 1587               	 ;  951 "../../freeRtos/Source/queue.c" 1
 1588 0464 0F90      		pop		__tmp_reg__
 1589               	 ;  0 "" 2
 1590               	 ;  951 "../../freeRtos/Source/queue.c" 1
 1591 0466 0FBE      		out		__SREG__, __tmp_reg__
 1592               	 ;  0 "" 2
 1593               	/* #NOAPP */
 1594 0468 00C0      		rjmp .L94
 1595               	.L84:
 955:../../freeRtos/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1597               	.LM148:
 1598 046a 3111      		cpse r19,__zero_reg__
 1599 046c 00C0      		rjmp .L85
 959:../../freeRtos/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1601               	.LM149:
 1602 046e CE01      		movw r24,r28
 1603 0470 0196      		adiw r24,1
 1604 0472 0E94 0000 		call vTaskSetTimeOutState
 1605               	.L85:
 964:../../freeRtos/Source/queue.c **** 		taskEXIT_CRITICAL();
 1607               	.LM150:
 1608               	/* #APP */
 1609               	 ;  964 "../../freeRtos/Source/queue.c" 1
 1610 0476 0F90      		pop		__tmp_reg__
 1611               	 ;  0 "" 2
 1612               	 ;  964 "../../freeRtos/Source/queue.c" 1
 1613 0478 0FBE      		out		__SREG__, __tmp_reg__
 1614               	 ;  0 "" 2
 969:../../freeRtos/Source/queue.c **** 		vTaskSuspendAll();
 1616               	.LM151:
 1617               	/* #NOAPP */
 1618 047a 0E94 0000 		call vTaskSuspendAll
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1620               	.LM152:
 1621               	/* #APP */
 1622               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1623 047e 0FB6      		in		__tmp_reg__, __SREG__
 1624               	 ;  0 "" 2
 1625               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1626 0480 F894      		cli
 1627               	 ;  0 "" 2
 1628               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1629 0482 0F92      		push	__tmp_reg__
 1630               	 ;  0 "" 2
 1631               	/* #NOAPP */
 1632 0484 F801      		movw r30,r16
 1633 0486 858D      		ldd r24,Z+29
 1634 0488 8F3F      		cpi r24,lo8(-1)
 1635 048a 01F4      		brne .L86
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1637               	.LM153:
 1638 048c 158E      		std Z+29,__zero_reg__
 1639               	.L86:
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1641               	.LM154:
 1642 048e F801      		movw r30,r16
 1643 0490 868D      		ldd r24,Z+30
 1644 0492 8F3F      		cpi r24,lo8(-1)
 1645 0494 01F4      		brne .L87
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1647               	.LM155:
 1648 0496 168E      		std Z+30,__zero_reg__
 1649               	.L87:
 970:../../freeRtos/Source/queue.c **** 		prvLockQueue( pxQueue );
 1651               	.LM156:
 1652               	/* #APP */
 1653               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1654 0498 0F90      		pop		__tmp_reg__
 1655               	 ;  0 "" 2
 1656               	 ;  970 "../../freeRtos/Source/queue.c" 1
 1657 049a 0FBE      		out		__SREG__, __tmp_reg__
 1658               	 ;  0 "" 2
 973:../../freeRtos/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1660               	.LM157:
 1661               	/* #NOAPP */
 1662 049c BE01      		movw r22,r28
 1663 049e 6C5F      		subi r22,-4
 1664 04a0 7F4F      		sbci r23,-1
 1665 04a2 CE01      		movw r24,r28
 1666 04a4 0196      		adiw r24,1
 1667 04a6 0E94 0000 		call xTaskCheckForTimeOut
 1668 04aa 8111      		cpse r24,__zero_reg__
 1669 04ac 00C0      		rjmp .L88
 1670               	.LBB8:
 1671               	.LBB9:
1219:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 1673               	.LM158:
 1674               	/* #APP */
 1675               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1676 04ae 0FB6      		in		__tmp_reg__, __SREG__
 1677               	 ;  0 "" 2
 1678               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1679 04b0 F894      		cli
 1680               	 ;  0 "" 2
 1681               	 ;  1219 "../../freeRtos/Source/queue.c" 1
 1682 04b2 0F92      		push	__tmp_reg__
 1683               	 ;  0 "" 2
1220:../../freeRtos/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1685               	.LM159:
 1686               	/* #NOAPP */
 1687 04b4 F801      		movw r30,r16
 1688 04b6 828D      		ldd r24,Z+26
1221:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 1690               	.LM160:
 1691               	/* #APP */
 1692               	 ;  1221 "../../freeRtos/Source/queue.c" 1
 1693 04b8 0F90      		pop		__tmp_reg__
 1694               	 ;  0 "" 2
 1695               	 ;  1221 "../../freeRtos/Source/queue.c" 1
 1696 04ba 0FBE      		out		__SREG__, __tmp_reg__
 1697               	 ;  0 "" 2
 1698               	/* #NOAPP */
 1699               	.LBE9:
 1700               	.LBE8:
 975:../../freeRtos/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) )
 1702               	.LM161:
 1703 04bc 8111      		cpse r24,__zero_reg__
 1704 04be 00C0      		rjmp .L89
 992:../../freeRtos/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1706               	.LM162:
 1707 04c0 6C81      		ldd r22,Y+4
 1708 04c2 7D81      		ldd r23,Y+5
 1709 04c4 C701      		movw r24,r14
 1710 04c6 0E94 0000 		call vTaskPlaceOnEventList
 993:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1712               	.LM163:
 1713 04ca C801      		movw r24,r16
 1714 04cc 0E94 0000 		call prvUnlockQueue
 994:../../freeRtos/Source/queue.c **** 				if( !xTaskResumeAll() )
 1716               	.LM164:
 1717 04d0 0E94 0000 		call xTaskResumeAll
 1718 04d4 8823      		tst r24
 1719 04d6 01F0      		breq .L95
 1720               	.L90:
 1721 04d8 31E0      		ldi r19,lo8(1)
 1722 04da 00C0      		rjmp .L76
 1723               	.L95:
 996:../../freeRtos/Source/queue.c **** 					portYIELD_WITHIN_API();
 1725               	.LM165:
 1726 04dc 0E94 0000 		call vPortYield
 1727 04e0 00C0      		rjmp .L90
 1728               	.L89:
1002:../../freeRtos/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1730               	.LM166:
 1731 04e2 C801      		movw r24,r16
 1732 04e4 0E94 0000 		call prvUnlockQueue
1003:../../freeRtos/Source/queue.c **** 				( void ) xTaskResumeAll();
 1734               	.LM167:
 1735 04e8 0E94 0000 		call xTaskResumeAll
 1736 04ec 00C0      		rjmp .L90
 1737               	.L88:
1008:../../freeRtos/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1739               	.LM168:
 1740 04ee C801      		movw r24,r16
 1741 04f0 0E94 0000 		call prvUnlockQueue
1009:../../freeRtos/Source/queue.c **** 			( void ) xTaskResumeAll();
 1743               	.LM169:
 1744 04f4 0E94 0000 		call xTaskResumeAll
 1745               	.L94:
1011:../../freeRtos/Source/queue.c **** 			return errQUEUE_EMPTY;
 1747               	.LM170:
 1748 04f8 80E0      		ldi r24,0
 1749               	.L83:
 1750               	/* epilogue start */
1014:../../freeRtos/Source/queue.c **** }
 1752               	.LM171:
 1753 04fa 2596      		adiw r28,5
 1754 04fc CDBF      		out __SP_L__,r28
 1755 04fe DEBF      		out __SP_H__,r29
 1756 0500 DF91      		pop r29
 1757 0502 CF91      		pop r28
 1758 0504 1F91      		pop r17
 1759 0506 0F91      		pop r16
 1760 0508 FF90      		pop r15
 1761 050a EF90      		pop r14
 1762 050c DF90      		pop r13
 1763 050e CF90      		pop r12
 1764 0510 BF90      		pop r11
 1765 0512 0895      		ret
 1772               	.Lscope8:
 1774               		.stabd	78,0,0
 1779               	.global	xQueueReceiveFromISR
 1781               	xQueueReceiveFromISR:
 1782               		.stabd	46,0,0
1018:../../freeRtos/Source/queue.c **** {
 1784               	.LM172:
 1785               	.LFBB9:
 1786 0514 0F93      		push r16
 1787 0516 1F93      		push r17
 1788 0518 CF93      		push r28
 1789 051a DF93      		push r29
 1790               	/* prologue: function */
 1791               	/* frame size = 0 */
 1792               	/* stack size = 4 */
 1793               	.L__stack_usage = 4
 1794 051c EC01      		movw r28,r24
 1795 051e 8A01      		movw r16,r20
1025:../../freeRtos/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1797               	.LM173:
 1798 0520 8A8D      		ldd r24,Y+26
 1799 0522 8823      		tst r24
 1800 0524 01F0      		breq .L101
1029:../../freeRtos/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1802               	.LM174:
 1803 0526 CE01      		movw r24,r28
 1804 0528 0E94 0000 		call prvCopyDataFromQueue
1030:../../freeRtos/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1806               	.LM175:
 1807 052c 8A8D      		ldd r24,Y+26
 1808 052e 8150      		subi r24,lo8(-(-1))
 1809 0530 8A8F      		std Y+26,r24
1035:../../freeRtos/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1811               	.LM176:
 1812 0532 8D8D      		ldd r24,Y+29
 1813 0534 8F3F      		cpi r24,lo8(-1)
 1814 0536 01F4      		brne .L98
1037:../../freeRtos/Source/queue.c **** 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 1816               	.LM177:
 1817 0538 8885      		ldd r24,Y+8
 1818 053a 8823      		tst r24
 1819 053c 01F0      		breq .L105
1039:../../freeRtos/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1821               	.LM178:
 1822 053e CE01      		movw r24,r28
 1823 0540 0896      		adiw r24,8
 1824 0542 0E94 0000 		call xTaskRemoveFromEventList
 1825 0546 8823      		tst r24
 1826 0548 01F0      		breq .L105
1043:../../freeRtos/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 1828               	.LM179:
 1829 054a 81E0      		ldi r24,lo8(1)
 1830 054c F801      		movw r30,r16
 1831 054e 8083      		st Z,r24
 1832 0550 00C0      		rjmp .L97
 1833               	.L98:
1051:../../freeRtos/Source/queue.c **** 				++( pxQueue->xRxLock );
 1835               	.LM180:
 1836 0552 8F5F      		subi r24,lo8(-(1))
 1837 0554 8D8F      		std Y+29,r24
 1838               	.L105:
1054:../../freeRtos/Source/queue.c **** 			xReturn = pdPASS;
 1840               	.LM181:
 1841 0556 81E0      		ldi r24,lo8(1)
 1842 0558 00C0      		rjmp .L97
 1843               	.L101:
1058:../../freeRtos/Source/queue.c **** 			xReturn = pdFAIL;
 1845               	.LM182:
 1846 055a 80E0      		ldi r24,0
 1847               	.L97:
 1848               	/* epilogue start */
1065:../../freeRtos/Source/queue.c **** }
 1850               	.LM183:
 1851 055c DF91      		pop r29
 1852 055e CF91      		pop r28
 1853 0560 1F91      		pop r17
 1854 0562 0F91      		pop r16
 1855 0564 0895      		ret
 1860               	.Lscope9:
 1862               		.stabd	78,0,0
 1865               	.global	uxQueueMessagesWaiting
 1867               	uxQueueMessagesWaiting:
 1868               		.stabd	46,0,0
1069:../../freeRtos/Source/queue.c **** {
 1870               	.LM184:
 1871               	.LFBB10:
 1872               	/* prologue: function */
 1873               	/* frame size = 0 */
 1874               	/* stack size = 0 */
 1875               	.L__stack_usage = 0
1072:../../freeRtos/Source/queue.c **** 	taskENTER_CRITICAL();
 1877               	.LM185:
 1878               	/* #APP */
 1879               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 1880 0566 0FB6      		in		__tmp_reg__, __SREG__
 1881               	 ;  0 "" 2
 1882               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 1883 0568 F894      		cli
 1884               	 ;  0 "" 2
 1885               	 ;  1072 "../../freeRtos/Source/queue.c" 1
 1886 056a 0F92      		push	__tmp_reg__
 1887               	 ;  0 "" 2
1073:../../freeRtos/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 1889               	.LM186:
 1890               	/* #NOAPP */
 1891 056c FC01      		movw r30,r24
 1892 056e 828D      		ldd r24,Z+26
1074:../../freeRtos/Source/queue.c **** 	taskEXIT_CRITICAL();
 1894               	.LM187:
 1895               	/* #APP */
 1896               	 ;  1074 "../../freeRtos/Source/queue.c" 1
 1897 0570 0F90      		pop		__tmp_reg__
 1898               	 ;  0 "" 2
 1899               	 ;  1074 "../../freeRtos/Source/queue.c" 1
 1900 0572 0FBE      		out		__SREG__, __tmp_reg__
 1901               	 ;  0 "" 2
1077:../../freeRtos/Source/queue.c **** }
 1903               	.LM188:
 1904               	/* #NOAPP */
 1905 0574 0895      		ret
 1910               	.Lscope10:
 1912               		.stabd	78,0,0
 1915               	.global	uxQueueMessagesWaitingFromISR
 1917               	uxQueueMessagesWaitingFromISR:
 1918               		.stabd	46,0,0
1081:../../freeRtos/Source/queue.c **** {
 1920               	.LM189:
 1921               	.LFBB11:
 1922               	/* prologue: function */
 1923               	/* frame size = 0 */
 1924               	/* stack size = 0 */
 1925               	.L__stack_usage = 0
1084:../../freeRtos/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 1927               	.LM190:
 1928 0576 FC01      		movw r30,r24
 1929 0578 828D      		ldd r24,Z+26
1087:../../freeRtos/Source/queue.c **** }
 1931               	.LM191:
 1932 057a 0895      		ret
 1937               	.Lscope11:
 1939               		.stabd	78,0,0
 1942               	.global	vQueueDelete
 1944               	vQueueDelete:
 1945               		.stabd	46,0,0
1091:../../freeRtos/Source/queue.c **** {
 1947               	.LM192:
 1948               	.LFBB12:
 1949 057c CF93      		push r28
 1950 057e DF93      		push r29
 1951               	/* prologue: function */
 1952               	/* frame size = 0 */
 1953               	/* stack size = 2 */
 1954               	.L__stack_usage = 2
 1955 0580 EC01      		movw r28,r24
1094:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 1957               	.LM193:
 1958 0582 8881      		ld r24,Y
 1959 0584 9981      		ldd r25,Y+1
 1960 0586 0E94 0000 		call vPortFree
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
 1962               	.LM194:
 1963 058a CE01      		movw r24,r28
 1964               	/* epilogue start */
1096:../../freeRtos/Source/queue.c **** }
 1966               	.LM195:
 1967 058c DF91      		pop r29
 1968 058e CF91      		pop r28
1095:../../freeRtos/Source/queue.c **** 	vPortFree( pxQueue );
 1970               	.LM196:
 1971 0590 0C94 0000 		jmp vPortFree
 1973               	.Lscope12:
 1975               		.stabd	78,0,0
 1978               	.global	xQueueIsQueueEmptyFromISR
 1980               	xQueueIsQueueEmptyFromISR:
 1981               		.stabd	46,0,0
1228:../../freeRtos/Source/queue.c **** {
 1983               	.LM197:
 1984               	.LFBB13:
 1985               	/* prologue: function */
 1986               	/* frame size = 0 */
 1987               	/* stack size = 0 */
 1988               	.L__stack_usage = 0
1231:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1990               	.LM198:
 1991 0594 FC01      		movw r30,r24
 1992 0596 928D      		ldd r25,Z+26
 1993 0598 81E0      		ldi r24,lo8(1)
 1994 059a 9111      		cpse r25,__zero_reg__
 1995 059c 80E0      		ldi r24,0
 1996               	.L110:
1234:../../freeRtos/Source/queue.c **** }
 1998               	.LM199:
 1999 059e 0895      		ret
 2001               	.Lscope13:
 2003               		.stabd	78,0,0
 2006               	.global	xQueueIsQueueFullFromISR
 2008               	xQueueIsQueueFullFromISR:
 2009               		.stabd	46,0,0
1244:../../freeRtos/Source/queue.c **** 
1245:../../freeRtos/Source/queue.c **** 	return xReturn;
1246:../../freeRtos/Source/queue.c **** }
1247:../../freeRtos/Source/queue.c **** /*-----------------------------------------------------------*/
1248:../../freeRtos/Source/queue.c **** 
1249:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1250:../../freeRtos/Source/queue.c **** {
 2011               	.LM200:
 2012               	.LFBB14:
 2013               	/* prologue: function */
 2014               	/* frame size = 0 */
 2015               	/* stack size = 0 */
 2016               	.L__stack_usage = 0
 2017 05a0 FC01      		movw r30,r24
1251:../../freeRtos/Source/queue.c **** signed portBASE_TYPE xReturn;
1252:../../freeRtos/Source/queue.c **** 
1253:../../freeRtos/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 2019               	.LM201:
 2020 05a2 228D      		ldd r18,Z+26
 2021 05a4 81E0      		ldi r24,lo8(1)
 2022 05a6 938D      		ldd r25,Z+27
 2023 05a8 2913      		cpse r18,r25
 2024 05aa 80E0      		ldi r24,0
 2025               	.L115:
1254:../../freeRtos/Source/queue.c **** 
1255:../../freeRtos/Source/queue.c **** 	return xReturn;
1256:../../freeRtos/Source/queue.c **** }
 2027               	.LM202:
 2028 05ac 0895      		ret
 2030               	.Lscope14:
 2032               		.stabd	78,0,0
 2034               	.Letext0:
 2035               		.ident	"GCC: (GNU) 4.8.2"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccYezVed.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYezVed.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYezVed.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYezVed.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccYezVed.s:6      *ABS*:000000000000003a __RAMPY__
     /tmp/ccYezVed.s:7      *ABS*:0000000000000039 __RAMPX__
     /tmp/ccYezVed.s:8      *ABS*:0000000000000038 __RAMPD__
     /tmp/ccYezVed.s:9      *ABS*:0000000000000034 __CCP__
     /tmp/ccYezVed.s:10     *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYezVed.s:11     *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYezVed.s:486    .text:0000000000000000 prvCopyDataToQueue
     /tmp/ccYezVed.s:592    .text:0000000000000080 prvCopyDataFromQueue
     /tmp/ccYezVed.s:645    .text:00000000000000b4 prvUnlockQueue
     /tmp/ccYezVed.s:792    .text:0000000000000130 xQueueCreate
     /tmp/ccYezVed.s:928    .text:00000000000001c6 xQueueCreateExternal
     /tmp/ccYezVed.s:1063   .text:000000000000025a xQueueGenericSend
     /tmp/ccYezVed.s:1364   .text:0000000000000380 xQueueGenericSendFromISR
     /tmp/ccYezVed.s:1450   .text:00000000000003d0 xQueueGenericReceive
     /tmp/ccYezVed.s:1781   .text:0000000000000514 xQueueReceiveFromISR
     /tmp/ccYezVed.s:1867   .text:0000000000000566 uxQueueMessagesWaiting
     /tmp/ccYezVed.s:1917   .text:0000000000000576 uxQueueMessagesWaitingFromISR
     /tmp/ccYezVed.s:1944   .text:000000000000057c vQueueDelete
     /tmp/ccYezVed.s:1980   .text:0000000000000594 xQueueIsQueueEmptyFromISR
     /tmp/ccYezVed.s:2008   .text:00000000000005a0 xQueueIsQueueFullFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
pvPortMalloc
vListInitialise
vPortFree
vPortYield
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
