   1               		.file	"tasks.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 445               		.data
 446               	.LC0:
 447 0000 2573 0909 		.string	"%s\t\t%c\t%u\t%u\t%u\r\n"
 447      2563 0925 
 447      7509 2575 
 447      0925 750D 
 447      0A00 
 448               		.text
 454               	prvListTaskWithinSingleList:
 455               		.stabd	46,0,0
   1:../../freeRtos/Source/tasks.c **** /*
   2:../../freeRtos/Source/tasks.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/Source/tasks.c **** 
   4:../../freeRtos/Source/tasks.c ****     ***************************************************************************
   5:../../freeRtos/Source/tasks.c ****     *                                                                         *
   6:../../freeRtos/Source/tasks.c ****     * If you are:                                                             *
   7:../../freeRtos/Source/tasks.c ****     *                                                                         *
   8:../../freeRtos/Source/tasks.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/Source/tasks.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/Source/tasks.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/Source/tasks.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/Source/tasks.c ****     *                                                                         *
  13:../../freeRtos/Source/tasks.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/Source/tasks.c ****     *                                                                         *
  15:../../freeRtos/Source/tasks.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/Source/tasks.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/Source/tasks.c ****     *                                                                         *
  18:../../freeRtos/Source/tasks.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/Source/tasks.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/Source/tasks.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/Source/tasks.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/Source/tasks.c ****     *                                                                         *
  23:../../freeRtos/Source/tasks.c ****     ***************************************************************************
  24:../../freeRtos/Source/tasks.c **** 
  25:../../freeRtos/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/Source/tasks.c **** 
  27:../../freeRtos/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/Source/tasks.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/Source/tasks.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/Source/tasks.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/Source/tasks.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/Source/tasks.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/Source/tasks.c ****     FreeRTOS WEB site.
  41:../../freeRtos/Source/tasks.c **** 
  42:../../freeRtos/Source/tasks.c ****     1 tab == 4 spaces!
  43:../../freeRtos/Source/tasks.c **** 
  44:../../freeRtos/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/Source/tasks.c ****     contact details.
  46:../../freeRtos/Source/tasks.c **** 
  47:../../freeRtos/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/Source/tasks.c ****     critical systems.
  49:../../freeRtos/Source/tasks.c **** 
  50:../../freeRtos/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/Source/tasks.c ****     licensing and training services.
  52:../../freeRtos/Source/tasks.c **** */
  53:../../freeRtos/Source/tasks.c **** 
  54:../../freeRtos/Source/tasks.c **** 
  55:../../freeRtos/Source/tasks.c **** #include <stdio.h>
  56:../../freeRtos/Source/tasks.c **** #include <stdlib.h>
  57:../../freeRtos/Source/tasks.c **** #include <string.h>
  58:../../freeRtos/Source/tasks.c **** 
  59:../../freeRtos/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../../freeRtos/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../../freeRtos/Source/tasks.c **** task.h is included from an application file. */
  62:../../freeRtos/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../../freeRtos/Source/tasks.c **** 
  64:../../freeRtos/Source/tasks.c **** #include "FreeRTOS.h"
  65:../../freeRtos/Source/tasks.c **** #include "task.h"
  66:../../freeRtos/Source/tasks.c **** #include "StackMacros.h"
  67:../../freeRtos/Source/tasks.c **** 
  68:../../freeRtos/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  69:../../freeRtos/Source/tasks.c **** 
  70:../../freeRtos/Source/tasks.c **** /*
  71:../../freeRtos/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  72:../../freeRtos/Source/tasks.c ****  */
  73:../../freeRtos/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  74:../../freeRtos/Source/tasks.c **** 
  75:../../freeRtos/Source/tasks.c **** /*
  76:../../freeRtos/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  77:../../freeRtos/Source/tasks.c ****  * and stores the context of the task.
  78:../../freeRtos/Source/tasks.c ****  */
  79:../../freeRtos/Source/tasks.c **** typedef struct tskTaskControlBlock
  80:../../freeRtos/Source/tasks.c **** {
  81:../../freeRtos/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  82:../../freeRtos/Source/tasks.c **** 
  83:../../freeRtos/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  84:../../freeRtos/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  85:../../freeRtos/Source/tasks.c **** 	#endif	
  86:../../freeRtos/Source/tasks.c **** 	
  87:../../freeRtos/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  88:../../freeRtos/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  89:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  90:../../freeRtos/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  91:../../freeRtos/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  92:../../freeRtos/Source/tasks.c **** 
  93:../../freeRtos/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  94:../../freeRtos/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  95:../../freeRtos/Source/tasks.c **** 	#endif
  96:../../freeRtos/Source/tasks.c **** 
  97:../../freeRtos/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  98:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
  99:../../freeRtos/Source/tasks.c **** 	#endif
 100:../../freeRtos/Source/tasks.c **** 
 101:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 102:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 103:../../freeRtos/Source/tasks.c **** 	#endif
 104:../../freeRtos/Source/tasks.c **** 
 105:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 106:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 107:../../freeRtos/Source/tasks.c **** 	#endif
 108:../../freeRtos/Source/tasks.c **** 
 109:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 110:../../freeRtos/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 111:../../freeRtos/Source/tasks.c **** 	#endif
 112:../../freeRtos/Source/tasks.c **** 
 113:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 114:../../freeRtos/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 115:../../freeRtos/Source/tasks.c **** 	#endif
 116:../../freeRtos/Source/tasks.c **** 
 117:../../freeRtos/Source/tasks.c **** } tskTCB;
 118:../../freeRtos/Source/tasks.c **** 
 119:../../freeRtos/Source/tasks.c **** 
 120:../../freeRtos/Source/tasks.c **** /*
 121:../../freeRtos/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 122:../../freeRtos/Source/tasks.c ****  * than file scope.
 123:../../freeRtos/Source/tasks.c ****  */
 124:../../freeRtos/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 125:../../freeRtos/Source/tasks.c **** 	#define static
 126:../../freeRtos/Source/tasks.c **** #endif
 127:../../freeRtos/Source/tasks.c **** 
 128:../../freeRtos/Source/tasks.c **** /*lint -e956 */
 129:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 130:../../freeRtos/Source/tasks.c **** 
 131:../../freeRtos/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 132:../../freeRtos/Source/tasks.c **** 
 133:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 134:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 135:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 136:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 137:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 138:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 139:../../freeRtos/Source/tasks.c **** 
 140:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 141:../../freeRtos/Source/tasks.c **** 
 142:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted 
 143:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 144:../../freeRtos/Source/tasks.c **** 
 145:../../freeRtos/Source/tasks.c **** #endif
 146:../../freeRtos/Source/tasks.c **** 
 147:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 148:../../freeRtos/Source/tasks.c **** 
 149:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 150:../../freeRtos/Source/tasks.c **** 
 151:../../freeRtos/Source/tasks.c **** #endif
 152:../../freeRtos/Source/tasks.c **** 
 153:../../freeRtos/Source/tasks.c **** /* File private variables. --------------------------------*/
 154:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 155:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
 156:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 157:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 158:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 159:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 160:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 161:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 162:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 163:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
 164:../../freeRtos/Source/tasks.c **** 
 165:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 166:../../freeRtos/Source/tasks.c **** 
 167:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 168:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 169:../../freeRtos/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 170:../../freeRtos/Source/tasks.c **** 
 171:../../freeRtos/Source/tasks.c **** #endif
 172:../../freeRtos/Source/tasks.c **** 
 173:../../freeRtos/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 174:../../freeRtos/Source/tasks.c **** 
 175:../../freeRtos/Source/tasks.c **** /*
 176:../../freeRtos/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 177:../../freeRtos/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 178:../../freeRtos/Source/tasks.c ****  */
 179:../../freeRtos/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5 )
 180:../../freeRtos/Source/tasks.c **** 
 181:../../freeRtos/Source/tasks.c **** /*
 182:../../freeRtos/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 183:../../freeRtos/Source/tasks.c ****  */
 184:../../freeRtos/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 185:../../freeRtos/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 186:../../freeRtos/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 187:../../freeRtos/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 188:../../freeRtos/Source/tasks.c **** 
 189:../../freeRtos/Source/tasks.c **** /*
 190:../../freeRtos/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 191:../../freeRtos/Source/tasks.c ****  */
 192:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 193:../../freeRtos/Source/tasks.c **** 
 194:../../freeRtos/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 195:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 196:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 197:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 198:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 199:../../freeRtos/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255;
 200:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 201:../../freeRtos/Source/tasks.c **** 
 202:../../freeRtos/Source/tasks.c **** #endif
 203:../../freeRtos/Source/tasks.c **** 
 204:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 205:../../freeRtos/Source/tasks.c **** 
 206:../../freeRtos/Source/tasks.c **** /*
 207:../../freeRtos/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 208:../../freeRtos/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 209:../../freeRtos/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 210:../../freeRtos/Source/tasks.c ****  * it if not using the facility.
 211:../../freeRtos/Source/tasks.c ****  */
 212:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 213:../../freeRtos/Source/tasks.c **** 
 214:../../freeRtos/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 215:../../freeRtos/Source/tasks.c **** 	{																								\
 216:../../freeRtos/Source/tasks.c **** 		if( xTracing )																				\
 217:../../freeRtos/Source/tasks.c **** 		{																							\
 218:../../freeRtos/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 219:../../freeRtos/Source/tasks.c **** 			{																						\
 220:../../freeRtos/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 221:../../freeRtos/Source/tasks.c **** 				{																					\
 222:../../freeRtos/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 223:../../freeRtos/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;		\
 224:../../freeRtos/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 225:../../freeRtos/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;	\
 226:../../freeRtos/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 227:../../freeRtos/Source/tasks.c **** 				}																					\
 228:../../freeRtos/Source/tasks.c **** 				else																				\
 229:../../freeRtos/Source/tasks.c **** 				{																					\
 230:../../freeRtos/Source/tasks.c **** 					xTracing = pdFALSE;																\
 231:../../freeRtos/Source/tasks.c **** 				}																					\
 232:../../freeRtos/Source/tasks.c **** 			}																						\
 233:../../freeRtos/Source/tasks.c **** 		}																							\
 234:../../freeRtos/Source/tasks.c **** 	}
 235:../../freeRtos/Source/tasks.c **** 
 236:../../freeRtos/Source/tasks.c **** #else
 237:../../freeRtos/Source/tasks.c **** 
 238:../../freeRtos/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 239:../../freeRtos/Source/tasks.c **** 
 240:../../freeRtos/Source/tasks.c **** #endif
 241:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 242:../../freeRtos/Source/tasks.c **** 
 243:../../freeRtos/Source/tasks.c **** /*
 244:../../freeRtos/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 245:../../freeRtos/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 246:../../freeRtos/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 247:../../freeRtos/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 248:../../freeRtos/Source/tasks.c ****  * executing task has been rescheduled.
 249:../../freeRtos/Source/tasks.c ****  */
 250:../../freeRtos/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																			\
 251:../../freeRtos/Source/tasks.c **** {																												\
 252:../../freeRtos/Source/tasks.c **** 	if( pxTCB->uxPriority > uxTopReadyPriority )																\
 253:../../freeRtos/Source/tasks.c **** 	{																											\
 254:../../freeRtos/Source/tasks.c **** 		uxTopReadyPriority = pxTCB->uxPriority;																	\
 255:../../freeRtos/Source/tasks.c **** 	}																											\
 256:../../freeRtos/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListIte
 257:../../freeRtos/Source/tasks.c **** }
 258:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 259:../../freeRtos/Source/tasks.c **** 
 260:../../freeRtos/Source/tasks.c **** /*
 261:../../freeRtos/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 262:../../freeRtos/Source/tasks.c ****  * any require waking.
 263:../../freeRtos/Source/tasks.c ****  *
 264:../../freeRtos/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 265:../../freeRtos/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 266:../../freeRtos/Source/tasks.c ****  * any further down the list.
 267:../../freeRtos/Source/tasks.c ****  */
 268:../../freeRtos/Source/tasks.c **** #define prvCheckDelayedTasks()																						\
 269:../../freeRtos/Source/tasks.c **** {																													\
 270:../../freeRtos/Source/tasks.c **** register tskTCB *pxTCB;																								\
 271:../../freeRtos/Source/tasks.c **** 																													\
 272:../../freeRtos/Source/tasks.c **** 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
 273:../../freeRtos/Source/tasks.c **** 	{																												\
 274:../../freeRtos/Source/tasks.c **** 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
 275:../../freeRtos/Source/tasks.c **** 		{																											\
 276:../../freeRtos/Source/tasks.c **** 			break;																									\
 277:../../freeRtos/Source/tasks.c **** 		}																											\
 278:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxTCB->xGenericListItem ) );																\
 279:../../freeRtos/Source/tasks.c **** 		/* Is the task waiting on an event also? */																	\
 280:../../freeRtos/Source/tasks.c **** 		if( pxTCB->xEventListItem.pvContainer )																		\
 281:../../freeRtos/Source/tasks.c **** 		{																											\
 282:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xEventListItem ) );																\
 283:../../freeRtos/Source/tasks.c **** 		}																											\
 284:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxTCB );																			\
 285:../../freeRtos/Source/tasks.c **** 	}																												\
 286:../../freeRtos/Source/tasks.c **** }
 287:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 288:../../freeRtos/Source/tasks.c **** 
 289:../../freeRtos/Source/tasks.c **** /*
 290:../../freeRtos/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 291:../../freeRtos/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 292:../../freeRtos/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 293:../../freeRtos/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 294:../../freeRtos/Source/tasks.c ****  */
 295:../../freeRtos/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskT
 296:../../freeRtos/Source/tasks.c **** 
 297:../../freeRtos/Source/tasks.c **** 
 298:../../freeRtos/Source/tasks.c **** /* File private functions. --------------------------------*/
 299:../../freeRtos/Source/tasks.c **** 
 300:../../freeRtos/Source/tasks.c **** /*
 301:../../freeRtos/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 302:../../freeRtos/Source/tasks.c ****  * into the TCB structure.
 303:../../freeRtos/Source/tasks.c ****  */
 304:../../freeRtos/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 305:../../freeRtos/Source/tasks.c **** 
 306:../../freeRtos/Source/tasks.c **** /*
 307:../../freeRtos/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 308:../../freeRtos/Source/tasks.c ****  * automatically upon the creation of the first task.
 309:../../freeRtos/Source/tasks.c ****  */
 310:../../freeRtos/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 311:../../freeRtos/Source/tasks.c **** 
 312:../../freeRtos/Source/tasks.c **** /*
 313:../../freeRtos/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 314:../../freeRtos/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 315:../../freeRtos/Source/tasks.c ****  * creation of the first user task.
 316:../../freeRtos/Source/tasks.c ****  *
 317:../../freeRtos/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 318:../../freeRtos/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 319:../../freeRtos/Source/tasks.c ****  *
 320:../../freeRtos/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 321:../../freeRtos/Source/tasks.c ****  *
 322:../../freeRtos/Source/tasks.c ****  */
 323:../../freeRtos/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 324:../../freeRtos/Source/tasks.c **** 
 325:../../freeRtos/Source/tasks.c **** /*
 326:../../freeRtos/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 327:../../freeRtos/Source/tasks.c ****  * including the stack pointed to by the TCB.
 328:../../freeRtos/Source/tasks.c ****  *
 329:../../freeRtos/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 330:../../freeRtos/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 331:../../freeRtos/Source/tasks.c ****  */
 332:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
 333:../../freeRtos/Source/tasks.c **** 
 334:../../freeRtos/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 335:../../freeRtos/Source/tasks.c **** 
 336:../../freeRtos/Source/tasks.c **** #endif
 337:../../freeRtos/Source/tasks.c **** 
 338:../../freeRtos/Source/tasks.c **** /*
 339:../../freeRtos/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 340:../../freeRtos/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 341:../../freeRtos/Source/tasks.c ****  * and its TCB deleted.
 342:../../freeRtos/Source/tasks.c ****  */
 343:../../freeRtos/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 344:../../freeRtos/Source/tasks.c **** 
 345:../../freeRtos/Source/tasks.c **** /*
 346:../../freeRtos/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 347:../../freeRtos/Source/tasks.c ****  * allocation was successful.
 348:../../freeRtos/Source/tasks.c ****  */
 349:../../freeRtos/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 350:../../freeRtos/Source/tasks.c **** 
 351:../../freeRtos/Source/tasks.c **** /*
 352:../../freeRtos/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 353:../../freeRtos/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 354:../../freeRtos/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 355:../../freeRtos/Source/tasks.c ****  * within just that list.
 356:../../freeRtos/Source/tasks.c ****  *
 357:../../freeRtos/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 358:../../freeRtos/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 359:../../freeRtos/Source/tasks.c ****  */
 360:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 361:../../freeRtos/Source/tasks.c **** 
 362:../../freeRtos/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 363:../../freeRtos/Source/tasks.c **** 
 364:../../freeRtos/Source/tasks.c **** #endif
 365:../../freeRtos/Source/tasks.c **** 
 366:../../freeRtos/Source/tasks.c **** /*
 367:../../freeRtos/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 368:../../freeRtos/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 369:../../freeRtos/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 370:../../freeRtos/Source/tasks.c ****  */
 371:../../freeRtos/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 372:../../freeRtos/Source/tasks.c **** 
 373:../../freeRtos/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 374:../../freeRtos/Source/tasks.c **** 
 375:../../freeRtos/Source/tasks.c **** #endif
 376:../../freeRtos/Source/tasks.c **** 
 377:../../freeRtos/Source/tasks.c **** 
 378:../../freeRtos/Source/tasks.c **** /*lint +e956 */
 379:../../freeRtos/Source/tasks.c **** 
 380:../../freeRtos/Source/tasks.c **** 
 381:../../freeRtos/Source/tasks.c **** 
 382:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
 383:../../freeRtos/Source/tasks.c ****  * TASK CREATION API documented in task.h
 384:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
 385:../../freeRtos/Source/tasks.c **** 
 386:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 387:../../freeRtos/Source/tasks.c **** {
 388:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xReturn;
 389:../../freeRtos/Source/tasks.c **** tskTCB * pxNewTCB;
 390:../../freeRtos/Source/tasks.c **** 
 391:../../freeRtos/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 392:../../freeRtos/Source/tasks.c **** 	checking that the allocation was successful. */
 393:../../freeRtos/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 394:../../freeRtos/Source/tasks.c **** 
 395:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
 396:../../freeRtos/Source/tasks.c **** 	{
 397:../../freeRtos/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 398:../../freeRtos/Source/tasks.c **** 
 399:../../freeRtos/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 400:../../freeRtos/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 401:../../freeRtos/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 402:../../freeRtos/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
 403:../../freeRtos/Source/tasks.c **** 			{
 404:../../freeRtos/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 405:../../freeRtos/Source/tasks.c **** 			}
 406:../../freeRtos/Source/tasks.c **** 			else
 407:../../freeRtos/Source/tasks.c **** 			{
 408:../../freeRtos/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 409:../../freeRtos/Source/tasks.c **** 			}
 410:../../freeRtos/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 411:../../freeRtos/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 412:../../freeRtos/Source/tasks.c **** 
 413:../../freeRtos/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 414:../../freeRtos/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 415:../../freeRtos/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 416:../../freeRtos/Source/tasks.c **** 		required by the port. */
 417:../../freeRtos/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 418:../../freeRtos/Source/tasks.c **** 		{
 419:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 420:../../freeRtos/Source/tasks.c **** //			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long )
 421:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( uint16_t ) pxTopOfStack ) & ( ( uint16_t ) ~portBYTE_A
 422:../../freeRtos/Source/tasks.c **** 		}
 423:../../freeRtos/Source/tasks.c **** 		#else
 424:../../freeRtos/Source/tasks.c **** 		{
 425:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 426:../../freeRtos/Source/tasks.c **** 
 427:../../freeRtos/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 428:../../freeRtos/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 429:../../freeRtos/Source/tasks.c **** 			other extreme of the stack space. */
 430:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 431:../../freeRtos/Source/tasks.c **** 		}
 432:../../freeRtos/Source/tasks.c **** 		#endif
 433:../../freeRtos/Source/tasks.c **** 
 434:../../freeRtos/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 435:../../freeRtos/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 436:../../freeRtos/Source/tasks.c **** 
 437:../../freeRtos/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 438:../../freeRtos/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 439:../../freeRtos/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 440:../../freeRtos/Source/tasks.c **** 		the	top of stack variable is updated. */
 441:../../freeRtos/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 442:../../freeRtos/Source/tasks.c **** 		{
 443:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 444:../../freeRtos/Source/tasks.c **** 		}
 445:../../freeRtos/Source/tasks.c **** 		#else
 446:../../freeRtos/Source/tasks.c **** 		{
 447:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 448:../../freeRtos/Source/tasks.c **** 		}
 449:../../freeRtos/Source/tasks.c **** 		#endif
 450:../../freeRtos/Source/tasks.c **** 
 451:../../freeRtos/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 452:../../freeRtos/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 453:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 454:../../freeRtos/Source/tasks.c **** 		{
 455:../../freeRtos/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 456:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 457:../../freeRtos/Source/tasks.c **** 			{
 458:../../freeRtos/Source/tasks.c **** 				/* As this is the first task it must also be the current task. */
 459:../../freeRtos/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 460:../../freeRtos/Source/tasks.c **** 
 461:../../freeRtos/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
 462:../../freeRtos/Source/tasks.c **** 				initialisation required.  We will not recover if this call
 463:../../freeRtos/Source/tasks.c **** 				fails, but we will report the failure. */
 464:../../freeRtos/Source/tasks.c **** 				prvInitialiseTaskLists();
 465:../../freeRtos/Source/tasks.c **** 			}
 466:../../freeRtos/Source/tasks.c **** 			else
 467:../../freeRtos/Source/tasks.c **** 			{
 468:../../freeRtos/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 469:../../freeRtos/Source/tasks.c **** 				current task if it is the highest priority task to be created
 470:../../freeRtos/Source/tasks.c **** 				so far. */
 471:../../freeRtos/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 472:../../freeRtos/Source/tasks.c **** 				{
 473:../../freeRtos/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 474:../../freeRtos/Source/tasks.c **** 					{
 475:../../freeRtos/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 476:../../freeRtos/Source/tasks.c **** 					}
 477:../../freeRtos/Source/tasks.c **** 				}
 478:../../freeRtos/Source/tasks.c **** 			}
 479:../../freeRtos/Source/tasks.c **** 
 480:../../freeRtos/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 481:../../freeRtos/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 482:../../freeRtos/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 483:../../freeRtos/Source/tasks.c **** 			{
 484:../../freeRtos/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 485:../../freeRtos/Source/tasks.c **** 			}
 486:../../freeRtos/Source/tasks.c **** 
 487:../../freeRtos/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 488:../../freeRtos/Source/tasks.c **** 			{
 489:../../freeRtos/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 490:../../freeRtos/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 491:../../freeRtos/Source/tasks.c **** 			}
 492:../../freeRtos/Source/tasks.c **** 			#endif
 493:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 494:../../freeRtos/Source/tasks.c **** 
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 496:../../freeRtos/Source/tasks.c **** 
 497:../../freeRtos/Source/tasks.c **** 			xReturn = pdPASS;
 498:../../freeRtos/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 499:../../freeRtos/Source/tasks.c **** 		}
 500:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 501:../../freeRtos/Source/tasks.c **** 	}
 502:../../freeRtos/Source/tasks.c **** 	else
 503:../../freeRtos/Source/tasks.c **** 	{
 504:../../freeRtos/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 505:../../freeRtos/Source/tasks.c **** 		traceTASK_CREATE_FAILED( pxNewTCB );
 506:../../freeRtos/Source/tasks.c **** 	}
 507:../../freeRtos/Source/tasks.c **** 
 508:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
 509:../../freeRtos/Source/tasks.c **** 	{
 510:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 511:../../freeRtos/Source/tasks.c **** 		{
 512:../../freeRtos/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 513:../../freeRtos/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 514:../../freeRtos/Source/tasks.c **** 			required.*/
 515:../../freeRtos/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 516:../../freeRtos/Source/tasks.c **** 		}
 517:../../freeRtos/Source/tasks.c **** 
 518:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 519:../../freeRtos/Source/tasks.c **** 		{
 520:../../freeRtos/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 521:../../freeRtos/Source/tasks.c **** 			then it should run now. */
 522:../../freeRtos/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 523:../../freeRtos/Source/tasks.c **** 			{
 524:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 525:../../freeRtos/Source/tasks.c **** 			}
 526:../../freeRtos/Source/tasks.c **** 		}
 527:../../freeRtos/Source/tasks.c **** 	}
 528:../../freeRtos/Source/tasks.c **** 
 529:../../freeRtos/Source/tasks.c **** 	return xReturn;
 530:../../freeRtos/Source/tasks.c **** }
 531:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 532:../../freeRtos/Source/tasks.c **** 
 533:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 534:../../freeRtos/Source/tasks.c **** 
 535:../../freeRtos/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 536:../../freeRtos/Source/tasks.c **** 	{
 537:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 538:../../freeRtos/Source/tasks.c **** 
 539:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 540:../../freeRtos/Source/tasks.c **** 		{
 541:../../freeRtos/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 542:../../freeRtos/Source/tasks.c **** 			deleted. */
 543:../../freeRtos/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 544:../../freeRtos/Source/tasks.c **** 			{
 545:../../freeRtos/Source/tasks.c **** 				pxTaskToDelete = NULL;
 546:../../freeRtos/Source/tasks.c **** 			}
 547:../../freeRtos/Source/tasks.c **** 
 548:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 549:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 550:../../freeRtos/Source/tasks.c **** 
 551:../../freeRtos/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 552:../../freeRtos/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 553:../../freeRtos/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 554:../../freeRtos/Source/tasks.c **** 			scheduler for the TCB and stack. */
 555:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 556:../../freeRtos/Source/tasks.c **** 
 557:../../freeRtos/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 558:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 559:../../freeRtos/Source/tasks.c **** 			{
 560:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 561:../../freeRtos/Source/tasks.c **** 			}
 562:../../freeRtos/Source/tasks.c **** 
 563:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 564:../../freeRtos/Source/tasks.c **** 
 565:../../freeRtos/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 566:../../freeRtos/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 567:../../freeRtos/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 568:../../freeRtos/Source/tasks.c **** 			++uxTasksDeleted;
 569:../../freeRtos/Source/tasks.c **** 
 570:../../freeRtos/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 571:../../freeRtos/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 572:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 573:../../freeRtos/Source/tasks.c **** 
 574:../../freeRtos/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 575:../../freeRtos/Source/tasks.c **** 		}
 576:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 577:../../freeRtos/Source/tasks.c **** 
 578:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 579:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 580:../../freeRtos/Source/tasks.c **** 		{
 581:../../freeRtos/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 582:../../freeRtos/Source/tasks.c **** 			{
 583:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 584:../../freeRtos/Source/tasks.c **** 			}
 585:../../freeRtos/Source/tasks.c **** 		}
 586:../../freeRtos/Source/tasks.c **** 	}
 587:../../freeRtos/Source/tasks.c **** 
 588:../../freeRtos/Source/tasks.c **** #endif
 589:../../freeRtos/Source/tasks.c **** 
 590:../../freeRtos/Source/tasks.c **** 
 591:../../freeRtos/Source/tasks.c **** 
 592:../../freeRtos/Source/tasks.c **** 
 593:../../freeRtos/Source/tasks.c **** 
 594:../../freeRtos/Source/tasks.c **** 
 595:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
 596:../../freeRtos/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 597:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
 598:../../freeRtos/Source/tasks.c **** 
 599:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 600:../../freeRtos/Source/tasks.c **** 
 601:../../freeRtos/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 602:../../freeRtos/Source/tasks.c **** 	{
 603:../../freeRtos/Source/tasks.c **** 	portTickType xTimeToWake;
 604:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 605:../../freeRtos/Source/tasks.c **** 
 606:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 607:../../freeRtos/Source/tasks.c **** 		{
 608:../../freeRtos/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 609:../../freeRtos/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 610:../../freeRtos/Source/tasks.c **** 
 611:../../freeRtos/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 612:../../freeRtos/Source/tasks.c **** 			{
 613:../../freeRtos/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 614:../../freeRtos/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 615:../../freeRtos/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 616:../../freeRtos/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 617:../../freeRtos/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 618:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 619:../../freeRtos/Source/tasks.c **** 				{
 620:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 621:../../freeRtos/Source/tasks.c **** 				}
 622:../../freeRtos/Source/tasks.c **** 			}
 623:../../freeRtos/Source/tasks.c **** 			else
 624:../../freeRtos/Source/tasks.c **** 			{
 625:../../freeRtos/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 626:../../freeRtos/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 627:../../freeRtos/Source/tasks.c **** 				tick time is less than the wake time. */
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 629:../../freeRtos/Source/tasks.c **** 				{
 630:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 631:../../freeRtos/Source/tasks.c **** 				}
 632:../../freeRtos/Source/tasks.c **** 			}
 633:../../freeRtos/Source/tasks.c **** 
 634:../../freeRtos/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 635:../../freeRtos/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 636:../../freeRtos/Source/tasks.c **** 
 637:../../freeRtos/Source/tasks.c **** 			if( xShouldDelay )
 638:../../freeRtos/Source/tasks.c **** 			{
 639:../../freeRtos/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 640:../../freeRtos/Source/tasks.c **** 
 641:../../freeRtos/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 642:../../freeRtos/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 643:../../freeRtos/Source/tasks.c **** 				both lists. */
 644:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 645:../../freeRtos/Source/tasks.c **** 
 646:../../freeRtos/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 647:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 648:../../freeRtos/Source/tasks.c **** 
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 650:../../freeRtos/Source/tasks.c **** 				{
 651:../../freeRtos/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 652:../../freeRtos/Source/tasks.c **** 					overflow list. */
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 654:../../freeRtos/Source/tasks.c **** 				}
 655:../../freeRtos/Source/tasks.c **** 				else
 656:../../freeRtos/Source/tasks.c **** 				{
 657:../../freeRtos/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 658:../../freeRtos/Source/tasks.c **** 					current block list. */
 659:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 660:../../freeRtos/Source/tasks.c **** 				}
 661:../../freeRtos/Source/tasks.c **** 			}
 662:../../freeRtos/Source/tasks.c **** 		}
 663:../../freeRtos/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 664:../../freeRtos/Source/tasks.c **** 
 665:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 666:../../freeRtos/Source/tasks.c **** 		have put ourselves to sleep. */
 667:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 668:../../freeRtos/Source/tasks.c **** 		{
 669:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 670:../../freeRtos/Source/tasks.c **** 		}
 671:../../freeRtos/Source/tasks.c **** 	}
 672:../../freeRtos/Source/tasks.c **** 
 673:../../freeRtos/Source/tasks.c **** #endif
 674:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 675:../../freeRtos/Source/tasks.c **** 
 676:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 677:../../freeRtos/Source/tasks.c **** 
 678:../../freeRtos/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 679:../../freeRtos/Source/tasks.c **** 	{
 680:../../freeRtos/Source/tasks.c **** 	portTickType xTimeToWake;
 681:../../freeRtos/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 682:../../freeRtos/Source/tasks.c **** 
 683:../../freeRtos/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 684:../../freeRtos/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 685:../../freeRtos/Source/tasks.c **** 		{
 686:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
 687:../../freeRtos/Source/tasks.c **** 			{
 688:../../freeRtos/Source/tasks.c **** 				traceTASK_DELAY();
 689:../../freeRtos/Source/tasks.c **** 
 690:../../freeRtos/Source/tasks.c **** 				/* A task that is removed from the event list while the
 691:../../freeRtos/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 692:../../freeRtos/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 693:../../freeRtos/Source/tasks.c **** 				is resumed.
 694:../../freeRtos/Source/tasks.c **** 
 695:../../freeRtos/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 696:../../freeRtos/Source/tasks.c **** 				executing task. */
 697:../../freeRtos/Source/tasks.c **** 
 698:../../freeRtos/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 699:../../freeRtos/Source/tasks.c **** 				not a problem. */
 700:../../freeRtos/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 701:../../freeRtos/Source/tasks.c **** 
 702:../../freeRtos/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 703:../../freeRtos/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 704:../../freeRtos/Source/tasks.c **** 				both lists. */
 705:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 706:../../freeRtos/Source/tasks.c **** 
 707:../../freeRtos/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 708:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 709:../../freeRtos/Source/tasks.c **** 
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 711:../../freeRtos/Source/tasks.c **** 				{
 712:../../freeRtos/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 713:../../freeRtos/Source/tasks.c **** 					overflow list. */
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 715:../../freeRtos/Source/tasks.c **** 				}
 716:../../freeRtos/Source/tasks.c **** 				else
 717:../../freeRtos/Source/tasks.c **** 				{
 718:../../freeRtos/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 719:../../freeRtos/Source/tasks.c **** 					current block list. */
 720:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 721:../../freeRtos/Source/tasks.c **** 				}
 722:../../freeRtos/Source/tasks.c **** 			}
 723:../../freeRtos/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 724:../../freeRtos/Source/tasks.c **** 		}
 725:../../freeRtos/Source/tasks.c **** 
 726:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 727:../../freeRtos/Source/tasks.c **** 		have put ourselves to sleep. */
 728:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 729:../../freeRtos/Source/tasks.c **** 		{
 730:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 731:../../freeRtos/Source/tasks.c **** 		}
 732:../../freeRtos/Source/tasks.c **** 	}
 733:../../freeRtos/Source/tasks.c **** 
 734:../../freeRtos/Source/tasks.c **** #endif
 735:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 736:../../freeRtos/Source/tasks.c **** 
 737:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 738:../../freeRtos/Source/tasks.c **** 
 739:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 740:../../freeRtos/Source/tasks.c **** 	{
 741:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 742:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 743:../../freeRtos/Source/tasks.c **** 
 744:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 745:../../freeRtos/Source/tasks.c **** 		{
 746:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 747:../../freeRtos/Source/tasks.c **** 			priority of the calling function. */
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 749:../../freeRtos/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 750:../../freeRtos/Source/tasks.c **** 		}
 751:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 752:../../freeRtos/Source/tasks.c **** 
 753:../../freeRtos/Source/tasks.c **** 		return uxReturn;
 754:../../freeRtos/Source/tasks.c **** 	}
 755:../../freeRtos/Source/tasks.c **** 
 756:../../freeRtos/Source/tasks.c **** #endif
 757:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 758:../../freeRtos/Source/tasks.c **** 
 759:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 760:../../freeRtos/Source/tasks.c **** 
 761:../../freeRtos/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 762:../../freeRtos/Source/tasks.c **** 	{
 763:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 764:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
 765:../../freeRtos/Source/tasks.c **** 
 766:../../freeRtos/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 767:../../freeRtos/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 768:../../freeRtos/Source/tasks.c **** 		{
 769:../../freeRtos/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - 1;
 770:../../freeRtos/Source/tasks.c **** 		}
 771:../../freeRtos/Source/tasks.c **** 
 772:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 773:../../freeRtos/Source/tasks.c **** 		{
 774:../../freeRtos/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 775:../../freeRtos/Source/tasks.c **** 			{
 776:../../freeRtos/Source/tasks.c **** 				pxTask = NULL;
 777:../../freeRtos/Source/tasks.c **** 			}
 778:../../freeRtos/Source/tasks.c **** 
 779:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 780:../../freeRtos/Source/tasks.c **** 			priority of the calling function. */
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 782:../../freeRtos/Source/tasks.c **** 
 783:../../freeRtos/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 784:../../freeRtos/Source/tasks.c **** 
 785:../../freeRtos/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 786:../../freeRtos/Source/tasks.c **** 			{
 787:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 788:../../freeRtos/Source/tasks.c **** 			}
 789:../../freeRtos/Source/tasks.c **** 			#else
 790:../../freeRtos/Source/tasks.c **** 			{
 791:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 792:../../freeRtos/Source/tasks.c **** 			}
 793:../../freeRtos/Source/tasks.c **** 			#endif
 794:../../freeRtos/Source/tasks.c **** 
 795:../../freeRtos/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 796:../../freeRtos/Source/tasks.c **** 			{
 797:../../freeRtos/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 798:../../freeRtos/Source/tasks.c **** 				priority than the calling task. */
 799:../../freeRtos/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 800:../../freeRtos/Source/tasks.c **** 				{
 801:../../freeRtos/Source/tasks.c **** 					if( pxTask != NULL )
 802:../../freeRtos/Source/tasks.c **** 					{
 803:../../freeRtos/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 804:../../freeRtos/Source/tasks.c **** 						were raising the priority of the currently running task
 805:../../freeRtos/Source/tasks.c **** 						there would be no need to switch as it must have already
 806:../../freeRtos/Source/tasks.c **** 						been the highest priority task. */
 807:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 808:../../freeRtos/Source/tasks.c **** 					}
 809:../../freeRtos/Source/tasks.c **** 				}
 810:../../freeRtos/Source/tasks.c **** 				else if( pxTask == NULL )
 811:../../freeRtos/Source/tasks.c **** 				{
 812:../../freeRtos/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 813:../../freeRtos/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 814:../../freeRtos/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 815:../../freeRtos/Source/tasks.c **** 				}
 816:../../freeRtos/Source/tasks.c **** 
 817:../../freeRtos/Source/tasks.c **** 
 818:../../freeRtos/Source/tasks.c **** 
 819:../../freeRtos/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 820:../../freeRtos/Source/tasks.c **** 				{
 821:../../freeRtos/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 822:../../freeRtos/Source/tasks.c **** 					currently using an inherited priority. */
 823:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 824:../../freeRtos/Source/tasks.c **** 					{
 825:../../freeRtos/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 826:../../freeRtos/Source/tasks.c **** 					}
 827:../../freeRtos/Source/tasks.c **** 
 828:../../freeRtos/Source/tasks.c **** 					/* The base priority gets set whatever. */
 829:../../freeRtos/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 830:../../freeRtos/Source/tasks.c **** 				}
 831:../../freeRtos/Source/tasks.c **** 				#else
 832:../../freeRtos/Source/tasks.c **** 				{
 833:../../freeRtos/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 834:../../freeRtos/Source/tasks.c **** 				}
 835:../../freeRtos/Source/tasks.c **** 				#endif
 836:../../freeRtos/Source/tasks.c **** 
 837:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 838:../../freeRtos/Source/tasks.c **** 
 839:../../freeRtos/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 840:../../freeRtos/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 841:../../freeRtos/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 842:../../freeRtos/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 843:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 844:../../freeRtos/Source/tasks.c **** 				{
 845:../../freeRtos/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 846:../../freeRtos/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 847:../../freeRtos/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 848:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 850:../../freeRtos/Source/tasks.c **** 				}
 851:../../freeRtos/Source/tasks.c **** 
 852:../../freeRtos/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 853:../../freeRtos/Source/tasks.c **** 				{
 854:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 855:../../freeRtos/Source/tasks.c **** 				}
 856:../../freeRtos/Source/tasks.c **** 			}
 857:../../freeRtos/Source/tasks.c **** 		}
 858:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 859:../../freeRtos/Source/tasks.c **** 	}
 860:../../freeRtos/Source/tasks.c **** 
 861:../../freeRtos/Source/tasks.c **** #endif
 862:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 863:../../freeRtos/Source/tasks.c **** 
 864:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 865:../../freeRtos/Source/tasks.c **** 
 866:../../freeRtos/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 867:../../freeRtos/Source/tasks.c **** 	{
 868:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 869:../../freeRtos/Source/tasks.c **** 
 870:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 871:../../freeRtos/Source/tasks.c **** 		{
 872:../../freeRtos/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 873:../../freeRtos/Source/tasks.c **** 			suspended. */
 874:../../freeRtos/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 875:../../freeRtos/Source/tasks.c **** 			{
 876:../../freeRtos/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 877:../../freeRtos/Source/tasks.c **** 			}
 878:../../freeRtos/Source/tasks.c **** 
 879:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 881:../../freeRtos/Source/tasks.c **** 
 882:../../freeRtos/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 883:../../freeRtos/Source/tasks.c **** 
 884:../../freeRtos/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 885:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 886:../../freeRtos/Source/tasks.c **** 
 887:../../freeRtos/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 888:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 889:../../freeRtos/Source/tasks.c **** 			{
 890:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 891:../../freeRtos/Source/tasks.c **** 			}
 892:../../freeRtos/Source/tasks.c **** 
 893:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 894:../../freeRtos/Source/tasks.c **** 		}
 895:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 896:../../freeRtos/Source/tasks.c **** 
 897:../../freeRtos/Source/tasks.c **** 		/* We may have just suspended the current task. */
 898:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 899:../../freeRtos/Source/tasks.c **** 		{
 900:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 901:../../freeRtos/Source/tasks.c **** 		}
 902:../../freeRtos/Source/tasks.c **** 	}
 903:../../freeRtos/Source/tasks.c **** 
 904:../../freeRtos/Source/tasks.c **** #endif
 905:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 906:../../freeRtos/Source/tasks.c **** 
 907:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 908:../../freeRtos/Source/tasks.c **** 
 909:../../freeRtos/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 910:../../freeRtos/Source/tasks.c **** 	{
 911:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 912:../../freeRtos/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 913:../../freeRtos/Source/tasks.c **** 
 914:../../freeRtos/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 915:../../freeRtos/Source/tasks.c **** 		suspended list? */
 916:../../freeRtos/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 917:../../freeRtos/Source/tasks.c **** 		{
 918:../../freeRtos/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 919:../../freeRtos/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 920:../../freeRtos/Source/tasks.c **** 			{
 921:../../freeRtos/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 922:../../freeRtos/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 923:../../freeRtos/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 924:../../freeRtos/Source/tasks.c **** 				specified. */
 925:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 926:../../freeRtos/Source/tasks.c **** 				{
 927:../../freeRtos/Source/tasks.c **** 					xReturn = pdTRUE;
 928:../../freeRtos/Source/tasks.c **** 				}
 929:../../freeRtos/Source/tasks.c **** 			}
 930:../../freeRtos/Source/tasks.c **** 		}
 931:../../freeRtos/Source/tasks.c **** 
 932:../../freeRtos/Source/tasks.c **** 		return xReturn;
 933:../../freeRtos/Source/tasks.c **** 	}
 934:../../freeRtos/Source/tasks.c **** 
 935:../../freeRtos/Source/tasks.c **** #endif
 936:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 937:../../freeRtos/Source/tasks.c **** 
 938:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 939:../../freeRtos/Source/tasks.c **** 
 940:../../freeRtos/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 941:../../freeRtos/Source/tasks.c **** 	{
 942:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 943:../../freeRtos/Source/tasks.c **** 
 944:../../freeRtos/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 945:../../freeRtos/Source/tasks.c **** 		it in the ready list. */
 946:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 947:../../freeRtos/Source/tasks.c **** 
 948:../../freeRtos/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 949:../../freeRtos/Source/tasks.c **** 		currently executing task. */
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 951:../../freeRtos/Source/tasks.c **** 		{
 952:../../freeRtos/Source/tasks.c **** 			portENTER_CRITICAL();
 953:../../freeRtos/Source/tasks.c **** 			{
 954:../../freeRtos/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 955:../../freeRtos/Source/tasks.c **** 				{
 956:../../freeRtos/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
 957:../../freeRtos/Source/tasks.c **** 
 958:../../freeRtos/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
 959:../../freeRtos/Source/tasks.c **** 					lists even if the scheduler is suspended. */
 960:../../freeRtos/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 962:../../freeRtos/Source/tasks.c **** 
 963:../../freeRtos/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
 964:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 965:../../freeRtos/Source/tasks.c **** 					{
 966:../../freeRtos/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 967:../../freeRtos/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 968:../../freeRtos/Source/tasks.c **** 						portYIELD_WITHIN_API();
 969:../../freeRtos/Source/tasks.c **** 					}
 970:../../freeRtos/Source/tasks.c **** 				}
 971:../../freeRtos/Source/tasks.c **** 			}
 972:../../freeRtos/Source/tasks.c **** 			portEXIT_CRITICAL();
 973:../../freeRtos/Source/tasks.c **** 		}
 974:../../freeRtos/Source/tasks.c **** 	}
 975:../../freeRtos/Source/tasks.c **** 
 976:../../freeRtos/Source/tasks.c **** #endif
 977:../../freeRtos/Source/tasks.c **** 
 978:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 979:../../freeRtos/Source/tasks.c **** 
 980:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 981:../../freeRtos/Source/tasks.c **** 
 982:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 983:../../freeRtos/Source/tasks.c **** 	{
 984:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 985:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 986:../../freeRtos/Source/tasks.c **** 
 987:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 988:../../freeRtos/Source/tasks.c **** 
 989:../../freeRtos/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 990:../../freeRtos/Source/tasks.c **** 		{
 991:../../freeRtos/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
 992:../../freeRtos/Source/tasks.c **** 
 993:../../freeRtos/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 994:../../freeRtos/Source/tasks.c **** 			{
 995:../../freeRtos/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 996:../../freeRtos/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 998:../../freeRtos/Source/tasks.c **** 			}
 999:../../freeRtos/Source/tasks.c **** 			else
1000:../../freeRtos/Source/tasks.c **** 			{
1001:../../freeRtos/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1002:../../freeRtos/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1003:../../freeRtos/Source/tasks.c **** 				yield will be performed if necessary. */
1004:../../freeRtos/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1005:../../freeRtos/Source/tasks.c **** 			}
1006:../../freeRtos/Source/tasks.c **** 		}
1007:../../freeRtos/Source/tasks.c **** 
1008:../../freeRtos/Source/tasks.c **** 		return xYieldRequired;
1009:../../freeRtos/Source/tasks.c **** 	}
1010:../../freeRtos/Source/tasks.c **** 
1011:../../freeRtos/Source/tasks.c **** #endif
1012:../../freeRtos/Source/tasks.c **** 
1013:../../freeRtos/Source/tasks.c **** 
1014:../../freeRtos/Source/tasks.c **** 
1015:../../freeRtos/Source/tasks.c **** 
1016:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1017:../../freeRtos/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1018:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1019:../../freeRtos/Source/tasks.c **** 
1020:../../freeRtos/Source/tasks.c **** 
1021:../../freeRtos/Source/tasks.c **** void vTaskStartScheduler( void )
1022:../../freeRtos/Source/tasks.c **** {
1023:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1024:../../freeRtos/Source/tasks.c **** 
1025:../../freeRtos/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1026:../../freeRtos/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
1027:../../freeRtos/Source/tasks.c **** 
1028:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
1029:../../freeRtos/Source/tasks.c **** 	{
1030:../../freeRtos/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1031:../../freeRtos/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1032:../../freeRtos/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1033:../../freeRtos/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1034:../../freeRtos/Source/tasks.c **** 		starts to run.
1035:../../freeRtos/Source/tasks.c **** 
1036:../../freeRtos/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1037:../../freeRtos/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1038:../../freeRtos/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1039:../../freeRtos/Source/tasks.c **** 
1040:../../freeRtos/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1041:../../freeRtos/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
1042:../../freeRtos/Source/tasks.c **** 
1043:../../freeRtos/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1044:../../freeRtos/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1045:../../freeRtos/Source/tasks.c **** 		the run time counter time base. */
1046:../../freeRtos/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1047:../../freeRtos/Source/tasks.c **** 
1048:../../freeRtos/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1049:../../freeRtos/Source/tasks.c **** 		portable interface. */
1050:../../freeRtos/Source/tasks.c **** 		if( xPortStartScheduler() )
1051:../../freeRtos/Source/tasks.c **** 		{
1052:../../freeRtos/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1053:../../freeRtos/Source/tasks.c **** 			function will not return. */
1054:../../freeRtos/Source/tasks.c **** 		}
1055:../../freeRtos/Source/tasks.c **** 		else
1056:../../freeRtos/Source/tasks.c **** 		{
1057:../../freeRtos/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1058:../../freeRtos/Source/tasks.c **** 		}
1059:../../freeRtos/Source/tasks.c **** 	}
1060:../../freeRtos/Source/tasks.c **** }
1061:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1062:../../freeRtos/Source/tasks.c **** 
1063:../../freeRtos/Source/tasks.c **** void vTaskEndScheduler( void )
1064:../../freeRtos/Source/tasks.c **** {
1065:../../freeRtos/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1066:../../freeRtos/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1067:../../freeRtos/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1068:../../freeRtos/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1069:../../freeRtos/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1070:../../freeRtos/Source/tasks.c **** 	vPortEndScheduler();
1071:../../freeRtos/Source/tasks.c **** }
1072:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1073:../../freeRtos/Source/tasks.c **** 
1074:../../freeRtos/Source/tasks.c **** void vTaskSuspendAll( void )
1075:../../freeRtos/Source/tasks.c **** {
1076:../../freeRtos/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1077:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE. */
1078:../../freeRtos/Source/tasks.c **** 	++uxSchedulerSuspended;
1079:../../freeRtos/Source/tasks.c **** }
1080:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1081:../../freeRtos/Source/tasks.c **** 
1082:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1083:../../freeRtos/Source/tasks.c **** {
1084:../../freeRtos/Source/tasks.c **** register tskTCB *pxTCB;
1085:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1086:../../freeRtos/Source/tasks.c **** 
1087:../../freeRtos/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1088:../../freeRtos/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1089:../../freeRtos/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1090:../../freeRtos/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1091:../../freeRtos/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1092:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1093:../../freeRtos/Source/tasks.c **** 	{
1094:../../freeRtos/Source/tasks.c **** 		--uxSchedulerSuspended;
1095:../../freeRtos/Source/tasks.c **** 
1096:../../freeRtos/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1097:../../freeRtos/Source/tasks.c **** 		{
1098:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
1099:../../freeRtos/Source/tasks.c **** 			{
1100:../../freeRtos/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1101:../../freeRtos/Source/tasks.c **** 
1102:../../freeRtos/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1103:../../freeRtos/Source/tasks.c **** 				appropriate ready list. */
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
1105:../../freeRtos/Source/tasks.c **** 				{
1106:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1107:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1109:../../freeRtos/Source/tasks.c **** 
1110:../../freeRtos/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1111:../../freeRtos/Source/tasks.c **** 					the current task then we should yield. */
1112:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1113:../../freeRtos/Source/tasks.c **** 					{
1114:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1115:../../freeRtos/Source/tasks.c **** 					}
1116:../../freeRtos/Source/tasks.c **** 				}
1117:../../freeRtos/Source/tasks.c **** 
1118:../../freeRtos/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1119:../../freeRtos/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1120:../../freeRtos/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1121:../../freeRtos/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1122:../../freeRtos/Source/tasks.c **** 				{
1123:../../freeRtos/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1124:../../freeRtos/Source/tasks.c **** 					{
1125:../../freeRtos/Source/tasks.c **** 						vTaskIncrementTick();
1126:../../freeRtos/Source/tasks.c **** 						--uxMissedTicks;
1127:../../freeRtos/Source/tasks.c **** 					}
1128:../../freeRtos/Source/tasks.c **** 
1129:../../freeRtos/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1130:../../freeRtos/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1131:../../freeRtos/Source/tasks.c **** 					the task actually running. */
1132:../../freeRtos/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1133:../../freeRtos/Source/tasks.c **** 					{
1134:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1135:../../freeRtos/Source/tasks.c **** 					}
1136:../../freeRtos/Source/tasks.c **** 					#endif
1137:../../freeRtos/Source/tasks.c **** 				}
1138:../../freeRtos/Source/tasks.c **** 
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1140:../../freeRtos/Source/tasks.c **** 				{
1141:../../freeRtos/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1142:../../freeRtos/Source/tasks.c **** 					xMissedYield = pdFALSE;
1143:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
1144:../../freeRtos/Source/tasks.c **** 				}
1145:../../freeRtos/Source/tasks.c **** 			}
1146:../../freeRtos/Source/tasks.c **** 		}
1147:../../freeRtos/Source/tasks.c **** 	}
1148:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1149:../../freeRtos/Source/tasks.c **** 
1150:../../freeRtos/Source/tasks.c **** 	return xAlreadyYielded;
1151:../../freeRtos/Source/tasks.c **** }
1152:../../freeRtos/Source/tasks.c **** 
1153:../../freeRtos/Source/tasks.c **** 
1154:../../freeRtos/Source/tasks.c **** 
1155:../../freeRtos/Source/tasks.c **** 
1156:../../freeRtos/Source/tasks.c **** 
1157:../../freeRtos/Source/tasks.c **** 
1158:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1159:../../freeRtos/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1160:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1161:../../freeRtos/Source/tasks.c **** 
1162:../../freeRtos/Source/tasks.c **** 
1163:../../freeRtos/Source/tasks.c **** 
1164:../../freeRtos/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1165:../../freeRtos/Source/tasks.c **** {
1166:../../freeRtos/Source/tasks.c **** portTickType xTicks;
1167:../../freeRtos/Source/tasks.c **** 
1168:../../freeRtos/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1169:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1170:../../freeRtos/Source/tasks.c **** 	{
1171:../../freeRtos/Source/tasks.c **** 		xTicks = xTickCount;
1172:../../freeRtos/Source/tasks.c **** 	}
1173:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1174:../../freeRtos/Source/tasks.c **** 
1175:../../freeRtos/Source/tasks.c **** 	return xTicks;
1176:../../freeRtos/Source/tasks.c **** }
1177:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1178:../../freeRtos/Source/tasks.c **** 
1179:../../freeRtos/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1180:../../freeRtos/Source/tasks.c **** {
1181:../../freeRtos/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1182:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE. */
1183:../../freeRtos/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1184:../../freeRtos/Source/tasks.c **** }
1185:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1186:../../freeRtos/Source/tasks.c **** 
1187:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1188:../../freeRtos/Source/tasks.c **** 
1189:../../freeRtos/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1190:../../freeRtos/Source/tasks.c **** 	{
1191:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1192:../../freeRtos/Source/tasks.c **** 
1193:../../freeRtos/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1194:../../freeRtos/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1195:../../freeRtos/Source/tasks.c **** 
1196:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
1197:../../freeRtos/Source/tasks.c **** 		{
1198:../../freeRtos/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1199:../../freeRtos/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1200:../../freeRtos/Source/tasks.c **** 
1201:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1202:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1203:../../freeRtos/Source/tasks.c **** 
1204:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1205:../../freeRtos/Source/tasks.c **** 
1206:../../freeRtos/Source/tasks.c **** 			do
1207:../../freeRtos/Source/tasks.c **** 			{
1208:../../freeRtos/Source/tasks.c **** 				uxQueue--;
1209:../../freeRtos/Source/tasks.c **** 
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1211:../../freeRtos/Source/tasks.c **** 				{
1212:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1213:../../freeRtos/Source/tasks.c **** 				}
1214:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1215:../../freeRtos/Source/tasks.c **** 
1216:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1217:../../freeRtos/Source/tasks.c **** 			{
1218:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1219:../../freeRtos/Source/tasks.c **** 			}
1220:../../freeRtos/Source/tasks.c **** 
1221:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1222:../../freeRtos/Source/tasks.c **** 			{
1223:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1224:../../freeRtos/Source/tasks.c **** 			}
1225:../../freeRtos/Source/tasks.c **** 
1226:../../freeRtos/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1227:../../freeRtos/Source/tasks.c **** 			{
1228:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1229:../../freeRtos/Source/tasks.c **** 				{
1230:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
1231:../../freeRtos/Source/tasks.c **** 				}
1232:../../freeRtos/Source/tasks.c **** 			}
1233:../../freeRtos/Source/tasks.c **** 			#endif
1234:../../freeRtos/Source/tasks.c **** 
1235:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1236:../../freeRtos/Source/tasks.c **** 			{
1237:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1238:../../freeRtos/Source/tasks.c **** 				{
1239:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
1240:../../freeRtos/Source/tasks.c **** 				}
1241:../../freeRtos/Source/tasks.c **** 			}
1242:../../freeRtos/Source/tasks.c **** 			#endif
1243:../../freeRtos/Source/tasks.c **** 		}
1244:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
1245:../../freeRtos/Source/tasks.c **** 	}
1246:../../freeRtos/Source/tasks.c **** 
1247:../../freeRtos/Source/tasks.c **** #endif
1248:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1249:../../freeRtos/Source/tasks.c **** 
1250:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1251:../../freeRtos/Source/tasks.c **** 
1252:../../freeRtos/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1253:../../freeRtos/Source/tasks.c **** 	{
1254:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1255:../../freeRtos/Source/tasks.c **** 	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1256:../../freeRtos/Source/tasks.c **** 
1257:../../freeRtos/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1258:../../freeRtos/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1259:../../freeRtos/Source/tasks.c **** 
1260:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
1261:../../freeRtos/Source/tasks.c **** 		{
1262:../../freeRtos/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1263:../../freeRtos/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1264:../../freeRtos/Source/tasks.c **** 			buffer. */
1265:../../freeRtos/Source/tasks.c **** 
1266:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1267:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1268:../../freeRtos/Source/tasks.c **** 
1269:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1270:../../freeRtos/Source/tasks.c **** 
1271:../../freeRtos/Source/tasks.c **** 			do
1272:../../freeRtos/Source/tasks.c **** 			{
1273:../../freeRtos/Source/tasks.c **** 				uxQueue--;
1274:../../freeRtos/Source/tasks.c **** 
1275:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1276:../../freeRtos/Source/tasks.c **** 				{
1277:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1278:../../freeRtos/Source/tasks.c **** 				}
1279:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1280:../../freeRtos/Source/tasks.c **** 
1281:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1282:../../freeRtos/Source/tasks.c **** 			{
1283:../../freeRtos/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1284:../../freeRtos/Source/tasks.c **** 			}
1285:../../freeRtos/Source/tasks.c **** 
1286:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1287:../../freeRtos/Source/tasks.c **** 			{
1288:../../freeRtos/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1289:../../freeRtos/Source/tasks.c **** 			}
1290:../../freeRtos/Source/tasks.c **** 
1291:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1292:../../freeRtos/Source/tasks.c **** 			{
1293:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1294:../../freeRtos/Source/tasks.c **** 				{
1295:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, u
1296:../../freeRtos/Source/tasks.c **** 				}
1297:../../freeRtos/Source/tasks.c **** 			}
1298:../../freeRtos/Source/tasks.c **** 			#endif
1299:../../freeRtos/Source/tasks.c **** 
1300:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1301:../../freeRtos/Source/tasks.c **** 			{
1302:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1303:../../freeRtos/Source/tasks.c **** 				{
1304:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotal
1305:../../freeRtos/Source/tasks.c **** 				}
1306:../../freeRtos/Source/tasks.c **** 			}
1307:../../freeRtos/Source/tasks.c **** 			#endif
1308:../../freeRtos/Source/tasks.c **** 		}
1309:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
1310:../../freeRtos/Source/tasks.c **** 	}
1311:../../freeRtos/Source/tasks.c **** 
1312:../../freeRtos/Source/tasks.c **** #endif
1313:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1314:../../freeRtos/Source/tasks.c **** 
1315:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1316:../../freeRtos/Source/tasks.c **** 
1317:../../freeRtos/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1318:../../freeRtos/Source/tasks.c **** 	{
1319:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1320:../../freeRtos/Source/tasks.c **** 		{
1321:../../freeRtos/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1322:../../freeRtos/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1323:../../freeRtos/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1324:../../freeRtos/Source/tasks.c **** 			xTracing = pdTRUE;
1325:../../freeRtos/Source/tasks.c **** 		}
1326:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1327:../../freeRtos/Source/tasks.c **** 	}
1328:../../freeRtos/Source/tasks.c **** 
1329:../../freeRtos/Source/tasks.c **** #endif
1330:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1331:../../freeRtos/Source/tasks.c **** 
1332:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1333:../../freeRtos/Source/tasks.c **** 
1334:../../freeRtos/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1335:../../freeRtos/Source/tasks.c **** 	{
1336:../../freeRtos/Source/tasks.c **** 	unsigned long ulBufferLength;
1337:../../freeRtos/Source/tasks.c **** 
1338:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1339:../../freeRtos/Source/tasks.c **** 			xTracing = pdFALSE;
1340:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1341:../../freeRtos/Source/tasks.c **** 
1342:../../freeRtos/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1343:../../freeRtos/Source/tasks.c **** 
1344:../../freeRtos/Source/tasks.c **** 		return ulBufferLength;
1345:../../freeRtos/Source/tasks.c **** 	}
1346:../../freeRtos/Source/tasks.c **** 
1347:../../freeRtos/Source/tasks.c **** #endif
1348:../../freeRtos/Source/tasks.c **** 
1349:../../freeRtos/Source/tasks.c **** 
1350:../../freeRtos/Source/tasks.c **** 
1351:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1352:../../freeRtos/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1353:../../freeRtos/Source/tasks.c ****  * documented in task.h
1354:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1355:../../freeRtos/Source/tasks.c **** 
1356:../../freeRtos/Source/tasks.c **** 
1357:../../freeRtos/Source/tasks.c **** void vTaskIncrementTick( void )
1358:../../freeRtos/Source/tasks.c **** {
1359:../../freeRtos/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1360:../../freeRtos/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1361:../../freeRtos/Source/tasks.c **** 	tasks to be unblocked. */
1362:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1363:../../freeRtos/Source/tasks.c **** 	{
1364:../../freeRtos/Source/tasks.c **** 		++xTickCount;
1365:../../freeRtos/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
1366:../../freeRtos/Source/tasks.c **** 		{
1367:../../freeRtos/Source/tasks.c **** 			xList *pxTemp;
1368:../../freeRtos/Source/tasks.c **** 
1369:../../freeRtos/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1370:../../freeRtos/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1371:../../freeRtos/Source/tasks.c **** 			an error! */
1372:../../freeRtos/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1373:../../freeRtos/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1374:../../freeRtos/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1375:../../freeRtos/Source/tasks.c **** 			xNumOfOverflows++;
1376:../../freeRtos/Source/tasks.c **** 		}
1377:../../freeRtos/Source/tasks.c **** 
1378:../../freeRtos/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
1380:../../freeRtos/Source/tasks.c **** 	}
1381:../../freeRtos/Source/tasks.c **** 	else
1382:../../freeRtos/Source/tasks.c **** 	{
1383:../../freeRtos/Source/tasks.c **** 		++uxMissedTicks;
1384:../../freeRtos/Source/tasks.c **** 
1385:../../freeRtos/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1386:../../freeRtos/Source/tasks.c **** 		scheduler is locked. */
1387:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1388:../../freeRtos/Source/tasks.c **** 		{
1389:../../freeRtos/Source/tasks.c **** 			extern void vApplicationTickHook( void );
1390:../../freeRtos/Source/tasks.c **** 
1391:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
1392:../../freeRtos/Source/tasks.c **** 		}
1393:../../freeRtos/Source/tasks.c **** 		#endif
1394:../../freeRtos/Source/tasks.c **** 	}
1395:../../freeRtos/Source/tasks.c **** 
1396:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1397:../../freeRtos/Source/tasks.c **** 	{
1398:../../freeRtos/Source/tasks.c **** 		extern void vApplicationTickHook( void );
1399:../../freeRtos/Source/tasks.c **** 
1400:../../freeRtos/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1401:../../freeRtos/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1402:../../freeRtos/Source/tasks.c **** 		if( uxMissedTicks == 0 )
1403:../../freeRtos/Source/tasks.c **** 		{
1404:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
1405:../../freeRtos/Source/tasks.c **** 		}
1406:../../freeRtos/Source/tasks.c **** 	}
1407:../../freeRtos/Source/tasks.c **** 	#endif
1408:../../freeRtos/Source/tasks.c **** 
1409:../../freeRtos/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1410:../../freeRtos/Source/tasks.c **** }
1411:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1412:../../freeRtos/Source/tasks.c **** 
1413:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1414:../../freeRtos/Source/tasks.c **** 
1415:../../freeRtos/Source/tasks.c **** 	void vTaskCleanUpResources( void )
1416:../../freeRtos/Source/tasks.c **** 	{
1417:../../freeRtos/Source/tasks.c **** 	unsigned short usQueue;
1418:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxTCB;
1419:../../freeRtos/Source/tasks.c **** 
1420:../../freeRtos/Source/tasks.c **** 		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
1421:../../freeRtos/Source/tasks.c **** 
1422:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the ready queues. */
1423:../../freeRtos/Source/tasks.c **** 		do
1424:../../freeRtos/Source/tasks.c **** 		{
1425:../../freeRtos/Source/tasks.c **** 			usQueue--;
1426:../../freeRtos/Source/tasks.c **** 
1427:../../freeRtos/Source/tasks.c **** 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
1428:../../freeRtos/Source/tasks.c **** 			{
1429:../../freeRtos/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
1430:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1431:../../freeRtos/Source/tasks.c **** 
1432:../../freeRtos/Source/tasks.c **** 				prvDeleteTCB( ( tskTCB * ) pxTCB );
1433:../../freeRtos/Source/tasks.c **** 			}
1434:../../freeRtos/Source/tasks.c **** 		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
1435:../../freeRtos/Source/tasks.c **** 
1436:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the delayed queue. */
1437:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
1438:../../freeRtos/Source/tasks.c **** 		{
1439:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
1440:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1441:../../freeRtos/Source/tasks.c **** 
1442:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1443:../../freeRtos/Source/tasks.c **** 		}
1444:../../freeRtos/Source/tasks.c **** 
1445:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the overflow delayed queue. */
1446:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
1447:../../freeRtos/Source/tasks.c **** 		{
1448:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
1449:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1450:../../freeRtos/Source/tasks.c **** 
1451:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1452:../../freeRtos/Source/tasks.c **** 		}
1453:../../freeRtos/Source/tasks.c **** 
1454:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1455:../../freeRtos/Source/tasks.c **** 		{
1456:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
1457:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1458:../../freeRtos/Source/tasks.c **** 
1459:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1460:../../freeRtos/Source/tasks.c **** 		}
1461:../../freeRtos/Source/tasks.c **** 	}
1462:../../freeRtos/Source/tasks.c **** 
1463:../../freeRtos/Source/tasks.c **** #endif
1464:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1465:../../freeRtos/Source/tasks.c **** 
1466:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1467:../../freeRtos/Source/tasks.c **** 
1468:../../freeRtos/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
1469:../../freeRtos/Source/tasks.c **** 	{
1470:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1471:../../freeRtos/Source/tasks.c **** 
1472:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1473:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1474:../../freeRtos/Source/tasks.c **** 		{
1475:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1476:../../freeRtos/Source/tasks.c **** 		}
1477:../../freeRtos/Source/tasks.c **** 		else
1478:../../freeRtos/Source/tasks.c **** 		{
1479:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1480:../../freeRtos/Source/tasks.c **** 		}
1481:../../freeRtos/Source/tasks.c **** 
1482:../../freeRtos/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1483:../../freeRtos/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1484:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1485:../../freeRtos/Source/tasks.c **** 			xTCB->pxTaskTag = pxTagValue;
1486:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1487:../../freeRtos/Source/tasks.c **** 	}
1488:../../freeRtos/Source/tasks.c **** 
1489:../../freeRtos/Source/tasks.c **** #endif
1490:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1491:../../freeRtos/Source/tasks.c **** 
1492:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1493:../../freeRtos/Source/tasks.c **** 
1494:../../freeRtos/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1495:../../freeRtos/Source/tasks.c **** 	{
1496:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1497:../../freeRtos/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1498:../../freeRtos/Source/tasks.c **** 
1499:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1500:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1501:../../freeRtos/Source/tasks.c **** 		{
1502:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1503:../../freeRtos/Source/tasks.c **** 		}
1504:../../freeRtos/Source/tasks.c **** 		else
1505:../../freeRtos/Source/tasks.c **** 		{
1506:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1507:../../freeRtos/Source/tasks.c **** 		}
1508:../../freeRtos/Source/tasks.c **** 
1509:../../freeRtos/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1510:../../freeRtos/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1511:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1512:../../freeRtos/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1513:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1514:../../freeRtos/Source/tasks.c **** 
1515:../../freeRtos/Source/tasks.c **** 		return xReturn;
1516:../../freeRtos/Source/tasks.c **** 	}
1517:../../freeRtos/Source/tasks.c **** 
1518:../../freeRtos/Source/tasks.c **** #endif
1519:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1520:../../freeRtos/Source/tasks.c **** 
1521:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1522:../../freeRtos/Source/tasks.c **** 
1523:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1524:../../freeRtos/Source/tasks.c **** 	{
1525:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1526:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn;
1527:../../freeRtos/Source/tasks.c **** 
1528:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1529:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1530:../../freeRtos/Source/tasks.c **** 		{
1531:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1532:../../freeRtos/Source/tasks.c **** 		}
1533:../../freeRtos/Source/tasks.c **** 		else
1534:../../freeRtos/Source/tasks.c **** 		{
1535:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1536:../../freeRtos/Source/tasks.c **** 		}
1537:../../freeRtos/Source/tasks.c **** 
1538:../../freeRtos/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1539:../../freeRtos/Source/tasks.c **** 		{
1540:../../freeRtos/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1541:../../freeRtos/Source/tasks.c **** 		}
1542:../../freeRtos/Source/tasks.c **** 		else
1543:../../freeRtos/Source/tasks.c **** 		{
1544:../../freeRtos/Source/tasks.c **** 			xReturn = pdFAIL;
1545:../../freeRtos/Source/tasks.c **** 		}
1546:../../freeRtos/Source/tasks.c **** 
1547:../../freeRtos/Source/tasks.c **** 		return xReturn;
1548:../../freeRtos/Source/tasks.c **** 	}
1549:../../freeRtos/Source/tasks.c **** 
1550:../../freeRtos/Source/tasks.c **** #endif
1551:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1552:../../freeRtos/Source/tasks.c **** 
1553:../../freeRtos/Source/tasks.c **** void vTaskSwitchContext( void )
1554:../../freeRtos/Source/tasks.c **** {
1555:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1556:../../freeRtos/Source/tasks.c **** 	{
1557:../../freeRtos/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1558:../../freeRtos/Source/tasks.c **** 		switch. */
1559:../../freeRtos/Source/tasks.c **** 		xMissedYield = pdTRUE;
1560:../../freeRtos/Source/tasks.c **** 		return;
1561:../../freeRtos/Source/tasks.c **** 	}
1562:../../freeRtos/Source/tasks.c **** 
1563:../../freeRtos/Source/tasks.c **** 	traceTASK_SWITCHED_OUT();
1564:../../freeRtos/Source/tasks.c **** 
1565:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1566:../../freeRtos/Source/tasks.c **** 	{
1567:../../freeRtos/Source/tasks.c **** 		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1568:../../freeRtos/Source/tasks.c **** 
1569:../../freeRtos/Source/tasks.c **** 			/* Add the amount of time the task has been running to the accumulated
1570:../../freeRtos/Source/tasks.c **** 			time so far.  The time the task started running was stored in
1571:../../freeRtos/Source/tasks.c **** 			ulTaskSwitchedInTime.  Note that there is no overflow protection here
1572:../../freeRtos/Source/tasks.c **** 			so count values are only valid until the timer overflows.  Generally
1573:../../freeRtos/Source/tasks.c **** 			this will be about 1 hour assuming a 1uS timer increment. */
1574:../../freeRtos/Source/tasks.c **** 			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1575:../../freeRtos/Source/tasks.c **** 			ulTaskSwitchedInTime = ulTempCounter;
1576:../../freeRtos/Source/tasks.c **** 	}
1577:../../freeRtos/Source/tasks.c **** 	#endif
1578:../../freeRtos/Source/tasks.c **** 
1579:../../freeRtos/Source/tasks.c **** 	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1580:../../freeRtos/Source/tasks.c **** 	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1581:../../freeRtos/Source/tasks.c **** 
1582:../../freeRtos/Source/tasks.c **** 	/* Find the highest priority queue that contains ready tasks. */
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1584:../../freeRtos/Source/tasks.c **** 	{
1585:../../freeRtos/Source/tasks.c **** 		--uxTopReadyPriority;
1586:../../freeRtos/Source/tasks.c **** 	}
1587:../../freeRtos/Source/tasks.c **** 
1588:../../freeRtos/Source/tasks.c **** 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1589:../../freeRtos/Source/tasks.c **** 	same priority get an equal share of the processor time. */
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1591:../../freeRtos/Source/tasks.c **** 
1592:../../freeRtos/Source/tasks.c **** 	traceTASK_SWITCHED_IN();
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
1594:../../freeRtos/Source/tasks.c **** }
1595:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1596:../../freeRtos/Source/tasks.c **** 
1597:../../freeRtos/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1598:../../freeRtos/Source/tasks.c **** {
1599:../../freeRtos/Source/tasks.c **** portTickType xTimeToWake;
1600:../../freeRtos/Source/tasks.c **** 
1601:../../freeRtos/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1602:../../freeRtos/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1603:../../freeRtos/Source/tasks.c **** 
1604:../../freeRtos/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1605:../../freeRtos/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1606:../../freeRtos/Source/tasks.c **** 	is the first to be woken by the event. */
1607:../../freeRtos/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1608:../../freeRtos/Source/tasks.c **** 
1609:../../freeRtos/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1610:../../freeRtos/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1611:../../freeRtos/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1612:../../freeRtos/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1613:../../freeRtos/Source/tasks.c **** 
1614:../../freeRtos/Source/tasks.c **** 
1615:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1616:../../freeRtos/Source/tasks.c **** 	{
1617:../../freeRtos/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1618:../../freeRtos/Source/tasks.c **** 		{
1619:../../freeRtos/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1620:../../freeRtos/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1621:../../freeRtos/Source/tasks.c **** 			indefinitely. */
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1623:../../freeRtos/Source/tasks.c **** 		}
1624:../../freeRtos/Source/tasks.c **** 		else
1625:../../freeRtos/Source/tasks.c **** 		{
1626:../../freeRtos/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1627:../../freeRtos/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1628:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1629:../../freeRtos/Source/tasks.c **** 
1630:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1631:../../freeRtos/Source/tasks.c **** 
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1633:../../freeRtos/Source/tasks.c **** 			{
1634:../../freeRtos/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1636:../../freeRtos/Source/tasks.c **** 			}
1637:../../freeRtos/Source/tasks.c **** 			else
1638:../../freeRtos/Source/tasks.c **** 			{
1639:../../freeRtos/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1641:../../freeRtos/Source/tasks.c **** 			}
1642:../../freeRtos/Source/tasks.c **** 		}
1643:../../freeRtos/Source/tasks.c **** 	}
1644:../../freeRtos/Source/tasks.c **** 	#else
1645:../../freeRtos/Source/tasks.c **** 	{
1646:../../freeRtos/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1647:../../freeRtos/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1648:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1649:../../freeRtos/Source/tasks.c **** 
1650:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1651:../../freeRtos/Source/tasks.c **** 
1652:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1653:../../freeRtos/Source/tasks.c **** 			{
1654:../../freeRtos/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1655:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1656:../../freeRtos/Source/tasks.c **** 			}
1657:../../freeRtos/Source/tasks.c **** 			else
1658:../../freeRtos/Source/tasks.c **** 			{
1659:../../freeRtos/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1660:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1661:../../freeRtos/Source/tasks.c **** 			}
1662:../../freeRtos/Source/tasks.c **** 	}
1663:../../freeRtos/Source/tasks.c **** 	#endif
1664:../../freeRtos/Source/tasks.c **** }
1665:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1666:../../freeRtos/Source/tasks.c **** 
1667:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1668:../../freeRtos/Source/tasks.c **** {
1669:../../freeRtos/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1670:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1671:../../freeRtos/Source/tasks.c **** 
1672:../../freeRtos/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1673:../../freeRtos/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1674:../../freeRtos/Source/tasks.c **** 
1675:../../freeRtos/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1676:../../freeRtos/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1677:../../freeRtos/Source/tasks.c **** 	it to the ready list.
1678:../../freeRtos/Source/tasks.c **** 
1679:../../freeRtos/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1680:../../freeRtos/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1681:../../freeRtos/Source/tasks.c **** 	means we can always expect exclusive access to the event list here. */
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1683:../../freeRtos/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1684:../../freeRtos/Source/tasks.c **** 
1685:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1686:../../freeRtos/Source/tasks.c **** 	{
1687:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1689:../../freeRtos/Source/tasks.c **** 	}
1690:../../freeRtos/Source/tasks.c **** 	else
1691:../../freeRtos/Source/tasks.c **** 	{
1692:../../freeRtos/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1693:../../freeRtos/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1694:../../freeRtos/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1695:../../freeRtos/Source/tasks.c **** 	}
1696:../../freeRtos/Source/tasks.c **** 
1697:../../freeRtos/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1698:../../freeRtos/Source/tasks.c **** 	{
1699:../../freeRtos/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1700:../../freeRtos/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1701:../../freeRtos/Source/tasks.c **** 		the calling task to know if it should force a context
1702:../../freeRtos/Source/tasks.c **** 		switch now. */
1703:../../freeRtos/Source/tasks.c **** 		xReturn = pdTRUE;
1704:../../freeRtos/Source/tasks.c **** 	}
1705:../../freeRtos/Source/tasks.c **** 	else
1706:../../freeRtos/Source/tasks.c **** 	{
1707:../../freeRtos/Source/tasks.c **** 		xReturn = pdFALSE;
1708:../../freeRtos/Source/tasks.c **** 	}
1709:../../freeRtos/Source/tasks.c **** 
1710:../../freeRtos/Source/tasks.c **** 	return xReturn;
1711:../../freeRtos/Source/tasks.c **** }
1712:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1713:../../freeRtos/Source/tasks.c **** 
1714:../../freeRtos/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1715:../../freeRtos/Source/tasks.c **** {
1716:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1717:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1718:../../freeRtos/Source/tasks.c **** }
1719:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1720:../../freeRtos/Source/tasks.c **** 
1721:../../freeRtos/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1722:../../freeRtos/Source/tasks.c **** {
1723:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1724:../../freeRtos/Source/tasks.c **** 
1725:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1726:../../freeRtos/Source/tasks.c **** 	{
1727:../../freeRtos/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1728:../../freeRtos/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1729:../../freeRtos/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1730:../../freeRtos/Source/tasks.c **** 			therefore never time out. */
1731:../../freeRtos/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
1732:../../freeRtos/Source/tasks.c **** 			{
1733:../../freeRtos/Source/tasks.c **** 				xReturn = pdFALSE;
1734:../../freeRtos/Source/tasks.c **** 			}
1735:../../freeRtos/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1736:../../freeRtos/Source/tasks.c **** 		#endif
1737:../../freeRtos/Source/tasks.c **** 
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1739:../../freeRtos/Source/tasks.c **** 		{
1740:../../freeRtos/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1741:../../freeRtos/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1742:../../freeRtos/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1743:../../freeRtos/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1744:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
1745:../../freeRtos/Source/tasks.c **** 		}
1746:../../freeRtos/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1747:../../freeRtos/Source/tasks.c **** 		{
1748:../../freeRtos/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1749:../../freeRtos/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1750:../../freeRtos/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1751:../../freeRtos/Source/tasks.c **** 			xReturn = pdFALSE;
1752:../../freeRtos/Source/tasks.c **** 		}
1753:../../freeRtos/Source/tasks.c **** 		else
1754:../../freeRtos/Source/tasks.c **** 		{
1755:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
1756:../../freeRtos/Source/tasks.c **** 		}
1757:../../freeRtos/Source/tasks.c **** 	}
1758:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1759:../../freeRtos/Source/tasks.c **** 
1760:../../freeRtos/Source/tasks.c **** 	return xReturn;
1761:../../freeRtos/Source/tasks.c **** }
1762:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1763:../../freeRtos/Source/tasks.c **** 
1764:../../freeRtos/Source/tasks.c **** void vTaskMissedYield( void )
1765:../../freeRtos/Source/tasks.c **** {
1766:../../freeRtos/Source/tasks.c **** 	xMissedYield = pdTRUE;
1767:../../freeRtos/Source/tasks.c **** }
1768:../../freeRtos/Source/tasks.c **** 
1769:../../freeRtos/Source/tasks.c **** /*
1770:../../freeRtos/Source/tasks.c ****  * -----------------------------------------------------------
1771:../../freeRtos/Source/tasks.c ****  * The Idle task.
1772:../../freeRtos/Source/tasks.c ****  * ----------------------------------------------------------
1773:../../freeRtos/Source/tasks.c ****  *
1774:../../freeRtos/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1775:../../freeRtos/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1776:../../freeRtos/Source/tasks.c ****  *
1777:../../freeRtos/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1778:../../freeRtos/Source/tasks.c ****  *
1779:../../freeRtos/Source/tasks.c ****  */
1780:../../freeRtos/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1781:../../freeRtos/Source/tasks.c **** {
1782:../../freeRtos/Source/tasks.c **** 	/* Stop warnings. */
1783:../../freeRtos/Source/tasks.c **** 	( void ) pvParameters;
1784:../../freeRtos/Source/tasks.c **** 
1785:../../freeRtos/Source/tasks.c **** 	for( ;; )
1786:../../freeRtos/Source/tasks.c **** 	{
1787:../../freeRtos/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1788:../../freeRtos/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1789:../../freeRtos/Source/tasks.c **** 
1790:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1791:../../freeRtos/Source/tasks.c **** 		{
1792:../../freeRtos/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1793:../../freeRtos/Source/tasks.c **** 			see if any other task has become available.  If we are using
1794:../../freeRtos/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1795:../../freeRtos/Source/tasks.c **** 			will automatically get the processor anyway. */
1796:../../freeRtos/Source/tasks.c **** 			taskYIELD();
1797:../../freeRtos/Source/tasks.c **** 		}
1798:../../freeRtos/Source/tasks.c **** 		#endif
1799:../../freeRtos/Source/tasks.c **** 
1800:../../freeRtos/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1801:../../freeRtos/Source/tasks.c **** 		{
1802:../../freeRtos/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1803:../../freeRtos/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1804:../../freeRtos/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1805:../../freeRtos/Source/tasks.c **** 			timeslice.
1806:../../freeRtos/Source/tasks.c **** 
1807:../../freeRtos/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1808:../../freeRtos/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1809:../../freeRtos/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1810:../../freeRtos/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1811:../../freeRtos/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1812:../../freeRtos/Source/tasks.c **** 			{
1813:../../freeRtos/Source/tasks.c **** 				taskYIELD();
1814:../../freeRtos/Source/tasks.c **** 			}
1815:../../freeRtos/Source/tasks.c **** 		}
1816:../../freeRtos/Source/tasks.c **** 		#endif
1817:../../freeRtos/Source/tasks.c **** 
1818:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1819:../../freeRtos/Source/tasks.c **** 		{
1820:../../freeRtos/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1821:../../freeRtos/Source/tasks.c **** 
1822:../../freeRtos/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1823:../../freeRtos/Source/tasks.c **** 			allows the application designer to add background functionality
1824:../../freeRtos/Source/tasks.c **** 			without the overhead of a separate task.
1825:../../freeRtos/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1826:../../freeRtos/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1827:../../freeRtos/Source/tasks.c **** 			vApplicationIdleHook();
1828:../../freeRtos/Source/tasks.c **** 		}
1829:../../freeRtos/Source/tasks.c **** 		#endif
1830:../../freeRtos/Source/tasks.c **** 	}
1831:../../freeRtos/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1832:../../freeRtos/Source/tasks.c **** 
1833:../../freeRtos/Source/tasks.c **** 
1834:../../freeRtos/Source/tasks.c **** 
1835:../../freeRtos/Source/tasks.c **** 
1836:../../freeRtos/Source/tasks.c **** 
1837:../../freeRtos/Source/tasks.c **** 
1838:../../freeRtos/Source/tasks.c **** 
1839:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1840:../../freeRtos/Source/tasks.c ****  * File private functions documented at the top of the file.
1841:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1842:../../freeRtos/Source/tasks.c **** 
1843:../../freeRtos/Source/tasks.c **** 
1844:../../freeRtos/Source/tasks.c **** 
1845:../../freeRtos/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1846:../../freeRtos/Source/tasks.c **** {
1847:../../freeRtos/Source/tasks.c **** 	/* Store the function name in the TCB. */
1848:../../freeRtos/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1849:../../freeRtos/Source/tasks.c **** 	{
1850:../../freeRtos/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1851:../../freeRtos/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1852:../../freeRtos/Source/tasks.c **** 	}
1853:../../freeRtos/Source/tasks.c **** 	#endif
1854:../../freeRtos/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
1855:../../freeRtos/Source/tasks.c **** 
1856:../../freeRtos/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1857:../../freeRtos/Source/tasks.c **** 	remove the privilege bit if one is present. */
1858:../../freeRtos/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1859:../../freeRtos/Source/tasks.c **** 	{
1860:../../freeRtos/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - 1;
1861:../../freeRtos/Source/tasks.c **** 	}
1862:../../freeRtos/Source/tasks.c **** 
1863:../../freeRtos/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
1864:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1865:../../freeRtos/Source/tasks.c **** 	{
1866:../../freeRtos/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
1867:../../freeRtos/Source/tasks.c **** 	}
1868:../../freeRtos/Source/tasks.c **** 	#endif
1869:../../freeRtos/Source/tasks.c **** 
1870:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
1871:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
1872:../../freeRtos/Source/tasks.c **** 
1873:../../freeRtos/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1874:../../freeRtos/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1875:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
1876:../../freeRtos/Source/tasks.c **** 
1877:../../freeRtos/Source/tasks.c **** 	/* Event lists are always in priority order. */
1878:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
1879:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
1880:../../freeRtos/Source/tasks.c **** 
1881:../../freeRtos/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1882:../../freeRtos/Source/tasks.c **** 	{
1883:../../freeRtos/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
1884:../../freeRtos/Source/tasks.c **** 	}
1885:../../freeRtos/Source/tasks.c **** 	#endif
1886:../../freeRtos/Source/tasks.c **** 
1887:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1888:../../freeRtos/Source/tasks.c **** 	{
1889:../../freeRtos/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1890:../../freeRtos/Source/tasks.c **** 	}
1891:../../freeRtos/Source/tasks.c **** 	#endif
1892:../../freeRtos/Source/tasks.c **** 
1893:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1894:../../freeRtos/Source/tasks.c **** 	{
1895:../../freeRtos/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1896:../../freeRtos/Source/tasks.c **** 	}
1897:../../freeRtos/Source/tasks.c **** 	#endif
1898:../../freeRtos/Source/tasks.c **** 
1899:../../freeRtos/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1900:../../freeRtos/Source/tasks.c **** 	{
1901:../../freeRtos/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1902:../../freeRtos/Source/tasks.c **** 	}
1903:../../freeRtos/Source/tasks.c **** 	#else
1904:../../freeRtos/Source/tasks.c **** 	{
1905:../../freeRtos/Source/tasks.c **** 		( void ) xRegions;
1906:../../freeRtos/Source/tasks.c **** 		( void ) usStackDepth;
1907:../../freeRtos/Source/tasks.c **** 	}
1908:../../freeRtos/Source/tasks.c **** 	#endif
1909:../../freeRtos/Source/tasks.c **** }
1910:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1911:../../freeRtos/Source/tasks.c **** 
1912:../../freeRtos/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
1913:../../freeRtos/Source/tasks.c **** 
1914:../../freeRtos/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
1915:../../freeRtos/Source/tasks.c **** 	{
1916:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
1917:../../freeRtos/Source/tasks.c **** 	
1918:../../freeRtos/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
1919:../../freeRtos/Source/tasks.c **** 		{
1920:../../freeRtos/Source/tasks.c **** 			xTaskToModify = NULL;
1921:../../freeRtos/Source/tasks.c **** 		}
1922:../../freeRtos/Source/tasks.c **** 
1923:../../freeRtos/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
1924:../../freeRtos/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
1925:../../freeRtos/Source/tasks.c **** 
1926:../../freeRtos/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
1927:../../freeRtos/Source/tasks.c **** 	}
1928:../../freeRtos/Source/tasks.c **** 	/*-----------------------------------------------------------*/
1929:../../freeRtos/Source/tasks.c **** #endif
1930:../../freeRtos/Source/tasks.c **** 
1931:../../freeRtos/Source/tasks.c **** static void prvInitialiseTaskLists( void )
1932:../../freeRtos/Source/tasks.c **** {
1933:../../freeRtos/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
1934:../../freeRtos/Source/tasks.c **** 
1935:../../freeRtos/Source/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
1936:../../freeRtos/Source/tasks.c **** 	{
1937:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
1938:../../freeRtos/Source/tasks.c **** 	}
1939:../../freeRtos/Source/tasks.c **** 
1940:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
1941:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
1942:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
1943:../../freeRtos/Source/tasks.c **** 
1944:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1945:../../freeRtos/Source/tasks.c **** 	{
1946:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
1947:../../freeRtos/Source/tasks.c **** 	}
1948:../../freeRtos/Source/tasks.c **** 	#endif
1949:../../freeRtos/Source/tasks.c **** 
1950:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1951:../../freeRtos/Source/tasks.c **** 	{
1952:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
1953:../../freeRtos/Source/tasks.c **** 	}
1954:../../freeRtos/Source/tasks.c **** 	#endif
1955:../../freeRtos/Source/tasks.c **** 
1956:../../freeRtos/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
1957:../../freeRtos/Source/tasks.c **** 	using list2. */
1958:../../freeRtos/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
1959:../../freeRtos/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
1960:../../freeRtos/Source/tasks.c **** }
1961:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1962:../../freeRtos/Source/tasks.c **** 
1963:../../freeRtos/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
1964:../../freeRtos/Source/tasks.c **** {
1965:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1966:../../freeRtos/Source/tasks.c **** 	{
1967:../../freeRtos/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
1968:../../freeRtos/Source/tasks.c **** 
1969:../../freeRtos/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
1970:../../freeRtos/Source/tasks.c **** 		too often in the idle task. */
1971:../../freeRtos/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
1972:../../freeRtos/Source/tasks.c **** 		{
1973:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
1974:../../freeRtos/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
1975:../../freeRtos/Source/tasks.c **** 			xTaskResumeAll();
1976:../../freeRtos/Source/tasks.c **** 
1977:../../freeRtos/Source/tasks.c **** 			if( !xListIsEmpty )
1978:../../freeRtos/Source/tasks.c **** 			{
1979:../../freeRtos/Source/tasks.c **** 				tskTCB *pxTCB;
1980:../../freeRtos/Source/tasks.c **** 
1981:../../freeRtos/Source/tasks.c **** 				portENTER_CRITICAL();
1982:../../freeRtos/Source/tasks.c **** 				{
1983:../../freeRtos/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
1984:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1985:../../freeRtos/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
1986:../../freeRtos/Source/tasks.c **** 					--uxTasksDeleted;
1987:../../freeRtos/Source/tasks.c **** 				}
1988:../../freeRtos/Source/tasks.c **** 				portEXIT_CRITICAL();
1989:../../freeRtos/Source/tasks.c **** 
1990:../../freeRtos/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1991:../../freeRtos/Source/tasks.c **** 			}
1992:../../freeRtos/Source/tasks.c **** 		}
1993:../../freeRtos/Source/tasks.c **** 	}
1994:../../freeRtos/Source/tasks.c **** 	#endif
1995:../../freeRtos/Source/tasks.c **** }
1996:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1997:../../freeRtos/Source/tasks.c **** 
1998:../../freeRtos/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
1999:../../freeRtos/Source/tasks.c **** {
2000:../../freeRtos/Source/tasks.c **** tskTCB *pxNewTCB;
2001:../../freeRtos/Source/tasks.c **** 
2002:../../freeRtos/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2003:../../freeRtos/Source/tasks.c **** 	the implementation of the port malloc function. */
2004:../../freeRtos/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2005:../../freeRtos/Source/tasks.c **** 
2006:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
2007:../../freeRtos/Source/tasks.c **** 	{
2008:../../freeRtos/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2009:../../freeRtos/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2010:../../freeRtos/Source/tasks.c **** 		be deleted later if required. */
2011:../../freeRtos/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2012:../../freeRtos/Source/tasks.c **** 
2013:../../freeRtos/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
2014:../../freeRtos/Source/tasks.c **** 		{
2015:../../freeRtos/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2016:../../freeRtos/Source/tasks.c **** 			vPortFree( pxNewTCB );
2017:../../freeRtos/Source/tasks.c **** 			pxNewTCB = NULL;
2018:../../freeRtos/Source/tasks.c **** 		}
2019:../../freeRtos/Source/tasks.c **** 		else
2020:../../freeRtos/Source/tasks.c **** 		{
2021:../../freeRtos/Source/tasks.c **** 			/* Just to help debugging. */
2022:../../freeRtos/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
2023:../../freeRtos/Source/tasks.c **** 		}
2024:../../freeRtos/Source/tasks.c **** 	}
2025:../../freeRtos/Source/tasks.c **** 
2026:../../freeRtos/Source/tasks.c **** 	return pxNewTCB;
2027:../../freeRtos/Source/tasks.c **** }
2028:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2029:../../freeRtos/Source/tasks.c **** 
2030:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2031:../../freeRtos/Source/tasks.c **** 
2032:../../freeRtos/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2033:../../freeRtos/Source/tasks.c **** 	{
 457               	.LM0:
 458               	.LFBB1:
 459 0000 4F92      		push r4
 460 0002 5F92      		push r5
 461 0004 6F92      		push r6
 462 0006 7F92      		push r7
 463 0008 8F92      		push r8
 464 000a 9F92      		push r9
 465 000c AF92      		push r10
 466 000e BF92      		push r11
 467 0010 CF92      		push r12
 468 0012 DF92      		push r13
 469 0014 EF92      		push r14
 470 0016 FF92      		push r15
 471 0018 0F93      		push r16
 472 001a 1F93      		push r17
 473 001c CF93      		push r28
 474 001e DF93      		push r29
 475               	/* prologue: function */
 476               	/* frame size = 0 */
 477               	/* stack size = 16 */
 478               	.L__stack_usage = 16
 479 0020 2C01      		movw r4,r24
 480 0022 EB01      		movw r28,r22
 481               	.LBB17:
2034:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2035:../../freeRtos/Source/tasks.c **** 	unsigned short usStackRemaining;
2036:../../freeRtos/Source/tasks.c **** 
2037:../../freeRtos/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2038:../../freeRtos/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 483               	.LM1:
 484 0024 E981      		ldd r30,Y+1
 485 0026 FA81      		ldd r31,Y+2
 486 0028 0280      		ldd __tmp_reg__,Z+2
 487 002a F381      		ldd r31,Z+3
 488 002c E02D      		mov r30,__tmp_reg__
 489 002e E983      		std Y+1,r30
 490 0030 FA83      		std Y+2,r31
 491 0032 CB01      		movw r24,r22
 492 0034 0396      		adiw r24,3
 493 0036 E817      		cp r30,r24
 494 0038 F907      		cpc r31,r25
 495 003a 01F4      		brne .L2
 497               	.LM2:
 498 003c 8281      		ldd r24,Z+2
 499 003e 9381      		ldd r25,Z+3
 500 0040 8983      		std Y+1,r24
 501 0042 9A83      		std Y+2,r25
 502               	.L2:
 504               	.LM3:
 505 0044 E981      		ldd r30,Y+1
 506 0046 FA81      		ldd r31,Y+2
 507 0048 A680      		ldd r10,Z+6
 508 004a B780      		ldd r11,Z+7
 509               	.LBE17:
 510               	.LBB18:
2039:../../freeRtos/Source/tasks.c **** 		do
2040:../../freeRtos/Source/tasks.c **** 		{
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 512               	.LM4:
 513 004c 23E0      		ldi r18,lo8(3)
 514 004e E22E      		mov r14,r18
 515 0050 F12C      		mov r15,__zero_reg__
 516 0052 EC0E      		add r14,r28
 517 0054 FD1E      		adc r15,r29
 518               	.LBE18:
2042:../../freeRtos/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2043:../../freeRtos/Source/tasks.c **** 			{
2044:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2045:../../freeRtos/Source/tasks.c **** 			}
2046:../../freeRtos/Source/tasks.c **** 			#else
2047:../../freeRtos/Source/tasks.c **** 			{
2048:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2049:../../freeRtos/Source/tasks.c **** 			}
2050:../../freeRtos/Source/tasks.c **** 			#endif			
2051:../../freeRtos/Source/tasks.c **** 			
2052:../../freeRtos/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 520               	.LM5:
 521 0056 90E0      		ldi r25,lo8(pcStatusString)
 522 0058 C92E      		mov r12,r25
 523 005a 90E0      		ldi r25,hi8(pcStatusString)
 524 005c D92E      		mov r13,r25
 525 005e 80E0      		ldi r24,lo8(.LC0)
 526 0060 882E      		mov r8,r24
 527 0062 80E0      		ldi r24,hi8(.LC0)
 528 0064 982E      		mov r9,r24
 529 0066 642E      		mov r6,r20
 530 0068 7724      		clr r7
 531 006a 67FC      		sbrc r6,7
 532 006c 7094      		com r7
 533               	.L6:
 534               	.LBB19:
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 536               	.LM6:
 537 006e E981      		ldd r30,Y+1
 538 0070 FA81      		ldd r31,Y+2
 539 0072 8281      		ldd r24,Z+2
 540 0074 9381      		ldd r25,Z+3
 541 0076 8983      		std Y+1,r24
 542 0078 9A83      		std Y+2,r25
 543 007a 8E15      		cp r24,r14
 544 007c 9F05      		cpc r25,r15
 545 007e 01F4      		brne .L3
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 547               	.LM7:
 548 0080 D701      		movw r26,r14
 549 0082 1296      		adiw r26,2
 550 0084 8D91      		ld r24,X+
 551 0086 9C91      		ld r25,X
 552 0088 1397      		sbiw r26,2+1
 553 008a 8983      		std Y+1,r24
 554 008c 9A83      		std Y+2,r25
 555               	.L3:
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 557               	.LM8:
 558 008e E981      		ldd r30,Y+1
 559 0090 FA81      		ldd r31,Y+2
 560 0092 0681      		ldd r16,Z+6
 561 0094 1781      		ldd r17,Z+7
 562               	.LBE19:
2048:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 564               	.LM9:
 565 0096 D801      		movw r26,r16
 566 0098 5796      		adiw r26,23
 567 009a ED91      		ld r30,X+
 568 009c FC91      		ld r31,X
 569 009e 5897      		sbiw r26,23+1
2053:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2054:../../freeRtos/Source/tasks.c **** 
2055:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2056:../../freeRtos/Source/tasks.c **** 	}
2057:../../freeRtos/Source/tasks.c **** 
2058:../../freeRtos/Source/tasks.c **** #endif
2059:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2060:../../freeRtos/Source/tasks.c **** 
2061:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2062:../../freeRtos/Source/tasks.c **** 
2063:../../freeRtos/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2064:../../freeRtos/Source/tasks.c **** 	{
2065:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2066:../../freeRtos/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2067:../../freeRtos/Source/tasks.c **** 
2068:../../freeRtos/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2069:../../freeRtos/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2070:../../freeRtos/Source/tasks.c **** 		do
2071:../../freeRtos/Source/tasks.c **** 		{
2072:../../freeRtos/Source/tasks.c **** 			/* Get next TCB in from the list. */
2073:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2074:../../freeRtos/Source/tasks.c **** 
2075:../../freeRtos/Source/tasks.c **** 			/* Divide by zero check. */
2076:../../freeRtos/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2077:../../freeRtos/Source/tasks.c **** 			{
2078:../../freeRtos/Source/tasks.c **** 				/* Has the task run at all? */
2079:../../freeRtos/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0 )
2080:../../freeRtos/Source/tasks.c **** 				{
2081:../../freeRtos/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2082:../../freeRtos/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2083:../../freeRtos/Source/tasks.c **** 				}
2084:../../freeRtos/Source/tasks.c **** 				else
2085:../../freeRtos/Source/tasks.c **** 				{
2086:../../freeRtos/Source/tasks.c **** 					/* What percentage of the total run time as the task used?
2087:../../freeRtos/Source/tasks.c **** 					This will always be rounded down to the nearest integer. */
2088:../../freeRtos/Source/tasks.c **** 					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
2089:../../freeRtos/Source/tasks.c **** 
2090:../../freeRtos/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2091:../../freeRtos/Source/tasks.c **** 					{
2092:../../freeRtos/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2093:../../freeRtos/Source/tasks.c **** 					}
2094:../../freeRtos/Source/tasks.c **** 					else
2095:../../freeRtos/Source/tasks.c **** 					{
2096:../../freeRtos/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2097:../../freeRtos/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2098:../../freeRtos/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2099:../../freeRtos/Source/tasks.c **** 					}
2100:../../freeRtos/Source/tasks.c **** 				}
2101:../../freeRtos/Source/tasks.c **** 
2102:../../freeRtos/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2103:../../freeRtos/Source/tasks.c **** 			}
2104:../../freeRtos/Source/tasks.c **** 
2105:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2106:../../freeRtos/Source/tasks.c **** 	}
2107:../../freeRtos/Source/tasks.c **** 
2108:../../freeRtos/Source/tasks.c **** #endif
2109:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2110:../../freeRtos/Source/tasks.c **** 
2111:../../freeRtos/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2112:../../freeRtos/Source/tasks.c **** 
2113:../../freeRtos/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2114:../../freeRtos/Source/tasks.c **** 	{
2115:../../freeRtos/Source/tasks.c **** 	register unsigned short usCount = 0;
 571               	.LM10:
 572 00a0 80E0      		ldi r24,lo8(0)
 573 00a2 90E0      		ldi r25,hi8(0)
 574 00a4 00C0      		rjmp .L4
 575               	.L5:
 576               	.LBB20:
 577               	.LBB21:
2116:../../freeRtos/Source/tasks.c **** 
2117:../../freeRtos/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2118:../../freeRtos/Source/tasks.c **** 		{
2119:../../freeRtos/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2120:../../freeRtos/Source/tasks.c **** 			usCount++;
 579               	.LM11:
 580 00a6 0196      		adiw r24,1
 581               	.L4:
2117:../../freeRtos/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 583               	.LM12:
 584 00a8 2191      		ld r18,Z+
 585 00aa 253A      		cpi r18,lo8(-91)
 586 00ac 01F0      		breq .L5
 587               	.LBE21:
 588               	.LBE20:
2052:../../freeRtos/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 590               	.LM13:
 591 00ae 9801      		movw r18,r16
 592 00b0 275E      		subi r18,lo8(-(25))
 593 00b2 3F4F      		sbci r19,hi8(-(25))
 594 00b4 F801      		movw r30,r16
 595 00b6 5689      		ldd r21,Z+22
 596 00b8 43A1      		ldd r20,Z+35
 597 00ba 6DB7      		in r22,__SP_L__
 598 00bc 7EB7      		in r23,__SP_H__
 599 00be 6E50      		subi r22,lo8(-(-14))
 600 00c0 7040      		sbci r23,hi8(-(-14))
 601 00c2 6DBF      		out __SP_L__,r22
 602 00c4 7EBF      		out __SP_H__,r23
 603 00c6 EDB7      		in r30,__SP_L__
 604 00c8 FEB7      		in r31,__SP_H__
 605 00ca 3196      		adiw r30,1
 606 00cc ADB7      		in r26,__SP_L__
 607 00ce BEB7      		in r27,__SP_H__
 608 00d0 1196      		adiw r26,1
 609 00d2 CD92      		st X+,r12
 610 00d4 DC92      		st X,r13
 611 00d6 1297      		sbiw r26,1+1
 612 00d8 8282      		std Z+2,r8
 613 00da 9382      		std Z+3,r9
 614 00dc 2483      		std Z+4,r18
 615 00de 3583      		std Z+5,r19
 616 00e0 6682      		std Z+6,r6
 617 00e2 7782      		std Z+7,r7
 618 00e4 5087      		std Z+8,r21
 619 00e6 1186      		std Z+9,__zero_reg__
 620 00e8 8287      		std Z+10,r24
 621 00ea 9387      		std Z+11,r25
 622 00ec 4487      		std Z+12,r20
 623 00ee 1586      		std Z+13,__zero_reg__
 624 00f0 0E94 0000 		call sprintf
2053:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 626               	.LM14:
 627 00f4 EDB7      		in r30,__SP_L__
 628 00f6 FEB7      		in r31,__SP_H__
 629 00f8 3E96      		adiw r30,14
 630 00fa EDBF      		out __SP_L__,r30
 631 00fc FEBF      		out __SP_H__,r31
 632 00fe C201      		movw r24,r4
 633 0100 B601      		movw r22,r12
 634 0102 0E94 0000 		call strcat
2055:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 636               	.LM15:
 637 0106 0A15      		cp r16,r10
 638 0108 1B05      		cpc r17,r11
 639 010a 01F0      		breq .+2
 640 010c 00C0      		rjmp .L6
 641               	/* epilogue start */
2056:../../freeRtos/Source/tasks.c **** 	}
 643               	.LM16:
 644 010e DF91      		pop r29
 645 0110 CF91      		pop r28
 646 0112 1F91      		pop r17
 647 0114 0F91      		pop r16
 648 0116 FF90      		pop r15
 649 0118 EF90      		pop r14
 650 011a DF90      		pop r13
 651 011c CF90      		pop r12
 652 011e BF90      		pop r11
 653 0120 AF90      		pop r10
 654 0122 9F90      		pop r9
 655 0124 8F90      		pop r8
 656 0126 7F90      		pop r7
 657 0128 6F90      		pop r6
 658 012a 5F90      		pop r5
 659 012c 4F90      		pop r4
 660 012e 0895      		ret
 667               	.Lscope1:
 669               		.stabd	78,0,0
 673               	prvIdleTask:
 674               		.stabd	46,0,0
1781:../../freeRtos/Source/tasks.c **** {
 676               	.LM17:
 677               	.LFBB2:
 678               	/* prologue: function */
 679               	/* frame size = 0 */
 680               	/* stack size = 0 */
 681               	.L__stack_usage = 0
 682               	.L9:
1796:../../freeRtos/Source/tasks.c **** 			taskYIELD();
 684               	.LM18:
 685 0130 0E94 0000 		call vPortYield
 686 0134 00C0      		rjmp .L9
 688               	.Lscope2:
 690               		.stabd	78,0,0
 700               	.global	xTaskGenericCreate
 702               	xTaskGenericCreate:
 703               		.stabd	46,0,0
 387:../../freeRtos/Source/tasks.c **** {
 705               	.LM19:
 706               	.LFBB3:
 707 0136 2F92      		push r2
 708 0138 3F92      		push r3
 709 013a 4F92      		push r4
 710 013c 5F92      		push r5
 711 013e 6F92      		push r6
 712 0140 7F92      		push r7
 713 0142 8F92      		push r8
 714 0144 9F92      		push r9
 715 0146 AF92      		push r10
 716 0148 BF92      		push r11
 717 014a CF92      		push r12
 718 014c DF92      		push r13
 719 014e EF92      		push r14
 720 0150 FF92      		push r15
 721 0152 0F93      		push r16
 722 0154 1F93      		push r17
 723 0156 CF93      		push r28
 724 0158 DF93      		push r29
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 18 */
 728               	.L__stack_usage = 18
 729 015a 1C01      		movw r2,r24
 730 015c 3B01      		movw r6,r22
 731 015e 5A01      		movw r10,r20
 732 0160 2901      		movw r4,r18
 733 0162 4701      		movw r8,r14
 734               	.LBB22:
 735               	.LBB23:
2004:../../freeRtos/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 737               	.LM20:
 738 0164 84E2      		ldi r24,lo8(36)
 739 0166 90E0      		ldi r25,hi8(36)
 740 0168 0E94 0000 		call pvPortMalloc
 741 016c E82E      		mov r14,r24
 742 016e E701      		movw r28,r14
 743 0170 7E01      		movw r14,r28
 744 0172 F92E      		mov r15,r25
 745 0174 E701      		movw r28,r14
2006:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
 747               	.LM21:
 748 0176 2097      		sbiw r28,0
 749 0178 01F4      		brne .+2
 750 017a 00C0      		rjmp .L20
2011:../../freeRtos/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 752               	.LM22:
 753 017c C114      		cp r12,__zero_reg__
 754 017e D104      		cpc r13,__zero_reg__
 755 0180 01F4      		brne .L12
 756 0182 C501      		movw r24,r10
 757 0184 0E94 0000 		call pvPortMalloc
 758 0188 C82E      		mov r12,r24
 759 018a D92E      		mov r13,r25
 760               	.L12:
 761 018c CF8A      		std Y+23,r12
 762 018e D88E      		std Y+24,r13
2013:../../freeRtos/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 764               	.LM23:
 765 0190 C114      		cp r12,__zero_reg__
 766 0192 D104      		cpc r13,__zero_reg__
 767 0194 01F4      		brne .L13
2016:../../freeRtos/Source/tasks.c **** 			vPortFree( pxNewTCB );
 769               	.LM24:
 770 0196 CE01      		movw r24,r28
 771 0198 0E94 0000 		call vPortFree
 772 019c 00C0      		rjmp .L20
 773               	.L13:
2022:../../freeRtos/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 775               	.LM25:
 776 019e C601      		movw r24,r12
 777 01a0 65EA      		ldi r22,lo8(165)
 778 01a2 70E0      		ldi r23,hi8(165)
 779 01a4 A501      		movw r20,r10
 780 01a6 0E94 0000 		call memset
 781               	.LBE23:
 782               	.LBE22:
 783               	.LBB25:
 419:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 785               	.LM26:
 786 01aa 0894      		sec
 787 01ac A108      		sbc r10,__zero_reg__
 788 01ae B108      		sbc r11,__zero_reg__
 789 01b0 EF88      		ldd r14,Y+23
 790 01b2 F88C      		ldd r15,Y+24
 791 01b4 EA0C      		add r14,r10
 792 01b6 FB1C      		adc r15,r11
 793               	.LBB26:
 794               	.LBB27:
1851:../../freeRtos/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 796               	.LM27:
 797 01b8 CE01      		movw r24,r28
 798 01ba 4996      		adiw r24,25
 799 01bc B301      		movw r22,r6
 800 01be 4AE0      		ldi r20,lo8(10)
 801 01c0 50E0      		ldi r21,hi8(10)
 802 01c2 0E94 0000 		call strncpy
1854:../../freeRtos/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 804               	.LM28:
 805 01c6 1AA2      		std Y+34,__zero_reg__
 806 01c8 102F      		mov r17,r16
 807 01ca 0330      		cpi r16,lo8(3)
 808 01cc 00F0      		brlo .L14
 809 01ce 12E0      		ldi r17,lo8(2)
 810               	.L14:
1863:../../freeRtos/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 812               	.LM29:
 813 01d0 1E8B      		std Y+22,r17
1870:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 815               	.LM30:
 816 01d2 72E0      		ldi r23,lo8(2)
 817 01d4 A72E      		mov r10,r23
 818 01d6 B12C      		mov r11,__zero_reg__
 819 01d8 AC0E      		add r10,r28
 820 01da BD1E      		adc r11,r29
 821 01dc C501      		movw r24,r10
 822 01de 0E94 0000 		call vListInitialiseItem
1871:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 824               	.LM31:
 825 01e2 CE01      		movw r24,r28
 826 01e4 0C96      		adiw r24,12
 827 01e6 0E94 0000 		call vListInitialiseItem
1875:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 829               	.LM32:
 830 01ea C887      		std Y+8,r28
 831 01ec D987      		std Y+9,r29
1878:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 833               	.LM33:
 834 01ee 83E0      		ldi r24,lo8(3)
 835 01f0 90E0      		ldi r25,hi8(3)
 836 01f2 811B      		sub r24,r17
 837 01f4 9109      		sbc r25,__zero_reg__
 838 01f6 8C87      		std Y+12,r24
 839 01f8 9D87      		std Y+13,r25
1879:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 841               	.LM34:
 842 01fa CA8B      		std Y+18,r28
 843 01fc DB8B      		std Y+19,r29
 844               	.LBE27:
 845               	.LBE26:
 447:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 847               	.LM35:
 848 01fe C701      		movw r24,r14
 849 0200 B101      		movw r22,r2
 850 0202 A201      		movw r20,r4
 851 0204 0E94 0000 		call pxPortInitialiseStack
 852 0208 8883      		st Y,r24
 853 020a 9983      		std Y+1,r25
 453:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 855               	.LM36:
 856               	/* #APP */
 857               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 858 020c 0FB6      		in		__tmp_reg__, __SREG__
 859               	 ;  0 "" 2
 860               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 861 020e F894      		cli
 862               	 ;  0 "" 2
 863               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 864 0210 0F92      		push	__tmp_reg__
 865               	 ;  0 "" 2
 455:../../freeRtos/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 867               	.LM37:
 868               	/* #NOAPP */
 869 0212 8091 0000 		lds r24,uxCurrentNumberOfTasks
 870 0216 8F5F      		subi r24,lo8(-(1))
 871 0218 8093 0000 		sts uxCurrentNumberOfTasks,r24
 456:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 873               	.LM38:
 874 021c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 875 0220 8130      		cpi r24,lo8(1)
 876 0222 01F4      		brne .L15
 459:../../freeRtos/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 878               	.LM39:
 879 0224 C093 0000 		sts pxCurrentTCB,r28
 880 0228 D093 0000 		sts pxCurrentTCB+1,r29
 881               	.LBB28:
 882               	.LBB29:
1937:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 884               	.LM40:
 885 022c 80E0      		ldi r24,lo8(pxReadyTasksLists)
 886 022e 90E0      		ldi r25,hi8(pxReadyTasksLists)
 887 0230 0E94 0000 		call vListInitialise
 888 0234 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 889 0236 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 890 0238 0E94 0000 		call vListInitialise
 891 023c 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 892 023e 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 893 0240 0E94 0000 		call vListInitialise
1940:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 895               	.LM41:
 896 0244 60E0      		ldi r22,lo8(xDelayedTaskList1)
 897 0246 E62E      		mov r14,r22
 898 0248 60E0      		ldi r22,hi8(xDelayedTaskList1)
 899 024a F62E      		mov r15,r22
 900 024c C701      		movw r24,r14
 901 024e 0E94 0000 		call vListInitialise
1941:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 903               	.LM42:
 904 0252 50E0      		ldi r21,lo8(xDelayedTaskList2)
 905 0254 C52E      		mov r12,r21
 906 0256 50E0      		ldi r21,hi8(xDelayedTaskList2)
 907 0258 D52E      		mov r13,r21
 908 025a C601      		movw r24,r12
 909 025c 0E94 0000 		call vListInitialise
1942:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 911               	.LM43:
 912 0260 80E0      		ldi r24,lo8(xPendingReadyList)
 913 0262 90E0      		ldi r25,hi8(xPendingReadyList)
 914 0264 0E94 0000 		call vListInitialise
1952:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 916               	.LM44:
 917 0268 80E0      		ldi r24,lo8(xSuspendedTaskList)
 918 026a 90E0      		ldi r25,hi8(xSuspendedTaskList)
 919 026c 0E94 0000 		call vListInitialise
1958:../../freeRtos/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 921               	.LM45:
 922 0270 E092 0000 		sts pxDelayedTaskList,r14
 923 0274 F092 0000 		sts pxDelayedTaskList+1,r15
1959:../../freeRtos/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 925               	.LM46:
 926 0278 C092 0000 		sts pxOverflowDelayedTaskList,r12
 927 027c D092 0000 		sts pxOverflowDelayedTaskList+1,r13
 928 0280 00C0      		rjmp .L16
 929               	.L15:
 930               	.LBE29:
 931               	.LBE28:
 471:../../freeRtos/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 933               	.LM47:
 934 0282 8091 0000 		lds r24,xSchedulerRunning
 935 0286 8823      		tst r24
 936 0288 01F4      		brne .L16
 473:../../freeRtos/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 938               	.LM48:
 939 028a E091 0000 		lds r30,pxCurrentTCB
 940 028e F091 0000 		lds r31,pxCurrentTCB+1
 941 0292 8689      		ldd r24,Z+22
 942 0294 0817      		cp r16,r24
 943 0296 00F0      		brlo .L16
 475:../../freeRtos/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 945               	.LM49:
 946 0298 C093 0000 		sts pxCurrentTCB,r28
 947 029c D093 0000 		sts pxCurrentTCB+1,r29
 948               	.L16:
 482:../../freeRtos/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 950               	.LM50:
 951 02a0 2E89      		ldd r18,Y+22
 952 02a2 8091 0000 		lds r24,uxTopUsedPriority
 953 02a6 8217      		cp r24,r18
 954 02a8 00F4      		brsh .L17
 484:../../freeRtos/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 956               	.LM51:
 957 02aa 2093 0000 		sts uxTopUsedPriority,r18
 958               	.L17:
 490:../../freeRtos/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 960               	.LM52:
 961 02ae 8091 0000 		lds r24,uxTaskNumber
 962 02b2 8BA3      		std Y+35,r24
 493:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 964               	.LM53:
 965 02b4 8F5F      		subi r24,lo8(-(1))
 966 02b6 8093 0000 		sts uxTaskNumber,r24
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 968               	.LM54:
 969 02ba 8091 0000 		lds r24,uxTopReadyPriority
 970 02be 8217      		cp r24,r18
 971 02c0 00F4      		brsh .L18
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 973               	.LM55:
 974 02c2 2093 0000 		sts uxTopReadyPriority,r18
 975               	.L18:
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 977               	.LM56:
 978 02c6 30E0      		ldi r19,lo8(0)
 979 02c8 C901      		movw r24,r18
 980 02ca 43E0      		ldi r20,3
 981 02cc 880F      	1:	lsl r24
 982 02ce 991F      		rol r25
 983 02d0 4A95      		dec r20
 984 02d2 01F4      		brne 1b
 985 02d4 820F      		add r24,r18
 986 02d6 931F      		adc r25,r19
 987 02d8 8050      		subi r24,lo8(-(pxReadyTasksLists))
 988 02da 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 989 02dc B501      		movw r22,r10
 990 02de 0E94 0000 		call vListInsertEnd
 500:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 992               	.LM57:
 993               	/* #APP */
 994               	 ;  500 "../../freeRtos/Source/tasks.c" 1
 995 02e2 0F90      		pop		__tmp_reg__
 996               	 ;  0 "" 2
 997               	 ;  500 "../../freeRtos/Source/tasks.c" 1
 998 02e4 0FBE      		out		__SREG__, __tmp_reg__
 999               	 ;  0 "" 2
 1000               	/* #NOAPP */
 1001               	.LBE25:
 510:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 1003               	.LM58:
 1004 02e6 8114      		cp r8,__zero_reg__
 1005 02e8 9104      		cpc r9,__zero_reg__
 1006 02ea 01F0      		breq .L19
 515:../../freeRtos/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 1008               	.LM59:
 1009 02ec F401      		movw r30,r8
 1010 02ee C083      		st Z,r28
 1011 02f0 D183      		std Z+1,r29
 1012               	.L19:
 518:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 1014               	.LM60:
 1015 02f2 8091 0000 		lds r24,xSchedulerRunning
 1016 02f6 8823      		tst r24
 1017 02f8 01F0      		breq .L22
 522:../../freeRtos/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 1019               	.LM61:
 1020 02fa E091 0000 		lds r30,pxCurrentTCB
 1021 02fe F091 0000 		lds r31,pxCurrentTCB+1
 1022 0302 8689      		ldd r24,Z+22
 1023 0304 8017      		cp r24,r16
 1024 0306 00F4      		brsh .L22
 524:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1026               	.LM62:
 1027 0308 0E94 0000 		call vPortYield
 1028 030c 00C0      		rjmp .L22
 1029               	.L20:
 1030               	.LBB30:
 1031               	.LBB24:
 504:../../freeRtos/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 1033               	.LM63:
 1034 030e 8FEF      		ldi r24,lo8(-1)
 1035 0310 00C0      		rjmp .L11
 1036               	.L22:
 1037               	.LBE24:
 1038               	.LBE30:
 497:../../freeRtos/Source/tasks.c **** 			xReturn = pdPASS;
 1040               	.LM64:
 1041 0312 81E0      		ldi r24,lo8(1)
 1042               	.L11:
 1043               	/* epilogue start */
 530:../../freeRtos/Source/tasks.c **** }
 1045               	.LM65:
 1046 0314 DF91      		pop r29
 1047 0316 CF91      		pop r28
 1048 0318 1F91      		pop r17
 1049 031a 0F91      		pop r16
 1050 031c FF90      		pop r15
 1051 031e EF90      		pop r14
 1052 0320 DF90      		pop r13
 1053 0322 CF90      		pop r12
 1054 0324 BF90      		pop r11
 1055 0326 AF90      		pop r10
 1056 0328 9F90      		pop r9
 1057 032a 8F90      		pop r8
 1058 032c 7F90      		pop r7
 1059 032e 6F90      		pop r6
 1060 0330 5F90      		pop r5
 1061 0332 4F90      		pop r4
 1062 0334 3F90      		pop r3
 1063 0336 2F90      		pop r2
 1064 0338 0895      		ret
 1072               	.Lscope3:
 1074               		.stabd	78,0,0
 1077               	.global	uxTaskPriorityGet
 1079               	uxTaskPriorityGet:
 1080               		.stabd	46,0,0
 740:../../freeRtos/Source/tasks.c **** 	{
 1082               	.LM66:
 1083               	.LFBB4:
 1084               	/* prologue: function */
 1085               	/* frame size = 0 */
 1086               	/* stack size = 0 */
 1087               	.L__stack_usage = 0
 744:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1089               	.LM67:
 1090               	/* #APP */
 1091               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 1092 033a 0FB6      		in		__tmp_reg__, __SREG__
 1093               	 ;  0 "" 2
 1094               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 1095 033c F894      		cli
 1096               	 ;  0 "" 2
 1097               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 1098 033e 0F92      		push	__tmp_reg__
 1099               	 ;  0 "" 2
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1101               	.LM68:
 1102               	/* #NOAPP */
 1103 0340 0097      		sbiw r24,0
 1104 0342 01F4      		brne .L24
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1106               	.LM69:
 1107 0344 E091 0000 		lds r30,pxCurrentTCB
 1108 0348 F091 0000 		lds r31,pxCurrentTCB+1
 1109 034c 00C0      		rjmp .L25
 1110               	.L24:
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1112               	.LM70:
 1113 034e FC01      		movw r30,r24
 1114               	.L25:
 751:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1116               	.LM71:
 1117               	/* #APP */
 1118               	 ;  751 "../../freeRtos/Source/tasks.c" 1
 1119 0350 0F90      		pop		__tmp_reg__
 1120               	 ;  0 "" 2
 1121               	 ;  751 "../../freeRtos/Source/tasks.c" 1
 1122 0352 0FBE      		out		__SREG__, __tmp_reg__
 1123               	 ;  0 "" 2
 754:../../freeRtos/Source/tasks.c **** 	}
 1125               	.LM72:
 1126               	/* #NOAPP */
 1127 0354 8689      		ldd r24,Z+22
 1128               	/* epilogue start */
 1129 0356 0895      		ret
 1134               	.Lscope4:
 1136               		.stabd	78,0,0
 1140               	.global	vTaskPrioritySet
 1142               	vTaskPrioritySet:
 1143               		.stabd	46,0,0
 762:../../freeRtos/Source/tasks.c **** 	{
 1145               	.LM73:
 1146               	.LFBB5:
 1147 0358 EF92      		push r14
 1148 035a FF92      		push r15
 1149 035c 0F93      		push r16
 1150 035e 1F93      		push r17
 1151 0360 DF93      		push r29
 1152 0362 CF93      		push r28
 1153 0364 0F92      		push __tmp_reg__
 1154 0366 CDB7      		in r28,__SP_L__
 1155 0368 DEB7      		in r29,__SP_H__
 1156               	/* prologue: function */
 1157               	/* frame size = 1 */
 1158               	/* stack size = 7 */
 1159               	.L__stack_usage = 7
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1161               	.LM74:
 1162 036a 6330      		cpi r22,lo8(3)
 1163 036c 00F0      		brlo .L27
 1164 036e 62E0      		ldi r22,lo8(2)
 1165               	.L27:
 772:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1167               	.LM75:
 1168               	/* #APP */
 1169               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 1170 0370 0FB6      		in		__tmp_reg__, __SREG__
 1171               	 ;  0 "" 2
 1172               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 1173 0372 F894      		cli
 1174               	 ;  0 "" 2
 1175               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 1176 0374 0F92      		push	__tmp_reg__
 1177               	 ;  0 "" 2
 774:../../freeRtos/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 1179               	.LM76:
 1180               	/* #NOAPP */
 1181 0376 2091 0000 		lds r18,pxCurrentTCB
 1182 037a 3091 0000 		lds r19,pxCurrentTCB+1
 1183 037e 8217      		cp r24,r18
 1184 0380 9307      		cpc r25,r19
 1185 0382 01F0      		breq .L28
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1187               	.LM77:
 1188 0384 0097      		sbiw r24,0
 1189 0386 01F4      		brne .L29
 1190               	.L28:
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1192               	.LM78:
 1193 0388 E090 0000 		lds r14,pxCurrentTCB
 1194 038c F090 0000 		lds r15,pxCurrentTCB+1
 1195 0390 80E0      		ldi r24,lo8(0)
 1196 0392 90E0      		ldi r25,hi8(0)
 1197 0394 00C0      		rjmp .L30
 1198               	.L29:
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1200               	.LM79:
 1201 0396 7C01      		movw r14,r24
 1202               	.L30:
 791:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 1204               	.LM80:
 1205 0398 F701      		movw r30,r14
 1206 039a 3689      		ldd r19,Z+22
 795:../../freeRtos/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 1208               	.LM81:
 1209 039c 3617      		cp r19,r22
 1210 039e 01F4      		brne .+2
 1211 03a0 00C0      		rjmp .L31
 799:../../freeRtos/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 1213               	.LM82:
 1214 03a2 3617      		cp r19,r22
 1215 03a4 00F4      		brsh .L32
 807:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1217               	.LM83:
 1218 03a6 21E0      		ldi r18,lo8(1)
 1219 03a8 0097      		sbiw r24,0
 1220 03aa 01F4      		brne .L34
 1221 03ac 00C0      		rjmp .L38
 1222               	.L32:
 1223 03ae 21E0      		ldi r18,lo8(1)
 1224 03b0 0097      		sbiw r24,0
 1225 03b2 01F0      		breq .L34
 1226               	.L38:
 1227 03b4 20E0      		ldi r18,lo8(0)
 1228               	.L34:
 833:../../freeRtos/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 1230               	.LM84:
 1231 03b6 F701      		movw r30,r14
 1232 03b8 668B      		std Z+22,r22
 837:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 1234               	.LM85:
 1235 03ba 43E0      		ldi r20,lo8(3)
 1236 03bc 50E0      		ldi r21,hi8(3)
 1237 03be 461B      		sub r20,r22
 1238 03c0 5109      		sbc r21,__zero_reg__
 1239 03c2 4487      		std Z+12,r20
 1240 03c4 5587      		std Z+13,r21
 843:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 1242               	.LM86:
 1243 03c6 89E0      		ldi r24,lo8(9)
 1244 03c8 389F      		mul r19,r24
 1245 03ca C001      		movw r24,r0
 1246 03cc 1124      		clr r1
 1247 03ce 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1248 03d0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1249 03d2 4285      		ldd r20,Z+10
 1250 03d4 5385      		ldd r21,Z+11
 1251 03d6 4817      		cp r20,r24
 1252 03d8 5907      		cpc r21,r25
 1253 03da 01F4      		brne .L36
 848:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1255               	.LM87:
 1256 03dc 8701      		movw r16,r14
 1257 03de 0E5F      		subi r16,lo8(-(2))
 1258 03e0 1F4F      		sbci r17,hi8(-(2))
 1259 03e2 C801      		movw r24,r16
 1260 03e4 2983      		std Y+1,r18
 1261 03e6 0E94 0000 		call vListRemove
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1263               	.LM88:
 1264 03ea F701      		movw r30,r14
 1265 03ec 4689      		ldd r20,Z+22
 1266 03ee 8091 0000 		lds r24,uxTopReadyPriority
 1267 03f2 2981      		ldd r18,Y+1
 1268 03f4 8417      		cp r24,r20
 1269 03f6 00F4      		brsh .L37
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1271               	.LM89:
 1272 03f8 4093 0000 		sts uxTopReadyPriority,r20
 1273               	.L37:
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1275               	.LM90:
 1276 03fc 50E0      		ldi r21,lo8(0)
 1277 03fe CA01      		movw r24,r20
 1278 0400 E3E0      		ldi r30,3
 1279 0402 880F      	1:	lsl r24
 1280 0404 991F      		rol r25
 1281 0406 EA95      		dec r30
 1282 0408 01F4      		brne 1b
 1283 040a 840F      		add r24,r20
 1284 040c 951F      		adc r25,r21
 1285 040e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1286 0410 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1287 0412 B801      		movw r22,r16
 1288 0414 2983      		std Y+1,r18
 1289 0416 0E94 0000 		call vListInsertEnd
 1290 041a 2981      		ldd r18,Y+1
 1291               	.L36:
 852:../../freeRtos/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 1293               	.LM91:
 1294 041c 2130      		cpi r18,lo8(1)
 1295 041e 01F4      		brne .L31
 854:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1297               	.LM92:
 1298 0420 0E94 0000 		call vPortYield
 1299               	.L31:
 858:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1301               	.LM93:
 1302               	/* #APP */
 1303               	 ;  858 "../../freeRtos/Source/tasks.c" 1
 1304 0424 0F90      		pop		__tmp_reg__
 1305               	 ;  0 "" 2
 1306               	 ;  858 "../../freeRtos/Source/tasks.c" 1
 1307 0426 0FBE      		out		__SREG__, __tmp_reg__
 1308               	 ;  0 "" 2
 1309               	/* epilogue start */
 859:../../freeRtos/Source/tasks.c **** 	}
 1311               	.LM94:
 1312               	/* #NOAPP */
 1313 0428 0F90      		pop __tmp_reg__
 1314 042a CF91      		pop r28
 1315 042c DF91      		pop r29
 1316 042e 1F91      		pop r17
 1317 0430 0F91      		pop r16
 1318 0432 FF90      		pop r15
 1319 0434 EF90      		pop r14
 1320 0436 0895      		ret
 1327               	.Lscope5:
 1329               		.stabd	78,0,0
 1332               	.global	vTaskSuspend
 1334               	vTaskSuspend:
 1335               		.stabd	46,0,0
 867:../../freeRtos/Source/tasks.c **** 	{
 1337               	.LM95:
 1338               	.LFBB6:
 1339 0438 EF92      		push r14
 1340 043a FF92      		push r15
 1341 043c 0F93      		push r16
 1342 043e 1F93      		push r17
 1343 0440 CF93      		push r28
 1344 0442 DF93      		push r29
 1345               	/* prologue: function */
 1346               	/* frame size = 0 */
 1347               	/* stack size = 6 */
 1348               	.L__stack_usage = 6
 1349 0444 EC01      		movw r28,r24
 870:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1351               	.LM96:
 1352               	/* #APP */
 1353               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1354 0446 0FB6      		in		__tmp_reg__, __SREG__
 1355               	 ;  0 "" 2
 1356               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1357 0448 F894      		cli
 1358               	 ;  0 "" 2
 1359               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1360 044a 0F92      		push	__tmp_reg__
 1361               	 ;  0 "" 2
 874:../../freeRtos/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1363               	.LM97:
 1364               	/* #NOAPP */
 1365 044c 8091 0000 		lds r24,pxCurrentTCB
 1366 0450 9091 0000 		lds r25,pxCurrentTCB+1
 1367 0454 C817      		cp r28,r24
 1368 0456 D907      		cpc r29,r25
 1369 0458 01F0      		breq .L40
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1371               	.LM98:
 1372 045a 2097      		sbiw r28,0
 1373 045c 01F4      		brne .L41
 1374               	.L40:
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1376               	.LM99:
 1377 045e 0091 0000 		lds r16,pxCurrentTCB
 1378 0462 1091 0000 		lds r17,pxCurrentTCB+1
 1379 0466 C0E0      		ldi r28,lo8(0)
 1380 0468 D0E0      		ldi r29,hi8(0)
 1381 046a 00C0      		rjmp .L42
 1382               	.L41:
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1384               	.LM100:
 1385 046c 8E01      		movw r16,r28
 1386               	.L42:
 885:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1388               	.LM101:
 1389 046e F2E0      		ldi r31,lo8(2)
 1390 0470 EF2E      		mov r14,r31
 1391 0472 F12C      		mov r15,__zero_reg__
 1392 0474 E00E      		add r14,r16
 1393 0476 F11E      		adc r15,r17
 1394 0478 C701      		movw r24,r14
 1395 047a 0E94 0000 		call vListRemove
 888:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 1397               	.LM102:
 1398 047e F801      		movw r30,r16
 1399 0480 8489      		ldd r24,Z+20
 1400 0482 9589      		ldd r25,Z+21
 1401 0484 0097      		sbiw r24,0
 1402 0486 01F0      		breq .L43
 890:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1404               	.LM103:
 1405 0488 C801      		movw r24,r16
 1406 048a 0C96      		adiw r24,12
 1407 048c 0E94 0000 		call vListRemove
 1408               	.L43:
 893:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1410               	.LM104:
 1411 0490 80E0      		ldi r24,lo8(xSuspendedTaskList)
 1412 0492 90E0      		ldi r25,hi8(xSuspendedTaskList)
 1413 0494 B701      		movw r22,r14
 1414 0496 0E94 0000 		call vListInsertEnd
 895:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1416               	.LM105:
 1417               	/* #APP */
 1418               	 ;  895 "../../freeRtos/Source/tasks.c" 1
 1419 049a 0F90      		pop		__tmp_reg__
 1420               	 ;  0 "" 2
 1421               	 ;  895 "../../freeRtos/Source/tasks.c" 1
 1422 049c 0FBE      		out		__SREG__, __tmp_reg__
 1423               	 ;  0 "" 2
 898:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1425               	.LM106:
 1426               	/* #NOAPP */
 1427 049e 2097      		sbiw r28,0
 1428 04a0 01F4      		brne .L39
 900:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1430               	.LM107:
 1431 04a2 0E94 0000 		call vPortYield
 1432               	.L39:
 1433               	/* epilogue start */
 902:../../freeRtos/Source/tasks.c **** 	}
 1435               	.LM108:
 1436 04a6 DF91      		pop r29
 1437 04a8 CF91      		pop r28
 1438 04aa 1F91      		pop r17
 1439 04ac 0F91      		pop r16
 1440 04ae FF90      		pop r15
 1441 04b0 EF90      		pop r14
 1442 04b2 0895      		ret
 1447               	.Lscope6:
 1449               		.stabd	78,0,0
 1451               	.global	xTaskIsTaskSuspended
 1453               	xTaskIsTaskSuspended:
 1454               		.stabd	46,0,0
 910:../../freeRtos/Source/tasks.c **** 	{
 1456               	.LM109:
 1457               	.LFBB7:
 1458               	/* prologue: function */
 1459               	/* frame size = 0 */
 1460               	/* stack size = 0 */
 1461               	.L__stack_usage = 0
 912:../../freeRtos/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1463               	.LM110:
 1464 04b4 FC01      		movw r30,r24
 916:../../freeRtos/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1466               	.LM111:
 1467 04b6 8285      		ldd r24,Z+10
 1468 04b8 9385      		ldd r25,Z+11
 1469 04ba 20E0      		ldi r18,hi8(xSuspendedTaskList)
 1470 04bc 8030      		cpi r24,lo8(xSuspendedTaskList)
 1471 04be 9207      		cpc r25,r18
 1472 04c0 01F4      		brne .L48
 919:../../freeRtos/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1474               	.LM112:
 1475 04c2 2489      		ldd r18,Z+20
 1476 04c4 3589      		ldd r19,Z+21
 1477 04c6 80E0      		ldi r24,hi8(xPendingReadyList)
 1478 04c8 2030      		cpi r18,lo8(xPendingReadyList)
 1479 04ca 3807      		cpc r19,r24
 1480 04cc 01F0      		breq .L49
 911:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1482               	.LM113:
 1483 04ce 81E0      		ldi r24,lo8(1)
 1484 04d0 2115      		cp r18,__zero_reg__
 1485 04d2 3105      		cpc r19,__zero_reg__
 1486 04d4 01F0      		breq .L46
 1487               	.L48:
 1488 04d6 80E0      		ldi r24,lo8(0)
 1489 04d8 0895      		ret
 1490               	.L49:
 1491 04da 80E0      		ldi r24,lo8(0)
 1492               	.L46:
 933:../../freeRtos/Source/tasks.c **** 	}
 1494               	.LM114:
 1495 04dc 0895      		ret
 1500               	.Lscope7:
 1502               		.stabd	78,0,0
 1504               	.global	vTaskResume
 1506               	vTaskResume:
 1507               		.stabd	46,0,0
 941:../../freeRtos/Source/tasks.c **** 	{
 1509               	.LM115:
 1510               	.LFBB8:
 1511 04de EF92      		push r14
 1512 04e0 FF92      		push r15
 1513 04e2 0F93      		push r16
 1514 04e4 1F93      		push r17
 1515 04e6 CF93      		push r28
 1516 04e8 DF93      		push r29
 1517               	/* prologue: function */
 1518               	/* frame size = 0 */
 1519               	/* stack size = 6 */
 1520               	.L__stack_usage = 6
 946:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1522               	.LM116:
 1523 04ea E82E      		mov r14,r24
 1524 04ec E701      		movw r28,r14
 1525 04ee 7E01      		movw r14,r28
 1526 04f0 F92E      		mov r15,r25
 1527 04f2 E701      		movw r28,r14
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1529               	.LM117:
 1530 04f4 2097      		sbiw r28,0
 1531 04f6 01F0      		breq .L50
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1533               	.LM118:
 1534 04f8 8091 0000 		lds r24,pxCurrentTCB
 1535 04fc 9091 0000 		lds r25,pxCurrentTCB+1
 1536 0500 E816      		cp r14,r24
 1537 0502 F906      		cpc r15,r25
 1538 0504 01F0      		breq .L50
 952:../../freeRtos/Source/tasks.c **** 			portENTER_CRITICAL();
 1540               	.LM119:
 1541               	/* #APP */
 1542               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1543 0506 0FB6      		in		__tmp_reg__, __SREG__
 1544               	 ;  0 "" 2
 1545               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1546 0508 F894      		cli
 1547               	 ;  0 "" 2
 1548               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1549 050a 0F92      		push	__tmp_reg__
 1550               	 ;  0 "" 2
 954:../../freeRtos/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1552               	.LM120:
 1553               	/* #NOAPP */
 1554 050c C701      		movw r24,r14
 1555 050e 0E94 0000 		call xTaskIsTaskSuspended
 1556 0512 8130      		cpi r24,lo8(1)
 1557 0514 01F4      		brne .L52
 960:../../freeRtos/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1559               	.LM121:
 1560 0516 8701      		movw r16,r14
 1561 0518 0E5F      		subi r16,lo8(-(2))
 1562 051a 1F4F      		sbci r17,hi8(-(2))
 1563 051c C801      		movw r24,r16
 1564 051e 0E94 0000 		call vListRemove
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1566               	.LM122:
 1567 0522 2E89      		ldd r18,Y+22
 1568 0524 8091 0000 		lds r24,uxTopReadyPriority
 1569 0528 8217      		cp r24,r18
 1570 052a 00F4      		brsh .L53
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1572               	.LM123:
 1573 052c 2093 0000 		sts uxTopReadyPriority,r18
 1574               	.L53:
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1576               	.LM124:
 1577 0530 30E0      		ldi r19,lo8(0)
 1578 0532 C901      		movw r24,r18
 1579 0534 A3E0      		ldi r26,3
 1580 0536 880F      	1:	lsl r24
 1581 0538 991F      		rol r25
 1582 053a AA95      		dec r26
 1583 053c 01F4      		brne 1b
 1584 053e 820F      		add r24,r18
 1585 0540 931F      		adc r25,r19
 1586 0542 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1587 0544 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1588 0546 B801      		movw r22,r16
 1589 0548 0E94 0000 		call vListInsertEnd
 964:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1591               	.LM125:
 1592 054c E091 0000 		lds r30,pxCurrentTCB
 1593 0550 F091 0000 		lds r31,pxCurrentTCB+1
 1594 0554 9E89      		ldd r25,Y+22
 1595 0556 8689      		ldd r24,Z+22
 1596 0558 9817      		cp r25,r24
 1597 055a 00F0      		brlo .L52
 968:../../freeRtos/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1599               	.LM126:
 1600 055c 0E94 0000 		call vPortYield
 1601               	.L52:
 972:../../freeRtos/Source/tasks.c **** 			portEXIT_CRITICAL();
 1603               	.LM127:
 1604               	/* #APP */
 1605               	 ;  972 "../../freeRtos/Source/tasks.c" 1
 1606 0560 0F90      		pop		__tmp_reg__
 1607               	 ;  0 "" 2
 1608               	 ;  972 "../../freeRtos/Source/tasks.c" 1
 1609 0562 0FBE      		out		__SREG__, __tmp_reg__
 1610               	 ;  0 "" 2
 1611               	/* #NOAPP */
 1612               	.L50:
 1613               	/* epilogue start */
 974:../../freeRtos/Source/tasks.c **** 	}
 1615               	.LM128:
 1616 0564 DF91      		pop r29
 1617 0566 CF91      		pop r28
 1618 0568 1F91      		pop r17
 1619 056a 0F91      		pop r16
 1620 056c FF90      		pop r15
 1621 056e EF90      		pop r14
 1622 0570 0895      		ret
 1624               	.Lscope8:
 1626               		.stabd	78,0,0
 1628               	.global	xTaskResumeFromISR
 1630               	xTaskResumeFromISR:
 1631               		.stabd	46,0,0
 983:../../freeRtos/Source/tasks.c **** 	{
 1633               	.LM129:
 1634               	.LFBB9:
 1635 0572 EF92      		push r14
 1636 0574 FF92      		push r15
 1637 0576 0F93      		push r16
 1638 0578 1F93      		push r17
 1639 057a CF93      		push r28
 1640 057c DF93      		push r29
 1641               	/* prologue: function */
 1642               	/* frame size = 0 */
 1643               	/* stack size = 6 */
 1644               	.L__stack_usage = 6
 987:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1646               	.LM130:
 1647 057e E82E      		mov r14,r24
 1648 0580 E701      		movw r28,r14
 1649 0582 7E01      		movw r14,r28
 1650 0584 F92E      		mov r15,r25
 1651 0586 E701      		movw r28,r14
 989:../../freeRtos/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1653               	.LM131:
 1654 0588 C701      		movw r24,r14
 1655 058a 0E94 0000 		call xTaskIsTaskSuspended
 1656 058e 8130      		cpi r24,lo8(1)
 1657 0590 01F4      		brne .L59
 993:../../freeRtos/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1659               	.LM132:
 1660 0592 8091 0000 		lds r24,uxSchedulerSuspended
 1661 0596 8823      		tst r24
 1662 0598 01F4      		brne .L56
 995:../../freeRtos/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1664               	.LM133:
 1665 059a E091 0000 		lds r30,pxCurrentTCB
 1666 059e F091 0000 		lds r31,pxCurrentTCB+1
 1667 05a2 FF24      		clr r15
 1668 05a4 F394      		inc r15
 1669 05a6 9E89      		ldd r25,Y+22
 1670 05a8 8689      		ldd r24,Z+22
 1671 05aa 9817      		cp r25,r24
 1672 05ac 00F4      		brsh .L57
 1673 05ae FF24      		clr r15
 1674               	.L57:
 996:../../freeRtos/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1676               	.LM134:
 1677 05b0 8E01      		movw r16,r28
 1678 05b2 0E5F      		subi r16,lo8(-(2))
 1679 05b4 1F4F      		sbci r17,hi8(-(2))
 1680 05b6 C801      		movw r24,r16
 1681 05b8 0E94 0000 		call vListRemove
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1683               	.LM135:
 1684 05bc 4E89      		ldd r20,Y+22
 1685 05be 8091 0000 		lds r24,uxTopReadyPriority
 1686 05c2 8417      		cp r24,r20
 1687 05c4 00F4      		brsh .L58
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1689               	.LM136:
 1690 05c6 4093 0000 		sts uxTopReadyPriority,r20
 1691               	.L58:
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1693               	.LM137:
 1694 05ca 50E0      		ldi r21,lo8(0)
 1695 05cc 9A01      		movw r18,r20
 1696 05ce B3E0      		ldi r27,3
 1697 05d0 220F      	1:	lsl r18
 1698 05d2 331F      		rol r19
 1699 05d4 BA95      		dec r27
 1700 05d6 01F4      		brne 1b
 1701 05d8 240F      		add r18,r20
 1702 05da 351F      		adc r19,r21
 1703 05dc C901      		movw r24,r18
 1704 05de 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1705 05e0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1706 05e2 B801      		movw r22,r16
 1707 05e4 0E94 0000 		call vListInsertEnd
 1708 05e8 00C0      		rjmp .L55
 1709               	.L56:
1004:../../freeRtos/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1711               	.LM138:
 1712 05ea B701      		movw r22,r14
 1713 05ec 645F      		subi r22,lo8(-(12))
 1714 05ee 7F4F      		sbci r23,hi8(-(12))
 1715 05f0 80E0      		ldi r24,lo8(xPendingReadyList)
 1716 05f2 90E0      		ldi r25,hi8(xPendingReadyList)
 1717 05f4 0E94 0000 		call vListInsertEnd
 1718               	.L59:
 984:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1720               	.LM139:
 1721 05f8 FF24      		clr r15
 1722               	.L55:
1009:../../freeRtos/Source/tasks.c **** 	}
 1724               	.LM140:
 1725 05fa 8F2D      		mov r24,r15
 1726               	/* epilogue start */
 1727 05fc DF91      		pop r29
 1728 05fe CF91      		pop r28
 1729 0600 1F91      		pop r17
 1730 0602 0F91      		pop r16
 1731 0604 FF90      		pop r15
 1732 0606 EF90      		pop r14
 1733 0608 0895      		ret
 1738               	.Lscope9:
 1740               		.stabd	78,0,0
 1741               		.data
 1742               	.LC1:
 1743 0012 4944 4C45 		.string	"IDLE"
 1743      00
 1744               		.text
 1746               	.global	vTaskStartScheduler
 1748               	vTaskStartScheduler:
 1749               		.stabd	46,0,0
1022:../../freeRtos/Source/tasks.c **** {
 1751               	.LM141:
 1752               	.LFBB10:
 1753 060a AF92      		push r10
 1754 060c BF92      		push r11
 1755 060e CF92      		push r12
 1756 0610 DF92      		push r13
 1757 0612 EF92      		push r14
 1758 0614 FF92      		push r15
 1759 0616 0F93      		push r16
 1760               	/* prologue: function */
 1761               	/* frame size = 0 */
 1762               	/* stack size = 7 */
 1763               	.L__stack_usage = 7
1026:../../freeRtos/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 1765               	.LM142:
 1766 0618 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1767 061a 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1768 061c 60E0      		ldi r22,lo8(.LC1)
 1769 061e 70E0      		ldi r23,hi8(.LC1)
 1770 0620 46E9      		ldi r20,lo8(150)
 1771 0622 50E0      		ldi r21,hi8(150)
 1772 0624 20E0      		ldi r18,lo8(0)
 1773 0626 30E0      		ldi r19,hi8(0)
 1774 0628 00E0      		ldi r16,lo8(0)
 1775 062a EE24      		clr r14
 1776 062c FF24      		clr r15
 1777 062e CC24      		clr r12
 1778 0630 DD24      		clr r13
 1779 0632 AA24      		clr r10
 1780 0634 BB24      		clr r11
 1781 0636 0E94 0000 		call xTaskGenericCreate
1028:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
 1783               	.LM143:
 1784 063a 8130      		cpi r24,lo8(1)
 1785 063c 01F4      		brne .L60
1038:../../freeRtos/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1787               	.LM144:
 1788               	/* #APP */
 1789               	 ;  1038 "../../freeRtos/Source/tasks.c" 1
 1790 063e F894      		cli
 1791               	 ;  0 "" 2
1040:../../freeRtos/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1793               	.LM145:
 1794               	/* #NOAPP */
 1795 0640 8093 0000 		sts xSchedulerRunning,r24
1041:../../freeRtos/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
 1797               	.LM146:
 1798 0644 1092 0000 		sts xTickCount,__zero_reg__
 1799 0648 1092 0000 		sts xTickCount+1,__zero_reg__
1050:../../freeRtos/Source/tasks.c **** 		if( xPortStartScheduler() )
 1801               	.LM147:
 1802 064c 0E94 0000 		call xPortStartScheduler
 1803               	.L60:
 1804               	/* epilogue start */
1060:../../freeRtos/Source/tasks.c **** }
 1806               	.LM148:
 1807 0650 0F91      		pop r16
 1808 0652 FF90      		pop r15
 1809 0654 EF90      		pop r14
 1810 0656 DF90      		pop r13
 1811 0658 CF90      		pop r12
 1812 065a BF90      		pop r11
 1813 065c AF90      		pop r10
 1814 065e 0895      		ret
 1816               	.Lscope10:
 1818               		.stabd	78,0,0
 1820               	.global	vTaskEndScheduler
 1822               	vTaskEndScheduler:
 1823               		.stabd	46,0,0
1064:../../freeRtos/Source/tasks.c **** {
 1825               	.LM149:
 1826               	.LFBB11:
 1827               	/* prologue: function */
 1828               	/* frame size = 0 */
 1829               	/* stack size = 0 */
 1830               	.L__stack_usage = 0
1068:../../freeRtos/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1832               	.LM150:
 1833               	/* #APP */
 1834               	 ;  1068 "../../freeRtos/Source/tasks.c" 1
 1835 0660 F894      		cli
 1836               	 ;  0 "" 2
1069:../../freeRtos/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1838               	.LM151:
 1839               	/* #NOAPP */
 1840 0662 1092 0000 		sts xSchedulerRunning,__zero_reg__
1070:../../freeRtos/Source/tasks.c **** 	vPortEndScheduler();
 1842               	.LM152:
 1843 0666 0E94 0000 		call vPortEndScheduler
 1844               	/* epilogue start */
1071:../../freeRtos/Source/tasks.c **** }
 1846               	.LM153:
 1847 066a 0895      		ret
 1849               	.Lscope11:
 1851               		.stabd	78,0,0
 1853               	.global	vTaskSuspendAll
 1855               	vTaskSuspendAll:
 1856               		.stabd	46,0,0
1075:../../freeRtos/Source/tasks.c **** {
 1858               	.LM154:
 1859               	.LFBB12:
 1860               	/* prologue: function */
 1861               	/* frame size = 0 */
 1862               	/* stack size = 0 */
 1863               	.L__stack_usage = 0
1078:../../freeRtos/Source/tasks.c **** 	++uxSchedulerSuspended;
 1865               	.LM155:
 1866 066c 8091 0000 		lds r24,uxSchedulerSuspended
 1867 0670 8F5F      		subi r24,lo8(-(1))
 1868 0672 8093 0000 		sts uxSchedulerSuspended,r24
 1869               	/* epilogue start */
1079:../../freeRtos/Source/tasks.c **** }
 1871               	.LM156:
 1872 0676 0895      		ret
 1874               	.Lscope12:
 1876               		.stabd	78,0,0
 1878               	.global	xTaskGetTickCount
 1880               	xTaskGetTickCount:
 1881               		.stabd	46,0,0
1165:../../freeRtos/Source/tasks.c **** {
 1883               	.LM157:
 1884               	.LFBB13:
 1885               	/* prologue: function */
 1886               	/* frame size = 0 */
 1887               	/* stack size = 0 */
 1888               	.L__stack_usage = 0
1169:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 1890               	.LM158:
 1891               	/* #APP */
 1892               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1893 0678 0FB6      		in		__tmp_reg__, __SREG__
 1894               	 ;  0 "" 2
 1895               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1896 067a F894      		cli
 1897               	 ;  0 "" 2
 1898               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1899 067c 0F92      		push	__tmp_reg__
 1900               	 ;  0 "" 2
1171:../../freeRtos/Source/tasks.c **** 		xTicks = xTickCount;
 1902               	.LM159:
 1903               	/* #NOAPP */
 1904 067e 2091 0000 		lds r18,xTickCount
 1905 0682 3091 0000 		lds r19,xTickCount+1
1173:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 1907               	.LM160:
 1908               	/* #APP */
 1909               	 ;  1173 "../../freeRtos/Source/tasks.c" 1
 1910 0686 0F90      		pop		__tmp_reg__
 1911               	 ;  0 "" 2
 1912               	 ;  1173 "../../freeRtos/Source/tasks.c" 1
 1913 0688 0FBE      		out		__SREG__, __tmp_reg__
 1914               	 ;  0 "" 2
1176:../../freeRtos/Source/tasks.c **** }
 1916               	.LM161:
 1917               	/* #NOAPP */
 1918 068a C901      		movw r24,r18
 1919               	/* epilogue start */
 1920 068c 0895      		ret
 1925               	.Lscope13:
 1927               		.stabd	78,0,0
 1929               	.global	uxTaskGetNumberOfTasks
 1931               	uxTaskGetNumberOfTasks:
 1932               		.stabd	46,0,0
1180:../../freeRtos/Source/tasks.c **** {
 1934               	.LM162:
 1935               	.LFBB14:
 1936               	/* prologue: function */
 1937               	/* frame size = 0 */
 1938               	/* stack size = 0 */
 1939               	.L__stack_usage = 0
1183:../../freeRtos/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1941               	.LM163:
 1942 068e 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1943               	/* epilogue start */
1184:../../freeRtos/Source/tasks.c **** }
 1945               	.LM164:
 1946 0692 0895      		ret
 1948               	.Lscope14:
 1950               		.stabd	78,0,0
 1954               	.global	vTaskStartTrace
 1956               	vTaskStartTrace:
 1957               		.stabd	46,0,0
1318:../../freeRtos/Source/tasks.c **** 	{
 1959               	.LM165:
 1960               	.LFBB15:
 1961               	/* prologue: function */
 1962               	/* frame size = 0 */
 1963               	/* stack size = 0 */
 1964               	.L__stack_usage = 0
1319:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1966               	.LM166:
 1967               	/* #APP */
 1968               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1969 0694 0FB6      		in		__tmp_reg__, __SREG__
 1970               	 ;  0 "" 2
 1971               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1972 0696 F894      		cli
 1973               	 ;  0 "" 2
 1974               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1975 0698 0F92      		push	__tmp_reg__
 1976               	 ;  0 "" 2
1321:../../freeRtos/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
 1978               	.LM167:
 1979               	/* #NOAPP */
 1980 069a 8093 0000 		sts pcTraceBuffer,r24
 1981 069e 9093 0000 		sts pcTraceBuffer+1,r25
1322:../../freeRtos/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
 1983               	.LM168:
 1984 06a2 8093 0000 		sts pcTraceBufferStart,r24
 1985 06a6 9093 0000 		sts pcTraceBufferStart+1,r25
1323:../../freeRtos/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
 1987               	.LM169:
 1988 06aa 4850      		subi r20,lo8(-(-8))
 1989 06ac 5040      		sbci r21,hi8(-(-8))
 1990 06ae 480F      		add r20,r24
 1991 06b0 591F      		adc r21,r25
 1992 06b2 4093 0000 		sts pcTraceBufferEnd,r20
 1993 06b6 5093 0000 		sts pcTraceBufferEnd+1,r21
1324:../../freeRtos/Source/tasks.c **** 			xTracing = pdTRUE;
 1995               	.LM170:
 1996 06ba 81E0      		ldi r24,lo8(1)
 1997 06bc 8093 0000 		sts xTracing,r24
1326:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1999               	.LM171:
 2000               	/* #APP */
 2001               	 ;  1326 "../../freeRtos/Source/tasks.c" 1
 2002 06c0 0F90      		pop		__tmp_reg__
 2003               	 ;  0 "" 2
 2004               	 ;  1326 "../../freeRtos/Source/tasks.c" 1
 2005 06c2 0FBE      		out		__SREG__, __tmp_reg__
 2006               	 ;  0 "" 2
 2007               	/* epilogue start */
1327:../../freeRtos/Source/tasks.c **** 	}
 2009               	.LM172:
 2010               	/* #NOAPP */
 2011 06c4 0895      		ret
 2013               	.Lscope15:
 2015               		.stabd	78,0,0
 2017               	.global	ulTaskEndTrace
 2019               	ulTaskEndTrace:
 2020               		.stabd	46,0,0
1335:../../freeRtos/Source/tasks.c **** 	{
 2022               	.LM173:
 2023               	.LFBB16:
 2024               	/* prologue: function */
 2025               	/* frame size = 0 */
 2026               	/* stack size = 0 */
 2027               	.L__stack_usage = 0
1338:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 2029               	.LM174:
 2030               	/* #APP */
 2031               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 2032 06c6 0FB6      		in		__tmp_reg__, __SREG__
 2033               	 ;  0 "" 2
 2034               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 2035 06c8 F894      		cli
 2036               	 ;  0 "" 2
 2037               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 2038 06ca 0F92      		push	__tmp_reg__
 2039               	 ;  0 "" 2
1339:../../freeRtos/Source/tasks.c **** 			xTracing = pdFALSE;
 2041               	.LM175:
 2042               	/* #NOAPP */
 2043 06cc 1092 0000 		sts xTracing,__zero_reg__
1340:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 2045               	.LM176:
 2046               	/* #APP */
 2047               	 ;  1340 "../../freeRtos/Source/tasks.c" 1
 2048 06d0 0F90      		pop		__tmp_reg__
 2049               	 ;  0 "" 2
 2050               	 ;  1340 "../../freeRtos/Source/tasks.c" 1
 2051 06d2 0FBE      		out		__SREG__, __tmp_reg__
 2052               	 ;  0 "" 2
1342:../../freeRtos/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
 2054               	.LM177:
 2055               	/* #NOAPP */
 2056 06d4 2091 0000 		lds r18,pcTraceBuffer
 2057 06d8 3091 0000 		lds r19,pcTraceBuffer+1
 2058 06dc 8091 0000 		lds r24,pcTraceBufferStart
 2059 06e0 9091 0000 		lds r25,pcTraceBufferStart+1
 2060 06e4 281B      		sub r18,r24
 2061 06e6 390B      		sbc r19,r25
 2062 06e8 4427      		clr r20
 2063 06ea 37FD      		sbrc r19,7
 2064 06ec 4095      		com r20
 2065 06ee 542F      		mov r21,r20
1345:../../freeRtos/Source/tasks.c **** 	}
 2067               	.LM178:
 2068 06f0 B901      		movw r22,r18
 2069 06f2 CA01      		movw r24,r20
 2070               	/* epilogue start */
 2071 06f4 0895      		ret
 2073               	.Lscope16:
 2075               		.stabd	78,0,0
 2077               	.global	vTaskIncrementTick
 2079               	vTaskIncrementTick:
 2080               		.stabd	46,0,0
1358:../../freeRtos/Source/tasks.c **** {
 2082               	.LM179:
 2083               	.LFBB17:
 2084 06f6 0F93      		push r16
 2085 06f8 1F93      		push r17
 2086 06fa CF93      		push r28
 2087 06fc DF93      		push r29
 2088               	/* prologue: function */
 2089               	/* frame size = 0 */
 2090               	/* stack size = 4 */
 2091               	.L__stack_usage = 4
1362:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2093               	.LM180:
 2094 06fe 8091 0000 		lds r24,uxSchedulerSuspended
 2095 0702 8823      		tst r24
 2096 0704 01F0      		breq .+2
 2097 0706 00C0      		rjmp .L69
1364:../../freeRtos/Source/tasks.c **** 		++xTickCount;
 2099               	.LM181:
 2100 0708 8091 0000 		lds r24,xTickCount
 2101 070c 9091 0000 		lds r25,xTickCount+1
 2102 0710 0196      		adiw r24,1
 2103 0712 8093 0000 		sts xTickCount,r24
 2104 0716 9093 0000 		sts xTickCount+1,r25
1365:../../freeRtos/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
 2106               	.LM182:
 2107 071a 8091 0000 		lds r24,xTickCount
 2108 071e 9091 0000 		lds r25,xTickCount+1
 2109 0722 0097      		sbiw r24,0
 2110 0724 01F0      		breq .+2
 2111 0726 00C0      		rjmp .L76
 2112               	.LBB31:
1372:../../freeRtos/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2114               	.LM183:
 2115 0728 8091 0000 		lds r24,pxDelayedTaskList
 2116 072c 9091 0000 		lds r25,pxDelayedTaskList+1
1373:../../freeRtos/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2118               	.LM184:
 2119 0730 2091 0000 		lds r18,pxOverflowDelayedTaskList
 2120 0734 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 2121 0738 2093 0000 		sts pxDelayedTaskList,r18
 2122 073c 3093 0000 		sts pxDelayedTaskList+1,r19
1374:../../freeRtos/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2124               	.LM185:
 2125 0740 8093 0000 		sts pxOverflowDelayedTaskList,r24
 2126 0744 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
1375:../../freeRtos/Source/tasks.c **** 			xNumOfOverflows++;
 2128               	.LM186:
 2129 0748 8091 0000 		lds r24,xNumOfOverflows
 2130 074c 8F5F      		subi r24,lo8(-(1))
 2131 074e 8093 0000 		sts xNumOfOverflows,r24
 2132 0752 00C0      		rjmp .L76
 2133               	.L75:
 2134               	.LBE31:
 2135               	.LBB32:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2137               	.LM187:
 2138 0754 2091 0000 		lds r18,xTickCount
 2139 0758 3091 0000 		lds r19,xTickCount+1
 2140 075c 8A81      		ldd r24,Y+2
 2141 075e 9B81      		ldd r25,Y+3
 2142 0760 2817      		cp r18,r24
 2143 0762 3907      		cpc r19,r25
 2144 0764 00F0      		brlo .L68
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2146               	.LM188:
 2147 0766 8E01      		movw r16,r28
 2148 0768 0E5F      		subi r16,lo8(-(2))
 2149 076a 1F4F      		sbci r17,hi8(-(2))
 2150 076c C801      		movw r24,r16
 2151 076e 0E94 0000 		call vListRemove
 2152 0772 8C89      		ldd r24,Y+20
 2153 0774 9D89      		ldd r25,Y+21
 2154 0776 0097      		sbiw r24,0
 2155 0778 01F0      		breq .L73
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2157               	.LM189:
 2158 077a CE01      		movw r24,r28
 2159 077c 0C96      		adiw r24,12
 2160 077e 0E94 0000 		call vListRemove
 2161               	.L73:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2163               	.LM190:
 2164 0782 2E89      		ldd r18,Y+22
 2165 0784 8091 0000 		lds r24,uxTopReadyPriority
 2166 0788 8217      		cp r24,r18
 2167 078a 00F4      		brsh .L74
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2169               	.LM191:
 2170 078c 2093 0000 		sts uxTopReadyPriority,r18
 2171               	.L74:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2173               	.LM192:
 2174 0790 30E0      		ldi r19,lo8(0)
 2175 0792 C901      		movw r24,r18
 2176 0794 43E0      		ldi r20,3
 2177 0796 880F      	1:	lsl r24
 2178 0798 991F      		rol r25
 2179 079a 4A95      		dec r20
 2180 079c 01F4      		brne 1b
 2181 079e 820F      		add r24,r18
 2182 07a0 931F      		adc r25,r19
 2183 07a2 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2184 07a4 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2185 07a6 B801      		movw r22,r16
 2186 07a8 0E94 0000 		call vListInsertEnd
 2187               	.L76:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2189               	.LM193:
 2190 07ac E091 0000 		lds r30,pxDelayedTaskList
 2191 07b0 F091 0000 		lds r31,pxDelayedTaskList+1
 2192 07b4 8081      		ld r24,Z
 2193 07b6 8823      		tst r24
 2194 07b8 01F0      		breq .L68
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2196               	.LM194:
 2197 07ba E091 0000 		lds r30,pxDelayedTaskList
 2198 07be F091 0000 		lds r31,pxDelayedTaskList+1
 2199 07c2 0580      		ldd __tmp_reg__,Z+5
 2200 07c4 F681      		ldd r31,Z+6
 2201 07c6 E02D      		mov r30,__tmp_reg__
 2202 07c8 C681      		ldd r28,Z+6
 2203 07ca D781      		ldd r29,Z+7
 2204 07cc 2097      		sbiw r28,0
 2205 07ce 01F4      		brne .L75
 2206 07d0 00C0      		rjmp .L68
 2207               	.L69:
 2208               	.LBE32:
1383:../../freeRtos/Source/tasks.c **** 		++uxMissedTicks;
 2210               	.LM195:
 2211 07d2 8091 0000 		lds r24,uxMissedTicks
 2212 07d6 8F5F      		subi r24,lo8(-(1))
 2213 07d8 8093 0000 		sts uxMissedTicks,r24
 2214               	.L68:
 2215               	/* epilogue start */
1410:../../freeRtos/Source/tasks.c **** }
 2217               	.LM196:
 2218 07dc DF91      		pop r29
 2219 07de CF91      		pop r28
 2220 07e0 1F91      		pop r17
 2221 07e2 0F91      		pop r16
 2222 07e4 0895      		ret
 2230               	.Lscope17:
 2232               		.stabd	78,0,0
 2234               	.global	xTaskResumeAll
 2236               	xTaskResumeAll:
 2237               		.stabd	46,0,0
1083:../../freeRtos/Source/tasks.c **** {
 2239               	.LM197:
 2240               	.LFBB18:
 2241 07e6 EF92      		push r14
 2242 07e8 FF92      		push r15
 2243 07ea 0F93      		push r16
 2244 07ec 1F93      		push r17
 2245 07ee DF93      		push r29
 2246 07f0 CF93      		push r28
 2247 07f2 0F92      		push __tmp_reg__
 2248 07f4 CDB7      		in r28,__SP_L__
 2249 07f6 DEB7      		in r29,__SP_H__
 2250               	/* prologue: function */
 2251               	/* frame size = 1 */
 2252               	/* stack size = 7 */
 2253               	.L__stack_usage = 7
1092:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 2255               	.LM198:
 2256               	/* #APP */
 2257               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 2258 07f8 0FB6      		in		__tmp_reg__, __SREG__
 2259               	 ;  0 "" 2
 2260               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 2261 07fa F894      		cli
 2262               	 ;  0 "" 2
 2263               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 2264 07fc 0F92      		push	__tmp_reg__
 2265               	 ;  0 "" 2
1094:../../freeRtos/Source/tasks.c **** 		--uxSchedulerSuspended;
 2267               	.LM199:
 2268               	/* #NOAPP */
 2269 07fe 8091 0000 		lds r24,uxSchedulerSuspended
 2270 0802 8150      		subi r24,lo8(-(-1))
 2271 0804 8093 0000 		sts uxSchedulerSuspended,r24
1096:../../freeRtos/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2273               	.LM200:
 2274 0808 8091 0000 		lds r24,uxSchedulerSuspended
 2275 080c 8823      		tst r24
 2276 080e 01F0      		breq .+2
 2277 0810 00C0      		rjmp .L91
1098:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 2279               	.LM201:
 2280 0812 8091 0000 		lds r24,uxCurrentNumberOfTasks
 2281 0816 8823      		tst r24
 2282 0818 01F4      		brne .+2
 2283 081a 00C0      		rjmp .L91
1098:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 2285               	.LM202:
 2286 081c 1982      		std Y+1,__zero_reg__
 2287 081e 00C0      		rjmp .L93
 2288               	.L83:
 2289               	.LBB33:
1106:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 2291               	.LM203:
 2292 0820 C701      		movw r24,r14
 2293 0822 0C96      		adiw r24,12
 2294 0824 0E94 0000 		call vListRemove
1107:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 2296               	.LM204:
 2297 0828 8701      		movw r16,r14
 2298 082a 0E5F      		subi r16,lo8(-(2))
 2299 082c 1F4F      		sbci r17,hi8(-(2))
 2300 082e C801      		movw r24,r16
 2301 0830 0E94 0000 		call vListRemove
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2303               	.LM205:
 2304 0834 D701      		movw r26,r14
 2305 0836 5696      		adiw r26,22
 2306 0838 2C91      		ld r18,X
 2307 083a 5697      		sbiw r26,22
 2308 083c 8091 0000 		lds r24,uxTopReadyPriority
 2309 0840 8217      		cp r24,r18
 2310 0842 00F4      		brsh .L80
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2312               	.LM206:
 2313 0844 2093 0000 		sts uxTopReadyPriority,r18
 2314               	.L80:
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2316               	.LM207:
 2317 0848 30E0      		ldi r19,lo8(0)
 2318 084a C901      		movw r24,r18
 2319 084c 53E0      		ldi r21,3
 2320 084e 880F      	1:	lsl r24
 2321 0850 991F      		rol r25
 2322 0852 5A95      		dec r21
 2323 0854 01F4      		brne 1b
 2324 0856 820F      		add r24,r18
 2325 0858 931F      		adc r25,r19
 2326 085a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2327 085c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2328 085e B801      		movw r22,r16
 2329 0860 0E94 0000 		call vListInsertEnd
1112:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2331               	.LM208:
 2332 0864 E091 0000 		lds r30,pxCurrentTCB
 2333 0868 F091 0000 		lds r31,pxCurrentTCB+1
 2334 086c D701      		movw r26,r14
 2335 086e 5696      		adiw r26,22
 2336 0870 9C91      		ld r25,X
 2337 0872 5697      		sbiw r26,22
 2338 0874 8689      		ldd r24,Z+22
 2339 0876 9817      		cp r25,r24
 2340 0878 00F0      		brlo .L93
1114:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 2342               	.LM209:
 2343 087a B1E0      		ldi r27,lo8(1)
 2344 087c B983      		std Y+1,r27
 2345               	.L93:
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 2347               	.LM210:
 2348 087e 8091 0000 		lds r24,xPendingReadyList
 2349 0882 8823      		tst r24
 2350 0884 01F0      		breq .L82
 2351 0886 E091 0000 		lds r30,xPendingReadyList+5
 2352 088a F091 0000 		lds r31,xPendingReadyList+5+1
 2353 088e E680      		ldd r14,Z+6
 2354 0890 F780      		ldd r15,Z+7
 2355 0892 E114      		cp r14,__zero_reg__
 2356 0894 F104      		cpc r15,__zero_reg__
 2357 0896 01F4      		brne .L83
 2358               	.L82:
1121:../../freeRtos/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 2360               	.LM211:
 2361 0898 8091 0000 		lds r24,uxMissedTicks
 2362 089c 8823      		tst r24
 2363 089e 01F4      		brne .L92
 2364 08a0 00C0      		rjmp .L85
 2365               	.L86:
1125:../../freeRtos/Source/tasks.c **** 						vTaskIncrementTick();
 2367               	.LM212:
 2368 08a2 0E94 0000 		call vTaskIncrementTick
1126:../../freeRtos/Source/tasks.c **** 						--uxMissedTicks;
 2370               	.LM213:
 2371 08a6 8091 0000 		lds r24,uxMissedTicks
 2372 08aa 8150      		subi r24,lo8(-(-1))
 2373 08ac 8093 0000 		sts uxMissedTicks,r24
 2374               	.L92:
1123:../../freeRtos/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 2376               	.LM214:
 2377 08b0 8091 0000 		lds r24,uxMissedTicks
 2378 08b4 8823      		tst r24
 2379 08b6 01F4      		brne .L86
 2380               	.L85:
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 2382               	.LM215:
 2383 08b8 E981      		ldd r30,Y+1
 2384 08ba E130      		cpi r30,lo8(1)
 2385 08bc 01F0      		breq .L87
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 2387               	.LM216:
 2388 08be 8091 0000 		lds r24,xMissedYield
 2389 08c2 8130      		cpi r24,lo8(1)
 2390 08c4 01F4      		brne .L91
 2391               	.L87:
1142:../../freeRtos/Source/tasks.c **** 					xMissedYield = pdFALSE;
 2393               	.LM217:
 2394 08c6 1092 0000 		sts xMissedYield,__zero_reg__
1143:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 2396               	.LM218:
 2397 08ca 0E94 0000 		call vPortYield
1141:../../freeRtos/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 2399               	.LM219:
 2400 08ce 81E0      		ldi r24,lo8(1)
 2401 08d0 00C0      		rjmp .L78
 2402               	.L91:
1085:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 2404               	.LM220:
 2405 08d2 80E0      		ldi r24,lo8(0)
 2406               	.L78:
 2407               	.LBE33:
1148:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 2409               	.LM221:
 2410               	/* #APP */
 2411               	 ;  1148 "../../freeRtos/Source/tasks.c" 1
 2412 08d4 0F90      		pop		__tmp_reg__
 2413               	 ;  0 "" 2
 2414               	 ;  1148 "../../freeRtos/Source/tasks.c" 1
 2415 08d6 0FBE      		out		__SREG__, __tmp_reg__
 2416               	 ;  0 "" 2
 2417               	/* epilogue start */
1151:../../freeRtos/Source/tasks.c **** }
 2419               	.LM222:
 2420               	/* #NOAPP */
 2421 08d8 0F90      		pop __tmp_reg__
 2422 08da CF91      		pop r28
 2423 08dc DF91      		pop r29
 2424 08de 1F91      		pop r17
 2425 08e0 0F91      		pop r16
 2426 08e2 FF90      		pop r15
 2427 08e4 EF90      		pop r14
 2428 08e6 0895      		ret
 2437               	.Lscope18:
 2439               		.stabd	78,0,0
 2440               		.data
 2441               	.LC2:
 2442 0017 0D0A 00   		.string	"\r\n"
 2443               		.text
 2446               	.global	vTaskList
 2448               	vTaskList:
 2449               		.stabd	46,0,0
1190:../../freeRtos/Source/tasks.c **** 	{
 2451               	.LM223:
 2452               	.LFBB19:
 2453 08e8 1F93      		push r17
 2454 08ea CF93      		push r28
 2455 08ec DF93      		push r29
 2456               	/* prologue: function */
 2457               	/* frame size = 0 */
 2458               	/* stack size = 3 */
 2459               	.L__stack_usage = 3
 2460 08ee EC01      		movw r28,r24
1196:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 2462               	.LM224:
 2463 08f0 0E94 0000 		call vTaskSuspendAll
1201:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
 2465               	.LM225:
 2466 08f4 1882      		st Y,__zero_reg__
1202:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 2468               	.LM226:
 2469 08f6 CE01      		movw r24,r28
 2470 08f8 60E0      		ldi r22,lo8(.LC2)
 2471 08fa 70E0      		ldi r23,hi8(.LC2)
 2472 08fc 0E94 0000 		call strcat
1204:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
 2474               	.LM227:
 2475 0900 1091 0000 		lds r17,uxTopUsedPriority
 2476 0904 1F5F      		subi r17,lo8(-(1))
 2477               	.L96:
1208:../../freeRtos/Source/tasks.c **** 				uxQueue--;
 2479               	.LM228:
 2480 0906 1150      		subi r17,lo8(-(-1))
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 2482               	.LM229:
 2483 0908 812F      		mov r24,r17
 2484 090a 90E0      		ldi r25,lo8(0)
 2485 090c BC01      		movw r22,r24
 2486 090e E3E0      		ldi r30,3
 2487 0910 660F      	1:	lsl r22
 2488 0912 771F      		rol r23
 2489 0914 EA95      		dec r30
 2490 0916 01F4      		brne 1b
 2491 0918 680F      		add r22,r24
 2492 091a 791F      		adc r23,r25
 2493 091c 6050      		subi r22,lo8(-(pxReadyTasksLists))
 2494 091e 7040      		sbci r23,hi8(-(pxReadyTasksLists))
 2495 0920 FB01      		movw r30,r22
 2496 0922 8081      		ld r24,Z
 2497 0924 8823      		tst r24
 2498 0926 01F0      		breq .L95
1212:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 2500               	.LM230:
 2501 0928 CE01      		movw r24,r28
 2502 092a 42E5      		ldi r20,lo8(82)
 2503 092c 0E94 0000 		call prvListTaskWithinSingleList
 2504               	.L95:
1214:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 2506               	.LM231:
 2507 0930 1123      		tst r17
 2508 0932 01F4      		brne .L96
1216:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
 2510               	.LM232:
 2511 0934 E091 0000 		lds r30,pxDelayedTaskList
 2512 0938 F091 0000 		lds r31,pxDelayedTaskList+1
 2513 093c 8081      		ld r24,Z
 2514 093e 8823      		tst r24
 2515 0940 01F0      		breq .L97
1218:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 2517               	.LM233:
 2518 0942 6091 0000 		lds r22,pxDelayedTaskList
 2519 0946 7091 0000 		lds r23,pxDelayedTaskList+1
 2520 094a CE01      		movw r24,r28
 2521 094c 42E4      		ldi r20,lo8(66)
 2522 094e 0E94 0000 		call prvListTaskWithinSingleList
 2523               	.L97:
1221:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
 2525               	.LM234:
 2526 0952 E091 0000 		lds r30,pxOverflowDelayedTaskList
 2527 0956 F091 0000 		lds r31,pxOverflowDelayedTaskList+1
 2528 095a 8081      		ld r24,Z
 2529 095c 8823      		tst r24
 2530 095e 01F0      		breq .L98
1223:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 2532               	.LM235:
 2533 0960 6091 0000 		lds r22,pxOverflowDelayedTaskList
 2534 0964 7091 0000 		lds r23,pxOverflowDelayedTaskList+1
 2535 0968 CE01      		movw r24,r28
 2536 096a 42E4      		ldi r20,lo8(66)
 2537 096c 0E94 0000 		call prvListTaskWithinSingleList
 2538               	.L98:
1237:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
 2540               	.LM236:
 2541 0970 8091 0000 		lds r24,xSuspendedTaskList
 2542 0974 8823      		tst r24
 2543 0976 01F0      		breq .L99
1239:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
 2545               	.LM237:
 2546 0978 CE01      		movw r24,r28
 2547 097a 60E0      		ldi r22,lo8(xSuspendedTaskList)
 2548 097c 70E0      		ldi r23,hi8(xSuspendedTaskList)
 2549 097e 43E5      		ldi r20,lo8(83)
 2550 0980 0E94 0000 		call prvListTaskWithinSingleList
 2551               	.L99:
1244:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
 2553               	.LM238:
 2554 0984 0E94 0000 		call xTaskResumeAll
 2555               	/* epilogue start */
1245:../../freeRtos/Source/tasks.c **** 	}
 2557               	.LM239:
 2558 0988 DF91      		pop r29
 2559 098a CF91      		pop r28
 2560 098c 1F91      		pop r17
 2561 098e 0895      		ret
 2566               	.Lscope19:
 2568               		.stabd	78,0,0
 2571               	.global	vTaskDelay
 2573               	vTaskDelay:
 2574               		.stabd	46,0,0
 679:../../freeRtos/Source/tasks.c **** 	{
 2576               	.LM240:
 2577               	.LFBB20:
 2578 0990 0F93      		push r16
 2579 0992 1F93      		push r17
 2580 0994 CF93      		push r28
 2581 0996 DF93      		push r29
 2582               	/* prologue: function */
 2583               	/* frame size = 0 */
 2584               	/* stack size = 4 */
 2585               	.L__stack_usage = 4
 2586 0998 8C01      		movw r16,r24
 684:../../freeRtos/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 2588               	.LM241:
 2589 099a 0097      		sbiw r24,0
 2590 099c 01F0      		breq .L102
 686:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
 2592               	.LM242:
 2593 099e 0E94 0000 		call vTaskSuspendAll
 700:../../freeRtos/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 2595               	.LM243:
 2596 09a2 C091 0000 		lds r28,xTickCount
 2597 09a6 D091 0000 		lds r29,xTickCount+1
 2598 09aa C00F      		add r28,r16
 2599 09ac D11F      		adc r29,r17
 705:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2601               	.LM244:
 2602 09ae 8091 0000 		lds r24,pxCurrentTCB
 2603 09b2 9091 0000 		lds r25,pxCurrentTCB+1
 2604 09b6 0296      		adiw r24,2
 2605 09b8 0E94 0000 		call vListRemove
 708:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2607               	.LM245:
 2608 09bc E091 0000 		lds r30,pxCurrentTCB
 2609 09c0 F091 0000 		lds r31,pxCurrentTCB+1
 2610 09c4 C283      		std Z+2,r28
 2611 09c6 D383      		std Z+3,r29
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2613               	.LM246:
 2614 09c8 8091 0000 		lds r24,xTickCount
 2615 09cc 9091 0000 		lds r25,xTickCount+1
 2616 09d0 C817      		cp r28,r24
 2617 09d2 D907      		cpc r29,r25
 2618 09d4 00F4      		brsh .L103
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2620               	.LM247:
 2621 09d6 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2622 09da 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2623 09de 00C0      		rjmp .L106
 2624               	.L103:
 720:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2626               	.LM248:
 2627 09e0 8091 0000 		lds r24,pxDelayedTaskList
 2628 09e4 9091 0000 		lds r25,pxDelayedTaskList+1
 2629               	.L106:
 2630 09e8 6091 0000 		lds r22,pxCurrentTCB
 2631 09ec 7091 0000 		lds r23,pxCurrentTCB+1
 2632 09f0 6E5F      		subi r22,lo8(-(2))
 2633 09f2 7F4F      		sbci r23,hi8(-(2))
 2634 09f4 0E94 0000 		call vListInsert
 723:../../freeRtos/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 2636               	.LM249:
 2637 09f8 0E94 0000 		call xTaskResumeAll
 728:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 2639               	.LM250:
 2640 09fc 8823      		tst r24
 2641 09fe 01F4      		brne .L101
 2642               	.L102:
 730:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 2644               	.LM251:
 2645 0a00 0E94 0000 		call vPortYield
 2646               	.L101:
 2647               	/* epilogue start */
 732:../../freeRtos/Source/tasks.c **** 	}
 2649               	.LM252:
 2650 0a04 DF91      		pop r29
 2651 0a06 CF91      		pop r28
 2652 0a08 1F91      		pop r17
 2653 0a0a 0F91      		pop r16
 2654 0a0c 0895      		ret
 2659               	.Lscope20:
 2661               		.stabd	78,0,0
 2665               	.global	vTaskDelayUntil
 2667               	vTaskDelayUntil:
 2668               		.stabd	46,0,0
 602:../../freeRtos/Source/tasks.c **** 	{
 2670               	.LM253:
 2671               	.LFBB21:
 2672 0a0e 0F93      		push r16
 2673 0a10 1F93      		push r17
 2674 0a12 CF93      		push r28
 2675 0a14 DF93      		push r29
 2676               	/* prologue: function */
 2677               	/* frame size = 0 */
 2678               	/* stack size = 4 */
 2679               	.L__stack_usage = 4
 2680 0a16 8C01      		movw r16,r24
 2681 0a18 EB01      		movw r28,r22
 606:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 2683               	.LM254:
 2684 0a1a 0E94 0000 		call vTaskSuspendAll
 609:../../freeRtos/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 2686               	.LM255:
 2687 0a1e F801      		movw r30,r16
 2688 0a20 8081      		ld r24,Z
 2689 0a22 9181      		ldd r25,Z+1
 2690 0a24 C80F      		add r28,r24
 2691 0a26 D91F      		adc r29,r25
 611:../../freeRtos/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 2693               	.LM256:
 2694 0a28 2091 0000 		lds r18,xTickCount
 2695 0a2c 3091 0000 		lds r19,xTickCount+1
 2696 0a30 2817      		cp r18,r24
 2697 0a32 3907      		cpc r19,r25
 2698 0a34 00F4      		brsh .L108
 618:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 2700               	.LM257:
 2701 0a36 C817      		cp r28,r24
 2702 0a38 D907      		cpc r29,r25
 2703 0a3a 00F4      		brsh .L115
 2704 0a3c 00C0      		rjmp .L120
 2705               	.L108:
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 2707               	.LM258:
 2708 0a3e C817      		cp r28,r24
 2709 0a40 D907      		cpc r29,r25
 2710 0a42 00F0      		brlo .L116
 2711               	.L120:
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 2713               	.LM259:
 2714 0a44 8091 0000 		lds r24,xTickCount
 2715 0a48 9091 0000 		lds r25,xTickCount+1
 604:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 2717               	.LM260:
 2718 0a4c 21E0      		ldi r18,lo8(1)
 2719 0a4e 8C17      		cp r24,r28
 2720 0a50 9D07      		cpc r25,r29
 2721 0a52 00F0      		brlo .L109
 2722               	.L115:
 604:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 2724               	.LM261:
 2725 0a54 20E0      		ldi r18,lo8(0)
 2726 0a56 00C0      		rjmp .L109
 2727               	.L116:
 630:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 2729               	.LM262:
 2730 0a58 21E0      		ldi r18,lo8(1)
 2731               	.L109:
 635:../../freeRtos/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 2733               	.LM263:
 2734 0a5a F801      		movw r30,r16
 2735 0a5c C083      		st Z,r28
 2736 0a5e D183      		std Z+1,r29
 637:../../freeRtos/Source/tasks.c **** 			if( xShouldDelay )
 2738               	.LM264:
 2739 0a60 2223      		tst r18
 2740 0a62 01F0      		breq .L112
 644:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2742               	.LM265:
 2743 0a64 8091 0000 		lds r24,pxCurrentTCB
 2744 0a68 9091 0000 		lds r25,pxCurrentTCB+1
 2745 0a6c 0296      		adiw r24,2
 2746 0a6e 0E94 0000 		call vListRemove
 647:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2748               	.LM266:
 2749 0a72 E091 0000 		lds r30,pxCurrentTCB
 2750 0a76 F091 0000 		lds r31,pxCurrentTCB+1
 2751 0a7a C283      		std Z+2,r28
 2752 0a7c D383      		std Z+3,r29
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2754               	.LM267:
 2755 0a7e 8091 0000 		lds r24,xTickCount
 2756 0a82 9091 0000 		lds r25,xTickCount+1
 2757 0a86 C817      		cp r28,r24
 2758 0a88 D907      		cpc r29,r25
 2759 0a8a 00F4      		brsh .L113
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2761               	.LM268:
 2762 0a8c 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2763 0a90 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2764 0a94 00C0      		rjmp .L118
 2765               	.L113:
 659:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2767               	.LM269:
 2768 0a96 8091 0000 		lds r24,pxDelayedTaskList
 2769 0a9a 9091 0000 		lds r25,pxDelayedTaskList+1
 2770               	.L118:
 2771 0a9e 6091 0000 		lds r22,pxCurrentTCB
 2772 0aa2 7091 0000 		lds r23,pxCurrentTCB+1
 2773 0aa6 6E5F      		subi r22,lo8(-(2))
 2774 0aa8 7F4F      		sbci r23,hi8(-(2))
 2775 0aaa 0E94 0000 		call vListInsert
 2776               	.L112:
 663:../../freeRtos/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 2778               	.LM270:
 2779 0aae 0E94 0000 		call xTaskResumeAll
 667:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 2781               	.LM271:
 2782 0ab2 8823      		tst r24
 2783 0ab4 01F4      		brne .L107
 669:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 2785               	.LM272:
 2786 0ab6 0E94 0000 		call vPortYield
 2787               	.L107:
 2788               	/* epilogue start */
 671:../../freeRtos/Source/tasks.c **** 	}
 2790               	.LM273:
 2791 0aba DF91      		pop r29
 2792 0abc CF91      		pop r28
 2793 0abe 1F91      		pop r17
 2794 0ac0 0F91      		pop r16
 2795 0ac2 0895      		ret
 2801               	.Lscope21:
 2803               		.stabd	78,0,0
 2805               	.global	vTaskSwitchContext
 2807               	vTaskSwitchContext:
 2808               		.stabd	46,0,0
1554:../../freeRtos/Source/tasks.c **** {
 2810               	.LM274:
 2811               	.LFBB22:
 2812               	/* prologue: function */
 2813               	/* frame size = 0 */
 2814               	/* stack size = 0 */
 2815               	.L__stack_usage = 0
1555:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2817               	.LM275:
 2818 0ac4 8091 0000 		lds r24,uxSchedulerSuspended
 2819 0ac8 8823      		tst r24
 2820 0aca 01F0      		breq .L127
1559:../../freeRtos/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2822               	.LM276:
 2823 0acc 81E0      		ldi r24,lo8(1)
 2824 0ace 8093 0000 		sts xMissedYield,r24
1560:../../freeRtos/Source/tasks.c **** 		return;
 2826               	.LM277:
 2827 0ad2 0895      		ret
 2828               	.L124:
1585:../../freeRtos/Source/tasks.c **** 		--uxTopReadyPriority;
 2830               	.LM278:
 2831 0ad4 8091 0000 		lds r24,uxTopReadyPriority
 2832 0ad8 8150      		subi r24,lo8(-(-1))
 2833 0ada 8093 0000 		sts uxTopReadyPriority,r24
 2834               	.L127:
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2836               	.LM279:
 2837 0ade 8091 0000 		lds r24,uxTopReadyPriority
 2838 0ae2 90E0      		ldi r25,lo8(0)
 2839 0ae4 FC01      		movw r30,r24
 2840 0ae6 23E0      		ldi r18,3
 2841 0ae8 EE0F      	1:	lsl r30
 2842 0aea FF1F      		rol r31
 2843 0aec 2A95      		dec r18
 2844 0aee 01F4      		brne 1b
 2845 0af0 E80F      		add r30,r24
 2846 0af2 F91F      		adc r31,r25
 2847 0af4 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2848 0af6 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2849 0af8 8081      		ld r24,Z
 2850 0afa 8823      		tst r24
 2851 0afc 01F0      		breq .L124
 2852               	.LBB34:
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2854               	.LM280:
 2855 0afe 8091 0000 		lds r24,uxTopReadyPriority
 2856 0b02 90E0      		ldi r25,lo8(0)
 2857 0b04 9C01      		movw r18,r24
 2858 0b06 B3E0      		ldi r27,3
 2859 0b08 220F      	1:	lsl r18
 2860 0b0a 331F      		rol r19
 2861 0b0c BA95      		dec r27
 2862 0b0e 01F4      		brne 1b
 2863 0b10 280F      		add r18,r24
 2864 0b12 391F      		adc r19,r25
 2865 0b14 F901      		movw r30,r18
 2866 0b16 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2867 0b18 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2868 0b1a A181      		ldd r26,Z+1
 2869 0b1c B281      		ldd r27,Z+2
 2870 0b1e 1296      		adiw r26,2
 2871 0b20 0D90      		ld __tmp_reg__,X+
 2872 0b22 BC91      		ld r27,X
 2873 0b24 A02D      		mov r26,__tmp_reg__
 2874 0b26 A183      		std Z+1,r26
 2875 0b28 B283      		std Z+2,r27
 2876 0b2a 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 2877 0b2c 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 2878 0b2e A217      		cp r26,r18
 2879 0b30 B307      		cpc r27,r19
 2880 0b32 01F4      		brne .L125
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2882               	.LM281:
 2883 0b34 1296      		adiw r26,2
 2884 0b36 2D91      		ld r18,X+
 2885 0b38 3C91      		ld r19,X
 2886 0b3a 1397      		sbiw r26,2+1
 2887 0b3c 2183      		std Z+1,r18
 2888 0b3e 3283      		std Z+2,r19
 2889               	.L125:
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2891               	.LM282:
 2892 0b40 FC01      		movw r30,r24
 2893 0b42 A3E0      		ldi r26,3
 2894 0b44 EE0F      	1:	lsl r30
 2895 0b46 FF1F      		rol r31
 2896 0b48 AA95      		dec r26
 2897 0b4a 01F4      		brne 1b
 2898 0b4c E80F      		add r30,r24
 2899 0b4e F91F      		adc r31,r25
 2900 0b50 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2901 0b52 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2902 0b54 0180      		ldd __tmp_reg__,Z+1
 2903 0b56 F281      		ldd r31,Z+2
 2904 0b58 E02D      		mov r30,__tmp_reg__
 2905 0b5a 8681      		ldd r24,Z+6
 2906 0b5c 9781      		ldd r25,Z+7
 2907 0b5e 8093 0000 		sts pxCurrentTCB,r24
 2908 0b62 9093 0000 		sts pxCurrentTCB+1,r25
 2909               	.LBE34:
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2911               	.LM283:
 2912 0b66 8091 0000 		lds r24,xTracing
 2913 0b6a 8823      		tst r24
 2914 0b6c 01F4      		brne .+2
 2915 0b6e 00C0      		rjmp .L121
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2917               	.LM284:
 2918 0b70 E091 0000 		lds r30,pxCurrentTCB
 2919 0b74 F091 0000 		lds r31,pxCurrentTCB+1
 2920 0b78 9091 0000 		lds r25,uxPreviousTask
 2921 0b7c 83A1      		ldd r24,Z+35
 2922 0b7e 9817      		cp r25,r24
 2923 0b80 01F4      		brne .+2
 2924 0b82 00C0      		rjmp .L121
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2926               	.LM285:
 2927 0b84 8091 0000 		lds r24,pcTraceBuffer
 2928 0b88 9091 0000 		lds r25,pcTraceBuffer+1
 2929 0b8c 0896      		adiw r24,8
 2930 0b8e 2091 0000 		lds r18,pcTraceBufferEnd
 2931 0b92 3091 0000 		lds r19,pcTraceBufferEnd+1
 2932 0b96 8217      		cp r24,r18
 2933 0b98 9307      		cpc r25,r19
 2934 0b9a 00F4      		brsh .L126
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2936               	.LM286:
 2937 0b9c E091 0000 		lds r30,pxCurrentTCB
 2938 0ba0 F091 0000 		lds r31,pxCurrentTCB+1
 2939 0ba4 83A1      		ldd r24,Z+35
 2940 0ba6 8093 0000 		sts uxPreviousTask,r24
 2941 0baa E091 0000 		lds r30,pcTraceBuffer
 2942 0bae F091 0000 		lds r31,pcTraceBuffer+1
 2943 0bb2 2091 0000 		lds r18,xTickCount
 2944 0bb6 3091 0000 		lds r19,xTickCount+1
 2945 0bba 40E0      		ldi r20,lo8(0)
 2946 0bbc 50E0      		ldi r21,hi8(0)
 2947 0bbe 2083      		st Z,r18
 2948 0bc0 3183      		std Z+1,r19
 2949 0bc2 4283      		std Z+2,r20
 2950 0bc4 5383      		std Z+3,r21
 2951 0bc6 2091 0000 		lds r18,pcTraceBuffer
 2952 0bca 3091 0000 		lds r19,pcTraceBuffer+1
 2953 0bce 2C5F      		subi r18,lo8(-(4))
 2954 0bd0 3F4F      		sbci r19,hi8(-(4))
 2955 0bd2 2093 0000 		sts pcTraceBuffer,r18
 2956 0bd6 3093 0000 		sts pcTraceBuffer+1,r19
 2957 0bda E091 0000 		lds r30,pcTraceBuffer
 2958 0bde F091 0000 		lds r31,pcTraceBuffer+1
 2959 0be2 90E0      		ldi r25,lo8(0)
 2960 0be4 A0E0      		ldi r26,lo8(0)
 2961 0be6 B0E0      		ldi r27,hi8(0)
 2962 0be8 8083      		st Z,r24
 2963 0bea 9183      		std Z+1,r25
 2964 0bec A283      		std Z+2,r26
 2965 0bee B383      		std Z+3,r27
 2966 0bf0 8091 0000 		lds r24,pcTraceBuffer
 2967 0bf4 9091 0000 		lds r25,pcTraceBuffer+1
 2968 0bf8 0496      		adiw r24,4
 2969 0bfa 8093 0000 		sts pcTraceBuffer,r24
 2970 0bfe 9093 0000 		sts pcTraceBuffer+1,r25
 2971 0c02 0895      		ret
 2972               	.L126:
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2974               	.LM287:
 2975 0c04 1092 0000 		sts xTracing,__zero_reg__
 2976               	.L121:
 2977 0c08 0895      		ret
 2979               	.Lscope22:
 2981               		.stabd	78,0,0
 2985               	.global	vTaskPlaceOnEventList
 2987               	vTaskPlaceOnEventList:
 2988               		.stabd	46,0,0
1598:../../freeRtos/Source/tasks.c **** {
 2990               	.LM288:
 2991               	.LFBB23:
 2992 0c0a CF93      		push r28
 2993 0c0c DF93      		push r29
 2994               	/* prologue: function */
 2995               	/* frame size = 0 */
 2996               	/* stack size = 2 */
 2997               	.L__stack_usage = 2
 2998 0c0e EB01      		movw r28,r22
1607:../../freeRtos/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 3000               	.LM289:
 3001 0c10 6091 0000 		lds r22,pxCurrentTCB
 3002 0c14 7091 0000 		lds r23,pxCurrentTCB+1
 3003 0c18 645F      		subi r22,lo8(-(12))
 3004 0c1a 7F4F      		sbci r23,hi8(-(12))
 3005 0c1c 0E94 0000 		call vListInsert
1612:../../freeRtos/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 3007               	.LM290:
 3008 0c20 8091 0000 		lds r24,pxCurrentTCB
 3009 0c24 9091 0000 		lds r25,pxCurrentTCB+1
 3010 0c28 0296      		adiw r24,2
 3011 0c2a 0E94 0000 		call vListRemove
1617:../../freeRtos/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 3013               	.LM291:
 3014 0c2e 8FEF      		ldi r24,hi8(-1)
 3015 0c30 CF3F      		cpi r28,lo8(-1)
 3016 0c32 D807      		cpc r29,r24
 3017 0c34 01F4      		brne .L129
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 3019               	.LM292:
 3020 0c36 6091 0000 		lds r22,pxCurrentTCB
 3021 0c3a 7091 0000 		lds r23,pxCurrentTCB+1
 3022 0c3e 6E5F      		subi r22,lo8(-(2))
 3023 0c40 7F4F      		sbci r23,hi8(-(2))
 3024 0c42 80E0      		ldi r24,lo8(xSuspendedTaskList)
 3025 0c44 90E0      		ldi r25,hi8(xSuspendedTaskList)
 3026 0c46 0E94 0000 		call vListInsertEnd
 3027 0c4a 00C0      		rjmp .L128
 3028               	.L129:
1628:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 3030               	.LM293:
 3031 0c4c 8091 0000 		lds r24,xTickCount
 3032 0c50 9091 0000 		lds r25,xTickCount+1
 3033 0c54 8C0F      		add r24,r28
 3034 0c56 9D1F      		adc r25,r29
1630:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3036               	.LM294:
 3037 0c58 E091 0000 		lds r30,pxCurrentTCB
 3038 0c5c F091 0000 		lds r31,pxCurrentTCB+1
 3039 0c60 8283      		std Z+2,r24
 3040 0c62 9383      		std Z+3,r25
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 3042               	.LM295:
 3043 0c64 2091 0000 		lds r18,xTickCount
 3044 0c68 3091 0000 		lds r19,xTickCount+1
 3045 0c6c 8217      		cp r24,r18
 3046 0c6e 9307      		cpc r25,r19
 3047 0c70 00F4      		brsh .L131
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 3049               	.LM296:
 3050 0c72 8091 0000 		lds r24,pxOverflowDelayedTaskList
 3051 0c76 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 3052 0c7a 00C0      		rjmp .L132
 3053               	.L131:
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 3055               	.LM297:
 3056 0c7c 8091 0000 		lds r24,pxDelayedTaskList
 3057 0c80 9091 0000 		lds r25,pxDelayedTaskList+1
 3058               	.L132:
 3059 0c84 6091 0000 		lds r22,pxCurrentTCB
 3060 0c88 7091 0000 		lds r23,pxCurrentTCB+1
 3061 0c8c 6E5F      		subi r22,lo8(-(2))
 3062 0c8e 7F4F      		sbci r23,hi8(-(2))
 3063 0c90 0E94 0000 		call vListInsert
 3064               	.L128:
 3065               	/* epilogue start */
1664:../../freeRtos/Source/tasks.c **** }
 3067               	.LM298:
 3068 0c94 DF91      		pop r29
 3069 0c96 CF91      		pop r28
 3070 0c98 0895      		ret
 3075               	.Lscope23:
 3077               		.stabd	78,0,0
 3080               	.global	xTaskRemoveFromEventList
 3082               	xTaskRemoveFromEventList:
 3083               		.stabd	46,0,0
1668:../../freeRtos/Source/tasks.c **** {
 3085               	.LM299:
 3086               	.LFBB24:
 3087 0c9a 0F93      		push r16
 3088 0c9c 1F93      		push r17
 3089 0c9e CF93      		push r28
 3090 0ca0 DF93      		push r29
 3091               	/* prologue: function */
 3092               	/* frame size = 0 */
 3093               	/* stack size = 4 */
 3094               	.L__stack_usage = 4
 3095 0ca2 FC01      		movw r30,r24
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3097               	.LM300:
 3098 0ca4 8081      		ld r24,Z
 3099 0ca6 8823      		tst r24
 3100 0ca8 01F0      		breq .L139
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3102               	.LM301:
 3103 0caa 0580      		ldd __tmp_reg__,Z+5
 3104 0cac F681      		ldd r31,Z+6
 3105 0cae E02D      		mov r30,__tmp_reg__
 3106 0cb0 C681      		ldd r28,Z+6
 3107 0cb2 D781      		ldd r29,Z+7
 3108 0cb4 00C0      		rjmp .L134
 3109               	.L139:
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3111               	.LM302:
 3112 0cb6 C0E0      		ldi r28,lo8(0)
 3113 0cb8 D0E0      		ldi r29,hi8(0)
 3114               	.L134:
1683:../../freeRtos/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3116               	.LM303:
 3117 0cba 8E01      		movw r16,r28
 3118 0cbc 045F      		subi r16,lo8(-(12))
 3119 0cbe 1F4F      		sbci r17,hi8(-(12))
 3120 0cc0 C801      		movw r24,r16
 3121 0cc2 0E94 0000 		call vListRemove
1685:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3123               	.LM304:
 3124 0cc6 8091 0000 		lds r24,uxSchedulerSuspended
 3125 0cca 8823      		tst r24
 3126 0ccc 01F4      		brne .L135
1687:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 3128               	.LM305:
 3129 0cce 8E01      		movw r16,r28
 3130 0cd0 0E5F      		subi r16,lo8(-(2))
 3131 0cd2 1F4F      		sbci r17,hi8(-(2))
 3132 0cd4 C801      		movw r24,r16
 3133 0cd6 0E94 0000 		call vListRemove
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 3135               	.LM306:
 3136 0cda 2E89      		ldd r18,Y+22
 3137 0cdc 8091 0000 		lds r24,uxTopReadyPriority
 3138 0ce0 8217      		cp r24,r18
 3139 0ce2 00F4      		brsh .L136
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 3141               	.LM307:
 3142 0ce4 2093 0000 		sts uxTopReadyPriority,r18
 3143               	.L136:
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 3145               	.LM308:
 3146 0ce8 30E0      		ldi r19,lo8(0)
 3147 0cea C901      		movw r24,r18
 3148 0cec 43E0      		ldi r20,3
 3149 0cee 880F      	1:	lsl r24
 3150 0cf0 991F      		rol r25
 3151 0cf2 4A95      		dec r20
 3152 0cf4 01F4      		brne 1b
 3153 0cf6 820F      		add r24,r18
 3154 0cf8 931F      		adc r25,r19
 3155 0cfa 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3156 0cfc 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3157 0cfe 00C0      		rjmp .L140
 3158               	.L135:
1694:../../freeRtos/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 3160               	.LM309:
 3161 0d00 80E0      		ldi r24,lo8(xPendingReadyList)
 3162 0d02 90E0      		ldi r25,hi8(xPendingReadyList)
 3163               	.L140:
 3164 0d04 B801      		movw r22,r16
 3165 0d06 0E94 0000 		call vListInsertEnd
1697:../../freeRtos/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 3167               	.LM310:
 3168 0d0a E091 0000 		lds r30,pxCurrentTCB
 3169 0d0e F091 0000 		lds r31,pxCurrentTCB+1
1703:../../freeRtos/Source/tasks.c **** 		xReturn = pdTRUE;
 3171               	.LM311:
 3172 0d12 81E0      		ldi r24,lo8(1)
 3173 0d14 2E89      		ldd r18,Y+22
 3174 0d16 9689      		ldd r25,Z+22
 3175 0d18 2917      		cp r18,r25
 3176 0d1a 00F4      		brsh .L138
 3177 0d1c 80E0      		ldi r24,lo8(0)
 3178               	.L138:
 3179               	/* epilogue start */
1711:../../freeRtos/Source/tasks.c **** }
 3181               	.LM312:
 3182 0d1e DF91      		pop r29
 3183 0d20 CF91      		pop r28
 3184 0d22 1F91      		pop r17
 3185 0d24 0F91      		pop r16
 3186 0d26 0895      		ret
 3191               	.Lscope24:
 3193               		.stabd	78,0,0
 3196               	.global	vTaskSetTimeOutState
 3198               	vTaskSetTimeOutState:
 3199               		.stabd	46,0,0
1715:../../freeRtos/Source/tasks.c **** {
 3201               	.LM313:
 3202               	.LFBB25:
 3203               	/* prologue: function */
 3204               	/* frame size = 0 */
 3205               	/* stack size = 0 */
 3206               	.L__stack_usage = 0
 3207 0d28 FC01      		movw r30,r24
1716:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3209               	.LM314:
 3210 0d2a 8091 0000 		lds r24,xNumOfOverflows
 3211 0d2e 8083      		st Z,r24
1717:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3213               	.LM315:
 3214 0d30 8091 0000 		lds r24,xTickCount
 3215 0d34 9091 0000 		lds r25,xTickCount+1
 3216 0d38 8183      		std Z+1,r24
 3217 0d3a 9283      		std Z+2,r25
 3218               	/* epilogue start */
1718:../../freeRtos/Source/tasks.c **** }
 3220               	.LM316:
 3221 0d3c 0895      		ret
 3223               	.Lscope25:
 3225               		.stabd	78,0,0
 3229               	.global	xTaskCheckForTimeOut
 3231               	xTaskCheckForTimeOut:
 3232               		.stabd	46,0,0
1722:../../freeRtos/Source/tasks.c **** {
 3234               	.LM317:
 3235               	.LFBB26:
 3236               	/* prologue: function */
 3237               	/* frame size = 0 */
 3238               	/* stack size = 0 */
 3239               	.L__stack_usage = 0
 3240 0d3e FC01      		movw r30,r24
 3241 0d40 DB01      		movw r26,r22
1725:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 3243               	.LM318:
 3244               	/* #APP */
 3245               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 3246 0d42 0FB6      		in		__tmp_reg__, __SREG__
 3247               	 ;  0 "" 2
 3248               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 3249 0d44 F894      		cli
 3250               	 ;  0 "" 2
 3251               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 3252 0d46 0F92      		push	__tmp_reg__
 3253               	 ;  0 "" 2
1731:../../freeRtos/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3255               	.LM319:
 3256               	/* #NOAPP */
 3257 0d48 2D91      		ld r18,X+
 3258 0d4a 3C91      		ld r19,X
 3259 0d4c 1197      		sbiw r26,1
 3260 0d4e 8FEF      		ldi r24,hi8(-1)
 3261 0d50 2F3F      		cpi r18,lo8(-1)
 3262 0d52 3807      		cpc r19,r24
 3263 0d54 01F0      		breq .L145
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 3265               	.LM320:
 3266 0d56 9091 0000 		lds r25,xNumOfOverflows
 3267 0d5a 8081      		ld r24,Z
 3268 0d5c 9817      		cp r25,r24
 3269 0d5e 01F0      		breq .L144
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 3271               	.LM321:
 3272 0d60 4091 0000 		lds r20,xTickCount
 3273 0d64 5091 0000 		lds r21,xTickCount+1
 3274 0d68 8181      		ldd r24,Z+1
 3275 0d6a 9281      		ldd r25,Z+2
 3276 0d6c 4817      		cp r20,r24
 3277 0d6e 5907      		cpc r21,r25
 3278 0d70 00F4      		brsh .L147
 3279               	.L144:
1746:../../freeRtos/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 3281               	.LM322:
 3282 0d72 4091 0000 		lds r20,xTickCount
 3283 0d76 5091 0000 		lds r21,xTickCount+1
 3284 0d7a 8181      		ldd r24,Z+1
 3285 0d7c 9281      		ldd r25,Z+2
 3286 0d7e 481B      		sub r20,r24
 3287 0d80 590B      		sbc r21,r25
 3288 0d82 4217      		cp r20,r18
 3289 0d84 5307      		cpc r21,r19
 3290 0d86 00F4      		brsh .L147
1749:../../freeRtos/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 3292               	.LM323:
 3293 0d88 4091 0000 		lds r20,xTickCount
 3294 0d8c 5091 0000 		lds r21,xTickCount+1
 3295 0d90 841B      		sub r24,r20
 3296 0d92 950B      		sbc r25,r21
 3297 0d94 820F      		add r24,r18
 3298 0d96 931F      		adc r25,r19
 3299 0d98 8D93      		st X+,r24
 3300 0d9a 9C93      		st X,r25
 3301 0d9c 1197      		sbiw r26,1
 3302               	.LBB35:
 3303               	.LBB36:
1716:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3305               	.LM324:
 3306 0d9e 8091 0000 		lds r24,xNumOfOverflows
 3307 0da2 8083      		st Z,r24
1717:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3309               	.LM325:
 3310 0da4 8091 0000 		lds r24,xTickCount
 3311 0da8 9091 0000 		lds r25,xTickCount+1
 3312 0dac 8183      		std Z+1,r24
 3313 0dae 9283      		std Z+2,r25
 3314               	.L145:
 3315               	.LBE36:
 3316               	.LBE35:
1733:../../freeRtos/Source/tasks.c **** 				xReturn = pdFALSE;
 3318               	.LM326:
 3319 0db0 80E0      		ldi r24,lo8(0)
 3320 0db2 00C0      		rjmp .L143
 3321               	.L147:
1755:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
 3323               	.LM327:
 3324 0db4 81E0      		ldi r24,lo8(1)
 3325               	.L143:
1758:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 3327               	.LM328:
 3328               	/* #APP */
 3329               	 ;  1758 "../../freeRtos/Source/tasks.c" 1
 3330 0db6 0F90      		pop		__tmp_reg__
 3331               	 ;  0 "" 2
 3332               	 ;  1758 "../../freeRtos/Source/tasks.c" 1
 3333 0db8 0FBE      		out		__SREG__, __tmp_reg__
 3334               	 ;  0 "" 2
 3335               	/* epilogue start */
1761:../../freeRtos/Source/tasks.c **** }
 3337               	.LM329:
 3338               	/* #NOAPP */
 3339 0dba 0895      		ret
 3344               	.Lscope26:
 3346               		.stabd	78,0,0
 3348               	.global	vTaskMissedYield
 3350               	vTaskMissedYield:
 3351               		.stabd	46,0,0
1765:../../freeRtos/Source/tasks.c **** {
 3353               	.LM330:
 3354               	.LFBB27:
 3355               	/* prologue: function */
 3356               	/* frame size = 0 */
 3357               	/* stack size = 0 */
 3358               	.L__stack_usage = 0
1766:../../freeRtos/Source/tasks.c **** 	xMissedYield = pdTRUE;
 3360               	.LM331:
 3361 0dbc 81E0      		ldi r24,lo8(1)
 3362 0dbe 8093 0000 		sts xMissedYield,r24
 3363               	/* epilogue start */
1767:../../freeRtos/Source/tasks.c **** }
 3365               	.LM332:
 3366 0dc2 0895      		ret
 3368               	.Lscope27:
 3370               		.stabd	78,0,0
 3371               	.global	pxCurrentTCB
 3372               	.global	pxCurrentTCB
 3373               		.section .bss
 3376               	pxCurrentTCB:
 3377 0000 0000      		.skip 2,0
 3378               		.lcomm xMissedYield,1
 3379               		.lcomm xNumOfOverflows,1
 3380               		.lcomm xTickCount,2
 3381               		.lcomm uxSchedulerSuspended,1
 3382               		.lcomm uxTopReadyPriority,1
 3383               		.lcomm pxReadyTasksLists,27
 3384               		.lcomm xPendingReadyList,9
 3385               		.lcomm xSuspendedTaskList,9
 3386               		.lcomm pxOverflowDelayedTaskList,2
 3387               		.lcomm pxDelayedTaskList,2
 3388               		.lcomm xTracing,1
 3389               		.data
 3392               	uxPreviousTask:
 3393 001a FF        		.byte	-1
 3394               		.lcomm pcTraceBuffer,2
 3395               		.lcomm pcTraceBufferEnd,2
 3396               		.lcomm uxMissedTicks,1
 3397               		.lcomm pcTraceBufferStart,2
 3398               		.lcomm uxTopUsedPriority,1
 3399               		.lcomm pcStatusString,50
 3400               		.lcomm uxCurrentNumberOfTasks,1
 3401               		.lcomm xSchedulerRunning,1
 3402               		.lcomm uxTaskNumber,1
 3403               		.lcomm xDelayedTaskList1,9
 3404               		.lcomm xDelayedTaskList2,9
 3429               		.text
 3431               	.Letext0:
 3432               	.global __do_copy_data
 3433               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccrVUL81.s:2      *ABS*:0000003f __SREG__
     /tmp/ccrVUL81.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccrVUL81.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccrVUL81.s:5      *ABS*:00000034 __CCP__
     /tmp/ccrVUL81.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccrVUL81.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccrVUL81.s:454    .text:00000000 prvListTaskWithinSingleList
     /tmp/ccrVUL81.s:3398   .bss:00000042 pcStatusString
     /tmp/ccrVUL81.s:673    .text:00000130 prvIdleTask
     /tmp/ccrVUL81.s:702    .text:00000136 xTaskGenericCreate
     /tmp/ccrVUL81.s:3399   .bss:00000074 uxCurrentNumberOfTasks
     /tmp/ccrVUL81.s:3376   .bss:00000000 pxCurrentTCB
     /tmp/ccrVUL81.s:3382   .bss:00000008 pxReadyTasksLists
     /tmp/ccrVUL81.s:3402   .bss:00000077 xDelayedTaskList1
     /tmp/ccrVUL81.s:3403   .bss:00000080 xDelayedTaskList2
     /tmp/ccrVUL81.s:3383   .bss:00000023 xPendingReadyList
     /tmp/ccrVUL81.s:3384   .bss:0000002c xSuspendedTaskList
     /tmp/ccrVUL81.s:3386   .bss:00000037 pxDelayedTaskList
     /tmp/ccrVUL81.s:3385   .bss:00000035 pxOverflowDelayedTaskList
     /tmp/ccrVUL81.s:3400   .bss:00000075 xSchedulerRunning
     /tmp/ccrVUL81.s:3397   .bss:00000041 uxTopUsedPriority
     /tmp/ccrVUL81.s:3401   .bss:00000076 uxTaskNumber
     /tmp/ccrVUL81.s:3381   .bss:00000007 uxTopReadyPriority
     /tmp/ccrVUL81.s:1079   .text:0000033a uxTaskPriorityGet
     /tmp/ccrVUL81.s:1142   .text:00000358 vTaskPrioritySet
     /tmp/ccrVUL81.s:1334   .text:00000438 vTaskSuspend
     /tmp/ccrVUL81.s:1453   .text:000004b4 xTaskIsTaskSuspended
     /tmp/ccrVUL81.s:1506   .text:000004de vTaskResume
     /tmp/ccrVUL81.s:1630   .text:00000572 xTaskResumeFromISR
     /tmp/ccrVUL81.s:3380   .bss:00000006 uxSchedulerSuspended
     /tmp/ccrVUL81.s:1748   .text:0000060a vTaskStartScheduler
     /tmp/ccrVUL81.s:3379   .bss:00000004 xTickCount
     /tmp/ccrVUL81.s:1822   .text:00000660 vTaskEndScheduler
     /tmp/ccrVUL81.s:1855   .text:0000066c vTaskSuspendAll
     /tmp/ccrVUL81.s:1880   .text:00000678 xTaskGetTickCount
     /tmp/ccrVUL81.s:1931   .text:0000068e uxTaskGetNumberOfTasks
     /tmp/ccrVUL81.s:1956   .text:00000694 vTaskStartTrace
     /tmp/ccrVUL81.s:3388   .bss:0000003a pcTraceBuffer
     /tmp/ccrVUL81.s:3396   .bss:0000003f pcTraceBufferStart
     /tmp/ccrVUL81.s:3394   .bss:0000003c pcTraceBufferEnd
     /tmp/ccrVUL81.s:3387   .bss:00000039 xTracing
     /tmp/ccrVUL81.s:2019   .text:000006c6 ulTaskEndTrace
     /tmp/ccrVUL81.s:2079   .text:000006f6 vTaskIncrementTick
     /tmp/ccrVUL81.s:3378   .bss:00000003 xNumOfOverflows
     /tmp/ccrVUL81.s:3395   .bss:0000003e uxMissedTicks
     /tmp/ccrVUL81.s:2236   .text:000007e6 xTaskResumeAll
                             .bss:00000002 xMissedYield
     /tmp/ccrVUL81.s:2448   .text:000008e8 vTaskList
     /tmp/ccrVUL81.s:2573   .text:00000990 vTaskDelay
     /tmp/ccrVUL81.s:2667   .text:00000a0e vTaskDelayUntil
     /tmp/ccrVUL81.s:2807   .text:00000ac4 vTaskSwitchContext
     /tmp/ccrVUL81.s:3392   .data:0000001a uxPreviousTask
     /tmp/ccrVUL81.s:2987   .text:00000c0a vTaskPlaceOnEventList
     /tmp/ccrVUL81.s:3082   .text:00000c9a xTaskRemoveFromEventList
     /tmp/ccrVUL81.s:3198   .text:00000d28 vTaskSetTimeOutState
     /tmp/ccrVUL81.s:3231   .text:00000d3e xTaskCheckForTimeOut
     /tmp/ccrVUL81.s:3350   .text:00000dbc vTaskMissedYield

UNDEFINED SYMBOLS
sprintf
strcat
vPortYield
pvPortMalloc
vPortFree
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
vListRemove
xPortStartScheduler
vPortEndScheduler
vListInsert
__do_copy_data
__do_clear_bss
