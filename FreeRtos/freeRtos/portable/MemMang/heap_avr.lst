   1               		.file	"heap_avr.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__RAMPY__ = 0x3a
   7               	__RAMPX__ = 0x39
   8               	__RAMPD__ = 0x38
   9               	__CCP__ = 0x34
  10               	__tmp_reg__ = 0
  11               	__zero_reg__ = 1
  14               		.text
  15               	.Ltext0:
 443               	.global	pvPortMalloc
 445               	pvPortMalloc:
 446               		.stabd	46,0,0
   1:../../freeRtos/portable/MemMang/heap_avr.c **** /*
   2:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/portable/MemMang/heap_avr.c **** 
   4:../../freeRtos/portable/MemMang/heap_avr.c ****     ***************************************************************************
   5:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
   6:../../freeRtos/portable/MemMang/heap_avr.c ****     * If you are:                                                             *
   7:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
   8:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  13:../../freeRtos/portable/MemMang/heap_avr.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  15:../../freeRtos/portable/MemMang/heap_avr.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/portable/MemMang/heap_avr.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  18:../../freeRtos/portable/MemMang/heap_avr.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/portable/MemMang/heap_avr.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/portable/MemMang/heap_avr.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/portable/MemMang/heap_avr.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  23:../../freeRtos/portable/MemMang/heap_avr.c ****     ***************************************************************************
  24:../../freeRtos/portable/MemMang/heap_avr.c **** 
  25:../../freeRtos/portable/MemMang/heap_avr.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/portable/MemMang/heap_avr.c **** 
  27:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/portable/MemMang/heap_avr.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/portable/MemMang/heap_avr.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/portable/MemMang/heap_avr.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/portable/MemMang/heap_avr.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/portable/MemMang/heap_avr.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/portable/MemMang/heap_avr.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/portable/MemMang/heap_avr.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/portable/MemMang/heap_avr.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/portable/MemMang/heap_avr.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/portable/MemMang/heap_avr.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/portable/MemMang/heap_avr.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS WEB site.
  41:../../freeRtos/portable/MemMang/heap_avr.c **** 
  42:../../freeRtos/portable/MemMang/heap_avr.c ****     1 tab == 4 spaces!
  43:../../freeRtos/portable/MemMang/heap_avr.c **** 
  44:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/portable/MemMang/heap_avr.c ****     contact details.
  46:../../freeRtos/portable/MemMang/heap_avr.c **** 
  47:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/portable/MemMang/heap_avr.c ****     critical systems.
  49:../../freeRtos/portable/MemMang/heap_avr.c **** 
  50:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/portable/MemMang/heap_avr.c ****     licensing and training services.
  52:../../freeRtos/portable/MemMang/heap_avr.c **** */
  53:../../freeRtos/portable/MemMang/heap_avr.c **** 
  54:../../freeRtos/portable/MemMang/heap_avr.c **** 
  55:../../freeRtos/portable/MemMang/heap_avr.c **** /*
  56:../../freeRtos/portable/MemMang/heap_avr.c ****  * AVR implementation of pvPortMalloc().
  57:../../freeRtos/portable/MemMang/heap_avr.c ****  * Modified by Adam Kaliszan
  58:../../freeRtos/portable/MemMang/heap_avr.c ****  */
  59:../../freeRtos/portable/MemMang/heap_avr.c **** #include <stdlib.h>
  60:../../freeRtos/portable/MemMang/heap_avr.c **** 
  61:../../freeRtos/portable/MemMang/heap_avr.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  62:../../freeRtos/portable/MemMang/heap_avr.c **** all the API functions to use the MPU wrappers.  That should only be done when
  63:../../freeRtos/portable/MemMang/heap_avr.c **** task.h is included from an application file. */
  64:../../freeRtos/portable/MemMang/heap_avr.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  65:../../freeRtos/portable/MemMang/heap_avr.c **** 
  66:../../freeRtos/portable/MemMang/heap_avr.c **** #include "FreeRTOS.h"
  67:../../freeRtos/portable/MemMang/heap_avr.c **** #include "task.h"
  68:../../freeRtos/portable/MemMang/heap_avr.c **** 
  69:../../freeRtos/portable/MemMang/heap_avr.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../../freeRtos/portable/MemMang/heap_avr.c **** 
  71:../../freeRtos/portable/MemMang/heap_avr.c **** /* Allocate the memory for the heap.  The struct is used to force byte
  72:../../freeRtos/portable/MemMang/heap_avr.c **** alignment without using any non-portable code. */
  73:../../freeRtos/portable/MemMang/heap_avr.c **** static union xRTOS_HEAP
  74:../../freeRtos/portable/MemMang/heap_avr.c **** {
  75:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if portBYTE_ALIGNMENT == 8
  76:../../freeRtos/portable/MemMang/heap_avr.c **** 		volatile portDOUBLE dDummy;
  77:../../freeRtos/portable/MemMang/heap_avr.c **** 	#else
  78:../../freeRtos/portable/MemMang/heap_avr.c **** 		volatile unsigned long ulDummy;
  79:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif	
  80:../../freeRtos/portable/MemMang/heap_avr.c **** 	unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
  81:../../freeRtos/portable/MemMang/heap_avr.c **** } xHeap;
  82:../../freeRtos/portable/MemMang/heap_avr.c **** 
  83:../../freeRtos/portable/MemMang/heap_avr.c **** static size_t xNextFreeByte = ( size_t ) 0;
  84:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
  85:../../freeRtos/portable/MemMang/heap_avr.c **** 
  86:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvPortMalloc( size_t xWantedSize )
  87:../../freeRtos/portable/MemMang/heap_avr.c **** {
 448               	.LM0:
 449               	.LFBB1:
 450 0000 0F93      		push r16
 451 0002 1F93      		push r17
 452 0004 CF93      		push r28
 453 0006 DF93      		push r29
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 4 */
 457               	.L__stack_usage = 4
 458 0008 8C01      		movw r16,r24
  88:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvReturn = NULL; 
  89:../../freeRtos/portable/MemMang/heap_avr.c **** 
  90:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Ensure that blocks are always aligned to the required number of bytes. */
  91:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if portBYTE_ALIGNMENT != 1
  92:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  93:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
  94:../../freeRtos/portable/MemMang/heap_avr.c **** 			/* Byte alignment required. */
  95:../../freeRtos/portable/MemMang/heap_avr.c **** 			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  96:../../freeRtos/portable/MemMang/heap_avr.c **** 		}
  97:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif
  98:../../freeRtos/portable/MemMang/heap_avr.c **** 
  99:../../freeRtos/portable/MemMang/heap_avr.c **** 	vTaskSuspendAll();
 460               	.LM1:
 461 000a 0E94 0000 		call vTaskSuspendAll
 100:../../freeRtos/portable/MemMang/heap_avr.c **** 	{
 101:../../freeRtos/portable/MemMang/heap_avr.c **** 		/* Check there is enough room left for the allocation. */
 102:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 463               	.LM2:
 464 000e C091 0000 		lds r28,xNextFreeByte
 465 0012 D091 0000 		lds r29,xNextFreeByte+1
 466 0016 C801      		movw r24,r16
 467 0018 8C0F      		add r24,r28
 468 001a 9D1F      		adc r25,r29
 469 001c 883B      		cpi r24,-72
 470 001e 2BE0      		ldi r18,11
 471 0020 9207      		cpc r25,r18
 472 0022 00F4      		brsh .L4
 474               	.LM3:
 475 0024 C817      		cp r28,r24
 476 0026 D907      		cpc r29,r25
 477 0028 00F4      		brsh .L4
 103:../../freeRtos/portable/MemMang/heap_avr.c **** 			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 104:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
 105:../../freeRtos/portable/MemMang/heap_avr.c **** 			/* Return the next free byte then increment the index past this
 106:../../freeRtos/portable/MemMang/heap_avr.c **** 			block. */
 107:../../freeRtos/portable/MemMang/heap_avr.c **** 			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 479               	.LM4:
 480 002a C050      		subi r28,lo8(-(xHeap))
 481 002c D040      		sbci r29,hi8(-(xHeap))
 108:../../freeRtos/portable/MemMang/heap_avr.c **** 			xNextFreeByte += xWantedSize;			
 483               	.LM5:
 484 002e 8093 0000 		sts xNextFreeByte,r24
 485 0032 9093 0000 		sts xNextFreeByte+1,r25
 486 0036 00C0      		rjmp .L2
 487               	.L4:
  88:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvReturn = NULL; 
 489               	.LM6:
 490 0038 C0E0      		ldi r28,0
 491 003a D0E0      		ldi r29,0
 492               	.L2:
 109:../../freeRtos/portable/MemMang/heap_avr.c **** 		}	
 110:../../freeRtos/portable/MemMang/heap_avr.c **** 	}
 111:../../freeRtos/portable/MemMang/heap_avr.c **** 	xTaskResumeAll();
 494               	.LM7:
 495 003c 0E94 0000 		call xTaskResumeAll
 112:../../freeRtos/portable/MemMang/heap_avr.c **** 	
 113:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
 114:../../freeRtos/portable/MemMang/heap_avr.c **** 	{
 115:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( pvReturn == NULL )
 116:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
 117:../../freeRtos/portable/MemMang/heap_avr.c **** 			extern void vApplicationMallocFailedHook( void );
 118:../../freeRtos/portable/MemMang/heap_avr.c **** 			vApplicationMallocFailedHook();
 119:../../freeRtos/portable/MemMang/heap_avr.c **** 		}
 120:../../freeRtos/portable/MemMang/heap_avr.c **** 	}
 121:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif	
 122:../../freeRtos/portable/MemMang/heap_avr.c **** 
 123:../../freeRtos/portable/MemMang/heap_avr.c **** 	return pvReturn;
 124:../../freeRtos/portable/MemMang/heap_avr.c **** }
 497               	.LM8:
 498 0040 CE01      		movw r24,r28
 499               	/* epilogue start */
 500 0042 DF91      		pop r29
 501 0044 CF91      		pop r28
 502 0046 1F91      		pop r17
 503 0048 0F91      		pop r16
 504 004a 0895      		ret
 509               	.Lscope1:
 511               		.stabd	78,0,0
 514               	.global	vPortFree
 516               	vPortFree:
 517               		.stabd	46,0,0
 125:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 126:../../freeRtos/portable/MemMang/heap_avr.c **** 
 127:../../freeRtos/portable/MemMang/heap_avr.c **** void vPortFree( void *pv )
 128:../../freeRtos/portable/MemMang/heap_avr.c **** {
 519               	.LM9:
 520               	.LFBB2:
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 0 */
 524               	.L__stack_usage = 0
 525 004c 0895      		ret
 527               	.Lscope2:
 529               		.stabd	78,0,0
 531               	.global	vPortInitialiseBlocks
 533               	vPortInitialiseBlocks:
 534               		.stabd	46,0,0
 129:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
 130:../../freeRtos/portable/MemMang/heap_avr.c **** 	for alternative implementations, and the memory management pages of 
 131:../../freeRtos/portable/MemMang/heap_avr.c **** 	http://www.FreeRTOS.org for more information. */
 132:../../freeRtos/portable/MemMang/heap_avr.c **** 	( void ) pv;
 133:../../freeRtos/portable/MemMang/heap_avr.c **** }
 134:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 135:../../freeRtos/portable/MemMang/heap_avr.c **** 
 136:../../freeRtos/portable/MemMang/heap_avr.c **** void vPortInitialiseBlocks( void )
 137:../../freeRtos/portable/MemMang/heap_avr.c **** {
 536               	.LM10:
 537               	.LFBB3:
 538               	/* prologue: function */
 539               	/* frame size = 0 */
 540               	/* stack size = 0 */
 541               	.L__stack_usage = 0
 138:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Only required when static memory is not cleared. */
 139:../../freeRtos/portable/MemMang/heap_avr.c **** 	xNextFreeByte = ( size_t ) 0;
 543               	.LM11:
 544 004e 1092 0000 		sts xNextFreeByte,__zero_reg__
 545 0052 1092 0000 		sts xNextFreeByte+1,__zero_reg__
 546 0056 0895      		ret
 548               	.Lscope3:
 550               		.stabd	78,0,0
 552               	.global	xPortGetFreeHeapSize
 554               	xPortGetFreeHeapSize:
 555               		.stabd	46,0,0
 140:../../freeRtos/portable/MemMang/heap_avr.c **** }
 141:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 142:../../freeRtos/portable/MemMang/heap_avr.c **** 
 143:../../freeRtos/portable/MemMang/heap_avr.c **** size_t xPortGetFreeHeapSize( void )
 144:../../freeRtos/portable/MemMang/heap_avr.c **** {
 557               	.LM12:
 558               	.LFBB4:
 559               	/* prologue: function */
 560               	/* frame size = 0 */
 561               	/* stack size = 0 */
 562               	.L__stack_usage = 0
 145:../../freeRtos/portable/MemMang/heap_avr.c **** 	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
 564               	.LM13:
 565 0058 28EB      		ldi r18,lo8(-72)
 566 005a 3BE0      		ldi r19,lo8(11)
 567 005c 8091 0000 		lds r24,xNextFreeByte
 568 0060 9091 0000 		lds r25,xNextFreeByte+1
 569 0064 281B      		sub r18,r24
 570 0066 390B      		sbc r19,r25
 146:../../freeRtos/portable/MemMang/heap_avr.c **** }
 572               	.LM14:
 573 0068 C901      		movw r24,r18
 574 006a 0895      		ret
 576               	.Lscope4:
 578               		.stabd	78,0,0
 579               		.local	xNextFreeByte
 580               		.comm	xNextFreeByte,2,1
 581               		.local	xHeap
 582               		.comm	xHeap,3000,1
 586               	.Letext0:
 587               		.ident	"GCC: (GNU) 4.7.0"
 588               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 heap_avr.c
     /tmp/ccNEOKdC.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccNEOKdC.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccNEOKdC.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccNEOKdC.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccNEOKdC.s:6      *ABS*:000000000000003a __RAMPY__
     /tmp/ccNEOKdC.s:7      *ABS*:0000000000000039 __RAMPX__
     /tmp/ccNEOKdC.s:8      *ABS*:0000000000000038 __RAMPD__
     /tmp/ccNEOKdC.s:9      *ABS*:0000000000000034 __CCP__
     /tmp/ccNEOKdC.s:10     *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccNEOKdC.s:11     *ABS*:0000000000000001 __zero_reg__
     /tmp/ccNEOKdC.s:445    .text:0000000000000000 pvPortMalloc
                             .bss:0000000000000000 xNextFreeByte
     /tmp/ccNEOKdC.s:580    .bss:0000000000000002 xHeap
     /tmp/ccNEOKdC.s:516    .text:000000000000004c vPortFree
     /tmp/ccNEOKdC.s:533    .text:000000000000004e vPortInitialiseBlocks
     /tmp/ccNEOKdC.s:554    .text:0000000000000058 xPortGetFreeHeapSize

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
__do_clear_bss
