   1               		.file	"heap_avr.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__RAMPY__ = 0x3a
   7               	__RAMPX__ = 0x39
   8               	__RAMPD__ = 0x38
   9               	__CCP__ = 0x34
  10               	__tmp_reg__ = 0
  11               	__zero_reg__ = 1
  14               		.text
  15               	.Ltext0:
 475               	.global	pvPortMalloc
 477               	pvPortMalloc:
 478               		.stabd	46,0,0
   1:../../freeRtos/portable/MemMang/heap_avr.c **** /*
   2:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/portable/MemMang/heap_avr.c **** 
   4:../../freeRtos/portable/MemMang/heap_avr.c ****     ***************************************************************************
   5:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
   6:../../freeRtos/portable/MemMang/heap_avr.c ****     * If you are:                                                             *
   7:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
   8:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/portable/MemMang/heap_avr.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  13:../../freeRtos/portable/MemMang/heap_avr.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  15:../../freeRtos/portable/MemMang/heap_avr.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/portable/MemMang/heap_avr.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  18:../../freeRtos/portable/MemMang/heap_avr.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/portable/MemMang/heap_avr.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/portable/MemMang/heap_avr.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/portable/MemMang/heap_avr.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/portable/MemMang/heap_avr.c ****     *                                                                         *
  23:../../freeRtos/portable/MemMang/heap_avr.c ****     ***************************************************************************
  24:../../freeRtos/portable/MemMang/heap_avr.c **** 
  25:../../freeRtos/portable/MemMang/heap_avr.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/portable/MemMang/heap_avr.c **** 
  27:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/portable/MemMang/heap_avr.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/portable/MemMang/heap_avr.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/portable/MemMang/heap_avr.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/portable/MemMang/heap_avr.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/portable/MemMang/heap_avr.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/portable/MemMang/heap_avr.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/portable/MemMang/heap_avr.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/portable/MemMang/heap_avr.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/portable/MemMang/heap_avr.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/portable/MemMang/heap_avr.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/portable/MemMang/heap_avr.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/portable/MemMang/heap_avr.c ****     FreeRTOS WEB site.
  41:../../freeRtos/portable/MemMang/heap_avr.c **** 
  42:../../freeRtos/portable/MemMang/heap_avr.c ****     1 tab == 4 spaces!
  43:../../freeRtos/portable/MemMang/heap_avr.c **** 
  44:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/portable/MemMang/heap_avr.c ****     contact details.
  46:../../freeRtos/portable/MemMang/heap_avr.c **** 
  47:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/portable/MemMang/heap_avr.c ****     critical systems.
  49:../../freeRtos/portable/MemMang/heap_avr.c **** 
  50:../../freeRtos/portable/MemMang/heap_avr.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/portable/MemMang/heap_avr.c ****     licensing and training services.
  52:../../freeRtos/portable/MemMang/heap_avr.c **** */
  53:../../freeRtos/portable/MemMang/heap_avr.c **** 
  54:../../freeRtos/portable/MemMang/heap_avr.c **** 
  55:../../freeRtos/portable/MemMang/heap_avr.c **** /*
  56:../../freeRtos/portable/MemMang/heap_avr.c ****  * AVR implementation of pvPortMalloc().
  57:../../freeRtos/portable/MemMang/heap_avr.c ****  * Modified by Adam Kaliszan
  58:../../freeRtos/portable/MemMang/heap_avr.c ****  */
  59:../../freeRtos/portable/MemMang/heap_avr.c **** #include <stdlib.h>
  60:../../freeRtos/portable/MemMang/heap_avr.c **** 
  61:../../freeRtos/portable/MemMang/heap_avr.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  62:../../freeRtos/portable/MemMang/heap_avr.c **** all the API functions to use the MPU wrappers.  That should only be done when
  63:../../freeRtos/portable/MemMang/heap_avr.c **** task.h is included from an application file. */
  64:../../freeRtos/portable/MemMang/heap_avr.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  65:../../freeRtos/portable/MemMang/heap_avr.c **** 
  66:../../freeRtos/portable/MemMang/heap_avr.c **** #include "FreeRTOS.h"
  67:../../freeRtos/portable/MemMang/heap_avr.c **** #include "task.h"
  68:../../freeRtos/portable/MemMang/heap_avr.c **** 
  69:../../freeRtos/portable/MemMang/heap_avr.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../../freeRtos/portable/MemMang/heap_avr.c **** 
  71:../../freeRtos/portable/MemMang/heap_avr.c **** /* Allocate the memory for the heap.  The struct is used to force byte
  72:../../freeRtos/portable/MemMang/heap_avr.c **** alignment without using any non-portable code. */
  73:../../freeRtos/portable/MemMang/heap_avr.c **** static union xRTOS_HEAP
  74:../../freeRtos/portable/MemMang/heap_avr.c **** {
  75:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if portBYTE_ALIGNMENT == 8
  76:../../freeRtos/portable/MemMang/heap_avr.c **** 		volatile portDOUBLE dDummy;
  77:../../freeRtos/portable/MemMang/heap_avr.c **** 	#else
  78:../../freeRtos/portable/MemMang/heap_avr.c **** 		volatile unsigned long ulDummy;
  79:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif	
  80:../../freeRtos/portable/MemMang/heap_avr.c **** 	unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
  81:../../freeRtos/portable/MemMang/heap_avr.c **** } xHeap;
  82:../../freeRtos/portable/MemMang/heap_avr.c **** 
  83:../../freeRtos/portable/MemMang/heap_avr.c **** static size_t xNextFreeByte = ( size_t ) 0;
  84:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
  85:../../freeRtos/portable/MemMang/heap_avr.c **** 
  86:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvPortMalloc( size_t xWantedSize )
  87:../../freeRtos/portable/MemMang/heap_avr.c **** {
 480               	.LM0:
 481               	.LFBB1:
 482 0000 0F93      		push r16
 483 0002 1F93      		push r17
 484 0004 CF93      		push r28
 485 0006 DF93      		push r29
 486               	/* prologue: function */
 487               	/* frame size = 0 */
 488               	/* stack size = 4 */
 489               	.L__stack_usage = 4
 490 0008 8C01      		movw r16,r24
  88:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvReturn = NULL; 
  89:../../freeRtos/portable/MemMang/heap_avr.c **** 
  90:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Ensure that blocks are always aligned to the required number of bytes. */
  91:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if portBYTE_ALIGNMENT != 1
  92:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  93:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
  94:../../freeRtos/portable/MemMang/heap_avr.c **** 			/* Byte alignment required. */
  95:../../freeRtos/portable/MemMang/heap_avr.c **** 			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  96:../../freeRtos/portable/MemMang/heap_avr.c **** 		}
  97:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif
  98:../../freeRtos/portable/MemMang/heap_avr.c **** 
  99:../../freeRtos/portable/MemMang/heap_avr.c **** 	vTaskSuspendAll();
 492               	.LM1:
 493 000a 0E94 0000 		call vTaskSuspendAll
 100:../../freeRtos/portable/MemMang/heap_avr.c **** 	{
 101:../../freeRtos/portable/MemMang/heap_avr.c **** 		/* Check there is enough room left for the allocation. */
 102:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 495               	.LM2:
 496 000e C091 0000 		lds r28,xNextFreeByte
 497 0012 D091 0000 		lds r29,xNextFreeByte+1
 498 0016 C801      		movw r24,r16
 499 0018 8C0F      		add r24,r28
 500 001a 9D1F      		adc r25,r29
 501 001c 8835      		cpi r24,88
 502 001e 2BE1      		ldi r18,27
 503 0020 9207      		cpc r25,r18
 504 0022 00F4      		brsh .L4
 506               	.LM3:
 507 0024 C817      		cp r28,r24
 508 0026 D907      		cpc r29,r25
 509 0028 00F4      		brsh .L4
 103:../../freeRtos/portable/MemMang/heap_avr.c **** 			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 104:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
 105:../../freeRtos/portable/MemMang/heap_avr.c **** 			/* Return the next free byte then increment the index past this
 106:../../freeRtos/portable/MemMang/heap_avr.c **** 			block. */
 107:../../freeRtos/portable/MemMang/heap_avr.c **** 			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 511               	.LM4:
 512 002a C050      		subi r28,lo8(-(xHeap))
 513 002c D040      		sbci r29,hi8(-(xHeap))
 108:../../freeRtos/portable/MemMang/heap_avr.c **** 			xNextFreeByte += xWantedSize;			
 515               	.LM5:
 516 002e 8093 0000 		sts xNextFreeByte,r24
 517 0032 9093 0000 		sts xNextFreeByte+1,r25
 518 0036 00C0      		rjmp .L2
 519               	.L4:
  88:../../freeRtos/portable/MemMang/heap_avr.c **** void *pvReturn = NULL; 
 521               	.LM6:
 522 0038 C0E0      		ldi r28,0
 523 003a D0E0      		ldi r29,0
 524               	.L2:
 109:../../freeRtos/portable/MemMang/heap_avr.c **** 		}	
 110:../../freeRtos/portable/MemMang/heap_avr.c **** 	}
 111:../../freeRtos/portable/MemMang/heap_avr.c **** 	xTaskResumeAll();
 526               	.LM7:
 527 003c 0E94 0000 		call xTaskResumeAll
 112:../../freeRtos/portable/MemMang/heap_avr.c **** 	
 113:../../freeRtos/portable/MemMang/heap_avr.c **** 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
 114:../../freeRtos/portable/MemMang/heap_avr.c **** 	{
 115:../../freeRtos/portable/MemMang/heap_avr.c **** 		if( pvReturn == NULL )
 116:../../freeRtos/portable/MemMang/heap_avr.c **** 		{
 117:../../freeRtos/portable/MemMang/heap_avr.c **** 			extern void vApplicationMallocFailedHook( void );
 118:../../freeRtos/portable/MemMang/heap_avr.c **** 			vApplicationMallocFailedHook();
 119:../../freeRtos/portable/MemMang/heap_avr.c **** 		}
 120:../../freeRtos/portable/MemMang/heap_avr.c **** 	}
 121:../../freeRtos/portable/MemMang/heap_avr.c **** 	#endif	
 122:../../freeRtos/portable/MemMang/heap_avr.c **** 
 123:../../freeRtos/portable/MemMang/heap_avr.c **** 	return pvReturn;
 124:../../freeRtos/portable/MemMang/heap_avr.c **** }
 529               	.LM8:
 530 0040 CE01      		movw r24,r28
 531               	/* epilogue start */
 532 0042 DF91      		pop r29
 533 0044 CF91      		pop r28
 534 0046 1F91      		pop r17
 535 0048 0F91      		pop r16
 536 004a 0895      		ret
 541               	.Lscope1:
 543               		.stabd	78,0,0
 546               	.global	vPortFree
 548               	vPortFree:
 549               		.stabd	46,0,0
 125:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 126:../../freeRtos/portable/MemMang/heap_avr.c **** 
 127:../../freeRtos/portable/MemMang/heap_avr.c **** void vPortFree( void *pv )
 128:../../freeRtos/portable/MemMang/heap_avr.c **** {
 551               	.LM9:
 552               	.LFBB2:
 553               	/* prologue: function */
 554               	/* frame size = 0 */
 555               	/* stack size = 0 */
 556               	.L__stack_usage = 0
 557 004c 0895      		ret
 559               	.Lscope2:
 561               		.stabd	78,0,0
 563               	.global	vPortInitialiseBlocks
 565               	vPortInitialiseBlocks:
 566               		.stabd	46,0,0
 129:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
 130:../../freeRtos/portable/MemMang/heap_avr.c **** 	for alternative implementations, and the memory management pages of 
 131:../../freeRtos/portable/MemMang/heap_avr.c **** 	http://www.FreeRTOS.org for more information. */
 132:../../freeRtos/portable/MemMang/heap_avr.c **** 	( void ) pv;
 133:../../freeRtos/portable/MemMang/heap_avr.c **** }
 134:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 135:../../freeRtos/portable/MemMang/heap_avr.c **** 
 136:../../freeRtos/portable/MemMang/heap_avr.c **** void vPortInitialiseBlocks( void )
 137:../../freeRtos/portable/MemMang/heap_avr.c **** {
 568               	.LM10:
 569               	.LFBB3:
 570               	/* prologue: function */
 571               	/* frame size = 0 */
 572               	/* stack size = 0 */
 573               	.L__stack_usage = 0
 138:../../freeRtos/portable/MemMang/heap_avr.c **** 	/* Only required when static memory is not cleared. */
 139:../../freeRtos/portable/MemMang/heap_avr.c **** 	xNextFreeByte = ( size_t ) 0;
 575               	.LM11:
 576 004e 1092 0000 		sts xNextFreeByte,__zero_reg__
 577 0052 1092 0000 		sts xNextFreeByte+1,__zero_reg__
 578 0056 0895      		ret
 580               	.Lscope3:
 582               		.stabd	78,0,0
 584               	.global	xPortGetFreeHeapSize
 586               	xPortGetFreeHeapSize:
 587               		.stabd	46,0,0
 140:../../freeRtos/portable/MemMang/heap_avr.c **** }
 141:../../freeRtos/portable/MemMang/heap_avr.c **** /*-----------------------------------------------------------*/
 142:../../freeRtos/portable/MemMang/heap_avr.c **** 
 143:../../freeRtos/portable/MemMang/heap_avr.c **** size_t xPortGetFreeHeapSize( void )
 144:../../freeRtos/portable/MemMang/heap_avr.c **** {
 589               	.LM12:
 590               	.LFBB4:
 591               	/* prologue: function */
 592               	/* frame size = 0 */
 593               	/* stack size = 0 */
 594               	.L__stack_usage = 0
 145:../../freeRtos/portable/MemMang/heap_avr.c **** 	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
 596               	.LM13:
 597 0058 2091 0000 		lds r18,xNextFreeByte
 598 005c 3091 0000 		lds r19,xNextFreeByte+1
 146:../../freeRtos/portable/MemMang/heap_avr.c **** }
 600               	.LM14:
 601 0060 88E5      		ldi r24,lo8(88)
 602 0062 9BE1      		ldi r25,lo8(27)
 603 0064 821B      		sub r24,r18
 604 0066 930B      		sbc r25,r19
 605 0068 0895      		ret
 607               	.Lscope4:
 609               		.stabd	78,0,0
 610               		.local	xNextFreeByte
 611               		.comm	xNextFreeByte,2,1
 612               		.local	xHeap
 613               		.comm	xHeap,7000,1
 617               	.Letext0:
 618               		.ident	"GCC: (GNU) 4.8.2"
 619               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 heap_avr.c
     /tmp/ccvkG6Rp.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccvkG6Rp.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccvkG6Rp.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccvkG6Rp.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccvkG6Rp.s:6      *ABS*:000000000000003a __RAMPY__
     /tmp/ccvkG6Rp.s:7      *ABS*:0000000000000039 __RAMPX__
     /tmp/ccvkG6Rp.s:8      *ABS*:0000000000000038 __RAMPD__
     /tmp/ccvkG6Rp.s:9      *ABS*:0000000000000034 __CCP__
     /tmp/ccvkG6Rp.s:10     *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccvkG6Rp.s:11     *ABS*:0000000000000001 __zero_reg__
     /tmp/ccvkG6Rp.s:477    .text:0000000000000000 pvPortMalloc
                             .bss:0000000000000000 xNextFreeByte
     /tmp/ccvkG6Rp.s:611    .bss:0000000000000002 xHeap
     /tmp/ccvkG6Rp.s:548    .text:000000000000004c vPortFree
     /tmp/ccvkG6Rp.s:565    .text:000000000000004e vPortInitialiseBlocks
     /tmp/ccvkG6Rp.s:586    .text:0000000000000058 xPortGetFreeHeapSize

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
__do_clear_bss
