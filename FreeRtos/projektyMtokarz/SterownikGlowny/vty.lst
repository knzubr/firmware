   1               		.file	"vty.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 563               	enableFunction:
 564               		.stabd	46,0,0
   1:vty.c         **** #include "main.h"
   2:vty.c         **** #include "vty.h"
   3:vty.c         **** #include "ramdysk.h"
   4:vty.c         **** #include "protocol1.h"
   5:vty.c         **** #include "mpc23s17.h"
   6:vty.c         **** #include "mcp3008.h"
   7:vty.c         **** #include "ds1305.h"
   8:vty.c         **** #include "hardwareConfig.h"
   9:vty.c         **** #include "configuration.h"
  10:vty.c         **** #include "Rs485_prot.h"
  11:vty.c         **** #include "net.h"
  12:vty.c         **** #include "ip.h"
  13:vty.c         **** #include "arp.h"
  14:vty.c         **** #include "softwareConfig.h"
  15:vty.c         **** #include "mcp4150.h"
  16:vty.c         **** 
  17:vty.c         **** #if LANG_EN
  18:vty.c         **** #include "vty_en.h"
  19:vty.c         **** #endif
  20:vty.c         **** 
  21:vty.c         **** #if LANG_PL
  22:vty.c         **** #include "vty_pl.h"
  23:vty.c         **** #endif
  24:vty.c         **** 
  25:vty.c         **** #ifndef LANG_VTY
  26:vty.c         **** #error "Vty Language not defined"
  27:vty.c         **** #endif
  28:vty.c         **** 
  29:vty.c         **** 
  30:vty.c         **** static cliExRes_t helpFunction           (cmdState_t *state);
  31:vty.c         **** static cliExRes_t statusFunction         (cmdState_t *state);
  32:vty.c         **** static cliExRes_t statusEncFunction      (cmdState_t *state);
  33:vty.c         **** static cliExRes_t curtainDownFunction    (cmdState_t *state);
  34:vty.c         **** static cliExRes_t curtainUpFunction      (cmdState_t *state);
  35:vty.c         **** static cliExRes_t rpingFunction          (cmdState_t *state);
  36:vty.c         **** static cliExRes_t pingFunction           (cmdState_t *state);
  37:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state);
  38:vty.c         **** static cliExRes_t goXmodemWyslijFunction (cmdState_t *state);
  39:vty.c         **** static cliExRes_t dodajRamPlikFunction   (cmdState_t *state);
  40:vty.c         **** static cliExRes_t eraseRamFileFunction   (cmdState_t *state);
  41:vty.c         **** static cliExRes_t flashExModuleFunction  (cmdState_t *state);
  42:vty.c         **** static cliExRes_t writeRamFileFunction   (cmdState_t *state);
  43:vty.c         **** static cliExRes_t editRamFileFunction    (cmdState_t *state);
  44:vty.c         **** static cliExRes_t readRamFIleFunction    (cmdState_t *state);
  45:vty.c         **** 
  46:vty.c         **** static cliExRes_t ustawPortExtAFunction  (cmdState_t *state);
  47:vty.c         **** static cliExRes_t ustawPortExtBFunction  (cmdState_t *state);
  48:vty.c         **** static cliExRes_t ustawPortRezystor      (cmdState_t *state);
  49:vty.c         **** 
  50:vty.c         **** static cliExRes_t pokazCzasFunction      (cmdState_t *state);
  51:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state);
  52:vty.c         **** static cliExRes_t czytajAC_Function      (cmdState_t *state);
  53:vty.c         **** 
  54:vty.c         **** static cliExRes_t enableFunction         (cmdState_t *state);
  55:vty.c         **** static cliExRes_t disableFunction        (cmdState_t *state);
  56:vty.c         **** static cliExRes_t configureModeFunction  (cmdState_t *state);
  57:vty.c         **** 
  58:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state);
  59:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state);
  60:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state);
  61:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state);
  62:vty.c         **** 
  63:vty.c         **** static cliExRes_t setMacAddrFunction     (cmdState_t *state);
  64:vty.c         **** static cliExRes_t setTimeFunction        (cmdState_t *state);
  65:vty.c         **** 
  66:vty.c         **** static cliExRes_t saveConfigFunction     (cmdState_t *state);
  67:vty.c         **** 
  68:vty.c         **** #ifdef testZewPamiec
  69:vty.c         **** static cliExRes_t testPamZewFunction     (cmdState_t *state);
  70:vty.c         **** #endif
  71:vty.c         **** 
  72:vty.c         **** struct ramPlikFd    fdVty;  //TODO move it to CLI struct
  73:vty.c         **** 
  74:vty.c         **** const char okStr[] PROGMEM = "OK\r\n";
  75:vty.c         **** const char nlStr[] PROGMEM = "\r\n";
  76:vty.c         **** const char BladBuforaPozostaloBajtowStr[] PROGMEM = "!!! W budorze Rs485 pozostalo %d bajtow\r\n";
  77:vty.c         **** 
  78:vty.c         **** 
  79:vty.c         **** const const char* const errorStrings[] PROGMEM = {
  80:vty.c         ****   errorOK,
  81:vty.c         ****   errorNoFile,
  82:vty.c         ****   errorxModemFrameStartTimeout,
  83:vty.c         ****   errorxModemByteSendTimeout,
  84:vty.c         ****   errorxModemWrongFrameNo,
  85:vty.c         ****   errorxModemFrameFrameNoCorrectionNotMatch,
  86:vty.c         ****   errorxModemFrameCrc,
  87:vty.c         ****   errorxModemRemoteSideCan,
  88:vty.c         ****   errorxModemUnknownResponse,
  89:vty.c         ****   errorNoRemoteDevice,
  90:vty.c         ****   errorBootloaderNotResponding,
  91:vty.c         ****   errorOpenFile
  92:vty.c         **** };
  93:vty.c         **** 
  94:vty.c         **** const command_t cmdListNormal[] PROGMEM =
  95:vty.c         **** {
  96:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
  97:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
  98:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},  
  99:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 100:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 101:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 102:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 103:vty.c         ****   {cmd_enable,    cmd_help_enable,    enableFunction},
 104:vty.c         ****   {NULL, NULL, NULL}
 105:vty.c         **** };
 106:vty.c         **** 
 107:vty.c         **** const command_t cmdListEnable[] =
 108:vty.c         **** {
 109:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
 110:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
 111:vty.c         ****   {cmd_enc_stat,  cmd_help_enc_stat,  statusEncFunction},
 112:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},
 113:vty.c         ****   {cmd_net_dbg,   cmd_help_net_dbg,   debugFunction},
 114:vty.c         ****   
 115:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 116:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 117:vty.c         ****   {cmd_xRec,      cmd_help_xRec,      goXmodemOdbierzFunction},
 118:vty.c         ****   {cmd_xSend,     cmd_help_xSend,     goXmodemWyslijFunction},
 119:vty.c         ****   {cmd_xflash,    cmd_help_xflash,    flashExModuleFunction},
 120:vty.c         **** #ifdef testZewPamiec
 121:vty.c         ****   {cmd_rtest,     cmd_help_rtest,     testPamZewFunction},
 122:vty.c         **** #endif
 123:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 124:vty.c         ****   {cmd_create_rf, cmd_help_create_rf, dodajRamPlikFunction},
 125:vty.c         ****   {cmd_erase_rf,  cmd_help_erase_rf,  eraseRamFileFunction},
 126:vty.c         ****   {cmd_edit_rf,   cmd_help_edit_rf,   editRamFileFunction},
 127:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 128:vty.c         **** 
 129:vty.c         ****   {cmd_up,        cmd_help_up,        curtainUpFunction},
 130:vty.c         ****   {cmd_down,      cmd_help_down,      curtainDownFunction},
 131:vty.c         **** 
 132:vty.c         ****   {cmd_spa,       cmd_help_spa,       ustawPortExtAFunction},
 133:vty.c         ****   {cmd_spb,       cmd_help_spb,       ustawPortExtBFunction},
 134:vty.c         ****   {cmd_ustawR,    cmd_help_ustawR,    ustawPortRezystor},
 135:vty.c         ****   {cmd_settime,   cmd_help_settime,   setTimeFunction},
 136:vty.c         ****   {cmd_ac,        cmd_help_ac,        czytajAC_Function},
 137:vty.c         ****   {cmd_disable,   cmd_help_disable,   disableFunction},
 138:vty.c         ****   {cmd_configure, cmd_help_configure, configureModeFunction},
 139:vty.c         ****   {NULL, NULL, NULL}
 140:vty.c         **** };
 141:vty.c         **** 
 142:vty.c         **** const command_t cmdListConfigure[] PROGMEM =
 143:vty.c         **** {
 144:vty.c         ****   {cmd_help,         cmd_help_help,         helpFunction},
 145:vty.c         ****   {cmd_status,       cmd_help_status,       statusFunction},
 146:vty.c         ****   {cmd_time,         cmd_help_time,         pokazCzasFunction},
 147:vty.c         ****   {cmd_settime,      cmd_help_settime,      setTimeFunction},
 148:vty.c         ****   {cmd_conf_ip,      cmd_help_conf_ip,      setIpFunction},
 149:vty.c         ****   {cmd_conf_ip_mask, cmd_conf_ip_mask_help, setIpMaskFunction},
 150:vty.c         ****   {cmd_conf_ip_gw,   cmd_conf_ip_gw_help,   setIpGwFunction},
 151:vty.c         ****   {cmd_conf_udp,     cmd_help_conf_udp,     setUdpFunction},
 152:vty.c         ****   {cmd_conf_mac,     cmd_help_conf_mac,     setMacAddrFunction},
 153:vty.c         ****   {cmd_conf_save,    cmd_help_conf_save,    saveConfigFunction},
 154:vty.c         ****   {cmd_enable,       cmd_help_enable,       enableFunction},
 155:vty.c         ****   {cmd_disable,      cmd_help_disable,      disableFunction},
 156:vty.c         ****   {NULL, NULL, NULL}
 157:vty.c         **** };
 158:vty.c         **** 
 159:vty.c         **** void VtyInit(cmdState_t* state, FILE *stream)
 160:vty.c         **** {
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 162:vty.c         **** }
 163:vty.c         **** 
 164:vty.c         **** void printErrorInfo(cmdState_t *state)
 165:vty.c         **** {
 166:vty.c         ****   if (state->errno != 0)
 167:vty.c         ****   {
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 169:vty.c         ****   }
 170:vty.c         ****   state->errno = 0;
 171:vty.c         ****   state->err1 = 0;
 172:vty.c         ****   state->err2 = 0;
 173:vty.c         **** }
 174:vty.c         **** 
 175:vty.c         **** static cliExRes_t enableFunction(cmdState_t *state)
 176:vty.c         **** {
 566               	.LM0:
 567               	.LFBB1:
 568               	/* prologue: function */
 569               	/* frame size = 0 */
 570               	/* stack size = 0 */
 571               	.L__stack_usage = 0
 572 0000 FC01      		movw r30,r24
 177:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 574               	.LM1:
 575 0002 80A1      		ldd r24,Z+32
 576 0004 8330      		cpi r24,lo8(3)
 577 0006 01F0      		breq .L3
 178:vty.c         ****   {
 179:vty.c         ****     state->cmdList = cmdListEnable;
 579               	.LM2:
 580 0008 80E0      		ldi r24,lo8(cmdListEnable)
 581 000a 90E0      		ldi r25,hi8(cmdListEnable)
 582 000c 81A3      		std Z+33,r24
 583 000e 92A3      		std Z+34,r25
 180:vty.c         ****     state->cliMode = NR_ENABLE;
 585               	.LM3:
 586 0010 81E0      		ldi r24,lo8(1)
 587 0012 80A3      		std Z+32,r24
 181:vty.c         ****     return OK_SILENT;
 589               	.LM4:
 590 0014 20E0      		ldi r18,lo8(0)
 591 0016 30E0      		ldi r19,hi8(0)
 592 0018 00C0      		rjmp .L2
 593               	.L3:
 182:vty.c         ****   }
 183:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 595               	.LM5:
 596 001a 25E0      		ldi r18,lo8(5)
 597 001c 30E0      		ldi r19,hi8(5)
 598               	.L2:
 184:vty.c         **** }
 600               	.LM6:
 601 001e C901      		movw r24,r18
 602               	/* epilogue start */
 603 0020 0895      		ret
 605               	.Lscope1:
 607               		.stabd	78,0,0
 611               	disableFunction:
 612               		.stabd	46,0,0
 185:vty.c         **** static cliExRes_t disableFunction(cmdState_t *state)
 186:vty.c         **** {
 614               	.LM7:
 615               	.LFBB2:
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 0 */
 619               	.L__stack_usage = 0
 620 0022 FC01      		movw r30,r24
 187:vty.c         ****   state->cmdList = cmdListNormal;
 622               	.LM8:
 623 0024 80E0      		ldi r24,lo8(cmdListNormal)
 624 0026 90E0      		ldi r25,hi8(cmdListNormal)
 625 0028 81A3      		std Z+33,r24
 626 002a 92A3      		std Z+34,r25
 188:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 628               	.LM9:
 629 002c 80A1      		ldd r24,Z+32
 630 002e 8330      		cpi r24,lo8(3)
 631 0030 01F0      		breq .L5
 189:vty.c         ****   {
 190:vty.c         ****     state->cliMode = NR_NORMAL;
 633               	.LM10:
 634 0032 10A2      		std Z+32,__zero_reg__
 635               	.L5:
 191:vty.c         ****   }
 192:vty.c         ****   return OK_SILENT;
 193:vty.c         **** }
 637               	.LM11:
 638 0034 80E0      		ldi r24,lo8(0)
 639 0036 90E0      		ldi r25,hi8(0)
 640               	/* epilogue start */
 641 0038 0895      		ret
 643               	.Lscope2:
 645               		.stabd	78,0,0
 649               	configureModeFunction:
 650               		.stabd	46,0,0
 194:vty.c         **** static cliExRes_t configureModeFunction(cmdState_t *state)
 195:vty.c         **** {
 652               	.LM12:
 653               	.LFBB3:
 654               	/* prologue: function */
 655               	/* frame size = 0 */
 656               	/* stack size = 0 */
 657               	.L__stack_usage = 0
 658 003a FC01      		movw r30,r24
 196:vty.c         ****   if (state->cliMode == NR_ENABLE)
 660               	.LM13:
 661 003c 80A1      		ldd r24,Z+32
 662 003e 8130      		cpi r24,lo8(1)
 663 0040 01F4      		brne .L8
 197:vty.c         ****   {
 198:vty.c         ****     state->cmdList = cmdListConfigure;
 665               	.LM14:
 666 0042 80E0      		ldi r24,lo8(cmdListConfigure)
 667 0044 90E0      		ldi r25,hi8(cmdListConfigure)
 668 0046 81A3      		std Z+33,r24
 669 0048 92A3      		std Z+34,r25
 199:vty.c         ****     state->cliMode = NR_CONFIGURE;
 671               	.LM15:
 672 004a 82E0      		ldi r24,lo8(2)
 673 004c 80A3      		std Z+32,r24
 200:vty.c         ****     return OK_SILENT;
 675               	.LM16:
 676 004e 20E0      		ldi r18,lo8(0)
 677 0050 30E0      		ldi r19,hi8(0)
 678 0052 00C0      		rjmp .L7
 679               	.L8:
 201:vty.c         ****   }
 202:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 681               	.LM17:
 682 0054 25E0      		ldi r18,lo8(5)
 683 0056 30E0      		ldi r19,hi8(5)
 684               	.L7:
 203:vty.c         **** }
 686               	.LM18:
 687 0058 C901      		movw r24,r18
 688               	/* epilogue start */
 689 005a 0895      		ret
 691               	.Lscope3:
 693               		.stabd	78,0,0
 697               	saveConfigFunction:
 698               		.stabd	46,0,0
 204:vty.c         **** 
 205:vty.c         **** // ************************** VTY API *************************************************************
 206:vty.c         **** void printStatus(FILE *stream)
 207:vty.c         **** {
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 209:vty.c         ****   //Print system state
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 216:vty.c         **** 
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 219:vty.c         **** //  printErrorInfo(state); //TODO fix and uncomment
 220:vty.c         ****   
 221:vty.c         ****   //Print system configuration
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 223:vty.c         **** 
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 227:vty.c         ****   
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 231:vty.c         **** 
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 235:vty.c         ****   
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 239:vty.c         ****   
 240:vty.c         ****   //Print Rs485 Execitive modules
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 242:vty.c         ****   tmp = printRs485devices(stream);
 243:vty.c         ****   if (tmp == 0)
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 245:vty.c         ****   
 246:vty.c         ****   //Print locker sensors
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 248:vty.c         ****   tmp = printLockers(stream);
 249:vty.c         ****   if (tmp == 0)
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 251:vty.c         ****   
 252:vty.c         ****   //Print time FIXME deadlock problem
 253:vty.c         **** /*  readTimeDecoded((timeDecoded_t *)(&czasRtc));
 254:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 255:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 256:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 257:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/
 258:vty.c         **** 
 259:vty.c         ****   udpPrintStatus(stream);
 260:vty.c         **** //  arpPrintTable(stream);
 261:vty.c         **** }
 262:vty.c         **** 
 263:vty.c         **** 
 264:vty.c         **** // ************************** CLI Functions *******************************************************
 265:vty.c         **** 
 266:vty.c         **** static cliExRes_t statusFunction(cmdState_t *state)
 267:vty.c         **** {
 268:vty.c         ****   if (state->argc < 1)
 269:vty.c         ****   {
 270:vty.c         ****     printStatus(state->myStdInOut);
 271:vty.c         ****     return OK_SILENT; 
 272:vty.c         ****   }
 273:vty.c         ****   
 274:vty.c         ****   FILE stream;
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 276:vty.c         ****   {
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 278:vty.c         ****     return ERROR_INFORM;
 279:vty.c         ****   }
 280:vty.c         **** 
 281:vty.c         ****   printStatus(&stream);
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 283:vty.c         ****   return OK_SILENT; 
 284:vty.c         **** }
 285:vty.c         **** 
 286:vty.c         **** static cliExRes_t statusEncFunction(cmdState_t *state)
 287:vty.c         **** {
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 289:vty.c         ****   return OK_SILENT;
 290:vty.c         **** }
 291:vty.c         **** 
 292:vty.c         **** static cliExRes_t pokazCzasFunction(cmdState_t *state)
 293:vty.c         **** {
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 299:vty.c         ****   return OK_SILENT;
 300:vty.c         **** }
 301:vty.c         **** 
 302:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state)
 303:vty.c         **** {
 304:vty.c         ****   if (state->argc < 2)
 305:vty.c         ****     return SYNTAX_ERROR;
 306:vty.c         **** 
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 309:vty.c         ****   if (level == 0)
 310:vty.c         ****   {
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 312:vty.c         ****     {
 313:vty.c         ****       setArpDebug(NULL, 0);
 314:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 315:vty.c         ****       return OK_SILENT;  
 316:vty.c         ****     }    
 317:vty.c         **** 
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 319:vty.c         ****     {
 320:vty.c         ****       setIpDebug(NULL, 0);
 321:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 322:vty.c         ****       return OK_SILENT;  
 323:vty.c         ****     }    
 324:vty.c         **** 
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 326:vty.c         ****     {
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 328:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 329:vty.c         ****       return OK_SILENT;  
 330:vty.c         ****     }    
 331:vty.c         **** 
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 333:vty.c         ****     {
 334:vty.c         ****       setTcpDebug(NULL, 0);
 335:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 336:vty.c         ****       return OK_SILENT;  
 337:vty.c         ****     }    
 338:vty.c         **** 
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 340:vty.c         ****     {
 341:vty.c         ****       setUdpDebug(NULL, 0);
 342:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 343:vty.c         ****       return OK_SILENT;  
 344:vty.c         ****     }    
 345:vty.c         **** 
 346:vty.c         **** 
 347:vty.c         ****   }
 348:vty.c         ****   else                   //level > 0
 349:vty.c         ****   {
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 351:vty.c         ****     {
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 353:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 354:vty.c         ****       return OK_SILENT;  
 355:vty.c         ****     }   
 356:vty.c         ****     
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 358:vty.c         ****     {
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 360:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 361:vty.c         ****       return OK_SILENT;  
 362:vty.c         ****     }
 363:vty.c         **** 
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 365:vty.c         ****     {
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 367:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 368:vty.c         ****       return OK_SILENT;  
 369:vty.c         ****     }
 370:vty.c         **** 
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 372:vty.c         ****     {
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 374:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 375:vty.c         ****       return OK_SILENT;  
 376:vty.c         ****     }
 377:vty.c         ****     
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 379:vty.c         ****     {
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 381:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 382:vty.c         ****       return OK_SILENT;  
 383:vty.c         ****     }
 384:vty.c         ****   }
 385:vty.c         ****   
 386:vty.c         ****   return SYNTAX_ERROR;
 387:vty.c         **** }
 388:vty.c         **** 
 389:vty.c         **** 
 390:vty.c         **** static cliExRes_t setTimeFunction(cmdState_t *state)
 391:vty.c         **** {
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 395:vty.c         ****   
 396:vty.c         ****   ds1305start();
 397:vty.c         **** 
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 399:vty.c         ****   uint8_t cJedn = godzina - cDzies*10;
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 402:vty.c         ****   
 403:vty.c         ****   cDzies = minuta/10;
 404:vty.c         ****   cJedn = minuta - cDzies * 10;
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 407:vty.c         ****   
 408:vty.c         ****   cDzies = sekunda/10;
 409:vty.c         ****   cJedn  = sekunda - cDzies * 10;
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 412:vty.c         ****   
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 414:vty.c         ****   return OK_SILENT;
 415:vty.c         **** }
 416:vty.c         **** 
 417:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state)
 418:vty.c         **** {
 419:vty.c         ****   if (state->argc < 4)
 420:vty.c         ****     return SYNTAX_ERROR;
 421:vty.c         ****   
 422:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 423:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 424:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 426:vty.c         ****   
 427:vty.c         ****   ipSetConfigIp(ip);
 428:vty.c         ****   return OK_SILENT;
 429:vty.c         **** }
 430:vty.c         **** 
 431:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state)
 432:vty.c         **** {
 433:vty.c         ****   if (state->argc < 5)
 434:vty.c         ****     return SYNTAX_ERROR;
 435:vty.c         ****   
 436:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 437:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 438:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 440:vty.c         ****   udpSocket->dstIp = ip;
 441:vty.c         ****   
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 444:vty.c         ****   
 445:vty.c         ****   if (state->argc > 5)
 446:vty.c         ****   {
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 449:vty.c         ****   }
 450:vty.c         ****   return OK_SILENT;
 451:vty.c         **** }
 452:vty.c         **** 
 453:vty.c         **** 
 454:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state)
 455:vty.c         **** {
 456:vty.c         ****   if (state->argc < 1)
 457:vty.c         ****     return SYNTAX_ERROR;
 458:vty.c         ****   
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 460:vty.c         ****   
 461:vty.c         ****   ipSetConfigMask(mask);
 462:vty.c         ****   return OK_SILENT;
 463:vty.c         **** }
 464:vty.c         **** 
 465:vty.c         **** 
 466:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state)
 467:vty.c         **** {
 468:vty.c         ****   if (state->argc < 4)
 469:vty.c         ****     return SYNTAX_ERROR;
 470:vty.c         ****   
 471:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) + 
 472:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 473:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 475:vty.c         ****   ipSetConfigGw(gw);
 476:vty.c         ****   return OK_SILENT;
 477:vty.c         **** }
 478:vty.c         **** 
 479:vty.c         **** static cliExRes_t setMacAddrFunction(cmdState_t *state)
 480:vty.c         **** {
 481:vty.c         ****   if (state->argc < 6)
 482:vty.c         ****     return SYNTAX_ERROR;  
 483:vty.c         ****   
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 491:vty.c         ****   return OK_SILENT;
 492:vty.c         **** }
 493:vty.c         **** 
 494:vty.c         **** static cliExRes_t czytajAC_Function(cmdState_t *state)
 495:vty.c         **** {
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 499:vty.c         ****   return OK_SILENT;
 500:vty.c         **** }
 501:vty.c         **** 
 502:vty.c         **** static cliExRes_t helpFunction(cmdState_t *state)
 503:vty.c         **** {
 504:vty.c         ****   cmdPrintHelp(state);
 505:vty.c         ****   return OK_SILENT;
 506:vty.c         **** }
 507:vty.c         **** 
 508:vty.c         **** static cliExRes_t curtainDownFunction(cmdState_t *state)
 509:vty.c         **** {
 510:vty.c         ****   uint8_t nrRolety;
 511:vty.c         ****   uint8_t nrSterownika;
 512:vty.c         ****   uint8_t wartosc;
 513:vty.c         ****   
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 516:vty.c         ****   nrRolety &= 0x01;
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 518:vty.c         **** 
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 520:vty.c         **** 
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 523:vty.c         **** 
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 525:vty.c         ****   
 526:vty.c         ****   if (result == 0)
 527:vty.c         ****     return OK_INFORM;
 528:vty.c         ****   
 529:vty.c         ****   return ERROR_SILENT;
 530:vty.c         **** }
 531:vty.c         **** 
 532:vty.c         **** static cliExRes_t curtainUpFunction(cmdState_t *state)
 533:vty.c         **** {
 534:vty.c         ****   if (state->argc < 2)
 535:vty.c         ****     return SYNTAX_ERROR;
 536:vty.c         ****   
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 539:vty.c         ****   uint8_t wartosc = 255;
 540:vty.c         ****   if (state->argc > 2)
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 542:vty.c         **** 
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 546:vty.c         **** 
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 548:vty.c         ****   
 549:vty.c         ****   if (result == 0)
 550:vty.c         ****     return OK_INFORM;
 551:vty.c         ****   
 552:vty.c         ****   return ERROR_SILENT;
 553:vty.c         **** }
 554:vty.c         **** 
 555:vty.c         **** static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
 556:vty.c         **** {
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 560:vty.c         ****   return OK_SILENT;
 561:vty.c         **** }
 562:vty.c         **** 
 563:vty.c         **** static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
 564:vty.c         **** {
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 568:vty.c         ****   return OK_SILENT;
 569:vty.c         **** }
 570:vty.c         **** 
 571:vty.c         **** static cliExRes_t ustawPortRezystor(cmdState_t *state)
 572:vty.c         **** {
 573:vty.c         ****   if (state->argc < 1)
 574:vty.c         ****     return SYNTAX_ERROR;
 575:vty.c         **** 
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 577:vty.c         ****   
 578:vty.c         ****   MCP4150_setValue(wartosc);
 579:vty.c         ****   
 580:vty.c         ****   return OK_SILENT;
 581:vty.c         **** }
 582:vty.c         **** 
 583:vty.c         **** static cliExRes_t rpingFunction(cmdState_t *state)
 584:vty.c         **** {
 585:vty.c         ****   if (state->argc < 1)
 586:vty.c         ****     return SYNTAX_ERROR;
 587:vty.c         ****   
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 590:vty.c         ****     return OK_INFORM;
 591:vty.c         **** 
 592:vty.c         ****   state->errno = noRemoteDevice;
 593:vty.c         ****   state->err1 = nrSterownika;
 594:vty.c         ****   printErrorInfo(state);
 595:vty.c         ****   return OK_SILENT;
 596:vty.c         **** }
 597:vty.c         **** 
 598:vty.c         **** static cliExRes_t pingFunction(cmdState_t *state)
 599:vty.c         **** {
 600:vty.c         ****   if (state->argc < 4)
 601:vty.c         ****     return SYNTAX_ERROR;
 602:vty.c         ****   
 603:vty.c         ****   uint8_t ip[4];
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 608:vty.c         **** 
 609:vty.c         **** //  Ipv4Ping(*((uint32_t *)(ip)));
 610:vty.c         ****   
 611:vty.c         ****   return OK_SILENT;
 612:vty.c         **** }
 613:vty.c         **** 
 614:vty.c         **** 
 615:vty.c         **** static cliExRes_t flashExModuleFunction(cmdState_t *state)
 616:vty.c         **** {
 617:vty.c         ****   if (state->argc != 2)
 618:vty.c         ****     return SYNTAX_ERROR;
 619:vty.c         ****   
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 622:vty.c         ****   uint8_t  blad;
 623:vty.c         ****   
 624:vty.c         ****   // Sprawdzanie, czy moduł wykonawczy odpowiada
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 626:vty.c         ****   {
 627:vty.c         ****     state->errno = noRemoteDevice;
 628:vty.c         ****     printErrorInfo(state);
 629:vty.c         ****     return ERROR_INFORM;
 630:vty.c         ****   }
 631:vty.c         ****   
 632:vty.c         ****   //Sprawdzanie, czy istnieje odpowiedni plik z firmware
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 634:vty.c         ****   {
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 636:vty.c         ****     return ERROR_INFORM;
 637:vty.c         ****   }
 638:vty.c         ****   
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 640:vty.c         **** 
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 642:vty.c         ****   
 643:vty.c         ****   if (blad != 0)
 644:vty.c         ****     return ERROR_INFORM;
 645:vty.c         **** 
 646:vty.c         ****   return OK_SILENT;
 647:vty.c         **** }
 648:vty.c         **** 
 649:vty.c         **** static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
 650:vty.c         **** {
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 653:vty.c         ****   {
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 655:vty.c         ****     return ERROR_INFORM;
 656:vty.c         ****   }
 657:vty.c         ****   return OK_SILENT;
 658:vty.c         **** }
 659:vty.c         **** 
 660:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
 661:vty.c         **** {
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 664:vty.c         ****   {
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 666:vty.c         ****     return ERROR_INFORM;
 667:vty.c         ****   }
 668:vty.c         ****    
 669:vty.c         ****   uint8_t  i = 25;
 670:vty.c         **** 
 671:vty.c         ****   uint8_t  temp1;
 672:vty.c         **** //  uint8_t  temp2;
 673:vty.c         **** 
 674:vty.c         ****   uint8_t  c;
 675:vty.c         ****   uint8_t  liczbaProb;
 676:vty.c         ****   uint8_t  *zapPtr;
 677:vty.c         ****   uint8_t  *zapPtrKopia;
 678:vty.c         ****  
 679:vty.c         ****   uint16_t crcLokalne;
 680:vty.c         ****   uint8_t nrBloku;
 681:vty.c         **** 
 682:vty.c         ****   uint8_t nrBlokuZdalny;
 683:vty.c         ****   uint8_t nrBlokuZdalnyNeg;
 684:vty.c         **** 
 685:vty.c         ****   uint8_t crcHi;
 686:vty.c         ****   uint8_t crcLo;
 687:vty.c         **** 
 688:vty.c         ****   state->err1=0;
 689:vty.c         ****   state->err2=0;
 690:vty.c         ****   liczbaProb = 20;
 691:vty.c         ****   for ( ; ; )
 692:vty.c         ****   {
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 694:vty.c         ****    // while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufo
 695:vty.c         **** //od usartD0
 696:vty.c         ****     while(!(USARTD0.STATUS & USART_TXCIF_bm));
 697:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 698:vty.c         ****       if (c == SOH)
 699:vty.c         ****         break;                                                   //Rozpoczynamy transmisje
 700:vty.c         **** 
 701:vty.c         ****     liczbaProb--;
 702:vty.c         ****     if (liczbaProb == 0)
 703:vty.c         ****     {
 704:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 705:vty.c         ****       state->errno = (uint8_t)(AllOK);
 706:vty.c         ****       return ERROR_INFORM;
 707:vty.c         ****     }
 708:vty.c         ****   }
 709:vty.c         ****   
 710:vty.c         ****   nrBloku = 1;
 711:vty.c         ****   liczbaProb = 10;
 712:vty.c         **** 
 713:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 714:vty.c         ****   zapPtrKopia     = zapPtr;
 715:vty.c         ****   for ( ; ; )
 716:vty.c         ****   {
 717:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 718:vty.c         ****     {
 719:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 720:vty.c         ****       break; 
 721:vty.c         ****     }
 722:vty.c         ****     
 723:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 724:vty.c         ****     {
 725:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 726:vty.c         ****       break; 
 727:vty.c         ****     }
 728:vty.c         ****   
 729:vty.c         ****     //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
 730:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 731:vty.c         ****     if (nrBlokuZdalny != c)
 732:vty.c         ****     {
 733:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 734:vty.c         ****       state->err1 = nrBlokuZdalny;
 735:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 736:vty.c         ****       break;
 737:vty.c         ****     }
 738:vty.c         ****     
 739:vty.c         ****     //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od b
 740:vty.c         ****     c = nrBloku-1;
 741:vty.c         ****     if (nrBlokuZdalny == c)
 742:vty.c         ****     {
 743:vty.c         ****       nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
 744:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 745:vty.c         ****       zapPtrKopia = zapPtr;
 746:vty.c         ****     }
 747:vty.c         ****     
 748:vty.c         ****     //2 Sprawdzanie, czy pasuje numer bloku
 749:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 750:vty.c         ****     {
 751:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 752:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 753:vty.c         ****       state->err2 = nrBloku;
 754:vty.c         ****       break;
 755:vty.c         ****     }
 756:vty.c         ****         
 757:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 758:vty.c         ****     {
 759:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 760:vty.c         ****         *(zapPtr++) = c;
 761:vty.c         ****       else
 762:vty.c         ****       {
 763:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 764:vty.c         ****         break;
 765:vty.c         ****       }
 766:vty.c         ****     }
 767:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 768:vty.c         ****     {
 769:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 770:vty.c         ****         state->err1 = 2;
 771:vty.c         ****         break;      
 772:vty.c         ****     }
 773:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 774:vty.c         ****     {
 775:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 776:vty.c         ****         state->err1 = 1;
 777:vty.c         ****         break;      
 778:vty.c         ****     }
 779:vty.c         **** 
 780:vty.c         ****     //3 Zerowanie CRC
 781:vty.c         ****     crcLokalne=0; 
 782:vty.c         ****     
 783:vty.c         ****     //4 Obliczanie CRC
 784:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 785:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 786:vty.c         ****      
 787:vty.c         ****     //5 Srawdzanie CRC
 788:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 789:vty.c         ****     {
 790:vty.c         ****       liczbaProb = 10;
 791:vty.c         ****       uartVtySendByte(ACK);      
 792:vty.c         ****     }
 793:vty.c         ****     else
 794:vty.c         ****     {
 795:vty.c         ****       liczbaProb--;
 796:vty.c         ****       nrBloku--;
 797:vty.c         ****       uartVtySendByte(NAK);   
 798:vty.c         ****     }
 799:vty.c         ****     
 800:vty.c         ****     if (liczbaProb == 0)
 801:vty.c         ****     {
 802:vty.c         ****       state->err1 = nrBlokuZdalny;
 803:vty.c         ****       state->err2 = nrBloku;
 804:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 805:vty.c         ****       break; 
 806:vty.c         ****     }
 807:vty.c         **** 
 808:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 809:vty.c         ****     {
 810:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 811:vty.c         ****       break;
 812:vty.c         ****     }
 813:vty.c         ****     
 814:vty.c         ****     if (temp1 == SOH)
 815:vty.c         ****     {
 816:vty.c         ****       nrBloku++;
 817:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 818:vty.c         ****       zapPtrKopia = zapPtr;
 819:vty.c         ****       state->errno = (uint8_t)(AllOK);
 820:vty.c         ****       continue;
 821:vty.c         ****     }
 822:vty.c         **** 
 823:vty.c         ****     if (temp1 == CAN)
 824:vty.c         ****     {
 825:vty.c         ****       state->err1 = nrBloku;
 826:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 827:vty.c         ****       break;
 828:vty.c         ****     }
 829:vty.c         ****     if (temp1 == EOT)
 830:vty.c         ****     {
 831:vty.c         ****       uartVtySendByte(NAK);
 832:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 833:vty.c         ****       {
 834:vty.c         ****         if (temp1 == EOT)
 835:vty.c         ****           uartVtySendByte(ACK);  
 836:vty.c         ****       }
 837:vty.c         ****       state->errno = (uint8_t)(AllOK);
 838:vty.c         ****       break;
 839:vty.c         ****     }
 840:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 841:vty.c         ****     state->err1 = temp1;
 842:vty.c         ****     break;
 843:vty.c         ****   }
 844:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 845:vty.c         ****   return OK_SILENT;
 846:vty.c         **** }
 847:vty.c         **** 
 848:vty.c         **** static cliExRes_t eraseRamFileFunction(cmdState_t *state)
 849:vty.c         **** {
 850:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 851:vty.c         ****     return OK_INFORM;
 852:vty.c         **** 
 853:vty.c         ****   printErrorInfo(state);
 854:vty.c         ****   return ERROR_INFORM;
 855:vty.c         **** }
 856:vty.c         **** 
 857:vty.c         **** static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
 858:vty.c         **** {
 859:vty.c         ****   if (state->argc != 1)
 860:vty.c         ****     return SYNTAX_ERROR;
 861:vty.c         **** 
 862:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 863:vty.c         ****   {
 864:vty.c         ****     return OK_INFORM;
 865:vty.c         ****   }
 866:vty.c         ****   printErrorInfo(state);
 867:vty.c         ****   return ERROR_INFORM;
 868:vty.c         **** }
 869:vty.c         **** 
 870:vty.c         **** static cliExRes_t writeRamFileFunction(cmdState_t *state)
 871:vty.c         **** {
 872:vty.c         ****   ramDyskDir(state->myStdInOut);
 873:vty.c         ****   return OK_SILENT;
 874:vty.c         **** }
 875:vty.c         **** 
 876:vty.c         **** static cliExRes_t editRamFileFunction(cmdState_t *state)
 877:vty.c         **** {
 878:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 879:vty.c         ****   {
 880:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 881:vty.c         ****     return ERROR_INFORM;
 882:vty.c         ****   }
 883:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 884:vty.c         ****   uint8_t znak = 0;
 885:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 886:vty.c         ****   while(1)
 887:vty.c         ****   {
 888:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 889:vty.c         ****       continue;
 890:vty.c         **** 
 891:vty.c         ****     if (znak == 0x03)                                       // ^C
 892:vty.c         ****       break;
 893:vty.c         **** 
 894:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 895:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 896:vty.c         ****   }
 897:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 898:vty.c         ****   return OK_SILENT;
 899:vty.c         **** }
 900:vty.c         **** 
 901:vty.c         **** static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
 902:vty.c         **** {
 903:vty.c         ****   uint8_t rezultat;
 904:vty.c         ****   uint8_t znak = ' ';
 905:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 906:vty.c         ****   {
 907:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 908:vty.c         ****     return ERROR_INFORM;
 909:vty.c         ****   }
 910:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 911:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 912:vty.c         ****   while (rezultat == 0)
 913:vty.c         ****   {
 914:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 915:vty.c         ****     
 916:vty.c         ****     uartVtySendByte(znak);
 917:vty.c         ****     if (znak == '\r')
 918:vty.c         ****       uartVtySendByte('\n');
 919:vty.c         ****   }
 920:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 921:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 922:vty.c         ****   return OK_SILENT;
 923:vty.c         **** }
 924:vty.c         **** 
 925:vty.c         **** static cliExRes_t saveConfigFunction(cmdState_t *state)
 926:vty.c         **** {
 700               	.LM19:
 701               	.LFBB4:
 702               	/* prologue: function */
 703               	/* frame size = 0 */
 704               	/* stack size = 0 */
 705               	.L__stack_usage = 0
 927:vty.c         ****   state = NULL;
 928:vty.c         ****   saveConfiguration();
 707               	.LM20:
 708 005c 0E94 0000 		call saveConfiguration
 929:vty.c         ****   return OK_SILENT;
 930:vty.c         **** }
 710               	.LM21:
 711 0060 80E0      		ldi r24,lo8(0)
 712 0062 90E0      		ldi r25,hi8(0)
 713               	/* epilogue start */
 714 0064 0895      		ret
 716               	.Lscope4:
 718               		.stabd	78,0,0
 722               	setMacAddrFunction:
 723               		.stabd	46,0,0
 480:vty.c         **** {
 725               	.LM22:
 726               	.LFBB5:
 727 0066 CF93      		push r28
 728 0068 DF93      		push r29
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731               	/* stack size = 2 */
 732               	.L__stack_usage = 2
 733 006a EC01      		movw r28,r24
 481:vty.c         ****   if (state->argc < 6)
 735               	.LM23:
 736 006c 898D      		ldd r24,Y+25
 737 006e 8630      		cpi r24,lo8(6)
 738 0070 00F0      		brlo .L12
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 740               	.LM24:
 741 0072 81E0      		ldi r24,lo8(1)
 742 0074 BE01      		movw r22,r28
 743 0076 0E94 0000 		call cmdlineGetArgHex
 744 007a 6093 0000 		sts nicState+2,r22
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 746               	.LM25:
 747 007e 82E0      		ldi r24,lo8(2)
 748 0080 BE01      		movw r22,r28
 749 0082 0E94 0000 		call cmdlineGetArgHex
 750 0086 6093 0000 		sts nicState+3,r22
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 752               	.LM26:
 753 008a 83E0      		ldi r24,lo8(3)
 754 008c BE01      		movw r22,r28
 755 008e 0E94 0000 		call cmdlineGetArgHex
 756 0092 6093 0000 		sts nicState+4,r22
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 758               	.LM27:
 759 0096 84E0      		ldi r24,lo8(4)
 760 0098 BE01      		movw r22,r28
 761 009a 0E94 0000 		call cmdlineGetArgHex
 762 009e 6093 0000 		sts nicState+5,r22
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 764               	.LM28:
 765 00a2 85E0      		ldi r24,lo8(5)
 766 00a4 BE01      		movw r22,r28
 767 00a6 0E94 0000 		call cmdlineGetArgHex
 768 00aa 6093 0000 		sts nicState+6,r22
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 770               	.LM29:
 771 00ae 86E0      		ldi r24,lo8(6)
 772 00b0 BE01      		movw r22,r28
 773 00b2 0E94 0000 		call cmdlineGetArgHex
 774 00b6 6093 0000 		sts nicState+7,r22
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 776               	.LM30:
 777 00ba 80E0      		ldi r24,lo8(nicState+2)
 778 00bc 90E0      		ldi r25,hi8(nicState+2)
 779 00be 0E94 0000 		call nicSetMacAddress
 491:vty.c         ****   return OK_SILENT;
 781               	.LM31:
 782 00c2 20E0      		ldi r18,lo8(0)
 783 00c4 30E0      		ldi r19,hi8(0)
 784 00c6 00C0      		rjmp .L11
 785               	.L12:
 482:vty.c         ****     return SYNTAX_ERROR;  
 787               	.LM32:
 788 00c8 22E0      		ldi r18,lo8(2)
 789 00ca 30E0      		ldi r19,hi8(2)
 790               	.L11:
 492:vty.c         **** }
 792               	.LM33:
 793 00cc C901      		movw r24,r18
 794               	/* epilogue start */
 795 00ce DF91      		pop r29
 796 00d0 CF91      		pop r28
 797 00d2 0895      		ret
 799               	.Lscope5:
 801               		.stabd	78,0,0
 805               	pingFunction:
 806               		.stabd	46,0,0
 599:vty.c         **** {
 808               	.LM34:
 809               	.LFBB6:
 810 00d4 CF93      		push r28
 811 00d6 DF93      		push r29
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 814               	/* stack size = 2 */
 815               	.L__stack_usage = 2
 816 00d8 EC01      		movw r28,r24
 600:vty.c         ****   if (state->argc < 4)
 818               	.LM35:
 819 00da 898D      		ldd r24,Y+25
 820 00dc 8430      		cpi r24,lo8(4)
 821 00de 00F0      		brlo .L15
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 823               	.LM36:
 824 00e0 81E0      		ldi r24,lo8(1)
 825 00e2 BE01      		movw r22,r28
 826 00e4 0E94 0000 		call cmdlineGetArgInt
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 828               	.LM37:
 829 00e8 82E0      		ldi r24,lo8(2)
 830 00ea BE01      		movw r22,r28
 831 00ec 0E94 0000 		call cmdlineGetArgInt
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 833               	.LM38:
 834 00f0 83E0      		ldi r24,lo8(3)
 835 00f2 BE01      		movw r22,r28
 836 00f4 0E94 0000 		call cmdlineGetArgInt
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 838               	.LM39:
 839 00f8 84E0      		ldi r24,lo8(4)
 840 00fa BE01      		movw r22,r28
 841 00fc 0E94 0000 		call cmdlineGetArgInt
 611:vty.c         ****   return OK_SILENT;
 843               	.LM40:
 844 0100 20E0      		ldi r18,lo8(0)
 845 0102 30E0      		ldi r19,hi8(0)
 846 0104 00C0      		rjmp .L14
 847               	.L15:
 601:vty.c         ****     return SYNTAX_ERROR;
 849               	.LM41:
 850 0106 22E0      		ldi r18,lo8(2)
 851 0108 30E0      		ldi r19,hi8(2)
 852               	.L14:
 612:vty.c         **** }
 854               	.LM42:
 855 010a C901      		movw r24,r18
 856               	/* epilogue start */
 857 010c DF91      		pop r29
 858 010e CF91      		pop r28
 859 0110 0895      		ret
 861               	.Lscope6:
 863               		.stabd	78,0,0
 867               	setUdpFunction:
 868               		.stabd	46,0,0
 432:vty.c         **** {
 870               	.LM43:
 871               	.LFBB7:
 872 0112 2F92      		push r2
 873 0114 3F92      		push r3
 874 0116 4F92      		push r4
 875 0118 5F92      		push r5
 876 011a 6F92      		push r6
 877 011c 7F92      		push r7
 878 011e 8F92      		push r8
 879 0120 9F92      		push r9
 880 0122 AF92      		push r10
 881 0124 BF92      		push r11
 882 0126 CF92      		push r12
 883 0128 DF92      		push r13
 884 012a EF92      		push r14
 885 012c FF92      		push r15
 886 012e 0F93      		push r16
 887 0130 1F93      		push r17
 888 0132 CF93      		push r28
 889 0134 DF93      		push r29
 890               	/* prologue: function */
 891               	/* frame size = 0 */
 892               	/* stack size = 18 */
 893               	.L__stack_usage = 18
 894 0136 EC01      		movw r28,r24
 433:vty.c         ****   if (state->argc < 5)
 896               	.LM44:
 897 0138 898D      		ldd r24,Y+25
 898 013a 8530      		cpi r24,lo8(5)
 899 013c 00F4      		brsh .+2
 900 013e 00C0      		rjmp .L18
 436:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 902               	.LM45:
 903 0140 81E0      		ldi r24,lo8(1)
 904 0142 BE01      		movw r22,r28
 905 0144 0E94 0000 		call cmdlineGetArgInt
 906 0148 1B01      		movw r2,r22
 907 014a 2C01      		movw r4,r24
 437:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 909               	.LM46:
 910 014c 82E0      		ldi r24,lo8(2)
 911 014e BE01      		movw r22,r28
 912 0150 0E94 0000 		call cmdlineGetArgInt
 913 0154 5B01      		movw r10,r22
 914 0156 6C01      		movw r12,r24
 438:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 916               	.LM47:
 917 0158 83E0      		ldi r24,lo8(3)
 918 015a BE01      		movw r22,r28
 919 015c 0E94 0000 		call cmdlineGetArgInt
 920 0160 3B01      		movw r6,r22
 921 0162 4C01      		movw r8,r24
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 923               	.LM48:
 924 0164 84E0      		ldi r24,lo8(4)
 925 0166 BE01      		movw r22,r28
 926 0168 0E94 0000 		call cmdlineGetArgInt
 927 016c 7B01      		movw r14,r22
 928 016e 8C01      		movw r16,r24
 440:vty.c         ****   udpSocket->dstIp = ip;
 930               	.LM49:
 931 0170 E091 0000 		lds r30,udpSocket
 932 0174 F091 0000 		lds r31,udpSocket+1
 437:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 934               	.LM50:
 935 0178 BC2D      		mov r27,r12
 936 017a AB2D      		mov r26,r11
 937 017c 9A2D      		mov r25,r10
 938 017e 8827      		clr r24
 438:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 940               	.LM51:
 941 0180 A301      		movw r20,r6
 942 0182 3327      		clr r19
 943 0184 2227      		clr r18
 436:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 945               	.LM52:
 946 0186 820F      		add r24,r18
 947 0188 931F      		adc r25,r19
 948 018a A41F      		adc r26,r20
 949 018c B51F      		adc r27,r21
 437:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 951               	.LM53:
 952 018e 820D      		add r24,r2
 953 0190 931D      		adc r25,r3
 954 0192 A41D      		adc r26,r4
 955 0194 B51D      		adc r27,r5
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 957               	.LM54:
 958 0196 1E2D      		mov r17,r14
 959 0198 0027      		clr r16
 960 019a FF24      		clr r15
 961 019c EE24      		clr r14
 436:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 963               	.LM55:
 964 019e 8E0D      		add r24,r14
 965 01a0 9F1D      		adc r25,r15
 966 01a2 A01F      		adc r26,r16
 967 01a4 B11F      		adc r27,r17
 440:vty.c         ****   udpSocket->dstIp = ip;
 969               	.LM56:
 970 01a6 8683      		std Z+6,r24
 971 01a8 9783      		std Z+7,r25
 972 01aa A087      		std Z+8,r26
 973 01ac B187      		std Z+9,r27
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 975               	.LM57:
 976 01ae 85E0      		ldi r24,lo8(5)
 977 01b0 BE01      		movw r22,r28
 978 01b2 0E94 0000 		call cmdlineGetArgInt
 979 01b6 DC01      		movw r26,r24
 980 01b8 CB01      		movw r24,r22
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 982               	.LM58:
 983 01ba E090 0000 		lds r14,udpSocket
 984 01be F090 0000 		lds r15,udpSocket+1
 985 01c2 0E94 0000 		call htons
 986 01c6 F701      		movw r30,r14
 987 01c8 8483      		std Z+4,r24
 988 01ca 9583      		std Z+5,r25
 445:vty.c         ****   if (state->argc > 5)
 990               	.LM59:
 991 01cc 898D      		ldd r24,Y+25
 992 01ce 8630      		cpi r24,lo8(6)
 993 01d0 00F0      		brlo .L19
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 995               	.LM60:
 996 01d2 86E0      		ldi r24,lo8(6)
 997 01d4 BE01      		movw r22,r28
 998 01d6 0E94 0000 		call cmdlineGetArgInt
 999 01da DC01      		movw r26,r24
 1000 01dc CB01      		movw r24,r22
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 1002               	.LM61:
 1003 01de C091 0000 		lds r28,udpSocket
 1004 01e2 D091 0000 		lds r29,udpSocket+1
 1005 01e6 0E94 0000 		call htons
 1006 01ea 8A83      		std Y+2,r24
 1007 01ec 9B83      		std Y+3,r25
 1008 01ee 00C0      		rjmp .L19
 1009               	.L18:
 434:vty.c         ****     return SYNTAX_ERROR;
 1011               	.LM62:
 1012 01f0 22E0      		ldi r18,lo8(2)
 1013 01f2 30E0      		ldi r19,hi8(2)
 1014 01f4 00C0      		rjmp .L17
 1015               	.L19:
 450:vty.c         ****   return OK_SILENT;
 1017               	.LM63:
 1018 01f6 20E0      		ldi r18,lo8(0)
 1019 01f8 30E0      		ldi r19,hi8(0)
 1020               	.L17:
 451:vty.c         **** }
 1022               	.LM64:
 1023 01fa C901      		movw r24,r18
 1024               	/* epilogue start */
 1025 01fc DF91      		pop r29
 1026 01fe CF91      		pop r28
 1027 0200 1F91      		pop r17
 1028 0202 0F91      		pop r16
 1029 0204 FF90      		pop r15
 1030 0206 EF90      		pop r14
 1031 0208 DF90      		pop r13
 1032 020a CF90      		pop r12
 1033 020c BF90      		pop r11
 1034 020e AF90      		pop r10
 1035 0210 9F90      		pop r9
 1036 0212 8F90      		pop r8
 1037 0214 7F90      		pop r7
 1038 0216 6F90      		pop r6
 1039 0218 5F90      		pop r5
 1040 021a 4F90      		pop r4
 1041 021c 3F90      		pop r3
 1042 021e 2F90      		pop r2
 1043 0220 0895      		ret
 1045               	.Lscope7:
 1047               		.stabd	78,0,0
 1051               	setIpGwFunction:
 1052               		.stabd	46,0,0
 467:vty.c         **** {
 1054               	.LM65:
 1055               	.LFBB8:
 1056 0222 6F92      		push r6
 1057 0224 7F92      		push r7
 1058 0226 8F92      		push r8
 1059 0228 9F92      		push r9
 1060 022a AF92      		push r10
 1061 022c BF92      		push r11
 1062 022e CF92      		push r12
 1063 0230 DF92      		push r13
 1064 0232 EF92      		push r14
 1065 0234 FF92      		push r15
 1066 0236 0F93      		push r16
 1067 0238 1F93      		push r17
 1068 023a CF93      		push r28
 1069 023c DF93      		push r29
 1070               	/* prologue: function */
 1071               	/* frame size = 0 */
 1072               	/* stack size = 14 */
 1073               	.L__stack_usage = 14
 1074 023e EC01      		movw r28,r24
 468:vty.c         ****   if (state->argc < 4)
 1076               	.LM66:
 1077 0240 898D      		ldd r24,Y+25
 1078 0242 8430      		cpi r24,lo8(4)
 1079 0244 00F0      		brlo .L22
 471:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) + 
 1081               	.LM67:
 1082 0246 81E0      		ldi r24,lo8(1)
 1083 0248 BE01      		movw r22,r28
 1084 024a 0E94 0000 		call cmdlineGetArgInt
 1085 024e 3B01      		movw r6,r22
 1086 0250 4C01      		movw r8,r24
 472:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 1088               	.LM68:
 1089 0252 82E0      		ldi r24,lo8(2)
 1090 0254 BE01      		movw r22,r28
 1091 0256 0E94 0000 		call cmdlineGetArgInt
 1092 025a 7B01      		movw r14,r22
 1093 025c 8C01      		movw r16,r24
 473:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 1095               	.LM69:
 1096 025e 83E0      		ldi r24,lo8(3)
 1097 0260 BE01      		movw r22,r28
 1098 0262 0E94 0000 		call cmdlineGetArgInt
 1099 0266 5B01      		movw r10,r22
 1100 0268 6C01      		movw r12,r24
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 1102               	.LM70:
 1103 026a 84E0      		ldi r24,lo8(4)
 1104 026c BE01      		movw r22,r28
 1105 026e 0E94 0000 		call cmdlineGetArgInt
 1106 0272 DC01      		movw r26,r24
 1107 0274 CB01      		movw r24,r22
 472:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 1109               	.LM71:
 1110 0276 102F      		mov r17,r16
 1111 0278 0F2D      		mov r16,r15
 1112 027a FE2C      		mov r15,r14
 1113 027c EE24      		clr r14
 473:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 1115               	.LM72:
 1116 027e 6501      		movw r12,r10
 1117 0280 BB24      		clr r11
 1118 0282 AA24      		clr r10
 471:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) + 
 1120               	.LM73:
 1121 0284 EA0C      		add r14,r10
 1122 0286 FB1C      		adc r15,r11
 1123 0288 0C1D      		adc r16,r12
 1124 028a 1D1D      		adc r17,r13
 472:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 1126               	.LM74:
 1127 028c E60C      		add r14,r6
 1128 028e F71C      		adc r15,r7
 1129 0290 081D      		adc r16,r8
 1130 0292 191D      		adc r17,r9
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 1132               	.LM75:
 1133 0294 B82F      		mov r27,r24
 1134 0296 AA27      		clr r26
 1135 0298 9927      		clr r25
 1136 029a 8827      		clr r24
 471:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) + 
 1138               	.LM76:
 1139 029c E80E      		add r14,r24
 1140 029e F91E      		adc r15,r25
 1141 02a0 0A1F      		adc r16,r26
 1142 02a2 1B1F      		adc r17,r27
 475:vty.c         ****   ipSetConfigGw(gw);
 1144               	.LM77:
 1145 02a4 C801      		movw r24,r16
 1146 02a6 B701      		movw r22,r14
 1147 02a8 0E94 0000 		call ipSetConfigGw
 476:vty.c         ****   return OK_SILENT;
 1149               	.LM78:
 1150 02ac 20E0      		ldi r18,lo8(0)
 1151 02ae 30E0      		ldi r19,hi8(0)
 1152 02b0 00C0      		rjmp .L21
 1153               	.L22:
 469:vty.c         ****     return SYNTAX_ERROR;
 1155               	.LM79:
 1156 02b2 22E0      		ldi r18,lo8(2)
 1157 02b4 30E0      		ldi r19,hi8(2)
 1158               	.L21:
 477:vty.c         **** }
 1160               	.LM80:
 1161 02b6 C901      		movw r24,r18
 1162               	/* epilogue start */
 1163 02b8 DF91      		pop r29
 1164 02ba CF91      		pop r28
 1165 02bc 1F91      		pop r17
 1166 02be 0F91      		pop r16
 1167 02c0 FF90      		pop r15
 1168 02c2 EF90      		pop r14
 1169 02c4 DF90      		pop r13
 1170 02c6 CF90      		pop r12
 1171 02c8 BF90      		pop r11
 1172 02ca AF90      		pop r10
 1173 02cc 9F90      		pop r9
 1174 02ce 8F90      		pop r8
 1175 02d0 7F90      		pop r7
 1176 02d2 6F90      		pop r6
 1177 02d4 0895      		ret
 1179               	.Lscope8:
 1181               		.stabd	78,0,0
 1185               	setIpMaskFunction:
 1186               		.stabd	46,0,0
 455:vty.c         **** {
 1188               	.LM81:
 1189               	.LFBB9:
 1190               	/* prologue: function */
 1191               	/* frame size = 0 */
 1192               	/* stack size = 0 */
 1193               	.L__stack_usage = 0
 1194 02d6 BC01      		movw r22,r24
 456:vty.c         ****   if (state->argc < 1)
 1196               	.LM82:
 1197 02d8 FC01      		movw r30,r24
 1198 02da 818D      		ldd r24,Z+25
 1199 02dc 8823      		tst r24
 1200 02de 01F0      		breq .L25
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 1202               	.LM83:
 1203 02e0 81E0      		ldi r24,lo8(1)
 1204 02e2 0E94 0000 		call cmdlineGetArgInt
 1205 02e6 20E2      		ldi r18,lo8(32)
 1206 02e8 30E0      		ldi r19,hi8(32)
 1207 02ea 261B      		sub r18,r22
 1208 02ec 370B      		sbc r19,r23
 1209 02ee 6FEF      		ldi r22,lo8(-1)
 1210 02f0 7FEF      		ldi r23,hi8(-1)
 1211 02f2 CB01      		movw r24,r22
 1212 02f4 00C0      		rjmp 2f
 1213 02f6 9695      	1:	lsr r25
 1214 02f8 8795      		ror r24
 1215 02fa 7795      		ror r23
 1216 02fc 6795      		ror r22
 1217 02fe 2A95      	2:	dec r18
 1218 0300 02F4      		brpl 1b
 461:vty.c         ****   ipSetConfigMask(mask);
 1220               	.LM84:
 1221 0302 0E94 0000 		call ipSetConfigMask
 462:vty.c         ****   return OK_SILENT;
 1223               	.LM85:
 1224 0306 20E0      		ldi r18,lo8(0)
 1225 0308 30E0      		ldi r19,hi8(0)
 1226 030a 00C0      		rjmp .L24
 1227               	.L25:
 457:vty.c         ****     return SYNTAX_ERROR;
 1229               	.LM86:
 1230 030c 22E0      		ldi r18,lo8(2)
 1231 030e 30E0      		ldi r19,hi8(2)
 1232               	.L24:
 463:vty.c         **** }
 1234               	.LM87:
 1235 0310 C901      		movw r24,r18
 1236               	/* epilogue start */
 1237 0312 0895      		ret
 1239               	.Lscope9:
 1241               		.stabd	78,0,0
 1245               	setIpFunction:
 1246               		.stabd	46,0,0
 418:vty.c         **** {
 1248               	.LM88:
 1249               	.LFBB10:
 1250 0314 6F92      		push r6
 1251 0316 7F92      		push r7
 1252 0318 8F92      		push r8
 1253 031a 9F92      		push r9
 1254 031c AF92      		push r10
 1255 031e BF92      		push r11
 1256 0320 CF92      		push r12
 1257 0322 DF92      		push r13
 1258 0324 EF92      		push r14
 1259 0326 FF92      		push r15
 1260 0328 0F93      		push r16
 1261 032a 1F93      		push r17
 1262 032c CF93      		push r28
 1263 032e DF93      		push r29
 1264               	/* prologue: function */
 1265               	/* frame size = 0 */
 1266               	/* stack size = 14 */
 1267               	.L__stack_usage = 14
 1268 0330 EC01      		movw r28,r24
 419:vty.c         ****   if (state->argc < 4)
 1270               	.LM89:
 1271 0332 898D      		ldd r24,Y+25
 1272 0334 8430      		cpi r24,lo8(4)
 1273 0336 00F0      		brlo .L28
 422:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 1275               	.LM90:
 1276 0338 81E0      		ldi r24,lo8(1)
 1277 033a BE01      		movw r22,r28
 1278 033c 0E94 0000 		call cmdlineGetArgInt
 1279 0340 3B01      		movw r6,r22
 1280 0342 4C01      		movw r8,r24
 423:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 1282               	.LM91:
 1283 0344 82E0      		ldi r24,lo8(2)
 1284 0346 BE01      		movw r22,r28
 1285 0348 0E94 0000 		call cmdlineGetArgInt
 1286 034c 7B01      		movw r14,r22
 1287 034e 8C01      		movw r16,r24
 424:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 1289               	.LM92:
 1290 0350 83E0      		ldi r24,lo8(3)
 1291 0352 BE01      		movw r22,r28
 1292 0354 0E94 0000 		call cmdlineGetArgInt
 1293 0358 5B01      		movw r10,r22
 1294 035a 6C01      		movw r12,r24
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 1296               	.LM93:
 1297 035c 84E0      		ldi r24,lo8(4)
 1298 035e BE01      		movw r22,r28
 1299 0360 0E94 0000 		call cmdlineGetArgInt
 1300 0364 DC01      		movw r26,r24
 1301 0366 CB01      		movw r24,r22
 423:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 1303               	.LM94:
 1304 0368 102F      		mov r17,r16
 1305 036a 0F2D      		mov r16,r15
 1306 036c FE2C      		mov r15,r14
 1307 036e EE24      		clr r14
 424:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 1309               	.LM95:
 1310 0370 6501      		movw r12,r10
 1311 0372 BB24      		clr r11
 1312 0374 AA24      		clr r10
 422:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 1314               	.LM96:
 1315 0376 EA0C      		add r14,r10
 1316 0378 FB1C      		adc r15,r11
 1317 037a 0C1D      		adc r16,r12
 1318 037c 1D1D      		adc r17,r13
 423:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 1320               	.LM97:
 1321 037e E60C      		add r14,r6
 1322 0380 F71C      		adc r15,r7
 1323 0382 081D      		adc r16,r8
 1324 0384 191D      		adc r17,r9
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 1326               	.LM98:
 1327 0386 B82F      		mov r27,r24
 1328 0388 AA27      		clr r26
 1329 038a 9927      		clr r25
 1330 038c 8827      		clr r24
 422:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 1332               	.LM99:
 1333 038e E80E      		add r14,r24
 1334 0390 F91E      		adc r15,r25
 1335 0392 0A1F      		adc r16,r26
 1336 0394 1B1F      		adc r17,r27
 427:vty.c         ****   ipSetConfigIp(ip);
 1338               	.LM100:
 1339 0396 C801      		movw r24,r16
 1340 0398 B701      		movw r22,r14
 1341 039a 0E94 0000 		call ipSetConfigIp
 428:vty.c         ****   return OK_SILENT;
 1343               	.LM101:
 1344 039e 20E0      		ldi r18,lo8(0)
 1345 03a0 30E0      		ldi r19,hi8(0)
 1346 03a2 00C0      		rjmp .L27
 1347               	.L28:
 420:vty.c         ****     return SYNTAX_ERROR;
 1349               	.LM102:
 1350 03a4 22E0      		ldi r18,lo8(2)
 1351 03a6 30E0      		ldi r19,hi8(2)
 1352               	.L27:
 429:vty.c         **** }
 1354               	.LM103:
 1355 03a8 C901      		movw r24,r18
 1356               	/* epilogue start */
 1357 03aa DF91      		pop r29
 1358 03ac CF91      		pop r28
 1359 03ae 1F91      		pop r17
 1360 03b0 0F91      		pop r16
 1361 03b2 FF90      		pop r15
 1362 03b4 EF90      		pop r14
 1363 03b6 DF90      		pop r13
 1364 03b8 CF90      		pop r12
 1365 03ba BF90      		pop r11
 1366 03bc AF90      		pop r10
 1367 03be 9F90      		pop r9
 1368 03c0 8F90      		pop r8
 1369 03c2 7F90      		pop r7
 1370 03c4 6F90      		pop r6
 1371 03c6 0895      		ret
 1373               	.Lscope10:
 1375               		.stabd	78,0,0
 1379               	czytajAC_Function:
 1380               		.stabd	46,0,0
 495:vty.c         **** {
 1382               	.LM104:
 1383               	.LFBB11:
 1384 03c8 0F93      		push r16
 1385 03ca 1F93      		push r17
 1386 03cc DF93      		push r29
 1387 03ce CF93      		push r28
 1388 03d0 0F92      		push __tmp_reg__
 1389 03d2 CDB7      		in r28,__SP_L__
 1390 03d4 DEB7      		in r29,__SP_H__
 1391               	/* prologue: function */
 1392               	/* frame size = 1 */
 1393               	/* stack size = 5 */
 1394               	.L__stack_usage = 5
 1395 03d6 8C01      		movw r16,r24
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 1397               	.LM105:
 1398 03d8 81E0      		ldi r24,lo8(1)
 1399 03da B801      		movw r22,r16
 1400 03dc 0E94 0000 		call cmdlineGetArgInt
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 1402               	.LM106:
 1403 03e0 862F      		mov r24,r22
 1404 03e2 6983      		std Y+1,r22
 1405 03e4 0E94 0000 		call MCP3008_getSampleSingle
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 1407               	.LM107:
 1408 03e8 2DB7      		in r18,__SP_L__
 1409 03ea 3EB7      		in r19,__SP_H__
 1410 03ec 2850      		subi r18,lo8(-(-8))
 1411 03ee 3040      		sbci r19,hi8(-(-8))
 1412 03f0 2DBF      		out __SP_L__,r18
 1413 03f2 3EBF      		out __SP_H__,r19
 1414 03f4 EDB7      		in r30,__SP_L__
 1415 03f6 FEB7      		in r31,__SP_H__
 1416 03f8 3196      		adiw r30,1
 1417 03fa D801      		movw r26,r16
 1418 03fc 5A96      		adiw r26,26
 1419 03fe 2D91      		ld r18,X+
 1420 0400 3C91      		ld r19,X
 1421 0402 5B97      		sbiw r26,26+1
 1422 0404 ADB7      		in r26,__SP_L__
 1423 0406 BEB7      		in r27,__SP_H__
 1424 0408 1196      		adiw r26,1
 1425 040a 2D93      		st X+,r18
 1426 040c 3C93      		st X,r19
 1427 040e 1297      		sbiw r26,1+1
 1428 0410 20E0      		ldi r18,lo8(__c.5194)
 1429 0412 30E0      		ldi r19,hi8(__c.5194)
 1430 0414 2283      		std Z+2,r18
 1431 0416 3383      		std Z+3,r19
 1432 0418 6981      		ldd r22,Y+1
 1433 041a 6483      		std Z+4,r22
 1434 041c 1582      		std Z+5,__zero_reg__
 1435 041e 8683      		std Z+6,r24
 1436 0420 9783      		std Z+7,r25
 1437 0422 0E94 0000 		call fprintf_P
 1438 0426 EDB7      		in r30,__SP_L__
 1439 0428 FEB7      		in r31,__SP_H__
 1440 042a 3896      		adiw r30,8
 1441 042c EDBF      		out __SP_L__,r30
 1442 042e FEBF      		out __SP_H__,r31
 500:vty.c         **** }
 1444               	.LM108:
 1445 0430 80E0      		ldi r24,lo8(0)
 1446 0432 90E0      		ldi r25,hi8(0)
 1447               	/* epilogue start */
 1448 0434 0F90      		pop __tmp_reg__
 1449 0436 CF91      		pop r28
 1450 0438 DF91      		pop r29
 1451 043a 1F91      		pop r17
 1452 043c 0F91      		pop r16
 1453 043e 0895      		ret
 1455               	.Lscope11:
 1457               		.stabd	78,0,0
 1461               	setTimeFunction:
 1462               		.stabd	46,0,0
 391:vty.c         **** {
 1464               	.LM109:
 1465               	.LFBB12:
 1466 0440 FF92      		push r15
 1467 0442 0F93      		push r16
 1468 0444 1F93      		push r17
 1469 0446 CF93      		push r28
 1470 0448 DF93      		push r29
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 5 */
 1474               	.L__stack_usage = 5
 1475 044a EC01      		movw r28,r24
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 1477               	.LM110:
 1478 044c 81E0      		ldi r24,lo8(1)
 1479 044e BE01      		movw r22,r28
 1480 0450 0E94 0000 		call cmdlineGetArgInt
 1481 0454 F62E      		mov r15,r22
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 1483               	.LM111:
 1484 0456 82E0      		ldi r24,lo8(2)
 1485 0458 BE01      		movw r22,r28
 1486 045a 0E94 0000 		call cmdlineGetArgInt
 1487 045e 062F      		mov r16,r22
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 1489               	.LM112:
 1490 0460 83E0      		ldi r24,lo8(3)
 1491 0462 BE01      		movw r22,r28
 1492 0464 0E94 0000 		call cmdlineGetArgInt
 1493 0468 162F      		mov r17,r22
 396:vty.c         ****   ds1305start();
 1495               	.LM113:
 1496 046a 0E94 0000 		call ds1305start
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 1498               	.LM114:
 1499 046e 5AE0      		ldi r21,lo8(10)
 1500 0470 8F2D      		mov r24,r15
 1501 0472 652F      		mov r22,r21
 1502 0474 0E94 0000 		call __udivmodqi4
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 1504               	.LM115:
 1505 0478 482F      		mov r20,r24
 1506 047a 4370      		andi r20,lo8(3)
 1507 047c 20E0      		ldi r18,lo8(czasRtc+2)
 1508 047e 30E0      		ldi r19,hi8(czasRtc+2)
 1509 0480 4295      		swap r20
 1510 0482 407F      		andi r20,lo8(-16)
 1511 0484 9091 0000 		lds r25,czasRtc+2
 1512 0488 9F7C      		andi r25,lo8(-49)
 1513 048a 942B      		or r25,r20
 1514 048c 9093 0000 		sts czasRtc+2,r25
 399:vty.c         ****   uint8_t cJedn = godzina - cDzies*10;
 1516               	.LM116:
 1517 0490 46EF      		ldi r20,lo8(-10)
 1518 0492 849F      		mul r24,r20
 1519 0494 802D      		mov r24,r0
 1520 0496 1124      		clr r1
 1521 0498 8F0D      		add r24,r15
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 1523               	.LM117:
 1524 049a 8F70      		andi r24,lo8(15)
 1525 049c 9091 0000 		lds r25,czasRtc+2
 1526 04a0 907F      		andi r25,lo8(-16)
 1527 04a2 982B      		or r25,r24
 1528 04a4 9093 0000 		sts czasRtc+2,r25
 403:vty.c         ****   cDzies = minuta/10;
 1530               	.LM118:
 1531 04a8 802F      		mov r24,r16
 1532 04aa 0E94 0000 		call __udivmodqi4
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 1534               	.LM119:
 1535 04ae 682F      		mov r22,r24
 1536 04b0 6770      		andi r22,lo8(7)
 1537 04b2 F901      		movw r30,r18
 1538 04b4 6295      		swap r22
 1539 04b6 607F      		andi r22,lo8(-16)
 1540 04b8 9291      		ld r25,-Z
 1541 04ba 9F78      		andi r25,lo8(-113)
 1542 04bc 962B      		or r25,r22
 1543 04be 9083      		st Z,r25
 404:vty.c         ****   cJedn = minuta - cDzies * 10;
 1545               	.LM120:
 1546 04c0 849F      		mul r24,r20
 1547 04c2 802D      		mov r24,r0
 1548 04c4 1124      		clr r1
 1549 04c6 800F      		add r24,r16
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 1551               	.LM121:
 1552 04c8 8F70      		andi r24,lo8(15)
 1553 04ca 9081      		ld r25,Z
 1554 04cc 907F      		andi r25,lo8(-16)
 1555 04ce 982B      		or r25,r24
 1556 04d0 9083      		st Z,r25
 408:vty.c         ****   cDzies = sekunda/10;
 1558               	.LM122:
 1559 04d2 812F      		mov r24,r17
 1560 04d4 652F      		mov r22,r21
 1561 04d6 0E94 0000 		call __udivmodqi4
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 1563               	.LM123:
 1564 04da 582F      		mov r21,r24
 1565 04dc 5770      		andi r21,lo8(7)
 1566 04de F901      		movw r30,r18
 1567 04e0 3297      		sbiw r30,2
 1568 04e2 5295      		swap r21
 1569 04e4 507F      		andi r21,lo8(-16)
 1570 04e6 9081      		ld r25,Z
 1571 04e8 9F78      		andi r25,lo8(-113)
 1572 04ea 952B      		or r25,r21
 1573 04ec 9083      		st Z,r25
 409:vty.c         ****   cJedn  = sekunda - cDzies * 10;
 1575               	.LM124:
 1576 04ee 849F      		mul r24,r20
 1577 04f0 402D      		mov r20,r0
 1578 04f2 1124      		clr r1
 1579 04f4 410F      		add r20,r17
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 1581               	.LM125:
 1582 04f6 4F70      		andi r20,lo8(15)
 1583 04f8 9081      		ld r25,Z
 1584 04fa 907F      		andi r25,lo8(-16)
 1585 04fc 942B      		or r25,r20
 1586 04fe 9083      		st Z,r25
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 1588               	.LM126:
 1589 0500 CF01      		movw r24,r30
 1590 0502 0E94 0000 		call setTimeDecoded
 415:vty.c         **** }
 1592               	.LM127:
 1593 0506 80E0      		ldi r24,lo8(0)
 1594 0508 90E0      		ldi r25,hi8(0)
 1595               	/* epilogue start */
 1596 050a DF91      		pop r29
 1597 050c CF91      		pop r28
 1598 050e 1F91      		pop r17
 1599 0510 0F91      		pop r16
 1600 0512 FF90      		pop r15
 1601 0514 0895      		ret
 1603               	.Lscope12:
 1605               		.stabd	78,0,0
 1609               	ustawPortRezystor:
 1610               		.stabd	46,0,0
 572:vty.c         **** {
 1612               	.LM128:
 1613               	.LFBB13:
 1614               	/* prologue: function */
 1615               	/* frame size = 0 */
 1616               	/* stack size = 0 */
 1617               	.L__stack_usage = 0
 1618 0516 BC01      		movw r22,r24
 573:vty.c         ****   if (state->argc < 1)
 1620               	.LM129:
 1621 0518 FC01      		movw r30,r24
 1622 051a 818D      		ldd r24,Z+25
 1623 051c 8823      		tst r24
 1624 051e 01F0      		breq .L33
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 1626               	.LM130:
 1627 0520 81E0      		ldi r24,lo8(1)
 1628 0522 0E94 0000 		call cmdlineGetArgInt
 1629 0526 862F      		mov r24,r22
 578:vty.c         ****   MCP4150_setValue(wartosc);
 1631               	.LM131:
 1632 0528 0E94 0000 		call MCP4150_setValue
 580:vty.c         ****   return OK_SILENT;
 1634               	.LM132:
 1635 052c 20E0      		ldi r18,lo8(0)
 1636 052e 30E0      		ldi r19,hi8(0)
 1637 0530 00C0      		rjmp .L32
 1638               	.L33:
 574:vty.c         ****     return SYNTAX_ERROR;
 1640               	.LM133:
 1641 0532 22E0      		ldi r18,lo8(2)
 1642 0534 30E0      		ldi r19,hi8(2)
 1643               	.L32:
 581:vty.c         **** }
 1645               	.LM134:
 1646 0536 C901      		movw r24,r18
 1647               	/* epilogue start */
 1648 0538 0895      		ret
 1650               	.Lscope13:
 1652               		.stabd	78,0,0
 1656               	ustawPortExtBFunction:
 1657               		.stabd	46,0,0
 564:vty.c         **** {
 1659               	.LM135:
 1660               	.LFBB14:
 1661 053a 1F93      		push r17
 1662               	/* prologue: function */
 1663               	/* frame size = 0 */
 1664               	/* stack size = 1 */
 1665               	.L__stack_usage = 1
 1666 053c BC01      		movw r22,r24
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1668               	.LM136:
 1669 053e 81E0      		ldi r24,lo8(1)
 1670 0540 0E94 0000 		call cmdlineGetArgInt
 1671 0544 162F      		mov r17,r22
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 1673               	.LM137:
 1674 0546 80E0      		ldi r24,lo8(0)
 1675 0548 60E0      		ldi r22,lo8(0)
 1676 054a 0E94 0000 		call MPC23s17SetDirB
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 1678               	.LM138:
 1679 054e 812F      		mov r24,r17
 1680 0550 60E0      		ldi r22,lo8(0)
 1681 0552 0E94 0000 		call MPC23s17SetPortB
 569:vty.c         **** }
 1683               	.LM139:
 1684 0556 80E0      		ldi r24,lo8(0)
 1685 0558 90E0      		ldi r25,hi8(0)
 1686               	/* epilogue start */
 1687 055a 1F91      		pop r17
 1688 055c 0895      		ret
 1690               	.Lscope14:
 1692               		.stabd	78,0,0
 1696               	ustawPortExtAFunction:
 1697               		.stabd	46,0,0
 556:vty.c         **** {
 1699               	.LM140:
 1700               	.LFBB15:
 1701 055e 1F93      		push r17
 1702               	/* prologue: function */
 1703               	/* frame size = 0 */
 1704               	/* stack size = 1 */
 1705               	.L__stack_usage = 1
 1706 0560 BC01      		movw r22,r24
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1708               	.LM141:
 1709 0562 81E0      		ldi r24,lo8(1)
 1710 0564 0E94 0000 		call cmdlineGetArgInt
 1711 0568 162F      		mov r17,r22
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 1713               	.LM142:
 1714 056a 80E0      		ldi r24,lo8(0)
 1715 056c 60E0      		ldi r22,lo8(0)
 1716 056e 0E94 0000 		call MPC23s17SetDirA
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 1718               	.LM143:
 1719 0572 812F      		mov r24,r17
 1720 0574 60E0      		ldi r22,lo8(0)
 1721 0576 0E94 0000 		call MPC23s17SetPortA
 561:vty.c         **** }
 1723               	.LM144:
 1724 057a 80E0      		ldi r24,lo8(0)
 1725 057c 90E0      		ldi r25,hi8(0)
 1726               	/* epilogue start */
 1727 057e 1F91      		pop r17
 1728 0580 0895      		ret
 1730               	.Lscope15:
 1732               		.stabd	78,0,0
 1736               	curtainDownFunction:
 1737               		.stabd	46,0,0
 509:vty.c         **** {
 1739               	.LM145:
 1740               	.LFBB16:
 1741 0582 FF92      		push r15
 1742 0584 0F93      		push r16
 1743 0586 1F93      		push r17
 1744 0588 CF93      		push r28
 1745 058a DF93      		push r29
 1746               	/* prologue: function */
 1747               	/* frame size = 0 */
 1748               	/* stack size = 5 */
 1749               	.L__stack_usage = 5
 1750 058c EC01      		movw r28,r24
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 1752               	.LM146:
 1753 058e 81E0      		ldi r24,lo8(1)
 1754 0590 BE01      		movw r22,r28
 1755 0592 0E94 0000 		call cmdlineGetArgInt
 1756 0596 062F      		mov r16,r22
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 1758               	.LM147:
 1759 0598 82E0      		ldi r24,lo8(2)
 1760 059a BE01      		movw r22,r28
 1761 059c 0E94 0000 		call cmdlineGetArgInt
 1762 05a0 162F      		mov r17,r22
 516:vty.c         ****   nrRolety &= 0x01;
 1764               	.LM148:
 1765 05a2 1170      		andi r17,lo8(1)
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 1767               	.LM149:
 1768 05a4 83E0      		ldi r24,lo8(3)
 1769 05a6 BE01      		movw r22,r28
 1770 05a8 0E94 0000 		call cmdlineGetArgInt
 1771 05ac F62E      		mov r15,r22
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 1773               	.LM150:
 1774 05ae 2DB7      		in r18,__SP_L__
 1775 05b0 3EB7      		in r19,__SP_H__
 1776 05b2 2850      		subi r18,lo8(-(-8))
 1777 05b4 3040      		sbci r19,hi8(-(-8))
 1778 05b6 2DBF      		out __SP_L__,r18
 1779 05b8 3EBF      		out __SP_H__,r19
 1780 05ba EDB7      		in r30,__SP_L__
 1781 05bc FEB7      		in r31,__SP_H__
 1782 05be 3196      		adiw r30,1
 1783 05c0 8A8D      		ldd r24,Y+26
 1784 05c2 9B8D      		ldd r25,Y+27
 1785 05c4 ADB7      		in r26,__SP_L__
 1786 05c6 BEB7      		in r27,__SP_H__
 1787 05c8 1196      		adiw r26,1
 1788 05ca 8D93      		st X+,r24
 1789 05cc 9C93      		st X,r25
 1790 05ce 1297      		sbiw r26,1+1
 1791 05d0 80E0      		ldi r24,lo8(movingCurtainDownStr)
 1792 05d2 90E0      		ldi r25,hi8(movingCurtainDownStr)
 1793 05d4 8283      		std Z+2,r24
 1794 05d6 9383      		std Z+3,r25
 1795 05d8 0483      		std Z+4,r16
 1796 05da 1582      		std Z+5,__zero_reg__
 1797 05dc 212F      		mov r18,r17
 1798 05de 30E0      		ldi r19,lo8(0)
 1799 05e0 2F5F      		subi r18,lo8(-(1))
 1800 05e2 3F4F      		sbci r19,hi8(-(1))
 1801 05e4 2683      		std Z+6,r18
 1802 05e6 3783      		std Z+7,r19
 1803 05e8 0E94 0000 		call fprintf_P
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1805               	.LM151:
 1806 05ec 8F2D      		mov r24,r15
 1807 05ee 8150      		subi r24,lo8(-(-1))
 1808 05f0 2DB7      		in r18,__SP_L__
 1809 05f2 3EB7      		in r19,__SP_H__
 1810 05f4 285F      		subi r18,lo8(-(8))
 1811 05f6 3F4F      		sbci r19,hi8(-(8))
 1812 05f8 2DBF      		out __SP_L__,r18
 1813 05fa 3EBF      		out __SP_H__,r19
 1814 05fc 8436      		cpi r24,lo8(100)
 1815 05fe 00F4      		brsh .L37
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1817               	.LM152:
 1818 0600 00D0      		rcall .
 1819 0602 00D0      		rcall .
 1820 0604 EDB7      		in r30,__SP_L__
 1821 0606 FEB7      		in r31,__SP_H__
 1822 0608 3196      		adiw r30,1
 1823 060a 8A8D      		ldd r24,Y+26
 1824 060c 9B8D      		ldd r25,Y+27
 1825 060e ADB7      		in r26,__SP_L__
 1826 0610 BEB7      		in r27,__SP_H__
 1827 0612 1196      		adiw r26,1
 1828 0614 8D93      		st X+,r24
 1829 0616 9C93      		st X,r25
 1830 0618 1297      		sbiw r26,1+1
 1831 061a 20E0      		ldi r18,lo8(movingCurtainPosStr)
 1832 061c 30E0      		ldi r19,hi8(movingCurtainPosStr)
 1833 061e 2283      		std Z+2,r18
 1834 0620 3383      		std Z+3,r19
 1835 0622 F482      		std Z+4,r15
 1836 0624 1582      		std Z+5,__zero_reg__
 1837 0626 0E94 0000 		call fprintf_P
 1838 062a 2DB7      		in r18,__SP_L__
 1839 062c 3EB7      		in r19,__SP_H__
 1840 062e 2A5F      		subi r18,lo8(-(6))
 1841 0630 3F4F      		sbci r19,hi8(-(6))
 1842 0632 2DBF      		out __SP_L__,r18
 1843 0634 3EBF      		out __SP_H__,r19
 1844               	.L37:
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 1846               	.LM153:
 1847 0636 802F      		mov r24,r16
 1848 0638 612F      		mov r22,r17
 1849 063a 4F2D      		mov r20,r15
 1850 063c 0E94 0000 		call rs485curtainDown
 526:vty.c         ****   if (result == 0)
 1852               	.LM154:
 1853 0640 8823      		tst r24
 1854 0642 01F4      		brne .L39
 527:vty.c         ****     return OK_INFORM;
 1856               	.LM155:
 1857 0644 21E0      		ldi r18,lo8(1)
 1858 0646 30E0      		ldi r19,hi8(1)
 1859 0648 00C0      		rjmp .L38
 1860               	.L39:
 529:vty.c         ****   return ERROR_SILENT;
 1862               	.LM156:
 1863 064a 23E0      		ldi r18,lo8(3)
 1864 064c 30E0      		ldi r19,hi8(3)
 1865               	.L38:
 530:vty.c         **** }
 1867               	.LM157:
 1868 064e C901      		movw r24,r18
 1869               	/* epilogue start */
 1870 0650 DF91      		pop r29
 1871 0652 CF91      		pop r28
 1872 0654 1F91      		pop r17
 1873 0656 0F91      		pop r16
 1874 0658 FF90      		pop r15
 1875 065a 0895      		ret
 1881               	.Lscope16:
 1883               		.stabd	78,0,0
 1887               	curtainUpFunction:
 1888               		.stabd	46,0,0
 533:vty.c         **** {
 1890               	.LM158:
 1891               	.LFBB17:
 1892 065c FF92      		push r15
 1893 065e 0F93      		push r16
 1894 0660 1F93      		push r17
 1895 0662 CF93      		push r28
 1896 0664 DF93      		push r29
 1897               	/* prologue: function */
 1898               	/* frame size = 0 */
 1899               	/* stack size = 5 */
 1900               	.L__stack_usage = 5
 1901 0666 EC01      		movw r28,r24
 534:vty.c         ****   if (state->argc < 2)
 1903               	.LM159:
 1904 0668 898D      		ldd r24,Y+25
 1905 066a 8230      		cpi r24,lo8(2)
 1906 066c 00F4      		brsh .+2
 1907 066e 00C0      		rjmp .L44
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 1909               	.LM160:
 1910 0670 81E0      		ldi r24,lo8(1)
 1911 0672 BE01      		movw r22,r28
 1912 0674 0E94 0000 		call cmdlineGetArgInt
 1913 0678 062F      		mov r16,r22
 1914 067a 0F73      		andi r16,lo8(63)
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 1916               	.LM161:
 1917 067c 82E0      		ldi r24,lo8(2)
 1918 067e BE01      		movw r22,r28
 1919 0680 0E94 0000 		call cmdlineGetArgInt
 1920 0684 162F      		mov r17,r22
 1921 0686 1170      		andi r17,lo8(1)
 540:vty.c         ****   if (state->argc > 2)
 1923               	.LM162:
 1924 0688 898D      		ldd r24,Y+25
 1925 068a 8330      		cpi r24,lo8(3)
 1926 068c 00F0      		brlo .L45
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 1928               	.LM163:
 1929 068e 83E0      		ldi r24,lo8(3)
 1930 0690 BE01      		movw r22,r28
 1931 0692 0E94 0000 		call cmdlineGetArgInt
 1932 0696 F62E      		mov r15,r22
 1933 0698 00C0      		rjmp .L42
 1934               	.L45:
 539:vty.c         ****   uint8_t wartosc = 255;
 1936               	.LM164:
 1937 069a FF24      		clr r15
 1938 069c FA94      		dec r15
 1939               	.L42:
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 1941               	.LM165:
 1942 069e 2DB7      		in r18,__SP_L__
 1943 06a0 3EB7      		in r19,__SP_H__
 1944 06a2 2850      		subi r18,lo8(-(-8))
 1945 06a4 3040      		sbci r19,hi8(-(-8))
 1946 06a6 2DBF      		out __SP_L__,r18
 1947 06a8 3EBF      		out __SP_H__,r19
 1948 06aa EDB7      		in r30,__SP_L__
 1949 06ac FEB7      		in r31,__SP_H__
 1950 06ae 3196      		adiw r30,1
 1951 06b0 8A8D      		ldd r24,Y+26
 1952 06b2 9B8D      		ldd r25,Y+27
 1953 06b4 ADB7      		in r26,__SP_L__
 1954 06b6 BEB7      		in r27,__SP_H__
 1955 06b8 1196      		adiw r26,1
 1956 06ba 8D93      		st X+,r24
 1957 06bc 9C93      		st X,r25
 1958 06be 1297      		sbiw r26,1+1
 1959 06c0 80E0      		ldi r24,lo8(movingCurtainUpStr)
 1960 06c2 90E0      		ldi r25,hi8(movingCurtainUpStr)
 1961 06c4 8283      		std Z+2,r24
 1962 06c6 9383      		std Z+3,r25
 1963 06c8 0483      		std Z+4,r16
 1964 06ca 1582      		std Z+5,__zero_reg__
 1965 06cc 212F      		mov r18,r17
 1966 06ce 30E0      		ldi r19,lo8(0)
 1967 06d0 2F5F      		subi r18,lo8(-(1))
 1968 06d2 3F4F      		sbci r19,hi8(-(1))
 1969 06d4 2683      		std Z+6,r18
 1970 06d6 3783      		std Z+7,r19
 1971 06d8 0E94 0000 		call fprintf_P
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1973               	.LM166:
 1974 06dc 8F2D      		mov r24,r15
 1975 06de 8150      		subi r24,lo8(-(-1))
 1976 06e0 2DB7      		in r18,__SP_L__
 1977 06e2 3EB7      		in r19,__SP_H__
 1978 06e4 285F      		subi r18,lo8(-(8))
 1979 06e6 3F4F      		sbci r19,hi8(-(8))
 1980 06e8 2DBF      		out __SP_L__,r18
 1981 06ea 3EBF      		out __SP_H__,r19
 1982 06ec 8436      		cpi r24,lo8(100)
 1983 06ee 00F4      		brsh .L43
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1985               	.LM167:
 1986 06f0 00D0      		rcall .
 1987 06f2 00D0      		rcall .
 1988 06f4 EDB7      		in r30,__SP_L__
 1989 06f6 FEB7      		in r31,__SP_H__
 1990 06f8 3196      		adiw r30,1
 1991 06fa 8A8D      		ldd r24,Y+26
 1992 06fc 9B8D      		ldd r25,Y+27
 1993 06fe ADB7      		in r26,__SP_L__
 1994 0700 BEB7      		in r27,__SP_H__
 1995 0702 1196      		adiw r26,1
 1996 0704 8D93      		st X+,r24
 1997 0706 9C93      		st X,r25
 1998 0708 1297      		sbiw r26,1+1
 1999 070a 20E0      		ldi r18,lo8(movingCurtainPosStr)
 2000 070c 30E0      		ldi r19,hi8(movingCurtainPosStr)
 2001 070e 2283      		std Z+2,r18
 2002 0710 3383      		std Z+3,r19
 2003 0712 F482      		std Z+4,r15
 2004 0714 1582      		std Z+5,__zero_reg__
 2005 0716 0E94 0000 		call fprintf_P
 2006 071a 2DB7      		in r18,__SP_L__
 2007 071c 3EB7      		in r19,__SP_H__
 2008 071e 2A5F      		subi r18,lo8(-(6))
 2009 0720 3F4F      		sbci r19,hi8(-(6))
 2010 0722 2DBF      		out __SP_L__,r18
 2011 0724 3EBF      		out __SP_H__,r19
 2012               	.L43:
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 2014               	.LM168:
 2015 0726 802F      		mov r24,r16
 2016 0728 612F      		mov r22,r17
 2017 072a 4F2D      		mov r20,r15
 2018 072c 0E94 0000 		call rs485curtainUp
 549:vty.c         ****   if (result == 0)
 2020               	.LM169:
 2021 0730 8823      		tst r24
 2022 0732 01F4      		brne .L46
 550:vty.c         ****     return OK_INFORM;
 2024               	.LM170:
 2025 0734 21E0      		ldi r18,lo8(1)
 2026 0736 30E0      		ldi r19,hi8(1)
 2027 0738 00C0      		rjmp .L41
 2028               	.L44:
 535:vty.c         ****     return SYNTAX_ERROR;
 2030               	.LM171:
 2031 073a 22E0      		ldi r18,lo8(2)
 2032 073c 30E0      		ldi r19,hi8(2)
 2033 073e 00C0      		rjmp .L41
 2034               	.L46:
 552:vty.c         ****   return ERROR_SILENT;
 2036               	.LM172:
 2037 0740 23E0      		ldi r18,lo8(3)
 2038 0742 30E0      		ldi r19,hi8(3)
 2039               	.L41:
 553:vty.c         **** }
 2041               	.LM173:
 2042 0744 C901      		movw r24,r18
 2043               	/* epilogue start */
 2044 0746 DF91      		pop r29
 2045 0748 CF91      		pop r28
 2046 074a 1F91      		pop r17
 2047 074c 0F91      		pop r16
 2048 074e FF90      		pop r15
 2049 0750 0895      		ret
 2056               	.Lscope17:
 2058               		.stabd	78,0,0
 2062               	goXmodemWyslijFunction:
 2063               		.stabd	46,0,0
 650:vty.c         **** {
 2065               	.LM174:
 2066               	.LFBB18:
 2067 0752 0F93      		push r16
 2068 0754 1F93      		push r17
 2069 0756 CF93      		push r28
 2070 0758 DF93      		push r29
 2071               	/* prologue: function */
 2072               	/* frame size = 0 */
 2073               	/* stack size = 4 */
 2074               	.L__stack_usage = 4
 2075 075a EC01      		movw r28,r24
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 2077               	.LM175:
 2078 075c 00D0      		rcall .
 2079 075e 0F92      		push __tmp_reg__
 2080 0760 8A8D      		ldd r24,Y+26
 2081 0762 9B8D      		ldd r25,Y+27
 2082 0764 ADB7      		in r26,__SP_L__
 2083 0766 BEB7      		in r27,__SP_H__
 2084 0768 1196      		adiw r26,1
 2085 076a 8D93      		st X+,r24
 2086 076c 9C93      		st X,r25
 2087 076e 1297      		sbiw r26,1+1
 2088 0770 80E0      		ldi r24,lo8(xwyslijStartStr)
 2089 0772 90E0      		ldi r25,hi8(xwyslijStartStr)
 2090 0774 1396      		adiw r26,3
 2091 0776 8D93      		st X+,r24
 2092 0778 9C93      		st X,r25
 2093 077a 1497      		sbiw r26,3+1
 2094 077c 0E94 0000 		call fprintf_P
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 2096               	.LM176:
 2097 0780 0F90      		pop __tmp_reg__
 2098 0782 0F90      		pop __tmp_reg__
 2099 0784 0F90      		pop __tmp_reg__
 2100 0786 0F90      		pop __tmp_reg__
 2101 0788 81E0      		ldi r24,lo8(1)
 2102 078a BE01      		movw r22,r28
 2103 078c 0E94 0000 		call cmdlineGetArgStr
 2104 0790 60E0      		ldi r22,lo8(fdVty)
 2105 0792 70E0      		ldi r23,hi8(fdVty)
 2106 0794 0E94 0000 		call ramDyskOtworzPlik
 2107 0798 8823      		tst r24
 2108 079a 01F0      		breq .L49
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 2110               	.LM177:
 2111 079c 0A8D      		ldd r16,Y+26
 2112 079e 1B8D      		ldd r17,Y+27
 2113 07a0 81E0      		ldi r24,lo8(1)
 2114 07a2 BE01      		movw r22,r28
 2115 07a4 0E94 0000 		call cmdlineGetArgStr
 2116 07a8 00D0      		rcall .
 2117 07aa 00D0      		rcall .
 2118 07ac EDB7      		in r30,__SP_L__
 2119 07ae FEB7      		in r31,__SP_H__
 2120 07b0 3196      		adiw r30,1
 2121 07b2 ADB7      		in r26,__SP_L__
 2122 07b4 BEB7      		in r27,__SP_H__
 2123 07b6 1196      		adiw r26,1
 2124 07b8 0D93      		st X+,r16
 2125 07ba 1C93      		st X,r17
 2126 07bc 1297      		sbiw r26,1+1
 2127 07be 20E0      		ldi r18,lo8(errorOpenFile)
 2128 07c0 30E0      		ldi r19,hi8(errorOpenFile)
 2129 07c2 2283      		std Z+2,r18
 2130 07c4 3383      		std Z+3,r19
 2131 07c6 8483      		std Z+4,r24
 2132 07c8 9583      		std Z+5,r25
 2133 07ca 0E94 0000 		call fprintf_P
 655:vty.c         ****     return ERROR_INFORM;
 2135               	.LM178:
 2136 07ce EDB7      		in r30,__SP_L__
 2137 07d0 FEB7      		in r31,__SP_H__
 2138 07d2 3696      		adiw r30,6
 2139 07d4 EDBF      		out __SP_L__,r30
 2140 07d6 FEBF      		out __SP_H__,r31
 2141 07d8 24E0      		ldi r18,lo8(4)
 2142 07da 30E0      		ldi r19,hi8(4)
 2143 07dc 00C0      		rjmp .L48
 2144               	.L49:
 657:vty.c         ****   return OK_SILENT;
 2146               	.LM179:
 2147 07de 20E0      		ldi r18,lo8(0)
 2148 07e0 30E0      		ldi r19,hi8(0)
 2149               	.L48:
 658:vty.c         **** }
 2151               	.LM180:
 2152 07e2 C901      		movw r24,r18
 2153               	/* epilogue start */
 2154 07e4 DF91      		pop r29
 2155 07e6 CF91      		pop r28
 2156 07e8 1F91      		pop r17
 2157 07ea 0F91      		pop r16
 2158 07ec 0895      		ret
 2160               	.Lscope18:
 2162               		.stabd	78,0,0
 2166               	editRamFileFunction:
 2167               		.stabd	46,0,0
 877:vty.c         **** {
 2169               	.LM181:
 2170               	.LFBB19:
 2171 07ee EF92      		push r14
 2172 07f0 FF92      		push r15
 2173 07f2 0F93      		push r16
 2174 07f4 1F93      		push r17
 2175 07f6 DF93      		push r29
 2176 07f8 CF93      		push r28
 2177 07fa 0F92      		push __tmp_reg__
 2178 07fc CDB7      		in r28,__SP_L__
 2179 07fe DEB7      		in r29,__SP_H__
 2180               	/* prologue: function */
 2181               	/* frame size = 1 */
 2182               	/* stack size = 7 */
 2183               	.L__stack_usage = 7
 2184 0800 8C01      		movw r16,r24
 878:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 2186               	.LM182:
 2187 0802 81E0      		ldi r24,lo8(1)
 2188 0804 B801      		movw r22,r16
 2189 0806 0E94 0000 		call cmdlineGetArgStr
 2190 080a 60E0      		ldi r22,lo8(fdVty)
 2191 080c 70E0      		ldi r23,hi8(fdVty)
 2192 080e 0E94 0000 		call ramDyskOtworzPlik
 2193 0812 8823      		tst r24
 2194 0814 01F0      		breq .L51
 880:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 2196               	.LM183:
 2197 0816 D801      		movw r26,r16
 2198 0818 5A96      		adiw r26,26
 2199 081a ED90      		ld r14,X+
 2200 081c FC90      		ld r15,X
 2201 081e 5B97      		sbiw r26,26+1
 2202 0820 81E0      		ldi r24,lo8(1)
 2203 0822 B801      		movw r22,r16
 2204 0824 0E94 0000 		call cmdlineGetArgStr
 2205 0828 00D0      		rcall .
 2206 082a 00D0      		rcall .
 2207 082c EDB7      		in r30,__SP_L__
 2208 082e FEB7      		in r31,__SP_H__
 2209 0830 3196      		adiw r30,1
 2210 0832 ADB7      		in r26,__SP_L__
 2211 0834 BEB7      		in r27,__SP_H__
 2212 0836 1196      		adiw r26,1
 2213 0838 ED92      		st X+,r14
 2214 083a FC92      		st X,r15
 2215 083c 1297      		sbiw r26,1+1
 2216 083e 20E0      		ldi r18,lo8(errorOpenFile)
 2217 0840 30E0      		ldi r19,hi8(errorOpenFile)
 2218 0842 2283      		std Z+2,r18
 2219 0844 3383      		std Z+3,r19
 2220 0846 8483      		std Z+4,r24
 2221 0848 9583      		std Z+5,r25
 2222 084a 0E94 0000 		call fprintf_P
 881:vty.c         ****     return ERROR_INFORM;
 2224               	.LM184:
 2225 084e EDB7      		in r30,__SP_L__
 2226 0850 FEB7      		in r31,__SP_H__
 2227 0852 3696      		adiw r30,6
 2228 0854 EDBF      		out __SP_L__,r30
 2229 0856 FEBF      		out __SP_H__,r31
 2230 0858 24E0      		ldi r18,lo8(4)
 2231 085a 30E0      		ldi r19,hi8(4)
 2232 085c 00C0      		rjmp .L52
 2233               	.L51:
 883:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 2235               	.LM185:
 2236 085e 80E0      		ldi r24,lo8(fdVty)
 2237 0860 90E0      		ldi r25,hi8(fdVty)
 2238 0862 0E94 0000 		call ramDyskUstawWskaznikNaKoniec
 884:vty.c         ****   uint8_t znak = 0;
 2240               	.LM186:
 2241 0866 1982      		std Y+1,__zero_reg__
 885:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 2243               	.LM187:
 2244 0868 00D0      		rcall .
 2245 086a 0F92      		push __tmp_reg__
 2246 086c D801      		movw r26,r16
 2247 086e 5A96      		adiw r26,26
 2248 0870 8D91      		ld r24,X+
 2249 0872 9C91      		ld r25,X
 2250 0874 5B97      		sbiw r26,26+1
 2251 0876 EDB7      		in r30,__SP_L__
 2252 0878 FEB7      		in r31,__SP_H__
 2253 087a 8183      		std Z+1,r24
 2254 087c 9283      		std Z+2,r25
 2255 087e 80E0      		ldi r24,lo8(editRamFileIntroStr)
 2256 0880 90E0      		ldi r25,hi8(editRamFileIntroStr)
 2257 0882 8383      		std Z+3,r24
 2258 0884 9483      		std Z+4,r25
 2259 0886 0E94 0000 		call fprintf_P
 2260 088a 0F90      		pop __tmp_reg__
 2261 088c 0F90      		pop __tmp_reg__
 2262 088e 0F90      		pop __tmp_reg__
 2263 0890 0F90      		pop __tmp_reg__
 888:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 2265               	.LM188:
 2266 0892 8E01      		movw r16,r28
 2267 0894 0F5F      		subi r16,lo8(-(1))
 2268 0896 1F4F      		sbci r17,hi8(-(1))
 2269               	.L58:
 2270 0898 8091 0000 		lds r24,xVtyRec
 2271 089c 9091 0000 		lds r25,xVtyRec+1
 2272 08a0 B801      		movw r22,r16
 2273 08a2 4FEF      		ldi r20,lo8(-1)
 2274 08a4 5FEF      		ldi r21,hi8(-1)
 2275 08a6 20E0      		ldi r18,lo8(0)
 2276 08a8 0E94 0000 		call xQueueGenericReceive
 2277 08ac 8823      		tst r24
 2278 08ae 01F0      		breq .L58
 891:vty.c         ****     if (znak == 0x03)                                       // ^C
 2280               	.LM189:
 2281 08b0 8981      		ldd r24,Y+1
 2282 08b2 8330      		cpi r24,lo8(3)
 2283 08b4 01F0      		breq .L54
 894:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 2285               	.LM190:
 2286 08b6 0E94 0000 		call uartVtySendByte
 895:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 2288               	.LM191:
 2289 08ba 80E0      		ldi r24,lo8(fdVty)
 2290 08bc 90E0      		ldi r25,hi8(fdVty)
 2291 08be 6981      		ldd r22,Y+1
 2292 08c0 0E94 0000 		call ramDyskZapiszBajtDoPliku
 2293 08c4 00C0      		rjmp .L58
 2294               	.L54:
 897:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2296               	.LM192:
 2297 08c6 80E0      		ldi r24,lo8(fdVty)
 2298 08c8 90E0      		ldi r25,hi8(fdVty)
 2299 08ca 0E94 0000 		call ramDyskZamknijPlik
 898:vty.c         ****   return OK_SILENT;
 2301               	.LM193:
 2302 08ce 20E0      		ldi r18,lo8(0)
 2303 08d0 30E0      		ldi r19,hi8(0)
 2304               	.L52:
 899:vty.c         **** }
 2306               	.LM194:
 2307 08d2 C901      		movw r24,r18
 2308               	/* epilogue start */
 2309 08d4 0F90      		pop __tmp_reg__
 2310 08d6 CF91      		pop r28
 2311 08d8 DF91      		pop r29
 2312 08da 1F91      		pop r17
 2313 08dc 0F91      		pop r16
 2314 08de FF90      		pop r15
 2315 08e0 EF90      		pop r14
 2316 08e2 0895      		ret
 2321               	.Lscope19:
 2323               		.stabd	78,0,0
 2327               	goXmodemOdbierzFunction:
 2328               		.stabd	46,0,0
 661:vty.c         **** {
 2330               	.LM195:
 2331               	.LFBB20:
 2332 08e4 2F92      		push r2
 2333 08e6 3F92      		push r3
 2334 08e8 4F92      		push r4
 2335 08ea 5F92      		push r5
 2336 08ec 6F92      		push r6
 2337 08ee 7F92      		push r7
 2338 08f0 8F92      		push r8
 2339 08f2 9F92      		push r9
 2340 08f4 AF92      		push r10
 2341 08f6 BF92      		push r11
 2342 08f8 CF92      		push r12
 2343 08fa DF92      		push r13
 2344 08fc EF92      		push r14
 2345 08fe FF92      		push r15
 2346 0900 0F93      		push r16
 2347 0902 1F93      		push r17
 2348 0904 DF93      		push r29
 2349 0906 CF93      		push r28
 2350 0908 CDB7      		in r28,__SP_L__
 2351 090a DEB7      		in r29,__SP_H__
 2352 090c 2797      		sbiw r28,7
 2353 090e CDBF      		out __SP_L__,r28
 2354 0910 DEBF      		out __SP_H__,r29
 2355               	/* prologue: function */
 2356               	/* frame size = 7 */
 2357               	/* stack size = 25 */
 2358               	.L__stack_usage = 25
 2359 0912 8C01      		movw r16,r24
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 2361               	.LM196:
 2362 0914 00D0      		rcall .
 2363 0916 0F92      		push __tmp_reg__
 2364 0918 DC01      		movw r26,r24
 2365 091a 5A96      		adiw r26,26
 2366 091c 8D91      		ld r24,X+
 2367 091e 9C91      		ld r25,X
 2368 0920 5B97      		sbiw r26,26+1
 2369 0922 EDB7      		in r30,__SP_L__
 2370 0924 FEB7      		in r31,__SP_H__
 2371 0926 8183      		std Z+1,r24
 2372 0928 9283      		std Z+2,r25
 2373 092a 80E0      		ldi r24,lo8(__c.5245)
 2374 092c 90E0      		ldi r25,hi8(__c.5245)
 2375 092e 8383      		std Z+3,r24
 2376 0930 9483      		std Z+4,r25
 2377 0932 0E94 0000 		call fprintf_P
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 2379               	.LM197:
 2380 0936 0F90      		pop __tmp_reg__
 2381 0938 0F90      		pop __tmp_reg__
 2382 093a 0F90      		pop __tmp_reg__
 2383 093c 0F90      		pop __tmp_reg__
 2384 093e 81E0      		ldi r24,lo8(1)
 2385 0940 B801      		movw r22,r16
 2386 0942 0E94 0000 		call cmdlineGetArgStr
 2387 0946 60E0      		ldi r22,lo8(fdVty)
 2388 0948 70E0      		ldi r23,hi8(fdVty)
 2389 094a 0E94 0000 		call ramDyskOtworzPlik
 2390 094e 8823      		tst r24
 2391 0950 01F0      		breq .L60
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 2393               	.LM198:
 2394 0952 D801      		movw r26,r16
 2395 0954 5A96      		adiw r26,26
 2396 0956 ED90      		ld r14,X+
 2397 0958 FC90      		ld r15,X
 2398 095a 5B97      		sbiw r26,26+1
 2399 095c 81E0      		ldi r24,lo8(1)
 2400 095e B801      		movw r22,r16
 2401 0960 0E94 0000 		call cmdlineGetArgStr
 2402 0964 00D0      		rcall .
 2403 0966 00D0      		rcall .
 2404 0968 EDB7      		in r30,__SP_L__
 2405 096a FEB7      		in r31,__SP_H__
 2406 096c 3196      		adiw r30,1
 2407 096e ADB7      		in r26,__SP_L__
 2408 0970 BEB7      		in r27,__SP_H__
 2409 0972 1196      		adiw r26,1
 2410 0974 ED92      		st X+,r14
 2411 0976 FC92      		st X,r15
 2412 0978 1297      		sbiw r26,1+1
 2413 097a 20E0      		ldi r18,lo8(errorOpenFile)
 2414 097c 30E0      		ldi r19,hi8(errorOpenFile)
 2415 097e 2283      		std Z+2,r18
 2416 0980 3383      		std Z+3,r19
 2417 0982 8483      		std Z+4,r24
 2418 0984 9583      		std Z+5,r25
 2419 0986 0E94 0000 		call fprintf_P
 666:vty.c         ****     return ERROR_INFORM;
 2421               	.LM199:
 2422 098a EDB7      		in r30,__SP_L__
 2423 098c FEB7      		in r31,__SP_H__
 2424 098e 3696      		adiw r30,6
 2425 0990 EDBF      		out __SP_L__,r30
 2426 0992 FEBF      		out __SP_H__,r31
 2427 0994 00C0      		rjmp .L93
 2428               	.L60:
 688:vty.c         ****   state->err1=0;
 2430               	.LM200:
 2431 0996 D801      		movw r26,r16
 2432 0998 5D96      		adiw r26,29
 2433 099a 1D92      		st X+,__zero_reg__
 2434 099c 1C92      		st X,__zero_reg__
 2435 099e 5E97      		sbiw r26,29+1
 689:vty.c         ****   state->err2=0;
 2437               	.LM201:
 2438 09a0 5F96      		adiw r26,31
 2439 09a2 1C92      		st X,__zero_reg__
 690:vty.c         ****   liczbaProb = 20;
 2441               	.LM202:
 2442 09a4 84E1      		ldi r24,lo8(20)
 2443 09a6 D82E      		mov r13,r24
 697:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2445               	.LM203:
 2446 09a8 B2E0      		ldi r27,lo8(2)
 2447 09aa EB2E      		mov r14,r27
 2448 09ac F12C      		mov r15,__zero_reg__
 2449 09ae EC0E      		add r14,r28
 2450 09b0 FD1E      		adc r15,r29
 2451               	.L65:
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 2453               	.LM204:
 2454 09b2 F801      		movw r30,r16
 2455 09b4 628D      		ldd r22,Z+26
 2456 09b6 738D      		ldd r23,Z+27
 2457 09b8 83E4      		ldi r24,lo8(67)
 2458 09ba 90E0      		ldi r25,hi8(67)
 2459 09bc 0E94 0000 		call fputc
 2460               	.L62:
 696:vty.c         ****     while(!(USARTD0.STATUS & USART_TXCIF_bm));
 2462               	.LM205:
 2463 09c0 8091 A109 		lds r24,2465
 2464 09c4 86FF      		sbrs r24,6
 2465 09c6 00C0      		rjmp .L62
 697:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2467               	.LM206:
 2468 09c8 8091 0000 		lds r24,xVtyRec
 2469 09cc 9091 0000 		lds r25,xVtyRec+1
 2470 09d0 B701      		movw r22,r14
 2471 09d2 44E6      		ldi r20,lo8(100)
 2472 09d4 50E0      		ldi r21,hi8(100)
 2473 09d6 20E0      		ldi r18,lo8(0)
 2474 09d8 0E94 0000 		call xQueueGenericReceive
 2475 09dc 8823      		tst r24
 2476 09de 01F0      		breq .L63
 698:vty.c         ****       if (c == SOH)
 2478               	.LM207:
 2479 09e0 8A81      		ldd r24,Y+2
 2480 09e2 8130      		cpi r24,lo8(1)
 2481 09e4 01F0      		breq .L64
 2482               	.L63:
 701:vty.c         ****     liczbaProb--;
 2484               	.LM208:
 2485 09e6 DA94      		dec r13
 702:vty.c         ****     if (liczbaProb == 0)
 2487               	.LM209:
 2488 09e8 01F4      		brne .L65
 704:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 2490               	.LM210:
 2491 09ea 80E0      		ldi r24,lo8(fdVty)
 2492 09ec 90E0      		ldi r25,hi8(fdVty)
 2493 09ee 0E94 0000 		call ramDyskZamknijPlik
 705:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2495               	.LM211:
 2496 09f2 D801      		movw r26,r16
 2497 09f4 5C96      		adiw r26,28
 2498 09f6 1C92      		st X,__zero_reg__
 2499 09f8 5C97      		sbiw r26,28
 2500               	.L93:
 706:vty.c         ****       return ERROR_INFORM;
 2502               	.LM212:
 2503 09fa 24E0      		ldi r18,lo8(4)
 2504 09fc 30E0      		ldi r19,hi8(4)
 2505 09fe 00C0      		rjmp .L61
 2506               	.L64:
 713:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2508               	.LM213:
 2509 0a00 80E0      		ldi r24,lo8(fdVty)
 2510 0a02 90E0      		ldi r25,hi8(fdVty)
 2511 0a04 61E0      		ldi r22,lo8(1)
 2512 0a06 70E0      		ldi r23,hi8(1)
 2513 0a08 0E94 0000 		call ramDyskDodajBlokXmodem
 2514 0a0c 6C01      		movw r12,r24
 710:vty.c         ****   nrBloku = 1;
 2516               	.LM214:
 2517 0a0e EE24      		clr r14
 2518 0a10 E394      		inc r14
 711:vty.c         ****   liczbaProb = 10;
 2520               	.LM215:
 2521 0a12 AAE0      		ldi r26,lo8(10)
 2522 0a14 BA2E      		mov r11,r26
 717:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 2524               	.LM216:
 2525 0a16 F3E0      		ldi r31,lo8(3)
 2526 0a18 4F2E      		mov r4,r31
 2527 0a1a 512C      		mov r5,__zero_reg__
 2528 0a1c 4C0E      		add r4,r28
 2529 0a1e 5D1E      		adc r5,r29
 723:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 2531               	.LM217:
 2532 0a20 E4E0      		ldi r30,lo8(4)
 2533 0a22 2E2E      		mov r2,r30
 2534 0a24 312C      		mov r3,__zero_reg__
 2535 0a26 2C0E      		add r2,r28
 2536 0a28 3D1E      		adc r3,r29
 763:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2538               	.LM218:
 2539 0a2a 73E0      		ldi r23,lo8(3)
 2540 0a2c A72E      		mov r10,r23
 808:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2542               	.LM219:
 2543 0a2e 3E01      		movw r6,r28
 2544 0a30 0894      		sec
 2545 0a32 611C      		adc r6,__zero_reg__
 2546 0a34 711C      		adc r7,__zero_reg__
 2547               	.L82:
 717:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 2549               	.LM220:
 2550 0a36 8091 0000 		lds r24,xVtyRec
 2551 0a3a 9091 0000 		lds r25,xVtyRec+1
 2552 0a3e B201      		movw r22,r4
 2553 0a40 44E6      		ldi r20,lo8(100)
 2554 0a42 50E0      		ldi r21,hi8(100)
 2555 0a44 20E0      		ldi r18,lo8(0)
 2556 0a46 0E94 0000 		call xQueueGenericReceive
 2557 0a4a 8823      		tst r24
 2558 0a4c 01F4      		brne .L66
 719:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 2560               	.LM221:
 2561 0a4e 82E0      		ldi r24,lo8(2)
 2562 0a50 F801      		movw r30,r16
 2563 0a52 00C0      		rjmp .L90
 2564               	.L66:
 723:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 2566               	.LM222:
 2567 0a54 8091 0000 		lds r24,xVtyRec
 2568 0a58 9091 0000 		lds r25,xVtyRec+1
 2569 0a5c B101      		movw r22,r2
 2570 0a5e 41E0      		ldi r20,lo8(1)
 2571 0a60 50E0      		ldi r21,hi8(1)
 2572 0a62 20E0      		ldi r18,lo8(0)
 2573 0a64 0E94 0000 		call xQueueGenericReceive
 2574 0a68 8823      		tst r24
 2575 0a6a 01F4      		brne .L68
 725:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 2577               	.LM223:
 2578 0a6c 83E0      		ldi r24,lo8(3)
 2579 0a6e 00C0      		rjmp .L91
 2580               	.L68:
 730:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 2582               	.LM224:
 2583 0a70 8C81      		ldd r24,Y+4
 2584 0a72 982F      		mov r25,r24
 2585 0a74 9095      		com r25
 2586 0a76 9A83      		std Y+2,r25
 731:vty.c         ****     if (nrBlokuZdalny != c)
 2588               	.LM225:
 2589 0a78 FB80      		ldd r15,Y+3
 2590 0a7a F916      		cp r15,r25
 2591 0a7c 01F0      		breq .L69
 733:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 2593               	.LM226:
 2594 0a7e 95E0      		ldi r25,lo8(5)
 2595 0a80 F801      		movw r30,r16
 2596 0a82 948F      		std Z+28,r25
 734:vty.c         ****       state->err1 = nrBlokuZdalny;
 2598               	.LM227:
 2599 0a84 F58E      		std Z+29,r15
 2600 0a86 168E      		std Z+30,__zero_reg__
 735:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 2602               	.LM228:
 2603 0a88 878F      		std Z+31,r24
 736:vty.c         ****       break;
 2605               	.LM229:
 2606 0a8a 00C0      		rjmp .L67
 2607               	.L69:
 740:vty.c         ****     c = nrBloku-1;
 2609               	.LM230:
 2610 0a8c 8E2D      		mov r24,r14
 2611 0a8e 8150      		subi r24,lo8(-(-1))
 2612 0a90 8A83      		std Y+2,r24
 741:vty.c         ****     if (nrBlokuZdalny == c)
 2614               	.LM231:
 2615 0a92 F816      		cp r15,r24
 2616 0a94 01F4      		brne .L70
 744:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2618               	.LM232:
 2619 0a96 80E0      		ldi r24,lo8(fdVty)
 2620 0a98 90E0      		ldi r25,hi8(fdVty)
 2621 0a9a 6F2D      		mov r22,r15
 2622 0a9c 70E0      		ldi r23,lo8(0)
 2623 0a9e 0E94 0000 		call ramDyskDodajBlokXmodem
 2624 0aa2 6C01      		movw r12,r24
 2625 0aa4 EF2C      		mov r14,r15
 2626               	.L70:
 749:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 2628               	.LM233:
 2629 0aa6 FB80      		ldd r15,Y+3
 2630 0aa8 FE14      		cp r15,r14
 2631 0aaa 01F0      		breq .L71
 751:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2633               	.LM234:
 2634 0aac 84E0      		ldi r24,lo8(4)
 2635 0aae D801      		movw r26,r16
 2636 0ab0 5C96      		adiw r26,28
 2637 0ab2 8C93      		st X,r24
 2638 0ab4 5C97      		sbiw r26,28
 752:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 2640               	.LM235:
 2641 0ab6 8C81      		ldd r24,Y+4
 2642 0ab8 5D96      		adiw r26,29
 2643 0aba 8C93      		st X,r24
 2644 0abc 5D97      		sbiw r26,29
 2645 0abe 5E96      		adiw r26,30
 2646 0ac0 1C92      		st X,__zero_reg__
 2647 0ac2 5E97      		sbiw r26,30
 753:vty.c         ****       state->err2 = nrBloku;
 2649               	.LM236:
 2650 0ac4 5F96      		adiw r26,31
 2651 0ac6 EC92      		st X,r14
 2652 0ac8 5F97      		sbiw r26,31
 754:vty.c         ****       break;
 2654               	.LM237:
 2655 0aca 00C0      		rjmp .L67
 2656               	.L71:
 749:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 2658               	.LM238:
 2659 0acc 8C2C      		mov r8,r12
 2660 0ace 9D2C      		mov r9,r13
 2661 0ad0 30E0      		ldi r19,lo8(0)
 2662               	.L73:
 759:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 2664               	.LM239:
 2665 0ad2 8091 0000 		lds r24,xVtyRec
 2666 0ad6 9091 0000 		lds r25,xVtyRec+1
 2667 0ada BE01      		movw r22,r28
 2668 0adc 6E5F      		subi r22,lo8(-(2))
 2669 0ade 7F4F      		sbci r23,hi8(-(2))
 2670 0ae0 4AE0      		ldi r20,lo8(10)
 2671 0ae2 50E0      		ldi r21,hi8(10)
 2672 0ae4 20E0      		ldi r18,lo8(0)
 2673 0ae6 3F83      		std Y+7,r19
 2674 0ae8 0E94 0000 		call xQueueGenericReceive
 2675 0aec 3F81      		ldd r19,Y+7
 2676 0aee 8823      		tst r24
 2677 0af0 01F0      		breq .L72
 760:vty.c         ****         *(zapPtr++) = c;
 2679               	.LM240:
 2680 0af2 8A81      		ldd r24,Y+2
 2681 0af4 F401      		movw r30,r8
 2682 0af6 8193      		st Z+,r24
 2683 0af8 4F01      		movw r8,r30
 757:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2685               	.LM241:
 2686 0afa 3F5F      		subi r19,lo8(-(1))
 2687 0afc 3038      		cpi r19,lo8(-128)
 2688 0afe 01F4      		brne .L73
 2689 0b00 00C0      		rjmp .L74
 2690               	.L72:
 763:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2692               	.LM242:
 2693 0b02 D801      		movw r26,r16
 2694 0b04 5C96      		adiw r26,28
 2695 0b06 AC92      		st X,r10
 2696               	.L74:
 767:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 2698               	.LM243:
 2699 0b08 8091 0000 		lds r24,xVtyRec
 2700 0b0c 9091 0000 		lds r25,xVtyRec+1
 2701 0b10 BE01      		movw r22,r28
 2702 0b12 6B5F      		subi r22,lo8(-(5))
 2703 0b14 7F4F      		sbci r23,hi8(-(5))
 2704 0b16 4AE0      		ldi r20,lo8(10)
 2705 0b18 50E0      		ldi r21,hi8(10)
 2706 0b1a 20E0      		ldi r18,lo8(0)
 2707 0b1c 0E94 0000 		call xQueueGenericReceive
 2708 0b20 8823      		tst r24
 2709 0b22 01F4      		brne .L75
 769:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2711               	.LM244:
 2712 0b24 86E0      		ldi r24,lo8(6)
 2713 0b26 F801      		movw r30,r16
 2714 0b28 848F      		std Z+28,r24
 770:vty.c         ****         state->err1 = 2;
 2716               	.LM245:
 2717 0b2a 82E0      		ldi r24,lo8(2)
 2718 0b2c 90E0      		ldi r25,hi8(2)
 2719 0b2e 858F      		std Z+29,r24
 2720 0b30 968F      		std Z+30,r25
 771:vty.c         ****         break;      
 2722               	.LM246:
 2723 0b32 00C0      		rjmp .L67
 2724               	.L75:
 773:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2726               	.LM247:
 2727 0b34 8091 0000 		lds r24,xVtyRec
 2728 0b38 9091 0000 		lds r25,xVtyRec+1
 2729 0b3c BE01      		movw r22,r28
 2730 0b3e 6A5F      		subi r22,lo8(-(6))
 2731 0b40 7F4F      		sbci r23,hi8(-(6))
 2732 0b42 4AE0      		ldi r20,lo8(10)
 2733 0b44 50E0      		ldi r21,hi8(10)
 2734 0b46 20E0      		ldi r18,lo8(0)
 2735 0b48 0E94 0000 		call xQueueGenericReceive
 2736 0b4c 8823      		tst r24
 2737 0b4e 01F4      		brne .L76
 775:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2739               	.LM248:
 2740 0b50 86E0      		ldi r24,lo8(6)
 2741 0b52 D801      		movw r26,r16
 2742 0b54 5C96      		adiw r26,28
 2743 0b56 8C93      		st X,r24
 2744 0b58 5C97      		sbiw r26,28
 776:vty.c         ****         state->err1 = 1;
 2746               	.LM249:
 2747 0b5a 81E0      		ldi r24,lo8(1)
 2748 0b5c 90E0      		ldi r25,hi8(1)
 2749 0b5e 5D96      		adiw r26,29
 2750 0b60 8D93      		st X+,r24
 2751 0b62 9C93      		st X,r25
 2752 0b64 5E97      		sbiw r26,29+1
 777:vty.c         ****         break;      
 2754               	.LM250:
 2755 0b66 00C0      		rjmp .L67
 2756               	.L76:
 773:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2758               	.LM251:
 2759 0b68 EC2D      		mov r30,r12
 2760 0b6a FD2D      		mov r31,r13
 2761 0b6c 80E0      		ldi r24,lo8(0)
 2762 0b6e 90E0      		ldi r25,hi8(0)
 2763 0b70 20E0      		ldi r18,lo8(0)
 2764               	.L77:
 785:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 2766               	.LM252:
 2767 0b72 3191      		ld r19,Z+
 2768               	.LBB5:
 2769               	.LBB6:
 2771               	.Ltext1:
   1:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
   5:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
   8:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  11:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****      distribution.
  15:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  16:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  20:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  32:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** /* $Id: crc16.h 2136 2010-06-08 12:03:38Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  34:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  35:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  36:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  37:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** #include <stdint.h>
  38:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  39:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** /** \file */
  40:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  41:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  42:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  43:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  44:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  45:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  46:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \par References:
  47:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  48:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \par
  49:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  50:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  51:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  52:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  53:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  54:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \par
  55:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  56:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  57:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  58:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  59:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     obtain a copy.
  60:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  61:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     A typical application would look like:
  62:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  63:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \code
  64:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     // Dallas iButton test vector.
  65:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  66:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  67:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     int
  68:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     checkcrc(void)
  69:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     {
  70:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  71:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  72:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  73:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  74:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  75:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	return crc; // must be 0
  76:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     }
  77:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \endcode
  78:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** */
  79:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  80:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
  81:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  82:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  83:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  84:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Initial value: 0xffff
  85:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  86:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  87:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  88:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  89:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  90:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \code
  91:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     uint16_t
  92:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  93:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     {
  94:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	int i;
  95:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
  96:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	crc ^= a;
  97:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
  98:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	{
  99:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	    if (crc & 1)
 100:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 101:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	    else
 102:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1);
 103:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	}
 104:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 105:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	return crc;
 106:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     }
 107:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 108:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \endcode */
 109:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 110:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 111:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 112:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** {
 113:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	uint8_t __tmp;
 114:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	uint16_t __ret;
 115:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 116:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 117:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 118:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 119:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 120:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 121:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 122:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 123:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 124:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 125:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 126:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 127:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 128:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 129:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 130:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 131:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 132:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 133:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 134:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 135:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 136:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 137:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 138:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 139:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		"eor %A0,%1"
 140:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 141:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 142:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 		: "r0"
 143:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	);
 144:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 	return __ret;
 145:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** }
 146:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 147:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
 148:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 149:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 150:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 151:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     Initial value: 0x0
 152:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 153:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 154:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 155:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 156:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 157:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \code
 158:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     uint16_t
 159:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 160:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     {
 161:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****         int i;
 162:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 163:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 164:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 165:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****         {
 166:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****             if (crc & 0x8000)
 167:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 168:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****             else
 169:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****                 crc <<= 1;
 170:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****         }
 171:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 172:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****         return crc;
 173:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     }
 174:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     \endcode */
 175:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 176:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 177:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 178:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** {
 179:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 180:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 181:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 182:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****                                 /* %3  __data */
 183:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h **** 
 184:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h ****     __asm__ __volatile__ (
 2773               	.LM253:
 2774               	/* #APP */
 2775               	 ;  184 "/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/crc16.h" 1
 2776 0b74 9327      		eor    r25,r19
 2777 0b76 092E      		mov    __tmp_reg__,r25
 2778 0b78 0294      		swap   __tmp_reg__
 2779 0b7a 302D      		mov    r19,__tmp_reg__
 2780 0b7c 3F70      		andi   r19,0x0f
 2781 0b7e 3927      		eor    r19,r25
 2782 0b80 492F      		mov    r20,r25
 2783 0b82 4025      		eor    r20,__tmp_reg__
 2784 0b84 440F      		lsl    r20
 2785 0b86 407E      		andi   r20,0xe0
 2786 0b88 3427      		eor    r19,r20
 2787 0b8a 402D      		mov    r20,__tmp_reg__
 2788 0b8c 4927      		eor    r20,r25
 2789 0b8e 407F      		andi   r20,0xf0
 2790 0b90 4695      		lsr    r20
 2791 0b92 092E      		mov    __tmp_reg__,r25
 2792 0b94 000C      		lsl    __tmp_reg__
 2793 0b96 441F      		rol    r20
 2794 0b98 9695      		lsr    r25
 2795 0b9a 9695      		lsr    r25
 2796 0b9c 9695      		lsr    r25
 2797 0b9e 9F71      		andi   r25,0x1f
 2798 0ba0 9427      		eor    r25,r20
 2799 0ba2 9827      		eor    r25,r24
 2800 0ba4 832F      		mov    r24,r19
 2801               		
 2802               	 ;  0 "" 2
 2803               	/* #NOAPP */
 2804               	.LBE6:
 2805               	.LBE5:
 2807               	.Ltext2:
 784:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2809               	.LM254:
 2810 0ba6 2F5F      		subi r18,lo8(-(1))
 2811 0ba8 2038      		cpi r18,lo8(-128)
 2812 0baa 01F4      		brne .L77
 788:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 2814               	.LM255:
 2815 0bac 4D81      		ldd r20,Y+5
 2816 0bae 50E0      		ldi r21,lo8(0)
 2817 0bb0 292F      		mov r18,r25
 2818 0bb2 3327      		clr r19
 2819 0bb4 4217      		cp r20,r18
 2820 0bb6 5307      		cpc r21,r19
 2821 0bb8 01F4      		brne .L78
 788:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 2823               	.LM256:
 2824 0bba 2E81      		ldd r18,Y+6
 2825 0bbc 30E0      		ldi r19,lo8(0)
 2826 0bbe 9070      		andi r25,hi8(255)
 2827 0bc0 2817      		cp r18,r24
 2828 0bc2 3907      		cpc r19,r25
 2829 0bc4 01F4      		brne .L78
 791:vty.c         ****       uartVtySendByte(ACK);      
 2831               	.LM257:
 2832 0bc6 86E0      		ldi r24,lo8(6)
 2833 0bc8 0E94 0000 		call uartVtySendByte
 790:vty.c         ****       liczbaProb = 10;
 2835               	.LM258:
 2836 0bcc 3AE0      		ldi r19,lo8(10)
 2837 0bce B32E      		mov r11,r19
 2838 0bd0 00C0      		rjmp .L79
 2839               	.L78:
 795:vty.c         ****       liczbaProb--;
 2841               	.LM259:
 2842 0bd2 BA94      		dec r11
 796:vty.c         ****       nrBloku--;
 2844               	.LM260:
 2845 0bd4 FA94      		dec r15
 797:vty.c         ****       uartVtySendByte(NAK);   
 2847               	.LM261:
 2848 0bd6 85E1      		ldi r24,lo8(21)
 2849 0bd8 0E94 0000 		call uartVtySendByte
 800:vty.c         ****     if (liczbaProb == 0)
 2851               	.LM262:
 2852 0bdc BB20      		tst r11
 2853 0bde 01F4      		brne .L79
 802:vty.c         ****       state->err1 = nrBlokuZdalny;
 2855               	.LM263:
 2856 0be0 8B81      		ldd r24,Y+3
 2857 0be2 F801      		movw r30,r16
 2858 0be4 858F      		std Z+29,r24
 2859 0be6 168E      		std Z+30,__zero_reg__
 803:vty.c         ****       state->err2 = nrBloku;
 2861               	.LM264:
 2862 0be8 F78E      		std Z+31,r15
 804:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2864               	.LM265:
 2865 0bea 84E0      		ldi r24,lo8(4)
 2866               	.L90:
 2867 0bec 848F      		std Z+28,r24
 805:vty.c         ****       break; 
 2869               	.LM266:
 2870 0bee 00C0      		rjmp .L67
 2871               	.L79:
 808:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2873               	.LM267:
 2874 0bf0 8091 0000 		lds r24,xVtyRec
 2875 0bf4 9091 0000 		lds r25,xVtyRec+1
 2876 0bf8 B301      		movw r22,r6
 2877 0bfa 44E6      		ldi r20,lo8(100)
 2878 0bfc 50E0      		ldi r21,hi8(100)
 2879 0bfe 20E0      		ldi r18,lo8(0)
 2880 0c00 0E94 0000 		call xQueueGenericReceive
 2881 0c04 8823      		tst r24
 2882 0c06 01F4      		brne .L80
 810:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 2884               	.LM268:
 2885 0c08 82E0      		ldi r24,lo8(2)
 2886               	.L91:
 2887 0c0a D801      		movw r26,r16
 2888               	.L92:
 2889 0c0c 5C96      		adiw r26,28
 2890 0c0e 8C93      		st X,r24
 2891 0c10 5C97      		sbiw r26,28
 811:vty.c         ****       break;
 2893               	.LM269:
 2894 0c12 00C0      		rjmp .L67
 2895               	.L80:
 814:vty.c         ****     if (temp1 == SOH)
 2897               	.LM270:
 2898 0c14 8981      		ldd r24,Y+1
 2899 0c16 8130      		cpi r24,lo8(1)
 2900 0c18 01F4      		brne .L81
 816:vty.c         ****       nrBloku++;
 2902               	.LM271:
 2903 0c1a EF2C      		mov r14,r15
 2904 0c1c E394      		inc r14
 817:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2906               	.LM272:
 2907 0c1e 80E0      		ldi r24,lo8(fdVty)
 2908 0c20 90E0      		ldi r25,hi8(fdVty)
 2909 0c22 6E2D      		mov r22,r14
 2910 0c24 70E0      		ldi r23,lo8(0)
 2911 0c26 0E94 0000 		call ramDyskDodajBlokXmodem
 2912 0c2a 6C01      		movw r12,r24
 819:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2914               	.LM273:
 2915 0c2c F801      		movw r30,r16
 2916 0c2e 148E      		std Z+28,__zero_reg__
 843:vty.c         ****   }
 2918               	.LM274:
 2919 0c30 00C0      		rjmp .L82
 2920               	.L81:
 823:vty.c         ****     if (temp1 == CAN)
 2922               	.LM275:
 2923 0c32 8831      		cpi r24,lo8(24)
 2924 0c34 01F4      		brne .L83
 825:vty.c         ****       state->err1 = nrBloku;
 2926               	.LM276:
 2927 0c36 D801      		movw r26,r16
 2928 0c38 5D96      		adiw r26,29
 2929 0c3a FC92      		st X,r15
 2930 0c3c 5D97      		sbiw r26,29
 2931 0c3e 5E96      		adiw r26,30
 2932 0c40 1C92      		st X,__zero_reg__
 2933 0c42 5E97      		sbiw r26,30
 826:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 2935               	.LM277:
 2936 0c44 87E0      		ldi r24,lo8(7)
 2937 0c46 00C0      		rjmp .L92
 2938               	.L83:
 829:vty.c         ****     if (temp1 == EOT)
 2940               	.LM278:
 2941 0c48 8430      		cpi r24,lo8(4)
 2942 0c4a 01F4      		brne .L84
 831:vty.c         ****       uartVtySendByte(NAK);
 2944               	.LM279:
 2945 0c4c 85E1      		ldi r24,lo8(21)
 2946 0c4e 0E94 0000 		call uartVtySendByte
 832:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 2948               	.LM280:
 2949 0c52 8091 0000 		lds r24,xVtyRec
 2950 0c56 9091 0000 		lds r25,xVtyRec+1
 2951 0c5a B301      		movw r22,r6
 2952 0c5c 4AE0      		ldi r20,lo8(10)
 2953 0c5e 50E0      		ldi r21,hi8(10)
 2954 0c60 20E0      		ldi r18,lo8(0)
 2955 0c62 0E94 0000 		call xQueueGenericReceive
 2956 0c66 8823      		tst r24
 2957 0c68 01F0      		breq .L85
 834:vty.c         ****         if (temp1 == EOT)
 2959               	.LM281:
 2960 0c6a 8981      		ldd r24,Y+1
 2961 0c6c 8430      		cpi r24,lo8(4)
 2962 0c6e 01F4      		brne .L85
 835:vty.c         ****           uartVtySendByte(ACK);  
 2964               	.LM282:
 2965 0c70 86E0      		ldi r24,lo8(6)
 2966 0c72 0E94 0000 		call uartVtySendByte
 2967               	.L85:
 837:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2969               	.LM283:
 2970 0c76 F801      		movw r30,r16
 2971 0c78 148E      		std Z+28,__zero_reg__
 838:vty.c         ****       break;
 2973               	.LM284:
 2974 0c7a 00C0      		rjmp .L67
 2975               	.L84:
 840:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 2977               	.LM285:
 2978 0c7c 98E0      		ldi r25,lo8(8)
 2979 0c7e D801      		movw r26,r16
 2980 0c80 5C96      		adiw r26,28
 2981 0c82 9C93      		st X,r25
 2982 0c84 5C97      		sbiw r26,28
 841:vty.c         ****     state->err1 = temp1;
 2984               	.LM286:
 2985 0c86 5D96      		adiw r26,29
 2986 0c88 8C93      		st X,r24
 2987 0c8a 5D97      		sbiw r26,29
 2988 0c8c 5E96      		adiw r26,30
 2989 0c8e 1C92      		st X,__zero_reg__
 2990               	.L67:
 844:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2992               	.LM287:
 2993 0c90 80E0      		ldi r24,lo8(fdVty)
 2994 0c92 90E0      		ldi r25,hi8(fdVty)
 2995 0c94 0E94 0000 		call ramDyskZamknijPlik
 845:vty.c         ****   return OK_SILENT;
 2997               	.LM288:
 2998 0c98 20E0      		ldi r18,lo8(0)
 2999 0c9a 30E0      		ldi r19,hi8(0)
 3000               	.L61:
 846:vty.c         **** }
 3002               	.LM289:
 3003 0c9c C901      		movw r24,r18
 3004               	/* epilogue start */
 3005 0c9e 2796      		adiw r28,7
 3006 0ca0 CDBF      		out __SP_L__,r28
 3007 0ca2 DEBF      		out __SP_H__,r29
 3008 0ca4 CF91      		pop r28
 3009 0ca6 DF91      		pop r29
 3010 0ca8 1F91      		pop r17
 3011 0caa 0F91      		pop r16
 3012 0cac FF90      		pop r15
 3013 0cae EF90      		pop r14
 3014 0cb0 DF90      		pop r13
 3015 0cb2 CF90      		pop r12
 3016 0cb4 BF90      		pop r11
 3017 0cb6 AF90      		pop r10
 3018 0cb8 9F90      		pop r9
 3019 0cba 8F90      		pop r8
 3020 0cbc 7F90      		pop r7
 3021 0cbe 6F90      		pop r6
 3022 0cc0 5F90      		pop r5
 3023 0cc2 4F90      		pop r4
 3024 0cc4 3F90      		pop r3
 3025 0cc6 2F90      		pop r2
 3026 0cc8 0895      		ret
 3038               	.Lscope20:
 3040               		.stabd	78,0,0
 3044               	debugFunction:
 3045               		.stabd	46,0,0
 303:vty.c         **** {
 3047               	.LM290:
 3048               	.LFBB21:
 3049 0cca FF92      		push r15
 3050 0ccc 0F93      		push r16
 3051 0cce 1F93      		push r17
 3052 0cd0 CF93      		push r28
 3053 0cd2 DF93      		push r29
 3054               	/* prologue: function */
 3055               	/* frame size = 0 */
 3056               	/* stack size = 5 */
 3057               	.L__stack_usage = 5
 3058 0cd4 8C01      		movw r16,r24
 304:vty.c         ****   if (state->argc < 2)
 3060               	.LM291:
 3061 0cd6 DC01      		movw r26,r24
 3062 0cd8 5996      		adiw r26,25
 3063 0cda 8C91      		ld r24,X
 3064 0cdc 5997      		sbiw r26,25
 3065 0cde 8230      		cpi r24,lo8(2)
 3066 0ce0 00F4      		brsh .+2
 3067 0ce2 00C0      		rjmp .L107
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 3069               	.LM292:
 3070 0ce4 82E0      		ldi r24,lo8(2)
 3071 0ce6 B801      		movw r22,r16
 3072 0ce8 0E94 0000 		call cmdlineGetArgInt
 3073 0cec F62E      		mov r15,r22
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 3075               	.LM293:
 3076 0cee 81E0      		ldi r24,lo8(1)
 3077 0cf0 B801      		movw r22,r16
 3078 0cf2 0E94 0000 		call cmdlineGetArgStr
 3079 0cf6 EC01      		movw r28,r24
 309:vty.c         ****   if (level == 0)
 3081               	.LM294:
 3082 0cf8 FF20      		tst r15
 3083 0cfa 01F0      		breq .+2
 3084 0cfc 00C0      		rjmp .L96
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 3086               	.LM295:
 3087 0cfe 60E0      		ldi r22,lo8(__c.5141)
 3088 0d00 70E0      		ldi r23,hi8(__c.5141)
 3089 0d02 43E0      		ldi r20,lo8(3)
 3090 0d04 50E0      		ldi r21,hi8(3)
 3091 0d06 0E94 0000 		call strncmp_P
 3092 0d0a 0097      		sbiw r24,0
 3093 0d0c 01F4      		brne .L97
 313:vty.c         ****       setArpDebug(NULL, 0);
 3095               	.LM296:
 3096 0d0e 80E0      		ldi r24,lo8(0)
 3097 0d10 90E0      		ldi r25,hi8(0)
 3098 0d12 60E0      		ldi r22,lo8(0)
 3099 0d14 0E94 0000 		call setArpDebug
 3100 0d18 00C0      		rjmp .L110
 3101               	.L97:
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3103               	.LM297:
 3104 0d1a CE01      		movw r24,r28
 3105 0d1c 60E0      		ldi r22,lo8(__c.5143)
 3106 0d1e 70E0      		ldi r23,hi8(__c.5143)
 3107 0d20 42E0      		ldi r20,lo8(2)
 3108 0d22 50E0      		ldi r21,hi8(2)
 3109 0d24 0E94 0000 		call strncmp_P
 3110 0d28 0097      		sbiw r24,0
 3111 0d2a 01F4      		brne .L98
 320:vty.c         ****       setIpDebug(NULL, 0);
 3113               	.LM298:
 3114 0d2c 80E0      		ldi r24,lo8(0)
 3115 0d2e 90E0      		ldi r25,hi8(0)
 3116 0d30 60E0      		ldi r22,lo8(0)
 3117 0d32 0E94 0000 		call setIpDebug
 3118 0d36 00C0      		rjmp .L110
 3119               	.L98:
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3121               	.LM299:
 3122 0d38 CE01      		movw r24,r28
 3123 0d3a 60E0      		ldi r22,lo8(__c.5145)
 3124 0d3c 70E0      		ldi r23,hi8(__c.5145)
 3125 0d3e 42E0      		ldi r20,lo8(2)
 3126 0d40 50E0      		ldi r21,hi8(2)
 3127 0d42 0E94 0000 		call strncmp_P
 3128 0d46 0097      		sbiw r24,0
 3129 0d48 01F4      		brne .L99
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 3131               	.LM300:
 3132 0d4a 80E0      		ldi r24,lo8(0)
 3133 0d4c 90E0      		ldi r25,hi8(0)
 3134 0d4e 60E0      		ldi r22,lo8(0)
 3135 0d50 0E94 0000 		call setIcmpDebug
 3136 0d54 00C0      		rjmp .L110
 3137               	.L99:
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3139               	.LM301:
 3140 0d56 CE01      		movw r24,r28
 3141 0d58 60E0      		ldi r22,lo8(__c.5147)
 3142 0d5a 70E0      		ldi r23,hi8(__c.5147)
 3143 0d5c 42E0      		ldi r20,lo8(2)
 3144 0d5e 50E0      		ldi r21,hi8(2)
 3145 0d60 0E94 0000 		call strncmp_P
 3146 0d64 0097      		sbiw r24,0
 3147 0d66 01F4      		brne .L100
 334:vty.c         ****       setTcpDebug(NULL, 0);
 3149               	.LM302:
 3150 0d68 80E0      		ldi r24,lo8(0)
 3151 0d6a 90E0      		ldi r25,hi8(0)
 3152 0d6c 60E0      		ldi r22,lo8(0)
 3153 0d6e 0E94 0000 		call setTcpDebug
 3154 0d72 00C0      		rjmp .L110
 3155               	.L100:
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3157               	.LM303:
 3158 0d74 CE01      		movw r24,r28
 3159 0d76 60E0      		ldi r22,lo8(__c.5149)
 3160 0d78 70E0      		ldi r23,hi8(__c.5149)
 3161 0d7a 42E0      		ldi r20,lo8(2)
 3162 0d7c 50E0      		ldi r21,hi8(2)
 3163 0d7e 0E94 0000 		call strncmp_P
 3164 0d82 0097      		sbiw r24,0
 3165 0d84 01F0      		breq .+2
 3166 0d86 00C0      		rjmp .L107
 341:vty.c         ****       setUdpDebug(NULL, 0);
 3168               	.LM304:
 3169 0d88 80E0      		ldi r24,lo8(0)
 3170 0d8a 90E0      		ldi r25,hi8(0)
 3171 0d8c 60E0      		ldi r22,lo8(0)
 3172 0d8e 0E94 0000 		call setUdpDebug
 3173               	.L110:
 342:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 3175               	.LM305:
 3176 0d92 00D0      		rcall .
 3177 0d94 00D0      		rcall .
 3178 0d96 EDB7      		in r30,__SP_L__
 3179 0d98 FEB7      		in r31,__SP_H__
 3180 0d9a 3196      		adiw r30,1
 3181 0d9c D801      		movw r26,r16
 3182 0d9e 5A96      		adiw r26,26
 3183 0da0 8D91      		ld r24,X+
 3184 0da2 9C91      		ld r25,X
 3185 0da4 5B97      		sbiw r26,26+1
 3186 0da6 ADB7      		in r26,__SP_L__
 3187 0da8 BEB7      		in r27,__SP_H__
 3188 0daa 1196      		adiw r26,1
 3189 0dac 8D93      		st X+,r24
 3190 0dae 9C93      		st X,r25
 3191 0db0 1297      		sbiw r26,1+1
 3192 0db2 80E0      		ldi r24,lo8(debugDisabledInfoStr)
 3193 0db4 90E0      		ldi r25,hi8(debugDisabledInfoStr)
 3194 0db6 00C0      		rjmp .L109
 3195               	.L96:
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 3197               	.LM306:
 3198 0db8 60E0      		ldi r22,lo8(__c.5151)
 3199 0dba 70E0      		ldi r23,hi8(__c.5151)
 3200 0dbc 43E0      		ldi r20,lo8(3)
 3201 0dbe 50E0      		ldi r21,hi8(3)
 3202 0dc0 0E94 0000 		call strncmp_P
 3203 0dc4 0097      		sbiw r24,0
 3204 0dc6 01F4      		brne .L101
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 3206               	.LM307:
 3207 0dc8 D801      		movw r26,r16
 3208 0dca 5A96      		adiw r26,26
 3209 0dcc 8D91      		ld r24,X+
 3210 0dce 9C91      		ld r25,X
 3211 0dd0 5B97      		sbiw r26,26+1
 3212 0dd2 6F2D      		mov r22,r15
 3213 0dd4 0E94 0000 		call setArpDebug
 3214 0dd8 00C0      		rjmp .L108
 3215               	.L101:
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3217               	.LM308:
 3218 0dda CE01      		movw r24,r28
 3219 0ddc 60E0      		ldi r22,lo8(__c.5153)
 3220 0dde 70E0      		ldi r23,hi8(__c.5153)
 3221 0de0 42E0      		ldi r20,lo8(2)
 3222 0de2 50E0      		ldi r21,hi8(2)
 3223 0de4 0E94 0000 		call strncmp_P
 3224 0de8 0097      		sbiw r24,0
 3225 0dea 01F4      		brne .L102
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 3227               	.LM309:
 3228 0dec D801      		movw r26,r16
 3229 0dee 5A96      		adiw r26,26
 3230 0df0 8D91      		ld r24,X+
 3231 0df2 9C91      		ld r25,X
 3232 0df4 5B97      		sbiw r26,26+1
 3233 0df6 6F2D      		mov r22,r15
 3234 0df8 0E94 0000 		call setIpDebug
 3235 0dfc 00C0      		rjmp .L108
 3236               	.L102:
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3238               	.LM310:
 3239 0dfe CE01      		movw r24,r28
 3240 0e00 60E0      		ldi r22,lo8(__c.5155)
 3241 0e02 70E0      		ldi r23,hi8(__c.5155)
 3242 0e04 42E0      		ldi r20,lo8(2)
 3243 0e06 50E0      		ldi r21,hi8(2)
 3244 0e08 0E94 0000 		call strncmp_P
 3245 0e0c 0097      		sbiw r24,0
 3246 0e0e 01F4      		brne .L103
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 3248               	.LM311:
 3249 0e10 D801      		movw r26,r16
 3250 0e12 5A96      		adiw r26,26
 3251 0e14 8D91      		ld r24,X+
 3252 0e16 9C91      		ld r25,X
 3253 0e18 5B97      		sbiw r26,26+1
 3254 0e1a 6F2D      		mov r22,r15
 3255 0e1c 0E94 0000 		call setIcmpDebug
 3256 0e20 00C0      		rjmp .L108
 3257               	.L103:
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3259               	.LM312:
 3260 0e22 CE01      		movw r24,r28
 3261 0e24 60E0      		ldi r22,lo8(__c.5157)
 3262 0e26 70E0      		ldi r23,hi8(__c.5157)
 3263 0e28 42E0      		ldi r20,lo8(2)
 3264 0e2a 50E0      		ldi r21,hi8(2)
 3265 0e2c 0E94 0000 		call strncmp_P
 3266 0e30 0097      		sbiw r24,0
 3267 0e32 01F4      		brne .L104
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 3269               	.LM313:
 3270 0e34 D801      		movw r26,r16
 3271 0e36 5A96      		adiw r26,26
 3272 0e38 8D91      		ld r24,X+
 3273 0e3a 9C91      		ld r25,X
 3274 0e3c 5B97      		sbiw r26,26+1
 3275 0e3e 6F2D      		mov r22,r15
 3276 0e40 0E94 0000 		call setTcpDebug
 3277 0e44 00C0      		rjmp .L108
 3278               	.L104:
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3280               	.LM314:
 3281 0e46 CE01      		movw r24,r28
 3282 0e48 60E0      		ldi r22,lo8(__c.5159)
 3283 0e4a 70E0      		ldi r23,hi8(__c.5159)
 3284 0e4c 42E0      		ldi r20,lo8(2)
 3285 0e4e 50E0      		ldi r21,hi8(2)
 3286 0e50 0E94 0000 		call strncmp_P
 3287 0e54 0097      		sbiw r24,0
 3288 0e56 01F4      		brne .L107
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 3290               	.LM315:
 3291 0e58 D801      		movw r26,r16
 3292 0e5a 5A96      		adiw r26,26
 3293 0e5c 8D91      		ld r24,X+
 3294 0e5e 9C91      		ld r25,X
 3295 0e60 5B97      		sbiw r26,26+1
 3296 0e62 6F2D      		mov r22,r15
 3297 0e64 0E94 0000 		call setUdpDebug
 3298               	.L108:
 381:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 3300               	.LM316:
 3301 0e68 00D0      		rcall .
 3302 0e6a 00D0      		rcall .
 3303 0e6c EDB7      		in r30,__SP_L__
 3304 0e6e FEB7      		in r31,__SP_H__
 3305 0e70 3196      		adiw r30,1
 3306 0e72 D801      		movw r26,r16
 3307 0e74 5A96      		adiw r26,26
 3308 0e76 8D91      		ld r24,X+
 3309 0e78 9C91      		ld r25,X
 3310 0e7a 5B97      		sbiw r26,26+1
 3311 0e7c ADB7      		in r26,__SP_L__
 3312 0e7e BEB7      		in r27,__SP_H__
 3313 0e80 1196      		adiw r26,1
 3314 0e82 8D93      		st X+,r24
 3315 0e84 9C93      		st X,r25
 3316 0e86 1297      		sbiw r26,1+1
 3317 0e88 80E0      		ldi r24,lo8(debugEnabledInfoStr)
 3318 0e8a 90E0      		ldi r25,hi8(debugEnabledInfoStr)
 3319               	.L109:
 3320 0e8c 8283      		std Z+2,r24
 3321 0e8e 9383      		std Z+3,r25
 3322 0e90 C483      		std Z+4,r28
 3323 0e92 D583      		std Z+5,r29
 3324 0e94 0E94 0000 		call fprintf_P
 382:vty.c         ****       return OK_SILENT;  
 3326               	.LM317:
 3327 0e98 EDB7      		in r30,__SP_L__
 3328 0e9a FEB7      		in r31,__SP_H__
 3329 0e9c 3696      		adiw r30,6
 3330 0e9e EDBF      		out __SP_L__,r30
 3331 0ea0 FEBF      		out __SP_H__,r31
 3332 0ea2 20E0      		ldi r18,lo8(0)
 3333 0ea4 30E0      		ldi r19,hi8(0)
 3334 0ea6 00C0      		rjmp .L95
 3335               	.L107:
 386:vty.c         ****   return SYNTAX_ERROR;
 3337               	.LM318:
 3338 0ea8 22E0      		ldi r18,lo8(2)
 3339 0eaa 30E0      		ldi r19,hi8(2)
 3340               	.L95:
 387:vty.c         **** }
 3342               	.LM319:
 3343 0eac C901      		movw r24,r18
 3344               	/* epilogue start */
 3345 0eae DF91      		pop r29
 3346 0eb0 CF91      		pop r28
 3347 0eb2 1F91      		pop r17
 3348 0eb4 0F91      		pop r16
 3349 0eb6 FF90      		pop r15
 3350 0eb8 0895      		ret
 3355               	.Lscope21:
 3357               		.stabd	78,0,0
 3361               	statusEncFunction:
 3362               		.stabd	46,0,0
 287:vty.c         **** {
 3364               	.LM320:
 3365               	.LFBB22:
 3366               	/* prologue: function */
 3367               	/* frame size = 0 */
 3368               	/* stack size = 0 */
 3369               	.L__stack_usage = 0
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 3371               	.LM321:
 3372 0eba FC01      		movw r30,r24
 3373 0ebc 828D      		ldd r24,Z+26
 3374 0ebe 938D      		ldd r25,Z+27
 3375 0ec0 0E94 0000 		call nicRegDump
 290:vty.c         **** }
 3377               	.LM322:
 3378 0ec4 80E0      		ldi r24,lo8(0)
 3379 0ec6 90E0      		ldi r25,hi8(0)
 3380               	/* epilogue start */
 3381 0ec8 0895      		ret
 3383               	.Lscope22:
 3385               		.stabd	78,0,0
 3389               	readRamFIleFunction:
 3390               		.stabd	46,0,0
 902:vty.c         **** {
 3392               	.LM323:
 3393               	.LFBB23:
 3394 0eca DF92      		push r13
 3395 0ecc EF92      		push r14
 3396 0ece FF92      		push r15
 3397 0ed0 0F93      		push r16
 3398 0ed2 1F93      		push r17
 3399 0ed4 DF93      		push r29
 3400 0ed6 CF93      		push r28
 3401 0ed8 0F92      		push __tmp_reg__
 3402 0eda CDB7      		in r28,__SP_L__
 3403 0edc DEB7      		in r29,__SP_H__
 3404               	/* prologue: function */
 3405               	/* frame size = 1 */
 3406               	/* stack size = 8 */
 3407               	.L__stack_usage = 8
 3408 0ede 8C01      		movw r16,r24
 904:vty.c         ****   uint8_t znak = ' ';
 3410               	.LM324:
 3411 0ee0 80E2      		ldi r24,lo8(32)
 3412 0ee2 8983      		std Y+1,r24
 905:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 3414               	.LM325:
 3415 0ee4 81E0      		ldi r24,lo8(1)
 3416 0ee6 B801      		movw r22,r16
 3417 0ee8 0E94 0000 		call cmdlineGetArgStr
 3418 0eec 60E0      		ldi r22,lo8(fdVty)
 3419 0eee 70E0      		ldi r23,hi8(fdVty)
 3420 0ef0 0E94 0000 		call ramDyskOtworzPlik
 3421 0ef4 D801      		movw r26,r16
 3422 0ef6 5A96      		adiw r26,26
 3423 0ef8 ED90      		ld r14,X+
 3424 0efa FC90      		ld r15,X
 3425 0efc 5B97      		sbiw r26,26+1
 3426 0efe 8823      		tst r24
 3427 0f00 01F0      		breq .L113
 907:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 3429               	.LM326:
 3430 0f02 81E0      		ldi r24,lo8(1)
 3431 0f04 B801      		movw r22,r16
 3432 0f06 0E94 0000 		call cmdlineGetArgStr
 3433 0f0a 00D0      		rcall .
 3434 0f0c 00D0      		rcall .
 3435 0f0e EDB7      		in r30,__SP_L__
 3436 0f10 FEB7      		in r31,__SP_H__
 3437 0f12 3196      		adiw r30,1
 3438 0f14 ADB7      		in r26,__SP_L__
 3439 0f16 BEB7      		in r27,__SP_H__
 3440 0f18 1196      		adiw r26,1
 3441 0f1a ED92      		st X+,r14
 3442 0f1c FC92      		st X,r15
 3443 0f1e 1297      		sbiw r26,1+1
 3444 0f20 20E0      		ldi r18,lo8(errorOpenFile)
 3445 0f22 30E0      		ldi r19,hi8(errorOpenFile)
 3446 0f24 2283      		std Z+2,r18
 3447 0f26 3383      		std Z+3,r19
 3448 0f28 8483      		std Z+4,r24
 3449 0f2a 9583      		std Z+5,r25
 3450 0f2c 0E94 0000 		call fprintf_P
 908:vty.c         ****     return ERROR_INFORM;
 3452               	.LM327:
 3453 0f30 EDB7      		in r30,__SP_L__
 3454 0f32 FEB7      		in r31,__SP_H__
 3455 0f34 3696      		adiw r30,6
 3456 0f36 EDBF      		out __SP_L__,r30
 3457 0f38 FEBF      		out __SP_H__,r31
 3458 0f3a 24E0      		ldi r18,lo8(4)
 3459 0f3c 30E0      		ldi r19,hi8(4)
 3460 0f3e 00C0      		rjmp .L114
 3461               	.L113:
 910:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 3463               	.LM328:
 3464 0f40 A091 0000 		lds r26,fdVty+4
 3465 0f44 B091 0000 		lds r27,fdVty+4+1
 911:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 3467               	.LM329:
 3468 0f48 00D0      		rcall .
 3469 0f4a 00D0      		rcall .
 3470 0f4c 4DB7      		in r20,__SP_L__
 3471 0f4e 5EB7      		in r21,__SP_H__
 3472 0f50 4F5F      		subi r20,lo8(-(1))
 3473 0f52 5F4F      		sbci r21,hi8(-(1))
 3474 0f54 EDB7      		in r30,__SP_L__
 3475 0f56 FEB7      		in r31,__SP_H__
 3476 0f58 E182      		std Z+1,r14
 3477 0f5a F282      		std Z+2,r15
 3478 0f5c 80E0      		ldi r24,lo8(readRamFIleLenStr)
 3479 0f5e 90E0      		ldi r25,hi8(readRamFIleLenStr)
 3480 0f60 FA01      		movw r30,r20
 3481 0f62 8283      		std Z+2,r24
 3482 0f64 9383      		std Z+3,r25
 910:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 3484               	.LM330:
 3485 0f66 1296      		adiw r26,2
 3486 0f68 9C91      		ld r25,X
 3487 0f6a 1297      		sbiw r26,2
 3488 0f6c 80E0      		ldi r24,lo8(0)
 3489 0f6e 1196      		adiw r26,1
 3490 0f70 2C91      		ld r18,X
 3491 0f72 820F      		add r24,r18
 3492 0f74 911D      		adc r25,__zero_reg__
 911:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 3494               	.LM331:
 3495 0f76 8483      		std Z+4,r24
 3496 0f78 9583      		std Z+5,r25
 3497 0f7a 0E94 0000 		call fprintf_P
 3498 0f7e 8DB7      		in r24,__SP_L__
 3499 0f80 9EB7      		in r25,__SP_H__
 3500 0f82 0696      		adiw r24,6
 3501 0f84 8DBF      		out __SP_L__,r24
 3502 0f86 9EBF      		out __SP_H__,r25
 914:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 3504               	.LM332:
 3505 0f88 7E01      		movw r14,r28
 3506 0f8a 0894      		sec
 3507 0f8c E11C      		adc r14,__zero_reg__
 3508 0f8e F11C      		adc r15,__zero_reg__
 3509               	.L116:
 3510 0f90 80E0      		ldi r24,lo8(fdVty)
 3511 0f92 90E0      		ldi r25,hi8(fdVty)
 3512 0f94 B701      		movw r22,r14
 3513 0f96 0E94 0000 		call ramDyskCzytajBajtZPliku
 3514 0f9a D82E      		mov r13,r24
 916:vty.c         ****     uartVtySendByte(znak);
 3516               	.LM333:
 3517 0f9c 8981      		ldd r24,Y+1
 3518 0f9e 0E94 0000 		call uartVtySendByte
 917:vty.c         ****     if (znak == '\r')
 3520               	.LM334:
 3521 0fa2 8981      		ldd r24,Y+1
 3522 0fa4 8D30      		cpi r24,lo8(13)
 3523 0fa6 01F4      		brne .L115
 918:vty.c         ****       uartVtySendByte('\n');
 3525               	.LM335:
 3526 0fa8 8AE0      		ldi r24,lo8(10)
 3527 0faa 0E94 0000 		call uartVtySendByte
 3528               	.L115:
 912:vty.c         ****   while (rezultat == 0)
 3530               	.LM336:
 3531 0fae DD20      		tst r13
 3532 0fb0 01F0      		breq .L116
 920:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 3534               	.LM337:
 3535 0fb2 00D0      		rcall .
 3536 0fb4 0F92      		push __tmp_reg__
 3537 0fb6 D801      		movw r26,r16
 3538 0fb8 5A96      		adiw r26,26
 3539 0fba 8D91      		ld r24,X+
 3540 0fbc 9C91      		ld r25,X
 3541 0fbe 5B97      		sbiw r26,26+1
 3542 0fc0 EDB7      		in r30,__SP_L__
 3543 0fc2 FEB7      		in r31,__SP_H__
 3544 0fc4 8183      		std Z+1,r24
 3545 0fc6 9283      		std Z+2,r25
 3546 0fc8 80E0      		ldi r24,lo8(nlStr)
 3547 0fca 90E0      		ldi r25,hi8(nlStr)
 3548 0fcc 8383      		std Z+3,r24
 3549 0fce 9483      		std Z+4,r25
 3550 0fd0 0E94 0000 		call fprintf_P
 921:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 3552               	.LM338:
 3553 0fd4 0F90      		pop __tmp_reg__
 3554 0fd6 0F90      		pop __tmp_reg__
 3555 0fd8 0F90      		pop __tmp_reg__
 3556 0fda 0F90      		pop __tmp_reg__
 3557 0fdc 80E0      		ldi r24,lo8(fdVty)
 3558 0fde 90E0      		ldi r25,hi8(fdVty)
 3559 0fe0 0E94 0000 		call ramDyskZamknijPlik
 922:vty.c         ****   return OK_SILENT;
 3561               	.LM339:
 3562 0fe4 20E0      		ldi r18,lo8(0)
 3563 0fe6 30E0      		ldi r19,hi8(0)
 3564               	.L114:
 923:vty.c         **** }
 3566               	.LM340:
 3567 0fe8 C901      		movw r24,r18
 3568               	/* epilogue start */
 3569 0fea 0F90      		pop __tmp_reg__
 3570 0fec CF91      		pop r28
 3571 0fee DF91      		pop r29
 3572 0ff0 1F91      		pop r17
 3573 0ff2 0F91      		pop r16
 3574 0ff4 FF90      		pop r15
 3575 0ff6 EF90      		pop r14
 3576 0ff8 DF90      		pop r13
 3577 0ffa 0895      		ret
 3582               	.Lscope23:
 3584               		.stabd	78,0,0
 3588               	writeRamFileFunction:
 3589               		.stabd	46,0,0
 871:vty.c         **** {
 3591               	.LM341:
 3592               	.LFBB24:
 3593               	/* prologue: function */
 3594               	/* frame size = 0 */
 3595               	/* stack size = 0 */
 3596               	.L__stack_usage = 0
 872:vty.c         ****   ramDyskDir(state->myStdInOut);
 3598               	.LM342:
 3599 0ffc FC01      		movw r30,r24
 3600 0ffe 828D      		ldd r24,Z+26
 3601 1000 938D      		ldd r25,Z+27
 3602 1002 0E94 0000 		call ramDyskDir
 874:vty.c         **** }
 3604               	.LM343:
 3605 1006 80E0      		ldi r24,lo8(0)
 3606 1008 90E0      		ldi r25,hi8(0)
 3607               	/* epilogue start */
 3608 100a 0895      		ret
 3610               	.Lscope24:
 3612               		.stabd	78,0,0
 3616               	pokazCzasFunction:
 3617               		.stabd	46,0,0
 293:vty.c         **** {
 3619               	.LM344:
 3620               	.LFBB25:
 3621 100c CF93      		push r28
 3622 100e DF93      		push r29
 3623               	/* prologue: function */
 3624               	/* frame size = 0 */
 3625               	/* stack size = 2 */
 3626               	.L__stack_usage = 2
 3627 1010 EC01      		movw r28,r24
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 3629               	.LM345:
 3630 1012 80E0      		ldi r24,lo8(czasRtc)
 3631 1014 90E0      		ldi r25,hi8(czasRtc)
 3632 1016 0E94 0000 		call readTimeDecoded
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 3634               	.LM346:
 3635 101a 4091 0000 		lds r20,czasRtc+2
 3636 101e 4695      		lsr r20
 3637 1020 4695      		lsr r20
 3638 1022 4695      		lsr r20
 3639 1024 7091 0000 		lds r23,czasRtc+2
 3640 1028 7F70      		andi r23,lo8(15)
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 3642               	.LM347:
 3643 102a 3091 0000 		lds r19,czasRtc+1
 3644 102e 3695      		lsr r19
 3645 1030 3695      		lsr r19
 3646 1032 3695      		lsr r19
 3647 1034 6091 0000 		lds r22,czasRtc+1
 3648 1038 6F70      		andi r22,lo8(15)
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 3650               	.LM348:
 3651 103a 2091 0000 		lds r18,czasRtc
 3652 103e 2695      		lsr r18
 3653 1040 2695      		lsr r18
 3654 1042 2695      		lsr r18
 3655 1044 5091 0000 		lds r21,czasRtc
 3656 1048 5F70      		andi r21,lo8(15)
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 3658               	.LM349:
 3659 104a 8DB7      		in r24,__SP_L__
 3660 104c 9EB7      		in r25,__SP_H__
 3661 104e 0A97      		sbiw r24,10
 3662 1050 8DBF      		out __SP_L__,r24
 3663 1052 9EBF      		out __SP_H__,r25
 3664 1054 EDB7      		in r30,__SP_L__
 3665 1056 FEB7      		in r31,__SP_H__
 3666 1058 3196      		adiw r30,1
 3667 105a 8A8D      		ldd r24,Y+26
 3668 105c 9B8D      		ldd r25,Y+27
 3669 105e ADB7      		in r26,__SP_L__
 3670 1060 BEB7      		in r27,__SP_H__
 3671 1062 1196      		adiw r26,1
 3672 1064 8D93      		st X+,r24
 3673 1066 9C93      		st X,r25
 3674 1068 1297      		sbiw r26,1+1
 3675 106a 80E0      		ldi r24,lo8(__c.5134)
 3676 106c 90E0      		ldi r25,hi8(__c.5134)
 3677 106e 8283      		std Z+2,r24
 3678 1070 9383      		std Z+3,r25
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 3680               	.LM350:
 3681 1072 4670      		andi r20,lo8(6)
 3682 1074 842F      		mov r24,r20
 3683 1076 880F      		lsl r24
 3684 1078 880F      		lsl r24
 3685 107a 840F      		add r24,r20
 3686 107c 870F      		add r24,r23
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 3688               	.LM351:
 3689 107e 8483      		std Z+4,r24
 3690 1080 1582      		std Z+5,__zero_reg__
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 3692               	.LM352:
 3693 1082 3E70      		andi r19,lo8(14)
 3694 1084 832F      		mov r24,r19
 3695 1086 880F      		lsl r24
 3696 1088 880F      		lsl r24
 3697 108a 830F      		add r24,r19
 3698 108c 860F      		add r24,r22
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 3700               	.LM353:
 3701 108e 8683      		std Z+6,r24
 3702 1090 1782      		std Z+7,__zero_reg__
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 3704               	.LM354:
 3705 1092 2E70      		andi r18,lo8(14)
 3706 1094 822F      		mov r24,r18
 3707 1096 880F      		lsl r24
 3708 1098 880F      		lsl r24
 3709 109a 820F      		add r24,r18
 3710 109c 850F      		add r24,r21
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 3712               	.LM355:
 3713 109e 8087      		std Z+8,r24
 3714 10a0 1186      		std Z+9,__zero_reg__
 3715 10a2 0E94 0000 		call fprintf_P
 3716 10a6 8DB7      		in r24,__SP_L__
 3717 10a8 9EB7      		in r25,__SP_H__
 3718 10aa 0A96      		adiw r24,10
 3719 10ac 8DBF      		out __SP_L__,r24
 3720 10ae 9EBF      		out __SP_H__,r25
 300:vty.c         **** }
 3722               	.LM356:
 3723 10b0 80E0      		ldi r24,lo8(0)
 3724 10b2 90E0      		ldi r25,hi8(0)
 3725               	/* epilogue start */
 3726 10b4 DF91      		pop r29
 3727 10b6 CF91      		pop r28
 3728 10b8 0895      		ret
 3730               	.Lscope25:
 3732               		.stabd	78,0,0
 3736               	helpFunction:
 3737               		.stabd	46,0,0
 503:vty.c         **** {
 3739               	.LM357:
 3740               	.LFBB26:
 3741               	/* prologue: function */
 3742               	/* frame size = 0 */
 3743               	/* stack size = 0 */
 3744               	.L__stack_usage = 0
 504:vty.c         ****   cmdPrintHelp(state);
 3746               	.LM358:
 3747 10ba 0E94 0000 		call cmdPrintHelp
 506:vty.c         **** }
 3749               	.LM359:
 3750 10be 80E0      		ldi r24,lo8(0)
 3751 10c0 90E0      		ldi r25,hi8(0)
 3752               	/* epilogue start */
 3753 10c2 0895      		ret
 3755               	.Lscope26:
 3757               		.stabd	78,0,0
 3761               	.global	VtyInit
 3763               	VtyInit:
 3764               		.stabd	46,0,0
 160:vty.c         **** {
 3766               	.LM360:
 3767               	.LFBB27:
 3768 10c4 EF92      		push r14
 3769 10c6 0F93      		push r16
 3770 10c8 1F93      		push r17
 3771               	/* prologue: function */
 3772               	/* frame size = 0 */
 3773               	/* stack size = 3 */
 3774               	.L__stack_usage = 3
 3775 10ca 9B01      		movw r18,r22
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 3777               	.LM361:
 3778 10cc 60E0      		ldi r22,lo8(10240)
 3779 10ce 78E2      		ldi r23,hi8(10240)
 3780 10d0 40E0      		ldi r20,lo8(256)
 3781 10d2 51E0      		ldi r21,hi8(256)
 3782 10d4 00E0      		ldi r16,lo8(cmdListNormal)
 3783 10d6 10E0      		ldi r17,hi8(cmdListNormal)
 3784 10d8 EE24      		clr r14
 3785 10da 0E94 0000 		call cmdStateConfigure
 3786               	/* epilogue start */
 162:vty.c         **** }
 3788               	.LM362:
 3789 10de 1F91      		pop r17
 3790 10e0 0F91      		pop r16
 3791 10e2 EF90      		pop r14
 3792 10e4 0895      		ret
 3794               	.Lscope27:
 3796               		.stabd	78,0,0
 3799               	.global	printErrorInfo
 3801               	printErrorInfo:
 3802               		.stabd	46,0,0
 165:vty.c         **** {
 3804               	.LM363:
 3805               	.LFBB28:
 3806 10e6 CF93      		push r28
 3807 10e8 DF93      		push r29
 3808               	/* prologue: function */
 3809               	/* frame size = 0 */
 3810               	/* stack size = 2 */
 3811               	.L__stack_usage = 2
 3812 10ea EC01      		movw r28,r24
 166:vty.c         ****   if (state->errno != 0)
 3814               	.LM364:
 3815 10ec EC8D      		ldd r30,Y+28
 3816 10ee EE23      		tst r30
 3817 10f0 01F0      		breq .L123
 3818               	.LBB7:
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 3820               	.LM365:
 3821 10f2 F0E0      		ldi r31,lo8(0)
 3822 10f4 EE0F      		lsl r30
 3823 10f6 FF1F      		rol r31
 3824 10f8 E050      		subi r30,lo8(-(errorStrings))
 3825 10fa F040      		sbci r31,hi8(-(errorStrings))
 3826               	/* #APP */
 3827               	 ;  168 "vty.c" 1
 3828 10fc 8591      		lpm r24, Z+
 3829 10fe 9491      		lpm r25, Z
 3830               		
 3831               	 ;  0 "" 2
 3832               	/* #NOAPP */
 3833               	.LBE7:
 3834 1100 2DB7      		in r18,__SP_L__
 3835 1102 3EB7      		in r19,__SP_H__
 3836 1104 2850      		subi r18,lo8(-(-8))
 3837 1106 3040      		sbci r19,hi8(-(-8))
 3838 1108 2DBF      		out __SP_L__,r18
 3839 110a 3EBF      		out __SP_H__,r19
 3840 110c EDB7      		in r30,__SP_L__
 3841 110e FEB7      		in r31,__SP_H__
 3842 1110 3196      		adiw r30,1
 3843 1112 2A8D      		ldd r18,Y+26
 3844 1114 3B8D      		ldd r19,Y+27
 3845 1116 ADB7      		in r26,__SP_L__
 3846 1118 BEB7      		in r27,__SP_H__
 3847 111a 1196      		adiw r26,1
 3848 111c 2D93      		st X+,r18
 3849 111e 3C93      		st X,r19
 3850 1120 1297      		sbiw r26,1+1
 3851 1122 8283      		std Z+2,r24
 3852 1124 9383      		std Z+3,r25
 3853 1126 8D8D      		ldd r24,Y+29
 3854 1128 9E8D      		ldd r25,Y+30
 3855 112a 8483      		std Z+4,r24
 3856 112c 9583      		std Z+5,r25
 3857 112e 8F8D      		ldd r24,Y+31
 3858 1130 8683      		std Z+6,r24
 3859 1132 1782      		std Z+7,__zero_reg__
 3860 1134 0E94 0000 		call fprintf_P
 3861 1138 2DB7      		in r18,__SP_L__
 3862 113a 3EB7      		in r19,__SP_H__
 3863 113c 285F      		subi r18,lo8(-(8))
 3864 113e 3F4F      		sbci r19,hi8(-(8))
 3865 1140 2DBF      		out __SP_L__,r18
 3866 1142 3EBF      		out __SP_H__,r19
 3867               	.L123:
 170:vty.c         ****   state->errno = 0;
 3869               	.LM366:
 3870 1144 1C8E      		std Y+28,__zero_reg__
 171:vty.c         ****   state->err1 = 0;
 3872               	.LM367:
 3873 1146 1D8E      		std Y+29,__zero_reg__
 3874 1148 1E8E      		std Y+30,__zero_reg__
 172:vty.c         ****   state->err2 = 0;
 3876               	.LM368:
 3877 114a 1F8E      		std Y+31,__zero_reg__
 3878               	/* epilogue start */
 173:vty.c         **** }
 3880               	.LM369:
 3881 114c DF91      		pop r29
 3882 114e CF91      		pop r28
 3883 1150 0895      		ret
 3888               	.Lscope28:
 3890               		.stabd	78,0,0
 3894               	eraseRamFileFunction:
 3895               		.stabd	46,0,0
 849:vty.c         **** {
 3897               	.LM370:
 3898               	.LFBB29:
 3899 1152 CF93      		push r28
 3900 1154 DF93      		push r29
 3901               	/* prologue: function */
 3902               	/* frame size = 0 */
 3903               	/* stack size = 2 */
 3904               	.L__stack_usage = 2
 3905 1156 EC01      		movw r28,r24
 850:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 3907               	.LM371:
 3908 1158 81E0      		ldi r24,lo8(1)
 3909 115a BE01      		movw r22,r28
 3910 115c 0E94 0000 		call cmdlineGetArgStr
 3911 1160 0E94 0000 		call ramDyskUsunPlik
 3912 1164 8823      		tst r24
 3913 1166 01F0      		breq .L126
 853:vty.c         ****   printErrorInfo(state);
 3915               	.LM372:
 3916 1168 CE01      		movw r24,r28
 3917 116a 0E94 0000 		call printErrorInfo
 854:vty.c         ****   return ERROR_INFORM;
 3919               	.LM373:
 3920 116e 24E0      		ldi r18,lo8(4)
 3921 1170 30E0      		ldi r19,hi8(4)
 3922 1172 00C0      		rjmp .L125
 3923               	.L126:
 851:vty.c         ****     return OK_INFORM;
 3925               	.LM374:
 3926 1174 21E0      		ldi r18,lo8(1)
 3927 1176 30E0      		ldi r19,hi8(1)
 3928               	.L125:
 855:vty.c         **** }
 3930               	.LM375:
 3931 1178 C901      		movw r24,r18
 3932               	/* epilogue start */
 3933 117a DF91      		pop r29
 3934 117c CF91      		pop r28
 3935 117e 0895      		ret
 3937               	.Lscope29:
 3939               		.stabd	78,0,0
 3943               	dodajRamPlikFunction:
 3944               		.stabd	46,0,0
 858:vty.c         **** {
 3946               	.LM376:
 3947               	.LFBB30:
 3948 1180 CF93      		push r28
 3949 1182 DF93      		push r29
 3950               	/* prologue: function */
 3951               	/* frame size = 0 */
 3952               	/* stack size = 2 */
 3953               	.L__stack_usage = 2
 3954 1184 EC01      		movw r28,r24
 859:vty.c         ****   if (state->argc != 1)
 3956               	.LM377:
 3957 1186 898D      		ldd r24,Y+25
 3958 1188 8130      		cpi r24,lo8(1)
 3959 118a 01F4      		brne .L129
 862:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 3961               	.LM378:
 3962 118c BE01      		movw r22,r28
 3963 118e 0E94 0000 		call cmdlineGetArgStr
 3964 1192 0E94 0000 		call ramDyskUtworzPlik
 3965 1196 8823      		tst r24
 3966 1198 01F0      		breq .L130
 866:vty.c         ****   printErrorInfo(state);
 3968               	.LM379:
 3969 119a CE01      		movw r24,r28
 3970 119c 0E94 0000 		call printErrorInfo
 867:vty.c         ****   return ERROR_INFORM;
 3972               	.LM380:
 3973 11a0 24E0      		ldi r18,lo8(4)
 3974 11a2 30E0      		ldi r19,hi8(4)
 3975 11a4 00C0      		rjmp .L128
 3976               	.L129:
 860:vty.c         ****     return SYNTAX_ERROR;
 3978               	.LM381:
 3979 11a6 22E0      		ldi r18,lo8(2)
 3980 11a8 30E0      		ldi r19,hi8(2)
 3981 11aa 00C0      		rjmp .L128
 3982               	.L130:
 864:vty.c         ****     return OK_INFORM;
 3984               	.LM382:
 3985 11ac 21E0      		ldi r18,lo8(1)
 3986 11ae 30E0      		ldi r19,hi8(1)
 3987               	.L128:
 868:vty.c         **** }
 3989               	.LM383:
 3990 11b0 C901      		movw r24,r18
 3991               	/* epilogue start */
 3992 11b2 DF91      		pop r29
 3993 11b4 CF91      		pop r28
 3994 11b6 0895      		ret
 3996               	.Lscope30:
 3998               		.stabd	78,0,0
 4002               	flashExModuleFunction:
 4003               		.stabd	46,0,0
 616:vty.c         **** {
 4005               	.LM384:
 4006               	.LFBB31:
 4007 11b8 FF92      		push r15
 4008 11ba 0F93      		push r16
 4009 11bc 1F93      		push r17
 4010 11be CF93      		push r28
 4011 11c0 DF93      		push r29
 4012               	/* prologue: function */
 4013               	/* frame size = 0 */
 4014               	/* stack size = 5 */
 4015               	.L__stack_usage = 5
 4016 11c2 EC01      		movw r28,r24
 617:vty.c         ****   if (state->argc != 2)
 4018               	.LM385:
 4019 11c4 898D      		ldd r24,Y+25
 4020 11c6 8230      		cpi r24,lo8(2)
 4021 11c8 01F0      		breq .+2
 4022 11ca 00C0      		rjmp .L135
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 4024               	.LM386:
 4025 11cc 81E0      		ldi r24,lo8(1)
 4026 11ce BE01      		movw r22,r28
 4027 11d0 0E94 0000 		call cmdlineGetArgInt
 4028 11d4 F62E      		mov r15,r22
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 4030               	.LM387:
 4031 11d6 82E0      		ldi r24,lo8(2)
 4032 11d8 BE01      		movw r22,r28
 4033 11da 0E94 0000 		call cmdlineGetArgStr
 4034 11de 8C01      		movw r16,r24
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 4036               	.LM388:
 4037 11e0 8F2D      		mov r24,r15
 4038 11e2 0E94 0000 		call rs485ping
 4039 11e6 8823      		tst r24
 4040 11e8 01F0      		breq .L133
 627:vty.c         ****     state->errno = noRemoteDevice;
 4042               	.LM389:
 4043 11ea 89E0      		ldi r24,lo8(9)
 4044 11ec 8C8F      		std Y+28,r24
 628:vty.c         ****     printErrorInfo(state);
 4046               	.LM390:
 4047 11ee CE01      		movw r24,r28
 4048 11f0 0E94 0000 		call printErrorInfo
 4049 11f4 00C0      		rjmp .L137
 4050               	.L133:
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 4052               	.LM391:
 4053 11f6 C801      		movw r24,r16
 4054 11f8 60E0      		ldi r22,lo8(fdVty)
 4055 11fa 70E0      		ldi r23,hi8(fdVty)
 4056 11fc 0E94 0000 		call ramDyskOtworzPlik
 4057 1200 4A8D      		ldd r20,Y+26
 4058 1202 5B8D      		ldd r21,Y+27
 4059 1204 8823      		tst r24
 4060 1206 01F0      		breq .L134
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 4062               	.LM392:
 4063 1208 00D0      		rcall .
 4064 120a 00D0      		rcall .
 4065 120c EDB7      		in r30,__SP_L__
 4066 120e FEB7      		in r31,__SP_H__
 4067 1210 3196      		adiw r30,1
 4068 1212 ADB7      		in r26,__SP_L__
 4069 1214 BEB7      		in r27,__SP_H__
 4070 1216 1196      		adiw r26,1
 4071 1218 4D93      		st X+,r20
 4072 121a 5C93      		st X,r21
 4073 121c 1297      		sbiw r26,1+1
 4074 121e 80E0      		ldi r24,lo8(errorOpenFile)
 4075 1220 90E0      		ldi r25,hi8(errorOpenFile)
 4076 1222 8283      		std Z+2,r24
 4077 1224 9383      		std Z+3,r25
 4078 1226 0483      		std Z+4,r16
 4079 1228 1583      		std Z+5,r17
 4080 122a 0E94 0000 		call fprintf_P
 636:vty.c         ****     return ERROR_INFORM;
 4082               	.LM393:
 4083 122e 8DB7      		in r24,__SP_L__
 4084 1230 9EB7      		in r25,__SP_H__
 4085 1232 0696      		adiw r24,6
 4086 1234 8DBF      		out __SP_L__,r24
 4087 1236 9EBF      		out __SP_H__,r25
 4088 1238 00C0      		rjmp .L137
 4089               	.L134:
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 4091               	.LM394:
 4092 123a 80E0      		ldi r24,lo8(fdVty)
 4093 123c 90E0      		ldi r25,hi8(fdVty)
 4094 123e 6F2D      		mov r22,r15
 4095 1240 0E94 0000 		call rs485xModemFlash
 4096 1244 082F      		mov r16,r24
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 4098               	.LM395:
 4099 1246 80E0      		ldi r24,lo8(fdVty)
 4100 1248 90E0      		ldi r25,hi8(fdVty)
 4101 124a 0E94 0000 		call ramDyskZamknijPlik
 643:vty.c         ****   if (blad != 0)
 4103               	.LM396:
 4104 124e 0023      		tst r16
 4105 1250 01F0      		breq .L136
 4106               	.L137:
 644:vty.c         ****     return ERROR_INFORM;
 4108               	.LM397:
 4109 1252 24E0      		ldi r18,lo8(4)
 4110 1254 30E0      		ldi r19,hi8(4)
 4111 1256 00C0      		rjmp .L132
 4112               	.L135:
 618:vty.c         ****     return SYNTAX_ERROR;
 4114               	.LM398:
 4115 1258 22E0      		ldi r18,lo8(2)
 4116 125a 30E0      		ldi r19,hi8(2)
 4117 125c 00C0      		rjmp .L132
 4118               	.L136:
 646:vty.c         ****   return OK_SILENT;
 4120               	.LM399:
 4121 125e 20E0      		ldi r18,lo8(0)
 4122 1260 30E0      		ldi r19,hi8(0)
 4123               	.L132:
 647:vty.c         **** }
 4125               	.LM400:
 4126 1262 C901      		movw r24,r18
 4127               	/* epilogue start */
 4128 1264 DF91      		pop r29
 4129 1266 CF91      		pop r28
 4130 1268 1F91      		pop r17
 4131 126a 0F91      		pop r16
 4132 126c FF90      		pop r15
 4133 126e 0895      		ret
 4139               	.Lscope31:
 4141               		.stabd	78,0,0
 4145               	rpingFunction:
 4146               		.stabd	46,0,0
 584:vty.c         **** {
 4148               	.LM401:
 4149               	.LFBB32:
 4150 1270 0F93      		push r16
 4151 1272 1F93      		push r17
 4152 1274 DF93      		push r29
 4153 1276 CF93      		push r28
 4154 1278 0F92      		push __tmp_reg__
 4155 127a CDB7      		in r28,__SP_L__
 4156 127c DEB7      		in r29,__SP_H__
 4157               	/* prologue: function */
 4158               	/* frame size = 1 */
 4159               	/* stack size = 5 */
 4160               	.L__stack_usage = 5
 4161 127e 8C01      		movw r16,r24
 585:vty.c         ****   if (state->argc < 1)
 4163               	.LM402:
 4164 1280 FC01      		movw r30,r24
 4165 1282 818D      		ldd r24,Z+25
 4166 1284 8823      		tst r24
 4167 1286 01F0      		breq .L140
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 4169               	.LM403:
 4170 1288 81E0      		ldi r24,lo8(1)
 4171 128a B801      		movw r22,r16
 4172 128c 0E94 0000 		call cmdlineGetArgInt
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 4174               	.LM404:
 4175 1290 862F      		mov r24,r22
 4176 1292 6983      		std Y+1,r22
 4177 1294 0E94 0000 		call rs485ping
 4178 1298 F801      		movw r30,r16
 4179 129a 878F      		std Z+31,r24
 4180 129c 6981      		ldd r22,Y+1
 4181 129e 8823      		tst r24
 4182 12a0 01F0      		breq .L141
 592:vty.c         ****   state->errno = noRemoteDevice;
 4184               	.LM405:
 4185 12a2 89E0      		ldi r24,lo8(9)
 4186 12a4 848F      		std Z+28,r24
 593:vty.c         ****   state->err1 = nrSterownika;
 4188               	.LM406:
 4189 12a6 658F      		std Z+29,r22
 4190 12a8 168E      		std Z+30,__zero_reg__
 594:vty.c         ****   printErrorInfo(state);
 4192               	.LM407:
 4193 12aa C801      		movw r24,r16
 4194 12ac 0E94 0000 		call printErrorInfo
 595:vty.c         ****   return OK_SILENT;
 4196               	.LM408:
 4197 12b0 20E0      		ldi r18,lo8(0)
 4198 12b2 30E0      		ldi r19,hi8(0)
 4199 12b4 00C0      		rjmp .L139
 4200               	.L140:
 586:vty.c         ****     return SYNTAX_ERROR;
 4202               	.LM409:
 4203 12b6 22E0      		ldi r18,lo8(2)
 4204 12b8 30E0      		ldi r19,hi8(2)
 4205 12ba 00C0      		rjmp .L139
 4206               	.L141:
 590:vty.c         ****     return OK_INFORM;
 4208               	.LM410:
 4209 12bc 21E0      		ldi r18,lo8(1)
 4210 12be 30E0      		ldi r19,hi8(1)
 4211               	.L139:
 596:vty.c         **** }
 4213               	.LM411:
 4214 12c0 C901      		movw r24,r18
 4215               	/* epilogue start */
 4216 12c2 0F90      		pop __tmp_reg__
 4217 12c4 CF91      		pop r28
 4218 12c6 DF91      		pop r29
 4219 12c8 1F91      		pop r17
 4220 12ca 0F91      		pop r16
 4221 12cc 0895      		ret
 4223               	.Lscope32:
 4225               		.stabd	78,0,0
 4228               	.global	printStatus
 4230               	printStatus:
 4231               		.stabd	46,0,0
 207:vty.c         **** {
 4233               	.LM412:
 4234               	.LFBB33:
 4235 12ce CF93      		push r28
 4236 12d0 DF93      		push r29
 4237               	/* prologue: function */
 4238               	/* frame size = 0 */
 4239               	/* stack size = 2 */
 4240               	.L__stack_usage = 2
 4241 12d2 EC01      		movw r28,r24
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 4243               	.LM413:
 4244 12d4 00D0      		rcall .
 4245 12d6 0F92      		push __tmp_reg__
 4246 12d8 ADB7      		in r26,__SP_L__
 4247 12da BEB7      		in r27,__SP_H__
 4248 12dc 1196      		adiw r26,1
 4249 12de 8D93      		st X+,r24
 4250 12e0 9C93      		st X,r25
 4251 12e2 1297      		sbiw r26,1+1
 4252 12e4 80E0      		ldi r24,lo8(__c.5110)
 4253 12e6 90E0      		ldi r25,hi8(__c.5110)
 4254 12e8 1396      		adiw r26,3
 4255 12ea 8D93      		st X+,r24
 4256 12ec 9C93      		st X,r25
 4257 12ee 1497      		sbiw r26,3+1
 4258 12f0 0E94 0000 		call fprintf_P
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 4260               	.LM414:
 4261 12f4 EDB7      		in r30,__SP_L__
 4262 12f6 FEB7      		in r31,__SP_H__
 4263 12f8 C183      		std Z+1,r28
 4264 12fa D283      		std Z+2,r29
 4265 12fc 80E0      		ldi r24,lo8(systemStateStr)
 4266 12fe 90E0      		ldi r25,hi8(systemStateStr)
 4267 1300 8383      		std Z+3,r24
 4268 1302 9483      		std Z+4,r25
 4269 1304 0E94 0000 		call fprintf_P
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 4271               	.LM415:
 4272 1308 0F90      		pop __tmp_reg__
 4273 130a 0F90      		pop __tmp_reg__
 4274 130c 0F90      		pop __tmp_reg__
 4275 130e 0F90      		pop __tmp_reg__
 4276 1310 0E94 0000 		call uxTaskGetNumberOfTasks
 4277 1314 00D0      		rcall .
 4278 1316 00D0      		rcall .
 4279 1318 EDB7      		in r30,__SP_L__
 4280 131a FEB7      		in r31,__SP_H__
 4281 131c 3196      		adiw r30,1
 4282 131e ADB7      		in r26,__SP_L__
 4283 1320 BEB7      		in r27,__SP_H__
 4284 1322 1196      		adiw r26,1
 4285 1324 CD93      		st X+,r28
 4286 1326 DC93      		st X,r29
 4287 1328 1297      		sbiw r26,1+1
 4288 132a 20E0      		ldi r18,lo8(statusNumberOfTasksStr)
 4289 132c 30E0      		ldi r19,hi8(statusNumberOfTasksStr)
 4290 132e 2283      		std Z+2,r18
 4291 1330 3383      		std Z+3,r19
 4292 1332 8483      		std Z+4,r24
 4293 1334 1582      		std Z+5,__zero_reg__
 4294 1336 0E94 0000 		call fprintf_P
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 4296               	.LM416:
 4297 133a EDB7      		in r30,__SP_L__
 4298 133c FEB7      		in r31,__SP_H__
 4299 133e 3696      		adiw r30,6
 4300 1340 EDBF      		out __SP_L__,r30
 4301 1342 FEBF      		out __SP_H__,r31
 4302 1344 0E94 0000 		call xPortGetFreeHeapSize
 4303 1348 2DB7      		in r18,__SP_L__
 4304 134a 3EB7      		in r19,__SP_H__
 4305 134c 2850      		subi r18,lo8(-(-8))
 4306 134e 3040      		sbci r19,hi8(-(-8))
 4307 1350 2DBF      		out __SP_L__,r18
 4308 1352 3EBF      		out __SP_H__,r19
 4309 1354 EDB7      		in r30,__SP_L__
 4310 1356 FEB7      		in r31,__SP_H__
 4311 1358 3196      		adiw r30,1
 4312 135a ADB7      		in r26,__SP_L__
 4313 135c BEB7      		in r27,__SP_H__
 4314 135e 1196      		adiw r26,1
 4315 1360 CD93      		st X+,r28
 4316 1362 DC93      		st X,r29
 4317 1364 1297      		sbiw r26,1+1
 4318 1366 20E0      		ldi r18,lo8(statusStaticHeapStateStr)
 4319 1368 30E0      		ldi r19,hi8(statusStaticHeapStateStr)
 4320 136a 2283      		std Z+2,r18
 4321 136c 3383      		std Z+3,r19
 4322 136e 8483      		std Z+4,r24
 4323 1370 9583      		std Z+5,r25
 4324 1372 88EB      		ldi r24,lo8(3000)
 4325 1374 9BE0      		ldi r25,hi8(3000)
 4326 1376 8683      		std Z+6,r24
 4327 1378 9783      		std Z+7,r25
 4328 137a 0E94 0000 		call fprintf_P
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 4330               	.LM417:
 4331 137e EDB7      		in r30,__SP_L__
 4332 1380 FEB7      		in r31,__SP_H__
 4333 1382 3896      		adiw r30,8
 4334 1384 EDBF      		out __SP_L__,r30
 4335 1386 FEBF      		out __SP_H__,r31
 4336 1388 0E94 0000 		call xmallocAvailable
 4337 138c 2DB7      		in r18,__SP_L__
 4338 138e 3EB7      		in r19,__SP_H__
 4339 1390 2850      		subi r18,lo8(-(-8))
 4340 1392 3040      		sbci r19,hi8(-(-8))
 4341 1394 2DBF      		out __SP_L__,r18
 4342 1396 3EBF      		out __SP_H__,r19
 4343 1398 EDB7      		in r30,__SP_L__
 4344 139a FEB7      		in r31,__SP_H__
 4345 139c 3196      		adiw r30,1
 4346 139e ADB7      		in r26,__SP_L__
 4347 13a0 BEB7      		in r27,__SP_H__
 4348 13a2 1196      		adiw r26,1
 4349 13a4 CD93      		st X+,r28
 4350 13a6 DC93      		st X,r29
 4351 13a8 1297      		sbiw r26,1+1
 4352 13aa 20E0      		ldi r18,lo8(statusDynamicHeapStateStr)
 4353 13ac 30E0      		ldi r19,hi8(statusDynamicHeapStateStr)
 4354 13ae 2283      		std Z+2,r18
 4355 13b0 3383      		std Z+3,r19
 4356 13b2 8483      		std Z+4,r24
 4357 13b4 9583      		std Z+5,r25
 4358 13b6 80E0      		ldi r24,lo8(5888)
 4359 13b8 97E1      		ldi r25,hi8(5888)
 4360 13ba 8683      		std Z+6,r24
 4361 13bc 9783      		std Z+7,r25
 4362 13be 0E94 0000 		call fprintf_P
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 4364               	.LM418:
 4365 13c2 2091 0000 		lds r18,temperature
 4366 13c6 0F90      		pop __tmp_reg__
 4367 13c8 0F90      		pop __tmp_reg__
 4368 13ca EDB7      		in r30,__SP_L__
 4369 13cc FEB7      		in r31,__SP_H__
 4370 13ce 3196      		adiw r30,1
 4371 13d0 ADB7      		in r26,__SP_L__
 4372 13d2 BEB7      		in r27,__SP_H__
 4373 13d4 1196      		adiw r26,1
 4374 13d6 CD93      		st X+,r28
 4375 13d8 DC93      		st X,r29
 4376 13da 1297      		sbiw r26,1+1
 4377 13dc 80E0      		ldi r24,lo8(statusTemperatureStr)
 4378 13de 90E0      		ldi r25,hi8(statusTemperatureStr)
 4379 13e0 8283      		std Z+2,r24
 4380 13e2 9383      		std Z+3,r25
 4381 13e4 2483      		std Z+4,r18
 4382 13e6 1582      		std Z+5,__zero_reg__
 4383 13e8 0E94 0000 		call fprintf_P
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 4385               	.LM419:
 4386 13ec 2091 0000 		lds r18,voltage
 4387 13f0 EDB7      		in r30,__SP_L__
 4388 13f2 FEB7      		in r31,__SP_H__
 4389 13f4 3196      		adiw r30,1
 4390 13f6 ADB7      		in r26,__SP_L__
 4391 13f8 BEB7      		in r27,__SP_H__
 4392 13fa 1196      		adiw r26,1
 4393 13fc CD93      		st X+,r28
 4394 13fe DC93      		st X,r29
 4395 1400 1297      		sbiw r26,1+1
 4396 1402 80E0      		ldi r24,lo8(statusVoltageStr)
 4397 1404 90E0      		ldi r25,hi8(statusVoltageStr)
 4398 1406 8283      		std Z+2,r24
 4399 1408 9383      		std Z+3,r25
 4400 140a 2483      		std Z+4,r18
 4401 140c 1582      		std Z+5,__zero_reg__
 4402 140e 0E94 0000 		call fprintf_P
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 4404               	.LM420:
 4405 1412 EDB7      		in r30,__SP_L__
 4406 1414 FEB7      		in r31,__SP_H__
 4407 1416 3696      		adiw r30,6
 4408 1418 EDBF      		out __SP_L__,r30
 4409 141a FEBF      		out __SP_H__,r31
 4410 141c 0E94 0000 		call ramDyskLiczbaWolnychKlastrow
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 4412               	.LM421:
 4413 1420 2DB7      		in r18,__SP_L__
 4414 1422 3EB7      		in r19,__SP_H__
 4415 1424 2850      		subi r18,lo8(-(-8))
 4416 1426 3040      		sbci r19,hi8(-(-8))
 4417 1428 2DBF      		out __SP_L__,r18
 4418 142a 3EBF      		out __SP_H__,r19
 4419 142c EDB7      		in r30,__SP_L__
 4420 142e FEB7      		in r31,__SP_H__
 4421 1430 3196      		adiw r30,1
 4422 1432 ADB7      		in r26,__SP_L__
 4423 1434 BEB7      		in r27,__SP_H__
 4424 1436 1196      		adiw r26,1
 4425 1438 CD93      		st X+,r28
 4426 143a DC93      		st X,r29
 4427 143c 1297      		sbiw r26,1+1
 4428 143e 20E0      		ldi r18,lo8(statusRamDiskStateStr)
 4429 1440 30E0      		ldi r19,hi8(statusRamDiskStateStr)
 4430 1442 2283      		std Z+2,r18
 4431 1444 3383      		std Z+3,r19
 4432 1446 8483      		std Z+4,r24
 4433 1448 1582      		std Z+5,__zero_reg__
 4434 144a 80E8      		ldi r24,lo8(128)
 4435 144c 90E0      		ldi r25,hi8(128)
 4436 144e 8683      		std Z+6,r24
 4437 1450 9783      		std Z+7,r25
 4438 1452 0E94 0000 		call fprintf_P
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 4440               	.LM422:
 4441 1456 0F90      		pop __tmp_reg__
 4442 1458 0F90      		pop __tmp_reg__
 4443 145a 0F90      		pop __tmp_reg__
 4444 145c 0F90      		pop __tmp_reg__
 4445 145e EDB7      		in r30,__SP_L__
 4446 1460 FEB7      		in r31,__SP_H__
 4447 1462 C183      		std Z+1,r28
 4448 1464 D283      		std Z+2,r29
 4449 1466 80E0      		ldi r24,lo8(systemRamConfigStr)
 4450 1468 90E0      		ldi r25,hi8(systemRamConfigStr)
 4451 146a 8383      		std Z+3,r24
 4452 146c 9483      		std Z+4,r25
 4453 146e 0E94 0000 		call fprintf_P
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 4455               	.LM423:
 4456 1472 ADB7      		in r26,__SP_L__
 4457 1474 BEB7      		in r27,__SP_H__
 4458 1476 1196      		adiw r26,1
 4459 1478 CD93      		st X+,r28
 4460 147a DC93      		st X,r29
 4461 147c 1297      		sbiw r26,1+1
 4462 147e 80E0      		ldi r24,lo8(statusMacStr)
 4463 1480 90E0      		ldi r25,hi8(statusMacStr)
 4464 1482 1396      		adiw r26,3
 4465 1484 8D93      		st X+,r24
 4466 1486 9C93      		st X,r25
 4467 1488 1497      		sbiw r26,3+1
 4468 148a 0E94 0000 		call fprintf_P
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 4470               	.LM424:
 4471 148e 0F90      		pop __tmp_reg__
 4472 1490 0F90      		pop __tmp_reg__
 4473 1492 0F90      		pop __tmp_reg__
 4474 1494 0F90      		pop __tmp_reg__
 4475 1496 CE01      		movw r24,r28
 4476 1498 60E0      		ldi r22,lo8(nicState+2)
 4477 149a 70E0      		ldi r23,hi8(nicState+2)
 4478 149c 0E94 0000 		call netPrintEthAddr
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4480               	.LM425:
 4481 14a0 00D0      		rcall .
 4482 14a2 0F92      		push __tmp_reg__
 4483 14a4 EDB7      		in r30,__SP_L__
 4484 14a6 FEB7      		in r31,__SP_H__
 4485 14a8 C183      		std Z+1,r28
 4486 14aa D283      		std Z+2,r29
 4487 14ac 80E0      		ldi r24,lo8(__c.5113)
 4488 14ae 90E0      		ldi r25,hi8(__c.5113)
 4489 14b0 8383      		std Z+3,r24
 4490 14b2 9483      		std Z+4,r25
 4491 14b4 0E94 0000 		call fprintf_P
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 4493               	.LM426:
 4494 14b8 ADB7      		in r26,__SP_L__
 4495 14ba BEB7      		in r27,__SP_H__
 4496 14bc 1196      		adiw r26,1
 4497 14be CD93      		st X+,r28
 4498 14c0 DC93      		st X,r29
 4499 14c2 1297      		sbiw r26,1+1
 4500 14c4 80E0      		ldi r24,lo8(statusIpStr)
 4501 14c6 90E0      		ldi r25,hi8(statusIpStr)
 4502 14c8 1396      		adiw r26,3
 4503 14ca 8D93      		st X+,r24
 4504 14cc 9C93      		st X,r25
 4505 14ce 1497      		sbiw r26,3+1
 4506 14d0 0E94 0000 		call fprintf_P
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 4508               	.LM427:
 4509 14d4 0F90      		pop __tmp_reg__
 4510 14d6 0F90      		pop __tmp_reg__
 4511 14d8 0F90      		pop __tmp_reg__
 4512 14da 0F90      		pop __tmp_reg__
 4513 14dc 0E94 0000 		call ipGetConfig
 4514 14e0 FC01      		movw r30,r24
 4515 14e2 4081      		ld r20,Z
 4516 14e4 5181      		ldd r21,Z+1
 4517 14e6 6281      		ldd r22,Z+2
 4518 14e8 7381      		ldd r23,Z+3
 4519 14ea CE01      		movw r24,r28
 4520 14ec 0E94 0000 		call netPrintIPAddr
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4522               	.LM428:
 4523 14f0 00D0      		rcall .
 4524 14f2 0F92      		push __tmp_reg__
 4525 14f4 ADB7      		in r26,__SP_L__
 4526 14f6 BEB7      		in r27,__SP_H__
 4527 14f8 1196      		adiw r26,1
 4528 14fa CD93      		st X+,r28
 4529 14fc DC93      		st X,r29
 4530 14fe 1297      		sbiw r26,1+1
 4531 1500 80E0      		ldi r24,lo8(__c.5115)
 4532 1502 90E0      		ldi r25,hi8(__c.5115)
 4533 1504 1396      		adiw r26,3
 4534 1506 8D93      		st X+,r24
 4535 1508 9C93      		st X,r25
 4536 150a 1497      		sbiw r26,3+1
 4537 150c 0E94 0000 		call fprintf_P
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 4539               	.LM429:
 4540 1510 EDB7      		in r30,__SP_L__
 4541 1512 FEB7      		in r31,__SP_H__
 4542 1514 C183      		std Z+1,r28
 4543 1516 D283      		std Z+2,r29
 4544 1518 80E0      		ldi r24,lo8(statusIpMaskStr)
 4545 151a 90E0      		ldi r25,hi8(statusIpMaskStr)
 4546 151c 8383      		std Z+3,r24
 4547 151e 9483      		std Z+4,r25
 4548 1520 0E94 0000 		call fprintf_P
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 4550               	.LM430:
 4551 1524 0F90      		pop __tmp_reg__
 4552 1526 0F90      		pop __tmp_reg__
 4553 1528 0F90      		pop __tmp_reg__
 4554 152a 0F90      		pop __tmp_reg__
 4555 152c 0E94 0000 		call ipGetConfig
 4556 1530 DC01      		movw r26,r24
 4557 1532 1496      		adiw r26,4
 4558 1534 4D91      		ld r20,X+
 4559 1536 5D91      		ld r21,X+
 4560 1538 6D91      		ld r22,X+
 4561 153a 7C91      		ld r23,X
 4562 153c 1797      		sbiw r26,4+3
 4563 153e CE01      		movw r24,r28
 4564 1540 0E94 0000 		call netPrintIPAddr
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4566               	.LM431:
 4567 1544 00D0      		rcall .
 4568 1546 0F92      		push __tmp_reg__
 4569 1548 EDB7      		in r30,__SP_L__
 4570 154a FEB7      		in r31,__SP_H__
 4571 154c C183      		std Z+1,r28
 4572 154e D283      		std Z+2,r29
 4573 1550 80E0      		ldi r24,lo8(__c.5117)
 4574 1552 90E0      		ldi r25,hi8(__c.5117)
 4575 1554 8383      		std Z+3,r24
 4576 1556 9483      		std Z+4,r25
 4577 1558 0E94 0000 		call fprintf_P
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 4579               	.LM432:
 4580 155c ADB7      		in r26,__SP_L__
 4581 155e BEB7      		in r27,__SP_H__
 4582 1560 1196      		adiw r26,1
 4583 1562 CD93      		st X+,r28
 4584 1564 DC93      		st X,r29
 4585 1566 1297      		sbiw r26,1+1
 4586 1568 80E0      		ldi r24,lo8(statusIpGwStr)
 4587 156a 90E0      		ldi r25,hi8(statusIpGwStr)
 4588 156c 1396      		adiw r26,3
 4589 156e 8D93      		st X+,r24
 4590 1570 9C93      		st X,r25
 4591 1572 1497      		sbiw r26,3+1
 4592 1574 0E94 0000 		call fprintf_P
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 4594               	.LM433:
 4595 1578 0F90      		pop __tmp_reg__
 4596 157a 0F90      		pop __tmp_reg__
 4597 157c 0F90      		pop __tmp_reg__
 4598 157e 0F90      		pop __tmp_reg__
 4599 1580 0E94 0000 		call ipGetConfig
 4600 1584 FC01      		movw r30,r24
 4601 1586 4085      		ldd r20,Z+8
 4602 1588 5185      		ldd r21,Z+9
 4603 158a 6285      		ldd r22,Z+10
 4604 158c 7385      		ldd r23,Z+11
 4605 158e CE01      		movw r24,r28
 4606 1590 0E94 0000 		call netPrintIPAddr
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4608               	.LM434:
 4609 1594 00D0      		rcall .
 4610 1596 0F92      		push __tmp_reg__
 4611 1598 ADB7      		in r26,__SP_L__
 4612 159a BEB7      		in r27,__SP_H__
 4613 159c 1196      		adiw r26,1
 4614 159e CD93      		st X+,r28
 4615 15a0 DC93      		st X,r29
 4616 15a2 1297      		sbiw r26,1+1
 4617 15a4 80E0      		ldi r24,lo8(__c.5119)
 4618 15a6 90E0      		ldi r25,hi8(__c.5119)
 4619 15a8 1396      		adiw r26,3
 4620 15aa 8D93      		st X+,r24
 4621 15ac 9C93      		st X,r25
 4622 15ae 1497      		sbiw r26,3+1
 4623 15b0 0E94 0000 		call fprintf_P
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 4625               	.LM435:
 4626 15b4 EDB7      		in r30,__SP_L__
 4627 15b6 FEB7      		in r31,__SP_H__
 4628 15b8 C183      		std Z+1,r28
 4629 15ba D283      		std Z+2,r29
 4630 15bc 80E0      		ldi r24,lo8(statusRs485listStr)
 4631 15be 90E0      		ldi r25,hi8(statusRs485listStr)
 4632 15c0 8383      		std Z+3,r24
 4633 15c2 9483      		std Z+4,r25
 4634 15c4 0E94 0000 		call fprintf_P
 242:vty.c         ****   tmp = printRs485devices(stream);
 4636               	.LM436:
 4637 15c8 0F90      		pop __tmp_reg__
 4638 15ca 0F90      		pop __tmp_reg__
 4639 15cc 0F90      		pop __tmp_reg__
 4640 15ce 0F90      		pop __tmp_reg__
 4641 15d0 CE01      		movw r24,r28
 4642 15d2 0E94 0000 		call printRs485devices
 243:vty.c         ****   if (tmp == 0)
 4644               	.LM437:
 4645 15d6 8823      		tst r24
 4646 15d8 01F4      		brne .L143
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 4648               	.LM438:
 4649 15da 00D0      		rcall .
 4650 15dc 0F92      		push __tmp_reg__
 4651 15de ADB7      		in r26,__SP_L__
 4652 15e0 BEB7      		in r27,__SP_H__
 4653 15e2 1196      		adiw r26,1
 4654 15e4 CD93      		st X+,r28
 4655 15e6 DC93      		st X,r29
 4656 15e8 1297      		sbiw r26,1+1
 4657 15ea 80E0      		ldi r24,lo8(statusNoRs485Dev)
 4658 15ec 90E0      		ldi r25,hi8(statusNoRs485Dev)
 4659 15ee 1396      		adiw r26,3
 4660 15f0 8D93      		st X+,r24
 4661 15f2 9C93      		st X,r25
 4662 15f4 1497      		sbiw r26,3+1
 4663 15f6 0E94 0000 		call fprintf_P
 4664 15fa 0F90      		pop __tmp_reg__
 4665 15fc 0F90      		pop __tmp_reg__
 4666 15fe 0F90      		pop __tmp_reg__
 4667 1600 0F90      		pop __tmp_reg__
 4668               	.L143:
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 4670               	.LM439:
 4671 1602 00D0      		rcall .
 4672 1604 0F92      		push __tmp_reg__
 4673 1606 EDB7      		in r30,__SP_L__
 4674 1608 FEB7      		in r31,__SP_H__
 4675 160a C183      		std Z+1,r28
 4676 160c D283      		std Z+2,r29
 4677 160e 80E0      		ldi r24,lo8(statusLockerSensorsStr)
 4678 1610 90E0      		ldi r25,hi8(statusLockerSensorsStr)
 4679 1612 8383      		std Z+3,r24
 4680 1614 9483      		std Z+4,r25
 4681 1616 0E94 0000 		call fprintf_P
 248:vty.c         ****   tmp = printLockers(stream);
 4683               	.LM440:
 4684 161a 0F90      		pop __tmp_reg__
 4685 161c 0F90      		pop __tmp_reg__
 4686 161e 0F90      		pop __tmp_reg__
 4687 1620 0F90      		pop __tmp_reg__
 4688 1622 CE01      		movw r24,r28
 4689 1624 0E94 0000 		call printLockers
 249:vty.c         ****   if (tmp == 0)
 4691               	.LM441:
 4692 1628 8823      		tst r24
 4693 162a 01F4      		brne .L144
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 4695               	.LM442:
 4696 162c 00D0      		rcall .
 4697 162e 0F92      		push __tmp_reg__
 4698 1630 ADB7      		in r26,__SP_L__
 4699 1632 BEB7      		in r27,__SP_H__
 4700 1634 1196      		adiw r26,1
 4701 1636 CD93      		st X+,r28
 4702 1638 DC93      		st X,r29
 4703 163a 1297      		sbiw r26,1+1
 4704 163c 80E0      		ldi r24,lo8(statusLockerSensorsDisStr)
 4705 163e 90E0      		ldi r25,hi8(statusLockerSensorsDisStr)
 4706 1640 1396      		adiw r26,3
 4707 1642 8D93      		st X+,r24
 4708 1644 9C93      		st X,r25
 4709 1646 1497      		sbiw r26,3+1
 4710 1648 0E94 0000 		call fprintf_P
 4711 164c 0F90      		pop __tmp_reg__
 4712 164e 0F90      		pop __tmp_reg__
 4713 1650 0F90      		pop __tmp_reg__
 4714 1652 0F90      		pop __tmp_reg__
 4715               	.L144:
 259:vty.c         ****   udpPrintStatus(stream);
 4717               	.LM443:
 4718 1654 CE01      		movw r24,r28
 4719 1656 0E94 0000 		call udpPrintStatus
 4720               	/* epilogue start */
 261:vty.c         **** }
 4722               	.LM444:
 4723 165a DF91      		pop r29
 4724 165c CF91      		pop r28
 4725 165e 0895      		ret
 4727               	.Lscope33:
 4729               		.stabd	78,0,0
 4733               	statusFunction:
 4734               		.stabd	46,0,0
 267:vty.c         **** {
 4736               	.LM445:
 4737               	.LFBB34:
 4738 1660 EF92      		push r14
 4739 1662 FF92      		push r15
 4740 1664 0F93      		push r16
 4741 1666 1F93      		push r17
 4742 1668 DF93      		push r29
 4743 166a CF93      		push r28
 4744 166c CDB7      		in r28,__SP_L__
 4745 166e DEB7      		in r29,__SP_H__
 4746 1670 2E97      		sbiw r28,14
 4747 1672 CDBF      		out __SP_L__,r28
 4748 1674 DEBF      		out __SP_H__,r29
 4749               	/* prologue: function */
 4750               	/* frame size = 14 */
 4751               	/* stack size = 20 */
 4752               	.L__stack_usage = 20
 4753 1676 7C01      		movw r14,r24
 268:vty.c         ****   if (state->argc < 1)
 4755               	.LM446:
 4756 1678 DC01      		movw r26,r24
 4757 167a 5996      		adiw r26,25
 4758 167c 8C91      		ld r24,X
 4759 167e 5997      		sbiw r26,25
 4760 1680 8823      		tst r24
 4761 1682 01F4      		brne .L146
 270:vty.c         ****     printStatus(state->myStdInOut);
 4763               	.LM447:
 4764 1684 5A96      		adiw r26,26
 4765 1686 8D91      		ld r24,X+
 4766 1688 9C91      		ld r25,X
 4767 168a 5B97      		sbiw r26,26+1
 4768 168c 0E94 0000 		call printStatus
 4769 1690 00C0      		rjmp .L149
 4770               	.L146:
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 4772               	.LM448:
 4773 1692 81E0      		ldi r24,lo8(1)
 4774 1694 B701      		movw r22,r14
 4775 1696 0E94 0000 		call cmdlineGetArgStr
 4776 169a 60E0      		ldi r22,lo8(fdVty)
 4777 169c 70E0      		ldi r23,hi8(fdVty)
 4778 169e 8E01      		movw r16,r28
 4779 16a0 0F5F      		subi r16,lo8(-(1))
 4780 16a2 1F4F      		sbci r17,hi8(-(1))
 4781 16a4 A801      		movw r20,r16
 4782 16a6 23E0      		ldi r18,lo8(3)
 4783 16a8 0E94 0000 		call ramDyskOtworzPlikStdIo
 4784 16ac 8823      		tst r24
 4785 16ae 01F0      		breq .L148
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 4787               	.LM449:
 4788 16b0 F701      		movw r30,r14
 4789 16b2 028D      		ldd r16,Z+26
 4790 16b4 138D      		ldd r17,Z+27
 4791 16b6 81E0      		ldi r24,lo8(1)
 4792 16b8 B701      		movw r22,r14
 4793 16ba 0E94 0000 		call cmdlineGetArgStr
 4794 16be 00D0      		rcall .
 4795 16c0 00D0      		rcall .
 4796 16c2 EDB7      		in r30,__SP_L__
 4797 16c4 FEB7      		in r31,__SP_H__
 4798 16c6 3196      		adiw r30,1
 4799 16c8 ADB7      		in r26,__SP_L__
 4800 16ca BEB7      		in r27,__SP_H__
 4801 16cc 1196      		adiw r26,1
 4802 16ce 0D93      		st X+,r16
 4803 16d0 1C93      		st X,r17
 4804 16d2 1297      		sbiw r26,1+1
 4805 16d4 20E0      		ldi r18,lo8(errorOpenFile)
 4806 16d6 30E0      		ldi r19,hi8(errorOpenFile)
 4807 16d8 2283      		std Z+2,r18
 4808 16da 3383      		std Z+3,r19
 4809 16dc 8483      		std Z+4,r24
 4810 16de 9583      		std Z+5,r25
 4811 16e0 0E94 0000 		call fprintf_P
 278:vty.c         ****     return ERROR_INFORM;
 4813               	.LM450:
 4814 16e4 EDB7      		in r30,__SP_L__
 4815 16e6 FEB7      		in r31,__SP_H__
 4816 16e8 3696      		adiw r30,6
 4817 16ea EDBF      		out __SP_L__,r30
 4818 16ec FEBF      		out __SP_H__,r31
 4819 16ee 24E0      		ldi r18,lo8(4)
 4820 16f0 30E0      		ldi r19,hi8(4)
 4821 16f2 00C0      		rjmp .L147
 4822               	.L148:
 281:vty.c         ****   printStatus(&stream);
 4824               	.LM451:
 4825 16f4 C801      		movw r24,r16
 4826 16f6 0E94 0000 		call printStatus
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 4828               	.LM452:
 4829 16fa C801      		movw r24,r16
 4830 16fc 0E94 0000 		call ramDyskZamknijPlikStdIo
 4831               	.L149:
 283:vty.c         ****   return OK_SILENT; 
 4833               	.LM453:
 4834 1700 20E0      		ldi r18,lo8(0)
 4835 1702 30E0      		ldi r19,hi8(0)
 4836               	.L147:
 284:vty.c         **** }
 4838               	.LM454:
 4839 1704 C901      		movw r24,r18
 4840               	/* epilogue start */
 4841 1706 2E96      		adiw r28,14
 4842 1708 CDBF      		out __SP_L__,r28
 4843 170a DEBF      		out __SP_H__,r29
 4844 170c CF91      		pop r28
 4845 170e DF91      		pop r29
 4846 1710 1F91      		pop r17
 4847 1712 0F91      		pop r16
 4848 1714 FF90      		pop r15
 4849 1716 EF90      		pop r14
 4850 1718 0895      		ret
 4855               	.Lscope34:
 4857               		.stabd	78,0,0
 4858               	.global	errorOK
 4859               		.section	.progmem.data,"a",@progbits
 4862               	errorOK:
 4863 0000 416C 6C20 		.string	"All OK\r\n"
 4863      4F4B 0D0A 
 4863      00
 4864               	.global	errorNoFile
 4867               	errorNoFile:
 4868 0009 4E6F 2046 		.string	"No File\r\n"
 4868      696C 650D 
 4868      0A00 
 4869               	.global	errorxModemFrameStartTimeout
 4872               	errorxModemFrameStartTimeout:
 4873 0013 0D0A 00   		.string	"\r\n"
 4874               	.global	errorxModemByteSendTimeout
 4877               	errorxModemByteSendTimeout:
 4878 0016 0D0A 00   		.string	"\r\n"
 4879               	.global	errorxModemWrongFrameNo
 4882               	errorxModemWrongFrameNo:
 4883 0019 0D0A 00   		.string	"\r\n"
 4884               	.global	errorxModemFrameFrameNoCorrectionNotMatch
 4887               	errorxModemFrameFrameNoCorrectionNotMatch:
 4888 001c 0D0A 00   		.string	"\r\n"
 4889               	.global	errorxModemFrameCrc
 4892               	errorxModemFrameCrc:
 4893 001f 784D 6F64 		.string	"xModem CRC error\r\n"
 4893      656D 2043 
 4893      5243 2065 
 4893      7272 6F72 
 4893      0D0A 00
 4894               	.global	errorxModemRemoteSideCan
 4897               	errorxModemRemoteSideCan:
 4898 0032 5265 6D6F 		.string	"Remote side cancelled at frame no %d\r\n"
 4898      7465 2073 
 4898      6964 6520 
 4898      6361 6E63 
 4898      656C 6C65 
 4899               	.global	errorxModemUnknownResponse
 4902               	errorxModemUnknownResponse:
 4903 0059 784D 6F64 		.string	"xModem unknown response 0x%x\r\n"
 4903      656D 2075 
 4903      6E6B 6E6F 
 4903      776E 2072 
 4903      6573 706F 
 4904               	.global	errorNoRemoteDevice
 4907               	errorNoRemoteDevice:
 4908 0078 4465 7669 		.string	"Device %d is not responding (%d)\r\n"
 4908      6365 2025 
 4908      6420 6973 
 4908      206E 6F74 
 4908      2072 6573 
 4909               	.global	errorBootloaderNotResponding
 4912               	errorBootloaderNotResponding:
 4913 009b 426F 6F74 		.string	"Bootloader is not responding\r\n"
 4913      6C6F 6164 
 4913      6572 2069 
 4913      7320 6E6F 
 4913      7420 7265 
 4914               	.global	errorOpenFile
 4917               	errorOpenFile:
 4918 00ba 4361 6E27 		.string	"Can't open file %s\r\n"
 4918      7420 6F70 
 4918      656E 2066 
 4918      696C 6520 
 4918      2573 0D0A 
 4919               	.global	systemStateStr
 4922               	systemStateStr:
 4923 00cf 5379 7374 		.string	"System state:\r\n"
 4923      656D 2073 
 4923      7461 7465 
 4923      3A0D 0A00 
 4924               	.global	statusNumberOfTasksStr
 4927               	statusNumberOfTasksStr:
 4928 00df 2020 4E75 		.string	"  Number of tasks : %d\r\n"
 4928      6D62 6572 
 4928      206F 6620 
 4928      7461 736B 
 4928      7320 3A20 
 4929               	.global	statusStaticHeapStateStr
 4932               	statusStaticHeapStateStr:
 4933 00f8 2020 4672 		.string	"  FreeRtos heap   : %d free of %d bytes\r\n"
 4933      6565 5274 
 4933      6F73 2068 
 4933      6561 7020 
 4933      2020 3A20 
 4934               	.global	statusDynamicHeapStateStr
 4937               	statusDynamicHeapStateStr:
 4938 0122 2020 4D61 		.string	"  Malloc heap     : %d free of %d bytes\r\n"
 4938      6C6C 6F63 
 4938      2068 6561 
 4938      7020 2020 
 4938      2020 3A20 
 4939               	.global	statusRamDiskStateStr
 4942               	statusRamDiskStateStr:
 4943 014c 2020 5261 		.string	"  Ram disc space  : %d free of %d clusters\r\n"
 4943      6D20 6469 
 4943      7363 2073 
 4943      7061 6365 
 4943      2020 3A20 
 4944               	.global	statusTemperatureStr
 4947               	statusTemperatureStr:
 4948 0179 2020 5465 		.string	"  Temperature     : %d C\r\n"
 4948      6D70 6572 
 4948      6174 7572 
 4948      6520 2020 
 4948      2020 3A20 
 4949               	.global	statusVoltageStr
 4952               	statusVoltageStr:
 4953 0194 2020 566F 		.string	"  Voltage         : %d V\r\n"
 4953      6C74 6167 
 4953      6520 2020 
 4953      2020 2020 
 4953      2020 3A20 
 4954               	.global	systemRamConfigStr
 4957               	systemRamConfigStr:
 4958 01af 5379 7374 		.string	"System settings:\r\n"
 4958      656D 2073 
 4958      6574 7469 
 4958      6E67 733A 
 4958      0D0A 00
 4959               	.global	statusMacStr
 4962               	statusMacStr:
 4963 01c2 2020 4D61 		.string	"  Mac address     : "
 4963      6320 6164 
 4963      6472 6573 
 4963      7320 2020 
 4963      2020 3A20 
 4964               	.global	statusIpStr
 4967               	statusIpStr:
 4968 01d7 2020 4950 		.string	"  IP address      : "
 4968      2061 6464 
 4968      7265 7373 
 4968      2020 2020 
 4968      2020 3A20 
 4969               	.global	statusIpMaskStr
 4972               	statusIpMaskStr:
 4973 01ec 2020 6D61 		.string	"  mask            : "
 4973      736B 2020 
 4973      2020 2020 
 4973      2020 2020 
 4973      2020 3A20 
 4974               	.global	statusIpGwStr
 4977               	statusIpGwStr:
 4978 0201 2020 6761 		.string	"  gateway         : "
 4978      7465 7761 
 4978      7920 2020 
 4978      2020 2020 
 4978      2020 3A20 
 4979               	.global	statusRs485listStr
 4982               	statusRs485listStr:
 4983 0216 4465 7465 		.string	"Detected RS 485 devices:\r\n"
 4983      6374 6564 
 4983      2052 5320 
 4983      3438 3520 
 4983      6465 7669 
 4984               	.global	statusNoRs485Dev
 4987               	statusNoRs485Dev:
 4988 0231 2020 4361 		.string	"  Can't find any device\r\n"
 4988      6E27 7420 
 4988      6669 6E64 
 4988      2061 6E79 
 4988      2064 6576 
 4989               	.global	statusLockerSensorsStr
 4992               	statusLockerSensorsStr:
 4993 024b 4C6F 636B 		.string	"Locker sensors states:\r\n"
 4993      6572 2073 
 4993      656E 736F 
 4993      7273 2073 
 4993      7461 7465 
 4994               	.global	statusLockerSensorsDisStr
 4997               	statusLockerSensorsDisStr:
 4998 0264 2020 4C6F 		.string	"  Locker sensors disabled\r\n"
 4998      636B 6572 
 4998      2073 656E 
 4998      736F 7273 
 4998      2064 6973 
 4999               	.global	editRamFileIntroStr
 5002               	editRamFileIntroStr:
 5003 0280 5772 6974 		.string	"Writing to file. Press CTRL+C to quit\r\n"
 5003      696E 6720 
 5003      746F 2066 
 5003      696C 652E 
 5003      2050 7265 
 5004               	.global	readRamFIleLenStr
 5007               	readRamFIleLenStr:
 5008 02a8 4669 6C65 		.string	"File length: %d\r\n"
 5008      206C 656E 
 5008      6774 683A 
 5008      2025 640D 
 5008      0A00 
 5009               	.global	xwyslijStartStr
 5012               	xwyslijStartStr:
 5013 02ba 586D 6F64 		.string	"Xmodem: Transmission start\r\n"
 5013      656D 3A20 
 5013      5472 616E 
 5013      736D 6973 
 5013      7369 6F6E 
 5014               	.global	movingCurtainUpStr
 5017               	movingCurtainUpStr:
 5018 02d7 506F 646E 		.string	"Podnoszenie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 5018      6F73 7A65 
 5018      6E69 6520 
 5018      726F 6C65 
 5018      7479 0D0A 
 5019               	.global	movingCurtainDownStr
 5022               	movingCurtainDownStr:
 5023 030a 4F70 7573 		.string	"Opuszczanie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 5023      7A63 7A61 
 5023      6E69 6520 
 5023      726F 6C65 
 5023      7479 0D0A 
 5024               	.global	movingCurtainPosStr
 5027               	movingCurtainPosStr:
 5028 033d 0970 6F7A 		.string	"\tpozycja   %d\r\n"
 5028      7963 6A61 
 5028      2020 2025 
 5028      640D 0A00 
 5029               	.global	debugEnabledInfoStr
 5032               	debugEnabledInfoStr:
 5033 034d 456E 6162 		.string	"Enabled %s debug\r\n"
 5033      6C65 6420 
 5033      2573 2064 
 5033      6562 7567 
 5033      0D0A 00
 5034               	.global	debugDisabledInfoStr
 5037               	debugDisabledInfoStr:
 5038 0360 4469 7361 		.string	"Disabled %s debug\r\n"
 5038      626C 6564 
 5038      2025 7320 
 5038      6465 6275 
 5038      670D 0A00 
 5039               	.global	cmd_help
 5042               	cmd_help:
 5043 0374 6865 6C70 		.string	"help"
 5043      00
 5044               	.global	cmd_help_help
 5045               		.data
 5048               	cmd_help_help:
 5049 0000 5072 696E 		.string	"Print help string"
 5049      7420 6865 
 5049      6C70 2073 
 5049      7472 696E 
 5049      6700 
 5050               	.global	cmd_status
 5051               		.section	.progmem.data
 5054               	cmd_status:
 5055 0379 7374 6174 		.string	"status"
 5055      7573 00
 5056               	.global	cmd_help_status
 5057               		.data
 5060               	cmd_help_status:
 5061 0012 7B66 696C 		.string	"{filename} Print device status on VTY or write to file"
 5061      656E 616D 
 5061      657D 2050 
 5061      7269 6E74 
 5061      2064 6576 
 5062               	.global	cmd_enc_stat
 5063               		.section	.progmem.data
 5066               	cmd_enc_stat:
 5067 0380 656E 6373 		.string	"encstat"
 5067      7461 7400 
 5068               	.global	cmd_help_enc_stat
 5069               		.data
 5072               	cmd_help_enc_stat:
 5073 0049 5072 696E 		.string	"Print Enc 28j60 registers"
 5073      7420 456E 
 5073      6320 3238 
 5073      6A36 3020 
 5073      7265 6769 
 5074               	.global	cmd_time
 5075               		.section	.progmem.data
 5078               	cmd_time:
 5079 0388 7469 6D65 		.string	"time"
 5079      00
 5080               	.global	cmd_help_time
 5081               		.data
 5084               	cmd_help_time:
 5085 0063 5072 696E 		.string	"Print time"
 5085      7420 7469 
 5085      6D65 00
 5086               	.global	cmd_net_dbg
 5087               		.section	.progmem.data
 5090               	cmd_net_dbg:
 5091 038d 6465 6275 		.string	"debug"
 5091      6700 
 5092               	.global	cmd_help_net_dbg
 5093               		.data
 5096               	cmd_help_net_dbg:
 5097 006e 5B61 7270 		.ascii	"[arp|icm"
 5097      7C69 636D 
 5098 0076 707C 6970 		.string	"p|ip|tcp|udp] [level] write debug info. Level 0 disable debuging"
 5098      7C74 6370 
 5098      7C75 6470 
 5098      5D20 5B6C 
 5098      6576 656C 
 5099               	.global	cmd_rping
 5100               		.section	.progmem.data
 5103               	cmd_rping:
 5104 0393 7270 696E 		.string	"rping"
 5104      6700 
 5105               	.global	cmd_help_rping
 5106               		.data
 5109               	cmd_help_rping:
 5110 00b7 5B44 6576 		.string	"[Device no] Send ping to Rs485 device"
 5110      6963 6520 
 5110      6E6F 5D20 
 5110      5365 6E64 
 5110      2070 696E 
 5111               	.global	cmd_ping
 5112               		.section	.progmem.data
 5115               	cmd_ping:
 5116 0399 7069 6E67 		.string	"ping"
 5116      00
 5117               	.global	cmd_help_ping
 5118               		.data
 5121               	cmd_help_ping:
 5122 00dd 5B41 315D 		.string	"[A1] [A2] [A3] [A4] Sends ping throught ethernet"
 5122      205B 4132 
 5122      5D20 5B41 
 5122      335D 205B 
 5122      4134 5D20 
 5123               	.global	cmd_xRec
 5124               		.section	.progmem.data
 5127               	cmd_xRec:
 5128 039e 7872 6563 		.string	"xrec"
 5128      00
 5129               	.global	cmd_help_xRec
 5130               		.data
 5133               	cmd_help_xRec:
 5134 010e 5B66 696C 		.string	"[file name] receive file using xModem"
 5134      6520 6E61 
 5134      6D65 5D20 
 5134      7265 6365 
 5134      6976 6520 
 5135               	.global	cmd_xSend
 5136               		.section	.progmem.data
 5139               	cmd_xSend:
 5140 03a3 7873 656E 		.string	"xsend"
 5140      6400 
 5141               	.global	cmd_help_xSend
 5142               		.data
 5145               	cmd_help_xSend:
 5146 0134 5B66 696C 		.string	"[file name] send file using xModem"
 5146      6520 6E61 
 5146      6D65 5D20 
 5146      7365 6E64 
 5146      2066 696C 
 5147               	.global	cmd_xflash
 5148               		.section	.progmem.data
 5151               	cmd_xflash:
 5152 03a9 7866 6C61 		.string	"xflash"
 5152      7368 00
 5153               	.global	cmd_help_xflash
 5154               		.data
 5157               	cmd_help_xflash:
 5158 0157 5B64 6576 		.string	"[device no] [file name] flash device connected to Rs485"
 5158      6963 6520 
 5158      6E6F 5D20 
 5158      5B66 696C 
 5158      6520 6E61 
 5159               	.global	cmd_dir_rf
 5160               		.section	.progmem.data
 5163               	cmd_dir_rf:
 5164 03b0 6469 7272 		.string	"dirrf"
 5164      6600 
 5165               	.global	cmd_help_dir_rf
 5166               		.data
 5169               	cmd_help_dir_rf:
 5170 018f 5072 696E 		.string	"Print ramdisk files"
 5170      7420 7261 
 5170      6D64 6973 
 5170      6B20 6669 
 5170      6C65 7300 
 5171               	.global	cmd_create_rf
 5172               		.section	.progmem.data
 5175               	cmd_create_rf:
 5176 03b6 6372 6600 		.string	"crf"
 5177               	.global	cmd_help_create_rf
 5178               		.data
 5181               	cmd_help_create_rf:
 5182 01a3 5B66 696C 		.string	"[file name] create ram file"
 5182      6520 6E61 
 5182      6D65 5D20 
 5182      6372 6561 
 5182      7465 2072 
 5183               	.global	cmd_erase_rf
 5184               		.section	.progmem.data
 5187               	cmd_erase_rf:
 5188 03ba 6572 6173 		.string	"eraserf"
 5188      6572 6600 
 5189               	.global	cmd_help_erase_rf
 5190               		.data
 5193               	cmd_help_erase_rf:
 5194 01bf 5B66 696C 		.string	"[file name] erase file from ram disk"
 5194      6520 6E61 
 5194      6D65 5D20 
 5194      6572 6173 
 5194      6520 6669 
 5195               	.global	cmd_edit_rf
 5196               		.section	.progmem.data
 5199               	cmd_edit_rf:
 5200 03c2 6564 6974 		.string	"editrf"
 5200      7266 00
 5201               	.global	cmd_help_edit_rf
 5202               		.data
 5205               	cmd_help_edit_rf:
 5206 01e4 5B66 696C 		.string	"[file name] edit file located on ram disk"
 5206      6520 6E61 
 5206      6D65 5D20 
 5206      6564 6974 
 5206      2066 696C 
 5207               	.global	cmd_read_rf
 5208               		.section	.progmem.data
 5211               	cmd_read_rf:
 5212 03c9 7265 6164 		.string	"readrf"
 5212      7266 00
 5213               	.global	cmd_help_read_rf
 5214               		.data
 5217               	cmd_help_read_rf:
 5218 020e 5B66 696C 		.string	"[file name] read file located on ram disk"
 5218      6520 6E61 
 5218      6D65 5D20 
 5218      7265 6164 
 5218      2066 696C 
 5219               	.global	cmd_up
 5220               		.section	.progmem.data
 5223               	cmd_up:
 5224 03d0 7570 00   		.string	"up"
 5225               	.global	cmd_help_up
 5226               		.data
 5229               	cmd_help_up:
 5230 0238 5B64 7269 		.string	"[driver no] [channel] {value} move up"
 5230      7665 7220 
 5230      6E6F 5D20 
 5230      5B63 6861 
 5230      6E6E 656C 
 5231               	.global	cmd_down
 5232               		.section	.progmem.data
 5235               	cmd_down:
 5236 03d3 646F 776E 		.string	"down"
 5236      00
 5237               	.global	cmd_help_down
 5238               		.data
 5241               	cmd_help_down:
 5242 025e 5B64 7269 		.string	"[driver no] [channel] {value} move down"
 5242      7665 7220 
 5242      6E6F 5D20 
 5242      5B63 6861 
 5242      6E6E 656C 
 5243               	.global	cmd_spa
 5244               		.section	.progmem.data
 5247               	cmd_spa:
 5248 03d8 7370 6100 		.string	"spa"
 5249               	.global	cmd_help_spa
 5250               		.data
 5253               	cmd_help_spa:
 5254 0286 5B76 616C 		.string	"[value] set port A"
 5254      7565 5D20 
 5254      7365 7420 
 5254      706F 7274 
 5254      2041 00
 5255               	.global	cmd_spb
 5256               		.section	.progmem.data
 5259               	cmd_spb:
 5260 03dc 7370 6200 		.string	"spb"
 5261               	.global	cmd_help_spb
 5262               		.data
 5265               	cmd_help_spb:
 5266 0299 5B76 616C 		.string	"[value] set port B"
 5266      7565 5D20 
 5266      7365 7420 
 5266      706F 7274 
 5266      2042 00
 5267               	.global	cmd_settime
 5268               		.section	.progmem.data
 5271               	cmd_settime:
 5272 03e0 7365 7474 		.string	"settime"
 5272      696D 6500 
 5273               	.global	cmd_help_settime
 5274               		.data
 5277               	cmd_help_settime:
 5278 02ac 5B68 5D20 		.string	"[h] [m] [s] set time (24h format)"
 5278      5B6D 5D20 
 5278      5B73 5D20 
 5278      7365 7420 
 5278      7469 6D65 
 5279               	.global	cmd_ac
 5280               		.section	.progmem.data
 5283               	cmd_ac:
 5284 03e8 6163 00   		.string	"ac"
 5285               	.global	cmd_help_ac
 5286               		.data
 5289               	cmd_help_ac:
 5290 02ce 5B63 6861 		.string	"[channel 0-7] read analog value"
 5290      6E6E 656C 
 5290      2030 2D37 
 5290      5D20 7265 
 5290      6164 2061 
 5291               	.global	cmd_enable
 5292               		.section	.progmem.data
 5295               	cmd_enable:
 5296 03eb 656E 6162 		.string	"enable"
 5296      6C65 00
 5297               	.global	cmd_help_enable
 5298               		.data
 5301               	cmd_help_enable:
 5302 02ee 456E 6162 		.string	"Enable mode"
 5302      6C65 206D 
 5302      6F64 6500 
 5303               	.global	cmd_disable
 5304               		.section	.progmem.data
 5307               	cmd_disable:
 5308 03f2 6469 7361 		.string	"disable"
 5308      626C 6500 
 5309               	.global	cmd_help_disable
 5310               		.data
 5313               	cmd_help_disable:
 5314 02fa 5669 6577 		.string	"View mode"
 5314      206D 6F64 
 5314      6500 
 5315               	.global	cmd_configure
 5316               		.section	.progmem.data
 5319               	cmd_configure:
 5320 03fa 636F 6E66 		.string	"config"
 5320      6967 00
 5321               	.global	cmd_help_configure
 5322               		.data
 5325               	cmd_help_configure:
 5326 0304 436F 6E66 		.string	"Configure mode"
 5326      6967 7572 
 5326      6520 6D6F 
 5326      6465 00
 5327               	.global	cmd_conf_ip
 5328               		.section	.progmem.data
 5331               	cmd_conf_ip:
 5332 0401 6970 00   		.string	"ip"
 5333               	.global	cmd_help_conf_ip
 5334               		.data
 5337               	cmd_help_conf_ip:
 5338 0313 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set IP address"
 5338      205B 4132 
 5338      5D20 5B41 
 5338      335D 205B 
 5338      4134 5D20 
 5339               	.global	cmd_conf_udp
 5340               		.section	.progmem.data
 5343               	cmd_conf_udp:
 5344 0404 7564 7000 		.string	"udp"
 5345               	.global	cmd_help_conf_udp
 5346               		.data
 5349               	cmd_help_conf_udp:
 5350 0336 5B41 315D 		.ascii	"[A1] [A2] [A3"
 5350      205B 4132 
 5350      5D20 5B41 
 5350      33
 5351 0343 5D20 5B41 		.string	"] [A4] [src port] {dst port} set udp client IP address and ports"
 5351      345D 205B 
 5351      7372 6320 
 5351      706F 7274 
 5351      5D20 7B64 
 5352               	.global	cmd_conf_ip_mask
 5353               		.section	.progmem.data
 5356               	cmd_conf_ip_mask:
 5357 0408 6D61 736B 		.string	"mask"
 5357      00
 5358               	.global	cmd_conf_ip_mask_help
 5359               		.data
 5362               	cmd_conf_ip_mask_help:
 5363 0384 5B6D 6173 		.string	"[mask] set mask"
 5363      6B5D 2073 
 5363      6574 206D 
 5363      6173 6B00 
 5364               	.global	cmd_conf_ip_gw
 5365               		.section	.progmem.data
 5368               	cmd_conf_ip_gw:
 5369 040d 6777 00   		.string	"gw"
 5370               	.global	cmd_conf_ip_gw_help
 5371               		.data
 5374               	cmd_conf_ip_gw_help:
 5375 0394 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set default gateway"
 5375      205B 4132 
 5375      5D20 5B41 
 5375      335D 205B 
 5375      4134 5D20 
 5376               	.global	cmd_conf_mac
 5377               		.section	.progmem.data
 5380               	cmd_conf_mac:
 5381 0410 6D61 6300 		.string	"mac"
 5382               	.global	cmd_help_conf_mac
 5383               		.data
 5386               	cmd_help_conf_mac:
 5387 03bc 5B41 315D 		.string	"[A1] [A2] [A3] [A4] [A5] [A6] set MAC address"
 5387      205B 4132 
 5387      5D20 5B41 
 5387      335D 205B 
 5387      4134 5D20 
 5388               	.global	cmd_conf_save
 5389               		.section	.progmem.data
 5392               	cmd_conf_save:
 5393 0414 7361 7665 		.string	"save"
 5393      00
 5394               	.global	cmd_help_conf_save
 5395               		.data
 5398               	cmd_help_conf_save:
 5399 03ea 5361 7665 		.string	"Save configuration"
 5399      2063 6F6E 
 5399      6669 6775 
 5399      7261 7469 
 5399      6F6E 00
 5400               	.global	cmd_ustawR
 5401               		.section	.progmem.data
 5404               	cmd_ustawR:
 5405 0419 7365 7472 		.string	"setr"
 5405      00
 5406               	.global	cmd_help_ustawR
 5407               		.data
 5410               	cmd_help_ustawR:
 5411 03fd 5B76 616C 		.string	"[value] set resistance value"
 5411      7565 5D20 
 5411      7365 7420 
 5411      7265 7369 
 5411      7374 616E 
 5412               	.global	okStr
 5413               		.section	.progmem.data
 5416               	okStr:
 5417 041e 4F4B 0D0A 		.string	"OK\r\n"
 5417      00
 5418               	.global	nlStr
 5421               	nlStr:
 5422 0423 0D0A 00   		.string	"\r\n"
 5423               	.global	BladBuforaPozostaloBajtowStr
 5426               	BladBuforaPozostaloBajtowStr:
 5427 0426 2121 2120 		.string	"!!! W budorze Rs485 pozostalo %d bajtow\r\n"
 5427      5720 6275 
 5427      646F 727A 
 5427      6520 5273 
 5427      3438 3520 
 5428               	.global	errorStrings
 5431               	errorStrings:
 5432 0450 0000      		.word	errorOK
 5433 0452 0000      		.word	errorNoFile
 5434 0454 0000      		.word	errorxModemFrameStartTimeout
 5435 0456 0000      		.word	errorxModemByteSendTimeout
 5436 0458 0000      		.word	errorxModemWrongFrameNo
 5437 045a 0000      		.word	errorxModemFrameFrameNoCorrectionNotMatch
 5438 045c 0000      		.word	errorxModemFrameCrc
 5439 045e 0000      		.word	errorxModemRemoteSideCan
 5440 0460 0000      		.word	errorxModemUnknownResponse
 5441 0462 0000      		.word	errorNoRemoteDevice
 5442 0464 0000      		.word	errorBootloaderNotResponding
 5443 0466 0000      		.word	errorOpenFile
 5444               	.global	cmdListNormal
 5447               	cmdListNormal:
 5448 0468 0000      		.word	cmd_help
 5449 046a 0000      		.word	cmd_help_help
 5450 046c 0000      		.word	gs(helpFunction)
 5451 046e 0000      		.word	cmd_status
 5452 0470 0000      		.word	cmd_help_status
 5453 0472 0000      		.word	gs(statusFunction)
 5454 0474 0000      		.word	cmd_time
 5455 0476 0000      		.word	cmd_help_time
 5456 0478 0000      		.word	gs(pokazCzasFunction)
 5457 047a 0000      		.word	cmd_rping
 5458 047c 0000      		.word	cmd_help_rping
 5459 047e 0000      		.word	gs(rpingFunction)
 5460 0480 0000      		.word	cmd_ping
 5461 0482 0000      		.word	cmd_help_ping
 5462 0484 0000      		.word	gs(pingFunction)
 5463 0486 0000      		.word	cmd_dir_rf
 5464 0488 0000      		.word	cmd_help_dir_rf
 5465 048a 0000      		.word	gs(writeRamFileFunction)
 5466 048c 0000      		.word	cmd_read_rf
 5467 048e 0000      		.word	cmd_help_read_rf
 5468 0490 0000      		.word	gs(readRamFIleFunction)
 5469 0492 0000      		.word	cmd_enable
 5470 0494 0000      		.word	cmd_help_enable
 5471 0496 0000      		.word	gs(enableFunction)
 5472 0498 0000      		.word	0
 5473 049a 0000      		.word	0
 5474 049c 0000      		.word	0
 5475               	.global	cmdListEnable
 5476               		.data
 5479               	cmdListEnable:
 5480 041a 0000      		.word	cmd_help
 5481 041c 0000      		.word	cmd_help_help
 5482 041e 0000      		.word	gs(helpFunction)
 5483 0420 0000      		.word	cmd_status
 5484 0422 0000      		.word	cmd_help_status
 5485 0424 0000      		.word	gs(statusFunction)
 5486 0426 0000      		.word	cmd_enc_stat
 5487 0428 0000      		.word	cmd_help_enc_stat
 5488 042a 0000      		.word	gs(statusEncFunction)
 5489 042c 0000      		.word	cmd_time
 5490 042e 0000      		.word	cmd_help_time
 5491 0430 0000      		.word	gs(pokazCzasFunction)
 5492 0432 0000      		.word	cmd_net_dbg
 5493 0434 0000      		.word	cmd_help_net_dbg
 5494 0436 0000      		.word	gs(debugFunction)
 5495 0438 0000      		.word	cmd_rping
 5496 043a 0000      		.word	cmd_help_rping
 5497 043c 0000      		.word	gs(rpingFunction)
 5498 043e 0000      		.word	cmd_ping
 5499 0440 0000      		.word	cmd_help_ping
 5500 0442 0000      		.word	gs(pingFunction)
 5501 0444 0000      		.word	cmd_xRec
 5502 0446 0000      		.word	cmd_help_xRec
 5503 0448 0000      		.word	gs(goXmodemOdbierzFunction)
 5504 044a 0000      		.word	cmd_xSend
 5505 044c 0000      		.word	cmd_help_xSend
 5506 044e 0000      		.word	gs(goXmodemWyslijFunction)
 5507 0450 0000      		.word	cmd_xflash
 5508 0452 0000      		.word	cmd_help_xflash
 5509 0454 0000      		.word	gs(flashExModuleFunction)
 5510 0456 0000      		.word	cmd_dir_rf
 5511 0458 0000      		.word	cmd_help_dir_rf
 5512 045a 0000      		.word	gs(writeRamFileFunction)
 5513 045c 0000      		.word	cmd_create_rf
 5514 045e 0000      		.word	cmd_help_create_rf
 5515 0460 0000      		.word	gs(dodajRamPlikFunction)
 5516 0462 0000      		.word	cmd_erase_rf
 5517 0464 0000      		.word	cmd_help_erase_rf
 5518 0466 0000      		.word	gs(eraseRamFileFunction)
 5519 0468 0000      		.word	cmd_edit_rf
 5520 046a 0000      		.word	cmd_help_edit_rf
 5521 046c 0000      		.word	gs(editRamFileFunction)
 5522 046e 0000      		.word	cmd_read_rf
 5523 0470 0000      		.word	cmd_help_read_rf
 5524 0472 0000      		.word	gs(readRamFIleFunction)
 5525 0474 0000      		.word	cmd_up
 5526 0476 0000      		.word	cmd_help_up
 5527 0478 0000      		.word	gs(curtainUpFunction)
 5528 047a 0000      		.word	cmd_down
 5529 047c 0000      		.word	cmd_help_down
 5530 047e 0000      		.word	gs(curtainDownFunction)
 5531 0480 0000      		.word	cmd_spa
 5532 0482 0000      		.word	cmd_help_spa
 5533 0484 0000      		.word	gs(ustawPortExtAFunction)
 5534 0486 0000      		.word	cmd_spb
 5535 0488 0000      		.word	cmd_help_spb
 5536 048a 0000      		.word	gs(ustawPortExtBFunction)
 5537 048c 0000      		.word	cmd_ustawR
 5538 048e 0000      		.word	cmd_help_ustawR
 5539 0490 0000      		.word	gs(ustawPortRezystor)
 5540 0492 0000      		.word	cmd_settime
 5541 0494 0000      		.word	cmd_help_settime
 5542 0496 0000      		.word	gs(setTimeFunction)
 5543 0498 0000      		.word	cmd_ac
 5544 049a 0000      		.word	cmd_help_ac
 5545 049c 0000      		.word	gs(czytajAC_Function)
 5546 049e 0000      		.word	cmd_disable
 5547 04a0 0000      		.word	cmd_help_disable
 5548 04a2 0000      		.word	gs(disableFunction)
 5549 04a4 0000      		.word	cmd_configure
 5550 04a6 0000      		.word	cmd_help_configure
 5551 04a8 0000      		.word	gs(configureModeFunction)
 5552 04aa 0000      		.word	0
 5553 04ac 0000      		.word	0
 5554 04ae 0000      		.word	0
 5555               	.global	cmdListConfigure
 5556               		.section	.progmem.data
 5559               	cmdListConfigure:
 5560 049e 0000      		.word	cmd_help
 5561 04a0 0000      		.word	cmd_help_help
 5562 04a2 0000      		.word	gs(helpFunction)
 5563 04a4 0000      		.word	cmd_status
 5564 04a6 0000      		.word	cmd_help_status
 5565 04a8 0000      		.word	gs(statusFunction)
 5566 04aa 0000      		.word	cmd_time
 5567 04ac 0000      		.word	cmd_help_time
 5568 04ae 0000      		.word	gs(pokazCzasFunction)
 5569 04b0 0000      		.word	cmd_settime
 5570 04b2 0000      		.word	cmd_help_settime
 5571 04b4 0000      		.word	gs(setTimeFunction)
 5572 04b6 0000      		.word	cmd_conf_ip
 5573 04b8 0000      		.word	cmd_help_conf_ip
 5574 04ba 0000      		.word	gs(setIpFunction)
 5575 04bc 0000      		.word	cmd_conf_ip_mask
 5576 04be 0000      		.word	cmd_conf_ip_mask_help
 5577 04c0 0000      		.word	gs(setIpMaskFunction)
 5578 04c2 0000      		.word	cmd_conf_ip_gw
 5579 04c4 0000      		.word	cmd_conf_ip_gw_help
 5580 04c6 0000      		.word	gs(setIpGwFunction)
 5581 04c8 0000      		.word	cmd_conf_udp
 5582 04ca 0000      		.word	cmd_help_conf_udp
 5583 04cc 0000      		.word	gs(setUdpFunction)
 5584 04ce 0000      		.word	cmd_conf_mac
 5585 04d0 0000      		.word	cmd_help_conf_mac
 5586 04d2 0000      		.word	gs(setMacAddrFunction)
 5587 04d4 0000      		.word	cmd_conf_save
 5588 04d6 0000      		.word	cmd_help_conf_save
 5589 04d8 0000      		.word	gs(saveConfigFunction)
 5590 04da 0000      		.word	cmd_enable
 5591 04dc 0000      		.word	cmd_help_enable
 5592 04de 0000      		.word	gs(enableFunction)
 5593 04e0 0000      		.word	cmd_disable
 5594 04e2 0000      		.word	cmd_help_disable
 5595 04e4 0000      		.word	gs(disableFunction)
 5596 04e6 0000      		.word	0
 5597 04e8 0000      		.word	0
 5598 04ea 0000      		.word	0
 5599               		.comm klastry,128,1
 5600               		.comm wwwport,1,1
 5601               		.comm rollers,2,1
 5602               		.comm xSemaphoreSpiSS,2,1
 5603               		.comm portA,1,1
 5604               		.comm portB,1,1
 5605               		.comm lockSensors,2,1
 5606               		.comm xSemaphoreRs485,2,1
 5607               		.comm nicState,14,1
 5608               		.comm plen,2,1
 5609               		.comm IpMyConfig,15,1
 5610               		.comm arpDebug,2,1
 5611               		.comm arpDebugLevel,1,1
 5612               		.comm icmpDebug,2,1
 5613               		.comm icmpDebugLevel,1,1
 5614               		.comm udpSocket,2,1
 5615               		.comm udpDbgStream,2,1
 5616               		.comm udpDbgLevel,1,1
 5617               		.comm tcpDebugStream,2,1
 5618               		.comm tcpDebugLevel,1,1
 5619               		.comm sockets,2,1
 5620               		.comm czasRtc,7,1
 5621               		.comm fdVty,6,1
 5624               	__c.5194:
 5625 04ec 5761 7274 		.string	"Wartosc probki na wejsciu %d: %d\r\n"
 5625      6F73 6320 
 5625      7072 6F62 
 5625      6B69 206E 
 5625      6120 7765 
 5628               	__c.5245:
 5629 050f 586D 6F64 		.string	"Xmodem: rozpoczynanie odbioru\r\n"
 5629      656D 3A20 
 5629      726F 7A70 
 5629      6F63 7A79 
 5629      6E61 6E69 
 5632               	__c.5159:
 5633 052f 7564 7000 		.string	"udp"
 5636               	__c.5157:
 5637 0533 7463 7000 		.string	"tcp"
 5640               	__c.5155:
 5641 0537 6963 6D70 		.string	"icmp"
 5641      00
 5644               	__c.5153:
 5645 053c 6970 00   		.string	"ip"
 5648               	__c.5151:
 5649 053f 6172 7000 		.string	"arp"
 5652               	__c.5149:
 5653 0543 7564 7000 		.string	"udp"
 5656               	__c.5147:
 5657 0547 7463 7000 		.string	"tcp"
 5660               	__c.5145:
 5661 054b 6963 6D70 		.string	"icmp"
 5661      00
 5664               	__c.5143:
 5665 0550 6970 00   		.string	"ip"
 5668               	__c.5141:
 5669 0553 6172 7000 		.string	"arp"
 5672               	__c.5134:
 5673 0557 416B 7475 		.string	"Aktualny czas %d:%d:%d\r\n"
 5673      616C 6E79 
 5673      2063 7A61 
 5673      7320 2564 
 5673      3A25 643A 
 5676               	__c.5119:
 5677 0570 0D0A 00   		.string	"\r\n"
 5680               	__c.5117:
 5681 0573 0D0A 00   		.string	"\r\n"
 5684               	__c.5115:
 5685 0576 0D0A 00   		.string	"\r\n"
 5688               	__c.5113:
 5689 0579 0D0A 00   		.string	"\r\n"
 5692               	__c.5110:
 5693 057c 4672 6565 		.string	"FreeRtos+ ver 0.31 build: Apr  3 2013, 22:07:38\r\n"
 5693      5274 6F73 
 5693      2B20 7665 
 5693      7220 302E 
 5693      3331 2062 
 5822               		.weak	nicRegDump
 5823               		.weak	nicSetMacAddress
 5824               		.text
 5826               	.Letext0:
 5827               	.global __do_copy_data
 5828               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 vty.c
     /tmp/ccHb5T0M.s:2      *ABS*:0000003f __SREG__
     /tmp/ccHb5T0M.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccHb5T0M.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccHb5T0M.s:5      *ABS*:00000034 __CCP__
     /tmp/ccHb5T0M.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccHb5T0M.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccHb5T0M.s:563    .text:00000000 enableFunction
     /tmp/ccHb5T0M.s:5479   .data:0000041a cmdListEnable
     /tmp/ccHb5T0M.s:611    .text:00000022 disableFunction
     /tmp/ccHb5T0M.s:5447   .progmem.data:00000468 cmdListNormal
     /tmp/ccHb5T0M.s:649    .text:0000003a configureModeFunction
     /tmp/ccHb5T0M.s:5559   .progmem.data:0000049e cmdListConfigure
     /tmp/ccHb5T0M.s:697    .text:0000005c saveConfigFunction
     /tmp/ccHb5T0M.s:722    .text:00000066 setMacAddrFunction
                            *COM*:0000000e nicState
     /tmp/ccHb5T0M.s:805    .text:000000d4 pingFunction
     /tmp/ccHb5T0M.s:867    .text:00000112 setUdpFunction
                            *COM*:00000002 udpSocket
     /tmp/ccHb5T0M.s:1051   .text:00000222 setIpGwFunction
     /tmp/ccHb5T0M.s:1185   .text:000002d6 setIpMaskFunction
     /tmp/ccHb5T0M.s:1245   .text:00000314 setIpFunction
     /tmp/ccHb5T0M.s:1379   .text:000003c8 czytajAC_Function
     /tmp/ccHb5T0M.s:5624   .progmem.data:000004ec __c.5194
     /tmp/ccHb5T0M.s:1461   .text:00000440 setTimeFunction
                            *COM*:00000007 czasRtc
     /tmp/ccHb5T0M.s:1609   .text:00000516 ustawPortRezystor
     /tmp/ccHb5T0M.s:1656   .text:0000053a ustawPortExtBFunction
     /tmp/ccHb5T0M.s:1696   .text:0000055e ustawPortExtAFunction
     /tmp/ccHb5T0M.s:1736   .text:00000582 curtainDownFunction
     /tmp/ccHb5T0M.s:5022   .progmem.data:0000030a movingCurtainDownStr
     /tmp/ccHb5T0M.s:5027   .progmem.data:0000033d movingCurtainPosStr
     /tmp/ccHb5T0M.s:1887   .text:0000065c curtainUpFunction
     /tmp/ccHb5T0M.s:5017   .progmem.data:000002d7 movingCurtainUpStr
     /tmp/ccHb5T0M.s:2062   .text:00000752 goXmodemWyslijFunction
     /tmp/ccHb5T0M.s:5012   .progmem.data:000002ba xwyslijStartStr
                            *COM*:00000006 fdVty
     /tmp/ccHb5T0M.s:4917   .progmem.data:000000ba errorOpenFile
     /tmp/ccHb5T0M.s:2166   .text:000007ee editRamFileFunction
     /tmp/ccHb5T0M.s:5002   .progmem.data:00000280 editRamFileIntroStr
     /tmp/ccHb5T0M.s:2327   .text:000008e4 goXmodemOdbierzFunction
     /tmp/ccHb5T0M.s:5628   .progmem.data:0000050f __c.5245
     /tmp/ccHb5T0M.s:3044   .text:00000cca debugFunction
     /tmp/ccHb5T0M.s:5668   .progmem.data:00000553 __c.5141
     /tmp/ccHb5T0M.s:5664   .progmem.data:00000550 __c.5143
     /tmp/ccHb5T0M.s:5660   .progmem.data:0000054b __c.5145
     /tmp/ccHb5T0M.s:5656   .progmem.data:00000547 __c.5147
     /tmp/ccHb5T0M.s:5652   .progmem.data:00000543 __c.5149
     /tmp/ccHb5T0M.s:5037   .progmem.data:00000360 debugDisabledInfoStr
     /tmp/ccHb5T0M.s:5648   .progmem.data:0000053f __c.5151
     /tmp/ccHb5T0M.s:5644   .progmem.data:0000053c __c.5153
     /tmp/ccHb5T0M.s:5640   .progmem.data:00000537 __c.5155
     /tmp/ccHb5T0M.s:5636   .progmem.data:00000533 __c.5157
     /tmp/ccHb5T0M.s:5632   .progmem.data:0000052f __c.5159
     /tmp/ccHb5T0M.s:5032   .progmem.data:0000034d debugEnabledInfoStr
     /tmp/ccHb5T0M.s:3361   .text:00000eba statusEncFunction
     /tmp/ccHb5T0M.s:3389   .text:00000eca readRamFIleFunction
     /tmp/ccHb5T0M.s:5007   .progmem.data:000002a8 readRamFIleLenStr
     /tmp/ccHb5T0M.s:5421   .progmem.data:00000423 nlStr
     /tmp/ccHb5T0M.s:3588   .text:00000ffc writeRamFileFunction
     /tmp/ccHb5T0M.s:3616   .text:0000100c pokazCzasFunction
     /tmp/ccHb5T0M.s:5672   .progmem.data:00000557 __c.5134
     /tmp/ccHb5T0M.s:3736   .text:000010ba helpFunction
     /tmp/ccHb5T0M.s:3763   .text:000010c4 VtyInit
     /tmp/ccHb5T0M.s:3801   .text:000010e6 printErrorInfo
     /tmp/ccHb5T0M.s:5431   .progmem.data:00000450 errorStrings
     /tmp/ccHb5T0M.s:3894   .text:00001152 eraseRamFileFunction
     /tmp/ccHb5T0M.s:3943   .text:00001180 dodajRamPlikFunction
     /tmp/ccHb5T0M.s:4002   .text:000011b8 flashExModuleFunction
     /tmp/ccHb5T0M.s:4145   .text:00001270 rpingFunction
     /tmp/ccHb5T0M.s:4230   .text:000012ce printStatus
     /tmp/ccHb5T0M.s:5692   .progmem.data:0000057c __c.5110
     /tmp/ccHb5T0M.s:4922   .progmem.data:000000cf systemStateStr
     /tmp/ccHb5T0M.s:4927   .progmem.data:000000df statusNumberOfTasksStr
     /tmp/ccHb5T0M.s:4932   .progmem.data:000000f8 statusStaticHeapStateStr
     /tmp/ccHb5T0M.s:4937   .progmem.data:00000122 statusDynamicHeapStateStr
     /tmp/ccHb5T0M.s:4947   .progmem.data:00000179 statusTemperatureStr
     /tmp/ccHb5T0M.s:4952   .progmem.data:00000194 statusVoltageStr
     /tmp/ccHb5T0M.s:4942   .progmem.data:0000014c statusRamDiskStateStr
     /tmp/ccHb5T0M.s:4957   .progmem.data:000001af systemRamConfigStr
     /tmp/ccHb5T0M.s:4962   .progmem.data:000001c2 statusMacStr
     /tmp/ccHb5T0M.s:5688   .progmem.data:00000579 __c.5113
     /tmp/ccHb5T0M.s:4967   .progmem.data:000001d7 statusIpStr
     /tmp/ccHb5T0M.s:5684   .progmem.data:00000576 __c.5115
     /tmp/ccHb5T0M.s:4972   .progmem.data:000001ec statusIpMaskStr
     /tmp/ccHb5T0M.s:5680   .progmem.data:00000573 __c.5117
     /tmp/ccHb5T0M.s:4977   .progmem.data:00000201 statusIpGwStr
     /tmp/ccHb5T0M.s:5676   .progmem.data:00000570 __c.5119
     /tmp/ccHb5T0M.s:4982   .progmem.data:00000216 statusRs485listStr
     /tmp/ccHb5T0M.s:4987   .progmem.data:00000231 statusNoRs485Dev
     /tmp/ccHb5T0M.s:4992   .progmem.data:0000024b statusLockerSensorsStr
     /tmp/ccHb5T0M.s:4997   .progmem.data:00000264 statusLockerSensorsDisStr
     /tmp/ccHb5T0M.s:4733   .text:00001660 statusFunction
     /tmp/ccHb5T0M.s:4862   .progmem.data:00000000 errorOK
     /tmp/ccHb5T0M.s:4867   .progmem.data:00000009 errorNoFile
     /tmp/ccHb5T0M.s:4872   .progmem.data:00000013 errorxModemFrameStartTimeout
     /tmp/ccHb5T0M.s:4877   .progmem.data:00000016 errorxModemByteSendTimeout
     /tmp/ccHb5T0M.s:4882   .progmem.data:00000019 errorxModemWrongFrameNo
     /tmp/ccHb5T0M.s:4887   .progmem.data:0000001c errorxModemFrameFrameNoCorrectionNotMatch
     /tmp/ccHb5T0M.s:4892   .progmem.data:0000001f errorxModemFrameCrc
     /tmp/ccHb5T0M.s:4897   .progmem.data:00000032 errorxModemRemoteSideCan
     /tmp/ccHb5T0M.s:4902   .progmem.data:00000059 errorxModemUnknownResponse
     /tmp/ccHb5T0M.s:4907   .progmem.data:00000078 errorNoRemoteDevice
     /tmp/ccHb5T0M.s:4912   .progmem.data:0000009b errorBootloaderNotResponding
     /tmp/ccHb5T0M.s:5042   .progmem.data:00000374 cmd_help
     /tmp/ccHb5T0M.s:5048   .data:00000000 cmd_help_help
     /tmp/ccHb5T0M.s:5054   .progmem.data:00000379 cmd_status
     /tmp/ccHb5T0M.s:5060   .data:00000012 cmd_help_status
     /tmp/ccHb5T0M.s:5066   .progmem.data:00000380 cmd_enc_stat
     /tmp/ccHb5T0M.s:5072   .data:00000049 cmd_help_enc_stat
     /tmp/ccHb5T0M.s:5078   .progmem.data:00000388 cmd_time
     /tmp/ccHb5T0M.s:5084   .data:00000063 cmd_help_time
     /tmp/ccHb5T0M.s:5090   .progmem.data:0000038d cmd_net_dbg
     /tmp/ccHb5T0M.s:5096   .data:0000006e cmd_help_net_dbg
     /tmp/ccHb5T0M.s:5103   .progmem.data:00000393 cmd_rping
     /tmp/ccHb5T0M.s:5109   .data:000000b7 cmd_help_rping
     /tmp/ccHb5T0M.s:5115   .progmem.data:00000399 cmd_ping
     /tmp/ccHb5T0M.s:5121   .data:000000dd cmd_help_ping
     /tmp/ccHb5T0M.s:5127   .progmem.data:0000039e cmd_xRec
     /tmp/ccHb5T0M.s:5133   .data:0000010e cmd_help_xRec
     /tmp/ccHb5T0M.s:5139   .progmem.data:000003a3 cmd_xSend
     /tmp/ccHb5T0M.s:5145   .data:00000134 cmd_help_xSend
     /tmp/ccHb5T0M.s:5151   .progmem.data:000003a9 cmd_xflash
     /tmp/ccHb5T0M.s:5157   .data:00000157 cmd_help_xflash
     /tmp/ccHb5T0M.s:5163   .progmem.data:000003b0 cmd_dir_rf
     /tmp/ccHb5T0M.s:5169   .data:0000018f cmd_help_dir_rf
     /tmp/ccHb5T0M.s:5175   .progmem.data:000003b6 cmd_create_rf
     /tmp/ccHb5T0M.s:5181   .data:000001a3 cmd_help_create_rf
     /tmp/ccHb5T0M.s:5187   .progmem.data:000003ba cmd_erase_rf
     /tmp/ccHb5T0M.s:5193   .data:000001bf cmd_help_erase_rf
     /tmp/ccHb5T0M.s:5199   .progmem.data:000003c2 cmd_edit_rf
     /tmp/ccHb5T0M.s:5205   .data:000001e4 cmd_help_edit_rf
     /tmp/ccHb5T0M.s:5211   .progmem.data:000003c9 cmd_read_rf
     /tmp/ccHb5T0M.s:5217   .data:0000020e cmd_help_read_rf
     /tmp/ccHb5T0M.s:5223   .progmem.data:000003d0 cmd_up
     /tmp/ccHb5T0M.s:5229   .data:00000238 cmd_help_up
     /tmp/ccHb5T0M.s:5235   .progmem.data:000003d3 cmd_down
     /tmp/ccHb5T0M.s:5241   .data:0000025e cmd_help_down
     /tmp/ccHb5T0M.s:5247   .progmem.data:000003d8 cmd_spa
     /tmp/ccHb5T0M.s:5253   .data:00000286 cmd_help_spa
     /tmp/ccHb5T0M.s:5259   .progmem.data:000003dc cmd_spb
     /tmp/ccHb5T0M.s:5265   .data:00000299 cmd_help_spb
     /tmp/ccHb5T0M.s:5271   .progmem.data:000003e0 cmd_settime
     /tmp/ccHb5T0M.s:5277   .data:000002ac cmd_help_settime
     /tmp/ccHb5T0M.s:5283   .progmem.data:000003e8 cmd_ac
     /tmp/ccHb5T0M.s:5289   .data:000002ce cmd_help_ac
     /tmp/ccHb5T0M.s:5295   .progmem.data:000003eb cmd_enable
     /tmp/ccHb5T0M.s:5301   .data:000002ee cmd_help_enable
     /tmp/ccHb5T0M.s:5307   .progmem.data:000003f2 cmd_disable
     /tmp/ccHb5T0M.s:5313   .data:000002fa cmd_help_disable
     /tmp/ccHb5T0M.s:5319   .progmem.data:000003fa cmd_configure
     /tmp/ccHb5T0M.s:5325   .data:00000304 cmd_help_configure
     /tmp/ccHb5T0M.s:5331   .progmem.data:00000401 cmd_conf_ip
     /tmp/ccHb5T0M.s:5337   .data:00000313 cmd_help_conf_ip
     /tmp/ccHb5T0M.s:5343   .progmem.data:00000404 cmd_conf_udp
     /tmp/ccHb5T0M.s:5349   .data:00000336 cmd_help_conf_udp
     /tmp/ccHb5T0M.s:5356   .progmem.data:00000408 cmd_conf_ip_mask
     /tmp/ccHb5T0M.s:5362   .data:00000384 cmd_conf_ip_mask_help
     /tmp/ccHb5T0M.s:5368   .progmem.data:0000040d cmd_conf_ip_gw
     /tmp/ccHb5T0M.s:5374   .data:00000394 cmd_conf_ip_gw_help
     /tmp/ccHb5T0M.s:5380   .progmem.data:00000410 cmd_conf_mac
     /tmp/ccHb5T0M.s:5386   .data:000003bc cmd_help_conf_mac
     /tmp/ccHb5T0M.s:5392   .progmem.data:00000414 cmd_conf_save
     /tmp/ccHb5T0M.s:5398   .data:000003ea cmd_help_conf_save
     /tmp/ccHb5T0M.s:5404   .progmem.data:00000419 cmd_ustawR
     /tmp/ccHb5T0M.s:5410   .data:000003fd cmd_help_ustawR
     /tmp/ccHb5T0M.s:5416   .progmem.data:0000041e okStr
     /tmp/ccHb5T0M.s:5426   .progmem.data:00000426 BladBuforaPozostaloBajtowStr
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:00000002 plen
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets

UNDEFINED SYMBOLS
saveConfiguration
cmdlineGetArgHex
nicSetMacAddress
cmdlineGetArgInt
htons
ipSetConfigGw
ipSetConfigMask
ipSetConfigIp
MCP3008_getSampleSingle
fprintf_P
ds1305start
__udivmodqi4
setTimeDecoded
MCP4150_setValue
MPC23s17SetDirB
MPC23s17SetPortB
MPC23s17SetDirA
MPC23s17SetPortA
rs485curtainDown
rs485curtainUp
cmdlineGetArgStr
ramDyskOtworzPlik
ramDyskUstawWskaznikNaKoniec
xVtyRec
xQueueGenericReceive
uartVtySendByte
ramDyskZapiszBajtDoPliku
ramDyskZamknijPlik
fputc
ramDyskDodajBlokXmodem
strncmp_P
setArpDebug
setIpDebug
setIcmpDebug
setTcpDebug
setUdpDebug
nicRegDump
ramDyskCzytajBajtZPliku
ramDyskDir
readTimeDecoded
cmdPrintHelp
cmdStateConfigure
ramDyskUsunPlik
ramDyskUtworzPlik
rs485ping
rs485xModemFlash
uxTaskGetNumberOfTasks
xPortGetFreeHeapSize
xmallocAvailable
temperature
voltage
ramDyskLiczbaWolnychKlastrow
netPrintEthAddr
ipGetConfig
netPrintIPAddr
printRs485devices
printLockers
udpPrintStatus
ramDyskOtworzPlikStdIo
ramDyskZamknijPlikStdIo
__do_copy_data
__do_clear_bss
