
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000b732  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000054a  00802000  0000b732  0000b7e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000dfe  0080254a  0080254a  0000bd30  2**0
                  ALLOC
  3 .eeprom       00000032  00810000  00810000  0000bd30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00019cb0  00000000  00000000  0000bd64  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00014d07  00000000  00000000  00025a14  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2c 08 	jmp	0x1058	; 0x1058 <__ctors_end>
       4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
       8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
       c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      10:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      14:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      18:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      1c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      20:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      24:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      28:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      2c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      30:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      34:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      38:	0c 94 68 54 	jmp	0xa8d0	; 0xa8d0 <__vector_14>
      3c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      40:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      44:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      48:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      4c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      50:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      54:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      58:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      5c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      60:	0c 94 f4 0d 	jmp	0x1be8	; 0x1be8 <__vector_24>
      64:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      68:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      6c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      70:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      74:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      78:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      7c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      80:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      84:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      88:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      8c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      90:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      94:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      98:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      9c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      a8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      ac:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      b8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      bc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      c8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      cc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      d8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      dc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      e8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      ec:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      f8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
      fc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     100:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     104:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     108:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     10c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     110:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     114:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     118:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     11c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     120:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     124:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     128:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     12c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     130:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     134:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     138:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     13c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     140:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     144:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     148:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     14c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     150:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     154:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     158:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     15c:	0c 94 ae 0d 	jmp	0x1b5c	; 0x1b5c <__vector_87>
     160:	0c 94 7d 0a 	jmp	0x14fa	; 0x14fa <__vector_88>
     164:	0c 94 ed 0a 	jmp	0x15da	; 0x15da <__vector_89>
     168:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     16c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     170:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     174:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     178:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     17c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     180:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     184:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     188:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     18c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     190:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     194:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     198:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     19c:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1a8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1ac:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1b8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1bc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1c8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1cc:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d4:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1d8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1dc:	0c 94 4c 09 	jmp	0x1298	; 0x1298 <__vector_119>
     1e0:	0c 94 c3 09 	jmp	0x1386	; 0x1386 <__vector_120>
     1e4:	0c 94 19 0a 	jmp	0x1432	; 0x1432 <__vector_121>
     1e8:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1ec:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>
     1f0:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__bad_interrupt>

000001f4 <statusLockerSensDescStr>:
     1f4:	20 6c 6f 63 6b 65 72 20 25 64 00                     locker %d.

000001ff <statusLockerOpenStr>:
     1ff:	20 6f 70 65 6e 20 20 20 00                           open   .

00000208 <statusLockerCloseStr>:
     208:	20 6c 6f 63 6b 65 64 20 00                           locked .

00000211 <statusLockerSensAdditionalDescStr>:
     211:	20 28 74 68 72 65 73 68 6f 6c 64 20 25 64 2c 20      (threshold %d, 
     221:	41 43 20 76 61 6c 75 65 20 25 64 29 0d 0a 00        AC value %d)...

00000230 <errorOK>:
     230:	41 6c 6c 20 4f 4b 0d 0a 00                          All OK...

00000239 <errorNoFile>:
     239:	4e 6f 20 46 69 6c 65 0d 0a 00                       No File...

00000243 <errorxModemFrameStartTimeout>:
     243:	0d 0a 00                                            ...

00000246 <errorxModemByteSendTimeout>:
     246:	0d 0a 00                                            ...

00000249 <errorxModemWrongFrameNo>:
     249:	0d 0a 00                                            ...

0000024c <errorxModemFrameFrameNoCorrectionNotMatch>:
     24c:	0d 0a 00                                            ...

0000024f <errorxModemFrameCrc>:
     24f:	78 4d 6f 64 65 6d 20 43 52 43 20 65 72 72 6f 72     xModem CRC error
     25f:	0d 0a 00                                            ...

00000262 <errorxModemRemoteSideCan>:
     262:	52 65 6d 6f 74 65 20 73 69 64 65 20 63 61 6e 63     Remote side canc
     272:	65 6c 6c 65 64 20 61 74 20 66 72 61 6d 65 20 6e     elled at frame n
     282:	6f 20 25 64 0d 0a 00                                o %d...

00000289 <errorxModemUnknownResponse>:
     289:	78 4d 6f 64 65 6d 20 75 6e 6b 6e 6f 77 6e 20 72     xModem unknown r
     299:	65 73 70 6f 6e 73 65 20 30 78 25 78 0d 0a 00        esponse 0x%x...

000002a8 <errorNoRemoteDevice>:
     2a8:	44 65 76 69 63 65 20 25 64 20 69 73 20 6e 6f 74     Device %d is not
     2b8:	20 72 65 73 70 6f 6e 64 69 6e 67 20 28 25 64 29      responding (%d)
     2c8:	0d 0a 00                                            ...

000002cb <errorBootloaderNotResponding>:
     2cb:	42 6f 6f 74 6c 6f 61 64 65 72 20 69 73 20 6e 6f     Bootloader is no
     2db:	74 20 72 65 73 70 6f 6e 64 69 6e 67 0d 0a 00        t responding...

000002ea <errorOpenFile>:
     2ea:	43 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 20     Can't open file 
     2fa:	25 73 0d 0a 00                                      %s...

000002ff <systemStateStr>:
     2ff:	53 79 73 74 65 6d 20 73 74 61 74 65 3a 0d 0a 00     System state:...

0000030f <statusNumberOfTasksStr>:
     30f:	20 20 4e 75 6d 62 65 72 20 6f 66 20 74 61 73 6b       Number of task
     31f:	73 20 3a 20 25 64 0d 0a 00                          s : %d...

00000328 <statusStaticHeapStateStr>:
     328:	20 20 46 72 65 65 52 74 6f 73 20 68 65 61 70 20       FreeRtos heap 
     338:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     348:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000352 <statusDynamicHeapStateStr>:
     352:	20 20 4d 61 6c 6c 6f 63 20 68 65 61 70 20 20 20       Malloc heap   
     362:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     372:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

0000037c <statusRamDiskStateStr>:
     37c:	20 20 52 61 6d 20 64 69 73 63 20 73 70 61 63 65       Ram disc space
     38c:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     39c:	64 20 63 6c 75 73 74 65 72 73 0d 0a 00              d clusters...

000003a9 <statusTemperatureStr>:
     3a9:	20 20 54 65 6d 70 65 72 61 74 75 72 65 20 20 20       Temperature   
     3b9:	20 20 3a 20 25 64 20 43 0d 0a 00                      : %d C...

000003c4 <statusVoltageStr>:
     3c4:	20 20 56 6f 6c 74 61 67 65 20 20 20 20 20 20 20       Voltage       
     3d4:	20 20 3a 20 25 64 20 56 0d 0a 00                      : %d V...

000003df <systemRamConfigStr>:
     3df:	53 79 73 74 65 6d 20 73 65 74 74 69 6e 67 73 3a     System settings:
     3ef:	0d 0a 00                                            ...

000003f2 <statusMacStr>:
     3f2:	20 20 4d 61 63 20 61 64 64 72 65 73 73 20 20 20       Mac address   
     402:	20 20 3a 20 00                                        : .

00000407 <statusIpStr>:
     407:	20 20 49 50 20 61 64 64 72 65 73 73 20 20 20 20       IP address    
     417:	20 20 3a 20 00                                        : .

0000041c <statusIpMaskStr>:
     41c:	20 20 6d 61 73 6b 20 20 20 20 20 20 20 20 20 20       mask          
     42c:	20 20 3a 20 00                                        : .

00000431 <statusIpGwStr>:
     431:	20 20 67 61 74 65 77 61 79 20 20 20 20 20 20 20       gateway       
     441:	20 20 3a 20 00                                        : .

00000446 <statusRs485listStr>:
     446:	44 65 74 65 63 74 65 64 20 52 53 20 34 38 35 20     Detected RS 485 
     456:	64 65 76 69 63 65 73 3a 0d 0a 00                    devices:...

00000461 <statusNoRs485Dev>:
     461:	20 20 43 61 6e 27 74 20 66 69 6e 64 20 61 6e 79       Can't find any
     471:	20 64 65 76 69 63 65 0d 0a 00                        device...

0000047b <statusLockerSensorsStr>:
     47b:	4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73 20 73     Locker sensors s
     48b:	74 61 74 65 73 3a 0d 0a 00                          tates:...

00000494 <statusLockerSensorsDisStr>:
     494:	20 20 4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73       Locker sensors
     4a4:	20 64 69 73 61 62 6c 65 64 0d 0a 00                  disabled...

000004b0 <editRamFileIntroStr>:
     4b0:	57 72 69 74 69 6e 67 20 74 6f 20 66 69 6c 65 2e     Writing to file.
     4c0:	20 50 72 65 73 73 20 43 54 52 4c 2b 43 20 74 6f      Press CTRL+C to
     4d0:	20 71 75 69 74 0d 0a 00                              quit...

000004d8 <readRamFIleLenStr>:
     4d8:	46 69 6c 65 20 6c 65 6e 67 74 68 3a 20 25 64 0d     File length: %d.
     4e8:	0a 00                                               ..

000004ea <xwyslijStartStr>:
     4ea:	58 6d 6f 64 65 6d 3a 20 54 72 61 6e 73 6d 69 73     Xmodem: Transmis
     4fa:	73 69 6f 6e 20 73 74 61 72 74 0d 0a 00              sion start...

00000507 <movingCurtainUpStr>:
     507:	50 6f 64 6e 6f 73 7a 65 6e 69 65 20 72 6f 6c 65     Podnoszenie role
     517:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     527:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     537:	0d 0a 00                                            ...

0000053a <movingCurtainDownStr>:
     53a:	4f 70 75 73 7a 63 7a 61 6e 69 65 20 72 6f 6c 65     Opuszczanie role
     54a:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     55a:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     56a:	0d 0a 00                                            ...

0000056d <movingCurtainPosStr>:
     56d:	09 70 6f 7a 79 63 6a 61 20 20 20 25 64 0d 0a 00     .pozycja   %d...

0000057d <debugEnabledInfoStr>:
     57d:	45 6e 61 62 6c 65 64 20 25 73 20 64 65 62 75 67     Enabled %s debug
     58d:	0d 0a 00                                            ...

00000590 <debugDisabledInfoStr>:
     590:	44 69 73 61 62 6c 65 64 20 25 73 20 64 65 62 75     Disabled %s debu
     5a0:	67 0d 0a 00                                         g...

000005a4 <cmd_help>:
     5a4:	68 65 6c 70 00                                      help.

000005a9 <cmd_status>:
     5a9:	73 74 61 74 75 73 00                                status.

000005b0 <cmd_enc_stat>:
     5b0:	65 6e 63 73 74 61 74 00                             encstat.

000005b8 <cmd_time>:
     5b8:	74 69 6d 65 00                                      time.

000005bd <cmd_net_dbg>:
     5bd:	64 65 62 75 67 00                                   debug.

000005c3 <cmd_rping>:
     5c3:	72 70 69 6e 67 00                                   rping.

000005c9 <cmd_ping>:
     5c9:	70 69 6e 67 00                                      ping.

000005ce <cmd_xRec>:
     5ce:	78 72 65 63 00                                      xrec.

000005d3 <cmd_xSend>:
     5d3:	78 73 65 6e 64 00                                   xsend.

000005d9 <cmd_xflash>:
     5d9:	78 66 6c 61 73 68 00                                xflash.

000005e0 <cmd_dir_rf>:
     5e0:	64 69 72 72 66 00                                   dirrf.

000005e6 <cmd_create_rf>:
     5e6:	63 72 66 00                                         crf.

000005ea <cmd_erase_rf>:
     5ea:	65 72 61 73 65 72 66 00                             eraserf.

000005f2 <cmd_edit_rf>:
     5f2:	65 64 69 74 72 66 00                                editrf.

000005f9 <cmd_read_rf>:
     5f9:	72 65 61 64 72 66 00                                readrf.

00000600 <cmd_up>:
     600:	75 70 00                                            up.

00000603 <cmd_down>:
     603:	64 6f 77 6e 00                                      down.

00000608 <cmd_spa>:
     608:	73 70 61 00                                         spa.

0000060c <cmd_spb>:
     60c:	73 70 62 00                                         spb.

00000610 <cmd_settime>:
     610:	73 65 74 74 69 6d 65 00                             settime.

00000618 <cmd_ac>:
     618:	61 63 00                                            ac.

0000061b <cmd_enable>:
     61b:	65 6e 61 62 6c 65 00                                enable.

00000622 <cmd_disable>:
     622:	64 69 73 61 62 6c 65 00                             disable.

0000062a <cmd_configure>:
     62a:	63 6f 6e 66 69 67 00                                config.

00000631 <cmd_conf_ip>:
     631:	69 70 00                                            ip.

00000634 <cmd_conf_udp>:
     634:	75 64 70 00                                         udp.

00000638 <cmd_conf_ip_mask>:
     638:	6d 61 73 6b 00                                      mask.

0000063d <cmd_conf_ip_gw>:
     63d:	67 77 00                                            gw.

00000640 <cmd_conf_mac>:
     640:	6d 61 63 00                                         mac.

00000644 <cmd_conf_save>:
     644:	73 61 76 65 00                                      save.

00000649 <cmd_ustawR>:
     649:	73 65 74 72 00                                      setr.

0000064e <okStr>:
     64e:	4f 4b 0d 0a 00                                      OK...

00000653 <nlStr>:
     653:	0d 0a 00                                            ...

00000656 <BladBuforaPozostaloBajtowStr>:
     656:	21 21 21 20 57 20 62 75 64 6f 72 7a 65 20 52 73     !!! W budorze Rs
     666:	34 38 35 20 70 6f 7a 6f 73 74 61 6c 6f 20 25 64     485 pozostalo %d
     676:	20 62 61 6a 74 6f 77 0d 0a 00                        bajtow...

00000680 <errorStrings>:
     680:	30 02 39 02 43 02 46 02 49 02 4c 02 4f 02 62 02     0.9.C.F.I.L.O.b.
     690:	89 02 a8 02 cb 02 ea 02                             ........

00000698 <cmdListNormal>:
     698:	a4 05 03 20 db 16 a9 05 15 20 ae 19 b8 05 66 20     ... ..... ....f 
     6a8:	84 16 c3 05 ba 20 b6 17 c9 05 e0 20 e8 0e e0 05     ..... ..... ....
     6b8:	92 21 7c 16 f9 05 11 22 e3 15 1b 06 f1 22 7e 0e     .!|...."....."~.
     6c8:	00 00 00 00 00 00                                   ......

000006ce <cmdListConfigure>:
     6ce:	a4 05 03 20 db 16 a9 05 15 20 ae 19 b8 05 66 20     ... ..... ....f 
     6de:	84 16 10 06 af 22 9e 10 31 06 16 23 08 10 38 06     ....."..1..#..8.
     6ee:	87 23 e9 0f 3d 06 97 23 8f 0f 34 06 39 23 07 0f     .#..=..#..4.9#..
     6fe:	40 06 bf 23 b1 0e 44 06 ed 23 ac 0e 1b 06 f1 22     @..#..D..#....."
     70e:	7e 0e 22 06 fd 22 8f 0e 00 00 00 00 00 00           ~.".."........

0000071c <__c.5350>:
     71c:	57 61 72 74 6f 73 63 20 70 72 6f 62 6b 69 20 6e     Wartosc probki n
     72c:	61 20 77 65 6a 73 63 69 75 20 25 64 3a 20 25 64     a wejsciu %d: %d
     73c:	0d 0a 00                                            ...

0000073f <__c.5401>:
     73f:	58 6d 6f 64 65 6d 3a 20 72 6f 7a 70 6f 63 7a 79     Xmodem: rozpoczy
     74f:	6e 61 6e 69 65 20 6f 64 62 69 6f 72 75 0d 0a 00     nanie odbioru...

0000075f <__c.5315>:
     75f:	75 64 70 00                                         udp.

00000763 <__c.5313>:
     763:	74 63 70 00                                         tcp.

00000767 <__c.5311>:
     767:	69 63 6d 70 00                                      icmp.

0000076c <__c.5309>:
     76c:	69 70 00                                            ip.

0000076f <__c.5307>:
     76f:	61 72 70 00                                         arp.

00000773 <__c.5305>:
     773:	75 64 70 00                                         udp.

00000777 <__c.5303>:
     777:	74 63 70 00                                         tcp.

0000077b <__c.5301>:
     77b:	69 63 6d 70 00                                      icmp.

00000780 <__c.5299>:
     780:	69 70 00                                            ip.

00000783 <__c.5297>:
     783:	61 72 70 00                                         arp.

00000787 <__c.5290>:
     787:	41 6b 74 75 61 6c 6e 79 20 63 7a 61 73 20 25 64     Aktualny czas %d
     797:	3a 25 64 3a 25 64 0d 0a 00                          :%d:%d...

000007a0 <__c.5275>:
     7a0:	0d 0a 00                                            ...

000007a3 <__c.5273>:
     7a3:	0d 0a 00                                            ...

000007a6 <__c.5271>:
     7a6:	0d 0a 00                                            ...

000007a9 <__c.5269>:
     7a9:	0d 0a 00                                            ...

000007ac <__c.5266>:
     7ac:	46 72 65 65 52 74 6f 73 2b 20 76 65 72 20 30 2e     FreeRtos+ ver 0.
     7bc:	33 31 20 62 75 69 6c 64 3a 20 41 70 72 20 31 36     31 build: Apr 16
     7cc:	20 32 30 31 33 2c 20 31 35 3a 34 39 3a 35 32 0d      2013, 15:49:52.
     7dc:	0a 00                                               ..

000007de <__c.5076>:
     7de:	55 6e 6b 6e 6f 77 6e 20 70 61 63 6b 65 74 0d 0a     Unknown packet..
	...

000007ef <__c.3756>:
     7ef:	52 65 73 74 61 72 74 0d 0a 00                       Restart...

000007f9 <CmdlinePromptNormal>:
     7f9:	44 6f 6d 4f 73 3e 00                                DomOs>.

00000800 <CmdlinePromptEnable>:
     800:	44 6f 6d 4f 73 23 00                                DomOs#.

00000807 <CmdlinePromptConfigure>:
     807:	44 6f 6d 4f 73 40 00                                DomOs@.

0000080e <CmdlineNotice>:
     80e:	63 6d 64 6c 69 6e 65 3a 20 00                       cmdline: .

00000818 <CmdlineCmdNotFound>:
     818:	23 20 6e 6b 00                                      # nk.

0000081d <__c.5303>:
     81d:	0d 0a 00                                            ...

00000820 <__c.5301>:
     820:	09 00                                               ..

00000822 <__c.5213>:
     822:	4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 61 6c     Operation not al
     832:	6c 6f 77 65 64 0d 0a 00                             lowed...

0000083a <__c.5210>:
     83a:	4f 70 65 72 61 74 69 6f 6e 20 66 61 69 6c 65 64     Operation failed
     84a:	0d 0a 00                                            ...

0000084d <__c.5207>:
     84d:	0d 0a 00                                            ...

00000850 <__c.5205>:
     850:	20 00                                                .

00000852 <__c.5203>:
     852:	53 79 6e 74 61 78 20 45 72 72 6f 72 2e 20 55 73     Syntax Error. Us
     862:	65 3a 20 00                                         e: .

00000866 <__c.5199>:
     866:	4f 4b 0d 0a 00                                      OK...

0000086b <__c.5212>:
     86b:	09 4d 41 41 44 52 35 20 30 78 25 78 0d 0a 00        .MAADR5 0x%x...

0000087a <__c.5210>:
     87a:	09 4d 41 41 44 52 34 20 30 78 25 78 0d 0a 00        .MAADR4 0x%x...

00000889 <__c.5208>:
     889:	09 4d 41 41 44 52 33 20 30 78 25 78 0d 0a 00        .MAADR3 0x%x...

00000898 <__c.5206>:
     898:	09 4d 41 41 44 52 32 20 30 78 25 78 0d 0a 00        .MAADR2 0x%x...

000008a7 <__c.5204>:
     8a7:	09 4d 41 41 44 52 31 20 30 78 25 78 0d 0a 00        .MAADR1 0x%x...

000008b6 <__c.5202>:
     8b6:	09 4d 41 41 44 52 30 20 30 78 25 78 0d 0a 00        .MAADR0 0x%x...

000008c5 <__c.5200>:
     8c5:	45 4e 43 32 38 6a 36 30 20 73 74 61 6e 20 72 65     ENC28j60 stan re
     8d5:	6a 65 73 74 72 6f 77 3a 0d 0a 00                    jestrow:...

000008e0 <__c.3740>:
     8e0:	4e 49 43 20 72 65 67 20 64 75 6d 70 20 6e 6f 74     NIC reg dump not
     8f0:	20 69 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00         implemented...

000008ff <__c.3601>:
     8ff:	0d 0a 00                                            ...

00000902 <__c.3599>:
     902:	55 52 47 20 00                                      URG .

00000907 <__c.3597>:
     907:	41 43 4b 20 00                                      ACK .

0000090c <__c.3595>:
     90c:	50 53 48 20 00                                      PSH .

00000911 <__c.3593>:
     911:	52 53 54 20 00                                      RST .

00000916 <__c.3591>:
     916:	53 59 4e 20 00                                      SYN .

0000091b <__c.3589>:
     91b:	46 49 4e 20 00                                      FIN .

00000920 <__c.3587>:
     920:	46 6c 61 67 73 20 20 20 3a 20 00                    Flags   : .

0000092b <__c.3585>:
     92b:	41 63 6b 20 4e 75 6d 20 3a 20 30 78 25 78 0d 0a     Ack Num : 0x%x..
	...

0000093c <__c.3583>:
     93c:	53 65 71 20 4e 75 6d 20 3a 20 30 78 25 78 00        Seq Num : 0x%x.

0000094b <__c.3581>:
     94b:	44 73 74 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Dst Port: %d...

0000095a <__c.3579>:
     95a:	53 72 63 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Src Port: %d...

00000969 <__c.3577>:
     969:	54 43 50 20 48 65 61 64 65 72 0d 0a 00              TCP Header...

00000976 <__c.3571>:
     976:	0d 0a 00                                            ...

00000979 <__c.3569>:
     979:	44 65 73 74 20 20 49 50 3a 20 00                    Dest  IP: .

00000984 <__c.3567>:
     984:	0d 0a 00                                            ...

00000987 <__c.3565>:
     987:	53 6f 75 72 63 65 49 50 3a 20 00                    SourceIP: .

00000992 <__c.3563>:
     992:	50 72 6f 74 6f 63 6f 6c 3a 20 25 64 0d 0a 00        Protocol: %d...

000009a1 <__c.3561>:
     9a1:	50 72 6f 74 6f 63 6f 6c 3a 20 55 44 50 0d 0a 00     Protocol: UDP...

000009b1 <__c.3559>:
     9b1:	50 72 6f 74 6f 63 6f 6c 3a 20 54 43 50 0d 0a 00     Protocol: TCP...

000009c1 <__c.3557>:
     9c1:	50 72 6f 74 6f 63 6f 6c 3a 20 49 43 4d 50 0d 0a     Protocol: ICMP..
	...

000009d2 <__c.3555>:
     9d2:	4c 65 6e 67 74 68 20 20 3a 20 25 64 0d 0a 00        Length  : %d...

000009e1 <__c.3553>:
     9e1:	56 65 72 20 20 20 20 20 3a 20 25 64 0d 0a 00        Ver     : %d...

000009f0 <__c.3551>:
     9f0:	49 50 20 48 65 61 64 65 72 0d 0a 00                 IP Header...

000009fc <__c.3545>:
     9fc:	2d 3e 44 53 54 3a 00                                ->DST:.

00000a03 <__c.3543>:
     a03:	20 53 52 43 3a 00                                    SRC:.

00000a09 <__c.3541>:
     a09:	45 74 68 20 50 61 63 6b 65 74 20 54 79 70 65 3a     Eth Packet Type:
     a19:	20 30 78 25 78 00                                    0x%x.

00000a1f <__c.3535>:
     a1f:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

00000a2b <__c.3529>:
     a2b:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
     a3b:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

00000a49 <__c.4280>:
     a49:	0d 0a 00                                            ...

00000a4c <__c.4278>:
     a4c:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00000a57 <__c.4276>:
     a57:	0d 0a 00                                            ...

00000a5a <__c.4274>:
     a5a:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00000a65 <__c.4272>:
     a65:	0d 0a 00                                            ...

00000a68 <__c.4270>:
     a68:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00000a73 <__c.4264>:
     a73:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     a83:	6c 65 28 6c 65 6e 2d 45 54 48 5f 48 45 41 44 45     le(len-ETH_HEADE
     a93:	52 5f 4c 45 4e 2c 20 26 64 61 74 61 5b 45 54 48     R_LEN, &data[ETH
     aa3:	5f 48 45 41 44 45 52 5f 4c 45 4e 5d 29 3b 00        _HEADER_LEN]);.

00000ab2 <__c.4262>:
     ab2:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     ac2:	6c 65 28 45 54 48 5f 48 45 41 44 45 52 5f 4c 45     le(ETH_HEADER_LE
     ad2:	4e 2c 20 26 64 61 74 61 5b 30 5d 29 3b 00           N, &data[0]);.

00000ae0 <__c.4260>:
     ae0:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     af0:	74 20 74 6f 20 67 61 74 65 77 61 79 0d 0a 00        t to gateway...

00000aff <__c.4258>:
     aff:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     b0f:	74 20 6f 6e 20 6c 6f 63 61 6c 20 6e 65 74 0d 0a     t on local net..
	...

00000b20 <__c.4230>:
     b20:	4e 45 54 20 52 78 3a 20 55 6e 6b 6e 6f 77 6e 20     NET Rx: Unknown 
     b30:	49 50 20 70 61 63 6b 65 74 0d 0a 00                 IP packet...

00000b3c <__c.4228>:
     b3c:	4e 45 54 20 52 78 3a 20 54 43 50 2f 49 50 20 70     NET Rx: TCP/IP p
     b4c:	61 63 6b 65 74 0d 0a 00                             acket...

00000b54 <__c.4226>:
     b54:	4e 45 54 20 52 78 3a 20 55 44 50 2f 49 50 20 70     NET Rx: UDP/IP p
     b64:	61 63 6b 65 74 0d 0a 00                             acket...

00000b6c <__c.4224>:
     b6c:	4e 45 54 20 52 78 3a 20 49 43 4d 50 2f 49 50 20     NET Rx: ICMP/IP 
     b7c:	70 61 63 6b 65 74 0d 0a 00                          packet...

00000b85 <__c.4262>:
     b85:	43 6f 64 65 20 20 20 3a 20 30 78 25 78 0d 0a 00     Code   : 0x%x...

00000b95 <__c.4260>:
     b95:	0d 0a 00                                            ...

00000b98 <__c.4257>:
     b98:	45 43 48 4f 20 52 45 50 4c 59 00                    ECHO REPLY.

00000ba3 <__c.4253>:
     ba3:	45 43 48 4f 20 52 45 51 55 45 53 54 00              ECHO REQUEST.

00000bb0 <__c.4250>:
     bb0:	54 79 70 65 20 20 20 3a 20 00                       Type   : .

00000bba <__c.4248>:
     bba:	0d 0a 00                                            ...

00000bbd <__c.4246>:
     bbd:	44 73 74 49 70 41 64 64 72 3a 20 00                 DstIpAddr: .

00000bc9 <__c.4244>:
     bc9:	0d 0a 00                                            ...

00000bcc <__c.4242>:
     bcc:	53 72 63 49 70 41 64 64 72 3a 20 00                 SrcIpAddr: .

00000bd8 <__c.4240>:
     bd8:	49 43 4d 50 20 50 61 63 6b 65 74 3a 0d 0a 00        ICMP Packet:...

00000be7 <__c.4229>:
     be7:	53 65 6e 64 69 6e 67 20 49 43 4d 50 20 50 4f 4e     Sending ICMP PON
     bf7:	47 0d 0a 00                                         G...

00000bfb <__c.4226>:
     bfb:	52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72 65     Received ICMP re
     c0b:	71 75 65 73 74 3a 20 00                             quest: .

00000c13 <__c.4221>:
     c13:	55 6e 6b 6e 6f 77 6e 20 49 43 4d 50 20 74 79 70     Unknown ICMP typ
     c23:	65 52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72     eReceived ICMP r
     c33:	65 71 75 65 73 74 3a 20 00                          equest: .

00000c3c <__c.4312>:
     c3c:	0d 0a 00                                            ...

00000c3f <__c.4310>:
     c3f:	20 20 00                                              .

00000c42 <__c.4308>:
     c42:	25 33 64 20 20 00                                   %3d  .

00000c48 <__c.4305>:
     c48:	0d 0a 00                                            ...

00000c4b <__c.4303>:
     c4b:	20 20 00                                              .

00000c4e <__c.4301>:
     c4e:	20 4d 59 20 20 00                                    MY  .

00000c54 <__c.4299>:
     c54:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     c64:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     c74:	2d 2d 2d 0d 0a 00                                   ---...

00000c7a <__c.4297>:
     c7a:	54 69 6d 65 20 45 74 68 20 41 64 64 72 65 73 73     Time Eth Address
     c8a:	20 20 20 20 20 20 20 20 49 50 20 41 64 64 72 65             IP Addre
     c9a:	73 73 0d 0a 00                                      ss...

00000c9f <__c.4291>:
     c9f:	0d 0a 00                                            ...

00000ca2 <__c.4289>:
     ca2:	44 73 74 50 72 6f 74 6f 41 64 64 72 3a 20 00        DstProtoAddr: .

00000cb1 <__c.4287>:
     cb1:	0d 0a 00                                            ...

00000cb4 <__c.4285>:
     cb4:	44 73 74 48 77 41 64 64 72 20 20 20 3a 20 00        DstHwAddr   : .

00000cc3 <__c.4283>:
     cc3:	0d 0a 00                                            ...

00000cc6 <__c.4281>:
     cc6:	53 72 63 50 72 6f 74 6f 41 64 64 72 3a 20 00        SrcProtoAddr: .

00000cd5 <__c.4279>:
     cd5:	0d 0a 00                                            ...

00000cd8 <__c.4277>:
     cd8:	53 72 63 48 77 41 64 64 72 20 20 20 3a 20 00        SrcHwAddr   : .

00000ce7 <__c.4275>:
     ce7:	0d 0a 00                                            ...

00000cea <__c.4273>:
     cea:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

00000cf2 <__c.4271>:
     cf2:	52 45 50 4c 59 00                                   REPLY.

00000cf8 <__c.4269>:
     cf8:	52 45 51 55 45 53 54 00                             REQUEST.

00000d00 <__c.4267>:
     d00:	4f 70 65 72 61 74 69 6f 6e 20 20 20 3a 20 00        Operation   : .

00000d0f <__c.4265>:
     d0f:	41 52 50 20 50 61 63 6b 65 74 3a 0d 0a 00           ARP Packet:...

00000d1d <__c.4237>:
     d1d:	0d 0a 00                                            ...

00000d20 <__c.4235>:
     d20:	20 49 50 3a 20 00                                    IP: .

00000d26 <__c.4233>:
     d26:	41 52 50 20 49 50 20 69 6e 20 4d 41 43 3a 20 00     ARP IP in MAC: .

00000d36 <__c.4228>:
     d36:	53 65 6e 64 69 6e 67 20 41 52 50 20 52 65 70 6c     Sending ARP Repl
     d46:	79 0d 0a 00                                         y...

00000d4a <__c.4226>:
     d4a:	52 65 63 65 69 76 65 64 20 41 52 50 20 52 65 71     Received ARP Req
     d5a:	75 65 73 74 0d 0a 00                                uest...

00000d61 <__c.4269>:
     d61:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
     d71:	6e 74 65 64 0d 0a 00                                nted...

00000d78 <__c.4255>:
     d78:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     d88:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
     d98:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
     da8:	74 0d 0a 00                                         t...

00000dac <__c.4253>:
     dac:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     dbc:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
     dcc:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
     ddc:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
     dec:	49 53 48 45 44 0d 0a 00                             ISHED...

00000df4 <__c.4251>:
     df4:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     e04:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
     e14:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
     e24:	74 0d 0a 00                                         t...

00000e28 <__c.4249>:
     e28:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
     e38:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
     e48:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
     e58:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
     e68:	0a 00                                               ..

00000e6a <__c.4240>:
     e6a:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
     e7a:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
     e8a:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

00000e94 <__c.4235>:
     e94:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
     ea4:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
     eb4:	54 45 4e 0d 0a 00                                   TEN...

00000eba <__c.4230>:
     eba:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
     eca:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

00000ed6 <__c.4268>:
     ed6:	25 64 0d 0a 00                                      %d...

00000edb <__c.4266>:
     edb:	41 4e 59 0d 0a 00                                   ANY...

00000ee1 <__c.4264>:
     ee1:	0d 0a 20 20 73 72 63 20 70 6f 72 74 20 20 20 20     ..  src port    
     ef1:	3a 20 25 64 0d 0a 20 20 64 73 74 20 70 6f 72 74     : %d..  dst port
     f01:	20 20 20 20 3a 20 00                                    : .

00000f08 <__c.4262>:
     f08:	0d 0a 20 20 49 50 20 20 20 20 20 20 20 20 20 20     ..  IP          
     f18:	3a 20 00                                            : .

00000f1b <__c.4260>:
     f1b:	55 44 50 20 63 6f 6e 66 69 67 3a 00                 UDP config:.

00000f27 <__c.4244>:
     f27:	0d 0a 00                                            ...

00000f2a <__c.4239>:
     f2a:	55 44 50 20 54 58 20 62 75 66 66 65 72 20 62 75     UDP TX buffer bu
     f3a:	73 79 0d 0a 00                                      sy...

00000f3f <__c.4237>:
     f3f:	30 78 25 32 78 0d 0a 00                             0x%2x...

00000f47 <__c.4235>:
     f47:	52 65 63 65 69 76 65 64 20 64 61 74 61 3a 20 00     Received data: .

00000f57 <__c.4232>:
     f57:	50 72 6f 63 2e 20 55 44 50 20 70 61 63 6b 65 74     Proc. UDP packet
     f67:	20 28 64 61 74 61 20 6c 65 6e 67 74 68 20 25 64      (data length %d
     f77:	29 0d 0a 00                                         )...

00000f7b <__c.4225>:
     f7b:	53 65 6e 64 69 6e 67 20 55 44 50 20 70 61 63 6b     Sending UDP pack
     f8b:	65 74 20 28 64 61 74 61 20 6c 65 6e 67 74 68 20     et (data length 
     f9b:	25 64 29 0d 0a 00                                   %d)...

00000fa1 <statusRollerDescStr>:
     fa1:	20 25 64 20 72 6f 6c 6c 65 72 20 64 72 69 76 65      %d roller drive
     fb1:	72 3a 20 72 6f 6c 6c 65 72 20 31 20 70 6f 73 69     r: roller 1 posi
     fc1:	74 69 6f 6e 20 25 64 2c 20 72 6f 6c 6c 65 72 20     tion %d, roller 
     fd1:	32 20 70 6f 73 69 74 69 6f 6e 20 25 64 00           2 position %d.

00000fdf <statusRollerDescStr2>:
     fdf:	2c 20 66 69 72 6d 77 61 72 65 20 25 73 0d 0a 00     , firmware %s...

00000fef <__c.5187>:
     fef:	62 6f 6f 74 6c 6f 61 64 65 72 20 6e 69 65 20 72     bootloader nie r
     fff:	6f 7a 70 6f 63 7a 61 6c 20 6f 64 62 69 6f 72 75     ozpoczal odbioru
    100f:	20 64 61 6e 79 63 68 0d 0a 00                        danych...

00001019 <__c.5185>:
    1019:	6e 61 20 75 72 7a 61 64 7a 65 6e 69 75 20 77 67     na urzadzeniu wg
    1029:	72 61 6e 79 20 6a 65 73 74 20 74 79 6c 6b 6f 20     rany jest tylko 
    1039:	62 6f 6f 74 6c 6f 61 64 65 72 0d 0a 00              bootloader...

00001046 <__c.5183>:
    1046:	72 46 4c 41 53 48 20 74 69 6d 65 6f 75 74 0d 0a     rFLASH timeout..
	...

00001058 <__ctors_end>:
    1058:	11 24       	eor	r1, r1
    105a:	1f be       	out	0x3f, r1	; 63
    105c:	cf ef       	ldi	r28, 0xFF	; 255
    105e:	df e3       	ldi	r29, 0x3F	; 63
    1060:	de bf       	out	0x3e, r29	; 62
    1062:	cd bf       	out	0x3d, r28	; 61
    1064:	00 e0       	ldi	r16, 0x00	; 0
    1066:	0c bf       	out	0x3c, r16	; 60
    1068:	18 be       	out	0x38, r1	; 56
    106a:	19 be       	out	0x39, r1	; 57
    106c:	1a be       	out	0x3a, r1	; 58
    106e:	1b be       	out	0x3b, r1	; 59

00001070 <__do_copy_data>:
    1070:	15 e2       	ldi	r17, 0x25	; 37
    1072:	a0 e0       	ldi	r26, 0x00	; 0
    1074:	b0 e2       	ldi	r27, 0x20	; 32
    1076:	e2 e3       	ldi	r30, 0x32	; 50
    1078:	f7 eb       	ldi	r31, 0xB7	; 183
    107a:	00 e0       	ldi	r16, 0x00	; 0
    107c:	0b bf       	out	0x3b, r16	; 59
    107e:	02 c0       	rjmp	.+4      	; 0x1084 <__do_copy_data+0x14>
    1080:	07 90       	elpm	r0, Z+
    1082:	0d 92       	st	X+, r0
    1084:	aa 34       	cpi	r26, 0x4A	; 74
    1086:	b1 07       	cpc	r27, r17
    1088:	d9 f7       	brne	.-10     	; 0x1080 <__do_copy_data+0x10>

0000108a <__do_clear_bss>:
    108a:	13 e3       	ldi	r17, 0x33	; 51
    108c:	aa e4       	ldi	r26, 0x4A	; 74
    108e:	b5 e2       	ldi	r27, 0x25	; 37
    1090:	01 c0       	rjmp	.+2      	; 0x1094 <.do_clear_bss_start>

00001092 <.do_clear_bss_loop>:
    1092:	1d 92       	st	X+, r1

00001094 <.do_clear_bss_start>:
    1094:	a8 34       	cpi	r26, 0x48	; 72
    1096:	b1 07       	cpc	r27, r17
    1098:	e1 f7       	brne	.-8      	; 0x1092 <.do_clear_bss_loop>
    109a:	0e 94 53 08 	call	0x10a6	; 0x10a6 <main>
    109e:	0c 94 97 5b 	jmp	0xb72e	; 0xb72e <_exit>

000010a2 <__bad_interrupt>:
    10a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000010a6 <main>:
FILE udpStream;

streamBuffers_t udpBuffers;

portSHORT main( void )
{
    10a6:	af 92       	push	r10
    10a8:	bf 92       	push	r11
    10aa:	cf 92       	push	r12
    10ac:	df 92       	push	r13
    10ae:	ef 92       	push	r14
    10b0:	ff 92       	push	r15
    10b2:	0f 93       	push	r16
  //ramDyskInit();              //Inicjalizacja Ram dysku
  //hardwareInit();
  //spiInit(disableAllSpiDevices);
  // MOJE
  /* konfiguracja zewnętrznego kwarcu, bez PLL, Pres ABCD=1*/
	OSC.XOSCCTRL=0b1101011;
    10b4:	8b e6       	ldi	r24, 0x6B	; 107
    10b6:	e0 e5       	ldi	r30, 0x50	; 80
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	82 83       	std	Z+2, r24	; 0x02
	OSC.CTRL=0b00001000;
    10bc:	88 e0       	ldi	r24, 0x08	; 8
    10be:	80 93 50 00 	sts	0x0050, r24
	while(!(OSC.STATUS & OSC_XOSCEN_bm));
    10c2:	80 91 51 00 	lds	r24, 0x0051
    10c6:	83 ff       	sbrs	r24, 3
    10c8:	fc cf       	rjmp	.-8      	; 0x10c2 <main+0x1c>
	CCP = CCP_IOREG_gc;
    10ca:	88 ed       	ldi	r24, 0xD8	; 216
    10cc:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL=CLK_SCLKSEL_XOSC_gc;
    10ce:	83 e0       	ldi	r24, 0x03	; 3
    10d0:	80 93 40 00 	sts	0x0040, r24
	// Koniec konfuguracji, Zew kwarc 16MHz
	PORTD.OUT=0xFF; //ok
    10d4:	e0 e6       	ldi	r30, 0x60	; 96
    10d6:	f6 e0       	ldi	r31, 0x06	; 6
    10d8:	9f ef       	ldi	r25, 0xFF	; 255
    10da:	94 83       	std	Z+4, r25	; 0x04
	PORTD.DIR=PIN3_bm;//ok
    10dc:	98 e0       	ldi	r25, 0x08	; 8
    10de:	90 93 60 06 	sts	0x0660, r25
	PORTD.DIRCLR = PIN2_bm;//ok
    10e2:	94 e0       	ldi	r25, 0x04	; 4
    10e4:	92 83       	std	Z+2, r25	; 0x02
	USARTD0.CTRLC=0b00000011;//ok
    10e6:	e0 ea       	ldi	r30, 0xA0	; 160
    10e8:	f9 e0       	ldi	r31, 0x09	; 9
    10ea:	85 83       	std	Z+5, r24	; 0x05
	USARTD0.CTRLA|=(USART_RXCINTLVL_LO_gc)|(USART_TXCINTLVL_LO_gc);
    10ec:	80 91 a3 09 	lds	r24, 0x09A3
    10f0:	84 61       	ori	r24, 0x14	; 20
    10f2:	83 83       	std	Z+3, r24	; 0x03
	USARTD0.BAUDCTRLA=0b01100111;//12;
    10f4:	87 e6       	ldi	r24, 0x67	; 103
    10f6:	86 83       	std	Z+6, r24	; 0x06
	USARTD0.BAUDCTRLB=0;//(0 << USART_BSCALE0_bp)|(12 >> 8);
    10f8:	17 82       	std	Z+7, r1	; 0x07
	USARTD0.CTRLB=0b00011000;
    10fa:	88 e1       	ldi	r24, 0x18	; 24
    10fc:	84 83       	std	Z+4, r24	; 0x04
	lcdinit();
    10fe:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <lcdinit>
  //MOJE
// VTY on serial  
  //xSerialPortInitMinimal(); 
  CLIStateSerialUsb  = xmalloc(sizeof(cmdState_t));
    1102:	83 e2       	ldi	r24, 0x23	; 35
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <xmalloc>
    110a:	80 93 00 32 	sts	0x3200, r24
    110e:	90 93 01 32 	sts	0x3201, r25
  CLIStateSerialUdp  = xmalloc(sizeof(cmdState_t));
    1112:	83 e2       	ldi	r24, 0x23	; 35
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <xmalloc>
    111a:	80 93 c2 32 	sts	0x32C2, r24
    111e:	90 93 c3 32 	sts	0x32C3, r25
 // socketInit();
 // initQueueStream(&udpStream, &udpBuffers, udpSocket->Rx, udpSocket->Tx);
 // VtyInit(CLIStateSerialUdp, &udpStream);
  
//xTaskCreate(encTask,        NULL /*"ENC"    */, STACK_SIZE_ENC,       (void *)CLIStateSerialUsb->myStdInOut,  0, &xHandleEnc);
  xTaskCreate(vTaskVTYusb,    NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUsb),            1, &xHandleVTY_USB);
    1122:	20 91 00 32 	lds	r18, 0x3200
    1126:	30 91 01 32 	lds	r19, 0x3201
    112a:	80 e6       	ldi	r24, 0x60	; 96
    112c:	9a e1       	ldi	r25, 0x1A	; 26
    112e:	60 e0       	ldi	r22, 0x00	; 0
    1130:	70 e0       	ldi	r23, 0x00	; 0
    1132:	4c eb       	ldi	r20, 0xBC	; 188
    1134:	52 e0       	ldi	r21, 0x02	; 2
    1136:	01 e0       	ldi	r16, 0x01	; 1
    1138:	fe e1       	ldi	r31, 0x1E	; 30
    113a:	ef 2e       	mov	r14, r31
    113c:	f2 e3       	ldi	r31, 0x32	; 50
    113e:	ff 2e       	mov	r15, r31
    1140:	cc 24       	eor	r12, r12
    1142:	dd 24       	eor	r13, r13
    1144:	aa 24       	eor	r10, r10
    1146:	bb 24       	eor	r11, r11
    1148:	0e 94 83 46 	call	0x8d06	; 0x8d06 <xTaskGenericCreate>
//xTaskCreate(vTaskVTYsocket, NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUdp),            1, &xHandleVTY_UDP);
//xTaskCreate(sensorsTask,    NULL /*"Sensors"*/, STACK_SIZE_SENSORS,   NULL,                                   1, &xHandleSensors);
  xTaskCreate(vTaskUSB,NULL,100,NULL,0,&xHandleUSB);
    114c:	89 e9       	ldi	r24, 0x99	; 153
    114e:	9a e1       	ldi	r25, 0x1A	; 26
    1150:	60 e0       	ldi	r22, 0x00	; 0
    1152:	70 e0       	ldi	r23, 0x00	; 0
    1154:	44 e6       	ldi	r20, 0x64	; 100
    1156:	50 e0       	ldi	r21, 0x00	; 0
    1158:	20 e0       	ldi	r18, 0x00	; 0
    115a:	30 e0       	ldi	r19, 0x00	; 0
    115c:	00 e0       	ldi	r16, 0x00	; 0
    115e:	ec ee       	ldi	r30, 0xEC	; 236
    1160:	ee 2e       	mov	r14, r30
    1162:	e1 e3       	ldi	r30, 0x31	; 49
    1164:	fe 2e       	mov	r15, r30
    1166:	0e 94 83 46 	call	0x8d06	; 0x8d06 <xTaskGenericCreate>
  vTaskStartScheduler();
    116a:	0e 94 ed 48 	call	0x91da	; 0x91da <vTaskStartScheduler>
  return 0;
}
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	0f 91       	pop	r16
    1174:	ff 90       	pop	r15
    1176:	ef 90       	pop	r14
    1178:	df 90       	pop	r13
    117a:	cf 90       	pop	r12
    117c:	bf 90       	pop	r11
    117e:	af 90       	pop	r10
    1180:	08 95       	ret

00001182 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
    1182:	0e 94 8a 51 	call	0xa314	; 0xa314 <vCoRoutineSchedule>
    1186:	fd cf       	rjmp	.-6      	; 0x1182 <vApplicationIdleHook>

00001188 <vApplicationTickHook>:
}

void vApplicationTickHook( void )
{
  static uint16_t tickCntr = configTICK_RATE_HZ;
  if (--tickCntr == 0)
    1188:	80 91 00 20 	lds	r24, 0x2000
    118c:	90 91 01 20 	lds	r25, 0x2001
    1190:	01 97       	sbiw	r24, 0x01	; 1
    1192:	80 93 00 20 	sts	0x2000, r24
    1196:	90 93 01 20 	sts	0x2001, r25
    119a:	00 97       	sbiw	r24, 0x00	; 0
    119c:	41 f4       	brne	.+16     	; 0x11ae <vApplicationTickHook+0x26>
  {
    tickCntr = configTICK_RATE_HZ;
    119e:	88 ee       	ldi	r24, 0xE8	; 232
    11a0:	93 e0       	ldi	r25, 0x03	; 3
    11a2:	80 93 00 20 	sts	0x2000, r24
    11a6:	90 93 01 20 	sts	0x2001, r25
    arpTimer();    
    11aa:	0e 94 6a 36 	call	0x6cd4	; 0x6cd4 <arpTimer>
    11ae:	08 95       	ret

000011b0 <loadConfiguration>:
                                                                                       {LOCK_SENS_3_ENA, LOCK_SENS_3_THR, 0, 0},
                                                                                       {LOCK_SENS_4_ENA, LOCK_SENS_4_THR, 0, 0}};

void loadConfiguration(void)
{
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
    11b0:	80 91 02 32 	lds	r24, 0x3202
    11b4:	90 91 03 32 	lds	r25, 0x3203
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	70 e0       	ldi	r23, 0x00	; 0
    11bc:	48 e1       	ldi	r20, 0x18	; 24
    11be:	50 e0       	ldi	r21, 0x00	; 0
    11c0:	0e 94 67 5a 	call	0xb4ce	; 0xb4ce <__eerd_block_x128a1>
}
    11c4:	08 95       	ret

000011c6 <saveConfiguration>:

void saveConfiguration(void)
{
  saveNic();
    11c6:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <saveNic>
  ipSaveConfig();
    11ca:	0e 94 18 32 	call	0x6430	; 0x6430 <ipSaveConfig>
  udpSaveConfig();
    11ce:	0e 94 e5 3e 	call	0x7dca	; 0x7dca <udpSaveConfig>
}
    11d2:	08 95       	ret

000011d4 <VtyGetChar>:
  fdev_set_udata(stream, NULL);
  return;
}

int VtyGetChar(FILE *stream)
{
    11d4:	df 93       	push	r29
    11d6:	cf 93       	push	r28
    11d8:	0f 92       	push	r0
    11da:	cd b7       	in	r28, 0x3d	; 61
    11dc:	de b7       	in	r29, 0x3e	; 62
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    11de:	80 91 0f 32 	lds	r24, 0x320F
    11e2:	90 91 10 32 	lds	r25, 0x3210
    11e6:	be 01       	movw	r22, r28
    11e8:	6f 5f       	subi	r22, 0xFF	; 255
    11ea:	7f 4f       	sbci	r23, 0xFF	; 255
    11ec:	4f ef       	ldi	r20, 0xFF	; 255
    11ee:	5f ef       	ldi	r21, 0xFF	; 255
    11f0:	20 e0       	ldi	r18, 0x00	; 0
    11f2:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    11f6:	88 23       	and	r24, r24
    11f8:	19 f0       	breq	.+6      	; 0x1200 <VtyGetChar+0x2c>
    return EOF;
  return c;
    11fa:	29 81       	ldd	r18, Y+1	; 0x01
    11fc:	30 e0       	ldi	r19, 0x00	; 0
    11fe:	02 c0       	rjmp	.+4      	; 0x1204 <VtyGetChar+0x30>
int VtyGetChar(FILE *stream)
{
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    return EOF;
    1200:	2f ef       	ldi	r18, 0xFF	; 255
    1202:	3f ef       	ldi	r19, 0xFF	; 255
  return c;
}
    1204:	c9 01       	movw	r24, r18
    1206:	0f 90       	pop	r0
    1208:	cf 91       	pop	r28
    120a:	df 91       	pop	r29
    120c:	08 95       	ret

0000120e <initQueueStreamUSB>:
#define debug 1

/*-----------------------------------------------------------*/

void initQueueStreamUSB(FILE *stream)
{
    120e:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
    1210:	88 ee       	ldi	r24, 0xE8	; 232
    1212:	9a e0       	ldi	r25, 0x0A	; 10
    1214:	80 87       	std	Z+8, r24	; 0x08
    1216:	91 87       	std	Z+9, r25	; 0x09
    1218:	8a ee       	ldi	r24, 0xEA	; 234
    121a:	98 e0       	ldi	r25, 0x08	; 8
    121c:	82 87       	std	Z+10, r24	; 0x0a
    121e:	93 87       	std	Z+11, r25	; 0x0b
    1220:	83 e0       	ldi	r24, 0x03	; 3
    1222:	83 83       	std	Z+3, r24	; 0x03
    1224:	14 86       	std	Z+12, r1	; 0x0c
    1226:	15 86       	std	Z+13, r1	; 0x0d
  fdev_set_udata(stream, NULL);
  return;
}
    1228:	08 95       	ret

0000122a <xSerialPortInitMinimal>:
  return 0;
}

void xSerialPortInitMinimal(void)
{
  portENTER_CRITICAL();
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	f8 94       	cli
    122e:	0f 92       	push	r0
  {
    xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1230:	80 e4       	ldi	r24, 0x40	; 64
    1232:	61 e0       	ldi	r22, 0x01	; 1
    1234:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    1238:	80 93 0f 32 	sts	0x320F, r24
    123c:	90 93 10 32 	sts	0x3210, r25
    xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1240:	80 e2       	ldi	r24, 0x20	; 32
    1242:	61 e0       	ldi	r22, 0x01	; 1
    1244:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    1248:	80 93 db 31 	sts	0x31DB, r24
    124c:	90 93 dc 31 	sts	0x31DC, r25
    xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1250:	80 e1       	ldi	r24, 0x10	; 16
    1252:	61 e0       	ldi	r22, 0x01	; 1
    1254:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    1258:	80 93 fe 31 	sts	0x31FE, r24
    125c:	90 93 ff 31 	sts	0x31FF, r25
    xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1260:	84 e0       	ldi	r24, 0x04	; 4
    1262:	61 e0       	ldi	r22, 0x01	; 1
    1264:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    1268:	80 93 27 32 	sts	0x3227, r24
    126c:	90 93 28 32 	sts	0x3228, r25
    
    vSemaphoreCreateBinary(xSemaphoreRs485); 
    1270:	81 e0       	ldi	r24, 0x01	; 1
    1272:	60 e0       	ldi	r22, 0x00	; 0
    1274:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    1278:	80 93 11 32 	sts	0x3211, r24
    127c:	90 93 12 32 	sts	0x3212, r25
    1280:	00 97       	sbiw	r24, 0x00	; 0
    1282:	39 f0       	breq	.+14     	; 0x1292 <xSerialPortInitMinimal+0x68>
    1284:	60 e0       	ldi	r22, 0x00	; 0
    1286:	70 e0       	ldi	r23, 0x00	; 0
    1288:	40 e0       	ldi	r20, 0x00	; 0
    128a:	50 e0       	ldi	r21, 0x00	; 0
    128c:	20 e0       	ldi	r18, 0x00	; 0
    128e:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
    1292:	0f 90       	pop	r0
    1294:	0f be       	out	0x3f, r0	; 63
  UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );      Set the data bits to 8. */
  //UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
  //UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );      Set the data bits to 8. */
  
  return;
}
    1296:	08 95       	ret

00001298 <__vector_119>:

/*-----------------------------------------------------------*/
ISR(USARTF0_RXC_vect)
{
    1298:	1f 92       	push	r1
    129a:	0f 92       	push	r0
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	0f 92       	push	r0
    12a0:	08 b6       	in	r0, 0x38	; 56
    12a2:	0f 92       	push	r0
    12a4:	09 b6       	in	r0, 0x39	; 57
    12a6:	0f 92       	push	r0
    12a8:	0b b6       	in	r0, 0x3b	; 59
    12aa:	0f 92       	push	r0
    12ac:	11 24       	eor	r1, r1
    12ae:	18 be       	out	0x38, r1	; 56
    12b0:	19 be       	out	0x39, r1	; 57
    12b2:	1b be       	out	0x3b, r1	; 59
    12b4:	2f 93       	push	r18
    12b6:	3f 93       	push	r19
    12b8:	4f 93       	push	r20
    12ba:	5f 93       	push	r21
    12bc:	6f 93       	push	r22
    12be:	7f 93       	push	r23
    12c0:	8f 93       	push	r24
    12c2:	9f 93       	push	r25
    12c4:	af 93       	push	r26
    12c6:	bf 93       	push	r27
    12c8:	ef 93       	push	r30
    12ca:	ff 93       	push	r31
    12cc:	df 93       	push	r29
    12ce:	cf 93       	push	r28
    12d0:	0f 92       	push	r0
    12d2:	cd b7       	in	r28, 0x3d	; 61
    12d4:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  signed portCHAR cChar;

  cChar = USARTF0.DATA;//UDR0;
    12d6:	80 91 a0 0b 	lds	r24, 0x0BA0
    12da:	89 83       	std	Y+1, r24	; 0x01

  xHigherPriorityTaskWoken = pdFALSE;
    12dc:	10 92 02 20 	sts	0x2002, r1

//  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
    12e0:	80 91 fe 31 	lds	r24, 0x31FE
    12e4:	90 91 ff 31 	lds	r25, 0x31FF
    12e8:	be 01       	movw	r22, r28
    12ea:	6f 5f       	subi	r22, 0xFF	; 255
    12ec:	7f 4f       	sbci	r23, 0xFF	; 255
    12ee:	42 e0       	ldi	r20, 0x02	; 2
    12f0:	50 e2       	ldi	r21, 0x20	; 32
    12f2:	20 e0       	ldi	r18, 0x00	; 0
    12f4:	0e 94 b8 4e 	call	0x9d70	; 0x9d70 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    12f8:	80 91 02 20 	lds	r24, 0x2002
    12fc:	88 23       	and	r24, r24
    12fe:	11 f0       	breq	.+4      	; 0x1304 <__vector_119+0x6c>
  {
    taskYIELD();
    1300:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
  }
}
    1304:	0f 90       	pop	r0
    1306:	cf 91       	pop	r28
    1308:	df 91       	pop	r29
    130a:	ff 91       	pop	r31
    130c:	ef 91       	pop	r30
    130e:	bf 91       	pop	r27
    1310:	af 91       	pop	r26
    1312:	9f 91       	pop	r25
    1314:	8f 91       	pop	r24
    1316:	7f 91       	pop	r23
    1318:	6f 91       	pop	r22
    131a:	5f 91       	pop	r21
    131c:	4f 91       	pop	r20
    131e:	3f 91       	pop	r19
    1320:	2f 91       	pop	r18
    1322:	0f 90       	pop	r0
    1324:	0b be       	out	0x3b, r0	; 59
    1326:	0f 90       	pop	r0
    1328:	09 be       	out	0x39, r0	; 57
    132a:	0f 90       	pop	r0
    132c:	08 be       	out	0x38, r0	; 56
    132e:	0f 90       	pop	r0
    1330:	0f be       	out	0x3f, r0	; 63
    1332:	0f 90       	pop	r0
    1334:	1f 90       	pop	r1
    1336:	18 95       	reti

00001338 <uartRs485SendByte>:
    1338:	df 93       	push	r29
    133a:	cf 93       	push	r28
    133c:	0f 92       	push	r0
    133e:	cd b7       	in	r28, 0x3d	; 61
    1340:	de b7       	in	r29, 0x3e	; 62
    1342:	89 83       	std	Y+1, r24	; 0x01
    1344:	80 91 27 32 	lds	r24, 0x3227
    1348:	90 91 28 32 	lds	r25, 0x3228
    134c:	be 01       	movw	r22, r28
    134e:	6f 5f       	subi	r22, 0xFF	; 255
    1350:	7f 4f       	sbci	r23, 0xFF	; 255
    1352:	4f ef       	ldi	r20, 0xFF	; 255
    1354:	5f ef       	ldi	r21, 0xFF	; 255
    1356:	20 e0       	ldi	r18, 0x00	; 0
    1358:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>
    135c:	e0 ea       	ldi	r30, 0xA0	; 160
    135e:	fb e0       	ldi	r31, 0x0B	; 11
    1360:	81 81       	ldd	r24, Z+1	; 0x01
    1362:	80 62       	ori	r24, 0x20	; 32
    1364:	81 83       	std	Z+1, r24	; 0x01
    1366:	0f 90       	pop	r0
    1368:	cf 91       	pop	r28
    136a:	df 91       	pop	r29
    136c:	08 95       	ret

0000136e <rs485Receive>:
    136e:	9c 01       	movw	r18, r24
    1370:	46 2f       	mov	r20, r22
    1372:	80 91 fe 31 	lds	r24, 0x31FE
    1376:	90 91 ff 31 	lds	r25, 0x31FF
    137a:	b9 01       	movw	r22, r18
    137c:	50 e0       	ldi	r21, 0x00	; 0
    137e:	20 e0       	ldi	r18, 0x00	; 0
    1380:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    1384:	08 95       	ret

00001386 <__vector_120>:
{
  return xQueueReceive(xRs485Rec, c, timeout);
}

ISR(USARTF0_DRE_vect) //   USART0_UDRE_vect
{
    1386:	1f 92       	push	r1
    1388:	0f 92       	push	r0
    138a:	0f b6       	in	r0, 0x3f	; 63
    138c:	0f 92       	push	r0
    138e:	08 b6       	in	r0, 0x38	; 56
    1390:	0f 92       	push	r0
    1392:	09 b6       	in	r0, 0x39	; 57
    1394:	0f 92       	push	r0
    1396:	0b b6       	in	r0, 0x3b	; 59
    1398:	0f 92       	push	r0
    139a:	11 24       	eor	r1, r1
    139c:	18 be       	out	0x38, r1	; 56
    139e:	19 be       	out	0x39, r1	; 57
    13a0:	1b be       	out	0x3b, r1	; 59
    13a2:	2f 93       	push	r18
    13a4:	3f 93       	push	r19
    13a6:	4f 93       	push	r20
    13a8:	5f 93       	push	r21
    13aa:	6f 93       	push	r22
    13ac:	7f 93       	push	r23
    13ae:	8f 93       	push	r24
    13b0:	9f 93       	push	r25
    13b2:	af 93       	push	r26
    13b4:	bf 93       	push	r27
    13b6:	ef 93       	push	r30
    13b8:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
    13ba:	80 91 27 32 	lds	r24, 0x3227
    13be:	90 91 28 32 	lds	r25, 0x3228
    13c2:	6e e4       	ldi	r22, 0x4E	; 78
    13c4:	75 e2       	ldi	r23, 0x25	; 37
    13c6:	4f e4       	ldi	r20, 0x4F	; 79
    13c8:	55 e2       	ldi	r21, 0x25	; 37
    13ca:	0e 94 e0 4f 	call	0x9fc0	; 0x9fc0 <xQueueReceiveFromISR>
    13ce:	81 30       	cpi	r24, 0x01	; 1
    13d0:	59 f4       	brne	.+22     	; 0x13e8 <__vector_120+0x62>
  {
    Rs485TxStart();
    13d2:	80 91 a4 06 	lds	r24, 0x06A4
    13d6:	80 62       	ori	r24, 0x20	; 32
    13d8:	e0 ea       	ldi	r30, 0xA0	; 160
    13da:	f6 e0       	ldi	r31, 0x06	; 6
    13dc:	84 83       	std	Z+4, r24	; 0x04
    USARTF0.DATA = data; 
    13de:	80 91 4e 25 	lds	r24, 0x254E
    13e2:	80 93 a0 0b 	sts	0x0BA0, r24
    13e6:	08 c0       	rjmp	.+16     	; 0x13f8 <__vector_120+0x72>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    13e8:	10 92 4f 25 	sts	0x254F, r1
    vInterruptRs485Off();
    13ec:	80 91 a1 0b 	lds	r24, 0x0BA1
    13f0:	8f 7d       	andi	r24, 0xDF	; 223
    13f2:	e0 ea       	ldi	r30, 0xA0	; 160
    13f4:	fb e0       	ldi	r31, 0x0B	; 11
    13f6:	81 83       	std	Z+1, r24	; 0x01
  }
  if( xHigherPriorityTaskWoken )
    13f8:	80 91 4f 25 	lds	r24, 0x254F
    13fc:	88 23       	and	r24, r24
    13fe:	11 f0       	breq	.+4      	; 0x1404 <__vector_120+0x7e>
  {
    taskYIELD();
    1400:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
  }
}
    1404:	ff 91       	pop	r31
    1406:	ef 91       	pop	r30
    1408:	bf 91       	pop	r27
    140a:	af 91       	pop	r26
    140c:	9f 91       	pop	r25
    140e:	8f 91       	pop	r24
    1410:	7f 91       	pop	r23
    1412:	6f 91       	pop	r22
    1414:	5f 91       	pop	r21
    1416:	4f 91       	pop	r20
    1418:	3f 91       	pop	r19
    141a:	2f 91       	pop	r18
    141c:	0f 90       	pop	r0
    141e:	0b be       	out	0x3b, r0	; 59
    1420:	0f 90       	pop	r0
    1422:	09 be       	out	0x39, r0	; 57
    1424:	0f 90       	pop	r0
    1426:	08 be       	out	0x38, r0	; 56
    1428:	0f 90       	pop	r0
    142a:	0f be       	out	0x3f, r0	; 63
    142c:	0f 90       	pop	r0
    142e:	1f 90       	pop	r1
    1430:	18 95       	reti

00001432 <__vector_121>:

ISR(USARTF0_TXC_vect) //  USART0_TX_vect
{
    1432:	1f 92       	push	r1
    1434:	0f 92       	push	r0
    1436:	0f b6       	in	r0, 0x3f	; 63
    1438:	0f 92       	push	r0
    143a:	08 b6       	in	r0, 0x38	; 56
    143c:	0f 92       	push	r0
    143e:	0b b6       	in	r0, 0x3b	; 59
    1440:	0f 92       	push	r0
    1442:	11 24       	eor	r1, r1
    1444:	18 be       	out	0x38, r1	; 56
    1446:	1b be       	out	0x3b, r1	; 59
    1448:	8f 93       	push	r24
    144a:	ef 93       	push	r30
    144c:	ff 93       	push	r31
  if (!vIsInterruptRs485On())
    144e:	80 91 a1 0b 	lds	r24, 0x0BA1
    1452:	85 fd       	sbrc	r24, 5
    1454:	06 c0       	rjmp	.+12     	; 0x1462 <__vector_121+0x30>
    Rs485TxStop();
    1456:	80 91 a4 06 	lds	r24, 0x06A4
    145a:	8f 7d       	andi	r24, 0xDF	; 223
    145c:	e0 ea       	ldi	r30, 0xA0	; 160
    145e:	f6 e0       	ldi	r31, 0x06	; 6
    1460:	84 83       	std	Z+4, r24	; 0x04
}
    1462:	ff 91       	pop	r31
    1464:	ef 91       	pop	r30
    1466:	8f 91       	pop	r24
    1468:	0f 90       	pop	r0
    146a:	0b be       	out	0x3b, r0	; 59
    146c:	0f 90       	pop	r0
    146e:	08 be       	out	0x38, r0	; 56
    1470:	0f 90       	pop	r0
    1472:	0f be       	out	0x3f, r0	; 63
    1474:	0f 90       	pop	r0
    1476:	1f 90       	pop	r1
    1478:	18 95       	reti

0000147a <flushRs485RecBuffer>:
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	df 93       	push	r29
    1482:	cf 93       	push	r28
    1484:	0f 92       	push	r0
    1486:	cd b7       	in	r28, 0x3d	; 61
    1488:	de b7       	in	r29, 0x3e	; 62
    148a:	ff 24       	eor	r15, r15
    148c:	8e 01       	movw	r16, r28
    148e:	0f 5f       	subi	r16, 0xFF	; 255
    1490:	1f 4f       	sbci	r17, 0xFF	; 255
    1492:	01 c0       	rjmp	.+2      	; 0x1496 <flushRs485RecBuffer+0x1c>
    1494:	f3 94       	inc	r15
    1496:	80 91 fe 31 	lds	r24, 0x31FE
    149a:	90 91 ff 31 	lds	r25, 0x31FF
    149e:	b8 01       	movw	r22, r16
    14a0:	4a e0       	ldi	r20, 0x0A	; 10
    14a2:	50 e0       	ldi	r21, 0x00	; 0
    14a4:	20 e0       	ldi	r18, 0x00	; 0
    14a6:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    14aa:	81 30       	cpi	r24, 0x01	; 1
    14ac:	99 f3       	breq	.-26     	; 0x1494 <flushRs485RecBuffer+0x1a>
    14ae:	8f 2d       	mov	r24, r15
    14b0:	0f 90       	pop	r0
    14b2:	cf 91       	pop	r28
    14b4:	df 91       	pop	r29
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	ff 90       	pop	r15
    14bc:	08 95       	ret

000014be <takeRs485>:
    14be:	80 91 11 32 	lds	r24, 0x3211
    14c2:	90 91 12 32 	lds	r25, 0x3212
    14c6:	60 e0       	ldi	r22, 0x00	; 0
    14c8:	70 e0       	ldi	r23, 0x00	; 0
    14ca:	4f ef       	ldi	r20, 0xFF	; 255
    14cc:	5f ef       	ldi	r21, 0xFF	; 255
    14ce:	20 e0       	ldi	r18, 0x00	; 0
    14d0:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    14d4:	08 95       	ret

000014d6 <releaseRs485>:
    14d6:	80 91 11 32 	lds	r24, 0x3211
    14da:	90 91 12 32 	lds	r25, 0x3212
    14de:	60 e0       	ldi	r22, 0x00	; 0
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	40 e0       	ldi	r20, 0x00	; 0
    14e4:	50 e0       	ldi	r21, 0x00	; 0
    14e6:	20 e0       	ldi	r18, 0x00	; 0
    14e8:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>
    14ec:	08 95       	ret

000014ee <InterruptVtyOn>:
}

void InterruptVtyOn(void)
{                                  
  unsigned portCHAR ucByte;                                       
  ucByte = USARTD0.STATUS;//UCSR1B;                 
    14ee:	e0 ea       	ldi	r30, 0xA0	; 160
    14f0:	f9 e0       	ldi	r31, 0x09	; 9
    14f2:	81 81       	ldd	r24, Z+1	; 0x01
  ucByte |= serDATA_INT_ENABLE;    
    14f4:	80 62       	ori	r24, 0x20	; 32
 // UCSR1B = ucByte;       
  USARTD0.STATUS=ucByte;
    14f6:	81 83       	std	Z+1, r24	; 0x01
}
    14f8:	08 95       	ret

000014fa <__vector_88>:

/*-----------------------------------------------------------*/
ISR(USARTD0_RXC_vect)//  USART1_RX_vect
{
    14fa:	1f 92       	push	r1
    14fc:	0f 92       	push	r0
    14fe:	0f b6       	in	r0, 0x3f	; 63
    1500:	0f 92       	push	r0
    1502:	08 b6       	in	r0, 0x38	; 56
    1504:	0f 92       	push	r0
    1506:	09 b6       	in	r0, 0x39	; 57
    1508:	0f 92       	push	r0
    150a:	0b b6       	in	r0, 0x3b	; 59
    150c:	0f 92       	push	r0
    150e:	11 24       	eor	r1, r1
    1510:	18 be       	out	0x38, r1	; 56
    1512:	19 be       	out	0x39, r1	; 57
    1514:	1b be       	out	0x3b, r1	; 59
    1516:	2f 93       	push	r18
    1518:	3f 93       	push	r19
    151a:	4f 93       	push	r20
    151c:	5f 93       	push	r21
    151e:	6f 93       	push	r22
    1520:	7f 93       	push	r23
    1522:	8f 93       	push	r24
    1524:	9f 93       	push	r25
    1526:	af 93       	push	r26
    1528:	bf 93       	push	r27
    152a:	ef 93       	push	r30
    152c:	ff 93       	push	r31
    152e:	df 93       	push	r29
    1530:	cf 93       	push	r28
    1532:	0f 92       	push	r0
    1534:	cd b7       	in	r28, 0x3d	; 61
    1536:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  signed portCHAR cChar;

  cChar = USARTD0.DATA;//UDR1;
    1538:	80 91 a0 09 	lds	r24, 0x09A0
    153c:	89 83       	std	Y+1, r24	; 0x01
//  xQueueSendFromISR(xVtyRec, &cChar, NULL);

  xHigherPriorityTaskWoken = pdFALSE;
    153e:	10 92 4d 25 	sts	0x254D, r1
  xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
    1542:	80 91 0f 32 	lds	r24, 0x320F
    1546:	90 91 10 32 	lds	r25, 0x3210
    154a:	be 01       	movw	r22, r28
    154c:	6f 5f       	subi	r22, 0xFF	; 255
    154e:	7f 4f       	sbci	r23, 0xFF	; 255
    1550:	4d e4       	ldi	r20, 0x4D	; 77
    1552:	55 e2       	ldi	r21, 0x25	; 37
    1554:	20 e0       	ldi	r18, 0x00	; 0
    1556:	0e 94 b8 4e 	call	0x9d70	; 0x9d70 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    155a:	80 91 4d 25 	lds	r24, 0x254D
    155e:	88 23       	and	r24, r24
    1560:	11 f0       	breq	.+4      	; 0x1566 <__vector_88+0x6c>
  {
    taskYIELD();
    1562:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
  }
}
    1566:	0f 90       	pop	r0
    1568:	cf 91       	pop	r28
    156a:	df 91       	pop	r29
    156c:	ff 91       	pop	r31
    156e:	ef 91       	pop	r30
    1570:	bf 91       	pop	r27
    1572:	af 91       	pop	r26
    1574:	9f 91       	pop	r25
    1576:	8f 91       	pop	r24
    1578:	7f 91       	pop	r23
    157a:	6f 91       	pop	r22
    157c:	5f 91       	pop	r21
    157e:	4f 91       	pop	r20
    1580:	3f 91       	pop	r19
    1582:	2f 91       	pop	r18
    1584:	0f 90       	pop	r0
    1586:	0b be       	out	0x3b, r0	; 59
    1588:	0f 90       	pop	r0
    158a:	09 be       	out	0x39, r0	; 57
    158c:	0f 90       	pop	r0
    158e:	08 be       	out	0x38, r0	; 56
    1590:	0f 90       	pop	r0
    1592:	0f be       	out	0x3f, r0	; 63
    1594:	0f 90       	pop	r0
    1596:	1f 90       	pop	r1
    1598:	18 95       	reti

0000159a <uartVtySendByte>:

void uartVtySendByte(uint8_t data)
{
    159a:	df 93       	push	r29
    159c:	cf 93       	push	r28
    159e:	0f 92       	push	r0
    15a0:	cd b7       	in	r28, 0x3d	; 61
    15a2:	de b7       	in	r29, 0x3e	; 62
    15a4:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
    15a6:	80 91 db 31 	lds	r24, 0x31DB
    15aa:	90 91 dc 31 	lds	r25, 0x31DC
    15ae:	be 01       	movw	r22, r28
    15b0:	6f 5f       	subi	r22, 0xFF	; 255
    15b2:	7f 4f       	sbci	r23, 0xFF	; 255
    15b4:	4f ef       	ldi	r20, 0xFF	; 255
    15b6:	5f ef       	ldi	r21, 0xFF	; 255
    15b8:	20 e0       	ldi	r18, 0x00	; 0
    15ba:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>
  vInterruptVtyOn();
    15be:	e0 ea       	ldi	r30, 0xA0	; 160
    15c0:	f9 e0       	ldi	r31, 0x09	; 9
    15c2:	81 81       	ldd	r24, Z+1	; 0x01
    15c4:	80 62       	ori	r24, 0x20	; 32
    15c6:	81 83       	std	Z+1, r24	; 0x01
}
    15c8:	0f 90       	pop	r0
    15ca:	cf 91       	pop	r28
    15cc:	df 91       	pop	r29
    15ce:	08 95       	ret

000015d0 <VtyPutChar>:
}

int VtyPutChar(char c, FILE *stream)
{
  stream = NULL;
  uartVtySendByte(c);
    15d0:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
  return 0;
}
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	08 95       	ret

000015da <__vector_89>:
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
  vInterruptVtyOn();
}

ISR(USARTD0_DRE_vect) // USART1_UDRE_vect
{
    15da:	1f 92       	push	r1
    15dc:	0f 92       	push	r0
    15de:	0f b6       	in	r0, 0x3f	; 63
    15e0:	0f 92       	push	r0
    15e2:	08 b6       	in	r0, 0x38	; 56
    15e4:	0f 92       	push	r0
    15e6:	09 b6       	in	r0, 0x39	; 57
    15e8:	0f 92       	push	r0
    15ea:	0b b6       	in	r0, 0x3b	; 59
    15ec:	0f 92       	push	r0
    15ee:	11 24       	eor	r1, r1
    15f0:	18 be       	out	0x38, r1	; 56
    15f2:	19 be       	out	0x39, r1	; 57
    15f4:	1b be       	out	0x3b, r1	; 59
    15f6:	2f 93       	push	r18
    15f8:	3f 93       	push	r19
    15fa:	4f 93       	push	r20
    15fc:	5f 93       	push	r21
    15fe:	6f 93       	push	r22
    1600:	7f 93       	push	r23
    1602:	8f 93       	push	r24
    1604:	9f 93       	push	r25
    1606:	af 93       	push	r26
    1608:	bf 93       	push	r27
    160a:	ef 93       	push	r30
    160c:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
    160e:	80 91 db 31 	lds	r24, 0x31DB
    1612:	90 91 dc 31 	lds	r25, 0x31DC
    1616:	6b e4       	ldi	r22, 0x4B	; 75
    1618:	75 e2       	ldi	r23, 0x25	; 37
    161a:	4c e4       	ldi	r20, 0x4C	; 76
    161c:	55 e2       	ldi	r21, 0x25	; 37
    161e:	0e 94 e0 4f 	call	0x9fc0	; 0x9fc0 <xQueueReceiveFromISR>
    1622:	81 30       	cpi	r24, 0x01	; 1
    1624:	29 f4       	brne	.+10     	; 0x1630 <__vector_89+0x56>
  {
    USARTD0.DATA = data; 
    1626:	80 91 4b 25 	lds	r24, 0x254B
    162a:	80 93 a0 09 	sts	0x09A0, r24
    162e:	08 c0       	rjmp	.+16     	; 0x1640 <__vector_89+0x66>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    1630:	10 92 4c 25 	sts	0x254C, r1
    vInterruptVtyOff();
    1634:	80 91 a1 09 	lds	r24, 0x09A1
    1638:	8f 7d       	andi	r24, 0xDF	; 223
    163a:	e0 ea       	ldi	r30, 0xA0	; 160
    163c:	f9 e0       	ldi	r31, 0x09	; 9
    163e:	81 83       	std	Z+1, r24	; 0x01
  }
  if( xHigherPriorityTaskWoken )
    1640:	80 91 4c 25 	lds	r24, 0x254C
    1644:	88 23       	and	r24, r24
    1646:	11 f0       	breq	.+4      	; 0x164c <__vector_89+0x72>
  {
    taskYIELD();
    1648:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
  }
}
    164c:	ff 91       	pop	r31
    164e:	ef 91       	pop	r30
    1650:	bf 91       	pop	r27
    1652:	af 91       	pop	r26
    1654:	9f 91       	pop	r25
    1656:	8f 91       	pop	r24
    1658:	7f 91       	pop	r23
    165a:	6f 91       	pop	r22
    165c:	5f 91       	pop	r21
    165e:	4f 91       	pop	r20
    1660:	3f 91       	pop	r19
    1662:	2f 91       	pop	r18
    1664:	0f 90       	pop	r0
    1666:	0b be       	out	0x3b, r0	; 59
    1668:	0f 90       	pop	r0
    166a:	09 be       	out	0x39, r0	; 57
    166c:	0f 90       	pop	r0
    166e:	08 be       	out	0x38, r0	; 56
    1670:	0f 90       	pop	r0
    1672:	0f be       	out	0x3f, r0	; 63
    1674:	0f 90       	pop	r0
    1676:	1f 90       	pop	r1
    1678:	18 95       	reti

0000167a <hardwareInit>:
xQueueHandle      xSpiRxEnc;
// napisać funkcje do konfiguracji zew pam s-ram
void hardwareInit(void)
{
  //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	f8 94       	cli
    167e:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	61 e0       	ldi	r22, 0x01	; 1
    1684:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    1688:	80 93 c6 32 	sts	0x32C6, r24
    168c:	90 93 c7 32 	sts	0x32C7, r25
  portEXIT_CRITICAL();
    1690:	0f 90       	pop	r0
    1692:	0f be       	out	0x3f, r0	; 63

 //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	61 e0       	ldi	r22, 0x01	; 1
    169e:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    16a2:	80 93 c6 32 	sts	0x32C6, r24
    16a6:	90 93 c7 32 	sts	0x32C7, r25
  portEXIT_CRITICAL();
    16aa:	0f 90       	pop	r0
    16ac:	0f be       	out	0x3f, r0	; 63
5- JTAG TDI
4- JTAG TMS
5:2 - LCD D4:D7
0 - ENC28J60 CS
*/
PORTB.DIR=0x01;
    16ae:	81 e0       	ldi	r24, 0x01	; 1
    16b0:	80 93 20 06 	sts	0x0620, r24
4- SD_card CS
3- ST2378 OE
1- I2C SCL
0- I2C SDA
*/
PORTC.DIR=0xA0;
    16b4:	80 ea       	ldi	r24, 0xA0	; 160
    16b6:	80 93 40 06 	sts	0x0640, r24
3- FT232 TXT-WY
2- FT232 RXT-WE
1- ENC28J60 RST
0- ENC28J60 INT
*/
PORTD.DIR=0xBA;
    16ba:	8a eb       	ldi	r24, 0xBA	; 186
    16bc:	80 93 60 06 	sts	0x0660, r24
/* PORTE
7:0- ZL SPI A7:A0
*/
PORTE.DIR=0xFF;
    16c0:	8f ef       	ldi	r24, 0xFF	; 255
    16c2:	80 93 80 06 	sts	0x0680, r24
5- RS485 DE/RE
4- INT
3- RS485 TXD
2- RS485 RXD
*/
PORTF.DIR=0x28;
    16c6:	98 e2       	ldi	r25, 0x28	; 40
    16c8:	90 93 a0 06 	sts	0x06A0, r25
6:4- EBI A18:A16
2-   EBI ALE
1-   EBI RE
0-   EBI WE
*/
PORTH.DIR=0xFF;
    16cc:	80 93 e0 06 	sts	0x06E0, r24
/* PORTJ
7:0- EBI D7:D0/A0:A7
*/
PORTJ.DIR=0xFF;
    16d0:	80 93 00 07 	sts	0x0700, r24
/* PORTK
7:0- EBI A8:A15
*/
PORTK.DIR=0xFF;
    16d4:	80 93 20 07 	sts	0x0720, r24
}
    16d8:	08 95       	ret

000016da <LockersMemInit>:

void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
    16da:	88 e1       	ldi	r24, 0x18	; 24
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <xmalloc>
    16e2:	80 93 02 32 	sts	0x3202, r24
    16e6:	90 93 03 32 	sts	0x3203, r25
}
    16ea:	08 95       	ret

000016ec <printLockers>:

uint8_t printLockers(FILE *stream)
{
    16ec:	4f 92       	push	r4
    16ee:	5f 92       	push	r5
    16f0:	6f 92       	push	r6
    16f2:	7f 92       	push	r7
    16f4:	9f 92       	push	r9
    16f6:	af 92       	push	r10
    16f8:	bf 92       	push	r11
    16fa:	cf 92       	push	r12
    16fc:	df 92       	push	r13
    16fe:	ef 92       	push	r14
    1700:	ff 92       	push	r15
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	7c 01       	movw	r14, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
    170c:	c0 91 02 32 	lds	r28, 0x3202
    1710:	d0 91 03 32 	lds	r29, 0x3203
    1714:	00 e0       	ldi	r16, 0x00	; 0
    1716:	10 e0       	ldi	r17, 0x00	; 0
}

uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
    1718:	99 24       	eor	r9, r9
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    171a:	34 ef       	ldi	r19, 0xF4	; 244
    171c:	c3 2e       	mov	r12, r19
    171e:	31 e0       	ldi	r19, 0x01	; 1
    1720:	d3 2e       	mov	r13, r19
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1722:	21 e1       	ldi	r18, 0x11	; 17
    1724:	a2 2e       	mov	r10, r18
    1726:	22 e0       	ldi	r18, 0x02	; 2
    1728:	b2 2e       	mov	r11, r18
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
    172a:	98 e0       	ldi	r25, 0x08	; 8
    172c:	69 2e       	mov	r6, r25
    172e:	92 e0       	ldi	r25, 0x02	; 2
    1730:	79 2e       	mov	r7, r25
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
    1732:	8f ef       	ldi	r24, 0xFF	; 255
    1734:	48 2e       	mov	r4, r24
    1736:	81 e0       	ldi	r24, 0x01	; 1
    1738:	58 2e       	mov	r5, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    173a:	88 81       	ld	r24, Y
    173c:	88 23       	and	r24, r24
    173e:	09 f4       	brne	.+2      	; 0x1742 <printLockers+0x56>
    1740:	5a c0       	rjmp	.+180    	; 0x17f6 <printLockers+0x10a>
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1742:	00 d0       	rcall	.+0      	; 0x1744 <printLockers+0x58>
    1744:	00 d0       	rcall	.+0      	; 0x1746 <printLockers+0x5a>
    1746:	ed b7       	in	r30, 0x3d	; 61
    1748:	fe b7       	in	r31, 0x3e	; 62
    174a:	31 96       	adiw	r30, 0x01	; 1
    174c:	ad b7       	in	r26, 0x3d	; 61
    174e:	be b7       	in	r27, 0x3e	; 62
    1750:	11 96       	adiw	r26, 0x01	; 1
    1752:	ed 92       	st	X+, r14
    1754:	fc 92       	st	X, r15
    1756:	12 97       	sbiw	r26, 0x02	; 2
    1758:	c2 82       	std	Z+2, r12	; 0x02
    175a:	d3 82       	std	Z+3, r13	; 0x03
void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
}

uint8_t printLockers(FILE *stream)
    175c:	c8 01       	movw	r24, r16
    175e:	01 96       	adiw	r24, 0x01	; 1
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1760:	84 83       	std	Z+4, r24	; 0x04
    1762:	95 83       	std	Z+5, r25	; 0x05
    1764:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      if (tmpLock->threshold > tmpLock->acVal)
    1768:	ed b7       	in	r30, 0x3d	; 61
    176a:	fe b7       	in	r31, 0x3e	; 62
    176c:	36 96       	adiw	r30, 0x06	; 6
    176e:	ed bf       	out	0x3d, r30	; 61
    1770:	fe bf       	out	0x3e, r31	; 62
    1772:	29 81       	ldd	r18, Y+1	; 0x01
    1774:	3a 81       	ldd	r19, Y+2	; 0x02
    1776:	8b 81       	ldd	r24, Y+3	; 0x03
    1778:	9c 81       	ldd	r25, Y+4	; 0x04
    177a:	82 17       	cp	r24, r18
    177c:	93 07       	cpc	r25, r19
    177e:	68 f4       	brcc	.+26     	; 0x179a <printLockers+0xae>
        fprintf_P(stream, statusLockerOpenStr);
    1780:	00 d0       	rcall	.+0      	; 0x1782 <printLockers+0x96>
    1782:	0f 92       	push	r0
    1784:	ad b7       	in	r26, 0x3d	; 61
    1786:	be b7       	in	r27, 0x3e	; 62
    1788:	11 96       	adiw	r26, 0x01	; 1
    178a:	ed 92       	st	X+, r14
    178c:	fc 92       	st	X, r15
    178e:	12 97       	sbiw	r26, 0x02	; 2
    1790:	13 96       	adiw	r26, 0x03	; 3
    1792:	4d 92       	st	X+, r4
    1794:	5c 92       	st	X, r5
    1796:	14 97       	sbiw	r26, 0x04	; 4
    1798:	08 c0       	rjmp	.+16     	; 0x17aa <printLockers+0xbe>
      else
        fprintf_P(stream, statusLockerCloseStr);
    179a:	00 d0       	rcall	.+0      	; 0x179c <printLockers+0xb0>
    179c:	0f 92       	push	r0
    179e:	ed b7       	in	r30, 0x3d	; 61
    17a0:	fe b7       	in	r31, 0x3e	; 62
    17a2:	e1 82       	std	Z+1, r14	; 0x01
    17a4:	f2 82       	std	Z+2, r15	; 0x02
    17a6:	63 82       	std	Z+3, r6	; 0x03
    17a8:	74 82       	std	Z+4, r7	; 0x04
    17aa:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    17ae:	0f 90       	pop	r0
    17b0:	0f 90       	pop	r0
    17b2:	0f 90       	pop	r0
    17b4:	0f 90       	pop	r0
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    17b6:	8d b7       	in	r24, 0x3d	; 61
    17b8:	9e b7       	in	r25, 0x3e	; 62
    17ba:	08 97       	sbiw	r24, 0x08	; 8
    17bc:	8d bf       	out	0x3d, r24	; 61
    17be:	9e bf       	out	0x3e, r25	; 62
    17c0:	ed b7       	in	r30, 0x3d	; 61
    17c2:	fe b7       	in	r31, 0x3e	; 62
    17c4:	31 96       	adiw	r30, 0x01	; 1
    17c6:	ad b7       	in	r26, 0x3d	; 61
    17c8:	be b7       	in	r27, 0x3e	; 62
    17ca:	11 96       	adiw	r26, 0x01	; 1
    17cc:	ed 92       	st	X+, r14
    17ce:	fc 92       	st	X, r15
    17d0:	12 97       	sbiw	r26, 0x02	; 2
    17d2:	a2 82       	std	Z+2, r10	; 0x02
    17d4:	b3 82       	std	Z+3, r11	; 0x03
    17d6:	89 81       	ldd	r24, Y+1	; 0x01
    17d8:	9a 81       	ldd	r25, Y+2	; 0x02
    17da:	84 83       	std	Z+4, r24	; 0x04
    17dc:	95 83       	std	Z+5, r25	; 0x05
    17de:	8b 81       	ldd	r24, Y+3	; 0x03
    17e0:	9c 81       	ldd	r25, Y+4	; 0x04
    17e2:	86 83       	std	Z+6, r24	; 0x06
    17e4:	97 83       	std	Z+7, r25	; 0x07
    17e6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      result++;
    17ea:	93 94       	inc	r9
    17ec:	ed b7       	in	r30, 0x3d	; 61
    17ee:	fe b7       	in	r31, 0x3e	; 62
    17f0:	38 96       	adiw	r30, 0x08	; 8
    17f2:	ed bf       	out	0x3d, r30	; 61
    17f4:	fe bf       	out	0x3e, r31	; 62
    17f6:	0f 5f       	subi	r16, 0xFF	; 255
    17f8:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
    17fa:	04 30       	cpi	r16, 0x04	; 4
    17fc:	11 05       	cpc	r17, r1
    17fe:	11 f0       	breq	.+4      	; 0x1804 <printLockers+0x118>
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
      result++;
    }
    tmpLock++;
    1800:	26 96       	adiw	r28, 0x06	; 6
    1802:	9b cf       	rjmp	.-202    	; 0x173a <printLockers+0x4e>
  }
  return result;
}
    1804:	89 2d       	mov	r24, r9
    1806:	df 91       	pop	r29
    1808:	cf 91       	pop	r28
    180a:	1f 91       	pop	r17
    180c:	0f 91       	pop	r16
    180e:	ff 90       	pop	r15
    1810:	ef 90       	pop	r14
    1812:	df 90       	pop	r13
    1814:	cf 90       	pop	r12
    1816:	bf 90       	pop	r11
    1818:	af 90       	pop	r10
    181a:	9f 90       	pop	r9
    181c:	7f 90       	pop	r7
    181e:	6f 90       	pop	r6
    1820:	5f 90       	pop	r5
    1822:	4f 90       	pop	r4
    1824:	08 95       	ret

00001826 <checkLockerSensors>:

void checkLockerSensors(void)
{
    1826:	cf 93       	push	r28
    1828:	df 93       	push	r29
  if (lockSensors[0].enabled)
    182a:	e0 91 02 32 	lds	r30, 0x3202
    182e:	f0 91 03 32 	lds	r31, 0x3203
    1832:	80 81       	ld	r24, Z
    1834:	88 23       	and	r24, r24
    1836:	39 f1       	breq	.+78     	; 0x1886 <checkLockerSensors+0x60>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1838:	80 e4       	ldi	r24, 0x40	; 64
    183a:	60 e0       	ldi	r22, 0x00	; 0
    183c:	0e 94 19 29 	call	0x5232	; 0x5232 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1840:	8e e1       	ldi	r24, 0x1E	; 30
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
    1848:	c0 91 02 32 	lds	r28, 0x3202
    184c:	d0 91 03 32 	lds	r29, 0x3203
    1850:	84 e0       	ldi	r24, 0x04	; 4
    1852:	0e 94 42 2a 	call	0x5484	; 0x5484 <MCP3008_getSampleSingle>
    1856:	8b 83       	std	Y+3, r24	; 0x03
    1858:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    185a:	80 e4       	ldi	r24, 0x40	; 64
    185c:	60 e0       	ldi	r22, 0x00	; 0
    185e:	0e 94 3e 29 	call	0x527c	; 0x527c <MPC23s17ClearBitsOnPortA>
    lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
    1862:	e0 91 02 32 	lds	r30, 0x3202
    1866:	f0 91 03 32 	lds	r31, 0x3203
    186a:	41 e0       	ldi	r20, 0x01	; 1
    186c:	23 81       	ldd	r18, Z+3	; 0x03
    186e:	34 81       	ldd	r19, Z+4	; 0x04
    1870:	81 81       	ldd	r24, Z+1	; 0x01
    1872:	92 81       	ldd	r25, Z+2	; 0x02
    1874:	82 17       	cp	r24, r18
    1876:	93 07       	cpc	r25, r19
    1878:	08 f0       	brcs	.+2      	; 0x187c <checkLockerSensors+0x56>
    187a:	40 e0       	ldi	r20, 0x00	; 0
    187c:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    187e:	8a e0       	ldi	r24, 0x0A	; 10
    1880:	90 e0       	ldi	r25, 0x00	; 0
    1882:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
  }
  
  if (lockSensors[1].enabled)
    1886:	e0 91 02 32 	lds	r30, 0x3202
    188a:	f0 91 03 32 	lds	r31, 0x3203
    188e:	86 81       	ldd	r24, Z+6	; 0x06
    1890:	88 23       	and	r24, r24
    1892:	49 f1       	breq	.+82     	; 0x18e6 <checkLockerSensors+0xc0>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1894:	80 e2       	ldi	r24, 0x20	; 32
    1896:	60 e0       	ldi	r22, 0x00	; 0
    1898:	0e 94 19 29 	call	0x5232	; 0x5232 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    189c:	8e e1       	ldi	r24, 0x1E	; 30
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
    18a4:	c0 91 02 32 	lds	r28, 0x3202
    18a8:	d0 91 03 32 	lds	r29, 0x3203
    18ac:	26 96       	adiw	r28, 0x06	; 6
    18ae:	85 e0       	ldi	r24, 0x05	; 5
    18b0:	0e 94 42 2a 	call	0x5484	; 0x5484 <MCP3008_getSampleSingle>
    18b4:	8b 83       	std	Y+3, r24	; 0x03
    18b6:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    18b8:	80 e2       	ldi	r24, 0x20	; 32
    18ba:	60 e0       	ldi	r22, 0x00	; 0
    18bc:	0e 94 3e 29 	call	0x527c	; 0x527c <MPC23s17ClearBitsOnPortA>
    lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
    18c0:	e0 91 02 32 	lds	r30, 0x3202
    18c4:	f0 91 03 32 	lds	r31, 0x3203
    18c8:	36 96       	adiw	r30, 0x06	; 6
    18ca:	41 e0       	ldi	r20, 0x01	; 1
    18cc:	23 81       	ldd	r18, Z+3	; 0x03
    18ce:	34 81       	ldd	r19, Z+4	; 0x04
    18d0:	81 81       	ldd	r24, Z+1	; 0x01
    18d2:	92 81       	ldd	r25, Z+2	; 0x02
    18d4:	82 17       	cp	r24, r18
    18d6:	93 07       	cpc	r25, r19
    18d8:	08 f0       	brcs	.+2      	; 0x18dc <checkLockerSensors+0xb6>
    18da:	40 e0       	ldi	r20, 0x00	; 0
    18dc:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    18de:	8a e0       	ldi	r24, 0x0A	; 10
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
  }
  
  if (lockSensors[2].enabled)
    18e6:	e0 91 02 32 	lds	r30, 0x3202
    18ea:	f0 91 03 32 	lds	r31, 0x3203
    18ee:	84 85       	ldd	r24, Z+12	; 0x0c
    18f0:	88 23       	and	r24, r24
    18f2:	49 f1       	breq	.+82     	; 0x1946 <checkLockerSensors+0x120>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    18f4:	80 e1       	ldi	r24, 0x10	; 16
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	0e 94 19 29 	call	0x5232	; 0x5232 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    18fc:	8e e1       	ldi	r24, 0x1E	; 30
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
    1904:	c0 91 02 32 	lds	r28, 0x3202
    1908:	d0 91 03 32 	lds	r29, 0x3203
    190c:	2c 96       	adiw	r28, 0x0c	; 12
    190e:	86 e0       	ldi	r24, 0x06	; 6
    1910:	0e 94 42 2a 	call	0x5484	; 0x5484 <MCP3008_getSampleSingle>
    1914:	8b 83       	std	Y+3, r24	; 0x03
    1916:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1918:	80 e1       	ldi	r24, 0x10	; 16
    191a:	60 e0       	ldi	r22, 0x00	; 0
    191c:	0e 94 3e 29 	call	0x527c	; 0x527c <MPC23s17ClearBitsOnPortA>
    lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
    1920:	e0 91 02 32 	lds	r30, 0x3202
    1924:	f0 91 03 32 	lds	r31, 0x3203
    1928:	3c 96       	adiw	r30, 0x0c	; 12
    192a:	41 e0       	ldi	r20, 0x01	; 1
    192c:	23 81       	ldd	r18, Z+3	; 0x03
    192e:	34 81       	ldd	r19, Z+4	; 0x04
    1930:	81 81       	ldd	r24, Z+1	; 0x01
    1932:	92 81       	ldd	r25, Z+2	; 0x02
    1934:	82 17       	cp	r24, r18
    1936:	93 07       	cpc	r25, r19
    1938:	08 f0       	brcs	.+2      	; 0x193c <checkLockerSensors+0x116>
    193a:	40 e0       	ldi	r20, 0x00	; 0
    193c:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    193e:	8a e0       	ldi	r24, 0x0A	; 10
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
  }
  
  if (lockSensors[3].enabled)
    1946:	e0 91 02 32 	lds	r30, 0x3202
    194a:	f0 91 03 32 	lds	r31, 0x3203
    194e:	82 89       	ldd	r24, Z+18	; 0x12
    1950:	88 23       	and	r24, r24
    1952:	49 f1       	breq	.+82     	; 0x19a6 <checkLockerSensors+0x180>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1954:	88 e0       	ldi	r24, 0x08	; 8
    1956:	60 e0       	ldi	r22, 0x00	; 0
    1958:	0e 94 19 29 	call	0x5232	; 0x5232 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    195c:	8e e1       	ldi	r24, 0x1E	; 30
    195e:	90 e0       	ldi	r25, 0x00	; 0
    1960:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    1964:	c0 91 02 32 	lds	r28, 0x3202
    1968:	d0 91 03 32 	lds	r29, 0x3203
    196c:	62 96       	adiw	r28, 0x12	; 18
    196e:	87 e0       	ldi	r24, 0x07	; 7
    1970:	0e 94 42 2a 	call	0x5484	; 0x5484 <MCP3008_getSampleSingle>
    1974:	8b 83       	std	Y+3, r24	; 0x03
    1976:	9c 83       	std	Y+4, r25	; 0x04
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1978:	88 e0       	ldi	r24, 0x08	; 8
    197a:	60 e0       	ldi	r22, 0x00	; 0
    197c:	0e 94 3e 29 	call	0x527c	; 0x527c <MPC23s17ClearBitsOnPortA>
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    1980:	e0 91 02 32 	lds	r30, 0x3202
    1984:	f0 91 03 32 	lds	r31, 0x3203
    1988:	72 96       	adiw	r30, 0x12	; 18
    198a:	41 e0       	ldi	r20, 0x01	; 1
    198c:	23 81       	ldd	r18, Z+3	; 0x03
    198e:	34 81       	ldd	r19, Z+4	; 0x04
    1990:	81 81       	ldd	r24, Z+1	; 0x01
    1992:	92 81       	ldd	r25, Z+2	; 0x02
    1994:	82 17       	cp	r24, r18
    1996:	93 07       	cpc	r25, r19
    1998:	08 f0       	brcs	.+2      	; 0x199c <checkLockerSensors+0x176>
    199a:	40 e0       	ldi	r20, 0x00	; 0
    199c:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    199e:	8a e0       	ldi	r24, 0x0A	; 10
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
  }
}
    19a6:	df 91       	pop	r29
    19a8:	cf 91       	pop	r28
    19aa:	08 95       	ret

000019ac <spiSend>:
    19ac:	df 93       	push	r29
    19ae:	cf 93       	push	r28
    19b0:	0f 92       	push	r0
    19b2:	cd b7       	in	r28, 0x3d	; 61
    19b4:	de b7       	in	r29, 0x3e	; 62
    19b6:	e0 ec       	ldi	r30, 0xC0	; 192
    19b8:	f9 e0       	ldi	r31, 0x09	; 9
    19ba:	83 83       	std	Z+3, r24	; 0x03
    19bc:	80 91 c6 32 	lds	r24, 0x32C6
    19c0:	90 91 c7 32 	lds	r25, 0x32C7
    19c4:	be 01       	movw	r22, r28
    19c6:	6f 5f       	subi	r22, 0xFF	; 255
    19c8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ca:	4a e0       	ldi	r20, 0x0A	; 10
    19cc:	50 e0       	ldi	r21, 0x00	; 0
    19ce:	20 e0       	ldi	r18, 0x00	; 0
    19d0:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    19d4:	89 81       	ldd	r24, Y+1	; 0x01
    19d6:	0f 90       	pop	r0
    19d8:	cf 91       	pop	r28
    19da:	df 91       	pop	r29
    19dc:	08 95       	ret

000019de <spiSendENC>:
  SPID.DATA = data; 
  xQueueReceive(xSpiRx, &result, 10); 
  return result;
}
uint8_t spiSendENC(uint8_t data)
{
    19de:	df 93       	push	r29
    19e0:	cf 93       	push	r28
    19e2:	0f 92       	push	r0
    19e4:	cd b7       	in	r28, 0x3d	; 61
    19e6:	de b7       	in	r29, 0x3e	; 62
  uint8_t result; 
  SPIC.DATA = data;
    19e8:	e0 ec       	ldi	r30, 0xC0	; 192
    19ea:	f8 e0       	ldi	r31, 0x08	; 8
    19ec:	83 83       	std	Z+3, r24	; 0x03
  //SPID.DATA = data; 
  xQueueReceive(xSpiRxEnc, &result, 10); 
    19ee:	80 91 c4 32 	lds	r24, 0x32C4
    19f2:	90 91 c5 32 	lds	r25, 0x32C5
    19f6:	be 01       	movw	r22, r28
    19f8:	6f 5f       	subi	r22, 0xFF	; 255
    19fa:	7f 4f       	sbci	r23, 0xFF	; 255
    19fc:	4a e0       	ldi	r20, 0x0A	; 10
    19fe:	50 e0       	ldi	r21, 0x00	; 0
    1a00:	20 e0       	ldi	r18, 0x00	; 0
    1a02:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
  return result;
}
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
    1a08:	0f 90       	pop	r0
    1a0a:	cf 91       	pop	r28
    1a0c:	df 91       	pop	r29
    1a0e:	08 95       	ret

00001a10 <spiSendSpinBlock>:
    1a10:	80 91 c2 09 	lds	r24, 0x09C2
    1a14:	87 ff       	sbrs	r24, 7
    1a16:	fc cf       	rjmp	.-8      	; 0x1a10 <spiSendSpinBlock>
    1a18:	80 91 c3 09 	lds	r24, 0x09C3
    1a1c:	80 91 c3 09 	lds	r24, 0x09C3
    1a20:	90 91 c1 09 	lds	r25, 0x09C1
    1a24:	91 60       	ori	r25, 0x01	; 1
    1a26:	e0 ec       	ldi	r30, 0xC0	; 192
    1a28:	f9 e0       	ldi	r31, 0x09	; 9
    1a2a:	91 83       	std	Z+1, r25	; 0x01
    1a2c:	08 95       	ret

00001a2e <spiSendSpinBlockENC>:
  return data;                     
}
uint8_t spiSendSpinBlockENC(uint8_t data)
{
  //SPDR = data;
  SPIC.DATA=data;
    1a2e:	e0 ec       	ldi	r30, 0xC0	; 192
    1a30:	f8 e0       	ldi	r31, 0x08	; 8
    1a32:	83 83       	std	Z+3, r24	; 0x03
  //SPCR &= ~(1<<SPIE);                
  SPIC.INTCTRL=0x00; //Disable SPI interrupt
    1a34:	11 82       	std	Z+1, r1	; 0x01
  while(!(SPIC.STATUS&(0x80))); //(SPSR&(1<<SPIF)));
    1a36:	80 91 c2 08 	lds	r24, 0x08C2
    1a3a:	87 ff       	sbrs	r24, 7
    1a3c:	fc cf       	rjmp	.-8      	; 0x1a36 <spiSendSpinBlockENC+0x8>
  data = SPIC.DATA;//SPSR;                       Clearing interrupt flag
    1a3e:	80 91 c3 08 	lds	r24, 0x08C3
  data = SPIC.DATA; //SPDR;                      Resfing DPI buffer register
    1a42:	80 91 c3 08 	lds	r24, 0x08C3
  //SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
  SPIC.INTCTRL|=0x01; //low level
    1a46:	90 91 c1 08 	lds	r25, 0x08C1
    1a4a:	91 60       	ori	r25, 0x01	; 1
    1a4c:	e0 ec       	ldi	r30, 0xC0	; 192
    1a4e:	f8 e0       	ldi	r31, 0x08	; 8
    1a50:	91 83       	std	Z+1, r25	; 0x01
  return data;                     
}
    1a52:	08 95       	ret

00001a54 <disableAllSpiDevices>:
{ 
#if disableSpiPORTA_OR !=0
  PORTA.OUT |= disableSpiPORTA_OR;
#endif
#if disableSpiPORTB_AND !=0xFF
  PORTA.OUT &= disableSpiPORTB_AND;
    1a54:	e0 e0       	ldi	r30, 0x00	; 0
    1a56:	f6 e0       	ldi	r31, 0x06	; 6
    1a58:	84 81       	ldd	r24, Z+4	; 0x04
    1a5a:	8e 7f       	andi	r24, 0xFE	; 254
    1a5c:	84 83       	std	Z+4, r24	; 0x04
#endif
  
#if disableSpiPORTB_OR != 0
  PORTB.OUT |= disableSpiPORTB_OR;
    1a5e:	e0 e2       	ldi	r30, 0x20	; 32
    1a60:	f6 e0       	ldi	r31, 0x06	; 6
    1a62:	84 81       	ldd	r24, Z+4	; 0x04
    1a64:	81 60       	ori	r24, 0x01	; 1
    1a66:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTB_AND != 0xFF 
  PORTB.OUT &= disableSpiPORTB_AND;
    1a68:	84 81       	ldd	r24, Z+4	; 0x04
    1a6a:	8e 7f       	andi	r24, 0xFE	; 254
    1a6c:	84 83       	std	Z+4, r24	; 0x04
#endif
  
#if disableSpiPORTC_OR !=0
  PORTC.OUT |= disableSpiPORTC_OR;
    1a6e:	e0 e4       	ldi	r30, 0x40	; 64
    1a70:	f6 e0       	ldi	r31, 0x06	; 6
    1a72:	84 81       	ldd	r24, Z+4	; 0x04
    1a74:	80 61       	ori	r24, 0x10	; 16
    1a76:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTC_AND !=0xFF
  PORTC.OUT |= disableSpiPORTC_AND;
    1a78:	84 81       	ldd	r24, Z+4	; 0x04
    1a7a:	8f 6e       	ori	r24, 0xEF	; 239
    1a7c:	84 83       	std	Z+4, r24	; 0x04
#if disableSpiPORTD_AND != 0xFF
  PORTD.OUT &= disableSpiPORTD_AND;
#endif
  
#if disableSpiPORTE_OR != 0
  PORTE.OUT |= disableSpiPORTE_OR;
    1a7e:	e0 e8       	ldi	r30, 0x80	; 128
    1a80:	f6 e0       	ldi	r31, 0x06	; 6
    1a82:	84 81       	ldd	r24, Z+4	; 0x04
    1a84:	80 6c       	ori	r24, 0xC0	; 192
    1a86:	84 83       	std	Z+4, r24	; 0x04
#endif
#if disableSpiPORTE_AND != 0xFF
  PORTE.OUT &= disableSpiPORTE_AND;
    1a88:	84 81       	ldd	r24, Z+4	; 0x04
    1a8a:	8f 7d       	andi	r24, 0xDF	; 223
    1a8c:	84 83       	std	Z+4, r24	; 0x04
#if disableSpiPORTH_AND != 0xFF
#error Port H is memory bus
  PORTH.OUT &= disableSpiPORTG_AND;
#endif

}
    1a8e:	08 95       	ret

00001a90 <spiEnableEnc28j60>:
    1a90:	e0 e2       	ldi	r30, 0x20	; 32
    1a92:	f6 e0       	ldi	r31, 0x06	; 6
    1a94:	84 81       	ldd	r24, Z+4	; 0x04
    1a96:	8e 7f       	andi	r24, 0xFE	; 254
    1a98:	84 83       	std	Z+4, r24	; 0x04
    1a9a:	08 95       	ret

00001a9c <spiDisableEnc28j60>:
    1a9c:	e0 e2       	ldi	r30, 0x20	; 32
    1a9e:	f6 e0       	ldi	r31, 0x06	; 6
    1aa0:	84 81       	ldd	r24, Z+4	; 0x04
    1aa2:	81 60       	ori	r24, 0x01	; 1
    1aa4:	84 83       	std	Z+4, r24	; 0x04
    1aa6:	08 95       	ret

00001aa8 <enableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
    1aa8:	e0 e4       	ldi	r30, 0x40	; 64
    1aaa:	f6 e0       	ldi	r31, 0x06	; 6
    1aac:	84 81       	ldd	r24, Z+4	; 0x04
    1aae:	8f 7e       	andi	r24, 0xEF	; 239
    1ab0:	84 83       	std	Z+4, r24	; 0x04
#endif   
}
    1ab2:	08 95       	ret

00001ab4 <disableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
    1ab4:	e0 e4       	ldi	r30, 0x40	; 64
    1ab6:	f6 e0       	ldi	r31, 0x06	; 6
    1ab8:	84 81       	ldd	r24, Z+4	; 0x04
    1aba:	80 61       	ori	r24, 0x10	; 16
    1abc:	84 83       	std	Z+4, r24	; 0x04
#endif  
}
    1abe:	08 95       	ret

00001ac0 <enableSpiMPC23S17>:
    1ac0:	e0 e8       	ldi	r30, 0x80	; 128
    1ac2:	f6 e0       	ldi	r31, 0x06	; 6
    1ac4:	84 81       	ldd	r24, Z+4	; 0x04
    1ac6:	8f 77       	andi	r24, 0x7F	; 127
    1ac8:	84 83       	std	Z+4, r24	; 0x04
    1aca:	08 95       	ret

00001acc <disableSpiMPC23S17>:
    1acc:	e0 e8       	ldi	r30, 0x80	; 128
    1ace:	f6 e0       	ldi	r31, 0x06	; 6
    1ad0:	84 81       	ldd	r24, Z+4	; 0x04
    1ad2:	80 68       	ori	r24, 0x80	; 128
    1ad4:	84 83       	std	Z+4, r24	; 0x04
    1ad6:	08 95       	ret

00001ad8 <enableSpiMCP3008>:
    1ad8:	e0 ec       	ldi	r30, 0xC0	; 192
    1ada:	f9 e0       	ldi	r31, 0x09	; 9
    1adc:	80 81       	ld	r24, Z
    1ade:	83 60       	ori	r24, 0x03	; 3
    1ae0:	80 83       	st	Z, r24
    1ae2:	e0 e8       	ldi	r30, 0x80	; 128
    1ae4:	f6 e0       	ldi	r31, 0x06	; 6
    1ae6:	84 81       	ldd	r24, Z+4	; 0x04
    1ae8:	8f 7b       	andi	r24, 0xBF	; 191
    1aea:	84 83       	std	Z+4, r24	; 0x04
    1aec:	08 95       	ret

00001aee <disableSpiMCP3008>:
    1aee:	e0 ec       	ldi	r30, 0xC0	; 192
    1af0:	f9 e0       	ldi	r31, 0x09	; 9
    1af2:	80 81       	ld	r24, Z
    1af4:	8c 7f       	andi	r24, 0xFC	; 252
    1af6:	80 83       	st	Z, r24
    1af8:	e0 e8       	ldi	r30, 0x80	; 128
    1afa:	f6 e0       	ldi	r31, 0x06	; 6
    1afc:	84 81       	ldd	r24, Z+4	; 0x04
    1afe:	80 64       	ori	r24, 0x40	; 64
    1b00:	84 83       	std	Z+4, r24	; 0x04
    1b02:	08 95       	ret

00001b04 <enableSpiMCP4150>:
    1b04:	e0 ec       	ldi	r30, 0xC0	; 192
    1b06:	f9 e0       	ldi	r31, 0x09	; 9
    1b08:	80 81       	ld	r24, Z
    1b0a:	83 60       	ori	r24, 0x03	; 3
    1b0c:	80 83       	st	Z, r24
    1b0e:	e0 e8       	ldi	r30, 0x80	; 128
    1b10:	f6 e0       	ldi	r31, 0x06	; 6
    1b12:	84 81       	ldd	r24, Z+4	; 0x04
    1b14:	8f 7b       	andi	r24, 0xBF	; 191
    1b16:	84 83       	std	Z+4, r24	; 0x04
    1b18:	08 95       	ret

00001b1a <disableSpiMCP4150>:
    1b1a:	e0 ec       	ldi	r30, 0xC0	; 192
    1b1c:	f9 e0       	ldi	r31, 0x09	; 9
    1b1e:	80 81       	ld	r24, Z
    1b20:	8c 7f       	andi	r24, 0xFC	; 252
    1b22:	80 83       	st	Z, r24
    1b24:	e0 e8       	ldi	r30, 0x80	; 128
    1b26:	f6 e0       	ldi	r31, 0x06	; 6
    1b28:	84 81       	ldd	r24, Z+4	; 0x04
    1b2a:	80 64       	ori	r24, 0x40	; 64
    1b2c:	84 83       	std	Z+4, r24	; 0x04
    1b2e:	08 95       	ret

00001b30 <spiEnableDS1305>:
    1b30:	e0 ec       	ldi	r30, 0xC0	; 192
    1b32:	f9 e0       	ldi	r31, 0x09	; 9
    1b34:	80 81       	ld	r24, Z
    1b36:	85 60       	ori	r24, 0x05	; 5
    1b38:	80 83       	st	Z, r24
    1b3a:	e0 e8       	ldi	r30, 0x80	; 128
    1b3c:	f6 e0       	ldi	r31, 0x06	; 6
    1b3e:	84 81       	ldd	r24, Z+4	; 0x04
    1b40:	80 62       	ori	r24, 0x20	; 32
    1b42:	84 83       	std	Z+4, r24	; 0x04
    1b44:	08 95       	ret

00001b46 <spiDisableDS1305>:
    1b46:	e0 ec       	ldi	r30, 0xC0	; 192
    1b48:	f9 e0       	ldi	r31, 0x09	; 9
    1b4a:	80 81       	ld	r24, Z
    1b4c:	8a 7f       	andi	r24, 0xFA	; 250
    1b4e:	80 83       	st	Z, r24
    1b50:	e0 e8       	ldi	r30, 0x80	; 128
    1b52:	f6 e0       	ldi	r31, 0x06	; 6
    1b54:	84 81       	ldd	r24, Z+4	; 0x04
    1b56:	8f 7d       	andi	r24, 0xDF	; 223
    1b58:	84 83       	std	Z+4, r24	; 0x04
    1b5a:	08 95       	ret

00001b5c <__vector_87>:
  DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
#endif  
}

ISR(SPID_INT_vect)
{
    1b5c:	1f 92       	push	r1
    1b5e:	0f 92       	push	r0
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	0f 92       	push	r0
    1b64:	08 b6       	in	r0, 0x38	; 56
    1b66:	0f 92       	push	r0
    1b68:	09 b6       	in	r0, 0x39	; 57
    1b6a:	0f 92       	push	r0
    1b6c:	0b b6       	in	r0, 0x3b	; 59
    1b6e:	0f 92       	push	r0
    1b70:	11 24       	eor	r1, r1
    1b72:	18 be       	out	0x38, r1	; 56
    1b74:	19 be       	out	0x39, r1	; 57
    1b76:	1b be       	out	0x3b, r1	; 59
    1b78:	2f 93       	push	r18
    1b7a:	3f 93       	push	r19
    1b7c:	4f 93       	push	r20
    1b7e:	5f 93       	push	r21
    1b80:	6f 93       	push	r22
    1b82:	7f 93       	push	r23
    1b84:	8f 93       	push	r24
    1b86:	9f 93       	push	r25
    1b88:	af 93       	push	r26
    1b8a:	bf 93       	push	r27
    1b8c:	ef 93       	push	r30
    1b8e:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 

  static uint8_t data;
  data = SPID.DATA;//SPDR;
    1b90:	80 91 c3 09 	lds	r24, 0x09C3
    1b94:	80 93 52 25 	sts	0x2552, r24
  
  xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
    1b98:	80 91 c6 32 	lds	r24, 0x32C6
    1b9c:	90 91 c7 32 	lds	r25, 0x32C7
    1ba0:	62 e5       	ldi	r22, 0x52	; 82
    1ba2:	75 e2       	ldi	r23, 0x25	; 37
    1ba4:	43 e5       	ldi	r20, 0x53	; 83
    1ba6:	55 e2       	ldi	r21, 0x25	; 37
    1ba8:	20 e0       	ldi	r18, 0x00	; 0
    1baa:	0e 94 b8 4e 	call	0x9d70	; 0x9d70 <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    1bae:	80 91 53 25 	lds	r24, 0x2553
    1bb2:	88 23       	and	r24, r24
    1bb4:	11 f0       	breq	.+4      	; 0x1bba <__vector_87+0x5e>
  {
    taskYIELD();
    1bb6:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
  }
  
  //clear SPI interrupt SPI |= 1;
}
    1bba:	ff 91       	pop	r31
    1bbc:	ef 91       	pop	r30
    1bbe:	bf 91       	pop	r27
    1bc0:	af 91       	pop	r26
    1bc2:	9f 91       	pop	r25
    1bc4:	8f 91       	pop	r24
    1bc6:	7f 91       	pop	r23
    1bc8:	6f 91       	pop	r22
    1bca:	5f 91       	pop	r21
    1bcc:	4f 91       	pop	r20
    1bce:	3f 91       	pop	r19
    1bd0:	2f 91       	pop	r18
    1bd2:	0f 90       	pop	r0
    1bd4:	0b be       	out	0x3b, r0	; 59
    1bd6:	0f 90       	pop	r0
    1bd8:	09 be       	out	0x39, r0	; 57
    1bda:	0f 90       	pop	r0
    1bdc:	08 be       	out	0x38, r0	; 56
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63
    1be2:	0f 90       	pop	r0
    1be4:	1f 90       	pop	r1
    1be6:	18 95       	reti

00001be8 <__vector_24>:
ISR(SPIC_INT_vect)
{
    1be8:	1f 92       	push	r1
    1bea:	0f 92       	push	r0
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	0f 92       	push	r0
    1bf0:	08 b6       	in	r0, 0x38	; 56
    1bf2:	0f 92       	push	r0
    1bf4:	09 b6       	in	r0, 0x39	; 57
    1bf6:	0f 92       	push	r0
    1bf8:	0b b6       	in	r0, 0x3b	; 59
    1bfa:	0f 92       	push	r0
    1bfc:	11 24       	eor	r1, r1
    1bfe:	18 be       	out	0x38, r1	; 56
    1c00:	19 be       	out	0x39, r1	; 57
    1c02:	1b be       	out	0x3b, r1	; 59
    1c04:	2f 93       	push	r18
    1c06:	3f 93       	push	r19
    1c08:	4f 93       	push	r20
    1c0a:	5f 93       	push	r21
    1c0c:	6f 93       	push	r22
    1c0e:	7f 93       	push	r23
    1c10:	8f 93       	push	r24
    1c12:	9f 93       	push	r25
    1c14:	af 93       	push	r26
    1c16:	bf 93       	push	r27
    1c18:	ef 93       	push	r30
    1c1a:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 

  static uint8_t data;
  data = SPIC.DATA;//SPDR;
    1c1c:	80 91 c3 08 	lds	r24, 0x08C3
    1c20:	80 93 50 25 	sts	0x2550, r24
  
  xQueueSendFromISR(xSpiRxEnc, &data, &xHigherPriorityTaskWoken);
    1c24:	80 91 c4 32 	lds	r24, 0x32C4
    1c28:	90 91 c5 32 	lds	r25, 0x32C5
    1c2c:	60 e5       	ldi	r22, 0x50	; 80
    1c2e:	75 e2       	ldi	r23, 0x25	; 37
    1c30:	41 e5       	ldi	r20, 0x51	; 81
    1c32:	55 e2       	ldi	r21, 0x25	; 37
    1c34:	20 e0       	ldi	r18, 0x00	; 0
    1c36:	0e 94 b8 4e 	call	0x9d70	; 0x9d70 <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    1c3a:	80 91 51 25 	lds	r24, 0x2551
    1c3e:	88 23       	and	r24, r24
    1c40:	11 f0       	breq	.+4      	; 0x1c46 <__vector_24+0x5e>
  {
    taskYIELD();
    1c42:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
  }
  
  //clear SPI interrupt SPI |= 1;
}
    1c46:	ff 91       	pop	r31
    1c48:	ef 91       	pop	r30
    1c4a:	bf 91       	pop	r27
    1c4c:	af 91       	pop	r26
    1c4e:	9f 91       	pop	r25
    1c50:	8f 91       	pop	r24
    1c52:	7f 91       	pop	r23
    1c54:	6f 91       	pop	r22
    1c56:	5f 91       	pop	r21
    1c58:	4f 91       	pop	r20
    1c5a:	3f 91       	pop	r19
    1c5c:	2f 91       	pop	r18
    1c5e:	0f 90       	pop	r0
    1c60:	0b be       	out	0x3b, r0	; 59
    1c62:	0f 90       	pop	r0
    1c64:	09 be       	out	0x39, r0	; 57
    1c66:	0f 90       	pop	r0
    1c68:	08 be       	out	0x38, r0	; 56
    1c6a:	0f 90       	pop	r0
    1c6c:	0f be       	out	0x3f, r0	; 63
    1c6e:	0f 90       	pop	r0
    1c70:	1f 90       	pop	r1
    1c72:	18 95       	reti

00001c74 <sensorsTaskInit>:



void sensorsTaskInit(void)
{
  LockersMemInit();
    1c74:	0e 94 6d 0b 	call	0x16da	; 0x16da <LockersMemInit>
  rollersMemInit();
    1c78:	0e 94 2c 40 	call	0x8058	; 0x8058 <rollersMemInit>
}
    1c7c:	08 95       	ret

00001c7e <sensorsTask>:

void sensorsTask(void* pvParameters)
{
    1c7e:	1f 93       	push	r17
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
  pvParameters = NULL;
  uint8_t addr = 255;
//  uint8_t i;

  MPC23s17SetDirA(0x00, 0);
    1c84:	80 e0       	ldi	r24, 0x00	; 0
    1c86:	60 e0       	ldi	r22, 0x00	; 0
    1c88:	0e 94 b0 28 	call	0x5160	; 0x5160 <MPC23s17SetDirA>
  
  MPC23s17SetDirB(0x00, 0);
    1c8c:	80 e0       	ldi	r24, 0x00	; 0
    1c8e:	60 e0       	ldi	r22, 0x00	; 0
    1c90:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <MPC23s17SetDirB>
    vTaskDelay(10);
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    tmp *=10;
    temperature = (uint8_t)(tmp / 24);
    1c94:	c8 e1       	ldi	r28, 0x18	; 24
    1c96:	d0 e0       	ldi	r29, 0x00	; 0

  for( ; ; )
  {
    uint16_t tmp;
    //Read power suply voltage
    tmp = MCP3008_getSampleSingle(0);
    1c98:	80 e0       	ldi	r24, 0x00	; 0
    1c9a:	0e 94 42 2a 	call	0x5484	; 0x5484 <MCP3008_getSampleSingle>
    voltage = (uint8_t)(tmp>>5);
    1c9e:	65 e0       	ldi	r22, 0x05	; 5
    1ca0:	96 95       	lsr	r25
    1ca2:	87 95       	ror	r24
    1ca4:	6a 95       	dec	r22
    1ca6:	e1 f7       	brne	.-8      	; 0x1ca0 <sensorsTask+0x22>
    1ca8:	80 93 0e 32 	sts	0x320E, r24
    vTaskDelay(10);
    1cac:	8a e0       	ldi	r24, 0x0A	; 10
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	0e 94 42 2a 	call	0x5484	; 0x5484 <MCP3008_getSampleSingle>
    tmp *=10;
    1cba:	9c 01       	movw	r18, r24
    1cbc:	88 0f       	add	r24, r24
    1cbe:	99 1f       	adc	r25, r25
    1cc0:	43 e0       	ldi	r20, 0x03	; 3
    1cc2:	22 0f       	add	r18, r18
    1cc4:	33 1f       	adc	r19, r19
    1cc6:	4a 95       	dec	r20
    1cc8:	e1 f7       	brne	.-8      	; 0x1cc2 <sensorsTask+0x44>
    1cca:	82 0f       	add	r24, r18
    1ccc:	93 1f       	adc	r25, r19
    temperature = (uint8_t)(tmp / 24);
    1cce:	be 01       	movw	r22, r28
    1cd0:	0e 94 76 54 	call	0xa8ec	; 0xa8ec <__udivmodhi4>
    1cd4:	60 93 06 32 	sts	0x3206, r22
    vTaskDelay(10);
    1cd8:	8a e0       	ldi	r24, 0x0A	; 10
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
      
    //read lock
    checkLockerSensors();
    1ce0:	0e 94 13 0c 	call	0x1826	; 0x1826 <checkLockerSensors>

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1ce4:	11 e0       	ldi	r17, 0x01	; 1
    {
      rs485rollerHello(addr);
    1ce6:	81 2f       	mov	r24, r17
    1ce8:	0e 94 92 41 	call	0x8324	; 0x8324 <rs485rollerHello>
      vTaskDelay(10);
    1cec:	8a e0       	ldi	r24, 0x0A	; 10
    1cee:	90 e0       	ldi	r25, 0x00	; 0
    1cf0:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    vTaskDelay(10);
      
    //read lock
    checkLockerSensors();

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1cf4:	1f 5f       	subi	r17, 0xFF	; 255
    1cf6:	10 32       	cpi	r17, 0x20	; 32
    1cf8:	b1 f7       	brne	.-20     	; 0x1ce6 <sensorsTask+0x68>
    1cfa:	ce cf       	rjmp	.-100    	; 0x1c98 <sensorsTask+0x1a>

00001cfc <enableFunction>:
  state->err1 = 0;
  state->err2 = 0;
}

static cliExRes_t enableFunction(cmdState_t *state)
{
    1cfc:	fc 01       	movw	r30, r24
  if (state->cliMode != RESTRICTED_NORMAL)
    1cfe:	80 a1       	ldd	r24, Z+32	; 0x20
    1d00:	83 30       	cpi	r24, 0x03	; 3
    1d02:	49 f0       	breq	.+18     	; 0x1d16 <enableFunction+0x1a>
  {
    state->cmdList = cmdListEnable;
    1d04:	8d e1       	ldi	r24, 0x1D	; 29
    1d06:	94 e2       	ldi	r25, 0x24	; 36
    1d08:	81 a3       	std	Z+33, r24	; 0x21
    1d0a:	92 a3       	std	Z+34, r25	; 0x22
    state->cliMode = NR_ENABLE;
    1d0c:	81 e0       	ldi	r24, 0x01	; 1
    1d0e:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1d10:	20 e0       	ldi	r18, 0x00	; 0
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	02 c0       	rjmp	.+4      	; 0x1d1a <enableFunction+0x1e>
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1d16:	25 e0       	ldi	r18, 0x05	; 5
    1d18:	30 e0       	ldi	r19, 0x00	; 0
}
    1d1a:	c9 01       	movw	r24, r18
    1d1c:	08 95       	ret

00001d1e <disableFunction>:
static cliExRes_t disableFunction(cmdState_t *state)
{
    1d1e:	fc 01       	movw	r30, r24
  state->cmdList = cmdListNormal;
    1d20:	88 e9       	ldi	r24, 0x98	; 152
    1d22:	96 e0       	ldi	r25, 0x06	; 6
    1d24:	81 a3       	std	Z+33, r24	; 0x21
    1d26:	92 a3       	std	Z+34, r25	; 0x22
  if (state->cliMode != RESTRICTED_NORMAL)
    1d28:	80 a1       	ldd	r24, Z+32	; 0x20
    1d2a:	83 30       	cpi	r24, 0x03	; 3
    1d2c:	09 f0       	breq	.+2      	; 0x1d30 <disableFunction+0x12>
  {
    state->cliMode = NR_NORMAL;
    1d2e:	10 a2       	std	Z+32, r1	; 0x20
  }
  return OK_SILENT;
}
    1d30:	80 e0       	ldi	r24, 0x00	; 0
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	08 95       	ret

00001d36 <configureModeFunction>:
static cliExRes_t configureModeFunction(cmdState_t *state)
{
    1d36:	fc 01       	movw	r30, r24
  if (state->cliMode == NR_ENABLE)
    1d38:	80 a1       	ldd	r24, Z+32	; 0x20
    1d3a:	81 30       	cpi	r24, 0x01	; 1
    1d3c:	49 f4       	brne	.+18     	; 0x1d50 <configureModeFunction+0x1a>
  {
    state->cmdList = cmdListConfigure;
    1d3e:	8e ec       	ldi	r24, 0xCE	; 206
    1d40:	96 e0       	ldi	r25, 0x06	; 6
    1d42:	81 a3       	std	Z+33, r24	; 0x21
    1d44:	92 a3       	std	Z+34, r25	; 0x22
    state->cliMode = NR_CONFIGURE;
    1d46:	82 e0       	ldi	r24, 0x02	; 2
    1d48:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1d4a:	20 e0       	ldi	r18, 0x00	; 0
    1d4c:	30 e0       	ldi	r19, 0x00	; 0
    1d4e:	02 c0       	rjmp	.+4      	; 0x1d54 <configureModeFunction+0x1e>
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1d50:	25 e0       	ldi	r18, 0x05	; 5
    1d52:	30 e0       	ldi	r19, 0x00	; 0
}
    1d54:	c9 01       	movw	r24, r18
    1d56:	08 95       	ret

00001d58 <saveConfigFunction>:
}

static cliExRes_t saveConfigFunction(cmdState_t *state)
{
  state = NULL;
  saveConfiguration();
    1d58:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <saveConfiguration>
  return OK_SILENT;
}
    1d5c:	80 e0       	ldi	r24, 0x00	; 0
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	08 95       	ret

00001d62 <setMacAddrFunction>:
  ipSetConfigGw(gw);
  return OK_SILENT;
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
    1d62:	cf 93       	push	r28
    1d64:	df 93       	push	r29
    1d66:	ec 01       	movw	r28, r24
  if (state->argc < 6)
    1d68:	89 8d       	ldd	r24, Y+25	; 0x19
    1d6a:	86 30       	cpi	r24, 0x06	; 6
    1d6c:	58 f1       	brcs	.+86     	; 0x1dc4 <setMacAddrFunction+0x62>
    return SYNTAX_ERROR;  
  
  nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	be 01       	movw	r22, r28
    1d72:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <cmdlineGetArgHex>
    1d76:	60 93 e0 31 	sts	0x31E0, r22
  nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
    1d7a:	82 e0       	ldi	r24, 0x02	; 2
    1d7c:	be 01       	movw	r22, r28
    1d7e:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <cmdlineGetArgHex>
    1d82:	60 93 e1 31 	sts	0x31E1, r22
  nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
    1d86:	83 e0       	ldi	r24, 0x03	; 3
    1d88:	be 01       	movw	r22, r28
    1d8a:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <cmdlineGetArgHex>
    1d8e:	60 93 e2 31 	sts	0x31E2, r22
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
    1d92:	84 e0       	ldi	r24, 0x04	; 4
    1d94:	be 01       	movw	r22, r28
    1d96:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <cmdlineGetArgHex>
    1d9a:	60 93 e3 31 	sts	0x31E3, r22
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
    1d9e:	85 e0       	ldi	r24, 0x05	; 5
    1da0:	be 01       	movw	r22, r28
    1da2:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <cmdlineGetArgHex>
    1da6:	60 93 e4 31 	sts	0x31E4, r22
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
    1daa:	86 e0       	ldi	r24, 0x06	; 6
    1dac:	be 01       	movw	r22, r28
    1dae:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <cmdlineGetArgHex>
    1db2:	60 93 e5 31 	sts	0x31E5, r22
  nicSetMacAddress(nicState.mac.addr);
    1db6:	80 ee       	ldi	r24, 0xE0	; 224
    1db8:	91 e3       	ldi	r25, 0x31	; 49
    1dba:	0e 94 73 2c 	call	0x58e6	; 0x58e6 <nicSetMacAddress>
  return OK_SILENT;
    1dbe:	20 e0       	ldi	r18, 0x00	; 0
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	02 c0       	rjmp	.+4      	; 0x1dc8 <setMacAddrFunction+0x66>
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
  if (state->argc < 6)
    return SYNTAX_ERROR;  
    1dc4:	22 e0       	ldi	r18, 0x02	; 2
    1dc6:	30 e0       	ldi	r19, 0x00	; 0
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}
    1dc8:	c9 01       	movw	r24, r18
    1dca:	df 91       	pop	r29
    1dcc:	cf 91       	pop	r28
    1dce:	08 95       	ret

00001dd0 <pingFunction>:
  printErrorInfo(state);
  return OK_SILENT;
}

static cliExRes_t pingFunction(cmdState_t *state)
{
    1dd0:	cf 93       	push	r28
    1dd2:	df 93       	push	r29
    1dd4:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1dd6:	89 8d       	ldd	r24, Y+25	; 0x19
    1dd8:	84 30       	cpi	r24, 0x04	; 4
    1dda:	98 f0       	brcs	.+38     	; 0x1e02 <pingFunction+0x32>
    return SYNTAX_ERROR;
  
  uint8_t ip[4];
  ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	be 01       	movw	r22, r28
    1de0:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
  ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
    1de4:	82 e0       	ldi	r24, 0x02	; 2
    1de6:	be 01       	movw	r22, r28
    1de8:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
  ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
    1dec:	83 e0       	ldi	r24, 0x03	; 3
    1dee:	be 01       	movw	r22, r28
    1df0:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
    1df4:	84 e0       	ldi	r24, 0x04	; 4
    1df6:	be 01       	movw	r22, r28
    1df8:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
    1dfc:	20 e0       	ldi	r18, 0x00	; 0
    1dfe:	30 e0       	ldi	r19, 0x00	; 0
    1e00:	02 c0       	rjmp	.+4      	; 0x1e06 <pingFunction+0x36>
}

static cliExRes_t pingFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    1e02:	22 e0       	ldi	r18, 0x02	; 2
    1e04:	30 e0       	ldi	r19, 0x00	; 0
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
}
    1e06:	c9 01       	movw	r24, r18
    1e08:	df 91       	pop	r29
    1e0a:	cf 91       	pop	r28
    1e0c:	08 95       	ret

00001e0e <setUdpFunction>:
  ipSetConfigIp(ip);
  return OK_SILENT;
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
    1e0e:	2f 92       	push	r2
    1e10:	3f 92       	push	r3
    1e12:	4f 92       	push	r4
    1e14:	5f 92       	push	r5
    1e16:	6f 92       	push	r6
    1e18:	7f 92       	push	r7
    1e1a:	8f 92       	push	r8
    1e1c:	9f 92       	push	r9
    1e1e:	af 92       	push	r10
    1e20:	bf 92       	push	r11
    1e22:	cf 92       	push	r12
    1e24:	df 92       	push	r13
    1e26:	ef 92       	push	r14
    1e28:	ff 92       	push	r15
    1e2a:	0f 93       	push	r16
    1e2c:	1f 93       	push	r17
    1e2e:	cf 93       	push	r28
    1e30:	df 93       	push	r29
    1e32:	ec 01       	movw	r28, r24
  if (state->argc < 5)
    1e34:	89 8d       	ldd	r24, Y+25	; 0x19
    1e36:	85 30       	cpi	r24, 0x05	; 5
    1e38:	08 f4       	brcc	.+2      	; 0x1e3c <setUdpFunction+0x2e>
    1e3a:	58 c0       	rjmp	.+176    	; 0x1eec <setUdpFunction+0xde>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	be 01       	movw	r22, r28
    1e40:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1e44:	1b 01       	movw	r2, r22
    1e46:	2c 01       	movw	r4, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1e48:	82 e0       	ldi	r24, 0x02	; 2
    1e4a:	be 01       	movw	r22, r28
    1e4c:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1e50:	5b 01       	movw	r10, r22
    1e52:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1e54:	83 e0       	ldi	r24, 0x03	; 3
    1e56:	be 01       	movw	r22, r28
    1e58:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1e5c:	3b 01       	movw	r6, r22
    1e5e:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1e60:	84 e0       	ldi	r24, 0x04	; 4
    1e62:	be 01       	movw	r22, r28
    1e64:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1e68:	7b 01       	movw	r14, r22
    1e6a:	8c 01       	movw	r16, r24
  udpSocket->dstIp = ip;
    1e6c:	e0 91 04 32 	lds	r30, 0x3204
    1e70:	f0 91 05 32 	lds	r31, 0x3205
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1e74:	bc 2d       	mov	r27, r12
    1e76:	ab 2d       	mov	r26, r11
    1e78:	9a 2d       	mov	r25, r10
    1e7a:	88 27       	eor	r24, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    1e7c:	a3 01       	movw	r20, r6
    1e7e:	33 27       	eor	r19, r19
    1e80:	22 27       	eor	r18, r18
static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1e82:	82 0f       	add	r24, r18
    1e84:	93 1f       	adc	r25, r19
    1e86:	a4 1f       	adc	r26, r20
    1e88:	b5 1f       	adc	r27, r21
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1e8a:	82 0d       	add	r24, r2
    1e8c:	93 1d       	adc	r25, r3
    1e8e:	a4 1d       	adc	r26, r4
    1e90:	b5 1d       	adc	r27, r5
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1e92:	1e 2d       	mov	r17, r14
    1e94:	00 27       	eor	r16, r16
    1e96:	ff 24       	eor	r15, r15
    1e98:	ee 24       	eor	r14, r14
static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    1e9a:	8e 0d       	add	r24, r14
    1e9c:	9f 1d       	adc	r25, r15
    1e9e:	a0 1f       	adc	r26, r16
    1ea0:	b1 1f       	adc	r27, r17
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  udpSocket->dstIp = ip;
    1ea2:	86 83       	std	Z+6, r24	; 0x06
    1ea4:	97 83       	std	Z+7, r25	; 0x07
    1ea6:	a0 87       	std	Z+8, r26	; 0x08
    1ea8:	b1 87       	std	Z+9, r27	; 0x09
  
  uint16_t port = cmdlineGetArgInt(5, state);
    1eaa:	85 e0       	ldi	r24, 0x05	; 5
    1eac:	be 01       	movw	r22, r28
    1eae:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1eb2:	dc 01       	movw	r26, r24
    1eb4:	cb 01       	movw	r24, r22
  udpSocket->srcPort = htons(port);
    1eb6:	e0 90 04 32 	lds	r14, 0x3204
    1eba:	f0 90 05 32 	lds	r15, 0x3205
    1ebe:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    1ec2:	f7 01       	movw	r30, r14
    1ec4:	84 83       	std	Z+4, r24	; 0x04
    1ec6:	95 83       	std	Z+5, r25	; 0x05
  
  if (state->argc > 5)
    1ec8:	89 8d       	ldd	r24, Y+25	; 0x19
    1eca:	86 30       	cpi	r24, 0x06	; 6
    1ecc:	90 f0       	brcs	.+36     	; 0x1ef2 <setUdpFunction+0xe4>
  {
    port = cmdlineGetArgInt(6, state);
    1ece:	86 e0       	ldi	r24, 0x06	; 6
    1ed0:	be 01       	movw	r22, r28
    1ed2:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1ed6:	dc 01       	movw	r26, r24
    1ed8:	cb 01       	movw	r24, r22
    udpSocket->dstPort = htons(port);    
    1eda:	c0 91 04 32 	lds	r28, 0x3204
    1ede:	d0 91 05 32 	lds	r29, 0x3205
    1ee2:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    1ee6:	8a 83       	std	Y+2, r24	; 0x02
    1ee8:	9b 83       	std	Y+3, r25	; 0x03
    1eea:	03 c0       	rjmp	.+6      	; 0x1ef2 <setUdpFunction+0xe4>
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
    1eec:	22 e0       	ldi	r18, 0x02	; 2
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	02 c0       	rjmp	.+4      	; 0x1ef6 <setUdpFunction+0xe8>
  if (state->argc > 5)
  {
    port = cmdlineGetArgInt(6, state);
    udpSocket->dstPort = htons(port);    
  }
  return OK_SILENT;
    1ef2:	20 e0       	ldi	r18, 0x00	; 0
    1ef4:	30 e0       	ldi	r19, 0x00	; 0
}
    1ef6:	c9 01       	movw	r24, r18
    1ef8:	df 91       	pop	r29
    1efa:	cf 91       	pop	r28
    1efc:	1f 91       	pop	r17
    1efe:	0f 91       	pop	r16
    1f00:	ff 90       	pop	r15
    1f02:	ef 90       	pop	r14
    1f04:	df 90       	pop	r13
    1f06:	cf 90       	pop	r12
    1f08:	bf 90       	pop	r11
    1f0a:	af 90       	pop	r10
    1f0c:	9f 90       	pop	r9
    1f0e:	8f 90       	pop	r8
    1f10:	7f 90       	pop	r7
    1f12:	6f 90       	pop	r6
    1f14:	5f 90       	pop	r5
    1f16:	4f 90       	pop	r4
    1f18:	3f 90       	pop	r3
    1f1a:	2f 90       	pop	r2
    1f1c:	08 95       	ret

00001f1e <setIpGwFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
    1f1e:	6f 92       	push	r6
    1f20:	7f 92       	push	r7
    1f22:	8f 92       	push	r8
    1f24:	9f 92       	push	r9
    1f26:	af 92       	push	r10
    1f28:	bf 92       	push	r11
    1f2a:	cf 92       	push	r12
    1f2c:	df 92       	push	r13
    1f2e:	ef 92       	push	r14
    1f30:	ff 92       	push	r15
    1f32:	0f 93       	push	r16
    1f34:	1f 93       	push	r17
    1f36:	cf 93       	push	r28
    1f38:	df 93       	push	r29
    1f3a:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    1f3c:	89 8d       	ldd	r24, Y+25	; 0x19
    1f3e:	84 30       	cpi	r24, 0x04	; 4
    1f40:	b0 f1       	brcs	.+108    	; 0x1fae <setIpGwFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	be 01       	movw	r22, r28
    1f46:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1f4a:	3b 01       	movw	r6, r22
    1f4c:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1f4e:	82 e0       	ldi	r24, 0x02	; 2
    1f50:	be 01       	movw	r22, r28
    1f52:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1f56:	7b 01       	movw	r14, r22
    1f58:	8c 01       	movw	r16, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    1f5a:	83 e0       	ldi	r24, 0x03	; 3
    1f5c:	be 01       	movw	r22, r28
    1f5e:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1f62:	5b 01       	movw	r10, r22
    1f64:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1f66:	84 e0       	ldi	r24, 0x04	; 4
    1f68:	be 01       	movw	r22, r28
    1f6a:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1f6e:	dc 01       	movw	r26, r24
    1f70:	cb 01       	movw	r24, r22
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1f72:	10 2f       	mov	r17, r16
    1f74:	0f 2d       	mov	r16, r15
    1f76:	fe 2c       	mov	r15, r14
    1f78:	ee 24       	eor	r14, r14
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    1f7a:	65 01       	movw	r12, r10
    1f7c:	bb 24       	eor	r11, r11
    1f7e:	aa 24       	eor	r10, r10
static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1f80:	ea 0c       	add	r14, r10
    1f82:	fb 1c       	adc	r15, r11
    1f84:	0c 1d       	adc	r16, r12
    1f86:	1d 1d       	adc	r17, r13
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    1f88:	e6 0c       	add	r14, r6
    1f8a:	f7 1c       	adc	r15, r7
    1f8c:	08 1d       	adc	r16, r8
    1f8e:	19 1d       	adc	r17, r9
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    1f90:	b8 2f       	mov	r27, r24
    1f92:	aa 27       	eor	r26, r26
    1f94:	99 27       	eor	r25, r25
    1f96:	88 27       	eor	r24, r24
static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
    1f98:	e8 0e       	add	r14, r24
    1f9a:	f9 1e       	adc	r15, r25
    1f9c:	0a 1f       	adc	r16, r26
    1f9e:	1b 1f       	adc	r17, r27
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  ipSetConfigGw(gw);
    1fa0:	c8 01       	movw	r24, r16
    1fa2:	b7 01       	movw	r22, r14
    1fa4:	0e 94 3b 33 	call	0x6676	; 0x6676 <ipSetConfigGw>
  return OK_SILENT;
    1fa8:	20 e0       	ldi	r18, 0x00	; 0
    1faa:	30 e0       	ldi	r19, 0x00	; 0
    1fac:	02 c0       	rjmp	.+4      	; 0x1fb2 <setIpGwFunction+0x94>


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    1fae:	22 e0       	ldi	r18, 0x02	; 2
    1fb0:	30 e0       	ldi	r19, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  ipSetConfigGw(gw);
  return OK_SILENT;
}
    1fb2:	c9 01       	movw	r24, r18
    1fb4:	df 91       	pop	r29
    1fb6:	cf 91       	pop	r28
    1fb8:	1f 91       	pop	r17
    1fba:	0f 91       	pop	r16
    1fbc:	ff 90       	pop	r15
    1fbe:	ef 90       	pop	r14
    1fc0:	df 90       	pop	r13
    1fc2:	cf 90       	pop	r12
    1fc4:	bf 90       	pop	r11
    1fc6:	af 90       	pop	r10
    1fc8:	9f 90       	pop	r9
    1fca:	8f 90       	pop	r8
    1fcc:	7f 90       	pop	r7
    1fce:	6f 90       	pop	r6
    1fd0:	08 95       	ret

00001fd2 <setIpMaskFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
    1fd2:	bc 01       	movw	r22, r24
  if (state->argc < 1)
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	81 8d       	ldd	r24, Z+25	; 0x19
    1fd8:	88 23       	and	r24, r24
    1fda:	b1 f0       	breq	.+44     	; 0x2008 <setIpMaskFunction+0x36>
    return SYNTAX_ERROR;
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    1fe2:	20 e2       	ldi	r18, 0x20	; 32
    1fe4:	30 e0       	ldi	r19, 0x00	; 0
    1fe6:	26 1b       	sub	r18, r22
    1fe8:	37 0b       	sbc	r19, r23
    1fea:	6f ef       	ldi	r22, 0xFF	; 255
    1fec:	7f ef       	ldi	r23, 0xFF	; 255
    1fee:	cb 01       	movw	r24, r22
    1ff0:	04 c0       	rjmp	.+8      	; 0x1ffa <setIpMaskFunction+0x28>
    1ff2:	96 95       	lsr	r25
    1ff4:	87 95       	ror	r24
    1ff6:	77 95       	ror	r23
    1ff8:	67 95       	ror	r22
    1ffa:	2a 95       	dec	r18
    1ffc:	d2 f7       	brpl	.-12     	; 0x1ff2 <setIpMaskFunction+0x20>
  
  ipSetConfigMask(mask);
    1ffe:	0e 94 32 33 	call	0x6664	; 0x6664 <ipSetConfigMask>
  return OK_SILENT;
    2002:	20 e0       	ldi	r18, 0x00	; 0
    2004:	30 e0       	ldi	r19, 0x00	; 0
    2006:	02 c0       	rjmp	.+4      	; 0x200c <setIpMaskFunction+0x3a>


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    2008:	22 e0       	ldi	r18, 0x02	; 2
    200a:	30 e0       	ldi	r19, 0x00	; 0
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
  
  ipSetConfigMask(mask);
  return OK_SILENT;
}
    200c:	c9 01       	movw	r24, r18
    200e:	08 95       	ret

00002010 <setIpFunction>:
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
  return OK_SILENT;
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
    2010:	6f 92       	push	r6
    2012:	7f 92       	push	r7
    2014:	8f 92       	push	r8
    2016:	9f 92       	push	r9
    2018:	af 92       	push	r10
    201a:	bf 92       	push	r11
    201c:	cf 92       	push	r12
    201e:	df 92       	push	r13
    2020:	ef 92       	push	r14
    2022:	ff 92       	push	r15
    2024:	0f 93       	push	r16
    2026:	1f 93       	push	r17
    2028:	cf 93       	push	r28
    202a:	df 93       	push	r29
    202c:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    202e:	89 8d       	ldd	r24, Y+25	; 0x19
    2030:	84 30       	cpi	r24, 0x04	; 4
    2032:	b0 f1       	brcs	.+108    	; 0x20a0 <setIpFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    2034:	81 e0       	ldi	r24, 0x01	; 1
    2036:	be 01       	movw	r22, r28
    2038:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    203c:	3b 01       	movw	r6, r22
    203e:	4c 01       	movw	r8, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    2040:	82 e0       	ldi	r24, 0x02	; 2
    2042:	be 01       	movw	r22, r28
    2044:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2048:	7b 01       	movw	r14, r22
    204a:	8c 01       	movw	r16, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    204c:	83 e0       	ldi	r24, 0x03	; 3
    204e:	be 01       	movw	r22, r28
    2050:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2054:	5b 01       	movw	r10, r22
    2056:	6c 01       	movw	r12, r24
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2058:	84 e0       	ldi	r24, 0x04	; 4
    205a:	be 01       	movw	r22, r28
    205c:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2060:	dc 01       	movw	r26, r24
    2062:	cb 01       	movw	r24, r22
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    2064:	10 2f       	mov	r17, r16
    2066:	0f 2d       	mov	r16, r15
    2068:	fe 2c       	mov	r15, r14
    206a:	ee 24       	eor	r14, r14
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
    206c:	65 01       	movw	r12, r10
    206e:	bb 24       	eor	r11, r11
    2070:	aa 24       	eor	r10, r10
static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    2072:	ea 0c       	add	r14, r10
    2074:	fb 1c       	adc	r15, r11
    2076:	0c 1d       	adc	r16, r12
    2078:	1d 1d       	adc	r17, r13
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
    207a:	e6 0c       	add	r14, r6
    207c:	f7 1c       	adc	r15, r7
    207e:	08 1d       	adc	r16, r8
    2080:	19 1d       	adc	r17, r9
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2082:	b8 2f       	mov	r27, r24
    2084:	aa 27       	eor	r26, r26
    2086:	99 27       	eor	r25, r25
    2088:	88 27       	eor	r24, r24
static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
    208a:	e8 0e       	add	r14, r24
    208c:	f9 1e       	adc	r15, r25
    208e:	0a 1f       	adc	r16, r26
    2090:	1b 1f       	adc	r17, r27
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  
  ipSetConfigIp(ip);
    2092:	c8 01       	movw	r24, r16
    2094:	b7 01       	movw	r22, r14
    2096:	0e 94 29 33 	call	0x6652	; 0x6652 <ipSetConfigIp>
  return OK_SILENT;
    209a:	20 e0       	ldi	r18, 0x00	; 0
    209c:	30 e0       	ldi	r19, 0x00	; 0
    209e:	02 c0       	rjmp	.+4      	; 0x20a4 <setIpFunction+0x94>
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    20a0:	22 e0       	ldi	r18, 0x02	; 2
    20a2:	30 e0       	ldi	r19, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
  
  ipSetConfigIp(ip);
  return OK_SILENT;
}
    20a4:	c9 01       	movw	r24, r18
    20a6:	df 91       	pop	r29
    20a8:	cf 91       	pop	r28
    20aa:	1f 91       	pop	r17
    20ac:	0f 91       	pop	r16
    20ae:	ff 90       	pop	r15
    20b0:	ef 90       	pop	r14
    20b2:	df 90       	pop	r13
    20b4:	cf 90       	pop	r12
    20b6:	bf 90       	pop	r11
    20b8:	af 90       	pop	r10
    20ba:	9f 90       	pop	r9
    20bc:	8f 90       	pop	r8
    20be:	7f 90       	pop	r7
    20c0:	6f 90       	pop	r6
    20c2:	08 95       	ret

000020c4 <czytajAC_Function>:
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}

static cliExRes_t czytajAC_Function(cmdState_t *state)
{
    20c4:	0f 93       	push	r16
    20c6:	1f 93       	push	r17
    20c8:	df 93       	push	r29
    20ca:	cf 93       	push	r28
    20cc:	0f 92       	push	r0
    20ce:	cd b7       	in	r28, 0x3d	; 61
    20d0:	de b7       	in	r29, 0x3e	; 62
    20d2:	8c 01       	movw	r16, r24
  uint8_t nrWejscia = cmdlineGetArgInt(1, state);
    20d4:	81 e0       	ldi	r24, 0x01	; 1
    20d6:	b8 01       	movw	r22, r16
    20d8:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
  uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
    20dc:	86 2f       	mov	r24, r22
    20de:	69 83       	std	Y+1, r22	; 0x01
    20e0:	0e 94 42 2a 	call	0x5484	; 0x5484 <MCP3008_getSampleSingle>
  fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
    20e4:	2d b7       	in	r18, 0x3d	; 61
    20e6:	3e b7       	in	r19, 0x3e	; 62
    20e8:	28 50       	subi	r18, 0x08	; 8
    20ea:	30 40       	sbci	r19, 0x00	; 0
    20ec:	2d bf       	out	0x3d, r18	; 61
    20ee:	3e bf       	out	0x3e, r19	; 62
    20f0:	ed b7       	in	r30, 0x3d	; 61
    20f2:	fe b7       	in	r31, 0x3e	; 62
    20f4:	31 96       	adiw	r30, 0x01	; 1
    20f6:	d8 01       	movw	r26, r16
    20f8:	5a 96       	adiw	r26, 0x1a	; 26
    20fa:	2d 91       	ld	r18, X+
    20fc:	3c 91       	ld	r19, X
    20fe:	5b 97       	sbiw	r26, 0x1b	; 27
    2100:	ad b7       	in	r26, 0x3d	; 61
    2102:	be b7       	in	r27, 0x3e	; 62
    2104:	11 96       	adiw	r26, 0x01	; 1
    2106:	2d 93       	st	X+, r18
    2108:	3c 93       	st	X, r19
    210a:	12 97       	sbiw	r26, 0x02	; 2
    210c:	2c e1       	ldi	r18, 0x1C	; 28
    210e:	37 e0       	ldi	r19, 0x07	; 7
    2110:	22 83       	std	Z+2, r18	; 0x02
    2112:	33 83       	std	Z+3, r19	; 0x03
    2114:	69 81       	ldd	r22, Y+1	; 0x01
    2116:	64 83       	std	Z+4, r22	; 0x04
    2118:	15 82       	std	Z+5, r1	; 0x05
    211a:	86 83       	std	Z+6, r24	; 0x06
    211c:	97 83       	std	Z+7, r25	; 0x07
    211e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    2122:	ed b7       	in	r30, 0x3d	; 61
    2124:	fe b7       	in	r31, 0x3e	; 62
    2126:	38 96       	adiw	r30, 0x08	; 8
    2128:	ed bf       	out	0x3d, r30	; 61
    212a:	fe bf       	out	0x3e, r31	; 62
  return OK_SILENT;
}
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	0f 90       	pop	r0
    2132:	cf 91       	pop	r28
    2134:	df 91       	pop	r29
    2136:	1f 91       	pop	r17
    2138:	0f 91       	pop	r16
    213a:	08 95       	ret

0000213c <setTimeFunction>:
  return SYNTAX_ERROR;
}


static cliExRes_t setTimeFunction(cmdState_t *state)
{
    213c:	ff 92       	push	r15
    213e:	0f 93       	push	r16
    2140:	1f 93       	push	r17
    2142:	cf 93       	push	r28
    2144:	df 93       	push	r29
    2146:	ec 01       	movw	r28, r24
  uint8_t godzina =  cmdlineGetArgInt(1, state);
    2148:	81 e0       	ldi	r24, 0x01	; 1
    214a:	be 01       	movw	r22, r28
    214c:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2150:	f6 2e       	mov	r15, r22
  uint8_t minuta  =  cmdlineGetArgInt(2, state);
    2152:	82 e0       	ldi	r24, 0x02	; 2
    2154:	be 01       	movw	r22, r28
    2156:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    215a:	06 2f       	mov	r16, r22
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
    215c:	83 e0       	ldi	r24, 0x03	; 3
    215e:	be 01       	movw	r22, r28
    2160:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2164:	16 2f       	mov	r17, r22
  
  ds1305start();
    2166:	0e 94 34 28 	call	0x5068	; 0x5068 <ds1305start>

  uint8_t cDzies = godzina/10;
    216a:	5a e0       	ldi	r21, 0x0A	; 10
    216c:	8f 2d       	mov	r24, r15
    216e:	65 2f       	mov	r22, r21
    2170:	0e 94 6a 54 	call	0xa8d4	; 0xa8d4 <__udivmodqi4>
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
    2174:	48 2f       	mov	r20, r24
    2176:	43 70       	andi	r20, 0x03	; 3
    2178:	29 e1       	ldi	r18, 0x19	; 25
    217a:	32 e3       	ldi	r19, 0x32	; 50
    217c:	42 95       	swap	r20
    217e:	40 7f       	andi	r20, 0xF0	; 240
    2180:	90 91 19 32 	lds	r25, 0x3219
    2184:	9f 7c       	andi	r25, 0xCF	; 207
    2186:	94 2b       	or	r25, r20
    2188:	90 93 19 32 	sts	0x3219, r25
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
  
  ds1305start();

  uint8_t cDzies = godzina/10;
  uint8_t cJedn = godzina - cDzies*10;
    218c:	46 ef       	ldi	r20, 0xF6	; 246
    218e:	84 9f       	mul	r24, r20
    2190:	80 2d       	mov	r24, r0
    2192:	11 24       	eor	r1, r1
    2194:	8f 0d       	add	r24, r15
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;
    2196:	8f 70       	andi	r24, 0x0F	; 15
    2198:	90 91 19 32 	lds	r25, 0x3219
    219c:	90 7f       	andi	r25, 0xF0	; 240
    219e:	98 2b       	or	r25, r24
    21a0:	90 93 19 32 	sts	0x3219, r25
  
  cDzies = minuta/10;
    21a4:	80 2f       	mov	r24, r16
    21a6:	0e 94 6a 54 	call	0xa8d4	; 0xa8d4 <__udivmodqi4>
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
    21aa:	68 2f       	mov	r22, r24
    21ac:	67 70       	andi	r22, 0x07	; 7
    21ae:	f9 01       	movw	r30, r18
    21b0:	62 95       	swap	r22
    21b2:	60 7f       	andi	r22, 0xF0	; 240
    21b4:	92 91       	ld	r25, -Z
    21b6:	9f 78       	andi	r25, 0x8F	; 143
    21b8:	96 2b       	or	r25, r22
    21ba:	90 83       	st	Z, r25
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;
  
  cDzies = minuta/10;
  cJedn = minuta - cDzies * 10;
    21bc:	84 9f       	mul	r24, r20
    21be:	80 2d       	mov	r24, r0
    21c0:	11 24       	eor	r1, r1
    21c2:	80 0f       	add	r24, r16
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;
    21c4:	8f 70       	andi	r24, 0x0F	; 15
    21c6:	90 81       	ld	r25, Z
    21c8:	90 7f       	andi	r25, 0xF0	; 240
    21ca:	98 2b       	or	r25, r24
    21cc:	90 83       	st	Z, r25
  
  cDzies = sekunda/10;
    21ce:	81 2f       	mov	r24, r17
    21d0:	65 2f       	mov	r22, r21
    21d2:	0e 94 6a 54 	call	0xa8d4	; 0xa8d4 <__udivmodqi4>
  cJedn  = sekunda - cDzies * 10;
  czasRtc.seconds.cDzies = cDzies;
    21d6:	58 2f       	mov	r21, r24
    21d8:	57 70       	andi	r21, 0x07	; 7
    21da:	f9 01       	movw	r30, r18
    21dc:	32 97       	sbiw	r30, 0x02	; 2
    21de:	52 95       	swap	r21
    21e0:	50 7f       	andi	r21, 0xF0	; 240
    21e2:	90 81       	ld	r25, Z
    21e4:	9f 78       	andi	r25, 0x8F	; 143
    21e6:	95 2b       	or	r25, r21
    21e8:	90 83       	st	Z, r25
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;
  
  cDzies = sekunda/10;
  cJedn  = sekunda - cDzies * 10;
    21ea:	84 9f       	mul	r24, r20
    21ec:	40 2d       	mov	r20, r0
    21ee:	11 24       	eor	r1, r1
    21f0:	41 0f       	add	r20, r17
  czasRtc.seconds.cDzies = cDzies;
  czasRtc.seconds.cJedn  = cJedn;
    21f2:	4f 70       	andi	r20, 0x0F	; 15
    21f4:	90 81       	ld	r25, Z
    21f6:	90 7f       	andi	r25, 0xF0	; 240
    21f8:	94 2b       	or	r25, r20
    21fa:	90 83       	st	Z, r25
  
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
    21fc:	cf 01       	movw	r24, r30
    21fe:	0e 94 2e 28 	call	0x505c	; 0x505c <setTimeDecoded>
  return OK_SILENT;
}
    2202:	80 e0       	ldi	r24, 0x00	; 0
    2204:	90 e0       	ldi	r25, 0x00	; 0
    2206:	df 91       	pop	r29
    2208:	cf 91       	pop	r28
    220a:	1f 91       	pop	r17
    220c:	0f 91       	pop	r16
    220e:	ff 90       	pop	r15
    2210:	08 95       	ret

00002212 <ustawPortRezystor>:
  MPC23s17SetPortB(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
    2212:	bc 01       	movw	r22, r24
  if (state->argc < 1)
    2214:	fc 01       	movw	r30, r24
    2216:	81 8d       	ldd	r24, Z+25	; 0x19
    2218:	88 23       	and	r24, r24
    221a:	49 f0       	breq	.+18     	; 0x222e <ustawPortRezystor+0x1c>
    return SYNTAX_ERROR;

  uint8_t wartosc = cmdlineGetArgInt(1, state);
    221c:	81 e0       	ldi	r24, 0x01	; 1
    221e:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2222:	86 2f       	mov	r24, r22
  
  MCP4150_setValue(wartosc);
    2224:	0e 94 6f 2a 	call	0x54de	; 0x54de <MCP4150_setValue>
  
  return OK_SILENT;
    2228:	20 e0       	ldi	r18, 0x00	; 0
    222a:	30 e0       	ldi	r19, 0x00	; 0
    222c:	02 c0       	rjmp	.+4      	; 0x2232 <ustawPortRezystor+0x20>
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    222e:	22 e0       	ldi	r18, 0x02	; 2
    2230:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t wartosc = cmdlineGetArgInt(1, state);
  
  MCP4150_setValue(wartosc);
  
  return OK_SILENT;
}
    2232:	c9 01       	movw	r24, r18
    2234:	08 95       	ret

00002236 <ustawPortExtBFunction>:
  MPC23s17SetPortA(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
{
    2236:	1f 93       	push	r17
    2238:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    223a:	81 e0       	ldi	r24, 0x01	; 1
    223c:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2240:	16 2f       	mov	r17, r22
  MPC23s17SetDirB(0x00, 0);
    2242:	80 e0       	ldi	r24, 0x00	; 0
    2244:	60 e0       	ldi	r22, 0x00	; 0
    2246:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <MPC23s17SetDirB>
  MPC23s17SetPortB(wyjscie, 0);
    224a:	81 2f       	mov	r24, r17
    224c:	60 e0       	ldi	r22, 0x00	; 0
    224e:	0e 94 64 29 	call	0x52c8	; 0x52c8 <MPC23s17SetPortB>
  return OK_SILENT;
}
    2252:	80 e0       	ldi	r24, 0x00	; 0
    2254:	90 e0       	ldi	r25, 0x00	; 0
    2256:	1f 91       	pop	r17
    2258:	08 95       	ret

0000225a <ustawPortExtAFunction>:
  
  return ERROR_SILENT;
}

static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
{
    225a:	1f 93       	push	r17
    225c:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    225e:	81 e0       	ldi	r24, 0x01	; 1
    2260:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2264:	16 2f       	mov	r17, r22
  MPC23s17SetDirA(0x00, 0);
    2266:	80 e0       	ldi	r24, 0x00	; 0
    2268:	60 e0       	ldi	r22, 0x00	; 0
    226a:	0e 94 b0 28 	call	0x5160	; 0x5160 <MPC23s17SetDirA>
  MPC23s17SetPortA(wyjscie, 0);
    226e:	81 2f       	mov	r24, r17
    2270:	60 e0       	ldi	r22, 0x00	; 0
    2272:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <MPC23s17SetPortA>
  return OK_SILENT;
}
    2276:	80 e0       	ldi	r24, 0x00	; 0
    2278:	90 e0       	ldi	r25, 0x00	; 0
    227a:	1f 91       	pop	r17
    227c:	08 95       	ret

0000227e <curtainDownFunction>:
  cmdPrintHelp(state);
  return OK_SILENT;
}

static cliExRes_t curtainDownFunction(cmdState_t *state)
{
    227e:	ff 92       	push	r15
    2280:	0f 93       	push	r16
    2282:	1f 93       	push	r17
    2284:	cf 93       	push	r28
    2286:	df 93       	push	r29
    2288:	ec 01       	movw	r28, r24
  uint8_t nrRolety;
  uint8_t nrSterownika;
  uint8_t wartosc;
  
  nrSterownika = cmdlineGetArgInt(1, state);
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	be 01       	movw	r22, r28
    228e:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2292:	06 2f       	mov	r16, r22
  nrRolety = cmdlineGetArgInt(2, state);
    2294:	82 e0       	ldi	r24, 0x02	; 2
    2296:	be 01       	movw	r22, r28
    2298:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    229c:	16 2f       	mov	r17, r22
  nrRolety &= 0x01;
    229e:	11 70       	andi	r17, 0x01	; 1
  wartosc = cmdlineGetArgInt(3, state);
    22a0:	83 e0       	ldi	r24, 0x03	; 3
    22a2:	be 01       	movw	r22, r28
    22a4:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    22a8:	f6 2e       	mov	r15, r22

  fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
    22aa:	2d b7       	in	r18, 0x3d	; 61
    22ac:	3e b7       	in	r19, 0x3e	; 62
    22ae:	28 50       	subi	r18, 0x08	; 8
    22b0:	30 40       	sbci	r19, 0x00	; 0
    22b2:	2d bf       	out	0x3d, r18	; 61
    22b4:	3e bf       	out	0x3e, r19	; 62
    22b6:	ed b7       	in	r30, 0x3d	; 61
    22b8:	fe b7       	in	r31, 0x3e	; 62
    22ba:	31 96       	adiw	r30, 0x01	; 1
    22bc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22be:	9b 8d       	ldd	r25, Y+27	; 0x1b
    22c0:	ad b7       	in	r26, 0x3d	; 61
    22c2:	be b7       	in	r27, 0x3e	; 62
    22c4:	11 96       	adiw	r26, 0x01	; 1
    22c6:	8d 93       	st	X+, r24
    22c8:	9c 93       	st	X, r25
    22ca:	12 97       	sbiw	r26, 0x02	; 2
    22cc:	8a e3       	ldi	r24, 0x3A	; 58
    22ce:	95 e0       	ldi	r25, 0x05	; 5
    22d0:	82 83       	std	Z+2, r24	; 0x02
    22d2:	93 83       	std	Z+3, r25	; 0x03
    22d4:	04 83       	std	Z+4, r16	; 0x04
    22d6:	15 82       	std	Z+5, r1	; 0x05
    22d8:	21 2f       	mov	r18, r17
    22da:	30 e0       	ldi	r19, 0x00	; 0
    22dc:	2f 5f       	subi	r18, 0xFF	; 255
    22de:	3f 4f       	sbci	r19, 0xFF	; 255
    22e0:	26 83       	std	Z+6, r18	; 0x06
    22e2:	37 83       	std	Z+7, r19	; 0x07
    22e4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>

  if ((wartosc > 0) && (wartosc <=100))
    22e8:	8f 2d       	mov	r24, r15
    22ea:	81 50       	subi	r24, 0x01	; 1
    22ec:	2d b7       	in	r18, 0x3d	; 61
    22ee:	3e b7       	in	r19, 0x3e	; 62
    22f0:	28 5f       	subi	r18, 0xF8	; 248
    22f2:	3f 4f       	sbci	r19, 0xFF	; 255
    22f4:	2d bf       	out	0x3d, r18	; 61
    22f6:	3e bf       	out	0x3e, r19	; 62
    22f8:	84 36       	cpi	r24, 0x64	; 100
    22fa:	d8 f4       	brcc	.+54     	; 0x2332 <curtainDownFunction+0xb4>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    22fc:	00 d0       	rcall	.+0      	; 0x22fe <curtainDownFunction+0x80>
    22fe:	00 d0       	rcall	.+0      	; 0x2300 <curtainDownFunction+0x82>
    2300:	ed b7       	in	r30, 0x3d	; 61
    2302:	fe b7       	in	r31, 0x3e	; 62
    2304:	31 96       	adiw	r30, 0x01	; 1
    2306:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2308:	9b 8d       	ldd	r25, Y+27	; 0x1b
    230a:	ad b7       	in	r26, 0x3d	; 61
    230c:	be b7       	in	r27, 0x3e	; 62
    230e:	11 96       	adiw	r26, 0x01	; 1
    2310:	8d 93       	st	X+, r24
    2312:	9c 93       	st	X, r25
    2314:	12 97       	sbiw	r26, 0x02	; 2
    2316:	2d e6       	ldi	r18, 0x6D	; 109
    2318:	35 e0       	ldi	r19, 0x05	; 5
    231a:	22 83       	std	Z+2, r18	; 0x02
    231c:	33 83       	std	Z+3, r19	; 0x03
    231e:	f4 82       	std	Z+4, r15	; 0x04
    2320:	15 82       	std	Z+5, r1	; 0x05
    2322:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    2326:	2d b7       	in	r18, 0x3d	; 61
    2328:	3e b7       	in	r19, 0x3e	; 62
    232a:	2a 5f       	subi	r18, 0xFA	; 250
    232c:	3f 4f       	sbci	r19, 0xFF	; 255
    232e:	2d bf       	out	0x3d, r18	; 61
    2330:	3e bf       	out	0x3e, r19	; 62

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
    2332:	80 2f       	mov	r24, r16
    2334:	61 2f       	mov	r22, r17
    2336:	4f 2d       	mov	r20, r15
    2338:	0e 94 97 45 	call	0x8b2e	; 0x8b2e <rs485curtainDown>
  
  if (result == 0)
    233c:	88 23       	and	r24, r24
    233e:	19 f4       	brne	.+6      	; 0x2346 <curtainDownFunction+0xc8>
    return OK_INFORM;
    2340:	21 e0       	ldi	r18, 0x01	; 1
    2342:	30 e0       	ldi	r19, 0x00	; 0
    2344:	02 c0       	rjmp	.+4      	; 0x234a <curtainDownFunction+0xcc>
  
  return ERROR_SILENT;
    2346:	23 e0       	ldi	r18, 0x03	; 3
    2348:	30 e0       	ldi	r19, 0x00	; 0
}
    234a:	c9 01       	movw	r24, r18
    234c:	df 91       	pop	r29
    234e:	cf 91       	pop	r28
    2350:	1f 91       	pop	r17
    2352:	0f 91       	pop	r16
    2354:	ff 90       	pop	r15
    2356:	08 95       	ret

00002358 <curtainUpFunction>:

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
    2358:	ff 92       	push	r15
    235a:	0f 93       	push	r16
    235c:	1f 93       	push	r17
    235e:	cf 93       	push	r28
    2360:	df 93       	push	r29
    2362:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    2364:	89 8d       	ldd	r24, Y+25	; 0x19
    2366:	82 30       	cpi	r24, 0x02	; 2
    2368:	08 f4       	brcc	.+2      	; 0x236c <curtainUpFunction+0x14>
    236a:	65 c0       	rjmp	.+202    	; 0x2436 <curtainUpFunction+0xde>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	be 01       	movw	r22, r28
    2370:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2374:	06 2f       	mov	r16, r22
    2376:	0f 73       	andi	r16, 0x3F	; 63
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
    2378:	82 e0       	ldi	r24, 0x02	; 2
    237a:	be 01       	movw	r22, r28
    237c:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2380:	16 2f       	mov	r17, r22
    2382:	11 70       	andi	r17, 0x01	; 1
  uint8_t wartosc = 255;
  if (state->argc > 2)
    2384:	89 8d       	ldd	r24, Y+25	; 0x19
    2386:	83 30       	cpi	r24, 0x03	; 3
    2388:	30 f0       	brcs	.+12     	; 0x2396 <curtainUpFunction+0x3e>
    wartosc = cmdlineGetArgInt(3, state);
    238a:	83 e0       	ldi	r24, 0x03	; 3
    238c:	be 01       	movw	r22, r28
    238e:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2392:	f6 2e       	mov	r15, r22
    2394:	02 c0       	rjmp	.+4      	; 0x239a <curtainUpFunction+0x42>
  if (state->argc < 2)
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
  uint8_t wartosc = 255;
    2396:	ff 24       	eor	r15, r15
    2398:	fa 94       	dec	r15
  if (state->argc > 2)
    wartosc = cmdlineGetArgInt(3, state);

  fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
    239a:	2d b7       	in	r18, 0x3d	; 61
    239c:	3e b7       	in	r19, 0x3e	; 62
    239e:	28 50       	subi	r18, 0x08	; 8
    23a0:	30 40       	sbci	r19, 0x00	; 0
    23a2:	2d bf       	out	0x3d, r18	; 61
    23a4:	3e bf       	out	0x3e, r19	; 62
    23a6:	ed b7       	in	r30, 0x3d	; 61
    23a8:	fe b7       	in	r31, 0x3e	; 62
    23aa:	31 96       	adiw	r30, 0x01	; 1
    23ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23ae:	9b 8d       	ldd	r25, Y+27	; 0x1b
    23b0:	ad b7       	in	r26, 0x3d	; 61
    23b2:	be b7       	in	r27, 0x3e	; 62
    23b4:	11 96       	adiw	r26, 0x01	; 1
    23b6:	8d 93       	st	X+, r24
    23b8:	9c 93       	st	X, r25
    23ba:	12 97       	sbiw	r26, 0x02	; 2
    23bc:	87 e0       	ldi	r24, 0x07	; 7
    23be:	95 e0       	ldi	r25, 0x05	; 5
    23c0:	82 83       	std	Z+2, r24	; 0x02
    23c2:	93 83       	std	Z+3, r25	; 0x03
    23c4:	04 83       	std	Z+4, r16	; 0x04
    23c6:	15 82       	std	Z+5, r1	; 0x05
    23c8:	21 2f       	mov	r18, r17
    23ca:	30 e0       	ldi	r19, 0x00	; 0
    23cc:	2f 5f       	subi	r18, 0xFF	; 255
    23ce:	3f 4f       	sbci	r19, 0xFF	; 255
    23d0:	26 83       	std	Z+6, r18	; 0x06
    23d2:	37 83       	std	Z+7, r19	; 0x07
    23d4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  if ((wartosc > 0) && (wartosc <=100))
    23d8:	8f 2d       	mov	r24, r15
    23da:	81 50       	subi	r24, 0x01	; 1
    23dc:	2d b7       	in	r18, 0x3d	; 61
    23de:	3e b7       	in	r19, 0x3e	; 62
    23e0:	28 5f       	subi	r18, 0xF8	; 248
    23e2:	3f 4f       	sbci	r19, 0xFF	; 255
    23e4:	2d bf       	out	0x3d, r18	; 61
    23e6:	3e bf       	out	0x3e, r19	; 62
    23e8:	84 36       	cpi	r24, 0x64	; 100
    23ea:	d8 f4       	brcc	.+54     	; 0x2422 <curtainUpFunction+0xca>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <curtainUpFunction+0x96>
    23ee:	00 d0       	rcall	.+0      	; 0x23f0 <curtainUpFunction+0x98>
    23f0:	ed b7       	in	r30, 0x3d	; 61
    23f2:	fe b7       	in	r31, 0x3e	; 62
    23f4:	31 96       	adiw	r30, 0x01	; 1
    23f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23f8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    23fa:	ad b7       	in	r26, 0x3d	; 61
    23fc:	be b7       	in	r27, 0x3e	; 62
    23fe:	11 96       	adiw	r26, 0x01	; 1
    2400:	8d 93       	st	X+, r24
    2402:	9c 93       	st	X, r25
    2404:	12 97       	sbiw	r26, 0x02	; 2
    2406:	2d e6       	ldi	r18, 0x6D	; 109
    2408:	35 e0       	ldi	r19, 0x05	; 5
    240a:	22 83       	std	Z+2, r18	; 0x02
    240c:	33 83       	std	Z+3, r19	; 0x03
    240e:	f4 82       	std	Z+4, r15	; 0x04
    2410:	15 82       	std	Z+5, r1	; 0x05
    2412:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    2416:	2d b7       	in	r18, 0x3d	; 61
    2418:	3e b7       	in	r19, 0x3e	; 62
    241a:	2a 5f       	subi	r18, 0xFA	; 250
    241c:	3f 4f       	sbci	r19, 0xFF	; 255
    241e:	2d bf       	out	0x3d, r18	; 61
    2420:	3e bf       	out	0x3e, r19	; 62

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
    2422:	80 2f       	mov	r24, r16
    2424:	61 2f       	mov	r22, r17
    2426:	4f 2d       	mov	r20, r15
    2428:	0e 94 03 45 	call	0x8a06	; 0x8a06 <rs485curtainUp>
  
  if (result == 0)
    242c:	88 23       	and	r24, r24
    242e:	31 f4       	brne	.+12     	; 0x243c <curtainUpFunction+0xe4>
    return OK_INFORM;
    2430:	21 e0       	ldi	r18, 0x01	; 1
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	05 c0       	rjmp	.+10     	; 0x2440 <curtainUpFunction+0xe8>
}

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
  if (state->argc < 2)
    return SYNTAX_ERROR;
    2436:	22 e0       	ldi	r18, 0x02	; 2
    2438:	30 e0       	ldi	r19, 0x00	; 0
    243a:	02 c0       	rjmp	.+4      	; 0x2440 <curtainUpFunction+0xe8>
  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
  
  if (result == 0)
    return OK_INFORM;
  
  return ERROR_SILENT;
    243c:	23 e0       	ldi	r18, 0x03	; 3
    243e:	30 e0       	ldi	r19, 0x00	; 0
}
    2440:	c9 01       	movw	r24, r18
    2442:	df 91       	pop	r29
    2444:	cf 91       	pop	r28
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	ff 90       	pop	r15
    244c:	08 95       	ret

0000244e <goXmodemWyslijFunction>:

  return OK_SILENT;
}

static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
{
    244e:	0f 93       	push	r16
    2450:	1f 93       	push	r17
    2452:	cf 93       	push	r28
    2454:	df 93       	push	r29
    2456:	ec 01       	movw	r28, r24
  fprintf_P(state->myStdInOut, xwyslijStartStr);
    2458:	00 d0       	rcall	.+0      	; 0x245a <goXmodemWyslijFunction+0xc>
    245a:	0f 92       	push	r0
    245c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    245e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2460:	ad b7       	in	r26, 0x3d	; 61
    2462:	be b7       	in	r27, 0x3e	; 62
    2464:	11 96       	adiw	r26, 0x01	; 1
    2466:	8d 93       	st	X+, r24
    2468:	9c 93       	st	X, r25
    246a:	12 97       	sbiw	r26, 0x02	; 2
    246c:	8a ee       	ldi	r24, 0xEA	; 234
    246e:	94 e0       	ldi	r25, 0x04	; 4
    2470:	13 96       	adiw	r26, 0x03	; 3
    2472:	8d 93       	st	X+, r24
    2474:	9c 93       	st	X, r25
    2476:	14 97       	sbiw	r26, 0x04	; 4
    2478:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    247c:	0f 90       	pop	r0
    247e:	0f 90       	pop	r0
    2480:	0f 90       	pop	r0
    2482:	0f 90       	pop	r0
    2484:	81 e0       	ldi	r24, 0x01	; 1
    2486:	be 01       	movw	r22, r28
    2488:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    248c:	68 ec       	ldi	r22, 0xC8	; 200
    248e:	72 e3       	ldi	r23, 0x32	; 50
    2490:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <ramDyskOtworzPlik>
    2494:	88 23       	and	r24, r24
    2496:	09 f1       	breq	.+66     	; 0x24da <goXmodemWyslijFunction+0x8c>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2498:	0a 8d       	ldd	r16, Y+26	; 0x1a
    249a:	1b 8d       	ldd	r17, Y+27	; 0x1b
    249c:	81 e0       	ldi	r24, 0x01	; 1
    249e:	be 01       	movw	r22, r28
    24a0:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    24a4:	00 d0       	rcall	.+0      	; 0x24a6 <goXmodemWyslijFunction+0x58>
    24a6:	00 d0       	rcall	.+0      	; 0x24a8 <goXmodemWyslijFunction+0x5a>
    24a8:	ed b7       	in	r30, 0x3d	; 61
    24aa:	fe b7       	in	r31, 0x3e	; 62
    24ac:	31 96       	adiw	r30, 0x01	; 1
    24ae:	ad b7       	in	r26, 0x3d	; 61
    24b0:	be b7       	in	r27, 0x3e	; 62
    24b2:	11 96       	adiw	r26, 0x01	; 1
    24b4:	0d 93       	st	X+, r16
    24b6:	1c 93       	st	X, r17
    24b8:	12 97       	sbiw	r26, 0x02	; 2
    24ba:	2a ee       	ldi	r18, 0xEA	; 234
    24bc:	32 e0       	ldi	r19, 0x02	; 2
    24be:	22 83       	std	Z+2, r18	; 0x02
    24c0:	33 83       	std	Z+3, r19	; 0x03
    24c2:	84 83       	std	Z+4, r24	; 0x04
    24c4:	95 83       	std	Z+5, r25	; 0x05
    24c6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    return ERROR_INFORM;
    24ca:	ed b7       	in	r30, 0x3d	; 61
    24cc:	fe b7       	in	r31, 0x3e	; 62
    24ce:	36 96       	adiw	r30, 0x06	; 6
    24d0:	ed bf       	out	0x3d, r30	; 61
    24d2:	fe bf       	out	0x3e, r31	; 62
    24d4:	24 e0       	ldi	r18, 0x04	; 4
    24d6:	30 e0       	ldi	r19, 0x00	; 0
    24d8:	02 c0       	rjmp	.+4      	; 0x24de <goXmodemWyslijFunction+0x90>
  }
  return OK_SILENT;
    24da:	20 e0       	ldi	r18, 0x00	; 0
    24dc:	30 e0       	ldi	r19, 0x00	; 0
}
    24de:	c9 01       	movw	r24, r18
    24e0:	df 91       	pop	r29
    24e2:	cf 91       	pop	r28
    24e4:	1f 91       	pop	r17
    24e6:	0f 91       	pop	r16
    24e8:	08 95       	ret

000024ea <editRamFileFunction>:
  ramDyskDir(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t editRamFileFunction(cmdState_t *state)
{
    24ea:	ef 92       	push	r14
    24ec:	ff 92       	push	r15
    24ee:	0f 93       	push	r16
    24f0:	1f 93       	push	r17
    24f2:	df 93       	push	r29
    24f4:	cf 93       	push	r28
    24f6:	0f 92       	push	r0
    24f8:	cd b7       	in	r28, 0x3d	; 61
    24fa:	de b7       	in	r29, 0x3e	; 62
    24fc:	8c 01       	movw	r16, r24
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    24fe:	81 e0       	ldi	r24, 0x01	; 1
    2500:	b8 01       	movw	r22, r16
    2502:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2506:	68 ec       	ldi	r22, 0xC8	; 200
    2508:	72 e3       	ldi	r23, 0x32	; 50
    250a:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <ramDyskOtworzPlik>
    250e:	88 23       	and	r24, r24
    2510:	21 f1       	breq	.+72     	; 0x255a <editRamFileFunction+0x70>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2512:	d8 01       	movw	r26, r16
    2514:	5a 96       	adiw	r26, 0x1a	; 26
    2516:	ed 90       	ld	r14, X+
    2518:	fc 90       	ld	r15, X
    251a:	5b 97       	sbiw	r26, 0x1b	; 27
    251c:	81 e0       	ldi	r24, 0x01	; 1
    251e:	b8 01       	movw	r22, r16
    2520:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2524:	00 d0       	rcall	.+0      	; 0x2526 <editRamFileFunction+0x3c>
    2526:	00 d0       	rcall	.+0      	; 0x2528 <editRamFileFunction+0x3e>
    2528:	ed b7       	in	r30, 0x3d	; 61
    252a:	fe b7       	in	r31, 0x3e	; 62
    252c:	31 96       	adiw	r30, 0x01	; 1
    252e:	ad b7       	in	r26, 0x3d	; 61
    2530:	be b7       	in	r27, 0x3e	; 62
    2532:	11 96       	adiw	r26, 0x01	; 1
    2534:	ed 92       	st	X+, r14
    2536:	fc 92       	st	X, r15
    2538:	12 97       	sbiw	r26, 0x02	; 2
    253a:	2a ee       	ldi	r18, 0xEA	; 234
    253c:	32 e0       	ldi	r19, 0x02	; 2
    253e:	22 83       	std	Z+2, r18	; 0x02
    2540:	33 83       	std	Z+3, r19	; 0x03
    2542:	84 83       	std	Z+4, r24	; 0x04
    2544:	95 83       	std	Z+5, r25	; 0x05
    2546:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    return ERROR_INFORM;
    254a:	ed b7       	in	r30, 0x3d	; 61
    254c:	fe b7       	in	r31, 0x3e	; 62
    254e:	36 96       	adiw	r30, 0x06	; 6
    2550:	ed bf       	out	0x3d, r30	; 61
    2552:	fe bf       	out	0x3e, r31	; 62
    2554:	24 e0       	ldi	r18, 0x04	; 4
    2556:	30 e0       	ldi	r19, 0x00	; 0
    2558:	3a c0       	rjmp	.+116    	; 0x25ce <editRamFileFunction+0xe4>
  }
  ramDyskUstawWskaznikNaKoniec(&fdVty);
    255a:	88 ec       	ldi	r24, 0xC8	; 200
    255c:	92 e3       	ldi	r25, 0x32	; 50
    255e:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <ramDyskUstawWskaznikNaKoniec>
  uint8_t znak = 0;
    2562:	19 82       	std	Y+1, r1	; 0x01
  fprintf_P(state->myStdInOut, editRamFileIntroStr);
    2564:	00 d0       	rcall	.+0      	; 0x2566 <editRamFileFunction+0x7c>
    2566:	0f 92       	push	r0
    2568:	d8 01       	movw	r26, r16
    256a:	5a 96       	adiw	r26, 0x1a	; 26
    256c:	8d 91       	ld	r24, X+
    256e:	9c 91       	ld	r25, X
    2570:	5b 97       	sbiw	r26, 0x1b	; 27
    2572:	ed b7       	in	r30, 0x3d	; 61
    2574:	fe b7       	in	r31, 0x3e	; 62
    2576:	81 83       	std	Z+1, r24	; 0x01
    2578:	92 83       	std	Z+2, r25	; 0x02
    257a:	80 eb       	ldi	r24, 0xB0	; 176
    257c:	94 e0       	ldi	r25, 0x04	; 4
    257e:	83 83       	std	Z+3, r24	; 0x03
    2580:	94 83       	std	Z+4, r25	; 0x04
    2582:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    2586:	0f 90       	pop	r0
    2588:	0f 90       	pop	r0
    258a:	0f 90       	pop	r0
    258c:	0f 90       	pop	r0
  while(1)
  {
    if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
    258e:	8e 01       	movw	r16, r28
    2590:	0f 5f       	subi	r16, 0xFF	; 255
    2592:	1f 4f       	sbci	r17, 0xFF	; 255
    2594:	80 91 0f 32 	lds	r24, 0x320F
    2598:	90 91 10 32 	lds	r25, 0x3210
    259c:	b8 01       	movw	r22, r16
    259e:	4f ef       	ldi	r20, 0xFF	; 255
    25a0:	5f ef       	ldi	r21, 0xFF	; 255
    25a2:	20 e0       	ldi	r18, 0x00	; 0
    25a4:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    25a8:	88 23       	and	r24, r24
    25aa:	a1 f3       	breq	.-24     	; 0x2594 <editRamFileFunction+0xaa>
      continue;

    if (znak == 0x03)                                       // ^C
    25ac:	89 81       	ldd	r24, Y+1	; 0x01
    25ae:	83 30       	cpi	r24, 0x03	; 3
    25b0:	41 f0       	breq	.+16     	; 0x25c2 <editRamFileFunction+0xd8>
      break;

    uartVtySendByte(znak);                                  //Echo
    25b2:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    ramDyskZapiszBajtDoPliku(&fdVty, znak);
    25b6:	88 ec       	ldi	r24, 0xC8	; 200
    25b8:	92 e3       	ldi	r25, 0x32	; 50
    25ba:	69 81       	ldd	r22, Y+1	; 0x01
    25bc:	0e 94 76 1e 	call	0x3cec	; 0x3cec <ramDyskZapiszBajtDoPliku>
    25c0:	e9 cf       	rjmp	.-46     	; 0x2594 <editRamFileFunction+0xaa>
  }
  ramDyskZamknijPlik(&fdVty);
    25c2:	88 ec       	ldi	r24, 0xC8	; 200
    25c4:	92 e3       	ldi	r25, 0x32	; 50
    25c6:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <ramDyskZamknijPlik>
  return OK_SILENT;
    25ca:	20 e0       	ldi	r18, 0x00	; 0
    25cc:	30 e0       	ldi	r19, 0x00	; 0
}
    25ce:	c9 01       	movw	r24, r18
    25d0:	0f 90       	pop	r0
    25d2:	cf 91       	pop	r28
    25d4:	df 91       	pop	r29
    25d6:	1f 91       	pop	r17
    25d8:	0f 91       	pop	r16
    25da:	ff 90       	pop	r15
    25dc:	ef 90       	pop	r14
    25de:	08 95       	ret

000025e0 <goXmodemOdbierzFunction>:
  }
  return OK_SILENT;
}

static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
{
    25e0:	2f 92       	push	r2
    25e2:	3f 92       	push	r3
    25e4:	4f 92       	push	r4
    25e6:	5f 92       	push	r5
    25e8:	6f 92       	push	r6
    25ea:	7f 92       	push	r7
    25ec:	8f 92       	push	r8
    25ee:	9f 92       	push	r9
    25f0:	af 92       	push	r10
    25f2:	bf 92       	push	r11
    25f4:	cf 92       	push	r12
    25f6:	df 92       	push	r13
    25f8:	ef 92       	push	r14
    25fa:	ff 92       	push	r15
    25fc:	0f 93       	push	r16
    25fe:	1f 93       	push	r17
    2600:	df 93       	push	r29
    2602:	cf 93       	push	r28
    2604:	cd b7       	in	r28, 0x3d	; 61
    2606:	de b7       	in	r29, 0x3e	; 62
    2608:	27 97       	sbiw	r28, 0x07	; 7
    260a:	cd bf       	out	0x3d, r28	; 61
    260c:	de bf       	out	0x3e, r29	; 62
    260e:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
    2610:	00 d0       	rcall	.+0      	; 0x2612 <goXmodemOdbierzFunction+0x32>
    2612:	0f 92       	push	r0
    2614:	dc 01       	movw	r26, r24
    2616:	5a 96       	adiw	r26, 0x1a	; 26
    2618:	8d 91       	ld	r24, X+
    261a:	9c 91       	ld	r25, X
    261c:	5b 97       	sbiw	r26, 0x1b	; 27
    261e:	ed b7       	in	r30, 0x3d	; 61
    2620:	fe b7       	in	r31, 0x3e	; 62
    2622:	81 83       	std	Z+1, r24	; 0x01
    2624:	92 83       	std	Z+2, r25	; 0x02
    2626:	8f e3       	ldi	r24, 0x3F	; 63
    2628:	97 e0       	ldi	r25, 0x07	; 7
    262a:	83 83       	std	Z+3, r24	; 0x03
    262c:	94 83       	std	Z+4, r25	; 0x04
    262e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    2632:	0f 90       	pop	r0
    2634:	0f 90       	pop	r0
    2636:	0f 90       	pop	r0
    2638:	0f 90       	pop	r0
    263a:	81 e0       	ldi	r24, 0x01	; 1
    263c:	b8 01       	movw	r22, r16
    263e:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2642:	68 ec       	ldi	r22, 0xC8	; 200
    2644:	72 e3       	ldi	r23, 0x32	; 50
    2646:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <ramDyskOtworzPlik>
    264a:	88 23       	and	r24, r24
    264c:	11 f1       	breq	.+68     	; 0x2692 <goXmodemOdbierzFunction+0xb2>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    264e:	d8 01       	movw	r26, r16
    2650:	5a 96       	adiw	r26, 0x1a	; 26
    2652:	ed 90       	ld	r14, X+
    2654:	fc 90       	ld	r15, X
    2656:	5b 97       	sbiw	r26, 0x1b	; 27
    2658:	81 e0       	ldi	r24, 0x01	; 1
    265a:	b8 01       	movw	r22, r16
    265c:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2660:	00 d0       	rcall	.+0      	; 0x2662 <goXmodemOdbierzFunction+0x82>
    2662:	00 d0       	rcall	.+0      	; 0x2664 <goXmodemOdbierzFunction+0x84>
    2664:	ed b7       	in	r30, 0x3d	; 61
    2666:	fe b7       	in	r31, 0x3e	; 62
    2668:	31 96       	adiw	r30, 0x01	; 1
    266a:	ad b7       	in	r26, 0x3d	; 61
    266c:	be b7       	in	r27, 0x3e	; 62
    266e:	11 96       	adiw	r26, 0x01	; 1
    2670:	ed 92       	st	X+, r14
    2672:	fc 92       	st	X, r15
    2674:	12 97       	sbiw	r26, 0x02	; 2
    2676:	2a ee       	ldi	r18, 0xEA	; 234
    2678:	32 e0       	ldi	r19, 0x02	; 2
    267a:	22 83       	std	Z+2, r18	; 0x02
    267c:	33 83       	std	Z+3, r19	; 0x03
    267e:	84 83       	std	Z+4, r24	; 0x04
    2680:	95 83       	std	Z+5, r25	; 0x05
    2682:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    return ERROR_INFORM;
    2686:	ed b7       	in	r30, 0x3d	; 61
    2688:	fe b7       	in	r31, 0x3e	; 62
    268a:	36 96       	adiw	r30, 0x06	; 6
    268c:	ed bf       	out	0x3d, r30	; 61
    268e:	fe bf       	out	0x3e, r31	; 62
    2690:	32 c0       	rjmp	.+100    	; 0x26f6 <goXmodemOdbierzFunction+0x116>
  uint8_t nrBlokuZdalnyNeg;

  uint8_t crcHi;
  uint8_t crcLo;

  state->err1=0;
    2692:	d8 01       	movw	r26, r16
    2694:	5d 96       	adiw	r26, 0x1d	; 29
    2696:	1d 92       	st	X+, r1
    2698:	1c 92       	st	X, r1
    269a:	5e 97       	sbiw	r26, 0x1e	; 30
  state->err2=0;
    269c:	5f 96       	adiw	r26, 0x1f	; 31
    269e:	1c 92       	st	X, r1
  liczbaProb = 20;
    26a0:	84 e1       	ldi	r24, 0x14	; 20
    26a2:	d8 2e       	mov	r13, r24
  {
    fputc('C'              , state->myStdInOut);
   // while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
//od usartD0
    while(!(USARTD0.STATUS & USART_TXCIF_bm));
    if(xQueueReceive(xVtyRec, &c, 100))
    26a4:	b2 e0       	ldi	r27, 0x02	; 2
    26a6:	eb 2e       	mov	r14, r27
    26a8:	f1 2c       	mov	r15, r1
    26aa:	ec 0e       	add	r14, r28
    26ac:	fd 1e       	adc	r15, r29
  state->err1=0;
  state->err2=0;
  liczbaProb = 20;
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    26ae:	f8 01       	movw	r30, r16
    26b0:	62 8d       	ldd	r22, Z+26	; 0x1a
    26b2:	73 8d       	ldd	r23, Z+27	; 0x1b
    26b4:	83 e4       	ldi	r24, 0x43	; 67
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
   // while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
//od usartD0
    while(!(USARTD0.STATUS & USART_TXCIF_bm));
    26bc:	80 91 a1 09 	lds	r24, 0x09A1
    26c0:	86 ff       	sbrs	r24, 6
    26c2:	fc cf       	rjmp	.-8      	; 0x26bc <goXmodemOdbierzFunction+0xdc>
    if(xQueueReceive(xVtyRec, &c, 100))
    26c4:	80 91 0f 32 	lds	r24, 0x320F
    26c8:	90 91 10 32 	lds	r25, 0x3210
    26cc:	b7 01       	movw	r22, r14
    26ce:	44 e6       	ldi	r20, 0x64	; 100
    26d0:	50 e0       	ldi	r21, 0x00	; 0
    26d2:	20 e0       	ldi	r18, 0x00	; 0
    26d4:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    26d8:	88 23       	and	r24, r24
    26da:	19 f0       	breq	.+6      	; 0x26e2 <goXmodemOdbierzFunction+0x102>
      if (c == SOH)
    26dc:	8a 81       	ldd	r24, Y+2	; 0x02
    26de:	81 30       	cpi	r24, 0x01	; 1
    26e0:	69 f0       	breq	.+26     	; 0x26fc <goXmodemOdbierzFunction+0x11c>
        break;                                                   //Rozpoczynamy transmisje

    liczbaProb--;
    26e2:	da 94       	dec	r13
    if (liczbaProb == 0)
    26e4:	21 f7       	brne	.-56     	; 0x26ae <goXmodemOdbierzFunction+0xce>
    {
      ramDyskZamknijPlik(&fdVty);
    26e6:	88 ec       	ldi	r24, 0xC8	; 200
    26e8:	92 e3       	ldi	r25, 0x32	; 50
    26ea:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <ramDyskZamknijPlik>
      state->errno = (uint8_t)(AllOK);
    26ee:	d8 01       	movw	r26, r16
    26f0:	5c 96       	adiw	r26, 0x1c	; 28
    26f2:	1c 92       	st	X, r1
    26f4:	5c 97       	sbiw	r26, 0x1c	; 28
      return ERROR_INFORM;
    26f6:	24 e0       	ldi	r18, 0x04	; 4
    26f8:	30 e0       	ldi	r19, 0x00	; 0
    26fa:	4e c1       	rjmp	.+668    	; 0x2998 <goXmodemOdbierzFunction+0x3b8>
  }
  
  nrBloku = 1;
  liczbaProb = 10;

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    26fc:	88 ec       	ldi	r24, 0xC8	; 200
    26fe:	92 e3       	ldi	r25, 0x32	; 50
    2700:	61 e0       	ldi	r22, 0x01	; 1
    2702:	70 e0       	ldi	r23, 0x00	; 0
    2704:	0e 94 9e 20 	call	0x413c	; 0x413c <ramDyskDodajBlokXmodem>
    2708:	6c 01       	movw	r12, r24
      state->errno = (uint8_t)(AllOK);
      return ERROR_INFORM;
    }
  }
  
  nrBloku = 1;
    270a:	ee 24       	eor	r14, r14
    270c:	e3 94       	inc	r14
  liczbaProb = 10;
    270e:	aa e0       	ldi	r26, 0x0A	; 10
    2710:	ba 2e       	mov	r11, r26

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    2712:	f3 e0       	ldi	r31, 0x03	; 3
    2714:	4f 2e       	mov	r4, r31
    2716:	51 2c       	mov	r5, r1
    2718:	4c 0e       	add	r4, r28
    271a:	5d 1e       	adc	r5, r29
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    271c:	e4 e0       	ldi	r30, 0x04	; 4
    271e:	2e 2e       	mov	r2, r30
    2720:	31 2c       	mov	r3, r1
    2722:	2c 0e       	add	r2, r28
    2724:	3d 1e       	adc	r3, r29
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2726:	73 e0       	ldi	r23, 0x03	; 3
    2728:	a7 2e       	mov	r10, r23
      state->err2 = nrBloku;
      state->errno = (uint8_t)(xModemWrongFrameNo);
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    272a:	3e 01       	movw	r6, r28
    272c:	08 94       	sec
    272e:	61 1c       	adc	r6, r1
    2730:	71 1c       	adc	r7, r1

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    2732:	80 91 0f 32 	lds	r24, 0x320F
    2736:	90 91 10 32 	lds	r25, 0x3210
    273a:	b2 01       	movw	r22, r4
    273c:	44 e6       	ldi	r20, 0x64	; 100
    273e:	50 e0       	ldi	r21, 0x00	; 0
    2740:	20 e0       	ldi	r18, 0x00	; 0
    2742:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    2746:	88 23       	and	r24, r24
    2748:	19 f4       	brne	.+6      	; 0x2750 <goXmodemOdbierzFunction+0x170>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    274a:	82 e0       	ldi	r24, 0x02	; 2
    274c:	f8 01       	movw	r30, r16
    274e:	cc c0       	rjmp	.+408    	; 0x28e8 <goXmodemOdbierzFunction+0x308>
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    2750:	80 91 0f 32 	lds	r24, 0x320F
    2754:	90 91 10 32 	lds	r25, 0x3210
    2758:	b1 01       	movw	r22, r2
    275a:	41 e0       	ldi	r20, 0x01	; 1
    275c:	50 e0       	ldi	r21, 0x00	; 0
    275e:	20 e0       	ldi	r18, 0x00	; 0
    2760:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    2764:	88 23       	and	r24, r24
    2766:	11 f4       	brne	.+4      	; 0x276c <goXmodemOdbierzFunction+0x18c>
    {
      state->errno = (uint8_t)(xModemByteSendTimeout);
    2768:	83 e0       	ldi	r24, 0x03	; 3
    276a:	cd c0       	rjmp	.+410    	; 0x2906 <goXmodemOdbierzFunction+0x326>
      break; 
    }
  
    //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
    c = 255-nrBlokuZdalnyNeg;
    276c:	8c 81       	ldd	r24, Y+4	; 0x04
    276e:	98 2f       	mov	r25, r24
    2770:	90 95       	com	r25
    2772:	9a 83       	std	Y+2, r25	; 0x02
    if (nrBlokuZdalny != c)
    2774:	fb 80       	ldd	r15, Y+3	; 0x03
    2776:	f9 16       	cp	r15, r25
    2778:	39 f0       	breq	.+14     	; 0x2788 <goXmodemOdbierzFunction+0x1a8>
    {
      state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
    277a:	95 e0       	ldi	r25, 0x05	; 5
    277c:	f8 01       	movw	r30, r16
    277e:	94 8f       	std	Z+28, r25	; 0x1c
      state->err1 = nrBlokuZdalny;
    2780:	f5 8e       	std	Z+29, r15	; 0x1d
    2782:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBlokuZdalnyNeg;
    2784:	87 8f       	std	Z+31, r24	; 0x1f
      break;
    2786:	02 c1       	rjmp	.+516    	; 0x298c <goXmodemOdbierzFunction+0x3ac>
    }
    
    //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od bloku 0
    c = nrBloku-1;
    2788:	8e 2d       	mov	r24, r14
    278a:	81 50       	subi	r24, 0x01	; 1
    278c:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny == c)
    278e:	f8 16       	cp	r15, r24
    2790:	41 f4       	brne	.+16     	; 0x27a2 <goXmodemOdbierzFunction+0x1c2>
    {
      nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2792:	88 ec       	ldi	r24, 0xC8	; 200
    2794:	92 e3       	ldi	r25, 0x32	; 50
    2796:	6f 2d       	mov	r22, r15
    2798:	70 e0       	ldi	r23, 0x00	; 0
    279a:	0e 94 9e 20 	call	0x413c	; 0x413c <ramDyskDodajBlokXmodem>
    279e:	6c 01       	movw	r12, r24
    27a0:	ef 2c       	mov	r14, r15
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    27a2:	fb 80       	ldd	r15, Y+3	; 0x03
    27a4:	fe 14       	cp	r15, r14
    27a6:	81 f0       	breq	.+32     	; 0x27c8 <goXmodemOdbierzFunction+0x1e8>
    {
      state->errno = (uint8_t)(xModemWrongFrameNo);
    27a8:	84 e0       	ldi	r24, 0x04	; 4
    27aa:	d8 01       	movw	r26, r16
    27ac:	5c 96       	adiw	r26, 0x1c	; 28
    27ae:	8c 93       	st	X, r24
    27b0:	5c 97       	sbiw	r26, 0x1c	; 28
      state->err1 = nrBlokuZdalnyNeg;
    27b2:	8c 81       	ldd	r24, Y+4	; 0x04
    27b4:	5d 96       	adiw	r26, 0x1d	; 29
    27b6:	8c 93       	st	X, r24
    27b8:	5d 97       	sbiw	r26, 0x1d	; 29
    27ba:	5e 96       	adiw	r26, 0x1e	; 30
    27bc:	1c 92       	st	X, r1
    27be:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    27c0:	5f 96       	adiw	r26, 0x1f	; 31
    27c2:	ec 92       	st	X, r14
    27c4:	5f 97       	sbiw	r26, 0x1f	; 31
      break;
    27c6:	e2 c0       	rjmp	.+452    	; 0x298c <goXmodemOdbierzFunction+0x3ac>
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    27c8:	8c 2c       	mov	r8, r12
    27ca:	9d 2c       	mov	r9, r13
    27cc:	30 e0       	ldi	r19, 0x00	; 0
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    {
      if(xQueueReceive(xVtyRec, &c, 10))
    27ce:	80 91 0f 32 	lds	r24, 0x320F
    27d2:	90 91 10 32 	lds	r25, 0x3210
    27d6:	be 01       	movw	r22, r28
    27d8:	6e 5f       	subi	r22, 0xFE	; 254
    27da:	7f 4f       	sbci	r23, 0xFF	; 255
    27dc:	4a e0       	ldi	r20, 0x0A	; 10
    27de:	50 e0       	ldi	r21, 0x00	; 0
    27e0:	20 e0       	ldi	r18, 0x00	; 0
    27e2:	3f 83       	std	Y+7, r19	; 0x07
    27e4:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    27e8:	3f 81       	ldd	r19, Y+7	; 0x07
    27ea:	88 23       	and	r24, r24
    27ec:	41 f0       	breq	.+16     	; 0x27fe <goXmodemOdbierzFunction+0x21e>
        *(zapPtr++) = c;
    27ee:	8a 81       	ldd	r24, Y+2	; 0x02
    27f0:	f4 01       	movw	r30, r8
    27f2:	81 93       	st	Z+, r24
    27f4:	4f 01       	movw	r8, r30
      state->err1 = nrBlokuZdalnyNeg;
      state->err2 = nrBloku;
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    27f6:	3f 5f       	subi	r19, 0xFF	; 255
    27f8:	30 38       	cpi	r19, 0x80	; 128
    27fa:	49 f7       	brne	.-46     	; 0x27ce <goXmodemOdbierzFunction+0x1ee>
    27fc:	03 c0       	rjmp	.+6      	; 0x2804 <goXmodemOdbierzFunction+0x224>
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    27fe:	d8 01       	movw	r26, r16
    2800:	5c 96       	adiw	r26, 0x1c	; 28
    2802:	ac 92       	st	X, r10
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    2804:	80 91 0f 32 	lds	r24, 0x320F
    2808:	90 91 10 32 	lds	r25, 0x3210
    280c:	be 01       	movw	r22, r28
    280e:	6b 5f       	subi	r22, 0xFB	; 251
    2810:	7f 4f       	sbci	r23, 0xFF	; 255
    2812:	4a e0       	ldi	r20, 0x0A	; 10
    2814:	50 e0       	ldi	r21, 0x00	; 0
    2816:	20 e0       	ldi	r18, 0x00	; 0
    2818:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    281c:	88 23       	and	r24, r24
    281e:	41 f4       	brne	.+16     	; 0x2830 <goXmodemOdbierzFunction+0x250>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2820:	86 e0       	ldi	r24, 0x06	; 6
    2822:	f8 01       	movw	r30, r16
    2824:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 2;
    2826:	82 e0       	ldi	r24, 0x02	; 2
    2828:	90 e0       	ldi	r25, 0x00	; 0
    282a:	85 8f       	std	Z+29, r24	; 0x1d
    282c:	96 8f       	std	Z+30, r25	; 0x1e
        break;      
    282e:	ae c0       	rjmp	.+348    	; 0x298c <goXmodemOdbierzFunction+0x3ac>
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    2830:	80 91 0f 32 	lds	r24, 0x320F
    2834:	90 91 10 32 	lds	r25, 0x3210
    2838:	be 01       	movw	r22, r28
    283a:	6a 5f       	subi	r22, 0xFA	; 250
    283c:	7f 4f       	sbci	r23, 0xFF	; 255
    283e:	4a e0       	ldi	r20, 0x0A	; 10
    2840:	50 e0       	ldi	r21, 0x00	; 0
    2842:	20 e0       	ldi	r18, 0x00	; 0
    2844:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    2848:	88 23       	and	r24, r24
    284a:	61 f4       	brne	.+24     	; 0x2864 <goXmodemOdbierzFunction+0x284>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    284c:	86 e0       	ldi	r24, 0x06	; 6
    284e:	d8 01       	movw	r26, r16
    2850:	5c 96       	adiw	r26, 0x1c	; 28
    2852:	8c 93       	st	X, r24
    2854:	5c 97       	sbiw	r26, 0x1c	; 28
        state->err1 = 1;
    2856:	81 e0       	ldi	r24, 0x01	; 1
    2858:	90 e0       	ldi	r25, 0x00	; 0
    285a:	5d 96       	adiw	r26, 0x1d	; 29
    285c:	8d 93       	st	X+, r24
    285e:	9c 93       	st	X, r25
    2860:	5e 97       	sbiw	r26, 0x1e	; 30
        break;      
    2862:	94 c0       	rjmp	.+296    	; 0x298c <goXmodemOdbierzFunction+0x3ac>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
        state->err1 = 2;
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    2864:	ec 2d       	mov	r30, r12
    2866:	fd 2d       	mov	r31, r13
    2868:	80 e0       	ldi	r24, 0x00	; 0
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	20 e0       	ldi	r18, 0x00	; 0
    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
    286e:	31 91       	ld	r19, Z+
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    2870:	93 27       	eor	r25, r19
    2872:	09 2e       	mov	r0, r25
    2874:	02 94       	swap	r0
    2876:	30 2d       	mov	r19, r0
    2878:	3f 70       	andi	r19, 0x0F	; 15
    287a:	39 27       	eor	r19, r25
    287c:	49 2f       	mov	r20, r25
    287e:	40 25       	eor	r20, r0
    2880:	44 0f       	add	r20, r20
    2882:	40 7e       	andi	r20, 0xE0	; 224
    2884:	34 27       	eor	r19, r20
    2886:	40 2d       	mov	r20, r0
    2888:	49 27       	eor	r20, r25
    288a:	40 7f       	andi	r20, 0xF0	; 240
    288c:	46 95       	lsr	r20
    288e:	09 2e       	mov	r0, r25
    2890:	00 0c       	add	r0, r0
    2892:	44 1f       	adc	r20, r20
    2894:	96 95       	lsr	r25
    2896:	96 95       	lsr	r25
    2898:	96 95       	lsr	r25
    289a:	9f 71       	andi	r25, 0x1F	; 31
    289c:	94 27       	eor	r25, r20
    289e:	98 27       	eor	r25, r24
    28a0:	83 2f       	mov	r24, r19

    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    28a2:	2f 5f       	subi	r18, 0xFF	; 255
    28a4:	20 38       	cpi	r18, 0x80	; 128
    28a6:	19 f7       	brne	.-58     	; 0x286e <goXmodemOdbierzFunction+0x28e>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    28a8:	4d 81       	ldd	r20, Y+5	; 0x05
    28aa:	50 e0       	ldi	r21, 0x00	; 0
    28ac:	29 2f       	mov	r18, r25
    28ae:	33 27       	eor	r19, r19
    28b0:	42 17       	cp	r20, r18
    28b2:	53 07       	cpc	r21, r19
    28b4:	61 f4       	brne	.+24     	; 0x28ce <goXmodemOdbierzFunction+0x2ee>
    28b6:	2e 81       	ldd	r18, Y+6	; 0x06
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	90 70       	andi	r25, 0x00	; 0
    28bc:	28 17       	cp	r18, r24
    28be:	39 07       	cpc	r19, r25
    28c0:	31 f4       	brne	.+12     	; 0x28ce <goXmodemOdbierzFunction+0x2ee>
    {
      liczbaProb = 10;
      uartVtySendByte(ACK);      
    28c2:	86 e0       	ldi	r24, 0x06	; 6
    28c4:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    {
      liczbaProb = 10;
    28c8:	3a e0       	ldi	r19, 0x0A	; 10
    28ca:	b3 2e       	mov	r11, r19
    28cc:	0f c0       	rjmp	.+30     	; 0x28ec <goXmodemOdbierzFunction+0x30c>
      uartVtySendByte(ACK);      
    }
    else
    {
      liczbaProb--;
    28ce:	ba 94       	dec	r11
      nrBloku--;
    28d0:	fa 94       	dec	r15
      uartVtySendByte(NAK);   
    28d2:	85 e1       	ldi	r24, 0x15	; 21
    28d4:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    }
    
    if (liczbaProb == 0)
    28d8:	bb 20       	and	r11, r11
    28da:	41 f4       	brne	.+16     	; 0x28ec <goXmodemOdbierzFunction+0x30c>
    {
      state->err1 = nrBlokuZdalny;
    28dc:	8b 81       	ldd	r24, Y+3	; 0x03
    28de:	f8 01       	movw	r30, r16
    28e0:	85 8f       	std	Z+29, r24	; 0x1d
    28e2:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBloku;
    28e4:	f7 8e       	std	Z+31, r15	; 0x1f
      state->errno = (uint8_t)(xModemWrongFrameNo);
    28e6:	84 e0       	ldi	r24, 0x04	; 4
    28e8:	84 8f       	std	Z+28, r24	; 0x1c
      break; 
    28ea:	50 c0       	rjmp	.+160    	; 0x298c <goXmodemOdbierzFunction+0x3ac>
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    28ec:	80 91 0f 32 	lds	r24, 0x320F
    28f0:	90 91 10 32 	lds	r25, 0x3210
    28f4:	b3 01       	movw	r22, r6
    28f6:	44 e6       	ldi	r20, 0x64	; 100
    28f8:	50 e0       	ldi	r21, 0x00	; 0
    28fa:	20 e0       	ldi	r18, 0x00	; 0
    28fc:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    2900:	88 23       	and	r24, r24
    2902:	31 f4       	brne	.+12     	; 0x2910 <goXmodemOdbierzFunction+0x330>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    2904:	82 e0       	ldi	r24, 0x02	; 2
    2906:	d8 01       	movw	r26, r16
    2908:	5c 96       	adiw	r26, 0x1c	; 28
    290a:	8c 93       	st	X, r24
    290c:	5c 97       	sbiw	r26, 0x1c	; 28
      break;
    290e:	3e c0       	rjmp	.+124    	; 0x298c <goXmodemOdbierzFunction+0x3ac>
    }
    
    if (temp1 == SOH)
    2910:	89 81       	ldd	r24, Y+1	; 0x01
    2912:	81 30       	cpi	r24, 0x01	; 1
    2914:	61 f4       	brne	.+24     	; 0x292e <goXmodemOdbierzFunction+0x34e>
    {
      nrBloku++;
    2916:	ef 2c       	mov	r14, r15
    2918:	e3 94       	inc	r14
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    291a:	88 ec       	ldi	r24, 0xC8	; 200
    291c:	92 e3       	ldi	r25, 0x32	; 50
    291e:	6e 2d       	mov	r22, r14
    2920:	70 e0       	ldi	r23, 0x00	; 0
    2922:	0e 94 9e 20 	call	0x413c	; 0x413c <ramDyskDodajBlokXmodem>
    2926:	6c 01       	movw	r12, r24
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
    2928:	f8 01       	movw	r30, r16
    292a:	14 8e       	std	Z+28, r1	; 0x1c
      break;
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    state->err1 = temp1;
    break;
  }
    292c:	02 cf       	rjmp	.-508    	; 0x2732 <goXmodemOdbierzFunction+0x152>
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
      continue;
    }

    if (temp1 == CAN)
    292e:	88 31       	cpi	r24, 0x18	; 24
    2930:	49 f4       	brne	.+18     	; 0x2944 <goXmodemOdbierzFunction+0x364>
    {
      state->err1 = nrBloku;
    2932:	d8 01       	movw	r26, r16
    2934:	5d 96       	adiw	r26, 0x1d	; 29
    2936:	fc 92       	st	X, r15
    2938:	5d 97       	sbiw	r26, 0x1d	; 29
    293a:	5e 96       	adiw	r26, 0x1e	; 30
    293c:	1c 92       	st	X, r1
    293e:	5e 97       	sbiw	r26, 0x1e	; 30
      state->errno = (uint8_t)(xModemRemoteSideCan);
    2940:	87 e0       	ldi	r24, 0x07	; 7
    2942:	e2 cf       	rjmp	.-60     	; 0x2908 <goXmodemOdbierzFunction+0x328>
      break;
    }
    if (temp1 == EOT)
    2944:	84 30       	cpi	r24, 0x04	; 4
    2946:	c1 f4       	brne	.+48     	; 0x2978 <goXmodemOdbierzFunction+0x398>
    {
      uartVtySendByte(NAK);
    2948:	85 e1       	ldi	r24, 0x15	; 21
    294a:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
      if (xQueueReceive(xVtyRec, &temp1, 10))
    294e:	80 91 0f 32 	lds	r24, 0x320F
    2952:	90 91 10 32 	lds	r25, 0x3210
    2956:	b3 01       	movw	r22, r6
    2958:	4a e0       	ldi	r20, 0x0A	; 10
    295a:	50 e0       	ldi	r21, 0x00	; 0
    295c:	20 e0       	ldi	r18, 0x00	; 0
    295e:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    2962:	88 23       	and	r24, r24
    2964:	31 f0       	breq	.+12     	; 0x2972 <goXmodemOdbierzFunction+0x392>
      {
        if (temp1 == EOT)
    2966:	89 81       	ldd	r24, Y+1	; 0x01
    2968:	84 30       	cpi	r24, 0x04	; 4
    296a:	19 f4       	brne	.+6      	; 0x2972 <goXmodemOdbierzFunction+0x392>
          uartVtySendByte(ACK);  
    296c:	86 e0       	ldi	r24, 0x06	; 6
    296e:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
      }
      state->errno = (uint8_t)(AllOK);
    2972:	f8 01       	movw	r30, r16
    2974:	14 8e       	std	Z+28, r1	; 0x1c
      break;
    2976:	0a c0       	rjmp	.+20     	; 0x298c <goXmodemOdbierzFunction+0x3ac>
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    2978:	98 e0       	ldi	r25, 0x08	; 8
    297a:	d8 01       	movw	r26, r16
    297c:	5c 96       	adiw	r26, 0x1c	; 28
    297e:	9c 93       	st	X, r25
    2980:	5c 97       	sbiw	r26, 0x1c	; 28
    state->err1 = temp1;
    2982:	5d 96       	adiw	r26, 0x1d	; 29
    2984:	8c 93       	st	X, r24
    2986:	5d 97       	sbiw	r26, 0x1d	; 29
    2988:	5e 96       	adiw	r26, 0x1e	; 30
    298a:	1c 92       	st	X, r1
    break;
  }
  ramDyskZamknijPlik(&fdVty);
    298c:	88 ec       	ldi	r24, 0xC8	; 200
    298e:	92 e3       	ldi	r25, 0x32	; 50
    2990:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <ramDyskZamknijPlik>
  return OK_SILENT;
    2994:	20 e0       	ldi	r18, 0x00	; 0
    2996:	30 e0       	ldi	r19, 0x00	; 0
}
    2998:	c9 01       	movw	r24, r18
    299a:	27 96       	adiw	r28, 0x07	; 7
    299c:	cd bf       	out	0x3d, r28	; 61
    299e:	de bf       	out	0x3e, r29	; 62
    29a0:	cf 91       	pop	r28
    29a2:	df 91       	pop	r29
    29a4:	1f 91       	pop	r17
    29a6:	0f 91       	pop	r16
    29a8:	ff 90       	pop	r15
    29aa:	ef 90       	pop	r14
    29ac:	df 90       	pop	r13
    29ae:	cf 90       	pop	r12
    29b0:	bf 90       	pop	r11
    29b2:	af 90       	pop	r10
    29b4:	9f 90       	pop	r9
    29b6:	8f 90       	pop	r8
    29b8:	7f 90       	pop	r7
    29ba:	6f 90       	pop	r6
    29bc:	5f 90       	pop	r5
    29be:	4f 90       	pop	r4
    29c0:	3f 90       	pop	r3
    29c2:	2f 90       	pop	r2
    29c4:	08 95       	ret

000029c6 <debugFunction>:
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
  return OK_SILENT;
}

static cliExRes_t debugFunction          (cmdState_t *state)
{
    29c6:	ff 92       	push	r15
    29c8:	0f 93       	push	r16
    29ca:	1f 93       	push	r17
    29cc:	cf 93       	push	r28
    29ce:	df 93       	push	r29
    29d0:	8c 01       	movw	r16, r24
  if (state->argc < 2)
    29d2:	dc 01       	movw	r26, r24
    29d4:	59 96       	adiw	r26, 0x19	; 25
    29d6:	8c 91       	ld	r24, X
    29d8:	59 97       	sbiw	r26, 0x19	; 25
    29da:	82 30       	cpi	r24, 0x02	; 2
    29dc:	08 f4       	brcc	.+2      	; 0x29e0 <debugFunction+0x1a>
    29de:	e2 c0       	rjmp	.+452    	; 0x2ba4 <debugFunction+0x1de>
    return SYNTAX_ERROR;

  uint8_t level = cmdlineGetArgInt(2, state);
    29e0:	82 e0       	ldi	r24, 0x02	; 2
    29e2:	b8 01       	movw	r22, r16
    29e4:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    29e8:	f6 2e       	mov	r15, r22
  const char *str = (const char*)cmdlineGetArgStr(1, state);
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	b8 01       	movw	r22, r16
    29ee:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    29f2:	ec 01       	movw	r28, r24
  if (level == 0)
    29f4:	ff 20       	and	r15, r15
    29f6:	09 f0       	breq	.+2      	; 0x29fa <debugFunction+0x34>
    29f8:	5d c0       	rjmp	.+186    	; 0x2ab4 <debugFunction+0xee>
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    29fa:	63 e8       	ldi	r22, 0x83	; 131
    29fc:	77 e0       	ldi	r23, 0x07	; 7
    29fe:	43 e0       	ldi	r20, 0x03	; 3
    2a00:	50 e0       	ldi	r21, 0x00	; 0
    2a02:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2a06:	00 97       	sbiw	r24, 0x00	; 0
    2a08:	31 f4       	brne	.+12     	; 0x2a16 <debugFunction+0x50>
    {
      setArpDebug(NULL, 0);
    2a0a:	80 e0       	ldi	r24, 0x00	; 0
    2a0c:	90 e0       	ldi	r25, 0x00	; 0
    2a0e:	60 e0       	ldi	r22, 0x00	; 0
    2a10:	0e 94 51 36 	call	0x6ca2	; 0x6ca2 <setArpDebug>
    2a14:	3c c0       	rjmp	.+120    	; 0x2a8e <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2a16:	ce 01       	movw	r24, r28
    2a18:	60 e8       	ldi	r22, 0x80	; 128
    2a1a:	77 e0       	ldi	r23, 0x07	; 7
    2a1c:	42 e0       	ldi	r20, 0x02	; 2
    2a1e:	50 e0       	ldi	r21, 0x00	; 0
    2a20:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2a24:	00 97       	sbiw	r24, 0x00	; 0
    2a26:	31 f4       	brne	.+12     	; 0x2a34 <debugFunction+0x6e>
    {
      setIpDebug(NULL, 0);
    2a28:	80 e0       	ldi	r24, 0x00	; 0
    2a2a:	90 e0       	ldi	r25, 0x00	; 0
    2a2c:	60 e0       	ldi	r22, 0x00	; 0
    2a2e:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <setIpDebug>
    2a32:	2d c0       	rjmp	.+90     	; 0x2a8e <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2a34:	ce 01       	movw	r24, r28
    2a36:	6b e7       	ldi	r22, 0x7B	; 123
    2a38:	77 e0       	ldi	r23, 0x07	; 7
    2a3a:	42 e0       	ldi	r20, 0x02	; 2
    2a3c:	50 e0       	ldi	r21, 0x00	; 0
    2a3e:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2a42:	00 97       	sbiw	r24, 0x00	; 0
    2a44:	31 f4       	brne	.+12     	; 0x2a52 <debugFunction+0x8c>
    {
      setIcmpDebug(NULL, 0);
    2a46:	80 e0       	ldi	r24, 0x00	; 0
    2a48:	90 e0       	ldi	r25, 0x00	; 0
    2a4a:	60 e0       	ldi	r22, 0x00	; 0
    2a4c:	0e 94 ca 34 	call	0x6994	; 0x6994 <setIcmpDebug>
    2a50:	1e c0       	rjmp	.+60     	; 0x2a8e <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2a52:	ce 01       	movw	r24, r28
    2a54:	67 e7       	ldi	r22, 0x77	; 119
    2a56:	77 e0       	ldi	r23, 0x07	; 7
    2a58:	42 e0       	ldi	r20, 0x02	; 2
    2a5a:	50 e0       	ldi	r21, 0x00	; 0
    2a5c:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2a60:	00 97       	sbiw	r24, 0x00	; 0
    2a62:	31 f4       	brne	.+12     	; 0x2a70 <debugFunction+0xaa>
    {
      setTcpDebug(NULL, 0);
    2a64:	80 e0       	ldi	r24, 0x00	; 0
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	60 e0       	ldi	r22, 0x00	; 0
    2a6a:	0e 94 fd 3c 	call	0x79fa	; 0x79fa <setTcpDebug>
    2a6e:	0f c0       	rjmp	.+30     	; 0x2a8e <debugFunction+0xc8>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2a70:	ce 01       	movw	r24, r28
    2a72:	63 e7       	ldi	r22, 0x73	; 115
    2a74:	77 e0       	ldi	r23, 0x07	; 7
    2a76:	42 e0       	ldi	r20, 0x02	; 2
    2a78:	50 e0       	ldi	r21, 0x00	; 0
    2a7a:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2a7e:	00 97       	sbiw	r24, 0x00	; 0
    2a80:	09 f0       	breq	.+2      	; 0x2a84 <debugFunction+0xbe>
    2a82:	90 c0       	rjmp	.+288    	; 0x2ba4 <debugFunction+0x1de>
    {
      setUdpDebug(NULL, 0);
    2a84:	80 e0       	ldi	r24, 0x00	; 0
    2a86:	90 e0       	ldi	r25, 0x00	; 0
    2a88:	60 e0       	ldi	r22, 0x00	; 0
    2a8a:	0e 94 4a 3d 	call	0x7a94	; 0x7a94 <setUdpDebug>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
    2a8e:	00 d0       	rcall	.+0      	; 0x2a90 <debugFunction+0xca>
    2a90:	00 d0       	rcall	.+0      	; 0x2a92 <debugFunction+0xcc>
    2a92:	ed b7       	in	r30, 0x3d	; 61
    2a94:	fe b7       	in	r31, 0x3e	; 62
    2a96:	31 96       	adiw	r30, 0x01	; 1
    2a98:	d8 01       	movw	r26, r16
    2a9a:	5a 96       	adiw	r26, 0x1a	; 26
    2a9c:	8d 91       	ld	r24, X+
    2a9e:	9c 91       	ld	r25, X
    2aa0:	5b 97       	sbiw	r26, 0x1b	; 27
    2aa2:	ad b7       	in	r26, 0x3d	; 61
    2aa4:	be b7       	in	r27, 0x3e	; 62
    2aa6:	11 96       	adiw	r26, 0x01	; 1
    2aa8:	8d 93       	st	X+, r24
    2aaa:	9c 93       	st	X, r25
    2aac:	12 97       	sbiw	r26, 0x02	; 2
    2aae:	80 e9       	ldi	r24, 0x90	; 144
    2ab0:	95 e0       	ldi	r25, 0x05	; 5
    2ab2:	6a c0       	rjmp	.+212    	; 0x2b88 <debugFunction+0x1c2>


  }
  else                   //level > 0
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2ab4:	6f e6       	ldi	r22, 0x6F	; 111
    2ab6:	77 e0       	ldi	r23, 0x07	; 7
    2ab8:	43 e0       	ldi	r20, 0x03	; 3
    2aba:	50 e0       	ldi	r21, 0x00	; 0
    2abc:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2ac0:	00 97       	sbiw	r24, 0x00	; 0
    2ac2:	49 f4       	brne	.+18     	; 0x2ad6 <debugFunction+0x110>
    {
      setArpDebug(state->myStdInOut, level);
    2ac4:	d8 01       	movw	r26, r16
    2ac6:	5a 96       	adiw	r26, 0x1a	; 26
    2ac8:	8d 91       	ld	r24, X+
    2aca:	9c 91       	ld	r25, X
    2acc:	5b 97       	sbiw	r26, 0x1b	; 27
    2ace:	6f 2d       	mov	r22, r15
    2ad0:	0e 94 51 36 	call	0x6ca2	; 0x6ca2 <setArpDebug>
    2ad4:	47 c0       	rjmp	.+142    	; 0x2b64 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }   
    
    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2ad6:	ce 01       	movw	r24, r28
    2ad8:	6c e6       	ldi	r22, 0x6C	; 108
    2ada:	77 e0       	ldi	r23, 0x07	; 7
    2adc:	42 e0       	ldi	r20, 0x02	; 2
    2ade:	50 e0       	ldi	r21, 0x00	; 0
    2ae0:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2ae4:	00 97       	sbiw	r24, 0x00	; 0
    2ae6:	49 f4       	brne	.+18     	; 0x2afa <debugFunction+0x134>
    {
      setIpDebug(state->myStdInOut, level);
    2ae8:	d8 01       	movw	r26, r16
    2aea:	5a 96       	adiw	r26, 0x1a	; 26
    2aec:	8d 91       	ld	r24, X+
    2aee:	9c 91       	ld	r25, X
    2af0:	5b 97       	sbiw	r26, 0x1b	; 27
    2af2:	6f 2d       	mov	r22, r15
    2af4:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <setIpDebug>
    2af8:	35 c0       	rjmp	.+106    	; 0x2b64 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2afa:	ce 01       	movw	r24, r28
    2afc:	67 e6       	ldi	r22, 0x67	; 103
    2afe:	77 e0       	ldi	r23, 0x07	; 7
    2b00:	42 e0       	ldi	r20, 0x02	; 2
    2b02:	50 e0       	ldi	r21, 0x00	; 0
    2b04:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2b08:	00 97       	sbiw	r24, 0x00	; 0
    2b0a:	49 f4       	brne	.+18     	; 0x2b1e <debugFunction+0x158>
    {
      setIcmpDebug(state->myStdInOut, level);
    2b0c:	d8 01       	movw	r26, r16
    2b0e:	5a 96       	adiw	r26, 0x1a	; 26
    2b10:	8d 91       	ld	r24, X+
    2b12:	9c 91       	ld	r25, X
    2b14:	5b 97       	sbiw	r26, 0x1b	; 27
    2b16:	6f 2d       	mov	r22, r15
    2b18:	0e 94 ca 34 	call	0x6994	; 0x6994 <setIcmpDebug>
    2b1c:	23 c0       	rjmp	.+70     	; 0x2b64 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2b1e:	ce 01       	movw	r24, r28
    2b20:	63 e6       	ldi	r22, 0x63	; 99
    2b22:	77 e0       	ldi	r23, 0x07	; 7
    2b24:	42 e0       	ldi	r20, 0x02	; 2
    2b26:	50 e0       	ldi	r21, 0x00	; 0
    2b28:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2b2c:	00 97       	sbiw	r24, 0x00	; 0
    2b2e:	49 f4       	brne	.+18     	; 0x2b42 <debugFunction+0x17c>
    {
      setTcpDebug(state->myStdInOut, level);
    2b30:	d8 01       	movw	r26, r16
    2b32:	5a 96       	adiw	r26, 0x1a	; 26
    2b34:	8d 91       	ld	r24, X+
    2b36:	9c 91       	ld	r25, X
    2b38:	5b 97       	sbiw	r26, 0x1b	; 27
    2b3a:	6f 2d       	mov	r22, r15
    2b3c:	0e 94 fd 3c 	call	0x79fa	; 0x79fa <setTcpDebug>
    2b40:	11 c0       	rjmp	.+34     	; 0x2b64 <debugFunction+0x19e>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }
    
    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2b42:	ce 01       	movw	r24, r28
    2b44:	6f e5       	ldi	r22, 0x5F	; 95
    2b46:	77 e0       	ldi	r23, 0x07	; 7
    2b48:	42 e0       	ldi	r20, 0x02	; 2
    2b4a:	50 e0       	ldi	r21, 0x00	; 0
    2b4c:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    2b50:	00 97       	sbiw	r24, 0x00	; 0
    2b52:	41 f5       	brne	.+80     	; 0x2ba4 <debugFunction+0x1de>
    {
      setUdpDebug(state->myStdInOut, level);
    2b54:	d8 01       	movw	r26, r16
    2b56:	5a 96       	adiw	r26, 0x1a	; 26
    2b58:	8d 91       	ld	r24, X+
    2b5a:	9c 91       	ld	r25, X
    2b5c:	5b 97       	sbiw	r26, 0x1b	; 27
    2b5e:	6f 2d       	mov	r22, r15
    2b60:	0e 94 4a 3d 	call	0x7a94	; 0x7a94 <setUdpDebug>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
    2b64:	00 d0       	rcall	.+0      	; 0x2b66 <debugFunction+0x1a0>
    2b66:	00 d0       	rcall	.+0      	; 0x2b68 <debugFunction+0x1a2>
    2b68:	ed b7       	in	r30, 0x3d	; 61
    2b6a:	fe b7       	in	r31, 0x3e	; 62
    2b6c:	31 96       	adiw	r30, 0x01	; 1
    2b6e:	d8 01       	movw	r26, r16
    2b70:	5a 96       	adiw	r26, 0x1a	; 26
    2b72:	8d 91       	ld	r24, X+
    2b74:	9c 91       	ld	r25, X
    2b76:	5b 97       	sbiw	r26, 0x1b	; 27
    2b78:	ad b7       	in	r26, 0x3d	; 61
    2b7a:	be b7       	in	r27, 0x3e	; 62
    2b7c:	11 96       	adiw	r26, 0x01	; 1
    2b7e:	8d 93       	st	X+, r24
    2b80:	9c 93       	st	X, r25
    2b82:	12 97       	sbiw	r26, 0x02	; 2
    2b84:	8d e7       	ldi	r24, 0x7D	; 125
    2b86:	95 e0       	ldi	r25, 0x05	; 5
    2b88:	82 83       	std	Z+2, r24	; 0x02
    2b8a:	93 83       	std	Z+3, r25	; 0x03
    2b8c:	c4 83       	std	Z+4, r28	; 0x04
    2b8e:	d5 83       	std	Z+5, r29	; 0x05
    2b90:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      return OK_SILENT;  
    2b94:	ed b7       	in	r30, 0x3d	; 61
    2b96:	fe b7       	in	r31, 0x3e	; 62
    2b98:	36 96       	adiw	r30, 0x06	; 6
    2b9a:	ed bf       	out	0x3d, r30	; 61
    2b9c:	fe bf       	out	0x3e, r31	; 62
    2b9e:	20 e0       	ldi	r18, 0x00	; 0
    2ba0:	30 e0       	ldi	r19, 0x00	; 0
    2ba2:	02 c0       	rjmp	.+4      	; 0x2ba8 <debugFunction+0x1e2>
    }
  }
  
  return SYNTAX_ERROR;
    2ba4:	22 e0       	ldi	r18, 0x02	; 2
    2ba6:	30 e0       	ldi	r19, 0x00	; 0
}
    2ba8:	c9 01       	movw	r24, r18
    2baa:	df 91       	pop	r29
    2bac:	cf 91       	pop	r28
    2bae:	1f 91       	pop	r17
    2bb0:	0f 91       	pop	r16
    2bb2:	ff 90       	pop	r15
    2bb4:	08 95       	ret

00002bb6 <statusEncFunction>:
  return OK_SILENT; 
}

static cliExRes_t statusEncFunction(cmdState_t *state)
{
  nicRegDump(state->myStdInOut);
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bba:	93 8d       	ldd	r25, Z+27	; 0x1b
    2bbc:	0e 94 40 2d 	call	0x5a80	; 0x5a80 <nicRegDump>
  return OK_SILENT;
}
    2bc0:	80 e0       	ldi	r24, 0x00	; 0
    2bc2:	90 e0       	ldi	r25, 0x00	; 0
    2bc4:	08 95       	ret

00002bc6 <readRamFIleFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
{
    2bc6:	df 92       	push	r13
    2bc8:	ef 92       	push	r14
    2bca:	ff 92       	push	r15
    2bcc:	0f 93       	push	r16
    2bce:	1f 93       	push	r17
    2bd0:	df 93       	push	r29
    2bd2:	cf 93       	push	r28
    2bd4:	0f 92       	push	r0
    2bd6:	cd b7       	in	r28, 0x3d	; 61
    2bd8:	de b7       	in	r29, 0x3e	; 62
    2bda:	8c 01       	movw	r16, r24
  uint8_t rezultat;
  uint8_t znak = ' ';
    2bdc:	80 e2       	ldi	r24, 0x20	; 32
    2bde:	89 83       	std	Y+1, r24	; 0x01
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
    2be0:	81 e0       	ldi	r24, 0x01	; 1
    2be2:	b8 01       	movw	r22, r16
    2be4:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2be8:	68 ec       	ldi	r22, 0xC8	; 200
    2bea:	72 e3       	ldi	r23, 0x32	; 50
    2bec:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <ramDyskOtworzPlik>
    2bf0:	d8 01       	movw	r26, r16
    2bf2:	5a 96       	adiw	r26, 0x1a	; 26
    2bf4:	ed 90       	ld	r14, X+
    2bf6:	fc 90       	ld	r15, X
    2bf8:	5b 97       	sbiw	r26, 0x1b	; 27
    2bfa:	88 23       	and	r24, r24
    2bfc:	f9 f0       	breq	.+62     	; 0x2c3c <readRamFIleFunction+0x76>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2bfe:	81 e0       	ldi	r24, 0x01	; 1
    2c00:	b8 01       	movw	r22, r16
    2c02:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2c06:	00 d0       	rcall	.+0      	; 0x2c08 <readRamFIleFunction+0x42>
    2c08:	00 d0       	rcall	.+0      	; 0x2c0a <readRamFIleFunction+0x44>
    2c0a:	ed b7       	in	r30, 0x3d	; 61
    2c0c:	fe b7       	in	r31, 0x3e	; 62
    2c0e:	31 96       	adiw	r30, 0x01	; 1
    2c10:	ad b7       	in	r26, 0x3d	; 61
    2c12:	be b7       	in	r27, 0x3e	; 62
    2c14:	11 96       	adiw	r26, 0x01	; 1
    2c16:	ed 92       	st	X+, r14
    2c18:	fc 92       	st	X, r15
    2c1a:	12 97       	sbiw	r26, 0x02	; 2
    2c1c:	2a ee       	ldi	r18, 0xEA	; 234
    2c1e:	32 e0       	ldi	r19, 0x02	; 2
    2c20:	22 83       	std	Z+2, r18	; 0x02
    2c22:	33 83       	std	Z+3, r19	; 0x03
    2c24:	84 83       	std	Z+4, r24	; 0x04
    2c26:	95 83       	std	Z+5, r25	; 0x05
    2c28:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    return ERROR_INFORM;
    2c2c:	ed b7       	in	r30, 0x3d	; 61
    2c2e:	fe b7       	in	r31, 0x3e	; 62
    2c30:	36 96       	adiw	r30, 0x06	; 6
    2c32:	ed bf       	out	0x3d, r30	; 61
    2c34:	fe bf       	out	0x3e, r31	; 62
    2c36:	24 e0       	ldi	r18, 0x04	; 4
    2c38:	30 e0       	ldi	r19, 0x00	; 0
    2c3a:	54 c0       	rjmp	.+168    	; 0x2ce4 <readRamFIleFunction+0x11e>
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    2c3c:	a0 91 cc 32 	lds	r26, 0x32CC
    2c40:	b0 91 cd 32 	lds	r27, 0x32CD
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    2c44:	00 d0       	rcall	.+0      	; 0x2c46 <readRamFIleFunction+0x80>
    2c46:	00 d0       	rcall	.+0      	; 0x2c48 <readRamFIleFunction+0x82>
    2c48:	4d b7       	in	r20, 0x3d	; 61
    2c4a:	5e b7       	in	r21, 0x3e	; 62
    2c4c:	4f 5f       	subi	r20, 0xFF	; 255
    2c4e:	5f 4f       	sbci	r21, 0xFF	; 255
    2c50:	ed b7       	in	r30, 0x3d	; 61
    2c52:	fe b7       	in	r31, 0x3e	; 62
    2c54:	e1 82       	std	Z+1, r14	; 0x01
    2c56:	f2 82       	std	Z+2, r15	; 0x02
    2c58:	88 ed       	ldi	r24, 0xD8	; 216
    2c5a:	94 e0       	ldi	r25, 0x04	; 4
    2c5c:	fa 01       	movw	r30, r20
    2c5e:	82 83       	std	Z+2, r24	; 0x02
    2c60:	93 83       	std	Z+3, r25	; 0x03
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    2c62:	12 96       	adiw	r26, 0x02	; 2
    2c64:	9c 91       	ld	r25, X
    2c66:	12 97       	sbiw	r26, 0x02	; 2
    2c68:	80 e0       	ldi	r24, 0x00	; 0
    2c6a:	11 96       	adiw	r26, 0x01	; 1
    2c6c:	2c 91       	ld	r18, X
    2c6e:	82 0f       	add	r24, r18
    2c70:	91 1d       	adc	r25, r1
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    2c72:	84 83       	std	Z+4, r24	; 0x04
    2c74:	95 83       	std	Z+5, r25	; 0x05
    2c76:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    2c7a:	8d b7       	in	r24, 0x3d	; 61
    2c7c:	9e b7       	in	r25, 0x3e	; 62
    2c7e:	06 96       	adiw	r24, 0x06	; 6
    2c80:	8d bf       	out	0x3d, r24	; 61
    2c82:	9e bf       	out	0x3e, r25	; 62
  while (rezultat == 0)
  {
    rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
    2c84:	7e 01       	movw	r14, r28
    2c86:	08 94       	sec
    2c88:	e1 1c       	adc	r14, r1
    2c8a:	f1 1c       	adc	r15, r1
    2c8c:	88 ec       	ldi	r24, 0xC8	; 200
    2c8e:	92 e3       	ldi	r25, 0x32	; 50
    2c90:	b7 01       	movw	r22, r14
    2c92:	0e 94 bd 1e 	call	0x3d7a	; 0x3d7a <ramDyskCzytajBajtZPliku>
    2c96:	d8 2e       	mov	r13, r24
    
    uartVtySendByte(znak);
    2c98:	89 81       	ldd	r24, Y+1	; 0x01
    2c9a:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    if (znak == '\r')
    2c9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ca0:	8d 30       	cpi	r24, 0x0D	; 13
    2ca2:	19 f4       	brne	.+6      	; 0x2caa <readRamFIleFunction+0xe4>
      uartVtySendByte('\n');
    2ca4:	8a e0       	ldi	r24, 0x0A	; 10
    2ca6:	0e 94 cd 0a 	call	0x159a	; 0x159a <uartVtySendByte>
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
  while (rezultat == 0)
    2caa:	dd 20       	and	r13, r13
    2cac:	79 f3       	breq	.-34     	; 0x2c8c <readRamFIleFunction+0xc6>
    
    uartVtySendByte(znak);
    if (znak == '\r')
      uartVtySendByte('\n');
  }
  fprintf_P(state->myStdInOut, nlStr);
    2cae:	00 d0       	rcall	.+0      	; 0x2cb0 <readRamFIleFunction+0xea>
    2cb0:	0f 92       	push	r0
    2cb2:	d8 01       	movw	r26, r16
    2cb4:	5a 96       	adiw	r26, 0x1a	; 26
    2cb6:	8d 91       	ld	r24, X+
    2cb8:	9c 91       	ld	r25, X
    2cba:	5b 97       	sbiw	r26, 0x1b	; 27
    2cbc:	ed b7       	in	r30, 0x3d	; 61
    2cbe:	fe b7       	in	r31, 0x3e	; 62
    2cc0:	81 83       	std	Z+1, r24	; 0x01
    2cc2:	92 83       	std	Z+2, r25	; 0x02
    2cc4:	83 e5       	ldi	r24, 0x53	; 83
    2cc6:	96 e0       	ldi	r25, 0x06	; 6
    2cc8:	83 83       	std	Z+3, r24	; 0x03
    2cca:	94 83       	std	Z+4, r25	; 0x04
    2ccc:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  ramDyskZamknijPlik(&fdVty);
    2cd0:	0f 90       	pop	r0
    2cd2:	0f 90       	pop	r0
    2cd4:	0f 90       	pop	r0
    2cd6:	0f 90       	pop	r0
    2cd8:	88 ec       	ldi	r24, 0xC8	; 200
    2cda:	92 e3       	ldi	r25, 0x32	; 50
    2cdc:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <ramDyskZamknijPlik>
  return OK_SILENT;
    2ce0:	20 e0       	ldi	r18, 0x00	; 0
    2ce2:	30 e0       	ldi	r19, 0x00	; 0
}
    2ce4:	c9 01       	movw	r24, r18
    2ce6:	0f 90       	pop	r0
    2ce8:	cf 91       	pop	r28
    2cea:	df 91       	pop	r29
    2cec:	1f 91       	pop	r17
    2cee:	0f 91       	pop	r16
    2cf0:	ff 90       	pop	r15
    2cf2:	ef 90       	pop	r14
    2cf4:	df 90       	pop	r13
    2cf6:	08 95       	ret

00002cf8 <writeRamFileFunction>:
  return ERROR_INFORM;
}

static cliExRes_t writeRamFileFunction(cmdState_t *state)
{
  ramDyskDir(state->myStdInOut);
    2cf8:	fc 01       	movw	r30, r24
    2cfa:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cfc:	93 8d       	ldd	r25, Z+27	; 0x1b
    2cfe:	0e 94 09 21 	call	0x4212	; 0x4212 <ramDyskDir>
  return OK_SILENT;
}
    2d02:	80 e0       	ldi	r24, 0x00	; 0
    2d04:	90 e0       	ldi	r25, 0x00	; 0
    2d06:	08 95       	ret

00002d08 <pokazCzasFunction>:
  nicRegDump(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
    2d08:	cf 93       	push	r28
    2d0a:	df 93       	push	r29
    2d0c:	ec 01       	movw	r28, r24
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
    2d0e:	87 e1       	ldi	r24, 0x17	; 23
    2d10:	92 e3       	ldi	r25, 0x32	; 50
    2d12:	0e 94 f8 27 	call	0x4ff0	; 0x4ff0 <readTimeDecoded>
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    2d16:	40 91 19 32 	lds	r20, 0x3219
    2d1a:	46 95       	lsr	r20
    2d1c:	46 95       	lsr	r20
    2d1e:	46 95       	lsr	r20
    2d20:	70 91 19 32 	lds	r23, 0x3219
    2d24:	7f 70       	andi	r23, 0x0F	; 15
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2d26:	30 91 18 32 	lds	r19, 0x3218
    2d2a:	36 95       	lsr	r19
    2d2c:	36 95       	lsr	r19
    2d2e:	36 95       	lsr	r19
    2d30:	60 91 18 32 	lds	r22, 0x3218
    2d34:	6f 70       	andi	r22, 0x0F	; 15
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    2d36:	20 91 17 32 	lds	r18, 0x3217
    2d3a:	26 95       	lsr	r18
    2d3c:	26 95       	lsr	r18
    2d3e:	26 95       	lsr	r18
    2d40:	50 91 17 32 	lds	r21, 0x3217
    2d44:	5f 70       	andi	r21, 0x0F	; 15
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2d46:	8d b7       	in	r24, 0x3d	; 61
    2d48:	9e b7       	in	r25, 0x3e	; 62
    2d4a:	0a 97       	sbiw	r24, 0x0a	; 10
    2d4c:	8d bf       	out	0x3d, r24	; 61
    2d4e:	9e bf       	out	0x3e, r25	; 62
    2d50:	ed b7       	in	r30, 0x3d	; 61
    2d52:	fe b7       	in	r31, 0x3e	; 62
    2d54:	31 96       	adiw	r30, 0x01	; 1
    2d56:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d58:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2d5a:	ad b7       	in	r26, 0x3d	; 61
    2d5c:	be b7       	in	r27, 0x3e	; 62
    2d5e:	11 96       	adiw	r26, 0x01	; 1
    2d60:	8d 93       	st	X+, r24
    2d62:	9c 93       	st	X, r25
    2d64:	12 97       	sbiw	r26, 0x02	; 2
    2d66:	87 e8       	ldi	r24, 0x87	; 135
    2d68:	97 e0       	ldi	r25, 0x07	; 7
    2d6a:	82 83       	std	Z+2, r24	; 0x02
    2d6c:	93 83       	std	Z+3, r25	; 0x03
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    2d6e:	46 70       	andi	r20, 0x06	; 6
    2d70:	84 2f       	mov	r24, r20
    2d72:	88 0f       	add	r24, r24
    2d74:	88 0f       	add	r24, r24
    2d76:	84 0f       	add	r24, r20
    2d78:	87 0f       	add	r24, r23
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2d7a:	84 83       	std	Z+4, r24	; 0x04
    2d7c:	15 82       	std	Z+5, r1	; 0x05

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2d7e:	3e 70       	andi	r19, 0x0E	; 14
    2d80:	83 2f       	mov	r24, r19
    2d82:	88 0f       	add	r24, r24
    2d84:	88 0f       	add	r24, r24
    2d86:	83 0f       	add	r24, r19
    2d88:	86 0f       	add	r24, r22
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2d8a:	86 83       	std	Z+6, r24	; 0x06
    2d8c:	17 82       	std	Z+7, r1	; 0x07
static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    2d8e:	2e 70       	andi	r18, 0x0E	; 14
    2d90:	82 2f       	mov	r24, r18
    2d92:	88 0f       	add	r24, r24
    2d94:	88 0f       	add	r24, r24
    2d96:	82 0f       	add	r24, r18
    2d98:	85 0f       	add	r24, r21
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2d9a:	80 87       	std	Z+8, r24	; 0x08
    2d9c:	11 86       	std	Z+9, r1	; 0x09
    2d9e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    2da2:	8d b7       	in	r24, 0x3d	; 61
    2da4:	9e b7       	in	r25, 0x3e	; 62
    2da6:	0a 96       	adiw	r24, 0x0a	; 10
    2da8:	8d bf       	out	0x3d, r24	; 61
    2daa:	9e bf       	out	0x3e, r25	; 62
  return OK_SILENT;
}
    2dac:	80 e0       	ldi	r24, 0x00	; 0
    2dae:	90 e0       	ldi	r25, 0x00	; 0
    2db0:	df 91       	pop	r29
    2db2:	cf 91       	pop	r28
    2db4:	08 95       	ret

00002db6 <helpFunction>:
  return OK_SILENT;
}

static cliExRes_t helpFunction(cmdState_t *state)
{
  cmdPrintHelp(state);
    2db6:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <cmdPrintHelp>
  return OK_SILENT;
}
    2dba:	80 e0       	ldi	r24, 0x00	; 0
    2dbc:	90 e0       	ldi	r25, 0x00	; 0
    2dbe:	08 95       	ret

00002dc0 <VtyInit>:
  {cmd_disable,      cmd_help_disable,      disableFunction},
  {NULL, NULL, NULL}
};

void VtyInit(cmdState_t* state, FILE *stream)
{
    2dc0:	ef 92       	push	r14
    2dc2:	0f 93       	push	r16
    2dc4:	1f 93       	push	r17
    2dc6:	9b 01       	movw	r18, r22
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
    2dc8:	60 e0       	ldi	r22, 0x00	; 0
    2dca:	78 e2       	ldi	r23, 0x28	; 40
    2dcc:	40 e0       	ldi	r20, 0x00	; 0
    2dce:	51 e0       	ldi	r21, 0x01	; 1
    2dd0:	08 e9       	ldi	r16, 0x98	; 152
    2dd2:	16 e0       	ldi	r17, 0x06	; 6
    2dd4:	ee 24       	eor	r14, r14
    2dd6:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cmdStateConfigure>
}
    2dda:	1f 91       	pop	r17
    2ddc:	0f 91       	pop	r16
    2dde:	ef 90       	pop	r14
    2de0:	08 95       	ret

00002de2 <printErrorInfo>:

void printErrorInfo(cmdState_t *state)
{
    2de2:	cf 93       	push	r28
    2de4:	df 93       	push	r29
    2de6:	ec 01       	movw	r28, r24
  if (state->errno != 0)
    2de8:	ec 8d       	ldd	r30, Y+28	; 0x1c
    2dea:	ee 23       	and	r30, r30
    2dec:	49 f1       	breq	.+82     	; 0x2e40 <printErrorInfo+0x5e>
  {
    fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->err1, state->err2);
    2dee:	f0 e0       	ldi	r31, 0x00	; 0
    2df0:	ee 0f       	add	r30, r30
    2df2:	ff 1f       	adc	r31, r31
    2df4:	e0 58       	subi	r30, 0x80	; 128
    2df6:	f9 4f       	sbci	r31, 0xF9	; 249
    2df8:	85 91       	lpm	r24, Z+
    2dfa:	94 91       	lpm	r25, Z+
    2dfc:	2d b7       	in	r18, 0x3d	; 61
    2dfe:	3e b7       	in	r19, 0x3e	; 62
    2e00:	28 50       	subi	r18, 0x08	; 8
    2e02:	30 40       	sbci	r19, 0x00	; 0
    2e04:	2d bf       	out	0x3d, r18	; 61
    2e06:	3e bf       	out	0x3e, r19	; 62
    2e08:	ed b7       	in	r30, 0x3d	; 61
    2e0a:	fe b7       	in	r31, 0x3e	; 62
    2e0c:	31 96       	adiw	r30, 0x01	; 1
    2e0e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2e10:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2e12:	ad b7       	in	r26, 0x3d	; 61
    2e14:	be b7       	in	r27, 0x3e	; 62
    2e16:	11 96       	adiw	r26, 0x01	; 1
    2e18:	2d 93       	st	X+, r18
    2e1a:	3c 93       	st	X, r19
    2e1c:	12 97       	sbiw	r26, 0x02	; 2
    2e1e:	82 83       	std	Z+2, r24	; 0x02
    2e20:	93 83       	std	Z+3, r25	; 0x03
    2e22:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2e24:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2e26:	84 83       	std	Z+4, r24	; 0x04
    2e28:	95 83       	std	Z+5, r25	; 0x05
    2e2a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2e2c:	86 83       	std	Z+6, r24	; 0x06
    2e2e:	17 82       	std	Z+7, r1	; 0x07
    2e30:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    2e34:	2d b7       	in	r18, 0x3d	; 61
    2e36:	3e b7       	in	r19, 0x3e	; 62
    2e38:	28 5f       	subi	r18, 0xF8	; 248
    2e3a:	3f 4f       	sbci	r19, 0xFF	; 255
    2e3c:	2d bf       	out	0x3d, r18	; 61
    2e3e:	3e bf       	out	0x3e, r19	; 62
  }
  state->errno = 0;
    2e40:	1c 8e       	std	Y+28, r1	; 0x1c
  state->err1 = 0;
    2e42:	1d 8e       	std	Y+29, r1	; 0x1d
    2e44:	1e 8e       	std	Y+30, r1	; 0x1e
  state->err2 = 0;
    2e46:	1f 8e       	std	Y+31, r1	; 0x1f
}
    2e48:	df 91       	pop	r29
    2e4a:	cf 91       	pop	r28
    2e4c:	08 95       	ret

00002e4e <eraseRamFileFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
    2e4e:	cf 93       	push	r28
    2e50:	df 93       	push	r29
    2e52:	ec 01       	movw	r28, r24
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    2e54:	81 e0       	ldi	r24, 0x01	; 1
    2e56:	be 01       	movw	r22, r28
    2e58:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2e5c:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <ramDyskUsunPlik>
    2e60:	88 23       	and	r24, r24
    2e62:	31 f0       	breq	.+12     	; 0x2e70 <eraseRamFileFunction+0x22>
    return OK_INFORM;

  printErrorInfo(state);
    2e64:	ce 01       	movw	r24, r28
    2e66:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <printErrorInfo>
  return ERROR_INFORM;
    2e6a:	24 e0       	ldi	r18, 0x04	; 4
    2e6c:	30 e0       	ldi	r19, 0x00	; 0
    2e6e:	02 c0       	rjmp	.+4      	; 0x2e74 <eraseRamFileFunction+0x26>
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    return OK_INFORM;
    2e70:	21 e0       	ldi	r18, 0x01	; 1
    2e72:	30 e0       	ldi	r19, 0x00	; 0

  printErrorInfo(state);
  return ERROR_INFORM;
}
    2e74:	c9 01       	movw	r24, r18
    2e76:	df 91       	pop	r29
    2e78:	cf 91       	pop	r28
    2e7a:	08 95       	ret

00002e7c <dodajRamPlikFunction>:

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
    2e7c:	cf 93       	push	r28
    2e7e:	df 93       	push	r29
    2e80:	ec 01       	movw	r28, r24
  if (state->argc != 1)
    2e82:	89 8d       	ldd	r24, Y+25	; 0x19
    2e84:	81 30       	cpi	r24, 0x01	; 1
    2e86:	69 f4       	brne	.+26     	; 0x2ea2 <dodajRamPlikFunction+0x26>
    return SYNTAX_ERROR;

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
    2e88:	be 01       	movw	r22, r28
    2e8a:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2e8e:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <ramDyskUtworzPlik>
    2e92:	88 23       	and	r24, r24
    2e94:	49 f0       	breq	.+18     	; 0x2ea8 <dodajRamPlikFunction+0x2c>
  {
    return OK_INFORM;
  }
  printErrorInfo(state);
    2e96:	ce 01       	movw	r24, r28
    2e98:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <printErrorInfo>
  return ERROR_INFORM;
    2e9c:	24 e0       	ldi	r18, 0x04	; 4
    2e9e:	30 e0       	ldi	r19, 0x00	; 0
    2ea0:	05 c0       	rjmp	.+10     	; 0x2eac <dodajRamPlikFunction+0x30>
}

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
  if (state->argc != 1)
    return SYNTAX_ERROR;
    2ea2:	22 e0       	ldi	r18, 0x02	; 2
    2ea4:	30 e0       	ldi	r19, 0x00	; 0
    2ea6:	02 c0       	rjmp	.+4      	; 0x2eac <dodajRamPlikFunction+0x30>

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
  {
    return OK_INFORM;
    2ea8:	21 e0       	ldi	r18, 0x01	; 1
    2eaa:	30 e0       	ldi	r19, 0x00	; 0
  }
  printErrorInfo(state);
  return ERROR_INFORM;
}
    2eac:	c9 01       	movw	r24, r18
    2eae:	df 91       	pop	r29
    2eb0:	cf 91       	pop	r28
    2eb2:	08 95       	ret

00002eb4 <flashExModuleFunction>:
  return OK_SILENT;
}


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
    2eb4:	ff 92       	push	r15
    2eb6:	0f 93       	push	r16
    2eb8:	1f 93       	push	r17
    2eba:	cf 93       	push	r28
    2ebc:	df 93       	push	r29
    2ebe:	ec 01       	movw	r28, r24
  if (state->argc != 2)
    2ec0:	89 8d       	ldd	r24, Y+25	; 0x19
    2ec2:	82 30       	cpi	r24, 0x02	; 2
    2ec4:	09 f0       	breq	.+2      	; 0x2ec8 <flashExModuleFunction+0x14>
    2ec6:	46 c0       	rjmp	.+140    	; 0x2f54 <flashExModuleFunction+0xa0>
    return SYNTAX_ERROR;
  
  uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	be 01       	movw	r22, r28
    2ecc:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
    2ed0:	f6 2e       	mov	r15, r22
  char *nazwaPliku      = cmdlineGetArgStr(2, state);
    2ed2:	82 e0       	ldi	r24, 0x02	; 2
    2ed4:	be 01       	movw	r22, r28
    2ed6:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    2eda:	8c 01       	movw	r16, r24
  uint8_t  blad;
  
  // Sprawdzanie, czy moduł wykonawczy odpowiada
  if (rs485ping(nrUrzadzenia) != 0)
    2edc:	8f 2d       	mov	r24, r15
    2ede:	0e 94 a5 40 	call	0x814a	; 0x814a <rs485ping>
    2ee2:	88 23       	and	r24, r24
    2ee4:	31 f0       	breq	.+12     	; 0x2ef2 <flashExModuleFunction+0x3e>
  {
    state->errno = noRemoteDevice;
    2ee6:	89 e0       	ldi	r24, 0x09	; 9
    2ee8:	8c 8f       	std	Y+28, r24	; 0x1c
    printErrorInfo(state);
    2eea:	ce 01       	movw	r24, r28
    2eec:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <printErrorInfo>
    2ef0:	2e c0       	rjmp	.+92     	; 0x2f4e <flashExModuleFunction+0x9a>
    return ERROR_INFORM;
  }
  
  //Sprawdzanie, czy istnieje odpowiedni plik z firmware
  if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
    2ef2:	c8 01       	movw	r24, r16
    2ef4:	68 ec       	ldi	r22, 0xC8	; 200
    2ef6:	72 e3       	ldi	r23, 0x32	; 50
    2ef8:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <ramDyskOtworzPlik>
    2efc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2efe:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2f00:	88 23       	and	r24, r24
    2f02:	c9 f0       	breq	.+50     	; 0x2f36 <flashExModuleFunction+0x82>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
    2f04:	00 d0       	rcall	.+0      	; 0x2f06 <flashExModuleFunction+0x52>
    2f06:	00 d0       	rcall	.+0      	; 0x2f08 <flashExModuleFunction+0x54>
    2f08:	ed b7       	in	r30, 0x3d	; 61
    2f0a:	fe b7       	in	r31, 0x3e	; 62
    2f0c:	31 96       	adiw	r30, 0x01	; 1
    2f0e:	ad b7       	in	r26, 0x3d	; 61
    2f10:	be b7       	in	r27, 0x3e	; 62
    2f12:	11 96       	adiw	r26, 0x01	; 1
    2f14:	4d 93       	st	X+, r20
    2f16:	5c 93       	st	X, r21
    2f18:	12 97       	sbiw	r26, 0x02	; 2
    2f1a:	8a ee       	ldi	r24, 0xEA	; 234
    2f1c:	92 e0       	ldi	r25, 0x02	; 2
    2f1e:	82 83       	std	Z+2, r24	; 0x02
    2f20:	93 83       	std	Z+3, r25	; 0x03
    2f22:	04 83       	std	Z+4, r16	; 0x04
    2f24:	15 83       	std	Z+5, r17	; 0x05
    2f26:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    return ERROR_INFORM;
    2f2a:	8d b7       	in	r24, 0x3d	; 61
    2f2c:	9e b7       	in	r25, 0x3e	; 62
    2f2e:	06 96       	adiw	r24, 0x06	; 6
    2f30:	8d bf       	out	0x3d, r24	; 61
    2f32:	9e bf       	out	0x3e, r25	; 62
    2f34:	0c c0       	rjmp	.+24     	; 0x2f4e <flashExModuleFunction+0x9a>
  }
  
  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
    2f36:	88 ec       	ldi	r24, 0xC8	; 200
    2f38:	92 e3       	ldi	r25, 0x32	; 50
    2f3a:	6f 2d       	mov	r22, r15
    2f3c:	0e 94 b5 42 	call	0x856a	; 0x856a <rs485xModemFlash>
    2f40:	08 2f       	mov	r16, r24

  ramDyskZamknijPlik(&fdVty);
    2f42:	88 ec       	ldi	r24, 0xC8	; 200
    2f44:	92 e3       	ldi	r25, 0x32	; 50
    2f46:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <ramDyskZamknijPlik>
  
  if (blad != 0)
    2f4a:	00 23       	and	r16, r16
    2f4c:	31 f0       	breq	.+12     	; 0x2f5a <flashExModuleFunction+0xa6>
    return ERROR_INFORM;
    2f4e:	24 e0       	ldi	r18, 0x04	; 4
    2f50:	30 e0       	ldi	r19, 0x00	; 0
    2f52:	05 c0       	rjmp	.+10     	; 0x2f5e <flashExModuleFunction+0xaa>


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
  if (state->argc != 2)
    return SYNTAX_ERROR;
    2f54:	22 e0       	ldi	r18, 0x02	; 2
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	02 c0       	rjmp	.+4      	; 0x2f5e <flashExModuleFunction+0xaa>
  ramDyskZamknijPlik(&fdVty);
  
  if (blad != 0)
    return ERROR_INFORM;

  return OK_SILENT;
    2f5a:	20 e0       	ldi	r18, 0x00	; 0
    2f5c:	30 e0       	ldi	r19, 0x00	; 0
}
    2f5e:	c9 01       	movw	r24, r18
    2f60:	df 91       	pop	r29
    2f62:	cf 91       	pop	r28
    2f64:	1f 91       	pop	r17
    2f66:	0f 91       	pop	r16
    2f68:	ff 90       	pop	r15
    2f6a:	08 95       	ret

00002f6c <rpingFunction>:
  
  return OK_SILENT;
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
    2f6c:	0f 93       	push	r16
    2f6e:	1f 93       	push	r17
    2f70:	df 93       	push	r29
    2f72:	cf 93       	push	r28
    2f74:	0f 92       	push	r0
    2f76:	cd b7       	in	r28, 0x3d	; 61
    2f78:	de b7       	in	r29, 0x3e	; 62
    2f7a:	8c 01       	movw	r16, r24
  if (state->argc < 1)
    2f7c:	fc 01       	movw	r30, r24
    2f7e:	81 8d       	ldd	r24, Z+25	; 0x19
    2f80:	88 23       	and	r24, r24
    2f82:	b9 f0       	breq	.+46     	; 0x2fb2 <rpingFunction+0x46>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
    2f84:	81 e0       	ldi	r24, 0x01	; 1
    2f86:	b8 01       	movw	r22, r16
    2f88:	0e 94 98 26 	call	0x4d30	; 0x4d30 <cmdlineGetArgInt>
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    2f8c:	86 2f       	mov	r24, r22
    2f8e:	69 83       	std	Y+1, r22	; 0x01
    2f90:	0e 94 a5 40 	call	0x814a	; 0x814a <rs485ping>
    2f94:	f8 01       	movw	r30, r16
    2f96:	87 8f       	std	Z+31, r24	; 0x1f
    2f98:	69 81       	ldd	r22, Y+1	; 0x01
    2f9a:	88 23       	and	r24, r24
    2f9c:	69 f0       	breq	.+26     	; 0x2fb8 <rpingFunction+0x4c>
    return OK_INFORM;

  state->errno = noRemoteDevice;
    2f9e:	89 e0       	ldi	r24, 0x09	; 9
    2fa0:	84 8f       	std	Z+28, r24	; 0x1c
  state->err1 = nrSterownika;
    2fa2:	65 8f       	std	Z+29, r22	; 0x1d
    2fa4:	16 8e       	std	Z+30, r1	; 0x1e
  printErrorInfo(state);
    2fa6:	c8 01       	movw	r24, r16
    2fa8:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <printErrorInfo>
  return OK_SILENT;
    2fac:	20 e0       	ldi	r18, 0x00	; 0
    2fae:	30 e0       	ldi	r19, 0x00	; 0
    2fb0:	05 c0       	rjmp	.+10     	; 0x2fbc <rpingFunction+0x50>
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    2fb2:	22 e0       	ldi	r18, 0x02	; 2
    2fb4:	30 e0       	ldi	r19, 0x00	; 0
    2fb6:	02 c0       	rjmp	.+4      	; 0x2fbc <rpingFunction+0x50>
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    return OK_INFORM;
    2fb8:	21 e0       	ldi	r18, 0x01	; 1
    2fba:	30 e0       	ldi	r19, 0x00	; 0

  state->errno = noRemoteDevice;
  state->err1 = nrSterownika;
  printErrorInfo(state);
  return OK_SILENT;
}
    2fbc:	c9 01       	movw	r24, r18
    2fbe:	0f 90       	pop	r0
    2fc0:	cf 91       	pop	r28
    2fc2:	df 91       	pop	r29
    2fc4:	1f 91       	pop	r17
    2fc6:	0f 91       	pop	r16
    2fc8:	08 95       	ret

00002fca <printStatus>:
  return ERROR_OPERATION_NOT_ALLOWED;
}

// ************************** VTY API ***************************************************************************************
void printStatus(FILE *stream)
{
    2fca:	cf 93       	push	r28
    2fcc:	df 93       	push	r29
    2fce:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
    2fd0:	00 d0       	rcall	.+0      	; 0x2fd2 <printStatus+0x8>
    2fd2:	0f 92       	push	r0
    2fd4:	ad b7       	in	r26, 0x3d	; 61
    2fd6:	be b7       	in	r27, 0x3e	; 62
    2fd8:	11 96       	adiw	r26, 0x01	; 1
    2fda:	8d 93       	st	X+, r24
    2fdc:	9c 93       	st	X, r25
    2fde:	12 97       	sbiw	r26, 0x02	; 2
    2fe0:	8c ea       	ldi	r24, 0xAC	; 172
    2fe2:	97 e0       	ldi	r25, 0x07	; 7
    2fe4:	13 96       	adiw	r26, 0x03	; 3
    2fe6:	8d 93       	st	X+, r24
    2fe8:	9c 93       	st	X, r25
    2fea:	14 97       	sbiw	r26, 0x04	; 4
    2fec:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  //Print system state
  fprintf_P(stream, systemStateStr);
    2ff0:	ed b7       	in	r30, 0x3d	; 61
    2ff2:	fe b7       	in	r31, 0x3e	; 62
    2ff4:	c1 83       	std	Z+1, r28	; 0x01
    2ff6:	d2 83       	std	Z+2, r29	; 0x02
    2ff8:	8f ef       	ldi	r24, 0xFF	; 255
    2ffa:	92 e0       	ldi	r25, 0x02	; 2
    2ffc:	83 83       	std	Z+3, r24	; 0x03
    2ffe:	94 83       	std	Z+4, r25	; 0x04
    3000:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
    3004:	0f 90       	pop	r0
    3006:	0f 90       	pop	r0
    3008:	0f 90       	pop	r0
    300a:	0f 90       	pop	r0
    300c:	0e 94 2f 49 	call	0x925e	; 0x925e <uxTaskGetNumberOfTasks>
    3010:	00 d0       	rcall	.+0      	; 0x3012 <printStatus+0x48>
    3012:	00 d0       	rcall	.+0      	; 0x3014 <printStatus+0x4a>
    3014:	ed b7       	in	r30, 0x3d	; 61
    3016:	fe b7       	in	r31, 0x3e	; 62
    3018:	31 96       	adiw	r30, 0x01	; 1
    301a:	ad b7       	in	r26, 0x3d	; 61
    301c:	be b7       	in	r27, 0x3e	; 62
    301e:	11 96       	adiw	r26, 0x01	; 1
    3020:	cd 93       	st	X+, r28
    3022:	dc 93       	st	X, r29
    3024:	12 97       	sbiw	r26, 0x02	; 2
    3026:	2f e0       	ldi	r18, 0x0F	; 15
    3028:	33 e0       	ldi	r19, 0x03	; 3
    302a:	22 83       	std	Z+2, r18	; 0x02
    302c:	33 83       	std	Z+3, r19	; 0x03
    302e:	84 83       	std	Z+4, r24	; 0x04
    3030:	15 82       	std	Z+5, r1	; 0x05
    3032:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
    3036:	ed b7       	in	r30, 0x3d	; 61
    3038:	fe b7       	in	r31, 0x3e	; 62
    303a:	36 96       	adiw	r30, 0x06	; 6
    303c:	ed bf       	out	0x3d, r30	; 61
    303e:	fe bf       	out	0x3e, r31	; 62
    3040:	0e 94 df 52 	call	0xa5be	; 0xa5be <xPortGetFreeHeapSize>
    3044:	2d b7       	in	r18, 0x3d	; 61
    3046:	3e b7       	in	r19, 0x3e	; 62
    3048:	28 50       	subi	r18, 0x08	; 8
    304a:	30 40       	sbci	r19, 0x00	; 0
    304c:	2d bf       	out	0x3d, r18	; 61
    304e:	3e bf       	out	0x3e, r19	; 62
    3050:	ed b7       	in	r30, 0x3d	; 61
    3052:	fe b7       	in	r31, 0x3e	; 62
    3054:	31 96       	adiw	r30, 0x01	; 1
    3056:	ad b7       	in	r26, 0x3d	; 61
    3058:	be b7       	in	r27, 0x3e	; 62
    305a:	11 96       	adiw	r26, 0x01	; 1
    305c:	cd 93       	st	X+, r28
    305e:	dc 93       	st	X, r29
    3060:	12 97       	sbiw	r26, 0x02	; 2
    3062:	28 e2       	ldi	r18, 0x28	; 40
    3064:	33 e0       	ldi	r19, 0x03	; 3
    3066:	22 83       	std	Z+2, r18	; 0x02
    3068:	33 83       	std	Z+3, r19	; 0x03
    306a:	84 83       	std	Z+4, r24	; 0x04
    306c:	95 83       	std	Z+5, r25	; 0x05
    306e:	88 eb       	ldi	r24, 0xB8	; 184
    3070:	9b e0       	ldi	r25, 0x0B	; 11
    3072:	86 83       	std	Z+6, r24	; 0x06
    3074:	97 83       	std	Z+7, r25	; 0x07
    3076:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
    307a:	ed b7       	in	r30, 0x3d	; 61
    307c:	fe b7       	in	r31, 0x3e	; 62
    307e:	38 96       	adiw	r30, 0x08	; 8
    3080:	ed bf       	out	0x3d, r30	; 61
    3082:	fe bf       	out	0x3e, r31	; 62
    3084:	0e 94 76 1c 	call	0x38ec	; 0x38ec <xmallocAvailable>
    3088:	2d b7       	in	r18, 0x3d	; 61
    308a:	3e b7       	in	r19, 0x3e	; 62
    308c:	28 50       	subi	r18, 0x08	; 8
    308e:	30 40       	sbci	r19, 0x00	; 0
    3090:	2d bf       	out	0x3d, r18	; 61
    3092:	3e bf       	out	0x3e, r19	; 62
    3094:	ed b7       	in	r30, 0x3d	; 61
    3096:	fe b7       	in	r31, 0x3e	; 62
    3098:	31 96       	adiw	r30, 0x01	; 1
    309a:	ad b7       	in	r26, 0x3d	; 61
    309c:	be b7       	in	r27, 0x3e	; 62
    309e:	11 96       	adiw	r26, 0x01	; 1
    30a0:	cd 93       	st	X+, r28
    30a2:	dc 93       	st	X, r29
    30a4:	12 97       	sbiw	r26, 0x02	; 2
    30a6:	22 e5       	ldi	r18, 0x52	; 82
    30a8:	33 e0       	ldi	r19, 0x03	; 3
    30aa:	22 83       	std	Z+2, r18	; 0x02
    30ac:	33 83       	std	Z+3, r19	; 0x03
    30ae:	84 83       	std	Z+4, r24	; 0x04
    30b0:	95 83       	std	Z+5, r25	; 0x05
    30b2:	80 e0       	ldi	r24, 0x00	; 0
    30b4:	97 e1       	ldi	r25, 0x17	; 23
    30b6:	86 83       	std	Z+6, r24	; 0x06
    30b8:	97 83       	std	Z+7, r25	; 0x07
    30ba:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, statusTemperatureStr, temperature); 
    30be:	20 91 06 32 	lds	r18, 0x3206
    30c2:	0f 90       	pop	r0
    30c4:	0f 90       	pop	r0
    30c6:	ed b7       	in	r30, 0x3d	; 61
    30c8:	fe b7       	in	r31, 0x3e	; 62
    30ca:	31 96       	adiw	r30, 0x01	; 1
    30cc:	ad b7       	in	r26, 0x3d	; 61
    30ce:	be b7       	in	r27, 0x3e	; 62
    30d0:	11 96       	adiw	r26, 0x01	; 1
    30d2:	cd 93       	st	X+, r28
    30d4:	dc 93       	st	X, r29
    30d6:	12 97       	sbiw	r26, 0x02	; 2
    30d8:	89 ea       	ldi	r24, 0xA9	; 169
    30da:	93 e0       	ldi	r25, 0x03	; 3
    30dc:	82 83       	std	Z+2, r24	; 0x02
    30de:	93 83       	std	Z+3, r25	; 0x03
    30e0:	24 83       	std	Z+4, r18	; 0x04
    30e2:	15 82       	std	Z+5, r1	; 0x05
    30e4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, statusVoltageStr, voltage); 
    30e8:	20 91 0e 32 	lds	r18, 0x320E
    30ec:	ed b7       	in	r30, 0x3d	; 61
    30ee:	fe b7       	in	r31, 0x3e	; 62
    30f0:	31 96       	adiw	r30, 0x01	; 1
    30f2:	ad b7       	in	r26, 0x3d	; 61
    30f4:	be b7       	in	r27, 0x3e	; 62
    30f6:	11 96       	adiw	r26, 0x01	; 1
    30f8:	cd 93       	st	X+, r28
    30fa:	dc 93       	st	X, r29
    30fc:	12 97       	sbiw	r26, 0x02	; 2
    30fe:	84 ec       	ldi	r24, 0xC4	; 196
    3100:	93 e0       	ldi	r25, 0x03	; 3
    3102:	82 83       	std	Z+2, r24	; 0x02
    3104:	93 83       	std	Z+3, r25	; 0x03
    3106:	24 83       	std	Z+4, r18	; 0x04
    3108:	15 82       	std	Z+5, r1	; 0x05
    310a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>

  uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
    310e:	ed b7       	in	r30, 0x3d	; 61
    3110:	fe b7       	in	r31, 0x3e	; 62
    3112:	36 96       	adiw	r30, 0x06	; 6
    3114:	ed bf       	out	0x3d, r30	; 61
    3116:	fe bf       	out	0x3e, r31	; 62
    3118:	0e 94 98 21 	call	0x4330	; 0x4330 <ramDyskLiczbaWolnychKlastrow>
  fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
    311c:	2d b7       	in	r18, 0x3d	; 61
    311e:	3e b7       	in	r19, 0x3e	; 62
    3120:	28 50       	subi	r18, 0x08	; 8
    3122:	30 40       	sbci	r19, 0x00	; 0
    3124:	2d bf       	out	0x3d, r18	; 61
    3126:	3e bf       	out	0x3e, r19	; 62
    3128:	ed b7       	in	r30, 0x3d	; 61
    312a:	fe b7       	in	r31, 0x3e	; 62
    312c:	31 96       	adiw	r30, 0x01	; 1
    312e:	ad b7       	in	r26, 0x3d	; 61
    3130:	be b7       	in	r27, 0x3e	; 62
    3132:	11 96       	adiw	r26, 0x01	; 1
    3134:	cd 93       	st	X+, r28
    3136:	dc 93       	st	X, r29
    3138:	12 97       	sbiw	r26, 0x02	; 2
    313a:	2c e7       	ldi	r18, 0x7C	; 124
    313c:	33 e0       	ldi	r19, 0x03	; 3
    313e:	22 83       	std	Z+2, r18	; 0x02
    3140:	33 83       	std	Z+3, r19	; 0x03
    3142:	84 83       	std	Z+4, r24	; 0x04
    3144:	15 82       	std	Z+5, r1	; 0x05
    3146:	80 e8       	ldi	r24, 0x80	; 128
    3148:	90 e0       	ldi	r25, 0x00	; 0
    314a:	86 83       	std	Z+6, r24	; 0x06
    314c:	97 83       	std	Z+7, r25	; 0x07
    314e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
//  printErrorInfo(state); //TODO fix and uncomment
  
  //Print system configuration
  fprintf_P(stream, systemRamConfigStr);
    3152:	0f 90       	pop	r0
    3154:	0f 90       	pop	r0
    3156:	0f 90       	pop	r0
    3158:	0f 90       	pop	r0
    315a:	ed b7       	in	r30, 0x3d	; 61
    315c:	fe b7       	in	r31, 0x3e	; 62
    315e:	c1 83       	std	Z+1, r28	; 0x01
    3160:	d2 83       	std	Z+2, r29	; 0x02
    3162:	8f ed       	ldi	r24, 0xDF	; 223
    3164:	93 e0       	ldi	r25, 0x03	; 3
    3166:	83 83       	std	Z+3, r24	; 0x03
    3168:	94 83       	std	Z+4, r25	; 0x04
    316a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>

  fprintf_P(stream, statusMacStr);
    316e:	ad b7       	in	r26, 0x3d	; 61
    3170:	be b7       	in	r27, 0x3e	; 62
    3172:	11 96       	adiw	r26, 0x01	; 1
    3174:	cd 93       	st	X+, r28
    3176:	dc 93       	st	X, r29
    3178:	12 97       	sbiw	r26, 0x02	; 2
    317a:	82 ef       	ldi	r24, 0xF2	; 242
    317c:	93 e0       	ldi	r25, 0x03	; 3
    317e:	13 96       	adiw	r26, 0x03	; 3
    3180:	8d 93       	st	X+, r24
    3182:	9c 93       	st	X, r25
    3184:	14 97       	sbiw	r26, 0x04	; 4
    3186:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    318a:	0f 90       	pop	r0
    318c:	0f 90       	pop	r0
    318e:	0f 90       	pop	r0
    3190:	0f 90       	pop	r0
    3192:	ce 01       	movw	r24, r28
    3194:	60 ee       	ldi	r22, 0xE0	; 224
    3196:	71 e3       	ldi	r23, 0x31	; 49
    3198:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
  fprintf_P(stream, PSTR("\r\n"));
    319c:	00 d0       	rcall	.+0      	; 0x319e <printStatus+0x1d4>
    319e:	0f 92       	push	r0
    31a0:	ed b7       	in	r30, 0x3d	; 61
    31a2:	fe b7       	in	r31, 0x3e	; 62
    31a4:	c1 83       	std	Z+1, r28	; 0x01
    31a6:	d2 83       	std	Z+2, r29	; 0x02
    31a8:	89 ea       	ldi	r24, 0xA9	; 169
    31aa:	97 e0       	ldi	r25, 0x07	; 7
    31ac:	83 83       	std	Z+3, r24	; 0x03
    31ae:	94 83       	std	Z+4, r25	; 0x04
    31b0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  
  fprintf_P(stream, statusIpStr);
    31b4:	ad b7       	in	r26, 0x3d	; 61
    31b6:	be b7       	in	r27, 0x3e	; 62
    31b8:	11 96       	adiw	r26, 0x01	; 1
    31ba:	cd 93       	st	X+, r28
    31bc:	dc 93       	st	X, r29
    31be:	12 97       	sbiw	r26, 0x02	; 2
    31c0:	87 e0       	ldi	r24, 0x07	; 7
    31c2:	94 e0       	ldi	r25, 0x04	; 4
    31c4:	13 96       	adiw	r26, 0x03	; 3
    31c6:	8d 93       	st	X+, r24
    31c8:	9c 93       	st	X, r25
    31ca:	14 97       	sbiw	r26, 0x04	; 4
    31cc:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->ip);
    31d0:	0f 90       	pop	r0
    31d2:	0f 90       	pop	r0
    31d4:	0f 90       	pop	r0
    31d6:	0f 90       	pop	r0
    31d8:	0e 94 44 33 	call	0x6688	; 0x6688 <ipGetConfig>
    31dc:	fc 01       	movw	r30, r24
    31de:	40 81       	ld	r20, Z
    31e0:	51 81       	ldd	r21, Z+1	; 0x01
    31e2:	62 81       	ldd	r22, Z+2	; 0x02
    31e4:	73 81       	ldd	r23, Z+3	; 0x03
    31e6:	ce 01       	movw	r24, r28
    31e8:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    31ec:	00 d0       	rcall	.+0      	; 0x31ee <printStatus+0x224>
    31ee:	0f 92       	push	r0
    31f0:	ad b7       	in	r26, 0x3d	; 61
    31f2:	be b7       	in	r27, 0x3e	; 62
    31f4:	11 96       	adiw	r26, 0x01	; 1
    31f6:	cd 93       	st	X+, r28
    31f8:	dc 93       	st	X, r29
    31fa:	12 97       	sbiw	r26, 0x02	; 2
    31fc:	86 ea       	ldi	r24, 0xA6	; 166
    31fe:	97 e0       	ldi	r25, 0x07	; 7
    3200:	13 96       	adiw	r26, 0x03	; 3
    3202:	8d 93       	st	X+, r24
    3204:	9c 93       	st	X, r25
    3206:	14 97       	sbiw	r26, 0x04	; 4
    3208:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>

  fprintf_P(stream, statusIpMaskStr);
    320c:	ed b7       	in	r30, 0x3d	; 61
    320e:	fe b7       	in	r31, 0x3e	; 62
    3210:	c1 83       	std	Z+1, r28	; 0x01
    3212:	d2 83       	std	Z+2, r29	; 0x02
    3214:	8c e1       	ldi	r24, 0x1C	; 28
    3216:	94 e0       	ldi	r25, 0x04	; 4
    3218:	83 83       	std	Z+3, r24	; 0x03
    321a:	94 83       	std	Z+4, r25	; 0x04
    321c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->netmask);
    3220:	0f 90       	pop	r0
    3222:	0f 90       	pop	r0
    3224:	0f 90       	pop	r0
    3226:	0f 90       	pop	r0
    3228:	0e 94 44 33 	call	0x6688	; 0x6688 <ipGetConfig>
    322c:	dc 01       	movw	r26, r24
    322e:	14 96       	adiw	r26, 0x04	; 4
    3230:	4d 91       	ld	r20, X+
    3232:	5d 91       	ld	r21, X+
    3234:	6d 91       	ld	r22, X+
    3236:	7c 91       	ld	r23, X
    3238:	17 97       	sbiw	r26, 0x07	; 7
    323a:	ce 01       	movw	r24, r28
    323c:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3240:	00 d0       	rcall	.+0      	; 0x3242 <printStatus+0x278>
    3242:	0f 92       	push	r0
    3244:	ed b7       	in	r30, 0x3d	; 61
    3246:	fe b7       	in	r31, 0x3e	; 62
    3248:	c1 83       	std	Z+1, r28	; 0x01
    324a:	d2 83       	std	Z+2, r29	; 0x02
    324c:	83 ea       	ldi	r24, 0xA3	; 163
    324e:	97 e0       	ldi	r25, 0x07	; 7
    3250:	83 83       	std	Z+3, r24	; 0x03
    3252:	94 83       	std	Z+4, r25	; 0x04
    3254:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  
  fprintf_P(stream, statusIpGwStr);
    3258:	ad b7       	in	r26, 0x3d	; 61
    325a:	be b7       	in	r27, 0x3e	; 62
    325c:	11 96       	adiw	r26, 0x01	; 1
    325e:	cd 93       	st	X+, r28
    3260:	dc 93       	st	X, r29
    3262:	12 97       	sbiw	r26, 0x02	; 2
    3264:	81 e3       	ldi	r24, 0x31	; 49
    3266:	94 e0       	ldi	r25, 0x04	; 4
    3268:	13 96       	adiw	r26, 0x03	; 3
    326a:	8d 93       	st	X+, r24
    326c:	9c 93       	st	X, r25
    326e:	14 97       	sbiw	r26, 0x04	; 4
    3270:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->gateway);
    3274:	0f 90       	pop	r0
    3276:	0f 90       	pop	r0
    3278:	0f 90       	pop	r0
    327a:	0f 90       	pop	r0
    327c:	0e 94 44 33 	call	0x6688	; 0x6688 <ipGetConfig>
    3280:	fc 01       	movw	r30, r24
    3282:	40 85       	ldd	r20, Z+8	; 0x08
    3284:	51 85       	ldd	r21, Z+9	; 0x09
    3286:	62 85       	ldd	r22, Z+10	; 0x0a
    3288:	73 85       	ldd	r23, Z+11	; 0x0b
    328a:	ce 01       	movw	r24, r28
    328c:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3290:	00 d0       	rcall	.+0      	; 0x3292 <printStatus+0x2c8>
    3292:	0f 92       	push	r0
    3294:	ad b7       	in	r26, 0x3d	; 61
    3296:	be b7       	in	r27, 0x3e	; 62
    3298:	11 96       	adiw	r26, 0x01	; 1
    329a:	cd 93       	st	X+, r28
    329c:	dc 93       	st	X, r29
    329e:	12 97       	sbiw	r26, 0x02	; 2
    32a0:	80 ea       	ldi	r24, 0xA0	; 160
    32a2:	97 e0       	ldi	r25, 0x07	; 7
    32a4:	13 96       	adiw	r26, 0x03	; 3
    32a6:	8d 93       	st	X+, r24
    32a8:	9c 93       	st	X, r25
    32aa:	14 97       	sbiw	r26, 0x04	; 4
    32ac:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  
  //Print Rs485 Execitive modules
  fprintf_P(stream, statusRs485listStr);
    32b0:	ed b7       	in	r30, 0x3d	; 61
    32b2:	fe b7       	in	r31, 0x3e	; 62
    32b4:	c1 83       	std	Z+1, r28	; 0x01
    32b6:	d2 83       	std	Z+2, r29	; 0x02
    32b8:	86 e4       	ldi	r24, 0x46	; 70
    32ba:	94 e0       	ldi	r25, 0x04	; 4
    32bc:	83 83       	std	Z+3, r24	; 0x03
    32be:	94 83       	std	Z+4, r25	; 0x04
    32c0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  tmp = printRs485devices(stream);
    32c4:	0f 90       	pop	r0
    32c6:	0f 90       	pop	r0
    32c8:	0f 90       	pop	r0
    32ca:	0f 90       	pop	r0
    32cc:	ce 01       	movw	r24, r28
    32ce:	0e 94 3b 40 	call	0x8076	; 0x8076 <printRs485devices>
  if (tmp == 0)
    32d2:	88 23       	and	r24, r24
    32d4:	a1 f4       	brne	.+40     	; 0x32fe <printStatus+0x334>
    fprintf_P(stream, statusNoRs485Dev);  
    32d6:	00 d0       	rcall	.+0      	; 0x32d8 <printStatus+0x30e>
    32d8:	0f 92       	push	r0
    32da:	ad b7       	in	r26, 0x3d	; 61
    32dc:	be b7       	in	r27, 0x3e	; 62
    32de:	11 96       	adiw	r26, 0x01	; 1
    32e0:	cd 93       	st	X+, r28
    32e2:	dc 93       	st	X, r29
    32e4:	12 97       	sbiw	r26, 0x02	; 2
    32e6:	81 e6       	ldi	r24, 0x61	; 97
    32e8:	94 e0       	ldi	r25, 0x04	; 4
    32ea:	13 96       	adiw	r26, 0x03	; 3
    32ec:	8d 93       	st	X+, r24
    32ee:	9c 93       	st	X, r25
    32f0:	14 97       	sbiw	r26, 0x04	; 4
    32f2:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    32f6:	0f 90       	pop	r0
    32f8:	0f 90       	pop	r0
    32fa:	0f 90       	pop	r0
    32fc:	0f 90       	pop	r0
  
  //Print locker sensors
  fprintf_P(stream, statusLockerSensorsStr);
    32fe:	00 d0       	rcall	.+0      	; 0x3300 <printStatus+0x336>
    3300:	0f 92       	push	r0
    3302:	ed b7       	in	r30, 0x3d	; 61
    3304:	fe b7       	in	r31, 0x3e	; 62
    3306:	c1 83       	std	Z+1, r28	; 0x01
    3308:	d2 83       	std	Z+2, r29	; 0x02
    330a:	8b e7       	ldi	r24, 0x7B	; 123
    330c:	94 e0       	ldi	r25, 0x04	; 4
    330e:	83 83       	std	Z+3, r24	; 0x03
    3310:	94 83       	std	Z+4, r25	; 0x04
    3312:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  tmp = printLockers(stream);
    3316:	0f 90       	pop	r0
    3318:	0f 90       	pop	r0
    331a:	0f 90       	pop	r0
    331c:	0f 90       	pop	r0
    331e:	ce 01       	movw	r24, r28
    3320:	0e 94 76 0b 	call	0x16ec	; 0x16ec <printLockers>
  if (tmp == 0)
    3324:	88 23       	and	r24, r24
    3326:	a1 f4       	brne	.+40     	; 0x3350 <printStatus+0x386>
    fprintf_P(stream, statusLockerSensorsDisStr);
    3328:	00 d0       	rcall	.+0      	; 0x332a <printStatus+0x360>
    332a:	0f 92       	push	r0
    332c:	ad b7       	in	r26, 0x3d	; 61
    332e:	be b7       	in	r27, 0x3e	; 62
    3330:	11 96       	adiw	r26, 0x01	; 1
    3332:	cd 93       	st	X+, r28
    3334:	dc 93       	st	X, r29
    3336:	12 97       	sbiw	r26, 0x02	; 2
    3338:	84 e9       	ldi	r24, 0x94	; 148
    333a:	94 e0       	ldi	r25, 0x04	; 4
    333c:	13 96       	adiw	r26, 0x03	; 3
    333e:	8d 93       	st	X+, r24
    3340:	9c 93       	st	X, r25
    3342:	14 97       	sbiw	r26, 0x04	; 4
    3344:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    3348:	0f 90       	pop	r0
    334a:	0f 90       	pop	r0
    334c:	0f 90       	pop	r0
    334e:	0f 90       	pop	r0
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    3350:	ce 01       	movw	r24, r28
    3352:	0e 94 06 3f 	call	0x7e0c	; 0x7e0c <udpPrintStatus>
//  arpPrintTable(stream);
}
    3356:	df 91       	pop	r29
    3358:	cf 91       	pop	r28
    335a:	08 95       	ret

0000335c <statusFunction>:


// ************************** CLI Functions *********************************************************************************

static cliExRes_t statusFunction(cmdState_t *state)
{
    335c:	ef 92       	push	r14
    335e:	ff 92       	push	r15
    3360:	0f 93       	push	r16
    3362:	1f 93       	push	r17
    3364:	df 93       	push	r29
    3366:	cf 93       	push	r28
    3368:	cd b7       	in	r28, 0x3d	; 61
    336a:	de b7       	in	r29, 0x3e	; 62
    336c:	2e 97       	sbiw	r28, 0x0e	; 14
    336e:	cd bf       	out	0x3d, r28	; 61
    3370:	de bf       	out	0x3e, r29	; 62
    3372:	7c 01       	movw	r14, r24
  if (state->argc < 1)
    3374:	dc 01       	movw	r26, r24
    3376:	59 96       	adiw	r26, 0x19	; 25
    3378:	8c 91       	ld	r24, X
    337a:	59 97       	sbiw	r26, 0x19	; 25
    337c:	88 23       	and	r24, r24
    337e:	39 f4       	brne	.+14     	; 0x338e <statusFunction+0x32>
  {
    printStatus(state->myStdInOut);
    3380:	5a 96       	adiw	r26, 0x1a	; 26
    3382:	8d 91       	ld	r24, X+
    3384:	9c 91       	ld	r25, X
    3386:	5b 97       	sbiw	r26, 0x1b	; 27
    3388:	0e 94 e5 17 	call	0x2fca	; 0x2fca <printStatus>
    338c:	37 c0       	rjmp	.+110    	; 0x33fc <statusFunction+0xa0>
    return OK_SILENT; 
  }
  
  FILE stream;
  if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
    338e:	81 e0       	ldi	r24, 0x01	; 1
    3390:	b7 01       	movw	r22, r14
    3392:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    3396:	68 ec       	ldi	r22, 0xC8	; 200
    3398:	72 e3       	ldi	r23, 0x32	; 50
    339a:	8e 01       	movw	r16, r28
    339c:	0f 5f       	subi	r16, 0xFF	; 255
    339e:	1f 4f       	sbci	r17, 0xFF	; 255
    33a0:	a8 01       	movw	r20, r16
    33a2:	23 e0       	ldi	r18, 0x03	; 3
    33a4:	0e 94 a4 21 	call	0x4348	; 0x4348 <ramDyskOtworzPlikStdIo>
    33a8:	88 23       	and	r24, r24
    33aa:	11 f1       	breq	.+68     	; 0x33f0 <statusFunction+0x94>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    33ac:	f7 01       	movw	r30, r14
    33ae:	02 8d       	ldd	r16, Z+26	; 0x1a
    33b0:	13 8d       	ldd	r17, Z+27	; 0x1b
    33b2:	81 e0       	ldi	r24, 0x01	; 1
    33b4:	b7 01       	movw	r22, r14
    33b6:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    33ba:	00 d0       	rcall	.+0      	; 0x33bc <statusFunction+0x60>
    33bc:	00 d0       	rcall	.+0      	; 0x33be <statusFunction+0x62>
    33be:	ed b7       	in	r30, 0x3d	; 61
    33c0:	fe b7       	in	r31, 0x3e	; 62
    33c2:	31 96       	adiw	r30, 0x01	; 1
    33c4:	ad b7       	in	r26, 0x3d	; 61
    33c6:	be b7       	in	r27, 0x3e	; 62
    33c8:	11 96       	adiw	r26, 0x01	; 1
    33ca:	0d 93       	st	X+, r16
    33cc:	1c 93       	st	X, r17
    33ce:	12 97       	sbiw	r26, 0x02	; 2
    33d0:	2a ee       	ldi	r18, 0xEA	; 234
    33d2:	32 e0       	ldi	r19, 0x02	; 2
    33d4:	22 83       	std	Z+2, r18	; 0x02
    33d6:	33 83       	std	Z+3, r19	; 0x03
    33d8:	84 83       	std	Z+4, r24	; 0x04
    33da:	95 83       	std	Z+5, r25	; 0x05
    33dc:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    return ERROR_INFORM;
    33e0:	ed b7       	in	r30, 0x3d	; 61
    33e2:	fe b7       	in	r31, 0x3e	; 62
    33e4:	36 96       	adiw	r30, 0x06	; 6
    33e6:	ed bf       	out	0x3d, r30	; 61
    33e8:	fe bf       	out	0x3e, r31	; 62
    33ea:	24 e0       	ldi	r18, 0x04	; 4
    33ec:	30 e0       	ldi	r19, 0x00	; 0
    33ee:	08 c0       	rjmp	.+16     	; 0x3400 <statusFunction+0xa4>
  }

  printStatus(&stream);
    33f0:	c8 01       	movw	r24, r16
    33f2:	0e 94 e5 17 	call	0x2fca	; 0x2fca <printStatus>
  ramDyskZamknijPlikStdIo(&stream);
    33f6:	c8 01       	movw	r24, r16
    33f8:	0e 94 c9 21 	call	0x4392	; 0x4392 <ramDyskZamknijPlikStdIo>
  return OK_SILENT; 
    33fc:	20 e0       	ldi	r18, 0x00	; 0
    33fe:	30 e0       	ldi	r19, 0x00	; 0
}
    3400:	c9 01       	movw	r24, r18
    3402:	2e 96       	adiw	r28, 0x0e	; 14
    3404:	cd bf       	out	0x3d, r28	; 61
    3406:	de bf       	out	0x3e, r29	; 62
    3408:	cf 91       	pop	r28
    340a:	df 91       	pop	r29
    340c:	1f 91       	pop	r17
    340e:	0f 91       	pop	r16
    3410:	ff 90       	pop	r15
    3412:	ef 90       	pop	r14
    3414:	08 95       	ret

00003416 <encTask>:
//   return 0;
// }


void encTask ( void *pvParameters )
{
    3416:	ef 92       	push	r14
    3418:	ff 92       	push	r15
    341a:	0f 93       	push	r16
    341c:	1f 93       	push	r17
    341e:	cf 93       	push	r28
    3420:	df 93       	push	r29
  FILE *netstackDebug = (FILE *) pvParameters;
    3422:	e8 2e       	mov	r14, r24
    3424:	e7 01       	movw	r28, r14
    3426:	7e 01       	movw	r14, r28
    3428:	f9 2e       	mov	r15, r25
    342a:	e7 01       	movw	r28, r14
  uint16_t plen;

  nicInit();
    342c:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <nicInit>
  ipInit();
    3430:	0e 94 ed 31 	call	0x63da	; 0x63da <ipInit>
  arpInit();
    3434:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <arpInit>
  icmpInit();
    3438:	0e 94 c3 34 	call	0x6986	; 0x6986 <icmpInit>
    }
    else
    {
      if (netstackDebug != NULL)
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    343c:	0e ed       	ldi	r16, 0xDE	; 222
    343e:	17 e0       	ldi	r17, 0x07	; 7
  //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);
  
  
  for ( ; ; )
  {
    vTaskDelay ( 0 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwolniony po odebrzeniu przerwania od ENC
    3440:	80 e0       	ldi	r24, 0x00	; 0
    3442:	90 e0       	ldi	r25, 0x00	; 0
    3444:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    
    // get the next new packet:
    plen = nicPoll();
    3448:	0e 94 66 2b 	call	0x56cc	; 0x56cc <nicPoll>
    /*plen will ne unequal to zero if there is a valid
    * packet (without crc error) */
    if ( plen==0 )
    344c:	00 97       	sbiw	r24, 0x00	; 0
    344e:	29 f4       	brne	.+10     	; 0x345a <encTask+0x44>
    {
      flushUdpQueues();
    3450:	0e 94 b5 3e 	call	0x7d6a	; 0x7d6a <flushUdpQueues>
      flushTcpQueues();
    3454:	0e 94 04 3d 	call	0x7a08	; 0x7a08 <flushTcpQueues>
      //flush HTTP long file queue 
      continue;
    3458:	f3 cf       	rjmp	.-26     	; 0x3440 <encTask+0x2a>
    }
    
    if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
    345a:	e0 91 e6 31 	lds	r30, 0x31E6
    345e:	f0 91 e7 31 	lds	r31, 0x31E7
    3462:	e4 84       	ldd	r14, Z+12	; 0x0c
    3464:	f5 84       	ldd	r15, Z+13	; 0x0d
    3466:	80 e0       	ldi	r24, 0x00	; 0
    3468:	98 e0       	ldi	r25, 0x08	; 8
    346a:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    346e:	e8 16       	cp	r14, r24
    3470:	f9 06       	cpc	r15, r25
    3472:	29 f4       	brne	.+10     	; 0x347e <encTask+0x68>
    {
      arpIpIn();
    3474:	0e 94 e0 36 	call	0x6dc0	; 0x6dc0 <arpIpIn>
      netstackIPv4Process();
    3478:	0e 94 3d 32 	call	0x647a	; 0x647a <netstackIPv4Process>
    347c:	e1 cf       	rjmp	.-62     	; 0x3440 <encTask+0x2a>
    }
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
    347e:	e0 91 e6 31 	lds	r30, 0x31E6
    3482:	f0 91 e7 31 	lds	r31, 0x31E7
    3486:	e4 84       	ldd	r14, Z+12	; 0x0c
    3488:	f5 84       	ldd	r15, Z+13	; 0x0d
    348a:	86 e0       	ldi	r24, 0x06	; 6
    348c:	98 e0       	ldi	r25, 0x08	; 8
    348e:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    3492:	e8 16       	cp	r14, r24
    3494:	f9 06       	cpc	r15, r25
    3496:	19 f4       	brne	.+6      	; 0x349e <encTask+0x88>
    {
      arpArpIn();
    3498:	0e 94 97 38 	call	0x712e	; 0x712e <arpArpIn>
    349c:	d1 cf       	rjmp	.-94     	; 0x3440 <encTask+0x2a>
    }
    else
    {
      if (netstackDebug != NULL)
    349e:	20 97       	sbiw	r28, 0x00	; 0
    34a0:	79 f2       	breq	.-98     	; 0x3440 <encTask+0x2a>
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    34a2:	00 d0       	rcall	.+0      	; 0x34a4 <encTask+0x8e>
    34a4:	0f 92       	push	r0
    34a6:	ed b7       	in	r30, 0x3d	; 61
    34a8:	fe b7       	in	r31, 0x3e	; 62
    34aa:	c1 83       	std	Z+1, r28	; 0x01
    34ac:	d2 83       	std	Z+2, r29	; 0x02
    34ae:	03 83       	std	Z+3, r16	; 0x03
    34b0:	14 83       	std	Z+4, r17	; 0x04
    34b2:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    34b6:	0f 90       	pop	r0
    34b8:	0f 90       	pop	r0
    34ba:	0f 90       	pop	r0
    34bc:	0f 90       	pop	r0
    34be:	c0 cf       	rjmp	.-128    	; 0x3440 <encTask+0x2a>

000034c0 <vTaskVTYusb>:
#include "cli_task.h"

void vTaskVTYusb(void *cliStatePtr)
{
    34c0:	ef 92       	push	r14
    34c2:	ff 92       	push	r15
    34c4:	0f 93       	push	r16
    34c6:	1f 93       	push	r17
    34c8:	df 93       	push	r29
    34ca:	cf 93       	push	r28
    34cc:	0f 92       	push	r0
    34ce:	cd b7       	in	r28, 0x3d	; 61
    34d0:	de b7       	in	r29, 0x3e	; 62
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    34d2:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Restart\r\n"));
    34d4:	00 d0       	rcall	.+0      	; 0x34d6 <vTaskVTYusb+0x16>
    34d6:	0f 92       	push	r0
    34d8:	fc 01       	movw	r30, r24
    34da:	82 8d       	ldd	r24, Z+26	; 0x1a
    34dc:	93 8d       	ldd	r25, Z+27	; 0x1b
    34de:	ed b7       	in	r30, 0x3d	; 61
    34e0:	fe b7       	in	r31, 0x3e	; 62
    34e2:	81 83       	std	Z+1, r24	; 0x01
    34e4:	92 83       	std	Z+2, r25	; 0x02
    34e6:	8f ee       	ldi	r24, 0xEF	; 239
    34e8:	97 e0       	ldi	r25, 0x07	; 7
    34ea:	83 83       	std	Z+3, r24	; 0x03
    34ec:	94 83       	std	Z+4, r25	; 0x04
    34ee:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  cmdlineInputFunc('\r', state);
    34f2:	0f 90       	pop	r0
    34f4:	0f 90       	pop	r0
    34f6:	0f 90       	pop	r0
    34f8:	0f 90       	pop	r0
    34fa:	8d e0       	ldi	r24, 0x0D	; 13
    34fc:	b8 01       	movw	r22, r16
    34fe:	0e 94 19 23 	call	0x4632	; 0x4632 <cmdlineInputFunc>
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    3502:	7e 01       	movw	r14, r28
    3504:	08 94       	sec
    3506:	e1 1c       	adc	r14, r1
    3508:	f1 1c       	adc	r15, r1
    350a:	80 91 0f 32 	lds	r24, 0x320F
    350e:	90 91 10 32 	lds	r25, 0x3210
    3512:	b7 01       	movw	r22, r14
    3514:	4f ef       	ldi	r20, 0xFF	; 255
    3516:	5f ef       	ldi	r21, 0xFF	; 255
    3518:	20 e0       	ldi	r18, 0x00	; 0
    351a:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    351e:	88 23       	and	r24, r24
    3520:	a1 f3       	breq	.-24     	; 0x350a <vTaskVTYusb+0x4a>
    {
      cmdlineInputFunc((char)znak, state);
    3522:	89 81       	ldd	r24, Y+1	; 0x01
    3524:	b8 01       	movw	r22, r16
    3526:	0e 94 19 23 	call	0x4632	; 0x4632 <cmdlineInputFunc>
      cmdlineMainLoop(state);
    352a:	c8 01       	movw	r24, r16
    352c:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <cmdlineMainLoop>
    3530:	ec cf       	rjmp	.-40     	; 0x350a <vTaskVTYusb+0x4a>

00003532 <vTaskUSB>:
    }  
  }
}
void vTaskUSB(void *cliStatePtr)
{
    3532:	1f 93       	push	r17
(void) cliStatePtr;; 
 for(;;)
 {
  vTaskDelay(200);
  USARTD0.DATA='a';
    3534:	11 e6       	ldi	r17, 0x61	; 97
void vTaskUSB(void *cliStatePtr)
{
(void) cliStatePtr;; 
 for(;;)
 {
  vTaskDelay(200);
    3536:	88 ec       	ldi	r24, 0xC8	; 200
    3538:	90 e0       	ldi	r25, 0x00	; 0
    353a:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
  USARTD0.DATA='a';
    353e:	10 93 a0 09 	sts	0x09A0, r17
    3542:	f9 cf       	rjmp	.-14     	; 0x3536 <vTaskUSB+0x4>

00003544 <vTaskVTYsocket>:
 }
}

void vTaskVTYsocket(void *cliStatePtr)
{
    3544:	ef 92       	push	r14
    3546:	ff 92       	push	r15
    3548:	cf 93       	push	r28
    354a:	df 93       	push	r29
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    354c:	e8 2e       	mov	r14, r24
    354e:	e7 01       	movw	r28, r14
    3550:	7e 01       	movw	r14, r28
    3552:	f9 2e       	mov	r15, r25
    3554:	e7 01       	movw	r28, r14
  
  char znak;
  for( ;; )
  {
    znak = 0;
    znak = fgetc(state->myStdInOut);
    3556:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3558:	9b 8d       	ldd	r25, Y+27	; 0x1b
    355a:	0e 94 7e 57 	call	0xaefc	; 0xaefc <fgetc>
    cmdlineInputFunc((char)znak, state);
    355e:	be 01       	movw	r22, r28
    3560:	0e 94 19 23 	call	0x4632	; 0x4632 <cmdlineInputFunc>
    cmdlineMainLoop(state);
    3564:	ce 01       	movw	r24, r28
    3566:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <cmdlineMainLoop>
    356a:	f5 cf       	rjmp	.-22     	; 0x3556 <vTaskVTYsocket+0x12>

0000356c <vTasklcd>:
void vTasklcd(void *cliStatePtr)
{
    
    for(;;)
    {
      vTaskDelay(100);
    356c:	84 e6       	ldi	r24, 0x64	; 100
    356e:	90 e0       	ldi	r25, 0x00	; 0
    3570:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
      lcdWrite('a');
    3574:	81 e6       	ldi	r24, 0x61	; 97
    3576:	0e 94 1d 1b 	call	0x363a	; 0x363a <lcdWrite>
    357a:	f8 cf       	rjmp	.-16     	; 0x356c <vTasklcd>

0000357c <odwroc>:
#include<lcd.h>
// PB5 D4, PB2 D7
unsigned char odwroc(unsigned char dana)
{
	unsigned char pomoc=0xFF;
	if(dana&0x01) pomoc|=0x80;
    357c:	98 2f       	mov	r25, r24
    357e:	80 ff       	sbrs	r24, 0
    3580:	02 c0       	rjmp	.+4      	; 0x3586 <odwroc+0xa>
    3582:	2f ef       	ldi	r18, 0xFF	; 255
    3584:	01 c0       	rjmp	.+2      	; 0x3588 <odwroc+0xc>
	else pomoc&=~0x80;
    3586:	2f e7       	ldi	r18, 0x7F	; 127
	if(dana&0x02) pomoc|=0x40;
    3588:	91 ff       	sbrs	r25, 1
    358a:	02 c0       	rjmp	.+4      	; 0x3590 <odwroc+0x14>
    358c:	20 64       	ori	r18, 0x40	; 64
    358e:	01 c0       	rjmp	.+2      	; 0x3592 <odwroc+0x16>
	else pomoc|=~0x40;
    3590:	2f 6b       	ori	r18, 0xBF	; 191
	if(dana&0x04) pomoc|=0x20;
    3592:	92 ff       	sbrs	r25, 2
    3594:	02 c0       	rjmp	.+4      	; 0x359a <odwroc+0x1e>
    3596:	20 62       	ori	r18, 0x20	; 32
    3598:	01 c0       	rjmp	.+2      	; 0x359c <odwroc+0x20>
	else pomoc&=~0x20;
    359a:	2f 7d       	andi	r18, 0xDF	; 223
	if(dana&0x08) pomoc|=0x10;
    359c:	93 ff       	sbrs	r25, 3
    359e:	02 c0       	rjmp	.+4      	; 0x35a4 <odwroc+0x28>
    35a0:	20 61       	ori	r18, 0x10	; 16
    35a2:	01 c0       	rjmp	.+2      	; 0x35a6 <odwroc+0x2a>
	else pomoc&=~0x10;
    35a4:	2f 7e       	andi	r18, 0xEF	; 239
	if(dana&0x10) pomoc|=0x08;
    35a6:	94 ff       	sbrs	r25, 4
    35a8:	02 c0       	rjmp	.+4      	; 0x35ae <odwroc+0x32>
    35aa:	28 60       	ori	r18, 0x08	; 8
    35ac:	01 c0       	rjmp	.+2      	; 0x35b0 <odwroc+0x34>
	else pomoc&=~0x08;
    35ae:	27 7f       	andi	r18, 0xF7	; 247
	if(dana&0x20) pomoc|=0x04;
    35b0:	95 ff       	sbrs	r25, 5
    35b2:	02 c0       	rjmp	.+4      	; 0x35b8 <odwroc+0x3c>
    35b4:	24 60       	ori	r18, 0x04	; 4
    35b6:	01 c0       	rjmp	.+2      	; 0x35ba <odwroc+0x3e>
	else pomoc&=~0x04;
    35b8:	2b 7f       	andi	r18, 0xFB	; 251
	if(dana&0x40) pomoc|=0x02;
    35ba:	96 ff       	sbrs	r25, 6
    35bc:	03 c0       	rjmp	.+6      	; 0x35c4 <odwroc+0x48>
    35be:	92 2f       	mov	r25, r18
    35c0:	92 60       	ori	r25, 0x02	; 2
    35c2:	02 c0       	rjmp	.+4      	; 0x35c8 <odwroc+0x4c>
	else pomoc&=~0x02;
    35c4:	92 2f       	mov	r25, r18
    35c6:	9d 7f       	andi	r25, 0xFD	; 253
	if(dana&0x80) pomoc|=0x01;
    35c8:	87 ff       	sbrs	r24, 7
    35ca:	03 c0       	rjmp	.+6      	; 0x35d2 <odwroc+0x56>
    35cc:	89 2f       	mov	r24, r25
    35ce:	81 60       	ori	r24, 0x01	; 1
    35d0:	08 95       	ret
	else pomoc&=~0x01;
    35d2:	89 2f       	mov	r24, r25
    35d4:	8e 7f       	andi	r24, 0xFE	; 254

	return pomoc;	
}
    35d6:	08 95       	ret

000035d8 <polbajt>:
void polbajt(unsigned char data)
{
  if(data&0x01)
    35d8:	80 ff       	sbrs	r24, 0
    35da:	04 c0       	rjmp	.+8      	; 0x35e4 <polbajt+0xc>
  {
	  PORTB.OUT|=LCD_D4;
    35dc:	20 91 24 06 	lds	r18, 0x0624
    35e0:	20 62       	ori	r18, 0x20	; 32
    35e2:	03 c0       	rjmp	.+6      	; 0x35ea <polbajt+0x12>
  }
  else
  {
	  PORTB.OUT&=~LCD_D4;
    35e4:	20 91 24 06 	lds	r18, 0x0624
    35e8:	2f 7d       	andi	r18, 0xDF	; 223
    35ea:	e0 e2       	ldi	r30, 0x20	; 32
    35ec:	f6 e0       	ldi	r31, 0x06	; 6
    35ee:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x02)
    35f0:	81 ff       	sbrs	r24, 1
    35f2:	04 c0       	rjmp	.+8      	; 0x35fc <polbajt+0x24>
  {
	  PORTB.OUT|=LCD_D5;
    35f4:	20 91 24 06 	lds	r18, 0x0624
    35f8:	20 61       	ori	r18, 0x10	; 16
    35fa:	03 c0       	rjmp	.+6      	; 0x3602 <polbajt+0x2a>
  }
  else
  {
	  PORTB.OUT&=~LCD_D5;
    35fc:	20 91 24 06 	lds	r18, 0x0624
    3600:	2f 7e       	andi	r18, 0xEF	; 239
    3602:	e0 e2       	ldi	r30, 0x20	; 32
    3604:	f6 e0       	ldi	r31, 0x06	; 6
    3606:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x04)
    3608:	82 ff       	sbrs	r24, 2
    360a:	04 c0       	rjmp	.+8      	; 0x3614 <polbajt+0x3c>
  {
	  PORTB.OUT|=LCD_D6;
    360c:	20 91 24 06 	lds	r18, 0x0624
    3610:	28 60       	ori	r18, 0x08	; 8
    3612:	03 c0       	rjmp	.+6      	; 0x361a <polbajt+0x42>
  }
  else
  {
	  PORTB.OUT&=~LCD_D6;
    3614:	20 91 24 06 	lds	r18, 0x0624
    3618:	27 7f       	andi	r18, 0xF7	; 247
    361a:	e0 e2       	ldi	r30, 0x20	; 32
    361c:	f6 e0       	ldi	r31, 0x06	; 6
    361e:	24 83       	std	Z+4, r18	; 0x04
  }

  if(data&0x08)
    3620:	83 ff       	sbrs	r24, 3
    3622:	04 c0       	rjmp	.+8      	; 0x362c <polbajt+0x54>
  {
	  PORTB.OUT|=LCD_D7;
    3624:	80 91 24 06 	lds	r24, 0x0624
    3628:	84 60       	ori	r24, 0x04	; 4
    362a:	03 c0       	rjmp	.+6      	; 0x3632 <polbajt+0x5a>
  }
  else
  {
	  PORTB.OUT&=~LCD_D7;
    362c:	80 91 24 06 	lds	r24, 0x0624
    3630:	8b 7f       	andi	r24, 0xFB	; 251
    3632:	e0 e2       	ldi	r30, 0x20	; 32
    3634:	f6 e0       	ldi	r31, 0x06	; 6
    3636:	84 83       	std	Z+4, r24	; 0x04
    3638:	08 95       	ret

0000363a <lcdWrite>:
{
LCD_RS_clear;
lcdWrite(command);
}
void lcdWrite(unsigned char data)
{
    363a:	0f 93       	push	r16
    363c:	1f 93       	push	r17
    363e:	cf 93       	push	r28
    3640:	df 93       	push	r29
    3642:	18 2f       	mov	r17, r24
uint8_t pomoc=odwroc(data>>4);
    3644:	82 95       	swap	r24
    3646:	8f 70       	andi	r24, 0x0F	; 15
    3648:	0e 94 be 1a 	call	0x357c	; 0x357c <odwroc>
    364c:	08 2f       	mov	r16, r24
data=odwroc(data);
    364e:	81 2f       	mov	r24, r17
    3650:	0e 94 be 1a 	call	0x357c	; 0x357c <odwroc>
    3654:	18 2f       	mov	r17, r24
LCD_E_set;
    3656:	c0 e0       	ldi	r28, 0x00	; 0
    3658:	d6 e0       	ldi	r29, 0x06	; 6
    365a:	8c 81       	ldd	r24, Y+4	; 0x04
    365c:	83 60       	ori	r24, 0x03	; 3
    365e:	8c 83       	std	Y+4, r24	; 0x04
polbajt(pomoc);
    3660:	80 2f       	mov	r24, r16
    3662:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <polbajt>
LCD_E_clear;
    3666:	8c 81       	ldd	r24, Y+4	; 0x04
    3668:	8d 7f       	andi	r24, 0xFD	; 253
    366a:	8c 83       	std	Y+4, r24	; 0x04
LCD_E_set;
    366c:	8c 81       	ldd	r24, Y+4	; 0x04
    366e:	83 60       	ori	r24, 0x03	; 3
    3670:	8c 83       	std	Y+4, r24	; 0x04
polbajt(data);
    3672:	81 2f       	mov	r24, r17
    3674:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <polbajt>
LCD_E_clear;
    3678:	8c 81       	ldd	r24, Y+4	; 0x04
    367a:	8d 7f       	andi	r24, 0xFD	; 253
    367c:	8c 83       	std	Y+4, r24	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    367e:	87 ec       	ldi	r24, 0xC7	; 199
    3680:	90 e0       	ldi	r25, 0x00	; 0
    3682:	01 97       	sbiw	r24, 0x01	; 1
    3684:	f1 f7       	brne	.-4      	; 0x3682 <lcdWrite+0x48>
    3686:	00 c0       	rjmp	.+0      	; 0x3688 <lcdWrite+0x4e>
    3688:	00 00       	nop
_delay_us(50);
}
    368a:	df 91       	pop	r29
    368c:	cf 91       	pop	r28
    368e:	1f 91       	pop	r17
    3690:	0f 91       	pop	r16
    3692:	08 95       	ret

00003694 <lcdwritecommand>:
	  PORTB.OUT&=~LCD_D7;
  }
}
void lcdwritecommand(unsigned char command)
{
LCD_RS_clear;
    3694:	e0 e0       	ldi	r30, 0x00	; 0
    3696:	f6 e0       	ldi	r31, 0x06	; 6
    3698:	94 81       	ldd	r25, Z+4	; 0x04
    369a:	9b 7f       	andi	r25, 0xFB	; 251
    369c:	94 83       	std	Z+4, r25	; 0x04
lcdWrite(command);
    369e:	0e 94 1d 1b 	call	0x363a	; 0x363a <lcdWrite>
}
    36a2:	08 95       	ret

000036a4 <lcdsend>:
LCD_E_clear;
_delay_us(50);
}
void lcdsend(unsigned char data)
{
LCD_RS_set;
    36a4:	e0 e0       	ldi	r30, 0x00	; 0
    36a6:	f6 e0       	ldi	r31, 0x06	; 6
    36a8:	94 81       	ldd	r25, Z+4	; 0x04
    36aa:	94 60       	ori	r25, 0x04	; 4
    36ac:	94 83       	std	Z+4, r25	; 0x04
lcdWrite(data);
    36ae:	0e 94 1d 1b 	call	0x363a	; 0x363a <lcdWrite>
}
    36b2:	08 95       	ret

000036b4 <lcdclear>:
void lcdclear(void)
{
lcdwritecommand(0x01);
    36b4:	81 e0       	ldi	r24, 0x01	; 1
    36b6:	0e 94 4a 1b 	call	0x3694	; 0x3694 <lcdwritecommand>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    36ba:	8f e3       	ldi	r24, 0x3F	; 63
    36bc:	9f e1       	ldi	r25, 0x1F	; 31
    36be:	01 97       	sbiw	r24, 0x01	; 1
    36c0:	f1 f7       	brne	.-4      	; 0x36be <lcdclear+0xa>
    36c2:	00 c0       	rjmp	.+0      	; 0x36c4 <lcdclear+0x10>
    36c4:	00 00       	nop
_delay_ms(2);
}
    36c6:	08 95       	ret

000036c8 <lcdinit>:
void lcdinit(void)
{// PB5 D4, PB2 D7
    36c8:	cf 93       	push	r28
    36ca:	df 93       	push	r29

	PORTB.DIR|=(PIN5_bm|PIN4_bm|PIN3_bm|PIN2_bm);
    36cc:	80 91 20 06 	lds	r24, 0x0620
    36d0:	8c 63       	ori	r24, 0x3C	; 60
    36d2:	80 93 20 06 	sts	0x0620, r24
	PORTA.DIR|=(PIN1_bm|PIN2_bm);
    36d6:	e0 e0       	ldi	r30, 0x00	; 0
    36d8:	f6 e0       	ldi	r31, 0x06	; 6
    36da:	80 91 00 06 	lds	r24, 0x0600
    36de:	86 60       	ori	r24, 0x06	; 6
    36e0:	80 93 00 06 	sts	0x0600, r24
	LCD_E_set;
    36e4:	80 91 04 06 	lds	r24, 0x0604
    36e8:	83 60       	ori	r24, 0x03	; 3
    36ea:	84 83       	std	Z+4, r24	; 0x04
	LCD_RS_set;
    36ec:	80 91 04 06 	lds	r24, 0x0604
    36f0:	84 60       	ori	r24, 0x04	; 4
    36f2:	84 83       	std	Z+4, r24	; 0x04
    36f4:	8f e5       	ldi	r24, 0x5F	; 95
    36f6:	9a ee       	ldi	r25, 0xEA	; 234
    36f8:	01 97       	sbiw	r24, 0x01	; 1
    36fa:	f1 f7       	brne	.-4      	; 0x36f8 <lcdinit+0x30>
    36fc:	00 c0       	rjmp	.+0      	; 0x36fe <lcdinit+0x36>
    36fe:	00 00       	nop
	_delay_ms(15);
	LCD_RS_clear;
    3700:	80 91 04 06 	lds	r24, 0x0604
    3704:	8b 7f       	andi	r24, 0xFB	; 251
    3706:	84 83       	std	Z+4, r24	; 0x04
	LCD_E_clear;
    3708:	80 91 04 06 	lds	r24, 0x0604
    370c:	8d 7f       	andi	r24, 0xFD	; 253
    370e:	84 83       	std	Z+4, r24	; 0x04
    3710:	83 e0       	ldi	r24, 0x03	; 3
    3712:	90 e0       	ldi	r25, 0x00	; 0
	for(int i = 0; i < 3; i++) 
	{
	   LCD_E_set;
	   PORTB.OUT&=0xF3;
    3714:	40 e2       	ldi	r20, 0x20	; 32
    3716:	56 e0       	ldi	r21, 0x06	; 6
	_delay_ms(15);
	LCD_RS_clear;
	LCD_E_clear;
	for(int i = 0; i < 3; i++) 
	{
	   LCD_E_set;
    3718:	c0 e0       	ldi	r28, 0x00	; 0
    371a:	d6 e0       	ldi	r29, 0x06	; 6
    371c:	20 91 04 06 	lds	r18, 0x0604
    3720:	23 60       	ori	r18, 0x03	; 3
    3722:	24 83       	std	Z+4, r18	; 0x04
	   PORTB.OUT&=0xF3;
    3724:	20 91 24 06 	lds	r18, 0x0624
    3728:	23 7f       	andi	r18, 0xF3	; 243
    372a:	da 01       	movw	r26, r20
    372c:	14 96       	adiw	r26, 0x04	; 4
    372e:	2c 93       	st	X, r18
    3730:	14 97       	sbiw	r26, 0x04	; 4
	   LCD_E_clear;	
    3732:	20 91 04 06 	lds	r18, 0x0604
    3736:	2d 7f       	andi	r18, 0xFD	; 253
    3738:	24 83       	std	Z+4, r18	; 0x04
    373a:	af e1       	ldi	r26, 0x1F	; 31
    373c:	be e4       	ldi	r27, 0x4E	; 78
    373e:	11 97       	sbiw	r26, 0x01	; 1
    3740:	f1 f7       	brne	.-4      	; 0x373e <lcdinit+0x76>
    3742:	00 c0       	rjmp	.+0      	; 0x3744 <lcdinit+0x7c>
    3744:	00 00       	nop
    3746:	01 97       	sbiw	r24, 0x01	; 1
	LCD_E_set;
	LCD_RS_set;
	_delay_ms(15);
	LCD_RS_clear;
	LCD_E_clear;
	for(int i = 0; i < 3; i++) 
    3748:	39 f7       	brne	.-50     	; 0x3718 <lcdinit+0x50>
	   LCD_E_set;
	   PORTB.OUT&=0xF3;
	   LCD_E_clear;	
	   _delay_ms(5); // czekaj 5ms
	}
	LCD_E_set;
    374a:	80 91 04 06 	lds	r24, 0x0604
    374e:	83 60       	ori	r24, 0x03	; 3
    3750:	8c 83       	std	Y+4, r24	; 0x04
	polbajt(0x02); //tryb 4 bitowy
    3752:	82 e0       	ldi	r24, 0x02	; 2
    3754:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <polbajt>
	LCD_E_clear;
    3758:	80 91 04 06 	lds	r24, 0x0604
    375c:	8d 7f       	andi	r24, 0xFD	; 253
    375e:	8c 83       	std	Y+4, r24	; 0x04
    3760:	8f e9       	ldi	r24, 0x9F	; 159
    3762:	9f e0       	ldi	r25, 0x0F	; 15
    3764:	01 97       	sbiw	r24, 0x01	; 1
    3766:	f1 f7       	brne	.-4      	; 0x3764 <lcdinit+0x9c>
    3768:	00 c0       	rjmp	.+0      	; 0x376a <lcdinit+0xa2>
    376a:	00 00       	nop
	_delay_ms(1); // czekaj 1ms 
	lcdwritecommand(0x20|0|8|0);
    376c:	88 e2       	ldi	r24, 0x28	; 40
    376e:	0e 94 4a 1b 	call	0x3694	; 0x3694 <lcdwritecommand>
	lcdwritecommand(0x80|0);
    3772:	80 e8       	ldi	r24, 0x80	; 128
    3774:	0e 94 4a 1b 	call	0x3694	; 0x3694 <lcdwritecommand>
	lcdwritecommand(0x01);
    3778:	81 e0       	ldi	r24, 0x01	; 1
    377a:	0e 94 4a 1b 	call	0x3694	; 0x3694 <lcdwritecommand>
    377e:	af e3       	ldi	r26, 0x3F	; 63
    3780:	bf e1       	ldi	r27, 0x1F	; 31
    3782:	11 97       	sbiw	r26, 0x01	; 1
    3784:	f1 f7       	brne	.-4      	; 0x3782 <lcdinit+0xba>
    3786:	00 c0       	rjmp	.+0      	; 0x3788 <lcdinit+0xc0>
    3788:	00 00       	nop
	_delay_ms(2); // czekaj 2ms 
	lcdwritecommand(0x04|0|2);
    378a:	86 e0       	ldi	r24, 0x06	; 6
    378c:	0e 94 4a 1b 	call	0x3694	; 0x3694 <lcdwritecommand>
	lcdwritecommand(0x08|4|2|1);	
    3790:	8f e0       	ldi	r24, 0x0F	; 15
    3792:	0e 94 4a 1b 	call	0x3694	; 0x3694 <lcdwritecommand>
}
    3796:	df 91       	pop	r29
    3798:	cf 91       	pop	r28
    379a:	08 95       	ret

0000379c <spiInit>:
#include "semphr.h"


void spiInit(void (*disableAllSpiDevicesFun)(void))
{
  disableAllSpiDevicesFun();
    379c:	fc 01       	movw	r30, r24
    379e:	19 95       	eicall
  portENTER_CRITICAL();
    37a0:	0f b6       	in	r0, 0x3f	; 63
    37a2:	f8 94       	cli
    37a4:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    37a6:	81 e0       	ldi	r24, 0x01	; 1
    37a8:	60 e0       	ldi	r22, 0x00	; 0
    37aa:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    37ae:	80 93 22 32 	sts	0x3222, r24
    37b2:	90 93 23 32 	sts	0x3223, r25
    37b6:	00 97       	sbiw	r24, 0x00	; 0
    37b8:	39 f0       	breq	.+14     	; 0x37c8 <spiInit+0x2c>
    37ba:	60 e0       	ldi	r22, 0x00	; 0
    37bc:	70 e0       	ldi	r23, 0x00	; 0
    37be:	40 e0       	ldi	r20, 0x00	; 0
    37c0:	50 e0       	ldi	r21, 0x00	; 0
    37c2:	20 e0       	ldi	r18, 0x00	; 0
    37c4:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>

  //SPCR  = (1<<SPE)|(1<<MSTR)|(1<<SPIE);  //TODO Adam: użyć odpowiednich nazw rejestrów
  //SPSR |= (1<<SPI2X);
  SPID.CTRL=(1<<SPI_ENABLE_bp)|(1<<SPI_MASTER_bp);
    37c8:	80 e5       	ldi	r24, 0x50	; 80
    37ca:	80 93 c0 09 	sts	0x09C0, r24
  SPID.INTCTRL|=(1<<SPI_INTLVL1_bp);//0x01;
    37ce:	80 91 c1 09 	lds	r24, 0x09C1
    37d2:	82 60       	ori	r24, 0x02	; 2
    37d4:	e0 ec       	ldi	r30, 0xC0	; 192
    37d6:	f9 e0       	ldi	r31, 0x09	; 9
    37d8:	81 83       	std	Z+1, r24	; 0x01
  SPID.CTRL|=(1<<SPI_CLK2X_bp);
    37da:	80 91 c0 09 	lds	r24, 0x09C0
    37de:	80 68       	ori	r24, 0x80	; 128
    37e0:	80 93 c0 09 	sts	0x09C0, r24
  portEXIT_CRITICAL();
    37e4:	0f 90       	pop	r0
    37e6:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    37e8:	08 95       	ret

000037ea <spiInitENC>:
void spiInitENC(void (*disableAllSpiDevicesFun)(void)) // PORTC
{
  disableAllSpiDevicesFun();
    37ea:	fc 01       	movw	r30, r24
    37ec:	19 95       	eicall
  portENTER_CRITICAL();
    37ee:	0f b6       	in	r0, 0x3f	; 63
    37f0:	f8 94       	cli
    37f2:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    37f4:	81 e0       	ldi	r24, 0x01	; 1
    37f6:	60 e0       	ldi	r22, 0x00	; 0
    37f8:	0e 94 0a 4d 	call	0x9a14	; 0x9a14 <xQueueCreate>
    37fc:	80 93 22 32 	sts	0x3222, r24
    3800:	90 93 23 32 	sts	0x3223, r25
    3804:	00 97       	sbiw	r24, 0x00	; 0
    3806:	39 f0       	breq	.+14     	; 0x3816 <spiInitENC+0x2c>
    3808:	60 e0       	ldi	r22, 0x00	; 0
    380a:	70 e0       	ldi	r23, 0x00	; 0
    380c:	40 e0       	ldi	r20, 0x00	; 0
    380e:	50 e0       	ldi	r21, 0x00	; 0
    3810:	20 e0       	ldi	r18, 0x00	; 0
    3812:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>

  //SPCR  = (1<<SPE)|(1<<MSTR)|(1<<SPIE);  //TODO Adam: użyć odpowiednich nazw rejestrów
  //SPSR |= (1<<SPI2X);
  SPIC.CTRL=(1<<SPI_ENABLE_bp)|(1<<SPI_MASTER_bp);
    3816:	80 e5       	ldi	r24, 0x50	; 80
    3818:	80 93 c0 08 	sts	0x08C0, r24
  SPIC.INTCTRL|=(1<<SPI_INTLVL1_bp);//0x01;
    381c:	80 91 c1 08 	lds	r24, 0x08C1
    3820:	82 60       	ori	r24, 0x02	; 2
    3822:	e0 ec       	ldi	r30, 0xC0	; 192
    3824:	f8 e0       	ldi	r31, 0x08	; 8
    3826:	81 83       	std	Z+1, r24	; 0x01
  SPIC.CTRL|=(1<<SPI_CLK2X_bp);
    3828:	80 91 c0 08 	lds	r24, 0x08C0
    382c:	80 68       	ori	r24, 0x80	; 128
    382e:	80 93 c0 08 	sts	0x08C0, r24
  portEXIT_CRITICAL();
    3832:	0f 90       	pop	r0
    3834:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    3836:	08 95       	ret

00003838 <spiSetCPHA>:

void spiSetCPHA(void)
{
  //SPCR |= (1<<CPHA);
  SPID.CTRL|=(1<<SPI_MODE_gp);
    3838:	e0 ec       	ldi	r30, 0xC0	; 192
    383a:	f9 e0       	ldi	r31, 0x09	; 9
    383c:	80 81       	ld	r24, Z
    383e:	84 60       	ori	r24, 0x04	; 4
    3840:	80 83       	st	Z, r24
}
    3842:	08 95       	ret

00003844 <spiSetCPHAENC>:
void spiSetCPHAENC(void)
{
  //SPCR |= (1<<CPHA);
  SPIC.CTRL|=(1<<SPI_MODE_gp);
    3844:	e0 ec       	ldi	r30, 0xC0	; 192
    3846:	f8 e0       	ldi	r31, 0x08	; 8
    3848:	80 81       	ld	r24, Z
    384a:	84 60       	ori	r24, 0x04	; 4
    384c:	80 83       	st	Z, r24
}
    384e:	08 95       	ret

00003850 <spiClearCPHA>:

void spiClearCPHA(void)
{
  //SPCR &= ~(1<<CPHA);
  SPID.CTRL&=~(1<<SPI_MODE_gp);
    3850:	e0 ec       	ldi	r30, 0xC0	; 192
    3852:	f9 e0       	ldi	r31, 0x09	; 9
    3854:	80 81       	ld	r24, Z
    3856:	8b 7f       	andi	r24, 0xFB	; 251
    3858:	80 83       	st	Z, r24
}
    385a:	08 95       	ret

0000385c <spiClearCPHAENC>:
void spiClearCPHAENC(void)
{
  //SPCR &= ~(1<<CPHA);
  SPIC.CTRL&=~(1<<SPI_MODE_gp);
    385c:	e0 ec       	ldi	r30, 0xC0	; 192
    385e:	f8 e0       	ldi	r31, 0x08	; 8
    3860:	80 81       	ld	r24, Z
    3862:	8b 7f       	andi	r24, 0xFB	; 251
    3864:	80 83       	st	Z, r24
}
    3866:	08 95       	ret

00003868 <spiSetCPOL>:


void spiSetCPOL(void)
{
  //SPCR |= (1<<CPOL);
  SPID.CTRL|=(1<<SPI_MODE1_bp);
    3868:	e0 ec       	ldi	r30, 0xC0	; 192
    386a:	f9 e0       	ldi	r31, 0x09	; 9
    386c:	80 81       	ld	r24, Z
    386e:	88 60       	ori	r24, 0x08	; 8
    3870:	80 83       	st	Z, r24
}
    3872:	08 95       	ret

00003874 <spiSetCPOLENC>:
void spiSetCPOLENC(void)
{
  //SPCR |= (1<<CPOL);
  SPIC.CTRL|=(1<<SPI_MODE1_bp);
    3874:	e0 ec       	ldi	r30, 0xC0	; 192
    3876:	f8 e0       	ldi	r31, 0x08	; 8
    3878:	80 81       	ld	r24, Z
    387a:	88 60       	ori	r24, 0x08	; 8
    387c:	80 83       	st	Z, r24
}
    387e:	08 95       	ret

00003880 <spiClearCPOL>:

void spiClearCPOL(void)
{
  //SPCR &= ~(1<<CPOL);
   SPID.CTRL&=~(1<<SPI_MODE1_bp);
    3880:	e0 ec       	ldi	r30, 0xC0	; 192
    3882:	f9 e0       	ldi	r31, 0x09	; 9
    3884:	80 81       	ld	r24, Z
    3886:	87 7f       	andi	r24, 0xF7	; 247
    3888:	80 83       	st	Z, r24
}
    388a:	08 95       	ret

0000388c <spiClearCPOLENC>:
void spiClearCPOLENC(void)
{
  //SPCR &= ~(1<<CPOL);
   SPID.CTRL&=~(1<<SPI_MODE1_bp);
    388c:	e0 ec       	ldi	r30, 0xC0	; 192
    388e:	f9 e0       	ldi	r31, 0x09	; 9
    3890:	80 81       	ld	r24, Z
    3892:	87 7f       	andi	r24, 0xF7	; 247
    3894:	80 83       	st	Z, r24
}
    3896:	08 95       	ret

00003898 <spiTake>:

void spiTake(void)
{
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
    3898:	80 91 22 32 	lds	r24, 0x3222
    389c:	90 91 23 32 	lds	r25, 0x3223
    38a0:	60 e0       	ldi	r22, 0x00	; 0
    38a2:	70 e0       	ldi	r23, 0x00	; 0
    38a4:	4f ef       	ldi	r20, 0xFF	; 255
    38a6:	5f ef       	ldi	r21, 0xFF	; 255
    38a8:	20 e0       	ldi	r18, 0x00	; 0
    38aa:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
}
    38ae:	08 95       	ret

000038b0 <spiGive>:

void spiGive(void)
{
  xSemaphoreGive(xSemaphoreSpiSS);
    38b0:	80 91 22 32 	lds	r24, 0x3222
    38b4:	90 91 23 32 	lds	r25, 0x3223
    38b8:	60 e0       	ldi	r22, 0x00	; 0
    38ba:	70 e0       	ldi	r23, 0x00	; 0
    38bc:	40 e0       	ldi	r20, 0x00	; 0
    38be:	50 e0       	ldi	r21, 0x00	; 0
    38c0:	20 e0       	ldi	r18, 0x00	; 0
    38c2:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>
}
    38c6:	08 95       	ret
    38c8:	80 e0       	ldi	r24, 0x00	; 0
    38ca:	08 95       	ret
    38cc:	80 e0       	ldi	r24, 0x00	; 0
    38ce:	08 95       	ret

000038d0 <xmalloc>:
#include "hardwareConfig.h"

char *heapEnd = HEAP_BEGIN;

void *xmalloc(size_t size)
{
    38d0:	cf 93       	push	r28
    38d2:	df 93       	push	r29
    38d4:	ec 01       	movw	r28, r24
  void *result = malloc(size);
    38d6:	0e 94 8a 54 	call	0xa914	; 0xa914 <malloc>
  
  heapEnd = (char *)(result);
  heapEnd += size;
    38da:	c8 0f       	add	r28, r24
    38dc:	d9 1f       	adc	r29, r25
    38de:	c0 93 b3 24 	sts	0x24B3, r28
    38e2:	d0 93 b4 24 	sts	0x24B4, r29
  
  return result;
}
    38e6:	df 91       	pop	r29
    38e8:	cf 91       	pop	r28
    38ea:	08 95       	ret

000038ec <xmallocAvailable>:

size_t xmallocAvailable(void)
{
  return __malloc_heap_end - heapEnd + 1;
    38ec:	20 91 44 25 	lds	r18, 0x2544
    38f0:	30 91 45 25 	lds	r19, 0x2545
    38f4:	2f 5f       	subi	r18, 0xFF	; 255
    38f6:	3f 4f       	sbci	r19, 0xFF	; 255
    38f8:	80 91 b3 24 	lds	r24, 0x24B3
    38fc:	90 91 b4 24 	lds	r25, 0x24B4
    3900:	28 1b       	sub	r18, r24
    3902:	39 0b       	sbc	r19, r25
    3904:	c9 01       	movw	r24, r18
    3906:	08 95       	ret

00003908 <uaktualnijRozmiarPliku>:

  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
    3908:	fc 01       	movw	r30, r24
  if (fd->wpis->rozmiarHi == fd->IndHi)
    390a:	a4 81       	ldd	r26, Z+4	; 0x04
    390c:	b5 81       	ldd	r27, Z+5	; 0x05
    390e:	12 96       	adiw	r26, 0x02	; 2
    3910:	9c 91       	ld	r25, X
    3912:	12 97       	sbiw	r26, 0x02	; 2
    3914:	83 81       	ldd	r24, Z+3	; 0x03
    3916:	98 17       	cp	r25, r24
    3918:	41 f4       	brne	.+16     	; 0x392a <uaktualnijRozmiarPliku+0x22>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    391a:	82 81       	ldd	r24, Z+2	; 0x02
    391c:	11 96       	adiw	r26, 0x01	; 1
    391e:	9c 91       	ld	r25, X
    3920:	11 97       	sbiw	r26, 0x01	; 1
    3922:	98 17       	cp	r25, r24
    3924:	10 f4       	brcc	.+4      	; 0x392a <uaktualnijRozmiarPliku+0x22>
      fd->wpis->rozmiarLo = fd->IndLo;
    3926:	11 96       	adiw	r26, 0x01	; 1
    3928:	8c 93       	st	X, r24
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    392a:	a4 81       	ldd	r26, Z+4	; 0x04
    392c:	b5 81       	ldd	r27, Z+5	; 0x05
    392e:	12 96       	adiw	r26, 0x02	; 2
    3930:	9c 91       	ld	r25, X
    3932:	12 97       	sbiw	r26, 0x02	; 2
    3934:	83 81       	ldd	r24, Z+3	; 0x03
    3936:	98 17       	cp	r25, r24
    3938:	48 f4       	brcc	.+18     	; 0x394c <uaktualnijRozmiarPliku+0x44>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    393a:	82 81       	ldd	r24, Z+2	; 0x02
    393c:	11 96       	adiw	r26, 0x01	; 1
    393e:	8c 93       	st	X, r24
      fd->wpis->rozmiarHi = fd->IndHi;    
    3940:	a4 81       	ldd	r26, Z+4	; 0x04
    3942:	b5 81       	ldd	r27, Z+5	; 0x05
    3944:	83 81       	ldd	r24, Z+3	; 0x03
    3946:	12 96       	adiw	r26, 0x02	; 2
    3948:	8c 93       	st	X, r24
    394a:	12 97       	sbiw	r26, 0x02	; 2
    394c:	08 95       	ret

0000394e <czyscKlaster>:
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    394e:	e0 e0       	ldi	r30, 0x00	; 0
    3950:	f8 2f       	mov	r31, r24
    3952:	f0 58       	subi	r31, 0x80	; 128
    3954:	80 e0       	ldi	r24, 0x00	; 0
    3956:	91 e0       	ldi	r25, 0x01	; 1
    3958:	df 01       	movw	r26, r30
    395a:	9c 01       	movw	r18, r24
    395c:	1d 92       	st	X+, r1
    395e:	21 50       	subi	r18, 0x01	; 1
    3960:	30 40       	sbci	r19, 0x00	; 0
    3962:	e1 f7       	brne	.-8      	; 0x395c <czyscKlaster+0xe>
}
    3964:	08 95       	ret

00003966 <znajdzWolnyKlaster>:
      fd->wpis->rozmiarHi = fd->IndHi;    
  }
}

static uint8_t znajdzWolnyKlaster(void)
{
    3966:	1f 93       	push	r17
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    3968:	11 e0       	ldi	r17, 0x01	; 1
  {                                        //Może być rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    396a:	e1 2f       	mov	r30, r17
    396c:	f0 e0       	ldi	r31, 0x00	; 0
    396e:	e3 5d       	subi	r30, 0xD3	; 211
    3970:	fd 4c       	sbci	r31, 0xCD	; 205
    3972:	80 81       	ld	r24, Z
    3974:	88 23       	and	r24, r24
    3976:	29 f4       	brne	.+10     	; 0x3982 <znajdzWolnyKlaster+0x1c>
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
    3978:	10 83       	st	Z, r17
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
    397a:	81 2f       	mov	r24, r17
    397c:	0e 94 a7 1c 	call	0x394e	; 0x394e <czyscKlaster>
      return i;
    3980:	04 c0       	rjmp	.+8      	; 0x398a <znajdzWolnyKlaster+0x24>
}

static uint8_t znajdzWolnyKlaster(void)
{
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    3982:	1f 5f       	subi	r17, 0xFF	; 255
    3984:	10 38       	cpi	r17, 0x80	; 128
    3986:	89 f7       	brne	.-30     	; 0x396a <znajdzWolnyKlaster+0x4>
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
      return i;
    }
  }
  return 0;
    3988:	10 e0       	ldi	r17, 0x00	; 0
}
    398a:	81 2f       	mov	r24, r17
    398c:	1f 91       	pop	r17
    398e:	08 95       	ret

00003990 <nastepnyKlaster>:

static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
    3990:	1f 93       	push	r17
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
    3992:	28 2f       	mov	r18, r24
    3994:	30 e0       	ldi	r19, 0x00	; 0
    3996:	f9 01       	movw	r30, r18
    3998:	e3 5d       	subi	r30, 0xD3	; 211
    399a:	fd 4c       	sbci	r31, 0xCD	; 205
    399c:	10 81       	ld	r17, Z
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
    399e:	18 17       	cp	r17, r24
    39a0:	b9 f4       	brne	.+46     	; 0x39d0 <nastepnyKlaster+0x40>
    39a2:	11 e0       	ldi	r17, 0x01	; 1
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma wolnego klastra
      if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, że jest on pusty
    39a4:	e1 2f       	mov	r30, r17
    39a6:	f0 e0       	ldi	r31, 0x00	; 0
    39a8:	e3 5d       	subi	r30, 0xD3	; 211
    39aa:	fd 4c       	sbci	r31, 0xCD	; 205
    39ac:	80 81       	ld	r24, Z
    39ae:	88 23       	and	r24, r24
    39b0:	19 f0       	breq	.+6      	; 0x39b8 <nastepnyKlaster+0x28>
static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    39b2:	1f 5f       	subi	r17, 0xFF	; 255
    39b4:	10 38       	cpi	r17, 0x80	; 128
    39b6:	b1 f7       	brne	.-20     	; 0x39a4 <nastepnyKlaster+0x14>
        break;                             //Wtedy można przerwać szukanie kolejnych klastrów dla klastra
    }                                      //Taka implementacja z założenia powoduje defragmentację.
    
    if (temp != 0)                         //Znaleziono jakiś wolny klaster
    {
      klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku kolejnego klastra
    39b8:	23 5d       	subi	r18, 0xD3	; 211
    39ba:	3d 4c       	sbci	r19, 0xCD	; 205
    39bc:	f9 01       	movw	r30, r18
    39be:	10 83       	st	Z, r17
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
    39c0:	e1 2f       	mov	r30, r17
    39c2:	f0 e0       	ldi	r31, 0x00	; 0
    39c4:	e3 5d       	subi	r30, 0xD3	; 211
    39c6:	fd 4c       	sbci	r31, 0xCD	; 205
    39c8:	10 83       	st	Z, r17
      czyscKlaster(temp);                  //Czyszczenie klastra
    39ca:	81 2f       	mov	r24, r17
    39cc:	0e 94 a7 1c 	call	0x394e	; 0x394e <czyscKlaster>
    }
  }
  return temp;
}
    39d0:	81 2f       	mov	r24, r17
    39d2:	1f 91       	pop	r17
    39d4:	08 95       	ret

000039d6 <znajdzKlasterN>:

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
    39d6:	1f 93       	push	r17
    39d8:	df 93       	push	r29
    39da:	cf 93       	push	r28
    39dc:	0f 92       	push	r0
    39de:	cd b7       	in	r28, 0x3d	; 61
    39e0:	de b7       	in	r29, 0x3e	; 62
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    39e2:	10 e0       	ldi	r17, 0x00	; 0
    39e4:	07 c0       	rjmp	.+14     	; 0x39f4 <znajdzKlasterN+0x1e>
  {
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    39e6:	69 83       	std	Y+1, r22	; 0x01
    39e8:	0e 94 c8 1c 	call	0x3990	; 0x3990 <nastepnyKlaster>
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
    39ec:	69 81       	ldd	r22, Y+1	; 0x01
    39ee:	88 23       	and	r24, r24
    39f0:	19 f0       	breq	.+6      	; 0x39f8 <znajdzKlasterN+0x22>

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    39f2:	1f 5f       	subi	r17, 0xFF	; 255
    39f4:	16 17       	cp	r17, r22
    39f6:	b8 f3       	brcs	.-18     	; 0x39e6 <znajdzKlasterN+0x10>
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
      break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany na początek tablicy plików
  }
  return wynik;
}
    39f8:	0f 90       	pop	r0
    39fa:	cf 91       	pop	r28
    39fc:	df 91       	pop	r29
    39fe:	1f 91       	pop	r17
    3a00:	08 95       	ret

00003a02 <znajdzPlik>:
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
{
    3a02:	8f 92       	push	r8
    3a04:	9f 92       	push	r9
    3a06:	af 92       	push	r10
    3a08:	bf 92       	push	r11
    3a0a:	df 92       	push	r13
    3a0c:	ef 92       	push	r14
    3a0e:	ff 92       	push	r15
    3a10:	0f 93       	push	r16
    3a12:	1f 93       	push	r17
    3a14:	df 93       	push	r29
    3a16:	cf 93       	push	r28
    3a18:	0f 92       	push	r0
    3a1a:	cd b7       	in	r28, 0x3d	; 61
    3a1c:	de b7       	in	r29, 0x3e	; 62
    3a1e:	8c 01       	movw	r16, r24
  uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
    3a20:	dc 01       	movw	r26, r24
    3a22:	0d 90       	ld	r0, X+
    3a24:	00 20       	and	r0, r0
    3a26:	e9 f7       	brne	.-6      	; 0x3a22 <znajdzPlik+0x20>
    3a28:	9d 01       	movw	r18, r26
    3a2a:	21 50       	subi	r18, 0x01	; 1
    3a2c:	30 40       	sbci	r19, 0x00	; 0
    3a2e:	28 1b       	sub	r18, r24
    3a30:	29 30       	cpi	r18, 0x09	; 9
    3a32:	08 f0       	brcs	.+2      	; 0x3a36 <znajdzPlik+0x34>
    3a34:	28 e0       	ldi	r18, 0x08	; 8
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  
  if (nazwa[dlNazwy-1] == 0)
    3a36:	f8 01       	movw	r30, r16
    3a38:	e2 0f       	add	r30, r18
    3a3a:	f1 1d       	adc	r31, r1
    3a3c:	31 97       	sbiw	r30, 0x01	; 1
    3a3e:	80 81       	ld	r24, Z
    3a40:	88 23       	and	r24, r24
    3a42:	09 f4       	brne	.+2      	; 0x3a46 <znajdzPlik+0x44>
    dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
    3a44:	21 50       	subi	r18, 0x01	; 1
  klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
    3a46:	f8 01       	movw	r30, r16
    3a48:	31 96       	adiw	r30, 0x01	; 1
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    3a4a:	81 e0       	ldi	r24, 0x01	; 1
    3a4c:	04 c0       	rjmp	.+8      	; 0x3a56 <znajdzPlik+0x54>
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    3a4e:	91 91       	ld	r25, Z+
    3a50:	90 32       	cpi	r25, 0x20	; 32
    3a52:	31 f0       	breq	.+12     	; 0x3a60 <znajdzPlik+0x5e>
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    3a54:	8f 5f       	subi	r24, 0xFF	; 255
    3a56:	82 17       	cp	r24, r18
    3a58:	d0 f3       	brcs	.-12     	; 0x3a4e <znajdzPlik+0x4c>
    {
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    3a5a:	22 23       	and	r18, r18
    3a5c:	59 f1       	breq	.+86     	; 0x3ab4 <znajdzPlik+0xb2>
    3a5e:	01 c0       	rjmp	.+2      	; 0x3a62 <znajdzPlik+0x60>
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    3a60:	28 2f       	mov	r18, r24
    3a62:	dd 24       	eor	r13, r13
    3a64:	01 c0       	rjmp	.+2      	; 0x3a68 <znajdzPlik+0x66>
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3a66:	d8 2e       	mov	r13, r24
  if (dlNazwy == 0)
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    3a68:	ed 2c       	mov	r14, r13
    3a6a:	ff 24       	eor	r15, r15
    3a6c:	c7 01       	movw	r24, r14
    3a6e:	80 58       	subi	r24, 0x80	; 128
    3a70:	9f 4f       	sbci	r25, 0xFF	; 255
    3a72:	98 2e       	mov	r9, r24
    3a74:	88 24       	eor	r8, r8
  klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
    3a76:	80 ef       	ldi	r24, 0xF0	; 240
    3a78:	a8 2e       	mov	r10, r24
    3a7a:	b1 2c       	mov	r11, r1
    3a7c:	a8 0c       	add	r10, r8
    3a7e:	b9 1c       	adc	r11, r9
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    3a80:	b4 01       	movw	r22, r8
    3a82:	6c 5f       	subi	r22, 0xFC	; 252
    3a84:	7f 4f       	sbci	r23, 0xFF	; 255
    3a86:	c8 01       	movw	r24, r16
    3a88:	42 2f       	mov	r20, r18
    3a8a:	50 e0       	ldi	r21, 0x00	; 0
    3a8c:	29 83       	std	Y+1, r18	; 0x01
    3a8e:	0e 94 37 57 	call	0xae6e	; 0xae6e <strncmp>
    3a92:	29 81       	ldd	r18, Y+1	; 0x01
    3a94:	00 97       	sbiw	r24, 0x00	; 0
    3a96:	81 f0       	breq	.+32     	; 0x3ab8 <znajdzPlik+0xb6>
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    3a98:	8a 14       	cp	r8, r10
    3a9a:	9b 04       	cpc	r9, r11
    3a9c:	29 f0       	breq	.+10     	; 0x3aa8 <znajdzPlik+0xa6>
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    3a9e:	e0 e1       	ldi	r30, 0x10	; 16
    3aa0:	f0 e0       	ldi	r31, 0x00	; 0
    3aa2:	8e 0e       	add	r8, r30
    3aa4:	9f 1e       	adc	r9, r31
    3aa6:	ec cf       	rjmp	.-40     	; 0x3a80 <znajdzPlik+0x7e>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3aa8:	f7 01       	movw	r30, r14
    3aaa:	e3 5d       	subi	r30, 0xD3	; 211
    3aac:	fd 4c       	sbci	r31, 0xCD	; 205
    3aae:	80 81       	ld	r24, Z
  }
  while (tempKlaster2 != tempKlaster);
    3ab0:	d8 16       	cp	r13, r24
    3ab2:	c9 f6       	brne	.-78     	; 0x3a66 <znajdzPlik+0x64>
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    return NULL;
    3ab4:	88 24       	eor	r8, r8
    3ab6:	99 24       	eor	r9, r9
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
  }
  while (tempKlaster2 != tempKlaster);
  return NULL;
}
    3ab8:	c4 01       	movw	r24, r8
    3aba:	0f 90       	pop	r0
    3abc:	cf 91       	pop	r28
    3abe:	df 91       	pop	r29
    3ac0:	1f 91       	pop	r17
    3ac2:	0f 91       	pop	r16
    3ac4:	ff 90       	pop	r15
    3ac6:	ef 90       	pop	r14
    3ac8:	df 90       	pop	r13
    3aca:	bf 90       	pop	r11
    3acc:	af 90       	pop	r10
    3ace:	9f 90       	pop	r9
    3ad0:	8f 90       	pop	r8
    3ad2:	08 95       	ret

00003ad4 <ramDyskInit>:
}


void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
    3ad4:	80 e8       	ldi	r24, 0x80	; 128
    3ad6:	ed e2       	ldi	r30, 0x2D	; 45
    3ad8:	f2 e3       	ldi	r31, 0x32	; 50
    3ada:	df 01       	movw	r26, r30
    3adc:	1d 92       	st	X+, r1
    3ade:	8a 95       	dec	r24
    3ae0:	e9 f7       	brne	.-6      	; 0x3adc <ramDyskInit+0x8>
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
    3ae2:	80 e0       	ldi	r24, 0x00	; 0
    3ae4:	91 e0       	ldi	r25, 0x01	; 1
    3ae6:	e0 e0       	ldi	r30, 0x00	; 0
    3ae8:	f0 e8       	ldi	r31, 0x80	; 128
    3aea:	df 01       	movw	r26, r30
    3aec:	9c 01       	movw	r18, r24
    3aee:	1d 92       	st	X+, r1
    3af0:	21 50       	subi	r18, 0x01	; 1
    3af2:	30 40       	sbci	r19, 0x00	; 0
    3af4:	e1 f7       	brne	.-8      	; 0x3aee <ramDyskInit+0x1a>
}
    3af6:	08 95       	ret

00003af8 <ramDyskUtworzPlik>:
uint8_t ramDyskUtworzPlik(const char *nazwa)
{                                        //Nowo utworzony plik nie zajmuje żadnego klastra
    3af8:	cf 92       	push	r12
    3afa:	df 92       	push	r13
    3afc:	ef 92       	push	r14
    3afe:	ff 92       	push	r15
    3b00:	0f 93       	push	r16
    3b02:	1f 93       	push	r17
    3b04:	cf 93       	push	r28
    3b06:	df 93       	push	r29
    3b08:	f8 2e       	mov	r15, r24
    3b0a:	09 2f       	mov	r16, r25
  uint8_t dlNazwy = strlen(nazwa);
    3b0c:	e8 2f       	mov	r30, r24
    3b0e:	f9 2f       	mov	r31, r25
    3b10:	df 01       	movw	r26, r30
    3b12:	0d 90       	ld	r0, X+
    3b14:	00 20       	and	r0, r0
    3b16:	e9 f7       	brne	.-6      	; 0x3b12 <ramDyskUtworzPlik+0x1a>
    3b18:	11 97       	sbiw	r26, 0x01	; 1
    3b1a:	1a 2f       	mov	r17, r26
    3b1c:	18 1b       	sub	r17, r24
    3b1e:	19 30       	cpi	r17, 0x09	; 9
    3b20:	08 f0       	brcs	.+2      	; 0x3b24 <ramDyskUtworzPlik+0x2c>
    3b22:	18 e0       	ldi	r17, 0x08	; 8
    3b24:	2f 2d       	mov	r18, r15
    3b26:	30 2f       	mov	r19, r16
    3b28:	f9 01       	movw	r30, r18
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    3b2a:	80 e0       	ldi	r24, 0x00	; 0
    3b2c:	04 c0       	rjmp	.+8      	; 0x3b36 <ramDyskUtworzPlik+0x3e>
  {  if (nazwa[i] == ' ')
    3b2e:	91 91       	ld	r25, Z+
    3b30:	90 32       	cpi	r25, 0x20	; 32
    3b32:	21 f0       	breq	.+8      	; 0x3b3c <ramDyskUtworzPlik+0x44>
  uint8_t dlNazwy = strlen(nazwa);
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    3b34:	8f 5f       	subi	r24, 0xFF	; 255
    3b36:	81 17       	cp	r24, r17
    3b38:	d0 f3       	brcs	.-12     	; 0x3b2e <ramDyskUtworzPlik+0x36>
    3b3a:	01 c0       	rjmp	.+2      	; 0x3b3e <ramDyskUtworzPlik+0x46>
  {  if (nazwa[i] == ' ')
    3b3c:	18 2f       	mov	r17, r24
     {
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    3b3e:	11 23       	and	r17, r17
    3b40:	09 f4       	brne	.+2      	; 0x3b44 <ramDyskUtworzPlik+0x4c>
    3b42:	47 c0       	rjmp	.+142    	; 0x3bd2 <ramDyskUtworzPlik+0xda>
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    3b44:	8f 2d       	mov	r24, r15
    3b46:	90 2f       	mov	r25, r16
    3b48:	0e 94 01 1d 	call	0x3a02	; 0x3a02 <znajdzPlik>
    3b4c:	00 97       	sbiw	r24, 0x00	; 0
    3b4e:	09 f0       	breq	.+2      	; 0x3b52 <ramDyskUtworzPlik+0x5a>
    3b50:	40 c0       	rjmp	.+128    	; 0x3bd2 <ramDyskUtworzPlik+0xda>
    3b52:	ee 24       	eor	r14, r14
    3b54:	01 c0       	rjmp	.+2      	; 0x3b58 <ramDyskUtworzPlik+0x60>
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3b56:	e8 2e       	mov	r14, r24
  uint8_t temp;
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    3b58:	8e 2d       	mov	r24, r14
    3b5a:	90 e0       	ldi	r25, 0x00	; 0
    3b5c:	ec 01       	movw	r28, r24
    3b5e:	c0 58       	subi	r28, 0x80	; 128
    3b60:	df 4f       	sbci	r29, 0xFF	; 255
    3b62:	dc 2f       	mov	r29, r28
    3b64:	cc 27       	eor	r28, r28
void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
}
uint8_t ramDyskUtworzPlik(const char *nazwa)
    3b66:	9e 01       	movw	r18, r28
    3b68:	20 51       	subi	r18, 0x10	; 16
    3b6a:	3f 4f       	sbci	r19, 0xFF	; 255
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (plik->nazwa[0] == 0)
    3b6c:	4c 81       	ldd	r20, Y+4	; 0x04
    3b6e:	44 23       	and	r20, r20
    3b70:	d1 f0       	breq	.+52     	; 0x3ba6 <ramDyskUtworzPlik+0xae>
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    3b72:	c2 17       	cp	r28, r18
    3b74:	d3 07       	cpc	r29, r19
    3b76:	11 f0       	breq	.+4      	; 0x3b7c <ramDyskUtworzPlik+0x84>
    {
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    3b78:	60 96       	adiw	r28, 0x10	; 16
    3b7a:	f8 cf       	rjmp	.-16     	; 0x3b6c <ramDyskUtworzPlik+0x74>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3b7c:	83 5d       	subi	r24, 0xD3	; 211
    3b7e:	9d 4c       	sbci	r25, 0xCD	; 205
    3b80:	dc 01       	movw	r26, r24
    3b82:	8c 91       	ld	r24, X
  }
  while (tempKlaster2 != tempKlaster);
    3b84:	e8 16       	cp	r14, r24
    3b86:	39 f7       	brne	.-50     	; 0x3b56 <ramDyskUtworzPlik+0x5e>
  
  klastry[tempKlaster] = znajdzWolnyKlaster();
    3b88:	0e 94 b3 1c 	call	0x3966	; 0x3966 <znajdzWolnyKlaster>
    3b8c:	ee 2d       	mov	r30, r14
    3b8e:	f0 e0       	ldi	r31, 0x00	; 0
    3b90:	e3 5d       	subi	r30, 0xD3	; 211
    3b92:	fd 4c       	sbci	r31, 0xCD	; 205
    3b94:	80 83       	st	Z, r24
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    3b96:	88 23       	and	r24, r24
    3b98:	f1 f0       	breq	.+60     	; 0x3bd6 <ramDyskUtworzPlik+0xde>
    plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
    3b9a:	c8 2f       	mov	r28, r24
    3b9c:	d0 e0       	ldi	r29, 0x00	; 0
    3b9e:	c0 58       	subi	r28, 0x80	; 128
    3ba0:	df 4f       	sbci	r29, 0xFF	; 255
    3ba2:	dc 2f       	mov	r29, r28
    3ba4:	cc 27       	eor	r28, r28
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
  }
  
  if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym pliku
    3ba6:	20 97       	sbiw	r28, 0x00	; 0
    3ba8:	b1 f0       	breq	.+44     	; 0x3bd6 <ramDyskUtworzPlik+0xde>
  {
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    3baa:	6e 01       	movw	r12, r28
    3bac:	ec 2f       	mov	r30, r28
    3bae:	fd 2d       	mov	r31, r13
    3bb0:	8c e0       	ldi	r24, 0x0C	; 12
    3bb2:	df 01       	movw	r26, r30
    3bb4:	1d 92       	st	X+, r1
    3bb6:	8a 95       	dec	r24
    3bb8:	e9 f7       	brne	.-6      	; 0x3bb4 <ramDyskUtworzPlik+0xbc>
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    3bba:	ce 01       	movw	r24, r28
    3bbc:	04 96       	adiw	r24, 0x04	; 4
    3bbe:	6f 2d       	mov	r22, r15
    3bc0:	70 2f       	mov	r23, r16
    3bc2:	41 2f       	mov	r20, r17
    3bc4:	50 e0       	ldi	r21, 0x00	; 0
    3bc6:	0e 94 45 57 	call	0xae8a	; 0xae8a <strncpy>
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    3bca:	1c 86       	std	Y+12, r1	; 0x0c
    3bcc:	1d 86       	std	Y+13, r1	; 0x0d
    3bce:	1e 86       	std	Y+14, r1	; 0x0e
    3bd0:	1f 86       	std	Y+15, r1	; 0x0f
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
    3bd2:	80 e0       	ldi	r24, 0x00	; 0
    3bd4:	01 c0       	rjmp	.+2      	; 0x3bd8 <ramDyskUtworzPlik+0xe0>
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    return 0;                            
  }
  return 1;
    3bd6:	81 e0       	ldi	r24, 0x01	; 1
}
    3bd8:	df 91       	pop	r29
    3bda:	cf 91       	pop	r28
    3bdc:	1f 91       	pop	r17
    3bde:	0f 91       	pop	r16
    3be0:	ff 90       	pop	r15
    3be2:	ef 90       	pop	r14
    3be4:	df 90       	pop	r13
    3be6:	cf 90       	pop	r12
    3be8:	08 95       	ret

00003bea <ramDyskOtworzPlik>:

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
    3bea:	ef 92       	push	r14
    3bec:	ff 92       	push	r15
    3bee:	cf 93       	push	r28
    3bf0:	df 93       	push	r29
    3bf2:	eb 01       	movw	r28, r22
  uint8_t wynik = 1;
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    3bf4:	0e 94 01 1d 	call	0x3a02	; 0x3a02 <znajdzPlik>
    3bf8:	fc 01       	movw	r30, r24
    3bfa:	00 97       	sbiw	r24, 0x00	; 0
    3bfc:	79 f0       	breq	.+30     	; 0x3c1c <ramDyskOtworzPlik+0x32>
  {
    memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
    3bfe:	7e 01       	movw	r14, r28
    3c00:	2c 2f       	mov	r18, r28
    3c02:	3f 2d       	mov	r19, r15
    3c04:	83 e0       	ldi	r24, 0x03	; 3
    3c06:	d9 01       	movw	r26, r18
    3c08:	1d 92       	st	X+, r1
    3c0a:	8a 95       	dec	r24
    3c0c:	e9 f7       	brne	.-6      	; 0x3c08 <ramDyskOtworzPlik+0x1e>
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    3c0e:	ec 83       	std	Y+4, r30	; 0x04
    3c10:	fd 83       	std	Y+5, r31	; 0x05
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    3c12:	83 81       	ldd	r24, Z+3	; 0x03
    3c14:	8f 5f       	subi	r24, 0xFF	; 255
    3c16:	83 83       	std	Z+3, r24	; 0x03
    wynik = 0;
    3c18:	80 e0       	ldi	r24, 0x00	; 0
    3c1a:	01 c0       	rjmp	.+2      	; 0x3c1e <ramDyskOtworzPlik+0x34>
  return 1;
}

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
  uint8_t wynik = 1;
    3c1c:	81 e0       	ldi	r24, 0x01	; 1
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    wynik = 0;
  }
  return wynik;
}
    3c1e:	df 91       	pop	r29
    3c20:	cf 91       	pop	r28
    3c22:	ff 90       	pop	r15
    3c24:	ef 90       	pop	r14
    3c26:	08 95       	ret

00003c28 <ramDyskUsunPlik>:

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    3c28:	0e 94 01 1d 	call	0x3a02	; 0x3a02 <znajdzPlik>
    3c2c:	fc 01       	movw	r30, r24
    3c2e:	00 97       	sbiw	r24, 0x00	; 0
    3c30:	e1 f0       	breq	.+56     	; 0x3c6a <ramDyskUsunPlik+0x42>
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    3c32:	83 81       	ldd	r24, Z+3	; 0x03
    3c34:	88 23       	and	r24, r24
    3c36:	81 f0       	breq	.+32     	; 0x3c58 <ramDyskUsunPlik+0x30>
    3c38:	1a c0       	rjmp	.+52     	; 0x3c6e <ramDyskUsunPlik+0x46>
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
  {
    usuwanyKlaster = plik->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3c3a:	82 2f       	mov	r24, r18
    3c3c:	90 e0       	ldi	r25, 0x00	; 0
    3c3e:	dc 01       	movw	r26, r24
    3c40:	a3 5d       	subi	r26, 0xD3	; 211
    3c42:	bd 4c       	sbci	r27, 0xCD	; 205
    3c44:	3c 91       	ld	r19, X
    3c46:	32 17       	cp	r19, r18
    3c48:	11 f4       	brne	.+4      	; 0x3c4e <ramDyskUsunPlik+0x26>
      plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3c4a:	10 82       	st	Z, r1
    3c4c:	01 c0       	rjmp	.+2      	; 0x3c50 <ramDyskUsunPlik+0x28>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3c4e:	30 83       	st	Z, r19
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
    3c50:	83 5d       	subi	r24, 0xD3	; 211
    3c52:	9d 4c       	sbci	r25, 0xCD	; 205
    3c54:	dc 01       	movw	r26, r24
    3c56:	1c 92       	st	X, r1
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3c58:	20 81       	ld	r18, Z
    3c5a:	22 23       	and	r18, r18
    3c5c:	71 f7       	brne	.-36     	; 0x3c3a <ramDyskUsunPlik+0x12>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
    3c5e:	80 e1       	ldi	r24, 0x10	; 16
    3c60:	11 92       	st	Z+, r1
    3c62:	8a 95       	dec	r24
    3c64:	e9 f7       	brne	.-6      	; 0x3c60 <ramDyskUsunPlik+0x38>
//relokacjaTablicyWpisow()
  return 0;
    3c66:	80 e0       	ldi	r24, 0x00	; 0
    3c68:	08 95       	ret

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    return 1;                                              //Nie znaleziono pliku
    3c6a:	81 e0       	ldi	r24, 0x01	; 1
    3c6c:	08 95       	ret
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
    3c6e:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
//relokacjaTablicyWpisow()
  return 0;
}
    3c70:	08 95       	ret

00003c72 <ramDyskZamknijPlik>:

void ramDyskZamknijPlik(struct ramPlikFd *fd)
{
  if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest poprawny
    3c72:	dc 01       	movw	r26, r24
    3c74:	14 96       	adiw	r26, 0x04	; 4
    3c76:	ed 91       	ld	r30, X+
    3c78:	fc 91       	ld	r31, X
    3c7a:	15 97       	sbiw	r26, 0x05	; 5
    3c7c:	23 81       	ldd	r18, Z+3	; 0x03
    3c7e:	22 23       	and	r18, r18
    3c80:	31 f0       	breq	.+12     	; 0x3c8e <ramDyskZamknijPlik+0x1c>
  {
    fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
    3c82:	21 50       	subi	r18, 0x01	; 1
    3c84:	23 83       	std	Z+3, r18	; 0x03
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
    3c86:	86 e0       	ldi	r24, 0x06	; 6
    3c88:	1d 92       	st	X+, r1
    3c8a:	8a 95       	dec	r24
    3c8c:	e9 f7       	brne	.-6      	; 0x3c88 <ramDyskZamknijPlik+0x16>
    3c8e:	08 95       	ret

00003c90 <ramDyskCzyscPlik>:
  }
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
    3c90:	cf 93       	push	r28
    3c92:	df 93       	push	r29
    3c94:	fc 01       	movw	r30, r24
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3c96:	0f c0       	rjmp	.+30     	; 0x3cb6 <ramDyskCzyscPlik+0x26>
  {
    usuwanyKlaster = fd->wpis->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostatniego klastra
    3c98:	82 2f       	mov	r24, r18
    3c9a:	90 e0       	ldi	r25, 0x00	; 0
    3c9c:	ec 01       	movw	r28, r24
    3c9e:	c3 5d       	subi	r28, 0xD3	; 211
    3ca0:	dd 4c       	sbci	r29, 0xCD	; 205
    3ca2:	38 81       	ld	r19, Y
    3ca4:	32 17       	cp	r19, r18
    3ca6:	11 f4       	brne	.+4      	; 0x3cac <ramDyskCzyscPlik+0x1c>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3ca8:	1c 92       	st	X, r1
    3caa:	01 c0       	rjmp	.+2      	; 0x3cae <ramDyskCzyscPlik+0x1e>
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    3cac:	3c 93       	st	X, r19
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
    3cae:	83 5d       	subi	r24, 0xD3	; 211
    3cb0:	9d 4c       	sbci	r25, 0xCD	; 205
    3cb2:	dc 01       	movw	r26, r24
    3cb4:	1c 92       	st	X, r1
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3cb6:	a4 81       	ldd	r26, Z+4	; 0x04
    3cb8:	b5 81       	ldd	r27, Z+5	; 0x05
    3cba:	2c 91       	ld	r18, X
    3cbc:	22 23       	and	r18, r18
    3cbe:	61 f7       	brne	.-40     	; 0x3c98 <ramDyskCzyscPlik+0x8>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
  }
  fd->wpis->rozmiarLo       = 0;
    3cc0:	11 96       	adiw	r26, 0x01	; 1
    3cc2:	1c 92       	st	X, r1
  fd->wpis->rozmiarHi       = 0;
    3cc4:	a4 81       	ldd	r26, Z+4	; 0x04
    3cc6:	b5 81       	ldd	r27, Z+5	; 0x05
    3cc8:	12 96       	adiw	r26, 0x02	; 2
    3cca:	1c 92       	st	X, r1
  fd->wpis->dataMod         = systemTime();
    3ccc:	a4 81       	ldd	r26, Z+4	; 0x04
    3cce:	b5 81       	ldd	r27, Z+5	; 0x05
    3cd0:	1c 96       	adiw	r26, 0x0c	; 12
    3cd2:	1d 92       	st	X+, r1
    3cd4:	1d 92       	st	X+, r1
    3cd6:	1d 92       	st	X+, r1
    3cd8:	1c 92       	st	X, r1
    3cda:	1f 97       	sbiw	r26, 0x0f	; 15
  memset (fd, 0, 4);
    3cdc:	10 82       	st	Z, r1
    3cde:	11 82       	std	Z+1, r1	; 0x01
    3ce0:	12 82       	std	Z+2, r1	; 0x02
    3ce2:	13 82       	std	Z+3, r1	; 0x03
  return 0;
}
    3ce4:	80 e0       	ldi	r24, 0x00	; 0
    3ce6:	df 91       	pop	r29
    3ce8:	cf 91       	pop	r28
    3cea:	08 95       	ret

00003cec <ramDyskZapiszBajtDoPliku>:

uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
{
    3cec:	1f 93       	push	r17
    3cee:	cf 93       	push	r28
    3cf0:	df 93       	push	r29
    3cf2:	ec 01       	movw	r28, r24
    3cf4:	16 2f       	mov	r17, r22
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
    3cf6:	ec 81       	ldd	r30, Y+4	; 0x04
    3cf8:	fd 81       	ldd	r31, Y+5	; 0x05
    3cfa:	80 81       	ld	r24, Z
    3cfc:	88 23       	and	r24, r24
    3cfe:	39 f4       	brne	.+14     	; 0x3d0e <ramDyskZapiszBajtDoPliku+0x22>
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
    3d00:	0e 94 b3 1c 	call	0x3966	; 0x3966 <znajdzWolnyKlaster>
    3d04:	88 23       	and	r24, r24
    3d06:	49 f1       	breq	.+82     	; 0x3d5a <ramDyskZapiszBajtDoPliku+0x6e>
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    fd->wpis->pierwszyKlaster = tmpKlaster;
    3d08:	ec 81       	ldd	r30, Y+4	; 0x04
    3d0a:	fd 81       	ldd	r31, Y+5	; 0x05
    3d0c:	80 83       	st	Z, r24
  }
  if (fd->IndLo == 0)
    3d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d10:	88 23       	and	r24, r24
    3d12:	69 f4       	brne	.+26     	; 0x3d2e <ramDyskZapiszBajtDoPliku+0x42>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    3d14:	ec 81       	ldd	r30, Y+4	; 0x04
    3d16:	fd 81       	ldd	r31, Y+5	; 0x05
    3d18:	80 81       	ld	r24, Z
    3d1a:	6b 81       	ldd	r22, Y+3	; 0x03
    3d1c:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <znajdzKlasterN>
    if (tmpKlaster == 0)
    3d20:	88 23       	and	r24, r24
    3d22:	e9 f0       	breq	.+58     	; 0x3d5e <ramDyskZapiszBajtDoPliku+0x72>
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    }
    fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego klastra
    3d24:	90 e0       	ldi	r25, 0x00	; 0
    3d26:	80 58       	subi	r24, 0x80	; 128
    3d28:	9f 4f       	sbci	r25, 0xFF	; 255
    3d2a:	18 82       	st	Y, r1
    3d2c:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
    3d2e:	e8 81       	ld	r30, Y
    3d30:	f9 81       	ldd	r31, Y+1	; 0x01
    3d32:	10 83       	st	Z, r17

  fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
    3d34:	8a 81       	ldd	r24, Y+2	; 0x02
    3d36:	8f 5f       	subi	r24, 0xFF	; 255
    3d38:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, że czły klaster jest zapisany
    3d3a:	88 23       	and	r24, r24
    3d3c:	21 f4       	brne	.+8      	; 0x3d46 <ramDyskZapiszBajtDoPliku+0x5a>
    fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt indeksu. Nie utworzono nowego klastra, zatem nie uaktualniamy wskaźnika
    3d3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d40:	8f 5f       	subi	r24, 0xFF	; 255
    3d42:	8b 83       	std	Y+3, r24	; 0x03
    3d44:	05 c0       	rjmp	.+10     	; 0x3d50 <ramDyskZapiszBajtDoPliku+0x64>
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    3d46:	88 81       	ld	r24, Y
    3d48:	99 81       	ldd	r25, Y+1	; 0x01
    3d4a:	01 96       	adiw	r24, 0x01	; 1
    3d4c:	88 83       	st	Y, r24
    3d4e:	99 83       	std	Y+1, r25	; 0x01
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
    3d50:	ce 01       	movw	r24, r28
    3d52:	0e 94 84 1c 	call	0x3908	; 0x3908 <uaktualnijRozmiarPliku>
  return 0;
    3d56:	80 e0       	ldi	r24, 0x00	; 0
    3d58:	03 c0       	rjmp	.+6      	; 0x3d60 <ramDyskZapiszBajtDoPliku+0x74>
{
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    3d5a:	81 e0       	ldi	r24, 0x01	; 1
    3d5c:	01 c0       	rjmp	.+2      	; 0x3d60 <ramDyskZapiszBajtDoPliku+0x74>
  if (fd->IndLo == 0)
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    if (tmpKlaster == 0)
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    3d5e:	82 e0       	ldi	r24, 0x02	; 2
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}
    3d60:	df 91       	pop	r29
    3d62:	cf 91       	pop	r28
    3d64:	1f 91       	pop	r17
    3d66:	08 95       	ret

00003d68 <putSTD>:
    return wynik;
  return EOF;
}

static int putSTD(char c, FILE *stream)
{
    3d68:	28 2f       	mov	r18, r24
    3d6a:	fb 01       	movw	r30, r22
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
    3d6c:	84 85       	ldd	r24, Z+12	; 0x0c
    3d6e:	95 85       	ldd	r25, Z+13	; 0x0d
    3d70:	62 2f       	mov	r22, r18
    3d72:	0e 94 76 1e 	call	0x3cec	; 0x3cec <ramDyskZapiszBajtDoPliku>
}
    3d76:	90 e0       	ldi	r25, 0x00	; 0
    3d78:	08 95       	ret

00003d7a <ramDyskCzytajBajtZPliku>:
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
    3d7a:	0f 93       	push	r16
    3d7c:	1f 93       	push	r17
    3d7e:	cf 93       	push	r28
    3d80:	df 93       	push	r29
    3d82:	ec 01       	movw	r28, r24
    3d84:	8b 01       	movw	r16, r22
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3d86:	ec 81       	ldd	r30, Y+4	; 0x04
    3d88:	fd 81       	ldd	r31, Y+5	; 0x05
    3d8a:	82 81       	ldd	r24, Z+2	; 0x02
    3d8c:	6b 81       	ldd	r22, Y+3	; 0x03
    3d8e:	68 17       	cp	r22, r24
    3d90:	30 f0       	brcs	.+12     	; 0x3d9e <ramDyskCzytajBajtZPliku+0x24>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3d92:	86 17       	cp	r24, r22
    3d94:	21 f5       	brne	.+72     	; 0x3dde <ramDyskCzytajBajtZPliku+0x64>
    3d96:	91 81       	ldd	r25, Z+1	; 0x01
    3d98:	8a 81       	ldd	r24, Y+2	; 0x02
    3d9a:	98 17       	cp	r25, r24
    3d9c:	00 f1       	brcs	.+64     	; 0x3dde <ramDyskCzytajBajtZPliku+0x64>
uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof

  if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku nowego klastra
    3d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    3da0:	88 23       	and	r24, r24
    3da2:	41 f4       	brne	.+16     	; 0x3db4 <ramDyskCzytajBajtZPliku+0x3a>
  {
    uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    3da4:	80 81       	ld	r24, Z
    3da6:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <znajdzKlasterN>
    fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego klastra
    3daa:	90 e0       	ldi	r25, 0x00	; 0
    3dac:	80 58       	subi	r24, 0x80	; 128
    3dae:	9f 4f       	sbci	r25, 0xFF	; 255
    3db0:	18 82       	st	Y, r1
    3db2:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *bajt = *(fd->Wsk);                                 //Odczyt z pliku
    3db4:	e8 81       	ld	r30, Y
    3db6:	f9 81       	ldd	r31, Y+1	; 0x01
    3db8:	80 81       	ld	r24, Z
    3dba:	f8 01       	movw	r30, r16
    3dbc:	80 83       	st	Z, r24
  fd->IndLo++;                                        //Zwiększenie indeksu o 1
    3dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc0:	8f 5f       	subi	r24, 0xFF	; 255
    3dc2:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    3dc4:	88 23       	and	r24, r24
    3dc6:	21 f4       	brne	.+8      	; 0x3dd0 <ramDyskCzytajBajtZPliku+0x56>
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
    3dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    3dca:	8f 5f       	subi	r24, 0xFF	; 255
    3dcc:	8b 83       	std	Y+3, r24	; 0x03
    3dce:	05 c0       	rjmp	.+10     	; 0x3dda <ramDyskCzytajBajtZPliku+0x60>
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
    3dd0:	88 81       	ld	r24, Y
    3dd2:	99 81       	ldd	r25, Y+1	; 0x01
    3dd4:	01 96       	adiw	r24, 0x01	; 1
    3dd6:	88 83       	st	Y, r24
    3dd8:	99 83       	std	Y+1, r25	; 0x01
  return 0;
    3dda:	80 e0       	ldi	r24, 0x00	; 0
    3ddc:	01 c0       	rjmp	.+2      	; 0x3de0 <ramDyskCzytajBajtZPliku+0x66>
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof
    3dde:	81 e0       	ldi	r24, 0x01	; 1
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}
    3de0:	df 91       	pop	r29
    3de2:	cf 91       	pop	r28
    3de4:	1f 91       	pop	r17
    3de6:	0f 91       	pop	r16
    3de8:	08 95       	ret

00003dea <getSTD>:
  return wynik;
}


static int getSTD(FILE *stream)
{
    3dea:	df 93       	push	r29
    3dec:	cf 93       	push	r28
    3dee:	0f 92       	push	r0
    3df0:	cd b7       	in	r28, 0x3d	; 61
    3df2:	de b7       	in	r29, 0x3e	; 62
  uint8_t wynik;
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  
  if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
    3df4:	fc 01       	movw	r30, r24
    3df6:	84 85       	ldd	r24, Z+12	; 0x0c
    3df8:	95 85       	ldd	r25, Z+13	; 0x0d
    3dfa:	be 01       	movw	r22, r28
    3dfc:	6f 5f       	subi	r22, 0xFF	; 255
    3dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    3e00:	0e 94 bd 1e 	call	0x3d7a	; 0x3d7a <ramDyskCzytajBajtZPliku>
    3e04:	88 23       	and	r24, r24
    3e06:	19 f4       	brne	.+6      	; 0x3e0e <getSTD+0x24>
    return wynik;
    3e08:	29 81       	ldd	r18, Y+1	; 0x01
    3e0a:	30 e0       	ldi	r19, 0x00	; 0
    3e0c:	02 c0       	rjmp	.+4      	; 0x3e12 <getSTD+0x28>
  return EOF;
    3e0e:	2f ef       	ldi	r18, 0xFF	; 255
    3e10:	3f ef       	ldi	r19, 0xFF	; 255
}
    3e12:	c9 01       	movw	r24, r18
    3e14:	0f 90       	pop	r0
    3e16:	cf 91       	pop	r28
    3e18:	df 91       	pop	r29
    3e1a:	08 95       	ret

00003e1c <ramDyskZapiszBlokDoPliku>:
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}

uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3e1c:	8f 92       	push	r8
    3e1e:	9f 92       	push	r9
    3e20:	af 92       	push	r10
    3e22:	bf 92       	push	r11
    3e24:	df 92       	push	r13
    3e26:	ef 92       	push	r14
    3e28:	ff 92       	push	r15
    3e2a:	0f 93       	push	r16
    3e2c:	1f 93       	push	r17
    3e2e:	cf 93       	push	r28
    3e30:	df 93       	push	r29
    3e32:	ec 01       	movw	r28, r24
    3e34:	4b 01       	movw	r8, r22
    3e36:	5a 01       	movw	r10, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3e38:	0c 81       	ldd	r16, Y+4	; 0x04
    3e3a:	1d 81       	ldd	r17, Y+5	; 0x05
    3e3c:	f8 01       	movw	r30, r16
    3e3e:	80 81       	ld	r24, Z
    3e40:	88 23       	and	r24, r24
    3e42:	21 f4       	brne	.+8      	; 0x3e4c <ramDyskZapiszBlokDoPliku+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    3e44:	0e 94 b3 1c 	call	0x3966	; 0x3966 <znajdzWolnyKlaster>
    3e48:	f8 01       	movw	r30, r16
    3e4a:	80 83       	st	Z, r24
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
    3e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e4e:	00 e0       	ldi	r16, 0x00	; 0
    3e50:	11 e0       	ldi	r17, 0x01	; 1
    3e52:	08 1b       	sub	r16, r24
    3e54:	11 09       	sbc	r17, r1
  uint16_t doZapisu = *dlugosc;
    3e56:	f5 01       	movw	r30, r10
    3e58:	e0 80       	ld	r14, Z
    3e5a:	f1 80       	ldd	r15, Z+1	; 0x01
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
    3e5c:	10 82       	st	Z, r1
    3e5e:	11 82       	std	Z+1, r1	; 0x01
  uint8_t tmpKlaster = 0;
    3e60:	dd 24       	eor	r13, r13
  while (doZapisu > 0)
    3e62:	4e c0       	rjmp	.+156    	; 0x3f00 <ramDyskZapiszBlokDoPliku+0xe4>
  {
    if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to należy odczytać jego numer oraz ustawić na niego wskaźnik
    3e64:	8a 81       	ldd	r24, Y+2	; 0x02
    3e66:	88 23       	and	r24, r24
    3e68:	a9 f4       	brne	.+42     	; 0x3e94 <ramDyskZapiszBlokDoPliku+0x78>
    {
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
    3e6a:	dd 20       	and	r13, r13
    3e6c:	39 f4       	brne	.+14     	; 0x3e7c <ramDyskZapiszBlokDoPliku+0x60>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
    3e6e:	ec 81       	ldd	r30, Y+4	; 0x04
    3e70:	fd 81       	ldd	r31, Y+5	; 0x05
    3e72:	80 81       	ld	r24, Z
    3e74:	6b 81       	ldd	r22, Y+3	; 0x03
    3e76:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <znajdzKlasterN>
    3e7a:	03 c0       	rjmp	.+6      	; 0x3e82 <ramDyskZapiszBlokDoPliku+0x66>
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
    3e7c:	8d 2d       	mov	r24, r13
    3e7e:	0e 94 c8 1c 	call	0x3990	; 0x3990 <nastepnyKlaster>
    3e82:	d8 2e       	mov	r13, r24
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
    3e84:	88 23       	and	r24, r24
    3e86:	09 f4       	brne	.+2      	; 0x3e8a <ramDyskZapiszBlokDoPliku+0x6e>
    3e88:	44 c0       	rjmp	.+136    	; 0x3f12 <ramDyskZapiszBlokDoPliku+0xf6>
        return 1;                                 //1 - Brak wolnego klastra

      fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Teraz można do niego już pisać
    3e8a:	90 e0       	ldi	r25, 0x00	; 0
    3e8c:	80 58       	subi	r24, 0x80	; 128
    3e8e:	9f 4f       	sbci	r25, 0xFF	; 255
    3e90:	18 82       	st	Y, r1
    3e92:	89 83       	std	Y+1, r24	; 0x01
    3e94:	88 81       	ld	r24, Y
    3e96:	99 81       	ldd	r25, Y+1	; 0x01
    }
    if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w bieżącym klastrze
    3e98:	0e 15       	cp	r16, r14
    3e9a:	1f 05       	cpc	r17, r15
    3e9c:	b0 f4       	brcc	.+44     	; 0x3eca <ramDyskZapiszBlokDoPliku+0xae>
    {                                             //Nie uda się, teraz zapiszemy cały klastr do końca
      memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
    3e9e:	b4 01       	movw	r22, r8
    3ea0:	a8 01       	movw	r20, r16
    3ea2:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
      znaki +=dlBloku;                      
    3ea6:	80 0e       	add	r8, r16
    3ea8:	91 1e       	adc	r9, r17
      fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na początek nowego klastra. Kolejna iteracja go utworzy
    3eaa:	1a 82       	std	Y+2, r1	; 0x02
      doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka pozostałą do zapisujemy
    3eac:	e0 1a       	sub	r14, r16
    3eae:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych danych
    3eb0:	f5 01       	movw	r30, r10
    3eb2:	80 81       	ld	r24, Z
    3eb4:	91 81       	ldd	r25, Z+1	; 0x01
    3eb6:	80 0f       	add	r24, r16
    3eb8:	91 1f       	adc	r25, r17
    3eba:	80 83       	st	Z, r24
    3ebc:	91 83       	std	Z+1, r25	; 0x01
      fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. Oznacza to przejście do kolejnego klastra
    3ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec0:	8f 5f       	subi	r24, 0xFF	; 255
    3ec2:	8b 83       	std	Y+3, r24	; 0x03
      dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 bajtów
    3ec4:	00 e0       	ldi	r16, 0x00	; 0
    3ec6:	11 e0       	ldi	r17, 0x01	; 1
    3ec8:	1b c0       	rjmp	.+54     	; 0x3f00 <ramDyskZapiszBlokDoPliku+0xe4>
    }
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
    3eca:	b4 01       	movw	r22, r8
    3ecc:	a7 01       	movw	r20, r14
    3ece:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
    3ed2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ed4:	8e 0d       	add	r24, r14
    3ed6:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
    3ed8:	f5 01       	movw	r30, r10
    3eda:	80 81       	ld	r24, Z
    3edc:	91 81       	ldd	r25, Z+1	; 0x01
    3ede:	8e 0d       	add	r24, r14
    3ee0:	9f 1d       	adc	r25, r15
    3ee2:	80 83       	st	Z, r24
    3ee4:	91 83       	std	Z+1, r25	; 0x01
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    3ee6:	8d 2d       	mov	r24, r13
    3ee8:	90 e0       	ldi	r25, 0x00	; 0
    3eea:	80 58       	subi	r24, 0x80	; 128
    3eec:	9f 4f       	sbci	r25, 0xFF	; 255
    3eee:	98 2f       	mov	r25, r24
    3ef0:	88 27       	eor	r24, r24
    3ef2:	2a 81       	ldd	r18, Y+2	; 0x02
    3ef4:	82 0f       	add	r24, r18
    3ef6:	91 1d       	adc	r25, r1
    3ef8:	88 83       	st	Y, r24
    3efa:	99 83       	std	Y+1, r25	; 0x01
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
    3efc:	ee 24       	eor	r14, r14
    3efe:	ff 24       	eor	r15, r15
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
  uint16_t doZapisu = *dlugosc;
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
    3f00:	e1 14       	cp	r14, r1
    3f02:	f1 04       	cpc	r15, r1
    3f04:	09 f0       	breq	.+2      	; 0x3f08 <ramDyskZapiszBlokDoPliku+0xec>
    3f06:	ae cf       	rjmp	.-164    	; 0x3e64 <ramDyskZapiszBlokDoPliku+0x48>
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
    3f08:	ce 01       	movw	r24, r28
    3f0a:	0e 94 84 1c 	call	0x3908	; 0x3908 <uaktualnijRozmiarPliku>
  return 0;
    3f0e:	80 e0       	ldi	r24, 0x00	; 0
    3f10:	01 c0       	rjmp	.+2      	; 0x3f14 <ramDyskZapiszBlokDoPliku+0xf8>
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
        return 1;                                 //1 - Brak wolnego klastra
    3f12:	81 e0       	ldi	r24, 0x01	; 1
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}
    3f14:	df 91       	pop	r29
    3f16:	cf 91       	pop	r28
    3f18:	1f 91       	pop	r17
    3f1a:	0f 91       	pop	r16
    3f1c:	ff 90       	pop	r15
    3f1e:	ef 90       	pop	r14
    3f20:	df 90       	pop	r13
    3f22:	bf 90       	pop	r11
    3f24:	af 90       	pop	r10
    3f26:	9f 90       	pop	r9
    3f28:	8f 90       	pop	r8
    3f2a:	08 95       	ret

00003f2c <ramDyskCzytajBlokZPliku>:

uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3f2c:	8f 92       	push	r8
    3f2e:	9f 92       	push	r9
    3f30:	bf 92       	push	r11
    3f32:	cf 92       	push	r12
    3f34:	df 92       	push	r13
    3f36:	ef 92       	push	r14
    3f38:	ff 92       	push	r15
    3f3a:	0f 93       	push	r16
    3f3c:	1f 93       	push	r17
    3f3e:	cf 93       	push	r28
    3f40:	df 93       	push	r29
    3f42:	ec 01       	movw	r28, r24
    3f44:	4b 01       	movw	r8, r22
    3f46:	6a 01       	movw	r12, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3f48:	ec 81       	ldd	r30, Y+4	; 0x04
    3f4a:	fd 81       	ldd	r31, Y+5	; 0x05
    3f4c:	80 81       	ld	r24, Z
    3f4e:	88 23       	and	r24, r24
    3f50:	29 f4       	brne	.+10     	; 0x3f5c <ramDyskCzytajBlokZPliku+0x30>
  {
    *dlugosc = 0;
    3f52:	fa 01       	movw	r30, r20
    3f54:	10 82       	st	Z, r1
    3f56:	11 82       	std	Z+1, r1	; 0x01
    return 1;                         //1 - Plik jest pusty
    3f58:	81 e0       	ldi	r24, 0x01	; 1
    3f5a:	78 c0       	rjmp	.+240    	; 0x404c <__stack+0x4d>
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3f5c:	22 81       	ldd	r18, Z+2	; 0x02
    3f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f60:	82 17       	cp	r24, r18
    3f62:	40 f0       	brcs	.+16     	; 0x3f74 <ramDyskCzytajBlokZPliku+0x48>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3f64:	28 17       	cp	r18, r24
    3f66:	09 f0       	breq	.+2      	; 0x3f6a <ramDyskCzytajBlokZPliku+0x3e>
    3f68:	7d c0       	rjmp	.+250    	; 0x4064 <__stack+0x65>
    3f6a:	31 81       	ldd	r19, Z+1	; 0x01
    3f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f6e:	39 17       	cp	r19, r25
    3f70:	08 f4       	brcc	.+2      	; 0x3f74 <ramDyskCzytajBlokZPliku+0x48>
    3f72:	78 c0       	rjmp	.+240    	; 0x4064 <__stack+0x65>
  {
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
    3f74:	30 e0       	ldi	r19, 0x00	; 0
    3f76:	28 1b       	sub	r18, r24
    3f78:	31 09       	sbc	r19, r1
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3f7a:	81 81       	ldd	r24, Z+1	; 0x01
    3f7c:	90 e0       	ldi	r25, 0x00	; 0
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
    3f7e:	4a 81       	ldd	r20, Y+2	; 0x02
    *dlugosc = 0;
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3f80:	84 1b       	sub	r24, r20
    3f82:	91 09       	sbc	r25, r1
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
    3f84:	82 0f       	add	r24, r18
    3f86:	93 1f       	adc	r25, r19
  
  uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i określenie ile bajtów zdoła się odczytać
    3f88:	f6 01       	movw	r30, r12
    3f8a:	00 81       	ld	r16, Z
    3f8c:	11 81       	ldd	r17, Z+1	; 0x01
    3f8e:	80 17       	cp	r24, r16
    3f90:	91 07       	cpc	r25, r17
    3f92:	08 f4       	brcc	.+2      	; 0x3f96 <ramDyskCzytajBlokZPliku+0x6a>
    3f94:	8c 01       	movw	r16, r24
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
    3f96:	f6 01       	movw	r30, r12
    3f98:	10 82       	st	Z, r1
    3f9a:	11 82       	std	Z+1, r1	; 0x01
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
    3f9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f9e:	e1 2c       	mov	r14, r1
    3fa0:	e1 e0       	ldi	r30, 0x01	; 1
    3fa2:	fe 2e       	mov	r15, r30
    3fa4:	e8 1a       	sub	r14, r24
    3fa6:	f1 08       	sbc	r15, r1
  uint8_t tmpKlaster = 0;
    3fa8:	bb 24       	eor	r11, r11
  while (doOdczytania > 0)
    3faa:	49 c0       	rjmp	.+146    	; 0x403e <__stack+0x3f>
  {
    if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, że wskaźnik nie jest jeszcze ustawiony
    3fac:	8a 81       	ldd	r24, Y+2	; 0x02
    3fae:	88 23       	and	r24, r24
    3fb0:	a1 f4       	brne	.+40     	; 0x3fda <ramDyskCzytajBlokZPliku+0xae>
    {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (od początkowego) należy się przesunąć do przodu
      if (tmpKlaster == 0)
    3fb2:	bb 20       	and	r11, r11
    3fb4:	39 f4       	brne	.+14     	; 0x3fc4 <ramDyskCzytajBlokZPliku+0x98>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
    3fb6:	ec 81       	ldd	r30, Y+4	; 0x04
    3fb8:	fd 81       	ldd	r31, Y+5	; 0x05
    3fba:	80 81       	ld	r24, Z
    3fbc:	6b 81       	ldd	r22, Y+3	; 0x03
    3fbe:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <znajdzKlasterN>
    3fc2:	03 c0       	rjmp	.+6      	; 0x3fca <ramDyskCzytajBlokZPliku+0x9e>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
    3fc4:	8b 2d       	mov	r24, r11
    3fc6:	0e 94 c8 1c 	call	0x3990	; 0x3990 <nastepnyKlaster>
    3fca:	b8 2e       	mov	r11, r24
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
    3fcc:	88 23       	and	r24, r24
    3fce:	e9 f1       	breq	.+122    	; 0x404a <__stack+0x4b>
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
    3fd0:	90 e0       	ldi	r25, 0x00	; 0
    3fd2:	80 58       	subi	r24, 0x80	; 128
    3fd4:	9f 4f       	sbci	r25, 0xFF	; 255
    3fd6:	18 82       	st	Y, r1
    3fd8:	89 83       	std	Y+1, r24	; 0x01
    3fda:	68 81       	ld	r22, Y
    3fdc:	79 81       	ldd	r23, Y+1	; 0x01
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    }
    
    if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
    3fde:	e0 16       	cp	r14, r16
    3fe0:	f1 06       	cpc	r15, r17
    3fe2:	b8 f4       	brcc	.+46     	; 0x4012 <__stack+0x13>
    {                                  //dlBloku określa ile zostało jeszcze bajtów do końca klasrta
      memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
    3fe4:	c4 01       	movw	r24, r8
    3fe6:	a7 01       	movw	r20, r14
    3fe8:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
      znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy odczytane bajty
    3fec:	8e 0c       	add	r8, r14
    3fee:	9f 1c       	adc	r9, r15
      fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
    3ff0:	1a 82       	std	Y+2, r1	; 0x02
      fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz nie ma potrzeby ustawienia wskaźnika odczytu na jego początek
    3ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ff4:	8f 5f       	subi	r24, 0xFF	; 255
    3ff6:	8b 83       	std	Y+3, r24	; 0x03
      doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
    3ff8:	0e 19       	sub	r16, r14
    3ffa:	1f 09       	sbc	r17, r15
      *dlugosc += dlBloku;             //Uaktualnienie 
    3ffc:	f6 01       	movw	r30, r12
    3ffe:	80 81       	ld	r24, Z
    4000:	91 81       	ldd	r25, Z+1	; 0x01
    4002:	8e 0d       	add	r24, r14
    4004:	9f 1d       	adc	r25, r15
    4006:	80 83       	st	Z, r24
    4008:	91 83       	std	Z+1, r25	; 0x01
      dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całego klastra.
    400a:	e1 2c       	mov	r14, r1
    400c:	71 e0       	ldi	r23, 0x01	; 1
    400e:	f7 2e       	mov	r15, r23
    4010:	16 c0       	rjmp	.+44     	; 0x403e <__stack+0x3f>
    }
    else                               //Ostatnia operacja odczytu
    {
      memcpy(znaki, fd->Wsk, doOdczytania);
    4012:	c4 01       	movw	r24, r8
    4014:	a8 01       	movw	r20, r16
    4016:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
      fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym samym klastrze, zatem trzeba teraz uaktualnić wzkaźnik
    401a:	88 81       	ld	r24, Y
    401c:	99 81       	ldd	r25, Y+1	; 0x01
    401e:	80 0f       	add	r24, r16
    4020:	91 1f       	adc	r25, r17
    4022:	88 83       	st	Y, r24
    4024:	99 83       	std	Y+1, r25	; 0x01
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
    4026:	8a 81       	ldd	r24, Y+2	; 0x02
    4028:	80 0f       	add	r24, r16
    402a:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
    402c:	f6 01       	movw	r30, r12
    402e:	80 81       	ld	r24, Z
    4030:	91 81       	ldd	r25, Z+1	; 0x01
    4032:	80 0f       	add	r24, r16
    4034:	91 1f       	adc	r25, r17
    4036:	80 83       	st	Z, r24
    4038:	91 83       	std	Z+1, r25	; 0x01
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    403a:	00 e0       	ldi	r16, 0x00	; 0
    403c:	10 e0       	ldi	r17, 0x00	; 0
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
    403e:	01 15       	cp	r16, r1
    4040:	11 05       	cpc	r17, r1
    4042:	09 f0       	breq	.+2      	; 0x4046 <__stack+0x47>
    4044:	b3 cf       	rjmp	.-154    	; 0x3fac <ramDyskCzytajBlokZPliku+0x80>
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
    4046:	80 e0       	ldi	r24, 0x00	; 0
    4048:	01 c0       	rjmp	.+2      	; 0x404c <__stack+0x4d>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    404a:	83 e0       	ldi	r24, 0x03	; 3
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                    
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
}
    404c:	df 91       	pop	r29
    404e:	cf 91       	pop	r28
    4050:	1f 91       	pop	r17
    4052:	0f 91       	pop	r16
    4054:	ff 90       	pop	r15
    4056:	ef 90       	pop	r14
    4058:	df 90       	pop	r13
    405a:	cf 90       	pop	r12
    405c:	bf 90       	pop	r11
    405e:	9f 90       	pop	r9
    4060:	8f 90       	pop	r8
    4062:	08 95       	ret
    *dlugosc = 0;
    return 1;                         //1 - Plik jest pusty
  }
  if (wObrebiePliku(fd) != 0)
  {
    *dlugosc = 0;
    4064:	f6 01       	movw	r30, r12
    4066:	10 82       	st	Z, r1
    4068:	11 82       	std	Z+1, r1	; 0x01
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
    406a:	82 e0       	ldi	r24, 0x02	; 2
    406c:	ef cf       	rjmp	.-34     	; 0x404c <__stack+0x4d>

0000406e <ramDyskUstawWskaznik>:
  }
  return 0;
}

uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
{
    406e:	ef 92       	push	r14
    4070:	ff 92       	push	r15
    4072:	0f 93       	push	r16
    4074:	1f 93       	push	r17
    4076:	cf 93       	push	r28
    4078:	df 93       	push	r29
    407a:	ec 01       	movw	r28, r24
  if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje na początek pliku.
    407c:	61 15       	cp	r22, r1
    407e:	71 05       	cpc	r23, r1
    4080:	19 f4       	brne	.+6      	; 0x4088 <ramDyskUstawWskaznik+0x1a>
  {                                                       //Jeśli tak, to nie ma potzeby tworzenia klastrów. Plik może nadal nei mieć żadnego klastra.
    fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bardziej znaczącego bajtu)
    4082:	1a 82       	std	Y+2, r1	; 0x02
    fd->IndHi = 0;
    4084:	1b 82       	std	Y+3, r1	; 0x03
    4086:	2e c0       	rjmp	.+92     	; 0x40e4 <ramDyskUstawWskaznik+0x76>
    return 0;
  }
  indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio ustawić rozmair pliku.
    4088:	8b 01       	movw	r16, r22
    408a:	01 50       	subi	r16, 0x01	; 1
    408c:	10 40       	sbci	r17, 0x00	; 0
                                                          //Jeśli indeks jest większy niż rozmiar pliku, to plik zostanie rozciągnięty do zadanej wartości indeksu -1
  
  if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydzielony pierwszy klaster
    408e:	ec 80       	ldd	r14, Y+4	; 0x04
    4090:	fd 80       	ldd	r15, Y+5	; 0x05
    4092:	f7 01       	movw	r30, r14
    4094:	80 81       	ld	r24, Z
    4096:	88 23       	and	r24, r24
    4098:	21 f4       	brne	.+8      	; 0x40a2 <ramDyskUstawWskaznik+0x34>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pliku. Jest to konieczne, ponieważ klaster ma wartość niezerową
    409a:	0e 94 b3 1c 	call	0x3966	; 0x3966 <znajdzWolnyKlaster>
    409e:	f7 01       	movw	r30, r14
    40a0:	80 83       	st	Z, r24

  uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką należy dodać do pierwszego klastra`

  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
    40a2:	0a 83       	std	Y+2, r16	; 0x02
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
    40a4:	1b 83       	std	Y+3, r17	; 0x03
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
    40a6:	ec 81       	ldd	r30, Y+4	; 0x04
    40a8:	fd 81       	ldd	r31, Y+5	; 0x05
    40aa:	80 81       	ld	r24, Z
    40ac:	61 2f       	mov	r22, r17
    40ae:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <znajdzKlasterN>
    40b2:	08 2f       	mov	r16, r24
  if (nrKlastra == 0)
    40b4:	88 23       	and	r24, r24
    40b6:	c1 f0       	breq	.+48     	; 0x40e8 <ramDyskUstawWskaznik+0x7a>
    return 1;                                             //Brak klastrów

  uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
    40b8:	ce 01       	movw	r24, r28
    40ba:	0e 94 84 1c 	call	0x3908	; 0x3908 <uaktualnijRozmiarPliku>

  fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
    40be:	2a 81       	ldd	r18, Y+2	; 0x02
    40c0:	2f 5f       	subi	r18, 0xFF	; 255
    40c2:	2a 83       	std	Y+2, r18	; 0x02
  if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, to jeszcze on nie iestnieje
    40c4:	22 23       	and	r18, r18
    40c6:	21 f4       	brne	.+8      	; 0x40d0 <ramDyskUstawWskaznik+0x62>
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
    40c8:	8b 81       	ldd	r24, Y+3	; 0x03
    40ca:	8f 5f       	subi	r24, 0xFF	; 255
    40cc:	8b 83       	std	Y+3, r24	; 0x03
    40ce:	0a c0       	rjmp	.+20     	; 0x40e4 <ramDyskUstawWskaznik+0x76>
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra
    40d0:	80 2f       	mov	r24, r16
    40d2:	90 e0       	ldi	r25, 0x00	; 0
    40d4:	80 58       	subi	r24, 0x80	; 128
    40d6:	9f 4f       	sbci	r25, 0xFF	; 255
    40d8:	98 2f       	mov	r25, r24
    40da:	88 27       	eor	r24, r24
    40dc:	82 0f       	add	r24, r18
    40de:	91 1d       	adc	r25, r1
    40e0:	88 83       	st	Y, r24
    40e2:	99 83       	std	Y+1, r25	; 0x01

  return 0; 
    40e4:	80 e0       	ldi	r24, 0x00	; 0
    40e6:	01 c0       	rjmp	.+2      	; 0x40ea <ramDyskUstawWskaznik+0x7c>
  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
  if (nrKlastra == 0)
    return 1;                                             //Brak klastrów
    40e8:	81 e0       	ldi	r24, 0x01	; 1
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra

  return 0; 
}
    40ea:	df 91       	pop	r29
    40ec:	cf 91       	pop	r28
    40ee:	1f 91       	pop	r17
    40f0:	0f 91       	pop	r16
    40f2:	ff 90       	pop	r15
    40f4:	ef 90       	pop	r14
    40f6:	08 95       	ret

000040f8 <ramDyskUstawWskaznikNaKoniec>:

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
    40f8:	cf 93       	push	r28
    40fa:	df 93       	push	r29
    40fc:	ec 01       	movw	r28, r24
  if (fd == NULL)
    40fe:	00 97       	sbiw	r24, 0x00	; 0
    4100:	b9 f0       	breq	.+46     	; 0x4130 <ramDyskUstawWskaznikNaKoniec+0x38>
    return 1;
  fd->IndLo = fd->wpis->rozmiarLo;
    4102:	ec 81       	ldd	r30, Y+4	; 0x04
    4104:	fd 81       	ldd	r31, Y+5	; 0x05
    4106:	81 81       	ldd	r24, Z+1	; 0x01
    4108:	8a 83       	std	Y+2, r24	; 0x02
  fd->IndHi = fd->wpis->rozmiarHi;
    410a:	92 81       	ldd	r25, Z+2	; 0x02
    410c:	9b 83       	std	Y+3, r25	; 0x03
//  fd->IndLo++;
  uint8_t tmpKlaster = 0;
  if (fd->IndLo != 0)
    410e:	88 23       	and	r24, r24
    4110:	89 f0       	breq	.+34     	; 0x4134 <ramDyskUstawWskaznikNaKoniec+0x3c>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    4112:	80 81       	ld	r24, Z
    4114:	62 81       	ldd	r22, Z+2	; 0x02
    4116:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <znajdzKlasterN>
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
    411a:	90 e0       	ldi	r25, 0x00	; 0
    411c:	80 58       	subi	r24, 0x80	; 128
    411e:	9f 4f       	sbci	r25, 0xFF	; 255
    4120:	98 2f       	mov	r25, r24
    4122:	88 27       	eor	r24, r24
    4124:	2a 81       	ldd	r18, Y+2	; 0x02
    4126:	82 0f       	add	r24, r18
    4128:	91 1d       	adc	r25, r1
    412a:	88 83       	st	Y, r24
    412c:	99 83       	std	Y+1, r25	; 0x01
    412e:	02 c0       	rjmp	.+4      	; 0x4134 <ramDyskUstawWskaznikNaKoniec+0x3c>
}

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
  if (fd == NULL)
    return 1;
    4130:	81 e0       	ldi	r24, 0x01	; 1
    4132:	01 c0       	rjmp	.+2      	; 0x4136 <ramDyskUstawWskaznikNaKoniec+0x3e>
  if (fd->IndLo != 0)
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
  }  
  return 0;
    4134:	80 e0       	ldi	r24, 0x00	; 0
}
    4136:	df 91       	pop	r29
    4138:	cf 91       	pop	r28
    413a:	08 95       	ret

0000413c <ramDyskDodajBlokXmodem>:

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
    413c:	bf 92       	push	r11
    413e:	cf 92       	push	r12
    4140:	df 92       	push	r13
    4142:	ef 92       	push	r14
    4144:	ff 92       	push	r15
    4146:	0f 93       	push	r16
    4148:	1f 93       	push	r17
    414a:	cf 93       	push	r28
    414c:	df 93       	push	r29
    414e:	8c 01       	movw	r16, r24
    4150:	6b 01       	movw	r12, r22
  if (nrBloku == 0)
    4152:	61 15       	cp	r22, r1
    4154:	71 05       	cpc	r23, r1
    4156:	09 f4       	brne	.+2      	; 0x415a <ramDyskDodajBlokXmodem+0x1e>
    4158:	4f c0       	rjmp	.+158    	; 0x41f8 <ramDyskDodajBlokXmodem+0xbc>
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
  uint8_t indLo = 0;
  uint8_t *wynik;
  
  if (fd->wpis->pierwszyKlaster == 0)
    415a:	dc 01       	movw	r26, r24
    415c:	14 96       	adiw	r26, 0x04	; 4
    415e:	ed 90       	ld	r14, X+
    4160:	fc 90       	ld	r15, X
    4162:	15 97       	sbiw	r26, 0x05	; 5
    4164:	f7 01       	movw	r30, r14
    4166:	80 81       	ld	r24, Z
    4168:	88 23       	and	r24, r24
    416a:	21 f4       	brne	.+8      	; 0x4174 <ramDyskDodajBlokXmodem+0x38>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    416c:	0e 94 b3 1c 	call	0x3966	; 0x3966 <znajdzWolnyKlaster>
    4170:	d7 01       	movw	r26, r14
    4172:	8c 93       	st	X, r24
  if (fd->wpis->pierwszyKlaster == 0)
    4174:	d8 01       	movw	r26, r16
    4176:	14 96       	adiw	r26, 0x04	; 4
    4178:	ed 91       	ld	r30, X+
    417a:	fc 91       	ld	r31, X
    417c:	15 97       	sbiw	r26, 0x05	; 5
    417e:	80 81       	ld	r24, Z
    4180:	88 23       	and	r24, r24
    4182:	d1 f1       	breq	.+116    	; 0x41f8 <ramDyskDodajBlokXmodem+0xbc>

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
  if (nrBloku == 0)
    return NULL;
  nrBloku --;
    4184:	08 94       	sec
    4186:	c1 08       	sbc	r12, r1
    4188:	d1 08       	sbc	r13, r1
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
    418a:	76 01       	movw	r14, r12
    418c:	f6 94       	lsr	r15
    418e:	e7 94       	ror	r14
    4190:	be 2c       	mov	r11, r14
  if (fd->wpis->pierwszyKlaster == 0)
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
    4192:	6e 2d       	mov	r22, r14
    4194:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <znajdzKlasterN>
  if (tmpKlaster == 0)
    4198:	88 23       	and	r24, r24
    419a:	71 f1       	breq	.+92     	; 0x41f8 <ramDyskDodajBlokXmodem+0xbc>
    419c:	d8 01       	movw	r26, r16
    419e:	14 96       	adiw	r26, 0x04	; 4
    41a0:	ed 91       	ld	r30, X+
    41a2:	fc 91       	ld	r31, X
    41a4:	15 97       	sbiw	r26, 0x05	; 5
    return NULL;
  if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
    41a6:	c0 fe       	sbrs	r12, 0
    41a8:	0f c0       	rjmp	.+30     	; 0x41c8 <ramDyskDodajBlokXmodem+0x8c>
  {
    indLo = 128;
    if (fd->wpis->rozmiarHi <= indHi)
    41aa:	92 81       	ldd	r25, Z+2	; 0x02
    41ac:	e9 16       	cp	r14, r25
    41ae:	38 f0       	brcs	.+14     	; 0x41be <ramDyskDodajBlokXmodem+0x82>
    {
      fd->wpis->rozmiarHi = indHi+1;
    41b0:	b3 94       	inc	r11
    41b2:	b2 82       	std	Z+2, r11	; 0x02
      fd->wpis->rozmiarLo = 0;
    41b4:	14 96       	adiw	r26, 0x04	; 4
    41b6:	ed 91       	ld	r30, X+
    41b8:	fc 91       	ld	r31, X
    41ba:	15 97       	sbiw	r26, 0x05	; 5
    41bc:	11 82       	std	Z+1, r1	; 0x01
    }
    wynik=dataPtr(tmpKlaster, 128);
    41be:	80 e0       	ldi	r24, 0x00	; 0
    41c0:	ec 01       	movw	r28, r24
    41c2:	c0 58       	subi	r28, 0x80	; 128
    41c4:	df 47       	sbci	r29, 0x7F	; 127
    41c6:	1a c0       	rjmp	.+52     	; 0x41fc <ramDyskDodajBlokXmodem+0xc0>
  }
  else
  {
    if (fd->wpis->rozmiarHi < indHi)
    41c8:	92 81       	ldd	r25, Z+2	; 0x02
    41ca:	9e 15       	cp	r25, r14
    41cc:	38 f4       	brcc	.+14     	; 0x41dc <ramDyskDodajBlokXmodem+0xa0>
    {
      fd->wpis->rozmiarHi = indHi;
    41ce:	e2 82       	std	Z+2, r14	; 0x02
      fd->wpis->rozmiarLo = 128;
    41d0:	d8 01       	movw	r26, r16
    41d2:	14 96       	adiw	r26, 0x04	; 4
    41d4:	ed 91       	ld	r30, X+
    41d6:	fc 91       	ld	r31, X
    41d8:	15 97       	sbiw	r26, 0x05	; 5
    41da:	05 c0       	rjmp	.+10     	; 0x41e6 <ramDyskDodajBlokXmodem+0xaa>
    }
    else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
    41dc:	9e 15       	cp	r25, r14
    41de:	29 f4       	brne	.+10     	; 0x41ea <ramDyskDodajBlokXmodem+0xae>
    41e0:	91 81       	ldd	r25, Z+1	; 0x01
    41e2:	97 fd       	sbrc	r25, 7
    41e4:	02 c0       	rjmp	.+4      	; 0x41ea <ramDyskDodajBlokXmodem+0xae>
      fd->wpis->rozmiarLo = 128;
    41e6:	90 e8       	ldi	r25, 0x80	; 128
    41e8:	91 83       	std	Z+1, r25	; 0x01
    
    wynik=dataPtr(tmpKlaster, 0);
    41ea:	c8 2f       	mov	r28, r24
    41ec:	d0 e0       	ldi	r29, 0x00	; 0
    41ee:	c0 58       	subi	r28, 0x80	; 128
    41f0:	df 4f       	sbci	r29, 0xFF	; 255
    41f2:	dc 2f       	mov	r29, r28
    41f4:	cc 27       	eor	r28, r28
    41f6:	02 c0       	rjmp	.+4      	; 0x41fc <ramDyskDodajBlokXmodem+0xc0>
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
  if (tmpKlaster == 0)
    return NULL;
    41f8:	c0 e0       	ldi	r28, 0x00	; 0
    41fa:	d0 e0       	ldi	r29, 0x00	; 0
      fd->wpis->rozmiarLo = 128;
    
    wynik=dataPtr(tmpKlaster, 0);
  }
  return wynik;
}
    41fc:	ce 01       	movw	r24, r28
    41fe:	df 91       	pop	r29
    4200:	cf 91       	pop	r28
    4202:	1f 91       	pop	r17
    4204:	0f 91       	pop	r16
    4206:	ff 90       	pop	r15
    4208:	ef 90       	pop	r14
    420a:	df 90       	pop	r13
    420c:	cf 90       	pop	r12
    420e:	bf 90       	pop	r11
    4210:	08 95       	ret

00004212 <ramDyskDir>:

void ramDyskDir(FILE *ostream)
{
    4212:	2f 92       	push	r2
    4214:	3f 92       	push	r3
    4216:	4f 92       	push	r4
    4218:	5f 92       	push	r5
    421a:	6f 92       	push	r6
    421c:	7f 92       	push	r7
    421e:	9f 92       	push	r9
    4220:	af 92       	push	r10
    4222:	bf 92       	push	r11
    4224:	cf 92       	push	r12
    4226:	df 92       	push	r13
    4228:	ef 92       	push	r14
    422a:	ff 92       	push	r15
    422c:	0f 93       	push	r16
    422e:	1f 93       	push	r17
    4230:	cf 93       	push	r28
    4232:	df 93       	push	r29
    4234:	8c 01       	movw	r16, r24
  fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
    4236:	85 eb       	ldi	r24, 0xB5	; 181
    4238:	94 e2       	ldi	r25, 0x24	; 36
    423a:	b8 01       	movw	r22, r16
    423c:	0e 94 17 58 	call	0xb02e	; 0xb02e <fputs>
  struct ramPlik *plik;
  uint8_t tmpKlaster = 0;
    4240:	aa 24       	eor	r10, r10
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    4242:	4e ec       	ldi	r20, 0xCE	; 206
    4244:	24 2e       	mov	r2, r20
    4246:	44 e2       	ldi	r20, 0x24	; 36
    4248:	34 2e       	mov	r3, r20
    424a:	01 c0       	rjmp	.+2      	; 0x424e <ramDyskDir+0x3c>
      plik++;
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    424c:	a8 2e       	mov	r10, r24
  uint8_t tmpKlaster = 0;
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    424e:	ca 2c       	mov	r12, r10
    4250:	dd 24       	eor	r13, r13
    4252:	e6 01       	movw	r28, r12
    4254:	c0 58       	subi	r28, 0x80	; 128
    4256:	df 4f       	sbci	r29, 0xFF	; 255
    4258:	dc 2f       	mov	r29, r28
    425a:	cc 27       	eor	r28, r28
    wynik=dataPtr(tmpKlaster, 0);
  }
  return wynik;
}

void ramDyskDir(FILE *ostream)
    425c:	20 ef       	ldi	r18, 0xF0	; 240
    425e:	62 2e       	mov	r6, r18
    4260:	71 2c       	mov	r7, r1
    4262:	6c 0e       	add	r6, r28
    4264:	7d 1e       	adc	r7, r29
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    {
      tmp3=plik->nazwa[0];
    4266:	bc 80       	ldd	r11, Y+4	; 0x04
      if (tmp3 == 0)
    4268:	bb 20       	and	r11, r11
    426a:	09 f4       	brne	.+2      	; 0x426e <ramDyskDir+0x5c>
    426c:	48 c0       	rjmp	.+144    	; 0x42fe <ramDyskDir+0xec>
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
    426e:	8b 2d       	mov	r24, r11
    4270:	90 e0       	ldi	r25, 0x00	; 0
    4272:	b8 01       	movw	r22, r16
    4274:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    4278:	7e 01       	movw	r14, r28
      for (tmp2=1; tmp2<8; tmp2++)
    427a:	99 24       	eor	r9, r9
    427c:	93 94       	inc	r9
      {
        if (tmp3 != 0)
    427e:	bb 20       	and	r11, r11
    4280:	61 f0       	breq	.+24     	; 0x429a <ramDyskDir+0x88>
          tmp3=plik->nazwa[tmp2];
    4282:	d7 01       	movw	r26, r14
    4284:	15 96       	adiw	r26, 0x05	; 5
    4286:	bc 90       	ld	r11, X
    4288:	15 97       	sbiw	r26, 0x05	; 5

        if (tmp3 != 0)
    428a:	bb 20       	and	r11, r11
    428c:	31 f0       	breq	.+12     	; 0x429a <ramDyskDir+0x88>
          fputc(tmp3     , ostream);
    428e:	8b 2d       	mov	r24, r11
    4290:	90 e0       	ldi	r25, 0x00	; 0
    4292:	b8 01       	movw	r22, r16
    4294:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    4298:	06 c0       	rjmp	.+12     	; 0x42a6 <ramDyskDir+0x94>
        else
          fputc(' '      , ostream);
    429a:	80 e2       	ldi	r24, 0x20	; 32
    429c:	90 e0       	ldi	r25, 0x00	; 0
    429e:	b8 01       	movw	r22, r16
    42a0:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    42a4:	bb 24       	eor	r11, r11
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
    42a6:	93 94       	inc	r9
    42a8:	08 94       	sec
    42aa:	e1 1c       	adc	r14, r1
    42ac:	f1 1c       	adc	r15, r1
    42ae:	b9 2d       	mov	r27, r9
    42b0:	b8 30       	cpi	r27, 0x08	; 8
    42b2:	29 f7       	brne	.-54     	; 0x427e <ramDyskDir+0x6c>
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    42b4:	ed b7       	in	r30, 0x3d	; 61
    42b6:	fe b7       	in	r31, 0x3e	; 62
    42b8:	38 97       	sbiw	r30, 0x08	; 8
    42ba:	ed bf       	out	0x3d, r30	; 61
    42bc:	fe bf       	out	0x3e, r31	; 62
    42be:	31 96       	adiw	r30, 0x01	; 1
    42c0:	ad b7       	in	r26, 0x3d	; 61
    42c2:	be b7       	in	r27, 0x3e	; 62
    42c4:	11 96       	adiw	r26, 0x01	; 1
    42c6:	0d 93       	st	X+, r16
    42c8:	1c 93       	st	X, r17
    42ca:	12 97       	sbiw	r26, 0x02	; 2
    42cc:	22 82       	std	Z+2, r2	; 0x02
    42ce:	33 82       	std	Z+3, r3	; 0x03
    42d0:	5a 80       	ldd	r5, Y+2	; 0x02
    42d2:	44 24       	eor	r4, r4
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	92 01       	movw	r18, r4
    42d8:	28 0f       	add	r18, r24
    42da:	31 1d       	adc	r19, r1
    42dc:	24 83       	std	Z+4, r18	; 0x04
    42de:	35 83       	std	Z+5, r19	; 0x05
    42e0:	8b 81       	ldd	r24, Y+3	; 0x03
    42e2:	86 83       	std	Z+6, r24	; 0x06
    42e4:	17 82       	std	Z+7, r1	; 0x07
    42e6:	0e 94 be 57 	call	0xaf7c	; 0xaf7c <fprintf>
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    42ea:	8d b7       	in	r24, 0x3d	; 61
    42ec:	9e b7       	in	r25, 0x3e	; 62
    42ee:	08 96       	adiw	r24, 0x08	; 8
    42f0:	8d bf       	out	0x3d, r24	; 61
    42f2:	9e bf       	out	0x3e, r25	; 62
    42f4:	c6 15       	cp	r28, r6
    42f6:	d7 05       	cpc	r29, r7
    42f8:	11 f0       	breq	.+4      	; 0x42fe <ramDyskDir+0xec>
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
      plik++;
    42fa:	60 96       	adiw	r28, 0x10	; 16
    42fc:	b4 cf       	rjmp	.-152    	; 0x4266 <ramDyskDir+0x54>
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    42fe:	f6 01       	movw	r30, r12
    4300:	e3 5d       	subi	r30, 0xD3	; 211
    4302:	fd 4c       	sbci	r31, 0xCD	; 205
    4304:	80 81       	ld	r24, Z
  }
  while (tmpKlaster != tmpKlaster2);
    4306:	8a 15       	cp	r24, r10
    4308:	09 f0       	breq	.+2      	; 0x430c <ramDyskDir+0xfa>
    430a:	a0 cf       	rjmp	.-192    	; 0x424c <ramDyskDir+0x3a>
}
    430c:	df 91       	pop	r29
    430e:	cf 91       	pop	r28
    4310:	1f 91       	pop	r17
    4312:	0f 91       	pop	r16
    4314:	ff 90       	pop	r15
    4316:	ef 90       	pop	r14
    4318:	df 90       	pop	r13
    431a:	cf 90       	pop	r12
    431c:	bf 90       	pop	r11
    431e:	af 90       	pop	r10
    4320:	9f 90       	pop	r9
    4322:	7f 90       	pop	r7
    4324:	6f 90       	pop	r6
    4326:	5f 90       	pop	r5
    4328:	4f 90       	pop	r4
    432a:	3f 90       	pop	r3
    432c:	2f 90       	pop	r2
    432e:	08 95       	ret

00004330 <ramDyskLiczbaWolnychKlastrow>:

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
    4330:	ed ea       	ldi	r30, 0xAD	; 173
    4332:	f2 e3       	ldi	r31, 0x32	; 50
    4334:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    if (klastry[temp] == 0)
    4336:	92 91       	ld	r25, -Z
    4338:	99 23       	and	r25, r25
    433a:	09 f4       	brne	.+2      	; 0x433e <ramDyskLiczbaWolnychKlastrow+0xe>
      wynik++;
    433c:	8f 5f       	subi	r24, 0xFF	; 255

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    433e:	92 e3       	ldi	r25, 0x32	; 50
    4340:	ee 32       	cpi	r30, 0x2E	; 46
    4342:	f9 07       	cpc	r31, r25
    4344:	c1 f7       	brne	.-16     	; 0x4336 <ramDyskLiczbaWolnychKlastrow+0x6>
    if (klastry[temp] == 0)
      wynik++;
  return wynik;
}
    4346:	08 95       	ret

00004348 <ramDyskOtworzPlikStdIo>:
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
}

uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags)
{
    4348:	ef 92       	push	r14
    434a:	ff 92       	push	r15
    434c:	0f 93       	push	r16
    434e:	1f 93       	push	r17
    4350:	df 93       	push	r29
    4352:	cf 93       	push	r28
    4354:	0f 92       	push	r0
    4356:	cd b7       	in	r28, 0x3d	; 61
    4358:	de b7       	in	r29, 0x3e	; 62
    435a:	8b 01       	movw	r16, r22
    435c:	7a 01       	movw	r14, r20
  uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
    435e:	29 83       	std	Y+1, r18	; 0x01
    4360:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <ramDyskOtworzPlik>
  if (wynik != 0)
    4364:	29 81       	ldd	r18, Y+1	; 0x01
    4366:	88 23       	and	r24, r24
    4368:	61 f4       	brne	.+24     	; 0x4382 <ramDyskOtworzPlikStdIo+0x3a>
    return wynik;
  
  fdev_setup_stream(stream, putSTD, getSTD, flags);
    436a:	44 eb       	ldi	r20, 0xB4	; 180
    436c:	5e e1       	ldi	r21, 0x1E	; 30
    436e:	f7 01       	movw	r30, r14
    4370:	40 87       	std	Z+8, r20	; 0x08
    4372:	51 87       	std	Z+9, r21	; 0x09
    4374:	45 ef       	ldi	r20, 0xF5	; 245
    4376:	5e e1       	ldi	r21, 0x1E	; 30
    4378:	42 87       	std	Z+10, r20	; 0x0a
    437a:	53 87       	std	Z+11, r21	; 0x0b
    437c:	23 83       	std	Z+3, r18	; 0x03
  fdev_set_udata(stream, fd);
    437e:	04 87       	std	Z+12, r16	; 0x0c
    4380:	15 87       	std	Z+13, r17	; 0x0d
  return 0;
}
    4382:	0f 90       	pop	r0
    4384:	cf 91       	pop	r28
    4386:	df 91       	pop	r29
    4388:	1f 91       	pop	r17
    438a:	0f 91       	pop	r16
    438c:	ff 90       	pop	r15
    438e:	ef 90       	pop	r14
    4390:	08 95       	ret

00004392 <ramDyskZamknijPlikStdIo>:

uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
{
    4392:	0f 93       	push	r16
    4394:	1f 93       	push	r17
    4396:	cf 93       	push	r28
    4398:	df 93       	push	r29
    439a:	8c 01       	movw	r16, r24
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
    439c:	fc 01       	movw	r30, r24
    439e:	c4 85       	ldd	r28, Z+12	; 0x0c
    43a0:	d5 85       	ldd	r29, Z+13	; 0x0d
  ramDyskZamknijPlik(fd);
    43a2:	ce 01       	movw	r24, r28
    43a4:	0e 94 39 1e 	call	0x3c72	; 0x3c72 <ramDyskZamknijPlik>
  fclose(stream);
    43a8:	c8 01       	movw	r24, r16
    43aa:	0e 94 54 57 	call	0xaea8	; 0xaea8 <fclose>
  return fd->wpis->lAktOtw;
    43ae:	ec 81       	ldd	r30, Y+4	; 0x04
    43b0:	fd 81       	ldd	r31, Y+5	; 0x05
}
    43b2:	83 81       	ldd	r24, Z+3	; 0x03
    43b4:	df 91       	pop	r29
    43b6:	cf 91       	pop	r28
    43b8:	1f 91       	pop	r17
    43ba:	0f 91       	pop	r16
    43bc:	08 95       	ret

000043be <cmdlinePrintPrompt>:
    cmdlinePrintPrompt(state);                  // output new prompt
  }
}

void cmdlinePrintPrompt(cmdState_t *state)
{
    43be:	0f 93       	push	r16
    43c0:	1f 93       	push	r17
    43c2:	cf 93       	push	r28
    43c4:	df 93       	push	r29
    43c6:	8c 01       	movw	r16, r24
  const char* ptr;
  // print a new command prompt
  switch (state->cliMode)
    43c8:	dc 01       	movw	r26, r24
    43ca:	90 96       	adiw	r26, 0x20	; 32
    43cc:	ec 91       	ld	r30, X
    43ce:	90 97       	sbiw	r26, 0x20	; 32
    43d0:	e3 30       	cpi	r30, 0x03	; 3
    43d2:	40 f4       	brcc	.+16     	; 0x43e4 <cmdlinePrintPrompt+0x26>
    43d4:	f0 e0       	ldi	r31, 0x00	; 0
    43d6:	ee 0f       	add	r30, r30
    43d8:	ff 1f       	adc	r31, r31
    43da:	e9 52       	subi	r30, 0x29	; 41
    43dc:	fb 4d       	sbci	r31, 0xDB	; 219
    43de:	c0 81       	ld	r28, Z
    43e0:	d1 81       	ldd	r29, Z+1	; 0x01
    43e2:	0e c0       	rjmp	.+28     	; 0x4400 <cmdlinePrintPrompt+0x42>
    43e4:	c9 ef       	ldi	r28, 0xF9	; 249
    43e6:	d7 e0       	ldi	r29, 0x07	; 7
    43e8:	0b c0       	rjmp	.+22     	; 0x4400 <cmdlinePrintPrompt+0x42>
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    43ea:	21 96       	adiw	r28, 0x01	; 1
    43ec:	fc 01       	movw	r30, r24
    43ee:	84 91       	lpm	r24, Z+
    43f0:	d8 01       	movw	r26, r16
    43f2:	5a 96       	adiw	r26, 0x1a	; 26
    43f4:	6d 91       	ld	r22, X+
    43f6:	7c 91       	ld	r23, X
    43f8:	5b 97       	sbiw	r26, 0x1b	; 27
    43fa:	90 e0       	ldi	r25, 0x00	; 0
    43fc:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    4400:	ce 01       	movw	r24, r28
      break;
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    4402:	fe 01       	movw	r30, r28
    4404:	24 91       	lpm	r18, Z+
    4406:	22 23       	and	r18, r18
    4408:	81 f7       	brne	.-32     	; 0x43ea <cmdlinePrintPrompt+0x2c>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
}
    440a:	df 91       	pop	r29
    440c:	cf 91       	pop	r28
    440e:	1f 91       	pop	r17
    4410:	0f 91       	pop	r16
    4412:	08 95       	ret

00004414 <cmdlineRepaint>:
    state->CmdlineInputVT100State = 1;
  }
}

void cmdlineRepaint(cmdState_t *state, char *buf)
{
    4414:	ff 92       	push	r15
    4416:	0f 93       	push	r16
    4418:	1f 93       	push	r17
    441a:	cf 93       	push	r28
    441c:	df 93       	push	r29
    441e:	ec 01       	movw	r28, r24
    4420:	8b 01       	movw	r16, r22
  uint8_t i;

  // carriage return
  fputc(ASCII_CR         , state->myStdInOut);
    4422:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4424:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4426:	8d e0       	ldi	r24, 0x0D	; 13
    4428:	90 e0       	ldi	r25, 0x00	; 0
    442a:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
  // print fresh prompt
  cmdlinePrintPrompt(state);
    442e:	ce 01       	movw	r24, r28
    4430:	0e 94 df 21 	call	0x43be	; 0x43be <cmdlinePrintPrompt>
  // print the new command line buffer
  i = state->CmdlineBufferLength;
    4434:	fd 84       	ldd	r15, Y+13	; 0x0d
  while(i--) 
    4436:	0b c0       	rjmp	.+22     	; 0x444e <cmdlineRepaint+0x3a>
    fputc(*buf++         , state->myStdInOut);
    4438:	f8 01       	movw	r30, r16
    443a:	81 91       	ld	r24, Z+
    443c:	8f 01       	movw	r16, r30
    443e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4440:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4442:	99 27       	eor	r25, r25
    4444:	87 fd       	sbrc	r24, 7
    4446:	90 95       	com	r25
    4448:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    444c:	fa 94       	dec	r15
  fputc(ASCII_CR         , state->myStdInOut);
  // print fresh prompt
  cmdlinePrintPrompt(state);
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    444e:	ff 20       	and	r15, r15
    4450:	99 f7       	brne	.-26     	; 0x4438 <cmdlineRepaint+0x24>
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    4452:	0c 85       	ldd	r16, Y+12	; 0x0c
    4454:	8d 85       	ldd	r24, Y+13	; 0x0d
    4456:	08 1b       	sub	r16, r24
  while (i--)
    4458:	07 c0       	rjmp	.+14     	; 0x4468 <cmdlineRepaint+0x54>
    fputc(' ', state->myStdInOut);
    445a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    445c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    445e:	80 e2       	ldi	r24, 0x20	; 32
    4460:	90 e0       	ldi	r25, 0x00	; 0
    4462:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    4466:	01 50       	subi	r16, 0x01	; 1
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    4468:	00 23       	and	r16, r16
    446a:	b9 f7       	brne	.-18     	; 0x445a <cmdlineRepaint+0x46>
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    446c:	0c 85       	ldd	r16, Y+12	; 0x0c
    446e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4470:	08 1b       	sub	r16, r24
  while (i--)
    4472:	07 c0       	rjmp	.+14     	; 0x4482 <cmdlineRepaint+0x6e>
    fputc(ASCII_BS,  state->myStdInOut);
    4474:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4476:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4478:	88 e0       	ldi	r24, 0x08	; 8
    447a:	90 e0       	ldi	r25, 0x00	; 0
    447c:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    4480:	01 50       	subi	r16, 0x01	; 1
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    4482:	00 23       	and	r16, r16
    4484:	b9 f7       	brne	.-18     	; 0x4474 <cmdlineRepaint+0x60>
    fputc(ASCII_BS,  state->myStdInOut);
}
    4486:	df 91       	pop	r29
    4488:	cf 91       	pop	r28
    448a:	1f 91       	pop	r17
    448c:	0f 91       	pop	r16
    448e:	ff 90       	pop	r15
    4490:	08 95       	ret

00004492 <cmdlineDoHistory>:
  state->historyDepthIdx = 0;
  state->bufferHistoryState = COPIED;
}

void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
{
    4492:	ef 92       	push	r14
    4494:	ff 92       	push	r15
    4496:	cf 93       	push	r28
    4498:	df 93       	push	r29
    449a:	fb 01       	movw	r30, r22
  uint8_t historyReadIdx;
  switch(action)
    449c:	81 30       	cpi	r24, 0x01	; 1
    449e:	f9 f0       	breq	.+62     	; 0x44de <cmdlineDoHistory+0x4c>
    44a0:	81 30       	cpi	r24, 0x01	; 1
    44a2:	20 f0       	brcs	.+8      	; 0x44ac <cmdlineDoHistory+0x1a>
    44a4:	82 30       	cpi	r24, 0x02	; 2
    44a6:	09 f0       	breq	.+2      	; 0x44aa <cmdlineDoHistory+0x18>
    44a8:	55 c0       	rjmp	.+170    	; 0x4554 <cmdlineDoHistory+0xc2>
    44aa:	32 c0       	rjmp	.+100    	; 0x4510 <cmdlineDoHistory+0x7e>
  {
  case CMDLINE_HISTORY_SAVE:
    // copy CmdlineBuffer to history if not null string
    state->CmdlineBufferLength  = 0;
    44ac:	15 86       	std	Z+13, r1	; 0x0d
    state->CmdlineBufferEditPos = 0;     
    44ae:	16 86       	std	Z+14, r1	; 0x0e
    state->bufferHistoryState   = NOT_COPIED;
    44b0:	11 8a       	std	Z+17, r1	; 0x11

    if( strlen(state->CmdlineBuffer) )
    44b2:	a0 81       	ld	r26, Z
    44b4:	b1 81       	ldd	r27, Z+1	; 0x01
    44b6:	8c 91       	ld	r24, X
    44b8:	88 23       	and	r24, r24
    44ba:	09 f4       	brne	.+2      	; 0x44be <cmdlineDoHistory+0x2c>
    44bc:	4b c0       	rjmp	.+150    	; 0x4554 <cmdlineDoHistory+0xc2>
    {
      state->historyWrIdx++;
    44be:	a7 85       	ldd	r26, Z+15	; 0x0f
    44c0:	af 5f       	subi	r26, 0xFF	; 255
      state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
    44c2:	a3 70       	andi	r26, 0x03	; 3
    44c4:	a7 87       	std	Z+15, r26	; 0x0f
      
      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    44c6:	b0 e0       	ldi	r27, 0x00	; 0
    44c8:	12 96       	adiw	r26, 0x02	; 2
    44ca:	aa 0f       	add	r26, r26
    44cc:	bb 1f       	adc	r27, r27
    44ce:	a6 0f       	add	r26, r22
    44d0:	b7 1f       	adc	r27, r23
    44d2:	8d 91       	ld	r24, X+
    44d4:	9c 91       	ld	r25, X
    44d6:	11 97       	sbiw	r26, 0x01	; 1
    44d8:	80 83       	st	Z, r24
    44da:	91 83       	std	Z+1, r25	; 0x01
    44dc:	3b c0       	rjmp	.+118    	; 0x4554 <cmdlineDoHistory+0xc2>
    }
    break;
  case CMDLINE_HISTORY_PREV:
    if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
    44de:	80 89       	ldd	r24, Z+16	; 0x10
    44e0:	83 30       	cpi	r24, 0x03	; 3
    44e2:	c1 f1       	breq	.+112    	; 0x4554 <cmdlineDoHistory+0xc2>
      break;                                               //We are on the end of the history list
    
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
    44e4:	a7 85       	ldd	r26, Z+15	; 0x0f
    44e6:	a1 50       	subi	r26, 0x01	; 1
    44e8:	a8 1b       	sub	r26, r24
    44ea:	a3 70       	andi	r26, 0x03	; 3
    
    if (state->CmdlineHistory[historyReadIdx][0] == 0)
    44ec:	b0 e0       	ldi	r27, 0x00	; 0
    44ee:	12 96       	adiw	r26, 0x02	; 2
    44f0:	aa 0f       	add	r26, r26
    44f2:	bb 1f       	adc	r27, r27
    44f4:	a6 0f       	add	r26, r22
    44f6:	b7 1f       	adc	r27, r23
    44f8:	6d 91       	ld	r22, X+
    44fa:	7c 91       	ld	r23, X
    44fc:	db 01       	movw	r26, r22
    44fe:	9c 91       	ld	r25, X
    4500:	99 23       	and	r25, r25
    4502:	41 f1       	breq	.+80     	; 0x4554 <cmdlineDoHistory+0xc2>
      break;
    
    state->historyDepthIdx++;
    4504:	8f 5f       	subi	r24, 0xFF	; 255
    state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
    4506:	83 70       	andi	r24, 0x03	; 3
    4508:	80 8b       	std	Z+16, r24	; 0x10
    
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    450a:	e6 2e       	mov	r14, r22
    450c:	e7 01       	movw	r28, r14
    450e:	13 c0       	rjmp	.+38     	; 0x4536 <cmdlineDoHistory+0xa4>
    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    
    break;
  case CMDLINE_HISTORY_NEXT:      
    if (state->historyDepthIdx == 0)
    4510:	80 89       	ldd	r24, Z+16	; 0x10
    4512:	88 23       	and	r24, r24
    4514:	f9 f0       	breq	.+62     	; 0x4554 <cmdlineDoHistory+0xc2>
      break;                                               //We are on the begining of the history list

    state->historyDepthIdx --;
    4516:	81 50       	subi	r24, 0x01	; 1
    4518:	80 8b       	std	Z+16, r24	; 0x10
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    451a:	a7 85       	ldd	r26, Z+15	; 0x0f
    451c:	a8 1b       	sub	r26, r24
    451e:	a3 70       	andi	r26, 0x03	; 3
   
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    4520:	b0 e0       	ldi	r27, 0x00	; 0
    4522:	12 96       	adiw	r26, 0x02	; 2
    4524:	aa 0f       	add	r26, r26
    4526:	bb 1f       	adc	r27, r27
    4528:	a6 0f       	add	r26, r22
    452a:	b7 1f       	adc	r27, r23
    452c:	6c 91       	ld	r22, X
    452e:	11 96       	adiw	r26, 0x01	; 1
    4530:	7c 91       	ld	r23, X
    4532:	a6 2f       	mov	r26, r22
    4534:	ed 01       	movw	r28, r26
    4536:	7e 01       	movw	r14, r28
    4538:	f7 2e       	mov	r15, r23
    453a:	d7 01       	movw	r26, r14
    453c:	0d 90       	ld	r0, X+
    453e:	00 20       	and	r0, r0
    4540:	e9 f7       	brne	.-6      	; 0x453c <cmdlineDoHistory+0xaa>
    4542:	11 97       	sbiw	r26, 0x01	; 1
    4544:	ae 19       	sub	r26, r14
    4546:	bf 09       	sbc	r27, r15
    4548:	a5 87       	std	Z+13, r26	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    454a:	a6 87       	std	Z+14, r26	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    454c:	11 8a       	std	Z+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    454e:	cf 01       	movw	r24, r30
    4550:	0e 94 0a 22 	call	0x4414	; 0x4414 <cmdlineRepaint>
    break;
  }
}
    4554:	df 91       	pop	r29
    4556:	cf 91       	pop	r28
    4558:	ff 90       	pop	r15
    455a:	ef 90       	pop	r14
    455c:	08 95       	ret

0000455e <cmdHistoryCopy>:
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
}

void cmdHistoryCopy(cmdState_t *state)
{
    455e:	1f 93       	push	r17
    4560:	cf 93       	push	r28
    4562:	df 93       	push	r29
    4564:	ec 01       	movw	r28, r24
  if (state->historyDepthIdx != 0)
    4566:	88 89       	ldd	r24, Y+16	; 0x10
    4568:	88 23       	and	r24, r24
    456a:	c1 f0       	breq	.+48     	; 0x459c <cmdHistoryCopy+0x3e>
  {
    uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    456c:	1f 85       	ldd	r17, Y+15	; 0x0f
    456e:	18 1b       	sub	r17, r24
    4570:	13 70       	andi	r17, 0x03	; 3
    memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
    4572:	4c 85       	ldd	r20, Y+12	; 0x0c
    4574:	88 81       	ld	r24, Y
    4576:	99 81       	ldd	r25, Y+1	; 0x01
    4578:	60 e0       	ldi	r22, 0x00	; 0
    457a:	70 e0       	ldi	r23, 0x00	; 0
    457c:	50 e0       	ldi	r21, 0x00	; 0
    457e:	0e 94 1e 57 	call	0xae3c	; 0xae3c <memset>
    strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
    4582:	e1 2f       	mov	r30, r17
    4584:	f0 e0       	ldi	r31, 0x00	; 0
    4586:	32 96       	adiw	r30, 0x02	; 2
    4588:	ee 0f       	add	r30, r30
    458a:	ff 1f       	adc	r31, r31
    458c:	ec 0f       	add	r30, r28
    458e:	fd 1f       	adc	r31, r29
    4590:	60 81       	ld	r22, Z
    4592:	71 81       	ldd	r23, Z+1	; 0x01
    4594:	88 81       	ld	r24, Y
    4596:	99 81       	ldd	r25, Y+1	; 0x01
    4598:	0e 94 30 57 	call	0xae60	; 0xae60 <strcpy>
  }
  
  state->historyDepthIdx = 0;
    459c:	18 8a       	std	Y+16, r1	; 0x10
  state->bufferHistoryState = COPIED;
    459e:	81 e0       	ldi	r24, 0x01	; 1
    45a0:	89 8b       	std	Y+17, r24	; 0x11
}
    45a2:	df 91       	pop	r29
    45a4:	cf 91       	pop	r28
    45a6:	1f 91       	pop	r17
    45a8:	08 95       	ret

000045aa <cmdStateConfigure>:
static void cmdHistoryCopy            (cmdState_t *state);
static void cmdHistoryMove            (cmdState_t *state);


void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, const command_t *commands, enum cliModeState mode)
{
    45aa:	6f 92       	push	r6
    45ac:	7f 92       	push	r7
    45ae:	8f 92       	push	r8
    45b0:	9f 92       	push	r9
    45b2:	af 92       	push	r10
    45b4:	bf 92       	push	r11
    45b6:	cf 92       	push	r12
    45b8:	df 92       	push	r13
    45ba:	ef 92       	push	r14
    45bc:	0f 93       	push	r16
    45be:	1f 93       	push	r17
    45c0:	cf 93       	push	r28
    45c2:	df 93       	push	r29
    45c4:	ec 01       	movw	r28, r24
    45c6:	6b 01       	movw	r12, r22
    45c8:	5a 01       	movw	r10, r20
    45ca:	49 01       	movw	r8, r18
  memset(state, 0, sizeof(cmdState_t));
    45cc:	83 e2       	ldi	r24, 0x23	; 35
    45ce:	de 01       	movw	r26, r28
    45d0:	1d 92       	st	X+, r1
    45d2:	8a 95       	dec	r24
    45d4:	e9 f7       	brne	.-6      	; 0x45d0 <cmdStateConfigure+0x26>
  memset(buffPtr, 0, bufferTotalSize);
    45d6:	cb 01       	movw	r24, r22
    45d8:	60 e0       	ldi	r22, 0x00	; 0
    45da:	70 e0       	ldi	r23, 0x00	; 0
    45dc:	0e 94 1e 57 	call	0xae3c	; 0xae3c <memset>
    
  state->CmdlineBuffer = buffPtr;
    45e0:	c8 82       	st	Y, r12
    45e2:	d9 82       	std	Y+1, r13	; 0x01
  state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
    45e4:	b6 94       	lsr	r11
    45e6:	a7 94       	ror	r10
    45e8:	b6 94       	lsr	r11
    45ea:	a7 94       	ror	r10
    45ec:	ac 86       	std	Y+12, r10	; 0x0c

  state->cliMode = mode;
    45ee:	e8 a2       	std	Y+32, r14	; 0x20
  state->cmdList = commands;
    45f0:	09 a3       	std	Y+33, r16	; 0x21
    45f2:	1a a3       	std	Y+34, r17	; 0x22
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    45f4:	cc 82       	std	Y+4, r12	; 0x04
    45f6:	dd 82       	std	Y+5, r13	; 0x05
    tmpPtr += state->bufferMaxSize;
    45f8:	bb 24       	eor	r11, r11
    45fa:	ca 0c       	add	r12, r10
    45fc:	db 1c       	adc	r13, r11
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    45fe:	ce 82       	std	Y+6, r12	; 0x06
    4600:	df 82       	std	Y+7, r13	; 0x07
    tmpPtr += state->bufferMaxSize;
    4602:	ca 0c       	add	r12, r10
    4604:	db 1c       	adc	r13, r11
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    4606:	c8 86       	std	Y+8, r12	; 0x08
    4608:	d9 86       	std	Y+9, r13	; 0x09
    tmpPtr += state->bufferMaxSize;
    460a:	ac 0c       	add	r10, r12
    460c:	bd 1c       	adc	r11, r13
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    460e:	aa 86       	std	Y+10, r10	; 0x0a
    4610:	bb 86       	std	Y+11, r11	; 0x0b
    tmpPtr += state->bufferMaxSize;
  }
  state->myStdInOut = stream;
    4612:	8a 8e       	std	Y+26, r8	; 0x1a
    4614:	9b 8e       	std	Y+27, r9	; 0x1b
}
    4616:	df 91       	pop	r29
    4618:	cf 91       	pop	r28
    461a:	1f 91       	pop	r17
    461c:	0f 91       	pop	r16
    461e:	ef 90       	pop	r14
    4620:	df 90       	pop	r13
    4622:	cf 90       	pop	r12
    4624:	bf 90       	pop	r11
    4626:	af 90       	pop	r10
    4628:	9f 90       	pop	r9
    462a:	8f 90       	pop	r8
    462c:	7f 90       	pop	r7
    462e:	6f 90       	pop	r6
    4630:	08 95       	ret

00004632 <cmdlineInputFunc>:
  // initialize executing function
  state->CmdlineExecFunction = 0;
}

void cmdlineInputFunc(char c, cmdState_t *state)
{
    4632:	8f 92       	push	r8
    4634:	9f 92       	push	r9
    4636:	af 92       	push	r10
    4638:	bf 92       	push	r11
    463a:	cf 92       	push	r12
    463c:	df 92       	push	r13
    463e:	ef 92       	push	r14
    4640:	ff 92       	push	r15
    4642:	0f 93       	push	r16
    4644:	1f 93       	push	r17
    4646:	df 93       	push	r29
    4648:	cf 93       	push	r28
    464a:	00 d0       	rcall	.+0      	; 0x464c <cmdlineInputFunc+0x1a>
    464c:	00 d0       	rcall	.+0      	; 0x464e <cmdlineInputFunc+0x1c>
    464e:	cd b7       	in	r28, 0x3d	; 61
    4650:	de b7       	in	r29, 0x3e	; 62
    4652:	08 2f       	mov	r16, r24
    4654:	7b 01       	movw	r14, r22
  uint8_t i;
  // process the received character

  // VT100 handling
  // are we processing a VT100 command?
  if(state->CmdlineInputVT100State == 2)
    4656:	db 01       	movw	r26, r22
    4658:	52 96       	adiw	r26, 0x12	; 18
    465a:	8c 91       	ld	r24, X
    465c:	52 97       	sbiw	r26, 0x12	; 18
    465e:	82 30       	cpi	r24, 0x02	; 2
    4660:	09 f0       	breq	.+2      	; 0x4664 <cmdlineInputFunc+0x32>
    4662:	5e c0       	rjmp	.+188    	; 0x4720 <cmdlineInputFunc+0xee>
  {
    // we have already received ESC and [
    // now process the vt100 codeCmdlineExcBuffer
    switch(c)
    4664:	02 34       	cpi	r16, 0x42	; 66
    4666:	71 f0       	breq	.+28     	; 0x4684 <cmdlineInputFunc+0x52>
    4668:	03 34       	cpi	r16, 0x43	; 67
    466a:	24 f4       	brge	.+8      	; 0x4674 <cmdlineInputFunc+0x42>
    466c:	01 34       	cpi	r16, 0x41	; 65
    466e:	09 f0       	breq	.+2      	; 0x4672 <cmdlineInputFunc+0x40>
    4670:	54 c0       	rjmp	.+168    	; 0x471a <cmdlineInputFunc+0xe8>
    4672:	06 c0       	rjmp	.+12     	; 0x4680 <cmdlineInputFunc+0x4e>
    4674:	03 34       	cpi	r16, 0x43	; 67
    4676:	59 f0       	breq	.+22     	; 0x468e <cmdlineInputFunc+0x5c>
    4678:	04 34       	cpi	r16, 0x44	; 68
    467a:	09 f0       	breq	.+2      	; 0x467e <cmdlineInputFunc+0x4c>
    467c:	4e c0       	rjmp	.+156    	; 0x471a <cmdlineInputFunc+0xe8>
    467e:	31 c0       	rjmp	.+98     	; 0x46e2 <cmdlineInputFunc+0xb0>
    {
    case VT100_ARROWUP:
      cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
    4680:	81 e0       	ldi	r24, 0x01	; 1
    4682:	01 c0       	rjmp	.+2      	; 0x4686 <cmdlineInputFunc+0x54>
      break;
    case VT100_ARROWDOWN:
      cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
    4684:	82 e0       	ldi	r24, 0x02	; 2
    4686:	b7 01       	movw	r22, r14
    4688:	0e 94 49 22 	call	0x4492	; 0x4492 <cmdlineDoHistory>
      break;
    468c:	46 c0       	rjmp	.+140    	; 0x471a <cmdlineInputFunc+0xe8>
    case VT100_ARROWRIGHT:
      if (state->bufferHistoryState == NOT_COPIED)
    468e:	fb 01       	movw	r30, r22
    4690:	81 89       	ldd	r24, Z+17	; 0x11
    4692:	88 23       	and	r24, r24
    4694:	19 f4       	brne	.+6      	; 0x469c <cmdlineInputFunc+0x6a>
        cmdHistoryCopy(state);
    4696:	cb 01       	movw	r24, r22
    4698:	0e 94 af 22 	call	0x455e	; 0x455e <cmdHistoryCopy>
      // if the edit position less than current string length
      if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
    469c:	d7 01       	movw	r26, r14
    469e:	1e 96       	adiw	r26, 0x0e	; 14
    46a0:	8c 91       	ld	r24, X
    46a2:	1e 97       	sbiw	r26, 0x0e	; 14
    46a4:	1d 96       	adiw	r26, 0x0d	; 13
    46a6:	9c 91       	ld	r25, X
    46a8:	1d 97       	sbiw	r26, 0x0d	; 13
    46aa:	5a 96       	adiw	r26, 0x1a	; 26
    46ac:	6d 91       	ld	r22, X+
    46ae:	7c 91       	ld	r23, X
    46b0:	5b 97       	sbiw	r26, 0x1b	; 27
    46b2:	89 17       	cp	r24, r25
    46b4:	70 f5       	brcc	.+92     	; 0x4712 <cmdlineInputFunc+0xe0>
      {
        // increment the edit position
        state->CmdlineBufferEditPos++;
    46b6:	8f 5f       	subi	r24, 0xFF	; 255
    46b8:	1e 96       	adiw	r26, 0x0e	; 14
    46ba:	8c 93       	st	X, r24
        // move cursor forward one space (no erase)
        fputc(ASCII_ESC        , state->myStdInOut);
    46bc:	8b e1       	ldi	r24, 0x1B	; 27
    46be:	90 e0       	ldi	r25, 0x00	; 0
    46c0:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        fputc('['              , state->myStdInOut);
    46c4:	f7 01       	movw	r30, r14
    46c6:	62 8d       	ldd	r22, Z+26	; 0x1a
    46c8:	73 8d       	ldd	r23, Z+27	; 0x1b
    46ca:	8b e5       	ldi	r24, 0x5B	; 91
    46cc:	90 e0       	ldi	r25, 0x00	; 0
    46ce:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        fputc(VT100_ARROWRIGHT , state->myStdInOut);
    46d2:	d7 01       	movw	r26, r14
    46d4:	5a 96       	adiw	r26, 0x1a	; 26
    46d6:	6d 91       	ld	r22, X+
    46d8:	7c 91       	ld	r23, X
    46da:	5b 97       	sbiw	r26, 0x1b	; 27
    46dc:	83 e4       	ldi	r24, 0x43	; 67
    46de:	90 e0       	ldi	r25, 0x00	; 0
    46e0:	1a c0       	rjmp	.+52     	; 0x4716 <cmdlineInputFunc+0xe4>
        fputc(ASCII_BEL        , state->myStdInOut);
      }
      break;
    case VT100_ARROWLEFT:
      // if the edit position is non-zero
      if (state->bufferHistoryState == NOT_COPIED)
    46e2:	fb 01       	movw	r30, r22
    46e4:	81 89       	ldd	r24, Z+17	; 0x11
    46e6:	88 23       	and	r24, r24
    46e8:	19 f4       	brne	.+6      	; 0x46f0 <cmdlineInputFunc+0xbe>
        cmdHistoryCopy(state);
    46ea:	cb 01       	movw	r24, r22
    46ec:	0e 94 af 22 	call	0x455e	; 0x455e <cmdHistoryCopy>
      
      if(state->CmdlineBufferEditPos)
    46f0:	d7 01       	movw	r26, r14
    46f2:	1e 96       	adiw	r26, 0x0e	; 14
    46f4:	8c 91       	ld	r24, X
    46f6:	1e 97       	sbiw	r26, 0x0e	; 14
    46f8:	5a 96       	adiw	r26, 0x1a	; 26
    46fa:	6d 91       	ld	r22, X+
    46fc:	7c 91       	ld	r23, X
    46fe:	5b 97       	sbiw	r26, 0x1b	; 27
    4700:	88 23       	and	r24, r24
    4702:	39 f0       	breq	.+14     	; 0x4712 <cmdlineInputFunc+0xe0>
      {
        // decrement the edit position
        state->CmdlineBufferEditPos--;
    4704:	81 50       	subi	r24, 0x01	; 1
    4706:	1e 96       	adiw	r26, 0x0e	; 14
    4708:	8c 93       	st	X, r24
    470a:	1e 97       	sbiw	r26, 0x0e	; 14
        // move cursor back one space (no erase)
        fputc(ASCII_BS         , state->myStdInOut);
    470c:	88 e0       	ldi	r24, 0x08	; 8
    470e:	90 e0       	ldi	r25, 0x00	; 0
    4710:	02 c0       	rjmp	.+4      	; 0x4716 <cmdlineInputFunc+0xe4>
      }
      else
      {
        // else, ring the bell
        fputc(ASCII_BEL        , state->myStdInOut);
    4712:	87 e0       	ldi	r24, 0x07	; 7
    4714:	90 e0       	ldi	r25, 0x00	; 0
    4716:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
      break;
    default:
      break;
    }
    // done, reset state
    state->CmdlineInputVT100State = 0;
    471a:	f7 01       	movw	r30, r14
    471c:	12 8a       	std	Z+18, r1	; 0x12
    return;
    471e:	27 c2       	rjmp	.+1102   	; 0x4b6e <cmdlineInputFunc+0x53c>
  }
  else if(state->CmdlineInputVT100State == 1)
    4720:	81 30       	cpi	r24, 0x01	; 1
    4722:	39 f4       	brne	.+14     	; 0x4732 <cmdlineInputFunc+0x100>
  {
    // we last received [ESC]
    if(c == '[')
    4724:	0b 35       	cpi	r16, 0x5B	; 91
    4726:	11 f4       	brne	.+4      	; 0x472c <cmdlineInputFunc+0xfa>
    {
      state->CmdlineInputVT100State = 2;
    4728:	82 e0       	ldi	r24, 0x02	; 2
    472a:	1d c2       	rjmp	.+1082   	; 0x4b66 <cmdlineInputFunc+0x534>
      return;
    }
    else
      state->CmdlineInputVT100State = 0;
    472c:	fb 01       	movw	r30, r22
    472e:	12 8a       	std	Z+18, r1	; 0x12
    4730:	04 c0       	rjmp	.+8      	; 0x473a <cmdlineInputFunc+0x108>
  }
  else
  {
    // anything else, reset state
    state->CmdlineInputVT100State = 0;
    4732:	db 01       	movw	r26, r22
    4734:	52 96       	adiw	r26, 0x12	; 18
    4736:	1c 92       	st	X, r1
    4738:	52 97       	sbiw	r26, 0x12	; 18
  }

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
    473a:	f7 01       	movw	r30, r14
    473c:	85 85       	ldd	r24, Z+13	; 0x0d
    473e:	94 85       	ldd	r25, Z+12	; 0x0c
    4740:	89 17       	cp	r24, r25
    4742:	91 f4       	brne	.+36     	; 0x4768 <cmdlineInputFunc+0x136>
  {
    state->CmdlineBufferLength--;
    4744:	81 50       	subi	r24, 0x01	; 1
    4746:	85 87       	std	Z+13, r24	; 0x0d
    for (i=1; i < state->bufferMaxSize; i++)
    4748:	81 e0       	ldi	r24, 0x01	; 1
    474a:	0a c0       	rjmp	.+20     	; 0x4760 <cmdlineInputFunc+0x12e>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    474c:	d7 01       	movw	r26, r14
    474e:	ed 91       	ld	r30, X+
    4750:	fc 91       	ld	r31, X
    4752:	e8 0f       	add	r30, r24
    4754:	f1 1d       	adc	r31, r1
    4756:	df 01       	movw	r26, r30
    4758:	11 97       	sbiw	r26, 0x01	; 1
    475a:	90 81       	ld	r25, Z
    475c:	9c 93       	st	X, r25
  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    for (i=1; i < state->bufferMaxSize; i++)
    475e:	8f 5f       	subi	r24, 0xFF	; 255
    4760:	f7 01       	movw	r30, r14
    4762:	94 85       	ldd	r25, Z+12	; 0x0c
    4764:	89 17       	cp	r24, r25
    4766:	90 f3       	brcs	.-28     	; 0x474c <cmdlineInputFunc+0x11a>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    }
  }
  
  if( (c >= 0x20) && (c < 0x7F) )
    4768:	80 2f       	mov	r24, r16
    476a:	80 52       	subi	r24, 0x20	; 32
    476c:	8f 35       	cpi	r24, 0x5F	; 95
    476e:	08 f0       	brcs	.+2      	; 0x4772 <cmdlineInputFunc+0x140>
    4770:	5b c0       	rjmp	.+182    	; 0x4828 <cmdlineInputFunc+0x1f6>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    4772:	d7 01       	movw	r26, r14
    4774:	51 96       	adiw	r26, 0x11	; 17
    4776:	8c 91       	ld	r24, X
    4778:	51 97       	sbiw	r26, 0x11	; 17
    477a:	88 23       	and	r24, r24
    477c:	19 f4       	brne	.+6      	; 0x4784 <cmdlineInputFunc+0x152>
      cmdHistoryCopy(state);
    477e:	c7 01       	movw	r24, r14
    4780:	0e 94 af 22 	call	0x455e	; 0x455e <cmdHistoryCopy>
    // character is printable
    // is this a simple append
    if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    4784:	f7 01       	movw	r30, r14
    4786:	85 85       	ldd	r24, Z+13	; 0x0d
    4788:	96 85       	ldd	r25, Z+14	; 0x0e
    478a:	98 17       	cp	r25, r24
    478c:	f1 f4       	brne	.+60     	; 0x47ca <cmdlineInputFunc+0x198>
    {
      // echo character to the output
      fputc(c                , state->myStdInOut);
    478e:	62 8d       	ldd	r22, Z+26	; 0x1a
    4790:	73 8d       	ldd	r23, Z+27	; 0x1b
    4792:	80 2f       	mov	r24, r16
    4794:	99 27       	eor	r25, r25
    4796:	87 fd       	sbrc	r24, 7
    4798:	90 95       	com	r25
    479a:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
      // add it to the command line buffer
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    479e:	d7 01       	movw	r26, r14
    47a0:	1e 96       	adiw	r26, 0x0e	; 14
    47a2:	8c 91       	ld	r24, X
    47a4:	1e 97       	sbiw	r26, 0x0e	; 14
    47a6:	ed 91       	ld	r30, X+
    47a8:	fc 91       	ld	r31, X
    47aa:	11 97       	sbiw	r26, 0x01	; 1
    47ac:	e8 0f       	add	r30, r24
    47ae:	f1 1d       	adc	r31, r1
    47b0:	00 83       	st	Z, r16
    47b2:	8f 5f       	subi	r24, 0xFF	; 255
    47b4:	1e 96       	adiw	r26, 0x0e	; 14
    47b6:	8c 93       	st	X, r24
    47b8:	1e 97       	sbiw	r26, 0x0e	; 14
      // update buffer length
      state->CmdlineBufferLength++;
    47ba:	1d 96       	adiw	r26, 0x0d	; 13
    47bc:	8c 91       	ld	r24, X
    47be:	1d 97       	sbiw	r26, 0x0d	; 13
    47c0:	8f 5f       	subi	r24, 0xFF	; 255
    47c2:	1d 96       	adiw	r26, 0x0d	; 13
    47c4:	8c 93       	st	X, r24
    47c6:	1d 97       	sbiw	r26, 0x0d	; 13
    47c8:	d2 c1       	rjmp	.+932    	; 0x4b6e <cmdlineInputFunc+0x53c>
    else
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
    47ca:	8f 5f       	subi	r24, 0xFF	; 255
    47cc:	f7 01       	movw	r30, r14
    47ce:	85 87       	std	Z+13, r24	; 0x0d
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    47d0:	08 c0       	rjmp	.+16     	; 0x47e2 <cmdlineInputFunc+0x1b0>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
    47d2:	68 0f       	add	r22, r24
    47d4:	71 1d       	adc	r23, r1
    47d6:	fb 01       	movw	r30, r22
    47d8:	31 97       	sbiw	r30, 0x01	; 1
    47da:	90 81       	ld	r25, Z
    47dc:	db 01       	movw	r26, r22
    47de:	9c 93       	st	X, r25
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    47e0:	81 50       	subi	r24, 0x01	; 1
    47e2:	f7 01       	movw	r30, r14
    47e4:	96 85       	ldd	r25, Z+14	; 0x0e
    47e6:	60 81       	ld	r22, Z
    47e8:	71 81       	ldd	r23, Z+1	; 0x01
    47ea:	98 17       	cp	r25, r24
    47ec:	90 f3       	brcs	.-28     	; 0x47d2 <cmdlineInputFunc+0x1a0>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    47ee:	69 0f       	add	r22, r25
    47f0:	71 1d       	adc	r23, r1
    47f2:	db 01       	movw	r26, r22
    47f4:	0c 93       	st	X, r16
    47f6:	9f 5f       	subi	r25, 0xFF	; 255
    47f8:	96 87       	std	Z+14, r25	; 0x0e
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
    47fa:	60 81       	ld	r22, Z
    47fc:	71 81       	ldd	r23, Z+1	; 0x01
    47fe:	c7 01       	movw	r24, r14
    4800:	0e 94 0a 22 	call	0x4414	; 0x4414 <cmdlineRepaint>
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4804:	f7 01       	movw	r30, r14
    4806:	06 85       	ldd	r16, Z+14	; 0x0e
    4808:	0a c0       	rjmp	.+20     	; 0x481e <cmdlineInputFunc+0x1ec>
        fputc(ASCII_BS         , state->myStdInOut);
    480a:	d7 01       	movw	r26, r14
    480c:	5a 96       	adiw	r26, 0x1a	; 26
    480e:	6d 91       	ld	r22, X+
    4810:	7c 91       	ld	r23, X
    4812:	5b 97       	sbiw	r26, 0x1b	; 27
    4814:	88 e0       	ldi	r24, 0x08	; 8
    4816:	90 e0       	ldi	r25, 0x00	; 0
    4818:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    481c:	0f 5f       	subi	r16, 0xFF	; 255
    481e:	f7 01       	movw	r30, r14
    4820:	85 85       	ldd	r24, Z+13	; 0x0d
    4822:	08 17       	cp	r16, r24
    4824:	90 f3       	brcs	.-28     	; 0x480a <cmdlineInputFunc+0x1d8>
    4826:	a3 c1       	rjmp	.+838    	; 0x4b6e <cmdlineInputFunc+0x53c>
        fputc(ASCII_BS         , state->myStdInOut);
    }
  }
  // handle special characters
  else if(c == ASCII_CR)
    4828:	0d 30       	cpi	r16, 0x0D	; 13
    482a:	09 f0       	breq	.+2      	; 0x482e <cmdlineInputFunc+0x1fc>
    482c:	27 c1       	rjmp	.+590    	; 0x4a7c <cmdlineInputFunc+0x44a>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    482e:	d7 01       	movw	r26, r14
    4830:	51 96       	adiw	r26, 0x11	; 17
    4832:	8c 91       	ld	r24, X
    4834:	51 97       	sbiw	r26, 0x11	; 17
    4836:	88 23       	and	r24, r24
    4838:	09 f0       	breq	.+2      	; 0x483c <cmdlineInputFunc+0x20a>
    483a:	49 c0       	rjmp	.+146    	; 0x48ce <cmdlineInputFunc+0x29c>
  state->bufferHistoryState = COPIED;
}

void cmdHistoryMove(cmdState_t *state)
{
  uint8_t i=state->historyDepthIdx;
    483c:	50 96       	adiw	r26, 0x10	; 16
    483e:	4c 91       	ld	r20, X
    4840:	50 97       	sbiw	r26, 0x10	; 16

  if (state->historyDepthIdx != 0)
    4842:	44 23       	and	r20, r20
    4844:	79 f1       	breq	.+94     	; 0x48a4 <cmdlineInputFunc+0x272>
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    4846:	1f 96       	adiw	r26, 0x0f	; 15
    4848:	8c 91       	ld	r24, X
    484a:	1f 97       	sbiw	r26, 0x0f	; 15
    484c:	90 e0       	ldi	r25, 0x00	; 0
    484e:	fc 01       	movw	r30, r24
    4850:	e4 1b       	sub	r30, r20
    4852:	f1 09       	sbc	r31, r1
    4854:	e3 70       	andi	r30, 0x03	; 3
    4856:	f0 70       	andi	r31, 0x00	; 0
    4858:	32 96       	adiw	r30, 0x02	; 2
    485a:	ee 0f       	add	r30, r30
    485c:	ff 1f       	adc	r31, r31
    485e:	ee 0d       	add	r30, r14
    4860:	ff 1d       	adc	r31, r15
    4862:	20 81       	ld	r18, Z
    4864:	31 81       	ldd	r19, Z+1	; 0x01
    4866:	2d 93       	st	X+, r18
    4868:	3c 93       	st	X, r19
    486a:	11 97       	sbiw	r26, 0x01	; 1
    486c:	19 c0       	rjmp	.+50     	; 0x48a0 <cmdlineInputFunc+0x26e>
    for ( ; i<CMD_STATE_HISTORY; i++)
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    486e:	fc 01       	movw	r30, r24
    4870:	e4 1b       	sub	r30, r20
    4872:	f1 09       	sbc	r31, r1
    4874:	df 01       	movw	r26, r30
    4876:	a3 70       	andi	r26, 0x03	; 3
    4878:	b0 70       	andi	r27, 0x00	; 0
    487a:	12 96       	adiw	r26, 0x02	; 2
    487c:	aa 0f       	add	r26, r26
    487e:	bb 1f       	adc	r27, r27
    4880:	ae 0d       	add	r26, r14
    4882:	bf 1d       	adc	r27, r15
    4884:	31 97       	sbiw	r30, 0x01	; 1
    4886:	e3 70       	andi	r30, 0x03	; 3
    4888:	f0 70       	andi	r31, 0x00	; 0
    488a:	32 96       	adiw	r30, 0x02	; 2
    488c:	ee 0f       	add	r30, r30
    488e:	ff 1f       	adc	r31, r31
    4890:	ee 0d       	add	r30, r14
    4892:	ff 1d       	adc	r31, r15
    4894:	20 81       	ld	r18, Z
    4896:	31 81       	ldd	r19, Z+1	; 0x01
    4898:	2d 93       	st	X+, r18
    489a:	3c 93       	st	X, r19
    489c:	11 97       	sbiw	r26, 0x01	; 1
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    for ( ; i<CMD_STATE_HISTORY; i++)
    489e:	4f 5f       	subi	r20, 0xFF	; 255
    48a0:	44 30       	cpi	r20, 0x04	; 4
    48a2:	28 f3       	brcs	.-54     	; 0x486e <cmdlineInputFunc+0x23c>
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    }
  }
  state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
    48a4:	d7 01       	movw	r26, r14
    48a6:	1f 96       	adiw	r26, 0x0f	; 15
    48a8:	ec 91       	ld	r30, X
    48aa:	1f 97       	sbiw	r26, 0x0f	; 15
    48ac:	f0 e0       	ldi	r31, 0x00	; 0
    48ae:	32 96       	adiw	r30, 0x02	; 2
    48b0:	ee 0f       	add	r30, r30
    48b2:	ff 1f       	adc	r31, r31
    48b4:	ee 0d       	add	r30, r14
    48b6:	ff 1d       	adc	r31, r15
    48b8:	8d 91       	ld	r24, X+
    48ba:	9c 91       	ld	r25, X
    48bc:	11 97       	sbiw	r26, 0x01	; 1
    48be:	80 83       	st	Z, r24
    48c0:	91 83       	std	Z+1, r25	; 0x01

  state->historyDepthIdx = 0;
    48c2:	50 96       	adiw	r26, 0x10	; 16
    48c4:	1c 92       	st	X, r1
    48c6:	50 97       	sbiw	r26, 0x10	; 16
  state->bufferHistoryState = COPIED;
    48c8:	81 e0       	ldi	r24, 0x01	; 1
    48ca:	51 96       	adiw	r26, 0x11	; 17
    48cc:	8c 93       	st	X, r24
    if (state->bufferHistoryState == NOT_COPIED)
      cmdHistoryMove(state);
    
    // user pressed [ENTER]
    // echo CR and LF to terminal
    fputc(ASCII_CR         , state->myStdInOut);
    48ce:	f7 01       	movw	r30, r14
    48d0:	62 8d       	ldd	r22, Z+26	; 0x1a
    48d2:	73 8d       	ldd	r23, Z+27	; 0x1b
    48d4:	8d e0       	ldi	r24, 0x0D	; 13
    48d6:	90 e0       	ldi	r25, 0x00	; 0
    48d8:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    fputc(ASCII_LF         , state->myStdInOut);
    48dc:	d7 01       	movw	r26, r14
    48de:	5a 96       	adiw	r26, 0x1a	; 26
    48e0:	6d 91       	ld	r22, X+
    48e2:	7c 91       	ld	r23, X
    48e4:	5b 97       	sbiw	r26, 0x1b	; 27
    48e6:	8a e0       	ldi	r24, 0x0A	; 10
    48e8:	90 e0       	ldi	r25, 0x00	; 0
    48ea:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    // add null termination to command
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    48ee:	f7 01       	movw	r30, r14
    48f0:	85 85       	ldd	r24, Z+13	; 0x0d
    48f2:	01 90       	ld	r0, Z+
    48f4:	f0 81       	ld	r31, Z
    48f6:	e0 2d       	mov	r30, r0
    48f8:	e8 0f       	add	r30, r24
    48fa:	f1 1d       	adc	r31, r1
    48fc:	10 82       	st	Z, r1
    48fe:	8f 5f       	subi	r24, 0xFF	; 255
    4900:	d7 01       	movw	r26, r14
    4902:	1d 96       	adiw	r26, 0x0d	; 13
    4904:	8c 93       	st	X, r24
    4906:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos++;
    4908:	1e 96       	adiw	r26, 0x0e	; 14
    490a:	8c 91       	ld	r24, X
    490c:	1e 97       	sbiw	r26, 0x0e	; 14
    490e:	8f 5f       	subi	r24, 0xFF	; 255
    4910:	1e 96       	adiw	r26, 0x0e	; 14
    4912:	8c 93       	st	X, r24
    4914:	1e 97       	sbiw	r26, 0x0e	; 14
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments
    4916:	8d 91       	ld	r24, X+
    4918:	9c 91       	ld	r25, X
    491a:	11 97       	sbiw	r26, 0x01	; 1
    491c:	12 96       	adiw	r26, 0x02	; 2
    491e:	8d 93       	st	X+, r24
    4920:	9c 93       	st	X, r25
    4922:	13 97       	sbiw	r26, 0x03	; 3
  }
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
    4924:	20 e0       	ldi	r18, 0x00	; 0
    4926:	01 c0       	rjmp	.+2      	; 0x492a <cmdlineInputFunc+0x2f8>
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length
    4928:	2f 5f       	subi	r18, 0xFF	; 255
void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    492a:	a2 2e       	mov	r10, r18
    492c:	bb 24       	eor	r11, r11
    492e:	fc 01       	movw	r30, r24
    4930:	ea 0d       	add	r30, r10
    4932:	fb 1d       	adc	r31, r11
    4934:	30 81       	ld	r19, Z
    4936:	30 32       	cpi	r19, 0x20	; 32
    4938:	11 f0       	breq	.+4      	; 0x493e <cmdlineInputFunc+0x30c>
    493a:	33 23       	and	r19, r19
    493c:	a9 f7       	brne	.-22     	; 0x4928 <cmdlineInputFunc+0x2f6>
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length

  if(!i)                                                              // command was null or empty
    493e:	22 23       	and	r18, r18
    4940:	09 f4       	brne	.+2      	; 0x4944 <cmdlineInputFunc+0x312>
    4942:	91 c0       	rjmp	.+290    	; 0x4a66 <cmdlineInputFunc+0x434>
  {
    cmdlinePrintPrompt(state);                                        // output a new prompt
    return;
  }

  const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The list depends of the cli mode
    4944:	f7 01       	movw	r30, r14
    4946:	c1 a0       	ldd	r12, Z+33	; 0x21
    4948:	d2 a0       	ldd	r13, Z+34	; 0x22
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.
    494a:	8e 01       	movw	r16, r28
    494c:	0f 5f       	subi	r16, 0xFF	; 255
    494e:	1f 4f       	sbci	r17, 0xFF	; 255
    4950:	c8 01       	movw	r24, r16
    4952:	b6 01       	movw	r22, r12
    4954:	46 e0       	ldi	r20, 0x06	; 6
    4956:	50 e0       	ldi	r21, 0x00	; 0
    4958:	0e 94 fe 56 	call	0xadfc	; 0xadfc <memcpy_P>
      state->command_help_str    = tmp.commandHelpStr;
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
      return;
    }
    tmpPtr++;                                                         // Next command
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    495c:	90 2e       	mov	r9, r16
    495e:	81 2e       	mov	r8, r17
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.

  do                                                                  // search command list for match with entered command
  {
    if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command matched a command in the list
    4960:	09 81       	ldd	r16, Y+1	; 0x01
    4962:	1a 81       	ldd	r17, Y+2	; 0x02
    4964:	d7 01       	movw	r26, r14
    4966:	12 96       	adiw	r26, 0x02	; 2
    4968:	8d 91       	ld	r24, X+
    496a:	9c 91       	ld	r25, X
    496c:	13 97       	sbiw	r26, 0x03	; 3
    496e:	b8 01       	movw	r22, r16
    4970:	a5 01       	movw	r20, r10
    4972:	0e 94 07 57 	call	0xae0e	; 0xae0e <strncmp_P>
    4976:	00 97       	sbiw	r24, 0x00	; 0
    4978:	81 f4       	brne	.+32     	; 0x499a <cmdlineInputFunc+0x368>
    {                                                                 // 
      state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
    497a:	8d 81       	ldd	r24, Y+5	; 0x05
    497c:	9e 81       	ldd	r25, Y+6	; 0x06
    497e:	f7 01       	movw	r30, r14
    4980:	87 8b       	std	Z+23, r24	; 0x17
    4982:	90 8f       	std	Z+24, r25	; 0x18
      state->command_str         = tmp.commandStr;
    4984:	03 8b       	std	Z+19, r16	; 0x13
    4986:	14 8b       	std	Z+20, r17	; 0x14
      state->command_help_str    = tmp.commandHelpStr;
    4988:	8b 81       	ldd	r24, Y+3	; 0x03
    498a:	9c 81       	ldd	r25, Y+4	; 0x04
    498c:	85 8b       	std	Z+21, r24	; 0x15
    498e:	96 8b       	std	Z+22, r25	; 0x16
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
    4990:	80 e0       	ldi	r24, 0x00	; 0
    4992:	b7 01       	movw	r22, r14
    4994:	0e 94 49 22 	call	0x4492	; 0x4492 <cmdlineDoHistory>
    4998:	69 c0       	rjmp	.+210    	; 0x4a6c <cmdlineInputFunc+0x43a>
      return;
    }
    tmpPtr++;                                                         // Next command
    499a:	86 e0       	ldi	r24, 0x06	; 6
    499c:	90 e0       	ldi	r25, 0x00	; 0
    499e:	c8 0e       	add	r12, r24
    49a0:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    49a2:	89 2d       	mov	r24, r9
    49a4:	98 2d       	mov	r25, r8
    49a6:	b6 01       	movw	r22, r12
    49a8:	46 e0       	ldi	r20, 0x06	; 6
    49aa:	50 e0       	ldi	r21, 0x00	; 0
    49ac:	0e 94 fe 56 	call	0xadfc	; 0xadfc <memcpy_P>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
    49b0:	89 81       	ldd	r24, Y+1	; 0x01
    49b2:	9a 81       	ldd	r25, Y+2	; 0x02
    49b4:	00 97       	sbiw	r24, 0x00	; 0
    49b6:	a1 f6       	brne	.-88     	; 0x4960 <cmdlineInputFunc+0x32e>
    49b8:	0e e0       	ldi	r16, 0x0E	; 14
    49ba:	18 e0       	ldi	r17, 0x08	; 8
    49bc:	0c c0       	rjmp	.+24     	; 0x49d6 <cmdlineInputFunc+0x3a4>

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    49be:	0f 5f       	subi	r16, 0xFF	; 255
    49c0:	1f 4f       	sbci	r17, 0xFF	; 255
    49c2:	fc 01       	movw	r30, r24
    49c4:	84 91       	lpm	r24, Z+
    49c6:	d7 01       	movw	r26, r14
    49c8:	5a 96       	adiw	r26, 0x1a	; 26
    49ca:	6d 91       	ld	r22, X+
    49cc:	7c 91       	ld	r23, X
    49ce:	5b 97       	sbiw	r26, 0x1b	; 27
    49d0:	90 e0       	ldi	r25, 0x00	; 0
    49d2:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    49d6:	c8 01       	movw	r24, r16
  char * ptr;

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    49d8:	f8 01       	movw	r30, r16
    49da:	24 91       	lpm	r18, Z+
    49dc:	22 23       	and	r18, r18
    49de:	79 f7       	brne	.-34     	; 0x49be <cmdlineInputFunc+0x38c>
    49e0:	d7 01       	movw	r26, r14
    49e2:	0d 91       	ld	r16, X+
    49e4:	1c 91       	ld	r17, X
    49e6:	11 97       	sbiw	r26, 0x01	; 1
    49e8:	08 c0       	rjmp	.+16     	; 0x49fa <cmdlineInputFunc+0x3c8>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    fputc(*ptr++    , state->myStdInOut);
    49ea:	f7 01       	movw	r30, r14
    49ec:	62 8d       	ldd	r22, Z+26	; 0x1a
    49ee:	73 8d       	ldd	r23, Z+27	; 0x1b
    49f0:	99 27       	eor	r25, r25
    49f2:	87 fd       	sbrc	r24, 7
    49f4:	90 95       	com	r25
    49f6:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    49fa:	d8 01       	movw	r26, r16
    49fc:	8d 91       	ld	r24, X+
    49fe:	8d 01       	movw	r16, r26
    4a00:	88 23       	and	r24, r24
    4a02:	11 f0       	breq	.+4      	; 0x4a08 <cmdlineInputFunc+0x3d6>
    4a04:	80 32       	cpi	r24, 0x20	; 32
    4a06:	89 f7       	brne	.-30     	; 0x49ea <cmdlineInputFunc+0x3b8>
    fputc(*ptr++    , state->myStdInOut);

  fputc(':'         , state->myStdInOut);
    4a08:	f7 01       	movw	r30, r14
    4a0a:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a0c:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a0e:	8a e3       	ldi	r24, 0x3A	; 58
    4a10:	90 e0       	ldi	r25, 0x00	; 0
    4a12:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
  fputc(' '         , state->myStdInOut);
    4a16:	d7 01       	movw	r26, r14
    4a18:	5a 96       	adiw	r26, 0x1a	; 26
    4a1a:	6d 91       	ld	r22, X+
    4a1c:	7c 91       	ld	r23, X
    4a1e:	5b 97       	sbiw	r26, 0x1b	; 27
    4a20:	80 e2       	ldi	r24, 0x20	; 32
    4a22:	90 e0       	ldi	r25, 0x00	; 0
    4a24:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
    4a28:	08 e1       	ldi	r16, 0x18	; 24
    4a2a:	18 e0       	ldi	r17, 0x08	; 8
    4a2c:	07 c0       	rjmp	.+14     	; 0x4a3c <cmdlineInputFunc+0x40a>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4a2e:	0f 5f       	subi	r16, 0xFF	; 255
    4a30:	1f 4f       	sbci	r17, 0xFF	; 255
    4a32:	fc 01       	movw	r30, r24
    4a34:	84 91       	lpm	r24, Z+
    4a36:	90 e0       	ldi	r25, 0x00	; 0
    4a38:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    4a3c:	c8 01       	movw	r24, r16
  fputc(' '         , state->myStdInOut);

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    4a3e:	f8 01       	movw	r30, r16
    4a40:	24 91       	lpm	r18, Z+
    4a42:	d7 01       	movw	r26, r14
    4a44:	5a 96       	adiw	r26, 0x1a	; 26
    4a46:	6d 91       	ld	r22, X+
    4a48:	7c 91       	ld	r23, X
    4a4a:	5b 97       	sbiw	r26, 0x1b	; 27
    4a4c:	22 23       	and	r18, r18
    4a4e:	79 f7       	brne	.-34     	; 0x4a2e <cmdlineInputFunc+0x3fc>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);

  fputc('\r'        , state->myStdInOut);
    4a50:	8d e0       	ldi	r24, 0x0D	; 13
    4a52:	90 e0       	ldi	r25, 0x00	; 0
    4a54:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
  fputc('\n'        , state->myStdInOut);
    4a58:	f7 01       	movw	r30, r14
    4a5a:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a5c:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a5e:	8a e0       	ldi	r24, 0x0A	; 10
    4a60:	90 e0       	ldi	r25, 0x00	; 0
    4a62:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
  
  // if we did not get a match
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
    4a66:	c7 01       	movw	r24, r14
    4a68:	0e 94 df 21 	call	0x43be	; 0x43be <cmdlinePrintPrompt>
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    state->CmdlineBufferEditPos++;
    // command is complete, process it
    cmdlineProcessInputString(state);
    // reset buffer
    state->CmdlineBufferLength = 0;
    4a6c:	d7 01       	movw	r26, r14
    4a6e:	1d 96       	adiw	r26, 0x0d	; 13
    4a70:	1c 92       	st	X, r1
    4a72:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = 0;
    4a74:	1e 96       	adiw	r26, 0x0e	; 14
    4a76:	1c 92       	st	X, r1
    4a78:	1e 97       	sbiw	r26, 0x0e	; 14
    4a7a:	79 c0       	rjmp	.+242    	; 0x4b6e <cmdlineInputFunc+0x53c>
  }
  else if(c == ASCII_BS)
    4a7c:	08 30       	cpi	r16, 0x08	; 8
    4a7e:	09 f0       	breq	.+2      	; 0x4a82 <cmdlineInputFunc+0x450>
    4a80:	6d c0       	rjmp	.+218    	; 0x4b5c <cmdlineInputFunc+0x52a>
  {
    if(state->CmdlineBufferEditPos)
    4a82:	f7 01       	movw	r30, r14
    4a84:	86 85       	ldd	r24, Z+14	; 0x0e
    4a86:	88 23       	and	r24, r24
    4a88:	09 f4       	brne	.+2      	; 0x4a8c <cmdlineInputFunc+0x45a>
    4a8a:	60 c0       	rjmp	.+192    	; 0x4b4c <cmdlineInputFunc+0x51a>
    {
      // is this a simple delete (off the end of the line)
      if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    4a8c:	95 85       	ldd	r25, Z+13	; 0x0d
    4a8e:	89 17       	cp	r24, r25
    4a90:	31 f5       	brne	.+76     	; 0x4ade <cmdlineInputFunc+0x4ac>
      {
        // destructive backspace
        // echo backspace-space-backspace
        fputc(ASCII_BS         , state->myStdInOut);
    4a92:	62 8d       	ldd	r22, Z+26	; 0x1a
    4a94:	73 8d       	ldd	r23, Z+27	; 0x1b
    4a96:	88 e0       	ldi	r24, 0x08	; 8
    4a98:	90 e0       	ldi	r25, 0x00	; 0
    4a9a:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        fputc(' '              , state->myStdInOut);
    4a9e:	d7 01       	movw	r26, r14
    4aa0:	5a 96       	adiw	r26, 0x1a	; 26
    4aa2:	6d 91       	ld	r22, X+
    4aa4:	7c 91       	ld	r23, X
    4aa6:	5b 97       	sbiw	r26, 0x1b	; 27
    4aa8:	80 e2       	ldi	r24, 0x20	; 32
    4aaa:	90 e0       	ldi	r25, 0x00	; 0
    4aac:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        fputc(ASCII_BS         , state->myStdInOut);
    4ab0:	f7 01       	movw	r30, r14
    4ab2:	62 8d       	ldd	r22, Z+26	; 0x1a
    4ab4:	73 8d       	ldd	r23, Z+27	; 0x1b
    4ab6:	88 e0       	ldi	r24, 0x08	; 8
    4ab8:	90 e0       	ldi	r25, 0x00	; 0
    4aba:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        // decrement our buffer length and edit position
        state->CmdlineBufferLength--;
    4abe:	d7 01       	movw	r26, r14
    4ac0:	1d 96       	adiw	r26, 0x0d	; 13
    4ac2:	8c 91       	ld	r24, X
    4ac4:	1d 97       	sbiw	r26, 0x0d	; 13
    4ac6:	81 50       	subi	r24, 0x01	; 1
    4ac8:	1d 96       	adiw	r26, 0x0d	; 13
    4aca:	8c 93       	st	X, r24
    4acc:	1d 97       	sbiw	r26, 0x0d	; 13
        state->CmdlineBufferEditPos--;
    4ace:	1e 96       	adiw	r26, 0x0e	; 14
    4ad0:	8c 91       	ld	r24, X
    4ad2:	1e 97       	sbiw	r26, 0x0e	; 14
    4ad4:	81 50       	subi	r24, 0x01	; 1
    4ad6:	1e 96       	adiw	r26, 0x0e	; 14
    4ad8:	8c 93       	st	X, r24
    4ada:	1e 97       	sbiw	r26, 0x0e	; 14
    4adc:	48 c0       	rjmp	.+144    	; 0x4b6e <cmdlineInputFunc+0x53c>
      else
      {
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
    4ade:	91 50       	subi	r25, 0x01	; 1
    4ae0:	f7 01       	movw	r30, r14
    4ae2:	95 87       	std	Z+13, r25	; 0x0d
        state->CmdlineBufferEditPos--;
    4ae4:	81 50       	subi	r24, 0x01	; 1
    4ae6:	86 87       	std	Z+14, r24	; 0x0e
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4ae8:	06 c0       	rjmp	.+12     	; 0x4af6 <cmdlineInputFunc+0x4c4>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
    4aea:	fb 01       	movw	r30, r22
    4aec:	e8 0f       	add	r30, r24
    4aee:	f1 1d       	adc	r31, r1
    4af0:	91 81       	ldd	r25, Z+1	; 0x01
    4af2:	90 83       	st	Z, r25
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
        state->CmdlineBufferEditPos--;
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4af4:	8f 5f       	subi	r24, 0xFF	; 255
    4af6:	d7 01       	movw	r26, r14
    4af8:	1d 96       	adiw	r26, 0x0d	; 13
    4afa:	9c 91       	ld	r25, X
    4afc:	1d 97       	sbiw	r26, 0x0d	; 13
    4afe:	6d 91       	ld	r22, X+
    4b00:	7c 91       	ld	r23, X
    4b02:	11 97       	sbiw	r26, 0x01	; 1
    4b04:	89 17       	cp	r24, r25
    4b06:	88 f3       	brcs	.-30     	; 0x4aea <cmdlineInputFunc+0x4b8>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
    4b08:	c7 01       	movw	r24, r14
    4b0a:	0e 94 0a 22 	call	0x4414	; 0x4414 <cmdlineRepaint>
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
    4b0e:	f7 01       	movw	r30, r14
    4b10:	62 8d       	ldd	r22, Z+26	; 0x1a
    4b12:	73 8d       	ldd	r23, Z+27	; 0x1b
    4b14:	80 e2       	ldi	r24, 0x20	; 32
    4b16:	90 e0       	ldi	r25, 0x00	; 0
    4b18:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4b1c:	d7 01       	movw	r26, r14
    4b1e:	1e 96       	adiw	r26, 0x0e	; 14
    4b20:	0c 91       	ld	r16, X
    4b22:	1e 97       	sbiw	r26, 0x0e	; 14
    4b24:	08 c0       	rjmp	.+16     	; 0x4b36 <cmdlineInputFunc+0x504>
          fputc(ASCII_BS       , state->myStdInOut);
    4b26:	f7 01       	movw	r30, r14
    4b28:	62 8d       	ldd	r22, Z+26	; 0x1a
    4b2a:	73 8d       	ldd	r23, Z+27	; 0x1b
    4b2c:	88 e0       	ldi	r24, 0x08	; 8
    4b2e:	90 e0       	ldi	r25, 0x00	; 0
    4b30:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4b34:	0f 5f       	subi	r16, 0xFF	; 255
    4b36:	d7 01       	movw	r26, r14
    4b38:	1d 96       	adiw	r26, 0x0d	; 13
    4b3a:	2c 91       	ld	r18, X
    4b3c:	1d 97       	sbiw	r26, 0x0d	; 13
    4b3e:	30 e0       	ldi	r19, 0x00	; 0
    4b40:	80 2f       	mov	r24, r16
    4b42:	90 e0       	ldi	r25, 0x00	; 0
    4b44:	28 17       	cp	r18, r24
    4b46:	39 07       	cpc	r19, r25
    4b48:	74 f7       	brge	.-36     	; 0x4b26 <cmdlineInputFunc+0x4f4>
    4b4a:	11 c0       	rjmp	.+34     	; 0x4b6e <cmdlineInputFunc+0x53c>
      }
    }
    else
    {
      // else, ring the bell
      fputc(ASCII_BEL          , state->myStdInOut);
    4b4c:	f7 01       	movw	r30, r14
    4b4e:	62 8d       	ldd	r22, Z+26	; 0x1a
    4b50:	73 8d       	ldd	r23, Z+27	; 0x1b
    4b52:	87 e0       	ldi	r24, 0x07	; 7
    4b54:	90 e0       	ldi	r25, 0x00	; 0
    4b56:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    4b5a:	09 c0       	rjmp	.+18     	; 0x4b6e <cmdlineInputFunc+0x53c>
    }
  }
  else if(c == ASCII_DEL)
    4b5c:	0f 37       	cpi	r16, 0x7F	; 127
    4b5e:	39 f0       	breq	.+14     	; 0x4b6e <cmdlineInputFunc+0x53c>
  {
    // not yet handled
  }
  else if(c == ASCII_ESC)
    4b60:	0b 31       	cpi	r16, 0x1B	; 27
    4b62:	29 f4       	brne	.+10     	; 0x4b6e <cmdlineInputFunc+0x53c>
  {
    state->CmdlineInputVT100State = 1;
    4b64:	81 e0       	ldi	r24, 0x01	; 1
    4b66:	d7 01       	movw	r26, r14
    4b68:	52 96       	adiw	r26, 0x12	; 18
    4b6a:	8c 93       	st	X, r24
    4b6c:	52 97       	sbiw	r26, 0x12	; 18
  }
}
    4b6e:	26 96       	adiw	r28, 0x06	; 6
    4b70:	cd bf       	out	0x3d, r28	; 61
    4b72:	de bf       	out	0x3e, r29	; 62
    4b74:	cf 91       	pop	r28
    4b76:	df 91       	pop	r29
    4b78:	1f 91       	pop	r17
    4b7a:	0f 91       	pop	r16
    4b7c:	ff 90       	pop	r15
    4b7e:	ef 90       	pop	r14
    4b80:	df 90       	pop	r13
    4b82:	cf 90       	pop	r12
    4b84:	bf 90       	pop	r11
    4b86:	af 90       	pop	r10
    4b88:	9f 90       	pop	r9
    4b8a:	8f 90       	pop	r8
    4b8c:	08 95       	ret

00004b8e <cmdLineGetLastArgIdx>:
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
    4b8e:	dc 01       	movw	r26, r24
    4b90:	12 96       	adiw	r26, 0x02	; 2
    4b92:	ed 91       	ld	r30, X+
    4b94:	fc 91       	ld	r31, X
    4b96:	13 97       	sbiw	r26, 0x03	; 3
  uint8_t lastWhite = 1;
    4b98:	91 e0       	ldi	r25, 0x01	; 1
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
    4b9a:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    4b9c:	09 c0       	rjmp	.+18     	; 0x4bb0 <cmdLineGetLastArgIdx+0x22>
  {
    if (*str == ' ')
    4b9e:	20 32       	cpi	r18, 0x20	; 32
    4ba0:	21 f4       	brne	.+8      	; 0x4baa <cmdLineGetLastArgIdx+0x1c>
    {
      if (lastWhite == 0)
    4ba2:	99 23       	and	r25, r25
    4ba4:	21 f4       	brne	.+8      	; 0x4bae <cmdLineGetLastArgIdx+0x20>
        result++;
    4ba6:	8f 5f       	subi	r24, 0xFF	; 255
    4ba8:	02 c0       	rjmp	.+4      	; 0x4bae <cmdLineGetLastArgIdx+0x20>
      lastWhite = 1;
    }
    else
      lastWhite = 0;
    4baa:	90 e0       	ldi	r25, 0x00	; 0
    4bac:	01 c0       	rjmp	.+2      	; 0x4bb0 <cmdLineGetLastArgIdx+0x22>
  {
    if (*str == ' ')
    {
      if (lastWhite == 0)
        result++;
      lastWhite = 1;
    4bae:	91 e0       	ldi	r25, 0x01	; 1
uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    4bb0:	21 91       	ld	r18, Z+
    4bb2:	22 23       	and	r18, r18
    4bb4:	a1 f7       	brne	.-24     	; 0x4b9e <cmdLineGetLastArgIdx+0x10>
    else
      lastWhite = 0;
    str++;
  }
  return result;
}
    4bb6:	08 95       	ret

00004bb8 <cmdlineMainLoop>:
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
}

void cmdlineMainLoop(cmdState_t *state)
{
    4bb8:	0f 93       	push	r16
    4bba:	1f 93       	push	r17
    4bbc:	cf 93       	push	r28
    4bbe:	df 93       	push	r29
    4bc0:	ec 01       	movw	r28, r24
  cliExRes_t result;
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
    4bc2:	0f 89       	ldd	r16, Y+23	; 0x17
    4bc4:	18 8d       	ldd	r17, Y+24	; 0x18
    4bc6:	01 15       	cp	r16, r1
    4bc8:	11 05       	cpc	r17, r1
    4bca:	09 f4       	brne	.+2      	; 0x4bce <cmdlineMainLoop+0x16>
    4bcc:	86 c0       	rjmp	.+268    	; 0x4cda <cmdlineMainLoop+0x122>
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    4bce:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <cmdLineGetLastArgIdx>
    4bd2:	89 8f       	std	Y+25, r24	; 0x19
    result = state->CmdlineExecFunction(state); // run it
    4bd4:	ce 01       	movw	r24, r28
    4bd6:	f8 01       	movw	r30, r16
    4bd8:	19 95       	eicall
    
    switch(result)
    4bda:	82 30       	cpi	r24, 0x02	; 2
    4bdc:	91 05       	cpc	r25, r1
    4bde:	e1 f0       	breq	.+56     	; 0x4c18 <cmdlineMainLoop+0x60>
    4be0:	83 30       	cpi	r24, 0x03	; 3
    4be2:	91 05       	cpc	r25, r1
    4be4:	28 f4       	brcc	.+10     	; 0x4bf0 <cmdlineMainLoop+0x38>
    4be6:	81 30       	cpi	r24, 0x01	; 1
    4be8:	91 05       	cpc	r25, r1
    4bea:	09 f0       	breq	.+2      	; 0x4bee <cmdlineMainLoop+0x36>
    4bec:	6d c0       	rjmp	.+218    	; 0x4cc8 <cmdlineMainLoop+0x110>
    4bee:	09 c0       	rjmp	.+18     	; 0x4c02 <cmdlineMainLoop+0x4a>
    4bf0:	84 30       	cpi	r24, 0x04	; 4
    4bf2:	91 05       	cpc	r25, r1
    4bf4:	09 f4       	brne	.+2      	; 0x4bf8 <cmdlineMainLoop+0x40>
    4bf6:	4b c0       	rjmp	.+150    	; 0x4c8e <cmdlineMainLoop+0xd6>
    4bf8:	85 30       	cpi	r24, 0x05	; 5
    4bfa:	91 05       	cpc	r25, r1
    4bfc:	09 f0       	breq	.+2      	; 0x4c00 <cmdlineMainLoop+0x48>
    4bfe:	64 c0       	rjmp	.+200    	; 0x4cc8 <cmdlineMainLoop+0x110>
    4c00:	51 c0       	rjmp	.+162    	; 0x4ca4 <cmdlineMainLoop+0xec>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
    4c02:	00 d0       	rcall	.+0      	; 0x4c04 <cmdlineMainLoop+0x4c>
    4c04:	0f 92       	push	r0
    4c06:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c08:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c0a:	ed b7       	in	r30, 0x3d	; 61
    4c0c:	fe b7       	in	r31, 0x3e	; 62
    4c0e:	81 83       	std	Z+1, r24	; 0x01
    4c10:	92 83       	std	Z+2, r25	; 0x02
    4c12:	86 e6       	ldi	r24, 0x66	; 102
    4c14:	98 e0       	ldi	r25, 0x08	; 8
    4c16:	50 c0       	rjmp	.+160    	; 0x4cb8 <cmdlineMainLoop+0x100>
        break;
      case SYNTAX_ERROR:
        fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
    4c18:	00 d0       	rcall	.+0      	; 0x4c1a <cmdlineMainLoop+0x62>
    4c1a:	0f 92       	push	r0
    4c1c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c1e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c20:	ed b7       	in	r30, 0x3d	; 61
    4c22:	fe b7       	in	r31, 0x3e	; 62
    4c24:	81 83       	std	Z+1, r24	; 0x01
    4c26:	92 83       	std	Z+2, r25	; 0x02
    4c28:	82 e5       	ldi	r24, 0x52	; 82
    4c2a:	98 e0       	ldi	r25, 0x08	; 8
    4c2c:	83 83       	std	Z+3, r24	; 0x03
    4c2e:	94 83       	std	Z+4, r25	; 0x04
    4c30:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_str);
    4c34:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c36:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c38:	ed b7       	in	r30, 0x3d	; 61
    4c3a:	fe b7       	in	r31, 0x3e	; 62
    4c3c:	81 83       	std	Z+1, r24	; 0x01
    4c3e:	92 83       	std	Z+2, r25	; 0x02
    4c40:	8b 89       	ldd	r24, Y+19	; 0x13
    4c42:	9c 89       	ldd	r25, Y+20	; 0x14
    4c44:	83 83       	std	Z+3, r24	; 0x03
    4c46:	94 83       	std	Z+4, r25	; 0x04
    4c48:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR(" "));
    4c4c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c4e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c50:	ed b7       	in	r30, 0x3d	; 61
    4c52:	fe b7       	in	r31, 0x3e	; 62
    4c54:	81 83       	std	Z+1, r24	; 0x01
    4c56:	92 83       	std	Z+2, r25	; 0x02
    4c58:	80 e5       	ldi	r24, 0x50	; 80
    4c5a:	98 e0       	ldi	r25, 0x08	; 8
    4c5c:	83 83       	std	Z+3, r24	; 0x03
    4c5e:	94 83       	std	Z+4, r25	; 0x04
    4c60:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_help_str);
    4c64:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c66:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c68:	ed b7       	in	r30, 0x3d	; 61
    4c6a:	fe b7       	in	r31, 0x3e	; 62
    4c6c:	81 83       	std	Z+1, r24	; 0x01
    4c6e:	92 83       	std	Z+2, r25	; 0x02
    4c70:	8d 89       	ldd	r24, Y+21	; 0x15
    4c72:	9e 89       	ldd	r25, Y+22	; 0x16
    4c74:	83 83       	std	Z+3, r24	; 0x03
    4c76:	94 83       	std	Z+4, r25	; 0x04
    4c78:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4c7c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c7e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c80:	ed b7       	in	r30, 0x3d	; 61
    4c82:	fe b7       	in	r31, 0x3e	; 62
    4c84:	81 83       	std	Z+1, r24	; 0x01
    4c86:	92 83       	std	Z+2, r25	; 0x02
    4c88:	8d e4       	ldi	r24, 0x4D	; 77
    4c8a:	98 e0       	ldi	r25, 0x08	; 8
    4c8c:	15 c0       	rjmp	.+42     	; 0x4cb8 <cmdlineMainLoop+0x100>
        break;
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
    4c8e:	00 d0       	rcall	.+0      	; 0x4c90 <cmdlineMainLoop+0xd8>
    4c90:	0f 92       	push	r0
    4c92:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c94:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c96:	ed b7       	in	r30, 0x3d	; 61
    4c98:	fe b7       	in	r31, 0x3e	; 62
    4c9a:	81 83       	std	Z+1, r24	; 0x01
    4c9c:	92 83       	std	Z+2, r25	; 0x02
    4c9e:	8a e3       	ldi	r24, 0x3A	; 58
    4ca0:	98 e0       	ldi	r25, 0x08	; 8
    4ca2:	0a c0       	rjmp	.+20     	; 0x4cb8 <cmdlineMainLoop+0x100>
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    4ca4:	00 d0       	rcall	.+0      	; 0x4ca6 <cmdlineMainLoop+0xee>
    4ca6:	0f 92       	push	r0
    4ca8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4caa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4cac:	ed b7       	in	r30, 0x3d	; 61
    4cae:	fe b7       	in	r31, 0x3e	; 62
    4cb0:	81 83       	std	Z+1, r24	; 0x01
    4cb2:	92 83       	std	Z+2, r25	; 0x02
    4cb4:	82 e2       	ldi	r24, 0x22	; 34
    4cb6:	98 e0       	ldi	r25, 0x08	; 8
    4cb8:	83 83       	std	Z+3, r24	; 0x03
    4cba:	94 83       	std	Z+4, r25	; 0x04
    4cbc:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
        break;
    4cc0:	0f 90       	pop	r0
    4cc2:	0f 90       	pop	r0
    4cc4:	0f 90       	pop	r0
    4cc6:	0f 90       	pop	r0
      default:
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    4cc8:	1f 8a       	std	Y+23, r1	; 0x17
    4cca:	18 8e       	std	Y+24, r1	; 0x18
    state->command_str         = NULL;
    4ccc:	1b 8a       	std	Y+19, r1	; 0x13
    4cce:	1c 8a       	std	Y+20, r1	; 0x14
    state->command_help_str    = NULL;
    4cd0:	1d 8a       	std	Y+21, r1	; 0x15
    4cd2:	1e 8a       	std	Y+22, r1	; 0x16
    cmdlinePrintPrompt(state);                  // output new prompt
    4cd4:	ce 01       	movw	r24, r28
    4cd6:	0e 94 df 21 	call	0x43be	; 0x43be <cmdlinePrintPrompt>
  }
}
    4cda:	df 91       	pop	r29
    4cdc:	cf 91       	pop	r28
    4cde:	1f 91       	pop	r17
    4ce0:	0f 91       	pop	r16
    4ce2:	08 95       	ret

00004ce4 <cmdlineGetArgStr>:
  // find the offset of argument number [argnum]
  uint8_t idx=0;
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4ce4:	fb 01       	movw	r30, r22
    4ce6:	22 81       	ldd	r18, Z+2	; 0x02
    4ce8:	33 81       	ldd	r19, Z+3	; 0x03
}

char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
{
  // find the offset of argument number [argnum]
  uint8_t idx=0;
    4cea:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4cec:	01 c0       	rjmp	.+2      	; 0x4cf0 <cmdlineGetArgStr+0xc>
    4cee:	9f 5f       	subi	r25, 0xFF	; 255
    4cf0:	f9 01       	movw	r30, r18
    4cf2:	e9 0f       	add	r30, r25
    4cf4:	f1 1d       	adc	r31, r1
    4cf6:	40 81       	ld	r20, Z
    4cf8:	40 32       	cpi	r20, 0x20	; 32
    4cfa:	c9 f3       	breq	.-14     	; 0x4cee <cmdlineGetArgStr+0xa>
    4cfc:	40 e0       	ldi	r20, 0x00	; 0
    4cfe:	12 c0       	rjmp	.+36     	; 0x4d24 <cmdlineGetArgStr+0x40>
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
  {
    // find the next whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    4d00:	9f 5f       	subi	r25, 0xFF	; 255
    4d02:	f9 01       	movw	r30, r18
    4d04:	e9 0f       	add	r30, r25
    4d06:	f1 1d       	adc	r31, r1
    4d08:	50 81       	ld	r21, Z
    4d0a:	55 23       	and	r21, r21
    4d0c:	21 f0       	breq	.+8      	; 0x4d16 <cmdlineGetArgStr+0x32>
    4d0e:	50 32       	cpi	r21, 0x20	; 32
    4d10:	b9 f7       	brne	.-18     	; 0x4d00 <cmdlineGetArgStr+0x1c>
    4d12:	01 c0       	rjmp	.+2      	; 0x4d16 <cmdlineGetArgStr+0x32>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4d14:	9f 5f       	subi	r25, 0xFF	; 255
    4d16:	f9 01       	movw	r30, r18
    4d18:	e9 0f       	add	r30, r25
    4d1a:	f1 1d       	adc	r31, r1
    4d1c:	50 81       	ld	r21, Z
    4d1e:	50 32       	cpi	r21, 0x20	; 32
    4d20:	c9 f3       	breq	.-14     	; 0x4d14 <cmdlineGetArgStr+0x30>
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    4d22:	4f 5f       	subi	r20, 0xFF	; 255
    4d24:	48 17       	cp	r20, r24
    4d26:	68 f3       	brcs	.-38     	; 0x4d02 <cmdlineGetArgStr+0x1e>
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  }
  // we are at the requested argument or the end of the buffer
  return &state->CmdlineExcBuffer[idx];
    4d28:	29 0f       	add	r18, r25
    4d2a:	31 1d       	adc	r19, r1
}
    4d2c:	c9 01       	movw	r24, r18
    4d2e:	08 95       	ret

00004d30 <cmdlineGetArgInt>:

// return argument [argnum] interpreted as a decimal integer
long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
{
    4d30:	df 93       	push	r29
    4d32:	cf 93       	push	r28
    4d34:	0f 92       	push	r0
    4d36:	0f 92       	push	r0
    4d38:	cd b7       	in	r28, 0x3d	; 61
    4d3a:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
    4d3c:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    4d40:	be 01       	movw	r22, r28
    4d42:	6f 5f       	subi	r22, 0xFF	; 255
    4d44:	7f 4f       	sbci	r23, 0xFF	; 255
    4d46:	4a e0       	ldi	r20, 0x0A	; 10
    4d48:	50 e0       	ldi	r21, 0x00	; 0
    4d4a:	0e 94 b9 55 	call	0xab72	; 0xab72 <strtol>
}
    4d4e:	0f 90       	pop	r0
    4d50:	0f 90       	pop	r0
    4d52:	cf 91       	pop	r28
    4d54:	df 91       	pop	r29
    4d56:	08 95       	ret

00004d58 <cmdlineGetArgHex>:

// return argument [argnum] interpreted as a hex integer
long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
{
    4d58:	df 93       	push	r29
    4d5a:	cf 93       	push	r28
    4d5c:	0f 92       	push	r0
    4d5e:	0f 92       	push	r0
    4d60:	cd b7       	in	r28, 0x3d	; 61
    4d62:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
    4d64:	0e 94 72 26 	call	0x4ce4	; 0x4ce4 <cmdlineGetArgStr>
    4d68:	be 01       	movw	r22, r28
    4d6a:	6f 5f       	subi	r22, 0xFF	; 255
    4d6c:	7f 4f       	sbci	r23, 0xFF	; 255
    4d6e:	40 e1       	ldi	r20, 0x10	; 16
    4d70:	50 e0       	ldi	r21, 0x00	; 0
    4d72:	0e 94 b9 55 	call	0xab72	; 0xab72 <strtol>
}
    4d76:	0f 90       	pop	r0
    4d78:	0f 90       	pop	r0
    4d7a:	cf 91       	pop	r28
    4d7c:	df 91       	pop	r29
    4d7e:	08 95       	ret

00004d80 <cmdPrintHelp>:

void cmdPrintHelp(cmdState_t *state)
{
    4d80:	8f 92       	push	r8
    4d82:	9f 92       	push	r9
    4d84:	af 92       	push	r10
    4d86:	bf 92       	push	r11
    4d88:	cf 92       	push	r12
    4d8a:	df 92       	push	r13
    4d8c:	ef 92       	push	r14
    4d8e:	ff 92       	push	r15
    4d90:	0f 93       	push	r16
    4d92:	1f 93       	push	r17
    4d94:	df 93       	push	r29
    4d96:	cf 93       	push	r28
    4d98:	00 d0       	rcall	.+0      	; 0x4d9a <cmdPrintHelp+0x1a>
    4d9a:	00 d0       	rcall	.+0      	; 0x4d9c <cmdPrintHelp+0x1c>
    4d9c:	cd b7       	in	r28, 0x3d	; 61
    4d9e:	de b7       	in	r29, 0x3e	; 62
    4da0:	8c 01       	movw	r16, r24
  command_t  tmp;
  const command_t *tmpPtr = state->cmdList;
    4da2:	fc 01       	movw	r30, r24
    4da4:	e1 a0       	ldd	r14, Z+33	; 0x21
    4da6:	f2 a0       	ldd	r15, Z+34	; 0x22
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4da8:	6e 01       	movw	r12, r28
    4daa:	08 94       	sec
    4dac:	c1 1c       	adc	r12, r1
    4dae:	d1 1c       	adc	r13, r1
    4db0:	c6 01       	movw	r24, r12
    4db2:	b7 01       	movw	r22, r14
    4db4:	46 e0       	ldi	r20, 0x06	; 6
    4db6:	50 e0       	ldi	r21, 0x00	; 0
    4db8:	0e 94 fe 56 	call	0xadfc	; 0xadfc <memcpy_P>
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4dbc:	90 e2       	ldi	r25, 0x20	; 32
    4dbe:	a9 2e       	mov	r10, r25
    4dc0:	98 e0       	ldi	r25, 0x08	; 8
    4dc2:	b9 2e       	mov	r11, r25
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4dc4:	8d e1       	ldi	r24, 0x1D	; 29
    4dc6:	88 2e       	mov	r8, r24
    4dc8:	88 e0       	ldi	r24, 0x08	; 8
    4dca:	98 2e       	mov	r9, r24

    tmpPtr++;
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4dcc:	c6 01       	movw	r24, r12
    4dce:	dc 2c       	mov	r13, r12
    4dd0:	c9 2e       	mov	r12, r25
  const command_t *tmpPtr = state->cmdList;
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    4dd2:	00 d0       	rcall	.+0      	; 0x4dd4 <cmdPrintHelp+0x54>
    4dd4:	0f 92       	push	r0
    4dd6:	f8 01       	movw	r30, r16
    4dd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    4dda:	93 8d       	ldd	r25, Z+27	; 0x1b
    4ddc:	ed b7       	in	r30, 0x3d	; 61
    4dde:	fe b7       	in	r31, 0x3e	; 62
    4de0:	81 83       	std	Z+1, r24	; 0x01
    4de2:	92 83       	std	Z+2, r25	; 0x02
    4de4:	89 81       	ldd	r24, Y+1	; 0x01
    4de6:	9a 81       	ldd	r25, Y+2	; 0x02
    4de8:	83 83       	std	Z+3, r24	; 0x03
    4dea:	94 83       	std	Z+4, r25	; 0x04
    4dec:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4df0:	f8 01       	movw	r30, r16
    4df2:	82 8d       	ldd	r24, Z+26	; 0x1a
    4df4:	93 8d       	ldd	r25, Z+27	; 0x1b
    4df6:	ed b7       	in	r30, 0x3d	; 61
    4df8:	fe b7       	in	r31, 0x3e	; 62
    4dfa:	81 83       	std	Z+1, r24	; 0x01
    4dfc:	92 83       	std	Z+2, r25	; 0x02
    4dfe:	a3 82       	std	Z+3, r10	; 0x03
    4e00:	b4 82       	std	Z+4, r11	; 0x04
    4e02:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    4e06:	f8 01       	movw	r30, r16
    4e08:	82 8d       	ldd	r24, Z+26	; 0x1a
    4e0a:	93 8d       	ldd	r25, Z+27	; 0x1b
    4e0c:	ed b7       	in	r30, 0x3d	; 61
    4e0e:	fe b7       	in	r31, 0x3e	; 62
    4e10:	81 83       	std	Z+1, r24	; 0x01
    4e12:	92 83       	std	Z+2, r25	; 0x02
    4e14:	8b 81       	ldd	r24, Y+3	; 0x03
    4e16:	9c 81       	ldd	r25, Y+4	; 0x04
    4e18:	83 83       	std	Z+3, r24	; 0x03
    4e1a:	94 83       	std	Z+4, r25	; 0x04
    4e1c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4e20:	f8 01       	movw	r30, r16
    4e22:	82 8d       	ldd	r24, Z+26	; 0x1a
    4e24:	93 8d       	ldd	r25, Z+27	; 0x1b
    4e26:	ed b7       	in	r30, 0x3d	; 61
    4e28:	fe b7       	in	r31, 0x3e	; 62
    4e2a:	81 83       	std	Z+1, r24	; 0x01
    4e2c:	92 83       	std	Z+2, r25	; 0x02
    4e2e:	83 82       	std	Z+3, r8	; 0x03
    4e30:	94 82       	std	Z+4, r9	; 0x04
    4e32:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>

    tmpPtr++;
    4e36:	86 e0       	ldi	r24, 0x06	; 6
    4e38:	90 e0       	ldi	r25, 0x00	; 0
    4e3a:	e8 0e       	add	r14, r24
    4e3c:	f9 1e       	adc	r15, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4e3e:	0f 90       	pop	r0
    4e40:	0f 90       	pop	r0
    4e42:	0f 90       	pop	r0
    4e44:	0f 90       	pop	r0
    4e46:	8d 2d       	mov	r24, r13
    4e48:	9c 2d       	mov	r25, r12
    4e4a:	b7 01       	movw	r22, r14
    4e4c:	46 e0       	ldi	r20, 0x06	; 6
    4e4e:	50 e0       	ldi	r21, 0x00	; 0
    4e50:	0e 94 fe 56 	call	0xadfc	; 0xadfc <memcpy_P>
  }
  while (tmp.commandFun != NULL);
    4e54:	8d 81       	ldd	r24, Y+5	; 0x05
    4e56:	9e 81       	ldd	r25, Y+6	; 0x06
    4e58:	00 97       	sbiw	r24, 0x00	; 0
    4e5a:	09 f0       	breq	.+2      	; 0x4e5e <cmdPrintHelp+0xde>
    4e5c:	ba cf       	rjmp	.-140    	; 0x4dd2 <cmdPrintHelp+0x52>
}
    4e5e:	26 96       	adiw	r28, 0x06	; 6
    4e60:	cd bf       	out	0x3d, r28	; 61
    4e62:	de bf       	out	0x3e, r29	; 62
    4e64:	cf 91       	pop	r28
    4e66:	df 91       	pop	r29
    4e68:	1f 91       	pop	r17
    4e6a:	0f 91       	pop	r16
    4e6c:	ff 90       	pop	r15
    4e6e:	ef 90       	pop	r14
    4e70:	df 90       	pop	r13
    4e72:	cf 90       	pop	r12
    4e74:	bf 90       	pop	r11
    4e76:	af 90       	pop	r10
    4e78:	9f 90       	pop	r9
    4e7a:	8f 90       	pop	r8
    4e7c:	08 95       	ret

00004e7e <vt100Init>:
void vt100Init(cmdState_t *state)
{
  // initializes terminal to "power-on" settings
  // ESC c

 fprintf_P(state->myStdInOut, "\x1B\x63");
    4e7e:	00 d0       	rcall	.+0      	; 0x4e80 <vt100Init+0x2>
    4e80:	0f 92       	push	r0
    4e82:	fc 01       	movw	r30, r24
    4e84:	82 8d       	ldd	r24, Z+26	; 0x1a
    4e86:	93 8d       	ldd	r25, Z+27	; 0x1b
    4e88:	ed b7       	in	r30, 0x3d	; 61
    4e8a:	fe b7       	in	r31, 0x3e	; 62
    4e8c:	81 83       	std	Z+1, r24	; 0x01
    4e8e:	92 83       	std	Z+2, r25	; 0x02
    4e90:	8d ed       	ldi	r24, 0xDD	; 221
    4e92:	94 e2       	ldi	r25, 0x24	; 36
    4e94:	83 83       	std	Z+3, r24	; 0x03
    4e96:	94 83       	std	Z+4, r25	; 0x04
    4e98:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    4e9c:	0f 90       	pop	r0
    4e9e:	0f 90       	pop	r0
    4ea0:	0f 90       	pop	r0
    4ea2:	0f 90       	pop	r0
}
    4ea4:	08 95       	ret

00004ea6 <vt100ClearScreen>:

void vt100ClearScreen(cmdState_t *state)
{
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
    4ea6:	00 d0       	rcall	.+0      	; 0x4ea8 <vt100ClearScreen+0x2>
    4ea8:	0f 92       	push	r0
    4eaa:	fc 01       	movw	r30, r24
    4eac:	82 8d       	ldd	r24, Z+26	; 0x1a
    4eae:	93 8d       	ldd	r25, Z+27	; 0x1b
    4eb0:	ed b7       	in	r30, 0x3d	; 61
    4eb2:	fe b7       	in	r31, 0x3e	; 62
    4eb4:	81 83       	std	Z+1, r24	; 0x01
    4eb6:	92 83       	std	Z+2, r25	; 0x02
    4eb8:	80 ee       	ldi	r24, 0xE0	; 224
    4eba:	94 e2       	ldi	r25, 0x24	; 36
    4ebc:	83 83       	std	Z+3, r24	; 0x03
    4ebe:	94 83       	std	Z+4, r25	; 0x04
    4ec0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    4ec4:	0f 90       	pop	r0
    4ec6:	0f 90       	pop	r0
    4ec8:	0f 90       	pop	r0
    4eca:	0f 90       	pop	r0
}
    4ecc:	08 95       	ret

00004ece <vt100SetAttr>:

void vt100SetAttr(uint8_t attr, cmdState_t *state)
{
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
    4ece:	00 d0       	rcall	.+0      	; 0x4ed0 <vt100SetAttr+0x2>
    4ed0:	00 d0       	rcall	.+0      	; 0x4ed2 <vt100SetAttr+0x4>
    4ed2:	ed b7       	in	r30, 0x3d	; 61
    4ed4:	fe b7       	in	r31, 0x3e	; 62
    4ed6:	31 96       	adiw	r30, 0x01	; 1
    4ed8:	db 01       	movw	r26, r22
    4eda:	5a 96       	adiw	r26, 0x1a	; 26
    4edc:	2d 91       	ld	r18, X+
    4ede:	3c 91       	ld	r19, X
    4ee0:	5b 97       	sbiw	r26, 0x1b	; 27
    4ee2:	ad b7       	in	r26, 0x3d	; 61
    4ee4:	be b7       	in	r27, 0x3e	; 62
    4ee6:	11 96       	adiw	r26, 0x01	; 1
    4ee8:	2d 93       	st	X+, r18
    4eea:	3c 93       	st	X, r19
    4eec:	12 97       	sbiw	r26, 0x02	; 2
    4eee:	25 ee       	ldi	r18, 0xE5	; 229
    4ef0:	34 e2       	ldi	r19, 0x24	; 36
    4ef2:	22 83       	std	Z+2, r18	; 0x02
    4ef4:	33 83       	std	Z+3, r19	; 0x03
    4ef6:	84 83       	std	Z+4, r24	; 0x04
    4ef8:	15 82       	std	Z+5, r1	; 0x05
    4efa:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    4efe:	8d b7       	in	r24, 0x3d	; 61
    4f00:	9e b7       	in	r25, 0x3e	; 62
    4f02:	06 96       	adiw	r24, 0x06	; 6
    4f04:	8d bf       	out	0x3d, r24	; 61
    4f06:	9e bf       	out	0x3e, r25	; 62
}
    4f08:	08 95       	ret

00004f0a <vt100SetCursorMode>:

void vt100SetCursorMode(uint8_t visible, cmdState_t *state)
{
    4f0a:	fb 01       	movw	r30, r22
    4f0c:	22 8d       	ldd	r18, Z+26	; 0x1a
    4f0e:	33 8d       	ldd	r19, Z+27	; 0x1b
  if(visible)
    4f10:	88 23       	and	r24, r24
    4f12:	49 f0       	breq	.+18     	; 0x4f26 <vt100SetCursorMode+0x1c>
  // ESC [ ? 25 h
    fprintf_P(state->myStdInOut, "\x1B[?25h");
    4f14:	00 d0       	rcall	.+0      	; 0x4f16 <vt100SetCursorMode+0xc>
    4f16:	0f 92       	push	r0
    4f18:	ed b7       	in	r30, 0x3d	; 61
    4f1a:	fe b7       	in	r31, 0x3e	; 62
    4f1c:	21 83       	std	Z+1, r18	; 0x01
    4f1e:	32 83       	std	Z+2, r19	; 0x02
    4f20:	8b ee       	ldi	r24, 0xEB	; 235
    4f22:	94 e2       	ldi	r25, 0x24	; 36
    4f24:	08 c0       	rjmp	.+16     	; 0x4f36 <vt100SetCursorMode+0x2c>
  else
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
    4f26:	00 d0       	rcall	.+0      	; 0x4f28 <vt100SetCursorMode+0x1e>
    4f28:	0f 92       	push	r0
    4f2a:	ed b7       	in	r30, 0x3d	; 61
    4f2c:	fe b7       	in	r31, 0x3e	; 62
    4f2e:	21 83       	std	Z+1, r18	; 0x01
    4f30:	32 83       	std	Z+2, r19	; 0x02
    4f32:	82 ef       	ldi	r24, 0xF2	; 242
    4f34:	94 e2       	ldi	r25, 0x24	; 36
    4f36:	83 83       	std	Z+3, r24	; 0x03
    4f38:	94 83       	std	Z+4, r25	; 0x04
    4f3a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    4f3e:	0f 90       	pop	r0
    4f40:	0f 90       	pop	r0
    4f42:	0f 90       	pop	r0
    4f44:	0f 90       	pop	r0
    4f46:	08 95       	ret

00004f48 <vt100SetCursorPos>:
}

void vt100SetCursorPos(uint8_t line, uint8_t col, cmdState_t *state)
{
  // ESC [ Pl ; Pc H
  fprintf_P(state->myStdInOut, "\x1B[%d;%dH",line,col);
    4f48:	2d b7       	in	r18, 0x3d	; 61
    4f4a:	3e b7       	in	r19, 0x3e	; 62
    4f4c:	28 50       	subi	r18, 0x08	; 8
    4f4e:	30 40       	sbci	r19, 0x00	; 0
    4f50:	2d bf       	out	0x3d, r18	; 61
    4f52:	3e bf       	out	0x3e, r19	; 62
    4f54:	ed b7       	in	r30, 0x3d	; 61
    4f56:	fe b7       	in	r31, 0x3e	; 62
    4f58:	31 96       	adiw	r30, 0x01	; 1
    4f5a:	da 01       	movw	r26, r20
    4f5c:	5a 96       	adiw	r26, 0x1a	; 26
    4f5e:	2d 91       	ld	r18, X+
    4f60:	3c 91       	ld	r19, X
    4f62:	5b 97       	sbiw	r26, 0x1b	; 27
    4f64:	ad b7       	in	r26, 0x3d	; 61
    4f66:	be b7       	in	r27, 0x3e	; 62
    4f68:	11 96       	adiw	r26, 0x01	; 1
    4f6a:	2d 93       	st	X+, r18
    4f6c:	3c 93       	st	X, r19
    4f6e:	12 97       	sbiw	r26, 0x02	; 2
    4f70:	29 ef       	ldi	r18, 0xF9	; 249
    4f72:	34 e2       	ldi	r19, 0x24	; 36
    4f74:	22 83       	std	Z+2, r18	; 0x02
    4f76:	33 83       	std	Z+3, r19	; 0x03
    4f78:	84 83       	std	Z+4, r24	; 0x04
    4f7a:	15 82       	std	Z+5, r1	; 0x05
    4f7c:	66 83       	std	Z+6, r22	; 0x06
    4f7e:	17 82       	std	Z+7, r1	; 0x07
    4f80:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    4f84:	2d b7       	in	r18, 0x3d	; 61
    4f86:	3e b7       	in	r19, 0x3e	; 62
    4f88:	28 5f       	subi	r18, 0xF8	; 248
    4f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    4f8c:	2d bf       	out	0x3d, r18	; 61
    4f8e:	3e bf       	out	0x3e, r19	; 62
}
    4f90:	08 95       	ret
    4f92:	08 95       	ret
    4f94:	08 95       	ret

00004f96 <readTimeBCD>:
void spiEnableDS1305(void)  {};
void spiDisableDS1305(void) {};


void readTimeBCD(timeBCD_t *time)
{
    4f96:	ef 92       	push	r14
    4f98:	ff 92       	push	r15
    4f9a:	1f 93       	push	r17
    4f9c:	df 93       	push	r29
    4f9e:	cf 93       	push	r28
    4fa0:	0f 92       	push	r0
    4fa2:	0f 92       	push	r0
    4fa4:	cd b7       	in	r28, 0x3d	; 61
    4fa6:	de b7       	in	r29, 0x3e	; 62
  spiTake();
    4fa8:	89 83       	std	Y+1, r24	; 0x01
    4faa:	9a 83       	std	Y+2, r25	; 0x02
    4fac:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  spiEnableDS1305();
    4fb0:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    4fb4:	89 81       	ldd	r24, Y+1	; 0x01
    4fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb8:	48 2f       	mov	r20, r24
    4fba:	59 2f       	mov	r21, r25
    4fbc:	7a 01       	movw	r14, r20
  uint8_t i;
  
  spiSend(0x00);
    4fbe:	80 e0       	ldi	r24, 0x00	; 0
    4fc0:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  for (i=0; i<sizeof(timeBCD_t); i++)
    4fc4:	10 e0       	ldi	r17, 0x00	; 0
  {
    *ptr = spiSend(i);
    4fc6:	81 2f       	mov	r24, r17
    4fc8:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    4fcc:	f7 01       	movw	r30, r14
    4fce:	81 93       	st	Z+, r24
    4fd0:	7f 01       	movw	r14, r30
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);

  for (i=0; i<sizeof(timeBCD_t); i++)
    4fd2:	1f 5f       	subi	r17, 0xFF	; 255
    4fd4:	17 30       	cpi	r17, 0x07	; 7
    4fd6:	b9 f7       	brne	.-18     	; 0x4fc6 <readTimeBCD+0x30>
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
    4fd8:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    4fdc:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    4fe0:	0f 90       	pop	r0
    4fe2:	0f 90       	pop	r0
    4fe4:	cf 91       	pop	r28
    4fe6:	df 91       	pop	r29
    4fe8:	1f 91       	pop	r17
    4fea:	ff 90       	pop	r15
    4fec:	ef 90       	pop	r14
    4fee:	08 95       	ret

00004ff0 <readTimeDecoded>:

#if USE_DECODED_TIME_STRUCT
void readTimeDecoded(timeDecoded_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4ff0:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <readTimeBCD>
}
    4ff4:	08 95       	ret

00004ff6 <readTime>:
void readTime (time_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4ff6:	0e 94 cb 27 	call	0x4f96	; 0x4f96 <readTimeBCD>
}
    4ffa:	08 95       	ret

00004ffc <setTimeBCD>:
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
{
    4ffc:	ef 92       	push	r14
    4ffe:	ff 92       	push	r15
    5000:	0f 93       	push	r16
    5002:	1f 93       	push	r17
    5004:	df 93       	push	r29
    5006:	cf 93       	push	r28
    5008:	0f 92       	push	r0
    500a:	0f 92       	push	r0
    500c:	cd b7       	in	r28, 0x3d	; 61
    500e:	de b7       	in	r29, 0x3e	; 62
  spiTake();
    5010:	89 83       	std	Y+1, r24	; 0x01
    5012:	9a 83       	std	Y+2, r25	; 0x02
    5014:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  spiEnableDS1305();
    5018:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    501c:	89 81       	ldd	r24, Y+1	; 0x01
    501e:	48 2f       	mov	r20, r24
    5020:	9a 81       	ldd	r25, Y+2	; 0x02
    5022:	59 2f       	mov	r21, r25
    5024:	7a 01       	movw	r14, r20
  uint8_t i;
  spiSend(0x80);
    5026:	80 e8       	ldi	r24, 0x80	; 128
    5028:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  readTimeBCD((timeBCD_t *)(time));
}
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
    502c:	87 01       	movw	r16, r14
    502e:	09 5f       	subi	r16, 0xF9	; 249
    5030:	1f 4f       	sbci	r17, 0xFF	; 255
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    spiSend(*ptr);
    5032:	f7 01       	movw	r30, r14
    5034:	81 91       	ld	r24, Z+
    5036:	7f 01       	movw	r14, r30
    5038:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiEnableDS1305();
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
    503c:	e0 16       	cp	r14, r16
    503e:	f1 06       	cpc	r15, r17
    5040:	c1 f7       	brne	.-16     	; 0x5032 <setTimeBCD+0x36>
  {
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
    5042:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    5046:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    504a:	0f 90       	pop	r0
    504c:	0f 90       	pop	r0
    504e:	cf 91       	pop	r28
    5050:	df 91       	pop	r29
    5052:	1f 91       	pop	r17
    5054:	0f 91       	pop	r16
    5056:	ff 90       	pop	r15
    5058:	ef 90       	pop	r14
    505a:	08 95       	ret

0000505c <setTimeDecoded>:

#if USE_DECODED_TIME_STRUCT
void setTimeDecoded(timeDecoded_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    505c:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <setTimeBCD>
}
    5060:	08 95       	ret

00005062 <setTime>:
void setTime(time_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    5062:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <setTimeBCD>
}
    5066:	08 95       	ret

00005068 <ds1305start>:
#endif /* USE_DECODED_TIME_STRUCT */

void ds1305start(void)
{  
  spiTake();
    5068:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  spiEnableDS1305();
    506c:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>

  spiSend(0x8F);
    5070:	8f e8       	ldi	r24, 0x8F	; 143
    5072:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(0x00);
    5076:	80 e0       	ldi	r24, 0x00	; 0
    5078:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  spiDisableDS1305();  
    507c:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    5080:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>

  return;
}
    5084:	08 95       	ret

00005086 <ds1305writeMem>:


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
    5086:	ef 92       	push	r14
    5088:	ff 92       	push	r15
    508a:	1f 93       	push	r17
    508c:	df 93       	push	r29
    508e:	cf 93       	push	r28
    5090:	0f 92       	push	r0
    5092:	cd b7       	in	r28, 0x3d	; 61
    5094:	de b7       	in	r29, 0x3e	; 62
    5096:	16 2f       	mov	r17, r22
    5098:	7a 01       	movw	r14, r20
  if (addr > 95)
    509a:	80 36       	cpi	r24, 0x60	; 96
    509c:	f8 f4       	brcc	.+62     	; 0x50dc <ds1305writeMem+0x56>
    return 1;
  if (addr + length > 95)
    509e:	28 2f       	mov	r18, r24
    50a0:	30 e0       	ldi	r19, 0x00	; 0
    50a2:	26 0f       	add	r18, r22
    50a4:	31 1d       	adc	r19, r1
    50a6:	20 36       	cpi	r18, 0x60	; 96
    50a8:	31 05       	cpc	r19, r1
    50aa:	d4 f4       	brge	.+52     	; 0x50e0 <ds1305writeMem+0x5a>
    return 2;

  addr += 0xA0;
  
  spiTake();
    50ac:	89 83       	std	Y+1, r24	; 0x01
    50ae:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  spiEnableDS1305();
    50b2:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>

  spiSend(addr);
    50b6:	89 81       	ldd	r24, Y+1	; 0x01
    50b8:	80 56       	subi	r24, 0x60	; 96
    50ba:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  while (length > 0)
    50be:	06 c0       	rjmp	.+12     	; 0x50cc <ds1305writeMem+0x46>
  {
    spiSend(*data);
    50c0:	f7 01       	movw	r30, r14
    50c2:	81 91       	ld	r24, Z+
    50c4:	7f 01       	movw	r14, r30
    50c6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    data++;
    length--;
    50ca:	11 50       	subi	r17, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    50cc:	11 23       	and	r17, r17
    50ce:	c1 f7       	brne	.-16     	; 0x50c0 <ds1305writeMem+0x3a>
    spiSend(*data);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    50d0:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    50d4:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
  return 0;
    50d8:	80 e0       	ldi	r24, 0x00	; 0
    50da:	03 c0       	rjmp	.+6      	; 0x50e2 <ds1305writeMem+0x5c>


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr > 95)
    return 1;
    50dc:	81 e0       	ldi	r24, 0x01	; 1
    50de:	01 c0       	rjmp	.+2      	; 0x50e2 <ds1305writeMem+0x5c>
  if (addr + length > 95)
    return 2;
    50e0:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    50e2:	0f 90       	pop	r0
    50e4:	cf 91       	pop	r28
    50e6:	df 91       	pop	r29
    50e8:	1f 91       	pop	r17
    50ea:	ff 90       	pop	r15
    50ec:	ef 90       	pop	r14
    50ee:	08 95       	ret

000050f0 <ds1305readMem>:
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
    50f0:	ef 92       	push	r14
    50f2:	ff 92       	push	r15
    50f4:	1f 93       	push	r17
    50f6:	df 93       	push	r29
    50f8:	cf 93       	push	r28
    50fa:	0f 92       	push	r0
    50fc:	cd b7       	in	r28, 0x3d	; 61
    50fe:	de b7       	in	r29, 0x3e	; 62
    5100:	16 2f       	mov	r17, r22
    5102:	7a 01       	movw	r14, r20
  if (addr >95)
    5104:	80 36       	cpi	r24, 0x60	; 96
    5106:	00 f5       	brcc	.+64     	; 0x5148 <ds1305readMem+0x58>
    return 1;
  if (addr + length > 95)
    5108:	28 2f       	mov	r18, r24
    510a:	30 e0       	ldi	r19, 0x00	; 0
    510c:	26 0f       	add	r18, r22
    510e:	31 1d       	adc	r19, r1
    5110:	20 36       	cpi	r18, 0x60	; 96
    5112:	31 05       	cpc	r19, r1
    5114:	dc f4       	brge	.+54     	; 0x514c <ds1305readMem+0x5c>
    return 2;
  
  addr += 0x20;
  
  spiTake();
    5116:	89 83       	std	Y+1, r24	; 0x01
    5118:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  spiEnableDS1305();
    511c:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <spiEnableDS1305>

  spiSend(addr);
    5120:	89 81       	ldd	r24, Y+1	; 0x01
    5122:	80 5e       	subi	r24, 0xE0	; 224
    5124:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  while (length > 0)
    5128:	07 c0       	rjmp	.+14     	; 0x5138 <ds1305readMem+0x48>
  {
    *data = spiSend(0);
    512a:	80 e0       	ldi	r24, 0x00	; 0
    512c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    5130:	f7 01       	movw	r30, r14
    5132:	81 93       	st	Z+, r24
    5134:	7f 01       	movw	r14, r30
    data++;
    length--;
    5136:	11 50       	subi	r17, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    5138:	11 23       	and	r17, r17
    513a:	b9 f7       	brne	.-18     	; 0x512a <ds1305readMem+0x3a>
    *data = spiSend(0);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    513c:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <spiDisableDS1305>
  spiGive();
    5140:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
  return 0;
    5144:	80 e0       	ldi	r24, 0x00	; 0
    5146:	03 c0       	rjmp	.+6      	; 0x514e <ds1305readMem+0x5e>
  return 0;
}
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr >95)
    return 1;
    5148:	81 e0       	ldi	r24, 0x01	; 1
    514a:	01 c0       	rjmp	.+2      	; 0x514e <ds1305readMem+0x5e>
  if (addr + length > 95)
    return 2;
    514c:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    514e:	0f 90       	pop	r0
    5150:	cf 91       	pop	r28
    5152:	df 91       	pop	r29
    5154:	1f 91       	pop	r17
    5156:	ff 90       	pop	r15
    5158:	ef 90       	pop	r14
    515a:	08 95       	ret
    515c:	08 95       	ret
    515e:	08 95       	ret

00005160 <MPC23s17SetDirA>:
void enableSpiMPC23S17(void)  {}
void disableSpiMPC23S17(void) {}


void MPC23s17SetDirA(uint8_t portAdir, uint8_t addr)
{
    5160:	1f 93       	push	r17
    5162:	df 93       	push	r29
    5164:	cf 93       	push	r28
    5166:	0f 92       	push	r0
    5168:	cd b7       	in	r28, 0x3d	; 61
    516a:	de b7       	in	r29, 0x3e	; 62
    516c:	18 2f       	mov	r17, r24
  addr = addr<<1;
    516e:	66 0f       	add	r22, r22
  addr &= 0x0E;
    5170:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    5172:	69 83       	std	Y+1, r22	; 0x01
    5174:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17(); 
    5178:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    517c:	69 81       	ldd	r22, Y+1	; 0x01
    517e:	86 2f       	mov	r24, r22
    5180:	80 64       	ori	r24, 0x40	; 64
    5182:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_IODIRA);
    5186:	80 e0       	ldi	r24, 0x00	; 0
    5188:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portAdir);  
    518c:	81 2f       	mov	r24, r17
    518e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMPC23S17();
    5192:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5196:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    519a:	0f 90       	pop	r0
    519c:	cf 91       	pop	r28
    519e:	df 91       	pop	r29
    51a0:	1f 91       	pop	r17
    51a2:	08 95       	ret

000051a4 <MPC23s17SetDirB>:

void MPC23s17SetDirB(uint8_t portBdir, uint8_t addr)
{
    51a4:	1f 93       	push	r17
    51a6:	df 93       	push	r29
    51a8:	cf 93       	push	r28
    51aa:	0f 92       	push	r0
    51ac:	cd b7       	in	r28, 0x3d	; 61
    51ae:	de b7       	in	r29, 0x3e	; 62
    51b0:	18 2f       	mov	r17, r24
  addr = addr<<1;
    51b2:	66 0f       	add	r22, r22
  addr &= 0x0E;
    51b4:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    51b6:	69 83       	std	Y+1, r22	; 0x01
    51b8:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    51bc:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  
  spiSend(addr);
    51c0:	69 81       	ldd	r22, Y+1	; 0x01
    51c2:	86 2f       	mov	r24, r22
    51c4:	80 64       	ori	r24, 0x40	; 64
    51c6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_IODIRB);
    51ca:	81 e0       	ldi	r24, 0x01	; 1
    51cc:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portBdir);  
    51d0:	81 2f       	mov	r24, r17
    51d2:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMPC23S17();
    51d6:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    51da:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    51de:	0f 90       	pop	r0
    51e0:	cf 91       	pop	r28
    51e2:	df 91       	pop	r29
    51e4:	1f 91       	pop	r17
    51e6:	08 95       	ret

000051e8 <MPC23s17SetPortA>:

void MPC23s17SetPortA(uint8_t portAout, uint8_t addr)
{
    51e8:	1f 93       	push	r17
    51ea:	df 93       	push	r29
    51ec:	cf 93       	push	r28
    51ee:	0f 92       	push	r0
    51f0:	cd b7       	in	r28, 0x3d	; 61
    51f2:	de b7       	in	r29, 0x3e	; 62
    51f4:	18 2f       	mov	r17, r24
  addr = addr<<1;
    51f6:	66 0f       	add	r22, r22
  addr &= 0x0E;
    51f8:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    51fa:	69 83       	std	Y+1, r22	; 0x01
    51fc:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    5200:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  portA = portAout;  
    5204:	10 93 26 32 	sts	0x3226, r17
  spiSend(addr);
    5208:	69 81       	ldd	r22, Y+1	; 0x01
    520a:	86 2f       	mov	r24, r22
    520c:	80 64       	ori	r24, 0x40	; 64
    520e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATA);
    5212:	84 e1       	ldi	r24, 0x14	; 20
    5214:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portA);  
    5218:	80 91 26 32 	lds	r24, 0x3226
    521c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    5220:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5224:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    5228:	0f 90       	pop	r0
    522a:	cf 91       	pop	r28
    522c:	df 91       	pop	r29
    522e:	1f 91       	pop	r17
    5230:	08 95       	ret

00005232 <MPC23s17SetBitsOnPortA>:

void MPC23s17SetBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    5232:	df 93       	push	r29
    5234:	cf 93       	push	r28
    5236:	0f 92       	push	r0
    5238:	cd b7       	in	r28, 0x3d	; 61
    523a:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    523c:	66 0f       	add	r22, r22
  addr &= 0x0E;
    523e:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA |= portAout;  
    5240:	90 91 26 32 	lds	r25, 0x3226
    5244:	98 2b       	or	r25, r24
    5246:	90 93 26 32 	sts	0x3226, r25

  spiTake();
    524a:	69 83       	std	Y+1, r22	; 0x01
    524c:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    5250:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    5254:	69 81       	ldd	r22, Y+1	; 0x01
    5256:	86 2f       	mov	r24, r22
    5258:	80 64       	ori	r24, 0x40	; 64
    525a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATA);
    525e:	84 e1       	ldi	r24, 0x14	; 20
    5260:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portA);  
    5264:	80 91 26 32 	lds	r24, 0x3226
    5268:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    526c:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5270:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    5274:	0f 90       	pop	r0
    5276:	cf 91       	pop	r28
    5278:	df 91       	pop	r29
    527a:	08 95       	ret

0000527c <MPC23s17ClearBitsOnPortA>:

void MPC23s17ClearBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    527c:	df 93       	push	r29
    527e:	cf 93       	push	r28
    5280:	0f 92       	push	r0
    5282:	cd b7       	in	r28, 0x3d	; 61
    5284:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5286:	66 0f       	add	r22, r22
  addr &= 0x0E;
    5288:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA &= (~portAout);
    528a:	90 91 26 32 	lds	r25, 0x3226
    528e:	80 95       	com	r24
    5290:	89 23       	and	r24, r25
    5292:	80 93 26 32 	sts	0x3226, r24

  spiTake();
    5296:	69 83       	std	Y+1, r22	; 0x01
    5298:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    529c:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    52a0:	69 81       	ldd	r22, Y+1	; 0x01
    52a2:	86 2f       	mov	r24, r22
    52a4:	80 64       	ori	r24, 0x40	; 64
    52a6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATA);
    52aa:	84 e1       	ldi	r24, 0x14	; 20
    52ac:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portA);  
    52b0:	80 91 26 32 	lds	r24, 0x3226
    52b4:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    52b8:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    52bc:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    52c0:	0f 90       	pop	r0
    52c2:	cf 91       	pop	r28
    52c4:	df 91       	pop	r29
    52c6:	08 95       	ret

000052c8 <MPC23s17SetPortB>:

void MPC23s17SetPortB(uint8_t portBout, uint8_t addr)
{
    52c8:	df 93       	push	r29
    52ca:	cf 93       	push	r28
    52cc:	0f 92       	push	r0
    52ce:	cd b7       	in	r28, 0x3d	; 61
    52d0:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    52d2:	66 0f       	add	r22, r22
  addr &= 0x0E;
    52d4:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB = portBout;
    52d6:	80 93 d9 31 	sts	0x31D9, r24

  spiTake();
    52da:	69 83       	std	Y+1, r22	; 0x01
    52dc:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    52e0:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    52e4:	69 81       	ldd	r22, Y+1	; 0x01
    52e6:	86 2f       	mov	r24, r22
    52e8:	80 64       	ori	r24, 0x40	; 64
    52ea:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATB);
    52ee:	85 e1       	ldi	r24, 0x15	; 21
    52f0:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portB);  
    52f4:	80 91 d9 31 	lds	r24, 0x31D9
    52f8:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    52fc:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5300:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    5304:	0f 90       	pop	r0
    5306:	cf 91       	pop	r28
    5308:	df 91       	pop	r29
    530a:	08 95       	ret

0000530c <MPC23s17SetBitsOnPortB>:

void MPC23s17SetBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    530c:	df 93       	push	r29
    530e:	cf 93       	push	r28
    5310:	0f 92       	push	r0
    5312:	cd b7       	in	r28, 0x3d	; 61
    5314:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5316:	66 0f       	add	r22, r22
  addr &= 0x0E;
    5318:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB |= portBout;
    531a:	90 91 d9 31 	lds	r25, 0x31D9
    531e:	98 2b       	or	r25, r24
    5320:	90 93 d9 31 	sts	0x31D9, r25

  spiTake();
    5324:	69 83       	std	Y+1, r22	; 0x01
    5326:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    532a:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    532e:	69 81       	ldd	r22, Y+1	; 0x01
    5330:	86 2f       	mov	r24, r22
    5332:	80 64       	ori	r24, 0x40	; 64
    5334:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATB);
    5338:	85 e1       	ldi	r24, 0x15	; 21
    533a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portB);  
    533e:	80 91 d9 31 	lds	r24, 0x31D9
    5342:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  disableSpiMPC23S17();
    5346:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    534a:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    534e:	0f 90       	pop	r0
    5350:	cf 91       	pop	r28
    5352:	df 91       	pop	r29
    5354:	08 95       	ret

00005356 <MPC23s17ClearBitsOnPortB>:

void MPC23s17ClearBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5356:	df 93       	push	r29
    5358:	cf 93       	push	r28
    535a:	0f 92       	push	r0
    535c:	cd b7       	in	r28, 0x3d	; 61
    535e:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    5360:	66 0f       	add	r22, r22
  addr &= 0x0E;
    5362:	6e 70       	andi	r22, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB &= (~portBout);
    5364:	90 91 d9 31 	lds	r25, 0x31D9
    5368:	80 95       	com	r24
    536a:	89 23       	and	r24, r25
    536c:	80 93 d9 31 	sts	0x31D9, r24

  spiTake();
    5370:	69 83       	std	Y+1, r22	; 0x01
    5372:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    5376:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>
  spiSend(addr);
    537a:	69 81       	ldd	r22, Y+1	; 0x01
    537c:	86 2f       	mov	r24, r22
    537e:	80 64       	ori	r24, 0x40	; 64
    5380:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_OLATB);
    5384:	85 e1       	ldi	r24, 0x15	; 21
    5386:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(portB);  
    538a:	80 91 d9 31 	lds	r24, 0x31D9
    538e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    5392:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    5396:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    539a:	0f 90       	pop	r0
    539c:	cf 91       	pop	r28
    539e:	df 91       	pop	r29
    53a0:	08 95       	ret

000053a2 <MPC23s17ReadPortA>:

uint8_t MPC23s17ReadPortA(uint8_t addr)
{
    53a2:	1f 93       	push	r17
    53a4:	df 93       	push	r29
    53a6:	cf 93       	push	r28
    53a8:	0f 92       	push	r0
    53aa:	cd b7       	in	r28, 0x3d	; 61
    53ac:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    53ae:	18 2f       	mov	r17, r24
    53b0:	11 0f       	add	r17, r17
  addr &= 0x0E;
    53b2:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    53b4:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    53b6:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    53ba:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>

  spiSend(addr);
    53be:	81 2f       	mov	r24, r17
    53c0:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_GPIOA);
    53c4:	82 e1       	ldi	r24, 0x12	; 18
    53c6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  uint8_t result = spiSend(addr);  
    53ca:	81 2f       	mov	r24, r17
    53cc:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    53d0:	89 83       	std	Y+1, r24	; 0x01
    53d2:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    53d6:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>

  return result; 
}
    53da:	89 81       	ldd	r24, Y+1	; 0x01
    53dc:	0f 90       	pop	r0
    53de:	cf 91       	pop	r28
    53e0:	df 91       	pop	r29
    53e2:	1f 91       	pop	r17
    53e4:	08 95       	ret

000053e6 <MPC23s17ReadPortB>:

uint8_t MPC23s17ReadPortB(uint8_t addr)
{
    53e6:	1f 93       	push	r17
    53e8:	df 93       	push	r29
    53ea:	cf 93       	push	r28
    53ec:	0f 92       	push	r0
    53ee:	cd b7       	in	r28, 0x3d	; 61
    53f0:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    53f2:	18 2f       	mov	r17, r24
    53f4:	11 0f       	add	r17, r17
  addr &= 0x0E;
    53f6:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    53f8:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    53fa:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMPC23S17();
    53fe:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <enableSpiMPC23S17>

  spiSend(addr);
    5402:	81 2f       	mov	r24, r17
    5404:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(B0_GPIOB);
    5408:	83 e1       	ldi	r24, 0x13	; 19
    540a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  uint8_t result = spiSend(addr);  
    540e:	81 2f       	mov	r24, r17
    5410:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>

  disableSpiMPC23S17();
    5414:	89 83       	std	Y+1, r24	; 0x01
    5416:	0e 94 66 0d 	call	0x1acc	; 0x1acc <disableSpiMPC23S17>
  spiGive();
    541a:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>

  return result; 
}
    541e:	89 81       	ldd	r24, Y+1	; 0x01
    5420:	0f 90       	pop	r0
    5422:	cf 91       	pop	r28
    5424:	df 91       	pop	r29
    5426:	1f 91       	pop	r17
    5428:	08 95       	ret
    542a:	08 95       	ret
    542c:	08 95       	ret

0000542e <MCP3008_getSampleDiff>:
void enableSpiMCP3008(void)   {};
void disableSpiMCP3008(void)  {};


uint16_t MCP3008_getSampleDiff(uint8_t inputNo)
{
    542e:	1f 93       	push	r17
    5430:	df 93       	push	r29
    5432:	cf 93       	push	r28
    5434:	0f 92       	push	r0
    5436:	cd b7       	in	r28, 0x3d	; 61
    5438:	de b7       	in	r29, 0x3e	; 62
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    543a:	18 2f       	mov	r17, r24
    543c:	12 95       	swap	r17
    543e:	10 7f       	andi	r17, 0xF0	; 240
  inputNo &= 0x70;
  
  spiTake();
    5440:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMCP3008();
    5444:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <enableSpiMCP3008>
  
  spiSend(0x01);                               //Start
    5448:	81 e0       	ldi	r24, 0x01	; 1
    544a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    544e:	81 2f       	mov	r24, r17
    5450:	80 77       	andi	r24, 0x70	; 112
    5452:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    5456:	18 2f       	mov	r17, r24
  resultLo = spiSend(0);        //X X X X X X X X
    5458:	80 e0       	ldi	r24, 0x00	; 0
    545a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMCP3008(); 
    545e:	89 83       	std	Y+1, r24	; 0x01
    5460:	0e 94 77 0d 	call	0x1aee	; 0x1aee <disableSpiMCP3008>
  spiGive();
    5464:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
    5468:	51 2f       	mov	r21, r17
    546a:	53 70       	andi	r21, 0x03	; 3
    546c:	40 e0       	ldi	r20, 0x00	; 0
    546e:	89 81       	ldd	r24, Y+1	; 0x01
    5470:	28 2f       	mov	r18, r24
    5472:	30 e0       	ldi	r19, 0x00	; 0
    5474:	24 2b       	or	r18, r20
    5476:	35 2b       	or	r19, r21
}
    5478:	c9 01       	movw	r24, r18
    547a:	0f 90       	pop	r0
    547c:	cf 91       	pop	r28
    547e:	df 91       	pop	r29
    5480:	1f 91       	pop	r17
    5482:	08 95       	ret

00005484 <MCP3008_getSampleSingle>:

uint16_t MCP3008_getSampleSingle(uint8_t inputNo)
{
    5484:	1f 93       	push	r17
    5486:	df 93       	push	r29
    5488:	cf 93       	push	r28
    548a:	0f 92       	push	r0
    548c:	cd b7       	in	r28, 0x3d	; 61
    548e:	de b7       	in	r29, 0x3e	; 62
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    5490:	18 2f       	mov	r17, r24
    5492:	12 95       	swap	r17
  inputNo &= 0x70;
    5494:	10 77       	andi	r17, 0x70	; 112
  inputNo |= 0x80;
  
  spiTake();
    5496:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMCP3008();
    549a:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <enableSpiMCP3008>
  
  spiSend(0x01);                //Start
    549e:	81 e0       	ldi	r24, 0x01	; 1
    54a0:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    54a4:	81 2f       	mov	r24, r17
    54a6:	80 68       	ori	r24, 0x80	; 128
    54a8:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
    54ac:	18 2f       	mov	r17, r24
  resultLo = spiSend(0);        //X X X X X X X X
    54ae:	80 e0       	ldi	r24, 0x00	; 0
    54b0:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMCP3008(); 
    54b4:	89 83       	std	Y+1, r24	; 0x01
    54b6:	0e 94 77 0d 	call	0x1aee	; 0x1aee <disableSpiMCP3008>
  spiGive();
    54ba:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
    54be:	51 2f       	mov	r21, r17
    54c0:	53 70       	andi	r21, 0x03	; 3
    54c2:	40 e0       	ldi	r20, 0x00	; 0
    54c4:	89 81       	ldd	r24, Y+1	; 0x01
    54c6:	28 2f       	mov	r18, r24
    54c8:	30 e0       	ldi	r19, 0x00	; 0
    54ca:	24 2b       	or	r18, r20
    54cc:	35 2b       	or	r19, r21
}
    54ce:	c9 01       	movw	r24, r18
    54d0:	0f 90       	pop	r0
    54d2:	cf 91       	pop	r28
    54d4:	df 91       	pop	r29
    54d6:	1f 91       	pop	r17
    54d8:	08 95       	ret
    54da:	08 95       	ret
    54dc:	08 95       	ret

000054de <MCP4150_setValue>:
/**
 * Ustawia wartość rezystancji
 * @param inputNo - WARTOŚĆ OD 0 DO 255.
 */
void MCP4150_setValue(uint8_t value)
{  
    54de:	1f 93       	push	r17
    54e0:	18 2f       	mov	r17, r24
  spiTake();
    54e2:	0e 94 4c 1c 	call	0x3898	; 0x3898 <spiTake>
  enableSpiMCP4150();
    54e6:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <enableSpiMCP4150>
  
  spiSend(0x11);  
    54ea:	81 e1       	ldi	r24, 0x11	; 17
    54ec:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  spiSend(value);
    54f0:	81 2f       	mov	r24, r17
    54f2:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <spiSend>
  
  disableSpiMCP4150(); 
    54f6:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <disableSpiMCP4150>
  spiGive();
    54fa:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <spiGive>
}
    54fe:	1f 91       	pop	r17
    5500:	08 95       	ret
    5502:	08 95       	ret
    5504:	08 95       	ret

00005506 <enc28j60WriteOp>:
 // spiGive();
  return result; 
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
    5506:	df 93       	push	r29
    5508:	cf 93       	push	r28
    550a:	00 d0       	rcall	.+0      	; 0x550c <enc28j60WriteOp+0x6>
    550c:	cd b7       	in	r28, 0x3d	; 61
    550e:	de b7       	in	r29, 0x3e	; 62
 // spiTake();
  spiEnableEnc28j60();
    5510:	4b 83       	std	Y+3, r20	; 0x03
    5512:	6a 83       	std	Y+2, r22	; 0x02
    5514:	89 83       	std	Y+1, r24	; 0x01
    5516:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSendENC(op | (address & ADDR_MASK));
    551a:	6a 81       	ldd	r22, Y+2	; 0x02
    551c:	70 e0       	ldi	r23, 0x00	; 0
    551e:	6f 71       	andi	r22, 0x1F	; 31
    5520:	70 70       	andi	r23, 0x00	; 0
    5522:	89 81       	ldd	r24, Y+1	; 0x01
    5524:	28 2f       	mov	r18, r24
    5526:	30 e0       	ldi	r19, 0x00	; 0
    5528:	cb 01       	movw	r24, r22
    552a:	82 2b       	or	r24, r18
    552c:	93 2b       	or	r25, r19
    552e:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>
  spiSendENC(data);
    5532:	4b 81       	ldd	r20, Y+3	; 0x03
    5534:	84 2f       	mov	r24, r20
    5536:	90 e0       	ldi	r25, 0x00	; 0
    5538:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>
  spiDisableEnc28j60();
    553c:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
 // spiGive();
}
    5540:	23 96       	adiw	r28, 0x03	; 3
    5542:	cd bf       	out	0x3d, r28	; 61
    5544:	de bf       	out	0x3e, r29	; 62
    5546:	cf 91       	pop	r28
    5548:	df 91       	pop	r29
    554a:	08 95       	ret

0000554c <enc28j60SetBank>:
//   spiGive();
// }


void enc28j60SetBank(uint8_t address)
{
    554c:	1f 93       	push	r17
    554e:	cf 93       	push	r28
    5550:	df 93       	push	r29
    5552:	18 2f       	mov	r17, r24
  // set the bank (if needed)
  if((address & BANK_MASK) != Enc28j60Bank)
    5554:	c8 2f       	mov	r28, r24
    5556:	d0 e0       	ldi	r29, 0x00	; 0
    5558:	c0 76       	andi	r28, 0x60	; 96
    555a:	d0 70       	andi	r29, 0x00	; 0
    555c:	20 91 54 25 	lds	r18, 0x2554
    5560:	30 e0       	ldi	r19, 0x00	; 0
    5562:	c2 17       	cp	r28, r18
    5564:	d3 07       	cpc	r29, r19
    5566:	91 f0       	breq	.+36     	; 0x558c <enc28j60SetBank+0x40>
  {
    // set the bank
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    5568:	80 ea       	ldi	r24, 0xA0	; 160
    556a:	6f e1       	ldi	r22, 0x1F	; 31
    556c:	43 e0       	ldi	r20, 0x03	; 3
    556e:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    5572:	ae 01       	movw	r20, r28
    5574:	85 e0       	ldi	r24, 0x05	; 5
    5576:	55 95       	asr	r21
    5578:	47 95       	ror	r20
    557a:	8a 95       	dec	r24
    557c:	e1 f7       	brne	.-8      	; 0x5576 <enc28j60SetBank+0x2a>
    557e:	80 e8       	ldi	r24, 0x80	; 128
    5580:	6f e1       	ldi	r22, 0x1F	; 31
    5582:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    Enc28j60Bank = (address & BANK_MASK);
    5586:	10 76       	andi	r17, 0x60	; 96
    5588:	10 93 54 25 	sts	0x2554, r17
  }
}
    558c:	df 91       	pop	r29
    558e:	cf 91       	pop	r28
    5590:	1f 91       	pop	r17
    5592:	08 95       	ret

00005594 <enc28j60Write>:

  return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    5594:	1f 93       	push	r17
    5596:	df 93       	push	r29
    5598:	cf 93       	push	r28
    559a:	0f 92       	push	r0
    559c:	cd b7       	in	r28, 0x3d	; 61
    559e:	de b7       	in	r29, 0x3e	; 62
    55a0:	18 2f       	mov	r17, r24
  // set the bank
  enc28j60SetBank(address);
    55a2:	69 83       	std	Y+1, r22	; 0x01
    55a4:	0e 94 a6 2a 	call	0x554c	; 0x554c <enc28j60SetBank>
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    55a8:	80 e4       	ldi	r24, 0x40	; 64
    55aa:	61 2f       	mov	r22, r17
    55ac:	49 81       	ldd	r20, Y+1	; 0x01
    55ae:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
}
    55b2:	0f 90       	pop	r0
    55b4:	cf 91       	pop	r28
    55b6:	df 91       	pop	r29
    55b8:	1f 91       	pop	r17
    55ba:	08 95       	ret

000055bc <enc28j60ReadOp>:
    enc28j60PhyWrite    (PHLCON, 0x476);
    vTaskDelay          (2);
}

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
    55bc:	1f 93       	push	r17
    55be:	df 93       	push	r29
    55c0:	cf 93       	push	r28
    55c2:	0f 92       	push	r0
    55c4:	cd b7       	in	r28, 0x3d	; 61
    55c6:	de b7       	in	r29, 0x3e	; 62
    55c8:	16 2f       	mov	r17, r22
  uint8_t result;
  //spiTake();
  spiEnableEnc28j60();
    55ca:	89 83       	std	Y+1, r24	; 0x01
    55cc:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
  
  // issue read command
  spiSendENC(op | (address & ADDR_MASK));
    55d0:	21 2f       	mov	r18, r17
    55d2:	30 e0       	ldi	r19, 0x00	; 0
    55d4:	2f 71       	andi	r18, 0x1F	; 31
    55d6:	30 70       	andi	r19, 0x00	; 0
    55d8:	89 81       	ldd	r24, Y+1	; 0x01
    55da:	90 e0       	ldi	r25, 0x00	; 0
    55dc:	82 2b       	or	r24, r18
    55de:	93 2b       	or	r25, r19
    55e0:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>

  // read data
  result = spiSendENC(0x00);
    55e4:	80 e0       	ldi	r24, 0x00	; 0
    55e6:	90 e0       	ldi	r25, 0x00	; 0
    55e8:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>

  // do dummy read if needed (for mac and mii, see datasheet page 29)
  if(address & 0x80)
    55ec:	17 ff       	sbrs	r17, 7
    55ee:	04 c0       	rjmp	.+8      	; 0x55f8 <enc28j60ReadOp+0x3c>
  {
    result = spiSendENC(0x00);
    55f0:	80 e0       	ldi	r24, 0x00	; 0
    55f2:	90 e0       	ldi	r25, 0x00	; 0
    55f4:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>
  }

  spiDisableEnc28j60();
    55f8:	89 83       	std	Y+1, r24	; 0x01
    55fa:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
 // spiGive();
  return result; 
}
    55fe:	89 81       	ldd	r24, Y+1	; 0x01
    5600:	0f 90       	pop	r0
    5602:	cf 91       	pop	r28
    5604:	df 91       	pop	r29
    5606:	1f 91       	pop	r17
    5608:	08 95       	ret

0000560a <enc28j60Read>:
    Enc28j60Bank = (address & BANK_MASK);
  }
}

uint8_t enc28j60Read(uint8_t address)
{
    560a:	df 93       	push	r29
    560c:	cf 93       	push	r28
    560e:	0f 92       	push	r0
    5610:	cd b7       	in	r28, 0x3d	; 61
    5612:	de b7       	in	r29, 0x3e	; 62
    5614:	68 2f       	mov	r22, r24
  // set the bank
  enc28j60SetBank(address);
    5616:	69 83       	std	Y+1, r22	; 0x01
    5618:	0e 94 a6 2a 	call	0x554c	; 0x554c <enc28j60SetBank>
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    561c:	80 e0       	ldi	r24, 0x00	; 0
    561e:	69 81       	ldd	r22, Y+1	; 0x01
    5620:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
  return result;
}
    5624:	0f 90       	pop	r0
    5626:	cf 91       	pop	r28
    5628:	df 91       	pop	r29
    562a:	08 95       	ret

0000562c <enc28j60hasRxPkt>:
}

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
  if( enc28j60Read(EPKTCNT) ==0 )
    562c:	89 e3       	ldi	r24, 0x39	; 57
    562e:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
  {
    return(0);
    5632:	91 e0       	ldi	r25, 0x01	; 1
    5634:	88 23       	and	r24, r24
    5636:	09 f4       	brne	.+2      	; 0x563a <enc28j60hasRxPkt+0xe>
    5638:	90 e0       	ldi	r25, 0x00	; 0
  }
  return(1);
}
    563a:	89 2f       	mov	r24, r25
    563c:	08 95       	ret

0000563e <enc28j60linkup>:

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
  // Set the right address and start the register read operation
  enc28j60Write(MIREGADR, address);
    563e:	84 ed       	ldi	r24, 0xD4	; 212
    5640:	61 e1       	ldi	r22, 0x11	; 17
    5642:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
  enc28j60Write(MICMD, MICMD_MIIRD);
    5646:	82 ed       	ldi	r24, 0xD2	; 210
    5648:	61 e0       	ldi	r22, 0x01	; 1
    564a:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie
    564e:	80 e0       	ldi	r24, 0x00	; 0
    5650:	90 e0       	ldi	r25, 0x00	; 0
    5652:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
  enc28j60Write(MICMD, MICMD_MIIRD);
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    5656:	8a ee       	ldi	r24, 0xEA	; 234
    5658:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    565c:	80 fd       	sbrc	r24, 0
    565e:	f7 cf       	rjmp	.-18     	; 0x564e <enc28j60linkup+0x10>
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie

  // reset reading bit
  enc28j60Write(MICMD, 0x00);
    5660:	82 ed       	ldi	r24, 0xD2	; 210
    5662:	60 e0       	ldi	r22, 0x00	; 0
    5664:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>

  return (enc28j60Read(MIRDH));
    5668:	89 ed       	ldi	r24, 0xD9	; 217
    566a:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>

// link status
uint8_t enc28j60linkup(void)
{
  // bit 10 (= bit 3 in upper reg)
  return(enc28j60PhyReadH(PHSTAT2) && 4);
    566e:	91 e0       	ldi	r25, 0x01	; 1
    5670:	88 23       	and	r24, r24
    5672:	09 f4       	brne	.+2      	; 0x5676 <enc28j60linkup+0x38>
    5674:	90 e0       	ldi	r25, 0x00	; 0
}
    5676:	89 2f       	mov	r24, r25
    5678:	08 95       	ret

0000567a <enc28j60getrev>:
}

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
  return(enc28j60Read(EREVID));
    567a:	82 e7       	ldi	r24, 0x72	; 114
    567c:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
}
    5680:	08 95       	ret

00005682 <enc28j60PhyWrite>:
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    5682:	1f 93       	push	r17
    5684:	df 93       	push	r29
    5686:	cf 93       	push	r28
    5688:	0f 92       	push	r0
    568a:	cd b7       	in	r28, 0x3d	; 61
    568c:	de b7       	in	r29, 0x3e	; 62
    568e:	98 2f       	mov	r25, r24
    5690:	16 2f       	mov	r17, r22
  // set the PHY register address
  enc28j60Write(MIREGADR, address);
    5692:	84 ed       	ldi	r24, 0xD4	; 212
    5694:	69 2f       	mov	r22, r25
    5696:	79 83       	std	Y+1, r23	; 0x01
    5698:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
  // write the PHY data
  enc28j60Write(MIWRL, data);
    569c:	86 ed       	ldi	r24, 0xD6	; 214
    569e:	61 2f       	mov	r22, r17
    56a0:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
  enc28j60Write(MIWRH, data>>8);
    56a4:	87 ed       	ldi	r24, 0xD7	; 215
    56a6:	79 81       	ldd	r23, Y+1	; 0x01
    56a8:	67 2f       	mov	r22, r23
    56aa:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    56ae:	04 c0       	rjmp	.+8      	; 0x56b8 <enc28j60PhyWrite+0x36>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
    56b0:	80 e0       	ldi	r24, 0x00	; 0
    56b2:	90 e0       	ldi	r25, 0x00	; 0
    56b4:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
  // write the PHY data
  enc28j60Write(MIWRL, data);
  enc28j60Write(MIWRH, data>>8);
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    56b8:	8a ee       	ldi	r24, 0xEA	; 234
    56ba:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    56be:	80 fd       	sbrc	r24, 0
    56c0:	f7 cf       	rjmp	.-18     	; 0x56b0 <enc28j60PhyWrite+0x2e>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
  }
}
    56c2:	0f 90       	pop	r0
    56c4:	cf 91       	pop	r28
    56c6:	df 91       	pop	r29
    56c8:	1f 91       	pop	r17
    56ca:	08 95       	ret

000056cc <nicPoll>:
    56cc:	cf 92       	push	r12
    56ce:	df 92       	push	r13
    56d0:	ef 92       	push	r14
    56d2:	ff 92       	push	r15
    56d4:	0f 93       	push	r16
    56d6:	1f 93       	push	r17
    56d8:	cf 93       	push	r28
    56da:	df 93       	push	r29
    56dc:	89 e3       	ldi	r24, 0x39	; 57
    56de:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    56e2:	88 23       	and	r24, r24
    56e4:	09 f4       	brne	.+2      	; 0x56e8 <nicPoll+0x1c>
    56e6:	9c c0       	rjmp	.+312    	; 0x5820 <nicPoll+0x154>
    56e8:	80 e0       	ldi	r24, 0x00	; 0
    56ea:	60 91 55 25 	lds	r22, 0x2555
    56ee:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    56f2:	60 91 56 25 	lds	r22, 0x2556
    56f6:	81 e0       	ldi	r24, 0x01	; 1
    56f8:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    56fc:	8a e3       	ldi	r24, 0x3A	; 58
    56fe:	60 e0       	ldi	r22, 0x00	; 0
    5700:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
    5704:	c8 2f       	mov	r28, r24
    5706:	d0 e0       	ldi	r29, 0x00	; 0
    5708:	c0 93 55 25 	sts	0x2555, r28
    570c:	d0 93 56 25 	sts	0x2556, r29
    5710:	8a e3       	ldi	r24, 0x3A	; 58
    5712:	60 e0       	ldi	r22, 0x00	; 0
    5714:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
    5718:	38 2f       	mov	r19, r24
    571a:	20 e0       	ldi	r18, 0x00	; 0
    571c:	c2 2b       	or	r28, r18
    571e:	d3 2b       	or	r29, r19
    5720:	c0 93 55 25 	sts	0x2555, r28
    5724:	d0 93 56 25 	sts	0x2556, r29
    5728:	8a e3       	ldi	r24, 0x3A	; 58
    572a:	60 e0       	ldi	r22, 0x00	; 0
    572c:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
    5730:	c8 2e       	mov	r12, r24
    5732:	8a e3       	ldi	r24, 0x3A	; 58
    5734:	60 e0       	ldi	r22, 0x00	; 0
    5736:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
    573a:	e8 2e       	mov	r14, r24
    573c:	8a e3       	ldi	r24, 0x3A	; 58
    573e:	60 e0       	ldi	r22, 0x00	; 0
    5740:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
    5744:	08 2f       	mov	r16, r24
    5746:	10 e0       	ldi	r17, 0x00	; 0
    5748:	8a e3       	ldi	r24, 0x3A	; 58
    574a:	60 e0       	ldi	r22, 0x00	; 0
    574c:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
    5750:	40 91 de 31 	lds	r20, 0x31DE
    5754:	50 91 df 31 	lds	r21, 0x31DF
    5758:	38 2f       	mov	r19, r24
    575a:	20 e0       	ldi	r18, 0x00	; 0
    575c:	02 2b       	or	r16, r18
    575e:	13 2b       	or	r17, r19
    5760:	07 ff       	sbrs	r16, 7
    5762:	2d c0       	rjmp	.+90     	; 0x57be <nicPoll+0xf2>
    5764:	cc 2d       	mov	r28, r12
    5766:	d0 e0       	ldi	r29, 0x00	; 0
    5768:	3e 2d       	mov	r19, r14
    576a:	20 e0       	ldi	r18, 0x00	; 0
    576c:	c2 2b       	or	r28, r18
    576e:	d3 2b       	or	r29, r19
    5770:	41 50       	subi	r20, 0x01	; 1
    5772:	50 40       	sbci	r21, 0x00	; 0
    5774:	24 97       	sbiw	r28, 0x04	; 4
    5776:	4c 17       	cp	r20, r28
    5778:	5d 07       	cpc	r21, r29
    577a:	08 f4       	brcc	.+2      	; 0x577e <nicPoll+0xb2>
    577c:	ea 01       	movw	r28, r20
    577e:	c0 90 e6 31 	lds	r12, 0x31E6
    5782:	d0 90 e7 31 	lds	r13, 0x31E7
    5786:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
    578a:	8a e3       	ldi	r24, 0x3A	; 58
    578c:	90 e0       	ldi	r25, 0x00	; 0
    578e:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>
    5792:	76 01       	movw	r14, r12
    5794:	8e 01       	movw	r16, r28
    5796:	09 c0       	rjmp	.+18     	; 0x57aa <nicPoll+0xde>
    5798:	01 50       	subi	r16, 0x01	; 1
    579a:	10 40       	sbci	r17, 0x00	; 0
    579c:	80 e0       	ldi	r24, 0x00	; 0
    579e:	90 e0       	ldi	r25, 0x00	; 0
    57a0:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>
    57a4:	f7 01       	movw	r30, r14
    57a6:	81 93       	st	Z+, r24
    57a8:	7f 01       	movw	r14, r30
    57aa:	01 15       	cp	r16, r1
    57ac:	11 05       	cpc	r17, r1
    57ae:	a1 f7       	brne	.-24     	; 0x5798 <nicPoll+0xcc>
    57b0:	f6 01       	movw	r30, r12
    57b2:	ec 0f       	add	r30, r28
    57b4:	fd 1f       	adc	r31, r29
    57b6:	10 82       	st	Z, r1
    57b8:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
    57bc:	02 c0       	rjmp	.+4      	; 0x57c2 <nicPoll+0xf6>
    57be:	c0 e0       	ldi	r28, 0x00	; 0
    57c0:	d0 e0       	ldi	r29, 0x00	; 0
    57c2:	8c e0       	ldi	r24, 0x0C	; 12
    57c4:	60 91 55 25 	lds	r22, 0x2555
    57c8:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    57cc:	60 91 56 25 	lds	r22, 0x2556
    57d0:	8d e0       	ldi	r24, 0x0D	; 13
    57d2:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    57d6:	60 91 55 25 	lds	r22, 0x2555
    57da:	70 91 56 25 	lds	r23, 0x2556
    57de:	cb 01       	movw	r24, r22
    57e0:	01 97       	sbiw	r24, 0x01	; 1
    57e2:	f9 e1       	ldi	r31, 0x19	; 25
    57e4:	8f 3f       	cpi	r24, 0xFF	; 255
    57e6:	9f 07       	cpc	r25, r31
    57e8:	38 f0       	brcs	.+14     	; 0x57f8 <nicPoll+0x12c>
    57ea:	8c e0       	ldi	r24, 0x0C	; 12
    57ec:	6e ef       	ldi	r22, 0xFE	; 254
    57ee:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    57f2:	8d e0       	ldi	r24, 0x0D	; 13
    57f4:	69 e1       	ldi	r22, 0x19	; 25
    57f6:	0c c0       	rjmp	.+24     	; 0x5810 <nicPoll+0x144>
    57f8:	61 50       	subi	r22, 0x01	; 1
    57fa:	8c e0       	ldi	r24, 0x0C	; 12
    57fc:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5800:	20 91 55 25 	lds	r18, 0x2555
    5804:	30 91 56 25 	lds	r19, 0x2556
    5808:	21 50       	subi	r18, 0x01	; 1
    580a:	30 40       	sbci	r19, 0x00	; 0
    580c:	8d e0       	ldi	r24, 0x0D	; 13
    580e:	63 2f       	mov	r22, r19
    5810:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5814:	80 e8       	ldi	r24, 0x80	; 128
    5816:	6e e1       	ldi	r22, 0x1E	; 30
    5818:	40 e4       	ldi	r20, 0x40	; 64
    581a:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    581e:	02 c0       	rjmp	.+4      	; 0x5824 <nicPoll+0x158>
    5820:	c0 e0       	ldi	r28, 0x00	; 0
    5822:	d0 e0       	ldi	r29, 0x00	; 0
    5824:	ce 01       	movw	r24, r28
    5826:	df 91       	pop	r29
    5828:	cf 91       	pop	r28
    582a:	1f 91       	pop	r17
    582c:	0f 91       	pop	r16
    582e:	ff 90       	pop	r15
    5830:	ef 90       	pop	r14
    5832:	df 90       	pop	r13
    5834:	cf 90       	pop	r12
    5836:	08 95       	ret

00005838 <nicSend>:
    5838:	0f 93       	push	r16
    583a:	1f 93       	push	r17
    583c:	cf 93       	push	r28
    583e:	df 93       	push	r29
    5840:	ec 01       	movw	r28, r24
    5842:	13 c0       	rjmp	.+38     	; 0x586a <nicSend+0x32>
    5844:	8c e1       	ldi	r24, 0x1C	; 28
    5846:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    584a:	81 ff       	sbrs	r24, 1
    584c:	0a c0       	rjmp	.+20     	; 0x5862 <nicSend+0x2a>
    584e:	80 e8       	ldi	r24, 0x80	; 128
    5850:	6f e1       	ldi	r22, 0x1F	; 31
    5852:	40 e8       	ldi	r20, 0x80	; 128
    5854:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    5858:	80 ea       	ldi	r24, 0xA0	; 160
    585a:	6f e1       	ldi	r22, 0x1F	; 31
    585c:	40 e8       	ldi	r20, 0x80	; 128
    585e:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    5862:	80 e0       	ldi	r24, 0x00	; 0
    5864:	90 e0       	ldi	r25, 0x00	; 0
    5866:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    586a:	80 e0       	ldi	r24, 0x00	; 0
    586c:	6f e1       	ldi	r22, 0x1F	; 31
    586e:	0e 94 de 2a 	call	0x55bc	; 0x55bc <enc28j60ReadOp>
    5872:	83 fd       	sbrc	r24, 3
    5874:	e7 cf       	rjmp	.-50     	; 0x5844 <nicSend+0xc>
    5876:	82 e0       	ldi	r24, 0x02	; 2
    5878:	6f ef       	ldi	r22, 0xFF	; 255
    587a:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    587e:	83 e0       	ldi	r24, 0x03	; 3
    5880:	69 e1       	ldi	r22, 0x19	; 25
    5882:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5886:	ce 01       	movw	r24, r28
    5888:	81 50       	subi	r24, 0x01	; 1
    588a:	68 2f       	mov	r22, r24
    588c:	86 e0       	ldi	r24, 0x06	; 6
    588e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5892:	9e 01       	movw	r18, r28
    5894:	21 50       	subi	r18, 0x01	; 1
    5896:	36 4e       	sbci	r19, 0xE6	; 230
    5898:	87 e0       	ldi	r24, 0x07	; 7
    589a:	63 2f       	mov	r22, r19
    589c:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    58a0:	8a e7       	ldi	r24, 0x7A	; 122
    58a2:	60 e0       	ldi	r22, 0x00	; 0
    58a4:	40 e0       	ldi	r20, 0x00	; 0
    58a6:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    58aa:	00 91 e6 31 	lds	r16, 0x31E6
    58ae:	10 91 e7 31 	lds	r17, 0x31E7
    58b2:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <spiEnableEnc28j60>
    58b6:	8a e7       	ldi	r24, 0x7A	; 122
    58b8:	90 e0       	ldi	r25, 0x00	; 0
    58ba:	05 c0       	rjmp	.+10     	; 0x58c6 <nicSend+0x8e>
    58bc:	21 97       	sbiw	r28, 0x01	; 1
    58be:	f8 01       	movw	r30, r16
    58c0:	81 91       	ld	r24, Z+
    58c2:	8f 01       	movw	r16, r30
    58c4:	90 e0       	ldi	r25, 0x00	; 0
    58c6:	0e 94 ef 0c 	call	0x19de	; 0x19de <spiSendENC>
    58ca:	20 97       	sbiw	r28, 0x00	; 0
    58cc:	b9 f7       	brne	.-18     	; 0x58bc <nicSend+0x84>
    58ce:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <spiDisableEnc28j60>
    58d2:	80 e8       	ldi	r24, 0x80	; 128
    58d4:	6f e1       	ldi	r22, 0x1F	; 31
    58d6:	48 e0       	ldi	r20, 0x08	; 8
    58d8:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    58dc:	df 91       	pop	r29
    58de:	cf 91       	pop	r28
    58e0:	1f 91       	pop	r17
    58e2:	0f 91       	pop	r16
    58e4:	08 95       	ret

000058e6 <nicSetMacAddress>:
    58e6:	cf 93       	push	r28
    58e8:	df 93       	push	r29
    58ea:	ec 01       	movw	r28, r24
    58ec:	84 ee       	ldi	r24, 0xE4	; 228
    58ee:	68 81       	ld	r22, Y
    58f0:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    58f4:	85 ee       	ldi	r24, 0xE5	; 229
    58f6:	69 81       	ldd	r22, Y+1	; 0x01
    58f8:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    58fc:	82 ee       	ldi	r24, 0xE2	; 226
    58fe:	6a 81       	ldd	r22, Y+2	; 0x02
    5900:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5904:	83 ee       	ldi	r24, 0xE3	; 227
    5906:	6b 81       	ldd	r22, Y+3	; 0x03
    5908:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    590c:	80 ee       	ldi	r24, 0xE0	; 224
    590e:	6c 81       	ldd	r22, Y+4	; 0x04
    5910:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5914:	81 ee       	ldi	r24, 0xE1	; 225
    5916:	6d 81       	ldd	r22, Y+5	; 0x05
    5918:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    591c:	df 91       	pop	r29
    591e:	cf 91       	pop	r28
    5920:	08 95       	ret

00005922 <nicMacInit>:
    5922:	85 e0       	ldi	r24, 0x05	; 5
    5924:	90 e0       	ldi	r25, 0x00	; 0
    5926:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    592a:	85 e0       	ldi	r24, 0x05	; 5
    592c:	90 e0       	ldi	r25, 0x00	; 0
    592e:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    5932:	85 e0       	ldi	r24, 0x05	; 5
    5934:	90 e0       	ldi	r25, 0x00	; 0
    5936:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    593a:	10 92 55 25 	sts	0x2555, r1
    593e:	10 92 56 25 	sts	0x2556, r1
    5942:	88 e0       	ldi	r24, 0x08	; 8
    5944:	60 e0       	ldi	r22, 0x00	; 0
    5946:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    594a:	89 e0       	ldi	r24, 0x09	; 9
    594c:	60 e0       	ldi	r22, 0x00	; 0
    594e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5952:	8c e0       	ldi	r24, 0x0C	; 12
    5954:	60 e0       	ldi	r22, 0x00	; 0
    5956:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    595a:	8d e0       	ldi	r24, 0x0D	; 13
    595c:	60 e0       	ldi	r22, 0x00	; 0
    595e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5962:	8a e0       	ldi	r24, 0x0A	; 10
    5964:	6e ef       	ldi	r22, 0xFE	; 254
    5966:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    596a:	8b e0       	ldi	r24, 0x0B	; 11
    596c:	69 e1       	ldi	r22, 0x19	; 25
    596e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5972:	84 e0       	ldi	r24, 0x04	; 4
    5974:	6f ef       	ldi	r22, 0xFF	; 255
    5976:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    597a:	85 e0       	ldi	r24, 0x05	; 5
    597c:	69 e1       	ldi	r22, 0x19	; 25
    597e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5982:	86 e0       	ldi	r24, 0x06	; 6
    5984:	6f ef       	ldi	r22, 0xFF	; 255
    5986:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    598a:	87 e0       	ldi	r24, 0x07	; 7
    598c:	6f e1       	ldi	r22, 0x1F	; 31
    598e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    5992:	88 e3       	ldi	r24, 0x38	; 56
    5994:	62 eb       	ldi	r22, 0xB2	; 178
    5996:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    599a:	88 e2       	ldi	r24, 0x28	; 40
    599c:	6f e3       	ldi	r22, 0x3F	; 63
    599e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59a2:	89 e2       	ldi	r24, 0x29	; 41
    59a4:	60 e3       	ldi	r22, 0x30	; 48
    59a6:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59aa:	80 e3       	ldi	r24, 0x30	; 48
    59ac:	69 ef       	ldi	r22, 0xF9	; 249
    59ae:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59b2:	81 e3       	ldi	r24, 0x31	; 49
    59b4:	67 ef       	ldi	r22, 0xF7	; 247
    59b6:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59ba:	80 ec       	ldi	r24, 0xC0	; 192
    59bc:	6d e0       	ldi	r22, 0x0D	; 13
    59be:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59c2:	81 ec       	ldi	r24, 0xC1	; 193
    59c4:	60 e0       	ldi	r22, 0x00	; 0
    59c6:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59ca:	80 e8       	ldi	r24, 0x80	; 128
    59cc:	62 ec       	ldi	r22, 0xC2	; 194
    59ce:	42 e3       	ldi	r20, 0x32	; 50
    59d0:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    59d4:	86 ec       	ldi	r24, 0xC6	; 198
    59d6:	62 e1       	ldi	r22, 0x12	; 18
    59d8:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59dc:	87 ec       	ldi	r24, 0xC7	; 199
    59de:	6c e0       	ldi	r22, 0x0C	; 12
    59e0:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59e4:	84 ec       	ldi	r24, 0xC4	; 196
    59e6:	62 e1       	ldi	r22, 0x12	; 18
    59e8:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59ec:	8a ec       	ldi	r24, 0xCA	; 202
    59ee:	6c ed       	ldi	r22, 0xDC	; 220
    59f0:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59f4:	8b ec       	ldi	r24, 0xCB	; 203
    59f6:	65 e0       	ldi	r22, 0x05	; 5
    59f8:	0e 94 ca 2a 	call	0x5594	; 0x5594 <enc28j60Write>
    59fc:	80 ee       	ldi	r24, 0xE0	; 224
    59fe:	91 e3       	ldi	r25, 0x31	; 49
    5a00:	0e 94 73 2c 	call	0x58e6	; 0x58e6 <nicSetMacAddress>
    5a04:	80 e1       	ldi	r24, 0x10	; 16
    5a06:	60 e0       	ldi	r22, 0x00	; 0
    5a08:	71 e0       	ldi	r23, 0x01	; 1
    5a0a:	0e 94 41 2b 	call	0x5682	; 0x5682 <enc28j60PhyWrite>
    5a0e:	8f e1       	ldi	r24, 0x1F	; 31
    5a10:	0e 94 a6 2a 	call	0x554c	; 0x554c <enc28j60SetBank>
    5a14:	80 e8       	ldi	r24, 0x80	; 128
    5a16:	6b e1       	ldi	r22, 0x1B	; 27
    5a18:	40 ec       	ldi	r20, 0xC0	; 192
    5a1a:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    5a1e:	80 e8       	ldi	r24, 0x80	; 128
    5a20:	6f e1       	ldi	r22, 0x1F	; 31
    5a22:	44 e0       	ldi	r20, 0x04	; 4
    5a24:	0e 94 83 2a 	call	0x5506	; 0x5506 <enc28j60WriteOp>
    5a28:	85 e0       	ldi	r24, 0x05	; 5
    5a2a:	90 e0       	ldi	r25, 0x00	; 0
    5a2c:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    5a30:	84 e1       	ldi	r24, 0x14	; 20
    5a32:	66 e7       	ldi	r22, 0x76	; 118
    5a34:	74 e0       	ldi	r23, 0x04	; 4
    5a36:	0e 94 41 2b 	call	0x5682	; 0x5682 <enc28j60PhyWrite>
    5a3a:	82 e0       	ldi	r24, 0x02	; 2
    5a3c:	90 e0       	ldi	r25, 0x00	; 0
    5a3e:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
    5a42:	08 95       	ret

00005a44 <nicGetMacAddress>:
    5a44:	cf 93       	push	r28
    5a46:	df 93       	push	r29
    5a48:	ec 01       	movw	r28, r24
    5a4a:	81 ee       	ldi	r24, 0xE1	; 225
    5a4c:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5a50:	8d 83       	std	Y+5, r24	; 0x05
    5a52:	80 ee       	ldi	r24, 0xE0	; 224
    5a54:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5a58:	8c 83       	std	Y+4, r24	; 0x04
    5a5a:	83 ee       	ldi	r24, 0xE3	; 227
    5a5c:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5a60:	8b 83       	std	Y+3, r24	; 0x03
    5a62:	82 ee       	ldi	r24, 0xE2	; 226
    5a64:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5a68:	8a 83       	std	Y+2, r24	; 0x02
    5a6a:	85 ee       	ldi	r24, 0xE5	; 229
    5a6c:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5a70:	89 83       	std	Y+1, r24	; 0x01
    5a72:	84 ee       	ldi	r24, 0xE4	; 228
    5a74:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5a78:	88 83       	st	Y, r24
    5a7a:	df 91       	pop	r29
    5a7c:	cf 91       	pop	r28
    5a7e:	08 95       	ret

00005a80 <nicRegDump>:
    5a80:	cf 93       	push	r28
    5a82:	df 93       	push	r29
    5a84:	ec 01       	movw	r28, r24
    5a86:	00 d0       	rcall	.+0      	; 0x5a88 <nicRegDump+0x8>
    5a88:	0f 92       	push	r0
    5a8a:	ad b7       	in	r26, 0x3d	; 61
    5a8c:	be b7       	in	r27, 0x3e	; 62
    5a8e:	11 96       	adiw	r26, 0x01	; 1
    5a90:	8d 93       	st	X+, r24
    5a92:	9c 93       	st	X, r25
    5a94:	12 97       	sbiw	r26, 0x02	; 2
    5a96:	85 ec       	ldi	r24, 0xC5	; 197
    5a98:	98 e0       	ldi	r25, 0x08	; 8
    5a9a:	13 96       	adiw	r26, 0x03	; 3
    5a9c:	8d 93       	st	X+, r24
    5a9e:	9c 93       	st	X, r25
    5aa0:	14 97       	sbiw	r26, 0x04	; 4
    5aa2:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5aa6:	0f 90       	pop	r0
    5aa8:	0f 90       	pop	r0
    5aaa:	0f 90       	pop	r0
    5aac:	0f 90       	pop	r0
    5aae:	81 ee       	ldi	r24, 0xE1	; 225
    5ab0:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5ab4:	00 d0       	rcall	.+0      	; 0x5ab6 <nicRegDump+0x36>
    5ab6:	00 d0       	rcall	.+0      	; 0x5ab8 <nicRegDump+0x38>
    5ab8:	ed b7       	in	r30, 0x3d	; 61
    5aba:	fe b7       	in	r31, 0x3e	; 62
    5abc:	31 96       	adiw	r30, 0x01	; 1
    5abe:	ad b7       	in	r26, 0x3d	; 61
    5ac0:	be b7       	in	r27, 0x3e	; 62
    5ac2:	11 96       	adiw	r26, 0x01	; 1
    5ac4:	cd 93       	st	X+, r28
    5ac6:	dc 93       	st	X, r29
    5ac8:	12 97       	sbiw	r26, 0x02	; 2
    5aca:	26 eb       	ldi	r18, 0xB6	; 182
    5acc:	38 e0       	ldi	r19, 0x08	; 8
    5ace:	22 83       	std	Z+2, r18	; 0x02
    5ad0:	33 83       	std	Z+3, r19	; 0x03
    5ad2:	84 83       	std	Z+4, r24	; 0x04
    5ad4:	15 82       	std	Z+5, r1	; 0x05
    5ad6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5ada:	ed b7       	in	r30, 0x3d	; 61
    5adc:	fe b7       	in	r31, 0x3e	; 62
    5ade:	36 96       	adiw	r30, 0x06	; 6
    5ae0:	ed bf       	out	0x3d, r30	; 61
    5ae2:	fe bf       	out	0x3e, r31	; 62
    5ae4:	80 ee       	ldi	r24, 0xE0	; 224
    5ae6:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5aea:	00 d0       	rcall	.+0      	; 0x5aec <nicRegDump+0x6c>
    5aec:	00 d0       	rcall	.+0      	; 0x5aee <nicRegDump+0x6e>
    5aee:	ed b7       	in	r30, 0x3d	; 61
    5af0:	fe b7       	in	r31, 0x3e	; 62
    5af2:	31 96       	adiw	r30, 0x01	; 1
    5af4:	ad b7       	in	r26, 0x3d	; 61
    5af6:	be b7       	in	r27, 0x3e	; 62
    5af8:	11 96       	adiw	r26, 0x01	; 1
    5afa:	cd 93       	st	X+, r28
    5afc:	dc 93       	st	X, r29
    5afe:	12 97       	sbiw	r26, 0x02	; 2
    5b00:	27 ea       	ldi	r18, 0xA7	; 167
    5b02:	38 e0       	ldi	r19, 0x08	; 8
    5b04:	22 83       	std	Z+2, r18	; 0x02
    5b06:	33 83       	std	Z+3, r19	; 0x03
    5b08:	84 83       	std	Z+4, r24	; 0x04
    5b0a:	15 82       	std	Z+5, r1	; 0x05
    5b0c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5b10:	ed b7       	in	r30, 0x3d	; 61
    5b12:	fe b7       	in	r31, 0x3e	; 62
    5b14:	36 96       	adiw	r30, 0x06	; 6
    5b16:	ed bf       	out	0x3d, r30	; 61
    5b18:	fe bf       	out	0x3e, r31	; 62
    5b1a:	83 ee       	ldi	r24, 0xE3	; 227
    5b1c:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5b20:	00 d0       	rcall	.+0      	; 0x5b22 <nicRegDump+0xa2>
    5b22:	00 d0       	rcall	.+0      	; 0x5b24 <nicRegDump+0xa4>
    5b24:	ed b7       	in	r30, 0x3d	; 61
    5b26:	fe b7       	in	r31, 0x3e	; 62
    5b28:	31 96       	adiw	r30, 0x01	; 1
    5b2a:	ad b7       	in	r26, 0x3d	; 61
    5b2c:	be b7       	in	r27, 0x3e	; 62
    5b2e:	11 96       	adiw	r26, 0x01	; 1
    5b30:	cd 93       	st	X+, r28
    5b32:	dc 93       	st	X, r29
    5b34:	12 97       	sbiw	r26, 0x02	; 2
    5b36:	28 e9       	ldi	r18, 0x98	; 152
    5b38:	38 e0       	ldi	r19, 0x08	; 8
    5b3a:	22 83       	std	Z+2, r18	; 0x02
    5b3c:	33 83       	std	Z+3, r19	; 0x03
    5b3e:	84 83       	std	Z+4, r24	; 0x04
    5b40:	15 82       	std	Z+5, r1	; 0x05
    5b42:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5b46:	ed b7       	in	r30, 0x3d	; 61
    5b48:	fe b7       	in	r31, 0x3e	; 62
    5b4a:	36 96       	adiw	r30, 0x06	; 6
    5b4c:	ed bf       	out	0x3d, r30	; 61
    5b4e:	fe bf       	out	0x3e, r31	; 62
    5b50:	82 ee       	ldi	r24, 0xE2	; 226
    5b52:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5b56:	00 d0       	rcall	.+0      	; 0x5b58 <nicRegDump+0xd8>
    5b58:	00 d0       	rcall	.+0      	; 0x5b5a <nicRegDump+0xda>
    5b5a:	ed b7       	in	r30, 0x3d	; 61
    5b5c:	fe b7       	in	r31, 0x3e	; 62
    5b5e:	31 96       	adiw	r30, 0x01	; 1
    5b60:	ad b7       	in	r26, 0x3d	; 61
    5b62:	be b7       	in	r27, 0x3e	; 62
    5b64:	11 96       	adiw	r26, 0x01	; 1
    5b66:	cd 93       	st	X+, r28
    5b68:	dc 93       	st	X, r29
    5b6a:	12 97       	sbiw	r26, 0x02	; 2
    5b6c:	29 e8       	ldi	r18, 0x89	; 137
    5b6e:	38 e0       	ldi	r19, 0x08	; 8
    5b70:	22 83       	std	Z+2, r18	; 0x02
    5b72:	33 83       	std	Z+3, r19	; 0x03
    5b74:	84 83       	std	Z+4, r24	; 0x04
    5b76:	15 82       	std	Z+5, r1	; 0x05
    5b78:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5b7c:	ed b7       	in	r30, 0x3d	; 61
    5b7e:	fe b7       	in	r31, 0x3e	; 62
    5b80:	36 96       	adiw	r30, 0x06	; 6
    5b82:	ed bf       	out	0x3d, r30	; 61
    5b84:	fe bf       	out	0x3e, r31	; 62
    5b86:	85 ee       	ldi	r24, 0xE5	; 229
    5b88:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5b8c:	00 d0       	rcall	.+0      	; 0x5b8e <nicRegDump+0x10e>
    5b8e:	00 d0       	rcall	.+0      	; 0x5b90 <nicRegDump+0x110>
    5b90:	ed b7       	in	r30, 0x3d	; 61
    5b92:	fe b7       	in	r31, 0x3e	; 62
    5b94:	31 96       	adiw	r30, 0x01	; 1
    5b96:	ad b7       	in	r26, 0x3d	; 61
    5b98:	be b7       	in	r27, 0x3e	; 62
    5b9a:	11 96       	adiw	r26, 0x01	; 1
    5b9c:	cd 93       	st	X+, r28
    5b9e:	dc 93       	st	X, r29
    5ba0:	12 97       	sbiw	r26, 0x02	; 2
    5ba2:	2a e7       	ldi	r18, 0x7A	; 122
    5ba4:	38 e0       	ldi	r19, 0x08	; 8
    5ba6:	22 83       	std	Z+2, r18	; 0x02
    5ba8:	33 83       	std	Z+3, r19	; 0x03
    5baa:	84 83       	std	Z+4, r24	; 0x04
    5bac:	15 82       	std	Z+5, r1	; 0x05
    5bae:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5bb2:	ed b7       	in	r30, 0x3d	; 61
    5bb4:	fe b7       	in	r31, 0x3e	; 62
    5bb6:	36 96       	adiw	r30, 0x06	; 6
    5bb8:	ed bf       	out	0x3d, r30	; 61
    5bba:	fe bf       	out	0x3e, r31	; 62
    5bbc:	84 ee       	ldi	r24, 0xE4	; 228
    5bbe:	0e 94 05 2b 	call	0x560a	; 0x560a <enc28j60Read>
    5bc2:	00 d0       	rcall	.+0      	; 0x5bc4 <nicRegDump+0x144>
    5bc4:	00 d0       	rcall	.+0      	; 0x5bc6 <nicRegDump+0x146>
    5bc6:	ed b7       	in	r30, 0x3d	; 61
    5bc8:	fe b7       	in	r31, 0x3e	; 62
    5bca:	31 96       	adiw	r30, 0x01	; 1
    5bcc:	ad b7       	in	r26, 0x3d	; 61
    5bce:	be b7       	in	r27, 0x3e	; 62
    5bd0:	11 96       	adiw	r26, 0x01	; 1
    5bd2:	cd 93       	st	X+, r28
    5bd4:	dc 93       	st	X, r29
    5bd6:	12 97       	sbiw	r26, 0x02	; 2
    5bd8:	2b e6       	ldi	r18, 0x6B	; 107
    5bda:	38 e0       	ldi	r19, 0x08	; 8
    5bdc:	22 83       	std	Z+2, r18	; 0x02
    5bde:	33 83       	std	Z+3, r19	; 0x03
    5be0:	84 83       	std	Z+4, r24	; 0x04
    5be2:	15 82       	std	Z+5, r1	; 0x05
    5be4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5be8:	ed b7       	in	r30, 0x3d	; 61
    5bea:	fe b7       	in	r31, 0x3e	; 62
    5bec:	36 96       	adiw	r30, 0x06	; 6
    5bee:	ed bf       	out	0x3d, r30	; 61
    5bf0:	fe bf       	out	0x3e, r31	; 62
    5bf2:	df 91       	pop	r29
    5bf4:	cf 91       	pop	r28
    5bf6:	08 95       	ret

00005bf8 <streamQueueInputFun>:
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
  return 0;
}

static int streamQueueInputFun(FILE *istream)
{
    5bf8:	df 93       	push	r29
    5bfa:	cf 93       	push	r28
    5bfc:	0f 92       	push	r0
    5bfe:	cd b7       	in	r28, 0x3d	; 61
    5c00:	de b7       	in	r29, 0x3e	; 62
  char c;
  streamBuffers_t *strBuf = (streamBuffers_t *) istream->udata;
  xQueueReceive(strBuf->Rx, &c, portMAX_DELAY);
    5c02:	dc 01       	movw	r26, r24
    5c04:	1c 96       	adiw	r26, 0x0c	; 12
    5c06:	ed 91       	ld	r30, X+
    5c08:	fc 91       	ld	r31, X
    5c0a:	1d 97       	sbiw	r26, 0x0d	; 13
    5c0c:	80 81       	ld	r24, Z
    5c0e:	91 81       	ldd	r25, Z+1	; 0x01
    5c10:	be 01       	movw	r22, r28
    5c12:	6f 5f       	subi	r22, 0xFF	; 255
    5c14:	7f 4f       	sbci	r23, 0xFF	; 255
    5c16:	4f ef       	ldi	r20, 0xFF	; 255
    5c18:	5f ef       	ldi	r21, 0xFF	; 255
    5c1a:	20 e0       	ldi	r18, 0x00	; 0
    5c1c:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
  return c;
    5c20:	89 81       	ldd	r24, Y+1	; 0x01
    5c22:	28 2f       	mov	r18, r24
    5c24:	33 27       	eor	r19, r19
    5c26:	27 fd       	sbrc	r18, 7
    5c28:	30 95       	com	r19
}
    5c2a:	93 2f       	mov	r25, r19
    5c2c:	0f 90       	pop	r0
    5c2e:	cf 91       	pop	r28
    5c30:	df 91       	pop	r29
    5c32:	08 95       	ret

00005c34 <streamQueueOutputFun>:
  buffer->Tx = Tx;
  return;
}

static int streamQueueOutputFun(char c, FILE *ostream)
{
    5c34:	df 93       	push	r29
    5c36:	cf 93       	push	r28
    5c38:	0f 92       	push	r0
    5c3a:	cd b7       	in	r28, 0x3d	; 61
    5c3c:	de b7       	in	r29, 0x3e	; 62
    5c3e:	89 83       	std	Y+1, r24	; 0x01
/*  if (xQueueSend( strBuf->Tx, &c, strBuf->tx_timeout))
  {
    return EOF;
  }
  else*/
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
    5c40:	db 01       	movw	r26, r22
    5c42:	1c 96       	adiw	r26, 0x0c	; 12
    5c44:	ed 91       	ld	r30, X+
    5c46:	fc 91       	ld	r31, X
    5c48:	1d 97       	sbiw	r26, 0x0d	; 13
    5c4a:	82 81       	ldd	r24, Z+2	; 0x02
    5c4c:	93 81       	ldd	r25, Z+3	; 0x03
    5c4e:	be 01       	movw	r22, r28
    5c50:	6f 5f       	subi	r22, 0xFF	; 255
    5c52:	7f 4f       	sbci	r23, 0xFF	; 255
    5c54:	4f ef       	ldi	r20, 0xFF	; 255
    5c56:	5f ef       	ldi	r21, 0xFF	; 255
    5c58:	20 e0       	ldi	r18, 0x00	; 0
    5c5a:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>
  return 0;
}
    5c5e:	80 e0       	ldi	r24, 0x00	; 0
    5c60:	90 e0       	ldi	r25, 0x00	; 0
    5c62:	0f 90       	pop	r0
    5c64:	cf 91       	pop	r28
    5c66:	df 91       	pop	r29
    5c68:	08 95       	ret

00005c6a <initQueueStream>:

static int streamQueueOutputFun(char c, FILE *ostream);
static int streamQueueInputFun(FILE *istream);

void initQueueStream(FILE *stream, streamBuffers_t *buffer, xQueueHandle Rx, xQueueHandle Tx)
{
    5c6a:	fc 01       	movw	r30, r24
    5c6c:	db 01       	movw	r26, r22
  fdev_setup_stream(stream, streamQueueOutputFun, streamQueueInputFun, _FDEV_SETUP_RW);
    5c6e:	8a e1       	ldi	r24, 0x1A	; 26
    5c70:	9e e2       	ldi	r25, 0x2E	; 46
    5c72:	80 87       	std	Z+8, r24	; 0x08
    5c74:	91 87       	std	Z+9, r25	; 0x09
    5c76:	8c ef       	ldi	r24, 0xFC	; 252
    5c78:	9d e2       	ldi	r25, 0x2D	; 45
    5c7a:	82 87       	std	Z+10, r24	; 0x0a
    5c7c:	93 87       	std	Z+11, r25	; 0x0b
    5c7e:	83 e0       	ldi	r24, 0x03	; 3
    5c80:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, (void *)buffer);
    5c82:	64 87       	std	Z+12, r22	; 0x0c
    5c84:	75 87       	std	Z+13, r23	; 0x0d
  buffer->Rx = Rx;
    5c86:	4d 93       	st	X+, r20
    5c88:	5c 93       	st	X, r21
    5c8a:	11 97       	sbiw	r26, 0x01	; 1
  buffer->Tx = Tx;
    5c8c:	12 96       	adiw	r26, 0x02	; 2
    5c8e:	2d 93       	st	X+, r18
    5c90:	3c 93       	st	X, r19
    5c92:	13 97       	sbiw	r26, 0x03	; 3
  return;
}
    5c94:	08 95       	ret
    5c96:	08 95       	ret
    5c98:	08 95       	ret
    5c9a:	80 e0       	ldi	r24, 0x00	; 0
    5c9c:	90 e0       	ldi	r25, 0x00	; 0
    5c9e:	08 95       	ret

00005ca0 <saveNic>:
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
}

void saveNic(void)
{
  eeprom_update_block(&nicState.mac.addr, mymac_eep, 6);
    5ca0:	80 ee       	ldi	r24, 0xE0	; 224
    5ca2:	91 e3       	ldi	r25, 0x31	; 49
    5ca4:	68 e1       	ldi	r22, 0x18	; 24
    5ca6:	70 e0       	ldi	r23, 0x00	; 0
    5ca8:	46 e0       	ldi	r20, 0x06	; 6
    5caa:	50 e0       	ldi	r21, 0x00	; 0
    5cac:	0e 94 7f 5a 	call	0xb4fe	; 0xb4fe <__eeupd_block_x128a1>
}
    5cb0:	08 95       	ret

00005cb2 <nicInit>:
unsigned int nicPoll(void)                                       { return 0; }


static void nicBufferInit(void)
{
  nicState.bufferSize  = NETWORK_STACK_BUF_SIZE;
    5cb2:	80 e0       	ldi	r24, 0x00	; 0
    5cb4:	96 e0       	ldi	r25, 0x06	; 6
    5cb6:	80 93 de 31 	sts	0x31DE, r24
    5cba:	90 93 df 31 	sts	0x31DF, r25
  nicState.layer2.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR);
    5cbe:	e0 e0       	ldi	r30, 0x00	; 0
    5cc0:	fa e7       	ldi	r31, 0x7A	; 122
    5cc2:	e0 93 e6 31 	sts	0x31E6, r30
    5cc6:	f0 93 e7 31 	sts	0x31E7, r31
  nicState.layer3.ip   = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
    5cca:	2e e0       	ldi	r18, 0x0E	; 14
    5ccc:	3a e7       	ldi	r19, 0x7A	; 122
    5cce:	20 93 e8 31 	sts	0x31E8, r18
    5cd2:	30 93 e9 31 	sts	0x31E9, r19
  nicState.layer4.icmp = (struct  netIcmpHeader *)(NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN + IP_HEADER_LEN);
    5cd6:	22 e2       	ldi	r18, 0x22	; 34
    5cd8:	3a e7       	ldi	r19, 0x7A	; 122
    5cda:	20 93 ea 31 	sts	0x31EA, r18
    5cde:	30 93 eb 31 	sts	0x31EB, r19
  #if IPV6_SUPPORT
  nicState.layer3.ipv6 = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  nicState.layer3.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  //nicState.layer4.icmpv6  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  #endif /*IPV6_SUPPORT*/
  memset(nicState.layer2.buf, 0, nicState.bufferSize);
    5ce2:	df 01       	movw	r26, r30
    5ce4:	9c 01       	movw	r18, r24
    5ce6:	1d 92       	st	X+, r1
    5ce8:	21 50       	subi	r18, 0x01	; 1
    5cea:	30 40       	sbci	r19, 0x00	; 0
    5cec:	e1 f7       	brne	.-8      	; 0x5ce6 <nicInit+0x34>
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
    5cee:	80 ee       	ldi	r24, 0xE0	; 224
    5cf0:	91 e3       	ldi	r25, 0x31	; 49
    5cf2:	68 e1       	ldi	r22, 0x18	; 24
    5cf4:	70 e0       	ldi	r23, 0x00	; 0
    5cf6:	46 e0       	ldi	r20, 0x06	; 6
    5cf8:	50 e0       	ldi	r21, 0x00	; 0
    5cfa:	0e 94 67 5a 	call	0xb4ce	; 0xb4ce <__eerd_block_x128a1>
}

void nicInit()
{
  nicBufferInit();
  nicMacInit();
    5cfe:	0e 94 91 2c 	call	0x5922	; 0x5922 <nicMacInit>
}
    5d02:	08 95       	ret
    5d04:	60 ee       	ldi	r22, 0xE0	; 224
    5d06:	71 e3       	ldi	r23, 0x31	; 49
    5d08:	46 e0       	ldi	r20, 0x06	; 6
    5d0a:	50 e0       	ldi	r21, 0x00	; 0
    5d0c:	0e 94 45 57 	call	0xae8a	; 0xae8a <strncpy>
    5d10:	08 95       	ret
    5d12:	bc 01       	movw	r22, r24
    5d14:	80 ee       	ldi	r24, 0xE0	; 224
    5d16:	91 e3       	ldi	r25, 0x31	; 49
    5d18:	46 e0       	ldi	r20, 0x06	; 6
    5d1a:	50 e0       	ldi	r21, 0x00	; 0
    5d1c:	0e 94 45 57 	call	0xae8a	; 0xae8a <strncpy>
    5d20:	0e 94 91 2c 	call	0x5922	; 0x5922 <nicMacInit>
    5d24:	08 95       	ret
    5d26:	00 d0       	rcall	.+0      	; 0x5d28 <nicInit+0x76>
    5d28:	0f 92       	push	r0
    5d2a:	ed b7       	in	r30, 0x3d	; 61
    5d2c:	fe b7       	in	r31, 0x3e	; 62
    5d2e:	81 83       	std	Z+1, r24	; 0x01
    5d30:	92 83       	std	Z+2, r25	; 0x02
    5d32:	80 ee       	ldi	r24, 0xE0	; 224
    5d34:	98 e0       	ldi	r25, 0x08	; 8
    5d36:	83 83       	std	Z+3, r24	; 0x03
    5d38:	94 83       	std	Z+4, r25	; 0x04
    5d3a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5d3e:	0f 90       	pop	r0
    5d40:	0f 90       	pop	r0
    5d42:	0f 90       	pop	r0
    5d44:	0f 90       	pop	r0
    5d46:	08 95       	ret

00005d48 <htons>:
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5d48:	38 2f       	mov	r19, r24
    5d4a:	29 2f       	mov	r18, r25
}
    5d4c:	c9 01       	movw	r24, r18
    5d4e:	08 95       	ret

00005d50 <htonl>:
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5d50:	36 2f       	mov	r19, r22
    5d52:	27 2f       	mov	r18, r23
}

uint32_t htonl(uint32_t val)
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
    5d54:	40 e0       	ldi	r20, 0x00	; 0
    5d56:	50 e0       	ldi	r21, 0x00	; 0
    5d58:	a9 01       	movw	r20, r18
    5d5a:	33 27       	eor	r19, r19
    5d5c:	22 27       	eor	r18, r18
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5d5e:	98 27       	eor	r25, r24
    5d60:	89 27       	eor	r24, r25
    5d62:	98 27       	eor	r25, r24
}

uint32_t htonl(uint32_t val)
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
    5d64:	a0 e0       	ldi	r26, 0x00	; 0
    5d66:	b0 e0       	ldi	r27, 0x00	; 0
    5d68:	28 2b       	or	r18, r24
    5d6a:	39 2b       	or	r19, r25
    5d6c:	4a 2b       	or	r20, r26
    5d6e:	5b 2b       	or	r21, r27
}
    5d70:	b9 01       	movw	r22, r18
    5d72:	ca 01       	movw	r24, r20
    5d74:	08 95       	ret

00005d76 <netChecksum>:


uint16_t netChecksum(uint8_t *data, uint16_t len)
{
    5d76:	ef 92       	push	r14
    5d78:	ff 92       	push	r15
    5d7a:	0f 93       	push	r16
    5d7c:	1f 93       	push	r17
    5d7e:	fb 01       	movw	r30, r22
    5d80:	dc 01       	movw	r26, r24
  register uint32_t sum = 0;
    5d82:	20 e0       	ldi	r18, 0x00	; 0
    5d84:	30 e0       	ldi	r19, 0x00	; 0
    5d86:	a9 01       	movw	r20, r18

  for (;;) 
  {
    if (len < 2)
    5d88:	e2 30       	cpi	r30, 0x02	; 2
    5d8a:	f1 05       	cpc	r31, r1
    5d8c:	50 f0       	brcs	.+20     	; 0x5da2 <netChecksum+0x2c>
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    5d8e:	ed 90       	ld	r14, X+
    5d90:	fd 90       	ld	r15, X+
    5d92:	00 e0       	ldi	r16, 0x00	; 0
    5d94:	10 e0       	ldi	r17, 0x00	; 0
    5d96:	2e 0d       	add	r18, r14
    5d98:	3f 1d       	adc	r19, r15
    5d9a:	40 1f       	adc	r20, r16
    5d9c:	51 1f       	adc	r21, r17
    data+=2;
    len -= 2;
    5d9e:	32 97       	sbiw	r30, 0x02	; 2
  }
    5da0:	f3 cf       	rjmp	.-26     	; 0x5d88 <netChecksum+0x12>
{
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
}


uint16_t netChecksum(uint8_t *data, uint16_t len)
    5da2:	fb 01       	movw	r30, r22
    5da4:	ee 7f       	andi	r30, 0xFE	; 254
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    data+=2;
    len -= 2;
  }
    5da6:	e8 0f       	add	r30, r24
    5da8:	f9 1f       	adc	r31, r25
  if (len)
    5daa:	60 ff       	sbrs	r22, 0
    5dac:	0a c0       	rjmp	.+20     	; 0x5dc2 <netChecksum+0x4c>
    sum += *(uint8_t *) data;
    5dae:	80 81       	ld	r24, Z
    5db0:	28 0f       	add	r18, r24
    5db2:	31 1d       	adc	r19, r1
    5db4:	41 1d       	adc	r20, r1
    5db6:	51 1d       	adc	r21, r1
    5db8:	04 c0       	rjmp	.+8      	; 0x5dc2 <netChecksum+0x4c>

  while ((len = (uint16_t) (sum >> 16)) != 0)
    sum = (uint16_t) sum + len;
    5dba:	28 0f       	add	r18, r24
    5dbc:	39 1f       	adc	r19, r25
    5dbe:	40 e0       	ldi	r20, 0x00	; 0
    5dc0:	50 e0       	ldi	r21, 0x00	; 0
    len -= 2;
  }
  if (len)
    sum += *(uint8_t *) data;

  while ((len = (uint16_t) (sum >> 16)) != 0)
    5dc2:	ca 01       	movw	r24, r20
    5dc4:	00 97       	sbiw	r24, 0x00	; 0
    5dc6:	c9 f7       	brne	.-14     	; 0x5dba <netChecksum+0x44>
    sum = (uint16_t) sum + len;

  return (uint16_t) sum ^ 0xFFFF;
    5dc8:	20 95       	com	r18
    5dca:	30 95       	com	r19
}
    5dcc:	c9 01       	movw	r24, r18
    5dce:	1f 91       	pop	r17
    5dd0:	0f 91       	pop	r16
    5dd2:	ff 90       	pop	r15
    5dd4:	ef 90       	pop	r14
    5dd6:	08 95       	ret

00005dd8 <netPrintEthAddr>:

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
    5dd8:	cf 93       	push	r28
    5dda:	df 93       	push	r29
    5ddc:	db 01       	movw	r26, r22
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    5dde:	2d b7       	in	r18, 0x3d	; 61
    5de0:	3e b7       	in	r19, 0x3e	; 62
    5de2:	20 51       	subi	r18, 0x10	; 16
    5de4:	30 40       	sbci	r19, 0x00	; 0
    5de6:	2d bf       	out	0x3d, r18	; 61
    5de8:	3e bf       	out	0x3e, r19	; 62
    5dea:	ed b7       	in	r30, 0x3d	; 61
    5dec:	fe b7       	in	r31, 0x3e	; 62
    5dee:	31 96       	adiw	r30, 0x01	; 1
    5df0:	cd b7       	in	r28, 0x3d	; 61
    5df2:	de b7       	in	r29, 0x3e	; 62
    5df4:	89 83       	std	Y+1, r24	; 0x01
    5df6:	9a 83       	std	Y+2, r25	; 0x02
    5df8:	8b e2       	ldi	r24, 0x2B	; 43
    5dfa:	9a e0       	ldi	r25, 0x0A	; 10
    5dfc:	82 83       	std	Z+2, r24	; 0x02
    5dfe:	93 83       	std	Z+3, r25	; 0x03
    5e00:	8c 91       	ld	r24, X
    5e02:	84 83       	std	Z+4, r24	; 0x04
    5e04:	15 82       	std	Z+5, r1	; 0x05
    5e06:	11 96       	adiw	r26, 0x01	; 1
    5e08:	8c 91       	ld	r24, X
    5e0a:	11 97       	sbiw	r26, 0x01	; 1
    5e0c:	86 83       	std	Z+6, r24	; 0x06
    5e0e:	17 82       	std	Z+7, r1	; 0x07
    5e10:	12 96       	adiw	r26, 0x02	; 2
    5e12:	8c 91       	ld	r24, X
    5e14:	12 97       	sbiw	r26, 0x02	; 2
    5e16:	80 87       	std	Z+8, r24	; 0x08
    5e18:	11 86       	std	Z+9, r1	; 0x09
    5e1a:	13 96       	adiw	r26, 0x03	; 3
    5e1c:	8c 91       	ld	r24, X
    5e1e:	13 97       	sbiw	r26, 0x03	; 3
    5e20:	82 87       	std	Z+10, r24	; 0x0a
    5e22:	13 86       	std	Z+11, r1	; 0x0b
    5e24:	14 96       	adiw	r26, 0x04	; 4
    5e26:	8c 91       	ld	r24, X
    5e28:	14 97       	sbiw	r26, 0x04	; 4
    5e2a:	84 87       	std	Z+12, r24	; 0x0c
    5e2c:	15 86       	std	Z+13, r1	; 0x0d
    5e2e:	15 96       	adiw	r26, 0x05	; 5
    5e30:	8c 91       	ld	r24, X
    5e32:	86 87       	std	Z+14, r24	; 0x0e
    5e34:	17 86       	std	Z+15, r1	; 0x0f
    5e36:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5e3a:	2d b7       	in	r18, 0x3d	; 61
    5e3c:	3e b7       	in	r19, 0x3e	; 62
    5e3e:	20 5f       	subi	r18, 0xF0	; 240
    5e40:	3f 4f       	sbci	r19, 0xFF	; 255
    5e42:	2d bf       	out	0x3d, r18	; 61
    5e44:	3e bf       	out	0x3e, r19	; 62
}
    5e46:	df 91       	pop	r29
    5e48:	cf 91       	pop	r28
    5e4a:	08 95       	ret

00005e4c <netPrintIPAddr>:

void netPrintIPAddr(FILE *stream, uint32_t ipaddr)
{
    5e4c:	df 93       	push	r29
    5e4e:	cf 93       	push	r28
    5e50:	00 d0       	rcall	.+0      	; 0x5e52 <netPrintIPAddr+0x6>
    5e52:	0f 92       	push	r0
    5e54:	cd b7       	in	r28, 0x3d	; 61
    5e56:	de b7       	in	r29, 0x3e	; 62
    5e58:	49 83       	std	Y+1, r20	; 0x01
    5e5a:	5a 83       	std	Y+2, r21	; 0x02
    5e5c:	6b 83       	std	Y+3, r22	; 0x03
    5e5e:	7c 83       	std	Y+4, r23	; 0x04
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
    5e60:	ae 01       	movw	r20, r28
    5e62:	4f 5f       	subi	r20, 0xFF	; 255
    5e64:	5f 4f       	sbci	r21, 0xFF	; 255
    5e66:	2d b7       	in	r18, 0x3d	; 61
    5e68:	3e b7       	in	r19, 0x3e	; 62
    5e6a:	2c 50       	subi	r18, 0x0C	; 12
    5e6c:	30 40       	sbci	r19, 0x00	; 0
    5e6e:	2d bf       	out	0x3d, r18	; 61
    5e70:	3e bf       	out	0x3e, r19	; 62
    5e72:	ed b7       	in	r30, 0x3d	; 61
    5e74:	fe b7       	in	r31, 0x3e	; 62
    5e76:	31 96       	adiw	r30, 0x01	; 1
    5e78:	ad b7       	in	r26, 0x3d	; 61
    5e7a:	be b7       	in	r27, 0x3e	; 62
    5e7c:	11 96       	adiw	r26, 0x01	; 1
    5e7e:	8d 93       	st	X+, r24
    5e80:	9c 93       	st	X, r25
    5e82:	12 97       	sbiw	r26, 0x02	; 2
    5e84:	8f e1       	ldi	r24, 0x1F	; 31
    5e86:	9a e0       	ldi	r25, 0x0A	; 10
    5e88:	82 83       	std	Z+2, r24	; 0x02
    5e8a:	93 83       	std	Z+3, r25	; 0x03
    5e8c:	89 81       	ldd	r24, Y+1	; 0x01
    5e8e:	84 83       	std	Z+4, r24	; 0x04
    5e90:	15 82       	std	Z+5, r1	; 0x05
    5e92:	da 01       	movw	r26, r20
    5e94:	11 96       	adiw	r26, 0x01	; 1
    5e96:	8c 91       	ld	r24, X
    5e98:	11 97       	sbiw	r26, 0x01	; 1
    5e9a:	86 83       	std	Z+6, r24	; 0x06
    5e9c:	17 82       	std	Z+7, r1	; 0x07
    5e9e:	12 96       	adiw	r26, 0x02	; 2
    5ea0:	8c 91       	ld	r24, X
    5ea2:	12 97       	sbiw	r26, 0x02	; 2
    5ea4:	80 87       	std	Z+8, r24	; 0x08
    5ea6:	11 86       	std	Z+9, r1	; 0x09
    5ea8:	13 96       	adiw	r26, 0x03	; 3
    5eaa:	8c 91       	ld	r24, X
    5eac:	82 87       	std	Z+10, r24	; 0x0a
    5eae:	13 86       	std	Z+11, r1	; 0x0b
    5eb0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    5eb4:	2d b7       	in	r18, 0x3d	; 61
    5eb6:	3e b7       	in	r19, 0x3e	; 62
    5eb8:	24 5f       	subi	r18, 0xF4	; 244
    5eba:	3f 4f       	sbci	r19, 0xFF	; 255
    5ebc:	2d bf       	out	0x3d, r18	; 61
    5ebe:	3e bf       	out	0x3e, r19	; 62
}
    5ec0:	24 96       	adiw	r28, 0x04	; 4
    5ec2:	cd bf       	out	0x3d, r28	; 61
    5ec4:	de bf       	out	0x3e, r29	; 62
    5ec6:	cf 91       	pop	r28
    5ec8:	df 91       	pop	r29
    5eca:	08 95       	ret

00005ecc <netPrintEthHeader>:

void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
    5ecc:	0f 93       	push	r16
    5ece:	1f 93       	push	r17
    5ed0:	cf 93       	push	r28
    5ed2:	df 93       	push	r29
    5ed4:	ec 01       	movw	r28, r24
    5ed6:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
    5ed8:	00 d0       	rcall	.+0      	; 0x5eda <netPrintEthHeader+0xe>
    5eda:	00 d0       	rcall	.+0      	; 0x5edc <netPrintEthHeader+0x10>
    5edc:	ed b7       	in	r30, 0x3d	; 61
    5ede:	fe b7       	in	r31, 0x3e	; 62
    5ee0:	31 96       	adiw	r30, 0x01	; 1
    5ee2:	ad b7       	in	r26, 0x3d	; 61
    5ee4:	be b7       	in	r27, 0x3e	; 62
    5ee6:	11 96       	adiw	r26, 0x01	; 1
    5ee8:	8d 93       	st	X+, r24
    5eea:	9c 93       	st	X, r25
    5eec:	12 97       	sbiw	r26, 0x02	; 2
    5eee:	89 e0       	ldi	r24, 0x09	; 9
    5ef0:	9a e0       	ldi	r25, 0x0A	; 10
    5ef2:	82 83       	std	Z+2, r24	; 0x02
    5ef4:	93 83       	std	Z+3, r25	; 0x03
    5ef6:	db 01       	movw	r26, r22
    5ef8:	1c 96       	adiw	r26, 0x0c	; 12
    5efa:	8d 91       	ld	r24, X+
    5efc:	9c 91       	ld	r25, X
    5efe:	1d 97       	sbiw	r26, 0x0d	; 13
    5f00:	84 83       	std	Z+4, r24	; 0x04
    5f02:	95 83       	std	Z+5, r25	; 0x05
    5f04:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR(" SRC:"));
    5f08:	0f 90       	pop	r0
    5f0a:	0f 90       	pop	r0
    5f0c:	ed b7       	in	r30, 0x3d	; 61
    5f0e:	fe b7       	in	r31, 0x3e	; 62
    5f10:	c1 83       	std	Z+1, r28	; 0x01
    5f12:	d2 83       	std	Z+2, r29	; 0x02
    5f14:	83 e0       	ldi	r24, 0x03	; 3
    5f16:	9a e0       	ldi	r25, 0x0A	; 10
    5f18:	83 83       	std	Z+3, r24	; 0x03
    5f1a:	94 83       	std	Z+4, r25	; 0x04
    5f1c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->src);
    5f20:	0f 90       	pop	r0
    5f22:	0f 90       	pop	r0
    5f24:	0f 90       	pop	r0
    5f26:	0f 90       	pop	r0
    5f28:	b8 01       	movw	r22, r16
    5f2a:	6a 5f       	subi	r22, 0xFA	; 250
    5f2c:	7f 4f       	sbci	r23, 0xFF	; 255
    5f2e:	ce 01       	movw	r24, r28
    5f30:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
  fprintf_P(stream, PSTR("->DST:"));
    5f34:	00 d0       	rcall	.+0      	; 0x5f36 <netPrintEthHeader+0x6a>
    5f36:	0f 92       	push	r0
    5f38:	ad b7       	in	r26, 0x3d	; 61
    5f3a:	be b7       	in	r27, 0x3e	; 62
    5f3c:	11 96       	adiw	r26, 0x01	; 1
    5f3e:	cd 93       	st	X+, r28
    5f40:	dc 93       	st	X, r29
    5f42:	12 97       	sbiw	r26, 0x02	; 2
    5f44:	8c ef       	ldi	r24, 0xFC	; 252
    5f46:	99 e0       	ldi	r25, 0x09	; 9
    5f48:	13 96       	adiw	r26, 0x03	; 3
    5f4a:	8d 93       	st	X+, r24
    5f4c:	9c 93       	st	X, r25
    5f4e:	14 97       	sbiw	r26, 0x04	; 4
    5f50:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->dest);
    5f54:	0f 90       	pop	r0
    5f56:	0f 90       	pop	r0
    5f58:	0f 90       	pop	r0
    5f5a:	0f 90       	pop	r0
    5f5c:	ce 01       	movw	r24, r28
    5f5e:	b8 01       	movw	r22, r16
    5f60:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
}
    5f64:	df 91       	pop	r29
    5f66:	cf 91       	pop	r28
    5f68:	1f 91       	pop	r17
    5f6a:	0f 91       	pop	r16
    5f6c:	08 95       	ret

00005f6e <netPrintIpHeader>:

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
    5f6e:	0f 93       	push	r16
    5f70:	1f 93       	push	r17
    5f72:	cf 93       	push	r28
    5f74:	df 93       	push	r29
    5f76:	ec 01       	movw	r28, r24
    5f78:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Header\r\n"));
    5f7a:	00 d0       	rcall	.+0      	; 0x5f7c <netPrintIpHeader+0xe>
    5f7c:	0f 92       	push	r0
    5f7e:	ad b7       	in	r26, 0x3d	; 61
    5f80:	be b7       	in	r27, 0x3e	; 62
    5f82:	11 96       	adiw	r26, 0x01	; 1
    5f84:	8d 93       	st	X+, r24
    5f86:	9c 93       	st	X, r25
    5f88:	12 97       	sbiw	r26, 0x02	; 2
    5f8a:	80 ef       	ldi	r24, 0xF0	; 240
    5f8c:	99 e0       	ldi	r25, 0x09	; 9
    5f8e:	13 96       	adiw	r26, 0x03	; 3
    5f90:	8d 93       	st	X+, r24
    5f92:	9c 93       	st	X, r25
    5f94:	14 97       	sbiw	r26, 0x04	; 4
    5f96:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
    5f9a:	0f 92       	push	r0
    5f9c:	0f 92       	push	r0
    5f9e:	ed b7       	in	r30, 0x3d	; 61
    5fa0:	fe b7       	in	r31, 0x3e	; 62
    5fa2:	31 96       	adiw	r30, 0x01	; 1
    5fa4:	ad b7       	in	r26, 0x3d	; 61
    5fa6:	be b7       	in	r27, 0x3e	; 62
    5fa8:	11 96       	adiw	r26, 0x01	; 1
    5faa:	cd 93       	st	X+, r28
    5fac:	dc 93       	st	X, r29
    5fae:	12 97       	sbiw	r26, 0x02	; 2
    5fb0:	81 ee       	ldi	r24, 0xE1	; 225
    5fb2:	99 e0       	ldi	r25, 0x09	; 9
    5fb4:	82 83       	std	Z+2, r24	; 0x02
    5fb6:	93 83       	std	Z+3, r25	; 0x03
    5fb8:	d8 01       	movw	r26, r16
    5fba:	8c 91       	ld	r24, X
    5fbc:	82 95       	swap	r24
    5fbe:	8f 70       	andi	r24, 0x0F	; 15
    5fc0:	84 83       	std	Z+4, r24	; 0x04
    5fc2:	15 82       	std	Z+5, r1	; 0x05
    5fc4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5fc8:	ed b7       	in	r30, 0x3d	; 61
    5fca:	fe b7       	in	r31, 0x3e	; 62
    5fcc:	31 96       	adiw	r30, 0x01	; 1
    5fce:	ad b7       	in	r26, 0x3d	; 61
    5fd0:	be b7       	in	r27, 0x3e	; 62
    5fd2:	11 96       	adiw	r26, 0x01	; 1
    5fd4:	cd 93       	st	X+, r28
    5fd6:	dc 93       	st	X, r29
    5fd8:	12 97       	sbiw	r26, 0x02	; 2
    5fda:	82 ed       	ldi	r24, 0xD2	; 210
    5fdc:	99 e0       	ldi	r25, 0x09	; 9
    5fde:	82 83       	std	Z+2, r24	; 0x02
    5fe0:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5fe2:	d8 01       	movw	r26, r16
    5fe4:	12 96       	adiw	r26, 0x02	; 2
    5fe6:	8d 91       	ld	r24, X+
    5fe8:	9c 91       	ld	r25, X
    5fea:	13 97       	sbiw	r26, 0x03	; 3
    5fec:	98 27       	eor	r25, r24
    5fee:	89 27       	eor	r24, r25
    5ff0:	98 27       	eor	r25, r24

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
  fprintf_P(stream, PSTR("IP Header\r\n"));
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5ff2:	84 83       	std	Z+4, r24	; 0x04
    5ff4:	95 83       	std	Z+5, r25	; 0x05
    5ff6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  if(ipheader->proto == IP_PROTO_ICMP)
    5ffa:	f8 01       	movw	r30, r16
    5ffc:	21 85       	ldd	r18, Z+9	; 0x09
    5ffe:	8d b7       	in	r24, 0x3d	; 61
    6000:	9e b7       	in	r25, 0x3e	; 62
    6002:	06 96       	adiw	r24, 0x06	; 6
    6004:	8d bf       	out	0x3d, r24	; 61
    6006:	9e bf       	out	0x3e, r25	; 62
    6008:	21 30       	cpi	r18, 0x01	; 1
    600a:	59 f4       	brne	.+22     	; 0x6022 <netPrintIpHeader+0xb4>
    fprintf_P(stream, PSTR("Protocol: ICMP\r\n"));
    600c:	00 d0       	rcall	.+0      	; 0x600e <netPrintIpHeader+0xa0>
    600e:	0f 92       	push	r0
    6010:	ad b7       	in	r26, 0x3d	; 61
    6012:	be b7       	in	r27, 0x3e	; 62
    6014:	11 96       	adiw	r26, 0x01	; 1
    6016:	cd 93       	st	X+, r28
    6018:	dc 93       	st	X, r29
    601a:	12 97       	sbiw	r26, 0x02	; 2
    601c:	81 ec       	ldi	r24, 0xC1	; 193
    601e:	99 e0       	ldi	r25, 0x09	; 9
    6020:	1f c0       	rjmp	.+62     	; 0x6060 <netPrintIpHeader+0xf2>
  else if(ipheader->proto == IP_PROTO_TCP)
    6022:	26 30       	cpi	r18, 0x06	; 6
    6024:	89 f4       	brne	.+34     	; 0x6048 <netPrintIpHeader+0xda>
    fprintf_P(stream, PSTR("Protocol: TCP\r\n"));
    6026:	00 d0       	rcall	.+0      	; 0x6028 <netPrintIpHeader+0xba>
    6028:	0f 92       	push	r0
    602a:	ed b7       	in	r30, 0x3d	; 61
    602c:	fe b7       	in	r31, 0x3e	; 62
    602e:	c1 83       	std	Z+1, r28	; 0x01
    6030:	d2 83       	std	Z+2, r29	; 0x02
    6032:	81 eb       	ldi	r24, 0xB1	; 177
    6034:	99 e0       	ldi	r25, 0x09	; 9
    6036:	83 83       	std	Z+3, r24	; 0x03
    6038:	94 83       	std	Z+4, r25	; 0x04
    603a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    603e:	0f 90       	pop	r0
    6040:	0f 90       	pop	r0
    6042:	0f 90       	pop	r0
    6044:	0f 90       	pop	r0
    6046:	29 c0       	rjmp	.+82     	; 0x609a <netPrintIpHeader+0x12c>
  else if(ipheader->proto == IP_PROTO_UDP)
    6048:	21 31       	cpi	r18, 0x11	; 17
    604a:	79 f4       	brne	.+30     	; 0x606a <netPrintIpHeader+0xfc>
    fprintf_P(stream, PSTR("Protocol: UDP\r\n"));
    604c:	00 d0       	rcall	.+0      	; 0x604e <netPrintIpHeader+0xe0>
    604e:	0f 92       	push	r0
    6050:	ad b7       	in	r26, 0x3d	; 61
    6052:	be b7       	in	r27, 0x3e	; 62
    6054:	11 96       	adiw	r26, 0x01	; 1
    6056:	cd 93       	st	X+, r28
    6058:	dc 93       	st	X, r29
    605a:	12 97       	sbiw	r26, 0x02	; 2
    605c:	81 ea       	ldi	r24, 0xA1	; 161
    605e:	99 e0       	ldi	r25, 0x09	; 9
    6060:	13 96       	adiw	r26, 0x03	; 3
    6062:	8d 93       	st	X+, r24
    6064:	9c 93       	st	X, r25
    6066:	14 97       	sbiw	r26, 0x04	; 4
    6068:	e8 cf       	rjmp	.-48     	; 0x603a <netPrintIpHeader+0xcc>
  else
    fprintf_P(stream, PSTR("Protocol: %d\r\n"), ipheader->proto);
    606a:	00 d0       	rcall	.+0      	; 0x606c <netPrintIpHeader+0xfe>
    606c:	00 d0       	rcall	.+0      	; 0x606e <netPrintIpHeader+0x100>
    606e:	ed b7       	in	r30, 0x3d	; 61
    6070:	fe b7       	in	r31, 0x3e	; 62
    6072:	31 96       	adiw	r30, 0x01	; 1
    6074:	ad b7       	in	r26, 0x3d	; 61
    6076:	be b7       	in	r27, 0x3e	; 62
    6078:	11 96       	adiw	r26, 0x01	; 1
    607a:	cd 93       	st	X+, r28
    607c:	dc 93       	st	X, r29
    607e:	12 97       	sbiw	r26, 0x02	; 2
    6080:	82 e9       	ldi	r24, 0x92	; 146
    6082:	99 e0       	ldi	r25, 0x09	; 9
    6084:	82 83       	std	Z+2, r24	; 0x02
    6086:	93 83       	std	Z+3, r25	; 0x03
    6088:	24 83       	std	Z+4, r18	; 0x04
    608a:	15 82       	std	Z+5, r1	; 0x05
    608c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6090:	ed b7       	in	r30, 0x3d	; 61
    6092:	fe b7       	in	r31, 0x3e	; 62
    6094:	36 96       	adiw	r30, 0x06	; 6
    6096:	ed bf       	out	0x3d, r30	; 61
    6098:	fe bf       	out	0x3e, r31	; 62

  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
    609a:	00 d0       	rcall	.+0      	; 0x609c <netPrintIpHeader+0x12e>
    609c:	0f 92       	push	r0
    609e:	ad b7       	in	r26, 0x3d	; 61
    60a0:	be b7       	in	r27, 0x3e	; 62
    60a2:	11 96       	adiw	r26, 0x01	; 1
    60a4:	cd 93       	st	X+, r28
    60a6:	dc 93       	st	X, r29
    60a8:	12 97       	sbiw	r26, 0x02	; 2
    60aa:	87 e8       	ldi	r24, 0x87	; 135
    60ac:	99 e0       	ldi	r25, 0x09	; 9
    60ae:	13 96       	adiw	r26, 0x03	; 3
    60b0:	8d 93       	st	X+, r24
    60b2:	9c 93       	st	X, r25
    60b4:	14 97       	sbiw	r26, 0x04	; 4
    60b6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    60ba:	0f 90       	pop	r0
    60bc:	0f 90       	pop	r0
    60be:	0f 90       	pop	r0
    60c0:	0f 90       	pop	r0
    60c2:	f8 01       	movw	r30, r16
    60c4:	64 85       	ldd	r22, Z+12	; 0x0c
    60c6:	75 85       	ldd	r23, Z+13	; 0x0d
    60c8:	86 85       	ldd	r24, Z+14	; 0x0e
    60ca:	97 85       	ldd	r25, Z+15	; 0x0f
    60cc:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <htonl>
    60d0:	ab 01       	movw	r20, r22
    60d2:	bc 01       	movw	r22, r24
    60d4:	ce 01       	movw	r24, r28
    60d6:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    60da:	00 d0       	rcall	.+0      	; 0x60dc <netPrintIpHeader+0x16e>
    60dc:	0f 92       	push	r0
    60de:	ad b7       	in	r26, 0x3d	; 61
    60e0:	be b7       	in	r27, 0x3e	; 62
    60e2:	11 96       	adiw	r26, 0x01	; 1
    60e4:	cd 93       	st	X+, r28
    60e6:	dc 93       	st	X, r29
    60e8:	12 97       	sbiw	r26, 0x02	; 2
    60ea:	84 e8       	ldi	r24, 0x84	; 132
    60ec:	99 e0       	ldi	r25, 0x09	; 9
    60ee:	13 96       	adiw	r26, 0x03	; 3
    60f0:	8d 93       	st	X+, r24
    60f2:	9c 93       	st	X, r25
    60f4:	14 97       	sbiw	r26, 0x04	; 4
    60f6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
    60fa:	ed b7       	in	r30, 0x3d	; 61
    60fc:	fe b7       	in	r31, 0x3e	; 62
    60fe:	c1 83       	std	Z+1, r28	; 0x01
    6100:	d2 83       	std	Z+2, r29	; 0x02
    6102:	89 e7       	ldi	r24, 0x79	; 121
    6104:	99 e0       	ldi	r25, 0x09	; 9
    6106:	83 83       	std	Z+3, r24	; 0x03
    6108:	94 83       	std	Z+4, r25	; 0x04
    610a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    610e:	0f 90       	pop	r0
    6110:	0f 90       	pop	r0
    6112:	0f 90       	pop	r0
    6114:	0f 90       	pop	r0
    6116:	d8 01       	movw	r26, r16
    6118:	50 96       	adiw	r26, 0x10	; 16
    611a:	6d 91       	ld	r22, X+
    611c:	7d 91       	ld	r23, X+
    611e:	8d 91       	ld	r24, X+
    6120:	9c 91       	ld	r25, X
    6122:	53 97       	sbiw	r26, 0x13	; 19
    6124:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <htonl>
    6128:	ab 01       	movw	r20, r22
    612a:	bc 01       	movw	r22, r24
    612c:	ce 01       	movw	r24, r28
    612e:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    6132:	00 d0       	rcall	.+0      	; 0x6134 <netPrintIpHeader+0x1c6>
    6134:	0f 92       	push	r0
    6136:	ed b7       	in	r30, 0x3d	; 61
    6138:	fe b7       	in	r31, 0x3e	; 62
    613a:	c1 83       	std	Z+1, r28	; 0x01
    613c:	d2 83       	std	Z+2, r29	; 0x02
    613e:	86 e7       	ldi	r24, 0x76	; 118
    6140:	99 e0       	ldi	r25, 0x09	; 9
    6142:	83 83       	std	Z+3, r24	; 0x03
    6144:	94 83       	std	Z+4, r25	; 0x04
    6146:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    614a:	0f 90       	pop	r0
    614c:	0f 90       	pop	r0
    614e:	0f 90       	pop	r0
    6150:	0f 90       	pop	r0
}
    6152:	df 91       	pop	r29
    6154:	cf 91       	pop	r28
    6156:	1f 91       	pop	r17
    6158:	0f 91       	pop	r16
    615a:	08 95       	ret

0000615c <netPrintTcpHeader>:

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
    615c:	0f 93       	push	r16
    615e:	1f 93       	push	r17
    6160:	cf 93       	push	r28
    6162:	df 93       	push	r29
    6164:	ec 01       	movw	r28, r24
    6166:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("TCP Header\r\n"));
    6168:	00 d0       	rcall	.+0      	; 0x616a <netPrintTcpHeader+0xe>
    616a:	0f 92       	push	r0
    616c:	ad b7       	in	r26, 0x3d	; 61
    616e:	be b7       	in	r27, 0x3e	; 62
    6170:	11 96       	adiw	r26, 0x01	; 1
    6172:	8d 93       	st	X+, r24
    6174:	9c 93       	st	X, r25
    6176:	12 97       	sbiw	r26, 0x02	; 2
    6178:	89 e6       	ldi	r24, 0x69	; 105
    617a:	99 e0       	ldi	r25, 0x09	; 9
    617c:	13 96       	adiw	r26, 0x03	; 3
    617e:	8d 93       	st	X+, r24
    6180:	9c 93       	st	X, r25
    6182:	14 97       	sbiw	r26, 0x04	; 4
    6184:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    6188:	0f 92       	push	r0
    618a:	0f 92       	push	r0
    618c:	ed b7       	in	r30, 0x3d	; 61
    618e:	fe b7       	in	r31, 0x3e	; 62
    6190:	31 96       	adiw	r30, 0x01	; 1
    6192:	ad b7       	in	r26, 0x3d	; 61
    6194:	be b7       	in	r27, 0x3e	; 62
    6196:	11 96       	adiw	r26, 0x01	; 1
    6198:	cd 93       	st	X+, r28
    619a:	dc 93       	st	X, r29
    619c:	12 97       	sbiw	r26, 0x02	; 2
    619e:	8a e5       	ldi	r24, 0x5A	; 90
    61a0:	99 e0       	ldi	r25, 0x09	; 9
    61a2:	82 83       	std	Z+2, r24	; 0x02
    61a4:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    61a6:	d8 01       	movw	r26, r16
    61a8:	8d 91       	ld	r24, X+
    61aa:	9c 91       	ld	r25, X
    61ac:	98 27       	eor	r25, r24
    61ae:	89 27       	eor	r24, r25
    61b0:	98 27       	eor	r25, r24
}

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    61b2:	84 83       	std	Z+4, r24	; 0x04
    61b4:	95 83       	std	Z+5, r25	; 0x05
    61b6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    61ba:	ed b7       	in	r30, 0x3d	; 61
    61bc:	fe b7       	in	r31, 0x3e	; 62
    61be:	31 96       	adiw	r30, 0x01	; 1
    61c0:	ad b7       	in	r26, 0x3d	; 61
    61c2:	be b7       	in	r27, 0x3e	; 62
    61c4:	11 96       	adiw	r26, 0x01	; 1
    61c6:	cd 93       	st	X+, r28
    61c8:	dc 93       	st	X, r29
    61ca:	12 97       	sbiw	r26, 0x02	; 2
    61cc:	8b e4       	ldi	r24, 0x4B	; 75
    61ce:	99 e0       	ldi	r25, 0x09	; 9
    61d0:	82 83       	std	Z+2, r24	; 0x02
    61d2:	93 83       	std	Z+3, r25	; 0x03
#include "net.h"


uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    61d4:	d8 01       	movw	r26, r16
    61d6:	12 96       	adiw	r26, 0x02	; 2
    61d8:	8d 91       	ld	r24, X+
    61da:	9c 91       	ld	r25, X
    61dc:	13 97       	sbiw	r26, 0x03	; 3
    61de:	98 27       	eor	r25, r24
    61e0:	89 27       	eor	r24, r25
    61e2:	98 27       	eor	r25, r24

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    61e4:	84 83       	std	Z+4, r24	; 0x04
    61e6:	95 83       	std	Z+5, r25	; 0x05
    61e8:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Seq Num : 0x%x"), htonl(tcpheader->seqno));
    61ec:	ed b7       	in	r30, 0x3d	; 61
    61ee:	fe b7       	in	r31, 0x3e	; 62
    61f0:	36 96       	adiw	r30, 0x06	; 6
    61f2:	ed bf       	out	0x3d, r30	; 61
    61f4:	fe bf       	out	0x3e, r31	; 62
    61f6:	d8 01       	movw	r26, r16
    61f8:	14 96       	adiw	r26, 0x04	; 4
    61fa:	6d 91       	ld	r22, X+
    61fc:	7d 91       	ld	r23, X+
    61fe:	8d 91       	ld	r24, X+
    6200:	9c 91       	ld	r25, X
    6202:	17 97       	sbiw	r26, 0x07	; 7
    6204:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <htonl>
    6208:	ed b7       	in	r30, 0x3d	; 61
    620a:	fe b7       	in	r31, 0x3e	; 62
    620c:	38 97       	sbiw	r30, 0x08	; 8
    620e:	ed bf       	out	0x3d, r30	; 61
    6210:	fe bf       	out	0x3e, r31	; 62
    6212:	31 96       	adiw	r30, 0x01	; 1
    6214:	ad b7       	in	r26, 0x3d	; 61
    6216:	be b7       	in	r27, 0x3e	; 62
    6218:	11 96       	adiw	r26, 0x01	; 1
    621a:	cd 93       	st	X+, r28
    621c:	dc 93       	st	X, r29
    621e:	12 97       	sbiw	r26, 0x02	; 2
    6220:	2c e3       	ldi	r18, 0x3C	; 60
    6222:	39 e0       	ldi	r19, 0x09	; 9
    6224:	22 83       	std	Z+2, r18	; 0x02
    6226:	33 83       	std	Z+3, r19	; 0x03
    6228:	64 83       	std	Z+4, r22	; 0x04
    622a:	75 83       	std	Z+5, r23	; 0x05
    622c:	86 83       	std	Z+6, r24	; 0x06
    622e:	97 83       	std	Z+7, r25	; 0x07
    6230:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Ack Num : 0x%x\r\n"), htonl(tcpheader->ackno));
    6234:	ed b7       	in	r30, 0x3d	; 61
    6236:	fe b7       	in	r31, 0x3e	; 62
    6238:	38 96       	adiw	r30, 0x08	; 8
    623a:	ed bf       	out	0x3d, r30	; 61
    623c:	fe bf       	out	0x3e, r31	; 62
    623e:	d8 01       	movw	r26, r16
    6240:	18 96       	adiw	r26, 0x08	; 8
    6242:	6d 91       	ld	r22, X+
    6244:	7d 91       	ld	r23, X+
    6246:	8d 91       	ld	r24, X+
    6248:	9c 91       	ld	r25, X
    624a:	1b 97       	sbiw	r26, 0x0b	; 11
    624c:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <htonl>
    6250:	ed b7       	in	r30, 0x3d	; 61
    6252:	fe b7       	in	r31, 0x3e	; 62
    6254:	38 97       	sbiw	r30, 0x08	; 8
    6256:	ed bf       	out	0x3d, r30	; 61
    6258:	fe bf       	out	0x3e, r31	; 62
    625a:	31 96       	adiw	r30, 0x01	; 1
    625c:	ad b7       	in	r26, 0x3d	; 61
    625e:	be b7       	in	r27, 0x3e	; 62
    6260:	11 96       	adiw	r26, 0x01	; 1
    6262:	cd 93       	st	X+, r28
    6264:	dc 93       	st	X, r29
    6266:	12 97       	sbiw	r26, 0x02	; 2
    6268:	2b e2       	ldi	r18, 0x2B	; 43
    626a:	39 e0       	ldi	r19, 0x09	; 9
    626c:	22 83       	std	Z+2, r18	; 0x02
    626e:	33 83       	std	Z+3, r19	; 0x03
    6270:	64 83       	std	Z+4, r22	; 0x04
    6272:	75 83       	std	Z+5, r23	; 0x05
    6274:	86 83       	std	Z+6, r24	; 0x06
    6276:	97 83       	std	Z+7, r25	; 0x07
    6278:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Flags   : "));
    627c:	0f 90       	pop	r0
    627e:	0f 90       	pop	r0
    6280:	0f 90       	pop	r0
    6282:	0f 90       	pop	r0
    6284:	ed b7       	in	r30, 0x3d	; 61
    6286:	fe b7       	in	r31, 0x3e	; 62
    6288:	c1 83       	std	Z+1, r28	; 0x01
    628a:	d2 83       	std	Z+2, r29	; 0x02
    628c:	80 e2       	ldi	r24, 0x20	; 32
    628e:	99 e0       	ldi	r25, 0x09	; 9
    6290:	83 83       	std	Z+3, r24	; 0x03
    6292:	94 83       	std	Z+4, r25	; 0x04
    6294:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  if(tcpheader->flags & TCP_FLAGS_FIN)
    6298:	d8 01       	movw	r26, r16
    629a:	1d 96       	adiw	r26, 0x0d	; 13
    629c:	8c 91       	ld	r24, X
    629e:	1d 97       	sbiw	r26, 0x0d	; 13
    62a0:	0f 90       	pop	r0
    62a2:	0f 90       	pop	r0
    62a4:	0f 90       	pop	r0
    62a6:	0f 90       	pop	r0
    62a8:	80 ff       	sbrs	r24, 0
    62aa:	10 c0       	rjmp	.+32     	; 0x62cc <netPrintTcpHeader+0x170>
    fprintf_P(stream, PSTR("FIN "));
    62ac:	00 d0       	rcall	.+0      	; 0x62ae <netPrintTcpHeader+0x152>
    62ae:	0f 92       	push	r0
    62b0:	ed b7       	in	r30, 0x3d	; 61
    62b2:	fe b7       	in	r31, 0x3e	; 62
    62b4:	c1 83       	std	Z+1, r28	; 0x01
    62b6:	d2 83       	std	Z+2, r29	; 0x02
    62b8:	8b e1       	ldi	r24, 0x1B	; 27
    62ba:	99 e0       	ldi	r25, 0x09	; 9
    62bc:	83 83       	std	Z+3, r24	; 0x03
    62be:	94 83       	std	Z+4, r25	; 0x04
    62c0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    62c4:	0f 90       	pop	r0
    62c6:	0f 90       	pop	r0
    62c8:	0f 90       	pop	r0
    62ca:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_SYN)
    62cc:	d8 01       	movw	r26, r16
    62ce:	1d 96       	adiw	r26, 0x0d	; 13
    62d0:	8c 91       	ld	r24, X
    62d2:	1d 97       	sbiw	r26, 0x0d	; 13
    62d4:	81 ff       	sbrs	r24, 1
    62d6:	10 c0       	rjmp	.+32     	; 0x62f8 <netPrintTcpHeader+0x19c>
    fprintf_P(stream, PSTR("SYN "));
    62d8:	00 d0       	rcall	.+0      	; 0x62da <netPrintTcpHeader+0x17e>
    62da:	0f 92       	push	r0
    62dc:	ed b7       	in	r30, 0x3d	; 61
    62de:	fe b7       	in	r31, 0x3e	; 62
    62e0:	c1 83       	std	Z+1, r28	; 0x01
    62e2:	d2 83       	std	Z+2, r29	; 0x02
    62e4:	86 e1       	ldi	r24, 0x16	; 22
    62e6:	99 e0       	ldi	r25, 0x09	; 9
    62e8:	83 83       	std	Z+3, r24	; 0x03
    62ea:	94 83       	std	Z+4, r25	; 0x04
    62ec:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    62f0:	0f 90       	pop	r0
    62f2:	0f 90       	pop	r0
    62f4:	0f 90       	pop	r0
    62f6:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_RST)
    62f8:	d8 01       	movw	r26, r16
    62fa:	1d 96       	adiw	r26, 0x0d	; 13
    62fc:	8c 91       	ld	r24, X
    62fe:	1d 97       	sbiw	r26, 0x0d	; 13
    6300:	82 ff       	sbrs	r24, 2
    6302:	10 c0       	rjmp	.+32     	; 0x6324 <netPrintTcpHeader+0x1c8>
    fprintf_P(stream, PSTR("RST "));
    6304:	00 d0       	rcall	.+0      	; 0x6306 <netPrintTcpHeader+0x1aa>
    6306:	0f 92       	push	r0
    6308:	ed b7       	in	r30, 0x3d	; 61
    630a:	fe b7       	in	r31, 0x3e	; 62
    630c:	c1 83       	std	Z+1, r28	; 0x01
    630e:	d2 83       	std	Z+2, r29	; 0x02
    6310:	81 e1       	ldi	r24, 0x11	; 17
    6312:	99 e0       	ldi	r25, 0x09	; 9
    6314:	83 83       	std	Z+3, r24	; 0x03
    6316:	94 83       	std	Z+4, r25	; 0x04
    6318:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    631c:	0f 90       	pop	r0
    631e:	0f 90       	pop	r0
    6320:	0f 90       	pop	r0
    6322:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_PSH)
    6324:	d8 01       	movw	r26, r16
    6326:	1d 96       	adiw	r26, 0x0d	; 13
    6328:	8c 91       	ld	r24, X
    632a:	1d 97       	sbiw	r26, 0x0d	; 13
    632c:	83 ff       	sbrs	r24, 3
    632e:	10 c0       	rjmp	.+32     	; 0x6350 <netPrintTcpHeader+0x1f4>
    fprintf_P(stream, PSTR("PSH "));
    6330:	00 d0       	rcall	.+0      	; 0x6332 <netPrintTcpHeader+0x1d6>
    6332:	0f 92       	push	r0
    6334:	ed b7       	in	r30, 0x3d	; 61
    6336:	fe b7       	in	r31, 0x3e	; 62
    6338:	c1 83       	std	Z+1, r28	; 0x01
    633a:	d2 83       	std	Z+2, r29	; 0x02
    633c:	8c e0       	ldi	r24, 0x0C	; 12
    633e:	99 e0       	ldi	r25, 0x09	; 9
    6340:	83 83       	std	Z+3, r24	; 0x03
    6342:	94 83       	std	Z+4, r25	; 0x04
    6344:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6348:	0f 90       	pop	r0
    634a:	0f 90       	pop	r0
    634c:	0f 90       	pop	r0
    634e:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_ACK)
    6350:	d8 01       	movw	r26, r16
    6352:	1d 96       	adiw	r26, 0x0d	; 13
    6354:	8c 91       	ld	r24, X
    6356:	1d 97       	sbiw	r26, 0x0d	; 13
    6358:	84 ff       	sbrs	r24, 4
    635a:	10 c0       	rjmp	.+32     	; 0x637c <netPrintTcpHeader+0x220>
    fprintf_P(stream, PSTR("ACK "));
    635c:	00 d0       	rcall	.+0      	; 0x635e <netPrintTcpHeader+0x202>
    635e:	0f 92       	push	r0
    6360:	ed b7       	in	r30, 0x3d	; 61
    6362:	fe b7       	in	r31, 0x3e	; 62
    6364:	c1 83       	std	Z+1, r28	; 0x01
    6366:	d2 83       	std	Z+2, r29	; 0x02
    6368:	87 e0       	ldi	r24, 0x07	; 7
    636a:	99 e0       	ldi	r25, 0x09	; 9
    636c:	83 83       	std	Z+3, r24	; 0x03
    636e:	94 83       	std	Z+4, r25	; 0x04
    6370:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6374:	0f 90       	pop	r0
    6376:	0f 90       	pop	r0
    6378:	0f 90       	pop	r0
    637a:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_URG)
    637c:	d8 01       	movw	r26, r16
    637e:	1d 96       	adiw	r26, 0x0d	; 13
    6380:	8c 91       	ld	r24, X
    6382:	1d 97       	sbiw	r26, 0x0d	; 13
    6384:	85 ff       	sbrs	r24, 5
    6386:	10 c0       	rjmp	.+32     	; 0x63a8 <netPrintTcpHeader+0x24c>
    fprintf_P(stream, PSTR("URG "));
    6388:	00 d0       	rcall	.+0      	; 0x638a <netPrintTcpHeader+0x22e>
    638a:	0f 92       	push	r0
    638c:	ed b7       	in	r30, 0x3d	; 61
    638e:	fe b7       	in	r31, 0x3e	; 62
    6390:	c1 83       	std	Z+1, r28	; 0x01
    6392:	d2 83       	std	Z+2, r29	; 0x02
    6394:	82 e0       	ldi	r24, 0x02	; 2
    6396:	99 e0       	ldi	r25, 0x09	; 9
    6398:	83 83       	std	Z+3, r24	; 0x03
    639a:	94 83       	std	Z+4, r25	; 0x04
    639c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    63a0:	0f 90       	pop	r0
    63a2:	0f 90       	pop	r0
    63a4:	0f 90       	pop	r0
    63a6:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    63a8:	00 d0       	rcall	.+0      	; 0x63aa <netPrintTcpHeader+0x24e>
    63aa:	0f 92       	push	r0
    63ac:	ad b7       	in	r26, 0x3d	; 61
    63ae:	be b7       	in	r27, 0x3e	; 62
    63b0:	11 96       	adiw	r26, 0x01	; 1
    63b2:	cd 93       	st	X+, r28
    63b4:	dc 93       	st	X, r29
    63b6:	12 97       	sbiw	r26, 0x02	; 2
    63b8:	8f ef       	ldi	r24, 0xFF	; 255
    63ba:	98 e0       	ldi	r25, 0x08	; 8
    63bc:	13 96       	adiw	r26, 0x03	; 3
    63be:	8d 93       	st	X+, r24
    63c0:	9c 93       	st	X, r25
    63c2:	14 97       	sbiw	r26, 0x04	; 4
    63c4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    63c8:	0f 90       	pop	r0
    63ca:	0f 90       	pop	r0
    63cc:	0f 90       	pop	r0
    63ce:	0f 90       	pop	r0
}
    63d0:	df 91       	pop	r29
    63d2:	cf 91       	pop	r28
    63d4:	1f 91       	pop	r17
    63d6:	0f 91       	pop	r16
    63d8:	08 95       	ret

000063da <ipInit>:
static uint32_t mask_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_MASK4 << 24) + ((uint32_t)MY_MASK3 <<16) + ((uint32_t)MY_MASK2 <<8) + MY_MASK1;
static uint32_t defGw_eep   __attribute__((section (".eeprom"))) = ((uint32_t)MY_GW4   << 24) + ((uint32_t)MY_GW3   <<16) + ((uint32_t)MY_GW2   <<8) + MY_GW1;

void ipInit(void)
{
  IpMyConfig.ip      = eeprom_read_dword(&myip_eep);
    63da:	8e e1       	ldi	r24, 0x1E	; 30
    63dc:	90 e0       	ldi	r25, 0x00	; 0
    63de:	0e 94 73 5a 	call	0xb4e6	; 0xb4e6 <__eerd_dword_x128a1>
    63e2:	60 93 b2 32 	sts	0x32B2, r22
    63e6:	70 93 b3 32 	sts	0x32B3, r23
    63ea:	80 93 b4 32 	sts	0x32B4, r24
    63ee:	90 93 b5 32 	sts	0x32B5, r25
  IpMyConfig.netmask = eeprom_read_dword(&mask_eep);
    63f2:	82 e2       	ldi	r24, 0x22	; 34
    63f4:	90 e0       	ldi	r25, 0x00	; 0
    63f6:	0e 94 73 5a 	call	0xb4e6	; 0xb4e6 <__eerd_dword_x128a1>
    63fa:	60 93 b6 32 	sts	0x32B6, r22
    63fe:	70 93 b7 32 	sts	0x32B7, r23
    6402:	80 93 b8 32 	sts	0x32B8, r24
    6406:	90 93 b9 32 	sts	0x32B9, r25
  IpMyConfig.gateway = eeprom_read_dword(&defGw_eep);
    640a:	86 e2       	ldi	r24, 0x26	; 38
    640c:	90 e0       	ldi	r25, 0x00	; 0
    640e:	0e 94 73 5a 	call	0xb4e6	; 0xb4e6 <__eerd_dword_x128a1>
    6412:	60 93 ba 32 	sts	0x32BA, r22
    6416:	70 93 bb 32 	sts	0x32BB, r23
    641a:	80 93 bc 32 	sts	0x32BC, r24
    641e:	90 93 bd 32 	sts	0x32BD, r25
#if IP_DEBUG
  IpMyConfig.dbgLevel = 0;
    6422:	10 92 c0 32 	sts	0x32C0, r1
  IpMyConfig.dbgStream = NULL;
    6426:	10 92 be 32 	sts	0x32BE, r1
    642a:	10 92 bf 32 	sts	0x32BF, r1
#endif
}
    642e:	08 95       	ret

00006430 <ipSaveConfig>:

void ipSaveConfig(void)
{
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
    6430:	40 91 b2 32 	lds	r20, 0x32B2
    6434:	50 91 b3 32 	lds	r21, 0x32B3
    6438:	60 91 b4 32 	lds	r22, 0x32B4
    643c:	70 91 b5 32 	lds	r23, 0x32B5
    6440:	8e e1       	ldi	r24, 0x1E	; 30
    6442:	90 e0       	ldi	r25, 0x00	; 0
    6444:	0e 94 9a 5a 	call	0xb534	; 0xb534 <__eeupd_dword_x128a1>
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
    6448:	40 91 b6 32 	lds	r20, 0x32B6
    644c:	50 91 b7 32 	lds	r21, 0x32B7
    6450:	60 91 b8 32 	lds	r22, 0x32B8
    6454:	70 91 b9 32 	lds	r23, 0x32B9
    6458:	82 e2       	ldi	r24, 0x22	; 34
    645a:	90 e0       	ldi	r25, 0x00	; 0
    645c:	0e 94 9a 5a 	call	0xb534	; 0xb534 <__eeupd_dword_x128a1>
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    6460:	40 91 ba 32 	lds	r20, 0x32BA
    6464:	50 91 bb 32 	lds	r21, 0x32BB
    6468:	60 91 bc 32 	lds	r22, 0x32BC
    646c:	70 91 bd 32 	lds	r23, 0x32BD
    6470:	86 e2       	ldi	r24, 0x26	; 38
    6472:	90 e0       	ldi	r25, 0x00	; 0
    6474:	0e 94 9a 5a 	call	0xb534	; 0xb534 <__eeupd_dword_x128a1>
}
    6478:	08 95       	ret

0000647a <netstackIPv4Process>:

inline void netstackIPv4Process(void)
{
    647a:	ef 92       	push	r14
    647c:	ff 92       	push	r15
    647e:	0f 93       	push	r16
    6480:	1f 93       	push	r17
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    6482:	e0 91 e8 31 	lds	r30, 0x31E8
    6486:	f0 91 e9 31 	lds	r31, 0x31E9
    648a:	80 89       	ldd	r24, Z+16	; 0x10
    648c:	91 89       	ldd	r25, Z+17	; 0x11
    648e:	a2 89       	ldd	r26, Z+18	; 0x12
    6490:	b3 89       	ldd	r27, Z+19	; 0x13
    6492:	e0 90 b2 32 	lds	r14, 0x32B2
    6496:	f0 90 b3 32 	lds	r15, 0x32B3
    649a:	00 91 b4 32 	lds	r16, 0x32B4
    649e:	10 91 b5 32 	lds	r17, 0x32B5
    64a2:	8e 15       	cp	r24, r14
    64a4:	9f 05       	cpc	r25, r15
    64a6:	a0 07       	cpc	r26, r16
    64a8:	b1 07       	cpc	r27, r17
    64aa:	d1 f0       	breq	.+52     	; 0x64e0 <netstackIPv4Process+0x66>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    64ac:	20 91 b6 32 	lds	r18, 0x32B6
    64b0:	30 91 b7 32 	lds	r19, 0x32B7
    64b4:	40 91 b8 32 	lds	r20, 0x32B8
    64b8:	50 91 b9 32 	lds	r21, 0x32B9
    64bc:	2e 29       	or	r18, r14
    64be:	3f 29       	or	r19, r15
    64c0:	40 2b       	or	r20, r16
    64c2:	51 2b       	or	r21, r17
}

inline void netstackIPv4Process(void)
{
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    64c4:	82 17       	cp	r24, r18
    64c6:	93 07       	cpc	r25, r19
    64c8:	a4 07       	cpc	r26, r20
    64ca:	b5 07       	cpc	r27, r21
    64cc:	49 f0       	breq	.+18     	; 0x64e0 <netstackIPv4Process+0x66>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
    64ce:	8f 3f       	cpi	r24, 0xFF	; 255
    64d0:	2f ef       	ldi	r18, 0xFF	; 255
    64d2:	92 07       	cpc	r25, r18
    64d4:	2f ef       	ldi	r18, 0xFF	; 255
    64d6:	a2 07       	cpc	r26, r18
    64d8:	2f ef       	ldi	r18, 0xFF	; 255
    64da:	b2 07       	cpc	r27, r18
    64dc:	09 f0       	breq	.+2      	; 0x64e0 <netstackIPv4Process+0x66>
    64de:	86 c0       	rjmp	.+268    	; 0x65ec <netstackIPv4Process+0x172>
      (nicState.layer3.ip->destipaddr != 0xFFFFFFFF)) 
    return;

// handle ICMP packet
  if(nicState.layer3.ip->proto == IP_PROTO_ICMP)
    64e0:	21 85       	ldd	r18, Z+9	; 0x09
    64e2:	21 30       	cpi	r18, 0x01	; 1
    64e4:	79 f5       	brne	.+94     	; 0x6544 <netstackIPv4Process+0xca>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    64e6:	80 91 be 32 	lds	r24, 0x32BE
    64ea:	90 91 bf 32 	lds	r25, 0x32BF
    64ee:	00 97       	sbiw	r24, 0x00	; 0
    64f0:	31 f1       	breq	.+76     	; 0x653e <netstackIPv4Process+0xc4>
    {
      if (IpMyConfig.dbgLevel > 0)
    64f2:	20 91 c0 32 	lds	r18, 0x32C0
    64f6:	22 23       	and	r18, r18
    64f8:	81 f0       	breq	.+32     	; 0x651a <netstackIPv4Process+0xa0>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
    64fa:	00 d0       	rcall	.+0      	; 0x64fc <netstackIPv4Process+0x82>
    64fc:	0f 92       	push	r0
    64fe:	ed b7       	in	r30, 0x3d	; 61
    6500:	fe b7       	in	r31, 0x3e	; 62
    6502:	81 83       	std	Z+1, r24	; 0x01
    6504:	92 83       	std	Z+2, r25	; 0x02
    6506:	8c e6       	ldi	r24, 0x6C	; 108
    6508:	9b e0       	ldi	r25, 0x0B	; 11
    650a:	83 83       	std	Z+3, r24	; 0x03
    650c:	94 83       	std	Z+4, r25	; 0x04
    650e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6512:	0f 90       	pop	r0
    6514:	0f 90       	pop	r0
    6516:	0f 90       	pop	r0
    6518:	0f 90       	pop	r0
      if (IpMyConfig.dbgLevel > 2)
    651a:	80 91 c0 32 	lds	r24, 0x32C0
    651e:	83 30       	cpi	r24, 0x03	; 3
    6520:	70 f0       	brcs	.+28     	; 0x653e <netstackIPv4Process+0xc4>
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    6522:	60 91 e8 31 	lds	r22, 0x31E8
    6526:	70 91 e9 31 	lds	r23, 0x31E9
    652a:	40 91 ea 31 	lds	r20, 0x31EA
    652e:	50 91 eb 31 	lds	r21, 0x31EB
    6532:	80 91 be 32 	lds	r24, 0x32BE
    6536:	90 91 bf 32 	lds	r25, 0x32BF
    653a:	0e 94 d1 34 	call	0x69a2	; 0x69a2 <icmpPrintHeader>
    }
#endif /*IP_DEBUG*/
    icmpIpIn();
    653e:	0e 94 2c 36 	call	0x6c58	; 0x6c58 <icmpIpIn>
    return;
    6542:	54 c0       	rjmp	.+168    	; 0x65ec <netstackIPv4Process+0x172>
  }
  if( nicState.layer3.ip->proto == IP_PROTO_UDP )
    6544:	21 31       	cpi	r18, 0x11	; 17
    6546:	e9 f4       	brne	.+58     	; 0x6582 <netstackIPv4Process+0x108>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    6548:	80 91 be 32 	lds	r24, 0x32BE
    654c:	90 91 bf 32 	lds	r25, 0x32BF
    6550:	00 97       	sbiw	r24, 0x00	; 0
    6552:	a1 f0       	breq	.+40     	; 0x657c <netstackIPv4Process+0x102>
    {
      if (IpMyConfig.dbgLevel > 0)
    6554:	20 91 c0 32 	lds	r18, 0x32C0
    6558:	22 23       	and	r18, r18
    655a:	81 f0       	breq	.+32     	; 0x657c <netstackIPv4Process+0x102>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    655c:	00 d0       	rcall	.+0      	; 0x655e <netstackIPv4Process+0xe4>
    655e:	0f 92       	push	r0
    6560:	ed b7       	in	r30, 0x3d	; 61
    6562:	fe b7       	in	r31, 0x3e	; 62
    6564:	81 83       	std	Z+1, r24	; 0x01
    6566:	92 83       	std	Z+2, r25	; 0x02
    6568:	84 e5       	ldi	r24, 0x54	; 84
    656a:	9b e0       	ldi	r25, 0x0B	; 11
    656c:	83 83       	std	Z+3, r24	; 0x03
    656e:	94 83       	std	Z+4, r25	; 0x04
    6570:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6574:	0f 90       	pop	r0
    6576:	0f 90       	pop	r0
    6578:	0f 90       	pop	r0
    657a:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackUDPIPProcess();
    657c:	0e 94 bb 3d 	call	0x7b76	; 0x7b76 <netstackUDPIPProcess>
    return;
    6580:	35 c0       	rjmp	.+106    	; 0x65ec <netstackIPv4Process+0x172>
    6582:	80 91 be 32 	lds	r24, 0x32BE
    6586:	90 91 bf 32 	lds	r25, 0x32BF
  }
  if( nicState.layer3.ip->proto == IP_PROTO_TCP )
    658a:	26 30       	cpi	r18, 0x06	; 6
    658c:	c9 f4       	brne	.+50     	; 0x65c0 <netstackIPv4Process+0x146>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    658e:	00 97       	sbiw	r24, 0x00	; 0
    6590:	a1 f0       	breq	.+40     	; 0x65ba <netstackIPv4Process+0x140>
    {
      if (IpMyConfig.dbgLevel > 0)
    6592:	20 91 c0 32 	lds	r18, 0x32C0
    6596:	22 23       	and	r18, r18
    6598:	81 f0       	breq	.+32     	; 0x65ba <netstackIPv4Process+0x140>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: TCP/IP packet\r\n"));
    659a:	00 d0       	rcall	.+0      	; 0x659c <netstackIPv4Process+0x122>
    659c:	0f 92       	push	r0
    659e:	ed b7       	in	r30, 0x3d	; 61
    65a0:	fe b7       	in	r31, 0x3e	; 62
    65a2:	81 83       	std	Z+1, r24	; 0x01
    65a4:	92 83       	std	Z+2, r25	; 0x02
    65a6:	8c e3       	ldi	r24, 0x3C	; 60
    65a8:	9b e0       	ldi	r25, 0x0B	; 11
    65aa:	83 83       	std	Z+3, r24	; 0x03
    65ac:	94 83       	std	Z+4, r25	; 0x04
    65ae:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    65b2:	0f 90       	pop	r0
    65b4:	0f 90       	pop	r0
    65b6:	0f 90       	pop	r0
    65b8:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackTCPIPProcess();
    65ba:	0e 94 d2 3c 	call	0x79a4	; 0x79a4 <netstackTCPIPProcess>
    return;
    65be:	16 c0       	rjmp	.+44     	; 0x65ec <netstackIPv4Process+0x172>
  }
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    65c0:	00 97       	sbiw	r24, 0x00	; 0
    65c2:	a1 f0       	breq	.+40     	; 0x65ec <netstackIPv4Process+0x172>
  {
    if (IpMyConfig.dbgLevel > 0)
    65c4:	20 91 c0 32 	lds	r18, 0x32C0
    65c8:	22 23       	and	r18, r18
    65ca:	81 f0       	breq	.+32     	; 0x65ec <netstackIPv4Process+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
    65cc:	00 d0       	rcall	.+0      	; 0x65ce <netstackIPv4Process+0x154>
    65ce:	0f 92       	push	r0
    65d0:	ed b7       	in	r30, 0x3d	; 61
    65d2:	fe b7       	in	r31, 0x3e	; 62
    65d4:	81 83       	std	Z+1, r24	; 0x01
    65d6:	92 83       	std	Z+2, r25	; 0x02
    65d8:	80 e2       	ldi	r24, 0x20	; 32
    65da:	9b e0       	ldi	r25, 0x0B	; 11
    65dc:	83 83       	std	Z+3, r24	; 0x03
    65de:	94 83       	std	Z+4, r25	; 0x04
    65e0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    65e4:	0f 90       	pop	r0
    65e6:	0f 90       	pop	r0
    65e8:	0f 90       	pop	r0
    65ea:	0f 90       	pop	r0
  }
#endif /*IP_DEBUG*/
}
    65ec:	1f 91       	pop	r17
    65ee:	0f 91       	pop	r16
    65f0:	ff 90       	pop	r15
    65f2:	ef 90       	pop	r14
    65f4:	08 95       	ret

000065f6 <setIpDebug>:

#if IP_DEBUG
void setIpDebug(FILE *stream, uint8_t level)
{
  IpMyConfig.dbgStream = stream;
    65f6:	80 93 be 32 	sts	0x32BE, r24
    65fa:	90 93 bf 32 	sts	0x32BF, r25
  IpMyConfig.dbgLevel = level;
    65fe:	60 93 c0 32 	sts	0x32C0, r22
  if (level == 0)
    6602:	66 23       	and	r22, r22
    6604:	21 f4       	brne	.+8      	; 0x660e <setIpDebug+0x18>
    IpMyConfig.dbgStream = NULL;
    6606:	10 92 be 32 	sts	0x32BE, r1
    660a:	10 92 bf 32 	sts	0x32BF, r1
    660e:	08 95       	ret

00006610 <ipSetConfig>:
}
#endif

void ipSetConfig(uint32_t myIp, uint32_t netmask, uint32_t gatewayIp)
{
    6610:	ef 92       	push	r14
    6612:	ff 92       	push	r15
    6614:	0f 93       	push	r16
    6616:	1f 93       	push	r17
  // set local addressing
  IpMyConfig.ip = myIp;
    6618:	60 93 b2 32 	sts	0x32B2, r22
    661c:	70 93 b3 32 	sts	0x32B3, r23
    6620:	80 93 b4 32 	sts	0x32B4, r24
    6624:	90 93 b5 32 	sts	0x32B5, r25
  IpMyConfig.netmask = netmask;
    6628:	20 93 b6 32 	sts	0x32B6, r18
    662c:	30 93 b7 32 	sts	0x32B7, r19
    6630:	40 93 b8 32 	sts	0x32B8, r20
    6634:	50 93 b9 32 	sts	0x32B9, r21
  IpMyConfig.gateway = gatewayIp;
    6638:	e0 92 ba 32 	sts	0x32BA, r14
    663c:	f0 92 bb 32 	sts	0x32BB, r15
    6640:	00 93 bc 32 	sts	0x32BC, r16
    6644:	10 93 bd 32 	sts	0x32BD, r17
}
    6648:	1f 91       	pop	r17
    664a:	0f 91       	pop	r16
    664c:	ff 90       	pop	r15
    664e:	ef 90       	pop	r14
    6650:	08 95       	ret

00006652 <ipSetConfigIp>:

void ipSetConfigIp(uint32_t myIp)
{
  // set local addressing
  IpMyConfig.ip = myIp; 
    6652:	60 93 b2 32 	sts	0x32B2, r22
    6656:	70 93 b3 32 	sts	0x32B3, r23
    665a:	80 93 b4 32 	sts	0x32B4, r24
    665e:	90 93 b5 32 	sts	0x32B5, r25
}
    6662:	08 95       	ret

00006664 <ipSetConfigMask>:

void ipSetConfigMask(uint32_t netmask)
{
  IpMyConfig.netmask = netmask;
    6664:	60 93 b6 32 	sts	0x32B6, r22
    6668:	70 93 b7 32 	sts	0x32B7, r23
    666c:	80 93 b8 32 	sts	0x32B8, r24
    6670:	90 93 b9 32 	sts	0x32B9, r25
}
    6674:	08 95       	ret

00006676 <ipSetConfigGw>:

void ipSetConfigGw(uint32_t gatewayIp)
{
  IpMyConfig.gateway = gatewayIp;
    6676:	60 93 ba 32 	sts	0x32BA, r22
    667a:	70 93 bb 32 	sts	0x32BB, r23
    667e:	80 93 bc 32 	sts	0x32BC, r24
    6682:	90 93 bd 32 	sts	0x32BD, r25
}
    6686:	08 95       	ret

00006688 <ipGetConfig>:


struct ipConfig* ipGetConfig(void)
{
  return &IpMyConfig;
}
    6688:	82 eb       	ldi	r24, 0xB2	; 178
    668a:	92 e3       	ldi	r25, 0x32	; 50
    668c:	08 95       	ret

0000668e <ipSend>:

void ipSend(uint32_t dstIp, uint8_t protocol, uint16_t len)
{
    668e:	af 92       	push	r10
    6690:	bf 92       	push	r11
    6692:	cf 92       	push	r12
    6694:	df 92       	push	r13
    6696:	ef 92       	push	r14
    6698:	ff 92       	push	r15
    669a:	0f 93       	push	r16
    669c:	1f 93       	push	r17
    669e:	df 93       	push	r29
    66a0:	cf 93       	push	r28
    66a2:	0f 92       	push	r0
    66a4:	cd b7       	in	r28, 0x3d	; 61
    66a6:	de b7       	in	r29, 0x3e	; 62
    66a8:	6b 01       	movw	r12, r22
    66aa:	7c 01       	movw	r14, r24
    66ac:	89 01       	movw	r16, r18
// make pointer to ethernet/IP header
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    66ae:	80 91 be 32 	lds	r24, 0x32BE
    66b2:	90 91 bf 32 	lds	r25, 0x32BF
    66b6:	00 97       	sbiw	r24, 0x00	; 0
    66b8:	b1 f0       	breq	.+44     	; 0x66e6 <ipSend+0x58>
  {  
    if (IpMyConfig.dbgLevel > 2)
    66ba:	20 91 c0 32 	lds	r18, 0x32C0
    66be:	23 30       	cpi	r18, 0x03	; 3
    66c0:	90 f0       	brcs	.+36     	; 0x66e6 <ipSend+0x58>
      fprintf_P(IpMyConfig.dbgStream, "Sending Ip packet\r\n");
    66c2:	00 d0       	rcall	.+0      	; 0x66c4 <ipSend+0x36>
    66c4:	0f 92       	push	r0
    66c6:	ed b7       	in	r30, 0x3d	; 61
    66c8:	fe b7       	in	r31, 0x3e	; 62
    66ca:	81 83       	std	Z+1, r24	; 0x01
    66cc:	92 83       	std	Z+2, r25	; 0x02
    66ce:	82 e0       	ldi	r24, 0x02	; 2
    66d0:	95 e2       	ldi	r25, 0x25	; 37
    66d2:	83 83       	std	Z+3, r24	; 0x03
    66d4:	94 83       	std	Z+4, r25	; 0x04
    66d6:	49 83       	std	Y+1, r20	; 0x01
    66d8:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    66dc:	0f 90       	pop	r0
    66de:	0f 90       	pop	r0
    66e0:	0f 90       	pop	r0
    66e2:	0f 90       	pop	r0
    66e4:	49 81       	ldd	r20, Y+1	; 0x01
  }
#endif

// adjust length to add IP header
  len += IP_HEADER_LEN;
    66e6:	0c 5e       	subi	r16, 0xEC	; 236
    66e8:	1f 4f       	sbci	r17, 0xFF	; 255

// fill IP header
  nicState.layer3.ip->destipaddr = dstIp;
    66ea:	e0 91 e8 31 	lds	r30, 0x31E8
    66ee:	f0 91 e9 31 	lds	r31, 0x31E9
    66f2:	c0 8a       	std	Z+16, r12	; 0x10
    66f4:	d1 8a       	std	Z+17, r13	; 0x11
    66f6:	e2 8a       	std	Z+18, r14	; 0x12
    66f8:	f3 8a       	std	Z+19, r15	; 0x13
  nicState.layer3.ip->srcipaddr  = IpMyConfig.ip;
    66fa:	80 91 b2 32 	lds	r24, 0x32B2
    66fe:	90 91 b3 32 	lds	r25, 0x32B3
    6702:	a0 91 b4 32 	lds	r26, 0x32B4
    6706:	b0 91 b5 32 	lds	r27, 0x32B5
    670a:	84 87       	std	Z+12, r24	; 0x0c
    670c:	95 87       	std	Z+13, r25	; 0x0d
    670e:	a6 87       	std	Z+14, r26	; 0x0e
    6710:	b7 87       	std	Z+15, r27	; 0x0f
  nicState.layer3.ip->proto      = protocol;
    6712:	41 87       	std	Z+9, r20	; 0x09
  nicState.layer3.ip->len        = htons(len);
    6714:	a0 90 e8 31 	lds	r10, 0x31E8
    6718:	b0 90 e9 31 	lds	r11, 0x31E9
    671c:	c8 01       	movw	r24, r16
    671e:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    6722:	f5 01       	movw	r30, r10
    6724:	82 83       	std	Z+2, r24	; 0x02
    6726:	93 83       	std	Z+3, r25	; 0x03
  nicState.layer3.ip->vhl        = 0x45;
    6728:	e0 91 e8 31 	lds	r30, 0x31E8
    672c:	f0 91 e9 31 	lds	r31, 0x31E9
    6730:	85 e4       	ldi	r24, 0x45	; 69
    6732:	80 83       	st	Z, r24
  nicState.layer3.ip->tos        = 0;
    6734:	e0 91 e8 31 	lds	r30, 0x31E8
    6738:	f0 91 e9 31 	lds	r31, 0x31E9
    673c:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ip->ipid       = 0;
    673e:	e0 91 e8 31 	lds	r30, 0x31E8
    6742:	f0 91 e9 31 	lds	r31, 0x31E9
    6746:	14 82       	std	Z+4, r1	; 0x04
    6748:	15 82       	std	Z+5, r1	; 0x05
  nicState.layer3.ip->ipoffset   = 0;
    674a:	e0 91 e8 31 	lds	r30, 0x31E8
    674e:	f0 91 e9 31 	lds	r31, 0x31E9
    6752:	16 82       	std	Z+6, r1	; 0x06
    6754:	17 82       	std	Z+7, r1	; 0x07
  nicState.layer3.ip->ttl        = IP_TIME_TO_LIVE;
    6756:	e0 91 e8 31 	lds	r30, 0x31E8
    675a:	f0 91 e9 31 	lds	r31, 0x31E9
    675e:	80 e8       	ldi	r24, 0x80	; 128
    6760:	80 87       	std	Z+8, r24	; 0x08
  nicState.layer3.ip->ipchksum   = 0;
    6762:	e0 91 e8 31 	lds	r30, 0x31E8
    6766:	f0 91 e9 31 	lds	r31, 0x31E9
    676a:	12 86       	std	Z+10, r1	; 0x0a
    676c:	13 86       	std	Z+11, r1	; 0x0b

// calculate and apply IP checksum
// DO THIS ONLY AFTER ALL CHANGES HAVE BEEN MADE TO IP HEADER
  nicState.layer3.ip->ipchksum   = netChecksum((uint8_t *)(nicState.layer3.ip), IP_HEADER_LEN);
    676e:	a0 90 e8 31 	lds	r10, 0x31E8
    6772:	b0 90 e9 31 	lds	r11, 0x31E9
    6776:	c5 01       	movw	r24, r10
    6778:	64 e1       	ldi	r22, 0x14	; 20
    677a:	70 e0       	ldi	r23, 0x00	; 0
    677c:	0e 94 bb 2e 	call	0x5d76	; 0x5d76 <netChecksum>
    6780:	f5 01       	movw	r30, r10
    6782:	82 87       	std	Z+10, r24	; 0x0a
    6784:	93 87       	std	Z+11, r25	; 0x0b

// add ethernet routing
// check if we need to send to gateway
  if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    6786:	80 91 b2 32 	lds	r24, 0x32B2
    678a:	90 91 b3 32 	lds	r25, 0x32B3
    678e:	a0 91 b4 32 	lds	r26, 0x32B4
    6792:	b0 91 b5 32 	lds	r27, 0x32B5
    6796:	8c 25       	eor	r24, r12
    6798:	9d 25       	eor	r25, r13
    679a:	ae 25       	eor	r26, r14
    679c:	bf 25       	eor	r27, r15
    679e:	20 91 b6 32 	lds	r18, 0x32B6
    67a2:	30 91 b7 32 	lds	r19, 0x32B7
    67a6:	40 91 b8 32 	lds	r20, 0x32B8
    67aa:	50 91 b9 32 	lds	r21, 0x32B9
    67ae:	82 23       	and	r24, r18
    67b0:	93 23       	and	r25, r19
    67b2:	a4 23       	and	r26, r20
    67b4:	b5 23       	and	r27, r21
    67b6:	00 97       	sbiw	r24, 0x00	; 0
    67b8:	a1 05       	cpc	r26, r1
    67ba:	b1 05       	cpc	r27, r1
    67bc:	a1 f4       	brne	.+40     	; 0x67e6 <ipSend+0x158>
  {
    arpIpOut(0);  // local send
    67be:	60 e0       	ldi	r22, 0x00	; 0
    67c0:	70 e0       	ldi	r23, 0x00	; 0
    67c2:	cb 01       	movw	r24, r22
    67c4:	0e 94 8e 36 	call	0x6d1c	; 0x6d1c <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    67c8:	80 91 be 32 	lds	r24, 0x32BE
    67cc:	90 91 bf 32 	lds	r25, 0x32BF
    67d0:	00 97       	sbiw	r24, 0x00	; 0
    67d2:	49 f1       	breq	.+82     	; 0x6826 <ipSend+0x198>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet on local net\r\n"));
    67d4:	00 d0       	rcall	.+0      	; 0x67d6 <ipSend+0x148>
    67d6:	0f 92       	push	r0
    67d8:	ed b7       	in	r30, 0x3d	; 61
    67da:	fe b7       	in	r31, 0x3e	; 62
    67dc:	81 83       	std	Z+1, r24	; 0x01
    67de:	92 83       	std	Z+2, r25	; 0x02
    67e0:	8f ef       	ldi	r24, 0xFF	; 255
    67e2:	9a e0       	ldi	r25, 0x0A	; 10
    67e4:	18 c0       	rjmp	.+48     	; 0x6816 <ipSend+0x188>
#endif
  }
  else
  {
    arpIpOut(IpMyConfig.gateway);  // gateway send
    67e6:	60 91 ba 32 	lds	r22, 0x32BA
    67ea:	70 91 bb 32 	lds	r23, 0x32BB
    67ee:	80 91 bc 32 	lds	r24, 0x32BC
    67f2:	90 91 bd 32 	lds	r25, 0x32BD
    67f6:	0e 94 8e 36 	call	0x6d1c	; 0x6d1c <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    67fa:	80 91 be 32 	lds	r24, 0x32BE
    67fe:	90 91 bf 32 	lds	r25, 0x32BF
    6802:	00 97       	sbiw	r24, 0x00	; 0
    6804:	81 f0       	breq	.+32     	; 0x6826 <ipSend+0x198>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet to gateway\r\n"));
    6806:	00 d0       	rcall	.+0      	; 0x6808 <ipSend+0x17a>
    6808:	0f 92       	push	r0
    680a:	ed b7       	in	r30, 0x3d	; 61
    680c:	fe b7       	in	r31, 0x3e	; 62
    680e:	81 83       	std	Z+1, r24	; 0x01
    6810:	92 83       	std	Z+2, r25	; 0x02
    6812:	80 ee       	ldi	r24, 0xE0	; 224
    6814:	9a e0       	ldi	r25, 0x0A	; 10
    6816:	83 83       	std	Z+3, r24	; 0x03
    6818:	94 83       	std	Z+4, r25	; 0x04
    681a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    681e:	0f 90       	pop	r0
    6820:	0f 90       	pop	r0
    6822:	0f 90       	pop	r0
    6824:	0f 90       	pop	r0
#endif
  }

// adjust length to add ethernet header
  len += ETH_HEADER_LEN;
    6826:	02 5f       	subi	r16, 0xF2	; 242
    6828:	1f 4f       	sbci	r17, 0xFF	; 255

#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    682a:	80 91 be 32 	lds	r24, 0x32BE
    682e:	90 91 bf 32 	lds	r25, 0x32BF
    6832:	00 97       	sbiw	r24, 0x00	; 0
    6834:	11 f1       	breq	.+68     	; 0x687a <ipSend+0x1ec>
  {
    if (IpMyConfig.dbgLevel > 3)
    6836:	20 91 c0 32 	lds	r18, 0x32C0
    683a:	24 30       	cpi	r18, 0x04	; 4
    683c:	f0 f0       	brcs	.+60     	; 0x687a <ipSend+0x1ec>
    {
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(ETH_HEADER_LEN, &data[0]);"));
    683e:	00 d0       	rcall	.+0      	; 0x6840 <ipSend+0x1b2>
    6840:	0f 92       	push	r0
    6842:	ed b7       	in	r30, 0x3d	; 61
    6844:	fe b7       	in	r31, 0x3e	; 62
    6846:	81 83       	std	Z+1, r24	; 0x01
    6848:	92 83       	std	Z+2, r25	; 0x02
    684a:	82 eb       	ldi	r24, 0xB2	; 178
    684c:	9a e0       	ldi	r25, 0x0A	; 10
    684e:	83 83       	std	Z+3, r24	; 0x03
    6850:	94 83       	std	Z+4, r25	; 0x04
    6852:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    6856:	80 91 be 32 	lds	r24, 0x32BE
    685a:	90 91 bf 32 	lds	r25, 0x32BF
    685e:	ed b7       	in	r30, 0x3d	; 61
    6860:	fe b7       	in	r31, 0x3e	; 62
    6862:	81 83       	std	Z+1, r24	; 0x01
    6864:	92 83       	std	Z+2, r25	; 0x02
    6866:	83 e7       	ldi	r24, 0x73	; 115
    6868:	9a e0       	ldi	r25, 0x0A	; 10
    686a:	83 83       	std	Z+3, r24	; 0x03
    686c:	94 83       	std	Z+4, r25	; 0x04
    686e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6872:	0f 90       	pop	r0
    6874:	0f 90       	pop	r0
    6876:	0f 90       	pop	r0
    6878:	0f 90       	pop	r0
    }
  }
#endif
// send it
  nicSend(len);
    687a:	c8 01       	movw	r24, r16
    687c:	0e 94 1c 2c 	call	0x5838	; 0x5838 <nicSend>
}
    6880:	0f 90       	pop	r0
    6882:	cf 91       	pop	r28
    6884:	df 91       	pop	r29
    6886:	1f 91       	pop	r17
    6888:	0f 91       	pop	r16
    688a:	ff 90       	pop	r15
    688c:	ef 90       	pop	r14
    688e:	df 90       	pop	r13
    6890:	cf 90       	pop	r12
    6892:	bf 90       	pop	r11
    6894:	af 90       	pop	r10
    6896:	08 95       	ret

00006898 <ipPrintConfig>:

void ipPrintConfig(FILE *stream, struct ipConfig* config)
{
    6898:	0f 93       	push	r16
    689a:	1f 93       	push	r17
    689c:	cf 93       	push	r28
    689e:	df 93       	push	r29
    68a0:	ec 01       	movw	r28, r24
    68a2:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Addr : ")); netPrintIPAddr(stream, config->ip);        fprintf_P(stream, PSTR("\r\n"));
    68a4:	00 d0       	rcall	.+0      	; 0x68a6 <ipPrintConfig+0xe>
    68a6:	0f 92       	push	r0
    68a8:	ed b7       	in	r30, 0x3d	; 61
    68aa:	fe b7       	in	r31, 0x3e	; 62
    68ac:	81 83       	std	Z+1, r24	; 0x01
    68ae:	92 83       	std	Z+2, r25	; 0x02
    68b0:	88 e6       	ldi	r24, 0x68	; 104
    68b2:	9a e0       	ldi	r25, 0x0A	; 10
    68b4:	83 83       	std	Z+3, r24	; 0x03
    68b6:	94 83       	std	Z+4, r25	; 0x04
    68b8:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    68bc:	0f 90       	pop	r0
    68be:	0f 90       	pop	r0
    68c0:	0f 90       	pop	r0
    68c2:	0f 90       	pop	r0
    68c4:	f8 01       	movw	r30, r16
    68c6:	40 81       	ld	r20, Z
    68c8:	51 81       	ldd	r21, Z+1	; 0x01
    68ca:	62 81       	ldd	r22, Z+2	; 0x02
    68cc:	73 81       	ldd	r23, Z+3	; 0x03
    68ce:	ce 01       	movw	r24, r28
    68d0:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    68d4:	00 d0       	rcall	.+0      	; 0x68d6 <ipPrintConfig+0x3e>
    68d6:	0f 92       	push	r0
    68d8:	ed b7       	in	r30, 0x3d	; 61
    68da:	fe b7       	in	r31, 0x3e	; 62
    68dc:	c1 83       	std	Z+1, r28	; 0x01
    68de:	d2 83       	std	Z+2, r29	; 0x02
    68e0:	85 e6       	ldi	r24, 0x65	; 101
    68e2:	9a e0       	ldi	r25, 0x0A	; 10
    68e4:	83 83       	std	Z+3, r24	; 0x03
    68e6:	94 83       	std	Z+4, r25	; 0x04
    68e8:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Netmask : ")); netPrintIPAddr(stream, config->netmask);   fprintf_P(stream, PSTR("\r\n"));
    68ec:	ed b7       	in	r30, 0x3d	; 61
    68ee:	fe b7       	in	r31, 0x3e	; 62
    68f0:	c1 83       	std	Z+1, r28	; 0x01
    68f2:	d2 83       	std	Z+2, r29	; 0x02
    68f4:	8a e5       	ldi	r24, 0x5A	; 90
    68f6:	9a e0       	ldi	r25, 0x0A	; 10
    68f8:	83 83       	std	Z+3, r24	; 0x03
    68fa:	94 83       	std	Z+4, r25	; 0x04
    68fc:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6900:	0f 90       	pop	r0
    6902:	0f 90       	pop	r0
    6904:	0f 90       	pop	r0
    6906:	0f 90       	pop	r0
    6908:	f8 01       	movw	r30, r16
    690a:	44 81       	ldd	r20, Z+4	; 0x04
    690c:	55 81       	ldd	r21, Z+5	; 0x05
    690e:	66 81       	ldd	r22, Z+6	; 0x06
    6910:	77 81       	ldd	r23, Z+7	; 0x07
    6912:	ce 01       	movw	r24, r28
    6914:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    6918:	00 d0       	rcall	.+0      	; 0x691a <ipPrintConfig+0x82>
    691a:	0f 92       	push	r0
    691c:	ed b7       	in	r30, 0x3d	; 61
    691e:	fe b7       	in	r31, 0x3e	; 62
    6920:	c1 83       	std	Z+1, r28	; 0x01
    6922:	d2 83       	std	Z+2, r29	; 0x02
    6924:	87 e5       	ldi	r24, 0x57	; 87
    6926:	9a e0       	ldi	r25, 0x0A	; 10
    6928:	83 83       	std	Z+3, r24	; 0x03
    692a:	94 83       	std	Z+4, r25	; 0x04
    692c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("Gateway : ")); netPrintIPAddr(stream, config->gateway);   fprintf_P(stream, PSTR("\r\n"));
    6930:	ed b7       	in	r30, 0x3d	; 61
    6932:	fe b7       	in	r31, 0x3e	; 62
    6934:	c1 83       	std	Z+1, r28	; 0x01
    6936:	d2 83       	std	Z+2, r29	; 0x02
    6938:	8c e4       	ldi	r24, 0x4C	; 76
    693a:	9a e0       	ldi	r25, 0x0A	; 10
    693c:	83 83       	std	Z+3, r24	; 0x03
    693e:	94 83       	std	Z+4, r25	; 0x04
    6940:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6944:	0f 90       	pop	r0
    6946:	0f 90       	pop	r0
    6948:	0f 90       	pop	r0
    694a:	0f 90       	pop	r0
    694c:	f8 01       	movw	r30, r16
    694e:	40 85       	ldd	r20, Z+8	; 0x08
    6950:	51 85       	ldd	r21, Z+9	; 0x09
    6952:	62 85       	ldd	r22, Z+10	; 0x0a
    6954:	73 85       	ldd	r23, Z+11	; 0x0b
    6956:	ce 01       	movw	r24, r28
    6958:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    695c:	00 d0       	rcall	.+0      	; 0x695e <ipPrintConfig+0xc6>
    695e:	0f 92       	push	r0
    6960:	ed b7       	in	r30, 0x3d	; 61
    6962:	fe b7       	in	r31, 0x3e	; 62
    6964:	c1 83       	std	Z+1, r28	; 0x01
    6966:	d2 83       	std	Z+2, r29	; 0x02
    6968:	89 e4       	ldi	r24, 0x49	; 73
    696a:	9a e0       	ldi	r25, 0x0A	; 10
    696c:	83 83       	std	Z+3, r24	; 0x03
    696e:	94 83       	std	Z+4, r25	; 0x04
    6970:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6974:	0f 90       	pop	r0
    6976:	0f 90       	pop	r0
    6978:	0f 90       	pop	r0
    697a:	0f 90       	pop	r0
}
    697c:	df 91       	pop	r29
    697e:	cf 91       	pop	r28
    6980:	1f 91       	pop	r17
    6982:	0f 91       	pop	r16
    6984:	08 95       	ret

00006986 <icmpInit>:


// functions
void icmpInit(void)
{
  icmpDebug = NULL;
    6986:	10 92 0c 32 	sts	0x320C, r1
    698a:	10 92 0d 32 	sts	0x320D, r1
  icmpDebugLevel = 0;
    698e:	10 92 af 32 	sts	0x32AF, r1
}
    6992:	08 95       	ret

00006994 <setIcmpDebug>:
}

#if ICMP_DEBUG
void setIcmpDebug(FILE *stream, uint8_t level)
{
  icmpDebug = stream;
    6994:	80 93 0c 32 	sts	0x320C, r24
    6998:	90 93 0d 32 	sts	0x320D, r25
  icmpDebugLevel = level;
    699c:	60 93 af 32 	sts	0x32AF, r22
}
    69a0:	08 95       	ret

000069a2 <icmpPrintHeader>:
#endif

void icmpPrintHeader(FILE *stream, struct netIpHeader *ipPacket, struct netIcmpHeader *icmpPacket)
{
    69a2:	ef 92       	push	r14
    69a4:	ff 92       	push	r15
    69a6:	0f 93       	push	r16
    69a8:	1f 93       	push	r17
    69aa:	cf 93       	push	r28
    69ac:	df 93       	push	r29
    69ae:	ec 01       	movw	r28, r24
    69b0:	8b 01       	movw	r16, r22
    69b2:	7a 01       	movw	r14, r20
  fprintf_P(stream, PSTR("ICMP Packet:\r\n"));
    69b4:	00 d0       	rcall	.+0      	; 0x69b6 <icmpPrintHeader+0x14>
    69b6:	0f 92       	push	r0
    69b8:	ad b7       	in	r26, 0x3d	; 61
    69ba:	be b7       	in	r27, 0x3e	; 62
    69bc:	11 96       	adiw	r26, 0x01	; 1
    69be:	8d 93       	st	X+, r24
    69c0:	9c 93       	st	X, r25
    69c2:	12 97       	sbiw	r26, 0x02	; 2
    69c4:	88 ed       	ldi	r24, 0xD8	; 216
    69c6:	9b e0       	ldi	r25, 0x0B	; 11
    69c8:	13 96       	adiw	r26, 0x03	; 3
    69ca:	8d 93       	st	X+, r24
    69cc:	9c 93       	st	X, r25
    69ce:	14 97       	sbiw	r26, 0x04	; 4
    69d0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print source IP address
  fprintf_P(stream, PSTR("SrcIpAddr: "));  netPrintIPAddr(stream, ipPacket->srcipaddr);  fprintf_P(stream, PSTR("\r\n"));
    69d4:	ed b7       	in	r30, 0x3d	; 61
    69d6:	fe b7       	in	r31, 0x3e	; 62
    69d8:	c1 83       	std	Z+1, r28	; 0x01
    69da:	d2 83       	std	Z+2, r29	; 0x02
    69dc:	8c ec       	ldi	r24, 0xCC	; 204
    69de:	9b e0       	ldi	r25, 0x0B	; 11
    69e0:	83 83       	std	Z+3, r24	; 0x03
    69e2:	94 83       	std	Z+4, r25	; 0x04
    69e4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    69e8:	0f 90       	pop	r0
    69ea:	0f 90       	pop	r0
    69ec:	0f 90       	pop	r0
    69ee:	0f 90       	pop	r0
    69f0:	d8 01       	movw	r26, r16
    69f2:	1c 96       	adiw	r26, 0x0c	; 12
    69f4:	4d 91       	ld	r20, X+
    69f6:	5d 91       	ld	r21, X+
    69f8:	6d 91       	ld	r22, X+
    69fa:	7c 91       	ld	r23, X
    69fc:	1f 97       	sbiw	r26, 0x0f	; 15
    69fe:	ce 01       	movw	r24, r28
    6a00:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    6a04:	00 d0       	rcall	.+0      	; 0x6a06 <icmpPrintHeader+0x64>
    6a06:	0f 92       	push	r0
    6a08:	ed b7       	in	r30, 0x3d	; 61
    6a0a:	fe b7       	in	r31, 0x3e	; 62
    6a0c:	c1 83       	std	Z+1, r28	; 0x01
    6a0e:	d2 83       	std	Z+2, r29	; 0x02
    6a10:	89 ec       	ldi	r24, 0xC9	; 201
    6a12:	9b e0       	ldi	r25, 0x0B	; 11
    6a14:	83 83       	std	Z+3, r24	; 0x03
    6a16:	94 83       	std	Z+4, r25	; 0x04
    6a18:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print dest IP address
  fprintf_P(stream, PSTR("DstIpAddr: "));  netPrintIPAddr(stream, ipPacket->destipaddr); fprintf_P(stream, PSTR("\r\n"));
    6a1c:	ad b7       	in	r26, 0x3d	; 61
    6a1e:	be b7       	in	r27, 0x3e	; 62
    6a20:	11 96       	adiw	r26, 0x01	; 1
    6a22:	cd 93       	st	X+, r28
    6a24:	dc 93       	st	X, r29
    6a26:	12 97       	sbiw	r26, 0x02	; 2
    6a28:	8d eb       	ldi	r24, 0xBD	; 189
    6a2a:	9b e0       	ldi	r25, 0x0B	; 11
    6a2c:	13 96       	adiw	r26, 0x03	; 3
    6a2e:	8d 93       	st	X+, r24
    6a30:	9c 93       	st	X, r25
    6a32:	14 97       	sbiw	r26, 0x04	; 4
    6a34:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6a38:	0f 90       	pop	r0
    6a3a:	0f 90       	pop	r0
    6a3c:	0f 90       	pop	r0
    6a3e:	0f 90       	pop	r0
    6a40:	f8 01       	movw	r30, r16
    6a42:	40 89       	ldd	r20, Z+16	; 0x10
    6a44:	51 89       	ldd	r21, Z+17	; 0x11
    6a46:	62 89       	ldd	r22, Z+18	; 0x12
    6a48:	73 89       	ldd	r23, Z+19	; 0x13
    6a4a:	ce 01       	movw	r24, r28
    6a4c:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    6a50:	00 d0       	rcall	.+0      	; 0x6a52 <icmpPrintHeader+0xb0>
    6a52:	0f 92       	push	r0
    6a54:	ad b7       	in	r26, 0x3d	; 61
    6a56:	be b7       	in	r27, 0x3e	; 62
    6a58:	11 96       	adiw	r26, 0x01	; 1
    6a5a:	cd 93       	st	X+, r28
    6a5c:	dc 93       	st	X, r29
    6a5e:	12 97       	sbiw	r26, 0x02	; 2
    6a60:	8a eb       	ldi	r24, 0xBA	; 186
    6a62:	9b e0       	ldi	r25, 0x0B	; 11
    6a64:	13 96       	adiw	r26, 0x03	; 3
    6a66:	8d 93       	st	X+, r24
    6a68:	9c 93       	st	X, r25
    6a6a:	14 97       	sbiw	r26, 0x04	; 4
    6a6c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print type
  fprintf_P(stream, PSTR("Type   : "));
    6a70:	ed b7       	in	r30, 0x3d	; 61
    6a72:	fe b7       	in	r31, 0x3e	; 62
    6a74:	c1 83       	std	Z+1, r28	; 0x01
    6a76:	d2 83       	std	Z+2, r29	; 0x02
    6a78:	80 eb       	ldi	r24, 0xB0	; 176
    6a7a:	9b e0       	ldi	r25, 0x0B	; 11
    6a7c:	83 83       	std	Z+3, r24	; 0x03
    6a7e:	94 83       	std	Z+4, r25	; 0x04
    6a80:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  switch(icmpPacket->type)
    6a84:	0f 90       	pop	r0
    6a86:	0f 90       	pop	r0
    6a88:	0f 90       	pop	r0
    6a8a:	0f 90       	pop	r0
    6a8c:	d7 01       	movw	r26, r14
    6a8e:	8c 91       	ld	r24, X
    6a90:	88 23       	and	r24, r24
    6a92:	59 f0       	breq	.+22     	; 0x6aaa <icmpPrintHeader+0x108>
    6a94:	88 30       	cpi	r24, 0x08	; 8
    6a96:	c1 f4       	brne	.+48     	; 0x6ac8 <icmpPrintHeader+0x126>
  {
    case ICMP_TYPE_ECHOREQUEST:
      fprintf_P(stream, PSTR("ECHO REQUEST"));
    6a98:	00 d0       	rcall	.+0      	; 0x6a9a <icmpPrintHeader+0xf8>
    6a9a:	0f 92       	push	r0
    6a9c:	ed b7       	in	r30, 0x3d	; 61
    6a9e:	fe b7       	in	r31, 0x3e	; 62
    6aa0:	c1 83       	std	Z+1, r28	; 0x01
    6aa2:	d2 83       	std	Z+2, r29	; 0x02
    6aa4:	83 ea       	ldi	r24, 0xA3	; 163
    6aa6:	9b e0       	ldi	r25, 0x0B	; 11
    6aa8:	17 c0       	rjmp	.+46     	; 0x6ad8 <icmpPrintHeader+0x136>
      break;
    case ICMP_TYPE_ECHOREPLY:
      fprintf_P(stream, PSTR("ECHO REPLY"));
    6aaa:	00 d0       	rcall	.+0      	; 0x6aac <icmpPrintHeader+0x10a>
    6aac:	0f 92       	push	r0
    6aae:	ad b7       	in	r26, 0x3d	; 61
    6ab0:	be b7       	in	r27, 0x3e	; 62
    6ab2:	11 96       	adiw	r26, 0x01	; 1
    6ab4:	cd 93       	st	X+, r28
    6ab6:	dc 93       	st	X, r29
    6ab8:	12 97       	sbiw	r26, 0x02	; 2
    6aba:	88 e9       	ldi	r24, 0x98	; 152
    6abc:	9b e0       	ldi	r25, 0x0B	; 11
    6abe:	13 96       	adiw	r26, 0x03	; 3
    6ac0:	8d 93       	st	X+, r24
    6ac2:	9c 93       	st	X, r25
    6ac4:	14 97       	sbiw	r26, 0x04	; 4
    6ac6:	0a c0       	rjmp	.+20     	; 0x6adc <icmpPrintHeader+0x13a>
      break;
    default:
      fprintf_P(stream, ("UNKNOWN"));
    6ac8:	00 d0       	rcall	.+0      	; 0x6aca <icmpPrintHeader+0x128>
    6aca:	0f 92       	push	r0
    6acc:	ed b7       	in	r30, 0x3d	; 61
    6ace:	fe b7       	in	r31, 0x3e	; 62
    6ad0:	c1 83       	std	Z+1, r28	; 0x01
    6ad2:	d2 83       	std	Z+2, r29	; 0x02
    6ad4:	86 e1       	ldi	r24, 0x16	; 22
    6ad6:	95 e2       	ldi	r25, 0x25	; 37
    6ad8:	83 83       	std	Z+3, r24	; 0x03
    6ada:	94 83       	std	Z+4, r25	; 0x04
    6adc:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      break;
  }
  fprintf_P(stream, PSTR("\r\n"));
    6ae0:	ad b7       	in	r26, 0x3d	; 61
    6ae2:	be b7       	in	r27, 0x3e	; 62
    6ae4:	11 96       	adiw	r26, 0x01	; 1
    6ae6:	cd 93       	st	X+, r28
    6ae8:	dc 93       	st	X, r29
    6aea:	12 97       	sbiw	r26, 0x02	; 2
    6aec:	85 e9       	ldi	r24, 0x95	; 149
    6aee:	9b e0       	ldi	r25, 0x0B	; 11
    6af0:	13 96       	adiw	r26, 0x03	; 3
    6af2:	8d 93       	st	X+, r24
    6af4:	9c 93       	st	X, r25
    6af6:	14 97       	sbiw	r26, 0x04	; 4
    6af8:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print code
  fprintf_P(stream, PSTR("Code   : 0x%x\r\n"), icmpPacket->icode);
    6afc:	0f 92       	push	r0
    6afe:	0f 92       	push	r0
    6b00:	ed b7       	in	r30, 0x3d	; 61
    6b02:	fe b7       	in	r31, 0x3e	; 62
    6b04:	31 96       	adiw	r30, 0x01	; 1
    6b06:	ad b7       	in	r26, 0x3d	; 61
    6b08:	be b7       	in	r27, 0x3e	; 62
    6b0a:	11 96       	adiw	r26, 0x01	; 1
    6b0c:	cd 93       	st	X+, r28
    6b0e:	dc 93       	st	X, r29
    6b10:	12 97       	sbiw	r26, 0x02	; 2
    6b12:	85 e8       	ldi	r24, 0x85	; 133
    6b14:	9b e0       	ldi	r25, 0x0B	; 11
    6b16:	82 83       	std	Z+2, r24	; 0x02
    6b18:	93 83       	std	Z+3, r25	; 0x03
    6b1a:	d7 01       	movw	r26, r14
    6b1c:	11 96       	adiw	r26, 0x01	; 1
    6b1e:	8c 91       	ld	r24, X
    6b20:	84 83       	std	Z+4, r24	; 0x04
    6b22:	15 82       	std	Z+5, r1	; 0x05
    6b24:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6b28:	ed b7       	in	r30, 0x3d	; 61
    6b2a:	fe b7       	in	r31, 0x3e	; 62
    6b2c:	36 96       	adiw	r30, 0x06	; 6
    6b2e:	ed bf       	out	0x3d, r30	; 61
    6b30:	fe bf       	out	0x3e, r31	; 62
}
    6b32:	df 91       	pop	r29
    6b34:	cf 91       	pop	r28
    6b36:	1f 91       	pop	r17
    6b38:	0f 91       	pop	r16
    6b3a:	ff 90       	pop	r15
    6b3c:	ef 90       	pop	r14
    6b3e:	08 95       	ret

00006b40 <icmpEchoRequest>:
      break;
  }
}

void icmpEchoRequest(void)
{
    6b40:	cf 93       	push	r28
    6b42:	df 93       	push	r29
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6b44:	80 91 0c 32 	lds	r24, 0x320C
    6b48:	90 91 0d 32 	lds	r25, 0x320D
    6b4c:	00 97       	sbiw	r24, 0x00	; 0
    6b4e:	a1 f0       	breq	.+40     	; 0x6b78 <icmpEchoRequest+0x38>
  {
    if (icmpDebugLevel > 1)
    6b50:	20 91 af 32 	lds	r18, 0x32AF
    6b54:	22 30       	cpi	r18, 0x02	; 2
    6b56:	80 f0       	brcs	.+32     	; 0x6b78 <icmpEchoRequest+0x38>
      fprintf_P(icmpDebug, PSTR("Received ICMP request: "));
    6b58:	00 d0       	rcall	.+0      	; 0x6b5a <icmpEchoRequest+0x1a>
    6b5a:	0f 92       	push	r0
    6b5c:	ed b7       	in	r30, 0x3d	; 61
    6b5e:	fe b7       	in	r31, 0x3e	; 62
    6b60:	81 83       	std	Z+1, r24	; 0x01
    6b62:	92 83       	std	Z+2, r25	; 0x02
    6b64:	8b ef       	ldi	r24, 0xFB	; 251
    6b66:	9b e0       	ldi	r25, 0x0B	; 11
    6b68:	83 83       	std	Z+3, r24	; 0x03
    6b6a:	94 83       	std	Z+4, r25	; 0x04
    6b6c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6b70:	0f 90       	pop	r0
    6b72:	0f 90       	pop	r0
    6b74:	0f 90       	pop	r0
    6b76:	0f 90       	pop	r0
  }
#endif
  uint32_t tempIp;

  // change type to reply
  nicState.layer4.icmp->type = ICMP_TYPE_ECHOREPLY;
    6b78:	e0 91 ea 31 	lds	r30, 0x31EA
    6b7c:	f0 91 eb 31 	lds	r31, 0x31EB
    6b80:	10 82       	st	Z, r1
  // recalculate checksum
  nicState.layer4.icmp->icmpchksum = 0;
    6b82:	e0 91 ea 31 	lds	r30, 0x31EA
    6b86:	f0 91 eb 31 	lds	r31, 0x31EB
    6b8a:	12 82       	std	Z+2, r1	; 0x02
    6b8c:	13 82       	std	Z+3, r1	; 0x03
  nicState.layer4.icmp->icmpchksum = netChecksum((uint8_t*)(nicState.layer4.icmp), htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
    6b8e:	c0 91 ea 31 	lds	r28, 0x31EA
    6b92:	d0 91 eb 31 	lds	r29, 0x31EB
    6b96:	e0 91 e8 31 	lds	r30, 0x31E8
    6b9a:	f0 91 e9 31 	lds	r31, 0x31E9
    6b9e:	82 81       	ldd	r24, Z+2	; 0x02
    6ba0:	93 81       	ldd	r25, Z+3	; 0x03
    6ba2:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    6ba6:	bc 01       	movw	r22, r24
    6ba8:	64 51       	subi	r22, 0x14	; 20
    6baa:	70 40       	sbci	r23, 0x00	; 0
    6bac:	ce 01       	movw	r24, r28
    6bae:	0e 94 bb 2e 	call	0x5d76	; 0x5d76 <netChecksum>
    6bb2:	8a 83       	std	Y+2, r24	; 0x02
    6bb4:	9b 83       	std	Y+3, r25	; 0x03
  // return to sender
  tempIp = nicState.layer3.ip->destipaddr;
    6bb6:	e0 91 e8 31 	lds	r30, 0x31E8
    6bba:	f0 91 e9 31 	lds	r31, 0x31E9
    6bbe:	80 89       	ldd	r24, Z+16	; 0x10
    6bc0:	91 89       	ldd	r25, Z+17	; 0x11
    6bc2:	a2 89       	ldd	r26, Z+18	; 0x12
    6bc4:	b3 89       	ldd	r27, Z+19	; 0x13
  nicState.layer3.ip->destipaddr = nicState.layer3.ip->srcipaddr;
    6bc6:	24 85       	ldd	r18, Z+12	; 0x0c
    6bc8:	35 85       	ldd	r19, Z+13	; 0x0d
    6bca:	46 85       	ldd	r20, Z+14	; 0x0e
    6bcc:	57 85       	ldd	r21, Z+15	; 0x0f
    6bce:	20 8b       	std	Z+16, r18	; 0x10
    6bd0:	31 8b       	std	Z+17, r19	; 0x11
    6bd2:	42 8b       	std	Z+18, r20	; 0x12
    6bd4:	53 8b       	std	Z+19, r21	; 0x13
  nicState.layer3.ip->srcipaddr = tempIp;
    6bd6:	84 87       	std	Z+12, r24	; 0x0c
    6bd8:	95 87       	std	Z+13, r25	; 0x0d
    6bda:	a6 87       	std	Z+14, r26	; 0x0e
    6bdc:	b7 87       	std	Z+15, r27	; 0x0f
  // add ethernet routing
  arpIpOut(0);
    6bde:	60 e0       	ldi	r22, 0x00	; 0
    6be0:	70 e0       	ldi	r23, 0x00	; 0
    6be2:	cb 01       	movw	r24, r22
    6be4:	0e 94 8e 36 	call	0x6d1c	; 0x6d1c <arpIpOut>

  // debugging
  if (icmpDebug != NULL)
    6be8:	80 91 0c 32 	lds	r24, 0x320C
    6bec:	90 91 0d 32 	lds	r25, 0x320D
    6bf0:	00 97       	sbiw	r24, 0x00	; 0
    6bf2:	51 f0       	breq	.+20     	; 0x6c08 <icmpEchoRequest+0xc8>
    icmpPrintHeader(icmpDebug, nicState.layer3.ip, nicState.layer4.icmp);
    6bf4:	60 91 e8 31 	lds	r22, 0x31E8
    6bf8:	70 91 e9 31 	lds	r23, 0x31E9
    6bfc:	40 91 ea 31 	lds	r20, 0x31EA
    6c00:	50 91 eb 31 	lds	r21, 0x31EB
    6c04:	0e 94 d1 34 	call	0x69a2	; 0x69a2 <icmpPrintHeader>
  //debugPrintHexTable(htons(packet->ip.len), (uint8_t*)packet);

  // send it (packet->ip.len+ETH_HEADER_LEN
  nicSend(htons(nicState.layer3.ip->len) + ETH_HEADER_LEN);
    6c08:	e0 91 e8 31 	lds	r30, 0x31E8
    6c0c:	f0 91 e9 31 	lds	r31, 0x31E9
    6c10:	82 81       	ldd	r24, Z+2	; 0x02
    6c12:	93 81       	ldd	r25, Z+3	; 0x03
    6c14:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    6c18:	0e 96       	adiw	r24, 0x0e	; 14
    6c1a:	0e 94 1c 2c 	call	0x5838	; 0x5838 <nicSend>
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6c1e:	80 91 0c 32 	lds	r24, 0x320C
    6c22:	90 91 0d 32 	lds	r25, 0x320D
    6c26:	00 97       	sbiw	r24, 0x00	; 0
    6c28:	a1 f0       	breq	.+40     	; 0x6c52 <icmpEchoRequest+0x112>
  {
    if (icmpDebugLevel > 1)
    6c2a:	20 91 af 32 	lds	r18, 0x32AF
    6c2e:	22 30       	cpi	r18, 0x02	; 2
    6c30:	80 f0       	brcs	.+32     	; 0x6c52 <icmpEchoRequest+0x112>
      fprintf_P(icmpDebug, PSTR("Sending ICMP PONG\r\n"));
    6c32:	00 d0       	rcall	.+0      	; 0x6c34 <icmpEchoRequest+0xf4>
    6c34:	0f 92       	push	r0
    6c36:	ed b7       	in	r30, 0x3d	; 61
    6c38:	fe b7       	in	r31, 0x3e	; 62
    6c3a:	81 83       	std	Z+1, r24	; 0x01
    6c3c:	92 83       	std	Z+2, r25	; 0x02
    6c3e:	87 ee       	ldi	r24, 0xE7	; 231
    6c40:	9b e0       	ldi	r25, 0x0B	; 11
    6c42:	83 83       	std	Z+3, r24	; 0x03
    6c44:	94 83       	std	Z+4, r25	; 0x04
    6c46:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6c4a:	0f 90       	pop	r0
    6c4c:	0f 90       	pop	r0
    6c4e:	0f 90       	pop	r0
    6c50:	0f 90       	pop	r0
  }
#endif
}
    6c52:	df 91       	pop	r29
    6c54:	cf 91       	pop	r28
    6c56:	08 95       	ret

00006c58 <icmpIpIn>:
}

void icmpIpIn(void)
{
  // check ICMP type
  switch(nicState.layer4.icmp->type)
    6c58:	e0 91 ea 31 	lds	r30, 0x31EA
    6c5c:	f0 91 eb 31 	lds	r31, 0x31EB
    6c60:	80 81       	ld	r24, Z
    6c62:	88 30       	cpi	r24, 0x08	; 8
    6c64:	19 f4       	brne	.+6      	; 0x6c6c <icmpIpIn+0x14>
  {
    case ICMP_TYPE_ECHOREQUEST:
      icmpEchoRequest();       // echo request
    6c66:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <icmpEchoRequest>
      break;
    6c6a:	08 95       	ret
    default:
#if ICMP_DEBUG
      if (icmpDebug != NULL)
    6c6c:	80 91 0c 32 	lds	r24, 0x320C
    6c70:	90 91 0d 32 	lds	r25, 0x320D
    6c74:	00 97       	sbiw	r24, 0x00	; 0
    6c76:	a1 f0       	breq	.+40     	; 0x6ca0 <icmpIpIn+0x48>
      {
        if (icmpDebugLevel > 0)
    6c78:	20 91 af 32 	lds	r18, 0x32AF
    6c7c:	22 23       	and	r18, r18
    6c7e:	81 f0       	breq	.+32     	; 0x6ca0 <icmpIpIn+0x48>
          fprintf_P(icmpDebug, PSTR("Unknown ICMP typeReceived ICMP request: "));
    6c80:	00 d0       	rcall	.+0      	; 0x6c82 <icmpIpIn+0x2a>
    6c82:	0f 92       	push	r0
    6c84:	ed b7       	in	r30, 0x3d	; 61
    6c86:	fe b7       	in	r31, 0x3e	; 62
    6c88:	81 83       	std	Z+1, r24	; 0x01
    6c8a:	92 83       	std	Z+2, r25	; 0x02
    6c8c:	83 e1       	ldi	r24, 0x13	; 19
    6c8e:	9c e0       	ldi	r25, 0x0C	; 12
    6c90:	83 83       	std	Z+3, r24	; 0x03
    6c92:	94 83       	std	Z+4, r25	; 0x04
    6c94:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6c98:	0f 90       	pop	r0
    6c9a:	0f 90       	pop	r0
    6c9c:	0f 90       	pop	r0
    6c9e:	0f 90       	pop	r0
    6ca0:	08 95       	ret

00006ca2 <setArpDebug>:

#ifdef ARP_DEBUG

void setArpDebug(FILE *stream, uint8_t level)
{
  arpDebug = stream;
    6ca2:	80 93 ee 31 	sts	0x31EE, r24
    6ca6:	90 93 ef 31 	sts	0x31EF, r25
  arpDebugLevel = level;
    6caa:	60 93 c1 32 	sts	0x32C1, r22
  if (level == 0)
    6cae:	66 23       	and	r22, r22
    6cb0:	21 f4       	brne	.+8      	; 0x6cba <setArpDebug+0x18>
    arpDebug = NULL;
    6cb2:	10 92 ee 31 	sts	0x31EE, r1
    6cb6:	10 92 ef 31 	sts	0x31EF, r1
    6cba:	08 95       	ret

00006cbc <arpInit>:
#endif /*ARP_DEBUG*/

void arpInit()
{

  memset(ArpTable, 0, sizeof(ArpTable));
    6cbc:	8e e6       	ldi	r24, 0x6E	; 110
    6cbe:	ee ec       	ldi	r30, 0xCE	; 206
    6cc0:	f2 e3       	ldi	r31, 0x32	; 50
    6cc2:	df 01       	movw	r26, r30
    6cc4:	1d 92       	st	X+, r1
    6cc6:	8a 95       	dec	r24
    6cc8:	e9 f7       	brne	.-6      	; 0x6cc4 <arpInit+0x8>
  arpDebug = NULL;
    6cca:	10 92 ee 31 	sts	0x31EE, r1
    6cce:	10 92 ef 31 	sts	0x31EF, r1
}
    6cd2:	08 95       	ret

00006cd4 <arpTimer>:
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}

void arpTimer(void)
{
    6cd4:	e8 ed       	ldi	r30, 0xD8	; 216
    6cd6:	f2 e3       	ldi	r31, 0x32	; 50
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time)
    6cd8:	80 81       	ld	r24, Z
    6cda:	88 23       	and	r24, r24
    6cdc:	11 f0       	breq	.+4      	; 0x6ce2 <arpTimer+0xe>
      ArpTable[index].time--;
    6cde:	81 50       	subi	r24, 0x01	; 1
    6ce0:	80 83       	st	Z, r24
    6ce2:	3b 96       	adiw	r30, 0x0b	; 11
{
  int index;
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6ce4:	83 e3       	ldi	r24, 0x33	; 51
    6ce6:	e6 34       	cpi	r30, 0x46	; 70
    6ce8:	f8 07       	cpc	r31, r24
    6cea:	b1 f7       	brne	.-20     	; 0x6cd8 <arpTimer+0x4>
  {
    if(ArpTable[index].time)
      ArpTable[index].time--;
  }
}
    6cec:	08 95       	ret

00006cee <arpMatchIp>:
      return i;
    }
  }

// no match
  return -1;
    6cee:	ae ec       	ldi	r26, 0xCE	; 206
    6cf0:	b2 e3       	ldi	r27, 0x32	; 50
      ArpTable[index].time--;
  }
}

int arpMatchIp(uint32_t ipaddr)
{
    6cf2:	e0 e0       	ldi	r30, 0x00	; 0
    6cf4:	f0 e0       	ldi	r31, 0x00	; 0
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    6cf6:	2d 91       	ld	r18, X+
    6cf8:	3d 91       	ld	r19, X+
    6cfa:	4d 91       	ld	r20, X+
    6cfc:	5c 91       	ld	r21, X
    6cfe:	13 97       	sbiw	r26, 0x03	; 3
    6d00:	26 17       	cp	r18, r22
    6d02:	37 07       	cpc	r19, r23
    6d04:	48 07       	cpc	r20, r24
    6d06:	59 07       	cpc	r21, r25
    6d08:	39 f0       	breq	.+14     	; 0x6d18 <arpMatchIp+0x2a>
    6d0a:	31 96       	adiw	r30, 0x01	; 1
    6d0c:	1b 96       	adiw	r26, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    6d0e:	ea 30       	cpi	r30, 0x0A	; 10
    6d10:	f1 05       	cpc	r31, r1
    6d12:	89 f7       	brne	.-30     	; 0x6cf6 <arpMatchIp+0x8>
      return i;
    }
  }

// no match
  return -1;
    6d14:	ef ef       	ldi	r30, 0xFF	; 255
    6d16:	ff ef       	ldi	r31, 0xFF	; 255
}
    6d18:	cf 01       	movw	r24, r30
    6d1a:	08 95       	ret

00006d1c <arpIpOut>:
void arpIpOut(uint32_t phyDstIp)
{
  int index;
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    6d1c:	61 15       	cp	r22, r1
    6d1e:	71 05       	cpc	r23, r1
    6d20:	81 05       	cpc	r24, r1
    6d22:	91 05       	cpc	r25, r1
    6d24:	41 f4       	brne	.+16     	; 0x6d36 <arpIpOut+0x1a>
    index = arpMatchIp(phyDstIp);
  else
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
    6d26:	e0 91 e8 31 	lds	r30, 0x31E8
    6d2a:	f0 91 e9 31 	lds	r31, 0x31E9
    6d2e:	60 89       	ldd	r22, Z+16	; 0x10
    6d30:	71 89       	ldd	r23, Z+17	; 0x11
    6d32:	82 89       	ldd	r24, Z+18	; 0x12
    6d34:	93 89       	ldd	r25, Z+19	; 0x13
    6d36:	0e 94 77 36 	call	0x6cee	; 0x6cee <arpMatchIp>
    6d3a:	a0 91 e6 31 	lds	r26, 0x31E6
    6d3e:	b0 91 e7 31 	lds	r27, 0x31E7
// fill in ethernet info
  if(index != -1)
    6d42:	2f ef       	ldi	r18, 0xFF	; 255
    6d44:	8f 3f       	cpi	r24, 0xFF	; 255
    6d46:	92 07       	cpc	r25, r18
    6d48:	01 f1       	breq	.+64     	; 0x6d8a <arpIpOut+0x6e>
  {
// ARP entry present, fill eth address(es)
    nicState.layer2.ethHeader->src      = nicState.mac;
    6d4a:	16 96       	adiw	r26, 0x06	; 6
    6d4c:	e0 ee       	ldi	r30, 0xE0	; 224
    6d4e:	f1 e3       	ldi	r31, 0x31	; 49
    6d50:	26 e0       	ldi	r18, 0x06	; 6
    6d52:	01 90       	ld	r0, Z+
    6d54:	0d 92       	st	X+, r0
    6d56:	21 50       	subi	r18, 0x01	; 1
    6d58:	e1 f7       	brne	.-8      	; 0x6d52 <arpIpOut+0x36>
    nicState.layer2.ethHeader->dest     = ArpTable[index].ethaddr;
    6d5a:	2b e0       	ldi	r18, 0x0B	; 11
    6d5c:	30 e0       	ldi	r19, 0x00	; 0
    6d5e:	82 9f       	mul	r24, r18
    6d60:	f0 01       	movw	r30, r0
    6d62:	83 9f       	mul	r24, r19
    6d64:	f0 0d       	add	r31, r0
    6d66:	92 9f       	mul	r25, r18
    6d68:	f0 0d       	add	r31, r0
    6d6a:	11 24       	eor	r1, r1
    6d6c:	30 91 e6 31 	lds	r19, 0x31E6
    6d70:	20 91 e7 31 	lds	r18, 0x31E7
    6d74:	83 2f       	mov	r24, r19
    6d76:	92 2f       	mov	r25, r18
    6d78:	dc 01       	movw	r26, r24
    6d7a:	ee 52       	subi	r30, 0x2E	; 46
    6d7c:	fd 4c       	sbci	r31, 0xCD	; 205
    6d7e:	86 e0       	ldi	r24, 0x06	; 6
    6d80:	01 90       	ld	r0, Z+
    6d82:	0d 92       	st	X+, r0
    6d84:	81 50       	subi	r24, 0x01	; 1
    6d86:	e1 f7       	brne	.-8      	; 0x6d80 <arpIpOut+0x64>
    6d88:	12 c0       	rjmp	.+36     	; 0x6dae <arpIpOut+0x92>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
  }
  else
  {
// not in table, must send ARP request
    nicState.layer2.ethHeader->src      = nicState.mac;
    6d8a:	16 96       	adiw	r26, 0x06	; 6
    6d8c:	e0 ee       	ldi	r30, 0xE0	; 224
    6d8e:	f1 e3       	ldi	r31, 0x31	; 49
    6d90:	86 e0       	ldi	r24, 0x06	; 6
    6d92:	01 90       	ld	r0, Z+
    6d94:	0d 92       	st	X+, r0
    6d96:	81 50       	subi	r24, 0x01	; 1
    6d98:	e1 f7       	brne	.-8      	; 0x6d92 <arpIpOut+0x76>
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    6d9a:	80 91 e6 31 	lds	r24, 0x31E6
    6d9e:	90 91 e7 31 	lds	r25, 0x31E7
    6da2:	6f ef       	ldi	r22, 0xFF	; 255
    6da4:	70 e0       	ldi	r23, 0x00	; 0
    6da6:	46 e0       	ldi	r20, 0x06	; 6
    6da8:	50 e0       	ldi	r21, 0x00	; 0
    6daa:	0e 94 1e 57 	call	0xae3c	; 0xae3c <memset>
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
    6dae:	e0 91 e6 31 	lds	r30, 0x31E6
    6db2:	f0 91 e7 31 	lds	r31, 0x31E7
    6db6:	88 e0       	ldi	r24, 0x08	; 8
    6db8:	90 e0       	ldi	r25, 0x00	; 0
    6dba:	84 87       	std	Z+12, r24	; 0x0c
    6dbc:	95 87       	std	Z+13, r25	; 0x0d
    6dbe:	08 95       	ret

00006dc0 <arpIpIn>:
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
  }
}

void arpIpIn(void)
{
    6dc0:	cf 93       	push	r28
    6dc2:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    6dc4:	80 91 ee 31 	lds	r24, 0x31EE
    6dc8:	90 91 ef 31 	lds	r25, 0x31EF
    6dcc:	00 97       	sbiw	r24, 0x00	; 0
    6dce:	09 f4       	brne	.+2      	; 0x6dd2 <arpIpIn+0x12>
    6dd0:	57 c0       	rjmp	.+174    	; 0x6e80 <arpIpIn+0xc0>
  {
    if (arpDebugLevel > 0)
    6dd2:	20 91 c1 32 	lds	r18, 0x32C1
    6dd6:	22 23       	and	r18, r18
    6dd8:	09 f4       	brne	.+2      	; 0x6ddc <arpIpIn+0x1c>
    6dda:	52 c0       	rjmp	.+164    	; 0x6e80 <arpIpIn+0xc0>
    {
      fprintf_P(arpDebug, PSTR("ARP IP in MAC: "));
    6ddc:	00 d0       	rcall	.+0      	; 0x6dde <arpIpIn+0x1e>
    6dde:	0f 92       	push	r0
    6de0:	ed b7       	in	r30, 0x3d	; 61
    6de2:	fe b7       	in	r31, 0x3e	; 62
    6de4:	81 83       	std	Z+1, r24	; 0x01
    6de6:	92 83       	std	Z+2, r25	; 0x02
    6de8:	86 e2       	ldi	r24, 0x26	; 38
    6dea:	9d e0       	ldi	r25, 0x0D	; 13
    6dec:	83 83       	std	Z+3, r24	; 0x03
    6dee:	94 83       	std	Z+4, r25	; 0x04
    6df0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      netPrintEthAddr(arpDebug, &nicState.layer2.ethHeader->src);
    6df4:	0f 90       	pop	r0
    6df6:	0f 90       	pop	r0
    6df8:	0f 90       	pop	r0
    6dfa:	0f 90       	pop	r0
    6dfc:	60 91 e6 31 	lds	r22, 0x31E6
    6e00:	70 91 e7 31 	lds	r23, 0x31E7
    6e04:	6a 5f       	subi	r22, 0xFA	; 250
    6e06:	7f 4f       	sbci	r23, 0xFF	; 255
    6e08:	80 91 ee 31 	lds	r24, 0x31EE
    6e0c:	90 91 ef 31 	lds	r25, 0x31EF
    6e10:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
      fprintf_P(arpDebug, PSTR(" IP: "));
    6e14:	00 d0       	rcall	.+0      	; 0x6e16 <arpIpIn+0x56>
    6e16:	0f 92       	push	r0
    6e18:	80 91 ee 31 	lds	r24, 0x31EE
    6e1c:	90 91 ef 31 	lds	r25, 0x31EF
    6e20:	ed b7       	in	r30, 0x3d	; 61
    6e22:	fe b7       	in	r31, 0x3e	; 62
    6e24:	81 83       	std	Z+1, r24	; 0x01
    6e26:	92 83       	std	Z+2, r25	; 0x02
    6e28:	80 e2       	ldi	r24, 0x20	; 32
    6e2a:	9d e0       	ldi	r25, 0x0D	; 13
    6e2c:	83 83       	std	Z+3, r24	; 0x03
    6e2e:	94 83       	std	Z+4, r25	; 0x04
    6e30:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      netPrintIPAddr(arpDebug, nicState.layer3.ip->srcipaddr);
    6e34:	0f 90       	pop	r0
    6e36:	0f 90       	pop	r0
    6e38:	0f 90       	pop	r0
    6e3a:	0f 90       	pop	r0
    6e3c:	e0 91 e8 31 	lds	r30, 0x31E8
    6e40:	f0 91 e9 31 	lds	r31, 0x31E9
    6e44:	44 85       	ldd	r20, Z+12	; 0x0c
    6e46:	55 85       	ldd	r21, Z+13	; 0x0d
    6e48:	66 85       	ldd	r22, Z+14	; 0x0e
    6e4a:	77 85       	ldd	r23, Z+15	; 0x0f
    6e4c:	80 91 ee 31 	lds	r24, 0x31EE
    6e50:	90 91 ef 31 	lds	r25, 0x31EF
    6e54:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
      fprintf_P(arpDebug, PSTR("\r\n"));
    6e58:	00 d0       	rcall	.+0      	; 0x6e5a <arpIpIn+0x9a>
    6e5a:	0f 92       	push	r0
    6e5c:	80 91 ee 31 	lds	r24, 0x31EE
    6e60:	90 91 ef 31 	lds	r25, 0x31EF
    6e64:	ed b7       	in	r30, 0x3d	; 61
    6e66:	fe b7       	in	r31, 0x3e	; 62
    6e68:	81 83       	std	Z+1, r24	; 0x01
    6e6a:	92 83       	std	Z+2, r25	; 0x02
    6e6c:	8d e1       	ldi	r24, 0x1D	; 29
    6e6e:	9d e0       	ldi	r25, 0x0D	; 13
    6e70:	83 83       	std	Z+3, r24	; 0x03
    6e72:	94 83       	std	Z+4, r25	; 0x04
    6e74:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    6e78:	0f 90       	pop	r0
    6e7a:	0f 90       	pop	r0
    6e7c:	0f 90       	pop	r0
    6e7e:	0f 90       	pop	r0
  }
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
    6e80:	c0 91 e8 31 	lds	r28, 0x31E8
    6e84:	d0 91 e9 31 	lds	r29, 0x31E9
    6e88:	6c 85       	ldd	r22, Y+12	; 0x0c
    6e8a:	7d 85       	ldd	r23, Y+13	; 0x0d
    6e8c:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e8e:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e90:	0e 94 77 36 	call	0x6cee	; 0x6cee <arpMatchIp>
  if(index != -1)
    6e94:	8f 3f       	cpi	r24, 0xFF	; 255
    6e96:	21 f1       	breq	.+72     	; 0x6ee0 <arpIpIn+0x120>
  {
// sender's IP address found, update ARP entry
    ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6e98:	99 27       	eor	r25, r25
    6e9a:	87 fd       	sbrc	r24, 7
    6e9c:	90 95       	com	r25
    6e9e:	2b e0       	ldi	r18, 0x0B	; 11
    6ea0:	30 e0       	ldi	r19, 0x00	; 0
    6ea2:	82 9f       	mul	r24, r18
    6ea4:	d0 01       	movw	r26, r0
    6ea6:	83 9f       	mul	r24, r19
    6ea8:	b0 0d       	add	r27, r0
    6eaa:	92 9f       	mul	r25, r18
    6eac:	b0 0d       	add	r27, r0
    6eae:	11 24       	eor	r1, r1
    6eb0:	e0 91 e6 31 	lds	r30, 0x31E6
    6eb4:	f0 91 e7 31 	lds	r31, 0x31E7
    6eb8:	ae 52       	subi	r26, 0x2E	; 46
    6eba:	bd 4c       	sbci	r27, 0xCD	; 205
    6ebc:	36 96       	adiw	r30, 0x06	; 6
    6ebe:	26 e0       	ldi	r18, 0x06	; 6
    6ec0:	01 90       	ld	r0, Z+
    6ec2:	0d 92       	st	X+, r0
    6ec4:	21 50       	subi	r18, 0x01	; 1
    6ec6:	e1 f7       	brne	.-8      	; 0x6ec0 <arpIpIn+0x100>
    ArpTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    6ec8:	2b e0       	ldi	r18, 0x0B	; 11
    6eca:	30 e0       	ldi	r19, 0x00	; 0
    6ecc:	82 9f       	mul	r24, r18
    6ece:	f0 01       	movw	r30, r0
    6ed0:	83 9f       	mul	r24, r19
    6ed2:	f0 0d       	add	r31, r0
    6ed4:	92 9f       	mul	r25, r18
    6ed6:	f0 0d       	add	r31, r0
    6ed8:	11 24       	eor	r1, r1
    6eda:	e2 53       	subi	r30, 0x32	; 50
    6edc:	fd 4c       	sbci	r31, 0xCD	; 205
    6ede:	2f c0       	rjmp	.+94     	; 0x6f3e <arpIpIn+0x17e>
// and we're done
    return;
    6ee0:	e8 ed       	ldi	r30, 0xD8	; 216
    6ee2:	f2 e3       	ldi	r31, 0x32	; 50
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
  if(index != -1)
    6ee4:	80 e0       	ldi	r24, 0x00	; 0
    6ee6:	90 e0       	ldi	r25, 0x00	; 0

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time == 0)
    6ee8:	20 81       	ld	r18, Z
    6eea:	22 23       	and	r18, r18
    6eec:	59 f5       	brne	.+86     	; 0x6f44 <arpIpIn+0x184>
    {
// write entry
      ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6eee:	2b e0       	ldi	r18, 0x0B	; 11
    6ef0:	30 e0       	ldi	r19, 0x00	; 0
    6ef2:	82 9f       	mul	r24, r18
    6ef4:	d0 01       	movw	r26, r0
    6ef6:	83 9f       	mul	r24, r19
    6ef8:	b0 0d       	add	r27, r0
    6efa:	92 9f       	mul	r25, r18
    6efc:	b0 0d       	add	r27, r0
    6efe:	11 24       	eor	r1, r1
    6f00:	e0 91 e6 31 	lds	r30, 0x31E6
    6f04:	f0 91 e7 31 	lds	r31, 0x31E7
    6f08:	ae 52       	subi	r26, 0x2E	; 46
    6f0a:	bd 4c       	sbci	r27, 0xCD	; 205
    6f0c:	36 96       	adiw	r30, 0x06	; 6
    6f0e:	26 e0       	ldi	r18, 0x06	; 6
    6f10:	01 90       	ld	r0, Z+
    6f12:	0d 92       	st	X+, r0
    6f14:	21 50       	subi	r18, 0x01	; 1
    6f16:	e1 f7       	brne	.-8      	; 0x6f10 <arpIpIn+0x150>
      ArpTable[index].ipaddr  = nicState.layer3.ip->srcipaddr;
    6f18:	2b e0       	ldi	r18, 0x0B	; 11
    6f1a:	30 e0       	ldi	r19, 0x00	; 0
    6f1c:	82 9f       	mul	r24, r18
    6f1e:	f0 01       	movw	r30, r0
    6f20:	83 9f       	mul	r24, r19
    6f22:	f0 0d       	add	r31, r0
    6f24:	92 9f       	mul	r25, r18
    6f26:	f0 0d       	add	r31, r0
    6f28:	11 24       	eor	r1, r1
    6f2a:	e2 53       	subi	r30, 0x32	; 50
    6f2c:	fd 4c       	sbci	r31, 0xCD	; 205
    6f2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    6f30:	9d 85       	ldd	r25, Y+13	; 0x0d
    6f32:	ae 85       	ldd	r26, Y+14	; 0x0e
    6f34:	bf 85       	ldd	r27, Y+15	; 0x0f
    6f36:	80 83       	st	Z, r24
    6f38:	91 83       	std	Z+1, r25	; 0x01
    6f3a:	a2 83       	std	Z+2, r26	; 0x02
    6f3c:	b3 83       	std	Z+3, r27	; 0x03
      ArpTable[index].time    = ARP_CACHE_TIME_TO_LIVE;
    6f3e:	80 e8       	ldi	r24, 0x80	; 128
    6f40:	82 87       	std	Z+10, r24	; 0x0a
// and we're done
      return;
    6f42:	05 c0       	rjmp	.+10     	; 0x6f4e <arpIpIn+0x18e>
    6f44:	01 96       	adiw	r24, 0x01	; 1
    6f46:	3b 96       	adiw	r30, 0x0b	; 11
    return;
  }

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6f48:	8a 30       	cpi	r24, 0x0A	; 10
    6f4a:	91 05       	cpc	r25, r1
    6f4c:	69 f6       	brne	.-102    	; 0x6ee8 <arpIpIn+0x128>
// and we're done
      return;
    }
  }
// no space in table, we give up
}
    6f4e:	df 91       	pop	r29
    6f50:	cf 91       	pop	r28
    6f52:	08 95       	ret

00006f54 <arpPrintHeader>:
  return -1;
}

#if ARP_DEBUG
void arpPrintHeader(FILE *stream, struct netArpHeader* packet)
{
    6f54:	ef 92       	push	r14
    6f56:	ff 92       	push	r15
    6f58:	0f 93       	push	r16
    6f5a:	1f 93       	push	r17
    6f5c:	cf 93       	push	r28
    6f5e:	df 93       	push	r29
    6f60:	ec 01       	movw	r28, r24
    6f62:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("ARP Packet:\r\n"));
    6f64:	00 d0       	rcall	.+0      	; 0x6f66 <arpPrintHeader+0x12>
    6f66:	0f 92       	push	r0
    6f68:	ed b7       	in	r30, 0x3d	; 61
    6f6a:	fe b7       	in	r31, 0x3e	; 62
    6f6c:	81 83       	std	Z+1, r24	; 0x01
    6f6e:	92 83       	std	Z+2, r25	; 0x02
    6f70:	8f e0       	ldi	r24, 0x0F	; 15
    6f72:	9d e0       	ldi	r25, 0x0D	; 13
    6f74:	83 83       	std	Z+3, r24	; 0x03
    6f76:	94 83       	std	Z+4, r25	; 0x04
    6f78:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  //debugPrintHexTable(60, (unsigned char*)&packet);
  // print operation type
  fprintf_P(stream, PSTR("Operation   : "));
    6f7c:	ed b7       	in	r30, 0x3d	; 61
    6f7e:	fe b7       	in	r31, 0x3e	; 62
    6f80:	c1 83       	std	Z+1, r28	; 0x01
    6f82:	d2 83       	std	Z+2, r29	; 0x02
    6f84:	80 e0       	ldi	r24, 0x00	; 0
    6f86:	9d e0       	ldi	r25, 0x0D	; 13
    6f88:	83 83       	std	Z+3, r24	; 0x03
    6f8a:	94 83       	std	Z+4, r25	; 0x04
    6f8c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  if(packet->opcode == htons(ARP_OPCODE_REQUEST))
    6f90:	f8 01       	movw	r30, r16
    6f92:	e6 80       	ldd	r14, Z+6	; 0x06
    6f94:	f7 80       	ldd	r15, Z+7	; 0x07
    6f96:	0f 90       	pop	r0
    6f98:	0f 90       	pop	r0
    6f9a:	0f 90       	pop	r0
    6f9c:	0f 90       	pop	r0
    6f9e:	81 e0       	ldi	r24, 0x01	; 1
    6fa0:	90 e0       	ldi	r25, 0x00	; 0
    6fa2:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    6fa6:	e8 16       	cp	r14, r24
    6fa8:	f9 06       	cpc	r15, r25
    6faa:	49 f4       	brne	.+18     	; 0x6fbe <arpPrintHeader+0x6a>
    fprintf_P(stream, PSTR("REQUEST"));
    6fac:	00 d0       	rcall	.+0      	; 0x6fae <arpPrintHeader+0x5a>
    6fae:	0f 92       	push	r0
    6fb0:	ed b7       	in	r30, 0x3d	; 61
    6fb2:	fe b7       	in	r31, 0x3e	; 62
    6fb4:	c1 83       	std	Z+1, r28	; 0x01
    6fb6:	d2 83       	std	Z+2, r29	; 0x02
    6fb8:	88 ef       	ldi	r24, 0xF8	; 248
    6fba:	9c e0       	ldi	r25, 0x0C	; 12
    6fbc:	1b c0       	rjmp	.+54     	; 0x6ff4 <arpPrintHeader+0xa0>
  else if(packet->opcode == htons(ARP_OPCODE_REPLY))
    6fbe:	f8 01       	movw	r30, r16
    6fc0:	e6 80       	ldd	r14, Z+6	; 0x06
    6fc2:	f7 80       	ldd	r15, Z+7	; 0x07
    6fc4:	82 e0       	ldi	r24, 0x02	; 2
    6fc6:	90 e0       	ldi	r25, 0x00	; 0
    6fc8:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    6fcc:	e8 16       	cp	r14, r24
    6fce:	f9 06       	cpc	r15, r25
    6fd0:	49 f4       	brne	.+18     	; 0x6fe4 <arpPrintHeader+0x90>
    fprintf_P(stream, PSTR("REPLY"));
    6fd2:	00 d0       	rcall	.+0      	; 0x6fd4 <arpPrintHeader+0x80>
    6fd4:	0f 92       	push	r0
    6fd6:	ed b7       	in	r30, 0x3d	; 61
    6fd8:	fe b7       	in	r31, 0x3e	; 62
    6fda:	c1 83       	std	Z+1, r28	; 0x01
    6fdc:	d2 83       	std	Z+2, r29	; 0x02
    6fde:	82 ef       	ldi	r24, 0xF2	; 242
    6fe0:	9c e0       	ldi	r25, 0x0C	; 12
    6fe2:	08 c0       	rjmp	.+16     	; 0x6ff4 <arpPrintHeader+0xa0>
  else
    fprintf_P(stream, PSTR("UNKNOWN"));
    6fe4:	00 d0       	rcall	.+0      	; 0x6fe6 <arpPrintHeader+0x92>
    6fe6:	0f 92       	push	r0
    6fe8:	ed b7       	in	r30, 0x3d	; 61
    6fea:	fe b7       	in	r31, 0x3e	; 62
    6fec:	c1 83       	std	Z+1, r28	; 0x01
    6fee:	d2 83       	std	Z+2, r29	; 0x02
    6ff0:	8a ee       	ldi	r24, 0xEA	; 234
    6ff2:	9c e0       	ldi	r25, 0x0C	; 12
    6ff4:	83 83       	std	Z+3, r24	; 0x03
    6ff6:	94 83       	std	Z+4, r25	; 0x04
    6ff8:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("\r\n"));
    6ffc:	ed b7       	in	r30, 0x3d	; 61
    6ffe:	fe b7       	in	r31, 0x3e	; 62
    7000:	c1 83       	std	Z+1, r28	; 0x01
    7002:	d2 83       	std	Z+2, r29	; 0x02
    7004:	87 ee       	ldi	r24, 0xE7	; 231
    7006:	9c e0       	ldi	r25, 0x0C	; 12
    7008:	83 83       	std	Z+3, r24	; 0x03
    700a:	94 83       	std	Z+4, r25	; 0x04
    700c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print source hardware address
  fprintf_P(stream, PSTR("SrcHwAddr   : "));  netPrintEthAddr(stream, &packet->shwaddr);   fprintf_P(stream, PSTR("\r\n"));
    7010:	ed b7       	in	r30, 0x3d	; 61
    7012:	fe b7       	in	r31, 0x3e	; 62
    7014:	c1 83       	std	Z+1, r28	; 0x01
    7016:	d2 83       	std	Z+2, r29	; 0x02
    7018:	88 ed       	ldi	r24, 0xD8	; 216
    701a:	9c e0       	ldi	r25, 0x0C	; 12
    701c:	83 83       	std	Z+3, r24	; 0x03
    701e:	94 83       	std	Z+4, r25	; 0x04
    7020:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7024:	0f 90       	pop	r0
    7026:	0f 90       	pop	r0
    7028:	0f 90       	pop	r0
    702a:	0f 90       	pop	r0
    702c:	b8 01       	movw	r22, r16
    702e:	68 5f       	subi	r22, 0xF8	; 248
    7030:	7f 4f       	sbci	r23, 0xFF	; 255
    7032:	ce 01       	movw	r24, r28
    7034:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
    7038:	00 d0       	rcall	.+0      	; 0x703a <arpPrintHeader+0xe6>
    703a:	0f 92       	push	r0
    703c:	ed b7       	in	r30, 0x3d	; 61
    703e:	fe b7       	in	r31, 0x3e	; 62
    7040:	c1 83       	std	Z+1, r28	; 0x01
    7042:	d2 83       	std	Z+2, r29	; 0x02
    7044:	85 ed       	ldi	r24, 0xD5	; 213
    7046:	9c e0       	ldi	r25, 0x0C	; 12
    7048:	83 83       	std	Z+3, r24	; 0x03
    704a:	94 83       	std	Z+4, r25	; 0x04
    704c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print source protocol address
  fprintf_P(stream, PSTR("SrcProtoAddr: "));  netPrintIPAddr(stream, packet->sipaddr);     fprintf_P(stream, PSTR("\r\n"));
    7050:	ed b7       	in	r30, 0x3d	; 61
    7052:	fe b7       	in	r31, 0x3e	; 62
    7054:	c1 83       	std	Z+1, r28	; 0x01
    7056:	d2 83       	std	Z+2, r29	; 0x02
    7058:	86 ec       	ldi	r24, 0xC6	; 198
    705a:	9c e0       	ldi	r25, 0x0C	; 12
    705c:	83 83       	std	Z+3, r24	; 0x03
    705e:	94 83       	std	Z+4, r25	; 0x04
    7060:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7064:	0f 90       	pop	r0
    7066:	0f 90       	pop	r0
    7068:	0f 90       	pop	r0
    706a:	0f 90       	pop	r0
    706c:	f8 01       	movw	r30, r16
    706e:	46 85       	ldd	r20, Z+14	; 0x0e
    7070:	57 85       	ldd	r21, Z+15	; 0x0f
    7072:	60 89       	ldd	r22, Z+16	; 0x10
    7074:	71 89       	ldd	r23, Z+17	; 0x11
    7076:	ce 01       	movw	r24, r28
    7078:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    707c:	00 d0       	rcall	.+0      	; 0x707e <arpPrintHeader+0x12a>
    707e:	0f 92       	push	r0
    7080:	ed b7       	in	r30, 0x3d	; 61
    7082:	fe b7       	in	r31, 0x3e	; 62
    7084:	c1 83       	std	Z+1, r28	; 0x01
    7086:	d2 83       	std	Z+2, r29	; 0x02
    7088:	83 ec       	ldi	r24, 0xC3	; 195
    708a:	9c e0       	ldi	r25, 0x0C	; 12
    708c:	83 83       	std	Z+3, r24	; 0x03
    708e:	94 83       	std	Z+4, r25	; 0x04
    7090:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print target hardware address
  fprintf_P(stream, PSTR("DstHwAddr   : "));  netPrintEthAddr(stream, &packet->dhwaddr);   fprintf_P(stream, PSTR("\r\n"));
    7094:	ed b7       	in	r30, 0x3d	; 61
    7096:	fe b7       	in	r31, 0x3e	; 62
    7098:	c1 83       	std	Z+1, r28	; 0x01
    709a:	d2 83       	std	Z+2, r29	; 0x02
    709c:	84 eb       	ldi	r24, 0xB4	; 180
    709e:	9c e0       	ldi	r25, 0x0C	; 12
    70a0:	83 83       	std	Z+3, r24	; 0x03
    70a2:	94 83       	std	Z+4, r25	; 0x04
    70a4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    70a8:	0f 90       	pop	r0
    70aa:	0f 90       	pop	r0
    70ac:	0f 90       	pop	r0
    70ae:	0f 90       	pop	r0
    70b0:	b8 01       	movw	r22, r16
    70b2:	6e 5e       	subi	r22, 0xEE	; 238
    70b4:	7f 4f       	sbci	r23, 0xFF	; 255
    70b6:	ce 01       	movw	r24, r28
    70b8:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
    70bc:	00 d0       	rcall	.+0      	; 0x70be <arpPrintHeader+0x16a>
    70be:	0f 92       	push	r0
    70c0:	ed b7       	in	r30, 0x3d	; 61
    70c2:	fe b7       	in	r31, 0x3e	; 62
    70c4:	c1 83       	std	Z+1, r28	; 0x01
    70c6:	d2 83       	std	Z+2, r29	; 0x02
    70c8:	81 eb       	ldi	r24, 0xB1	; 177
    70ca:	9c e0       	ldi	r25, 0x0C	; 12
    70cc:	83 83       	std	Z+3, r24	; 0x03
    70ce:	94 83       	std	Z+4, r25	; 0x04
    70d0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
// print target protocol address
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
    70d4:	ed b7       	in	r30, 0x3d	; 61
    70d6:	fe b7       	in	r31, 0x3e	; 62
    70d8:	c1 83       	std	Z+1, r28	; 0x01
    70da:	d2 83       	std	Z+2, r29	; 0x02
    70dc:	82 ea       	ldi	r24, 0xA2	; 162
    70de:	9c e0       	ldi	r25, 0x0C	; 12
    70e0:	83 83       	std	Z+3, r24	; 0x03
    70e2:	94 83       	std	Z+4, r25	; 0x04
    70e4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    70e8:	0f 90       	pop	r0
    70ea:	0f 90       	pop	r0
    70ec:	0f 90       	pop	r0
    70ee:	0f 90       	pop	r0
    70f0:	f8 01       	movw	r30, r16
    70f2:	40 8d       	ldd	r20, Z+24	; 0x18
    70f4:	51 8d       	ldd	r21, Z+25	; 0x19
    70f6:	62 8d       	ldd	r22, Z+26	; 0x1a
    70f8:	73 8d       	ldd	r23, Z+27	; 0x1b
    70fa:	ce 01       	movw	r24, r28
    70fc:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    7100:	00 d0       	rcall	.+0      	; 0x7102 <arpPrintHeader+0x1ae>
    7102:	0f 92       	push	r0
    7104:	ed b7       	in	r30, 0x3d	; 61
    7106:	fe b7       	in	r31, 0x3e	; 62
    7108:	c1 83       	std	Z+1, r28	; 0x01
    710a:	d2 83       	std	Z+2, r29	; 0x02
    710c:	8f e9       	ldi	r24, 0x9F	; 159
    710e:	9c e0       	ldi	r25, 0x0C	; 12
    7110:	83 83       	std	Z+3, r24	; 0x03
    7112:	94 83       	std	Z+4, r25	; 0x04
    7114:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7118:	0f 90       	pop	r0
    711a:	0f 90       	pop	r0
    711c:	0f 90       	pop	r0
    711e:	0f 90       	pop	r0
}
    7120:	df 91       	pop	r29
    7122:	cf 91       	pop	r28
    7124:	1f 91       	pop	r17
    7126:	0f 91       	pop	r16
    7128:	ff 90       	pop	r15
    712a:	ef 90       	pop	r14
    712c:	08 95       	ret

0000712e <arpArpIn>:
  memset(ArpTable, 0, sizeof(ArpTable));
  arpDebug = NULL;
}

void arpArpIn(void)
{
    712e:	cf 93       	push	r28
    7130:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    7132:	80 91 ee 31 	lds	r24, 0x31EE
    7136:	90 91 ef 31 	lds	r25, 0x31EF
    713a:	00 97       	sbiw	r24, 0x00	; 0
    713c:	11 f1       	breq	.+68     	; 0x7182 <arpArpIn+0x54>
  {
    if (arpDebugLevel > 1)
    713e:	20 91 c1 32 	lds	r18, 0x32C1
    7142:	22 30       	cpi	r18, 0x02	; 2
    7144:	80 f0       	brcs	.+32     	; 0x7166 <arpArpIn+0x38>
      fprintf_P(arpDebug, PSTR("Received ARP Request\r\n"));
    7146:	00 d0       	rcall	.+0      	; 0x7148 <arpArpIn+0x1a>
    7148:	0f 92       	push	r0
    714a:	ed b7       	in	r30, 0x3d	; 61
    714c:	fe b7       	in	r31, 0x3e	; 62
    714e:	81 83       	std	Z+1, r24	; 0x01
    7150:	92 83       	std	Z+2, r25	; 0x02
    7152:	8a e4       	ldi	r24, 0x4A	; 74
    7154:	9d e0       	ldi	r25, 0x0D	; 13
    7156:	83 83       	std	Z+3, r24	; 0x03
    7158:	94 83       	std	Z+4, r25	; 0x04
    715a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    715e:	0f 90       	pop	r0
    7160:	0f 90       	pop	r0
    7162:	0f 90       	pop	r0
    7164:	0f 90       	pop	r0
    if (arpDebugLevel > 2)
    7166:	80 91 c1 32 	lds	r24, 0x32C1
    716a:	83 30       	cpi	r24, 0x03	; 3
    716c:	50 f0       	brcs	.+20     	; 0x7182 <arpArpIn+0x54>
      arpPrintHeader(arpDebug, nicState.layer3.arp);   
    716e:	60 91 e8 31 	lds	r22, 0x31E8
    7172:	70 91 e9 31 	lds	r23, 0x31E9
    7176:	80 91 ee 31 	lds	r24, 0x31EE
    717a:	90 91 ef 31 	lds	r25, 0x31EF
    717e:	0e 94 aa 37 	call	0x6f54	; 0x6f54 <arpPrintHeader>
  }
#endif

// for now, we just reply to requests
// need to add ARP cache
  if((nicState.layer3.arp->dipaddr == IpMyConfig.ip) && (nicState.layer3.arp->opcode == htons(ARP_OPCODE_REQUEST)) )
    7182:	e0 91 e8 31 	lds	r30, 0x31E8
    7186:	f0 91 e9 31 	lds	r31, 0x31E9
    718a:	20 8d       	ldd	r18, Z+24	; 0x18
    718c:	31 8d       	ldd	r19, Z+25	; 0x19
    718e:	42 8d       	ldd	r20, Z+26	; 0x1a
    7190:	53 8d       	ldd	r21, Z+27	; 0x1b
    7192:	80 91 b2 32 	lds	r24, 0x32B2
    7196:	90 91 b3 32 	lds	r25, 0x32B3
    719a:	a0 91 b4 32 	lds	r26, 0x32B4
    719e:	b0 91 b5 32 	lds	r27, 0x32B5
    71a2:	28 17       	cp	r18, r24
    71a4:	39 07       	cpc	r19, r25
    71a6:	4a 07       	cpc	r20, r26
    71a8:	5b 07       	cpc	r21, r27
    71aa:	09 f0       	breq	.+2      	; 0x71ae <arpArpIn+0x80>
    71ac:	80 c0       	rjmp	.+256    	; 0x72ae <arpArpIn+0x180>
    71ae:	c6 81       	ldd	r28, Z+6	; 0x06
    71b0:	d7 81       	ldd	r29, Z+7	; 0x07
    71b2:	81 e0       	ldi	r24, 0x01	; 1
    71b4:	90 e0       	ldi	r25, 0x00	; 0
    71b6:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    71ba:	c8 17       	cp	r28, r24
    71bc:	d9 07       	cpc	r29, r25
    71be:	09 f0       	breq	.+2      	; 0x71c2 <arpArpIn+0x94>
    71c0:	76 c0       	rjmp	.+236    	; 0x72ae <arpArpIn+0x180>
  {
// in ARP header
// copy sender's address info to dest. fields
    nicState.layer3.arp->dhwaddr = nicState.layer3.arp->shwaddr;
    71c2:	e0 91 e8 31 	lds	r30, 0x31E8
    71c6:	f0 91 e9 31 	lds	r31, 0x31E9
    71ca:	ef 01       	movw	r28, r30
    71cc:	62 96       	adiw	r28, 0x12	; 18
    71ce:	df 01       	movw	r26, r30
    71d0:	18 96       	adiw	r26, 0x08	; 8
    71d2:	86 e0       	ldi	r24, 0x06	; 6
    71d4:	0d 90       	ld	r0, X+
    71d6:	09 92       	st	Y+, r0
    71d8:	81 50       	subi	r24, 0x01	; 1
    71da:	e1 f7       	brne	.-8      	; 0x71d4 <arpArpIn+0xa6>
    nicState.layer3.arp->dipaddr = nicState.layer3.arp->sipaddr;
    71dc:	86 85       	ldd	r24, Z+14	; 0x0e
    71de:	97 85       	ldd	r25, Z+15	; 0x0f
    71e0:	a0 89       	ldd	r26, Z+16	; 0x10
    71e2:	b1 89       	ldd	r27, Z+17	; 0x11
    71e4:	80 8f       	std	Z+24, r24	; 0x18
    71e6:	91 8f       	std	Z+25, r25	; 0x19
    71e8:	a2 8f       	std	Z+26, r26	; 0x1a
    71ea:	b3 8f       	std	Z+27, r27	; 0x1b
// fill in our information
    nicState.layer3.arp->shwaddr =  nicState.mac;
    71ec:	38 96       	adiw	r30, 0x08	; 8
    71ee:	a0 ee       	ldi	r26, 0xE0	; 224
    71f0:	b1 e3       	ldi	r27, 0x31	; 49
    71f2:	86 e0       	ldi	r24, 0x06	; 6
    71f4:	0d 90       	ld	r0, X+
    71f6:	01 92       	st	Z+, r0
    71f8:	81 50       	subi	r24, 0x01	; 1
    71fa:	e1 f7       	brne	.-8      	; 0x71f4 <arpArpIn+0xc6>
    nicState.layer3.arp->sipaddr =  IpMyConfig.ip;
    71fc:	c0 91 e8 31 	lds	r28, 0x31E8
    7200:	d0 91 e9 31 	lds	r29, 0x31E9
    7204:	80 91 b2 32 	lds	r24, 0x32B2
    7208:	90 91 b3 32 	lds	r25, 0x32B3
    720c:	a0 91 b4 32 	lds	r26, 0x32B4
    7210:	b0 91 b5 32 	lds	r27, 0x32B5
    7214:	8e 87       	std	Y+14, r24	; 0x0e
    7216:	9f 87       	std	Y+15, r25	; 0x0f
    7218:	a8 8b       	std	Y+16, r26	; 0x10
    721a:	b9 8b       	std	Y+17, r27	; 0x11
// change op to reply
    nicState.layer3.arp->opcode = htons(ARP_OPCODE_REPLY);
    721c:	82 e0       	ldi	r24, 0x02	; 2
    721e:	90 e0       	ldi	r25, 0x00	; 0
    7220:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    7224:	8e 83       	std	Y+6, r24	; 0x06
    7226:	9f 83       	std	Y+7, r25	; 0x07

// in ethernet header
    nicState.layer2.ethHeader->dest = nicState.layer2.ethHeader->src;
    7228:	e0 91 e6 31 	lds	r30, 0x31E6
    722c:	f0 91 e7 31 	lds	r31, 0x31E7
    7230:	df 01       	movw	r26, r30
    7232:	16 96       	adiw	r26, 0x06	; 6
    7234:	86 e0       	ldi	r24, 0x06	; 6
    7236:	0d 90       	ld	r0, X+
    7238:	01 92       	st	Z+, r0
    723a:	81 50       	subi	r24, 0x01	; 1
    723c:	e1 f7       	brne	.-8      	; 0x7236 <arpArpIn+0x108>
    nicState.layer2.ethHeader->src  = nicState.mac;
    723e:	e0 91 e6 31 	lds	r30, 0x31E6
    7242:	f0 91 e7 31 	lds	r31, 0x31E7
    7246:	36 96       	adiw	r30, 0x06	; 6
    7248:	a0 ee       	ldi	r26, 0xE0	; 224
    724a:	b1 e3       	ldi	r27, 0x31	; 49
    724c:	86 e0       	ldi	r24, 0x06	; 6
    724e:	0d 90       	ld	r0, X+
    7250:	01 92       	st	Z+, r0
    7252:	81 50       	subi	r24, 0x01	; 1
    7254:	e1 f7       	brne	.-8      	; 0x724e <arpArpIn+0x120>

#ifdef ARP_DEBUG
    if (arpDebug != NULL)
    7256:	80 91 ee 31 	lds	r24, 0x31EE
    725a:	90 91 ef 31 	lds	r25, 0x31EF
    725e:	00 97       	sbiw	r24, 0x00	; 0
    7260:	11 f1       	breq	.+68     	; 0x72a6 <arpArpIn+0x178>
    {
      if (arpDebugLevel > 0)
    7262:	20 91 c1 32 	lds	r18, 0x32C1
    7266:	22 23       	and	r18, r18
    7268:	81 f0       	breq	.+32     	; 0x728a <arpArpIn+0x15c>
        fprintf_P(arpDebug, PSTR("Sending ARP Reply\r\n"));
    726a:	00 d0       	rcall	.+0      	; 0x726c <arpArpIn+0x13e>
    726c:	0f 92       	push	r0
    726e:	ed b7       	in	r30, 0x3d	; 61
    7270:	fe b7       	in	r31, 0x3e	; 62
    7272:	81 83       	std	Z+1, r24	; 0x01
    7274:	92 83       	std	Z+2, r25	; 0x02
    7276:	86 e3       	ldi	r24, 0x36	; 54
    7278:	9d e0       	ldi	r25, 0x0D	; 13
    727a:	83 83       	std	Z+3, r24	; 0x03
    727c:	94 83       	std	Z+4, r25	; 0x04
    727e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7282:	0f 90       	pop	r0
    7284:	0f 90       	pop	r0
    7286:	0f 90       	pop	r0
    7288:	0f 90       	pop	r0
      if (arpDebugLevel > 2)
    728a:	80 91 c1 32 	lds	r24, 0x32C1
    728e:	83 30       	cpi	r24, 0x03	; 3
    7290:	50 f0       	brcs	.+20     	; 0x72a6 <arpArpIn+0x178>
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    7292:	60 91 e8 31 	lds	r22, 0x31E8
    7296:	70 91 e9 31 	lds	r23, 0x31E9
    729a:	80 91 ee 31 	lds	r24, 0x31EE
    729e:	90 91 ef 31 	lds	r25, 0x31EF
    72a2:	0e 94 aa 37 	call	0x6f54	; 0x6f54 <arpPrintHeader>
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    72a6:	8a e2       	ldi	r24, 0x2A	; 42
    72a8:	90 e0       	ldi	r25, 0x00	; 0
    72aa:	0e 94 1c 2c 	call	0x5838	; 0x5838 <nicSend>
  }
}
    72ae:	df 91       	pop	r29
    72b0:	cf 91       	pop	r28
    72b2:	08 95       	ret

000072b4 <arpPrintTable>:
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
}
#endif /*ARP_DEBUG*/

void arpPrintTable(FILE *stream)
{
    72b4:	6f 92       	push	r6
    72b6:	7f 92       	push	r7
    72b8:	8f 92       	push	r8
    72ba:	9f 92       	push	r9
    72bc:	af 92       	push	r10
    72be:	bf 92       	push	r11
    72c0:	cf 92       	push	r12
    72c2:	df 92       	push	r13
    72c4:	ef 92       	push	r14
    72c6:	ff 92       	push	r15
    72c8:	0f 93       	push	r16
    72ca:	1f 93       	push	r17
    72cc:	cf 93       	push	r28
    72ce:	df 93       	push	r29
    72d0:	ec 01       	movw	r28, r24
  uint8_t i;

  // print ARP table
  fprintf_P(stream, PSTR("Time Eth Address        IP Address\r\n"));
    72d2:	00 d0       	rcall	.+0      	; 0x72d4 <arpPrintTable+0x20>
    72d4:	0f 92       	push	r0
    72d6:	ad b7       	in	r26, 0x3d	; 61
    72d8:	be b7       	in	r27, 0x3e	; 62
    72da:	11 96       	adiw	r26, 0x01	; 1
    72dc:	8d 93       	st	X+, r24
    72de:	9c 93       	st	X, r25
    72e0:	12 97       	sbiw	r26, 0x02	; 2
    72e2:	8a e7       	ldi	r24, 0x7A	; 122
    72e4:	9c e0       	ldi	r25, 0x0C	; 12
    72e6:	13 96       	adiw	r26, 0x03	; 3
    72e8:	8d 93       	st	X+, r24
    72ea:	9c 93       	st	X, r25
    72ec:	14 97       	sbiw	r26, 0x04	; 4
    72ee:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("-----------------------------------\r\n"));
    72f2:	ed b7       	in	r30, 0x3d	; 61
    72f4:	fe b7       	in	r31, 0x3e	; 62
    72f6:	c1 83       	std	Z+1, r28	; 0x01
    72f8:	d2 83       	std	Z+2, r29	; 0x02
    72fa:	84 e5       	ldi	r24, 0x54	; 84
    72fc:	9c e0       	ldi	r25, 0x0C	; 12
    72fe:	83 83       	std	Z+3, r24	; 0x03
    7300:	94 83       	std	Z+4, r25	; 0x04
    7302:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR(" MY  "));
    7306:	ad b7       	in	r26, 0x3d	; 61
    7308:	be b7       	in	r27, 0x3e	; 62
    730a:	11 96       	adiw	r26, 0x01	; 1
    730c:	cd 93       	st	X+, r28
    730e:	dc 93       	st	X, r29
    7310:	12 97       	sbiw	r26, 0x02	; 2
    7312:	8e e4       	ldi	r24, 0x4E	; 78
    7314:	9c e0       	ldi	r25, 0x0C	; 12
    7316:	13 96       	adiw	r26, 0x03	; 3
    7318:	8d 93       	st	X+, r24
    731a:	9c 93       	st	X, r25
    731c:	14 97       	sbiw	r26, 0x04	; 4
    731e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    7322:	0f 90       	pop	r0
    7324:	0f 90       	pop	r0
    7326:	0f 90       	pop	r0
    7328:	0f 90       	pop	r0
    732a:	ce 01       	movw	r24, r28
    732c:	60 ee       	ldi	r22, 0xE0	; 224
    732e:	71 e3       	ldi	r23, 0x31	; 49
    7330:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
  fprintf_P(stream, PSTR("  "));
    7334:	00 d0       	rcall	.+0      	; 0x7336 <arpPrintTable+0x82>
    7336:	0f 92       	push	r0
    7338:	ed b7       	in	r30, 0x3d	; 61
    733a:	fe b7       	in	r31, 0x3e	; 62
    733c:	c1 83       	std	Z+1, r28	; 0x01
    733e:	d2 83       	std	Z+2, r29	; 0x02
    7340:	8b e4       	ldi	r24, 0x4B	; 75
    7342:	9c e0       	ldi	r25, 0x0C	; 12
    7344:	83 83       	std	Z+3, r24	; 0x03
    7346:	94 83       	std	Z+4, r25	; 0x04
    7348:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  netPrintIPAddr(stream, IpMyConfig.ip);
    734c:	0f 90       	pop	r0
    734e:	0f 90       	pop	r0
    7350:	0f 90       	pop	r0
    7352:	0f 90       	pop	r0
    7354:	40 91 b2 32 	lds	r20, 0x32B2
    7358:	50 91 b3 32 	lds	r21, 0x32B3
    735c:	60 91 b4 32 	lds	r22, 0x32B4
    7360:	70 91 b5 32 	lds	r23, 0x32B5
    7364:	ce 01       	movw	r24, r28
    7366:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    736a:	00 d0       	rcall	.+0      	; 0x736c <arpPrintTable+0xb8>
    736c:	0f 92       	push	r0
    736e:	ad b7       	in	r26, 0x3d	; 61
    7370:	be b7       	in	r27, 0x3e	; 62
    7372:	11 96       	adiw	r26, 0x01	; 1
    7374:	cd 93       	st	X+, r28
    7376:	dc 93       	st	X, r29
    7378:	12 97       	sbiw	r26, 0x02	; 2
    737a:	88 e4       	ldi	r24, 0x48	; 72
    737c:	9c e0       	ldi	r25, 0x0C	; 12
    737e:	13 96       	adiw	r26, 0x03	; 3
    7380:	8d 93       	st	X+, r24
    7382:	9c 93       	st	X, r25
    7384:	14 97       	sbiw	r26, 0x04	; 4
    7386:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    738a:	0e ec       	ldi	r16, 0xCE	; 206
    738c:	12 e3       	ldi	r17, 0x32	; 50
    738e:	0f 90       	pop	r0
    7390:	0f 90       	pop	r0
    7392:	0f 90       	pop	r0
    7394:	0f 90       	pop	r0
    7396:	ee 24       	eor	r14, r14
    7398:	ff 24       	eor	r15, r15

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    739a:	32 e4       	ldi	r19, 0x42	; 66
    739c:	c3 2e       	mov	r12, r19
    739e:	3c e0       	ldi	r19, 0x0C	; 12
    73a0:	d3 2e       	mov	r13, r19
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    73a2:	2b e0       	ldi	r18, 0x0B	; 11
    73a4:	a2 2e       	mov	r10, r18
    73a6:	b1 2c       	mov	r11, r1
    fprintf_P(stream, PSTR("  "));
    73a8:	9f e3       	ldi	r25, 0x3F	; 63
    73aa:	89 2e       	mov	r8, r25
    73ac:	9c e0       	ldi	r25, 0x0C	; 12
    73ae:	99 2e       	mov	r9, r25
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
    73b0:	8c e3       	ldi	r24, 0x3C	; 60
    73b2:	68 2e       	mov	r6, r24
    73b4:	8c e0       	ldi	r24, 0x0C	; 12
    73b6:	78 2e       	mov	r7, r24
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
    73b8:	f8 01       	movw	r30, r16
    73ba:	80 81       	ld	r24, Z
    73bc:	91 81       	ldd	r25, Z+1	; 0x01
    73be:	a2 81       	ldd	r26, Z+2	; 0x02
    73c0:	b3 81       	ldd	r27, Z+3	; 0x03
    73c2:	00 97       	sbiw	r24, 0x00	; 0
    73c4:	a1 05       	cpc	r26, r1
    73c6:	b1 05       	cpc	r27, r1
    73c8:	09 f4       	brne	.+2      	; 0x73cc <arpPrintTable+0x118>
    73ca:	51 c0       	rjmp	.+162    	; 0x746e <arpPrintTable+0x1ba>
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    73cc:	00 d0       	rcall	.+0      	; 0x73ce <arpPrintTable+0x11a>
    73ce:	00 d0       	rcall	.+0      	; 0x73d0 <arpPrintTable+0x11c>
    73d0:	ed b7       	in	r30, 0x3d	; 61
    73d2:	fe b7       	in	r31, 0x3e	; 62
    73d4:	31 96       	adiw	r30, 0x01	; 1
    73d6:	ad b7       	in	r26, 0x3d	; 61
    73d8:	be b7       	in	r27, 0x3e	; 62
    73da:	11 96       	adiw	r26, 0x01	; 1
    73dc:	cd 93       	st	X+, r28
    73de:	dc 93       	st	X, r29
    73e0:	12 97       	sbiw	r26, 0x02	; 2
    73e2:	c2 82       	std	Z+2, r12	; 0x02
    73e4:	d3 82       	std	Z+3, r13	; 0x03
    73e6:	d8 01       	movw	r26, r16
    73e8:	1a 96       	adiw	r26, 0x0a	; 10
    73ea:	8c 91       	ld	r24, X
    73ec:	84 83       	std	Z+4, r24	; 0x04
    73ee:	15 82       	std	Z+5, r1	; 0x05
    73f0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    73f4:	ed b7       	in	r30, 0x3d	; 61
    73f6:	fe b7       	in	r31, 0x3e	; 62
    73f8:	36 96       	adiw	r30, 0x06	; 6
    73fa:	ed bf       	out	0x3d, r30	; 61
    73fc:	fe bf       	out	0x3e, r31	; 62
    73fe:	ea 9c       	mul	r14, r10
    7400:	b0 01       	movw	r22, r0
    7402:	eb 9c       	mul	r14, r11
    7404:	70 0d       	add	r23, r0
    7406:	fa 9c       	mul	r15, r10
    7408:	70 0d       	add	r23, r0
    740a:	11 24       	eor	r1, r1
    740c:	6e 52       	subi	r22, 0x2E	; 46
    740e:	7d 4c       	sbci	r23, 0xCD	; 205
    7410:	ce 01       	movw	r24, r28
    7412:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <netPrintEthAddr>
    fprintf_P(stream, PSTR("  "));
    7416:	00 d0       	rcall	.+0      	; 0x7418 <arpPrintTable+0x164>
    7418:	0f 92       	push	r0
    741a:	ad b7       	in	r26, 0x3d	; 61
    741c:	be b7       	in	r27, 0x3e	; 62
    741e:	11 96       	adiw	r26, 0x01	; 1
    7420:	cd 93       	st	X+, r28
    7422:	dc 93       	st	X, r29
    7424:	12 97       	sbiw	r26, 0x02	; 2
    7426:	13 96       	adiw	r26, 0x03	; 3
    7428:	8d 92       	st	X+, r8
    742a:	9c 92       	st	X, r9
    742c:	14 97       	sbiw	r26, 0x04	; 4
    742e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    7432:	0f 90       	pop	r0
    7434:	0f 90       	pop	r0
    7436:	0f 90       	pop	r0
    7438:	0f 90       	pop	r0
    743a:	f8 01       	movw	r30, r16
    743c:	40 81       	ld	r20, Z
    743e:	51 81       	ldd	r21, Z+1	; 0x01
    7440:	62 81       	ldd	r22, Z+2	; 0x02
    7442:	73 81       	ldd	r23, Z+3	; 0x03
    7444:	ce 01       	movw	r24, r28
    7446:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
    fprintf_P(stream, PSTR("\r\n"));
    744a:	00 d0       	rcall	.+0      	; 0x744c <arpPrintTable+0x198>
    744c:	0f 92       	push	r0
    744e:	ad b7       	in	r26, 0x3d	; 61
    7450:	be b7       	in	r27, 0x3e	; 62
    7452:	11 96       	adiw	r26, 0x01	; 1
    7454:	cd 93       	st	X+, r28
    7456:	dc 93       	st	X, r29
    7458:	12 97       	sbiw	r26, 0x02	; 2
    745a:	13 96       	adiw	r26, 0x03	; 3
    745c:	6d 92       	st	X+, r6
    745e:	7c 92       	st	X, r7
    7460:	14 97       	sbiw	r26, 0x04	; 4
    7462:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7466:	0f 90       	pop	r0
    7468:	0f 90       	pop	r0
    746a:	0f 90       	pop	r0
    746c:	0f 90       	pop	r0
    746e:	08 94       	sec
    7470:	e1 1c       	adc	r14, r1
    7472:	f1 1c       	adc	r15, r1
    7474:	05 5f       	subi	r16, 0xF5	; 245
    7476:	1f 4f       	sbci	r17, 0xFF	; 255
  netPrintEthAddr(stream, &nicState.mac);
  fprintf_P(stream, PSTR("  "));
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
    7478:	ba e0       	ldi	r27, 0x0A	; 10
    747a:	eb 16       	cp	r14, r27
    747c:	f1 04       	cpc	r15, r1
    747e:	09 f0       	breq	.+2      	; 0x7482 <arpPrintTable+0x1ce>
    7480:	9b cf       	rjmp	.-202    	; 0x73b8 <arpPrintTable+0x104>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
  }
}
    7482:	df 91       	pop	r29
    7484:	cf 91       	pop	r28
    7486:	1f 91       	pop	r17
    7488:	0f 91       	pop	r16
    748a:	ff 90       	pop	r15
    748c:	ef 90       	pop	r14
    748e:	df 90       	pop	r13
    7490:	cf 90       	pop	r12
    7492:	bf 90       	pop	r11
    7494:	af 90       	pop	r10
    7496:	9f 90       	pop	r9
    7498:	8f 90       	pop	r8
    749a:	7f 90       	pop	r7
    749c:	6f 90       	pop	r6
    749e:	08 95       	ret

000074a0 <socketInit>:
 * @param *sck socket
 */
static inline void tcpAcceptConn(struct TcpIpSocket *sck);

inline void socketInit(void)
{
    74a0:	bf 92       	push	r11
    74a2:	cf 92       	push	r12
    74a4:	df 92       	push	r13
    74a6:	ef 92       	push	r14
    74a8:	ff 92       	push	r15
    74aa:	0f 93       	push	r16
    74ac:	1f 93       	push	r17
    74ae:	cf 93       	push	r28
    74b0:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    74b2:	80 e3       	ldi	r24, 0x30	; 48
    74b4:	92 e0       	ldi	r25, 0x02	; 2
    74b6:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <xmalloc>
    74ba:	80 93 20 32 	sts	0x3220, r24
    74be:	90 93 21 32 	sts	0x3221, r25
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    74c2:	fc 01       	movw	r30, r24
    74c4:	80 e3       	ldi	r24, 0x30	; 48
    74c6:	92 e0       	ldi	r25, 0x02	; 2
    74c8:	df 01       	movw	r26, r30
    74ca:	9c 01       	movw	r18, r24
    74cc:	1d 92       	st	X+, r1
    74ce:	21 50       	subi	r18, 0x01	; 1
    74d0:	30 40       	sbci	r19, 0x00	; 0
    74d2:	e1 f7       	brne	.-8      	; 0x74cc <socketInit+0x2c>
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    74d4:	00 91 20 32 	lds	r16, 0x3220
    74d8:	10 91 21 32 	lds	r17, 0x3221
    74dc:	c8 ea       	ldi	r28, 0xA8	; 168
    74de:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    74e0:	8f ef       	ldi	r24, 0xFF	; 255
    74e2:	c8 2e       	mov	r12, r24
    74e4:	81 e1       	ldi	r24, 0x11	; 17
    74e6:	d8 2e       	mov	r13, r24
    74e8:	82 e2       	ldi	r24, 0x22	; 34
    74ea:	e8 2e       	mov	r14, r24
    74ec:	83 e3       	ldi	r24, 0x33	; 51
    74ee:	f8 2e       	mov	r15, r24
    sck->state         = LISTEN;   
    74f0:	bb 24       	eor	r11, r11
    74f2:	b3 94       	inc	r11
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    74f4:	de 01       	movw	r26, r28
    74f6:	a8 5a       	subi	r26, 0xA8	; 168
    74f8:	a0 31       	cpi	r26, 0x10	; 16
    74fa:	20 f4       	brcc	.+8      	; 0x7504 <socketInit+0x64>
    74fc:	ce 01       	movw	r24, r28
    74fe:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    7502:	02 c0       	rjmp	.+4      	; 0x7508 <socketInit+0x68>
    7504:	88 eb       	ldi	r24, 0xB8	; 184
    7506:	91 e6       	ldi	r25, 0x61	; 97
    7508:	f8 01       	movw	r30, r16
    750a:	85 83       	std	Z+5, r24	; 0x05
    750c:	96 83       	std	Z+6, r25	; 0x06
    sck->seqNoLastSent = HTONL(0xFF112233); 
    750e:	d8 01       	movw	r26, r16
    7510:	1d 96       	adiw	r26, 0x0d	; 13
    7512:	cd 92       	st	X+, r12
    7514:	dd 92       	st	X+, r13
    7516:	ed 92       	st	X+, r14
    7518:	fc 92       	st	X, r15
    751a:	50 97       	sbiw	r26, 0x10	; 16
    sck->state         = LISTEN;   
    751c:	bc 92       	st	X, r11
    751e:	21 96       	adiw	r28, 0x01	; 1
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    7520:	b1 e6       	ldi	r27, 0x61	; 97
    7522:	cc 3b       	cpi	r28, 0xBC	; 188
    7524:	db 07       	cpc	r29, r27
    7526:	19 f0       	breq	.+6      	; 0x752e <socketInit+0x8e>
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    sck->state         = LISTEN;   
    sck++;
    7528:	04 5e       	subi	r16, 0xE4	; 228
    752a:	1f 4f       	sbci	r17, 0xFF	; 255
    752c:	e3 cf       	rjmp	.-58     	; 0x74f4 <socketInit+0x54>
  }
}
    752e:	df 91       	pop	r29
    7530:	cf 91       	pop	r28
    7532:	1f 91       	pop	r17
    7534:	0f 91       	pop	r16
    7536:	ff 90       	pop	r15
    7538:	ef 90       	pop	r14
    753a:	df 90       	pop	r13
    753c:	cf 90       	pop	r12
    753e:	bf 90       	pop	r11
    7540:	08 95       	ret

00007542 <calculateTcpChecksun>:
  
  return 0;
}

void calculateTcpChecksun(uint16_t tcpLen)
{
    7542:	cf 93       	push	r28
    7544:	df 93       	push	r29
    7546:	bc 01       	movw	r22, r24
  nicState.layer4.tcp->tcpchksum = 0;
    7548:	c0 91 ea 31 	lds	r28, 0x31EA
    754c:	d0 91 eb 31 	lds	r29, 0x31EB
    7550:	18 8a       	std	Y+16, r1	; 0x10
    7552:	19 8a       	std	Y+17, r1	; 0x11
  nicState.layer4.tcp->tcpchksum = netChecksum(nicState.layer4.tcp, tcpLen); //TODO finish it
    7554:	ce 01       	movw	r24, r28
    7556:	0e 94 bb 2e 	call	0x5d76	; 0x5d76 <netChecksum>
    755a:	88 8b       	std	Y+16, r24	; 0x10
    755c:	99 8b       	std	Y+17, r25	; 0x11
}
    755e:	df 91       	pop	r29
    7560:	cf 91       	pop	r28
    7562:	08 95       	ret

00007564 <processTcpPacket>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket(void)
{
    7564:	af 92       	push	r10
    7566:	bf 92       	push	r11
    7568:	cf 92       	push	r12
    756a:	df 92       	push	r13
    756c:	ef 92       	push	r14
    756e:	ff 92       	push	r15
    7570:	0f 93       	push	r16
    7572:	1f 93       	push	r17
    7574:	cf 93       	push	r28
    7576:	df 93       	push	r29
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    7578:	e0 91 20 32 	lds	r30, 0x3220
    757c:	f0 91 21 32 	lds	r31, 0x3221
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    7580:	00 91 e8 31 	lds	r16, 0x31E8
    7584:	10 91 e9 31 	lds	r17, 0x31E9
    7588:	60 91 ea 31 	lds	r22, 0x31EA
    758c:	70 91 eb 31 	lds	r23, 0x31EB
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    7590:	ef 01       	movw	r28, r30
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    7592:	ee 24       	eor	r14, r14
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
    7594:	f8 80       	ld	r15, Y
    7596:	8f 2d       	mov	r24, r15
    7598:	82 30       	cpi	r24, 0x02	; 2
    759a:	08 f4       	brcc	.+2      	; 0x759e <processTcpPacket+0x3a>
    759c:	47 c0       	rjmp	.+142    	; 0x762c <processTcpPacket+0xc8>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    759e:	29 81       	ldd	r18, Y+1	; 0x01
    75a0:	3a 81       	ldd	r19, Y+2	; 0x02
    75a2:	4b 81       	ldd	r20, Y+3	; 0x03
    75a4:	5c 81       	ldd	r21, Y+4	; 0x04
    75a6:	d8 01       	movw	r26, r16
    75a8:	1c 96       	adiw	r26, 0x0c	; 12
    75aa:	ad 90       	ld	r10, X+
    75ac:	bd 90       	ld	r11, X+
    75ae:	cd 90       	ld	r12, X+
    75b0:	dc 90       	ld	r13, X
    75b2:	1f 97       	sbiw	r26, 0x0f	; 15
    75b4:	2a 15       	cp	r18, r10
    75b6:	3b 05       	cpc	r19, r11
    75b8:	4c 05       	cpc	r20, r12
    75ba:	5d 05       	cpc	r21, r13
    75bc:	b9 f5       	brne	.+110    	; 0x762c <processTcpPacket+0xc8>
    75be:	2d 81       	ldd	r18, Y+5	; 0x05
    75c0:	3e 81       	ldd	r19, Y+6	; 0x06
    75c2:	db 01       	movw	r26, r22
    75c4:	12 96       	adiw	r26, 0x02	; 2
    75c6:	8d 91       	ld	r24, X+
    75c8:	9c 91       	ld	r25, X
    75ca:	13 97       	sbiw	r26, 0x03	; 3
    75cc:	28 17       	cp	r18, r24
    75ce:	39 07       	cpc	r19, r25
    75d0:	69 f5       	brne	.+90     	; 0x762c <processTcpPacket+0xc8>
    75d2:	2f 81       	ldd	r18, Y+7	; 0x07
    75d4:	38 85       	ldd	r19, Y+8	; 0x08
    75d6:	8d 91       	ld	r24, X+
    75d8:	9c 91       	ld	r25, X
    75da:	11 97       	sbiw	r26, 0x01	; 1
    75dc:	28 17       	cp	r18, r24
    75de:	39 07       	cpc	r19, r25
    75e0:	29 f5       	brne	.+74     	; 0x762c <processTcpPacket+0xc8>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    75e2:	80 91 b0 32 	lds	r24, 0x32B0
    75e6:	90 91 b1 32 	lds	r25, 0x32B1
    75ea:	00 97       	sbiw	r24, 0x00	; 0
    75ec:	09 f4       	brne	.+2      	; 0x75f0 <processTcpPacket+0x8c>
    75ee:	90 c0       	rjmp	.+288    	; 0x7710 <processTcpPacket+0x1ac>
        if (tcpDebugLevel > 2)
    75f0:	20 91 07 32 	lds	r18, 0x3207
    75f4:	23 30       	cpi	r18, 0x03	; 3
    75f6:	08 f4       	brcc	.+2      	; 0x75fa <processTcpPacket+0x96>
    75f8:	8b c0       	rjmp	.+278    	; 0x7710 <processTcpPacket+0x1ac>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    75fa:	00 d0       	rcall	.+0      	; 0x75fc <processTcpPacket+0x98>
    75fc:	00 d0       	rcall	.+0      	; 0x75fe <processTcpPacket+0x9a>
    75fe:	ed b7       	in	r30, 0x3d	; 61
    7600:	fe b7       	in	r31, 0x3e	; 62
    7602:	31 96       	adiw	r30, 0x01	; 1
    7604:	ad b7       	in	r26, 0x3d	; 61
    7606:	be b7       	in	r27, 0x3e	; 62
    7608:	11 96       	adiw	r26, 0x01	; 1
    760a:	8d 93       	st	X+, r24
    760c:	9c 93       	st	X, r25
    760e:	12 97       	sbiw	r26, 0x02	; 2
    7610:	8a eb       	ldi	r24, 0xBA	; 186
    7612:	9e e0       	ldi	r25, 0x0E	; 14
    7614:	82 83       	std	Z+2, r24	; 0x02
    7616:	93 83       	std	Z+3, r25	; 0x03
    7618:	f4 82       	std	Z+4, r15	; 0x04
    761a:	15 82       	std	Z+5, r1	; 0x05
    761c:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7620:	ed b7       	in	r30, 0x3d	; 61
    7622:	fe b7       	in	r31, 0x3e	; 62
    7624:	36 96       	adiw	r30, 0x06	; 6
    7626:	ed bf       	out	0x3d, r30	; 61
    7628:	fe bf       	out	0x3e, r31	; 62
    762a:	72 c0       	rjmp	.+228    	; 0x7710 <processTcpPacket+0x1ac>

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    762c:	e3 94       	inc	r14
    762e:	8e 2d       	mov	r24, r14
    7630:	84 31       	cpi	r24, 0x14	; 20
    7632:	11 f0       	breq	.+4      	; 0x7638 <processTcpPacket+0xd4>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
#endif      
      return result;
    }
    result++;
    7634:	6c 96       	adiw	r28, 0x1c	; 28
    7636:	ae cf       	rjmp	.-164    	; 0x7594 <processTcpPacket+0x30>
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    7638:	00 e0       	ldi	r16, 0x00	; 0
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    763a:	80 81       	ld	r24, Z
    763c:	81 30       	cpi	r24, 0x01	; 1
    763e:	b9 f5       	brne	.+110    	; 0x76ae <processTcpPacket+0x14a>
    7640:	45 81       	ldd	r20, Z+5	; 0x05
    7642:	56 81       	ldd	r21, Z+6	; 0x06
    7644:	db 01       	movw	r26, r22
    7646:	12 96       	adiw	r26, 0x02	; 2
    7648:	2d 91       	ld	r18, X+
    764a:	3c 91       	ld	r19, X
    764c:	13 97       	sbiw	r26, 0x03	; 3
    764e:	42 17       	cp	r20, r18
    7650:	53 07       	cpc	r21, r19
    7652:	69 f5       	brne	.+90     	; 0x76ae <processTcpPacket+0x14a>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    7654:	80 91 b0 32 	lds	r24, 0x32B0
    7658:	90 91 b1 32 	lds	r25, 0x32B1
    765c:	00 97       	sbiw	r24, 0x00	; 0
    765e:	e1 f0       	breq	.+56     	; 0x7698 <processTcpPacket+0x134>
        if (tcpDebugLevel > 2)
    7660:	20 91 07 32 	lds	r18, 0x3207
    7664:	23 30       	cpi	r18, 0x03	; 3
    7666:	c0 f0       	brcs	.+48     	; 0x7698 <processTcpPacket+0x134>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    7668:	00 d0       	rcall	.+0      	; 0x766a <processTcpPacket+0x106>
    766a:	00 d0       	rcall	.+0      	; 0x766c <processTcpPacket+0x108>
    766c:	ed b7       	in	r30, 0x3d	; 61
    766e:	fe b7       	in	r31, 0x3e	; 62
    7670:	31 96       	adiw	r30, 0x01	; 1
    7672:	ad b7       	in	r26, 0x3d	; 61
    7674:	be b7       	in	r27, 0x3e	; 62
    7676:	11 96       	adiw	r26, 0x01	; 1
    7678:	8d 93       	st	X+, r24
    767a:	9c 93       	st	X, r25
    767c:	12 97       	sbiw	r26, 0x02	; 2
    767e:	24 e9       	ldi	r18, 0x94	; 148
    7680:	3e e0       	ldi	r19, 0x0E	; 14
    7682:	22 83       	std	Z+2, r18	; 0x02
    7684:	33 83       	std	Z+3, r19	; 0x03
    7686:	04 83       	std	Z+4, r16	; 0x04
    7688:	15 82       	std	Z+5, r1	; 0x05
    768a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    768e:	ed b7       	in	r30, 0x3d	; 61
    7690:	fe b7       	in	r31, 0x3e	; 62
    7692:	36 96       	adiw	r30, 0x06	; 6
    7694:	ed bf       	out	0x3d, r30	; 61
    7696:	fe bf       	out	0x3e, r31	; 62
#endif      
      return &sockets[i];
    7698:	8c e1       	ldi	r24, 0x1C	; 28
    769a:	08 9f       	mul	r16, r24
    769c:	c0 01       	movw	r24, r0
    769e:	11 24       	eor	r1, r1
    76a0:	c0 91 20 32 	lds	r28, 0x3220
    76a4:	d0 91 21 32 	lds	r29, 0x3221
    76a8:	c8 0f       	add	r28, r24
    76aa:	d9 1f       	adc	r29, r25
    76ac:	31 c0       	rjmp	.+98     	; 0x7710 <processTcpPacket+0x1ac>
    }
    result++;
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    76ae:	0f 5f       	subi	r16, 0xFF	; 255
    76b0:	04 31       	cpi	r16, 0x14	; 20
    76b2:	11 f0       	breq	.+4      	; 0x76b8 <processTcpPacket+0x154>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
#endif      
      return &sockets[i];
    }
    result++;
    76b4:	7c 96       	adiw	r30, 0x1c	; 28
    76b6:	c1 cf       	rjmp	.-126    	; 0x763a <processTcpPacket+0xd6>
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    76b8:	c0 91 b0 32 	lds	r28, 0x32B0
    76bc:	d0 91 b1 32 	lds	r29, 0x32B1
    76c0:	20 97       	sbiw	r28, 0x00	; 0
    76c2:	09 f4       	brne	.+2      	; 0x76c6 <processTcpPacket+0x162>
    76c4:	5f c1       	rjmp	.+702    	; 0x7984 <processTcpPacket+0x420>
    if (tcpDebugLevel > 2)
    76c6:	80 91 07 32 	lds	r24, 0x3207
    76ca:	83 30       	cpi	r24, 0x03	; 3
    76cc:	08 f4       	brcc	.+2      	; 0x76d0 <processTcpPacket+0x16c>
    76ce:	5a c1       	rjmp	.+692    	; 0x7984 <processTcpPacket+0x420>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    76d0:	db 01       	movw	r26, r22
    76d2:	12 96       	adiw	r26, 0x02	; 2
    76d4:	8d 91       	ld	r24, X+
    76d6:	9c 91       	ld	r25, X
    76d8:	13 97       	sbiw	r26, 0x03	; 3
    76da:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    76de:	00 d0       	rcall	.+0      	; 0x76e0 <processTcpPacket+0x17c>
    76e0:	00 d0       	rcall	.+0      	; 0x76e2 <processTcpPacket+0x17e>
    76e2:	ed b7       	in	r30, 0x3d	; 61
    76e4:	fe b7       	in	r31, 0x3e	; 62
    76e6:	31 96       	adiw	r30, 0x01	; 1
    76e8:	ad b7       	in	r26, 0x3d	; 61
    76ea:	be b7       	in	r27, 0x3e	; 62
    76ec:	11 96       	adiw	r26, 0x01	; 1
    76ee:	cd 93       	st	X+, r28
    76f0:	dc 93       	st	X, r29
    76f2:	12 97       	sbiw	r26, 0x02	; 2
    76f4:	2a e6       	ldi	r18, 0x6A	; 106
    76f6:	3e e0       	ldi	r19, 0x0E	; 14
    76f8:	22 83       	std	Z+2, r18	; 0x02
    76fa:	33 83       	std	Z+3, r19	; 0x03
    76fc:	84 83       	std	Z+4, r24	; 0x04
    76fe:	95 83       	std	Z+5, r25	; 0x05
    7700:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7704:	ed b7       	in	r30, 0x3d	; 61
    7706:	fe b7       	in	r31, 0x3e	; 62
    7708:	36 96       	adiw	r30, 0x06	; 6
    770a:	ed bf       	out	0x3d, r30	; 61
    770c:	fe bf       	out	0x3e, r31	; 62
    770e:	3a c1       	rjmp	.+628    	; 0x7984 <processTcpPacket+0x420>

inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    7710:	20 97       	sbiw	r28, 0x00	; 0
    7712:	09 f4       	brne	.+2      	; 0x7716 <processTcpPacket+0x1b2>
    7714:	37 c1       	rjmp	.+622    	; 0x7984 <processTcpPacket+0x420>
    return 1;
  
  
  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    7716:	e0 91 ea 31 	lds	r30, 0x31EA
    771a:	f0 91 eb 31 	lds	r31, 0x31EB
    771e:	64 81       	ldd	r22, Z+4	; 0x04
    7720:	75 81       	ldd	r23, Z+5	; 0x05
    7722:	86 81       	ldd	r24, Z+6	; 0x06
    7724:	97 81       	ldd	r25, Z+7	; 0x07
    7726:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <htonl>
    772a:	69 87       	std	Y+9, r22	; 0x09
    772c:	7a 87       	std	Y+10, r23	; 0x0a
    772e:	8b 87       	std	Y+11, r24	; 0x0b
    7730:	9c 87       	std	Y+12, r25	; 0x0c
  
  if (socket->state == LISTEN)
    7732:	88 81       	ld	r24, Y
    7734:	81 30       	cpi	r24, 0x01	; 1
    7736:	09 f0       	breq	.+2      	; 0x773a <processTcpPacket+0x1d6>
    7738:	b8 c0       	rjmp	.+368    	; 0x78aa <processTcpPacket+0x346>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    773a:	e0 91 ea 31 	lds	r30, 0x31EA
    773e:	f0 91 eb 31 	lds	r31, 0x31EB
    7742:	25 85       	ldd	r18, Z+13	; 0x0d
    7744:	80 91 b0 32 	lds	r24, 0x32B0
    7748:	90 91 b1 32 	lds	r25, 0x32B1
    774c:	21 ff       	sbrs	r18, 1
    774e:	9a c0       	rjmp	.+308    	; 0x7884 <processTcpPacket+0x320>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    7750:	00 97       	sbiw	r24, 0x00	; 0
    7752:	c1 f0       	breq	.+48     	; 0x7784 <processTcpPacket+0x220>
        if (tcpDebugLevel > 2)
    7754:	20 91 07 32 	lds	r18, 0x3207
    7758:	23 30       	cpi	r18, 0x03	; 3
    775a:	a0 f0       	brcs	.+40     	; 0x7784 <processTcpPacket+0x220>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    775c:	00 d0       	rcall	.+0      	; 0x775e <processTcpPacket+0x1fa>
    775e:	0f 92       	push	r0
    7760:	ad b7       	in	r26, 0x3d	; 61
    7762:	be b7       	in	r27, 0x3e	; 62
    7764:	11 96       	adiw	r26, 0x01	; 1
    7766:	8d 93       	st	X+, r24
    7768:	9c 93       	st	X, r25
    776a:	12 97       	sbiw	r26, 0x02	; 2
    776c:	88 e2       	ldi	r24, 0x28	; 40
    776e:	9e e0       	ldi	r25, 0x0E	; 14
    7770:	13 96       	adiw	r26, 0x03	; 3
    7772:	8d 93       	st	X+, r24
    7774:	9c 93       	st	X, r25
    7776:	14 97       	sbiw	r26, 0x04	; 4
    7778:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    777c:	0f 90       	pop	r0
    777e:	0f 90       	pop	r0
    7780:	0f 90       	pop	r0
    7782:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    7784:	82 e0       	ldi	r24, 0x02	; 2
    7786:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    7788:	e0 91 ea 31 	lds	r30, 0x31EA
    778c:	f0 91 eb 31 	lds	r31, 0x31EB
    7790:	20 81       	ld	r18, Z
    7792:	31 81       	ldd	r19, Z+1	; 0x01
    7794:	2f 83       	std	Y+7, r18	; 0x07
    7796:	38 87       	std	Y+8, r19	; 0x08
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    7798:	e0 91 e8 31 	lds	r30, 0x31E8
    779c:	f0 91 e9 31 	lds	r31, 0x31E9
    77a0:	84 85       	ldd	r24, Z+12	; 0x0c
    77a2:	95 85       	ldd	r25, Z+13	; 0x0d
    77a4:	a6 85       	ldd	r26, Z+14	; 0x0e
    77a6:	b7 85       	ldd	r27, Z+15	; 0x0f
    77a8:	89 83       	std	Y+1, r24	; 0x01
    77aa:	9a 83       	std	Y+2, r25	; 0x02
    77ac:	ab 83       	std	Y+3, r26	; 0x03
    77ae:	bc 83       	std	Y+4, r27	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    77b0:	e0 91 ea 31 	lds	r30, 0x31EA
    77b4:	f0 91 eb 31 	lds	r31, 0x31EB
    77b8:	8d 81       	ldd	r24, Y+5	; 0x05
    77ba:	9e 81       	ldd	r25, Y+6	; 0x06
    77bc:	80 83       	st	Z, r24
    77be:	91 83       	std	Z+1, r25	; 0x01
      nicState.layer4.tcp->destport  = socket->remotePort;
    77c0:	e0 91 ea 31 	lds	r30, 0x31EA
    77c4:	f0 91 eb 31 	lds	r31, 0x31EB
    77c8:	22 83       	std	Z+2, r18	; 0x02
    77ca:	33 83       	std	Z+3, r19	; 0x03
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    77cc:	00 91 ea 31 	lds	r16, 0x31EA
    77d0:	10 91 eb 31 	lds	r17, 0x31EB
    77d4:	6d 85       	ldd	r22, Y+13	; 0x0d
    77d6:	7e 85       	ldd	r23, Y+14	; 0x0e
    77d8:	8f 85       	ldd	r24, Y+15	; 0x0f
    77da:	98 89       	ldd	r25, Y+16	; 0x10
    77dc:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <htonl>
    77e0:	f8 01       	movw	r30, r16
    77e2:	64 83       	std	Z+4, r22	; 0x04
    77e4:	75 83       	std	Z+5, r23	; 0x05
    77e6:	86 83       	std	Z+6, r24	; 0x06
    77e8:	97 83       	std	Z+7, r25	; 0x07
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    77ea:	00 91 ea 31 	lds	r16, 0x31EA
    77ee:	10 91 eb 31 	lds	r17, 0x31EB
    77f2:	69 85       	ldd	r22, Y+9	; 0x09
    77f4:	7a 85       	ldd	r23, Y+10	; 0x0a
    77f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    77f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    77fa:	6f 5f       	subi	r22, 0xFF	; 255
    77fc:	7f 4f       	sbci	r23, 0xFF	; 255
    77fe:	8f 4f       	sbci	r24, 0xFF	; 255
    7800:	9f 4f       	sbci	r25, 0xFF	; 255
    7802:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <htonl>
    7806:	d8 01       	movw	r26, r16
    7808:	18 96       	adiw	r26, 0x08	; 8
    780a:	6d 93       	st	X+, r22
    780c:	7d 93       	st	X+, r23
    780e:	8d 93       	st	X+, r24
    7810:	9c 93       	st	X, r25
    7812:	1b 97       	sbiw	r26, 0x0b	; 11
      nicState.layer4.tcp->tcpoffset = 5<<4;
    7814:	e0 91 ea 31 	lds	r30, 0x31EA
    7818:	f0 91 eb 31 	lds	r31, 0x31EB
    781c:	80 e5       	ldi	r24, 0x50	; 80
    781e:	84 87       	std	Z+12, r24	; 0x0c
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    7820:	e0 91 ea 31 	lds	r30, 0x31EA
    7824:	f0 91 eb 31 	lds	r31, 0x31EB
    7828:	82 e1       	ldi	r24, 0x12	; 18
    782a:	85 87       	std	Z+13, r24	; 0x0d
      nicState.layer4.tcp->wnd       = htons(100);
    782c:	00 91 ea 31 	lds	r16, 0x31EA
    7830:	10 91 eb 31 	lds	r17, 0x31EB
    7834:	84 e6       	ldi	r24, 0x64	; 100
    7836:	90 e0       	ldi	r25, 0x00	; 0
    7838:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    783c:	f8 01       	movw	r30, r16
    783e:	86 87       	std	Z+14, r24	; 0x0e
    7840:	97 87       	std	Z+15, r25	; 0x0f
      nicState.layer4.tcp->tcpchksum = 0;
    7842:	e0 91 ea 31 	lds	r30, 0x31EA
    7846:	f0 91 eb 31 	lds	r31, 0x31EB
    784a:	10 8a       	std	Z+16, r1	; 0x10
    784c:	11 8a       	std	Z+17, r1	; 0x11
      nicState.layer4.tcp->urgp      = 0;
    784e:	12 8a       	std	Z+18, r1	; 0x12
    7850:	13 8a       	std	Z+19, r1	; 0x13
      calculateTcpChecksun(TCP_HEADER_LEN);
    7852:	84 e1       	ldi	r24, 0x14	; 20
    7854:	90 e0       	ldi	r25, 0x00	; 0
    7856:	0e 94 a1 3a 	call	0x7542	; 0x7542 <calculateTcpChecksun>

      socket->seqNoLastSent++;
    785a:	8d 85       	ldd	r24, Y+13	; 0x0d
    785c:	9e 85       	ldd	r25, Y+14	; 0x0e
    785e:	af 85       	ldd	r26, Y+15	; 0x0f
    7860:	b8 89       	ldd	r27, Y+16	; 0x10
    7862:	01 96       	adiw	r24, 0x01	; 1
    7864:	a1 1d       	adc	r26, r1
    7866:	b1 1d       	adc	r27, r1
    7868:	8d 87       	std	Y+13, r24	; 0x0d
    786a:	9e 87       	std	Y+14, r25	; 0x0e
    786c:	af 87       	std	Y+15, r26	; 0x0f
    786e:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    7870:	69 81       	ldd	r22, Y+1	; 0x01
    7872:	7a 81       	ldd	r23, Y+2	; 0x02
    7874:	8b 81       	ldd	r24, Y+3	; 0x03
    7876:	9c 81       	ldd	r25, Y+4	; 0x04
    7878:	46 e0       	ldi	r20, 0x06	; 6
    787a:	24 e1       	ldi	r18, 0x14	; 20
    787c:	30 e0       	ldi	r19, 0x00	; 0
    787e:	0e 94 47 33 	call	0x668e	; 0x668e <ipSend>
    7882:	82 c0       	rjmp	.+260    	; 0x7988 <processTcpPacket+0x424>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    7884:	00 97       	sbiw	r24, 0x00	; 0
    7886:	09 f4       	brne	.+2      	; 0x788a <processTcpPacket+0x326>
    7888:	7f c0       	rjmp	.+254    	; 0x7988 <processTcpPacket+0x424>
        if (tcpDebugLevel > 1)
    788a:	20 91 07 32 	lds	r18, 0x3207
    788e:	22 30       	cpi	r18, 0x02	; 2
    7890:	08 f4       	brcc	.+2      	; 0x7894 <processTcpPacket+0x330>
    7892:	7a c0       	rjmp	.+244    	; 0x7988 <processTcpPacket+0x424>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    7894:	00 d0       	rcall	.+0      	; 0x7896 <processTcpPacket+0x332>
    7896:	0f 92       	push	r0
    7898:	ad b7       	in	r26, 0x3d	; 61
    789a:	be b7       	in	r27, 0x3e	; 62
    789c:	11 96       	adiw	r26, 0x01	; 1
    789e:	8d 93       	st	X+, r24
    78a0:	9c 93       	st	X, r25
    78a2:	12 97       	sbiw	r26, 0x02	; 2
    78a4:	84 ef       	ldi	r24, 0xF4	; 244
    78a6:	9d e0       	ldi	r25, 0x0D	; 13
    78a8:	37 c0       	rjmp	.+110    	; 0x7918 <processTcpPacket+0x3b4>
    }
#endif    
    return 0;
  }
  
  if (socket->state == SYN_RECEIVED)
    78aa:	82 30       	cpi	r24, 0x02	; 2
    78ac:	09 f0       	breq	.+2      	; 0x78b0 <processTcpPacket+0x34c>
    78ae:	3f c0       	rjmp	.+126    	; 0x792e <processTcpPacket+0x3ca>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    78b0:	e0 91 ea 31 	lds	r30, 0x31EA
    78b4:	f0 91 eb 31 	lds	r31, 0x31EB
    78b8:	25 85       	ldd	r18, Z+13	; 0x0d
    78ba:	80 91 b0 32 	lds	r24, 0x32B0
    78be:	90 91 b1 32 	lds	r25, 0x32B1
    78c2:	24 ff       	sbrs	r18, 4
    78c4:	15 c0       	rjmp	.+42     	; 0x78f0 <processTcpPacket+0x38c>
    {
      socket->state    = ESTABILISHED;
    78c6:	23 e0       	ldi	r18, 0x03	; 3
    78c8:	28 83       	st	Y, r18
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    78ca:	00 97       	sbiw	r24, 0x00	; 0
    78cc:	09 f4       	brne	.+2      	; 0x78d0 <processTcpPacket+0x36c>
    78ce:	5c c0       	rjmp	.+184    	; 0x7988 <processTcpPacket+0x424>
      if (tcpDebugLevel > 2)
    78d0:	20 91 07 32 	lds	r18, 0x3207
    78d4:	23 30       	cpi	r18, 0x03	; 3
    78d6:	08 f4       	brcc	.+2      	; 0x78da <processTcpPacket+0x376>
    78d8:	57 c0       	rjmp	.+174    	; 0x7988 <processTcpPacket+0x424>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    78da:	00 d0       	rcall	.+0      	; 0x78dc <processTcpPacket+0x378>
    78dc:	0f 92       	push	r0
    78de:	ed b7       	in	r30, 0x3d	; 61
    78e0:	fe b7       	in	r31, 0x3e	; 62
    78e2:	81 83       	std	Z+1, r24	; 0x01
    78e4:	92 83       	std	Z+2, r25	; 0x02
    78e6:	8c ea       	ldi	r24, 0xAC	; 172
    78e8:	9d e0       	ldi	r25, 0x0D	; 13
    78ea:	83 83       	std	Z+3, r24	; 0x03
    78ec:	94 83       	std	Z+4, r25	; 0x04
    78ee:	18 c0       	rjmp	.+48     	; 0x7920 <processTcpPacket+0x3bc>
#endif        

    }
    else
    {
      socket->state = LISTEN;
    78f0:	21 e0       	ldi	r18, 0x01	; 1
    78f2:	28 83       	st	Y, r18
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    78f4:	00 97       	sbiw	r24, 0x00	; 0
    78f6:	09 f4       	brne	.+2      	; 0x78fa <processTcpPacket+0x396>
    78f8:	47 c0       	rjmp	.+142    	; 0x7988 <processTcpPacket+0x424>
        if (tcpDebugLevel > 1)
    78fa:	20 91 07 32 	lds	r18, 0x3207
    78fe:	22 30       	cpi	r18, 0x02	; 2
    7900:	08 f4       	brcc	.+2      	; 0x7904 <processTcpPacket+0x3a0>
    7902:	42 c0       	rjmp	.+132    	; 0x7988 <processTcpPacket+0x424>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    7904:	00 d0       	rcall	.+0      	; 0x7906 <processTcpPacket+0x3a2>
    7906:	0f 92       	push	r0
    7908:	ad b7       	in	r26, 0x3d	; 61
    790a:	be b7       	in	r27, 0x3e	; 62
    790c:	11 96       	adiw	r26, 0x01	; 1
    790e:	8d 93       	st	X+, r24
    7910:	9c 93       	st	X, r25
    7912:	12 97       	sbiw	r26, 0x02	; 2
    7914:	88 e7       	ldi	r24, 0x78	; 120
    7916:	9d e0       	ldi	r25, 0x0D	; 13
    7918:	13 96       	adiw	r26, 0x03	; 3
    791a:	8d 93       	st	X+, r24
    791c:	9c 93       	st	X, r25
    791e:	14 97       	sbiw	r26, 0x04	; 4
    7920:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7924:	0f 90       	pop	r0
    7926:	0f 90       	pop	r0
    7928:	0f 90       	pop	r0
    792a:	0f 90       	pop	r0
    792c:	2d c0       	rjmp	.+90     	; 0x7988 <processTcpPacket+0x424>
    }
    return 0;
  }
  
  
  if (socket->state == ESTABILISHED)
    792e:	83 30       	cpi	r24, 0x03	; 3
    7930:	59 f5       	brne	.+86     	; 0x7988 <processTcpPacket+0x424>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    7932:	e0 91 ea 31 	lds	r30, 0x31EA
    7936:	f0 91 eb 31 	lds	r31, 0x31EB
    793a:	85 85       	ldd	r24, Z+13	; 0x0d
    793c:	80 ff       	sbrs	r24, 0
    793e:	24 c0       	rjmp	.+72     	; 0x7988 <processTcpPacket+0x424>
    {
      socket->timer              = timer100Hz;
    7940:	80 91 4a 25 	lds	r24, 0x254A
    7944:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    7946:	80 e1       	ldi	r24, 0x10	; 16
    7948:	85 87       	std	Z+13, r24	; 0x0d
//      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
//      {
//        dataFromBufLen++;
//        dataPtr++;
//      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    794a:	69 81       	ldd	r22, Y+1	; 0x01
    794c:	7a 81       	ldd	r23, Y+2	; 0x02
    794e:	8b 81       	ldd	r24, Y+3	; 0x03
    7950:	9c 81       	ldd	r25, Y+4	; 0x04
    7952:	46 e0       	ldi	r20, 0x06	; 6
    7954:	24 e1       	ldi	r18, 0x14	; 20
    7956:	30 e0       	ldi	r19, 0x00	; 0
    7958:	0e 94 47 33 	call	0x668e	; 0x668e <ipSend>
      socket->state    = CLOSE_WAIT;
    795c:	84 e0       	ldi	r24, 0x04	; 4
    795e:	88 83       	st	Y, r24
      
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    7960:	e0 91 ea 31 	lds	r30, 0x31EA
    7964:	f0 91 eb 31 	lds	r31, 0x31EB
    7968:	81 e0       	ldi	r24, 0x01	; 1
    796a:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    796c:	69 81       	ldd	r22, Y+1	; 0x01
    796e:	7a 81       	ldd	r23, Y+2	; 0x02
    7970:	8b 81       	ldd	r24, Y+3	; 0x03
    7972:	9c 81       	ldd	r25, Y+4	; 0x04
    7974:	46 e0       	ldi	r20, 0x06	; 6
    7976:	24 e1       	ldi	r18, 0x14	; 20
    7978:	30 e0       	ldi	r19, 0x00	; 0
    797a:	0e 94 47 33 	call	0x668e	; 0x668e <ipSend>
      socket->state    = LAST_ACK;
    797e:	85 e0       	ldi	r24, 0x05	; 5
    7980:	88 83       	st	Y, r24
    7982:	02 c0       	rjmp	.+4      	; 0x7988 <processTcpPacket+0x424>
inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    return 1;
    7984:	81 e0       	ldi	r24, 0x01	; 1
    7986:	01 c0       	rjmp	.+2      	; 0x798a <processTcpPacket+0x426>
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
      socket->state    = LAST_ACK;
    }
    return 0;
    7988:	80 e0       	ldi	r24, 0x00	; 0
  }

  //Read data and put into the queue
  
  return 0;
}
    798a:	df 91       	pop	r29
    798c:	cf 91       	pop	r28
    798e:	1f 91       	pop	r17
    7990:	0f 91       	pop	r16
    7992:	ff 90       	pop	r15
    7994:	ef 90       	pop	r14
    7996:	df 90       	pop	r13
    7998:	cf 90       	pop	r12
    799a:	bf 90       	pop	r11
    799c:	af 90       	pop	r10
    799e:	08 95       	ret

000079a0 <sendTcBuffer>:

uint8_t sendTcBuffer(uint8_t socketNo)
{
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    79a0:	80 e0       	ldi	r24, 0x00	; 0
    79a2:	08 95       	ret

000079a4 <netstackTCPIPProcess>:

void netstackTCPIPProcess(void)
{
    79a4:	cf 93       	push	r28
    79a6:	df 93       	push	r29
  if (nicState.layer4.tcp->destport == htons(80))
    79a8:	e0 91 ea 31 	lds	r30, 0x31EA
    79ac:	f0 91 eb 31 	lds	r31, 0x31EB
    79b0:	c2 81       	ldd	r28, Z+2	; 0x02
    79b2:	d3 81       	ldd	r29, Z+3	; 0x03
    79b4:	80 e5       	ldi	r24, 0x50	; 80
    79b6:	90 e0       	ldi	r25, 0x00	; 0
    79b8:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    79bc:	c8 17       	cp	r28, r24
    79be:	d9 07       	cpc	r29, r25
    79c0:	b9 f4       	brne	.+46     	; 0x79f0 <netstackTCPIPProcess+0x4c>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    79c2:	80 91 b0 32 	lds	r24, 0x32B0
    79c6:	90 91 b1 32 	lds	r25, 0x32B1
    79ca:	00 97       	sbiw	r24, 0x00	; 0
    79cc:	99 f0       	breq	.+38     	; 0x79f4 <netstackTCPIPProcess+0x50>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    79ce:	00 d0       	rcall	.+0      	; 0x79d0 <netstackTCPIPProcess+0x2c>
    79d0:	0f 92       	push	r0
    79d2:	ed b7       	in	r30, 0x3d	; 61
    79d4:	fe b7       	in	r31, 0x3e	; 62
    79d6:	81 83       	std	Z+1, r24	; 0x01
    79d8:	92 83       	std	Z+2, r25	; 0x02
    79da:	81 e6       	ldi	r24, 0x61	; 97
    79dc:	9d e0       	ldi	r25, 0x0D	; 13
    79de:	83 83       	std	Z+3, r24	; 0x03
    79e0:	94 83       	std	Z+4, r25	; 0x04
    79e2:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    79e6:	0f 90       	pop	r0
    79e8:	0f 90       	pop	r0
    79ea:	0f 90       	pop	r0
    79ec:	0f 90       	pop	r0
    79ee:	02 c0       	rjmp	.+4      	; 0x79f4 <netstackTCPIPProcess+0x50>
#endif
    ;
  }
  else
  {
    processTcpPacket();
    79f0:	0e 94 b2 3a 	call	0x7564	; 0x7564 <processTcpPacket>
  }
}
    79f4:	df 91       	pop	r29
    79f6:	cf 91       	pop	r28
    79f8:	08 95       	ret

000079fa <setTcpDebug>:

#if TCP_DEBUG
void setTcpDebug(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    79fa:	80 93 b0 32 	sts	0x32B0, r24
    79fe:	90 93 b1 32 	sts	0x32B1, r25
  tcpDebugLevel = level;
    7a02:	60 93 07 32 	sts	0x3207, r22
}
    7a06:	08 95       	ret

00007a08 <flushTcpQueues>:
  for (sckNo = 0; sckNo < NUMBER_OF_SOCKETS; sckNo++)
  {
    
    sck++;
  }
}
    7a08:	08 95       	ret

00007a0a <httpProcess>:
          continue;  
        }
      }

#endif
    7a0a:	08 95       	ret

00007a0c <udpInit>:
static uint32_t udpIpDst_eep   __attribute__((section (".eeprom"))) = ((uint32_t)UDP_DST_IP4   << 24) + ((uint32_t)UDP_DST_IP3   <<16) + ((uint32_t)UDP_DST_IP2   <<8) + UDP_DST_IP1;
static uint16_t udpPortDstEep  __attribute__((section (".eeprom"))) = HTONS(UDP_DST_PORT);
static uint16_t udpPortSrcEep  __attribute__((section (".eeprom"))) = HTONS(UDP_SRC_PORT);

void udpInit(void)
{
    7a0c:	ef 92       	push	r14
    7a0e:	ff 92       	push	r15
    7a10:	cf 93       	push	r28
    7a12:	df 93       	push	r29
#if UDP_DEBUG
  udpDbgStream         = NULL;
    7a14:	10 92 24 32 	sts	0x3224, r1
    7a18:	10 92 25 32 	sts	0x3225, r1
  udpDbgLevel          = 0;
    7a1c:	10 92 dd 31 	sts	0x31DD, r1
#endif
  udpSocket = xmalloc(sizeof(UdpSocket_t));
    7a20:	8e e0       	ldi	r24, 0x0E	; 14
    7a22:	90 e0       	ldi	r25, 0x00	; 0
    7a24:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <xmalloc>
    7a28:	e8 2e       	mov	r14, r24
    7a2a:	e7 01       	movw	r28, r14
    7a2c:	7e 01       	movw	r14, r28
    7a2e:	f9 2e       	mov	r15, r25
    7a30:	e7 01       	movw	r28, r14
    7a32:	e0 92 04 32 	sts	0x3204, r14
    7a36:	f0 92 05 32 	sts	0x3205, r15

  udpSocket->dstIp      = eeprom_read_dword(&udpIpDst_eep);
    7a3a:	8a e2       	ldi	r24, 0x2A	; 42
    7a3c:	90 e0       	ldi	r25, 0x00	; 0
    7a3e:	0e 94 73 5a 	call	0xb4e6	; 0xb4e6 <__eerd_dword_x128a1>
    7a42:	6e 83       	std	Y+6, r22	; 0x06
    7a44:	7f 83       	std	Y+7, r23	; 0x07
    7a46:	88 87       	std	Y+8, r24	; 0x08
    7a48:	99 87       	std	Y+9, r25	; 0x09
  udpSocket->dstPortDef = eeprom_read_word(&udpPortDstEep);;
    7a4a:	8e e2       	ldi	r24, 0x2E	; 46
    7a4c:	90 e0       	ldi	r25, 0x00	; 0
    7a4e:	0e 94 7a 5a 	call	0xb4f4	; 0xb4f4 <__eerd_word_x128a1>
    7a52:	88 83       	st	Y, r24
    7a54:	99 83       	std	Y+1, r25	; 0x01
  udpSocket->srcPort    = eeprom_read_word(&udpPortSrcEep);
    7a56:	80 e3       	ldi	r24, 0x30	; 48
    7a58:	90 e0       	ldi	r25, 0x00	; 0
    7a5a:	0e 94 7a 5a 	call	0xb4f4	; 0xb4f4 <__eerd_word_x128a1>
    7a5e:	8c 83       	std	Y+4, r24	; 0x04
    7a60:	9d 83       	std	Y+5, r25	; 0x05
  
  udpSocket->Rx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_RX_BUF_ADDR));
    7a62:	8f ef       	ldi	r24, 0xFF	; 255
    7a64:	61 e0       	ldi	r22, 0x01	; 1
    7a66:	40 e0       	ldi	r20, 0x00	; 0
    7a68:	59 e7       	ldi	r21, 0x79	; 121
    7a6a:	0e 94 6a 4d 	call	0x9ad4	; 0x9ad4 <xQueueCreateExternal>
    7a6e:	8a 87       	std	Y+10, r24	; 0x0a
    7a70:	9b 87       	std	Y+11, r25	; 0x0b
  udpSocket->Tx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_TX_BUF_ADDR));
    7a72:	c0 91 04 32 	lds	r28, 0x3204
    7a76:	d0 91 05 32 	lds	r29, 0x3205
    7a7a:	8f ef       	ldi	r24, 0xFF	; 255
    7a7c:	61 e0       	ldi	r22, 0x01	; 1
    7a7e:	40 e0       	ldi	r20, 0x00	; 0
    7a80:	58 e7       	ldi	r21, 0x78	; 120
    7a82:	0e 94 6a 4d 	call	0x9ad4	; 0x9ad4 <xQueueCreateExternal>
    7a86:	8c 87       	std	Y+12, r24	; 0x0c
    7a88:	9d 87       	std	Y+13, r25	; 0x0d
}
    7a8a:	df 91       	pop	r29
    7a8c:	cf 91       	pop	r28
    7a8e:	ff 90       	pop	r15
    7a90:	ef 90       	pop	r14
    7a92:	08 95       	ret

00007a94 <setUdpDebug>:

#if UDP_DEBUG
void setUdpDebug(FILE *stream, uint8_t level)
{
  udpDbgStream = stream;
    7a94:	80 93 24 32 	sts	0x3224, r24
    7a98:	90 93 25 32 	sts	0x3225, r25
  udpDbgLevel = level;
    7a9c:	60 93 dd 31 	sts	0x31DD, r22
}
    7aa0:	08 95       	ret

00007aa2 <udpSend>:
#endif

inline void udpSend(uint16_t len)
{
    7aa2:	ef 92       	push	r14
    7aa4:	ff 92       	push	r15
    7aa6:	0f 93       	push	r16
    7aa8:	1f 93       	push	r17
    7aaa:	cf 93       	push	r28
    7aac:	df 93       	push	r29
    7aae:	8c 01       	movw	r16, r24
// make pointer to UDP header
  nicState.layer4.udp->srcport  = udpSocket->srcPort;
    7ab0:	e0 91 04 32 	lds	r30, 0x3204
    7ab4:	f0 91 05 32 	lds	r31, 0x3205
    7ab8:	a0 91 ea 31 	lds	r26, 0x31EA
    7abc:	b0 91 eb 31 	lds	r27, 0x31EB
    7ac0:	84 81       	ldd	r24, Z+4	; 0x04
    7ac2:	95 81       	ldd	r25, Z+5	; 0x05
    7ac4:	8d 93       	st	X+, r24
    7ac6:	9c 93       	st	X, r25
  nicState.layer4.udp->destport = (udpSocket->dstPortDef == 0)? udpSocket->dstPort : udpSocket->dstPortDef;          //data in udpSocket are stored in network order
    7ac8:	a0 91 ea 31 	lds	r26, 0x31EA
    7acc:	b0 91 eb 31 	lds	r27, 0x31EB
    7ad0:	80 81       	ld	r24, Z
    7ad2:	91 81       	ldd	r25, Z+1	; 0x01
    7ad4:	00 97       	sbiw	r24, 0x00	; 0
    7ad6:	11 f4       	brne	.+4      	; 0x7adc <udpSend+0x3a>
    7ad8:	82 81       	ldd	r24, Z+2	; 0x02
    7ada:	93 81       	ldd	r25, Z+3	; 0x03
    7adc:	12 96       	adiw	r26, 0x02	; 2
    7ade:	8d 93       	st	X+, r24
    7ae0:	9c 93       	st	X, r25
    7ae2:	13 97       	sbiw	r26, 0x03	; 3
  
  nicState.layer4.udp->udplen = htons(len + UDP_HEADER_LEN);
    7ae4:	e0 90 ea 31 	lds	r14, 0x31EA
    7ae8:	f0 90 eb 31 	lds	r15, 0x31EB
    7aec:	e8 01       	movw	r28, r16
    7aee:	28 96       	adiw	r28, 0x08	; 8
    7af0:	ce 01       	movw	r24, r28
    7af2:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    7af6:	d7 01       	movw	r26, r14
    7af8:	14 96       	adiw	r26, 0x04	; 4
    7afa:	8d 93       	st	X+, r24
    7afc:	9c 93       	st	X, r25
    7afe:	15 97       	sbiw	r26, 0x05	; 5
  nicState.layer4.udp->udpchksum = 0;
    7b00:	e0 91 ea 31 	lds	r30, 0x31EA
    7b04:	f0 91 eb 31 	lds	r31, 0x31EB
    7b08:	16 82       	std	Z+6, r1	; 0x06
    7b0a:	17 82       	std	Z+7, r1	; 0x07

#if UDP_DEBUG
  if (udpDbgStream != NULL)
    7b0c:	80 91 24 32 	lds	r24, 0x3224
    7b10:	90 91 25 32 	lds	r25, 0x3225
    7b14:	00 97       	sbiw	r24, 0x00	; 0
    7b16:	e1 f0       	breq	.+56     	; 0x7b50 <udpSend+0xae>
    if (udpDbgLevel > 1)
    7b18:	20 91 dd 31 	lds	r18, 0x31DD
    7b1c:	22 30       	cpi	r18, 0x02	; 2
    7b1e:	c0 f0       	brcs	.+48     	; 0x7b50 <udpSend+0xae>
      fprintf_P(udpDbgStream, PSTR("Sending UDP packet (data length %d)\r\n"), len);
    7b20:	00 d0       	rcall	.+0      	; 0x7b22 <udpSend+0x80>
    7b22:	00 d0       	rcall	.+0      	; 0x7b24 <udpSend+0x82>
    7b24:	ed b7       	in	r30, 0x3d	; 61
    7b26:	fe b7       	in	r31, 0x3e	; 62
    7b28:	31 96       	adiw	r30, 0x01	; 1
    7b2a:	ad b7       	in	r26, 0x3d	; 61
    7b2c:	be b7       	in	r27, 0x3e	; 62
    7b2e:	11 96       	adiw	r26, 0x01	; 1
    7b30:	8d 93       	st	X+, r24
    7b32:	9c 93       	st	X, r25
    7b34:	12 97       	sbiw	r26, 0x02	; 2
    7b36:	8b e7       	ldi	r24, 0x7B	; 123
    7b38:	9f e0       	ldi	r25, 0x0F	; 15
    7b3a:	82 83       	std	Z+2, r24	; 0x02
    7b3c:	93 83       	std	Z+3, r25	; 0x03
    7b3e:	04 83       	std	Z+4, r16	; 0x04
    7b40:	15 83       	std	Z+5, r17	; 0x05
    7b42:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7b46:	ed b7       	in	r30, 0x3d	; 61
    7b48:	fe b7       	in	r31, 0x3e	; 62
    7b4a:	36 96       	adiw	r30, 0x06	; 6
    7b4c:	ed bf       	out	0x3d, r30	; 61
    7b4e:	fe bf       	out	0x3e, r31	; 62
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
    7b50:	e0 91 04 32 	lds	r30, 0x3204
    7b54:	f0 91 05 32 	lds	r31, 0x3205
    7b58:	66 81       	ldd	r22, Z+6	; 0x06
    7b5a:	77 81       	ldd	r23, Z+7	; 0x07
    7b5c:	80 85       	ldd	r24, Z+8	; 0x08
    7b5e:	91 85       	ldd	r25, Z+9	; 0x09
    7b60:	41 e1       	ldi	r20, 0x11	; 17
    7b62:	9e 01       	movw	r18, r28
    7b64:	0e 94 47 33 	call	0x668e	; 0x668e <ipSend>
}
    7b68:	df 91       	pop	r29
    7b6a:	cf 91       	pop	r28
    7b6c:	1f 91       	pop	r17
    7b6e:	0f 91       	pop	r16
    7b70:	ff 90       	pop	r15
    7b72:	ef 90       	pop	r14
    7b74:	08 95       	ret

00007b76 <netstackUDPIPProcess>:

inline void netstackUDPIPProcess(void)
{
    7b76:	af 92       	push	r10
    7b78:	bf 92       	push	r11
    7b7a:	cf 92       	push	r12
    7b7c:	df 92       	push	r13
    7b7e:	ff 92       	push	r15
    7b80:	0f 93       	push	r16
    7b82:	1f 93       	push	r17
    7b84:	cf 93       	push	r28
    7b86:	df 93       	push	r29
  uint16_t len = (uint16_t) htons(nicState.layer4.udp->udplen);
    7b88:	e0 91 ea 31 	lds	r30, 0x31EA
    7b8c:	f0 91 eb 31 	lds	r31, 0x31EB
    7b90:	84 81       	ldd	r24, Z+4	; 0x04
    7b92:	95 81       	ldd	r25, Z+5	; 0x05
    7b94:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    7b98:	8c 01       	movw	r16, r24
  uint8_t i;

  #if UDP_DEBUG
  if(udpDbgStream != NULL)
    7b9a:	80 91 24 32 	lds	r24, 0x3224
    7b9e:	90 91 25 32 	lds	r25, 0x3225
    7ba2:	00 97       	sbiw	r24, 0x00	; 0
    7ba4:	f1 f0       	breq	.+60     	; 0x7be2 <netstackUDPIPProcess+0x6c>
    if (udpDbgLevel > 3)
    7ba6:	20 91 dd 31 	lds	r18, 0x31DD
    7baa:	24 30       	cpi	r18, 0x04	; 4
    7bac:	d0 f0       	brcs	.+52     	; 0x7be2 <netstackUDPIPProcess+0x6c>
      fprintf_P(udpDbgStream, PSTR("Proc. UDP packet (data length %d)\r\n"), len-UDP_HEADER_LEN);
    7bae:	00 d0       	rcall	.+0      	; 0x7bb0 <netstackUDPIPProcess+0x3a>
    7bb0:	00 d0       	rcall	.+0      	; 0x7bb2 <netstackUDPIPProcess+0x3c>
    7bb2:	ed b7       	in	r30, 0x3d	; 61
    7bb4:	fe b7       	in	r31, 0x3e	; 62
    7bb6:	31 96       	adiw	r30, 0x01	; 1
    7bb8:	ad b7       	in	r26, 0x3d	; 61
    7bba:	be b7       	in	r27, 0x3e	; 62
    7bbc:	11 96       	adiw	r26, 0x01	; 1
    7bbe:	8d 93       	st	X+, r24
    7bc0:	9c 93       	st	X, r25
    7bc2:	12 97       	sbiw	r26, 0x02	; 2
    7bc4:	87 e5       	ldi	r24, 0x57	; 87
    7bc6:	9f e0       	ldi	r25, 0x0F	; 15
    7bc8:	82 83       	std	Z+2, r24	; 0x02
    7bca:	93 83       	std	Z+3, r25	; 0x03
    7bcc:	c8 01       	movw	r24, r16
    7bce:	08 97       	sbiw	r24, 0x08	; 8
    7bd0:	84 83       	std	Z+4, r24	; 0x04
    7bd2:	95 83       	std	Z+5, r25	; 0x05
    7bd4:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7bd8:	ed b7       	in	r30, 0x3d	; 61
    7bda:	fe b7       	in	r31, 0x3e	; 62
    7bdc:	36 96       	adiw	r30, 0x06	; 6
    7bde:	ed bf       	out	0x3d, r30	; 61
    7be0:	fe bf       	out	0x3e, r31	; 62
#endif

  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    7be2:	a0 91 ea 31 	lds	r26, 0x31EA
    7be6:	b0 91 eb 31 	lds	r27, 0x31EB
    7bea:	e0 91 04 32 	lds	r30, 0x3204
    7bee:	f0 91 05 32 	lds	r31, 0x3205
    7bf2:	12 96       	adiw	r26, 0x02	; 2
    7bf4:	2d 91       	ld	r18, X+
    7bf6:	3c 91       	ld	r19, X
    7bf8:	13 97       	sbiw	r26, 0x03	; 3
    7bfa:	84 81       	ldd	r24, Z+4	; 0x04
    7bfc:	95 81       	ldd	r25, Z+5	; 0x05
    7bfe:	28 17       	cp	r18, r24
    7c00:	39 07       	cpc	r19, r25
    7c02:	09 f0       	breq	.+2      	; 0x7c06 <netstackUDPIPProcess+0x90>
    7c04:	a8 c0       	rjmp	.+336    	; 0x7d56 <netstackUDPIPProcess+0x1e0>
    7c06:	20 81       	ld	r18, Z
    7c08:	31 81       	ldd	r19, Z+1	; 0x01
    7c0a:	8d 91       	ld	r24, X+
    7c0c:	9c 91       	ld	r25, X
    7c0e:	11 97       	sbiw	r26, 0x01	; 1
    7c10:	21 15       	cp	r18, r1
    7c12:	31 05       	cpc	r19, r1
    7c14:	39 f0       	breq	.+14     	; 0x7c24 <netstackUDPIPProcess+0xae>
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
    7c16:	22 81       	ldd	r18, Z+2	; 0x02
    7c18:	33 81       	ldd	r19, Z+3	; 0x03
    7c1a:	28 17       	cp	r18, r24
    7c1c:	39 07       	cpc	r19, r25
    7c1e:	09 f0       	breq	.+2      	; 0x7c22 <netstackUDPIPProcess+0xac>
    7c20:	9a c0       	rjmp	.+308    	; 0x7d56 <netstackUDPIPProcess+0x1e0>
    7c22:	02 c0       	rjmp	.+4      	; 0x7c28 <netstackUDPIPProcess+0xb2>
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    7c24:	82 83       	std	Z+2, r24	; 0x02
    7c26:	93 83       	std	Z+3, r25	; 0x03
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7c28:	c0 91 ea 31 	lds	r28, 0x31EA
    7c2c:	d0 91 eb 31 	lds	r29, 0x31EB
    7c30:	28 96       	adiw	r28, 0x08	; 8
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7c32:	80 91 24 32 	lds	r24, 0x3224
    7c36:	90 91 25 32 	lds	r25, 0x3225
    7c3a:	00 97       	sbiw	r24, 0x00	; 0
    7c3c:	c1 f0       	breq	.+48     	; 0x7c6e <netstackUDPIPProcess+0xf8>
        if (udpDbgLevel > 4)
    7c3e:	20 91 dd 31 	lds	r18, 0x31DD
    7c42:	25 30       	cpi	r18, 0x05	; 5
    7c44:	a0 f0       	brcs	.+40     	; 0x7c6e <netstackUDPIPProcess+0xf8>
          fprintf_P(udpDbgStream, PSTR("Received data: "));
    7c46:	00 d0       	rcall	.+0      	; 0x7c48 <netstackUDPIPProcess+0xd2>
    7c48:	0f 92       	push	r0
    7c4a:	ad b7       	in	r26, 0x3d	; 61
    7c4c:	be b7       	in	r27, 0x3e	; 62
    7c4e:	11 96       	adiw	r26, 0x01	; 1
    7c50:	8d 93       	st	X+, r24
    7c52:	9c 93       	st	X, r25
    7c54:	12 97       	sbiw	r26, 0x02	; 2
    7c56:	87 e4       	ldi	r24, 0x47	; 71
    7c58:	9f e0       	ldi	r25, 0x0F	; 15
    7c5a:	13 96       	adiw	r26, 0x03	; 3
    7c5c:	8d 93       	st	X+, r24
    7c5e:	9c 93       	st	X, r25
    7c60:	14 97       	sbiw	r26, 0x04	; 4
    7c62:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7c66:	0f 90       	pop	r0
    7c68:	0f 90       	pop	r0
    7c6a:	0f 90       	pop	r0
    7c6c:	0f 90       	pop	r0
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
}

inline void netstackUDPIPProcess(void)
{
    7c6e:	28 e0       	ldi	r18, 0x08	; 8
    7c70:	f2 2e       	mov	r15, r18
    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7c72:	9f e3       	ldi	r25, 0x3F	; 63
    7c74:	c9 2e       	mov	r12, r25
    7c76:	9f e0       	ldi	r25, 0x0F	; 15
    7c78:	d9 2e       	mov	r13, r25
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
        if(udpDbgStream != NULL)
          if (udpDbgLevel > 0)
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7c7a:	8a e2       	ldi	r24, 0x2A	; 42
    7c7c:	a8 2e       	mov	r10, r24
    7c7e:	8f e0       	ldi	r24, 0x0F	; 15
    7c80:	b8 2e       	mov	r11, r24
    7c82:	49 c0       	rjmp	.+146    	; 0x7d16 <netstackUDPIPProcess+0x1a0>
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    7c84:	00 97       	sbiw	r24, 0x00	; 0
    7c86:	d9 f0       	breq	.+54     	; 0x7cbe <netstackUDPIPProcess+0x148>
        if (udpDbgLevel > 4)
    7c88:	20 91 dd 31 	lds	r18, 0x31DD
    7c8c:	25 30       	cpi	r18, 0x05	; 5
    7c8e:	b8 f0       	brcs	.+46     	; 0x7cbe <netstackUDPIPProcess+0x148>
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    7c90:	00 d0       	rcall	.+0      	; 0x7c92 <netstackUDPIPProcess+0x11c>
    7c92:	00 d0       	rcall	.+0      	; 0x7c94 <netstackUDPIPProcess+0x11e>
    7c94:	ed b7       	in	r30, 0x3d	; 61
    7c96:	fe b7       	in	r31, 0x3e	; 62
    7c98:	31 96       	adiw	r30, 0x01	; 1
    7c9a:	ad b7       	in	r26, 0x3d	; 61
    7c9c:	be b7       	in	r27, 0x3e	; 62
    7c9e:	11 96       	adiw	r26, 0x01	; 1
    7ca0:	8d 93       	st	X+, r24
    7ca2:	9c 93       	st	X, r25
    7ca4:	12 97       	sbiw	r26, 0x02	; 2
    7ca6:	c2 82       	std	Z+2, r12	; 0x02
    7ca8:	d3 82       	std	Z+3, r13	; 0x03
    7caa:	88 81       	ld	r24, Y
    7cac:	84 83       	std	Z+4, r24	; 0x04
    7cae:	15 82       	std	Z+5, r1	; 0x05
    7cb0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7cb4:	ed b7       	in	r30, 0x3d	; 61
    7cb6:	fe b7       	in	r31, 0x3e	; 62
    7cb8:	36 96       	adiw	r30, 0x06	; 6
    7cba:	ed bf       	out	0x3d, r30	; 61
    7cbc:	fe bf       	out	0x3e, r31	; 62
#endif
#if UDB_DEBUG
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
    7cbe:	e0 91 04 32 	lds	r30, 0x3204
    7cc2:	f0 91 05 32 	lds	r31, 0x3205
    7cc6:	82 85       	ldd	r24, Z+10	; 0x0a
    7cc8:	93 85       	ldd	r25, Z+11	; 0x0b
    7cca:	be 01       	movw	r22, r28
    7ccc:	4a e0       	ldi	r20, 0x0A	; 10
    7cce:	50 e0       	ldi	r21, 0x00	; 0
    7cd0:	20 e0       	ldi	r18, 0x00	; 0
    7cd2:	0e 94 dc 4d 	call	0x9bb8	; 0x9bb8 <xQueueGenericSend>
    7cd6:	88 23       	and	r24, r24
    7cd8:	e1 f4       	brne	.+56     	; 0x7d12 <netstackUDPIPProcess+0x19c>
        if(udpDbgStream != NULL)
    7cda:	80 91 24 32 	lds	r24, 0x3224
    7cde:	90 91 25 32 	lds	r25, 0x3225
    7ce2:	00 97       	sbiw	r24, 0x00	; 0
    7ce4:	b1 f0       	breq	.+44     	; 0x7d12 <netstackUDPIPProcess+0x19c>
          if (udpDbgLevel > 0)
    7ce6:	20 91 dd 31 	lds	r18, 0x31DD
    7cea:	22 23       	and	r18, r18
    7cec:	91 f0       	breq	.+36     	; 0x7d12 <netstackUDPIPProcess+0x19c>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    7cee:	00 d0       	rcall	.+0      	; 0x7cf0 <netstackUDPIPProcess+0x17a>
    7cf0:	0f 92       	push	r0
    7cf2:	ad b7       	in	r26, 0x3d	; 61
    7cf4:	be b7       	in	r27, 0x3e	; 62
    7cf6:	11 96       	adiw	r26, 0x01	; 1
    7cf8:	8d 93       	st	X+, r24
    7cfa:	9c 93       	st	X, r25
    7cfc:	12 97       	sbiw	r26, 0x02	; 2
    7cfe:	13 96       	adiw	r26, 0x03	; 3
    7d00:	ad 92       	st	X+, r10
    7d02:	bc 92       	st	X, r11
    7d04:	14 97       	sbiw	r26, 0x04	; 4
    7d06:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7d0a:	0f 90       	pop	r0
    7d0c:	0f 90       	pop	r0
    7d0e:	0f 90       	pop	r0
    7d10:	0f 90       	pop	r0
#endif
      tmp++;
    7d12:	21 96       	adiw	r28, 0x01	; 1
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received data: "));
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    7d14:	f3 94       	inc	r15
    7d16:	2f 2d       	mov	r18, r15
    7d18:	30 e0       	ldi	r19, 0x00	; 0
    7d1a:	80 91 24 32 	lds	r24, 0x3224
    7d1e:	90 91 25 32 	lds	r25, 0x3225
    7d22:	20 17       	cp	r18, r16
    7d24:	31 07       	cpc	r19, r17
    7d26:	08 f4       	brcc	.+2      	; 0x7d2a <netstackUDPIPProcess+0x1b4>
    7d28:	ad cf       	rjmp	.-166    	; 0x7c84 <netstackUDPIPProcess+0x10e>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
#endif
      tmp++;
    }
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    7d2a:	00 97       	sbiw	r24, 0x00	; 0
    7d2c:	a1 f0       	breq	.+40     	; 0x7d56 <netstackUDPIPProcess+0x1e0>
      if (udpDbgLevel > 4)
    7d2e:	20 91 dd 31 	lds	r18, 0x31DD
    7d32:	25 30       	cpi	r18, 0x05	; 5
    7d34:	80 f0       	brcs	.+32     	; 0x7d56 <netstackUDPIPProcess+0x1e0>
        fprintf_P(udpDbgStream, PSTR("\r\n"));
    7d36:	00 d0       	rcall	.+0      	; 0x7d38 <netstackUDPIPProcess+0x1c2>
    7d38:	0f 92       	push	r0
    7d3a:	ed b7       	in	r30, 0x3d	; 61
    7d3c:	fe b7       	in	r31, 0x3e	; 62
    7d3e:	81 83       	std	Z+1, r24	; 0x01
    7d40:	92 83       	std	Z+2, r25	; 0x02
    7d42:	87 e2       	ldi	r24, 0x27	; 39
    7d44:	9f e0       	ldi	r25, 0x0F	; 15
    7d46:	83 83       	std	Z+3, r24	; 0x03
    7d48:	94 83       	std	Z+4, r25	; 0x04
    7d4a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7d4e:	0f 90       	pop	r0
    7d50:	0f 90       	pop	r0
    7d52:	0f 90       	pop	r0
    7d54:	0f 90       	pop	r0
#endif

  }
}
    7d56:	df 91       	pop	r29
    7d58:	cf 91       	pop	r28
    7d5a:	1f 91       	pop	r17
    7d5c:	0f 91       	pop	r16
    7d5e:	ff 90       	pop	r15
    7d60:	df 90       	pop	r13
    7d62:	cf 90       	pop	r12
    7d64:	bf 90       	pop	r11
    7d66:	af 90       	pop	r10
    7d68:	08 95       	ret

00007d6a <flushUdpQueues>:

inline void flushUdpQueues(void)
{
    7d6a:	0f 93       	push	r16
    7d6c:	1f 93       	push	r17
    7d6e:	cf 93       	push	r28
    7d70:	df 93       	push	r29
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
    7d72:	e0 91 04 32 	lds	r30, 0x3204
    7d76:	f0 91 05 32 	lds	r31, 0x3205
    7d7a:	84 85       	ldd	r24, Z+12	; 0x0c
    7d7c:	95 85       	ldd	r25, Z+13	; 0x0d
    7d7e:	0e 94 20 50 	call	0xa040	; 0xa040 <uxQueueMessagesWaiting>
    7d82:	88 23       	and	r24, r24
    7d84:	e9 f0       	breq	.+58     	; 0x7dc0 <flushUdpQueues+0x56>
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7d86:	00 91 ea 31 	lds	r16, 0x31EA
    7d8a:	10 91 eb 31 	lds	r17, 0x31EB

inline void flushUdpQueues(void)
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    7d8e:	c0 e0       	ldi	r28, 0x00	; 0
    7d90:	d0 e0       	ldi	r29, 0x00	; 0
#endif

  }
}

inline void flushUdpQueues(void)
    7d92:	08 5f       	subi	r16, 0xF8	; 248
    7d94:	1f 4f       	sbci	r17, 0xFF	; 255
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7d96:	01 c0       	rjmp	.+2      	; 0x7d9a <flushUdpQueues+0x30>
    {
      data++;
      len++;
    7d98:	21 96       	adiw	r28, 0x01	; 1
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7d9a:	e0 91 04 32 	lds	r30, 0x3204
    7d9e:	f0 91 05 32 	lds	r31, 0x3205
#endif

  }
}

inline void flushUdpQueues(void)
    7da2:	b8 01       	movw	r22, r16
    7da4:	6c 0f       	add	r22, r28
    7da6:	7d 1f       	adc	r23, r29
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7da8:	84 85       	ldd	r24, Z+12	; 0x0c
    7daa:	95 85       	ldd	r25, Z+13	; 0x0d
    7dac:	40 e0       	ldi	r20, 0x00	; 0
    7dae:	50 e0       	ldi	r21, 0x00	; 0
    7db0:	20 e0       	ldi	r18, 0x00	; 0
    7db2:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    7db6:	81 30       	cpi	r24, 0x01	; 1
    7db8:	79 f3       	breq	.-34     	; 0x7d98 <flushUdpQueues+0x2e>
    {
      data++;
      len++;
    }
    udpSend(len);
    7dba:	ce 01       	movw	r24, r28
    7dbc:	0e 94 51 3d 	call	0x7aa2	; 0x7aa2 <udpSend>
  }
}
    7dc0:	df 91       	pop	r29
    7dc2:	cf 91       	pop	r28
    7dc4:	1f 91       	pop	r17
    7dc6:	0f 91       	pop	r16
    7dc8:	08 95       	ret

00007dca <udpSaveConfig>:

void udpSaveConfig(void)
{
  eeprom_update_dword(&udpIpDst_eep, udpSocket->dstIp);
    7dca:	e0 91 04 32 	lds	r30, 0x3204
    7dce:	f0 91 05 32 	lds	r31, 0x3205
    7dd2:	46 81       	ldd	r20, Z+6	; 0x06
    7dd4:	57 81       	ldd	r21, Z+7	; 0x07
    7dd6:	60 85       	ldd	r22, Z+8	; 0x08
    7dd8:	71 85       	ldd	r23, Z+9	; 0x09
    7dda:	8a e2       	ldi	r24, 0x2A	; 42
    7ddc:	90 e0       	ldi	r25, 0x00	; 0
    7dde:	0e 94 9a 5a 	call	0xb534	; 0xb534 <__eeupd_dword_x128a1>
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
    7de2:	e0 91 04 32 	lds	r30, 0x3204
    7de6:	f0 91 05 32 	lds	r31, 0x3205
    7dea:	60 81       	ld	r22, Z
    7dec:	71 81       	ldd	r23, Z+1	; 0x01
    7dee:	8e e2       	ldi	r24, 0x2E	; 46
    7df0:	90 e0       	ldi	r25, 0x00	; 0
    7df2:	0e 94 a6 5a 	call	0xb54c	; 0xb54c <__eeupd_word_x128a1>
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
    7df6:	e0 91 04 32 	lds	r30, 0x3204
    7dfa:	f0 91 05 32 	lds	r31, 0x3205
    7dfe:	64 81       	ldd	r22, Z+4	; 0x04
    7e00:	75 81       	ldd	r23, Z+5	; 0x05
    7e02:	80 e3       	ldi	r24, 0x30	; 48
    7e04:	90 e0       	ldi	r25, 0x00	; 0
    7e06:	0e 94 a6 5a 	call	0xb54c	; 0xb54c <__eeupd_word_x128a1>
}
    7e0a:	08 95       	ret

00007e0c <udpPrintStatus>:

void udpPrintStatus(FILE *stream)
{
    7e0c:	cf 93       	push	r28
    7e0e:	df 93       	push	r29
    7e10:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR("UDP config:"));
    7e12:	00 d0       	rcall	.+0      	; 0x7e14 <udpPrintStatus+0x8>
    7e14:	0f 92       	push	r0
    7e16:	ad b7       	in	r26, 0x3d	; 61
    7e18:	be b7       	in	r27, 0x3e	; 62
    7e1a:	11 96       	adiw	r26, 0x01	; 1
    7e1c:	8d 93       	st	X+, r24
    7e1e:	9c 93       	st	X, r25
    7e20:	12 97       	sbiw	r26, 0x02	; 2
    7e22:	8b e1       	ldi	r24, 0x1B	; 27
    7e24:	9f e0       	ldi	r25, 0x0F	; 15
    7e26:	13 96       	adiw	r26, 0x03	; 3
    7e28:	8d 93       	st	X+, r24
    7e2a:	9c 93       	st	X, r25
    7e2c:	14 97       	sbiw	r26, 0x04	; 4
    7e2e:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  fprintf_P(stream, PSTR("\r\n  IP          : ")); netPrintIPAddr(stream, udpSocket->dstIp);
    7e32:	ed b7       	in	r30, 0x3d	; 61
    7e34:	fe b7       	in	r31, 0x3e	; 62
    7e36:	c1 83       	std	Z+1, r28	; 0x01
    7e38:	d2 83       	std	Z+2, r29	; 0x02
    7e3a:	88 e0       	ldi	r24, 0x08	; 8
    7e3c:	9f e0       	ldi	r25, 0x0F	; 15
    7e3e:	83 83       	std	Z+3, r24	; 0x03
    7e40:	94 83       	std	Z+4, r25	; 0x04
    7e42:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7e46:	0f 90       	pop	r0
    7e48:	0f 90       	pop	r0
    7e4a:	0f 90       	pop	r0
    7e4c:	0f 90       	pop	r0
    7e4e:	e0 91 04 32 	lds	r30, 0x3204
    7e52:	f0 91 05 32 	lds	r31, 0x3205
    7e56:	46 81       	ldd	r20, Z+6	; 0x06
    7e58:	57 81       	ldd	r21, Z+7	; 0x07
    7e5a:	60 85       	ldd	r22, Z+8	; 0x08
    7e5c:	71 85       	ldd	r23, Z+9	; 0x09
    7e5e:	ce 01       	movw	r24, r28
    7e60:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n  src port    : %d\r\n  dst port    : "), htons(udpSocket->srcPort));
    7e64:	e0 91 04 32 	lds	r30, 0x3204
    7e68:	f0 91 05 32 	lds	r31, 0x3205
    7e6c:	84 81       	ldd	r24, Z+4	; 0x04
    7e6e:	95 81       	ldd	r25, Z+5	; 0x05
    7e70:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    7e74:	00 d0       	rcall	.+0      	; 0x7e76 <udpPrintStatus+0x6a>
    7e76:	00 d0       	rcall	.+0      	; 0x7e78 <udpPrintStatus+0x6c>
    7e78:	ed b7       	in	r30, 0x3d	; 61
    7e7a:	fe b7       	in	r31, 0x3e	; 62
    7e7c:	31 96       	adiw	r30, 0x01	; 1
    7e7e:	ad b7       	in	r26, 0x3d	; 61
    7e80:	be b7       	in	r27, 0x3e	; 62
    7e82:	11 96       	adiw	r26, 0x01	; 1
    7e84:	cd 93       	st	X+, r28
    7e86:	dc 93       	st	X, r29
    7e88:	12 97       	sbiw	r26, 0x02	; 2
    7e8a:	21 ee       	ldi	r18, 0xE1	; 225
    7e8c:	3e e0       	ldi	r19, 0x0E	; 14
    7e8e:	22 83       	std	Z+2, r18	; 0x02
    7e90:	33 83       	std	Z+3, r19	; 0x03
    7e92:	84 83       	std	Z+4, r24	; 0x04
    7e94:	95 83       	std	Z+5, r25	; 0x05
    7e96:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
  if (udpSocket->dstPortDef == HTONS(0))
    7e9a:	e0 91 04 32 	lds	r30, 0x3204
    7e9e:	f0 91 05 32 	lds	r31, 0x3205
    7ea2:	80 81       	ld	r24, Z
    7ea4:	91 81       	ldd	r25, Z+1	; 0x01
    7ea6:	ed b7       	in	r30, 0x3d	; 61
    7ea8:	fe b7       	in	r31, 0x3e	; 62
    7eaa:	36 96       	adiw	r30, 0x06	; 6
    7eac:	ed bf       	out	0x3d, r30	; 61
    7eae:	fe bf       	out	0x3e, r31	; 62
    7eb0:	00 97       	sbiw	r24, 0x00	; 0
    7eb2:	a9 f4       	brne	.+42     	; 0x7ede <udpPrintStatus+0xd2>
    fprintf_P(stream, PSTR("ANY\r\n"));
    7eb4:	00 d0       	rcall	.+0      	; 0x7eb6 <udpPrintStatus+0xaa>
    7eb6:	0f 92       	push	r0
    7eb8:	ad b7       	in	r26, 0x3d	; 61
    7eba:	be b7       	in	r27, 0x3e	; 62
    7ebc:	11 96       	adiw	r26, 0x01	; 1
    7ebe:	cd 93       	st	X+, r28
    7ec0:	dc 93       	st	X, r29
    7ec2:	12 97       	sbiw	r26, 0x02	; 2
    7ec4:	8b ed       	ldi	r24, 0xDB	; 219
    7ec6:	9e e0       	ldi	r25, 0x0E	; 14
    7ec8:	13 96       	adiw	r26, 0x03	; 3
    7eca:	8d 93       	st	X+, r24
    7ecc:	9c 93       	st	X, r25
    7ece:	14 97       	sbiw	r26, 0x04	; 4
    7ed0:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7ed4:	0f 90       	pop	r0
    7ed6:	0f 90       	pop	r0
    7ed8:	0f 90       	pop	r0
    7eda:	0f 90       	pop	r0
    7edc:	1a c0       	rjmp	.+52     	; 0x7f12 <udpPrintStatus+0x106>
  else
    fprintf_P(stream, PSTR("%d\r\n"), htons(udpSocket->dstPortDef));    
    7ede:	0e 94 a4 2e 	call	0x5d48	; 0x5d48 <htons>
    7ee2:	00 d0       	rcall	.+0      	; 0x7ee4 <udpPrintStatus+0xd8>
    7ee4:	00 d0       	rcall	.+0      	; 0x7ee6 <udpPrintStatus+0xda>
    7ee6:	ed b7       	in	r30, 0x3d	; 61
    7ee8:	fe b7       	in	r31, 0x3e	; 62
    7eea:	31 96       	adiw	r30, 0x01	; 1
    7eec:	ad b7       	in	r26, 0x3d	; 61
    7eee:	be b7       	in	r27, 0x3e	; 62
    7ef0:	11 96       	adiw	r26, 0x01	; 1
    7ef2:	cd 93       	st	X+, r28
    7ef4:	dc 93       	st	X, r29
    7ef6:	12 97       	sbiw	r26, 0x02	; 2
    7ef8:	26 ed       	ldi	r18, 0xD6	; 214
    7efa:	3e e0       	ldi	r19, 0x0E	; 14
    7efc:	22 83       	std	Z+2, r18	; 0x02
    7efe:	33 83       	std	Z+3, r19	; 0x03
    7f00:	84 83       	std	Z+4, r24	; 0x04
    7f02:	95 83       	std	Z+5, r25	; 0x05
    7f04:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    7f08:	ed b7       	in	r30, 0x3d	; 61
    7f0a:	fe b7       	in	r31, 0x3e	; 62
    7f0c:	36 96       	adiw	r30, 0x06	; 6
    7f0e:	ed bf       	out	0x3d, r30	; 61
    7f10:	fe bf       	out	0x3e, r31	; 62
}
    7f12:	df 91       	pop	r29
    7f14:	cf 91       	pop	r28
    7f16:	08 95       	ret

00007f18 <_crc_xmodem_update>:
    7f18:	9c 01       	movw	r18, r24
    7f1a:	36 27       	eor	r19, r22
    7f1c:	03 2e       	mov	r0, r19
    7f1e:	02 94       	swap	r0
    7f20:	80 2d       	mov	r24, r0
    7f22:	8f 70       	andi	r24, 0x0F	; 15
    7f24:	83 27       	eor	r24, r19
    7f26:	63 2f       	mov	r22, r19
    7f28:	60 25       	eor	r22, r0
    7f2a:	66 0f       	add	r22, r22
    7f2c:	60 7e       	andi	r22, 0xE0	; 224
    7f2e:	86 27       	eor	r24, r22
    7f30:	60 2d       	mov	r22, r0
    7f32:	63 27       	eor	r22, r19
    7f34:	60 7f       	andi	r22, 0xF0	; 240
    7f36:	66 95       	lsr	r22
    7f38:	03 2e       	mov	r0, r19
    7f3a:	00 0c       	add	r0, r0
    7f3c:	66 1f       	adc	r22, r22
    7f3e:	36 95       	lsr	r19
    7f40:	36 95       	lsr	r19
    7f42:	36 95       	lsr	r19
    7f44:	3f 71       	andi	r19, 0x1F	; 31
    7f46:	36 27       	eor	r19, r22
    7f48:	32 27       	eor	r19, r18
    7f4a:	28 2f       	mov	r18, r24
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
    7f4c:	c9 01       	movw	r24, r18
    7f4e:	08 95       	ret
    7f50:	08 95       	ret
    7f52:	08 95       	ret
    7f54:	08 95       	ret
    7f56:	81 e0       	ldi	r24, 0x01	; 1
    7f58:	08 95       	ret
    7f5a:	81 e0       	ldi	r24, 0x01	; 1
    7f5c:	08 95       	ret

00007f5e <sendSettings>:



// ********************* Hiden Functions ***************************************************
void sendSettings(uint8_t addr, uint8_t value)
{
    7f5e:	ef 92       	push	r14
    7f60:	ff 92       	push	r15
    7f62:	0f 93       	push	r16
    7f64:	1f 93       	push	r17
    7f66:	df 93       	push	r29
    7f68:	cf 93       	push	r28
    7f6a:	0f 92       	push	r0
    7f6c:	cd b7       	in	r28, 0x3d	; 61
    7f6e:	de b7       	in	r29, 0x3e	; 62
    7f70:	08 2f       	mov	r16, r24
    7f72:	16 2f       	mov	r17, r22
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    7f74:	80 e0       	ldi	r24, 0x00	; 0
    7f76:	90 e0       	ldi	r25, 0x00	; 0
    7f78:	6a e5       	ldi	r22, 0x5A	; 90
    7f7a:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    7f7e:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    7f80:	8a e5       	ldi	r24, 0x5A	; 90
    7f82:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    7f86:	c7 01       	movw	r24, r14
    7f88:	60 2f       	mov	r22, r16
    7f8a:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    7f8e:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    7f90:	80 2f       	mov	r24, r16
    7f92:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rUstaw);
    7f96:	c7 01       	movw	r24, r14
    7f98:	60 e4       	ldi	r22, 0x40	; 64
    7f9a:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    7f9e:	7c 01       	movw	r14, r24
  uartRs485SendByte(rUstaw);
    7fa0:	80 e4       	ldi	r24, 0x40	; 64
    7fa2:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 1);
    7fa6:	c7 01       	movw	r24, r14
    7fa8:	61 e0       	ldi	r22, 0x01	; 1
    7faa:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    7fae:	7c 01       	movw	r14, r24
  uartRs485SendByte(1);
    7fb0:	81 e0       	ldi	r24, 0x01	; 1
    7fb2:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, value);
    7fb6:	c7 01       	movw	r24, r14
    7fb8:	61 2f       	mov	r22, r17
    7fba:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    7fbe:	08 2f       	mov	r16, r24
  uartRs485SendByte(value);
    7fc0:	81 2f       	mov	r24, r17
    7fc2:	99 83       	std	Y+1, r25	; 0x01
    7fc4:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  uartRs485SendByte((uint8_t)(crc >> 8));
    7fc8:	99 81       	ldd	r25, Y+1	; 0x01
    7fca:	89 2f       	mov	r24, r25
    7fcc:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    7fd0:	80 2f       	mov	r24, r16
    7fd2:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
}
    7fd6:	0f 90       	pop	r0
    7fd8:	cf 91       	pop	r28
    7fda:	df 91       	pop	r29
    7fdc:	1f 91       	pop	r17
    7fde:	0f 91       	pop	r16
    7fe0:	ff 90       	pop	r15
    7fe2:	ef 90       	pop	r14
    7fe4:	08 95       	ret

00007fe6 <saveSettings>:

void saveSettings(uint8_t addr)
{
    7fe6:	ef 92       	push	r14
    7fe8:	ff 92       	push	r15
    7fea:	1f 93       	push	r17
    7fec:	df 93       	push	r29
    7fee:	cf 93       	push	r28
    7ff0:	0f 92       	push	r0
    7ff2:	cd b7       	in	r28, 0x3d	; 61
    7ff4:	de b7       	in	r29, 0x3e	; 62
    7ff6:	18 2f       	mov	r17, r24
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    7ff8:	80 e0       	ldi	r24, 0x00	; 0
    7ffa:	90 e0       	ldi	r25, 0x00	; 0
    7ffc:	6a e5       	ldi	r22, 0x5A	; 90
    7ffe:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8002:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    8004:	8a e5       	ldi	r24, 0x5A	; 90
    8006:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    800a:	c7 01       	movw	r24, r14
    800c:	61 2f       	mov	r22, r17
    800e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8012:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    8014:	81 2f       	mov	r24, r17
    8016:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rZapiszUstawienia);
    801a:	c7 01       	movw	r24, r14
    801c:	61 e4       	ldi	r22, 0x41	; 65
    801e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8022:	7c 01       	movw	r14, r24
  uartRs485SendByte(rZapiszUstawienia);
    8024:	81 e4       	ldi	r24, 0x41	; 65
    8026:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 0);
    802a:	c7 01       	movw	r24, r14
    802c:	60 e0       	ldi	r22, 0x00	; 0
    802e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8032:	18 2f       	mov	r17, r24
  uartRs485SendByte(0);
    8034:	80 e0       	ldi	r24, 0x00	; 0
    8036:	99 83       	std	Y+1, r25	; 0x01
    8038:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  uartRs485SendByte((uint8_t)(crc >> 8));
    803c:	99 81       	ldd	r25, Y+1	; 0x01
    803e:	89 2f       	mov	r24, r25
    8040:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8044:	81 2f       	mov	r24, r17
    8046:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
}
    804a:	0f 90       	pop	r0
    804c:	cf 91       	pop	r28
    804e:	df 91       	pop	r29
    8050:	1f 91       	pop	r17
    8052:	ff 90       	pop	r15
    8054:	ef 90       	pop	r14
    8056:	08 95       	ret

00008058 <rollersMemInit>:

// ************************ Rs485 API ************************************

void rollersMemInit(void)
{
  rollers = xmalloc(MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    8058:	8e e6       	ldi	r24, 0x6E	; 110
    805a:	90 e0       	ldi	r25, 0x00	; 0
    805c:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <xmalloc>
    8060:	80 93 0a 32 	sts	0x320A, r24
    8064:	90 93 0b 32 	sts	0x320B, r25
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    8068:	fc 01       	movw	r30, r24
    806a:	8e e6       	ldi	r24, 0x6E	; 110
    806c:	df 01       	movw	r26, r30
    806e:	1d 92       	st	X+, r1
    8070:	8a 95       	dec	r24
    8072:	e9 f7       	brne	.-6      	; 0x806e <rollersMemInit+0x16>
}
    8074:	08 95       	ret

00008076 <printRs485devices>:

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
    8076:	af 92       	push	r10
    8078:	bf 92       	push	r11
    807a:	cf 92       	push	r12
    807c:	df 92       	push	r13
    807e:	ef 92       	push	r14
    8080:	ff 92       	push	r15
    8082:	0f 93       	push	r16
    8084:	1f 93       	push	r17
    8086:	cf 93       	push	r28
    8088:	df 93       	push	r29
    808a:	8c 01       	movw	r16, r24
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
    808c:	c0 91 0a 32 	lds	r28, 0x320A
    8090:	d0 91 0b 32 	lds	r29, 0x320B
    8094:	2a e0       	ldi	r18, 0x0A	; 10
    8096:	a2 2e       	mov	r10, r18
}

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
  uint8_t result = 0;
    8098:	bb 24       	eor	r11, r11
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    809a:	91 ea       	ldi	r25, 0xA1	; 161
    809c:	e9 2e       	mov	r14, r25
    809e:	9f e0       	ldi	r25, 0x0F	; 15
    80a0:	f9 2e       	mov	r15, r25
   //   fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    80a2:	8f ed       	ldi	r24, 0xDF	; 223
    80a4:	c8 2e       	mov	r12, r24
    80a6:	8f e0       	ldi	r24, 0x0F	; 15
    80a8:	d8 2e       	mov	r13, r24
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    80aa:	89 81       	ldd	r24, Y+1	; 0x01
    80ac:	88 23       	and	r24, r24
    80ae:	e9 f1       	breq	.+122    	; 0x812a <printRs485devices+0xb4>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    80b0:	2d b7       	in	r18, 0x3d	; 61
    80b2:	3e b7       	in	r19, 0x3e	; 62
    80b4:	2a 50       	subi	r18, 0x0A	; 10
    80b6:	30 40       	sbci	r19, 0x00	; 0
    80b8:	2d bf       	out	0x3d, r18	; 61
    80ba:	3e bf       	out	0x3e, r19	; 62
    80bc:	ed b7       	in	r30, 0x3d	; 61
    80be:	fe b7       	in	r31, 0x3e	; 62
    80c0:	31 96       	adiw	r30, 0x01	; 1
    80c2:	ad b7       	in	r26, 0x3d	; 61
    80c4:	be b7       	in	r27, 0x3e	; 62
    80c6:	11 96       	adiw	r26, 0x01	; 1
    80c8:	0d 93       	st	X+, r16
    80ca:	1c 93       	st	X, r17
    80cc:	12 97       	sbiw	r26, 0x02	; 2
    80ce:	e2 82       	std	Z+2, r14	; 0x02
    80d0:	f3 82       	std	Z+3, r15	; 0x03
    80d2:	84 83       	std	Z+4, r24	; 0x04
    80d4:	15 82       	std	Z+5, r1	; 0x05
    80d6:	2a 81       	ldd	r18, Y+2	; 0x02
    80d8:	30 e0       	ldi	r19, 0x00	; 0
    80da:	2f 73       	andi	r18, 0x3F	; 63
    80dc:	30 70       	andi	r19, 0x00	; 0
    80de:	26 83       	std	Z+6, r18	; 0x06
    80e0:	37 83       	std	Z+7, r19	; 0x07
    80e2:	2b 81       	ldd	r18, Y+3	; 0x03
    80e4:	30 e0       	ldi	r19, 0x00	; 0
    80e6:	2f 73       	andi	r18, 0x3F	; 63
    80e8:	30 70       	andi	r19, 0x00	; 0
    80ea:	20 87       	std	Z+8, r18	; 0x08
    80ec:	31 87       	std	Z+9, r19	; 0x09
    80ee:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
   //   fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    80f2:	0f 90       	pop	r0
    80f4:	0f 90       	pop	r0
    80f6:	0f 90       	pop	r0
    80f8:	0f 90       	pop	r0
    80fa:	ed b7       	in	r30, 0x3d	; 61
    80fc:	fe b7       	in	r31, 0x3e	; 62
    80fe:	31 96       	adiw	r30, 0x01	; 1
    8100:	ad b7       	in	r26, 0x3d	; 61
    8102:	be b7       	in	r27, 0x3e	; 62
    8104:	11 96       	adiw	r26, 0x01	; 1
    8106:	0d 93       	st	X+, r16
    8108:	1c 93       	st	X, r17
    810a:	12 97       	sbiw	r26, 0x02	; 2
    810c:	c2 82       	std	Z+2, r12	; 0x02
    810e:	d3 82       	std	Z+3, r13	; 0x03
    8110:	ce 01       	movw	r24, r28
    8112:	05 96       	adiw	r24, 0x05	; 5
    8114:	84 83       	std	Z+4, r24	; 0x04
    8116:	95 83       	std	Z+5, r25	; 0x05
    8118:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
      result++;
    811c:	b3 94       	inc	r11
    811e:	2d b7       	in	r18, 0x3d	; 61
    8120:	3e b7       	in	r19, 0x3e	; 62
    8122:	2a 5f       	subi	r18, 0xFA	; 250
    8124:	3f 4f       	sbci	r19, 0xFF	; 255
    8126:	2d bf       	out	0x3d, r18	; 61
    8128:	3e bf       	out	0x3e, r19	; 62
    812a:	aa 94       	dec	r10
{
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    812c:	11 f0       	breq	.+4      	; 0x8132 <printRs485devices+0xbc>
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
   //   fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
      result++;
    }
    rolTmp++;
    812e:	2b 96       	adiw	r28, 0x0b	; 11
    8130:	bc cf       	rjmp	.-136    	; 0x80aa <printRs485devices+0x34>
  }
  
  
  return result;
}
    8132:	8b 2d       	mov	r24, r11
    8134:	df 91       	pop	r29
    8136:	cf 91       	pop	r28
    8138:	1f 91       	pop	r17
    813a:	0f 91       	pop	r16
    813c:	ff 90       	pop	r15
    813e:	ef 90       	pop	r14
    8140:	df 90       	pop	r13
    8142:	cf 90       	pop	r12
    8144:	bf 90       	pop	r11
    8146:	af 90       	pop	r10
    8148:	08 95       	ret

0000814a <rs485ping>:
#endif /*PRINT_RS485_DEVICE*/

uint8_t rs485ping(uint8_t devAddr)
{
    814a:	cf 92       	push	r12
    814c:	df 92       	push	r13
    814e:	ef 92       	push	r14
    8150:	ff 92       	push	r15
    8152:	0f 93       	push	r16
    8154:	1f 93       	push	r17
    8156:	df 93       	push	r29
    8158:	cf 93       	push	r28
    815a:	00 d0       	rcall	.+0      	; 0x815c <rs485ping+0x12>
    815c:	0f 92       	push	r0
    815e:	cd b7       	in	r28, 0x3d	; 61
    8160:	de b7       	in	r29, 0x3e	; 62
    8162:	f8 2e       	mov	r15, r24
  takeRs485();
    8164:	0e 94 5f 0a 	call	0x14be	; 0x14be <takeRs485>
}


void sendPing(uint8_t addr, uint8_t pingLen)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    8168:	80 e0       	ldi	r24, 0x00	; 0
    816a:	90 e0       	ldi	r25, 0x00	; 0
    816c:	6a e5       	ldi	r22, 0x5A	; 90
    816e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8172:	8c 01       	movw	r16, r24
  uartRs485SendByte(SYNC);
    8174:	8a e5       	ldi	r24, 0x5A	; 90
    8176:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    817a:	c8 01       	movw	r24, r16
    817c:	6f 2d       	mov	r22, r15
    817e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8182:	8c 01       	movw	r16, r24
  uartRs485SendByte(addr);
    8184:	8f 2d       	mov	r24, r15
    8186:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rPING);
    818a:	c8 01       	movw	r24, r16
    818c:	60 e8       	ldi	r22, 0x80	; 128
    818e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8192:	8c 01       	movw	r16, r24
  uartRs485SendByte(rPING);
    8194:	80 e8       	ldi	r24, 0x80	; 128
    8196:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, pingLen);
    819a:	c8 01       	movw	r24, r16
    819c:	68 e0       	ldi	r22, 0x08	; 8
    819e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    81a2:	f8 2e       	mov	r15, r24
  uartRs485SendByte(pingLen);
    81a4:	88 e0       	ldi	r24, 0x08	; 8
    81a6:	9c 83       	std	Y+4, r25	; 0x04
    81a8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  for (uint8_t i=0; i < pingLen; i++)
    81ac:	00 e0       	ldi	r16, 0x00	; 0
    81ae:	9c 81       	ldd	r25, Y+4	; 0x04
  {
    crc = _crc_xmodem_update(crc, i);
    81b0:	8f 2d       	mov	r24, r15
    81b2:	60 2f       	mov	r22, r16
    81b4:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    81b8:	f8 2e       	mov	r15, r24
    uartRs485SendByte(i);
    81ba:	80 2f       	mov	r24, r16
    81bc:	9c 83       	std	Y+4, r25	; 0x04
    81be:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte(rPING);

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
  
  for (uint8_t i=0; i < pingLen; i++)
    81c2:	0f 5f       	subi	r16, 0xFF	; 255
    81c4:	9c 81       	ldd	r25, Y+4	; 0x04
    81c6:	08 30       	cpi	r16, 0x08	; 8
    81c8:	99 f7       	brne	.-26     	; 0x81b0 <rs485ping+0x66>
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
  }
  uartRs485SendByte((uint8_t)(crc >> 8));
    81ca:	89 2f       	mov	r24, r25
    81cc:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    81d0:	8f 2d       	mov	r24, r15
    81d2:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  addr = 0;
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    81d6:	8e 01       	movw	r16, r28
    81d8:	0f 5f       	subi	r16, 0xFF	; 255
    81da:	1f 4f       	sbci	r17, 0xFF	; 255
    81dc:	c8 01       	movw	r24, r16
    81de:	64 e1       	ldi	r22, 0x14	; 20
    81e0:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    81e4:	88 23       	and	r24, r24
    81e6:	09 f4       	brne	.+2      	; 0x81ea <rs485ping+0xa0>
    81e8:	75 c0       	rjmp	.+234    	; 0x82d4 <rs485ping+0x18a>
    return 1;
  
  if (data != SYNC)
    81ea:	89 81       	ldd	r24, Y+1	; 0x01
    81ec:	8a 35       	cpi	r24, 0x5A	; 90
    81ee:	09 f0       	breq	.+2      	; 0x81f2 <rs485ping+0xa8>
    81f0:	73 c0       	rjmp	.+230    	; 0x82d8 <rs485ping+0x18e>
    return 2;
  crc = _crc_xmodem_update(0, data);
    81f2:	80 e0       	ldi	r24, 0x00	; 0
    81f4:	90 e0       	ldi	r25, 0x00	; 0
    81f6:	6a e5       	ldi	r22, 0x5A	; 90
    81f8:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    81fc:	7c 01       	movw	r14, r24

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    81fe:	c8 01       	movw	r24, r16
    8200:	61 e0       	ldi	r22, 0x01	; 1
    8202:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8206:	88 23       	and	r24, r24
    8208:	09 f4       	brne	.+2      	; 0x820c <rs485ping+0xc2>
    820a:	68 c0       	rjmp	.+208    	; 0x82dc <rs485ping+0x192>
    return 3;

  if (data != 0)
    820c:	89 81       	ldd	r24, Y+1	; 0x01
    820e:	88 23       	and	r24, r24
    8210:	09 f0       	breq	.+2      	; 0x8214 <rs485ping+0xca>
    8212:	66 c0       	rjmp	.+204    	; 0x82e0 <rs485ping+0x196>
    return 4;
  
  crc = _crc_xmodem_update(crc, data);
    8214:	c7 01       	movw	r24, r14
    8216:	60 e0       	ldi	r22, 0x00	; 0
    8218:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    821c:	7c 01       	movw	r14, r24

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    821e:	c8 01       	movw	r24, r16
    8220:	61 e0       	ldi	r22, 0x01	; 1
    8222:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8226:	88 23       	and	r24, r24
    8228:	09 f4       	brne	.+2      	; 0x822c <rs485ping+0xe2>
    822a:	5c c0       	rjmp	.+184    	; 0x82e4 <rs485ping+0x19a>
    return 5;
  if (data != rPING)
    822c:	89 81       	ldd	r24, Y+1	; 0x01
    822e:	80 38       	cpi	r24, 0x80	; 128
    8230:	09 f0       	breq	.+2      	; 0x8234 <rs485ping+0xea>
    8232:	5a c0       	rjmp	.+180    	; 0x82e8 <rs485ping+0x19e>
    return 6;
  crc = _crc_xmodem_update(crc, data);
    8234:	c7 01       	movw	r24, r14
    8236:	60 e8       	ldi	r22, 0x80	; 128
    8238:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    823c:	7c 01       	movw	r14, r24

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    823e:	c8 01       	movw	r24, r16
    8240:	61 e0       	ldi	r22, 0x01	; 1
    8242:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8246:	88 23       	and	r24, r24
    8248:	09 f4       	brne	.+2      	; 0x824c <rs485ping+0x102>
    824a:	50 c0       	rjmp	.+160    	; 0x82ec <rs485ping+0x1a2>
    return 7;
  if (data != dataLen)
    824c:	89 81       	ldd	r24, Y+1	; 0x01
    824e:	88 30       	cpi	r24, 0x08	; 8
    8250:	09 f0       	breq	.+2      	; 0x8254 <rs485ping+0x10a>
    8252:	4e c0       	rjmp	.+156    	; 0x82f0 <rs485ping+0x1a6>
    return 8;
  crc = _crc_xmodem_update(crc, data);
    8254:	c7 01       	movw	r24, r14
    8256:	68 e0       	ldi	r22, 0x08	; 8
    8258:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    825c:	7c 01       	movw	r14, r24

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    825e:	dd 24       	eor	r13, r13
  {
    if(rs485Receive(&data, 5) == pdFALSE)
    8260:	c0 2e       	mov	r12, r16
    8262:	01 2f       	mov	r16, r17
    8264:	8c 2d       	mov	r24, r12
    8266:	90 2f       	mov	r25, r16
    8268:	65 e0       	ldi	r22, 0x05	; 5
    826a:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    826e:	88 23       	and	r24, r24
    8270:	21 f4       	brne	.+8      	; 0x827a <rs485ping+0x130>
      return 2*temp+9;
    8272:	0d 2d       	mov	r16, r13
    8274:	00 0f       	add	r16, r16
    8276:	07 5f       	subi	r16, 0xF7	; 247
    8278:	44 c0       	rjmp	.+136    	; 0x8302 <rs485ping+0x1b8>
    crc = _crc_xmodem_update(crc, data);
    827a:	c7 01       	movw	r24, r14
    827c:	69 81       	ldd	r22, Y+1	; 0x01
    827e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8282:	7c 01       	movw	r14, r24
    if (data != temp)
    8284:	89 81       	ldd	r24, Y+1	; 0x01
    8286:	8d 15       	cp	r24, r13
    8288:	21 f0       	breq	.+8      	; 0x8292 <rs485ping+0x148>
      return 2*temp+10; 
    828a:	0d 2d       	mov	r16, r13
    828c:	00 0f       	add	r16, r16
    828e:	06 5f       	subi	r16, 0xF6	; 246
    8290:	38 c0       	rjmp	.+112    	; 0x8302 <rs485ping+0x1b8>
    return 8;
  crc = _crc_xmodem_update(crc, data);

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    8292:	d3 94       	inc	r13
    8294:	8d 2d       	mov	r24, r13
    8296:	88 30       	cpi	r24, 0x08	; 8
    8298:	29 f7       	brne	.-54     	; 0x8264 <rs485ping+0x11a>
      return 2*temp+10; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    829a:	ce 01       	movw	r24, r28
    829c:	02 96       	adiw	r24, 0x02	; 2
    829e:	61 e0       	ldi	r22, 0x01	; 1
    82a0:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    82a4:	81 30       	cpi	r24, 0x01	; 1
    82a6:	31 f5       	brne	.+76     	; 0x82f4 <rs485ping+0x1aa>
    return 2*temp+11;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    82a8:	80 91 fe 31 	lds	r24, 0x31FE
    82ac:	90 91 ff 31 	lds	r25, 0x31FF
    82b0:	be 01       	movw	r22, r28
    82b2:	6d 5f       	subi	r22, 0xFD	; 253
    82b4:	7f 4f       	sbci	r23, 0xFF	; 255
    82b6:	41 e0       	ldi	r20, 0x01	; 1
    82b8:	50 e0       	ldi	r21, 0x00	; 0
    82ba:	20 e0       	ldi	r18, 0x00	; 0
    82bc:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    82c0:	81 30       	cpi	r24, 0x01	; 1
    82c2:	d1 f4       	brne	.+52     	; 0x82f8 <rs485ping+0x1ae>
    return 2*temp+12;

  if (crcHi != (uint8_t)(crc>>8))
    82c4:	8a 81       	ldd	r24, Y+2	; 0x02
    82c6:	8f 15       	cp	r24, r15
    82c8:	c9 f4       	brne	.+50     	; 0x82fc <rs485ping+0x1b2>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    82ca:	8b 81       	ldd	r24, Y+3	; 0x03
    82cc:	8e 15       	cp	r24, r14
    82ce:	c1 f0       	breq	.+48     	; 0x8300 <rs485ping+0x1b6>
    return 255;
    82d0:	0f ef       	ldi	r16, 0xFF	; 255
    82d2:	17 c0       	rjmp	.+46     	; 0x8302 <rs485ping+0x1b8>
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    return 1;
    82d4:	01 e0       	ldi	r16, 0x01	; 1
    82d6:	15 c0       	rjmp	.+42     	; 0x8302 <rs485ping+0x1b8>
  
  if (data != SYNC)
    return 2;
    82d8:	02 e0       	ldi	r16, 0x02	; 2
    82da:	13 c0       	rjmp	.+38     	; 0x8302 <rs485ping+0x1b8>
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    return 3;
    82dc:	03 e0       	ldi	r16, 0x03	; 3
    82de:	11 c0       	rjmp	.+34     	; 0x8302 <rs485ping+0x1b8>

  if (data != 0)
    return 4;
    82e0:	04 e0       	ldi	r16, 0x04	; 4
    82e2:	0f c0       	rjmp	.+30     	; 0x8302 <rs485ping+0x1b8>
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    return 5;
    82e4:	05 e0       	ldi	r16, 0x05	; 5
    82e6:	0d c0       	rjmp	.+26     	; 0x8302 <rs485ping+0x1b8>
  if (data != rPING)
    return 6;
    82e8:	06 e0       	ldi	r16, 0x06	; 6
    82ea:	0b c0       	rjmp	.+22     	; 0x8302 <rs485ping+0x1b8>
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
    82ec:	07 e0       	ldi	r16, 0x07	; 7
    82ee:	09 c0       	rjmp	.+18     	; 0x8302 <rs485ping+0x1b8>
  if (data != dataLen)
    return 8;
    82f0:	08 e0       	ldi	r16, 0x08	; 8
    82f2:	07 c0       	rjmp	.+14     	; 0x8302 <rs485ping+0x1b8>
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    return 2*temp+11;
    82f4:	0b e1       	ldi	r16, 0x1B	; 27
    82f6:	05 c0       	rjmp	.+10     	; 0x8302 <rs485ping+0x1b8>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    return 2*temp+12;
    82f8:	0c e1       	ldi	r16, 0x1C	; 28
    82fa:	03 c0       	rjmp	.+6      	; 0x8302 <rs485ping+0x1b8>

  if (crcHi != (uint8_t)(crc>>8))
    return 254;
    82fc:	0e ef       	ldi	r16, 0xFE	; 254
    82fe:	01 c0       	rjmp	.+2      	; 0x8302 <rs485ping+0x1b8>
  if (crcLo != (uint8_t)(crc & 0xFF))
    return 255;
  
  return 0; 
    8300:	00 e0       	ldi	r16, 0x00	; 0
{
  takeRs485();
  const int len = 8;    
  sendPing(devAddr, len);
  uint8_t result = receivePong(devAddr, len);
  flushRs485RecBuffer();
    8302:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>

  releaseRs485();
    8306:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
  return result;
}
    830a:	80 2f       	mov	r24, r16
    830c:	24 96       	adiw	r28, 0x04	; 4
    830e:	cd bf       	out	0x3d, r28	; 61
    8310:	de bf       	out	0x3e, r29	; 62
    8312:	cf 91       	pop	r28
    8314:	df 91       	pop	r29
    8316:	1f 91       	pop	r17
    8318:	0f 91       	pop	r16
    831a:	ff 90       	pop	r15
    831c:	ef 90       	pop	r14
    831e:	df 90       	pop	r13
    8320:	cf 90       	pop	r12
    8322:	08 95       	ret

00008324 <rs485rollerHello>:

uint8_t rs485rollerHello(uint8_t devAddr)
{
    8324:	cf 92       	push	r12
    8326:	df 92       	push	r13
    8328:	ef 92       	push	r14
    832a:	ff 92       	push	r15
    832c:	0f 93       	push	r16
    832e:	1f 93       	push	r17
    8330:	df 93       	push	r29
    8332:	cf 93       	push	r28
    8334:	00 d0       	rcall	.+0      	; 0x8336 <rs485rollerHello+0x12>
    8336:	0f 92       	push	r0
    8338:	cd b7       	in	r28, 0x3d	; 61
    833a:	de b7       	in	r29, 0x3e	; 62
    833c:	c8 2e       	mov	r12, r24
    {
      tmp->state &= (~NOT_DETECTED);
      tmp->address = devAddr;
    }
    else
      return 1;
    833e:	e0 91 0a 32 	lds	r30, 0x320A
    8342:	f0 91 0b 32 	lds	r31, 0x320B
uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    8346:	8a e0       	ldi	r24, 0x0A	; 10
  return result;
}

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
    8348:	00 e0       	ldi	r16, 0x00	; 0
    834a:	10 e0       	ldi	r17, 0x00	; 0
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    834c:	91 81       	ldd	r25, Z+1	; 0x01
    834e:	9c 15       	cp	r25, r12
    8350:	11 f4       	brne	.+4      	; 0x8356 <rs485rollerHello+0x32>
      tmp = &rollers[i];
    8352:	0e 2f       	mov	r16, r30
    8354:	1f 2f       	mov	r17, r31
uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    8356:	81 50       	subi	r24, 0x01	; 1
    8358:	3b 96       	adiw	r30, 0x0b	; 11

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    835a:	88 23       	and	r24, r24
    835c:	b9 f7       	brne	.-18     	; 0x834c <rs485rollerHello+0x28>
    if (rollers[i].address == devAddr)
      tmp = &rollers[i];
    
  if (rs485ping(devAddr)==0)
    835e:	8c 2d       	mov	r24, r12
    8360:	0e 94 a5 40 	call	0x814a	; 0x814a <rs485ping>
    8364:	88 23       	and	r24, r24
    8366:	f1 f4       	brne	.+60     	; 0x83a4 <rs485rollerHello+0x80>
  {
    if (tmp == NULL)
    8368:	01 15       	cp	r16, r1
    836a:	11 05       	cpc	r17, r1
    836c:	79 f4       	brne	.+30     	; 0x838c <rs485rollerHello+0x68>
    836e:	e0 91 0a 32 	lds	r30, 0x320A
    8372:	f0 91 0b 32 	lds	r31, 0x320B
    8376:	8f 01       	movw	r16, r30
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
      {
        if (rollers[i].address == 0)
    8378:	91 81       	ldd	r25, Z+1	; 0x01
    837a:	99 23       	and	r25, r25
    837c:	11 f4       	brne	.+4      	; 0x8382 <rs485rollerHello+0x5e>
        {
          tmp = &rollers[i];
          tmp->address = devAddr;
    837e:	c1 82       	std	Z+1, r12	; 0x01
          break;
    8380:	05 c0       	rjmp	.+10     	; 0x838c <rs485rollerHello+0x68>
    
  if (rs485ping(devAddr)==0)
  {
    if (tmp == NULL)
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    8382:	8f 5f       	subi	r24, 0xFF	; 255
    8384:	3b 96       	adiw	r30, 0x0b	; 11
    8386:	8a 30       	cpi	r24, 0x0A	; 10
    8388:	b1 f7       	brne	.-20     	; 0x8376 <rs485rollerHello+0x52>
    838a:	e2 c0       	rjmp	.+452    	; 0x8550 <rs485rollerHello+0x22c>
          tmp->address = devAddr;
          break;
        }
      }
    }
    if (tmp != NULL)
    838c:	01 15       	cp	r16, r1
    838e:	11 05       	cpc	r17, r1
    8390:	09 f4       	brne	.+2      	; 0x8394 <rs485rollerHello+0x70>
    8392:	de c0       	rjmp	.+444    	; 0x8550 <rs485rollerHello+0x22c>
    {
      tmp->state &= (~NOT_DETECTED);
    8394:	d8 01       	movw	r26, r16
    8396:	8c 91       	ld	r24, X
    8398:	8e 7f       	andi	r24, 0xFE	; 254
    839a:	8c 93       	st	X, r24
      tmp->address = devAddr;
    839c:	11 96       	adiw	r26, 0x01	; 1
    839e:	cc 92       	st	X, r12
    83a0:	11 97       	sbiw	r26, 0x01	; 1
    83a2:	0c c0       	rjmp	.+24     	; 0x83bc <rs485rollerHello+0x98>
    else
      return 1;
  }
  else
  {
    if (tmp != NULL)
    83a4:	01 15       	cp	r16, r1
    83a6:	11 05       	cpc	r17, r1
    83a8:	49 f0       	breq	.+18     	; 0x83bc <rs485rollerHello+0x98>
    {
      if (tmp->state & NOT_DETECTED)
    83aa:	f8 01       	movw	r30, r16
    83ac:	80 81       	ld	r24, Z
    83ae:	80 fd       	sbrc	r24, 0
      {
        tmp->address = 0;
    83b0:	11 82       	std	Z+1, r1	; 0x01
      }
      tmp->state |= NOT_DETECTED;
    83b2:	81 60       	ori	r24, 0x01	; 1
    83b4:	d8 01       	movw	r26, r16
    83b6:	8c 93       	st	X, r24
      return 2;
    83b8:	82 e0       	ldi	r24, 0x02	; 2
    83ba:	cb c0       	rjmp	.+406    	; 0x8552 <rs485rollerHello+0x22e>
    }
  }
  
  takeRs485();
    83bc:	0e 94 5f 0a 	call	0x14be	; 0x14be <takeRs485>
  return 0; 
}

static void    sendHello(uint8_t addr)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
    83c0:	80 e0       	ldi	r24, 0x00	; 0
    83c2:	90 e0       	ldi	r25, 0x00	; 0
    83c4:	6a e5       	ldi	r22, 0x5A	; 90
    83c6:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    83ca:	7c 01       	movw	r14, r24
  uartRs485SendByte(SYNC);
    83cc:	8a e5       	ldi	r24, 0x5A	; 90
    83ce:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, addr);
    83d2:	c7 01       	movw	r24, r14
    83d4:	6c 2d       	mov	r22, r12
    83d6:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    83da:	7c 01       	movw	r14, r24
  uartRs485SendByte(addr);
    83dc:	8c 2d       	mov	r24, r12
    83de:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, rHELLO);
    83e2:	c7 01       	movw	r24, r14
    83e4:	62 e8       	ldi	r22, 0x82	; 130
    83e6:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    83ea:	7c 01       	movw	r14, r24
  uartRs485SendByte(rHELLO);
    83ec:	82 e8       	ldi	r24, 0x82	; 130
    83ee:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, 0);
    83f2:	c7 01       	movw	r24, r14
    83f4:	60 e0       	ldi	r22, 0x00	; 0
    83f6:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    83fa:	f8 2e       	mov	r15, r24
  uartRs485SendByte(0);
    83fc:	80 e0       	ldi	r24, 0x00	; 0
    83fe:	9c 83       	std	Y+4, r25	; 0x04
    8400:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc >> 8));
    8404:	9c 81       	ldd	r25, Y+4	; 0x04
    8406:	89 2f       	mov	r24, r25
    8408:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    840c:	8f 2d       	mov	r24, r15
    840e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
static uint8_t receiveHello(uint8_t* response, uint8_t maxSize)
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    8412:	7e 01       	movw	r14, r28
    8414:	08 94       	sec
    8416:	e1 1c       	adc	r14, r1
    8418:	f1 1c       	adc	r15, r1
    841a:	c7 01       	movw	r24, r14
    841c:	64 e1       	ldi	r22, 0x14	; 20
    841e:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8422:	88 23       	and	r24, r24
    8424:	09 f4       	brne	.+2      	; 0x8428 <rs485rollerHello+0x104>
    8426:	76 c0       	rjmp	.+236    	; 0x8514 <rs485rollerHello+0x1f0>
    return 8;
  
  if (data != SYNC)
    8428:	89 81       	ldd	r24, Y+1	; 0x01
    842a:	8a 35       	cpi	r24, 0x5A	; 90
    842c:	09 f0       	breq	.+2      	; 0x8430 <rs485rollerHello+0x10c>
    842e:	74 c0       	rjmp	.+232    	; 0x8518 <rs485rollerHello+0x1f4>
    return 2;
  crc = _crc_xmodem_update(0, data);
    8430:	80 e0       	ldi	r24, 0x00	; 0
    8432:	90 e0       	ldi	r25, 0x00	; 0
    8434:	6a e5       	ldi	r22, 0x5A	; 90
    8436:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    843a:	6c 01       	movw	r12, r24

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    843c:	c7 01       	movw	r24, r14
    843e:	61 e0       	ldi	r22, 0x01	; 1
    8440:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8444:	88 23       	and	r24, r24
    8446:	09 f4       	brne	.+2      	; 0x844a <rs485rollerHello+0x126>
    8448:	69 c0       	rjmp	.+210    	; 0x851c <rs485rollerHello+0x1f8>
    return 3;

  if (data != 0)
    844a:	89 81       	ldd	r24, Y+1	; 0x01
    844c:	88 23       	and	r24, r24
    844e:	09 f0       	breq	.+2      	; 0x8452 <rs485rollerHello+0x12e>
    8450:	67 c0       	rjmp	.+206    	; 0x8520 <rs485rollerHello+0x1fc>
    return 4;
  
  crc = _crc_xmodem_update(crc, data);
    8452:	c6 01       	movw	r24, r12
    8454:	60 e0       	ldi	r22, 0x00	; 0
    8456:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    845a:	6c 01       	movw	r12, r24

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    845c:	c7 01       	movw	r24, r14
    845e:	61 e0       	ldi	r22, 0x01	; 1
    8460:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8464:	88 23       	and	r24, r24
    8466:	09 f4       	brne	.+2      	; 0x846a <rs485rollerHello+0x146>
    8468:	5d c0       	rjmp	.+186    	; 0x8524 <rs485rollerHello+0x200>
    return 5;
  if (data != rHELLO)
    846a:	89 81       	ldd	r24, Y+1	; 0x01
    846c:	82 38       	cpi	r24, 0x82	; 130
    846e:	09 f0       	breq	.+2      	; 0x8472 <rs485rollerHello+0x14e>
    8470:	5b c0       	rjmp	.+182    	; 0x8528 <rs485rollerHello+0x204>
    return 6;
  crc = _crc_xmodem_update(crc, data);
    8472:	c6 01       	movw	r24, r12
    8474:	62 e8       	ldi	r22, 0x82	; 130
    8476:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    847a:	6c 01       	movw	r12, r24

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    847c:	c7 01       	movw	r24, r14
    847e:	61 e0       	ldi	r22, 0x01	; 1
    8480:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8484:	88 23       	and	r24, r24
    8486:	09 f4       	brne	.+2      	; 0x848a <rs485rollerHello+0x166>
    8488:	51 c0       	rjmp	.+162    	; 0x852c <rs485rollerHello+0x208>
    return 7;
  if (data > maxSize)
    848a:	69 81       	ldd	r22, Y+1	; 0x01
    848c:	69 30       	cpi	r22, 0x09	; 9
    848e:	08 f0       	brcs	.+2      	; 0x8492 <rs485rollerHello+0x16e>
    8490:	4f c0       	rjmp	.+158    	; 0x8530 <rs485rollerHello+0x20c>
    }
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
    8492:	0e 5f       	subi	r16, 0xFE	; 254
    8494:	1f 4f       	sbci	r17, 0xFF	; 255
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
  if (data > maxSize)
    return 1;
  
  crc = _crc_xmodem_update(crc, data);
    8496:	c6 01       	movw	r24, r12
    8498:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    849c:	e8 2e       	mov	r14, r24
    849e:	c9 2e       	mov	r12, r25
  memset(response, 0, maxSize);
    84a0:	88 e0       	ldi	r24, 0x08	; 8
    84a2:	d8 01       	movw	r26, r16
    84a4:	1d 92       	st	X+, r1
    84a6:	8a 95       	dec	r24
    84a8:	e9 f7       	brne	.-6      	; 0x84a4 <rs485rollerHello+0x180>
  maxSize = data;
    84aa:	f9 80       	ldd	r15, Y+1	; 0x01
  
  for (data=0; data < maxSize; data++)
    84ac:	19 82       	std	Y+1, r1	; 0x01
    84ae:	12 c0       	rjmp	.+36     	; 0x84d4 <rs485rollerHello+0x1b0>
  {
    if(rs485Receive(response, 5) == pdFALSE)
    84b0:	c8 01       	movw	r24, r16
    84b2:	65 e0       	ldi	r22, 0x05	; 5
    84b4:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    84b8:	88 23       	and	r24, r24
    84ba:	e1 f1       	breq	.+120    	; 0x8534 <rs485rollerHello+0x210>
      return 20;
    crc = _crc_xmodem_update(crc, *((uint8_t *)(response)));
    84bc:	8e 2d       	mov	r24, r14
    84be:	9c 2d       	mov	r25, r12
    84c0:	f8 01       	movw	r30, r16
    84c2:	61 91       	ld	r22, Z+
    84c4:	8f 01       	movw	r16, r30
    84c6:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    84ca:	e8 2e       	mov	r14, r24
    84cc:	c9 2e       	mov	r12, r25
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
    84ce:	89 81       	ldd	r24, Y+1	; 0x01
    84d0:	8f 5f       	subi	r24, 0xFF	; 255
    84d2:	89 83       	std	Y+1, r24	; 0x01
    84d4:	89 81       	ldd	r24, Y+1	; 0x01
    84d6:	8f 15       	cp	r24, r15
    84d8:	58 f3       	brcs	.-42     	; 0x84b0 <rs485rollerHello+0x18c>
    response++; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    84da:	ce 01       	movw	r24, r28
    84dc:	02 96       	adiw	r24, 0x02	; 2
    84de:	61 e0       	ldi	r22, 0x01	; 1
    84e0:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    84e4:	81 30       	cpi	r24, 0x01	; 1
    84e6:	41 f5       	brne	.+80     	; 0x8538 <rs485rollerHello+0x214>
    return 21;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    84e8:	80 91 fe 31 	lds	r24, 0x31FE
    84ec:	90 91 ff 31 	lds	r25, 0x31FF
    84f0:	be 01       	movw	r22, r28
    84f2:	6d 5f       	subi	r22, 0xFD	; 253
    84f4:	7f 4f       	sbci	r23, 0xFF	; 255
    84f6:	41 e0       	ldi	r20, 0x01	; 1
    84f8:	50 e0       	ldi	r21, 0x00	; 0
    84fa:	20 e0       	ldi	r18, 0x00	; 0
    84fc:	0e 94 17 4f 	call	0x9e2e	; 0x9e2e <xQueueGenericReceive>
    8500:	81 30       	cpi	r24, 0x01	; 1
    8502:	e1 f4       	brne	.+56     	; 0x853c <rs485rollerHello+0x218>
    return 22;

  if (crcHi != (uint8_t)(crc>>8))
    8504:	8a 81       	ldd	r24, Y+2	; 0x02
    8506:	8c 15       	cp	r24, r12
    8508:	d9 f4       	brne	.+54     	; 0x8540 <rs485rollerHello+0x21c>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    850a:	8b 81       	ldd	r24, Y+3	; 0x03
    850c:	8e 15       	cp	r24, r14
    850e:	d1 f0       	breq	.+52     	; 0x8544 <rs485rollerHello+0x220>
    return 255;
    8510:	8f ef       	ldi	r24, 0xFF	; 255
    8512:	19 c0       	rjmp	.+50     	; 0x8546 <rs485rollerHello+0x222>
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    return 8;
    8514:	88 e0       	ldi	r24, 0x08	; 8
    8516:	17 c0       	rjmp	.+46     	; 0x8546 <rs485rollerHello+0x222>
  
  if (data != SYNC)
    return 2;
    8518:	82 e0       	ldi	r24, 0x02	; 2
    851a:	15 c0       	rjmp	.+42     	; 0x8546 <rs485rollerHello+0x222>
  crc = _crc_xmodem_update(0, data);

  //Adres ma być wartość 0
  if(rs485Receive(&data, 1) == 0)
    return 3;
    851c:	83 e0       	ldi	r24, 0x03	; 3
    851e:	13 c0       	rjmp	.+38     	; 0x8546 <rs485rollerHello+0x222>

  if (data != 0)
    return 4;
    8520:	84 e0       	ldi	r24, 0x04	; 4
    8522:	11 c0       	rjmp	.+34     	; 0x8546 <rs485rollerHello+0x222>
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma być rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    return 5;
    8524:	85 e0       	ldi	r24, 0x05	; 5
    8526:	0f c0       	rjmp	.+30     	; 0x8546 <rs485rollerHello+0x222>
  if (data != rHELLO)
    return 6;
    8528:	86 e0       	ldi	r24, 0x06	; 6
    852a:	0d c0       	rjmp	.+26     	; 0x8546 <rs485rollerHello+0x222>
  crc = _crc_xmodem_update(crc, data);

  //Długość odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    return 7;
    852c:	87 e0       	ldi	r24, 0x07	; 7
    852e:	0b c0       	rjmp	.+22     	; 0x8546 <rs485rollerHello+0x222>
  if (data > maxSize)
    return 1;
    8530:	81 e0       	ldi	r24, 0x01	; 1
    8532:	09 c0       	rjmp	.+18     	; 0x8546 <rs485rollerHello+0x222>
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
  {
    if(rs485Receive(response, 5) == pdFALSE)
      return 20;
    8534:	84 e1       	ldi	r24, 0x14	; 20
    8536:	07 c0       	rjmp	.+14     	; 0x8546 <rs485rollerHello+0x222>
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    return 21;
    8538:	85 e1       	ldi	r24, 0x15	; 21
    853a:	05 c0       	rjmp	.+10     	; 0x8546 <rs485rollerHello+0x222>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    return 22;
    853c:	86 e1       	ldi	r24, 0x16	; 22
    853e:	03 c0       	rjmp	.+6      	; 0x8546 <rs485rollerHello+0x222>

  if (crcHi != (uint8_t)(crc>>8))
    return 254;
    8540:	8e ef       	ldi	r24, 0xFE	; 254
    8542:	01 c0       	rjmp	.+2      	; 0x8546 <rs485rollerHello+0x222>
  if (crcLo != (uint8_t)(crc & 0xFF))
    return 255;
  
  return 0; 
    8544:	80 e0       	ldi	r24, 0x00	; 0
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
    8546:	8c 83       	std	Y+4, r24	; 0x04
    8548:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
  return result;
    854c:	8c 81       	ldd	r24, Y+4	; 0x04
    854e:	01 c0       	rjmp	.+2      	; 0x8552 <rs485rollerHello+0x22e>
    {
      tmp->state &= (~NOT_DETECTED);
      tmp->address = devAddr;
    }
    else
      return 1;
    8550:	81 e0       	ldi	r24, 0x01	; 1
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
  return result;
}
    8552:	24 96       	adiw	r28, 0x04	; 4
    8554:	cd bf       	out	0x3d, r28	; 61
    8556:	de bf       	out	0x3e, r29	; 62
    8558:	cf 91       	pop	r28
    855a:	df 91       	pop	r29
    855c:	1f 91       	pop	r17
    855e:	0f 91       	pop	r16
    8560:	ff 90       	pop	r15
    8562:	ef 90       	pop	r14
    8564:	df 90       	pop	r13
    8566:	cf 90       	pop	r12
    8568:	08 95       	ret

0000856a <rs485xModemFlash>:


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
    856a:	4f 92       	push	r4
    856c:	5f 92       	push	r5
    856e:	7f 92       	push	r7
    8570:	8f 92       	push	r8
    8572:	9f 92       	push	r9
    8574:	af 92       	push	r10
    8576:	bf 92       	push	r11
    8578:	cf 92       	push	r12
    857a:	df 92       	push	r13
    857c:	ef 92       	push	r14
    857e:	ff 92       	push	r15
    8580:	0f 93       	push	r16
    8582:	1f 93       	push	r17
    8584:	df 93       	push	r29
    8586:	cf 93       	push	r28
    8588:	00 d0       	rcall	.+0      	; 0x858a <rs485xModemFlash+0x20>
    858a:	cd b7       	in	r28, 0x3d	; 61
    858c:	de b7       	in	r29, 0x3e	; 62
    858e:	2c 01       	movw	r4, r24
    8590:	c6 2e       	mov	r12, r22
    8592:	8a 01       	movw	r16, r20
  uint8_t  blad = 0;
  uint8_t  data;
  uint8_t  nrBloku;
  uint8_t  lRetransmisji;
  
  takeRs485();                                  // Zajmowanie magistrali Rs485
    8594:	0e 94 5f 0a 	call	0x14be	; 0x14be <takeRs485>

  // Wysyłanie polecenia restartu
  crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    8598:	80 e0       	ldi	r24, 0x00	; 0
    859a:	90 e0       	ldi	r25, 0x00	; 0
    859c:	6a e5       	ldi	r22, 0x5A	; 90
    859e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    85a2:	7c 01       	movw	r14, r24
    85a4:	8a e5       	ldi	r24, 0x5A	; 90
    85a6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    85aa:	c7 01       	movw	r24, r14
    85ac:	6c 2d       	mov	r22, r12
    85ae:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    85b2:	7c 01       	movw	r14, r24
    85b4:	8c 2d       	mov	r24, r12
    85b6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    85ba:	c7 01       	movw	r24, r14
    85bc:	61 e8       	ldi	r22, 0x81	; 129
    85be:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    85c2:	7c 01       	movw	r14, r24
    85c4:	81 e8       	ldi	r24, 0x81	; 129
    85c6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    85ca:	c7 01       	movw	r24, r14
    85cc:	61 e0       	ldi	r22, 0x01	; 1
    85ce:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    85d2:	7c 01       	movw	r14, r24
    85d4:	81 e0       	ldi	r24, 0x01	; 1
    85d6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    85da:	c7 01       	movw	r24, r14
    85dc:	6c 2d       	mov	r22, r12
    85de:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    85e2:	e8 2e       	mov	r14, r24
    85e4:	8c 2d       	mov	r24, r12
    85e6:	9b 83       	std	Y+3, r25	; 0x03
    85e8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc>>8));
    85ec:	9b 81       	ldd	r25, Y+3	; 0x03
    85ee:	89 2f       	mov	r24, r25
    85f0:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    85f4:	8e 2d       	mov	r24, r14
    85f6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
    85fa:	ce 01       	movw	r24, r28
    85fc:	01 96       	adiw	r24, 0x01	; 1
    85fe:	64 e6       	ldi	r22, 0x64	; 100
    8600:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8604:	81 30       	cpi	r24, 0x01	; 1
    8606:	c1 f0       	breq	.+48     	; 0x8638 <rs485xModemFlash+0xce>
  {
    blad = 1;                                  // Timeout
    if (debugStr != NULL)
    8608:	01 15       	cp	r16, r1
    860a:	11 05       	cpc	r17, r1
    860c:	b9 f0       	breq	.+46     	; 0x863c <rs485xModemFlash+0xd2>
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
    860e:	00 d0       	rcall	.+0      	; 0x8610 <rs485xModemFlash+0xa6>
    8610:	0f 92       	push	r0
    8612:	ad b7       	in	r26, 0x3d	; 61
    8614:	be b7       	in	r27, 0x3e	; 62
    8616:	11 96       	adiw	r26, 0x01	; 1
    8618:	0d 93       	st	X+, r16
    861a:	1c 93       	st	X, r17
    861c:	12 97       	sbiw	r26, 0x02	; 2
    861e:	86 e4       	ldi	r24, 0x46	; 70
    8620:	90 e1       	ldi	r25, 0x10	; 16
    8622:	13 96       	adiw	r26, 0x03	; 3
    8624:	8d 93       	st	X+, r24
    8626:	9c 93       	st	X, r25
    8628:	14 97       	sbiw	r26, 0x04	; 4
    862a:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    862e:	0f 90       	pop	r0
    8630:	0f 90       	pop	r0
    8632:	0f 90       	pop	r0
    8634:	0f 90       	pop	r0
    8636:	02 c0       	rjmp	.+4      	; 0x863c <rs485xModemFlash+0xd2>


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
  uint16_t crc;
  uint8_t  blad = 0;
    8638:	aa 24       	eor	r10, r10
    863a:	02 c0       	rjmp	.+4      	; 0x8640 <rs485xModemFlash+0xd6>

  // Odbieranie odpowiedzi po wysłaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
  {
    blad = 1;                                  // Timeout
    863c:	aa 24       	eor	r10, r10
    863e:	a3 94       	inc	r10
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
  }
  crc = _crc_xmodem_update(0, data);
    8640:	80 e0       	ldi	r24, 0x00	; 0
    8642:	90 e0       	ldi	r25, 0x00	; 0
    8644:	69 81       	ldd	r22, Y+1	; 0x01
    8646:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    864a:	7c 01       	movw	r14, r24
 
  if ((blad == 0) && (data == 'C'))
    864c:	aa 20       	and	r10, r10
    864e:	c1 f4       	brne	.+48     	; 0x8680 <rs485xModemFlash+0x116>
    8650:	89 81       	ldd	r24, Y+1	; 0x01
    8652:	83 34       	cpi	r24, 0x43	; 67
    8654:	a9 f4       	brne	.+42     	; 0x8680 <rs485xModemFlash+0x116>
  {
    blad = 253;                                //Na urządzeniu jest wgrany tylko bootloader
    if (debugStr != NULL)
    8656:	01 15       	cp	r16, r1
    8658:	11 05       	cpc	r17, r1
    865a:	09 f4       	brne	.+2      	; 0x865e <rs485xModemFlash+0xf4>
    865c:	8f c0       	rjmp	.+286    	; 0x877c <rs485xModemFlash+0x212>
      fprintf_P(debugStr, PSTR("na urzadzeniu wgrany jest tylko bootloader\r\n"));    
    865e:	00 d0       	rcall	.+0      	; 0x8660 <rs485xModemFlash+0xf6>
    8660:	0f 92       	push	r0
    8662:	ed b7       	in	r30, 0x3d	; 61
    8664:	fe b7       	in	r31, 0x3e	; 62
    8666:	01 83       	std	Z+1, r16	; 0x01
    8668:	12 83       	std	Z+2, r17	; 0x02
    866a:	89 e1       	ldi	r24, 0x19	; 25
    866c:	90 e1       	ldi	r25, 0x10	; 16
    866e:	83 83       	std	Z+3, r24	; 0x03
    8670:	94 83       	std	Z+4, r25	; 0x04
    8672:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    8676:	0f 90       	pop	r0
    8678:	0f 90       	pop	r0
    867a:	0f 90       	pop	r0
    867c:	0f 90       	pop	r0
    867e:	7e c0       	rjmp	.+252    	; 0x877c <rs485xModemFlash+0x212>
  }
  else
  {
    if (data != SYNC)
    8680:	89 81       	ldd	r24, Y+1	; 0x01
    8682:	8a 35       	cpi	r24, 0x5A	; 90
    8684:	09 f0       	breq	.+2      	; 0x8688 <rs485xModemFlash+0x11e>
    8686:	75 c0       	rjmp	.+234    	; 0x8772 <rs485xModemFlash+0x208>
      blad = 2;
  }
 
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
    8688:	aa 20       	and	r10, r10
    868a:	09 f0       	breq	.+2      	; 0x868e <rs485xModemFlash+0x124>
    868c:	72 c0       	rjmp	.+228    	; 0x8772 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    868e:	ce 01       	movw	r24, r28
    8690:	01 96       	adiw	r24, 0x01	; 1
    8692:	61 e0       	ldi	r22, 0x01	; 1
    8694:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8698:	81 30       	cpi	r24, 0x01	; 1
    869a:	21 f4       	brne	.+8      	; 0x86a4 <rs485xModemFlash+0x13a>
      blad = 3;
    else
    {
      if (data != 0)
    869c:	89 81       	ldd	r24, Y+1	; 0x01
    869e:	88 23       	and	r24, r24
    86a0:	21 f4       	brne	.+8      	; 0x86aa <rs485xModemFlash+0x140>
    86a2:	05 c0       	rjmp	.+10     	; 0x86ae <rs485xModemFlash+0x144>
  //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno być 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 3;
    86a4:	33 e0       	ldi	r19, 0x03	; 3
    86a6:	a3 2e       	mov	r10, r19
    86a8:	02 c0       	rjmp	.+4      	; 0x86ae <rs485xModemFlash+0x144>
    else
    {
      if (data != 0)
        blad = 4;
    86aa:	24 e0       	ldi	r18, 0x04	; 4
    86ac:	a2 2e       	mov	r10, r18
    }
    crc = _crc_xmodem_update(crc, data);
    86ae:	c7 01       	movw	r24, r14
    86b0:	69 81       	ldd	r22, Y+1	; 0x01
    86b2:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    86b6:	7c 01       	movw	r14, r24
  }
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
    86b8:	aa 20       	and	r10, r10
    86ba:	09 f0       	breq	.+2      	; 0x86be <rs485xModemFlash+0x154>
    86bc:	5a c0       	rjmp	.+180    	; 0x8772 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    86be:	ce 01       	movw	r24, r28
    86c0:	01 96       	adiw	r24, 0x01	; 1
    86c2:	61 e0       	ldi	r22, 0x01	; 1
    86c4:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    86c8:	81 30       	cpi	r24, 0x01	; 1
    86ca:	21 f4       	brne	.+8      	; 0x86d4 <rs485xModemFlash+0x16a>
      blad = 5;
    else
    {
      if (data != rFLASH)
    86cc:	89 81       	ldd	r24, Y+1	; 0x01
    86ce:	81 38       	cpi	r24, 0x81	; 129
    86d0:	21 f4       	brne	.+8      	; 0x86da <rs485xModemFlash+0x170>
    86d2:	05 c0       	rjmp	.+10     	; 0x86de <rs485xModemFlash+0x174>
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 5;
    86d4:	95 e0       	ldi	r25, 0x05	; 5
    86d6:	a9 2e       	mov	r10, r25
    86d8:	02 c0       	rjmp	.+4      	; 0x86de <rs485xModemFlash+0x174>
    else
    {
      if (data != rFLASH)
        blad = 6;
    86da:	86 e0       	ldi	r24, 0x06	; 6
    86dc:	a8 2e       	mov	r10, r24
    }
    crc = _crc_xmodem_update(crc, data);
    86de:	c7 01       	movw	r24, r14
    86e0:	69 81       	ldd	r22, Y+1	; 0x01
    86e2:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    86e6:	7c 01       	movw	r14, r24
  }
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
    86e8:	aa 20       	and	r10, r10
    86ea:	09 f0       	breq	.+2      	; 0x86ee <rs485xModemFlash+0x184>
    86ec:	42 c0       	rjmp	.+132    	; 0x8772 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    86ee:	ce 01       	movw	r24, r28
    86f0:	01 96       	adiw	r24, 0x01	; 1
    86f2:	61 e0       	ldi	r22, 0x01	; 1
    86f4:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    86f8:	81 30       	cpi	r24, 0x01	; 1
    86fa:	21 f4       	brne	.+8      	; 0x8704 <rs485xModemFlash+0x19a>
      blad = 7;
    else
    {
      if (data != 1)
    86fc:	89 81       	ldd	r24, Y+1	; 0x01
    86fe:	81 30       	cpi	r24, 0x01	; 1
    8700:	21 f4       	brne	.+8      	; 0x870a <rs485xModemFlash+0x1a0>
    8702:	05 c0       	rjmp	.+10     	; 0x870e <rs485xModemFlash+0x1a4>
 
  //Odbieranie długości danych w rozkazie
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 7;
    8704:	b7 e0       	ldi	r27, 0x07	; 7
    8706:	ab 2e       	mov	r10, r27
    8708:	02 c0       	rjmp	.+4      	; 0x870e <rs485xModemFlash+0x1a4>
    else
    {
      if (data != 1)
        blad = 8;
    870a:	a8 e0       	ldi	r26, 0x08	; 8
    870c:	aa 2e       	mov	r10, r26
    }
    crc = _crc_xmodem_update(crc, data);
    870e:	c7 01       	movw	r24, r14
    8710:	69 81       	ldd	r22, Y+1	; 0x01
    8712:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8716:	7c 01       	movw	r14, r24
  }
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
    8718:	aa 20       	and	r10, r10
    871a:	59 f5       	brne	.+86     	; 0x8772 <rs485xModemFlash+0x208>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    871c:	ce 01       	movw	r24, r28
    871e:	01 96       	adiw	r24, 0x01	; 1
    8720:	61 e0       	ldi	r22, 0x01	; 1
    8722:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8726:	81 30       	cpi	r24, 0x01	; 1
    8728:	21 f4       	brne	.+8      	; 0x8732 <rs485xModemFlash+0x1c8>
      blad = 9;
    else
    {
      if (data != devAddr)
    872a:	89 81       	ldd	r24, Y+1	; 0x01
    872c:	8c 15       	cp	r24, r12
    872e:	21 f4       	brne	.+8      	; 0x8738 <rs485xModemFlash+0x1ce>
    8730:	05 c0       	rjmp	.+10     	; 0x873c <rs485xModemFlash+0x1d2>
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
  {
    if(rs485Receive(&data, 1) != pdTRUE)
      blad = 9;
    8732:	f9 e0       	ldi	r31, 0x09	; 9
    8734:	af 2e       	mov	r10, r31
    8736:	02 c0       	rjmp	.+4      	; 0x873c <rs485xModemFlash+0x1d2>
    else
    {
      if (data != devAddr)
        blad = 10;
    8738:	ea e0       	ldi	r30, 0x0A	; 10
    873a:	ae 2e       	mov	r10, r30
    }
    crc = _crc_xmodem_update(crc, data);
    873c:	c7 01       	movw	r24, r14
    873e:	69 81       	ldd	r22, Y+1	; 0x01
    8740:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8744:	98 2e       	mov	r9, r24
    8746:	89 2e       	mov	r8, r25
  }
   
  //Odbieranie CRC Hi
  if (blad == 0)
    8748:	aa 20       	and	r10, r10
    874a:	99 f4       	brne	.+38     	; 0x8772 <rs485xModemFlash+0x208>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    874c:	72 e0       	ldi	r23, 0x02	; 2
    874e:	e7 2e       	mov	r14, r23
    8750:	f1 2c       	mov	r15, r1
    8752:	ec 0e       	add	r14, r28
    8754:	fd 1e       	adc	r15, r29
    8756:	c7 01       	movw	r24, r14
    8758:	61 e0       	ldi	r22, 0x01	; 1
    875a:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    875e:	81 30       	cpi	r24, 0x01	; 1
    8760:	41 f4       	brne	.+16     	; 0x8772 <rs485xModemFlash+0x208>
      blad = 11;
    else
    {
      if ((uint8_t)(crc>>8) != nrBloku)
    8762:	8a 81       	ldd	r24, Y+2	; 0x02
    8764:	88 15       	cp	r24, r8
    8766:	29 f4       	brne	.+10     	; 0x8772 <rs485xModemFlash+0x208>
    8768:	f7 c0       	rjmp	.+494    	; 0x8958 <rs485xModemFlash+0x3ee>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
      blad = 13;
    else
    {
      if ((uint8_t)(crc & 0xFF) != nrBloku)
    876a:	8a 81       	ldd	r24, Y+2	; 0x02
    876c:	89 15       	cp	r24, r9
    876e:	09 f4       	brne	.+2      	; 0x8772 <rs485xModemFlash+0x208>
    8770:	fb c0       	rjmp	.+502    	; 0x8968 <rs485xModemFlash+0x3fe>
    }    
  }
   
  if ((blad != 0) && (blad != 253))
  {
    releaseRs485();
    8772:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
    flushRs485RecBuffer();  
    8776:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>
    877a:	3c c1       	rjmp	.+632    	; 0x89f4 <rs485xModemFlash+0x48a>
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
    877c:	d2 01       	movw	r26, r4
    877e:	14 96       	adiw	r26, 0x04	; 4
    8780:	ed 91       	ld	r30, X+
    8782:	fc 91       	ld	r31, X
    8784:	15 97       	sbiw	r26, 0x05	; 5
    8786:	72 80       	ldd	r7, Z+2	; 0x02
    8788:	77 0c       	add	r7, r7
  if (file->wpis->rozmiarLo == 128)
    878a:	81 81       	ldd	r24, Z+1	; 0x01
    878c:	80 38       	cpi	r24, 0x80	; 128
    878e:	99 f4       	brne	.+38     	; 0x87b6 <rs485xModemFlash+0x24c>
    8790:	11 c0       	rjmp	.+34     	; 0x87b4 <rs485xModemFlash+0x24a>
  if (blad != 0)
  {
    releaseRs485();
    flushRs485RecBuffer();  
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    8792:	00 d0       	rcall	.+0      	; 0x8794 <rs485xModemFlash+0x22a>
    8794:	0f 92       	push	r0
    8796:	ed b7       	in	r30, 0x3d	; 61
    8798:	fe b7       	in	r31, 0x3e	; 62
    879a:	01 83       	std	Z+1, r16	; 0x01
    879c:	12 83       	std	Z+2, r17	; 0x02
    879e:	8f ee       	ldi	r24, 0xEF	; 239
    87a0:	9f e0       	ldi	r25, 0x0F	; 15
    87a2:	83 83       	std	Z+3, r24	; 0x03
    87a4:	94 83       	std	Z+4, r25	; 0x04
    87a6:	0e 94 ce 57 	call	0xaf9c	; 0xaf9c <fprintf_P>
    87aa:	0f 90       	pop	r0
    87ac:	0f 90       	pop	r0
    87ae:	0f 90       	pop	r0
    87b0:	0f 90       	pop	r0
    87b2:	20 c1       	rjmp	.+576    	; 0x89f4 <rs485xModemFlash+0x48a>
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
  if (file->wpis->rozmiarLo == 128)
    liczbaBlokow++;
    87b4:	73 94       	inc	r7
   
  nrBloku = 1;
    87b6:	81 e0       	ldi	r24, 0x01	; 1
    87b8:	8a 83       	std	Y+2, r24	; 0x02
  lRetransmisji = 0;
    87ba:	88 24       	eor	r8, r8
   
  while (nrBloku <= liczbaBlokow)
    87bc:	99 24       	eor	r9, r9
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    87be:	6e 01       	movw	r12, r28
    87c0:	08 94       	sec
    87c2:	c1 1c       	adc	r12, r1
    87c4:	d1 1c       	adc	r13, r1
    if (debugStr != NULL)
    {
      if (data == NAK)
        fputc('N', debugStr);
      if (data != 0)
        fprintf(debugStr, "data 0x%x ", data);                    
    87c6:	6e e1       	ldi	r22, 0x1E	; 30
    87c8:	a6 2e       	mov	r10, r22
    87ca:	65 e2       	ldi	r22, 0x25	; 37
    87cc:	b6 2e       	mov	r11, r22
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    87ce:	90 c0       	rjmp	.+288    	; 0x88f0 <rs485xModemFlash+0x386>
  {
    crc = 0;
    uartRs485SendByte(SOH);
    87d0:	81 e0       	ldi	r24, 0x01	; 1
    87d2:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte(nrBloku);
    87d6:	8a 81       	ldd	r24, Y+2	; 0x02
    87d8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    data = (uint8_t)(~nrBloku);
    87dc:	8a 81       	ldd	r24, Y+2	; 0x02
    87de:	80 95       	com	r24
    87e0:	89 83       	std	Y+1, r24	; 0x01
    uartRs485SendByte(data);
    87e2:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    87e6:	99 24       	eor	r9, r9
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
  {
    crc = 0;
    87e8:	ee 24       	eor	r14, r14
    87ea:	ff 24       	eor	r15, r15
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    87ec:	c2 01       	movw	r24, r4
    87ee:	b6 01       	movw	r22, r12
    87f0:	0e 94 bd 1e 	call	0x3d7a	; 0x3d7a <ramDyskCzytajBajtZPliku>
    87f4:	81 11       	cpse	r24, r1
        data = 0;
    87f6:	19 82       	std	Y+1, r1	; 0x01
      crc = _crc_xmodem_update(crc, data);
    87f8:	c7 01       	movw	r24, r14
    87fa:	69 81       	ldd	r22, Y+1	; 0x01
    87fc:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8800:	7c 01       	movw	r14, r24
      uartRs485SendByte(data);
    8802:	89 81       	ldd	r24, Y+1	; 0x01
    8804:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte(SOH);
    uartRs485SendByte(nrBloku);
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
    8808:	93 94       	inc	r9
    880a:	f9 2d       	mov	r31, r9
    880c:	f0 38       	cpi	r31, 0x80	; 128
    880e:	71 f7       	brne	.-36     	; 0x87ec <rs485xModemFlash+0x282>
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
        data = 0;
      crc = _crc_xmodem_update(crc, data);
      uartRs485SendByte(data);
    }
    uartRs485SendByte((uint8_t)(crc>>8));
    8810:	8f 2d       	mov	r24, r15
    8812:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    8816:	8e 2d       	mov	r24, r14
    8818:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 
    if(rs485Receive(&data, 100) != pdTRUE)
    881c:	c6 01       	movw	r24, r12
    881e:	64 e6       	ldi	r22, 0x64	; 100
    8820:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8824:	81 30       	cpi	r24, 0x01	; 1
    8826:	59 f0       	breq	.+22     	; 0x883e <rs485xModemFlash+0x2d4>
    {
      blad = 250;
      if (debugStr != NULL)
    8828:	01 15       	cp	r16, r1
    882a:	11 05       	cpc	r17, r1
    882c:	29 f0       	breq	.+10     	; 0x8838 <rs485xModemFlash+0x2ce>
        fputc('#', debugStr);
    882e:	83 e2       	ldi	r24, 0x23	; 35
    8830:	90 e0       	ldi	r25, 0x00	; 0
    8832:	b8 01       	movw	r22, r16
    8834:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
      data = 0;
    8838:	19 82       	std	Y+1, r1	; 0x01
    uartRs485SendByte((uint8_t)(crc>>8));
    uartRs485SendByte((uint8_t)(crc & 0xFF));
 
    if(rs485Receive(&data, 100) != pdTRUE)
    {
      blad = 250;
    883a:	5a ef       	ldi	r21, 0xFA	; 250
    883c:	95 2e       	mov	r9, r21
      if (debugStr != NULL)
        fputc('#', debugStr);
      data = 0;
    }
     
    flushRs485RecBuffer();
    883e:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>

    if (data == ACK)
    8842:	89 81       	ldd	r24, Y+1	; 0x01
    8844:	86 30       	cpi	r24, 0x06	; 6
    8846:	f1 f4       	brne	.+60     	; 0x8884 <rs485xModemFlash+0x31a>
    {
      nrBloku ++;
    8848:	8a 81       	ldd	r24, Y+2	; 0x02
    884a:	8f 5f       	subi	r24, 0xFF	; 255
    884c:	8a 83       	std	Y+2, r24	; 0x02
      lRetransmisji = 0;
      blad = 0;
      if (debugStr != NULL)
    884e:	01 15       	cp	r16, r1
    8850:	11 05       	cpc	r17, r1
    8852:	09 f4       	brne	.+2      	; 0x8856 <rs485xModemFlash+0x2ec>
    8854:	4b c0       	rjmp	.+150    	; 0x88ec <rs485xModemFlash+0x382>
      {
        fputc('.', debugStr);
    8856:	8e e2       	ldi	r24, 0x2E	; 46
    8858:	90 e0       	ldi	r25, 0x00	; 0
    885a:	b8 01       	movw	r22, r16
    885c:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
        if ((nrBloku & 0x0F) == 0)
    8860:	8a 81       	ldd	r24, Y+2	; 0x02
    8862:	90 e0       	ldi	r25, 0x00	; 0
    8864:	8f 70       	andi	r24, 0x0F	; 15
    8866:	90 70       	andi	r25, 0x00	; 0
    8868:	00 97       	sbiw	r24, 0x00	; 0
    886a:	09 f0       	breq	.+2      	; 0x886e <rs485xModemFlash+0x304>
    886c:	3f c0       	rjmp	.+126    	; 0x88ec <rs485xModemFlash+0x382>
        {
          fputc('\r', debugStr);
    886e:	8d e0       	ldi	r24, 0x0D	; 13
    8870:	90 e0       	ldi	r25, 0x00	; 0
    8872:	b8 01       	movw	r22, r16
    8874:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
          fputc('\n', debugStr);      
    8878:	8a e0       	ldi	r24, 0x0A	; 10
    887a:	90 e0       	ldi	r25, 0x00	; 0
    887c:	b8 01       	movw	r22, r16
    887e:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    8882:	34 c0       	rjmp	.+104    	; 0x88ec <rs485xModemFlash+0x382>
        }
      }
      continue;
    }
 
    if (data == CAN)
    8884:	88 31       	cpi	r24, 0x18	; 24
    8886:	51 f4       	brne	.+20     	; 0x889c <rs485xModemFlash+0x332>
    {
      if (debugStr != NULL)
    8888:	01 15       	cp	r16, r1
    888a:	11 05       	cpc	r17, r1
    888c:	09 f4       	brne	.+2      	; 0x8890 <rs485xModemFlash+0x326>
    888e:	b5 c0       	rjmp	.+362    	; 0x89fa <rs485xModemFlash+0x490>
        fputc('C', debugStr);
    8890:	83 e4       	ldi	r24, 0x43	; 67
    8892:	90 e0       	ldi	r25, 0x00	; 0
    8894:	b8 01       	movw	r22, r16
    8896:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    889a:	af c0       	rjmp	.+350    	; 0x89fa <rs485xModemFlash+0x490>
      blad = 249;
      break;
    }
    
    if (debugStr != NULL)
    889c:	01 15       	cp	r16, r1
    889e:	11 05       	cpc	r17, r1
    88a0:	01 f1       	breq	.+64     	; 0x88e2 <rs485xModemFlash+0x378>
    {
      if (data == NAK)
    88a2:	85 31       	cpi	r24, 0x15	; 21
    88a4:	29 f4       	brne	.+10     	; 0x88b0 <rs485xModemFlash+0x346>
        fputc('N', debugStr);
    88a6:	8e e4       	ldi	r24, 0x4E	; 78
    88a8:	90 e0       	ldi	r25, 0x00	; 0
    88aa:	b8 01       	movw	r22, r16
    88ac:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
      if (data != 0)
    88b0:	89 81       	ldd	r24, Y+1	; 0x01
    88b2:	88 23       	and	r24, r24
    88b4:	b1 f0       	breq	.+44     	; 0x88e2 <rs485xModemFlash+0x378>
        fprintf(debugStr, "data 0x%x ", data);                    
    88b6:	00 d0       	rcall	.+0      	; 0x88b8 <rs485xModemFlash+0x34e>
    88b8:	00 d0       	rcall	.+0      	; 0x88ba <rs485xModemFlash+0x350>
    88ba:	ed b7       	in	r30, 0x3d	; 61
    88bc:	fe b7       	in	r31, 0x3e	; 62
    88be:	31 96       	adiw	r30, 0x01	; 1
    88c0:	ad b7       	in	r26, 0x3d	; 61
    88c2:	be b7       	in	r27, 0x3e	; 62
    88c4:	11 96       	adiw	r26, 0x01	; 1
    88c6:	0d 93       	st	X+, r16
    88c8:	1c 93       	st	X, r17
    88ca:	12 97       	sbiw	r26, 0x02	; 2
    88cc:	a2 82       	std	Z+2, r10	; 0x02
    88ce:	b3 82       	std	Z+3, r11	; 0x03
    88d0:	84 83       	std	Z+4, r24	; 0x04
    88d2:	15 82       	std	Z+5, r1	; 0x05
    88d4:	0e 94 be 57 	call	0xaf7c	; 0xaf7c <fprintf>
    88d8:	ed b7       	in	r30, 0x3d	; 61
    88da:	fe b7       	in	r31, 0x3e	; 62
    88dc:	36 96       	adiw	r30, 0x06	; 6
    88de:	ed bf       	out	0x3d, r30	; 61
    88e0:	fe bf       	out	0x3e, r31	; 62
    }
    
    lRetransmisji ++;
    88e2:	83 94       	inc	r8
     
    if (lRetransmisji == 3)
    88e4:	f8 2d       	mov	r31, r8
    88e6:	f3 30       	cpi	r31, 0x03	; 3
    88e8:	19 f4       	brne	.+6      	; 0x88f0 <rs485xModemFlash+0x386>
    88ea:	8a c0       	rjmp	.+276    	; 0x8a00 <rs485xModemFlash+0x496>
    flushRs485RecBuffer();

    if (data == ACK)
    {
      nrBloku ++;
      lRetransmisji = 0;
    88ec:	88 24       	eor	r8, r8
      blad = 0;
    88ee:	99 24       	eor	r9, r9
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    88f0:	8a 81       	ldd	r24, Y+2	; 0x02
    88f2:	78 16       	cp	r7, r24
    88f4:	08 f0       	brcs	.+2      	; 0x88f8 <rs485xModemFlash+0x38e>
    88f6:	6c cf       	rjmp	.-296    	; 0x87d0 <rs485xModemFlash+0x266>
      blad = 248;
      break;
    }
  }
 
  if (blad == 0)
    88f8:	99 20       	and	r9, r9
    88fa:	b1 f4       	brne	.+44     	; 0x8928 <rs485xModemFlash+0x3be>
  {
    uartRs485SendByte(EOT); 
    88fc:	84 e0       	ldi	r24, 0x04	; 4
    88fe:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    if(rs485Receive(&data, 25) == pdTRUE)
    8902:	8e 01       	movw	r16, r28
    8904:	0f 5f       	subi	r16, 0xFF	; 255
    8906:	1f 4f       	sbci	r17, 0xFF	; 255
    8908:	c8 01       	movw	r24, r16
    890a:	69 e1       	ldi	r22, 0x19	; 25
    890c:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8910:	81 30       	cpi	r24, 0x01	; 1
    8912:	51 f4       	brne	.+20     	; 0x8928 <rs485xModemFlash+0x3be>
    {
      if (data == ACK)
    8914:	89 81       	ldd	r24, Y+1	; 0x01
    8916:	86 30       	cpi	r24, 0x06	; 6
    8918:	39 f4       	brne	.+14     	; 0x8928 <rs485xModemFlash+0x3be>
      {
        uartRs485SendByte(EOT);
    891a:	84 e0       	ldi	r24, 0x04	; 4
    891c:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
        rs485Receive(&data, 25);
    8920:	c8 01       	movw	r24, r16
    8922:	69 e1       	ldi	r22, 0x19	; 25
    8924:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
      }
    }
  }

  flushRs485RecBuffer();  
    8928:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>
  releaseRs485();
    892c:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
  return blad;
}
    8930:	89 2d       	mov	r24, r9
    8932:	23 96       	adiw	r28, 0x03	; 3
    8934:	cd bf       	out	0x3d, r28	; 61
    8936:	de bf       	out	0x3e, r29	; 62
    8938:	cf 91       	pop	r28
    893a:	df 91       	pop	r29
    893c:	1f 91       	pop	r17
    893e:	0f 91       	pop	r16
    8940:	ff 90       	pop	r15
    8942:	ef 90       	pop	r14
    8944:	df 90       	pop	r13
    8946:	cf 90       	pop	r12
    8948:	bf 90       	pop	r11
    894a:	af 90       	pop	r10
    894c:	9f 90       	pop	r9
    894e:	8f 90       	pop	r8
    8950:	7f 90       	pop	r7
    8952:	5f 90       	pop	r5
    8954:	4f 90       	pop	r4
    8956:	08 95       	ret
  }
   
  //Odbieranie CRC Lo
  if (blad == 0)
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    8958:	c7 01       	movw	r24, r14
    895a:	61 e0       	ldi	r22, 0x01	; 1
    895c:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
    8960:	81 30       	cpi	r24, 0x01	; 1
    8962:	09 f0       	breq	.+2      	; 0x8966 <rs485xModemFlash+0x3fc>
    8964:	06 cf       	rjmp	.-500    	; 0x8772 <rs485xModemFlash+0x208>
    8966:	01 cf       	rjmp	.-510    	; 0x876a <rs485xModemFlash+0x200>
  }

// Wysyłanie polecenia do bootloadera
  if (blad == 0)
  {
    vTaskDelay(100);
    8968:	84 e6       	ldi	r24, 0x64	; 100
    896a:	90 e0       	ldi	r25, 0x00	; 0
    896c:	0e 94 b0 4a 	call	0x9560	; 0x9560 <vTaskDelay>
     
    crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    8970:	80 e0       	ldi	r24, 0x00	; 0
    8972:	90 e0       	ldi	r25, 0x00	; 0
    8974:	6a e5       	ldi	r22, 0x5A	; 90
    8976:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    897a:	7c 01       	movw	r14, r24
    897c:	8a e5       	ldi	r24, 0x5A	; 90
    897e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    8982:	c7 01       	movw	r24, r14
    8984:	6c 2d       	mov	r22, r12
    8986:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    898a:	7c 01       	movw	r14, r24
    898c:	8c 2d       	mov	r24, r12
    898e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    8992:	c7 01       	movw	r24, r14
    8994:	61 e8       	ldi	r22, 0x81	; 129
    8996:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    899a:	7c 01       	movw	r14, r24
    899c:	81 e8       	ldi	r24, 0x81	; 129
    899e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    89a2:	c7 01       	movw	r24, r14
    89a4:	61 e0       	ldi	r22, 0x01	; 1
    89a6:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    89aa:	7c 01       	movw	r14, r24
    89ac:	81 e0       	ldi	r24, 0x01	; 1
    89ae:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    89b2:	c7 01       	movw	r24, r14
    89b4:	6c 2d       	mov	r22, r12
    89b6:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    89ba:	e8 2e       	mov	r14, r24
    89bc:	8c 2d       	mov	r24, r12
    89be:	9b 83       	std	Y+3, r25	; 0x03
    89c0:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc>>8));
    89c4:	9b 81       	ldd	r25, Y+3	; 0x03
    89c6:	89 2f       	mov	r24, r25
    89c8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    89cc:	8e 2d       	mov	r24, r14
    89ce:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
 
    //Odbieranie odpowiedzi od Bootloadera
    if(rs485Receive(&data, 150) != pdTRUE)
    89d2:	ce 01       	movw	r24, r28
    89d4:	01 96       	adiw	r24, 0x01	; 1
    89d6:	66 e9       	ldi	r22, 0x96	; 150
    89d8:	0e 94 b7 09 	call	0x136e	; 0x136e <rs485Receive>
      blad = 15;

    if (data != 'C')
    89dc:	89 81       	ldd	r24, Y+1	; 0x01
    89de:	83 34       	cpi	r24, 0x43	; 67
    89e0:	09 f4       	brne	.+2      	; 0x89e4 <rs485xModemFlash+0x47a>
    89e2:	cc ce       	rjmp	.-616    	; 0x877c <rs485xModemFlash+0x212>
    blad = 0;
  
   
  if (blad != 0)
  {
    releaseRs485();
    89e4:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <releaseRs485>
    flushRs485RecBuffer();  
    89e8:	0e 94 3d 0a 	call	0x147a	; 0x147a <flushRs485RecBuffer>
    if (debugStr != NULL)
    89ec:	01 15       	cp	r16, r1
    89ee:	11 05       	cpc	r17, r1
    89f0:	09 f0       	breq	.+2      	; 0x89f4 <rs485xModemFlash+0x48a>
    89f2:	cf ce       	rjmp	.-610    	; 0x8792 <rs485xModemFlash+0x228>
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
    89f4:	99 24       	eor	r9, r9
    89f6:	93 94       	inc	r9
    89f8:	9b cf       	rjmp	.-202    	; 0x8930 <rs485xModemFlash+0x3c6>
 
    if (data == CAN)
    {
      if (debugStr != NULL)
        fputc('C', debugStr);
      blad = 249;
    89fa:	49 ef       	ldi	r20, 0xF9	; 249
    89fc:	94 2e       	mov	r9, r20
    89fe:	94 cf       	rjmp	.-216    	; 0x8928 <rs485xModemFlash+0x3be>
    
    lRetransmisji ++;
     
    if (lRetransmisji == 3)
    {
      blad = 248;
    8a00:	38 ef       	ldi	r19, 0xF8	; 248
    8a02:	93 2e       	mov	r9, r19
    8a04:	91 cf       	rjmp	.-222    	; 0x8928 <rs485xModemFlash+0x3be>

00008a06 <rs485curtainUp>:
  releaseRs485();
  return blad;
}

uint8_t rs485curtainUp(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    8a06:	cf 92       	push	r12
    8a08:	df 92       	push	r13
    8a0a:	ff 92       	push	r15
    8a0c:	0f 93       	push	r16
    8a0e:	1f 93       	push	r17
    8a10:	df 93       	push	r29
    8a12:	cf 93       	push	r28
    8a14:	0f 92       	push	r0
    8a16:	cd b7       	in	r28, 0x3d	; 61
    8a18:	de b7       	in	r29, 0x3e	; 62
    8a1a:	18 2f       	mov	r17, r24
    8a1c:	06 2f       	mov	r16, r22
    8a1e:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
    8a20:	80 e0       	ldi	r24, 0x00	; 0
    8a22:	90 e0       	ldi	r25, 0x00	; 0
    8a24:	6a e5       	ldi	r22, 0x5A	; 90
    8a26:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8a2a:	6c 01       	movw	r12, r24
  uartRs485SendByte(SYNC);
    8a2c:	8a e5       	ldi	r24, 0x5A	; 90
    8a2e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, deviceAddr);
    8a32:	c6 01       	movw	r24, r12
    8a34:	61 2f       	mov	r22, r17
    8a36:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8a3a:	6c 01       	movw	r12, r24
  uartRs485SendByte(deviceAddr);
    8a3c:	81 2f       	mov	r24, r17
    8a3e:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  if (curtainNo == 0)
    8a42:	00 23       	and	r16, r16
    8a44:	39 f4       	brne	.+14     	; 0x8a54 <rs485curtainUp+0x4e>
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete1);
    8a46:	c6 01       	movw	r24, r12
    8a48:	60 e2       	ldi	r22, 0x20	; 32
    8a4a:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8a4e:	8c 01       	movw	r16, r24
    uartRs485SendByte(rPodniesRolete1);
    8a50:	80 e2       	ldi	r24, 0x20	; 32
    8a52:	06 c0       	rjmp	.+12     	; 0x8a60 <rs485curtainUp+0x5a>
  }
  else
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete2);
    8a54:	c6 01       	movw	r24, r12
    8a56:	61 e2       	ldi	r22, 0x21	; 33
    8a58:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8a5c:	8c 01       	movw	r16, r24
    uartRs485SendByte(rPodniesRolete2); 
    8a5e:	81 e2       	ldi	r24, 0x21	; 33
    8a60:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  }
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    8a64:	c8 01       	movw	r24, r16
    8a66:	61 e0       	ldi	r22, 0x01	; 1
    8a68:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8a6c:	8c 01       	movw	r16, r24
    8a6e:	81 e0       	ldi	r24, 0x01	; 1
    8a70:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, pos);  uartRs485SendByte(pos);
    8a74:	c8 01       	movw	r24, r16
    8a76:	6f 2d       	mov	r22, r15
    8a78:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8a7c:	18 2f       	mov	r17, r24
    8a7e:	8f 2d       	mov	r24, r15
    8a80:	99 83       	std	Y+1, r25	; 0x01
    8a82:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8a86:	99 81       	ldd	r25, Y+1	; 0x01
    8a88:	89 2f       	mov	r24, r25
    8a8a:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8a8e:	81 2f       	mov	r24, r17
    8a90:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  return 0;
}
    8a94:	80 e0       	ldi	r24, 0x00	; 0
    8a96:	0f 90       	pop	r0
    8a98:	cf 91       	pop	r28
    8a9a:	df 91       	pop	r29
    8a9c:	1f 91       	pop	r17
    8a9e:	0f 91       	pop	r16
    8aa0:	ff 90       	pop	r15
    8aa2:	df 90       	pop	r13
    8aa4:	cf 90       	pop	r12
    8aa6:	08 95       	ret

00008aa8 <rs485Led>:

uint8_t rs485Led(uint8_t deviceAddr, uint8_t ledNo, uint8_t time)
{
    8aa8:	cf 92       	push	r12
    8aaa:	df 92       	push	r13
    8aac:	ff 92       	push	r15
    8aae:	0f 93       	push	r16
    8ab0:	1f 93       	push	r17
    8ab2:	df 93       	push	r29
    8ab4:	cf 93       	push	r28
    8ab6:	0f 92       	push	r0
    8ab8:	cd b7       	in	r28, 0x3d	; 61
    8aba:	de b7       	in	r29, 0x3e	; 62
    8abc:	18 2f       	mov	r17, r24
    8abe:	06 2f       	mov	r16, r22
    8ac0:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
    8ac2:	80 e0       	ldi	r24, 0x00	; 0
    8ac4:	90 e0       	ldi	r25, 0x00	; 0
    8ac6:	6a e5       	ldi	r22, 0x5A	; 90
    8ac8:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8acc:	6c 01       	movw	r12, r24
  uartRs485SendByte(SYNC);
    8ace:	8a e5       	ldi	r24, 0x5A	; 90
    8ad0:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, deviceAddr);
    8ad4:	c6 01       	movw	r24, r12
    8ad6:	61 2f       	mov	r22, r17
    8ad8:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8adc:	6c 01       	movw	r12, r24
  uartRs485SendByte(deviceAddr);
    8ade:	81 2f       	mov	r24, r17
    8ae0:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  crc = _crc_xmodem_update(crc, ledNo);
    8ae4:	c6 01       	movw	r24, r12
    8ae6:	60 2f       	mov	r22, r16
    8ae8:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    8aec:	61 e0       	ldi	r22, 0x01	; 1
    8aee:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8af2:	8c 01       	movw	r16, r24
    8af4:	81 e0       	ldi	r24, 0x01	; 1
    8af6:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, time);  uartRs485SendByte(time);
    8afa:	c8 01       	movw	r24, r16
    8afc:	6f 2d       	mov	r22, r15
    8afe:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8b02:	18 2f       	mov	r17, r24
    8b04:	8f 2d       	mov	r24, r15
    8b06:	99 83       	std	Y+1, r25	; 0x01
    8b08:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8b0c:	99 81       	ldd	r25, Y+1	; 0x01
    8b0e:	89 2f       	mov	r24, r25
    8b10:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8b14:	81 2f       	mov	r24, r17
    8b16:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  return 0;
}
    8b1a:	80 e0       	ldi	r24, 0x00	; 0
    8b1c:	0f 90       	pop	r0
    8b1e:	cf 91       	pop	r28
    8b20:	df 91       	pop	r29
    8b22:	1f 91       	pop	r17
    8b24:	0f 91       	pop	r16
    8b26:	ff 90       	pop	r15
    8b28:	df 90       	pop	r13
    8b2a:	cf 90       	pop	r12
    8b2c:	08 95       	ret

00008b2e <rs485curtainDown>:


uint8_t rs485curtainDown(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    8b2e:	cf 92       	push	r12
    8b30:	df 92       	push	r13
    8b32:	ff 92       	push	r15
    8b34:	0f 93       	push	r16
    8b36:	1f 93       	push	r17
    8b38:	df 93       	push	r29
    8b3a:	cf 93       	push	r28
    8b3c:	0f 92       	push	r0
    8b3e:	cd b7       	in	r28, 0x3d	; 61
    8b40:	de b7       	in	r29, 0x3e	; 62
    8b42:	18 2f       	mov	r17, r24
    8b44:	06 2f       	mov	r16, r22
    8b46:	f4 2e       	mov	r15, r20
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);            uartRs485SendByte(SYNC);
    8b48:	80 e0       	ldi	r24, 0x00	; 0
    8b4a:	90 e0       	ldi	r25, 0x00	; 0
    8b4c:	6a e5       	ldi	r22, 0x5A	; 90
    8b4e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8b52:	6c 01       	movw	r12, r24
    8b54:	8a e5       	ldi	r24, 0x5A	; 90
    8b56:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, deviceAddr);    uartRs485SendByte(deviceAddr);
    8b5a:	c6 01       	movw	r24, r12
    8b5c:	61 2f       	mov	r22, r17
    8b5e:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8b62:	6c 01       	movw	r12, r24
    8b64:	81 2f       	mov	r24, r17
    8b66:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  if (curtainNo == 0)
    8b6a:	00 23       	and	r16, r16
    8b6c:	39 f4       	brne	.+14     	; 0x8b7c <rs485curtainDown+0x4e>
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete1); uartRs485SendByte(rOpuscRolete1);
    8b6e:	c6 01       	movw	r24, r12
    8b70:	60 e1       	ldi	r22, 0x10	; 16
    8b72:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8b76:	8c 01       	movw	r16, r24
    8b78:	80 e1       	ldi	r24, 0x10	; 16
    8b7a:	06 c0       	rjmp	.+12     	; 0x8b88 <rs485curtainDown+0x5a>
  }
  else
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete2); uartRs485SendByte(rOpuscRolete2); 
    8b7c:	c6 01       	movw	r24, r12
    8b7e:	61 e1       	ldi	r22, 0x11	; 17
    8b80:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8b84:	8c 01       	movw	r16, r24
    8b86:	81 e1       	ldi	r24, 0x11	; 17
    8b88:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  }

  crc = _crc_xmodem_update(crc, 1);               uartRs485SendByte(1);
    8b8c:	c8 01       	movw	r24, r16
    8b8e:	61 e0       	ldi	r22, 0x01	; 1
    8b90:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8b94:	8c 01       	movw	r16, r24
    8b96:	81 e0       	ldi	r24, 0x01	; 1
    8b98:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  crc = _crc_xmodem_update(crc, pos);         uartRs485SendByte(pos);
    8b9c:	c8 01       	movw	r24, r16
    8b9e:	6f 2d       	mov	r22, r15
    8ba0:	0e 94 8c 3f 	call	0x7f18	; 0x7f18 <_crc_xmodem_update>
    8ba4:	18 2f       	mov	r17, r24
    8ba6:	8f 2d       	mov	r24, r15
    8ba8:	99 83       	std	Y+1, r25	; 0x01
    8baa:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    8bae:	99 81       	ldd	r25, Y+1	; 0x01
    8bb0:	89 2f       	mov	r24, r25
    8bb2:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    8bb6:	81 2f       	mov	r24, r17
    8bb8:	0e 94 9c 09 	call	0x1338	; 0x1338 <uartRs485SendByte>

  return 0;
}
    8bbc:	80 e0       	ldi	r24, 0x00	; 0
    8bbe:	0f 90       	pop	r0
    8bc0:	cf 91       	pop	r28
    8bc2:	df 91       	pop	r29
    8bc4:	1f 91       	pop	r17
    8bc6:	0f 91       	pop	r16
    8bc8:	ff 90       	pop	r15
    8bca:	df 90       	pop	r13
    8bcc:	cf 90       	pop	r12
    8bce:	08 95       	ret

00008bd0 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
    8bd0:	4f 92       	push	r4
    8bd2:	5f 92       	push	r5
    8bd4:	6f 92       	push	r6
    8bd6:	7f 92       	push	r7
    8bd8:	8f 92       	push	r8
    8bda:	9f 92       	push	r9
    8bdc:	af 92       	push	r10
    8bde:	bf 92       	push	r11
    8be0:	cf 92       	push	r12
    8be2:	df 92       	push	r13
    8be4:	ef 92       	push	r14
    8be6:	ff 92       	push	r15
    8be8:	0f 93       	push	r16
    8bea:	1f 93       	push	r17
    8bec:	cf 93       	push	r28
    8bee:	df 93       	push	r29
    8bf0:	2c 01       	movw	r4, r24
    8bf2:	eb 01       	movw	r28, r22
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    8bf4:	e9 81       	ldd	r30, Y+1	; 0x01
    8bf6:	fa 81       	ldd	r31, Y+2	; 0x02
    8bf8:	02 80       	ldd	r0, Z+2	; 0x02
    8bfa:	f3 81       	ldd	r31, Z+3	; 0x03
    8bfc:	e0 2d       	mov	r30, r0
    8bfe:	e9 83       	std	Y+1, r30	; 0x01
    8c00:	fa 83       	std	Y+2, r31	; 0x02
    8c02:	cb 01       	movw	r24, r22
    8c04:	03 96       	adiw	r24, 0x03	; 3
    8c06:	e8 17       	cp	r30, r24
    8c08:	f9 07       	cpc	r31, r25
    8c0a:	21 f4       	brne	.+8      	; 0x8c14 <prvListTaskWithinSingleList+0x44>
    8c0c:	82 81       	ldd	r24, Z+2	; 0x02
    8c0e:	93 81       	ldd	r25, Z+3	; 0x03
    8c10:	89 83       	std	Y+1, r24	; 0x01
    8c12:	9a 83       	std	Y+2, r25	; 0x02
    8c14:	e9 81       	ldd	r30, Y+1	; 0x01
    8c16:	fa 81       	ldd	r31, Y+2	; 0x02
    8c18:	a6 80       	ldd	r10, Z+6	; 0x06
    8c1a:	b7 80       	ldd	r11, Z+7	; 0x07
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    8c1c:	23 e0       	ldi	r18, 0x03	; 3
    8c1e:	e2 2e       	mov	r14, r18
    8c20:	f1 2c       	mov	r15, r1
    8c22:	ec 0e       	add	r14, r28
    8c24:	fd 1e       	adc	r15, r29
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    8c26:	99 e9       	ldi	r25, 0x99	; 153
    8c28:	c9 2e       	mov	r12, r25
    8c2a:	95 e2       	ldi	r25, 0x25	; 37
    8c2c:	d9 2e       	mov	r13, r25
    8c2e:	89 e2       	ldi	r24, 0x29	; 41
    8c30:	88 2e       	mov	r8, r24
    8c32:	85 e2       	ldi	r24, 0x25	; 37
    8c34:	98 2e       	mov	r9, r24
    8c36:	64 2e       	mov	r6, r20
    8c38:	77 24       	eor	r7, r7
    8c3a:	67 fc       	sbrc	r6, 7
    8c3c:	70 94       	com	r7

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    8c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    8c40:	fa 81       	ldd	r31, Y+2	; 0x02
    8c42:	82 81       	ldd	r24, Z+2	; 0x02
    8c44:	93 81       	ldd	r25, Z+3	; 0x03
    8c46:	89 83       	std	Y+1, r24	; 0x01
    8c48:	9a 83       	std	Y+2, r25	; 0x02
    8c4a:	8e 15       	cp	r24, r14
    8c4c:	9f 05       	cpc	r25, r15
    8c4e:	39 f4       	brne	.+14     	; 0x8c5e <prvListTaskWithinSingleList+0x8e>
    8c50:	d7 01       	movw	r26, r14
    8c52:	12 96       	adiw	r26, 0x02	; 2
    8c54:	8d 91       	ld	r24, X+
    8c56:	9c 91       	ld	r25, X
    8c58:	13 97       	sbiw	r26, 0x03	; 3
    8c5a:	89 83       	std	Y+1, r24	; 0x01
    8c5c:	9a 83       	std	Y+2, r25	; 0x02
    8c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    8c60:	fa 81       	ldd	r31, Y+2	; 0x02
    8c62:	06 81       	ldd	r16, Z+6	; 0x06
    8c64:	17 81       	ldd	r17, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
    8c66:	d8 01       	movw	r26, r16
    8c68:	57 96       	adiw	r26, 0x17	; 23
    8c6a:	ed 91       	ld	r30, X+
    8c6c:	fc 91       	ld	r31, X
    8c6e:	58 97       	sbiw	r26, 0x18	; 24

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;
    8c70:	80 e0       	ldi	r24, 0x00	; 0
    8c72:	90 e0       	ldi	r25, 0x00	; 0
    8c74:	01 c0       	rjmp	.+2      	; 0x8c78 <prvListTaskWithinSingleList+0xa8>

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    8c76:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    8c78:	21 91       	ld	r18, Z+
    8c7a:	25 3a       	cpi	r18, 0xA5	; 165
    8c7c:	e1 f3       	breq	.-8      	; 0x8c76 <prvListTaskWithinSingleList+0xa6>
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    8c7e:	98 01       	movw	r18, r16
    8c80:	27 5e       	subi	r18, 0xE7	; 231
    8c82:	3f 4f       	sbci	r19, 0xFF	; 255
    8c84:	f8 01       	movw	r30, r16
    8c86:	56 89       	ldd	r21, Z+22	; 0x16
    8c88:	43 a1       	ldd	r20, Z+35	; 0x23
    8c8a:	6d b7       	in	r22, 0x3d	; 61
    8c8c:	7e b7       	in	r23, 0x3e	; 62
    8c8e:	6e 50       	subi	r22, 0x0E	; 14
    8c90:	70 40       	sbci	r23, 0x00	; 0
    8c92:	6d bf       	out	0x3d, r22	; 61
    8c94:	7e bf       	out	0x3e, r23	; 62
    8c96:	ed b7       	in	r30, 0x3d	; 61
    8c98:	fe b7       	in	r31, 0x3e	; 62
    8c9a:	31 96       	adiw	r30, 0x01	; 1
    8c9c:	ad b7       	in	r26, 0x3d	; 61
    8c9e:	be b7       	in	r27, 0x3e	; 62
    8ca0:	11 96       	adiw	r26, 0x01	; 1
    8ca2:	cd 92       	st	X+, r12
    8ca4:	dc 92       	st	X, r13
    8ca6:	12 97       	sbiw	r26, 0x02	; 2
    8ca8:	82 82       	std	Z+2, r8	; 0x02
    8caa:	93 82       	std	Z+3, r9	; 0x03
    8cac:	24 83       	std	Z+4, r18	; 0x04
    8cae:	35 83       	std	Z+5, r19	; 0x05
    8cb0:	66 82       	std	Z+6, r6	; 0x06
    8cb2:	77 82       	std	Z+7, r7	; 0x07
    8cb4:	50 87       	std	Z+8, r21	; 0x08
    8cb6:	11 86       	std	Z+9, r1	; 0x09
    8cb8:	82 87       	std	Z+10, r24	; 0x0a
    8cba:	93 87       	std	Z+11, r25	; 0x0b
    8cbc:	44 87       	std	Z+12, r20	; 0x0c
    8cbe:	15 86       	std	Z+13, r1	; 0x0d
    8cc0:	0e 94 3d 58 	call	0xb07a	; 0xb07a <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
    8cc4:	ed b7       	in	r30, 0x3d	; 61
    8cc6:	fe b7       	in	r31, 0x3e	; 62
    8cc8:	3e 96       	adiw	r30, 0x0e	; 14
    8cca:	ed bf       	out	0x3d, r30	; 61
    8ccc:	fe bf       	out	0x3e, r31	; 62
    8cce:	c2 01       	movw	r24, r4
    8cd0:	b6 01       	movw	r22, r12
    8cd2:	0e 94 25 57 	call	0xae4a	; 0xae4a <strcat>

		} while( pxNextTCB != pxFirstTCB );
    8cd6:	0a 15       	cp	r16, r10
    8cd8:	1b 05       	cpc	r17, r11
    8cda:	09 f0       	breq	.+2      	; 0x8cde <prvListTaskWithinSingleList+0x10e>
    8cdc:	b0 cf       	rjmp	.-160    	; 0x8c3e <prvListTaskWithinSingleList+0x6e>
	}
    8cde:	df 91       	pop	r29
    8ce0:	cf 91       	pop	r28
    8ce2:	1f 91       	pop	r17
    8ce4:	0f 91       	pop	r16
    8ce6:	ff 90       	pop	r15
    8ce8:	ef 90       	pop	r14
    8cea:	df 90       	pop	r13
    8cec:	cf 90       	pop	r12
    8cee:	bf 90       	pop	r11
    8cf0:	af 90       	pop	r10
    8cf2:	9f 90       	pop	r9
    8cf4:	8f 90       	pop	r8
    8cf6:	7f 90       	pop	r7
    8cf8:	6f 90       	pop	r6
    8cfa:	5f 90       	pop	r5
    8cfc:	4f 90       	pop	r4
    8cfe:	08 95       	ret

00008d00 <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    8d00:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
    8d04:	fd cf       	rjmp	.-6      	; 0x8d00 <prvIdleTask>

00008d06 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    8d06:	2f 92       	push	r2
    8d08:	3f 92       	push	r3
    8d0a:	4f 92       	push	r4
    8d0c:	5f 92       	push	r5
    8d0e:	6f 92       	push	r6
    8d10:	7f 92       	push	r7
    8d12:	8f 92       	push	r8
    8d14:	9f 92       	push	r9
    8d16:	af 92       	push	r10
    8d18:	bf 92       	push	r11
    8d1a:	cf 92       	push	r12
    8d1c:	df 92       	push	r13
    8d1e:	ef 92       	push	r14
    8d20:	ff 92       	push	r15
    8d22:	0f 93       	push	r16
    8d24:	1f 93       	push	r17
    8d26:	cf 93       	push	r28
    8d28:	df 93       	push	r29
    8d2a:	1c 01       	movw	r2, r24
    8d2c:	3b 01       	movw	r6, r22
    8d2e:	5a 01       	movw	r10, r20
    8d30:	29 01       	movw	r4, r18
    8d32:	47 01       	movw	r8, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    8d34:	84 e2       	ldi	r24, 0x24	; 36
    8d36:	90 e0       	ldi	r25, 0x00	; 0
    8d38:	0e 94 b0 52 	call	0xa560	; 0xa560 <pvPortMalloc>
    8d3c:	e8 2e       	mov	r14, r24
    8d3e:	e7 01       	movw	r28, r14
    8d40:	7e 01       	movw	r14, r28
    8d42:	f9 2e       	mov	r15, r25
    8d44:	e7 01       	movw	r28, r14

	if( pxNewTCB != NULL )
    8d46:	20 97       	sbiw	r28, 0x00	; 0
    8d48:	09 f4       	brne	.+2      	; 0x8d4c <xTaskGenericCreate+0x46>
    8d4a:	c9 c0       	rjmp	.+402    	; 0x8ede <xTaskGenericCreate+0x1d8>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    8d4c:	c1 14       	cp	r12, r1
    8d4e:	d1 04       	cpc	r13, r1
    8d50:	29 f4       	brne	.+10     	; 0x8d5c <xTaskGenericCreate+0x56>
    8d52:	c5 01       	movw	r24, r10
    8d54:	0e 94 b0 52 	call	0xa560	; 0xa560 <pvPortMalloc>
    8d58:	c8 2e       	mov	r12, r24
    8d5a:	d9 2e       	mov	r13, r25
    8d5c:	cf 8a       	std	Y+23, r12	; 0x17
    8d5e:	d8 8e       	std	Y+24, r13	; 0x18

		if( pxNewTCB->pxStack == NULL )
    8d60:	c1 14       	cp	r12, r1
    8d62:	d1 04       	cpc	r13, r1
    8d64:	21 f4       	brne	.+8      	; 0x8d6e <xTaskGenericCreate+0x68>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    8d66:	ce 01       	movw	r24, r28
    8d68:	0e 94 d9 52 	call	0xa5b2	; 0xa5b2 <vPortFree>
    8d6c:	b8 c0       	rjmp	.+368    	; 0x8ede <xTaskGenericCreate+0x1d8>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    8d6e:	c6 01       	movw	r24, r12
    8d70:	65 ea       	ldi	r22, 0xA5	; 165
    8d72:	70 e0       	ldi	r23, 0x00	; 0
    8d74:	a5 01       	movw	r20, r10
    8d76:	0e 94 1e 57 	call	0xae3c	; 0xae3c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    8d7a:	08 94       	sec
    8d7c:	a1 08       	sbc	r10, r1
    8d7e:	b1 08       	sbc	r11, r1
    8d80:	ef 88       	ldd	r14, Y+23	; 0x17
    8d82:	f8 8c       	ldd	r15, Y+24	; 0x18
    8d84:	ea 0c       	add	r14, r10
    8d86:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    8d88:	ce 01       	movw	r24, r28
    8d8a:	49 96       	adiw	r24, 0x19	; 25
    8d8c:	b3 01       	movw	r22, r6
    8d8e:	4a e0       	ldi	r20, 0x0A	; 10
    8d90:	50 e0       	ldi	r21, 0x00	; 0
    8d92:	0e 94 45 57 	call	0xae8a	; 0xae8a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    8d96:	1a a2       	std	Y+34, r1	; 0x22
    8d98:	10 2f       	mov	r17, r16
    8d9a:	03 30       	cpi	r16, 0x03	; 3
    8d9c:	08 f0       	brcs	.+2      	; 0x8da0 <xTaskGenericCreate+0x9a>
    8d9e:	12 e0       	ldi	r17, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    8da0:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    8da2:	72 e0       	ldi	r23, 0x02	; 2
    8da4:	a7 2e       	mov	r10, r23
    8da6:	b1 2c       	mov	r11, r1
    8da8:	ac 0e       	add	r10, r28
    8daa:	bd 1e       	adc	r11, r29
    8dac:	c5 01       	movw	r24, r10
    8dae:	0e 94 53 50 	call	0xa0a6	; 0xa0a6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    8db2:	ce 01       	movw	r24, r28
    8db4:	0c 96       	adiw	r24, 0x0c	; 12
    8db6:	0e 94 53 50 	call	0xa0a6	; 0xa0a6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    8dba:	c8 87       	std	Y+8, r28	; 0x08
    8dbc:	d9 87       	std	Y+9, r29	; 0x09

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    8dbe:	83 e0       	ldi	r24, 0x03	; 3
    8dc0:	90 e0       	ldi	r25, 0x00	; 0
    8dc2:	81 1b       	sub	r24, r17
    8dc4:	91 09       	sbc	r25, r1
    8dc6:	8c 87       	std	Y+12, r24	; 0x0c
    8dc8:	9d 87       	std	Y+13, r25	; 0x0d
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    8dca:	ca 8b       	std	Y+18, r28	; 0x12
    8dcc:	db 8b       	std	Y+19, r29	; 0x13
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    8dce:	c7 01       	movw	r24, r14
    8dd0:	b1 01       	movw	r22, r2
    8dd2:	a2 01       	movw	r20, r4
    8dd4:	0e 94 e9 52 	call	0xa5d2	; 0xa5d2 <pxPortInitialiseStack>
    8dd8:	88 83       	st	Y, r24
    8dda:	99 83       	std	Y+1, r25	; 0x01
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    8ddc:	0f b6       	in	r0, 0x3f	; 63
    8dde:	f8 94       	cli
    8de0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    8de2:	80 91 cb 25 	lds	r24, 0x25CB
    8de6:	8f 5f       	subi	r24, 0xFF	; 255
    8de8:	80 93 cb 25 	sts	0x25CB, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    8dec:	80 91 cb 25 	lds	r24, 0x25CB
    8df0:	81 30       	cpi	r24, 0x01	; 1
    8df2:	79 f5       	brne	.+94     	; 0x8e52 <xTaskGenericCreate+0x14c>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    8df4:	c0 93 57 25 	sts	0x2557, r28
    8df8:	d0 93 58 25 	sts	0x2558, r29
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    8dfc:	8f e5       	ldi	r24, 0x5F	; 95
    8dfe:	95 e2       	ldi	r25, 0x25	; 37
    8e00:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
    8e04:	88 e6       	ldi	r24, 0x68	; 104
    8e06:	95 e2       	ldi	r25, 0x25	; 37
    8e08:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
    8e0c:	81 e7       	ldi	r24, 0x71	; 113
    8e0e:	95 e2       	ldi	r25, 0x25	; 37
    8e10:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    8e14:	6e ec       	ldi	r22, 0xCE	; 206
    8e16:	e6 2e       	mov	r14, r22
    8e18:	65 e2       	ldi	r22, 0x25	; 37
    8e1a:	f6 2e       	mov	r15, r22
    8e1c:	c7 01       	movw	r24, r14
    8e1e:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    8e22:	57 ed       	ldi	r21, 0xD7	; 215
    8e24:	c5 2e       	mov	r12, r21
    8e26:	55 e2       	ldi	r21, 0x25	; 37
    8e28:	d5 2e       	mov	r13, r21
    8e2a:	c6 01       	movw	r24, r12
    8e2c:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    8e30:	8a e7       	ldi	r24, 0x7A	; 122
    8e32:	95 e2       	ldi	r25, 0x25	; 37
    8e34:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    8e38:	83 e8       	ldi	r24, 0x83	; 131
    8e3a:	95 e2       	ldi	r25, 0x25	; 37
    8e3c:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    8e40:	e0 92 8e 25 	sts	0x258E, r14
    8e44:	f0 92 8f 25 	sts	0x258F, r15
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    8e48:	c0 92 8c 25 	sts	0x258C, r12
    8e4c:	d0 92 8d 25 	sts	0x258D, r13
    8e50:	0f c0       	rjmp	.+30     	; 0x8e70 <xTaskGenericCreate+0x16a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    8e52:	80 91 cc 25 	lds	r24, 0x25CC
    8e56:	88 23       	and	r24, r24
    8e58:	59 f4       	brne	.+22     	; 0x8e70 <xTaskGenericCreate+0x16a>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    8e5a:	e0 91 57 25 	lds	r30, 0x2557
    8e5e:	f0 91 58 25 	lds	r31, 0x2558
    8e62:	86 89       	ldd	r24, Z+22	; 0x16
    8e64:	08 17       	cp	r16, r24
    8e66:	20 f0       	brcs	.+8      	; 0x8e70 <xTaskGenericCreate+0x16a>
					{
						pxCurrentTCB = pxNewTCB;
    8e68:	c0 93 57 25 	sts	0x2557, r28
    8e6c:	d0 93 58 25 	sts	0x2558, r29
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    8e70:	2e 89       	ldd	r18, Y+22	; 0x16
    8e72:	80 91 98 25 	lds	r24, 0x2598
    8e76:	82 17       	cp	r24, r18
    8e78:	10 f4       	brcc	.+4      	; 0x8e7e <xTaskGenericCreate+0x178>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    8e7a:	20 93 98 25 	sts	0x2598, r18
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    8e7e:	80 91 cd 25 	lds	r24, 0x25CD
    8e82:	8b a3       	std	Y+35, r24	; 0x23
			}
			#endif
			uxTaskNumber++;
    8e84:	8f 5f       	subi	r24, 0xFF	; 255
    8e86:	80 93 cd 25 	sts	0x25CD, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    8e8a:	80 91 5e 25 	lds	r24, 0x255E
    8e8e:	82 17       	cp	r24, r18
    8e90:	10 f4       	brcc	.+4      	; 0x8e96 <xTaskGenericCreate+0x190>
    8e92:	20 93 5e 25 	sts	0x255E, r18
    8e96:	30 e0       	ldi	r19, 0x00	; 0
    8e98:	c9 01       	movw	r24, r18
    8e9a:	43 e0       	ldi	r20, 0x03	; 3
    8e9c:	88 0f       	add	r24, r24
    8e9e:	99 1f       	adc	r25, r25
    8ea0:	4a 95       	dec	r20
    8ea2:	e1 f7       	brne	.-8      	; 0x8e9c <xTaskGenericCreate+0x196>
    8ea4:	82 0f       	add	r24, r18
    8ea6:	93 1f       	adc	r25, r19
    8ea8:	81 5a       	subi	r24, 0xA1	; 161
    8eaa:	9a 4d       	sbci	r25, 0xDA	; 218
    8eac:	b5 01       	movw	r22, r10
    8eae:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    8eb2:	0f 90       	pop	r0
    8eb4:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    8eb6:	81 14       	cp	r8, r1
    8eb8:	91 04       	cpc	r9, r1
    8eba:	19 f0       	breq	.+6      	; 0x8ec2 <xTaskGenericCreate+0x1bc>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    8ebc:	f4 01       	movw	r30, r8
    8ebe:	c0 83       	st	Z, r28
    8ec0:	d1 83       	std	Z+1, r29	; 0x01
		}

		if( xSchedulerRunning != pdFALSE )
    8ec2:	80 91 cc 25 	lds	r24, 0x25CC
    8ec6:	88 23       	and	r24, r24
    8ec8:	61 f0       	breq	.+24     	; 0x8ee2 <xTaskGenericCreate+0x1dc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    8eca:	e0 91 57 25 	lds	r30, 0x2557
    8ece:	f0 91 58 25 	lds	r31, 0x2558
    8ed2:	86 89       	ldd	r24, Z+22	; 0x16
    8ed4:	80 17       	cp	r24, r16
    8ed6:	28 f4       	brcc	.+10     	; 0x8ee2 <xTaskGenericCreate+0x1dc>
			{
				portYIELD_WITHIN_API();
    8ed8:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
    8edc:	02 c0       	rjmp	.+4      	; 0x8ee2 <xTaskGenericCreate+0x1dc>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    8ede:	8f ef       	ldi	r24, 0xFF	; 255
    8ee0:	01 c0       	rjmp	.+2      	; 0x8ee4 <xTaskGenericCreate+0x1de>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    8ee2:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    8ee4:	df 91       	pop	r29
    8ee6:	cf 91       	pop	r28
    8ee8:	1f 91       	pop	r17
    8eea:	0f 91       	pop	r16
    8eec:	ff 90       	pop	r15
    8eee:	ef 90       	pop	r14
    8ef0:	df 90       	pop	r13
    8ef2:	cf 90       	pop	r12
    8ef4:	bf 90       	pop	r11
    8ef6:	af 90       	pop	r10
    8ef8:	9f 90       	pop	r9
    8efa:	8f 90       	pop	r8
    8efc:	7f 90       	pop	r7
    8efe:	6f 90       	pop	r6
    8f00:	5f 90       	pop	r5
    8f02:	4f 90       	pop	r4
    8f04:	3f 90       	pop	r3
    8f06:	2f 90       	pop	r2
    8f08:	08 95       	ret

00008f0a <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		portENTER_CRITICAL();
    8f0a:	0f b6       	in	r0, 0x3f	; 63
    8f0c:	f8 94       	cli
    8f0e:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8f10:	00 97       	sbiw	r24, 0x00	; 0
    8f12:	29 f4       	brne	.+10     	; 0x8f1e <uxTaskPriorityGet+0x14>
    8f14:	e0 91 57 25 	lds	r30, 0x2557
    8f18:	f0 91 58 25 	lds	r31, 0x2558
    8f1c:	01 c0       	rjmp	.+2      	; 0x8f20 <uxTaskPriorityGet+0x16>
    8f1e:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portEXIT_CRITICAL();
    8f20:	0f 90       	pop	r0
    8f22:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    8f24:	86 89       	ldd	r24, Z+22	; 0x16
    8f26:	08 95       	ret

00008f28 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    8f28:	ef 92       	push	r14
    8f2a:	ff 92       	push	r15
    8f2c:	0f 93       	push	r16
    8f2e:	1f 93       	push	r17
    8f30:	df 93       	push	r29
    8f32:	cf 93       	push	r28
    8f34:	0f 92       	push	r0
    8f36:	cd b7       	in	r28, 0x3d	; 61
    8f38:	de b7       	in	r29, 0x3e	; 62
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8f3a:	63 30       	cpi	r22, 0x03	; 3
    8f3c:	08 f0       	brcs	.+2      	; 0x8f40 <vTaskPrioritySet+0x18>
    8f3e:	62 e0       	ldi	r22, 0x02	; 2
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		portENTER_CRITICAL();
    8f40:	0f b6       	in	r0, 0x3f	; 63
    8f42:	f8 94       	cli
    8f44:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    8f46:	20 91 57 25 	lds	r18, 0x2557
    8f4a:	30 91 58 25 	lds	r19, 0x2558
    8f4e:	82 17       	cp	r24, r18
    8f50:	93 07       	cpc	r25, r19
    8f52:	11 f0       	breq	.+4      	; 0x8f58 <vTaskPrioritySet+0x30>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8f54:	00 97       	sbiw	r24, 0x00	; 0
    8f56:	39 f4       	brne	.+14     	; 0x8f66 <vTaskPrioritySet+0x3e>
    8f58:	e0 90 57 25 	lds	r14, 0x2557
    8f5c:	f0 90 58 25 	lds	r15, 0x2558
    8f60:	80 e0       	ldi	r24, 0x00	; 0
    8f62:	90 e0       	ldi	r25, 0x00	; 0
    8f64:	01 c0       	rjmp	.+2      	; 0x8f68 <vTaskPrioritySet+0x40>
    8f66:	7c 01       	movw	r14, r24
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    8f68:	f7 01       	movw	r30, r14
    8f6a:	36 89       	ldd	r19, Z+22	; 0x16
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    8f6c:	36 17       	cp	r19, r22
    8f6e:	09 f4       	brne	.+2      	; 0x8f72 <vTaskPrioritySet+0x4a>
    8f70:	41 c0       	rjmp	.+130    	; 0x8ff4 <vTaskPrioritySet+0xcc>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    8f72:	36 17       	cp	r19, r22
    8f74:	20 f4       	brcc	.+8      	; 0x8f7e <vTaskPrioritySet+0x56>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    8f76:	21 e0       	ldi	r18, 0x01	; 1
    8f78:	00 97       	sbiw	r24, 0x00	; 0
    8f7a:	29 f4       	brne	.+10     	; 0x8f86 <vTaskPrioritySet+0x5e>
    8f7c:	03 c0       	rjmp	.+6      	; 0x8f84 <vTaskPrioritySet+0x5c>
    8f7e:	21 e0       	ldi	r18, 0x01	; 1
    8f80:	00 97       	sbiw	r24, 0x00	; 0
    8f82:	09 f0       	breq	.+2      	; 0x8f86 <vTaskPrioritySet+0x5e>
    8f84:	20 e0       	ldi	r18, 0x00	; 0
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    8f86:	f7 01       	movw	r30, r14
    8f88:	66 8b       	std	Z+22, r22	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    8f8a:	43 e0       	ldi	r20, 0x03	; 3
    8f8c:	50 e0       	ldi	r21, 0x00	; 0
    8f8e:	46 1b       	sub	r20, r22
    8f90:	51 09       	sbc	r21, r1
    8f92:	44 87       	std	Z+12, r20	; 0x0c
    8f94:	55 87       	std	Z+13, r21	; 0x0d

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    8f96:	89 e0       	ldi	r24, 0x09	; 9
    8f98:	38 9f       	mul	r19, r24
    8f9a:	c0 01       	movw	r24, r0
    8f9c:	11 24       	eor	r1, r1
    8f9e:	81 5a       	subi	r24, 0xA1	; 161
    8fa0:	9a 4d       	sbci	r25, 0xDA	; 218
    8fa2:	42 85       	ldd	r20, Z+10	; 0x0a
    8fa4:	53 85       	ldd	r21, Z+11	; 0x0b
    8fa6:	48 17       	cp	r20, r24
    8fa8:	59 07       	cpc	r21, r25
    8faa:	01 f5       	brne	.+64     	; 0x8fec <vTaskPrioritySet+0xc4>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    8fac:	87 01       	movw	r16, r14
    8fae:	0e 5f       	subi	r16, 0xFE	; 254
    8fb0:	1f 4f       	sbci	r17, 0xFF	; 255
    8fb2:	c8 01       	movw	r24, r16
    8fb4:	29 83       	std	Y+1, r18	; 0x01
    8fb6:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    8fba:	f7 01       	movw	r30, r14
    8fbc:	46 89       	ldd	r20, Z+22	; 0x16
    8fbe:	80 91 5e 25 	lds	r24, 0x255E
    8fc2:	29 81       	ldd	r18, Y+1	; 0x01
    8fc4:	84 17       	cp	r24, r20
    8fc6:	10 f4       	brcc	.+4      	; 0x8fcc <vTaskPrioritySet+0xa4>
    8fc8:	40 93 5e 25 	sts	0x255E, r20
    8fcc:	50 e0       	ldi	r21, 0x00	; 0
    8fce:	ca 01       	movw	r24, r20
    8fd0:	e3 e0       	ldi	r30, 0x03	; 3
    8fd2:	88 0f       	add	r24, r24
    8fd4:	99 1f       	adc	r25, r25
    8fd6:	ea 95       	dec	r30
    8fd8:	e1 f7       	brne	.-8      	; 0x8fd2 <vTaskPrioritySet+0xaa>
    8fda:	84 0f       	add	r24, r20
    8fdc:	95 1f       	adc	r25, r21
    8fde:	81 5a       	subi	r24, 0xA1	; 161
    8fe0:	9a 4d       	sbci	r25, 0xDA	; 218
    8fe2:	b8 01       	movw	r22, r16
    8fe4:	29 83       	std	Y+1, r18	; 0x01
    8fe6:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
    8fea:	29 81       	ldd	r18, Y+1	; 0x01
				}

				if( xYieldRequired == pdTRUE )
    8fec:	21 30       	cpi	r18, 0x01	; 1
    8fee:	11 f4       	brne	.+4      	; 0x8ff4 <vTaskPrioritySet+0xcc>
				{
					portYIELD_WITHIN_API();
    8ff0:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
				}
			}
		}
		portEXIT_CRITICAL();
    8ff4:	0f 90       	pop	r0
    8ff6:	0f be       	out	0x3f, r0	; 63
	}
    8ff8:	0f 90       	pop	r0
    8ffa:	cf 91       	pop	r28
    8ffc:	df 91       	pop	r29
    8ffe:	1f 91       	pop	r17
    9000:	0f 91       	pop	r16
    9002:	ff 90       	pop	r15
    9004:	ef 90       	pop	r14
    9006:	08 95       	ret

00009008 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    9008:	ef 92       	push	r14
    900a:	ff 92       	push	r15
    900c:	0f 93       	push	r16
    900e:	1f 93       	push	r17
    9010:	cf 93       	push	r28
    9012:	df 93       	push	r29
    9014:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    9016:	0f b6       	in	r0, 0x3f	; 63
    9018:	f8 94       	cli
    901a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    901c:	80 91 57 25 	lds	r24, 0x2557
    9020:	90 91 58 25 	lds	r25, 0x2558
    9024:	c8 17       	cp	r28, r24
    9026:	d9 07       	cpc	r29, r25
    9028:	11 f0       	breq	.+4      	; 0x902e <vTaskSuspend+0x26>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    902a:	20 97       	sbiw	r28, 0x00	; 0
    902c:	39 f4       	brne	.+14     	; 0x903c <vTaskSuspend+0x34>
    902e:	00 91 57 25 	lds	r16, 0x2557
    9032:	10 91 58 25 	lds	r17, 0x2558
    9036:	c0 e0       	ldi	r28, 0x00	; 0
    9038:	d0 e0       	ldi	r29, 0x00	; 0
    903a:	01 c0       	rjmp	.+2      	; 0x903e <vTaskSuspend+0x36>
    903c:	8e 01       	movw	r16, r28

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    903e:	f2 e0       	ldi	r31, 0x02	; 2
    9040:	ef 2e       	mov	r14, r31
    9042:	f1 2c       	mov	r15, r1
    9044:	e0 0e       	add	r14, r16
    9046:	f1 1e       	adc	r15, r17
    9048:	c7 01       	movw	r24, r14
    904a:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    904e:	f8 01       	movw	r30, r16
    9050:	84 89       	ldd	r24, Z+20	; 0x14
    9052:	95 89       	ldd	r25, Z+21	; 0x15
    9054:	00 97       	sbiw	r24, 0x00	; 0
    9056:	21 f0       	breq	.+8      	; 0x9060 <vTaskSuspend+0x58>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    9058:	c8 01       	movw	r24, r16
    905a:	0c 96       	adiw	r24, 0x0c	; 12
    905c:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    9060:	83 e8       	ldi	r24, 0x83	; 131
    9062:	95 e2       	ldi	r25, 0x25	; 37
    9064:	b7 01       	movw	r22, r14
    9066:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    906a:	0f 90       	pop	r0
    906c:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    906e:	20 97       	sbiw	r28, 0x00	; 0
    9070:	11 f4       	brne	.+4      	; 0x9076 <vTaskSuspend+0x6e>
		{
			portYIELD_WITHIN_API();
    9072:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
		}
	}
    9076:	df 91       	pop	r29
    9078:	cf 91       	pop	r28
    907a:	1f 91       	pop	r17
    907c:	0f 91       	pop	r16
    907e:	ff 90       	pop	r15
    9080:	ef 90       	pop	r14
    9082:	08 95       	ret

00009084 <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    9084:	fc 01       	movw	r30, r24

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    9086:	82 85       	ldd	r24, Z+10	; 0x0a
    9088:	93 85       	ldd	r25, Z+11	; 0x0b
    908a:	25 e2       	ldi	r18, 0x25	; 37
    908c:	83 38       	cpi	r24, 0x83	; 131
    908e:	92 07       	cpc	r25, r18
    9090:	51 f4       	brne	.+20     	; 0x90a6 <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    9092:	24 89       	ldd	r18, Z+20	; 0x14
    9094:	35 89       	ldd	r19, Z+21	; 0x15
    9096:	85 e2       	ldi	r24, 0x25	; 37
    9098:	2a 37       	cpi	r18, 0x7A	; 122
    909a:	38 07       	cpc	r19, r24
    909c:	31 f0       	breq	.+12     	; 0x90aa <xTaskIsTaskSuspended+0x26>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    909e:	81 e0       	ldi	r24, 0x01	; 1
    90a0:	21 15       	cp	r18, r1
    90a2:	31 05       	cpc	r19, r1
    90a4:	19 f0       	breq	.+6      	; 0x90ac <xTaskIsTaskSuspended+0x28>
    90a6:	80 e0       	ldi	r24, 0x00	; 0
    90a8:	08 95       	ret
    90aa:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    90ac:	08 95       	ret

000090ae <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    90ae:	ef 92       	push	r14
    90b0:	ff 92       	push	r15
    90b2:	0f 93       	push	r16
    90b4:	1f 93       	push	r17
    90b6:	cf 93       	push	r28
    90b8:	df 93       	push	r29
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    90ba:	e8 2e       	mov	r14, r24
    90bc:	e7 01       	movw	r28, r14
    90be:	7e 01       	movw	r14, r28
    90c0:	f9 2e       	mov	r15, r25
    90c2:	e7 01       	movw	r28, r14

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    90c4:	20 97       	sbiw	r28, 0x00	; 0
    90c6:	b1 f1       	breq	.+108    	; 0x9134 <vTaskResume+0x86>
    90c8:	80 91 57 25 	lds	r24, 0x2557
    90cc:	90 91 58 25 	lds	r25, 0x2558
    90d0:	e8 16       	cp	r14, r24
    90d2:	f9 06       	cpc	r15, r25
    90d4:	79 f1       	breq	.+94     	; 0x9134 <vTaskResume+0x86>
		{
			portENTER_CRITICAL();
    90d6:	0f b6       	in	r0, 0x3f	; 63
    90d8:	f8 94       	cli
    90da:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    90dc:	c7 01       	movw	r24, r14
    90de:	0e 94 42 48 	call	0x9084	; 0x9084 <xTaskIsTaskSuspended>
    90e2:	81 30       	cpi	r24, 0x01	; 1
    90e4:	29 f5       	brne	.+74     	; 0x9130 <vTaskResume+0x82>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    90e6:	87 01       	movw	r16, r14
    90e8:	0e 5f       	subi	r16, 0xFE	; 254
    90ea:	1f 4f       	sbci	r17, 0xFF	; 255
    90ec:	c8 01       	movw	r24, r16
    90ee:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    90f2:	2e 89       	ldd	r18, Y+22	; 0x16
    90f4:	80 91 5e 25 	lds	r24, 0x255E
    90f8:	82 17       	cp	r24, r18
    90fa:	10 f4       	brcc	.+4      	; 0x9100 <vTaskResume+0x52>
    90fc:	20 93 5e 25 	sts	0x255E, r18
    9100:	30 e0       	ldi	r19, 0x00	; 0
    9102:	c9 01       	movw	r24, r18
    9104:	a3 e0       	ldi	r26, 0x03	; 3
    9106:	88 0f       	add	r24, r24
    9108:	99 1f       	adc	r25, r25
    910a:	aa 95       	dec	r26
    910c:	e1 f7       	brne	.-8      	; 0x9106 <vTaskResume+0x58>
    910e:	82 0f       	add	r24, r18
    9110:	93 1f       	adc	r25, r19
    9112:	81 5a       	subi	r24, 0xA1	; 161
    9114:	9a 4d       	sbci	r25, 0xDA	; 218
    9116:	b8 01       	movw	r22, r16
    9118:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    911c:	e0 91 57 25 	lds	r30, 0x2557
    9120:	f0 91 58 25 	lds	r31, 0x2558
    9124:	9e 89       	ldd	r25, Y+22	; 0x16
    9126:	86 89       	ldd	r24, Z+22	; 0x16
    9128:	98 17       	cp	r25, r24
    912a:	10 f0       	brcs	.+4      	; 0x9130 <vTaskResume+0x82>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    912c:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    9130:	0f 90       	pop	r0
    9132:	0f be       	out	0x3f, r0	; 63
		}
	}
    9134:	df 91       	pop	r29
    9136:	cf 91       	pop	r28
    9138:	1f 91       	pop	r17
    913a:	0f 91       	pop	r16
    913c:	ff 90       	pop	r15
    913e:	ef 90       	pop	r14
    9140:	08 95       	ret

00009142 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    9142:	ef 92       	push	r14
    9144:	ff 92       	push	r15
    9146:	0f 93       	push	r16
    9148:	1f 93       	push	r17
    914a:	cf 93       	push	r28
    914c:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
    914e:	e8 2e       	mov	r14, r24
    9150:	e7 01       	movw	r28, r14
    9152:	7e 01       	movw	r14, r28
    9154:	f9 2e       	mov	r15, r25
    9156:	e7 01       	movw	r28, r14

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    9158:	c7 01       	movw	r24, r14
    915a:	0e 94 42 48 	call	0x9084	; 0x9084 <xTaskIsTaskSuspended>
    915e:	81 30       	cpi	r24, 0x01	; 1
    9160:	99 f5       	brne	.+102    	; 0x91c8 <xTaskResumeFromISR+0x86>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9162:	80 91 5d 25 	lds	r24, 0x255D
    9166:	88 23       	and	r24, r24
    9168:	41 f5       	brne	.+80     	; 0x91ba <xTaskResumeFromISR+0x78>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    916a:	e0 91 57 25 	lds	r30, 0x2557
    916e:	f0 91 58 25 	lds	r31, 0x2558
    9172:	ff 24       	eor	r15, r15
    9174:	f3 94       	inc	r15
    9176:	9e 89       	ldd	r25, Y+22	; 0x16
    9178:	86 89       	ldd	r24, Z+22	; 0x16
    917a:	98 17       	cp	r25, r24
    917c:	08 f4       	brcc	.+2      	; 0x9180 <xTaskResumeFromISR+0x3e>
    917e:	ff 24       	eor	r15, r15
				vListRemove(  &( pxTCB->xGenericListItem ) );
    9180:	8e 01       	movw	r16, r28
    9182:	0e 5f       	subi	r16, 0xFE	; 254
    9184:	1f 4f       	sbci	r17, 0xFF	; 255
    9186:	c8 01       	movw	r24, r16
    9188:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    918c:	4e 89       	ldd	r20, Y+22	; 0x16
    918e:	80 91 5e 25 	lds	r24, 0x255E
    9192:	84 17       	cp	r24, r20
    9194:	10 f4       	brcc	.+4      	; 0x919a <xTaskResumeFromISR+0x58>
    9196:	40 93 5e 25 	sts	0x255E, r20
    919a:	50 e0       	ldi	r21, 0x00	; 0
    919c:	9a 01       	movw	r18, r20
    919e:	b3 e0       	ldi	r27, 0x03	; 3
    91a0:	22 0f       	add	r18, r18
    91a2:	33 1f       	adc	r19, r19
    91a4:	ba 95       	dec	r27
    91a6:	e1 f7       	brne	.-8      	; 0x91a0 <xTaskResumeFromISR+0x5e>
    91a8:	24 0f       	add	r18, r20
    91aa:	35 1f       	adc	r19, r21
    91ac:	c9 01       	movw	r24, r18
    91ae:	81 5a       	subi	r24, 0xA1	; 161
    91b0:	9a 4d       	sbci	r25, 0xDA	; 218
    91b2:	b8 01       	movw	r22, r16
    91b4:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
    91b8:	08 c0       	rjmp	.+16     	; 0x91ca <xTaskResumeFromISR+0x88>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    91ba:	b7 01       	movw	r22, r14
    91bc:	64 5f       	subi	r22, 0xF4	; 244
    91be:	7f 4f       	sbci	r23, 0xFF	; 255
    91c0:	8a e7       	ldi	r24, 0x7A	; 122
    91c2:	95 e2       	ldi	r25, 0x25	; 37
    91c4:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    91c8:	ff 24       	eor	r15, r15
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
			}
		}

		return xYieldRequired;
	}
    91ca:	8f 2d       	mov	r24, r15
    91cc:	df 91       	pop	r29
    91ce:	cf 91       	pop	r28
    91d0:	1f 91       	pop	r17
    91d2:	0f 91       	pop	r16
    91d4:	ff 90       	pop	r15
    91d6:	ef 90       	pop	r14
    91d8:	08 95       	ret

000091da <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    91da:	af 92       	push	r10
    91dc:	bf 92       	push	r11
    91de:	cf 92       	push	r12
    91e0:	df 92       	push	r13
    91e2:	ef 92       	push	r14
    91e4:	ff 92       	push	r15
    91e6:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    91e8:	80 e8       	ldi	r24, 0x80	; 128
    91ea:	96 e4       	ldi	r25, 0x46	; 70
    91ec:	6b e3       	ldi	r22, 0x3B	; 59
    91ee:	75 e2       	ldi	r23, 0x25	; 37
    91f0:	46 e9       	ldi	r20, 0x96	; 150
    91f2:	50 e0       	ldi	r21, 0x00	; 0
    91f4:	20 e0       	ldi	r18, 0x00	; 0
    91f6:	30 e0       	ldi	r19, 0x00	; 0
    91f8:	00 e0       	ldi	r16, 0x00	; 0
    91fa:	ee 24       	eor	r14, r14
    91fc:	ff 24       	eor	r15, r15
    91fe:	cc 24       	eor	r12, r12
    9200:	dd 24       	eor	r13, r13
    9202:	aa 24       	eor	r10, r10
    9204:	bb 24       	eor	r11, r11
    9206:	0e 94 83 46 	call	0x8d06	; 0x8d06 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    920a:	81 30       	cpi	r24, 0x01	; 1
    920c:	49 f4       	brne	.+18     	; 0x9220 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    920e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    9210:	80 93 cc 25 	sts	0x25CC, r24
		xTickCount = ( portTickType ) 0;
    9214:	10 92 5b 25 	sts	0x255B, r1
    9218:	10 92 5c 25 	sts	0x255C, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    921c:	0e 94 41 53 	call	0xa682	; 0xa682 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    9220:	0f 91       	pop	r16
    9222:	ff 90       	pop	r15
    9224:	ef 90       	pop	r14
    9226:	df 90       	pop	r13
    9228:	cf 90       	pop	r12
    922a:	bf 90       	pop	r11
    922c:	af 90       	pop	r10
    922e:	08 95       	ret

00009230 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    9230:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    9232:	10 92 cc 25 	sts	0x25CC, r1
	vPortEndScheduler();
    9236:	0e 94 8b 53 	call	0xa716	; 0xa716 <vPortEndScheduler>
}
    923a:	08 95       	ret

0000923c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    923c:	80 91 5d 25 	lds	r24, 0x255D
    9240:	8f 5f       	subi	r24, 0xFF	; 255
    9242:	80 93 5d 25 	sts	0x255D, r24
}
    9246:	08 95       	ret

00009248 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    9248:	0f b6       	in	r0, 0x3f	; 63
    924a:	f8 94       	cli
    924c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    924e:	20 91 5b 25 	lds	r18, 0x255B
    9252:	30 91 5c 25 	lds	r19, 0x255C
	}
	portEXIT_CRITICAL();
    9256:	0f 90       	pop	r0
    9258:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    925a:	c9 01       	movw	r24, r18
    925c:	08 95       	ret

0000925e <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    925e:	80 91 cb 25 	lds	r24, 0x25CB
}
    9262:	08 95       	ret

00009264 <vTaskStartTrace>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
	{
		portENTER_CRITICAL();
    9264:	0f b6       	in	r0, 0x3f	; 63
    9266:	f8 94       	cli
    9268:	0f 92       	push	r0
		{
			pcTraceBuffer = ( signed char * )pcBuffer;
    926a:	80 93 91 25 	sts	0x2591, r24
    926e:	90 93 92 25 	sts	0x2592, r25
			pcTraceBufferStart = pcBuffer;
    9272:	80 93 96 25 	sts	0x2596, r24
    9276:	90 93 97 25 	sts	0x2597, r25
			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
    927a:	48 50       	subi	r20, 0x08	; 8
    927c:	50 40       	sbci	r21, 0x00	; 0
    927e:	48 0f       	add	r20, r24
    9280:	59 1f       	adc	r21, r25
    9282:	40 93 93 25 	sts	0x2593, r20
    9286:	50 93 94 25 	sts	0x2594, r21
			xTracing = pdTRUE;
    928a:	81 e0       	ldi	r24, 0x01	; 1
    928c:	80 93 90 25 	sts	0x2590, r24
		}
		portEXIT_CRITICAL();
    9290:	0f 90       	pop	r0
    9292:	0f be       	out	0x3f, r0	; 63
	}
    9294:	08 95       	ret

00009296 <ulTaskEndTrace>:

	unsigned long ulTaskEndTrace( void )
	{
	unsigned long ulBufferLength;

		portENTER_CRITICAL();
    9296:	0f b6       	in	r0, 0x3f	; 63
    9298:	f8 94       	cli
    929a:	0f 92       	push	r0
			xTracing = pdFALSE;
    929c:	10 92 90 25 	sts	0x2590, r1
		portEXIT_CRITICAL();
    92a0:	0f 90       	pop	r0
    92a2:	0f be       	out	0x3f, r0	; 63

		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
    92a4:	20 91 91 25 	lds	r18, 0x2591
    92a8:	30 91 92 25 	lds	r19, 0x2592
    92ac:	80 91 96 25 	lds	r24, 0x2596
    92b0:	90 91 97 25 	lds	r25, 0x2597
    92b4:	28 1b       	sub	r18, r24
    92b6:	39 0b       	sbc	r19, r25
    92b8:	44 27       	eor	r20, r20
    92ba:	37 fd       	sbrc	r19, 7
    92bc:	40 95       	com	r20
    92be:	54 2f       	mov	r21, r20

		return ulBufferLength;
	}
    92c0:	b9 01       	movw	r22, r18
    92c2:	ca 01       	movw	r24, r20
    92c4:	08 95       	ret

000092c6 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    92c6:	0f 93       	push	r16
    92c8:	1f 93       	push	r17
    92ca:	cf 93       	push	r28
    92cc:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    92ce:	80 91 5d 25 	lds	r24, 0x255D
    92d2:	88 23       	and	r24, r24
    92d4:	09 f0       	breq	.+2      	; 0x92d8 <vTaskIncrementTick+0x12>
    92d6:	65 c0       	rjmp	.+202    	; 0x93a2 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
    92d8:	80 91 5b 25 	lds	r24, 0x255B
    92dc:	90 91 5c 25 	lds	r25, 0x255C
    92e0:	01 96       	adiw	r24, 0x01	; 1
    92e2:	80 93 5b 25 	sts	0x255B, r24
    92e6:	90 93 5c 25 	sts	0x255C, r25
		if( xTickCount == ( portTickType ) 0 )
    92ea:	80 91 5b 25 	lds	r24, 0x255B
    92ee:	90 91 5c 25 	lds	r25, 0x255C
    92f2:	00 97       	sbiw	r24, 0x00	; 0
    92f4:	09 f0       	breq	.+2      	; 0x92f8 <vTaskIncrementTick+0x32>
    92f6:	42 c0       	rjmp	.+132    	; 0x937c <vTaskIncrementTick+0xb6>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    92f8:	80 91 8e 25 	lds	r24, 0x258E
    92fc:	90 91 8f 25 	lds	r25, 0x258F
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    9300:	20 91 8c 25 	lds	r18, 0x258C
    9304:	30 91 8d 25 	lds	r19, 0x258D
    9308:	20 93 8e 25 	sts	0x258E, r18
    930c:	30 93 8f 25 	sts	0x258F, r19
			pxOverflowDelayedTaskList = pxTemp;
    9310:	80 93 8c 25 	sts	0x258C, r24
    9314:	90 93 8d 25 	sts	0x258D, r25
			xNumOfOverflows++;
    9318:	80 91 5a 25 	lds	r24, 0x255A
    931c:	8f 5f       	subi	r24, 0xFF	; 255
    931e:	80 93 5a 25 	sts	0x255A, r24
    9322:	2c c0       	rjmp	.+88     	; 0x937c <vTaskIncrementTick+0xb6>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    9324:	20 91 5b 25 	lds	r18, 0x255B
    9328:	30 91 5c 25 	lds	r19, 0x255C
    932c:	8a 81       	ldd	r24, Y+2	; 0x02
    932e:	9b 81       	ldd	r25, Y+3	; 0x03
    9330:	28 17       	cp	r18, r24
    9332:	39 07       	cpc	r19, r25
    9334:	d8 f1       	brcs	.+118    	; 0x93ac <vTaskIncrementTick+0xe6>
    9336:	8e 01       	movw	r16, r28
    9338:	0e 5f       	subi	r16, 0xFE	; 254
    933a:	1f 4f       	sbci	r17, 0xFF	; 255
    933c:	c8 01       	movw	r24, r16
    933e:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
    9342:	8c 89       	ldd	r24, Y+20	; 0x14
    9344:	9d 89       	ldd	r25, Y+21	; 0x15
    9346:	00 97       	sbiw	r24, 0x00	; 0
    9348:	21 f0       	breq	.+8      	; 0x9352 <vTaskIncrementTick+0x8c>
    934a:	ce 01       	movw	r24, r28
    934c:	0c 96       	adiw	r24, 0x0c	; 12
    934e:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
    9352:	2e 89       	ldd	r18, Y+22	; 0x16
    9354:	80 91 5e 25 	lds	r24, 0x255E
    9358:	82 17       	cp	r24, r18
    935a:	10 f4       	brcc	.+4      	; 0x9360 <vTaskIncrementTick+0x9a>
    935c:	20 93 5e 25 	sts	0x255E, r18
    9360:	30 e0       	ldi	r19, 0x00	; 0
    9362:	c9 01       	movw	r24, r18
    9364:	43 e0       	ldi	r20, 0x03	; 3
    9366:	88 0f       	add	r24, r24
    9368:	99 1f       	adc	r25, r25
    936a:	4a 95       	dec	r20
    936c:	e1 f7       	brne	.-8      	; 0x9366 <vTaskIncrementTick+0xa0>
    936e:	82 0f       	add	r24, r18
    9370:	93 1f       	adc	r25, r19
    9372:	81 5a       	subi	r24, 0xA1	; 161
    9374:	9a 4d       	sbci	r25, 0xDA	; 218
    9376:	b8 01       	movw	r22, r16
    9378:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
    937c:	e0 91 8e 25 	lds	r30, 0x258E
    9380:	f0 91 8f 25 	lds	r31, 0x258F
    9384:	80 81       	ld	r24, Z
    9386:	88 23       	and	r24, r24
    9388:	89 f0       	breq	.+34     	; 0x93ac <vTaskIncrementTick+0xe6>
    938a:	e0 91 8e 25 	lds	r30, 0x258E
    938e:	f0 91 8f 25 	lds	r31, 0x258F
    9392:	05 80       	ldd	r0, Z+5	; 0x05
    9394:	f6 81       	ldd	r31, Z+6	; 0x06
    9396:	e0 2d       	mov	r30, r0
    9398:	c6 81       	ldd	r28, Z+6	; 0x06
    939a:	d7 81       	ldd	r29, Z+7	; 0x07
    939c:	20 97       	sbiw	r28, 0x00	; 0
    939e:	11 f6       	brne	.-124    	; 0x9324 <vTaskIncrementTick+0x5e>
    93a0:	05 c0       	rjmp	.+10     	; 0x93ac <vTaskIncrementTick+0xe6>
	}
	else
	{
		++uxMissedTicks;
    93a2:	80 91 95 25 	lds	r24, 0x2595
    93a6:	8f 5f       	subi	r24, 0xFF	; 255
    93a8:	80 93 95 25 	sts	0x2595, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    93ac:	df 91       	pop	r29
    93ae:	cf 91       	pop	r28
    93b0:	1f 91       	pop	r17
    93b2:	0f 91       	pop	r16
    93b4:	08 95       	ret

000093b6 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    93b6:	ef 92       	push	r14
    93b8:	ff 92       	push	r15
    93ba:	0f 93       	push	r16
    93bc:	1f 93       	push	r17
    93be:	df 93       	push	r29
    93c0:	cf 93       	push	r28
    93c2:	0f 92       	push	r0
    93c4:	cd b7       	in	r28, 0x3d	; 61
    93c6:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    93c8:	0f b6       	in	r0, 0x3f	; 63
    93ca:	f8 94       	cli
    93cc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    93ce:	80 91 5d 25 	lds	r24, 0x255D
    93d2:	81 50       	subi	r24, 0x01	; 1
    93d4:	80 93 5d 25 	sts	0x255D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    93d8:	80 91 5d 25 	lds	r24, 0x255D
    93dc:	88 23       	and	r24, r24
    93de:	09 f0       	breq	.+2      	; 0x93e2 <xTaskResumeAll+0x2c>
    93e0:	60 c0       	rjmp	.+192    	; 0x94a2 <xTaskResumeAll+0xec>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    93e2:	80 91 cb 25 	lds	r24, 0x25CB
    93e6:	88 23       	and	r24, r24
    93e8:	09 f4       	brne	.+2      	; 0x93ec <xTaskResumeAll+0x36>
    93ea:	5b c0       	rjmp	.+182    	; 0x94a2 <xTaskResumeAll+0xec>
    93ec:	19 82       	std	Y+1, r1	; 0x01
    93ee:	2f c0       	rjmp	.+94     	; 0x944e <xTaskResumeAll+0x98>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    93f0:	c7 01       	movw	r24, r14
    93f2:	0c 96       	adiw	r24, 0x0c	; 12
    93f4:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    93f8:	87 01       	movw	r16, r14
    93fa:	0e 5f       	subi	r16, 0xFE	; 254
    93fc:	1f 4f       	sbci	r17, 0xFF	; 255
    93fe:	c8 01       	movw	r24, r16
    9400:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    9404:	d7 01       	movw	r26, r14
    9406:	56 96       	adiw	r26, 0x16	; 22
    9408:	2c 91       	ld	r18, X
    940a:	56 97       	sbiw	r26, 0x16	; 22
    940c:	80 91 5e 25 	lds	r24, 0x255E
    9410:	82 17       	cp	r24, r18
    9412:	10 f4       	brcc	.+4      	; 0x9418 <xTaskResumeAll+0x62>
    9414:	20 93 5e 25 	sts	0x255E, r18
    9418:	30 e0       	ldi	r19, 0x00	; 0
    941a:	c9 01       	movw	r24, r18
    941c:	53 e0       	ldi	r21, 0x03	; 3
    941e:	88 0f       	add	r24, r24
    9420:	99 1f       	adc	r25, r25
    9422:	5a 95       	dec	r21
    9424:	e1 f7       	brne	.-8      	; 0x941e <xTaskResumeAll+0x68>
    9426:	82 0f       	add	r24, r18
    9428:	93 1f       	adc	r25, r19
    942a:	81 5a       	subi	r24, 0xA1	; 161
    942c:	9a 4d       	sbci	r25, 0xDA	; 218
    942e:	b8 01       	movw	r22, r16
    9430:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    9434:	e0 91 57 25 	lds	r30, 0x2557
    9438:	f0 91 58 25 	lds	r31, 0x2558
    943c:	d7 01       	movw	r26, r14
    943e:	56 96       	adiw	r26, 0x16	; 22
    9440:	9c 91       	ld	r25, X
    9442:	56 97       	sbiw	r26, 0x16	; 22
    9444:	86 89       	ldd	r24, Z+22	; 0x16
    9446:	98 17       	cp	r25, r24
    9448:	10 f0       	brcs	.+4      	; 0x944e <xTaskResumeAll+0x98>
					{
						xYieldRequired = pdTRUE;
    944a:	b1 e0       	ldi	r27, 0x01	; 1
    944c:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    944e:	80 91 7a 25 	lds	r24, 0x257A
    9452:	88 23       	and	r24, r24
    9454:	49 f0       	breq	.+18     	; 0x9468 <xTaskResumeAll+0xb2>
    9456:	e0 91 7f 25 	lds	r30, 0x257F
    945a:	f0 91 80 25 	lds	r31, 0x2580
    945e:	e6 80       	ldd	r14, Z+6	; 0x06
    9460:	f7 80       	ldd	r15, Z+7	; 0x07
    9462:	e1 14       	cp	r14, r1
    9464:	f1 04       	cpc	r15, r1
    9466:	21 f6       	brne	.-120    	; 0x93f0 <xTaskResumeAll+0x3a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    9468:	80 91 95 25 	lds	r24, 0x2595
    946c:	88 23       	and	r24, r24
    946e:	41 f4       	brne	.+16     	; 0x9480 <xTaskResumeAll+0xca>
    9470:	0b c0       	rjmp	.+22     	; 0x9488 <xTaskResumeAll+0xd2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    9472:	0e 94 63 49 	call	0x92c6	; 0x92c6 <vTaskIncrementTick>
						--uxMissedTicks;
    9476:	80 91 95 25 	lds	r24, 0x2595
    947a:	81 50       	subi	r24, 0x01	; 1
    947c:	80 93 95 25 	sts	0x2595, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    9480:	80 91 95 25 	lds	r24, 0x2595
    9484:	88 23       	and	r24, r24
    9486:	a9 f7       	brne	.-22     	; 0x9472 <xTaskResumeAll+0xbc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    9488:	e9 81       	ldd	r30, Y+1	; 0x01
    948a:	e1 30       	cpi	r30, 0x01	; 1
    948c:	21 f0       	breq	.+8      	; 0x9496 <xTaskResumeAll+0xe0>
    948e:	80 91 59 25 	lds	r24, 0x2559
    9492:	81 30       	cpi	r24, 0x01	; 1
    9494:	31 f4       	brne	.+12     	; 0x94a2 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    9496:	10 92 59 25 	sts	0x2559, r1
					portYIELD_WITHIN_API();
    949a:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    949e:	81 e0       	ldi	r24, 0x01	; 1
    94a0:	01 c0       	rjmp	.+2      	; 0x94a4 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    94a2:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
    94a4:	0f 90       	pop	r0
    94a6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    94a8:	0f 90       	pop	r0
    94aa:	cf 91       	pop	r28
    94ac:	df 91       	pop	r29
    94ae:	1f 91       	pop	r17
    94b0:	0f 91       	pop	r16
    94b2:	ff 90       	pop	r15
    94b4:	ef 90       	pop	r14
    94b6:	08 95       	ret

000094b8 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
    94b8:	1f 93       	push	r17
    94ba:	cf 93       	push	r28
    94bc:	df 93       	push	r29
    94be:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
    94c0:	0e 94 1e 49 	call	0x923c	; 0x923c <vTaskSuspendAll>
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
    94c4:	18 82       	st	Y, r1
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
    94c6:	ce 01       	movw	r24, r28
    94c8:	60 e4       	ldi	r22, 0x40	; 64
    94ca:	75 e2       	ldi	r23, 0x25	; 37
    94cc:	0e 94 25 57 	call	0xae4a	; 0xae4a <strcat>

			uxQueue = uxTopUsedPriority + 1;
    94d0:	10 91 98 25 	lds	r17, 0x2598
    94d4:	1f 5f       	subi	r17, 0xFF	; 255

			do
			{
				uxQueue--;
    94d6:	11 50       	subi	r17, 0x01	; 1

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    94d8:	81 2f       	mov	r24, r17
    94da:	90 e0       	ldi	r25, 0x00	; 0
    94dc:	bc 01       	movw	r22, r24
    94de:	e3 e0       	ldi	r30, 0x03	; 3
    94e0:	66 0f       	add	r22, r22
    94e2:	77 1f       	adc	r23, r23
    94e4:	ea 95       	dec	r30
    94e6:	e1 f7       	brne	.-8      	; 0x94e0 <vTaskList+0x28>
    94e8:	68 0f       	add	r22, r24
    94ea:	79 1f       	adc	r23, r25
    94ec:	61 5a       	subi	r22, 0xA1	; 161
    94ee:	7a 4d       	sbci	r23, 0xDA	; 218
    94f0:	fb 01       	movw	r30, r22
    94f2:	80 81       	ld	r24, Z
    94f4:	88 23       	and	r24, r24
    94f6:	21 f0       	breq	.+8      	; 0x9500 <vTaskList+0x48>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
    94f8:	ce 01       	movw	r24, r28
    94fa:	42 e5       	ldi	r20, 0x52	; 82
    94fc:	0e 94 e8 45 	call	0x8bd0	; 0x8bd0 <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
    9500:	11 23       	and	r17, r17
    9502:	49 f7       	brne	.-46     	; 0x94d6 <vTaskList+0x1e>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
    9504:	e0 91 8e 25 	lds	r30, 0x258E
    9508:	f0 91 8f 25 	lds	r31, 0x258F
    950c:	80 81       	ld	r24, Z
    950e:	88 23       	and	r24, r24
    9510:	41 f0       	breq	.+16     	; 0x9522 <vTaskList+0x6a>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
    9512:	60 91 8e 25 	lds	r22, 0x258E
    9516:	70 91 8f 25 	lds	r23, 0x258F
    951a:	ce 01       	movw	r24, r28
    951c:	42 e4       	ldi	r20, 0x42	; 66
    951e:	0e 94 e8 45 	call	0x8bd0	; 0x8bd0 <prvListTaskWithinSingleList>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
    9522:	e0 91 8c 25 	lds	r30, 0x258C
    9526:	f0 91 8d 25 	lds	r31, 0x258D
    952a:	80 81       	ld	r24, Z
    952c:	88 23       	and	r24, r24
    952e:	41 f0       	breq	.+16     	; 0x9540 <vTaskList+0x88>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
    9530:	60 91 8c 25 	lds	r22, 0x258C
    9534:	70 91 8d 25 	lds	r23, 0x258D
    9538:	ce 01       	movw	r24, r28
    953a:	42 e4       	ldi	r20, 0x42	; 66
    953c:	0e 94 e8 45 	call	0x8bd0	; 0x8bd0 <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
    9540:	80 91 83 25 	lds	r24, 0x2583
    9544:	88 23       	and	r24, r24
    9546:	31 f0       	breq	.+12     	; 0x9554 <vTaskList+0x9c>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
    9548:	ce 01       	movw	r24, r28
    954a:	63 e8       	ldi	r22, 0x83	; 131
    954c:	75 e2       	ldi	r23, 0x25	; 37
    954e:	43 e5       	ldi	r20, 0x53	; 83
    9550:	0e 94 e8 45 	call	0x8bd0	; 0x8bd0 <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
    9554:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
	}
    9558:	df 91       	pop	r29
    955a:	cf 91       	pop	r28
    955c:	1f 91       	pop	r17
    955e:	08 95       	ret

00009560 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    9560:	0f 93       	push	r16
    9562:	1f 93       	push	r17
    9564:	cf 93       	push	r28
    9566:	df 93       	push	r29
    9568:	8c 01       	movw	r16, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    956a:	00 97       	sbiw	r24, 0x00	; 0
    956c:	89 f1       	breq	.+98     	; 0x95d0 <vTaskDelay+0x70>
		{
			vTaskSuspendAll();
    956e:	0e 94 1e 49 	call	0x923c	; 0x923c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    9572:	c0 91 5b 25 	lds	r28, 0x255B
    9576:	d0 91 5c 25 	lds	r29, 0x255C
    957a:	c0 0f       	add	r28, r16
    957c:	d1 1f       	adc	r29, r17

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    957e:	80 91 57 25 	lds	r24, 0x2557
    9582:	90 91 58 25 	lds	r25, 0x2558
    9586:	02 96       	adiw	r24, 0x02	; 2
    9588:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    958c:	e0 91 57 25 	lds	r30, 0x2557
    9590:	f0 91 58 25 	lds	r31, 0x2558
    9594:	c2 83       	std	Z+2, r28	; 0x02
    9596:	d3 83       	std	Z+3, r29	; 0x03

				if( xTimeToWake < xTickCount )
    9598:	80 91 5b 25 	lds	r24, 0x255B
    959c:	90 91 5c 25 	lds	r25, 0x255C
    95a0:	c8 17       	cp	r28, r24
    95a2:	d9 07       	cpc	r29, r25
    95a4:	28 f4       	brcc	.+10     	; 0x95b0 <vTaskDelay+0x50>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    95a6:	80 91 8c 25 	lds	r24, 0x258C
    95aa:	90 91 8d 25 	lds	r25, 0x258D
    95ae:	04 c0       	rjmp	.+8      	; 0x95b8 <vTaskDelay+0x58>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    95b0:	80 91 8e 25 	lds	r24, 0x258E
    95b4:	90 91 8f 25 	lds	r25, 0x258F
    95b8:	60 91 57 25 	lds	r22, 0x2557
    95bc:	70 91 58 25 	lds	r23, 0x2558
    95c0:	6e 5f       	subi	r22, 0xFE	; 254
    95c2:	7f 4f       	sbci	r23, 0xFF	; 255
    95c4:	0e 94 7c 50 	call	0xa0f8	; 0xa0f8 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    95c8:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    95cc:	88 23       	and	r24, r24
    95ce:	11 f4       	brne	.+4      	; 0x95d4 <vTaskDelay+0x74>
		{
			portYIELD_WITHIN_API();
    95d0:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
		}
	}
    95d4:	df 91       	pop	r29
    95d6:	cf 91       	pop	r28
    95d8:	1f 91       	pop	r17
    95da:	0f 91       	pop	r16
    95dc:	08 95       	ret

000095de <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    95de:	0f 93       	push	r16
    95e0:	1f 93       	push	r17
    95e2:	cf 93       	push	r28
    95e4:	df 93       	push	r29
    95e6:	8c 01       	movw	r16, r24
    95e8:	eb 01       	movw	r28, r22
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
    95ea:	0e 94 1e 49 	call	0x923c	; 0x923c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    95ee:	f8 01       	movw	r30, r16
    95f0:	80 81       	ld	r24, Z
    95f2:	91 81       	ldd	r25, Z+1	; 0x01
    95f4:	c8 0f       	add	r28, r24
    95f6:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    95f8:	20 91 5b 25 	lds	r18, 0x255B
    95fc:	30 91 5c 25 	lds	r19, 0x255C
    9600:	28 17       	cp	r18, r24
    9602:	39 07       	cpc	r19, r25
    9604:	20 f4       	brcc	.+8      	; 0x960e <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    9606:	c8 17       	cp	r28, r24
    9608:	d9 07       	cpc	r29, r25
    960a:	60 f4       	brcc	.+24     	; 0x9624 <vTaskDelayUntil+0x46>
    960c:	03 c0       	rjmp	.+6      	; 0x9614 <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    960e:	c8 17       	cp	r28, r24
    9610:	d9 07       	cpc	r29, r25
    9612:	50 f0       	brcs	.+20     	; 0x9628 <vTaskDelayUntil+0x4a>
    9614:	80 91 5b 25 	lds	r24, 0x255B
    9618:	90 91 5c 25 	lds	r25, 0x255C
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    961c:	21 e0       	ldi	r18, 0x01	; 1
    961e:	8c 17       	cp	r24, r28
    9620:	9d 07       	cpc	r25, r29
    9622:	18 f0       	brcs	.+6      	; 0x962a <vTaskDelayUntil+0x4c>
    9624:	20 e0       	ldi	r18, 0x00	; 0
    9626:	01 c0       	rjmp	.+2      	; 0x962a <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    9628:	21 e0       	ldi	r18, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    962a:	f8 01       	movw	r30, r16
    962c:	c0 83       	st	Z, r28
    962e:	d1 83       	std	Z+1, r29	; 0x01

			if( xShouldDelay )
    9630:	22 23       	and	r18, r18
    9632:	29 f1       	breq	.+74     	; 0x967e <vTaskDelayUntil+0xa0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9634:	80 91 57 25 	lds	r24, 0x2557
    9638:	90 91 58 25 	lds	r25, 0x2558
    963c:	02 96       	adiw	r24, 0x02	; 2
    963e:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    9642:	e0 91 57 25 	lds	r30, 0x2557
    9646:	f0 91 58 25 	lds	r31, 0x2558
    964a:	c2 83       	std	Z+2, r28	; 0x02
    964c:	d3 83       	std	Z+3, r29	; 0x03

				if( xTimeToWake < xTickCount )
    964e:	80 91 5b 25 	lds	r24, 0x255B
    9652:	90 91 5c 25 	lds	r25, 0x255C
    9656:	c8 17       	cp	r28, r24
    9658:	d9 07       	cpc	r29, r25
    965a:	28 f4       	brcc	.+10     	; 0x9666 <vTaskDelayUntil+0x88>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    965c:	80 91 8c 25 	lds	r24, 0x258C
    9660:	90 91 8d 25 	lds	r25, 0x258D
    9664:	04 c0       	rjmp	.+8      	; 0x966e <vTaskDelayUntil+0x90>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9666:	80 91 8e 25 	lds	r24, 0x258E
    966a:	90 91 8f 25 	lds	r25, 0x258F
    966e:	60 91 57 25 	lds	r22, 0x2557
    9672:	70 91 58 25 	lds	r23, 0x2558
    9676:	6e 5f       	subi	r22, 0xFE	; 254
    9678:	7f 4f       	sbci	r23, 0xFF	; 255
    967a:	0e 94 7c 50 	call	0xa0f8	; 0xa0f8 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    967e:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    9682:	88 23       	and	r24, r24
    9684:	11 f4       	brne	.+4      	; 0x968a <vTaskDelayUntil+0xac>
		{
			portYIELD_WITHIN_API();
    9686:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
		}
	}
    968a:	df 91       	pop	r29
    968c:	cf 91       	pop	r28
    968e:	1f 91       	pop	r17
    9690:	0f 91       	pop	r16
    9692:	08 95       	ret

00009694 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    9694:	80 91 5d 25 	lds	r24, 0x255D
    9698:	88 23       	and	r24, r24
    969a:	49 f0       	breq	.+18     	; 0x96ae <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    969c:	81 e0       	ldi	r24, 0x01	; 1
    969e:	80 93 59 25 	sts	0x2559, r24
		return;
    96a2:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    96a4:	80 91 5e 25 	lds	r24, 0x255E
    96a8:	81 50       	subi	r24, 0x01	; 1
    96aa:	80 93 5e 25 	sts	0x255E, r24

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    96ae:	80 91 5e 25 	lds	r24, 0x255E
    96b2:	90 e0       	ldi	r25, 0x00	; 0
    96b4:	fc 01       	movw	r30, r24
    96b6:	23 e0       	ldi	r18, 0x03	; 3
    96b8:	ee 0f       	add	r30, r30
    96ba:	ff 1f       	adc	r31, r31
    96bc:	2a 95       	dec	r18
    96be:	e1 f7       	brne	.-8      	; 0x96b8 <vTaskSwitchContext+0x24>
    96c0:	e8 0f       	add	r30, r24
    96c2:	f9 1f       	adc	r31, r25
    96c4:	e1 5a       	subi	r30, 0xA1	; 161
    96c6:	fa 4d       	sbci	r31, 0xDA	; 218
    96c8:	80 81       	ld	r24, Z
    96ca:	88 23       	and	r24, r24
    96cc:	59 f3       	breq	.-42     	; 0x96a4 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    96ce:	80 91 5e 25 	lds	r24, 0x255E
    96d2:	90 e0       	ldi	r25, 0x00	; 0
    96d4:	9c 01       	movw	r18, r24
    96d6:	b3 e0       	ldi	r27, 0x03	; 3
    96d8:	22 0f       	add	r18, r18
    96da:	33 1f       	adc	r19, r19
    96dc:	ba 95       	dec	r27
    96de:	e1 f7       	brne	.-8      	; 0x96d8 <vTaskSwitchContext+0x44>
    96e0:	28 0f       	add	r18, r24
    96e2:	39 1f       	adc	r19, r25
    96e4:	f9 01       	movw	r30, r18
    96e6:	e1 5a       	subi	r30, 0xA1	; 161
    96e8:	fa 4d       	sbci	r31, 0xDA	; 218
    96ea:	a1 81       	ldd	r26, Z+1	; 0x01
    96ec:	b2 81       	ldd	r27, Z+2	; 0x02
    96ee:	12 96       	adiw	r26, 0x02	; 2
    96f0:	0d 90       	ld	r0, X+
    96f2:	bc 91       	ld	r27, X
    96f4:	a0 2d       	mov	r26, r0
    96f6:	a1 83       	std	Z+1, r26	; 0x01
    96f8:	b2 83       	std	Z+2, r27	; 0x02
    96fa:	2e 59       	subi	r18, 0x9E	; 158
    96fc:	3a 4d       	sbci	r19, 0xDA	; 218
    96fe:	a2 17       	cp	r26, r18
    9700:	b3 07       	cpc	r27, r19
    9702:	31 f4       	brne	.+12     	; 0x9710 <vTaskSwitchContext+0x7c>
    9704:	12 96       	adiw	r26, 0x02	; 2
    9706:	2d 91       	ld	r18, X+
    9708:	3c 91       	ld	r19, X
    970a:	13 97       	sbiw	r26, 0x03	; 3
    970c:	21 83       	std	Z+1, r18	; 0x01
    970e:	32 83       	std	Z+2, r19	; 0x02
    9710:	fc 01       	movw	r30, r24
    9712:	a3 e0       	ldi	r26, 0x03	; 3
    9714:	ee 0f       	add	r30, r30
    9716:	ff 1f       	adc	r31, r31
    9718:	aa 95       	dec	r26
    971a:	e1 f7       	brne	.-8      	; 0x9714 <vTaskSwitchContext+0x80>
    971c:	e8 0f       	add	r30, r24
    971e:	f9 1f       	adc	r31, r25
    9720:	e1 5a       	subi	r30, 0xA1	; 161
    9722:	fa 4d       	sbci	r31, 0xDA	; 218
    9724:	01 80       	ldd	r0, Z+1	; 0x01
    9726:	f2 81       	ldd	r31, Z+2	; 0x02
    9728:	e0 2d       	mov	r30, r0
    972a:	86 81       	ldd	r24, Z+6	; 0x06
    972c:	97 81       	ldd	r25, Z+7	; 0x07
    972e:	80 93 57 25 	sts	0x2557, r24
    9732:	90 93 58 25 	sts	0x2558, r25

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
    9736:	80 91 90 25 	lds	r24, 0x2590
    973a:	88 23       	and	r24, r24
    973c:	09 f4       	brne	.+2      	; 0x9740 <vTaskSwitchContext+0xac>
    973e:	4c c0       	rjmp	.+152    	; 0x97d8 <vTaskSwitchContext+0x144>
    9740:	e0 91 57 25 	lds	r30, 0x2557
    9744:	f0 91 58 25 	lds	r31, 0x2558
    9748:	90 91 43 25 	lds	r25, 0x2543
    974c:	83 a1       	ldd	r24, Z+35	; 0x23
    974e:	98 17       	cp	r25, r24
    9750:	09 f4       	brne	.+2      	; 0x9754 <vTaskSwitchContext+0xc0>
    9752:	42 c0       	rjmp	.+132    	; 0x97d8 <vTaskSwitchContext+0x144>
    9754:	80 91 91 25 	lds	r24, 0x2591
    9758:	90 91 92 25 	lds	r25, 0x2592
    975c:	08 96       	adiw	r24, 0x08	; 8
    975e:	20 91 93 25 	lds	r18, 0x2593
    9762:	30 91 94 25 	lds	r19, 0x2594
    9766:	82 17       	cp	r24, r18
    9768:	93 07       	cpc	r25, r19
    976a:	a0 f5       	brcc	.+104    	; 0x97d4 <vTaskSwitchContext+0x140>
    976c:	e0 91 57 25 	lds	r30, 0x2557
    9770:	f0 91 58 25 	lds	r31, 0x2558
    9774:	83 a1       	ldd	r24, Z+35	; 0x23
    9776:	80 93 43 25 	sts	0x2543, r24
    977a:	e0 91 91 25 	lds	r30, 0x2591
    977e:	f0 91 92 25 	lds	r31, 0x2592
    9782:	20 91 5b 25 	lds	r18, 0x255B
    9786:	30 91 5c 25 	lds	r19, 0x255C
    978a:	40 e0       	ldi	r20, 0x00	; 0
    978c:	50 e0       	ldi	r21, 0x00	; 0
    978e:	20 83       	st	Z, r18
    9790:	31 83       	std	Z+1, r19	; 0x01
    9792:	42 83       	std	Z+2, r20	; 0x02
    9794:	53 83       	std	Z+3, r21	; 0x03
    9796:	20 91 91 25 	lds	r18, 0x2591
    979a:	30 91 92 25 	lds	r19, 0x2592
    979e:	2c 5f       	subi	r18, 0xFC	; 252
    97a0:	3f 4f       	sbci	r19, 0xFF	; 255
    97a2:	20 93 91 25 	sts	0x2591, r18
    97a6:	30 93 92 25 	sts	0x2592, r19
    97aa:	e0 91 91 25 	lds	r30, 0x2591
    97ae:	f0 91 92 25 	lds	r31, 0x2592
    97b2:	90 e0       	ldi	r25, 0x00	; 0
    97b4:	a0 e0       	ldi	r26, 0x00	; 0
    97b6:	b0 e0       	ldi	r27, 0x00	; 0
    97b8:	80 83       	st	Z, r24
    97ba:	91 83       	std	Z+1, r25	; 0x01
    97bc:	a2 83       	std	Z+2, r26	; 0x02
    97be:	b3 83       	std	Z+3, r27	; 0x03
    97c0:	80 91 91 25 	lds	r24, 0x2591
    97c4:	90 91 92 25 	lds	r25, 0x2592
    97c8:	04 96       	adiw	r24, 0x04	; 4
    97ca:	80 93 91 25 	sts	0x2591, r24
    97ce:	90 93 92 25 	sts	0x2592, r25
    97d2:	08 95       	ret
    97d4:	10 92 90 25 	sts	0x2590, r1
    97d8:	08 95       	ret

000097da <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    97da:	cf 93       	push	r28
    97dc:	df 93       	push	r29
    97de:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    97e0:	60 91 57 25 	lds	r22, 0x2557
    97e4:	70 91 58 25 	lds	r23, 0x2558
    97e8:	64 5f       	subi	r22, 0xF4	; 244
    97ea:	7f 4f       	sbci	r23, 0xFF	; 255
    97ec:	0e 94 7c 50 	call	0xa0f8	; 0xa0f8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    97f0:	80 91 57 25 	lds	r24, 0x2557
    97f4:	90 91 58 25 	lds	r25, 0x2558
    97f8:	02 96       	adiw	r24, 0x02	; 2
    97fa:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    97fe:	8f ef       	ldi	r24, 0xFF	; 255
    9800:	cf 3f       	cpi	r28, 0xFF	; 255
    9802:	d8 07       	cpc	r29, r24
    9804:	59 f4       	brne	.+22     	; 0x981c <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9806:	60 91 57 25 	lds	r22, 0x2557
    980a:	70 91 58 25 	lds	r23, 0x2558
    980e:	6e 5f       	subi	r22, 0xFE	; 254
    9810:	7f 4f       	sbci	r23, 0xFF	; 255
    9812:	83 e8       	ldi	r24, 0x83	; 131
    9814:	95 e2       	ldi	r25, 0x25	; 37
    9816:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
    981a:	24 c0       	rjmp	.+72     	; 0x9864 <vTaskPlaceOnEventList+0x8a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    981c:	80 91 5b 25 	lds	r24, 0x255B
    9820:	90 91 5c 25 	lds	r25, 0x255C
    9824:	8c 0f       	add	r24, r28
    9826:	9d 1f       	adc	r25, r29

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    9828:	e0 91 57 25 	lds	r30, 0x2557
    982c:	f0 91 58 25 	lds	r31, 0x2558
    9830:	82 83       	std	Z+2, r24	; 0x02
    9832:	93 83       	std	Z+3, r25	; 0x03

			if( xTimeToWake < xTickCount )
    9834:	20 91 5b 25 	lds	r18, 0x255B
    9838:	30 91 5c 25 	lds	r19, 0x255C
    983c:	82 17       	cp	r24, r18
    983e:	93 07       	cpc	r25, r19
    9840:	28 f4       	brcc	.+10     	; 0x984c <vTaskPlaceOnEventList+0x72>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    9842:	80 91 8c 25 	lds	r24, 0x258C
    9846:	90 91 8d 25 	lds	r25, 0x258D
    984a:	04 c0       	rjmp	.+8      	; 0x9854 <vTaskPlaceOnEventList+0x7a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    984c:	80 91 8e 25 	lds	r24, 0x258E
    9850:	90 91 8f 25 	lds	r25, 0x258F
    9854:	60 91 57 25 	lds	r22, 0x2557
    9858:	70 91 58 25 	lds	r23, 0x2558
    985c:	6e 5f       	subi	r22, 0xFE	; 254
    985e:	7f 4f       	sbci	r23, 0xFF	; 255
    9860:	0e 94 7c 50 	call	0xa0f8	; 0xa0f8 <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    9864:	df 91       	pop	r29
    9866:	cf 91       	pop	r28
    9868:	08 95       	ret

0000986a <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    986a:	0f 93       	push	r16
    986c:	1f 93       	push	r17
    986e:	cf 93       	push	r28
    9870:	df 93       	push	r29
    9872:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    9874:	80 81       	ld	r24, Z
    9876:	88 23       	and	r24, r24
    9878:	31 f0       	breq	.+12     	; 0x9886 <xTaskRemoveFromEventList+0x1c>
    987a:	05 80       	ldd	r0, Z+5	; 0x05
    987c:	f6 81       	ldd	r31, Z+6	; 0x06
    987e:	e0 2d       	mov	r30, r0
    9880:	c6 81       	ldd	r28, Z+6	; 0x06
    9882:	d7 81       	ldd	r29, Z+7	; 0x07
    9884:	02 c0       	rjmp	.+4      	; 0x988a <xTaskRemoveFromEventList+0x20>
    9886:	c0 e0       	ldi	r28, 0x00	; 0
    9888:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    988a:	8e 01       	movw	r16, r28
    988c:	04 5f       	subi	r16, 0xF4	; 244
    988e:	1f 4f       	sbci	r17, 0xFF	; 255
    9890:	c8 01       	movw	r24, r16
    9892:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    9896:	80 91 5d 25 	lds	r24, 0x255D
    989a:	88 23       	and	r24, r24
    989c:	c9 f4       	brne	.+50     	; 0x98d0 <xTaskRemoveFromEventList+0x66>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    989e:	8e 01       	movw	r16, r28
    98a0:	0e 5f       	subi	r16, 0xFE	; 254
    98a2:	1f 4f       	sbci	r17, 0xFF	; 255
    98a4:	c8 01       	movw	r24, r16
    98a6:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    98aa:	2e 89       	ldd	r18, Y+22	; 0x16
    98ac:	80 91 5e 25 	lds	r24, 0x255E
    98b0:	82 17       	cp	r24, r18
    98b2:	10 f4       	brcc	.+4      	; 0x98b8 <xTaskRemoveFromEventList+0x4e>
    98b4:	20 93 5e 25 	sts	0x255E, r18
    98b8:	30 e0       	ldi	r19, 0x00	; 0
    98ba:	c9 01       	movw	r24, r18
    98bc:	43 e0       	ldi	r20, 0x03	; 3
    98be:	88 0f       	add	r24, r24
    98c0:	99 1f       	adc	r25, r25
    98c2:	4a 95       	dec	r20
    98c4:	e1 f7       	brne	.-8      	; 0x98be <xTaskRemoveFromEventList+0x54>
    98c6:	82 0f       	add	r24, r18
    98c8:	93 1f       	adc	r25, r19
    98ca:	81 5a       	subi	r24, 0xA1	; 161
    98cc:	9a 4d       	sbci	r25, 0xDA	; 218
    98ce:	02 c0       	rjmp	.+4      	; 0x98d4 <xTaskRemoveFromEventList+0x6a>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    98d0:	8a e7       	ldi	r24, 0x7A	; 122
    98d2:	95 e2       	ldi	r25, 0x25	; 37
    98d4:	b8 01       	movw	r22, r16
    98d6:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    98da:	e0 91 57 25 	lds	r30, 0x2557
    98de:	f0 91 58 25 	lds	r31, 0x2558
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    98e2:	81 e0       	ldi	r24, 0x01	; 1
    98e4:	2e 89       	ldd	r18, Y+22	; 0x16
    98e6:	96 89       	ldd	r25, Z+22	; 0x16
    98e8:	29 17       	cp	r18, r25
    98ea:	08 f4       	brcc	.+2      	; 0x98ee <xTaskRemoveFromEventList+0x84>
    98ec:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    98ee:	df 91       	pop	r29
    98f0:	cf 91       	pop	r28
    98f2:	1f 91       	pop	r17
    98f4:	0f 91       	pop	r16
    98f6:	08 95       	ret

000098f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    98f8:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    98fa:	80 91 5a 25 	lds	r24, 0x255A
    98fe:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    9900:	80 91 5b 25 	lds	r24, 0x255B
    9904:	90 91 5c 25 	lds	r25, 0x255C
    9908:	81 83       	std	Z+1, r24	; 0x01
    990a:	92 83       	std	Z+2, r25	; 0x02
}
    990c:	08 95       	ret

0000990e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    990e:	fc 01       	movw	r30, r24
    9910:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    9912:	0f b6       	in	r0, 0x3f	; 63
    9914:	f8 94       	cli
    9916:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    9918:	2d 91       	ld	r18, X+
    991a:	3c 91       	ld	r19, X
    991c:	11 97       	sbiw	r26, 0x01	; 1
    991e:	8f ef       	ldi	r24, 0xFF	; 255
    9920:	2f 3f       	cpi	r18, 0xFF	; 255
    9922:	38 07       	cpc	r19, r24
    9924:	69 f1       	breq	.+90     	; 0x9980 <xTaskCheckForTimeOut+0x72>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    9926:	90 91 5a 25 	lds	r25, 0x255A
    992a:	80 81       	ld	r24, Z
    992c:	98 17       	cp	r25, r24
    992e:	49 f0       	breq	.+18     	; 0x9942 <xTaskCheckForTimeOut+0x34>
    9930:	40 91 5b 25 	lds	r20, 0x255B
    9934:	50 91 5c 25 	lds	r21, 0x255C
    9938:	81 81       	ldd	r24, Z+1	; 0x01
    993a:	92 81       	ldd	r25, Z+2	; 0x02
    993c:	48 17       	cp	r20, r24
    993e:	59 07       	cpc	r21, r25
    9940:	08 f5       	brcc	.+66     	; 0x9984 <xTaskCheckForTimeOut+0x76>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    9942:	40 91 5b 25 	lds	r20, 0x255B
    9946:	50 91 5c 25 	lds	r21, 0x255C
    994a:	81 81       	ldd	r24, Z+1	; 0x01
    994c:	92 81       	ldd	r25, Z+2	; 0x02
    994e:	48 1b       	sub	r20, r24
    9950:	59 0b       	sbc	r21, r25
    9952:	42 17       	cp	r20, r18
    9954:	53 07       	cpc	r21, r19
    9956:	b0 f4       	brcc	.+44     	; 0x9984 <xTaskCheckForTimeOut+0x76>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    9958:	40 91 5b 25 	lds	r20, 0x255B
    995c:	50 91 5c 25 	lds	r21, 0x255C
    9960:	84 1b       	sub	r24, r20
    9962:	95 0b       	sbc	r25, r21
    9964:	82 0f       	add	r24, r18
    9966:	93 1f       	adc	r25, r19
    9968:	8d 93       	st	X+, r24
    996a:	9c 93       	st	X, r25
    996c:	11 97       	sbiw	r26, 0x01	; 1
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    996e:	80 91 5a 25 	lds	r24, 0x255A
    9972:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    9974:	80 91 5b 25 	lds	r24, 0x255B
    9978:	90 91 5c 25 	lds	r25, 0x255C
    997c:	81 83       	std	Z+1, r24	; 0x01
    997e:	92 83       	std	Z+2, r25	; 0x02
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    9980:	80 e0       	ldi	r24, 0x00	; 0
    9982:	01 c0       	rjmp	.+2      	; 0x9986 <xTaskCheckForTimeOut+0x78>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    9984:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portEXIT_CRITICAL();
    9986:	0f 90       	pop	r0
    9988:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    998a:	08 95       	ret

0000998c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    998c:	81 e0       	ldi	r24, 0x01	; 1
    998e:	80 93 59 25 	sts	0x2559, r24
}
    9992:	08 95       	ret

00009994 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    9994:	0f 93       	push	r16
    9996:	1f 93       	push	r17
    9998:	cf 93       	push	r28
    999a:	df 93       	push	r29
    999c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    999e:	0f b6       	in	r0, 0x3f	; 63
    99a0:	f8 94       	cli
    99a2:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    99a4:	8c 01       	movw	r16, r24
    99a6:	0f 5e       	subi	r16, 0xEF	; 239
    99a8:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    99aa:	0d c0       	rjmp	.+26     	; 0x99c6 <prvUnlockQueue+0x32>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    99ac:	89 89       	ldd	r24, Y+17	; 0x11
    99ae:	88 23       	and	r24, r24
    99b0:	69 f0       	breq	.+26     	; 0x99cc <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    99b2:	c8 01       	movw	r24, r16
    99b4:	0e 94 35 4c 	call	0x986a	; 0x986a <xTaskRemoveFromEventList>
    99b8:	88 23       	and	r24, r24
    99ba:	11 f0       	breq	.+4      	; 0x99c0 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    99bc:	0e 94 c6 4c 	call	0x998c	; 0x998c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    99c0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    99c2:	81 50       	subi	r24, 0x01	; 1
    99c4:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    99c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    99c8:	18 16       	cp	r1, r24
    99ca:	84 f3       	brlt	.-32     	; 0x99ac <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    99cc:	8f ef       	ldi	r24, 0xFF	; 255
    99ce:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    99d0:	0f 90       	pop	r0
    99d2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    99d4:	0f b6       	in	r0, 0x3f	; 63
    99d6:	f8 94       	cli
    99d8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    99da:	8e 01       	movw	r16, r28
    99dc:	08 5f       	subi	r16, 0xF8	; 248
    99de:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    99e0:	0d c0       	rjmp	.+26     	; 0x99fc <prvUnlockQueue+0x68>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    99e2:	88 85       	ldd	r24, Y+8	; 0x08
    99e4:	88 23       	and	r24, r24
    99e6:	69 f0       	breq	.+26     	; 0x9a02 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    99e8:	c8 01       	movw	r24, r16
    99ea:	0e 94 35 4c 	call	0x986a	; 0x986a <xTaskRemoveFromEventList>
    99ee:	88 23       	and	r24, r24
    99f0:	11 f0       	breq	.+4      	; 0x99f6 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    99f2:	0e 94 c6 4c 	call	0x998c	; 0x998c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    99f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    99f8:	81 50       	subi	r24, 0x01	; 1
    99fa:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    99fc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    99fe:	18 16       	cp	r1, r24
    9a00:	84 f3       	brlt	.-32     	; 0x99e2 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    9a02:	8f ef       	ldi	r24, 0xFF	; 255
    9a04:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    9a06:	0f 90       	pop	r0
    9a08:	0f be       	out	0x3f, r0	; 63
}
    9a0a:	df 91       	pop	r29
    9a0c:	cf 91       	pop	r28
    9a0e:	1f 91       	pop	r17
    9a10:	0f 91       	pop	r16
    9a12:	08 95       	ret

00009a14 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    9a14:	af 92       	push	r10
    9a16:	bf 92       	push	r11
    9a18:	cf 92       	push	r12
    9a1a:	df 92       	push	r13
    9a1c:	ef 92       	push	r14
    9a1e:	ff 92       	push	r15
    9a20:	0f 93       	push	r16
    9a22:	1f 93       	push	r17
    9a24:	cf 93       	push	r28
    9a26:	df 93       	push	r29
    9a28:	b8 2e       	mov	r11, r24
    9a2a:	a6 2e       	mov	r10, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    9a2c:	88 23       	and	r24, r24
    9a2e:	09 f4       	brne	.+2      	; 0x9a32 <xQueueCreate+0x1e>
    9a30:	43 c0       	rjmp	.+134    	; 0x9ab8 <xQueueCreate+0xa4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    9a32:	8f e1       	ldi	r24, 0x1F	; 31
    9a34:	90 e0       	ldi	r25, 0x00	; 0
    9a36:	0e 94 b0 52 	call	0xa560	; 0xa560 <pvPortMalloc>
    9a3a:	e8 2e       	mov	r14, r24
    9a3c:	e7 01       	movw	r28, r14
    9a3e:	7e 01       	movw	r14, r28
    9a40:	f9 2e       	mov	r15, r25
    9a42:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
    9a44:	20 97       	sbiw	r28, 0x00	; 0
    9a46:	d1 f1       	breq	.+116    	; 0x9abc <xQueueCreate+0xa8>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    9a48:	0b 2d       	mov	r16, r11
    9a4a:	10 e0       	ldi	r17, 0x00	; 0
    9a4c:	ca 2c       	mov	r12, r10
    9a4e:	dd 24       	eor	r13, r13
    9a50:	c0 9e       	mul	r12, r16
    9a52:	70 01       	movw	r14, r0
    9a54:	c1 9e       	mul	r12, r17
    9a56:	f0 0c       	add	r15, r0
    9a58:	d0 9e       	mul	r13, r16
    9a5a:	f0 0c       	add	r15, r0
    9a5c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    9a5e:	c7 01       	movw	r24, r14
    9a60:	01 96       	adiw	r24, 0x01	; 1
    9a62:	0e 94 b0 52 	call	0xa560	; 0xa560 <pvPortMalloc>
    9a66:	88 83       	st	Y, r24
    9a68:	99 83       	std	Y+1, r25	; 0x01
			if( pxNewQueue->pcHead != NULL )
    9a6a:	00 97       	sbiw	r24, 0x00	; 0
    9a6c:	11 f1       	breq	.+68     	; 0x9ab2 <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    9a6e:	e8 0e       	add	r14, r24
    9a70:	f9 1e       	adc	r15, r25
    9a72:	ea 82       	std	Y+2, r14	; 0x02
    9a74:	fb 82       	std	Y+3, r15	; 0x03
				pxNewQueue->uxMessagesWaiting = 0;
    9a76:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    9a78:	8c 83       	std	Y+4, r24	; 0x04
    9a7a:	9d 83       	std	Y+5, r25	; 0x05
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    9a7c:	01 50       	subi	r16, 0x01	; 1
    9a7e:	10 40       	sbci	r17, 0x00	; 0
    9a80:	0c 9d       	mul	r16, r12
    9a82:	a0 01       	movw	r20, r0
    9a84:	0d 9d       	mul	r16, r13
    9a86:	50 0d       	add	r21, r0
    9a88:	1c 9d       	mul	r17, r12
    9a8a:	50 0d       	add	r21, r0
    9a8c:	11 24       	eor	r1, r1
    9a8e:	48 0f       	add	r20, r24
    9a90:	59 1f       	adc	r21, r25
    9a92:	4e 83       	std	Y+6, r20	; 0x06
    9a94:	5f 83       	std	Y+7, r21	; 0x07
				pxNewQueue->uxLength = uxQueueLength;
    9a96:	bb 8e       	std	Y+27, r11	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    9a98:	ac 8e       	std	Y+28, r10	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    9a9a:	8f ef       	ldi	r24, 0xFF	; 255
    9a9c:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    9a9e:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    9aa0:	ce 01       	movw	r24, r28
    9aa2:	08 96       	adiw	r24, 0x08	; 8
    9aa4:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    9aa8:	ce 01       	movw	r24, r28
    9aaa:	41 96       	adiw	r24, 0x11	; 17
    9aac:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    9ab0:	05 c0       	rjmp	.+10     	; 0x9abc <xQueueCreate+0xa8>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    9ab2:	ce 01       	movw	r24, r28
    9ab4:	0e 94 d9 52 	call	0xa5b2	; 0xa5b2 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    9ab8:	c0 e0       	ldi	r28, 0x00	; 0
    9aba:	d0 e0       	ldi	r29, 0x00	; 0
}
    9abc:	ce 01       	movw	r24, r28
    9abe:	df 91       	pop	r29
    9ac0:	cf 91       	pop	r28
    9ac2:	1f 91       	pop	r17
    9ac4:	0f 91       	pop	r16
    9ac6:	ff 90       	pop	r15
    9ac8:	ef 90       	pop	r14
    9aca:	df 90       	pop	r13
    9acc:	cf 90       	pop	r12
    9ace:	bf 90       	pop	r11
    9ad0:	af 90       	pop	r10
    9ad2:	08 95       	ret

00009ad4 <xQueueCreateExternal>:

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    9ad4:	cf 92       	push	r12
    9ad6:	df 92       	push	r13
    9ad8:	ef 92       	push	r14
    9ada:	ff 92       	push	r15
    9adc:	1f 93       	push	r17
    9ade:	df 93       	push	r29
    9ae0:	cf 93       	push	r28
    9ae2:	00 d0       	rcall	.+0      	; 0x9ae4 <xQueueCreateExternal+0x10>
    9ae4:	cd b7       	in	r28, 0x3d	; 61
    9ae6:	de b7       	in	r29, 0x3e	; 62
    9ae8:	18 2f       	mov	r17, r24
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    9aea:	88 23       	and	r24, r24
    9aec:	09 f4       	brne	.+2      	; 0x9af0 <xQueueCreateExternal+0x1c>
    9aee:	56 c0       	rjmp	.+172    	; 0x9b9c <xQueueCreateExternal+0xc8>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    9af0:	8f e1       	ldi	r24, 0x1F	; 31
    9af2:	90 e0       	ldi	r25, 0x00	; 0
    9af4:	4a 83       	std	Y+2, r20	; 0x02
    9af6:	5b 83       	std	Y+3, r21	; 0x03
    9af8:	69 83       	std	Y+1, r22	; 0x01
    9afa:	0e 94 b0 52 	call	0xa560	; 0xa560 <pvPortMalloc>
    9afe:	c8 2e       	mov	r12, r24
    9b00:	d9 2e       	mov	r13, r25
		if( pxNewQueue != NULL )
    9b02:	4a 81       	ldd	r20, Y+2	; 0x02
    9b04:	5b 81       	ldd	r21, Y+3	; 0x03
    9b06:	69 81       	ldd	r22, Y+1	; 0x01
    9b08:	c1 14       	cp	r12, r1
    9b0a:	d1 04       	cpc	r13, r1
    9b0c:	09 f4       	brne	.+2      	; 0x9b10 <xQueueCreateExternal+0x3c>
    9b0e:	48 c0       	rjmp	.+144    	; 0x9ba0 <xQueueCreateExternal+0xcc>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    9b10:	9a 01       	movw	r18, r20
    9b12:	d6 01       	movw	r26, r12
    9b14:	2d 93       	st	X+, r18
    9b16:	3c 93       	st	X, r19
    9b18:	11 97       	sbiw	r26, 0x01	; 1
			if( pxNewQueue->pcHead != NULL )
    9b1a:	21 15       	cp	r18, r1
    9b1c:	31 05       	cpc	r19, r1
    9b1e:	d9 f1       	breq	.+118    	; 0x9b96 <xQueueCreateExternal+0xc2>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    9b20:	e1 2f       	mov	r30, r17
    9b22:	f0 e0       	ldi	r31, 0x00	; 0
    9b24:	86 2f       	mov	r24, r22
    9b26:	90 e0       	ldi	r25, 0x00	; 0
    9b28:	8e 9f       	mul	r24, r30
    9b2a:	a0 01       	movw	r20, r0
    9b2c:	8f 9f       	mul	r24, r31
    9b2e:	50 0d       	add	r21, r0
    9b30:	9e 9f       	mul	r25, r30
    9b32:	50 0d       	add	r21, r0
    9b34:	11 24       	eor	r1, r1
    9b36:	42 0f       	add	r20, r18
    9b38:	53 1f       	adc	r21, r19
    9b3a:	12 96       	adiw	r26, 0x02	; 2
    9b3c:	4d 93       	st	X+, r20
    9b3e:	5c 93       	st	X, r21
    9b40:	13 97       	sbiw	r26, 0x03	; 3
				pxNewQueue->uxMessagesWaiting = 0;
    9b42:	5a 96       	adiw	r26, 0x1a	; 26
    9b44:	1c 92       	st	X, r1
    9b46:	5a 97       	sbiw	r26, 0x1a	; 26
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    9b48:	14 96       	adiw	r26, 0x04	; 4
    9b4a:	2d 93       	st	X+, r18
    9b4c:	3c 93       	st	X, r19
    9b4e:	15 97       	sbiw	r26, 0x05	; 5
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    9b50:	31 97       	sbiw	r30, 0x01	; 1
    9b52:	e8 9f       	mul	r30, r24
    9b54:	a0 01       	movw	r20, r0
    9b56:	e9 9f       	mul	r30, r25
    9b58:	50 0d       	add	r21, r0
    9b5a:	f8 9f       	mul	r31, r24
    9b5c:	50 0d       	add	r21, r0
    9b5e:	11 24       	eor	r1, r1
    9b60:	42 0f       	add	r20, r18
    9b62:	53 1f       	adc	r21, r19
    9b64:	16 96       	adiw	r26, 0x06	; 6
    9b66:	4d 93       	st	X+, r20
    9b68:	5c 93       	st	X, r21
    9b6a:	17 97       	sbiw	r26, 0x07	; 7
				pxNewQueue->uxLength = uxQueueLength;
    9b6c:	5b 96       	adiw	r26, 0x1b	; 27
    9b6e:	1c 93       	st	X, r17
    9b70:	5b 97       	sbiw	r26, 0x1b	; 27
				pxNewQueue->uxItemSize = uxItemSize;
    9b72:	5c 96       	adiw	r26, 0x1c	; 28
    9b74:	6c 93       	st	X, r22
    9b76:	5c 97       	sbiw	r26, 0x1c	; 28
				pxNewQueue->xRxLock = queueUNLOCKED;
    9b78:	8f ef       	ldi	r24, 0xFF	; 255
    9b7a:	5d 96       	adiw	r26, 0x1d	; 29
    9b7c:	8c 93       	st	X, r24
    9b7e:	5d 97       	sbiw	r26, 0x1d	; 29
				pxNewQueue->xTxLock = queueUNLOCKED;
    9b80:	5e 96       	adiw	r26, 0x1e	; 30
    9b82:	8c 93       	st	X, r24

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    9b84:	c6 01       	movw	r24, r12
    9b86:	08 96       	adiw	r24, 0x08	; 8
    9b88:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    9b8c:	c6 01       	movw	r24, r12
    9b8e:	41 96       	adiw	r24, 0x11	; 17
    9b90:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    9b94:	05 c0       	rjmp	.+10     	; 0x9ba0 <xQueueCreateExternal+0xcc>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    9b96:	c6 01       	movw	r24, r12
    9b98:	0e 94 d9 52 	call	0xa5b2	; 0xa5b2 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    9b9c:	cc 24       	eor	r12, r12
    9b9e:	dd 24       	eor	r13, r13
}
    9ba0:	c6 01       	movw	r24, r12
    9ba2:	23 96       	adiw	r28, 0x03	; 3
    9ba4:	cd bf       	out	0x3d, r28	; 61
    9ba6:	de bf       	out	0x3e, r29	; 62
    9ba8:	cf 91       	pop	r28
    9baa:	df 91       	pop	r29
    9bac:	1f 91       	pop	r17
    9bae:	ff 90       	pop	r15
    9bb0:	ef 90       	pop	r14
    9bb2:	df 90       	pop	r13
    9bb4:	cf 90       	pop	r12
    9bb6:	08 95       	ret

00009bb8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    9bb8:	7f 92       	push	r7
    9bba:	8f 92       	push	r8
    9bbc:	9f 92       	push	r9
    9bbe:	af 92       	push	r10
    9bc0:	bf 92       	push	r11
    9bc2:	cf 92       	push	r12
    9bc4:	df 92       	push	r13
    9bc6:	ef 92       	push	r14
    9bc8:	ff 92       	push	r15
    9bca:	0f 93       	push	r16
    9bcc:	1f 93       	push	r17
    9bce:	df 93       	push	r29
    9bd0:	cf 93       	push	r28
    9bd2:	cd b7       	in	r28, 0x3d	; 61
    9bd4:	de b7       	in	r29, 0x3e	; 62
    9bd6:	25 97       	sbiw	r28, 0x05	; 5
    9bd8:	cd bf       	out	0x3d, r28	; 61
    9bda:	de bf       	out	0x3e, r29	; 62
    9bdc:	8c 01       	movw	r16, r24
    9bde:	6b 01       	movw	r12, r22
    9be0:	4c 83       	std	Y+4, r20	; 0x04
    9be2:	5d 83       	std	Y+5, r21	; 0x05
    9be4:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    9be6:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9be8:	7e 01       	movw	r14, r28
    9bea:	08 94       	sec
    9bec:	e1 1c       	adc	r14, r1
    9bee:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9bf0:	94 e0       	ldi	r25, 0x04	; 4
    9bf2:	a9 2e       	mov	r10, r25
    9bf4:	b1 2c       	mov	r11, r1
    9bf6:	ac 0e       	add	r10, r28
    9bf8:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    9bfa:	88 e0       	ldi	r24, 0x08	; 8
    9bfc:	88 2e       	mov	r8, r24
    9bfe:	91 2c       	mov	r9, r1
    9c00:	80 0e       	add	r8, r16
    9c02:	91 1e       	adc	r9, r17
    9c04:	01 c0       	rjmp	.+2      	; 0x9c08 <xQueueGenericSend+0x50>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    9c06:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    9c08:	0f b6       	in	r0, 0x3f	; 63
    9c0a:	f8 94       	cli
    9c0c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    9c0e:	f8 01       	movw	r30, r16
    9c10:	92 8d       	ldd	r25, Z+26	; 0x1a
    9c12:	83 8d       	ldd	r24, Z+27	; 0x1b
    9c14:	98 17       	cp	r25, r24
    9c16:	08 f0       	brcs	.+2      	; 0x9c1a <xQueueGenericSend+0x62>
    9c18:	4e c0       	rjmp	.+156    	; 0x9cb6 <xQueueGenericSend+0xfe>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    9c1a:	44 8d       	ldd	r20, Z+28	; 0x1c
    9c1c:	44 23       	and	r20, r20
    9c1e:	c1 f1       	breq	.+112    	; 0x9c90 <xQueueGenericSend+0xd8>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    9c20:	77 20       	and	r7, r7
    9c22:	c1 f4       	brne	.+48     	; 0x9c54 <xQueueGenericSend+0x9c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9c24:	84 81       	ldd	r24, Z+4	; 0x04
    9c26:	95 81       	ldd	r25, Z+5	; 0x05
    9c28:	b6 01       	movw	r22, r12
    9c2a:	50 e0       	ldi	r21, 0x00	; 0
    9c2c:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    9c30:	f8 01       	movw	r30, r16
    9c32:	24 8d       	ldd	r18, Z+28	; 0x1c
    9c34:	84 81       	ldd	r24, Z+4	; 0x04
    9c36:	95 81       	ldd	r25, Z+5	; 0x05
    9c38:	82 0f       	add	r24, r18
    9c3a:	91 1d       	adc	r25, r1
    9c3c:	84 83       	std	Z+4, r24	; 0x04
    9c3e:	95 83       	std	Z+5, r25	; 0x05
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    9c40:	22 81       	ldd	r18, Z+2	; 0x02
    9c42:	33 81       	ldd	r19, Z+3	; 0x03
    9c44:	82 17       	cp	r24, r18
    9c46:	93 07       	cpc	r25, r19
    9c48:	18 f1       	brcs	.+70     	; 0x9c90 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    9c4a:	80 81       	ld	r24, Z
    9c4c:	91 81       	ldd	r25, Z+1	; 0x01
    9c4e:	84 83       	std	Z+4, r24	; 0x04
    9c50:	95 83       	std	Z+5, r25	; 0x05
    9c52:	1e c0       	rjmp	.+60     	; 0x9c90 <xQueueGenericSend+0xd8>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9c54:	f8 01       	movw	r30, r16
    9c56:	86 81       	ldd	r24, Z+6	; 0x06
    9c58:	97 81       	ldd	r25, Z+7	; 0x07
    9c5a:	b6 01       	movw	r22, r12
    9c5c:	50 e0       	ldi	r21, 0x00	; 0
    9c5e:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    9c62:	f8 01       	movw	r30, r16
    9c64:	24 8d       	ldd	r18, Z+28	; 0x1c
    9c66:	30 e0       	ldi	r19, 0x00	; 0
    9c68:	30 95       	com	r19
    9c6a:	21 95       	neg	r18
    9c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    9c6e:	86 81       	ldd	r24, Z+6	; 0x06
    9c70:	97 81       	ldd	r25, Z+7	; 0x07
    9c72:	82 0f       	add	r24, r18
    9c74:	93 1f       	adc	r25, r19
    9c76:	86 83       	std	Z+6, r24	; 0x06
    9c78:	97 83       	std	Z+7, r25	; 0x07
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    9c7a:	40 81       	ld	r20, Z
    9c7c:	51 81       	ldd	r21, Z+1	; 0x01
    9c7e:	84 17       	cp	r24, r20
    9c80:	95 07       	cpc	r25, r21
    9c82:	30 f4       	brcc	.+12     	; 0x9c90 <xQueueGenericSend+0xd8>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    9c84:	82 81       	ldd	r24, Z+2	; 0x02
    9c86:	93 81       	ldd	r25, Z+3	; 0x03
    9c88:	82 0f       	add	r24, r18
    9c8a:	93 1f       	adc	r25, r19
    9c8c:	86 83       	std	Z+6, r24	; 0x06
    9c8e:	97 83       	std	Z+7, r25	; 0x07
		}
	}

	++( pxQueue->uxMessagesWaiting );
    9c90:	f8 01       	movw	r30, r16
    9c92:	82 8d       	ldd	r24, Z+26	; 0x1a
    9c94:	8f 5f       	subi	r24, 0xFF	; 255
    9c96:	82 8f       	std	Z+26, r24	; 0x1a
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    9c98:	81 89       	ldd	r24, Z+17	; 0x11
    9c9a:	88 23       	and	r24, r24
    9c9c:	41 f0       	breq	.+16     	; 0x9cae <xQueueGenericSend+0xf6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    9c9e:	c8 01       	movw	r24, r16
    9ca0:	41 96       	adiw	r24, 0x11	; 17
    9ca2:	0e 94 35 4c 	call	0x986a	; 0x986a <xTaskRemoveFromEventList>
    9ca6:	81 30       	cpi	r24, 0x01	; 1
    9ca8:	11 f4       	brne	.+4      	; 0x9cae <xQueueGenericSend+0xf6>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    9caa:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    9cae:	0f 90       	pop	r0
    9cb0:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    9cb2:	81 e0       	ldi	r24, 0x01	; 1
    9cb4:	4c c0       	rjmp	.+152    	; 0x9d4e <xQueueGenericSend+0x196>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    9cb6:	8c 81       	ldd	r24, Y+4	; 0x04
    9cb8:	9d 81       	ldd	r25, Y+5	; 0x05
    9cba:	00 97       	sbiw	r24, 0x00	; 0
    9cbc:	19 f4       	brne	.+6      	; 0x9cc4 <xQueueGenericSend+0x10c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    9cbe:	0f 90       	pop	r0
    9cc0:	0f be       	out	0x3f, r0	; 63
    9cc2:	44 c0       	rjmp	.+136    	; 0x9d4c <xQueueGenericSend+0x194>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    9cc4:	22 23       	and	r18, r18
    9cc6:	19 f4       	brne	.+6      	; 0x9cce <xQueueGenericSend+0x116>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9cc8:	c7 01       	movw	r24, r14
    9cca:	0e 94 7c 4c 	call	0x98f8	; 0x98f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    9cce:	0f 90       	pop	r0
    9cd0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    9cd2:	0e 94 1e 49 	call	0x923c	; 0x923c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    9cd6:	0f b6       	in	r0, 0x3f	; 63
    9cd8:	f8 94       	cli
    9cda:	0f 92       	push	r0
    9cdc:	f8 01       	movw	r30, r16
    9cde:	85 8d       	ldd	r24, Z+29	; 0x1d
    9ce0:	8f 3f       	cpi	r24, 0xFF	; 255
    9ce2:	09 f4       	brne	.+2      	; 0x9ce6 <xQueueGenericSend+0x12e>
    9ce4:	15 8e       	std	Z+29, r1	; 0x1d
    9ce6:	f8 01       	movw	r30, r16
    9ce8:	86 8d       	ldd	r24, Z+30	; 0x1e
    9cea:	8f 3f       	cpi	r24, 0xFF	; 255
    9cec:	09 f4       	brne	.+2      	; 0x9cf0 <xQueueGenericSend+0x138>
    9cee:	16 8e       	std	Z+30, r1	; 0x1e
    9cf0:	0f 90       	pop	r0
    9cf2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9cf4:	c7 01       	movw	r24, r14
    9cf6:	b5 01       	movw	r22, r10
    9cf8:	0e 94 87 4c 	call	0x990e	; 0x990e <xTaskCheckForTimeOut>
    9cfc:	88 23       	and	r24, r24
    9cfe:	09 f5       	brne	.+66     	; 0x9d42 <xQueueGenericSend+0x18a>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    9d00:	0f b6       	in	r0, 0x3f	; 63
    9d02:	f8 94       	cli
    9d04:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    9d06:	f8 01       	movw	r30, r16
    9d08:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9d0a:	0f 90       	pop	r0
    9d0c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    9d0e:	f8 01       	movw	r30, r16
    9d10:	83 8d       	ldd	r24, Z+27	; 0x1b
    9d12:	98 17       	cp	r25, r24
    9d14:	81 f4       	brne	.+32     	; 0x9d36 <xQueueGenericSend+0x17e>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    9d16:	6c 81       	ldd	r22, Y+4	; 0x04
    9d18:	7d 81       	ldd	r23, Y+5	; 0x05
    9d1a:	c4 01       	movw	r24, r8
    9d1c:	0e 94 ed 4b 	call	0x97da	; 0x97da <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    9d20:	c8 01       	movw	r24, r16
    9d22:	0e 94 ca 4c 	call	0x9994	; 0x9994 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    9d26:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
    9d2a:	88 23       	and	r24, r24
    9d2c:	09 f0       	breq	.+2      	; 0x9d30 <xQueueGenericSend+0x178>
    9d2e:	6b cf       	rjmp	.-298    	; 0x9c06 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    9d30:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
    9d34:	68 cf       	rjmp	.-304    	; 0x9c06 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    9d36:	c8 01       	movw	r24, r16
    9d38:	0e 94 ca 4c 	call	0x9994	; 0x9994 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    9d3c:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
    9d40:	62 cf       	rjmp	.-316    	; 0x9c06 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    9d42:	c8 01       	movw	r24, r16
    9d44:	0e 94 ca 4c 	call	0x9994	; 0x9994 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    9d48:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    9d4c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    9d4e:	25 96       	adiw	r28, 0x05	; 5
    9d50:	cd bf       	out	0x3d, r28	; 61
    9d52:	de bf       	out	0x3e, r29	; 62
    9d54:	cf 91       	pop	r28
    9d56:	df 91       	pop	r29
    9d58:	1f 91       	pop	r17
    9d5a:	0f 91       	pop	r16
    9d5c:	ff 90       	pop	r15
    9d5e:	ef 90       	pop	r14
    9d60:	df 90       	pop	r13
    9d62:	cf 90       	pop	r12
    9d64:	bf 90       	pop	r11
    9d66:	af 90       	pop	r10
    9d68:	9f 90       	pop	r9
    9d6a:	8f 90       	pop	r8
    9d6c:	7f 90       	pop	r7
    9d6e:	08 95       	ret

00009d70 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    9d70:	0f 93       	push	r16
    9d72:	1f 93       	push	r17
    9d74:	cf 93       	push	r28
    9d76:	df 93       	push	r29
    9d78:	ec 01       	movw	r28, r24
    9d7a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    9d7c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9d7e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    9d80:	98 17       	cp	r25, r24
    9d82:	08 f0       	brcs	.+2      	; 0x9d86 <xQueueGenericSendFromISR+0x16>
    9d84:	4c c0       	rjmp	.+152    	; 0x9e1e <xQueueGenericSendFromISR+0xae>
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    9d86:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9d88:	44 23       	and	r20, r20
    9d8a:	99 f1       	breq	.+102    	; 0x9df2 <xQueueGenericSendFromISR+0x82>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    9d8c:	22 23       	and	r18, r18
    9d8e:	b1 f4       	brne	.+44     	; 0x9dbc <xQueueGenericSendFromISR+0x4c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9d90:	8c 81       	ldd	r24, Y+4	; 0x04
    9d92:	9d 81       	ldd	r25, Y+5	; 0x05
    9d94:	50 e0       	ldi	r21, 0x00	; 0
    9d96:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    9d9a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9d9c:	8c 81       	ldd	r24, Y+4	; 0x04
    9d9e:	9d 81       	ldd	r25, Y+5	; 0x05
    9da0:	82 0f       	add	r24, r18
    9da2:	91 1d       	adc	r25, r1
    9da4:	8c 83       	std	Y+4, r24	; 0x04
    9da6:	9d 83       	std	Y+5, r25	; 0x05
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    9da8:	2a 81       	ldd	r18, Y+2	; 0x02
    9daa:	3b 81       	ldd	r19, Y+3	; 0x03
    9dac:	82 17       	cp	r24, r18
    9dae:	93 07       	cpc	r25, r19
    9db0:	00 f1       	brcs	.+64     	; 0x9df2 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    9db2:	88 81       	ld	r24, Y
    9db4:	99 81       	ldd	r25, Y+1	; 0x01
    9db6:	8c 83       	std	Y+4, r24	; 0x04
    9db8:	9d 83       	std	Y+5, r25	; 0x05
    9dba:	1b c0       	rjmp	.+54     	; 0x9df2 <xQueueGenericSendFromISR+0x82>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    9dbc:	8e 81       	ldd	r24, Y+6	; 0x06
    9dbe:	9f 81       	ldd	r25, Y+7	; 0x07
    9dc0:	50 e0       	ldi	r21, 0x00	; 0
    9dc2:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    9dc6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9dc8:	30 e0       	ldi	r19, 0x00	; 0
    9dca:	30 95       	com	r19
    9dcc:	21 95       	neg	r18
    9dce:	3f 4f       	sbci	r19, 0xFF	; 255
    9dd0:	8e 81       	ldd	r24, Y+6	; 0x06
    9dd2:	9f 81       	ldd	r25, Y+7	; 0x07
    9dd4:	82 0f       	add	r24, r18
    9dd6:	93 1f       	adc	r25, r19
    9dd8:	8e 83       	std	Y+6, r24	; 0x06
    9dda:	9f 83       	std	Y+7, r25	; 0x07
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    9ddc:	48 81       	ld	r20, Y
    9dde:	59 81       	ldd	r21, Y+1	; 0x01
    9de0:	84 17       	cp	r24, r20
    9de2:	95 07       	cpc	r25, r21
    9de4:	30 f4       	brcc	.+12     	; 0x9df2 <xQueueGenericSendFromISR+0x82>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    9de6:	8a 81       	ldd	r24, Y+2	; 0x02
    9de8:	9b 81       	ldd	r25, Y+3	; 0x03
    9dea:	82 0f       	add	r24, r18
    9dec:	93 1f       	adc	r25, r19
    9dee:	8e 83       	std	Y+6, r24	; 0x06
    9df0:	9f 83       	std	Y+7, r25	; 0x07
		}
	}

	++( pxQueue->uxMessagesWaiting );
    9df2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9df4:	8f 5f       	subi	r24, 0xFF	; 255
    9df6:	8a 8f       	std	Y+26, r24	; 0x1a

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    9df8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9dfa:	8f 3f       	cpi	r24, 0xFF	; 255
    9dfc:	69 f4       	brne	.+26     	; 0x9e18 <xQueueGenericSendFromISR+0xa8>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9dfe:	89 89       	ldd	r24, Y+17	; 0x11
    9e00:	88 23       	and	r24, r24
    9e02:	79 f0       	breq	.+30     	; 0x9e22 <xQueueGenericSendFromISR+0xb2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    9e04:	ce 01       	movw	r24, r28
    9e06:	41 96       	adiw	r24, 0x11	; 17
    9e08:	0e 94 35 4c 	call	0x986a	; 0x986a <xTaskRemoveFromEventList>
    9e0c:	88 23       	and	r24, r24
    9e0e:	49 f0       	breq	.+18     	; 0x9e22 <xQueueGenericSendFromISR+0xb2>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    9e10:	81 e0       	ldi	r24, 0x01	; 1
    9e12:	f8 01       	movw	r30, r16
    9e14:	80 83       	st	Z, r24
    9e16:	06 c0       	rjmp	.+12     	; 0x9e24 <xQueueGenericSendFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    9e18:	8f 5f       	subi	r24, 0xFF	; 255
    9e1a:	8e 8f       	std	Y+30, r24	; 0x1e
    9e1c:	02 c0       	rjmp	.+4      	; 0x9e22 <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    9e1e:	80 e0       	ldi	r24, 0x00	; 0
    9e20:	01 c0       	rjmp	.+2      	; 0x9e24 <xQueueGenericSendFromISR+0xb4>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    9e22:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    9e24:	df 91       	pop	r29
    9e26:	cf 91       	pop	r28
    9e28:	1f 91       	pop	r17
    9e2a:	0f 91       	pop	r16
    9e2c:	08 95       	ret

00009e2e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    9e2e:	7f 92       	push	r7
    9e30:	8f 92       	push	r8
    9e32:	9f 92       	push	r9
    9e34:	af 92       	push	r10
    9e36:	bf 92       	push	r11
    9e38:	cf 92       	push	r12
    9e3a:	df 92       	push	r13
    9e3c:	ef 92       	push	r14
    9e3e:	ff 92       	push	r15
    9e40:	0f 93       	push	r16
    9e42:	1f 93       	push	r17
    9e44:	df 93       	push	r29
    9e46:	cf 93       	push	r28
    9e48:	cd b7       	in	r28, 0x3d	; 61
    9e4a:	de b7       	in	r29, 0x3e	; 62
    9e4c:	25 97       	sbiw	r28, 0x05	; 5
    9e4e:	cd bf       	out	0x3d, r28	; 61
    9e50:	de bf       	out	0x3e, r29	; 62
    9e52:	8c 01       	movw	r16, r24
    9e54:	86 2e       	mov	r8, r22
    9e56:	77 2e       	mov	r7, r23
    9e58:	4c 83       	std	Y+4, r20	; 0x04
    9e5a:	5d 83       	std	Y+5, r21	; 0x05
    9e5c:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    9e5e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9e60:	7e 01       	movw	r14, r28
    9e62:	08 94       	sec
    9e64:	e1 1c       	adc	r14, r1
    9e66:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9e68:	44 e0       	ldi	r20, 0x04	; 4
    9e6a:	c4 2e       	mov	r12, r20
    9e6c:	d1 2c       	mov	r13, r1
    9e6e:	cc 0e       	add	r12, r28
    9e70:	dd 1e       	adc	r13, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    9e72:	31 e1       	ldi	r19, 0x11	; 17
    9e74:	a3 2e       	mov	r10, r19
    9e76:	b1 2c       	mov	r11, r1
    9e78:	a8 0e       	add	r10, r24
    9e7a:	b9 1e       	adc	r11, r25
    9e7c:	01 c0       	rjmp	.+2      	; 0x9e80 <xQueueGenericReceive+0x52>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    9e7e:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    9e80:	0f b6       	in	r0, 0x3f	; 63
    9e82:	f8 94       	cli
    9e84:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    9e86:	f8 01       	movw	r30, r16
    9e88:	82 8d       	ldd	r24, Z+26	; 0x1a
    9e8a:	88 23       	and	r24, r24
    9e8c:	09 f4       	brne	.+2      	; 0x9e90 <xQueueGenericReceive+0x62>
    9e8e:	3d c0       	rjmp	.+122    	; 0x9f0a <xQueueGenericReceive+0xdc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    9e90:	e6 80       	ldd	r14, Z+6	; 0x06
    9e92:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    9e94:	80 81       	ld	r24, Z
    9e96:	91 81       	ldd	r25, Z+1	; 0x01
    9e98:	00 97       	sbiw	r24, 0x00	; 0
    9e9a:	a9 f0       	breq	.+42     	; 0x9ec6 <xQueueGenericReceive+0x98>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    9e9c:	44 8d       	ldd	r20, Z+28	; 0x1c
    9e9e:	97 01       	movw	r18, r14
    9ea0:	24 0f       	add	r18, r20
    9ea2:	31 1d       	adc	r19, r1
    9ea4:	26 83       	std	Z+6, r18	; 0x06
    9ea6:	37 83       	std	Z+7, r19	; 0x07
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    9ea8:	62 81       	ldd	r22, Z+2	; 0x02
    9eaa:	73 81       	ldd	r23, Z+3	; 0x03
    9eac:	26 17       	cp	r18, r22
    9eae:	37 07       	cpc	r19, r23
    9eb0:	10 f0       	brcs	.+4      	; 0x9eb6 <xQueueGenericReceive+0x88>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    9eb2:	86 83       	std	Z+6, r24	; 0x06
    9eb4:	97 83       	std	Z+7, r25	; 0x07
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    9eb6:	f8 01       	movw	r30, r16
    9eb8:	66 81       	ldd	r22, Z+6	; 0x06
    9eba:	77 81       	ldd	r23, Z+7	; 0x07
    9ebc:	88 2d       	mov	r24, r8
    9ebe:	97 2d       	mov	r25, r7
    9ec0:	50 e0       	ldi	r21, 0x00	; 0
    9ec2:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    9ec6:	99 20       	and	r9, r9
    9ec8:	71 f4       	brne	.+28     	; 0x9ee6 <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    9eca:	f8 01       	movw	r30, r16
    9ecc:	82 8d       	ldd	r24, Z+26	; 0x1a
    9ece:	81 50       	subi	r24, 0x01	; 1
    9ed0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    9ed2:	80 85       	ldd	r24, Z+8	; 0x08
    9ed4:	88 23       	and	r24, r24
    9ed6:	a9 f0       	breq	.+42     	; 0x9f02 <xQueueGenericReceive+0xd4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    9ed8:	c8 01       	movw	r24, r16
    9eda:	08 96       	adiw	r24, 0x08	; 8
    9edc:	0e 94 35 4c 	call	0x986a	; 0x986a <xTaskRemoveFromEventList>
    9ee0:	81 30       	cpi	r24, 0x01	; 1
    9ee2:	79 f4       	brne	.+30     	; 0x9f02 <xQueueGenericReceive+0xd4>
    9ee4:	0c c0       	rjmp	.+24     	; 0x9efe <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    9ee6:	f8 01       	movw	r30, r16
    9ee8:	e6 82       	std	Z+6, r14	; 0x06
    9eea:	f7 82       	std	Z+7, r15	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    9eec:	81 89       	ldd	r24, Z+17	; 0x11
    9eee:	88 23       	and	r24, r24
    9ef0:	41 f0       	breq	.+16     	; 0x9f02 <xQueueGenericReceive+0xd4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    9ef2:	c8 01       	movw	r24, r16
    9ef4:	41 96       	adiw	r24, 0x11	; 17
    9ef6:	0e 94 35 4c 	call	0x986a	; 0x986a <xTaskRemoveFromEventList>
    9efa:	88 23       	and	r24, r24
    9efc:	11 f0       	breq	.+4      	; 0x9f02 <xQueueGenericReceive+0xd4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    9efe:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    9f02:	0f 90       	pop	r0
    9f04:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    9f06:	81 e0       	ldi	r24, 0x01	; 1
    9f08:	4a c0       	rjmp	.+148    	; 0x9f9e <xQueueGenericReceive+0x170>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    9f0a:	8c 81       	ldd	r24, Y+4	; 0x04
    9f0c:	9d 81       	ldd	r25, Y+5	; 0x05
    9f0e:	00 97       	sbiw	r24, 0x00	; 0
    9f10:	19 f4       	brne	.+6      	; 0x9f18 <xQueueGenericReceive+0xea>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    9f12:	0f 90       	pop	r0
    9f14:	0f be       	out	0x3f, r0	; 63
    9f16:	42 c0       	rjmp	.+132    	; 0x9f9c <xQueueGenericReceive+0x16e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    9f18:	22 23       	and	r18, r18
    9f1a:	19 f4       	brne	.+6      	; 0x9f22 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    9f1c:	c7 01       	movw	r24, r14
    9f1e:	0e 94 7c 4c 	call	0x98f8	; 0x98f8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    9f22:	0f 90       	pop	r0
    9f24:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    9f26:	0e 94 1e 49 	call	0x923c	; 0x923c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    9f2a:	0f b6       	in	r0, 0x3f	; 63
    9f2c:	f8 94       	cli
    9f2e:	0f 92       	push	r0
    9f30:	f8 01       	movw	r30, r16
    9f32:	85 8d       	ldd	r24, Z+29	; 0x1d
    9f34:	8f 3f       	cpi	r24, 0xFF	; 255
    9f36:	09 f4       	brne	.+2      	; 0x9f3a <xQueueGenericReceive+0x10c>
    9f38:	15 8e       	std	Z+29, r1	; 0x1d
    9f3a:	f8 01       	movw	r30, r16
    9f3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    9f3e:	8f 3f       	cpi	r24, 0xFF	; 255
    9f40:	09 f4       	brne	.+2      	; 0x9f44 <xQueueGenericReceive+0x116>
    9f42:	16 8e       	std	Z+30, r1	; 0x1e
    9f44:	0f 90       	pop	r0
    9f46:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    9f48:	c7 01       	movw	r24, r14
    9f4a:	b6 01       	movw	r22, r12
    9f4c:	0e 94 87 4c 	call	0x990e	; 0x990e <xTaskCheckForTimeOut>
    9f50:	88 23       	and	r24, r24
    9f52:	f9 f4       	brne	.+62     	; 0x9f92 <xQueueGenericReceive+0x164>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    9f54:	0f b6       	in	r0, 0x3f	; 63
    9f56:	f8 94       	cli
    9f58:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    9f5a:	f8 01       	movw	r30, r16
    9f5c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9f5e:	0f 90       	pop	r0
    9f60:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    9f62:	88 23       	and	r24, r24
    9f64:	81 f4       	brne	.+32     	; 0x9f86 <xQueueGenericReceive+0x158>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    9f66:	6c 81       	ldd	r22, Y+4	; 0x04
    9f68:	7d 81       	ldd	r23, Y+5	; 0x05
    9f6a:	c5 01       	movw	r24, r10
    9f6c:	0e 94 ed 4b 	call	0x97da	; 0x97da <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    9f70:	c8 01       	movw	r24, r16
    9f72:	0e 94 ca 4c 	call	0x9994	; 0x9994 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    9f76:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
    9f7a:	88 23       	and	r24, r24
    9f7c:	09 f0       	breq	.+2      	; 0x9f80 <xQueueGenericReceive+0x152>
    9f7e:	7f cf       	rjmp	.-258    	; 0x9e7e <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    9f80:	0e 94 8c 53 	call	0xa718	; 0xa718 <vPortYield>
    9f84:	7c cf       	rjmp	.-264    	; 0x9e7e <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    9f86:	c8 01       	movw	r24, r16
    9f88:	0e 94 ca 4c 	call	0x9994	; 0x9994 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    9f8c:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
    9f90:	76 cf       	rjmp	.-276    	; 0x9e7e <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    9f92:	c8 01       	movw	r24, r16
    9f94:	0e 94 ca 4c 	call	0x9994	; 0x9994 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    9f98:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    9f9c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    9f9e:	25 96       	adiw	r28, 0x05	; 5
    9fa0:	cd bf       	out	0x3d, r28	; 61
    9fa2:	de bf       	out	0x3e, r29	; 62
    9fa4:	cf 91       	pop	r28
    9fa6:	df 91       	pop	r29
    9fa8:	1f 91       	pop	r17
    9faa:	0f 91       	pop	r16
    9fac:	ff 90       	pop	r15
    9fae:	ef 90       	pop	r14
    9fb0:	df 90       	pop	r13
    9fb2:	cf 90       	pop	r12
    9fb4:	bf 90       	pop	r11
    9fb6:	af 90       	pop	r10
    9fb8:	9f 90       	pop	r9
    9fba:	8f 90       	pop	r8
    9fbc:	7f 90       	pop	r7
    9fbe:	08 95       	ret

00009fc0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    9fc0:	0f 93       	push	r16
    9fc2:	1f 93       	push	r17
    9fc4:	cf 93       	push	r28
    9fc6:	df 93       	push	r29
    9fc8:	ec 01       	movw	r28, r24
    9fca:	cb 01       	movw	r24, r22
    9fcc:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    9fce:	2a 8d       	ldd	r18, Y+26	; 0x1a
    9fd0:	22 23       	and	r18, r18
    9fd2:	71 f1       	breq	.+92     	; 0xa030 <xQueueReceiveFromISR+0x70>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    9fd4:	e8 81       	ld	r30, Y
    9fd6:	f9 81       	ldd	r31, Y+1	; 0x01
    9fd8:	30 97       	sbiw	r30, 0x00	; 0
    9fda:	a1 f0       	breq	.+40     	; 0xa004 <xQueueReceiveFromISR+0x44>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    9fdc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    9fde:	2e 81       	ldd	r18, Y+6	; 0x06
    9fe0:	3f 81       	ldd	r19, Y+7	; 0x07
    9fe2:	24 0f       	add	r18, r20
    9fe4:	31 1d       	adc	r19, r1
    9fe6:	2e 83       	std	Y+6, r18	; 0x06
    9fe8:	3f 83       	std	Y+7, r19	; 0x07
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    9fea:	aa 81       	ldd	r26, Y+2	; 0x02
    9fec:	bb 81       	ldd	r27, Y+3	; 0x03
    9fee:	2a 17       	cp	r18, r26
    9ff0:	3b 07       	cpc	r19, r27
    9ff2:	10 f0       	brcs	.+4      	; 0x9ff8 <xQueueReceiveFromISR+0x38>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    9ff4:	ee 83       	std	Y+6, r30	; 0x06
    9ff6:	ff 83       	std	Y+7, r31	; 0x07
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    9ff8:	6e 81       	ldd	r22, Y+6	; 0x06
    9ffa:	2f 81       	ldd	r18, Y+7	; 0x07
    9ffc:	72 2f       	mov	r23, r18
    9ffe:	50 e0       	ldi	r21, 0x00	; 0
    a000:	0e 94 15 57 	call	0xae2a	; 0xae2a <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    a004:	8a 8d       	ldd	r24, Y+26	; 0x1a
    a006:	81 50       	subi	r24, 0x01	; 1
    a008:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    a00a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a00c:	8f 3f       	cpi	r24, 0xFF	; 255
    a00e:	69 f4       	brne	.+26     	; 0xa02a <xQueueReceiveFromISR+0x6a>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    a010:	88 85       	ldd	r24, Y+8	; 0x08
    a012:	88 23       	and	r24, r24
    a014:	79 f0       	breq	.+30     	; 0xa034 <xQueueReceiveFromISR+0x74>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    a016:	ce 01       	movw	r24, r28
    a018:	08 96       	adiw	r24, 0x08	; 8
    a01a:	0e 94 35 4c 	call	0x986a	; 0x986a <xTaskRemoveFromEventList>
    a01e:	88 23       	and	r24, r24
    a020:	49 f0       	breq	.+18     	; 0xa034 <xQueueReceiveFromISR+0x74>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    a022:	81 e0       	ldi	r24, 0x01	; 1
    a024:	f8 01       	movw	r30, r16
    a026:	80 83       	st	Z, r24
    a028:	06 c0       	rjmp	.+12     	; 0xa036 <xQueueReceiveFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    a02a:	8f 5f       	subi	r24, 0xFF	; 255
    a02c:	8d 8f       	std	Y+29, r24	; 0x1d
    a02e:	02 c0       	rjmp	.+4      	; 0xa034 <xQueueReceiveFromISR+0x74>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    a030:	80 e0       	ldi	r24, 0x00	; 0
    a032:	01 c0       	rjmp	.+2      	; 0xa036 <xQueueReceiveFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    a034:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    a036:	df 91       	pop	r29
    a038:	cf 91       	pop	r28
    a03a:	1f 91       	pop	r17
    a03c:	0f 91       	pop	r16
    a03e:	08 95       	ret

0000a040 <uxQueueMessagesWaiting>:

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    a040:	0f b6       	in	r0, 0x3f	; 63
    a042:	f8 94       	cli
    a044:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    a046:	fc 01       	movw	r30, r24
    a048:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    a04a:	0f 90       	pop	r0
    a04c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    a04e:	08 95       	ret

0000a050 <uxQueueMessagesWaitingFromISR>:

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    a050:	fc 01       	movw	r30, r24
    a052:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    a054:	08 95       	ret

0000a056 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    a056:	cf 93       	push	r28
    a058:	df 93       	push	r29
    a05a:	ec 01       	movw	r28, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    a05c:	88 81       	ld	r24, Y
    a05e:	99 81       	ldd	r25, Y+1	; 0x01
    a060:	0e 94 d9 52 	call	0xa5b2	; 0xa5b2 <vPortFree>
	vPortFree( pxQueue );
    a064:	ce 01       	movw	r24, r28
    a066:	0e 94 d9 52 	call	0xa5b2	; 0xa5b2 <vPortFree>
}
    a06a:	df 91       	pop	r29
    a06c:	cf 91       	pop	r28
    a06e:	08 95       	ret

0000a070 <xQueueIsQueueEmptyFromISR>:

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    a070:	fc 01       	movw	r30, r24
    a072:	92 8d       	ldd	r25, Z+26	; 0x1a
    a074:	81 e0       	ldi	r24, 0x01	; 1
    a076:	91 11       	cpse	r25, r1
    a078:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    a07a:	08 95       	ret

0000a07c <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    a07c:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    a07e:	22 8d       	ldd	r18, Z+26	; 0x1a
    a080:	81 e0       	ldi	r24, 0x01	; 1
    a082:	93 8d       	ldd	r25, Z+27	; 0x1b
    a084:	29 13       	cpse	r18, r25
    a086:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    a088:	08 95       	ret

0000a08a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    a08a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    a08c:	03 96       	adiw	r24, 0x03	; 3
    a08e:	81 83       	std	Z+1, r24	; 0x01
    a090:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    a092:	2f ef       	ldi	r18, 0xFF	; 255
    a094:	3f ef       	ldi	r19, 0xFF	; 255
    a096:	23 83       	std	Z+3, r18	; 0x03
    a098:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    a09a:	85 83       	std	Z+5, r24	; 0x05
    a09c:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    a09e:	87 83       	std	Z+7, r24	; 0x07
    a0a0:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = 0;
    a0a2:	10 82       	st	Z, r1
}
    a0a4:	08 95       	ret

0000a0a6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    a0a6:	fc 01       	movw	r30, r24
    a0a8:	10 86       	std	Z+8, r1	; 0x08
    a0aa:	11 86       	std	Z+9, r1	; 0x09
}
    a0ac:	08 95       	ret

0000a0ae <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    a0ae:	cf 93       	push	r28
    a0b0:	df 93       	push	r29
    a0b2:	fc 01       	movw	r30, r24
    a0b4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    a0b6:	21 81       	ldd	r18, Z+1	; 0x01
    a0b8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    a0ba:	e9 01       	movw	r28, r18
    a0bc:	8a 81       	ldd	r24, Y+2	; 0x02
    a0be:	9b 81       	ldd	r25, Y+3	; 0x03
    a0c0:	12 96       	adiw	r26, 0x02	; 2
    a0c2:	8d 93       	st	X+, r24
    a0c4:	9c 93       	st	X, r25
    a0c6:	13 97       	sbiw	r26, 0x03	; 3
	pxNewListItem->pxPrevious = pxList->pxIndex;
    a0c8:	14 96       	adiw	r26, 0x04	; 4
    a0ca:	2d 93       	st	X+, r18
    a0cc:	3c 93       	st	X, r19
    a0ce:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a0d0:	8a 81       	ldd	r24, Y+2	; 0x02
    a0d2:	9b 81       	ldd	r25, Y+3	; 0x03
    a0d4:	ec 01       	movw	r28, r24
    a0d6:	6c 83       	std	Y+4, r22	; 0x04
    a0d8:	7d 83       	std	Y+5, r23	; 0x05
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    a0da:	e9 01       	movw	r28, r18
    a0dc:	6a 83       	std	Y+2, r22	; 0x02
    a0de:	7b 83       	std	Y+3, r23	; 0x03
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    a0e0:	61 83       	std	Z+1, r22	; 0x01
    a0e2:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a0e4:	18 96       	adiw	r26, 0x08	; 8
    a0e6:	ed 93       	st	X+, r30
    a0e8:	fc 93       	st	X, r31
    a0ea:	19 97       	sbiw	r26, 0x09	; 9

	( pxList->uxNumberOfItems )++;
    a0ec:	80 81       	ld	r24, Z
    a0ee:	8f 5f       	subi	r24, 0xFF	; 255
    a0f0:	80 83       	st	Z, r24
}
    a0f2:	df 91       	pop	r29
    a0f4:	cf 91       	pop	r28
    a0f6:	08 95       	ret

0000a0f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    a0f8:	cf 93       	push	r28
    a0fa:	df 93       	push	r29
    a0fc:	ac 01       	movw	r20, r24
    a0fe:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    a100:	88 81       	ld	r24, Y
    a102:	99 81       	ldd	r25, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    a104:	2f ef       	ldi	r18, 0xFF	; 255
    a106:	8f 3f       	cpi	r24, 0xFF	; 255
    a108:	92 07       	cpc	r25, r18
    a10a:	21 f4       	brne	.+8      	; 0xa114 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    a10c:	fa 01       	movw	r30, r20
    a10e:	a7 81       	ldd	r26, Z+7	; 0x07
    a110:	b0 85       	ldd	r27, Z+8	; 0x08
    a112:	11 c0       	rjmp	.+34     	; 0xa136 <vListInsert+0x3e>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    a114:	da 01       	movw	r26, r20
    a116:	13 96       	adiw	r26, 0x03	; 3
    a118:	04 c0       	rjmp	.+8      	; 0xa122 <vListInsert+0x2a>
    a11a:	12 96       	adiw	r26, 0x02	; 2
    a11c:	0d 90       	ld	r0, X+
    a11e:	bc 91       	ld	r27, X
    a120:	a0 2d       	mov	r26, r0
    a122:	12 96       	adiw	r26, 0x02	; 2
    a124:	2d 91       	ld	r18, X+
    a126:	3c 91       	ld	r19, X
    a128:	13 97       	sbiw	r26, 0x03	; 3
    a12a:	f9 01       	movw	r30, r18
    a12c:	20 81       	ld	r18, Z
    a12e:	31 81       	ldd	r19, Z+1	; 0x01
    a130:	82 17       	cp	r24, r18
    a132:	93 07       	cpc	r25, r19
    a134:	90 f7       	brcc	.-28     	; 0xa11a <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    a136:	12 96       	adiw	r26, 0x02	; 2
    a138:	8d 91       	ld	r24, X+
    a13a:	9c 91       	ld	r25, X
    a13c:	13 97       	sbiw	r26, 0x03	; 3
    a13e:	8a 83       	std	Y+2, r24	; 0x02
    a140:	9b 83       	std	Y+3, r25	; 0x03
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    a142:	fc 01       	movw	r30, r24
    a144:	c4 83       	std	Z+4, r28	; 0x04
    a146:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    a148:	ac 83       	std	Y+4, r26	; 0x04
    a14a:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    a14c:	12 96       	adiw	r26, 0x02	; 2
    a14e:	cd 93       	st	X+, r28
    a150:	dc 93       	st	X, r29
    a152:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    a154:	48 87       	std	Y+8, r20	; 0x08
    a156:	59 87       	std	Y+9, r21	; 0x09

	( pxList->uxNumberOfItems )++;
    a158:	fa 01       	movw	r30, r20
    a15a:	80 81       	ld	r24, Z
    a15c:	8f 5f       	subi	r24, 0xFF	; 255
    a15e:	80 83       	st	Z, r24
}
    a160:	df 91       	pop	r29
    a162:	cf 91       	pop	r28
    a164:	08 95       	ret

0000a166 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    a166:	cf 93       	push	r28
    a168:	df 93       	push	r29
    a16a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    a16c:	a2 81       	ldd	r26, Z+2	; 0x02
    a16e:	b3 81       	ldd	r27, Z+3	; 0x03
    a170:	84 81       	ldd	r24, Z+4	; 0x04
    a172:	95 81       	ldd	r25, Z+5	; 0x05
    a174:	14 96       	adiw	r26, 0x04	; 4
    a176:	8d 93       	st	X+, r24
    a178:	9c 93       	st	X, r25
    a17a:	15 97       	sbiw	r26, 0x05	; 5
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    a17c:	c4 81       	ldd	r28, Z+4	; 0x04
    a17e:	d5 81       	ldd	r29, Z+5	; 0x05
    a180:	aa 83       	std	Y+2, r26	; 0x02
    a182:	bb 83       	std	Y+3, r27	; 0x03
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    a184:	a0 85       	ldd	r26, Z+8	; 0x08
    a186:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    a188:	11 96       	adiw	r26, 0x01	; 1
    a18a:	8d 91       	ld	r24, X+
    a18c:	9c 91       	ld	r25, X
    a18e:	12 97       	sbiw	r26, 0x02	; 2
    a190:	8e 17       	cp	r24, r30
    a192:	9f 07       	cpc	r25, r31
    a194:	21 f4       	brne	.+8      	; 0xa19e <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    a196:	11 96       	adiw	r26, 0x01	; 1
    a198:	cd 93       	st	X+, r28
    a19a:	dc 93       	st	X, r29
    a19c:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    a19e:	10 86       	std	Z+8, r1	; 0x08
    a1a0:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    a1a2:	8c 91       	ld	r24, X
    a1a4:	81 50       	subi	r24, 0x01	; 1
    a1a6:	8c 93       	st	X, r24
}
    a1a8:	df 91       	pop	r29
    a1aa:	cf 91       	pop	r28
    a1ac:	08 95       	ret

0000a1ae <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    a1ae:	bf 92       	push	r11
    a1b0:	cf 92       	push	r12
    a1b2:	df 92       	push	r13
    a1b4:	ef 92       	push	r14
    a1b6:	ff 92       	push	r15
    a1b8:	0f 93       	push	r16
    a1ba:	1f 93       	push	r17
    a1bc:	cf 93       	push	r28
    a1be:	df 93       	push	r29
    a1c0:	6c 01       	movw	r12, r24
    a1c2:	b4 2e       	mov	r11, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    a1c4:	8a e1       	ldi	r24, 0x1A	; 26
    a1c6:	90 e0       	ldi	r25, 0x00	; 0
    a1c8:	0e 94 b0 52 	call	0xa560	; 0xa560 <pvPortMalloc>
    a1cc:	e8 2e       	mov	r14, r24
    a1ce:	e7 01       	movw	r28, r14
    a1d0:	7e 01       	movw	r14, r28
    a1d2:	f9 2e       	mov	r15, r25
    a1d4:	e7 01       	movw	r28, r14
	if( pxCoRoutine )
    a1d6:	20 97       	sbiw	r28, 0x00	; 0
    a1d8:	09 f4       	brne	.+2      	; 0xa1dc <xCoRoutineCreate+0x2e>
    a1da:	54 c0       	rjmp	.+168    	; 0xa284 <xCoRoutineCreate+0xd6>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    a1dc:	80 91 e0 25 	lds	r24, 0x25E0
    a1e0:	90 91 e1 25 	lds	r25, 0x25E1
    a1e4:	00 97       	sbiw	r24, 0x00	; 0
    a1e6:	01 f5       	brne	.+64     	; 0xa228 <xCoRoutineCreate+0x7a>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    a1e8:	e0 92 e0 25 	sts	0x25E0, r14
    a1ec:	f0 92 e1 25 	sts	0x25E1, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    a1f0:	8c ee       	ldi	r24, 0xEC	; 236
    a1f2:	95 e2       	ldi	r25, 0x25	; 37
    a1f4:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    a1f8:	5f ef       	ldi	r21, 0xFF	; 255
    a1fa:	e5 2e       	mov	r14, r21
    a1fc:	55 e2       	ldi	r21, 0x25	; 37
    a1fe:	f5 2e       	mov	r15, r21
    a200:	c7 01       	movw	r24, r14
    a202:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    a206:	08 e0       	ldi	r16, 0x08	; 8
    a208:	16 e2       	ldi	r17, 0x26	; 38
    a20a:	c8 01       	movw	r24, r16
    a20c:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    a210:	82 ee       	ldi	r24, 0xE2	; 226
    a212:	95 e2       	ldi	r25, 0x25	; 37
    a214:	0e 94 45 50 	call	0xa08a	; 0xa08a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    a218:	e0 92 fb 25 	sts	0x25FB, r14
    a21c:	f0 92 fc 25 	sts	0x25FC, r15
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    a220:	00 93 fd 25 	sts	0x25FD, r16
    a224:	10 93 fe 25 	sts	0x25FE, r17
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    a228:	18 8e       	std	Y+24, r1	; 0x18
    a22a:	19 8e       	std	Y+25, r1	; 0x19
		pxCoRoutine->uxPriority = uxPriority;
    a22c:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    a22e:	bf 8a       	std	Y+23, r11	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    a230:	fe 01       	movw	r30, r28
    a232:	c1 92       	st	Z+, r12
    a234:	d1 92       	st	Z+, r13
    a236:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    a238:	cf 01       	movw	r24, r30
    a23a:	0e 94 53 50 	call	0xa0a6	; 0xa0a6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    a23e:	ce 01       	movw	r24, r28
    a240:	0c 96       	adiw	r24, 0x0c	; 12
    a242:	0e 94 53 50 	call	0xa0a6	; 0xa0a6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    a246:	c8 87       	std	Y+8, r28	; 0x08
    a248:	d9 87       	std	Y+9, r29	; 0x09
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    a24a:	ca 8b       	std	Y+18, r28	; 0x12
    a24c:	db 8b       	std	Y+19, r29	; 0x13
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    a24e:	83 e0       	ldi	r24, 0x03	; 3
    a250:	90 e0       	ldi	r25, 0x00	; 0
    a252:	8c 87       	std	Y+12, r24	; 0x0c
    a254:	9d 87       	std	Y+13, r25	; 0x0d
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    a256:	2e 89       	ldd	r18, Y+22	; 0x16
    a258:	80 91 eb 25 	lds	r24, 0x25EB
    a25c:	82 17       	cp	r24, r18
    a25e:	10 f4       	brcc	.+4      	; 0xa264 <xCoRoutineCreate+0xb6>
    a260:	20 93 eb 25 	sts	0x25EB, r18
    a264:	30 e0       	ldi	r19, 0x00	; 0
    a266:	c9 01       	movw	r24, r18
    a268:	43 e0       	ldi	r20, 0x03	; 3
    a26a:	88 0f       	add	r24, r24
    a26c:	99 1f       	adc	r25, r25
    a26e:	4a 95       	dec	r20
    a270:	e1 f7       	brne	.-8      	; 0xa26a <xCoRoutineCreate+0xbc>
    a272:	82 0f       	add	r24, r18
    a274:	93 1f       	adc	r25, r19
    a276:	84 51       	subi	r24, 0x14	; 20
    a278:	9a 4d       	sbci	r25, 0xDA	; 218
    a27a:	b8 01       	movw	r22, r16
    a27c:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>

		xReturn = pdPASS;
    a280:	81 e0       	ldi	r24, 0x01	; 1
    a282:	01 c0       	rjmp	.+2      	; 0xa286 <xCoRoutineCreate+0xd8>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    a284:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    a286:	df 91       	pop	r29
    a288:	cf 91       	pop	r28
    a28a:	1f 91       	pop	r17
    a28c:	0f 91       	pop	r16
    a28e:	ff 90       	pop	r15
    a290:	ef 90       	pop	r14
    a292:	df 90       	pop	r13
    a294:	cf 90       	pop	r12
    a296:	bf 90       	pop	r11
    a298:	08 95       	ret

0000a29a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    a29a:	0f 93       	push	r16
    a29c:	1f 93       	push	r17
    a29e:	cf 93       	push	r28
    a2a0:	df 93       	push	r29
    a2a2:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    a2a4:	00 91 f9 25 	lds	r16, 0x25F9
    a2a8:	10 91 fa 25 	lds	r17, 0x25FA
    a2ac:	08 0f       	add	r16, r24
    a2ae:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a2b0:	80 91 e0 25 	lds	r24, 0x25E0
    a2b4:	90 91 e1 25 	lds	r25, 0x25E1
    a2b8:	02 96       	adiw	r24, 0x02	; 2
    a2ba:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    a2be:	60 91 e0 25 	lds	r22, 0x25E0
    a2c2:	70 91 e1 25 	lds	r23, 0x25E1
    a2c6:	fb 01       	movw	r30, r22
    a2c8:	02 83       	std	Z+2, r16	; 0x02
    a2ca:	13 83       	std	Z+3, r17	; 0x03

	if( xTimeToWake < xCoRoutineTickCount )
    a2cc:	80 91 f9 25 	lds	r24, 0x25F9
    a2d0:	90 91 fa 25 	lds	r25, 0x25FA
    a2d4:	6e 5f       	subi	r22, 0xFE	; 254
    a2d6:	7f 4f       	sbci	r23, 0xFF	; 255
    a2d8:	08 17       	cp	r16, r24
    a2da:	19 07       	cpc	r17, r25
    a2dc:	28 f4       	brcc	.+10     	; 0xa2e8 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a2de:	80 91 fd 25 	lds	r24, 0x25FD
    a2e2:	90 91 fe 25 	lds	r25, 0x25FE
    a2e6:	04 c0       	rjmp	.+8      	; 0xa2f0 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    a2e8:	80 91 fb 25 	lds	r24, 0x25FB
    a2ec:	90 91 fc 25 	lds	r25, 0x25FC
    a2f0:	0e 94 7c 50 	call	0xa0f8	; 0xa0f8 <vListInsert>
	}

	if( pxEventList )
    a2f4:	20 97       	sbiw	r28, 0x00	; 0
    a2f6:	49 f0       	breq	.+18     	; 0xa30a <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    a2f8:	60 91 e0 25 	lds	r22, 0x25E0
    a2fc:	70 91 e1 25 	lds	r23, 0x25E1
    a300:	64 5f       	subi	r22, 0xF4	; 244
    a302:	7f 4f       	sbci	r23, 0xFF	; 255
    a304:	ce 01       	movw	r24, r28
    a306:	0e 94 7c 50 	call	0xa0f8	; 0xa0f8 <vListInsert>
	}
}
    a30a:	df 91       	pop	r29
    a30c:	cf 91       	pop	r28
    a30e:	1f 91       	pop	r17
    a310:	0f 91       	pop	r16
    a312:	08 95       	ret

0000a314 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    a314:	0f 93       	push	r16
    a316:	1f 93       	push	r17
    a318:	cf 93       	push	r28
    a31a:	df 93       	push	r29
    a31c:	2e c0       	rjmp	.+92     	; 0xa37a <vCoRoutineSchedule+0x66>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    a31e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    a320:	80 91 e2 25 	lds	r24, 0x25E2
    a324:	88 23       	and	r24, r24
    a326:	39 f0       	breq	.+14     	; 0xa336 <vCoRoutineSchedule+0x22>
    a328:	e0 91 e7 25 	lds	r30, 0x25E7
    a32c:	f0 91 e8 25 	lds	r31, 0x25E8
    a330:	c6 81       	ldd	r28, Z+6	; 0x06
    a332:	d7 81       	ldd	r29, Z+7	; 0x07
    a334:	02 c0       	rjmp	.+4      	; 0xa33a <vCoRoutineSchedule+0x26>
    a336:	c0 e0       	ldi	r28, 0x00	; 0
    a338:	d0 e0       	ldi	r29, 0x00	; 0
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a33a:	ce 01       	movw	r24, r28
    a33c:	0c 96       	adiw	r24, 0x0c	; 12
    a33e:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    a342:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    a344:	8e 01       	movw	r16, r28
    a346:	0e 5f       	subi	r16, 0xFE	; 254
    a348:	1f 4f       	sbci	r17, 0xFF	; 255
    a34a:	c8 01       	movw	r24, r16
    a34c:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    a350:	2e 89       	ldd	r18, Y+22	; 0x16
    a352:	80 91 eb 25 	lds	r24, 0x25EB
    a356:	82 17       	cp	r24, r18
    a358:	10 f4       	brcc	.+4      	; 0xa35e <vCoRoutineSchedule+0x4a>
    a35a:	20 93 eb 25 	sts	0x25EB, r18
    a35e:	30 e0       	ldi	r19, 0x00	; 0
    a360:	c9 01       	movw	r24, r18
    a362:	f3 e0       	ldi	r31, 0x03	; 3
    a364:	88 0f       	add	r24, r24
    a366:	99 1f       	adc	r25, r25
    a368:	fa 95       	dec	r31
    a36a:	e1 f7       	brne	.-8      	; 0xa364 <vCoRoutineSchedule+0x50>
    a36c:	82 0f       	add	r24, r18
    a36e:	93 1f       	adc	r25, r19
    a370:	84 51       	subi	r24, 0x14	; 20
    a372:	9a 4d       	sbci	r25, 0xDA	; 218
    a374:	b8 01       	movw	r22, r16
    a376:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    a37a:	80 91 e2 25 	lds	r24, 0x25E2
    a37e:	88 23       	and	r24, r24
    a380:	71 f6       	brne	.-100    	; 0xa31e <vCoRoutineSchedule+0xa>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    a382:	0e 94 24 49 	call	0x9248	; 0x9248 <xTaskGetTickCount>
    a386:	20 91 f5 25 	lds	r18, 0x25F5
    a38a:	30 91 f6 25 	lds	r19, 0x25F6
    a38e:	82 1b       	sub	r24, r18
    a390:	93 0b       	sbc	r25, r19
    a392:	80 93 f7 25 	sts	0x25F7, r24
    a396:	90 93 f8 25 	sts	0x25F8, r25
    a39a:	5b c0       	rjmp	.+182    	; 0xa452 <vCoRoutineSchedule+0x13e>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    a39c:	01 96       	adiw	r24, 0x01	; 1
    a39e:	80 93 f9 25 	sts	0x25F9, r24
    a3a2:	90 93 fa 25 	sts	0x25FA, r25
		xPassedTicks--;
    a3a6:	21 50       	subi	r18, 0x01	; 1
    a3a8:	30 40       	sbci	r19, 0x00	; 0
    a3aa:	20 93 f7 25 	sts	0x25F7, r18
    a3ae:	30 93 f8 25 	sts	0x25F8, r19

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    a3b2:	00 97       	sbiw	r24, 0x00	; 0
    a3b4:	09 f0       	breq	.+2      	; 0xa3b8 <vCoRoutineSchedule+0xa4>
    a3b6:	3f c0       	rjmp	.+126    	; 0xa436 <vCoRoutineSchedule+0x122>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    a3b8:	80 91 fb 25 	lds	r24, 0x25FB
    a3bc:	90 91 fc 25 	lds	r25, 0x25FC
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    a3c0:	20 91 fd 25 	lds	r18, 0x25FD
    a3c4:	30 91 fe 25 	lds	r19, 0x25FE
    a3c8:	20 93 fb 25 	sts	0x25FB, r18
    a3cc:	30 93 fc 25 	sts	0x25FC, r19
			pxOverflowDelayedCoRoutineList = pxTemp;
    a3d0:	80 93 fd 25 	sts	0x25FD, r24
    a3d4:	90 93 fe 25 	sts	0x25FE, r25
    a3d8:	2e c0       	rjmp	.+92     	; 0xa436 <vCoRoutineSchedule+0x122>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    a3da:	20 91 f9 25 	lds	r18, 0x25F9
    a3de:	30 91 fa 25 	lds	r19, 0x25FA
    a3e2:	8a 81       	ldd	r24, Y+2	; 0x02
    a3e4:	9b 81       	ldd	r25, Y+3	; 0x03
    a3e6:	28 17       	cp	r18, r24
    a3e8:	39 07       	cpc	r19, r25
    a3ea:	98 f1       	brcs	.+102    	; 0xa452 <vCoRoutineSchedule+0x13e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    a3ec:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    a3ee:	8e 01       	movw	r16, r28
    a3f0:	0e 5f       	subi	r16, 0xFE	; 254
    a3f2:	1f 4f       	sbci	r17, 0xFF	; 255
    a3f4:	c8 01       	movw	r24, r16
    a3f6:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    a3fa:	8c 89       	ldd	r24, Y+20	; 0x14
    a3fc:	9d 89       	ldd	r25, Y+21	; 0x15
    a3fe:	00 97       	sbiw	r24, 0x00	; 0
    a400:	21 f0       	breq	.+8      	; 0xa40a <vCoRoutineSchedule+0xf6>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    a402:	ce 01       	movw	r24, r28
    a404:	0c 96       	adiw	r24, 0x0c	; 12
    a406:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    a40a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    a40c:	2e 89       	ldd	r18, Y+22	; 0x16
    a40e:	80 91 eb 25 	lds	r24, 0x25EB
    a412:	82 17       	cp	r24, r18
    a414:	10 f4       	brcc	.+4      	; 0xa41a <vCoRoutineSchedule+0x106>
    a416:	20 93 eb 25 	sts	0x25EB, r18
    a41a:	30 e0       	ldi	r19, 0x00	; 0
    a41c:	c9 01       	movw	r24, r18
    a41e:	e3 e0       	ldi	r30, 0x03	; 3
    a420:	88 0f       	add	r24, r24
    a422:	99 1f       	adc	r25, r25
    a424:	ea 95       	dec	r30
    a426:	e1 f7       	brne	.-8      	; 0xa420 <vCoRoutineSchedule+0x10c>
    a428:	82 0f       	add	r24, r18
    a42a:	93 1f       	adc	r25, r19
    a42c:	84 51       	subi	r24, 0x14	; 20
    a42e:	9a 4d       	sbci	r25, 0xDA	; 218
    a430:	b8 01       	movw	r22, r16
    a432:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    a436:	e0 91 fb 25 	lds	r30, 0x25FB
    a43a:	f0 91 fc 25 	lds	r31, 0x25FC
    a43e:	80 81       	ld	r24, Z
    a440:	88 23       	and	r24, r24
    a442:	39 f0       	breq	.+14     	; 0xa452 <vCoRoutineSchedule+0x13e>
    a444:	05 80       	ldd	r0, Z+5	; 0x05
    a446:	f6 81       	ldd	r31, Z+6	; 0x06
    a448:	e0 2d       	mov	r30, r0
    a44a:	c6 81       	ldd	r28, Z+6	; 0x06
    a44c:	d7 81       	ldd	r29, Z+7	; 0x07
    a44e:	20 97       	sbiw	r28, 0x00	; 0
    a450:	21 f6       	brne	.-120    	; 0xa3da <vCoRoutineSchedule+0xc6>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    a452:	20 91 f7 25 	lds	r18, 0x25F7
    a456:	30 91 f8 25 	lds	r19, 0x25F8
    a45a:	80 91 f9 25 	lds	r24, 0x25F9
    a45e:	90 91 fa 25 	lds	r25, 0x25FA
    a462:	21 15       	cp	r18, r1
    a464:	31 05       	cpc	r19, r1
    a466:	09 f0       	breq	.+2      	; 0xa46a <vCoRoutineSchedule+0x156>
    a468:	99 cf       	rjmp	.-206    	; 0xa39c <vCoRoutineSchedule+0x88>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    a46a:	80 93 f5 25 	sts	0x25F5, r24
    a46e:	90 93 f6 25 	sts	0x25F6, r25
    a472:	40 91 eb 25 	lds	r20, 0x25EB

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a476:	06 c0       	rjmp	.+12     	; 0xa484 <vCoRoutineSchedule+0x170>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    a478:	44 23       	and	r20, r20
    a47a:	19 f4       	brne	.+6      	; 0xa482 <vCoRoutineSchedule+0x16e>
    a47c:	10 92 eb 25 	sts	0x25EB, r1
    a480:	40 c0       	rjmp	.+128    	; 0xa502 <vCoRoutineSchedule+0x1ee>
    a482:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    a484:	84 2f       	mov	r24, r20
    a486:	90 e0       	ldi	r25, 0x00	; 0
    a488:	9c 01       	movw	r18, r24
    a48a:	73 e0       	ldi	r23, 0x03	; 3
    a48c:	22 0f       	add	r18, r18
    a48e:	33 1f       	adc	r19, r19
    a490:	7a 95       	dec	r23
    a492:	e1 f7       	brne	.-8      	; 0xa48c <vCoRoutineSchedule+0x178>
    a494:	28 0f       	add	r18, r24
    a496:	39 1f       	adc	r19, r25
    a498:	f9 01       	movw	r30, r18
    a49a:	e4 51       	subi	r30, 0x14	; 20
    a49c:	fa 4d       	sbci	r31, 0xDA	; 218
    a49e:	50 81       	ld	r21, Z
    a4a0:	55 23       	and	r21, r21
    a4a2:	51 f3       	breq	.-44     	; 0xa478 <vCoRoutineSchedule+0x164>
    a4a4:	40 93 eb 25 	sts	0x25EB, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    a4a8:	a1 81       	ldd	r26, Z+1	; 0x01
    a4aa:	b2 81       	ldd	r27, Z+2	; 0x02
    a4ac:	12 96       	adiw	r26, 0x02	; 2
    a4ae:	0d 90       	ld	r0, X+
    a4b0:	bc 91       	ld	r27, X
    a4b2:	a0 2d       	mov	r26, r0
    a4b4:	a1 83       	std	Z+1, r26	; 0x01
    a4b6:	b2 83       	std	Z+2, r27	; 0x02
    a4b8:	21 51       	subi	r18, 0x11	; 17
    a4ba:	3a 4d       	sbci	r19, 0xDA	; 218
    a4bc:	a2 17       	cp	r26, r18
    a4be:	b3 07       	cpc	r27, r19
    a4c0:	31 f4       	brne	.+12     	; 0xa4ce <vCoRoutineSchedule+0x1ba>
    a4c2:	12 96       	adiw	r26, 0x02	; 2
    a4c4:	2d 91       	ld	r18, X+
    a4c6:	3c 91       	ld	r19, X
    a4c8:	13 97       	sbiw	r26, 0x03	; 3
    a4ca:	21 83       	std	Z+1, r18	; 0x01
    a4cc:	32 83       	std	Z+2, r19	; 0x02
    a4ce:	fc 01       	movw	r30, r24
    a4d0:	63 e0       	ldi	r22, 0x03	; 3
    a4d2:	ee 0f       	add	r30, r30
    a4d4:	ff 1f       	adc	r31, r31
    a4d6:	6a 95       	dec	r22
    a4d8:	e1 f7       	brne	.-8      	; 0xa4d2 <vCoRoutineSchedule+0x1be>
    a4da:	e8 0f       	add	r30, r24
    a4dc:	f9 1f       	adc	r31, r25
    a4de:	e4 51       	subi	r30, 0x14	; 20
    a4e0:	fa 4d       	sbci	r31, 0xDA	; 218
    a4e2:	01 80       	ldd	r0, Z+1	; 0x01
    a4e4:	f2 81       	ldd	r31, Z+2	; 0x02
    a4e6:	e0 2d       	mov	r30, r0
    a4e8:	a6 81       	ldd	r26, Z+6	; 0x06
    a4ea:	b7 81       	ldd	r27, Z+7	; 0x07
    a4ec:	a0 93 e0 25 	sts	0x25E0, r26
    a4f0:	b0 93 e1 25 	sts	0x25E1, r27

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    a4f4:	ed 91       	ld	r30, X+
    a4f6:	fc 91       	ld	r31, X
    a4f8:	11 97       	sbiw	r26, 0x01	; 1
    a4fa:	cd 01       	movw	r24, r26
    a4fc:	57 96       	adiw	r26, 0x17	; 23
    a4fe:	6c 91       	ld	r22, X
    a500:	19 95       	eicall

	return;
}
    a502:	df 91       	pop	r29
    a504:	cf 91       	pop	r28
    a506:	1f 91       	pop	r17
    a508:	0f 91       	pop	r16
    a50a:	08 95       	ret

0000a50c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    a50c:	0f 93       	push	r16
    a50e:	1f 93       	push	r17
    a510:	cf 93       	push	r28
    a512:	df 93       	push	r29
    a514:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    a516:	80 81       	ld	r24, Z
    a518:	88 23       	and	r24, r24
    a51a:	31 f0       	breq	.+12     	; 0xa528 <xCoRoutineRemoveFromEventList+0x1c>
    a51c:	05 80       	ldd	r0, Z+5	; 0x05
    a51e:	f6 81       	ldd	r31, Z+6	; 0x06
    a520:	e0 2d       	mov	r30, r0
    a522:	c6 81       	ldd	r28, Z+6	; 0x06
    a524:	d7 81       	ldd	r29, Z+7	; 0x07
    a526:	02 c0       	rjmp	.+4      	; 0xa52c <xCoRoutineRemoveFromEventList+0x20>
    a528:	c0 e0       	ldi	r28, 0x00	; 0
    a52a:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    a52c:	8e 01       	movw	r16, r28
    a52e:	04 5f       	subi	r16, 0xF4	; 244
    a530:	1f 4f       	sbci	r17, 0xFF	; 255
    a532:	c8 01       	movw	r24, r16
    a534:	0e 94 b3 50 	call	0xa166	; 0xa166 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    a538:	82 ee       	ldi	r24, 0xE2	; 226
    a53a:	95 e2       	ldi	r25, 0x25	; 37
    a53c:	b8 01       	movw	r22, r16
    a53e:	0e 94 57 50 	call	0xa0ae	; 0xa0ae <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    a542:	e0 91 e0 25 	lds	r30, 0x25E0
    a546:	f0 91 e1 25 	lds	r31, 0x25E1
	{
		xReturn = pdTRUE;
    a54a:	81 e0       	ldi	r24, 0x01	; 1
    a54c:	2e 89       	ldd	r18, Y+22	; 0x16
    a54e:	96 89       	ldd	r25, Z+22	; 0x16
    a550:	29 17       	cp	r18, r25
    a552:	08 f4       	brcc	.+2      	; 0xa556 <xCoRoutineRemoveFromEventList+0x4a>
    a554:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    a556:	df 91       	pop	r29
    a558:	cf 91       	pop	r28
    a55a:	1f 91       	pop	r17
    a55c:	0f 91       	pop	r16
    a55e:	08 95       	ret

0000a560 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    a560:	ef 92       	push	r14
    a562:	ff 92       	push	r15
    a564:	0f 93       	push	r16
    a566:	1f 93       	push	r17
    a568:	cf 93       	push	r28
    a56a:	df 93       	push	r29
    a56c:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    a56e:	0e 94 1e 49 	call	0x923c	; 0x923c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    a572:	c0 91 11 26 	lds	r28, 0x2611
    a576:	d0 91 12 26 	lds	r29, 0x2612
    a57a:	0c 0f       	add	r16, r28
    a57c:	1d 1f       	adc	r17, r29
    a57e:	2b e0       	ldi	r18, 0x0B	; 11
    a580:	08 3b       	cpi	r16, 0xB8	; 184
    a582:	12 07       	cpc	r17, r18
    a584:	50 f4       	brcc	.+20     	; 0xa59a <pvPortMalloc+0x3a>
    a586:	c0 17       	cp	r28, r16
    a588:	d1 07       	cpc	r29, r17
    a58a:	38 f4       	brcc	.+14     	; 0xa59a <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    a58c:	cd 5e       	subi	r28, 0xED	; 237
    a58e:	d9 4d       	sbci	r29, 0xD9	; 217
			xNextFreeByte += xWantedSize;			
    a590:	00 93 11 26 	sts	0x2611, r16
    a594:	10 93 12 26 	sts	0x2612, r17
    a598:	02 c0       	rjmp	.+4      	; 0xa59e <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    a59a:	c0 e0       	ldi	r28, 0x00	; 0
    a59c:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    a59e:	0e 94 db 49 	call	0x93b6	; 0x93b6 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    a5a2:	ce 01       	movw	r24, r28
    a5a4:	df 91       	pop	r29
    a5a6:	cf 91       	pop	r28
    a5a8:	1f 91       	pop	r17
    a5aa:	0f 91       	pop	r16
    a5ac:	ff 90       	pop	r15
    a5ae:	ef 90       	pop	r14
    a5b0:	08 95       	ret

0000a5b2 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    a5b2:	08 95       	ret

0000a5b4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    a5b4:	10 92 11 26 	sts	0x2611, r1
    a5b8:	10 92 12 26 	sts	0x2612, r1
}
    a5bc:	08 95       	ret

0000a5be <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    a5be:	28 eb       	ldi	r18, 0xB8	; 184
    a5c0:	3b e0       	ldi	r19, 0x0B	; 11
    a5c2:	80 91 11 26 	lds	r24, 0x2611
    a5c6:	90 91 12 26 	lds	r25, 0x2612
    a5ca:	28 1b       	sub	r18, r24
    a5cc:	39 0b       	sbc	r19, r25
}
    a5ce:	c9 01       	movw	r24, r18
    a5d0:	08 95       	ret

0000a5d2 <pxPortInitialiseStack>:
  uint32_t usAddress;
/**
 * Place a few bytes of known values on the bottom of the stack.
 * This is just useful for debugging.
 */ //TODO Adam: zrobi? kompilacj? warunkow? wy??czaj?c? to debugowanie 
  *pxTopOfStack = 0x11;
    a5d2:	31 e1       	ldi	r19, 0x11	; 17
    a5d4:	fc 01       	movw	r30, r24
    a5d6:	30 83       	st	Z, r19
  pxTopOfStack--;
  *pxTopOfStack = 0x22;
    a5d8:	22 e2       	ldi	r18, 0x22	; 34
    a5da:	22 93       	st	-Z, r18
  pxTopOfStack--;
  *pxTopOfStack = 0x33;
    a5dc:	83 e3       	ldi	r24, 0x33	; 51
    a5de:	82 93       	st	-Z, r24
	/* end of original code block */

	/* The way it should be done for xmega with probably  more than 128K program memory.
	 * Warning is OK here - type incompatibility does not matter - usAddress is only
	 * used as temporary storage */
  usAddress = ( uint32_t ) pxCode;
    a5e0:	88 27       	eor	r24, r24
    a5e2:	77 fd       	sbrc	r23, 7
    a5e4:	80 95       	com	r24
    a5e6:	98 2f       	mov	r25, r24

  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff );
    a5e8:	62 93       	st	-Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff ); //tu powinno byc chyba 000000FF
	pxTopOfStack--;
	usAddress >>= 8;
#endif*/

  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( uint32_t ) 0x000000ff ); //tu powinno byc chyba 000000FF
    a5ea:	72 93       	st	-Z, r23
/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
  portSAVE_CONTEXT places the flags on the stack immediately after r0
  to ensure the interrupts get disabled as soon as possible, and so ensuring
  the stack use is minimal should a context switch interrupt occur. */

  *pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    a5ec:	12 92       	st	-Z, r1
  pxTopOfStack--;
  *pxTopOfStack = portFLAGS_INT_ENABLED;
    a5ee:	80 e8       	ldi	r24, 0x80	; 128
    a5f0:	82 93       	st	-Z, r24
  pxTopOfStack--;


/* Now the remaining registers.   The compiler expects R1 to be 0. */

  *pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    a5f2:	12 92       	st	-Z, r1
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    a5f4:	82 e0       	ldi	r24, 0x02	; 2
    a5f6:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    a5f8:	83 e0       	ldi	r24, 0x03	; 3
    a5fa:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    a5fc:	84 e0       	ldi	r24, 0x04	; 4
    a5fe:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    a600:	85 e0       	ldi	r24, 0x05	; 5
    a602:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    a604:	86 e0       	ldi	r24, 0x06	; 6
    a606:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    a608:	87 e0       	ldi	r24, 0x07	; 7
    a60a:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    a60c:	88 e0       	ldi	r24, 0x08	; 8
    a60e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    a610:	89 e0       	ldi	r24, 0x09	; 9
    a612:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    a614:	80 e1       	ldi	r24, 0x10	; 16
    a616:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    a618:	32 93       	st	-Z, r19
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    a61a:	82 e1       	ldi	r24, 0x12	; 18
    a61c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    a61e:	83 e1       	ldi	r24, 0x13	; 19
    a620:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    a622:	84 e1       	ldi	r24, 0x14	; 20
    a624:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    a626:	85 e1       	ldi	r24, 0x15	; 21
    a628:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    a62a:	86 e1       	ldi	r24, 0x16	; 22
    a62c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    a62e:	87 e1       	ldi	r24, 0x17	; 23
    a630:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    a632:	88 e1       	ldi	r24, 0x18	; 24
    a634:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    a636:	89 e1       	ldi	r24, 0x19	; 25
    a638:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    a63a:	80 e2       	ldi	r24, 0x20	; 32
    a63c:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    a63e:	81 e2       	ldi	r24, 0x21	; 33
    a640:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    a642:	22 93       	st	-Z, r18
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    a644:	83 e2       	ldi	r24, 0x23	; 35
    a646:	82 93       	st	-Z, r24
  pxTopOfStack--;
	/* Place the parameter on the stack in the expected location. */
  usAddress = ( unsigned short ) pvParameters;
  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    a648:	42 93       	st	-Z, r20
  pxTopOfStack--;

  usAddress >>= 8;
  *pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    a64a:	52 93       	st	-Z, r21
  pxTopOfStack--;

  *pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    a64c:	86 e2       	ldi	r24, 0x26	; 38
    a64e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    a650:	87 e2       	ldi	r24, 0x27	; 39
    a652:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    a654:	88 e2       	ldi	r24, 0x28	; 40
    a656:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    a658:	89 e2       	ldi	r24, 0x29	; 41
    a65a:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    a65c:	80 e3       	ldi	r24, 0x30	; 48
    a65e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x31;	/* R31 */
    a660:	81 e3       	ldi	r24, 0x31	; 49
    a662:	82 93       	st	-Z, r24
  pxTopOfStack--;
/* these registers are also part of execution context
 * Corresponing registars are saved and restored in saveCONTEXT and restoreCONTEXT
 * TODO  See datasheet for explanation
 */
  *pxTopOfStack = ( portSTACK_TYPE ) 0x38;	/* 38 RAMPD */
    a664:	88 e3       	ldi	r24, 0x38	; 56
    a666:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x39;	/* 39 RAMPX */
    a668:	89 e3       	ldi	r24, 0x39	; 57
    a66a:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3a;	/* 3a RAMPY */
    a66c:	8a e3       	ldi	r24, 0x3A	; 58
    a66e:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3b;	/* 3b RAMPZ */
    a670:	8b e3       	ldi	r24, 0x3B	; 59
    a672:	82 93       	st	-Z, r24
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) 0x3c;	/* 3c EIND */
    a674:	8c e3       	ldi	r24, 0x3C	; 60
    a676:	82 93       	st	-Z, r24
  pxTopOfStack--;
    a678:	9f 01       	movw	r18, r30
    a67a:	21 50       	subi	r18, 0x01	; 1
    a67c:	30 40       	sbci	r19, 0x00	; 0

/*lint +e950 +e611 +e923 */

  return pxTopOfStack;
}
    a67e:	c9 01       	movw	r24, r18
    a680:	08 95       	ret

0000a682 <xPortStartScheduler>:
0110 DIV256 Prescaler clk/256
0111 DIV1024 Prescaler clk/1024
1xxx EVCHn event chanerl n, n=[0...7]
*/
///select the clock source and pre-scale by 64	
  TCC0.CTRLA= ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_DIV64_gc;
    a682:	e0 e0       	ldi	r30, 0x00	; 0
    a684:	f8 e0       	ldi	r31, 0x08	; 8
    a686:	80 81       	ld	r24, Z
    a688:	80 7f       	andi	r24, 0xF0	; 240
    a68a:	85 60       	ori	r24, 0x05	; 5
    a68c:	80 83       	st	Z, r24
  TC_CLKSEL_EVCH5_gc =   (0x0D<<0),   // Event Channel 5 
  TC_CLKSEL_EVCH6_gc =   (0x0E<<0),   // Event Channel 6 
  TC_CLKSEL_EVCH7_gc =   (0x0F<<0),   // Event Channel 7 
*/
/// set period of counter
  TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ/64-1; // tu zmienic 16Mhz/1000/
    a68e:	89 ef       	ldi	r24, 0xF9	; 249
    a690:	90 e0       	ldi	r25, 0x00	; 0
    a692:	86 a3       	std	Z+38, r24	; 0x26
    a694:	97 a3       	std	Z+39, r25	; 0x27
	+---+---+---+---+---+---+---+---+
	|    PER [7:0]                  | 
	+---+---+---+---+---+---+---+---+
*/
/// enable interrupt and set low level	
  TCC0.INTCTRLA = ( TCC0.INTCTRLA & ~TC0_OVFINTLVL_gm ) | TC_OVFINTLVL_LO_gc;
    a696:	86 81       	ldd	r24, Z+6	; 0x06
    a698:	8c 7f       	andi	r24, 0xFC	; 252
    a69a:	81 60       	ori	r24, 0x01	; 1
    a69c:	86 83       	std	Z+6, r24	; 0x06
+---+---+---+---+--------+--------+--------+--------+
| - | - | - | - | ERRINTLVL[1:0]  | OVFINTLVL [1:0] |
+---+---+---+---+--------+--------+--------+--------+
*/
/// enable low level interrupts   
  PMIC.CTRL |= PMIC_LOLVLEN_bm;
    a69e:	e0 ea       	ldi	r30, 0xA0	; 160
    a6a0:	f0 e0       	ldi	r31, 0x00	; 0
    a6a2:	82 81       	ldd	r24, Z+2	; 0x02
    a6a4:	81 60       	ori	r24, 0x01	; 1
    a6a6:	82 83       	std	Z+2, r24	; 0x02
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();


	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    a6a8:	a0 91 57 25 	lds	r26, 0x2557
    a6ac:	b0 91 58 25 	lds	r27, 0x2558
    a6b0:	cd 91       	ld	r28, X+
    a6b2:	cd bf       	out	0x3d, r28	; 61
    a6b4:	dd 91       	ld	r29, X+
    a6b6:	de bf       	out	0x3e, r29	; 62
    a6b8:	0f 91       	pop	r16
    a6ba:	0c bf       	out	0x3c, r16	; 60
    a6bc:	0f 91       	pop	r16
    a6be:	0b bf       	out	0x3b, r16	; 59
    a6c0:	0f 91       	pop	r16
    a6c2:	0a bf       	out	0x3a, r16	; 58
    a6c4:	0f 91       	pop	r16
    a6c6:	09 bf       	out	0x39, r16	; 57
    a6c8:	0f 91       	pop	r16
    a6ca:	08 bf       	out	0x38, r16	; 56
    a6cc:	ff 91       	pop	r31
    a6ce:	ef 91       	pop	r30
    a6d0:	df 91       	pop	r29
    a6d2:	cf 91       	pop	r28
    a6d4:	bf 91       	pop	r27
    a6d6:	af 91       	pop	r26
    a6d8:	9f 91       	pop	r25
    a6da:	8f 91       	pop	r24
    a6dc:	7f 91       	pop	r23
    a6de:	6f 91       	pop	r22
    a6e0:	5f 91       	pop	r21
    a6e2:	4f 91       	pop	r20
    a6e4:	3f 91       	pop	r19
    a6e6:	2f 91       	pop	r18
    a6e8:	1f 91       	pop	r17
    a6ea:	0f 91       	pop	r16
    a6ec:	ff 90       	pop	r15
    a6ee:	ef 90       	pop	r14
    a6f0:	df 90       	pop	r13
    a6f2:	cf 90       	pop	r12
    a6f4:	bf 90       	pop	r11
    a6f6:	af 90       	pop	r10
    a6f8:	9f 90       	pop	r9
    a6fa:	8f 90       	pop	r8
    a6fc:	7f 90       	pop	r7
    a6fe:	6f 90       	pop	r6
    a700:	5f 90       	pop	r5
    a702:	4f 90       	pop	r4
    a704:	3f 90       	pop	r3
    a706:	2f 90       	pop	r2
    a708:	1f 90       	pop	r1
    a70a:	0f 90       	pop	r0
    a70c:	0f be       	out	0x3f, r0	; 63
    a70e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    a710:	08 95       	ret


	/* Should not get here. */
	return pdTRUE;
}
    a712:	81 e0       	ldi	r24, 0x01	; 1
    a714:	08 95       	ret

0000a716 <vPortEndScheduler>:
void vPortEndScheduler( void )
{
/* 
 * It is unlikely that the AVR port will get stopped.  If required simply
 * disable the tick interrupt here. */
}
    a716:	08 95       	ret

0000a718 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
  portSAVE_CONTEXT();
    a718:	0f 92       	push	r0
    a71a:	0f b6       	in	r0, 0x3f	; 63
    a71c:	f8 94       	cli
    a71e:	0f 92       	push	r0
    a720:	1f 92       	push	r1
    a722:	11 24       	eor	r1, r1
    a724:	2f 92       	push	r2
    a726:	3f 92       	push	r3
    a728:	4f 92       	push	r4
    a72a:	5f 92       	push	r5
    a72c:	6f 92       	push	r6
    a72e:	7f 92       	push	r7
    a730:	8f 92       	push	r8
    a732:	9f 92       	push	r9
    a734:	af 92       	push	r10
    a736:	bf 92       	push	r11
    a738:	cf 92       	push	r12
    a73a:	df 92       	push	r13
    a73c:	ef 92       	push	r14
    a73e:	ff 92       	push	r15
    a740:	0f 93       	push	r16
    a742:	1f 93       	push	r17
    a744:	2f 93       	push	r18
    a746:	3f 93       	push	r19
    a748:	4f 93       	push	r20
    a74a:	5f 93       	push	r21
    a74c:	6f 93       	push	r22
    a74e:	7f 93       	push	r23
    a750:	8f 93       	push	r24
    a752:	9f 93       	push	r25
    a754:	af 93       	push	r26
    a756:	bf 93       	push	r27
    a758:	cf 93       	push	r28
    a75a:	df 93       	push	r29
    a75c:	ef 93       	push	r30
    a75e:	ff 93       	push	r31
    a760:	08 b7       	in	r16, 0x38	; 56
    a762:	0f 93       	push	r16
    a764:	09 b7       	in	r16, 0x39	; 57
    a766:	0f 93       	push	r16
    a768:	0a b7       	in	r16, 0x3a	; 58
    a76a:	0f 93       	push	r16
    a76c:	0b b7       	in	r16, 0x3b	; 59
    a76e:	0f 93       	push	r16
    a770:	0c b7       	in	r16, 0x3c	; 60
    a772:	0f 93       	push	r16
    a774:	a0 91 57 25 	lds	r26, 0x2557
    a778:	b0 91 58 25 	lds	r27, 0x2558
    a77c:	0d b6       	in	r0, 0x3d	; 61
    a77e:	0d 92       	st	X+, r0
    a780:	0e b6       	in	r0, 0x3e	; 62
    a782:	0d 92       	st	X+, r0
  vTaskSwitchContext();
    a784:	0e 94 4a 4b 	call	0x9694	; 0x9694 <vTaskSwitchContext>
  portRESTORE_CONTEXT();
    a788:	a0 91 57 25 	lds	r26, 0x2557
    a78c:	b0 91 58 25 	lds	r27, 0x2558
    a790:	cd 91       	ld	r28, X+
    a792:	cd bf       	out	0x3d, r28	; 61
    a794:	dd 91       	ld	r29, X+
    a796:	de bf       	out	0x3e, r29	; 62
    a798:	0f 91       	pop	r16
    a79a:	0c bf       	out	0x3c, r16	; 60
    a79c:	0f 91       	pop	r16
    a79e:	0b bf       	out	0x3b, r16	; 59
    a7a0:	0f 91       	pop	r16
    a7a2:	0a bf       	out	0x3a, r16	; 58
    a7a4:	0f 91       	pop	r16
    a7a6:	09 bf       	out	0x39, r16	; 57
    a7a8:	0f 91       	pop	r16
    a7aa:	08 bf       	out	0x38, r16	; 56
    a7ac:	ff 91       	pop	r31
    a7ae:	ef 91       	pop	r30
    a7b0:	df 91       	pop	r29
    a7b2:	cf 91       	pop	r28
    a7b4:	bf 91       	pop	r27
    a7b6:	af 91       	pop	r26
    a7b8:	9f 91       	pop	r25
    a7ba:	8f 91       	pop	r24
    a7bc:	7f 91       	pop	r23
    a7be:	6f 91       	pop	r22
    a7c0:	5f 91       	pop	r21
    a7c2:	4f 91       	pop	r20
    a7c4:	3f 91       	pop	r19
    a7c6:	2f 91       	pop	r18
    a7c8:	1f 91       	pop	r17
    a7ca:	0f 91       	pop	r16
    a7cc:	ff 90       	pop	r15
    a7ce:	ef 90       	pop	r14
    a7d0:	df 90       	pop	r13
    a7d2:	cf 90       	pop	r12
    a7d4:	bf 90       	pop	r11
    a7d6:	af 90       	pop	r10
    a7d8:	9f 90       	pop	r9
    a7da:	8f 90       	pop	r8
    a7dc:	7f 90       	pop	r7
    a7de:	6f 90       	pop	r6
    a7e0:	5f 90       	pop	r5
    a7e2:	4f 90       	pop	r4
    a7e4:	3f 90       	pop	r3
    a7e6:	2f 90       	pop	r2
    a7e8:	1f 90       	pop	r1
    a7ea:	0f 90       	pop	r0
    a7ec:	0f be       	out	0x3f, r0	; 63
    a7ee:	0f 90       	pop	r0

  asm volatile ( "ret" );
    a7f0:	08 95       	ret

0000a7f2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
  portSAVE_CONTEXT();
    a7f2:	0f 92       	push	r0
    a7f4:	0f b6       	in	r0, 0x3f	; 63
    a7f6:	f8 94       	cli
    a7f8:	0f 92       	push	r0
    a7fa:	1f 92       	push	r1
    a7fc:	11 24       	eor	r1, r1
    a7fe:	2f 92       	push	r2
    a800:	3f 92       	push	r3
    a802:	4f 92       	push	r4
    a804:	5f 92       	push	r5
    a806:	6f 92       	push	r6
    a808:	7f 92       	push	r7
    a80a:	8f 92       	push	r8
    a80c:	9f 92       	push	r9
    a80e:	af 92       	push	r10
    a810:	bf 92       	push	r11
    a812:	cf 92       	push	r12
    a814:	df 92       	push	r13
    a816:	ef 92       	push	r14
    a818:	ff 92       	push	r15
    a81a:	0f 93       	push	r16
    a81c:	1f 93       	push	r17
    a81e:	2f 93       	push	r18
    a820:	3f 93       	push	r19
    a822:	4f 93       	push	r20
    a824:	5f 93       	push	r21
    a826:	6f 93       	push	r22
    a828:	7f 93       	push	r23
    a82a:	8f 93       	push	r24
    a82c:	9f 93       	push	r25
    a82e:	af 93       	push	r26
    a830:	bf 93       	push	r27
    a832:	cf 93       	push	r28
    a834:	df 93       	push	r29
    a836:	ef 93       	push	r30
    a838:	ff 93       	push	r31
    a83a:	08 b7       	in	r16, 0x38	; 56
    a83c:	0f 93       	push	r16
    a83e:	09 b7       	in	r16, 0x39	; 57
    a840:	0f 93       	push	r16
    a842:	0a b7       	in	r16, 0x3a	; 58
    a844:	0f 93       	push	r16
    a846:	0b b7       	in	r16, 0x3b	; 59
    a848:	0f 93       	push	r16
    a84a:	0c b7       	in	r16, 0x3c	; 60
    a84c:	0f 93       	push	r16
    a84e:	a0 91 57 25 	lds	r26, 0x2557
    a852:	b0 91 58 25 	lds	r27, 0x2558
    a856:	0d b6       	in	r0, 0x3d	; 61
    a858:	0d 92       	st	X+, r0
    a85a:	0e b6       	in	r0, 0x3e	; 62
    a85c:	0d 92       	st	X+, r0
  vTaskIncrementTick();
    a85e:	0e 94 63 49 	call	0x92c6	; 0x92c6 <vTaskIncrementTick>
  vTaskSwitchContext();
    a862:	0e 94 4a 4b 	call	0x9694	; 0x9694 <vTaskSwitchContext>
  portRESTORE_CONTEXT();
    a866:	a0 91 57 25 	lds	r26, 0x2557
    a86a:	b0 91 58 25 	lds	r27, 0x2558
    a86e:	cd 91       	ld	r28, X+
    a870:	cd bf       	out	0x3d, r28	; 61
    a872:	dd 91       	ld	r29, X+
    a874:	de bf       	out	0x3e, r29	; 62
    a876:	0f 91       	pop	r16
    a878:	0c bf       	out	0x3c, r16	; 60
    a87a:	0f 91       	pop	r16
    a87c:	0b bf       	out	0x3b, r16	; 59
    a87e:	0f 91       	pop	r16
    a880:	0a bf       	out	0x3a, r16	; 58
    a882:	0f 91       	pop	r16
    a884:	09 bf       	out	0x39, r16	; 57
    a886:	0f 91       	pop	r16
    a888:	08 bf       	out	0x38, r16	; 56
    a88a:	ff 91       	pop	r31
    a88c:	ef 91       	pop	r30
    a88e:	df 91       	pop	r29
    a890:	cf 91       	pop	r28
    a892:	bf 91       	pop	r27
    a894:	af 91       	pop	r26
    a896:	9f 91       	pop	r25
    a898:	8f 91       	pop	r24
    a89a:	7f 91       	pop	r23
    a89c:	6f 91       	pop	r22
    a89e:	5f 91       	pop	r21
    a8a0:	4f 91       	pop	r20
    a8a2:	3f 91       	pop	r19
    a8a4:	2f 91       	pop	r18
    a8a6:	1f 91       	pop	r17
    a8a8:	0f 91       	pop	r16
    a8aa:	ff 90       	pop	r15
    a8ac:	ef 90       	pop	r14
    a8ae:	df 90       	pop	r13
    a8b0:	cf 90       	pop	r12
    a8b2:	bf 90       	pop	r11
    a8b4:	af 90       	pop	r10
    a8b6:	9f 90       	pop	r9
    a8b8:	8f 90       	pop	r8
    a8ba:	7f 90       	pop	r7
    a8bc:	6f 90       	pop	r6
    a8be:	5f 90       	pop	r5
    a8c0:	4f 90       	pop	r4
    a8c2:	3f 90       	pop	r3
    a8c4:	2f 90       	pop	r2
    a8c6:	1f 90       	pop	r1
    a8c8:	0f 90       	pop	r0
    a8ca:	0f be       	out	0x3f, r0	; 63
    a8cc:	0f 90       	pop	r0

  asm volatile ( "ret" );
    a8ce:	08 95       	ret

0000a8d0 <__vector_14>:
 * tick count.  We don't need to switch context, this can only be done by
 * manual calls to taskYIELD();
 */
ISR (TCC0_OVF_vect, ISR_NAKED)
{
  vTaskIncrementTick();
    a8d0:	0e 94 63 49 	call	0x92c6	; 0x92c6 <vTaskIncrementTick>

0000a8d4 <__udivmodqi4>:
}
    a8d4:	99 1b       	sub	r25, r25
    a8d6:	79 e0       	ldi	r23, 0x09	; 9
    a8d8:	04 c0       	rjmp	.+8      	; 0xa8e2 <__udivmodqi4_ep>

0000a8da <__udivmodqi4_loop>:
    a8da:	99 1f       	adc	r25, r25
    a8dc:	96 17       	cp	r25, r22
    a8de:	08 f0       	brcs	.+2      	; 0xa8e2 <__udivmodqi4_ep>
    a8e0:	96 1b       	sub	r25, r22

0000a8e2 <__udivmodqi4_ep>:
    a8e2:	88 1f       	adc	r24, r24
    a8e4:	7a 95       	dec	r23
    a8e6:	c9 f7       	brne	.-14     	; 0xa8da <__udivmodqi4_loop>
    a8e8:	80 95       	com	r24
    a8ea:	08 95       	ret

0000a8ec <__udivmodhi4>:
    a8ec:	aa 1b       	sub	r26, r26
    a8ee:	bb 1b       	sub	r27, r27
    a8f0:	51 e1       	ldi	r21, 0x11	; 17
    a8f2:	07 c0       	rjmp	.+14     	; 0xa902 <__udivmodhi4_ep>

0000a8f4 <__udivmodhi4_loop>:
    a8f4:	aa 1f       	adc	r26, r26
    a8f6:	bb 1f       	adc	r27, r27
    a8f8:	a6 17       	cp	r26, r22
    a8fa:	b7 07       	cpc	r27, r23
    a8fc:	10 f0       	brcs	.+4      	; 0xa902 <__udivmodhi4_ep>
    a8fe:	a6 1b       	sub	r26, r22
    a900:	b7 0b       	sbc	r27, r23

0000a902 <__udivmodhi4_ep>:
    a902:	88 1f       	adc	r24, r24
    a904:	99 1f       	adc	r25, r25
    a906:	5a 95       	dec	r21
    a908:	a9 f7       	brne	.-22     	; 0xa8f4 <__udivmodhi4_loop>
    a90a:	80 95       	com	r24
    a90c:	90 95       	com	r25
    a90e:	bc 01       	movw	r22, r24
    a910:	cd 01       	movw	r24, r26
    a912:	08 95       	ret

0000a914 <malloc>:
    a914:	cf 93       	push	r28
    a916:	df 93       	push	r29
    a918:	ac 01       	movw	r20, r24
    a91a:	82 30       	cpi	r24, 0x02	; 2
    a91c:	91 05       	cpc	r25, r1
    a91e:	10 f4       	brcc	.+4      	; 0xa924 <malloc+0x10>
    a920:	42 e0       	ldi	r20, 0x02	; 2
    a922:	50 e0       	ldi	r21, 0x00	; 0
    a924:	e0 91 3e 33 	lds	r30, 0x333E
    a928:	f0 91 3f 33 	lds	r31, 0x333F
    a92c:	20 e0       	ldi	r18, 0x00	; 0
    a92e:	30 e0       	ldi	r19, 0x00	; 0
    a930:	a0 e0       	ldi	r26, 0x00	; 0
    a932:	b0 e0       	ldi	r27, 0x00	; 0
    a934:	24 c0       	rjmp	.+72     	; 0xa97e <malloc+0x6a>
    a936:	80 81       	ld	r24, Z
    a938:	91 81       	ldd	r25, Z+1	; 0x01
    a93a:	84 17       	cp	r24, r20
    a93c:	95 07       	cpc	r25, r21
    a93e:	d0 f0       	brcs	.+52     	; 0xa974 <malloc+0x60>
    a940:	84 17       	cp	r24, r20
    a942:	95 07       	cpc	r25, r21
    a944:	71 f4       	brne	.+28     	; 0xa962 <malloc+0x4e>
    a946:	82 81       	ldd	r24, Z+2	; 0x02
    a948:	93 81       	ldd	r25, Z+3	; 0x03
    a94a:	10 97       	sbiw	r26, 0x00	; 0
    a94c:	29 f0       	breq	.+10     	; 0xa958 <malloc+0x44>
    a94e:	12 96       	adiw	r26, 0x02	; 2
    a950:	8d 93       	st	X+, r24
    a952:	9c 93       	st	X, r25
    a954:	13 97       	sbiw	r26, 0x03	; 3
    a956:	2c c0       	rjmp	.+88     	; 0xa9b0 <malloc+0x9c>
    a958:	80 93 3e 33 	sts	0x333E, r24
    a95c:	90 93 3f 33 	sts	0x333F, r25
    a960:	27 c0       	rjmp	.+78     	; 0xa9b0 <malloc+0x9c>
    a962:	21 15       	cp	r18, r1
    a964:	31 05       	cpc	r19, r1
    a966:	19 f0       	breq	.+6      	; 0xa96e <malloc+0x5a>
    a968:	82 17       	cp	r24, r18
    a96a:	93 07       	cpc	r25, r19
    a96c:	18 f4       	brcc	.+6      	; 0xa974 <malloc+0x60>
    a96e:	9c 01       	movw	r18, r24
    a970:	bd 01       	movw	r22, r26
    a972:	ef 01       	movw	r28, r30
    a974:	92 81       	ldd	r25, Z+2	; 0x02
    a976:	83 81       	ldd	r24, Z+3	; 0x03
    a978:	df 01       	movw	r26, r30
    a97a:	e9 2f       	mov	r30, r25
    a97c:	f8 2f       	mov	r31, r24
    a97e:	30 97       	sbiw	r30, 0x00	; 0
    a980:	d1 f6       	brne	.-76     	; 0xa936 <malloc+0x22>
    a982:	21 15       	cp	r18, r1
    a984:	31 05       	cpc	r19, r1
    a986:	f9 f0       	breq	.+62     	; 0xa9c6 <malloc+0xb2>
    a988:	c9 01       	movw	r24, r18
    a98a:	84 1b       	sub	r24, r20
    a98c:	95 0b       	sbc	r25, r21
    a98e:	84 30       	cpi	r24, 0x04	; 4
    a990:	91 05       	cpc	r25, r1
    a992:	80 f4       	brcc	.+32     	; 0xa9b4 <malloc+0xa0>
    a994:	8a 81       	ldd	r24, Y+2	; 0x02
    a996:	9b 81       	ldd	r25, Y+3	; 0x03
    a998:	61 15       	cp	r22, r1
    a99a:	71 05       	cpc	r23, r1
    a99c:	21 f0       	breq	.+8      	; 0xa9a6 <malloc+0x92>
    a99e:	fb 01       	movw	r30, r22
    a9a0:	82 83       	std	Z+2, r24	; 0x02
    a9a2:	93 83       	std	Z+3, r25	; 0x03
    a9a4:	04 c0       	rjmp	.+8      	; 0xa9ae <malloc+0x9a>
    a9a6:	80 93 3e 33 	sts	0x333E, r24
    a9aa:	90 93 3f 33 	sts	0x333F, r25
    a9ae:	fe 01       	movw	r30, r28
    a9b0:	32 96       	adiw	r30, 0x02	; 2
    a9b2:	42 c0       	rjmp	.+132    	; 0xaa38 <malloc+0x124>
    a9b4:	fe 01       	movw	r30, r28
    a9b6:	e8 0f       	add	r30, r24
    a9b8:	f9 1f       	adc	r31, r25
    a9ba:	41 93       	st	Z+, r20
    a9bc:	51 93       	st	Z+, r21
    a9be:	02 97       	sbiw	r24, 0x02	; 2
    a9c0:	88 83       	st	Y, r24
    a9c2:	99 83       	std	Y+1, r25	; 0x01
    a9c4:	39 c0       	rjmp	.+114    	; 0xaa38 <malloc+0x124>
    a9c6:	80 91 3c 33 	lds	r24, 0x333C
    a9ca:	90 91 3d 33 	lds	r25, 0x333D
    a9ce:	00 97       	sbiw	r24, 0x00	; 0
    a9d0:	41 f4       	brne	.+16     	; 0xa9e2 <malloc+0xce>
    a9d2:	80 91 46 25 	lds	r24, 0x2546
    a9d6:	90 91 47 25 	lds	r25, 0x2547
    a9da:	80 93 3c 33 	sts	0x333C, r24
    a9de:	90 93 3d 33 	sts	0x333D, r25
    a9e2:	20 91 44 25 	lds	r18, 0x2544
    a9e6:	30 91 45 25 	lds	r19, 0x2545
    a9ea:	21 15       	cp	r18, r1
    a9ec:	31 05       	cpc	r19, r1
    a9ee:	41 f4       	brne	.+16     	; 0xaa00 <malloc+0xec>
    a9f0:	2d b7       	in	r18, 0x3d	; 61
    a9f2:	3e b7       	in	r19, 0x3e	; 62
    a9f4:	80 91 48 25 	lds	r24, 0x2548
    a9f8:	90 91 49 25 	lds	r25, 0x2549
    a9fc:	28 1b       	sub	r18, r24
    a9fe:	39 0b       	sbc	r19, r25
    aa00:	e0 91 3c 33 	lds	r30, 0x333C
    aa04:	f0 91 3d 33 	lds	r31, 0x333D
    aa08:	e2 17       	cp	r30, r18
    aa0a:	f3 07       	cpc	r31, r19
    aa0c:	98 f4       	brcc	.+38     	; 0xaa34 <malloc+0x120>
    aa0e:	2e 1b       	sub	r18, r30
    aa10:	3f 0b       	sbc	r19, r31
    aa12:	24 17       	cp	r18, r20
    aa14:	35 07       	cpc	r19, r21
    aa16:	70 f0       	brcs	.+28     	; 0xaa34 <malloc+0x120>
    aa18:	ca 01       	movw	r24, r20
    aa1a:	02 96       	adiw	r24, 0x02	; 2
    aa1c:	28 17       	cp	r18, r24
    aa1e:	39 07       	cpc	r19, r25
    aa20:	48 f0       	brcs	.+18     	; 0xaa34 <malloc+0x120>
    aa22:	8e 0f       	add	r24, r30
    aa24:	9f 1f       	adc	r25, r31
    aa26:	80 93 3c 33 	sts	0x333C, r24
    aa2a:	90 93 3d 33 	sts	0x333D, r25
    aa2e:	41 93       	st	Z+, r20
    aa30:	51 93       	st	Z+, r21
    aa32:	02 c0       	rjmp	.+4      	; 0xaa38 <malloc+0x124>
    aa34:	e0 e0       	ldi	r30, 0x00	; 0
    aa36:	f0 e0       	ldi	r31, 0x00	; 0
    aa38:	cf 01       	movw	r24, r30
    aa3a:	df 91       	pop	r29
    aa3c:	cf 91       	pop	r28
    aa3e:	08 95       	ret

0000aa40 <free>:
    aa40:	0f 93       	push	r16
    aa42:	1f 93       	push	r17
    aa44:	cf 93       	push	r28
    aa46:	df 93       	push	r29
    aa48:	9c 01       	movw	r18, r24
    aa4a:	00 97       	sbiw	r24, 0x00	; 0
    aa4c:	09 f4       	brne	.+2      	; 0xaa50 <free+0x10>
    aa4e:	8c c0       	rjmp	.+280    	; 0xab68 <free+0x128>
    aa50:	dc 01       	movw	r26, r24
    aa52:	12 97       	sbiw	r26, 0x02	; 2
    aa54:	12 96       	adiw	r26, 0x02	; 2
    aa56:	1d 92       	st	X+, r1
    aa58:	1c 92       	st	X, r1
    aa5a:	13 97       	sbiw	r26, 0x03	; 3
    aa5c:	60 91 3e 33 	lds	r22, 0x333E
    aa60:	70 91 3f 33 	lds	r23, 0x333F
    aa64:	61 15       	cp	r22, r1
    aa66:	71 05       	cpc	r23, r1
    aa68:	89 f4       	brne	.+34     	; 0xaa8c <free+0x4c>
    aa6a:	8d 91       	ld	r24, X+
    aa6c:	9c 91       	ld	r25, X
    aa6e:	11 97       	sbiw	r26, 0x01	; 1
    aa70:	82 0f       	add	r24, r18
    aa72:	93 1f       	adc	r25, r19
    aa74:	20 91 3c 33 	lds	r18, 0x333C
    aa78:	30 91 3d 33 	lds	r19, 0x333D
    aa7c:	28 17       	cp	r18, r24
    aa7e:	39 07       	cpc	r19, r25
    aa80:	69 f5       	brne	.+90     	; 0xaadc <free+0x9c>
    aa82:	a0 93 3c 33 	sts	0x333C, r26
    aa86:	b0 93 3d 33 	sts	0x333D, r27
    aa8a:	6e c0       	rjmp	.+220    	; 0xab68 <free+0x128>
    aa8c:	fb 01       	movw	r30, r22
    aa8e:	40 e0       	ldi	r20, 0x00	; 0
    aa90:	50 e0       	ldi	r21, 0x00	; 0
    aa92:	01 c0       	rjmp	.+2      	; 0xaa96 <free+0x56>
    aa94:	fc 01       	movw	r30, r24
    aa96:	ea 17       	cp	r30, r26
    aa98:	fb 07       	cpc	r31, r27
    aa9a:	30 f4       	brcc	.+12     	; 0xaaa8 <free+0x68>
    aa9c:	82 81       	ldd	r24, Z+2	; 0x02
    aa9e:	93 81       	ldd	r25, Z+3	; 0x03
    aaa0:	af 01       	movw	r20, r30
    aaa2:	00 97       	sbiw	r24, 0x00	; 0
    aaa4:	b9 f7       	brne	.-18     	; 0xaa94 <free+0x54>
    aaa6:	1f c0       	rjmp	.+62     	; 0xaae6 <free+0xa6>
    aaa8:	e9 01       	movw	r28, r18
    aaaa:	22 97       	sbiw	r28, 0x02	; 2
    aaac:	ea 83       	std	Y+2, r30	; 0x02
    aaae:	fb 83       	std	Y+3, r31	; 0x03
    aab0:	08 81       	ld	r16, Y
    aab2:	19 81       	ldd	r17, Y+1	; 0x01
    aab4:	c9 01       	movw	r24, r18
    aab6:	80 0f       	add	r24, r16
    aab8:	91 1f       	adc	r25, r17
    aaba:	8e 17       	cp	r24, r30
    aabc:	9f 07       	cpc	r25, r31
    aabe:	59 f4       	brne	.+22     	; 0xaad6 <free+0x96>
    aac0:	80 81       	ld	r24, Z
    aac2:	91 81       	ldd	r25, Z+1	; 0x01
    aac4:	80 0f       	add	r24, r16
    aac6:	91 1f       	adc	r25, r17
    aac8:	02 96       	adiw	r24, 0x02	; 2
    aaca:	88 83       	st	Y, r24
    aacc:	99 83       	std	Y+1, r25	; 0x01
    aace:	82 81       	ldd	r24, Z+2	; 0x02
    aad0:	93 81       	ldd	r25, Z+3	; 0x03
    aad2:	8a 83       	std	Y+2, r24	; 0x02
    aad4:	9b 83       	std	Y+3, r25	; 0x03
    aad6:	41 15       	cp	r20, r1
    aad8:	51 05       	cpc	r21, r1
    aada:	29 f4       	brne	.+10     	; 0xaae6 <free+0xa6>
    aadc:	a0 93 3e 33 	sts	0x333E, r26
    aae0:	b0 93 3f 33 	sts	0x333F, r27
    aae4:	41 c0       	rjmp	.+130    	; 0xab68 <free+0x128>
    aae6:	fa 01       	movw	r30, r20
    aae8:	a2 83       	std	Z+2, r26	; 0x02
    aaea:	b3 83       	std	Z+3, r27	; 0x03
    aaec:	c1 91       	ld	r28, Z+
    aaee:	d1 91       	ld	r29, Z+
    aaf0:	ec 0f       	add	r30, r28
    aaf2:	fd 1f       	adc	r31, r29
    aaf4:	ae 17       	cp	r26, r30
    aaf6:	bf 07       	cpc	r27, r31
    aaf8:	81 f4       	brne	.+32     	; 0xab1a <free+0xda>
    aafa:	f9 01       	movw	r30, r18
    aafc:	92 91       	ld	r25, -Z
    aafe:	82 91       	ld	r24, -Z
    ab00:	8c 0f       	add	r24, r28
    ab02:	9d 1f       	adc	r25, r29
    ab04:	02 96       	adiw	r24, 0x02	; 2
    ab06:	da 01       	movw	r26, r20
    ab08:	8d 93       	st	X+, r24
    ab0a:	9c 93       	st	X, r25
    ab0c:	11 97       	sbiw	r26, 0x01	; 1
    ab0e:	82 81       	ldd	r24, Z+2	; 0x02
    ab10:	93 81       	ldd	r25, Z+3	; 0x03
    ab12:	12 96       	adiw	r26, 0x02	; 2
    ab14:	8d 93       	st	X+, r24
    ab16:	9c 93       	st	X, r25
    ab18:	13 97       	sbiw	r26, 0x03	; 3
    ab1a:	e0 e0       	ldi	r30, 0x00	; 0
    ab1c:	f0 e0       	ldi	r31, 0x00	; 0
    ab1e:	02 c0       	rjmp	.+4      	; 0xab24 <free+0xe4>
    ab20:	fb 01       	movw	r30, r22
    ab22:	bc 01       	movw	r22, r24
    ab24:	db 01       	movw	r26, r22
    ab26:	12 96       	adiw	r26, 0x02	; 2
    ab28:	8d 91       	ld	r24, X+
    ab2a:	9c 91       	ld	r25, X
    ab2c:	13 97       	sbiw	r26, 0x03	; 3
    ab2e:	00 97       	sbiw	r24, 0x00	; 0
    ab30:	b9 f7       	brne	.-18     	; 0xab20 <free+0xe0>
    ab32:	cb 01       	movw	r24, r22
    ab34:	02 96       	adiw	r24, 0x02	; 2
    ab36:	2d 91       	ld	r18, X+
    ab38:	3c 91       	ld	r19, X
    ab3a:	11 97       	sbiw	r26, 0x01	; 1
    ab3c:	82 0f       	add	r24, r18
    ab3e:	93 1f       	adc	r25, r19
    ab40:	20 91 3c 33 	lds	r18, 0x333C
    ab44:	30 91 3d 33 	lds	r19, 0x333D
    ab48:	28 17       	cp	r18, r24
    ab4a:	39 07       	cpc	r19, r25
    ab4c:	69 f4       	brne	.+26     	; 0xab68 <free+0x128>
    ab4e:	30 97       	sbiw	r30, 0x00	; 0
    ab50:	29 f4       	brne	.+10     	; 0xab5c <free+0x11c>
    ab52:	10 92 3e 33 	sts	0x333E, r1
    ab56:	10 92 3f 33 	sts	0x333F, r1
    ab5a:	02 c0       	rjmp	.+4      	; 0xab60 <free+0x120>
    ab5c:	12 82       	std	Z+2, r1	; 0x02
    ab5e:	13 82       	std	Z+3, r1	; 0x03
    ab60:	60 93 3c 33 	sts	0x333C, r22
    ab64:	70 93 3d 33 	sts	0x333D, r23
    ab68:	df 91       	pop	r29
    ab6a:	cf 91       	pop	r28
    ab6c:	1f 91       	pop	r17
    ab6e:	0f 91       	pop	r16
    ab70:	08 95       	ret

0000ab72 <strtol>:
    ab72:	2f 92       	push	r2
    ab74:	3f 92       	push	r3
    ab76:	4f 92       	push	r4
    ab78:	5f 92       	push	r5
    ab7a:	6f 92       	push	r6
    ab7c:	7f 92       	push	r7
    ab7e:	8f 92       	push	r8
    ab80:	9f 92       	push	r9
    ab82:	bf 92       	push	r11
    ab84:	cf 92       	push	r12
    ab86:	df 92       	push	r13
    ab88:	ef 92       	push	r14
    ab8a:	ff 92       	push	r15
    ab8c:	0f 93       	push	r16
    ab8e:	1f 93       	push	r17
    ab90:	cf 93       	push	r28
    ab92:	df 93       	push	r29
    ab94:	3b 01       	movw	r6, r22
    ab96:	8a 01       	movw	r16, r20
    ab98:	61 15       	cp	r22, r1
    ab9a:	71 05       	cpc	r23, r1
    ab9c:	19 f0       	breq	.+6      	; 0xaba4 <strtol+0x32>
    ab9e:	fb 01       	movw	r30, r22
    aba0:	80 83       	st	Z, r24
    aba2:	91 83       	std	Z+1, r25	; 0x01
    aba4:	01 15       	cp	r16, r1
    aba6:	11 05       	cpc	r17, r1
    aba8:	39 f0       	breq	.+14     	; 0xabb8 <strtol+0x46>
    abaa:	98 01       	movw	r18, r16
    abac:	22 50       	subi	r18, 0x02	; 2
    abae:	30 40       	sbci	r19, 0x00	; 0
    abb0:	23 32       	cpi	r18, 0x23	; 35
    abb2:	31 05       	cpc	r19, r1
    abb4:	08 f0       	brcs	.+2      	; 0xabb8 <strtol+0x46>
    abb6:	03 c1       	rjmp	.+518    	; 0xadbe <strtol+0x24c>
    abb8:	6c 01       	movw	r12, r24
    abba:	76 01       	movw	r14, r12
    abbc:	08 94       	sec
    abbe:	c1 1c       	adc	r12, r1
    abc0:	d1 1c       	adc	r13, r1
    abc2:	f7 01       	movw	r30, r14
    abc4:	c0 81       	ld	r28, Z
    abc6:	46 01       	movw	r8, r12
    abc8:	8c 2f       	mov	r24, r28
    abca:	90 e0       	ldi	r25, 0x00	; 0
    abcc:	0e 94 f6 56 	call	0xadec	; 0xadec <isspace>
    abd0:	00 97       	sbiw	r24, 0x00	; 0
    abd2:	99 f7       	brne	.-26     	; 0xabba <strtol+0x48>
    abd4:	cd 32       	cpi	r28, 0x2D	; 45
    abd6:	49 f4       	brne	.+18     	; 0xabea <strtol+0x78>
    abd8:	f7 01       	movw	r30, r14
    abda:	c1 81       	ldd	r28, Z+1	; 0x01
    abdc:	b2 e0       	ldi	r27, 0x02	; 2
    abde:	8b 2e       	mov	r8, r27
    abe0:	91 2c       	mov	r9, r1
    abe2:	8e 0c       	add	r8, r14
    abe4:	9f 1c       	adc	r9, r15
    abe6:	d1 e0       	ldi	r29, 0x01	; 1
    abe8:	0a c0       	rjmp	.+20     	; 0xabfe <strtol+0x8c>
    abea:	cb 32       	cpi	r28, 0x2B	; 43
    abec:	39 f4       	brne	.+14     	; 0xabfc <strtol+0x8a>
    abee:	f7 01       	movw	r30, r14
    abf0:	c1 81       	ldd	r28, Z+1	; 0x01
    abf2:	a2 e0       	ldi	r26, 0x02	; 2
    abf4:	8a 2e       	mov	r8, r26
    abf6:	91 2c       	mov	r9, r1
    abf8:	8e 0c       	add	r8, r14
    abfa:	9f 1c       	adc	r9, r15
    abfc:	d0 e0       	ldi	r29, 0x00	; 0
    abfe:	01 15       	cp	r16, r1
    ac00:	11 05       	cpc	r17, r1
    ac02:	19 f0       	breq	.+6      	; 0xac0a <strtol+0x98>
    ac04:	00 31       	cpi	r16, 0x10	; 16
    ac06:	11 05       	cpc	r17, r1
    ac08:	c1 f4       	brne	.+48     	; 0xac3a <strtol+0xc8>
    ac0a:	c0 33       	cpi	r28, 0x30	; 48
    ac0c:	81 f4       	brne	.+32     	; 0xac2e <strtol+0xbc>
    ac0e:	f4 01       	movw	r30, r8
    ac10:	80 81       	ld	r24, Z
    ac12:	88 37       	cpi	r24, 0x78	; 120
    ac14:	11 f0       	breq	.+4      	; 0xac1a <strtol+0xa8>
    ac16:	88 35       	cpi	r24, 0x58	; 88
    ac18:	51 f4       	brne	.+20     	; 0xac2e <strtol+0xbc>
    ac1a:	f4 01       	movw	r30, r8
    ac1c:	c1 81       	ldd	r28, Z+1	; 0x01
    ac1e:	82 e0       	ldi	r24, 0x02	; 2
    ac20:	90 e0       	ldi	r25, 0x00	; 0
    ac22:	88 0e       	add	r8, r24
    ac24:	99 1e       	adc	r9, r25
    ac26:	d2 60       	ori	r29, 0x02	; 2
    ac28:	00 e1       	ldi	r16, 0x10	; 16
    ac2a:	10 e0       	ldi	r17, 0x00	; 0
    ac2c:	06 c0       	rjmp	.+12     	; 0xac3a <strtol+0xc8>
    ac2e:	01 15       	cp	r16, r1
    ac30:	11 05       	cpc	r17, r1
    ac32:	19 f4       	brne	.+6      	; 0xac3a <strtol+0xc8>
    ac34:	c0 33       	cpi	r28, 0x30	; 48
    ac36:	c1 f4       	brne	.+48     	; 0xac68 <strtol+0xf6>
    ac38:	22 c0       	rjmp	.+68     	; 0xac7e <strtol+0x10c>
    ac3a:	08 30       	cpi	r16, 0x08	; 8
    ac3c:	11 05       	cpc	r17, r1
    ac3e:	f9 f0       	breq	.+62     	; 0xac7e <strtol+0x10c>
    ac40:	09 30       	cpi	r16, 0x09	; 9
    ac42:	11 05       	cpc	r17, r1
    ac44:	24 f4       	brge	.+8      	; 0xac4e <strtol+0xdc>
    ac46:	02 30       	cpi	r16, 0x02	; 2
    ac48:	11 05       	cpc	r17, r1
    ac4a:	09 f5       	brne	.+66     	; 0xac8e <strtol+0x11c>
    ac4c:	07 c0       	rjmp	.+14     	; 0xac5c <strtol+0xea>
    ac4e:	0a 30       	cpi	r16, 0x0A	; 10
    ac50:	11 05       	cpc	r17, r1
    ac52:	51 f0       	breq	.+20     	; 0xac68 <strtol+0xf6>
    ac54:	00 31       	cpi	r16, 0x10	; 16
    ac56:	11 05       	cpc	r17, r1
    ac58:	d1 f4       	brne	.+52     	; 0xac8e <strtol+0x11c>
    ac5a:	27 c0       	rjmp	.+78     	; 0xacaa <strtol+0x138>
    ac5c:	c1 2c       	mov	r12, r1
    ac5e:	d1 2c       	mov	r13, r1
    ac60:	e1 2c       	mov	r14, r1
    ac62:	70 e4       	ldi	r23, 0x40	; 64
    ac64:	f7 2e       	mov	r15, r23
    ac66:	26 c0       	rjmp	.+76     	; 0xacb4 <strtol+0x142>
    ac68:	0a e0       	ldi	r16, 0x0A	; 10
    ac6a:	10 e0       	ldi	r17, 0x00	; 0
    ac6c:	6c ec       	ldi	r22, 0xCC	; 204
    ac6e:	c6 2e       	mov	r12, r22
    ac70:	6c ec       	ldi	r22, 0xCC	; 204
    ac72:	d6 2e       	mov	r13, r22
    ac74:	6c ec       	ldi	r22, 0xCC	; 204
    ac76:	e6 2e       	mov	r14, r22
    ac78:	6c e0       	ldi	r22, 0x0C	; 12
    ac7a:	f6 2e       	mov	r15, r22
    ac7c:	1b c0       	rjmp	.+54     	; 0xacb4 <strtol+0x142>
    ac7e:	08 e0       	ldi	r16, 0x08	; 8
    ac80:	10 e0       	ldi	r17, 0x00	; 0
    ac82:	c1 2c       	mov	r12, r1
    ac84:	d1 2c       	mov	r13, r1
    ac86:	e1 2c       	mov	r14, r1
    ac88:	50 e1       	ldi	r21, 0x10	; 16
    ac8a:	f5 2e       	mov	r15, r21
    ac8c:	13 c0       	rjmp	.+38     	; 0xacb4 <strtol+0x142>
    ac8e:	98 01       	movw	r18, r16
    ac90:	44 27       	eor	r20, r20
    ac92:	37 fd       	sbrc	r19, 7
    ac94:	40 95       	com	r20
    ac96:	54 2f       	mov	r21, r20
    ac98:	60 e0       	ldi	r22, 0x00	; 0
    ac9a:	70 e0       	ldi	r23, 0x00	; 0
    ac9c:	80 e0       	ldi	r24, 0x00	; 0
    ac9e:	90 e8       	ldi	r25, 0x80	; 128
    aca0:	0e 94 75 5b 	call	0xb6ea	; 0xb6ea <__udivmodsi4>
    aca4:	69 01       	movw	r12, r18
    aca6:	7a 01       	movw	r14, r20
    aca8:	05 c0       	rjmp	.+10     	; 0xacb4 <strtol+0x142>
    acaa:	c1 2c       	mov	r12, r1
    acac:	d1 2c       	mov	r13, r1
    acae:	e1 2c       	mov	r14, r1
    acb0:	48 e0       	ldi	r20, 0x08	; 8
    acb2:	f4 2e       	mov	r15, r20
    acb4:	20 e0       	ldi	r18, 0x00	; 0
    acb6:	40 e0       	ldi	r20, 0x00	; 0
    acb8:	50 e0       	ldi	r21, 0x00	; 0
    acba:	ba 01       	movw	r22, r20
    acbc:	18 01       	movw	r2, r16
    acbe:	44 24       	eor	r4, r4
    acc0:	37 fc       	sbrc	r3, 7
    acc2:	40 94       	com	r4
    acc4:	54 2c       	mov	r5, r4
    acc6:	30 ed       	ldi	r19, 0xD0	; 208
    acc8:	b3 2e       	mov	r11, r19
    acca:	bc 0e       	add	r11, r28
    accc:	99 e0       	ldi	r25, 0x09	; 9
    acce:	9b 15       	cp	r25, r11
    acd0:	70 f4       	brcc	.+28     	; 0xacee <strtol+0x17c>
    acd2:	8c 2f       	mov	r24, r28
    acd4:	81 54       	subi	r24, 0x41	; 65
    acd6:	8a 31       	cpi	r24, 0x1A	; 26
    acd8:	18 f4       	brcc	.+6      	; 0xace0 <strtol+0x16e>
    acda:	99 ec       	ldi	r25, 0xC9	; 201
    acdc:	b9 2e       	mov	r11, r25
    acde:	06 c0       	rjmp	.+12     	; 0xacec <strtol+0x17a>
    ace0:	8c 2f       	mov	r24, r28
    ace2:	81 56       	subi	r24, 0x61	; 97
    ace4:	8a 31       	cpi	r24, 0x1A	; 26
    ace6:	50 f5       	brcc	.+84     	; 0xad3c <strtol+0x1ca>
    ace8:	89 ea       	ldi	r24, 0xA9	; 169
    acea:	b8 2e       	mov	r11, r24
    acec:	bc 0e       	add	r11, r28
    acee:	8b 2d       	mov	r24, r11
    acf0:	90 e0       	ldi	r25, 0x00	; 0
    acf2:	80 17       	cp	r24, r16
    acf4:	91 07       	cpc	r25, r17
    acf6:	14 f5       	brge	.+68     	; 0xad3c <strtol+0x1ca>
    acf8:	27 fd       	sbrc	r18, 7
    acfa:	1c c0       	rjmp	.+56     	; 0xad34 <strtol+0x1c2>
    acfc:	c4 16       	cp	r12, r20
    acfe:	d5 06       	cpc	r13, r21
    ad00:	e6 06       	cpc	r14, r22
    ad02:	f7 06       	cpc	r15, r23
    ad04:	a0 f0       	brcs	.+40     	; 0xad2e <strtol+0x1bc>
    ad06:	cb 01       	movw	r24, r22
    ad08:	ba 01       	movw	r22, r20
    ad0a:	a2 01       	movw	r20, r4
    ad0c:	91 01       	movw	r18, r2
    ad0e:	0e 94 56 5b 	call	0xb6ac	; 0xb6ac <__mulsi3>
    ad12:	ab 01       	movw	r20, r22
    ad14:	bc 01       	movw	r22, r24
    ad16:	4b 0d       	add	r20, r11
    ad18:	51 1d       	adc	r21, r1
    ad1a:	61 1d       	adc	r22, r1
    ad1c:	71 1d       	adc	r23, r1
    ad1e:	41 30       	cpi	r20, 0x01	; 1
    ad20:	e0 e0       	ldi	r30, 0x00	; 0
    ad22:	5e 07       	cpc	r21, r30
    ad24:	e0 e0       	ldi	r30, 0x00	; 0
    ad26:	6e 07       	cpc	r22, r30
    ad28:	e0 e8       	ldi	r30, 0x80	; 128
    ad2a:	7e 07       	cpc	r23, r30
    ad2c:	10 f0       	brcs	.+4      	; 0xad32 <strtol+0x1c0>
    ad2e:	2f ef       	ldi	r18, 0xFF	; 255
    ad30:	01 c0       	rjmp	.+2      	; 0xad34 <strtol+0x1c2>
    ad32:	21 e0       	ldi	r18, 0x01	; 1
    ad34:	f4 01       	movw	r30, r8
    ad36:	c1 91       	ld	r28, Z+
    ad38:	4f 01       	movw	r8, r30
    ad3a:	c5 cf       	rjmp	.-118    	; 0xacc6 <strtol+0x154>
    ad3c:	61 14       	cp	r6, r1
    ad3e:	71 04       	cpc	r7, r1
    ad40:	89 f0       	breq	.+34     	; 0xad64 <strtol+0x1f2>
    ad42:	22 23       	and	r18, r18
    ad44:	39 f0       	breq	.+14     	; 0xad54 <strtol+0x1e2>
    ad46:	08 94       	sec
    ad48:	81 08       	sbc	r8, r1
    ad4a:	91 08       	sbc	r9, r1
    ad4c:	f3 01       	movw	r30, r6
    ad4e:	80 82       	st	Z, r8
    ad50:	91 82       	std	Z+1, r9	; 0x01
    ad52:	08 c0       	rjmp	.+16     	; 0xad64 <strtol+0x1f2>
    ad54:	d1 ff       	sbrs	r29, 1
    ad56:	1a c0       	rjmp	.+52     	; 0xad8c <strtol+0x21a>
    ad58:	c4 01       	movw	r24, r8
    ad5a:	02 97       	sbiw	r24, 0x02	; 2
    ad5c:	f3 01       	movw	r30, r6
    ad5e:	80 83       	st	Z, r24
    ad60:	91 83       	std	Z+1, r25	; 0x01
    ad62:	14 c0       	rjmp	.+40     	; 0xad8c <strtol+0x21a>
    ad64:	27 ff       	sbrs	r18, 7
    ad66:	12 c0       	rjmp	.+36     	; 0xad8c <strtol+0x21a>
    ad68:	d0 ff       	sbrs	r29, 0
    ad6a:	05 c0       	rjmp	.+10     	; 0xad76 <strtol+0x204>
    ad6c:	40 e0       	ldi	r20, 0x00	; 0
    ad6e:	50 e0       	ldi	r21, 0x00	; 0
    ad70:	60 e0       	ldi	r22, 0x00	; 0
    ad72:	70 e8       	ldi	r23, 0x80	; 128
    ad74:	04 c0       	rjmp	.+8      	; 0xad7e <strtol+0x20c>
    ad76:	4f ef       	ldi	r20, 0xFF	; 255
    ad78:	5f ef       	ldi	r21, 0xFF	; 255
    ad7a:	6f ef       	ldi	r22, 0xFF	; 255
    ad7c:	7f e7       	ldi	r23, 0x7F	; 127
    ad7e:	82 e2       	ldi	r24, 0x22	; 34
    ad80:	90 e0       	ldi	r25, 0x00	; 0
    ad82:	80 93 46 33 	sts	0x3346, r24
    ad86:	90 93 47 33 	sts	0x3347, r25
    ad8a:	16 c0       	rjmp	.+44     	; 0xadb8 <strtol+0x246>
    ad8c:	d0 ff       	sbrs	r29, 0
    ad8e:	08 c0       	rjmp	.+16     	; 0xada0 <strtol+0x22e>
    ad90:	70 95       	com	r23
    ad92:	60 95       	com	r22
    ad94:	50 95       	com	r21
    ad96:	41 95       	neg	r20
    ad98:	5f 4f       	sbci	r21, 0xFF	; 255
    ad9a:	6f 4f       	sbci	r22, 0xFF	; 255
    ad9c:	7f 4f       	sbci	r23, 0xFF	; 255
    ad9e:	0c c0       	rjmp	.+24     	; 0xadb8 <strtol+0x246>
    ada0:	77 ff       	sbrs	r23, 7
    ada2:	0a c0       	rjmp	.+20     	; 0xadb8 <strtol+0x246>
    ada4:	82 e2       	ldi	r24, 0x22	; 34
    ada6:	90 e0       	ldi	r25, 0x00	; 0
    ada8:	80 93 46 33 	sts	0x3346, r24
    adac:	90 93 47 33 	sts	0x3347, r25
    adb0:	4f ef       	ldi	r20, 0xFF	; 255
    adb2:	5f ef       	ldi	r21, 0xFF	; 255
    adb4:	6f ef       	ldi	r22, 0xFF	; 255
    adb6:	7f e7       	ldi	r23, 0x7F	; 127
    adb8:	8a 01       	movw	r16, r20
    adba:	9b 01       	movw	r18, r22
    adbc:	03 c0       	rjmp	.+6      	; 0xadc4 <strtol+0x252>
    adbe:	00 e0       	ldi	r16, 0x00	; 0
    adc0:	10 e0       	ldi	r17, 0x00	; 0
    adc2:	98 01       	movw	r18, r16
    adc4:	b8 01       	movw	r22, r16
    adc6:	c9 01       	movw	r24, r18
    adc8:	df 91       	pop	r29
    adca:	cf 91       	pop	r28
    adcc:	1f 91       	pop	r17
    adce:	0f 91       	pop	r16
    add0:	ff 90       	pop	r15
    add2:	ef 90       	pop	r14
    add4:	df 90       	pop	r13
    add6:	cf 90       	pop	r12
    add8:	bf 90       	pop	r11
    adda:	9f 90       	pop	r9
    addc:	8f 90       	pop	r8
    adde:	7f 90       	pop	r7
    ade0:	6f 90       	pop	r6
    ade2:	5f 90       	pop	r5
    ade4:	4f 90       	pop	r4
    ade6:	3f 90       	pop	r3
    ade8:	2f 90       	pop	r2
    adea:	08 95       	ret

0000adec <isspace>:
    adec:	91 11       	cpse	r25, r1
    adee:	e7 c3       	rjmp	.+1998   	; 0xb5be <__ctype_isfalse>
    adf0:	80 32       	cpi	r24, 0x20	; 32
    adf2:	19 f0       	breq	.+6      	; 0xadfa <isspace+0xe>
    adf4:	89 50       	subi	r24, 0x09	; 9
    adf6:	85 50       	subi	r24, 0x05	; 5
    adf8:	d0 f7       	brcc	.-12     	; 0xadee <isspace+0x2>
    adfa:	08 95       	ret

0000adfc <memcpy_P>:
    adfc:	fb 01       	movw	r30, r22
    adfe:	dc 01       	movw	r26, r24
    ae00:	02 c0       	rjmp	.+4      	; 0xae06 <memcpy_P+0xa>
    ae02:	05 90       	lpm	r0, Z+
    ae04:	0d 92       	st	X+, r0
    ae06:	41 50       	subi	r20, 0x01	; 1
    ae08:	50 40       	sbci	r21, 0x00	; 0
    ae0a:	d8 f7       	brcc	.-10     	; 0xae02 <memcpy_P+0x6>
    ae0c:	08 95       	ret

0000ae0e <strncmp_P>:
    ae0e:	fb 01       	movw	r30, r22
    ae10:	dc 01       	movw	r26, r24
    ae12:	41 50       	subi	r20, 0x01	; 1
    ae14:	50 40       	sbci	r21, 0x00	; 0
    ae16:	30 f0       	brcs	.+12     	; 0xae24 <strncmp_P+0x16>
    ae18:	8d 91       	ld	r24, X+
    ae1a:	05 90       	lpm	r0, Z+
    ae1c:	80 19       	sub	r24, r0
    ae1e:	19 f4       	brne	.+6      	; 0xae26 <strncmp_P+0x18>
    ae20:	00 20       	and	r0, r0
    ae22:	b9 f7       	brne	.-18     	; 0xae12 <strncmp_P+0x4>
    ae24:	88 1b       	sub	r24, r24
    ae26:	99 0b       	sbc	r25, r25
    ae28:	08 95       	ret

0000ae2a <memcpy>:
    ae2a:	fb 01       	movw	r30, r22
    ae2c:	dc 01       	movw	r26, r24
    ae2e:	02 c0       	rjmp	.+4      	; 0xae34 <memcpy+0xa>
    ae30:	01 90       	ld	r0, Z+
    ae32:	0d 92       	st	X+, r0
    ae34:	41 50       	subi	r20, 0x01	; 1
    ae36:	50 40       	sbci	r21, 0x00	; 0
    ae38:	d8 f7       	brcc	.-10     	; 0xae30 <memcpy+0x6>
    ae3a:	08 95       	ret

0000ae3c <memset>:
    ae3c:	dc 01       	movw	r26, r24
    ae3e:	01 c0       	rjmp	.+2      	; 0xae42 <memset+0x6>
    ae40:	6d 93       	st	X+, r22
    ae42:	41 50       	subi	r20, 0x01	; 1
    ae44:	50 40       	sbci	r21, 0x00	; 0
    ae46:	e0 f7       	brcc	.-8      	; 0xae40 <memset+0x4>
    ae48:	08 95       	ret

0000ae4a <strcat>:
    ae4a:	fb 01       	movw	r30, r22
    ae4c:	dc 01       	movw	r26, r24
    ae4e:	0d 90       	ld	r0, X+
    ae50:	00 20       	and	r0, r0
    ae52:	e9 f7       	brne	.-6      	; 0xae4e <strcat+0x4>
    ae54:	11 97       	sbiw	r26, 0x01	; 1
    ae56:	01 90       	ld	r0, Z+
    ae58:	0d 92       	st	X+, r0
    ae5a:	00 20       	and	r0, r0
    ae5c:	e1 f7       	brne	.-8      	; 0xae56 <strcat+0xc>
    ae5e:	08 95       	ret

0000ae60 <strcpy>:
    ae60:	fb 01       	movw	r30, r22
    ae62:	dc 01       	movw	r26, r24
    ae64:	01 90       	ld	r0, Z+
    ae66:	0d 92       	st	X+, r0
    ae68:	00 20       	and	r0, r0
    ae6a:	e1 f7       	brne	.-8      	; 0xae64 <strcpy+0x4>
    ae6c:	08 95       	ret

0000ae6e <strncmp>:
    ae6e:	fb 01       	movw	r30, r22
    ae70:	dc 01       	movw	r26, r24
    ae72:	41 50       	subi	r20, 0x01	; 1
    ae74:	50 40       	sbci	r21, 0x00	; 0
    ae76:	30 f0       	brcs	.+12     	; 0xae84 <strncmp+0x16>
    ae78:	8d 91       	ld	r24, X+
    ae7a:	01 90       	ld	r0, Z+
    ae7c:	80 19       	sub	r24, r0
    ae7e:	19 f4       	brne	.+6      	; 0xae86 <strncmp+0x18>
    ae80:	00 20       	and	r0, r0
    ae82:	b9 f7       	brne	.-18     	; 0xae72 <strncmp+0x4>
    ae84:	88 1b       	sub	r24, r24
    ae86:	99 0b       	sbc	r25, r25
    ae88:	08 95       	ret

0000ae8a <strncpy>:
    ae8a:	fb 01       	movw	r30, r22
    ae8c:	dc 01       	movw	r26, r24
    ae8e:	41 50       	subi	r20, 0x01	; 1
    ae90:	50 40       	sbci	r21, 0x00	; 0
    ae92:	48 f0       	brcs	.+18     	; 0xaea6 <strncpy+0x1c>
    ae94:	01 90       	ld	r0, Z+
    ae96:	0d 92       	st	X+, r0
    ae98:	00 20       	and	r0, r0
    ae9a:	c9 f7       	brne	.-14     	; 0xae8e <strncpy+0x4>
    ae9c:	01 c0       	rjmp	.+2      	; 0xaea0 <strncpy+0x16>
    ae9e:	1d 92       	st	X+, r1
    aea0:	41 50       	subi	r20, 0x01	; 1
    aea2:	50 40       	sbci	r21, 0x00	; 0
    aea4:	e0 f7       	brcc	.-8      	; 0xae9e <strncpy+0x14>
    aea6:	08 95       	ret

0000aea8 <fclose>:
    aea8:	fc 01       	movw	r30, r24
    aeaa:	23 81       	ldd	r18, Z+3	; 0x03
    aeac:	27 ff       	sbrs	r18, 7
    aeae:	23 c0       	rjmp	.+70     	; 0xaef6 <fclose+0x4e>
    aeb0:	20 91 40 33 	lds	r18, 0x3340
    aeb4:	30 91 41 33 	lds	r19, 0x3341
    aeb8:	28 17       	cp	r18, r24
    aeba:	39 07       	cpc	r19, r25
    aebc:	21 f4       	brne	.+8      	; 0xaec6 <fclose+0x1e>
    aebe:	10 92 40 33 	sts	0x3340, r1
    aec2:	10 92 41 33 	sts	0x3341, r1
    aec6:	20 91 42 33 	lds	r18, 0x3342
    aeca:	30 91 43 33 	lds	r19, 0x3343
    aece:	28 17       	cp	r18, r24
    aed0:	39 07       	cpc	r19, r25
    aed2:	21 f4       	brne	.+8      	; 0xaedc <fclose+0x34>
    aed4:	10 92 42 33 	sts	0x3342, r1
    aed8:	10 92 43 33 	sts	0x3343, r1
    aedc:	20 91 44 33 	lds	r18, 0x3344
    aee0:	30 91 45 33 	lds	r19, 0x3345
    aee4:	28 17       	cp	r18, r24
    aee6:	39 07       	cpc	r19, r25
    aee8:	21 f4       	brne	.+8      	; 0xaef2 <fclose+0x4a>
    aeea:	10 92 44 33 	sts	0x3344, r1
    aeee:	10 92 45 33 	sts	0x3345, r1
    aef2:	0e 94 20 55 	call	0xaa40	; 0xaa40 <free>
    aef6:	80 e0       	ldi	r24, 0x00	; 0
    aef8:	90 e0       	ldi	r25, 0x00	; 0
    aefa:	08 95       	ret

0000aefc <fgetc>:
    aefc:	cf 93       	push	r28
    aefe:	df 93       	push	r29
    af00:	ec 01       	movw	r28, r24
    af02:	2b 81       	ldd	r18, Y+3	; 0x03
    af04:	20 ff       	sbrs	r18, 0
    af06:	35 c0       	rjmp	.+106    	; 0xaf72 <fgetc+0x76>
    af08:	26 ff       	sbrs	r18, 6
    af0a:	09 c0       	rjmp	.+18     	; 0xaf1e <fgetc+0x22>
    af0c:	2f 7b       	andi	r18, 0xBF	; 191
    af0e:	2b 83       	std	Y+3, r18	; 0x03
    af10:	8e 81       	ldd	r24, Y+6	; 0x06
    af12:	9f 81       	ldd	r25, Y+7	; 0x07
    af14:	01 96       	adiw	r24, 0x01	; 1
    af16:	8e 83       	std	Y+6, r24	; 0x06
    af18:	9f 83       	std	Y+7, r25	; 0x07
    af1a:	8a 81       	ldd	r24, Y+2	; 0x02
    af1c:	28 c0       	rjmp	.+80     	; 0xaf6e <fgetc+0x72>
    af1e:	22 ff       	sbrs	r18, 2
    af20:	0f c0       	rjmp	.+30     	; 0xaf40 <fgetc+0x44>
    af22:	e8 81       	ld	r30, Y
    af24:	f9 81       	ldd	r31, Y+1	; 0x01
    af26:	80 81       	ld	r24, Z
    af28:	99 27       	eor	r25, r25
    af2a:	87 fd       	sbrc	r24, 7
    af2c:	90 95       	com	r25
    af2e:	00 97       	sbiw	r24, 0x00	; 0
    af30:	19 f4       	brne	.+6      	; 0xaf38 <fgetc+0x3c>
    af32:	20 62       	ori	r18, 0x20	; 32
    af34:	2b 83       	std	Y+3, r18	; 0x03
    af36:	1d c0       	rjmp	.+58     	; 0xaf72 <fgetc+0x76>
    af38:	31 96       	adiw	r30, 0x01	; 1
    af3a:	e8 83       	st	Y, r30
    af3c:	f9 83       	std	Y+1, r31	; 0x01
    af3e:	11 c0       	rjmp	.+34     	; 0xaf62 <fgetc+0x66>
    af40:	ea 85       	ldd	r30, Y+10	; 0x0a
    af42:	fb 85       	ldd	r31, Y+11	; 0x0b
    af44:	ce 01       	movw	r24, r28
    af46:	19 95       	eicall
    af48:	97 ff       	sbrs	r25, 7
    af4a:	0b c0       	rjmp	.+22     	; 0xaf62 <fgetc+0x66>
    af4c:	2b 81       	ldd	r18, Y+3	; 0x03
    af4e:	3f ef       	ldi	r19, 0xFF	; 255
    af50:	8f 3f       	cpi	r24, 0xFF	; 255
    af52:	93 07       	cpc	r25, r19
    af54:	11 f4       	brne	.+4      	; 0xaf5a <fgetc+0x5e>
    af56:	80 e1       	ldi	r24, 0x10	; 16
    af58:	01 c0       	rjmp	.+2      	; 0xaf5c <fgetc+0x60>
    af5a:	80 e2       	ldi	r24, 0x20	; 32
    af5c:	82 2b       	or	r24, r18
    af5e:	8b 83       	std	Y+3, r24	; 0x03
    af60:	08 c0       	rjmp	.+16     	; 0xaf72 <fgetc+0x76>
    af62:	2e 81       	ldd	r18, Y+6	; 0x06
    af64:	3f 81       	ldd	r19, Y+7	; 0x07
    af66:	2f 5f       	subi	r18, 0xFF	; 255
    af68:	3f 4f       	sbci	r19, 0xFF	; 255
    af6a:	2e 83       	std	Y+6, r18	; 0x06
    af6c:	3f 83       	std	Y+7, r19	; 0x07
    af6e:	90 e0       	ldi	r25, 0x00	; 0
    af70:	02 c0       	rjmp	.+4      	; 0xaf76 <fgetc+0x7a>
    af72:	8f ef       	ldi	r24, 0xFF	; 255
    af74:	9f ef       	ldi	r25, 0xFF	; 255
    af76:	df 91       	pop	r29
    af78:	cf 91       	pop	r28
    af7a:	08 95       	ret

0000af7c <fprintf>:
    af7c:	cf 93       	push	r28
    af7e:	df 93       	push	r29
    af80:	cd b7       	in	r28, 0x3d	; 61
    af82:	de b7       	in	r29, 0x3e	; 62
    af84:	ae 01       	movw	r20, r28
    af86:	46 5f       	subi	r20, 0xF6	; 246
    af88:	5f 4f       	sbci	r21, 0xFF	; 255
    af8a:	8e 81       	ldd	r24, Y+6	; 0x06
    af8c:	9f 81       	ldd	r25, Y+7	; 0x07
    af8e:	68 85       	ldd	r22, Y+8	; 0x08
    af90:	79 85       	ldd	r23, Y+9	; 0x09
    af92:	0e 94 66 58 	call	0xb0cc	; 0xb0cc <vfprintf>
    af96:	df 91       	pop	r29
    af98:	cf 91       	pop	r28
    af9a:	08 95       	ret

0000af9c <fprintf_P>:
    af9c:	0f 93       	push	r16
    af9e:	1f 93       	push	r17
    afa0:	cf 93       	push	r28
    afa2:	df 93       	push	r29
    afa4:	cd b7       	in	r28, 0x3d	; 61
    afa6:	de b7       	in	r29, 0x3e	; 62
    afa8:	08 85       	ldd	r16, Y+8	; 0x08
    afaa:	19 85       	ldd	r17, Y+9	; 0x09
    afac:	ae 01       	movw	r20, r28
    afae:	44 5f       	subi	r20, 0xF4	; 244
    afb0:	5f 4f       	sbci	r21, 0xFF	; 255
    afb2:	f8 01       	movw	r30, r16
    afb4:	83 81       	ldd	r24, Z+3	; 0x03
    afb6:	88 60       	ori	r24, 0x08	; 8
    afb8:	83 83       	std	Z+3, r24	; 0x03
    afba:	c8 01       	movw	r24, r16
    afbc:	6a 85       	ldd	r22, Y+10	; 0x0a
    afbe:	7b 85       	ldd	r23, Y+11	; 0x0b
    afc0:	0e 94 66 58 	call	0xb0cc	; 0xb0cc <vfprintf>
    afc4:	f8 01       	movw	r30, r16
    afc6:	23 81       	ldd	r18, Z+3	; 0x03
    afc8:	27 7f       	andi	r18, 0xF7	; 247
    afca:	23 83       	std	Z+3, r18	; 0x03
    afcc:	df 91       	pop	r29
    afce:	cf 91       	pop	r28
    afd0:	1f 91       	pop	r17
    afd2:	0f 91       	pop	r16
    afd4:	08 95       	ret

0000afd6 <fputc>:
    afd6:	0f 93       	push	r16
    afd8:	1f 93       	push	r17
    afda:	cf 93       	push	r28
    afdc:	df 93       	push	r29
    afde:	8c 01       	movw	r16, r24
    afe0:	eb 01       	movw	r28, r22
    afe2:	8b 81       	ldd	r24, Y+3	; 0x03
    afe4:	81 ff       	sbrs	r24, 1
    afe6:	1b c0       	rjmp	.+54     	; 0xb01e <fputc+0x48>
    afe8:	82 ff       	sbrs	r24, 2
    afea:	0d c0       	rjmp	.+26     	; 0xb006 <fputc+0x30>
    afec:	2e 81       	ldd	r18, Y+6	; 0x06
    afee:	3f 81       	ldd	r19, Y+7	; 0x07
    aff0:	8c 81       	ldd	r24, Y+4	; 0x04
    aff2:	9d 81       	ldd	r25, Y+5	; 0x05
    aff4:	28 17       	cp	r18, r24
    aff6:	39 07       	cpc	r19, r25
    aff8:	64 f4       	brge	.+24     	; 0xb012 <fputc+0x3c>
    affa:	e8 81       	ld	r30, Y
    affc:	f9 81       	ldd	r31, Y+1	; 0x01
    affe:	01 93       	st	Z+, r16
    b000:	e8 83       	st	Y, r30
    b002:	f9 83       	std	Y+1, r31	; 0x01
    b004:	06 c0       	rjmp	.+12     	; 0xb012 <fputc+0x3c>
    b006:	e8 85       	ldd	r30, Y+8	; 0x08
    b008:	f9 85       	ldd	r31, Y+9	; 0x09
    b00a:	80 2f       	mov	r24, r16
    b00c:	19 95       	eicall
    b00e:	00 97       	sbiw	r24, 0x00	; 0
    b010:	31 f4       	brne	.+12     	; 0xb01e <fputc+0x48>
    b012:	8e 81       	ldd	r24, Y+6	; 0x06
    b014:	9f 81       	ldd	r25, Y+7	; 0x07
    b016:	01 96       	adiw	r24, 0x01	; 1
    b018:	8e 83       	std	Y+6, r24	; 0x06
    b01a:	9f 83       	std	Y+7, r25	; 0x07
    b01c:	02 c0       	rjmp	.+4      	; 0xb022 <fputc+0x4c>
    b01e:	0f ef       	ldi	r16, 0xFF	; 255
    b020:	1f ef       	ldi	r17, 0xFF	; 255
    b022:	c8 01       	movw	r24, r16
    b024:	df 91       	pop	r29
    b026:	cf 91       	pop	r28
    b028:	1f 91       	pop	r17
    b02a:	0f 91       	pop	r16
    b02c:	08 95       	ret

0000b02e <fputs>:
    b02e:	ef 92       	push	r14
    b030:	ff 92       	push	r15
    b032:	0f 93       	push	r16
    b034:	1f 93       	push	r17
    b036:	cf 93       	push	r28
    b038:	df 93       	push	r29
    b03a:	7c 01       	movw	r14, r24
    b03c:	eb 01       	movw	r28, r22
    b03e:	8b 81       	ldd	r24, Y+3	; 0x03
    b040:	81 ff       	sbrs	r24, 1
    b042:	11 c0       	rjmp	.+34     	; 0xb066 <fputs+0x38>
    b044:	00 e0       	ldi	r16, 0x00	; 0
    b046:	10 e0       	ldi	r17, 0x00	; 0
    b048:	08 c0       	rjmp	.+16     	; 0xb05a <fputs+0x2c>
    b04a:	e8 85       	ldd	r30, Y+8	; 0x08
    b04c:	f9 85       	ldd	r31, Y+9	; 0x09
    b04e:	be 01       	movw	r22, r28
    b050:	19 95       	eicall
    b052:	00 97       	sbiw	r24, 0x00	; 0
    b054:	11 f0       	breq	.+4      	; 0xb05a <fputs+0x2c>
    b056:	0f ef       	ldi	r16, 0xFF	; 255
    b058:	1f ef       	ldi	r17, 0xFF	; 255
    b05a:	f7 01       	movw	r30, r14
    b05c:	81 91       	ld	r24, Z+
    b05e:	7f 01       	movw	r14, r30
    b060:	88 23       	and	r24, r24
    b062:	99 f7       	brne	.-26     	; 0xb04a <fputs+0x1c>
    b064:	02 c0       	rjmp	.+4      	; 0xb06a <fputs+0x3c>
    b066:	0f ef       	ldi	r16, 0xFF	; 255
    b068:	1f ef       	ldi	r17, 0xFF	; 255
    b06a:	c8 01       	movw	r24, r16
    b06c:	df 91       	pop	r29
    b06e:	cf 91       	pop	r28
    b070:	1f 91       	pop	r17
    b072:	0f 91       	pop	r16
    b074:	ff 90       	pop	r15
    b076:	ef 90       	pop	r14
    b078:	08 95       	ret

0000b07a <sprintf>:
    b07a:	0f 93       	push	r16
    b07c:	1f 93       	push	r17
    b07e:	cf 93       	push	r28
    b080:	df 93       	push	r29
    b082:	cd b7       	in	r28, 0x3d	; 61
    b084:	de b7       	in	r29, 0x3e	; 62
    b086:	2e 97       	sbiw	r28, 0x0e	; 14
    b088:	cd bf       	out	0x3d, r28	; 61
    b08a:	de bf       	out	0x3e, r29	; 62
    b08c:	0e 89       	ldd	r16, Y+22	; 0x16
    b08e:	1f 89       	ldd	r17, Y+23	; 0x17
    b090:	86 e0       	ldi	r24, 0x06	; 6
    b092:	8c 83       	std	Y+4, r24	; 0x04
    b094:	09 83       	std	Y+1, r16	; 0x01
    b096:	1a 83       	std	Y+2, r17	; 0x02
    b098:	8f ef       	ldi	r24, 0xFF	; 255
    b09a:	9f e7       	ldi	r25, 0x7F	; 127
    b09c:	8d 83       	std	Y+5, r24	; 0x05
    b09e:	9e 83       	std	Y+6, r25	; 0x06
    b0a0:	ae 01       	movw	r20, r28
    b0a2:	46 5e       	subi	r20, 0xE6	; 230
    b0a4:	5f 4f       	sbci	r21, 0xFF	; 255
    b0a6:	ce 01       	movw	r24, r28
    b0a8:	01 96       	adiw	r24, 0x01	; 1
    b0aa:	68 8d       	ldd	r22, Y+24	; 0x18
    b0ac:	79 8d       	ldd	r23, Y+25	; 0x19
    b0ae:	0e 94 66 58 	call	0xb0cc	; 0xb0cc <vfprintf>
    b0b2:	ef 81       	ldd	r30, Y+7	; 0x07
    b0b4:	f8 85       	ldd	r31, Y+8	; 0x08
    b0b6:	e0 0f       	add	r30, r16
    b0b8:	f1 1f       	adc	r31, r17
    b0ba:	10 82       	st	Z, r1
    b0bc:	2e 96       	adiw	r28, 0x0e	; 14
    b0be:	cd bf       	out	0x3d, r28	; 61
    b0c0:	de bf       	out	0x3e, r29	; 62
    b0c2:	df 91       	pop	r29
    b0c4:	cf 91       	pop	r28
    b0c6:	1f 91       	pop	r17
    b0c8:	0f 91       	pop	r16
    b0ca:	08 95       	ret

0000b0cc <vfprintf>:
    b0cc:	2f 92       	push	r2
    b0ce:	3f 92       	push	r3
    b0d0:	4f 92       	push	r4
    b0d2:	5f 92       	push	r5
    b0d4:	6f 92       	push	r6
    b0d6:	7f 92       	push	r7
    b0d8:	8f 92       	push	r8
    b0da:	9f 92       	push	r9
    b0dc:	af 92       	push	r10
    b0de:	bf 92       	push	r11
    b0e0:	cf 92       	push	r12
    b0e2:	df 92       	push	r13
    b0e4:	ef 92       	push	r14
    b0e6:	ff 92       	push	r15
    b0e8:	0f 93       	push	r16
    b0ea:	1f 93       	push	r17
    b0ec:	cf 93       	push	r28
    b0ee:	df 93       	push	r29
    b0f0:	cd b7       	in	r28, 0x3d	; 61
    b0f2:	de b7       	in	r29, 0x3e	; 62
    b0f4:	2d 97       	sbiw	r28, 0x0d	; 13
    b0f6:	cd bf       	out	0x3d, r28	; 61
    b0f8:	de bf       	out	0x3e, r29	; 62
    b0fa:	3c 01       	movw	r6, r24
    b0fc:	6c 87       	std	Y+12, r22	; 0x0c
    b0fe:	7d 87       	std	Y+13, r23	; 0x0d
    b100:	5a 01       	movw	r10, r20
    b102:	fc 01       	movw	r30, r24
    b104:	16 82       	std	Z+6, r1	; 0x06
    b106:	17 82       	std	Z+7, r1	; 0x07
    b108:	83 81       	ldd	r24, Z+3	; 0x03
    b10a:	81 ff       	sbrs	r24, 1
    b10c:	c8 c1       	rjmp	.+912    	; 0xb49e <vfprintf+0x3d2>
    b10e:	2e 01       	movw	r4, r28
    b110:	08 94       	sec
    b112:	41 1c       	adc	r4, r1
    b114:	51 1c       	adc	r5, r1
    b116:	f3 01       	movw	r30, r6
    b118:	93 81       	ldd	r25, Z+3	; 0x03
    b11a:	ec 85       	ldd	r30, Y+12	; 0x0c
    b11c:	fd 85       	ldd	r31, Y+13	; 0x0d
    b11e:	93 fd       	sbrc	r25, 3
    b120:	85 91       	lpm	r24, Z+
    b122:	93 ff       	sbrs	r25, 3
    b124:	81 91       	ld	r24, Z+
    b126:	ec 87       	std	Y+12, r30	; 0x0c
    b128:	fd 87       	std	Y+13, r31	; 0x0d
    b12a:	88 23       	and	r24, r24
    b12c:	09 f4       	brne	.+2      	; 0xb130 <vfprintf+0x64>
    b12e:	b3 c1       	rjmp	.+870    	; 0xb496 <vfprintf+0x3ca>
    b130:	85 32       	cpi	r24, 0x25	; 37
    b132:	41 f4       	brne	.+16     	; 0xb144 <vfprintf+0x78>
    b134:	93 fd       	sbrc	r25, 3
    b136:	85 91       	lpm	r24, Z+
    b138:	93 ff       	sbrs	r25, 3
    b13a:	81 91       	ld	r24, Z+
    b13c:	ec 87       	std	Y+12, r30	; 0x0c
    b13e:	fd 87       	std	Y+13, r31	; 0x0d
    b140:	85 32       	cpi	r24, 0x25	; 37
    b142:	29 f4       	brne	.+10     	; 0xb14e <vfprintf+0x82>
    b144:	90 e0       	ldi	r25, 0x00	; 0
    b146:	b3 01       	movw	r22, r6
    b148:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b14c:	e4 cf       	rjmp	.-56     	; 0xb116 <vfprintf+0x4a>
    b14e:	ff 24       	eor	r15, r15
    b150:	ee 24       	eor	r14, r14
    b152:	10 e0       	ldi	r17, 0x00	; 0
    b154:	10 32       	cpi	r17, 0x20	; 32
    b156:	b0 f4       	brcc	.+44     	; 0xb184 <vfprintf+0xb8>
    b158:	8b 32       	cpi	r24, 0x2B	; 43
    b15a:	69 f0       	breq	.+26     	; 0xb176 <vfprintf+0xaa>
    b15c:	8c 32       	cpi	r24, 0x2C	; 44
    b15e:	28 f4       	brcc	.+10     	; 0xb16a <vfprintf+0x9e>
    b160:	80 32       	cpi	r24, 0x20	; 32
    b162:	51 f0       	breq	.+20     	; 0xb178 <vfprintf+0xac>
    b164:	83 32       	cpi	r24, 0x23	; 35
    b166:	71 f4       	brne	.+28     	; 0xb184 <vfprintf+0xb8>
    b168:	0b c0       	rjmp	.+22     	; 0xb180 <vfprintf+0xb4>
    b16a:	8d 32       	cpi	r24, 0x2D	; 45
    b16c:	39 f0       	breq	.+14     	; 0xb17c <vfprintf+0xb0>
    b16e:	80 33       	cpi	r24, 0x30	; 48
    b170:	49 f4       	brne	.+18     	; 0xb184 <vfprintf+0xb8>
    b172:	11 60       	ori	r17, 0x01	; 1
    b174:	2c c0       	rjmp	.+88     	; 0xb1ce <vfprintf+0x102>
    b176:	12 60       	ori	r17, 0x02	; 2
    b178:	14 60       	ori	r17, 0x04	; 4
    b17a:	29 c0       	rjmp	.+82     	; 0xb1ce <vfprintf+0x102>
    b17c:	18 60       	ori	r17, 0x08	; 8
    b17e:	27 c0       	rjmp	.+78     	; 0xb1ce <vfprintf+0x102>
    b180:	10 61       	ori	r17, 0x10	; 16
    b182:	25 c0       	rjmp	.+74     	; 0xb1ce <vfprintf+0x102>
    b184:	17 fd       	sbrc	r17, 7
    b186:	2e c0       	rjmp	.+92     	; 0xb1e4 <vfprintf+0x118>
    b188:	28 2f       	mov	r18, r24
    b18a:	20 53       	subi	r18, 0x30	; 48
    b18c:	2a 30       	cpi	r18, 0x0A	; 10
    b18e:	98 f4       	brcc	.+38     	; 0xb1b6 <vfprintf+0xea>
    b190:	16 ff       	sbrs	r17, 6
    b192:	08 c0       	rjmp	.+16     	; 0xb1a4 <vfprintf+0xd8>
    b194:	8f 2d       	mov	r24, r15
    b196:	88 0f       	add	r24, r24
    b198:	f8 2e       	mov	r15, r24
    b19a:	ff 0c       	add	r15, r15
    b19c:	ff 0c       	add	r15, r15
    b19e:	f8 0e       	add	r15, r24
    b1a0:	f2 0e       	add	r15, r18
    b1a2:	15 c0       	rjmp	.+42     	; 0xb1ce <vfprintf+0x102>
    b1a4:	8e 2d       	mov	r24, r14
    b1a6:	88 0f       	add	r24, r24
    b1a8:	e8 2e       	mov	r14, r24
    b1aa:	ee 0c       	add	r14, r14
    b1ac:	ee 0c       	add	r14, r14
    b1ae:	e8 0e       	add	r14, r24
    b1b0:	e2 0e       	add	r14, r18
    b1b2:	10 62       	ori	r17, 0x20	; 32
    b1b4:	0c c0       	rjmp	.+24     	; 0xb1ce <vfprintf+0x102>
    b1b6:	8e 32       	cpi	r24, 0x2E	; 46
    b1b8:	21 f4       	brne	.+8      	; 0xb1c2 <vfprintf+0xf6>
    b1ba:	16 fd       	sbrc	r17, 6
    b1bc:	6c c1       	rjmp	.+728    	; 0xb496 <vfprintf+0x3ca>
    b1be:	10 64       	ori	r17, 0x40	; 64
    b1c0:	06 c0       	rjmp	.+12     	; 0xb1ce <vfprintf+0x102>
    b1c2:	8c 36       	cpi	r24, 0x6C	; 108
    b1c4:	11 f4       	brne	.+4      	; 0xb1ca <vfprintf+0xfe>
    b1c6:	10 68       	ori	r17, 0x80	; 128
    b1c8:	02 c0       	rjmp	.+4      	; 0xb1ce <vfprintf+0x102>
    b1ca:	88 36       	cpi	r24, 0x68	; 104
    b1cc:	59 f4       	brne	.+22     	; 0xb1e4 <vfprintf+0x118>
    b1ce:	ec 85       	ldd	r30, Y+12	; 0x0c
    b1d0:	fd 85       	ldd	r31, Y+13	; 0x0d
    b1d2:	93 fd       	sbrc	r25, 3
    b1d4:	85 91       	lpm	r24, Z+
    b1d6:	93 ff       	sbrs	r25, 3
    b1d8:	81 91       	ld	r24, Z+
    b1da:	ec 87       	std	Y+12, r30	; 0x0c
    b1dc:	fd 87       	std	Y+13, r31	; 0x0d
    b1de:	88 23       	and	r24, r24
    b1e0:	09 f0       	breq	.+2      	; 0xb1e4 <vfprintf+0x118>
    b1e2:	b8 cf       	rjmp	.-144    	; 0xb154 <vfprintf+0x88>
    b1e4:	98 2f       	mov	r25, r24
    b1e6:	95 54       	subi	r25, 0x45	; 69
    b1e8:	93 30       	cpi	r25, 0x03	; 3
    b1ea:	18 f0       	brcs	.+6      	; 0xb1f2 <vfprintf+0x126>
    b1ec:	90 52       	subi	r25, 0x20	; 32
    b1ee:	93 30       	cpi	r25, 0x03	; 3
    b1f0:	38 f4       	brcc	.+14     	; 0xb200 <vfprintf+0x134>
    b1f2:	24 e0       	ldi	r18, 0x04	; 4
    b1f4:	30 e0       	ldi	r19, 0x00	; 0
    b1f6:	a2 0e       	add	r10, r18
    b1f8:	b3 1e       	adc	r11, r19
    b1fa:	3f e3       	ldi	r19, 0x3F	; 63
    b1fc:	39 83       	std	Y+1, r19	; 0x01
    b1fe:	0f c0       	rjmp	.+30     	; 0xb21e <vfprintf+0x152>
    b200:	83 36       	cpi	r24, 0x63	; 99
    b202:	31 f0       	breq	.+12     	; 0xb210 <vfprintf+0x144>
    b204:	83 37       	cpi	r24, 0x73	; 115
    b206:	81 f0       	breq	.+32     	; 0xb228 <vfprintf+0x15c>
    b208:	83 35       	cpi	r24, 0x53	; 83
    b20a:	09 f0       	breq	.+2      	; 0xb20e <vfprintf+0x142>
    b20c:	5a c0       	rjmp	.+180    	; 0xb2c2 <vfprintf+0x1f6>
    b20e:	22 c0       	rjmp	.+68     	; 0xb254 <vfprintf+0x188>
    b210:	f5 01       	movw	r30, r10
    b212:	80 81       	ld	r24, Z
    b214:	89 83       	std	Y+1, r24	; 0x01
    b216:	22 e0       	ldi	r18, 0x02	; 2
    b218:	30 e0       	ldi	r19, 0x00	; 0
    b21a:	a2 0e       	add	r10, r18
    b21c:	b3 1e       	adc	r11, r19
    b21e:	21 e0       	ldi	r18, 0x01	; 1
    b220:	c2 2e       	mov	r12, r18
    b222:	d1 2c       	mov	r13, r1
    b224:	42 01       	movw	r8, r4
    b226:	14 c0       	rjmp	.+40     	; 0xb250 <vfprintf+0x184>
    b228:	92 e0       	ldi	r25, 0x02	; 2
    b22a:	29 2e       	mov	r2, r25
    b22c:	31 2c       	mov	r3, r1
    b22e:	2a 0c       	add	r2, r10
    b230:	3b 1c       	adc	r3, r11
    b232:	f5 01       	movw	r30, r10
    b234:	80 80       	ld	r8, Z
    b236:	91 80       	ldd	r9, Z+1	; 0x01
    b238:	16 ff       	sbrs	r17, 6
    b23a:	03 c0       	rjmp	.+6      	; 0xb242 <vfprintf+0x176>
    b23c:	6f 2d       	mov	r22, r15
    b23e:	70 e0       	ldi	r23, 0x00	; 0
    b240:	02 c0       	rjmp	.+4      	; 0xb246 <vfprintf+0x17a>
    b242:	6f ef       	ldi	r22, 0xFF	; 255
    b244:	7f ef       	ldi	r23, 0xFF	; 255
    b246:	c4 01       	movw	r24, r8
    b248:	0e 94 ed 5a 	call	0xb5da	; 0xb5da <strnlen>
    b24c:	6c 01       	movw	r12, r24
    b24e:	51 01       	movw	r10, r2
    b250:	1f 77       	andi	r17, 0x7F	; 127
    b252:	15 c0       	rjmp	.+42     	; 0xb27e <vfprintf+0x1b2>
    b254:	82 e0       	ldi	r24, 0x02	; 2
    b256:	28 2e       	mov	r2, r24
    b258:	31 2c       	mov	r3, r1
    b25a:	2a 0c       	add	r2, r10
    b25c:	3b 1c       	adc	r3, r11
    b25e:	f5 01       	movw	r30, r10
    b260:	80 80       	ld	r8, Z
    b262:	91 80       	ldd	r9, Z+1	; 0x01
    b264:	16 ff       	sbrs	r17, 6
    b266:	03 c0       	rjmp	.+6      	; 0xb26e <vfprintf+0x1a2>
    b268:	6f 2d       	mov	r22, r15
    b26a:	70 e0       	ldi	r23, 0x00	; 0
    b26c:	02 c0       	rjmp	.+4      	; 0xb272 <vfprintf+0x1a6>
    b26e:	6f ef       	ldi	r22, 0xFF	; 255
    b270:	7f ef       	ldi	r23, 0xFF	; 255
    b272:	c4 01       	movw	r24, r8
    b274:	0e 94 e2 5a 	call	0xb5c4	; 0xb5c4 <strnlen_P>
    b278:	6c 01       	movw	r12, r24
    b27a:	10 68       	ori	r17, 0x80	; 128
    b27c:	51 01       	movw	r10, r2
    b27e:	13 fd       	sbrc	r17, 3
    b280:	1c c0       	rjmp	.+56     	; 0xb2ba <vfprintf+0x1ee>
    b282:	06 c0       	rjmp	.+12     	; 0xb290 <vfprintf+0x1c4>
    b284:	80 e2       	ldi	r24, 0x20	; 32
    b286:	90 e0       	ldi	r25, 0x00	; 0
    b288:	b3 01       	movw	r22, r6
    b28a:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b28e:	ea 94       	dec	r14
    b290:	8e 2d       	mov	r24, r14
    b292:	90 e0       	ldi	r25, 0x00	; 0
    b294:	c8 16       	cp	r12, r24
    b296:	d9 06       	cpc	r13, r25
    b298:	a8 f3       	brcs	.-22     	; 0xb284 <vfprintf+0x1b8>
    b29a:	0f c0       	rjmp	.+30     	; 0xb2ba <vfprintf+0x1ee>
    b29c:	f4 01       	movw	r30, r8
    b29e:	17 fd       	sbrc	r17, 7
    b2a0:	85 91       	lpm	r24, Z+
    b2a2:	17 ff       	sbrs	r17, 7
    b2a4:	81 91       	ld	r24, Z+
    b2a6:	4f 01       	movw	r8, r30
    b2a8:	90 e0       	ldi	r25, 0x00	; 0
    b2aa:	b3 01       	movw	r22, r6
    b2ac:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b2b0:	e1 10       	cpse	r14, r1
    b2b2:	ea 94       	dec	r14
    b2b4:	08 94       	sec
    b2b6:	c1 08       	sbc	r12, r1
    b2b8:	d1 08       	sbc	r13, r1
    b2ba:	c1 14       	cp	r12, r1
    b2bc:	d1 04       	cpc	r13, r1
    b2be:	71 f7       	brne	.-36     	; 0xb29c <vfprintf+0x1d0>
    b2c0:	e7 c0       	rjmp	.+462    	; 0xb490 <vfprintf+0x3c4>
    b2c2:	84 36       	cpi	r24, 0x64	; 100
    b2c4:	11 f0       	breq	.+4      	; 0xb2ca <vfprintf+0x1fe>
    b2c6:	89 36       	cpi	r24, 0x69	; 105
    b2c8:	51 f5       	brne	.+84     	; 0xb31e <vfprintf+0x252>
    b2ca:	f5 01       	movw	r30, r10
    b2cc:	17 ff       	sbrs	r17, 7
    b2ce:	07 c0       	rjmp	.+14     	; 0xb2de <vfprintf+0x212>
    b2d0:	80 81       	ld	r24, Z
    b2d2:	91 81       	ldd	r25, Z+1	; 0x01
    b2d4:	a2 81       	ldd	r26, Z+2	; 0x02
    b2d6:	b3 81       	ldd	r27, Z+3	; 0x03
    b2d8:	24 e0       	ldi	r18, 0x04	; 4
    b2da:	30 e0       	ldi	r19, 0x00	; 0
    b2dc:	08 c0       	rjmp	.+16     	; 0xb2ee <vfprintf+0x222>
    b2de:	80 81       	ld	r24, Z
    b2e0:	91 81       	ldd	r25, Z+1	; 0x01
    b2e2:	aa 27       	eor	r26, r26
    b2e4:	97 fd       	sbrc	r25, 7
    b2e6:	a0 95       	com	r26
    b2e8:	ba 2f       	mov	r27, r26
    b2ea:	22 e0       	ldi	r18, 0x02	; 2
    b2ec:	30 e0       	ldi	r19, 0x00	; 0
    b2ee:	a2 0e       	add	r10, r18
    b2f0:	b3 1e       	adc	r11, r19
    b2f2:	01 2f       	mov	r16, r17
    b2f4:	0f 76       	andi	r16, 0x6F	; 111
    b2f6:	b7 ff       	sbrs	r27, 7
    b2f8:	08 c0       	rjmp	.+16     	; 0xb30a <vfprintf+0x23e>
    b2fa:	b0 95       	com	r27
    b2fc:	a0 95       	com	r26
    b2fe:	90 95       	com	r25
    b300:	81 95       	neg	r24
    b302:	9f 4f       	sbci	r25, 0xFF	; 255
    b304:	af 4f       	sbci	r26, 0xFF	; 255
    b306:	bf 4f       	sbci	r27, 0xFF	; 255
    b308:	00 68       	ori	r16, 0x80	; 128
    b30a:	bc 01       	movw	r22, r24
    b30c:	cd 01       	movw	r24, r26
    b30e:	a2 01       	movw	r20, r4
    b310:	2a e0       	ldi	r18, 0x0A	; 10
    b312:	30 e0       	ldi	r19, 0x00	; 0
    b314:	0e 94 f8 5a 	call	0xb5f0	; 0xb5f0 <__ultoa_invert>
    b318:	d8 2e       	mov	r13, r24
    b31a:	d4 18       	sub	r13, r4
    b31c:	3f c0       	rjmp	.+126    	; 0xb39c <vfprintf+0x2d0>
    b31e:	85 37       	cpi	r24, 0x75	; 117
    b320:	21 f4       	brne	.+8      	; 0xb32a <vfprintf+0x25e>
    b322:	1f 7e       	andi	r17, 0xEF	; 239
    b324:	2a e0       	ldi	r18, 0x0A	; 10
    b326:	30 e0       	ldi	r19, 0x00	; 0
    b328:	20 c0       	rjmp	.+64     	; 0xb36a <vfprintf+0x29e>
    b32a:	19 7f       	andi	r17, 0xF9	; 249
    b32c:	8f 36       	cpi	r24, 0x6F	; 111
    b32e:	a9 f0       	breq	.+42     	; 0xb35a <vfprintf+0x28e>
    b330:	80 37       	cpi	r24, 0x70	; 112
    b332:	20 f4       	brcc	.+8      	; 0xb33c <vfprintf+0x270>
    b334:	88 35       	cpi	r24, 0x58	; 88
    b336:	09 f0       	breq	.+2      	; 0xb33a <vfprintf+0x26e>
    b338:	ae c0       	rjmp	.+348    	; 0xb496 <vfprintf+0x3ca>
    b33a:	0b c0       	rjmp	.+22     	; 0xb352 <vfprintf+0x286>
    b33c:	80 37       	cpi	r24, 0x70	; 112
    b33e:	21 f0       	breq	.+8      	; 0xb348 <vfprintf+0x27c>
    b340:	88 37       	cpi	r24, 0x78	; 120
    b342:	09 f0       	breq	.+2      	; 0xb346 <vfprintf+0x27a>
    b344:	a8 c0       	rjmp	.+336    	; 0xb496 <vfprintf+0x3ca>
    b346:	01 c0       	rjmp	.+2      	; 0xb34a <vfprintf+0x27e>
    b348:	10 61       	ori	r17, 0x10	; 16
    b34a:	14 ff       	sbrs	r17, 4
    b34c:	09 c0       	rjmp	.+18     	; 0xb360 <vfprintf+0x294>
    b34e:	14 60       	ori	r17, 0x04	; 4
    b350:	07 c0       	rjmp	.+14     	; 0xb360 <vfprintf+0x294>
    b352:	14 ff       	sbrs	r17, 4
    b354:	08 c0       	rjmp	.+16     	; 0xb366 <vfprintf+0x29a>
    b356:	16 60       	ori	r17, 0x06	; 6
    b358:	06 c0       	rjmp	.+12     	; 0xb366 <vfprintf+0x29a>
    b35a:	28 e0       	ldi	r18, 0x08	; 8
    b35c:	30 e0       	ldi	r19, 0x00	; 0
    b35e:	05 c0       	rjmp	.+10     	; 0xb36a <vfprintf+0x29e>
    b360:	20 e1       	ldi	r18, 0x10	; 16
    b362:	30 e0       	ldi	r19, 0x00	; 0
    b364:	02 c0       	rjmp	.+4      	; 0xb36a <vfprintf+0x29e>
    b366:	20 e1       	ldi	r18, 0x10	; 16
    b368:	32 e0       	ldi	r19, 0x02	; 2
    b36a:	f5 01       	movw	r30, r10
    b36c:	17 ff       	sbrs	r17, 7
    b36e:	07 c0       	rjmp	.+14     	; 0xb37e <vfprintf+0x2b2>
    b370:	60 81       	ld	r22, Z
    b372:	71 81       	ldd	r23, Z+1	; 0x01
    b374:	82 81       	ldd	r24, Z+2	; 0x02
    b376:	93 81       	ldd	r25, Z+3	; 0x03
    b378:	44 e0       	ldi	r20, 0x04	; 4
    b37a:	50 e0       	ldi	r21, 0x00	; 0
    b37c:	06 c0       	rjmp	.+12     	; 0xb38a <vfprintf+0x2be>
    b37e:	60 81       	ld	r22, Z
    b380:	71 81       	ldd	r23, Z+1	; 0x01
    b382:	80 e0       	ldi	r24, 0x00	; 0
    b384:	90 e0       	ldi	r25, 0x00	; 0
    b386:	42 e0       	ldi	r20, 0x02	; 2
    b388:	50 e0       	ldi	r21, 0x00	; 0
    b38a:	a4 0e       	add	r10, r20
    b38c:	b5 1e       	adc	r11, r21
    b38e:	a2 01       	movw	r20, r4
    b390:	0e 94 f8 5a 	call	0xb5f0	; 0xb5f0 <__ultoa_invert>
    b394:	d8 2e       	mov	r13, r24
    b396:	d4 18       	sub	r13, r4
    b398:	01 2f       	mov	r16, r17
    b39a:	0f 77       	andi	r16, 0x7F	; 127
    b39c:	06 ff       	sbrs	r16, 6
    b39e:	09 c0       	rjmp	.+18     	; 0xb3b2 <vfprintf+0x2e6>
    b3a0:	0e 7f       	andi	r16, 0xFE	; 254
    b3a2:	df 14       	cp	r13, r15
    b3a4:	30 f4       	brcc	.+12     	; 0xb3b2 <vfprintf+0x2e6>
    b3a6:	04 ff       	sbrs	r16, 4
    b3a8:	06 c0       	rjmp	.+12     	; 0xb3b6 <vfprintf+0x2ea>
    b3aa:	02 fd       	sbrc	r16, 2
    b3ac:	04 c0       	rjmp	.+8      	; 0xb3b6 <vfprintf+0x2ea>
    b3ae:	0f 7e       	andi	r16, 0xEF	; 239
    b3b0:	02 c0       	rjmp	.+4      	; 0xb3b6 <vfprintf+0x2ea>
    b3b2:	1d 2d       	mov	r17, r13
    b3b4:	01 c0       	rjmp	.+2      	; 0xb3b8 <vfprintf+0x2ec>
    b3b6:	1f 2d       	mov	r17, r15
    b3b8:	80 2f       	mov	r24, r16
    b3ba:	90 e0       	ldi	r25, 0x00	; 0
    b3bc:	04 ff       	sbrs	r16, 4
    b3be:	0c c0       	rjmp	.+24     	; 0xb3d8 <vfprintf+0x30c>
    b3c0:	fe 01       	movw	r30, r28
    b3c2:	ed 0d       	add	r30, r13
    b3c4:	f1 1d       	adc	r31, r1
    b3c6:	20 81       	ld	r18, Z
    b3c8:	20 33       	cpi	r18, 0x30	; 48
    b3ca:	11 f4       	brne	.+4      	; 0xb3d0 <vfprintf+0x304>
    b3cc:	09 7e       	andi	r16, 0xE9	; 233
    b3ce:	09 c0       	rjmp	.+18     	; 0xb3e2 <vfprintf+0x316>
    b3d0:	02 ff       	sbrs	r16, 2
    b3d2:	06 c0       	rjmp	.+12     	; 0xb3e0 <vfprintf+0x314>
    b3d4:	1e 5f       	subi	r17, 0xFE	; 254
    b3d6:	05 c0       	rjmp	.+10     	; 0xb3e2 <vfprintf+0x316>
    b3d8:	86 78       	andi	r24, 0x86	; 134
    b3da:	90 70       	andi	r25, 0x00	; 0
    b3dc:	00 97       	sbiw	r24, 0x00	; 0
    b3de:	09 f0       	breq	.+2      	; 0xb3e2 <vfprintf+0x316>
    b3e0:	1f 5f       	subi	r17, 0xFF	; 255
    b3e2:	80 2e       	mov	r8, r16
    b3e4:	99 24       	eor	r9, r9
    b3e6:	03 fd       	sbrc	r16, 3
    b3e8:	12 c0       	rjmp	.+36     	; 0xb40e <vfprintf+0x342>
    b3ea:	00 ff       	sbrs	r16, 0
    b3ec:	0d c0       	rjmp	.+26     	; 0xb408 <vfprintf+0x33c>
    b3ee:	fd 2c       	mov	r15, r13
    b3f0:	1e 15       	cp	r17, r14
    b3f2:	50 f4       	brcc	.+20     	; 0xb408 <vfprintf+0x33c>
    b3f4:	fe 0c       	add	r15, r14
    b3f6:	f1 1a       	sub	r15, r17
    b3f8:	1e 2d       	mov	r17, r14
    b3fa:	06 c0       	rjmp	.+12     	; 0xb408 <vfprintf+0x33c>
    b3fc:	80 e2       	ldi	r24, 0x20	; 32
    b3fe:	90 e0       	ldi	r25, 0x00	; 0
    b400:	b3 01       	movw	r22, r6
    b402:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b406:	1f 5f       	subi	r17, 0xFF	; 255
    b408:	1e 15       	cp	r17, r14
    b40a:	c0 f3       	brcs	.-16     	; 0xb3fc <vfprintf+0x330>
    b40c:	04 c0       	rjmp	.+8      	; 0xb416 <vfprintf+0x34a>
    b40e:	1e 15       	cp	r17, r14
    b410:	10 f4       	brcc	.+4      	; 0xb416 <vfprintf+0x34a>
    b412:	e1 1a       	sub	r14, r17
    b414:	01 c0       	rjmp	.+2      	; 0xb418 <vfprintf+0x34c>
    b416:	ee 24       	eor	r14, r14
    b418:	84 fe       	sbrs	r8, 4
    b41a:	0f c0       	rjmp	.+30     	; 0xb43a <vfprintf+0x36e>
    b41c:	80 e3       	ldi	r24, 0x30	; 48
    b41e:	90 e0       	ldi	r25, 0x00	; 0
    b420:	b3 01       	movw	r22, r6
    b422:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b426:	82 fe       	sbrs	r8, 2
    b428:	1f c0       	rjmp	.+62     	; 0xb468 <vfprintf+0x39c>
    b42a:	81 fe       	sbrs	r8, 1
    b42c:	03 c0       	rjmp	.+6      	; 0xb434 <vfprintf+0x368>
    b42e:	88 e5       	ldi	r24, 0x58	; 88
    b430:	90 e0       	ldi	r25, 0x00	; 0
    b432:	10 c0       	rjmp	.+32     	; 0xb454 <vfprintf+0x388>
    b434:	88 e7       	ldi	r24, 0x78	; 120
    b436:	90 e0       	ldi	r25, 0x00	; 0
    b438:	0d c0       	rjmp	.+26     	; 0xb454 <vfprintf+0x388>
    b43a:	c4 01       	movw	r24, r8
    b43c:	86 78       	andi	r24, 0x86	; 134
    b43e:	90 70       	andi	r25, 0x00	; 0
    b440:	00 97       	sbiw	r24, 0x00	; 0
    b442:	91 f0       	breq	.+36     	; 0xb468 <vfprintf+0x39c>
    b444:	81 fc       	sbrc	r8, 1
    b446:	02 c0       	rjmp	.+4      	; 0xb44c <vfprintf+0x380>
    b448:	80 e2       	ldi	r24, 0x20	; 32
    b44a:	01 c0       	rjmp	.+2      	; 0xb44e <vfprintf+0x382>
    b44c:	8b e2       	ldi	r24, 0x2B	; 43
    b44e:	07 fd       	sbrc	r16, 7
    b450:	8d e2       	ldi	r24, 0x2D	; 45
    b452:	90 e0       	ldi	r25, 0x00	; 0
    b454:	b3 01       	movw	r22, r6
    b456:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b45a:	06 c0       	rjmp	.+12     	; 0xb468 <vfprintf+0x39c>
    b45c:	80 e3       	ldi	r24, 0x30	; 48
    b45e:	90 e0       	ldi	r25, 0x00	; 0
    b460:	b3 01       	movw	r22, r6
    b462:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b466:	fa 94       	dec	r15
    b468:	df 14       	cp	r13, r15
    b46a:	c0 f3       	brcs	.-16     	; 0xb45c <vfprintf+0x390>
    b46c:	da 94       	dec	r13
    b46e:	f2 01       	movw	r30, r4
    b470:	ed 0d       	add	r30, r13
    b472:	f1 1d       	adc	r31, r1
    b474:	80 81       	ld	r24, Z
    b476:	90 e0       	ldi	r25, 0x00	; 0
    b478:	b3 01       	movw	r22, r6
    b47a:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b47e:	dd 20       	and	r13, r13
    b480:	a9 f7       	brne	.-22     	; 0xb46c <vfprintf+0x3a0>
    b482:	06 c0       	rjmp	.+12     	; 0xb490 <vfprintf+0x3c4>
    b484:	80 e2       	ldi	r24, 0x20	; 32
    b486:	90 e0       	ldi	r25, 0x00	; 0
    b488:	b3 01       	movw	r22, r6
    b48a:	0e 94 eb 57 	call	0xafd6	; 0xafd6 <fputc>
    b48e:	ea 94       	dec	r14
    b490:	ee 20       	and	r14, r14
    b492:	c1 f7       	brne	.-16     	; 0xb484 <vfprintf+0x3b8>
    b494:	40 ce       	rjmp	.-896    	; 0xb116 <vfprintf+0x4a>
    b496:	f3 01       	movw	r30, r6
    b498:	86 81       	ldd	r24, Z+6	; 0x06
    b49a:	97 81       	ldd	r25, Z+7	; 0x07
    b49c:	02 c0       	rjmp	.+4      	; 0xb4a2 <vfprintf+0x3d6>
    b49e:	8f ef       	ldi	r24, 0xFF	; 255
    b4a0:	9f ef       	ldi	r25, 0xFF	; 255
    b4a2:	2d 96       	adiw	r28, 0x0d	; 13
    b4a4:	cd bf       	out	0x3d, r28	; 61
    b4a6:	de bf       	out	0x3e, r29	; 62
    b4a8:	df 91       	pop	r29
    b4aa:	cf 91       	pop	r28
    b4ac:	1f 91       	pop	r17
    b4ae:	0f 91       	pop	r16
    b4b0:	ff 90       	pop	r15
    b4b2:	ef 90       	pop	r14
    b4b4:	df 90       	pop	r13
    b4b6:	cf 90       	pop	r12
    b4b8:	bf 90       	pop	r11
    b4ba:	af 90       	pop	r10
    b4bc:	9f 90       	pop	r9
    b4be:	8f 90       	pop	r8
    b4c0:	7f 90       	pop	r7
    b4c2:	6f 90       	pop	r6
    b4c4:	5f 90       	pop	r5
    b4c6:	4f 90       	pop	r4
    b4c8:	3f 90       	pop	r3
    b4ca:	2f 90       	pop	r2
    b4cc:	08 95       	ret

0000b4ce <__eerd_block_x128a1>:
    b4ce:	e0 ec       	ldi	r30, 0xC0	; 192
    b4d0:	f1 e0       	ldi	r31, 0x01	; 1
    b4d2:	a7 85       	ldd	r26, Z+15	; 0x0f
    b4d4:	a7 fd       	sbrc	r26, 7
    b4d6:	fd cf       	rjmp	.-6      	; 0xb4d2 <__eerd_block_x128a1+0x4>
    b4d8:	a4 85       	ldd	r26, Z+12	; 0x0c
    b4da:	a8 60       	ori	r26, 0x08	; 8
    b4dc:	a4 87       	std	Z+12, r26	; 0x0c
    b4de:	60 50       	subi	r22, 0x00	; 0
    b4e0:	70 4f       	sbci	r23, 0xF0	; 240
    b4e2:	0c 94 15 57 	jmp	0xae2a	; 0xae2a <memcpy>

0000b4e6 <__eerd_dword_x128a1>:
    b4e6:	0e 94 d3 5a 	call	0xb5a6	; 0xb5a6 <eeprom_mapen>
    b4ea:	60 81       	ld	r22, Z
    b4ec:	71 81       	ldd	r23, Z+1	; 0x01
    b4ee:	82 81       	ldd	r24, Z+2	; 0x02
    b4f0:	93 81       	ldd	r25, Z+3	; 0x03
    b4f2:	08 95       	ret

0000b4f4 <__eerd_word_x128a1>:
    b4f4:	0e 94 d3 5a 	call	0xb5a6	; 0xb5a6 <eeprom_mapen>
    b4f8:	80 81       	ld	r24, Z
    b4fa:	91 81       	ldd	r25, Z+1	; 0x01
    b4fc:	08 95       	ret

0000b4fe <__eeupd_block_x128a1>:
    b4fe:	dc 01       	movw	r26, r24
    b500:	a4 0f       	add	r26, r20
    b502:	b5 1f       	adc	r27, r21
    b504:	41 50       	subi	r20, 0x01	; 1
    b506:	50 40       	sbci	r21, 0x00	; 0
    b508:	48 f0       	brcs	.+18     	; 0xb51c <__eeupd_block_x128a1+0x1e>
    b50a:	cb 01       	movw	r24, r22
    b50c:	84 0f       	add	r24, r20
    b50e:	95 1f       	adc	r25, r21
    b510:	2e 91       	ld	r18, -X
    b512:	0e 94 90 5a 	call	0xb520	; 0xb520 <__eeupd_r18_x128a1>
    b516:	41 50       	subi	r20, 0x01	; 1
    b518:	50 40       	sbci	r21, 0x00	; 0
    b51a:	d0 f7       	brcc	.-12     	; 0xb510 <__eeupd_block_x128a1+0x12>
    b51c:	08 95       	ret

0000b51e <__eeupd_byte_x128a1>:
    b51e:	26 2f       	mov	r18, r22

0000b520 <__eeupd_r18_x128a1>:
    b520:	0e 94 d3 5a 	call	0xb5a6	; 0xb5a6 <eeprom_mapen>
    b524:	00 80       	ld	r0, Z
    b526:	02 16       	cp	r0, r18
    b528:	19 f0       	breq	.+6      	; 0xb530 <__eeupd_r18_x128a1+0x10>
    b52a:	0e 94 ad 5a 	call	0xb55a	; 0xb55a <__eewr_r18_x128a1>
    b52e:	01 97       	sbiw	r24, 0x01	; 1
    b530:	01 97       	sbiw	r24, 0x01	; 1
    b532:	08 95       	ret

0000b534 <__eeupd_dword_x128a1>:
    b534:	03 96       	adiw	r24, 0x03	; 3
    b536:	27 2f       	mov	r18, r23
    b538:	0e 94 90 5a 	call	0xb520	; 0xb520 <__eeupd_r18_x128a1>
    b53c:	0e 94 8f 5a 	call	0xb51e	; 0xb51e <__eeupd_byte_x128a1>
    b540:	25 2f       	mov	r18, r21
    b542:	0e 94 90 5a 	call	0xb520	; 0xb520 <__eeupd_r18_x128a1>
    b546:	24 2f       	mov	r18, r20
    b548:	0c 94 90 5a 	jmp	0xb520	; 0xb520 <__eeupd_r18_x128a1>

0000b54c <__eeupd_word_x128a1>:
    b54c:	01 96       	adiw	r24, 0x01	; 1
    b54e:	27 2f       	mov	r18, r23
    b550:	0e 94 90 5a 	call	0xb520	; 0xb520 <__eeupd_r18_x128a1>
    b554:	0c 94 8f 5a 	jmp	0xb51e	; 0xb51e <__eeupd_byte_x128a1>

0000b558 <__eewr_byte_x128a1>:
    b558:	26 2f       	mov	r18, r22

0000b55a <__eewr_r18_x128a1>:
    b55a:	e0 ec       	ldi	r30, 0xC0	; 192
    b55c:	f1 e0       	ldi	r31, 0x01	; 1
    b55e:	37 85       	ldd	r19, Z+15	; 0x0f
    b560:	37 fd       	sbrc	r19, 7
    b562:	fd cf       	rjmp	.-6      	; 0xb55e <__eewr_r18_x128a1+0x4>
    b564:	34 85       	ldd	r19, Z+12	; 0x0c
    b566:	37 7f       	andi	r19, 0xF7	; 247
    b568:	34 87       	std	Z+12, r19	; 0x0c
    b56a:	37 85       	ldd	r19, Z+15	; 0x0f
    b56c:	31 ff       	sbrs	r19, 1
    b56e:	09 c0       	rjmp	.+18     	; 0xb582 <__eewr_r18_x128a1+0x28>
    b570:	36 e3       	ldi	r19, 0x36	; 54
    b572:	32 87       	std	Z+10, r19	; 0x0a
    b574:	38 ed       	ldi	r19, 0xD8	; 216
    b576:	34 bf       	out	0x34, r19	; 52
    b578:	31 e0       	ldi	r19, 0x01	; 1
    b57a:	33 87       	std	Z+11, r19	; 0x0b
    b57c:	37 85       	ldd	r19, Z+15	; 0x0f
    b57e:	37 fd       	sbrc	r19, 7
    b580:	fd cf       	rjmp	.-6      	; 0xb57c <__eewr_r18_x128a1+0x22>
    b582:	33 e3       	ldi	r19, 0x33	; 51
    b584:	32 87       	std	Z+10, r19	; 0x0a
    b586:	80 83       	st	Z, r24
    b588:	91 83       	std	Z+1, r25	; 0x01
    b58a:	12 82       	std	Z+2, r1	; 0x02
    b58c:	24 83       	std	Z+4, r18	; 0x04
    b58e:	25 e3       	ldi	r18, 0x35	; 53
    b590:	22 87       	std	Z+10, r18	; 0x0a
    b592:	28 ed       	ldi	r18, 0xD8	; 216
    b594:	31 e0       	ldi	r19, 0x01	; 1
    b596:	24 bf       	out	0x34, r18	; 52
    b598:	33 87       	std	Z+11, r19	; 0x0b
    b59a:	01 96       	adiw	r24, 0x01	; 1
    b59c:	08 95       	ret

0000b59e <__eerd_byte_x128a1u>:
    b59e:	03 d0       	rcall	.+6      	; 0xb5a6 <eeprom_mapen>
    b5a0:	80 81       	ld	r24, Z
    b5a2:	99 27       	eor	r25, r25
    b5a4:	08 95       	ret

0000b5a6 <eeprom_mapen>:
    b5a6:	e0 ec       	ldi	r30, 0xC0	; 192
    b5a8:	f1 e0       	ldi	r31, 0x01	; 1
    b5aa:	37 85       	ldd	r19, Z+15	; 0x0f
    b5ac:	37 fd       	sbrc	r19, 7
    b5ae:	fd cf       	rjmp	.-6      	; 0xb5aa <eeprom_mapen+0x4>
    b5b0:	34 85       	ldd	r19, Z+12	; 0x0c
    b5b2:	38 60       	ori	r19, 0x08	; 8
    b5b4:	34 87       	std	Z+12, r19	; 0x0c
    b5b6:	fc 01       	movw	r30, r24
    b5b8:	e0 50       	subi	r30, 0x00	; 0
    b5ba:	f0 4f       	sbci	r31, 0xF0	; 240
    b5bc:	08 95       	ret

0000b5be <__ctype_isfalse>:
    b5be:	99 27       	eor	r25, r25
    b5c0:	88 27       	eor	r24, r24

0000b5c2 <__ctype_istrue>:
    b5c2:	08 95       	ret

0000b5c4 <strnlen_P>:
    b5c4:	fc 01       	movw	r30, r24
    b5c6:	05 90       	lpm	r0, Z+
    b5c8:	61 50       	subi	r22, 0x01	; 1
    b5ca:	70 40       	sbci	r23, 0x00	; 0
    b5cc:	01 10       	cpse	r0, r1
    b5ce:	d8 f7       	brcc	.-10     	; 0xb5c6 <strnlen_P+0x2>
    b5d0:	80 95       	com	r24
    b5d2:	90 95       	com	r25
    b5d4:	8e 0f       	add	r24, r30
    b5d6:	9f 1f       	adc	r25, r31
    b5d8:	08 95       	ret

0000b5da <strnlen>:
    b5da:	fc 01       	movw	r30, r24
    b5dc:	61 50       	subi	r22, 0x01	; 1
    b5de:	70 40       	sbci	r23, 0x00	; 0
    b5e0:	01 90       	ld	r0, Z+
    b5e2:	01 10       	cpse	r0, r1
    b5e4:	d8 f7       	brcc	.-10     	; 0xb5dc <strnlen+0x2>
    b5e6:	80 95       	com	r24
    b5e8:	90 95       	com	r25
    b5ea:	8e 0f       	add	r24, r30
    b5ec:	9f 1f       	adc	r25, r31
    b5ee:	08 95       	ret

0000b5f0 <__ultoa_invert>:
    b5f0:	fa 01       	movw	r30, r20
    b5f2:	aa 27       	eor	r26, r26
    b5f4:	28 30       	cpi	r18, 0x08	; 8
    b5f6:	51 f1       	breq	.+84     	; 0xb64c <__ultoa_invert+0x5c>
    b5f8:	20 31       	cpi	r18, 0x10	; 16
    b5fa:	81 f1       	breq	.+96     	; 0xb65c <__ultoa_invert+0x6c>
    b5fc:	e8 94       	clt
    b5fe:	6f 93       	push	r22
    b600:	6e 7f       	andi	r22, 0xFE	; 254
    b602:	6e 5f       	subi	r22, 0xFE	; 254
    b604:	7f 4f       	sbci	r23, 0xFF	; 255
    b606:	8f 4f       	sbci	r24, 0xFF	; 255
    b608:	9f 4f       	sbci	r25, 0xFF	; 255
    b60a:	af 4f       	sbci	r26, 0xFF	; 255
    b60c:	b1 e0       	ldi	r27, 0x01	; 1
    b60e:	3e d0       	rcall	.+124    	; 0xb68c <__ultoa_invert+0x9c>
    b610:	b4 e0       	ldi	r27, 0x04	; 4
    b612:	3c d0       	rcall	.+120    	; 0xb68c <__ultoa_invert+0x9c>
    b614:	67 0f       	add	r22, r23
    b616:	78 1f       	adc	r23, r24
    b618:	89 1f       	adc	r24, r25
    b61a:	9a 1f       	adc	r25, r26
    b61c:	a1 1d       	adc	r26, r1
    b61e:	68 0f       	add	r22, r24
    b620:	79 1f       	adc	r23, r25
    b622:	8a 1f       	adc	r24, r26
    b624:	91 1d       	adc	r25, r1
    b626:	a1 1d       	adc	r26, r1
    b628:	6a 0f       	add	r22, r26
    b62a:	71 1d       	adc	r23, r1
    b62c:	81 1d       	adc	r24, r1
    b62e:	91 1d       	adc	r25, r1
    b630:	a1 1d       	adc	r26, r1
    b632:	20 d0       	rcall	.+64     	; 0xb674 <__ultoa_invert+0x84>
    b634:	09 f4       	brne	.+2      	; 0xb638 <__ultoa_invert+0x48>
    b636:	68 94       	set
    b638:	3f 91       	pop	r19
    b63a:	2a e0       	ldi	r18, 0x0A	; 10
    b63c:	26 9f       	mul	r18, r22
    b63e:	11 24       	eor	r1, r1
    b640:	30 19       	sub	r19, r0
    b642:	30 5d       	subi	r19, 0xD0	; 208
    b644:	31 93       	st	Z+, r19
    b646:	de f6       	brtc	.-74     	; 0xb5fe <__ultoa_invert+0xe>
    b648:	cf 01       	movw	r24, r30
    b64a:	08 95       	ret
    b64c:	46 2f       	mov	r20, r22
    b64e:	47 70       	andi	r20, 0x07	; 7
    b650:	40 5d       	subi	r20, 0xD0	; 208
    b652:	41 93       	st	Z+, r20
    b654:	b3 e0       	ldi	r27, 0x03	; 3
    b656:	0f d0       	rcall	.+30     	; 0xb676 <__ultoa_invert+0x86>
    b658:	c9 f7       	brne	.-14     	; 0xb64c <__ultoa_invert+0x5c>
    b65a:	f6 cf       	rjmp	.-20     	; 0xb648 <__ultoa_invert+0x58>
    b65c:	46 2f       	mov	r20, r22
    b65e:	4f 70       	andi	r20, 0x0F	; 15
    b660:	40 5d       	subi	r20, 0xD0	; 208
    b662:	4a 33       	cpi	r20, 0x3A	; 58
    b664:	18 f0       	brcs	.+6      	; 0xb66c <__ultoa_invert+0x7c>
    b666:	49 5d       	subi	r20, 0xD9	; 217
    b668:	31 fd       	sbrc	r19, 1
    b66a:	40 52       	subi	r20, 0x20	; 32
    b66c:	41 93       	st	Z+, r20
    b66e:	02 d0       	rcall	.+4      	; 0xb674 <__ultoa_invert+0x84>
    b670:	a9 f7       	brne	.-22     	; 0xb65c <__ultoa_invert+0x6c>
    b672:	ea cf       	rjmp	.-44     	; 0xb648 <__ultoa_invert+0x58>
    b674:	b4 e0       	ldi	r27, 0x04	; 4
    b676:	a6 95       	lsr	r26
    b678:	97 95       	ror	r25
    b67a:	87 95       	ror	r24
    b67c:	77 95       	ror	r23
    b67e:	67 95       	ror	r22
    b680:	ba 95       	dec	r27
    b682:	c9 f7       	brne	.-14     	; 0xb676 <__ultoa_invert+0x86>
    b684:	00 97       	sbiw	r24, 0x00	; 0
    b686:	61 05       	cpc	r22, r1
    b688:	71 05       	cpc	r23, r1
    b68a:	08 95       	ret
    b68c:	9b 01       	movw	r18, r22
    b68e:	ac 01       	movw	r20, r24
    b690:	0a 2e       	mov	r0, r26
    b692:	06 94       	lsr	r0
    b694:	57 95       	ror	r21
    b696:	47 95       	ror	r20
    b698:	37 95       	ror	r19
    b69a:	27 95       	ror	r18
    b69c:	ba 95       	dec	r27
    b69e:	c9 f7       	brne	.-14     	; 0xb692 <__ultoa_invert+0xa2>
    b6a0:	62 0f       	add	r22, r18
    b6a2:	73 1f       	adc	r23, r19
    b6a4:	84 1f       	adc	r24, r20
    b6a6:	95 1f       	adc	r25, r21
    b6a8:	a0 1d       	adc	r26, r0
    b6aa:	08 95       	ret

0000b6ac <__mulsi3>:
    b6ac:	62 9f       	mul	r22, r18
    b6ae:	d0 01       	movw	r26, r0
    b6b0:	73 9f       	mul	r23, r19
    b6b2:	f0 01       	movw	r30, r0
    b6b4:	82 9f       	mul	r24, r18
    b6b6:	e0 0d       	add	r30, r0
    b6b8:	f1 1d       	adc	r31, r1
    b6ba:	64 9f       	mul	r22, r20
    b6bc:	e0 0d       	add	r30, r0
    b6be:	f1 1d       	adc	r31, r1
    b6c0:	92 9f       	mul	r25, r18
    b6c2:	f0 0d       	add	r31, r0
    b6c4:	83 9f       	mul	r24, r19
    b6c6:	f0 0d       	add	r31, r0
    b6c8:	74 9f       	mul	r23, r20
    b6ca:	f0 0d       	add	r31, r0
    b6cc:	65 9f       	mul	r22, r21
    b6ce:	f0 0d       	add	r31, r0
    b6d0:	99 27       	eor	r25, r25
    b6d2:	72 9f       	mul	r23, r18
    b6d4:	b0 0d       	add	r27, r0
    b6d6:	e1 1d       	adc	r30, r1
    b6d8:	f9 1f       	adc	r31, r25
    b6da:	63 9f       	mul	r22, r19
    b6dc:	b0 0d       	add	r27, r0
    b6de:	e1 1d       	adc	r30, r1
    b6e0:	f9 1f       	adc	r31, r25
    b6e2:	bd 01       	movw	r22, r26
    b6e4:	cf 01       	movw	r24, r30
    b6e6:	11 24       	eor	r1, r1
    b6e8:	08 95       	ret

0000b6ea <__udivmodsi4>:
    b6ea:	a1 e2       	ldi	r26, 0x21	; 33
    b6ec:	1a 2e       	mov	r1, r26
    b6ee:	aa 1b       	sub	r26, r26
    b6f0:	bb 1b       	sub	r27, r27
    b6f2:	fd 01       	movw	r30, r26
    b6f4:	0d c0       	rjmp	.+26     	; 0xb710 <__udivmodsi4_ep>

0000b6f6 <__udivmodsi4_loop>:
    b6f6:	aa 1f       	adc	r26, r26
    b6f8:	bb 1f       	adc	r27, r27
    b6fa:	ee 1f       	adc	r30, r30
    b6fc:	ff 1f       	adc	r31, r31
    b6fe:	a2 17       	cp	r26, r18
    b700:	b3 07       	cpc	r27, r19
    b702:	e4 07       	cpc	r30, r20
    b704:	f5 07       	cpc	r31, r21
    b706:	20 f0       	brcs	.+8      	; 0xb710 <__udivmodsi4_ep>
    b708:	a2 1b       	sub	r26, r18
    b70a:	b3 0b       	sbc	r27, r19
    b70c:	e4 0b       	sbc	r30, r20
    b70e:	f5 0b       	sbc	r31, r21

0000b710 <__udivmodsi4_ep>:
    b710:	66 1f       	adc	r22, r22
    b712:	77 1f       	adc	r23, r23
    b714:	88 1f       	adc	r24, r24
    b716:	99 1f       	adc	r25, r25
    b718:	1a 94       	dec	r1
    b71a:	69 f7       	brne	.-38     	; 0xb6f6 <__udivmodsi4_loop>
    b71c:	60 95       	com	r22
    b71e:	70 95       	com	r23
    b720:	80 95       	com	r24
    b722:	90 95       	com	r25
    b724:	9b 01       	movw	r18, r22
    b726:	ac 01       	movw	r20, r24
    b728:	bd 01       	movw	r22, r26
    b72a:	cf 01       	movw	r24, r30
    b72c:	08 95       	ret

0000b72e <_exit>:
    b72e:	f8 94       	cli

0000b730 <__stop_program>:
    b730:	ff cf       	rjmp	.-2      	; 0xb730 <__stop_program>
