   1               		.file	"hardware.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 561               	.global	hardwareInit
 563               	hardwareInit:
 564               		.stabd	46,0,0
   1:hardware.c    **** #include "hardware.h"
   2:hardware.c    **** 
   3:hardware.c    **** #if LANG_EN
   4:hardware.c    **** #include "hardware_en.h"
   5:hardware.c    **** #endif
   6:hardware.c    **** 
   7:hardware.c    **** #if LANG_PL
   8:hardware.c    **** #include "hardware_pl.h"
   9:hardware.c    **** #endif
  10:hardware.c    **** 
  11:hardware.c    **** xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisję d
  12:hardware.c    **** xQueueHandle      xSpiRxEnc;
  13:hardware.c    **** // napisać funkcje do konfiguracji zew pam s-ram
  14:hardware.c    **** void hardwareInit(void)
  15:hardware.c    **** {
 566               	.LM0:
 567               	.LFBB1:
 568               	/* prologue: function */
 569               	/* frame size = 0 */
 570               	/* stack size = 0 */
 571               	.L__stack_usage = 0
  16:hardware.c    ****   //DDRA = 0x00;  //External Memory
  17:hardware.c    ****   portENTER_CRITICAL();
 573               	.LM1:
 574               	/* #APP */
 575               	 ;  17 "hardware.c" 1
 576 0000 0FB6      		in		__tmp_reg__, __SREG__
 577               	 ;  0 "" 2
 578               	 ;  17 "hardware.c" 1
 579 0002 F894      		cli
 580               	 ;  0 "" 2
 581               	 ;  17 "hardware.c" 1
 582 0004 0F92      		push	__tmp_reg__
 583               	 ;  0 "" 2
  18:hardware.c    ****   xSpiRx          = xQueueCreate(1, 1);
 585               	.LM2:
 586               	/* #NOAPP */
 587 0006 81E0      		ldi r24,lo8(1)
 588 0008 61E0      		ldi r22,lo8(1)
 589 000a 0E94 0000 		call xQueueCreate
 590 000e 8093 0000 		sts xSpiRx,r24
 591 0012 9093 0000 		sts xSpiRx+1,r25
  19:hardware.c    ****   portEXIT_CRITICAL();
 593               	.LM3:
 594               	/* #APP */
 595               	 ;  19 "hardware.c" 1
 596 0016 0F90      		pop		__tmp_reg__
 597               	 ;  0 "" 2
 598               	 ;  19 "hardware.c" 1
 599 0018 0FBE      		out		__SREG__, __tmp_reg__
 600               	 ;  0 "" 2
  20:hardware.c    **** 
  21:hardware.c    ****  //DDRA = 0x00;  //External Memory
  22:hardware.c    ****   portENTER_CRITICAL();
 602               	.LM4:
 603               	 ;  22 "hardware.c" 1
 604 001a 0FB6      		in		__tmp_reg__, __SREG__
 605               	 ;  0 "" 2
 606               	 ;  22 "hardware.c" 1
 607 001c F894      		cli
 608               	 ;  0 "" 2
 609               	 ;  22 "hardware.c" 1
 610 001e 0F92      		push	__tmp_reg__
 611               	 ;  0 "" 2
  23:hardware.c    ****   xSpiRx          = xQueueCreate(1, 1);
 613               	.LM5:
 614               	/* #NOAPP */
 615 0020 81E0      		ldi r24,lo8(1)
 616 0022 61E0      		ldi r22,lo8(1)
 617 0024 0E94 0000 		call xQueueCreate
 618 0028 8093 0000 		sts xSpiRx,r24
 619 002c 9093 0000 		sts xSpiRx+1,r25
  24:hardware.c    ****   portEXIT_CRITICAL();
 621               	.LM6:
 622               	/* #APP */
 623               	 ;  24 "hardware.c" 1
 624 0030 0F90      		pop		__tmp_reg__
 625               	 ;  0 "" 2
 626               	 ;  24 "hardware.c" 1
 627 0032 0FBE      		out		__SREG__, __tmp_reg__
 628               	 ;  0 "" 2
  25:hardware.c    ****   /* Port B
  26:hardware.c    **** 7- JTAG TD0
  27:hardware.c    **** 6- JTAG TCK
  28:hardware.c    **** 5- JTAG TDI
  29:hardware.c    **** 4- JTAG TMS
  30:hardware.c    **** 5:2 - LCD D4:D7
  31:hardware.c    **** 0 - ENC28J60 CS
  32:hardware.c    **** */
  33:hardware.c    **** PORTB.DIR=0x01;
 630               	.LM7:
 631               	/* #NOAPP */
 632 0034 81E0      		ldi r24,lo8(1)
 633 0036 8093 2006 		sts 1568,r24
  34:hardware.c    **** /* Port C
  35:hardware.c    **** 7- ENC28J60 SCK
  36:hardware.c    **** 6- ENC28J60 SO
  37:hardware.c    **** 5- ENC28J60 SI
  38:hardware.c    **** 4- SD_card CS
  39:hardware.c    **** 3- ST2378 OE
  40:hardware.c    **** 1- I2C SCL
  41:hardware.c    **** 0- I2C SDA
  42:hardware.c    **** */
  43:hardware.c    **** PORTC.DIR=0xA0;
 635               	.LM8:
 636 003a 80EA      		ldi r24,lo8(-96)
 637 003c 8093 4006 		sts 1600,r24
  44:hardware.c    **** /* PORTD
  45:hardware.c    **** 7- SD SCK
  46:hardware.c    **** 6- SD S0
  47:hardware.c    **** 5- SD SI
  48:hardware.c    **** 4- ZL SPI SLRST
  49:hardware.c    **** 3- FT232 TXT-WY
  50:hardware.c    **** 2- FT232 RXT-WE
  51:hardware.c    **** 1- ENC28J60 RST
  52:hardware.c    **** 0- ENC28J60 INT
  53:hardware.c    **** */
  54:hardware.c    **** PORTD.DIR=0xBA;
 639               	.LM9:
 640 0040 8AEB      		ldi r24,lo8(-70)
 641 0042 8093 6006 		sts 1632,r24
  55:hardware.c    **** /* PORTE
  56:hardware.c    **** 7:0- ZL SPI A7:A0
  57:hardware.c    **** */
  58:hardware.c    **** PORTE.DIR=0xFF;
 643               	.LM10:
 644 0046 8FEF      		ldi r24,lo8(-1)
 645 0048 8093 8006 		sts 1664,r24
  59:hardware.c    **** /* PORTF
  60:hardware.c    **** 7- INT
  61:hardware.c    **** 6- INT
  62:hardware.c    **** 5- RS485 DE/RE
  63:hardware.c    **** 4- INT
  64:hardware.c    **** 3- RS485 TXD
  65:hardware.c    **** 2- RS485 RXD
  66:hardware.c    **** */
  67:hardware.c    **** PORTF.DIR=0x28;
 647               	.LM11:
 648 004c 98E2      		ldi r25,lo8(40)
 649 004e 9093 A006 		sts 1696,r25
  68:hardware.c    **** /* PORTH
  69:hardware.c    **** 6:4- EBI A18:A16
  70:hardware.c    **** 2-   EBI ALE
  71:hardware.c    **** 1-   EBI RE
  72:hardware.c    **** 0-   EBI WE
  73:hardware.c    **** */
  74:hardware.c    **** PORTH.DIR=0xFF;
 651               	.LM12:
 652 0052 8093 E006 		sts 1760,r24
  75:hardware.c    **** /* PORTJ
  76:hardware.c    **** 7:0- EBI D7:D0/A0:A7
  77:hardware.c    **** */
  78:hardware.c    **** PORTJ.DIR=0xFF;
 654               	.LM13:
 655 0056 8093 0007 		sts 1792,r24
  79:hardware.c    **** /* PORTK
  80:hardware.c    **** 7:0- EBI A8:A15
  81:hardware.c    **** */
  82:hardware.c    **** PORTK.DIR=0xFF;
 657               	.LM14:
 658 005a 8093 2007 		sts 1824,r24
 659               	/* epilogue start */
  83:hardware.c    **** }
 661               	.LM15:
 662 005e 0895      		ret
 664               	.Lscope1:
 666               		.stabd	78,0,0
 668               	.global	LockersMemInit
 670               	LockersMemInit:
 671               		.stabd	46,0,0
  84:hardware.c    **** 
  85:hardware.c    **** void LockersMemInit(void)
  86:hardware.c    **** {
 673               	.LM16:
 674               	.LFBB2:
 675               	/* prologue: function */
 676               	/* frame size = 0 */
 677               	/* stack size = 0 */
 678               	.L__stack_usage = 0
  87:hardware.c    ****   lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
 680               	.LM17:
 681 0060 88E1      		ldi r24,lo8(24)
 682 0062 90E0      		ldi r25,hi8(24)
 683 0064 0E94 0000 		call xmalloc
 684 0068 8093 0000 		sts lockSensors,r24
 685 006c 9093 0000 		sts lockSensors+1,r25
 686               	/* epilogue start */
  88:hardware.c    **** }
 688               	.LM18:
 689 0070 0895      		ret
 691               	.Lscope2:
 693               		.stabd	78,0,0
 696               	.global	printLockers
 698               	printLockers:
 699               		.stabd	46,0,0
  89:hardware.c    **** 
  90:hardware.c    **** uint8_t printLockers(FILE *stream)
  91:hardware.c    **** {
 701               	.LM19:
 702               	.LFBB3:
 703 0072 4F92      		push r4
 704 0074 5F92      		push r5
 705 0076 6F92      		push r6
 706 0078 7F92      		push r7
 707 007a 9F92      		push r9
 708 007c AF92      		push r10
 709 007e BF92      		push r11
 710 0080 CF92      		push r12
 711 0082 DF92      		push r13
 712 0084 EF92      		push r14
 713 0086 FF92      		push r15
 714 0088 0F93      		push r16
 715 008a 1F93      		push r17
 716 008c CF93      		push r28
 717 008e DF93      		push r29
 718               	/* prologue: function */
 719               	/* frame size = 0 */
 720               	/* stack size = 15 */
 721               	.L__stack_usage = 15
 722 0090 7C01      		movw r14,r24
  92:hardware.c    ****   uint8_t i;
  93:hardware.c    ****   uint8_t result = 0;
  94:hardware.c    ****   struct lockerSensor *tmpLock = lockSensors;
 724               	.LM20:
 725 0092 C091 0000 		lds r28,lockSensors
 726 0096 D091 0000 		lds r29,lockSensors+1
 727 009a 00E0      		ldi r16,lo8(0)
 728 009c 10E0      		ldi r17,hi8(0)
  93:hardware.c    ****   uint8_t result = 0;
 730               	.LM21:
 731 009e 9924      		clr r9
  95:hardware.c    ****   for (i=1; i<=4; i++)
  96:hardware.c    ****   {
  97:hardware.c    ****     if (tmpLock->enabled)
  98:hardware.c    ****     {
  99:hardware.c    ****       fprintf_P(stream, statusLockerSensDescStr, i);
 733               	.LM22:
 734 00a0 30E0      		ldi r19,lo8(statusLockerSensDescStr)
 735 00a2 C32E      		mov r12,r19
 736 00a4 30E0      		ldi r19,hi8(statusLockerSensDescStr)
 737 00a6 D32E      		mov r13,r19
 100:hardware.c    ****       if (tmpLock->threshold > tmpLock->acVal)
 101:hardware.c    ****         fprintf_P(stream, statusLockerOpenStr);
 102:hardware.c    ****       else
 103:hardware.c    ****         fprintf_P(stream, statusLockerCloseStr);
 104:hardware.c    ****       fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
 739               	.LM23:
 740 00a8 20E0      		ldi r18,lo8(statusLockerSensAdditionalDescStr)
 741 00aa A22E      		mov r10,r18
 742 00ac 20E0      		ldi r18,hi8(statusLockerSensAdditionalDescStr)
 743 00ae B22E      		mov r11,r18
 103:hardware.c    ****         fprintf_P(stream, statusLockerCloseStr);
 745               	.LM24:
 746 00b0 90E0      		ldi r25,lo8(statusLockerCloseStr)
 747 00b2 692E      		mov r6,r25
 748 00b4 90E0      		ldi r25,hi8(statusLockerCloseStr)
 749 00b6 792E      		mov r7,r25
 101:hardware.c    ****         fprintf_P(stream, statusLockerOpenStr);
 751               	.LM25:
 752 00b8 80E0      		ldi r24,lo8(statusLockerOpenStr)
 753 00ba 482E      		mov r4,r24
 754 00bc 80E0      		ldi r24,hi8(statusLockerOpenStr)
 755 00be 582E      		mov r5,r24
 756               	.L8:
  97:hardware.c    ****     if (tmpLock->enabled)
 758               	.LM26:
 759 00c0 8881      		ld r24,Y
 760 00c2 8823      		tst r24
 761 00c4 01F4      		brne .+2
 762 00c6 00C0      		rjmp .L4
  99:hardware.c    ****       fprintf_P(stream, statusLockerSensDescStr, i);
 764               	.LM27:
 765 00c8 00D0      		rcall .
 766 00ca 00D0      		rcall .
 767 00cc EDB7      		in r30,__SP_L__
 768 00ce FEB7      		in r31,__SP_H__
 769 00d0 3196      		adiw r30,1
 770 00d2 ADB7      		in r26,__SP_L__
 771 00d4 BEB7      		in r27,__SP_H__
 772 00d6 1196      		adiw r26,1
 773 00d8 ED92      		st X+,r14
 774 00da FC92      		st X,r15
 775 00dc 1297      		sbiw r26,1+1
 776 00de C282      		std Z+2,r12
 777 00e0 D382      		std Z+3,r13
  90:hardware.c    **** uint8_t printLockers(FILE *stream)
 779               	.LM28:
 780 00e2 C801      		movw r24,r16
 781 00e4 0196      		adiw r24,1
  99:hardware.c    ****       fprintf_P(stream, statusLockerSensDescStr, i);
 783               	.LM29:
 784 00e6 8483      		std Z+4,r24
 785 00e8 9583      		std Z+5,r25
 786 00ea 0E94 0000 		call fprintf_P
 100:hardware.c    ****       if (tmpLock->threshold > tmpLock->acVal)
 788               	.LM30:
 789 00ee EDB7      		in r30,__SP_L__
 790 00f0 FEB7      		in r31,__SP_H__
 791 00f2 3696      		adiw r30,6
 792 00f4 EDBF      		out __SP_L__,r30
 793 00f6 FEBF      		out __SP_H__,r31
 794 00f8 2981      		ldd r18,Y+1
 795 00fa 3A81      		ldd r19,Y+2
 796 00fc 8B81      		ldd r24,Y+3
 797 00fe 9C81      		ldd r25,Y+4
 798 0100 8217      		cp r24,r18
 799 0102 9307      		cpc r25,r19
 800 0104 00F4      		brsh .L5
 101:hardware.c    ****         fprintf_P(stream, statusLockerOpenStr);
 802               	.LM31:
 803 0106 00D0      		rcall .
 804 0108 0F92      		push __tmp_reg__
 805 010a ADB7      		in r26,__SP_L__
 806 010c BEB7      		in r27,__SP_H__
 807 010e 1196      		adiw r26,1
 808 0110 ED92      		st X+,r14
 809 0112 FC92      		st X,r15
 810 0114 1297      		sbiw r26,1+1
 811 0116 1396      		adiw r26,3
 812 0118 4D92      		st X+,r4
 813 011a 5C92      		st X,r5
 814 011c 1497      		sbiw r26,3+1
 815 011e 00C0      		rjmp .L9
 816               	.L5:
 103:hardware.c    ****         fprintf_P(stream, statusLockerCloseStr);
 818               	.LM32:
 819 0120 00D0      		rcall .
 820 0122 0F92      		push __tmp_reg__
 821 0124 EDB7      		in r30,__SP_L__
 822 0126 FEB7      		in r31,__SP_H__
 823 0128 E182      		std Z+1,r14
 824 012a F282      		std Z+2,r15
 825 012c 6382      		std Z+3,r6
 826 012e 7482      		std Z+4,r7
 827               	.L9:
 828 0130 0E94 0000 		call fprintf_P
 829 0134 0F90      		pop __tmp_reg__
 830 0136 0F90      		pop __tmp_reg__
 831 0138 0F90      		pop __tmp_reg__
 832 013a 0F90      		pop __tmp_reg__
 834               	.LM33:
 835 013c 8DB7      		in r24,__SP_L__
 836 013e 9EB7      		in r25,__SP_H__
 837 0140 0897      		sbiw r24,8
 838 0142 8DBF      		out __SP_L__,r24
 839 0144 9EBF      		out __SP_H__,r25
 840 0146 EDB7      		in r30,__SP_L__
 841 0148 FEB7      		in r31,__SP_H__
 842 014a 3196      		adiw r30,1
 843 014c ADB7      		in r26,__SP_L__
 844 014e BEB7      		in r27,__SP_H__
 845 0150 1196      		adiw r26,1
 846 0152 ED92      		st X+,r14
 847 0154 FC92      		st X,r15
 848 0156 1297      		sbiw r26,1+1
 849 0158 A282      		std Z+2,r10
 850 015a B382      		std Z+3,r11
 851 015c 8981      		ldd r24,Y+1
 852 015e 9A81      		ldd r25,Y+2
 853 0160 8483      		std Z+4,r24
 854 0162 9583      		std Z+5,r25
 855 0164 8B81      		ldd r24,Y+3
 856 0166 9C81      		ldd r25,Y+4
 857 0168 8683      		std Z+6,r24
 858 016a 9783      		std Z+7,r25
 859 016c 0E94 0000 		call fprintf_P
 105:hardware.c    ****       result++;
 861               	.LM34:
 862 0170 9394      		inc r9
 863 0172 EDB7      		in r30,__SP_L__
 864 0174 FEB7      		in r31,__SP_H__
 865 0176 3896      		adiw r30,8
 866 0178 EDBF      		out __SP_L__,r30
 867 017a FEBF      		out __SP_H__,r31
 868               	.L4:
 869 017c 0F5F      		subi r16,lo8(-(1))
 870 017e 1F4F      		sbci r17,hi8(-(1))
  95:hardware.c    ****   for (i=1; i<=4; i++)
 872               	.LM35:
 873 0180 0430      		cpi r16,4
 874 0182 1105      		cpc r17,__zero_reg__
 875 0184 01F0      		breq .L7
 106:hardware.c    ****     }
 107:hardware.c    ****     tmpLock++;
 877               	.LM36:
 878 0186 2696      		adiw r28,6
 879 0188 00C0      		rjmp .L8
 880               	.L7:
 108:hardware.c    ****   }
 109:hardware.c    ****   return result;
 110:hardware.c    **** }
 882               	.LM37:
 883 018a 892D      		mov r24,r9
 884               	/* epilogue start */
 885 018c DF91      		pop r29
 886 018e CF91      		pop r28
 887 0190 1F91      		pop r17
 888 0192 0F91      		pop r16
 889 0194 FF90      		pop r15
 890 0196 EF90      		pop r14
 891 0198 DF90      		pop r13
 892 019a CF90      		pop r12
 893 019c BF90      		pop r11
 894 019e AF90      		pop r10
 895 01a0 9F90      		pop r9
 896 01a2 7F90      		pop r7
 897 01a4 6F90      		pop r6
 898 01a6 5F90      		pop r5
 899 01a8 4F90      		pop r4
 900 01aa 0895      		ret
 906               	.Lscope3:
 908               		.stabd	78,0,0
 910               	.global	checkLockerSensors
 912               	checkLockerSensors:
 913               		.stabd	46,0,0
 111:hardware.c    **** 
 112:hardware.c    **** void checkLockerSensors(void)
 113:hardware.c    **** {
 915               	.LM38:
 916               	.LFBB4:
 917 01ac CF93      		push r28
 918 01ae DF93      		push r29
 919               	/* prologue: function */
 920               	/* frame size = 0 */
 921               	/* stack size = 2 */
 922               	.L__stack_usage = 2
 114:hardware.c    ****   if (lockSensors[0].enabled)
 924               	.LM39:
 925 01b0 E091 0000 		lds r30,lockSensors
 926 01b4 F091 0000 		lds r31,lockSensors+1
 927 01b8 8081      		ld r24,Z
 928 01ba 8823      		tst r24
 929 01bc 01F0      		breq .L11
 115:hardware.c    ****   {
 116:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
 931               	.LM40:
 932 01be 80E4      		ldi r24,lo8(64)
 933 01c0 60E0      		ldi r22,lo8(0)
 934 01c2 0E94 0000 		call MPC23s17SetBitsOnPortA
 117:hardware.c    ****     vTaskDelay(30);
 936               	.LM41:
 937 01c6 8EE1      		ldi r24,lo8(30)
 938 01c8 90E0      		ldi r25,hi8(30)
 939 01ca 0E94 0000 		call vTaskDelay
 118:hardware.c    ****     lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
 941               	.LM42:
 942 01ce C091 0000 		lds r28,lockSensors
 943 01d2 D091 0000 		lds r29,lockSensors+1
 944 01d6 84E0      		ldi r24,lo8(4)
 945 01d8 0E94 0000 		call MCP3008_getSampleSingle
 946 01dc 8B83      		std Y+3,r24
 947 01de 9C83      		std Y+4,r25
 119:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
 949               	.LM43:
 950 01e0 80E4      		ldi r24,lo8(64)
 951 01e2 60E0      		ldi r22,lo8(0)
 952 01e4 0E94 0000 		call MPC23s17ClearBitsOnPortA
 120:hardware.c    ****     lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
 954               	.LM44:
 955 01e8 E091 0000 		lds r30,lockSensors
 956 01ec F091 0000 		lds r31,lockSensors+1
 957 01f0 41E0      		ldi r20,lo8(1)
 958 01f2 2381      		ldd r18,Z+3
 959 01f4 3481      		ldd r19,Z+4
 960 01f6 8181      		ldd r24,Z+1
 961 01f8 9281      		ldd r25,Z+2
 962 01fa 8217      		cp r24,r18
 963 01fc 9307      		cpc r25,r19
 964 01fe 00F0      		brlo .L12
 965 0200 40E0      		ldi r20,lo8(0)
 966               	.L12:
 967 0202 4583      		std Z+5,r20
 121:hardware.c    ****     vTaskDelay(10);
 969               	.LM45:
 970 0204 8AE0      		ldi r24,lo8(10)
 971 0206 90E0      		ldi r25,hi8(10)
 972 0208 0E94 0000 		call vTaskDelay
 973               	.L11:
 122:hardware.c    ****   }
 123:hardware.c    ****   
 124:hardware.c    ****   if (lockSensors[1].enabled)
 975               	.LM46:
 976 020c E091 0000 		lds r30,lockSensors
 977 0210 F091 0000 		lds r31,lockSensors+1
 978 0214 8681      		ldd r24,Z+6
 979 0216 8823      		tst r24
 980 0218 01F0      		breq .L13
 125:hardware.c    ****   {
 126:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
 982               	.LM47:
 983 021a 80E2      		ldi r24,lo8(32)
 984 021c 60E0      		ldi r22,lo8(0)
 985 021e 0E94 0000 		call MPC23s17SetBitsOnPortA
 127:hardware.c    ****     vTaskDelay(30);
 987               	.LM48:
 988 0222 8EE1      		ldi r24,lo8(30)
 989 0224 90E0      		ldi r25,hi8(30)
 990 0226 0E94 0000 		call vTaskDelay
 128:hardware.c    ****     lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
 992               	.LM49:
 993 022a C091 0000 		lds r28,lockSensors
 994 022e D091 0000 		lds r29,lockSensors+1
 995 0232 2696      		adiw r28,6
 996 0234 85E0      		ldi r24,lo8(5)
 997 0236 0E94 0000 		call MCP3008_getSampleSingle
 998 023a 8B83      		std Y+3,r24
 999 023c 9C83      		std Y+4,r25
 129:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
 1001               	.LM50:
 1002 023e 80E2      		ldi r24,lo8(32)
 1003 0240 60E0      		ldi r22,lo8(0)
 1004 0242 0E94 0000 		call MPC23s17ClearBitsOnPortA
 130:hardware.c    ****     lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
 1006               	.LM51:
 1007 0246 E091 0000 		lds r30,lockSensors
 1008 024a F091 0000 		lds r31,lockSensors+1
 1009 024e 3696      		adiw r30,6
 1010 0250 41E0      		ldi r20,lo8(1)
 1011 0252 2381      		ldd r18,Z+3
 1012 0254 3481      		ldd r19,Z+4
 1013 0256 8181      		ldd r24,Z+1
 1014 0258 9281      		ldd r25,Z+2
 1015 025a 8217      		cp r24,r18
 1016 025c 9307      		cpc r25,r19
 1017 025e 00F0      		brlo .L14
 1018 0260 40E0      		ldi r20,lo8(0)
 1019               	.L14:
 1020 0262 4583      		std Z+5,r20
 131:hardware.c    ****     vTaskDelay(10);
 1022               	.LM52:
 1023 0264 8AE0      		ldi r24,lo8(10)
 1024 0266 90E0      		ldi r25,hi8(10)
 1025 0268 0E94 0000 		call vTaskDelay
 1026               	.L13:
 132:hardware.c    ****   }
 133:hardware.c    ****   
 134:hardware.c    ****   if (lockSensors[2].enabled)
 1028               	.LM53:
 1029 026c E091 0000 		lds r30,lockSensors
 1030 0270 F091 0000 		lds r31,lockSensors+1
 1031 0274 8485      		ldd r24,Z+12
 1032 0276 8823      		tst r24
 1033 0278 01F0      		breq .L15
 135:hardware.c    ****   {
 136:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
 1035               	.LM54:
 1036 027a 80E1      		ldi r24,lo8(16)
 1037 027c 60E0      		ldi r22,lo8(0)
 1038 027e 0E94 0000 		call MPC23s17SetBitsOnPortA
 137:hardware.c    ****     vTaskDelay(30);
 1040               	.LM55:
 1041 0282 8EE1      		ldi r24,lo8(30)
 1042 0284 90E0      		ldi r25,hi8(30)
 1043 0286 0E94 0000 		call vTaskDelay
 138:hardware.c    ****     lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
 1045               	.LM56:
 1046 028a C091 0000 		lds r28,lockSensors
 1047 028e D091 0000 		lds r29,lockSensors+1
 1048 0292 2C96      		adiw r28,12
 1049 0294 86E0      		ldi r24,lo8(6)
 1050 0296 0E94 0000 		call MCP3008_getSampleSingle
 1051 029a 8B83      		std Y+3,r24
 1052 029c 9C83      		std Y+4,r25
 139:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
 1054               	.LM57:
 1055 029e 80E1      		ldi r24,lo8(16)
 1056 02a0 60E0      		ldi r22,lo8(0)
 1057 02a2 0E94 0000 		call MPC23s17ClearBitsOnPortA
 140:hardware.c    ****     lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
 1059               	.LM58:
 1060 02a6 E091 0000 		lds r30,lockSensors
 1061 02aa F091 0000 		lds r31,lockSensors+1
 1062 02ae 3C96      		adiw r30,12
 1063 02b0 41E0      		ldi r20,lo8(1)
 1064 02b2 2381      		ldd r18,Z+3
 1065 02b4 3481      		ldd r19,Z+4
 1066 02b6 8181      		ldd r24,Z+1
 1067 02b8 9281      		ldd r25,Z+2
 1068 02ba 8217      		cp r24,r18
 1069 02bc 9307      		cpc r25,r19
 1070 02be 00F0      		brlo .L16
 1071 02c0 40E0      		ldi r20,lo8(0)
 1072               	.L16:
 1073 02c2 4583      		std Z+5,r20
 141:hardware.c    ****     vTaskDelay(10);
 1075               	.LM59:
 1076 02c4 8AE0      		ldi r24,lo8(10)
 1077 02c6 90E0      		ldi r25,hi8(10)
 1078 02c8 0E94 0000 		call vTaskDelay
 1079               	.L15:
 142:hardware.c    ****   }
 143:hardware.c    ****   
 144:hardware.c    ****   if (lockSensors[3].enabled)
 1081               	.LM60:
 1082 02cc E091 0000 		lds r30,lockSensors
 1083 02d0 F091 0000 		lds r31,lockSensors+1
 1084 02d4 8289      		ldd r24,Z+18
 1085 02d6 8823      		tst r24
 1086 02d8 01F0      		breq .L10
 145:hardware.c    ****   {
 146:hardware.c    ****     MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
 1088               	.LM61:
 1089 02da 88E0      		ldi r24,lo8(8)
 1090 02dc 60E0      		ldi r22,lo8(0)
 1091 02de 0E94 0000 		call MPC23s17SetBitsOnPortA
 147:hardware.c    ****     vTaskDelay(30);
 1093               	.LM62:
 1094 02e2 8EE1      		ldi r24,lo8(30)
 1095 02e4 90E0      		ldi r25,hi8(30)
 1096 02e6 0E94 0000 		call vTaskDelay
 148:hardware.c    ****     lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
 1098               	.LM63:
 1099 02ea C091 0000 		lds r28,lockSensors
 1100 02ee D091 0000 		lds r29,lockSensors+1
 1101 02f2 6296      		adiw r28,18
 1102 02f4 87E0      		ldi r24,lo8(7)
 1103 02f6 0E94 0000 		call MCP3008_getSampleSingle
 1104 02fa 8B83      		std Y+3,r24
 1105 02fc 9C83      		std Y+4,r25
 149:hardware.c    ****     MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
 1107               	.LM64:
 1108 02fe 88E0      		ldi r24,lo8(8)
 1109 0300 60E0      		ldi r22,lo8(0)
 1110 0302 0E94 0000 		call MPC23s17ClearBitsOnPortA
 150:hardware.c    ****     lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
 1112               	.LM65:
 1113 0306 E091 0000 		lds r30,lockSensors
 1114 030a F091 0000 		lds r31,lockSensors+1
 1115 030e 7296      		adiw r30,18
 1116 0310 41E0      		ldi r20,lo8(1)
 1117 0312 2381      		ldd r18,Z+3
 1118 0314 3481      		ldd r19,Z+4
 1119 0316 8181      		ldd r24,Z+1
 1120 0318 9281      		ldd r25,Z+2
 1121 031a 8217      		cp r24,r18
 1122 031c 9307      		cpc r25,r19
 1123 031e 00F0      		brlo .L18
 1124 0320 40E0      		ldi r20,lo8(0)
 1125               	.L18:
 1126 0322 4583      		std Z+5,r20
 151:hardware.c    ****     vTaskDelay(10);
 1128               	.LM66:
 1129 0324 8AE0      		ldi r24,lo8(10)
 1130 0326 90E0      		ldi r25,hi8(10)
 1131 0328 0E94 0000 		call vTaskDelay
 1132               	.L10:
 1133               	/* epilogue start */
 152:hardware.c    ****   }
 153:hardware.c    **** }
 1135               	.LM67:
 1136 032c DF91      		pop r29
 1137 032e CF91      		pop r28
 1138 0330 0895      		ret
 1140               	.Lscope4:
 1142               		.stabd	78,0,0
 1145               		.weak	spiSend
 1147               	spiSend:
 1148               		.stabd	46,0,0
 154:hardware.c    **** 
 155:hardware.c    **** 
 156:hardware.c    **** uint8_t spiSend(uint8_t data)
 157:hardware.c    **** {
 1150               	.LM68:
 1151               	.LFBB5:
 1152 0332 DF93      		push r29
 1153 0334 CF93      		push r28
 1154 0336 0F92      		push __tmp_reg__
 1155 0338 CDB7      		in r28,__SP_L__
 1156 033a DEB7      		in r29,__SP_H__
 1157               	/* prologue: function */
 1158               	/* frame size = 1 */
 1159               	/* stack size = 3 */
 1160               	.L__stack_usage = 3
 158:hardware.c    ****   uint8_t result; 
 159:hardware.c    ****  // SPIC.DATA = data;
 160:hardware.c    ****   SPID.DATA = data; 
 1162               	.LM69:
 1163 033c E0EC      		ldi r30,lo8(2496)
 1164 033e F9E0      		ldi r31,hi8(2496)
 1165 0340 8383      		std Z+3,r24
 161:hardware.c    ****   xQueueReceive(xSpiRx, &result, 10); 
 1167               	.LM70:
 1168 0342 8091 0000 		lds r24,xSpiRx
 1169 0346 9091 0000 		lds r25,xSpiRx+1
 1170 034a BE01      		movw r22,r28
 1171 034c 6F5F      		subi r22,lo8(-(1))
 1172 034e 7F4F      		sbci r23,hi8(-(1))
 1173 0350 4AE0      		ldi r20,lo8(10)
 1174 0352 50E0      		ldi r21,hi8(10)
 1175 0354 20E0      		ldi r18,lo8(0)
 1176 0356 0E94 0000 		call xQueueGenericReceive
 162:hardware.c    ****   return result;
 163:hardware.c    **** }
 1178               	.LM71:
 1179 035a 8981      		ldd r24,Y+1
 1180               	/* epilogue start */
 1181 035c 0F90      		pop __tmp_reg__
 1182 035e CF91      		pop r28
 1183 0360 DF91      		pop r29
 1184 0362 0895      		ret
 1189               	.Lscope5:
 1191               		.stabd	78,0,0
 1194               	.global	spiSendENC
 1196               	spiSendENC:
 1197               		.stabd	46,0,0
 164:hardware.c    **** uint8_t spiSendENC(uint8_t data)
 165:hardware.c    **** {
 1199               	.LM72:
 1200               	.LFBB6:
 1201 0364 DF93      		push r29
 1202 0366 CF93      		push r28
 1203 0368 0F92      		push __tmp_reg__
 1204 036a CDB7      		in r28,__SP_L__
 1205 036c DEB7      		in r29,__SP_H__
 1206               	/* prologue: function */
 1207               	/* frame size = 1 */
 1208               	/* stack size = 3 */
 1209               	.L__stack_usage = 3
 166:hardware.c    ****   uint8_t result; 
 167:hardware.c    ****   SPIC.DATA = data;
 1211               	.LM73:
 1212 036e E0EC      		ldi r30,lo8(2240)
 1213 0370 F8E0      		ldi r31,hi8(2240)
 1214 0372 8383      		std Z+3,r24
 168:hardware.c    ****   //SPID.DATA = data; 
 169:hardware.c    ****   xQueueReceive(xSpiRxEnc, &result, 10); 
 1216               	.LM74:
 1217 0374 8091 0000 		lds r24,xSpiRxEnc
 1218 0378 9091 0000 		lds r25,xSpiRxEnc+1
 1219 037c BE01      		movw r22,r28
 1220 037e 6F5F      		subi r22,lo8(-(1))
 1221 0380 7F4F      		sbci r23,hi8(-(1))
 1222 0382 4AE0      		ldi r20,lo8(10)
 1223 0384 50E0      		ldi r21,hi8(10)
 1224 0386 20E0      		ldi r18,lo8(0)
 1225 0388 0E94 0000 		call xQueueGenericReceive
 170:hardware.c    ****   return result;
 171:hardware.c    **** }
 1227               	.LM75:
 1228 038c 8981      		ldd r24,Y+1
 1229               	/* epilogue start */
 1230 038e 0F90      		pop __tmp_reg__
 1231 0390 CF91      		pop r28
 1232 0392 DF91      		pop r29
 1233 0394 0895      		ret
 1238               	.Lscope6:
 1240               		.stabd	78,0,0
 1243               		.weak	spiSendSpinBlock
 1245               	spiSendSpinBlock:
 1246               		.stabd	46,0,0
 172:hardware.c    **** 
 173:hardware.c    **** uint8_t spiSendSpinBlock(uint8_t data)
 174:hardware.c    **** {
 1248               	.LM76:
 1249               	.LFBB7:
 1250               	/* prologue: function */
 1251               	/* frame size = 0 */
 1252               	/* stack size = 0 */
 1253               	.L__stack_usage = 0
 1254               	.L22:
 175:hardware.c    ****   //SPDR = data;
 176:hardware.c    ****  // SPIC.DATA=data;
 177:hardware.c    ****   //SPCR &= ~(1<<SPIE);                
 178:hardware.c    ****   //SPIC.INTCTRL=0x00; //Disable SPI interrupt
 179:hardware.c    ****   while(!(SPID.STATUS&(0x80))); //(SPSR&(1<<SPIF)));
 1256               	.LM77:
 1257 0396 8091 C209 		lds r24,2498
 1258 039a 87FF      		sbrs r24,7
 1259 039c 00C0      		rjmp .L22
 180:hardware.c    ****   data = SPID.DATA;//SPSR;                       Clearing interrupt flag
 1261               	.LM78:
 1262 039e 8091 C309 		lds r24,2499
 181:hardware.c    ****   data = SPID.DATA; //SPDR;                      Resfing DPI buffer register
 1264               	.LM79:
 1265 03a2 8091 C309 		lds r24,2499
 182:hardware.c    ****   //SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
 183:hardware.c    ****   SPID.INTCTRL|=0x01; //low level
 1267               	.LM80:
 1268 03a6 9091 C109 		lds r25,2497
 1269 03aa 9160      		ori r25,lo8(1)
 1270 03ac E0EC      		ldi r30,lo8(2496)
 1271 03ae F9E0      		ldi r31,hi8(2496)
 1272 03b0 9183      		std Z+1,r25
 1273               	/* epilogue start */
 184:hardware.c    ****   return data;                     
 185:hardware.c    **** }
 1275               	.LM81:
 1276 03b2 0895      		ret
 1278               	.Lscope7:
 1280               		.stabd	78,0,0
 1283               	.global	spiSendSpinBlockENC
 1285               	spiSendSpinBlockENC:
 1286               		.stabd	46,0,0
 186:hardware.c    **** uint8_t spiSendSpinBlockENC(uint8_t data)
 187:hardware.c    **** {
 1288               	.LM82:
 1289               	.LFBB8:
 1290               	/* prologue: function */
 1291               	/* frame size = 0 */
 1292               	/* stack size = 0 */
 1293               	.L__stack_usage = 0
 188:hardware.c    ****   //SPDR = data;
 189:hardware.c    ****   SPIC.DATA=data;
 1295               	.LM83:
 1296 03b4 E0EC      		ldi r30,lo8(2240)
 1297 03b6 F8E0      		ldi r31,hi8(2240)
 1298 03b8 8383      		std Z+3,r24
 190:hardware.c    ****   //SPCR &= ~(1<<SPIE);                
 191:hardware.c    ****   SPIC.INTCTRL=0x00; //Disable SPI interrupt
 1300               	.LM84:
 1301 03ba 1182      		std Z+1,__zero_reg__
 1302               	.L25:
 192:hardware.c    ****   while(!(SPIC.STATUS&(0x80))); //(SPSR&(1<<SPIF)));
 1304               	.LM85:
 1305 03bc 8091 C208 		lds r24,2242
 1306 03c0 87FF      		sbrs r24,7
 1307 03c2 00C0      		rjmp .L25
 193:hardware.c    ****   data = SPIC.DATA;//SPSR;                       Clearing interrupt flag
 1309               	.LM86:
 1310 03c4 8091 C308 		lds r24,2243
 194:hardware.c    ****   data = SPIC.DATA; //SPDR;                      Resfing DPI buffer register
 1312               	.LM87:
 1313 03c8 8091 C308 		lds r24,2243
 195:hardware.c    ****   //SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
 196:hardware.c    ****   SPIC.INTCTRL|=0x01; //low level
 1315               	.LM88:
 1316 03cc 9091 C108 		lds r25,2241
 1317 03d0 9160      		ori r25,lo8(1)
 1318 03d2 E0EC      		ldi r30,lo8(2240)
 1319 03d4 F8E0      		ldi r31,hi8(2240)
 1320 03d6 9183      		std Z+1,r25
 1321               	/* epilogue start */
 197:hardware.c    ****   return data;                     
 198:hardware.c    **** }
 1323               	.LM89:
 1324 03d8 0895      		ret
 1326               	.Lscope8:
 1328               		.stabd	78,0,0
 1330               	.global	disableAllSpiDevices
 1332               	disableAllSpiDevices:
 1333               		.stabd	46,0,0
 199:hardware.c    **** //tu duzo zmienic i hardwareconfig.h
 200:hardware.c    **** void disableAllSpiDevices(void)
 201:hardware.c    **** { 
 1335               	.LM90:
 1336               	.LFBB9:
 1337               	/* prologue: function */
 1338               	/* frame size = 0 */
 1339               	/* stack size = 0 */
 1340               	.L__stack_usage = 0
 202:hardware.c    **** #if disableSpiPORTA_OR !=0
 203:hardware.c    ****   PORTA.OUT |= disableSpiPORTA_OR;
 204:hardware.c    **** #endif
 205:hardware.c    **** #if disableSpiPORTB_AND !=0xFF
 206:hardware.c    ****   PORTA.OUT &= disableSpiPORTB_AND;
 1342               	.LM91:
 1343 03da E0E0      		ldi r30,lo8(1536)
 1344 03dc F6E0      		ldi r31,hi8(1536)
 1345 03de 8481      		ldd r24,Z+4
 1346 03e0 8E7F      		andi r24,lo8(-2)
 1347 03e2 8483      		std Z+4,r24
 207:hardware.c    **** #endif
 208:hardware.c    ****   
 209:hardware.c    **** #if disableSpiPORTB_OR != 0
 210:hardware.c    ****   PORTB.OUT |= disableSpiPORTB_OR;
 1349               	.LM92:
 1350 03e4 E0E2      		ldi r30,lo8(1568)
 1351 03e6 F6E0      		ldi r31,hi8(1568)
 1352 03e8 8481      		ldd r24,Z+4
 1353 03ea 8160      		ori r24,lo8(1)
 1354 03ec 8483      		std Z+4,r24
 211:hardware.c    **** #endif
 212:hardware.c    **** #if disableSpiPORTB_AND != 0xFF 
 213:hardware.c    ****   PORTB.OUT &= disableSpiPORTB_AND;
 1356               	.LM93:
 1357 03ee 8481      		ldd r24,Z+4
 1358 03f0 8E7F      		andi r24,lo8(-2)
 1359 03f2 8483      		std Z+4,r24
 214:hardware.c    **** #endif
 215:hardware.c    ****   
 216:hardware.c    **** #if disableSpiPORTC_OR !=0
 217:hardware.c    ****   PORTC.OUT |= disableSpiPORTC_OR;
 1361               	.LM94:
 1362 03f4 E0E4      		ldi r30,lo8(1600)
 1363 03f6 F6E0      		ldi r31,hi8(1600)
 1364 03f8 8481      		ldd r24,Z+4
 1365 03fa 8061      		ori r24,lo8(16)
 1366 03fc 8483      		std Z+4,r24
 218:hardware.c    **** #endif
 219:hardware.c    **** #if disableSpiPORTC_AND !=0xFF
 220:hardware.c    ****   PORTC.OUT |= disableSpiPORTC_AND;
 1368               	.LM95:
 1369 03fe 8481      		ldd r24,Z+4
 1370 0400 8F6E      		ori r24,lo8(-17)
 1371 0402 8483      		std Z+4,r24
 221:hardware.c    **** #endif
 222:hardware.c    ****   
 223:hardware.c    **** #if disableSpiPORTD_OR != 0
 224:hardware.c    ****   PORTD.OUT |= disableSpiPORTD_OR;
 225:hardware.c    **** #endif
 226:hardware.c    **** #if disableSpiPORTD_AND != 0xFF
 227:hardware.c    ****   PORTD.OUT &= disableSpiPORTD_AND;
 228:hardware.c    **** #endif
 229:hardware.c    ****   
 230:hardware.c    **** #if disableSpiPORTE_OR != 0
 231:hardware.c    ****   PORTE.OUT |= disableSpiPORTE_OR;
 1373               	.LM96:
 1374 0404 E0E8      		ldi r30,lo8(1664)
 1375 0406 F6E0      		ldi r31,hi8(1664)
 1376 0408 8481      		ldd r24,Z+4
 1377 040a 806C      		ori r24,lo8(-64)
 1378 040c 8483      		std Z+4,r24
 232:hardware.c    **** #endif
 233:hardware.c    **** #if disableSpiPORTE_AND != 0xFF
 234:hardware.c    ****   PORTE.OUT &= disableSpiPORTE_AND;
 1380               	.LM97:
 1381 040e 8481      		ldd r24,Z+4
 1382 0410 8F7D      		andi r24,lo8(-33)
 1383 0412 8483      		std Z+4,r24
 1384               	/* epilogue start */
 235:hardware.c    **** #endif
 236:hardware.c    **** 
 237:hardware.c    **** #if disableSpiPORTF_OR != 0
 238:hardware.c    ****   PORTF.OUT |= disableSpiPORTF_OR;
 239:hardware.c    **** #endif
 240:hardware.c    **** #if disableSpiPORTF_AND != 0xFF
 241:hardware.c    ****   PORTF.OUT &= disableSpiPORTF_AND;
 242:hardware.c    **** #endif
 243:hardware.c    **** 
 244:hardware.c    ****   #if disableSpiPORTJ_OR != 0
 245:hardware.c    **** #error Port J is memory bus
 246:hardware.c    ****   PORTJ.OUT |= disableSpiPORTJ_OR;
 247:hardware.c    **** #endif
 248:hardware.c    **** #if disableSpiPORTJ_AND != 0xFF
 249:hardware.c    **** #error Port J is memory bus
 250:hardware.c    ****   PORTJ.OUT &= disableSpiPORTJ_AND;
 251:hardware.c    **** #endif
 252:hardware.c    ****   
 253:hardware.c    **** #if disableSpiPORTK_OR != 0
 254:hardware.c    **** #error Port K is memory bus
 255:hardware.c    ****   PORTK.OUT |= disableSpiPORTK_OR;
 256:hardware.c    **** #endif
 257:hardware.c    **** #if disableSpiPORTK_AND != 0xFF
 258:hardware.c    **** #error Port K is memory bus
 259:hardware.c    ****   PORTK.OUT &= disableSpiPORTK_AND;
 260:hardware.c    **** #endif
 261:hardware.c    ****   
 262:hardware.c    ****   #if disableSpiPORTH_OR != 0
 263:hardware.c    **** #error Port H is memory bus
 264:hardware.c    ****   PORTK.OUT |= disableSpiPORTG_OR;
 265:hardware.c    **** #endif
 266:hardware.c    **** #if disableSpiPORTH_AND != 0xFF
 267:hardware.c    **** #error Port H is memory bus
 268:hardware.c    ****   PORTH.OUT &= disableSpiPORTG_AND;
 269:hardware.c    **** #endif
 270:hardware.c    **** 
 271:hardware.c    **** }
 1386               	.LM98:
 1387 0414 0895      		ret
 1389               	.Lscope9:
 1391               		.stabd	78,0,0
 1393               		.weak	spiEnableEnc28j60
 1395               	spiEnableEnc28j60:
 1396               		.stabd	46,0,0
 272:hardware.c    **** 
 273:hardware.c    **** void spiEnableEnc28j60(void)
 274:hardware.c    **** {
 1398               	.LM99:
 1399               	.LFBB10:
 1400               	/* prologue: function */
 1401               	/* frame size = 0 */
 1402               	/* stack size = 0 */
 1403               	.L__stack_usage = 0
 275:hardware.c    **** #if ENC_SPI_CS_EN_MASK_OR != 0
 276:hardware.c    ****   ENC_SPI_CS_PORT |= ENC_SPI_CS_EN_MASK_OR;
 277:hardware.c    **** #endif
 278:hardware.c    **** #if ENC_SPI_CS_EN_MASK_AND != 0xFF
 279:hardware.c    ****   ENC_SPI_CS_PORT &= ENC_SPI_CS_EN_MASK_AND;
 1405               	.LM100:
 1406 0416 E0E2      		ldi r30,lo8(1568)
 1407 0418 F6E0      		ldi r31,hi8(1568)
 1408 041a 8481      		ldd r24,Z+4
 1409 041c 8E7F      		andi r24,lo8(-2)
 1410 041e 8483      		std Z+4,r24
 1411               	/* epilogue start */
 280:hardware.c    **** #endif
 281:hardware.c    **** }
 1413               	.LM101:
 1414 0420 0895      		ret
 1416               	.Lscope10:
 1418               		.stabd	78,0,0
 1420               		.weak	spiDisableEnc28j60
 1422               	spiDisableEnc28j60:
 1423               		.stabd	46,0,0
 282:hardware.c    **** 
 283:hardware.c    **** void spiDisableEnc28j60(void)
 284:hardware.c    **** {
 1425               	.LM102:
 1426               	.LFBB11:
 1427               	/* prologue: function */
 1428               	/* frame size = 0 */
 1429               	/* stack size = 0 */
 1430               	.L__stack_usage = 0
 285:hardware.c    **** #if ENC_SPI_CS_EN_MASK_OR != 0
 286:hardware.c    ****   ENC_SPI_CS_PORT &= (~ENC_SPI_CS_EN_MASK_OR);
 287:hardware.c    **** #endif
 288:hardware.c    **** #if ENC_SPI_CS_EN_MASK_AND != 0xFF
 289:hardware.c    ****   ENC_SPI_CS_PORT |= (~ENC_SPI_CS_EN_MASK_AND);
 1432               	.LM103:
 1433 0422 E0E2      		ldi r30,lo8(1568)
 1434 0424 F6E0      		ldi r31,hi8(1568)
 1435 0426 8481      		ldd r24,Z+4
 1436 0428 8160      		ori r24,lo8(1)
 1437 042a 8483      		std Z+4,r24
 1438               	/* epilogue start */
 290:hardware.c    **** #endif
 291:hardware.c    **** }
 1440               	.LM104:
 1441 042c 0895      		ret
 1443               	.Lscope11:
 1445               		.stabd	78,0,0
 1447               	.global	enableSpiSd
 1449               	enableSpiSd:
 1450               		.stabd	46,0,0
 292:hardware.c    **** 
 293:hardware.c    **** void enableSpiSd(void)
 294:hardware.c    **** {
 1452               	.LM105:
 1453               	.LFBB12:
 1454               	/* prologue: function */
 1455               	/* frame size = 0 */
 1456               	/* stack size = 0 */
 1457               	.L__stack_usage = 0
 295:hardware.c    **** #if SD_SPI_CS_EN_MASK_OR != 0
 296:hardware.c    ****   SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
 297:hardware.c    **** #endif
 298:hardware.c    **** #if SD_SPI_CS_EN_MASK_AND != 0xFF
 299:hardware.c    ****   SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
 1459               	.LM106:
 1460 042e E0E4      		ldi r30,lo8(1600)
 1461 0430 F6E0      		ldi r31,hi8(1600)
 1462 0432 8481      		ldd r24,Z+4
 1463 0434 8F7E      		andi r24,lo8(-17)
 1464 0436 8483      		std Z+4,r24
 1465               	/* epilogue start */
 300:hardware.c    **** #endif   
 301:hardware.c    **** }
 1467               	.LM107:
 1468 0438 0895      		ret
 1470               	.Lscope12:
 1472               		.stabd	78,0,0
 1474               	.global	disableSpiSd
 1476               	disableSpiSd:
 1477               		.stabd	46,0,0
 302:hardware.c    **** 
 303:hardware.c    **** void disableSpiSd(void)
 304:hardware.c    **** {
 1479               	.LM108:
 1480               	.LFBB13:
 1481               	/* prologue: function */
 1482               	/* frame size = 0 */
 1483               	/* stack size = 0 */
 1484               	.L__stack_usage = 0
 305:hardware.c    **** #if SD_SPI_CS_EN_MASK_OR != 0
 306:hardware.c    ****   SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
 307:hardware.c    **** #endif
 308:hardware.c    **** #if SD_SPI_CS_EN_MASK_AND != 0xFF
 309:hardware.c    ****   SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
 1486               	.LM109:
 1487 043a E0E4      		ldi r30,lo8(1600)
 1488 043c F6E0      		ldi r31,hi8(1600)
 1489 043e 8481      		ldd r24,Z+4
 1490 0440 8061      		ori r24,lo8(16)
 1491 0442 8483      		std Z+4,r24
 1492               	/* epilogue start */
 310:hardware.c    **** #endif  
 311:hardware.c    **** }
 1494               	.LM110:
 1495 0444 0895      		ret
 1497               	.Lscope13:
 1499               		.stabd	78,0,0
 1501               		.weak	enableSpiMPC23S17
 1503               	enableSpiMPC23S17:
 1504               		.stabd	46,0,0
 312:hardware.c    **** 
 313:hardware.c    **** void enableSpiMPC23S17(void)
 314:hardware.c    **** {
 1506               	.LM111:
 1507               	.LFBB14:
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 0 */
 1511               	.L__stack_usage = 0
 315:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_OR != 0
 316:hardware.c    ****   MCP23S17_SPI_CS_PORT |= MCP23S17_SPI_CS_EN_MASK_OR;
 317:hardware.c    **** #endif
 318:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_AND != 0xFF
 319:hardware.c    ****   MPC23S17_SPI_CS_PORT &= MPC23S17_SPI_CS_EN_MASK_AND;
 1513               	.LM112:
 1514 0446 E0E8      		ldi r30,lo8(1664)
 1515 0448 F6E0      		ldi r31,hi8(1664)
 1516 044a 8481      		ldd r24,Z+4
 1517 044c 8F77      		andi r24,lo8(127)
 1518 044e 8483      		std Z+4,r24
 1519               	/* epilogue start */
 320:hardware.c    **** #endif
 321:hardware.c    **** }
 1521               	.LM113:
 1522 0450 0895      		ret
 1524               	.Lscope14:
 1526               		.stabd	78,0,0
 1528               		.weak	disableSpiMPC23S17
 1530               	disableSpiMPC23S17:
 1531               		.stabd	46,0,0
 322:hardware.c    **** 
 323:hardware.c    **** void disableSpiMPC23S17(void)
 324:hardware.c    **** {
 1533               	.LM114:
 1534               	.LFBB15:
 1535               	/* prologue: function */
 1536               	/* frame size = 0 */
 1537               	/* stack size = 0 */
 1538               	.L__stack_usage = 0
 325:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_OR != 0
 326:hardware.c    ****   MCP23S17_SPI_CS_PORT &= (~MCP23S17_SPI_CS_EN_MASK_OR);
 327:hardware.c    **** #endif
 328:hardware.c    **** #if MCP23S17_SPI_CS_EN_MASK_AND != 0xFF
 329:hardware.c    ****   MPC23S17_SPI_CS_PORT |= (~MPC23S17_SPI_CS_EN_MASK_AND);
 1540               	.LM115:
 1541 0452 E0E8      		ldi r30,lo8(1664)
 1542 0454 F6E0      		ldi r31,hi8(1664)
 1543 0456 8481      		ldd r24,Z+4
 1544 0458 8068      		ori r24,lo8(-128)
 1545 045a 8483      		std Z+4,r24
 1546               	/* epilogue start */
 330:hardware.c    **** #endif
 331:hardware.c    **** }
 1548               	.LM116:
 1549 045c 0895      		ret
 1551               	.Lscope15:
 1553               		.stabd	78,0,0
 1555               		.weak	enableSpiMCP3008
 1557               	enableSpiMCP3008:
 1558               		.stabd	46,0,0
 332:hardware.c    **** 
 333:hardware.c    **** #define MCP3008_SPCR_OR_MASK  0b00000011
 334:hardware.c    **** //((1<<SPR1)|(1<<SPR0))
 335:hardware.c    **** void enableSpiMCP3008(void)
 336:hardware.c    **** {
 1560               	.LM117:
 1561               	.LFBB16:
 1562               	/* prologue: function */
 1563               	/* frame size = 0 */
 1564               	/* stack size = 0 */
 1565               	.L__stack_usage = 0
 337:hardware.c    ****   SPID.CTRL|= MCP3008_SPCR_OR_MASK;
 1567               	.LM118:
 1568 045e E0EC      		ldi r30,lo8(2496)
 1569 0460 F9E0      		ldi r31,hi8(2496)
 1570 0462 8081      		ld r24,Z
 1571 0464 8360      		ori r24,lo8(3)
 1572 0466 8083      		st Z,r24
 338:hardware.c    **** #if MCP3008_SPI_CS_EN_MASK_OR != 0
 339:hardware.c    ****   MCP3008_SPI_CS_PORT |= MCP3008_SPI_CS_EN_MASK_OR;
 340:hardware.c    **** #endif
 341:hardware.c    **** #if MCP3008_SPI_CS_EN_MASK_AND != 0xFF
 342:hardware.c    ****   MCP3008_SPI_CS_PORT &= MCP3008_SPI_CS_EN_MASK_AND;
 1574               	.LM119:
 1575 0468 E0E8      		ldi r30,lo8(1664)
 1576 046a F6E0      		ldi r31,hi8(1664)
 1577 046c 8481      		ldd r24,Z+4
 1578 046e 8F7B      		andi r24,lo8(-65)
 1579 0470 8483      		std Z+4,r24
 1580               	/* epilogue start */
 343:hardware.c    **** #endif  
 344:hardware.c    **** 
 345:hardware.c    **** }
 1582               	.LM120:
 1583 0472 0895      		ret
 1585               	.Lscope16:
 1587               		.stabd	78,0,0
 1589               		.weak	disableSpiMCP3008
 1591               	disableSpiMCP3008:
 1592               		.stabd	46,0,0
 346:hardware.c    **** 
 347:hardware.c    **** void disableSpiMCP3008(void)
 348:hardware.c    **** {
 1594               	.LM121:
 1595               	.LFBB17:
 1596               	/* prologue: function */
 1597               	/* frame size = 0 */
 1598               	/* stack size = 0 */
 1599               	.L__stack_usage = 0
 349:hardware.c    ****   //SPCR
 350:hardware.c    ****   SPID.CTRL&= ~MCP3008_SPCR_OR_MASK;
 1601               	.LM122:
 1602 0474 E0EC      		ldi r30,lo8(2496)
 1603 0476 F9E0      		ldi r31,hi8(2496)
 1604 0478 8081      		ld r24,Z
 1605 047a 8C7F      		andi r24,lo8(-4)
 1606 047c 8083      		st Z,r24
 351:hardware.c    ****   #if MCP3008_SPI_CS_EN_MASK_OR != 0
 352:hardware.c    ****   MCP3008_SPI_CS_PORT &= (~MCP3008_SPI_CS_EN_MASK_OR);
 353:hardware.c    **** #endif
 354:hardware.c    **** #if MCP3008_SPI_CS_EN_MASK_AND != 0xFF
 355:hardware.c    ****   MCP3008_SPI_CS_PORT |= (~MCP3008_SPI_CS_EN_MASK_AND);
 1608               	.LM123:
 1609 047e E0E8      		ldi r30,lo8(1664)
 1610 0480 F6E0      		ldi r31,hi8(1664)
 1611 0482 8481      		ldd r24,Z+4
 1612 0484 8064      		ori r24,lo8(64)
 1613 0486 8483      		std Z+4,r24
 1614               	/* epilogue start */
 356:hardware.c    **** #endif
 357:hardware.c    **** }
 1616               	.LM124:
 1617 0488 0895      		ret
 1619               	.Lscope17:
 1621               		.stabd	78,0,0
 1623               	.global	enableSpiMCP4150
 1625               	enableSpiMCP4150:
 1626               		.stabd	46,0,0
 358:hardware.c    **** 
 359:hardware.c    **** 
 360:hardware.c    **** #define MCP4150_SPCR_OR_MASK  0b00000011
 361:hardware.c    **** //((1<<SPR1)|(1<<SPR0))
 362:hardware.c    **** void enableSpiMCP4150(void)
 363:hardware.c    **** {
 1628               	.LM125:
 1629               	.LFBB18:
 1630               	/* prologue: function */
 1631               	/* frame size = 0 */
 1632               	/* stack size = 0 */
 1633               	.L__stack_usage = 0
 364:hardware.c    ****  // SPCR
 365:hardware.c    ****  SPID.CTRL|= MCP4150_SPCR_OR_MASK;
 1635               	.LM126:
 1636 048a E0EC      		ldi r30,lo8(2496)
 1637 048c F9E0      		ldi r31,hi8(2496)
 1638 048e 8081      		ld r24,Z
 1639 0490 8360      		ori r24,lo8(3)
 1640 0492 8083      		st Z,r24
 366:hardware.c    **** #if MCP4150_SPI_CS_EN_MASK_OR != 0
 367:hardware.c    ****   MCP4150_SPI_CS_PORT |= MCP4150_SPI_CS_EN_MASK_OR;
 368:hardware.c    **** #endif
 369:hardware.c    **** #if MCP4150_SPI_CS_EN_MASK_AND != 0xFF
 370:hardware.c    ****   MCP4150_SPI_CS_PORT &= MCP4150_SPI_CS_EN_MASK_AND;
 1642               	.LM127:
 1643 0494 E0E8      		ldi r30,lo8(1664)
 1644 0496 F6E0      		ldi r31,hi8(1664)
 1645 0498 8481      		ldd r24,Z+4
 1646 049a 8F7B      		andi r24,lo8(-65)
 1647 049c 8483      		std Z+4,r24
 1648               	/* epilogue start */
 371:hardware.c    **** #endif  
 372:hardware.c    **** }
 1650               	.LM128:
 1651 049e 0895      		ret
 1653               	.Lscope18:
 1655               		.stabd	78,0,0
 1657               	.global	disableSpiMCP4150
 1659               	disableSpiMCP4150:
 1660               		.stabd	46,0,0
 373:hardware.c    **** void disableSpiMCP4150(void) 
 374:hardware.c    **** {
 1662               	.LM129:
 1663               	.LFBB19:
 1664               	/* prologue: function */
 1665               	/* frame size = 0 */
 1666               	/* stack size = 0 */
 1667               	.L__stack_usage = 0
 375:hardware.c    ****   //SPCR
 376:hardware.c    ****   SPID.CTRL&= ~MCP4150_SPCR_OR_MASK;
 1669               	.LM130:
 1670 04a0 E0EC      		ldi r30,lo8(2496)
 1671 04a2 F9E0      		ldi r31,hi8(2496)
 1672 04a4 8081      		ld r24,Z
 1673 04a6 8C7F      		andi r24,lo8(-4)
 1674 04a8 8083      		st Z,r24
 377:hardware.c    ****   #if MCP4150_SPI_CS_EN_MASK_OR != 0
 378:hardware.c    ****   MCP4150_SPI_CS_PORT &= (~MCP4150_SPI_CS_EN_MASK_OR);
 379:hardware.c    **** #endif
 380:hardware.c    **** #if MCP4150_SPI_CS_EN_MASK_AND != 0xFF
 381:hardware.c    ****   MCP4150_SPI_CS_PORT |= (~MCP4150_SPI_CS_EN_MASK_AND);
 1676               	.LM131:
 1677 04aa E0E8      		ldi r30,lo8(1664)
 1678 04ac F6E0      		ldi r31,hi8(1664)
 1679 04ae 8481      		ldd r24,Z+4
 1680 04b0 8064      		ori r24,lo8(64)
 1681 04b2 8483      		std Z+4,r24
 1682               	/* epilogue start */
 382:hardware.c    **** #endif  
 383:hardware.c    **** }
 1684               	.LM132:
 1685 04b4 0895      		ret
 1687               	.Lscope19:
 1689               		.stabd	78,0,0
 1691               		.weak	spiEnableDS1305
 1693               	spiEnableDS1305:
 1694               		.stabd	46,0,0
 384:hardware.c    **** 
 385:hardware.c    **** #define DS_SPCR_OR_MASK 0b00000101
 386:hardware.c    **** //((1<<CPHA)|(1<<SPR0))
 387:hardware.c    **** 
 388:hardware.c    **** void spiEnableDS1305(void)
 389:hardware.c    **** {
 1696               	.LM133:
 1697               	.LFBB20:
 1698               	/* prologue: function */
 1699               	/* frame size = 0 */
 1700               	/* stack size = 0 */
 1701               	.L__stack_usage = 0
 390:hardware.c    ****   //SPCR 
 391:hardware.c    ****   SPID.CTRL|= DS_SPCR_OR_MASK;
 1703               	.LM134:
 1704 04b6 E0EC      		ldi r30,lo8(2496)
 1705 04b8 F9E0      		ldi r31,hi8(2496)
 1706 04ba 8081      		ld r24,Z
 1707 04bc 8560      		ori r24,lo8(5)
 1708 04be 8083      		st Z,r24
 392:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_OR != 0
 393:hardware.c    ****   DS1305_SPI_CS_PORT |= DS1305_SPI_CS_EN_MASK_OR;
 1710               	.LM135:
 1711 04c0 E0E8      		ldi r30,lo8(1664)
 1712 04c2 F6E0      		ldi r31,hi8(1664)
 1713 04c4 8481      		ldd r24,Z+4
 1714 04c6 8062      		ori r24,lo8(32)
 1715 04c8 8483      		std Z+4,r24
 1716               	/* epilogue start */
 394:hardware.c    **** #endif
 395:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_AND != 0xFF
 396:hardware.c    ****   DS1305_SPI_CS_PORT &= DS1305_SPI_CS_EN_MASK_AND;
 397:hardware.c    **** #endif
 398:hardware.c    **** }
 1718               	.LM136:
 1719 04ca 0895      		ret
 1721               	.Lscope20:
 1723               		.stabd	78,0,0
 1725               		.weak	spiDisableDS1305
 1727               	spiDisableDS1305:
 1728               		.stabd	46,0,0
 399:hardware.c    **** 
 400:hardware.c    **** void spiDisableDS1305(void)
 401:hardware.c    **** {
 1730               	.LM137:
 1731               	.LFBB21:
 1732               	/* prologue: function */
 1733               	/* frame size = 0 */
 1734               	/* stack size = 0 */
 1735               	.L__stack_usage = 0
 402:hardware.c    ****   //SPCR
 403:hardware.c    ****   SPID.CTRL &= (~(DS_SPCR_OR_MASK));
 1737               	.LM138:
 1738 04cc E0EC      		ldi r30,lo8(2496)
 1739 04ce F9E0      		ldi r31,hi8(2496)
 1740 04d0 8081      		ld r24,Z
 1741 04d2 8A7F      		andi r24,lo8(-6)
 1742 04d4 8083      		st Z,r24
 404:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_OR != 0
 405:hardware.c    ****   DS1305_SPI_CS_PORT &= (~(DS1305_SPI_CS_EN_MASK_OR));
 1744               	.LM139:
 1745 04d6 E0E8      		ldi r30,lo8(1664)
 1746 04d8 F6E0      		ldi r31,hi8(1664)
 1747 04da 8481      		ldd r24,Z+4
 1748 04dc 8F7D      		andi r24,lo8(-33)
 1749 04de 8483      		std Z+4,r24
 1750               	/* epilogue start */
 406:hardware.c    **** #endif
 407:hardware.c    **** #if DS1305_SPI_CS_EN_MASK_AND != 0xFF
 408:hardware.c    ****   DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
 409:hardware.c    **** #endif  
 410:hardware.c    **** }
 1752               	.LM140:
 1753 04e0 0895      		ret
 1755               	.Lscope21:
 1757               		.stabd	78,0,0
 1759               	.global	__vector_87
 1761               	__vector_87:
 1762               		.stabd	46,0,0
 411:hardware.c    **** 
 412:hardware.c    **** ISR(SPID_INT_vect)
 413:hardware.c    **** {
 1764               	.LM141:
 1765               	.LFBB22:
 1766 04e2 1F92      		push __zero_reg__
 1767 04e4 0F92      		push r0
 1768 04e6 0FB6      		in r0,__SREG__
 1769 04e8 0F92      		push r0
 1770 04ea 08B6      		in r0,56-0
 1771 04ec 0F92      		push r0
 1772 04ee 09B6      		in r0,57-0
 1773 04f0 0F92      		push r0
 1774 04f2 0BB6      		in r0,59-0
 1775 04f4 0F92      		push r0
 1776 04f6 1124      		clr __zero_reg__
 1777 04f8 18BE      		out 56-0,__zero_reg__
 1778 04fa 19BE      		out 57-0,__zero_reg__
 1779 04fc 1BBE      		out 59-0,__zero_reg__
 1780 04fe 2F93      		push r18
 1781 0500 3F93      		push r19
 1782 0502 4F93      		push r20
 1783 0504 5F93      		push r21
 1784 0506 6F93      		push r22
 1785 0508 7F93      		push r23
 1786 050a 8F93      		push r24
 1787 050c 9F93      		push r25
 1788 050e AF93      		push r26
 1789 0510 BF93      		push r27
 1790 0512 EF93      		push r30
 1791 0514 FF93      		push r31
 1792               	/* prologue: Signal */
 1793               	/* frame size = 0 */
 1794               	/* stack size = 16 */
 1795               	.L__stack_usage = 16
 414:hardware.c    ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
 415:hardware.c    **** 
 416:hardware.c    ****   static uint8_t data;
 417:hardware.c    ****   data = SPID.DATA;//SPDR;
 1797               	.LM142:
 1798 0516 8091 C309 		lds r24,2499
 1799 051a 8093 0000 		sts data.5159,r24
 418:hardware.c    ****   
 419:hardware.c    ****   xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
 1801               	.LM143:
 1802 051e 8091 0000 		lds r24,xSpiRx
 1803 0522 9091 0000 		lds r25,xSpiRx+1
 1804 0526 60E0      		ldi r22,lo8(data.5159)
 1805 0528 70E0      		ldi r23,hi8(data.5159)
 1806 052a 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.5158)
 1807 052c 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.5158)
 1808 052e 20E0      		ldi r18,lo8(0)
 1809 0530 0E94 0000 		call xQueueGenericSendFromISR
 420:hardware.c    **** 
 421:hardware.c    ****   if( xHigherPriorityTaskWoken )
 1811               	.LM144:
 1812 0534 8091 0000 		lds r24,xHigherPriorityTaskWoken.5158
 1813 0538 8823      		tst r24
 1814 053a 01F0      		breq .L40
 422:hardware.c    ****   {
 423:hardware.c    ****     taskYIELD();
 1816               	.LM145:
 1817 053c 0E94 0000 		call vPortYield
 1818               	.L40:
 1819               	/* epilogue start */
 424:hardware.c    ****   }
 425:hardware.c    ****   
 426:hardware.c    ****   //clear SPI interrupt SPI |= 1;
 427:hardware.c    **** }
 1821               	.LM146:
 1822 0540 FF91      		pop r31
 1823 0542 EF91      		pop r30
 1824 0544 BF91      		pop r27
 1825 0546 AF91      		pop r26
 1826 0548 9F91      		pop r25
 1827 054a 8F91      		pop r24
 1828 054c 7F91      		pop r23
 1829 054e 6F91      		pop r22
 1830 0550 5F91      		pop r21
 1831 0552 4F91      		pop r20
 1832 0554 3F91      		pop r19
 1833 0556 2F91      		pop r18
 1834 0558 0F90      		pop r0
 1835 055a 0BBE      		out 59-0,r0
 1836 055c 0F90      		pop r0
 1837 055e 09BE      		out 57-0,r0
 1838 0560 0F90      		pop r0
 1839 0562 08BE      		out 56-0,r0
 1840 0564 0F90      		pop r0
 1841 0566 0FBE      		out __SREG__,r0
 1842 0568 0F90      		pop r0
 1843 056a 1F90      		pop __zero_reg__
 1844 056c 1895      		reti
 1850               	.Lscope22:
 1852               		.stabd	78,0,0
 1854               	.global	__vector_24
 1856               	__vector_24:
 1857               		.stabd	46,0,0
 428:hardware.c    **** ISR(SPIC_INT_vect)
 429:hardware.c    **** {
 1859               	.LM147:
 1860               	.LFBB23:
 1861 056e 1F92      		push __zero_reg__
 1862 0570 0F92      		push r0
 1863 0572 0FB6      		in r0,__SREG__
 1864 0574 0F92      		push r0
 1865 0576 08B6      		in r0,56-0
 1866 0578 0F92      		push r0
 1867 057a 09B6      		in r0,57-0
 1868 057c 0F92      		push r0
 1869 057e 0BB6      		in r0,59-0
 1870 0580 0F92      		push r0
 1871 0582 1124      		clr __zero_reg__
 1872 0584 18BE      		out 56-0,__zero_reg__
 1873 0586 19BE      		out 57-0,__zero_reg__
 1874 0588 1BBE      		out 59-0,__zero_reg__
 1875 058a 2F93      		push r18
 1876 058c 3F93      		push r19
 1877 058e 4F93      		push r20
 1878 0590 5F93      		push r21
 1879 0592 6F93      		push r22
 1880 0594 7F93      		push r23
 1881 0596 8F93      		push r24
 1882 0598 9F93      		push r25
 1883 059a AF93      		push r26
 1884 059c BF93      		push r27
 1885 059e EF93      		push r30
 1886 05a0 FF93      		push r31
 1887               	/* prologue: Signal */
 1888               	/* frame size = 0 */
 1889               	/* stack size = 16 */
 1890               	.L__stack_usage = 16
 430:hardware.c    ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
 431:hardware.c    **** 
 432:hardware.c    ****   static uint8_t data;
 433:hardware.c    ****   data = SPIC.DATA;//SPDR;
 1892               	.LM148:
 1893 05a2 8091 C308 		lds r24,2243
 1894 05a6 8093 0000 		sts data.5166,r24
 434:hardware.c    ****   
 435:hardware.c    ****   xQueueSendFromISR(xSpiRxEnc, &data, &xHigherPriorityTaskWoken);
 1896               	.LM149:
 1897 05aa 8091 0000 		lds r24,xSpiRxEnc
 1898 05ae 9091 0000 		lds r25,xSpiRxEnc+1
 1899 05b2 60E0      		ldi r22,lo8(data.5166)
 1900 05b4 70E0      		ldi r23,hi8(data.5166)
 1901 05b6 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.5165)
 1902 05b8 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.5165)
 1903 05ba 20E0      		ldi r18,lo8(0)
 1904 05bc 0E94 0000 		call xQueueGenericSendFromISR
 436:hardware.c    **** 
 437:hardware.c    ****   if( xHigherPriorityTaskWoken )
 1906               	.LM150:
 1907 05c0 8091 0000 		lds r24,xHigherPriorityTaskWoken.5165
 1908 05c4 8823      		tst r24
 1909 05c6 01F0      		breq .L42
 438:hardware.c    ****   {
 439:hardware.c    ****     taskYIELD();
 1911               	.LM151:
 1912 05c8 0E94 0000 		call vPortYield
 1913               	.L42:
 1914               	/* epilogue start */
 440:hardware.c    ****   }
 441:hardware.c    ****   
 442:hardware.c    ****   //clear SPI interrupt SPI |= 1;
 443:hardware.c    **** }
 1916               	.LM152:
 1917 05cc FF91      		pop r31
 1918 05ce EF91      		pop r30
 1919 05d0 BF91      		pop r27
 1920 05d2 AF91      		pop r26
 1921 05d4 9F91      		pop r25
 1922 05d6 8F91      		pop r24
 1923 05d8 7F91      		pop r23
 1924 05da 6F91      		pop r22
 1925 05dc 5F91      		pop r21
 1926 05de 4F91      		pop r20
 1927 05e0 3F91      		pop r19
 1928 05e2 2F91      		pop r18
 1929 05e4 0F90      		pop r0
 1930 05e6 0BBE      		out 59-0,r0
 1931 05e8 0F90      		pop r0
 1932 05ea 09BE      		out 57-0,r0
 1933 05ec 0F90      		pop r0
 1934 05ee 08BE      		out 56-0,r0
 1935 05f0 0F90      		pop r0
 1936 05f2 0FBE      		out __SREG__,r0
 1937 05f4 0F90      		pop r0
 1938 05f6 1F90      		pop __zero_reg__
 1939 05f8 1895      		reti
 1945               	.Lscope23:
 1947               		.stabd	78,0,0
 1948               	.global	statusLockerSensDescStr
 1949               		.section	.progmem.data,"a",@progbits
 1952               	statusLockerSensDescStr:
 1953 0000 206C 6F63 		.string	" locker %d"
 1953      6B65 7220 
 1953      2564 00
 1954               	.global	statusLockerOpenStr
 1957               	statusLockerOpenStr:
 1958 000b 206F 7065 		.string	" open   "
 1958      6E20 2020 
 1958      00
 1959               	.global	statusLockerCloseStr
 1962               	statusLockerCloseStr:
 1963 0014 206C 6F63 		.string	" locked "
 1963      6B65 6420 
 1963      00
 1964               	.global	statusLockerSensAdditionalDescStr
 1967               	statusLockerSensAdditionalDescStr:
 1968 001d 2028 7468 		.string	" (threshold %d, AC value %d)\r\n"
 1968      7265 7368 
 1968      6F6C 6420 
 1968      2564 2C20 
 1968      4143 2076 
 1969               		.comm wwwport,1,1
 1970               		.comm klastry,128,1
 1971               		.comm rollers,2,1
 1972               		.comm xSemaphoreRs485,2,1
 1973               		.comm xSemaphoreSpiSS,2,1
 1974               		.comm nicState,14,1
 1975               		.comm plen,2,1
 1976               		.comm IpMyConfig,15,1
 1977               		.comm arpDebug,2,1
 1978               		.comm arpDebugLevel,1,1
 1979               		.comm icmpDebug,2,1
 1980               		.comm icmpDebugLevel,1,1
 1981               		.comm udpSocket,2,1
 1982               		.comm udpDbgStream,2,1
 1983               		.comm udpDbgLevel,1,1
 1984               		.comm tcpDebugStream,2,1
 1985               		.comm tcpDebugLevel,1,1
 1986               		.comm sockets,2,1
 1987               		.comm lockSensors,2,1
 1988               		.comm czasRtc,7,1
 1989               		.comm portA,1,1
 1990               		.comm portB,1,1
 1991               		.comm xSpiRx,2,1
 1992               		.comm xSpiRxEnc,2,1
 1993               		.lcomm data.5166,1
 1994               		.lcomm xHigherPriorityTaskWoken.5165,1
 1995               		.lcomm data.5159,1
 1996               		.lcomm xHigherPriorityTaskWoken.5158,1
 2025               		.text
 2027               	.Letext0:
 2028               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 hardware.c
     /tmp/ccV74uVJ.s:2      *ABS*:0000003f __SREG__
     /tmp/ccV74uVJ.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccV74uVJ.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccV74uVJ.s:5      *ABS*:00000034 __CCP__
     /tmp/ccV74uVJ.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccV74uVJ.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccV74uVJ.s:563    .text:00000000 hardwareInit
                            *COM*:00000002 xSpiRx
     /tmp/ccV74uVJ.s:670    .text:00000060 LockersMemInit
                            *COM*:00000002 lockSensors
     /tmp/ccV74uVJ.s:698    .text:00000072 printLockers
     /tmp/ccV74uVJ.s:1952   .progmem.data:00000000 statusLockerSensDescStr
     /tmp/ccV74uVJ.s:1967   .progmem.data:0000001d statusLockerSensAdditionalDescStr
     /tmp/ccV74uVJ.s:1962   .progmem.data:00000014 statusLockerCloseStr
     /tmp/ccV74uVJ.s:1957   .progmem.data:0000000b statusLockerOpenStr
     /tmp/ccV74uVJ.s:912    .text:000001ac checkLockerSensors
     /tmp/ccV74uVJ.s:1147   .text:00000332 spiSend
     /tmp/ccV74uVJ.s:1196   .text:00000364 spiSendENC
                            *COM*:00000002 xSpiRxEnc
     /tmp/ccV74uVJ.s:1245   .text:00000396 spiSendSpinBlock
     /tmp/ccV74uVJ.s:1285   .text:000003b4 spiSendSpinBlockENC
     /tmp/ccV74uVJ.s:1332   .text:000003da disableAllSpiDevices
     /tmp/ccV74uVJ.s:1395   .text:00000416 spiEnableEnc28j60
     /tmp/ccV74uVJ.s:1422   .text:00000422 spiDisableEnc28j60
     /tmp/ccV74uVJ.s:1449   .text:0000042e enableSpiSd
     /tmp/ccV74uVJ.s:1476   .text:0000043a disableSpiSd
     /tmp/ccV74uVJ.s:1503   .text:00000446 enableSpiMPC23S17
     /tmp/ccV74uVJ.s:1530   .text:00000452 disableSpiMPC23S17
     /tmp/ccV74uVJ.s:1557   .text:0000045e enableSpiMCP3008
     /tmp/ccV74uVJ.s:1591   .text:00000474 disableSpiMCP3008
     /tmp/ccV74uVJ.s:1625   .text:0000048a enableSpiMCP4150
     /tmp/ccV74uVJ.s:1659   .text:000004a0 disableSpiMCP4150
     /tmp/ccV74uVJ.s:1693   .text:000004b6 spiEnableDS1305
     /tmp/ccV74uVJ.s:1727   .text:000004cc spiDisableDS1305
     /tmp/ccV74uVJ.s:1761   .text:000004e2 __vector_87
     /tmp/ccV74uVJ.s:1994   .bss:00000002 data.5159
     /tmp/ccV74uVJ.s:1995   .bss:00000003 xHigherPriorityTaskWoken.5158
     /tmp/ccV74uVJ.s:1856   .text:0000056e __vector_24
                             .bss:00000000 data.5166
     /tmp/ccV74uVJ.s:1993   .bss:00000001 xHigherPriorityTaskWoken.5165
                            *COM*:00000001 wwwport
                            *COM*:00000080 klastry
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:0000000e nicState
                            *COM*:00000002 plen
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpSocket
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000007 czasRtc
                            *COM*:00000001 portA
                            *COM*:00000001 portB

UNDEFINED SYMBOLS
xQueueCreate
xmalloc
fprintf_P
MPC23s17SetBitsOnPortA
vTaskDelay
MCP3008_getSampleSingle
MPC23s17ClearBitsOnPortA
xQueueGenericReceive
xQueueGenericSendFromISR
vPortYield
__do_clear_bss
