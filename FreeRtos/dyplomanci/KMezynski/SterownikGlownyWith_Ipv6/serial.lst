   1               		.file	"serial.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 280               	.global	initQueueStreamUSB
 282               	initQueueStreamUSB:
 283               		.stabd	46,0,0
   1:serial.c      **** #include <stdlib.h>
   2:serial.c      **** #include <avr/interrupt.h>
   3:serial.c      **** #include "FreeRTOS.h"
   4:serial.c      **** #include "queue.h"
   5:serial.c      **** #include "task.h"
   6:serial.c      **** #include "serial.h"
   7:serial.c      **** #include "hardware.h"
   8:serial.c      **** 
   9:serial.c      **** #define debug 1
  10:serial.c      **** 
  11:serial.c      **** /*-----------------------------------------------------------*/
  12:serial.c      **** 
  13:serial.c      **** void initQueueStreamUSB(FILE *stream)
  14:serial.c      **** {
 285               	.LM0:
 286               	.LFBB1:
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289 0000 FC01      		movw r30,r24
  15:serial.c      ****   fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
 291               	.LM1:
 292 0002 80E0      		ldi r24,lo8(gs(VtyPutChar))
 293 0004 90E0      		ldi r25,hi8(gs(VtyPutChar))
 294 0006 9187      		std Z+9,r25
 295 0008 8087      		std Z+8,r24
 296 000a 80E0      		ldi r24,lo8(gs(VtyGetChar))
 297 000c 90E0      		ldi r25,hi8(gs(VtyGetChar))
 298 000e 9387      		std Z+11,r25
 299 0010 8287      		std Z+10,r24
 300 0012 83E0      		ldi r24,lo8(3)
 301 0014 8383      		std Z+3,r24
  16:serial.c      ****   fdev_set_udata(stream, NULL);
 303               	.LM2:
 304 0016 1586      		std Z+13,__zero_reg__
 305 0018 1486      		std Z+12,__zero_reg__
 306               	/* epilogue start */
  17:serial.c      ****   return;
  18:serial.c      **** }
 308               	.LM3:
 309 001a 0895      		ret
 311               	.Lscope1:
 313               		.stabd	78,0,0
 315               	.global	__vector_20
 317               	__vector_20:
 318               		.stabd	46,0,0
  19:serial.c      **** 
  20:serial.c      **** int VtyGetChar(FILE *stream)
  21:serial.c      **** {
  22:serial.c      ****   stream = NULL;
  23:serial.c      ****   uint8_t c;
  24:serial.c      ****   if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
  25:serial.c      ****     return EOF;
  26:serial.c      ****   return c;
  27:serial.c      **** }
  28:serial.c      **** 
  29:serial.c      **** int VtyPutChar(char c, FILE *stream)
  30:serial.c      **** {
  31:serial.c      ****   stream = NULL;
  32:serial.c      ****   uartVtySendByte(c);
  33:serial.c      ****   return 0;
  34:serial.c      **** }
  35:serial.c      **** 
  36:serial.c      **** void xSerialPortInitMinimal(void)
  37:serial.c      **** {
  38:serial.c      ****   portENTER_CRITICAL();
  39:serial.c      ****   {
  40:serial.c      ****     xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
  41:serial.c      ****     xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
  42:serial.c      ****     xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
  43:serial.c      ****     xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
  44:serial.c      ****     
  45:serial.c      ****     vSemaphoreCreateBinary(xSemaphoreRs485); 
  46:serial.c      ****   }
  47:serial.c      ****   portEXIT_CRITICAL();
  48:serial.c      ****   
  49:serial.c      ****   UBRR0L = 7;
  50:serial.c      ****   UBRR0H = 0;
  51:serial.c      **** 
  52:serial.c      ****   UBRR1L = 7;
  53:serial.c      ****   UBRR1H = 0;
  54:serial.c      **** 
  55:serial.c      ****   UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
  56:serial.c      ****   UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
  57:serial.c      ****   UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
  58:serial.c      ****   UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
  59:serial.c      ****   return;
  60:serial.c      **** }
  61:serial.c      **** 
  62:serial.c      **** /*-----------------------------------------------------------*/
  63:serial.c      **** ISR(USART0_RX_vect)
  64:serial.c      **** {
  65:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  66:serial.c      ****   signed portCHAR cChar;
  67:serial.c      **** 
  68:serial.c      ****   cChar = UDR0;
  69:serial.c      **** 
  70:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
  71:serial.c      **** 
  72:serial.c      **** //  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  73:serial.c      ****   xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
  74:serial.c      ****   if( xHigherPriorityTaskWoken )
  75:serial.c      ****   {
  76:serial.c      ****     taskYIELD();
  77:serial.c      ****   }
  78:serial.c      **** }
  79:serial.c      **** 
  80:serial.c      **** void uartRs485SendByte(uint8_t data)
  81:serial.c      **** {
  82:serial.c      ****   xQueueSend(xRs485Tx, &data, portMAX_DELAY);
  83:serial.c      ****   vInterruptRs485On();
  84:serial.c      **** }
  85:serial.c      **** 
  86:serial.c      **** uint8_t rs485Receive(uint8_t *c, uint8_t timeout)
  87:serial.c      **** {
  88:serial.c      ****   return xQueueReceive(xRs485Rec, c, timeout);
  89:serial.c      **** }
  90:serial.c      **** 
  91:serial.c      **** ISR(USART0_UDRE_vect)
  92:serial.c      **** {
  93:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  94:serial.c      ****   static char data;
  95:serial.c      ****   if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
  96:serial.c      ****   {
  97:serial.c      ****     Rs485TxStart();
  98:serial.c      ****     UDR0 = data; 
  99:serial.c      ****   }
 100:serial.c      ****   else
 101:serial.c      ****   {
 102:serial.c      ****     xHigherPriorityTaskWoken = pdFALSE;
 103:serial.c      ****     vInterruptRs485Off();
 104:serial.c      ****   }
 105:serial.c      ****   if( xHigherPriorityTaskWoken )
 106:serial.c      ****   {
 107:serial.c      ****     taskYIELD();
 108:serial.c      ****   }
 109:serial.c      **** }
 110:serial.c      **** 
 111:serial.c      **** ISR(USART0_TX_vect)
 112:serial.c      **** {
 320               	.LM4:
 321               	.LFBB2:
 322 001c 1F92      		push __zero_reg__
 323 001e 0F92      		push r0
 324 0020 0FB6      		in r0,__SREG__
 325 0022 0F92      		push r0
 326 0024 1124      		clr __zero_reg__
 327 0026 8F93      		push r24
 328               	/* prologue: Signal */
 329               	/* frame size = 0 */
 113:serial.c      ****   if (!vIsInterruptRs485On())
 331               	.LM5:
 332 0028 5599      		sbic 42-32,5
 333 002a 00C0      		rjmp .L5
 114:serial.c      ****     Rs485TxStop();
 335               	.LM6:
 336 002c 8091 6500 		lds r24,101
 337 0030 8F7E      		andi r24,lo8(-17)
 338 0032 8093 6500 		sts 101,r24
 339               	.L5:
 340               	/* epilogue start */
 115:serial.c      **** }
 342               	.LM7:
 343 0036 8F91      		pop r24
 344 0038 0F90      		pop r0
 345 003a 0FBE      		out __SREG__,r0
 346 003c 0F90      		pop r0
 347 003e 1F90      		pop __zero_reg__
 348 0040 1895      		reti
 350               	.Lscope2:
 352               		.stabd	78,0,0
 354               	.global	InterruptVtyOn
 356               	InterruptVtyOn:
 357               		.stabd	46,0,0
 116:serial.c      **** 
 117:serial.c      **** uint8_t flushRs485RecBuffer(void)
 118:serial.c      **** {
 119:serial.c      ****   uint8_t temp;
 120:serial.c      ****   uint8_t wynik = 0;
 121:serial.c      ****   while(xQueueReceive(xRs485Rec, &temp, 10) == pdTRUE)
 122:serial.c      ****     wynik++;
 123:serial.c      ****     
 124:serial.c      ****   return wynik;
 125:serial.c      **** }
 126:serial.c      **** 
 127:serial.c      **** void    takeRs485(void)
 128:serial.c      **** {
 129:serial.c      ****   xSemaphoreTake(xSemaphoreRs485, portMAX_DELAY);
 130:serial.c      **** }
 131:serial.c      **** 
 132:serial.c      **** void    releaseRs485(void)
 133:serial.c      **** {
 134:serial.c      ****   xSemaphoreGive(xSemaphoreRs485);
 135:serial.c      **** }
 136:serial.c      **** 
 137:serial.c      **** void InterruptVtyOn(void)
 138:serial.c      **** {                                  
 359               	.LM8:
 360               	.LFBB3:
 361               	/* prologue: function */
 362               	/* frame size = 0 */
 139:serial.c      ****   unsigned portCHAR ucByte;                                       
 140:serial.c      ****   ucByte = UCSR1B;                 
 364               	.LM9:
 365 0042 EAE9      		ldi r30,lo8(154)
 366 0044 F0E0      		ldi r31,hi8(154)
 367 0046 8081      		ld r24,Z
 141:serial.c      ****   ucByte |= serDATA_INT_ENABLE;    
 369               	.LM10:
 370 0048 8062      		ori r24,lo8(32)
 142:serial.c      ****   UCSR1B = ucByte;                 
 372               	.LM11:
 373 004a 8083      		st Z,r24
 374               	/* epilogue start */
 143:serial.c      **** }
 376               	.LM12:
 377 004c 0895      		ret
 382               	.Lscope3:
 384               		.stabd	78,0,0
 386               	.global	__vector_31
 388               	__vector_31:
 389               		.stabd	46,0,0
 144:serial.c      **** 
 145:serial.c      **** /*-----------------------------------------------------------*/
 146:serial.c      **** ISR(USART1_RX_vect)
 147:serial.c      **** {
 148:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
 149:serial.c      ****   signed portCHAR cChar;
 150:serial.c      **** 
 151:serial.c      ****   cChar = UDR1;
 152:serial.c      **** //  xQueueSendFromISR(xVtyRec, &cChar, NULL);
 153:serial.c      **** 
 154:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
 155:serial.c      ****   xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
 156:serial.c      ****   if( xHigherPriorityTaskWoken )
 157:serial.c      ****   {
 158:serial.c      ****     taskYIELD();
 159:serial.c      ****   }
 160:serial.c      **** }
 161:serial.c      **** 
 162:serial.c      **** void uartVtySendByte(uint8_t data)
 163:serial.c      **** {
 164:serial.c      ****   xQueueSend(xVtyTx, &data, portMAX_DELAY);
 165:serial.c      ****   vInterruptVtyOn();
 166:serial.c      **** }
 167:serial.c      **** 
 168:serial.c      **** ISR(USART1_UDRE_vect)
 169:serial.c      **** {
 391               	.LM13:
 392               	.LFBB4:
 393 004e 1F92      		push __zero_reg__
 394 0050 0F92      		push r0
 395 0052 0FB6      		in r0,__SREG__
 396 0054 0F92      		push r0
 397 0056 0BB6      		in r0,91-32
 398 0058 0F92      		push r0
 399 005a 1124      		clr __zero_reg__
 400 005c 2F93      		push r18
 401 005e 3F93      		push r19
 402 0060 4F93      		push r20
 403 0062 5F93      		push r21
 404 0064 6F93      		push r22
 405 0066 7F93      		push r23
 406 0068 8F93      		push r24
 407 006a 9F93      		push r25
 408 006c AF93      		push r26
 409 006e BF93      		push r27
 410 0070 EF93      		push r30
 411 0072 FF93      		push r31
 412               	/* prologue: Signal */
 413               	/* frame size = 0 */
 170:serial.c      ****   static signed portBASE_TYPE xHigherPriorityTaskWoken; 
 171:serial.c      ****   static char data;
 172:serial.c      ****   if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
 415               	.LM14:
 416 0074 8091 0000 		lds r24,xVtyTx
 417 0078 9091 0000 		lds r25,(xVtyTx)+1
 418 007c 60E0      		ldi r22,lo8(data.3245)
 419 007e 70E0      		ldi r23,hi8(data.3245)
 420 0080 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3244)
 421 0082 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3244)
 422 0084 0E94 0000 		call xQueueReceiveFromISR
 423 0088 8130      		cpi r24,lo8(1)
 424 008a 01F4      		brne .L9
 173:serial.c      ****   {
 174:serial.c      ****     UDR1 = data; 
 426               	.LM15:
 427 008c 8091 0000 		lds r24,data.3245
 428 0090 8093 9C00 		sts 156,r24
 429 0094 00C0      		rjmp .L10
 430               	.L9:
 175:serial.c      ****   }
 176:serial.c      ****   else
 177:serial.c      ****   {
 178:serial.c      ****     xHigherPriorityTaskWoken = pdFALSE;
 432               	.LM16:
 433 0096 1092 0000 		sts xHigherPriorityTaskWoken.3244,__zero_reg__
 434               	.LBB2:
 179:serial.c      ****     vInterruptVtyOff();
 436               	.LM17:
 437 009a 8091 9A00 		lds r24,154
 438 009e 8F7D      		andi r24,lo8(-33)
 439 00a0 8093 9A00 		sts 154,r24
 440               	.L10:
 441               	.LBE2:
 180:serial.c      ****   }
 181:serial.c      ****   if( xHigherPriorityTaskWoken )
 443               	.LM18:
 444 00a4 8091 0000 		lds r24,xHigherPriorityTaskWoken.3244
 445 00a8 8823      		tst r24
 446 00aa 01F0      		breq .L12
 182:serial.c      ****   {
 183:serial.c      ****     taskYIELD();
 448               	.LM19:
 449 00ac 0E94 0000 		call vPortYield
 450               	.L12:
 451               	/* epilogue start */
 184:serial.c      ****   }
 185:serial.c      **** }
 453               	.LM20:
 454 00b0 FF91      		pop r31
 455 00b2 EF91      		pop r30
 456 00b4 BF91      		pop r27
 457 00b6 AF91      		pop r26
 458 00b8 9F91      		pop r25
 459 00ba 8F91      		pop r24
 460 00bc 7F91      		pop r23
 461 00be 6F91      		pop r22
 462 00c0 5F91      		pop r21
 463 00c2 4F91      		pop r20
 464 00c4 3F91      		pop r19
 465 00c6 2F91      		pop r18
 466 00c8 0F90      		pop r0
 467 00ca 0BBE      		out 91-32,r0
 468 00cc 0F90      		pop r0
 469 00ce 0FBE      		out __SREG__,r0
 470 00d0 0F90      		pop r0
 471 00d2 1F90      		pop __zero_reg__
 472 00d4 1895      		reti
 481               	.Lscope4:
 483               		.stabd	78,0,0
 485               	.global	__vector_19
 487               	__vector_19:
 488               		.stabd	46,0,0
  92:serial.c      **** {
 490               	.LM21:
 491               	.LFBB5:
 492 00d6 1F92      		push __zero_reg__
 493 00d8 0F92      		push r0
 494 00da 0FB6      		in r0,__SREG__
 495 00dc 0F92      		push r0
 496 00de 0BB6      		in r0,91-32
 497 00e0 0F92      		push r0
 498 00e2 1124      		clr __zero_reg__
 499 00e4 2F93      		push r18
 500 00e6 3F93      		push r19
 501 00e8 4F93      		push r20
 502 00ea 5F93      		push r21
 503 00ec 6F93      		push r22
 504 00ee 7F93      		push r23
 505 00f0 8F93      		push r24
 506 00f2 9F93      		push r25
 507 00f4 AF93      		push r26
 508 00f6 BF93      		push r27
 509 00f8 EF93      		push r30
 510 00fa FF93      		push r31
 511               	/* prologue: Signal */
 512               	/* frame size = 0 */
  95:serial.c      ****   if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
 514               	.LM22:
 515 00fc 8091 0000 		lds r24,xRs485Tx
 516 0100 9091 0000 		lds r25,(xRs485Tx)+1
 517 0104 60E0      		ldi r22,lo8(data.3173)
 518 0106 70E0      		ldi r23,hi8(data.3173)
 519 0108 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3172)
 520 010a 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3172)
 521 010c 0E94 0000 		call xQueueReceiveFromISR
 522 0110 8130      		cpi r24,lo8(1)
 523 0112 01F4      		brne .L14
  97:serial.c      ****     Rs485TxStart();
 525               	.LM23:
 526 0114 8091 6500 		lds r24,101
 527 0118 8061      		ori r24,lo8(16)
 528 011a 8093 6500 		sts 101,r24
  98:serial.c      ****     UDR0 = data; 
 530               	.LM24:
 531 011e 8091 0000 		lds r24,data.3173
 532 0122 8CB9      		out 44-32,r24
 533 0124 00C0      		rjmp .L15
 534               	.L14:
 102:serial.c      ****     xHigherPriorityTaskWoken = pdFALSE;
 536               	.LM25:
 537 0126 1092 0000 		sts xHigherPriorityTaskWoken.3172,__zero_reg__
 538               	.LBB3:
 103:serial.c      ****     vInterruptRs485Off();
 540               	.LM26:
 541 012a 5598      		cbi 42-32,5
 542               	.L15:
 543               	.LBE3:
 105:serial.c      ****   if( xHigherPriorityTaskWoken )
 545               	.LM27:
 546 012c 8091 0000 		lds r24,xHigherPriorityTaskWoken.3172
 547 0130 8823      		tst r24
 548 0132 01F0      		breq .L17
 107:serial.c      ****     taskYIELD();
 550               	.LM28:
 551 0134 0E94 0000 		call vPortYield
 552               	.L17:
 553               	/* epilogue start */
 109:serial.c      **** }
 555               	.LM29:
 556 0138 FF91      		pop r31
 557 013a EF91      		pop r30
 558 013c BF91      		pop r27
 559 013e AF91      		pop r26
 560 0140 9F91      		pop r25
 561 0142 8F91      		pop r24
 562 0144 7F91      		pop r23
 563 0146 6F91      		pop r22
 564 0148 5F91      		pop r21
 565 014a 4F91      		pop r20
 566 014c 3F91      		pop r19
 567 014e 2F91      		pop r18
 568 0150 0F90      		pop r0
 569 0152 0BBE      		out 91-32,r0
 570 0154 0F90      		pop r0
 571 0156 0FBE      		out __SREG__,r0
 572 0158 0F90      		pop r0
 573 015a 1F90      		pop __zero_reg__
 574 015c 1895      		reti
 580               	.Lscope5:
 582               		.stabd	78,0,0
 585               	.global	uartVtySendByte
 587               	uartVtySendByte:
 588               		.stabd	46,0,0
 163:serial.c      **** {
 590               	.LM30:
 591               	.LFBB6:
 592 015e DF93      		push r29
 593 0160 CF93      		push r28
 594 0162 0F92      		push __tmp_reg__
 595 0164 CDB7      		in r28,__SP_L__
 596 0166 DEB7      		in r29,__SP_H__
 597               	/* prologue: function */
 598               	/* frame size = 1 */
 599 0168 8983      		std Y+1,r24
 164:serial.c      ****   xQueueSend(xVtyTx, &data, portMAX_DELAY);
 601               	.LM31:
 602 016a 8091 0000 		lds r24,xVtyTx
 603 016e 9091 0000 		lds r25,(xVtyTx)+1
 604 0172 BE01      		movw r22,r28
 605 0174 6F5F      		subi r22,lo8(-(1))
 606 0176 7F4F      		sbci r23,hi8(-(1))
 607 0178 4FEF      		ldi r20,lo8(-1)
 608 017a 5FEF      		ldi r21,hi8(-1)
 609 017c 20E0      		ldi r18,lo8(0)
 610 017e 0E94 0000 		call xQueueGenericSend
 611               	.LBB4:
 165:serial.c      ****   vInterruptVtyOn();
 613               	.LM32:
 614 0182 EAE9      		ldi r30,lo8(154)
 615 0184 F0E0      		ldi r31,hi8(154)
 616 0186 8081      		ld r24,Z
 617 0188 8062      		ori r24,lo8(32)
 618 018a 8083      		st Z,r24
 619               	/* epilogue start */
 620               	.LBE4:
 166:serial.c      **** }
 622               	.LM33:
 623 018c 0F90      		pop __tmp_reg__
 624 018e CF91      		pop r28
 625 0190 DF91      		pop r29
 626 0192 0895      		ret
 631               	.Lscope6:
 633               		.stabd	78,0,0
 637               	.global	VtyPutChar
 639               	VtyPutChar:
 640               		.stabd	46,0,0
  30:serial.c      **** {
 642               	.LM34:
 643               	.LFBB7:
 644               	/* prologue: function */
 645               	/* frame size = 0 */
  32:serial.c      ****   uartVtySendByte(c);
 647               	.LM35:
 648 0194 0E94 0000 		call uartVtySendByte
  34:serial.c      **** }
 650               	.LM36:
 651 0198 80E0      		ldi r24,lo8(0)
 652 019a 90E0      		ldi r25,hi8(0)
 653               	/* epilogue start */
 654 019c 0895      		ret
 656               	.Lscope7:
 658               		.stabd	78,0,0
 660               		.weak	releaseRs485
 662               	releaseRs485:
 663               		.stabd	46,0,0
 133:serial.c      **** {
 665               	.LM37:
 666               	.LFBB8:
 667               	/* prologue: function */
 668               	/* frame size = 0 */
 134:serial.c      ****   xSemaphoreGive(xSemaphoreRs485);
 670               	.LM38:
 671 019e 8091 0000 		lds r24,xSemaphoreRs485
 672 01a2 9091 0000 		lds r25,(xSemaphoreRs485)+1
 673 01a6 60E0      		ldi r22,lo8(0)
 674 01a8 70E0      		ldi r23,hi8(0)
 675 01aa 40E0      		ldi r20,lo8(0)
 676 01ac 50E0      		ldi r21,hi8(0)
 677 01ae 20E0      		ldi r18,lo8(0)
 678 01b0 0E94 0000 		call xQueueGenericSend
 679               	/* epilogue start */
 135:serial.c      **** }
 681               	.LM39:
 682 01b4 0895      		ret
 684               	.Lscope8:
 686               		.stabd	78,0,0
 689               		.weak	uartRs485SendByte
 691               	uartRs485SendByte:
 692               		.stabd	46,0,0
  81:serial.c      **** {
 694               	.LM40:
 695               	.LFBB9:
 696 01b6 DF93      		push r29
 697 01b8 CF93      		push r28
 698 01ba 0F92      		push __tmp_reg__
 699 01bc CDB7      		in r28,__SP_L__
 700 01be DEB7      		in r29,__SP_H__
 701               	/* prologue: function */
 702               	/* frame size = 1 */
 703 01c0 8983      		std Y+1,r24
  82:serial.c      ****   xQueueSend(xRs485Tx, &data, portMAX_DELAY);
 705               	.LM41:
 706 01c2 8091 0000 		lds r24,xRs485Tx
 707 01c6 9091 0000 		lds r25,(xRs485Tx)+1
 708 01ca BE01      		movw r22,r28
 709 01cc 6F5F      		subi r22,lo8(-(1))
 710 01ce 7F4F      		sbci r23,hi8(-(1))
 711 01d0 4FEF      		ldi r20,lo8(-1)
 712 01d2 5FEF      		ldi r21,hi8(-1)
 713 01d4 20E0      		ldi r18,lo8(0)
 714 01d6 0E94 0000 		call xQueueGenericSend
 715               	.LBB5:
  83:serial.c      ****   vInterruptRs485On();
 717               	.LM42:
 718 01da 559A      		sbi 42-32,5
 719               	/* epilogue start */
 720               	.LBE5:
  84:serial.c      **** }
 722               	.LM43:
 723 01dc 0F90      		pop __tmp_reg__
 724 01de CF91      		pop r28
 725 01e0 DF91      		pop r29
 726 01e2 0895      		ret
 728               	.Lscope9:
 730               		.stabd	78,0,0
 732               	.global	__vector_30
 734               	__vector_30:
 735               		.stabd	46,0,0
 147:serial.c      **** {
 737               	.LM44:
 738               	.LFBB10:
 739 01e4 1F92      		push __zero_reg__
 740 01e6 0F92      		push r0
 741 01e8 0FB6      		in r0,__SREG__
 742 01ea 0F92      		push r0
 743 01ec 0BB6      		in r0,91-32
 744 01ee 0F92      		push r0
 745 01f0 1124      		clr __zero_reg__
 746 01f2 2F93      		push r18
 747 01f4 3F93      		push r19
 748 01f6 4F93      		push r20
 749 01f8 5F93      		push r21
 750 01fa 6F93      		push r22
 751 01fc 7F93      		push r23
 752 01fe 8F93      		push r24
 753 0200 9F93      		push r25
 754 0202 AF93      		push r26
 755 0204 BF93      		push r27
 756 0206 EF93      		push r30
 757 0208 FF93      		push r31
 758 020a DF93      		push r29
 759 020c CF93      		push r28
 760 020e 0F92      		push __tmp_reg__
 761 0210 CDB7      		in r28,__SP_L__
 762 0212 DEB7      		in r29,__SP_H__
 763               	/* prologue: Signal */
 764               	/* frame size = 1 */
 151:serial.c      ****   cChar = UDR1;
 766               	.LM45:
 767 0214 8091 9C00 		lds r24,156
 768 0218 8983      		std Y+1,r24
 154:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
 770               	.LM46:
 771 021a 1092 0000 		sts xHigherPriorityTaskWoken.3226,__zero_reg__
 155:serial.c      ****   xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
 773               	.LM47:
 774 021e 8091 0000 		lds r24,xVtyRec
 775 0222 9091 0000 		lds r25,(xVtyRec)+1
 776 0226 BE01      		movw r22,r28
 777 0228 6F5F      		subi r22,lo8(-(1))
 778 022a 7F4F      		sbci r23,hi8(-(1))
 779 022c 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3226)
 780 022e 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3226)
 781 0230 20E0      		ldi r18,lo8(0)
 782 0232 0E94 0000 		call xQueueGenericSendFromISR
 156:serial.c      ****   if( xHigherPriorityTaskWoken )
 784               	.LM48:
 785 0236 8091 0000 		lds r24,xHigherPriorityTaskWoken.3226
 786 023a 8823      		tst r24
 787 023c 01F0      		breq .L28
 158:serial.c      ****     taskYIELD();
 789               	.LM49:
 790 023e 0E94 0000 		call vPortYield
 791               	.L28:
 792               	/* epilogue start */
 160:serial.c      **** }
 794               	.LM50:
 795 0242 0F90      		pop __tmp_reg__
 796 0244 CF91      		pop r28
 797 0246 DF91      		pop r29
 798 0248 FF91      		pop r31
 799 024a EF91      		pop r30
 800 024c BF91      		pop r27
 801 024e AF91      		pop r26
 802 0250 9F91      		pop r25
 803 0252 8F91      		pop r24
 804 0254 7F91      		pop r23
 805 0256 6F91      		pop r22
 806 0258 5F91      		pop r21
 807 025a 4F91      		pop r20
 808 025c 3F91      		pop r19
 809 025e 2F91      		pop r18
 810 0260 0F90      		pop r0
 811 0262 0BBE      		out 91-32,r0
 812 0264 0F90      		pop r0
 813 0266 0FBE      		out __SREG__,r0
 814 0268 0F90      		pop r0
 815 026a 1F90      		pop __zero_reg__
 816 026c 1895      		reti
 822               	.Lscope10:
 824               		.stabd	78,0,0
 826               	.global	__vector_18
 828               	__vector_18:
 829               		.stabd	46,0,0
  64:serial.c      **** {
 831               	.LM51:
 832               	.LFBB11:
 833 026e 1F92      		push __zero_reg__
 834 0270 0F92      		push r0
 835 0272 0FB6      		in r0,__SREG__
 836 0274 0F92      		push r0
 837 0276 0BB6      		in r0,91-32
 838 0278 0F92      		push r0
 839 027a 1124      		clr __zero_reg__
 840 027c 2F93      		push r18
 841 027e 3F93      		push r19
 842 0280 4F93      		push r20
 843 0282 5F93      		push r21
 844 0284 6F93      		push r22
 845 0286 7F93      		push r23
 846 0288 8F93      		push r24
 847 028a 9F93      		push r25
 848 028c AF93      		push r26
 849 028e BF93      		push r27
 850 0290 EF93      		push r30
 851 0292 FF93      		push r31
 852 0294 DF93      		push r29
 853 0296 CF93      		push r28
 854 0298 0F92      		push __tmp_reg__
 855 029a CDB7      		in r28,__SP_L__
 856 029c DEB7      		in r29,__SP_H__
 857               	/* prologue: Signal */
 858               	/* frame size = 1 */
  68:serial.c      ****   cChar = UDR0;
 860               	.LM52:
 861 029e 8CB1      		in r24,44-32
 862 02a0 8983      		std Y+1,r24
  70:serial.c      ****   xHigherPriorityTaskWoken = pdFALSE;
 864               	.LM53:
 865 02a2 1092 0000 		sts xHigherPriorityTaskWoken.3146,__zero_reg__
  73:serial.c      ****   xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
 867               	.LM54:
 868 02a6 8091 0000 		lds r24,xRs485Rec
 869 02aa 9091 0000 		lds r25,(xRs485Rec)+1
 870 02ae BE01      		movw r22,r28
 871 02b0 6F5F      		subi r22,lo8(-(1))
 872 02b2 7F4F      		sbci r23,hi8(-(1))
 873 02b4 40E0      		ldi r20,lo8(xHigherPriorityTaskWoken.3146)
 874 02b6 50E0      		ldi r21,hi8(xHigherPriorityTaskWoken.3146)
 875 02b8 20E0      		ldi r18,lo8(0)
 876 02ba 0E94 0000 		call xQueueGenericSendFromISR
  74:serial.c      ****   if( xHigherPriorityTaskWoken )
 878               	.LM55:
 879 02be 8091 0000 		lds r24,xHigherPriorityTaskWoken.3146
 880 02c2 8823      		tst r24
 881 02c4 01F0      		breq .L31
  76:serial.c      ****     taskYIELD();
 883               	.LM56:
 884 02c6 0E94 0000 		call vPortYield
 885               	.L31:
 886               	/* epilogue start */
  78:serial.c      **** }
 888               	.LM57:
 889 02ca 0F90      		pop __tmp_reg__
 890 02cc CF91      		pop r28
 891 02ce DF91      		pop r29
 892 02d0 FF91      		pop r31
 893 02d2 EF91      		pop r30
 894 02d4 BF91      		pop r27
 895 02d6 AF91      		pop r26
 896 02d8 9F91      		pop r25
 897 02da 8F91      		pop r24
 898 02dc 7F91      		pop r23
 899 02de 6F91      		pop r22
 900 02e0 5F91      		pop r21
 901 02e2 4F91      		pop r20
 902 02e4 3F91      		pop r19
 903 02e6 2F91      		pop r18
 904 02e8 0F90      		pop r0
 905 02ea 0BBE      		out 91-32,r0
 906 02ec 0F90      		pop r0
 907 02ee 0FBE      		out __SREG__,r0
 908 02f0 0F90      		pop r0
 909 02f2 1F90      		pop __zero_reg__
 910 02f4 1895      		reti
 916               	.Lscope11:
 918               		.stabd	78,0,0
 920               		.weak	takeRs485
 922               	takeRs485:
 923               		.stabd	46,0,0
 128:serial.c      **** {
 925               	.LM58:
 926               	.LFBB12:
 927               	/* prologue: function */
 928               	/* frame size = 0 */
 129:serial.c      ****   xSemaphoreTake(xSemaphoreRs485, portMAX_DELAY);
 930               	.LM59:
 931 02f6 8091 0000 		lds r24,xSemaphoreRs485
 932 02fa 9091 0000 		lds r25,(xSemaphoreRs485)+1
 933 02fe 60E0      		ldi r22,lo8(0)
 934 0300 70E0      		ldi r23,hi8(0)
 935 0302 4FEF      		ldi r20,lo8(-1)
 936 0304 5FEF      		ldi r21,hi8(-1)
 937 0306 20E0      		ldi r18,lo8(0)
 938 0308 0E94 0000 		call xQueueGenericReceive
 939               	/* epilogue start */
 130:serial.c      **** }
 941               	.LM60:
 942 030c 0895      		ret
 944               	.Lscope12:
 946               		.stabd	78,0,0
 948               		.weak	flushRs485RecBuffer
 950               	flushRs485RecBuffer:
 951               		.stabd	46,0,0
 118:serial.c      **** {
 953               	.LM61:
 954               	.LFBB13:
 955 030e EF92      		push r14
 956 0310 FF92      		push r15
 957 0312 1F93      		push r17
 958 0314 DF93      		push r29
 959 0316 CF93      		push r28
 960 0318 0F92      		push __tmp_reg__
 961 031a CDB7      		in r28,__SP_L__
 962 031c DEB7      		in r29,__SP_H__
 963               	/* prologue: function */
 964               	/* frame size = 1 */
 118:serial.c      **** {
 966               	.LM62:
 967 031e 10E0      		ldi r17,lo8(0)
 121:serial.c      ****   while(xQueueReceive(xRs485Rec, &temp, 10) == pdTRUE)
 969               	.LM63:
 970 0320 7E01      		movw r14,r28
 971 0322 0894      		sec
 972 0324 E11C      		adc r14,__zero_reg__
 973 0326 F11C      		adc r15,__zero_reg__
 974 0328 00C0      		rjmp .L35
 975               	.L36:
 122:serial.c      ****     wynik++;
 977               	.LM64:
 978 032a 1F5F      		subi r17,lo8(-(1))
 979               	.L35:
 121:serial.c      ****   while(xQueueReceive(xRs485Rec, &temp, 10) == pdTRUE)
 981               	.LM65:
 982 032c 8091 0000 		lds r24,xRs485Rec
 983 0330 9091 0000 		lds r25,(xRs485Rec)+1
 984 0334 B701      		movw r22,r14
 985 0336 4AE0      		ldi r20,lo8(10)
 986 0338 50E0      		ldi r21,hi8(10)
 987 033a 20E0      		ldi r18,lo8(0)
 988 033c 0E94 0000 		call xQueueGenericReceive
 989 0340 8130      		cpi r24,lo8(1)
 990 0342 01F0      		breq .L36
 125:serial.c      **** }
 992               	.LM66:
 993 0344 812F      		mov r24,r17
 994               	/* epilogue start */
 995 0346 0F90      		pop __tmp_reg__
 996 0348 CF91      		pop r28
 997 034a DF91      		pop r29
 998 034c 1F91      		pop r17
 999 034e FF90      		pop r15
 1000 0350 EF90      		pop r14
 1001 0352 0895      		ret
 1007               	.Lscope13:
 1009               		.stabd	78,0,0
 1013               		.weak	rs485Receive
 1015               	rs485Receive:
 1016               		.stabd	46,0,0
  87:serial.c      **** {
 1018               	.LM67:
 1019               	.LFBB14:
 1020               	/* prologue: function */
 1021               	/* frame size = 0 */
 1022 0354 9C01      		movw r18,r24
 1023 0356 462F      		mov r20,r22
  88:serial.c      ****   return xQueueReceive(xRs485Rec, c, timeout);
 1025               	.LM68:
 1026 0358 8091 0000 		lds r24,xRs485Rec
 1027 035c 9091 0000 		lds r25,(xRs485Rec)+1
 1028 0360 B901      		movw r22,r18
 1029 0362 50E0      		ldi r21,lo8(0)
 1030 0364 20E0      		ldi r18,lo8(0)
 1031 0366 0E94 0000 		call xQueueGenericReceive
 1032               	/* epilogue start */
  89:serial.c      **** }
 1034               	.LM69:
 1035 036a 0895      		ret
 1037               	.Lscope14:
 1039               		.stabd	78,0,0
 1042               	.global	VtyGetChar
 1044               	VtyGetChar:
 1045               		.stabd	46,0,0
  21:serial.c      **** {
 1047               	.LM70:
 1048               	.LFBB15:
 1049 036c DF93      		push r29
 1050 036e CF93      		push r28
 1051 0370 0F92      		push __tmp_reg__
 1052 0372 CDB7      		in r28,__SP_L__
 1053 0374 DEB7      		in r29,__SP_H__
 1054               	/* prologue: function */
 1055               	/* frame size = 1 */
  24:serial.c      ****   if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
 1057               	.LM71:
 1058 0376 8091 0000 		lds r24,xVtyRec
 1059 037a 9091 0000 		lds r25,(xVtyRec)+1
 1060 037e BE01      		movw r22,r28
 1061 0380 6F5F      		subi r22,lo8(-(1))
 1062 0382 7F4F      		sbci r23,hi8(-(1))
 1063 0384 4FEF      		ldi r20,lo8(-1)
 1064 0386 5FEF      		ldi r21,hi8(-1)
 1065 0388 20E0      		ldi r18,lo8(0)
 1066 038a 0E94 0000 		call xQueueGenericReceive
 1067 038e 8823      		tst r24
 1068 0390 01F4      		brne .L41
 1069 0392 2FEF      		ldi r18,lo8(-1)
 1070 0394 3FEF      		ldi r19,hi8(-1)
 1071 0396 00C0      		rjmp .L42
 1072               	.L41:
  26:serial.c      ****   return c;
 1074               	.LM72:
 1075 0398 8981      		ldd r24,Y+1
 1076 039a 282F      		mov r18,r24
 1077 039c 30E0      		ldi r19,lo8(0)
 1078               	.L42:
  27:serial.c      **** }
 1080               	.LM73:
 1081 039e C901      		movw r24,r18
 1082               	/* epilogue start */
 1083 03a0 0F90      		pop __tmp_reg__
 1084 03a2 CF91      		pop r28
 1085 03a4 DF91      		pop r29
 1086 03a6 0895      		ret
 1091               	.Lscope15:
 1093               		.stabd	78,0,0
 1095               	.global	xSerialPortInitMinimal
 1097               	xSerialPortInitMinimal:
 1098               		.stabd	46,0,0
  37:serial.c      **** {
 1100               	.LM74:
 1101               	.LFBB16:
 1102               	/* prologue: function */
 1103               	/* frame size = 0 */
  38:serial.c      ****   portENTER_CRITICAL();
 1105               	.LM75:
 1106               	/* #APP */
 1107               	 ;  38 "serial.c" 1
 1108 03a8 0FB6      		in		__tmp_reg__, __SREG__
 1109               	 ;  0 "" 2
 1110               	 ;  38 "serial.c" 1
 1111 03aa F894      		cli
 1112               	 ;  0 "" 2
 1113               	 ;  38 "serial.c" 1
 1114 03ac 0F92      		push	__tmp_reg__
 1115               	 ;  0 "" 2
  40:serial.c      ****     xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
 1117               	.LM76:
 1118               	/* #NOAPP */
 1119 03ae 80E4      		ldi r24,lo8(64)
 1120 03b0 61E0      		ldi r22,lo8(1)
 1121 03b2 0E94 0000 		call xQueueCreate
 1122 03b6 9093 0000 		sts (xVtyRec)+1,r25
 1123 03ba 8093 0000 		sts xVtyRec,r24
  41:serial.c      ****     xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
 1125               	.LM77:
 1126 03be 80E2      		ldi r24,lo8(32)
 1127 03c0 61E0      		ldi r22,lo8(1)
 1128 03c2 0E94 0000 		call xQueueCreate
 1129 03c6 9093 0000 		sts (xVtyTx)+1,r25
 1130 03ca 8093 0000 		sts xVtyTx,r24
  42:serial.c      ****     xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
 1132               	.LM78:
 1133 03ce 80E1      		ldi r24,lo8(16)
 1134 03d0 61E0      		ldi r22,lo8(1)
 1135 03d2 0E94 0000 		call xQueueCreate
 1136 03d6 9093 0000 		sts (xRs485Rec)+1,r25
 1137 03da 8093 0000 		sts xRs485Rec,r24
  43:serial.c      ****     xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
 1139               	.LM79:
 1140 03de 84E0      		ldi r24,lo8(4)
 1141 03e0 61E0      		ldi r22,lo8(1)
 1142 03e2 0E94 0000 		call xQueueCreate
 1143 03e6 9093 0000 		sts (xRs485Tx)+1,r25
 1144 03ea 8093 0000 		sts xRs485Tx,r24
  45:serial.c      ****     vSemaphoreCreateBinary(xSemaphoreRs485); 
 1146               	.LM80:
 1147 03ee 81E0      		ldi r24,lo8(1)
 1148 03f0 60E0      		ldi r22,lo8(0)
 1149 03f2 0E94 0000 		call xQueueCreate
 1150 03f6 9093 0000 		sts (xSemaphoreRs485)+1,r25
 1151 03fa 8093 0000 		sts xSemaphoreRs485,r24
 1152 03fe 0097      		sbiw r24,0
 1153 0400 01F0      		breq .L45
 1154 0402 60E0      		ldi r22,lo8(0)
 1155 0404 70E0      		ldi r23,hi8(0)
 1156 0406 40E0      		ldi r20,lo8(0)
 1157 0408 50E0      		ldi r21,hi8(0)
 1158 040a 20E0      		ldi r18,lo8(0)
 1159 040c 0E94 0000 		call xQueueGenericSend
 1160               	.L45:
  47:serial.c      ****   portEXIT_CRITICAL();
 1162               	.LM81:
 1163               	/* #APP */
 1164               	 ;  47 "serial.c" 1
 1165 0410 0F90      		pop		__tmp_reg__
 1166               	 ;  0 "" 2
 1167               	 ;  47 "serial.c" 1
 1168 0412 0FBE      		out		__SREG__, __tmp_reg__
 1169               	 ;  0 "" 2
  49:serial.c      ****   UBRR0L = 7;
 1171               	.LM82:
 1172               	/* #NOAPP */
 1173 0414 87E0      		ldi r24,lo8(7)
 1174 0416 89B9      		out 41-32,r24
  50:serial.c      ****   UBRR0H = 0;
 1176               	.LM83:
 1177 0418 1092 9000 		sts 144,__zero_reg__
  52:serial.c      ****   UBRR1L = 7;
 1179               	.LM84:
 1180 041c 8093 9900 		sts 153,r24
  53:serial.c      ****   UBRR1H = 0;
 1182               	.LM85:
 1183 0420 1092 9800 		sts 152,__zero_reg__
  55:serial.c      ****   UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
 1185               	.LM86:
 1186 0424 88ED      		ldi r24,lo8(-40)
 1187 0426 8AB9      		out 42-32,r24
  56:serial.c      ****   UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
 1189               	.LM87:
 1190 0428 96E8      		ldi r25,lo8(-122)
 1191 042a 9093 9500 		sts 149,r25
  57:serial.c      ****   UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
 1193               	.LM88:
 1194 042e 88E9      		ldi r24,lo8(-104)
 1195 0430 8093 9A00 		sts 154,r24
  58:serial.c      ****   UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
 1197               	.LM89:
 1198 0434 9093 9D00 		sts 157,r25
 1199               	/* epilogue start */
  60:serial.c      **** }
 1201               	.LM90:
 1202 0438 0895      		ret
 1204               	.Lscope16:
 1206               		.stabd	78,0,0
 1207               		.lcomm data.3245,1
 1208               		.lcomm xHigherPriorityTaskWoken.3244,1
 1209               		.lcomm xHigherPriorityTaskWoken.3226,1
 1210               		.lcomm data.3173,1
 1211               		.lcomm xHigherPriorityTaskWoken.3172,1
 1212               		.data
 1215               	xHigherPriorityTaskWoken.3146:
 1216 0000 01        		.byte	1
 1217               		.comm klastry,128,1
 1218               		.comm wwwport,1,1
 1219               		.comm rollers,2,1
 1220               		.comm xSemaphoreSpiSS,2,1
 1221               		.comm portA,1,1
 1222               		.comm portB,1,1
 1223               		.comm lockSensors,2,1
 1224               		.comm nicState,14,1
 1225               		.comm plen,2,1
 1226               		.comm IpMyConfig,15,1
 1227               		.comm arpDebug,2,1
 1228               		.comm arpDebugLevel,1,1
 1229               		.comm icmpDebug,2,1
 1230               		.comm icmpDebugLevel,1,1
 1231               		.comm udpSocket,2,1
 1232               		.comm udpDbgStream,2,1
 1233               		.comm udpDbgLevel,1,1
 1234               		.comm tcpDebugStream,2,1
 1235               		.comm tcpDebugLevel,1,1
 1236               		.comm sockets,2,1
 1237               		.comm entries,2,1
 1238               		.comm debugStream,2,1
 1239               		.comm uip_netif_physical_if,2,1
 1240               		.comm uip_ext_len,1,1
 1241               		.comm uip_ext_opt_offset,1,1
 1242               		.comm czasRtc,7,1
 1243               		.comm xSemaphoreRs485,2,1
 1277               		.text
 1279               	.Letext0:
 1280               	.global __do_copy_data
 1281               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 serial.c
     /tmp/cc95d0UL.s:2      *ABS*:0000003f __SREG__
     /tmp/cc95d0UL.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc95d0UL.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc95d0UL.s:5      *ABS*:00000034 __CCP__
     /tmp/cc95d0UL.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc95d0UL.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc95d0UL.s:282    .text:00000000 initQueueStreamUSB
     /tmp/cc95d0UL.s:639    .text:00000194 VtyPutChar
     /tmp/cc95d0UL.s:1044   .text:0000036c VtyGetChar
     /tmp/cc95d0UL.s:317    .text:0000001c __vector_20
     /tmp/cc95d0UL.s:356    .text:00000042 InterruptVtyOn
     /tmp/cc95d0UL.s:388    .text:0000004e __vector_31
                             .bss:00000000 data.3245
     /tmp/cc95d0UL.s:1207   .bss:00000001 xHigherPriorityTaskWoken.3244
     /tmp/cc95d0UL.s:487    .text:000000d6 __vector_19
     /tmp/cc95d0UL.s:1209   .bss:00000003 data.3173
     /tmp/cc95d0UL.s:1210   .bss:00000004 xHigherPriorityTaskWoken.3172
     /tmp/cc95d0UL.s:587    .text:0000015e uartVtySendByte
     /tmp/cc95d0UL.s:662    .text:0000019e releaseRs485
                            *COM*:00000002 xSemaphoreRs485
     /tmp/cc95d0UL.s:691    .text:000001b6 uartRs485SendByte
     /tmp/cc95d0UL.s:734    .text:000001e4 __vector_30
     /tmp/cc95d0UL.s:1208   .bss:00000002 xHigherPriorityTaskWoken.3226
     /tmp/cc95d0UL.s:828    .text:0000026e __vector_18
     /tmp/cc95d0UL.s:1215   .data:00000000 xHigherPriorityTaskWoken.3146
     /tmp/cc95d0UL.s:922    .text:000002f6 takeRs485
     /tmp/cc95d0UL.s:950    .text:0000030e flushRs485RecBuffer
     /tmp/cc95d0UL.s:1015   .text:00000354 rs485Receive
     /tmp/cc95d0UL.s:1097   .text:000003a8 xSerialPortInitMinimal
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:0000000e nicState
                            *COM*:00000002 plen
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpSocket
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000002 entries
                            *COM*:00000002 debugStream
                            *COM*:00000002 uip_netif_physical_if
                            *COM*:00000001 uip_ext_len
                            *COM*:00000001 uip_ext_opt_offset
                            *COM*:00000007 czasRtc

UNDEFINED SYMBOLS
xVtyTx
xQueueReceiveFromISR
vPortYield
xRs485Tx
xQueueGenericSend
xVtyRec
xQueueGenericSendFromISR
xRs485Rec
xQueueGenericReceive
xQueueCreate
__do_copy_data
__do_clear_bss
