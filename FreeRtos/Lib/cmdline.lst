   1               		.file	"cmdline.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__RAMPY__ = 0x3a
   7               	__RAMPX__ = 0x39
   8               	__RAMPD__ = 0x38
   9               	__CCP__ = 0x34
  10               	__tmp_reg__ = 0
  11               	__zero_reg__ = 1
  14               		.text
  15               	.Ltext0:
 599               	cmdlinePrintPrompt:
 600               		.stabd	46,0,0
   1:../../Lib/cmdline.c **** /**
   2:../../Lib/cmdline.c ****  * @file        cmdline.h 
   3:../../Lib/cmdline.c ****  * @author      Pascal Stang, Adam Kaliszan
   4:../../Lib/cmdline.c ****  * @brief       Command-Line Interface Library
   5:../../Lib/cmdline.c ****  * @ingroup     protocols
   6:../../Lib/cmdline.c ****  * @version     0.6
   7:../../Lib/cmdline.c ****  * Created      2003.07.16
   8:../../Lib/cmdline.c ****  * Revised      2010.04.23
   9:../../Lib/cmdline.c ****  * Editor Tabs  2
  10:../../Lib/cmdline.c ****  * Target MCU   Atmel AVR Series
  11:../../Lib/cmdline.c ****  *
  12:../../Lib/cmdline.c ****  * @par Description
  13:../../Lib/cmdline.c ****  * This library provides cammand lineinterpreter, that works on many instances. 
  14:../../Lib/cmdline.c ****  * Each instance requires: separate input/output stream, and separate instance of cmdState struct
  15:../../Lib/cmdline.c ****  * The library was optimised under memory consumption.
  16:../../Lib/cmdline.c ****  *
  17:../../Lib/cmdline.c ****  * @note: This code is currently below version 1.0, and therefore is considered
  18:../../Lib/cmdline.c ****  * to be lacking in some functionality or documentation, or may not be fully
  19:../../Lib/cmdline.c ****  * tested.  Nonetheless, you can expect most functions to work.
  20:../../Lib/cmdline.c ****  *
  21:../../Lib/cmdline.c ****  * This code is distributed under the GNU Public License
  22:../../Lib/cmdline.c ****  * which can be found at http://www.gnu.org/licenses/gpl.txt
  23:../../Lib/cmdline.c **** */
  24:../../Lib/cmdline.c **** //----- Include Files ---------------------------------------------------------
  25:../../Lib/cmdline.c **** 
  26:../../Lib/cmdline.c **** #include "main.h"
  27:../../Lib/cmdline.c **** 
  28:../../Lib/cmdline.c **** #include <stdio.h>          // fprint() support
  29:../../Lib/cmdline.c **** #include <avr/io.h>         // include I/O definitions (port names, pin names, etc)
  30:../../Lib/cmdline.c **** #include <avr/interrupt.h>  // include interrupt support
  31:../../Lib/cmdline.c **** #include <avr/pgmspace.h>   // include AVR program memory support
  32:../../Lib/cmdline.c **** #include <string.h>         // include standard C string functions
  33:../../Lib/cmdline.c **** #include <stdlib.h>         // include stdlib for string conversion functions
  34:../../Lib/cmdline.c **** 
  35:../../Lib/cmdline.c **** #include "cmdline.h"        // Configuration
  36:../../Lib/cmdline.c **** #include "vt100.h"          // vty100 constans
  37:../../Lib/cmdline.c **** 
  38:../../Lib/cmdline.c **** 
  39:../../Lib/cmdline.c **** // Constans Strings
  40:../../Lib/cmdline.c **** const char CmdlinePromptNormal[]    PROGMEM  = "DomOs>";
  41:../../Lib/cmdline.c **** const char CmdlinePromptEnable[]    PROGMEM  = "DomOs#";
  42:../../Lib/cmdline.c **** const char CmdlinePromptConfigure[] PROGMEM  = "DomOs@";
  43:../../Lib/cmdline.c **** const char CmdlineNotice[]          PROGMEM  = "cmdline: ";
  44:../../Lib/cmdline.c **** const char CmdlineCmdNotFound[]     PROGMEM  = "# nk";
  45:../../Lib/cmdline.c **** 
  46:../../Lib/cmdline.c **** 
  47:../../Lib/cmdline.c **** // internal commands
  48:../../Lib/cmdline.c **** static void cmdlineRepaint            (cmdState_t *state, char *buf);
  49:../../Lib/cmdline.c **** static void cmdlineDoHistory          (enum cliHistoryAction action, cmdState_t *state);
  50:../../Lib/cmdline.c **** static void cmdlineProcessInputString (cmdState_t *state);
  51:../../Lib/cmdline.c **** static void cmdlinePrintPrompt        (cmdState_t *state);
  52:../../Lib/cmdline.c **** static void cmdlinePrintError         (cmdState_t *state);
  53:../../Lib/cmdline.c **** static void cmdStateClear             (cmdState_t *state);
  54:../../Lib/cmdline.c **** static void cmdHistoryCopy            (cmdState_t *state);
  55:../../Lib/cmdline.c **** static void cmdHistoryMove            (cmdState_t *state);
  56:../../Lib/cmdline.c **** 
  57:../../Lib/cmdline.c **** 
  58:../../Lib/cmdline.c **** void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, c
  59:../../Lib/cmdline.c **** {
  60:../../Lib/cmdline.c ****   memset(state, 0, sizeof(cmdState_t));
  61:../../Lib/cmdline.c ****   memset(buffPtr, 0, bufferTotalSize);
  62:../../Lib/cmdline.c ****     
  63:../../Lib/cmdline.c ****   state->CmdlineBuffer = buffPtr;
  64:../../Lib/cmdline.c ****   state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
  65:../../Lib/cmdline.c **** 
  66:../../Lib/cmdline.c ****   state->cliMode = mode;
  67:../../Lib/cmdline.c ****   state->cmdList = commands;
  68:../../Lib/cmdline.c ****   
  69:../../Lib/cmdline.c ****   uint8_t i;
  70:../../Lib/cmdline.c ****   char *tmpPtr = buffPtr;
  71:../../Lib/cmdline.c ****   for (i=0; i < CMD_STATE_HISTORY; i++)
  72:../../Lib/cmdline.c ****   {
  73:../../Lib/cmdline.c ****     state->CmdlineHistory[i] = tmpPtr;
  74:../../Lib/cmdline.c ****     tmpPtr += state->bufferMaxSize;
  75:../../Lib/cmdline.c ****   }
  76:../../Lib/cmdline.c ****   state->myStdInOut = stream;
  77:../../Lib/cmdline.c **** }
  78:../../Lib/cmdline.c **** 
  79:../../Lib/cmdline.c **** void cmdStateClear(cmdState_t *state)
  80:../../Lib/cmdline.c **** {
  81:../../Lib/cmdline.c ****   // reset vt100 processing state
  82:../../Lib/cmdline.c ****   state->CmdlineInputVT100State = 0;
  83:../../Lib/cmdline.c **** 
  84:../../Lib/cmdline.c ****   // initialize input buffer
  85:../../Lib/cmdline.c ****   state->CmdlineBufferLength = 0;
  86:../../Lib/cmdline.c ****   state->CmdlineBufferEditPos = 0;
  87:../../Lib/cmdline.c **** 
  88:../../Lib/cmdline.c ****   // initialize executing function
  89:../../Lib/cmdline.c ****   state->CmdlineExecFunction = 0;
  90:../../Lib/cmdline.c **** }
  91:../../Lib/cmdline.c **** 
  92:../../Lib/cmdline.c **** void cmdlineInputFunc(char c, cmdState_t *state)
  93:../../Lib/cmdline.c **** {
  94:../../Lib/cmdline.c ****   uint8_t i;
  95:../../Lib/cmdline.c ****   // process the received character
  96:../../Lib/cmdline.c **** 
  97:../../Lib/cmdline.c ****   // VT100 handling
  98:../../Lib/cmdline.c ****   // are we processing a VT100 command?
  99:../../Lib/cmdline.c ****   if(state->CmdlineInputVT100State == 2)
 100:../../Lib/cmdline.c ****   {
 101:../../Lib/cmdline.c ****     // we have already received ESC and [
 102:../../Lib/cmdline.c ****     // now process the vt100 codeCmdlineExcBuffer
 103:../../Lib/cmdline.c ****     switch(c)
 104:../../Lib/cmdline.c ****     {
 105:../../Lib/cmdline.c ****     case VT100_ARROWUP:
 106:../../Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
 107:../../Lib/cmdline.c ****       break;
 108:../../Lib/cmdline.c ****     case VT100_ARROWDOWN:
 109:../../Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
 110:../../Lib/cmdline.c ****       break;
 111:../../Lib/cmdline.c ****     case VT100_ARROWRIGHT:
 112:../../Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 113:../../Lib/cmdline.c ****         cmdHistoryCopy(state);
 114:../../Lib/cmdline.c ****       // if the edit position less than current string length
 115:../../Lib/cmdline.c ****       if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
 116:../../Lib/cmdline.c ****       {
 117:../../Lib/cmdline.c ****         // increment the edit position
 118:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos++;
 119:../../Lib/cmdline.c ****         // move cursor forward one space (no erase)
 120:../../Lib/cmdline.c ****         fputc(ASCII_ESC        , state->myStdInOut);
 121:../../Lib/cmdline.c ****         fputc('['              , state->myStdInOut);
 122:../../Lib/cmdline.c ****         fputc(VT100_ARROWRIGHT , state->myStdInOut);
 123:../../Lib/cmdline.c ****       }
 124:../../Lib/cmdline.c ****       else
 125:../../Lib/cmdline.c ****       {
 126:../../Lib/cmdline.c ****         // else, ring the bell
 127:../../Lib/cmdline.c ****         fputc(ASCII_BEL        , state->myStdInOut);
 128:../../Lib/cmdline.c ****       }
 129:../../Lib/cmdline.c ****       break;
 130:../../Lib/cmdline.c ****     case VT100_ARROWLEFT:
 131:../../Lib/cmdline.c ****       // if the edit position is non-zero
 132:../../Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 133:../../Lib/cmdline.c ****         cmdHistoryCopy(state);
 134:../../Lib/cmdline.c ****       
 135:../../Lib/cmdline.c ****       if(state->CmdlineBufferEditPos)
 136:../../Lib/cmdline.c ****       {
 137:../../Lib/cmdline.c ****         // decrement the edit position
 138:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 139:../../Lib/cmdline.c ****         // move cursor back one space (no erase)
 140:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 141:../../Lib/cmdline.c ****       }
 142:../../Lib/cmdline.c ****       else
 143:../../Lib/cmdline.c ****       {
 144:../../Lib/cmdline.c ****         // else, ring the bell
 145:../../Lib/cmdline.c ****         fputc(ASCII_BEL        , state->myStdInOut);
 146:../../Lib/cmdline.c ****       }
 147:../../Lib/cmdline.c ****       break;
 148:../../Lib/cmdline.c ****     default:
 149:../../Lib/cmdline.c ****       break;
 150:../../Lib/cmdline.c ****     }
 151:../../Lib/cmdline.c ****     // done, reset state
 152:../../Lib/cmdline.c ****     state->CmdlineInputVT100State = 0;
 153:../../Lib/cmdline.c ****     return;
 154:../../Lib/cmdline.c ****   }
 155:../../Lib/cmdline.c ****   else if(state->CmdlineInputVT100State == 1)
 156:../../Lib/cmdline.c ****   {
 157:../../Lib/cmdline.c ****     // we last received [ESC]
 158:../../Lib/cmdline.c ****     if(c == '[')
 159:../../Lib/cmdline.c ****     {
 160:../../Lib/cmdline.c ****       state->CmdlineInputVT100State = 2;
 161:../../Lib/cmdline.c ****       return;
 162:../../Lib/cmdline.c ****     }
 163:../../Lib/cmdline.c ****     else
 164:../../Lib/cmdline.c ****       state->CmdlineInputVT100State = 0;
 165:../../Lib/cmdline.c ****   }
 166:../../Lib/cmdline.c ****   else
 167:../../Lib/cmdline.c ****   {
 168:../../Lib/cmdline.c ****     // anything else, reset state
 169:../../Lib/cmdline.c ****     state->CmdlineInputVT100State = 0;
 170:../../Lib/cmdline.c ****   }
 171:../../Lib/cmdline.c **** 
 172:../../Lib/cmdline.c ****   // Regular handling
 173:../../Lib/cmdline.c ****   //Protection against buffer Overflow
 174:../../Lib/cmdline.c ****   if (state->CmdlineBufferLength == state->bufferMaxSize)
 175:../../Lib/cmdline.c ****   {
 176:../../Lib/cmdline.c ****     state->CmdlineBufferLength--;
 177:../../Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 178:../../Lib/cmdline.c ****     {
 179:../../Lib/cmdline.c ****       state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
 180:../../Lib/cmdline.c ****     }
 181:../../Lib/cmdline.c ****   }
 182:../../Lib/cmdline.c ****   
 183:../../Lib/cmdline.c ****   if( (c >= 0x20) && (c < 0x7F) )
 184:../../Lib/cmdline.c ****   {
 185:../../Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 186:../../Lib/cmdline.c ****       cmdHistoryCopy(state);
 187:../../Lib/cmdline.c ****     // character is printable
 188:../../Lib/cmdline.c ****     // is this a simple append
 189:../../Lib/cmdline.c ****     if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 190:../../Lib/cmdline.c ****     {
 191:../../Lib/cmdline.c ****       // echo character to the output
 192:../../Lib/cmdline.c ****       fputc(c                , state->myStdInOut);
 193:../../Lib/cmdline.c ****       // add it to the command line buffer
 194:../../Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 195:../../Lib/cmdline.c ****       // update buffer length
 196:../../Lib/cmdline.c ****       state->CmdlineBufferLength++;
 197:../../Lib/cmdline.c ****     }
 198:../../Lib/cmdline.c ****     else
 199:../../Lib/cmdline.c ****     {
 200:../../Lib/cmdline.c ****       // edit/cursor position != end of buffer
 201:../../Lib/cmdline.c ****       // we're inserting characters at a mid-line edit position
 202:../../Lib/cmdline.c ****       // make room at the insert point
 203:../../Lib/cmdline.c ****       state->CmdlineBufferLength++;
 204:../../Lib/cmdline.c ****       for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
 205:../../Lib/cmdline.c ****         state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
 206:../../Lib/cmdline.c ****       // insert character
 207:../../Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 208:../../Lib/cmdline.c ****       // repaint
 209:../../Lib/cmdline.c ****       cmdlineRepaint(state, state->CmdlineBuffer);
 210:../../Lib/cmdline.c ****       // reposition cursor
 211:../../Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 212:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 213:../../Lib/cmdline.c ****     }
 214:../../Lib/cmdline.c ****   }
 215:../../Lib/cmdline.c ****   // handle special characters
 216:../../Lib/cmdline.c ****   else if(c == ASCII_CR)
 217:../../Lib/cmdline.c ****   {
 218:../../Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 219:../../Lib/cmdline.c ****       cmdHistoryMove(state);
 220:../../Lib/cmdline.c ****     
 221:../../Lib/cmdline.c ****     // user pressed [ENTER]
 222:../../Lib/cmdline.c ****     // echo CR and LF to terminal
 223:../../Lib/cmdline.c ****     fputc(ASCII_CR         , state->myStdInOut);
 224:../../Lib/cmdline.c ****     fputc(ASCII_LF         , state->myStdInOut);
 225:../../Lib/cmdline.c ****     // add null termination to command
 226:../../Lib/cmdline.c ****     state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
 227:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos++;
 228:../../Lib/cmdline.c ****     // command is complete, process it
 229:../../Lib/cmdline.c ****     cmdlineProcessInputString(state);
 230:../../Lib/cmdline.c ****     // reset buffer
 231:../../Lib/cmdline.c ****     state->CmdlineBufferLength = 0;
 232:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;
 233:../../Lib/cmdline.c ****   }
 234:../../Lib/cmdline.c ****   else if(c == ASCII_BS)
 235:../../Lib/cmdline.c ****   {
 236:../../Lib/cmdline.c ****     if(state->CmdlineBufferEditPos)
 237:../../Lib/cmdline.c ****     {
 238:../../Lib/cmdline.c ****       // is this a simple delete (off the end of the line)
 239:../../Lib/cmdline.c ****       if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 240:../../Lib/cmdline.c ****       {
 241:../../Lib/cmdline.c ****         // destructive backspace
 242:../../Lib/cmdline.c ****         // echo backspace-space-backspace
 243:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 244:../../Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 245:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 246:../../Lib/cmdline.c ****         // decrement our buffer length and edit position
 247:../../Lib/cmdline.c ****         state->CmdlineBufferLength--;
 248:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 249:../../Lib/cmdline.c ****       }
 250:../../Lib/cmdline.c ****       else
 251:../../Lib/cmdline.c ****       {
 252:../../Lib/cmdline.c ****         // edit/cursor position != end of buffer
 253:../../Lib/cmdline.c ****         // we're deleting characters at a mid-line edit position
 254:../../Lib/cmdline.c ****         // shift characters down, effectively deleting
 255:../../Lib/cmdline.c ****         state->CmdlineBufferLength--;
 256:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 257:../../Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 258:../../Lib/cmdline.c ****           state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
 259:../../Lib/cmdline.c ****         // repaint
 260:../../Lib/cmdline.c ****         cmdlineRepaint(state, state->CmdlineBuffer);
 261:../../Lib/cmdline.c ****         // add space to clear leftover characters
 262:../../Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 263:../../Lib/cmdline.c ****         // reposition cursor
 264:../../Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 265:../../Lib/cmdline.c ****           fputc(ASCII_BS       , state->myStdInOut);
 266:../../Lib/cmdline.c ****       }
 267:../../Lib/cmdline.c ****     }
 268:../../Lib/cmdline.c ****     else
 269:../../Lib/cmdline.c ****     {
 270:../../Lib/cmdline.c ****       // else, ring the bell
 271:../../Lib/cmdline.c ****       fputc(ASCII_BEL          , state->myStdInOut);
 272:../../Lib/cmdline.c ****     }
 273:../../Lib/cmdline.c ****   }
 274:../../Lib/cmdline.c ****   else if(c == ASCII_DEL)
 275:../../Lib/cmdline.c ****   {
 276:../../Lib/cmdline.c ****     // not yet handled
 277:../../Lib/cmdline.c ****   }
 278:../../Lib/cmdline.c ****   else if(c == ASCII_ESC)
 279:../../Lib/cmdline.c ****   {
 280:../../Lib/cmdline.c ****     state->CmdlineInputVT100State = 1;
 281:../../Lib/cmdline.c ****   }
 282:../../Lib/cmdline.c **** }
 283:../../Lib/cmdline.c **** 
 284:../../Lib/cmdline.c **** void cmdlineRepaint(cmdState_t *state, char *buf)
 285:../../Lib/cmdline.c **** {
 286:../../Lib/cmdline.c ****   uint8_t i;
 287:../../Lib/cmdline.c **** 
 288:../../Lib/cmdline.c ****   // carriage return
 289:../../Lib/cmdline.c ****   fputc(ASCII_CR         , state->myStdInOut);
 290:../../Lib/cmdline.c ****   // print fresh prompt
 291:../../Lib/cmdline.c ****   cmdlinePrintPrompt(state);
 292:../../Lib/cmdline.c ****   // print the new command line buffer
 293:../../Lib/cmdline.c ****   i = state->CmdlineBufferLength;
 294:../../Lib/cmdline.c ****   while(i--) 
 295:../../Lib/cmdline.c ****     fputc(*buf++         , state->myStdInOut);
 296:../../Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 297:../../Lib/cmdline.c ****   while (i--)
 298:../../Lib/cmdline.c ****     fputc(' ', state->myStdInOut);
 299:../../Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 300:../../Lib/cmdline.c ****   while (i--)
 301:../../Lib/cmdline.c ****     fputc(ASCII_BS,  state->myStdInOut);
 302:../../Lib/cmdline.c **** }
 303:../../Lib/cmdline.c **** 
 304:../../Lib/cmdline.c **** void cmdHistoryCopy(cmdState_t *state)
 305:../../Lib/cmdline.c **** {
 306:../../Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 307:../../Lib/cmdline.c ****   {
 308:../../Lib/cmdline.c ****     uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MAS
 309:../../Lib/cmdline.c ****     memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
 310:../../Lib/cmdline.c ****     strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
 311:../../Lib/cmdline.c ****   }
 312:../../Lib/cmdline.c ****   
 313:../../Lib/cmdline.c ****   state->historyDepthIdx = 0;
 314:../../Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 315:../../Lib/cmdline.c **** }
 316:../../Lib/cmdline.c **** 
 317:../../Lib/cmdline.c **** void cmdHistoryMove(cmdState_t *state)
 318:../../Lib/cmdline.c **** {
 319:../../Lib/cmdline.c ****   uint8_t i=state->historyDepthIdx;
 320:../../Lib/cmdline.c **** 
 321:../../Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 322:../../Lib/cmdline.c ****   {
 323:../../Lib/cmdline.c ****     state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
 324:../../Lib/cmdline.c ****     for ( ; i<CMD_STATE_HISTORY; i++)
 325:../../Lib/cmdline.c ****     {
 326:../../Lib/cmdline.c ****       state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHisto
 327:../../Lib/cmdline.c ****     }
 328:../../Lib/cmdline.c ****   }
 329:../../Lib/cmdline.c ****   state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
 330:../../Lib/cmdline.c **** 
 331:../../Lib/cmdline.c ****   state->historyDepthIdx = 0;
 332:../../Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 333:../../Lib/cmdline.c **** }
 334:../../Lib/cmdline.c **** 
 335:../../Lib/cmdline.c **** void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
 336:../../Lib/cmdline.c **** {
 337:../../Lib/cmdline.c ****   uint8_t historyReadIdx;
 338:../../Lib/cmdline.c ****   switch(action)
 339:../../Lib/cmdline.c ****   {
 340:../../Lib/cmdline.c ****   case CMDLINE_HISTORY_SAVE:
 341:../../Lib/cmdline.c ****     // copy CmdlineBuffer to history if not null string
 342:../../Lib/cmdline.c ****     state->CmdlineBufferLength  = 0;
 343:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;     
 344:../../Lib/cmdline.c ****     state->bufferHistoryState   = NOT_COPIED;
 345:../../Lib/cmdline.c **** 
 346:../../Lib/cmdline.c ****     if( strlen(state->CmdlineBuffer) )
 347:../../Lib/cmdline.c ****     {
 348:../../Lib/cmdline.c ****       state->historyWrIdx++;
 349:../../Lib/cmdline.c ****       state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
 350:../../Lib/cmdline.c ****       
 351:../../Lib/cmdline.c ****       state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
 352:../../Lib/cmdline.c ****     }
 353:../../Lib/cmdline.c ****     break;
 354:../../Lib/cmdline.c ****   case CMDLINE_HISTORY_PREV:
 355:../../Lib/cmdline.c ****     if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
 356:../../Lib/cmdline.c ****       break;                                               //We are on the end of the history list
 357:../../Lib/cmdline.c ****     
 358:../../Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
 359:../../Lib/cmdline.c ****     
 360:../../Lib/cmdline.c ****     if (state->CmdlineHistory[historyReadIdx][0] == 0)
 361:../../Lib/cmdline.c ****       break;
 362:../../Lib/cmdline.c ****     
 363:../../Lib/cmdline.c ****     state->historyDepthIdx++;
 364:../../Lib/cmdline.c ****     state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
 365:../../Lib/cmdline.c ****     
 366:../../Lib/cmdline.c ****     // set the buffer position to the end of the line
 367:../../Lib/cmdline.c ****     state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
 368:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos = state->CmdlineBufferLength;
 369:../../Lib/cmdline.c ****     
 370:../../Lib/cmdline.c ****     state->bufferHistoryState = NOT_COPIED;
 371:../../Lib/cmdline.c **** 
 372:../../Lib/cmdline.c ****     // "re-paint" line
 373:../../Lib/cmdline.c ****     cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
 374:../../Lib/cmdline.c ****     
 375:../../Lib/cmdline.c ****     break;
 376:../../Lib/cmdline.c ****   case CMDLINE_HISTORY_NEXT:      
 377:../../Lib/cmdline.c ****     if (state->historyDepthIdx == 0)
 378:../../Lib/cmdline.c ****       break;                                               //We are on the begining of the history 
 379:../../Lib/cmdline.c **** 
 380:../../Lib/cmdline.c ****     state->historyDepthIdx --;
 381:../../Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
 382:../../Lib/cmdline.c ****    
 383:../../Lib/cmdline.c ****     // set the buffer position to the end of the line
 384:../../Lib/cmdline.c ****     state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
 385:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos = state->CmdlineBufferLength;
 386:../../Lib/cmdline.c ****     
 387:../../Lib/cmdline.c ****     state->bufferHistoryState = NOT_COPIED;
 388:../../Lib/cmdline.c **** 
 389:../../Lib/cmdline.c ****     // "re-paint" line
 390:../../Lib/cmdline.c ****     cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
 391:../../Lib/cmdline.c ****     break;
 392:../../Lib/cmdline.c ****   }
 393:../../Lib/cmdline.c **** }
 394:../../Lib/cmdline.c **** 
 395:../../Lib/cmdline.c **** void cmdlineProcessInputString(cmdState_t *state)
 396:../../Lib/cmdline.c **** {
 397:../../Lib/cmdline.c ****   uint8_t i=0;
 398:../../Lib/cmdline.c ****   state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer la
 399:../../Lib/cmdline.c **** 
 400:../../Lib/cmdline.c ****   while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the comman
 401:../../Lib/cmdline.c ****     || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace char
 402:../../Lib/cmdline.c ****     i++;                                                              // i determines the cammand l
 403:../../Lib/cmdline.c **** 
 404:../../Lib/cmdline.c ****   if(!i)                                                              // command was null or empty
 405:../../Lib/cmdline.c ****   {
 406:../../Lib/cmdline.c ****     cmdlinePrintPrompt(state);                                        // output a new prompt
 407:../../Lib/cmdline.c ****     return;
 408:../../Lib/cmdline.c ****   }
 409:../../Lib/cmdline.c **** 
 410:../../Lib/cmdline.c ****   const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The 
 411:../../Lib/cmdline.c ****   command_t  tmp;                                                     // We need to create this obj
 412:../../Lib/cmdline.c ****   memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need t
 413:../../Lib/cmdline.c **** 
 414:../../Lib/cmdline.c ****   do                                                                  // search command list for ma
 415:../../Lib/cmdline.c ****   {
 416:../../Lib/cmdline.c ****     if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command match
 417:../../Lib/cmdline.c ****     {                                                                 // 
 418:../../Lib/cmdline.c ****       state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
 419:../../Lib/cmdline.c ****       state->command_str         = tmp.commandStr;
 420:../../Lib/cmdline.c ****       state->command_help_str    = tmp.commandHelpStr;
 421:../../Lib/cmdline.c ****       cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
 422:../../Lib/cmdline.c ****       return;
 423:../../Lib/cmdline.c ****     }
 424:../../Lib/cmdline.c ****     tmpPtr++;                                                         // Next command
 425:../../Lib/cmdline.c ****     memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from fla
 426:../../Lib/cmdline.c ****   }
 427:../../Lib/cmdline.c ****   while (tmp.commandStr != NULL);                                     // Last command on the list i
 428:../../Lib/cmdline.c ****   
 429:../../Lib/cmdline.c ****   // if we did not get a match
 430:../../Lib/cmdline.c ****   cmdlinePrintError(state);                                           // output an error message
 431:../../Lib/cmdline.c ****   cmdlinePrintPrompt(state);                                          // output a new prompt
 432:../../Lib/cmdline.c **** }
 433:../../Lib/cmdline.c **** 
 434:../../Lib/cmdline.c **** void cmdlineMainLoop(cmdState_t *state)
 435:../../Lib/cmdline.c **** {
 436:../../Lib/cmdline.c ****   cliExRes_t result;
 437:../../Lib/cmdline.c ****   if(state->CmdlineExecFunction)                // do we have a command/function to be executed
 438:../../Lib/cmdline.c ****   {
 439:../../Lib/cmdline.c ****     state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
 440:../../Lib/cmdline.c ****     result = state->CmdlineExecFunction(state); // run it
 441:../../Lib/cmdline.c ****     
 442:../../Lib/cmdline.c ****     switch(result)
 443:../../Lib/cmdline.c ****     {
 444:../../Lib/cmdline.c ****       case OK_INFORM:
 445:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
 446:../../Lib/cmdline.c ****         break;
 447:../../Lib/cmdline.c ****       case SYNTAX_ERROR:
 448:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
 449:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_str);
 450:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR(" "));
 451:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_help_str);
 452:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("\r\n"));
 453:../../Lib/cmdline.c ****         break;
 454:../../Lib/cmdline.c ****       case ERROR_INFORM:
 455:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
 456:../../Lib/cmdline.c ****         break;
 457:../../Lib/cmdline.c ****       case ERROR_OPERATION_NOT_ALLOWED:
 458:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
 459:../../Lib/cmdline.c ****         break;
 460:../../Lib/cmdline.c ****       default:
 461:../../Lib/cmdline.c ****         break;
 462:../../Lib/cmdline.c ****     }
 463:../../Lib/cmdline.c ****     state->CmdlineExecFunction = NULL;          // reset
 464:../../Lib/cmdline.c ****     state->command_str         = NULL;
 465:../../Lib/cmdline.c ****     state->command_help_str    = NULL;
 466:../../Lib/cmdline.c ****     cmdlinePrintPrompt(state);                  // output new prompt
 467:../../Lib/cmdline.c ****   }
 468:../../Lib/cmdline.c **** }
 469:../../Lib/cmdline.c **** 
 470:../../Lib/cmdline.c **** void cmdlinePrintPrompt(cmdState_t *state)
 471:../../Lib/cmdline.c **** {
 602               	.LM0:
 603               	.LFBB1:
 604 0000 0F93      		push r16
 605 0002 1F93      		push r17
 606 0004 CF93      		push r28
 607 0006 DF93      		push r29
 608               	/* prologue: function */
 609               	/* frame size = 0 */
 610               	/* stack size = 4 */
 611               	.L__stack_usage = 4
 612 0008 8C01      		movw r16,r24
 472:../../Lib/cmdline.c ****   const char* ptr;
 473:../../Lib/cmdline.c ****   // print a new command prompt
 474:../../Lib/cmdline.c ****   switch (state->cliMode)
 614               	.LM1:
 615 000a FC01      		movw r30,r24
 616 000c 80A1      		ldd r24,Z+32
 617 000e 8130      		cpi r24,lo8(1)
 618 0010 01F0      		breq .L7
 619 0012 8230      		cpi r24,lo8(2)
 620 0014 01F0      		breq .L4
 475:../../Lib/cmdline.c ****   {
 476:../../Lib/cmdline.c ****     case NR_NORMAL:
 477:../../Lib/cmdline.c ****       ptr = CmdlinePromptNormal;
 622               	.LM2:
 623 0016 C0E0      		ldi r28,lo8(CmdlinePromptNormal)
 624 0018 D0E0      		ldi r29,hi8(CmdlinePromptNormal)
 625 001a 00C0      		rjmp .L5
 626               	.L7:
 478:../../Lib/cmdline.c ****       break;
 479:../../Lib/cmdline.c ****     case NR_ENABLE:
 480:../../Lib/cmdline.c ****       ptr = CmdlinePromptEnable;
 628               	.LM3:
 629 001c C0E0      		ldi r28,lo8(CmdlinePromptEnable)
 630 001e D0E0      		ldi r29,hi8(CmdlinePromptEnable)
 631 0020 00C0      		rjmp .L5
 632               	.L4:
 481:../../Lib/cmdline.c ****       break;
 482:../../Lib/cmdline.c ****     case NR_CONFIGURE:
 483:../../Lib/cmdline.c ****       ptr = CmdlinePromptConfigure;
 634               	.LM4:
 635 0022 C0E0      		ldi r28,lo8(CmdlinePromptConfigure)
 636 0024 D0E0      		ldi r29,hi8(CmdlinePromptConfigure)
 637               	.L5:
 638               	.LBB2:
 484:../../Lib/cmdline.c ****       break;
 485:../../Lib/cmdline.c ****     default:
 486:../../Lib/cmdline.c ****       ptr = CmdlinePromptNormal;
 487:../../Lib/cmdline.c ****       break;      
 488:../../Lib/cmdline.c ****   }
 489:../../Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 640               	.LM5:
 641 0026 CE01      		movw r24,r28
 642 0028 FE01      		movw r30,r28
 643               	/* #APP */
 644               	 ;  489 "../../Lib/cmdline.c" 1
 645 002a 2491      		lpm r18, Z
 646               		
 647               	 ;  0 "" 2
 648               	/* #NOAPP */
 649               	.LBE2:
 650 002c 2223      		tst r18
 651 002e 01F0      		breq .L9
 652               	.LBB3:
 490:../../Lib/cmdline.c ****     fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
 654               	.LM6:
 655 0030 2196      		adiw r28,1
 656 0032 FC01      		movw r30,r24
 657               	/* #APP */
 658               	 ;  490 "../../Lib/cmdline.c" 1
 659 0034 8491      		lpm r24, Z
 660               		
 661               	 ;  0 "" 2
 662               	/* #NOAPP */
 663               	.LBE3:
 664 0036 F801      		movw r30,r16
 665 0038 628D      		ldd r22,Z+26
 666 003a 738D      		ldd r23,Z+27
 667 003c 90E0      		ldi r25,0
 668 003e 0E94 0000 		call fputc
 669 0042 00C0      		rjmp .L5
 670               	.L9:
 671               	/* epilogue start */
 491:../../Lib/cmdline.c **** }
 673               	.LM7:
 674 0044 DF91      		pop r29
 675 0046 CF91      		pop r28
 676 0048 1F91      		pop r17
 677 004a 0F91      		pop r16
 678 004c 0895      		ret
 686               	.Lscope1:
 688               		.stabd	78,0,0
 692               	cmdlineRepaint:
 693               		.stabd	46,0,0
 285:../../Lib/cmdline.c **** {
 695               	.LM8:
 696               	.LFBB2:
 697 004e DF92      		push r13
 698 0050 EF92      		push r14
 699 0052 FF92      		push r15
 700 0054 0F93      		push r16
 701 0056 1F93      		push r17
 702 0058 CF93      		push r28
 703 005a DF93      		push r29
 704               	/* prologue: function */
 705               	/* frame size = 0 */
 706               	/* stack size = 7 */
 707               	.L__stack_usage = 7
 708 005c EC01      		movw r28,r24
 709 005e E62E      		mov r14,r22
 710 0060 D72E      		mov r13,r23
 289:../../Lib/cmdline.c ****   fputc(ASCII_CR         , state->myStdInOut);
 712               	.LM9:
 713 0062 6A8D      		ldd r22,Y+26
 714 0064 7B8D      		ldd r23,Y+27
 715 0066 8DE0      		ldi r24,lo8(13)
 716 0068 90E0      		ldi r25,0
 717 006a 0E94 0000 		call fputc
 291:../../Lib/cmdline.c ****   cmdlinePrintPrompt(state);
 719               	.LM10:
 720 006e CE01      		movw r24,r28
 721 0070 0E94 0000 		call cmdlinePrintPrompt
 293:../../Lib/cmdline.c ****   i = state->CmdlineBufferLength;
 723               	.LM11:
 724 0074 FD84      		ldd r15,Y+13
 294:../../Lib/cmdline.c ****   while(i--) 
 726               	.LM12:
 727 0076 0E2D      		mov r16,r14
 728 0078 1D2D      		mov r17,r13
 729 007a FE0C      		add r15,r14
 730               	.L11:
 294:../../Lib/cmdline.c ****   while(i--) 
 732               	.LM13:
 733 007c F016      		cp r15,r16
 734 007e 01F0      		breq .L17
 295:../../Lib/cmdline.c ****     fputc(*buf++         , state->myStdInOut);
 736               	.LM14:
 737 0080 F801      		movw r30,r16
 738 0082 8191      		ld r24,Z+
 739 0084 8F01      		movw r16,r30
 740 0086 6A8D      		ldd r22,Y+26
 741 0088 7B8D      		ldd r23,Y+27
 742 008a 9927      		clr r25
 743 008c 87FD      		sbrc r24,7
 744 008e 9095      		com r25
 745 0090 0E94 0000 		call fputc
 746 0094 00C0      		rjmp .L11
 747               	.L17:
 296:../../Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 749               	.LM15:
 750 0096 1C85      		ldd r17,Y+12
 751 0098 8D85      		ldd r24,Y+13
 752 009a 181B      		sub r17,r24
 753               	.L13:
 297:../../Lib/cmdline.c ****   while (i--)
 755               	.LM16:
 756 009c 1123      		tst r17
 757 009e 01F0      		breq .L18
 298:../../Lib/cmdline.c ****     fputc(' ', state->myStdInOut);
 759               	.LM17:
 760 00a0 6A8D      		ldd r22,Y+26
 761 00a2 7B8D      		ldd r23,Y+27
 762 00a4 80E2      		ldi r24,lo8(32)
 763 00a6 90E0      		ldi r25,0
 764 00a8 0E94 0000 		call fputc
 765 00ac 1150      		subi r17,lo8(-(-1))
 766 00ae 00C0      		rjmp .L13
 767               	.L18:
 299:../../Lib/cmdline.c ****   i = state->bufferMaxSize - state->CmdlineBufferLength;
 769               	.LM18:
 770 00b0 1C85      		ldd r17,Y+12
 771 00b2 8D85      		ldd r24,Y+13
 772 00b4 181B      		sub r17,r24
 773               	.L15:
 300:../../Lib/cmdline.c ****   while (i--)
 775               	.LM19:
 776 00b6 1123      		tst r17
 777 00b8 01F0      		breq .L19
 301:../../Lib/cmdline.c ****     fputc(ASCII_BS,  state->myStdInOut);
 779               	.LM20:
 780 00ba 6A8D      		ldd r22,Y+26
 781 00bc 7B8D      		ldd r23,Y+27
 782 00be 88E0      		ldi r24,lo8(8)
 783 00c0 90E0      		ldi r25,0
 784 00c2 0E94 0000 		call fputc
 785 00c6 1150      		subi r17,lo8(-(-1))
 786 00c8 00C0      		rjmp .L15
 787               	.L19:
 788               	/* epilogue start */
 302:../../Lib/cmdline.c **** }
 790               	.LM21:
 791 00ca DF91      		pop r29
 792 00cc CF91      		pop r28
 793 00ce 1F91      		pop r17
 794 00d0 0F91      		pop r16
 795 00d2 FF90      		pop r15
 796 00d4 EF90      		pop r14
 797 00d6 DF90      		pop r13
 798 00d8 0895      		ret
 800               	.Lscope2:
 802               		.stabd	78,0,0
 806               	cmdHistoryCopy:
 807               		.stabd	46,0,0
 305:../../Lib/cmdline.c **** {
 809               	.LM22:
 810               	.LFBB3:
 811 00da 1F93      		push r17
 812 00dc CF93      		push r28
 813 00de DF93      		push r29
 814               	/* prologue: function */
 815               	/* frame size = 0 */
 816               	/* stack size = 3 */
 817               	.L__stack_usage = 3
 818 00e0 EC01      		movw r28,r24
 306:../../Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 820               	.LM23:
 821 00e2 8889      		ldd r24,Y+16
 822 00e4 8823      		tst r24
 823 00e6 01F0      		breq .L21
 824               	.LBB4:
 308:../../Lib/cmdline.c ****     uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MAS
 826               	.LM24:
 827 00e8 1F85      		ldd r17,Y+15
 828 00ea 181B      		sub r17,r24
 829 00ec 1370      		andi r17,lo8(3)
 309:../../Lib/cmdline.c ****     memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
 831               	.LM25:
 832 00ee 4C85      		ldd r20,Y+12
 833 00f0 50E0      		ldi r21,0
 834 00f2 60E0      		ldi r22,0
 835 00f4 70E0      		ldi r23,0
 836 00f6 8881      		ld r24,Y
 837 00f8 9981      		ldd r25,Y+1
 838 00fa 0E94 0000 		call memset
 310:../../Lib/cmdline.c ****     strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
 840               	.LM26:
 841 00fe FE01      		movw r30,r28
 842 0100 E10F      		add r30,r17
 843 0102 F11D      		adc r31,__zero_reg__
 844 0104 E10F      		add r30,r17
 845 0106 F11D      		adc r31,__zero_reg__
 846 0108 6481      		ldd r22,Z+4
 847 010a 7581      		ldd r23,Z+5
 848 010c 8881      		ld r24,Y
 849 010e 9981      		ldd r25,Y+1
 850 0110 0E94 0000 		call strcpy
 851               	.L21:
 852               	.LBE4:
 313:../../Lib/cmdline.c ****   state->historyDepthIdx = 0;
 854               	.LM27:
 855 0114 188A      		std Y+16,__zero_reg__
 314:../../Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 857               	.LM28:
 858 0116 81E0      		ldi r24,lo8(1)
 859 0118 898B      		std Y+17,r24
 860               	/* epilogue start */
 315:../../Lib/cmdline.c **** }
 862               	.LM29:
 863 011a DF91      		pop r29
 864 011c CF91      		pop r28
 865 011e 1F91      		pop r17
 866 0120 0895      		ret
 871               	.Lscope3:
 873               		.stabd	78,0,0
 881               	.global	cmdStateConfigure
 883               	cmdStateConfigure:
 884               		.stabd	46,0,0
  59:../../Lib/cmdline.c **** {
 886               	.LM30:
 887               	.LFBB4:
 888 0122 8F92      		push r8
 889 0124 9F92      		push r9
 890 0126 AF92      		push r10
 891 0128 BF92      		push r11
 892 012a CF92      		push r12
 893 012c DF92      		push r13
 894 012e EF92      		push r14
 895 0130 0F93      		push r16
 896 0132 1F93      		push r17
 897 0134 CF93      		push r28
 898 0136 DF93      		push r29
 899               	/* prologue: function */
 900               	/* frame size = 0 */
 901               	/* stack size = 11 */
 902               	.L__stack_usage = 11
 903 0138 EC01      		movw r28,r24
 904 013a 6B01      		movw r12,r22
 905 013c 5A01      		movw r10,r20
 906 013e 4901      		movw r8,r18
  60:../../Lib/cmdline.c ****   memset(state, 0, sizeof(cmdState_t));
 908               	.LM31:
 909 0140 83E2      		ldi r24,lo8(35)
 910 0142 FE01      		movw r30,r28
 911               		0:
 912 0144 1192      		st Z+,__zero_reg__
 913 0146 8A95      		dec r24
 914 0148 01F4      		brne 0b
  61:../../Lib/cmdline.c ****   memset(buffPtr, 0, bufferTotalSize);
 916               	.LM32:
 917 014a 60E0      		ldi r22,0
 918 014c 70E0      		ldi r23,0
 919 014e C601      		movw r24,r12
 920 0150 0E94 0000 		call memset
  63:../../Lib/cmdline.c ****   state->CmdlineBuffer = buffPtr;
 922               	.LM33:
 923 0154 C882      		st Y,r12
 924 0156 D982      		std Y+1,r13
  64:../../Lib/cmdline.c ****   state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
 926               	.LM34:
 927 0158 B694      		lsr r11
 928 015a A794      		ror r10
 929 015c B694      		lsr r11
 930 015e A794      		ror r10
 931 0160 AC86      		std Y+12,r10
  66:../../Lib/cmdline.c ****   state->cliMode = mode;
 933               	.LM35:
 934 0162 E8A2      		std Y+32,r14
  67:../../Lib/cmdline.c ****   state->cmdList = commands;
 936               	.LM36:
 937 0164 09A3      		std Y+33,r16
 938 0166 1AA3      		std Y+34,r17
 939 0168 80E0      		ldi r24,0
 940 016a 90E0      		ldi r25,0
  74:../../Lib/cmdline.c ****     tmpPtr += state->bufferMaxSize;
 942               	.LM37:
 943 016c BB24      		clr r11
 944               	.L27:
 945 016e FE01      		movw r30,r28
 946 0170 E80F      		add r30,r24
 947 0172 F91F      		adc r31,r25
  73:../../Lib/cmdline.c ****     state->CmdlineHistory[i] = tmpPtr;
 949               	.LM38:
 950 0174 C482      		std Z+4,r12
 951 0176 D582      		std Z+5,r13
  74:../../Lib/cmdline.c ****     tmpPtr += state->bufferMaxSize;
 953               	.LM39:
 954 0178 CA0C      		add r12,r10
 955 017a DB1C      		adc r13,r11
 956 017c 0296      		adiw r24,2
  71:../../Lib/cmdline.c ****   for (i=0; i < CMD_STATE_HISTORY; i++)
 958               	.LM40:
 959 017e 8830      		cpi r24,8
 960 0180 9105      		cpc r25,__zero_reg__
 961 0182 01F4      		brne .L27
  76:../../Lib/cmdline.c ****   state->myStdInOut = stream;
 963               	.LM41:
 964 0184 8A8E      		std Y+26,r8
 965 0186 9B8E      		std Y+27,r9
 966               	/* epilogue start */
  77:../../Lib/cmdline.c **** }
 968               	.LM42:
 969 0188 DF91      		pop r29
 970 018a CF91      		pop r28
 971 018c 1F91      		pop r17
 972 018e 0F91      		pop r16
 973 0190 EF90      		pop r14
 974 0192 DF90      		pop r13
 975 0194 CF90      		pop r12
 976 0196 BF90      		pop r11
 977 0198 AF90      		pop r10
 978 019a 9F90      		pop r9
 979 019c 8F90      		pop r8
 980 019e 0895      		ret
 982               	.Lscope4:
 984               		.stabd	78,0,0
 988               	.global	cmdlineInputFunc
 990               	cmdlineInputFunc:
 991               		.stabd	46,0,0
  93:../../Lib/cmdline.c **** {
 993               	.LM43:
 994               	.LFBB5:
 995 01a0 AF92      		push r10
 996 01a2 BF92      		push r11
 997 01a4 CF92      		push r12
 998 01a6 DF92      		push r13
 999 01a8 EF92      		push r14
 1000 01aa FF92      		push r15
 1001 01ac 0F93      		push r16
 1002 01ae 1F93      		push r17
 1003 01b0 CF93      		push r28
 1004 01b2 DF93      		push r29
 1005 01b4 CDB7      		in r28,__SP_L__
 1006 01b6 DEB7      		in r29,__SP_H__
 1007 01b8 2797      		sbiw r28,7
 1008 01ba CDBF      		out __SP_L__,r28
 1009 01bc DEBF      		out __SP_H__,r29
 1010               	/* prologue: function */
 1011               	/* frame size = 7 */
 1012               	/* stack size = 17 */
 1013               	.L__stack_usage = 17
 1014 01be 482F      		mov r20,r24
 1015 01c0 8B01      		movw r16,r22
  99:../../Lib/cmdline.c ****   if(state->CmdlineInputVT100State == 2)
 1017               	.LM44:
 1018 01c2 DB01      		movw r26,r22
 1019 01c4 5296      		adiw r26,18
 1020 01c6 8C91      		ld r24,X
 1021 01c8 8230      		cpi r24,lo8(2)
 1022 01ca 01F0      		breq .+2
 1023 01cc 00C0      		rjmp .L29
 103:../../Lib/cmdline.c ****     switch(c)
 1025               	.LM45:
 1026 01ce 4234      		cpi r20,lo8(66)
 1027 01d0 01F0      		breq .L31
 1028 01d2 04F4      		brge .L32
 1029 01d4 4134      		cpi r20,lo8(65)
 1030 01d6 01F0      		breq .L33
 1031 01d8 00C0      		rjmp .L30
 1032               	.L32:
 1033 01da 4334      		cpi r20,lo8(67)
 1034 01dc 01F4      		brne .+2
 1035 01de 00C0      		rjmp .L34
 1036 01e0 4434      		cpi r20,lo8(68)
 1037 01e2 01F4      		brne .+2
 1038 01e4 00C0      		rjmp .L35
 1039 01e6 00C0      		rjmp .L30
 1040               	.L33:
 1041               	.LBB21:
 1042               	.LBB22:
 355:../../Lib/cmdline.c ****     if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
 1044               	.LM46:
 1045 01e8 FB01      		movw r30,r22
 1046 01ea 9089      		ldd r25,Z+16
 1047 01ec 9330      		cpi r25,lo8(3)
 1048 01ee 01F4      		brne .+2
 1049 01f0 00C0      		rjmp .L30
 358:../../Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
 1051               	.LM47:
 1052 01f2 8785      		ldd r24,Z+15
 1053 01f4 8150      		subi r24,lo8(-(-1))
 1054 01f6 891B      		sub r24,r25
 1055 01f8 8370      		andi r24,lo8(3)
 360:../../Lib/cmdline.c ****     if (state->CmdlineHistory[historyReadIdx][0] == 0)
 1057               	.LM48:
 1058 01fa E80F      		add r30,r24
 1059 01fc F11D      		adc r31,__zero_reg__
 1060 01fe E80F      		add r30,r24
 1061 0200 F11D      		adc r31,__zero_reg__
 1062 0202 6481      		ldd r22,Z+4
 1063 0204 7581      		ldd r23,Z+5
 1064 0206 DB01      		movw r26,r22
 1065 0208 8C91      		ld r24,X
 1066 020a 8823      		tst r24
 1067 020c 01F4      		brne .+2
 1068 020e 00C0      		rjmp .L30
 363:../../Lib/cmdline.c ****     state->historyDepthIdx++;
 1070               	.LM49:
 1071 0210 81E0      		ldi r24,lo8(1)
 1072 0212 890F      		add r24,r25
 364:../../Lib/cmdline.c ****     state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
 1074               	.LM50:
 1075 0214 8370      		andi r24,lo8(3)
 1076 0216 F801      		movw r30,r16
 1077 0218 808B      		std Z+16,r24
 1078 021a 00C0      		rjmp .L95
 1079               	.L31:
 1080               	.LBE22:
 1081               	.LBE21:
 1082               	.LBB23:
 1083               	.LBB24:
 377:../../Lib/cmdline.c ****     if (state->historyDepthIdx == 0)
 1085               	.LM51:
 1086 021c FB01      		movw r30,r22
 1087 021e 9089      		ldd r25,Z+16
 1088 0220 9923      		tst r25
 1089 0222 01F4      		brne .+2
 1090 0224 00C0      		rjmp .L30
 380:../../Lib/cmdline.c ****     state->historyDepthIdx --;
 1092               	.LM52:
 1093 0226 9150      		subi r25,lo8(-(-1))
 1094 0228 908B      		std Z+16,r25
 381:../../Lib/cmdline.c ****     historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
 1096               	.LM53:
 1097 022a 8785      		ldd r24,Z+15
 1098 022c 891B      		sub r24,r25
 1099 022e 8370      		andi r24,lo8(3)
 384:../../Lib/cmdline.c ****     state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
 1101               	.LM54:
 1102 0230 E80F      		add r30,r24
 1103 0232 F11D      		adc r31,__zero_reg__
 1104 0234 E80F      		add r30,r24
 1105 0236 F11D      		adc r31,__zero_reg__
 1106 0238 6481      		ldd r22,Z+4
 1107 023a 7581      		ldd r23,Z+5
 1108               	.L95:
 1109 023c FB01      		movw r30,r22
 1110               		0:
 1111 023e 0190      		ld __tmp_reg__,Z+
 1112 0240 0020      		tst __tmp_reg__
 1113 0242 01F4      		brne 0b
 1114 0244 3197      		sbiw r30,1
 1115 0246 E61B      		sub r30,r22
 1116 0248 F70B      		sbc r31,r23
 1117 024a D801      		movw r26,r16
 1118 024c 1D96      		adiw r26,13
 1119 024e EC93      		st X,r30
 1120 0250 1D97      		sbiw r26,13
 385:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos = state->CmdlineBufferLength;
 1122               	.LM55:
 1123 0252 1E96      		adiw r26,14
 1124 0254 EC93      		st X,r30
 1125 0256 1E97      		sbiw r26,14
 387:../../Lib/cmdline.c ****     state->bufferHistoryState = NOT_COPIED;
 1127               	.LM56:
 1128 0258 5196      		adiw r26,17
 1129 025a 1C92      		st X,__zero_reg__
 390:../../Lib/cmdline.c ****     cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
 1131               	.LM57:
 1132 025c C801      		movw r24,r16
 1133 025e 0E94 0000 		call cmdlineRepaint
 1134 0262 00C0      		rjmp .L30
 1135               	.L34:
 1136               	.LBE24:
 1137               	.LBE23:
 112:../../Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 1139               	.LM58:
 1140 0264 FB01      		movw r30,r22
 1141 0266 8189      		ldd r24,Z+17
 1142 0268 8111      		cpse r24,__zero_reg__
 1143 026a 00C0      		rjmp .L36
 113:../../Lib/cmdline.c ****         cmdHistoryCopy(state);
 1145               	.LM59:
 1146 026c CB01      		movw r24,r22
 1147 026e 0E94 0000 		call cmdHistoryCopy
 1148               	.L36:
 115:../../Lib/cmdline.c ****       if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
 1150               	.LM60:
 1151 0272 D801      		movw r26,r16
 1152 0274 1E96      		adiw r26,14
 1153 0276 8C91      		ld r24,X
 1154 0278 1E97      		sbiw r26,14
 1155 027a 1D96      		adiw r26,13
 1156 027c 9C91      		ld r25,X
 1157 027e 1D97      		sbiw r26,13
 1158 0280 5A96      		adiw r26,26
 1159 0282 6D91      		ld r22,X+
 1160 0284 7C91      		ld r23,X
 1161 0286 5B97      		sbiw r26,26+1
 1162 0288 8917      		cp r24,r25
 1163 028a 00F4      		brsh .L39
 118:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos++;
 1165               	.LM61:
 1166 028c 8F5F      		subi r24,lo8(-(1))
 1167 028e 1E96      		adiw r26,14
 1168 0290 8C93      		st X,r24
 120:../../Lib/cmdline.c ****         fputc(ASCII_ESC        , state->myStdInOut);
 1170               	.LM62:
 1171 0292 8BE1      		ldi r24,lo8(27)
 1172 0294 90E0      		ldi r25,0
 1173 0296 0E94 0000 		call fputc
 121:../../Lib/cmdline.c ****         fputc('['              , state->myStdInOut);
 1175               	.LM63:
 1176 029a F801      		movw r30,r16
 1177 029c 628D      		ldd r22,Z+26
 1178 029e 738D      		ldd r23,Z+27
 1179 02a0 8BE5      		ldi r24,lo8(91)
 1180 02a2 90E0      		ldi r25,0
 1181 02a4 0E94 0000 		call fputc
 122:../../Lib/cmdline.c ****         fputc(VT100_ARROWRIGHT , state->myStdInOut);
 1183               	.LM64:
 1184 02a8 D801      		movw r26,r16
 1185 02aa 5A96      		adiw r26,26
 1186 02ac 6D91      		ld r22,X+
 1187 02ae 7C91      		ld r23,X
 1188 02b0 5B97      		sbiw r26,26+1
 1189 02b2 83E4      		ldi r24,lo8(67)
 1190 02b4 90E0      		ldi r25,0
 1191 02b6 00C0      		rjmp .L96
 1192               	.L35:
 132:../../Lib/cmdline.c ****       if (state->bufferHistoryState == NOT_COPIED)
 1194               	.LM65:
 1195 02b8 FB01      		movw r30,r22
 1196 02ba 8189      		ldd r24,Z+17
 1197 02bc 8111      		cpse r24,__zero_reg__
 1198 02be 00C0      		rjmp .L38
 133:../../Lib/cmdline.c ****         cmdHistoryCopy(state);
 1200               	.LM66:
 1201 02c0 CB01      		movw r24,r22
 1202 02c2 0E94 0000 		call cmdHistoryCopy
 1203               	.L38:
 135:../../Lib/cmdline.c ****       if(state->CmdlineBufferEditPos)
 1205               	.LM67:
 1206 02c6 D801      		movw r26,r16
 1207 02c8 1E96      		adiw r26,14
 1208 02ca 8C91      		ld r24,X
 1209 02cc 1E97      		sbiw r26,14
 1210 02ce 5A96      		adiw r26,26
 1211 02d0 6D91      		ld r22,X+
 1212 02d2 7C91      		ld r23,X
 1213 02d4 5B97      		sbiw r26,26+1
 1214 02d6 8823      		tst r24
 1215 02d8 01F0      		breq .L39
 138:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 1217               	.LM68:
 1218 02da 8150      		subi r24,lo8(-(-1))
 1219 02dc 1E96      		adiw r26,14
 1220 02de 8C93      		st X,r24
 140:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1222               	.LM69:
 1223 02e0 88E0      		ldi r24,lo8(8)
 1224 02e2 90E0      		ldi r25,0
 1225 02e4 00C0      		rjmp .L96
 1226               	.L39:
 145:../../Lib/cmdline.c ****         fputc(ASCII_BEL        , state->myStdInOut);
 1228               	.LM70:
 1229 02e6 87E0      		ldi r24,lo8(7)
 1230 02e8 90E0      		ldi r25,0
 1231               	.L96:
 1232 02ea 0E94 0000 		call fputc
 1233               	.L30:
 152:../../Lib/cmdline.c ****     state->CmdlineInputVT100State = 0;
 1235               	.LM71:
 1236 02ee F801      		movw r30,r16
 1237 02f0 128A      		std Z+18,__zero_reg__
 153:../../Lib/cmdline.c ****     return;
 1239               	.LM72:
 1240 02f2 00C0      		rjmp .L28
 1241               	.L29:
 155:../../Lib/cmdline.c ****   else if(state->CmdlineInputVT100State == 1)
 1243               	.LM73:
 1244 02f4 8130      		cpi r24,lo8(1)
 1245 02f6 01F4      		brne .L41
 158:../../Lib/cmdline.c ****     if(c == '[')
 1247               	.LM74:
 1248 02f8 4B35      		cpi r20,lo8(91)
 1249 02fa 01F4      		brne .L41
 160:../../Lib/cmdline.c ****       state->CmdlineInputVT100State = 2;
 1251               	.LM75:
 1252 02fc 82E0      		ldi r24,lo8(2)
 1253 02fe 00C0      		rjmp .L98
 1254               	.L41:
 164:../../Lib/cmdline.c ****       state->CmdlineInputVT100State = 0;
 1256               	.LM76:
 1257 0300 F801      		movw r30,r16
 1258 0302 128A      		std Z+18,__zero_reg__
 174:../../Lib/cmdline.c ****   if (state->CmdlineBufferLength == state->bufferMaxSize)
 1260               	.LM77:
 1261 0304 8585      		ldd r24,Z+13
 1262 0306 9485      		ldd r25,Z+12
 1263 0308 8917      		cp r24,r25
 1264 030a 01F0      		breq .L42
 1265               	.L47:
 183:../../Lib/cmdline.c ****   if( (c >= 0x20) && (c < 0x7F) )
 1267               	.LM78:
 1268 030c 80EE      		ldi r24,lo8(-32)
 1269 030e 840F      		add r24,r20
 1270 0310 8F35      		cpi r24,lo8(95)
 1271 0312 00F0      		brlo .L43
 1272 0314 00C0      		rjmp .L99
 1273               	.L42:
 176:../../Lib/cmdline.c ****     state->CmdlineBufferLength--;
 1275               	.LM79:
 1276 0316 8150      		subi r24,lo8(-(-1))
 1277 0318 8587      		std Z+13,r24
 177:../../Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 1279               	.LM80:
 1280 031a 81E0      		ldi r24,lo8(1)
 1281               	.L45:
 177:../../Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 1283               	.LM81:
 1284 031c F801      		movw r30,r16
 1285 031e 9485      		ldd r25,Z+12
 1286 0320 8917      		cp r24,r25
 1287 0322 00F4      		brsh .L47
 179:../../Lib/cmdline.c ****       state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
 1289               	.LM82:
 1290 0324 D801      		movw r26,r16
 1291 0326 ED91      		ld r30,X+
 1292 0328 FC91      		ld r31,X
 1293 032a E80F      		add r30,r24
 1294 032c F11D      		adc r31,__zero_reg__
 1295 032e 9081      		ld r25,Z
 1296 0330 3197      		sbiw r30,1
 1297 0332 9083      		st Z,r25
 177:../../Lib/cmdline.c ****     for (i=1; i < state->bufferMaxSize; i++)
 1299               	.LM83:
 1300 0334 8F5F      		subi r24,lo8(-(1))
 1301 0336 00C0      		rjmp .L45
 1302               	.L43:
 185:../../Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 1304               	.LM84:
 1305 0338 D801      		movw r26,r16
 1306 033a 5196      		adiw r26,17
 1307 033c 8C91      		ld r24,X
 1308 033e 8111      		cpse r24,__zero_reg__
 1309 0340 00C0      		rjmp .L48
 186:../../Lib/cmdline.c ****       cmdHistoryCopy(state);
 1311               	.LM85:
 1312 0342 C801      		movw r24,r16
 1313 0344 4F83      		std Y+7,r20
 1314 0346 0E94 0000 		call cmdHistoryCopy
 1315 034a 4F81      		ldd r20,Y+7
 1316               	.L48:
 189:../../Lib/cmdline.c ****     if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 1318               	.LM86:
 1319 034c F801      		movw r30,r16
 1320 034e 8585      		ldd r24,Z+13
 1321 0350 9685      		ldd r25,Z+14
 1322 0352 9813      		cpse r25,r24
 1323 0354 00C0      		rjmp .L49
 192:../../Lib/cmdline.c ****       fputc(c                , state->myStdInOut);
 1325               	.LM87:
 1326 0356 628D      		ldd r22,Z+26
 1327 0358 738D      		ldd r23,Z+27
 1328 035a 842F      		mov r24,r20
 1329 035c 9927      		clr r25
 1330 035e 87FD      		sbrc r24,7
 1331 0360 9095      		com r25
 1332 0362 4F83      		std Y+7,r20
 1333 0364 0E94 0000 		call fputc
 194:../../Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 1335               	.LM88:
 1336 0368 D801      		movw r26,r16
 1337 036a ED91      		ld r30,X+
 1338 036c FC91      		ld r31,X
 1339 036e 1197      		sbiw r26,1
 1340 0370 1E96      		adiw r26,14
 1341 0372 8C91      		ld r24,X
 1342 0374 1E97      		sbiw r26,14
 1343 0376 91E0      		ldi r25,lo8(1)
 1344 0378 980F      		add r25,r24
 1345 037a 1E96      		adiw r26,14
 1346 037c 9C93      		st X,r25
 1347 037e 1E97      		sbiw r26,14
 1348 0380 E80F      		add r30,r24
 1349 0382 F11D      		adc r31,__zero_reg__
 1350 0384 4F81      		ldd r20,Y+7
 1351 0386 4083      		st Z,r20
 196:../../Lib/cmdline.c ****       state->CmdlineBufferLength++;
 1353               	.LM89:
 1354 0388 1D96      		adiw r26,13
 1355 038a 8C91      		ld r24,X
 1356 038c 1D97      		sbiw r26,13
 1357 038e 8F5F      		subi r24,lo8(-(1))
 1358 0390 1D96      		adiw r26,13
 1359 0392 8C93      		st X,r24
 1360 0394 00C0      		rjmp .L28
 1361               	.L49:
 203:../../Lib/cmdline.c ****       state->CmdlineBufferLength++;
 1363               	.LM90:
 1364 0396 8F5F      		subi r24,lo8(-(1))
 1365 0398 F801      		movw r30,r16
 1366 039a 8587      		std Z+13,r24
 1367               	.L50:
 204:../../Lib/cmdline.c ****       for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
 1369               	.LM91:
 1370 039c D801      		movw r26,r16
 1371 039e 1E96      		adiw r26,14
 1372 03a0 9C91      		ld r25,X
 1373 03a2 1E97      		sbiw r26,14
 1374 03a4 2D91      		ld r18,X+
 1375 03a6 3C91      		ld r19,X
 1376 03a8 1197      		sbiw r26,1
 1377 03aa 9817      		cp r25,r24
 1378 03ac 00F4      		brsh .L100
 205:../../Lib/cmdline.c ****         state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
 1380               	.LM92:
 1381 03ae D901      		movw r26,r18
 1382 03b0 A80F      		add r26,r24
 1383 03b2 B11D      		adc r27,__zero_reg__
 1384 03b4 FD01      		movw r30,r26
 1385 03b6 3197      		sbiw r30,1
 1386 03b8 9081      		ld r25,Z
 1387 03ba 9C93      		st X,r25
 204:../../Lib/cmdline.c ****       for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
 1389               	.LM93:
 1390 03bc 8150      		subi r24,lo8(-(-1))
 1391 03be 00C0      		rjmp .L50
 1392               	.L100:
 207:../../Lib/cmdline.c ****       state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
 1394               	.LM94:
 1395 03c0 81E0      		ldi r24,lo8(1)
 1396 03c2 890F      		add r24,r25
 1397 03c4 1E96      		adiw r26,14
 1398 03c6 8C93      		st X,r24
 1399 03c8 1E97      		sbiw r26,14
 1400 03ca F901      		movw r30,r18
 1401 03cc E90F      		add r30,r25
 1402 03ce F11D      		adc r31,__zero_reg__
 1403 03d0 4083      		st Z,r20
 209:../../Lib/cmdline.c ****       cmdlineRepaint(state, state->CmdlineBuffer);
 1405               	.LM95:
 1406 03d2 6D91      		ld r22,X+
 1407 03d4 7C91      		ld r23,X
 1408 03d6 C801      		movw r24,r16
 1409 03d8 0E94 0000 		call cmdlineRepaint
 211:../../Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1411               	.LM96:
 1412 03dc F801      		movw r30,r16
 1413 03de F684      		ldd r15,Z+14
 1414               	.L52:
 211:../../Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1416               	.LM97:
 1417 03e0 F801      		movw r30,r16
 1418 03e2 8585      		ldd r24,Z+13
 1419 03e4 F816      		cp r15,r24
 1420 03e6 00F0      		brlo .+2
 1421 03e8 00C0      		rjmp .L28
 212:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1423               	.LM98:
 1424 03ea D801      		movw r26,r16
 1425 03ec 5A96      		adiw r26,26
 1426 03ee 6D91      		ld r22,X+
 1427 03f0 7C91      		ld r23,X
 1428 03f2 5B97      		sbiw r26,26+1
 1429 03f4 88E0      		ldi r24,lo8(8)
 1430 03f6 90E0      		ldi r25,0
 1431 03f8 0E94 0000 		call fputc
 211:../../Lib/cmdline.c ****       for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1433               	.LM99:
 1434 03fc F394      		inc r15
 1435 03fe 00C0      		rjmp .L52
 1436               	.L99:
 216:../../Lib/cmdline.c ****   else if(c == ASCII_CR)
 1438               	.LM100:
 1439 0400 4D30      		cpi r20,lo8(13)
 1440 0402 01F0      		breq .+2
 1441 0404 00C0      		rjmp .L54
 218:../../Lib/cmdline.c ****     if (state->bufferHistoryState == NOT_COPIED)
 1443               	.LM101:
 1444 0406 D801      		movw r26,r16
 1445 0408 5196      		adiw r26,17
 1446 040a 8C91      		ld r24,X
 1447 040c 5197      		sbiw r26,17
 1448 040e 8111      		cpse r24,__zero_reg__
 1449 0410 00C0      		rjmp .L55
 1450               	.LBB25:
 1451               	.LBB26:
 319:../../Lib/cmdline.c ****   uint8_t i=state->historyDepthIdx;
 1453               	.LM102:
 1454 0412 5096      		adiw r26,16
 1455 0414 6C91      		ld r22,X
 1456 0416 5097      		sbiw r26,16
 1457 0418 1F96      		adiw r26,15
 1458 041a 7C91      		ld r23,X
 321:../../Lib/cmdline.c ****   if (state->historyDepthIdx != 0)
 1460               	.LM103:
 1461 041c 6111      		cpse r22,__zero_reg__
 1462 041e 00C0      		rjmp .L56
 1463               	.L59:
 329:../../Lib/cmdline.c ****   state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
 1465               	.LM104:
 1466 0420 F801      		movw r30,r16
 1467 0422 E70F      		add r30,r23
 1468 0424 F11D      		adc r31,__zero_reg__
 1469 0426 E70F      		add r30,r23
 1470 0428 F11D      		adc r31,__zero_reg__
 1471 042a D801      		movw r26,r16
 1472 042c 8D91      		ld r24,X+
 1473 042e 9C91      		ld r25,X
 1474 0430 1197      		sbiw r26,1
 1475 0432 8483      		std Z+4,r24
 1476 0434 9583      		std Z+5,r25
 331:../../Lib/cmdline.c ****   state->historyDepthIdx = 0;
 1478               	.LM105:
 1479 0436 5096      		adiw r26,16
 1480 0438 1C92      		st X,__zero_reg__
 1481 043a 5097      		sbiw r26,16
 332:../../Lib/cmdline.c ****   state->bufferHistoryState = COPIED;
 1483               	.LM106:
 1484 043c 81E0      		ldi r24,lo8(1)
 1485 043e 5196      		adiw r26,17
 1486 0440 8C93      		st X,r24
 1487 0442 00C0      		rjmp .L55
 1488               	.L56:
 323:../../Lib/cmdline.c ****     state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
 1490               	.LM107:
 1491 0444 872F      		mov r24,r23
 1492 0446 90E0      		ldi r25,0
 1493 0448 FC01      		movw r30,r24
 1494 044a E61B      		sub r30,r22
 1495 044c F109      		sbc r31,__zero_reg__
 1496 044e E370      		andi r30,3
 1497 0450 FF27      		clr r31
 1498 0452 3296      		adiw r30,2
 1499 0454 EE0F      		lsl r30
 1500 0456 FF1F      		rol r31
 1501 0458 E00F      		add r30,r16
 1502 045a F11F      		adc r31,r17
 1503 045c 2081      		ld r18,Z
 1504 045e 3181      		ldd r19,Z+1
 1505 0460 F801      		movw r30,r16
 1506 0462 2083      		st Z,r18
 1507 0464 3183      		std Z+1,r19
 1508               	.L57:
 324:../../Lib/cmdline.c ****     for ( ; i<CMD_STATE_HISTORY; i++)
 1510               	.LM108:
 1511 0466 6430      		cpi r22,lo8(4)
 1512 0468 00F4      		brsh .L59
 326:../../Lib/cmdline.c ****       state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHisto
 1514               	.LM109:
 1515 046a 9C01      		movw r18,r24
 1516 046c 261B      		sub r18,r22
 1517 046e 3109      		sbc r19,__zero_reg__
 1518 0470 F901      		movw r30,r18
 1519 0472 3197      		sbiw r30,1
 1520 0474 E370      		andi r30,3
 1521 0476 FF27      		clr r31
 1522 0478 3296      		adiw r30,2
 1523 047a EE0F      		lsl r30
 1524 047c FF1F      		rol r31
 1525 047e E00F      		add r30,r16
 1526 0480 F11F      		adc r31,r17
 1527 0482 4081      		ld r20,Z
 1528 0484 5181      		ldd r21,Z+1
 1529 0486 F901      		movw r30,r18
 1530 0488 E370      		andi r30,3
 1531 048a FF27      		clr r31
 1532 048c 3296      		adiw r30,2
 1533 048e EE0F      		lsl r30
 1534 0490 FF1F      		rol r31
 1535 0492 E00F      		add r30,r16
 1536 0494 F11F      		adc r31,r17
 1537 0496 4083      		st Z,r20
 1538 0498 5183      		std Z+1,r21
 324:../../Lib/cmdline.c ****     for ( ; i<CMD_STATE_HISTORY; i++)
 1540               	.LM110:
 1541 049a 6F5F      		subi r22,lo8(-(1))
 1542 049c 00C0      		rjmp .L57
 1543               	.L55:
 1544               	.LBE26:
 1545               	.LBE25:
 223:../../Lib/cmdline.c ****     fputc(ASCII_CR         , state->myStdInOut);
 1547               	.LM111:
 1548 049e D801      		movw r26,r16
 1549 04a0 5A96      		adiw r26,26
 1550 04a2 6D91      		ld r22,X+
 1551 04a4 7C91      		ld r23,X
 1552 04a6 5B97      		sbiw r26,26+1
 1553 04a8 8DE0      		ldi r24,lo8(13)
 1554 04aa 90E0      		ldi r25,0
 1555 04ac 0E94 0000 		call fputc
 224:../../Lib/cmdline.c ****     fputc(ASCII_LF         , state->myStdInOut);
 1557               	.LM112:
 1558 04b0 F801      		movw r30,r16
 1559 04b2 628D      		ldd r22,Z+26
 1560 04b4 738D      		ldd r23,Z+27
 1561 04b6 8AE0      		ldi r24,lo8(10)
 1562 04b8 90E0      		ldi r25,0
 1563 04ba 0E94 0000 		call fputc
 226:../../Lib/cmdline.c ****     state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
 1565               	.LM113:
 1566 04be D801      		movw r26,r16
 1567 04c0 ED91      		ld r30,X+
 1568 04c2 FC91      		ld r31,X
 1569 04c4 1197      		sbiw r26,1
 1570 04c6 1D96      		adiw r26,13
 1571 04c8 8C91      		ld r24,X
 1572 04ca 1D97      		sbiw r26,13
 1573 04cc 91E0      		ldi r25,lo8(1)
 1574 04ce 980F      		add r25,r24
 1575 04d0 1D96      		adiw r26,13
 1576 04d2 9C93      		st X,r25
 1577 04d4 1D97      		sbiw r26,13
 1578 04d6 E80F      		add r30,r24
 1579 04d8 F11D      		adc r31,__zero_reg__
 1580 04da 1082      		st Z,__zero_reg__
 227:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos++;
 1582               	.LM114:
 1583 04dc 1E96      		adiw r26,14
 1584 04de 8C91      		ld r24,X
 1585 04e0 1E97      		sbiw r26,14
 1586 04e2 8F5F      		subi r24,lo8(-(1))
 1587 04e4 1E96      		adiw r26,14
 1588 04e6 8C93      		st X,r24
 1589 04e8 1E97      		sbiw r26,14
 1590               	.LBB27:
 1591               	.LBB28:
 398:../../Lib/cmdline.c ****   state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer la
 1593               	.LM115:
 1594 04ea 8D91      		ld r24,X+
 1595 04ec 9C91      		ld r25,X
 1596 04ee 1197      		sbiw r26,1
 1597 04f0 1296      		adiw r26,2
 1598 04f2 8D93      		st X+,r24
 1599 04f4 9C93      		st X,r25
 1600 04f6 1397      		sbiw r26,2+1
 397:../../Lib/cmdline.c ****   uint8_t i=0;
 1602               	.LM116:
 1603 04f8 20E0      		ldi r18,0
 1604               	.L60:
 400:../../Lib/cmdline.c ****   while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the comman
 1606               	.LM117:
 1607 04fa C22E      		mov r12,r18
 1608 04fc D12C      		mov r13,__zero_reg__
 1609 04fe FC01      		movw r30,r24
 1610 0500 EC0D      		add r30,r12
 1611 0502 FD1D      		adc r31,r13
 1612 0504 3081      		ld r19,Z
 1613 0506 3F7D      		andi r19,lo8(-33)
 1614 0508 01F0      		breq .L101
 402:../../Lib/cmdline.c ****     i++;                                                              // i determines the cammand l
 1616               	.LM118:
 1617 050a 2F5F      		subi r18,lo8(-(1))
 1618 050c 00C0      		rjmp .L60
 1619               	.L101:
 404:../../Lib/cmdline.c ****   if(!i)                                                              // command was null or empty
 1621               	.LM119:
 1622 050e 2223      		tst r18
 1623 0510 01F4      		brne .+2
 1624 0512 00C0      		rjmp .L97
 410:../../Lib/cmdline.c ****   const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The 
 1626               	.LM120:
 1627 0514 F801      		movw r30,r16
 1628 0516 E1A0      		ldd r14,Z+33
 1629 0518 F2A0      		ldd r15,Z+34
 412:../../Lib/cmdline.c ****   memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need t
 1631               	.LM121:
 1632 051a 46E0      		ldi r20,lo8(6)
 1633 051c 50E0      		ldi r21,0
 1634 051e B701      		movw r22,r14
 1635 0520 CE01      		movw r24,r28
 1636 0522 0196      		adiw r24,1
 1637 0524 0E94 0000 		call memcpy_P
 1638               	.L67:
 416:../../Lib/cmdline.c ****     if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command match
 1640               	.LM122:
 1641 0528 A980      		ldd r10,Y+1
 1642 052a BA80      		ldd r11,Y+2
 1643 052c A601      		movw r20,r12
 1644 052e B501      		movw r22,r10
 1645 0530 D801      		movw r26,r16
 1646 0532 1296      		adiw r26,2
 1647 0534 8D91      		ld r24,X+
 1648 0536 9C91      		ld r25,X
 1649 0538 1397      		sbiw r26,2+1
 1650 053a 0E94 0000 		call strncmp_P
 1651 053e 892B      		or r24,r25
 1652 0540 01F4      		brne .L64
 418:../../Lib/cmdline.c ****       state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
 1654               	.LM123:
 1655 0542 8D81      		ldd r24,Y+5
 1656 0544 9E81      		ldd r25,Y+6
 1657 0546 F801      		movw r30,r16
 1658 0548 878B      		std Z+23,r24
 1659 054a 908F      		std Z+24,r25
 419:../../Lib/cmdline.c ****       state->command_str         = tmp.commandStr;
 1661               	.LM124:
 1662 054c A38A      		std Z+19,r10
 1663 054e B48A      		std Z+20,r11
 420:../../Lib/cmdline.c ****       state->command_help_str    = tmp.commandHelpStr;
 1665               	.LM125:
 1666 0550 8B81      		ldd r24,Y+3
 1667 0552 9C81      		ldd r25,Y+4
 1668 0554 858B      		std Z+21,r24
 1669 0556 968B      		std Z+22,r25
 1670               	.LBB29:
 1671               	.LBB30:
 342:../../Lib/cmdline.c ****     state->CmdlineBufferLength  = 0;
 1673               	.LM126:
 1674 0558 1586      		std Z+13,__zero_reg__
 343:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;     
 1676               	.LM127:
 1677 055a 1686      		std Z+14,__zero_reg__
 344:../../Lib/cmdline.c ****     state->bufferHistoryState   = NOT_COPIED;
 1679               	.LM128:
 1680 055c 118A      		std Z+17,__zero_reg__
 346:../../Lib/cmdline.c ****     if( strlen(state->CmdlineBuffer) )
 1682               	.LM129:
 1683 055e 0190      		ld __tmp_reg__,Z+
 1684 0560 F081      		ld r31,Z
 1685 0562 E02D      		mov r30,__tmp_reg__
 1686 0564 8081      		ld r24,Z
 1687 0566 8823      		tst r24
 1688 0568 01F4      		brne .+2
 1689 056a 00C0      		rjmp .L73
 348:../../Lib/cmdline.c ****       state->historyWrIdx++;
 1691               	.LM130:
 1692 056c D801      		movw r26,r16
 1693 056e 1F96      		adiw r26,15
 1694 0570 8C91      		ld r24,X
 1695 0572 1F97      		sbiw r26,15
 1696 0574 8F5F      		subi r24,lo8(-(1))
 349:../../Lib/cmdline.c ****       state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
 1698               	.LM131:
 1699 0576 8370      		andi r24,lo8(3)
 1700 0578 1F96      		adiw r26,15
 1701 057a 8C93      		st X,r24
 351:../../Lib/cmdline.c ****       state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
 1703               	.LM132:
 1704 057c F801      		movw r30,r16
 1705 057e E80F      		add r30,r24
 1706 0580 F11D      		adc r31,__zero_reg__
 1707 0582 E80F      		add r30,r24
 1708 0584 F11D      		adc r31,__zero_reg__
 1709 0586 8481      		ldd r24,Z+4
 1710 0588 9581      		ldd r25,Z+5
 1711 058a F801      		movw r30,r16
 1712 058c 8083      		st Z,r24
 1713 058e 9183      		std Z+1,r25
 1714 0590 00C0      		rjmp .L73
 1715               	.L64:
 1716               	.LBE30:
 1717               	.LBE29:
 424:../../Lib/cmdline.c ****     tmpPtr++;                                                         // Next command
 1719               	.LM133:
 1720 0592 F6E0      		ldi r31,6
 1721 0594 EF0E      		add r14,r31
 1722 0596 F11C      		adc r15,__zero_reg__
 425:../../Lib/cmdline.c ****     memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from fla
 1724               	.LM134:
 1725 0598 46E0      		ldi r20,lo8(6)
 1726 059a 50E0      		ldi r21,0
 1727 059c B701      		movw r22,r14
 1728 059e CE01      		movw r24,r28
 1729 05a0 0196      		adiw r24,1
 1730 05a2 0E94 0000 		call memcpy_P
 427:../../Lib/cmdline.c ****   while (tmp.commandStr != NULL);                                     // Last command on the list i
 1732               	.LM135:
 1733 05a6 8981      		ldd r24,Y+1
 1734 05a8 9A81      		ldd r25,Y+2
 1735 05aa 892B      		or r24,r25
 1736 05ac 01F0      		breq .+2
 1737 05ae 00C0      		rjmp .L67
 1738 05b0 20E0      		ldi r18,lo8(CmdlineNotice)
 1739 05b2 E22E      		mov r14,r18
 1740 05b4 20E0      		ldi r18,hi8(CmdlineNotice)
 1741 05b6 F22E      		mov r15,r18
 1742               	.L66:
 1743               	.LBB31:
 1744               	.LBB32:
 1745               	.LBB33:
 492:../../Lib/cmdline.c **** 
 493:../../Lib/cmdline.c **** void cmdlinePrintError(cmdState_t *state)
 494:../../Lib/cmdline.c **** {
 495:../../Lib/cmdline.c ****   char * ptr;
 496:../../Lib/cmdline.c **** 
 497:../../Lib/cmdline.c ****   // print a notice header
 498:../../Lib/cmdline.c ****   // (uint8_t*) cast used to avoid compiler warning
 499:../../Lib/cmdline.c ****   ptr = (char*)CmdlineNotice;
 500:../../Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 1747               	.LM136:
 1748 05b8 C701      		movw r24,r14
 1749 05ba F701      		movw r30,r14
 1750               	/* #APP */
 1751               	 ;  500 "../../Lib/cmdline.c" 1
 1752 05bc 2491      		lpm r18, Z
 1753               		
 1754               	 ;  0 "" 2
 1755               	/* #NOAPP */
 1756               	.LBE33:
 1757 05be 2223      		tst r18
 1758 05c0 01F0      		breq .L102
 1759               	.LBB34:
 501:../../Lib/cmdline.c ****     fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
 1761               	.LM137:
 1762 05c2 2FEF      		ldi r18,-1
 1763 05c4 E21A      		sub r14,r18
 1764 05c6 F20A      		sbc r15,r18
 1765 05c8 FC01      		movw r30,r24
 1766               	/* #APP */
 1767               	 ;  501 "../../Lib/cmdline.c" 1
 1768 05ca 8491      		lpm r24, Z
 1769               		
 1770               	 ;  0 "" 2
 1771               	/* #NOAPP */
 1772               	.LBE34:
 1773 05cc D801      		movw r26,r16
 1774 05ce 5A96      		adiw r26,26
 1775 05d0 6D91      		ld r22,X+
 1776 05d2 7C91      		ld r23,X
 1777 05d4 5B97      		sbiw r26,26+1
 1778 05d6 90E0      		ldi r25,0
 1779 05d8 0E94 0000 		call fputc
 1780 05dc 00C0      		rjmp .L66
 1781               	.L102:
 1782 05de D801      		movw r26,r16
 1783 05e0 ED90      		ld r14,X+
 1784 05e2 FC90      		ld r15,X
 1785               	.L69:
 502:../../Lib/cmdline.c ****   
 503:../../Lib/cmdline.c ****   // print the offending command
 504:../../Lib/cmdline.c ****   ptr = state->CmdlineBuffer;
 505:../../Lib/cmdline.c ****   while((*ptr) && (*ptr != ' '))
 1787               	.LM138:
 1788 05e4 F701      		movw r30,r14
 1789 05e6 8191      		ld r24,Z+
 1790 05e8 7F01      		movw r14,r30
 1791 05ea 982F      		mov r25,r24
 1792 05ec 9F7D      		andi r25,lo8(-33)
 1793 05ee D801      		movw r26,r16
 1794 05f0 5A96      		adiw r26,26
 1795 05f2 6D91      		ld r22,X+
 1796 05f4 7C91      		ld r23,X
 1797 05f6 5B97      		sbiw r26,26+1
 1798 05f8 9923      		tst r25
 1799 05fa 01F0      		breq .L103
 506:../../Lib/cmdline.c ****     fputc(*ptr++    , state->myStdInOut);
 1801               	.LM139:
 1802 05fc 9927      		clr r25
 1803 05fe 87FD      		sbrc r24,7
 1804 0600 9095      		com r25
 1805 0602 0E94 0000 		call fputc
 1806 0606 00C0      		rjmp .L69
 1807               	.L103:
 507:../../Lib/cmdline.c **** 
 508:../../Lib/cmdline.c ****   fputc(':'         , state->myStdInOut);
 1809               	.LM140:
 1810 0608 8AE3      		ldi r24,lo8(58)
 1811 060a 90E0      		ldi r25,0
 1812 060c 0E94 0000 		call fputc
 509:../../Lib/cmdline.c ****   fputc(' '         , state->myStdInOut);
 1814               	.LM141:
 1815 0610 F801      		movw r30,r16
 1816 0612 628D      		ldd r22,Z+26
 1817 0614 738D      		ldd r23,Z+27
 1818 0616 80E2      		ldi r24,lo8(32)
 1819 0618 90E0      		ldi r25,0
 1820 061a 0E94 0000 		call fputc
 510:../../Lib/cmdline.c **** 
 511:../../Lib/cmdline.c ****   // print the not-found message
 512:../../Lib/cmdline.c ****   // (uint8_t*) cast used to avoid compiler warning
 513:../../Lib/cmdline.c ****   ptr = (char*)CmdlineCmdNotFound;
 1822               	.LM142:
 1823 061e 90E0      		ldi r25,lo8(CmdlineCmdNotFound)
 1824 0620 E92E      		mov r14,r25
 1825 0622 90E0      		ldi r25,hi8(CmdlineCmdNotFound)
 1826 0624 F92E      		mov r15,r25
 1827               	.L71:
 1828               	.LBB35:
 514:../../Lib/cmdline.c ****   while(pgm_read_byte(ptr))
 1830               	.LM143:
 1831 0626 C701      		movw r24,r14
 1832 0628 F701      		movw r30,r14
 1833               	/* #APP */
 1834               	 ;  514 "../../Lib/cmdline.c" 1
 1835 062a 2491      		lpm r18, Z
 1836               		
 1837               	 ;  0 "" 2
 1838               	/* #NOAPP */
 1839 062c D801      		movw r26,r16
 1840 062e 5A96      		adiw r26,26
 1841 0630 6D91      		ld r22,X+
 1842 0632 7C91      		ld r23,X
 1843 0634 5B97      		sbiw r26,26+1
 1844               	.LBE35:
 1845 0636 2223      		tst r18
 1846 0638 01F0      		breq .L104
 1847               	.LBB36:
 515:../../Lib/cmdline.c ****     fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
 1849               	.LM144:
 1850 063a FFEF      		ldi r31,-1
 1851 063c EF1A      		sub r14,r31
 1852 063e FF0A      		sbc r15,r31
 1853 0640 FC01      		movw r30,r24
 1854               	/* #APP */
 1855               	 ;  515 "../../Lib/cmdline.c" 1
 1856 0642 8491      		lpm r24, Z
 1857               		
 1858               	 ;  0 "" 2
 1859               	/* #NOAPP */
 1860               	.LBE36:
 1861 0644 90E0      		ldi r25,0
 1862 0646 0E94 0000 		call fputc
 1863 064a 00C0      		rjmp .L71
 1864               	.L104:
 516:../../Lib/cmdline.c **** 
 517:../../Lib/cmdline.c ****   fputc('\r'        , state->myStdInOut);
 1866               	.LM145:
 1867 064c 8DE0      		ldi r24,lo8(13)
 1868 064e 90E0      		ldi r25,0
 1869 0650 0E94 0000 		call fputc
 518:../../Lib/cmdline.c ****   fputc('\n'        , state->myStdInOut);
 1871               	.LM146:
 1872 0654 F801      		movw r30,r16
 1873 0656 628D      		ldd r22,Z+26
 1874 0658 738D      		ldd r23,Z+27
 1875 065a 8AE0      		ldi r24,lo8(10)
 1876 065c 90E0      		ldi r25,0
 1877 065e 0E94 0000 		call fputc
 1878               	.L97:
 1879               	.LBE32:
 1880               	.LBE31:
 431:../../Lib/cmdline.c ****   cmdlinePrintPrompt(state);                                          // output a new prompt
 1882               	.LM147:
 1883 0662 C801      		movw r24,r16
 1884 0664 0E94 0000 		call cmdlinePrintPrompt
 1885               	.L73:
 1886               	.LBE28:
 1887               	.LBE27:
 231:../../Lib/cmdline.c ****     state->CmdlineBufferLength = 0;
 1889               	.LM148:
 1890 0668 D801      		movw r26,r16
 1891 066a 1D96      		adiw r26,13
 1892 066c 1C92      		st X,__zero_reg__
 1893 066e 1D97      		sbiw r26,13
 232:../../Lib/cmdline.c ****     state->CmdlineBufferEditPos = 0;
 1895               	.LM149:
 1896 0670 1E96      		adiw r26,14
 1897 0672 1C92      		st X,__zero_reg__
 1898 0674 00C0      		rjmp .L28
 1899               	.L54:
 234:../../Lib/cmdline.c ****   else if(c == ASCII_BS)
 1901               	.LM150:
 1902 0676 4830      		cpi r20,lo8(8)
 1903 0678 01F0      		breq .+2
 1904 067a 00C0      		rjmp .L74
 236:../../Lib/cmdline.c ****     if(state->CmdlineBufferEditPos)
 1906               	.LM151:
 1907 067c F801      		movw r30,r16
 1908 067e 8685      		ldd r24,Z+14
 1909 0680 8823      		tst r24
 1910 0682 01F4      		brne .+2
 1911 0684 00C0      		rjmp .L75
 239:../../Lib/cmdline.c ****       if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
 1913               	.LM152:
 1914 0686 9585      		ldd r25,Z+13
 1915 0688 8913      		cpse r24,r25
 1916 068a 00C0      		rjmp .L76
 243:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1918               	.LM153:
 1919 068c 628D      		ldd r22,Z+26
 1920 068e 738D      		ldd r23,Z+27
 1921 0690 88E0      		ldi r24,lo8(8)
 1922 0692 90E0      		ldi r25,0
 1923 0694 0E94 0000 		call fputc
 244:../../Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 1925               	.LM154:
 1926 0698 D801      		movw r26,r16
 1927 069a 5A96      		adiw r26,26
 1928 069c 6D91      		ld r22,X+
 1929 069e 7C91      		ld r23,X
 1930 06a0 5B97      		sbiw r26,26+1
 1931 06a2 80E2      		ldi r24,lo8(32)
 1932 06a4 90E0      		ldi r25,0
 1933 06a6 0E94 0000 		call fputc
 245:../../Lib/cmdline.c ****         fputc(ASCII_BS         , state->myStdInOut);
 1935               	.LM155:
 1936 06aa F801      		movw r30,r16
 1937 06ac 628D      		ldd r22,Z+26
 1938 06ae 738D      		ldd r23,Z+27
 1939 06b0 88E0      		ldi r24,lo8(8)
 1940 06b2 90E0      		ldi r25,0
 1941 06b4 0E94 0000 		call fputc
 247:../../Lib/cmdline.c ****         state->CmdlineBufferLength--;
 1943               	.LM156:
 1944 06b8 D801      		movw r26,r16
 1945 06ba 1D96      		adiw r26,13
 1946 06bc 8C91      		ld r24,X
 1947 06be 1D97      		sbiw r26,13
 1948 06c0 8150      		subi r24,lo8(-(-1))
 1949 06c2 1D96      		adiw r26,13
 1950 06c4 8C93      		st X,r24
 1951 06c6 1D97      		sbiw r26,13
 248:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 1953               	.LM157:
 1954 06c8 1E96      		adiw r26,14
 1955 06ca 8C91      		ld r24,X
 1956 06cc 1E97      		sbiw r26,14
 1957 06ce 8150      		subi r24,lo8(-(-1))
 1958 06d0 1E96      		adiw r26,14
 1959 06d2 8C93      		st X,r24
 1960 06d4 00C0      		rjmp .L28
 1961               	.L76:
 255:../../Lib/cmdline.c ****         state->CmdlineBufferLength--;
 1963               	.LM158:
 1964 06d6 9150      		subi r25,lo8(-(-1))
 1965 06d8 F801      		movw r30,r16
 1966 06da 9587      		std Z+13,r25
 256:../../Lib/cmdline.c ****         state->CmdlineBufferEditPos--;
 1968               	.LM159:
 1969 06dc 8150      		subi r24,lo8(-(-1))
 1970 06de 8687      		std Z+14,r24
 1971               	.L77:
 257:../../Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1973               	.LM160:
 1974 06e0 D801      		movw r26,r16
 1975 06e2 1D96      		adiw r26,13
 1976 06e4 9C91      		ld r25,X
 1977 06e6 1D97      		sbiw r26,13
 1978 06e8 6D91      		ld r22,X+
 1979 06ea 7C91      		ld r23,X
 1980 06ec 8917      		cp r24,r25
 1981 06ee 00F4      		brsh .L105
 258:../../Lib/cmdline.c ****           state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
 1983               	.LM161:
 1984 06f0 FB01      		movw r30,r22
 1985 06f2 E80F      		add r30,r24
 1986 06f4 F11D      		adc r31,__zero_reg__
 1987 06f6 9181      		ldd r25,Z+1
 1988 06f8 9083      		st Z,r25
 257:../../Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
 1990               	.LM162:
 1991 06fa 8F5F      		subi r24,lo8(-(1))
 1992 06fc 00C0      		rjmp .L77
 1993               	.L105:
 260:../../Lib/cmdline.c ****         cmdlineRepaint(state, state->CmdlineBuffer);
 1995               	.LM163:
 1996 06fe C801      		movw r24,r16
 1997 0700 0E94 0000 		call cmdlineRepaint
 262:../../Lib/cmdline.c ****         fputc(' '              , state->myStdInOut);
 1999               	.LM164:
 2000 0704 F801      		movw r30,r16
 2001 0706 628D      		ldd r22,Z+26
 2002 0708 738D      		ldd r23,Z+27
 2003 070a 80E2      		ldi r24,lo8(32)
 2004 070c 90E0      		ldi r25,0
 2005 070e 0E94 0000 		call fputc
 264:../../Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 2007               	.LM165:
 2008 0712 D801      		movw r26,r16
 2009 0714 1E96      		adiw r26,14
 2010 0716 FC90      		ld r15,X
 2011               	.L79:
 264:../../Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 2013               	.LM166:
 2014 0718 D801      		movw r26,r16
 2015 071a 1D96      		adiw r26,13
 2016 071c 2C91      		ld r18,X
 2017 071e 30E0      		ldi r19,0
 2018 0720 8F2D      		mov r24,r15
 2019 0722 90E0      		ldi r25,0
 2020 0724 2817      		cp r18,r24
 2021 0726 3907      		cpc r19,r25
 2022 0728 04F0      		brlt .L28
 265:../../Lib/cmdline.c ****           fputc(ASCII_BS       , state->myStdInOut);
 2024               	.LM167:
 2025 072a F801      		movw r30,r16
 2026 072c 628D      		ldd r22,Z+26
 2027 072e 738D      		ldd r23,Z+27
 2028 0730 88E0      		ldi r24,lo8(8)
 2029 0732 90E0      		ldi r25,0
 2030 0734 0E94 0000 		call fputc
 264:../../Lib/cmdline.c ****         for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
 2032               	.LM168:
 2033 0738 F394      		inc r15
 2034 073a 00C0      		rjmp .L79
 2035               	.L75:
 271:../../Lib/cmdline.c ****       fputc(ASCII_BEL          , state->myStdInOut);
 2037               	.LM169:
 2038 073c F801      		movw r30,r16
 2039 073e 628D      		ldd r22,Z+26
 2040 0740 738D      		ldd r23,Z+27
 2041 0742 87E0      		ldi r24,lo8(7)
 2042 0744 90E0      		ldi r25,0
 2043 0746 0E94 0000 		call fputc
 2044 074a 00C0      		rjmp .L28
 2045               	.L74:
 278:../../Lib/cmdline.c ****   else if(c == ASCII_ESC)
 2047               	.LM170:
 2048 074c 4B31      		cpi r20,lo8(27)
 2049 074e 01F4      		brne .L28
 280:../../Lib/cmdline.c ****     state->CmdlineInputVT100State = 1;
 2051               	.LM171:
 2052 0750 81E0      		ldi r24,lo8(1)
 2053               	.L98:
 2054 0752 D801      		movw r26,r16
 2055 0754 5296      		adiw r26,18
 2056 0756 8C93      		st X,r24
 2057               	.L28:
 2058               	/* epilogue start */
 282:../../Lib/cmdline.c **** }
 2060               	.LM172:
 2061 0758 2796      		adiw r28,7
 2062 075a CDBF      		out __SP_L__,r28
 2063 075c DEBF      		out __SP_H__,r29
 2064 075e DF91      		pop r29
 2065 0760 CF91      		pop r28
 2066 0762 1F91      		pop r17
 2067 0764 0F91      		pop r16
 2068 0766 FF90      		pop r15
 2069 0768 EF90      		pop r14
 2070 076a DF90      		pop r13
 2071 076c CF90      		pop r12
 2072 076e BF90      		pop r11
 2073 0770 AF90      		pop r10
 2074 0772 0895      		ret
 2090               	.Lscope5:
 2092               		.stabd	78,0,0
 2095               	.global	cmdLineGetLastArgIdx
 2097               	cmdLineGetLastArgIdx:
 2098               		.stabd	46,0,0
 519:../../Lib/cmdline.c **** }
 520:../../Lib/cmdline.c **** 
 521:../../Lib/cmdline.c **** 
 522:../../Lib/cmdline.c **** uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
 523:../../Lib/cmdline.c **** {
 2100               	.LM173:
 2101               	.LFBB6:
 2102               	/* prologue: function */
 2103               	/* frame size = 0 */
 2104               	/* stack size = 0 */
 2105               	.L__stack_usage = 0
 2106 0774 DC01      		movw r26,r24
 2107 0776 1296      		adiw r26,2
 2108 0778 ED91      		ld r30,X+
 2109 077a FC91      		ld r31,X
 2110 077c 1397      		sbiw r26,2+1
 524:../../Lib/cmdline.c ****   uint8_t result = 0;
 525:../../Lib/cmdline.c ****   uint8_t lastWhite = 1;
 2112               	.LM174:
 2113 077e 91E0      		ldi r25,lo8(1)
 524:../../Lib/cmdline.c ****   uint8_t result = 0;
 2115               	.LM175:
 2116 0780 80E0      		ldi r24,0
 2117               	.L107:
 526:../../Lib/cmdline.c ****   char *str = state->CmdlineExcBuffer;
 527:../../Lib/cmdline.c ****   while(*str != 0)
 2119               	.LM176:
 2120 0782 2191      		ld r18,Z+
 2121 0784 2223      		tst r18
 2122 0786 01F0      		breq .L112
 528:../../Lib/cmdline.c ****   {
 529:../../Lib/cmdline.c ****     if (*str == ' ')
 2124               	.LM177:
 2125 0788 2032      		cpi r18,lo8(32)
 2126 078a 01F4      		brne .L110
 530:../../Lib/cmdline.c ****     {
 531:../../Lib/cmdline.c ****       if (lastWhite == 0)
 2128               	.LM178:
 2129 078c 9111      		cpse r25,__zero_reg__
 2130 078e 00C0      		rjmp .L111
 532:../../Lib/cmdline.c ****         result++;
 2132               	.LM179:
 2133 0790 8F5F      		subi r24,lo8(-(1))
 2134 0792 00C0      		rjmp .L111
 2135               	.L110:
 533:../../Lib/cmdline.c ****       lastWhite = 1;
 534:../../Lib/cmdline.c ****     }
 535:../../Lib/cmdline.c ****     else
 536:../../Lib/cmdline.c ****       lastWhite = 0;
 2137               	.LM180:
 2138 0794 90E0      		ldi r25,0
 2139 0796 00C0      		rjmp .L107
 2140               	.L111:
 533:../../Lib/cmdline.c ****       lastWhite = 1;
 2142               	.LM181:
 2143 0798 91E0      		ldi r25,lo8(1)
 2144 079a 00C0      		rjmp .L107
 2145               	.L112:
 2146               	/* epilogue start */
 537:../../Lib/cmdline.c ****     str++;
 538:../../Lib/cmdline.c ****   }
 539:../../Lib/cmdline.c ****   return result;
 540:../../Lib/cmdline.c **** }
 2148               	.LM182:
 2149 079c 0895      		ret
 2155               	.Lscope6:
 2157               		.stabd	78,0,0
 2160               	.global	cmdlineMainLoop
 2162               	cmdlineMainLoop:
 2163               		.stabd	46,0,0
 435:../../Lib/cmdline.c **** {
 2165               	.LM183:
 2166               	.LFBB7:
 2167 079e 0F93      		push r16
 2168 07a0 1F93      		push r17
 2169 07a2 CF93      		push r28
 2170 07a4 DF93      		push r29
 2171               	/* prologue: function */
 2172               	/* frame size = 0 */
 2173               	/* stack size = 4 */
 2174               	.L__stack_usage = 4
 2175 07a6 EC01      		movw r28,r24
 437:../../Lib/cmdline.c ****   if(state->CmdlineExecFunction)                // do we have a command/function to be executed
 2177               	.LM184:
 2178 07a8 0F89      		ldd r16,Y+23
 2179 07aa 188D      		ldd r17,Y+24
 2180 07ac 0115      		cp r16,__zero_reg__
 2181 07ae 1105      		cpc r17,__zero_reg__
 2182 07b0 01F4      		brne .+2
 2183 07b2 00C0      		rjmp .L113
 439:../../Lib/cmdline.c ****     state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
 2185               	.LM185:
 2186 07b4 0E94 0000 		call cmdLineGetLastArgIdx
 2187 07b8 898F      		std Y+25,r24
 440:../../Lib/cmdline.c ****     result = state->CmdlineExecFunction(state); // run it
 2189               	.LM186:
 2190 07ba CE01      		movw r24,r28
 2191 07bc F801      		movw r30,r16
 2192 07be 1995      		eicall
 442:../../Lib/cmdline.c ****     switch(result)
 2194               	.LM187:
 2195 07c0 8230      		cpi r24,2
 2196 07c2 9105      		cpc r25,__zero_reg__
 2197 07c4 01F0      		breq .L116
 2198 07c6 00F4      		brsh .L117
 2199 07c8 0197      		sbiw r24,1
 2200 07ca 01F0      		breq .+2
 2201 07cc 00C0      		rjmp .L115
 445:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
 2203               	.LM188:
 2204 07ce 80E0      		ldi r24,lo8(__c.5464)
 2205 07d0 90E0      		ldi r25,hi8(__c.5464)
 2206 07d2 00C0      		rjmp .L121
 2207               	.L117:
 442:../../Lib/cmdline.c ****     switch(result)
 2209               	.LM189:
 2210 07d4 8430      		cpi r24,4
 2211 07d6 9105      		cpc r25,__zero_reg__
 2212 07d8 01F0      		breq .L119
 2213 07da 0597      		sbiw r24,5
 2214 07dc 01F0      		breq .+2
 2215 07de 00C0      		rjmp .L115
 458:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
 2217               	.LM190:
 2218 07e0 80E0      		ldi r24,lo8(__c.5478)
 2219 07e2 90E0      		ldi r25,hi8(__c.5478)
 2220 07e4 00C0      		rjmp .L121
 2221               	.L116:
 448:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
 2223               	.LM191:
 2224 07e6 80E0      		ldi r24,lo8(__c.5468)
 2225 07e8 90E0      		ldi r25,hi8(__c.5468)
 2226 07ea 9F93      		push r25
 2227 07ec 8F93      		push r24
 2228 07ee 8B8D      		ldd r24,Y+27
 2229 07f0 8F93      		push r24
 2230 07f2 8A8D      		ldd r24,Y+26
 2231 07f4 8F93      		push r24
 2232 07f6 0E94 0000 		call fprintf_P
 449:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_str);
 2234               	.LM192:
 2235 07fa 8C89      		ldd r24,Y+20
 2236 07fc 8F93      		push r24
 2237 07fe 8B89      		ldd r24,Y+19
 2238 0800 8F93      		push r24
 2239 0802 8B8D      		ldd r24,Y+27
 2240 0804 8F93      		push r24
 2241 0806 8A8D      		ldd r24,Y+26
 2242 0808 8F93      		push r24
 2243 080a 0E94 0000 		call fprintf_P
 450:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR(" "));
 2245               	.LM193:
 2246 080e 80E0      		ldi r24,lo8(__c.5470)
 2247 0810 90E0      		ldi r25,hi8(__c.5470)
 2248 0812 9F93      		push r25
 2249 0814 8F93      		push r24
 2250 0816 8B8D      		ldd r24,Y+27
 2251 0818 8F93      		push r24
 2252 081a 8A8D      		ldd r24,Y+26
 2253 081c 8F93      		push r24
 2254 081e 0E94 0000 		call fprintf_P
 451:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, state->command_help_str);
 2256               	.LM194:
 2257 0822 8E89      		ldd r24,Y+22
 2258 0824 8F93      		push r24
 2259 0826 8D89      		ldd r24,Y+21
 2260 0828 8F93      		push r24
 2261 082a 8B8D      		ldd r24,Y+27
 2262 082c 8F93      		push r24
 2263 082e 8A8D      		ldd r24,Y+26
 2264 0830 8F93      		push r24
 2265 0832 0E94 0000 		call fprintf_P
 452:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("\r\n"));
 2267               	.LM195:
 2268 0836 80E0      		ldi r24,lo8(__c.5472)
 2269 0838 90E0      		ldi r25,hi8(__c.5472)
 2270 083a 9F93      		push r25
 2271 083c 8F93      		push r24
 2272 083e 8B8D      		ldd r24,Y+27
 2273 0840 8F93      		push r24
 2274 0842 8A8D      		ldd r24,Y+26
 2275 0844 8F93      		push r24
 2276 0846 0E94 0000 		call fprintf_P
 453:../../Lib/cmdline.c ****         break;
 2278               	.LM196:
 2279 084a 8DB7      		in r24,__SP_L__
 2280 084c 9EB7      		in r25,__SP_H__
 2281 084e 4496      		adiw r24,20
 2282 0850 8DBF      		out __SP_L__,r24
 2283 0852 9EBF      		out __SP_H__,r25
 2284 0854 00C0      		rjmp .L115
 2285               	.L119:
 455:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
 2287               	.LM197:
 2288 0856 80E0      		ldi r24,lo8(__c.5475)
 2289 0858 90E0      		ldi r25,hi8(__c.5475)
 2290               	.L121:
 458:../../Lib/cmdline.c ****         fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
 2292               	.LM198:
 2293 085a 9F93      		push r25
 2294 085c 8F93      		push r24
 2295 085e 8B8D      		ldd r24,Y+27
 2296 0860 8F93      		push r24
 2297 0862 8A8D      		ldd r24,Y+26
 2298 0864 8F93      		push r24
 2299 0866 0E94 0000 		call fprintf_P
 459:../../Lib/cmdline.c ****         break;
 2301               	.LM199:
 2302 086a 0F90      		pop __tmp_reg__
 2303 086c 0F90      		pop __tmp_reg__
 2304 086e 0F90      		pop __tmp_reg__
 2305 0870 0F90      		pop __tmp_reg__
 2306               	.L115:
 463:../../Lib/cmdline.c ****     state->CmdlineExecFunction = NULL;          // reset
 2308               	.LM200:
 2309 0872 1F8A      		std Y+23,__zero_reg__
 2310 0874 188E      		std Y+24,__zero_reg__
 464:../../Lib/cmdline.c ****     state->command_str         = NULL;
 2312               	.LM201:
 2313 0876 1B8A      		std Y+19,__zero_reg__
 2314 0878 1C8A      		std Y+20,__zero_reg__
 465:../../Lib/cmdline.c ****     state->command_help_str    = NULL;
 2316               	.LM202:
 2317 087a 1D8A      		std Y+21,__zero_reg__
 2318 087c 1E8A      		std Y+22,__zero_reg__
 466:../../Lib/cmdline.c ****     cmdlinePrintPrompt(state);                  // output new prompt
 2320               	.LM203:
 2321 087e CE01      		movw r24,r28
 2322               	/* epilogue start */
 468:../../Lib/cmdline.c **** }
 2324               	.LM204:
 2325 0880 DF91      		pop r29
 2326 0882 CF91      		pop r28
 2327 0884 1F91      		pop r17
 2328 0886 0F91      		pop r16
 466:../../Lib/cmdline.c ****     cmdlinePrintPrompt(state);                  // output new prompt
 2330               	.LM205:
 2331 0888 0C94 0000 		jmp cmdlinePrintPrompt
 2332               	.L113:
 2333               	/* epilogue start */
 468:../../Lib/cmdline.c **** }
 2335               	.LM206:
 2336 088c DF91      		pop r29
 2337 088e CF91      		pop r28
 2338 0890 1F91      		pop r17
 2339 0892 0F91      		pop r16
 2340 0894 0895      		ret
 2345               	.Lscope7:
 2347               		.stabd	78,0,0
 2351               	.global	cmdlineGetArgStr
 2353               	cmdlineGetArgStr:
 2354               		.stabd	46,0,0
 541:../../Lib/cmdline.c **** 
 542:../../Lib/cmdline.c **** char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
 543:../../Lib/cmdline.c **** {
 2356               	.LM207:
 2357               	.LFBB8:
 2358               	/* prologue: function */
 2359               	/* frame size = 0 */
 2360               	/* stack size = 0 */
 2361               	.L__stack_usage = 0
 544:../../Lib/cmdline.c ****   // find the offset of argument number [argnum]
 545:../../Lib/cmdline.c ****   uint8_t idx=0;
 546:../../Lib/cmdline.c ****   uint8_t arg;
 547:../../Lib/cmdline.c ****   
 548:../../Lib/cmdline.c ****   // find the first non-whitespace character
 549:../../Lib/cmdline.c ****   while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
 2363               	.LM208:
 2364 0896 FB01      		movw r30,r22
 2365 0898 2281      		ldd r18,Z+2
 2366 089a 3381      		ldd r19,Z+3
 545:../../Lib/cmdline.c ****   uint8_t idx=0;
 2368               	.LM209:
 2369 089c 90E0      		ldi r25,0
 2370               	.L123:
 2372               	.LM210:
 2373 089e F901      		movw r30,r18
 2374 08a0 E90F      		add r30,r25
 2375 08a2 F11D      		adc r31,__zero_reg__
 2376 08a4 4081      		ld r20,Z
 2377 08a6 4032      		cpi r20,lo8(32)
 2378 08a8 01F4      		brne .L131
 2380               	.LM211:
 2381 08aa 9F5F      		subi r25,lo8(-(1))
 2382 08ac 00C0      		rjmp .L123
 2383               	.L131:
 2385               	.LM212:
 2386 08ae 40E0      		ldi r20,0
 2387               	.L125:
 550:../../Lib/cmdline.c ****   
 551:../../Lib/cmdline.c ****   // we are at the first argument
 552:../../Lib/cmdline.c ****   for(arg=0; arg<argnum; arg++)
 2389               	.LM213:
 2390 08b0 4817      		cp r20,r24
 2391 08b2 01F0      		breq .L132
 2392               	.L130:
 553:../../Lib/cmdline.c ****   {
 554:../../Lib/cmdline.c ****     // find the next whitespace character
 555:../../Lib/cmdline.c ****     while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
 2394               	.LM214:
 2395 08b4 F901      		movw r30,r18
 2396 08b6 E90F      		add r30,r25
 2397 08b8 F11D      		adc r31,__zero_reg__
 2398 08ba 5081      		ld r21,Z
 2399 08bc 5F7D      		andi r21,lo8(-33)
 2400 08be 01F0      		breq .L127
 2401 08c0 9F5F      		subi r25,lo8(-(1))
 2402 08c2 00C0      		rjmp .L130
 2403               	.L127:
 556:../../Lib/cmdline.c ****     // find the first non-whitespace character
 557:../../Lib/cmdline.c ****     while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
 2405               	.LM215:
 2406 08c4 F901      		movw r30,r18
 2407 08c6 E90F      		add r30,r25
 2408 08c8 F11D      		adc r31,__zero_reg__
 2409 08ca 5081      		ld r21,Z
 2410 08cc 5032      		cpi r21,lo8(32)
 2411 08ce 01F4      		brne .L133
 2413               	.LM216:
 2414 08d0 9F5F      		subi r25,lo8(-(1))
 2415 08d2 00C0      		rjmp .L127
 2416               	.L133:
 552:../../Lib/cmdline.c ****   for(arg=0; arg<argnum; arg++)
 2418               	.LM217:
 2419 08d4 4F5F      		subi r20,lo8(-(1))
 2420 08d6 00C0      		rjmp .L125
 2421               	.L132:
 558:../../Lib/cmdline.c ****   }
 559:../../Lib/cmdline.c ****   // we are at the requested argument or the end of the buffer
 560:../../Lib/cmdline.c ****   return &state->CmdlineExcBuffer[idx];
 561:../../Lib/cmdline.c **** }
 2423               	.LM218:
 2424 08d8 A901      		movw r20,r18
 2425 08da 490F      		add r20,r25
 2426 08dc 511D      		adc r21,__zero_reg__
 2427 08de CA01      		movw r24,r20
 2428 08e0 0895      		ret
 2434               	.Lscope8:
 2436               		.stabd	78,0,0
 2440               	.global	cmdlineGetArgInt
 2442               	cmdlineGetArgInt:
 2443               		.stabd	46,0,0
 562:../../Lib/cmdline.c **** 
 563:../../Lib/cmdline.c **** // return argument [argnum] interpreted as a decimal integer
 564:../../Lib/cmdline.c **** long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
 565:../../Lib/cmdline.c **** {
 2445               	.LM219:
 2446               	.LFBB9:
 2447 08e2 CF93      		push r28
 2448 08e4 DF93      		push r29
 2449 08e6 1F92      		push __zero_reg__
 2450 08e8 1F92      		push __zero_reg__
 2451 08ea CDB7      		in r28,__SP_L__
 2452 08ec DEB7      		in r29,__SP_H__
 2453               	/* prologue: function */
 2454               	/* frame size = 2 */
 2455               	/* stack size = 4 */
 2456               	.L__stack_usage = 4
 566:../../Lib/cmdline.c ****   char* endptr;
 567:../../Lib/cmdline.c ****   return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
 2458               	.LM220:
 2459 08ee 0E94 0000 		call cmdlineGetArgStr
 2460 08f2 4AE0      		ldi r20,lo8(10)
 2461 08f4 50E0      		ldi r21,0
 2462 08f6 BE01      		movw r22,r28
 2463 08f8 6F5F      		subi r22,-1
 2464 08fa 7F4F      		sbci r23,-1
 2465 08fc 0E94 0000 		call strtol
 2466               	/* epilogue start */
 568:../../Lib/cmdline.c **** }
 2468               	.LM221:
 2469 0900 0F90      		pop __tmp_reg__
 2470 0902 0F90      		pop __tmp_reg__
 2471 0904 DF91      		pop r29
 2472 0906 CF91      		pop r28
 2473 0908 0895      		ret
 2478               	.Lscope9:
 2480               		.stabd	78,0,0
 2484               	.global	cmdlineGetArgHex
 2486               	cmdlineGetArgHex:
 2487               		.stabd	46,0,0
 569:../../Lib/cmdline.c **** 
 570:../../Lib/cmdline.c **** // return argument [argnum] interpreted as a hex integer
 571:../../Lib/cmdline.c **** long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
 572:../../Lib/cmdline.c **** {
 2489               	.LM222:
 2490               	.LFBB10:
 2491 090a CF93      		push r28
 2492 090c DF93      		push r29
 2493 090e 1F92      		push __zero_reg__
 2494 0910 1F92      		push __zero_reg__
 2495 0912 CDB7      		in r28,__SP_L__
 2496 0914 DEB7      		in r29,__SP_H__
 2497               	/* prologue: function */
 2498               	/* frame size = 2 */
 2499               	/* stack size = 4 */
 2500               	.L__stack_usage = 4
 573:../../Lib/cmdline.c ****   char* endptr;
 574:../../Lib/cmdline.c ****   return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
 2502               	.LM223:
 2503 0916 0E94 0000 		call cmdlineGetArgStr
 2504 091a 40E1      		ldi r20,lo8(16)
 2505 091c 50E0      		ldi r21,0
 2506 091e BE01      		movw r22,r28
 2507 0920 6F5F      		subi r22,-1
 2508 0922 7F4F      		sbci r23,-1
 2509 0924 0E94 0000 		call strtol
 2510               	/* epilogue start */
 575:../../Lib/cmdline.c **** }
 2512               	.LM224:
 2513 0928 0F90      		pop __tmp_reg__
 2514 092a 0F90      		pop __tmp_reg__
 2515 092c DF91      		pop r29
 2516 092e CF91      		pop r28
 2517 0930 0895      		ret
 2522               	.Lscope10:
 2524               		.stabd	78,0,0
 2527               	.global	cmdPrintHelp
 2529               	cmdPrintHelp:
 2530               		.stabd	46,0,0
 576:../../Lib/cmdline.c **** 
 577:../../Lib/cmdline.c **** void cmdPrintHelp(cmdState_t *state)
 578:../../Lib/cmdline.c **** {
 2532               	.LM225:
 2533               	.LFBB11:
 2534 0932 AF92      		push r10
 2535 0934 BF92      		push r11
 2536 0936 CF92      		push r12
 2537 0938 DF92      		push r13
 2538 093a EF92      		push r14
 2539 093c FF92      		push r15
 2540 093e 0F93      		push r16
 2541 0940 1F93      		push r17
 2542 0942 CF93      		push r28
 2543 0944 DF93      		push r29
 2544 0946 00D0      		rcall .
 2545 0948 00D0      		rcall .
 2546 094a CDB7      		in r28,__SP_L__
 2547 094c DEB7      		in r29,__SP_H__
 2548               	/* prologue: function */
 2549               	/* frame size = 6 */
 2550               	/* stack size = 16 */
 2551               	.L__stack_usage = 16
 2552 094e 8C01      		movw r16,r24
 579:../../Lib/cmdline.c ****   command_t  tmp;
 580:../../Lib/cmdline.c ****   const command_t *tmpPtr = state->cmdList;
 2554               	.LM226:
 2555 0950 FC01      		movw r30,r24
 2556 0952 E1A0      		ldd r14,Z+33
 2557 0954 F2A0      		ldd r15,Z+34
 581:../../Lib/cmdline.c ****   
 582:../../Lib/cmdline.c ****   memcpy_P(&tmp, tmpPtr, sizeof(command_t));
 2559               	.LM227:
 2560 0956 46E0      		ldi r20,lo8(6)
 2561 0958 50E0      		ldi r21,0
 2562 095a B701      		movw r22,r14
 2563 095c CE01      		movw r24,r28
 2564 095e 0196      		adiw r24,1
 2565 0960 0E94 0000 		call memcpy_P
 583:../../Lib/cmdline.c ****   do
 584:../../Lib/cmdline.c ****   {
 585:../../Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandStr);
 586:../../Lib/cmdline.c ****     fprintf_P(state->myStdInOut, PSTR("\t"));
 2567               	.LM228:
 2568 0964 80E0      		ldi r24,lo8(__c.5566)
 2569 0966 A82E      		mov r10,r24
 2570 0968 80E0      		ldi r24,hi8(__c.5566)
 2571 096a B82E      		mov r11,r24
 587:../../Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandHelpStr);
 588:../../Lib/cmdline.c ****     fprintf_P(state->myStdInOut, PSTR("\r\n"));
 2573               	.LM229:
 2574 096c 90E0      		ldi r25,lo8(__c.5568)
 2575 096e C92E      		mov r12,r25
 2576 0970 90E0      		ldi r25,hi8(__c.5568)
 2577 0972 D92E      		mov r13,r25
 2578               	.L138:
 585:../../Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandStr);
 2580               	.LM230:
 2581 0974 8A81      		ldd r24,Y+2
 2582 0976 8F93      		push r24
 2583 0978 8981      		ldd r24,Y+1
 2584 097a 8F93      		push r24
 2585 097c F801      		movw r30,r16
 2586 097e 838D      		ldd r24,Z+27
 2587 0980 8F93      		push r24
 2588 0982 828D      		ldd r24,Z+26
 2589 0984 8F93      		push r24
 2590 0986 0E94 0000 		call fprintf_P
 586:../../Lib/cmdline.c ****     fprintf_P(state->myStdInOut, PSTR("\t"));
 2592               	.LM231:
 2593 098a BF92      		push r11
 2594 098c AF92      		push r10
 2595 098e F801      		movw r30,r16
 2596 0990 838D      		ldd r24,Z+27
 2597 0992 8F93      		push r24
 2598 0994 828D      		ldd r24,Z+26
 2599 0996 8F93      		push r24
 2600 0998 0E94 0000 		call fprintf_P
 587:../../Lib/cmdline.c ****     fprintf_P(state->myStdInOut, tmp.commandHelpStr);
 2602               	.LM232:
 2603 099c 8C81      		ldd r24,Y+4
 2604 099e 8F93      		push r24
 2605 09a0 8B81      		ldd r24,Y+3
 2606 09a2 8F93      		push r24
 2607 09a4 F801      		movw r30,r16
 2608 09a6 838D      		ldd r24,Z+27
 2609 09a8 8F93      		push r24
 2610 09aa 828D      		ldd r24,Z+26
 2611 09ac 8F93      		push r24
 2612 09ae 0E94 0000 		call fprintf_P
 2614               	.LM233:
 2615 09b2 DF92      		push r13
 2616 09b4 CF92      		push r12
 2617 09b6 F801      		movw r30,r16
 2618 09b8 838D      		ldd r24,Z+27
 2619 09ba 8F93      		push r24
 2620 09bc 828D      		ldd r24,Z+26
 2621 09be 8F93      		push r24
 2622 09c0 0E94 0000 		call fprintf_P
 589:../../Lib/cmdline.c **** 
 590:../../Lib/cmdline.c ****     tmpPtr++;
 2624               	.LM234:
 2625 09c4 F6E0      		ldi r31,6
 2626 09c6 EF0E      		add r14,r31
 2627 09c8 F11C      		adc r15,__zero_reg__
 591:../../Lib/cmdline.c ****     memcpy_P(&tmp, tmpPtr, sizeof(command_t));
 2629               	.LM235:
 2630 09ca 46E0      		ldi r20,lo8(6)
 2631 09cc 50E0      		ldi r21,0
 2632 09ce B701      		movw r22,r14
 2633 09d0 CE01      		movw r24,r28
 2634 09d2 0196      		adiw r24,1
 2635 09d4 0E94 0000 		call memcpy_P
 592:../../Lib/cmdline.c ****   }
 593:../../Lib/cmdline.c ****   while (tmp.commandFun != NULL);
 2637               	.LM236:
 2638 09d8 CDBF      		out __SP_L__,r28
 2639 09da DEBF      		out __SP_H__,r29
 2640 09dc 8D81      		ldd r24,Y+5
 2641 09de 9E81      		ldd r25,Y+6
 2642 09e0 892B      		or r24,r25
 2643 09e2 01F4      		brne .L138
 2644               	/* epilogue start */
 594:../../Lib/cmdline.c **** }
 2646               	.LM237:
 2647 09e4 2696      		adiw r28,6
 2648 09e6 CDBF      		out __SP_L__,r28
 2649 09e8 DEBF      		out __SP_H__,r29
 2650 09ea DF91      		pop r29
 2651 09ec CF91      		pop r28
 2652 09ee 1F91      		pop r17
 2653 09f0 0F91      		pop r16
 2654 09f2 FF90      		pop r15
 2655 09f4 EF90      		pop r14
 2656 09f6 DF90      		pop r13
 2657 09f8 CF90      		pop r12
 2658 09fa BF90      		pop r11
 2659 09fc AF90      		pop r10
 2660 09fe 0895      		ret
 2666               	.Lscope11:
 2668               		.stabd	78,0,0
 2669               		.section	.progmem.data,"a",@progbits
 2672               	__c.5568:
 2673 0000 0D0A 00   		.string	"\r\n"
 2676               	__c.5566:
 2677 0003 0900      		.string	"\t"
 2680               	__c.5478:
 2681 0005 4F70 6572 		.string	"Operation not allowed\r\n"
 2681      6174 696F 
 2681      6E20 6E6F 
 2681      7420 616C 
 2681      6C6F 7765 
 2684               	__c.5475:
 2685 001d 4F70 6572 		.string	"Operation failed\r\n"
 2685      6174 696F 
 2685      6E20 6661 
 2685      696C 6564 
 2685      0D0A 00
 2688               	__c.5472:
 2689 0030 0D0A 00   		.string	"\r\n"
 2692               	__c.5470:
 2693 0033 2000      		.string	" "
 2696               	__c.5468:
 2697 0035 5379 6E74 		.string	"Syntax Error. Use: "
 2697      6178 2045 
 2697      7272 6F72 
 2697      2E20 5573 
 2697      653A 2000 
 2700               	__c.5464:
 2701 0049 4F4B 0D0A 		.string	"OK\r\n"
 2701      00
 2702               	.global	CmdlineCmdNotFound
 2705               	CmdlineCmdNotFound:
 2706 004e 2320 6E6B 		.string	"# nk"
 2706      00
 2707               	.global	CmdlineNotice
 2710               	CmdlineNotice:
 2711 0053 636D 646C 		.string	"cmdline: "
 2711      696E 653A 
 2711      2000 
 2712               	.global	CmdlinePromptConfigure
 2715               	CmdlinePromptConfigure:
 2716 005d 446F 6D4F 		.string	"DomOs@"
 2716      7340 00
 2717               	.global	CmdlinePromptEnable
 2720               	CmdlinePromptEnable:
 2721 0064 446F 6D4F 		.string	"DomOs#"
 2721      7323 00
 2722               	.global	CmdlinePromptNormal
 2725               	CmdlinePromptNormal:
 2726 006b 446F 6D4F 		.string	"DomOs>"
 2726      733E 00
 2727               		.comm	czasRtc,7,1
 2728               		.comm	rollers,2,1
 2729               		.comm	sockets,2,1
 2730               		.comm	tcpDebugLevel,1,1
 2731               		.comm	tcpDebugStream,2,1
 2732               		.comm	IpMyConfig,15,1
 2733               		.comm	udpDbgLevel,1,1
 2734               		.comm	udpDbgStream,2,1
 2735               		.comm	udpSocket,2,1
 2736               		.comm	icmpDebugLevel,1,1
 2737               		.comm	icmpDebug,2,1
 2738               		.comm	arpDebugLevel,1,1
 2739               		.comm	arpDebug,2,1
 2740               		.comm	plen,2,1
 2741               		.comm	nicState,14,1
 2742               		.comm	klastry,128,1
 2743               		.comm	xSemaphoreRs485,2,1
 2744               		.comm	lockSensors,2,1
 2745               		.comm	portB,1,1
 2746               		.comm	portA,1,1
 2747               		.comm	xSemaphoreSpiSS,2,1
 2748               		.comm	wwwport,1,1
 2776               		.text
 2778               	.Letext0:
 2779               		.ident	"GCC: (GNU) 4.8.2"
 2780               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 cmdline.c
     /tmp/ccM9sy3i.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccM9sy3i.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccM9sy3i.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccM9sy3i.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccM9sy3i.s:6      *ABS*:000000000000003a __RAMPY__
     /tmp/ccM9sy3i.s:7      *ABS*:0000000000000039 __RAMPX__
     /tmp/ccM9sy3i.s:8      *ABS*:0000000000000038 __RAMPD__
     /tmp/ccM9sy3i.s:9      *ABS*:0000000000000034 __CCP__
     /tmp/ccM9sy3i.s:10     *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccM9sy3i.s:11     *ABS*:0000000000000001 __zero_reg__
     /tmp/ccM9sy3i.s:599    .text:0000000000000000 cmdlinePrintPrompt
     /tmp/ccM9sy3i.s:2725   .progmem.data:000000000000006b CmdlinePromptNormal
     /tmp/ccM9sy3i.s:2720   .progmem.data:0000000000000064 CmdlinePromptEnable
     /tmp/ccM9sy3i.s:2715   .progmem.data:000000000000005d CmdlinePromptConfigure
     /tmp/ccM9sy3i.s:692    .text:000000000000004e cmdlineRepaint
     /tmp/ccM9sy3i.s:806    .text:00000000000000da cmdHistoryCopy
     /tmp/ccM9sy3i.s:883    .text:0000000000000122 cmdStateConfigure
     /tmp/ccM9sy3i.s:990    .text:00000000000001a0 cmdlineInputFunc
     /tmp/ccM9sy3i.s:2710   .progmem.data:0000000000000053 CmdlineNotice
     /tmp/ccM9sy3i.s:2705   .progmem.data:000000000000004e CmdlineCmdNotFound
     /tmp/ccM9sy3i.s:2097   .text:0000000000000774 cmdLineGetLastArgIdx
     /tmp/ccM9sy3i.s:2162   .text:000000000000079e cmdlineMainLoop
     /tmp/ccM9sy3i.s:2700   .progmem.data:0000000000000049 __c.5464
     /tmp/ccM9sy3i.s:2680   .progmem.data:0000000000000005 __c.5478
     /tmp/ccM9sy3i.s:2696   .progmem.data:0000000000000035 __c.5468
     /tmp/ccM9sy3i.s:2692   .progmem.data:0000000000000033 __c.5470
     /tmp/ccM9sy3i.s:2688   .progmem.data:0000000000000030 __c.5472
     /tmp/ccM9sy3i.s:2684   .progmem.data:000000000000001d __c.5475
     /tmp/ccM9sy3i.s:2353   .text:0000000000000896 cmdlineGetArgStr
     /tmp/ccM9sy3i.s:2442   .text:00000000000008e2 cmdlineGetArgInt
     /tmp/ccM9sy3i.s:2486   .text:000000000000090a cmdlineGetArgHex
     /tmp/ccM9sy3i.s:2529   .text:0000000000000932 cmdPrintHelp
     /tmp/ccM9sy3i.s:2676   .progmem.data:0000000000000003 __c.5566
     /tmp/ccM9sy3i.s:2672   .progmem.data:0000000000000000 __c.5568
                            *COM*:0000000000000007 czasRtc
                            *COM*:0000000000000002 rollers
                            *COM*:0000000000000002 sockets
                            *COM*:0000000000000001 tcpDebugLevel
                            *COM*:0000000000000002 tcpDebugStream
                            *COM*:000000000000000f IpMyConfig
                            *COM*:0000000000000001 udpDbgLevel
                            *COM*:0000000000000002 udpDbgStream
                            *COM*:0000000000000002 udpSocket
                            *COM*:0000000000000001 icmpDebugLevel
                            *COM*:0000000000000002 icmpDebug
                            *COM*:0000000000000001 arpDebugLevel
                            *COM*:0000000000000002 arpDebug
                            *COM*:0000000000000002 plen
                            *COM*:000000000000000e nicState
                            *COM*:0000000000000080 klastry
                            *COM*:0000000000000002 xSemaphoreRs485
                            *COM*:0000000000000002 lockSensors
                            *COM*:0000000000000001 portB
                            *COM*:0000000000000001 portA
                            *COM*:0000000000000002 xSemaphoreSpiSS
                            *COM*:0000000000000001 wwwport

UNDEFINED SYMBOLS
fputc
memset
strcpy
memcpy_P
strncmp_P
fprintf_P
strtol
__do_clear_bss
