   1               		.file	"Rs485_prot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__RAMPY__ = 0x3a
   7               	__RAMPX__ = 0x39
   8               	__RAMPD__ = 0x38
   9               	__CCP__ = 0x34
  10               	__tmp_reg__ = 0
  11               	__zero_reg__ = 1
  14               		.text
  15               	.Ltext0:
 594               	_crc_xmodem_update:
 595               		.stabd	46,0,0
 597               	.Ltext1:
   1:/usr/lib/avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/crc16.h ****    All rights reserved.
   4:/usr/lib/avr/include/util/crc16.h **** 
   5:/usr/lib/avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/util/crc16.h **** 
   8:/usr/lib/avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/util/crc16.h **** 
  11:/usr/lib/avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/util/crc16.h ****      distribution.
  15:/usr/lib/avr/include/util/crc16.h **** 
  16:/usr/lib/avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/util/crc16.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/util/crc16.h **** 
  20:/usr/lib/avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/util/crc16.h **** 
  32:/usr/lib/avr/include/util/crc16.h **** /* $Id: crc16.h 2136 2010-06-08 12:03:38Z joerg_wunsch $ */
  33:/usr/lib/avr/include/util/crc16.h **** 
  34:/usr/lib/avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  35:/usr/lib/avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  36:/usr/lib/avr/include/util/crc16.h **** 
  37:/usr/lib/avr/include/util/crc16.h **** #include <stdint.h>
  38:/usr/lib/avr/include/util/crc16.h **** 
  39:/usr/lib/avr/include/util/crc16.h **** /** \file */
  40:/usr/lib/avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  41:/usr/lib/avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  42:/usr/lib/avr/include/util/crc16.h **** 
  43:/usr/lib/avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  44:/usr/lib/avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  45:/usr/lib/avr/include/util/crc16.h **** 
  46:/usr/lib/avr/include/util/crc16.h ****     \par References:
  47:/usr/lib/avr/include/util/crc16.h **** 
  48:/usr/lib/avr/include/util/crc16.h ****     \par
  49:/usr/lib/avr/include/util/crc16.h **** 
  50:/usr/lib/avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  51:/usr/lib/avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  52:/usr/lib/avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  53:/usr/lib/avr/include/util/crc16.h **** 
  54:/usr/lib/avr/include/util/crc16.h ****     \par
  55:/usr/lib/avr/include/util/crc16.h **** 
  56:/usr/lib/avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  57:/usr/lib/avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  58:/usr/lib/avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  59:/usr/lib/avr/include/util/crc16.h ****     obtain a copy.
  60:/usr/lib/avr/include/util/crc16.h **** 
  61:/usr/lib/avr/include/util/crc16.h ****     A typical application would look like:
  62:/usr/lib/avr/include/util/crc16.h **** 
  63:/usr/lib/avr/include/util/crc16.h ****     \code
  64:/usr/lib/avr/include/util/crc16.h ****     // Dallas iButton test vector.
  65:/usr/lib/avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  66:/usr/lib/avr/include/util/crc16.h **** 
  67:/usr/lib/avr/include/util/crc16.h ****     int
  68:/usr/lib/avr/include/util/crc16.h ****     checkcrc(void)
  69:/usr/lib/avr/include/util/crc16.h ****     {
  70:/usr/lib/avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  71:/usr/lib/avr/include/util/crc16.h **** 
  72:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  73:/usr/lib/avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  74:/usr/lib/avr/include/util/crc16.h **** 
  75:/usr/lib/avr/include/util/crc16.h **** 	return crc; // must be 0
  76:/usr/lib/avr/include/util/crc16.h ****     }
  77:/usr/lib/avr/include/util/crc16.h ****     \endcode
  78:/usr/lib/avr/include/util/crc16.h **** */
  79:/usr/lib/avr/include/util/crc16.h **** 
  80:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
  81:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  82:/usr/lib/avr/include/util/crc16.h **** 
  83:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  84:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
  85:/usr/lib/avr/include/util/crc16.h **** 
  86:/usr/lib/avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  87:/usr/lib/avr/include/util/crc16.h **** 
  88:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  89:/usr/lib/avr/include/util/crc16.h **** 
  90:/usr/lib/avr/include/util/crc16.h ****     \code
  91:/usr/lib/avr/include/util/crc16.h ****     uint16_t
  92:/usr/lib/avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  93:/usr/lib/avr/include/util/crc16.h ****     {
  94:/usr/lib/avr/include/util/crc16.h **** 	int i;
  95:/usr/lib/avr/include/util/crc16.h **** 
  96:/usr/lib/avr/include/util/crc16.h **** 	crc ^= a;
  97:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
  98:/usr/lib/avr/include/util/crc16.h **** 	{
  99:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 1)
 100:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 101:/usr/lib/avr/include/util/crc16.h **** 	    else
 102:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1);
 103:/usr/lib/avr/include/util/crc16.h **** 	}
 104:/usr/lib/avr/include/util/crc16.h **** 
 105:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 106:/usr/lib/avr/include/util/crc16.h ****     }
 107:/usr/lib/avr/include/util/crc16.h **** 
 108:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 109:/usr/lib/avr/include/util/crc16.h **** 
 110:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 111:/usr/lib/avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 112:/usr/lib/avr/include/util/crc16.h **** {
 113:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __tmp;
 114:/usr/lib/avr/include/util/crc16.h **** 	uint16_t __ret;
 115:/usr/lib/avr/include/util/crc16.h **** 
 116:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 117:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 118:/usr/lib/avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 119:/usr/lib/avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 120:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 121:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 122:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 123:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 124:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 125:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 126:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 127:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 128:/usr/lib/avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 129:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 130:/usr/lib/avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 131:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 132:/usr/lib/avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 133:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 134:/usr/lib/avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 135:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 136:/usr/lib/avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 137:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 138:/usr/lib/avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 139:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1"
 140:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 141:/usr/lib/avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 142:/usr/lib/avr/include/util/crc16.h **** 		: "r0"
 143:/usr/lib/avr/include/util/crc16.h **** 	);
 144:/usr/lib/avr/include/util/crc16.h **** 	return __ret;
 145:/usr/lib/avr/include/util/crc16.h **** }
 146:/usr/lib/avr/include/util/crc16.h **** 
 147:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 148:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 149:/usr/lib/avr/include/util/crc16.h **** 
 150:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 151:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 152:/usr/lib/avr/include/util/crc16.h **** 
 153:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 154:/usr/lib/avr/include/util/crc16.h **** 
 155:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 156:/usr/lib/avr/include/util/crc16.h **** 
 157:/usr/lib/avr/include/util/crc16.h ****     \code
 158:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 159:/usr/lib/avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 160:/usr/lib/avr/include/util/crc16.h ****     {
 161:/usr/lib/avr/include/util/crc16.h ****         int i;
 162:/usr/lib/avr/include/util/crc16.h **** 
 163:/usr/lib/avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 164:/usr/lib/avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 165:/usr/lib/avr/include/util/crc16.h ****         {
 166:/usr/lib/avr/include/util/crc16.h ****             if (crc & 0x8000)
 167:/usr/lib/avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 168:/usr/lib/avr/include/util/crc16.h ****             else
 169:/usr/lib/avr/include/util/crc16.h ****                 crc <<= 1;
 170:/usr/lib/avr/include/util/crc16.h ****         }
 171:/usr/lib/avr/include/util/crc16.h **** 
 172:/usr/lib/avr/include/util/crc16.h ****         return crc;
 173:/usr/lib/avr/include/util/crc16.h ****     }
 174:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 175:/usr/lib/avr/include/util/crc16.h **** 
 176:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 177:/usr/lib/avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 178:/usr/lib/avr/include/util/crc16.h **** {
 599               	.LM0:
 600               	.LFBB1:
 601               	/* prologue: function */
 602               	/* frame size = 0 */
 603               	/* stack size = 0 */
 604               	.L__stack_usage = 0
 179:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 180:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 181:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 182:/usr/lib/avr/include/util/crc16.h ****                                 /* %3  __data */
 183:/usr/lib/avr/include/util/crc16.h **** 
 184:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 185:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%3"          "\n\t" /* crc.hi ^ data */
 186:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 187:/usr/lib/avr/include/util/crc16.h ****         "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */
 188:/usr/lib/avr/include/util/crc16.h **** 
 189:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.lo of the CRC. */
 190:/usr/lib/avr/include/util/crc16.h ****         "mov    %1,__tmp_reg__"  "\n\t"
 191:/usr/lib/avr/include/util/crc16.h ****         "andi   %1,0x0f"         "\n\t"
 192:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%B0"          "\n\t"
 193:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,%B0"          "\n\t"
 194:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,__tmp_reg__"  "\n\t"
 195:/usr/lib/avr/include/util/crc16.h ****         "lsl    %2"              "\n\t"
 196:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xe0"         "\n\t"
 197:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */
 198:/usr/lib/avr/include/util/crc16.h **** 
 199:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.hi of the CRC. */
 200:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,__tmp_reg__"  "\n\t"
 201:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,%B0"          "\n\t"
 202:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xf0"         "\n\t"
 203:/usr/lib/avr/include/util/crc16.h ****         "lsr    %2"              "\n\t"
 204:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 205:/usr/lib/avr/include/util/crc16.h ****         "lsl    __tmp_reg__"     "\n\t"
 206:/usr/lib/avr/include/util/crc16.h ****         "rol    %2"              "\n\t"
 207:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 208:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 209:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 210:/usr/lib/avr/include/util/crc16.h ****         "andi   %B0,0x1f"        "\n\t"
 211:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%2"          "\n\t"
 212:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
 213:/usr/lib/avr/include/util/crc16.h ****         "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
 214:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
 215:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 216:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 217:/usr/lib/avr/include/util/crc16.h ****     );
 218:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 219:/usr/lib/avr/include/util/crc16.h **** }
 606               	.LM1:
 607               	/* #APP */
 608               	 ;  184 "/usr/lib/avr/include/util/crc16.h" 1
 609 0000 9627      		eor    r25,r22
 610 0002 092E      		mov    __tmp_reg__,r25
 611 0004 0294      		swap   __tmp_reg__
 612 0006 202D      		mov    r18,__tmp_reg__
 613 0008 2F70      		andi   r18,0x0f
 614 000a 2927      		eor    r18,r25
 615 000c 692F      		mov    r22,r25
 616 000e 6025      		eor    r22,__tmp_reg__
 617 0010 660F      		lsl    r22
 618 0012 607E      		andi   r22,0xe0
 619 0014 2627      		eor    r18,r22
 620 0016 602D      		mov    r22,__tmp_reg__
 621 0018 6927      		eor    r22,r25
 622 001a 607F      		andi   r22,0xf0
 623 001c 6695      		lsr    r22
 624 001e 092E      		mov    __tmp_reg__,r25
 625 0020 000C      		lsl    __tmp_reg__
 626 0022 661F      		rol    r22
 627 0024 9695      		lsr    r25
 628 0026 9695      		lsr    r25
 629 0028 9695      		lsr    r25
 630 002a 9F71      		andi   r25,0x1f
 631 002c 9627      		eor    r25,r22
 632 002e 9827      		eor    r25,r24
 633 0030 822F      		mov    r24,r18
 634               		
 635               	 ;  0 "" 2
 636               	/* #NOAPP */
 637 0032 0895      		ret
 639               	.Lscope1:
 641               		.stabd	78,0,0
 643               		.weak	takeRs485
 645               	takeRs485:
 646               		.stabd	46,0,0
 648               	.Ltext2:
   1:../../Lib/Rs485_prot.c **** #include "Rs485_prot.h"
   2:../../Lib/Rs485_prot.c **** #include <util/crc16.h>
   3:../../Lib/Rs485_prot.c **** #include <stdio.h>
   4:../../Lib/Rs485_prot.c **** 
   5:../../Lib/Rs485_prot.c **** #if LANG_EN
   6:../../Lib/Rs485_prot.c **** #include "Rs485_prot_en.h"
   7:../../Lib/Rs485_prot.c **** #define PRINT_RS485_DEVICE 1
   8:../../Lib/Rs485_prot.c **** #endif
   9:../../Lib/Rs485_prot.c **** 
  10:../../Lib/Rs485_prot.c **** #if LANG_PL
  11:../../Lib/Rs485_prot.c **** #include "Rs485_prot_pl.h"
  12:../../Lib/Rs485_prot.c **** #define PRINT_RS485_DEVICE 1
  13:../../Lib/Rs485_prot.c **** #endif
  14:../../Lib/Rs485_prot.c **** 
  15:../../Lib/Rs485_prot.c **** static void    sendPing(uint8_t addr, uint8_t pingLen);
  16:../../Lib/Rs485_prot.c **** static uint8_t receivePong(uint8_t addr, uint8_t pingLen);
  17:../../Lib/Rs485_prot.c **** static void    sendHello(uint8_t addr);
  18:../../Lib/Rs485_prot.c **** static uint8_t receiveHello(uint8_t* response, uint8_t maxSize);
  19:../../Lib/Rs485_prot.c **** 
  20:../../Lib/Rs485_prot.c **** // ********************* Those function have to be implemented in your project *************
  21:../../Lib/Rs485_prot.c **** void takeRs485(void)                              { }
 650               	.LM2:
 651               	.LFBB2:
 652               	/* prologue: function */
 653               	/* frame size = 0 */
 654               	/* stack size = 0 */
 655               	.L__stack_usage = 0
 656 0034 0895      		ret
 658               	.Lscope2:
 660               		.stabd	78,0,0
 662               		.weak	releaseRs485
 664               	releaseRs485:
 665               		.stabd	46,0,0
  22:../../Lib/Rs485_prot.c **** void releaseRs485(void)                           { }
 667               	.LM3:
 668               	.LFBB3:
 669               	/* prologue: function */
 670               	/* frame size = 0 */
 671               	/* stack size = 0 */
 672               	.L__stack_usage = 0
 673 0036 0895      		ret
 675               	.Lscope3:
 677               		.stabd	78,0,0
 680               		.weak	uartRs485SendByte
 682               	uartRs485SendByte:
 683               		.stabd	46,0,0
  23:../../Lib/Rs485_prot.c **** void uartRs485SendByte(uint8_t c)                 { c=0; }
 685               	.LM4:
 686               	.LFBB4:
 687               	/* prologue: function */
 688               	/* frame size = 0 */
 689               	/* stack size = 0 */
 690               	.L__stack_usage = 0
 691 0038 0895      		ret
 693               	.Lscope4:
 695               		.stabd	78,0,0
 699               		.weak	rs485Receive
 701               	rs485Receive:
 702               		.stabd	46,0,0
  24:../../Lib/Rs485_prot.c **** uint8_t rs485Receive(uint8_t *c, uint8_t timeout) {  timeout = 0; c = NULL; return 1; }
 704               	.LM5:
 705               	.LFBB5:
 706               	/* prologue: function */
 707               	/* frame size = 0 */
 708               	/* stack size = 0 */
 709               	.L__stack_usage = 0
 711               	.LM6:
 712 003a 81E0      		ldi r24,lo8(1)
 713 003c 0895      		ret
 715               	.Lscope5:
 717               		.stabd	78,0,0
 719               		.weak	flushRs485RecBuffer
 721               	flushRs485RecBuffer:
 722               		.stabd	46,0,0
  25:../../Lib/Rs485_prot.c **** uint8_t flushRs485RecBuffer(void)                 {return 1;}
 724               	.LM7:
 725               	.LFBB6:
 726               	/* prologue: function */
 727               	/* frame size = 0 */
 728               	/* stack size = 0 */
 729               	.L__stack_usage = 0
 731               	.LM8:
 732 003e 81E0      		ldi r24,lo8(1)
 733 0040 0895      		ret
 735               	.Lscope6:
 737               		.stabd	78,0,0
 741               	.global	sendSettings
 743               	sendSettings:
 744               		.stabd	46,0,0
  26:../../Lib/Rs485_prot.c **** 
  27:../../Lib/Rs485_prot.c **** 
  28:../../Lib/Rs485_prot.c **** 
  29:../../Lib/Rs485_prot.c **** 
  30:../../Lib/Rs485_prot.c **** 
  31:../../Lib/Rs485_prot.c **** // ********************* Hiden Functions ***************************************************
  32:../../Lib/Rs485_prot.c **** void sendSettings(uint8_t addr, uint8_t value)
  33:../../Lib/Rs485_prot.c **** {
 746               	.LM9:
 747               	.LFBB7:
 748 0042 EF92      		push r14
 749 0044 FF92      		push r15
 750 0046 0F93      		push r16
 751 0048 1F93      		push r17
 752 004a CF93      		push r28
 753 004c DF93      		push r29
 754 004e 1F92      		push __zero_reg__
 755 0050 CDB7      		in r28,__SP_L__
 756 0052 DEB7      		in r29,__SP_H__
 757               	/* prologue: function */
 758               	/* frame size = 1 */
 759               	/* stack size = 7 */
 760               	.L__stack_usage = 7
 761 0054 082F      		mov r16,r24
 762 0056 162F      		mov r17,r22
  34:../../Lib/Rs485_prot.c ****   uint16_t crc = _crc_xmodem_update(0, SYNC);
 764               	.LM10:
 765 0058 6AE5      		ldi r22,lo8(90)
 766 005a 80E0      		ldi r24,0
 767 005c 90E0      		ldi r25,0
 768 005e 0E94 0000 		call _crc_xmodem_update
 769 0062 7C01      		movw r14,r24
  35:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
 771               	.LM11:
 772 0064 8AE5      		ldi r24,lo8(90)
 773 0066 0E94 0000 		call uartRs485SendByte
  36:../../Lib/Rs485_prot.c **** 
  37:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, addr);
 775               	.LM12:
 776 006a 602F      		mov r22,r16
 777 006c C701      		movw r24,r14
 778 006e 0E94 0000 		call _crc_xmodem_update
 779 0072 7C01      		movw r14,r24
  38:../../Lib/Rs485_prot.c ****   uartRs485SendByte(addr);
 781               	.LM13:
 782 0074 802F      		mov r24,r16
 783 0076 0E94 0000 		call uartRs485SendByte
  39:../../Lib/Rs485_prot.c **** 
  40:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, rUstaw);
 785               	.LM14:
 786 007a 60E4      		ldi r22,lo8(64)
 787 007c C701      		movw r24,r14
 788 007e 0E94 0000 		call _crc_xmodem_update
 789 0082 7C01      		movw r14,r24
  41:../../Lib/Rs485_prot.c ****   uartRs485SendByte(rUstaw);
 791               	.LM15:
 792 0084 80E4      		ldi r24,lo8(64)
 793 0086 0E94 0000 		call uartRs485SendByte
  42:../../Lib/Rs485_prot.c **** 
  43:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 1);
 795               	.LM16:
 796 008a 61E0      		ldi r22,lo8(1)
 797 008c C701      		movw r24,r14
 798 008e 0E94 0000 		call _crc_xmodem_update
 799 0092 7C01      		movw r14,r24
  44:../../Lib/Rs485_prot.c ****   uartRs485SendByte(1);
 801               	.LM17:
 802 0094 81E0      		ldi r24,lo8(1)
 803 0096 0E94 0000 		call uartRs485SendByte
  45:../../Lib/Rs485_prot.c **** 
  46:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, value);
 805               	.LM18:
 806 009a 612F      		mov r22,r17
 807 009c C701      		movw r24,r14
 808 009e 0E94 0000 		call _crc_xmodem_update
 809 00a2 082F      		mov r16,r24
  47:../../Lib/Rs485_prot.c ****   uartRs485SendByte(value);
 811               	.LM19:
 812 00a4 812F      		mov r24,r17
 813 00a6 9983      		std Y+1,r25
 814 00a8 0E94 0000 		call uartRs485SendByte
  48:../../Lib/Rs485_prot.c **** 
  49:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc >> 8));
 816               	.LM20:
 817 00ac 9981      		ldd r25,Y+1
 818 00ae 892F      		mov r24,r25
 819 00b0 0E94 0000 		call uartRs485SendByte
  50:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 821               	.LM21:
 822 00b4 802F      		mov r24,r16
 823               	/* epilogue start */
  51:../../Lib/Rs485_prot.c **** }
 825               	.LM22:
 826 00b6 0F90      		pop __tmp_reg__
 827 00b8 DF91      		pop r29
 828 00ba CF91      		pop r28
 829 00bc 1F91      		pop r17
 830 00be 0F91      		pop r16
 831 00c0 FF90      		pop r15
 832 00c2 EF90      		pop r14
  50:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 834               	.LM23:
 835 00c4 0C94 0000 		jmp uartRs485SendByte
 837               	.Lscope7:
 839               		.stabd	78,0,0
 842               	.global	saveSettings
 844               	saveSettings:
 845               		.stabd	46,0,0
  52:../../Lib/Rs485_prot.c **** 
  53:../../Lib/Rs485_prot.c **** void saveSettings(uint8_t addr)
  54:../../Lib/Rs485_prot.c **** {
 847               	.LM24:
 848               	.LFBB8:
 849 00c8 EF92      		push r14
 850 00ca FF92      		push r15
 851 00cc 1F93      		push r17
 852 00ce CF93      		push r28
 853 00d0 DF93      		push r29
 854 00d2 1F92      		push __zero_reg__
 855 00d4 CDB7      		in r28,__SP_L__
 856 00d6 DEB7      		in r29,__SP_H__
 857               	/* prologue: function */
 858               	/* frame size = 1 */
 859               	/* stack size = 6 */
 860               	.L__stack_usage = 6
 861 00d8 182F      		mov r17,r24
  55:../../Lib/Rs485_prot.c ****   uint16_t crc = _crc_xmodem_update(0, SYNC);
 863               	.LM25:
 864 00da 6AE5      		ldi r22,lo8(90)
 865 00dc 80E0      		ldi r24,0
 866 00de 90E0      		ldi r25,0
 867 00e0 0E94 0000 		call _crc_xmodem_update
 868 00e4 7C01      		movw r14,r24
  56:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
 870               	.LM26:
 871 00e6 8AE5      		ldi r24,lo8(90)
 872 00e8 0E94 0000 		call uartRs485SendByte
  57:../../Lib/Rs485_prot.c **** 
  58:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, addr);
 874               	.LM27:
 875 00ec 612F      		mov r22,r17
 876 00ee C701      		movw r24,r14
 877 00f0 0E94 0000 		call _crc_xmodem_update
 878 00f4 7C01      		movw r14,r24
  59:../../Lib/Rs485_prot.c ****   uartRs485SendByte(addr);
 880               	.LM28:
 881 00f6 812F      		mov r24,r17
 882 00f8 0E94 0000 		call uartRs485SendByte
  60:../../Lib/Rs485_prot.c **** 
  61:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, rZapiszUstawienia);
 884               	.LM29:
 885 00fc 61E4      		ldi r22,lo8(65)
 886 00fe C701      		movw r24,r14
 887 0100 0E94 0000 		call _crc_xmodem_update
 888 0104 7C01      		movw r14,r24
  62:../../Lib/Rs485_prot.c ****   uartRs485SendByte(rZapiszUstawienia);
 890               	.LM30:
 891 0106 81E4      		ldi r24,lo8(65)
 892 0108 0E94 0000 		call uartRs485SendByte
  63:../../Lib/Rs485_prot.c **** 
  64:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 0);
 894               	.LM31:
 895 010c 60E0      		ldi r22,0
 896 010e C701      		movw r24,r14
 897 0110 0E94 0000 		call _crc_xmodem_update
 898 0114 182F      		mov r17,r24
  65:../../Lib/Rs485_prot.c ****   uartRs485SendByte(0);
 900               	.LM32:
 901 0116 80E0      		ldi r24,0
 902 0118 9983      		std Y+1,r25
 903 011a 0E94 0000 		call uartRs485SendByte
  66:../../Lib/Rs485_prot.c **** 
  67:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc >> 8));
 905               	.LM33:
 906 011e 9981      		ldd r25,Y+1
 907 0120 892F      		mov r24,r25
 908 0122 0E94 0000 		call uartRs485SendByte
  68:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 910               	.LM34:
 911 0126 812F      		mov r24,r17
 912               	/* epilogue start */
  69:../../Lib/Rs485_prot.c **** }
 914               	.LM35:
 915 0128 0F90      		pop __tmp_reg__
 916 012a DF91      		pop r29
 917 012c CF91      		pop r28
 918 012e 1F91      		pop r17
 919 0130 FF90      		pop r15
 920 0132 EF90      		pop r14
  68:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 922               	.LM36:
 923 0134 0C94 0000 		jmp uartRs485SendByte
 925               	.Lscope8:
 927               		.stabd	78,0,0
 929               	.global	rollersMemInit
 931               	rollersMemInit:
 932               		.stabd	46,0,0
  70:../../Lib/Rs485_prot.c **** 
  71:../../Lib/Rs485_prot.c **** 
  72:../../Lib/Rs485_prot.c **** void sendPing(uint8_t addr, uint8_t pingLen)
  73:../../Lib/Rs485_prot.c **** {
  74:../../Lib/Rs485_prot.c ****   uint16_t crc = _crc_xmodem_update(0, SYNC);
  75:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
  76:../../Lib/Rs485_prot.c **** 
  77:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, addr);
  78:../../Lib/Rs485_prot.c ****   uartRs485SendByte(addr);
  79:../../Lib/Rs485_prot.c **** 
  80:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, rPING);
  81:../../Lib/Rs485_prot.c ****   uartRs485SendByte(rPING);
  82:../../Lib/Rs485_prot.c **** 
  83:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, pingLen);
  84:../../Lib/Rs485_prot.c ****   uartRs485SendByte(pingLen);
  85:../../Lib/Rs485_prot.c ****   
  86:../../Lib/Rs485_prot.c ****   for (uint8_t i=0; i < pingLen; i++)
  87:../../Lib/Rs485_prot.c ****   {
  88:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, i);
  89:../../Lib/Rs485_prot.c ****     uartRs485SendByte(i);
  90:../../Lib/Rs485_prot.c ****   }
  91:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc >> 8));
  92:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
  93:../../Lib/Rs485_prot.c **** }
  94:../../Lib/Rs485_prot.c **** 
  95:../../Lib/Rs485_prot.c **** uint8_t receivePong(uint8_t addr, uint8_t dataLen)
  96:../../Lib/Rs485_prot.c **** { 
  97:../../Lib/Rs485_prot.c ****   addr = 0;
  98:../../Lib/Rs485_prot.c ****   uint8_t data;
  99:../../Lib/Rs485_prot.c ****   uint16_t crc;
 100:../../Lib/Rs485_prot.c ****    
 101:../../Lib/Rs485_prot.c ****   //SYNC
 102:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 20) == pdFALSE)
 103:../../Lib/Rs485_prot.c ****     return 1;
 104:../../Lib/Rs485_prot.c ****   
 105:../../Lib/Rs485_prot.c ****   if (data != SYNC)
 106:../../Lib/Rs485_prot.c ****     return 2;
 107:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(0, data);
 108:../../Lib/Rs485_prot.c **** 
 109:../../Lib/Rs485_prot.c ****   //Adres ma być wartość 0
 110:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == 0)
 111:../../Lib/Rs485_prot.c ****     return 3;
 112:../../Lib/Rs485_prot.c **** 
 113:../../Lib/Rs485_prot.c ****   if (data != 0)
 114:../../Lib/Rs485_prot.c ****     return 4;
 115:../../Lib/Rs485_prot.c ****   
 116:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 117:../../Lib/Rs485_prot.c **** 
 118:../../Lib/Rs485_prot.c ****   //Kod rozkazu. Ma być rPING
 119:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 120:../../Lib/Rs485_prot.c ****     return 5;
 121:../../Lib/Rs485_prot.c ****   if (data != rPING)
 122:../../Lib/Rs485_prot.c ****     return 6;
 123:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 124:../../Lib/Rs485_prot.c **** 
 125:../../Lib/Rs485_prot.c ****   //Długość odpowiedzi
 126:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 127:../../Lib/Rs485_prot.c ****     return 7;
 128:../../Lib/Rs485_prot.c ****   if (data != dataLen)
 129:../../Lib/Rs485_prot.c ****     return 8;
 130:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 131:../../Lib/Rs485_prot.c **** 
 132:../../Lib/Rs485_prot.c ****   
 133:../../Lib/Rs485_prot.c ****   uint8_t temp;
 134:../../Lib/Rs485_prot.c ****   for (temp=0; temp < dataLen; temp++)
 135:../../Lib/Rs485_prot.c ****   {
 136:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 5) == pdFALSE)
 137:../../Lib/Rs485_prot.c ****       return 2*temp+9;
 138:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, data);
 139:../../Lib/Rs485_prot.c ****     if (data != temp)
 140:../../Lib/Rs485_prot.c ****       return 2*temp+10; 
 141:../../Lib/Rs485_prot.c ****   }
 142:../../Lib/Rs485_prot.c **** 
 143:../../Lib/Rs485_prot.c ****   uint8_t crcHi;
 144:../../Lib/Rs485_prot.c ****   uint8_t crcLo;
 145:../../Lib/Rs485_prot.c ****   if(rs485Receive(&crcHi, 1) != pdTRUE)
 146:../../Lib/Rs485_prot.c ****     return 2*temp+11;
 147:../../Lib/Rs485_prot.c ****   
 148:../../Lib/Rs485_prot.c ****   if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
 149:../../Lib/Rs485_prot.c ****     return 2*temp+12;
 150:../../Lib/Rs485_prot.c **** 
 151:../../Lib/Rs485_prot.c ****   if (crcHi != (uint8_t)(crc>>8))
 152:../../Lib/Rs485_prot.c ****     return 254;
 153:../../Lib/Rs485_prot.c ****   if (crcLo != (uint8_t)(crc & 0xFF))
 154:../../Lib/Rs485_prot.c ****     return 255;
 155:../../Lib/Rs485_prot.c ****   
 156:../../Lib/Rs485_prot.c ****   return 0; 
 157:../../Lib/Rs485_prot.c **** }
 158:../../Lib/Rs485_prot.c **** 
 159:../../Lib/Rs485_prot.c **** static void    sendHello(uint8_t addr)
 160:../../Lib/Rs485_prot.c **** {
 161:../../Lib/Rs485_prot.c ****   uint16_t crc = _crc_xmodem_update(0, SYNC);
 162:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
 163:../../Lib/Rs485_prot.c **** 
 164:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, addr);
 165:../../Lib/Rs485_prot.c ****   uartRs485SendByte(addr);
 166:../../Lib/Rs485_prot.c **** 
 167:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, rHELLO);
 168:../../Lib/Rs485_prot.c ****   uartRs485SendByte(rHELLO);
 169:../../Lib/Rs485_prot.c **** 
 170:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 0);
 171:../../Lib/Rs485_prot.c ****   uartRs485SendByte(0);
 172:../../Lib/Rs485_prot.c ****   
 173:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc >> 8));
 174:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 175:../../Lib/Rs485_prot.c **** }
 176:../../Lib/Rs485_prot.c **** 
 177:../../Lib/Rs485_prot.c **** static uint8_t receiveHello(uint8_t* response, uint8_t maxSize)
 178:../../Lib/Rs485_prot.c **** {
 179:../../Lib/Rs485_prot.c ****   uint16_t crc;
 180:../../Lib/Rs485_prot.c ****   uint8_t data; 
 181:../../Lib/Rs485_prot.c ****   //SYNC
 182:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 20) == pdFALSE)
 183:../../Lib/Rs485_prot.c ****     return 8;
 184:../../Lib/Rs485_prot.c ****   
 185:../../Lib/Rs485_prot.c ****   if (data != SYNC)
 186:../../Lib/Rs485_prot.c ****     return 2;
 187:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(0, data);
 188:../../Lib/Rs485_prot.c **** 
 189:../../Lib/Rs485_prot.c ****   //Adres ma być wartość 0
 190:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == 0)
 191:../../Lib/Rs485_prot.c ****     return 3;
 192:../../Lib/Rs485_prot.c **** 
 193:../../Lib/Rs485_prot.c ****   if (data != 0)
 194:../../Lib/Rs485_prot.c ****     return 4;
 195:../../Lib/Rs485_prot.c ****   
 196:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 197:../../Lib/Rs485_prot.c **** 
 198:../../Lib/Rs485_prot.c ****   //Kod rozkazu. Ma być rHELLO
 199:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 200:../../Lib/Rs485_prot.c ****     return 5;
 201:../../Lib/Rs485_prot.c ****   if (data != rHELLO)
 202:../../Lib/Rs485_prot.c ****     return 6;
 203:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 204:../../Lib/Rs485_prot.c **** 
 205:../../Lib/Rs485_prot.c ****   //Długość odpowiedzi
 206:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 207:../../Lib/Rs485_prot.c ****     return 7;
 208:../../Lib/Rs485_prot.c ****   if (data > maxSize)
 209:../../Lib/Rs485_prot.c ****     return 1;
 210:../../Lib/Rs485_prot.c ****   
 211:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 212:../../Lib/Rs485_prot.c ****   memset(response, 0, maxSize);
 213:../../Lib/Rs485_prot.c ****   maxSize = data;
 214:../../Lib/Rs485_prot.c ****   
 215:../../Lib/Rs485_prot.c ****   for (data=0; data < maxSize; data++)
 216:../../Lib/Rs485_prot.c ****   {
 217:../../Lib/Rs485_prot.c ****     if(rs485Receive(response, 5) == pdFALSE)
 218:../../Lib/Rs485_prot.c ****       return 20;
 219:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, *((uint8_t *)(response)));
 220:../../Lib/Rs485_prot.c ****     response++; 
 221:../../Lib/Rs485_prot.c ****   }
 222:../../Lib/Rs485_prot.c **** 
 223:../../Lib/Rs485_prot.c ****   uint8_t crcHi;
 224:../../Lib/Rs485_prot.c ****   uint8_t crcLo;
 225:../../Lib/Rs485_prot.c ****   if(rs485Receive(&crcHi, 1) != pdTRUE)
 226:../../Lib/Rs485_prot.c ****     return 21;
 227:../../Lib/Rs485_prot.c ****   
 228:../../Lib/Rs485_prot.c ****   if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
 229:../../Lib/Rs485_prot.c ****     return 22;
 230:../../Lib/Rs485_prot.c **** 
 231:../../Lib/Rs485_prot.c ****   if (crcHi != (uint8_t)(crc>>8))
 232:../../Lib/Rs485_prot.c ****     return 254;
 233:../../Lib/Rs485_prot.c ****   if (crcLo != (uint8_t)(crc & 0xFF))
 234:../../Lib/Rs485_prot.c ****     return 255;
 235:../../Lib/Rs485_prot.c ****   
 236:../../Lib/Rs485_prot.c ****   return 0; 
 237:../../Lib/Rs485_prot.c **** }
 238:../../Lib/Rs485_prot.c **** 
 239:../../Lib/Rs485_prot.c **** // ************************ Rs485 API ************************************
 240:../../Lib/Rs485_prot.c **** 
 241:../../Lib/Rs485_prot.c **** void rollersMemInit(void)
 242:../../Lib/Rs485_prot.c **** {
 934               	.LM37:
 935               	.LFBB9:
 936               	/* prologue: function */
 937               	/* frame size = 0 */
 938               	/* stack size = 0 */
 939               	.L__stack_usage = 0
 243:../../Lib/Rs485_prot.c ****   rollers = xmalloc(MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
 941               	.LM38:
 942 0138 8EE6      		ldi r24,lo8(110)
 943 013a 90E0      		ldi r25,0
 944 013c 0E94 0000 		call malloc
 945 0140 8093 0000 		sts rollers,r24
 946 0144 9093 0000 		sts rollers+1,r25
 244:../../Lib/Rs485_prot.c ****   memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
 948               	.LM39:
 949 0148 2EE6      		ldi r18,lo8(110)
 950 014a FC01      		movw r30,r24
 951               		0:
 952 014c 1192      		st Z+,__zero_reg__
 953 014e 2A95      		dec r18
 954 0150 01F4      		brne 0b
 955 0152 0895      		ret
 957               	.Lscope9:
 959               		.stabd	78,0,0
 961               	.global	printRs485devices
 963               	printRs485devices:
 964               		.stabd	46,0,0
 245:../../Lib/Rs485_prot.c **** }
 246:../../Lib/Rs485_prot.c **** 
 247:../../Lib/Rs485_prot.c **** #ifdef PRINT_RS485_DEVICE
 248:../../Lib/Rs485_prot.c **** uint8_t printRs485devices(FILE *stream)
 249:../../Lib/Rs485_prot.c **** {
 966               	.LM40:
 967               	.LFBB10:
 968 0154 9F92      		push r9
 969 0156 AF92      		push r10
 970 0158 BF92      		push r11
 971 015a CF92      		push r12
 972 015c DF92      		push r13
 973 015e EF92      		push r14
 974 0160 FF92      		push r15
 975 0162 0F93      		push r16
 976 0164 1F93      		push r17
 977 0166 CF93      		push r28
 978 0168 DF93      		push r29
 979               	/* prologue: function */
 980               	/* frame size = 0 */
 981               	/* stack size = 11 */
 982               	.L__stack_usage = 11
 983 016a B82E      		mov r11,r24
 984 016c A92E      		mov r10,r25
 250:../../Lib/Rs485_prot.c ****   uint8_t result = 0;
 251:../../Lib/Rs485_prot.c ****   struct sterRolet *rolTmp = rollers;
 986               	.LM41:
 987 016e 2091 0000 		lds r18,rollers
 988 0172 3091 0000 		lds r19,rollers+1
 989 0176 E901      		movw r28,r18
 990 0178 2596      		adiw r28,5
 991 017a 6901      		movw r12,r18
 992 017c 83E7      		ldi r24,115
 993 017e C80E      		add r12,r24
 994 0180 D11C      		adc r13,__zero_reg__
 250:../../Lib/Rs485_prot.c ****   uint8_t result = 0;
 996               	.LM42:
 997 0182 912C      		mov r9,__zero_reg__
 998               	.LBB3:
 252:../../Lib/Rs485_prot.c ****   
 253:../../Lib/Rs485_prot.c ****   //Print RollerDrivers
 254:../../Lib/Rs485_prot.c ****   for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
 255:../../Lib/Rs485_prot.c ****   {
 256:../../Lib/Rs485_prot.c ****     if (rolTmp->address != 0)
 257:../../Lib/Rs485_prot.c ****     {
 258:../../Lib/Rs485_prot.c ****       fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 
 1000               	.LM43:
 1001 0184 80E0      		ldi r24,lo8(statusRollerDescStr)
 1002 0186 E82E      		mov r14,r24
 1003 0188 80E0      		ldi r24,hi8(statusRollerDescStr)
 1004 018a F82E      		mov r15,r24
 259:../../Lib/Rs485_prot.c ****    //   fprintf_P(stream, statusRollerDescStrConf, rolTmp->response.parsed.settings);      
 260:../../Lib/Rs485_prot.c ****       fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
 1006               	.LM44:
 1007 018c 00E0      		ldi r16,lo8(statusRollerDescStr2)
 1008 018e 10E0      		ldi r17,hi8(statusRollerDescStr2)
 1009               	.L13:
 1010 0190 FE01      		movw r30,r28
 1011 0192 3497      		sbiw r30,4
 256:../../Lib/Rs485_prot.c ****     if (rolTmp->address != 0)
 1013               	.LM45:
 1014 0194 9081      		ld r25,Z
 1015 0196 9923      		tst r25
 1016 0198 01F0      		breq .L11
 1017 019a FE01      		movw r30,r28
 1018 019c 3297      		sbiw r30,2
 258:../../Lib/Rs485_prot.c ****       fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 
 1020               	.LM46:
 1021 019e 8081      		ld r24,Z
 1022 01a0 8F73      		andi r24,lo8(63)
 1023 01a2 1F92      		push __zero_reg__
 1024 01a4 8F93      		push r24
 1025 01a6 FE01      		movw r30,r28
 1026 01a8 3397      		sbiw r30,3
 1027 01aa 8081      		ld r24,Z
 1028 01ac 8F73      		andi r24,lo8(63)
 1029 01ae 1F92      		push __zero_reg__
 1030 01b0 8F93      		push r24
 1031 01b2 1F92      		push __zero_reg__
 1032 01b4 9F93      		push r25
 1033 01b6 FF92      		push r15
 1034 01b8 EF92      		push r14
 1035 01ba AF92      		push r10
 1036 01bc BF92      		push r11
 1037 01be 0E94 0000 		call fprintf_P
 1039               	.LM47:
 1040 01c2 DF93      		push r29
 1041 01c4 CF93      		push r28
 1042 01c6 1F93      		push r17
 1043 01c8 0F93      		push r16
 1044 01ca AF92      		push r10
 1045 01cc BF92      		push r11
 1046 01ce 0E94 0000 		call fprintf_P
 261:../../Lib/Rs485_prot.c ****       result++;
 1048               	.LM48:
 1049 01d2 9394      		inc r9
 1050 01d4 8DB7      		in r24,__SP_L__
 1051 01d6 9EB7      		in r25,__SP_H__
 1052 01d8 4096      		adiw r24,16
 1053 01da 8DBF      		out __SP_L__,r24
 1054 01dc 9EBF      		out __SP_H__,r25
 1055               	.L11:
 1056 01de 2B96      		adiw r28,11
 254:../../Lib/Rs485_prot.c ****   for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
 1058               	.LM49:
 1059 01e0 CC15      		cp r28,r12
 1060 01e2 DD05      		cpc r29,r13
 1061 01e4 01F4      		brne .L13
 1062               	.LBE3:
 262:../../Lib/Rs485_prot.c ****     }
 263:../../Lib/Rs485_prot.c ****     rolTmp++;
 264:../../Lib/Rs485_prot.c ****   }
 265:../../Lib/Rs485_prot.c ****   
 266:../../Lib/Rs485_prot.c ****   
 267:../../Lib/Rs485_prot.c ****   return result;
 268:../../Lib/Rs485_prot.c **** }
 1064               	.LM50:
 1065 01e6 892D      		mov r24,r9
 1066               	/* epilogue start */
 1067 01e8 DF91      		pop r29
 1068 01ea CF91      		pop r28
 1069 01ec 1F91      		pop r17
 1070 01ee 0F91      		pop r16
 1071 01f0 FF90      		pop r15
 1072 01f2 EF90      		pop r14
 1073 01f4 DF90      		pop r13
 1074 01f6 CF90      		pop r12
 1075 01f8 BF90      		pop r11
 1076 01fa AF90      		pop r10
 1077 01fc 9F90      		pop r9
 1078 01fe 0895      		ret
 1084               	.Lscope10:
 1086               		.stabd	78,0,0
 1089               	.global	rs485ping
 1091               	rs485ping:
 1092               		.stabd	46,0,0
 269:../../Lib/Rs485_prot.c **** #endif /*PRINT_RS485_DEVICE*/
 270:../../Lib/Rs485_prot.c **** 
 271:../../Lib/Rs485_prot.c **** uint8_t rs485ping(uint8_t devAddr)
 272:../../Lib/Rs485_prot.c **** {
 1094               	.LM51:
 1095               	.LFBB11:
 1096 0200 FF92      		push r15
 1097 0202 0F93      		push r16
 1098 0204 1F93      		push r17
 1099 0206 CF93      		push r28
 1100 0208 DF93      		push r29
 1101 020a 00D0      		rcall .
 1102 020c 1F92      		push __zero_reg__
 1103 020e CDB7      		in r28,__SP_L__
 1104 0210 DEB7      		in r29,__SP_H__
 1105               	/* prologue: function */
 1106               	/* frame size = 4 */
 1107               	/* stack size = 9 */
 1108               	.L__stack_usage = 9
 1109 0212 F82E      		mov r15,r24
 273:../../Lib/Rs485_prot.c ****   takeRs485();
 1111               	.LM52:
 1112 0214 0E94 0000 		call takeRs485
 1113               	.LBB9:
 1114               	.LBB10:
  74:../../Lib/Rs485_prot.c ****   uint16_t crc = _crc_xmodem_update(0, SYNC);
 1116               	.LM53:
 1117 0218 6AE5      		ldi r22,lo8(90)
 1118 021a 80E0      		ldi r24,0
 1119 021c 90E0      		ldi r25,0
 1120 021e 0E94 0000 		call _crc_xmodem_update
 1121 0222 8C01      		movw r16,r24
  75:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
 1123               	.LM54:
 1124 0224 8AE5      		ldi r24,lo8(90)
 1125 0226 0E94 0000 		call uartRs485SendByte
  77:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, addr);
 1127               	.LM55:
 1128 022a 6F2D      		mov r22,r15
 1129 022c C801      		movw r24,r16
 1130 022e 0E94 0000 		call _crc_xmodem_update
 1131 0232 8C01      		movw r16,r24
  78:../../Lib/Rs485_prot.c ****   uartRs485SendByte(addr);
 1133               	.LM56:
 1134 0234 8F2D      		mov r24,r15
 1135 0236 0E94 0000 		call uartRs485SendByte
  80:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, rPING);
 1137               	.LM57:
 1138 023a 60E8      		ldi r22,lo8(-128)
 1139 023c C801      		movw r24,r16
 1140 023e 0E94 0000 		call _crc_xmodem_update
 1141 0242 8C01      		movw r16,r24
  81:../../Lib/Rs485_prot.c ****   uartRs485SendByte(rPING);
 1143               	.LM58:
 1144 0244 80E8      		ldi r24,lo8(-128)
 1145 0246 0E94 0000 		call uartRs485SendByte
  83:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, pingLen);
 1147               	.LM59:
 1148 024a 68E0      		ldi r22,lo8(8)
 1149 024c C801      		movw r24,r16
 1150 024e 0E94 0000 		call _crc_xmodem_update
 1151 0252 082F      		mov r16,r24
  84:../../Lib/Rs485_prot.c ****   uartRs485SendByte(pingLen);
 1153               	.LM60:
 1154 0254 88E0      		ldi r24,lo8(8)
 1155 0256 9C83      		std Y+4,r25
 1156 0258 0E94 0000 		call uartRs485SendByte
 1157               	.LBB11:
  86:../../Lib/Rs485_prot.c ****   for (uint8_t i=0; i < pingLen; i++)
 1159               	.LM61:
 1160 025c 10E0      		ldi r17,0
 1161 025e 9C81      		ldd r25,Y+4
 1162               	.L20:
  88:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, i);
 1164               	.LM62:
 1165 0260 612F      		mov r22,r17
 1166 0262 802F      		mov r24,r16
 1167 0264 0E94 0000 		call _crc_xmodem_update
 1168 0268 082F      		mov r16,r24
  89:../../Lib/Rs485_prot.c ****     uartRs485SendByte(i);
 1170               	.LM63:
 1171 026a 812F      		mov r24,r17
 1172 026c 9C83      		std Y+4,r25
 1173 026e 0E94 0000 		call uartRs485SendByte
  86:../../Lib/Rs485_prot.c ****   for (uint8_t i=0; i < pingLen; i++)
 1175               	.LM64:
 1176 0272 1F5F      		subi r17,lo8(-(1))
 1177 0274 9C81      		ldd r25,Y+4
 1178 0276 1830      		cpi r17,lo8(8)
 1179 0278 01F4      		brne .L20
 1180               	.LBE11:
  91:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc >> 8));
 1182               	.LM65:
 1183 027a 892F      		mov r24,r25
 1184 027c 0E94 0000 		call uartRs485SendByte
  92:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 1186               	.LM66:
 1187 0280 802F      		mov r24,r16
 1188 0282 0E94 0000 		call uartRs485SendByte
 1189               	.LBE10:
 1190               	.LBE9:
 1191               	.LBB12:
 1192               	.LBB13:
 102:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 20) == pdFALSE)
 1194               	.LM67:
 1195 0286 64E1      		ldi r22,lo8(20)
 1196 0288 CE01      		movw r24,r28
 1197 028a 0396      		adiw r24,3
 1198 028c 0E94 0000 		call rs485Receive
 1199 0290 8823      		tst r24
 1200 0292 01F4      		brne .+2
 1201 0294 00C0      		rjmp .L27
 105:../../Lib/Rs485_prot.c ****   if (data != SYNC)
 1203               	.LM68:
 1204 0296 8B81      		ldd r24,Y+3
 1205 0298 8A35      		cpi r24,lo8(90)
 1206 029a 01F0      		breq .+2
 1207 029c 00C0      		rjmp .L28
 107:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(0, data);
 1209               	.LM69:
 1210 029e 6AE5      		ldi r22,lo8(90)
 1211 02a0 80E0      		ldi r24,0
 1212 02a2 90E0      		ldi r25,0
 1213 02a4 0E94 0000 		call _crc_xmodem_update
 1214 02a8 8C01      		movw r16,r24
 110:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == 0)
 1216               	.LM70:
 1217 02aa 61E0      		ldi r22,lo8(1)
 1218 02ac CE01      		movw r24,r28
 1219 02ae 0396      		adiw r24,3
 1220 02b0 0E94 0000 		call rs485Receive
 1221 02b4 8823      		tst r24
 1222 02b6 01F4      		brne .+2
 1223 02b8 00C0      		rjmp .L29
 113:../../Lib/Rs485_prot.c ****   if (data != 0)
 1225               	.LM71:
 1226 02ba 8B81      		ldd r24,Y+3
 1227 02bc 8111      		cpse r24,__zero_reg__
 1228 02be 00C0      		rjmp .L30
 116:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 1230               	.LM72:
 1231 02c0 60E0      		ldi r22,0
 1232 02c2 C801      		movw r24,r16
 1233 02c4 0E94 0000 		call _crc_xmodem_update
 1234 02c8 8C01      		movw r16,r24
 119:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 1236               	.LM73:
 1237 02ca 61E0      		ldi r22,lo8(1)
 1238 02cc CE01      		movw r24,r28
 1239 02ce 0396      		adiw r24,3
 1240 02d0 0E94 0000 		call rs485Receive
 1241 02d4 8823      		tst r24
 1242 02d6 01F4      		brne .+2
 1243 02d8 00C0      		rjmp .L31
 121:../../Lib/Rs485_prot.c ****   if (data != rPING)
 1245               	.LM74:
 1246 02da 8B81      		ldd r24,Y+3
 1247 02dc 8038      		cpi r24,lo8(-128)
 1248 02de 01F0      		breq .+2
 1249 02e0 00C0      		rjmp .L32
 123:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 1251               	.LM75:
 1252 02e2 60E8      		ldi r22,lo8(-128)
 1253 02e4 C801      		movw r24,r16
 1254 02e6 0E94 0000 		call _crc_xmodem_update
 1255 02ea 8C01      		movw r16,r24
 126:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 1257               	.LM76:
 1258 02ec 61E0      		ldi r22,lo8(1)
 1259 02ee CE01      		movw r24,r28
 1260 02f0 0396      		adiw r24,3
 1261 02f2 0E94 0000 		call rs485Receive
 1262 02f6 8823      		tst r24
 1263 02f8 01F4      		brne .+2
 1264 02fa 00C0      		rjmp .L33
 128:../../Lib/Rs485_prot.c ****   if (data != dataLen)
 1266               	.LM77:
 1267 02fc 8B81      		ldd r24,Y+3
 1268 02fe 8830      		cpi r24,lo8(8)
 1269 0300 01F0      		breq .+2
 1270 0302 00C0      		rjmp .L34
 130:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 1272               	.LM78:
 1273 0304 68E0      		ldi r22,lo8(8)
 1274 0306 C801      		movw r24,r16
 1275 0308 0E94 0000 		call _crc_xmodem_update
 1276 030c 082F      		mov r16,r24
 1277 030e F92E      		mov r15,r25
 134:../../Lib/Rs485_prot.c ****   for (temp=0; temp < dataLen; temp++)
 1279               	.LM79:
 1280 0310 10E0      		ldi r17,0
 1281               	.L25:
 136:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 5) == pdFALSE)
 1283               	.LM80:
 1284 0312 65E0      		ldi r22,lo8(5)
 1285 0314 CE01      		movw r24,r28
 1286 0316 0396      		adiw r24,3
 1287 0318 0E94 0000 		call rs485Receive
 1288 031c 8111      		cpse r24,__zero_reg__
 1289 031e 00C0      		rjmp .L22
 137:../../Lib/Rs485_prot.c ****       return 2*temp+9;
 1291               	.LM81:
 1292 0320 110F      		lsl r17
 1293 0322 175F      		subi r17,lo8(-(9))
 1294 0324 00C0      		rjmp .L21
 1295               	.L22:
 138:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, data);
 1297               	.LM82:
 1298 0326 6B81      		ldd r22,Y+3
 1299 0328 802F      		mov r24,r16
 1300 032a 9F2D      		mov r25,r15
 1301 032c 0E94 0000 		call _crc_xmodem_update
 1302 0330 082F      		mov r16,r24
 1303 0332 F92E      		mov r15,r25
 139:../../Lib/Rs485_prot.c ****     if (data != temp)
 1305               	.LM83:
 1306 0334 8B81      		ldd r24,Y+3
 1307 0336 8117      		cp r24,r17
 1308 0338 01F0      		breq .L23
 140:../../Lib/Rs485_prot.c ****       return 2*temp+10; 
 1310               	.LM84:
 1311 033a 110F      		lsl r17
 1312 033c 165F      		subi r17,lo8(-(10))
 1313 033e 00C0      		rjmp .L21
 1314               	.L23:
 134:../../Lib/Rs485_prot.c ****   for (temp=0; temp < dataLen; temp++)
 1316               	.LM85:
 1317 0340 1F5F      		subi r17,lo8(-(1))
 1318 0342 1830      		cpi r17,lo8(8)
 1319 0344 01F4      		brne .L25
 145:../../Lib/Rs485_prot.c ****   if(rs485Receive(&crcHi, 1) != pdTRUE)
 1321               	.LM86:
 1322 0346 61E0      		ldi r22,lo8(1)
 1323 0348 CE01      		movw r24,r28
 1324 034a 0296      		adiw r24,2
 1325 034c 0E94 0000 		call rs485Receive
 1326 0350 8130      		cpi r24,lo8(1)
 1327 0352 01F4      		brne .L35
 148:../../Lib/Rs485_prot.c ****   if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
 1329               	.LM87:
 1330 0354 20E0      		ldi r18,0
 1331 0356 41E0      		ldi r20,lo8(1)
 1332 0358 50E0      		ldi r21,0
 1333 035a BE01      		movw r22,r28
 1334 035c 6F5F      		subi r22,-1
 1335 035e 7F4F      		sbci r23,-1
 1336 0360 8091 0000 		lds r24,xRs485Rec
 1337 0364 9091 0000 		lds r25,xRs485Rec+1
 1338 0368 0E94 0000 		call xQueueGenericReceive
 1339 036c 8130      		cpi r24,lo8(1)
 1340 036e 01F4      		brne .L36
 151:../../Lib/Rs485_prot.c ****   if (crcHi != (uint8_t)(crc>>8))
 1342               	.LM88:
 1343 0370 8A81      		ldd r24,Y+2
 1344 0372 8F11      		cpse r24,r15
 1345 0374 00C0      		rjmp .L37
 153:../../Lib/Rs485_prot.c ****   if (crcLo != (uint8_t)(crc & 0xFF))
 1347               	.LM89:
 1348 0376 11E0      		ldi r17,lo8(1)
 1349 0378 8981      		ldd r24,Y+1
 1350 037a 8013      		cpse r24,r16
 1351 037c 00C0      		rjmp .L26
 1352 037e 10E0      		ldi r17,0
 1353               	.L26:
 1354 0380 1195      		neg r17
 1355 0382 00C0      		rjmp .L21
 1356               	.L27:
 103:../../Lib/Rs485_prot.c ****     return 1;
 1358               	.LM90:
 1359 0384 11E0      		ldi r17,lo8(1)
 1360 0386 00C0      		rjmp .L21
 1361               	.L28:
 106:../../Lib/Rs485_prot.c ****     return 2;
 1363               	.LM91:
 1364 0388 12E0      		ldi r17,lo8(2)
 1365 038a 00C0      		rjmp .L21
 1366               	.L29:
 111:../../Lib/Rs485_prot.c ****     return 3;
 1368               	.LM92:
 1369 038c 13E0      		ldi r17,lo8(3)
 1370 038e 00C0      		rjmp .L21
 1371               	.L30:
 114:../../Lib/Rs485_prot.c ****     return 4;
 1373               	.LM93:
 1374 0390 14E0      		ldi r17,lo8(4)
 1375 0392 00C0      		rjmp .L21
 1376               	.L31:
 120:../../Lib/Rs485_prot.c ****     return 5;
 1378               	.LM94:
 1379 0394 15E0      		ldi r17,lo8(5)
 1380 0396 00C0      		rjmp .L21
 1381               	.L32:
 122:../../Lib/Rs485_prot.c ****     return 6;
 1383               	.LM95:
 1384 0398 16E0      		ldi r17,lo8(6)
 1385 039a 00C0      		rjmp .L21
 1386               	.L33:
 127:../../Lib/Rs485_prot.c ****     return 7;
 1388               	.LM96:
 1389 039c 17E0      		ldi r17,lo8(7)
 1390 039e 00C0      		rjmp .L21
 1391               	.L34:
 129:../../Lib/Rs485_prot.c ****     return 8;
 1393               	.LM97:
 1394 03a0 18E0      		ldi r17,lo8(8)
 1395 03a2 00C0      		rjmp .L21
 1396               	.L35:
 146:../../Lib/Rs485_prot.c ****     return 2*temp+11;
 1398               	.LM98:
 1399 03a4 1BE1      		ldi r17,lo8(27)
 1400 03a6 00C0      		rjmp .L21
 1401               	.L36:
 149:../../Lib/Rs485_prot.c ****     return 2*temp+12;
 1403               	.LM99:
 1404 03a8 1CE1      		ldi r17,lo8(28)
 1405 03aa 00C0      		rjmp .L21
 1406               	.L37:
 152:../../Lib/Rs485_prot.c ****     return 254;
 1408               	.LM100:
 1409 03ac 1EEF      		ldi r17,lo8(-2)
 1410               	.L21:
 1411               	.LBE13:
 1412               	.LBE12:
 274:../../Lib/Rs485_prot.c ****   const int len = 8;    
 275:../../Lib/Rs485_prot.c ****   sendPing(devAddr, len);
 276:../../Lib/Rs485_prot.c ****   uint8_t result = receivePong(devAddr, len);
 277:../../Lib/Rs485_prot.c ****   flushRs485RecBuffer();
 1414               	.LM101:
 1415 03ae 0E94 0000 		call flushRs485RecBuffer
 278:../../Lib/Rs485_prot.c **** 
 279:../../Lib/Rs485_prot.c ****   releaseRs485();
 1417               	.LM102:
 1418 03b2 0E94 0000 		call releaseRs485
 280:../../Lib/Rs485_prot.c ****   return result;
 281:../../Lib/Rs485_prot.c **** }
 1420               	.LM103:
 1421 03b6 812F      		mov r24,r17
 1422               	/* epilogue start */
 1423 03b8 2496      		adiw r28,4
 1424 03ba CDBF      		out __SP_L__,r28
 1425 03bc DEBF      		out __SP_H__,r29
 1426 03be DF91      		pop r29
 1427 03c0 CF91      		pop r28
 1428 03c2 1F91      		pop r17
 1429 03c4 0F91      		pop r16
 1430 03c6 FF90      		pop r15
 1431 03c8 0895      		ret
 1442               	.Lscope11:
 1444               		.stabd	78,0,0
 1447               	.global	rs485rollerHello
 1449               	rs485rollerHello:
 1450               		.stabd	46,0,0
 282:../../Lib/Rs485_prot.c **** 
 283:../../Lib/Rs485_prot.c **** uint8_t rs485rollerHello(uint8_t devAddr)
 284:../../Lib/Rs485_prot.c **** {
 1452               	.LM104:
 1453               	.LFBB12:
 1454 03ca DF92      		push r13
 1455 03cc EF92      		push r14
 1456 03ce FF92      		push r15
 1457 03d0 0F93      		push r16
 1458 03d2 1F93      		push r17
 1459 03d4 CF93      		push r28
 1460 03d6 DF93      		push r29
 1461 03d8 00D0      		rcall .
 1462 03da 1F92      		push __zero_reg__
 1463 03dc CDB7      		in r28,__SP_L__
 1464 03de DEB7      		in r29,__SP_H__
 1465               	/* prologue: function */
 1466               	/* frame size = 4 */
 1467               	/* stack size = 11 */
 1468               	.L__stack_usage = 11
 1469 03e0 D82E      		mov r13,r24
 285:../../Lib/Rs485_prot.c ****   struct sterRolet *tmp = NULL;
 286:../../Lib/Rs485_prot.c ****   uint8_t i;
 287:../../Lib/Rs485_prot.c ****   for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
 288:../../Lib/Rs485_prot.c ****     if (rollers[i].address == devAddr)
 1471               	.LM105:
 1472 03e2 4091 0000 		lds r20,rollers
 1473 03e6 5091 0000 		lds r21,rollers+1
 1474 03ea 20E0      		ldi r18,0
 1475 03ec 30E0      		ldi r19,0
 285:../../Lib/Rs485_prot.c ****   struct sterRolet *tmp = NULL;
 1477               	.LM106:
 1478 03ee 00E0      		ldi r16,0
 1479 03f0 10E0      		ldi r17,0
 1480               	.L41:
 1481 03f2 FA01      		movw r30,r20
 1482 03f4 E20F      		add r30,r18
 1483 03f6 F31F      		adc r31,r19
 1485               	.LM107:
 1486 03f8 8181      		ldd r24,Z+1
 1487 03fa 8D11      		cpse r24,r13
 1488 03fc 00C0      		rjmp .L39
 289:../../Lib/Rs485_prot.c ****       tmp = &rollers[i];
 1490               	.LM108:
 1491 03fe 8F01      		movw r16,r30
 1492               	.L39:
 1493 0400 255F      		subi r18,-11
 1494 0402 3F4F      		sbci r19,-1
 287:../../Lib/Rs485_prot.c ****   for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
 1496               	.LM109:
 1497 0404 2E36      		cpi r18,110
 1498 0406 3105      		cpc r19,__zero_reg__
 1499 0408 01F4      		brne .L41
 290:../../Lib/Rs485_prot.c ****     
 291:../../Lib/Rs485_prot.c ****   if (rs485ping(devAddr)==0)
 1501               	.LM110:
 1502 040a 8D2D      		mov r24,r13
 1503 040c 0E94 0000 		call rs485ping
 1504 0410 8111      		cpse r24,__zero_reg__
 1505 0412 00C0      		rjmp .L42
 292:../../Lib/Rs485_prot.c ****   {
 293:../../Lib/Rs485_prot.c ****     if (tmp == NULL)
 1507               	.LM111:
 1508 0414 0115      		cp r16,__zero_reg__
 1509 0416 1105      		cpc r17,__zero_reg__
 1510 0418 01F4      		brne .L43
 294:../../Lib/Rs485_prot.c ****     {
 295:../../Lib/Rs485_prot.c ****       for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
 296:../../Lib/Rs485_prot.c ****       {
 297:../../Lib/Rs485_prot.c ****         if (rollers[i].address == 0)
 1512               	.LM112:
 1513 041a 4091 0000 		lds r20,rollers
 1514 041e 5091 0000 		lds r21,rollers+1
 1515 0422 20E0      		ldi r18,0
 1516 0424 30E0      		ldi r19,0
 1517               	.L47:
 1518 0426 8A01      		movw r16,r20
 1519 0428 020F      		add r16,r18
 1520 042a 131F      		adc r17,r19
 1521 042c F801      		movw r30,r16
 1522 042e 8181      		ldd r24,Z+1
 1523 0430 8111      		cpse r24,__zero_reg__
 1524 0432 00C0      		rjmp .L44
 298:../../Lib/Rs485_prot.c ****         {
 299:../../Lib/Rs485_prot.c ****           tmp = &rollers[i];
 300:../../Lib/Rs485_prot.c ****           tmp->address = devAddr;
 1526               	.LM113:
 1527 0434 D182      		std Z+1,r13
 301:../../Lib/Rs485_prot.c ****           break;
 302:../../Lib/Rs485_prot.c ****         }
 303:../../Lib/Rs485_prot.c ****       }
 304:../../Lib/Rs485_prot.c ****     }
 305:../../Lib/Rs485_prot.c ****     if (tmp != NULL)
 1529               	.LM114:
 1530 0436 0115      		cp r16,__zero_reg__
 1531 0438 1105      		cpc r17,__zero_reg__
 1532 043a 01F4      		brne .L43
 1533               	.L46:
 306:../../Lib/Rs485_prot.c ****     {
 307:../../Lib/Rs485_prot.c ****       tmp->state &= (~NOT_DETECTED);
 308:../../Lib/Rs485_prot.c ****       tmp->address = devAddr;
 309:../../Lib/Rs485_prot.c ****     }
 310:../../Lib/Rs485_prot.c ****     else
 311:../../Lib/Rs485_prot.c ****       return 1;
 1535               	.LM115:
 1536 043c 81E0      		ldi r24,lo8(1)
 1537 043e 00C0      		rjmp .L45
 1538               	.L44:
 1539 0440 255F      		subi r18,-11
 1540 0442 3F4F      		sbci r19,-1
 295:../../Lib/Rs485_prot.c ****       for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
 1542               	.LM116:
 1543 0444 2E36      		cpi r18,110
 1544 0446 3105      		cpc r19,__zero_reg__
 1545 0448 01F4      		brne .L47
 1546 044a 00C0      		rjmp .L46
 1547               	.L43:
 307:../../Lib/Rs485_prot.c ****       tmp->state &= (~NOT_DETECTED);
 1549               	.LM117:
 1550 044c F801      		movw r30,r16
 1551 044e 8081      		ld r24,Z
 1552 0450 8E7F      		andi r24,lo8(-2)
 1553 0452 8083      		st Z,r24
 308:../../Lib/Rs485_prot.c ****       tmp->address = devAddr;
 1555               	.LM118:
 1556 0454 D182      		std Z+1,r13
 1557 0456 00C0      		rjmp .L48
 1558               	.L42:
 312:../../Lib/Rs485_prot.c ****   }
 313:../../Lib/Rs485_prot.c ****   else
 314:../../Lib/Rs485_prot.c ****   {
 315:../../Lib/Rs485_prot.c ****     if (tmp != NULL)
 1560               	.LM119:
 1561 0458 0115      		cp r16,__zero_reg__
 1562 045a 1105      		cpc r17,__zero_reg__
 1563 045c 01F0      		breq .L48
 316:../../Lib/Rs485_prot.c ****     {
 317:../../Lib/Rs485_prot.c ****       if (tmp->state & NOT_DETECTED)
 1565               	.LM120:
 1566 045e F801      		movw r30,r16
 1567 0460 8081      		ld r24,Z
 1568 0462 80FD      		sbrc r24,0
 318:../../Lib/Rs485_prot.c ****       {
 319:../../Lib/Rs485_prot.c ****         tmp->address = 0;
 1570               	.LM121:
 1571 0464 1182      		std Z+1,__zero_reg__
 1572               	.L49:
 320:../../Lib/Rs485_prot.c ****       }
 321:../../Lib/Rs485_prot.c ****       tmp->state |= NOT_DETECTED;
 1574               	.LM122:
 1575 0466 8160      		ori r24,lo8(1)
 1576 0468 F801      		movw r30,r16
 1577 046a 8083      		st Z,r24
 322:../../Lib/Rs485_prot.c ****       return 2;
 1579               	.LM123:
 1580 046c 82E0      		ldi r24,lo8(2)
 1581 046e 00C0      		rjmp .L45
 1582               	.L48:
 323:../../Lib/Rs485_prot.c ****     }
 324:../../Lib/Rs485_prot.c ****   }
 325:../../Lib/Rs485_prot.c ****   
 326:../../Lib/Rs485_prot.c ****   takeRs485();
 1584               	.LM124:
 1585 0470 0E94 0000 		call takeRs485
 1586               	.LBB18:
 1587               	.LBB19:
 161:../../Lib/Rs485_prot.c ****   uint16_t crc = _crc_xmodem_update(0, SYNC);
 1589               	.LM125:
 1590 0474 6AE5      		ldi r22,lo8(90)
 1591 0476 80E0      		ldi r24,0
 1592 0478 90E0      		ldi r25,0
 1593 047a 0E94 0000 		call _crc_xmodem_update
 1594 047e 7C01      		movw r14,r24
 162:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
 1596               	.LM126:
 1597 0480 8AE5      		ldi r24,lo8(90)
 1598 0482 0E94 0000 		call uartRs485SendByte
 164:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, addr);
 1600               	.LM127:
 1601 0486 6D2D      		mov r22,r13
 1602 0488 C701      		movw r24,r14
 1603 048a 0E94 0000 		call _crc_xmodem_update
 1604 048e 7C01      		movw r14,r24
 165:../../Lib/Rs485_prot.c ****   uartRs485SendByte(addr);
 1606               	.LM128:
 1607 0490 8D2D      		mov r24,r13
 1608 0492 0E94 0000 		call uartRs485SendByte
 167:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, rHELLO);
 1610               	.LM129:
 1611 0496 62E8      		ldi r22,lo8(-126)
 1612 0498 C701      		movw r24,r14
 1613 049a 0E94 0000 		call _crc_xmodem_update
 1614 049e 7C01      		movw r14,r24
 168:../../Lib/Rs485_prot.c ****   uartRs485SendByte(rHELLO);
 1616               	.LM130:
 1617 04a0 82E8      		ldi r24,lo8(-126)
 1618 04a2 0E94 0000 		call uartRs485SendByte
 170:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 0);
 1620               	.LM131:
 1621 04a6 60E0      		ldi r22,0
 1622 04a8 C701      		movw r24,r14
 1623 04aa 0E94 0000 		call _crc_xmodem_update
 1624 04ae F82E      		mov r15,r24
 171:../../Lib/Rs485_prot.c ****   uartRs485SendByte(0);
 1626               	.LM132:
 1627 04b0 80E0      		ldi r24,0
 1628 04b2 9C83      		std Y+4,r25
 1629 04b4 0E94 0000 		call uartRs485SendByte
 173:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc >> 8));
 1631               	.LM133:
 1632 04b8 9C81      		ldd r25,Y+4
 1633 04ba 892F      		mov r24,r25
 1634 04bc 0E94 0000 		call uartRs485SendByte
 174:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 1636               	.LM134:
 1637 04c0 8F2D      		mov r24,r15
 1638 04c2 0E94 0000 		call uartRs485SendByte
 1639               	.LBE19:
 1640               	.LBE18:
 1641               	.LBB20:
 1642               	.LBB21:
 182:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 20) == pdFALSE)
 1644               	.LM135:
 1645 04c6 64E1      		ldi r22,lo8(20)
 1646 04c8 CE01      		movw r24,r28
 1647 04ca 0396      		adiw r24,3
 1648 04cc 0E94 0000 		call rs485Receive
 1649 04d0 8823      		tst r24
 1650 04d2 01F4      		brne .+2
 1651 04d4 00C0      		rjmp .L54
 185:../../Lib/Rs485_prot.c ****   if (data != SYNC)
 1653               	.LM136:
 1654 04d6 8B81      		ldd r24,Y+3
 1655 04d8 8A35      		cpi r24,lo8(90)
 1656 04da 01F0      		breq .+2
 1657 04dc 00C0      		rjmp .L55
 187:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(0, data);
 1659               	.LM137:
 1660 04de 6AE5      		ldi r22,lo8(90)
 1661 04e0 80E0      		ldi r24,0
 1662 04e2 90E0      		ldi r25,0
 1663 04e4 0E94 0000 		call _crc_xmodem_update
 1664 04e8 7C01      		movw r14,r24
 190:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == 0)
 1666               	.LM138:
 1667 04ea 61E0      		ldi r22,lo8(1)
 1668 04ec CE01      		movw r24,r28
 1669 04ee 0396      		adiw r24,3
 1670 04f0 0E94 0000 		call rs485Receive
 1671 04f4 8823      		tst r24
 1672 04f6 01F4      		brne .+2
 1673 04f8 00C0      		rjmp .L56
 193:../../Lib/Rs485_prot.c ****   if (data != 0)
 1675               	.LM139:
 1676 04fa 8B81      		ldd r24,Y+3
 1677 04fc 8111      		cpse r24,__zero_reg__
 1678 04fe 00C0      		rjmp .L57
 196:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 1680               	.LM140:
 1681 0500 60E0      		ldi r22,0
 1682 0502 C701      		movw r24,r14
 1683 0504 0E94 0000 		call _crc_xmodem_update
 1684 0508 7C01      		movw r14,r24
 199:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 1686               	.LM141:
 1687 050a 61E0      		ldi r22,lo8(1)
 1688 050c CE01      		movw r24,r28
 1689 050e 0396      		adiw r24,3
 1690 0510 0E94 0000 		call rs485Receive
 1691 0514 8823      		tst r24
 1692 0516 01F4      		brne .+2
 1693 0518 00C0      		rjmp .L58
 201:../../Lib/Rs485_prot.c ****   if (data != rHELLO)
 1695               	.LM142:
 1696 051a 8B81      		ldd r24,Y+3
 1697 051c 8238      		cpi r24,lo8(-126)
 1698 051e 01F0      		breq .+2
 1699 0520 00C0      		rjmp .L59
 203:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 1701               	.LM143:
 1702 0522 62E8      		ldi r22,lo8(-126)
 1703 0524 C701      		movw r24,r14
 1704 0526 0E94 0000 		call _crc_xmodem_update
 1705 052a 7C01      		movw r14,r24
 206:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 1) == pdFALSE)
 1707               	.LM144:
 1708 052c 61E0      		ldi r22,lo8(1)
 1709 052e CE01      		movw r24,r28
 1710 0530 0396      		adiw r24,3
 1711 0532 0E94 0000 		call rs485Receive
 1712 0536 8823      		tst r24
 1713 0538 01F4      		brne .+2
 1714 053a 00C0      		rjmp .L60
 208:../../Lib/Rs485_prot.c ****   if (data > maxSize)
 1716               	.LM145:
 1717 053c 6B81      		ldd r22,Y+3
 1718 053e 6930      		cpi r22,lo8(9)
 1719 0540 00F0      		brlo .+2
 1720 0542 00C0      		rjmp .L61
 1721               	.LBE21:
 1722               	.LBE20:
 327:../../Lib/Rs485_prot.c ****   sendHello(devAddr);
 328:../../Lib/Rs485_prot.c ****   uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
 1724               	.LM146:
 1725 0544 0E5F      		subi r16,-2
 1726 0546 1F4F      		sbci r17,-1
 1727               	.LBB23:
 1728               	.LBB22:
 211:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, data);
 1730               	.LM147:
 1731 0548 C701      		movw r24,r14
 1732 054a 0E94 0000 		call _crc_xmodem_update
 1733 054e F82E      		mov r15,r24
 1734 0550 E92E      		mov r14,r25
 212:../../Lib/Rs485_prot.c ****   memset(response, 0, maxSize);
 1736               	.LM148:
 1737 0552 88E0      		ldi r24,lo8(8)
 1738 0554 F801      		movw r30,r16
 1739               		0:
 1740 0556 1192      		st Z+,__zero_reg__
 1741 0558 8A95      		dec r24
 1742 055a 01F4      		brne 0b
 213:../../Lib/Rs485_prot.c ****   maxSize = data;
 1744               	.LM149:
 1745 055c DB80      		ldd r13,Y+3
 215:../../Lib/Rs485_prot.c ****   for (data=0; data < maxSize; data++)
 1747               	.LM150:
 1748 055e 1B82      		std Y+3,__zero_reg__
 1749               	.L51:
 1750 0560 8B81      		ldd r24,Y+3
 1751 0562 8D15      		cp r24,r13
 1752 0564 00F4      		brsh .L75
 217:../../Lib/Rs485_prot.c ****     if(rs485Receive(response, 5) == pdFALSE)
 1754               	.LM151:
 1755 0566 65E0      		ldi r22,lo8(5)
 1756 0568 C801      		movw r24,r16
 1757 056a 0E94 0000 		call rs485Receive
 1758 056e 8823      		tst r24
 1759 0570 01F0      		breq .L62
 219:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, *((uint8_t *)(response)));
 1761               	.LM152:
 1762 0572 F801      		movw r30,r16
 1763 0574 6191      		ld r22,Z+
 1764 0576 8F01      		movw r16,r30
 1765 0578 8F2D      		mov r24,r15
 1766 057a 9E2D      		mov r25,r14
 1767 057c 0E94 0000 		call _crc_xmodem_update
 1768 0580 F82E      		mov r15,r24
 1769 0582 E92E      		mov r14,r25
 215:../../Lib/Rs485_prot.c ****   for (data=0; data < maxSize; data++)
 1771               	.LM153:
 1772 0584 8B81      		ldd r24,Y+3
 1773 0586 8F5F      		subi r24,lo8(-(1))
 1774 0588 8B83      		std Y+3,r24
 1775 058a 00C0      		rjmp .L51
 1776               	.L75:
 225:../../Lib/Rs485_prot.c ****   if(rs485Receive(&crcHi, 1) != pdTRUE)
 1778               	.LM154:
 1779 058c 61E0      		ldi r22,lo8(1)
 1780 058e CE01      		movw r24,r28
 1781 0590 0296      		adiw r24,2
 1782 0592 0E94 0000 		call rs485Receive
 1783 0596 8130      		cpi r24,lo8(1)
 1784 0598 01F4      		brne .L63
 228:../../Lib/Rs485_prot.c ****   if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
 1786               	.LM155:
 1787 059a 20E0      		ldi r18,0
 1788 059c 41E0      		ldi r20,lo8(1)
 1789 059e 50E0      		ldi r21,0
 1790 05a0 BE01      		movw r22,r28
 1791 05a2 6F5F      		subi r22,-1
 1792 05a4 7F4F      		sbci r23,-1
 1793 05a6 8091 0000 		lds r24,xRs485Rec
 1794 05aa 9091 0000 		lds r25,xRs485Rec+1
 1795 05ae 0E94 0000 		call xQueueGenericReceive
 1796 05b2 8130      		cpi r24,lo8(1)
 1797 05b4 01F4      		brne .L64
 231:../../Lib/Rs485_prot.c ****   if (crcHi != (uint8_t)(crc>>8))
 1799               	.LM156:
 1800 05b6 8A81      		ldd r24,Y+2
 1801 05b8 8E11      		cpse r24,r14
 1802 05ba 00C0      		rjmp .L65
 233:../../Lib/Rs485_prot.c ****   if (crcLo != (uint8_t)(crc & 0xFF))
 1804               	.LM157:
 1805 05bc 81E0      		ldi r24,lo8(1)
 1806 05be 9981      		ldd r25,Y+1
 1807 05c0 9F11      		cpse r25,r15
 1808 05c2 00C0      		rjmp .L53
 1809 05c4 80E0      		ldi r24,0
 1810               	.L53:
 1811 05c6 8195      		neg r24
 1812 05c8 00C0      		rjmp .L50
 1813               	.L54:
 183:../../Lib/Rs485_prot.c ****     return 8;
 1815               	.LM158:
 1816 05ca 88E0      		ldi r24,lo8(8)
 1817 05cc 00C0      		rjmp .L50
 1818               	.L55:
 186:../../Lib/Rs485_prot.c ****     return 2;
 1820               	.LM159:
 1821 05ce 82E0      		ldi r24,lo8(2)
 1822 05d0 00C0      		rjmp .L50
 1823               	.L56:
 191:../../Lib/Rs485_prot.c ****     return 3;
 1825               	.LM160:
 1826 05d2 83E0      		ldi r24,lo8(3)
 1827 05d4 00C0      		rjmp .L50
 1828               	.L57:
 194:../../Lib/Rs485_prot.c ****     return 4;
 1830               	.LM161:
 1831 05d6 84E0      		ldi r24,lo8(4)
 1832 05d8 00C0      		rjmp .L50
 1833               	.L58:
 200:../../Lib/Rs485_prot.c ****     return 5;
 1835               	.LM162:
 1836 05da 85E0      		ldi r24,lo8(5)
 1837 05dc 00C0      		rjmp .L50
 1838               	.L59:
 202:../../Lib/Rs485_prot.c ****     return 6;
 1840               	.LM163:
 1841 05de 86E0      		ldi r24,lo8(6)
 1842 05e0 00C0      		rjmp .L50
 1843               	.L60:
 207:../../Lib/Rs485_prot.c ****     return 7;
 1845               	.LM164:
 1846 05e2 87E0      		ldi r24,lo8(7)
 1847 05e4 00C0      		rjmp .L50
 1848               	.L61:
 209:../../Lib/Rs485_prot.c ****     return 1;
 1850               	.LM165:
 1851 05e6 81E0      		ldi r24,lo8(1)
 1852 05e8 00C0      		rjmp .L50
 1853               	.L62:
 218:../../Lib/Rs485_prot.c ****       return 20;
 1855               	.LM166:
 1856 05ea 84E1      		ldi r24,lo8(20)
 1857 05ec 00C0      		rjmp .L50
 1858               	.L63:
 226:../../Lib/Rs485_prot.c ****     return 21;
 1860               	.LM167:
 1861 05ee 85E1      		ldi r24,lo8(21)
 1862 05f0 00C0      		rjmp .L50
 1863               	.L64:
 229:../../Lib/Rs485_prot.c ****     return 22;
 1865               	.LM168:
 1866 05f2 86E1      		ldi r24,lo8(22)
 1867 05f4 00C0      		rjmp .L50
 1868               	.L65:
 232:../../Lib/Rs485_prot.c ****     return 254;
 1870               	.LM169:
 1871 05f6 8EEF      		ldi r24,lo8(-2)
 1872               	.L50:
 1873               	.LBE22:
 1874               	.LBE23:
 329:../../Lib/Rs485_prot.c ****   releaseRs485();
 1876               	.LM170:
 1877 05f8 8C83      		std Y+4,r24
 1878 05fa 0E94 0000 		call releaseRs485
 1879 05fe 8C81      		ldd r24,Y+4
 1880               	.L45:
 1881               	/* epilogue start */
 330:../../Lib/Rs485_prot.c ****   return result;
 331:../../Lib/Rs485_prot.c **** }
 1883               	.LM171:
 1884 0600 2496      		adiw r28,4
 1885 0602 CDBF      		out __SP_L__,r28
 1886 0604 DEBF      		out __SP_H__,r29
 1887 0606 DF91      		pop r29
 1888 0608 CF91      		pop r28
 1889 060a 1F91      		pop r17
 1890 060c 0F91      		pop r16
 1891 060e FF90      		pop r15
 1892 0610 EF90      		pop r14
 1893 0612 DF90      		pop r13
 1894 0614 0895      		ret
 1914               	.Lscope12:
 1916               		.stabd	78,0,0
 1917               		.section	.rodata.str1.1,"aMS",@progbits,1
 1918               	.LC0:
 1919 0000 6461 7461 		.string	"data 0x%x "
 1919      2030 7825 
 1919      7820 00
 1920               		.text
 1925               	.global	rs485xModemFlash
 1927               	rs485xModemFlash:
 1928               		.stabd	46,0,0
 332:../../Lib/Rs485_prot.c **** 
 333:../../Lib/Rs485_prot.c **** 
 334:../../Lib/Rs485_prot.c **** uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
 335:../../Lib/Rs485_prot.c **** {
 1930               	.LM172:
 1931               	.LFBB13:
 1932 0616 7F92      		push r7
 1933 0618 8F92      		push r8
 1934 061a 9F92      		push r9
 1935 061c AF92      		push r10
 1936 061e BF92      		push r11
 1937 0620 CF92      		push r12
 1938 0622 DF92      		push r13
 1939 0624 EF92      		push r14
 1940 0626 FF92      		push r15
 1941 0628 0F93      		push r16
 1942 062a 1F93      		push r17
 1943 062c CF93      		push r28
 1944 062e DF93      		push r29
 1945 0630 00D0      		rcall .
 1946 0632 CDB7      		in r28,__SP_L__
 1947 0634 DEB7      		in r29,__SP_H__
 1948               	/* prologue: function */
 1949               	/* frame size = 3 */
 1950               	/* stack size = 16 */
 1951               	.L__stack_usage = 16
 1952 0636 7C01      		movw r14,r24
 1953 0638 B62E      		mov r11,r22
 1954 063a 8A01      		movw r16,r20
 336:../../Lib/Rs485_prot.c ****   uint16_t crc;
 337:../../Lib/Rs485_prot.c ****   uint8_t  blad = 0;
 338:../../Lib/Rs485_prot.c ****   uint8_t  data;
 339:../../Lib/Rs485_prot.c ****   uint8_t  nrBloku;
 340:../../Lib/Rs485_prot.c ****   uint8_t  lRetransmisji;
 341:../../Lib/Rs485_prot.c ****   
 342:../../Lib/Rs485_prot.c ****   takeRs485();                                  // Zajmowanie magistrali Rs485
 1956               	.LM173:
 1957 063c 0E94 0000 		call takeRs485
 343:../../Lib/Rs485_prot.c **** 
 344:../../Lib/Rs485_prot.c ****   // Wysyłanie polecenia restartu
 345:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
 1959               	.LM174:
 1960 0640 6AE5      		ldi r22,lo8(90)
 1961 0642 80E0      		ldi r24,0
 1962 0644 90E0      		ldi r25,0
 1963 0646 0E94 0000 		call _crc_xmodem_update
 1964 064a 6C01      		movw r12,r24
 1965 064c 8AE5      		ldi r24,lo8(90)
 1966 064e 0E94 0000 		call uartRs485SendByte
 346:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
 1968               	.LM175:
 1969 0652 6B2D      		mov r22,r11
 1970 0654 C601      		movw r24,r12
 1971 0656 0E94 0000 		call _crc_xmodem_update
 1972 065a 6C01      		movw r12,r24
 1973 065c 8B2D      		mov r24,r11
 1974 065e 0E94 0000 		call uartRs485SendByte
 347:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
 1976               	.LM176:
 1977 0662 61E8      		ldi r22,lo8(-127)
 1978 0664 C601      		movw r24,r12
 1979 0666 0E94 0000 		call _crc_xmodem_update
 1980 066a 6C01      		movw r12,r24
 1981 066c 81E8      		ldi r24,lo8(-127)
 1982 066e 0E94 0000 		call uartRs485SendByte
 348:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
 1984               	.LM177:
 1985 0672 61E0      		ldi r22,lo8(1)
 1986 0674 C601      		movw r24,r12
 1987 0676 0E94 0000 		call _crc_xmodem_update
 1988 067a 6C01      		movw r12,r24
 1989 067c 81E0      		ldi r24,lo8(1)
 1990 067e 0E94 0000 		call uartRs485SendByte
 349:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
 1992               	.LM178:
 1993 0682 6B2D      		mov r22,r11
 1994 0684 C601      		movw r24,r12
 1995 0686 0E94 0000 		call _crc_xmodem_update
 1996 068a D82E      		mov r13,r24
 1997 068c 8B2D      		mov r24,r11
 1998 068e 9B83      		std Y+3,r25
 1999 0690 0E94 0000 		call uartRs485SendByte
 350:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc>>8));
 2001               	.LM179:
 2002 0694 9B81      		ldd r25,Y+3
 2003 0696 892F      		mov r24,r25
 2004 0698 0E94 0000 		call uartRs485SendByte
 351:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 2006               	.LM180:
 2007 069c 8D2D      		mov r24,r13
 2008 069e 0E94 0000 		call uartRs485SendByte
 352:../../Lib/Rs485_prot.c ****  
 353:../../Lib/Rs485_prot.c **** 
 354:../../Lib/Rs485_prot.c ****   // Odbieranie odpowiedzi po wysłaniu polecenia restartu
 355:../../Lib/Rs485_prot.c ****   //Odbieranie SYNC lub C
 356:../../Lib/Rs485_prot.c ****   if(rs485Receive(&data, 100) != pdTRUE)
 2010               	.LM181:
 2011 06a2 64E6      		ldi r22,lo8(100)
 2012 06a4 CE01      		movw r24,r28
 2013 06a6 0296      		adiw r24,2
 2014 06a8 0E94 0000 		call rs485Receive
 2015 06ac 8130      		cpi r24,lo8(1)
 2016 06ae 01F0      		breq .L116
 357:../../Lib/Rs485_prot.c ****   {
 358:../../Lib/Rs485_prot.c ****     blad = 1;                                  // Timeout
 359:../../Lib/Rs485_prot.c ****     if (debugStr != NULL)
 2018               	.LM182:
 2019 06b0 0115      		cp r16,__zero_reg__
 2020 06b2 1105      		cpc r17,__zero_reg__
 2021 06b4 01F0      		breq .L117
 360:../../Lib/Rs485_prot.c ****       fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
 2023               	.LM183:
 2024 06b6 20E0      		ldi r18,lo8(__c.5448)
 2025 06b8 30E0      		ldi r19,hi8(__c.5448)
 2026 06ba 3F93      		push r19
 2027 06bc 2F93      		push r18
 2028 06be 1F93      		push r17
 2029 06c0 0F93      		push r16
 2030 06c2 0E94 0000 		call fprintf_P
 2031 06c6 0F90      		pop __tmp_reg__
 2032 06c8 0F90      		pop __tmp_reg__
 2033 06ca 0F90      		pop __tmp_reg__
 2034 06cc 0F90      		pop __tmp_reg__
 2035 06ce 00C0      		rjmp .L117
 2036               	.L116:
 337:../../Lib/Rs485_prot.c ****   uint8_t  blad = 0;
 2038               	.LM184:
 2039 06d0 A12C      		mov r10,__zero_reg__
 2040 06d2 00C0      		rjmp .L77
 2041               	.L117:
 358:../../Lib/Rs485_prot.c ****     blad = 1;                                  // Timeout
 2043               	.LM185:
 2044 06d4 AA24      		clr r10
 2045 06d6 A394      		inc r10
 2046               	.L77:
 361:../../Lib/Rs485_prot.c ****   }
 362:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(0, data);
 2048               	.LM186:
 2049 06d8 6A81      		ldd r22,Y+2
 2050 06da 80E0      		ldi r24,0
 2051 06dc 90E0      		ldi r25,0
 2052 06de 0E94 0000 		call _crc_xmodem_update
 2053 06e2 6C01      		movw r12,r24
 2054 06e4 8A81      		ldd r24,Y+2
 363:../../Lib/Rs485_prot.c ****  
 364:../../Lib/Rs485_prot.c ****   if ((blad == 0) && (data == 'C'))
 2056               	.LM187:
 2057 06e6 A110      		cpse r10,__zero_reg__
 2058 06e8 00C0      		rjmp .L78
 2060               	.LM188:
 2061 06ea 8334      		cpi r24,lo8(67)
 2062 06ec 01F4      		brne .L78
 365:../../Lib/Rs485_prot.c ****   {
 366:../../Lib/Rs485_prot.c ****     blad = 253;                                //Na urządzeniu jest wgrany tylko bootloader
 367:../../Lib/Rs485_prot.c ****     if (debugStr != NULL)
 2064               	.LM189:
 2065 06ee 0115      		cp r16,__zero_reg__
 2066 06f0 1105      		cpc r17,__zero_reg__
 2067 06f2 01F4      		brne .+2
 2068 06f4 00C0      		rjmp .L111
 368:../../Lib/Rs485_prot.c ****       fprintf_P(debugStr, PSTR("na urzadzeniu wgrany jest tylko bootloader\r\n"));    
 2070               	.LM190:
 2071 06f6 80E0      		ldi r24,lo8(__c.5450)
 2072 06f8 90E0      		ldi r25,hi8(__c.5450)
 2073 06fa 9F93      		push r25
 2074 06fc 8F93      		push r24
 2075 06fe 1F93      		push r17
 2076 0700 0F93      		push r16
 2077 0702 0E94 0000 		call fprintf_P
 2078 0706 0F90      		pop __tmp_reg__
 2079 0708 0F90      		pop __tmp_reg__
 2080 070a 0F90      		pop __tmp_reg__
 2081 070c 0F90      		pop __tmp_reg__
 2082 070e 00C0      		rjmp .L111
 2083               	.L78:
 369:../../Lib/Rs485_prot.c ****   }
 370:../../Lib/Rs485_prot.c ****   else
 371:../../Lib/Rs485_prot.c ****   {
 372:../../Lib/Rs485_prot.c ****     if (data != SYNC)
 2085               	.LM191:
 2086 0710 8A35      		cpi r24,lo8(90)
 2087 0712 01F0      		breq .+2
 2088 0714 00C0      		rjmp .L110
 373:../../Lib/Rs485_prot.c ****       blad = 2;
 374:../../Lib/Rs485_prot.c ****   }
 375:../../Lib/Rs485_prot.c ****  
 376:../../Lib/Rs485_prot.c ****   //Odbieranie odpowiedzi programu. Program zresetuje się by uruchomić bootloadera.
 377:../../Lib/Rs485_prot.c ****   //Odbieranie adresu
 378:../../Lib/Rs485_prot.c ****   if (blad == 0)  //Odbieranie adresu (powinno być 0)
 2090               	.LM192:
 2091 0716 A110      		cpse r10,__zero_reg__
 2092 0718 00C0      		rjmp .L110
 379:../../Lib/Rs485_prot.c ****   {
 380:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 1) != pdTRUE)
 2094               	.LM193:
 2095 071a 61E0      		ldi r22,lo8(1)
 2096 071c CE01      		movw r24,r28
 2097 071e 0296      		adiw r24,2
 2098 0720 0E94 0000 		call rs485Receive
 2099 0724 8130      		cpi r24,lo8(1)
 2100 0726 01F4      		brne .L121
 381:../../Lib/Rs485_prot.c ****       blad = 3;
 382:../../Lib/Rs485_prot.c ****     else
 383:../../Lib/Rs485_prot.c ****     {
 384:../../Lib/Rs485_prot.c ****       if (data != 0)
 2102               	.LM194:
 2103 0728 8A81      		ldd r24,Y+2
 2104 072a 8823      		tst r24
 2105 072c 01F0      		breq .L81
 385:../../Lib/Rs485_prot.c ****         blad = 4;
 2107               	.LM195:
 2108 072e F4E0      		ldi r31,lo8(4)
 2109 0730 AF2E      		mov r10,r31
 2110 0732 00C0      		rjmp .L81
 2111               	.L121:
 381:../../Lib/Rs485_prot.c ****       blad = 3;
 2113               	.LM196:
 2114 0734 A3E0      		ldi r26,lo8(3)
 2115 0736 AA2E      		mov r10,r26
 2116               	.L81:
 386:../../Lib/Rs485_prot.c ****     }
 387:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, data);
 2118               	.LM197:
 2119 0738 6A81      		ldd r22,Y+2
 2120 073a C601      		movw r24,r12
 2121 073c 0E94 0000 		call _crc_xmodem_update
 2122 0740 6C01      		movw r12,r24
 388:../../Lib/Rs485_prot.c ****   }
 389:../../Lib/Rs485_prot.c ****    
 390:../../Lib/Rs485_prot.c ****   //Odbieranie kodu rozkazu
 391:../../Lib/Rs485_prot.c ****   if (blad == 0)
 2124               	.LM198:
 2125 0742 A110      		cpse r10,__zero_reg__
 2126 0744 00C0      		rjmp .L110
 392:../../Lib/Rs485_prot.c ****   {
 393:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 1) != pdTRUE)
 2128               	.LM199:
 2129 0746 61E0      		ldi r22,lo8(1)
 2130 0748 CE01      		movw r24,r28
 2131 074a 0296      		adiw r24,2
 2132 074c 0E94 0000 		call rs485Receive
 2133 0750 8130      		cpi r24,lo8(1)
 2134 0752 01F4      		brne .L123
 394:../../Lib/Rs485_prot.c ****       blad = 5;
 395:../../Lib/Rs485_prot.c ****     else
 396:../../Lib/Rs485_prot.c ****     {
 397:../../Lib/Rs485_prot.c ****       if (data != rFLASH)
 2136               	.LM200:
 2137 0754 8A81      		ldd r24,Y+2
 2138 0756 8138      		cpi r24,lo8(-127)
 2139 0758 01F0      		breq .L83
 398:../../Lib/Rs485_prot.c ****         blad = 6;
 2141               	.LM201:
 2142 075a 76E0      		ldi r23,lo8(6)
 2143 075c A72E      		mov r10,r23
 2144 075e 00C0      		rjmp .L83
 2145               	.L123:
 394:../../Lib/Rs485_prot.c ****       blad = 5;
 2147               	.LM202:
 2148 0760 E5E0      		ldi r30,lo8(5)
 2149 0762 AE2E      		mov r10,r30
 2150               	.L83:
 399:../../Lib/Rs485_prot.c ****     }
 400:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, data);
 2152               	.LM203:
 2153 0764 6A81      		ldd r22,Y+2
 2154 0766 C601      		movw r24,r12
 2155 0768 0E94 0000 		call _crc_xmodem_update
 2156 076c 6C01      		movw r12,r24
 401:../../Lib/Rs485_prot.c ****   }
 402:../../Lib/Rs485_prot.c ****  
 403:../../Lib/Rs485_prot.c ****   //Odbieranie długości danych w rozkazie
 404:../../Lib/Rs485_prot.c ****   if (blad == 0)
 2158               	.LM204:
 2159 076e A110      		cpse r10,__zero_reg__
 2160 0770 00C0      		rjmp .L110
 405:../../Lib/Rs485_prot.c ****   {
 406:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 1) != pdTRUE)
 2162               	.LM205:
 2163 0772 61E0      		ldi r22,lo8(1)
 2164 0774 CE01      		movw r24,r28
 2165 0776 0296      		adiw r24,2
 2166 0778 0E94 0000 		call rs485Receive
 2167 077c 8130      		cpi r24,lo8(1)
 2168 077e 01F4      		brne .L125
 407:../../Lib/Rs485_prot.c ****       blad = 7;
 408:../../Lib/Rs485_prot.c ****     else
 409:../../Lib/Rs485_prot.c ****     {
 410:../../Lib/Rs485_prot.c ****       if (data != 1)
 2170               	.LM206:
 2171 0780 8A81      		ldd r24,Y+2
 2172 0782 8130      		cpi r24,lo8(1)
 2173 0784 01F0      		breq .L85
 411:../../Lib/Rs485_prot.c ****         blad = 8;
 2175               	.LM207:
 2176 0786 58E0      		ldi r21,lo8(8)
 2177 0788 A52E      		mov r10,r21
 2178 078a 00C0      		rjmp .L85
 2179               	.L125:
 407:../../Lib/Rs485_prot.c ****       blad = 7;
 2181               	.LM208:
 2182 078c 67E0      		ldi r22,lo8(7)
 2183 078e A62E      		mov r10,r22
 2184               	.L85:
 412:../../Lib/Rs485_prot.c ****     }
 413:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, data);
 2186               	.LM209:
 2187 0790 6A81      		ldd r22,Y+2
 2188 0792 C601      		movw r24,r12
 2189 0794 0E94 0000 		call _crc_xmodem_update
 2190 0798 6C01      		movw r12,r24
 414:../../Lib/Rs485_prot.c ****   }
 415:../../Lib/Rs485_prot.c ****  
 416:../../Lib/Rs485_prot.c ****   //Odbieranie danych w rozkazie
 417:../../Lib/Rs485_prot.c ****   if (blad == 0)
 2192               	.LM210:
 2193 079a A110      		cpse r10,__zero_reg__
 2194 079c 00C0      		rjmp .L110
 418:../../Lib/Rs485_prot.c ****   {
 419:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 1) != pdTRUE)
 2196               	.LM211:
 2197 079e 61E0      		ldi r22,lo8(1)
 2198 07a0 CE01      		movw r24,r28
 2199 07a2 0296      		adiw r24,2
 2200 07a4 0E94 0000 		call rs485Receive
 2201 07a8 8130      		cpi r24,lo8(1)
 2202 07aa 01F4      		brne .L127
 420:../../Lib/Rs485_prot.c ****       blad = 9;
 421:../../Lib/Rs485_prot.c ****     else
 422:../../Lib/Rs485_prot.c ****     {
 423:../../Lib/Rs485_prot.c ****       if (data != devAddr)
 2204               	.LM212:
 2205 07ac 8A81      		ldd r24,Y+2
 2206 07ae 8B15      		cp r24,r11
 2207 07b0 01F0      		breq .L87
 424:../../Lib/Rs485_prot.c ****         blad = 10;
 2209               	.LM213:
 2210 07b2 3AE0      		ldi r19,lo8(10)
 2211 07b4 A32E      		mov r10,r19
 2212 07b6 00C0      		rjmp .L87
 2213               	.L127:
 420:../../Lib/Rs485_prot.c ****       blad = 9;
 2215               	.LM214:
 2216 07b8 49E0      		ldi r20,lo8(9)
 2217 07ba A42E      		mov r10,r20
 2218               	.L87:
 425:../../Lib/Rs485_prot.c ****     }
 426:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, data);
 2220               	.LM215:
 2221 07bc 6A81      		ldd r22,Y+2
 2222 07be C601      		movw r24,r12
 2223 07c0 0E94 0000 		call _crc_xmodem_update
 2224 07c4 D82E      		mov r13,r24
 2225 07c6 C92E      		mov r12,r25
 427:../../Lib/Rs485_prot.c ****   }
 428:../../Lib/Rs485_prot.c ****    
 429:../../Lib/Rs485_prot.c ****   //Odbieranie CRC Hi
 430:../../Lib/Rs485_prot.c ****   if (blad == 0)
 2227               	.LM216:
 2228 07c8 A110      		cpse r10,__zero_reg__
 2229 07ca 00C0      		rjmp .L110
 431:../../Lib/Rs485_prot.c ****   {
 432:../../Lib/Rs485_prot.c ****     if (rs485Receive(&nrBloku, 1) != pdTRUE)
 2231               	.LM217:
 2232 07cc 61E0      		ldi r22,lo8(1)
 2233 07ce CE01      		movw r24,r28
 2234 07d0 0196      		adiw r24,1
 2235 07d2 0E94 0000 		call rs485Receive
 2236 07d6 8130      		cpi r24,lo8(1)
 2237 07d8 01F4      		brne .L110
 433:../../Lib/Rs485_prot.c ****       blad = 11;
 434:../../Lib/Rs485_prot.c ****     else
 435:../../Lib/Rs485_prot.c ****     {
 436:../../Lib/Rs485_prot.c ****       if ((uint8_t)(crc>>8) != nrBloku)
 2239               	.LM218:
 2240 07da 8981      		ldd r24,Y+1
 2241 07dc 8C11      		cpse r24,r12
 2242 07de 00C0      		rjmp .L110
 437:../../Lib/Rs485_prot.c ****         blad = 12;
 438:../../Lib/Rs485_prot.c ****     }
 439:../../Lib/Rs485_prot.c ****   }
 440:../../Lib/Rs485_prot.c ****    
 441:../../Lib/Rs485_prot.c ****   //Odbieranie CRC Lo
 442:../../Lib/Rs485_prot.c ****   if (blad == 0)
 443:../../Lib/Rs485_prot.c ****   {
 444:../../Lib/Rs485_prot.c ****     if (rs485Receive(&nrBloku, 1) != pdTRUE)
 2244               	.LM219:
 2245 07e0 61E0      		ldi r22,lo8(1)
 2246 07e2 CE01      		movw r24,r28
 2247 07e4 0196      		adiw r24,1
 2248 07e6 0E94 0000 		call rs485Receive
 2249 07ea 8130      		cpi r24,lo8(1)
 2250 07ec 01F4      		brne .L110
 445:../../Lib/Rs485_prot.c ****       blad = 13;
 446:../../Lib/Rs485_prot.c ****     else
 447:../../Lib/Rs485_prot.c ****     {
 448:../../Lib/Rs485_prot.c ****       if ((uint8_t)(crc & 0xFF) != nrBloku)
 2252               	.LM220:
 2253 07ee 8981      		ldd r24,Y+1
 2254 07f0 8D15      		cp r24,r13
 2255 07f2 01F0      		breq .L90
 2256               	.L110:
 449:../../Lib/Rs485_prot.c ****         blad = 14;
 450:../../Lib/Rs485_prot.c ****     }    
 451:../../Lib/Rs485_prot.c ****   }
 452:../../Lib/Rs485_prot.c ****    
 453:../../Lib/Rs485_prot.c ****   if ((blad != 0) && (blad != 253))
 454:../../Lib/Rs485_prot.c ****   {
 455:../../Lib/Rs485_prot.c ****     releaseRs485();
 2258               	.LM221:
 2259 07f4 0E94 0000 		call releaseRs485
 456:../../Lib/Rs485_prot.c ****     flushRs485RecBuffer();  
 2261               	.LM222:
 2262 07f8 0E94 0000 		call flushRs485RecBuffer
 2263 07fc 00C0      		rjmp .L152
 2264               	.L90:
 457:../../Lib/Rs485_prot.c ****     return 1;
 458:../../Lib/Rs485_prot.c ****   }
 459:../../Lib/Rs485_prot.c **** 
 460:../../Lib/Rs485_prot.c **** // Wysyłanie polecenia do bootloadera
 461:../../Lib/Rs485_prot.c ****   if (blad == 0)
 462:../../Lib/Rs485_prot.c ****   {
 463:../../Lib/Rs485_prot.c ****     vTaskDelay(100);
 2266               	.LM223:
 2267 07fe 84E6      		ldi r24,lo8(100)
 2268 0800 90E0      		ldi r25,0
 2269 0802 0E94 0000 		call vTaskDelay
 464:../../Lib/Rs485_prot.c ****      
 465:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
 2271               	.LM224:
 2272 0806 6AE5      		ldi r22,lo8(90)
 2273 0808 80E0      		ldi r24,0
 2274 080a 90E0      		ldi r25,0
 2275 080c 0E94 0000 		call _crc_xmodem_update
 2276 0810 6C01      		movw r12,r24
 2277 0812 8AE5      		ldi r24,lo8(90)
 2278 0814 0E94 0000 		call uartRs485SendByte
 466:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
 2280               	.LM225:
 2281 0818 6B2D      		mov r22,r11
 2282 081a C601      		movw r24,r12
 2283 081c 0E94 0000 		call _crc_xmodem_update
 2284 0820 6C01      		movw r12,r24
 2285 0822 8B2D      		mov r24,r11
 2286 0824 0E94 0000 		call uartRs485SendByte
 467:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
 2288               	.LM226:
 2289 0828 61E8      		ldi r22,lo8(-127)
 2290 082a C601      		movw r24,r12
 2291 082c 0E94 0000 		call _crc_xmodem_update
 2292 0830 6C01      		movw r12,r24
 2293 0832 81E8      		ldi r24,lo8(-127)
 2294 0834 0E94 0000 		call uartRs485SendByte
 468:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
 2296               	.LM227:
 2297 0838 61E0      		ldi r22,lo8(1)
 2298 083a C601      		movw r24,r12
 2299 083c 0E94 0000 		call _crc_xmodem_update
 2300 0840 6C01      		movw r12,r24
 2301 0842 81E0      		ldi r24,lo8(1)
 2302 0844 0E94 0000 		call uartRs485SendByte
 469:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
 2304               	.LM228:
 2305 0848 6B2D      		mov r22,r11
 2306 084a C601      		movw r24,r12
 2307 084c 0E94 0000 		call _crc_xmodem_update
 2308 0850 D82E      		mov r13,r24
 2309 0852 8B2D      		mov r24,r11
 2310 0854 9B83      		std Y+3,r25
 2311 0856 0E94 0000 		call uartRs485SendByte
 470:../../Lib/Rs485_prot.c ****     uartRs485SendByte((uint8_t)(crc>>8));
 2313               	.LM229:
 2314 085a 9B81      		ldd r25,Y+3
 2315 085c 892F      		mov r24,r25
 2316 085e 0E94 0000 		call uartRs485SendByte
 471:../../Lib/Rs485_prot.c ****     uartRs485SendByte((uint8_t)(crc & 0xFF));
 2318               	.LM230:
 2319 0862 8D2D      		mov r24,r13
 2320 0864 0E94 0000 		call uartRs485SendByte
 472:../../Lib/Rs485_prot.c ****  
 473:../../Lib/Rs485_prot.c ****     //Odbieranie odpowiedzi od Bootloadera
 474:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 150) != pdTRUE)
 2322               	.LM231:
 2323 0868 66E9      		ldi r22,lo8(-106)
 2324 086a CE01      		movw r24,r28
 2325 086c 0296      		adiw r24,2
 2326 086e 0E94 0000 		call rs485Receive
 475:../../Lib/Rs485_prot.c ****       blad = 15;
 476:../../Lib/Rs485_prot.c **** 
 477:../../Lib/Rs485_prot.c ****     if (data != 'C')
 2328               	.LM232:
 2329 0872 8A81      		ldd r24,Y+2
 2330 0874 8334      		cpi r24,lo8(67)
 2331 0876 01F0      		breq .L111
 478:../../Lib/Rs485_prot.c ****       blad = 16;
 479:../../Lib/Rs485_prot.c ****     else
 480:../../Lib/Rs485_prot.c ****       blad = 0;
 481:../../Lib/Rs485_prot.c ****   }
 482:../../Lib/Rs485_prot.c ****   else
 483:../../Lib/Rs485_prot.c ****     blad = 0;
 484:../../Lib/Rs485_prot.c ****   
 485:../../Lib/Rs485_prot.c ****    
 486:../../Lib/Rs485_prot.c ****   if (blad != 0)
 487:../../Lib/Rs485_prot.c ****   {
 488:../../Lib/Rs485_prot.c ****     releaseRs485();
 2333               	.LM233:
 2334 0878 0E94 0000 		call releaseRs485
 489:../../Lib/Rs485_prot.c ****     flushRs485RecBuffer();  
 2336               	.LM234:
 2337 087c 0E94 0000 		call flushRs485RecBuffer
 490:../../Lib/Rs485_prot.c ****     if (debugStr != NULL)
 2339               	.LM235:
 2340 0880 0115      		cp r16,__zero_reg__
 2341 0882 1105      		cpc r17,__zero_reg__
 2342 0884 01F0      		breq .L152
 491:../../Lib/Rs485_prot.c ****       fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
 2344               	.LM236:
 2345 0886 80E0      		ldi r24,lo8(__c.5452)
 2346 0888 90E0      		ldi r25,hi8(__c.5452)
 2347 088a 9F93      		push r25
 2348 088c 8F93      		push r24
 2349 088e 1F93      		push r17
 2350 0890 0F93      		push r16
 2351 0892 0E94 0000 		call fprintf_P
 2352 0896 0F90      		pop __tmp_reg__
 2353 0898 0F90      		pop __tmp_reg__
 2354 089a 0F90      		pop __tmp_reg__
 2355 089c 0F90      		pop __tmp_reg__
 2356               	.L152:
 492:../../Lib/Rs485_prot.c ****     return 1;
 2358               	.LM237:
 2359 089e 81E0      		ldi r24,lo8(1)
 2360 08a0 00C0      		rjmp .L149
 2361               	.L111:
 493:../../Lib/Rs485_prot.c ****   }
 494:../../Lib/Rs485_prot.c ****  
 495:../../Lib/Rs485_prot.c ****   uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
 2363               	.LM238:
 2364 08a2 D701      		movw r26,r14
 2365 08a4 1496      		adiw r26,4
 2366 08a6 ED91      		ld r30,X+
 2367 08a8 FC91      		ld r31,X
 2368 08aa 1597      		sbiw r26,4+1
 2369 08ac A280      		ldd r10,Z+2
 2370 08ae AA0C      		lsl r10
 496:../../Lib/Rs485_prot.c ****   if (file->wpis->rozmiarLo == 128)
 2372               	.LM239:
 2373 08b0 8181      		ldd r24,Z+1
 2374 08b2 8038      		cpi r24,lo8(-128)
 2375 08b4 01F4      		brne .L115
 497:../../Lib/Rs485_prot.c ****     liczbaBlokow++;
 2377               	.LM240:
 2378 08b6 A394      		inc r10
 2379               	.L115:
 498:../../Lib/Rs485_prot.c ****    
 499:../../Lib/Rs485_prot.c ****   nrBloku = 1;
 2381               	.LM241:
 2382 08b8 81E0      		ldi r24,lo8(1)
 2383 08ba 8983      		std Y+1,r24
 500:../../Lib/Rs485_prot.c ****   lRetransmisji = 0;
 2385               	.LM242:
 2386 08bc 912C      		mov r9,__zero_reg__
 501:../../Lib/Rs485_prot.c ****    
 502:../../Lib/Rs485_prot.c ****   while (nrBloku <= liczbaBlokow)
 2388               	.LM243:
 2389 08be B12C      		mov r11,__zero_reg__
 503:../../Lib/Rs485_prot.c ****   {
 504:../../Lib/Rs485_prot.c ****     crc = 0;
 505:../../Lib/Rs485_prot.c ****     uartRs485SendByte(SOH);
 506:../../Lib/Rs485_prot.c ****     uartRs485SendByte(nrBloku);
 507:../../Lib/Rs485_prot.c ****     data = (uint8_t)(~nrBloku);
 508:../../Lib/Rs485_prot.c ****     uartRs485SendByte(data);
 509:../../Lib/Rs485_prot.c ****  
 510:../../Lib/Rs485_prot.c ****     for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
 511:../../Lib/Rs485_prot.c ****     {
 512:../../Lib/Rs485_prot.c ****       if (ramDyskCzytajBajtZPliku(file, &data) != 0)
 513:../../Lib/Rs485_prot.c ****         data = 0;
 514:../../Lib/Rs485_prot.c ****       crc = _crc_xmodem_update(crc, data);
 515:../../Lib/Rs485_prot.c ****       uartRs485SendByte(data);
 516:../../Lib/Rs485_prot.c ****     }
 517:../../Lib/Rs485_prot.c ****     uartRs485SendByte((uint8_t)(crc>>8));
 518:../../Lib/Rs485_prot.c ****     uartRs485SendByte((uint8_t)(crc & 0xFF));
 519:../../Lib/Rs485_prot.c ****  
 520:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 100) != pdTRUE)
 521:../../Lib/Rs485_prot.c ****     {
 522:../../Lib/Rs485_prot.c ****       blad = 250;
 523:../../Lib/Rs485_prot.c ****       if (debugStr != NULL)
 524:../../Lib/Rs485_prot.c ****         fputc('#', debugStr);
 525:../../Lib/Rs485_prot.c ****       data = 0;
 526:../../Lib/Rs485_prot.c ****     }
 527:../../Lib/Rs485_prot.c ****      
 528:../../Lib/Rs485_prot.c ****     flushRs485RecBuffer();
 529:../../Lib/Rs485_prot.c **** 
 530:../../Lib/Rs485_prot.c ****     if (data == ACK)
 531:../../Lib/Rs485_prot.c ****     {
 532:../../Lib/Rs485_prot.c ****       nrBloku ++;
 533:../../Lib/Rs485_prot.c ****       lRetransmisji = 0;
 534:../../Lib/Rs485_prot.c ****       blad = 0;
 535:../../Lib/Rs485_prot.c ****       if (debugStr != NULL)
 536:../../Lib/Rs485_prot.c ****       {
 537:../../Lib/Rs485_prot.c ****         fputc('.', debugStr);
 538:../../Lib/Rs485_prot.c ****         if ((nrBloku & 0x0F) == 0)
 539:../../Lib/Rs485_prot.c ****         {
 540:../../Lib/Rs485_prot.c ****           fputc('\r', debugStr);
 541:../../Lib/Rs485_prot.c ****           fputc('\n', debugStr);      
 542:../../Lib/Rs485_prot.c ****         }
 543:../../Lib/Rs485_prot.c ****       }
 544:../../Lib/Rs485_prot.c ****       continue;
 545:../../Lib/Rs485_prot.c ****     }
 546:../../Lib/Rs485_prot.c ****  
 547:../../Lib/Rs485_prot.c ****     if (data == CAN)
 548:../../Lib/Rs485_prot.c ****     {
 549:../../Lib/Rs485_prot.c ****       if (debugStr != NULL)
 550:../../Lib/Rs485_prot.c ****         fputc('C', debugStr);
 551:../../Lib/Rs485_prot.c ****       blad = 249;
 552:../../Lib/Rs485_prot.c ****       break;
 553:../../Lib/Rs485_prot.c ****     }
 554:../../Lib/Rs485_prot.c ****     
 555:../../Lib/Rs485_prot.c ****     if (debugStr != NULL)
 556:../../Lib/Rs485_prot.c ****     {
 557:../../Lib/Rs485_prot.c ****       if (data == NAK)
 558:../../Lib/Rs485_prot.c ****         fputc('N', debugStr);
 559:../../Lib/Rs485_prot.c ****       if (data != 0)
 560:../../Lib/Rs485_prot.c ****         fprintf(debugStr, "data 0x%x ", data);                    
 2391               	.LM244:
 2392 08c0 20E0      		ldi r18,lo8(.LC0)
 2393 08c2 C22E      		mov r12,r18
 2394 08c4 20E0      		ldi r18,hi8(.LC0)
 2395 08c6 D22E      		mov r13,r18
 2396               	.L92:
 502:../../Lib/Rs485_prot.c ****   while (nrBloku <= liczbaBlokow)
 2398               	.LM245:
 2399 08c8 8981      		ldd r24,Y+1
 2400 08ca A816      		cp r10,r24
 2401 08cc 00F4      		brsh .+2
 2402 08ce 00C0      		rjmp .L153
 505:../../Lib/Rs485_prot.c ****     uartRs485SendByte(SOH);
 2404               	.LM246:
 2405 08d0 81E0      		ldi r24,lo8(1)
 2406 08d2 0E94 0000 		call uartRs485SendByte
 506:../../Lib/Rs485_prot.c ****     uartRs485SendByte(nrBloku);
 2408               	.LM247:
 2409 08d6 8981      		ldd r24,Y+1
 2410 08d8 0E94 0000 		call uartRs485SendByte
 507:../../Lib/Rs485_prot.c ****     data = (uint8_t)(~nrBloku);
 2412               	.LM248:
 2413 08dc 8981      		ldd r24,Y+1
 2414 08de 8095      		com r24
 2415 08e0 8A83      		std Y+2,r24
 508:../../Lib/Rs485_prot.c ****     uartRs485SendByte(data);
 2417               	.LM249:
 2418 08e2 0E94 0000 		call uartRs485SendByte
 510:../../Lib/Rs485_prot.c ****     for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
 2420               	.LM250:
 2421 08e6 B12C      		mov r11,__zero_reg__
 504:../../Lib/Rs485_prot.c ****     crc = 0;
 2423               	.LM251:
 2424 08e8 812C      		mov r8,__zero_reg__
 2425 08ea 712C      		mov r7,__zero_reg__
 2426               	.L93:
 512:../../Lib/Rs485_prot.c ****       if (ramDyskCzytajBajtZPliku(file, &data) != 0)
 2428               	.LM252:
 2429 08ec BE01      		movw r22,r28
 2430 08ee 6E5F      		subi r22,-2
 2431 08f0 7F4F      		sbci r23,-1
 2432 08f2 C701      		movw r24,r14
 2433 08f4 0E94 0000 		call ramDyskCzytajBajtZPliku
 2434 08f8 8111      		cpse r24,__zero_reg__
 513:../../Lib/Rs485_prot.c ****         data = 0;
 2436               	.LM253:
 2437 08fa 1A82      		std Y+2,__zero_reg__
 2438               	.L94:
 514:../../Lib/Rs485_prot.c ****       crc = _crc_xmodem_update(crc, data);
 2440               	.LM254:
 2441 08fc 6A81      		ldd r22,Y+2
 2442 08fe 882D      		mov r24,r8
 2443 0900 972D      		mov r25,r7
 2444 0902 0E94 0000 		call _crc_xmodem_update
 2445 0906 882E      		mov r8,r24
 2446 0908 792E      		mov r7,r25
 515:../../Lib/Rs485_prot.c ****       uartRs485SendByte(data);
 2448               	.LM255:
 2449 090a 8A81      		ldd r24,Y+2
 2450 090c 0E94 0000 		call uartRs485SendByte
 510:../../Lib/Rs485_prot.c ****     for (blad = 0; blad < 128; blad++)           //wysyłanie danych. Zmianna Blad jest tymczasowa
 2452               	.LM256:
 2453 0910 B394      		inc r11
 2454 0912 80E8      		ldi r24,lo8(-128)
 2455 0914 B812      		cpse r11,r24
 2456 0916 00C0      		rjmp .L93
 517:../../Lib/Rs485_prot.c ****     uartRs485SendByte((uint8_t)(crc>>8));
 2458               	.LM257:
 2459 0918 872D      		mov r24,r7
 2460 091a 0E94 0000 		call uartRs485SendByte
 518:../../Lib/Rs485_prot.c ****     uartRs485SendByte((uint8_t)(crc & 0xFF));
 2462               	.LM258:
 2463 091e 882D      		mov r24,r8
 2464 0920 0E94 0000 		call uartRs485SendByte
 520:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 100) != pdTRUE)
 2466               	.LM259:
 2467 0924 64E6      		ldi r22,lo8(100)
 2468 0926 CE01      		movw r24,r28
 2469 0928 0296      		adiw r24,2
 2470 092a 0E94 0000 		call rs485Receive
 2471 092e 8130      		cpi r24,lo8(1)
 2472 0930 01F0      		breq .L96
 523:../../Lib/Rs485_prot.c ****       if (debugStr != NULL)
 2474               	.LM260:
 2475 0932 0115      		cp r16,__zero_reg__
 2476 0934 1105      		cpc r17,__zero_reg__
 2477 0936 01F0      		breq .L97
 524:../../Lib/Rs485_prot.c ****         fputc('#', debugStr);
 2479               	.LM261:
 2480 0938 B801      		movw r22,r16
 2481 093a 83E2      		ldi r24,lo8(35)
 2482 093c 90E0      		ldi r25,0
 2483 093e 0E94 0000 		call fputc
 2484               	.L97:
 525:../../Lib/Rs485_prot.c ****       data = 0;
 2486               	.LM262:
 2487 0942 1A82      		std Y+2,__zero_reg__
 522:../../Lib/Rs485_prot.c ****       blad = 250;
 2489               	.LM263:
 2490 0944 9AEF      		ldi r25,lo8(-6)
 2491 0946 B92E      		mov r11,r25
 2492               	.L96:
 528:../../Lib/Rs485_prot.c ****     flushRs485RecBuffer();
 2494               	.LM264:
 2495 0948 0E94 0000 		call flushRs485RecBuffer
 530:../../Lib/Rs485_prot.c ****     if (data == ACK)
 2497               	.LM265:
 2498 094c 8A81      		ldd r24,Y+2
 2499 094e 8630      		cpi r24,lo8(6)
 2500 0950 01F4      		brne .L98
 532:../../Lib/Rs485_prot.c ****       nrBloku ++;
 2502               	.LM266:
 2503 0952 8981      		ldd r24,Y+1
 2504 0954 8F5F      		subi r24,lo8(-(1))
 2505 0956 8983      		std Y+1,r24
 535:../../Lib/Rs485_prot.c ****       if (debugStr != NULL)
 2507               	.LM267:
 2508 0958 0115      		cp r16,__zero_reg__
 2509 095a 1105      		cpc r17,__zero_reg__
 2510 095c 01F0      		breq .L151
 537:../../Lib/Rs485_prot.c ****         fputc('.', debugStr);
 2512               	.LM268:
 2513 095e B801      		movw r22,r16
 2514 0960 8EE2      		ldi r24,lo8(46)
 2515 0962 90E0      		ldi r25,0
 2516 0964 0E94 0000 		call fputc
 538:../../Lib/Rs485_prot.c ****         if ((nrBloku & 0x0F) == 0)
 2518               	.LM269:
 2519 0968 8981      		ldd r24,Y+1
 2520 096a 8F70      		andi r24,lo8(15)
 2521 096c 01F4      		brne .L151
 540:../../Lib/Rs485_prot.c ****           fputc('\r', debugStr);
 2523               	.LM270:
 2524 096e B801      		movw r22,r16
 2525 0970 8DE0      		ldi r24,lo8(13)
 2526 0972 90E0      		ldi r25,0
 2527 0974 0E94 0000 		call fputc
 541:../../Lib/Rs485_prot.c ****           fputc('\n', debugStr);      
 2529               	.LM271:
 2530 0978 B801      		movw r22,r16
 2531 097a 8AE0      		ldi r24,lo8(10)
 2532 097c 90E0      		ldi r25,0
 2533 097e 0E94 0000 		call fputc
 2534               	.L151:
 533:../../Lib/Rs485_prot.c ****       lRetransmisji = 0;
 2536               	.LM272:
 2537 0982 912C      		mov r9,__zero_reg__
 534:../../Lib/Rs485_prot.c ****       blad = 0;
 2539               	.LM273:
 2540 0984 B12C      		mov r11,__zero_reg__
 2541 0986 00C0      		rjmp .L92
 2542               	.L98:
 547:../../Lib/Rs485_prot.c ****     if (data == CAN)
 2544               	.LM274:
 2545 0988 8831      		cpi r24,lo8(24)
 2546 098a 01F4      		brne .L102
 549:../../Lib/Rs485_prot.c ****       if (debugStr != NULL)
 2548               	.LM275:
 2549 098c 0115      		cp r16,__zero_reg__
 2550 098e 1105      		cpc r17,__zero_reg__
 2551 0990 01F4      		brne .+2
 2552 0992 00C0      		rjmp .L129
 550:../../Lib/Rs485_prot.c ****         fputc('C', debugStr);
 2554               	.LM276:
 2555 0994 B801      		movw r22,r16
 2556 0996 83E4      		ldi r24,lo8(67)
 2557 0998 90E0      		ldi r25,0
 2558 099a 0E94 0000 		call fputc
 2559 099e 00C0      		rjmp .L129
 2560               	.L102:
 555:../../Lib/Rs485_prot.c ****     if (debugStr != NULL)
 2562               	.LM277:
 2563 09a0 0115      		cp r16,__zero_reg__
 2564 09a2 1105      		cpc r17,__zero_reg__
 2565 09a4 01F0      		breq .L105
 557:../../Lib/Rs485_prot.c ****       if (data == NAK)
 2567               	.LM278:
 2568 09a6 8531      		cpi r24,lo8(21)
 2569 09a8 01F4      		brne .L106
 558:../../Lib/Rs485_prot.c ****         fputc('N', debugStr);
 2571               	.LM279:
 2572 09aa B801      		movw r22,r16
 2573 09ac 8EE4      		ldi r24,lo8(78)
 2574 09ae 90E0      		ldi r25,0
 2575 09b0 0E94 0000 		call fputc
 2576               	.L106:
 559:../../Lib/Rs485_prot.c ****       if (data != 0)
 2578               	.LM280:
 2579 09b4 8A81      		ldd r24,Y+2
 2580 09b6 8823      		tst r24
 2581 09b8 01F0      		breq .L105
 2583               	.LM281:
 2584 09ba 1F92      		push __zero_reg__
 2585 09bc 8F93      		push r24
 2586 09be DF92      		push r13
 2587 09c0 CF92      		push r12
 2588 09c2 1F93      		push r17
 2589 09c4 0F93      		push r16
 2590 09c6 0E94 0000 		call fprintf
 2591 09ca 0F90      		pop __tmp_reg__
 2592 09cc 0F90      		pop __tmp_reg__
 2593 09ce 0F90      		pop __tmp_reg__
 2594 09d0 0F90      		pop __tmp_reg__
 2595 09d2 0F90      		pop __tmp_reg__
 2596 09d4 0F90      		pop __tmp_reg__
 2597               	.L105:
 561:../../Lib/Rs485_prot.c ****     }
 562:../../Lib/Rs485_prot.c ****     
 563:../../Lib/Rs485_prot.c ****     lRetransmisji ++;
 2599               	.LM282:
 2600 09d6 9394      		inc r9
 564:../../Lib/Rs485_prot.c ****      
 565:../../Lib/Rs485_prot.c ****     if (lRetransmisji == 3)
 2602               	.LM283:
 2603 09d8 A3E0      		ldi r26,lo8(3)
 2604 09da 9A12      		cpse r9,r26
 2605 09dc 00C0      		rjmp .L92
 566:../../Lib/Rs485_prot.c ****     {
 567:../../Lib/Rs485_prot.c ****       blad = 248;
 2607               	.LM284:
 2608 09de 18EF      		ldi r17,lo8(-8)
 2609 09e0 00C0      		rjmp .L109
 2610               	.L153:
 2611 09e2 1B2D      		mov r17,r11
 568:../../Lib/Rs485_prot.c ****       break;
 569:../../Lib/Rs485_prot.c ****     }
 570:../../Lib/Rs485_prot.c ****   }
 571:../../Lib/Rs485_prot.c ****  
 572:../../Lib/Rs485_prot.c ****   if (blad == 0)
 2613               	.LM285:
 2614 09e4 B110      		cpse r11,__zero_reg__
 2615 09e6 00C0      		rjmp .L109
 573:../../Lib/Rs485_prot.c ****   {
 574:../../Lib/Rs485_prot.c ****     uartRs485SendByte(EOT); 
 2617               	.LM286:
 2618 09e8 84E0      		ldi r24,lo8(4)
 2619 09ea 0E94 0000 		call uartRs485SendByte
 575:../../Lib/Rs485_prot.c ****     if(rs485Receive(&data, 25) == pdTRUE)
 2621               	.LM287:
 2622 09ee 69E1      		ldi r22,lo8(25)
 2623 09f0 CE01      		movw r24,r28
 2624 09f2 0296      		adiw r24,2
 2625 09f4 0E94 0000 		call rs485Receive
 2626 09f8 8130      		cpi r24,lo8(1)
 2627 09fa 01F4      		brne .L109
 576:../../Lib/Rs485_prot.c ****     {
 577:../../Lib/Rs485_prot.c ****       if (data == ACK)
 2629               	.LM288:
 2630 09fc 8A81      		ldd r24,Y+2
 2631 09fe 8630      		cpi r24,lo8(6)
 2632 0a00 01F4      		brne .L109
 578:../../Lib/Rs485_prot.c ****       {
 579:../../Lib/Rs485_prot.c ****         uartRs485SendByte(EOT);
 2634               	.LM289:
 2635 0a02 84E0      		ldi r24,lo8(4)
 2636 0a04 0E94 0000 		call uartRs485SendByte
 580:../../Lib/Rs485_prot.c ****         rs485Receive(&data, 25);
 2638               	.LM290:
 2639 0a08 69E1      		ldi r22,lo8(25)
 2640 0a0a CE01      		movw r24,r28
 2641 0a0c 0296      		adiw r24,2
 2642 0a0e 0E94 0000 		call rs485Receive
 2643               	.L109:
 581:../../Lib/Rs485_prot.c ****       }
 582:../../Lib/Rs485_prot.c ****     }
 583:../../Lib/Rs485_prot.c ****   }
 584:../../Lib/Rs485_prot.c **** 
 585:../../Lib/Rs485_prot.c ****   flushRs485RecBuffer();  
 2645               	.LM291:
 2646 0a12 0E94 0000 		call flushRs485RecBuffer
 586:../../Lib/Rs485_prot.c ****   releaseRs485();
 2648               	.LM292:
 2649 0a16 0E94 0000 		call releaseRs485
 587:../../Lib/Rs485_prot.c ****   return blad;
 2651               	.LM293:
 2652 0a1a 812F      		mov r24,r17
 2653 0a1c 00C0      		rjmp .L149
 2654               	.L129:
 551:../../Lib/Rs485_prot.c ****       blad = 249;
 2656               	.LM294:
 2657 0a1e 19EF      		ldi r17,lo8(-7)
 2658 0a20 00C0      		rjmp .L109
 2659               	.L149:
 2660               	/* epilogue start */
 588:../../Lib/Rs485_prot.c **** }
 2662               	.LM295:
 2663 0a22 2396      		adiw r28,3
 2664 0a24 CDBF      		out __SP_L__,r28
 2665 0a26 DEBF      		out __SP_H__,r29
 2666 0a28 DF91      		pop r29
 2667 0a2a CF91      		pop r28
 2668 0a2c 1F91      		pop r17
 2669 0a2e 0F91      		pop r16
 2670 0a30 FF90      		pop r15
 2671 0a32 EF90      		pop r14
 2672 0a34 DF90      		pop r13
 2673 0a36 CF90      		pop r12
 2674 0a38 BF90      		pop r11
 2675 0a3a AF90      		pop r10
 2676 0a3c 9F90      		pop r9
 2677 0a3e 8F90      		pop r8
 2678 0a40 7F90      		pop r7
 2679 0a42 0895      		ret
 2687               	.Lscope13:
 2689               		.stabd	78,0,0
 2694               	.global	rs485curtainUp
 2696               	rs485curtainUp:
 2697               		.stabd	46,0,0
 589:../../Lib/Rs485_prot.c **** 
 590:../../Lib/Rs485_prot.c **** uint8_t rs485curtainUp(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
 591:../../Lib/Rs485_prot.c **** {
 2699               	.LM296:
 2700               	.LFBB14:
 2701 0a44 CF92      		push r12
 2702 0a46 DF92      		push r13
 2703 0a48 EF92      		push r14
 2704 0a4a FF92      		push r15
 2705 0a4c 0F93      		push r16
 2706 0a4e 1F93      		push r17
 2707 0a50 CF93      		push r28
 2708 0a52 DF93      		push r29
 2709 0a54 1F92      		push __zero_reg__
 2710 0a56 CDB7      		in r28,__SP_L__
 2711 0a58 DEB7      		in r29,__SP_H__
 2712               	/* prologue: function */
 2713               	/* frame size = 1 */
 2714               	/* stack size = 9 */
 2715               	.L__stack_usage = 9
 2716 0a5a 082F      		mov r16,r24
 2717 0a5c F62E      		mov r15,r22
 2718 0a5e 142F      		mov r17,r20
 592:../../Lib/Rs485_prot.c ****   uint16_t crc = 0;
 593:../../Lib/Rs485_prot.c ****   
 594:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, SYNC);
 2720               	.LM297:
 2721 0a60 6AE5      		ldi r22,lo8(90)
 2722 0a62 80E0      		ldi r24,0
 2723 0a64 90E0      		ldi r25,0
 2724 0a66 0E94 0000 		call _crc_xmodem_update
 2725 0a6a 6C01      		movw r12,r24
 595:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
 2727               	.LM298:
 2728 0a6c 8AE5      		ldi r24,lo8(90)
 2729 0a6e 0E94 0000 		call uartRs485SendByte
 596:../../Lib/Rs485_prot.c **** 
 597:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, deviceAddr);
 2731               	.LM299:
 2732 0a72 602F      		mov r22,r16
 2733 0a74 C601      		movw r24,r12
 2734 0a76 0E94 0000 		call _crc_xmodem_update
 2735 0a7a 6C01      		movw r12,r24
 598:../../Lib/Rs485_prot.c ****   uartRs485SendByte(deviceAddr);
 2737               	.LM300:
 2738 0a7c 802F      		mov r24,r16
 2739 0a7e 0E94 0000 		call uartRs485SendByte
 599:../../Lib/Rs485_prot.c ****   if (curtainNo == 0)
 2741               	.LM301:
 2742 0a82 F110      		cpse r15,__zero_reg__
 2743 0a84 00C0      		rjmp .L155
 600:../../Lib/Rs485_prot.c ****   {
 601:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, rPodniesRolete1);
 2745               	.LM302:
 2746 0a86 60E2      		ldi r22,lo8(32)
 2747 0a88 C601      		movw r24,r12
 2748 0a8a 0E94 0000 		call _crc_xmodem_update
 2749 0a8e 7C01      		movw r14,r24
 602:../../Lib/Rs485_prot.c ****     uartRs485SendByte(rPodniesRolete1);
 2751               	.LM303:
 2752 0a90 80E2      		ldi r24,lo8(32)
 2753 0a92 00C0      		rjmp .L157
 2754               	.L155:
 603:../../Lib/Rs485_prot.c ****   }
 604:../../Lib/Rs485_prot.c ****   else
 605:../../Lib/Rs485_prot.c ****   {
 606:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, rPodniesRolete2);
 2756               	.LM304:
 2757 0a94 61E2      		ldi r22,lo8(33)
 2758 0a96 C601      		movw r24,r12
 2759 0a98 0E94 0000 		call _crc_xmodem_update
 2760 0a9c 7C01      		movw r14,r24
 607:../../Lib/Rs485_prot.c ****     uartRs485SendByte(rPodniesRolete2); 
 2762               	.LM305:
 2763 0a9e 81E2      		ldi r24,lo8(33)
 2764               	.L157:
 2765 0aa0 0E94 0000 		call uartRs485SendByte
 608:../../Lib/Rs485_prot.c ****   }
 609:../../Lib/Rs485_prot.c ****   
 610:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
 2767               	.LM306:
 2768 0aa4 61E0      		ldi r22,lo8(1)
 2769 0aa6 C701      		movw r24,r14
 2770 0aa8 0E94 0000 		call _crc_xmodem_update
 2771 0aac 7C01      		movw r14,r24
 2772 0aae 81E0      		ldi r24,lo8(1)
 2773 0ab0 0E94 0000 		call uartRs485SendByte
 611:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, pos);  uartRs485SendByte(pos);
 2775               	.LM307:
 2776 0ab4 612F      		mov r22,r17
 2777 0ab6 C701      		movw r24,r14
 2778 0ab8 0E94 0000 		call _crc_xmodem_update
 2779 0abc 082F      		mov r16,r24
 2780 0abe 812F      		mov r24,r17
 2781 0ac0 9983      		std Y+1,r25
 2782 0ac2 0E94 0000 		call uartRs485SendByte
 612:../../Lib/Rs485_prot.c ****   
 613:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc>>8));
 2784               	.LM308:
 2785 0ac6 9981      		ldd r25,Y+1
 2786 0ac8 892F      		mov r24,r25
 2787 0aca 0E94 0000 		call uartRs485SendByte
 614:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 2789               	.LM309:
 2790 0ace 802F      		mov r24,r16
 2791 0ad0 0E94 0000 		call uartRs485SendByte
 615:../../Lib/Rs485_prot.c ****   
 616:../../Lib/Rs485_prot.c ****   return 0;
 617:../../Lib/Rs485_prot.c **** }
 2793               	.LM310:
 2794 0ad4 80E0      		ldi r24,0
 2795               	/* epilogue start */
 2796 0ad6 0F90      		pop __tmp_reg__
 2797 0ad8 DF91      		pop r29
 2798 0ada CF91      		pop r28
 2799 0adc 1F91      		pop r17
 2800 0ade 0F91      		pop r16
 2801 0ae0 FF90      		pop r15
 2802 0ae2 EF90      		pop r14
 2803 0ae4 DF90      		pop r13
 2804 0ae6 CF90      		pop r12
 2805 0ae8 0895      		ret
 2807               	.Lscope14:
 2809               		.stabd	78,0,0
 2814               	.global	rs485Led
 2816               	rs485Led:
 2817               		.stabd	46,0,0
 618:../../Lib/Rs485_prot.c **** 
 619:../../Lib/Rs485_prot.c **** uint8_t rs485Led(uint8_t deviceAddr, uint8_t ledNo, uint8_t time)
 620:../../Lib/Rs485_prot.c **** {
 2819               	.LM311:
 2820               	.LFBB15:
 2821 0aea CF92      		push r12
 2822 0aec DF92      		push r13
 2823 0aee FF92      		push r15
 2824 0af0 0F93      		push r16
 2825 0af2 1F93      		push r17
 2826 0af4 CF93      		push r28
 2827 0af6 DF93      		push r29
 2828 0af8 1F92      		push __zero_reg__
 2829 0afa CDB7      		in r28,__SP_L__
 2830 0afc DEB7      		in r29,__SP_H__
 2831               	/* prologue: function */
 2832               	/* frame size = 1 */
 2833               	/* stack size = 8 */
 2834               	.L__stack_usage = 8
 2835 0afe 182F      		mov r17,r24
 2836 0b00 F62E      		mov r15,r22
 2837 0b02 042F      		mov r16,r20
 621:../../Lib/Rs485_prot.c ****   uint16_t crc = 0;
 622:../../Lib/Rs485_prot.c ****   
 623:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, SYNC);
 2839               	.LM312:
 2840 0b04 6AE5      		ldi r22,lo8(90)
 2841 0b06 80E0      		ldi r24,0
 2842 0b08 90E0      		ldi r25,0
 2843 0b0a 0E94 0000 		call _crc_xmodem_update
 2844 0b0e 6C01      		movw r12,r24
 624:../../Lib/Rs485_prot.c ****   uartRs485SendByte(SYNC);
 2846               	.LM313:
 2847 0b10 8AE5      		ldi r24,lo8(90)
 2848 0b12 0E94 0000 		call uartRs485SendByte
 625:../../Lib/Rs485_prot.c **** 
 626:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, deviceAddr);
 2850               	.LM314:
 2851 0b16 612F      		mov r22,r17
 2852 0b18 C601      		movw r24,r12
 2853 0b1a 0E94 0000 		call _crc_xmodem_update
 2854 0b1e 6C01      		movw r12,r24
 627:../../Lib/Rs485_prot.c ****   uartRs485SendByte(deviceAddr);
 2856               	.LM315:
 2857 0b20 812F      		mov r24,r17
 2858 0b22 0E94 0000 		call uartRs485SendByte
 628:../../Lib/Rs485_prot.c **** 
 629:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, ledNo);
 2860               	.LM316:
 2861 0b26 6F2D      		mov r22,r15
 2862 0b28 C601      		movw r24,r12
 2863 0b2a 0E94 0000 		call _crc_xmodem_update
 630:../../Lib/Rs485_prot.c ****   
 631:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
 2865               	.LM317:
 2866 0b2e 61E0      		ldi r22,lo8(1)
 2867 0b30 0E94 0000 		call _crc_xmodem_update
 2868 0b34 6C01      		movw r12,r24
 2869 0b36 81E0      		ldi r24,lo8(1)
 2870 0b38 0E94 0000 		call uartRs485SendByte
 632:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, time);  uartRs485SendByte(time);
 2872               	.LM318:
 2873 0b3c 602F      		mov r22,r16
 2874 0b3e C601      		movw r24,r12
 2875 0b40 0E94 0000 		call _crc_xmodem_update
 2876 0b44 182F      		mov r17,r24
 2877 0b46 802F      		mov r24,r16
 2878 0b48 9983      		std Y+1,r25
 2879 0b4a 0E94 0000 		call uartRs485SendByte
 633:../../Lib/Rs485_prot.c ****   
 634:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc>>8));
 2881               	.LM319:
 2882 0b4e 9981      		ldd r25,Y+1
 2883 0b50 892F      		mov r24,r25
 2884 0b52 0E94 0000 		call uartRs485SendByte
 635:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 2886               	.LM320:
 2887 0b56 812F      		mov r24,r17
 2888 0b58 0E94 0000 		call uartRs485SendByte
 636:../../Lib/Rs485_prot.c ****   
 637:../../Lib/Rs485_prot.c ****   return 0;
 638:../../Lib/Rs485_prot.c **** }
 2890               	.LM321:
 2891 0b5c 80E0      		ldi r24,0
 2892               	/* epilogue start */
 2893 0b5e 0F90      		pop __tmp_reg__
 2894 0b60 DF91      		pop r29
 2895 0b62 CF91      		pop r28
 2896 0b64 1F91      		pop r17
 2897 0b66 0F91      		pop r16
 2898 0b68 FF90      		pop r15
 2899 0b6a DF90      		pop r13
 2900 0b6c CF90      		pop r12
 2901 0b6e 0895      		ret
 2903               	.Lscope15:
 2905               		.stabd	78,0,0
 2910               	.global	rs485curtainDown
 2912               	rs485curtainDown:
 2913               		.stabd	46,0,0
 639:../../Lib/Rs485_prot.c **** 
 640:../../Lib/Rs485_prot.c **** 
 641:../../Lib/Rs485_prot.c **** uint8_t rs485curtainDown(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
 642:../../Lib/Rs485_prot.c **** {
 2915               	.LM322:
 2916               	.LFBB16:
 2917 0b70 CF92      		push r12
 2918 0b72 DF92      		push r13
 2919 0b74 EF92      		push r14
 2920 0b76 FF92      		push r15
 2921 0b78 0F93      		push r16
 2922 0b7a 1F93      		push r17
 2923 0b7c CF93      		push r28
 2924 0b7e DF93      		push r29
 2925 0b80 1F92      		push __zero_reg__
 2926 0b82 CDB7      		in r28,__SP_L__
 2927 0b84 DEB7      		in r29,__SP_H__
 2928               	/* prologue: function */
 2929               	/* frame size = 1 */
 2930               	/* stack size = 9 */
 2931               	.L__stack_usage = 9
 2932 0b86 082F      		mov r16,r24
 2933 0b88 F62E      		mov r15,r22
 2934 0b8a 142F      		mov r17,r20
 643:../../Lib/Rs485_prot.c ****   uint16_t crc = 0;
 644:../../Lib/Rs485_prot.c ****   
 645:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, SYNC);            uartRs485SendByte(SYNC);
 2936               	.LM323:
 2937 0b8c 6AE5      		ldi r22,lo8(90)
 2938 0b8e 80E0      		ldi r24,0
 2939 0b90 90E0      		ldi r25,0
 2940 0b92 0E94 0000 		call _crc_xmodem_update
 2941 0b96 6C01      		movw r12,r24
 2942 0b98 8AE5      		ldi r24,lo8(90)
 2943 0b9a 0E94 0000 		call uartRs485SendByte
 646:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, deviceAddr);    uartRs485SendByte(deviceAddr);
 2945               	.LM324:
 2946 0b9e 602F      		mov r22,r16
 2947 0ba0 C601      		movw r24,r12
 2948 0ba2 0E94 0000 		call _crc_xmodem_update
 2949 0ba6 6C01      		movw r12,r24
 2950 0ba8 802F      		mov r24,r16
 2951 0baa 0E94 0000 		call uartRs485SendByte
 647:../../Lib/Rs485_prot.c ****   if (curtainNo == 0)
 2953               	.LM325:
 2954 0bae F110      		cpse r15,__zero_reg__
 2955 0bb0 00C0      		rjmp .L160
 648:../../Lib/Rs485_prot.c ****   {
 649:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, rOpuscRolete1); uartRs485SendByte(rOpuscRolete1);
 2957               	.LM326:
 2958 0bb2 60E1      		ldi r22,lo8(16)
 2959 0bb4 C601      		movw r24,r12
 2960 0bb6 0E94 0000 		call _crc_xmodem_update
 2961 0bba 7C01      		movw r14,r24
 2962 0bbc 80E1      		ldi r24,lo8(16)
 2963 0bbe 00C0      		rjmp .L162
 2964               	.L160:
 650:../../Lib/Rs485_prot.c ****   }
 651:../../Lib/Rs485_prot.c ****   else
 652:../../Lib/Rs485_prot.c ****   {
 653:../../Lib/Rs485_prot.c ****     crc = _crc_xmodem_update(crc, rOpuscRolete2); uartRs485SendByte(rOpuscRolete2); 
 2966               	.LM327:
 2967 0bc0 61E1      		ldi r22,lo8(17)
 2968 0bc2 C601      		movw r24,r12
 2969 0bc4 0E94 0000 		call _crc_xmodem_update
 2970 0bc8 7C01      		movw r14,r24
 2971 0bca 81E1      		ldi r24,lo8(17)
 2972               	.L162:
 2973 0bcc 0E94 0000 		call uartRs485SendByte
 654:../../Lib/Rs485_prot.c ****   }
 655:../../Lib/Rs485_prot.c **** 
 656:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, 1);               uartRs485SendByte(1);
 2975               	.LM328:
 2976 0bd0 61E0      		ldi r22,lo8(1)
 2977 0bd2 C701      		movw r24,r14
 2978 0bd4 0E94 0000 		call _crc_xmodem_update
 2979 0bd8 7C01      		movw r14,r24
 2980 0bda 81E0      		ldi r24,lo8(1)
 2981 0bdc 0E94 0000 		call uartRs485SendByte
 657:../../Lib/Rs485_prot.c ****   crc = _crc_xmodem_update(crc, pos);         uartRs485SendByte(pos);
 2983               	.LM329:
 2984 0be0 612F      		mov r22,r17
 2985 0be2 C701      		movw r24,r14
 2986 0be4 0E94 0000 		call _crc_xmodem_update
 2987 0be8 082F      		mov r16,r24
 2988 0bea 812F      		mov r24,r17
 2989 0bec 9983      		std Y+1,r25
 2990 0bee 0E94 0000 		call uartRs485SendByte
 658:../../Lib/Rs485_prot.c ****   
 659:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc>>8));
 2992               	.LM330:
 2993 0bf2 9981      		ldd r25,Y+1
 2994 0bf4 892F      		mov r24,r25
 2995 0bf6 0E94 0000 		call uartRs485SendByte
 660:../../Lib/Rs485_prot.c ****   uartRs485SendByte((uint8_t)(crc & 0xFF));
 2997               	.LM331:
 2998 0bfa 802F      		mov r24,r16
 2999 0bfc 0E94 0000 		call uartRs485SendByte
 661:../../Lib/Rs485_prot.c **** 
 662:../../Lib/Rs485_prot.c ****   return 0;
 663:../../Lib/Rs485_prot.c **** }
 3001               	.LM332:
 3002 0c00 80E0      		ldi r24,0
 3003               	/* epilogue start */
 3004 0c02 0F90      		pop __tmp_reg__
 3005 0c04 DF91      		pop r29
 3006 0c06 CF91      		pop r28
 3007 0c08 1F91      		pop r17
 3008 0c0a 0F91      		pop r16
 3009 0c0c FF90      		pop r15
 3010 0c0e EF90      		pop r14
 3011 0c10 DF90      		pop r13
 3012 0c12 CF90      		pop r12
 3013 0c14 0895      		ret
 3015               	.Lscope16:
 3017               		.stabd	78,0,0
 3018               		.section	.progmem.data,"a",@progbits
 3021               	__c.5452:
 3022 0000 626F 6F74 		.string	"bootloader nie rozpoczal odbioru danych\r\n"
 3022      6C6F 6164 
 3022      6572 206E 
 3022      6965 2072 
 3022      6F7A 706F 
 3025               	__c.5450:
 3026 002a 6E61 2075 		.string	"na urzadzeniu wgrany jest tylko bootloader\r\n"
 3026      727A 6164 
 3026      7A65 6E69 
 3026      7520 7767 
 3026      7261 6E79 
 3029               	__c.5448:
 3030 0057 7246 4C41 		.string	"rFLASH timeout\r\n"
 3030      5348 2074 
 3030      696D 656F 
 3030      7574 0D0A 
 3030      00
 3031               	.global	statusRollerDescStr2
 3034               	statusRollerDescStr2:
 3035 0068 2C20 6669 		.string	", firmware %s\r\n"
 3035      726D 7761 
 3035      7265 2025 
 3035      730D 0A00 
 3036               	.global	statusRollerDescStr
 3039               	statusRollerDescStr:
 3040 0078 2025 6420 		.string	" %d roller driver: roller 1 position %d, roller 2 position %d"
 3040      726F 6C6C 
 3040      6572 2064 
 3040      7269 7665 
 3040      723A 2072 
 3041               		.comm	rollers,2,1
 3042               		.comm	klastry,128,1
 3043               		.comm	czasRtc,7,1
 3044               		.comm	sockets,2,1
 3045               		.comm	tcpDebugLevel,1,1
 3046               		.comm	tcpDebugStream,2,1
 3047               		.comm	IpMyConfig,15,1
 3048               		.comm	udpDbgLevel,1,1
 3049               		.comm	udpDbgStream,2,1
 3050               		.comm	udpSocket,2,1
 3051               		.comm	icmpDebugLevel,1,1
 3052               		.comm	icmpDebug,2,1
 3053               		.comm	arpDebugLevel,1,1
 3054               		.comm	arpDebug,2,1
 3055               		.comm	plen,2,1
 3056               		.comm	nicState,14,1
 3057               		.comm	xSemaphoreRs485,2,1
 3058               		.comm	lockSensors,2,1
 3059               		.comm	portB,1,1
 3060               		.comm	portA,1,1
 3061               		.comm	xSemaphoreSpiSS,2,1
 3062               		.comm	wwwport,1,1
 3087               		.text
 3089               	.Letext0:
 3090               		.ident	"GCC: (GNU) 4.8.2"
 3091               	.global __do_copy_data
 3092               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Rs485_prot.c
     /tmp/ccApFHnE.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccApFHnE.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccApFHnE.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccApFHnE.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccApFHnE.s:6      *ABS*:000000000000003a __RAMPY__
     /tmp/ccApFHnE.s:7      *ABS*:0000000000000039 __RAMPX__
     /tmp/ccApFHnE.s:8      *ABS*:0000000000000038 __RAMPD__
     /tmp/ccApFHnE.s:9      *ABS*:0000000000000034 __CCP__
     /tmp/ccApFHnE.s:10     *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccApFHnE.s:11     *ABS*:0000000000000001 __zero_reg__
     /tmp/ccApFHnE.s:594    .text:0000000000000000 _crc_xmodem_update
     /tmp/ccApFHnE.s:645    .text:0000000000000034 takeRs485
     /tmp/ccApFHnE.s:664    .text:0000000000000036 releaseRs485
     /tmp/ccApFHnE.s:682    .text:0000000000000038 uartRs485SendByte
     /tmp/ccApFHnE.s:701    .text:000000000000003a rs485Receive
     /tmp/ccApFHnE.s:721    .text:000000000000003e flushRs485RecBuffer
     /tmp/ccApFHnE.s:743    .text:0000000000000042 sendSettings
     /tmp/ccApFHnE.s:844    .text:00000000000000c8 saveSettings
     /tmp/ccApFHnE.s:931    .text:0000000000000138 rollersMemInit
                            *COM*:0000000000000002 rollers
     /tmp/ccApFHnE.s:963    .text:0000000000000154 printRs485devices
     /tmp/ccApFHnE.s:3039   .progmem.data:0000000000000078 statusRollerDescStr
     /tmp/ccApFHnE.s:3034   .progmem.data:0000000000000068 statusRollerDescStr2
     /tmp/ccApFHnE.s:1091   .text:0000000000000200 rs485ping
     /tmp/ccApFHnE.s:1449   .text:00000000000003ca rs485rollerHello
     /tmp/ccApFHnE.s:1927   .text:0000000000000616 rs485xModemFlash
     /tmp/ccApFHnE.s:3029   .progmem.data:0000000000000057 __c.5448
     /tmp/ccApFHnE.s:3025   .progmem.data:000000000000002a __c.5450
     /tmp/ccApFHnE.s:3021   .progmem.data:0000000000000000 __c.5452
     /tmp/ccApFHnE.s:2696   .text:0000000000000a44 rs485curtainUp
     /tmp/ccApFHnE.s:2816   .text:0000000000000aea rs485Led
     /tmp/ccApFHnE.s:2912   .text:0000000000000b70 rs485curtainDown
                            *COM*:0000000000000080 klastry
                            *COM*:0000000000000007 czasRtc
                            *COM*:0000000000000002 sockets
                            *COM*:0000000000000001 tcpDebugLevel
                            *COM*:0000000000000002 tcpDebugStream
                            *COM*:000000000000000f IpMyConfig
                            *COM*:0000000000000001 udpDbgLevel
                            *COM*:0000000000000002 udpDbgStream
                            *COM*:0000000000000002 udpSocket
                            *COM*:0000000000000001 icmpDebugLevel
                            *COM*:0000000000000002 icmpDebug
                            *COM*:0000000000000001 arpDebugLevel
                            *COM*:0000000000000002 arpDebug
                            *COM*:0000000000000002 plen
                            *COM*:000000000000000e nicState
                            *COM*:0000000000000002 xSemaphoreRs485
                            *COM*:0000000000000002 lockSensors
                            *COM*:0000000000000001 portB
                            *COM*:0000000000000001 portA
                            *COM*:0000000000000002 xSemaphoreSpiSS
                            *COM*:0000000000000001 wwwport

UNDEFINED SYMBOLS
malloc
fprintf_P
xRs485Rec
xQueueGenericReceive
vTaskDelay
ramDyskCzytajBajtZPliku
fputc
fprintf
__do_copy_data
__do_clear_bss
