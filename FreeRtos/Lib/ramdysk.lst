   1               		.file	"ramdysk.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 275               	uaktualnijRozmiarPliku:
 276               		.stabd	46,0,0
   1:../../freeRtos/Lib/ramdysk.c **** #include "ramdysk.h"
   2:../../freeRtos/Lib/ramdysk.c **** #include <string.h>
   3:../../freeRtos/Lib/ramdysk.c **** 
   4:../../freeRtos/Lib/ramdysk.c **** #define systemTime() 0; //Dodać w pliku hardware.h funkcje do odczytu czasu systemowego
   5:../../freeRtos/Lib/ramdysk.c **** 
   6:../../freeRtos/Lib/ramdysk.c **** static uint8_t         znajdzWolnyKlaster(void);
   7:../../freeRtos/Lib/ramdysk.c **** static uint8_t         nastepnyKlaster(uint8_t nrKlastra);
   8:../../freeRtos/Lib/ramdysk.c **** static uint8_t         znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow);
   9:../../freeRtos/Lib/ramdysk.c **** #if ( USUNKLASTER == 1)
  10:../../freeRtos/Lib/ramdysk.c **** static uint8_t         usunKlaster(uint8_t nrKlastra);
  11:../../freeRtos/Lib/ramdysk.c **** #endif
  12:../../freeRtos/Lib/ramdysk.c **** static uint8_t         wObrebiePliku(struct ramPlikFd *fd);
  13:../../freeRtos/Lib/ramdysk.c **** static void            uaktualnijRozmiarPliku(struct ramPlikFd *fd);
  14:../../freeRtos/Lib/ramdysk.c **** static struct ramPlik* znajdzPlik(const char *nazwa);
  15:../../freeRtos/Lib/ramdysk.c **** static struct ramPlik* znajdzMiejsceNaWpis(void);
  16:../../freeRtos/Lib/ramdysk.c **** static void            czyscKlaster(uint8_t nrKlastra);
  17:../../freeRtos/Lib/ramdysk.c **** 
  18:../../freeRtos/Lib/ramdysk.c **** static void            czyscKlaster(uint8_t nrKlastra)
  19:../../freeRtos/Lib/ramdysk.c **** {
  20:../../freeRtos/Lib/ramdysk.c ****   uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  21:../../freeRtos/Lib/ramdysk.c ****   memset (tmpPtr, 0, 256);
  22:../../freeRtos/Lib/ramdysk.c **** }
  23:../../freeRtos/Lib/ramdysk.c **** 
  24:../../freeRtos/Lib/ramdysk.c **** static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
  25:../../freeRtos/Lib/ramdysk.c **** {
  26:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi > fd->IndHi)
  27:../../freeRtos/Lib/ramdysk.c ****     return 0;
  28:../../freeRtos/Lib/ramdysk.c ****   
  29:../../freeRtos/Lib/ramdysk.c ****   if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
  30:../../freeRtos/Lib/ramdysk.c ****     return 0;
  31:../../freeRtos/Lib/ramdysk.c **** 
  32:../../freeRtos/Lib/ramdysk.c ****   return 1;
  33:../../freeRtos/Lib/ramdysk.c **** }
  34:../../freeRtos/Lib/ramdysk.c **** 
  35:../../freeRtos/Lib/ramdysk.c **** static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
  36:../../freeRtos/Lib/ramdysk.c **** {
 278               	.LM0:
 279               	.LFBB1:
 280               	/* prologue: function */
 281               	/* frame size = 0 */
 282               	/* stack size = 0 */
 283               	.L__stack_usage = 0
 284 0000 FC01      		movw r30,r24
  37:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi == fd->IndHi)
 286               	.LM1:
 287 0002 A481      		ldd r26,Z+4
 288 0004 B581      		ldd r27,Z+5
 289 0006 1296      		adiw r26,2
 290 0008 9C91      		ld r25,X
 291 000a 1297      		sbiw r26,2
 292 000c 8381      		ldd r24,Z+3
 293 000e 9813      		cpse r25,r24
 294 0010 00C0      		rjmp .L2
  38:../../freeRtos/Lib/ramdysk.c ****   {
  39:../../freeRtos/Lib/ramdysk.c ****     if (fd->wpis->rozmiarLo < fd->IndLo)
 296               	.LM2:
 297 0012 8281      		ldd r24,Z+2
 298 0014 1196      		adiw r26,1
 299 0016 9C91      		ld r25,X
 300 0018 1197      		sbiw r26,1
 301 001a 9817      		cp r25,r24
 302 001c 00F4      		brsh .L2
  40:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = fd->IndLo;
 304               	.LM3:
 305 001e 1196      		adiw r26,1
 306 0020 8C93      		st X,r24
 307               	.L2:
  41:../../freeRtos/Lib/ramdysk.c ****   }
  42:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi < fd->IndHi)
 309               	.LM4:
 310 0022 A481      		ldd r26,Z+4
 311 0024 B581      		ldd r27,Z+5
 312 0026 1296      		adiw r26,2
 313 0028 9C91      		ld r25,X
 314 002a 1297      		sbiw r26,2
 315 002c 8381      		ldd r24,Z+3
 316 002e 9817      		cp r25,r24
 317 0030 00F4      		brsh .L1
  43:../../freeRtos/Lib/ramdysk.c ****   {
  44:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = fd->IndLo;    
 319               	.LM5:
 320 0032 8281      		ldd r24,Z+2
 321 0034 1196      		adiw r26,1
 322 0036 8C93      		st X,r24
  45:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarHi = fd->IndHi;    
 324               	.LM6:
 325 0038 A481      		ldd r26,Z+4
 326 003a B581      		ldd r27,Z+5
 327 003c 8381      		ldd r24,Z+3
 328 003e 1296      		adiw r26,2
 329 0040 8C93      		st X,r24
 330               	.L1:
 331 0042 0895      		ret
 333               	.Lscope1:
 335               		.stabd	78,0,0
 339               	nastepnyKlaster:
 340               		.stabd	46,0,0
  46:../../freeRtos/Lib/ramdysk.c ****   }
  47:../../freeRtos/Lib/ramdysk.c **** }
  48:../../freeRtos/Lib/ramdysk.c **** 
  49:../../freeRtos/Lib/ramdysk.c **** static uint8_t znajdzWolnyKlaster(void)
  50:../../freeRtos/Lib/ramdysk.c **** {
  51:../../freeRtos/Lib/ramdysk.c ****   uint8_t i;
  52:../../freeRtos/Lib/ramdysk.c ****   for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli m
  53:../../freeRtos/Lib/ramdysk.c ****   {                                        //Może być rozszerzony na inne klastry.
  54:../../freeRtos/Lib/ramdysk.c ****     if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
  55:../../freeRtos/Lib/ramdysk.c ****     {
  56:../../freeRtos/Lib/ramdysk.c ****       klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
  57:../../freeRtos/Lib/ramdysk.c ****       czyscKlaster(i);                     //Czyszczenie zawartości klastra.
  58:../../freeRtos/Lib/ramdysk.c ****       return i;
  59:../../freeRtos/Lib/ramdysk.c ****     }
  60:../../freeRtos/Lib/ramdysk.c ****   }
  61:../../freeRtos/Lib/ramdysk.c ****   return 0;
  62:../../freeRtos/Lib/ramdysk.c **** }
  63:../../freeRtos/Lib/ramdysk.c **** 
  64:../../freeRtos/Lib/ramdysk.c **** static uint8_t nastepnyKlaster(uint8_t nrKlastra)
  65:../../freeRtos/Lib/ramdysk.c **** {
 342               	.LM7:
 343               	.LFBB2:
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 346               	/* stack size = 0 */
 347               	.L__stack_usage = 0
 348 0044 982F      		mov r25,r24
  66:../../freeRtos/Lib/ramdysk.c ****   uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
 350               	.LM8:
 351 0046 E82F      		mov r30,r24
 352 0048 F0E0      		ldi r31,0
 353 004a E050      		subi r30,lo8(-(klastry))
 354 004c F040      		sbci r31,hi8(-(klastry))
 355 004e 8081      		ld r24,Z
  67:../../freeRtos/Lib/ramdysk.c ****   if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, 
 357               	.LM9:
 358 0050 8913      		cpse r24,r25
 359 0052 00C0      		rjmp .L6
 360 0054 A0E0      		ldi r26,lo8(klastry+1)
 361 0056 B0E0      		ldi r27,hi8(klastry+1)
 362 0058 81E0      		ldi r24,lo8(1)
 363               	.L7:
  68:../../freeRtos/Lib/ramdysk.c ****   {                                        //Należy znaleźć jakiś wolny klaster i go dodać do 
  69:../../freeRtos/Lib/ramdysk.c ****     for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 
  70:../../freeRtos/Lib/ramdysk.c ****     {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma woln
  71:../../freeRtos/Lib/ramdysk.c ****       if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, ż
 365               	.LM10:
 366 005a 9D91      		ld r25,X+
 367 005c 9111      		cpse r25,__zero_reg__
 368 005e 00C0      		rjmp .L8
 369               	.L10:
  72:../../freeRtos/Lib/ramdysk.c ****         break;                             //Wtedy można przerwać szukanie kolejnych klastrów dl
  73:../../freeRtos/Lib/ramdysk.c ****     }                                      //Taka implementacja z założenia powoduje defragmentac
  74:../../freeRtos/Lib/ramdysk.c ****     
  75:../../freeRtos/Lib/ramdysk.c ****     if (temp != 0)                         //Znaleziono jakiś wolny klaster
  76:../../freeRtos/Lib/ramdysk.c ****     {
  77:../../freeRtos/Lib/ramdysk.c ****       klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku ko
 371               	.LM11:
 372 0060 8083      		st Z,r24
  78:../../freeRtos/Lib/ramdysk.c ****       klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym 
 374               	.LM12:
 375 0062 282F      		mov r18,r24
 376 0064 30E0      		ldi r19,0
 377 0066 F901      		movw r30,r18
 378 0068 E050      		subi r30,lo8(-(klastry))
 379 006a F040      		sbci r31,hi8(-(klastry))
 380 006c 8083      		st Z,r24
 381               	.LBB4:
 382               	.LBB5:
  21:../../freeRtos/Lib/ramdysk.c ****   memset (tmpPtr, 0, 256);
 384               	.LM13:
 385 006e E0E0      		ldi r30,0
 386 0070 F0E8      		ldi r31,lo8(-128)
 387 0072 F80F      		add r31,r24
 388 0074 20E0      		ldi r18,0
 389 0076 31E0      		ldi r19,lo8(1)
 390 0078 DF01      		movw r26,r30
 391 007a A901      		movw r20,r18
 392               		0:
 393 007c 1D92      		st X+,__zero_reg__
 394 007e 4150      		subi r20,1
 395 0080 5040      		sbci r21,0
 396 0082 01F4      		brne 0b
 397 0084 0895      		ret
 398               	.L8:
 399               	.LBE5:
 400               	.LBE4:
  69:../../freeRtos/Lib/ramdysk.c ****     for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 
 402               	.LM14:
 403 0086 8F5F      		subi r24,lo8(-(1))
 404 0088 8038      		cpi r24,lo8(-128)
 405 008a 01F4      		brne .L7
 406 008c 00C0      		rjmp .L10
 407               	.L6:
  79:../../freeRtos/Lib/ramdysk.c ****       czyscKlaster(temp);                  //Czyszczenie klastra
  80:../../freeRtos/Lib/ramdysk.c ****     }
  81:../../freeRtos/Lib/ramdysk.c ****   }
  82:../../freeRtos/Lib/ramdysk.c ****   return temp;
  83:../../freeRtos/Lib/ramdysk.c **** }
 409               	.LM15:
 410 008e 0895      		ret
 415               	.Lscope2:
 417               		.stabd	78,0,0
 422               	znajdzKlasterN:
 423               		.stabd	46,0,0
  84:../../freeRtos/Lib/ramdysk.c **** 
  85:../../freeRtos/Lib/ramdysk.c **** static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
  86:../../freeRtos/Lib/ramdysk.c **** {
 425               	.LM16:
 426               	.LFBB3:
 427 0090 1F93      		push r17
 428 0092 CF93      		push r28
 429 0094 DF93      		push r29
 430 0096 1F92      		push __zero_reg__
 431 0098 CDB7      		in r28,__SP_L__
 432 009a DEB7      		in r29,__SP_H__
 433               	/* prologue: function */
 434               	/* frame size = 1 */
 435               	/* stack size = 4 */
 436               	.L__stack_usage = 4
  87:../../freeRtos/Lib/ramdysk.c ****   uint8_t ind;                             //PIerwszy klaster ma indeks 0
  88:../../freeRtos/Lib/ramdysk.c ****   uint8_t wynik = nrPierwszegoKlastra;
  89:../../freeRtos/Lib/ramdysk.c ****   for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klast
 438               	.LM17:
 439 009c 10E0      		ldi r17,0
 440               	.L12:
 442               	.LM18:
 443 009e 1617      		cp r17,r22
 444 00a0 01F0      		breq .L13
  90:../../freeRtos/Lib/ramdysk.c ****   {
  91:../../freeRtos/Lib/ramdysk.c ****     wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatyc
 446               	.LM19:
 447 00a2 6983      		std Y+1,r22
 448 00a4 0E94 0000 		call nastepnyKlaster
  92:../../freeRtos/Lib/ramdysk.c ****     if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
 450               	.LM20:
 451 00a8 6981      		ldd r22,Y+1
 452 00aa 8823      		tst r24
 453 00ac 01F0      		breq .L13
  89:../../freeRtos/Lib/ramdysk.c ****   for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klast
 455               	.LM21:
 456 00ae 1F5F      		subi r17,lo8(-(1))
 457 00b0 00C0      		rjmp .L12
 458               	.L13:
 459               	/* epilogue start */
  93:../../freeRtos/Lib/ramdysk.c ****       break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany n
  94:../../freeRtos/Lib/ramdysk.c ****   }
  95:../../freeRtos/Lib/ramdysk.c ****   return wynik;
  96:../../freeRtos/Lib/ramdysk.c **** }
 461               	.LM22:
 462 00b2 0F90      		pop __tmp_reg__
 463 00b4 DF91      		pop r29
 464 00b6 CF91      		pop r28
 465 00b8 1F91      		pop r17
 466 00ba 0895      		ret
 471               	.Lscope3:
 473               		.stabd	78,0,0
 477               	znajdzPlik:
 478               		.stabd	46,0,0
  97:../../freeRtos/Lib/ramdysk.c **** 
  98:../../freeRtos/Lib/ramdysk.c **** #if ( USUNKLASTER == 1)
  99:../../freeRtos/Lib/ramdysk.c **** static uint8_t usunKlaster(uint8_t nrKlastra)
 100:../../freeRtos/Lib/ramdysk.c **** {
 101:../../freeRtos/Lib/ramdysk.c ****   if (klastry[nrKlastra] == 0)
 102:../../freeRtos/Lib/ramdysk.c ****     return 1;                              //Klaster nie był zajęty                     
 103:../../freeRtos/Lib/ramdysk.c ****   uint8_t temp;
 104:../../freeRtos/Lib/ramdysk.c ****   for (temp = 0; temp <128; temp++)
 105:../../freeRtos/Lib/ramdysk.c ****     if (klastry[temp] == nrKlastra)        //Znaleziono klaster, który wskazuje na ten usuwany
 106:../../freeRtos/Lib/ramdysk.c ****     {
 107:../../freeRtos/Lib/ramdysk.c ****       if (klastry[nrKlastra] == nrKlastra) //Sprawdzanie, czy usuwany klaster nie jest ostatni.
 108:../../freeRtos/Lib/ramdysk.c **** 	klastry[temp] = temp;              //Jeśli tak, to klaster poprzedni musi być ustawiony jako kla
 109:../../freeRtos/Lib/ramdysk.c ****       else
 110:../../freeRtos/Lib/ramdysk.c **** 	klastry[temp] = klastry[nrKlastra];//Klaster poprzedni wskazuje na klaster następny za tym usuwan
 111:../../freeRtos/Lib/ramdysk.c ****     }
 112:../../freeRtos/Lib/ramdysk.c ****   klastry[nrKlastra] = 0;                  //Oznaczanie klastra jako pusty
 113:../../freeRtos/Lib/ramdysk.c ****   return 0;
 114:../../freeRtos/Lib/ramdysk.c **** }
 115:../../freeRtos/Lib/ramdysk.c **** #endif
 116:../../freeRtos/Lib/ramdysk.c **** 
 117:../../freeRtos/Lib/ramdysk.c **** static struct ramPlik* znajdzPlik(const char *nazwa)
 118:../../freeRtos/Lib/ramdysk.c **** {
 480               	.LM23:
 481               	.LFBB4:
 482 00bc 9F92      		push r9
 483 00be AF92      		push r10
 484 00c0 BF92      		push r11
 485 00c2 CF92      		push r12
 486 00c4 DF92      		push r13
 487 00c6 EF92      		push r14
 488 00c8 FF92      		push r15
 489 00ca 0F93      		push r16
 490 00cc 1F93      		push r17
 491 00ce CF93      		push r28
 492 00d0 DF93      		push r29
 493               	/* prologue: function */
 494               	/* frame size = 0 */
 495               	/* stack size = 11 */
 496               	.L__stack_usage = 11
 497 00d2 8C01      		movw r16,r24
 119:../../freeRtos/Lib/ramdysk.c ****   uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
 499               	.LM24:
 500 00d4 FC01      		movw r30,r24
 501               		0:
 502 00d6 0190      		ld __tmp_reg__,Z+
 503 00d8 0020      		tst __tmp_reg__
 504 00da 01F4      		brne 0b
 505 00dc 3197      		sbiw r30,1
 506 00de 8E2F      		mov r24,r30
 507 00e0 801B      		sub r24,r16
 508 00e2 8930      		cpi r24,lo8(9)
 509 00e4 00F0      		brlo .L19
 510 00e6 88E0      		ldi r24,lo8(8)
 511               	.L19:
 120:../../freeRtos/Lib/ramdysk.c ****   if (dlNazwy > 8)
 121:../../freeRtos/Lib/ramdysk.c ****     dlNazwy = 8;
 122:../../freeRtos/Lib/ramdysk.c ****   
 123:../../freeRtos/Lib/ramdysk.c ****   
 124:../../freeRtos/Lib/ramdysk.c ****   if (nazwa[dlNazwy-1] == 0)
 513               	.LM25:
 514 00e8 F801      		movw r30,r16
 515 00ea E80F      		add r30,r24
 516 00ec F11D      		adc r31,__zero_reg__
 517 00ee 3197      		sbiw r30,1
 518 00f0 9081      		ld r25,Z
 519 00f2 9111      		cpse r25,__zero_reg__
 520 00f4 00C0      		rjmp .L20
 125:../../freeRtos/Lib/ramdysk.c ****     dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
 522               	.LM26:
 523 00f6 8150      		subi r24,lo8(-(-1))
 524               	.L20:
 525 00f8 D801      		movw r26,r16
 526 00fa 1196      		adiw r26,1
 126:../../freeRtos/Lib/ramdysk.c ****   struct ramPlik *plik;
 127:../../freeRtos/Lib/ramdysk.c ****   uint8_t temp;
 128:../../freeRtos/Lib/ramdysk.c ****   uint8_t tempKlaster=0;
 129:../../freeRtos/Lib/ramdysk.c ****   uint8_t tempKlaster2;
 130:../../freeRtos/Lib/ramdysk.c **** 
 131:../../freeRtos/Lib/ramdysk.c ****   for (temp=1; temp < dlNazwy; temp ++)
 528               	.LM27:
 529 00fc 91E0      		ldi r25,lo8(1)
 530               	.L21:
 532               	.LM28:
 533 00fe 9817      		cp r25,r24
 534 0100 00F4      		brsh .L32
 132:../../freeRtos/Lib/ramdysk.c ****   {
 133:../../freeRtos/Lib/ramdysk.c ****     if (nazwa[temp] == ' ')               //Pozbycie sie spacji
 536               	.LM29:
 537 0102 2D91      		ld r18,X+
 538 0104 2032      		cpi r18,lo8(32)
 539 0106 01F0      		breq .L28
 131:../../freeRtos/Lib/ramdysk.c ****   for (temp=1; temp < dlNazwy; temp ++)
 541               	.LM30:
 542 0108 9F5F      		subi r25,lo8(-(1))
 543 010a 00C0      		rjmp .L21
 544               	.L32:
 134:../../freeRtos/Lib/ramdysk.c ****     {
 135:../../freeRtos/Lib/ramdysk.c ****       dlNazwy = temp;
 136:../../freeRtos/Lib/ramdysk.c ****       break; 
 137:../../freeRtos/Lib/ramdysk.c ****     }
 138:../../freeRtos/Lib/ramdysk.c ****   }
 139:../../freeRtos/Lib/ramdysk.c ****   if (dlNazwy == 0)
 546               	.LM31:
 547 010c 8111      		cpse r24,__zero_reg__
 548 010e 00C0      		rjmp .L22
 549 0110 00C0      		rjmp .L31
 550               	.L28:
 551 0112 892F      		mov r24,r25
 552               	.L22:
 553 0114 912C      		mov r9,__zero_reg__
 140:../../freeRtos/Lib/ramdysk.c ****     return NULL;
 141:../../freeRtos/Lib/ramdysk.c ****   
 142:../../freeRtos/Lib/ramdysk.c ****   do
 143:../../freeRtos/Lib/ramdysk.c ****   {
 144:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 145:../../freeRtos/Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 146:../../freeRtos/Lib/ramdysk.c ****     {
 147:../../freeRtos/Lib/ramdysk.c ****       if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
 555               	.LM32:
 556 0116 C82E      		mov r12,r24
 557 0118 D12C      		mov r13,__zero_reg__
 558               	.L27:
 144:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 560               	.LM33:
 561 011a E92C      		mov r14,r9
 562 011c F12C      		mov r15,__zero_reg__
 563 011e E701      		movw r28,r14
 564 0120 C058      		subi r28,-128
 565 0122 DF4F      		sbci r29,-1
 566 0124 DC2F      		mov r29,r28
 567 0126 CC27      		clr r28
 568 0128 5E01      		movw r10,r28
 569 012a B394      		inc r11
 570               	.L26:
 572               	.LM34:
 573 012c A601      		movw r20,r12
 574 012e BE01      		movw r22,r28
 575 0130 6C5F      		subi r22,-4
 576 0132 7F4F      		sbci r23,-1
 577 0134 C801      		movw r24,r16
 578 0136 0E94 0000 		call strncmp
 579 013a 892B      		or r24,r25
 580 013c 01F0      		breq .L30
 148:../../freeRtos/Lib/ramdysk.c **** 	return plik;
 149:../../freeRtos/Lib/ramdysk.c ****       plik++;                                            //Przejście do kolejnego wpisu (w tym sam
 582               	.LM35:
 583 013e 6096      		adiw r28,16
 145:../../freeRtos/Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 585               	.LM36:
 586 0140 CA15      		cp r28,r10
 587 0142 DB05      		cpc r29,r11
 588 0144 01F4      		brne .L26
 150:../../freeRtos/Lib/ramdysk.c ****     }   
 151:../../freeRtos/Lib/ramdysk.c ****     tempKlaster2 = tempKlaster;
 152:../../freeRtos/Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 590               	.LM37:
 591 0146 F701      		movw r30,r14
 592 0148 E050      		subi r30,lo8(-(klastry))
 593 014a F040      		sbci r31,hi8(-(klastry))
 594 014c 8081      		ld r24,Z
 153:../../freeRtos/Lib/ramdysk.c ****   }
 154:../../freeRtos/Lib/ramdysk.c ****   while (tempKlaster2 != tempKlaster);
 596               	.LM38:
 597 014e 9816      		cp r9,r24
 598 0150 01F0      		breq .L31
 152:../../freeRtos/Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 600               	.LM39:
 601 0152 982E      		mov r9,r24
 602 0154 00C0      		rjmp .L27
 603               	.L30:
 604 0156 CE01      		movw r24,r28
 605 0158 00C0      		rjmp .L24
 606               	.L31:
 140:../../freeRtos/Lib/ramdysk.c ****     return NULL;
 608               	.LM40:
 609 015a 80E0      		ldi r24,0
 610 015c 90E0      		ldi r25,0
 611               	.L24:
 612               	/* epilogue start */
 155:../../freeRtos/Lib/ramdysk.c ****   return NULL;
 156:../../freeRtos/Lib/ramdysk.c **** }
 614               	.LM41:
 615 015e DF91      		pop r29
 616 0160 CF91      		pop r28
 617 0162 1F91      		pop r17
 618 0164 0F91      		pop r16
 619 0166 FF90      		pop r15
 620 0168 EF90      		pop r14
 621 016a DF90      		pop r13
 622 016c CF90      		pop r12
 623 016e BF90      		pop r11
 624 0170 AF90      		pop r10
 625 0172 9F90      		pop r9
 626 0174 0895      		ret
 631               	.Lscope4:
 633               		.stabd	78,0,0
 636               	znajdzWolnyKlaster:
 637               		.stabd	46,0,0
  50:../../freeRtos/Lib/ramdysk.c **** {
 639               	.LM42:
 640               	.LFBB5:
 641               	/* prologue: function */
 642               	/* frame size = 0 */
 643               	/* stack size = 0 */
 644               	.L__stack_usage = 0
 645 0176 E0E0      		ldi r30,lo8(klastry+1)
 646 0178 F0E0      		ldi r31,hi8(klastry+1)
  52:../../freeRtos/Lib/ramdysk.c ****   for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli m
 648               	.LM43:
 649 017a 21E0      		ldi r18,lo8(1)
 650 017c 30E0      		ldi r19,0
 651               	.L34:
 652 017e 822F      		mov r24,r18
  52:../../freeRtos/Lib/ramdysk.c ****   for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli m
 654               	.LM44:
 655 0180 2038      		cpi r18,-128
 656 0182 3105      		cpc r19,__zero_reg__
 657 0184 01F0      		breq .L38
  54:../../freeRtos/Lib/ramdysk.c ****     if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
 659               	.LM45:
 660 0186 A901      		movw r20,r18
 661 0188 9191      		ld r25,Z+
 662 018a 2F5F      		subi r18,-1
 663 018c 3F4F      		sbci r19,-1
 664 018e 9111      		cpse r25,__zero_reg__
 665 0190 00C0      		rjmp .L34
  56:../../freeRtos/Lib/ramdysk.c ****       klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
 667               	.LM46:
 668 0192 FA01      		movw r30,r20
 669 0194 E050      		subi r30,lo8(-(klastry))
 670 0196 F040      		sbci r31,hi8(-(klastry))
 671 0198 8083      		st Z,r24
 672               	.LBB8:
 673               	.LBB9:
  21:../../freeRtos/Lib/ramdysk.c ****   memset (tmpPtr, 0, 256);
 675               	.LM47:
 676 019a E0E0      		ldi r30,0
 677 019c F0E8      		ldi r31,lo8(-128)
 678 019e F40F      		add r31,r20
 679 01a0 20E0      		ldi r18,0
 680 01a2 31E0      		ldi r19,lo8(1)
 681 01a4 DF01      		movw r26,r30
 682 01a6 A901      		movw r20,r18
 683               		0:
 684 01a8 1D92      		st X+,__zero_reg__
 685 01aa 4150      		subi r20,1
 686 01ac 5040      		sbci r21,0
 687 01ae 01F4      		brne 0b
 688 01b0 0895      		ret
 689               	.L38:
 690               	.LBE9:
 691               	.LBE8:
  61:../../freeRtos/Lib/ramdysk.c ****   return 0;
 693               	.LM48:
 694 01b2 80E0      		ldi r24,0
  62:../../freeRtos/Lib/ramdysk.c **** }
 696               	.LM49:
 697 01b4 0895      		ret
 699               	.Lscope5:
 701               		.stabd	78,0,0
 703               	.global	ramDyskInit
 705               	ramDyskInit:
 706               		.stabd	46,0,0
 157:../../freeRtos/Lib/ramdysk.c **** 
 158:../../freeRtos/Lib/ramdysk.c **** static struct ramPlik* znajdzMiejsceNaWpis(void)
 159:../../freeRtos/Lib/ramdysk.c **** {
 160:../../freeRtos/Lib/ramdysk.c ****   struct ramPlik *plik;
 161:../../freeRtos/Lib/ramdysk.c ****   uint8_t temp;
 162:../../freeRtos/Lib/ramdysk.c ****   uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogo
 163:../../freeRtos/Lib/ramdysk.c ****   uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogo
 164:../../freeRtos/Lib/ramdysk.c ****   do
 165:../../freeRtos/Lib/ramdysk.c ****   {
 166:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 167:../../freeRtos/Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 168:../../freeRtos/Lib/ramdysk.c ****     {
 169:../../freeRtos/Lib/ramdysk.c ****       if (plik->nazwa[0] == 0)
 170:../../freeRtos/Lib/ramdysk.c **** 	return plik;
 171:../../freeRtos/Lib/ramdysk.c ****       plik++;                                            //Przejście do kolejnego wpisu (w tym sam
 172:../../freeRtos/Lib/ramdysk.c ****     }   
 173:../../freeRtos/Lib/ramdysk.c ****     tempKlaster2 = tempKlaster;
 174:../../freeRtos/Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 175:../../freeRtos/Lib/ramdysk.c ****   }
 176:../../freeRtos/Lib/ramdysk.c ****   while (tempKlaster2 != tempKlaster);
 177:../../freeRtos/Lib/ramdysk.c ****   
 178:../../freeRtos/Lib/ramdysk.c ****   klastry[tempKlaster] = znajdzWolnyKlaster();
 179:../../freeRtos/Lib/ramdysk.c ****   plik = NULL;
 180:../../freeRtos/Lib/ramdysk.c ****   if (klastry[tempKlaster] != 0)
 181:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
 182:../../freeRtos/Lib/ramdysk.c **** 
 183:../../freeRtos/Lib/ramdysk.c ****   return plik;
 184:../../freeRtos/Lib/ramdysk.c **** }
 185:../../freeRtos/Lib/ramdysk.c **** 
 186:../../freeRtos/Lib/ramdysk.c **** 
 187:../../freeRtos/Lib/ramdysk.c **** void ramDyskInit(void)
 188:../../freeRtos/Lib/ramdysk.c **** {
 708               	.LM50:
 709               	.LFBB6:
 710               	/* prologue: function */
 711               	/* frame size = 0 */
 712               	/* stack size = 0 */
 713               	.L__stack_usage = 0
 189:../../freeRtos/Lib/ramdysk.c ****   memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
 715               	.LM51:
 716 01b6 80E8      		ldi r24,lo8(-128)
 717 01b8 E0E0      		ldi r30,lo8(klastry)
 718 01ba F0E0      		ldi r31,hi8(klastry)
 719 01bc DF01      		movw r26,r30
 720               		0:
 721 01be 1D92      		st X+,__zero_reg__
 722 01c0 8A95      		dec r24
 723 01c2 01F4      		brne 0b
 190:../../freeRtos/Lib/ramdysk.c ****   memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
 725               	.LM52:
 726 01c4 80E0      		ldi r24,0
 727 01c6 91E0      		ldi r25,lo8(1)
 728 01c8 E0E0      		ldi r30,0
 729 01ca F0E8      		ldi r31,lo8(-128)
 730 01cc DF01      		movw r26,r30
 731 01ce 9C01      		movw r18,r24
 732               		0:
 733 01d0 1D92      		st X+,__zero_reg__
 734 01d2 2150      		subi r18,1
 735 01d4 3040      		sbci r19,0
 736 01d6 01F4      		brne 0b
 737 01d8 0895      		ret
 739               	.Lscope6:
 741               		.stabd	78,0,0
 744               	.global	ramDyskUtworzPlik
 746               	ramDyskUtworzPlik:
 747               		.stabd	46,0,0
 191:../../freeRtos/Lib/ramdysk.c **** }
 192:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskUtworzPlik(const char *nazwa)
 193:../../freeRtos/Lib/ramdysk.c **** {                                        //Nowo utworzony plik nie zajmuje żadnego klastra
 749               	.LM53:
 750               	.LFBB7:
 751 01da FF92      		push r15
 752 01dc 0F93      		push r16
 753 01de 1F93      		push r17
 754 01e0 CF93      		push r28
 755 01e2 DF93      		push r29
 756               	/* prologue: function */
 757               	/* frame size = 0 */
 758               	/* stack size = 5 */
 759               	.L__stack_usage = 5
 760 01e4 8C01      		movw r16,r24
 194:../../freeRtos/Lib/ramdysk.c ****   uint8_t dlNazwy = strlen(nazwa);
 762               	.LM54:
 763 01e6 FC01      		movw r30,r24
 764               		0:
 765 01e8 0190      		ld __tmp_reg__,Z+
 766 01ea 0020      		tst __tmp_reg__
 767 01ec 01F4      		brne 0b
 768 01ee 3197      		sbiw r30,1
 769 01f0 FE2E      		mov r15,r30
 770 01f2 F81A      		sub r15,r24
 771 01f4 88E0      		ldi r24,lo8(8)
 772 01f6 8F15      		cp r24,r15
 773 01f8 00F4      		brsh .L41
 774 01fa 38E0      		ldi r19,lo8(8)
 775 01fc F32E      		mov r15,r19
 776               	.L41:
 777 01fe 902F      		mov r25,r16
 195:../../freeRtos/Lib/ramdysk.c ****   uint8_t i;
 196:../../freeRtos/Lib/ramdysk.c ****   if (dlNazwy > 8)
 197:../../freeRtos/Lib/ramdysk.c ****     dlNazwy = 8;
 198:../../freeRtos/Lib/ramdysk.c ****   
 199:../../freeRtos/Lib/ramdysk.c ****   for (i=0; i<dlNazwy; i++)
 779               	.LM55:
 780 0200 F801      		movw r30,r16
 781               	.L42:
 782 0202 8E2F      		mov r24,r30
 783 0204 891B      		sub r24,r25
 785               	.LM56:
 786 0206 8F15      		cp r24,r15
 787 0208 00F4      		brsh .L43
 200:../../freeRtos/Lib/ramdysk.c ****   {  if (nazwa[i] == ' ')
 789               	.LM57:
 790 020a 2191      		ld r18,Z+
 791 020c 2032      		cpi r18,lo8(32)
 792 020e 01F4      		brne .L42
 793 0210 F82E      		mov r15,r24
 794               	.L43:
 201:../../freeRtos/Lib/ramdysk.c ****      {
 202:../../freeRtos/Lib/ramdysk.c ****        dlNazwy = i;
 203:../../freeRtos/Lib/ramdysk.c ****        break;
 204:../../freeRtos/Lib/ramdysk.c ****      }
 205:../../freeRtos/Lib/ramdysk.c ****   }
 206:../../freeRtos/Lib/ramdysk.c ****   if (dlNazwy == 0)
 796               	.LM58:
 797 0212 FF20      		tst r15
 798 0214 01F0      		breq .L55
 207:../../freeRtos/Lib/ramdysk.c ****     return 0;
 208:../../freeRtos/Lib/ramdysk.c ****   
 209:../../freeRtos/Lib/ramdysk.c ****   struct ramPlik *plik;
 210:../../freeRtos/Lib/ramdysk.c ****   if ((plik = znajdzPlik(nazwa)) != NULL)
 800               	.LM59:
 801 0216 C801      		movw r24,r16
 802 0218 0E94 0000 		call znajdzPlik
 803 021c 892B      		or r24,r25
 804 021e 01F4      		brne .L55
 805 0220 40E0      		ldi r20,0
 806               	.L50:
 807               	.LBB12:
 808               	.LBB13:
 166:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w kla
 810               	.LM60:
 811 0222 842F      		mov r24,r20
 812 0224 90E0      		ldi r25,0
 813 0226 EC01      		movw r28,r24
 814 0228 C058      		subi r28,-128
 815 022a DF4F      		sbci r29,-1
 816 022c DC2F      		mov r29,r28
 817 022e CC27      		clr r28
 818 0230 9E01      		movw r18,r28
 819 0232 3395      		inc r19
 820               	.L48:
 169:../../freeRtos/Lib/ramdysk.c ****       if (plik->nazwa[0] == 0)
 822               	.LM61:
 823 0234 5C81      		ldd r21,Y+4
 824 0236 5523      		tst r21
 825 0238 01F0      		breq .L46
 171:../../freeRtos/Lib/ramdysk.c ****       plik++;                                            //Przejście do kolejnego wpisu (w tym sam
 827               	.LM62:
 828 023a 6096      		adiw r28,16
 167:../../freeRtos/Lib/ramdysk.c ****     for (temp=0; temp <16; temp++)
 830               	.LM63:
 831 023c C217      		cp r28,r18
 832 023e D307      		cpc r29,r19
 833 0240 01F4      		brne .L48
 174:../../freeRtos/Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 835               	.LM64:
 836 0242 EC01      		movw r28,r24
 837 0244 C050      		subi r28,lo8(-(klastry))
 838 0246 D040      		sbci r29,hi8(-(klastry))
 839 0248 8881      		ld r24,Y
 176:../../freeRtos/Lib/ramdysk.c ****   while (tempKlaster2 != tempKlaster);
 841               	.LM65:
 842 024a 4817      		cp r20,r24
 843 024c 01F0      		breq .L49
 174:../../freeRtos/Lib/ramdysk.c ****     tempKlaster = klastry[tempKlaster];
 845               	.LM66:
 846 024e 482F      		mov r20,r24
 847 0250 00C0      		rjmp .L50
 848               	.L49:
 178:../../freeRtos/Lib/ramdysk.c ****   klastry[tempKlaster] = znajdzWolnyKlaster();
 850               	.LM67:
 851 0252 0E94 0000 		call znajdzWolnyKlaster
 852 0256 8883      		st Y,r24
 180:../../freeRtos/Lib/ramdysk.c ****   if (klastry[tempKlaster] != 0)
 854               	.LM68:
 855 0258 8111      		cpse r24,__zero_reg__
 856 025a 00C0      		rjmp .L51
 857               	.L52:
 858               	.LBE13:
 859               	.LBE12:
 211:../../freeRtos/Lib/ramdysk.c ****   {
 212:../../freeRtos/Lib/ramdysk.c ****     return 0;
 213:../../freeRtos/Lib/ramdysk.c ****   }
 214:../../freeRtos/Lib/ramdysk.c ****   
 215:../../freeRtos/Lib/ramdysk.c ****   if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym p
 216:../../freeRtos/Lib/ramdysk.c ****   {
 217:../../freeRtos/Lib/ramdysk.c ****     memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo
 218:../../freeRtos/Lib/ramdysk.c ****     strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
 219:../../freeRtos/Lib/ramdysk.c ****     plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
 220:../../freeRtos/Lib/ramdysk.c ****     return 0;                            
 221:../../freeRtos/Lib/ramdysk.c ****   }
 222:../../freeRtos/Lib/ramdysk.c ****   return 1;
 861               	.LM69:
 862 025c 81E0      		ldi r24,lo8(1)
 863 025e 00C0      		rjmp .L45
 864               	.L51:
 865               	.LBB15:
 866               	.LBB14:
 181:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
 868               	.LM70:
 869 0260 90E0      		ldi r25,0
 870 0262 C92F      		mov r28,r25
 871 0264 D0E8      		ldi r29,lo8(-128)
 872 0266 D80F      		add r29,r24
 873               	.L46:
 874               	.LBE14:
 875               	.LBE15:
 215:../../freeRtos/Lib/ramdysk.c ****   if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym p
 877               	.LM71:
 878 0268 2097      		sbiw r28,0
 879 026a 01F0      		breq .L52
 217:../../freeRtos/Lib/ramdysk.c ****     memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo
 881               	.LM72:
 882 026c 8CE0      		ldi r24,lo8(12)
 883 026e FE01      		movw r30,r28
 884               		0:
 885 0270 1192      		st Z+,__zero_reg__
 886 0272 8A95      		dec r24
 887 0274 01F4      		brne 0b
 218:../../freeRtos/Lib/ramdysk.c ****     strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
 889               	.LM73:
 890 0276 4F2D      		mov r20,r15
 891 0278 50E0      		ldi r21,0
 892 027a B801      		movw r22,r16
 893 027c CE01      		movw r24,r28
 894 027e 0496      		adiw r24,4
 895 0280 0E94 0000 		call strncpy
 219:../../freeRtos/Lib/ramdysk.c ****     plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
 897               	.LM74:
 898 0284 1C86      		std Y+12,__zero_reg__
 899 0286 1D86      		std Y+13,__zero_reg__
 900 0288 1E86      		std Y+14,__zero_reg__
 901 028a 1F86      		std Y+15,__zero_reg__
 902               	.L55:
 207:../../freeRtos/Lib/ramdysk.c ****     return 0;
 904               	.LM75:
 905 028c 80E0      		ldi r24,0
 906               	.L45:
 907               	/* epilogue start */
 223:../../freeRtos/Lib/ramdysk.c **** }
 909               	.LM76:
 910 028e DF91      		pop r29
 911 0290 CF91      		pop r28
 912 0292 1F91      		pop r17
 913 0294 0F91      		pop r16
 914 0296 FF90      		pop r15
 915 0298 0895      		ret
 917               	.Lscope7:
 919               		.stabd	78,0,0
 923               	.global	ramDyskOtworzPlik
 925               	ramDyskOtworzPlik:
 926               		.stabd	46,0,0
 224:../../freeRtos/Lib/ramdysk.c **** 
 225:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
 226:../../freeRtos/Lib/ramdysk.c **** {
 928               	.LM77:
 929               	.LFBB8:
 930 029a CF93      		push r28
 931 029c DF93      		push r29
 932               	/* prologue: function */
 933               	/* frame size = 0 */
 934               	/* stack size = 2 */
 935               	.L__stack_usage = 2
 936 029e EB01      		movw r28,r22
 227:../../freeRtos/Lib/ramdysk.c ****   uint8_t wynik = 1;
 228:../../freeRtos/Lib/ramdysk.c ****   struct ramPlik *plik;
 229:../../freeRtos/Lib/ramdysk.c ****   if ((plik = znajdzPlik(nazwa)) != NULL)
 938               	.LM78:
 939 02a0 0E94 0000 		call znajdzPlik
 940 02a4 0097      		sbiw r24,0
 941 02a6 01F0      		breq .L62
 230:../../freeRtos/Lib/ramdysk.c ****   {
 231:../../freeRtos/Lib/ramdysk.c ****     memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
 943               	.LM79:
 944 02a8 1882      		st Y,__zero_reg__
 945 02aa 1982      		std Y+1,__zero_reg__
 946 02ac 1A82      		std Y+2,__zero_reg__
 232:../../freeRtos/Lib/ramdysk.c ****     fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika n
 948               	.LM80:
 949 02ae 9D83      		std Y+5,r25
 950 02b0 8C83      		std Y+4,r24
 233:../../freeRtos/Lib/ramdysk.c ****     plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
 952               	.LM81:
 953 02b2 FC01      		movw r30,r24
 954 02b4 2381      		ldd r18,Z+3
 955 02b6 2F5F      		subi r18,lo8(-(1))
 956 02b8 2383      		std Z+3,r18
 234:../../freeRtos/Lib/ramdysk.c ****     wynik = 0;
 958               	.LM82:
 959 02ba 80E0      		ldi r24,0
 960 02bc 00C0      		rjmp .L61
 961               	.L62:
 227:../../freeRtos/Lib/ramdysk.c ****   uint8_t wynik = 1;
 963               	.LM83:
 964 02be 81E0      		ldi r24,lo8(1)
 965               	.L61:
 966               	/* epilogue start */
 235:../../freeRtos/Lib/ramdysk.c ****   }
 236:../../freeRtos/Lib/ramdysk.c ****   return wynik;
 237:../../freeRtos/Lib/ramdysk.c **** }
 968               	.LM84:
 969 02c0 DF91      		pop r29
 970 02c2 CF91      		pop r28
 971 02c4 0895      		ret
 977               	.Lscope8:
 979               		.stabd	78,0,0
 982               	.global	ramDyskUsunPlik
 984               	ramDyskUsunPlik:
 985               		.stabd	46,0,0
 238:../../freeRtos/Lib/ramdysk.c **** 
 239:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskUsunPlik(const char *nazwa)
 240:../../freeRtos/Lib/ramdysk.c **** {
 987               	.LM85:
 988               	.LFBB9:
 989               	/* prologue: function */
 990               	/* frame size = 0 */
 991               	/* stack size = 0 */
 992               	.L__stack_usage = 0
 241:../../freeRtos/Lib/ramdysk.c ****   struct ramPlik *plik;
 242:../../freeRtos/Lib/ramdysk.c ****   if ((plik = znajdzPlik(nazwa)) == NULL)
 994               	.LM86:
 995 02c6 0E94 0000 		call znajdzPlik
 996 02ca FC01      		movw r30,r24
 997 02cc 0097      		sbiw r24,0
 998 02ce 01F0      		breq .L69
 243:../../freeRtos/Lib/ramdysk.c ****     return 1;                                              //Nie znaleziono pliku
 244:../../freeRtos/Lib/ramdysk.c ****   if (plik->lAktOtw != 0)
 1000               	.LM87:
 1001 02d0 8381      		ldd r24,Z+3
 1002 02d2 8111      		cpse r24,__zero_reg__
 1003 02d4 00C0      		rjmp .L70
 1004               	.L65:
 245:../../freeRtos/Lib/ramdysk.c ****     return 2;                                              //Plik jest otwarty
 246:../../freeRtos/Lib/ramdysk.c ****   
 247:../../freeRtos/Lib/ramdysk.c ****   uint8_t usuwanyKlaster;
 248:../../freeRtos/Lib/ramdysk.c ****   while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się oka
 1006               	.LM88:
 1007 02d6 8081      		ld r24,Z
 1008 02d8 8823      		tst r24
 1009 02da 01F0      		breq .L71
 249:../../freeRtos/Lib/ramdysk.c ****   {
 250:../../freeRtos/Lib/ramdysk.c ****     usuwanyKlaster = plik->pierwszyKlaster;
 251:../../freeRtos/Lib/ramdysk.c ****     if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatnieg
 1011               	.LM89:
 1012 02dc A82F      		mov r26,r24
 1013 02de B0E0      		ldi r27,0
 1014 02e0 A050      		subi r26,lo8(-(klastry))
 1015 02e2 B040      		sbci r27,hi8(-(klastry))
 1016 02e4 9C91      		ld r25,X
 1017 02e6 9813      		cpse r25,r24
 1018 02e8 00C0      		rjmp .L66
 252:../../freeRtos/Lib/ramdysk.c ****       plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pl
 1020               	.LM90:
 1021 02ea 1082      		st Z,__zero_reg__
 1022 02ec 00C0      		rjmp .L67
 1023               	.L66:
 253:../../freeRtos/Lib/ramdysk.c ****     else
 254:../../freeRtos/Lib/ramdysk.c ****       plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
 1025               	.LM91:
 1026 02ee 9083      		st Z,r25
 1027               	.L67:
 255:../../freeRtos/Lib/ramdysk.c ****     klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
 1029               	.LM92:
 1030 02f0 1C92      		st X,__zero_reg__
 1031 02f2 00C0      		rjmp .L65
 1032               	.L71:
 256:../../freeRtos/Lib/ramdysk.c ****   }
 257:../../freeRtos/Lib/ramdysk.c ****   
 258:../../freeRtos/Lib/ramdysk.c ****   memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. I
 1034               	.LM93:
 1035 02f4 80E1      		ldi r24,lo8(16)
 1036 02f6 DF01      		movw r26,r30
 1037               		0:
 1038 02f8 1D92      		st X+,__zero_reg__
 1039 02fa 8A95      		dec r24
 1040 02fc 01F4      		brne 0b
 259:../../freeRtos/Lib/ramdysk.c **** //relokacjaTablicyWpisow()
 260:../../freeRtos/Lib/ramdysk.c ****   return 0;
 1042               	.LM94:
 1043 02fe 80E0      		ldi r24,0
 1044 0300 0895      		ret
 1045               	.L69:
 243:../../freeRtos/Lib/ramdysk.c ****     return 1;                                              //Nie znaleziono pliku
 1047               	.LM95:
 1048 0302 81E0      		ldi r24,lo8(1)
 1049 0304 0895      		ret
 1050               	.L70:
 245:../../freeRtos/Lib/ramdysk.c ****     return 2;                                              //Plik jest otwarty
 1052               	.LM96:
 1053 0306 82E0      		ldi r24,lo8(2)
 261:../../freeRtos/Lib/ramdysk.c **** }
 1055               	.LM97:
 1056 0308 0895      		ret
 1061               	.Lscope9:
 1063               		.stabd	78,0,0
 1066               	.global	ramDyskZamknijPlik
 1068               	ramDyskZamknijPlik:
 1069               		.stabd	46,0,0
 262:../../freeRtos/Lib/ramdysk.c **** 
 263:../../freeRtos/Lib/ramdysk.c **** void ramDyskZamknijPlik(struct ramPlikFd *fd)
 264:../../freeRtos/Lib/ramdysk.c **** {
 1071               	.LM98:
 1072               	.LFBB10:
 1073               	/* prologue: function */
 1074               	/* frame size = 0 */
 1075               	/* stack size = 0 */
 1076               	.L__stack_usage = 0
 265:../../freeRtos/Lib/ramdysk.c ****   if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest 
 1078               	.LM99:
 1079 030a DC01      		movw r26,r24
 1080 030c 1496      		adiw r26,4
 1081 030e ED91      		ld r30,X+
 1082 0310 FC91      		ld r31,X
 1083 0312 1597      		sbiw r26,4+1
 1084 0314 2381      		ldd r18,Z+3
 1085 0316 2223      		tst r18
 1086 0318 01F0      		breq .L72
 266:../../freeRtos/Lib/ramdysk.c ****   {
 267:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
 1088               	.LM100:
 1089 031a 2150      		subi r18,lo8(-(-1))
 1090 031c 2383      		std Z+3,r18
 268:../../freeRtos/Lib/ramdysk.c ****     memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plik
 1092               	.LM101:
 1093 031e 26E0      		ldi r18,lo8(6)
 1094 0320 FC01      		movw r30,r24
 1095               		0:
 1096 0322 1192      		st Z+,__zero_reg__
 1097 0324 2A95      		dec r18
 1098 0326 01F4      		brne 0b
 1099               	.L72:
 1100 0328 0895      		ret
 1102               	.Lscope10:
 1104               		.stabd	78,0,0
 1107               	.global	ramDyskCzyscPlik
 1109               	ramDyskCzyscPlik:
 1110               		.stabd	46,0,0
 269:../../freeRtos/Lib/ramdysk.c ****   }
 270:../../freeRtos/Lib/ramdysk.c **** }
 271:../../freeRtos/Lib/ramdysk.c **** 
 272:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
 273:../../freeRtos/Lib/ramdysk.c **** {
 1112               	.LM102:
 1113               	.LFBB11:
 1114 032a CF93      		push r28
 1115 032c DF93      		push r29
 1116               	/* prologue: function */
 1117               	/* frame size = 0 */
 1118               	/* stack size = 2 */
 1119               	.L__stack_usage = 2
 1120 032e FC01      		movw r30,r24
 1121               	.L78:
 274:../../freeRtos/Lib/ramdysk.c ****   uint8_t usuwanyKlaster;
 275:../../freeRtos/Lib/ramdysk.c ****   while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się
 1123               	.LM103:
 1124 0330 A481      		ldd r26,Z+4
 1125 0332 B581      		ldd r27,Z+5
 1126 0334 8C91      		ld r24,X
 1127 0336 8823      		tst r24
 1128 0338 01F0      		breq .L82
 276:../../freeRtos/Lib/ramdysk.c ****   {
 277:../../freeRtos/Lib/ramdysk.c ****     usuwanyKlaster = fd->wpis->pierwszyKlaster;
 278:../../freeRtos/Lib/ramdysk.c ****     if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostat
 1130               	.LM104:
 1131 033a C82F      		mov r28,r24
 1132 033c D0E0      		ldi r29,0
 1133 033e C050      		subi r28,lo8(-(klastry))
 1134 0340 D040      		sbci r29,hi8(-(klastry))
 1135 0342 9881      		ld r25,Y
 1136 0344 9813      		cpse r25,r24
 1137 0346 00C0      		rjmp .L79
 279:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwani
 1139               	.LM105:
 1140 0348 1C92      		st X,__zero_reg__
 1141 034a 00C0      		rjmp .L80
 1142               	.L79:
 280:../../freeRtos/Lib/ramdysk.c ****     else
 281:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
 1144               	.LM106:
 1145 034c 9C93      		st X,r25
 1146               	.L80:
 282:../../freeRtos/Lib/ramdysk.c ****     klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
 1148               	.LM107:
 1149 034e 1882      		st Y,__zero_reg__
 1150 0350 00C0      		rjmp .L78
 1151               	.L82:
 283:../../freeRtos/Lib/ramdysk.c ****   }
 284:../../freeRtos/Lib/ramdysk.c ****   fd->wpis->rozmiarLo       = 0;
 1153               	.LM108:
 1154 0352 1196      		adiw r26,1
 1155 0354 1C92      		st X,__zero_reg__
 285:../../freeRtos/Lib/ramdysk.c ****   fd->wpis->rozmiarHi       = 0;
 1157               	.LM109:
 1158 0356 A481      		ldd r26,Z+4
 1159 0358 B581      		ldd r27,Z+5
 1160 035a 1296      		adiw r26,2
 1161 035c 1C92      		st X,__zero_reg__
 286:../../freeRtos/Lib/ramdysk.c ****   fd->wpis->dataMod         = systemTime();
 1163               	.LM110:
 1164 035e A481      		ldd r26,Z+4
 1165 0360 B581      		ldd r27,Z+5
 1166 0362 1C96      		adiw r26,12
 1167 0364 1D92      		st X+,__zero_reg__
 1168 0366 1D92      		st X+,__zero_reg__
 1169 0368 1D92      		st X+,__zero_reg__
 1170 036a 1C92      		st X,__zero_reg__
 1171 036c 1F97      		sbiw r26,12+3
 287:../../freeRtos/Lib/ramdysk.c ****   memset (fd, 0, 4);
 1173               	.LM111:
 1174 036e 1082      		st Z,__zero_reg__
 1175 0370 1182      		std Z+1,__zero_reg__
 1176 0372 1282      		std Z+2,__zero_reg__
 1177 0374 1382      		std Z+3,__zero_reg__
 1178               	/* epilogue start */
 288:../../freeRtos/Lib/ramdysk.c ****   return 0;
 289:../../freeRtos/Lib/ramdysk.c **** }
 1180               	.LM112:
 1181 0376 DF91      		pop r29
 1182 0378 CF91      		pop r28
 1183 037a 0895      		ret
 1185               	.Lscope11:
 1187               		.stabd	78,0,0
 1191               	.global	ramDyskZapiszBajtDoPliku
 1193               	ramDyskZapiszBajtDoPliku:
 1194               		.stabd	46,0,0
 290:../../freeRtos/Lib/ramdysk.c **** 
 291:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
 292:../../freeRtos/Lib/ramdysk.c **** {
 1196               	.LM113:
 1197               	.LFBB12:
 1198 037c 1F93      		push r17
 1199 037e CF93      		push r28
 1200 0380 DF93      		push r29
 1201               	/* prologue: function */
 1202               	/* frame size = 0 */
 1203               	/* stack size = 3 */
 1204               	.L__stack_usage = 3
 1205 0382 EC01      		movw r28,r24
 1206 0384 162F      		mov r17,r22
 293:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster;
 294:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 1208               	.LM114:
 1209 0386 EC81      		ldd r30,Y+4
 1210 0388 FD81      		ldd r31,Y+5
 1211 038a 8081      		ld r24,Z
 1212 038c 8111      		cpse r24,__zero_reg__
 1213 038e 00C0      		rjmp .L84
 295:../../freeRtos/Lib/ramdysk.c ****   {
 296:../../freeRtos/Lib/ramdysk.c ****     if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
 1215               	.LM115:
 1216 0390 0E94 0000 		call znajdzWolnyKlaster
 1217 0394 8823      		tst r24
 1218 0396 01F0      		breq .L89
 297:../../freeRtos/Lib/ramdysk.c ****       return 1;                                         //Nie można było przydzielić pierwszego 
 298:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = tmpKlaster;
 1220               	.LM116:
 1221 0398 EC81      		ldd r30,Y+4
 1222 039a FD81      		ldd r31,Y+5
 1223 039c 8083      		st Z,r24
 1224               	.L84:
 299:../../freeRtos/Lib/ramdysk.c ****   }
 300:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)
 1226               	.LM117:
 1227 039e 8A81      		ldd r24,Y+2
 1228 03a0 8111      		cpse r24,__zero_reg__
 1229 03a2 00C0      		rjmp .L86
 301:../../freeRtos/Lib/ramdysk.c ****   {
 302:../../freeRtos/Lib/ramdysk.c ****     tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie nas
 1231               	.LM118:
 1232 03a4 EC81      		ldd r30,Y+4
 1233 03a6 FD81      		ldd r31,Y+5
 1234 03a8 6B81      		ldd r22,Y+3
 1235 03aa 8081      		ld r24,Z
 1236 03ac 0E94 0000 		call znajdzKlasterN
 303:../../freeRtos/Lib/ramdysk.c ****     if (tmpKlaster == 0)
 1238               	.LM119:
 1239 03b0 8823      		tst r24
 1240 03b2 01F0      		breq .L90
 304:../../freeRtos/Lib/ramdysk.c ****     {
 305:../../freeRtos/Lib/ramdysk.c ****       return 2;                                       //Nie można było przydzielić kolejnego kla
 306:../../freeRtos/Lib/ramdysk.c ****     }
 307:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego k
 1242               	.LM120:
 1243 03b4 90E0      		ldi r25,0
 1244 03b6 8058      		subi r24,-128
 1245 03b8 9F4F      		sbci r25,-1
 1246 03ba 1882      		st Y,__zero_reg__
 1247 03bc 8983      		std Y+1,r24
 1248               	.L86:
 308:../../freeRtos/Lib/ramdysk.c ****   }
 309:../../freeRtos/Lib/ramdysk.c ****   
 310:../../freeRtos/Lib/ramdysk.c ****   *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
 1250               	.LM121:
 1251 03be E881      		ld r30,Y
 1252 03c0 F981      		ldd r31,Y+1
 1253 03c2 1083      		st Z,r17
 311:../../freeRtos/Lib/ramdysk.c **** 
 312:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
 1255               	.LM122:
 1256 03c4 8A81      		ldd r24,Y+2
 1257 03c6 8F5F      		subi r24,lo8(-(1))
 1258 03c8 8A83      		std Y+2,r24
 313:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, ż
 1260               	.LM123:
 1261 03ca 8111      		cpse r24,__zero_reg__
 1262 03cc 00C0      		rjmp .L87
 314:../../freeRtos/Lib/ramdysk.c ****     fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt
 1264               	.LM124:
 1265 03ce 8B81      		ldd r24,Y+3
 1266 03d0 8F5F      		subi r24,lo8(-(1))
 1267 03d2 8B83      		std Y+3,r24
 1268 03d4 00C0      		rjmp .L88
 1269               	.L87:
 315:../../freeRtos/Lib/ramdysk.c ****   else                                                //Wziąż działamy na tym samym klastrze.
 316:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk++;                                        //Można uaktualnić wskaźnik
 1271               	.LM125:
 1272 03d6 8881      		ld r24,Y
 1273 03d8 9981      		ldd r25,Y+1
 1274 03da 0196      		adiw r24,1
 1275 03dc 9983      		std Y+1,r25
 1276 03de 8883      		st Y,r24
 1277               	.L88:
 317:../../freeRtos/Lib/ramdysk.c ****     
 318:../../freeRtos/Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
 1279               	.LM126:
 1280 03e0 CE01      		movw r24,r28
 1281 03e2 0E94 0000 		call uaktualnijRozmiarPliku
 319:../../freeRtos/Lib/ramdysk.c ****   return 0;
 1283               	.LM127:
 1284 03e6 80E0      		ldi r24,0
 1285 03e8 00C0      		rjmp .L85
 1286               	.L89:
 297:../../freeRtos/Lib/ramdysk.c ****       return 1;                                         //Nie można było przydzielić pierwszego 
 1288               	.LM128:
 1289 03ea 81E0      		ldi r24,lo8(1)
 1290 03ec 00C0      		rjmp .L85
 1291               	.L90:
 305:../../freeRtos/Lib/ramdysk.c ****       return 2;                                       //Nie można było przydzielić kolejnego kla
 1293               	.LM129:
 1294 03ee 82E0      		ldi r24,lo8(2)
 1295               	.L85:
 1296               	/* epilogue start */
 320:../../freeRtos/Lib/ramdysk.c **** }
 1298               	.LM130:
 1299 03f0 DF91      		pop r29
 1300 03f2 CF91      		pop r28
 1301 03f4 1F91      		pop r17
 1302 03f6 0895      		ret
 1304               	.Lscope12:
 1306               		.stabd	78,0,0
 1311               	putSTD:
 1312               		.stabd	46,0,0
 321:../../freeRtos/Lib/ramdysk.c **** 
 322:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
 323:../../freeRtos/Lib/ramdysk.c **** {
 324:../../freeRtos/Lib/ramdysk.c ****   if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
 325:../../freeRtos/Lib/ramdysk.c ****     return 1;                                         //1 - eof
 326:../../freeRtos/Lib/ramdysk.c **** 
 327:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku now
 328:../../freeRtos/Lib/ramdysk.c ****   {
 329:../../freeRtos/Lib/ramdysk.c ****     uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
 330:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego k
 331:../../freeRtos/Lib/ramdysk.c ****   }
 332:../../freeRtos/Lib/ramdysk.c ****   
 333:../../freeRtos/Lib/ramdysk.c ****   *bajt = *(fd->Wsk);                                 //Odczyt z pliku
 334:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo++;                                        //Zwiększenie indeksu o 1
 335:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klas
 336:../../freeRtos/Lib/ramdysk.c ****     fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół wzgl
 337:../../freeRtos/Lib/ramdysk.c ****   else                                                //Działamy na tym samym klastrze
 338:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
 339:../../freeRtos/Lib/ramdysk.c ****   return 0;
 340:../../freeRtos/Lib/ramdysk.c **** }
 341:../../freeRtos/Lib/ramdysk.c **** 
 342:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
 343:../../freeRtos/Lib/ramdysk.c **** {
 344:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 345:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 346:../../freeRtos/Lib/ramdysk.c ****   
 347:../../freeRtos/Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisa
 348:../../freeRtos/Lib/ramdysk.c ****   uint16_t doZapisu = *dlugosc;
 349:../../freeRtos/Lib/ramdysk.c ****   *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
 350:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 351:../../freeRtos/Lib/ramdysk.c ****   while (doZapisu > 0)
 352:../../freeRtos/Lib/ramdysk.c ****   {
 353:../../freeRtos/Lib/ramdysk.c ****     if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to
 354:../../freeRtos/Lib/ramdysk.c ****     {
 355:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze
 356:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra 
 357:../../freeRtos/Lib/ramdysk.c ****       else                                        //Znamy poprzedni klaster
 358:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
 359:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
 360:../../freeRtos/Lib/ramdysk.c ****         return 1;                                 //1 - Brak wolnego klastra
 361:../../freeRtos/Lib/ramdysk.c **** 
 362:../../freeRtos/Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Ter
 363:../../freeRtos/Lib/ramdysk.c ****     }
 364:../../freeRtos/Lib/ramdysk.c ****     if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w b
 365:../../freeRtos/Lib/ramdysk.c ****     {                                             //Nie uda się, teraz zapiszemy cały klastr do k
 366:../../freeRtos/Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
 367:../../freeRtos/Lib/ramdysk.c ****       znaki +=dlBloku;                      
 368:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na począ
 369:../../freeRtos/Lib/ramdysk.c ****       doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka
 370:../../freeRtos/Lib/ramdysk.c ****       *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych d
 371:../../freeRtos/Lib/ramdysk.c ****       fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. 
 372:../../freeRtos/Lib/ramdysk.c ****       dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 
 373:../../freeRtos/Lib/ramdysk.c ****     }
 374:../../freeRtos/Lib/ramdysk.c ****     else                                          //Jest to ostatni zapis. Całe dane zostaną skop
 375:../../freeRtos/Lib/ramdysk.c ****     {
 376:../../freeRtos/Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
 377:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mn
 378:../../freeRtos/Lib/ramdysk.c ****       *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych d
 379:../../freeRtos/Lib/ramdysk.c ****       doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
 380:../../freeRtos/Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce kla
 381:../../freeRtos/Lib/ramdysk.c ****     }
 382:../../freeRtos/Lib/ramdysk.c ****   }
 383:../../freeRtos/Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
 384:../../freeRtos/Lib/ramdysk.c ****   return 0;
 385:../../freeRtos/Lib/ramdysk.c **** }
 386:../../freeRtos/Lib/ramdysk.c **** 
 387:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
 388:../../freeRtos/Lib/ramdysk.c **** {
 389:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 390:../../freeRtos/Lib/ramdysk.c ****   {
 391:../../freeRtos/Lib/ramdysk.c ****     *dlugosc = 0;
 392:../../freeRtos/Lib/ramdysk.c ****     return 1;                         //1 - Plik jest pusty
 393:../../freeRtos/Lib/ramdysk.c ****   }
 394:../../freeRtos/Lib/ramdysk.c ****   if (wObrebiePliku(fd) != 0)
 395:../../freeRtos/Lib/ramdysk.c ****   {
 396:../../freeRtos/Lib/ramdysk.c ****     *dlugosc = 0;
 397:../../freeRtos/Lib/ramdysk.c ****     return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pli
 398:../../freeRtos/Lib/ramdysk.c ****   }
 399:../../freeRtos/Lib/ramdysk.c ****   
 400:../../freeRtos/Lib/ramdysk.c ****   uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
 401:../../freeRtos/Lib/ramdysk.c ****   lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze z
 402:../../freeRtos/Lib/ramdysk.c ****   lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zaws
 403:../../freeRtos/Lib/ramdysk.c ****   
 404:../../freeRtos/Lib/ramdysk.c ****   uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i
 405:../../freeRtos/Lib/ramdysk.c ****     lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczyta
 406:../../freeRtos/Lib/ramdysk.c ****     *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
 407:../../freeRtos/Lib/ramdysk.c ****   *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
 408:../../freeRtos/Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktua
 409:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 410:../../freeRtos/Lib/ramdysk.c ****   while (doOdczytania > 0)
 411:../../freeRtos/Lib/ramdysk.c ****   {
 412:../../freeRtos/Lib/ramdysk.c ****     if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, 
 413:../../freeRtos/Lib/ramdysk.c ****     {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (
 414:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster == 0)
 415:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
 416:../../freeRtos/Lib/ramdysk.c ****       else
 417:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster);
 418:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
 419:../../freeRtos/Lib/ramdysk.c ****         fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
 420:../../freeRtos/Lib/ramdysk.c ****       else
 421:../../freeRtos/Lib/ramdysk.c ****         return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
 422:../../freeRtos/Lib/ramdysk.c ****     }
 423:../../freeRtos/Lib/ramdysk.c ****     
 424:../../freeRtos/Lib/ramdysk.c ****     if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
 425:../../freeRtos/Lib/ramdysk.c ****     {                                  //dlBloku określa ile zostało jeszcze bajtów do końca kl
 426:../../freeRtos/Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
 427:../../freeRtos/Lib/ramdysk.c ****       znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy 
 428:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
 429:../../freeRtos/Lib/ramdysk.c ****       fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz ni
 430:../../freeRtos/Lib/ramdysk.c ****       doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
 431:../../freeRtos/Lib/ramdysk.c ****       *dlugosc += dlBloku;             //Uaktualnienie 
 432:../../freeRtos/Lib/ramdysk.c ****       dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całeg
 433:../../freeRtos/Lib/ramdysk.c ****     }
 434:../../freeRtos/Lib/ramdysk.c ****     else                               //Ostatnia operacja odczytu
 435:../../freeRtos/Lib/ramdysk.c ****     {
 436:../../freeRtos/Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, doOdczytania);
 437:../../freeRtos/Lib/ramdysk.c ****       fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym sam
 438:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zat
 439:../../freeRtos/Lib/ramdysk.c ****       *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                  
 440:../../freeRtos/Lib/ramdysk.c ****       doOdczytania = 0;                //Tutaj równie dobrze może być brake
 441:../../freeRtos/Lib/ramdysk.c ****     }
 442:../../freeRtos/Lib/ramdysk.c ****   }
 443:../../freeRtos/Lib/ramdysk.c ****   return 0;
 444:../../freeRtos/Lib/ramdysk.c **** }
 445:../../freeRtos/Lib/ramdysk.c **** 
 446:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
 447:../../freeRtos/Lib/ramdysk.c **** {
 448:../../freeRtos/Lib/ramdysk.c ****   if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje
 449:../../freeRtos/Lib/ramdysk.c ****   {                                                       //Jeśli tak, to nie ma potzeby tworzenia
 450:../../freeRtos/Lib/ramdysk.c ****     fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bard
 451:../../freeRtos/Lib/ramdysk.c ****     fd->IndHi = 0;
 452:../../freeRtos/Lib/ramdysk.c ****     return 0;
 453:../../freeRtos/Lib/ramdysk.c ****   }
 454:../../freeRtos/Lib/ramdysk.c ****   indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio 
 455:../../freeRtos/Lib/ramdysk.c ****                                                           //Jeśli indeks jest większy niż rozmia
 456:../../freeRtos/Lib/ramdysk.c ****   
 457:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydziel
 458:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pl
 459:../../freeRtos/Lib/ramdysk.c **** 
 460:../../freeRtos/Lib/ramdysk.c ****   uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką nale
 461:../../freeRtos/Lib/ramdysk.c **** 
 462:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mn
 463:../../freeRtos/Lib/ramdysk.c ****   fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu
 464:../../freeRtos/Lib/ramdysk.c ****   
 465:../../freeRtos/Lib/ramdysk.c ****   uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
 466:../../freeRtos/Lib/ramdysk.c ****   if (nrKlastra == 0)
 467:../../freeRtos/Lib/ramdysk.c ****     return 1;                                             //Brak klastrów
 468:../../freeRtos/Lib/ramdysk.c **** 
 469:../../freeRtos/Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
 470:../../freeRtos/Lib/ramdysk.c **** 
 471:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
 472:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, 
 473:../../freeRtos/Lib/ramdysk.c ****     fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący b
 474:../../freeRtos/Lib/ramdysk.c ****   else                                                    //Jesteśmy w obszarze utworzonego klastr
 475:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejs
 476:../../freeRtos/Lib/ramdysk.c **** 
 477:../../freeRtos/Lib/ramdysk.c ****   return 0; 
 478:../../freeRtos/Lib/ramdysk.c **** }
 479:../../freeRtos/Lib/ramdysk.c **** 
 480:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
 481:../../freeRtos/Lib/ramdysk.c **** {
 482:../../freeRtos/Lib/ramdysk.c ****   if (fd == NULL)
 483:../../freeRtos/Lib/ramdysk.c ****     return 1;
 484:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo = fd->wpis->rozmiarLo;
 485:../../freeRtos/Lib/ramdysk.c ****   fd->IndHi = fd->wpis->rozmiarHi;
 486:../../freeRtos/Lib/ramdysk.c **** //  fd->IndLo++;
 487:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 488:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo != 0)
 489:../../freeRtos/Lib/ramdysk.c ****   {
 490:../../freeRtos/Lib/ramdysk.c ****     tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
 491:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
 492:../../freeRtos/Lib/ramdysk.c ****   }  
 493:../../freeRtos/Lib/ramdysk.c ****   return 0;
 494:../../freeRtos/Lib/ramdysk.c **** }
 495:../../freeRtos/Lib/ramdysk.c **** 
 496:../../freeRtos/Lib/ramdysk.c **** uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
 497:../../freeRtos/Lib/ramdysk.c **** {
 498:../../freeRtos/Lib/ramdysk.c ****   if (nrBloku == 0)
 499:../../freeRtos/Lib/ramdysk.c ****     return NULL;
 500:../../freeRtos/Lib/ramdysk.c ****   nrBloku --;
 501:../../freeRtos/Lib/ramdysk.c ****   
 502:../../freeRtos/Lib/ramdysk.c ****   uint8_t indHi = (uint8_t)(nrBloku / 2);
 503:../../freeRtos/Lib/ramdysk.c ****   uint8_t indLo = 0;
 504:../../freeRtos/Lib/ramdysk.c ****   uint8_t *wynik;
 505:../../freeRtos/Lib/ramdysk.c ****   
 506:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 507:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 508:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 509:../../freeRtos/Lib/ramdysk.c ****     return NULL;
 510:../../freeRtos/Lib/ramdysk.c ****   
 511:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
 512:../../freeRtos/Lib/ramdysk.c ****   if (tmpKlaster == 0)
 513:../../freeRtos/Lib/ramdysk.c ****     return NULL;
 514:../../freeRtos/Lib/ramdysk.c ****   if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
 515:../../freeRtos/Lib/ramdysk.c ****   {
 516:../../freeRtos/Lib/ramdysk.c ****     indLo = 128;
 517:../../freeRtos/Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi <= indHi)
 518:../../freeRtos/Lib/ramdysk.c ****     {
 519:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi+1;
 520:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 0;
 521:../../freeRtos/Lib/ramdysk.c ****     }
 522:../../freeRtos/Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 128);
 523:../../freeRtos/Lib/ramdysk.c ****   }
 524:../../freeRtos/Lib/ramdysk.c ****   else
 525:../../freeRtos/Lib/ramdysk.c ****   {
 526:../../freeRtos/Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi < indHi)
 527:../../freeRtos/Lib/ramdysk.c ****     {
 528:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi;
 529:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 530:../../freeRtos/Lib/ramdysk.c ****     }
 531:../../freeRtos/Lib/ramdysk.c ****     else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
 532:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 533:../../freeRtos/Lib/ramdysk.c ****     
 534:../../freeRtos/Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 0);
 535:../../freeRtos/Lib/ramdysk.c ****   }
 536:../../freeRtos/Lib/ramdysk.c ****   return wynik;
 537:../../freeRtos/Lib/ramdysk.c **** }
 538:../../freeRtos/Lib/ramdysk.c **** 
 539:../../freeRtos/Lib/ramdysk.c **** void ramDyskDir(FILE *ostream)
 540:../../freeRtos/Lib/ramdysk.c **** {
 541:../../freeRtos/Lib/ramdysk.c ****   fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
 542:../../freeRtos/Lib/ramdysk.c ****   struct ramPlik *plik;
 543:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 544:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster2;
 545:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmp, tmp2, tmp3;
 546:../../freeRtos/Lib/ramdysk.c ****   do 
 547:../../freeRtos/Lib/ramdysk.c ****   {
 548:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
 549:../../freeRtos/Lib/ramdysk.c ****     for (tmp=0; tmp<16; tmp++)
 550:../../freeRtos/Lib/ramdysk.c ****     {
 551:../../freeRtos/Lib/ramdysk.c ****       tmp3=plik->nazwa[0];
 552:../../freeRtos/Lib/ramdysk.c ****       if (tmp3 == 0)
 553:../../freeRtos/Lib/ramdysk.c ****         break;                                            //Ten wpis jest pusty.
 554:../../freeRtos/Lib/ramdysk.c ****       fputc(tmp3         , ostream);
 555:../../freeRtos/Lib/ramdysk.c ****       for (tmp2=1; tmp2<8; tmp2++)
 556:../../freeRtos/Lib/ramdysk.c ****       {
 557:../../freeRtos/Lib/ramdysk.c ****         if (tmp3 != 0)
 558:../../freeRtos/Lib/ramdysk.c ****           tmp3=plik->nazwa[tmp2];
 559:../../freeRtos/Lib/ramdysk.c **** 
 560:../../freeRtos/Lib/ramdysk.c ****         if (tmp3 != 0)
 561:../../freeRtos/Lib/ramdysk.c ****           fputc(tmp3     , ostream);
 562:../../freeRtos/Lib/ramdysk.c ****         else
 563:../../freeRtos/Lib/ramdysk.c ****           fputc(' '      , ostream);
 564:../../freeRtos/Lib/ramdysk.c ****       }
 565:../../freeRtos/Lib/ramdysk.c ****       fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
 566:../../freeRtos/Lib/ramdysk.c ****       plik++;
 567:../../freeRtos/Lib/ramdysk.c ****     }
 568:../../freeRtos/Lib/ramdysk.c ****     tmpKlaster2 = tmpKlaster;
 569:../../freeRtos/Lib/ramdysk.c ****     tmpKlaster = klastry[tmpKlaster];
 570:../../freeRtos/Lib/ramdysk.c ****   }
 571:../../freeRtos/Lib/ramdysk.c ****   while (tmpKlaster != tmpKlaster2);
 572:../../freeRtos/Lib/ramdysk.c **** }
 573:../../freeRtos/Lib/ramdysk.c **** 
 574:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskLiczbaWolnychKlastrow(void)
 575:../../freeRtos/Lib/ramdysk.c **** {
 576:../../freeRtos/Lib/ramdysk.c ****   uint8_t wynik=0;
 577:../../freeRtos/Lib/ramdysk.c ****   uint8_t temp;
 578:../../freeRtos/Lib/ramdysk.c ****   for (temp = L_KLASTROW-1; temp > 0; temp--)
 579:../../freeRtos/Lib/ramdysk.c ****     if (klastry[temp] == 0)
 580:../../freeRtos/Lib/ramdysk.c ****       wynik++;
 581:../../freeRtos/Lib/ramdysk.c ****   return wynik;
 582:../../freeRtos/Lib/ramdysk.c **** }
 583:../../freeRtos/Lib/ramdysk.c **** 
 584:../../freeRtos/Lib/ramdysk.c **** 
 585:../../freeRtos/Lib/ramdysk.c **** static int getSTD(FILE *stream)
 586:../../freeRtos/Lib/ramdysk.c **** {
 587:../../freeRtos/Lib/ramdysk.c ****   uint8_t wynik;
 588:../../freeRtos/Lib/ramdysk.c ****   struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
 589:../../freeRtos/Lib/ramdysk.c ****   
 590:../../freeRtos/Lib/ramdysk.c ****   if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
 591:../../freeRtos/Lib/ramdysk.c ****     return wynik;
 592:../../freeRtos/Lib/ramdysk.c ****   return EOF;
 593:../../freeRtos/Lib/ramdysk.c **** }
 594:../../freeRtos/Lib/ramdysk.c **** 
 595:../../freeRtos/Lib/ramdysk.c **** static int putSTD(char c, FILE *stream)
 596:../../freeRtos/Lib/ramdysk.c **** {
 1314               	.LM131:
 1315               	.LFBB13:
 1316               	/* prologue: function */
 1317               	/* frame size = 0 */
 1318               	/* stack size = 0 */
 1319               	.L__stack_usage = 0
 1320 03f8 FB01      		movw r30,r22
 597:../../freeRtos/Lib/ramdysk.c ****   struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
 598:../../freeRtos/Lib/ramdysk.c ****   return ramDyskZapiszBajtDoPliku(fd, c);  
 1322               	.LM132:
 1323 03fa 682F      		mov r22,r24
 1324 03fc 8485      		ldd r24,Z+12
 1325 03fe 9585      		ldd r25,Z+13
 1326 0400 0E94 0000 		call ramDyskZapiszBajtDoPliku
 599:../../freeRtos/Lib/ramdysk.c **** }
 1328               	.LM133:
 1329 0404 90E0      		ldi r25,0
 1330 0406 0895      		ret
 1332               	.Lscope13:
 1334               		.stabd	78,0,0
 1338               	.global	ramDyskCzytajBajtZPliku
 1340               	ramDyskCzytajBajtZPliku:
 1341               		.stabd	46,0,0
 323:../../freeRtos/Lib/ramdysk.c **** {
 1343               	.LM134:
 1344               	.LFBB14:
 1345 0408 0F93      		push r16
 1346 040a 1F93      		push r17
 1347 040c CF93      		push r28
 1348 040e DF93      		push r29
 1349               	/* prologue: function */
 1350               	/* frame size = 0 */
 1351               	/* stack size = 4 */
 1352               	.L__stack_usage = 4
 1353 0410 EC01      		movw r28,r24
 1354 0412 8B01      		movw r16,r22
 1355               	.LBB19:
 1356               	.LBB20:
  26:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi > fd->IndHi)
 1358               	.LM135:
 1359 0414 EC81      		ldd r30,Y+4
 1360 0416 FD81      		ldd r31,Y+5
 1361 0418 8281      		ldd r24,Z+2
 1362 041a 6B81      		ldd r22,Y+3
 1363 041c 6817      		cp r22,r24
 1364 041e 00F0      		brlo .L93
  29:../../freeRtos/Lib/ramdysk.c ****   if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
 1366               	.LM136:
 1367 0420 8613      		cpse r24,r22
 1368 0422 00C0      		rjmp .L98
 1369 0424 9181      		ldd r25,Z+1
 1370 0426 8A81      		ldd r24,Y+2
 1371 0428 9817      		cp r25,r24
 1372 042a 00F4      		brsh .L93
 1373               	.L98:
 1374               	.LBE20:
 1375               	.LBE19:
 325:../../freeRtos/Lib/ramdysk.c ****     return 1;                                         //1 - eof
 1377               	.LM137:
 1378 042c 81E0      		ldi r24,lo8(1)
 1379 042e 00C0      		rjmp .L99
 1380               	.L93:
 327:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku now
 1382               	.LM138:
 1383 0430 8A81      		ldd r24,Y+2
 1384 0432 8111      		cpse r24,__zero_reg__
 1385 0434 00C0      		rjmp .L97
 1386               	.LBB21:
 329:../../freeRtos/Lib/ramdysk.c ****     uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
 1388               	.LM139:
 1389 0436 8081      		ld r24,Z
 1390 0438 0E94 0000 		call znajdzKlasterN
 330:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego k
 1392               	.LM140:
 1393 043c 90E0      		ldi r25,0
 1394 043e 8058      		subi r24,-128
 1395 0440 9F4F      		sbci r25,-1
 1396 0442 1882      		st Y,__zero_reg__
 1397 0444 8983      		std Y+1,r24
 1398               	.L97:
 1399               	.LBE21:
 333:../../freeRtos/Lib/ramdysk.c ****   *bajt = *(fd->Wsk);                                 //Odczyt z pliku
 1401               	.LM141:
 1402 0446 E881      		ld r30,Y
 1403 0448 F981      		ldd r31,Y+1
 1404 044a 8081      		ld r24,Z
 1405 044c F801      		movw r30,r16
 1406 044e 8083      		st Z,r24
 334:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo++;                                        //Zwiększenie indeksu o 1
 1408               	.LM142:
 1409 0450 8A81      		ldd r24,Y+2
 1410 0452 8F5F      		subi r24,lo8(-(1))
 1411 0454 8A83      		std Y+2,r24
 335:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klas
 1413               	.LM143:
 1414 0456 8111      		cpse r24,__zero_reg__
 1415 0458 00C0      		rjmp .L95
 336:../../freeRtos/Lib/ramdysk.c ****     fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół wzgl
 1417               	.LM144:
 1418 045a 8B81      		ldd r24,Y+3
 1419 045c 8F5F      		subi r24,lo8(-(1))
 1420 045e 8B83      		std Y+3,r24
 1421 0460 00C0      		rjmp .L100
 1422               	.L95:
 338:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
 1424               	.LM145:
 1425 0462 8881      		ld r24,Y
 1426 0464 9981      		ldd r25,Y+1
 1427 0466 0196      		adiw r24,1
 1428 0468 9983      		std Y+1,r25
 1429 046a 8883      		st Y,r24
 1430               	.L100:
 339:../../freeRtos/Lib/ramdysk.c ****   return 0;
 1432               	.LM146:
 1433 046c 80E0      		ldi r24,0
 1434               	.L99:
 1435               	/* epilogue start */
 340:../../freeRtos/Lib/ramdysk.c **** }
 1437               	.LM147:
 1438 046e DF91      		pop r29
 1439 0470 CF91      		pop r28
 1440 0472 1F91      		pop r17
 1441 0474 0F91      		pop r16
 1442 0476 0895      		ret
 1447               	.Lscope14:
 1449               		.stabd	78,0,0
 1453               	getSTD:
 1454               		.stabd	46,0,0
 586:../../freeRtos/Lib/ramdysk.c **** {
 1456               	.LM148:
 1457               	.LFBB15:
 1458 0478 CF93      		push r28
 1459 047a DF93      		push r29
 1460 047c 1F92      		push __zero_reg__
 1461 047e CDB7      		in r28,__SP_L__
 1462 0480 DEB7      		in r29,__SP_H__
 1463               	/* prologue: function */
 1464               	/* frame size = 1 */
 1465               	/* stack size = 3 */
 1466               	.L__stack_usage = 3
 590:../../freeRtos/Lib/ramdysk.c ****   if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
 1468               	.LM149:
 1469 0482 BE01      		movw r22,r28
 1470 0484 6F5F      		subi r22,-1
 1471 0486 7F4F      		sbci r23,-1
 1472 0488 FC01      		movw r30,r24
 1473 048a 8485      		ldd r24,Z+12
 1474 048c 9585      		ldd r25,Z+13
 1475 048e 0E94 0000 		call ramDyskCzytajBajtZPliku
 1476 0492 8111      		cpse r24,__zero_reg__
 1477 0494 00C0      		rjmp .L103
 591:../../freeRtos/Lib/ramdysk.c ****     return wynik;
 1479               	.LM150:
 1480 0496 8981      		ldd r24,Y+1
 1481 0498 90E0      		ldi r25,0
 1482 049a 00C0      		rjmp .L102
 1483               	.L103:
 592:../../freeRtos/Lib/ramdysk.c ****   return EOF;
 1485               	.LM151:
 1486 049c 8FEF      		ldi r24,lo8(-1)
 1487 049e 9FEF      		ldi r25,lo8(-1)
 1488               	.L102:
 1489               	/* epilogue start */
 593:../../freeRtos/Lib/ramdysk.c **** }
 1491               	.LM152:
 1492 04a0 0F90      		pop __tmp_reg__
 1493 04a2 DF91      		pop r29
 1494 04a4 CF91      		pop r28
 1495 04a6 0895      		ret
 1500               	.Lscope15:
 1502               		.stabd	78,0,0
 1507               	.global	ramDyskZapiszBlokDoPliku
 1509               	ramDyskZapiszBlokDoPliku:
 1510               		.stabd	46,0,0
 343:../../freeRtos/Lib/ramdysk.c **** {
 1512               	.LM153:
 1513               	.LFBB16:
 1514 04a8 9F92      		push r9
 1515 04aa AF92      		push r10
 1516 04ac BF92      		push r11
 1517 04ae CF92      		push r12
 1518 04b0 DF92      		push r13
 1519 04b2 EF92      		push r14
 1520 04b4 FF92      		push r15
 1521 04b6 0F93      		push r16
 1522 04b8 1F93      		push r17
 1523 04ba CF93      		push r28
 1524 04bc DF93      		push r29
 1525               	/* prologue: function */
 1526               	/* frame size = 0 */
 1527               	/* stack size = 11 */
 1528               	.L__stack_usage = 11
 1529 04be EC01      		movw r28,r24
 1530 04c0 5B01      		movw r10,r22
 1531 04c2 6A01      		movw r12,r20
 344:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 1533               	.LM154:
 1534 04c4 0C81      		ldd r16,Y+4
 1535 04c6 1D81      		ldd r17,Y+5
 1536 04c8 F801      		movw r30,r16
 1537 04ca 8081      		ld r24,Z
 1538 04cc 8111      		cpse r24,__zero_reg__
 1539 04ce 00C0      		rjmp .L105
 345:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 1541               	.LM155:
 1542 04d0 0E94 0000 		call znajdzWolnyKlaster
 1543 04d4 F801      		movw r30,r16
 1544 04d6 8083      		st Z,r24
 1545               	.L105:
 347:../../freeRtos/Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisa
 1547               	.LM156:
 1548 04d8 8A81      		ldd r24,Y+2
 1549 04da E12C      		mov r14,__zero_reg__
 1550 04dc FF24      		clr r15
 1551 04de F394      		inc r15
 1552 04e0 E81A      		sub r14,r24
 1553 04e2 F108      		sbc r15,__zero_reg__
 348:../../freeRtos/Lib/ramdysk.c ****   uint16_t doZapisu = *dlugosc;
 1555               	.LM157:
 1556 04e4 F601      		movw r30,r12
 1557 04e6 0081      		ld r16,Z
 1558 04e8 1181      		ldd r17,Z+1
 349:../../freeRtos/Lib/ramdysk.c ****   *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
 1560               	.LM158:
 1561 04ea 1182      		std Z+1,__zero_reg__
 1562 04ec 1082      		st Z,__zero_reg__
 350:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 1564               	.LM159:
 1565 04ee 912C      		mov r9,__zero_reg__
 1566               	.L106:
 351:../../freeRtos/Lib/ramdysk.c ****   while (doZapisu > 0)
 1568               	.LM160:
 1569 04f0 0115      		cp r16,__zero_reg__
 1570 04f2 1105      		cpc r17,__zero_reg__
 1571 04f4 01F4      		brne .+2
 1572 04f6 00C0      		rjmp .L116
 353:../../freeRtos/Lib/ramdysk.c ****     if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to
 1574               	.LM161:
 1575 04f8 8A81      		ldd r24,Y+2
 1576 04fa 8111      		cpse r24,__zero_reg__
 1577 04fc 00C0      		rjmp .L107
 355:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze
 1579               	.LM162:
 1580 04fe 9110      		cpse r9,__zero_reg__
 1581 0500 00C0      		rjmp .L108
 356:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra 
 1583               	.LM163:
 1584 0502 EC81      		ldd r30,Y+4
 1585 0504 FD81      		ldd r31,Y+5
 1586 0506 6B81      		ldd r22,Y+3
 1587 0508 8081      		ld r24,Z
 1588 050a 0E94 0000 		call znajdzKlasterN
 1589 050e 00C0      		rjmp .L115
 1590               	.L108:
 358:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
 1592               	.LM164:
 1593 0510 892D      		mov r24,r9
 1594 0512 0E94 0000 		call nastepnyKlaster
 1595               	.L115:
 1596 0516 982E      		mov r9,r24
 359:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
 1598               	.LM165:
 1599 0518 8823      		tst r24
 1600 051a 01F4      		brne .+2
 1601 051c 00C0      		rjmp .L114
 362:../../freeRtos/Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Ter
 1603               	.LM166:
 1604 051e 90E0      		ldi r25,0
 1605 0520 8058      		subi r24,-128
 1606 0522 9F4F      		sbci r25,-1
 1607 0524 1882      		st Y,__zero_reg__
 1608 0526 8983      		std Y+1,r24
 1609               	.L107:
 1610 0528 8881      		ld r24,Y
 1611 052a 9981      		ldd r25,Y+1
 364:../../freeRtos/Lib/ramdysk.c ****     if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w b
 1613               	.LM167:
 1614 052c E016      		cp r14,r16
 1615 052e F106      		cpc r15,r17
 1616 0530 00F4      		brsh .L111
 366:../../freeRtos/Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
 1618               	.LM168:
 1619 0532 A701      		movw r20,r14
 1620 0534 B501      		movw r22,r10
 1621 0536 0E94 0000 		call memcpy
 367:../../freeRtos/Lib/ramdysk.c ****       znaki +=dlBloku;                      
 1623               	.LM169:
 1624 053a AE0C      		add r10,r14
 1625 053c BF1C      		adc r11,r15
 368:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na począ
 1627               	.LM170:
 1628 053e 1A82      		std Y+2,__zero_reg__
 369:../../freeRtos/Lib/ramdysk.c ****       doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka
 1630               	.LM171:
 1631 0540 0E19      		sub r16,r14
 1632 0542 1F09      		sbc r17,r15
 370:../../freeRtos/Lib/ramdysk.c ****       *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych d
 1634               	.LM172:
 1635 0544 F601      		movw r30,r12
 1636 0546 2081      		ld r18,Z
 1637 0548 3181      		ldd r19,Z+1
 1638 054a 2E0D      		add r18,r14
 1639 054c 3F1D      		adc r19,r15
 1640 054e 3183      		std Z+1,r19
 1641 0550 2083      		st Z,r18
 371:../../freeRtos/Lib/ramdysk.c ****       fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. 
 1643               	.LM173:
 1644 0552 8B81      		ldd r24,Y+3
 1645 0554 8F5F      		subi r24,lo8(-(1))
 1646 0556 8B83      		std Y+3,r24
 372:../../freeRtos/Lib/ramdysk.c ****       dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 
 1648               	.LM174:
 1649 0558 E12C      		mov r14,__zero_reg__
 1650 055a FF24      		clr r15
 1651 055c F394      		inc r15
 1652 055e 00C0      		rjmp .L106
 1653               	.L111:
 376:../../freeRtos/Lib/ramdysk.c ****       memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
 1655               	.LM175:
 1656 0560 A801      		movw r20,r16
 1657 0562 B501      		movw r22,r10
 1658 0564 0E94 0000 		call memcpy
 377:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mn
 1660               	.LM176:
 1661 0568 8A81      		ldd r24,Y+2
 1662 056a 800F      		add r24,r16
 1663 056c 8A83      		std Y+2,r24
 378:../../freeRtos/Lib/ramdysk.c ****       *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych d
 1665               	.LM177:
 1666 056e F601      		movw r30,r12
 1667 0570 2081      		ld r18,Z
 1668 0572 3181      		ldd r19,Z+1
 1669 0574 200F      		add r18,r16
 1670 0576 311F      		adc r19,r17
 1671 0578 3183      		std Z+1,r19
 1672 057a 2083      		st Z,r18
 380:../../freeRtos/Lib/ramdysk.c ****       fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce kla
 1674               	.LM178:
 1675 057c 292D      		mov r18,r9
 1676 057e 30E0      		ldi r19,0
 1677 0580 2058      		subi r18,-128
 1678 0582 3F4F      		sbci r19,-1
 1679 0584 322F      		mov r19,r18
 1680 0586 2227      		clr r18
 1681 0588 8A81      		ldd r24,Y+2
 1682 058a 280F      		add r18,r24
 1683 058c 311D      		adc r19,__zero_reg__
 1684 058e 3983      		std Y+1,r19
 1685 0590 2883      		st Y,r18
 379:../../freeRtos/Lib/ramdysk.c ****       doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
 1687               	.LM179:
 1688 0592 00E0      		ldi r16,0
 1689 0594 10E0      		ldi r17,0
 1690 0596 00C0      		rjmp .L106
 1691               	.L116:
 383:../../freeRtos/Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
 1693               	.LM180:
 1694 0598 CE01      		movw r24,r28
 1695 059a 0E94 0000 		call uaktualnijRozmiarPliku
 384:../../freeRtos/Lib/ramdysk.c ****   return 0;
 1697               	.LM181:
 1698 059e 80E0      		ldi r24,0
 1699 05a0 00C0      		rjmp .L110
 1700               	.L114:
 360:../../freeRtos/Lib/ramdysk.c ****         return 1;                                 //1 - Brak wolnego klastra
 1702               	.LM182:
 1703 05a2 81E0      		ldi r24,lo8(1)
 1704               	.L110:
 1705               	/* epilogue start */
 385:../../freeRtos/Lib/ramdysk.c **** }
 1707               	.LM183:
 1708 05a4 DF91      		pop r29
 1709 05a6 CF91      		pop r28
 1710 05a8 1F91      		pop r17
 1711 05aa 0F91      		pop r16
 1712 05ac FF90      		pop r15
 1713 05ae EF90      		pop r14
 1714 05b0 DF90      		pop r13
 1715 05b2 CF90      		pop r12
 1716 05b4 BF90      		pop r11
 1717 05b6 AF90      		pop r10
 1718 05b8 9F90      		pop r9
 1719 05ba 0895      		ret
 1726               	.Lscope16:
 1728               		.stabd	78,0,0
 1733               	.global	ramDyskCzytajBlokZPliku
 1735               	ramDyskCzytajBlokZPliku:
 1736               		.stabd	46,0,0
 388:../../freeRtos/Lib/ramdysk.c **** {
 1738               	.LM184:
 1739               	.LFBB17:
 1740 05bc 9F92      		push r9
 1741 05be AF92      		push r10
 1742 05c0 BF92      		push r11
 1743 05c2 CF92      		push r12
 1744 05c4 DF92      		push r13
 1745 05c6 EF92      		push r14
 1746 05c8 FF92      		push r15
 1747 05ca 0F93      		push r16
 1748 05cc 1F93      		push r17
 1749 05ce CF93      		push r28
 1750 05d0 DF93      		push r29
 1751               	/* prologue: function */
 1752               	/* frame size = 0 */
 1753               	/* stack size = 11 */
 1754               	.L__stack_usage = 11
 1755 05d2 EC01      		movw r28,r24
 1756 05d4 5B01      		movw r10,r22
 1757 05d6 7A01      		movw r14,r20
 389:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 1759               	.LM185:
 1760 05d8 EC81      		ldd r30,Y+4
 1761 05da FD81      		ldd r31,Y+5
 1762 05dc 8081      		ld r24,Z
 1763 05de 8111      		cpse r24,__zero_reg__
 1764 05e0 00C0      		rjmp .L118
 391:../../freeRtos/Lib/ramdysk.c ****     *dlugosc = 0;
 1766               	.LM186:
 1767 05e2 FA01      		movw r30,r20
 1768 05e4 1182      		std Z+1,__zero_reg__
 1769 05e6 1082      		st Z,__zero_reg__
 392:../../freeRtos/Lib/ramdysk.c ****     return 1;                         //1 - Plik jest pusty
 1771               	.LM187:
 1772 05e8 81E0      		ldi r24,lo8(1)
 1773 05ea 00C0      		rjmp .L131
 1774               	.L118:
 1775               	.LBB24:
 1776               	.LBB25:
  26:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->rozmiarHi > fd->IndHi)
 1778               	.LM188:
 1779 05ec 8281      		ldd r24,Z+2
 1780 05ee 2B81      		ldd r18,Y+3
 1781 05f0 2817      		cp r18,r24
 1782 05f2 00F0      		brlo .L120
  29:../../freeRtos/Lib/ramdysk.c ****   if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
 1784               	.LM189:
 1785 05f4 8213      		cpse r24,r18
 1786 05f6 00C0      		rjmp .L121
 1787 05f8 3181      		ldd r19,Z+1
 1788 05fa 9A81      		ldd r25,Y+2
 1789 05fc 3917      		cp r19,r25
 1790 05fe 00F4      		brsh .L120
 1791               	.L121:
 1792               	.LBE25:
 1793               	.LBE24:
 396:../../freeRtos/Lib/ramdysk.c ****     *dlugosc = 0;
 1795               	.LM190:
 1796 0600 F701      		movw r30,r14
 1797 0602 1182      		std Z+1,__zero_reg__
 1798 0604 1082      		st Z,__zero_reg__
 397:../../freeRtos/Lib/ramdysk.c ****     return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pli
 1800               	.LM191:
 1801 0606 82E0      		ldi r24,lo8(2)
 1802 0608 00C0      		rjmp .L131
 1803               	.L120:
 400:../../freeRtos/Lib/ramdysk.c ****   uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
 1805               	.LM192:
 1806 060a 90E0      		ldi r25,0
 1807 060c 821B      		sub r24,r18
 1808 060e 9109      		sbc r25,__zero_reg__
 401:../../freeRtos/Lib/ramdysk.c ****   lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze z
 1810               	.LM193:
 1811 0610 2181      		ldd r18,Z+1
 1812 0612 30E0      		ldi r19,0
 402:../../freeRtos/Lib/ramdysk.c ****   lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zaws
 1814               	.LM194:
 1815 0614 4A81      		ldd r20,Y+2
 401:../../freeRtos/Lib/ramdysk.c ****   lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze z
 1817               	.LM195:
 1818 0616 241B      		sub r18,r20
 1819 0618 3109      		sbc r19,__zero_reg__
 402:../../freeRtos/Lib/ramdysk.c ****   lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zaws
 1821               	.LM196:
 1822 061a 280F      		add r18,r24
 1823 061c 391F      		adc r19,r25
 404:../../freeRtos/Lib/ramdysk.c ****   uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i
 1825               	.LM197:
 1826 061e F701      		movw r30,r14
 1827 0620 0081      		ld r16,Z
 1828 0622 1181      		ldd r17,Z+1
 1829 0624 2017      		cp r18,r16
 1830 0626 3107      		cpc r19,r17
 1831 0628 00F4      		brsh .L128
 1832 062a 8901      		movw r16,r18
 1833               	.L128:
 407:../../freeRtos/Lib/ramdysk.c ****   *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
 1835               	.LM198:
 1836 062c F701      		movw r30,r14
 1837 062e 1182      		std Z+1,__zero_reg__
 1838 0630 1082      		st Z,__zero_reg__
 408:../../freeRtos/Lib/ramdysk.c ****   uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktua
 1840               	.LM199:
 1841 0632 8A81      		ldd r24,Y+2
 1842 0634 C12C      		mov r12,__zero_reg__
 1843 0636 DD24      		clr r13
 1844 0638 D394      		inc r13
 1845 063a C81A      		sub r12,r24
 1846 063c D108      		sbc r13,__zero_reg__
 409:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 1848               	.LM200:
 1849 063e 912C      		mov r9,__zero_reg__
 1850               	.L129:
 410:../../freeRtos/Lib/ramdysk.c ****   while (doOdczytania > 0)
 1852               	.LM201:
 1853 0640 0115      		cp r16,__zero_reg__
 1854 0642 1105      		cpc r17,__zero_reg__
 1855 0644 01F4      		brne .+2
 1856 0646 00C0      		rjmp .L133
 412:../../freeRtos/Lib/ramdysk.c ****     if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, 
 1858               	.LM202:
 1859 0648 8A81      		ldd r24,Y+2
 1860 064a 8111      		cpse r24,__zero_reg__
 1861 064c 00C0      		rjmp .L122
 414:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster == 0)
 1863               	.LM203:
 1864 064e 9110      		cpse r9,__zero_reg__
 1865 0650 00C0      		rjmp .L123
 415:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
 1867               	.LM204:
 1868 0652 EC81      		ldd r30,Y+4
 1869 0654 FD81      		ldd r31,Y+5
 1870 0656 6B81      		ldd r22,Y+3
 1871 0658 8081      		ld r24,Z
 1872 065a 0E94 0000 		call znajdzKlasterN
 1873 065e 00C0      		rjmp .L132
 1874               	.L123:
 417:../../freeRtos/Lib/ramdysk.c ****         tmpKlaster = nastepnyKlaster(tmpKlaster);
 1876               	.LM205:
 1877 0660 892D      		mov r24,r9
 1878 0662 0E94 0000 		call nastepnyKlaster
 1879               	.L132:
 1880 0666 982E      		mov r9,r24
 418:../../freeRtos/Lib/ramdysk.c ****       if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
 1882               	.LM206:
 1883 0668 8823      		tst r24
 1884 066a 01F0      		breq .L130
 419:../../freeRtos/Lib/ramdysk.c ****         fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
 1886               	.LM207:
 1887 066c 90E0      		ldi r25,0
 1888 066e 8058      		subi r24,-128
 1889 0670 9F4F      		sbci r25,-1
 1890 0672 1882      		st Y,__zero_reg__
 1891 0674 8983      		std Y+1,r24
 1892               	.L122:
 1893 0676 6881      		ld r22,Y
 1894 0678 7981      		ldd r23,Y+1
 424:../../freeRtos/Lib/ramdysk.c ****     if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
 1896               	.LM208:
 1897 067a C016      		cp r12,r16
 1898 067c D106      		cpc r13,r17
 1899 067e 00F4      		brsh .L125
 426:../../freeRtos/Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
 1901               	.LM209:
 1902 0680 A601      		movw r20,r12
 1903 0682 C501      		movw r24,r10
 1904 0684 0E94 0000 		call memcpy
 427:../../freeRtos/Lib/ramdysk.c ****       znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy 
 1906               	.LM210:
 1907 0688 AC0C      		add r10,r12
 1908 068a BD1C      		adc r11,r13
 428:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
 1910               	.LM211:
 1911 068c 1A82      		std Y+2,__zero_reg__
 429:../../freeRtos/Lib/ramdysk.c ****       fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz ni
 1913               	.LM212:
 1914 068e 8B81      		ldd r24,Y+3
 1915 0690 8F5F      		subi r24,lo8(-(1))
 1916 0692 8B83      		std Y+3,r24
 430:../../freeRtos/Lib/ramdysk.c ****       doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
 1918               	.LM213:
 1919 0694 0C19      		sub r16,r12
 1920 0696 1D09      		sbc r17,r13
 431:../../freeRtos/Lib/ramdysk.c ****       *dlugosc += dlBloku;             //Uaktualnienie 
 1922               	.LM214:
 1923 0698 F701      		movw r30,r14
 1924 069a 2081      		ld r18,Z
 1925 069c 3181      		ldd r19,Z+1
 1926 069e 2C0D      		add r18,r12
 1927 06a0 3D1D      		adc r19,r13
 1928 06a2 3183      		std Z+1,r19
 1929 06a4 2083      		st Z,r18
 432:../../freeRtos/Lib/ramdysk.c ****       dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całeg
 1931               	.LM215:
 1932 06a6 C12C      		mov r12,__zero_reg__
 1933 06a8 DD24      		clr r13
 1934 06aa D394      		inc r13
 1935 06ac 00C0      		rjmp .L129
 1936               	.L125:
 436:../../freeRtos/Lib/ramdysk.c ****       memcpy(znaki, fd->Wsk, doOdczytania);
 1938               	.LM216:
 1939 06ae A801      		movw r20,r16
 1940 06b0 C501      		movw r24,r10
 1941 06b2 0E94 0000 		call memcpy
 437:../../freeRtos/Lib/ramdysk.c ****       fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym sam
 1943               	.LM217:
 1944 06b6 2881      		ld r18,Y
 1945 06b8 3981      		ldd r19,Y+1
 1946 06ba 200F      		add r18,r16
 1947 06bc 311F      		adc r19,r17
 1948 06be 3983      		std Y+1,r19
 1949 06c0 2883      		st Y,r18
 438:../../freeRtos/Lib/ramdysk.c ****       fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zat
 1951               	.LM218:
 1952 06c2 8A81      		ldd r24,Y+2
 1953 06c4 800F      		add r24,r16
 1954 06c6 8A83      		std Y+2,r24
 439:../../freeRtos/Lib/ramdysk.c ****       *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów                  
 1956               	.LM219:
 1957 06c8 F701      		movw r30,r14
 1958 06ca 2081      		ld r18,Z
 1959 06cc 3181      		ldd r19,Z+1
 1960 06ce 200F      		add r18,r16
 1961 06d0 311F      		adc r19,r17
 1962 06d2 3183      		std Z+1,r19
 1963 06d4 2083      		st Z,r18
 440:../../freeRtos/Lib/ramdysk.c ****       doOdczytania = 0;                //Tutaj równie dobrze może być brake
 1965               	.LM220:
 1966 06d6 00E0      		ldi r16,0
 1967 06d8 10E0      		ldi r17,0
 1968 06da 00C0      		rjmp .L129
 1969               	.L133:
 443:../../freeRtos/Lib/ramdysk.c ****   return 0;
 1971               	.LM221:
 1972 06dc 80E0      		ldi r24,0
 1973 06de 00C0      		rjmp .L131
 1974               	.L130:
 421:../../freeRtos/Lib/ramdysk.c ****         return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
 1976               	.LM222:
 1977 06e0 83E0      		ldi r24,lo8(3)
 1978               	.L131:
 1979               	/* epilogue start */
 444:../../freeRtos/Lib/ramdysk.c **** }
 1981               	.LM223:
 1982 06e2 DF91      		pop r29
 1983 06e4 CF91      		pop r28
 1984 06e6 1F91      		pop r17
 1985 06e8 0F91      		pop r16
 1986 06ea FF90      		pop r15
 1987 06ec EF90      		pop r14
 1988 06ee DF90      		pop r13
 1989 06f0 CF90      		pop r12
 1990 06f2 BF90      		pop r11
 1991 06f4 AF90      		pop r10
 1992 06f6 9F90      		pop r9
 1993 06f8 0895      		ret
 2000               	.Lscope17:
 2002               		.stabd	78,0,0
 2006               	.global	ramDyskUstawWskaznik
 2008               	ramDyskUstawWskaznik:
 2009               		.stabd	46,0,0
 447:../../freeRtos/Lib/ramdysk.c **** {
 2011               	.LM224:
 2012               	.LFBB18:
 2013 06fa EF92      		push r14
 2014 06fc FF92      		push r15
 2015 06fe 0F93      		push r16
 2016 0700 1F93      		push r17
 2017 0702 CF93      		push r28
 2018 0704 DF93      		push r29
 2019               	/* prologue: function */
 2020               	/* frame size = 0 */
 2021               	/* stack size = 6 */
 2022               	.L__stack_usage = 6
 2023 0706 EC01      		movw r28,r24
 448:../../freeRtos/Lib/ramdysk.c ****   if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje
 2025               	.LM225:
 2026 0708 6115      		cp r22,__zero_reg__
 2027 070a 7105      		cpc r23,__zero_reg__
 2028 070c 01F4      		brne .L135
 450:../../freeRtos/Lib/ramdysk.c ****     fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bard
 2030               	.LM226:
 2031 070e 1A82      		std Y+2,__zero_reg__
 451:../../freeRtos/Lib/ramdysk.c ****     fd->IndHi = 0;
 2033               	.LM227:
 2034 0710 1B82      		std Y+3,__zero_reg__
 2035 0712 00C0      		rjmp .L140
 2036               	.L135:
 454:../../freeRtos/Lib/ramdysk.c ****   indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio 
 2038               	.LM228:
 2039 0714 8B01      		movw r16,r22
 2040 0716 0150      		subi r16,1
 2041 0718 1109      		sbc r17,__zero_reg__
 457:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydziel
 2043               	.LM229:
 2044 071a EC80      		ldd r14,Y+4
 2045 071c FD80      		ldd r15,Y+5
 2046 071e F701      		movw r30,r14
 2047 0720 8081      		ld r24,Z
 2048 0722 8111      		cpse r24,__zero_reg__
 2049 0724 00C0      		rjmp .L137
 458:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pl
 2051               	.LM230:
 2052 0726 0E94 0000 		call znajdzWolnyKlaster
 2053 072a F701      		movw r30,r14
 2054 072c 8083      		st Z,r24
 2055               	.L137:
 462:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mn
 2057               	.LM231:
 2058 072e 0A83      		std Y+2,r16
 463:../../freeRtos/Lib/ramdysk.c ****   fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu
 2060               	.LM232:
 2061 0730 1B83      		std Y+3,r17
 465:../../freeRtos/Lib/ramdysk.c ****   uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
 2063               	.LM233:
 2064 0732 EC81      		ldd r30,Y+4
 2065 0734 FD81      		ldd r31,Y+5
 2066 0736 612F      		mov r22,r17
 2067 0738 8081      		ld r24,Z
 2068 073a 0E94 0000 		call znajdzKlasterN
 2069 073e 182F      		mov r17,r24
 466:../../freeRtos/Lib/ramdysk.c ****   if (nrKlastra == 0)
 2071               	.LM234:
 2072 0740 8823      		tst r24
 2073 0742 01F0      		breq .L139
 469:../../freeRtos/Lib/ramdysk.c ****   uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
 2075               	.LM235:
 2076 0744 CE01      		movw r24,r28
 2077 0746 0E94 0000 		call uaktualnijRozmiarPliku
 471:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
 2079               	.LM236:
 2080 074a 2A81      		ldd r18,Y+2
 2081 074c 2F5F      		subi r18,lo8(-(1))
 2082 074e 2A83      		std Y+2,r18
 472:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, 
 2084               	.LM237:
 2085 0750 2111      		cpse r18,__zero_reg__
 2086 0752 00C0      		rjmp .L138
 473:../../freeRtos/Lib/ramdysk.c ****     fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący b
 2088               	.LM238:
 2089 0754 8B81      		ldd r24,Y+3
 2090 0756 8F5F      		subi r24,lo8(-(1))
 2091 0758 8B83      		std Y+3,r24
 2092 075a 00C0      		rjmp .L140
 2093               	.L138:
 475:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejs
 2095               	.LM239:
 2096 075c 812F      		mov r24,r17
 2097 075e 90E0      		ldi r25,0
 2098 0760 8058      		subi r24,-128
 2099 0762 9F4F      		sbci r25,-1
 2100 0764 982F      		mov r25,r24
 2101 0766 8827      		clr r24
 2102 0768 820F      		add r24,r18
 2103 076a 911D      		adc r25,__zero_reg__
 2104 076c 9983      		std Y+1,r25
 2105 076e 8883      		st Y,r24
 2106               	.L140:
 477:../../freeRtos/Lib/ramdysk.c ****   return 0; 
 2108               	.LM240:
 2109 0770 80E0      		ldi r24,0
 2110 0772 00C0      		rjmp .L136
 2111               	.L139:
 467:../../freeRtos/Lib/ramdysk.c ****     return 1;                                             //Brak klastrów
 2113               	.LM241:
 2114 0774 81E0      		ldi r24,lo8(1)
 2115               	.L136:
 2116               	/* epilogue start */
 478:../../freeRtos/Lib/ramdysk.c **** }
 2118               	.LM242:
 2119 0776 DF91      		pop r29
 2120 0778 CF91      		pop r28
 2121 077a 1F91      		pop r17
 2122 077c 0F91      		pop r16
 2123 077e FF90      		pop r15
 2124 0780 EF90      		pop r14
 2125 0782 0895      		ret
 2130               	.Lscope18:
 2132               		.stabd	78,0,0
 2135               	.global	ramDyskUstawWskaznikNaKoniec
 2137               	ramDyskUstawWskaznikNaKoniec:
 2138               		.stabd	46,0,0
 481:../../freeRtos/Lib/ramdysk.c **** {
 2140               	.LM243:
 2141               	.LFBB19:
 2142 0784 CF93      		push r28
 2143 0786 DF93      		push r29
 2144               	/* prologue: function */
 2145               	/* frame size = 0 */
 2146               	/* stack size = 2 */
 2147               	.L__stack_usage = 2
 2148 0788 EC01      		movw r28,r24
 482:../../freeRtos/Lib/ramdysk.c ****   if (fd == NULL)
 2150               	.LM244:
 2151 078a 0097      		sbiw r24,0
 2152 078c 01F0      		breq .L143
 484:../../freeRtos/Lib/ramdysk.c ****   fd->IndLo = fd->wpis->rozmiarLo;
 2154               	.LM245:
 2155 078e EC81      		ldd r30,Y+4
 2156 0790 FD81      		ldd r31,Y+5
 2157 0792 8181      		ldd r24,Z+1
 2158 0794 8A83      		std Y+2,r24
 485:../../freeRtos/Lib/ramdysk.c ****   fd->IndHi = fd->wpis->rozmiarHi;
 2160               	.LM246:
 2161 0796 9281      		ldd r25,Z+2
 2162 0798 9B83      		std Y+3,r25
 488:../../freeRtos/Lib/ramdysk.c ****   if (fd->IndLo != 0)
 2164               	.LM247:
 2165 079a 8823      		tst r24
 2166 079c 01F0      		breq .L144
 490:../../freeRtos/Lib/ramdysk.c ****     tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
 2168               	.LM248:
 2169 079e 6281      		ldd r22,Z+2
 2170 07a0 8081      		ld r24,Z
 2171 07a2 0E94 0000 		call znajdzKlasterN
 491:../../freeRtos/Lib/ramdysk.c ****     fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
 2173               	.LM249:
 2174 07a6 90E0      		ldi r25,0
 2175 07a8 8058      		subi r24,-128
 2176 07aa 9F4F      		sbci r25,-1
 2177 07ac 982F      		mov r25,r24
 2178 07ae 8827      		clr r24
 2179 07b0 2A81      		ldd r18,Y+2
 2180 07b2 820F      		add r24,r18
 2181 07b4 911D      		adc r25,__zero_reg__
 2182 07b6 9983      		std Y+1,r25
 2183 07b8 8883      		st Y,r24
 2184 07ba 00C0      		rjmp .L144
 2185               	.L143:
 483:../../freeRtos/Lib/ramdysk.c ****     return 1;
 2187               	.LM250:
 2188 07bc 81E0      		ldi r24,lo8(1)
 2189 07be 00C0      		rjmp .L142
 2190               	.L144:
 493:../../freeRtos/Lib/ramdysk.c ****   return 0;
 2192               	.LM251:
 2193 07c0 80E0      		ldi r24,0
 2194               	.L142:
 2195               	/* epilogue start */
 494:../../freeRtos/Lib/ramdysk.c **** }
 2197               	.LM252:
 2198 07c2 DF91      		pop r29
 2199 07c4 CF91      		pop r28
 2200 07c6 0895      		ret
 2205               	.Lscope19:
 2207               		.stabd	78,0,0
 2211               	.global	ramDyskDodajBlokXmodem
 2213               	ramDyskDodajBlokXmodem:
 2214               		.stabd	46,0,0
 497:../../freeRtos/Lib/ramdysk.c **** {
 2216               	.LM253:
 2217               	.LFBB20:
 2218 07c8 BF92      		push r11
 2219 07ca CF92      		push r12
 2220 07cc DF92      		push r13
 2221 07ce EF92      		push r14
 2222 07d0 FF92      		push r15
 2223 07d2 0F93      		push r16
 2224 07d4 1F93      		push r17
 2225 07d6 CF93      		push r28
 2226 07d8 DF93      		push r29
 2227               	/* prologue: function */
 2228               	/* frame size = 0 */
 2229               	/* stack size = 9 */
 2230               	.L__stack_usage = 9
 2231 07da EC01      		movw r28,r24
 498:../../freeRtos/Lib/ramdysk.c ****   if (nrBloku == 0)
 2233               	.LM254:
 2234 07dc 6115      		cp r22,__zero_reg__
 2235 07de 7105      		cpc r23,__zero_reg__
 2236 07e0 01F4      		brne .L146
 2237               	.L149:
 499:../../freeRtos/Lib/ramdysk.c ****     return NULL;
 2239               	.LM255:
 2240 07e2 80E0      		ldi r24,0
 2241 07e4 90E0      		ldi r25,0
 2242 07e6 00C0      		rjmp .L147
 2243               	.L146:
 500:../../freeRtos/Lib/ramdysk.c ****   nrBloku --;
 2245               	.LM256:
 2246 07e8 7B01      		movw r14,r22
 2247 07ea 81E0      		ldi r24,1
 2248 07ec E81A      		sub r14,r24
 2249 07ee F108      		sbc r15,__zero_reg__
 502:../../freeRtos/Lib/ramdysk.c ****   uint8_t indHi = (uint8_t)(nrBloku / 2);
 2251               	.LM257:
 2252 07f0 8701      		movw r16,r14
 2253 07f2 1695      		lsr r17
 2254 07f4 0795      		ror r16
 2255 07f6 B02E      		mov r11,r16
 506:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 2257               	.LM258:
 2258 07f8 CC80      		ldd r12,Y+4
 2259 07fa DD80      		ldd r13,Y+5
 2260 07fc F601      		movw r30,r12
 2261 07fe 8081      		ld r24,Z
 2262 0800 8111      		cpse r24,__zero_reg__
 2263 0802 00C0      		rjmp .L148
 507:../../freeRtos/Lib/ramdysk.c ****     fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
 2265               	.LM259:
 2266 0804 0E94 0000 		call znajdzWolnyKlaster
 2267 0808 F601      		movw r30,r12
 2268 080a 8083      		st Z,r24
 2269               	.L148:
 508:../../freeRtos/Lib/ramdysk.c ****   if (fd->wpis->pierwszyKlaster == 0)
 2271               	.LM260:
 2272 080c EC81      		ldd r30,Y+4
 2273 080e FD81      		ldd r31,Y+5
 2274 0810 8081      		ld r24,Z
 2275 0812 8823      		tst r24
 2276 0814 01F0      		breq .L149
 511:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
 2278               	.LM261:
 2279 0816 602F      		mov r22,r16
 2280 0818 0E94 0000 		call znajdzKlasterN
 512:../../freeRtos/Lib/ramdysk.c ****   if (tmpKlaster == 0)
 2282               	.LM262:
 2283 081c 8823      		tst r24
 2284 081e 01F0      		breq .L149
 2285 0820 EC81      		ldd r30,Y+4
 2286 0822 FD81      		ldd r31,Y+5
 2287 0824 282F      		mov r18,r24
 2288 0826 30E0      		ldi r19,0
 517:../../freeRtos/Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi <= indHi)
 2290               	.LM263:
 2291 0828 8281      		ldd r24,Z+2
 514:../../freeRtos/Lib/ramdysk.c ****   if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
 2293               	.LM264:
 2294 082a E0FE      		sbrs r14,0
 2295 082c 00C0      		rjmp .L150
 517:../../freeRtos/Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi <= indHi)
 2297               	.LM265:
 2298 082e B816      		cp r11,r24
 2299 0830 00F0      		brlo .L151
 519:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi+1;
 2301               	.LM266:
 2302 0832 0F5F      		subi r16,lo8(-(1))
 2303 0834 0283      		std Z+2,r16
 520:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 0;
 2305               	.LM267:
 2306 0836 EC81      		ldd r30,Y+4
 2307 0838 FD81      		ldd r31,Y+5
 2308 083a 1182      		std Z+1,__zero_reg__
 2309               	.L151:
 522:../../freeRtos/Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 128);
 2311               	.LM268:
 2312 083c 322F      		mov r19,r18
 2313 083e 2227      		clr r18
 2314 0840 2058      		subi r18,-128
 2315 0842 3F47      		sbci r19,127
 2316 0844 C901      		movw r24,r18
 2317 0846 00C0      		rjmp .L147
 2318               	.L150:
 526:../../freeRtos/Lib/ramdysk.c ****     if (fd->wpis->rozmiarHi < indHi)
 2320               	.LM269:
 2321 0848 8B15      		cp r24,r11
 2322 084a 00F4      		brsh .L152
 528:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarHi = indHi;
 2324               	.LM270:
 2325 084c 0283      		std Z+2,r16
 529:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 2327               	.LM271:
 2328 084e EC81      		ldd r30,Y+4
 2329 0850 FD81      		ldd r31,Y+5
 2330 0852 00C0      		rjmp .L160
 2331               	.L152:
 531:../../freeRtos/Lib/ramdysk.c ****     else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
 2333               	.LM272:
 2334 0854 8B11      		cpse r24,r11
 2335 0856 00C0      		rjmp .L153
 531:../../freeRtos/Lib/ramdysk.c ****     else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
 2337               	.LM273:
 2338 0858 8181      		ldd r24,Z+1
 2339 085a 87FD      		sbrc r24,7
 2340 085c 00C0      		rjmp .L153
 2341               	.L160:
 532:../../freeRtos/Lib/ramdysk.c ****       fd->wpis->rozmiarLo = 128;
 2343               	.LM274:
 2344 085e 80E8      		ldi r24,lo8(-128)
 2345 0860 8183      		std Z+1,r24
 2346               	.L153:
 534:../../freeRtos/Lib/ramdysk.c ****     wynik=dataPtr(tmpKlaster, 0);
 2348               	.LM275:
 2349 0862 80E0      		ldi r24,0
 2350 0864 90E8      		ldi r25,lo8(-128)
 2351 0866 920F      		add r25,r18
 2352               	.L147:
 2353               	/* epilogue start */
 537:../../freeRtos/Lib/ramdysk.c **** }
 2355               	.LM276:
 2356 0868 DF91      		pop r29
 2357 086a CF91      		pop r28
 2358 086c 1F91      		pop r17
 2359 086e 0F91      		pop r16
 2360 0870 FF90      		pop r15
 2361 0872 EF90      		pop r14
 2362 0874 DF90      		pop r13
 2363 0876 CF90      		pop r12
 2364 0878 BF90      		pop r11
 2365 087a 0895      		ret
 2371               	.Lscope20:
 2373               		.stabd	78,0,0
 2374               		.section	.rodata.str1.1,"aMS",@progbits,1
 2375               	.LC0:
 2376 0000 6E61 7A77 		.string	"nazwa\t\trozmiar\totwarty\r\n"
 2376      6109 0972 
 2376      6F7A 6D69 
 2376      6172 096F 
 2376      7477 6172 
 2377               	.LC1:
 2378 0019 0925 6409 		.string	"\t%d\t%d\r\n"
 2378      2564 0D0A 
 2378      00
 2379               		.text
 2381               	.global	ramDyskDir
 2383               	ramDyskDir:
 2384               		.stabd	46,0,0
 540:../../freeRtos/Lib/ramdysk.c **** {
 2386               	.LM277:
 2387               	.LFBB21:
 2388 087c 4F92      		push r4
 2389 087e 5F92      		push r5
 2390 0880 6F92      		push r6
 2391 0882 7F92      		push r7
 2392 0884 8F92      		push r8
 2393 0886 9F92      		push r9
 2394 0888 AF92      		push r10
 2395 088a BF92      		push r11
 2396 088c CF92      		push r12
 2397 088e DF92      		push r13
 2398 0890 EF92      		push r14
 2399 0892 FF92      		push r15
 2400 0894 0F93      		push r16
 2401 0896 1F93      		push r17
 2402 0898 CF93      		push r28
 2403 089a DF93      		push r29
 2404               	/* prologue: function */
 2405               	/* frame size = 0 */
 2406               	/* stack size = 16 */
 2407               	.L__stack_usage = 16
 2408 089c 782E      		mov r7,r24
 2409 089e 692E      		mov r6,r25
 541:../../freeRtos/Lib/ramdysk.c ****   fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
 2411               	.LM278:
 2412 08a0 682F      		mov r22,r24
 2413 08a2 792F      		mov r23,r25
 2414 08a4 80E0      		ldi r24,lo8(.LC0)
 2415 08a6 90E0      		ldi r25,hi8(.LC0)
 2416 08a8 0E94 0000 		call fputs
 543:../../freeRtos/Lib/ramdysk.c ****   uint8_t tmpKlaster = 0;
 2418               	.LM279:
 2419 08ac 512C      		mov r5,__zero_reg__
 565:../../freeRtos/Lib/ramdysk.c ****       fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
 2421               	.LM280:
 2422 08ae 30E0      		ldi r19,lo8(.LC1)
 2423 08b0 E32E      		mov r14,r19
 2424 08b2 30E0      		ldi r19,hi8(.LC1)
 2425 08b4 F32E      		mov r15,r19
 2426               	.L171:
 548:../../freeRtos/Lib/ramdysk.c ****     plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
 2428               	.LM281:
 2429 08b6 C52C      		mov r12,r5
 2430 08b8 D12C      		mov r13,__zero_reg__
 2431 08ba 5601      		movw r10,r12
 2432 08bc 80E8      		ldi r24,-128
 2433 08be A80E      		add r10,r24
 2434 08c0 B11C      		adc r11,__zero_reg__
 2435 08c2 BA2C      		mov r11,r10
 2436 08c4 AA24      		clr r10
 2437 08c6 E501      		movw r28,r10
 2438 08c8 6096      		adiw r28,16
 2439 08ca 90EF      		ldi r25,-16
 2440 08cc A91A      		sub r10,r25
 2441 08ce 9EEF      		ldi r25,-2
 2442 08d0 B90A      		sbc r11,r25
 2443               	.L170:
 2444 08d2 4E01      		movw r8,r28
 2445 08d4 80E1      		ldi r24,16
 2446 08d6 881A      		sub r8,r24
 2447 08d8 9108      		sbc r9,__zero_reg__
 2448 08da FE01      		movw r30,r28
 2449 08dc 3C97      		sbiw r30,12
 551:../../freeRtos/Lib/ramdysk.c ****       tmp3=plik->nazwa[0];
 2451               	.LM282:
 2452 08de 4080      		ld r4,Z
 552:../../freeRtos/Lib/ramdysk.c ****       if (tmp3 == 0)
 2454               	.LM283:
 2455 08e0 4110      		cpse r4,__zero_reg__
 2456 08e2 00C0      		rjmp .L162
 2457               	.L169:
 569:../../freeRtos/Lib/ramdysk.c ****     tmpKlaster = klastry[tmpKlaster];
 2459               	.LM284:
 2460 08e4 F601      		movw r30,r12
 2461 08e6 E050      		subi r30,lo8(-(klastry))
 2462 08e8 F040      		sbci r31,hi8(-(klastry))
 2463 08ea 8081      		ld r24,Z
 571:../../freeRtos/Lib/ramdysk.c ****   while (tmpKlaster != tmpKlaster2);
 2465               	.LM285:
 2466 08ec 8515      		cp r24,r5
 2467 08ee 01F4      		brne .+2
 2468 08f0 00C0      		rjmp .L179
 569:../../freeRtos/Lib/ramdysk.c ****     tmpKlaster = klastry[tmpKlaster];
 2470               	.LM286:
 2471 08f2 582E      		mov r5,r24
 2472 08f4 00C0      		rjmp .L171
 2473               	.L162:
 554:../../freeRtos/Lib/ramdysk.c ****       fputc(tmp3         , ostream);
 2475               	.LM287:
 2476 08f6 672D      		mov r22,r7
 2477 08f8 762D      		mov r23,r6
 2478 08fa 842D      		mov r24,r4
 2479 08fc 90E0      		ldi r25,0
 2480 08fe 0E94 0000 		call fputc
 2481 0902 00E0      		ldi r16,0
 2482 0904 10E0      		ldi r17,0
 2483               	.L168:
 561:../../freeRtos/Lib/ramdysk.c ****           fputc(tmp3     , ostream);
 2485               	.LM288:
 2486 0906 672D      		mov r22,r7
 2487 0908 762D      		mov r23,r6
 557:../../freeRtos/Lib/ramdysk.c ****         if (tmp3 != 0)
 2489               	.LM289:
 2490 090a 4420      		tst r4
 2491 090c 01F0      		breq .L165
 2492 090e F401      		movw r30,r8
 2493 0910 E00F      		add r30,r16
 2494 0912 F11F      		adc r31,r17
 558:../../freeRtos/Lib/ramdysk.c ****           tmp3=plik->nazwa[tmp2];
 2496               	.LM290:
 2497 0914 4580      		ldd r4,Z+5
 560:../../freeRtos/Lib/ramdysk.c ****         if (tmp3 != 0)
 2499               	.LM291:
 2500 0916 4420      		tst r4
 2501 0918 01F0      		breq .L165
 561:../../freeRtos/Lib/ramdysk.c ****           fputc(tmp3     , ostream);
 2503               	.LM292:
 2504 091a 842D      		mov r24,r4
 2505 091c 90E0      		ldi r25,0
 2506 091e 0E94 0000 		call fputc
 2507 0922 00C0      		rjmp .L166
 2508               	.L165:
 563:../../freeRtos/Lib/ramdysk.c ****           fputc(' '      , ostream);
 2510               	.LM293:
 2511 0924 80E2      		ldi r24,lo8(32)
 2512 0926 90E0      		ldi r25,0
 2513 0928 0E94 0000 		call fputc
 2514 092c 412C      		mov r4,__zero_reg__
 2515               	.L166:
 2516 092e 0F5F      		subi r16,-1
 2517 0930 1F4F      		sbci r17,-1
 555:../../freeRtos/Lib/ramdysk.c ****       for (tmp2=1; tmp2<8; tmp2++)
 2519               	.LM294:
 2520 0932 0730      		cpi r16,7
 2521 0934 1105      		cpc r17,__zero_reg__
 2522 0936 01F4      		brne .L168
 2523 0938 FE01      		movw r30,r28
 2524 093a 3D97      		sbiw r30,13
 565:../../freeRtos/Lib/ramdysk.c ****       fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
 2526               	.LM295:
 2527 093c 8081      		ld r24,Z
 2528 093e 1F92      		push __zero_reg__
 2529 0940 8F93      		push r24
 2530 0942 FE01      		movw r30,r28
 2531 0944 3E97      		sbiw r30,14
 2532 0946 2081      		ld r18,Z
 2533 0948 30E0      		ldi r19,0
 2534 094a 322F      		mov r19,r18
 2535 094c 2227      		clr r18
 2536 094e FE01      		movw r30,r28
 2537 0950 3F97      		sbiw r30,15
 2538 0952 8081      		ld r24,Z
 2539 0954 280F      		add r18,r24
 2540 0956 311D      		adc r19,__zero_reg__
 2541 0958 3F93      		push r19
 2542 095a 2F93      		push r18
 2543 095c FF92      		push r15
 2544 095e EF92      		push r14
 2545 0960 6F92      		push r6
 2546 0962 7F92      		push r7
 2547 0964 0E94 0000 		call fprintf
 2548 0968 6096      		adiw r28,16
 549:../../freeRtos/Lib/ramdysk.c ****     for (tmp=0; tmp<16; tmp++)
 2550               	.LM296:
 2551 096a 8DB7      		in r24,__SP_L__
 2552 096c 9EB7      		in r25,__SP_H__
 2553 096e 0896      		adiw r24,8
 2554 0970 0FB6      		in __tmp_reg__,__SREG__
 2555 0972 F894      		cli
 2556 0974 9EBF      		out __SP_H__,r25
 2557 0976 0FBE      		out __SREG__,__tmp_reg__
 2558 0978 8DBF      		out __SP_L__,r24
 2559 097a CA15      		cp r28,r10
 2560 097c DB05      		cpc r29,r11
 2561 097e 01F0      		breq .+2
 2562 0980 00C0      		rjmp .L170
 2563 0982 00C0      		rjmp .L169
 2564               	.L179:
 2565               	/* epilogue start */
 572:../../freeRtos/Lib/ramdysk.c **** }
 2567               	.LM297:
 2568 0984 DF91      		pop r29
 2569 0986 CF91      		pop r28
 2570 0988 1F91      		pop r17
 2571 098a 0F91      		pop r16
 2572 098c FF90      		pop r15
 2573 098e EF90      		pop r14
 2574 0990 DF90      		pop r13
 2575 0992 CF90      		pop r12
 2576 0994 BF90      		pop r11
 2577 0996 AF90      		pop r10
 2578 0998 9F90      		pop r9
 2579 099a 8F90      		pop r8
 2580 099c 7F90      		pop r7
 2581 099e 6F90      		pop r6
 2582 09a0 5F90      		pop r5
 2583 09a2 4F90      		pop r4
 2584 09a4 0895      		ret
 2589               	.Lscope21:
 2591               		.stabd	78,0,0
 2593               	.global	ramDyskLiczbaWolnychKlastrow
 2595               	ramDyskLiczbaWolnychKlastrow:
 2596               		.stabd	46,0,0
 575:../../freeRtos/Lib/ramdysk.c **** {
 2598               	.LM298:
 2599               	.LFBB22:
 2600               	/* prologue: function */
 2601               	/* frame size = 0 */
 2602               	/* stack size = 0 */
 2603               	.L__stack_usage = 0
 2604 09a6 E0E0      		ldi r30,lo8(klastry+128)
 2605 09a8 F0E0      		ldi r31,hi8(klastry+128)
 576:../../freeRtos/Lib/ramdysk.c ****   uint8_t wynik=0;
 2607               	.LM299:
 2608 09aa 80E0      		ldi r24,0
 2609               	.L183:
 579:../../freeRtos/Lib/ramdysk.c ****     if (klastry[temp] == 0)
 2611               	.LM300:
 2612 09ac 9291      		ld r25,-Z
 2613 09ae 9111      		cpse r25,__zero_reg__
 2614 09b0 00C0      		rjmp .L181
 580:../../freeRtos/Lib/ramdysk.c ****       wynik++;
 2616               	.LM301:
 2617 09b2 8F5F      		subi r24,lo8(-(1))
 2618               	.L181:
 578:../../freeRtos/Lib/ramdysk.c ****   for (temp = L_KLASTROW-1; temp > 0; temp--)
 2620               	.LM302:
 2621 09b4 90E0      		ldi r25,hi8(klastry+1)
 2622 09b6 E030      		cpi r30,lo8(klastry+1)
 2623 09b8 F907      		cpc r31,r25
 2624 09ba 01F4      		brne .L183
 2625               	/* epilogue start */
 582:../../freeRtos/Lib/ramdysk.c **** }
 2627               	.LM303:
 2628 09bc 0895      		ret
 2633               	.Lscope22:
 2635               		.stabd	78,0,0
 2641               	.global	ramDyskOtworzPlikStdIo
 2643               	ramDyskOtworzPlikStdIo:
 2644               		.stabd	46,0,0
 600:../../freeRtos/Lib/ramdysk.c **** 
 601:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags
 602:../../freeRtos/Lib/ramdysk.c **** {
 2646               	.LM304:
 2647               	.LFBB23:
 2648 09be EF92      		push r14
 2649 09c0 FF92      		push r15
 2650 09c2 0F93      		push r16
 2651 09c4 1F93      		push r17
 2652 09c6 CF93      		push r28
 2653 09c8 DF93      		push r29
 2654 09ca 1F92      		push __zero_reg__
 2655 09cc CDB7      		in r28,__SP_L__
 2656 09ce DEB7      		in r29,__SP_H__
 2657               	/* prologue: function */
 2658               	/* frame size = 1 */
 2659               	/* stack size = 7 */
 2660               	.L__stack_usage = 7
 2661 09d0 8B01      		movw r16,r22
 2662 09d2 7A01      		movw r14,r20
 603:../../freeRtos/Lib/ramdysk.c ****   uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
 2664               	.LM305:
 2665 09d4 2983      		std Y+1,r18
 2666 09d6 0E94 0000 		call ramDyskOtworzPlik
 604:../../freeRtos/Lib/ramdysk.c ****   if (wynik != 0)
 2668               	.LM306:
 2669 09da 2981      		ldd r18,Y+1
 2670 09dc 8111      		cpse r24,__zero_reg__
 2671 09de 00C0      		rjmp .L185
 605:../../freeRtos/Lib/ramdysk.c ****     return wynik;
 606:../../freeRtos/Lib/ramdysk.c ****   
 607:../../freeRtos/Lib/ramdysk.c ****   fdev_setup_stream(stream, putSTD, getSTD, flags);
 2673               	.LM307:
 2674 09e0 40E0      		ldi r20,lo8(gs(putSTD))
 2675 09e2 50E0      		ldi r21,hi8(gs(putSTD))
 2676 09e4 F701      		movw r30,r14
 2677 09e6 5187      		std Z+9,r21
 2678 09e8 4087      		std Z+8,r20
 2679 09ea 40E0      		ldi r20,lo8(gs(getSTD))
 2680 09ec 50E0      		ldi r21,hi8(gs(getSTD))
 2681 09ee 5387      		std Z+11,r21
 2682 09f0 4287      		std Z+10,r20
 2683 09f2 2383      		std Z+3,r18
 608:../../freeRtos/Lib/ramdysk.c ****   fdev_set_udata(stream, fd);
 2685               	.LM308:
 2686 09f4 1587      		std Z+13,r17
 2687 09f6 0487      		std Z+12,r16
 2688               	.L185:
 2689               	/* epilogue start */
 609:../../freeRtos/Lib/ramdysk.c ****   return 0;
 610:../../freeRtos/Lib/ramdysk.c **** }
 2691               	.LM309:
 2692 09f8 0F90      		pop __tmp_reg__
 2693 09fa DF91      		pop r29
 2694 09fc CF91      		pop r28
 2695 09fe 1F91      		pop r17
 2696 0a00 0F91      		pop r16
 2697 0a02 FF90      		pop r15
 2698 0a04 EF90      		pop r14
 2699 0a06 0895      		ret
 2704               	.Lscope23:
 2706               		.stabd	78,0,0
 2709               	.global	ramDyskZamknijPlikStdIo
 2711               	ramDyskZamknijPlikStdIo:
 2712               		.stabd	46,0,0
 611:../../freeRtos/Lib/ramdysk.c **** 
 612:../../freeRtos/Lib/ramdysk.c **** uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
 613:../../freeRtos/Lib/ramdysk.c **** {
 2714               	.LM310:
 2715               	.LFBB24:
 2716 0a08 0F93      		push r16
 2717 0a0a 1F93      		push r17
 2718 0a0c CF93      		push r28
 2719 0a0e DF93      		push r29
 2720               	/* prologue: function */
 2721               	/* frame size = 0 */
 2722               	/* stack size = 4 */
 2723               	.L__stack_usage = 4
 2724 0a10 8C01      		movw r16,r24
 614:../../freeRtos/Lib/ramdysk.c ****   struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
 2726               	.LM311:
 2727 0a12 FC01      		movw r30,r24
 2728 0a14 C485      		ldd r28,Z+12
 2729 0a16 D585      		ldd r29,Z+13
 615:../../freeRtos/Lib/ramdysk.c ****   ramDyskZamknijPlik(fd);
 2731               	.LM312:
 2732 0a18 CE01      		movw r24,r28
 2733 0a1a 0E94 0000 		call ramDyskZamknijPlik
 616:../../freeRtos/Lib/ramdysk.c ****   fclose(stream);
 2735               	.LM313:
 2736 0a1e C801      		movw r24,r16
 2737 0a20 0E94 0000 		call fclose
 617:../../freeRtos/Lib/ramdysk.c ****   return fd->wpis->lAktOtw;
 2739               	.LM314:
 2740 0a24 EC81      		ldd r30,Y+4
 2741 0a26 FD81      		ldd r31,Y+5
 618:../../freeRtos/Lib/ramdysk.c **** }
 2743               	.LM315:
 2744 0a28 8381      		ldd r24,Z+3
 2745               	/* epilogue start */
 2746 0a2a DF91      		pop r29
 2747 0a2c CF91      		pop r28
 2748 0a2e 1F91      		pop r17
 2749 0a30 0F91      		pop r16
 2750 0a32 0895      		ret
 2755               	.Lscope24:
 2757               		.stabd	78,0,0
 2758               		.comm	klastry,128,1
 2759               		.comm	czasRtc,7,1
 2760               		.comm	sockets,2,1
 2761               		.comm	tcpDebugLevel,1,1
 2762               		.comm	tcpDebugStream,2,1
 2763               		.comm	IpMyConfig,15,1
 2764               		.comm	udpDbgLevel,1,1
 2765               		.comm	udpDbgStream,2,1
 2766               		.comm	udpSocket,2,1
 2767               		.comm	icmpDebugLevel,1,1
 2768               		.comm	icmpDebug,2,1
 2769               		.comm	arpDebugLevel,1,1
 2770               		.comm	arpDebug,2,1
 2771               		.comm	plen,2,1
 2772               		.comm	nicState,14,1
 2773               		.comm	xSemaphoreRs485,2,1
 2774               		.comm	lockSensors,2,1
 2775               		.comm	portB,1,1
 2776               		.comm	portA,1,1
 2777               		.comm	xSemaphoreSpiSS,2,1
 2778               		.comm	rollers,2,1
 2779               		.comm	wwwport,1,1
 2803               	.Letext0:
 2804               		.ident	"GCC: (GNU) 4.8.2"
 2805               	.global __do_copy_data
 2806               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ramdysk.c
     /tmp/cc65cZet.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc65cZet.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc65cZet.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc65cZet.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc65cZet.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc65cZet.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc65cZet.s:275    .text:0000000000000000 uaktualnijRozmiarPliku
     /tmp/cc65cZet.s:339    .text:0000000000000044 nastepnyKlaster
                            *COM*:0000000000000080 klastry
     /tmp/cc65cZet.s:422    .text:0000000000000090 znajdzKlasterN
     /tmp/cc65cZet.s:477    .text:00000000000000bc znajdzPlik
     /tmp/cc65cZet.s:636    .text:0000000000000176 znajdzWolnyKlaster
     /tmp/cc65cZet.s:705    .text:00000000000001b6 ramDyskInit
     /tmp/cc65cZet.s:746    .text:00000000000001da ramDyskUtworzPlik
     /tmp/cc65cZet.s:925    .text:000000000000029a ramDyskOtworzPlik
     /tmp/cc65cZet.s:984    .text:00000000000002c6 ramDyskUsunPlik
     /tmp/cc65cZet.s:1068   .text:000000000000030a ramDyskZamknijPlik
     /tmp/cc65cZet.s:1109   .text:000000000000032a ramDyskCzyscPlik
     /tmp/cc65cZet.s:1193   .text:000000000000037c ramDyskZapiszBajtDoPliku
     /tmp/cc65cZet.s:1311   .text:00000000000003f8 putSTD
     /tmp/cc65cZet.s:1340   .text:0000000000000408 ramDyskCzytajBajtZPliku
     /tmp/cc65cZet.s:1453   .text:0000000000000478 getSTD
     /tmp/cc65cZet.s:1509   .text:00000000000004a8 ramDyskZapiszBlokDoPliku
     /tmp/cc65cZet.s:1735   .text:00000000000005bc ramDyskCzytajBlokZPliku
     /tmp/cc65cZet.s:2008   .text:00000000000006fa ramDyskUstawWskaznik
     /tmp/cc65cZet.s:2137   .text:0000000000000784 ramDyskUstawWskaznikNaKoniec
     /tmp/cc65cZet.s:2213   .text:00000000000007c8 ramDyskDodajBlokXmodem
     /tmp/cc65cZet.s:2383   .text:000000000000087c ramDyskDir
     /tmp/cc65cZet.s:2595   .text:00000000000009a6 ramDyskLiczbaWolnychKlastrow
     /tmp/cc65cZet.s:2643   .text:00000000000009be ramDyskOtworzPlikStdIo
     /tmp/cc65cZet.s:2711   .text:0000000000000a08 ramDyskZamknijPlikStdIo
                            *COM*:0000000000000007 czasRtc
                            *COM*:0000000000000002 sockets
                            *COM*:0000000000000001 tcpDebugLevel
                            *COM*:0000000000000002 tcpDebugStream
                            *COM*:000000000000000f IpMyConfig
                            *COM*:0000000000000001 udpDbgLevel
                            *COM*:0000000000000002 udpDbgStream
                            *COM*:0000000000000002 udpSocket
                            *COM*:0000000000000001 icmpDebugLevel
                            *COM*:0000000000000002 icmpDebug
                            *COM*:0000000000000001 arpDebugLevel
                            *COM*:0000000000000002 arpDebug
                            *COM*:0000000000000002 plen
                            *COM*:000000000000000e nicState
                            *COM*:0000000000000002 xSemaphoreRs485
                            *COM*:0000000000000002 lockSensors
                            *COM*:0000000000000001 portB
                            *COM*:0000000000000001 portA
                            *COM*:0000000000000002 xSemaphoreSpiSS
                            *COM*:0000000000000002 rollers
                            *COM*:0000000000000001 wwwport

UNDEFINED SYMBOLS
strncmp
strncpy
memcpy
fputs
fputc
fprintf
fclose
__do_copy_data
__do_clear_bss
