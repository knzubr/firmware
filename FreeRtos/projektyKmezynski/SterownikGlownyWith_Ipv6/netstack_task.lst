   1               		.file	"netstack_task.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 260               	.global	encTask
 262               	encTask:
 263               		.stabd	46,0,0
   1:netstack_task.c **** /*********************************************
   2:netstack_task.c ****  * vim:sw=8:ts=8:si:et
   3:netstack_task.c ****  * To use the above modeline in vim you must have "set modeline" in your .vimrc
   4:netstack_task.c ****  * Author: Guido Socher
   5:netstack_task.c ****  * Copyright: GPL V2
   6:netstack_task.c ****  * See http://www.gnu.org/licenses/gpl.html
   7:netstack_task.c ****  *
   8:netstack_task.c ****  * Ethernet remote device and sensor
   9:netstack_task.c ****  * UDP and HTTP interface
  10:netstack_task.c ****         url looks like this http://baseurl/password/command
  11:netstack_task.c ****         or http://baseurl/password/
  12:netstack_task.c ****  *
  13:netstack_task.c ****  * Chip type           : Atmega88 or Atmega168 or Atmega328 with ENC28J60
  14:netstack_task.c ****  * Note: there is a version number in the text. Search for tuxgraphics
  15:netstack_task.c ****  *********************************************/
  16:netstack_task.c **** #include "netstack_task.h"
  17:netstack_task.c **** 
  18:netstack_task.c **** 
  19:netstack_task.c **** /*uint16_t printHTMLstatus(char *buf, uint16_t pos, uint16_t maxPos)
  20:netstack_task.c **** {*/
  21:netstack_task.c **** /*  char *tmpPtr;
  22:netstack_task.c **** 
  23:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ( "<head><meta http-equiv=\"Content-Type\" con
  24:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ( "<h3>Status</h3>"));
  25:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("<p>"SYSTEM_NAME" ver <b>"S_VERSION"</b> buil
  26:netstack_task.c ****   
  27:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("<p><table border=1>"));
  28:netstack_task.c **** 
  29:netstack_task.c ****   tmpPtr = getBufPosToWrite(buf, pos);
  30:netstack_task.c ****   pos +=sprintf_P(tmpPtr, PSTR("<tr><td>Temperatura</td><td>%d C</td></tr>"), temperature);
  31:netstack_task.c ****   tmpPtr = getBufPosToWrite(buf, pos);
  32:netstack_task.c ****   pos +=sprintf_P(tmpPtr, PSTR("<tr><td>Napięcie na magistrali</td><td>%d V</td></tr>"), voltage);
  33:netstack_task.c **** 
  34:netstack_task.c ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
  35:netstack_task.c ****   tmpPtr = getBufPosToWrite(buf, pos);
  36:netstack_task.c ****   pos +=sprintf_P(tmpPtr, PSTR("<tr><td>Liczba wolnych klastrów</td><td>%d / %d</td></tr>"), tmp, 
  37:netstack_task.c **** 
  38:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("</table></p>"));
  39:netstack_task.c **** 
  40:netstack_task.c ****   tmpPtr = getBufPosToWrite(buf, pos);
  41:netstack_task.c ****   
  42:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR("<h3>Czujniki rygli</h3>"));
  43:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("<p><table border=1>"));
  44:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("<tr><td>Czujnik nr</td><td>Położenie rygla
  45:netstack_task.c ****   for (tmp = 0; tmp < 4; tmp++)
  46:netstack_task.c ****   {
  47:netstack_task.c ****     if (lockSensors[tmp].enabled)
  48:netstack_task.c ****     {
  49:netstack_task.c ****       tmpPtr = getBufPosToWrite(buf, pos);
  50:netstack_task.c ****       pos +=sprintf_P(tmpPtr, PSTR("<tr align=\"center\"><td>%d</td>"), tmp+1);
  51:netstack_task.c ****       if (lockSensors[tmp].locked)
  52:netstack_task.c ****         pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("<td>zamknięty</td>"));
  53:netstack_task.c ****       else
  54:netstack_task.c ****         pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("<td>otwarty</td>"));
  55:netstack_task.c **** 
  56:netstack_task.c ****       tmpPtr = getBufPosToWrite(buf, pos);
  57:netstack_task.c ****       pos +=sprintf_P(tmpPtr, PSTR("<td>%d</td><td>%d</td>"), lockSensors[tmp].acVal, lockSensors[t
  58:netstack_task.c ****       pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("</tr>"));
  59:netstack_task.c ****     }
  60:netstack_task.c ****   }
  61:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR ("</table></p>"));
  62:netstack_task.c **** 
  63:netstack_task.c ****   pos=fill_tcp_data_p(Enc28j60_global.buf, pos, PSTR("<h3>Moduły wykonawcze</h3>"));
  64:netstack_task.c ****   return pos;*/
  65:netstack_task.c **** //   return 0;
  66:netstack_task.c **** // }
  67:netstack_task.c **** 
  68:netstack_task.c **** 
  69:netstack_task.c **** void encTask ( void *pvParameters )
  70:netstack_task.c **** {
 265               	.LM0:
 266               	.LFBB1:
 267 0000 CF92      		push r12
 268 0002 DF92      		push r13
 269 0004 EF92      		push r14
 270 0006 FF92      		push r15
 271 0008 0F93      		push r16
 272 000a 1F93      		push r17
 273 000c CF93      		push r28
 274 000e DF93      		push r29
 275               	/* prologue: function */
 276               	/* frame size = 0 */
  71:netstack_task.c ****   FILE *netstackDebug = (FILE *) pvParameters;
 278               	.LM1:
 279 0010 EC01      		movw r28,r24
  72:netstack_task.c ****   uint16_t plen;
  73:netstack_task.c ****   #ifdef DEBUG_PRINT_NET_PACKET
  74:netstack_task.c ****   uint16_t packetNo = 0;
  75:netstack_task.c ****   #endif /*DEBUG_PRINT_NET_PACKET*/
  76:netstack_task.c **** 
  77:netstack_task.c ****   nicInit();
 281               	.LM2:
 282 0012 0E94 0000 		call nicInit
  78:netstack_task.c ****   ipInit();
 284               	.LM3:
 285 0016 0E94 0000 		call ipInit
  79:netstack_task.c ****   arpInit();
 287               	.LM4:
 288 001a 0E94 0000 		call arpInit
  80:netstack_task.c ****   icmpInit();
 290               	.LM5:
 291 001e 0E94 0000 		call icmpInit
  81:netstack_task.c ****   #ifdef IP_DEBUG
  82:netstack_task.c ****     #if IPV6_SUPPORT
  83:netstack_task.c ****     ipv6DebugInit(netstackDebug);
 293               	.LM6:
 294 0022 CE01      		movw r24,r28
 295 0024 0E94 0000 		call ipv6DebugInit
  84:netstack_task.c ****     #endif /*IPV6_SUPPORT*/
  85:netstack_task.c ****   fprintf_P(netstackDebug, PSTR("IP stack ready \r\n"));
 297               	.LM7:
 298 0028 00D0      		rcall .
 299 002a 00D0      		rcall .
 300 002c EDB7      		in r30,__SP_L__
 301 002e FEB7      		in r31,__SP_H__
 302 0030 D283      		std Z+2,r29
 303 0032 C183      		std Z+1,r28
 304 0034 80E0      		ldi r24,lo8(__c.3026)
 305 0036 90E0      		ldi r25,hi8(__c.3026)
 306 0038 9483      		std Z+4,r25
 307 003a 8383      		std Z+3,r24
 308 003c 0E94 0000 		call fprintf_P
  86:netstack_task.c ****   #endif /*IP_DEBUG*/
  87:netstack_task.c ****   #if IPV6_SUPPORT
  88:netstack_task.c ****   ipv6Init();
 310               	.LM8:
 311 0040 0F90      		pop __tmp_reg__
 312 0042 0F90      		pop __tmp_reg__
 313 0044 0F90      		pop __tmp_reg__
 314 0046 0F90      		pop __tmp_reg__
 315 0048 0E94 0000 		call ipv6Init
  89:netstack_task.c ****   #endif /*IPV6_SUPPORT*/
  90:netstack_task.c ****   
  91:netstack_task.c ****   //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);
  92:netstack_task.c ****   
  93:netstack_task.c ****   
  94:netstack_task.c ****   for ( ; ; )
  95:netstack_task.c ****   {
  96:netstack_task.c ****     vTaskDelay ( 0 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwo
  97:netstack_task.c ****         
  98:netstack_task.c ****     // get the next new packet:
  99:netstack_task.c ****     plen = nicPoll();
 100:netstack_task.c ****     /*plen will ne unequal to zero if there is a valid
 101:netstack_task.c ****     * packet (without crc error) */
 102:netstack_task.c ****     if ( plen==0 )
 103:netstack_task.c ****     {
 104:netstack_task.c ****       flushUdpQueues();
 105:netstack_task.c ****       flushTcpQueues();
 106:netstack_task.c ****       //flush HTTP long file queue 
 107:netstack_task.c ****       continue;
 108:netstack_task.c ****     }
 109:netstack_task.c ****     #if DEBUG_PRINT_NET_PACKET
 110:netstack_task.c ****     packetNo++;
 111:netstack_task.c ****     fprintf_P(netstackDebug, PSTR("Packet in, length=%d, packetNo: %d\r\n"), plen, packetNo);    
 112:netstack_task.c ****     for (uint8_t i=0; i < plen; i++)
 113:netstack_task.c ****     {
 114:netstack_task.c ****       if (i!=0 && i%16==0) fprintf_P(netstackDebug, PSTR("\r\n"));
 115:netstack_task.c ****       fprintf_P(netstackDebug, PSTR("%02x:"), nicState.layer2.buf[i]);
 116:netstack_task.c ****     }
 117:netstack_task.c ****     fprintf_P(netstackDebug, PSTR("\r\n"));    
 118:netstack_task.c ****     #endif /*DEBUG_PRINT_NET_PACKET*/
 119:netstack_task.c ****     
 120:netstack_task.c ****     if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
 121:netstack_task.c ****     {
 122:netstack_task.c ****       arpIpIn();
 123:netstack_task.c ****       netstackIPv4Process();
 124:netstack_task.c ****     }
 125:netstack_task.c ****     else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
 126:netstack_task.c ****     {
 127:netstack_task.c ****       arpArpIn();
 128:netstack_task.c ****     }
 129:netstack_task.c ****     #if IPV6_SUPPORT
 130:netstack_task.c ****     else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP6))       // process an ARP packet
 131:netstack_task.c ****     {
 132:netstack_task.c ****       netstackIPv6Process();
 133:netstack_task.c ****     }
 134:netstack_task.c ****     #endif /*IPV6_SUPPORT*/
 135:netstack_task.c ****     else
 136:netstack_task.c ****     {
 137:netstack_task.c ****       if (netstackDebug != NULL)
 138:netstack_task.c ****       {
 139:netstack_task.c ****         fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
 140:netstack_task.c ****       }
 141:netstack_task.c ****     }
 142:netstack_task.c ****     
 143:netstack_task.c ****     #ifdef IP_DEBUG
 144:netstack_task.c ****     fprintf_P(netstackDebug, PSTR("==============================\r\n"));
 317               	.LM9:
 318 004c 90E0      		ldi r25,lo8(__c.3031)
 319 004e C92E      		mov r12,r25
 320 0050 90E0      		ldi r25,hi8(__c.3031)
 321 0052 D92E      		mov r13,r25
 139:netstack_task.c ****         fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
 323               	.LM10:
 324 0054 80E0      		ldi r24,lo8(__c.3029)
 325 0056 E82E      		mov r14,r24
 326 0058 80E0      		ldi r24,hi8(__c.3029)
 327 005a F82E      		mov r15,r24
 328               	.L9:
  96:netstack_task.c ****     vTaskDelay ( 0 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwo
 330               	.LM11:
 331 005c 80E0      		ldi r24,lo8(0)
 332 005e 90E0      		ldi r25,hi8(0)
 333 0060 0E94 0000 		call vTaskDelay
  99:netstack_task.c ****     plen = nicPoll();
 335               	.LM12:
 336 0064 0E94 0000 		call nicPoll
 102:netstack_task.c ****     if ( plen==0 )
 338               	.LM13:
 339 0068 892B      		or r24,r25
 340 006a 01F4      		brne .L2
 104:netstack_task.c ****       flushUdpQueues();
 342               	.LM14:
 343 006c 0E94 0000 		call flushUdpQueues
 105:netstack_task.c ****       flushTcpQueues();
 345               	.LM15:
 346 0070 0E94 0000 		call flushTcpQueues
 347 0074 00C0      		rjmp .L9
 348               	.L2:
 120:netstack_task.c ****     if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
 350               	.LM16:
 351 0076 E091 0000 		lds r30,nicState+8
 352 007a F091 0000 		lds r31,(nicState+8)+1
 353 007e 0485      		ldd r16,Z+12
 354 0080 1585      		ldd r17,Z+13
 355 0082 80E0      		ldi r24,lo8(2048)
 356 0084 98E0      		ldi r25,hi8(2048)
 357 0086 0E94 0000 		call htons
 358 008a 0817      		cp r16,r24
 359 008c 1907      		cpc r17,r25
 360 008e 01F4      		brne .L4
 122:netstack_task.c ****       arpIpIn();
 362               	.LM17:
 363 0090 0E94 0000 		call arpIpIn
 123:netstack_task.c ****       netstackIPv4Process();
 365               	.LM18:
 366 0094 0E94 0000 		call netstackIPv4Process
 367 0098 00C0      		rjmp .L5
 368               	.L4:
 125:netstack_task.c ****     else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
 370               	.LM19:
 371 009a E091 0000 		lds r30,nicState+8
 372 009e F091 0000 		lds r31,(nicState+8)+1
 373 00a2 0485      		ldd r16,Z+12
 374 00a4 1585      		ldd r17,Z+13
 375 00a6 86E0      		ldi r24,lo8(2054)
 376 00a8 98E0      		ldi r25,hi8(2054)
 377 00aa 0E94 0000 		call htons
 378 00ae 0817      		cp r16,r24
 379 00b0 1907      		cpc r17,r25
 380 00b2 01F4      		brne .L6
 127:netstack_task.c ****       arpArpIn();
 382               	.LM20:
 383 00b4 0E94 0000 		call arpArpIn
 384 00b8 00C0      		rjmp .L5
 385               	.L6:
 130:netstack_task.c ****     else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP6))       // process an ARP packet
 387               	.LM21:
 388 00ba E091 0000 		lds r30,nicState+8
 389 00be F091 0000 		lds r31,(nicState+8)+1
 390 00c2 0485      		ldd r16,Z+12
 391 00c4 1585      		ldd r17,Z+13
 392 00c6 8DED      		ldi r24,lo8(-31011)
 393 00c8 96E8      		ldi r25,hi8(-31011)
 394 00ca 0E94 0000 		call htons
 395 00ce 0817      		cp r16,r24
 396 00d0 1907      		cpc r17,r25
 397 00d2 01F4      		brne .L7
 132:netstack_task.c ****       netstackIPv6Process();
 399               	.LM22:
 400 00d4 0E94 0000 		call netstackIPv6Process
 401 00d8 00C0      		rjmp .L5
 402               	.L7:
 137:netstack_task.c ****       if (netstackDebug != NULL)
 404               	.LM23:
 405 00da 2097      		sbiw r28,0
 406 00dc 01F0      		breq .L5
 139:netstack_task.c ****         fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
 408               	.LM24:
 409 00de 00D0      		rcall .
 410 00e0 00D0      		rcall .
 411 00e2 EDB7      		in r30,__SP_L__
 412 00e4 FEB7      		in r31,__SP_H__
 413 00e6 D283      		std Z+2,r29
 414 00e8 C183      		std Z+1,r28
 415 00ea F482      		std Z+4,r15
 416 00ec E382      		std Z+3,r14
 417 00ee 0E94 0000 		call fprintf_P
 418 00f2 0F90      		pop __tmp_reg__
 419 00f4 0F90      		pop __tmp_reg__
 420 00f6 0F90      		pop __tmp_reg__
 421 00f8 0F90      		pop __tmp_reg__
 422               	.L5:
 424               	.LM25:
 425 00fa 00D0      		rcall .
 426 00fc 00D0      		rcall .
 427 00fe EDB7      		in r30,__SP_L__
 428 0100 FEB7      		in r31,__SP_H__
 429 0102 D283      		std Z+2,r29
 430 0104 C183      		std Z+1,r28
 431 0106 D482      		std Z+4,r13
 432 0108 C382      		std Z+3,r12
 433 010a 0E94 0000 		call fprintf_P
 434 010e 0F90      		pop __tmp_reg__
 435 0110 0F90      		pop __tmp_reg__
 436 0112 0F90      		pop __tmp_reg__
 437 0114 0F90      		pop __tmp_reg__
 438 0116 00C0      		rjmp .L9
 440               	.Lscope1:
 442               		.stabd	78,0,0
 443               		.section	.progmem.data,"a",@progbits
 446               	__c.3031:
 447 0000 3D3D 3D3D 		.string	"==============================\r\n"
 447      3D3D 3D3D 
 447      3D3D 3D3D 
 447      3D3D 3D3D 
 447      3D3D 3D3D 
 450               	__c.3029:
 451 0021 556E 6B6E 		.string	"Unknown packet\r\n"
 451      6F77 6E20 
 451      7061 636B 
 451      6574 0D0A 
 451      00
 454               	__c.3026:
 455 0032 4950 2073 		.string	"IP stack ready \r\n"
 455      7461 636B 
 455      2072 6561 
 455      6479 200D 
 455      0A00 
 456               		.comm klastry,128,1
 457               		.comm wwwport,1,1
 458               		.comm rollers,2,1
 459               		.comm xSemaphoreSpiSS,2,1
 460               		.comm portA,1,1
 461               		.comm portB,1,1
 462               		.comm lockSensors,2,1
 463               		.comm xSemaphoreRs485,2,1
 464               		.comm nicState,14,1
 465               		.comm IpMyConfig,15,1
 466               		.comm arpDebug,2,1
 467               		.comm arpDebugLevel,1,1
 468               		.comm icmpDebug,2,1
 469               		.comm icmpDebugLevel,1,1
 470               		.comm udpSocket,2,1
 471               		.comm udpDbgStream,2,1
 472               		.comm udpDbgLevel,1,1
 473               		.comm tcpDebugStream,2,1
 474               		.comm tcpDebugLevel,1,1
 475               		.comm sockets,2,1
 476               		.comm czasRtc,7,1
 477               		.comm Ipv6MyConfig,5,1
 478               		.comm debugStream,2,1
 505               		.weak	nicPoll
 506               		.text
 508               	.Letext0:
 509               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 netstack_task.c
     /tmp/ccR7pkAB.s:2      *ABS*:0000003f __SREG__
     /tmp/ccR7pkAB.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccR7pkAB.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccR7pkAB.s:5      *ABS*:00000034 __CCP__
     /tmp/ccR7pkAB.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccR7pkAB.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccR7pkAB.s:262    .text:00000000 encTask
     /tmp/ccR7pkAB.s:454    .progmem.data:00000032 __c.3026
     /tmp/ccR7pkAB.s:446    .progmem.data:00000000 __c.3031
     /tmp/ccR7pkAB.s:450    .progmem.data:00000021 __c.3029
                            *COM*:0000000e nicState
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpSocket
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000007 czasRtc
                            *COM*:00000005 Ipv6MyConfig
                            *COM*:00000002 debugStream

UNDEFINED SYMBOLS
nicInit
ipInit
arpInit
icmpInit
ipv6DebugInit
fprintf_P
ipv6Init
vTaskDelay
nicPoll
flushUdpQueues
flushTcpQueues
htons
arpIpIn
netstackIPv4Process
arpArpIn
netstackIPv6Process
__do_clear_bss
