
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000088  00800100  0000f198  0000f24c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000f198  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000e79  00800188  00800188  0000f2d4  2**0
                  ALLOC
  3 .eeprom       00000032  00810000  00810000  0000f2d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         0001f260  00000000  00000000  0000f308  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0001010d  00000000  00000000  0002e568  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a0 0f 	jmp	0x1f40	; 0x1f40 <__ctors_end>
       4:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
       8:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
       c:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      10:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      14:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      18:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      1c:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      20:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      24:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      28:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      2c:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      30:	0c 94 fe 70 	jmp	0xe1fc	; 0xe1fc <__vector_12>
      34:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      38:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      3c:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      40:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      44:	0c 94 dc 12 	jmp	0x25b8	; 0x25b8 <__vector_17>
      48:	0c 94 b1 11 	jmp	0x2362	; 0x2362 <__vector_18>
      4c:	0c 94 e5 10 	jmp	0x21ca	; 0x21ca <__vector_19>
      50:	0c 94 88 10 	jmp	0x2110	; 0x2110 <__vector_20>
      54:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      58:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      5c:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      60:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      64:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      68:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      6c:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      70:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      74:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      78:	0c 94 6c 11 	jmp	0x22d8	; 0x22d8 <__vector_30>
      7c:	0c 94 a1 10 	jmp	0x2142	; 0x2142 <__vector_31>
      80:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      84:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>
      88:	0c 94 c5 0f 	jmp	0x1f8a	; 0x1f8a <__bad_interrupt>

0000008c <statusLockerSensDescStr>:
      8c:	20 6c 6f 63 6b 65 72 20 25 64 00                     locker %d.

00000097 <statusLockerOpenStr>:
      97:	20 6f 70 65 6e 20 20 20 00                           open   .

000000a0 <statusLockerCloseStr>:
      a0:	20 6c 6f 63 6b 65 64 20 00                           locked .

000000a9 <statusLockerSensAdditionalDescStr>:
      a9:	20 28 74 68 72 65 73 68 6f 6c 64 20 25 64 2c 20      (threshold %d, 
      b9:	41 43 20 76 61 6c 75 65 20 25 64 29 0d 0a 00        AC value %d)...

000000c8 <errorOK>:
      c8:	41 6c 6c 20 4f 4b 0d 0a 00                          All OK...

000000d1 <errorNoFile>:
      d1:	4e 6f 20 46 69 6c 65 0d 0a 00                       No File...

000000db <errorxModemFrameStartTimeout>:
      db:	0d 0a 00                                            ...

000000de <errorxModemByteSendTimeout>:
      de:	0d 0a 00                                            ...

000000e1 <errorxModemWrongFrameNo>:
      e1:	0d 0a 00                                            ...

000000e4 <errorxModemFrameFrameNoCorrectionNotMatch>:
      e4:	0d 0a 00                                            ...

000000e7 <errorxModemFrameCrc>:
      e7:	78 4d 6f 64 65 6d 20 43 52 43 20 65 72 72 6f 72     xModem CRC error
      f7:	0d 0a 00                                            ...

000000fa <errorxModemRemoteSideCan>:
      fa:	52 65 6d 6f 74 65 20 73 69 64 65 20 63 61 6e 63     Remote side canc
     10a:	65 6c 6c 65 64 20 61 74 20 66 72 61 6d 65 20 6e     elled at frame n
     11a:	6f 20 25 64 0d 0a 00                                o %d...

00000121 <errorxModemUnknownResponse>:
     121:	78 4d 6f 64 65 6d 20 75 6e 6b 6e 6f 77 6e 20 72     xModem unknown r
     131:	65 73 70 6f 6e 73 65 20 30 78 25 78 0d 0a 00        esponse 0x%x...

00000140 <errorNoRemoteDevice>:
     140:	44 65 76 69 63 65 20 25 64 20 69 73 20 6e 6f 74     Device %d is not
     150:	20 72 65 73 70 6f 6e 64 69 6e 67 20 28 25 64 29      responding (%d)
     160:	0d 0a 00                                            ...

00000163 <errorBootloaderNotResponding>:
     163:	42 6f 6f 74 6c 6f 61 64 65 72 20 69 73 20 6e 6f     Bootloader is no
     173:	74 20 72 65 73 70 6f 6e 64 69 6e 67 0d 0a 00        t responding...

00000182 <errorOpenFile>:
     182:	43 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 20     Can't open file 
     192:	25 73 0d 0a 00                                      %s...

00000197 <systemStateStr>:
     197:	53 79 73 74 65 6d 20 73 74 61 74 65 3a 0d 0a 00     System state:...

000001a7 <statusNumberOfTasksStr>:
     1a7:	20 20 4e 75 6d 62 65 72 20 6f 66 20 74 61 73 6b       Number of task
     1b7:	73 20 3a 20 25 64 0d 0a 00                          s : %d...

000001c0 <statusStaticHeapStateStr>:
     1c0:	20 20 46 72 65 65 52 74 6f 73 20 68 65 61 70 20       FreeRtos heap 
     1d0:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     1e0:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

000001ea <statusDynamicHeapStateStr>:
     1ea:	20 20 4d 61 6c 6c 6f 63 20 68 65 61 70 20 20 20       Malloc heap   
     1fa:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     20a:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000214 <statusRamDiskStateStr>:
     214:	20 20 52 61 6d 20 64 69 73 63 20 73 70 61 63 65       Ram disc space
     224:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     234:	64 20 63 6c 75 73 74 65 72 73 0d 0a 00              d clusters...

00000241 <statusTemperatureStr>:
     241:	20 20 54 65 6d 70 65 72 61 74 75 72 65 20 20 20       Temperature   
     251:	20 20 3a 20 25 64 20 43 0d 0a 00                      : %d C...

0000025c <statusVoltageStr>:
     25c:	20 20 56 6f 6c 74 61 67 65 20 20 20 20 20 20 20       Voltage       
     26c:	20 20 3a 20 25 64 20 56 0d 0a 00                      : %d V...

00000277 <systemRamConfigStr>:
     277:	53 79 73 74 65 6d 20 73 65 74 74 69 6e 67 73 3a     System settings:
     287:	0d 0a 00                                            ...

0000028a <statusMacStr>:
     28a:	20 20 4d 61 63 20 61 64 64 72 65 73 73 20 20 20       Mac address   
     29a:	20 20 3a 20 00                                        : .

0000029f <statusIpStr>:
     29f:	20 20 49 50 20 61 64 64 72 65 73 73 20 20 20 20       IP address    
     2af:	20 20 3a 20 00                                        : .

000002b4 <statusIpMaskStr>:
     2b4:	20 20 6d 61 73 6b 20 20 20 20 20 20 20 20 20 20       mask          
     2c4:	20 20 3a 20 00                                        : .

000002c9 <statusIpGwStr>:
     2c9:	20 20 67 61 74 65 77 61 79 20 20 20 20 20 20 20       gateway       
     2d9:	20 20 3a 20 00                                        : .

000002de <statusRs485listStr>:
     2de:	44 65 74 65 63 74 65 64 20 52 53 20 34 38 35 20     Detected RS 485 
     2ee:	64 65 76 69 63 65 73 3a 0d 0a 00                    devices:...

000002f9 <statusNoRs485Dev>:
     2f9:	20 20 43 61 6e 27 74 20 66 69 6e 64 20 61 6e 79       Can't find any
     309:	20 64 65 76 69 63 65 0d 0a 00                        device...

00000313 <statusLockerSensorsStr>:
     313:	4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73 20 73     Locker sensors s
     323:	74 61 74 65 73 3a 0d 0a 00                          tates:...

0000032c <statusLockerSensorsDisStr>:
     32c:	20 20 4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73       Locker sensors
     33c:	20 64 69 73 61 62 6c 65 64 0d 0a 00                  disabled...

00000348 <editRamFileIntroStr>:
     348:	57 72 69 74 69 6e 67 20 74 6f 20 66 69 6c 65 2e     Writing to file.
     358:	20 50 72 65 73 73 20 43 54 52 4c 2b 43 20 74 6f      Press CTRL+C to
     368:	20 71 75 69 74 0d 0a 00                              quit...

00000370 <readRamFIleLenStr>:
     370:	46 69 6c 65 20 6c 65 6e 67 74 68 3a 20 25 64 0d     File length: %d.
     380:	0a 00                                               ..

00000382 <xwyslijStartStr>:
     382:	58 6d 6f 64 65 6d 3a 20 54 72 61 6e 73 6d 69 73     Xmodem: Transmis
     392:	73 69 6f 6e 20 73 74 61 72 74 0d 0a 00              sion start...

0000039f <movingCurtainUpStr>:
     39f:	50 6f 64 6e 6f 73 7a 65 6e 69 65 20 72 6f 6c 65     Podnoszenie role
     3af:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     3bf:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     3cf:	0d 0a 00                                            ...

000003d2 <movingCurtainDownStr>:
     3d2:	4f 70 75 73 7a 63 7a 61 6e 69 65 20 72 6f 6c 65     Opuszczanie role
     3e2:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     3f2:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     402:	0d 0a 00                                            ...

00000405 <movingCurtainPosStr>:
     405:	09 70 6f 7a 79 63 6a 61 20 20 20 25 64 0d 0a 00     .pozycja   %d...

00000415 <debugEnabledInfoStr>:
     415:	45 6e 61 62 6c 65 64 20 25 73 20 64 65 62 75 67     Enabled %s debug
     425:	0d 0a 00                                            ...

00000428 <debugDisabledInfoStr>:
     428:	44 69 73 61 62 6c 65 64 20 25 73 20 64 65 62 75     Disabled %s debu
     438:	67 0d 0a 00                                         g...

0000043c <cmd_help>:
     43c:	68 65 6c 70 00                                      help.

00000441 <cmd_help_help>:
     441:	50 72 69 6e 74 20 68 65 6c 70 20 73 74 72 69 6e     Print help strin
     451:	67 00                                               g.

00000453 <cmd_status>:
     453:	73 74 61 74 75 73 00                                status.

0000045a <cmd_help_status>:
     45a:	7b 66 69 6c 65 6e 61 6d 65 7d 20 50 72 69 6e 74     {filename} Print
     46a:	20 64 65 76 69 63 65 20 73 74 61 74 75 73 20 6f      device status o
     47a:	6e 20 56 54 59 20 6f 72 20 77 72 69 74 65 20 74     n VTY or write t
     48a:	6f 20 66 69 6c 65 00                                o file.

00000491 <cmd_enc_stat>:
     491:	65 6e 63 73 74 61 74 00                             encstat.

00000499 <cmd_help_enc_stat>:
     499:	50 72 69 6e 74 20 45 6e 63 20 32 38 6a 36 30 20     Print Enc 28j60 
     4a9:	72 65 67 69 73 74 65 72 73 00                       registers.

000004b3 <cmd_time>:
     4b3:	74 69 6d 65 00                                      time.

000004b8 <cmd_help_time>:
     4b8:	50 72 69 6e 74 20 74 69 6d 65 00                    Print time.

000004c3 <cmd_net_dbg>:
     4c3:	64 65 62 75 67 00                                   debug.

000004c9 <cmd_help_net_dbg>:
     4c9:	5b 61 72 70 7c 69 63 6d 70 7c 69 70 7c 74 63 70     [arp|icmp|ip|tcp
     4d9:	7c 75 64 70 5d 20 5b 6c 65 76 65 6c 5d 20 77 72     |udp] [level] wr
     4e9:	69 74 65 20 64 65 62 75 67 20 69 6e 66 6f 2e 20     ite debug info. 
     4f9:	4c 65 76 65 6c 20 30 20 64 69 73 61 62 6c 65 20     Level 0 disable 
     509:	64 65 62 75 67 69 6e 67 00                          debuging.

00000512 <cmd_rping>:
     512:	72 70 69 6e 67 00                                   rping.

00000518 <cmd_help_rping>:
     518:	5b 44 65 76 69 63 65 20 6e 6f 5d 20 53 65 6e 64     [Device no] Send
     528:	20 70 69 6e 67 20 74 6f 20 52 73 34 38 35 20 64      ping to Rs485 d
     538:	65 76 69 63 65 00                                   evice.

0000053e <cmd_ping>:
     53e:	70 69 6e 67 00                                      ping.

00000543 <cmd_help_ping>:
     543:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     553:	41 34 5d 20 53 65 6e 64 73 20 70 69 6e 67 20 74     A4] Sends ping t
     563:	68 72 6f 75 67 68 74 20 65 74 68 65 72 6e 65 74     hrought ethernet
	...

00000574 <cmd_xRec>:
     574:	78 72 65 63 00                                      xrec.

00000579 <cmd_help_xRec>:
     579:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 63 65     [file name] rece
     589:	69 76 65 20 66 69 6c 65 20 75 73 69 6e 67 20 78     ive file using x
     599:	4d 6f 64 65 6d 00                                   Modem.

0000059f <cmd_xSend>:
     59f:	78 73 65 6e 64 00                                   xsend.

000005a5 <cmd_help_xSend>:
     5a5:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 73 65 6e 64     [file name] send
     5b5:	20 66 69 6c 65 20 75 73 69 6e 67 20 78 4d 6f 64      file using xMod
     5c5:	65 6d 00                                            em.

000005c8 <cmd_xflash>:
     5c8:	78 66 6c 61 73 68 00                                xflash.

000005cf <cmd_help_xflash>:
     5cf:	5b 64 65 76 69 63 65 20 6e 6f 5d 20 5b 66 69 6c     [device no] [fil
     5df:	65 20 6e 61 6d 65 5d 20 66 6c 61 73 68 20 64 65     e name] flash de
     5ef:	76 69 63 65 20 63 6f 6e 6e 65 63 74 65 64 20 74     vice connected t
     5ff:	6f 20 52 73 34 38 35 00                             o Rs485.

00000607 <cmd_dir_rf>:
     607:	64 69 72 72 66 00                                   dirrf.

0000060d <cmd_help_dir_rf>:
     60d:	50 72 69 6e 74 20 72 61 6d 64 69 73 6b 20 66 69     Print ramdisk fi
     61d:	6c 65 73 00                                         les.

00000621 <cmd_create_rf>:
     621:	63 72 66 00                                         crf.

00000625 <cmd_help_create_rf>:
     625:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 63 72 65 61     [file name] crea
     635:	74 65 20 72 61 6d 20 66 69 6c 65 00                 te ram file.

00000641 <cmd_erase_rf>:
     641:	65 72 61 73 65 72 66 00                             eraserf.

00000649 <cmd_help_erase_rf>:
     649:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 72 61 73     [file name] eras
     659:	65 20 66 69 6c 65 20 66 72 6f 6d 20 72 61 6d 20     e file from ram 
     669:	64 69 73 6b 00                                      disk.

0000066e <cmd_edit_rf>:
     66e:	65 64 69 74 72 66 00                                editrf.

00000675 <cmd_help_edit_rf>:
     675:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 64 69 74     [file name] edit
     685:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     695:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

0000069f <cmd_read_rf>:
     69f:	72 65 61 64 72 66 00                                readrf.

000006a6 <cmd_help_read_rf>:
     6a6:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 61 64     [file name] read
     6b6:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     6c6:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

000006d0 <cmd_up>:
     6d0:	75 70 00                                            up.

000006d3 <cmd_help_up>:
     6d3:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     6e3:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     6f3:	76 65 20 75 70 00                                   ve up.

000006f9 <cmd_down>:
     6f9:	64 6f 77 6e 00                                      down.

000006fe <cmd_help_down>:
     6fe:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     70e:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     71e:	76 65 20 64 6f 77 6e 00                             ve down.

00000726 <cmd_spa>:
     726:	73 70 61 00                                         spa.

0000072a <cmd_help_spa>:
     72a:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     73a:	20 41 00                                             A.

0000073d <cmd_spb>:
     73d:	73 70 62 00                                         spb.

00000741 <cmd_help_spb>:
     741:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     751:	20 42 00                                             B.

00000754 <cmd_settime>:
     754:	73 65 74 74 69 6d 65 00                             settime.

0000075c <cmd_help_settime>:
     75c:	5b 68 5d 20 5b 6d 5d 20 5b 73 5d 20 73 65 74 20     [h] [m] [s] set 
     76c:	74 69 6d 65 20 28 32 34 68 20 66 6f 72 6d 61 74     time (24h format
     77c:	29 00                                               ).

0000077e <cmd_ac>:
     77e:	61 63 00                                            ac.

00000781 <cmd_help_ac>:
     781:	5b 63 68 61 6e 6e 65 6c 20 30 2d 37 5d 20 72 65     [channel 0-7] re
     791:	61 64 20 61 6e 61 6c 6f 67 20 76 61 6c 75 65 00     ad analog value.

000007a1 <cmd_enable>:
     7a1:	65 6e 61 62 6c 65 00                                enable.

000007a8 <cmd_help_enable>:
     7a8:	45 6e 61 62 6c 65 20 6d 6f 64 65 00                 Enable mode.

000007b4 <cmd_disable>:
     7b4:	64 69 73 61 62 6c 65 00                             disable.

000007bc <cmd_help_disable>:
     7bc:	56 69 65 77 20 6d 6f 64 65 00                       View mode.

000007c6 <cmd_configure>:
     7c6:	63 6f 6e 66 69 67 00                                config.

000007cd <cmd_help_configure>:
     7cd:	43 6f 6e 66 69 67 75 72 65 20 6d 6f 64 65 00        Configure mode.

000007dc <cmd_conf_ip>:
     7dc:	69 70 00                                            ip.

000007df <cmd_help_conf_ip>:
     7df:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     7ef:	41 34 5d 20 73 65 74 20 49 50 20 61 64 64 72 65     A4] set IP addre
     7ff:	73 73 00                                            ss.

00000802 <cmd_conf_udp>:
     802:	75 64 70 00                                         udp.

00000806 <cmd_help_conf_udp>:
     806:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     816:	41 34 5d 20 5b 73 72 63 20 70 6f 72 74 5d 20 7b     A4] [src port] {
     826:	64 73 74 20 70 6f 72 74 7d 20 73 65 74 20 75 64     dst port} set ud
     836:	70 20 63 6c 69 65 6e 74 20 49 50 20 61 64 64 72     p client IP addr
     846:	65 73 73 20 61 6e 64 20 70 6f 72 74 73 00           ess and ports.

00000854 <cmd_conf_ip_mask>:
     854:	6d 61 73 6b 00                                      mask.

00000859 <cmd_conf_ip_mask_help>:
     859:	5b 6d 61 73 6b 5d 20 73 65 74 20 6d 61 73 6b 00     [mask] set mask.

00000869 <cmd_conf_ip_gw>:
     869:	67 77 00                                            gw.

0000086c <cmd_conf_ip_gw_help>:
     86c:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     87c:	41 34 5d 20 73 65 74 20 64 65 66 61 75 6c 74 20     A4] set default 
     88c:	67 61 74 65 77 61 79 00                             gateway.

00000894 <cmd_conf_mac>:
     894:	6d 61 63 00                                         mac.

00000898 <cmd_help_conf_mac>:
     898:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     8a8:	41 34 5d 20 5b 41 35 5d 20 5b 41 36 5d 20 73 65     A4] [A5] [A6] se
     8b8:	74 20 4d 41 43 20 61 64 64 72 65 73 73 00           t MAC address.

000008c6 <cmd_conf_save>:
     8c6:	73 61 76 65 00                                      save.

000008cb <cmd_help_conf_save>:
     8cb:	53 61 76 65 20 63 6f 6e 66 69 67 75 72 61 74 69     Save configurati
     8db:	6f 6e 00                                            on.

000008de <cmd_ustawR>:
     8de:	73 65 74 72 00                                      setr.

000008e3 <cmd_help_ustawR>:
     8e3:	5b 76 61 6c 75 65 5d 20 73 65 74 20 72 65 73 69     [value] set resi
     8f3:	73 74 61 6e 63 65 20 76 61 6c 75 65 00              stance value.

00000900 <okStr>:
     900:	4f 4b 0d 0a 00                                      OK...

00000905 <nlStr>:
     905:	0d 0a 00                                            ...

00000908 <BladBuforaPozostaloBajtowStr>:
     908:	21 21 21 20 57 20 62 75 64 6f 72 7a 65 20 52 73     !!! W budorze Rs
     918:	34 38 35 20 70 6f 7a 6f 73 74 61 6c 6f 20 25 64     485 pozostalo %d
     928:	20 62 61 6a 74 6f 77 0d 0a 00                        bajtow...

00000932 <errorStrings>:
     932:	c8 00 d1 00 db 00 de 00 e1 00 e4 00 e7 00 fa 00     ................
     942:	21 01 40 01 63 01 82 01                             !.@.c...

0000094a <cmdListNormal>:
     94a:	3c 04 41 04 7d 1e 53 04 5a 04 5a 20 b3 04 b8 04     <.A.}.S.Z.Z ....
     95a:	08 1e 12 05 18 05 f5 19 3e 05 43 05 77 15 07 06     ........>.C.w...
     96a:	0d 06 00 1e 9f 06 a6 06 5d 1d a1 07 a8 07 0d 15     ........].......
     97a:	00 00 00 00 00 00                                   ......

00000980 <cmdListEnable>:
     980:	3c 04 41 04 7d 1e 53 04 5a 04 5a 20 91 04 99 04     <.A.}.S.Z.Z ....
     990:	55 1d b3 04 b8 04 08 1e c3 04 c9 04 70 1c 12 05     U...........p...
     9a0:	18 05 f5 19 3e 05 43 05 77 15 74 05 79 05 7c 1a     ....>.C.w.t.y.|.
     9b0:	9f 05 a5 05 ef 18 c8 05 cf 05 1b 1a 07 06 0d 06     ................
     9c0:	00 1e 21 06 25 06 d8 19 41 06 49 06 c1 19 6e 06     ..!.%...A.I...n.
     9d0:	75 06 41 19 9f 06 a6 06 5d 1d d0 06 d3 06 6d 18     u.A.....].....m.
     9e0:	f9 06 fe 06 f7 17 26 07 2a 07 e5 17 3d 07 41 07     ......&.*...=.A.
     9f0:	d3 17 de 08 e3 08 c1 17 54 07 5c 07 5a 17 7e 07     ........T.\.Z.~.
     a00:	81 07 e3 16 b4 07 bc 07 1e 15 c6 07 cd 07 2a 15     ..............*.
     a10:	00 00 00 00 00 00                                   ......

00000a16 <cmdListConfigure>:
     a16:	3c 04 41 04 7d 1e 53 04 5a 04 5a 20 b3 04 b8 04     <.A.}.S.Z.Z ....
     a26:	08 1e 54 07 5c 07 5a 17 dc 07 df 07 8b 16 54 08     ..T.\.Z.......T.
     a36:	59 08 6b 16 69 08 6c 08 13 16 02 08 06 08 96 15     Y.k.i.l.........
     a46:	94 08 98 08 40 15 c6 08 cb 08 3b 15 a1 07 a8 07     ....@.....;.....
     a56:	0d 15 b4 07 bc 07 1e 15 00 00 00 00 00 00           ..............

00000a64 <__c.3542>:
     a64:	57 61 72 74 6f 73 63 20 70 72 6f 62 6b 69 20 6e     Wartosc probki n
     a74:	61 20 77 65 6a 73 63 69 75 20 25 64 3a 20 25 64     a wejsciu %d: %d
     a84:	0d 0a 00                                            ...

00000a87 <__c.3660>:
     a87:	58 6d 6f 64 65 6d 3a 20 72 6f 7a 70 6f 63 7a 79     Xmodem: rozpoczy
     a97:	6e 61 6e 69 65 20 6f 64 62 69 6f 72 75 0d 0a 00     nanie odbioru...

00000aa7 <__c.3412>:
     aa7:	75 64 70 00                                         udp.

00000aab <__c.3410>:
     aab:	74 63 70 00                                         tcp.

00000aaf <__c.3408>:
     aaf:	69 63 6d 70 00                                      icmp.

00000ab4 <__c.3406>:
     ab4:	69 70 00                                            ip.

00000ab7 <__c.3404>:
     ab7:	61 72 70 00                                         arp.

00000abb <__c.3402>:
     abb:	75 64 70 00                                         udp.

00000abf <__c.3400>:
     abf:	74 63 70 00                                         tcp.

00000ac3 <__c.3398>:
     ac3:	69 63 6d 70 00                                      icmp.

00000ac8 <__c.3396>:
     ac8:	69 70 00                                            ip.

00000acb <__c.3394>:
     acb:	61 72 70 00                                         arp.

00000acf <__c.3364>:
     acf:	41 6b 74 75 61 6c 6e 79 20 63 7a 61 73 20 25 64     Aktualny czas %d
     adf:	3a 25 64 3a 25 64 0d 0a 00                          :%d:%d...

00000ae8 <__c.3323>:
     ae8:	0d 0a 00                                            ...

00000aeb <__c.3321>:
     aeb:	0d 0a 00                                            ...

00000aee <__c.3319>:
     aee:	0d 0a 00                                            ...

00000af1 <__c.3317>:
     af1:	0d 0a 00                                            ...

00000af4 <__c.3314>:
     af4:	46 72 65 65 52 74 6f 73 2b 20 76 65 72 20 30 2e     FreeRtos+ ver 0.
     b04:	33 31 20 62 75 69 6c 64 3a 20 41 75 67 20 32 31     31 build: Aug 21
     b14:	20 32 30 31 31 2c 20 31 36 3a 33 30 3a 33 31 0d      2011, 16:30:31.
     b24:	0a 00                                               ..

00000b26 <__c.3114>:
     b26:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ================
     b36:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d 0a     ==============..
	...

00000b47 <__c.3112>:
     b47:	55 6e 6b 6e 6f 77 6e 20 70 61 63 6b 65 74 0d 0a     Unknown packet..
	...

00000b58 <__c.3109>:
     b58:	49 50 20 73 74 61 63 6b 20 72 65 61 64 79 20 0d     IP stack ready .
     b68:	0a 00                                               ..

00000b6a <__c.1665>:
     b6a:	52 65 73 74 61 72 74 0d 0a 00                       Restart...

00000b74 <CmdlinePromptNormal>:
     b74:	44 6f 6d 4f 73 3e 00                                DomOs>.

00000b7b <CmdlinePromptEnable>:
     b7b:	44 6f 6d 4f 73 23 00                                DomOs#.

00000b82 <CmdlinePromptConfigure>:
     b82:	44 6f 6d 4f 73 40 00                                DomOs@.

00000b89 <CmdlineNotice>:
     b89:	63 6d 64 6c 69 6e 65 3a 20 00                       cmdline: .

00000b93 <CmdlineCmdNotFound>:
     b93:	23 20 6e 6b 00                                      # nk.

00000b98 <__c.3458>:
     b98:	0d 0a 00                                            ...

00000b9b <__c.3456>:
     b9b:	09 00                                               ..

00000b9d <__c.3340>:
     b9d:	4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 61 6c     Operation not al
     bad:	6c 6f 77 65 64 0d 0a 00                             lowed...

00000bb5 <__c.3337>:
     bb5:	4f 70 65 72 61 74 69 6f 6e 20 66 61 69 6c 65 64     Operation failed
     bc5:	0d 0a 00                                            ...

00000bc8 <__c.3334>:
     bc8:	0d 0a 00                                            ...

00000bcb <__c.3332>:
     bcb:	20 00                                                .

00000bcd <__c.3330>:
     bcd:	53 79 6e 74 61 78 20 45 72 72 6f 72 2e 20 55 73     Syntax Error. Us
     bdd:	65 3a 20 00                                         e: .

00000be1 <__c.3326>:
     be1:	4f 4b 0d 0a 00                                      OK...

00000be6 <__c.3355>:
     be6:	09 4d 41 41 44 52 35 20 30 78 25 78 0d 0a 00        .MAADR5 0x%x...

00000bf5 <__c.3353>:
     bf5:	09 4d 41 41 44 52 34 20 30 78 25 78 0d 0a 00        .MAADR4 0x%x...

00000c04 <__c.3351>:
     c04:	09 4d 41 41 44 52 33 20 30 78 25 78 0d 0a 00        .MAADR3 0x%x...

00000c13 <__c.3349>:
     c13:	09 4d 41 41 44 52 32 20 30 78 25 78 0d 0a 00        .MAADR2 0x%x...

00000c22 <__c.3347>:
     c22:	09 4d 41 41 44 52 31 20 30 78 25 78 0d 0a 00        .MAADR1 0x%x...

00000c31 <__c.3345>:
     c31:	09 4d 41 41 44 52 30 20 30 78 25 78 0d 0a 00        .MAADR0 0x%x...

00000c40 <__c.3343>:
     c40:	45 4e 43 32 38 6a 36 30 20 73 74 61 6e 20 72 65     ENC28j60 stan re
     c50:	6a 65 73 74 72 6f 77 3a 0d 0a 00                    jestrow:...

00000c5b <__c.1815>:
     c5b:	4e 49 43 20 72 65 67 20 64 75 6d 70 20 6e 6f 74     NIC reg dump not
     c6b:	20 69 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00         implemented...

00000c7a <__c.1725>:
     c7a:	0d 0a 00                                            ...

00000c7d <__c.1723>:
     c7d:	55 52 47 20 00                                      URG .

00000c82 <__c.1721>:
     c82:	41 43 4b 20 00                                      ACK .

00000c87 <__c.1719>:
     c87:	50 53 48 20 00                                      PSH .

00000c8c <__c.1717>:
     c8c:	52 53 54 20 00                                      RST .

00000c91 <__c.1715>:
     c91:	53 59 4e 20 00                                      SYN .

00000c96 <__c.1713>:
     c96:	46 49 4e 20 00                                      FIN .

00000c9b <__c.1711>:
     c9b:	46 6c 61 67 73 20 20 20 3a 20 00                    Flags   : .

00000ca6 <__c.1709>:
     ca6:	41 63 6b 20 4e 75 6d 20 3a 20 30 78 25 78 0d 0a     Ack Num : 0x%x..
	...

00000cb7 <__c.1707>:
     cb7:	53 65 71 20 4e 75 6d 20 3a 20 30 78 25 78 00        Seq Num : 0x%x.

00000cc6 <__c.1705>:
     cc6:	44 73 74 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Dst Port: %d...

00000cd5 <__c.1703>:
     cd5:	53 72 63 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Src Port: %d...

00000ce4 <__c.1701>:
     ce4:	54 43 50 20 48 65 61 64 65 72 0d 0a 00              TCP Header...

00000cf1 <__c.1684>:
     cf1:	0d 0a 00                                            ...

00000cf4 <__c.1682>:
     cf4:	44 65 73 74 20 20 49 50 3a 20 00                    Dest  IP: .

00000cff <__c.1680>:
     cff:	0d 0a 00                                            ...

00000d02 <__c.1678>:
     d02:	53 6f 75 72 63 65 49 50 3a 20 00                    SourceIP: .

00000d0d <__c.1676>:
     d0d:	50 72 6f 74 6f 63 6f 6c 3a 20 25 64 0d 0a 00        Protocol: %d...

00000d1c <__c.1674>:
     d1c:	50 72 6f 74 6f 63 6f 6c 3a 20 55 44 50 0d 0a 00     Protocol: UDP...

00000d2c <__c.1672>:
     d2c:	50 72 6f 74 6f 63 6f 6c 3a 20 54 43 50 0d 0a 00     Protocol: TCP...

00000d3c <__c.1670>:
     d3c:	50 72 6f 74 6f 63 6f 6c 3a 20 49 43 4d 50 0d 0a     Protocol: ICMP..
	...

00000d4d <__c.1668>:
     d4d:	4c 65 6e 67 74 68 20 20 3a 20 25 64 0d 0a 00        Length  : %d...

00000d5c <__c.1666>:
     d5c:	56 65 72 20 20 20 20 20 3a 20 25 64 0d 0a 00        Ver     : %d...

00000d6b <__c.1664>:
     d6b:	49 50 20 48 65 61 64 65 72 0d 0a 00                 IP Header...

00000d77 <__c.1655>:
     d77:	2d 3e 44 53 54 3a 00                                ->DST:.

00000d7e <__c.1653>:
     d7e:	20 53 52 43 3a 00                                    SRC:.

00000d84 <__c.1651>:
     d84:	45 74 68 20 50 61 63 6b 65 74 20 54 79 70 65 3a     Eth Packet Type:
     d94:	20 30 78 25 78 00                                    0x%x.

00000d9a <__c.1633>:
     d9a:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

00000da6 <__c.1615>:
     da6:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
     db6:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

00000dc4 <__c.2379>:
     dc4:	0d 0a 00                                            ...

00000dc7 <__c.2377>:
     dc7:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00000dd2 <__c.2375>:
     dd2:	0d 0a 00                                            ...

00000dd5 <__c.2373>:
     dd5:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00000de0 <__c.2371>:
     de0:	0d 0a 00                                            ...

00000de3 <__c.2369>:
     de3:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00000dee <__c.2352>:
     dee:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     dfe:	6c 65 28 6c 65 6e 2d 45 54 48 5f 48 45 41 44 45     le(len-ETH_HEADE
     e0e:	52 5f 4c 45 4e 2c 20 26 64 61 74 61 5b 45 54 48     R_LEN, &data[ETH
     e1e:	5f 48 45 41 44 45 52 5f 4c 45 4e 5d 29 3b 00        _HEADER_LEN]);.

00000e2d <__c.2350>:
     e2d:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     e3d:	6c 65 28 45 54 48 5f 48 45 41 44 45 52 5f 4c 45     le(ETH_HEADER_LE
     e4d:	4e 2c 20 26 64 61 74 61 5b 30 5d 29 3b 00           N, &data[0]);.

00000e5b <__c.2348>:
     e5b:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     e6b:	74 20 74 6f 20 67 61 74 65 77 61 79 0d 0a 00        t to gateway...

00000e7a <__c.2346>:
     e7a:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     e8a:	74 20 6f 6e 20 6c 6f 63 61 6c 20 6e 65 74 0d 0a     t on local net..
	...

00000e9b <__c.2304>:
     e9b:	4e 45 54 20 52 78 3a 20 55 6e 6b 6e 6f 77 6e 20     NET Rx: Unknown 
     eab:	49 50 20 70 61 63 6b 65 74 0d 0a 00                 IP packet...

00000eb7 <__c.2302>:
     eb7:	4e 45 54 20 52 78 3a 20 54 43 50 2f 49 50 20 70     NET Rx: TCP/IP p
     ec7:	61 63 6b 65 74 0d 0a 00                             acket...

00000ecf <__c.2300>:
     ecf:	4e 45 54 20 52 78 3a 20 55 44 50 2f 49 50 20 70     NET Rx: UDP/IP p
     edf:	61 63 6b 65 74 0d 0a 00                             acket...

00000ee7 <__c.2298>:
     ee7:	4e 45 54 20 52 78 3a 20 49 43 4d 50 2f 49 50 20     NET Rx: ICMP/IP 
     ef7:	70 61 63 6b 65 74 0d 0a 00                          packet...

00000f00 <__c.2347>:
     f00:	43 6f 64 65 20 20 20 3a 20 30 78 25 78 0d 0a 00     Code   : 0x%x...

00000f10 <__c.2345>:
     f10:	0d 0a 00                                            ...

00000f13 <__c.2342>:
     f13:	45 43 48 4f 20 52 45 50 4c 59 00                    ECHO REPLY.

00000f1e <__c.2338>:
     f1e:	45 43 48 4f 20 52 45 51 55 45 53 54 00              ECHO REQUEST.

00000f2b <__c.2335>:
     f2b:	54 79 70 65 20 20 20 3a 20 00                       Type   : .

00000f35 <__c.2333>:
     f35:	0d 0a 00                                            ...

00000f38 <__c.2331>:
     f38:	44 73 74 49 70 41 64 64 72 3a 20 00                 DstIpAddr: .

00000f44 <__c.2329>:
     f44:	0d 0a 00                                            ...

00000f47 <__c.2327>:
     f47:	53 72 63 49 70 41 64 64 72 3a 20 00                 SrcIpAddr: .

00000f53 <__c.2325>:
     f53:	49 43 4d 50 20 50 61 63 6b 65 74 3a 0d 0a 00        ICMP Packet:...

00000f62 <__c.2302>:
     f62:	53 65 6e 64 69 6e 67 20 49 43 4d 50 20 50 4f 4e     Sending ICMP PON
     f72:	47 0d 0a 00                                         G...

00000f76 <__c.2299>:
     f76:	52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72 65     Received ICMP re
     f86:	71 75 65 73 74 3a 20 00                             quest: .

00000f8e <__c.2289>:
     f8e:	55 6e 6b 6e 6f 77 6e 20 49 43 4d 50 20 74 79 70     Unknown ICMP typ
     f9e:	65 52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72     eReceived ICMP r
     fae:	65 71 75 65 73 74 3a 20 00                          equest: .

00000fb7 <__c.2419>:
     fb7:	0d 0a 00                                            ...

00000fba <__c.2417>:
     fba:	20 20 00                                              .

00000fbd <__c.2415>:
     fbd:	25 33 64 20 20 00                                   %3d  .

00000fc3 <__c.2412>:
     fc3:	0d 0a 00                                            ...

00000fc6 <__c.2410>:
     fc6:	20 20 00                                              .

00000fc9 <__c.2408>:
     fc9:	20 4d 59 20 20 00                                    MY  .

00000fcf <__c.2406>:
     fcf:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fdf:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fef:	2d 2d 2d 0d 0a 00                                   ---...

00000ff5 <__c.2404>:
     ff5:	54 69 6d 65 20 45 74 68 20 41 64 64 72 65 73 73     Time Eth Address
    1005:	20 20 20 20 20 20 20 20 49 50 20 41 64 64 72 65             IP Addre
    1015:	73 73 0d 0a 00                                      ss...

0000101a <__c.2391>:
    101a:	0d 0a 00                                            ...

0000101d <__c.2389>:
    101d:	44 73 74 50 72 6f 74 6f 41 64 64 72 3a 20 00        DstProtoAddr: .

0000102c <__c.2387>:
    102c:	0d 0a 00                                            ...

0000102f <__c.2385>:
    102f:	44 73 74 48 77 41 64 64 72 20 20 20 3a 20 00        DstHwAddr   : .

0000103e <__c.2383>:
    103e:	0d 0a 00                                            ...

00001041 <__c.2381>:
    1041:	53 72 63 50 72 6f 74 6f 41 64 64 72 3a 20 00        SrcProtoAddr: .

00001050 <__c.2379>:
    1050:	0d 0a 00                                            ...

00001053 <__c.2377>:
    1053:	53 72 63 48 77 41 64 64 72 20 20 20 3a 20 00        SrcHwAddr   : .

00001062 <__c.2375>:
    1062:	0d 0a 00                                            ...

00001065 <__c.2373>:
    1065:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

0000106d <__c.2371>:
    106d:	52 45 50 4c 59 00                                   REPLY.

00001073 <__c.2369>:
    1073:	52 45 51 55 45 53 54 00                             REQUEST.

0000107b <__c.2367>:
    107b:	4f 70 65 72 61 74 69 6f 6e 20 20 20 3a 20 00        Operation   : .

0000108a <__c.2365>:
    108a:	41 52 50 20 50 61 63 6b 65 74 3a 0d 0a 00           ARP Packet:...

00001098 <__c.2315>:
    1098:	0d 0a 00                                            ...

0000109b <__c.2313>:
    109b:	20 49 50 3a 20 00                                    IP: .

000010a1 <__c.2311>:
    10a1:	41 52 50 20 49 50 20 69 6e 20 4d 41 43 3a 20 00     ARP IP in MAC: .

000010b1 <__c.2296>:
    10b1:	53 65 6e 64 69 6e 67 20 41 52 50 20 52 65 70 6c     Sending ARP Repl
    10c1:	79 0d 0a 00                                         y...

000010c5 <__c.2294>:
    10c5:	52 65 63 65 69 76 65 64 20 41 52 50 20 52 65 71     Received ARP Req
    10d5:	75 65 73 74 0d 0a 00                                uest...

000010dc <__c.2403>:
    10dc:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
    10ec:	6e 74 65 64 0d 0a 00                                nted...

000010f3 <__c.2353>:
    10f3:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1103:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
    1113:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
    1123:	74 0d 0a 00                                         t...

00001127 <__c.2351>:
    1127:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1137:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    1147:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
    1157:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
    1167:	49 53 48 45 44 0d 0a 00                             ISHED...

0000116f <__c.2349>:
    116f:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    117f:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
    118f:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
    119f:	74 0d 0a 00                                         t...

000011a3 <__c.2347>:
    11a3:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    11b3:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    11c3:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
    11d3:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
    11e3:	0a 00                                               ..

000011e5 <__c.2316>:
    11e5:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
    11f5:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
    1205:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

0000120f <__c.2311>:
    120f:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    121f:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
    122f:	54 45 4e 0d 0a 00                                   TEN...

00001235 <__c.2306>:
    1235:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    1245:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

00001251 <__c.2384>:
    1251:	25 64 0d 0a 00                                      %d...

00001256 <__c.2382>:
    1256:	41 4e 59 0d 0a 00                                   ANY...

0000125c <__c.2380>:
    125c:	0d 0a 20 20 73 72 63 20 70 6f 72 74 20 20 20 20     ..  src port    
    126c:	3a 20 25 64 0d 0a 20 20 64 73 74 20 70 6f 72 74     : %d..  dst port
    127c:	20 20 20 20 3a 20 00                                    : .

00001283 <__c.2378>:
    1283:	0d 0a 20 20 49 50 20 20 20 20 20 20 20 20 20 20     ..  IP          
    1293:	3a 20 00                                            : .

00001296 <__c.2376>:
    1296:	55 44 50 20 63 6f 6e 66 69 67 3a 00                 UDP config:.

000012a2 <__c.2330>:
    12a2:	0d 0a 00                                            ...

000012a5 <__c.2325>:
    12a5:	55 44 50 20 54 58 20 62 75 66 66 65 72 20 62 75     UDP TX buffer bu
    12b5:	73 79 0d 0a 00                                      sy...

000012ba <__c.2323>:
    12ba:	30 78 25 32 78 0d 0a 00                             0x%2x...

000012c2 <__c.2321>:
    12c2:	52 65 63 65 69 76 65 64 20 64 61 74 61 3a 20 00     Received data: .

000012d2 <__c.2318>:
    12d2:	50 72 6f 63 2e 20 55 44 50 20 70 61 63 6b 65 74     Proc. UDP packet
    12e2:	20 28 64 61 74 61 20 6c 65 6e 67 74 68 20 25 64      (data length %d
    12f2:	29 0d 0a 00                                         )...

000012f6 <__c.2301>:
    12f6:	53 65 6e 64 69 6e 67 20 55 44 50 20 70 61 63 6b     Sending UDP pack
    1306:	65 74 20 28 64 61 74 61 20 6c 65 6e 67 74 68 20     et (data length 
    1316:	25 64 29 0d 0a 00                                   %d)...

0000131c <__c.2692>:
    131c:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    132c:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    133c:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    134c:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    135c:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    136c:	30 32 78 20 0d 0a 00                                02x ...

00001373 <__c.2690>:
    1373:	09 53 6f 6c 69 63 69 74 65 64 20 6e 6f 64 65 20     .Solicited node 
    1383:	6d 63 61 73 74 20 61 64 64 72 65 73 73 3a 00        mcast address:.

00001392 <__c.2685>:
    1392:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    13a2:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    13b2:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    13c2:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    13d2:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    13e2:	30 32 78 20 0d 0a 00                                02x ...

000013e9 <__c.2683>:
    13e9:	09 41 64 64 72 65 73 73 20 25 64 3a 09 09 00        .Address %d:...

000013f8 <__c.2681>:
    13f8:	09 41 64 64 72 65 73 73 65 73 3a 0a 0d 00           .Addresses:...

00001406 <__c.2678>:
    1406:	2a 49 6e 74 65 72 66 61 63 65 20 49 50 76 36 20     *Interface IPv6 
    1416:	63 6f 6e 66 69 67 3a 0a 0d 00                       config:...

00001420 <__c.2656>:
    1420:	0d 0a 00                                            ...

00001423 <__c.2651>:
    1423:	25 30 32 78 3a 00                                   %02x:.

00001429 <__c.2649>:
    1429:	09 00                                               ..

0000142b <__c.2647>:
    142b:	0d 0a 00                                            ...

0000142e <__c.2644>:
    142e:	09 00                                               ..

00001430 <__c.2642>:
    1430:	2a 49 50 76 36 20 50 61 79 6c 6f 61 64 20 52 41     *IPv6 Payload RA
    1440:	57 3a 0d 0a 00                                      W:...

00001445 <__c.2519>:
    1445:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1455:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1465:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1475:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1485:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1495:	30 32 78 20 0d 0a 00                                02x ...

0000149c <__c.2517>:
    149c:	09 44 65 73 74 69 6e 61 74 69 6f 6e 20 61 64 64     .Destination add
    14ac:	72 65 73 73 3a 20 09 00                             ress: ..

000014b4 <__c.2515>:
    14b4:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    14c4:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    14d4:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    14e4:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    14f4:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1504:	30 32 78 20 0d 0a 00                                02x ...

0000150b <__c.2513>:
    150b:	09 53 6f 75 72 63 65 20 61 64 64 72 65 73 73 3a     .Source address:
    151b:	20 09 00                                             ..

0000151e <__c.2511>:
    151e:	09 25 64 20 0a 0d 00                                .%d ...

00001525 <__c.2509>:
    1525:	09 50 61 79 6c 6f 61 64 20 4c 65 6e 67 74 68 3a     .Payload Length:
    1535:	20 09 00                                             ..

00001538 <__c.2507>:
    1538:	09 25 64 20 0a 0d 00                                .%d ...

0000153f <__c.2505>:
    153f:	09 46 6c 6f 77 20 4c 61 62 65 6c 3a 20 09 09 00     .Flow Label: ...

0000154f <__c.2503>:
    154f:	09 25 64 20 0a 0d 00                                .%d ...

00001556 <__c.2501>:
    1556:	09 54 72 61 66 66 69 63 20 43 6c 61 73 73 3a 20     .Traffic Class: 
    1566:	09 09 00                                            ...

00001569 <__c.2499>:
    1569:	09 25 64 20 0a 0d 00                                .%d ...

00001570 <__c.2497>:
    1570:	09 56 65 72 73 69 6f 6e 3a 20 09 09 00              .Version: ...

0000157d <__c.2495>:
    157d:	2a 49 50 76 36 20 48 65 61 64 65 72 3a 0d 0a 00     *IPv6 Header:...

0000158d <__c.2483>:
    158d:	0d 0a 00                                            ...

00001590 <__c.2478>:
    1590:	25 30 32 78 3a 00                                   %02x:.

00001596 <__c.2476>:
    1596:	09 00                                               ..

00001598 <__c.2474>:
    1598:	0d 0a 00                                            ...

0000159b <__c.2471>:
    159b:	09 00                                               ..

0000159d <__c.2469>:
    159d:	2a 49 50 76 36 20 48 65 61 64 65 72 20 52 41 57     *IPv6 Header RAW
    15ad:	3a 0d 0a 00                                         :...

000015b1 <__c.2416>:
    15b1:	69 70 3a 20 70 61 63 6b 65 74 20 73 68 6f 72 74     ip: packet short
    15c1:	65 72 20 74 68 61 6e 20 72 65 70 6f 72 74 65 64     er than reported
    15d1:	20 69 6e 20 49 50 20 68 65 61 64 65 72 2e 0a 0d      in IP header...
	...

000015e2 <__c.2414>:
    15e2:	0d 0a 00                                            ...

000015e5 <__c.2409>:
    15e5:	25 30 32 78 3a 00                                   %02x:.

000015eb <__c.2407>:
    15eb:	0d 0a 00                                            ...

000015ee <__c.2404>:
    15ee:	50 61 63 6b 65 74 20 6f 75 74 2c 20 6c 65 6e 67     Packet out, leng
    15fe:	74 68 3d 25 64 2c 20 0d 0a 00                       th=%d, ...

00001608 <__c.2402>:
    1608:	0d 0a 00                                            ...

0000160b <__c.2397>:
    160b:	25 30 32 78 3a 00                                   %02x:.

00001611 <__c.2395>:
    1611:	0d 0a 00                                            ...

00001614 <__c.2392>:
    1614:	4e 53 2c 20 6c 65 6e 67 74 68 3d 25 64 2c 20 0d     NS, length=%d, .
    1624:	0a 00                                               ..

00001626 <__c.2390>:
    1626:	2a 49 50 76 36 20 70 61 63 6b 65 74 20 69 6e 2e     *IPv6 packet in.
    1636:	20 4c 65 6e 67 74 68 3a 20 25 64 0d 0a 00            Length: %d...

00001644 <__c.2391>:
    1644:	45 63 68 6f 20 72 65 71 75 65 73 74 0a 0d 00        Echo request...

00001653 <__c.2508>:
    1653:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1663:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1673:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1683:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1693:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    16a3:	30 32 78 20 0d 0a 00                                02x ...

000016aa <__c.2506>:
    16aa:	77 69 74 68 20 74 61 72 67 65 74 20 61 64 64 72     with target addr
    16ba:	65 73 73 0a 0d 00                                   ess...

000016c0 <__c.2504>:
    16c0:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    16d0:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    16e0:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    16f0:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1700:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1710:	30 32 78 20 0d 0a 00                                02x ...

00001717 <__c.2502>:
    1717:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1727:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1737:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1747:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1757:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1767:	30 32 78 20 0d 0a 00                                02x ...

0000176e <__c.2500>:
    176e:	66 72 6f 6d 0a 0d 00                                from...

00001775 <__c.2498>:
    1775:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1785:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1795:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    17a5:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    17b5:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    17c5:	30 32 78 20 0d 0a 00                                02x ...

000017cc <__c.2496>:
    17cc:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    17dc:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    17ec:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    17fc:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    180c:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    181c:	30 32 78 20 0d 0a 00                                02x ...

00001823 <__c.2494>:
    1823:	53 65 6e 64 69 6e 67 20 4e 41 20 74 6f 0a 0d 00     Sending NA to...

00001833 <__c.2492>:
    1833:	0d 0a 00                                            ...

00001836 <__c.2487>:
    1836:	25 30 32 78 3a 00                                   %02x:.

0000183c <__c.2485>:
    183c:	0d 0a 00                                            ...

0000183f <__c.2482>:
    183f:	4e 53 20 70 61 63 6b 65 74 20 41 46 54 45 52 3a     NS packet AFTER:
    184f:	0d 0a 00                                            ...

00001852 <__c.2480>:
    1852:	6e 69 63 53 74 61 74 65 2e 6c 61 79 65 72 34 2e     nicState.layer4.
    1862:	69 63 6d 70 2d 3e 69 63 6d 70 63 68 6b 73 75 6d     icmp->icmpchksum
    1872:	20 20 25 30 34 78 0a 0d 00                            %04x...

0000187b <__c.2478>:
    187b:	6e 69 63 53 74 61 74 65 2e 6c 61 79 65 72 34 2e     nicState.layer4.
    188b:	69 63 6d 70 2d 3e 69 63 6d 70 63 68 6b 73 75 6d     icmp->icmpchksum
    189b:	20 20 25 30 34 78 0a 0d 00                            %04x...

000018a4 <__c.2476>:
    18a4:	26 6e 69 63 53 74 61 74 65 2e 6d 61 63 2e 61 64     &nicState.mac.ad
    18b4:	64 72 20 25 30 32 78 20 0a 0d 00                    dr %02x ...

000018bf <__c.2474>:
    18bf:	0d 0a 00                                            ...

000018c2 <__c.2469>:
    18c2:	25 30 32 78 3a 00                                   %02x:.

000018c8 <__c.2467>:
    18c8:	0d 0a 00                                            ...

000018cb <__c.2464>:
    18cb:	4e 53 20 70 61 63 6b 65 74 20 62 65 66 6f 72 65     NS packet before
    18db:	3a 0d 0a 00                                         :...

000018df <__c.2461>:
    18df:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    18ef:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    18ff:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    190f:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    191f:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    192f:	30 32 78 20 0d 0a 00                                02x ...

00001936 <__c.2459>:
    1936:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1946:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1956:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1966:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1976:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1986:	30 32 78 20 0d 0a 00                                02x ...

0000198d <__c.2457>:
    198d:	4d 4f 44 20 61 64 64 72 3a 20 0d 0a 00              MOD addr: ...

0000199a <__c.2455>:
    199a:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    19aa:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    19ba:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    19ca:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    19da:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    19ea:	30 32 78 20 0d 0a 00                                02x ...

000019f1 <__c.2453>:
    19f1:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1a01:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1a11:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1a21:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1a31:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1a41:	30 32 78 20 0d 0a 00                                02x ...

00001a48 <__c.2451>:
    1a48:	4f 52 47 20 61 64 64 72 3a 20 0d 0a 00              ORG addr: ...

00001a55 <__c.2449>:
    1a55:	75 69 70 5f 6e 65 74 69 66 5f 61 64 64 72 5f 6c     uip_netif_addr_l
    1a65:	6f 6f 6b 75 70 3a 20 0d 0a 00                       ookup: ...

00001a6f <__c.2446>:
    1a6f:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1a7f:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1a8f:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1a9f:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1aaf:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1abf:	30 32 78 20 0d 0a 00                                02x ...

00001ac6 <__c.2444>:
    1ac6:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1ad6:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1ae6:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1af6:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1b06:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1b16:	30 32 78 20 0d 0a 00                                02x ...

00001b1d <__c.2442>:
    1b1d:	69 66 61 64 64 72 3a 20 2a 2a 20 25 30 34 78 20     ifaddr: ** %04x 
    1b2d:	0d 0a 00                                            ...

00001b30 <__c.2437>:
    1b30:	4e 44 20 6f 70 74 69 6f 6e 20 6e 6f 74 20 73 75     ND option not su
    1b40:	70 70 6f 72 74 65 64 20 69 6e 20 4e 53 00           pported in NS.

00001b4e <__c.2432>:
    1b4e:	0d 0a 00                                            ...

00001b51 <__c.2427>:
    1b51:	25 30 32 78 3a 00                                   %02x:.

00001b57 <__c.2424>:
    1b57:	49 43 4d 50 76 36 20 70 61 79 6c 6f 61 64 3a 20     ICMPv6 payload: 
    1b67:	0d 0a 00                                            ...

00001b6a <__c.2422>:
    1b6a:	75 69 70 5f 6c 32 5f 6c 33 5f 69 63 6d 70 5f 68     uip_l2_l3_icmp_h
    1b7a:	64 72 5f 6c 65 6e 20 25 30 34 78 3b 20 70 61 63     dr_len %04x; pac
    1b8a:	6b 65 74 4c 65 6e 67 68 74 20 20 25 30 34 78 20     ketLenght  %04x 
    1b9a:	3b 20 55 49 50 5f 4e 44 36 5f 4f 50 54 5f 48 44     ; UIP_ND6_OPT_HD
    1baa:	52 5f 42 55 46 20 25 30 34 78 2c 20 6e 64 36 5f     R_BUF %04x, nd6_
    1bba:	6f 70 74 5f 6f 66 66 73 65 74 20 25 30 34 78 0d     opt_offset %04x.
    1bca:	0a 00                                               ..

00001bcc <__c.2419>:
    1bcc:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1bdc:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1bec:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1bfc:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1c0c:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1c1c:	30 32 78 20 0d 0a 00                                02x ...

00001c23 <__c.2417>:
    1c23:	77 69 74 68 20 74 61 72 67 65 74 20 61 64 64 72     with target addr
    1c33:	65 73 73 0a 0d 00                                   ess...

00001c39 <__c.2415>:
    1c39:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1c49:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1c59:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1c69:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1c79:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1c89:	30 32 78 20 0d 0a 00                                02x ...

00001c90 <__c.2413>:
    1c90:	74 6f 0a 0d 00                                      to...

00001c95 <__c.2411>:
    1c95:	09 49 50 76 36 20 61 64 64 72 3a 20 25 30 32 78     .IPv6 addr: %02x
    1ca5:	25 30 32 78 3a 25 30 32 78 25 30 32 78 3a 25 30     %02x:%02x%02x:%0
    1cb5:	32 78 25 30 32 78 3a 25 30 32 78 25 30 32 78 3a     2x%02x:%02x%02x:
    1cc5:	25 30 32 78 25 30 32 78 3a 25 30 32 78 25 30 32     %02x%02x:%02x%02
    1cd5:	78 3a 25 30 32 78 25 30 32 78 3a 25 30 32 78 25     x:%02x%02x:%02x%
    1ce5:	30 32 78 20 0d 0a 00                                02x ...

00001cec <__c.2409>:
    1cec:	52 65 63 65 69 76 65 64 20 4e 53 20 66 72 6f 6d     Received NS from
    1cfc:	0a 0d 00                                            ...

00001cff <__c.2390>:
    1cff:	45 4e 54 52 49 45 53 20 25 64 20 25 64 3a 00        ENTRIES %d %d:.

00001d0e <__c.2532>:
    1d0e:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
    1d1e:	6e 74 65 64 0d 0a 00                                nted...

00001d25 <__c.2482>:
    1d25:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1d35:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
    1d45:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
    1d55:	74 0d 0a 00                                         t...

00001d59 <__c.2480>:
    1d59:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1d69:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    1d79:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
    1d89:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
    1d99:	49 53 48 45 44 0d 0a 00                             ISHED...

00001da1 <__c.2478>:
    1da1:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1db1:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
    1dc1:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
    1dd1:	74 0d 0a 00                                         t...

00001dd5 <__c.2476>:
    1dd5:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1de5:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    1df5:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
    1e05:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
    1e15:	0a 00                                               ..

00001e17 <__c.2445>:
    1e17:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
    1e27:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
    1e37:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

00001e41 <__c.2440>:
    1e41:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    1e51:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
    1e61:	54 45 4e 0d 0a 00                                   TEN...

00001e67 <__c.2435>:
    1e67:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    1e77:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

00001e83 <statusRollerDescStr>:
    1e83:	20 25 64 20 72 6f 6c 6c 65 72 20 64 72 69 76 65      %d roller drive
    1e93:	72 3a 20 72 6f 6c 6c 65 72 20 31 20 70 6f 73 69     r: roller 1 posi
    1ea3:	74 69 6f 6e 20 25 64 2c 20 72 6f 6c 6c 65 72 20     tion %d, roller 
    1eb3:	32 20 70 6f 73 69 74 69 6f 6e 20 25 64 00           2 position %d.

00001ec1 <statusRollerDescStr2>:
    1ec1:	2c 20 66 69 72 6d 77 61 72 65 20 25 73 0d 0a 00     , firmware %s...

00001ed1 <__c.3317>:
    1ed1:	0d 0a 4f 4b 0d 0a 00                                ..OK...

00001ed8 <__c.3308>:
    1ed8:	62 6f 6f 74 6c 6f 61 64 65 72 20 6e 69 65 20 72     bootloader nie r
    1ee8:	6f 7a 70 6f 63 7a 61 6c 20 6f 64 62 69 6f 72 75     ozpoczal odbioru
    1ef8:	20 64 61 6e 79 63 68 0d 0a 00                        danych...

00001f02 <__c.3306>:
    1f02:	6e 61 20 75 72 7a 61 64 7a 65 6e 69 75 20 77 67     na urzadzeniu wg
    1f12:	72 61 6e 79 20 6a 65 73 74 20 74 79 6c 6b 6f 20     rany jest tylko 
    1f22:	62 6f 6f 74 6c 6f 61 64 65 72 0d 0a 00              bootloader...

00001f2f <__c.3304>:
    1f2f:	72 46 4c 41 53 48 20 74 69 6d 65 6f 75 74 0d 0a     rFLASH timeout..
	...

00001f40 <__ctors_end>:
    1f40:	11 24       	eor	r1, r1
    1f42:	1f be       	out	0x3f, r1	; 63
    1f44:	cf ef       	ldi	r28, 0xFF	; 255
    1f46:	d0 e1       	ldi	r29, 0x10	; 16
    1f48:	de bf       	out	0x3e, r29	; 62
    1f4a:	cd bf       	out	0x3d, r28	; 61

00001f4c <__do_copy_data>:
    1f4c:	11 e0       	ldi	r17, 0x01	; 1
    1f4e:	a0 e0       	ldi	r26, 0x00	; 0
    1f50:	b1 e0       	ldi	r27, 0x01	; 1
    1f52:	e8 e9       	ldi	r30, 0x98	; 152
    1f54:	f1 ef       	ldi	r31, 0xF1	; 241
    1f56:	00 e0       	ldi	r16, 0x00	; 0
    1f58:	0b bf       	out	0x3b, r16	; 59
    1f5a:	02 c0       	rjmp	.+4      	; 0x1f60 <__do_copy_data+0x14>
    1f5c:	07 90       	elpm	r0, Z+
    1f5e:	0d 92       	st	X+, r0
    1f60:	a8 38       	cpi	r26, 0x88	; 136
    1f62:	b1 07       	cpc	r27, r17
    1f64:	d9 f7       	brne	.-10     	; 0x1f5c <__do_copy_data+0x10>

00001f66 <initExternalMem>:
    1f66:	85 b7       	in	r24, 0x35	; 53
    1f68:	80 68       	ori	r24, 0x80	; 128
    1f6a:	85 bf       	out	0x35, r24	; 53
    1f6c:	85 b7       	in	r24, 0x35	; 53
    1f6e:	8e 60       	ori	r24, 0x0E	; 14
    1f70:	85 bf       	out	0x35, r24	; 53

00001f72 <__do_clear_bss>:
    1f72:	10 e1       	ldi	r17, 0x10	; 16
    1f74:	a8 e8       	ldi	r26, 0x88	; 136
    1f76:	b1 e0       	ldi	r27, 0x01	; 1
    1f78:	01 c0       	rjmp	.+2      	; 0x1f7c <.do_clear_bss_start>

00001f7a <.do_clear_bss_loop>:
    1f7a:	1d 92       	st	X+, r1

00001f7c <.do_clear_bss_start>:
    1f7c:	a1 30       	cpi	r26, 0x01	; 1
    1f7e:	b1 07       	cpc	r27, r17
    1f80:	e1 f7       	brne	.-8      	; 0x1f7a <.do_clear_bss_loop>
    1f82:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <main>
    1f86:	0c 94 ca 78 	jmp	0xf194	; 0xf194 <_exit>

00001f8a <__bad_interrupt>:
    1f8a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001f8e <vApplicationTickHook>:
}

void vApplicationTickHook( void )
{
  static uint8_t tickCntr = configTICK_RATE_HZ;
  if (--tickCntr == 0)
    1f8e:	80 91 00 01 	lds	r24, 0x0100
    1f92:	81 50       	subi	r24, 0x01	; 1
    1f94:	80 93 00 01 	sts	0x0100, r24
    1f98:	88 23       	and	r24, r24
    1f9a:	29 f4       	brne	.+10     	; 0x1fa6 <vApplicationTickHook+0x18>
  {
    tickCntr = configTICK_RATE_HZ;
    1f9c:	84 e6       	ldi	r24, 0x64	; 100
    1f9e:	80 93 00 01 	sts	0x0100, r24
    arpTimer();    
    1fa2:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <arpTimer>
    1fa6:	08 95       	ret

00001fa8 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
    1fa8:	0e 94 b7 6e 	call	0xdd6e	; 0xdd6e <vCoRoutineSchedule>
    1fac:	fd cf       	rjmp	.-6      	; 0x1fa8 <vApplicationIdleHook>

00001fae <main>:
FILE udpStream;

streamBuffers_t udpBuffers;

portSHORT main( void )
{
    1fae:	af 92       	push	r10
    1fb0:	bf 92       	push	r11
    1fb2:	cf 92       	push	r12
    1fb4:	df 92       	push	r13
    1fb6:	ef 92       	push	r14
    1fb8:	ff 92       	push	r15
    1fba:	0f 93       	push	r16
    1fbc:	1f 93       	push	r17
  ramDyskInit();              //Inicjalizacja Ram dysku
    1fbe:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <ramDyskInit>
  hardwareInit();
    1fc2:	0e 94 b0 14 	call	0x2960	; 0x2960 <hardwareInit>
  spiInit(disableAllSpiDevices);
    1fc6:	8f e9       	ldi	r24, 0x9F	; 159
    1fc8:	92 e1       	ldi	r25, 0x12	; 18
    1fca:	0e 94 d2 21 	call	0x43a4	; 0x43a4 <spiInit>

// VTY on serial  
  xSerialPortInitMinimal(); 
    1fce:	0e 94 4e 12 	call	0x249c	; 0x249c <xSerialPortInitMinimal>
  CLIStateSerialUsb  = xmalloc(sizeof(cmdState_t));
    1fd2:	83 e2       	ldi	r24, 0x23	; 35
    1fd4:	90 e0       	ldi	r25, 0x00	; 0
    1fd6:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    1fda:	90 93 b6 0e 	sts	0x0EB6, r25
    1fde:	80 93 b5 0e 	sts	0x0EB5, r24
  CLIStateSerialUdp  = xmalloc(sizeof(cmdState_t));
    1fe2:	83 e2       	ldi	r24, 0x23	; 35
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    1fea:	90 93 7e 0f 	sts	0x0F7E, r25
    1fee:	80 93 7d 0f 	sts	0x0F7D, r24


//  cmdStateClear(newCmdState);
  
  sensorsTaskInit();
    1ff2:	0e 94 08 15 	call	0x2a10	; 0x2a10 <sensorsTaskInit>
  loadConfiguration();
    1ff6:	0e 94 6f 10 	call	0x20de	; 0x20de <loadConfiguration>

  initQueueStreamUSB(&usbStream);
    1ffa:	00 e8       	ldi	r16, 0x80	; 128
    1ffc:	1e e0       	ldi	r17, 0x0E	; 14
    1ffe:	c8 01       	movw	r24, r16
    2000:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <initQueueStreamUSB>
  VtyInit(CLIStateSerialUsb, &usbStream);
    2004:	80 91 b5 0e 	lds	r24, 0x0EB5
    2008:	90 91 b6 0e 	lds	r25, 0x0EB6
    200c:	b8 01       	movw	r22, r16
    200e:	0e 94 c1 20 	call	0x4182	; 0x4182 <VtyInit>

  udpInit();
    2012:	0e 94 50 45 	call	0x8aa0	; 0x8aa0 <udpInit>
  socketInit();
    2016:	0e 94 b6 42 	call	0x856c	; 0x856c <socketInit>
  initQueueStream(&udpStream, &udpBuffers, udpSocket->Rx, udpSocket->Tx);
    201a:	e0 91 b9 0e 	lds	r30, 0x0EB9
    201e:	f0 91 ba 0e 	lds	r31, 0x0EBA
    2022:	05 ea       	ldi	r16, 0xA5	; 165
    2024:	1e e0       	ldi	r17, 0x0E	; 14
    2026:	42 85       	ldd	r20, Z+10	; 0x0a
    2028:	53 85       	ldd	r21, Z+11	; 0x0b
    202a:	24 85       	ldd	r18, Z+12	; 0x0c
    202c:	35 85       	ldd	r19, Z+13	; 0x0d
    202e:	c8 01       	movw	r24, r16
    2030:	6e ed       	ldi	r22, 0xDE	; 222
    2032:	7e e0       	ldi	r23, 0x0E	; 14
    2034:	0e 94 02 33 	call	0x6604	; 0x6604 <initQueueStream>
  VtyInit(CLIStateSerialUdp, &udpStream);
    2038:	80 91 7d 0f 	lds	r24, 0x0F7D
    203c:	90 91 7e 0f 	lds	r25, 0x0F7E
    2040:	b8 01       	movw	r22, r16
    2042:	0e 94 c1 20 	call	0x4182	; 0x4182 <VtyInit>
  
  xTaskCreate(encTask,        NULL /*"ENC"    */, STACK_SIZE_ENC,       (void *)CLIStateSerialUsb->myStdInOut, 0, &xHandleEnc);
    2046:	e0 91 b5 0e 	lds	r30, 0x0EB5
    204a:	f0 91 b6 0e 	lds	r31, 0x0EB6
    204e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2050:	33 8d       	ldd	r19, Z+27	; 0x1b
    2052:	82 ed       	ldi	r24, 0xD2	; 210
    2054:	90 e2       	ldi	r25, 0x20	; 32
    2056:	60 e0       	ldi	r22, 0x00	; 0
    2058:	70 e0       	ldi	r23, 0x00	; 0
    205a:	44 ef       	ldi	r20, 0xF4	; 244
    205c:	51 e0       	ldi	r21, 0x01	; 1
    205e:	00 e0       	ldi	r16, 0x00	; 0
    2060:	a2 e6       	ldi	r26, 0x62	; 98
    2062:	ea 2e       	mov	r14, r26
    2064:	af e0       	ldi	r26, 0x0F	; 15
    2066:	fa 2e       	mov	r15, r26
    2068:	cc 24       	eor	r12, r12
    206a:	dd 24       	eor	r13, r13
    206c:	aa 24       	eor	r10, r10
    206e:	bb 24       	eor	r11, r11
    2070:	0e 94 71 69 	call	0xd2e2	; 0xd2e2 <xTaskGenericCreate>
  xTaskCreate(vTaskVTYusb,    NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUsb),            1, &xHandleVTY_USB);
    2074:	20 91 b5 0e 	lds	r18, 0x0EB5
    2078:	30 91 b6 0e 	lds	r19, 0x0EB6
    207c:	85 e7       	ldi	r24, 0x75	; 117
    207e:	91 e2       	ldi	r25, 0x21	; 33
    2080:	60 e0       	ldi	r22, 0x00	; 0
    2082:	70 e0       	ldi	r23, 0x00	; 0
    2084:	4c eb       	ldi	r20, 0xBC	; 188
    2086:	52 e0       	ldi	r21, 0x02	; 2
    2088:	01 e0       	ldi	r16, 0x01	; 1
    208a:	f3 ed       	ldi	r31, 0xD3	; 211
    208c:	ef 2e       	mov	r14, r31
    208e:	fe e0       	ldi	r31, 0x0E	; 14
    2090:	ff 2e       	mov	r15, r31
    2092:	0e 94 71 69 	call	0xd2e2	; 0xd2e2 <xTaskGenericCreate>
  xTaskCreate(vTaskVTYsocket, NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUdp),            1, &xHandleVTY_UDP);
    2096:	20 91 7d 0f 	lds	r18, 0x0F7D
    209a:	30 91 7e 0f 	lds	r19, 0x0F7E
    209e:	87 e6       	ldi	r24, 0x67	; 103
    20a0:	91 e2       	ldi	r25, 0x21	; 33
    20a2:	60 e0       	ldi	r22, 0x00	; 0
    20a4:	70 e0       	ldi	r23, 0x00	; 0
    20a6:	4c eb       	ldi	r20, 0xBC	; 188
    20a8:	52 e0       	ldi	r21, 0x02	; 2
    20aa:	ea ec       	ldi	r30, 0xCA	; 202
    20ac:	ee 2e       	mov	r14, r30
    20ae:	ee e0       	ldi	r30, 0x0E	; 14
    20b0:	fe 2e       	mov	r15, r30
    20b2:	0e 94 71 69 	call	0xd2e2	; 0xd2e2 <xTaskGenericCreate>
  //xTaskCreate(sensorsTask,    NULL /*"Sensors"*/, STACK_SIZE_SENSORS,   NULL,                                   1, &xHandleSensors);
  vTaskStartScheduler();
    20b6:	0e 94 8e 6a 	call	0xd51c	; 0xd51c <vTaskStartScheduler>
  return 0;
}
    20ba:	80 e0       	ldi	r24, 0x00	; 0
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	1f 91       	pop	r17
    20c0:	0f 91       	pop	r16
    20c2:	ff 90       	pop	r15
    20c4:	ef 90       	pop	r14
    20c6:	df 90       	pop	r13
    20c8:	cf 90       	pop	r12
    20ca:	bf 90       	pop	r11
    20cc:	af 90       	pop	r10
    20ce:	08 95       	ret

000020d0 <saveConfiguration>:
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
}

void saveConfiguration(void)
{
  saveNic();
    20d0:	0e 94 9e 33 	call	0x673c	; 0x673c <saveNic>
  ipSaveConfig();
    20d4:	0e 94 10 3a 	call	0x7420	; 0x7420 <ipSaveConfig>
  udpSaveConfig();
    20d8:	0e 94 9c 43 	call	0x8738	; 0x8738 <udpSaveConfig>
}
    20dc:	08 95       	ret

000020de <loadConfiguration>:
                                                                                       {LOCK_SENS_3_ENA, LOCK_SENS_3_THR, 0, 0},
                                                                                       {LOCK_SENS_4_ENA, LOCK_SENS_4_THR, 0, 0}};

void loadConfiguration(void)
{
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
    20de:	80 91 b7 0e 	lds	r24, 0x0EB7
    20e2:	90 91 b8 0e 	lds	r25, 0x0EB8
    20e6:	60 e0       	ldi	r22, 0x00	; 0
    20e8:	70 e0       	ldi	r23, 0x00	; 0
    20ea:	48 e1       	ldi	r20, 0x18	; 24
    20ec:	50 e0       	ldi	r21, 0x00	; 0
    20ee:	0e 94 c3 77 	call	0xef86	; 0xef86 <__eerd_block_m128>
}
    20f2:	08 95       	ret

000020f4 <initQueueStreamUSB>:
#define debug 1

/*-----------------------------------------------------------*/

void initQueueStreamUSB(FILE *stream)
{
    20f4:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
    20f6:	84 e4       	ldi	r24, 0x44	; 68
    20f8:	91 e1       	ldi	r25, 0x11	; 17
    20fa:	91 87       	std	Z+9, r25	; 0x09
    20fc:	80 87       	std	Z+8, r24	; 0x08
    20fe:	80 e3       	ldi	r24, 0x30	; 48
    2100:	92 e1       	ldi	r25, 0x12	; 18
    2102:	93 87       	std	Z+11, r25	; 0x0b
    2104:	82 87       	std	Z+10, r24	; 0x0a
    2106:	83 e0       	ldi	r24, 0x03	; 3
    2108:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, NULL);
    210a:	15 86       	std	Z+13, r1	; 0x0d
    210c:	14 86       	std	Z+12, r1	; 0x0c
  return;
}
    210e:	08 95       	ret

00002110 <__vector_20>:
    taskYIELD();
  }
}

ISR(USART0_TX_vect)
{
    2110:	1f 92       	push	r1
    2112:	0f 92       	push	r0
    2114:	0f b6       	in	r0, 0x3f	; 63
    2116:	0f 92       	push	r0
    2118:	11 24       	eor	r1, r1
    211a:	8f 93       	push	r24
  if (!vIsInterruptRs485On())
    211c:	55 99       	sbic	0x0a, 5	; 10
    211e:	05 c0       	rjmp	.+10     	; 0x212a <__vector_20+0x1a>
    Rs485TxStop();
    2120:	80 91 65 00 	lds	r24, 0x0065
    2124:	8f 7e       	andi	r24, 0xEF	; 239
    2126:	80 93 65 00 	sts	0x0065, r24
}
    212a:	8f 91       	pop	r24
    212c:	0f 90       	pop	r0
    212e:	0f be       	out	0x3f, r0	; 63
    2130:	0f 90       	pop	r0
    2132:	1f 90       	pop	r1
    2134:	18 95       	reti

00002136 <InterruptVtyOn>:
}

void InterruptVtyOn(void)
{                                  
  unsigned portCHAR ucByte;                                       
  ucByte = UCSR1B;                 
    2136:	ea e9       	ldi	r30, 0x9A	; 154
    2138:	f0 e0       	ldi	r31, 0x00	; 0
    213a:	80 81       	ld	r24, Z
  ucByte |= serDATA_INT_ENABLE;    
    213c:	80 62       	ori	r24, 0x20	; 32
  UCSR1B = ucByte;                 
    213e:	80 83       	st	Z, r24
}
    2140:	08 95       	ret

00002142 <__vector_31>:
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
  vInterruptVtyOn();
}

ISR(USART1_UDRE_vect)
{
    2142:	1f 92       	push	r1
    2144:	0f 92       	push	r0
    2146:	0f b6       	in	r0, 0x3f	; 63
    2148:	0f 92       	push	r0
    214a:	0b b6       	in	r0, 0x3b	; 59
    214c:	0f 92       	push	r0
    214e:	11 24       	eor	r1, r1
    2150:	2f 93       	push	r18
    2152:	3f 93       	push	r19
    2154:	4f 93       	push	r20
    2156:	5f 93       	push	r21
    2158:	6f 93       	push	r22
    215a:	7f 93       	push	r23
    215c:	8f 93       	push	r24
    215e:	9f 93       	push	r25
    2160:	af 93       	push	r26
    2162:	bf 93       	push	r27
    2164:	ef 93       	push	r30
    2166:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
    2168:	80 91 92 0e 	lds	r24, 0x0E92
    216c:	90 91 93 0e 	lds	r25, 0x0E93
    2170:	69 e8       	ldi	r22, 0x89	; 137
    2172:	71 e0       	ldi	r23, 0x01	; 1
    2174:	4a e8       	ldi	r20, 0x8A	; 138
    2176:	51 e0       	ldi	r21, 0x01	; 1
    2178:	0e 94 e3 6a 	call	0xd5c6	; 0xd5c6 <xQueueReceiveFromISR>
    217c:	81 30       	cpi	r24, 0x01	; 1
    217e:	29 f4       	brne	.+10     	; 0x218a <__vector_31+0x48>
  {
    UDR1 = data; 
    2180:	80 91 89 01 	lds	r24, 0x0189
    2184:	80 93 9c 00 	sts	0x009C, r24
    2188:	07 c0       	rjmp	.+14     	; 0x2198 <__vector_31+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    218a:	10 92 8a 01 	sts	0x018A, r1
    vInterruptVtyOff();
    218e:	80 91 9a 00 	lds	r24, 0x009A
    2192:	8f 7d       	andi	r24, 0xDF	; 223
    2194:	80 93 9a 00 	sts	0x009A, r24
  }
  if( xHigherPriorityTaskWoken )
    2198:	80 91 8a 01 	lds	r24, 0x018A
    219c:	88 23       	and	r24, r24
    219e:	11 f0       	breq	.+4      	; 0x21a4 <__vector_31+0x62>
  {
    taskYIELD();
    21a0:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
  }
}
    21a4:	ff 91       	pop	r31
    21a6:	ef 91       	pop	r30
    21a8:	bf 91       	pop	r27
    21aa:	af 91       	pop	r26
    21ac:	9f 91       	pop	r25
    21ae:	8f 91       	pop	r24
    21b0:	7f 91       	pop	r23
    21b2:	6f 91       	pop	r22
    21b4:	5f 91       	pop	r21
    21b6:	4f 91       	pop	r20
    21b8:	3f 91       	pop	r19
    21ba:	2f 91       	pop	r18
    21bc:	0f 90       	pop	r0
    21be:	0b be       	out	0x3b, r0	; 59
    21c0:	0f 90       	pop	r0
    21c2:	0f be       	out	0x3f, r0	; 63
    21c4:	0f 90       	pop	r0
    21c6:	1f 90       	pop	r1
    21c8:	18 95       	reti

000021ca <__vector_19>:
{
  return xQueueReceive(xRs485Rec, c, timeout);
}

ISR(USART0_UDRE_vect)
{
    21ca:	1f 92       	push	r1
    21cc:	0f 92       	push	r0
    21ce:	0f b6       	in	r0, 0x3f	; 63
    21d0:	0f 92       	push	r0
    21d2:	0b b6       	in	r0, 0x3b	; 59
    21d4:	0f 92       	push	r0
    21d6:	11 24       	eor	r1, r1
    21d8:	2f 93       	push	r18
    21da:	3f 93       	push	r19
    21dc:	4f 93       	push	r20
    21de:	5f 93       	push	r21
    21e0:	6f 93       	push	r22
    21e2:	7f 93       	push	r23
    21e4:	8f 93       	push	r24
    21e6:	9f 93       	push	r25
    21e8:	af 93       	push	r26
    21ea:	bf 93       	push	r27
    21ec:	ef 93       	push	r30
    21ee:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  static char data;
  if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
    21f0:	80 91 dc 0e 	lds	r24, 0x0EDC
    21f4:	90 91 dd 0e 	lds	r25, 0x0EDD
    21f8:	6c e8       	ldi	r22, 0x8C	; 140
    21fa:	71 e0       	ldi	r23, 0x01	; 1
    21fc:	4d e8       	ldi	r20, 0x8D	; 141
    21fe:	51 e0       	ldi	r21, 0x01	; 1
    2200:	0e 94 e3 6a 	call	0xd5c6	; 0xd5c6 <xQueueReceiveFromISR>
    2204:	81 30       	cpi	r24, 0x01	; 1
    2206:	49 f4       	brne	.+18     	; 0x221a <__vector_19+0x50>
  {
    Rs485TxStart();
    2208:	80 91 65 00 	lds	r24, 0x0065
    220c:	80 61       	ori	r24, 0x10	; 16
    220e:	80 93 65 00 	sts	0x0065, r24
    UDR0 = data; 
    2212:	80 91 8c 01 	lds	r24, 0x018C
    2216:	8c b9       	out	0x0c, r24	; 12
    2218:	03 c0       	rjmp	.+6      	; 0x2220 <__vector_19+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    221a:	10 92 8d 01 	sts	0x018D, r1
    vInterruptRs485Off();
    221e:	55 98       	cbi	0x0a, 5	; 10
  }
  if( xHigherPriorityTaskWoken )
    2220:	80 91 8d 01 	lds	r24, 0x018D
    2224:	88 23       	and	r24, r24
    2226:	11 f0       	breq	.+4      	; 0x222c <__vector_19+0x62>
  {
    taskYIELD();
    2228:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
  }
}
    222c:	ff 91       	pop	r31
    222e:	ef 91       	pop	r30
    2230:	bf 91       	pop	r27
    2232:	af 91       	pop	r26
    2234:	9f 91       	pop	r25
    2236:	8f 91       	pop	r24
    2238:	7f 91       	pop	r23
    223a:	6f 91       	pop	r22
    223c:	5f 91       	pop	r21
    223e:	4f 91       	pop	r20
    2240:	3f 91       	pop	r19
    2242:	2f 91       	pop	r18
    2244:	0f 90       	pop	r0
    2246:	0b be       	out	0x3b, r0	; 59
    2248:	0f 90       	pop	r0
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	0f 90       	pop	r0
    224e:	1f 90       	pop	r1
    2250:	18 95       	reti

00002252 <uartVtySendByte>:
    taskYIELD();
  }
}

void uartVtySendByte(uint8_t data)
{
    2252:	df 93       	push	r29
    2254:	cf 93       	push	r28
    2256:	0f 92       	push	r0
    2258:	cd b7       	in	r28, 0x3d	; 61
    225a:	de b7       	in	r29, 0x3e	; 62
    225c:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
    225e:	80 91 92 0e 	lds	r24, 0x0E92
    2262:	90 91 93 0e 	lds	r25, 0x0E93
    2266:	be 01       	movw	r22, r28
    2268:	6f 5f       	subi	r22, 0xFF	; 255
    226a:	7f 4f       	sbci	r23, 0xFF	; 255
    226c:	4f ef       	ldi	r20, 0xFF	; 255
    226e:	5f ef       	ldi	r21, 0xFF	; 255
    2270:	20 e0       	ldi	r18, 0x00	; 0
    2272:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>
  vInterruptVtyOn();
    2276:	ea e9       	ldi	r30, 0x9A	; 154
    2278:	f0 e0       	ldi	r31, 0x00	; 0
    227a:	80 81       	ld	r24, Z
    227c:	80 62       	ori	r24, 0x20	; 32
    227e:	80 83       	st	Z, r24
}
    2280:	0f 90       	pop	r0
    2282:	cf 91       	pop	r28
    2284:	df 91       	pop	r29
    2286:	08 95       	ret

00002288 <VtyPutChar>:
}

int VtyPutChar(char c, FILE *stream)
{
  stream = NULL;
  uartVtySendByte(c);
    2288:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
  return 0;
}
    228c:	80 e0       	ldi	r24, 0x00	; 0
    228e:	90 e0       	ldi	r25, 0x00	; 0
    2290:	08 95       	ret

00002292 <releaseRs485>:
    2292:	80 91 c6 0e 	lds	r24, 0x0EC6
    2296:	90 91 c7 0e 	lds	r25, 0x0EC7
    229a:	60 e0       	ldi	r22, 0x00	; 0
    229c:	70 e0       	ldi	r23, 0x00	; 0
    229e:	40 e0       	ldi	r20, 0x00	; 0
    22a0:	50 e0       	ldi	r21, 0x00	; 0
    22a2:	20 e0       	ldi	r18, 0x00	; 0
    22a4:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>
    22a8:	08 95       	ret

000022aa <uartRs485SendByte>:
    22aa:	df 93       	push	r29
    22ac:	cf 93       	push	r28
    22ae:	0f 92       	push	r0
    22b0:	cd b7       	in	r28, 0x3d	; 61
    22b2:	de b7       	in	r29, 0x3e	; 62
    22b4:	89 83       	std	Y+1, r24	; 0x01
    22b6:	80 91 dc 0e 	lds	r24, 0x0EDC
    22ba:	90 91 dd 0e 	lds	r25, 0x0EDD
    22be:	be 01       	movw	r22, r28
    22c0:	6f 5f       	subi	r22, 0xFF	; 255
    22c2:	7f 4f       	sbci	r23, 0xFF	; 255
    22c4:	4f ef       	ldi	r20, 0xFF	; 255
    22c6:	5f ef       	ldi	r21, 0xFF	; 255
    22c8:	20 e0       	ldi	r18, 0x00	; 0
    22ca:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>
    22ce:	55 9a       	sbi	0x0a, 5	; 10
    22d0:	0f 90       	pop	r0
    22d2:	cf 91       	pop	r28
    22d4:	df 91       	pop	r29
    22d6:	08 95       	ret

000022d8 <__vector_30>:
  UCSR1B = ucByte;                 
}

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    22d8:	1f 92       	push	r1
    22da:	0f 92       	push	r0
    22dc:	0f b6       	in	r0, 0x3f	; 63
    22de:	0f 92       	push	r0
    22e0:	0b b6       	in	r0, 0x3b	; 59
    22e2:	0f 92       	push	r0
    22e4:	11 24       	eor	r1, r1
    22e6:	2f 93       	push	r18
    22e8:	3f 93       	push	r19
    22ea:	4f 93       	push	r20
    22ec:	5f 93       	push	r21
    22ee:	6f 93       	push	r22
    22f0:	7f 93       	push	r23
    22f2:	8f 93       	push	r24
    22f4:	9f 93       	push	r25
    22f6:	af 93       	push	r26
    22f8:	bf 93       	push	r27
    22fa:	ef 93       	push	r30
    22fc:	ff 93       	push	r31
    22fe:	df 93       	push	r29
    2300:	cf 93       	push	r28
    2302:	0f 92       	push	r0
    2304:	cd b7       	in	r28, 0x3d	; 61
    2306:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 
  signed portCHAR cChar;

  cChar = UDR1;
    2308:	80 91 9c 00 	lds	r24, 0x009C
    230c:	89 83       	std	Y+1, r24	; 0x01
//  xQueueSendFromISR(xVtyRec, &cChar, NULL);

  xHigherPriorityTaskWoken = pdFALSE;
    230e:	10 92 8b 01 	sts	0x018B, r1
  xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
    2312:	80 91 c4 0e 	lds	r24, 0x0EC4
    2316:	90 91 c5 0e 	lds	r25, 0x0EC5
    231a:	be 01       	movw	r22, r28
    231c:	6f 5f       	subi	r22, 0xFF	; 255
    231e:	7f 4f       	sbci	r23, 0xFF	; 255
    2320:	4b e8       	ldi	r20, 0x8B	; 139
    2322:	51 e0       	ldi	r21, 0x01	; 1
    2324:	20 e0       	ldi	r18, 0x00	; 0
    2326:	0e 94 63 6b 	call	0xd6c6	; 0xd6c6 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    232a:	80 91 8b 01 	lds	r24, 0x018B
    232e:	88 23       	and	r24, r24
    2330:	11 f0       	breq	.+4      	; 0x2336 <__vector_30+0x5e>
  {
    taskYIELD();
    2332:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
  }
}
    2336:	0f 90       	pop	r0
    2338:	cf 91       	pop	r28
    233a:	df 91       	pop	r29
    233c:	ff 91       	pop	r31
    233e:	ef 91       	pop	r30
    2340:	bf 91       	pop	r27
    2342:	af 91       	pop	r26
    2344:	9f 91       	pop	r25
    2346:	8f 91       	pop	r24
    2348:	7f 91       	pop	r23
    234a:	6f 91       	pop	r22
    234c:	5f 91       	pop	r21
    234e:	4f 91       	pop	r20
    2350:	3f 91       	pop	r19
    2352:	2f 91       	pop	r18
    2354:	0f 90       	pop	r0
    2356:	0b be       	out	0x3b, r0	; 59
    2358:	0f 90       	pop	r0
    235a:	0f be       	out	0x3f, r0	; 63
    235c:	0f 90       	pop	r0
    235e:	1f 90       	pop	r1
    2360:	18 95       	reti

00002362 <__vector_18>:
  return;
}

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    2362:	1f 92       	push	r1
    2364:	0f 92       	push	r0
    2366:	0f b6       	in	r0, 0x3f	; 63
    2368:	0f 92       	push	r0
    236a:	0b b6       	in	r0, 0x3b	; 59
    236c:	0f 92       	push	r0
    236e:	11 24       	eor	r1, r1
    2370:	2f 93       	push	r18
    2372:	3f 93       	push	r19
    2374:	4f 93       	push	r20
    2376:	5f 93       	push	r21
    2378:	6f 93       	push	r22
    237a:	7f 93       	push	r23
    237c:	8f 93       	push	r24
    237e:	9f 93       	push	r25
    2380:	af 93       	push	r26
    2382:	bf 93       	push	r27
    2384:	ef 93       	push	r30
    2386:	ff 93       	push	r31
    2388:	df 93       	push	r29
    238a:	cf 93       	push	r28
    238c:	0f 92       	push	r0
    238e:	cd b7       	in	r28, 0x3d	; 61
    2390:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE; 
  signed portCHAR cChar;

  cChar = UDR0;
    2392:	8c b1       	in	r24, 0x0c	; 12
    2394:	89 83       	std	Y+1, r24	; 0x01

  xHigherPriorityTaskWoken = pdFALSE;
    2396:	10 92 01 01 	sts	0x0101, r1

//  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
    239a:	80 91 b3 0e 	lds	r24, 0x0EB3
    239e:	90 91 b4 0e 	lds	r25, 0x0EB4
    23a2:	be 01       	movw	r22, r28
    23a4:	6f 5f       	subi	r22, 0xFF	; 255
    23a6:	7f 4f       	sbci	r23, 0xFF	; 255
    23a8:	41 e0       	ldi	r20, 0x01	; 1
    23aa:	51 e0       	ldi	r21, 0x01	; 1
    23ac:	20 e0       	ldi	r18, 0x00	; 0
    23ae:	0e 94 63 6b 	call	0xd6c6	; 0xd6c6 <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    23b2:	80 91 01 01 	lds	r24, 0x0101
    23b6:	88 23       	and	r24, r24
    23b8:	11 f0       	breq	.+4      	; 0x23be <__vector_18+0x5c>
  {
    taskYIELD();
    23ba:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
  }
}
    23be:	0f 90       	pop	r0
    23c0:	cf 91       	pop	r28
    23c2:	df 91       	pop	r29
    23c4:	ff 91       	pop	r31
    23c6:	ef 91       	pop	r30
    23c8:	bf 91       	pop	r27
    23ca:	af 91       	pop	r26
    23cc:	9f 91       	pop	r25
    23ce:	8f 91       	pop	r24
    23d0:	7f 91       	pop	r23
    23d2:	6f 91       	pop	r22
    23d4:	5f 91       	pop	r21
    23d6:	4f 91       	pop	r20
    23d8:	3f 91       	pop	r19
    23da:	2f 91       	pop	r18
    23dc:	0f 90       	pop	r0
    23de:	0b be       	out	0x3b, r0	; 59
    23e0:	0f 90       	pop	r0
    23e2:	0f be       	out	0x3f, r0	; 63
    23e4:	0f 90       	pop	r0
    23e6:	1f 90       	pop	r1
    23e8:	18 95       	reti

000023ea <takeRs485>:
    23ea:	80 91 c6 0e 	lds	r24, 0x0EC6
    23ee:	90 91 c7 0e 	lds	r25, 0x0EC7
    23f2:	60 e0       	ldi	r22, 0x00	; 0
    23f4:	70 e0       	ldi	r23, 0x00	; 0
    23f6:	4f ef       	ldi	r20, 0xFF	; 255
    23f8:	5f ef       	ldi	r21, 0xFF	; 255
    23fa:	20 e0       	ldi	r18, 0x00	; 0
    23fc:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    2400:	08 95       	ret

00002402 <flushRs485RecBuffer>:
    2402:	ef 92       	push	r14
    2404:	ff 92       	push	r15
    2406:	1f 93       	push	r17
    2408:	df 93       	push	r29
    240a:	cf 93       	push	r28
    240c:	0f 92       	push	r0
    240e:	cd b7       	in	r28, 0x3d	; 61
    2410:	de b7       	in	r29, 0x3e	; 62
    2412:	10 e0       	ldi	r17, 0x00	; 0
    2414:	7e 01       	movw	r14, r28
    2416:	08 94       	sec
    2418:	e1 1c       	adc	r14, r1
    241a:	f1 1c       	adc	r15, r1
    241c:	01 c0       	rjmp	.+2      	; 0x2420 <flushRs485RecBuffer+0x1e>
    241e:	1f 5f       	subi	r17, 0xFF	; 255
    2420:	80 91 b3 0e 	lds	r24, 0x0EB3
    2424:	90 91 b4 0e 	lds	r25, 0x0EB4
    2428:	b7 01       	movw	r22, r14
    242a:	4a e0       	ldi	r20, 0x0A	; 10
    242c:	50 e0       	ldi	r21, 0x00	; 0
    242e:	20 e0       	ldi	r18, 0x00	; 0
    2430:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    2434:	81 30       	cpi	r24, 0x01	; 1
    2436:	99 f3       	breq	.-26     	; 0x241e <flushRs485RecBuffer+0x1c>
    2438:	81 2f       	mov	r24, r17
    243a:	0f 90       	pop	r0
    243c:	cf 91       	pop	r28
    243e:	df 91       	pop	r29
    2440:	1f 91       	pop	r17
    2442:	ff 90       	pop	r15
    2444:	ef 90       	pop	r14
    2446:	08 95       	ret

00002448 <rs485Receive>:
    2448:	9c 01       	movw	r18, r24
    244a:	46 2f       	mov	r20, r22
    244c:	80 91 b3 0e 	lds	r24, 0x0EB3
    2450:	90 91 b4 0e 	lds	r25, 0x0EB4
    2454:	b9 01       	movw	r22, r18
    2456:	50 e0       	ldi	r21, 0x00	; 0
    2458:	20 e0       	ldi	r18, 0x00	; 0
    245a:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    245e:	08 95       	ret

00002460 <VtyGetChar>:
  fdev_set_udata(stream, NULL);
  return;
}

int VtyGetChar(FILE *stream)
{
    2460:	df 93       	push	r29
    2462:	cf 93       	push	r28
    2464:	0f 92       	push	r0
    2466:	cd b7       	in	r28, 0x3d	; 61
    2468:	de b7       	in	r29, 0x3e	; 62
  stream = NULL;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    246a:	80 91 c4 0e 	lds	r24, 0x0EC4
    246e:	90 91 c5 0e 	lds	r25, 0x0EC5
    2472:	be 01       	movw	r22, r28
    2474:	6f 5f       	subi	r22, 0xFF	; 255
    2476:	7f 4f       	sbci	r23, 0xFF	; 255
    2478:	4f ef       	ldi	r20, 0xFF	; 255
    247a:	5f ef       	ldi	r21, 0xFF	; 255
    247c:	20 e0       	ldi	r18, 0x00	; 0
    247e:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    2482:	88 23       	and	r24, r24
    2484:	19 f4       	brne	.+6      	; 0x248c <VtyGetChar+0x2c>
    2486:	2f ef       	ldi	r18, 0xFF	; 255
    2488:	3f ef       	ldi	r19, 0xFF	; 255
    248a:	03 c0       	rjmp	.+6      	; 0x2492 <VtyGetChar+0x32>
    return EOF;
  return c;
    248c:	89 81       	ldd	r24, Y+1	; 0x01
    248e:	28 2f       	mov	r18, r24
    2490:	30 e0       	ldi	r19, 0x00	; 0
}
    2492:	c9 01       	movw	r24, r18
    2494:	0f 90       	pop	r0
    2496:	cf 91       	pop	r28
    2498:	df 91       	pop	r29
    249a:	08 95       	ret

0000249c <xSerialPortInitMinimal>:
  return 0;
}

void xSerialPortInitMinimal(void)
{
  portENTER_CRITICAL();
    249c:	0f b6       	in	r0, 0x3f	; 63
    249e:	f8 94       	cli
    24a0:	0f 92       	push	r0
  {
    xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    24a2:	80 e4       	ldi	r24, 0x40	; 64
    24a4:	61 e0       	ldi	r22, 0x01	; 1
    24a6:	0e 94 8f 6d 	call	0xdb1e	; 0xdb1e <xQueueCreate>
    24aa:	90 93 c5 0e 	sts	0x0EC5, r25
    24ae:	80 93 c4 0e 	sts	0x0EC4, r24
    xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    24b2:	80 e2       	ldi	r24, 0x20	; 32
    24b4:	61 e0       	ldi	r22, 0x01	; 1
    24b6:	0e 94 8f 6d 	call	0xdb1e	; 0xdb1e <xQueueCreate>
    24ba:	90 93 93 0e 	sts	0x0E93, r25
    24be:	80 93 92 0e 	sts	0x0E92, r24
    xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    24c2:	80 e1       	ldi	r24, 0x10	; 16
    24c4:	61 e0       	ldi	r22, 0x01	; 1
    24c6:	0e 94 8f 6d 	call	0xdb1e	; 0xdb1e <xQueueCreate>
    24ca:	90 93 b4 0e 	sts	0x0EB4, r25
    24ce:	80 93 b3 0e 	sts	0x0EB3, r24
    xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    24d2:	84 e0       	ldi	r24, 0x04	; 4
    24d4:	61 e0       	ldi	r22, 0x01	; 1
    24d6:	0e 94 8f 6d 	call	0xdb1e	; 0xdb1e <xQueueCreate>
    24da:	90 93 dd 0e 	sts	0x0EDD, r25
    24de:	80 93 dc 0e 	sts	0x0EDC, r24
    
    vSemaphoreCreateBinary(xSemaphoreRs485); 
    24e2:	81 e0       	ldi	r24, 0x01	; 1
    24e4:	60 e0       	ldi	r22, 0x00	; 0
    24e6:	0e 94 8f 6d 	call	0xdb1e	; 0xdb1e <xQueueCreate>
    24ea:	90 93 c7 0e 	sts	0x0EC7, r25
    24ee:	80 93 c6 0e 	sts	0x0EC6, r24
    24f2:	00 97       	sbiw	r24, 0x00	; 0
    24f4:	39 f0       	breq	.+14     	; 0x2504 <xSerialPortInitMinimal+0x68>
    24f6:	60 e0       	ldi	r22, 0x00	; 0
    24f8:	70 e0       	ldi	r23, 0x00	; 0
    24fa:	40 e0       	ldi	r20, 0x00	; 0
    24fc:	50 e0       	ldi	r21, 0x00	; 0
    24fe:	20 e0       	ldi	r18, 0x00	; 0
    2500:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
    2504:	0f 90       	pop	r0
    2506:	0f be       	out	0x3f, r0	; 63
  
  UBRR0L = 7;
    2508:	87 e0       	ldi	r24, 0x07	; 7
    250a:	89 b9       	out	0x09, r24	; 9
  UBRR0H = 0;
    250c:	10 92 90 00 	sts	0x0090, r1

  UBRR1L = 7;
    2510:	80 93 99 00 	sts	0x0099, r24
  UBRR1H = 0;
    2514:	10 92 98 00 	sts	0x0098, r1

  UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
    2518:	88 ed       	ldi	r24, 0xD8	; 216
    251a:	8a b9       	out	0x0a, r24	; 10
  UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    251c:	96 e8       	ldi	r25, 0x86	; 134
    251e:	90 93 95 00 	sts	0x0095, r25
  UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
    2522:	88 e9       	ldi	r24, 0x98	; 152
    2524:	80 93 9a 00 	sts	0x009A, r24
  UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    2528:	90 93 9d 00 	sts	0x009D, r25
  return;
}
    252c:	08 95       	ret

0000252e <spiSendSpinBlock>:
    252e:	8f b9       	out	0x0f, r24	; 15
    2530:	6f 98       	cbi	0x0d, 7	; 13
    2532:	77 9b       	sbis	0x0e, 7	; 14
    2534:	fe cf       	rjmp	.-4      	; 0x2532 <spiSendSpinBlock+0x4>
    2536:	8e b1       	in	r24, 0x0e	; 14
    2538:	8f b1       	in	r24, 0x0f	; 15
    253a:	6f 9a       	sbi	0x0d, 7	; 13
    253c:	08 95       	ret

0000253e <disableAllSpiDevices>:
#error Port A is memory bus
  PORTA &= disableSpiPORTA_AND;
#endif

#if disableSpiPORTB_OR != 0
  PORTB |= disableSpiPORTB_OR;
    253e:	88 b3       	in	r24, 0x18	; 24
    2540:	80 6c       	ori	r24, 0xC0	; 192
    2542:	88 bb       	out	0x18, r24	; 24
#endif
#if disableSpiPORTB_AND != 0xFF
  PORTB &= disableSpiPORTB_AND;
    2544:	c5 98       	cbi	0x18, 5	; 24
#endif
#if disableSpiPORTD_AND != 0xFF
  PORTD &= disableSpiPORTD_AND;
#endif
#if disableSpiPORTE_OR != 0
  PORTE |= disableSpiPORTE_OR;
    2546:	1b 9a       	sbi	0x03, 3	; 3
#if disableSpiPORTF_AND != 0xFF
  PORTF &= disableSpiPORTF_AND;
#endif

#if disableSpiPORTG_OR != 0
  PORTG |= disableSpiPORTG_OR;
    2548:	e5 e6       	ldi	r30, 0x65	; 101
    254a:	f0 e0       	ldi	r31, 0x00	; 0
    254c:	80 81       	ld	r24, Z
    254e:	88 60       	ori	r24, 0x08	; 8
    2550:	80 83       	st	Z, r24
#endif
#if disableSpiPORTG_AND != 0xFF
  PORTG &= disableSpiPORTG_AND;
#endif
}
    2552:	08 95       	ret

00002554 <spiEnableEnc28j60>:
    2554:	1b 98       	cbi	0x03, 3	; 3
    2556:	08 95       	ret

00002558 <spiDisableEnc28j60>:
    2558:	1b 9a       	sbi	0x03, 3	; 3
    255a:	08 95       	ret

0000255c <enableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
    255c:	e5 e6       	ldi	r30, 0x65	; 101
    255e:	f0 e0       	ldi	r31, 0x00	; 0
    2560:	80 81       	ld	r24, Z
    2562:	87 7f       	andi	r24, 0xF7	; 247
    2564:	80 83       	st	Z, r24
#endif   
}
    2566:	08 95       	ret

00002568 <disableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
    2568:	e5 e6       	ldi	r30, 0x65	; 101
    256a:	f0 e0       	ldi	r31, 0x00	; 0
    256c:	80 81       	ld	r24, Z
    256e:	88 60       	ori	r24, 0x08	; 8
    2570:	80 83       	st	Z, r24
#endif  
}
    2572:	08 95       	ret

00002574 <enableSpiMPC23S17>:
    2574:	c7 98       	cbi	0x18, 7	; 24
    2576:	08 95       	ret

00002578 <disableSpiMPC23S17>:
    2578:	c7 9a       	sbi	0x18, 7	; 24
    257a:	08 95       	ret

0000257c <enableSpiMCP3008>:
    257c:	8d b1       	in	r24, 0x0d	; 13
    257e:	83 60       	ori	r24, 0x03	; 3
    2580:	8d b9       	out	0x0d, r24	; 13
    2582:	c6 98       	cbi	0x18, 6	; 24
    2584:	08 95       	ret

00002586 <disableSpiMCP3008>:
    2586:	8d b1       	in	r24, 0x0d	; 13
    2588:	8c 7f       	andi	r24, 0xFC	; 252
    258a:	8d b9       	out	0x0d, r24	; 13
    258c:	c6 9a       	sbi	0x18, 6	; 24
    258e:	08 95       	ret

00002590 <enableSpiMCP4150>:
    2590:	8d b1       	in	r24, 0x0d	; 13
    2592:	83 60       	ori	r24, 0x03	; 3
    2594:	8d b9       	out	0x0d, r24	; 13
    2596:	c6 98       	cbi	0x18, 6	; 24
    2598:	08 95       	ret

0000259a <disableSpiMCP4150>:
    259a:	8d b1       	in	r24, 0x0d	; 13
    259c:	8c 7f       	andi	r24, 0xFC	; 252
    259e:	8d b9       	out	0x0d, r24	; 13
    25a0:	c6 9a       	sbi	0x18, 6	; 24
    25a2:	08 95       	ret

000025a4 <spiEnableDS1305>:
    25a4:	8d b1       	in	r24, 0x0d	; 13
    25a6:	85 60       	ori	r24, 0x05	; 5
    25a8:	8d b9       	out	0x0d, r24	; 13
    25aa:	c5 9a       	sbi	0x18, 5	; 24
    25ac:	08 95       	ret

000025ae <spiDisableDS1305>:
    25ae:	8d b1       	in	r24, 0x0d	; 13
    25b0:	8a 7f       	andi	r24, 0xFA	; 250
    25b2:	8d b9       	out	0x0d, r24	; 13
    25b4:	c5 98       	cbi	0x18, 5	; 24
    25b6:	08 95       	ret

000025b8 <__vector_17>:
  DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
#endif  
}

ISR(SPI_STC_vect)
{
    25b8:	1f 92       	push	r1
    25ba:	0f 92       	push	r0
    25bc:	0f b6       	in	r0, 0x3f	; 63
    25be:	0f 92       	push	r0
    25c0:	0b b6       	in	r0, 0x3b	; 59
    25c2:	0f 92       	push	r0
    25c4:	11 24       	eor	r1, r1
    25c6:	2f 93       	push	r18
    25c8:	3f 93       	push	r19
    25ca:	4f 93       	push	r20
    25cc:	5f 93       	push	r21
    25ce:	6f 93       	push	r22
    25d0:	7f 93       	push	r23
    25d2:	8f 93       	push	r24
    25d4:	9f 93       	push	r25
    25d6:	af 93       	push	r26
    25d8:	bf 93       	push	r27
    25da:	ef 93       	push	r30
    25dc:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken; 

  static uint8_t data;
  data = SPDR;
    25de:	8f b1       	in	r24, 0x0f	; 15
    25e0:	80 93 8e 01 	sts	0x018E, r24
  
  xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
    25e4:	80 91 7f 0f 	lds	r24, 0x0F7F
    25e8:	90 91 80 0f 	lds	r25, 0x0F80
    25ec:	6e e8       	ldi	r22, 0x8E	; 142
    25ee:	71 e0       	ldi	r23, 0x01	; 1
    25f0:	4f e8       	ldi	r20, 0x8F	; 143
    25f2:	51 e0       	ldi	r21, 0x01	; 1
    25f4:	20 e0       	ldi	r18, 0x00	; 0
    25f6:	0e 94 63 6b 	call	0xd6c6	; 0xd6c6 <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    25fa:	80 91 8f 01 	lds	r24, 0x018F
    25fe:	88 23       	and	r24, r24
    2600:	11 f0       	breq	.+4      	; 0x2606 <__vector_17+0x4e>
  {
    taskYIELD();
    2602:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
  }
  
  //clear SPI interrupt SPI |= 1;
}
    2606:	ff 91       	pop	r31
    2608:	ef 91       	pop	r30
    260a:	bf 91       	pop	r27
    260c:	af 91       	pop	r26
    260e:	9f 91       	pop	r25
    2610:	8f 91       	pop	r24
    2612:	7f 91       	pop	r23
    2614:	6f 91       	pop	r22
    2616:	5f 91       	pop	r21
    2618:	4f 91       	pop	r20
    261a:	3f 91       	pop	r19
    261c:	2f 91       	pop	r18
    261e:	0f 90       	pop	r0
    2620:	0b be       	out	0x3b, r0	; 59
    2622:	0f 90       	pop	r0
    2624:	0f be       	out	0x3f, r0	; 63
    2626:	0f 90       	pop	r0
    2628:	1f 90       	pop	r1
    262a:	18 95       	reti

0000262c <spiSend>:
    262c:	df 93       	push	r29
    262e:	cf 93       	push	r28
    2630:	0f 92       	push	r0
    2632:	cd b7       	in	r28, 0x3d	; 61
    2634:	de b7       	in	r29, 0x3e	; 62
    2636:	8f b9       	out	0x0f, r24	; 15
    2638:	80 91 7f 0f 	lds	r24, 0x0F7F
    263c:	90 91 80 0f 	lds	r25, 0x0F80
    2640:	be 01       	movw	r22, r28
    2642:	6f 5f       	subi	r22, 0xFF	; 255
    2644:	7f 4f       	sbci	r23, 0xFF	; 255
    2646:	4a e0       	ldi	r20, 0x0A	; 10
    2648:	50 e0       	ldi	r21, 0x00	; 0
    264a:	20 e0       	ldi	r18, 0x00	; 0
    264c:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    2650:	89 81       	ldd	r24, Y+1	; 0x01
    2652:	0f 90       	pop	r0
    2654:	cf 91       	pop	r28
    2656:	df 91       	pop	r29
    2658:	08 95       	ret

0000265a <checkLockerSensors>:
  }
  return result;
}

void checkLockerSensors(void)
{
    265a:	0f 93       	push	r16
    265c:	1f 93       	push	r17
  if (lockSensors[0].enabled)
    265e:	e0 91 b7 0e 	lds	r30, 0x0EB7
    2662:	f0 91 b8 0e 	lds	r31, 0x0EB8
    2666:	80 81       	ld	r24, Z
    2668:	88 23       	and	r24, r24
    266a:	41 f1       	breq	.+80     	; 0x26bc <checkLockerSensors+0x62>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    266c:	80 e4       	ldi	r24, 0x40	; 64
    266e:	60 e0       	ldi	r22, 0x00	; 0
    2670:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    2674:	8e e1       	ldi	r24, 0x1E	; 30
    2676:	90 e0       	ldi	r25, 0x00	; 0
    2678:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
    267c:	00 91 b7 0e 	lds	r16, 0x0EB7
    2680:	10 91 b8 0e 	lds	r17, 0x0EB8
    2684:	84 e0       	ldi	r24, 0x04	; 4
    2686:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <MCP3008_getSampleSingle>
    268a:	f8 01       	movw	r30, r16
    268c:	94 83       	std	Z+4, r25	; 0x04
    268e:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    2690:	80 e4       	ldi	r24, 0x40	; 64
    2692:	60 e0       	ldi	r22, 0x00	; 0
    2694:	0e 94 99 2e 	call	0x5d32	; 0x5d32 <MPC23s17ClearBitsOnPortA>
    lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
    2698:	e0 91 b7 0e 	lds	r30, 0x0EB7
    269c:	f0 91 b8 0e 	lds	r31, 0x0EB8
    26a0:	40 e0       	ldi	r20, 0x00	; 0
    26a2:	23 81       	ldd	r18, Z+3	; 0x03
    26a4:	34 81       	ldd	r19, Z+4	; 0x04
    26a6:	81 81       	ldd	r24, Z+1	; 0x01
    26a8:	92 81       	ldd	r25, Z+2	; 0x02
    26aa:	82 17       	cp	r24, r18
    26ac:	93 07       	cpc	r25, r19
    26ae:	08 f4       	brcc	.+2      	; 0x26b2 <checkLockerSensors+0x58>
    26b0:	41 e0       	ldi	r20, 0x01	; 1
    26b2:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    26b4:	8a e0       	ldi	r24, 0x0A	; 10
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
  }
  
  if (lockSensors[1].enabled)
    26bc:	e0 91 b7 0e 	lds	r30, 0x0EB7
    26c0:	f0 91 b8 0e 	lds	r31, 0x0EB8
    26c4:	86 81       	ldd	r24, Z+6	; 0x06
    26c6:	88 23       	and	r24, r24
    26c8:	59 f1       	breq	.+86     	; 0x2720 <checkLockerSensors+0xc6>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    26ca:	80 e2       	ldi	r24, 0x20	; 32
    26cc:	60 e0       	ldi	r22, 0x00	; 0
    26ce:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    26d2:	8e e1       	ldi	r24, 0x1E	; 30
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
    26da:	00 91 b7 0e 	lds	r16, 0x0EB7
    26de:	10 91 b8 0e 	lds	r17, 0x0EB8
    26e2:	0a 5f       	subi	r16, 0xFA	; 250
    26e4:	1f 4f       	sbci	r17, 0xFF	; 255
    26e6:	85 e0       	ldi	r24, 0x05	; 5
    26e8:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <MCP3008_getSampleSingle>
    26ec:	f8 01       	movw	r30, r16
    26ee:	94 83       	std	Z+4, r25	; 0x04
    26f0:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    26f2:	80 e2       	ldi	r24, 0x20	; 32
    26f4:	60 e0       	ldi	r22, 0x00	; 0
    26f6:	0e 94 99 2e 	call	0x5d32	; 0x5d32 <MPC23s17ClearBitsOnPortA>
    lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
    26fa:	e0 91 b7 0e 	lds	r30, 0x0EB7
    26fe:	f0 91 b8 0e 	lds	r31, 0x0EB8
    2702:	36 96       	adiw	r30, 0x06	; 6
    2704:	40 e0       	ldi	r20, 0x00	; 0
    2706:	23 81       	ldd	r18, Z+3	; 0x03
    2708:	34 81       	ldd	r19, Z+4	; 0x04
    270a:	81 81       	ldd	r24, Z+1	; 0x01
    270c:	92 81       	ldd	r25, Z+2	; 0x02
    270e:	82 17       	cp	r24, r18
    2710:	93 07       	cpc	r25, r19
    2712:	08 f4       	brcc	.+2      	; 0x2716 <checkLockerSensors+0xbc>
    2714:	41 e0       	ldi	r20, 0x01	; 1
    2716:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    2718:	8a e0       	ldi	r24, 0x0A	; 10
    271a:	90 e0       	ldi	r25, 0x00	; 0
    271c:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
  }
  
  if (lockSensors[2].enabled)
    2720:	e0 91 b7 0e 	lds	r30, 0x0EB7
    2724:	f0 91 b8 0e 	lds	r31, 0x0EB8
    2728:	84 85       	ldd	r24, Z+12	; 0x0c
    272a:	88 23       	and	r24, r24
    272c:	59 f1       	breq	.+86     	; 0x2784 <checkLockerSensors+0x12a>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    272e:	80 e1       	ldi	r24, 0x10	; 16
    2730:	60 e0       	ldi	r22, 0x00	; 0
    2732:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    2736:	8e e1       	ldi	r24, 0x1E	; 30
    2738:	90 e0       	ldi	r25, 0x00	; 0
    273a:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
    273e:	00 91 b7 0e 	lds	r16, 0x0EB7
    2742:	10 91 b8 0e 	lds	r17, 0x0EB8
    2746:	04 5f       	subi	r16, 0xF4	; 244
    2748:	1f 4f       	sbci	r17, 0xFF	; 255
    274a:	86 e0       	ldi	r24, 0x06	; 6
    274c:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <MCP3008_getSampleSingle>
    2750:	f8 01       	movw	r30, r16
    2752:	94 83       	std	Z+4, r25	; 0x04
    2754:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    2756:	80 e1       	ldi	r24, 0x10	; 16
    2758:	60 e0       	ldi	r22, 0x00	; 0
    275a:	0e 94 99 2e 	call	0x5d32	; 0x5d32 <MPC23s17ClearBitsOnPortA>
    lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
    275e:	e0 91 b7 0e 	lds	r30, 0x0EB7
    2762:	f0 91 b8 0e 	lds	r31, 0x0EB8
    2766:	3c 96       	adiw	r30, 0x0c	; 12
    2768:	40 e0       	ldi	r20, 0x00	; 0
    276a:	23 81       	ldd	r18, Z+3	; 0x03
    276c:	34 81       	ldd	r19, Z+4	; 0x04
    276e:	81 81       	ldd	r24, Z+1	; 0x01
    2770:	92 81       	ldd	r25, Z+2	; 0x02
    2772:	82 17       	cp	r24, r18
    2774:	93 07       	cpc	r25, r19
    2776:	08 f4       	brcc	.+2      	; 0x277a <checkLockerSensors+0x120>
    2778:	41 e0       	ldi	r20, 0x01	; 1
    277a:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    277c:	8a e0       	ldi	r24, 0x0A	; 10
    277e:	90 e0       	ldi	r25, 0x00	; 0
    2780:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
  }
  
  if (lockSensors[3].enabled)
    2784:	e0 91 b7 0e 	lds	r30, 0x0EB7
    2788:	f0 91 b8 0e 	lds	r31, 0x0EB8
    278c:	82 89       	ldd	r24, Z+18	; 0x12
    278e:	88 23       	and	r24, r24
    2790:	59 f1       	breq	.+86     	; 0x27e8 <checkLockerSensors+0x18e>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    2792:	88 e0       	ldi	r24, 0x08	; 8
    2794:	60 e0       	ldi	r22, 0x00	; 0
    2796:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    279a:	8e e1       	ldi	r24, 0x1E	; 30
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    27a2:	00 91 b7 0e 	lds	r16, 0x0EB7
    27a6:	10 91 b8 0e 	lds	r17, 0x0EB8
    27aa:	0e 5e       	subi	r16, 0xEE	; 238
    27ac:	1f 4f       	sbci	r17, 0xFF	; 255
    27ae:	87 e0       	ldi	r24, 0x07	; 7
    27b0:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <MCP3008_getSampleSingle>
    27b4:	f8 01       	movw	r30, r16
    27b6:	94 83       	std	Z+4, r25	; 0x04
    27b8:	83 83       	std	Z+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    27ba:	88 e0       	ldi	r24, 0x08	; 8
    27bc:	60 e0       	ldi	r22, 0x00	; 0
    27be:	0e 94 99 2e 	call	0x5d32	; 0x5d32 <MPC23s17ClearBitsOnPortA>
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    27c2:	e0 91 b7 0e 	lds	r30, 0x0EB7
    27c6:	f0 91 b8 0e 	lds	r31, 0x0EB8
    27ca:	72 96       	adiw	r30, 0x12	; 18
    27cc:	40 e0       	ldi	r20, 0x00	; 0
    27ce:	23 81       	ldd	r18, Z+3	; 0x03
    27d0:	34 81       	ldd	r19, Z+4	; 0x04
    27d2:	81 81       	ldd	r24, Z+1	; 0x01
    27d4:	92 81       	ldd	r25, Z+2	; 0x02
    27d6:	82 17       	cp	r24, r18
    27d8:	93 07       	cpc	r25, r19
    27da:	08 f4       	brcc	.+2      	; 0x27de <checkLockerSensors+0x184>
    27dc:	41 e0       	ldi	r20, 0x01	; 1
    27de:	45 83       	std	Z+5, r20	; 0x05
    vTaskDelay(10);
    27e0:	8a e0       	ldi	r24, 0x0A	; 10
    27e2:	90 e0       	ldi	r25, 0x00	; 0
    27e4:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
  }
}
    27e8:	1f 91       	pop	r17
    27ea:	0f 91       	pop	r16
    27ec:	08 95       	ret

000027ee <printLockers>:
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
}

uint8_t printLockers(FILE *stream)
{
    27ee:	4f 92       	push	r4
    27f0:	5f 92       	push	r5
    27f2:	6f 92       	push	r6
    27f4:	7f 92       	push	r7
    27f6:	8f 92       	push	r8
    27f8:	9f 92       	push	r9
    27fa:	af 92       	push	r10
    27fc:	bf 92       	push	r11
    27fe:	df 92       	push	r13
    2800:	ef 92       	push	r14
    2802:	ff 92       	push	r15
    2804:	0f 93       	push	r16
    2806:	1f 93       	push	r17
    2808:	cf 93       	push	r28
    280a:	df 93       	push	r29
    280c:	7c 01       	movw	r14, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
    280e:	00 91 b7 0e 	lds	r16, 0x0EB7
    2812:	10 91 b8 0e 	lds	r17, 0x0EB8
    2816:	dd 24       	eor	r13, r13
    2818:	c0 e0       	ldi	r28, 0x00	; 0
    281a:	d0 e0       	ldi	r29, 0x00	; 0
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    281c:	3c e8       	ldi	r19, 0x8C	; 140
    281e:	43 2e       	mov	r4, r19
    2820:	30 e0       	ldi	r19, 0x00	; 0
    2822:	53 2e       	mov	r5, r19
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    2824:	29 ea       	ldi	r18, 0xA9	; 169
    2826:	62 2e       	mov	r6, r18
    2828:	20 e0       	ldi	r18, 0x00	; 0
    282a:	72 2e       	mov	r7, r18
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
    282c:	90 ea       	ldi	r25, 0xA0	; 160
    282e:	89 2e       	mov	r8, r25
    2830:	90 e0       	ldi	r25, 0x00	; 0
    2832:	99 2e       	mov	r9, r25
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
    2834:	87 e9       	ldi	r24, 0x97	; 151
    2836:	a8 2e       	mov	r10, r24
    2838:	80 e0       	ldi	r24, 0x00	; 0
    283a:	b8 2e       	mov	r11, r24
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    283c:	d8 01       	movw	r26, r16
    283e:	8c 91       	ld	r24, X
    2840:	88 23       	and	r24, r24
    2842:	09 f4       	brne	.+2      	; 0x2846 <printLockers+0x58>
    2844:	6c c0       	rjmp	.+216    	; 0x291e <printLockers+0x130>
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    2846:	00 d0       	rcall	.+0      	; 0x2848 <printLockers+0x5a>
    2848:	00 d0       	rcall	.+0      	; 0x284a <printLockers+0x5c>
    284a:	00 d0       	rcall	.+0      	; 0x284c <printLockers+0x5e>
    284c:	ed b7       	in	r30, 0x3d	; 61
    284e:	fe b7       	in	r31, 0x3e	; 62
    2850:	31 96       	adiw	r30, 0x01	; 1
    2852:	ad b7       	in	r26, 0x3d	; 61
    2854:	be b7       	in	r27, 0x3e	; 62
    2856:	12 96       	adiw	r26, 0x02	; 2
    2858:	fc 92       	st	X, r15
    285a:	ee 92       	st	-X, r14
    285c:	11 97       	sbiw	r26, 0x01	; 1
    285e:	53 82       	std	Z+3, r5	; 0x03
    2860:	42 82       	std	Z+2, r4	; 0x02
    2862:	21 96       	adiw	r28, 0x01	; 1
    2864:	d5 83       	std	Z+5, r29	; 0x05
    2866:	c4 83       	std	Z+4, r28	; 0x04
    2868:	21 97       	sbiw	r28, 0x01	; 1
    286a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      if (tmpLock->threshold > tmpLock->acVal)
    286e:	ed b7       	in	r30, 0x3d	; 61
    2870:	fe b7       	in	r31, 0x3e	; 62
    2872:	36 96       	adiw	r30, 0x06	; 6
    2874:	0f b6       	in	r0, 0x3f	; 63
    2876:	f8 94       	cli
    2878:	fe bf       	out	0x3e, r31	; 62
    287a:	0f be       	out	0x3f, r0	; 63
    287c:	ed bf       	out	0x3d, r30	; 61
    287e:	d8 01       	movw	r26, r16
    2880:	11 96       	adiw	r26, 0x01	; 1
    2882:	2d 91       	ld	r18, X+
    2884:	3c 91       	ld	r19, X
    2886:	12 97       	sbiw	r26, 0x02	; 2
    2888:	13 96       	adiw	r26, 0x03	; 3
    288a:	8d 91       	ld	r24, X+
    288c:	9c 91       	ld	r25, X
    288e:	14 97       	sbiw	r26, 0x04	; 4
    2890:	82 17       	cp	r24, r18
    2892:	93 07       	cpc	r25, r19
    2894:	48 f4       	brcc	.+18     	; 0x28a8 <printLockers+0xba>
        fprintf_P(stream, statusLockerOpenStr);
    2896:	00 d0       	rcall	.+0      	; 0x2898 <printLockers+0xaa>
    2898:	00 d0       	rcall	.+0      	; 0x289a <printLockers+0xac>
    289a:	ed b7       	in	r30, 0x3d	; 61
    289c:	fe b7       	in	r31, 0x3e	; 62
    289e:	f2 82       	std	Z+2, r15	; 0x02
    28a0:	e1 82       	std	Z+1, r14	; 0x01
    28a2:	b4 82       	std	Z+4, r11	; 0x04
    28a4:	a3 82       	std	Z+3, r10	; 0x03
    28a6:	0c c0       	rjmp	.+24     	; 0x28c0 <printLockers+0xd2>
      else
        fprintf_P(stream, statusLockerCloseStr);
    28a8:	00 d0       	rcall	.+0      	; 0x28aa <printLockers+0xbc>
    28aa:	00 d0       	rcall	.+0      	; 0x28ac <printLockers+0xbe>
    28ac:	ad b7       	in	r26, 0x3d	; 61
    28ae:	be b7       	in	r27, 0x3e	; 62
    28b0:	12 96       	adiw	r26, 0x02	; 2
    28b2:	fc 92       	st	X, r15
    28b4:	ee 92       	st	-X, r14
    28b6:	11 97       	sbiw	r26, 0x01	; 1
    28b8:	14 96       	adiw	r26, 0x04	; 4
    28ba:	9c 92       	st	X, r9
    28bc:	8e 92       	st	-X, r8
    28be:	13 97       	sbiw	r26, 0x03	; 3
    28c0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    28c4:	0f 90       	pop	r0
    28c6:	0f 90       	pop	r0
    28c8:	0f 90       	pop	r0
    28ca:	0f 90       	pop	r0
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    28cc:	ed b7       	in	r30, 0x3d	; 61
    28ce:	fe b7       	in	r31, 0x3e	; 62
    28d0:	38 97       	sbiw	r30, 0x08	; 8
    28d2:	0f b6       	in	r0, 0x3f	; 63
    28d4:	f8 94       	cli
    28d6:	fe bf       	out	0x3e, r31	; 62
    28d8:	0f be       	out	0x3f, r0	; 63
    28da:	ed bf       	out	0x3d, r30	; 61
    28dc:	31 96       	adiw	r30, 0x01	; 1
    28de:	ad b7       	in	r26, 0x3d	; 61
    28e0:	be b7       	in	r27, 0x3e	; 62
    28e2:	12 96       	adiw	r26, 0x02	; 2
    28e4:	fc 92       	st	X, r15
    28e6:	ee 92       	st	-X, r14
    28e8:	11 97       	sbiw	r26, 0x01	; 1
    28ea:	73 82       	std	Z+3, r7	; 0x03
    28ec:	62 82       	std	Z+2, r6	; 0x02
    28ee:	d8 01       	movw	r26, r16
    28f0:	11 96       	adiw	r26, 0x01	; 1
    28f2:	8d 91       	ld	r24, X+
    28f4:	9c 91       	ld	r25, X
    28f6:	12 97       	sbiw	r26, 0x02	; 2
    28f8:	95 83       	std	Z+5, r25	; 0x05
    28fa:	84 83       	std	Z+4, r24	; 0x04
    28fc:	13 96       	adiw	r26, 0x03	; 3
    28fe:	8d 91       	ld	r24, X+
    2900:	9c 91       	ld	r25, X
    2902:	14 97       	sbiw	r26, 0x04	; 4
    2904:	97 83       	std	Z+7, r25	; 0x07
    2906:	86 83       	std	Z+6, r24	; 0x06
    2908:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      result++;
    290c:	d3 94       	inc	r13
    290e:	ed b7       	in	r30, 0x3d	; 61
    2910:	fe b7       	in	r31, 0x3e	; 62
    2912:	38 96       	adiw	r30, 0x08	; 8
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	f8 94       	cli
    2918:	fe bf       	out	0x3e, r31	; 62
    291a:	0f be       	out	0x3f, r0	; 63
    291c:	ed bf       	out	0x3d, r30	; 61
    291e:	21 96       	adiw	r28, 0x01	; 1
uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
    2920:	c4 30       	cpi	r28, 0x04	; 4
    2922:	d1 05       	cpc	r29, r1
    2924:	19 f0       	breq	.+6      	; 0x292c <printLockers+0x13e>
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
      result++;
    }
    tmpLock++;
    2926:	0a 5f       	subi	r16, 0xFA	; 250
    2928:	1f 4f       	sbci	r17, 0xFF	; 255
    292a:	88 cf       	rjmp	.-240    	; 0x283c <printLockers+0x4e>
  }
  return result;
}
    292c:	8d 2d       	mov	r24, r13
    292e:	df 91       	pop	r29
    2930:	cf 91       	pop	r28
    2932:	1f 91       	pop	r17
    2934:	0f 91       	pop	r16
    2936:	ff 90       	pop	r15
    2938:	ef 90       	pop	r14
    293a:	df 90       	pop	r13
    293c:	bf 90       	pop	r11
    293e:	af 90       	pop	r10
    2940:	9f 90       	pop	r9
    2942:	8f 90       	pop	r8
    2944:	7f 90       	pop	r7
    2946:	6f 90       	pop	r6
    2948:	5f 90       	pop	r5
    294a:	4f 90       	pop	r4
    294c:	08 95       	ret

0000294e <LockersMemInit>:
   */
}

void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
    294e:	88 e1       	ldi	r24, 0x18	; 24
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    2956:	90 93 b8 0e 	sts	0x0EB8, r25
    295a:	80 93 b7 0e 	sts	0x0EB7, r24
}
    295e:	08 95       	ret

00002960 <hardwareInit>:
xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisj do czasu zakoczenia wysyania poprzedniego bajtu

void hardwareInit(void)
{
  //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    2960:	0f b6       	in	r0, 0x3f	; 63
    2962:	f8 94       	cli
    2964:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    2966:	81 e0       	ldi	r24, 0x01	; 1
    2968:	61 e0       	ldi	r22, 0x01	; 1
    296a:	0e 94 8f 6d 	call	0xdb1e	; 0xdb1e <xQueueCreate>
    296e:	90 93 80 0f 	sts	0x0F80, r25
    2972:	80 93 7f 0f 	sts	0x0F7F, r24
  portEXIT_CRITICAL();
    2976:	0f 90       	pop	r0
    2978:	0f be       	out	0x3f, r0	; 63

  DDRB = 0xF7;
    297a:	87 ef       	ldi	r24, 0xF7	; 247
    297c:	87 bb       	out	0x17, r24	; 23
  PORTB = 0xD1;
    297e:	81 ed       	ldi	r24, 0xD1	; 209
    2980:	88 bb       	out	0x18, r24	; 24
   7 - External SPI ASR 7 (MPC23S17)   0 - on;  1 - off
  */
  
  //DDRC = 0x00;  //External Memory

  DDRD = 0x00;
    2982:	11 ba       	out	0x11, r1	; 17
   5 - External SPI ASR 1
   6 - External SPI ASR 2
   7 - External SPI ASR 3
   */

  DDRE  = 0x0E;
    2984:	8e e0       	ldi	r24, 0x0E	; 14
    2986:	82 b9       	out	0x02, r24	; 2
  PORTE = 0x0C;
    2988:	8c e0       	ldi	r24, 0x0C	; 12
    298a:	83 b9       	out	0x03, r24	; 3
   4 - INT 4
   5 - INT 5
   6 - INT 6
   7 - INT Enc28j60
  */
  DDRF = 0x00;    //JTAG and A/C
    298c:	10 92 61 00 	sts	0x0061, r1
  DDRG = 0x1F;
    2990:	8f e1       	ldi	r24, 0x1F	; 31
    2992:	80 93 64 00 	sts	0x0064, r24
   4 - RS485 TxEn
   5 - 
   6 - 
   7 - 
   */
}
    2996:	08 95       	ret

00002998 <sensorsTask>:
  LockersMemInit();
  rollersMemInit();
}

void sensorsTask(void* pvParameters)
{
    2998:	1f 93       	push	r17
  pvParameters = NULL;
  uint8_t addr = 255;
//  uint8_t i;

  MPC23s17SetDirA(0x00, 0);
    299a:	80 e0       	ldi	r24, 0x00	; 0
    299c:	60 e0       	ldi	r22, 0x00	; 0
    299e:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <MPC23s17SetDirA>
  
  MPC23s17SetDirB(0x00, 0);
    29a2:	80 e0       	ldi	r24, 0x00	; 0
    29a4:	60 e0       	ldi	r22, 0x00	; 0
    29a6:	0e 94 f4 2e 	call	0x5de8	; 0x5de8 <MPC23s17SetDirB>

  for( ; ; )
  {
    uint16_t tmp;
    //Read power suply voltage
    tmp = MCP3008_getSampleSingle(0);
    29aa:	80 e0       	ldi	r24, 0x00	; 0
    29ac:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <MCP3008_getSampleSingle>
    voltage = (uint8_t)(tmp>>5);
    29b0:	65 e0       	ldi	r22, 0x05	; 5
    29b2:	96 95       	lsr	r25
    29b4:	87 95       	ror	r24
    29b6:	6a 95       	dec	r22
    29b8:	e1 f7       	brne	.-8      	; 0x29b2 <sensorsTask+0x1a>
    29ba:	80 93 c3 0e 	sts	0x0EC3, r24
    vTaskDelay(10);
    29be:	8a e0       	ldi	r24, 0x0A	; 10
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
      
    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    29c6:	81 e0       	ldi	r24, 0x01	; 1
    29c8:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <MCP3008_getSampleSingle>
    tmp *=10;
    temperature = (uint8_t)(tmp / 24);
    29cc:	9c 01       	movw	r18, r24
    29ce:	53 e0       	ldi	r21, 0x03	; 3
    29d0:	88 0f       	add	r24, r24
    29d2:	99 1f       	adc	r25, r25
    29d4:	5a 95       	dec	r21
    29d6:	e1 f7       	brne	.-8      	; 0x29d0 <sensorsTask+0x38>
    29d8:	22 0f       	add	r18, r18
    29da:	33 1f       	adc	r19, r19
    29dc:	82 0f       	add	r24, r18
    29de:	93 1f       	adc	r25, r19
    29e0:	68 e1       	ldi	r22, 0x18	; 24
    29e2:	70 e0       	ldi	r23, 0x00	; 0
    29e4:	0e 94 e6 71 	call	0xe3cc	; 0xe3cc <__udivmodhi4>
    29e8:	60 93 bb 0e 	sts	0x0EBB, r22
    vTaskDelay(10);
    29ec:	8a e0       	ldi	r24, 0x0A	; 10
    29ee:	90 e0       	ldi	r25, 0x00	; 0
    29f0:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
      
    //read lock
    checkLockerSensors();
    29f4:	0e 94 2d 13 	call	0x265a	; 0x265a <checkLockerSensors>
    29f8:	11 e0       	ldi	r17, 0x01	; 1

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    {
      rs485rollerHello(addr);
    29fa:	81 2f       	mov	r24, r17
    29fc:	0e 94 e1 61 	call	0xc3c2	; 0xc3c2 <rs485rollerHello>
      vTaskDelay(10);
    2a00:	8a e0       	ldi	r24, 0x0A	; 10
    2a02:	90 e0       	ldi	r25, 0x00	; 0
    2a04:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    vTaskDelay(10);
      
    //read lock
    checkLockerSensors();

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    2a08:	1f 5f       	subi	r17, 0xFF	; 255
    2a0a:	10 32       	cpi	r17, 0x20	; 32
    2a0c:	b1 f7       	brne	.-20     	; 0x29fa <sensorsTask+0x62>
    2a0e:	cd cf       	rjmp	.-102    	; 0x29aa <sensorsTask+0x12>

00002a10 <sensorsTaskInit>:



void sensorsTaskInit(void)
{
  LockersMemInit();
    2a10:	0e 94 a7 14 	call	0x294e	; 0x294e <LockersMemInit>
  rollersMemInit();
    2a14:	0e 94 b7 63 	call	0xc76e	; 0xc76e <rollersMemInit>
}
    2a18:	08 95       	ret

00002a1a <enableFunction>:
  state->err1 = 0;
  state->err2 = 0;
}

static cliExRes_t enableFunction(cmdState_t *state)
{
    2a1a:	fc 01       	movw	r30, r24
  if (state->cliMode != RESTRICTED_NORMAL)
    2a1c:	80 a1       	ldd	r24, Z+32	; 0x20
    2a1e:	83 30       	cpi	r24, 0x03	; 3
    2a20:	19 f4       	brne	.+6      	; 0x2a28 <enableFunction+0xe>
    2a22:	25 e0       	ldi	r18, 0x05	; 5
    2a24:	30 e0       	ldi	r19, 0x00	; 0
    2a26:	08 c0       	rjmp	.+16     	; 0x2a38 <enableFunction+0x1e>
  {
    state->cmdList = cmdListEnable;
    2a28:	80 e8       	ldi	r24, 0x80	; 128
    2a2a:	99 e0       	ldi	r25, 0x09	; 9
    2a2c:	92 a3       	std	Z+34, r25	; 0x22
    2a2e:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_ENABLE;
    2a30:	81 e0       	ldi	r24, 0x01	; 1
    2a32:	80 a3       	std	Z+32, r24	; 0x20
    2a34:	20 e0       	ldi	r18, 0x00	; 0
    2a36:	30 e0       	ldi	r19, 0x00	; 0
    return OK_SILENT;
  }
  return ERROR_OPERATION_NOT_ALLOWED;
}
    2a38:	c9 01       	movw	r24, r18
    2a3a:	08 95       	ret

00002a3c <disableFunction>:
static cliExRes_t disableFunction(cmdState_t *state)
{
    2a3c:	fc 01       	movw	r30, r24
  state->cmdList = cmdListNormal;
    2a3e:	8a e4       	ldi	r24, 0x4A	; 74
    2a40:	99 e0       	ldi	r25, 0x09	; 9
    2a42:	92 a3       	std	Z+34, r25	; 0x22
    2a44:	81 a3       	std	Z+33, r24	; 0x21
  if (state->cliMode != RESTRICTED_NORMAL)
    2a46:	80 a1       	ldd	r24, Z+32	; 0x20
    2a48:	83 30       	cpi	r24, 0x03	; 3
    2a4a:	09 f0       	breq	.+2      	; 0x2a4e <disableFunction+0x12>
  {
    state->cliMode = NR_NORMAL;
    2a4c:	10 a2       	std	Z+32, r1	; 0x20
  }
  return OK_SILENT;
}
    2a4e:	80 e0       	ldi	r24, 0x00	; 0
    2a50:	90 e0       	ldi	r25, 0x00	; 0
    2a52:	08 95       	ret

00002a54 <configureModeFunction>:
static cliExRes_t configureModeFunction(cmdState_t *state)
{
    2a54:	fc 01       	movw	r30, r24
  if (state->cliMode == NR_ENABLE)
    2a56:	80 a1       	ldd	r24, Z+32	; 0x20
    2a58:	81 30       	cpi	r24, 0x01	; 1
    2a5a:	19 f0       	breq	.+6      	; 0x2a62 <configureModeFunction+0xe>
    2a5c:	25 e0       	ldi	r18, 0x05	; 5
    2a5e:	30 e0       	ldi	r19, 0x00	; 0
    2a60:	08 c0       	rjmp	.+16     	; 0x2a72 <configureModeFunction+0x1e>
  {
    state->cmdList = cmdListConfigure;
    2a62:	86 e1       	ldi	r24, 0x16	; 22
    2a64:	9a e0       	ldi	r25, 0x0A	; 10
    2a66:	92 a3       	std	Z+34, r25	; 0x22
    2a68:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_CONFIGURE;
    2a6a:	82 e0       	ldi	r24, 0x02	; 2
    2a6c:	80 a3       	std	Z+32, r24	; 0x20
    2a6e:	20 e0       	ldi	r18, 0x00	; 0
    2a70:	30 e0       	ldi	r19, 0x00	; 0
    return OK_SILENT;
  }
  return ERROR_OPERATION_NOT_ALLOWED;
}
    2a72:	c9 01       	movw	r24, r18
    2a74:	08 95       	ret

00002a76 <saveConfigFunction>:
}

static cliExRes_t saveConfigFunction(cmdState_t *state)
{
  state = NULL;
  saveConfiguration();
    2a76:	0e 94 68 10 	call	0x20d0	; 0x20d0 <saveConfiguration>
  return OK_SILENT;
}
    2a7a:	80 e0       	ldi	r24, 0x00	; 0
    2a7c:	90 e0       	ldi	r25, 0x00	; 0
    2a7e:	08 95       	ret

00002a80 <setMacAddrFunction>:
  ipSetConfigGw(gw);
  return OK_SILENT;
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
    2a80:	cf 93       	push	r28
    2a82:	df 93       	push	r29
    2a84:	ec 01       	movw	r28, r24
  if (state->argc < 6)
    2a86:	89 8d       	ldd	r24, Y+25	; 0x19
    2a88:	86 30       	cpi	r24, 0x06	; 6
    2a8a:	18 f4       	brcc	.+6      	; 0x2a92 <setMacAddrFunction+0x12>
    2a8c:	22 e0       	ldi	r18, 0x02	; 2
    2a8e:	30 e0       	ldi	r19, 0x00	; 0
    2a90:	2a c0       	rjmp	.+84     	; 0x2ae6 <setMacAddrFunction+0x66>
    return SYNTAX_ERROR;  
  
  nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
    2a92:	81 e0       	ldi	r24, 0x01	; 1
    2a94:	be 01       	movw	r22, r28
    2a96:	0e 94 22 28 	call	0x5044	; 0x5044 <cmdlineGetArgHex>
    2a9a:	60 93 97 0e 	sts	0x0E97, r22
  nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
    2a9e:	82 e0       	ldi	r24, 0x02	; 2
    2aa0:	be 01       	movw	r22, r28
    2aa2:	0e 94 22 28 	call	0x5044	; 0x5044 <cmdlineGetArgHex>
    2aa6:	60 93 98 0e 	sts	0x0E98, r22
  nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
    2aaa:	83 e0       	ldi	r24, 0x03	; 3
    2aac:	be 01       	movw	r22, r28
    2aae:	0e 94 22 28 	call	0x5044	; 0x5044 <cmdlineGetArgHex>
    2ab2:	60 93 99 0e 	sts	0x0E99, r22
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
    2ab6:	84 e0       	ldi	r24, 0x04	; 4
    2ab8:	be 01       	movw	r22, r28
    2aba:	0e 94 22 28 	call	0x5044	; 0x5044 <cmdlineGetArgHex>
    2abe:	60 93 9a 0e 	sts	0x0E9A, r22
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
    2ac2:	85 e0       	ldi	r24, 0x05	; 5
    2ac4:	be 01       	movw	r22, r28
    2ac6:	0e 94 22 28 	call	0x5044	; 0x5044 <cmdlineGetArgHex>
    2aca:	60 93 9b 0e 	sts	0x0E9B, r22
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
    2ace:	86 e0       	ldi	r24, 0x06	; 6
    2ad0:	be 01       	movw	r22, r28
    2ad2:	0e 94 22 28 	call	0x5044	; 0x5044 <cmdlineGetArgHex>
    2ad6:	60 93 9c 0e 	sts	0x0E9C, r22
  nicSetMacAddress(nicState.mac.addr);
    2ada:	87 e9       	ldi	r24, 0x97	; 151
    2adc:	9e e0       	ldi	r25, 0x0E	; 14
    2ade:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <nicSetMacAddress>
    2ae2:	20 e0       	ldi	r18, 0x00	; 0
    2ae4:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2ae6:	c9 01       	movw	r24, r18
    2ae8:	df 91       	pop	r29
    2aea:	cf 91       	pop	r28
    2aec:	08 95       	ret

00002aee <pingFunction>:
  printErrorInfo(state);
  return OK_SILENT;
}

static cliExRes_t pingFunction(cmdState_t *state)
{
    2aee:	cf 93       	push	r28
    2af0:	df 93       	push	r29
    2af2:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    2af4:	89 8d       	ldd	r24, Y+25	; 0x19
    2af6:	84 30       	cpi	r24, 0x04	; 4
    2af8:	18 f4       	brcc	.+6      	; 0x2b00 <pingFunction+0x12>
    2afa:	22 e0       	ldi	r18, 0x02	; 2
    2afc:	30 e0       	ldi	r19, 0x00	; 0
    2afe:	12 c0       	rjmp	.+36     	; 0x2b24 <pingFunction+0x36>
    return SYNTAX_ERROR;
  
  uint8_t ip[4];
  ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
    2b00:	81 e0       	ldi	r24, 0x01	; 1
    2b02:	be 01       	movw	r22, r28
    2b04:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
  ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
    2b08:	82 e0       	ldi	r24, 0x02	; 2
    2b0a:	be 01       	movw	r22, r28
    2b0c:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
  ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
    2b10:	83 e0       	ldi	r24, 0x03	; 3
    2b12:	be 01       	movw	r22, r28
    2b14:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
  ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
    2b18:	84 e0       	ldi	r24, 0x04	; 4
    2b1a:	be 01       	movw	r22, r28
    2b1c:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2b20:	20 e0       	ldi	r18, 0x00	; 0
    2b22:	30 e0       	ldi	r19, 0x00	; 0

//  Ipv4Ping(*((uint32_t *)(ip)));
  
  return OK_SILENT;
}
    2b24:	c9 01       	movw	r24, r18
    2b26:	df 91       	pop	r29
    2b28:	cf 91       	pop	r28
    2b2a:	08 95       	ret

00002b2c <setUdpFunction>:
  ipSetConfigIp(ip);
  return OK_SILENT;
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
    2b2c:	6f 92       	push	r6
    2b2e:	7f 92       	push	r7
    2b30:	8f 92       	push	r8
    2b32:	9f 92       	push	r9
    2b34:	af 92       	push	r10
    2b36:	bf 92       	push	r11
    2b38:	cf 92       	push	r12
    2b3a:	df 92       	push	r13
    2b3c:	ef 92       	push	r14
    2b3e:	ff 92       	push	r15
    2b40:	0f 93       	push	r16
    2b42:	1f 93       	push	r17
    2b44:	cf 93       	push	r28
    2b46:	df 93       	push	r29
    2b48:	ec 01       	movw	r28, r24
  if (state->argc < 5)
    2b4a:	89 8d       	ldd	r24, Y+25	; 0x19
    2b4c:	85 30       	cpi	r24, 0x05	; 5
    2b4e:	18 f4       	brcc	.+6      	; 0x2b56 <setUdpFunction+0x2a>
    2b50:	22 e0       	ldi	r18, 0x02	; 2
    2b52:	30 e0       	ldi	r19, 0x00	; 0
    2b54:	58 c0       	rjmp	.+176    	; 0x2c06 <setUdpFunction+0xda>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2b56:	81 e0       	ldi	r24, 0x01	; 1
    2b58:	be 01       	movw	r22, r28
    2b5a:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2b5e:	3b 01       	movw	r6, r22
    2b60:	4c 01       	movw	r8, r24
    2b62:	82 e0       	ldi	r24, 0x02	; 2
    2b64:	be 01       	movw	r22, r28
    2b66:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2b6a:	7b 01       	movw	r14, r22
    2b6c:	8c 01       	movw	r16, r24
    2b6e:	83 e0       	ldi	r24, 0x03	; 3
    2b70:	be 01       	movw	r22, r28
    2b72:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2b76:	5b 01       	movw	r10, r22
    2b78:	6c 01       	movw	r12, r24
    2b7a:	84 e0       	ldi	r24, 0x04	; 4
    2b7c:	be 01       	movw	r22, r28
    2b7e:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
  udpSocket->dstIp = ip;
    2b82:	e0 91 b9 0e 	lds	r30, 0x0EB9
    2b86:	f0 91 ba 0e 	lds	r31, 0x0EBA
    2b8a:	10 2f       	mov	r17, r16
    2b8c:	0f 2d       	mov	r16, r15
    2b8e:	fe 2c       	mov	r15, r14
    2b90:	ee 24       	eor	r14, r14
    2b92:	65 01       	movw	r12, r10
    2b94:	bb 24       	eor	r11, r11
    2b96:	aa 24       	eor	r10, r10
    2b98:	ea 0c       	add	r14, r10
    2b9a:	fb 1c       	adc	r15, r11
    2b9c:	0c 1d       	adc	r16, r12
    2b9e:	1d 1d       	adc	r17, r13
    2ba0:	e6 0c       	add	r14, r6
    2ba2:	f7 1c       	adc	r15, r7
    2ba4:	08 1d       	adc	r16, r8
    2ba6:	19 1d       	adc	r17, r9
    2ba8:	96 2f       	mov	r25, r22
    2baa:	88 27       	eor	r24, r24
    2bac:	77 27       	eor	r23, r23
    2bae:	66 27       	eor	r22, r22
    2bb0:	e6 0e       	add	r14, r22
    2bb2:	f7 1e       	adc	r15, r23
    2bb4:	08 1f       	adc	r16, r24
    2bb6:	19 1f       	adc	r17, r25
    2bb8:	e6 82       	std	Z+6, r14	; 0x06
    2bba:	f7 82       	std	Z+7, r15	; 0x07
    2bbc:	00 87       	std	Z+8, r16	; 0x08
    2bbe:	11 87       	std	Z+9, r17	; 0x09
  
  uint16_t port = cmdlineGetArgInt(5, state);
    2bc0:	85 e0       	ldi	r24, 0x05	; 5
    2bc2:	be 01       	movw	r22, r28
    2bc4:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2bc8:	dc 01       	movw	r26, r24
    2bca:	cb 01       	movw	r24, r22
  udpSocket->srcPort = htons(port);
    2bcc:	00 91 b9 0e 	lds	r16, 0x0EB9
    2bd0:	10 91 ba 0e 	lds	r17, 0x0EBA
    2bd4:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    2bd8:	f8 01       	movw	r30, r16
    2bda:	95 83       	std	Z+5, r25	; 0x05
    2bdc:	84 83       	std	Z+4, r24	; 0x04
  
  if (state->argc > 5)
    2bde:	89 8d       	ldd	r24, Y+25	; 0x19
    2be0:	86 30       	cpi	r24, 0x06	; 6
    2be2:	78 f0       	brcs	.+30     	; 0x2c02 <setUdpFunction+0xd6>
  {
    port = cmdlineGetArgInt(6, state);
    2be4:	86 e0       	ldi	r24, 0x06	; 6
    2be6:	be 01       	movw	r22, r28
    2be8:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2bec:	dc 01       	movw	r26, r24
    2bee:	cb 01       	movw	r24, r22
    udpSocket->dstPort = htons(port);    
    2bf0:	00 91 b9 0e 	lds	r16, 0x0EB9
    2bf4:	10 91 ba 0e 	lds	r17, 0x0EBA
    2bf8:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    2bfc:	f8 01       	movw	r30, r16
    2bfe:	93 83       	std	Z+3, r25	; 0x03
    2c00:	82 83       	std	Z+2, r24	; 0x02
    2c02:	20 e0       	ldi	r18, 0x00	; 0
    2c04:	30 e0       	ldi	r19, 0x00	; 0
  }
  return OK_SILENT;
}
    2c06:	c9 01       	movw	r24, r18
    2c08:	df 91       	pop	r29
    2c0a:	cf 91       	pop	r28
    2c0c:	1f 91       	pop	r17
    2c0e:	0f 91       	pop	r16
    2c10:	ff 90       	pop	r15
    2c12:	ef 90       	pop	r14
    2c14:	df 90       	pop	r13
    2c16:	cf 90       	pop	r12
    2c18:	bf 90       	pop	r11
    2c1a:	af 90       	pop	r10
    2c1c:	9f 90       	pop	r9
    2c1e:	8f 90       	pop	r8
    2c20:	7f 90       	pop	r7
    2c22:	6f 90       	pop	r6
    2c24:	08 95       	ret

00002c26 <setIpGwFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
    2c26:	6f 92       	push	r6
    2c28:	7f 92       	push	r7
    2c2a:	8f 92       	push	r8
    2c2c:	9f 92       	push	r9
    2c2e:	af 92       	push	r10
    2c30:	bf 92       	push	r11
    2c32:	cf 92       	push	r12
    2c34:	df 92       	push	r13
    2c36:	ef 92       	push	r14
    2c38:	ff 92       	push	r15
    2c3a:	0f 93       	push	r16
    2c3c:	1f 93       	push	r17
    2c3e:	cf 93       	push	r28
    2c40:	df 93       	push	r29
    2c42:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    2c44:	89 8d       	ldd	r24, Y+25	; 0x19
    2c46:	84 30       	cpi	r24, 0x04	; 4
    2c48:	18 f4       	brcc	.+6      	; 0x2c50 <setIpGwFunction+0x2a>
    2c4a:	22 e0       	ldi	r18, 0x02	; 2
    2c4c:	30 e0       	ldi	r19, 0x00	; 0
    2c4e:	33 c0       	rjmp	.+102    	; 0x2cb6 <setIpGwFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t gw = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2c50:	81 e0       	ldi	r24, 0x01	; 1
    2c52:	be 01       	movw	r22, r28
    2c54:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2c58:	3b 01       	movw	r6, r22
    2c5a:	4c 01       	movw	r8, r24
    2c5c:	82 e0       	ldi	r24, 0x02	; 2
    2c5e:	be 01       	movw	r22, r28
    2c60:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2c64:	7b 01       	movw	r14, r22
    2c66:	8c 01       	movw	r16, r24
    2c68:	83 e0       	ldi	r24, 0x03	; 3
    2c6a:	be 01       	movw	r22, r28
    2c6c:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2c70:	5b 01       	movw	r10, r22
    2c72:	6c 01       	movw	r12, r24
    2c74:	84 e0       	ldi	r24, 0x04	; 4
    2c76:	be 01       	movw	r22, r28
    2c78:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
  ipSetConfigGw(gw);
    2c7c:	10 2f       	mov	r17, r16
    2c7e:	0f 2d       	mov	r16, r15
    2c80:	fe 2c       	mov	r15, r14
    2c82:	ee 24       	eor	r14, r14
    2c84:	65 01       	movw	r12, r10
    2c86:	bb 24       	eor	r11, r11
    2c88:	aa 24       	eor	r10, r10
    2c8a:	ea 0c       	add	r14, r10
    2c8c:	fb 1c       	adc	r15, r11
    2c8e:	0c 1d       	adc	r16, r12
    2c90:	1d 1d       	adc	r17, r13
    2c92:	e6 0c       	add	r14, r6
    2c94:	f7 1c       	adc	r15, r7
    2c96:	08 1d       	adc	r16, r8
    2c98:	19 1d       	adc	r17, r9
    2c9a:	96 2f       	mov	r25, r22
    2c9c:	88 27       	eor	r24, r24
    2c9e:	77 27       	eor	r23, r23
    2ca0:	66 27       	eor	r22, r22
    2ca2:	e6 0e       	add	r14, r22
    2ca4:	f7 1e       	adc	r15, r23
    2ca6:	08 1f       	adc	r16, r24
    2ca8:	19 1f       	adc	r17, r25
    2caa:	c8 01       	movw	r24, r16
    2cac:	b7 01       	movw	r22, r14
    2cae:	0e 94 d6 37 	call	0x6fac	; 0x6fac <ipSetConfigGw>
    2cb2:	20 e0       	ldi	r18, 0x00	; 0
    2cb4:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2cb6:	c9 01       	movw	r24, r18
    2cb8:	df 91       	pop	r29
    2cba:	cf 91       	pop	r28
    2cbc:	1f 91       	pop	r17
    2cbe:	0f 91       	pop	r16
    2cc0:	ff 90       	pop	r15
    2cc2:	ef 90       	pop	r14
    2cc4:	df 90       	pop	r13
    2cc6:	cf 90       	pop	r12
    2cc8:	bf 90       	pop	r11
    2cca:	af 90       	pop	r10
    2ccc:	9f 90       	pop	r9
    2cce:	8f 90       	pop	r8
    2cd0:	7f 90       	pop	r7
    2cd2:	6f 90       	pop	r6
    2cd4:	08 95       	ret

00002cd6 <setIpMaskFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
    2cd6:	fc 01       	movw	r30, r24
  if (state->argc < 1)
    2cd8:	81 8d       	ldd	r24, Z+25	; 0x19
    2cda:	88 23       	and	r24, r24
    2cdc:	19 f4       	brne	.+6      	; 0x2ce4 <setIpMaskFunction+0xe>
    2cde:	22 e0       	ldi	r18, 0x02	; 2
    2ce0:	30 e0       	ldi	r19, 0x00	; 0
    2ce2:	17 c0       	rjmp	.+46     	; 0x2d12 <setIpMaskFunction+0x3c>
    return SYNTAX_ERROR;
  
  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
    2ce4:	81 e0       	ldi	r24, 0x01	; 1
    2ce6:	bf 01       	movw	r22, r30
    2ce8:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
  
  ipSetConfigMask(mask);
    2cec:	20 e2       	ldi	r18, 0x20	; 32
    2cee:	30 e0       	ldi	r19, 0x00	; 0
    2cf0:	26 1b       	sub	r18, r22
    2cf2:	37 0b       	sbc	r19, r23
    2cf4:	6f ef       	ldi	r22, 0xFF	; 255
    2cf6:	7f ef       	ldi	r23, 0xFF	; 255
    2cf8:	8f ef       	ldi	r24, 0xFF	; 255
    2cfa:	9f ef       	ldi	r25, 0xFF	; 255
    2cfc:	04 c0       	rjmp	.+8      	; 0x2d06 <setIpMaskFunction+0x30>
    2cfe:	96 95       	lsr	r25
    2d00:	87 95       	ror	r24
    2d02:	77 95       	ror	r23
    2d04:	67 95       	ror	r22
    2d06:	2a 95       	dec	r18
    2d08:	d2 f7       	brpl	.-12     	; 0x2cfe <setIpMaskFunction+0x28>
    2d0a:	0e 94 cd 37 	call	0x6f9a	; 0x6f9a <ipSetConfigMask>
    2d0e:	20 e0       	ldi	r18, 0x00	; 0
    2d10:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2d12:	c9 01       	movw	r24, r18
    2d14:	08 95       	ret

00002d16 <setIpFunction>:
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
  return OK_SILENT;
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
    2d16:	6f 92       	push	r6
    2d18:	7f 92       	push	r7
    2d1a:	8f 92       	push	r8
    2d1c:	9f 92       	push	r9
    2d1e:	af 92       	push	r10
    2d20:	bf 92       	push	r11
    2d22:	cf 92       	push	r12
    2d24:	df 92       	push	r13
    2d26:	ef 92       	push	r14
    2d28:	ff 92       	push	r15
    2d2a:	0f 93       	push	r16
    2d2c:	1f 93       	push	r17
    2d2e:	cf 93       	push	r28
    2d30:	df 93       	push	r29
    2d32:	ec 01       	movw	r28, r24
  if (state->argc < 4)
    2d34:	89 8d       	ldd	r24, Y+25	; 0x19
    2d36:	84 30       	cpi	r24, 0x04	; 4
    2d38:	18 f4       	brcc	.+6      	; 0x2d40 <setIpFunction+0x2a>
    2d3a:	22 e0       	ldi	r18, 0x02	; 2
    2d3c:	30 e0       	ldi	r19, 0x00	; 0
    2d3e:	33 c0       	rjmp	.+102    	; 0x2da6 <setIpFunction+0x90>
    return SYNTAX_ERROR;
  
  uint32_t ip = cmdlineGetArgInt(1, state) + 
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
    2d40:	81 e0       	ldi	r24, 0x01	; 1
    2d42:	be 01       	movw	r22, r28
    2d44:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2d48:	3b 01       	movw	r6, r22
    2d4a:	4c 01       	movw	r8, r24
    2d4c:	82 e0       	ldi	r24, 0x02	; 2
    2d4e:	be 01       	movw	r22, r28
    2d50:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2d54:	7b 01       	movw	r14, r22
    2d56:	8c 01       	movw	r16, r24
    2d58:	83 e0       	ldi	r24, 0x03	; 3
    2d5a:	be 01       	movw	r22, r28
    2d5c:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2d60:	5b 01       	movw	r10, r22
    2d62:	6c 01       	movw	r12, r24
    2d64:	84 e0       	ldi	r24, 0x04	; 4
    2d66:	be 01       	movw	r22, r28
    2d68:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
  
  ipSetConfigIp(ip);
    2d6c:	10 2f       	mov	r17, r16
    2d6e:	0f 2d       	mov	r16, r15
    2d70:	fe 2c       	mov	r15, r14
    2d72:	ee 24       	eor	r14, r14
    2d74:	65 01       	movw	r12, r10
    2d76:	bb 24       	eor	r11, r11
    2d78:	aa 24       	eor	r10, r10
    2d7a:	ea 0c       	add	r14, r10
    2d7c:	fb 1c       	adc	r15, r11
    2d7e:	0c 1d       	adc	r16, r12
    2d80:	1d 1d       	adc	r17, r13
    2d82:	e6 0c       	add	r14, r6
    2d84:	f7 1c       	adc	r15, r7
    2d86:	08 1d       	adc	r16, r8
    2d88:	19 1d       	adc	r17, r9
    2d8a:	96 2f       	mov	r25, r22
    2d8c:	88 27       	eor	r24, r24
    2d8e:	77 27       	eor	r23, r23
    2d90:	66 27       	eor	r22, r22
    2d92:	e6 0e       	add	r14, r22
    2d94:	f7 1e       	adc	r15, r23
    2d96:	08 1f       	adc	r16, r24
    2d98:	19 1f       	adc	r17, r25
    2d9a:	c8 01       	movw	r24, r16
    2d9c:	b7 01       	movw	r22, r14
    2d9e:	0e 94 c4 37 	call	0x6f88	; 0x6f88 <ipSetConfigIp>
    2da2:	20 e0       	ldi	r18, 0x00	; 0
    2da4:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    2da6:	c9 01       	movw	r24, r18
    2da8:	df 91       	pop	r29
    2daa:	cf 91       	pop	r28
    2dac:	1f 91       	pop	r17
    2dae:	0f 91       	pop	r16
    2db0:	ff 90       	pop	r15
    2db2:	ef 90       	pop	r14
    2db4:	df 90       	pop	r13
    2db6:	cf 90       	pop	r12
    2db8:	bf 90       	pop	r11
    2dba:	af 90       	pop	r10
    2dbc:	9f 90       	pop	r9
    2dbe:	8f 90       	pop	r8
    2dc0:	7f 90       	pop	r7
    2dc2:	6f 90       	pop	r6
    2dc4:	08 95       	ret

00002dc6 <czytajAC_Function>:
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}

static cliExRes_t czytajAC_Function(cmdState_t *state)
{
    2dc6:	ff 92       	push	r15
    2dc8:	0f 93       	push	r16
    2dca:	1f 93       	push	r17
    2dcc:	8c 01       	movw	r16, r24
  uint8_t nrWejscia = cmdlineGetArgInt(1, state);
    2dce:	81 e0       	ldi	r24, 0x01	; 1
    2dd0:	b8 01       	movw	r22, r16
    2dd2:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2dd6:	f6 2e       	mov	r15, r22
  uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
    2dd8:	86 2f       	mov	r24, r22
    2dda:	0e 94 2c 2f 	call	0x5e58	; 0x5e58 <MCP3008_getSampleSingle>
  fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
    2dde:	2d b7       	in	r18, 0x3d	; 61
    2de0:	3e b7       	in	r19, 0x3e	; 62
    2de2:	28 50       	subi	r18, 0x08	; 8
    2de4:	30 40       	sbci	r19, 0x00	; 0
    2de6:	0f b6       	in	r0, 0x3f	; 63
    2de8:	f8 94       	cli
    2dea:	3e bf       	out	0x3e, r19	; 62
    2dec:	0f be       	out	0x3f, r0	; 63
    2dee:	2d bf       	out	0x3d, r18	; 61
    2df0:	ed b7       	in	r30, 0x3d	; 61
    2df2:	fe b7       	in	r31, 0x3e	; 62
    2df4:	31 96       	adiw	r30, 0x01	; 1
    2df6:	d8 01       	movw	r26, r16
    2df8:	5a 96       	adiw	r26, 0x1a	; 26
    2dfa:	2d 91       	ld	r18, X+
    2dfc:	3c 91       	ld	r19, X
    2dfe:	5b 97       	sbiw	r26, 0x1b	; 27
    2e00:	ad b7       	in	r26, 0x3d	; 61
    2e02:	be b7       	in	r27, 0x3e	; 62
    2e04:	12 96       	adiw	r26, 0x02	; 2
    2e06:	3c 93       	st	X, r19
    2e08:	2e 93       	st	-X, r18
    2e0a:	11 97       	sbiw	r26, 0x01	; 1
    2e0c:	24 e6       	ldi	r18, 0x64	; 100
    2e0e:	3a e0       	ldi	r19, 0x0A	; 10
    2e10:	33 83       	std	Z+3, r19	; 0x03
    2e12:	22 83       	std	Z+2, r18	; 0x02
    2e14:	f4 82       	std	Z+4, r15	; 0x04
    2e16:	15 82       	std	Z+5, r1	; 0x05
    2e18:	97 83       	std	Z+7, r25	; 0x07
    2e1a:	86 83       	std	Z+6, r24	; 0x06
    2e1c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    2e20:	2d b7       	in	r18, 0x3d	; 61
    2e22:	3e b7       	in	r19, 0x3e	; 62
    2e24:	28 5f       	subi	r18, 0xF8	; 248
    2e26:	3f 4f       	sbci	r19, 0xFF	; 255
    2e28:	0f b6       	in	r0, 0x3f	; 63
    2e2a:	f8 94       	cli
    2e2c:	3e bf       	out	0x3e, r19	; 62
    2e2e:	0f be       	out	0x3f, r0	; 63
    2e30:	2d bf       	out	0x3d, r18	; 61
  return OK_SILENT;
}
    2e32:	80 e0       	ldi	r24, 0x00	; 0
    2e34:	90 e0       	ldi	r25, 0x00	; 0
    2e36:	1f 91       	pop	r17
    2e38:	0f 91       	pop	r16
    2e3a:	ff 90       	pop	r15
    2e3c:	08 95       	ret

00002e3e <printErrorInfo>:
{
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
}

void printErrorInfo(cmdState_t *state)
{
    2e3e:	cf 93       	push	r28
    2e40:	df 93       	push	r29
    2e42:	ec 01       	movw	r28, r24
  if (state->errno != 0)
    2e44:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2e46:	88 23       	and	r24, r24
    2e48:	71 f1       	breq	.+92     	; 0x2ea6 <printErrorInfo+0x68>
  {
    fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->err1, state->err2);
    2e4a:	e8 2f       	mov	r30, r24
    2e4c:	f0 e0       	ldi	r31, 0x00	; 0
    2e4e:	ee 0f       	add	r30, r30
    2e50:	ff 1f       	adc	r31, r31
    2e52:	ee 5c       	subi	r30, 0xCE	; 206
    2e54:	f6 4f       	sbci	r31, 0xF6	; 246
    2e56:	25 91       	lpm	r18, Z+
    2e58:	34 91       	lpm	r19, Z+
    2e5a:	8d b7       	in	r24, 0x3d	; 61
    2e5c:	9e b7       	in	r25, 0x3e	; 62
    2e5e:	08 97       	sbiw	r24, 0x08	; 8
    2e60:	0f b6       	in	r0, 0x3f	; 63
    2e62:	f8 94       	cli
    2e64:	9e bf       	out	0x3e, r25	; 62
    2e66:	0f be       	out	0x3f, r0	; 63
    2e68:	8d bf       	out	0x3d, r24	; 61
    2e6a:	ed b7       	in	r30, 0x3d	; 61
    2e6c:	fe b7       	in	r31, 0x3e	; 62
    2e6e:	31 96       	adiw	r30, 0x01	; 1
    2e70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2e72:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2e74:	ad b7       	in	r26, 0x3d	; 61
    2e76:	be b7       	in	r27, 0x3e	; 62
    2e78:	12 96       	adiw	r26, 0x02	; 2
    2e7a:	9c 93       	st	X, r25
    2e7c:	8e 93       	st	-X, r24
    2e7e:	11 97       	sbiw	r26, 0x01	; 1
    2e80:	33 83       	std	Z+3, r19	; 0x03
    2e82:	22 83       	std	Z+2, r18	; 0x02
    2e84:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2e86:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2e88:	95 83       	std	Z+5, r25	; 0x05
    2e8a:	84 83       	std	Z+4, r24	; 0x04
    2e8c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2e8e:	86 83       	std	Z+6, r24	; 0x06
    2e90:	17 82       	std	Z+7, r1	; 0x07
    2e92:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    2e96:	8d b7       	in	r24, 0x3d	; 61
    2e98:	9e b7       	in	r25, 0x3e	; 62
    2e9a:	08 96       	adiw	r24, 0x08	; 8
    2e9c:	0f b6       	in	r0, 0x3f	; 63
    2e9e:	f8 94       	cli
    2ea0:	9e bf       	out	0x3e, r25	; 62
    2ea2:	0f be       	out	0x3f, r0	; 63
    2ea4:	8d bf       	out	0x3d, r24	; 61
  }
  state->errno = 0;
    2ea6:	1c 8e       	std	Y+28, r1	; 0x1c
  state->err1 = 0;
    2ea8:	1e 8e       	std	Y+30, r1	; 0x1e
    2eaa:	1d 8e       	std	Y+29, r1	; 0x1d
  state->err2 = 0;
    2eac:	1f 8e       	std	Y+31, r1	; 0x1f
}
    2eae:	df 91       	pop	r29
    2eb0:	cf 91       	pop	r28
    2eb2:	08 95       	ret

00002eb4 <setTimeFunction>:
  return SYNTAX_ERROR;
}


static cliExRes_t setTimeFunction(cmdState_t *state)
{
    2eb4:	ef 92       	push	r14
    2eb6:	ff 92       	push	r15
    2eb8:	0f 93       	push	r16
    2eba:	1f 93       	push	r17
    2ebc:	8c 01       	movw	r16, r24
  uint8_t godzina =  cmdlineGetArgInt(1, state);
    2ebe:	81 e0       	ldi	r24, 0x01	; 1
    2ec0:	b8 01       	movw	r22, r16
    2ec2:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2ec6:	f6 2e       	mov	r15, r22
  uint8_t minuta  =  cmdlineGetArgInt(2, state);
    2ec8:	82 e0       	ldi	r24, 0x02	; 2
    2eca:	b8 01       	movw	r22, r16
    2ecc:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2ed0:	e6 2e       	mov	r14, r22
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
    2ed2:	83 e0       	ldi	r24, 0x03	; 3
    2ed4:	b8 01       	movw	r22, r16
    2ed6:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2eda:	16 2f       	mov	r17, r22
  
  ds1305start();
    2edc:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <ds1305start>

  uint8_t cDzies = godzina/10;
    2ee0:	8f 2d       	mov	r24, r15
    2ee2:	6a e0       	ldi	r22, 0x0A	; 10
    2ee4:	0e 94 da 71 	call	0xe3b4	; 0xe3b4 <__udivmodqi4>
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
    2ee8:	28 2f       	mov	r18, r24
    2eea:	23 70       	andi	r18, 0x03	; 3
    2eec:	ae ec       	ldi	r26, 0xCE	; 206
    2eee:	be e0       	ldi	r27, 0x0E	; 14
    2ef0:	22 95       	swap	r18
    2ef2:	20 7f       	andi	r18, 0xF0	; 240
    2ef4:	90 91 ce 0e 	lds	r25, 0x0ECE
    2ef8:	9f 7c       	andi	r25, 0xCF	; 207
    2efa:	92 2b       	or	r25, r18
    2efc:	90 93 ce 0e 	sts	0x0ECE, r25
  czasRtc.hours.syst24.cJedn  = cJedn;
    2f00:	46 ef       	ldi	r20, 0xF6	; 246
    2f02:	5f ef       	ldi	r21, 0xFF	; 255
    2f04:	84 9f       	mul	r24, r20
    2f06:	80 2d       	mov	r24, r0
    2f08:	11 24       	eor	r1, r1
    2f0a:	8f 0d       	add	r24, r15
    2f0c:	8f 70       	andi	r24, 0x0F	; 15
    2f0e:	90 91 ce 0e 	lds	r25, 0x0ECE
    2f12:	90 7f       	andi	r25, 0xF0	; 240
    2f14:	98 2b       	or	r25, r24
    2f16:	90 93 ce 0e 	sts	0x0ECE, r25
  
  cDzies = minuta/10;
    2f1a:	8e 2d       	mov	r24, r14
    2f1c:	0e 94 da 71 	call	0xe3b4	; 0xe3b4 <__udivmodqi4>
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
    2f20:	28 2f       	mov	r18, r24
    2f22:	27 70       	andi	r18, 0x07	; 7
    2f24:	fd 01       	movw	r30, r26
    2f26:	22 95       	swap	r18
    2f28:	20 7f       	andi	r18, 0xF0	; 240
    2f2a:	92 91       	ld	r25, -Z
    2f2c:	9f 78       	andi	r25, 0x8F	; 143
    2f2e:	92 2b       	or	r25, r18
    2f30:	90 83       	st	Z, r25
  czasRtc.minutes.cJedn  = cJedn;
    2f32:	84 9f       	mul	r24, r20
    2f34:	80 2d       	mov	r24, r0
    2f36:	11 24       	eor	r1, r1
    2f38:	8e 0d       	add	r24, r14
    2f3a:	8f 70       	andi	r24, 0x0F	; 15
    2f3c:	90 81       	ld	r25, Z
    2f3e:	90 7f       	andi	r25, 0xF0	; 240
    2f40:	98 2b       	or	r25, r24
    2f42:	90 83       	st	Z, r25
  
  cDzies = sekunda/10;
    2f44:	81 2f       	mov	r24, r17
    2f46:	0e 94 da 71 	call	0xe3b4	; 0xe3b4 <__udivmodqi4>
  cJedn  = sekunda - cDzies * 10;
  czasRtc.seconds.cDzies = cDzies;
    2f4a:	28 2f       	mov	r18, r24
    2f4c:	27 70       	andi	r18, 0x07	; 7
    2f4e:	12 97       	sbiw	r26, 0x02	; 2
    2f50:	22 95       	swap	r18
    2f52:	20 7f       	andi	r18, 0xF0	; 240
    2f54:	9c 91       	ld	r25, X
    2f56:	9f 78       	andi	r25, 0x8F	; 143
    2f58:	92 2b       	or	r25, r18
    2f5a:	9c 93       	st	X, r25
  czasRtc.seconds.cJedn  = cJedn;
    2f5c:	84 9f       	mul	r24, r20
    2f5e:	80 2d       	mov	r24, r0
    2f60:	11 24       	eor	r1, r1
    2f62:	81 0f       	add	r24, r17
    2f64:	8f 70       	andi	r24, 0x0F	; 15
    2f66:	9c 91       	ld	r25, X
    2f68:	90 7f       	andi	r25, 0xF0	; 240
    2f6a:	98 2b       	or	r25, r24
    2f6c:	9c 93       	st	X, r25
  
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
    2f6e:	cd 01       	movw	r24, r26
    2f70:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <setTimeDecoded>
  return OK_SILENT;
}
    2f74:	80 e0       	ldi	r24, 0x00	; 0
    2f76:	90 e0       	ldi	r25, 0x00	; 0
    2f78:	1f 91       	pop	r17
    2f7a:	0f 91       	pop	r16
    2f7c:	ff 90       	pop	r15
    2f7e:	ef 90       	pop	r14
    2f80:	08 95       	ret

00002f82 <ustawPortRezystor>:
  MPC23s17SetPortB(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
    2f82:	fc 01       	movw	r30, r24
  if (state->argc < 1)
    2f84:	81 8d       	ldd	r24, Z+25	; 0x19
    2f86:	88 23       	and	r24, r24
    2f88:	19 f4       	brne	.+6      	; 0x2f90 <ustawPortRezystor+0xe>
    2f8a:	22 e0       	ldi	r18, 0x02	; 2
    2f8c:	30 e0       	ldi	r19, 0x00	; 0
    2f8e:	09 c0       	rjmp	.+18     	; 0x2fa2 <ustawPortRezystor+0x20>
    return SYNTAX_ERROR;

  uint8_t wartosc = cmdlineGetArgInt(1, state);
    2f90:	81 e0       	ldi	r24, 0x01	; 1
    2f92:	bf 01       	movw	r22, r30
    2f94:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2f98:	86 2f       	mov	r24, r22
  
  MCP4150_setValue(wartosc);
    2f9a:	0e 94 78 2f 	call	0x5ef0	; 0x5ef0 <MCP4150_setValue>
    2f9e:	20 e0       	ldi	r18, 0x00	; 0
    2fa0:	30 e0       	ldi	r19, 0x00	; 0
  
  return OK_SILENT;
}
    2fa2:	c9 01       	movw	r24, r18
    2fa4:	08 95       	ret

00002fa6 <ustawPortExtBFunction>:
  MPC23s17SetPortA(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
{
    2fa6:	1f 93       	push	r17
    2fa8:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    2faa:	81 e0       	ldi	r24, 0x01	; 1
    2fac:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2fb0:	16 2f       	mov	r17, r22
  MPC23s17SetDirB(0x00, 0);
    2fb2:	80 e0       	ldi	r24, 0x00	; 0
    2fb4:	60 e0       	ldi	r22, 0x00	; 0
    2fb6:	0e 94 f4 2e 	call	0x5de8	; 0x5de8 <MPC23s17SetDirB>
  MPC23s17SetPortB(wyjscie, 0);
    2fba:	81 2f       	mov	r24, r17
    2fbc:	60 e0       	ldi	r22, 0x00	; 0
    2fbe:	0e 94 7e 2e 	call	0x5cfc	; 0x5cfc <MPC23s17SetPortB>
  return OK_SILENT;
}
    2fc2:	80 e0       	ldi	r24, 0x00	; 0
    2fc4:	90 e0       	ldi	r25, 0x00	; 0
    2fc6:	1f 91       	pop	r17
    2fc8:	08 95       	ret

00002fca <ustawPortExtAFunction>:
  
  return ERROR_SILENT;
}

static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
{
    2fca:	1f 93       	push	r17
    2fcc:	bc 01       	movw	r22, r24
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    2fce:	81 e0       	ldi	r24, 0x01	; 1
    2fd0:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    2fd4:	16 2f       	mov	r17, r22
  MPC23s17SetDirA(0x00, 0);
    2fd6:	80 e0       	ldi	r24, 0x00	; 0
    2fd8:	60 e0       	ldi	r22, 0x00	; 0
    2fda:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <MPC23s17SetDirA>
  MPC23s17SetPortA(wyjscie, 0);
    2fde:	81 2f       	mov	r24, r17
    2fe0:	60 e0       	ldi	r22, 0x00	; 0
    2fe2:	0e 94 d6 2e 	call	0x5dac	; 0x5dac <MPC23s17SetPortA>
  return OK_SILENT;
}
    2fe6:	80 e0       	ldi	r24, 0x00	; 0
    2fe8:	90 e0       	ldi	r25, 0x00	; 0
    2fea:	1f 91       	pop	r17
    2fec:	08 95       	ret

00002fee <curtainDownFunction>:
  cmdPrintHelp(state);
  return OK_SILENT;
}

static cliExRes_t curtainDownFunction(cmdState_t *state)
{
    2fee:	ff 92       	push	r15
    2ff0:	0f 93       	push	r16
    2ff2:	1f 93       	push	r17
    2ff4:	cf 93       	push	r28
    2ff6:	df 93       	push	r29
    2ff8:	ec 01       	movw	r28, r24
  uint8_t nrRolety;
  uint8_t nrSterownika;
  uint8_t wartosc;
  
  nrSterownika = cmdlineGetArgInt(1, state);
    2ffa:	81 e0       	ldi	r24, 0x01	; 1
    2ffc:	be 01       	movw	r22, r28
    2ffe:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    3002:	f6 2e       	mov	r15, r22
  nrRolety = cmdlineGetArgInt(2, state);
    3004:	82 e0       	ldi	r24, 0x02	; 2
    3006:	be 01       	movw	r22, r28
    3008:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    300c:	16 2f       	mov	r17, r22
  nrRolety &= 0x01;
    300e:	11 70       	andi	r17, 0x01	; 1
  wartosc = cmdlineGetArgInt(3, state);
    3010:	83 e0       	ldi	r24, 0x03	; 3
    3012:	be 01       	movw	r22, r28
    3014:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    3018:	06 2f       	mov	r16, r22

  fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
    301a:	2d b7       	in	r18, 0x3d	; 61
    301c:	3e b7       	in	r19, 0x3e	; 62
    301e:	28 50       	subi	r18, 0x08	; 8
    3020:	30 40       	sbci	r19, 0x00	; 0
    3022:	0f b6       	in	r0, 0x3f	; 63
    3024:	f8 94       	cli
    3026:	3e bf       	out	0x3e, r19	; 62
    3028:	0f be       	out	0x3f, r0	; 63
    302a:	2d bf       	out	0x3d, r18	; 61
    302c:	ed b7       	in	r30, 0x3d	; 61
    302e:	fe b7       	in	r31, 0x3e	; 62
    3030:	31 96       	adiw	r30, 0x01	; 1
    3032:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3034:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3036:	ad b7       	in	r26, 0x3d	; 61
    3038:	be b7       	in	r27, 0x3e	; 62
    303a:	12 96       	adiw	r26, 0x02	; 2
    303c:	9c 93       	st	X, r25
    303e:	8e 93       	st	-X, r24
    3040:	11 97       	sbiw	r26, 0x01	; 1
    3042:	82 ed       	ldi	r24, 0xD2	; 210
    3044:	93 e0       	ldi	r25, 0x03	; 3
    3046:	93 83       	std	Z+3, r25	; 0x03
    3048:	82 83       	std	Z+2, r24	; 0x02
    304a:	f4 82       	std	Z+4, r15	; 0x04
    304c:	15 82       	std	Z+5, r1	; 0x05
    304e:	81 2f       	mov	r24, r17
    3050:	90 e0       	ldi	r25, 0x00	; 0
    3052:	01 96       	adiw	r24, 0x01	; 1
    3054:	97 83       	std	Z+7, r25	; 0x07
    3056:	86 83       	std	Z+6, r24	; 0x06
    3058:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>

  if ((wartosc > 0) && (wartosc <=100))
    305c:	80 2f       	mov	r24, r16
    305e:	81 50       	subi	r24, 0x01	; 1
    3060:	2d b7       	in	r18, 0x3d	; 61
    3062:	3e b7       	in	r19, 0x3e	; 62
    3064:	28 5f       	subi	r18, 0xF8	; 248
    3066:	3f 4f       	sbci	r19, 0xFF	; 255
    3068:	0f b6       	in	r0, 0x3f	; 63
    306a:	f8 94       	cli
    306c:	3e bf       	out	0x3e, r19	; 62
    306e:	0f be       	out	0x3f, r0	; 63
    3070:	2d bf       	out	0x3d, r18	; 61
    3072:	84 36       	cpi	r24, 0x64	; 100
    3074:	f8 f4       	brcc	.+62     	; 0x30b4 <curtainDownFunction+0xc6>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    3076:	00 d0       	rcall	.+0      	; 0x3078 <curtainDownFunction+0x8a>
    3078:	00 d0       	rcall	.+0      	; 0x307a <curtainDownFunction+0x8c>
    307a:	00 d0       	rcall	.+0      	; 0x307c <curtainDownFunction+0x8e>
    307c:	ed b7       	in	r30, 0x3d	; 61
    307e:	fe b7       	in	r31, 0x3e	; 62
    3080:	31 96       	adiw	r30, 0x01	; 1
    3082:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3084:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3086:	ad b7       	in	r26, 0x3d	; 61
    3088:	be b7       	in	r27, 0x3e	; 62
    308a:	12 96       	adiw	r26, 0x02	; 2
    308c:	9c 93       	st	X, r25
    308e:	8e 93       	st	-X, r24
    3090:	11 97       	sbiw	r26, 0x01	; 1
    3092:	85 e0       	ldi	r24, 0x05	; 5
    3094:	94 e0       	ldi	r25, 0x04	; 4
    3096:	93 83       	std	Z+3, r25	; 0x03
    3098:	82 83       	std	Z+2, r24	; 0x02
    309a:	04 83       	std	Z+4, r16	; 0x04
    309c:	15 82       	std	Z+5, r1	; 0x05
    309e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    30a2:	2d b7       	in	r18, 0x3d	; 61
    30a4:	3e b7       	in	r19, 0x3e	; 62
    30a6:	2a 5f       	subi	r18, 0xFA	; 250
    30a8:	3f 4f       	sbci	r19, 0xFF	; 255
    30aa:	0f b6       	in	r0, 0x3f	; 63
    30ac:	f8 94       	cli
    30ae:	3e bf       	out	0x3e, r19	; 62
    30b0:	0f be       	out	0x3f, r0	; 63
    30b2:	2d bf       	out	0x3d, r18	; 61

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
    30b4:	8f 2d       	mov	r24, r15
    30b6:	61 2f       	mov	r22, r17
    30b8:	40 2f       	mov	r20, r16
    30ba:	0e 94 96 5b 	call	0xb72c	; 0xb72c <rs485curtainDown>
  
  if (result == 0)
    30be:	88 23       	and	r24, r24
    30c0:	19 f0       	breq	.+6      	; 0x30c8 <curtainDownFunction+0xda>
    30c2:	23 e0       	ldi	r18, 0x03	; 3
    30c4:	30 e0       	ldi	r19, 0x00	; 0
    30c6:	02 c0       	rjmp	.+4      	; 0x30cc <curtainDownFunction+0xde>
    30c8:	21 e0       	ldi	r18, 0x01	; 1
    30ca:	30 e0       	ldi	r19, 0x00	; 0
    return OK_INFORM;
  
  return ERROR_SILENT;
}
    30cc:	c9 01       	movw	r24, r18
    30ce:	df 91       	pop	r29
    30d0:	cf 91       	pop	r28
    30d2:	1f 91       	pop	r17
    30d4:	0f 91       	pop	r16
    30d6:	ff 90       	pop	r15
    30d8:	08 95       	ret

000030da <curtainUpFunction>:

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
    30da:	ff 92       	push	r15
    30dc:	0f 93       	push	r16
    30de:	1f 93       	push	r17
    30e0:	cf 93       	push	r28
    30e2:	df 93       	push	r29
    30e4:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    30e6:	89 8d       	ldd	r24, Y+25	; 0x19
    30e8:	82 30       	cpi	r24, 0x02	; 2
    30ea:	18 f4       	brcc	.+6      	; 0x30f2 <curtainUpFunction+0x18>
    30ec:	22 e0       	ldi	r18, 0x02	; 2
    30ee:	30 e0       	ldi	r19, 0x00	; 0
    30f0:	6f c0       	rjmp	.+222    	; 0x31d0 <curtainUpFunction+0xf6>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
    30f2:	81 e0       	ldi	r24, 0x01	; 1
    30f4:	be 01       	movw	r22, r28
    30f6:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    30fa:	f6 2e       	mov	r15, r22
    30fc:	2f e3       	ldi	r18, 0x3F	; 63
    30fe:	f2 22       	and	r15, r18
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
    3100:	82 e0       	ldi	r24, 0x02	; 2
    3102:	be 01       	movw	r22, r28
    3104:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    3108:	06 2f       	mov	r16, r22
    310a:	01 70       	andi	r16, 0x01	; 1
  uint8_t wartosc = 255;
  if (state->argc > 2)
    310c:	89 8d       	ldd	r24, Y+25	; 0x19
    310e:	83 30       	cpi	r24, 0x03	; 3
    3110:	10 f4       	brcc	.+4      	; 0x3116 <curtainUpFunction+0x3c>
    3112:	1f ef       	ldi	r17, 0xFF	; 255
    3114:	05 c0       	rjmp	.+10     	; 0x3120 <curtainUpFunction+0x46>
    wartosc = cmdlineGetArgInt(3, state);
    3116:	83 e0       	ldi	r24, 0x03	; 3
    3118:	be 01       	movw	r22, r28
    311a:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    311e:	16 2f       	mov	r17, r22

  fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
    3120:	8d b7       	in	r24, 0x3d	; 61
    3122:	9e b7       	in	r25, 0x3e	; 62
    3124:	08 97       	sbiw	r24, 0x08	; 8
    3126:	0f b6       	in	r0, 0x3f	; 63
    3128:	f8 94       	cli
    312a:	9e bf       	out	0x3e, r25	; 62
    312c:	0f be       	out	0x3f, r0	; 63
    312e:	8d bf       	out	0x3d, r24	; 61
    3130:	ed b7       	in	r30, 0x3d	; 61
    3132:	fe b7       	in	r31, 0x3e	; 62
    3134:	31 96       	adiw	r30, 0x01	; 1
    3136:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3138:	9b 8d       	ldd	r25, Y+27	; 0x1b
    313a:	ad b7       	in	r26, 0x3d	; 61
    313c:	be b7       	in	r27, 0x3e	; 62
    313e:	12 96       	adiw	r26, 0x02	; 2
    3140:	9c 93       	st	X, r25
    3142:	8e 93       	st	-X, r24
    3144:	11 97       	sbiw	r26, 0x01	; 1
    3146:	8f e9       	ldi	r24, 0x9F	; 159
    3148:	93 e0       	ldi	r25, 0x03	; 3
    314a:	93 83       	std	Z+3, r25	; 0x03
    314c:	82 83       	std	Z+2, r24	; 0x02
    314e:	f4 82       	std	Z+4, r15	; 0x04
    3150:	15 82       	std	Z+5, r1	; 0x05
    3152:	80 2f       	mov	r24, r16
    3154:	90 e0       	ldi	r25, 0x00	; 0
    3156:	01 96       	adiw	r24, 0x01	; 1
    3158:	97 83       	std	Z+7, r25	; 0x07
    315a:	86 83       	std	Z+6, r24	; 0x06
    315c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  if ((wartosc > 0) && (wartosc <=100))
    3160:	81 2f       	mov	r24, r17
    3162:	81 50       	subi	r24, 0x01	; 1
    3164:	2d b7       	in	r18, 0x3d	; 61
    3166:	3e b7       	in	r19, 0x3e	; 62
    3168:	28 5f       	subi	r18, 0xF8	; 248
    316a:	3f 4f       	sbci	r19, 0xFF	; 255
    316c:	0f b6       	in	r0, 0x3f	; 63
    316e:	f8 94       	cli
    3170:	3e bf       	out	0x3e, r19	; 62
    3172:	0f be       	out	0x3f, r0	; 63
    3174:	2d bf       	out	0x3d, r18	; 61
    3176:	84 36       	cpi	r24, 0x64	; 100
    3178:	f8 f4       	brcc	.+62     	; 0x31b8 <curtainUpFunction+0xde>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    317a:	00 d0       	rcall	.+0      	; 0x317c <curtainUpFunction+0xa2>
    317c:	00 d0       	rcall	.+0      	; 0x317e <curtainUpFunction+0xa4>
    317e:	00 d0       	rcall	.+0      	; 0x3180 <curtainUpFunction+0xa6>
    3180:	ed b7       	in	r30, 0x3d	; 61
    3182:	fe b7       	in	r31, 0x3e	; 62
    3184:	31 96       	adiw	r30, 0x01	; 1
    3186:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3188:	9b 8d       	ldd	r25, Y+27	; 0x1b
    318a:	ad b7       	in	r26, 0x3d	; 61
    318c:	be b7       	in	r27, 0x3e	; 62
    318e:	12 96       	adiw	r26, 0x02	; 2
    3190:	9c 93       	st	X, r25
    3192:	8e 93       	st	-X, r24
    3194:	11 97       	sbiw	r26, 0x01	; 1
    3196:	85 e0       	ldi	r24, 0x05	; 5
    3198:	94 e0       	ldi	r25, 0x04	; 4
    319a:	93 83       	std	Z+3, r25	; 0x03
    319c:	82 83       	std	Z+2, r24	; 0x02
    319e:	14 83       	std	Z+4, r17	; 0x04
    31a0:	15 82       	std	Z+5, r1	; 0x05
    31a2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    31a6:	2d b7       	in	r18, 0x3d	; 61
    31a8:	3e b7       	in	r19, 0x3e	; 62
    31aa:	2a 5f       	subi	r18, 0xFA	; 250
    31ac:	3f 4f       	sbci	r19, 0xFF	; 255
    31ae:	0f b6       	in	r0, 0x3f	; 63
    31b0:	f8 94       	cli
    31b2:	3e bf       	out	0x3e, r19	; 62
    31b4:	0f be       	out	0x3f, r0	; 63
    31b6:	2d bf       	out	0x3d, r18	; 61

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
    31b8:	8f 2d       	mov	r24, r15
    31ba:	60 2f       	mov	r22, r16
    31bc:	41 2f       	mov	r20, r17
    31be:	0e 94 d2 5a 	call	0xb5a4	; 0xb5a4 <rs485curtainUp>
  
  if (result == 0)
    31c2:	88 23       	and	r24, r24
    31c4:	19 f0       	breq	.+6      	; 0x31cc <curtainUpFunction+0xf2>
    31c6:	23 e0       	ldi	r18, 0x03	; 3
    31c8:	30 e0       	ldi	r19, 0x00	; 0
    31ca:	02 c0       	rjmp	.+4      	; 0x31d0 <curtainUpFunction+0xf6>
    31cc:	21 e0       	ldi	r18, 0x01	; 1
    31ce:	30 e0       	ldi	r19, 0x00	; 0
    return OK_INFORM;
  
  return ERROR_SILENT;
}
    31d0:	c9 01       	movw	r24, r18
    31d2:	df 91       	pop	r29
    31d4:	cf 91       	pop	r28
    31d6:	1f 91       	pop	r17
    31d8:	0f 91       	pop	r16
    31da:	ff 90       	pop	r15
    31dc:	08 95       	ret

000031de <goXmodemWyslijFunction>:

  return OK_SILENT;
}

static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
{
    31de:	0f 93       	push	r16
    31e0:	1f 93       	push	r17
    31e2:	cf 93       	push	r28
    31e4:	df 93       	push	r29
    31e6:	ec 01       	movw	r28, r24
  fprintf_P(state->myStdInOut, xwyslijStartStr);
    31e8:	00 d0       	rcall	.+0      	; 0x31ea <goXmodemWyslijFunction+0xc>
    31ea:	00 d0       	rcall	.+0      	; 0x31ec <goXmodemWyslijFunction+0xe>
    31ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    31ee:	9b 8d       	ldd	r25, Y+27	; 0x1b
    31f0:	ad b7       	in	r26, 0x3d	; 61
    31f2:	be b7       	in	r27, 0x3e	; 62
    31f4:	12 96       	adiw	r26, 0x02	; 2
    31f6:	9c 93       	st	X, r25
    31f8:	8e 93       	st	-X, r24
    31fa:	11 97       	sbiw	r26, 0x01	; 1
    31fc:	82 e8       	ldi	r24, 0x82	; 130
    31fe:	93 e0       	ldi	r25, 0x03	; 3
    3200:	14 96       	adiw	r26, 0x04	; 4
    3202:	9c 93       	st	X, r25
    3204:	8e 93       	st	-X, r24
    3206:	13 97       	sbiw	r26, 0x03	; 3
    3208:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    320c:	0f 90       	pop	r0
    320e:	0f 90       	pop	r0
    3210:	0f 90       	pop	r0
    3212:	0f 90       	pop	r0
    3214:	81 e0       	ldi	r24, 0x01	; 1
    3216:	be 01       	movw	r22, r28
    3218:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    321c:	61 e8       	ldi	r22, 0x81	; 129
    321e:	7f e0       	ldi	r23, 0x0F	; 15
    3220:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ramDyskOtworzPlik>
    3224:	88 23       	and	r24, r24
    3226:	19 f4       	brne	.+6      	; 0x322e <goXmodemWyslijFunction+0x50>
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	30 e0       	ldi	r19, 0x00	; 0
    322c:	24 c0       	rjmp	.+72     	; 0x3276 <goXmodemWyslijFunction+0x98>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    322e:	0a 8d       	ldd	r16, Y+26	; 0x1a
    3230:	1b 8d       	ldd	r17, Y+27	; 0x1b
    3232:	81 e0       	ldi	r24, 0x01	; 1
    3234:	be 01       	movw	r22, r28
    3236:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    323a:	00 d0       	rcall	.+0      	; 0x323c <goXmodemWyslijFunction+0x5e>
    323c:	00 d0       	rcall	.+0      	; 0x323e <goXmodemWyslijFunction+0x60>
    323e:	00 d0       	rcall	.+0      	; 0x3240 <goXmodemWyslijFunction+0x62>
    3240:	ed b7       	in	r30, 0x3d	; 61
    3242:	fe b7       	in	r31, 0x3e	; 62
    3244:	31 96       	adiw	r30, 0x01	; 1
    3246:	ad b7       	in	r26, 0x3d	; 61
    3248:	be b7       	in	r27, 0x3e	; 62
    324a:	12 96       	adiw	r26, 0x02	; 2
    324c:	1c 93       	st	X, r17
    324e:	0e 93       	st	-X, r16
    3250:	11 97       	sbiw	r26, 0x01	; 1
    3252:	22 e8       	ldi	r18, 0x82	; 130
    3254:	31 e0       	ldi	r19, 0x01	; 1
    3256:	33 83       	std	Z+3, r19	; 0x03
    3258:	22 83       	std	Z+2, r18	; 0x02
    325a:	95 83       	std	Z+5, r25	; 0x05
    325c:	84 83       	std	Z+4, r24	; 0x04
    325e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    3262:	24 e0       	ldi	r18, 0x04	; 4
    3264:	30 e0       	ldi	r19, 0x00	; 0
    3266:	ed b7       	in	r30, 0x3d	; 61
    3268:	fe b7       	in	r31, 0x3e	; 62
    326a:	36 96       	adiw	r30, 0x06	; 6
    326c:	0f b6       	in	r0, 0x3f	; 63
    326e:	f8 94       	cli
    3270:	fe bf       	out	0x3e, r31	; 62
    3272:	0f be       	out	0x3f, r0	; 63
    3274:	ed bf       	out	0x3d, r30	; 61
    return ERROR_INFORM;
  }
  return OK_SILENT;
}
    3276:	c9 01       	movw	r24, r18
    3278:	df 91       	pop	r29
    327a:	cf 91       	pop	r28
    327c:	1f 91       	pop	r17
    327e:	0f 91       	pop	r16
    3280:	08 95       	ret

00003282 <editRamFileFunction>:
  ramDyskDir(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t editRamFileFunction(cmdState_t *state)
{
    3282:	ef 92       	push	r14
    3284:	ff 92       	push	r15
    3286:	0f 93       	push	r16
    3288:	1f 93       	push	r17
    328a:	df 93       	push	r29
    328c:	cf 93       	push	r28
    328e:	0f 92       	push	r0
    3290:	cd b7       	in	r28, 0x3d	; 61
    3292:	de b7       	in	r29, 0x3e	; 62
    3294:	7c 01       	movw	r14, r24
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    3296:	81 e0       	ldi	r24, 0x01	; 1
    3298:	b7 01       	movw	r22, r14
    329a:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    329e:	61 e8       	ldi	r22, 0x81	; 129
    32a0:	7f e0       	ldi	r23, 0x0F	; 15
    32a2:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ramDyskOtworzPlik>
    32a6:	88 23       	and	r24, r24
    32a8:	41 f1       	breq	.+80     	; 0x32fa <editRamFileFunction+0x78>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    32aa:	d7 01       	movw	r26, r14
    32ac:	5a 96       	adiw	r26, 0x1a	; 26
    32ae:	0d 91       	ld	r16, X+
    32b0:	1c 91       	ld	r17, X
    32b2:	5b 97       	sbiw	r26, 0x1b	; 27
    32b4:	81 e0       	ldi	r24, 0x01	; 1
    32b6:	b7 01       	movw	r22, r14
    32b8:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    32bc:	00 d0       	rcall	.+0      	; 0x32be <editRamFileFunction+0x3c>
    32be:	00 d0       	rcall	.+0      	; 0x32c0 <editRamFileFunction+0x3e>
    32c0:	00 d0       	rcall	.+0      	; 0x32c2 <editRamFileFunction+0x40>
    32c2:	ed b7       	in	r30, 0x3d	; 61
    32c4:	fe b7       	in	r31, 0x3e	; 62
    32c6:	31 96       	adiw	r30, 0x01	; 1
    32c8:	ad b7       	in	r26, 0x3d	; 61
    32ca:	be b7       	in	r27, 0x3e	; 62
    32cc:	12 96       	adiw	r26, 0x02	; 2
    32ce:	1c 93       	st	X, r17
    32d0:	0e 93       	st	-X, r16
    32d2:	11 97       	sbiw	r26, 0x01	; 1
    32d4:	22 e8       	ldi	r18, 0x82	; 130
    32d6:	31 e0       	ldi	r19, 0x01	; 1
    32d8:	33 83       	std	Z+3, r19	; 0x03
    32da:	22 83       	std	Z+2, r18	; 0x02
    32dc:	95 83       	std	Z+5, r25	; 0x05
    32de:	84 83       	std	Z+4, r24	; 0x04
    32e0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    32e4:	24 e0       	ldi	r18, 0x04	; 4
    32e6:	30 e0       	ldi	r19, 0x00	; 0
    32e8:	ed b7       	in	r30, 0x3d	; 61
    32ea:	fe b7       	in	r31, 0x3e	; 62
    32ec:	36 96       	adiw	r30, 0x06	; 6
    32ee:	0f b6       	in	r0, 0x3f	; 63
    32f0:	f8 94       	cli
    32f2:	fe bf       	out	0x3e, r31	; 62
    32f4:	0f be       	out	0x3f, r0	; 63
    32f6:	ed bf       	out	0x3d, r30	; 61
    32f8:	3b c0       	rjmp	.+118    	; 0x3370 <editRamFileFunction+0xee>
    return ERROR_INFORM;
  }
  ramDyskUstawWskaznikNaKoniec(&fdVty);
    32fa:	81 e8       	ldi	r24, 0x81	; 129
    32fc:	9f e0       	ldi	r25, 0x0F	; 15
    32fe:	0e 94 6a 23 	call	0x46d4	; 0x46d4 <ramDyskUstawWskaznikNaKoniec>
  uint8_t znak = 0;
    3302:	19 82       	std	Y+1, r1	; 0x01
  fprintf_P(state->myStdInOut, editRamFileIntroStr);
    3304:	00 d0       	rcall	.+0      	; 0x3306 <editRamFileFunction+0x84>
    3306:	00 d0       	rcall	.+0      	; 0x3308 <editRamFileFunction+0x86>
    3308:	d7 01       	movw	r26, r14
    330a:	5a 96       	adiw	r26, 0x1a	; 26
    330c:	8d 91       	ld	r24, X+
    330e:	9c 91       	ld	r25, X
    3310:	5b 97       	sbiw	r26, 0x1b	; 27
    3312:	ed b7       	in	r30, 0x3d	; 61
    3314:	fe b7       	in	r31, 0x3e	; 62
    3316:	92 83       	std	Z+2, r25	; 0x02
    3318:	81 83       	std	Z+1, r24	; 0x01
    331a:	88 e4       	ldi	r24, 0x48	; 72
    331c:	93 e0       	ldi	r25, 0x03	; 3
    331e:	94 83       	std	Z+4, r25	; 0x04
    3320:	83 83       	std	Z+3, r24	; 0x03
    3322:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    3326:	0f 90       	pop	r0
    3328:	0f 90       	pop	r0
    332a:	0f 90       	pop	r0
    332c:	0f 90       	pop	r0
  while(1)
  {
    if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
    332e:	7e 01       	movw	r14, r28
    3330:	08 94       	sec
    3332:	e1 1c       	adc	r14, r1
    3334:	f1 1c       	adc	r15, r1
    3336:	80 91 c4 0e 	lds	r24, 0x0EC4
    333a:	90 91 c5 0e 	lds	r25, 0x0EC5
    333e:	b7 01       	movw	r22, r14
    3340:	4f ef       	ldi	r20, 0xFF	; 255
    3342:	5f ef       	ldi	r21, 0xFF	; 255
    3344:	20 e0       	ldi	r18, 0x00	; 0
    3346:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    334a:	88 23       	and	r24, r24
    334c:	a1 f3       	breq	.-24     	; 0x3336 <editRamFileFunction+0xb4>
      continue;

    if (znak == 0x03)                                       // ^C
    334e:	89 81       	ldd	r24, Y+1	; 0x01
    3350:	83 30       	cpi	r24, 0x03	; 3
    3352:	41 f0       	breq	.+16     	; 0x3364 <editRamFileFunction+0xe2>
      break;

    uartVtySendByte(znak);                                  //Echo
    3354:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
    ramDyskZapiszBajtDoPliku(&fdVty, znak);
    3358:	81 e8       	ldi	r24, 0x81	; 129
    335a:	9f e0       	ldi	r25, 0x0F	; 15
    335c:	69 81       	ldd	r22, Y+1	; 0x01
    335e:	0e 94 36 24 	call	0x486c	; 0x486c <ramDyskZapiszBajtDoPliku>
    3362:	e9 cf       	rjmp	.-46     	; 0x3336 <editRamFileFunction+0xb4>
  }
  ramDyskZamknijPlik(&fdVty);
    3364:	81 e8       	ldi	r24, 0x81	; 129
    3366:	9f e0       	ldi	r25, 0x0F	; 15
    3368:	0e 94 c1 24 	call	0x4982	; 0x4982 <ramDyskZamknijPlik>
    336c:	20 e0       	ldi	r18, 0x00	; 0
    336e:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    3370:	c9 01       	movw	r24, r18
    3372:	0f 90       	pop	r0
    3374:	cf 91       	pop	r28
    3376:	df 91       	pop	r29
    3378:	1f 91       	pop	r17
    337a:	0f 91       	pop	r16
    337c:	ff 90       	pop	r15
    337e:	ef 90       	pop	r14
    3380:	08 95       	ret

00003382 <eraseRamFileFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
    3382:	cf 93       	push	r28
    3384:	df 93       	push	r29
    3386:	ec 01       	movw	r28, r24
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    3388:	81 e0       	ldi	r24, 0x01	; 1
    338a:	be 01       	movw	r22, r28
    338c:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    3390:	0e 94 98 26 	call	0x4d30	; 0x4d30 <ramDyskUsunPlik>
    3394:	88 23       	and	r24, r24
    3396:	19 f4       	brne	.+6      	; 0x339e <eraseRamFileFunction+0x1c>
    3398:	21 e0       	ldi	r18, 0x01	; 1
    339a:	30 e0       	ldi	r19, 0x00	; 0
    339c:	05 c0       	rjmp	.+10     	; 0x33a8 <eraseRamFileFunction+0x26>
    return OK_INFORM;

  printErrorInfo(state);
    339e:	ce 01       	movw	r24, r28
    33a0:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <printErrorInfo>
    33a4:	24 e0       	ldi	r18, 0x04	; 4
    33a6:	30 e0       	ldi	r19, 0x00	; 0
  return ERROR_INFORM;
}
    33a8:	c9 01       	movw	r24, r18
    33aa:	df 91       	pop	r29
    33ac:	cf 91       	pop	r28
    33ae:	08 95       	ret

000033b0 <dodajRamPlikFunction>:

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
    33b0:	cf 93       	push	r28
    33b2:	df 93       	push	r29
    33b4:	ec 01       	movw	r28, r24
  if (state->argc != 1)
    33b6:	89 8d       	ldd	r24, Y+25	; 0x19
    33b8:	81 30       	cpi	r24, 0x01	; 1
    33ba:	19 f0       	breq	.+6      	; 0x33c2 <dodajRamPlikFunction+0x12>
    33bc:	22 e0       	ldi	r18, 0x02	; 2
    33be:	30 e0       	ldi	r19, 0x00	; 0
    33c0:	10 c0       	rjmp	.+32     	; 0x33e2 <dodajRamPlikFunction+0x32>
    return SYNTAX_ERROR;

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
    33c2:	81 e0       	ldi	r24, 0x01	; 1
    33c4:	be 01       	movw	r22, r28
    33c6:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    33ca:	0e 94 f7 26 	call	0x4dee	; 0x4dee <ramDyskUtworzPlik>
    33ce:	88 23       	and	r24, r24
    33d0:	19 f4       	brne	.+6      	; 0x33d8 <dodajRamPlikFunction+0x28>
    33d2:	21 e0       	ldi	r18, 0x01	; 1
    33d4:	30 e0       	ldi	r19, 0x00	; 0
    33d6:	05 c0       	rjmp	.+10     	; 0x33e2 <dodajRamPlikFunction+0x32>
  {
    return OK_INFORM;
  }
  printErrorInfo(state);
    33d8:	ce 01       	movw	r24, r28
    33da:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <printErrorInfo>
    33de:	24 e0       	ldi	r18, 0x04	; 4
    33e0:	30 e0       	ldi	r19, 0x00	; 0
  return ERROR_INFORM;
}
    33e2:	c9 01       	movw	r24, r18
    33e4:	df 91       	pop	r29
    33e6:	cf 91       	pop	r28
    33e8:	08 95       	ret

000033ea <rpingFunction>:
  
  return OK_SILENT;
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
    33ea:	1f 93       	push	r17
    33ec:	cf 93       	push	r28
    33ee:	df 93       	push	r29
    33f0:	ec 01       	movw	r28, r24
  if (state->argc < 1)
    33f2:	89 8d       	ldd	r24, Y+25	; 0x19
    33f4:	88 23       	and	r24, r24
    33f6:	19 f4       	brne	.+6      	; 0x33fe <rpingFunction+0x14>
    33f8:	22 e0       	ldi	r18, 0x02	; 2
    33fa:	30 e0       	ldi	r19, 0x00	; 0
    33fc:	17 c0       	rjmp	.+46     	; 0x342c <rpingFunction+0x42>
    return SYNTAX_ERROR;
  
  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
    33fe:	81 e0       	ldi	r24, 0x01	; 1
    3400:	be 01       	movw	r22, r28
    3402:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    3406:	16 2f       	mov	r17, r22
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    3408:	86 2f       	mov	r24, r22
    340a:	0e 94 1f 60 	call	0xc03e	; 0xc03e <rs485ping>
    340e:	8f 8f       	std	Y+31, r24	; 0x1f
    3410:	88 23       	and	r24, r24
    3412:	19 f4       	brne	.+6      	; 0x341a <rpingFunction+0x30>
    3414:	21 e0       	ldi	r18, 0x01	; 1
    3416:	30 e0       	ldi	r19, 0x00	; 0
    3418:	09 c0       	rjmp	.+18     	; 0x342c <rpingFunction+0x42>
    return OK_INFORM;

  state->errno = noRemoteDevice;
    341a:	89 e0       	ldi	r24, 0x09	; 9
    341c:	8c 8f       	std	Y+28, r24	; 0x1c
  state->err1 = nrSterownika;
    341e:	1d 8f       	std	Y+29, r17	; 0x1d
    3420:	1e 8e       	std	Y+30, r1	; 0x1e
  printErrorInfo(state);
    3422:	ce 01       	movw	r24, r28
    3424:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <printErrorInfo>
    3428:	20 e0       	ldi	r18, 0x00	; 0
    342a:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    342c:	c9 01       	movw	r24, r18
    342e:	df 91       	pop	r29
    3430:	cf 91       	pop	r28
    3432:	1f 91       	pop	r17
    3434:	08 95       	ret

00003436 <flashExModuleFunction>:
  return OK_SILENT;
}


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
    3436:	ff 92       	push	r15
    3438:	0f 93       	push	r16
    343a:	1f 93       	push	r17
    343c:	cf 93       	push	r28
    343e:	df 93       	push	r29
    3440:	ec 01       	movw	r28, r24
  if (state->argc != 2)
    3442:	89 8d       	ldd	r24, Y+25	; 0x19
    3444:	82 30       	cpi	r24, 0x02	; 2
    3446:	19 f0       	breq	.+6      	; 0x344e <flashExModuleFunction+0x18>
    3448:	22 e0       	ldi	r18, 0x02	; 2
    344a:	30 e0       	ldi	r19, 0x00	; 0
    344c:	4e c0       	rjmp	.+156    	; 0x34ea <flashExModuleFunction+0xb4>
    return SYNTAX_ERROR;
  
  uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
    344e:	81 e0       	ldi	r24, 0x01	; 1
    3450:	be 01       	movw	r22, r28
    3452:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    3456:	f6 2e       	mov	r15, r22
  char *nazwaPliku      = cmdlineGetArgStr(2, state);
    3458:	82 e0       	ldi	r24, 0x02	; 2
    345a:	be 01       	movw	r22, r28
    345c:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    3460:	8c 01       	movw	r16, r24
  uint8_t  blad;
  
  // Sprawdzanie, czy modu wykonawczy odpowiada
  if (rs485ping(nrUrzadzenia) != 0)
    3462:	8f 2d       	mov	r24, r15
    3464:	0e 94 1f 60 	call	0xc03e	; 0xc03e <rs485ping>
    3468:	88 23       	and	r24, r24
    346a:	31 f0       	breq	.+12     	; 0x3478 <flashExModuleFunction+0x42>
  {
    state->errno = noRemoteDevice;
    346c:	89 e0       	ldi	r24, 0x09	; 9
    346e:	8c 8f       	std	Y+28, r24	; 0x1c
    printErrorInfo(state);
    3470:	ce 01       	movw	r24, r28
    3472:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <printErrorInfo>
    3476:	37 c0       	rjmp	.+110    	; 0x34e6 <flashExModuleFunction+0xb0>
    return ERROR_INFORM;
  }
  
  //Sprawdzanie, czy istnieje odpowiedni plik z firmware
  if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
    3478:	c8 01       	movw	r24, r16
    347a:	61 e8       	ldi	r22, 0x81	; 129
    347c:	7f e0       	ldi	r23, 0x0F	; 15
    347e:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ramDyskOtworzPlik>
    3482:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3484:	5b 8d       	ldd	r21, Y+27	; 0x1b
    3486:	88 23       	and	r24, r24
    3488:	f9 f0       	breq	.+62     	; 0x34c8 <flashExModuleFunction+0x92>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
    348a:	00 d0       	rcall	.+0      	; 0x348c <flashExModuleFunction+0x56>
    348c:	00 d0       	rcall	.+0      	; 0x348e <flashExModuleFunction+0x58>
    348e:	00 d0       	rcall	.+0      	; 0x3490 <flashExModuleFunction+0x5a>
    3490:	ed b7       	in	r30, 0x3d	; 61
    3492:	fe b7       	in	r31, 0x3e	; 62
    3494:	31 96       	adiw	r30, 0x01	; 1
    3496:	ad b7       	in	r26, 0x3d	; 61
    3498:	be b7       	in	r27, 0x3e	; 62
    349a:	12 96       	adiw	r26, 0x02	; 2
    349c:	5c 93       	st	X, r21
    349e:	4e 93       	st	-X, r20
    34a0:	11 97       	sbiw	r26, 0x01	; 1
    34a2:	82 e8       	ldi	r24, 0x82	; 130
    34a4:	91 e0       	ldi	r25, 0x01	; 1
    34a6:	93 83       	std	Z+3, r25	; 0x03
    34a8:	82 83       	std	Z+2, r24	; 0x02
    34aa:	15 83       	std	Z+5, r17	; 0x05
    34ac:	04 83       	std	Z+4, r16	; 0x04
    34ae:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    34b2:	24 e0       	ldi	r18, 0x04	; 4
    34b4:	30 e0       	ldi	r19, 0x00	; 0
    34b6:	8d b7       	in	r24, 0x3d	; 61
    34b8:	9e b7       	in	r25, 0x3e	; 62
    34ba:	06 96       	adiw	r24, 0x06	; 6
    34bc:	0f b6       	in	r0, 0x3f	; 63
    34be:	f8 94       	cli
    34c0:	9e bf       	out	0x3e, r25	; 62
    34c2:	0f be       	out	0x3f, r0	; 63
    34c4:	8d bf       	out	0x3d, r24	; 61
    34c6:	11 c0       	rjmp	.+34     	; 0x34ea <flashExModuleFunction+0xb4>
    return ERROR_INFORM;
  }
  
  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
    34c8:	81 e8       	ldi	r24, 0x81	; 129
    34ca:	9f e0       	ldi	r25, 0x0F	; 15
    34cc:	6f 2d       	mov	r22, r15
    34ce:	0e 94 cb 5c 	call	0xb996	; 0xb996 <rs485xModemFlash>
    34d2:	18 2f       	mov	r17, r24

  ramDyskZamknijPlik(&fdVty);
    34d4:	81 e8       	ldi	r24, 0x81	; 129
    34d6:	9f e0       	ldi	r25, 0x0F	; 15
    34d8:	0e 94 c1 24 	call	0x4982	; 0x4982 <ramDyskZamknijPlik>
  
  if (blad != 0)
    34dc:	11 23       	and	r17, r17
    34de:	19 f4       	brne	.+6      	; 0x34e6 <flashExModuleFunction+0xb0>
    34e0:	20 e0       	ldi	r18, 0x00	; 0
    34e2:	30 e0       	ldi	r19, 0x00	; 0
    34e4:	02 c0       	rjmp	.+4      	; 0x34ea <flashExModuleFunction+0xb4>
    34e6:	24 e0       	ldi	r18, 0x04	; 4
    34e8:	30 e0       	ldi	r19, 0x00	; 0
    return ERROR_INFORM;

  return OK_SILENT;
}
    34ea:	c9 01       	movw	r24, r18
    34ec:	df 91       	pop	r29
    34ee:	cf 91       	pop	r28
    34f0:	1f 91       	pop	r17
    34f2:	0f 91       	pop	r16
    34f4:	ff 90       	pop	r15
    34f6:	08 95       	ret

000034f8 <goXmodemOdbierzFunction>:
  }
  return OK_SILENT;
}

static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
{
    34f8:	2f 92       	push	r2
    34fa:	3f 92       	push	r3
    34fc:	4f 92       	push	r4
    34fe:	5f 92       	push	r5
    3500:	6f 92       	push	r6
    3502:	7f 92       	push	r7
    3504:	8f 92       	push	r8
    3506:	9f 92       	push	r9
    3508:	af 92       	push	r10
    350a:	bf 92       	push	r11
    350c:	cf 92       	push	r12
    350e:	df 92       	push	r13
    3510:	ef 92       	push	r14
    3512:	ff 92       	push	r15
    3514:	0f 93       	push	r16
    3516:	1f 93       	push	r17
    3518:	df 93       	push	r29
    351a:	cf 93       	push	r28
    351c:	00 d0       	rcall	.+0      	; 0x351e <goXmodemOdbierzFunction+0x26>
    351e:	00 d0       	rcall	.+0      	; 0x3520 <goXmodemOdbierzFunction+0x28>
    3520:	00 d0       	rcall	.+0      	; 0x3522 <goXmodemOdbierzFunction+0x2a>
    3522:	cd b7       	in	r28, 0x3d	; 61
    3524:	de b7       	in	r29, 0x3e	; 62
    3526:	7c 01       	movw	r14, r24
  fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
    3528:	00 d0       	rcall	.+0      	; 0x352a <goXmodemOdbierzFunction+0x32>
    352a:	00 d0       	rcall	.+0      	; 0x352c <goXmodemOdbierzFunction+0x34>
    352c:	dc 01       	movw	r26, r24
    352e:	5a 96       	adiw	r26, 0x1a	; 26
    3530:	8d 91       	ld	r24, X+
    3532:	9c 91       	ld	r25, X
    3534:	5b 97       	sbiw	r26, 0x1b	; 27
    3536:	ed b7       	in	r30, 0x3d	; 61
    3538:	fe b7       	in	r31, 0x3e	; 62
    353a:	92 83       	std	Z+2, r25	; 0x02
    353c:	81 83       	std	Z+1, r24	; 0x01
    353e:	87 e8       	ldi	r24, 0x87	; 135
    3540:	9a e0       	ldi	r25, 0x0A	; 10
    3542:	94 83       	std	Z+4, r25	; 0x04
    3544:	83 83       	std	Z+3, r24	; 0x03
    3546:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    354a:	0f 90       	pop	r0
    354c:	0f 90       	pop	r0
    354e:	0f 90       	pop	r0
    3550:	0f 90       	pop	r0
    3552:	81 e0       	ldi	r24, 0x01	; 1
    3554:	b7 01       	movw	r22, r14
    3556:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    355a:	61 e8       	ldi	r22, 0x81	; 129
    355c:	7f e0       	ldi	r23, 0x0F	; 15
    355e:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ramDyskOtworzPlik>
    3562:	88 23       	and	r24, r24
    3564:	41 f1       	breq	.+80     	; 0x35b6 <goXmodemOdbierzFunction+0xbe>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    3566:	d7 01       	movw	r26, r14
    3568:	5a 96       	adiw	r26, 0x1a	; 26
    356a:	0d 91       	ld	r16, X+
    356c:	1c 91       	ld	r17, X
    356e:	5b 97       	sbiw	r26, 0x1b	; 27
    3570:	81 e0       	ldi	r24, 0x01	; 1
    3572:	b7 01       	movw	r22, r14
    3574:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    3578:	00 d0       	rcall	.+0      	; 0x357a <goXmodemOdbierzFunction+0x82>
    357a:	00 d0       	rcall	.+0      	; 0x357c <goXmodemOdbierzFunction+0x84>
    357c:	00 d0       	rcall	.+0      	; 0x357e <goXmodemOdbierzFunction+0x86>
    357e:	ed b7       	in	r30, 0x3d	; 61
    3580:	fe b7       	in	r31, 0x3e	; 62
    3582:	31 96       	adiw	r30, 0x01	; 1
    3584:	ad b7       	in	r26, 0x3d	; 61
    3586:	be b7       	in	r27, 0x3e	; 62
    3588:	12 96       	adiw	r26, 0x02	; 2
    358a:	1c 93       	st	X, r17
    358c:	0e 93       	st	-X, r16
    358e:	11 97       	sbiw	r26, 0x01	; 1
    3590:	22 e8       	ldi	r18, 0x82	; 130
    3592:	31 e0       	ldi	r19, 0x01	; 1
    3594:	33 83       	std	Z+3, r19	; 0x03
    3596:	22 83       	std	Z+2, r18	; 0x02
    3598:	95 83       	std	Z+5, r25	; 0x05
    359a:	84 83       	std	Z+4, r24	; 0x04
    359c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    35a0:	24 e0       	ldi	r18, 0x04	; 4
    35a2:	30 e0       	ldi	r19, 0x00	; 0
    35a4:	ed b7       	in	r30, 0x3d	; 61
    35a6:	fe b7       	in	r31, 0x3e	; 62
    35a8:	36 96       	adiw	r30, 0x06	; 6
    35aa:	0f b6       	in	r0, 0x3f	; 63
    35ac:	f8 94       	cli
    35ae:	fe bf       	out	0x3e, r31	; 62
    35b0:	0f be       	out	0x3f, r0	; 63
    35b2:	ed bf       	out	0x3d, r30	; 61
    35b4:	7b c1       	rjmp	.+758    	; 0x38ac <goXmodemOdbierzFunction+0x3b4>
  uint8_t nrBlokuZdalnyNeg;

  uint8_t crcHi;
  uint8_t crcLo;

  state->err1=0;
    35b6:	d7 01       	movw	r26, r14
    35b8:	5e 96       	adiw	r26, 0x1e	; 30
    35ba:	1c 92       	st	X, r1
    35bc:	1e 92       	st	-X, r1
    35be:	5d 97       	sbiw	r26, 0x1d	; 29
  state->err2=0;
    35c0:	5f 96       	adiw	r26, 0x1f	; 31
    35c2:	1c 92       	st	X, r1
    35c4:	04 e1       	ldi	r16, 0x14	; 20
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na oprnienie bufora

    if(xQueueReceive(xVtyRec, &c, 100))
    35c6:	b2 e0       	ldi	r27, 0x02	; 2
    35c8:	cb 2e       	mov	r12, r27
    35ca:	d1 2c       	mov	r13, r1
    35cc:	cc 0e       	add	r12, r28
    35ce:	dd 1e       	adc	r13, r29
  state->err1=0;
  state->err2=0;
  liczbaProb = 20;
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    35d0:	f7 01       	movw	r30, r14
    35d2:	62 8d       	ldd	r22, Z+26	; 0x1a
    35d4:	73 8d       	ldd	r23, Z+27	; 0x1b
    35d6:	83 e4       	ldi	r24, 0x43	; 67
    35d8:	90 e0       	ldi	r25, 0x00	; 0
    35da:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na oprnienie bufora
    35de:	80 91 9b 00 	lds	r24, 0x009B
    35e2:	86 ff       	sbrs	r24, 6
    35e4:	fc cf       	rjmp	.-8      	; 0x35de <goXmodemOdbierzFunction+0xe6>

    if(xQueueReceive(xVtyRec, &c, 100))
    35e6:	80 91 c4 0e 	lds	r24, 0x0EC4
    35ea:	90 91 c5 0e 	lds	r25, 0x0EC5
    35ee:	b6 01       	movw	r22, r12
    35f0:	44 e6       	ldi	r20, 0x64	; 100
    35f2:	50 e0       	ldi	r21, 0x00	; 0
    35f4:	20 e0       	ldi	r18, 0x00	; 0
    35f6:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    35fa:	88 23       	and	r24, r24
    35fc:	19 f0       	breq	.+6      	; 0x3604 <goXmodemOdbierzFunction+0x10c>
      if (c == SOH)
    35fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3600:	81 30       	cpi	r24, 0x01	; 1
    3602:	61 f0       	breq	.+24     	; 0x361c <goXmodemOdbierzFunction+0x124>
        break;                                                   //Rozpoczynamy transmisje

    liczbaProb--;
    3604:	01 50       	subi	r16, 0x01	; 1
    if (liczbaProb == 0)
    3606:	21 f7       	brne	.-56     	; 0x35d0 <goXmodemOdbierzFunction+0xd8>
    {
      ramDyskZamknijPlik(&fdVty);
    3608:	81 e8       	ldi	r24, 0x81	; 129
    360a:	9f e0       	ldi	r25, 0x0F	; 15
    360c:	0e 94 c1 24 	call	0x4982	; 0x4982 <ramDyskZamknijPlik>
      state->errno = (uint8_t)(AllOK);
    3610:	d7 01       	movw	r26, r14
    3612:	5c 96       	adiw	r26, 0x1c	; 28
    3614:	1c 92       	st	X, r1
    3616:	24 e0       	ldi	r18, 0x04	; 4
    3618:	30 e0       	ldi	r19, 0x00	; 0
    361a:	48 c1       	rjmp	.+656    	; 0x38ac <goXmodemOdbierzFunction+0x3b4>
  }
  
  nrBloku = 1;
  liczbaProb = 10;

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    361c:	81 e8       	ldi	r24, 0x81	; 129
    361e:	9f e0       	ldi	r25, 0x0F	; 15
    3620:	61 e0       	ldi	r22, 0x01	; 1
    3622:	70 e0       	ldi	r23, 0x00	; 0
    3624:	0e 94 04 23 	call	0x4608	; 0x4608 <ramDyskDodajBlokXmodem>
    3628:	6c 01       	movw	r12, r24
    362a:	5c 01       	movw	r10, r24
    362c:	aa e0       	ldi	r26, 0x0A	; 10
    362e:	9a 2e       	mov	r9, r26
    3630:	11 e0       	ldi	r17, 0x01	; 1
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    3632:	f3 e0       	ldi	r31, 0x03	; 3
    3634:	8f 2e       	mov	r8, r31
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    3636:	e5 e0       	ldi	r30, 0x05	; 5
    3638:	2e 2e       	mov	r2, r30
    363a:	31 2c       	mov	r3, r1
    363c:	2c 0e       	add	r2, r28
    363e:	3d 1e       	adc	r3, r29
    {
        state->errno = (uint8_t)(xModemFrameCrc);
        state->err1 = 2;
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    3640:	76 e0       	ldi	r23, 0x06	; 6
    3642:	47 2e       	mov	r4, r23
    3644:	51 2c       	mov	r5, r1
    3646:	4c 0e       	add	r4, r28
    3648:	5d 1e       	adc	r5, r29
      state->err2 = nrBloku;
      state->errno = (uint8_t)(xModemWrongFrameNo);
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    364a:	3e 01       	movw	r6, r28
    364c:	08 94       	sec
    364e:	61 1c       	adc	r6, r1
    3650:	71 1c       	adc	r7, r1

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    3652:	80 91 c4 0e 	lds	r24, 0x0EC4
    3656:	90 91 c5 0e 	lds	r25, 0x0EC5
    365a:	be 01       	movw	r22, r28
    365c:	6d 5f       	subi	r22, 0xFD	; 253
    365e:	7f 4f       	sbci	r23, 0xFF	; 255
    3660:	44 e6       	ldi	r20, 0x64	; 100
    3662:	50 e0       	ldi	r21, 0x00	; 0
    3664:	20 e0       	ldi	r18, 0x00	; 0
    3666:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    366a:	88 23       	and	r24, r24
    366c:	09 f4       	brne	.+2      	; 0x3670 <goXmodemOdbierzFunction+0x178>
    366e:	dd c0       	rjmp	.+442    	; 0x382a <goXmodemOdbierzFunction+0x332>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
      break; 
    }
    
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    3670:	80 91 c4 0e 	lds	r24, 0x0EC4
    3674:	90 91 c5 0e 	lds	r25, 0x0EC5
    3678:	be 01       	movw	r22, r28
    367a:	6c 5f       	subi	r22, 0xFC	; 252
    367c:	7f 4f       	sbci	r23, 0xFF	; 255
    367e:	41 e0       	ldi	r20, 0x01	; 1
    3680:	50 e0       	ldi	r21, 0x00	; 0
    3682:	20 e0       	ldi	r18, 0x00	; 0
    3684:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    3688:	88 23       	and	r24, r24
    368a:	19 f4       	brne	.+6      	; 0x3692 <goXmodemOdbierzFunction+0x19a>
    {
      state->errno = (uint8_t)(xModemByteSendTimeout);
    368c:	83 e0       	ldi	r24, 0x03	; 3
    368e:	d7 01       	movw	r26, r14
    3690:	bd c0       	rjmp	.+378    	; 0x380c <goXmodemOdbierzFunction+0x314>
      break; 
    }
  
    //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupenieniu bitowym do 1
    c = 255-nrBlokuZdalnyNeg;
    3692:	9c 81       	ldd	r25, Y+4	; 0x04
    3694:	89 2f       	mov	r24, r25
    3696:	80 95       	com	r24
    3698:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny != c)
    369a:	0b 81       	ldd	r16, Y+3	; 0x03
    369c:	08 17       	cp	r16, r24
    369e:	39 f0       	breq	.+14     	; 0x36ae <goXmodemOdbierzFunction+0x1b6>
    {
      state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
    36a0:	85 e0       	ldi	r24, 0x05	; 5
    36a2:	f7 01       	movw	r30, r14
    36a4:	84 8f       	std	Z+28, r24	; 0x1c
      state->err1 = nrBlokuZdalny;
    36a6:	05 8f       	std	Z+29, r16	; 0x1d
    36a8:	16 8e       	std	Z+30, r1	; 0x1e
      state->err2 = nrBlokuZdalnyNeg;
    36aa:	97 8f       	std	Z+31, r25	; 0x1f
    36ac:	f9 c0       	rjmp	.+498    	; 0x38a0 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    
    //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zacza si od bloku 0
    c = nrBloku-1;
    36ae:	81 2f       	mov	r24, r17
    36b0:	81 50       	subi	r24, 0x01	; 1
    36b2:	8a 83       	std	Y+2, r24	; 0x02
    if (nrBlokuZdalny == c)
    36b4:	08 17       	cp	r16, r24
    36b6:	11 f0       	breq	.+4      	; 0x36bc <goXmodemOdbierzFunction+0x1c4>
    36b8:	01 2f       	mov	r16, r17
    36ba:	08 c0       	rjmp	.+16     	; 0x36cc <goXmodemOdbierzFunction+0x1d4>
    {
      nrBloku = c;    //Cofnicie nr aktualnego bloku o 1
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    36bc:	81 e8       	ldi	r24, 0x81	; 129
    36be:	9f e0       	ldi	r25, 0x0F	; 15
    36c0:	60 2f       	mov	r22, r16
    36c2:	70 e0       	ldi	r23, 0x00	; 0
    36c4:	0e 94 04 23 	call	0x4608	; 0x4608 <ramDyskDodajBlokXmodem>
    36c8:	6c 01       	movw	r12, r24
    36ca:	5c 01       	movw	r10, r24
      zapPtrKopia = zapPtr;
    }
    
    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    36cc:	1b 81       	ldd	r17, Y+3	; 0x03
    36ce:	10 17       	cp	r17, r16
    36d0:	79 f0       	breq	.+30     	; 0x36f0 <goXmodemOdbierzFunction+0x1f8>
    {
      state->errno = (uint8_t)(xModemWrongFrameNo);
    36d2:	84 e0       	ldi	r24, 0x04	; 4
    36d4:	d7 01       	movw	r26, r14
    36d6:	5c 96       	adiw	r26, 0x1c	; 28
    36d8:	8c 93       	st	X, r24
    36da:	5c 97       	sbiw	r26, 0x1c	; 28
      state->err1 = nrBlokuZdalnyNeg;
    36dc:	8c 81       	ldd	r24, Y+4	; 0x04
    36de:	5d 96       	adiw	r26, 0x1d	; 29
    36e0:	8c 93       	st	X, r24
    36e2:	5d 97       	sbiw	r26, 0x1d	; 29
    36e4:	5e 96       	adiw	r26, 0x1e	; 30
    36e6:	1c 92       	st	X, r1
    36e8:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    36ea:	5f 96       	adiw	r26, 0x1f	; 31
    36ec:	0c 93       	st	X, r16
    36ee:	d8 c0       	rjmp	.+432    	; 0x38a0 <goXmodemOdbierzFunction+0x3a8>
      break;
    36f0:	00 e0       	ldi	r16, 0x00	; 0
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    {
      if(xQueueReceive(xVtyRec, &c, 10))
    36f2:	80 91 c4 0e 	lds	r24, 0x0EC4
    36f6:	90 91 c5 0e 	lds	r25, 0x0EC5
    36fa:	be 01       	movw	r22, r28
    36fc:	6e 5f       	subi	r22, 0xFE	; 254
    36fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3700:	4a e0       	ldi	r20, 0x0A	; 10
    3702:	50 e0       	ldi	r21, 0x00	; 0
    3704:	20 e0       	ldi	r18, 0x00	; 0
    3706:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    370a:	88 23       	and	r24, r24
    370c:	41 f0       	breq	.+16     	; 0x371e <goXmodemOdbierzFunction+0x226>
        *(zapPtr++) = c;
    370e:	8a 81       	ldd	r24, Y+2	; 0x02
    3710:	f6 01       	movw	r30, r12
    3712:	81 93       	st	Z+, r24
    3714:	6f 01       	movw	r12, r30
      state->err1 = nrBlokuZdalnyNeg;
      state->err2 = nrBloku;
      break;
    }
        
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    3716:	0f 5f       	subi	r16, 0xFF	; 255
    3718:	00 38       	cpi	r16, 0x80	; 128
    371a:	59 f7       	brne	.-42     	; 0x36f2 <goXmodemOdbierzFunction+0x1fa>
    371c:	03 c0       	rjmp	.+6      	; 0x3724 <goXmodemOdbierzFunction+0x22c>
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    371e:	d7 01       	movw	r26, r14
    3720:	5c 96       	adiw	r26, 0x1c	; 28
    3722:	8c 92       	st	X, r8
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    3724:	80 91 c4 0e 	lds	r24, 0x0EC4
    3728:	90 91 c5 0e 	lds	r25, 0x0EC5
    372c:	b1 01       	movw	r22, r2
    372e:	4a e0       	ldi	r20, 0x0A	; 10
    3730:	50 e0       	ldi	r21, 0x00	; 0
    3732:	20 e0       	ldi	r18, 0x00	; 0
    3734:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    3738:	88 23       	and	r24, r24
    373a:	41 f4       	brne	.+16     	; 0x374c <goXmodemOdbierzFunction+0x254>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    373c:	86 e0       	ldi	r24, 0x06	; 6
    373e:	f7 01       	movw	r30, r14
    3740:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 2;
    3742:	82 e0       	ldi	r24, 0x02	; 2
    3744:	90 e0       	ldi	r25, 0x00	; 0
    3746:	96 8f       	std	Z+30, r25	; 0x1e
    3748:	85 8f       	std	Z+29, r24	; 0x1d
    374a:	aa c0       	rjmp	.+340    	; 0x38a0 <goXmodemOdbierzFunction+0x3a8>
        break;      
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    374c:	80 91 c4 0e 	lds	r24, 0x0EC4
    3750:	90 91 c5 0e 	lds	r25, 0x0EC5
    3754:	b2 01       	movw	r22, r4
    3756:	4a e0       	ldi	r20, 0x0A	; 10
    3758:	50 e0       	ldi	r21, 0x00	; 0
    375a:	20 e0       	ldi	r18, 0x00	; 0
    375c:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    3760:	88 23       	and	r24, r24
    3762:	61 f4       	brne	.+24     	; 0x377c <goXmodemOdbierzFunction+0x284>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    3764:	86 e0       	ldi	r24, 0x06	; 6
    3766:	d7 01       	movw	r26, r14
    3768:	5c 96       	adiw	r26, 0x1c	; 28
    376a:	8c 93       	st	X, r24
    376c:	5c 97       	sbiw	r26, 0x1c	; 28
        state->err1 = 1;
    376e:	81 e0       	ldi	r24, 0x01	; 1
    3770:	90 e0       	ldi	r25, 0x00	; 0
    3772:	5e 96       	adiw	r26, 0x1e	; 30
    3774:	9c 93       	st	X, r25
    3776:	8e 93       	st	-X, r24
    3778:	5d 97       	sbiw	r26, 0x1d	; 29
    377a:	92 c0       	rjmp	.+292    	; 0x38a0 <goXmodemOdbierzFunction+0x3a8>
        break;      
    377c:	90 e0       	ldi	r25, 0x00	; 0
    377e:	40 e0       	ldi	r20, 0x00	; 0
    3780:	50 e0       	ldi	r21, 0x00	; 0
    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
    3782:	f5 01       	movw	r30, r10
    3784:	81 91       	ld	r24, Z+
    3786:	5f 01       	movw	r10, r30
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    3788:	58 27       	eor	r21, r24
    378a:	05 2e       	mov	r0, r21
    378c:	02 94       	swap	r0
    378e:	80 2d       	mov	r24, r0
    3790:	8f 70       	andi	r24, 0x0F	; 15
    3792:	85 27       	eor	r24, r21
    3794:	25 2f       	mov	r18, r21
    3796:	20 25       	eor	r18, r0
    3798:	22 0f       	add	r18, r18
    379a:	20 7e       	andi	r18, 0xE0	; 224
    379c:	82 27       	eor	r24, r18
    379e:	20 2d       	mov	r18, r0
    37a0:	25 27       	eor	r18, r21
    37a2:	20 7f       	andi	r18, 0xF0	; 240
    37a4:	26 95       	lsr	r18
    37a6:	05 2e       	mov	r0, r21
    37a8:	00 0c       	add	r0, r0
    37aa:	22 1f       	adc	r18, r18
    37ac:	56 95       	lsr	r21
    37ae:	56 95       	lsr	r21
    37b0:	56 95       	lsr	r21
    37b2:	5f 71       	andi	r21, 0x1F	; 31
    37b4:	52 27       	eor	r21, r18
    37b6:	54 27       	eor	r21, r20
    37b8:	48 2f       	mov	r20, r24

    //3 Zerowanie CRC
    crcLokalne=0; 
    
    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    37ba:	9f 5f       	subi	r25, 0xFF	; 255
    37bc:	90 38       	cpi	r25, 0x80	; 128
    37be:	09 f7       	brne	.-62     	; 0x3782 <goXmodemOdbierzFunction+0x28a>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
     
    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    37c0:	8d 81       	ldd	r24, Y+5	; 0x05
    37c2:	90 e0       	ldi	r25, 0x00	; 0
    37c4:	25 2f       	mov	r18, r21
    37c6:	33 27       	eor	r19, r19
    37c8:	82 17       	cp	r24, r18
    37ca:	93 07       	cpc	r25, r19
    37cc:	61 f4       	brne	.+24     	; 0x37e6 <goXmodemOdbierzFunction+0x2ee>
    37ce:	8e 81       	ldd	r24, Y+6	; 0x06
    37d0:	90 e0       	ldi	r25, 0x00	; 0
    37d2:	50 70       	andi	r21, 0x00	; 0
    37d4:	84 17       	cp	r24, r20
    37d6:	95 07       	cpc	r25, r21
    37d8:	31 f4       	brne	.+12     	; 0x37e6 <goXmodemOdbierzFunction+0x2ee>
    {
      liczbaProb = 10;
      uartVtySendByte(ACK);      
    37da:	86 e0       	ldi	r24, 0x06	; 6
    37dc:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
    37e0:	4a e0       	ldi	r20, 0x0A	; 10
    37e2:	94 2e       	mov	r9, r20
    37e4:	16 c0       	rjmp	.+44     	; 0x3812 <goXmodemOdbierzFunction+0x31a>
    }
    else
    {
      liczbaProb--;
    37e6:	9a 94       	dec	r9
      nrBloku--;
    37e8:	11 50       	subi	r17, 0x01	; 1
      uartVtySendByte(NAK);   
    37ea:	85 e1       	ldi	r24, 0x15	; 21
    37ec:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
    }
    
    if (liczbaProb == 0)
    37f0:	99 20       	and	r9, r9
    37f2:	79 f4       	brne	.+30     	; 0x3812 <goXmodemOdbierzFunction+0x31a>
    {
      state->err1 = nrBlokuZdalny;
    37f4:	8b 81       	ldd	r24, Y+3	; 0x03
    37f6:	d7 01       	movw	r26, r14
    37f8:	5d 96       	adiw	r26, 0x1d	; 29
    37fa:	8c 93       	st	X, r24
    37fc:	5d 97       	sbiw	r26, 0x1d	; 29
    37fe:	5e 96       	adiw	r26, 0x1e	; 30
    3800:	1c 92       	st	X, r1
    3802:	5e 97       	sbiw	r26, 0x1e	; 30
      state->err2 = nrBloku;
    3804:	5f 96       	adiw	r26, 0x1f	; 31
    3806:	1c 93       	st	X, r17
    3808:	5f 97       	sbiw	r26, 0x1f	; 31
      state->errno = (uint8_t)(xModemWrongFrameNo);
    380a:	84 e0       	ldi	r24, 0x04	; 4
    380c:	5c 96       	adiw	r26, 0x1c	; 28
    380e:	8c 93       	st	X, r24
    3810:	47 c0       	rjmp	.+142    	; 0x38a0 <goXmodemOdbierzFunction+0x3a8>
      break; 
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    3812:	80 91 c4 0e 	lds	r24, 0x0EC4
    3816:	90 91 c5 0e 	lds	r25, 0x0EC5
    381a:	b3 01       	movw	r22, r6
    381c:	44 e6       	ldi	r20, 0x64	; 100
    381e:	50 e0       	ldi	r21, 0x00	; 0
    3820:	20 e0       	ldi	r18, 0x00	; 0
    3822:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    3826:	88 23       	and	r24, r24
    3828:	19 f4       	brne	.+6      	; 0x3830 <goXmodemOdbierzFunction+0x338>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    382a:	82 e0       	ldi	r24, 0x02	; 2
    382c:	f7 01       	movw	r30, r14
    382e:	16 c0       	rjmp	.+44     	; 0x385c <goXmodemOdbierzFunction+0x364>
      break;
    }
    
    if (temp1 == SOH)
    3830:	99 81       	ldd	r25, Y+1	; 0x01
    3832:	91 30       	cpi	r25, 0x01	; 1
    3834:	69 f4       	brne	.+26     	; 0x3850 <goXmodemOdbierzFunction+0x358>
    {
      nrBloku++;
    3836:	1f 5f       	subi	r17, 0xFF	; 255
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    3838:	81 e8       	ldi	r24, 0x81	; 129
    383a:	9f e0       	ldi	r25, 0x0F	; 15
    383c:	61 2f       	mov	r22, r17
    383e:	70 e0       	ldi	r23, 0x00	; 0
    3840:	0e 94 04 23 	call	0x4608	; 0x4608 <ramDyskDodajBlokXmodem>
    3844:	6c 01       	movw	r12, r24
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
    3846:	d7 01       	movw	r26, r14
    3848:	5c 96       	adiw	r26, 0x1c	; 28
    384a:	1c 92       	st	X, r1
    384c:	5c 01       	movw	r10, r24
    384e:	01 cf       	rjmp	.-510    	; 0x3652 <goXmodemOdbierzFunction+0x15a>
      continue;
    }

    if (temp1 == CAN)
    3850:	98 31       	cpi	r25, 0x18	; 24
    3852:	31 f4       	brne	.+12     	; 0x3860 <goXmodemOdbierzFunction+0x368>
    {
      state->err1 = nrBloku;
    3854:	f7 01       	movw	r30, r14
    3856:	15 8f       	std	Z+29, r17	; 0x1d
    3858:	16 8e       	std	Z+30, r1	; 0x1e
      state->errno = (uint8_t)(xModemRemoteSideCan);
    385a:	87 e0       	ldi	r24, 0x07	; 7
    385c:	84 8f       	std	Z+28, r24	; 0x1c
    385e:	20 c0       	rjmp	.+64     	; 0x38a0 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    if (temp1 == EOT)
    3860:	94 30       	cpi	r25, 0x04	; 4
    3862:	c9 f4       	brne	.+50     	; 0x3896 <goXmodemOdbierzFunction+0x39e>
    {
      uartVtySendByte(NAK);
    3864:	85 e1       	ldi	r24, 0x15	; 21
    3866:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
      if (xQueueReceive(xVtyRec, &temp1, 10))
    386a:	80 91 c4 0e 	lds	r24, 0x0EC4
    386e:	90 91 c5 0e 	lds	r25, 0x0EC5
    3872:	b3 01       	movw	r22, r6
    3874:	4a e0       	ldi	r20, 0x0A	; 10
    3876:	50 e0       	ldi	r21, 0x00	; 0
    3878:	20 e0       	ldi	r18, 0x00	; 0
    387a:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    387e:	88 23       	and	r24, r24
    3880:	31 f0       	breq	.+12     	; 0x388e <goXmodemOdbierzFunction+0x396>
      {
        if (temp1 == EOT)
    3882:	89 81       	ldd	r24, Y+1	; 0x01
    3884:	84 30       	cpi	r24, 0x04	; 4
    3886:	19 f4       	brne	.+6      	; 0x388e <goXmodemOdbierzFunction+0x396>
          uartVtySendByte(ACK);  
    3888:	86 e0       	ldi	r24, 0x06	; 6
    388a:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
      }
      state->errno = (uint8_t)(AllOK);
    388e:	d7 01       	movw	r26, r14
    3890:	5c 96       	adiw	r26, 0x1c	; 28
    3892:	1c 92       	st	X, r1
    3894:	05 c0       	rjmp	.+10     	; 0x38a0 <goXmodemOdbierzFunction+0x3a8>
      break;
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    3896:	88 e0       	ldi	r24, 0x08	; 8
    3898:	f7 01       	movw	r30, r14
    389a:	84 8f       	std	Z+28, r24	; 0x1c
    state->err1 = temp1;
    389c:	95 8f       	std	Z+29, r25	; 0x1d
    389e:	16 8e       	std	Z+30, r1	; 0x1e
    break;
  }
  ramDyskZamknijPlik(&fdVty);
    38a0:	81 e8       	ldi	r24, 0x81	; 129
    38a2:	9f e0       	ldi	r25, 0x0F	; 15
    38a4:	0e 94 c1 24 	call	0x4982	; 0x4982 <ramDyskZamknijPlik>
    38a8:	20 e0       	ldi	r18, 0x00	; 0
    38aa:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    38ac:	c9 01       	movw	r24, r18
    38ae:	26 96       	adiw	r28, 0x06	; 6
    38b0:	0f b6       	in	r0, 0x3f	; 63
    38b2:	f8 94       	cli
    38b4:	de bf       	out	0x3e, r29	; 62
    38b6:	0f be       	out	0x3f, r0	; 63
    38b8:	cd bf       	out	0x3d, r28	; 61
    38ba:	cf 91       	pop	r28
    38bc:	df 91       	pop	r29
    38be:	1f 91       	pop	r17
    38c0:	0f 91       	pop	r16
    38c2:	ff 90       	pop	r15
    38c4:	ef 90       	pop	r14
    38c6:	df 90       	pop	r13
    38c8:	cf 90       	pop	r12
    38ca:	bf 90       	pop	r11
    38cc:	af 90       	pop	r10
    38ce:	9f 90       	pop	r9
    38d0:	8f 90       	pop	r8
    38d2:	7f 90       	pop	r7
    38d4:	6f 90       	pop	r6
    38d6:	5f 90       	pop	r5
    38d8:	4f 90       	pop	r4
    38da:	3f 90       	pop	r3
    38dc:	2f 90       	pop	r2
    38de:	08 95       	ret

000038e0 <debugFunction>:
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
  return OK_SILENT;
}

static cliExRes_t debugFunction          (cmdState_t *state)
{
    38e0:	ff 92       	push	r15
    38e2:	0f 93       	push	r16
    38e4:	1f 93       	push	r17
    38e6:	cf 93       	push	r28
    38e8:	df 93       	push	r29
    38ea:	ec 01       	movw	r28, r24
  if (state->argc < 2)
    38ec:	89 8d       	ldd	r24, Y+25	; 0x19
    38ee:	82 30       	cpi	r24, 0x02	; 2
    38f0:	08 f4       	brcc	.+2      	; 0x38f4 <debugFunction+0x14>
    38f2:	d2 c0       	rjmp	.+420    	; 0x3a98 <debugFunction+0x1b8>
    return SYNTAX_ERROR;

  uint8_t level = cmdlineGetArgInt(2, state);
    38f4:	82 e0       	ldi	r24, 0x02	; 2
    38f6:	be 01       	movw	r22, r28
    38f8:	0e 94 35 28 	call	0x506a	; 0x506a <cmdlineGetArgInt>
    38fc:	f6 2e       	mov	r15, r22
  const char *str = (const char*)cmdlineGetArgStr(1, state);
    38fe:	81 e0       	ldi	r24, 0x01	; 1
    3900:	be 01       	movw	r22, r28
    3902:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    3906:	8c 01       	movw	r16, r24
  if (level == 0)
    3908:	ff 20       	and	r15, r15
    390a:	09 f0       	breq	.+2      	; 0x390e <debugFunction+0x2e>
    390c:	5b c0       	rjmp	.+182    	; 0x39c4 <debugFunction+0xe4>
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    390e:	6b ec       	ldi	r22, 0xCB	; 203
    3910:	7a e0       	ldi	r23, 0x0A	; 10
    3912:	43 e0       	ldi	r20, 0x03	; 3
    3914:	50 e0       	ldi	r21, 0x00	; 0
    3916:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    391a:	89 2b       	or	r24, r25
    391c:	31 f4       	brne	.+12     	; 0x392a <debugFunction+0x4a>
    {
      setArpDebug(NULL, 0);
    391e:	80 e0       	ldi	r24, 0x00	; 0
    3920:	90 e0       	ldi	r25, 0x00	; 0
    3922:	60 e0       	ldi	r22, 0x00	; 0
    3924:	0e 94 f2 3b 	call	0x77e4	; 0x77e4 <setArpDebug>
    3928:	2c c0       	rjmp	.+88     	; 0x3982 <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    392a:	c8 01       	movw	r24, r16
    392c:	68 ec       	ldi	r22, 0xC8	; 200
    392e:	7a e0       	ldi	r23, 0x0A	; 10
    3930:	42 e0       	ldi	r20, 0x02	; 2
    3932:	50 e0       	ldi	r21, 0x00	; 0
    3934:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    3938:	89 2b       	or	r24, r25
    393a:	31 f4       	brne	.+12     	; 0x3948 <debugFunction+0x68>
    {
      setIpDebug(NULL, 0);
    393c:	80 e0       	ldi	r24, 0x00	; 0
    393e:	90 e0       	ldi	r25, 0x00	; 0
    3940:	60 e0       	ldi	r22, 0x00	; 0
    3942:	0e 94 96 37 	call	0x6f2c	; 0x6f2c <setIpDebug>
    3946:	1d c0       	rjmp	.+58     	; 0x3982 <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    3948:	c8 01       	movw	r24, r16
    394a:	63 ec       	ldi	r22, 0xC3	; 195
    394c:	7a e0       	ldi	r23, 0x0A	; 10
    394e:	42 e0       	ldi	r20, 0x02	; 2
    3950:	50 e0       	ldi	r21, 0x00	; 0
    3952:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    3956:	89 2b       	or	r24, r25
    3958:	31 f4       	brne	.+12     	; 0x3966 <debugFunction+0x86>
    {
      setIcmpDebug(NULL, 0);
    395a:	80 e0       	ldi	r24, 0x00	; 0
    395c:	90 e0       	ldi	r25, 0x00	; 0
    395e:	60 e0       	ldi	r22, 0x00	; 0
    3960:	0e 94 67 3a 	call	0x74ce	; 0x74ce <setIcmpDebug>
    3964:	0e c0       	rjmp	.+28     	; 0x3982 <debugFunction+0xa2>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    3966:	c8 01       	movw	r24, r16
    3968:	6f eb       	ldi	r22, 0xBF	; 191
    396a:	7a e0       	ldi	r23, 0x0A	; 10
    396c:	42 e0       	ldi	r20, 0x02	; 2
    396e:	50 e0       	ldi	r21, 0x00	; 0
    3970:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    3974:	89 2b       	or	r24, r25
    3976:	b1 f4       	brne	.+44     	; 0x39a4 <debugFunction+0xc4>
    {
      setTcpDebug(NULL, 0);
    3978:	80 e0       	ldi	r24, 0x00	; 0
    397a:	90 e0       	ldi	r25, 0x00	; 0
    397c:	60 e0       	ldi	r22, 0x00	; 0
    397e:	0e 94 45 40 	call	0x808a	; 0x808a <setTcpDebug>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
    3982:	00 d0       	rcall	.+0      	; 0x3984 <debugFunction+0xa4>
    3984:	00 d0       	rcall	.+0      	; 0x3986 <debugFunction+0xa6>
    3986:	00 d0       	rcall	.+0      	; 0x3988 <debugFunction+0xa8>
    3988:	ed b7       	in	r30, 0x3d	; 61
    398a:	fe b7       	in	r31, 0x3e	; 62
    398c:	31 96       	adiw	r30, 0x01	; 1
    398e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3990:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3992:	ad b7       	in	r26, 0x3d	; 61
    3994:	be b7       	in	r27, 0x3e	; 62
    3996:	12 96       	adiw	r26, 0x02	; 2
    3998:	9c 93       	st	X, r25
    399a:	8e 93       	st	-X, r24
    399c:	11 97       	sbiw	r26, 0x01	; 1
    399e:	88 e2       	ldi	r24, 0x28	; 40
    39a0:	94 e0       	ldi	r25, 0x04	; 4
    39a2:	5a c0       	rjmp	.+180    	; 0x3a58 <debugFunction+0x178>
      return OK_SILENT;  
    }    

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    39a4:	c8 01       	movw	r24, r16
    39a6:	6b eb       	ldi	r22, 0xBB	; 187
    39a8:	7a e0       	ldi	r23, 0x0A	; 10
    39aa:	42 e0       	ldi	r20, 0x02	; 2
    39ac:	50 e0       	ldi	r21, 0x00	; 0
    39ae:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    39b2:	89 2b       	or	r24, r25
    39b4:	09 f0       	breq	.+2      	; 0x39b8 <debugFunction+0xd8>
    39b6:	70 c0       	rjmp	.+224    	; 0x3a98 <debugFunction+0x1b8>
    {
      setUdpDebug(NULL, 0);
    39b8:	80 e0       	ldi	r24, 0x00	; 0
    39ba:	90 e0       	ldi	r25, 0x00	; 0
    39bc:	60 e0       	ldi	r22, 0x00	; 0
    39be:	0e 94 07 43 	call	0x860e	; 0x860e <setUdpDebug>
    39c2:	df cf       	rjmp	.-66     	; 0x3982 <debugFunction+0xa2>


  }
  else                   //level > 0
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    39c4:	67 eb       	ldi	r22, 0xB7	; 183
    39c6:	7a e0       	ldi	r23, 0x0A	; 10
    39c8:	43 e0       	ldi	r20, 0x03	; 3
    39ca:	50 e0       	ldi	r21, 0x00	; 0
    39cc:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    39d0:	89 2b       	or	r24, r25
    39d2:	31 f4       	brne	.+12     	; 0x39e0 <debugFunction+0x100>
    {
      setArpDebug(state->myStdInOut, level);
    39d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    39d6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    39d8:	6f 2d       	mov	r22, r15
    39da:	0e 94 f2 3b 	call	0x77e4	; 0x77e4 <setArpDebug>
    39de:	2c c0       	rjmp	.+88     	; 0x3a38 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }   
    
    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    39e0:	c8 01       	movw	r24, r16
    39e2:	64 eb       	ldi	r22, 0xB4	; 180
    39e4:	7a e0       	ldi	r23, 0x0A	; 10
    39e6:	42 e0       	ldi	r20, 0x02	; 2
    39e8:	50 e0       	ldi	r21, 0x00	; 0
    39ea:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    39ee:	89 2b       	or	r24, r25
    39f0:	31 f4       	brne	.+12     	; 0x39fe <debugFunction+0x11e>
    {
      setIpDebug(state->myStdInOut, level);
    39f2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    39f4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    39f6:	6f 2d       	mov	r22, r15
    39f8:	0e 94 96 37 	call	0x6f2c	; 0x6f2c <setIpDebug>
    39fc:	1d c0       	rjmp	.+58     	; 0x3a38 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    39fe:	c8 01       	movw	r24, r16
    3a00:	6f ea       	ldi	r22, 0xAF	; 175
    3a02:	7a e0       	ldi	r23, 0x0A	; 10
    3a04:	42 e0       	ldi	r20, 0x02	; 2
    3a06:	50 e0       	ldi	r21, 0x00	; 0
    3a08:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    3a0c:	89 2b       	or	r24, r25
    3a0e:	31 f4       	brne	.+12     	; 0x3a1c <debugFunction+0x13c>
    {
      setIcmpDebug(state->myStdInOut, level);
    3a10:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a12:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a14:	6f 2d       	mov	r22, r15
    3a16:	0e 94 67 3a 	call	0x74ce	; 0x74ce <setIcmpDebug>
    3a1a:	0e c0       	rjmp	.+28     	; 0x3a38 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    3a1c:	c8 01       	movw	r24, r16
    3a1e:	6b ea       	ldi	r22, 0xAB	; 171
    3a20:	7a e0       	ldi	r23, 0x0A	; 10
    3a22:	42 e0       	ldi	r20, 0x02	; 2
    3a24:	50 e0       	ldi	r21, 0x00	; 0
    3a26:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    3a2a:	89 2b       	or	r24, r25
    3a2c:	31 f5       	brne	.+76     	; 0x3a7a <debugFunction+0x19a>
    {
      setTcpDebug(state->myStdInOut, level);
    3a2e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a30:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a32:	6f 2d       	mov	r22, r15
    3a34:	0e 94 45 40 	call	0x808a	; 0x808a <setTcpDebug>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
    3a38:	00 d0       	rcall	.+0      	; 0x3a3a <debugFunction+0x15a>
    3a3a:	00 d0       	rcall	.+0      	; 0x3a3c <debugFunction+0x15c>
    3a3c:	00 d0       	rcall	.+0      	; 0x3a3e <debugFunction+0x15e>
    3a3e:	ed b7       	in	r30, 0x3d	; 61
    3a40:	fe b7       	in	r31, 0x3e	; 62
    3a42:	31 96       	adiw	r30, 0x01	; 1
    3a44:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a46:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a48:	ad b7       	in	r26, 0x3d	; 61
    3a4a:	be b7       	in	r27, 0x3e	; 62
    3a4c:	12 96       	adiw	r26, 0x02	; 2
    3a4e:	9c 93       	st	X, r25
    3a50:	8e 93       	st	-X, r24
    3a52:	11 97       	sbiw	r26, 0x01	; 1
    3a54:	85 e1       	ldi	r24, 0x15	; 21
    3a56:	94 e0       	ldi	r25, 0x04	; 4
    3a58:	93 83       	std	Z+3, r25	; 0x03
    3a5a:	82 83       	std	Z+2, r24	; 0x02
    3a5c:	15 83       	std	Z+5, r17	; 0x05
    3a5e:	04 83       	std	Z+4, r16	; 0x04
    3a60:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    3a64:	20 e0       	ldi	r18, 0x00	; 0
    3a66:	30 e0       	ldi	r19, 0x00	; 0
    3a68:	8d b7       	in	r24, 0x3d	; 61
    3a6a:	9e b7       	in	r25, 0x3e	; 62
    3a6c:	06 96       	adiw	r24, 0x06	; 6
    3a6e:	0f b6       	in	r0, 0x3f	; 63
    3a70:	f8 94       	cli
    3a72:	9e bf       	out	0x3e, r25	; 62
    3a74:	0f be       	out	0x3f, r0	; 63
    3a76:	8d bf       	out	0x3d, r24	; 61
    3a78:	11 c0       	rjmp	.+34     	; 0x3a9c <debugFunction+0x1bc>
      return OK_SILENT;  
    }
    
    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    3a7a:	c8 01       	movw	r24, r16
    3a7c:	67 ea       	ldi	r22, 0xA7	; 167
    3a7e:	7a e0       	ldi	r23, 0x0A	; 10
    3a80:	42 e0       	ldi	r20, 0x02	; 2
    3a82:	50 e0       	ldi	r21, 0x00	; 0
    3a84:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    3a88:	89 2b       	or	r24, r25
    3a8a:	31 f4       	brne	.+12     	; 0x3a98 <debugFunction+0x1b8>
    {
      setUdpDebug(state->myStdInOut, level);
    3a8c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a8e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a90:	6f 2d       	mov	r22, r15
    3a92:	0e 94 07 43 	call	0x860e	; 0x860e <setUdpDebug>
    3a96:	d0 cf       	rjmp	.-96     	; 0x3a38 <debugFunction+0x158>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;  
    3a98:	22 e0       	ldi	r18, 0x02	; 2
    3a9a:	30 e0       	ldi	r19, 0x00	; 0
    }
  }
  
  return SYNTAX_ERROR;
}
    3a9c:	c9 01       	movw	r24, r18
    3a9e:	df 91       	pop	r29
    3aa0:	cf 91       	pop	r28
    3aa2:	1f 91       	pop	r17
    3aa4:	0f 91       	pop	r16
    3aa6:	ff 90       	pop	r15
    3aa8:	08 95       	ret

00003aaa <statusEncFunction>:
  return OK_SILENT; 
}

static cliExRes_t statusEncFunction(cmdState_t *state)
{
  nicRegDump(state->myStdInOut);
    3aaa:	fc 01       	movw	r30, r24
    3aac:	82 8d       	ldd	r24, Z+26	; 0x1a
    3aae:	93 8d       	ldd	r25, Z+27	; 0x1b
    3ab0:	0e 94 25 30 	call	0x604a	; 0x604a <nicRegDump>
  return OK_SILENT;
}
    3ab4:	80 e0       	ldi	r24, 0x00	; 0
    3ab6:	90 e0       	ldi	r25, 0x00	; 0
    3ab8:	08 95       	ret

00003aba <readRamFIleFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
{
    3aba:	cf 92       	push	r12
    3abc:	df 92       	push	r13
    3abe:	ef 92       	push	r14
    3ac0:	ff 92       	push	r15
    3ac2:	0f 93       	push	r16
    3ac4:	1f 93       	push	r17
    3ac6:	df 93       	push	r29
    3ac8:	cf 93       	push	r28
    3aca:	0f 92       	push	r0
    3acc:	cd b7       	in	r28, 0x3d	; 61
    3ace:	de b7       	in	r29, 0x3e	; 62
    3ad0:	8c 01       	movw	r16, r24
  uint8_t rezultat;
  uint8_t znak = ' ';
    3ad2:	80 e2       	ldi	r24, 0x20	; 32
    3ad4:	89 83       	std	Y+1, r24	; 0x01
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	b8 01       	movw	r22, r16
    3ada:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    3ade:	61 e8       	ldi	r22, 0x81	; 129
    3ae0:	7f e0       	ldi	r23, 0x0F	; 15
    3ae2:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ramDyskOtworzPlik>
    3ae6:	d8 01       	movw	r26, r16
    3ae8:	5a 96       	adiw	r26, 0x1a	; 26
    3aea:	ed 90       	ld	r14, X+
    3aec:	fc 90       	ld	r15, X
    3aee:	5b 97       	sbiw	r26, 0x1b	; 27
    3af0:	88 23       	and	r24, r24
    3af2:	19 f1       	breq	.+70     	; 0x3b3a <readRamFIleFunction+0x80>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    3af4:	81 e0       	ldi	r24, 0x01	; 1
    3af6:	b8 01       	movw	r22, r16
    3af8:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    3afc:	00 d0       	rcall	.+0      	; 0x3afe <readRamFIleFunction+0x44>
    3afe:	00 d0       	rcall	.+0      	; 0x3b00 <readRamFIleFunction+0x46>
    3b00:	00 d0       	rcall	.+0      	; 0x3b02 <readRamFIleFunction+0x48>
    3b02:	ed b7       	in	r30, 0x3d	; 61
    3b04:	fe b7       	in	r31, 0x3e	; 62
    3b06:	31 96       	adiw	r30, 0x01	; 1
    3b08:	ad b7       	in	r26, 0x3d	; 61
    3b0a:	be b7       	in	r27, 0x3e	; 62
    3b0c:	12 96       	adiw	r26, 0x02	; 2
    3b0e:	fc 92       	st	X, r15
    3b10:	ee 92       	st	-X, r14
    3b12:	11 97       	sbiw	r26, 0x01	; 1
    3b14:	22 e8       	ldi	r18, 0x82	; 130
    3b16:	31 e0       	ldi	r19, 0x01	; 1
    3b18:	33 83       	std	Z+3, r19	; 0x03
    3b1a:	22 83       	std	Z+2, r18	; 0x02
    3b1c:	95 83       	std	Z+5, r25	; 0x05
    3b1e:	84 83       	std	Z+4, r24	; 0x04
    3b20:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    3b24:	24 e0       	ldi	r18, 0x04	; 4
    3b26:	30 e0       	ldi	r19, 0x00	; 0
    3b28:	ed b7       	in	r30, 0x3d	; 61
    3b2a:	fe b7       	in	r31, 0x3e	; 62
    3b2c:	36 96       	adiw	r30, 0x06	; 6
    3b2e:	0f b6       	in	r0, 0x3f	; 63
    3b30:	f8 94       	cli
    3b32:	fe bf       	out	0x3e, r31	; 62
    3b34:	0f be       	out	0x3f, r0	; 63
    3b36:	ed bf       	out	0x3d, r30	; 61
    3b38:	58 c0       	rjmp	.+176    	; 0x3bea <readRamFIleFunction+0x130>
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    3b3a:	20 91 85 0f 	lds	r18, 0x0F85
    3b3e:	30 91 86 0f 	lds	r19, 0x0F86
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    3b42:	00 d0       	rcall	.+0      	; 0x3b44 <readRamFIleFunction+0x8a>
    3b44:	00 d0       	rcall	.+0      	; 0x3b46 <readRamFIleFunction+0x8c>
    3b46:	00 d0       	rcall	.+0      	; 0x3b48 <readRamFIleFunction+0x8e>
    3b48:	ad b7       	in	r26, 0x3d	; 61
    3b4a:	be b7       	in	r27, 0x3e	; 62
    3b4c:	11 96       	adiw	r26, 0x01	; 1
    3b4e:	ed b7       	in	r30, 0x3d	; 61
    3b50:	fe b7       	in	r31, 0x3e	; 62
    3b52:	f2 82       	std	Z+2, r15	; 0x02
    3b54:	e1 82       	std	Z+1, r14	; 0x01
    3b56:	80 e7       	ldi	r24, 0x70	; 112
    3b58:	93 e0       	ldi	r25, 0x03	; 3
    3b5a:	13 96       	adiw	r26, 0x03	; 3
    3b5c:	9c 93       	st	X, r25
    3b5e:	8e 93       	st	-X, r24
    3b60:	12 97       	sbiw	r26, 0x02	; 2
    3b62:	f9 01       	movw	r30, r18
    3b64:	92 81       	ldd	r25, Z+2	; 0x02
    3b66:	80 e0       	ldi	r24, 0x00	; 0
    3b68:	21 81       	ldd	r18, Z+1	; 0x01
    3b6a:	82 0f       	add	r24, r18
    3b6c:	91 1d       	adc	r25, r1
    3b6e:	15 96       	adiw	r26, 0x05	; 5
    3b70:	9c 93       	st	X, r25
    3b72:	8e 93       	st	-X, r24
    3b74:	14 97       	sbiw	r26, 0x04	; 4
    3b76:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    3b7a:	8d b7       	in	r24, 0x3d	; 61
    3b7c:	9e b7       	in	r25, 0x3e	; 62
    3b7e:	06 96       	adiw	r24, 0x06	; 6
    3b80:	0f b6       	in	r0, 0x3f	; 63
    3b82:	f8 94       	cli
    3b84:	9e bf       	out	0x3e, r25	; 62
    3b86:	0f be       	out	0x3f, r0	; 63
    3b88:	8d bf       	out	0x3d, r24	; 61
  while (rezultat == 0)
  {
    rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
    3b8a:	6e 01       	movw	r12, r28
    3b8c:	08 94       	sec
    3b8e:	c1 1c       	adc	r12, r1
    3b90:	d1 1c       	adc	r13, r1
    3b92:	81 e8       	ldi	r24, 0x81	; 129
    3b94:	9f e0       	ldi	r25, 0x0F	; 15
    3b96:	b6 01       	movw	r22, r12
    3b98:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <ramDyskCzytajBajtZPliku>
    3b9c:	f8 2e       	mov	r15, r24
    
    uartVtySendByte(znak);
    3b9e:	89 81       	ldd	r24, Y+1	; 0x01
    3ba0:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
    if (znak == '\r')
    3ba4:	89 81       	ldd	r24, Y+1	; 0x01
    3ba6:	8d 30       	cpi	r24, 0x0D	; 13
    3ba8:	19 f4       	brne	.+6      	; 0x3bb0 <readRamFIleFunction+0xf6>
      uartVtySendByte('\n');
    3baa:	8a e0       	ldi	r24, 0x0A	; 10
    3bac:	0e 94 29 11 	call	0x2252	; 0x2252 <uartVtySendByte>
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
  while (rezultat == 0)
    3bb0:	ff 20       	and	r15, r15
    3bb2:	79 f3       	breq	.-34     	; 0x3b92 <readRamFIleFunction+0xd8>
    
    uartVtySendByte(znak);
    if (znak == '\r')
      uartVtySendByte('\n');
  }
  fprintf_P(state->myStdInOut, nlStr);
    3bb4:	00 d0       	rcall	.+0      	; 0x3bb6 <readRamFIleFunction+0xfc>
    3bb6:	00 d0       	rcall	.+0      	; 0x3bb8 <readRamFIleFunction+0xfe>
    3bb8:	d8 01       	movw	r26, r16
    3bba:	5a 96       	adiw	r26, 0x1a	; 26
    3bbc:	8d 91       	ld	r24, X+
    3bbe:	9c 91       	ld	r25, X
    3bc0:	5b 97       	sbiw	r26, 0x1b	; 27
    3bc2:	ed b7       	in	r30, 0x3d	; 61
    3bc4:	fe b7       	in	r31, 0x3e	; 62
    3bc6:	92 83       	std	Z+2, r25	; 0x02
    3bc8:	81 83       	std	Z+1, r24	; 0x01
    3bca:	85 e0       	ldi	r24, 0x05	; 5
    3bcc:	99 e0       	ldi	r25, 0x09	; 9
    3bce:	94 83       	std	Z+4, r25	; 0x04
    3bd0:	83 83       	std	Z+3, r24	; 0x03
    3bd2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  ramDyskZamknijPlik(&fdVty);
    3bd6:	0f 90       	pop	r0
    3bd8:	0f 90       	pop	r0
    3bda:	0f 90       	pop	r0
    3bdc:	0f 90       	pop	r0
    3bde:	81 e8       	ldi	r24, 0x81	; 129
    3be0:	9f e0       	ldi	r25, 0x0F	; 15
    3be2:	0e 94 c1 24 	call	0x4982	; 0x4982 <ramDyskZamknijPlik>
    3be6:	20 e0       	ldi	r18, 0x00	; 0
    3be8:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT;
}
    3bea:	c9 01       	movw	r24, r18
    3bec:	0f 90       	pop	r0
    3bee:	cf 91       	pop	r28
    3bf0:	df 91       	pop	r29
    3bf2:	1f 91       	pop	r17
    3bf4:	0f 91       	pop	r16
    3bf6:	ff 90       	pop	r15
    3bf8:	ef 90       	pop	r14
    3bfa:	df 90       	pop	r13
    3bfc:	cf 90       	pop	r12
    3bfe:	08 95       	ret

00003c00 <writeRamFileFunction>:
  return ERROR_INFORM;
}

static cliExRes_t writeRamFileFunction(cmdState_t *state)
{
  ramDyskDir(state->myStdInOut);
    3c00:	fc 01       	movw	r30, r24
    3c02:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c04:	93 8d       	ldd	r25, Z+27	; 0x1b
    3c06:	0e 94 18 22 	call	0x4430	; 0x4430 <ramDyskDir>
  return OK_SILENT;
}
    3c0a:	80 e0       	ldi	r24, 0x00	; 0
    3c0c:	90 e0       	ldi	r25, 0x00	; 0
    3c0e:	08 95       	ret

00003c10 <pokazCzasFunction>:
  nicRegDump(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
    3c10:	0f 93       	push	r16
    3c12:	1f 93       	push	r17
    3c14:	cf 93       	push	r28
    3c16:	df 93       	push	r29
    3c18:	8c 01       	movw	r16, r24
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
    3c1a:	8c ec       	ldi	r24, 0xCC	; 204
    3c1c:	9e e0       	ldi	r25, 0x0E	; 14
    3c1e:	0e 94 08 2e 	call	0x5c10	; 0x5c10 <readTimeDecoded>
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
    3c22:	20 91 ce 0e 	lds	r18, 0x0ECE
    3c26:	22 95       	swap	r18
    3c28:	2f 70       	andi	r18, 0x0F	; 15
    3c2a:	40 91 ce 0e 	lds	r20, 0x0ECE
    3c2e:	4f 70       	andi	r20, 0x0F	; 15
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    3c30:	70 91 cd 0e 	lds	r23, 0x0ECD
    3c34:	72 95       	swap	r23
    3c36:	7f 70       	andi	r23, 0x0F	; 15
    3c38:	50 91 cd 0e 	lds	r21, 0x0ECD
    3c3c:	5f 70       	andi	r21, 0x0F	; 15
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
    3c3e:	a0 91 cc 0e 	lds	r26, 0x0ECC
    3c42:	a2 95       	swap	r26
    3c44:	af 70       	andi	r26, 0x0F	; 15
    3c46:	60 91 cc 0e 	lds	r22, 0x0ECC
    3c4a:	6f 70       	andi	r22, 0x0F	; 15
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    3c4c:	8d b7       	in	r24, 0x3d	; 61
    3c4e:	9e b7       	in	r25, 0x3e	; 62
    3c50:	0a 97       	sbiw	r24, 0x0a	; 10
    3c52:	0f b6       	in	r0, 0x3f	; 63
    3c54:	f8 94       	cli
    3c56:	9e bf       	out	0x3e, r25	; 62
    3c58:	0f be       	out	0x3f, r0	; 63
    3c5a:	8d bf       	out	0x3d, r24	; 61
    3c5c:	ed b7       	in	r30, 0x3d	; 61
    3c5e:	fe b7       	in	r31, 0x3e	; 62
    3c60:	31 96       	adiw	r30, 0x01	; 1
    3c62:	e8 01       	movw	r28, r16
    3c64:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3c66:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3c68:	cd b7       	in	r28, 0x3d	; 61
    3c6a:	de b7       	in	r29, 0x3e	; 62
    3c6c:	9a 83       	std	Y+2, r25	; 0x02
    3c6e:	89 83       	std	Y+1, r24	; 0x01
    3c70:	8f ec       	ldi	r24, 0xCF	; 207
    3c72:	9a e0       	ldi	r25, 0x0A	; 10
    3c74:	93 83       	std	Z+3, r25	; 0x03
    3c76:	82 83       	std	Z+2, r24	; 0x02
    3c78:	82 2f       	mov	r24, r18
    3c7a:	83 70       	andi	r24, 0x03	; 3
    3c7c:	90 e0       	ldi	r25, 0x00	; 0
    3c7e:	9c 01       	movw	r18, r24
    3c80:	13 e0       	ldi	r17, 0x03	; 3
    3c82:	22 0f       	add	r18, r18
    3c84:	33 1f       	adc	r19, r19
    3c86:	1a 95       	dec	r17
    3c88:	e1 f7       	brne	.-8      	; 0x3c82 <pokazCzasFunction+0x72>
    3c8a:	88 0f       	add	r24, r24
    3c8c:	99 1f       	adc	r25, r25
    3c8e:	28 0f       	add	r18, r24
    3c90:	39 1f       	adc	r19, r25
    3c92:	42 0f       	add	r20, r18
    3c94:	44 83       	std	Z+4, r20	; 0x04
    3c96:	15 82       	std	Z+5, r1	; 0x05
    3c98:	87 2f       	mov	r24, r23
    3c9a:	87 70       	andi	r24, 0x07	; 7
    3c9c:	90 e0       	ldi	r25, 0x00	; 0
    3c9e:	9c 01       	movw	r18, r24
    3ca0:	73 e0       	ldi	r23, 0x03	; 3
    3ca2:	22 0f       	add	r18, r18
    3ca4:	33 1f       	adc	r19, r19
    3ca6:	7a 95       	dec	r23
    3ca8:	e1 f7       	brne	.-8      	; 0x3ca2 <pokazCzasFunction+0x92>
    3caa:	88 0f       	add	r24, r24
    3cac:	99 1f       	adc	r25, r25
    3cae:	28 0f       	add	r18, r24
    3cb0:	39 1f       	adc	r19, r25
    3cb2:	52 0f       	add	r21, r18
    3cb4:	56 83       	std	Z+6, r21	; 0x06
    3cb6:	17 82       	std	Z+7, r1	; 0x07
    3cb8:	8a 2f       	mov	r24, r26
    3cba:	87 70       	andi	r24, 0x07	; 7
    3cbc:	90 e0       	ldi	r25, 0x00	; 0
    3cbe:	9c 01       	movw	r18, r24
    3cc0:	03 e0       	ldi	r16, 0x03	; 3
    3cc2:	22 0f       	add	r18, r18
    3cc4:	33 1f       	adc	r19, r19
    3cc6:	0a 95       	dec	r16
    3cc8:	e1 f7       	brne	.-8      	; 0x3cc2 <pokazCzasFunction+0xb2>
    3cca:	88 0f       	add	r24, r24
    3ccc:	99 1f       	adc	r25, r25
    3cce:	28 0f       	add	r18, r24
    3cd0:	39 1f       	adc	r19, r25
    3cd2:	62 0f       	add	r22, r18
    3cd4:	60 87       	std	Z+8, r22	; 0x08
    3cd6:	11 86       	std	Z+9, r1	; 0x09
    3cd8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    3cdc:	8d b7       	in	r24, 0x3d	; 61
    3cde:	9e b7       	in	r25, 0x3e	; 62
    3ce0:	0a 96       	adiw	r24, 0x0a	; 10
    3ce2:	0f b6       	in	r0, 0x3f	; 63
    3ce4:	f8 94       	cli
    3ce6:	9e bf       	out	0x3e, r25	; 62
    3ce8:	0f be       	out	0x3f, r0	; 63
    3cea:	8d bf       	out	0x3d, r24	; 61
  return OK_SILENT;
}
    3cec:	80 e0       	ldi	r24, 0x00	; 0
    3cee:	90 e0       	ldi	r25, 0x00	; 0
    3cf0:	df 91       	pop	r29
    3cf2:	cf 91       	pop	r28
    3cf4:	1f 91       	pop	r17
    3cf6:	0f 91       	pop	r16
    3cf8:	08 95       	ret

00003cfa <helpFunction>:
  return OK_SILENT;
}

static cliExRes_t helpFunction(cmdState_t *state)
{
  cmdPrintHelp(state);
    3cfa:	0e 94 9f 27 	call	0x4f3e	; 0x4f3e <cmdPrintHelp>
  return OK_SILENT;
}
    3cfe:	80 e0       	ldi	r24, 0x00	; 0
    3d00:	90 e0       	ldi	r25, 0x00	; 0
    3d02:	08 95       	ret

00003d04 <printStatus>:
  return ERROR_OPERATION_NOT_ALLOWED;
}

// ************************** VTY API ***************************************************************************************
void printStatus(FILE *stream)
{
    3d04:	cf 93       	push	r28
    3d06:	df 93       	push	r29
    3d08:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
    3d0a:	00 d0       	rcall	.+0      	; 0x3d0c <printStatus+0x8>
    3d0c:	00 d0       	rcall	.+0      	; 0x3d0e <printStatus+0xa>
    3d0e:	ad b7       	in	r26, 0x3d	; 61
    3d10:	be b7       	in	r27, 0x3e	; 62
    3d12:	12 96       	adiw	r26, 0x02	; 2
    3d14:	9c 93       	st	X, r25
    3d16:	8e 93       	st	-X, r24
    3d18:	11 97       	sbiw	r26, 0x01	; 1
    3d1a:	84 ef       	ldi	r24, 0xF4	; 244
    3d1c:	9a e0       	ldi	r25, 0x0A	; 10
    3d1e:	14 96       	adiw	r26, 0x04	; 4
    3d20:	9c 93       	st	X, r25
    3d22:	8e 93       	st	-X, r24
    3d24:	13 97       	sbiw	r26, 0x03	; 3
    3d26:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  //Print system state
  fprintf_P(stream, systemStateStr);
    3d2a:	ed b7       	in	r30, 0x3d	; 61
    3d2c:	fe b7       	in	r31, 0x3e	; 62
    3d2e:	d2 83       	std	Z+2, r29	; 0x02
    3d30:	c1 83       	std	Z+1, r28	; 0x01
    3d32:	87 e9       	ldi	r24, 0x97	; 151
    3d34:	91 e0       	ldi	r25, 0x01	; 1
    3d36:	94 83       	std	Z+4, r25	; 0x04
    3d38:	83 83       	std	Z+3, r24	; 0x03
    3d3a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
    3d3e:	0f 90       	pop	r0
    3d40:	0f 90       	pop	r0
    3d42:	0f 90       	pop	r0
    3d44:	0f 90       	pop	r0
    3d46:	0e 94 fa 63 	call	0xc7f4	; 0xc7f4 <uxTaskGetNumberOfTasks>
    3d4a:	00 d0       	rcall	.+0      	; 0x3d4c <printStatus+0x48>
    3d4c:	00 d0       	rcall	.+0      	; 0x3d4e <printStatus+0x4a>
    3d4e:	00 d0       	rcall	.+0      	; 0x3d50 <printStatus+0x4c>
    3d50:	ed b7       	in	r30, 0x3d	; 61
    3d52:	fe b7       	in	r31, 0x3e	; 62
    3d54:	31 96       	adiw	r30, 0x01	; 1
    3d56:	ad b7       	in	r26, 0x3d	; 61
    3d58:	be b7       	in	r27, 0x3e	; 62
    3d5a:	12 96       	adiw	r26, 0x02	; 2
    3d5c:	dc 93       	st	X, r29
    3d5e:	ce 93       	st	-X, r28
    3d60:	11 97       	sbiw	r26, 0x01	; 1
    3d62:	27 ea       	ldi	r18, 0xA7	; 167
    3d64:	31 e0       	ldi	r19, 0x01	; 1
    3d66:	33 83       	std	Z+3, r19	; 0x03
    3d68:	22 83       	std	Z+2, r18	; 0x02
    3d6a:	84 83       	std	Z+4, r24	; 0x04
    3d6c:	15 82       	std	Z+5, r1	; 0x05
    3d6e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
    3d72:	ed b7       	in	r30, 0x3d	; 61
    3d74:	fe b7       	in	r31, 0x3e	; 62
    3d76:	36 96       	adiw	r30, 0x06	; 6
    3d78:	0f b6       	in	r0, 0x3f	; 63
    3d7a:	f8 94       	cli
    3d7c:	fe bf       	out	0x3e, r31	; 62
    3d7e:	0f be       	out	0x3f, r0	; 63
    3d80:	ed bf       	out	0x3d, r30	; 61
    3d82:	0e 94 4e 70 	call	0xe09c	; 0xe09c <xPortGetFreeHeapSize>
    3d86:	2d b7       	in	r18, 0x3d	; 61
    3d88:	3e b7       	in	r19, 0x3e	; 62
    3d8a:	28 50       	subi	r18, 0x08	; 8
    3d8c:	30 40       	sbci	r19, 0x00	; 0
    3d8e:	0f b6       	in	r0, 0x3f	; 63
    3d90:	f8 94       	cli
    3d92:	3e bf       	out	0x3e, r19	; 62
    3d94:	0f be       	out	0x3f, r0	; 63
    3d96:	2d bf       	out	0x3d, r18	; 61
    3d98:	ed b7       	in	r30, 0x3d	; 61
    3d9a:	fe b7       	in	r31, 0x3e	; 62
    3d9c:	31 96       	adiw	r30, 0x01	; 1
    3d9e:	ad b7       	in	r26, 0x3d	; 61
    3da0:	be b7       	in	r27, 0x3e	; 62
    3da2:	12 96       	adiw	r26, 0x02	; 2
    3da4:	dc 93       	st	X, r29
    3da6:	ce 93       	st	-X, r28
    3da8:	11 97       	sbiw	r26, 0x01	; 1
    3daa:	20 ec       	ldi	r18, 0xC0	; 192
    3dac:	31 e0       	ldi	r19, 0x01	; 1
    3dae:	33 83       	std	Z+3, r19	; 0x03
    3db0:	22 83       	std	Z+2, r18	; 0x02
    3db2:	95 83       	std	Z+5, r25	; 0x05
    3db4:	84 83       	std	Z+4, r24	; 0x04
    3db6:	8c e1       	ldi	r24, 0x1C	; 28
    3db8:	9c e0       	ldi	r25, 0x0C	; 12
    3dba:	97 83       	std	Z+7, r25	; 0x07
    3dbc:	86 83       	std	Z+6, r24	; 0x06
    3dbe:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
    3dc2:	ed b7       	in	r30, 0x3d	; 61
    3dc4:	fe b7       	in	r31, 0x3e	; 62
    3dc6:	38 96       	adiw	r30, 0x08	; 8
    3dc8:	0f b6       	in	r0, 0x3f	; 63
    3dca:	f8 94       	cli
    3dcc:	fe bf       	out	0x3e, r31	; 62
    3dce:	0f be       	out	0x3f, r0	; 63
    3dd0:	ed bf       	out	0x3d, r30	; 61
    3dd2:	0e 94 ee 21 	call	0x43dc	; 0x43dc <xmallocAvailable>
    3dd6:	2d b7       	in	r18, 0x3d	; 61
    3dd8:	3e b7       	in	r19, 0x3e	; 62
    3dda:	28 50       	subi	r18, 0x08	; 8
    3ddc:	30 40       	sbci	r19, 0x00	; 0
    3dde:	0f b6       	in	r0, 0x3f	; 63
    3de0:	f8 94       	cli
    3de2:	3e bf       	out	0x3e, r19	; 62
    3de4:	0f be       	out	0x3f, r0	; 63
    3de6:	2d bf       	out	0x3d, r18	; 61
    3de8:	ed b7       	in	r30, 0x3d	; 61
    3dea:	fe b7       	in	r31, 0x3e	; 62
    3dec:	31 96       	adiw	r30, 0x01	; 1
    3dee:	ad b7       	in	r26, 0x3d	; 61
    3df0:	be b7       	in	r27, 0x3e	; 62
    3df2:	12 96       	adiw	r26, 0x02	; 2
    3df4:	dc 93       	st	X, r29
    3df6:	ce 93       	st	-X, r28
    3df8:	11 97       	sbiw	r26, 0x01	; 1
    3dfa:	2a ee       	ldi	r18, 0xEA	; 234
    3dfc:	31 e0       	ldi	r19, 0x01	; 1
    3dfe:	33 83       	std	Z+3, r19	; 0x03
    3e00:	22 83       	std	Z+2, r18	; 0x02
    3e02:	95 83       	std	Z+5, r25	; 0x05
    3e04:	84 83       	std	Z+4, r24	; 0x04
    3e06:	80 e0       	ldi	r24, 0x00	; 0
    3e08:	97 e1       	ldi	r25, 0x17	; 23
    3e0a:	97 83       	std	Z+7, r25	; 0x07
    3e0c:	86 83       	std	Z+6, r24	; 0x06
    3e0e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, statusTemperatureStr, temperature); 
    3e12:	20 91 bb 0e 	lds	r18, 0x0EBB
    3e16:	0f 90       	pop	r0
    3e18:	0f 90       	pop	r0
    3e1a:	ed b7       	in	r30, 0x3d	; 61
    3e1c:	fe b7       	in	r31, 0x3e	; 62
    3e1e:	31 96       	adiw	r30, 0x01	; 1
    3e20:	ad b7       	in	r26, 0x3d	; 61
    3e22:	be b7       	in	r27, 0x3e	; 62
    3e24:	12 96       	adiw	r26, 0x02	; 2
    3e26:	dc 93       	st	X, r29
    3e28:	ce 93       	st	-X, r28
    3e2a:	11 97       	sbiw	r26, 0x01	; 1
    3e2c:	81 e4       	ldi	r24, 0x41	; 65
    3e2e:	92 e0       	ldi	r25, 0x02	; 2
    3e30:	93 83       	std	Z+3, r25	; 0x03
    3e32:	82 83       	std	Z+2, r24	; 0x02
    3e34:	24 83       	std	Z+4, r18	; 0x04
    3e36:	15 82       	std	Z+5, r1	; 0x05
    3e38:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, statusVoltageStr, voltage); 
    3e3c:	20 91 c3 0e 	lds	r18, 0x0EC3
    3e40:	ed b7       	in	r30, 0x3d	; 61
    3e42:	fe b7       	in	r31, 0x3e	; 62
    3e44:	31 96       	adiw	r30, 0x01	; 1
    3e46:	ad b7       	in	r26, 0x3d	; 61
    3e48:	be b7       	in	r27, 0x3e	; 62
    3e4a:	12 96       	adiw	r26, 0x02	; 2
    3e4c:	dc 93       	st	X, r29
    3e4e:	ce 93       	st	-X, r28
    3e50:	11 97       	sbiw	r26, 0x01	; 1
    3e52:	8c e5       	ldi	r24, 0x5C	; 92
    3e54:	92 e0       	ldi	r25, 0x02	; 2
    3e56:	93 83       	std	Z+3, r25	; 0x03
    3e58:	82 83       	std	Z+2, r24	; 0x02
    3e5a:	24 83       	std	Z+4, r18	; 0x04
    3e5c:	15 82       	std	Z+5, r1	; 0x05
    3e5e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>

  uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
    3e62:	ed b7       	in	r30, 0x3d	; 61
    3e64:	fe b7       	in	r31, 0x3e	; 62
    3e66:	36 96       	adiw	r30, 0x06	; 6
    3e68:	0f b6       	in	r0, 0x3f	; 63
    3e6a:	f8 94       	cli
    3e6c:	fe bf       	out	0x3e, r31	; 62
    3e6e:	0f be       	out	0x3f, r0	; 63
    3e70:	ed bf       	out	0x3d, r30	; 61
    3e72:	0e 94 0a 22 	call	0x4414	; 0x4414 <ramDyskLiczbaWolnychKlastrow>
  fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
    3e76:	2d b7       	in	r18, 0x3d	; 61
    3e78:	3e b7       	in	r19, 0x3e	; 62
    3e7a:	28 50       	subi	r18, 0x08	; 8
    3e7c:	30 40       	sbci	r19, 0x00	; 0
    3e7e:	0f b6       	in	r0, 0x3f	; 63
    3e80:	f8 94       	cli
    3e82:	3e bf       	out	0x3e, r19	; 62
    3e84:	0f be       	out	0x3f, r0	; 63
    3e86:	2d bf       	out	0x3d, r18	; 61
    3e88:	ed b7       	in	r30, 0x3d	; 61
    3e8a:	fe b7       	in	r31, 0x3e	; 62
    3e8c:	31 96       	adiw	r30, 0x01	; 1
    3e8e:	ad b7       	in	r26, 0x3d	; 61
    3e90:	be b7       	in	r27, 0x3e	; 62
    3e92:	12 96       	adiw	r26, 0x02	; 2
    3e94:	dc 93       	st	X, r29
    3e96:	ce 93       	st	-X, r28
    3e98:	11 97       	sbiw	r26, 0x01	; 1
    3e9a:	24 e1       	ldi	r18, 0x14	; 20
    3e9c:	32 e0       	ldi	r19, 0x02	; 2
    3e9e:	33 83       	std	Z+3, r19	; 0x03
    3ea0:	22 83       	std	Z+2, r18	; 0x02
    3ea2:	84 83       	std	Z+4, r24	; 0x04
    3ea4:	15 82       	std	Z+5, r1	; 0x05
    3ea6:	80 e8       	ldi	r24, 0x80	; 128
    3ea8:	90 e0       	ldi	r25, 0x00	; 0
    3eaa:	97 83       	std	Z+7, r25	; 0x07
    3eac:	86 83       	std	Z+6, r24	; 0x06
    3eae:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
//  printErrorInfo(state); //TODO fix and uncomment
  
  //Print system configuration
  fprintf_P(stream, systemRamConfigStr);
    3eb2:	0f 90       	pop	r0
    3eb4:	0f 90       	pop	r0
    3eb6:	0f 90       	pop	r0
    3eb8:	0f 90       	pop	r0
    3eba:	ed b7       	in	r30, 0x3d	; 61
    3ebc:	fe b7       	in	r31, 0x3e	; 62
    3ebe:	d2 83       	std	Z+2, r29	; 0x02
    3ec0:	c1 83       	std	Z+1, r28	; 0x01
    3ec2:	87 e7       	ldi	r24, 0x77	; 119
    3ec4:	92 e0       	ldi	r25, 0x02	; 2
    3ec6:	94 83       	std	Z+4, r25	; 0x04
    3ec8:	83 83       	std	Z+3, r24	; 0x03
    3eca:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>

  fprintf_P(stream, statusMacStr);
    3ece:	ad b7       	in	r26, 0x3d	; 61
    3ed0:	be b7       	in	r27, 0x3e	; 62
    3ed2:	12 96       	adiw	r26, 0x02	; 2
    3ed4:	dc 93       	st	X, r29
    3ed6:	ce 93       	st	-X, r28
    3ed8:	11 97       	sbiw	r26, 0x01	; 1
    3eda:	8a e8       	ldi	r24, 0x8A	; 138
    3edc:	92 e0       	ldi	r25, 0x02	; 2
    3ede:	14 96       	adiw	r26, 0x04	; 4
    3ee0:	9c 93       	st	X, r25
    3ee2:	8e 93       	st	-X, r24
    3ee4:	13 97       	sbiw	r26, 0x03	; 3
    3ee6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    3eea:	0f 90       	pop	r0
    3eec:	0f 90       	pop	r0
    3eee:	0f 90       	pop	r0
    3ef0:	0f 90       	pop	r0
    3ef2:	ce 01       	movw	r24, r28
    3ef4:	67 e9       	ldi	r22, 0x97	; 151
    3ef6:	7e e0       	ldi	r23, 0x0E	; 14
    3ef8:	0e 94 a2 36 	call	0x6d44	; 0x6d44 <netPrintEthAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3efc:	00 d0       	rcall	.+0      	; 0x3efe <printStatus+0x1fa>
    3efe:	00 d0       	rcall	.+0      	; 0x3f00 <printStatus+0x1fc>
    3f00:	ed b7       	in	r30, 0x3d	; 61
    3f02:	fe b7       	in	r31, 0x3e	; 62
    3f04:	d2 83       	std	Z+2, r29	; 0x02
    3f06:	c1 83       	std	Z+1, r28	; 0x01
    3f08:	81 ef       	ldi	r24, 0xF1	; 241
    3f0a:	9a e0       	ldi	r25, 0x0A	; 10
    3f0c:	94 83       	std	Z+4, r25	; 0x04
    3f0e:	83 83       	std	Z+3, r24	; 0x03
    3f10:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  
  fprintf_P(stream, statusIpStr);
    3f14:	ad b7       	in	r26, 0x3d	; 61
    3f16:	be b7       	in	r27, 0x3e	; 62
    3f18:	12 96       	adiw	r26, 0x02	; 2
    3f1a:	dc 93       	st	X, r29
    3f1c:	ce 93       	st	-X, r28
    3f1e:	11 97       	sbiw	r26, 0x01	; 1
    3f20:	8f e9       	ldi	r24, 0x9F	; 159
    3f22:	92 e0       	ldi	r25, 0x02	; 2
    3f24:	14 96       	adiw	r26, 0x04	; 4
    3f26:	9c 93       	st	X, r25
    3f28:	8e 93       	st	-X, r24
    3f2a:	13 97       	sbiw	r26, 0x03	; 3
    3f2c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->ip);
    3f30:	0f 90       	pop	r0
    3f32:	0f 90       	pop	r0
    3f34:	0f 90       	pop	r0
    3f36:	0f 90       	pop	r0
    3f38:	0e 94 df 37 	call	0x6fbe	; 0x6fbe <ipGetConfig>
    3f3c:	fc 01       	movw	r30, r24
    3f3e:	40 81       	ld	r20, Z
    3f40:	51 81       	ldd	r21, Z+1	; 0x01
    3f42:	62 81       	ldd	r22, Z+2	; 0x02
    3f44:	73 81       	ldd	r23, Z+3	; 0x03
    3f46:	ce 01       	movw	r24, r28
    3f48:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3f4c:	00 d0       	rcall	.+0      	; 0x3f4e <printStatus+0x24a>
    3f4e:	00 d0       	rcall	.+0      	; 0x3f50 <printStatus+0x24c>
    3f50:	ed b7       	in	r30, 0x3d	; 61
    3f52:	fe b7       	in	r31, 0x3e	; 62
    3f54:	d2 83       	std	Z+2, r29	; 0x02
    3f56:	c1 83       	std	Z+1, r28	; 0x01
    3f58:	8e ee       	ldi	r24, 0xEE	; 238
    3f5a:	9a e0       	ldi	r25, 0x0A	; 10
    3f5c:	94 83       	std	Z+4, r25	; 0x04
    3f5e:	83 83       	std	Z+3, r24	; 0x03
    3f60:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>

  fprintf_P(stream, statusIpMaskStr);
    3f64:	ad b7       	in	r26, 0x3d	; 61
    3f66:	be b7       	in	r27, 0x3e	; 62
    3f68:	12 96       	adiw	r26, 0x02	; 2
    3f6a:	dc 93       	st	X, r29
    3f6c:	ce 93       	st	-X, r28
    3f6e:	11 97       	sbiw	r26, 0x01	; 1
    3f70:	84 eb       	ldi	r24, 0xB4	; 180
    3f72:	92 e0       	ldi	r25, 0x02	; 2
    3f74:	14 96       	adiw	r26, 0x04	; 4
    3f76:	9c 93       	st	X, r25
    3f78:	8e 93       	st	-X, r24
    3f7a:	13 97       	sbiw	r26, 0x03	; 3
    3f7c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->netmask);
    3f80:	0f 90       	pop	r0
    3f82:	0f 90       	pop	r0
    3f84:	0f 90       	pop	r0
    3f86:	0f 90       	pop	r0
    3f88:	0e 94 df 37 	call	0x6fbe	; 0x6fbe <ipGetConfig>
    3f8c:	fc 01       	movw	r30, r24
    3f8e:	44 81       	ldd	r20, Z+4	; 0x04
    3f90:	55 81       	ldd	r21, Z+5	; 0x05
    3f92:	66 81       	ldd	r22, Z+6	; 0x06
    3f94:	77 81       	ldd	r23, Z+7	; 0x07
    3f96:	ce 01       	movw	r24, r28
    3f98:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3f9c:	00 d0       	rcall	.+0      	; 0x3f9e <printStatus+0x29a>
    3f9e:	00 d0       	rcall	.+0      	; 0x3fa0 <printStatus+0x29c>
    3fa0:	ad b7       	in	r26, 0x3d	; 61
    3fa2:	be b7       	in	r27, 0x3e	; 62
    3fa4:	12 96       	adiw	r26, 0x02	; 2
    3fa6:	dc 93       	st	X, r29
    3fa8:	ce 93       	st	-X, r28
    3faa:	11 97       	sbiw	r26, 0x01	; 1
    3fac:	8b ee       	ldi	r24, 0xEB	; 235
    3fae:	9a e0       	ldi	r25, 0x0A	; 10
    3fb0:	14 96       	adiw	r26, 0x04	; 4
    3fb2:	9c 93       	st	X, r25
    3fb4:	8e 93       	st	-X, r24
    3fb6:	13 97       	sbiw	r26, 0x03	; 3
    3fb8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  
  fprintf_P(stream, statusIpGwStr);
    3fbc:	ed b7       	in	r30, 0x3d	; 61
    3fbe:	fe b7       	in	r31, 0x3e	; 62
    3fc0:	d2 83       	std	Z+2, r29	; 0x02
    3fc2:	c1 83       	std	Z+1, r28	; 0x01
    3fc4:	89 ec       	ldi	r24, 0xC9	; 201
    3fc6:	92 e0       	ldi	r25, 0x02	; 2
    3fc8:	94 83       	std	Z+4, r25	; 0x04
    3fca:	83 83       	std	Z+3, r24	; 0x03
    3fcc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->gateway);
    3fd0:	0f 90       	pop	r0
    3fd2:	0f 90       	pop	r0
    3fd4:	0f 90       	pop	r0
    3fd6:	0f 90       	pop	r0
    3fd8:	0e 94 df 37 	call	0x6fbe	; 0x6fbe <ipGetConfig>
    3fdc:	dc 01       	movw	r26, r24
    3fde:	18 96       	adiw	r26, 0x08	; 8
    3fe0:	4d 91       	ld	r20, X+
    3fe2:	5d 91       	ld	r21, X+
    3fe4:	6d 91       	ld	r22, X+
    3fe6:	7c 91       	ld	r23, X
    3fe8:	1b 97       	sbiw	r26, 0x0b	; 11
    3fea:	ce 01       	movw	r24, r28
    3fec:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3ff0:	00 d0       	rcall	.+0      	; 0x3ff2 <printStatus+0x2ee>
    3ff2:	00 d0       	rcall	.+0      	; 0x3ff4 <printStatus+0x2f0>
    3ff4:	ed b7       	in	r30, 0x3d	; 61
    3ff6:	fe b7       	in	r31, 0x3e	; 62
    3ff8:	d2 83       	std	Z+2, r29	; 0x02
    3ffa:	c1 83       	std	Z+1, r28	; 0x01
    3ffc:	88 ee       	ldi	r24, 0xE8	; 232
    3ffe:	9a e0       	ldi	r25, 0x0A	; 10
    4000:	94 83       	std	Z+4, r25	; 0x04
    4002:	83 83       	std	Z+3, r24	; 0x03
    4004:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  
  //Print Rs485 Execitive modules
  fprintf_P(stream, statusRs485listStr);
    4008:	ad b7       	in	r26, 0x3d	; 61
    400a:	be b7       	in	r27, 0x3e	; 62
    400c:	12 96       	adiw	r26, 0x02	; 2
    400e:	dc 93       	st	X, r29
    4010:	ce 93       	st	-X, r28
    4012:	11 97       	sbiw	r26, 0x01	; 1
    4014:	8e ed       	ldi	r24, 0xDE	; 222
    4016:	92 e0       	ldi	r25, 0x02	; 2
    4018:	14 96       	adiw	r26, 0x04	; 4
    401a:	9c 93       	st	X, r25
    401c:	8e 93       	st	-X, r24
    401e:	13 97       	sbiw	r26, 0x03	; 3
    4020:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  tmp = printRs485devices(stream);
    4024:	0f 90       	pop	r0
    4026:	0f 90       	pop	r0
    4028:	0f 90       	pop	r0
    402a:	0f 90       	pop	r0
    402c:	ce 01       	movw	r24, r28
    402e:	0e 94 5a 5c 	call	0xb8b4	; 0xb8b4 <printRs485devices>
  if (tmp == 0)
    4032:	88 23       	and	r24, r24
    4034:	81 f4       	brne	.+32     	; 0x4056 <printStatus+0x352>
    fprintf_P(stream, statusNoRs485Dev);  
    4036:	00 d0       	rcall	.+0      	; 0x4038 <printStatus+0x334>
    4038:	00 d0       	rcall	.+0      	; 0x403a <printStatus+0x336>
    403a:	ed b7       	in	r30, 0x3d	; 61
    403c:	fe b7       	in	r31, 0x3e	; 62
    403e:	d2 83       	std	Z+2, r29	; 0x02
    4040:	c1 83       	std	Z+1, r28	; 0x01
    4042:	89 ef       	ldi	r24, 0xF9	; 249
    4044:	92 e0       	ldi	r25, 0x02	; 2
    4046:	94 83       	std	Z+4, r25	; 0x04
    4048:	83 83       	std	Z+3, r24	; 0x03
    404a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    404e:	0f 90       	pop	r0
    4050:	0f 90       	pop	r0
    4052:	0f 90       	pop	r0
    4054:	0f 90       	pop	r0
  
  //Print locker sensors
  fprintf_P(stream, statusLockerSensorsStr);
    4056:	00 d0       	rcall	.+0      	; 0x4058 <printStatus+0x354>
    4058:	00 d0       	rcall	.+0      	; 0x405a <printStatus+0x356>
    405a:	ad b7       	in	r26, 0x3d	; 61
    405c:	be b7       	in	r27, 0x3e	; 62
    405e:	12 96       	adiw	r26, 0x02	; 2
    4060:	dc 93       	st	X, r29
    4062:	ce 93       	st	-X, r28
    4064:	11 97       	sbiw	r26, 0x01	; 1
    4066:	83 e1       	ldi	r24, 0x13	; 19
    4068:	93 e0       	ldi	r25, 0x03	; 3
    406a:	14 96       	adiw	r26, 0x04	; 4
    406c:	9c 93       	st	X, r25
    406e:	8e 93       	st	-X, r24
    4070:	13 97       	sbiw	r26, 0x03	; 3
    4072:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  tmp = printLockers(stream);
    4076:	0f 90       	pop	r0
    4078:	0f 90       	pop	r0
    407a:	0f 90       	pop	r0
    407c:	0f 90       	pop	r0
    407e:	ce 01       	movw	r24, r28
    4080:	0e 94 f7 13 	call	0x27ee	; 0x27ee <printLockers>
  if (tmp == 0)
    4084:	88 23       	and	r24, r24
    4086:	81 f4       	brne	.+32     	; 0x40a8 <printStatus+0x3a4>
    fprintf_P(stream, statusLockerSensorsDisStr);
    4088:	00 d0       	rcall	.+0      	; 0x408a <printStatus+0x386>
    408a:	00 d0       	rcall	.+0      	; 0x408c <printStatus+0x388>
    408c:	ed b7       	in	r30, 0x3d	; 61
    408e:	fe b7       	in	r31, 0x3e	; 62
    4090:	d2 83       	std	Z+2, r29	; 0x02
    4092:	c1 83       	std	Z+1, r28	; 0x01
    4094:	8c e2       	ldi	r24, 0x2C	; 44
    4096:	93 e0       	ldi	r25, 0x03	; 3
    4098:	94 83       	std	Z+4, r25	; 0x04
    409a:	83 83       	std	Z+3, r24	; 0x03
    409c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    40a0:	0f 90       	pop	r0
    40a2:	0f 90       	pop	r0
    40a4:	0f 90       	pop	r0
    40a6:	0f 90       	pop	r0
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    40a8:	ce 01       	movw	r24, r28
    40aa:	0e 94 0e 43 	call	0x861c	; 0x861c <udpPrintStatus>
//  arpPrintTable(stream);
}
    40ae:	df 91       	pop	r29
    40b0:	cf 91       	pop	r28
    40b2:	08 95       	ret

000040b4 <statusFunction>:


// ************************** CLI Functions *********************************************************************************

static cliExRes_t statusFunction(cmdState_t *state)
{
    40b4:	ef 92       	push	r14
    40b6:	ff 92       	push	r15
    40b8:	0f 93       	push	r16
    40ba:	1f 93       	push	r17
    40bc:	df 93       	push	r29
    40be:	cf 93       	push	r28
    40c0:	cd b7       	in	r28, 0x3d	; 61
    40c2:	de b7       	in	r29, 0x3e	; 62
    40c4:	2e 97       	sbiw	r28, 0x0e	; 14
    40c6:	0f b6       	in	r0, 0x3f	; 63
    40c8:	f8 94       	cli
    40ca:	de bf       	out	0x3e, r29	; 62
    40cc:	0f be       	out	0x3f, r0	; 63
    40ce:	cd bf       	out	0x3d, r28	; 61
    40d0:	7c 01       	movw	r14, r24
  if (state->argc < 1)
    40d2:	dc 01       	movw	r26, r24
    40d4:	59 96       	adiw	r26, 0x19	; 25
    40d6:	8c 91       	ld	r24, X
    40d8:	59 97       	sbiw	r26, 0x19	; 25
    40da:	88 23       	and	r24, r24
    40dc:	39 f4       	brne	.+14     	; 0x40ec <statusFunction+0x38>
  {
    printStatus(state->myStdInOut);
    40de:	5a 96       	adiw	r26, 0x1a	; 26
    40e0:	8d 91       	ld	r24, X+
    40e2:	9c 91       	ld	r25, X
    40e4:	5b 97       	sbiw	r26, 0x1b	; 27
    40e6:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <printStatus>
    40ea:	3b c0       	rjmp	.+118    	; 0x4162 <statusFunction+0xae>
    return OK_SILENT; 
  }
  
  FILE stream;
  if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
    40ec:	81 e0       	ldi	r24, 0x01	; 1
    40ee:	b7 01       	movw	r22, r14
    40f0:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    40f4:	61 e8       	ldi	r22, 0x81	; 129
    40f6:	7f e0       	ldi	r23, 0x0F	; 15
    40f8:	8e 01       	movw	r16, r28
    40fa:	0f 5f       	subi	r16, 0xFF	; 255
    40fc:	1f 4f       	sbci	r17, 0xFF	; 255
    40fe:	a8 01       	movw	r20, r16
    4100:	23 e0       	ldi	r18, 0x03	; 3
    4102:	0e 94 d8 26 	call	0x4db0	; 0x4db0 <ramDyskOtworzPlikStdIo>
    4106:	88 23       	and	r24, r24
    4108:	31 f1       	breq	.+76     	; 0x4156 <statusFunction+0xa2>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    410a:	f7 01       	movw	r30, r14
    410c:	02 8d       	ldd	r16, Z+26	; 0x1a
    410e:	13 8d       	ldd	r17, Z+27	; 0x1b
    4110:	81 e0       	ldi	r24, 0x01	; 1
    4112:	b7 01       	movw	r22, r14
    4114:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    4118:	00 d0       	rcall	.+0      	; 0x411a <statusFunction+0x66>
    411a:	00 d0       	rcall	.+0      	; 0x411c <statusFunction+0x68>
    411c:	00 d0       	rcall	.+0      	; 0x411e <statusFunction+0x6a>
    411e:	ed b7       	in	r30, 0x3d	; 61
    4120:	fe b7       	in	r31, 0x3e	; 62
    4122:	31 96       	adiw	r30, 0x01	; 1
    4124:	ad b7       	in	r26, 0x3d	; 61
    4126:	be b7       	in	r27, 0x3e	; 62
    4128:	12 96       	adiw	r26, 0x02	; 2
    412a:	1c 93       	st	X, r17
    412c:	0e 93       	st	-X, r16
    412e:	11 97       	sbiw	r26, 0x01	; 1
    4130:	22 e8       	ldi	r18, 0x82	; 130
    4132:	31 e0       	ldi	r19, 0x01	; 1
    4134:	33 83       	std	Z+3, r19	; 0x03
    4136:	22 83       	std	Z+2, r18	; 0x02
    4138:	95 83       	std	Z+5, r25	; 0x05
    413a:	84 83       	std	Z+4, r24	; 0x04
    413c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    4140:	24 e0       	ldi	r18, 0x04	; 4
    4142:	30 e0       	ldi	r19, 0x00	; 0
    4144:	ed b7       	in	r30, 0x3d	; 61
    4146:	fe b7       	in	r31, 0x3e	; 62
    4148:	36 96       	adiw	r30, 0x06	; 6
    414a:	0f b6       	in	r0, 0x3f	; 63
    414c:	f8 94       	cli
    414e:	fe bf       	out	0x3e, r31	; 62
    4150:	0f be       	out	0x3f, r0	; 63
    4152:	ed bf       	out	0x3d, r30	; 61
    4154:	08 c0       	rjmp	.+16     	; 0x4166 <statusFunction+0xb2>
    return ERROR_INFORM;
  }

  printStatus(&stream);
    4156:	c8 01       	movw	r24, r16
    4158:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <printStatus>
  ramDyskZamknijPlikStdIo(&stream);
    415c:	c8 01       	movw	r24, r16
    415e:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <ramDyskZamknijPlikStdIo>
    4162:	20 e0       	ldi	r18, 0x00	; 0
    4164:	30 e0       	ldi	r19, 0x00	; 0
  return OK_SILENT; 
}
    4166:	c9 01       	movw	r24, r18
    4168:	2e 96       	adiw	r28, 0x0e	; 14
    416a:	0f b6       	in	r0, 0x3f	; 63
    416c:	f8 94       	cli
    416e:	de bf       	out	0x3e, r29	; 62
    4170:	0f be       	out	0x3f, r0	; 63
    4172:	cd bf       	out	0x3d, r28	; 61
    4174:	cf 91       	pop	r28
    4176:	df 91       	pop	r29
    4178:	1f 91       	pop	r17
    417a:	0f 91       	pop	r16
    417c:	ff 90       	pop	r15
    417e:	ef 90       	pop	r14
    4180:	08 95       	ret

00004182 <VtyInit>:
  {cmd_disable,      cmd_help_disable,      disableFunction},
  {NULL, NULL, NULL}
};

void VtyInit(cmdState_t* state, FILE *stream)
{
    4182:	ef 92       	push	r14
    4184:	0f 93       	push	r16
    4186:	1f 93       	push	r17
    4188:	9b 01       	movw	r18, r22
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
    418a:	60 e0       	ldi	r22, 0x00	; 0
    418c:	78 e2       	ldi	r23, 0x28	; 40
    418e:	40 e0       	ldi	r20, 0x00	; 0
    4190:	51 e0       	ldi	r21, 0x01	; 1
    4192:	0a e4       	ldi	r16, 0x4A	; 74
    4194:	19 e0       	ldi	r17, 0x09	; 9
    4196:	ee 24       	eor	r14, r14
    4198:	0e 94 ac 29 	call	0x5358	; 0x5358 <cmdStateConfigure>
}
    419c:	1f 91       	pop	r17
    419e:	0f 91       	pop	r16
    41a0:	ef 90       	pop	r14
    41a2:	08 95       	ret

000041a4 <encTask>:
//   return 0;
// }


void encTask ( void *pvParameters )
{
    41a4:	cf 92       	push	r12
    41a6:	df 92       	push	r13
    41a8:	ef 92       	push	r14
    41aa:	ff 92       	push	r15
    41ac:	0f 93       	push	r16
    41ae:	1f 93       	push	r17
    41b0:	cf 93       	push	r28
    41b2:	df 93       	push	r29
  FILE *netstackDebug = (FILE *) pvParameters;
    41b4:	ec 01       	movw	r28, r24
  #ifdef DEBUG_PRINT_NET_PACKET
  uint16_t packetNo = 0;
  #endif /*DEBUG_PRINT_NET_PACKET*/

  nicInit();
    41b6:	0e 94 76 33 	call	0x66ec	; 0x66ec <nicInit>
  ipInit();
    41ba:	0e 94 35 3a 	call	0x746a	; 0x746a <ipInit>
  arpInit();
    41be:	0e 94 6b 3f 	call	0x7ed6	; 0x7ed6 <arpInit>
  icmpInit();
    41c2:	0e 94 60 3a 	call	0x74c0	; 0x74c0 <icmpInit>
  #if IP_DEBUG
    #if IPV6_SUPPORT
    ipv6DebugInit(netstackDebug);
    41c6:	ce 01       	movw	r24, r28
    41c8:	0e 94 92 45 	call	0x8b24	; 0x8b24 <ipv6DebugInit>
    vICMP6DebugInit(netstackDebug);
    41cc:	ce 01       	movw	r24, r28
    41ce:	0e 94 e3 4b 	call	0x97c6	; 0x97c6 <vICMP6DebugInit>
    #endif /*IPV6_SUPPORT*/
  fprintf_P(netstackDebug, PSTR("IP stack ready \r\n"));
    41d2:	00 d0       	rcall	.+0      	; 0x41d4 <encTask+0x30>
    41d4:	00 d0       	rcall	.+0      	; 0x41d6 <encTask+0x32>
    41d6:	ed b7       	in	r30, 0x3d	; 61
    41d8:	fe b7       	in	r31, 0x3e	; 62
    41da:	d2 83       	std	Z+2, r29	; 0x02
    41dc:	c1 83       	std	Z+1, r28	; 0x01
    41de:	88 e5       	ldi	r24, 0x58	; 88
    41e0:	9b e0       	ldi	r25, 0x0B	; 11
    41e2:	94 83       	std	Z+4, r25	; 0x04
    41e4:	83 83       	std	Z+3, r24	; 0x03
    41e6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  #endif /*IP_DEBUG*/
  #if IPV6_SUPPORT
  ipv6Init();
    41ea:	0f 90       	pop	r0
    41ec:	0f 90       	pop	r0
    41ee:	0f 90       	pop	r0
    41f0:	0f 90       	pop	r0
    41f2:	0e 94 91 45 	call	0x8b22	; 0x8b22 <ipv6Init>
  uip_netif_init();
    41f6:	0e 94 23 4d 	call	0x9a46	; 0x9a46 <uip_netif_init>
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
      }
    }
    
    #ifdef IP_DEBUG
    fprintf_P(netstackDebug, PSTR("==============================\r\n"));
    41fa:	96 e2       	ldi	r25, 0x26	; 38
    41fc:	c9 2e       	mov	r12, r25
    41fe:	9b e0       	ldi	r25, 0x0B	; 11
    4200:	d9 2e       	mov	r13, r25
    #endif /*IPV6_SUPPORT*/
    else
    {
      if (netstackDebug != NULL)
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    4202:	87 e4       	ldi	r24, 0x47	; 71
    4204:	e8 2e       	mov	r14, r24
    4206:	8b e0       	ldi	r24, 0x0B	; 11
    4208:	f8 2e       	mov	r15, r24
  //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);
  
  
  for ( ; ; )
  {
    vTaskDelay ( 0 );         //Zastpi oczekiwaniem na zwolnienie semafora. Semafor zostaje zwolniony po odebrzeniu przerwania od ENC
    420a:	80 e0       	ldi	r24, 0x00	; 0
    420c:	90 e0       	ldi	r25, 0x00	; 0
    420e:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
        
    // get the next new packet:
    plen = nicPoll();
    4212:	0e 94 27 31 	call	0x624e	; 0x624e <nicPoll>
    4216:	90 93 c9 0e 	sts	0x0EC9, r25
    421a:	80 93 c8 0e 	sts	0x0EC8, r24
    /*plen will ne unequal to zero if there is a valid
    * packet (without crc error) */
    if ( plen==0 )
    421e:	89 2b       	or	r24, r25
    4220:	29 f4       	brne	.+10     	; 0x422c <encTask+0x88>
    {
      flushUdpQueues();
    4222:	0e 94 21 45 	call	0x8a42	; 0x8a42 <flushUdpQueues>
      flushTcpQueues();
    4226:	0e 94 4c 40 	call	0x8098	; 0x8098 <flushTcpQueues>
    422a:	ef cf       	rjmp	.-34     	; 0x420a <encTask+0x66>
      fprintf_P(netstackDebug, PSTR("%02x:"), nicState.layer2.buf[i]);
    }
    fprintf_P(netstackDebug, PSTR("\r\n"));    
    #endif /*DEBUG_PRINT_NET_PACKET*/
    
    if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
    422c:	e0 91 9d 0e 	lds	r30, 0x0E9D
    4230:	f0 91 9e 0e 	lds	r31, 0x0E9E
    4234:	04 85       	ldd	r16, Z+12	; 0x0c
    4236:	15 85       	ldd	r17, Z+13	; 0x0d
    4238:	80 e0       	ldi	r24, 0x00	; 0
    423a:	98 e0       	ldi	r25, 0x08	; 8
    423c:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    4240:	08 17       	cp	r16, r24
    4242:	19 07       	cpc	r17, r25
    4244:	29 f4       	brne	.+10     	; 0x4250 <encTask+0xac>
    {
      arpIpIn();
    4246:	0e 94 20 3d 	call	0x7a40	; 0x7a40 <arpIpIn>
      netstackIPv4Process();
    424a:	0e 94 49 39 	call	0x7292	; 0x7292 <netstackIPv4Process>
    424e:	30 c0       	rjmp	.+96     	; 0x42b0 <encTask+0x10c>
    }
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
    4250:	e0 91 9d 0e 	lds	r30, 0x0E9D
    4254:	f0 91 9e 0e 	lds	r31, 0x0E9E
    4258:	04 85       	ldd	r16, Z+12	; 0x0c
    425a:	15 85       	ldd	r17, Z+13	; 0x0d
    425c:	86 e0       	ldi	r24, 0x06	; 6
    425e:	98 e0       	ldi	r25, 0x08	; 8
    4260:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    4264:	08 17       	cp	r16, r24
    4266:	19 07       	cpc	r17, r25
    4268:	19 f4       	brne	.+6      	; 0x4270 <encTask+0xcc>
    {
      arpArpIn();
    426a:	0e 94 77 3f 	call	0x7eee	; 0x7eee <arpArpIn>
    426e:	20 c0       	rjmp	.+64     	; 0x42b0 <encTask+0x10c>
    }
    #if IPV6_SUPPORT
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP6))       // process an ARP packet
    4270:	e0 91 9d 0e 	lds	r30, 0x0E9D
    4274:	f0 91 9e 0e 	lds	r31, 0x0E9E
    4278:	04 85       	ldd	r16, Z+12	; 0x0c
    427a:	15 85       	ldd	r17, Z+13	; 0x0d
    427c:	8d ed       	ldi	r24, 0xDD	; 221
    427e:	96 e8       	ldi	r25, 0x86	; 134
    4280:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    4284:	08 17       	cp	r16, r24
    4286:	19 07       	cpc	r17, r25
    4288:	19 f4       	brne	.+6      	; 0x4290 <encTask+0xec>
    {
      netstackIPv6Process();
    428a:	0e 94 27 4a 	call	0x944e	; 0x944e <netstackIPv6Process>
    428e:	10 c0       	rjmp	.+32     	; 0x42b0 <encTask+0x10c>
    }
    #endif /*IPV6_SUPPORT*/
    else
    {
      if (netstackDebug != NULL)
    4290:	20 97       	sbiw	r28, 0x00	; 0
    4292:	71 f0       	breq	.+28     	; 0x42b0 <encTask+0x10c>
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    4294:	00 d0       	rcall	.+0      	; 0x4296 <encTask+0xf2>
    4296:	00 d0       	rcall	.+0      	; 0x4298 <encTask+0xf4>
    4298:	ed b7       	in	r30, 0x3d	; 61
    429a:	fe b7       	in	r31, 0x3e	; 62
    429c:	d2 83       	std	Z+2, r29	; 0x02
    429e:	c1 83       	std	Z+1, r28	; 0x01
    42a0:	f4 82       	std	Z+4, r15	; 0x04
    42a2:	e3 82       	std	Z+3, r14	; 0x03
    42a4:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    42a8:	0f 90       	pop	r0
    42aa:	0f 90       	pop	r0
    42ac:	0f 90       	pop	r0
    42ae:	0f 90       	pop	r0
      }
    }
    
    #ifdef IP_DEBUG
    fprintf_P(netstackDebug, PSTR("==============================\r\n"));
    42b0:	00 d0       	rcall	.+0      	; 0x42b2 <encTask+0x10e>
    42b2:	00 d0       	rcall	.+0      	; 0x42b4 <encTask+0x110>
    42b4:	ed b7       	in	r30, 0x3d	; 61
    42b6:	fe b7       	in	r31, 0x3e	; 62
    42b8:	d2 83       	std	Z+2, r29	; 0x02
    42ba:	c1 83       	std	Z+1, r28	; 0x01
    42bc:	d4 82       	std	Z+4, r13	; 0x04
    42be:	c3 82       	std	Z+3, r12	; 0x03
    42c0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    42c4:	0f 90       	pop	r0
    42c6:	0f 90       	pop	r0
    42c8:	0f 90       	pop	r0
    42ca:	0f 90       	pop	r0
    42cc:	9e cf       	rjmp	.-196    	; 0x420a <encTask+0x66>

000042ce <vTaskVTYsocket>:
    }  
  }
}

void vTaskVTYsocket(void *cliStatePtr)
{
    42ce:	cf 93       	push	r28
    42d0:	df 93       	push	r29
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    42d2:	ec 01       	movw	r28, r24
  
  char znak;
  for( ;; )
  {
    znak = 0;
    znak = fgetc(state->myStdInOut);
    42d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    42d6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    42d8:	0e 94 c4 74 	call	0xe988	; 0xe988 <fgetc>
    cmdlineInputFunc((char)znak, state);
    42dc:	be 01       	movw	r22, r28
    42de:	0e 94 19 2a 	call	0x5432	; 0x5432 <cmdlineInputFunc>
    cmdlineMainLoop(state);
    42e2:	ce 01       	movw	r24, r28
    42e4:	0e 94 70 28 	call	0x50e0	; 0x50e0 <cmdlineMainLoop>
    42e8:	f5 cf       	rjmp	.-22     	; 0x42d4 <vTaskVTYsocket+0x6>

000042ea <vTaskVTYusb>:
#include "cli_task.h"

void vTaskVTYusb(void *cliStatePtr)
{
    42ea:	ef 92       	push	r14
    42ec:	ff 92       	push	r15
    42ee:	0f 93       	push	r16
    42f0:	1f 93       	push	r17
    42f2:	df 93       	push	r29
    42f4:	cf 93       	push	r28
    42f6:	0f 92       	push	r0
    42f8:	cd b7       	in	r28, 0x3d	; 61
    42fa:	de b7       	in	r29, 0x3e	; 62
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
    42fc:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Restart\r\n"));
    42fe:	00 d0       	rcall	.+0      	; 0x4300 <vTaskVTYusb+0x16>
    4300:	00 d0       	rcall	.+0      	; 0x4302 <vTaskVTYusb+0x18>
    4302:	fc 01       	movw	r30, r24
    4304:	82 8d       	ldd	r24, Z+26	; 0x1a
    4306:	93 8d       	ldd	r25, Z+27	; 0x1b
    4308:	ed b7       	in	r30, 0x3d	; 61
    430a:	fe b7       	in	r31, 0x3e	; 62
    430c:	92 83       	std	Z+2, r25	; 0x02
    430e:	81 83       	std	Z+1, r24	; 0x01
    4310:	8a e6       	ldi	r24, 0x6A	; 106
    4312:	9b e0       	ldi	r25, 0x0B	; 11
    4314:	94 83       	std	Z+4, r25	; 0x04
    4316:	83 83       	std	Z+3, r24	; 0x03
    4318:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  cmdlineInputFunc('\r', state);
    431c:	0f 90       	pop	r0
    431e:	0f 90       	pop	r0
    4320:	0f 90       	pop	r0
    4322:	0f 90       	pop	r0
    4324:	8d e0       	ldi	r24, 0x0D	; 13
    4326:	b8 01       	movw	r22, r16
    4328:	0e 94 19 2a 	call	0x5432	; 0x5432 <cmdlineInputFunc>
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    432c:	7e 01       	movw	r14, r28
    432e:	08 94       	sec
    4330:	e1 1c       	adc	r14, r1
    4332:	f1 1c       	adc	r15, r1
    4334:	80 91 c4 0e 	lds	r24, 0x0EC4
    4338:	90 91 c5 0e 	lds	r25, 0x0EC5
    433c:	b7 01       	movw	r22, r14
    433e:	4f ef       	ldi	r20, 0xFF	; 255
    4340:	5f ef       	ldi	r21, 0xFF	; 255
    4342:	20 e0       	ldi	r18, 0x00	; 0
    4344:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    4348:	88 23       	and	r24, r24
    434a:	a1 f3       	breq	.-24     	; 0x4334 <vTaskVTYusb+0x4a>
    {
      cmdlineInputFunc((char)znak, state);
    434c:	89 81       	ldd	r24, Y+1	; 0x01
    434e:	b8 01       	movw	r22, r16
    4350:	0e 94 19 2a 	call	0x5432	; 0x5432 <cmdlineInputFunc>
      cmdlineMainLoop(state);
    4354:	c8 01       	movw	r24, r16
    4356:	0e 94 70 28 	call	0x50e0	; 0x50e0 <cmdlineMainLoop>
    435a:	ec cf       	rjmp	.-40     	; 0x4334 <vTaskVTYusb+0x4a>

0000435c <spiSetCPHA>:
  //mode 0,0
}

void spiSetCPHA(void)
{
  SPCR |= (1<<CPHA);
    435c:	6a 9a       	sbi	0x0d, 2	; 13
}
    435e:	08 95       	ret

00004360 <spiClearCPHA>:

void spiClearCPHA(void)
{
  SPCR &= ~(1<<CPHA);
    4360:	6a 98       	cbi	0x0d, 2	; 13
}
    4362:	08 95       	ret

00004364 <spiSetCPOL>:

void spiSetCPOL(void)
{
  SPCR |= (1<<CPOL);
    4364:	6b 9a       	sbi	0x0d, 3	; 13
}
    4366:	08 95       	ret

00004368 <spiClearCPOL>:

void spiClearCPOL(void)
{
  SPCR &= ~(1<<CPOL);
    4368:	6b 98       	cbi	0x0d, 3	; 13
}
    436a:	08 95       	ret
    436c:	80 e0       	ldi	r24, 0x00	; 0
    436e:	08 95       	ret
    4370:	80 e0       	ldi	r24, 0x00	; 0
    4372:	08 95       	ret

00004374 <spiGive>:
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
}

void spiGive(void)
{
  xSemaphoreGive(xSemaphoreSpiSS);
    4374:	80 91 d7 0e 	lds	r24, 0x0ED7
    4378:	90 91 d8 0e 	lds	r25, 0x0ED8
    437c:	60 e0       	ldi	r22, 0x00	; 0
    437e:	70 e0       	ldi	r23, 0x00	; 0
    4380:	40 e0       	ldi	r20, 0x00	; 0
    4382:	50 e0       	ldi	r21, 0x00	; 0
    4384:	20 e0       	ldi	r18, 0x00	; 0
    4386:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>
}
    438a:	08 95       	ret

0000438c <spiTake>:
  SPCR &= ~(1<<CPOL);
}

void spiTake(void)
{
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
    438c:	80 91 d7 0e 	lds	r24, 0x0ED7
    4390:	90 91 d8 0e 	lds	r25, 0x0ED8
    4394:	60 e0       	ldi	r22, 0x00	; 0
    4396:	70 e0       	ldi	r23, 0x00	; 0
    4398:	4f ef       	ldi	r20, 0xFF	; 255
    439a:	5f ef       	ldi	r21, 0xFF	; 255
    439c:	20 e0       	ldi	r18, 0x00	; 0
    439e:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
}
    43a2:	08 95       	ret

000043a4 <spiInit>:
#include "semphr.h"


void spiInit(void (*disableAllSpiDevicesFun)(void))
{
  disableAllSpiDevicesFun();
    43a4:	fc 01       	movw	r30, r24
    43a6:	09 95       	icall
  portENTER_CRITICAL();
    43a8:	0f b6       	in	r0, 0x3f	; 63
    43aa:	f8 94       	cli
    43ac:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS); 
    43ae:	81 e0       	ldi	r24, 0x01	; 1
    43b0:	60 e0       	ldi	r22, 0x00	; 0
    43b2:	0e 94 8f 6d 	call	0xdb1e	; 0xdb1e <xQueueCreate>
    43b6:	90 93 d8 0e 	sts	0x0ED8, r25
    43ba:	80 93 d7 0e 	sts	0x0ED7, r24
    43be:	00 97       	sbiw	r24, 0x00	; 0
    43c0:	39 f0       	breq	.+14     	; 0x43d0 <spiInit+0x2c>
    43c2:	60 e0       	ldi	r22, 0x00	; 0
    43c4:	70 e0       	ldi	r23, 0x00	; 0
    43c6:	40 e0       	ldi	r20, 0x00	; 0
    43c8:	50 e0       	ldi	r21, 0x00	; 0
    43ca:	20 e0       	ldi	r18, 0x00	; 0
    43cc:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>

  SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPIE);
    43d0:	80 ed       	ldi	r24, 0xD0	; 208
    43d2:	8d b9       	out	0x0d, r24	; 13
  //SPCR = (1<<SPE)|(1<<MSTR);
  SPSR |= (1<<SPI2X);
    43d4:	70 9a       	sbi	0x0e, 0	; 14
  portEXIT_CRITICAL();
    43d6:	0f 90       	pop	r0
    43d8:	0f be       	out	0x3f, r0	; 63
  
  //mode 0,0
}
    43da:	08 95       	ret

000043dc <xmallocAvailable>:
  
  return result;
}

size_t xmallocAvailable(void)
{
    43dc:	20 91 86 01 	lds	r18, 0x0186
    43e0:	30 91 87 01 	lds	r19, 0x0187
    43e4:	2f 5f       	subi	r18, 0xFF	; 255
    43e6:	3f 4f       	sbci	r19, 0xFF	; 255
    43e8:	80 91 02 01 	lds	r24, 0x0102
    43ec:	90 91 03 01 	lds	r25, 0x0103
    43f0:	28 1b       	sub	r18, r24
    43f2:	39 0b       	sbc	r19, r25
  return __malloc_heap_end - heapEnd + 1;
    43f4:	c9 01       	movw	r24, r18
    43f6:	08 95       	ret

000043f8 <xmalloc>:
#include "hardwareConfig.h"

char *heapEnd = HEAP_BEGIN;

void *xmalloc(size_t size)
{
    43f8:	0f 93       	push	r16
    43fa:	1f 93       	push	r17
    43fc:	8c 01       	movw	r16, r24
  void *result = malloc(size);
    43fe:	0e 94 fa 71 	call	0xe3f4	; 0xe3f4 <malloc>
  
  heapEnd = (char *)(result);
  heapEnd += size;
    4402:	08 0f       	add	r16, r24
    4404:	19 1f       	adc	r17, r25
    4406:	10 93 03 01 	sts	0x0103, r17
    440a:	00 93 02 01 	sts	0x0102, r16
  
  return result;
}
    440e:	1f 91       	pop	r17
    4410:	0f 91       	pop	r16
    4412:	08 95       	ret

00004414 <ramDyskLiczbaWolnychKlastrow>:
  }
  while (tmpKlaster != tmpKlaster2);
}

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
    4414:	e1 e6       	ldi	r30, 0x61	; 97
    4416:	ff e0       	ldi	r31, 0x0F	; 15
    4418:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    if (klastry[temp] == 0)
    441a:	80 81       	ld	r24, Z
    441c:	88 23       	and	r24, r24
    441e:	09 f4       	brne	.+2      	; 0x4422 <ramDyskLiczbaWolnychKlastrow+0xe>
      wynik++;
    4420:	9f 5f       	subi	r25, 0xFF	; 255
    4422:	31 97       	sbiw	r30, 0x01	; 1

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    4424:	8e e0       	ldi	r24, 0x0E	; 14
    4426:	e2 3e       	cpi	r30, 0xE2	; 226
    4428:	f8 07       	cpc	r31, r24
    442a:	b9 f7       	brne	.-18     	; 0x441a <ramDyskLiczbaWolnychKlastrow+0x6>
    if (klastry[temp] == 0)
      wynik++;
  return wynik;
}
    442c:	89 2f       	mov	r24, r25
    442e:	08 95       	ret

00004430 <ramDyskDir>:
  }
  return wynik;
}

void ramDyskDir(FILE *ostream)
{
    4430:	2f 92       	push	r2
    4432:	3f 92       	push	r3
    4434:	4f 92       	push	r4
    4436:	5f 92       	push	r5
    4438:	7f 92       	push	r7
    443a:	8f 92       	push	r8
    443c:	9f 92       	push	r9
    443e:	af 92       	push	r10
    4440:	bf 92       	push	r11
    4442:	cf 92       	push	r12
    4444:	df 92       	push	r13
    4446:	ef 92       	push	r14
    4448:	ff 92       	push	r15
    444a:	0f 93       	push	r16
    444c:	1f 93       	push	r17
    444e:	cf 93       	push	r28
    4450:	df 93       	push	r29
    4452:	4c 01       	movw	r8, r24
  fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
    4454:	84 e0       	ldi	r24, 0x04	; 4
    4456:	91 e0       	ldi	r25, 0x01	; 1
    4458:	b4 01       	movw	r22, r8
    445a:	0e 94 61 75 	call	0xeac2	; 0xeac2 <fputs>
    445e:	77 24       	eor	r7, r7
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    4460:	2d e1       	ldi	r18, 0x1D	; 29
    4462:	22 2e       	mov	r2, r18
    4464:	21 e0       	ldi	r18, 0x01	; 1
    4466:	32 2e       	mov	r3, r18
  uint8_t tmpKlaster = 0;
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    4468:	e7 2c       	mov	r14, r7
    446a:	ff 24       	eor	r15, r15
    446c:	20 e8       	ldi	r18, 0x80	; 128
    446e:	30 e0       	ldi	r19, 0x00	; 0
    4470:	e2 0e       	add	r14, r18
    4472:	f3 1e       	adc	r15, r19
    4474:	de 2d       	mov	r29, r14
    4476:	cc 27       	eor	r28, r28
    4478:	80 e8       	ldi	r24, 0x80	; 128
    447a:	9f ef       	ldi	r25, 0xFF	; 255
    447c:	e8 0e       	add	r14, r24
    447e:	f9 1e       	adc	r15, r25
    for (tmp=0; tmp<16; tmp++)
    4480:	80 ef       	ldi	r24, 0xF0	; 240
    4482:	48 2e       	mov	r4, r24
    4484:	51 2c       	mov	r5, r1
    4486:	4c 0e       	add	r4, r28
    4488:	5d 1e       	adc	r5, r29
    {
      tmp3=plik->nazwa[0];
    448a:	1c 81       	ldd	r17, Y+4	; 0x04
      if (tmp3 == 0)
    448c:	11 23       	and	r17, r17
    448e:	09 f4       	brne	.+2      	; 0x4492 <ramDyskDir+0x62>
    4490:	4b c0       	rjmp	.+150    	; 0x4528 <ramDyskDir+0xf8>
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
    4492:	81 2f       	mov	r24, r17
    4494:	90 e0       	ldi	r25, 0x00	; 0
    4496:	b4 01       	movw	r22, r8
    4498:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    449c:	6e 01       	movw	r12, r28
    449e:	01 e0       	ldi	r16, 0x01	; 1
      for (tmp2=1; tmp2<8; tmp2++)
      {
        if (tmp3 != 0)
    44a0:	11 23       	and	r17, r17
    44a2:	59 f0       	breq	.+22     	; 0x44ba <ramDyskDir+0x8a>
          tmp3=plik->nazwa[tmp2];
    44a4:	d6 01       	movw	r26, r12
    44a6:	15 96       	adiw	r26, 0x05	; 5
    44a8:	1c 91       	ld	r17, X

        if (tmp3 != 0)
    44aa:	11 23       	and	r17, r17
    44ac:	31 f0       	breq	.+12     	; 0x44ba <ramDyskDir+0x8a>
          fputc(tmp3     , ostream);
    44ae:	81 2f       	mov	r24, r17
    44b0:	90 e0       	ldi	r25, 0x00	; 0
    44b2:	b4 01       	movw	r22, r8
    44b4:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    44b8:	06 c0       	rjmp	.+12     	; 0x44c6 <ramDyskDir+0x96>
        else
          fputc(' '      , ostream);
    44ba:	80 e2       	ldi	r24, 0x20	; 32
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	b4 01       	movw	r22, r8
    44c0:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    44c4:	10 e0       	ldi	r17, 0x00	; 0
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
    44c6:	0f 5f       	subi	r16, 0xFF	; 255
    44c8:	08 94       	sec
    44ca:	c1 1c       	adc	r12, r1
    44cc:	d1 1c       	adc	r13, r1
    44ce:	08 30       	cpi	r16, 0x08	; 8
    44d0:	39 f7       	brne	.-50     	; 0x44a0 <ramDyskDir+0x70>
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    44d2:	ed b7       	in	r30, 0x3d	; 61
    44d4:	fe b7       	in	r31, 0x3e	; 62
    44d6:	38 97       	sbiw	r30, 0x08	; 8
    44d8:	0f b6       	in	r0, 0x3f	; 63
    44da:	f8 94       	cli
    44dc:	fe bf       	out	0x3e, r31	; 62
    44de:	0f be       	out	0x3f, r0	; 63
    44e0:	ed bf       	out	0x3d, r30	; 61
    44e2:	31 96       	adiw	r30, 0x01	; 1
    44e4:	ad b7       	in	r26, 0x3d	; 61
    44e6:	be b7       	in	r27, 0x3e	; 62
    44e8:	12 96       	adiw	r26, 0x02	; 2
    44ea:	9c 92       	st	X, r9
    44ec:	8e 92       	st	-X, r8
    44ee:	11 97       	sbiw	r26, 0x01	; 1
    44f0:	33 82       	std	Z+3, r3	; 0x03
    44f2:	22 82       	std	Z+2, r2	; 0x02
    44f4:	ba 80       	ldd	r11, Y+2	; 0x02
    44f6:	aa 24       	eor	r10, r10
    44f8:	89 81       	ldd	r24, Y+1	; 0x01
    44fa:	95 01       	movw	r18, r10
    44fc:	28 0f       	add	r18, r24
    44fe:	31 1d       	adc	r19, r1
    4500:	35 83       	std	Z+5, r19	; 0x05
    4502:	24 83       	std	Z+4, r18	; 0x04
    4504:	8b 81       	ldd	r24, Y+3	; 0x03
    4506:	86 83       	std	Z+6, r24	; 0x06
    4508:	17 82       	std	Z+7, r1	; 0x07
    450a:	0e 94 06 75 	call	0xea0c	; 0xea0c <fprintf>
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do 
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    450e:	8d b7       	in	r24, 0x3d	; 61
    4510:	9e b7       	in	r25, 0x3e	; 62
    4512:	08 96       	adiw	r24, 0x08	; 8
    4514:	0f b6       	in	r0, 0x3f	; 63
    4516:	f8 94       	cli
    4518:	9e bf       	out	0x3e, r25	; 62
    451a:	0f be       	out	0x3f, r0	; 63
    451c:	8d bf       	out	0x3d, r24	; 61
    451e:	c4 15       	cp	r28, r4
    4520:	d5 05       	cpc	r29, r5
    4522:	11 f0       	breq	.+4      	; 0x4528 <ramDyskDir+0xf8>
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
      plik++;
    4524:	60 96       	adiw	r28, 0x10	; 16
    4526:	b1 cf       	rjmp	.-158    	; 0x448a <ramDyskDir+0x5a>
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    4528:	a2 ee       	ldi	r26, 0xE2	; 226
    452a:	be e0       	ldi	r27, 0x0E	; 14
    452c:	ea 0e       	add	r14, r26
    452e:	fb 1e       	adc	r15, r27
    4530:	f7 01       	movw	r30, r14
    4532:	80 81       	ld	r24, Z
  }
  while (tmpKlaster != tmpKlaster2);
    4534:	87 15       	cp	r24, r7
    4536:	11 f0       	breq	.+4      	; 0x453c <ramDyskDir+0x10c>
    4538:	78 2e       	mov	r7, r24
    453a:	96 cf       	rjmp	.-212    	; 0x4468 <ramDyskDir+0x38>
}
    453c:	df 91       	pop	r29
    453e:	cf 91       	pop	r28
    4540:	1f 91       	pop	r17
    4542:	0f 91       	pop	r16
    4544:	ff 90       	pop	r15
    4546:	ef 90       	pop	r14
    4548:	df 90       	pop	r13
    454a:	cf 90       	pop	r12
    454c:	bf 90       	pop	r11
    454e:	af 90       	pop	r10
    4550:	9f 90       	pop	r9
    4552:	8f 90       	pop	r8
    4554:	7f 90       	pop	r7
    4556:	5f 90       	pop	r5
    4558:	4f 90       	pop	r4
    455a:	3f 90       	pop	r3
    455c:	2f 90       	pop	r2
    455e:	08 95       	ret

00004560 <znajdzWolnyKlaster>:
      fd->wpis->rozmiarHi = fd->IndHi;    
  }
}

static uint8_t znajdzWolnyKlaster(void)
{
    4560:	21 e0       	ldi	r18, 0x01	; 1
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeli ma warto 0, to oznacza to, e na nim si koczy wpis katalogowy.
  {                                        //Moe by rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    4562:	42 2f       	mov	r20, r18
    4564:	50 e0       	ldi	r21, 0x00	; 0
    4566:	fa 01       	movw	r30, r20
    4568:	ee 51       	subi	r30, 0x1E	; 30
    456a:	f1 4f       	sbci	r31, 0xF1	; 241
    456c:	80 81       	ld	r24, Z
    456e:	88 23       	and	r24, r24
    4570:	69 f4       	brne	.+26     	; 0x458c <znajdzWolnyKlaster+0x2c>
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
    4572:	20 83       	st	Z, r18
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    4574:	e0 e0       	ldi	r30, 0x00	; 0
    4576:	f2 2f       	mov	r31, r18
    4578:	f0 58       	subi	r31, 0x80	; 128
    457a:	80 e0       	ldi	r24, 0x00	; 0
    457c:	91 e0       	ldi	r25, 0x01	; 1
    457e:	df 01       	movw	r26, r30
    4580:	ac 01       	movw	r20, r24
    4582:	1d 92       	st	X+, r1
    4584:	41 50       	subi	r20, 0x01	; 1
    4586:	50 40       	sbci	r21, 0x00	; 0
    4588:	e1 f7       	brne	.-8      	; 0x4582 <znajdzWolnyKlaster+0x22>
    458a:	04 c0       	rjmp	.+8      	; 0x4594 <znajdzWolnyKlaster+0x34>
}

static uint8_t znajdzWolnyKlaster(void)
{
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeli ma warto 0, to oznacza to, e na nim si koczy wpis katalogowy.
    458c:	2f 5f       	subi	r18, 0xFF	; 255
    458e:	20 38       	cpi	r18, 0x80	; 128
    4590:	41 f7       	brne	.-48     	; 0x4562 <znajdzWolnyKlaster+0x2>
    4592:	20 e0       	ldi	r18, 0x00	; 0
      czyscKlaster(i);                     //Czyszczenie zawartoci klastra.
      return i;
    }
  }
  return 0;
}
    4594:	82 2f       	mov	r24, r18
    4596:	08 95       	ret

00004598 <nastepnyKlaster>:

static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na nastpny klaster.
    4598:	a8 2f       	mov	r26, r24
    459a:	b0 e0       	ldi	r27, 0x00	; 0
    459c:	fd 01       	movw	r30, r26
    459e:	ee 51       	subi	r30, 0x1E	; 30
    45a0:	f1 4f       	sbci	r31, 0xF1	; 241
    45a2:	20 81       	ld	r18, Z
  if (temp == nrKlastra)                   //Jeli klaster wskazuje na samego siebie, co oznacza, e jest ostatni w pliku
    45a4:	28 17       	cp	r18, r24
    45a6:	f9 f4       	brne	.+62     	; 0x45e6 <nastepnyKlaster+0x4e>
    45a8:	21 e0       	ldi	r18, 0x01	; 1
  {                                        //Naley znale jaki wolny klaster i go doda do acycha klastrw w pliku
    for (temp=1; temp <128; temp++)        //Przekgldamy wszystkie klastry za wyjtkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    {                                      //Jeli temp ma warto 0 to oznacza, e nie ma wolnego klastra
      if (klastry[temp] == 0)              //Jeli w tablicy klaster wskazuje na 0, to oznacza, e jest on pusty
    45aa:	e2 2f       	mov	r30, r18
    45ac:	f0 e0       	ldi	r31, 0x00	; 0
    45ae:	ee 51       	subi	r30, 0x1E	; 30
    45b0:	f1 4f       	sbci	r31, 0xF1	; 241
    45b2:	80 81       	ld	r24, Z
    45b4:	88 23       	and	r24, r24
    45b6:	19 f0       	breq	.+6      	; 0x45be <nastepnyKlaster+0x26>
static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na nastpny klaster.
  if (temp == nrKlastra)                   //Jeli klaster wskazuje na samego siebie, co oznacza, e jest ostatni w pliku
  {                                        //Naley znale jaki wolny klaster i go doda do acycha klastrw w pliku
    for (temp=1; temp <128; temp++)        //Przekgldamy wszystkie klastry za wyjtkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    45b8:	2f 5f       	subi	r18, 0xFF	; 255
    45ba:	20 38       	cpi	r18, 0x80	; 128
    45bc:	b1 f7       	brne	.-20     	; 0x45aa <nastepnyKlaster+0x12>
        break;                             //Wtedy mona przerwa szukanie kolejnych klastrw dla klastra
    }                                      //Taka implementacja z zaoenia powoduje defragmentacj.
    
    if (temp != 0)                         //Znaleziono jaki wolny klaster
    {
      klastry[nrKlastra] = temp;           //Ustawienie acucha z klastrami, dodanie do pliku kolejnego klastra
    45be:	ae 51       	subi	r26, 0x1E	; 30
    45c0:	b1 4f       	sbci	r27, 0xF1	; 241
    45c2:	2c 93       	st	X, r18
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajtego (ostatniego w danym pliku)
    45c4:	82 2f       	mov	r24, r18
    45c6:	90 e0       	ldi	r25, 0x00	; 0
    45c8:	fc 01       	movw	r30, r24
    45ca:	ee 51       	subi	r30, 0x1E	; 30
    45cc:	f1 4f       	sbci	r31, 0xF1	; 241
    45ce:	20 83       	st	Z, r18
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    45d0:	e0 e0       	ldi	r30, 0x00	; 0
    45d2:	f2 2f       	mov	r31, r18
    45d4:	f0 58       	subi	r31, 0x80	; 128
    45d6:	80 e0       	ldi	r24, 0x00	; 0
    45d8:	91 e0       	ldi	r25, 0x01	; 1
    45da:	df 01       	movw	r26, r30
    45dc:	ac 01       	movw	r20, r24
    45de:	1d 92       	st	X+, r1
    45e0:	41 50       	subi	r20, 0x01	; 1
    45e2:	50 40       	sbci	r21, 0x00	; 0
    45e4:	e1 f7       	brne	.-8      	; 0x45de <nastepnyKlaster+0x46>
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajtego (ostatniego w danym pliku)
      czyscKlaster(temp);                  //Czyszczenie klastra
    }
  }
  return temp;
}
    45e6:	82 2f       	mov	r24, r18
    45e8:	08 95       	ret

000045ea <znajdzKlasterN>:

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
    45ea:	0f 93       	push	r16
    45ec:	1f 93       	push	r17
    45ee:	06 2f       	mov	r16, r22
    45f0:	10 e0       	ldi	r17, 0x00	; 0
    45f2:	05 c0       	rjmp	.+10     	; 0x45fe <znajdzKlasterN+0x14>
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Naley wykona klasterN przeskokw na kolejne klastry (IndHi okrela ile trzeba zrobi przeskokw od pierwszego klastra)
  {
    wynik = nastepnyKlaster(wynik);        //Jeli nie ma kolejnego klastra, to zostanie automatycznie dodany
    45f4:	0e 94 cc 22 	call	0x4598	; 0x4598 <nastepnyKlaster>
    if (wynik == 0)                        //Sprawdzany, czy znalaz si kolejny klaster
    45f8:	88 23       	and	r24, r24
    45fa:	19 f0       	breq	.+6      	; 0x4602 <znajdzKlasterN+0x18>

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Naley wykona klasterN przeskokw na kolejne klastry (IndHi okrela ile trzeba zrobi przeskokw od pierwszego klastra)
    45fc:	1f 5f       	subi	r17, 0xFF	; 255
    45fe:	10 17       	cp	r17, r16
    4600:	c8 f3       	brcs	.-14     	; 0x45f4 <znajdzKlasterN+0xa>
    wynik = nastepnyKlaster(wynik);        //Jeli nie ma kolejnego klastra, to zostanie automatycznie dodany
    if (wynik == 0)                        //Sprawdzany, czy znalaz si kolejny klaster
      break;                               //Bd, zwrcony zostanie klaster 0 - zarezerwowany na pocztek tablicy plikw
  }
  return wynik;
}
    4602:	1f 91       	pop	r17
    4604:	0f 91       	pop	r16
    4606:	08 95       	ret

00004608 <ramDyskDodajBlokXmodem>:
  }  
  return 0;
}

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
    4608:	cf 92       	push	r12
    460a:	df 92       	push	r13
    460c:	ef 92       	push	r14
    460e:	ff 92       	push	r15
    4610:	1f 93       	push	r17
    4612:	cf 93       	push	r28
    4614:	df 93       	push	r29
    4616:	7c 01       	movw	r14, r24
    4618:	6b 01       	movw	r12, r22
  if (nrBloku == 0)
    461a:	61 15       	cp	r22, r1
    461c:	71 05       	cpc	r23, r1
    461e:	09 f4       	brne	.+2      	; 0x4622 <ramDyskDodajBlokXmodem+0x1a>
    4620:	4e c0       	rjmp	.+156    	; 0x46be <ramDyskDodajBlokXmodem+0xb6>
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
  uint8_t indLo = 0;
  uint8_t *wynik;
  
  if (fd->wpis->pierwszyKlaster == 0)
    4622:	dc 01       	movw	r26, r24
    4624:	14 96       	adiw	r26, 0x04	; 4
    4626:	cd 91       	ld	r28, X+
    4628:	dc 91       	ld	r29, X
    462a:	15 97       	sbiw	r26, 0x05	; 5
    462c:	88 81       	ld	r24, Y
    462e:	88 23       	and	r24, r24
    4630:	19 f4       	brne	.+6      	; 0x4638 <ramDyskDodajBlokXmodem+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    4632:	0e 94 b0 22 	call	0x4560	; 0x4560 <znajdzWolnyKlaster>
    4636:	88 83       	st	Y, r24
  if (fd->wpis->pierwszyKlaster == 0)
    4638:	d7 01       	movw	r26, r14
    463a:	14 96       	adiw	r26, 0x04	; 4
    463c:	ed 91       	ld	r30, X+
    463e:	fc 91       	ld	r31, X
    4640:	15 97       	sbiw	r26, 0x05	; 5
    4642:	80 81       	ld	r24, Z
    4644:	88 23       	and	r24, r24
    4646:	d9 f1       	breq	.+118    	; 0x46be <ramDyskDodajBlokXmodem+0xb6>

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
  if (nrBloku == 0)
    return NULL;
  nrBloku --;
    4648:	08 94       	sec
    464a:	c1 08       	sbc	r12, r1
    464c:	d1 08       	sbc	r13, r1
  
  uint8_t indHi = (uint8_t)(nrBloku / 2);
    464e:	e6 01       	movw	r28, r12
    4650:	d6 95       	lsr	r29
    4652:	c7 95       	ror	r28
    4654:	1c 2f       	mov	r17, r28
  if (fd->wpis->pierwszyKlaster == 0)
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
  if (fd->wpis->pierwszyKlaster == 0)
    return NULL;
  
  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
    4656:	6c 2f       	mov	r22, r28
    4658:	0e 94 f5 22 	call	0x45ea	; 0x45ea <znajdzKlasterN>
    465c:	98 2f       	mov	r25, r24
  if (tmpKlaster == 0)
    465e:	88 23       	and	r24, r24
    4660:	71 f1       	breq	.+92     	; 0x46be <ramDyskDodajBlokXmodem+0xb6>
    4662:	d7 01       	movw	r26, r14
    4664:	14 96       	adiw	r26, 0x04	; 4
    4666:	ed 91       	ld	r30, X+
    4668:	fc 91       	ld	r31, X
    466a:	15 97       	sbiw	r26, 0x05	; 5
    return NULL;
  if ((nrBloku & 0x0001) == 0x0001)           // Druga cz klastra
    466c:	c0 fe       	sbrs	r12, 0
    466e:	0f c0       	rjmp	.+30     	; 0x468e <ramDyskDodajBlokXmodem+0x86>
  {
    indLo = 128;
    if (fd->wpis->rozmiarHi <= indHi)
    4670:	82 81       	ldd	r24, Z+2	; 0x02
    4672:	c8 17       	cp	r28, r24
    4674:	38 f0       	brcs	.+14     	; 0x4684 <ramDyskDodajBlokXmodem+0x7c>
    {
      fd->wpis->rozmiarHi = indHi+1;
    4676:	1f 5f       	subi	r17, 0xFF	; 255
    4678:	12 83       	std	Z+2, r17	; 0x02
      fd->wpis->rozmiarLo = 0;
    467a:	14 96       	adiw	r26, 0x04	; 4
    467c:	ed 91       	ld	r30, X+
    467e:	fc 91       	ld	r31, X
    4680:	15 97       	sbiw	r26, 0x05	; 5
    4682:	11 82       	std	Z+1, r1	; 0x01
    }
    wynik=dataPtr(tmpKlaster, 128);
    4684:	39 2f       	mov	r19, r25
    4686:	20 e0       	ldi	r18, 0x00	; 0
    4688:	20 58       	subi	r18, 0x80	; 128
    468a:	3f 47       	sbci	r19, 0x7F	; 127
    468c:	1a c0       	rjmp	.+52     	; 0x46c2 <ramDyskDodajBlokXmodem+0xba>
  }
  else
  {
    if (fd->wpis->rozmiarHi < indHi)
    468e:	82 81       	ldd	r24, Z+2	; 0x02
    4690:	8c 17       	cp	r24, r28
    4692:	38 f4       	brcc	.+14     	; 0x46a2 <ramDyskDodajBlokXmodem+0x9a>
    {
      fd->wpis->rozmiarHi = indHi;
    4694:	c2 83       	std	Z+2, r28	; 0x02
      fd->wpis->rozmiarLo = 128;
    4696:	d7 01       	movw	r26, r14
    4698:	14 96       	adiw	r26, 0x04	; 4
    469a:	ed 91       	ld	r30, X+
    469c:	fc 91       	ld	r31, X
    469e:	15 97       	sbiw	r26, 0x05	; 5
    46a0:	05 c0       	rjmp	.+10     	; 0x46ac <ramDyskDodajBlokXmodem+0xa4>
    }
    else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
    46a2:	8c 17       	cp	r24, r28
    46a4:	29 f4       	brne	.+10     	; 0x46b0 <ramDyskDodajBlokXmodem+0xa8>
    46a6:	81 81       	ldd	r24, Z+1	; 0x01
    46a8:	87 fd       	sbrc	r24, 7
    46aa:	02 c0       	rjmp	.+4      	; 0x46b0 <ramDyskDodajBlokXmodem+0xa8>
      fd->wpis->rozmiarLo = 128;
    46ac:	80 e8       	ldi	r24, 0x80	; 128
    46ae:	81 83       	std	Z+1, r24	; 0x01
    
    wynik=dataPtr(tmpKlaster, 0);
    46b0:	89 2f       	mov	r24, r25
    46b2:	90 e0       	ldi	r25, 0x00	; 0
    46b4:	80 58       	subi	r24, 0x80	; 128
    46b6:	9f 4f       	sbci	r25, 0xFF	; 255
    46b8:	38 2f       	mov	r19, r24
    46ba:	22 27       	eor	r18, r18
    46bc:	02 c0       	rjmp	.+4      	; 0x46c2 <ramDyskDodajBlokXmodem+0xba>
    46be:	20 e0       	ldi	r18, 0x00	; 0
    46c0:	30 e0       	ldi	r19, 0x00	; 0
  }
  return wynik;
}
    46c2:	c9 01       	movw	r24, r18
    46c4:	df 91       	pop	r29
    46c6:	cf 91       	pop	r28
    46c8:	1f 91       	pop	r17
    46ca:	ff 90       	pop	r15
    46cc:	ef 90       	pop	r14
    46ce:	df 90       	pop	r13
    46d0:	cf 90       	pop	r12
    46d2:	08 95       	ret

000046d4 <ramDyskUstawWskaznikNaKoniec>:

  return 0; 
}

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
    46d4:	cf 93       	push	r28
    46d6:	df 93       	push	r29
    46d8:	ec 01       	movw	r28, r24
  if (fd == NULL)
    46da:	00 97       	sbiw	r24, 0x00	; 0
    46dc:	11 f4       	brne	.+4      	; 0x46e2 <ramDyskUstawWskaznikNaKoniec+0xe>
    46de:	81 e0       	ldi	r24, 0x01	; 1
    46e0:	17 c0       	rjmp	.+46     	; 0x4710 <ramDyskUstawWskaznikNaKoniec+0x3c>
    return 1;
  fd->IndLo = fd->wpis->rozmiarLo;
    46e2:	ec 81       	ldd	r30, Y+4	; 0x04
    46e4:	fd 81       	ldd	r31, Y+5	; 0x05
    46e6:	91 81       	ldd	r25, Z+1	; 0x01
    46e8:	9a 83       	std	Y+2, r25	; 0x02
  fd->IndHi = fd->wpis->rozmiarHi;
    46ea:	82 81       	ldd	r24, Z+2	; 0x02
    46ec:	8b 83       	std	Y+3, r24	; 0x03
//  fd->IndLo++;
  uint8_t tmpKlaster = 0;
  if (fd->IndLo != 0)
    46ee:	99 23       	and	r25, r25
    46f0:	71 f0       	breq	.+28     	; 0x470e <ramDyskUstawWskaznikNaKoniec+0x3a>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    46f2:	80 81       	ld	r24, Z
    46f4:	62 81       	ldd	r22, Z+2	; 0x02
    46f6:	0e 94 f5 22 	call	0x45ea	; 0x45ea <znajdzKlasterN>
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
    46fa:	90 e0       	ldi	r25, 0x00	; 0
    46fc:	80 58       	subi	r24, 0x80	; 128
    46fe:	9f 4f       	sbci	r25, 0xFF	; 255
    4700:	98 2f       	mov	r25, r24
    4702:	88 27       	eor	r24, r24
    4704:	2a 81       	ldd	r18, Y+2	; 0x02
    4706:	82 0f       	add	r24, r18
    4708:	91 1d       	adc	r25, r1
    470a:	99 83       	std	Y+1, r25	; 0x01
    470c:	88 83       	st	Y, r24
    470e:	80 e0       	ldi	r24, 0x00	; 0
  }  
  return 0;
}
    4710:	df 91       	pop	r29
    4712:	cf 91       	pop	r28
    4714:	08 95       	ret

00004716 <ramDyskUstawWskaznik>:
  }
  return 0;
}

uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
{
    4716:	ef 92       	push	r14
    4718:	ff 92       	push	r15
    471a:	0f 93       	push	r16
    471c:	1f 93       	push	r17
    471e:	cf 93       	push	r28
    4720:	df 93       	push	r29
    4722:	ec 01       	movw	r28, r24
  if (indeks == 0)                                        //Sprawdzanie, czy wskanik nie pokazuje na pocztek pliku.
    4724:	61 15       	cp	r22, r1
    4726:	71 05       	cpc	r23, r1
    4728:	19 f4       	brne	.+6      	; 0x4730 <ramDyskUstawWskaznik+0x1a>
  {                                                       //Jeli tak, to nie ma potzeby tworzenia klastrw. Plik moe nadal nei mie adnego klastra.
    fd->IndLo = 0;                                        //Ustawianie na 0 indeksw (mniej i bardziej znaczcego bajtu)
    472a:	1a 82       	std	Y+2, r1	; 0x02
    fd->IndHi = 0;
    472c:	1b 82       	std	Y+3, r1	; 0x03
    472e:	44 c0       	rjmp	.+136    	; 0x47b8 <ramDyskUstawWskaznik+0xa2>
    return 0;
  }
  indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio ustawi rozmair pliku.
    4730:	8b 01       	movw	r16, r22
    4732:	01 50       	subi	r16, 0x01	; 1
    4734:	10 40       	sbci	r17, 0x00	; 0
                                                          //Jeli indeks jest wikszy ni rozmiar pliku, to plik zostanie rozcignity do zadanej wartoci indeksu -1
  
  if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma ju przydzielony pierwszy klaster
    4736:	ec 80       	ldd	r14, Y+4	; 0x04
    4738:	fd 80       	ldd	r15, Y+5	; 0x05
    473a:	f7 01       	movw	r30, r14
    473c:	80 81       	ld	r24, Z
    473e:	88 23       	and	r24, r24
    4740:	21 f4       	brne	.+8      	; 0x474a <ramDyskUstawWskaznik+0x34>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pliku. Jest to konieczne, poniewa klaster ma warto niezerow
    4742:	0e 94 b0 22 	call	0x4560	; 0x4560 <znajdzWolnyKlaster>
    4746:	f7 01       	movw	r30, r14
    4748:	80 83       	st	Z, r24

  uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrw, jak naley doda do pierwszego klastra`

  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartoci 16 mniej znaczcego bajtu indeksu pomniejszonej o 1
    474a:	0a 83       	std	Y+2, r16	; 0x02
  fd->IndHi = klasterN;                                   //oraz bardziej znaczcego bajtu indeksu w deskryptorze.
    474c:	1b 83       	std	Y+3, r17	; 0x03
  
  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
    474e:	ec 81       	ldd	r30, Y+4	; 0x04
    4750:	fd 81       	ldd	r31, Y+5	; 0x05
    4752:	80 81       	ld	r24, Z
    4754:	61 2f       	mov	r22, r17
    4756:	0e 94 f5 22 	call	0x45ea	; 0x45ea <znajdzKlasterN>
    475a:	38 2f       	mov	r19, r24
  if (nrKlastra == 0)
    475c:	88 23       	and	r24, r24
    475e:	11 f4       	brne	.+4      	; 0x4764 <ramDyskUstawWskaznik+0x4e>
    4760:	81 e0       	ldi	r24, 0x01	; 1
    4762:	2b c0       	rjmp	.+86     	; 0x47ba <ramDyskUstawWskaznik+0xa4>
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    4764:	ec 81       	ldd	r30, Y+4	; 0x04
    4766:	fd 81       	ldd	r31, Y+5	; 0x05
    4768:	92 81       	ldd	r25, Z+2	; 0x02
    476a:	8b 81       	ldd	r24, Y+3	; 0x03
    476c:	98 17       	cp	r25, r24
    476e:	29 f4       	brne	.+10     	; 0x477a <ramDyskUstawWskaznik+0x64>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    4770:	9a 81       	ldd	r25, Y+2	; 0x02
    4772:	81 81       	ldd	r24, Z+1	; 0x01
    4774:	89 17       	cp	r24, r25
    4776:	08 f4       	brcc	.+2      	; 0x477a <ramDyskUstawWskaznik+0x64>
      fd->wpis->rozmiarLo = fd->IndLo;
    4778:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    477a:	ec 81       	ldd	r30, Y+4	; 0x04
    477c:	fd 81       	ldd	r31, Y+5	; 0x05
    477e:	92 81       	ldd	r25, Z+2	; 0x02
    4780:	8b 81       	ldd	r24, Y+3	; 0x03
    4782:	98 17       	cp	r25, r24
    4784:	30 f4       	brcc	.+12     	; 0x4792 <ramDyskUstawWskaznik+0x7c>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    4786:	8a 81       	ldd	r24, Y+2	; 0x02
    4788:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    478a:	ec 81       	ldd	r30, Y+4	; 0x04
    478c:	fd 81       	ldd	r31, Y+5	; 0x05
    478e:	8b 81       	ldd	r24, Y+3	; 0x03
    4790:	82 83       	std	Z+2, r24	; 0x02
  if (nrKlastra == 0)
    return 1;                                             //Brak klastrw

  uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku

  fd->IndLo++;                                            //Powrt do zadanej wartoci indeksu
    4792:	2a 81       	ldd	r18, Y+2	; 0x02
    4794:	2f 5f       	subi	r18, 0xFF	; 255
    4796:	2a 83       	std	Y+2, r18	; 0x02
  if (fd->IndLo == 0)                                     //Jeli jestemy na pocztku klastra, to jeszcze on nie iestnieje
    4798:	22 23       	and	r18, r18
    479a:	21 f4       	brne	.+8      	; 0x47a4 <ramDyskUstawWskaznik+0x8e>
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczcy bajt indeksu
    479c:	8b 81       	ldd	r24, Y+3	; 0x03
    479e:	8f 5f       	subi	r24, 0xFF	; 255
    47a0:	8b 83       	std	Y+3, r24	; 0x03
    47a2:	0a c0       	rjmp	.+20     	; 0x47b8 <ramDyskUstawWskaznik+0xa2>
  else                                                    //Jestemy w obszarze utworzonego klastra, mona uaktualni wskanik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawi wskanik na odpowiednie miejsce klastra
    47a4:	83 2f       	mov	r24, r19
    47a6:	90 e0       	ldi	r25, 0x00	; 0
    47a8:	80 58       	subi	r24, 0x80	; 128
    47aa:	9f 4f       	sbci	r25, 0xFF	; 255
    47ac:	98 2f       	mov	r25, r24
    47ae:	88 27       	eor	r24, r24
    47b0:	82 0f       	add	r24, r18
    47b2:	91 1d       	adc	r25, r1
    47b4:	99 83       	std	Y+1, r25	; 0x01
    47b6:	88 83       	st	Y, r24
    47b8:	80 e0       	ldi	r24, 0x00	; 0

  return 0; 
}
    47ba:	df 91       	pop	r29
    47bc:	cf 91       	pop	r28
    47be:	1f 91       	pop	r17
    47c0:	0f 91       	pop	r16
    47c2:	ff 90       	pop	r15
    47c4:	ef 90       	pop	r14
    47c6:	08 95       	ret

000047c8 <ramDyskCzytajBajtZPliku>:
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
    47c8:	0f 93       	push	r16
    47ca:	1f 93       	push	r17
    47cc:	cf 93       	push	r28
    47ce:	df 93       	push	r29
    47d0:	ec 01       	movw	r28, r24
    47d2:	8b 01       	movw	r16, r22
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    47d4:	ec 81       	ldd	r30, Y+4	; 0x04
    47d6:	fd 81       	ldd	r31, Y+5	; 0x05
    47d8:	82 81       	ldd	r24, Z+2	; 0x02
    47da:	6b 81       	ldd	r22, Y+3	; 0x03
    47dc:	68 17       	cp	r22, r24
    47de:	30 f0       	brcs	.+12     	; 0x47ec <ramDyskCzytajBajtZPliku+0x24>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    47e0:	86 17       	cp	r24, r22
    47e2:	21 f5       	brne	.+72     	; 0x482c <ramDyskCzytajBajtZPliku+0x64>
    47e4:	91 81       	ldd	r25, Z+1	; 0x01
    47e6:	8a 81       	ldd	r24, Y+2	; 0x02
    47e8:	98 17       	cp	r25, r24
    47ea:	00 f1       	brcs	.+64     	; 0x482c <ramDyskCzytajBajtZPliku+0x64>
uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jestemy w obrbie pliku
    return 1;                                         //1 - eof

  if (fd->IndLo == 0)                                 //Sprawdzanie, czy dziaamy na pocztku nowego klastra
    47ec:	8a 81       	ldd	r24, Y+2	; 0x02
    47ee:	88 23       	and	r24, r24
    47f0:	41 f4       	brne	.+16     	; 0x4802 <ramDyskCzytajBajtZPliku+0x3a>
  {
    uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    47f2:	80 81       	ld	r24, Z
    47f4:	0e 94 f5 22 	call	0x45ea	; 0x45ea <znajdzKlasterN>
    fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskanika na pocztek nowego klastra
    47f8:	90 e0       	ldi	r25, 0x00	; 0
    47fa:	80 58       	subi	r24, 0x80	; 128
    47fc:	9f 4f       	sbci	r25, 0xFF	; 255
    47fe:	18 82       	st	Y, r1
    4800:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *bajt = *(fd->Wsk);                                 //Odczyt z pliku
    4802:	e8 81       	ld	r30, Y
    4804:	f9 81       	ldd	r31, Y+1	; 0x01
    4806:	80 81       	ld	r24, Z
    4808:	f8 01       	movw	r30, r16
    480a:	80 83       	st	Z, r24
  fd->IndLo++;                                        //Zwikszenie indeksu o 1
    480c:	8a 81       	ldd	r24, Y+2	; 0x02
    480e:	8f 5f       	subi	r24, 0xFF	; 255
    4810:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszlimy do nowego klastra
    4812:	88 23       	and	r24, r24
    4814:	21 f4       	brne	.+8      	; 0x481e <ramDyskCzytajBajtZPliku+0x56>
    fd->IndHi++;                                      //Tak: uaktualniamy liczb przeskok wzgldem pierwszego klastra (bardziej znaczcy bajt indeksu)
    4816:	8b 81       	ldd	r24, Y+3	; 0x03
    4818:	8f 5f       	subi	r24, 0xFF	; 255
    481a:	8b 83       	std	Y+3, r24	; 0x03
    481c:	05 c0       	rjmp	.+10     	; 0x4828 <ramDyskCzytajBajtZPliku+0x60>
  else                                                //Dziaamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskanik do tego klastra
    481e:	88 81       	ld	r24, Y
    4820:	99 81       	ldd	r25, Y+1	; 0x01
    4822:	01 96       	adiw	r24, 0x01	; 1
    4824:	99 83       	std	Y+1, r25	; 0x01
    4826:	88 83       	st	Y, r24
    4828:	80 e0       	ldi	r24, 0x00	; 0
    482a:	01 c0       	rjmp	.+2      	; 0x482e <ramDyskCzytajBajtZPliku+0x66>
    482c:	81 e0       	ldi	r24, 0x01	; 1
  return 0;
}
    482e:	df 91       	pop	r29
    4830:	cf 91       	pop	r28
    4832:	1f 91       	pop	r17
    4834:	0f 91       	pop	r16
    4836:	08 95       	ret

00004838 <getSTD>:
  return wynik;
}


static int getSTD(FILE *stream)
{
    4838:	df 93       	push	r29
    483a:	cf 93       	push	r28
    483c:	0f 92       	push	r0
    483e:	cd b7       	in	r28, 0x3d	; 61
    4840:	de b7       	in	r29, 0x3e	; 62
  uint8_t wynik;
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  
  if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
    4842:	fc 01       	movw	r30, r24
    4844:	84 85       	ldd	r24, Z+12	; 0x0c
    4846:	95 85       	ldd	r25, Z+13	; 0x0d
    4848:	be 01       	movw	r22, r28
    484a:	6f 5f       	subi	r22, 0xFF	; 255
    484c:	7f 4f       	sbci	r23, 0xFF	; 255
    484e:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <ramDyskCzytajBajtZPliku>
    4852:	88 23       	and	r24, r24
    4854:	19 f0       	breq	.+6      	; 0x485c <getSTD+0x24>
    4856:	2f ef       	ldi	r18, 0xFF	; 255
    4858:	3f ef       	ldi	r19, 0xFF	; 255
    485a:	03 c0       	rjmp	.+6      	; 0x4862 <getSTD+0x2a>
    return wynik;
    485c:	89 81       	ldd	r24, Y+1	; 0x01
    485e:	28 2f       	mov	r18, r24
    4860:	30 e0       	ldi	r19, 0x00	; 0
  return EOF;
}
    4862:	c9 01       	movw	r24, r18
    4864:	0f 90       	pop	r0
    4866:	cf 91       	pop	r28
    4868:	df 91       	pop	r29
    486a:	08 95       	ret

0000486c <ramDyskZapiszBajtDoPliku>:
  memset (fd, 0, 4);
  return 0;
}

uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
{
    486c:	1f 93       	push	r17
    486e:	cf 93       	push	r28
    4870:	df 93       	push	r29
    4872:	ec 01       	movw	r28, r24
    4874:	16 2f       	mov	r17, r22
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
    4876:	ec 81       	ldd	r30, Y+4	; 0x04
    4878:	fd 81       	ldd	r31, Y+5	; 0x05
    487a:	80 81       	ld	r24, Z
    487c:	88 23       	and	r24, r24
    487e:	49 f4       	brne	.+18     	; 0x4892 <ramDyskZapiszBajtDoPliku+0x26>
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
    4880:	0e 94 b0 22 	call	0x4560	; 0x4560 <znajdzWolnyKlaster>
    4884:	88 23       	and	r24, r24
    4886:	11 f4       	brne	.+4      	; 0x488c <ramDyskZapiszBajtDoPliku+0x20>
    4888:	81 e0       	ldi	r24, 0x01	; 1
    488a:	3e c0       	rjmp	.+124    	; 0x4908 <ramDyskZapiszBajtDoPliku+0x9c>
      return 1;                                         //Nie mona byo przydzieli pierwszego klastra do pliku
    fd->wpis->pierwszyKlaster = tmpKlaster;
    488c:	ec 81       	ldd	r30, Y+4	; 0x04
    488e:	fd 81       	ldd	r31, Y+5	; 0x05
    4890:	80 83       	st	Z, r24
  }
  if (fd->IndLo == 0)
    4892:	8a 81       	ldd	r24, Y+2	; 0x02
    4894:	88 23       	and	r24, r24
    4896:	79 f4       	brne	.+30     	; 0x48b6 <ramDyskZapiszBajtDoPliku+0x4a>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie nastpnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster by dodany
    4898:	ec 81       	ldd	r30, Y+4	; 0x04
    489a:	fd 81       	ldd	r31, Y+5	; 0x05
    489c:	80 81       	ld	r24, Z
    489e:	6b 81       	ldd	r22, Y+3	; 0x03
    48a0:	0e 94 f5 22 	call	0x45ea	; 0x45ea <znajdzKlasterN>
    if (tmpKlaster == 0)
    48a4:	88 23       	and	r24, r24
    48a6:	11 f4       	brne	.+4      	; 0x48ac <ramDyskZapiszBajtDoPliku+0x40>
    48a8:	82 e0       	ldi	r24, 0x02	; 2
    48aa:	2e c0       	rjmp	.+92     	; 0x4908 <ramDyskZapiszBajtDoPliku+0x9c>
    {
      return 2;                                       //Nie mona byo przydzieli kolejnego klastra
    }
    fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskanika na pocztek nowego klastra
    48ac:	90 e0       	ldi	r25, 0x00	; 0
    48ae:	80 58       	subi	r24, 0x80	; 128
    48b0:	9f 4f       	sbci	r25, 0xFF	; 255
    48b2:	18 82       	st	Y, r1
    48b4:	89 83       	std	Y+1, r24	; 0x01
  }
  
  *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
    48b6:	e8 81       	ld	r30, Y
    48b8:	f9 81       	ldd	r31, Y+1	; 0x01
    48ba:	10 83       	st	Z, r17

  fd->IndLo++;                                        //Zwikszanie indeksu odczytu/zapisu
    48bc:	8a 81       	ldd	r24, Y+2	; 0x02
    48be:	8f 5f       	subi	r24, 0xFF	; 255
    48c0:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Jeli ma on warto 0, to oznacza to, e czy klaster jest zapisany
    48c2:	88 23       	and	r24, r24
    48c4:	21 f4       	brne	.+8      	; 0x48ce <ramDyskZapiszBajtDoPliku+0x62>
    fd->IndHi++;                                      //Naley zwikszy bardziej znaczcy bajt indeksu. Nie utworzono nowego klastra, zatem nie uaktualniamy wskanika
    48c6:	8b 81       	ldd	r24, Y+3	; 0x03
    48c8:	8f 5f       	subi	r24, 0xFF	; 255
    48ca:	8b 83       	std	Y+3, r24	; 0x03
    48cc:	05 c0       	rjmp	.+10     	; 0x48d8 <ramDyskZapiszBajtDoPliku+0x6c>
  else                                                //Wzi dziaamy na tym samym klastrze.
    fd->Wsk++;                                        //Mona uaktualni wskanik
    48ce:	88 81       	ld	r24, Y
    48d0:	99 81       	ldd	r25, Y+1	; 0x01
    48d2:	01 96       	adiw	r24, 0x01	; 1
    48d4:	99 83       	std	Y+1, r25	; 0x01
    48d6:	88 83       	st	Y, r24
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    48d8:	ec 81       	ldd	r30, Y+4	; 0x04
    48da:	fd 81       	ldd	r31, Y+5	; 0x05
    48dc:	92 81       	ldd	r25, Z+2	; 0x02
    48de:	8b 81       	ldd	r24, Y+3	; 0x03
    48e0:	98 17       	cp	r25, r24
    48e2:	29 f4       	brne	.+10     	; 0x48ee <ramDyskZapiszBajtDoPliku+0x82>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    48e4:	9a 81       	ldd	r25, Y+2	; 0x02
    48e6:	81 81       	ldd	r24, Z+1	; 0x01
    48e8:	89 17       	cp	r24, r25
    48ea:	08 f4       	brcc	.+2      	; 0x48ee <ramDyskZapiszBajtDoPliku+0x82>
      fd->wpis->rozmiarLo = fd->IndLo;
    48ec:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    48ee:	ec 81       	ldd	r30, Y+4	; 0x04
    48f0:	fd 81       	ldd	r31, Y+5	; 0x05
    48f2:	92 81       	ldd	r25, Z+2	; 0x02
    48f4:	8b 81       	ldd	r24, Y+3	; 0x03
    48f6:	98 17       	cp	r25, r24
    48f8:	30 f4       	brcc	.+12     	; 0x4906 <ramDyskZapiszBajtDoPliku+0x9a>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    48fa:	8a 81       	ldd	r24, Y+2	; 0x02
    48fc:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    48fe:	ec 81       	ldd	r30, Y+4	; 0x04
    4900:	fd 81       	ldd	r31, Y+5	; 0x05
    4902:	8b 81       	ldd	r24, Y+3	; 0x03
    4904:	82 83       	std	Z+2, r24	; 0x02
    4906:	80 e0       	ldi	r24, 0x00	; 0
  else                                                //Wzi dziaamy na tym samym klastrze.
    fd->Wsk++;                                        //Mona uaktualni wskanik
    
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}
    4908:	df 91       	pop	r29
    490a:	cf 91       	pop	r28
    490c:	1f 91       	pop	r17
    490e:	08 95       	ret

00004910 <putSTD>:
    return wynik;
  return EOF;
}

static int putSTD(char c, FILE *stream)
{
    4910:	28 2f       	mov	r18, r24
    4912:	fb 01       	movw	r30, r22
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
    4914:	84 85       	ldd	r24, Z+12	; 0x0c
    4916:	95 85       	ldd	r25, Z+13	; 0x0d
    4918:	62 2f       	mov	r22, r18
    491a:	0e 94 36 24 	call	0x486c	; 0x486c <ramDyskZapiszBajtDoPliku>
}
    491e:	90 e0       	ldi	r25, 0x00	; 0
    4920:	08 95       	ret

00004922 <ramDyskCzyscPlik>:
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plikw
  }
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
    4922:	cf 93       	push	r28
    4924:	df 93       	push	r29
    4926:	9c 01       	movw	r18, r24
    4928:	0e c0       	rjmp	.+28     	; 0x4946 <ramDyskCzyscPlik+0x24>
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Ju na samym pocztku moe si okaza, e plik nie mia klastrw
  {
    usuwanyKlaster = fd->wpis->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostatniego klastra
    492a:	a8 2f       	mov	r26, r24
    492c:	b0 e0       	ldi	r27, 0x00	; 0
    492e:	fd 01       	movw	r30, r26
    4930:	ee 51       	subi	r30, 0x1E	; 30
    4932:	f1 4f       	sbci	r31, 0xF1	; 241
    4934:	e0 81       	ld	r30, Z
    4936:	e8 17       	cp	r30, r24
    4938:	11 f4       	brne	.+4      	; 0x493e <ramDyskCzyscPlik+0x1c>
      fd->wpis->pierwszyKlaster = 0;                           //Ok mona ju zakoczy usuwanie pliku
    493a:	18 82       	st	Y, r1
    493c:	01 c0       	rjmp	.+2      	; 0x4940 <ramDyskCzyscPlik+0x1e>
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejcie do nastpnego klastra
    493e:	e8 83       	st	Y, r30
    klastry[usuwanyKlaster] = 0;                               //Usunicie klastra
    4940:	ae 51       	subi	r26, 0x1E	; 30
    4942:	b1 4f       	sbci	r27, 0xF1	; 241
    4944:	1c 92       	st	X, r1
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Ju na samym pocztku moe si okaza, e plik nie mia klastrw
    4946:	d9 01       	movw	r26, r18
    4948:	14 96       	adiw	r26, 0x04	; 4
    494a:	cd 91       	ld	r28, X+
    494c:	dc 91       	ld	r29, X
    494e:	15 97       	sbiw	r26, 0x05	; 5
    4950:	88 81       	ld	r24, Y
    4952:	88 23       	and	r24, r24
    4954:	51 f7       	brne	.-44     	; 0x492a <ramDyskCzyscPlik+0x8>
      fd->wpis->pierwszyKlaster = 0;                           //Ok mona ju zakoczy usuwanie pliku
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejcie do nastpnego klastra
    klastry[usuwanyKlaster] = 0;                               //Usunicie klastra
  }
  fd->wpis->rozmiarLo       = 0;
    4956:	19 82       	std	Y+1, r1	; 0x01
  fd->wpis->rozmiarHi       = 0;
    4958:	14 96       	adiw	r26, 0x04	; 4
    495a:	ed 91       	ld	r30, X+
    495c:	fc 91       	ld	r31, X
    495e:	15 97       	sbiw	r26, 0x05	; 5
    4960:	12 82       	std	Z+2, r1	; 0x02
  fd->wpis->dataMod         = systemTime();
    4962:	14 96       	adiw	r26, 0x04	; 4
    4964:	ed 91       	ld	r30, X+
    4966:	fc 91       	ld	r31, X
    4968:	15 97       	sbiw	r26, 0x05	; 5
    496a:	14 86       	std	Z+12, r1	; 0x0c
    496c:	15 86       	std	Z+13, r1	; 0x0d
    496e:	16 86       	std	Z+14, r1	; 0x0e
    4970:	17 86       	std	Z+15, r1	; 0x0f
  memset (fd, 0, 4);
    4972:	f9 01       	movw	r30, r18
    4974:	10 82       	st	Z, r1
    4976:	11 82       	std	Z+1, r1	; 0x01
    4978:	12 82       	std	Z+2, r1	; 0x02
    497a:	13 82       	std	Z+3, r1	; 0x03
  return 0;
}
    497c:	df 91       	pop	r29
    497e:	cf 91       	pop	r28
    4980:	08 95       	ret

00004982 <ramDyskZamknijPlik>:
//relokacjaTablicyWpisow()
  return 0;
}

void ramDyskZamknijPlik(struct ramPlikFd *fd)
{
    4982:	dc 01       	movw	r26, r24
  if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwar jest poprawny
    4984:	14 96       	adiw	r26, 0x04	; 4
    4986:	ed 91       	ld	r30, X+
    4988:	fc 91       	ld	r31, X
    498a:	15 97       	sbiw	r26, 0x05	; 5
    498c:	83 81       	ldd	r24, Z+3	; 0x03
    498e:	88 23       	and	r24, r24
    4990:	39 f0       	breq	.+14     	; 0x49a0 <ramDyskZamknijPlik+0x1e>
  {
    fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwar pliku
    4992:	81 50       	subi	r24, 0x01	; 1
    4994:	83 83       	std	Z+3, r24	; 0x03
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plikw
    4996:	86 e0       	ldi	r24, 0x06	; 6
    4998:	fd 01       	movw	r30, r26
    499a:	11 92       	st	Z+, r1
    499c:	8a 95       	dec	r24
    499e:	e9 f7       	brne	.-6      	; 0x499a <ramDyskZamknijPlik+0x18>
    49a0:	08 95       	ret

000049a2 <ramDyskZamknijPlikStdIo>:
  fdev_set_udata(stream, fd);
  return 0;
}

uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
{
    49a2:	ef 92       	push	r14
    49a4:	ff 92       	push	r15
    49a6:	0f 93       	push	r16
    49a8:	1f 93       	push	r17
    49aa:	8c 01       	movw	r16, r24
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
    49ac:	dc 01       	movw	r26, r24
    49ae:	1c 96       	adiw	r26, 0x0c	; 12
    49b0:	ed 90       	ld	r14, X+
    49b2:	fc 90       	ld	r15, X
    49b4:	1d 97       	sbiw	r26, 0x0d	; 13
  ramDyskZamknijPlik(fd);
    49b6:	c7 01       	movw	r24, r14
    49b8:	0e 94 c1 24 	call	0x4982	; 0x4982 <ramDyskZamknijPlik>
  fclose(stream);
    49bc:	c8 01       	movw	r24, r16
    49be:	0e 94 99 74 	call	0xe932	; 0xe932 <fclose>
    49c2:	d7 01       	movw	r26, r14
    49c4:	14 96       	adiw	r26, 0x04	; 4
    49c6:	ed 91       	ld	r30, X+
    49c8:	fc 91       	ld	r31, X
    49ca:	15 97       	sbiw	r26, 0x05	; 5
  return fd->wpis->lAktOtw;
}
    49cc:	83 81       	ldd	r24, Z+3	; 0x03
    49ce:	1f 91       	pop	r17
    49d0:	0f 91       	pop	r16
    49d2:	ff 90       	pop	r15
    49d4:	ef 90       	pop	r14
    49d6:	08 95       	ret

000049d8 <ramDyskInit>:
}


void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrw (wszystkie s puste)
    49d8:	80 e8       	ldi	r24, 0x80	; 128
    49da:	e2 ee       	ldi	r30, 0xE2	; 226
    49dc:	fe e0       	ldi	r31, 0x0E	; 14
    49de:	df 01       	movw	r26, r30
    49e0:	1d 92       	st	X+, r1
    49e2:	8a 95       	dec	r24
    49e4:	e9 f7       	brne	.-6      	; 0x49e0 <ramDyskInit+0x8>
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablic plikw
    49e6:	80 e0       	ldi	r24, 0x00	; 0
    49e8:	91 e0       	ldi	r25, 0x01	; 1
    49ea:	e0 e0       	ldi	r30, 0x00	; 0
    49ec:	f0 e8       	ldi	r31, 0x80	; 128
    49ee:	df 01       	movw	r26, r30
    49f0:	9c 01       	movw	r18, r24
    49f2:	1d 92       	st	X+, r1
    49f4:	21 50       	subi	r18, 0x01	; 1
    49f6:	30 40       	sbci	r19, 0x00	; 0
    49f8:	e1 f7       	brne	.-8      	; 0x49f2 <ramDyskInit+0x1a>
}
    49fa:	08 95       	ret

000049fc <ramDyskCzytajBlokZPliku>:
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}

uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    49fc:	9f 92       	push	r9
    49fe:	af 92       	push	r10
    4a00:	bf 92       	push	r11
    4a02:	cf 92       	push	r12
    4a04:	df 92       	push	r13
    4a06:	ef 92       	push	r14
    4a08:	ff 92       	push	r15
    4a0a:	0f 93       	push	r16
    4a0c:	1f 93       	push	r17
    4a0e:	cf 93       	push	r28
    4a10:	df 93       	push	r29
    4a12:	ec 01       	movw	r28, r24
    4a14:	5b 01       	movw	r10, r22
    4a16:	6a 01       	movw	r12, r20
  if (fd->wpis->pierwszyKlaster == 0)
    4a18:	ec 81       	ldd	r30, Y+4	; 0x04
    4a1a:	fd 81       	ldd	r31, Y+5	; 0x05
    4a1c:	80 81       	ld	r24, Z
    4a1e:	88 23       	and	r24, r24
    4a20:	29 f4       	brne	.+10     	; 0x4a2c <ramDyskCzytajBlokZPliku+0x30>
  {
    *dlugosc = 0;
    4a22:	fa 01       	movw	r30, r20
    4a24:	11 82       	std	Z+1, r1	; 0x01
    4a26:	10 82       	st	Z, r1
    4a28:	81 e0       	ldi	r24, 0x01	; 1
    4a2a:	77 c0       	rjmp	.+238    	; 0x4b1a <ramDyskCzytajBlokZPliku+0x11e>
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    4a2c:	22 81       	ldd	r18, Z+2	; 0x02
    4a2e:	3b 81       	ldd	r19, Y+3	; 0x03
    4a30:	32 17       	cp	r19, r18
    4a32:	40 f0       	brcs	.+16     	; 0x4a44 <ramDyskCzytajBlokZPliku+0x48>
    return 0;
  
  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    4a34:	23 17       	cp	r18, r19
    4a36:	09 f0       	breq	.+2      	; 0x4a3a <ramDyskCzytajBlokZPliku+0x3e>
    4a38:	7c c0       	rjmp	.+248    	; 0x4b32 <ramDyskCzytajBlokZPliku+0x136>
    4a3a:	91 81       	ldd	r25, Z+1	; 0x01
    4a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a3e:	98 17       	cp	r25, r24
    4a40:	08 f4       	brcc	.+2      	; 0x4a44 <ramDyskCzytajBlokZPliku+0x48>
    4a42:	77 c0       	rjmp	.+238    	; 0x4b32 <ramDyskCzytajBlokZPliku+0x136>
  {
    *dlugosc = 0;
    return 2;                         //2 - le ustawiony indeks odczytu/zapisu (poza obszarem pliku)
  }
  
  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
    4a44:	82 2f       	mov	r24, r18
    4a46:	90 e0       	ldi	r25, 0x00	; 0
    4a48:	83 1b       	sub	r24, r19
    4a4a:	91 09       	sbc	r25, r1
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtw jaka zosta zapisana jeszcze za wskanikiem.
    4a4c:	21 81       	ldd	r18, Z+1	; 0x01
    4a4e:	42 2f       	mov	r20, r18
    4a50:	50 e0       	ldi	r21, 0x00	; 0
    4a52:	2a 81       	ldd	r18, Y+2	; 0x02
    4a54:	42 1b       	sub	r20, r18
    4a56:	51 09       	sbc	r21, r1
  lDanych -=fd->IndLo;                //Na podstawie wczeniej sprawdzonych warunkw jest to zawsze liczba dodatnia
  
  uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajt w pliku i okrelenie ile bajtw zdoa si odczyta
    lDanych :                          //W pliku jest mniej bajtw do odczytu ni chcemy odczyta
    *dlugosc;                          //W pliku jest wicej bajtw ni chcemy odczyta
    4a58:	48 0f       	add	r20, r24
    4a5a:	59 1f       	adc	r21, r25
    4a5c:	f6 01       	movw	r30, r12
    4a5e:	e0 80       	ld	r14, Z
    4a60:	f1 80       	ldd	r15, Z+1	; 0x01
    4a62:	4e 15       	cp	r20, r14
    4a64:	5f 05       	cpc	r21, r15
    4a66:	08 f4       	brcc	.+2      	; 0x4a6a <ramDyskCzytajBlokZPliku+0x6e>
    4a68:	7a 01       	movw	r14, r20
  *dlugosc = 0;                        //Jak do td odczytano 0 bajtw
    4a6a:	f6 01       	movw	r30, r12
    4a6c:	11 82       	std	Z+1, r1	; 0x01
    4a6e:	10 82       	st	Z, r1
  uint16_t dlBloku = 256 - fd->IndLo;  //Okrelanie liczby bajt jaka zosta do koca aktualnego klastra`
    4a70:	8a 81       	ldd	r24, Y+2	; 0x02
    4a72:	00 e0       	ldi	r16, 0x00	; 0
    4a74:	11 e0       	ldi	r17, 0x01	; 1
    4a76:	08 1b       	sub	r16, r24
    4a78:	11 09       	sbc	r17, r1
    4a7a:	99 24       	eor	r9, r9
    4a7c:	49 c0       	rjmp	.+146    	; 0x4b10 <ramDyskCzytajBlokZPliku+0x114>
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
  {
    if (fd->IndLo == 0)                //Indeks odczytu wskazuje na pocztek klastra. Oznacza to, e wskanik nie jest jeszcze ustawiony
    4a7e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a80:	88 23       	and	r24, r24
    4a82:	b1 f4       	brne	.+44     	; 0x4ab0 <ramDyskCzytajBlokZPliku+0xb4>
    {                                  //Bardziej znaczcy bajt indeksu okrela o ile klastrw (od pocztkowego) naley si przesun do przodu
      if (tmpKlaster == 0)
    4a84:	99 20       	and	r9, r9
    4a86:	39 f4       	brne	.+14     	; 0x4a96 <ramDyskCzytajBlokZPliku+0x9a>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); 
    4a88:	ec 81       	ldd	r30, Y+4	; 0x04
    4a8a:	fd 81       	ldd	r31, Y+5	; 0x05
    4a8c:	80 81       	ld	r24, Z
    4a8e:	6b 81       	ldd	r22, Y+3	; 0x03
    4a90:	0e 94 f5 22 	call	0x45ea	; 0x45ea <znajdzKlasterN>
    4a94:	03 c0       	rjmp	.+6      	; 0x4a9c <ramDyskCzytajBlokZPliku+0xa0>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
    4a96:	89 2d       	mov	r24, r9
    4a98:	0e 94 cc 22 	call	0x4598	; 0x4598 <nastepnyKlaster>
    4a9c:	98 2e       	mov	r9, r24
      if (tmpKlaster != 0)             //Jeli znaleziono odpowiedni klaster, to
    4a9e:	88 23       	and	r24, r24
    4aa0:	11 f4       	brne	.+4      	; 0x4aa6 <ramDyskCzytajBlokZPliku+0xaa>
    4aa2:	83 e0       	ldi	r24, 0x03	; 3
    4aa4:	3a c0       	rjmp	.+116    	; 0x4b1a <ramDyskCzytajBlokZPliku+0x11e>
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskanik na pocztek tego klastra
    4aa6:	90 e0       	ldi	r25, 0x00	; 0
    4aa8:	80 58       	subi	r24, 0x80	; 128
    4aaa:	9f 4f       	sbci	r25, 0xFF	; 255
    4aac:	18 82       	st	Y, r1
    4aae:	89 83       	std	Y+1, r24	; 0x01
    4ab0:	68 81       	ld	r22, Y
    4ab2:	79 81       	ldd	r23, Y+1	; 0x01
      else
        return 3;                      //3 - Nie udao si znale odpowiedniego klastra
    }
    
    if (doOdczytania > dlBloku)        //Odczyt do koca zawartoci klastra
    4ab4:	0e 15       	cp	r16, r14
    4ab6:	1f 05       	cpc	r17, r15
    4ab8:	b0 f4       	brcc	.+44     	; 0x4ae6 <ramDyskCzytajBlokZPliku+0xea>
    {                                  //dlBloku okrela ile zostao jeszcze bajtw do koca klasrta
      memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartoci Klastra
    4aba:	c5 01       	movw	r24, r10
    4abc:	a8 01       	movw	r20, r16
    4abe:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
      znaki +=dlBloku;                 //Przestawienie wskanika do tablicy, w ktrej zapisujemy odczytane bajty
    4ac2:	a0 0e       	add	r10, r16
    4ac4:	b1 1e       	adc	r11, r17
      fd->IndLo = 0;                   //Indeks wskazuje na pocztek nowego klastra
    4ac6:	1a 82       	std	Y+2, r1	; 0x02
      fd->IndHi++;                     //Bardziej znaczcy bajt okrela zmian klastra. Teraz nie ma potrzeby ustawienia wskanika odczytu na jego pocztek
    4ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    4aca:	8f 5f       	subi	r24, 0xFF	; 255
    4acc:	8b 83       	std	Y+3, r24	; 0x03
      doOdczytania -= dlBloku;         //Uaktualnienie liczby bajt jak naley odczyta
    4ace:	e0 1a       	sub	r14, r16
    4ad0:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;             //Uaktualnienie 
    4ad2:	f6 01       	movw	r30, r12
    4ad4:	80 81       	ld	r24, Z
    4ad6:	91 81       	ldd	r25, Z+1	; 0x01
    4ad8:	80 0f       	add	r24, r16
    4ada:	91 1f       	adc	r25, r17
    4adc:	91 83       	std	Z+1, r25	; 0x01
    4ade:	80 83       	st	Z, r24
    4ae0:	00 e0       	ldi	r16, 0x00	; 0
    4ae2:	11 e0       	ldi	r17, 0x01	; 1
    4ae4:	15 c0       	rjmp	.+42     	; 0x4b10 <ramDyskCzytajBlokZPliku+0x114>
      dlBloku = 256;                   //Kolejny dostpny blok do odczytania, to dugo caego klastra.
    }
    else                               //Ostatnia operacja odczytu
    {
      memcpy(znaki, fd->Wsk, doOdczytania);
    4ae6:	c5 01       	movw	r24, r10
    4ae8:	a7 01       	movw	r20, r14
    4aea:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
      fd->Wsk   += doOdczytania;       //Po zakoczeniu operacji odczytu nadal dziaamy w tym samym klastrze, zatem trzeba teraz uaktualni wzkanik
    4aee:	88 81       	ld	r24, Y
    4af0:	99 81       	ldd	r25, Y+1	; 0x01
    4af2:	8e 0d       	add	r24, r14
    4af4:	9f 1d       	adc	r25, r15
    4af6:	99 83       	std	Y+1, r25	; 0x01
    4af8:	88 83       	st	Y, r24
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jestemy w tym samym klastrze, zatem nie trzeba zmienia IndHi
    4afa:	8a 81       	ldd	r24, Y+2	; 0x02
    4afc:	8e 0d       	add	r24, r14
    4afe:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtw                    
    4b00:	f6 01       	movw	r30, r12
    4b02:	80 81       	ld	r24, Z
    4b04:	91 81       	ldd	r25, Z+1	; 0x01
    4b06:	8e 0d       	add	r24, r14
    4b08:	9f 1d       	adc	r25, r15
    4b0a:	91 83       	std	Z+1, r25	; 0x01
    4b0c:	80 83       	st	Z, r24
    4b0e:	04 c0       	rjmp	.+8      	; 0x4b18 <ramDyskCzytajBlokZPliku+0x11c>
    lDanych :                          //W pliku jest mniej bajtw do odczytu ni chcemy odczyta
    *dlugosc;                          //W pliku jest wicej bajtw ni chcemy odczyta
  *dlugosc = 0;                        //Jak do td odczytano 0 bajtw
  uint16_t dlBloku = 256 - fd->IndLo;  //Okrelanie liczby bajt jaka zosta do koca aktualnego klastra`
  uint8_t tmpKlaster = 0;
  while (doOdczytania > 0)
    4b10:	e1 14       	cp	r14, r1
    4b12:	f1 04       	cpc	r15, r1
    4b14:	09 f0       	breq	.+2      	; 0x4b18 <ramDyskCzytajBlokZPliku+0x11c>
    4b16:	b3 cf       	rjmp	.-154    	; 0x4a7e <ramDyskCzytajBlokZPliku+0x82>
    4b18:	80 e0       	ldi	r24, 0x00	; 0
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtw                    
      doOdczytania = 0;                //Tutaj rwnie dobrze moe by brake
    }
  }
  return 0;
}
    4b1a:	df 91       	pop	r29
    4b1c:	cf 91       	pop	r28
    4b1e:	1f 91       	pop	r17
    4b20:	0f 91       	pop	r16
    4b22:	ff 90       	pop	r15
    4b24:	ef 90       	pop	r14
    4b26:	df 90       	pop	r13
    4b28:	cf 90       	pop	r12
    4b2a:	bf 90       	pop	r11
    4b2c:	af 90       	pop	r10
    4b2e:	9f 90       	pop	r9
    4b30:	08 95       	ret
    *dlugosc = 0;
    return 1;                         //1 - Plik jest pusty
  }
  if (wObrebiePliku(fd) != 0)
  {
    *dlugosc = 0;
    4b32:	f6 01       	movw	r30, r12
    4b34:	11 82       	std	Z+1, r1	; 0x01
    4b36:	10 82       	st	Z, r1
    4b38:	82 e0       	ldi	r24, 0x02	; 2
    4b3a:	ef cf       	rjmp	.-34     	; 0x4b1a <ramDyskCzytajBlokZPliku+0x11e>

00004b3c <ramDyskZapiszBlokDoPliku>:
    fd->Wsk++;                                        //Uaktualniamy wskanik do tego klastra
  return 0;
}

uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    4b3c:	8f 92       	push	r8
    4b3e:	9f 92       	push	r9
    4b40:	bf 92       	push	r11
    4b42:	cf 92       	push	r12
    4b44:	df 92       	push	r13
    4b46:	ef 92       	push	r14
    4b48:	ff 92       	push	r15
    4b4a:	0f 93       	push	r16
    4b4c:	1f 93       	push	r17
    4b4e:	cf 93       	push	r28
    4b50:	df 93       	push	r29
    4b52:	ec 01       	movw	r28, r24
    4b54:	6b 01       	movw	r12, r22
    4b56:	4a 01       	movw	r8, r20
  if (fd->wpis->pierwszyKlaster == 0)
    4b58:	0c 81       	ldd	r16, Y+4	; 0x04
    4b5a:	1d 81       	ldd	r17, Y+5	; 0x05
    4b5c:	f8 01       	movw	r30, r16
    4b5e:	80 81       	ld	r24, Z
    4b60:	88 23       	and	r24, r24
    4b62:	21 f4       	brne	.+8      	; 0x4b6c <ramDyskZapiszBlokDoPliku+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    4b64:	0e 94 b0 22 	call	0x4560	; 0x4560 <znajdzWolnyKlaster>
    4b68:	f8 01       	movw	r30, r16
    4b6a:	80 83       	st	Z, r24
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtw, jak da si zapisa w aktualnym klastrze
    4b6c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b6e:	00 e0       	ldi	r16, 0x00	; 0
    4b70:	11 e0       	ldi	r17, 0x01	; 1
    4b72:	08 1b       	sub	r16, r24
    4b74:	11 09       	sbc	r17, r1
  uint16_t doZapisu = *dlugosc;
    4b76:	f4 01       	movw	r30, r8
    4b78:	e0 80       	ld	r14, Z
    4b7a:	f1 80       	ldd	r15, Z+1	; 0x01
  *dlugosc = 0;                                   //Jak do td jeszcze nic nie zapisano
    4b7c:	11 82       	std	Z+1, r1	; 0x01
    4b7e:	10 82       	st	Z, r1
    4b80:	bb 24       	eor	r11, r11
    4b82:	4e c0       	rjmp	.+156    	; 0x4c20 <ramDyskZapiszBlokDoPliku+0xe4>
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
  {
    if (fd->IndLo == 0)                           //Jeli indeks pokazuje na pocztek klastra, to naley odczyta jego numer oraz ustawi na niego wskanik
    4b84:	8a 81       	ldd	r24, Y+2	; 0x02
    4b86:	88 23       	and	r24, r24
    4b88:	b1 f4       	brne	.+44     	; 0x4bb6 <ramDyskZapiszBlokDoPliku+0x7a>
    {
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
    4b8a:	bb 20       	and	r11, r11
    4b8c:	39 f4       	brne	.+14     	; 0x4b9c <ramDyskZapiszBlokDoPliku+0x60>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskokw od pierwszego
    4b8e:	ec 81       	ldd	r30, Y+4	; 0x04
    4b90:	fd 81       	ldd	r31, Y+5	; 0x05
    4b92:	80 81       	ld	r24, Z
    4b94:	6b 81       	ldd	r22, Y+3	; 0x03
    4b96:	0e 94 f5 22 	call	0x45ea	; 0x45ea <znajdzKlasterN>
    4b9a:	03 c0       	rjmp	.+6      	; 0x4ba2 <ramDyskZapiszBlokDoPliku+0x66>
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przej do nastpnego
    4b9c:	8b 2d       	mov	r24, r11
    4b9e:	0e 94 cc 22 	call	0x4598	; 0x4598 <nastepnyKlaster>
    4ba2:	b8 2e       	mov	r11, r24
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udao si znale klaster
    4ba4:	88 23       	and	r24, r24
    4ba6:	11 f4       	brne	.+4      	; 0x4bac <ramDyskZapiszBlokDoPliku+0x70>
    4ba8:	81 e0       	ldi	r24, 0x01	; 1
    4baa:	56 c0       	rjmp	.+172    	; 0x4c58 <ramDyskZapiszBlokDoPliku+0x11c>
        return 1;                                 //1 - Brak wolnego klastra

      fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskanika na pocztek klastra. Teraz mona do niego ju pisa
    4bac:	90 e0       	ldi	r25, 0x00	; 0
    4bae:	80 58       	subi	r24, 0x80	; 128
    4bb0:	9f 4f       	sbci	r25, 0xFF	; 255
    4bb2:	18 82       	st	Y, r1
    4bb4:	89 83       	std	Y+1, r24	; 0x01
    4bb6:	88 81       	ld	r24, Y
    4bb8:	99 81       	ldd	r25, Y+1	; 0x01
    }
    if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda si zapisa w biecym klastrze
    4bba:	0e 15       	cp	r16, r14
    4bbc:	1f 05       	cpc	r17, r15
    4bbe:	b0 f4       	brcc	.+44     	; 0x4bec <ramDyskZapiszBlokDoPliku+0xb0>
    {                                             //Nie uda si, teraz zapiszemy cay klastr do koca
      memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do koca aktualnego klastra
    4bc0:	b6 01       	movw	r22, r12
    4bc2:	a8 01       	movw	r20, r16
    4bc4:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
      znaki +=dlBloku;                      
    4bc8:	c0 0e       	add	r12, r16
    4bca:	d1 1e       	adc	r13, r17
      fd->IndLo = 0;                              //Mniej znaczcy bajt odczytu wskazuje na pocztek nowego klastra. Kolejna iteracja go utworzy
    4bcc:	1a 82       	std	Y+2, r1	; 0x02
      doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtw jaka pozosta do zapisujemy
    4bce:	e0 1a       	sub	r14, r16
    4bd0:	f1 0a       	sbc	r15, r17
      *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych danych
    4bd2:	f4 01       	movw	r30, r8
    4bd4:	80 81       	ld	r24, Z
    4bd6:	91 81       	ldd	r25, Z+1	; 0x01
    4bd8:	80 0f       	add	r24, r16
    4bda:	91 1f       	adc	r25, r17
    4bdc:	91 83       	std	Z+1, r25	; 0x01
    4bde:	80 83       	st	Z, r24
      fd->IndHi++;                                //Ustawienie bardziej znaczcego bajtu indeksu. Oznacza to przejcie do kolejnego klastra
    4be0:	8b 81       	ldd	r24, Y+3	; 0x03
    4be2:	8f 5f       	subi	r24, 0xFF	; 255
    4be4:	8b 83       	std	Y+3, r24	; 0x03
    4be6:	00 e0       	ldi	r16, 0x00	; 0
    4be8:	11 e0       	ldi	r17, 0x01	; 1
    4bea:	1a c0       	rjmp	.+52     	; 0x4c20 <ramDyskZapiszBlokDoPliku+0xe4>
      dlBloku = 256;                              //Do nastpnego klastra moemy zapisa do 256 bajtw
    }
    else                                          //Jest to ostatni zapis. Cae dane zostan skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
    4bec:	b6 01       	movw	r22, r12
    4bee:	a7 01       	movw	r20, r14
    4bf0:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualni mneij znaczcy bajt).
    4bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf6:	8e 0d       	add	r24, r14
    4bf8:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
    4bfa:	f4 01       	movw	r30, r8
    4bfc:	80 81       	ld	r24, Z
    4bfe:	91 81       	ldd	r25, Z+1	; 0x01
    4c00:	8e 0d       	add	r24, r14
    4c02:	9f 1d       	adc	r25, r15
    4c04:	91 83       	std	Z+1, r25	; 0x01
    4c06:	80 83       	st	Z, r24
      doZapisu  =  0;                             //Rwnie dobrze mona tutaj wstawi break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskanika w odpowiednie miejsce klastra.
    4c08:	8b 2d       	mov	r24, r11
    4c0a:	90 e0       	ldi	r25, 0x00	; 0
    4c0c:	80 58       	subi	r24, 0x80	; 128
    4c0e:	9f 4f       	sbci	r25, 0xFF	; 255
    4c10:	98 2f       	mov	r25, r24
    4c12:	88 27       	eor	r24, r24
    4c14:	2a 81       	ldd	r18, Y+2	; 0x02
    4c16:	82 0f       	add	r24, r18
    4c18:	91 1d       	adc	r25, r1
    4c1a:	99 83       	std	Y+1, r25	; 0x01
    4c1c:	88 83       	st	Y, r24
    4c1e:	04 c0       	rjmp	.+8      	; 0x4c28 <ramDyskZapiszBlokDoPliku+0xec>
  
  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtw, jak da si zapisa w aktualnym klastrze
  uint16_t doZapisu = *dlugosc;
  *dlugosc = 0;                                   //Jak do td jeszcze nic nie zapisano
  uint8_t tmpKlaster = 0;
  while (doZapisu > 0)
    4c20:	e1 14       	cp	r14, r1
    4c22:	f1 04       	cpc	r15, r1
    4c24:	09 f0       	breq	.+2      	; 0x4c28 <ramDyskZapiszBlokDoPliku+0xec>
    4c26:	ae cf       	rjmp	.-164    	; 0x4b84 <ramDyskZapiszBlokDoPliku+0x48>
  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi == fd->IndHi)
    4c28:	ec 81       	ldd	r30, Y+4	; 0x04
    4c2a:	fd 81       	ldd	r31, Y+5	; 0x05
    4c2c:	92 81       	ldd	r25, Z+2	; 0x02
    4c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c30:	98 17       	cp	r25, r24
    4c32:	29 f4       	brne	.+10     	; 0x4c3e <ramDyskZapiszBlokDoPliku+0x102>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    4c34:	9a 81       	ldd	r25, Y+2	; 0x02
    4c36:	81 81       	ldd	r24, Z+1	; 0x01
    4c38:	89 17       	cp	r24, r25
    4c3a:	08 f4       	brcc	.+2      	; 0x4c3e <ramDyskZapiszBlokDoPliku+0x102>
      fd->wpis->rozmiarLo = fd->IndLo;
    4c3c:	91 83       	std	Z+1, r25	; 0x01
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    4c3e:	ec 81       	ldd	r30, Y+4	; 0x04
    4c40:	fd 81       	ldd	r31, Y+5	; 0x05
    4c42:	92 81       	ldd	r25, Z+2	; 0x02
    4c44:	8b 81       	ldd	r24, Y+3	; 0x03
    4c46:	98 17       	cp	r25, r24
    4c48:	30 f4       	brcc	.+12     	; 0x4c56 <ramDyskZapiszBlokDoPliku+0x11a>
  {
      fd->wpis->rozmiarLo = fd->IndLo;    
    4c4a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c4c:	81 83       	std	Z+1, r24	; 0x01
      fd->wpis->rozmiarHi = fd->IndHi;    
    4c4e:	ec 81       	ldd	r30, Y+4	; 0x04
    4c50:	fd 81       	ldd	r31, Y+5	; 0x05
    4c52:	8b 81       	ldd	r24, Y+3	; 0x03
    4c54:	82 83       	std	Z+2, r24	; 0x02
    4c56:	80 e0       	ldi	r24, 0x00	; 0
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskanika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}
    4c58:	df 91       	pop	r29
    4c5a:	cf 91       	pop	r28
    4c5c:	1f 91       	pop	r17
    4c5e:	0f 91       	pop	r16
    4c60:	ff 90       	pop	r15
    4c62:	ef 90       	pop	r14
    4c64:	df 90       	pop	r13
    4c66:	cf 90       	pop	r12
    4c68:	bf 90       	pop	r11
    4c6a:	9f 90       	pop	r9
    4c6c:	8f 90       	pop	r8
    4c6e:	08 95       	ret

00004c70 <znajdzPlik>:
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
{
    4c70:	af 92       	push	r10
    4c72:	bf 92       	push	r11
    4c74:	cf 92       	push	r12
    4c76:	df 92       	push	r13
    4c78:	ef 92       	push	r14
    4c7a:	ff 92       	push	r15
    4c7c:	0f 93       	push	r16
    4c7e:	1f 93       	push	r17
    4c80:	cf 93       	push	r28
    4c82:	df 93       	push	r29
    4c84:	6c 01       	movw	r12, r24
  uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znakw
    4c86:	fc 01       	movw	r30, r24
    4c88:	01 90       	ld	r0, Z+
    4c8a:	00 20       	and	r0, r0
    4c8c:	e9 f7       	brne	.-6      	; 0x4c88 <znajdzPlik+0x18>
    4c8e:	31 97       	sbiw	r30, 0x01	; 1
    4c90:	fe 2e       	mov	r15, r30
    4c92:	f8 1a       	sub	r15, r24
    4c94:	88 e0       	ldi	r24, 0x08	; 8
    4c96:	8f 15       	cp	r24, r15
    4c98:	10 f4       	brcc	.+4      	; 0x4c9e <znajdzPlik+0x2e>
    4c9a:	a8 e0       	ldi	r26, 0x08	; 8
    4c9c:	fa 2e       	mov	r15, r26
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  
  if (nazwa[dlNazwy-1] == 0)
    4c9e:	f6 01       	movw	r30, r12
    4ca0:	ef 0d       	add	r30, r15
    4ca2:	f1 1d       	adc	r31, r1
    4ca4:	31 97       	sbiw	r30, 0x01	; 1
    4ca6:	80 81       	ld	r24, Z
    4ca8:	88 23       	and	r24, r24
    4caa:	09 f4       	brne	.+2      	; 0x4cae <znajdzPlik+0x3e>
    dlNazwy--;                            //Nie sprawdzamy czy string koczy si /0
    4cac:	fa 94       	dec	r15
    4cae:	f6 01       	movw	r30, r12
    4cb0:	91 e0       	ldi	r25, 0x01	; 1
    4cb2:	07 c0       	rjmp	.+14     	; 0x4cc2 <znajdzPlik+0x52>
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    4cb4:	81 81       	ldd	r24, Z+1	; 0x01
    4cb6:	31 96       	adiw	r30, 0x01	; 1
    4cb8:	80 32       	cpi	r24, 0x20	; 32
    4cba:	11 f4       	brne	.+4      	; 0x4cc0 <znajdzPlik+0x50>
    4cbc:	f9 2e       	mov	r15, r25
    4cbe:	05 c0       	rjmp	.+10     	; 0x4cca <znajdzPlik+0x5a>
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    4cc0:	9f 5f       	subi	r25, 0xFF	; 255
    4cc2:	9f 15       	cp	r25, r15
    4cc4:	b8 f3       	brcs	.-18     	; 0x4cb4 <znajdzPlik+0x44>
    {
      dlNazwy = temp;
      break; 
    }
  }
  if (dlNazwy == 0)
    4cc6:	ff 20       	and	r15, r15
    4cc8:	29 f1       	breq	.+74     	; 0x4d14 <znajdzPlik+0xa4>
    4cca:	ee 24       	eor	r14, r14
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagwka pliku w klastrze
    4ccc:	0e 2d       	mov	r16, r14
    4cce:	10 e0       	ldi	r17, 0x00	; 0
    4cd0:	00 58       	subi	r16, 0x80	; 128
    4cd2:	1f 4f       	sbci	r17, 0xFF	; 255
    4cd4:	d0 2f       	mov	r29, r16
    4cd6:	cc 27       	eor	r28, r28
    4cd8:	00 58       	subi	r16, 0x80	; 128
    4cda:	10 40       	sbci	r17, 0x00	; 0
    for (temp=0; temp <16; temp++)
    4cdc:	e0 ef       	ldi	r30, 0xF0	; 240
    4cde:	ae 2e       	mov	r10, r30
    4ce0:	b1 2c       	mov	r11, r1
    4ce2:	ac 0e       	add	r10, r28
    4ce4:	bd 1e       	adc	r11, r29
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    4ce6:	be 01       	movw	r22, r28
    4ce8:	6c 5f       	subi	r22, 0xFC	; 252
    4cea:	7f 4f       	sbci	r23, 0xFF	; 255
    4cec:	c6 01       	movw	r24, r12
    4cee:	4f 2d       	mov	r20, r15
    4cf0:	50 e0       	ldi	r21, 0x00	; 0
    4cf2:	0e 94 7c 74 	call	0xe8f8	; 0xe8f8 <strncmp>
    4cf6:	00 97       	sbiw	r24, 0x00	; 0
    4cf8:	79 f0       	breq	.+30     	; 0x4d18 <znajdzPlik+0xa8>
    return NULL;
  
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagwka pliku w klastrze
    for (temp=0; temp <16; temp++)
    4cfa:	ca 15       	cp	r28, r10
    4cfc:	db 05       	cpc	r29, r11
    4cfe:	11 f0       	breq	.+4      	; 0x4d04 <znajdzPlik+0x94>
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejcie do kolejnego wpisu (w tym samym klastrze)
    4d00:	60 96       	adiw	r28, 0x10	; 16
    4d02:	f1 cf       	rjmp	.-30     	; 0x4ce6 <znajdzPlik+0x76>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    4d04:	0e 51       	subi	r16, 0x1E	; 30
    4d06:	11 4f       	sbci	r17, 0xF1	; 241
    4d08:	f8 01       	movw	r30, r16
    4d0a:	80 81       	ld	r24, Z
  }
  while (tempKlaster2 != tempKlaster);
    4d0c:	e8 16       	cp	r14, r24
    4d0e:	11 f0       	breq	.+4      	; 0x4d14 <znajdzPlik+0xa4>
    4d10:	e8 2e       	mov	r14, r24
    4d12:	dc cf       	rjmp	.-72     	; 0x4ccc <znajdzPlik+0x5c>
    4d14:	c0 e0       	ldi	r28, 0x00	; 0
    4d16:	d0 e0       	ldi	r29, 0x00	; 0
  return NULL;
}
    4d18:	ce 01       	movw	r24, r28
    4d1a:	df 91       	pop	r29
    4d1c:	cf 91       	pop	r28
    4d1e:	1f 91       	pop	r17
    4d20:	0f 91       	pop	r16
    4d22:	ff 90       	pop	r15
    4d24:	ef 90       	pop	r14
    4d26:	df 90       	pop	r13
    4d28:	cf 90       	pop	r12
    4d2a:	bf 90       	pop	r11
    4d2c:	af 90       	pop	r10
    4d2e:	08 95       	ret

00004d30 <ramDyskUsunPlik>:
  }
  return wynik;
}

uint8_t ramDyskUsunPlik(const char *nazwa)
{
    4d30:	cf 93       	push	r28
    4d32:	df 93       	push	r29
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    4d34:	0e 94 38 26 	call	0x4c70	; 0x4c70 <znajdzPlik>
    4d38:	ec 01       	movw	r28, r24
    4d3a:	00 97       	sbiw	r24, 0x00	; 0
    4d3c:	11 f4       	brne	.+4      	; 0x4d42 <ramDyskUsunPlik+0x12>
    4d3e:	81 e0       	ldi	r24, 0x01	; 1
    4d40:	1c c0       	rjmp	.+56     	; 0x4d7a <ramDyskUsunPlik+0x4a>
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    4d42:	8b 81       	ldd	r24, Y+3	; 0x03
    4d44:	88 23       	and	r24, r24
    4d46:	81 f0       	breq	.+32     	; 0x4d68 <ramDyskUsunPlik+0x38>
    4d48:	82 e0       	ldi	r24, 0x02	; 2
    4d4a:	17 c0       	rjmp	.+46     	; 0x4d7a <ramDyskUsunPlik+0x4a>
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Ju na samym pocztku moe si okaza, e plik nie mia klastrw
  {
    usuwanyKlaster = plik->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatniego klastra
    4d4c:	a8 2f       	mov	r26, r24
    4d4e:	b0 e0       	ldi	r27, 0x00	; 0
    4d50:	fd 01       	movw	r30, r26
    4d52:	ee 51       	subi	r30, 0x1E	; 30
    4d54:	f1 4f       	sbci	r31, 0xF1	; 241
    4d56:	e0 81       	ld	r30, Z
    4d58:	e8 17       	cp	r30, r24
    4d5a:	11 f4       	brne	.+4      	; 0x4d60 <ramDyskUsunPlik+0x30>
      plik->pierwszyKlaster = 0;                           //Ok mona ju zakoczy usuwanie pliku
    4d5c:	18 82       	st	Y, r1
    4d5e:	01 c0       	rjmp	.+2      	; 0x4d62 <ramDyskUsunPlik+0x32>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejcie do nastpnego klastra
    4d60:	e8 83       	st	Y, r30
    klastry[usuwanyKlaster] = 0;                           //Usunicie klastra
    4d62:	ae 51       	subi	r26, 0x1E	; 30
    4d64:	b1 4f       	sbci	r27, 0xF1	; 241
    4d66:	1c 92       	st	X, r1
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
  
  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Ju na samym pocztku moe si okaza, e plik nie mia klastrw
    4d68:	88 81       	ld	r24, Y
    4d6a:	88 23       	and	r24, r24
    4d6c:	79 f7       	brne	.-34     	; 0x4d4c <ramDyskUsunPlik+0x1c>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejcie do nastpnego klastra
    klastry[usuwanyKlaster] = 0;                           //Usunicie klastra
  }
  
  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik moe by tam wpisany
    4d6e:	80 e1       	ldi	r24, 0x10	; 16
    4d70:	fe 01       	movw	r30, r28
    4d72:	11 92       	st	Z+, r1
    4d74:	8a 95       	dec	r24
    4d76:	e9 f7       	brne	.-6      	; 0x4d72 <ramDyskUsunPlik+0x42>
    4d78:	80 e0       	ldi	r24, 0x00	; 0
//relokacjaTablicyWpisow()
  return 0;
}
    4d7a:	df 91       	pop	r29
    4d7c:	cf 91       	pop	r28
    4d7e:	08 95       	ret

00004d80 <ramDyskOtworzPlik>:
  }
  return 1;
}

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
    4d80:	cf 93       	push	r28
    4d82:	df 93       	push	r29
    4d84:	eb 01       	movw	r28, r22
  uint8_t wynik = 1;
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    4d86:	0e 94 38 26 	call	0x4c70	; 0x4c70 <znajdzPlik>
    4d8a:	fc 01       	movw	r30, r24
    4d8c:	00 97       	sbiw	r24, 0x00	; 0
    4d8e:	11 f4       	brne	.+4      	; 0x4d94 <ramDyskOtworzPlik+0x14>
    4d90:	81 e0       	ldi	r24, 0x01	; 1
    4d92:	0b c0       	rjmp	.+22     	; 0x4daa <ramDyskOtworzPlik+0x2a>
  {
    memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
    4d94:	83 e0       	ldi	r24, 0x03	; 3
    4d96:	de 01       	movw	r26, r28
    4d98:	1d 92       	st	X+, r1
    4d9a:	8a 95       	dec	r24
    4d9c:	e9 f7       	brne	.-6      	; 0x4d98 <ramDyskOtworzPlik+0x18>
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskanika na wpis pliku do katalogu gwnego
    4d9e:	fd 83       	std	Y+5, r31	; 0x05
    4da0:	ec 83       	std	Y+4, r30	; 0x04
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwar plikw
    4da2:	83 81       	ldd	r24, Z+3	; 0x03
    4da4:	8f 5f       	subi	r24, 0xFF	; 255
    4da6:	83 83       	std	Z+3, r24	; 0x03
    4da8:	80 e0       	ldi	r24, 0x00	; 0
    wynik = 0;
  }
  return wynik;
}
    4daa:	df 91       	pop	r29
    4dac:	cf 91       	pop	r28
    4dae:	08 95       	ret

00004db0 <ramDyskOtworzPlikStdIo>:
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);  
}

uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags)
{
    4db0:	ff 92       	push	r15
    4db2:	0f 93       	push	r16
    4db4:	1f 93       	push	r17
    4db6:	cf 93       	push	r28
    4db8:	df 93       	push	r29
    4dba:	8b 01       	movw	r16, r22
    4dbc:	ea 01       	movw	r28, r20
    4dbe:	f2 2e       	mov	r15, r18
  uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
    4dc0:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ramDyskOtworzPlik>
    4dc4:	28 2f       	mov	r18, r24
  if (wynik != 0)
    4dc6:	88 23       	and	r24, r24
    4dc8:	59 f4       	brne	.+22     	; 0x4de0 <ramDyskOtworzPlikStdIo+0x30>
    return wynik;
  
  fdev_setup_stream(stream, putSTD, getSTD, flags);
    4dca:	88 e8       	ldi	r24, 0x88	; 136
    4dcc:	94 e2       	ldi	r25, 0x24	; 36
    4dce:	99 87       	std	Y+9, r25	; 0x09
    4dd0:	88 87       	std	Y+8, r24	; 0x08
    4dd2:	8c e1       	ldi	r24, 0x1C	; 28
    4dd4:	94 e2       	ldi	r25, 0x24	; 36
    4dd6:	9b 87       	std	Y+11, r25	; 0x0b
    4dd8:	8a 87       	std	Y+10, r24	; 0x0a
    4dda:	fb 82       	std	Y+3, r15	; 0x03
  fdev_set_udata(stream, fd);
    4ddc:	1d 87       	std	Y+13, r17	; 0x0d
    4dde:	0c 87       	std	Y+12, r16	; 0x0c
  return 0;
}
    4de0:	82 2f       	mov	r24, r18
    4de2:	df 91       	pop	r29
    4de4:	cf 91       	pop	r28
    4de6:	1f 91       	pop	r17
    4de8:	0f 91       	pop	r16
    4dea:	ff 90       	pop	r15
    4dec:	08 95       	ret

00004dee <ramDyskUtworzPlik>:
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrw (wszystkie s puste)
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablic plikw
}
uint8_t ramDyskUtworzPlik(const char *nazwa)
{                                        //Nowo utworzony plik nie zajmuje adnego klastra
    4dee:	ff 92       	push	r15
    4df0:	0f 93       	push	r16
    4df2:	1f 93       	push	r17
    4df4:	cf 93       	push	r28
    4df6:	df 93       	push	r29
    4df8:	08 2f       	mov	r16, r24
    4dfa:	f9 2e       	mov	r15, r25
  uint8_t dlNazwy = strlen(nazwa);
    4dfc:	a8 2f       	mov	r26, r24
    4dfe:	b9 2f       	mov	r27, r25
    4e00:	fd 01       	movw	r30, r26
    4e02:	01 90       	ld	r0, Z+
    4e04:	00 20       	and	r0, r0
    4e06:	e9 f7       	brne	.-6      	; 0x4e02 <ramDyskUtworzPlik+0x14>
    4e08:	31 97       	sbiw	r30, 0x01	; 1
    4e0a:	1e 2f       	mov	r17, r30
    4e0c:	18 1b       	sub	r17, r24
    4e0e:	19 30       	cpi	r17, 0x09	; 9
    4e10:	08 f0       	brcs	.+2      	; 0x4e14 <ramDyskUtworzPlik+0x26>
    4e12:	18 e0       	ldi	r17, 0x08	; 8
    4e14:	80 2f       	mov	r24, r16
    4e16:	9f 2d       	mov	r25, r15
    4e18:	9c 01       	movw	r18, r24
    4e1a:	f9 01       	movw	r30, r18
    4e1c:	90 e0       	ldi	r25, 0x00	; 0
    4e1e:	06 c0       	rjmp	.+12     	; 0x4e2c <ramDyskUtworzPlik+0x3e>
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
  {  if (nazwa[i] == ' ')
    4e20:	81 91       	ld	r24, Z+
    4e22:	80 32       	cpi	r24, 0x20	; 32
    4e24:	11 f4       	brne	.+4      	; 0x4e2a <ramDyskUtworzPlik+0x3c>
    4e26:	19 2f       	mov	r17, r25
    4e28:	03 c0       	rjmp	.+6      	; 0x4e30 <ramDyskUtworzPlik+0x42>
  uint8_t dlNazwy = strlen(nazwa);
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;
  
  for (i=0; i<dlNazwy; i++)
    4e2a:	9f 5f       	subi	r25, 0xFF	; 255
    4e2c:	91 17       	cp	r25, r17
    4e2e:	c0 f3       	brcs	.-16     	; 0x4e20 <ramDyskUtworzPlik+0x32>
     {
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    4e30:	11 23       	and	r17, r17
    4e32:	09 f4       	brne	.+2      	; 0x4e36 <ramDyskUtworzPlik+0x48>
    4e34:	3f c0       	rjmp	.+126    	; 0x4eb4 <ramDyskUtworzPlik+0xc6>
    return 0;
  
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    4e36:	80 2f       	mov	r24, r16
    4e38:	9f 2d       	mov	r25, r15
    4e3a:	0e 94 38 26 	call	0x4c70	; 0x4c70 <znajdzPlik>
    4e3e:	89 2b       	or	r24, r25
    4e40:	c9 f5       	brne	.+114    	; 0x4eb4 <ramDyskUtworzPlik+0xc6>
    4e42:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t temp;
  uint8_t tempKlaster=0;                                 //Przeszukiwanie gwnego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie gwnego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagwka pliku w klastrze
    4e44:	29 2f       	mov	r18, r25
    4e46:	30 e0       	ldi	r19, 0x00	; 0
    4e48:	20 58       	subi	r18, 0x80	; 128
    4e4a:	3f 4f       	sbci	r19, 0xFF	; 255
    4e4c:	d2 2f       	mov	r29, r18
    4e4e:	cc 27       	eor	r28, r28
    4e50:	20 58       	subi	r18, 0x80	; 128
    4e52:	30 40       	sbci	r19, 0x00	; 0
    for (temp=0; temp <16; temp++)
    4e54:	ae 01       	movw	r20, r28
    4e56:	40 51       	subi	r20, 0x10	; 16
    4e58:	5f 4f       	sbci	r21, 0xFF	; 255
    {
      if (plik->nazwa[0] == 0)
    4e5a:	8c 81       	ldd	r24, Y+4	; 0x04
    4e5c:	88 23       	and	r24, r24
    4e5e:	b9 f0       	breq	.+46     	; 0x4e8e <ramDyskUtworzPlik+0xa0>
  uint8_t tempKlaster=0;                                 //Przeszukiwanie gwnego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie gwnego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagwka pliku w klastrze
    for (temp=0; temp <16; temp++)
    4e60:	c4 17       	cp	r28, r20
    4e62:	d5 07       	cpc	r29, r21
    4e64:	11 f0       	breq	.+4      	; 0x4e6a <ramDyskUtworzPlik+0x7c>
    {
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejcie do kolejnego wpisu (w tym samym klastrze)
    4e66:	60 96       	adiw	r28, 0x10	; 16
    4e68:	f8 cf       	rjmp	.-16     	; 0x4e5a <ramDyskUtworzPlik+0x6c>
    }   
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    4e6a:	e9 01       	movw	r28, r18
    4e6c:	ce 51       	subi	r28, 0x1E	; 30
    4e6e:	d1 4f       	sbci	r29, 0xF1	; 241
    4e70:	88 81       	ld	r24, Y
  }
  while (tempKlaster2 != tempKlaster);
    4e72:	98 17       	cp	r25, r24
    4e74:	11 f0       	breq	.+4      	; 0x4e7a <ramDyskUtworzPlik+0x8c>
    4e76:	98 2f       	mov	r25, r24
    4e78:	e5 cf       	rjmp	.-54     	; 0x4e44 <ramDyskUtworzPlik+0x56>
  
  klastry[tempKlaster] = znajdzWolnyKlaster();
    4e7a:	0e 94 b0 22 	call	0x4560	; 0x4560 <znajdzWolnyKlaster>
    4e7e:	88 83       	st	Y, r24
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    4e80:	88 23       	and	r24, r24
    4e82:	d1 f0       	breq	.+52     	; 0x4eb8 <ramDyskUtworzPlik+0xca>
    plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
    4e84:	90 e0       	ldi	r25, 0x00	; 0
    4e86:	80 58       	subi	r24, 0x80	; 128
    4e88:	9f 4f       	sbci	r25, 0xFF	; 255
    4e8a:	d8 2f       	mov	r29, r24
    4e8c:	cc 27       	eor	r28, r28
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
  }
  
  if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagwka) po skasowanym pliku
    4e8e:	20 97       	sbiw	r28, 0x00	; 0
    4e90:	99 f0       	breq	.+38     	; 0x4eb8 <ramDyskUtworzPlik+0xca>
  {
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na warto 0)
    4e92:	8c e0       	ldi	r24, 0x0C	; 12
    4e94:	fe 01       	movw	r30, r28
    4e96:	11 92       	st	Z+, r1
    4e98:	8a 95       	dec	r24
    4e9a:	e9 f7       	brne	.-6      	; 0x4e96 <ramDyskUtworzPlik+0xa8>
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    4e9c:	ce 01       	movw	r24, r28
    4e9e:	04 96       	adiw	r24, 0x04	; 4
    4ea0:	60 2f       	mov	r22, r16
    4ea2:	7f 2d       	mov	r23, r15
    4ea4:	41 2f       	mov	r20, r17
    4ea6:	50 e0       	ldi	r21, 0x00	; 0
    4ea8:	0e 94 8a 74 	call	0xe914	; 0xe914 <strncpy>
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    4eac:	1c 86       	std	Y+12, r1	; 0x0c
    4eae:	1d 86       	std	Y+13, r1	; 0x0d
    4eb0:	1e 86       	std	Y+14, r1	; 0x0e
    4eb2:	1f 86       	std	Y+15, r1	; 0x0f
    return 0;                            
    4eb4:	80 e0       	ldi	r24, 0x00	; 0
    4eb6:	01 c0       	rjmp	.+2      	; 0x4eba <ramDyskUtworzPlik+0xcc>
    4eb8:	81 e0       	ldi	r24, 0x01	; 1
  }
  return 1;
}
    4eba:	df 91       	pop	r29
    4ebc:	cf 91       	pop	r28
    4ebe:	1f 91       	pop	r17
    4ec0:	0f 91       	pop	r16
    4ec2:	ff 90       	pop	r15
    4ec4:	08 95       	ret

00004ec6 <cmdLineGetLastArgIdx>:

uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
    4ec6:	dc 01       	movw	r26, r24
    4ec8:	12 96       	adiw	r26, 0x02	; 2
    4eca:	ed 91       	ld	r30, X+
    4ecc:	fc 91       	ld	r31, X
    4ece:	13 97       	sbiw	r26, 0x03	; 3
    4ed0:	80 e0       	ldi	r24, 0x00	; 0
    4ed2:	21 e0       	ldi	r18, 0x01	; 1
    4ed4:	09 c0       	rjmp	.+18     	; 0x4ee8 <cmdLineGetLastArgIdx+0x22>
  while(*str != 0)
  {
    if (*str == ' ')
    4ed6:	90 32       	cpi	r25, 0x20	; 32
    4ed8:	11 f0       	breq	.+4      	; 0x4ede <cmdLineGetLastArgIdx+0x18>
    4eda:	20 e0       	ldi	r18, 0x00	; 0
    4edc:	04 c0       	rjmp	.+8      	; 0x4ee6 <cmdLineGetLastArgIdx+0x20>
    {
      if (lastWhite == 0)
    4ede:	22 23       	and	r18, r18
    4ee0:	09 f4       	brne	.+2      	; 0x4ee4 <cmdLineGetLastArgIdx+0x1e>
        result++;
    4ee2:	8f 5f       	subi	r24, 0xFF	; 255
    4ee4:	21 e0       	ldi	r18, 0x01	; 1
      lastWhite = 1;
    }
    else
      lastWhite = 0;
    str++;
    4ee6:	31 96       	adiw	r30, 0x01	; 1
uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    4ee8:	90 81       	ld	r25, Z
    4eea:	99 23       	and	r25, r25
    4eec:	a1 f7       	brne	.-24     	; 0x4ed6 <cmdLineGetLastArgIdx+0x10>
    else
      lastWhite = 0;
    str++;
  }
  return result;
}
    4eee:	08 95       	ret

00004ef0 <cmdlineGetArgStr>:

char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
{
    4ef0:	58 2f       	mov	r21, r24
    4ef2:	fb 01       	movw	r30, r22
  // find the offset of argument number [argnum]
  uint8_t idx=0;
  uint8_t arg;
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4ef4:	22 81       	ldd	r18, Z+2	; 0x02
    4ef6:	33 81       	ldd	r19, Z+3	; 0x03
    4ef8:	90 e0       	ldi	r25, 0x00	; 0
    4efa:	01 c0       	rjmp	.+2      	; 0x4efe <cmdlineGetArgStr+0xe>
    4efc:	9f 5f       	subi	r25, 0xFF	; 255
    4efe:	f9 01       	movw	r30, r18
    4f00:	e9 0f       	add	r30, r25
    4f02:	f1 1d       	adc	r31, r1
    4f04:	80 81       	ld	r24, Z
    4f06:	80 32       	cpi	r24, 0x20	; 32
    4f08:	c9 f3       	breq	.-14     	; 0x4efc <cmdlineGetArgStr+0xc>
    4f0a:	40 e0       	ldi	r20, 0x00	; 0
    4f0c:	12 c0       	rjmp	.+36     	; 0x4f32 <cmdlineGetArgStr+0x42>
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
  {
    // find the next whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    4f0e:	9f 5f       	subi	r25, 0xFF	; 255
    4f10:	f9 01       	movw	r30, r18
    4f12:	e9 0f       	add	r30, r25
    4f14:	f1 1d       	adc	r31, r1
    4f16:	e0 81       	ld	r30, Z
    4f18:	ee 23       	and	r30, r30
    4f1a:	21 f0       	breq	.+8      	; 0x4f24 <cmdlineGetArgStr+0x34>
    4f1c:	e0 32       	cpi	r30, 0x20	; 32
    4f1e:	b9 f7       	brne	.-18     	; 0x4f0e <cmdlineGetArgStr+0x1e>
    4f20:	01 c0       	rjmp	.+2      	; 0x4f24 <cmdlineGetArgStr+0x34>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    4f22:	9f 5f       	subi	r25, 0xFF	; 255
    4f24:	f9 01       	movw	r30, r18
    4f26:	e9 0f       	add	r30, r25
    4f28:	f1 1d       	adc	r31, r1
    4f2a:	80 81       	ld	r24, Z
    4f2c:	80 32       	cpi	r24, 0x20	; 32
    4f2e:	c9 f3       	breq	.-14     	; 0x4f22 <cmdlineGetArgStr+0x32>
  
  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  
  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    4f30:	4f 5f       	subi	r20, 0xFF	; 255
    4f32:	45 17       	cp	r20, r21
    4f34:	68 f3       	brcs	.-38     	; 0x4f10 <cmdlineGetArgStr+0x20>
    4f36:	29 0f       	add	r18, r25
    4f38:	31 1d       	adc	r19, r1
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  }
  // we are at the requested argument or the end of the buffer
  return &state->CmdlineExcBuffer[idx];
}
    4f3a:	c9 01       	movw	r24, r18
    4f3c:	08 95       	ret

00004f3e <cmdPrintHelp>:
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
}

void cmdPrintHelp(cmdState_t *state)
{
    4f3e:	6f 92       	push	r6
    4f40:	7f 92       	push	r7
    4f42:	8f 92       	push	r8
    4f44:	9f 92       	push	r9
    4f46:	bf 92       	push	r11
    4f48:	cf 92       	push	r12
    4f4a:	df 92       	push	r13
    4f4c:	ef 92       	push	r14
    4f4e:	ff 92       	push	r15
    4f50:	0f 93       	push	r16
    4f52:	1f 93       	push	r17
    4f54:	df 93       	push	r29
    4f56:	cf 93       	push	r28
    4f58:	00 d0       	rcall	.+0      	; 0x4f5a <cmdPrintHelp+0x1c>
    4f5a:	00 d0       	rcall	.+0      	; 0x4f5c <cmdPrintHelp+0x1e>
    4f5c:	00 d0       	rcall	.+0      	; 0x4f5e <cmdPrintHelp+0x20>
    4f5e:	cd b7       	in	r28, 0x3d	; 61
    4f60:	de b7       	in	r29, 0x3e	; 62
    4f62:	7c 01       	movw	r14, r24
  command_t  tmp;
  const command_t *tmpPtr = state->cmdList;
    4f64:	fc 01       	movw	r30, r24
    4f66:	c1 a0       	ldd	r12, Z+33	; 0x21
    4f68:	d2 a0       	ldd	r13, Z+34	; 0x22
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4f6a:	8e 01       	movw	r16, r28
    4f6c:	0f 5f       	subi	r16, 0xFF	; 255
    4f6e:	1f 4f       	sbci	r17, 0xFF	; 255
    4f70:	c8 01       	movw	r24, r16
    4f72:	b6 01       	movw	r22, r12
    4f74:	46 e0       	ldi	r20, 0x06	; 6
    4f76:	50 e0       	ldi	r21, 0x00	; 0
    4f78:	0e 94 36 74 	call	0xe86c	; 0xe86c <memcpy_P>
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4f7c:	9b e9       	ldi	r25, 0x9B	; 155
    4f7e:	69 2e       	mov	r6, r25
    4f80:	9b e0       	ldi	r25, 0x0B	; 11
    4f82:	79 2e       	mov	r7, r25
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4f84:	88 e9       	ldi	r24, 0x98	; 152
    4f86:	88 2e       	mov	r8, r24
    4f88:	8b e0       	ldi	r24, 0x0B	; 11
    4f8a:	98 2e       	mov	r9, r24

    tmpPtr++;
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4f8c:	b0 2e       	mov	r11, r16
    4f8e:	01 2f       	mov	r16, r17
  const command_t *tmpPtr = state->cmdList;
  
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    4f90:	00 d0       	rcall	.+0      	; 0x4f92 <cmdPrintHelp+0x54>
    4f92:	00 d0       	rcall	.+0      	; 0x4f94 <cmdPrintHelp+0x56>
    4f94:	f7 01       	movw	r30, r14
    4f96:	82 8d       	ldd	r24, Z+26	; 0x1a
    4f98:	93 8d       	ldd	r25, Z+27	; 0x1b
    4f9a:	ed b7       	in	r30, 0x3d	; 61
    4f9c:	fe b7       	in	r31, 0x3e	; 62
    4f9e:	92 83       	std	Z+2, r25	; 0x02
    4fa0:	81 83       	std	Z+1, r24	; 0x01
    4fa2:	89 81       	ldd	r24, Y+1	; 0x01
    4fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    4fa6:	94 83       	std	Z+4, r25	; 0x04
    4fa8:	83 83       	std	Z+3, r24	; 0x03
    4faa:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\t"));
    4fae:	f7 01       	movw	r30, r14
    4fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    4fb2:	93 8d       	ldd	r25, Z+27	; 0x1b
    4fb4:	ed b7       	in	r30, 0x3d	; 61
    4fb6:	fe b7       	in	r31, 0x3e	; 62
    4fb8:	92 83       	std	Z+2, r25	; 0x02
    4fba:	81 83       	std	Z+1, r24	; 0x01
    4fbc:	74 82       	std	Z+4, r7	; 0x04
    4fbe:	63 82       	std	Z+3, r6	; 0x03
    4fc0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    4fc4:	f7 01       	movw	r30, r14
    4fc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    4fc8:	93 8d       	ldd	r25, Z+27	; 0x1b
    4fca:	ed b7       	in	r30, 0x3d	; 61
    4fcc:	fe b7       	in	r31, 0x3e	; 62
    4fce:	92 83       	std	Z+2, r25	; 0x02
    4fd0:	81 83       	std	Z+1, r24	; 0x01
    4fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    4fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    4fd6:	94 83       	std	Z+4, r25	; 0x04
    4fd8:	83 83       	std	Z+3, r24	; 0x03
    4fda:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4fde:	f7 01       	movw	r30, r14
    4fe0:	82 8d       	ldd	r24, Z+26	; 0x1a
    4fe2:	93 8d       	ldd	r25, Z+27	; 0x1b
    4fe4:	ed b7       	in	r30, 0x3d	; 61
    4fe6:	fe b7       	in	r31, 0x3e	; 62
    4fe8:	92 83       	std	Z+2, r25	; 0x02
    4fea:	81 83       	std	Z+1, r24	; 0x01
    4fec:	94 82       	std	Z+4, r9	; 0x04
    4fee:	83 82       	std	Z+3, r8	; 0x03
    4ff0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>

    tmpPtr++;
    4ff4:	86 e0       	ldi	r24, 0x06	; 6
    4ff6:	90 e0       	ldi	r25, 0x00	; 0
    4ff8:	c8 0e       	add	r12, r24
    4ffa:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4ffc:	0f 90       	pop	r0
    4ffe:	0f 90       	pop	r0
    5000:	0f 90       	pop	r0
    5002:	0f 90       	pop	r0
    5004:	8b 2d       	mov	r24, r11
    5006:	90 2f       	mov	r25, r16
    5008:	b6 01       	movw	r22, r12
    500a:	46 e0       	ldi	r20, 0x06	; 6
    500c:	50 e0       	ldi	r21, 0x00	; 0
    500e:	0e 94 36 74 	call	0xe86c	; 0xe86c <memcpy_P>
  }
  while (tmp.commandFun != NULL);
    5012:	8d 81       	ldd	r24, Y+5	; 0x05
    5014:	9e 81       	ldd	r25, Y+6	; 0x06
    5016:	89 2b       	or	r24, r25
    5018:	09 f0       	breq	.+2      	; 0x501c <cmdPrintHelp+0xde>
    501a:	ba cf       	rjmp	.-140    	; 0x4f90 <cmdPrintHelp+0x52>
}
    501c:	26 96       	adiw	r28, 0x06	; 6
    501e:	0f b6       	in	r0, 0x3f	; 63
    5020:	f8 94       	cli
    5022:	de bf       	out	0x3e, r29	; 62
    5024:	0f be       	out	0x3f, r0	; 63
    5026:	cd bf       	out	0x3d, r28	; 61
    5028:	cf 91       	pop	r28
    502a:	df 91       	pop	r29
    502c:	1f 91       	pop	r17
    502e:	0f 91       	pop	r16
    5030:	ff 90       	pop	r15
    5032:	ef 90       	pop	r14
    5034:	df 90       	pop	r13
    5036:	cf 90       	pop	r12
    5038:	bf 90       	pop	r11
    503a:	9f 90       	pop	r9
    503c:	8f 90       	pop	r8
    503e:	7f 90       	pop	r7
    5040:	6f 90       	pop	r6
    5042:	08 95       	ret

00005044 <cmdlineGetArgHex>:
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
}

// return argument [argnum] interpreted as a hex integer
long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
{
    5044:	df 93       	push	r29
    5046:	cf 93       	push	r28
    5048:	00 d0       	rcall	.+0      	; 0x504a <cmdlineGetArgHex+0x6>
    504a:	cd b7       	in	r28, 0x3d	; 61
    504c:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
    504e:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    5052:	be 01       	movw	r22, r28
    5054:	6f 5f       	subi	r22, 0xFF	; 255
    5056:	7f 4f       	sbci	r23, 0xFF	; 255
    5058:	40 e1       	ldi	r20, 0x10	; 16
    505a:	50 e0       	ldi	r21, 0x00	; 0
    505c:	0e 94 ff 72 	call	0xe5fe	; 0xe5fe <strtol>
}
    5060:	0f 90       	pop	r0
    5062:	0f 90       	pop	r0
    5064:	cf 91       	pop	r28
    5066:	df 91       	pop	r29
    5068:	08 95       	ret

0000506a <cmdlineGetArgInt>:
  return &state->CmdlineExcBuffer[idx];
}

// return argument [argnum] interpreted as a decimal integer
long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
{
    506a:	df 93       	push	r29
    506c:	cf 93       	push	r28
    506e:	00 d0       	rcall	.+0      	; 0x5070 <cmdlineGetArgInt+0x6>
    5070:	cd b7       	in	r28, 0x3d	; 61
    5072:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
    5074:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <cmdlineGetArgStr>
    5078:	be 01       	movw	r22, r28
    507a:	6f 5f       	subi	r22, 0xFF	; 255
    507c:	7f 4f       	sbci	r23, 0xFF	; 255
    507e:	4a e0       	ldi	r20, 0x0A	; 10
    5080:	50 e0       	ldi	r21, 0x00	; 0
    5082:	0e 94 ff 72 	call	0xe5fe	; 0xe5fe <strtol>
}
    5086:	0f 90       	pop	r0
    5088:	0f 90       	pop	r0
    508a:	cf 91       	pop	r28
    508c:	df 91       	pop	r29
    508e:	08 95       	ret

00005090 <cmdlinePrintPrompt>:
    cmdlinePrintPrompt(state);                  // output new prompt
  }
}

void cmdlinePrintPrompt(cmdState_t *state)
{
    5090:	0f 93       	push	r16
    5092:	1f 93       	push	r17
    5094:	cf 93       	push	r28
    5096:	df 93       	push	r29
    5098:	8c 01       	movw	r16, r24
  const char* ptr;
  // print a new command prompt
  switch (state->cliMode)
    509a:	fc 01       	movw	r30, r24
    509c:	80 a1       	ldd	r24, Z+32	; 0x20
    509e:	81 30       	cpi	r24, 0x01	; 1
    50a0:	19 f0       	breq	.+6      	; 0x50a8 <cmdlinePrintPrompt+0x18>
    50a2:	82 30       	cpi	r24, 0x02	; 2
    50a4:	21 f4       	brne	.+8      	; 0x50ae <cmdlinePrintPrompt+0x1e>
    50a6:	06 c0       	rjmp	.+12     	; 0x50b4 <cmdlinePrintPrompt+0x24>
    50a8:	cb e7       	ldi	r28, 0x7B	; 123
    50aa:	db e0       	ldi	r29, 0x0B	; 11
    50ac:	0f c0       	rjmp	.+30     	; 0x50cc <cmdlinePrintPrompt+0x3c>
    50ae:	c4 e7       	ldi	r28, 0x74	; 116
    50b0:	db e0       	ldi	r29, 0x0B	; 11
    50b2:	0c c0       	rjmp	.+24     	; 0x50cc <cmdlinePrintPrompt+0x3c>
    50b4:	c2 e8       	ldi	r28, 0x82	; 130
    50b6:	db e0       	ldi	r29, 0x0B	; 11
    50b8:	09 c0       	rjmp	.+18     	; 0x50cc <cmdlinePrintPrompt+0x3c>
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    50ba:	21 96       	adiw	r28, 0x01	; 1
    50bc:	f9 01       	movw	r30, r18
    50be:	84 91       	lpm	r24, Z+
    50c0:	f8 01       	movw	r30, r16
    50c2:	62 8d       	ldd	r22, Z+26	; 0x1a
    50c4:	73 8d       	ldd	r23, Z+27	; 0x1b
    50c6:	90 e0       	ldi	r25, 0x00	; 0
    50c8:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    50cc:	9e 01       	movw	r18, r28
      break;
    default:
      ptr = CmdlinePromptNormal;
      break;      
  }
  while(pgm_read_byte(ptr))
    50ce:	fe 01       	movw	r30, r28
    50d0:	84 91       	lpm	r24, Z+
    50d2:	88 23       	and	r24, r24
    50d4:	91 f7       	brne	.-28     	; 0x50ba <cmdlinePrintPrompt+0x2a>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
}
    50d6:	df 91       	pop	r29
    50d8:	cf 91       	pop	r28
    50da:	1f 91       	pop	r17
    50dc:	0f 91       	pop	r16
    50de:	08 95       	ret

000050e0 <cmdlineMainLoop>:
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
}

void cmdlineMainLoop(cmdState_t *state)
{
    50e0:	cf 93       	push	r28
    50e2:	df 93       	push	r29
    50e4:	ec 01       	movw	r28, r24
  cliExRes_t result;
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
    50e6:	8f 89       	ldd	r24, Y+23	; 0x17
    50e8:	98 8d       	ldd	r25, Y+24	; 0x18
    50ea:	89 2b       	or	r24, r25
    50ec:	09 f4       	brne	.+2      	; 0x50f0 <cmdlineMainLoop+0x10>
    50ee:	86 c0       	rjmp	.+268    	; 0x51fc <cmdlineMainLoop+0x11c>
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    50f0:	ce 01       	movw	r24, r28
    50f2:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <cmdLineGetLastArgIdx>
    50f6:	89 8f       	std	Y+25, r24	; 0x19
    result = state->CmdlineExecFunction(state); // run it
    50f8:	ef 89       	ldd	r30, Y+23	; 0x17
    50fa:	f8 8d       	ldd	r31, Y+24	; 0x18
    50fc:	ce 01       	movw	r24, r28
    50fe:	09 95       	icall
    
    switch(result)
    5100:	82 30       	cpi	r24, 0x02	; 2
    5102:	91 05       	cpc	r25, r1
    5104:	d1 f0       	breq	.+52     	; 0x513a <cmdlineMainLoop+0x5a>
    5106:	83 30       	cpi	r24, 0x03	; 3
    5108:	91 05       	cpc	r25, r1
    510a:	20 f4       	brcc	.+8      	; 0x5114 <cmdlineMainLoop+0x34>
    510c:	01 97       	sbiw	r24, 0x01	; 1
    510e:	09 f0       	breq	.+2      	; 0x5112 <cmdlineMainLoop+0x32>
    5110:	6c c0       	rjmp	.+216    	; 0x51ea <cmdlineMainLoop+0x10a>
    5112:	08 c0       	rjmp	.+16     	; 0x5124 <cmdlineMainLoop+0x44>
    5114:	84 30       	cpi	r24, 0x04	; 4
    5116:	91 05       	cpc	r25, r1
    5118:	09 f4       	brne	.+2      	; 0x511c <cmdlineMainLoop+0x3c>
    511a:	4a c0       	rjmp	.+148    	; 0x51b0 <cmdlineMainLoop+0xd0>
    511c:	05 97       	sbiw	r24, 0x05	; 5
    511e:	09 f0       	breq	.+2      	; 0x5122 <cmdlineMainLoop+0x42>
    5120:	64 c0       	rjmp	.+200    	; 0x51ea <cmdlineMainLoop+0x10a>
    5122:	51 c0       	rjmp	.+162    	; 0x51c6 <cmdlineMainLoop+0xe6>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
    5124:	00 d0       	rcall	.+0      	; 0x5126 <cmdlineMainLoop+0x46>
    5126:	00 d0       	rcall	.+0      	; 0x5128 <cmdlineMainLoop+0x48>
    5128:	8a 8d       	ldd	r24, Y+26	; 0x1a
    512a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    512c:	ed b7       	in	r30, 0x3d	; 61
    512e:	fe b7       	in	r31, 0x3e	; 62
    5130:	92 83       	std	Z+2, r25	; 0x02
    5132:	81 83       	std	Z+1, r24	; 0x01
    5134:	81 ee       	ldi	r24, 0xE1	; 225
    5136:	9b e0       	ldi	r25, 0x0B	; 11
    5138:	50 c0       	rjmp	.+160    	; 0x51da <cmdlineMainLoop+0xfa>
        break;
      case SYNTAX_ERROR:
        fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
    513a:	00 d0       	rcall	.+0      	; 0x513c <cmdlineMainLoop+0x5c>
    513c:	00 d0       	rcall	.+0      	; 0x513e <cmdlineMainLoop+0x5e>
    513e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5140:	9b 8d       	ldd	r25, Y+27	; 0x1b
    5142:	ed b7       	in	r30, 0x3d	; 61
    5144:	fe b7       	in	r31, 0x3e	; 62
    5146:	92 83       	std	Z+2, r25	; 0x02
    5148:	81 83       	std	Z+1, r24	; 0x01
    514a:	8d ec       	ldi	r24, 0xCD	; 205
    514c:	9b e0       	ldi	r25, 0x0B	; 11
    514e:	94 83       	std	Z+4, r25	; 0x04
    5150:	83 83       	std	Z+3, r24	; 0x03
    5152:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_str);
    5156:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5158:	9b 8d       	ldd	r25, Y+27	; 0x1b
    515a:	ed b7       	in	r30, 0x3d	; 61
    515c:	fe b7       	in	r31, 0x3e	; 62
    515e:	92 83       	std	Z+2, r25	; 0x02
    5160:	81 83       	std	Z+1, r24	; 0x01
    5162:	8b 89       	ldd	r24, Y+19	; 0x13
    5164:	9c 89       	ldd	r25, Y+20	; 0x14
    5166:	94 83       	std	Z+4, r25	; 0x04
    5168:	83 83       	std	Z+3, r24	; 0x03
    516a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR(" "));
    516e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5170:	9b 8d       	ldd	r25, Y+27	; 0x1b
    5172:	ed b7       	in	r30, 0x3d	; 61
    5174:	fe b7       	in	r31, 0x3e	; 62
    5176:	92 83       	std	Z+2, r25	; 0x02
    5178:	81 83       	std	Z+1, r24	; 0x01
    517a:	8b ec       	ldi	r24, 0xCB	; 203
    517c:	9b e0       	ldi	r25, 0x0B	; 11
    517e:	94 83       	std	Z+4, r25	; 0x04
    5180:	83 83       	std	Z+3, r24	; 0x03
    5182:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_help_str);
    5186:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5188:	9b 8d       	ldd	r25, Y+27	; 0x1b
    518a:	ed b7       	in	r30, 0x3d	; 61
    518c:	fe b7       	in	r31, 0x3e	; 62
    518e:	92 83       	std	Z+2, r25	; 0x02
    5190:	81 83       	std	Z+1, r24	; 0x01
    5192:	8d 89       	ldd	r24, Y+21	; 0x15
    5194:	9e 89       	ldd	r25, Y+22	; 0x16
    5196:	94 83       	std	Z+4, r25	; 0x04
    5198:	83 83       	std	Z+3, r24	; 0x03
    519a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR("\r\n"));
    519e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    51a0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    51a2:	ed b7       	in	r30, 0x3d	; 61
    51a4:	fe b7       	in	r31, 0x3e	; 62
    51a6:	92 83       	std	Z+2, r25	; 0x02
    51a8:	81 83       	std	Z+1, r24	; 0x01
    51aa:	88 ec       	ldi	r24, 0xC8	; 200
    51ac:	9b e0       	ldi	r25, 0x0B	; 11
    51ae:	15 c0       	rjmp	.+42     	; 0x51da <cmdlineMainLoop+0xfa>
        break;
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
    51b0:	00 d0       	rcall	.+0      	; 0x51b2 <cmdlineMainLoop+0xd2>
    51b2:	00 d0       	rcall	.+0      	; 0x51b4 <cmdlineMainLoop+0xd4>
    51b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    51b6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    51b8:	ed b7       	in	r30, 0x3d	; 61
    51ba:	fe b7       	in	r31, 0x3e	; 62
    51bc:	92 83       	std	Z+2, r25	; 0x02
    51be:	81 83       	std	Z+1, r24	; 0x01
    51c0:	85 eb       	ldi	r24, 0xB5	; 181
    51c2:	9b e0       	ldi	r25, 0x0B	; 11
    51c4:	0a c0       	rjmp	.+20     	; 0x51da <cmdlineMainLoop+0xfa>
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    51c6:	00 d0       	rcall	.+0      	; 0x51c8 <cmdlineMainLoop+0xe8>
    51c8:	00 d0       	rcall	.+0      	; 0x51ca <cmdlineMainLoop+0xea>
    51ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    51cc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    51ce:	ed b7       	in	r30, 0x3d	; 61
    51d0:	fe b7       	in	r31, 0x3e	; 62
    51d2:	92 83       	std	Z+2, r25	; 0x02
    51d4:	81 83       	std	Z+1, r24	; 0x01
    51d6:	8d e9       	ldi	r24, 0x9D	; 157
    51d8:	9b e0       	ldi	r25, 0x0B	; 11
    51da:	94 83       	std	Z+4, r25	; 0x04
    51dc:	83 83       	std	Z+3, r24	; 0x03
    51de:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    51e2:	0f 90       	pop	r0
    51e4:	0f 90       	pop	r0
    51e6:	0f 90       	pop	r0
    51e8:	0f 90       	pop	r0
        break;
      default:
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    51ea:	18 8e       	std	Y+24, r1	; 0x18
    51ec:	1f 8a       	std	Y+23, r1	; 0x17
    state->command_str         = NULL;
    51ee:	1c 8a       	std	Y+20, r1	; 0x14
    51f0:	1b 8a       	std	Y+19, r1	; 0x13
    state->command_help_str    = NULL;
    51f2:	1e 8a       	std	Y+22, r1	; 0x16
    51f4:	1d 8a       	std	Y+21, r1	; 0x15
    cmdlinePrintPrompt(state);                  // output new prompt
    51f6:	ce 01       	movw	r24, r28
    51f8:	0e 94 48 28 	call	0x5090	; 0x5090 <cmdlinePrintPrompt>
  }
}
    51fc:	df 91       	pop	r29
    51fe:	cf 91       	pop	r28
    5200:	08 95       	ret

00005202 <cmdlineRepaint>:
    state->CmdlineInputVT100State = 1;
  }
}

void cmdlineRepaint(cmdState_t *state, char *buf)
{
    5202:	ef 92       	push	r14
    5204:	ff 92       	push	r15
    5206:	1f 93       	push	r17
    5208:	cf 93       	push	r28
    520a:	df 93       	push	r29
    520c:	ec 01       	movw	r28, r24
    520e:	7b 01       	movw	r14, r22
  uint8_t i;

  // carriage return
  fputc(ASCII_CR         , state->myStdInOut);
    5210:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5212:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5214:	8d e0       	ldi	r24, 0x0D	; 13
    5216:	90 e0       	ldi	r25, 0x00	; 0
    5218:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
  // print fresh prompt
  cmdlinePrintPrompt(state);
    521c:	ce 01       	movw	r24, r28
    521e:	0e 94 48 28 	call	0x5090	; 0x5090 <cmdlinePrintPrompt>
  // print the new command line buffer
  i = state->CmdlineBufferLength;
    5222:	1d 85       	ldd	r17, Y+13	; 0x0d
    5224:	0b c0       	rjmp	.+22     	; 0x523c <cmdlineRepaint+0x3a>
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
    5226:	f7 01       	movw	r30, r14
    5228:	81 91       	ld	r24, Z+
    522a:	7f 01       	movw	r14, r30
    522c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    522e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5230:	99 27       	eor	r25, r25
    5232:	87 fd       	sbrc	r24, 7
    5234:	90 95       	com	r25
    5236:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    523a:	11 50       	subi	r17, 0x01	; 1
  fputc(ASCII_CR         , state->myStdInOut);
  // print fresh prompt
  cmdlinePrintPrompt(state);
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    523c:	11 23       	and	r17, r17
    523e:	99 f7       	brne	.-26     	; 0x5226 <cmdlineRepaint+0x24>
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    5240:	1c 85       	ldd	r17, Y+12	; 0x0c
    5242:	8d 85       	ldd	r24, Y+13	; 0x0d
    5244:	18 1b       	sub	r17, r24
    5246:	07 c0       	rjmp	.+14     	; 0x5256 <cmdlineRepaint+0x54>
  while (i--)
    fputc(' ', state->myStdInOut);
    5248:	6a 8d       	ldd	r22, Y+26	; 0x1a
    524a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    524c:	80 e2       	ldi	r24, 0x20	; 32
    524e:	90 e0       	ldi	r25, 0x00	; 0
    5250:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    5254:	11 50       	subi	r17, 0x01	; 1
  // print the new command line buffer
  i = state->CmdlineBufferLength;
  while(i--) 
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    5256:	11 23       	and	r17, r17
    5258:	b9 f7       	brne	.-18     	; 0x5248 <cmdlineRepaint+0x46>
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    525a:	1c 85       	ldd	r17, Y+12	; 0x0c
    525c:	8d 85       	ldd	r24, Y+13	; 0x0d
    525e:	18 1b       	sub	r17, r24
    5260:	07 c0       	rjmp	.+14     	; 0x5270 <cmdlineRepaint+0x6e>
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
    5262:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5264:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5266:	88 e0       	ldi	r24, 0x08	; 8
    5268:	90 e0       	ldi	r25, 0x00	; 0
    526a:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    526e:	11 50       	subi	r17, 0x01	; 1
    fputc(*buf++         , state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    fputc(' ', state->myStdInOut);
  i = state->bufferMaxSize - state->CmdlineBufferLength;
  while (i--)
    5270:	11 23       	and	r17, r17
    5272:	b9 f7       	brne	.-18     	; 0x5262 <cmdlineRepaint+0x60>
    fputc(ASCII_BS,  state->myStdInOut);
}
    5274:	df 91       	pop	r29
    5276:	cf 91       	pop	r28
    5278:	1f 91       	pop	r17
    527a:	ff 90       	pop	r15
    527c:	ef 90       	pop	r14
    527e:	08 95       	ret

00005280 <cmdlineDoHistory>:
  state->historyDepthIdx = 0;
  state->bufferHistoryState = COPIED;
}

void cmdlineDoHistory(enum cliHistoryAction action, cmdState_t *state)
{
    5280:	cf 93       	push	r28
    5282:	df 93       	push	r29
    5284:	eb 01       	movw	r28, r22
  uint8_t historyReadIdx;
  switch(action)
    5286:	81 30       	cpi	r24, 0x01	; 1
    5288:	f1 f0       	breq	.+60     	; 0x52c6 <cmdlineDoHistory+0x46>
    528a:	81 30       	cpi	r24, 0x01	; 1
    528c:	20 f0       	brcs	.+8      	; 0x5296 <cmdlineDoHistory+0x16>
    528e:	82 30       	cpi	r24, 0x02	; 2
    5290:	09 f0       	breq	.+2      	; 0x5294 <cmdlineDoHistory+0x14>
    5292:	5f c0       	rjmp	.+190    	; 0x5352 <cmdlineDoHistory+0xd2>
    5294:	3f c0       	rjmp	.+126    	; 0x5314 <cmdlineDoHistory+0x94>
  {
  case CMDLINE_HISTORY_SAVE:
    // copy CmdlineBuffer to history if not null string
    state->CmdlineBufferLength  = 0;
    5296:	1d 86       	std	Y+13, r1	; 0x0d
    state->CmdlineBufferEditPos = 0;     
    5298:	1e 86       	std	Y+14, r1	; 0x0e
    state->bufferHistoryState   = NOT_COPIED;
    529a:	19 8a       	std	Y+17, r1	; 0x11

    if( strlen(state->CmdlineBuffer) )
    529c:	e8 81       	ld	r30, Y
    529e:	f9 81       	ldd	r31, Y+1	; 0x01
    52a0:	80 81       	ld	r24, Z
    52a2:	88 23       	and	r24, r24
    52a4:	09 f4       	brne	.+2      	; 0x52a8 <cmdlineDoHistory+0x28>
    52a6:	55 c0       	rjmp	.+170    	; 0x5352 <cmdlineDoHistory+0xd2>
    {
      state->historyWrIdx++;
      state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
    52a8:	ef 85       	ldd	r30, Y+15	; 0x0f
    52aa:	ef 5f       	subi	r30, 0xFF	; 255
    52ac:	e3 70       	andi	r30, 0x03	; 3
    52ae:	ef 87       	std	Y+15, r30	; 0x0f
      
      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    52b0:	f0 e0       	ldi	r31, 0x00	; 0
    52b2:	32 96       	adiw	r30, 0x02	; 2
    52b4:	ee 0f       	add	r30, r30
    52b6:	ff 1f       	adc	r31, r31
    52b8:	e6 0f       	add	r30, r22
    52ba:	f7 1f       	adc	r31, r23
    52bc:	80 81       	ld	r24, Z
    52be:	91 81       	ldd	r25, Z+1	; 0x01
    52c0:	99 83       	std	Y+1, r25	; 0x01
    52c2:	88 83       	st	Y, r24
    52c4:	46 c0       	rjmp	.+140    	; 0x5352 <cmdlineDoHistory+0xd2>
    }
    break;
  case CMDLINE_HISTORY_PREV:
    if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
    52c6:	98 89       	ldd	r25, Y+16	; 0x10
    52c8:	93 30       	cpi	r25, 0x03	; 3
    52ca:	09 f4       	brne	.+2      	; 0x52ce <cmdlineDoHistory+0x4e>
    52cc:	42 c0       	rjmp	.+132    	; 0x5352 <cmdlineDoHistory+0xd2>
      break;                                               //We are on the end of the history list
    
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
    
    if (state->CmdlineHistory[historyReadIdx][0] == 0)
    52ce:	8f 85       	ldd	r24, Y+15	; 0x0f
    52d0:	81 50       	subi	r24, 0x01	; 1
    52d2:	89 1b       	sub	r24, r25
    52d4:	83 70       	andi	r24, 0x03	; 3
    52d6:	e8 2f       	mov	r30, r24
    52d8:	f0 e0       	ldi	r31, 0x00	; 0
    52da:	32 96       	adiw	r30, 0x02	; 2
    52dc:	ee 0f       	add	r30, r30
    52de:	ff 1f       	adc	r31, r31
    52e0:	e6 0f       	add	r30, r22
    52e2:	f7 1f       	adc	r31, r23
    52e4:	20 81       	ld	r18, Z
    52e6:	31 81       	ldd	r19, Z+1	; 0x01
    52e8:	d9 01       	movw	r26, r18
    52ea:	8c 91       	ld	r24, X
    52ec:	88 23       	and	r24, r24
    52ee:	89 f1       	breq	.+98     	; 0x5352 <cmdlineDoHistory+0xd2>
      break;
    
    state->historyDepthIdx++;
    state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
    52f0:	9f 5f       	subi	r25, 0xFF	; 255
    52f2:	93 70       	andi	r25, 0x03	; 3
    52f4:	98 8b       	std	Y+16, r25	; 0x10
    
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    52f6:	a0 81       	ld	r26, Z
    52f8:	b1 81       	ldd	r27, Z+1	; 0x01
    52fa:	fd 01       	movw	r30, r26
    52fc:	01 90       	ld	r0, Z+
    52fe:	00 20       	and	r0, r0
    5300:	e9 f7       	brne	.-6      	; 0x52fc <cmdlineDoHistory+0x7c>
    5302:	31 97       	sbiw	r30, 0x01	; 1
    5304:	ea 1b       	sub	r30, r26
    5306:	fb 0b       	sbc	r31, r27
    5308:	ed 87       	std	Y+13, r30	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    530a:	ee 87       	std	Y+14, r30	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    530c:	19 8a       	std	Y+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    530e:	cb 01       	movw	r24, r22
    5310:	b9 01       	movw	r22, r18
    5312:	1d c0       	rjmp	.+58     	; 0x534e <cmdlineDoHistory+0xce>
    
    break;
  case CMDLINE_HISTORY_NEXT:      
    if (state->historyDepthIdx == 0)
    5314:	88 89       	ldd	r24, Y+16	; 0x10
    5316:	88 23       	and	r24, r24
    5318:	e1 f0       	breq	.+56     	; 0x5352 <cmdlineDoHistory+0xd2>
      break;                                               //We are on the begining of the history list

    state->historyDepthIdx --;
    531a:	81 50       	subi	r24, 0x01	; 1
    531c:	88 8b       	std	Y+16, r24	; 0x10
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
   
    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    531e:	ef 85       	ldd	r30, Y+15	; 0x0f
    5320:	e8 1b       	sub	r30, r24
    5322:	e3 70       	andi	r30, 0x03	; 3
    5324:	f0 e0       	ldi	r31, 0x00	; 0
    5326:	32 96       	adiw	r30, 0x02	; 2
    5328:	ee 0f       	add	r30, r30
    532a:	ff 1f       	adc	r31, r31
    532c:	e6 0f       	add	r30, r22
    532e:	f7 1f       	adc	r31, r23
    5330:	80 81       	ld	r24, Z
    5332:	91 81       	ldd	r25, Z+1	; 0x01
    5334:	dc 01       	movw	r26, r24
    5336:	0d 90       	ld	r0, X+
    5338:	00 20       	and	r0, r0
    533a:	e9 f7       	brne	.-6      	; 0x5336 <cmdlineDoHistory+0xb6>
    533c:	11 97       	sbiw	r26, 0x01	; 1
    533e:	a8 1b       	sub	r26, r24
    5340:	b9 0b       	sbc	r27, r25
    5342:	ad 87       	std	Y+13, r26	; 0x0d
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    5344:	ae 87       	std	Y+14, r26	; 0x0e
    
    state->bufferHistoryState = NOT_COPIED;
    5346:	19 8a       	std	Y+17, r1	; 0x11

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    5348:	60 81       	ld	r22, Z
    534a:	71 81       	ldd	r23, Z+1	; 0x01
    534c:	ce 01       	movw	r24, r28
    534e:	0e 94 01 29 	call	0x5202	; 0x5202 <cmdlineRepaint>
    break;
  }
}
    5352:	df 91       	pop	r29
    5354:	cf 91       	pop	r28
    5356:	08 95       	ret

00005358 <cmdStateConfigure>:
static void cmdHistoryCopy            (cmdState_t *state);
static void cmdHistoryMove            (cmdState_t *state);


void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, const command_t *commands, enum cliModeState mode)
{
    5358:	8f 92       	push	r8
    535a:	9f 92       	push	r9
    535c:	bf 92       	push	r11
    535e:	cf 92       	push	r12
    5360:	df 92       	push	r13
    5362:	ef 92       	push	r14
    5364:	ff 92       	push	r15
    5366:	0f 93       	push	r16
    5368:	1f 93       	push	r17
    536a:	cf 93       	push	r28
    536c:	df 93       	push	r29
    536e:	ec 01       	movw	r28, r24
    5370:	f6 2e       	mov	r15, r22
    5372:	b7 2e       	mov	r11, r23
    5374:	6a 01       	movw	r12, r20
    5376:	49 01       	movw	r8, r18
  memset(state, 0, sizeof(cmdState_t));
    5378:	83 e2       	ldi	r24, 0x23	; 35
    537a:	fe 01       	movw	r30, r28
    537c:	11 92       	st	Z+, r1
    537e:	8a 95       	dec	r24
    5380:	e9 f7       	brne	.-6      	; 0x537c <cmdStateConfigure+0x24>
  memset(buffPtr, 0, bufferTotalSize);
    5382:	86 2f       	mov	r24, r22
    5384:	97 2f       	mov	r25, r23
    5386:	60 e0       	ldi	r22, 0x00	; 0
    5388:	70 e0       	ldi	r23, 0x00	; 0
    538a:	0e 94 63 74 	call	0xe8c6	; 0xe8c6 <memset>
    
  state->CmdlineBuffer = buffPtr;
    538e:	f8 82       	st	Y, r15
    5390:	b9 82       	std	Y+1, r11	; 0x01
  state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
    5392:	d6 94       	lsr	r13
    5394:	c7 94       	ror	r12
    5396:	d6 94       	lsr	r13
    5398:	c7 94       	ror	r12
    539a:	cc 86       	std	Y+12, r12	; 0x0c

  state->cliMode = mode;
    539c:	e8 a2       	std	Y+32, r14	; 0x20
  state->cmdList = commands;
    539e:	1a a3       	std	Y+34, r17	; 0x22
    53a0:	09 a3       	std	Y+33, r16	; 0x21
    53a2:	fe 01       	movw	r30, r28
    53a4:	2f 2d       	mov	r18, r15
    53a6:	3b 2d       	mov	r19, r11
    53a8:	c9 01       	movw	r24, r18
    53aa:	9c 01       	movw	r18, r24
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
    53ac:	ae 01       	movw	r20, r28
    53ae:	48 5f       	subi	r20, 0xF8	; 248
    53b0:	5f 4f       	sbci	r21, 0xFF	; 255
  {
    state->CmdlineHistory[i] = tmpPtr;
    53b2:	35 83       	std	Z+5, r19	; 0x05
    53b4:	24 83       	std	Z+4, r18	; 0x04
    tmpPtr += state->bufferMaxSize;
    53b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    53b8:	28 0f       	add	r18, r24
    53ba:	31 1d       	adc	r19, r1
    53bc:	32 96       	adiw	r30, 0x02	; 2
  state->cliMode = mode;
  state->cmdList = commands;
  
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
    53be:	e4 17       	cp	r30, r20
    53c0:	f5 07       	cpc	r31, r21
    53c2:	b9 f7       	brne	.-18     	; 0x53b2 <cmdStateConfigure+0x5a>
  {
    state->CmdlineHistory[i] = tmpPtr;
    tmpPtr += state->bufferMaxSize;
  }
  state->myStdInOut = stream;
    53c4:	9b 8e       	std	Y+27, r9	; 0x1b
    53c6:	8a 8e       	std	Y+26, r8	; 0x1a
}
    53c8:	df 91       	pop	r29
    53ca:	cf 91       	pop	r28
    53cc:	1f 91       	pop	r17
    53ce:	0f 91       	pop	r16
    53d0:	ff 90       	pop	r15
    53d2:	ef 90       	pop	r14
    53d4:	df 90       	pop	r13
    53d6:	cf 90       	pop	r12
    53d8:	bf 90       	pop	r11
    53da:	9f 90       	pop	r9
    53dc:	8f 90       	pop	r8
    53de:	08 95       	ret

000053e0 <cmdHistoryCopy>:
  while (i--)
    fputc(ASCII_BS,  state->myStdInOut);
}

void cmdHistoryCopy(cmdState_t *state)
{
    53e0:	0f 93       	push	r16
    53e2:	1f 93       	push	r17
    53e4:	cf 93       	push	r28
    53e6:	df 93       	push	r29
    53e8:	ec 01       	movw	r28, r24
  if (state->historyDepthIdx != 0)
    53ea:	88 89       	ldd	r24, Y+16	; 0x10
    53ec:	88 23       	and	r24, r24
    53ee:	c9 f0       	breq	.+50     	; 0x5422 <cmdHistoryCopy+0x42>
  {
    uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    53f0:	0f 85       	ldd	r16, Y+15	; 0x0f
    53f2:	08 1b       	sub	r16, r24
    53f4:	03 70       	andi	r16, 0x03	; 3
    memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
    53f6:	4c 85       	ldd	r20, Y+12	; 0x0c
    53f8:	88 81       	ld	r24, Y
    53fa:	99 81       	ldd	r25, Y+1	; 0x01
    53fc:	60 e0       	ldi	r22, 0x00	; 0
    53fe:	70 e0       	ldi	r23, 0x00	; 0
    5400:	50 e0       	ldi	r21, 0x00	; 0
    5402:	0e 94 63 74 	call	0xe8c6	; 0xe8c6 <memset>
    strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
    5406:	10 e0       	ldi	r17, 0x00	; 0
    5408:	0e 5f       	subi	r16, 0xFE	; 254
    540a:	1f 4f       	sbci	r17, 0xFF	; 255
    540c:	00 0f       	add	r16, r16
    540e:	11 1f       	adc	r17, r17
    5410:	0c 0f       	add	r16, r28
    5412:	1d 1f       	adc	r17, r29
    5414:	f8 01       	movw	r30, r16
    5416:	60 81       	ld	r22, Z
    5418:	71 81       	ldd	r23, Z+1	; 0x01
    541a:	88 81       	ld	r24, Y
    541c:	99 81       	ldd	r25, Y+1	; 0x01
    541e:	0e 94 75 74 	call	0xe8ea	; 0xe8ea <strcpy>
  }
  
  state->historyDepthIdx = 0;
    5422:	18 8a       	std	Y+16, r1	; 0x10
  state->bufferHistoryState = COPIED;
    5424:	81 e0       	ldi	r24, 0x01	; 1
    5426:	89 8b       	std	Y+17, r24	; 0x11
}
    5428:	df 91       	pop	r29
    542a:	cf 91       	pop	r28
    542c:	1f 91       	pop	r17
    542e:	0f 91       	pop	r16
    5430:	08 95       	ret

00005432 <cmdlineInputFunc>:
  // initialize executing function
  state->CmdlineExecFunction = 0;
}

void cmdlineInputFunc(char c, cmdState_t *state)
{
    5432:	9f 92       	push	r9
    5434:	af 92       	push	r10
    5436:	bf 92       	push	r11
    5438:	cf 92       	push	r12
    543a:	df 92       	push	r13
    543c:	ef 92       	push	r14
    543e:	ff 92       	push	r15
    5440:	0f 93       	push	r16
    5442:	1f 93       	push	r17
    5444:	df 93       	push	r29
    5446:	cf 93       	push	r28
    5448:	00 d0       	rcall	.+0      	; 0x544a <cmdlineInputFunc+0x18>
    544a:	00 d0       	rcall	.+0      	; 0x544c <cmdlineInputFunc+0x1a>
    544c:	00 d0       	rcall	.+0      	; 0x544e <cmdlineInputFunc+0x1c>
    544e:	cd b7       	in	r28, 0x3d	; 61
    5450:	de b7       	in	r29, 0x3e	; 62
    5452:	18 2f       	mov	r17, r24
    5454:	7b 01       	movw	r14, r22
  uint8_t i;
  // process the received character

  // VT100 handling
  // are we processing a VT100 command?
  if(state->CmdlineInputVT100State == 2)
    5456:	db 01       	movw	r26, r22
    5458:	52 96       	adiw	r26, 0x12	; 18
    545a:	8c 91       	ld	r24, X
    545c:	82 30       	cpi	r24, 0x02	; 2
    545e:	09 f0       	breq	.+2      	; 0x5462 <cmdlineInputFunc+0x30>
    5460:	5d c0       	rjmp	.+186    	; 0x551c <cmdlineInputFunc+0xea>
  {
    // we have already received ESC and [
    // now process the vt100 codeCmdlineExcBuffer
    switch(c)
    5462:	12 34       	cpi	r17, 0x42	; 66
    5464:	71 f0       	breq	.+28     	; 0x5482 <cmdlineInputFunc+0x50>
    5466:	13 34       	cpi	r17, 0x43	; 67
    5468:	24 f4       	brge	.+8      	; 0x5472 <cmdlineInputFunc+0x40>
    546a:	11 34       	cpi	r17, 0x41	; 65
    546c:	09 f0       	breq	.+2      	; 0x5470 <cmdlineInputFunc+0x3e>
    546e:	53 c0       	rjmp	.+166    	; 0x5516 <cmdlineInputFunc+0xe4>
    5470:	06 c0       	rjmp	.+12     	; 0x547e <cmdlineInputFunc+0x4c>
    5472:	13 34       	cpi	r17, 0x43	; 67
    5474:	59 f0       	breq	.+22     	; 0x548c <cmdlineInputFunc+0x5a>
    5476:	14 34       	cpi	r17, 0x44	; 68
    5478:	09 f0       	breq	.+2      	; 0x547c <cmdlineInputFunc+0x4a>
    547a:	4d c0       	rjmp	.+154    	; 0x5516 <cmdlineInputFunc+0xe4>
    547c:	31 c0       	rjmp	.+98     	; 0x54e0 <cmdlineInputFunc+0xae>
    {
    case VT100_ARROWUP:
      cmdlineDoHistory(CMDLINE_HISTORY_PREV, state);
    547e:	81 e0       	ldi	r24, 0x01	; 1
    5480:	01 c0       	rjmp	.+2      	; 0x5484 <cmdlineInputFunc+0x52>
      break;
    case VT100_ARROWDOWN:
      cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
    5482:	82 e0       	ldi	r24, 0x02	; 2
    5484:	b7 01       	movw	r22, r14
    5486:	0e 94 40 29 	call	0x5280	; 0x5280 <cmdlineDoHistory>
    548a:	45 c0       	rjmp	.+138    	; 0x5516 <cmdlineInputFunc+0xe4>
      break;
    case VT100_ARROWRIGHT:
      if (state->bufferHistoryState == NOT_COPIED)
    548c:	fb 01       	movw	r30, r22
    548e:	81 89       	ldd	r24, Z+17	; 0x11
    5490:	88 23       	and	r24, r24
    5492:	19 f4       	brne	.+6      	; 0x549a <cmdlineInputFunc+0x68>
        cmdHistoryCopy(state);
    5494:	cb 01       	movw	r24, r22
    5496:	0e 94 f0 29 	call	0x53e0	; 0x53e0 <cmdHistoryCopy>
      // if the edit position less than current string length
      if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
    549a:	d7 01       	movw	r26, r14
    549c:	1e 96       	adiw	r26, 0x0e	; 14
    549e:	9c 91       	ld	r25, X
    54a0:	1e 97       	sbiw	r26, 0x0e	; 14
    54a2:	1d 96       	adiw	r26, 0x0d	; 13
    54a4:	8c 91       	ld	r24, X
    54a6:	1d 97       	sbiw	r26, 0x0d	; 13
    54a8:	5a 96       	adiw	r26, 0x1a	; 26
    54aa:	6d 91       	ld	r22, X+
    54ac:	7c 91       	ld	r23, X
    54ae:	5b 97       	sbiw	r26, 0x1b	; 27
    54b0:	98 17       	cp	r25, r24
    54b2:	68 f5       	brcc	.+90     	; 0x550e <cmdlineInputFunc+0xdc>
      {
        // increment the edit position
        state->CmdlineBufferEditPos++;
    54b4:	9f 5f       	subi	r25, 0xFF	; 255
    54b6:	1e 96       	adiw	r26, 0x0e	; 14
    54b8:	9c 93       	st	X, r25
        // move cursor forward one space (no erase)
        fputc(ASCII_ESC        , state->myStdInOut);
    54ba:	8b e1       	ldi	r24, 0x1B	; 27
    54bc:	90 e0       	ldi	r25, 0x00	; 0
    54be:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
        fputc('['              , state->myStdInOut);
    54c2:	f7 01       	movw	r30, r14
    54c4:	62 8d       	ldd	r22, Z+26	; 0x1a
    54c6:	73 8d       	ldd	r23, Z+27	; 0x1b
    54c8:	8b e5       	ldi	r24, 0x5B	; 91
    54ca:	90 e0       	ldi	r25, 0x00	; 0
    54cc:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
        fputc(VT100_ARROWRIGHT , state->myStdInOut);
    54d0:	d7 01       	movw	r26, r14
    54d2:	5a 96       	adiw	r26, 0x1a	; 26
    54d4:	6d 91       	ld	r22, X+
    54d6:	7c 91       	ld	r23, X
    54d8:	5b 97       	sbiw	r26, 0x1b	; 27
    54da:	83 e4       	ldi	r24, 0x43	; 67
    54dc:	90 e0       	ldi	r25, 0x00	; 0
    54de:	19 c0       	rjmp	.+50     	; 0x5512 <cmdlineInputFunc+0xe0>
        fputc(ASCII_BEL        , state->myStdInOut);
      }
      break;
    case VT100_ARROWLEFT:
      // if the edit position is non-zero
      if (state->bufferHistoryState == NOT_COPIED)
    54e0:	fb 01       	movw	r30, r22
    54e2:	81 89       	ldd	r24, Z+17	; 0x11
    54e4:	88 23       	and	r24, r24
    54e6:	19 f4       	brne	.+6      	; 0x54ee <cmdlineInputFunc+0xbc>
        cmdHistoryCopy(state);
    54e8:	cb 01       	movw	r24, r22
    54ea:	0e 94 f0 29 	call	0x53e0	; 0x53e0 <cmdHistoryCopy>
      
      if(state->CmdlineBufferEditPos)
    54ee:	d7 01       	movw	r26, r14
    54f0:	1e 96       	adiw	r26, 0x0e	; 14
    54f2:	8c 91       	ld	r24, X
    54f4:	1e 97       	sbiw	r26, 0x0e	; 14
    54f6:	5a 96       	adiw	r26, 0x1a	; 26
    54f8:	6d 91       	ld	r22, X+
    54fa:	7c 91       	ld	r23, X
    54fc:	5b 97       	sbiw	r26, 0x1b	; 27
    54fe:	88 23       	and	r24, r24
    5500:	31 f0       	breq	.+12     	; 0x550e <cmdlineInputFunc+0xdc>
      {
        // decrement the edit position
        state->CmdlineBufferEditPos--;
    5502:	81 50       	subi	r24, 0x01	; 1
    5504:	1e 96       	adiw	r26, 0x0e	; 14
    5506:	8c 93       	st	X, r24
        // move cursor back one space (no erase)
        fputc(ASCII_BS         , state->myStdInOut);
    5508:	88 e0       	ldi	r24, 0x08	; 8
    550a:	90 e0       	ldi	r25, 0x00	; 0
    550c:	02 c0       	rjmp	.+4      	; 0x5512 <cmdlineInputFunc+0xe0>
      }
      else
      {
        // else, ring the bell
        fputc(ASCII_BEL        , state->myStdInOut);
    550e:	87 e0       	ldi	r24, 0x07	; 7
    5510:	90 e0       	ldi	r25, 0x00	; 0
    5512:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
      break;
    default:
      break;
    }
    // done, reset state
    state->CmdlineInputVT100State = 0;
    5516:	f7 01       	movw	r30, r14
    5518:	12 8a       	std	Z+18, r1	; 0x12
    551a:	1e c2       	rjmp	.+1084   	; 0x5958 <cmdlineInputFunc+0x526>
    return;
  }
  else if(state->CmdlineInputVT100State == 1)
    551c:	81 30       	cpi	r24, 0x01	; 1
    551e:	39 f4       	brne	.+14     	; 0x552e <cmdlineInputFunc+0xfc>
  {
    // we last received [ESC]
    if(c == '[')
    5520:	1b 35       	cpi	r17, 0x5B	; 91
    5522:	11 f4       	brne	.+4      	; 0x5528 <cmdlineInputFunc+0xf6>
    {
      state->CmdlineInputVT100State = 2;
    5524:	82 e0       	ldi	r24, 0x02	; 2
    5526:	15 c2       	rjmp	.+1066   	; 0x5952 <cmdlineInputFunc+0x520>
      return;
    }
    else
      state->CmdlineInputVT100State = 0;
    5528:	fb 01       	movw	r30, r22
    552a:	12 8a       	std	Z+18, r1	; 0x12
    552c:	03 c0       	rjmp	.+6      	; 0x5534 <cmdlineInputFunc+0x102>
  }
  else
  {
    // anything else, reset state
    state->CmdlineInputVT100State = 0;
    552e:	db 01       	movw	r26, r22
    5530:	52 96       	adiw	r26, 0x12	; 18
    5532:	1c 92       	st	X, r1
  }

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
    5534:	f7 01       	movw	r30, r14
    5536:	95 85       	ldd	r25, Z+13	; 0x0d
    5538:	84 85       	ldd	r24, Z+12	; 0x0c
    553a:	98 17       	cp	r25, r24
    553c:	89 f4       	brne	.+34     	; 0x5560 <cmdlineInputFunc+0x12e>
  {
    state->CmdlineBufferLength--;
    553e:	91 50       	subi	r25, 0x01	; 1
    5540:	95 87       	std	Z+13, r25	; 0x0d
    5542:	91 e0       	ldi	r25, 0x01	; 1
    5544:	09 c0       	rjmp	.+18     	; 0x5558 <cmdlineInputFunc+0x126>
    for (i=1; i < state->bufferMaxSize; i++)
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    5546:	d7 01       	movw	r26, r14
    5548:	ed 91       	ld	r30, X+
    554a:	fc 91       	ld	r31, X
    554c:	e9 0f       	add	r30, r25
    554e:	f1 1d       	adc	r31, r1
    5550:	80 81       	ld	r24, Z
    5552:	31 97       	sbiw	r30, 0x01	; 1
    5554:	80 83       	st	Z, r24
  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    for (i=1; i < state->bufferMaxSize; i++)
    5556:	9f 5f       	subi	r25, 0xFF	; 255
    5558:	f7 01       	movw	r30, r14
    555a:	84 85       	ldd	r24, Z+12	; 0x0c
    555c:	98 17       	cp	r25, r24
    555e:	98 f3       	brcs	.-26     	; 0x5546 <cmdlineInputFunc+0x114>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    }
  }
  
  if( (c >= 0x20) && (c < 0x7F) )
    5560:	81 2f       	mov	r24, r17
    5562:	80 52       	subi	r24, 0x20	; 32
    5564:	8f 35       	cpi	r24, 0x5F	; 95
    5566:	08 f0       	brcs	.+2      	; 0x556a <cmdlineInputFunc+0x138>
    5568:	5b c0       	rjmp	.+182    	; 0x5620 <cmdlineInputFunc+0x1ee>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    556a:	d7 01       	movw	r26, r14
    556c:	51 96       	adiw	r26, 0x11	; 17
    556e:	8c 91       	ld	r24, X
    5570:	88 23       	and	r24, r24
    5572:	19 f4       	brne	.+6      	; 0x557a <cmdlineInputFunc+0x148>
      cmdHistoryCopy(state);
    5574:	c7 01       	movw	r24, r14
    5576:	0e 94 f0 29 	call	0x53e0	; 0x53e0 <cmdHistoryCopy>
    // character is printable
    // is this a simple append
    if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    557a:	f7 01       	movw	r30, r14
    557c:	95 85       	ldd	r25, Z+13	; 0x0d
    557e:	86 85       	ldd	r24, Z+14	; 0x0e
    5580:	89 17       	cp	r24, r25
    5582:	e9 f4       	brne	.+58     	; 0x55be <cmdlineInputFunc+0x18c>
    {
      // echo character to the output
      fputc(c                , state->myStdInOut);
    5584:	62 8d       	ldd	r22, Z+26	; 0x1a
    5586:	73 8d       	ldd	r23, Z+27	; 0x1b
    5588:	81 2f       	mov	r24, r17
    558a:	99 27       	eor	r25, r25
    558c:	87 fd       	sbrc	r24, 7
    558e:	90 95       	com	r25
    5590:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
      // add it to the command line buffer
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    5594:	d7 01       	movw	r26, r14
    5596:	1e 96       	adiw	r26, 0x0e	; 14
    5598:	8c 91       	ld	r24, X
    559a:	1e 97       	sbiw	r26, 0x0e	; 14
    559c:	ed 91       	ld	r30, X+
    559e:	fc 91       	ld	r31, X
    55a0:	11 97       	sbiw	r26, 0x01	; 1
    55a2:	e8 0f       	add	r30, r24
    55a4:	f1 1d       	adc	r31, r1
    55a6:	10 83       	st	Z, r17
    55a8:	8f 5f       	subi	r24, 0xFF	; 255
    55aa:	1e 96       	adiw	r26, 0x0e	; 14
    55ac:	8c 93       	st	X, r24
    55ae:	1e 97       	sbiw	r26, 0x0e	; 14
      // update buffer length
      state->CmdlineBufferLength++;
    55b0:	1d 96       	adiw	r26, 0x0d	; 13
    55b2:	8c 91       	ld	r24, X
    55b4:	1d 97       	sbiw	r26, 0x0d	; 13
    55b6:	8f 5f       	subi	r24, 0xFF	; 255
    55b8:	1d 96       	adiw	r26, 0x0d	; 13
    55ba:	8c 93       	st	X, r24
    55bc:	cd c1       	rjmp	.+922    	; 0x5958 <cmdlineInputFunc+0x526>
    else
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
    55be:	9f 5f       	subi	r25, 0xFF	; 255
    55c0:	f7 01       	movw	r30, r14
    55c2:	95 87       	std	Z+13, r25	; 0x0d
    55c4:	06 c0       	rjmp	.+12     	; 0x55d2 <cmdlineInputFunc+0x1a0>
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
    55c6:	e9 0f       	add	r30, r25
    55c8:	f1 1d       	adc	r31, r1
    55ca:	82 91       	ld	r24, -Z
    55cc:	31 96       	adiw	r30, 0x01	; 1
    55ce:	80 83       	st	Z, r24
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    55d0:	91 50       	subi	r25, 0x01	; 1
    55d2:	d7 01       	movw	r26, r14
    55d4:	1e 96       	adiw	r26, 0x0e	; 14
    55d6:	8c 91       	ld	r24, X
    55d8:	1e 97       	sbiw	r26, 0x0e	; 14
    55da:	ed 91       	ld	r30, X+
    55dc:	fc 91       	ld	r31, X
    55de:	11 97       	sbiw	r26, 0x01	; 1
    55e0:	89 17       	cp	r24, r25
    55e2:	88 f3       	brcs	.-30     	; 0x55c6 <cmdlineInputFunc+0x194>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    55e4:	e8 0f       	add	r30, r24
    55e6:	f1 1d       	adc	r31, r1
    55e8:	10 83       	st	Z, r17
    55ea:	8f 5f       	subi	r24, 0xFF	; 255
    55ec:	1e 96       	adiw	r26, 0x0e	; 14
    55ee:	8c 93       	st	X, r24
    55f0:	1e 97       	sbiw	r26, 0x0e	; 14
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
    55f2:	6d 91       	ld	r22, X+
    55f4:	7c 91       	ld	r23, X
    55f6:	c7 01       	movw	r24, r14
    55f8:	0e 94 01 29 	call	0x5202	; 0x5202 <cmdlineRepaint>
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    55fc:	f7 01       	movw	r30, r14
    55fe:	16 85       	ldd	r17, Z+14	; 0x0e
    5600:	0a c0       	rjmp	.+20     	; 0x5616 <cmdlineInputFunc+0x1e4>
        fputc(ASCII_BS         , state->myStdInOut);
    5602:	d7 01       	movw	r26, r14
    5604:	5a 96       	adiw	r26, 0x1a	; 26
    5606:	6d 91       	ld	r22, X+
    5608:	7c 91       	ld	r23, X
    560a:	5b 97       	sbiw	r26, 0x1b	; 27
    560c:	88 e0       	ldi	r24, 0x08	; 8
    560e:	90 e0       	ldi	r25, 0x00	; 0
    5610:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    5614:	1f 5f       	subi	r17, 0xFF	; 255
    5616:	f7 01       	movw	r30, r14
    5618:	85 85       	ldd	r24, Z+13	; 0x0d
    561a:	18 17       	cp	r17, r24
    561c:	90 f3       	brcs	.-28     	; 0x5602 <cmdlineInputFunc+0x1d0>
    561e:	9c c1       	rjmp	.+824    	; 0x5958 <cmdlineInputFunc+0x526>
        fputc(ASCII_BS         , state->myStdInOut);
    }
  }
  // handle special characters
  else if(c == ASCII_CR)
    5620:	1d 30       	cpi	r17, 0x0D	; 13
    5622:	09 f0       	breq	.+2      	; 0x5626 <cmdlineInputFunc+0x1f4>
    5624:	25 c1       	rjmp	.+586    	; 0x5870 <cmdlineInputFunc+0x43e>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    5626:	d7 01       	movw	r26, r14
    5628:	51 96       	adiw	r26, 0x11	; 17
    562a:	8c 91       	ld	r24, X
    562c:	51 97       	sbiw	r26, 0x11	; 17
    562e:	88 23       	and	r24, r24
    5630:	09 f0       	breq	.+2      	; 0x5634 <cmdlineInputFunc+0x202>
    5632:	49 c0       	rjmp	.+146    	; 0x56c6 <cmdlineInputFunc+0x294>
  state->bufferHistoryState = COPIED;
}

void cmdHistoryMove(cmdState_t *state)
{
  uint8_t i=state->historyDepthIdx;
    5634:	50 96       	adiw	r26, 0x10	; 16
    5636:	2c 91       	ld	r18, X
    5638:	50 97       	sbiw	r26, 0x10	; 16

  if (state->historyDepthIdx != 0)
    563a:	22 23       	and	r18, r18
    563c:	79 f1       	breq	.+94     	; 0x569c <cmdlineInputFunc+0x26a>
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    563e:	1f 96       	adiw	r26, 0x0f	; 15
    5640:	ec 91       	ld	r30, X
    5642:	1f 97       	sbiw	r26, 0x0f	; 15
    5644:	f0 e0       	ldi	r31, 0x00	; 0
    5646:	e2 1b       	sub	r30, r18
    5648:	f1 09       	sbc	r31, r1
    564a:	e3 70       	andi	r30, 0x03	; 3
    564c:	f0 70       	andi	r31, 0x00	; 0
    564e:	32 96       	adiw	r30, 0x02	; 2
    5650:	ee 0f       	add	r30, r30
    5652:	ff 1f       	adc	r31, r31
    5654:	ee 0d       	add	r30, r14
    5656:	ff 1d       	adc	r31, r15
    5658:	80 81       	ld	r24, Z
    565a:	91 81       	ldd	r25, Z+1	; 0x01
    565c:	8d 93       	st	X+, r24
    565e:	9c 93       	st	X, r25
    5660:	1b c0       	rjmp	.+54     	; 0x5698 <cmdlineInputFunc+0x266>
    for ( ; i<CMD_STATE_HISTORY; i++)
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    5662:	d7 01       	movw	r26, r14
    5664:	1f 96       	adiw	r26, 0x0f	; 15
    5666:	ec 91       	ld	r30, X
    5668:	f0 e0       	ldi	r31, 0x00	; 0
    566a:	e2 1b       	sub	r30, r18
    566c:	f1 09       	sbc	r31, r1
    566e:	df 01       	movw	r26, r30
    5670:	a3 70       	andi	r26, 0x03	; 3
    5672:	b0 70       	andi	r27, 0x00	; 0
    5674:	12 96       	adiw	r26, 0x02	; 2
    5676:	aa 0f       	add	r26, r26
    5678:	bb 1f       	adc	r27, r27
    567a:	ae 0d       	add	r26, r14
    567c:	bf 1d       	adc	r27, r15
    567e:	31 97       	sbiw	r30, 0x01	; 1
    5680:	e3 70       	andi	r30, 0x03	; 3
    5682:	f0 70       	andi	r31, 0x00	; 0
    5684:	32 96       	adiw	r30, 0x02	; 2
    5686:	ee 0f       	add	r30, r30
    5688:	ff 1f       	adc	r31, r31
    568a:	ee 0d       	add	r30, r14
    568c:	ff 1d       	adc	r31, r15
    568e:	80 81       	ld	r24, Z
    5690:	91 81       	ldd	r25, Z+1	; 0x01
    5692:	8d 93       	st	X+, r24
    5694:	9c 93       	st	X, r25
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    for ( ; i<CMD_STATE_HISTORY; i++)
    5696:	2f 5f       	subi	r18, 0xFF	; 255
    5698:	24 30       	cpi	r18, 0x04	; 4
    569a:	18 f3       	brcs	.-58     	; 0x5662 <cmdlineInputFunc+0x230>
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    }
  }
  state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
    569c:	d7 01       	movw	r26, r14
    569e:	1f 96       	adiw	r26, 0x0f	; 15
    56a0:	ec 91       	ld	r30, X
    56a2:	1f 97       	sbiw	r26, 0x0f	; 15
    56a4:	f0 e0       	ldi	r31, 0x00	; 0
    56a6:	32 96       	adiw	r30, 0x02	; 2
    56a8:	ee 0f       	add	r30, r30
    56aa:	ff 1f       	adc	r31, r31
    56ac:	ee 0d       	add	r30, r14
    56ae:	ff 1d       	adc	r31, r15
    56b0:	8d 91       	ld	r24, X+
    56b2:	9c 91       	ld	r25, X
    56b4:	11 97       	sbiw	r26, 0x01	; 1
    56b6:	91 83       	std	Z+1, r25	; 0x01
    56b8:	80 83       	st	Z, r24

  state->historyDepthIdx = 0;
    56ba:	50 96       	adiw	r26, 0x10	; 16
    56bc:	1c 92       	st	X, r1
    56be:	50 97       	sbiw	r26, 0x10	; 16
  state->bufferHistoryState = COPIED;
    56c0:	81 e0       	ldi	r24, 0x01	; 1
    56c2:	51 96       	adiw	r26, 0x11	; 17
    56c4:	8c 93       	st	X, r24
    if (state->bufferHistoryState == NOT_COPIED)
      cmdHistoryMove(state);
    
    // user pressed [ENTER]
    // echo CR and LF to terminal
    fputc(ASCII_CR         , state->myStdInOut);
    56c6:	f7 01       	movw	r30, r14
    56c8:	62 8d       	ldd	r22, Z+26	; 0x1a
    56ca:	73 8d       	ldd	r23, Z+27	; 0x1b
    56cc:	8d e0       	ldi	r24, 0x0D	; 13
    56ce:	90 e0       	ldi	r25, 0x00	; 0
    56d0:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    fputc(ASCII_LF         , state->myStdInOut);
    56d4:	d7 01       	movw	r26, r14
    56d6:	5a 96       	adiw	r26, 0x1a	; 26
    56d8:	6d 91       	ld	r22, X+
    56da:	7c 91       	ld	r23, X
    56dc:	5b 97       	sbiw	r26, 0x1b	; 27
    56de:	8a e0       	ldi	r24, 0x0A	; 10
    56e0:	90 e0       	ldi	r25, 0x00	; 0
    56e2:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    // add null termination to command
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    56e6:	f7 01       	movw	r30, r14
    56e8:	85 85       	ldd	r24, Z+13	; 0x0d
    56ea:	01 90       	ld	r0, Z+
    56ec:	f0 81       	ld	r31, Z
    56ee:	e0 2d       	mov	r30, r0
    56f0:	e8 0f       	add	r30, r24
    56f2:	f1 1d       	adc	r31, r1
    56f4:	10 82       	st	Z, r1
    56f6:	8f 5f       	subi	r24, 0xFF	; 255
    56f8:	d7 01       	movw	r26, r14
    56fa:	1d 96       	adiw	r26, 0x0d	; 13
    56fc:	8c 93       	st	X, r24
    56fe:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos++;
    5700:	1e 96       	adiw	r26, 0x0e	; 14
    5702:	8c 91       	ld	r24, X
    5704:	1e 97       	sbiw	r26, 0x0e	; 14
    5706:	8f 5f       	subi	r24, 0xFF	; 255
    5708:	1e 96       	adiw	r26, 0x0e	; 14
    570a:	8c 93       	st	X, r24
    570c:	1e 97       	sbiw	r26, 0x0e	; 14
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments
    570e:	8d 91       	ld	r24, X+
    5710:	9c 91       	ld	r25, X
    5712:	11 97       	sbiw	r26, 0x01	; 1
    5714:	13 96       	adiw	r26, 0x03	; 3
    5716:	9c 93       	st	X, r25
    5718:	8e 93       	st	-X, r24
    571a:	12 97       	sbiw	r26, 0x02	; 2
    571c:	bb 24       	eor	r11, r11
    571e:	01 c0       	rjmp	.+2      	; 0x5722 <cmdlineInputFunc+0x2f0>

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length
    5720:	b3 94       	inc	r11
void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    5722:	fc 01       	movw	r30, r24
    5724:	eb 0d       	add	r30, r11
    5726:	f1 1d       	adc	r31, r1
    5728:	e0 81       	ld	r30, Z
    572a:	e0 32       	cpi	r30, 0x20	; 32
    572c:	11 f0       	breq	.+4      	; 0x5732 <cmdlineInputFunc+0x300>
    572e:	ee 23       	and	r30, r30
    5730:	b9 f7       	brne	.-18     	; 0x5720 <cmdlineInputFunc+0x2ee>
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length

  if(!i)                                                              // command was null or empty
    5732:	bb 20       	and	r11, r11
    5734:	09 f4       	brne	.+2      	; 0x5738 <cmdlineInputFunc+0x306>
    5736:	92 c0       	rjmp	.+292    	; 0x585c <cmdlineInputFunc+0x42a>
  {
    cmdlinePrintPrompt(state);                                        // output a new prompt
    return;
  }

  const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The list depends of the cli mode
    5738:	f7 01       	movw	r30, r14
    573a:	c1 a0       	ldd	r12, Z+33	; 0x21
    573c:	d2 a0       	ldd	r13, Z+34	; 0x22
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.
    573e:	8e 01       	movw	r16, r28
    5740:	0f 5f       	subi	r16, 0xFF	; 255
    5742:	1f 4f       	sbci	r17, 0xFF	; 255
    5744:	c8 01       	movw	r24, r16
    5746:	b6 01       	movw	r22, r12
    5748:	46 e0       	ldi	r20, 0x06	; 6
    574a:	50 e0       	ldi	r21, 0x00	; 0
    574c:	0e 94 36 74 	call	0xe86c	; 0xe86c <memcpy_P>
      state->command_help_str    = tmp.commandHelpStr;
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
      return;
    }
    tmpPtr++;                                                         // Next command
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    5750:	90 2e       	mov	r9, r16
    5752:	a1 2e       	mov	r10, r17
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.

  do                                                                  // search command list for match with entered command
  {
    if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command matched a command in the list
    5754:	09 81       	ldd	r16, Y+1	; 0x01
    5756:	1a 81       	ldd	r17, Y+2	; 0x02
    5758:	d7 01       	movw	r26, r14
    575a:	12 96       	adiw	r26, 0x02	; 2
    575c:	8d 91       	ld	r24, X+
    575e:	9c 91       	ld	r25, X
    5760:	13 97       	sbiw	r26, 0x03	; 3
    5762:	b8 01       	movw	r22, r16
    5764:	4b 2d       	mov	r20, r11
    5766:	50 e0       	ldi	r21, 0x00	; 0
    5768:	0e 94 3f 74 	call	0xe87e	; 0xe87e <strncmp_P>
    576c:	89 2b       	or	r24, r25
    576e:	81 f4       	brne	.+32     	; 0x5790 <cmdlineInputFunc+0x35e>
    {                                                                 // 
      state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
    5770:	8d 81       	ldd	r24, Y+5	; 0x05
    5772:	9e 81       	ldd	r25, Y+6	; 0x06
    5774:	f7 01       	movw	r30, r14
    5776:	90 8f       	std	Z+24, r25	; 0x18
    5778:	87 8b       	std	Z+23, r24	; 0x17
      state->command_str         = tmp.commandStr;
    577a:	14 8b       	std	Z+20, r17	; 0x14
    577c:	03 8b       	std	Z+19, r16	; 0x13
      state->command_help_str    = tmp.commandHelpStr;
    577e:	8b 81       	ldd	r24, Y+3	; 0x03
    5780:	9c 81       	ldd	r25, Y+4	; 0x04
    5782:	96 8b       	std	Z+22, r25	; 0x16
    5784:	85 8b       	std	Z+21, r24	; 0x15
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
    5786:	80 e0       	ldi	r24, 0x00	; 0
    5788:	b7 01       	movw	r22, r14
    578a:	0e 94 40 29 	call	0x5280	; 0x5280 <cmdlineDoHistory>
    578e:	69 c0       	rjmp	.+210    	; 0x5862 <cmdlineInputFunc+0x430>
      return;
    }
    tmpPtr++;                                                         // Next command
    5790:	86 e0       	ldi	r24, 0x06	; 6
    5792:	90 e0       	ldi	r25, 0x00	; 0
    5794:	c8 0e       	add	r12, r24
    5796:	d9 1e       	adc	r13, r25
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    5798:	89 2d       	mov	r24, r9
    579a:	9a 2d       	mov	r25, r10
    579c:	b6 01       	movw	r22, r12
    579e:	46 e0       	ldi	r20, 0x06	; 6
    57a0:	50 e0       	ldi	r21, 0x00	; 0
    57a2:	0e 94 36 74 	call	0xe86c	; 0xe86c <memcpy_P>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
    57a6:	89 81       	ldd	r24, Y+1	; 0x01
    57a8:	9a 81       	ldd	r25, Y+2	; 0x02
    57aa:	89 2b       	or	r24, r25
    57ac:	99 f6       	brne	.-90     	; 0x5754 <cmdlineInputFunc+0x322>
    57ae:	09 e8       	ldi	r16, 0x89	; 137
    57b0:	1b e0       	ldi	r17, 0x0B	; 11
    57b2:	0c c0       	rjmp	.+24     	; 0x57cc <cmdlineInputFunc+0x39a>

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    57b4:	0f 5f       	subi	r16, 0xFF	; 255
    57b6:	1f 4f       	sbci	r17, 0xFF	; 255
    57b8:	f9 01       	movw	r30, r18
    57ba:	84 91       	lpm	r24, Z+
    57bc:	d7 01       	movw	r26, r14
    57be:	5a 96       	adiw	r26, 0x1a	; 26
    57c0:	6d 91       	ld	r22, X+
    57c2:	7c 91       	ld	r23, X
    57c4:	5b 97       	sbiw	r26, 0x1b	; 27
    57c6:	90 e0       	ldi	r25, 0x00	; 0
    57c8:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    57cc:	98 01       	movw	r18, r16
  char * ptr;

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    57ce:	f8 01       	movw	r30, r16
    57d0:	84 91       	lpm	r24, Z+
    57d2:	88 23       	and	r24, r24
    57d4:	79 f7       	brne	.-34     	; 0x57b4 <cmdlineInputFunc+0x382>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
    57d6:	d7 01       	movw	r26, r14
    57d8:	0d 91       	ld	r16, X+
    57da:	1c 91       	ld	r17, X
    57dc:	0a c0       	rjmp	.+20     	; 0x57f2 <cmdlineInputFunc+0x3c0>
  while((*ptr) && (*ptr != ' '))
    fputc(*ptr++    , state->myStdInOut);
    57de:	0f 5f       	subi	r16, 0xFF	; 255
    57e0:	1f 4f       	sbci	r17, 0xFF	; 255
    57e2:	f7 01       	movw	r30, r14
    57e4:	62 8d       	ldd	r22, Z+26	; 0x1a
    57e6:	73 8d       	ldd	r23, Z+27	; 0x1b
    57e8:	99 27       	eor	r25, r25
    57ea:	87 fd       	sbrc	r24, 7
    57ec:	90 95       	com	r25
    57ee:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
  
  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    57f2:	d8 01       	movw	r26, r16
    57f4:	8c 91       	ld	r24, X
    57f6:	88 23       	and	r24, r24
    57f8:	11 f0       	breq	.+4      	; 0x57fe <cmdlineInputFunc+0x3cc>
    57fa:	80 32       	cpi	r24, 0x20	; 32
    57fc:	81 f7       	brne	.-32     	; 0x57de <cmdlineInputFunc+0x3ac>
    fputc(*ptr++    , state->myStdInOut);

  fputc(':'         , state->myStdInOut);
    57fe:	f7 01       	movw	r30, r14
    5800:	62 8d       	ldd	r22, Z+26	; 0x1a
    5802:	73 8d       	ldd	r23, Z+27	; 0x1b
    5804:	8a e3       	ldi	r24, 0x3A	; 58
    5806:	90 e0       	ldi	r25, 0x00	; 0
    5808:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
  fputc(' '         , state->myStdInOut);
    580c:	d7 01       	movw	r26, r14
    580e:	5a 96       	adiw	r26, 0x1a	; 26
    5810:	6d 91       	ld	r22, X+
    5812:	7c 91       	ld	r23, X
    5814:	5b 97       	sbiw	r26, 0x1b	; 27
    5816:	80 e2       	ldi	r24, 0x20	; 32
    5818:	90 e0       	ldi	r25, 0x00	; 0
    581a:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    581e:	03 e9       	ldi	r16, 0x93	; 147
    5820:	1b e0       	ldi	r17, 0x0B	; 11
    5822:	07 c0       	rjmp	.+14     	; 0x5832 <cmdlineInputFunc+0x400>

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    5824:	0f 5f       	subi	r16, 0xFF	; 255
    5826:	1f 4f       	sbci	r17, 0xFF	; 255
    5828:	f9 01       	movw	r30, r18
    582a:	84 91       	lpm	r24, Z+
    582c:	90 e0       	ldi	r25, 0x00	; 0
    582e:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    5832:	98 01       	movw	r18, r16
  fputc(' '         , state->myStdInOut);

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
  while(pgm_read_byte(ptr))
    5834:	f8 01       	movw	r30, r16
    5836:	84 91       	lpm	r24, Z+
    5838:	d7 01       	movw	r26, r14
    583a:	5a 96       	adiw	r26, 0x1a	; 26
    583c:	6d 91       	ld	r22, X+
    583e:	7c 91       	ld	r23, X
    5840:	5b 97       	sbiw	r26, 0x1b	; 27
    5842:	88 23       	and	r24, r24
    5844:	79 f7       	brne	.-34     	; 0x5824 <cmdlineInputFunc+0x3f2>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);

  fputc('\r'        , state->myStdInOut);
    5846:	8d e0       	ldi	r24, 0x0D	; 13
    5848:	90 e0       	ldi	r25, 0x00	; 0
    584a:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
  fputc('\n'        , state->myStdInOut);
    584e:	f7 01       	movw	r30, r14
    5850:	62 8d       	ldd	r22, Z+26	; 0x1a
    5852:	73 8d       	ldd	r23, Z+27	; 0x1b
    5854:	8a e0       	ldi	r24, 0x0A	; 10
    5856:	90 e0       	ldi	r25, 0x00	; 0
    5858:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
  
  // if we did not get a match
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
    585c:	c7 01       	movw	r24, r14
    585e:	0e 94 48 28 	call	0x5090	; 0x5090 <cmdlinePrintPrompt>
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    state->CmdlineBufferEditPos++;
    // command is complete, process it
    cmdlineProcessInputString(state);
    // reset buffer
    state->CmdlineBufferLength = 0;
    5862:	d7 01       	movw	r26, r14
    5864:	1d 96       	adiw	r26, 0x0d	; 13
    5866:	1c 92       	st	X, r1
    5868:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = 0;
    586a:	1e 96       	adiw	r26, 0x0e	; 14
    586c:	1c 92       	st	X, r1
    586e:	74 c0       	rjmp	.+232    	; 0x5958 <cmdlineInputFunc+0x526>
  }
  else if(c == ASCII_BS)
    5870:	18 30       	cpi	r17, 0x08	; 8
    5872:	09 f0       	breq	.+2      	; 0x5876 <cmdlineInputFunc+0x444>
    5874:	69 c0       	rjmp	.+210    	; 0x5948 <cmdlineInputFunc+0x516>
  {
    if(state->CmdlineBufferEditPos)
    5876:	f7 01       	movw	r30, r14
    5878:	96 85       	ldd	r25, Z+14	; 0x0e
    587a:	99 23       	and	r25, r25
    587c:	09 f4       	brne	.+2      	; 0x5880 <cmdlineInputFunc+0x44e>
    587e:	5c c0       	rjmp	.+184    	; 0x5938 <cmdlineInputFunc+0x506>
    {
      // is this a simple delete (off the end of the line)
      if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    5880:	85 85       	ldd	r24, Z+13	; 0x0d
    5882:	98 17       	cp	r25, r24
    5884:	29 f5       	brne	.+74     	; 0x58d0 <cmdlineInputFunc+0x49e>
      {
        // destructive backspace
        // echo backspace-space-backspace
        fputc(ASCII_BS         , state->myStdInOut);
    5886:	62 8d       	ldd	r22, Z+26	; 0x1a
    5888:	73 8d       	ldd	r23, Z+27	; 0x1b
    588a:	88 e0       	ldi	r24, 0x08	; 8
    588c:	90 e0       	ldi	r25, 0x00	; 0
    588e:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
        fputc(' '              , state->myStdInOut);
    5892:	d7 01       	movw	r26, r14
    5894:	5a 96       	adiw	r26, 0x1a	; 26
    5896:	6d 91       	ld	r22, X+
    5898:	7c 91       	ld	r23, X
    589a:	5b 97       	sbiw	r26, 0x1b	; 27
    589c:	80 e2       	ldi	r24, 0x20	; 32
    589e:	90 e0       	ldi	r25, 0x00	; 0
    58a0:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
        fputc(ASCII_BS         , state->myStdInOut);
    58a4:	f7 01       	movw	r30, r14
    58a6:	62 8d       	ldd	r22, Z+26	; 0x1a
    58a8:	73 8d       	ldd	r23, Z+27	; 0x1b
    58aa:	88 e0       	ldi	r24, 0x08	; 8
    58ac:	90 e0       	ldi	r25, 0x00	; 0
    58ae:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
        // decrement our buffer length and edit position
        state->CmdlineBufferLength--;
    58b2:	d7 01       	movw	r26, r14
    58b4:	1d 96       	adiw	r26, 0x0d	; 13
    58b6:	8c 91       	ld	r24, X
    58b8:	1d 97       	sbiw	r26, 0x0d	; 13
    58ba:	81 50       	subi	r24, 0x01	; 1
    58bc:	1d 96       	adiw	r26, 0x0d	; 13
    58be:	8c 93       	st	X, r24
    58c0:	1d 97       	sbiw	r26, 0x0d	; 13
        state->CmdlineBufferEditPos--;
    58c2:	1e 96       	adiw	r26, 0x0e	; 14
    58c4:	8c 91       	ld	r24, X
    58c6:	1e 97       	sbiw	r26, 0x0e	; 14
    58c8:	81 50       	subi	r24, 0x01	; 1
    58ca:	1e 96       	adiw	r26, 0x0e	; 14
    58cc:	8c 93       	st	X, r24
    58ce:	44 c0       	rjmp	.+136    	; 0x5958 <cmdlineInputFunc+0x526>
      else
      {
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
    58d0:	81 50       	subi	r24, 0x01	; 1
    58d2:	f7 01       	movw	r30, r14
    58d4:	85 87       	std	Z+13, r24	; 0x0d
        state->CmdlineBufferEditPos--;
    58d6:	91 50       	subi	r25, 0x01	; 1
    58d8:	96 87       	std	Z+14, r25	; 0x0e
    58da:	05 c0       	rjmp	.+10     	; 0x58e6 <cmdlineInputFunc+0x4b4>
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
    58dc:	e9 0f       	add	r30, r25
    58de:	f1 1d       	adc	r31, r1
    58e0:	81 81       	ldd	r24, Z+1	; 0x01
    58e2:	80 83       	st	Z, r24
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
        state->CmdlineBufferEditPos--;
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    58e4:	9f 5f       	subi	r25, 0xFF	; 255
    58e6:	d7 01       	movw	r26, r14
    58e8:	1d 96       	adiw	r26, 0x0d	; 13
    58ea:	8c 91       	ld	r24, X
    58ec:	1d 97       	sbiw	r26, 0x0d	; 13
    58ee:	ed 91       	ld	r30, X+
    58f0:	fc 91       	ld	r31, X
    58f2:	98 17       	cp	r25, r24
    58f4:	98 f3       	brcs	.-26     	; 0x58dc <cmdlineInputFunc+0x4aa>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
    58f6:	c7 01       	movw	r24, r14
    58f8:	bf 01       	movw	r22, r30
    58fa:	0e 94 01 29 	call	0x5202	; 0x5202 <cmdlineRepaint>
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
    58fe:	f7 01       	movw	r30, r14
    5900:	62 8d       	ldd	r22, Z+26	; 0x1a
    5902:	73 8d       	ldd	r23, Z+27	; 0x1b
    5904:	80 e2       	ldi	r24, 0x20	; 32
    5906:	90 e0       	ldi	r25, 0x00	; 0
    5908:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    590c:	d7 01       	movw	r26, r14
    590e:	1e 96       	adiw	r26, 0x0e	; 14
    5910:	1c 91       	ld	r17, X
    5912:	08 c0       	rjmp	.+16     	; 0x5924 <cmdlineInputFunc+0x4f2>
          fputc(ASCII_BS       , state->myStdInOut);
    5914:	f7 01       	movw	r30, r14
    5916:	62 8d       	ldd	r22, Z+26	; 0x1a
    5918:	73 8d       	ldd	r23, Z+27	; 0x1b
    591a:	88 e0       	ldi	r24, 0x08	; 8
    591c:	90 e0       	ldi	r25, 0x00	; 0
    591e:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    5922:	1f 5f       	subi	r17, 0xFF	; 255
    5924:	d7 01       	movw	r26, r14
    5926:	1d 96       	adiw	r26, 0x0d	; 13
    5928:	8c 91       	ld	r24, X
    592a:	90 e0       	ldi	r25, 0x00	; 0
    592c:	21 2f       	mov	r18, r17
    592e:	30 e0       	ldi	r19, 0x00	; 0
    5930:	82 17       	cp	r24, r18
    5932:	93 07       	cpc	r25, r19
    5934:	7c f7       	brge	.-34     	; 0x5914 <cmdlineInputFunc+0x4e2>
    5936:	10 c0       	rjmp	.+32     	; 0x5958 <cmdlineInputFunc+0x526>
      }
    }
    else
    {
      // else, ring the bell
      fputc(ASCII_BEL          , state->myStdInOut);
    5938:	f7 01       	movw	r30, r14
    593a:	62 8d       	ldd	r22, Z+26	; 0x1a
    593c:	73 8d       	ldd	r23, Z+27	; 0x1b
    593e:	87 e0       	ldi	r24, 0x07	; 7
    5940:	90 e0       	ldi	r25, 0x00	; 0
    5942:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    5946:	08 c0       	rjmp	.+16     	; 0x5958 <cmdlineInputFunc+0x526>
    }
  }
  else if(c == ASCII_DEL)
    5948:	1f 37       	cpi	r17, 0x7F	; 127
    594a:	31 f0       	breq	.+12     	; 0x5958 <cmdlineInputFunc+0x526>
  {
    // not yet handled
  }
  else if(c == ASCII_ESC)
    594c:	1b 31       	cpi	r17, 0x1B	; 27
    594e:	21 f4       	brne	.+8      	; 0x5958 <cmdlineInputFunc+0x526>
  {
    state->CmdlineInputVT100State = 1;
    5950:	81 e0       	ldi	r24, 0x01	; 1
    5952:	d7 01       	movw	r26, r14
    5954:	52 96       	adiw	r26, 0x12	; 18
    5956:	8c 93       	st	X, r24
  }
}
    5958:	26 96       	adiw	r28, 0x06	; 6
    595a:	0f b6       	in	r0, 0x3f	; 63
    595c:	f8 94       	cli
    595e:	de bf       	out	0x3e, r29	; 62
    5960:	0f be       	out	0x3f, r0	; 63
    5962:	cd bf       	out	0x3d, r28	; 61
    5964:	cf 91       	pop	r28
    5966:	df 91       	pop	r29
    5968:	1f 91       	pop	r17
    596a:	0f 91       	pop	r16
    596c:	ff 90       	pop	r15
    596e:	ef 90       	pop	r14
    5970:	df 90       	pop	r13
    5972:	cf 90       	pop	r12
    5974:	bf 90       	pop	r11
    5976:	af 90       	pop	r10
    5978:	9f 90       	pop	r9
    597a:	08 95       	ret

0000597c <vt100SetCursorPos>:
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
}

void vt100SetCursorPos(uint8_t line, uint8_t col, cmdState_t *state)
{
    597c:	da 01       	movw	r26, r20
  // ESC [ Pl ; Pc H
  fprintf_P(state->myStdInOut, "\x1B[%d;%dH",line,col);
    597e:	2d b7       	in	r18, 0x3d	; 61
    5980:	3e b7       	in	r19, 0x3e	; 62
    5982:	28 50       	subi	r18, 0x08	; 8
    5984:	30 40       	sbci	r19, 0x00	; 0
    5986:	0f b6       	in	r0, 0x3f	; 63
    5988:	f8 94       	cli
    598a:	3e bf       	out	0x3e, r19	; 62
    598c:	0f be       	out	0x3f, r0	; 63
    598e:	2d bf       	out	0x3d, r18	; 61
    5990:	ed b7       	in	r30, 0x3d	; 61
    5992:	fe b7       	in	r31, 0x3e	; 62
    5994:	31 96       	adiw	r30, 0x01	; 1
    5996:	5a 96       	adiw	r26, 0x1a	; 26
    5998:	2d 91       	ld	r18, X+
    599a:	3c 91       	ld	r19, X
    599c:	5b 97       	sbiw	r26, 0x1b	; 27
    599e:	ad b7       	in	r26, 0x3d	; 61
    59a0:	be b7       	in	r27, 0x3e	; 62
    59a2:	12 96       	adiw	r26, 0x02	; 2
    59a4:	3c 93       	st	X, r19
    59a6:	2e 93       	st	-X, r18
    59a8:	11 97       	sbiw	r26, 0x01	; 1
    59aa:	26 e2       	ldi	r18, 0x26	; 38
    59ac:	31 e0       	ldi	r19, 0x01	; 1
    59ae:	33 83       	std	Z+3, r19	; 0x03
    59b0:	22 83       	std	Z+2, r18	; 0x02
    59b2:	84 83       	std	Z+4, r24	; 0x04
    59b4:	15 82       	std	Z+5, r1	; 0x05
    59b6:	66 83       	std	Z+6, r22	; 0x06
    59b8:	17 82       	std	Z+7, r1	; 0x07
    59ba:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    59be:	2d b7       	in	r18, 0x3d	; 61
    59c0:	3e b7       	in	r19, 0x3e	; 62
    59c2:	28 5f       	subi	r18, 0xF8	; 248
    59c4:	3f 4f       	sbci	r19, 0xFF	; 255
    59c6:	0f b6       	in	r0, 0x3f	; 63
    59c8:	f8 94       	cli
    59ca:	3e bf       	out	0x3e, r19	; 62
    59cc:	0f be       	out	0x3f, r0	; 63
    59ce:	2d bf       	out	0x3d, r18	; 61
}
    59d0:	08 95       	ret

000059d2 <vt100SetCursorMode>:
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
}

void vt100SetCursorMode(uint8_t visible, cmdState_t *state)
{
    59d2:	fb 01       	movw	r30, r22
    59d4:	22 8d       	ldd	r18, Z+26	; 0x1a
    59d6:	33 8d       	ldd	r19, Z+27	; 0x1b
  if(visible)
    59d8:	88 23       	and	r24, r24
    59da:	49 f0       	breq	.+18     	; 0x59ee <vt100SetCursorMode+0x1c>
  // ESC [ ? 25 h
    fprintf_P(state->myStdInOut, "\x1B[?25h");
    59dc:	00 d0       	rcall	.+0      	; 0x59de <vt100SetCursorMode+0xc>
    59de:	00 d0       	rcall	.+0      	; 0x59e0 <vt100SetCursorMode+0xe>
    59e0:	ed b7       	in	r30, 0x3d	; 61
    59e2:	fe b7       	in	r31, 0x3e	; 62
    59e4:	32 83       	std	Z+2, r19	; 0x02
    59e6:	21 83       	std	Z+1, r18	; 0x01
    59e8:	8f e2       	ldi	r24, 0x2F	; 47
    59ea:	91 e0       	ldi	r25, 0x01	; 1
    59ec:	08 c0       	rjmp	.+16     	; 0x59fe <vt100SetCursorMode+0x2c>
  else
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
    59ee:	00 d0       	rcall	.+0      	; 0x59f0 <vt100SetCursorMode+0x1e>
    59f0:	00 d0       	rcall	.+0      	; 0x59f2 <vt100SetCursorMode+0x20>
    59f2:	ed b7       	in	r30, 0x3d	; 61
    59f4:	fe b7       	in	r31, 0x3e	; 62
    59f6:	32 83       	std	Z+2, r19	; 0x02
    59f8:	21 83       	std	Z+1, r18	; 0x01
    59fa:	86 e3       	ldi	r24, 0x36	; 54
    59fc:	91 e0       	ldi	r25, 0x01	; 1
    59fe:	94 83       	std	Z+4, r25	; 0x04
    5a00:	83 83       	std	Z+3, r24	; 0x03
    5a02:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    5a06:	0f 90       	pop	r0
    5a08:	0f 90       	pop	r0
    5a0a:	0f 90       	pop	r0
    5a0c:	0f 90       	pop	r0
    5a0e:	08 95       	ret

00005a10 <vt100SetAttr>:
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
}

void vt100SetAttr(uint8_t attr, cmdState_t *state)
{
    5a10:	db 01       	movw	r26, r22
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
    5a12:	00 d0       	rcall	.+0      	; 0x5a14 <vt100SetAttr+0x4>
    5a14:	00 d0       	rcall	.+0      	; 0x5a16 <vt100SetAttr+0x6>
    5a16:	00 d0       	rcall	.+0      	; 0x5a18 <vt100SetAttr+0x8>
    5a18:	ed b7       	in	r30, 0x3d	; 61
    5a1a:	fe b7       	in	r31, 0x3e	; 62
    5a1c:	31 96       	adiw	r30, 0x01	; 1
    5a1e:	5a 96       	adiw	r26, 0x1a	; 26
    5a20:	2d 91       	ld	r18, X+
    5a22:	3c 91       	ld	r19, X
    5a24:	5b 97       	sbiw	r26, 0x1b	; 27
    5a26:	ad b7       	in	r26, 0x3d	; 61
    5a28:	be b7       	in	r27, 0x3e	; 62
    5a2a:	12 96       	adiw	r26, 0x02	; 2
    5a2c:	3c 93       	st	X, r19
    5a2e:	2e 93       	st	-X, r18
    5a30:	11 97       	sbiw	r26, 0x01	; 1
    5a32:	2d e3       	ldi	r18, 0x3D	; 61
    5a34:	31 e0       	ldi	r19, 0x01	; 1
    5a36:	33 83       	std	Z+3, r19	; 0x03
    5a38:	22 83       	std	Z+2, r18	; 0x02
    5a3a:	84 83       	std	Z+4, r24	; 0x04
    5a3c:	15 82       	std	Z+5, r1	; 0x05
    5a3e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    5a42:	8d b7       	in	r24, 0x3d	; 61
    5a44:	9e b7       	in	r25, 0x3e	; 62
    5a46:	06 96       	adiw	r24, 0x06	; 6
    5a48:	0f b6       	in	r0, 0x3f	; 63
    5a4a:	f8 94       	cli
    5a4c:	9e bf       	out	0x3e, r25	; 62
    5a4e:	0f be       	out	0x3f, r0	; 63
    5a50:	8d bf       	out	0x3d, r24	; 61
}
    5a52:	08 95       	ret

00005a54 <vt100ClearScreen>:
}

void vt100ClearScreen(cmdState_t *state)
{
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
    5a54:	00 d0       	rcall	.+0      	; 0x5a56 <vt100ClearScreen+0x2>
    5a56:	00 d0       	rcall	.+0      	; 0x5a58 <vt100ClearScreen+0x4>
    5a58:	fc 01       	movw	r30, r24
    5a5a:	82 8d       	ldd	r24, Z+26	; 0x1a
    5a5c:	93 8d       	ldd	r25, Z+27	; 0x1b
    5a5e:	ed b7       	in	r30, 0x3d	; 61
    5a60:	fe b7       	in	r31, 0x3e	; 62
    5a62:	92 83       	std	Z+2, r25	; 0x02
    5a64:	81 83       	std	Z+1, r24	; 0x01
    5a66:	83 e4       	ldi	r24, 0x43	; 67
    5a68:	91 e0       	ldi	r25, 0x01	; 1
    5a6a:	94 83       	std	Z+4, r25	; 0x04
    5a6c:	83 83       	std	Z+3, r24	; 0x03
    5a6e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    5a72:	0f 90       	pop	r0
    5a74:	0f 90       	pop	r0
    5a76:	0f 90       	pop	r0
    5a78:	0f 90       	pop	r0
}
    5a7a:	08 95       	ret

00005a7c <vt100Init>:
void vt100Init(cmdState_t *state)
{
  // initializes terminal to "power-on" settings
  // ESC c

 fprintf_P(state->myStdInOut, "\x1B\x63");
    5a7c:	00 d0       	rcall	.+0      	; 0x5a7e <vt100Init+0x2>
    5a7e:	00 d0       	rcall	.+0      	; 0x5a80 <vt100Init+0x4>
    5a80:	fc 01       	movw	r30, r24
    5a82:	82 8d       	ldd	r24, Z+26	; 0x1a
    5a84:	93 8d       	ldd	r25, Z+27	; 0x1b
    5a86:	ed b7       	in	r30, 0x3d	; 61
    5a88:	fe b7       	in	r31, 0x3e	; 62
    5a8a:	92 83       	std	Z+2, r25	; 0x02
    5a8c:	81 83       	std	Z+1, r24	; 0x01
    5a8e:	88 e4       	ldi	r24, 0x48	; 72
    5a90:	91 e0       	ldi	r25, 0x01	; 1
    5a92:	94 83       	std	Z+4, r25	; 0x04
    5a94:	83 83       	std	Z+3, r24	; 0x03
    5a96:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    5a9a:	0f 90       	pop	r0
    5a9c:	0f 90       	pop	r0
    5a9e:	0f 90       	pop	r0
    5aa0:	0f 90       	pop	r0
}
    5aa2:	08 95       	ret
    5aa4:	08 95       	ret
    5aa6:	08 95       	ret

00005aa8 <ds1305readMem>:
  spiDisableDS1305();  
  spiGive();
  return 0;
}
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
    5aa8:	0f 93       	push	r16
    5aaa:	1f 93       	push	r17
    5aac:	cf 93       	push	r28
    5aae:	df 93       	push	r29
    5ab0:	18 2f       	mov	r17, r24
    5ab2:	06 2f       	mov	r16, r22
    5ab4:	ea 01       	movw	r28, r20
  if (addr >95)
    5ab6:	80 36       	cpi	r24, 0x60	; 96
    5ab8:	10 f0       	brcs	.+4      	; 0x5abe <ds1305readMem+0x16>
    5aba:	81 e0       	ldi	r24, 0x01	; 1
    5abc:	1d c0       	rjmp	.+58     	; 0x5af8 <ds1305readMem+0x50>
    return 1;
  if (addr + length > 95)
    5abe:	90 e0       	ldi	r25, 0x00	; 0
    5ac0:	86 0f       	add	r24, r22
    5ac2:	91 1d       	adc	r25, r1
    5ac4:	80 36       	cpi	r24, 0x60	; 96
    5ac6:	91 05       	cpc	r25, r1
    5ac8:	14 f0       	brlt	.+4      	; 0x5ace <ds1305readMem+0x26>
    5aca:	82 e0       	ldi	r24, 0x02	; 2
    5acc:	15 c0       	rjmp	.+42     	; 0x5af8 <ds1305readMem+0x50>
    return 2;
  
  addr += 0x20;
  
  spiTake();
    5ace:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  spiEnableDS1305();
    5ad2:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <spiEnableDS1305>

  spiSend(addr);
    5ad6:	81 2f       	mov	r24, r17
    5ad8:	80 5e       	subi	r24, 0xE0	; 224
    5ada:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5ade:	05 c0       	rjmp	.+10     	; 0x5aea <ds1305readMem+0x42>
  while (length > 0)
  {
    *data = spiSend(0);
    5ae0:	80 e0       	ldi	r24, 0x00	; 0
    5ae2:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5ae6:	89 93       	st	Y+, r24
    data++;
    length--;
    5ae8:	01 50       	subi	r16, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    5aea:	00 23       	and	r16, r16
    5aec:	c9 f7       	brne	.-14     	; 0x5ae0 <ds1305readMem+0x38>
    *data = spiSend(0);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    5aee:	0e 94 d7 12 	call	0x25ae	; 0x25ae <spiDisableDS1305>
  spiGive();
    5af2:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
    5af6:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    5af8:	df 91       	pop	r29
    5afa:	cf 91       	pop	r28
    5afc:	1f 91       	pop	r17
    5afe:	0f 91       	pop	r16
    5b00:	08 95       	ret

00005b02 <ds1305writeMem>:
  return;
}


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
    5b02:	0f 93       	push	r16
    5b04:	1f 93       	push	r17
    5b06:	cf 93       	push	r28
    5b08:	df 93       	push	r29
    5b0a:	18 2f       	mov	r17, r24
    5b0c:	06 2f       	mov	r16, r22
    5b0e:	ea 01       	movw	r28, r20
  if (addr > 95)
    5b10:	80 36       	cpi	r24, 0x60	; 96
    5b12:	10 f0       	brcs	.+4      	; 0x5b18 <ds1305writeMem+0x16>
    5b14:	81 e0       	ldi	r24, 0x01	; 1
    5b16:	1c c0       	rjmp	.+56     	; 0x5b50 <ds1305writeMem+0x4e>
    return 1;
  if (addr + length > 95)
    5b18:	90 e0       	ldi	r25, 0x00	; 0
    5b1a:	86 0f       	add	r24, r22
    5b1c:	91 1d       	adc	r25, r1
    5b1e:	80 36       	cpi	r24, 0x60	; 96
    5b20:	91 05       	cpc	r25, r1
    5b22:	14 f0       	brlt	.+4      	; 0x5b28 <ds1305writeMem+0x26>
    5b24:	82 e0       	ldi	r24, 0x02	; 2
    5b26:	14 c0       	rjmp	.+40     	; 0x5b50 <ds1305writeMem+0x4e>
    return 2;

  addr += 0xA0;
  
  spiTake();
    5b28:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  spiEnableDS1305();
    5b2c:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <spiEnableDS1305>

  spiSend(addr);
    5b30:	81 2f       	mov	r24, r17
    5b32:	80 56       	subi	r24, 0x60	; 96
    5b34:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5b38:	04 c0       	rjmp	.+8      	; 0x5b42 <ds1305writeMem+0x40>
  while (length > 0)
  {
    spiSend(*data);
    5b3a:	89 91       	ld	r24, Y+
    5b3c:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    data++;
    length--;
    5b40:	01 50       	subi	r16, 0x01	; 1
  
  spiTake();
  spiEnableDS1305();

  spiSend(addr);
  while (length > 0)
    5b42:	00 23       	and	r16, r16
    5b44:	d1 f7       	brne	.-12     	; 0x5b3a <ds1305writeMem+0x38>
    spiSend(*data);
    data++;
    length--;
  }
  
  spiDisableDS1305();  
    5b46:	0e 94 d7 12 	call	0x25ae	; 0x25ae <spiDisableDS1305>
  spiGive();
    5b4a:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
    5b4e:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    5b50:	df 91       	pop	r29
    5b52:	cf 91       	pop	r28
    5b54:	1f 91       	pop	r17
    5b56:	0f 91       	pop	r16
    5b58:	08 95       	ret

00005b5a <ds1305start>:
}
#endif /* USE_DECODED_TIME_STRUCT */

void ds1305start(void)
{  
  spiTake();
    5b5a:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  spiEnableDS1305();
    5b5e:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <spiEnableDS1305>

  spiSend(0x8F);
    5b62:	8f e8       	ldi	r24, 0x8F	; 143
    5b64:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(0x00);
    5b68:	80 e0       	ldi	r24, 0x00	; 0
    5b6a:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  
  spiDisableDS1305();  
    5b6e:	0e 94 d7 12 	call	0x25ae	; 0x25ae <spiDisableDS1305>
  spiGive();
    5b72:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>

  return;
}
    5b76:	08 95       	ret

00005b78 <setTimeBCD>:
}
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
{
    5b78:	0f 93       	push	r16
    5b7a:	1f 93       	push	r17
    5b7c:	cf 93       	push	r28
    5b7e:	df 93       	push	r29
    5b80:	18 2f       	mov	r17, r24
    5b82:	09 2f       	mov	r16, r25
  spiTake();
    5b84:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  spiEnableDS1305();
    5b88:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    5b8c:	21 2f       	mov	r18, r17
    5b8e:	30 2f       	mov	r19, r16
    5b90:	c9 01       	movw	r24, r18
    5b92:	ec 01       	movw	r28, r24
  uint8_t i;
  spiSend(0x80);
    5b94:	80 e8       	ldi	r24, 0x80	; 128
    5b96:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5b9a:	10 e0       	ldi	r17, 0x00	; 0
  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    spiSend(*ptr);
    5b9c:	89 91       	ld	r24, Y+
    5b9e:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiEnableDS1305();
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
    5ba2:	1f 5f       	subi	r17, 0xFF	; 255
    5ba4:	17 30       	cpi	r17, 0x07	; 7
    5ba6:	d1 f7       	brne	.-12     	; 0x5b9c <setTimeBCD+0x24>
  {
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
    5ba8:	0e 94 d7 12 	call	0x25ae	; 0x25ae <spiDisableDS1305>
  spiGive();
    5bac:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5bb0:	df 91       	pop	r29
    5bb2:	cf 91       	pop	r28
    5bb4:	1f 91       	pop	r17
    5bb6:	0f 91       	pop	r16
    5bb8:	08 95       	ret

00005bba <setTime>:
{
  setTimeBCD((timeBCD_t *)(time));
}
void setTime(time_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    5bba:	0e 94 bc 2d 	call	0x5b78	; 0x5b78 <setTimeBCD>
}
    5bbe:	08 95       	ret

00005bc0 <setTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void setTimeDecoded(timeDecoded_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    5bc0:	0e 94 bc 2d 	call	0x5b78	; 0x5b78 <setTimeBCD>
}
    5bc4:	08 95       	ret

00005bc6 <readTimeBCD>:
void spiEnableDS1305(void)  {};
void spiDisableDS1305(void) {};


void readTimeBCD(timeBCD_t *time)
{
    5bc6:	0f 93       	push	r16
    5bc8:	1f 93       	push	r17
    5bca:	cf 93       	push	r28
    5bcc:	df 93       	push	r29
    5bce:	18 2f       	mov	r17, r24
    5bd0:	09 2f       	mov	r16, r25
  spiTake();
    5bd2:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  spiEnableDS1305();
    5bd6:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
    5bda:	21 2f       	mov	r18, r17
    5bdc:	30 2f       	mov	r19, r16
    5bde:	c9 01       	movw	r24, r18
    5be0:	ec 01       	movw	r28, r24
  uint8_t i;
  
  spiSend(0x00);
    5be2:	80 e0       	ldi	r24, 0x00	; 0
    5be4:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5be8:	10 e0       	ldi	r17, 0x00	; 0

  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    *ptr = spiSend(i);
    5bea:	81 2f       	mov	r24, r17
    5bec:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5bf0:	89 93       	st	Y+, r24
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);

  for (i=0; i<sizeof(timeBCD_t); i++)
    5bf2:	1f 5f       	subi	r17, 0xFF	; 255
    5bf4:	17 30       	cpi	r17, 0x07	; 7
    5bf6:	c9 f7       	brne	.-14     	; 0x5bea <readTimeBCD+0x24>
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
    5bf8:	0e 94 d7 12 	call	0x25ae	; 0x25ae <spiDisableDS1305>
  spiGive();
    5bfc:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5c00:	df 91       	pop	r29
    5c02:	cf 91       	pop	r28
    5c04:	1f 91       	pop	r17
    5c06:	0f 91       	pop	r16
    5c08:	08 95       	ret

00005c0a <readTime>:
{
  readTimeBCD((timeBCD_t *)(time));
}
void readTime (time_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    5c0a:	0e 94 e3 2d 	call	0x5bc6	; 0x5bc6 <readTimeBCD>
}
    5c0e:	08 95       	ret

00005c10 <readTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void readTimeDecoded(timeDecoded_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    5c10:	0e 94 e3 2d 	call	0x5bc6	; 0x5bc6 <readTimeBCD>
}
    5c14:	08 95       	ret
    5c16:	08 95       	ret
    5c18:	08 95       	ret

00005c1a <MPC23s17ReadPortB>:

  return result; 
}

uint8_t MPC23s17ReadPortB(uint8_t addr)
{
    5c1a:	1f 93       	push	r17
  addr = addr<<1;
    5c1c:	18 2f       	mov	r17, r24
    5c1e:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5c20:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    5c22:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    5c24:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5c28:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>

  spiSend(addr);
    5c2c:	81 2f       	mov	r24, r17
    5c2e:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_GPIOB);
    5c32:	83 e1       	ldi	r24, 0x13	; 19
    5c34:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  uint8_t result = spiSend(addr);  
    5c38:	81 2f       	mov	r24, r17
    5c3a:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5c3e:	18 2f       	mov	r17, r24

  disableSpiMPC23S17();
    5c40:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5c44:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>

  return result; 
}
    5c48:	81 2f       	mov	r24, r17
    5c4a:	1f 91       	pop	r17
    5c4c:	08 95       	ret

00005c4e <MPC23s17ReadPortA>:
  disableSpiMPC23S17();
  spiGive();
}

uint8_t MPC23s17ReadPortA(uint8_t addr)
{
    5c4e:	1f 93       	push	r17
  addr = addr<<1;
    5c50:	18 2f       	mov	r17, r24
    5c52:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5c54:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    5c56:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    5c58:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5c5c:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>

  spiSend(addr);
    5c60:	81 2f       	mov	r24, r17
    5c62:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_GPIOA);
    5c66:	82 e1       	ldi	r24, 0x12	; 18
    5c68:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  uint8_t result = spiSend(addr);  
    5c6c:	81 2f       	mov	r24, r17
    5c6e:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5c72:	18 2f       	mov	r17, r24

  disableSpiMPC23S17();
    5c74:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5c78:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>

  return result; 
}
    5c7c:	81 2f       	mov	r24, r17
    5c7e:	1f 91       	pop	r17
    5c80:	08 95       	ret

00005c82 <MPC23s17ClearBitsOnPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17ClearBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5c82:	1f 93       	push	r17
    5c84:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5c86:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5c88:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB &= (~portBout);
    5c8a:	90 91 8e 0e 	lds	r25, 0x0E8E
    5c8e:	80 95       	com	r24
    5c90:	98 23       	and	r25, r24
    5c92:	90 93 8e 0e 	sts	0x0E8E, r25

  spiTake();
    5c96:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5c9a:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  spiSend(addr);
    5c9e:	81 2f       	mov	r24, r17
    5ca0:	80 64       	ori	r24, 0x40	; 64
    5ca2:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_OLATB);
    5ca6:	85 e1       	ldi	r24, 0x15	; 21
    5ca8:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portB);  
    5cac:	80 91 8e 0e 	lds	r24, 0x0E8E
    5cb0:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>

  disableSpiMPC23S17();
    5cb4:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5cb8:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5cbc:	1f 91       	pop	r17
    5cbe:	08 95       	ret

00005cc0 <MPC23s17SetBitsOnPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    5cc0:	1f 93       	push	r17
    5cc2:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5cc4:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5cc6:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB |= portBout;
    5cc8:	90 91 8e 0e 	lds	r25, 0x0E8E
    5ccc:	98 2b       	or	r25, r24
    5cce:	90 93 8e 0e 	sts	0x0E8E, r25

  spiTake();
    5cd2:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5cd6:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  spiSend(addr);
    5cda:	81 2f       	mov	r24, r17
    5cdc:	80 64       	ori	r24, 0x40	; 64
    5cde:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_OLATB);
    5ce2:	85 e1       	ldi	r24, 0x15	; 21
    5ce4:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portB);  
    5ce8:	80 91 8e 0e 	lds	r24, 0x0E8E
    5cec:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  disableSpiMPC23S17();
    5cf0:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5cf4:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5cf8:	1f 91       	pop	r17
    5cfa:	08 95       	ret

00005cfc <MPC23s17SetPortB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetPortB(uint8_t portBout, uint8_t addr)
{
    5cfc:	1f 93       	push	r17
    5cfe:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5d00:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5d02:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB = portBout;
    5d04:	80 93 8e 0e 	sts	0x0E8E, r24

  spiTake();
    5d08:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5d0c:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  spiSend(addr);
    5d10:	81 2f       	mov	r24, r17
    5d12:	80 64       	ori	r24, 0x40	; 64
    5d14:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_OLATB);
    5d18:	85 e1       	ldi	r24, 0x15	; 21
    5d1a:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portB);  
    5d1e:	80 91 8e 0e 	lds	r24, 0x0E8E
    5d22:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  disableSpiMPC23S17();
    5d26:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5d2a:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5d2e:	1f 91       	pop	r17
    5d30:	08 95       	ret

00005d32 <MPC23s17ClearBitsOnPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17ClearBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    5d32:	1f 93       	push	r17
    5d34:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5d36:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5d38:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA &= (~portAout);
    5d3a:	90 91 db 0e 	lds	r25, 0x0EDB
    5d3e:	80 95       	com	r24
    5d40:	98 23       	and	r25, r24
    5d42:	90 93 db 0e 	sts	0x0EDB, r25

  spiTake();
    5d46:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5d4a:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  spiSend(addr);
    5d4e:	81 2f       	mov	r24, r17
    5d50:	80 64       	ori	r24, 0x40	; 64
    5d52:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_OLATA);
    5d56:	84 e1       	ldi	r24, 0x14	; 20
    5d58:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portA);  
    5d5c:	80 91 db 0e 	lds	r24, 0x0EDB
    5d60:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  disableSpiMPC23S17();
    5d64:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5d68:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5d6c:	1f 91       	pop	r17
    5d6e:	08 95       	ret

00005d70 <MPC23s17SetBitsOnPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    5d70:	1f 93       	push	r17
    5d72:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5d74:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5d76:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA |= portAout;  
    5d78:	90 91 db 0e 	lds	r25, 0x0EDB
    5d7c:	98 2b       	or	r25, r24
    5d7e:	90 93 db 0e 	sts	0x0EDB, r25

  spiTake();
    5d82:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5d86:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  spiSend(addr);
    5d8a:	81 2f       	mov	r24, r17
    5d8c:	80 64       	ori	r24, 0x40	; 64
    5d8e:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_OLATA);
    5d92:	84 e1       	ldi	r24, 0x14	; 20
    5d94:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portA);  
    5d98:	80 91 db 0e 	lds	r24, 0x0EDB
    5d9c:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  disableSpiMPC23S17();
    5da0:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5da4:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5da8:	1f 91       	pop	r17
    5daa:	08 95       	ret

00005dac <MPC23s17SetPortA>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetPortA(uint8_t portAout, uint8_t addr)
{
    5dac:	0f 93       	push	r16
    5dae:	1f 93       	push	r17
    5db0:	18 2f       	mov	r17, r24
    5db2:	06 2f       	mov	r16, r22
  addr = addr<<1;
    5db4:	00 0f       	add	r16, r16
  addr &= 0x0E;
    5db6:	0e 70       	andi	r16, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    5db8:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5dbc:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  portA = portAout;  
    5dc0:	10 93 db 0e 	sts	0x0EDB, r17
  spiSend(addr);
    5dc4:	80 2f       	mov	r24, r16
    5dc6:	80 64       	ori	r24, 0x40	; 64
    5dc8:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_OLATA);
    5dcc:	84 e1       	ldi	r24, 0x14	; 20
    5dce:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portA);  
    5dd2:	80 91 db 0e 	lds	r24, 0x0EDB
    5dd6:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>

  disableSpiMPC23S17();
    5dda:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5dde:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5de2:	1f 91       	pop	r17
    5de4:	0f 91       	pop	r16
    5de6:	08 95       	ret

00005de8 <MPC23s17SetDirB>:
  disableSpiMPC23S17();
  spiGive();
}

void MPC23s17SetDirB(uint8_t portBdir, uint8_t addr)
{
    5de8:	0f 93       	push	r16
    5dea:	1f 93       	push	r17
    5dec:	08 2f       	mov	r16, r24
    5dee:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5df0:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5df2:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    5df4:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17();
    5df8:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  
  spiSend(addr);
    5dfc:	81 2f       	mov	r24, r17
    5dfe:	80 64       	ori	r24, 0x40	; 64
    5e00:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_IODIRB);
    5e04:	81 e0       	ldi	r24, 0x01	; 1
    5e06:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portBdir);  
    5e0a:	80 2f       	mov	r24, r16
    5e0c:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  
  disableSpiMPC23S17();
    5e10:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5e14:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5e18:	1f 91       	pop	r17
    5e1a:	0f 91       	pop	r16
    5e1c:	08 95       	ret

00005e1e <MPC23s17SetDirA>:
void enableSpiMPC23S17(void)  {}
void disableSpiMPC23S17(void) {}


void MPC23s17SetDirA(uint8_t portAdir, uint8_t addr)
{
    5e1e:	0f 93       	push	r16
    5e20:	1f 93       	push	r17
    5e22:	08 2f       	mov	r16, r24
    5e24:	16 2f       	mov	r17, r22
  addr = addr<<1;
    5e26:	11 0f       	add	r17, r17
  addr &= 0x0E;
    5e28:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    5e2a:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMPC23S17(); 
    5e2e:	0e 94 ba 12 	call	0x2574	; 0x2574 <enableSpiMPC23S17>
  spiSend(addr);
    5e32:	81 2f       	mov	r24, r17
    5e34:	80 64       	ori	r24, 0x40	; 64
    5e36:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(B0_IODIRA);
    5e3a:	80 e0       	ldi	r24, 0x00	; 0
    5e3c:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(portAdir);  
    5e40:	80 2f       	mov	r24, r16
    5e42:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  
  disableSpiMPC23S17();
    5e46:	0e 94 bc 12 	call	0x2578	; 0x2578 <disableSpiMPC23S17>
  spiGive();
    5e4a:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5e4e:	1f 91       	pop	r17
    5e50:	0f 91       	pop	r16
    5e52:	08 95       	ret
    5e54:	08 95       	ret
    5e56:	08 95       	ret

00005e58 <MCP3008_getSampleSingle>:
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}

uint16_t MCP3008_getSampleSingle(uint8_t inputNo)
{
    5e58:	ff 92       	push	r15
    5e5a:	0f 93       	push	r16
    5e5c:	1f 93       	push	r17
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    5e5e:	18 2f       	mov	r17, r24
    5e60:	12 95       	swap	r17
  inputNo &= 0x70;
    5e62:	10 77       	andi	r17, 0x70	; 112
  inputNo |= 0x80;
  
  spiTake();
    5e64:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMCP3008();
    5e68:	0e 94 be 12 	call	0x257c	; 0x257c <enableSpiMCP3008>
  
  spiSend(0x01);                //Start
    5e6c:	81 e0       	ldi	r24, 0x01	; 1
    5e6e:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    5e72:	81 2f       	mov	r24, r17
    5e74:	80 68       	ori	r24, 0x80	; 128
    5e76:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5e7a:	f8 2e       	mov	r15, r24
  resultLo = spiSend(0);        //X X X X X X X X
    5e7c:	80 e0       	ldi	r24, 0x00	; 0
    5e7e:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5e82:	08 2f       	mov	r16, r24
  
  disableSpiMCP3008(); 
    5e84:	0e 94 c3 12 	call	0x2586	; 0x2586 <disableSpiMCP3008>
  spiGive();
    5e88:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
    5e8c:	9f 2d       	mov	r25, r15
    5e8e:	93 70       	andi	r25, 0x03	; 3
    5e90:	80 e0       	ldi	r24, 0x00	; 0
    5e92:	10 e0       	ldi	r17, 0x00	; 0
    5e94:	08 2b       	or	r16, r24
    5e96:	19 2b       	or	r17, r25
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}
    5e98:	c8 01       	movw	r24, r16
    5e9a:	1f 91       	pop	r17
    5e9c:	0f 91       	pop	r16
    5e9e:	ff 90       	pop	r15
    5ea0:	08 95       	ret

00005ea2 <MCP3008_getSampleDiff>:
void enableSpiMCP3008(void)   {};
void disableSpiMCP3008(void)  {};


uint16_t MCP3008_getSampleDiff(uint8_t inputNo)
{
    5ea2:	ff 92       	push	r15
    5ea4:	0f 93       	push	r16
    5ea6:	1f 93       	push	r17
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    5ea8:	18 2f       	mov	r17, r24
    5eaa:	12 95       	swap	r17
    5eac:	10 7f       	andi	r17, 0xF0	; 240
  inputNo &= 0x70;
  
  spiTake();
    5eae:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMCP3008();
    5eb2:	0e 94 be 12 	call	0x257c	; 0x257c <enableSpiMCP3008>
  
  spiSend(0x01);                               //Start
    5eb6:	81 e0       	ldi	r24, 0x01	; 1
    5eb8:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    5ebc:	81 2f       	mov	r24, r17
    5ebe:	80 77       	andi	r24, 0x70	; 112
    5ec0:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5ec4:	f8 2e       	mov	r15, r24
  resultLo = spiSend(0);        //X X X X X X X X
    5ec6:	80 e0       	ldi	r24, 0x00	; 0
    5ec8:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    5ecc:	08 2f       	mov	r16, r24
  
  disableSpiMCP3008(); 
    5ece:	0e 94 c3 12 	call	0x2586	; 0x2586 <disableSpiMCP3008>
  spiGive();
    5ed2:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
    5ed6:	9f 2d       	mov	r25, r15
    5ed8:	93 70       	andi	r25, 0x03	; 3
    5eda:	80 e0       	ldi	r24, 0x00	; 0
    5edc:	10 e0       	ldi	r17, 0x00	; 0
    5ede:	08 2b       	or	r16, r24
    5ee0:	19 2b       	or	r17, r25
  
  resultHi &= 0x03;
  return resultHi << 8 | resultLo;
}
    5ee2:	c8 01       	movw	r24, r16
    5ee4:	1f 91       	pop	r17
    5ee6:	0f 91       	pop	r16
    5ee8:	ff 90       	pop	r15
    5eea:	08 95       	ret
    5eec:	08 95       	ret
    5eee:	08 95       	ret

00005ef0 <MCP4150_setValue>:
/**
 * Ustawia warto rezystancji
 * @param inputNo - WARTO OD 0 DO 255.
 */
void MCP4150_setValue(uint8_t value)
{  
    5ef0:	1f 93       	push	r17
    5ef2:	18 2f       	mov	r17, r24
  spiTake();
    5ef4:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  enableSpiMCP4150();
    5ef8:	0e 94 c8 12 	call	0x2590	; 0x2590 <enableSpiMCP4150>
  
  spiSend(0x11);  
    5efc:	81 e1       	ldi	r24, 0x11	; 17
    5efe:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(value);
    5f02:	81 2f       	mov	r24, r17
    5f04:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  
  disableSpiMCP4150(); 
    5f08:	0e 94 cd 12 	call	0x259a	; 0x259a <disableSpiMCP4150>
  spiGive();
    5f0c:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5f10:	1f 91       	pop	r17
    5f12:	08 95       	ret
    5f14:	08 95       	ret
    5f16:	08 95       	ret

00005f18 <enc28j60WriteOp>:
  spiGive();
  return result; 
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
    5f18:	ff 92       	push	r15
    5f1a:	0f 93       	push	r16
    5f1c:	1f 93       	push	r17
    5f1e:	18 2f       	mov	r17, r24
    5f20:	06 2f       	mov	r16, r22
    5f22:	f4 2e       	mov	r15, r20
  spiTake();
    5f24:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  spiEnableEnc28j60();
    5f28:	0e 94 aa 12 	call	0x2554	; 0x2554 <spiEnableEnc28j60>
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSend(op | (address & ADDR_MASK));
    5f2c:	0f 71       	andi	r16, 0x1F	; 31
    5f2e:	80 2f       	mov	r24, r16
    5f30:	81 2b       	or	r24, r17
    5f32:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiSend(data);
    5f36:	8f 2d       	mov	r24, r15
    5f38:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
  spiDisableEnc28j60();
    5f3c:	0e 94 ac 12 	call	0x2558	; 0x2558 <spiDisableEnc28j60>
  spiGive();
    5f40:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
}
    5f44:	1f 91       	pop	r17
    5f46:	0f 91       	pop	r16
    5f48:	ff 90       	pop	r15
    5f4a:	08 95       	ret

00005f4c <enc28j60SetBank>:
//   spiGive();
// }


void enc28j60SetBank(uint8_t address)
{
    5f4c:	1f 93       	push	r17
    5f4e:	cf 93       	push	r28
    5f50:	df 93       	push	r29
    5f52:	18 2f       	mov	r17, r24
  // set the bank (if needed)
  if((address & BANK_MASK) != Enc28j60Bank)
    5f54:	c8 2f       	mov	r28, r24
    5f56:	d0 e0       	ldi	r29, 0x00	; 0
    5f58:	c0 76       	andi	r28, 0x60	; 96
    5f5a:	d0 70       	andi	r29, 0x00	; 0
    5f5c:	80 91 90 01 	lds	r24, 0x0190
    5f60:	90 e0       	ldi	r25, 0x00	; 0
    5f62:	c8 17       	cp	r28, r24
    5f64:	d9 07       	cpc	r29, r25
    5f66:	91 f0       	breq	.+36     	; 0x5f8c <enc28j60SetBank+0x40>
  {
    // set the bank
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    5f68:	80 ea       	ldi	r24, 0xA0	; 160
    5f6a:	6f e1       	ldi	r22, 0x1F	; 31
    5f6c:	43 e0       	ldi	r20, 0x03	; 3
    5f6e:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    5f72:	85 e0       	ldi	r24, 0x05	; 5
    5f74:	d5 95       	asr	r29
    5f76:	c7 95       	ror	r28
    5f78:	8a 95       	dec	r24
    5f7a:	e1 f7       	brne	.-8      	; 0x5f74 <enc28j60SetBank+0x28>
    5f7c:	80 e8       	ldi	r24, 0x80	; 128
    5f7e:	6f e1       	ldi	r22, 0x1F	; 31
    5f80:	4c 2f       	mov	r20, r28
    5f82:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    Enc28j60Bank = (address & BANK_MASK);
    5f86:	10 76       	andi	r17, 0x60	; 96
    5f88:	10 93 90 01 	sts	0x0190, r17
  }
}
    5f8c:	df 91       	pop	r29
    5f8e:	cf 91       	pop	r28
    5f90:	1f 91       	pop	r17
    5f92:	08 95       	ret

00005f94 <enc28j60Write>:

  return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    5f94:	0f 93       	push	r16
    5f96:	1f 93       	push	r17
    5f98:	18 2f       	mov	r17, r24
    5f9a:	06 2f       	mov	r16, r22
  // set the bank
  enc28j60SetBank(address);
    5f9c:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <enc28j60SetBank>
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    5fa0:	80 e4       	ldi	r24, 0x40	; 64
    5fa2:	61 2f       	mov	r22, r17
    5fa4:	40 2f       	mov	r20, r16
    5fa6:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
}
    5faa:	1f 91       	pop	r17
    5fac:	0f 91       	pop	r16
    5fae:	08 95       	ret

00005fb0 <nicSetMacAddress>:
    5fb0:	0f 93       	push	r16
    5fb2:	1f 93       	push	r17
    5fb4:	8c 01       	movw	r16, r24
    5fb6:	84 ee       	ldi	r24, 0xE4	; 228
    5fb8:	f8 01       	movw	r30, r16
    5fba:	60 81       	ld	r22, Z
    5fbc:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    5fc0:	85 ee       	ldi	r24, 0xE5	; 229
    5fc2:	f8 01       	movw	r30, r16
    5fc4:	61 81       	ldd	r22, Z+1	; 0x01
    5fc6:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    5fca:	82 ee       	ldi	r24, 0xE2	; 226
    5fcc:	f8 01       	movw	r30, r16
    5fce:	62 81       	ldd	r22, Z+2	; 0x02
    5fd0:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    5fd4:	83 ee       	ldi	r24, 0xE3	; 227
    5fd6:	f8 01       	movw	r30, r16
    5fd8:	63 81       	ldd	r22, Z+3	; 0x03
    5fda:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    5fde:	80 ee       	ldi	r24, 0xE0	; 224
    5fe0:	f8 01       	movw	r30, r16
    5fe2:	64 81       	ldd	r22, Z+4	; 0x04
    5fe4:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    5fe8:	81 ee       	ldi	r24, 0xE1	; 225
    5fea:	f8 01       	movw	r30, r16
    5fec:	65 81       	ldd	r22, Z+5	; 0x05
    5fee:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    5ff2:	1f 91       	pop	r17
    5ff4:	0f 91       	pop	r16
    5ff6:	08 95       	ret

00005ff8 <enc28j60ReadOp>:
    enc28j60PhyWrite    (PHLCON, 0x476);
    vTaskDelay          (2);
}

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
    5ff8:	0f 93       	push	r16
    5ffa:	1f 93       	push	r17
    5ffc:	18 2f       	mov	r17, r24
    5ffe:	06 2f       	mov	r16, r22
  uint8_t result;
  spiTake();
    6000:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
  spiEnableEnc28j60();
    6004:	0e 94 aa 12 	call	0x2554	; 0x2554 <spiEnableEnc28j60>
  
  // issue read command
  spiSend(op | (address & ADDR_MASK));
    6008:	80 2f       	mov	r24, r16
    600a:	8f 71       	andi	r24, 0x1F	; 31
    600c:	81 2b       	or	r24, r17
    600e:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>

  // read data
  result = spiSend(0x00);
    6012:	80 e0       	ldi	r24, 0x00	; 0
    6014:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    6018:	18 2f       	mov	r17, r24

  // do dummy read if needed (for mac and mii, see datasheet page 29)
  if(address & 0x80)
    601a:	07 ff       	sbrs	r16, 7
    601c:	04 c0       	rjmp	.+8      	; 0x6026 <enc28j60ReadOp+0x2e>
  {
    result = spiSend(0x00);
    601e:	80 e0       	ldi	r24, 0x00	; 0
    6020:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    6024:	18 2f       	mov	r17, r24
  }

  spiDisableEnc28j60();
    6026:	0e 94 ac 12 	call	0x2558	; 0x2558 <spiDisableEnc28j60>
  spiGive();
    602a:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
  return result; 
}
    602e:	81 2f       	mov	r24, r17
    6030:	1f 91       	pop	r17
    6032:	0f 91       	pop	r16
    6034:	08 95       	ret

00006036 <enc28j60Read>:
    Enc28j60Bank = (address & BANK_MASK);
  }
}

uint8_t enc28j60Read(uint8_t address)
{
    6036:	1f 93       	push	r17
    6038:	18 2f       	mov	r17, r24
  // set the bank
  enc28j60SetBank(address);
    603a:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <enc28j60SetBank>
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    603e:	80 e0       	ldi	r24, 0x00	; 0
    6040:	61 2f       	mov	r22, r17
    6042:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
  return result;
}
    6046:	1f 91       	pop	r17
    6048:	08 95       	ret

0000604a <nicRegDump>:
    604a:	0f 93       	push	r16
    604c:	1f 93       	push	r17
    604e:	8c 01       	movw	r16, r24
    6050:	00 d0       	rcall	.+0      	; 0x6052 <nicRegDump+0x8>
    6052:	00 d0       	rcall	.+0      	; 0x6054 <nicRegDump+0xa>
    6054:	ad b7       	in	r26, 0x3d	; 61
    6056:	be b7       	in	r27, 0x3e	; 62
    6058:	12 96       	adiw	r26, 0x02	; 2
    605a:	9c 93       	st	X, r25
    605c:	8e 93       	st	-X, r24
    605e:	11 97       	sbiw	r26, 0x01	; 1
    6060:	80 e4       	ldi	r24, 0x40	; 64
    6062:	9c e0       	ldi	r25, 0x0C	; 12
    6064:	14 96       	adiw	r26, 0x04	; 4
    6066:	9c 93       	st	X, r25
    6068:	8e 93       	st	-X, r24
    606a:	13 97       	sbiw	r26, 0x03	; 3
    606c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6070:	0f 90       	pop	r0
    6072:	0f 90       	pop	r0
    6074:	0f 90       	pop	r0
    6076:	0f 90       	pop	r0
    6078:	81 ee       	ldi	r24, 0xE1	; 225
    607a:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    607e:	00 d0       	rcall	.+0      	; 0x6080 <nicRegDump+0x36>
    6080:	00 d0       	rcall	.+0      	; 0x6082 <nicRegDump+0x38>
    6082:	00 d0       	rcall	.+0      	; 0x6084 <nicRegDump+0x3a>
    6084:	ed b7       	in	r30, 0x3d	; 61
    6086:	fe b7       	in	r31, 0x3e	; 62
    6088:	31 96       	adiw	r30, 0x01	; 1
    608a:	ad b7       	in	r26, 0x3d	; 61
    608c:	be b7       	in	r27, 0x3e	; 62
    608e:	12 96       	adiw	r26, 0x02	; 2
    6090:	1c 93       	st	X, r17
    6092:	0e 93       	st	-X, r16
    6094:	11 97       	sbiw	r26, 0x01	; 1
    6096:	21 e3       	ldi	r18, 0x31	; 49
    6098:	3c e0       	ldi	r19, 0x0C	; 12
    609a:	33 83       	std	Z+3, r19	; 0x03
    609c:	22 83       	std	Z+2, r18	; 0x02
    609e:	84 83       	std	Z+4, r24	; 0x04
    60a0:	15 82       	std	Z+5, r1	; 0x05
    60a2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    60a6:	ed b7       	in	r30, 0x3d	; 61
    60a8:	fe b7       	in	r31, 0x3e	; 62
    60aa:	36 96       	adiw	r30, 0x06	; 6
    60ac:	0f b6       	in	r0, 0x3f	; 63
    60ae:	f8 94       	cli
    60b0:	fe bf       	out	0x3e, r31	; 62
    60b2:	0f be       	out	0x3f, r0	; 63
    60b4:	ed bf       	out	0x3d, r30	; 61
    60b6:	80 ee       	ldi	r24, 0xE0	; 224
    60b8:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    60bc:	00 d0       	rcall	.+0      	; 0x60be <nicRegDump+0x74>
    60be:	00 d0       	rcall	.+0      	; 0x60c0 <nicRegDump+0x76>
    60c0:	00 d0       	rcall	.+0      	; 0x60c2 <nicRegDump+0x78>
    60c2:	ed b7       	in	r30, 0x3d	; 61
    60c4:	fe b7       	in	r31, 0x3e	; 62
    60c6:	31 96       	adiw	r30, 0x01	; 1
    60c8:	ad b7       	in	r26, 0x3d	; 61
    60ca:	be b7       	in	r27, 0x3e	; 62
    60cc:	12 96       	adiw	r26, 0x02	; 2
    60ce:	1c 93       	st	X, r17
    60d0:	0e 93       	st	-X, r16
    60d2:	11 97       	sbiw	r26, 0x01	; 1
    60d4:	22 e2       	ldi	r18, 0x22	; 34
    60d6:	3c e0       	ldi	r19, 0x0C	; 12
    60d8:	33 83       	std	Z+3, r19	; 0x03
    60da:	22 83       	std	Z+2, r18	; 0x02
    60dc:	84 83       	std	Z+4, r24	; 0x04
    60de:	15 82       	std	Z+5, r1	; 0x05
    60e0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    60e4:	ed b7       	in	r30, 0x3d	; 61
    60e6:	fe b7       	in	r31, 0x3e	; 62
    60e8:	36 96       	adiw	r30, 0x06	; 6
    60ea:	0f b6       	in	r0, 0x3f	; 63
    60ec:	f8 94       	cli
    60ee:	fe bf       	out	0x3e, r31	; 62
    60f0:	0f be       	out	0x3f, r0	; 63
    60f2:	ed bf       	out	0x3d, r30	; 61
    60f4:	83 ee       	ldi	r24, 0xE3	; 227
    60f6:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    60fa:	00 d0       	rcall	.+0      	; 0x60fc <nicRegDump+0xb2>
    60fc:	00 d0       	rcall	.+0      	; 0x60fe <nicRegDump+0xb4>
    60fe:	00 d0       	rcall	.+0      	; 0x6100 <nicRegDump+0xb6>
    6100:	ed b7       	in	r30, 0x3d	; 61
    6102:	fe b7       	in	r31, 0x3e	; 62
    6104:	31 96       	adiw	r30, 0x01	; 1
    6106:	ad b7       	in	r26, 0x3d	; 61
    6108:	be b7       	in	r27, 0x3e	; 62
    610a:	12 96       	adiw	r26, 0x02	; 2
    610c:	1c 93       	st	X, r17
    610e:	0e 93       	st	-X, r16
    6110:	11 97       	sbiw	r26, 0x01	; 1
    6112:	23 e1       	ldi	r18, 0x13	; 19
    6114:	3c e0       	ldi	r19, 0x0C	; 12
    6116:	33 83       	std	Z+3, r19	; 0x03
    6118:	22 83       	std	Z+2, r18	; 0x02
    611a:	84 83       	std	Z+4, r24	; 0x04
    611c:	15 82       	std	Z+5, r1	; 0x05
    611e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6122:	ed b7       	in	r30, 0x3d	; 61
    6124:	fe b7       	in	r31, 0x3e	; 62
    6126:	36 96       	adiw	r30, 0x06	; 6
    6128:	0f b6       	in	r0, 0x3f	; 63
    612a:	f8 94       	cli
    612c:	fe bf       	out	0x3e, r31	; 62
    612e:	0f be       	out	0x3f, r0	; 63
    6130:	ed bf       	out	0x3d, r30	; 61
    6132:	82 ee       	ldi	r24, 0xE2	; 226
    6134:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6138:	00 d0       	rcall	.+0      	; 0x613a <nicRegDump+0xf0>
    613a:	00 d0       	rcall	.+0      	; 0x613c <nicRegDump+0xf2>
    613c:	00 d0       	rcall	.+0      	; 0x613e <nicRegDump+0xf4>
    613e:	ed b7       	in	r30, 0x3d	; 61
    6140:	fe b7       	in	r31, 0x3e	; 62
    6142:	31 96       	adiw	r30, 0x01	; 1
    6144:	ad b7       	in	r26, 0x3d	; 61
    6146:	be b7       	in	r27, 0x3e	; 62
    6148:	12 96       	adiw	r26, 0x02	; 2
    614a:	1c 93       	st	X, r17
    614c:	0e 93       	st	-X, r16
    614e:	11 97       	sbiw	r26, 0x01	; 1
    6150:	24 e0       	ldi	r18, 0x04	; 4
    6152:	3c e0       	ldi	r19, 0x0C	; 12
    6154:	33 83       	std	Z+3, r19	; 0x03
    6156:	22 83       	std	Z+2, r18	; 0x02
    6158:	84 83       	std	Z+4, r24	; 0x04
    615a:	15 82       	std	Z+5, r1	; 0x05
    615c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6160:	ed b7       	in	r30, 0x3d	; 61
    6162:	fe b7       	in	r31, 0x3e	; 62
    6164:	36 96       	adiw	r30, 0x06	; 6
    6166:	0f b6       	in	r0, 0x3f	; 63
    6168:	f8 94       	cli
    616a:	fe bf       	out	0x3e, r31	; 62
    616c:	0f be       	out	0x3f, r0	; 63
    616e:	ed bf       	out	0x3d, r30	; 61
    6170:	85 ee       	ldi	r24, 0xE5	; 229
    6172:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6176:	00 d0       	rcall	.+0      	; 0x6178 <nicRegDump+0x12e>
    6178:	00 d0       	rcall	.+0      	; 0x617a <nicRegDump+0x130>
    617a:	00 d0       	rcall	.+0      	; 0x617c <nicRegDump+0x132>
    617c:	ed b7       	in	r30, 0x3d	; 61
    617e:	fe b7       	in	r31, 0x3e	; 62
    6180:	31 96       	adiw	r30, 0x01	; 1
    6182:	ad b7       	in	r26, 0x3d	; 61
    6184:	be b7       	in	r27, 0x3e	; 62
    6186:	12 96       	adiw	r26, 0x02	; 2
    6188:	1c 93       	st	X, r17
    618a:	0e 93       	st	-X, r16
    618c:	11 97       	sbiw	r26, 0x01	; 1
    618e:	25 ef       	ldi	r18, 0xF5	; 245
    6190:	3b e0       	ldi	r19, 0x0B	; 11
    6192:	33 83       	std	Z+3, r19	; 0x03
    6194:	22 83       	std	Z+2, r18	; 0x02
    6196:	84 83       	std	Z+4, r24	; 0x04
    6198:	15 82       	std	Z+5, r1	; 0x05
    619a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    619e:	ed b7       	in	r30, 0x3d	; 61
    61a0:	fe b7       	in	r31, 0x3e	; 62
    61a2:	36 96       	adiw	r30, 0x06	; 6
    61a4:	0f b6       	in	r0, 0x3f	; 63
    61a6:	f8 94       	cli
    61a8:	fe bf       	out	0x3e, r31	; 62
    61aa:	0f be       	out	0x3f, r0	; 63
    61ac:	ed bf       	out	0x3d, r30	; 61
    61ae:	84 ee       	ldi	r24, 0xE4	; 228
    61b0:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    61b4:	00 d0       	rcall	.+0      	; 0x61b6 <nicRegDump+0x16c>
    61b6:	00 d0       	rcall	.+0      	; 0x61b8 <nicRegDump+0x16e>
    61b8:	00 d0       	rcall	.+0      	; 0x61ba <nicRegDump+0x170>
    61ba:	ed b7       	in	r30, 0x3d	; 61
    61bc:	fe b7       	in	r31, 0x3e	; 62
    61be:	31 96       	adiw	r30, 0x01	; 1
    61c0:	ad b7       	in	r26, 0x3d	; 61
    61c2:	be b7       	in	r27, 0x3e	; 62
    61c4:	12 96       	adiw	r26, 0x02	; 2
    61c6:	1c 93       	st	X, r17
    61c8:	0e 93       	st	-X, r16
    61ca:	11 97       	sbiw	r26, 0x01	; 1
    61cc:	26 ee       	ldi	r18, 0xE6	; 230
    61ce:	3b e0       	ldi	r19, 0x0B	; 11
    61d0:	33 83       	std	Z+3, r19	; 0x03
    61d2:	22 83       	std	Z+2, r18	; 0x02
    61d4:	84 83       	std	Z+4, r24	; 0x04
    61d6:	15 82       	std	Z+5, r1	; 0x05
    61d8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    61dc:	ed b7       	in	r30, 0x3d	; 61
    61de:	fe b7       	in	r31, 0x3e	; 62
    61e0:	36 96       	adiw	r30, 0x06	; 6
    61e2:	0f b6       	in	r0, 0x3f	; 63
    61e4:	f8 94       	cli
    61e6:	fe bf       	out	0x3e, r31	; 62
    61e8:	0f be       	out	0x3f, r0	; 63
    61ea:	ed bf       	out	0x3d, r30	; 61
    61ec:	1f 91       	pop	r17
    61ee:	0f 91       	pop	r16
    61f0:	08 95       	ret

000061f2 <nicGetMacAddress>:
    61f2:	0f 93       	push	r16
    61f4:	1f 93       	push	r17
    61f6:	8c 01       	movw	r16, r24
    61f8:	81 ee       	ldi	r24, 0xE1	; 225
    61fa:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    61fe:	f8 01       	movw	r30, r16
    6200:	85 83       	std	Z+5, r24	; 0x05
    6202:	80 ee       	ldi	r24, 0xE0	; 224
    6204:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6208:	f8 01       	movw	r30, r16
    620a:	84 83       	std	Z+4, r24	; 0x04
    620c:	83 ee       	ldi	r24, 0xE3	; 227
    620e:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6212:	f8 01       	movw	r30, r16
    6214:	83 83       	std	Z+3, r24	; 0x03
    6216:	82 ee       	ldi	r24, 0xE2	; 226
    6218:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    621c:	f8 01       	movw	r30, r16
    621e:	82 83       	std	Z+2, r24	; 0x02
    6220:	85 ee       	ldi	r24, 0xE5	; 229
    6222:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6226:	f8 01       	movw	r30, r16
    6228:	81 83       	std	Z+1, r24	; 0x01
    622a:	84 ee       	ldi	r24, 0xE4	; 228
    622c:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6230:	f8 01       	movw	r30, r16
    6232:	80 83       	st	Z, r24
    6234:	1f 91       	pop	r17
    6236:	0f 91       	pop	r16
    6238:	08 95       	ret

0000623a <enc28j60hasRxPkt>:
}

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
  if( enc28j60Read(EPKTCNT) ==0 )
    623a:	89 e3       	ldi	r24, 0x39	; 57
    623c:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6240:	81 11       	cpse	r24, r1
    6242:	81 e0       	ldi	r24, 0x01	; 1
  {
    return(0);
  }
  return(1);
}
    6244:	08 95       	ret

00006246 <enc28j60getrev>:
}

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
  return(enc28j60Read(EREVID));
    6246:	82 e7       	ldi	r24, 0x72	; 114
    6248:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
}
    624c:	08 95       	ret

0000624e <nicPoll>:
    624e:	cf 92       	push	r12
    6250:	df 92       	push	r13
    6252:	ef 92       	push	r14
    6254:	ff 92       	push	r15
    6256:	0f 93       	push	r16
    6258:	1f 93       	push	r17
    625a:	cf 93       	push	r28
    625c:	df 93       	push	r29
    625e:	89 e3       	ldi	r24, 0x39	; 57
    6260:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    6264:	88 23       	and	r24, r24
    6266:	19 f4       	brne	.+6      	; 0x626e <nicPoll+0x20>
    6268:	ee 24       	eor	r14, r14
    626a:	ff 24       	eor	r15, r15
    626c:	9d c0       	rjmp	.+314    	; 0x63a8 <nicPoll+0x15a>
    626e:	80 e0       	ldi	r24, 0x00	; 0
    6270:	60 91 91 01 	lds	r22, 0x0191
    6274:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6278:	60 91 92 01 	lds	r22, 0x0192
    627c:	81 e0       	ldi	r24, 0x01	; 1
    627e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6282:	8a e3       	ldi	r24, 0x3A	; 58
    6284:	60 e0       	ldi	r22, 0x00	; 0
    6286:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
    628a:	08 2f       	mov	r16, r24
    628c:	10 e0       	ldi	r17, 0x00	; 0
    628e:	10 93 92 01 	sts	0x0192, r17
    6292:	00 93 91 01 	sts	0x0191, r16
    6296:	8a e3       	ldi	r24, 0x3A	; 58
    6298:	60 e0       	ldi	r22, 0x00	; 0
    629a:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
    629e:	38 2f       	mov	r19, r24
    62a0:	20 e0       	ldi	r18, 0x00	; 0
    62a2:	20 2b       	or	r18, r16
    62a4:	31 2b       	or	r19, r17
    62a6:	30 93 92 01 	sts	0x0192, r19
    62aa:	20 93 91 01 	sts	0x0191, r18
    62ae:	8a e3       	ldi	r24, 0x3A	; 58
    62b0:	60 e0       	ldi	r22, 0x00	; 0
    62b2:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
    62b6:	f8 2e       	mov	r15, r24
    62b8:	8a e3       	ldi	r24, 0x3A	; 58
    62ba:	60 e0       	ldi	r22, 0x00	; 0
    62bc:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
    62c0:	d8 2e       	mov	r13, r24
    62c2:	8a e3       	ldi	r24, 0x3A	; 58
    62c4:	60 e0       	ldi	r22, 0x00	; 0
    62c6:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
    62ca:	08 2f       	mov	r16, r24
    62cc:	10 e0       	ldi	r17, 0x00	; 0
    62ce:	8a e3       	ldi	r24, 0x3A	; 58
    62d0:	60 e0       	ldi	r22, 0x00	; 0
    62d2:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
    62d6:	40 91 95 0e 	lds	r20, 0x0E95
    62da:	50 91 96 0e 	lds	r21, 0x0E96
    62de:	38 2f       	mov	r19, r24
    62e0:	20 e0       	ldi	r18, 0x00	; 0
    62e2:	20 2b       	or	r18, r16
    62e4:	31 2b       	or	r19, r17
    62e6:	27 fd       	sbrc	r18, 7
    62e8:	03 c0       	rjmp	.+6      	; 0x62f0 <nicPoll+0xa2>
    62ea:	ee 24       	eor	r14, r14
    62ec:	ff 24       	eor	r15, r15
    62ee:	2f c0       	rjmp	.+94     	; 0x634e <nicPoll+0x100>
    62f0:	ef 2c       	mov	r14, r15
    62f2:	ff 24       	eor	r15, r15
    62f4:	9d 2d       	mov	r25, r13
    62f6:	80 e0       	ldi	r24, 0x00	; 0
    62f8:	e8 2a       	or	r14, r24
    62fa:	f9 2a       	or	r15, r25
    62fc:	ca 01       	movw	r24, r20
    62fe:	01 97       	sbiw	r24, 0x01	; 1
    6300:	2c ef       	ldi	r18, 0xFC	; 252
    6302:	3f ef       	ldi	r19, 0xFF	; 255
    6304:	e2 0e       	add	r14, r18
    6306:	f3 1e       	adc	r15, r19
    6308:	8e 15       	cp	r24, r14
    630a:	9f 05       	cpc	r25, r15
    630c:	08 f4       	brcc	.+2      	; 0x6310 <nicPoll+0xc2>
    630e:	7c 01       	movw	r14, r24
    6310:	00 91 9d 0e 	lds	r16, 0x0E9D
    6314:	10 91 9e 0e 	lds	r17, 0x0E9E
    6318:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
    631c:	0e 94 aa 12 	call	0x2554	; 0x2554 <spiEnableEnc28j60>
    6320:	8a e3       	ldi	r24, 0x3A	; 58
    6322:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    6326:	68 01       	movw	r12, r16
    6328:	e7 01       	movw	r28, r14
    632a:	07 c0       	rjmp	.+14     	; 0x633a <nicPoll+0xec>
    632c:	21 97       	sbiw	r28, 0x01	; 1
    632e:	80 e0       	ldi	r24, 0x00	; 0
    6330:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    6334:	f6 01       	movw	r30, r12
    6336:	81 93       	st	Z+, r24
    6338:	6f 01       	movw	r12, r30
    633a:	20 97       	sbiw	r28, 0x00	; 0
    633c:	b9 f7       	brne	.-18     	; 0x632c <nicPoll+0xde>
    633e:	0e 0d       	add	r16, r14
    6340:	1f 1d       	adc	r17, r15
    6342:	f8 01       	movw	r30, r16
    6344:	10 82       	st	Z, r1
    6346:	0e 94 ac 12 	call	0x2558	; 0x2558 <spiDisableEnc28j60>
    634a:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
    634e:	8c e0       	ldi	r24, 0x0C	; 12
    6350:	60 91 91 01 	lds	r22, 0x0191
    6354:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6358:	60 91 92 01 	lds	r22, 0x0192
    635c:	8d e0       	ldi	r24, 0x0D	; 13
    635e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6362:	60 91 91 01 	lds	r22, 0x0191
    6366:	70 91 92 01 	lds	r23, 0x0192
    636a:	cb 01       	movw	r24, r22
    636c:	01 97       	sbiw	r24, 0x01	; 1
    636e:	8f 5f       	subi	r24, 0xFF	; 255
    6370:	99 41       	sbci	r25, 0x19	; 25
    6372:	38 f0       	brcs	.+14     	; 0x6382 <nicPoll+0x134>
    6374:	8c e0       	ldi	r24, 0x0C	; 12
    6376:	6e ef       	ldi	r22, 0xFE	; 254
    6378:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    637c:	8d e0       	ldi	r24, 0x0D	; 13
    637e:	69 e1       	ldi	r22, 0x19	; 25
    6380:	0c c0       	rjmp	.+24     	; 0x639a <nicPoll+0x14c>
    6382:	61 50       	subi	r22, 0x01	; 1
    6384:	8c e0       	ldi	r24, 0x0C	; 12
    6386:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    638a:	20 91 91 01 	lds	r18, 0x0191
    638e:	30 91 92 01 	lds	r19, 0x0192
    6392:	21 50       	subi	r18, 0x01	; 1
    6394:	30 40       	sbci	r19, 0x00	; 0
    6396:	8d e0       	ldi	r24, 0x0D	; 13
    6398:	63 2f       	mov	r22, r19
    639a:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    639e:	80 e8       	ldi	r24, 0x80	; 128
    63a0:	6e e1       	ldi	r22, 0x1E	; 30
    63a2:	40 e4       	ldi	r20, 0x40	; 64
    63a4:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    63a8:	c7 01       	movw	r24, r14
    63aa:	df 91       	pop	r29
    63ac:	cf 91       	pop	r28
    63ae:	1f 91       	pop	r17
    63b0:	0f 91       	pop	r16
    63b2:	ff 90       	pop	r15
    63b4:	ef 90       	pop	r14
    63b6:	df 90       	pop	r13
    63b8:	cf 90       	pop	r12
    63ba:	08 95       	ret

000063bc <nicSend>:
    63bc:	0f 93       	push	r16
    63be:	1f 93       	push	r17
    63c0:	cf 93       	push	r28
    63c2:	df 93       	push	r29
    63c4:	8c 01       	movw	r16, r24
    63c6:	13 c0       	rjmp	.+38     	; 0x63ee <nicSend+0x32>
    63c8:	8c e1       	ldi	r24, 0x1C	; 28
    63ca:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    63ce:	81 ff       	sbrs	r24, 1
    63d0:	0a c0       	rjmp	.+20     	; 0x63e6 <nicSend+0x2a>
    63d2:	80 e8       	ldi	r24, 0x80	; 128
    63d4:	6f e1       	ldi	r22, 0x1F	; 31
    63d6:	40 e8       	ldi	r20, 0x80	; 128
    63d8:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    63dc:	80 ea       	ldi	r24, 0xA0	; 160
    63de:	6f e1       	ldi	r22, 0x1F	; 31
    63e0:	40 e8       	ldi	r20, 0x80	; 128
    63e2:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    63e6:	80 e0       	ldi	r24, 0x00	; 0
    63e8:	90 e0       	ldi	r25, 0x00	; 0
    63ea:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    63ee:	80 e0       	ldi	r24, 0x00	; 0
    63f0:	6f e1       	ldi	r22, 0x1F	; 31
    63f2:	0e 94 fc 2f 	call	0x5ff8	; 0x5ff8 <enc28j60ReadOp>
    63f6:	83 fd       	sbrc	r24, 3
    63f8:	e7 cf       	rjmp	.-50     	; 0x63c8 <nicSend+0xc>
    63fa:	82 e0       	ldi	r24, 0x02	; 2
    63fc:	6f ef       	ldi	r22, 0xFF	; 255
    63fe:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6402:	83 e0       	ldi	r24, 0x03	; 3
    6404:	69 e1       	ldi	r22, 0x19	; 25
    6406:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    640a:	60 2f       	mov	r22, r16
    640c:	61 50       	subi	r22, 0x01	; 1
    640e:	86 e0       	ldi	r24, 0x06	; 6
    6410:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6414:	98 01       	movw	r18, r16
    6416:	21 50       	subi	r18, 0x01	; 1
    6418:	36 4e       	sbci	r19, 0xE6	; 230
    641a:	87 e0       	ldi	r24, 0x07	; 7
    641c:	63 2f       	mov	r22, r19
    641e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6422:	8a e7       	ldi	r24, 0x7A	; 122
    6424:	60 e0       	ldi	r22, 0x00	; 0
    6426:	40 e0       	ldi	r20, 0x00	; 0
    6428:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    642c:	c0 91 9d 0e 	lds	r28, 0x0E9D
    6430:	d0 91 9e 0e 	lds	r29, 0x0E9E
    6434:	0e 94 c6 21 	call	0x438c	; 0x438c <spiTake>
    6438:	0e 94 aa 12 	call	0x2554	; 0x2554 <spiEnableEnc28j60>
    643c:	8a e7       	ldi	r24, 0x7A	; 122
    643e:	03 c0       	rjmp	.+6      	; 0x6446 <nicSend+0x8a>
    6440:	01 50       	subi	r16, 0x01	; 1
    6442:	10 40       	sbci	r17, 0x00	; 0
    6444:	89 91       	ld	r24, Y+
    6446:	0e 94 16 13 	call	0x262c	; 0x262c <spiSend>
    644a:	01 15       	cp	r16, r1
    644c:	11 05       	cpc	r17, r1
    644e:	c1 f7       	brne	.-16     	; 0x6440 <nicSend+0x84>
    6450:	0e 94 ac 12 	call	0x2558	; 0x2558 <spiDisableEnc28j60>
    6454:	0e 94 ba 21 	call	0x4374	; 0x4374 <spiGive>
    6458:	80 e8       	ldi	r24, 0x80	; 128
    645a:	6f e1       	ldi	r22, 0x1F	; 31
    645c:	48 e0       	ldi	r20, 0x08	; 8
    645e:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    6462:	df 91       	pop	r29
    6464:	cf 91       	pop	r28
    6466:	1f 91       	pop	r17
    6468:	0f 91       	pop	r16
    646a:	08 95       	ret

0000646c <enc28j60linkup>:

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
  // Set the right address and start the register read operation
  enc28j60Write(MIREGADR, address);
    646c:	84 ed       	ldi	r24, 0xD4	; 212
    646e:	61 e1       	ldi	r22, 0x11	; 17
    6470:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
  enc28j60Write(MICMD, MICMD_MIIRD);
    6474:	82 ed       	ldi	r24, 0xD2	; 210
    6476:	61 e0       	ldi	r22, 0x01	; 1
    6478:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
   vTaskDelay ( 0 ); //FIXME by moe tutaj nastpuje zawieszenie
    647c:	80 e0       	ldi	r24, 0x00	; 0
    647e:	90 e0       	ldi	r25, 0x00	; 0
    6480:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
  enc28j60Write(MICMD, MICMD_MIIRD);
  
  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    6484:	8a ee       	ldi	r24, 0xEA	; 234
    6486:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    648a:	80 fd       	sbrc	r24, 0
    648c:	f7 cf       	rjmp	.-18     	; 0x647c <enc28j60linkup+0x10>
   vTaskDelay ( 0 ); //FIXME by moe tutaj nastpuje zawieszenie

  // reset reading bit
  enc28j60Write(MICMD, 0x00);
    648e:	82 ed       	ldi	r24, 0xD2	; 210
    6490:	60 e0       	ldi	r22, 0x00	; 0
    6492:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>

  return (enc28j60Read(MIRDH));
    6496:	89 ed       	ldi	r24, 0xD9	; 217
    6498:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    649c:	81 11       	cpse	r24, r1
    649e:	81 e0       	ldi	r24, 0x01	; 1
// link status
uint8_t enc28j60linkup(void)
{
  // bit 10 (= bit 3 in upper reg)
  return(enc28j60PhyReadH(PHSTAT2) && 4);
}
    64a0:	08 95       	ret

000064a2 <enc28j60PhyWrite>:
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    64a2:	0f 93       	push	r16
    64a4:	1f 93       	push	r17
    64a6:	98 2f       	mov	r25, r24
    64a8:	16 2f       	mov	r17, r22
    64aa:	07 2f       	mov	r16, r23
  // set the PHY register address
  enc28j60Write(MIREGADR, address);
    64ac:	84 ed       	ldi	r24, 0xD4	; 212
    64ae:	69 2f       	mov	r22, r25
    64b0:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
  // write the PHY data
  enc28j60Write(MIWRL, data);
    64b4:	86 ed       	ldi	r24, 0xD6	; 214
    64b6:	61 2f       	mov	r22, r17
    64b8:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
  enc28j60Write(MIWRH, data>>8);
    64bc:	87 ed       	ldi	r24, 0xD7	; 215
    64be:	60 2f       	mov	r22, r16
    64c0:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    64c4:	04 c0       	rjmp	.+8      	; 0x64ce <enc28j60PhyWrite+0x2c>
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
  {
    vTaskDelay ( 0 );         //FIXME by moe tutaj nastpuje zakleszczenie
    64c6:	80 e0       	ldi	r24, 0x00	; 0
    64c8:	90 e0       	ldi	r25, 0x00	; 0
    64ca:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
  // write the PHY data
  enc28j60Write(MIWRL, data);
  enc28j60Write(MIWRH, data>>8);
  // wait until the PHY write completes
  
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    64ce:	8a ee       	ldi	r24, 0xEA	; 234
    64d0:	0e 94 1b 30 	call	0x6036	; 0x6036 <enc28j60Read>
    64d4:	80 fd       	sbrc	r24, 0
    64d6:	f7 cf       	rjmp	.-18     	; 0x64c6 <enc28j60PhyWrite+0x24>
  {
    vTaskDelay ( 0 );         //FIXME by moe tutaj nastpuje zakleszczenie
  }
}
    64d8:	1f 91       	pop	r17
    64da:	0f 91       	pop	r16
    64dc:	08 95       	ret

000064de <nicMacInit>:
    64de:	85 e0       	ldi	r24, 0x05	; 5
    64e0:	90 e0       	ldi	r25, 0x00	; 0
    64e2:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    64e6:	1a 98       	cbi	0x03, 2	; 3
    64e8:	85 e0       	ldi	r24, 0x05	; 5
    64ea:	90 e0       	ldi	r25, 0x00	; 0
    64ec:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    64f0:	1a 9a       	sbi	0x03, 2	; 3
    64f2:	85 e0       	ldi	r24, 0x05	; 5
    64f4:	90 e0       	ldi	r25, 0x00	; 0
    64f6:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    64fa:	10 92 92 01 	sts	0x0192, r1
    64fe:	10 92 91 01 	sts	0x0191, r1
    6502:	88 e0       	ldi	r24, 0x08	; 8
    6504:	60 e0       	ldi	r22, 0x00	; 0
    6506:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    650a:	89 e0       	ldi	r24, 0x09	; 9
    650c:	60 e0       	ldi	r22, 0x00	; 0
    650e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6512:	8c e0       	ldi	r24, 0x0C	; 12
    6514:	60 e0       	ldi	r22, 0x00	; 0
    6516:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    651a:	8d e0       	ldi	r24, 0x0D	; 13
    651c:	60 e0       	ldi	r22, 0x00	; 0
    651e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6522:	8a e0       	ldi	r24, 0x0A	; 10
    6524:	6e ef       	ldi	r22, 0xFE	; 254
    6526:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    652a:	8b e0       	ldi	r24, 0x0B	; 11
    652c:	69 e1       	ldi	r22, 0x19	; 25
    652e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6532:	84 e0       	ldi	r24, 0x04	; 4
    6534:	6f ef       	ldi	r22, 0xFF	; 255
    6536:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    653a:	85 e0       	ldi	r24, 0x05	; 5
    653c:	69 e1       	ldi	r22, 0x19	; 25
    653e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6542:	86 e0       	ldi	r24, 0x06	; 6
    6544:	6f ef       	ldi	r22, 0xFF	; 255
    6546:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    654a:	87 e0       	ldi	r24, 0x07	; 7
    654c:	6f e1       	ldi	r22, 0x1F	; 31
    654e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6552:	88 e3       	ldi	r24, 0x38	; 56
    6554:	62 eb       	ldi	r22, 0xB2	; 178
    6556:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    655a:	88 e2       	ldi	r24, 0x28	; 40
    655c:	6f e3       	ldi	r22, 0x3F	; 63
    655e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6562:	89 e2       	ldi	r24, 0x29	; 41
    6564:	60 e3       	ldi	r22, 0x30	; 48
    6566:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    656a:	80 e3       	ldi	r24, 0x30	; 48
    656c:	69 ef       	ldi	r22, 0xF9	; 249
    656e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6572:	81 e3       	ldi	r24, 0x31	; 49
    6574:	67 ef       	ldi	r22, 0xF7	; 247
    6576:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    657a:	80 ec       	ldi	r24, 0xC0	; 192
    657c:	6d e0       	ldi	r22, 0x0D	; 13
    657e:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    6582:	81 ec       	ldi	r24, 0xC1	; 193
    6584:	60 e0       	ldi	r22, 0x00	; 0
    6586:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    658a:	80 e8       	ldi	r24, 0x80	; 128
    658c:	62 ec       	ldi	r22, 0xC2	; 194
    658e:	42 e3       	ldi	r20, 0x32	; 50
    6590:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    6594:	86 ec       	ldi	r24, 0xC6	; 198
    6596:	62 e1       	ldi	r22, 0x12	; 18
    6598:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    659c:	87 ec       	ldi	r24, 0xC7	; 199
    659e:	6c e0       	ldi	r22, 0x0C	; 12
    65a0:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    65a4:	84 ec       	ldi	r24, 0xC4	; 196
    65a6:	62 e1       	ldi	r22, 0x12	; 18
    65a8:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    65ac:	8a ec       	ldi	r24, 0xCA	; 202
    65ae:	6c ed       	ldi	r22, 0xDC	; 220
    65b0:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    65b4:	8b ec       	ldi	r24, 0xCB	; 203
    65b6:	65 e0       	ldi	r22, 0x05	; 5
    65b8:	0e 94 ca 2f 	call	0x5f94	; 0x5f94 <enc28j60Write>
    65bc:	87 e9       	ldi	r24, 0x97	; 151
    65be:	9e e0       	ldi	r25, 0x0E	; 14
    65c0:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <nicSetMacAddress>
    65c4:	80 e1       	ldi	r24, 0x10	; 16
    65c6:	60 e0       	ldi	r22, 0x00	; 0
    65c8:	71 e0       	ldi	r23, 0x01	; 1
    65ca:	0e 94 51 32 	call	0x64a2	; 0x64a2 <enc28j60PhyWrite>
    65ce:	8f e1       	ldi	r24, 0x1F	; 31
    65d0:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <enc28j60SetBank>
    65d4:	80 e8       	ldi	r24, 0x80	; 128
    65d6:	6b e1       	ldi	r22, 0x1B	; 27
    65d8:	40 ec       	ldi	r20, 0xC0	; 192
    65da:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    65de:	80 e8       	ldi	r24, 0x80	; 128
    65e0:	6f e1       	ldi	r22, 0x1F	; 31
    65e2:	44 e0       	ldi	r20, 0x04	; 4
    65e4:	0e 94 8c 2f 	call	0x5f18	; 0x5f18 <enc28j60WriteOp>
    65e8:	85 e0       	ldi	r24, 0x05	; 5
    65ea:	90 e0       	ldi	r25, 0x00	; 0
    65ec:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    65f0:	84 e1       	ldi	r24, 0x14	; 20
    65f2:	66 e7       	ldi	r22, 0x76	; 118
    65f4:	74 e0       	ldi	r23, 0x04	; 4
    65f6:	0e 94 51 32 	call	0x64a2	; 0x64a2 <enc28j60PhyWrite>
    65fa:	82 e0       	ldi	r24, 0x02	; 2
    65fc:	90 e0       	ldi	r25, 0x00	; 0
    65fe:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    6602:	08 95       	ret

00006604 <initQueueStream>:

static int streamQueueOutputFun(char c, FILE *ostream);
static int streamQueueInputFun(FILE *istream);

void initQueueStream(FILE *stream, streamBuffers_t *buffer, xQueueHandle Rx, xQueueHandle Tx)
{
    6604:	fc 01       	movw	r30, r24
    6606:	db 01       	movw	r26, r22
  fdev_setup_stream(stream, streamQueueOutputFun, streamQueueInputFun, _FDEV_SETUP_RW);
    6608:	85 e3       	ldi	r24, 0x35	; 53
    660a:	93 e3       	ldi	r25, 0x33	; 51
    660c:	91 87       	std	Z+9, r25	; 0x09
    660e:	80 87       	std	Z+8, r24	; 0x08
    6610:	88 e1       	ldi	r24, 0x18	; 24
    6612:	93 e3       	ldi	r25, 0x33	; 51
    6614:	93 87       	std	Z+11, r25	; 0x0b
    6616:	82 87       	std	Z+10, r24	; 0x0a
    6618:	83 e0       	ldi	r24, 0x03	; 3
    661a:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, (void *)buffer);
    661c:	75 87       	std	Z+13, r23	; 0x0d
    661e:	64 87       	std	Z+12, r22	; 0x0c
  buffer->Rx = Rx;
    6620:	11 96       	adiw	r26, 0x01	; 1
    6622:	5c 93       	st	X, r21
    6624:	4e 93       	st	-X, r20
  buffer->Tx = Tx;
    6626:	13 96       	adiw	r26, 0x03	; 3
    6628:	3c 93       	st	X, r19
    662a:	2e 93       	st	-X, r18
    662c:	12 97       	sbiw	r26, 0x02	; 2
  return;
}
    662e:	08 95       	ret

00006630 <streamQueueInputFun>:
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
  return 0;
}

static int streamQueueInputFun(FILE *istream)
{
    6630:	df 93       	push	r29
    6632:	cf 93       	push	r28
    6634:	0f 92       	push	r0
    6636:	cd b7       	in	r28, 0x3d	; 61
    6638:	de b7       	in	r29, 0x3e	; 62
  char c;
  streamBuffers_t *strBuf = (streamBuffers_t *) istream->udata;
  xQueueReceive(strBuf->Rx, &c, portMAX_DELAY);
    663a:	dc 01       	movw	r26, r24
    663c:	1c 96       	adiw	r26, 0x0c	; 12
    663e:	ed 91       	ld	r30, X+
    6640:	fc 91       	ld	r31, X
    6642:	1d 97       	sbiw	r26, 0x0d	; 13
    6644:	80 81       	ld	r24, Z
    6646:	91 81       	ldd	r25, Z+1	; 0x01
    6648:	be 01       	movw	r22, r28
    664a:	6f 5f       	subi	r22, 0xFF	; 255
    664c:	7f 4f       	sbci	r23, 0xFF	; 255
    664e:	4f ef       	ldi	r20, 0xFF	; 255
    6650:	5f ef       	ldi	r21, 0xFF	; 255
    6652:	20 e0       	ldi	r18, 0x00	; 0
    6654:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    6658:	29 81       	ldd	r18, Y+1	; 0x01
    665a:	33 27       	eor	r19, r19
    665c:	27 fd       	sbrc	r18, 7
    665e:	30 95       	com	r19
  return c;
}
    6660:	c9 01       	movw	r24, r18
    6662:	0f 90       	pop	r0
    6664:	cf 91       	pop	r28
    6666:	df 91       	pop	r29
    6668:	08 95       	ret

0000666a <streamQueueOutputFun>:
  buffer->Tx = Tx;
  return;
}

static int streamQueueOutputFun(char c, FILE *ostream)
{
    666a:	df 93       	push	r29
    666c:	cf 93       	push	r28
    666e:	0f 92       	push	r0
    6670:	cd b7       	in	r28, 0x3d	; 61
    6672:	de b7       	in	r29, 0x3e	; 62
    6674:	89 83       	std	Y+1, r24	; 0x01
    6676:	fb 01       	movw	r30, r22
/*  if (xQueueSend( strBuf->Tx, &c, strBuf->tx_timeout))
  {
    return EOF;
  }
  else*/
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
    6678:	04 84       	ldd	r0, Z+12	; 0x0c
    667a:	f5 85       	ldd	r31, Z+13	; 0x0d
    667c:	e0 2d       	mov	r30, r0
    667e:	82 81       	ldd	r24, Z+2	; 0x02
    6680:	93 81       	ldd	r25, Z+3	; 0x03
    6682:	be 01       	movw	r22, r28
    6684:	6f 5f       	subi	r22, 0xFF	; 255
    6686:	7f 4f       	sbci	r23, 0xFF	; 255
    6688:	4f ef       	ldi	r20, 0xFF	; 255
    668a:	5f ef       	ldi	r21, 0xFF	; 255
    668c:	20 e0       	ldi	r18, 0x00	; 0
    668e:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>
  return 0;
}
    6692:	80 e0       	ldi	r24, 0x00	; 0
    6694:	90 e0       	ldi	r25, 0x00	; 0
    6696:	0f 90       	pop	r0
    6698:	cf 91       	pop	r28
    669a:	df 91       	pop	r29
    669c:	08 95       	ret
    669e:	08 95       	ret
    66a0:	08 95       	ret
    66a2:	80 e0       	ldi	r24, 0x00	; 0
    66a4:	90 e0       	ldi	r25, 0x00	; 0
    66a6:	08 95       	ret
    66a8:	00 d0       	rcall	.+0      	; 0x66aa <streamQueueOutputFun+0x40>
    66aa:	00 d0       	rcall	.+0      	; 0x66ac <streamQueueOutputFun+0x42>
    66ac:	ed b7       	in	r30, 0x3d	; 61
    66ae:	fe b7       	in	r31, 0x3e	; 62
    66b0:	92 83       	std	Z+2, r25	; 0x02
    66b2:	81 83       	std	Z+1, r24	; 0x01
    66b4:	8b e5       	ldi	r24, 0x5B	; 91
    66b6:	9c e0       	ldi	r25, 0x0C	; 12
    66b8:	94 83       	std	Z+4, r25	; 0x04
    66ba:	83 83       	std	Z+3, r24	; 0x03
    66bc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    66c0:	0f 90       	pop	r0
    66c2:	0f 90       	pop	r0
    66c4:	0f 90       	pop	r0
    66c6:	0f 90       	pop	r0
    66c8:	08 95       	ret
    66ca:	bc 01       	movw	r22, r24
    66cc:	87 e9       	ldi	r24, 0x97	; 151
    66ce:	9e e0       	ldi	r25, 0x0E	; 14
    66d0:	46 e0       	ldi	r20, 0x06	; 6
    66d2:	50 e0       	ldi	r21, 0x00	; 0
    66d4:	0e 94 8a 74 	call	0xe914	; 0xe914 <strncpy>
    66d8:	0e 94 6f 32 	call	0x64de	; 0x64de <nicMacInit>
    66dc:	08 95       	ret
    66de:	67 e9       	ldi	r22, 0x97	; 151
    66e0:	7e e0       	ldi	r23, 0x0E	; 14
    66e2:	46 e0       	ldi	r20, 0x06	; 6
    66e4:	50 e0       	ldi	r21, 0x00	; 0
    66e6:	0e 94 8a 74 	call	0xe914	; 0xe914 <strncpy>
    66ea:	08 95       	ret

000066ec <nicInit>:
unsigned int nicPoll(void)                                       { return 0; }


static void nicBufferInit(void)
{
  nicState.bufferSize  = NETWORK_STACK_BUF_SIZE;
    66ec:	20 e0       	ldi	r18, 0x00	; 0
    66ee:	36 e0       	ldi	r19, 0x06	; 6
    66f0:	30 93 96 0e 	sts	0x0E96, r19
    66f4:	20 93 95 0e 	sts	0x0E95, r18
  nicState.layer2.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR);
    66f8:	e0 e0       	ldi	r30, 0x00	; 0
    66fa:	fa e7       	ldi	r31, 0x7A	; 122
    66fc:	f0 93 9e 0e 	sts	0x0E9E, r31
    6700:	e0 93 9d 0e 	sts	0x0E9D, r30
  nicState.layer3.ip   = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  nicState.layer4.icmp = (struct  netIcmpHeader *)(NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN + IP_HEADER_LEN);
    6704:	82 e2       	ldi	r24, 0x22	; 34
    6706:	9a e7       	ldi	r25, 0x7A	; 122
    6708:	90 93 a2 0e 	sts	0x0EA2, r25
    670c:	80 93 a1 0e 	sts	0x0EA1, r24
  #if IPV6_SUPPORT
  nicState.layer3.ipv6 = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
  nicState.layer3.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); 
    6710:	8e e0       	ldi	r24, 0x0E	; 14
    6712:	9a e7       	ldi	r25, 0x7A	; 122
    6714:	90 93 a0 0e 	sts	0x0EA0, r25
    6718:	80 93 9f 0e 	sts	0x0E9F, r24
  //nicState.layer4.icmpv6  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  #endif /*IPV6_SUPPORT*/
  memset(nicState.layer2.buf, 0, nicState.bufferSize);
    671c:	df 01       	movw	r26, r30
    671e:	c9 01       	movw	r24, r18
    6720:	1d 92       	st	X+, r1
    6722:	01 97       	sbiw	r24, 0x01	; 1
    6724:	e9 f7       	brne	.-6      	; 0x6720 <nicInit+0x34>
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
    6726:	87 e9       	ldi	r24, 0x97	; 151
    6728:	9e e0       	ldi	r25, 0x0E	; 14
    672a:	68 e1       	ldi	r22, 0x18	; 24
    672c:	70 e0       	ldi	r23, 0x00	; 0
    672e:	46 e0       	ldi	r20, 0x06	; 6
    6730:	50 e0       	ldi	r21, 0x00	; 0
    6732:	0e 94 c3 77 	call	0xef86	; 0xef86 <__eerd_block_m128>
}

void nicInit()
{
  nicBufferInit();
  nicMacInit();
    6736:	0e 94 6f 32 	call	0x64de	; 0x64de <nicMacInit>
}
    673a:	08 95       	ret

0000673c <saveNic>:
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
}

void saveNic(void)
{
  eeprom_update_block(&nicState.mac.addr, mymac_eep, 6);
    673c:	87 e9       	ldi	r24, 0x97	; 151
    673e:	9e e0       	ldi	r25, 0x0E	; 14
    6740:	68 e1       	ldi	r22, 0x18	; 24
    6742:	70 e0       	ldi	r23, 0x00	; 0
    6744:	46 e0       	ldi	r20, 0x06	; 6
    6746:	50 e0       	ldi	r21, 0x00	; 0
    6748:	0e 94 df 77 	call	0xefbe	; 0xefbe <__eeupd_block_m128>
}
    674c:	08 95       	ret

0000674e <htons>:

#include "net.h"


uint16_t htons(uint16_t val)
{
    674e:	28 2f       	mov	r18, r24
  return (val<<8) | (val>>8);
}
    6750:	89 2f       	mov	r24, r25
    6752:	92 2f       	mov	r25, r18
    6754:	08 95       	ret

00006756 <htonl>:

uint32_t htonl(uint32_t val)
{
    6756:	ef 92       	push	r14
    6758:	ff 92       	push	r15
    675a:	0f 93       	push	r16
    675c:	1f 93       	push	r17
    675e:	f6 2e       	mov	r15, r22
    6760:	e7 2e       	mov	r14, r23
    6762:	00 e0       	ldi	r16, 0x00	; 0
    6764:	10 e0       	ldi	r17, 0x00	; 0
    6766:	87 01       	movw	r16, r14
    6768:	ff 24       	eor	r15, r15
    676a:	ee 24       	eor	r14, r14
    676c:	bc 01       	movw	r22, r24
    676e:	88 27       	eor	r24, r24
    6770:	99 27       	eor	r25, r25
    6772:	36 2f       	mov	r19, r22
    6774:	27 2f       	mov	r18, r23
    6776:	40 e0       	ldi	r20, 0x00	; 0
    6778:	50 e0       	ldi	r21, 0x00	; 0
    677a:	e2 2a       	or	r14, r18
    677c:	f3 2a       	or	r15, r19
    677e:	04 2b       	or	r16, r20
    6780:	15 2b       	or	r17, r21
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
}
    6782:	b7 01       	movw	r22, r14
    6784:	c8 01       	movw	r24, r16
    6786:	1f 91       	pop	r17
    6788:	0f 91       	pop	r16
    678a:	ff 90       	pop	r15
    678c:	ef 90       	pop	r14
    678e:	08 95       	ret

00006790 <netChecksum>:


uint16_t netChecksum(uint8_t *data, uint16_t len)
{
    6790:	0f 93       	push	r16
    6792:	1f 93       	push	r17
    6794:	cf 93       	push	r28
    6796:	df 93       	push	r29
    6798:	8c 01       	movw	r16, r24
    679a:	ec 01       	movw	r28, r24
    679c:	fb 01       	movw	r30, r22
    679e:	20 e0       	ldi	r18, 0x00	; 0
    67a0:	30 e0       	ldi	r19, 0x00	; 0
    67a2:	40 e0       	ldi	r20, 0x00	; 0
    67a4:	50 e0       	ldi	r21, 0x00	; 0
  register uint32_t sum = 0;

  for (;;) 
  {
    if (len < 2)
    67a6:	e2 30       	cpi	r30, 0x02	; 2
    67a8:	f1 05       	cpc	r31, r1
    67aa:	50 f0       	brcs	.+20     	; 0x67c0 <netChecksum+0x30>
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    67ac:	89 91       	ld	r24, Y+
    67ae:	99 91       	ld	r25, Y+
    67b0:	a0 e0       	ldi	r26, 0x00	; 0
    67b2:	b0 e0       	ldi	r27, 0x00	; 0
    67b4:	28 0f       	add	r18, r24
    67b6:	39 1f       	adc	r19, r25
    67b8:	4a 1f       	adc	r20, r26
    67ba:	5b 1f       	adc	r21, r27
    data+=2;
    len -= 2;
    67bc:	32 97       	sbiw	r30, 0x02	; 2
    67be:	f3 cf       	rjmp	.-26     	; 0x67a6 <netChecksum+0x16>
  }
    67c0:	fb 01       	movw	r30, r22
    67c2:	ee 7f       	andi	r30, 0xFE	; 254
    67c4:	e0 0f       	add	r30, r16
    67c6:	f1 1f       	adc	r31, r17
  if (len)
    67c8:	60 ff       	sbrs	r22, 0
    67ca:	0b c0       	rjmp	.+22     	; 0x67e2 <netChecksum+0x52>
    sum += *(uint8_t *) data;
    67cc:	80 81       	ld	r24, Z
    67ce:	28 0f       	add	r18, r24
    67d0:	31 1d       	adc	r19, r1
    67d2:	41 1d       	adc	r20, r1
    67d4:	51 1d       	adc	r21, r1
    67d6:	05 c0       	rjmp	.+10     	; 0x67e2 <netChecksum+0x52>

  while ((len = (uint16_t) (sum >> 16)) != 0)
    sum = (uint16_t) sum + len;
    67d8:	62 0f       	add	r22, r18
    67da:	73 1f       	adc	r23, r19
    67dc:	9b 01       	movw	r18, r22
    67de:	40 e0       	ldi	r20, 0x00	; 0
    67e0:	50 e0       	ldi	r21, 0x00	; 0
    len -= 2;
  }
  if (len)
    sum += *(uint8_t *) data;

  while ((len = (uint16_t) (sum >> 16)) != 0)
    67e2:	ca 01       	movw	r24, r20
    67e4:	aa 27       	eor	r26, r26
    67e6:	bb 27       	eor	r27, r27
    67e8:	bc 01       	movw	r22, r24
    67ea:	89 2b       	or	r24, r25
    67ec:	a9 f7       	brne	.-22     	; 0x67d8 <netChecksum+0x48>
    67ee:	20 95       	com	r18
    67f0:	30 95       	com	r19
    sum = (uint16_t) sum + len;

  return (uint16_t) sum ^ 0xFFFF;
}
    67f2:	c9 01       	movw	r24, r18
    67f4:	df 91       	pop	r29
    67f6:	cf 91       	pop	r28
    67f8:	1f 91       	pop	r17
    67fa:	0f 91       	pop	r16
    67fc:	08 95       	ret

000067fe <netPrintTcpHeader>:
  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
}

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
    67fe:	cf 92       	push	r12
    6800:	df 92       	push	r13
    6802:	ef 92       	push	r14
    6804:	ff 92       	push	r15
    6806:	0f 93       	push	r16
    6808:	1f 93       	push	r17
    680a:	cf 93       	push	r28
    680c:	df 93       	push	r29
    680e:	6c 01       	movw	r12, r24
    6810:	eb 01       	movw	r28, r22
  fprintf_P(stream, PSTR("TCP Header\r\n"));
    6812:	00 d0       	rcall	.+0      	; 0x6814 <netPrintTcpHeader+0x16>
    6814:	00 d0       	rcall	.+0      	; 0x6816 <netPrintTcpHeader+0x18>
    6816:	ad b7       	in	r26, 0x3d	; 61
    6818:	be b7       	in	r27, 0x3e	; 62
    681a:	12 96       	adiw	r26, 0x02	; 2
    681c:	9c 93       	st	X, r25
    681e:	8e 93       	st	-X, r24
    6820:	11 97       	sbiw	r26, 0x01	; 1
    6822:	84 ee       	ldi	r24, 0xE4	; 228
    6824:	9c e0       	ldi	r25, 0x0C	; 12
    6826:	14 96       	adiw	r26, 0x04	; 4
    6828:	9c 93       	st	X, r25
    682a:	8e 93       	st	-X, r24
    682c:	13 97       	sbiw	r26, 0x03	; 3
    682e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    6832:	00 d0       	rcall	.+0      	; 0x6834 <netPrintTcpHeader+0x36>
    6834:	ed b7       	in	r30, 0x3d	; 61
    6836:	fe b7       	in	r31, 0x3e	; 62
    6838:	31 96       	adiw	r30, 0x01	; 1
    683a:	ad b7       	in	r26, 0x3d	; 61
    683c:	be b7       	in	r27, 0x3e	; 62
    683e:	12 96       	adiw	r26, 0x02	; 2
    6840:	dc 92       	st	X, r13
    6842:	ce 92       	st	-X, r12
    6844:	11 97       	sbiw	r26, 0x01	; 1
    6846:	85 ed       	ldi	r24, 0xD5	; 213
    6848:	9c e0       	ldi	r25, 0x0C	; 12
    684a:	93 83       	std	Z+3, r25	; 0x03
    684c:	82 83       	std	Z+2, r24	; 0x02
    684e:	98 81       	ld	r25, Y
    6850:	89 81       	ldd	r24, Y+1	; 0x01
    6852:	84 83       	std	Z+4, r24	; 0x04
    6854:	95 83       	std	Z+5, r25	; 0x05
    6856:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    685a:	ed b7       	in	r30, 0x3d	; 61
    685c:	fe b7       	in	r31, 0x3e	; 62
    685e:	31 96       	adiw	r30, 0x01	; 1
    6860:	ad b7       	in	r26, 0x3d	; 61
    6862:	be b7       	in	r27, 0x3e	; 62
    6864:	12 96       	adiw	r26, 0x02	; 2
    6866:	dc 92       	st	X, r13
    6868:	ce 92       	st	-X, r12
    686a:	11 97       	sbiw	r26, 0x01	; 1
    686c:	86 ec       	ldi	r24, 0xC6	; 198
    686e:	9c e0       	ldi	r25, 0x0C	; 12
    6870:	93 83       	std	Z+3, r25	; 0x03
    6872:	82 83       	std	Z+2, r24	; 0x02
    6874:	9a 81       	ldd	r25, Y+2	; 0x02
    6876:	8b 81       	ldd	r24, Y+3	; 0x03
    6878:	84 83       	std	Z+4, r24	; 0x04
    687a:	95 83       	std	Z+5, r25	; 0x05
    687c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Seq Num : 0x%x"), htonl(tcpheader->seqno));
    6880:	ec 80       	ldd	r14, Y+4	; 0x04
    6882:	fd 80       	ldd	r15, Y+5	; 0x05
    6884:	0e 81       	ldd	r16, Y+6	; 0x06
    6886:	1f 81       	ldd	r17, Y+7	; 0x07
    6888:	00 d0       	rcall	.+0      	; 0x688a <netPrintTcpHeader+0x8c>
    688a:	ed b7       	in	r30, 0x3d	; 61
    688c:	fe b7       	in	r31, 0x3e	; 62
    688e:	31 96       	adiw	r30, 0x01	; 1
    6890:	ad b7       	in	r26, 0x3d	; 61
    6892:	be b7       	in	r27, 0x3e	; 62
    6894:	12 96       	adiw	r26, 0x02	; 2
    6896:	dc 92       	st	X, r13
    6898:	ce 92       	st	-X, r12
    689a:	11 97       	sbiw	r26, 0x01	; 1
    689c:	87 eb       	ldi	r24, 0xB7	; 183
    689e:	9c e0       	ldi	r25, 0x0C	; 12
    68a0:	93 83       	std	Z+3, r25	; 0x03
    68a2:	82 83       	std	Z+2, r24	; 0x02
    68a4:	3e 2d       	mov	r19, r14
    68a6:	2f 2d       	mov	r18, r15
    68a8:	40 e0       	ldi	r20, 0x00	; 0
    68aa:	50 e0       	ldi	r21, 0x00	; 0
    68ac:	a9 01       	movw	r20, r18
    68ae:	33 27       	eor	r19, r19
    68b0:	22 27       	eor	r18, r18
    68b2:	78 01       	movw	r14, r16
    68b4:	00 27       	eor	r16, r16
    68b6:	11 27       	eor	r17, r17
    68b8:	9e 2d       	mov	r25, r14
    68ba:	8f 2d       	mov	r24, r15
    68bc:	a0 e0       	ldi	r26, 0x00	; 0
    68be:	b0 e0       	ldi	r27, 0x00	; 0
    68c0:	28 2b       	or	r18, r24
    68c2:	39 2b       	or	r19, r25
    68c4:	4a 2b       	or	r20, r26
    68c6:	5b 2b       	or	r21, r27
    68c8:	24 83       	std	Z+4, r18	; 0x04
    68ca:	35 83       	std	Z+5, r19	; 0x05
    68cc:	46 83       	std	Z+6, r20	; 0x06
    68ce:	57 83       	std	Z+7, r21	; 0x07
    68d0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Ack Num : 0x%x\r\n"), htonl(tcpheader->ackno));
    68d4:	e8 84       	ldd	r14, Y+8	; 0x08
    68d6:	f9 84       	ldd	r15, Y+9	; 0x09
    68d8:	0a 85       	ldd	r16, Y+10	; 0x0a
    68da:	1b 85       	ldd	r17, Y+11	; 0x0b
    68dc:	ed b7       	in	r30, 0x3d	; 61
    68de:	fe b7       	in	r31, 0x3e	; 62
    68e0:	31 96       	adiw	r30, 0x01	; 1
    68e2:	ad b7       	in	r26, 0x3d	; 61
    68e4:	be b7       	in	r27, 0x3e	; 62
    68e6:	12 96       	adiw	r26, 0x02	; 2
    68e8:	dc 92       	st	X, r13
    68ea:	ce 92       	st	-X, r12
    68ec:	11 97       	sbiw	r26, 0x01	; 1
    68ee:	86 ea       	ldi	r24, 0xA6	; 166
    68f0:	9c e0       	ldi	r25, 0x0C	; 12
    68f2:	93 83       	std	Z+3, r25	; 0x03
    68f4:	82 83       	std	Z+2, r24	; 0x02
    68f6:	3e 2d       	mov	r19, r14
    68f8:	2f 2d       	mov	r18, r15
    68fa:	40 e0       	ldi	r20, 0x00	; 0
    68fc:	50 e0       	ldi	r21, 0x00	; 0
    68fe:	a9 01       	movw	r20, r18
    6900:	33 27       	eor	r19, r19
    6902:	22 27       	eor	r18, r18
    6904:	78 01       	movw	r14, r16
    6906:	00 27       	eor	r16, r16
    6908:	11 27       	eor	r17, r17
    690a:	9e 2d       	mov	r25, r14
    690c:	8f 2d       	mov	r24, r15
    690e:	a0 e0       	ldi	r26, 0x00	; 0
    6910:	b0 e0       	ldi	r27, 0x00	; 0
    6912:	28 2b       	or	r18, r24
    6914:	39 2b       	or	r19, r25
    6916:	4a 2b       	or	r20, r26
    6918:	5b 2b       	or	r21, r27
    691a:	24 83       	std	Z+4, r18	; 0x04
    691c:	35 83       	std	Z+5, r19	; 0x05
    691e:	46 83       	std	Z+6, r20	; 0x06
    6920:	57 83       	std	Z+7, r21	; 0x07
    6922:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Flags   : "));
    6926:	0f 90       	pop	r0
    6928:	0f 90       	pop	r0
    692a:	0f 90       	pop	r0
    692c:	0f 90       	pop	r0
    692e:	ed b7       	in	r30, 0x3d	; 61
    6930:	fe b7       	in	r31, 0x3e	; 62
    6932:	d2 82       	std	Z+2, r13	; 0x02
    6934:	c1 82       	std	Z+1, r12	; 0x01
    6936:	8b e9       	ldi	r24, 0x9B	; 155
    6938:	9c e0       	ldi	r25, 0x0C	; 12
    693a:	94 83       	std	Z+4, r25	; 0x04
    693c:	83 83       	std	Z+3, r24	; 0x03
    693e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  if(tcpheader->flags & TCP_FLAGS_FIN)
    6942:	8d 85       	ldd	r24, Y+13	; 0x0d
    6944:	0f 90       	pop	r0
    6946:	0f 90       	pop	r0
    6948:	0f 90       	pop	r0
    694a:	0f 90       	pop	r0
    694c:	80 ff       	sbrs	r24, 0
    694e:	14 c0       	rjmp	.+40     	; 0x6978 <netPrintTcpHeader+0x17a>
    fprintf_P(stream, PSTR("FIN "));
    6950:	00 d0       	rcall	.+0      	; 0x6952 <netPrintTcpHeader+0x154>
    6952:	00 d0       	rcall	.+0      	; 0x6954 <netPrintTcpHeader+0x156>
    6954:	ad b7       	in	r26, 0x3d	; 61
    6956:	be b7       	in	r27, 0x3e	; 62
    6958:	12 96       	adiw	r26, 0x02	; 2
    695a:	dc 92       	st	X, r13
    695c:	ce 92       	st	-X, r12
    695e:	11 97       	sbiw	r26, 0x01	; 1
    6960:	86 e9       	ldi	r24, 0x96	; 150
    6962:	9c e0       	ldi	r25, 0x0C	; 12
    6964:	14 96       	adiw	r26, 0x04	; 4
    6966:	9c 93       	st	X, r25
    6968:	8e 93       	st	-X, r24
    696a:	13 97       	sbiw	r26, 0x03	; 3
    696c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6970:	0f 90       	pop	r0
    6972:	0f 90       	pop	r0
    6974:	0f 90       	pop	r0
    6976:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_SYN)
    6978:	8d 85       	ldd	r24, Y+13	; 0x0d
    697a:	81 ff       	sbrs	r24, 1
    697c:	10 c0       	rjmp	.+32     	; 0x699e <netPrintTcpHeader+0x1a0>
    fprintf_P(stream, PSTR("SYN "));
    697e:	00 d0       	rcall	.+0      	; 0x6980 <netPrintTcpHeader+0x182>
    6980:	00 d0       	rcall	.+0      	; 0x6982 <netPrintTcpHeader+0x184>
    6982:	ed b7       	in	r30, 0x3d	; 61
    6984:	fe b7       	in	r31, 0x3e	; 62
    6986:	d2 82       	std	Z+2, r13	; 0x02
    6988:	c1 82       	std	Z+1, r12	; 0x01
    698a:	81 e9       	ldi	r24, 0x91	; 145
    698c:	9c e0       	ldi	r25, 0x0C	; 12
    698e:	94 83       	std	Z+4, r25	; 0x04
    6990:	83 83       	std	Z+3, r24	; 0x03
    6992:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6996:	0f 90       	pop	r0
    6998:	0f 90       	pop	r0
    699a:	0f 90       	pop	r0
    699c:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_RST)
    699e:	8d 85       	ldd	r24, Y+13	; 0x0d
    69a0:	82 ff       	sbrs	r24, 2
    69a2:	14 c0       	rjmp	.+40     	; 0x69cc <netPrintTcpHeader+0x1ce>
    fprintf_P(stream, PSTR("RST "));
    69a4:	00 d0       	rcall	.+0      	; 0x69a6 <netPrintTcpHeader+0x1a8>
    69a6:	00 d0       	rcall	.+0      	; 0x69a8 <netPrintTcpHeader+0x1aa>
    69a8:	ad b7       	in	r26, 0x3d	; 61
    69aa:	be b7       	in	r27, 0x3e	; 62
    69ac:	12 96       	adiw	r26, 0x02	; 2
    69ae:	dc 92       	st	X, r13
    69b0:	ce 92       	st	-X, r12
    69b2:	11 97       	sbiw	r26, 0x01	; 1
    69b4:	8c e8       	ldi	r24, 0x8C	; 140
    69b6:	9c e0       	ldi	r25, 0x0C	; 12
    69b8:	14 96       	adiw	r26, 0x04	; 4
    69ba:	9c 93       	st	X, r25
    69bc:	8e 93       	st	-X, r24
    69be:	13 97       	sbiw	r26, 0x03	; 3
    69c0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    69c4:	0f 90       	pop	r0
    69c6:	0f 90       	pop	r0
    69c8:	0f 90       	pop	r0
    69ca:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_PSH)
    69cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    69ce:	83 ff       	sbrs	r24, 3
    69d0:	10 c0       	rjmp	.+32     	; 0x69f2 <netPrintTcpHeader+0x1f4>
    fprintf_P(stream, PSTR("PSH "));
    69d2:	00 d0       	rcall	.+0      	; 0x69d4 <netPrintTcpHeader+0x1d6>
    69d4:	00 d0       	rcall	.+0      	; 0x69d6 <netPrintTcpHeader+0x1d8>
    69d6:	ed b7       	in	r30, 0x3d	; 61
    69d8:	fe b7       	in	r31, 0x3e	; 62
    69da:	d2 82       	std	Z+2, r13	; 0x02
    69dc:	c1 82       	std	Z+1, r12	; 0x01
    69de:	87 e8       	ldi	r24, 0x87	; 135
    69e0:	9c e0       	ldi	r25, 0x0C	; 12
    69e2:	94 83       	std	Z+4, r25	; 0x04
    69e4:	83 83       	std	Z+3, r24	; 0x03
    69e6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    69ea:	0f 90       	pop	r0
    69ec:	0f 90       	pop	r0
    69ee:	0f 90       	pop	r0
    69f0:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_ACK)
    69f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    69f4:	84 ff       	sbrs	r24, 4
    69f6:	14 c0       	rjmp	.+40     	; 0x6a20 <netPrintTcpHeader+0x222>
    fprintf_P(stream, PSTR("ACK "));
    69f8:	00 d0       	rcall	.+0      	; 0x69fa <netPrintTcpHeader+0x1fc>
    69fa:	00 d0       	rcall	.+0      	; 0x69fc <netPrintTcpHeader+0x1fe>
    69fc:	ad b7       	in	r26, 0x3d	; 61
    69fe:	be b7       	in	r27, 0x3e	; 62
    6a00:	12 96       	adiw	r26, 0x02	; 2
    6a02:	dc 92       	st	X, r13
    6a04:	ce 92       	st	-X, r12
    6a06:	11 97       	sbiw	r26, 0x01	; 1
    6a08:	82 e8       	ldi	r24, 0x82	; 130
    6a0a:	9c e0       	ldi	r25, 0x0C	; 12
    6a0c:	14 96       	adiw	r26, 0x04	; 4
    6a0e:	9c 93       	st	X, r25
    6a10:	8e 93       	st	-X, r24
    6a12:	13 97       	sbiw	r26, 0x03	; 3
    6a14:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6a18:	0f 90       	pop	r0
    6a1a:	0f 90       	pop	r0
    6a1c:	0f 90       	pop	r0
    6a1e:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_URG)
    6a20:	8d 85       	ldd	r24, Y+13	; 0x0d
    6a22:	85 ff       	sbrs	r24, 5
    6a24:	10 c0       	rjmp	.+32     	; 0x6a46 <netPrintTcpHeader+0x248>
    fprintf_P(stream, PSTR("URG "));
    6a26:	00 d0       	rcall	.+0      	; 0x6a28 <netPrintTcpHeader+0x22a>
    6a28:	00 d0       	rcall	.+0      	; 0x6a2a <netPrintTcpHeader+0x22c>
    6a2a:	ed b7       	in	r30, 0x3d	; 61
    6a2c:	fe b7       	in	r31, 0x3e	; 62
    6a2e:	d2 82       	std	Z+2, r13	; 0x02
    6a30:	c1 82       	std	Z+1, r12	; 0x01
    6a32:	8d e7       	ldi	r24, 0x7D	; 125
    6a34:	9c e0       	ldi	r25, 0x0C	; 12
    6a36:	94 83       	std	Z+4, r25	; 0x04
    6a38:	83 83       	std	Z+3, r24	; 0x03
    6a3a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6a3e:	0f 90       	pop	r0
    6a40:	0f 90       	pop	r0
    6a42:	0f 90       	pop	r0
    6a44:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    6a46:	00 d0       	rcall	.+0      	; 0x6a48 <netPrintTcpHeader+0x24a>
    6a48:	00 d0       	rcall	.+0      	; 0x6a4a <netPrintTcpHeader+0x24c>
    6a4a:	ad b7       	in	r26, 0x3d	; 61
    6a4c:	be b7       	in	r27, 0x3e	; 62
    6a4e:	12 96       	adiw	r26, 0x02	; 2
    6a50:	dc 92       	st	X, r13
    6a52:	ce 92       	st	-X, r12
    6a54:	11 97       	sbiw	r26, 0x01	; 1
    6a56:	8a e7       	ldi	r24, 0x7A	; 122
    6a58:	9c e0       	ldi	r25, 0x0C	; 12
    6a5a:	14 96       	adiw	r26, 0x04	; 4
    6a5c:	9c 93       	st	X, r25
    6a5e:	8e 93       	st	-X, r24
    6a60:	13 97       	sbiw	r26, 0x03	; 3
    6a62:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6a66:	0f 90       	pop	r0
    6a68:	0f 90       	pop	r0
    6a6a:	0f 90       	pop	r0
    6a6c:	0f 90       	pop	r0
}
    6a6e:	df 91       	pop	r29
    6a70:	cf 91       	pop	r28
    6a72:	1f 91       	pop	r17
    6a74:	0f 91       	pop	r16
    6a76:	ff 90       	pop	r15
    6a78:	ef 90       	pop	r14
    6a7a:	df 90       	pop	r13
    6a7c:	cf 90       	pop	r12
    6a7e:	08 95       	ret

00006a80 <netPrintIPAddr>:
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
}

void netPrintIPAddr(FILE *stream, uint32_t ipaddr)
{
    6a80:	df 93       	push	r29
    6a82:	cf 93       	push	r28
    6a84:	00 d0       	rcall	.+0      	; 0x6a86 <netPrintIPAddr+0x6>
    6a86:	00 d0       	rcall	.+0      	; 0x6a88 <netPrintIPAddr+0x8>
    6a88:	cd b7       	in	r28, 0x3d	; 61
    6a8a:	de b7       	in	r29, 0x3e	; 62
    6a8c:	49 83       	std	Y+1, r20	; 0x01
    6a8e:	5a 83       	std	Y+2, r21	; 0x02
    6a90:	6b 83       	std	Y+3, r22	; 0x03
    6a92:	7c 83       	std	Y+4, r23	; 0x04
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
    6a94:	ae 01       	movw	r20, r28
    6a96:	4f 5f       	subi	r20, 0xFF	; 255
    6a98:	5f 4f       	sbci	r21, 0xFF	; 255
    6a9a:	2d b7       	in	r18, 0x3d	; 61
    6a9c:	3e b7       	in	r19, 0x3e	; 62
    6a9e:	2c 50       	subi	r18, 0x0C	; 12
    6aa0:	30 40       	sbci	r19, 0x00	; 0
    6aa2:	0f b6       	in	r0, 0x3f	; 63
    6aa4:	f8 94       	cli
    6aa6:	3e bf       	out	0x3e, r19	; 62
    6aa8:	0f be       	out	0x3f, r0	; 63
    6aaa:	2d bf       	out	0x3d, r18	; 61
    6aac:	ed b7       	in	r30, 0x3d	; 61
    6aae:	fe b7       	in	r31, 0x3e	; 62
    6ab0:	31 96       	adiw	r30, 0x01	; 1
    6ab2:	ad b7       	in	r26, 0x3d	; 61
    6ab4:	be b7       	in	r27, 0x3e	; 62
    6ab6:	12 96       	adiw	r26, 0x02	; 2
    6ab8:	9c 93       	st	X, r25
    6aba:	8e 93       	st	-X, r24
    6abc:	11 97       	sbiw	r26, 0x01	; 1
    6abe:	8a e9       	ldi	r24, 0x9A	; 154
    6ac0:	9d e0       	ldi	r25, 0x0D	; 13
    6ac2:	93 83       	std	Z+3, r25	; 0x03
    6ac4:	82 83       	std	Z+2, r24	; 0x02
    6ac6:	89 81       	ldd	r24, Y+1	; 0x01
    6ac8:	84 83       	std	Z+4, r24	; 0x04
    6aca:	15 82       	std	Z+5, r1	; 0x05
    6acc:	da 01       	movw	r26, r20
    6ace:	11 96       	adiw	r26, 0x01	; 1
    6ad0:	8c 91       	ld	r24, X
    6ad2:	11 97       	sbiw	r26, 0x01	; 1
    6ad4:	86 83       	std	Z+6, r24	; 0x06
    6ad6:	17 82       	std	Z+7, r1	; 0x07
    6ad8:	12 96       	adiw	r26, 0x02	; 2
    6ada:	8c 91       	ld	r24, X
    6adc:	12 97       	sbiw	r26, 0x02	; 2
    6ade:	80 87       	std	Z+8, r24	; 0x08
    6ae0:	11 86       	std	Z+9, r1	; 0x09
    6ae2:	13 96       	adiw	r26, 0x03	; 3
    6ae4:	8c 91       	ld	r24, X
    6ae6:	82 87       	std	Z+10, r24	; 0x0a
    6ae8:	13 86       	std	Z+11, r1	; 0x0b
    6aea:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6aee:	2d b7       	in	r18, 0x3d	; 61
    6af0:	3e b7       	in	r19, 0x3e	; 62
    6af2:	24 5f       	subi	r18, 0xF4	; 244
    6af4:	3f 4f       	sbci	r19, 0xFF	; 255
    6af6:	0f b6       	in	r0, 0x3f	; 63
    6af8:	f8 94       	cli
    6afa:	3e bf       	out	0x3e, r19	; 62
    6afc:	0f be       	out	0x3f, r0	; 63
    6afe:	2d bf       	out	0x3d, r18	; 61
}
    6b00:	0f 90       	pop	r0
    6b02:	0f 90       	pop	r0
    6b04:	0f 90       	pop	r0
    6b06:	0f 90       	pop	r0
    6b08:	cf 91       	pop	r28
    6b0a:	df 91       	pop	r29
    6b0c:	08 95       	ret

00006b0e <netPrintIpHeader>:
  fprintf_P(stream, PSTR("->DST:"));
  netPrintEthAddr(stream, &eth_hdr->dest);
}

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
    6b0e:	ef 92       	push	r14
    6b10:	ff 92       	push	r15
    6b12:	0f 93       	push	r16
    6b14:	1f 93       	push	r17
    6b16:	cf 93       	push	r28
    6b18:	df 93       	push	r29
    6b1a:	ec 01       	movw	r28, r24
    6b1c:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("IP Header\r\n"));
    6b1e:	00 d0       	rcall	.+0      	; 0x6b20 <netPrintIpHeader+0x12>
    6b20:	00 d0       	rcall	.+0      	; 0x6b22 <netPrintIpHeader+0x14>
    6b22:	ad b7       	in	r26, 0x3d	; 61
    6b24:	be b7       	in	r27, 0x3e	; 62
    6b26:	12 96       	adiw	r26, 0x02	; 2
    6b28:	9c 93       	st	X, r25
    6b2a:	8e 93       	st	-X, r24
    6b2c:	11 97       	sbiw	r26, 0x01	; 1
    6b2e:	8b e6       	ldi	r24, 0x6B	; 107
    6b30:	9d e0       	ldi	r25, 0x0D	; 13
    6b32:	14 96       	adiw	r26, 0x04	; 4
    6b34:	9c 93       	st	X, r25
    6b36:	8e 93       	st	-X, r24
    6b38:	13 97       	sbiw	r26, 0x03	; 3
    6b3a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
    6b3e:	00 d0       	rcall	.+0      	; 0x6b40 <netPrintIpHeader+0x32>
    6b40:	ed b7       	in	r30, 0x3d	; 61
    6b42:	fe b7       	in	r31, 0x3e	; 62
    6b44:	31 96       	adiw	r30, 0x01	; 1
    6b46:	ad b7       	in	r26, 0x3d	; 61
    6b48:	be b7       	in	r27, 0x3e	; 62
    6b4a:	12 96       	adiw	r26, 0x02	; 2
    6b4c:	dc 93       	st	X, r29
    6b4e:	ce 93       	st	-X, r28
    6b50:	11 97       	sbiw	r26, 0x01	; 1
    6b52:	8c e5       	ldi	r24, 0x5C	; 92
    6b54:	9d e0       	ldi	r25, 0x0D	; 13
    6b56:	93 83       	std	Z+3, r25	; 0x03
    6b58:	82 83       	std	Z+2, r24	; 0x02
    6b5a:	d7 01       	movw	r26, r14
    6b5c:	8c 91       	ld	r24, X
    6b5e:	82 95       	swap	r24
    6b60:	8f 70       	andi	r24, 0x0F	; 15
    6b62:	84 83       	std	Z+4, r24	; 0x04
    6b64:	15 82       	std	Z+5, r1	; 0x05
    6b66:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    6b6a:	ed b7       	in	r30, 0x3d	; 61
    6b6c:	fe b7       	in	r31, 0x3e	; 62
    6b6e:	31 96       	adiw	r30, 0x01	; 1
    6b70:	ad b7       	in	r26, 0x3d	; 61
    6b72:	be b7       	in	r27, 0x3e	; 62
    6b74:	12 96       	adiw	r26, 0x02	; 2
    6b76:	dc 93       	st	X, r29
    6b78:	ce 93       	st	-X, r28
    6b7a:	11 97       	sbiw	r26, 0x01	; 1
    6b7c:	8d e4       	ldi	r24, 0x4D	; 77
    6b7e:	9d e0       	ldi	r25, 0x0D	; 13
    6b80:	93 83       	std	Z+3, r25	; 0x03
    6b82:	82 83       	std	Z+2, r24	; 0x02
    6b84:	d7 01       	movw	r26, r14
    6b86:	12 96       	adiw	r26, 0x02	; 2
    6b88:	9c 91       	ld	r25, X
    6b8a:	12 97       	sbiw	r26, 0x02	; 2
    6b8c:	13 96       	adiw	r26, 0x03	; 3
    6b8e:	8c 91       	ld	r24, X
    6b90:	84 83       	std	Z+4, r24	; 0x04
    6b92:	95 83       	std	Z+5, r25	; 0x05
    6b94:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  if(ipheader->proto == IP_PROTO_ICMP)
    6b98:	f7 01       	movw	r30, r14
    6b9a:	21 85       	ldd	r18, Z+9	; 0x09
    6b9c:	8d b7       	in	r24, 0x3d	; 61
    6b9e:	9e b7       	in	r25, 0x3e	; 62
    6ba0:	06 96       	adiw	r24, 0x06	; 6
    6ba2:	0f b6       	in	r0, 0x3f	; 63
    6ba4:	f8 94       	cli
    6ba6:	9e bf       	out	0x3e, r25	; 62
    6ba8:	0f be       	out	0x3f, r0	; 63
    6baa:	8d bf       	out	0x3d, r24	; 61
    6bac:	21 30       	cpi	r18, 0x01	; 1
    6bae:	59 f4       	brne	.+22     	; 0x6bc6 <netPrintIpHeader+0xb8>
    fprintf_P(stream, PSTR("Protocol: ICMP\r\n"));
    6bb0:	00 d0       	rcall	.+0      	; 0x6bb2 <netPrintIpHeader+0xa4>
    6bb2:	00 d0       	rcall	.+0      	; 0x6bb4 <netPrintIpHeader+0xa6>
    6bb4:	ad b7       	in	r26, 0x3d	; 61
    6bb6:	be b7       	in	r27, 0x3e	; 62
    6bb8:	12 96       	adiw	r26, 0x02	; 2
    6bba:	dc 93       	st	X, r29
    6bbc:	ce 93       	st	-X, r28
    6bbe:	11 97       	sbiw	r26, 0x01	; 1
    6bc0:	8c e3       	ldi	r24, 0x3C	; 60
    6bc2:	9d e0       	ldi	r25, 0x0D	; 13
    6bc4:	1f c0       	rjmp	.+62     	; 0x6c04 <netPrintIpHeader+0xf6>
  else if(ipheader->proto == IP_PROTO_TCP)
    6bc6:	26 30       	cpi	r18, 0x06	; 6
    6bc8:	89 f4       	brne	.+34     	; 0x6bec <netPrintIpHeader+0xde>
    fprintf_P(stream, PSTR("Protocol: TCP\r\n"));
    6bca:	00 d0       	rcall	.+0      	; 0x6bcc <netPrintIpHeader+0xbe>
    6bcc:	00 d0       	rcall	.+0      	; 0x6bce <netPrintIpHeader+0xc0>
    6bce:	ed b7       	in	r30, 0x3d	; 61
    6bd0:	fe b7       	in	r31, 0x3e	; 62
    6bd2:	d2 83       	std	Z+2, r29	; 0x02
    6bd4:	c1 83       	std	Z+1, r28	; 0x01
    6bd6:	8c e2       	ldi	r24, 0x2C	; 44
    6bd8:	9d e0       	ldi	r25, 0x0D	; 13
    6bda:	94 83       	std	Z+4, r25	; 0x04
    6bdc:	83 83       	std	Z+3, r24	; 0x03
    6bde:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6be2:	0f 90       	pop	r0
    6be4:	0f 90       	pop	r0
    6be6:	0f 90       	pop	r0
    6be8:	0f 90       	pop	r0
    6bea:	2d c0       	rjmp	.+90     	; 0x6c46 <netPrintIpHeader+0x138>
  else if(ipheader->proto == IP_PROTO_UDP)
    6bec:	21 31       	cpi	r18, 0x11	; 17
    6bee:	79 f4       	brne	.+30     	; 0x6c0e <netPrintIpHeader+0x100>
    fprintf_P(stream, PSTR("Protocol: UDP\r\n"));
    6bf0:	00 d0       	rcall	.+0      	; 0x6bf2 <netPrintIpHeader+0xe4>
    6bf2:	00 d0       	rcall	.+0      	; 0x6bf4 <netPrintIpHeader+0xe6>
    6bf4:	ad b7       	in	r26, 0x3d	; 61
    6bf6:	be b7       	in	r27, 0x3e	; 62
    6bf8:	12 96       	adiw	r26, 0x02	; 2
    6bfa:	dc 93       	st	X, r29
    6bfc:	ce 93       	st	-X, r28
    6bfe:	11 97       	sbiw	r26, 0x01	; 1
    6c00:	8c e1       	ldi	r24, 0x1C	; 28
    6c02:	9d e0       	ldi	r25, 0x0D	; 13
    6c04:	14 96       	adiw	r26, 0x04	; 4
    6c06:	9c 93       	st	X, r25
    6c08:	8e 93       	st	-X, r24
    6c0a:	13 97       	sbiw	r26, 0x03	; 3
    6c0c:	e8 cf       	rjmp	.-48     	; 0x6bde <netPrintIpHeader+0xd0>
  else
    fprintf_P(stream, PSTR("Protocol: %d\r\n"), ipheader->proto);
    6c0e:	00 d0       	rcall	.+0      	; 0x6c10 <netPrintIpHeader+0x102>
    6c10:	00 d0       	rcall	.+0      	; 0x6c12 <netPrintIpHeader+0x104>
    6c12:	00 d0       	rcall	.+0      	; 0x6c14 <netPrintIpHeader+0x106>
    6c14:	ed b7       	in	r30, 0x3d	; 61
    6c16:	fe b7       	in	r31, 0x3e	; 62
    6c18:	31 96       	adiw	r30, 0x01	; 1
    6c1a:	ad b7       	in	r26, 0x3d	; 61
    6c1c:	be b7       	in	r27, 0x3e	; 62
    6c1e:	12 96       	adiw	r26, 0x02	; 2
    6c20:	dc 93       	st	X, r29
    6c22:	ce 93       	st	-X, r28
    6c24:	11 97       	sbiw	r26, 0x01	; 1
    6c26:	8d e0       	ldi	r24, 0x0D	; 13
    6c28:	9d e0       	ldi	r25, 0x0D	; 13
    6c2a:	93 83       	std	Z+3, r25	; 0x03
    6c2c:	82 83       	std	Z+2, r24	; 0x02
    6c2e:	24 83       	std	Z+4, r18	; 0x04
    6c30:	15 82       	std	Z+5, r1	; 0x05
    6c32:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6c36:	ed b7       	in	r30, 0x3d	; 61
    6c38:	fe b7       	in	r31, 0x3e	; 62
    6c3a:	36 96       	adiw	r30, 0x06	; 6
    6c3c:	0f b6       	in	r0, 0x3f	; 63
    6c3e:	f8 94       	cli
    6c40:	fe bf       	out	0x3e, r31	; 62
    6c42:	0f be       	out	0x3f, r0	; 63
    6c44:	ed bf       	out	0x3d, r30	; 61

  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
    6c46:	00 d0       	rcall	.+0      	; 0x6c48 <netPrintIpHeader+0x13a>
    6c48:	00 d0       	rcall	.+0      	; 0x6c4a <netPrintIpHeader+0x13c>
    6c4a:	ad b7       	in	r26, 0x3d	; 61
    6c4c:	be b7       	in	r27, 0x3e	; 62
    6c4e:	12 96       	adiw	r26, 0x02	; 2
    6c50:	dc 93       	st	X, r29
    6c52:	ce 93       	st	-X, r28
    6c54:	11 97       	sbiw	r26, 0x01	; 1
    6c56:	82 e0       	ldi	r24, 0x02	; 2
    6c58:	9d e0       	ldi	r25, 0x0D	; 13
    6c5a:	14 96       	adiw	r26, 0x04	; 4
    6c5c:	9c 93       	st	X, r25
    6c5e:	8e 93       	st	-X, r24
    6c60:	13 97       	sbiw	r26, 0x03	; 3
    6c62:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6c66:	f7 01       	movw	r30, r14
    6c68:	04 85       	ldd	r16, Z+12	; 0x0c
    6c6a:	15 85       	ldd	r17, Z+13	; 0x0d
    6c6c:	26 85       	ldd	r18, Z+14	; 0x0e
    6c6e:	37 85       	ldd	r19, Z+15	; 0x0f
    6c70:	0f 90       	pop	r0
    6c72:	0f 90       	pop	r0
    6c74:	0f 90       	pop	r0
    6c76:	0f 90       	pop	r0
    6c78:	50 2f       	mov	r21, r16
    6c7a:	41 2f       	mov	r20, r17
    6c7c:	60 e0       	ldi	r22, 0x00	; 0
    6c7e:	70 e0       	ldi	r23, 0x00	; 0
    6c80:	ba 01       	movw	r22, r20
    6c82:	55 27       	eor	r21, r21
    6c84:	44 27       	eor	r20, r20
    6c86:	89 01       	movw	r16, r18
    6c88:	22 27       	eor	r18, r18
    6c8a:	33 27       	eor	r19, r19
    6c8c:	90 2f       	mov	r25, r16
    6c8e:	81 2f       	mov	r24, r17
    6c90:	a0 e0       	ldi	r26, 0x00	; 0
    6c92:	b0 e0       	ldi	r27, 0x00	; 0
    6c94:	48 2b       	or	r20, r24
    6c96:	59 2b       	or	r21, r25
    6c98:	6a 2b       	or	r22, r26
    6c9a:	7b 2b       	or	r23, r27
    6c9c:	ce 01       	movw	r24, r28
    6c9e:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    6ca2:	00 d0       	rcall	.+0      	; 0x6ca4 <netPrintIpHeader+0x196>
    6ca4:	00 d0       	rcall	.+0      	; 0x6ca6 <netPrintIpHeader+0x198>
    6ca6:	ad b7       	in	r26, 0x3d	; 61
    6ca8:	be b7       	in	r27, 0x3e	; 62
    6caa:	12 96       	adiw	r26, 0x02	; 2
    6cac:	dc 93       	st	X, r29
    6cae:	ce 93       	st	-X, r28
    6cb0:	11 97       	sbiw	r26, 0x01	; 1
    6cb2:	8f ef       	ldi	r24, 0xFF	; 255
    6cb4:	9c e0       	ldi	r25, 0x0C	; 12
    6cb6:	14 96       	adiw	r26, 0x04	; 4
    6cb8:	9c 93       	st	X, r25
    6cba:	8e 93       	st	-X, r24
    6cbc:	13 97       	sbiw	r26, 0x03	; 3
    6cbe:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
    6cc2:	ed b7       	in	r30, 0x3d	; 61
    6cc4:	fe b7       	in	r31, 0x3e	; 62
    6cc6:	d2 83       	std	Z+2, r29	; 0x02
    6cc8:	c1 83       	std	Z+1, r28	; 0x01
    6cca:	84 ef       	ldi	r24, 0xF4	; 244
    6ccc:	9c e0       	ldi	r25, 0x0C	; 12
    6cce:	94 83       	std	Z+4, r25	; 0x04
    6cd0:	83 83       	std	Z+3, r24	; 0x03
    6cd2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6cd6:	d7 01       	movw	r26, r14
    6cd8:	50 96       	adiw	r26, 0x10	; 16
    6cda:	0d 91       	ld	r16, X+
    6cdc:	1d 91       	ld	r17, X+
    6cde:	2d 91       	ld	r18, X+
    6ce0:	3c 91       	ld	r19, X
    6ce2:	53 97       	sbiw	r26, 0x13	; 19
    6ce4:	0f 90       	pop	r0
    6ce6:	0f 90       	pop	r0
    6ce8:	0f 90       	pop	r0
    6cea:	0f 90       	pop	r0
    6cec:	50 2f       	mov	r21, r16
    6cee:	41 2f       	mov	r20, r17
    6cf0:	60 e0       	ldi	r22, 0x00	; 0
    6cf2:	70 e0       	ldi	r23, 0x00	; 0
    6cf4:	ba 01       	movw	r22, r20
    6cf6:	55 27       	eor	r21, r21
    6cf8:	44 27       	eor	r20, r20
    6cfa:	89 01       	movw	r16, r18
    6cfc:	22 27       	eor	r18, r18
    6cfe:	33 27       	eor	r19, r19
    6d00:	90 2f       	mov	r25, r16
    6d02:	81 2f       	mov	r24, r17
    6d04:	a0 e0       	ldi	r26, 0x00	; 0
    6d06:	b0 e0       	ldi	r27, 0x00	; 0
    6d08:	48 2b       	or	r20, r24
    6d0a:	59 2b       	or	r21, r25
    6d0c:	6a 2b       	or	r22, r26
    6d0e:	7b 2b       	or	r23, r27
    6d10:	ce 01       	movw	r24, r28
    6d12:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    6d16:	00 d0       	rcall	.+0      	; 0x6d18 <netPrintIpHeader+0x20a>
    6d18:	00 d0       	rcall	.+0      	; 0x6d1a <netPrintIpHeader+0x20c>
    6d1a:	ed b7       	in	r30, 0x3d	; 61
    6d1c:	fe b7       	in	r31, 0x3e	; 62
    6d1e:	d2 83       	std	Z+2, r29	; 0x02
    6d20:	c1 83       	std	Z+1, r28	; 0x01
    6d22:	81 ef       	ldi	r24, 0xF1	; 241
    6d24:	9c e0       	ldi	r25, 0x0C	; 12
    6d26:	94 83       	std	Z+4, r25	; 0x04
    6d28:	83 83       	std	Z+3, r24	; 0x03
    6d2a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6d2e:	0f 90       	pop	r0
    6d30:	0f 90       	pop	r0
    6d32:	0f 90       	pop	r0
    6d34:	0f 90       	pop	r0
}
    6d36:	df 91       	pop	r29
    6d38:	cf 91       	pop	r28
    6d3a:	1f 91       	pop	r17
    6d3c:	0f 91       	pop	r16
    6d3e:	ff 90       	pop	r15
    6d40:	ef 90       	pop	r14
    6d42:	08 95       	ret

00006d44 <netPrintEthAddr>:

  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
    6d44:	cf 93       	push	r28
    6d46:	df 93       	push	r29
    6d48:	db 01       	movw	r26, r22
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    6d4a:	2d b7       	in	r18, 0x3d	; 61
    6d4c:	3e b7       	in	r19, 0x3e	; 62
    6d4e:	20 51       	subi	r18, 0x10	; 16
    6d50:	30 40       	sbci	r19, 0x00	; 0
    6d52:	0f b6       	in	r0, 0x3f	; 63
    6d54:	f8 94       	cli
    6d56:	3e bf       	out	0x3e, r19	; 62
    6d58:	0f be       	out	0x3f, r0	; 63
    6d5a:	2d bf       	out	0x3d, r18	; 61
    6d5c:	ed b7       	in	r30, 0x3d	; 61
    6d5e:	fe b7       	in	r31, 0x3e	; 62
    6d60:	31 96       	adiw	r30, 0x01	; 1
    6d62:	cd b7       	in	r28, 0x3d	; 61
    6d64:	de b7       	in	r29, 0x3e	; 62
    6d66:	9a 83       	std	Y+2, r25	; 0x02
    6d68:	89 83       	std	Y+1, r24	; 0x01
    6d6a:	86 ea       	ldi	r24, 0xA6	; 166
    6d6c:	9d e0       	ldi	r25, 0x0D	; 13
    6d6e:	93 83       	std	Z+3, r25	; 0x03
    6d70:	82 83       	std	Z+2, r24	; 0x02
    6d72:	8c 91       	ld	r24, X
    6d74:	84 83       	std	Z+4, r24	; 0x04
    6d76:	15 82       	std	Z+5, r1	; 0x05
    6d78:	11 96       	adiw	r26, 0x01	; 1
    6d7a:	8c 91       	ld	r24, X
    6d7c:	11 97       	sbiw	r26, 0x01	; 1
    6d7e:	86 83       	std	Z+6, r24	; 0x06
    6d80:	17 82       	std	Z+7, r1	; 0x07
    6d82:	12 96       	adiw	r26, 0x02	; 2
    6d84:	8c 91       	ld	r24, X
    6d86:	12 97       	sbiw	r26, 0x02	; 2
    6d88:	80 87       	std	Z+8, r24	; 0x08
    6d8a:	11 86       	std	Z+9, r1	; 0x09
    6d8c:	13 96       	adiw	r26, 0x03	; 3
    6d8e:	8c 91       	ld	r24, X
    6d90:	13 97       	sbiw	r26, 0x03	; 3
    6d92:	82 87       	std	Z+10, r24	; 0x0a
    6d94:	13 86       	std	Z+11, r1	; 0x0b
    6d96:	14 96       	adiw	r26, 0x04	; 4
    6d98:	8c 91       	ld	r24, X
    6d9a:	14 97       	sbiw	r26, 0x04	; 4
    6d9c:	84 87       	std	Z+12, r24	; 0x0c
    6d9e:	15 86       	std	Z+13, r1	; 0x0d
    6da0:	15 96       	adiw	r26, 0x05	; 5
    6da2:	8c 91       	ld	r24, X
    6da4:	86 87       	std	Z+14, r24	; 0x0e
    6da6:	17 86       	std	Z+15, r1	; 0x0f
    6da8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6dac:	2d b7       	in	r18, 0x3d	; 61
    6dae:	3e b7       	in	r19, 0x3e	; 62
    6db0:	20 5f       	subi	r18, 0xF0	; 240
    6db2:	3f 4f       	sbci	r19, 0xFF	; 255
    6db4:	0f b6       	in	r0, 0x3f	; 63
    6db6:	f8 94       	cli
    6db8:	3e bf       	out	0x3e, r19	; 62
    6dba:	0f be       	out	0x3f, r0	; 63
    6dbc:	2d bf       	out	0x3d, r18	; 61
}
    6dbe:	df 91       	pop	r29
    6dc0:	cf 91       	pop	r28
    6dc2:	08 95       	ret

00006dc4 <netPrintEthHeader>:
{
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
}

void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
    6dc4:	cf 92       	push	r12
    6dc6:	df 92       	push	r13
    6dc8:	ef 92       	push	r14
    6dca:	ff 92       	push	r15
    6dcc:	0f 93       	push	r16
    6dce:	1f 93       	push	r17
    6dd0:	7c 01       	movw	r14, r24
    6dd2:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
    6dd4:	00 d0       	rcall	.+0      	; 0x6dd6 <netPrintEthHeader+0x12>
    6dd6:	00 d0       	rcall	.+0      	; 0x6dd8 <netPrintEthHeader+0x14>
    6dd8:	00 d0       	rcall	.+0      	; 0x6dda <netPrintEthHeader+0x16>
    6dda:	ed b7       	in	r30, 0x3d	; 61
    6ddc:	fe b7       	in	r31, 0x3e	; 62
    6dde:	31 96       	adiw	r30, 0x01	; 1
    6de0:	ad b7       	in	r26, 0x3d	; 61
    6de2:	be b7       	in	r27, 0x3e	; 62
    6de4:	12 96       	adiw	r26, 0x02	; 2
    6de6:	9c 93       	st	X, r25
    6de8:	8e 93       	st	-X, r24
    6dea:	11 97       	sbiw	r26, 0x01	; 1
    6dec:	84 e8       	ldi	r24, 0x84	; 132
    6dee:	9d e0       	ldi	r25, 0x0D	; 13
    6df0:	93 83       	std	Z+3, r25	; 0x03
    6df2:	82 83       	std	Z+2, r24	; 0x02
    6df4:	db 01       	movw	r26, r22
    6df6:	1c 96       	adiw	r26, 0x0c	; 12
    6df8:	8d 91       	ld	r24, X+
    6dfa:	9c 91       	ld	r25, X
    6dfc:	1d 97       	sbiw	r26, 0x0d	; 13
    6dfe:	95 83       	std	Z+5, r25	; 0x05
    6e00:	84 83       	std	Z+4, r24	; 0x04
    6e02:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR(" SRC:"));
    6e06:	0f 90       	pop	r0
    6e08:	0f 90       	pop	r0
    6e0a:	ed b7       	in	r30, 0x3d	; 61
    6e0c:	fe b7       	in	r31, 0x3e	; 62
    6e0e:	f2 82       	std	Z+2, r15	; 0x02
    6e10:	e1 82       	std	Z+1, r14	; 0x01
    6e12:	8e e7       	ldi	r24, 0x7E	; 126
    6e14:	9d e0       	ldi	r25, 0x0D	; 13
    6e16:	94 83       	std	Z+4, r25	; 0x04
    6e18:	83 83       	std	Z+3, r24	; 0x03
    6e1a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    6e1e:	8d b7       	in	r24, 0x3d	; 61
    6e20:	9e b7       	in	r25, 0x3e	; 62
    6e22:	0c 97       	sbiw	r24, 0x0c	; 12
    6e24:	0f b6       	in	r0, 0x3f	; 63
    6e26:	f8 94       	cli
    6e28:	9e bf       	out	0x3e, r25	; 62
    6e2a:	0f be       	out	0x3f, r0	; 63
    6e2c:	8d bf       	out	0x3d, r24	; 61
    6e2e:	ed b7       	in	r30, 0x3d	; 61
    6e30:	fe b7       	in	r31, 0x3e	; 62
    6e32:	31 96       	adiw	r30, 0x01	; 1
    6e34:	ad b7       	in	r26, 0x3d	; 61
    6e36:	be b7       	in	r27, 0x3e	; 62
    6e38:	12 96       	adiw	r26, 0x02	; 2
    6e3a:	fc 92       	st	X, r15
    6e3c:	ee 92       	st	-X, r14
    6e3e:	11 97       	sbiw	r26, 0x01	; 1
    6e40:	b6 ea       	ldi	r27, 0xA6	; 166
    6e42:	cb 2e       	mov	r12, r27
    6e44:	bd e0       	ldi	r27, 0x0D	; 13
    6e46:	db 2e       	mov	r13, r27
    6e48:	d3 82       	std	Z+3, r13	; 0x03
    6e4a:	c2 82       	std	Z+2, r12	; 0x02
    6e4c:	d8 01       	movw	r26, r16
    6e4e:	16 96       	adiw	r26, 0x06	; 6
    6e50:	8c 91       	ld	r24, X
    6e52:	16 97       	sbiw	r26, 0x06	; 6
    6e54:	84 83       	std	Z+4, r24	; 0x04
    6e56:	15 82       	std	Z+5, r1	; 0x05
    6e58:	17 96       	adiw	r26, 0x07	; 7
    6e5a:	8c 91       	ld	r24, X
    6e5c:	17 97       	sbiw	r26, 0x07	; 7
    6e5e:	86 83       	std	Z+6, r24	; 0x06
    6e60:	17 82       	std	Z+7, r1	; 0x07
    6e62:	18 96       	adiw	r26, 0x08	; 8
    6e64:	8c 91       	ld	r24, X
    6e66:	18 97       	sbiw	r26, 0x08	; 8
    6e68:	80 87       	std	Z+8, r24	; 0x08
    6e6a:	11 86       	std	Z+9, r1	; 0x09
    6e6c:	19 96       	adiw	r26, 0x09	; 9
    6e6e:	8c 91       	ld	r24, X
    6e70:	19 97       	sbiw	r26, 0x09	; 9
    6e72:	82 87       	std	Z+10, r24	; 0x0a
    6e74:	13 86       	std	Z+11, r1	; 0x0b
    6e76:	1a 96       	adiw	r26, 0x0a	; 10
    6e78:	8c 91       	ld	r24, X
    6e7a:	1a 97       	sbiw	r26, 0x0a	; 10
    6e7c:	84 87       	std	Z+12, r24	; 0x0c
    6e7e:	15 86       	std	Z+13, r1	; 0x0d
    6e80:	1b 96       	adiw	r26, 0x0b	; 11
    6e82:	8c 91       	ld	r24, X
    6e84:	86 87       	std	Z+14, r24	; 0x0e
    6e86:	17 86       	std	Z+15, r1	; 0x0f
    6e88:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
  fprintf_P(stream, PSTR(" SRC:"));
  netPrintEthAddr(stream, &eth_hdr->src);
  fprintf_P(stream, PSTR("->DST:"));
    6e8c:	ed b7       	in	r30, 0x3d	; 61
    6e8e:	fe b7       	in	r31, 0x3e	; 62
    6e90:	3c 96       	adiw	r30, 0x0c	; 12
    6e92:	0f b6       	in	r0, 0x3f	; 63
    6e94:	f8 94       	cli
    6e96:	fe bf       	out	0x3e, r31	; 62
    6e98:	0f be       	out	0x3f, r0	; 63
    6e9a:	ed bf       	out	0x3d, r30	; 61
    6e9c:	f2 82       	std	Z+2, r15	; 0x02
    6e9e:	e1 82       	std	Z+1, r14	; 0x01
    6ea0:	87 e7       	ldi	r24, 0x77	; 119
    6ea2:	9d e0       	ldi	r25, 0x0D	; 13
    6ea4:	94 83       	std	Z+4, r25	; 0x04
    6ea6:	83 83       	std	Z+3, r24	; 0x03
    6ea8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  return (uint16_t) sum ^ 0xFFFF;
}

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    6eac:	8d b7       	in	r24, 0x3d	; 61
    6eae:	9e b7       	in	r25, 0x3e	; 62
    6eb0:	0c 97       	sbiw	r24, 0x0c	; 12
    6eb2:	0f b6       	in	r0, 0x3f	; 63
    6eb4:	f8 94       	cli
    6eb6:	9e bf       	out	0x3e, r25	; 62
    6eb8:	0f be       	out	0x3f, r0	; 63
    6eba:	8d bf       	out	0x3d, r24	; 61
    6ebc:	ed b7       	in	r30, 0x3d	; 61
    6ebe:	fe b7       	in	r31, 0x3e	; 62
    6ec0:	31 96       	adiw	r30, 0x01	; 1
    6ec2:	ad b7       	in	r26, 0x3d	; 61
    6ec4:	be b7       	in	r27, 0x3e	; 62
    6ec6:	12 96       	adiw	r26, 0x02	; 2
    6ec8:	fc 92       	st	X, r15
    6eca:	ee 92       	st	-X, r14
    6ecc:	11 97       	sbiw	r26, 0x01	; 1
    6ece:	d3 82       	std	Z+3, r13	; 0x03
    6ed0:	c2 82       	std	Z+2, r12	; 0x02
    6ed2:	d8 01       	movw	r26, r16
    6ed4:	8c 91       	ld	r24, X
    6ed6:	84 83       	std	Z+4, r24	; 0x04
    6ed8:	15 82       	std	Z+5, r1	; 0x05
    6eda:	11 96       	adiw	r26, 0x01	; 1
    6edc:	8c 91       	ld	r24, X
    6ede:	11 97       	sbiw	r26, 0x01	; 1
    6ee0:	86 83       	std	Z+6, r24	; 0x06
    6ee2:	17 82       	std	Z+7, r1	; 0x07
    6ee4:	12 96       	adiw	r26, 0x02	; 2
    6ee6:	8c 91       	ld	r24, X
    6ee8:	12 97       	sbiw	r26, 0x02	; 2
    6eea:	80 87       	std	Z+8, r24	; 0x08
    6eec:	11 86       	std	Z+9, r1	; 0x09
    6eee:	13 96       	adiw	r26, 0x03	; 3
    6ef0:	8c 91       	ld	r24, X
    6ef2:	13 97       	sbiw	r26, 0x03	; 3
    6ef4:	82 87       	std	Z+10, r24	; 0x0a
    6ef6:	13 86       	std	Z+11, r1	; 0x0b
    6ef8:	14 96       	adiw	r26, 0x04	; 4
    6efa:	8c 91       	ld	r24, X
    6efc:	14 97       	sbiw	r26, 0x04	; 4
    6efe:	84 87       	std	Z+12, r24	; 0x0c
    6f00:	15 86       	std	Z+13, r1	; 0x0d
    6f02:	15 96       	adiw	r26, 0x05	; 5
    6f04:	8c 91       	ld	r24, X
    6f06:	86 87       	std	Z+14, r24	; 0x0e
    6f08:	17 86       	std	Z+15, r1	; 0x0f
    6f0a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6f0e:	ed b7       	in	r30, 0x3d	; 61
    6f10:	fe b7       	in	r31, 0x3e	; 62
    6f12:	70 96       	adiw	r30, 0x10	; 16
    6f14:	0f b6       	in	r0, 0x3f	; 63
    6f16:	f8 94       	cli
    6f18:	fe bf       	out	0x3e, r31	; 62
    6f1a:	0f be       	out	0x3f, r0	; 63
    6f1c:	ed bf       	out	0x3d, r30	; 61
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
  fprintf_P(stream, PSTR(" SRC:"));
  netPrintEthAddr(stream, &eth_hdr->src);
  fprintf_P(stream, PSTR("->DST:"));
  netPrintEthAddr(stream, &eth_hdr->dest);
}
    6f1e:	1f 91       	pop	r17
    6f20:	0f 91       	pop	r16
    6f22:	ff 90       	pop	r15
    6f24:	ef 90       	pop	r14
    6f26:	df 90       	pop	r13
    6f28:	cf 90       	pop	r12
    6f2a:	08 95       	ret

00006f2c <setIpDebug>:
}

#if IP_DEBUG
void setIpDebug(FILE *stream, uint8_t level)
{
  IpMyConfig.dbgStream = stream;
    6f2c:	90 93 77 0f 	sts	0x0F77, r25
    6f30:	80 93 76 0f 	sts	0x0F76, r24
  IpMyConfig.dbgLevel = level;
    6f34:	60 93 78 0f 	sts	0x0F78, r22
  if (level == 0)
    6f38:	66 23       	and	r22, r22
    6f3a:	21 f4       	brne	.+8      	; 0x6f44 <setIpDebug+0x18>
    IpMyConfig.dbgStream = NULL;
    6f3c:	10 92 77 0f 	sts	0x0F77, r1
    6f40:	10 92 76 0f 	sts	0x0F76, r1
    6f44:	08 95       	ret

00006f46 <ipSetConfig>:
}
#endif

void ipSetConfig(uint32_t myIp, uint32_t netmask, uint32_t gatewayIp)
{
    6f46:	ef 92       	push	r14
    6f48:	ff 92       	push	r15
    6f4a:	0f 93       	push	r16
    6f4c:	1f 93       	push	r17
  // set local addressing
  IpMyConfig.ip = myIp;
    6f4e:	60 93 6a 0f 	sts	0x0F6A, r22
    6f52:	70 93 6b 0f 	sts	0x0F6B, r23
    6f56:	80 93 6c 0f 	sts	0x0F6C, r24
    6f5a:	90 93 6d 0f 	sts	0x0F6D, r25
  IpMyConfig.netmask = netmask;
    6f5e:	20 93 6e 0f 	sts	0x0F6E, r18
    6f62:	30 93 6f 0f 	sts	0x0F6F, r19
    6f66:	40 93 70 0f 	sts	0x0F70, r20
    6f6a:	50 93 71 0f 	sts	0x0F71, r21
  IpMyConfig.gateway = gatewayIp;
    6f6e:	e0 92 72 0f 	sts	0x0F72, r14
    6f72:	f0 92 73 0f 	sts	0x0F73, r15
    6f76:	00 93 74 0f 	sts	0x0F74, r16
    6f7a:	10 93 75 0f 	sts	0x0F75, r17
}
    6f7e:	1f 91       	pop	r17
    6f80:	0f 91       	pop	r16
    6f82:	ff 90       	pop	r15
    6f84:	ef 90       	pop	r14
    6f86:	08 95       	ret

00006f88 <ipSetConfigIp>:

void ipSetConfigIp(uint32_t myIp)
{
  // set local addressing
  IpMyConfig.ip = myIp; 
    6f88:	60 93 6a 0f 	sts	0x0F6A, r22
    6f8c:	70 93 6b 0f 	sts	0x0F6B, r23
    6f90:	80 93 6c 0f 	sts	0x0F6C, r24
    6f94:	90 93 6d 0f 	sts	0x0F6D, r25
}
    6f98:	08 95       	ret

00006f9a <ipSetConfigMask>:

void ipSetConfigMask(uint32_t netmask)
{
  IpMyConfig.netmask = netmask;
    6f9a:	60 93 6e 0f 	sts	0x0F6E, r22
    6f9e:	70 93 6f 0f 	sts	0x0F6F, r23
    6fa2:	80 93 70 0f 	sts	0x0F70, r24
    6fa6:	90 93 71 0f 	sts	0x0F71, r25
}
    6faa:	08 95       	ret

00006fac <ipSetConfigGw>:

void ipSetConfigGw(uint32_t gatewayIp)
{
  IpMyConfig.gateway = gatewayIp;
    6fac:	60 93 72 0f 	sts	0x0F72, r22
    6fb0:	70 93 73 0f 	sts	0x0F73, r23
    6fb4:	80 93 74 0f 	sts	0x0F74, r24
    6fb8:	90 93 75 0f 	sts	0x0F75, r25
}
    6fbc:	08 95       	ret

00006fbe <ipGetConfig>:


struct ipConfig* ipGetConfig(void)
{
  return &IpMyConfig;
}
    6fbe:	8a e6       	ldi	r24, 0x6A	; 106
    6fc0:	9f e0       	ldi	r25, 0x0F	; 15
    6fc2:	08 95       	ret

00006fc4 <ipPrintConfig>:
// send it
  nicSend(len);
}

void ipPrintConfig(FILE *stream, struct ipConfig* config)
{
    6fc4:	ef 92       	push	r14
    6fc6:	ff 92       	push	r15
    6fc8:	0f 93       	push	r16
    6fca:	1f 93       	push	r17
    6fcc:	8c 01       	movw	r16, r24
    6fce:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("IP Addr : ")); netPrintIPAddr(stream, config->ip);        fprintf_P(stream, PSTR("\r\n"));
    6fd0:	00 d0       	rcall	.+0      	; 0x6fd2 <ipPrintConfig+0xe>
    6fd2:	00 d0       	rcall	.+0      	; 0x6fd4 <ipPrintConfig+0x10>
    6fd4:	ed b7       	in	r30, 0x3d	; 61
    6fd6:	fe b7       	in	r31, 0x3e	; 62
    6fd8:	92 83       	std	Z+2, r25	; 0x02
    6fda:	81 83       	std	Z+1, r24	; 0x01
    6fdc:	83 ee       	ldi	r24, 0xE3	; 227
    6fde:	9d e0       	ldi	r25, 0x0D	; 13
    6fe0:	94 83       	std	Z+4, r25	; 0x04
    6fe2:	83 83       	std	Z+3, r24	; 0x03
    6fe4:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    6fe8:	0f 90       	pop	r0
    6fea:	0f 90       	pop	r0
    6fec:	0f 90       	pop	r0
    6fee:	0f 90       	pop	r0
    6ff0:	f7 01       	movw	r30, r14
    6ff2:	40 81       	ld	r20, Z
    6ff4:	51 81       	ldd	r21, Z+1	; 0x01
    6ff6:	62 81       	ldd	r22, Z+2	; 0x02
    6ff8:	73 81       	ldd	r23, Z+3	; 0x03
    6ffa:	c8 01       	movw	r24, r16
    6ffc:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    7000:	00 d0       	rcall	.+0      	; 0x7002 <ipPrintConfig+0x3e>
    7002:	00 d0       	rcall	.+0      	; 0x7004 <ipPrintConfig+0x40>
    7004:	ed b7       	in	r30, 0x3d	; 61
    7006:	fe b7       	in	r31, 0x3e	; 62
    7008:	12 83       	std	Z+2, r17	; 0x02
    700a:	01 83       	std	Z+1, r16	; 0x01
    700c:	80 ee       	ldi	r24, 0xE0	; 224
    700e:	9d e0       	ldi	r25, 0x0D	; 13
    7010:	94 83       	std	Z+4, r25	; 0x04
    7012:	83 83       	std	Z+3, r24	; 0x03
    7014:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Netmask : ")); netPrintIPAddr(stream, config->netmask);   fprintf_P(stream, PSTR("\r\n"));
    7018:	ed b7       	in	r30, 0x3d	; 61
    701a:	fe b7       	in	r31, 0x3e	; 62
    701c:	12 83       	std	Z+2, r17	; 0x02
    701e:	01 83       	std	Z+1, r16	; 0x01
    7020:	85 ed       	ldi	r24, 0xD5	; 213
    7022:	9d e0       	ldi	r25, 0x0D	; 13
    7024:	94 83       	std	Z+4, r25	; 0x04
    7026:	83 83       	std	Z+3, r24	; 0x03
    7028:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    702c:	0f 90       	pop	r0
    702e:	0f 90       	pop	r0
    7030:	0f 90       	pop	r0
    7032:	0f 90       	pop	r0
    7034:	f7 01       	movw	r30, r14
    7036:	44 81       	ldd	r20, Z+4	; 0x04
    7038:	55 81       	ldd	r21, Z+5	; 0x05
    703a:	66 81       	ldd	r22, Z+6	; 0x06
    703c:	77 81       	ldd	r23, Z+7	; 0x07
    703e:	c8 01       	movw	r24, r16
    7040:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    7044:	00 d0       	rcall	.+0      	; 0x7046 <ipPrintConfig+0x82>
    7046:	00 d0       	rcall	.+0      	; 0x7048 <ipPrintConfig+0x84>
    7048:	ed b7       	in	r30, 0x3d	; 61
    704a:	fe b7       	in	r31, 0x3e	; 62
    704c:	12 83       	std	Z+2, r17	; 0x02
    704e:	01 83       	std	Z+1, r16	; 0x01
    7050:	82 ed       	ldi	r24, 0xD2	; 210
    7052:	9d e0       	ldi	r25, 0x0D	; 13
    7054:	94 83       	std	Z+4, r25	; 0x04
    7056:	83 83       	std	Z+3, r24	; 0x03
    7058:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("Gateway : ")); netPrintIPAddr(stream, config->gateway);   fprintf_P(stream, PSTR("\r\n"));
    705c:	ed b7       	in	r30, 0x3d	; 61
    705e:	fe b7       	in	r31, 0x3e	; 62
    7060:	12 83       	std	Z+2, r17	; 0x02
    7062:	01 83       	std	Z+1, r16	; 0x01
    7064:	87 ec       	ldi	r24, 0xC7	; 199
    7066:	9d e0       	ldi	r25, 0x0D	; 13
    7068:	94 83       	std	Z+4, r25	; 0x04
    706a:	83 83       	std	Z+3, r24	; 0x03
    706c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7070:	0f 90       	pop	r0
    7072:	0f 90       	pop	r0
    7074:	0f 90       	pop	r0
    7076:	0f 90       	pop	r0
    7078:	f7 01       	movw	r30, r14
    707a:	40 85       	ldd	r20, Z+8	; 0x08
    707c:	51 85       	ldd	r21, Z+9	; 0x09
    707e:	62 85       	ldd	r22, Z+10	; 0x0a
    7080:	73 85       	ldd	r23, Z+11	; 0x0b
    7082:	c8 01       	movw	r24, r16
    7084:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    7088:	00 d0       	rcall	.+0      	; 0x708a <ipPrintConfig+0xc6>
    708a:	00 d0       	rcall	.+0      	; 0x708c <ipPrintConfig+0xc8>
    708c:	ed b7       	in	r30, 0x3d	; 61
    708e:	fe b7       	in	r31, 0x3e	; 62
    7090:	12 83       	std	Z+2, r17	; 0x02
    7092:	01 83       	std	Z+1, r16	; 0x01
    7094:	84 ec       	ldi	r24, 0xC4	; 196
    7096:	9d e0       	ldi	r25, 0x0D	; 13
    7098:	94 83       	std	Z+4, r25	; 0x04
    709a:	83 83       	std	Z+3, r24	; 0x03
    709c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    70a0:	0f 90       	pop	r0
    70a2:	0f 90       	pop	r0
    70a4:	0f 90       	pop	r0
    70a6:	0f 90       	pop	r0
}
    70a8:	1f 91       	pop	r17
    70aa:	0f 91       	pop	r16
    70ac:	ff 90       	pop	r15
    70ae:	ef 90       	pop	r14
    70b0:	08 95       	ret

000070b2 <ipSend>:
{
  return &IpMyConfig;
}

void ipSend(uint32_t dstIp, uint8_t protocol, uint16_t len)
{
    70b2:	bf 92       	push	r11
    70b4:	cf 92       	push	r12
    70b6:	df 92       	push	r13
    70b8:	ef 92       	push	r14
    70ba:	ff 92       	push	r15
    70bc:	0f 93       	push	r16
    70be:	1f 93       	push	r17
    70c0:	cf 93       	push	r28
    70c2:	df 93       	push	r29
    70c4:	6b 01       	movw	r12, r22
    70c6:	7c 01       	movw	r14, r24
    70c8:	b4 2e       	mov	r11, r20
    70ca:	e9 01       	movw	r28, r18
// make pointer to ethernet/IP header
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    70cc:	20 91 76 0f 	lds	r18, 0x0F76
    70d0:	30 91 77 0f 	lds	r19, 0x0F77
    70d4:	21 15       	cp	r18, r1
    70d6:	31 05       	cpc	r19, r1
    70d8:	a1 f0       	breq	.+40     	; 0x7102 <ipSend+0x50>
  {  
    if (IpMyConfig.dbgLevel > 2)
    70da:	80 91 78 0f 	lds	r24, 0x0F78
    70de:	83 30       	cpi	r24, 0x03	; 3
    70e0:	80 f0       	brcs	.+32     	; 0x7102 <ipSend+0x50>
      fprintf_P(IpMyConfig.dbgStream, "Sending Ip packet\r\n");
    70e2:	00 d0       	rcall	.+0      	; 0x70e4 <ipSend+0x32>
    70e4:	00 d0       	rcall	.+0      	; 0x70e6 <ipSend+0x34>
    70e6:	ed b7       	in	r30, 0x3d	; 61
    70e8:	fe b7       	in	r31, 0x3e	; 62
    70ea:	32 83       	std	Z+2, r19	; 0x02
    70ec:	21 83       	std	Z+1, r18	; 0x01
    70ee:	8b e4       	ldi	r24, 0x4B	; 75
    70f0:	91 e0       	ldi	r25, 0x01	; 1
    70f2:	94 83       	std	Z+4, r25	; 0x04
    70f4:	83 83       	std	Z+3, r24	; 0x03
    70f6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    70fa:	0f 90       	pop	r0
    70fc:	0f 90       	pop	r0
    70fe:	0f 90       	pop	r0
    7100:	0f 90       	pop	r0
  }
#endif

// adjust length to add IP header
  len += IP_HEADER_LEN;
    7102:	64 96       	adiw	r28, 0x14	; 20

// fill IP header
  nicState.layer3.ip->destipaddr = dstIp;
    7104:	00 91 9f 0e 	lds	r16, 0x0E9F
    7108:	10 91 a0 0e 	lds	r17, 0x0EA0
    710c:	f8 01       	movw	r30, r16
    710e:	c0 8a       	std	Z+16, r12	; 0x10
    7110:	d1 8a       	std	Z+17, r13	; 0x11
    7112:	e2 8a       	std	Z+18, r14	; 0x12
    7114:	f3 8a       	std	Z+19, r15	; 0x13
  nicState.layer3.ip->srcipaddr  = IpMyConfig.ip;
    7116:	80 91 6a 0f 	lds	r24, 0x0F6A
    711a:	90 91 6b 0f 	lds	r25, 0x0F6B
    711e:	a0 91 6c 0f 	lds	r26, 0x0F6C
    7122:	b0 91 6d 0f 	lds	r27, 0x0F6D
    7126:	84 87       	std	Z+12, r24	; 0x0c
    7128:	95 87       	std	Z+13, r25	; 0x0d
    712a:	a6 87       	std	Z+14, r26	; 0x0e
    712c:	b7 87       	std	Z+15, r27	; 0x0f
  nicState.layer3.ip->proto      = protocol;
    712e:	b1 86       	std	Z+9, r11	; 0x09
  nicState.layer3.ip->len        = htons(len);
    7130:	ce 01       	movw	r24, r28
    7132:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    7136:	f8 01       	movw	r30, r16
    7138:	93 83       	std	Z+3, r25	; 0x03
    713a:	82 83       	std	Z+2, r24	; 0x02
  nicState.layer3.ip->vhl        = 0x45;
    713c:	e0 91 9f 0e 	lds	r30, 0x0E9F
    7140:	f0 91 a0 0e 	lds	r31, 0x0EA0
    7144:	85 e4       	ldi	r24, 0x45	; 69
    7146:	80 83       	st	Z, r24
  nicState.layer3.ip->tos        = 0;
    7148:	e0 91 9f 0e 	lds	r30, 0x0E9F
    714c:	f0 91 a0 0e 	lds	r31, 0x0EA0
    7150:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ip->ipid       = 0;
    7152:	e0 91 9f 0e 	lds	r30, 0x0E9F
    7156:	f0 91 a0 0e 	lds	r31, 0x0EA0
    715a:	15 82       	std	Z+5, r1	; 0x05
    715c:	14 82       	std	Z+4, r1	; 0x04
  nicState.layer3.ip->ipoffset   = 0;
    715e:	17 82       	std	Z+7, r1	; 0x07
    7160:	16 82       	std	Z+6, r1	; 0x06
  nicState.layer3.ip->ttl        = IP_TIME_TO_LIVE;
    7162:	80 e8       	ldi	r24, 0x80	; 128
    7164:	80 87       	std	Z+8, r24	; 0x08
  nicState.layer3.ip->ipchksum   = 0;
    7166:	13 86       	std	Z+11, r1	; 0x0b
    7168:	12 86       	std	Z+10, r1	; 0x0a

// calculate and apply IP checksum
// DO THIS ONLY AFTER ALL CHANGES HAVE BEEN MADE TO IP HEADER
  nicState.layer3.ip->ipchksum   = netChecksum((uint8_t *)(nicState.layer3.ip), IP_HEADER_LEN);
    716a:	00 91 9f 0e 	lds	r16, 0x0E9F
    716e:	10 91 a0 0e 	lds	r17, 0x0EA0
    7172:	c8 01       	movw	r24, r16
    7174:	64 e1       	ldi	r22, 0x14	; 20
    7176:	70 e0       	ldi	r23, 0x00	; 0
    7178:	0e 94 c8 33 	call	0x6790	; 0x6790 <netChecksum>
    717c:	f8 01       	movw	r30, r16
    717e:	93 87       	std	Z+11, r25	; 0x0b
    7180:	82 87       	std	Z+10, r24	; 0x0a

// add ethernet routing
// check if we need to send to gateway
  if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    7182:	20 91 6a 0f 	lds	r18, 0x0F6A
    7186:	30 91 6b 0f 	lds	r19, 0x0F6B
    718a:	40 91 6c 0f 	lds	r20, 0x0F6C
    718e:	50 91 6d 0f 	lds	r21, 0x0F6D
    7192:	2c 25       	eor	r18, r12
    7194:	3d 25       	eor	r19, r13
    7196:	4e 25       	eor	r20, r14
    7198:	5f 25       	eor	r21, r15
    719a:	80 91 6e 0f 	lds	r24, 0x0F6E
    719e:	90 91 6f 0f 	lds	r25, 0x0F6F
    71a2:	a0 91 70 0f 	lds	r26, 0x0F70
    71a6:	b0 91 71 0f 	lds	r27, 0x0F71
    71aa:	82 23       	and	r24, r18
    71ac:	93 23       	and	r25, r19
    71ae:	a4 23       	and	r26, r20
    71b0:	b5 23       	and	r27, r21
    71b2:	00 97       	sbiw	r24, 0x00	; 0
    71b4:	a1 05       	cpc	r26, r1
    71b6:	b1 05       	cpc	r27, r1
    71b8:	a9 f4       	brne	.+42     	; 0x71e4 <ipSend+0x132>
  {
    arpIpOut(0);  // local send
    71ba:	60 e0       	ldi	r22, 0x00	; 0
    71bc:	70 e0       	ldi	r23, 0x00	; 0
    71be:	80 e0       	ldi	r24, 0x00	; 0
    71c0:	90 e0       	ldi	r25, 0x00	; 0
    71c2:	0e 94 ed 3e 	call	0x7dda	; 0x7dda <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    71c6:	80 91 76 0f 	lds	r24, 0x0F76
    71ca:	90 91 77 0f 	lds	r25, 0x0F77
    71ce:	00 97       	sbiw	r24, 0x00	; 0
    71d0:	49 f1       	breq	.+82     	; 0x7224 <ipSend+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet on local net\r\n"));
    71d2:	00 d0       	rcall	.+0      	; 0x71d4 <ipSend+0x122>
    71d4:	00 d0       	rcall	.+0      	; 0x71d6 <ipSend+0x124>
    71d6:	ed b7       	in	r30, 0x3d	; 61
    71d8:	fe b7       	in	r31, 0x3e	; 62
    71da:	92 83       	std	Z+2, r25	; 0x02
    71dc:	81 83       	std	Z+1, r24	; 0x01
    71de:	8a e7       	ldi	r24, 0x7A	; 122
    71e0:	9e e0       	ldi	r25, 0x0E	; 14
    71e2:	18 c0       	rjmp	.+48     	; 0x7214 <ipSend+0x162>
#endif
  }
  else
  {
    arpIpOut(IpMyConfig.gateway);  // gateway send
    71e4:	60 91 72 0f 	lds	r22, 0x0F72
    71e8:	70 91 73 0f 	lds	r23, 0x0F73
    71ec:	80 91 74 0f 	lds	r24, 0x0F74
    71f0:	90 91 75 0f 	lds	r25, 0x0F75
    71f4:	0e 94 ed 3e 	call	0x7dda	; 0x7dda <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    71f8:	80 91 76 0f 	lds	r24, 0x0F76
    71fc:	90 91 77 0f 	lds	r25, 0x0F77
    7200:	00 97       	sbiw	r24, 0x00	; 0
    7202:	81 f0       	breq	.+32     	; 0x7224 <ipSend+0x172>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet to gateway\r\n"));
    7204:	00 d0       	rcall	.+0      	; 0x7206 <ipSend+0x154>
    7206:	00 d0       	rcall	.+0      	; 0x7208 <ipSend+0x156>
    7208:	ed b7       	in	r30, 0x3d	; 61
    720a:	fe b7       	in	r31, 0x3e	; 62
    720c:	92 83       	std	Z+2, r25	; 0x02
    720e:	81 83       	std	Z+1, r24	; 0x01
    7210:	8b e5       	ldi	r24, 0x5B	; 91
    7212:	9e e0       	ldi	r25, 0x0E	; 14
    7214:	94 83       	std	Z+4, r25	; 0x04
    7216:	83 83       	std	Z+3, r24	; 0x03
    7218:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    721c:	0f 90       	pop	r0
    721e:	0f 90       	pop	r0
    7220:	0f 90       	pop	r0
    7222:	0f 90       	pop	r0

// adjust length to add ethernet header
  len += ETH_HEADER_LEN;

#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    7224:	20 91 76 0f 	lds	r18, 0x0F76
    7228:	30 91 77 0f 	lds	r19, 0x0F77
    722c:	21 15       	cp	r18, r1
    722e:	31 05       	cpc	r19, r1
    7230:	11 f1       	breq	.+68     	; 0x7276 <ipSend+0x1c4>
  {
    if (IpMyConfig.dbgLevel > 3)
    7232:	80 91 78 0f 	lds	r24, 0x0F78
    7236:	84 30       	cpi	r24, 0x04	; 4
    7238:	f0 f0       	brcs	.+60     	; 0x7276 <ipSend+0x1c4>
    {
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(ETH_HEADER_LEN, &data[0]);"));
    723a:	00 d0       	rcall	.+0      	; 0x723c <ipSend+0x18a>
    723c:	00 d0       	rcall	.+0      	; 0x723e <ipSend+0x18c>
    723e:	ed b7       	in	r30, 0x3d	; 61
    7240:	fe b7       	in	r31, 0x3e	; 62
    7242:	32 83       	std	Z+2, r19	; 0x02
    7244:	21 83       	std	Z+1, r18	; 0x01
    7246:	8d e2       	ldi	r24, 0x2D	; 45
    7248:	9e e0       	ldi	r25, 0x0E	; 14
    724a:	94 83       	std	Z+4, r25	; 0x04
    724c:	83 83       	std	Z+3, r24	; 0x03
    724e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    7252:	80 91 76 0f 	lds	r24, 0x0F76
    7256:	90 91 77 0f 	lds	r25, 0x0F77
    725a:	ed b7       	in	r30, 0x3d	; 61
    725c:	fe b7       	in	r31, 0x3e	; 62
    725e:	92 83       	std	Z+2, r25	; 0x02
    7260:	81 83       	std	Z+1, r24	; 0x01
    7262:	8e ee       	ldi	r24, 0xEE	; 238
    7264:	9d e0       	ldi	r25, 0x0D	; 13
    7266:	94 83       	std	Z+4, r25	; 0x04
    7268:	83 83       	std	Z+3, r24	; 0x03
    726a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    726e:	0f 90       	pop	r0
    7270:	0f 90       	pop	r0
    7272:	0f 90       	pop	r0
    7274:	0f 90       	pop	r0
    }
  }
#endif
// send it
  nicSend(len);
    7276:	ce 01       	movw	r24, r28
    7278:	0e 96       	adiw	r24, 0x0e	; 14
    727a:	0e 94 de 31 	call	0x63bc	; 0x63bc <nicSend>
}
    727e:	df 91       	pop	r29
    7280:	cf 91       	pop	r28
    7282:	1f 91       	pop	r17
    7284:	0f 91       	pop	r16
    7286:	ff 90       	pop	r15
    7288:	ef 90       	pop	r14
    728a:	df 90       	pop	r13
    728c:	cf 90       	pop	r12
    728e:	bf 90       	pop	r11
    7290:	08 95       	ret

00007292 <netstackIPv4Process>:
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
}

inline void netstackIPv4Process(void)
{
    7292:	ef 92       	push	r14
    7294:	ff 92       	push	r15
    7296:	0f 93       	push	r16
    7298:	1f 93       	push	r17
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&
    729a:	e0 91 9f 0e 	lds	r30, 0x0E9F
    729e:	f0 91 a0 0e 	lds	r31, 0x0EA0
    72a2:	e0 88       	ldd	r14, Z+16	; 0x10
    72a4:	f1 88       	ldd	r15, Z+17	; 0x11
    72a6:	02 89       	ldd	r16, Z+18	; 0x12
    72a8:	13 89       	ldd	r17, Z+19	; 0x13
    72aa:	20 91 6a 0f 	lds	r18, 0x0F6A
    72ae:	30 91 6b 0f 	lds	r19, 0x0F6B
    72b2:	40 91 6c 0f 	lds	r20, 0x0F6C
    72b6:	50 91 6d 0f 	lds	r21, 0x0F6D
    72ba:	e2 16       	cp	r14, r18
    72bc:	f3 06       	cpc	r15, r19
    72be:	04 07       	cpc	r16, r20
    72c0:	15 07       	cpc	r17, r21
    72c2:	d9 f0       	breq	.+54     	; 0x72fa <netstackIPv4Process+0x68>
    72c4:	80 91 6e 0f 	lds	r24, 0x0F6E
    72c8:	90 91 6f 0f 	lds	r25, 0x0F6F
    72cc:	a0 91 70 0f 	lds	r26, 0x0F70
    72d0:	b0 91 71 0f 	lds	r27, 0x0F71
    72d4:	28 2b       	or	r18, r24
    72d6:	39 2b       	or	r19, r25
    72d8:	4a 2b       	or	r20, r26
    72da:	5b 2b       	or	r21, r27
    72dc:	e2 16       	cp	r14, r18
    72de:	f3 06       	cpc	r15, r19
    72e0:	04 07       	cpc	r16, r20
    72e2:	15 07       	cpc	r17, r21
    72e4:	51 f0       	breq	.+20     	; 0x72fa <netstackIPv4Process+0x68>
    72e6:	8f ef       	ldi	r24, 0xFF	; 255
    72e8:	e8 16       	cp	r14, r24
    72ea:	8f ef       	ldi	r24, 0xFF	; 255
    72ec:	f8 06       	cpc	r15, r24
    72ee:	8f ef       	ldi	r24, 0xFF	; 255
    72f0:	08 07       	cpc	r16, r24
    72f2:	8f ef       	ldi	r24, 0xFF	; 255
    72f4:	18 07       	cpc	r17, r24
    72f6:	09 f0       	breq	.+2      	; 0x72fa <netstackIPv4Process+0x68>
    72f8:	8e c0       	rjmp	.+284    	; 0x7416 <netstackIPv4Process+0x184>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip|ipGetConfig()->netmask)) &&
      (nicState.layer3.ip->destipaddr != 0xFFFFFFFF)) 
    return;

// handle ICMP packet
  if(nicState.layer3.ip->proto == IP_PROTO_ICMP)
    72fa:	81 85       	ldd	r24, Z+9	; 0x09
    72fc:	81 30       	cpi	r24, 0x01	; 1
    72fe:	81 f5       	brne	.+96     	; 0x7360 <netstackIPv4Process+0xce>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    7300:	20 91 76 0f 	lds	r18, 0x0F76
    7304:	30 91 77 0f 	lds	r19, 0x0F77
    7308:	21 15       	cp	r18, r1
    730a:	31 05       	cpc	r19, r1
    730c:	31 f1       	breq	.+76     	; 0x735a <netstackIPv4Process+0xc8>
    {
      if (IpMyConfig.dbgLevel > 0)
    730e:	80 91 78 0f 	lds	r24, 0x0F78
    7312:	88 23       	and	r24, r24
    7314:	81 f0       	breq	.+32     	; 0x7336 <netstackIPv4Process+0xa4>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
    7316:	00 d0       	rcall	.+0      	; 0x7318 <netstackIPv4Process+0x86>
    7318:	00 d0       	rcall	.+0      	; 0x731a <netstackIPv4Process+0x88>
    731a:	ed b7       	in	r30, 0x3d	; 61
    731c:	fe b7       	in	r31, 0x3e	; 62
    731e:	32 83       	std	Z+2, r19	; 0x02
    7320:	21 83       	std	Z+1, r18	; 0x01
    7322:	87 ee       	ldi	r24, 0xE7	; 231
    7324:	9e e0       	ldi	r25, 0x0E	; 14
    7326:	94 83       	std	Z+4, r25	; 0x04
    7328:	83 83       	std	Z+3, r24	; 0x03
    732a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    732e:	0f 90       	pop	r0
    7330:	0f 90       	pop	r0
    7332:	0f 90       	pop	r0
    7334:	0f 90       	pop	r0
      if (IpMyConfig.dbgLevel > 2)
    7336:	80 91 78 0f 	lds	r24, 0x0F78
    733a:	83 30       	cpi	r24, 0x03	; 3
    733c:	70 f0       	brcs	.+28     	; 0x735a <netstackIPv4Process+0xc8>
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    733e:	60 91 9f 0e 	lds	r22, 0x0E9F
    7342:	70 91 a0 0e 	lds	r23, 0x0EA0
    7346:	40 91 a1 0e 	lds	r20, 0x0EA1
    734a:	50 91 a2 0e 	lds	r21, 0x0EA2
    734e:	80 91 76 0f 	lds	r24, 0x0F76
    7352:	90 91 77 0f 	lds	r25, 0x0F77
    7356:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <icmpPrintHeader>
    }
#endif /*IP_DEBUG*/
    icmpIpIn();
    735a:	0e 94 cc 3b 	call	0x7798	; 0x7798 <icmpIpIn>
    735e:	5b c0       	rjmp	.+182    	; 0x7416 <netstackIPv4Process+0x184>
    return;
  }
  if( nicState.layer3.ip->proto == IP_PROTO_UDP )
    7360:	81 31       	cpi	r24, 0x11	; 17
    7362:	f1 f4       	brne	.+60     	; 0x73a0 <netstackIPv4Process+0x10e>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    7364:	20 91 76 0f 	lds	r18, 0x0F76
    7368:	30 91 77 0f 	lds	r19, 0x0F77
    736c:	21 15       	cp	r18, r1
    736e:	31 05       	cpc	r19, r1
    7370:	a1 f0       	breq	.+40     	; 0x739a <netstackIPv4Process+0x108>
    {
      if (IpMyConfig.dbgLevel > 0)
    7372:	80 91 78 0f 	lds	r24, 0x0F78
    7376:	88 23       	and	r24, r24
    7378:	81 f0       	breq	.+32     	; 0x739a <netstackIPv4Process+0x108>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    737a:	00 d0       	rcall	.+0      	; 0x737c <netstackIPv4Process+0xea>
    737c:	00 d0       	rcall	.+0      	; 0x737e <netstackIPv4Process+0xec>
    737e:	ed b7       	in	r30, 0x3d	; 61
    7380:	fe b7       	in	r31, 0x3e	; 62
    7382:	32 83       	std	Z+2, r19	; 0x02
    7384:	21 83       	std	Z+1, r18	; 0x01
    7386:	8f ec       	ldi	r24, 0xCF	; 207
    7388:	9e e0       	ldi	r25, 0x0E	; 14
    738a:	94 83       	std	Z+4, r25	; 0x04
    738c:	83 83       	std	Z+3, r24	; 0x03
    738e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7392:	0f 90       	pop	r0
    7394:	0f 90       	pop	r0
    7396:	0f 90       	pop	r0
    7398:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackUDPIPProcess();
    739a:	0e 94 bd 43 	call	0x877a	; 0x877a <netstackUDPIPProcess>
    739e:	3b c0       	rjmp	.+118    	; 0x7416 <netstackIPv4Process+0x184>
    return;
  }
  if( nicState.layer3.ip->proto == IP_PROTO_TCP )
    73a0:	86 30       	cpi	r24, 0x06	; 6
    73a2:	f1 f4       	brne	.+60     	; 0x73e0 <netstackIPv4Process+0x14e>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    73a4:	20 91 76 0f 	lds	r18, 0x0F76
    73a8:	30 91 77 0f 	lds	r19, 0x0F77
    73ac:	21 15       	cp	r18, r1
    73ae:	31 05       	cpc	r19, r1
    73b0:	a1 f0       	breq	.+40     	; 0x73da <netstackIPv4Process+0x148>
    {
      if (IpMyConfig.dbgLevel > 0)
    73b2:	80 91 78 0f 	lds	r24, 0x0F78
    73b6:	88 23       	and	r24, r24
    73b8:	81 f0       	breq	.+32     	; 0x73da <netstackIPv4Process+0x148>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: TCP/IP packet\r\n"));
    73ba:	00 d0       	rcall	.+0      	; 0x73bc <netstackIPv4Process+0x12a>
    73bc:	00 d0       	rcall	.+0      	; 0x73be <netstackIPv4Process+0x12c>
    73be:	ed b7       	in	r30, 0x3d	; 61
    73c0:	fe b7       	in	r31, 0x3e	; 62
    73c2:	32 83       	std	Z+2, r19	; 0x02
    73c4:	21 83       	std	Z+1, r18	; 0x01
    73c6:	87 eb       	ldi	r24, 0xB7	; 183
    73c8:	9e e0       	ldi	r25, 0x0E	; 14
    73ca:	94 83       	std	Z+4, r25	; 0x04
    73cc:	83 83       	std	Z+3, r24	; 0x03
    73ce:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    73d2:	0f 90       	pop	r0
    73d4:	0f 90       	pop	r0
    73d6:	0f 90       	pop	r0
    73d8:	0f 90       	pop	r0
    }
#endif /*IP_DEBUG*/
    netstackTCPIPProcess();
    73da:	0e 94 8b 42 	call	0x8516	; 0x8516 <netstackTCPIPProcess>
    73de:	1b c0       	rjmp	.+54     	; 0x7416 <netstackIPv4Process+0x184>
    return;
  }
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    73e0:	20 91 76 0f 	lds	r18, 0x0F76
    73e4:	30 91 77 0f 	lds	r19, 0x0F77
    73e8:	21 15       	cp	r18, r1
    73ea:	31 05       	cpc	r19, r1
    73ec:	a1 f0       	breq	.+40     	; 0x7416 <netstackIPv4Process+0x184>
  {
    if (IpMyConfig.dbgLevel > 0)
    73ee:	80 91 78 0f 	lds	r24, 0x0F78
    73f2:	88 23       	and	r24, r24
    73f4:	81 f0       	breq	.+32     	; 0x7416 <netstackIPv4Process+0x184>
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
    73f6:	00 d0       	rcall	.+0      	; 0x73f8 <netstackIPv4Process+0x166>
    73f8:	00 d0       	rcall	.+0      	; 0x73fa <netstackIPv4Process+0x168>
    73fa:	ed b7       	in	r30, 0x3d	; 61
    73fc:	fe b7       	in	r31, 0x3e	; 62
    73fe:	32 83       	std	Z+2, r19	; 0x02
    7400:	21 83       	std	Z+1, r18	; 0x01
    7402:	8b e9       	ldi	r24, 0x9B	; 155
    7404:	9e e0       	ldi	r25, 0x0E	; 14
    7406:	94 83       	std	Z+4, r25	; 0x04
    7408:	83 83       	std	Z+3, r24	; 0x03
    740a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    740e:	0f 90       	pop	r0
    7410:	0f 90       	pop	r0
    7412:	0f 90       	pop	r0
    7414:	0f 90       	pop	r0
  }
#endif /*IP_DEBUG*/
}
    7416:	1f 91       	pop	r17
    7418:	0f 91       	pop	r16
    741a:	ff 90       	pop	r15
    741c:	ef 90       	pop	r14
    741e:	08 95       	ret

00007420 <ipSaveConfig>:
#endif
}

void ipSaveConfig(void)
{
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
    7420:	40 91 6a 0f 	lds	r20, 0x0F6A
    7424:	50 91 6b 0f 	lds	r21, 0x0F6B
    7428:	60 91 6c 0f 	lds	r22, 0x0F6C
    742c:	70 91 6d 0f 	lds	r23, 0x0F6D
    7430:	8e e1       	ldi	r24, 0x1E	; 30
    7432:	90 e0       	ldi	r25, 0x00	; 0
    7434:	0e 94 00 78 	call	0xf000	; 0xf000 <__eeupd_dword_m128>
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
    7438:	40 91 6e 0f 	lds	r20, 0x0F6E
    743c:	50 91 6f 0f 	lds	r21, 0x0F6F
    7440:	60 91 70 0f 	lds	r22, 0x0F70
    7444:	70 91 71 0f 	lds	r23, 0x0F71
    7448:	82 e2       	ldi	r24, 0x22	; 34
    744a:	90 e0       	ldi	r25, 0x00	; 0
    744c:	0e 94 00 78 	call	0xf000	; 0xf000 <__eeupd_dword_m128>
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    7450:	40 91 72 0f 	lds	r20, 0x0F72
    7454:	50 91 73 0f 	lds	r21, 0x0F73
    7458:	60 91 74 0f 	lds	r22, 0x0F74
    745c:	70 91 75 0f 	lds	r23, 0x0F75
    7460:	86 e2       	ldi	r24, 0x26	; 38
    7462:	90 e0       	ldi	r25, 0x00	; 0
    7464:	0e 94 00 78 	call	0xf000	; 0xf000 <__eeupd_dword_m128>
}
    7468:	08 95       	ret

0000746a <ipInit>:
static uint32_t mask_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_MASK4 << 24) + ((uint32_t)MY_MASK3 <<16) + ((uint32_t)MY_MASK2 <<8) + MY_MASK1;
static uint32_t defGw_eep   __attribute__((section (".eeprom"))) = ((uint32_t)MY_GW4   << 24) + ((uint32_t)MY_GW3   <<16) + ((uint32_t)MY_GW2   <<8) + MY_GW1;

void ipInit(void)
{
  IpMyConfig.ip      = eeprom_read_dword(&myip_eep);
    746a:	8e e1       	ldi	r24, 0x1E	; 30
    746c:	90 e0       	ldi	r25, 0x00	; 0
    746e:	0e 94 d3 77 	call	0xefa6	; 0xefa6 <__eerd_dword_m128>
    7472:	60 93 6a 0f 	sts	0x0F6A, r22
    7476:	70 93 6b 0f 	sts	0x0F6B, r23
    747a:	80 93 6c 0f 	sts	0x0F6C, r24
    747e:	90 93 6d 0f 	sts	0x0F6D, r25
  IpMyConfig.netmask = eeprom_read_dword(&mask_eep);
    7482:	82 e2       	ldi	r24, 0x22	; 34
    7484:	90 e0       	ldi	r25, 0x00	; 0
    7486:	0e 94 d3 77 	call	0xefa6	; 0xefa6 <__eerd_dword_m128>
    748a:	60 93 6e 0f 	sts	0x0F6E, r22
    748e:	70 93 6f 0f 	sts	0x0F6F, r23
    7492:	80 93 70 0f 	sts	0x0F70, r24
    7496:	90 93 71 0f 	sts	0x0F71, r25
  IpMyConfig.gateway = eeprom_read_dword(&defGw_eep);
    749a:	86 e2       	ldi	r24, 0x26	; 38
    749c:	90 e0       	ldi	r25, 0x00	; 0
    749e:	0e 94 d3 77 	call	0xefa6	; 0xefa6 <__eerd_dword_m128>
    74a2:	60 93 72 0f 	sts	0x0F72, r22
    74a6:	70 93 73 0f 	sts	0x0F73, r23
    74aa:	80 93 74 0f 	sts	0x0F74, r24
    74ae:	90 93 75 0f 	sts	0x0F75, r25
#if IP_DEBUG
  IpMyConfig.dbgLevel = 0;
    74b2:	10 92 78 0f 	sts	0x0F78, r1
  IpMyConfig.dbgStream = NULL;
    74b6:	10 92 77 0f 	sts	0x0F77, r1
    74ba:	10 92 76 0f 	sts	0x0F76, r1
#endif
}
    74be:	08 95       	ret

000074c0 <icmpInit>:


// functions
void icmpInit(void)
{
  icmpDebug = NULL;
    74c0:	10 92 c2 0e 	sts	0x0EC2, r1
    74c4:	10 92 c1 0e 	sts	0x0EC1, r1
  icmpDebugLevel = 0;
    74c8:	10 92 66 0f 	sts	0x0F66, r1
}
    74cc:	08 95       	ret

000074ce <setIcmpDebug>:
}

#if ICMP_DEBUG
void setIcmpDebug(FILE *stream, uint8_t level)
{
  icmpDebug = stream;
    74ce:	90 93 c2 0e 	sts	0x0EC2, r25
    74d2:	80 93 c1 0e 	sts	0x0EC1, r24
  icmpDebugLevel = level;
    74d6:	60 93 66 0f 	sts	0x0F66, r22
}
    74da:	08 95       	ret

000074dc <icmpPrintHeader>:
#endif

void icmpPrintHeader(FILE *stream, struct netIpHeader *ipPacket, struct netIcmpHeader *icmpPacket)
{
    74dc:	ef 92       	push	r14
    74de:	ff 92       	push	r15
    74e0:	0f 93       	push	r16
    74e2:	1f 93       	push	r17
    74e4:	cf 93       	push	r28
    74e6:	df 93       	push	r29
    74e8:	ec 01       	movw	r28, r24
    74ea:	8b 01       	movw	r16, r22
    74ec:	7a 01       	movw	r14, r20
  fprintf_P(stream, PSTR("ICMP Packet:\r\n"));
    74ee:	00 d0       	rcall	.+0      	; 0x74f0 <icmpPrintHeader+0x14>
    74f0:	00 d0       	rcall	.+0      	; 0x74f2 <icmpPrintHeader+0x16>
    74f2:	ad b7       	in	r26, 0x3d	; 61
    74f4:	be b7       	in	r27, 0x3e	; 62
    74f6:	12 96       	adiw	r26, 0x02	; 2
    74f8:	9c 93       	st	X, r25
    74fa:	8e 93       	st	-X, r24
    74fc:	11 97       	sbiw	r26, 0x01	; 1
    74fe:	83 e5       	ldi	r24, 0x53	; 83
    7500:	9f e0       	ldi	r25, 0x0F	; 15
    7502:	14 96       	adiw	r26, 0x04	; 4
    7504:	9c 93       	st	X, r25
    7506:	8e 93       	st	-X, r24
    7508:	13 97       	sbiw	r26, 0x03	; 3
    750a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print source IP address
  fprintf_P(stream, PSTR("SrcIpAddr: "));  netPrintIPAddr(stream, ipPacket->srcipaddr);  fprintf_P(stream, PSTR("\r\n"));
    750e:	ed b7       	in	r30, 0x3d	; 61
    7510:	fe b7       	in	r31, 0x3e	; 62
    7512:	d2 83       	std	Z+2, r29	; 0x02
    7514:	c1 83       	std	Z+1, r28	; 0x01
    7516:	87 e4       	ldi	r24, 0x47	; 71
    7518:	9f e0       	ldi	r25, 0x0F	; 15
    751a:	94 83       	std	Z+4, r25	; 0x04
    751c:	83 83       	std	Z+3, r24	; 0x03
    751e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7522:	0f 90       	pop	r0
    7524:	0f 90       	pop	r0
    7526:	0f 90       	pop	r0
    7528:	0f 90       	pop	r0
    752a:	d8 01       	movw	r26, r16
    752c:	1c 96       	adiw	r26, 0x0c	; 12
    752e:	4d 91       	ld	r20, X+
    7530:	5d 91       	ld	r21, X+
    7532:	6d 91       	ld	r22, X+
    7534:	7c 91       	ld	r23, X
    7536:	1f 97       	sbiw	r26, 0x0f	; 15
    7538:	ce 01       	movw	r24, r28
    753a:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    753e:	00 d0       	rcall	.+0      	; 0x7540 <icmpPrintHeader+0x64>
    7540:	00 d0       	rcall	.+0      	; 0x7542 <icmpPrintHeader+0x66>
    7542:	ed b7       	in	r30, 0x3d	; 61
    7544:	fe b7       	in	r31, 0x3e	; 62
    7546:	d2 83       	std	Z+2, r29	; 0x02
    7548:	c1 83       	std	Z+1, r28	; 0x01
    754a:	84 e4       	ldi	r24, 0x44	; 68
    754c:	9f e0       	ldi	r25, 0x0F	; 15
    754e:	94 83       	std	Z+4, r25	; 0x04
    7550:	83 83       	std	Z+3, r24	; 0x03
    7552:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print dest IP address
  fprintf_P(stream, PSTR("DstIpAddr: "));  netPrintIPAddr(stream, ipPacket->destipaddr); fprintf_P(stream, PSTR("\r\n"));
    7556:	ad b7       	in	r26, 0x3d	; 61
    7558:	be b7       	in	r27, 0x3e	; 62
    755a:	12 96       	adiw	r26, 0x02	; 2
    755c:	dc 93       	st	X, r29
    755e:	ce 93       	st	-X, r28
    7560:	11 97       	sbiw	r26, 0x01	; 1
    7562:	88 e3       	ldi	r24, 0x38	; 56
    7564:	9f e0       	ldi	r25, 0x0F	; 15
    7566:	14 96       	adiw	r26, 0x04	; 4
    7568:	9c 93       	st	X, r25
    756a:	8e 93       	st	-X, r24
    756c:	13 97       	sbiw	r26, 0x03	; 3
    756e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7572:	0f 90       	pop	r0
    7574:	0f 90       	pop	r0
    7576:	0f 90       	pop	r0
    7578:	0f 90       	pop	r0
    757a:	f8 01       	movw	r30, r16
    757c:	40 89       	ldd	r20, Z+16	; 0x10
    757e:	51 89       	ldd	r21, Z+17	; 0x11
    7580:	62 89       	ldd	r22, Z+18	; 0x12
    7582:	73 89       	ldd	r23, Z+19	; 0x13
    7584:	ce 01       	movw	r24, r28
    7586:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    758a:	00 d0       	rcall	.+0      	; 0x758c <icmpPrintHeader+0xb0>
    758c:	00 d0       	rcall	.+0      	; 0x758e <icmpPrintHeader+0xb2>
    758e:	ad b7       	in	r26, 0x3d	; 61
    7590:	be b7       	in	r27, 0x3e	; 62
    7592:	12 96       	adiw	r26, 0x02	; 2
    7594:	dc 93       	st	X, r29
    7596:	ce 93       	st	-X, r28
    7598:	11 97       	sbiw	r26, 0x01	; 1
    759a:	85 e3       	ldi	r24, 0x35	; 53
    759c:	9f e0       	ldi	r25, 0x0F	; 15
    759e:	14 96       	adiw	r26, 0x04	; 4
    75a0:	9c 93       	st	X, r25
    75a2:	8e 93       	st	-X, r24
    75a4:	13 97       	sbiw	r26, 0x03	; 3
    75a6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print type
  fprintf_P(stream, PSTR("Type   : "));
    75aa:	ed b7       	in	r30, 0x3d	; 61
    75ac:	fe b7       	in	r31, 0x3e	; 62
    75ae:	d2 83       	std	Z+2, r29	; 0x02
    75b0:	c1 83       	std	Z+1, r28	; 0x01
    75b2:	8b e2       	ldi	r24, 0x2B	; 43
    75b4:	9f e0       	ldi	r25, 0x0F	; 15
    75b6:	94 83       	std	Z+4, r25	; 0x04
    75b8:	83 83       	std	Z+3, r24	; 0x03
    75ba:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  switch(icmpPacket->type)
    75be:	0f 90       	pop	r0
    75c0:	0f 90       	pop	r0
    75c2:	0f 90       	pop	r0
    75c4:	0f 90       	pop	r0
    75c6:	d7 01       	movw	r26, r14
    75c8:	8c 91       	ld	r24, X
    75ca:	88 23       	and	r24, r24
    75cc:	59 f0       	breq	.+22     	; 0x75e4 <icmpPrintHeader+0x108>
    75ce:	88 30       	cpi	r24, 0x08	; 8
    75d0:	c1 f4       	brne	.+48     	; 0x7602 <icmpPrintHeader+0x126>
  {
    case ICMP_TYPE_ECHOREQUEST:
      fprintf_P(stream, PSTR("ECHO REQUEST"));
    75d2:	00 d0       	rcall	.+0      	; 0x75d4 <icmpPrintHeader+0xf8>
    75d4:	00 d0       	rcall	.+0      	; 0x75d6 <icmpPrintHeader+0xfa>
    75d6:	ed b7       	in	r30, 0x3d	; 61
    75d8:	fe b7       	in	r31, 0x3e	; 62
    75da:	d2 83       	std	Z+2, r29	; 0x02
    75dc:	c1 83       	std	Z+1, r28	; 0x01
    75de:	8e e1       	ldi	r24, 0x1E	; 30
    75e0:	9f e0       	ldi	r25, 0x0F	; 15
    75e2:	17 c0       	rjmp	.+46     	; 0x7612 <icmpPrintHeader+0x136>
      break;
    case ICMP_TYPE_ECHOREPLY:
      fprintf_P(stream, PSTR("ECHO REPLY"));
    75e4:	00 d0       	rcall	.+0      	; 0x75e6 <icmpPrintHeader+0x10a>
    75e6:	00 d0       	rcall	.+0      	; 0x75e8 <icmpPrintHeader+0x10c>
    75e8:	ad b7       	in	r26, 0x3d	; 61
    75ea:	be b7       	in	r27, 0x3e	; 62
    75ec:	12 96       	adiw	r26, 0x02	; 2
    75ee:	dc 93       	st	X, r29
    75f0:	ce 93       	st	-X, r28
    75f2:	11 97       	sbiw	r26, 0x01	; 1
    75f4:	83 e1       	ldi	r24, 0x13	; 19
    75f6:	9f e0       	ldi	r25, 0x0F	; 15
    75f8:	14 96       	adiw	r26, 0x04	; 4
    75fa:	9c 93       	st	X, r25
    75fc:	8e 93       	st	-X, r24
    75fe:	13 97       	sbiw	r26, 0x03	; 3
    7600:	0a c0       	rjmp	.+20     	; 0x7616 <icmpPrintHeader+0x13a>
      break;
    default:
      fprintf_P(stream, ("UNKNOWN"));
    7602:	00 d0       	rcall	.+0      	; 0x7604 <icmpPrintHeader+0x128>
    7604:	00 d0       	rcall	.+0      	; 0x7606 <icmpPrintHeader+0x12a>
    7606:	ed b7       	in	r30, 0x3d	; 61
    7608:	fe b7       	in	r31, 0x3e	; 62
    760a:	d2 83       	std	Z+2, r29	; 0x02
    760c:	c1 83       	std	Z+1, r28	; 0x01
    760e:	8f e5       	ldi	r24, 0x5F	; 95
    7610:	91 e0       	ldi	r25, 0x01	; 1
    7612:	94 83       	std	Z+4, r25	; 0x04
    7614:	83 83       	std	Z+3, r24	; 0x03
    7616:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      break;
  }
  fprintf_P(stream, PSTR("\r\n"));
    761a:	ad b7       	in	r26, 0x3d	; 61
    761c:	be b7       	in	r27, 0x3e	; 62
    761e:	12 96       	adiw	r26, 0x02	; 2
    7620:	dc 93       	st	X, r29
    7622:	ce 93       	st	-X, r28
    7624:	11 97       	sbiw	r26, 0x01	; 1
    7626:	80 e1       	ldi	r24, 0x10	; 16
    7628:	9f e0       	ldi	r25, 0x0F	; 15
    762a:	14 96       	adiw	r26, 0x04	; 4
    762c:	9c 93       	st	X, r25
    762e:	8e 93       	st	-X, r24
    7630:	13 97       	sbiw	r26, 0x03	; 3
    7632:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print code
  fprintf_P(stream, PSTR("Code   : 0x%x\r\n"), icmpPacket->icode);
    7636:	00 d0       	rcall	.+0      	; 0x7638 <icmpPrintHeader+0x15c>
    7638:	ed b7       	in	r30, 0x3d	; 61
    763a:	fe b7       	in	r31, 0x3e	; 62
    763c:	31 96       	adiw	r30, 0x01	; 1
    763e:	ad b7       	in	r26, 0x3d	; 61
    7640:	be b7       	in	r27, 0x3e	; 62
    7642:	12 96       	adiw	r26, 0x02	; 2
    7644:	dc 93       	st	X, r29
    7646:	ce 93       	st	-X, r28
    7648:	11 97       	sbiw	r26, 0x01	; 1
    764a:	80 e0       	ldi	r24, 0x00	; 0
    764c:	9f e0       	ldi	r25, 0x0F	; 15
    764e:	93 83       	std	Z+3, r25	; 0x03
    7650:	82 83       	std	Z+2, r24	; 0x02
    7652:	d7 01       	movw	r26, r14
    7654:	11 96       	adiw	r26, 0x01	; 1
    7656:	8c 91       	ld	r24, X
    7658:	84 83       	std	Z+4, r24	; 0x04
    765a:	15 82       	std	Z+5, r1	; 0x05
    765c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7660:	ed b7       	in	r30, 0x3d	; 61
    7662:	fe b7       	in	r31, 0x3e	; 62
    7664:	36 96       	adiw	r30, 0x06	; 6
    7666:	0f b6       	in	r0, 0x3f	; 63
    7668:	f8 94       	cli
    766a:	fe bf       	out	0x3e, r31	; 62
    766c:	0f be       	out	0x3f, r0	; 63
    766e:	ed bf       	out	0x3d, r30	; 61
}
    7670:	df 91       	pop	r29
    7672:	cf 91       	pop	r28
    7674:	1f 91       	pop	r17
    7676:	0f 91       	pop	r16
    7678:	ff 90       	pop	r15
    767a:	ef 90       	pop	r14
    767c:	08 95       	ret

0000767e <icmpEchoRequest>:
      break;
  }
}

void icmpEchoRequest(void)
{
    767e:	0f 93       	push	r16
    7680:	1f 93       	push	r17
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    7682:	20 91 c1 0e 	lds	r18, 0x0EC1
    7686:	30 91 c2 0e 	lds	r19, 0x0EC2
    768a:	21 15       	cp	r18, r1
    768c:	31 05       	cpc	r19, r1
    768e:	a1 f0       	breq	.+40     	; 0x76b8 <icmpEchoRequest+0x3a>
  {
    if (icmpDebugLevel > 1)
    7690:	80 91 66 0f 	lds	r24, 0x0F66
    7694:	82 30       	cpi	r24, 0x02	; 2
    7696:	80 f0       	brcs	.+32     	; 0x76b8 <icmpEchoRequest+0x3a>
      fprintf_P(icmpDebug, PSTR("Received ICMP request: "));
    7698:	00 d0       	rcall	.+0      	; 0x769a <icmpEchoRequest+0x1c>
    769a:	00 d0       	rcall	.+0      	; 0x769c <icmpEchoRequest+0x1e>
    769c:	ed b7       	in	r30, 0x3d	; 61
    769e:	fe b7       	in	r31, 0x3e	; 62
    76a0:	32 83       	std	Z+2, r19	; 0x02
    76a2:	21 83       	std	Z+1, r18	; 0x01
    76a4:	86 e7       	ldi	r24, 0x76	; 118
    76a6:	9f e0       	ldi	r25, 0x0F	; 15
    76a8:	94 83       	std	Z+4, r25	; 0x04
    76aa:	83 83       	std	Z+3, r24	; 0x03
    76ac:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    76b0:	0f 90       	pop	r0
    76b2:	0f 90       	pop	r0
    76b4:	0f 90       	pop	r0
    76b6:	0f 90       	pop	r0
  }
#endif
  uint32_t tempIp;

  // change type to reply
  nicState.layer4.icmp->type = ICMP_TYPE_ECHOREPLY;
    76b8:	e0 91 a1 0e 	lds	r30, 0x0EA1
    76bc:	f0 91 a2 0e 	lds	r31, 0x0EA2
    76c0:	10 82       	st	Z, r1
  // recalculate checksum
  nicState.layer4.icmp->icmpchksum = 0;
    76c2:	00 91 a1 0e 	lds	r16, 0x0EA1
    76c6:	10 91 a2 0e 	lds	r17, 0x0EA2
    76ca:	f8 01       	movw	r30, r16
    76cc:	13 82       	std	Z+3, r1	; 0x03
    76ce:	12 82       	std	Z+2, r1	; 0x02
  nicState.layer4.icmp->icmpchksum = netChecksum((uint8_t*)(nicState.layer4.icmp), htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
    76d0:	e0 91 9f 0e 	lds	r30, 0x0E9F
    76d4:	f0 91 a0 0e 	lds	r31, 0x0EA0
    76d8:	82 81       	ldd	r24, Z+2	; 0x02
    76da:	93 81       	ldd	r25, Z+3	; 0x03
    76dc:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    76e0:	bc 01       	movw	r22, r24
    76e2:	64 51       	subi	r22, 0x14	; 20
    76e4:	70 40       	sbci	r23, 0x00	; 0
    76e6:	c8 01       	movw	r24, r16
    76e8:	0e 94 c8 33 	call	0x6790	; 0x6790 <netChecksum>
    76ec:	f8 01       	movw	r30, r16
    76ee:	93 83       	std	Z+3, r25	; 0x03
    76f0:	82 83       	std	Z+2, r24	; 0x02
  // return to sender
  tempIp = nicState.layer3.ip->destipaddr;
    76f2:	e0 91 9f 0e 	lds	r30, 0x0E9F
    76f6:	f0 91 a0 0e 	lds	r31, 0x0EA0
    76fa:	20 89       	ldd	r18, Z+16	; 0x10
    76fc:	31 89       	ldd	r19, Z+17	; 0x11
    76fe:	42 89       	ldd	r20, Z+18	; 0x12
    7700:	53 89       	ldd	r21, Z+19	; 0x13
  nicState.layer3.ip->destipaddr = nicState.layer3.ip->srcipaddr;
    7702:	84 85       	ldd	r24, Z+12	; 0x0c
    7704:	95 85       	ldd	r25, Z+13	; 0x0d
    7706:	a6 85       	ldd	r26, Z+14	; 0x0e
    7708:	b7 85       	ldd	r27, Z+15	; 0x0f
    770a:	80 8b       	std	Z+16, r24	; 0x10
    770c:	91 8b       	std	Z+17, r25	; 0x11
    770e:	a2 8b       	std	Z+18, r26	; 0x12
    7710:	b3 8b       	std	Z+19, r27	; 0x13
  nicState.layer3.ip->srcipaddr = tempIp;
    7712:	24 87       	std	Z+12, r18	; 0x0c
    7714:	35 87       	std	Z+13, r19	; 0x0d
    7716:	46 87       	std	Z+14, r20	; 0x0e
    7718:	57 87       	std	Z+15, r21	; 0x0f
  // add ethernet routing
  arpIpOut(0);
    771a:	60 e0       	ldi	r22, 0x00	; 0
    771c:	70 e0       	ldi	r23, 0x00	; 0
    771e:	80 e0       	ldi	r24, 0x00	; 0
    7720:	90 e0       	ldi	r25, 0x00	; 0
    7722:	0e 94 ed 3e 	call	0x7dda	; 0x7dda <arpIpOut>

  // debugging
  if (icmpDebug != NULL)
    7726:	80 91 c1 0e 	lds	r24, 0x0EC1
    772a:	90 91 c2 0e 	lds	r25, 0x0EC2
    772e:	00 97       	sbiw	r24, 0x00	; 0
    7730:	51 f0       	breq	.+20     	; 0x7746 <icmpEchoRequest+0xc8>
    icmpPrintHeader(icmpDebug, nicState.layer3.ip, nicState.layer4.icmp);
    7732:	60 91 9f 0e 	lds	r22, 0x0E9F
    7736:	70 91 a0 0e 	lds	r23, 0x0EA0
    773a:	40 91 a1 0e 	lds	r20, 0x0EA1
    773e:	50 91 a2 0e 	lds	r21, 0x0EA2
    7742:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <icmpPrintHeader>
  //debugPrintHexTable(htons(packet->ip.len), (uint8_t*)packet);

  // send it (packet->ip.len+ETH_HEADER_LEN
  nicSend(htons(nicState.layer3.ip->len) + ETH_HEADER_LEN);
    7746:	e0 91 9f 0e 	lds	r30, 0x0E9F
    774a:	f0 91 a0 0e 	lds	r31, 0x0EA0
    774e:	82 81       	ldd	r24, Z+2	; 0x02
    7750:	93 81       	ldd	r25, Z+3	; 0x03
    7752:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    7756:	0e 96       	adiw	r24, 0x0e	; 14
    7758:	0e 94 de 31 	call	0x63bc	; 0x63bc <nicSend>
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    775c:	20 91 c1 0e 	lds	r18, 0x0EC1
    7760:	30 91 c2 0e 	lds	r19, 0x0EC2
    7764:	21 15       	cp	r18, r1
    7766:	31 05       	cpc	r19, r1
    7768:	a1 f0       	breq	.+40     	; 0x7792 <icmpEchoRequest+0x114>
  {
    if (icmpDebugLevel > 1)
    776a:	80 91 66 0f 	lds	r24, 0x0F66
    776e:	82 30       	cpi	r24, 0x02	; 2
    7770:	80 f0       	brcs	.+32     	; 0x7792 <icmpEchoRequest+0x114>
      fprintf_P(icmpDebug, PSTR("Sending ICMP PONG\r\n"));
    7772:	00 d0       	rcall	.+0      	; 0x7774 <icmpEchoRequest+0xf6>
    7774:	00 d0       	rcall	.+0      	; 0x7776 <icmpEchoRequest+0xf8>
    7776:	ed b7       	in	r30, 0x3d	; 61
    7778:	fe b7       	in	r31, 0x3e	; 62
    777a:	32 83       	std	Z+2, r19	; 0x02
    777c:	21 83       	std	Z+1, r18	; 0x01
    777e:	82 e6       	ldi	r24, 0x62	; 98
    7780:	9f e0       	ldi	r25, 0x0F	; 15
    7782:	94 83       	std	Z+4, r25	; 0x04
    7784:	83 83       	std	Z+3, r24	; 0x03
    7786:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    778a:	0f 90       	pop	r0
    778c:	0f 90       	pop	r0
    778e:	0f 90       	pop	r0
    7790:	0f 90       	pop	r0
  }
#endif
}
    7792:	1f 91       	pop	r17
    7794:	0f 91       	pop	r16
    7796:	08 95       	ret

00007798 <icmpIpIn>:
}

void icmpIpIn(void)
{
  // check ICMP type
  switch(nicState.layer4.icmp->type)
    7798:	e0 91 a1 0e 	lds	r30, 0x0EA1
    779c:	f0 91 a2 0e 	lds	r31, 0x0EA2
    77a0:	80 81       	ld	r24, Z
    77a2:	88 30       	cpi	r24, 0x08	; 8
    77a4:	19 f4       	brne	.+6      	; 0x77ac <icmpIpIn+0x14>
  {
    case ICMP_TYPE_ECHOREQUEST:
      icmpEchoRequest();       // echo request
    77a6:	0e 94 3f 3b 	call	0x767e	; 0x767e <icmpEchoRequest>
    77aa:	08 95       	ret
      break;
    default:
#if ICMP_DEBUG
      if (icmpDebug != NULL)
    77ac:	20 91 c1 0e 	lds	r18, 0x0EC1
    77b0:	30 91 c2 0e 	lds	r19, 0x0EC2
    77b4:	21 15       	cp	r18, r1
    77b6:	31 05       	cpc	r19, r1
    77b8:	a1 f0       	breq	.+40     	; 0x77e2 <icmpIpIn+0x4a>
      {
        if (icmpDebugLevel > 0)
    77ba:	80 91 66 0f 	lds	r24, 0x0F66
    77be:	88 23       	and	r24, r24
    77c0:	81 f0       	breq	.+32     	; 0x77e2 <icmpIpIn+0x4a>
          fprintf_P(icmpDebug, PSTR("Unknown ICMP typeReceived ICMP request: "));
    77c2:	00 d0       	rcall	.+0      	; 0x77c4 <icmpIpIn+0x2c>
    77c4:	00 d0       	rcall	.+0      	; 0x77c6 <icmpIpIn+0x2e>
    77c6:	ed b7       	in	r30, 0x3d	; 61
    77c8:	fe b7       	in	r31, 0x3e	; 62
    77ca:	32 83       	std	Z+2, r19	; 0x02
    77cc:	21 83       	std	Z+1, r18	; 0x01
    77ce:	8e e8       	ldi	r24, 0x8E	; 142
    77d0:	9f e0       	ldi	r25, 0x0F	; 15
    77d2:	94 83       	std	Z+4, r25	; 0x04
    77d4:	83 83       	std	Z+3, r24	; 0x03
    77d6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    77da:	0f 90       	pop	r0
    77dc:	0f 90       	pop	r0
    77de:	0f 90       	pop	r0
    77e0:	0f 90       	pop	r0
    77e2:	08 95       	ret

000077e4 <setArpDebug>:

#ifdef ARP_DEBUG

void setArpDebug(FILE *stream, uint8_t level)
{
  arpDebug = stream;
    77e4:	90 93 a4 0e 	sts	0x0EA4, r25
    77e8:	80 93 a3 0e 	sts	0x0EA3, r24
  arpDebugLevel = level;
    77ec:	60 93 7c 0f 	sts	0x0F7C, r22
  if (level == 0)
    77f0:	66 23       	and	r22, r22
    77f2:	21 f4       	brne	.+8      	; 0x77fc <setArpDebug+0x18>
    arpDebug = NULL;
    77f4:	10 92 a4 0e 	sts	0x0EA4, r1
    77f8:	10 92 a3 0e 	sts	0x0EA3, r1
    77fc:	08 95       	ret

000077fe <arpTimer>:
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}

void arpTimer(void)
{
    77fe:	e1 e9       	ldi	r30, 0x91	; 145
    7800:	ff e0       	ldi	r31, 0x0F	; 15
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time)
    7802:	80 81       	ld	r24, Z
    7804:	88 23       	and	r24, r24
    7806:	11 f0       	breq	.+4      	; 0x780c <arpTimer+0xe>
      ArpTable[index].time--;
    7808:	81 50       	subi	r24, 0x01	; 1
    780a:	80 83       	st	Z, r24
    780c:	3b 96       	adiw	r30, 0x0b	; 11
{
  int index;
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
    780e:	8f e0       	ldi	r24, 0x0F	; 15
    7810:	ef 3f       	cpi	r30, 0xFF	; 255
    7812:	f8 07       	cpc	r31, r24
    7814:	b1 f7       	brne	.-20     	; 0x7802 <arpTimer+0x4>
  {
    if(ArpTable[index].time)
      ArpTable[index].time--;
  }
}
    7816:	08 95       	ret

00007818 <arpMatchIp>:

int arpMatchIp(uint32_t ipaddr)
{
    7818:	ab 01       	movw	r20, r22
    781a:	bc 01       	movw	r22, r24
    781c:	e7 e8       	ldi	r30, 0x87	; 135
    781e:	ff e0       	ldi	r31, 0x0F	; 15
    7820:	80 e0       	ldi	r24, 0x00	; 0
    7822:	90 e0       	ldi	r25, 0x00	; 0
    7824:	9c 01       	movw	r18, r24
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    7826:	80 81       	ld	r24, Z
    7828:	91 81       	ldd	r25, Z+1	; 0x01
    782a:	a2 81       	ldd	r26, Z+2	; 0x02
    782c:	b3 81       	ldd	r27, Z+3	; 0x03
    782e:	84 17       	cp	r24, r20
    7830:	95 07       	cpc	r25, r21
    7832:	a6 07       	cpc	r26, r22
    7834:	b7 07       	cpc	r27, r23
    7836:	41 f0       	breq	.+16     	; 0x7848 <arpMatchIp+0x30>
    7838:	c9 01       	movw	r24, r18
    783a:	01 96       	adiw	r24, 0x01	; 1
    783c:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    783e:	8a 30       	cpi	r24, 0x0A	; 10
    7840:	91 05       	cpc	r25, r1
    7842:	81 f7       	brne	.-32     	; 0x7824 <arpMatchIp+0xc>
    7844:	2f ef       	ldi	r18, 0xFF	; 255
    7846:	3f ef       	ldi	r19, 0xFF	; 255
    }
  }

// no match
  return -1;
}
    7848:	c9 01       	movw	r24, r18
    784a:	08 95       	ret

0000784c <arpPrintTable>:
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
}
#endif /*ARP_DEBUG*/

void arpPrintTable(FILE *stream)
{
    784c:	6f 92       	push	r6
    784e:	7f 92       	push	r7
    7850:	8f 92       	push	r8
    7852:	9f 92       	push	r9
    7854:	af 92       	push	r10
    7856:	bf 92       	push	r11
    7858:	cf 92       	push	r12
    785a:	df 92       	push	r13
    785c:	ef 92       	push	r14
    785e:	ff 92       	push	r15
    7860:	0f 93       	push	r16
    7862:	1f 93       	push	r17
    7864:	cf 93       	push	r28
    7866:	df 93       	push	r29
    7868:	ec 01       	movw	r28, r24
  uint8_t i;

  // print ARP table
  fprintf_P(stream, PSTR("Time Eth Address        IP Address\r\n"));
    786a:	00 d0       	rcall	.+0      	; 0x786c <arpPrintTable+0x20>
    786c:	00 d0       	rcall	.+0      	; 0x786e <arpPrintTable+0x22>
    786e:	ad b7       	in	r26, 0x3d	; 61
    7870:	be b7       	in	r27, 0x3e	; 62
    7872:	12 96       	adiw	r26, 0x02	; 2
    7874:	9c 93       	st	X, r25
    7876:	8e 93       	st	-X, r24
    7878:	11 97       	sbiw	r26, 0x01	; 1
    787a:	85 ef       	ldi	r24, 0xF5	; 245
    787c:	9f e0       	ldi	r25, 0x0F	; 15
    787e:	14 96       	adiw	r26, 0x04	; 4
    7880:	9c 93       	st	X, r25
    7882:	8e 93       	st	-X, r24
    7884:	13 97       	sbiw	r26, 0x03	; 3
    7886:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("-----------------------------------\r\n"));
    788a:	ed b7       	in	r30, 0x3d	; 61
    788c:	fe b7       	in	r31, 0x3e	; 62
    788e:	d2 83       	std	Z+2, r29	; 0x02
    7890:	c1 83       	std	Z+1, r28	; 0x01
    7892:	8f ec       	ldi	r24, 0xCF	; 207
    7894:	9f e0       	ldi	r25, 0x0F	; 15
    7896:	94 83       	std	Z+4, r25	; 0x04
    7898:	83 83       	std	Z+3, r24	; 0x03
    789a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR(" MY  "));
    789e:	ad b7       	in	r26, 0x3d	; 61
    78a0:	be b7       	in	r27, 0x3e	; 62
    78a2:	12 96       	adiw	r26, 0x02	; 2
    78a4:	dc 93       	st	X, r29
    78a6:	ce 93       	st	-X, r28
    78a8:	11 97       	sbiw	r26, 0x01	; 1
    78aa:	89 ec       	ldi	r24, 0xC9	; 201
    78ac:	9f e0       	ldi	r25, 0x0F	; 15
    78ae:	14 96       	adiw	r26, 0x04	; 4
    78b0:	9c 93       	st	X, r25
    78b2:	8e 93       	st	-X, r24
    78b4:	13 97       	sbiw	r26, 0x03	; 3
    78b6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    78ba:	0f 90       	pop	r0
    78bc:	0f 90       	pop	r0
    78be:	0f 90       	pop	r0
    78c0:	0f 90       	pop	r0
    78c2:	ce 01       	movw	r24, r28
    78c4:	67 e9       	ldi	r22, 0x97	; 151
    78c6:	7e e0       	ldi	r23, 0x0E	; 14
    78c8:	0e 94 a2 36 	call	0x6d44	; 0x6d44 <netPrintEthAddr>
  fprintf_P(stream, PSTR("  "));
    78cc:	00 d0       	rcall	.+0      	; 0x78ce <arpPrintTable+0x82>
    78ce:	00 d0       	rcall	.+0      	; 0x78d0 <arpPrintTable+0x84>
    78d0:	ed b7       	in	r30, 0x3d	; 61
    78d2:	fe b7       	in	r31, 0x3e	; 62
    78d4:	d2 83       	std	Z+2, r29	; 0x02
    78d6:	c1 83       	std	Z+1, r28	; 0x01
    78d8:	86 ec       	ldi	r24, 0xC6	; 198
    78da:	9f e0       	ldi	r25, 0x0F	; 15
    78dc:	94 83       	std	Z+4, r25	; 0x04
    78de:	83 83       	std	Z+3, r24	; 0x03
    78e0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  netPrintIPAddr(stream, IpMyConfig.ip);
    78e4:	0f 90       	pop	r0
    78e6:	0f 90       	pop	r0
    78e8:	0f 90       	pop	r0
    78ea:	0f 90       	pop	r0
    78ec:	40 91 6a 0f 	lds	r20, 0x0F6A
    78f0:	50 91 6b 0f 	lds	r21, 0x0F6B
    78f4:	60 91 6c 0f 	lds	r22, 0x0F6C
    78f8:	70 91 6d 0f 	lds	r23, 0x0F6D
    78fc:	ce 01       	movw	r24, r28
    78fe:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    7902:	00 d0       	rcall	.+0      	; 0x7904 <arpPrintTable+0xb8>
    7904:	00 d0       	rcall	.+0      	; 0x7906 <arpPrintTable+0xba>
    7906:	ad b7       	in	r26, 0x3d	; 61
    7908:	be b7       	in	r27, 0x3e	; 62
    790a:	12 96       	adiw	r26, 0x02	; 2
    790c:	dc 93       	st	X, r29
    790e:	ce 93       	st	-X, r28
    7910:	11 97       	sbiw	r26, 0x01	; 1
    7912:	83 ec       	ldi	r24, 0xC3	; 195
    7914:	9f e0       	ldi	r25, 0x0F	; 15
    7916:	14 96       	adiw	r26, 0x04	; 4
    7918:	9c 93       	st	X, r25
    791a:	8e 93       	st	-X, r24
    791c:	13 97       	sbiw	r26, 0x03	; 3
    791e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7922:	07 e8       	ldi	r16, 0x87	; 135
    7924:	1f e0       	ldi	r17, 0x0F	; 15
    7926:	ee 24       	eor	r14, r14
    7928:	ff 24       	eor	r15, r15
    792a:	0f 90       	pop	r0
    792c:	0f 90       	pop	r0
    792e:	0f 90       	pop	r0
    7930:	0f 90       	pop	r0

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    7932:	3d eb       	ldi	r19, 0xBD	; 189
    7934:	63 2e       	mov	r6, r19
    7936:	3f e0       	ldi	r19, 0x0F	; 15
    7938:	73 2e       	mov	r7, r19
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    793a:	2b e0       	ldi	r18, 0x0B	; 11
    793c:	82 2e       	mov	r8, r18
    793e:	91 2c       	mov	r9, r1
    fprintf_P(stream, PSTR("  "));
    7940:	9a eb       	ldi	r25, 0xBA	; 186
    7942:	a9 2e       	mov	r10, r25
    7944:	9f e0       	ldi	r25, 0x0F	; 15
    7946:	b9 2e       	mov	r11, r25
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
    7948:	87 eb       	ldi	r24, 0xB7	; 183
    794a:	c8 2e       	mov	r12, r24
    794c:	8f e0       	ldi	r24, 0x0F	; 15
    794e:	d8 2e       	mov	r13, r24
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
    7950:	f8 01       	movw	r30, r16
    7952:	80 81       	ld	r24, Z
    7954:	91 81       	ldd	r25, Z+1	; 0x01
    7956:	a2 81       	ldd	r26, Z+2	; 0x02
    7958:	b3 81       	ldd	r27, Z+3	; 0x03
    795a:	00 97       	sbiw	r24, 0x00	; 0
    795c:	a1 05       	cpc	r26, r1
    795e:	b1 05       	cpc	r27, r1
    7960:	09 f4       	brne	.+2      	; 0x7964 <arpPrintTable+0x118>
    7962:	55 c0       	rjmp	.+170    	; 0x7a0e <arpPrintTable+0x1c2>
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    7964:	00 d0       	rcall	.+0      	; 0x7966 <arpPrintTable+0x11a>
    7966:	00 d0       	rcall	.+0      	; 0x7968 <arpPrintTable+0x11c>
    7968:	00 d0       	rcall	.+0      	; 0x796a <arpPrintTable+0x11e>
    796a:	ed b7       	in	r30, 0x3d	; 61
    796c:	fe b7       	in	r31, 0x3e	; 62
    796e:	31 96       	adiw	r30, 0x01	; 1
    7970:	ad b7       	in	r26, 0x3d	; 61
    7972:	be b7       	in	r27, 0x3e	; 62
    7974:	12 96       	adiw	r26, 0x02	; 2
    7976:	dc 93       	st	X, r29
    7978:	ce 93       	st	-X, r28
    797a:	11 97       	sbiw	r26, 0x01	; 1
    797c:	73 82       	std	Z+3, r7	; 0x03
    797e:	62 82       	std	Z+2, r6	; 0x02
    7980:	d8 01       	movw	r26, r16
    7982:	1a 96       	adiw	r26, 0x0a	; 10
    7984:	8c 91       	ld	r24, X
    7986:	84 83       	std	Z+4, r24	; 0x04
    7988:	15 82       	std	Z+5, r1	; 0x05
    798a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    798e:	ed b7       	in	r30, 0x3d	; 61
    7990:	fe b7       	in	r31, 0x3e	; 62
    7992:	36 96       	adiw	r30, 0x06	; 6
    7994:	0f b6       	in	r0, 0x3f	; 63
    7996:	f8 94       	cli
    7998:	fe bf       	out	0x3e, r31	; 62
    799a:	0f be       	out	0x3f, r0	; 63
    799c:	ed bf       	out	0x3d, r30	; 61
    799e:	e8 9c       	mul	r14, r8
    79a0:	b0 01       	movw	r22, r0
    79a2:	e9 9c       	mul	r14, r9
    79a4:	70 0d       	add	r23, r0
    79a6:	f8 9c       	mul	r15, r8
    79a8:	70 0d       	add	r23, r0
    79aa:	11 24       	eor	r1, r1
    79ac:	65 57       	subi	r22, 0x75	; 117
    79ae:	70 4f       	sbci	r23, 0xF0	; 240
    79b0:	ce 01       	movw	r24, r28
    79b2:	0e 94 a2 36 	call	0x6d44	; 0x6d44 <netPrintEthAddr>
    fprintf_P(stream, PSTR("  "));
    79b6:	00 d0       	rcall	.+0      	; 0x79b8 <arpPrintTable+0x16c>
    79b8:	00 d0       	rcall	.+0      	; 0x79ba <arpPrintTable+0x16e>
    79ba:	ad b7       	in	r26, 0x3d	; 61
    79bc:	be b7       	in	r27, 0x3e	; 62
    79be:	12 96       	adiw	r26, 0x02	; 2
    79c0:	dc 93       	st	X, r29
    79c2:	ce 93       	st	-X, r28
    79c4:	11 97       	sbiw	r26, 0x01	; 1
    79c6:	14 96       	adiw	r26, 0x04	; 4
    79c8:	bc 92       	st	X, r11
    79ca:	ae 92       	st	-X, r10
    79cc:	13 97       	sbiw	r26, 0x03	; 3
    79ce:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    79d2:	0f 90       	pop	r0
    79d4:	0f 90       	pop	r0
    79d6:	0f 90       	pop	r0
    79d8:	0f 90       	pop	r0
    79da:	f8 01       	movw	r30, r16
    79dc:	40 81       	ld	r20, Z
    79de:	51 81       	ldd	r21, Z+1	; 0x01
    79e0:	62 81       	ldd	r22, Z+2	; 0x02
    79e2:	73 81       	ldd	r23, Z+3	; 0x03
    79e4:	ce 01       	movw	r24, r28
    79e6:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    fprintf_P(stream, PSTR("\r\n"));
    79ea:	00 d0       	rcall	.+0      	; 0x79ec <arpPrintTable+0x1a0>
    79ec:	00 d0       	rcall	.+0      	; 0x79ee <arpPrintTable+0x1a2>
    79ee:	ad b7       	in	r26, 0x3d	; 61
    79f0:	be b7       	in	r27, 0x3e	; 62
    79f2:	12 96       	adiw	r26, 0x02	; 2
    79f4:	dc 93       	st	X, r29
    79f6:	ce 93       	st	-X, r28
    79f8:	11 97       	sbiw	r26, 0x01	; 1
    79fa:	14 96       	adiw	r26, 0x04	; 4
    79fc:	dc 92       	st	X, r13
    79fe:	ce 92       	st	-X, r12
    7a00:	13 97       	sbiw	r26, 0x03	; 3
    7a02:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7a06:	0f 90       	pop	r0
    7a08:	0f 90       	pop	r0
    7a0a:	0f 90       	pop	r0
    7a0c:	0f 90       	pop	r0
    7a0e:	08 94       	sec
    7a10:	e1 1c       	adc	r14, r1
    7a12:	f1 1c       	adc	r15, r1
    7a14:	05 5f       	subi	r16, 0xF5	; 245
    7a16:	1f 4f       	sbci	r17, 0xFF	; 255
  netPrintEthAddr(stream, &nicState.mac);
  fprintf_P(stream, PSTR("  "));
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
    7a18:	ba e0       	ldi	r27, 0x0A	; 10
    7a1a:	eb 16       	cp	r14, r27
    7a1c:	f1 04       	cpc	r15, r1
    7a1e:	09 f0       	breq	.+2      	; 0x7a22 <arpPrintTable+0x1d6>
    7a20:	97 cf       	rjmp	.-210    	; 0x7950 <arpPrintTable+0x104>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
  }
}
    7a22:	df 91       	pop	r29
    7a24:	cf 91       	pop	r28
    7a26:	1f 91       	pop	r17
    7a28:	0f 91       	pop	r16
    7a2a:	ff 90       	pop	r15
    7a2c:	ef 90       	pop	r14
    7a2e:	df 90       	pop	r13
    7a30:	cf 90       	pop	r12
    7a32:	bf 90       	pop	r11
    7a34:	af 90       	pop	r10
    7a36:	9f 90       	pop	r9
    7a38:	8f 90       	pop	r8
    7a3a:	7f 90       	pop	r7
    7a3c:	6f 90       	pop	r6
    7a3e:	08 95       	ret

00007a40 <arpIpIn>:
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
  }
}

void arpIpIn(void)
{
    7a40:	cf 93       	push	r28
    7a42:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    7a44:	20 91 a3 0e 	lds	r18, 0x0EA3
    7a48:	30 91 a4 0e 	lds	r19, 0x0EA4
    7a4c:	21 15       	cp	r18, r1
    7a4e:	31 05       	cpc	r19, r1
    7a50:	09 f4       	brne	.+2      	; 0x7a54 <arpIpIn+0x14>
    7a52:	57 c0       	rjmp	.+174    	; 0x7b02 <arpIpIn+0xc2>
  {
    if (arpDebugLevel > 0)
    7a54:	80 91 7c 0f 	lds	r24, 0x0F7C
    7a58:	88 23       	and	r24, r24
    7a5a:	09 f4       	brne	.+2      	; 0x7a5e <arpIpIn+0x1e>
    7a5c:	52 c0       	rjmp	.+164    	; 0x7b02 <arpIpIn+0xc2>
    {
      fprintf_P(arpDebug, PSTR("ARP IP in MAC: "));
    7a5e:	00 d0       	rcall	.+0      	; 0x7a60 <arpIpIn+0x20>
    7a60:	00 d0       	rcall	.+0      	; 0x7a62 <arpIpIn+0x22>
    7a62:	ed b7       	in	r30, 0x3d	; 61
    7a64:	fe b7       	in	r31, 0x3e	; 62
    7a66:	32 83       	std	Z+2, r19	; 0x02
    7a68:	21 83       	std	Z+1, r18	; 0x01
    7a6a:	81 ea       	ldi	r24, 0xA1	; 161
    7a6c:	90 e1       	ldi	r25, 0x10	; 16
    7a6e:	94 83       	std	Z+4, r25	; 0x04
    7a70:	83 83       	std	Z+3, r24	; 0x03
    7a72:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      netPrintEthAddr(arpDebug, &nicState.layer2.ethHeader->src);
    7a76:	0f 90       	pop	r0
    7a78:	0f 90       	pop	r0
    7a7a:	0f 90       	pop	r0
    7a7c:	0f 90       	pop	r0
    7a7e:	60 91 9d 0e 	lds	r22, 0x0E9D
    7a82:	70 91 9e 0e 	lds	r23, 0x0E9E
    7a86:	6a 5f       	subi	r22, 0xFA	; 250
    7a88:	7f 4f       	sbci	r23, 0xFF	; 255
    7a8a:	80 91 a3 0e 	lds	r24, 0x0EA3
    7a8e:	90 91 a4 0e 	lds	r25, 0x0EA4
    7a92:	0e 94 a2 36 	call	0x6d44	; 0x6d44 <netPrintEthAddr>
      fprintf_P(arpDebug, PSTR(" IP: "));
    7a96:	00 d0       	rcall	.+0      	; 0x7a98 <arpIpIn+0x58>
    7a98:	00 d0       	rcall	.+0      	; 0x7a9a <arpIpIn+0x5a>
    7a9a:	80 91 a3 0e 	lds	r24, 0x0EA3
    7a9e:	90 91 a4 0e 	lds	r25, 0x0EA4
    7aa2:	ed b7       	in	r30, 0x3d	; 61
    7aa4:	fe b7       	in	r31, 0x3e	; 62
    7aa6:	92 83       	std	Z+2, r25	; 0x02
    7aa8:	81 83       	std	Z+1, r24	; 0x01
    7aaa:	8b e9       	ldi	r24, 0x9B	; 155
    7aac:	90 e1       	ldi	r25, 0x10	; 16
    7aae:	94 83       	std	Z+4, r25	; 0x04
    7ab0:	83 83       	std	Z+3, r24	; 0x03
    7ab2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      netPrintIPAddr(arpDebug, nicState.layer3.ip->srcipaddr);
    7ab6:	0f 90       	pop	r0
    7ab8:	0f 90       	pop	r0
    7aba:	0f 90       	pop	r0
    7abc:	0f 90       	pop	r0
    7abe:	e0 91 9f 0e 	lds	r30, 0x0E9F
    7ac2:	f0 91 a0 0e 	lds	r31, 0x0EA0
    7ac6:	44 85       	ldd	r20, Z+12	; 0x0c
    7ac8:	55 85       	ldd	r21, Z+13	; 0x0d
    7aca:	66 85       	ldd	r22, Z+14	; 0x0e
    7acc:	77 85       	ldd	r23, Z+15	; 0x0f
    7ace:	80 91 a3 0e 	lds	r24, 0x0EA3
    7ad2:	90 91 a4 0e 	lds	r25, 0x0EA4
    7ad6:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
      fprintf_P(arpDebug, PSTR("\r\n"));
    7ada:	00 d0       	rcall	.+0      	; 0x7adc <arpIpIn+0x9c>
    7adc:	00 d0       	rcall	.+0      	; 0x7ade <arpIpIn+0x9e>
    7ade:	80 91 a3 0e 	lds	r24, 0x0EA3
    7ae2:	90 91 a4 0e 	lds	r25, 0x0EA4
    7ae6:	ed b7       	in	r30, 0x3d	; 61
    7ae8:	fe b7       	in	r31, 0x3e	; 62
    7aea:	92 83       	std	Z+2, r25	; 0x02
    7aec:	81 83       	std	Z+1, r24	; 0x01
    7aee:	88 e9       	ldi	r24, 0x98	; 152
    7af0:	90 e1       	ldi	r25, 0x10	; 16
    7af2:	94 83       	std	Z+4, r25	; 0x04
    7af4:	83 83       	std	Z+3, r24	; 0x03
    7af6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7afa:	0f 90       	pop	r0
    7afc:	0f 90       	pop	r0
    7afe:	0f 90       	pop	r0
    7b00:	0f 90       	pop	r0
  }
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
    7b02:	c0 91 9f 0e 	lds	r28, 0x0E9F
    7b06:	d0 91 a0 0e 	lds	r29, 0x0EA0
    7b0a:	4c 85       	ldd	r20, Y+12	; 0x0c
    7b0c:	5d 85       	ldd	r21, Y+13	; 0x0d
    7b0e:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b10:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b12:	e7 e8       	ldi	r30, 0x87	; 135
    7b14:	ff e0       	ldi	r31, 0x0F	; 15
    7b16:	80 e0       	ldi	r24, 0x00	; 0
    7b18:	90 e0       	ldi	r25, 0x00	; 0
    7b1a:	9c 01       	movw	r18, r24
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    7b1c:	80 81       	ld	r24, Z
    7b1e:	91 81       	ldd	r25, Z+1	; 0x01
    7b20:	a2 81       	ldd	r26, Z+2	; 0x02
    7b22:	b3 81       	ldd	r27, Z+3	; 0x03
    7b24:	84 17       	cp	r24, r20
    7b26:	95 07       	cpc	r25, r21
    7b28:	a6 07       	cpc	r26, r22
    7b2a:	b7 07       	cpc	r27, r23
    7b2c:	41 f0       	breq	.+16     	; 0x7b3e <arpIpIn+0xfe>
    7b2e:	c9 01       	movw	r24, r18
    7b30:	01 96       	adiw	r24, 0x01	; 1
    7b32:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    7b34:	8a 30       	cpi	r24, 0x0A	; 10
    7b36:	91 05       	cpc	r25, r1
    7b38:	81 f7       	brne	.-32     	; 0x7b1a <arpIpIn+0xda>
    7b3a:	2f ef       	ldi	r18, 0xFF	; 255
    7b3c:	3f ef       	ldi	r19, 0xFF	; 255
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
  if(index != -1)
    7b3e:	2f 3f       	cpi	r18, 0xFF	; 255
    7b40:	21 f1       	breq	.+72     	; 0x7b8a <arpIpIn+0x14a>
  {
// sender's IP address found, update ARP entry
    ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    7b42:	33 27       	eor	r19, r19
    7b44:	27 fd       	sbrc	r18, 7
    7b46:	30 95       	com	r19
    7b48:	8b e0       	ldi	r24, 0x0B	; 11
    7b4a:	90 e0       	ldi	r25, 0x00	; 0
    7b4c:	28 9f       	mul	r18, r24
    7b4e:	d0 01       	movw	r26, r0
    7b50:	29 9f       	mul	r18, r25
    7b52:	b0 0d       	add	r27, r0
    7b54:	38 9f       	mul	r19, r24
    7b56:	b0 0d       	add	r27, r0
    7b58:	11 24       	eor	r1, r1
    7b5a:	e0 91 9d 0e 	lds	r30, 0x0E9D
    7b5e:	f0 91 9e 0e 	lds	r31, 0x0E9E
    7b62:	a5 57       	subi	r26, 0x75	; 117
    7b64:	b0 4f       	sbci	r27, 0xF0	; 240
    7b66:	36 96       	adiw	r30, 0x06	; 6
    7b68:	86 e0       	ldi	r24, 0x06	; 6
    7b6a:	01 90       	ld	r0, Z+
    7b6c:	0d 92       	st	X+, r0
    7b6e:	81 50       	subi	r24, 0x01	; 1
    7b70:	e1 f7       	brne	.-8      	; 0x7b6a <arpIpIn+0x12a>
    ArpTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    7b72:	8b e0       	ldi	r24, 0x0B	; 11
    7b74:	90 e0       	ldi	r25, 0x00	; 0
    7b76:	28 9f       	mul	r18, r24
    7b78:	f0 01       	movw	r30, r0
    7b7a:	29 9f       	mul	r18, r25
    7b7c:	f0 0d       	add	r31, r0
    7b7e:	38 9f       	mul	r19, r24
    7b80:	f0 0d       	add	r31, r0
    7b82:	11 24       	eor	r1, r1
    7b84:	e9 57       	subi	r30, 0x79	; 121
    7b86:	f0 4f       	sbci	r31, 0xF0	; 240
    7b88:	2f c0       	rjmp	.+94     	; 0x7be8 <arpIpIn+0x1a8>
// and we're done
    return;
    7b8a:	e1 e9       	ldi	r30, 0x91	; 145
    7b8c:	ff e0       	ldi	r31, 0x0F	; 15
    7b8e:	20 e0       	ldi	r18, 0x00	; 0
    7b90:	30 e0       	ldi	r19, 0x00	; 0

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time == 0)
    7b92:	80 81       	ld	r24, Z
    7b94:	88 23       	and	r24, r24
    7b96:	59 f5       	brne	.+86     	; 0x7bee <arpIpIn+0x1ae>
    {
// write entry
      ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    7b98:	8b e0       	ldi	r24, 0x0B	; 11
    7b9a:	90 e0       	ldi	r25, 0x00	; 0
    7b9c:	28 9f       	mul	r18, r24
    7b9e:	d0 01       	movw	r26, r0
    7ba0:	29 9f       	mul	r18, r25
    7ba2:	b0 0d       	add	r27, r0
    7ba4:	38 9f       	mul	r19, r24
    7ba6:	b0 0d       	add	r27, r0
    7ba8:	11 24       	eor	r1, r1
    7baa:	e0 91 9d 0e 	lds	r30, 0x0E9D
    7bae:	f0 91 9e 0e 	lds	r31, 0x0E9E
    7bb2:	a5 57       	subi	r26, 0x75	; 117
    7bb4:	b0 4f       	sbci	r27, 0xF0	; 240
    7bb6:	36 96       	adiw	r30, 0x06	; 6
    7bb8:	86 e0       	ldi	r24, 0x06	; 6
    7bba:	01 90       	ld	r0, Z+
    7bbc:	0d 92       	st	X+, r0
    7bbe:	81 50       	subi	r24, 0x01	; 1
    7bc0:	e1 f7       	brne	.-8      	; 0x7bba <arpIpIn+0x17a>
      ArpTable[index].ipaddr  = nicState.layer3.ip->srcipaddr;
    7bc2:	8b e0       	ldi	r24, 0x0B	; 11
    7bc4:	90 e0       	ldi	r25, 0x00	; 0
    7bc6:	28 9f       	mul	r18, r24
    7bc8:	f0 01       	movw	r30, r0
    7bca:	29 9f       	mul	r18, r25
    7bcc:	f0 0d       	add	r31, r0
    7bce:	38 9f       	mul	r19, r24
    7bd0:	f0 0d       	add	r31, r0
    7bd2:	11 24       	eor	r1, r1
    7bd4:	e9 57       	subi	r30, 0x79	; 121
    7bd6:	f0 4f       	sbci	r31, 0xF0	; 240
    7bd8:	8c 85       	ldd	r24, Y+12	; 0x0c
    7bda:	9d 85       	ldd	r25, Y+13	; 0x0d
    7bdc:	ae 85       	ldd	r26, Y+14	; 0x0e
    7bde:	bf 85       	ldd	r27, Y+15	; 0x0f
    7be0:	80 83       	st	Z, r24
    7be2:	91 83       	std	Z+1, r25	; 0x01
    7be4:	a2 83       	std	Z+2, r26	; 0x02
    7be6:	b3 83       	std	Z+3, r27	; 0x03
      ArpTable[index].time    = ARP_CACHE_TIME_TO_LIVE;
    7be8:	80 e8       	ldi	r24, 0x80	; 128
    7bea:	82 87       	std	Z+10, r24	; 0x0a
    7bec:	06 c0       	rjmp	.+12     	; 0x7bfa <arpIpIn+0x1ba>
// and we're done
      return;
    7bee:	2f 5f       	subi	r18, 0xFF	; 255
    7bf0:	3f 4f       	sbci	r19, 0xFF	; 255
    7bf2:	3b 96       	adiw	r30, 0x0b	; 11
    return;
  }

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
    7bf4:	2a 30       	cpi	r18, 0x0A	; 10
    7bf6:	31 05       	cpc	r19, r1
    7bf8:	61 f6       	brne	.-104    	; 0x7b92 <arpIpIn+0x152>
// and we're done
      return;
    }
  }
// no space in table, we give up
}
    7bfa:	df 91       	pop	r29
    7bfc:	cf 91       	pop	r28
    7bfe:	08 95       	ret

00007c00 <arpPrintHeader>:
  return -1;
}

#if ARP_DEBUG
void arpPrintHeader(FILE *stream, struct netArpHeader* packet)
{
    7c00:	ef 92       	push	r14
    7c02:	ff 92       	push	r15
    7c04:	0f 93       	push	r16
    7c06:	1f 93       	push	r17
    7c08:	cf 93       	push	r28
    7c0a:	df 93       	push	r29
    7c0c:	ec 01       	movw	r28, r24
    7c0e:	7b 01       	movw	r14, r22
  fprintf_P(stream, PSTR("ARP Packet:\r\n"));
    7c10:	00 d0       	rcall	.+0      	; 0x7c12 <arpPrintHeader+0x12>
    7c12:	00 d0       	rcall	.+0      	; 0x7c14 <arpPrintHeader+0x14>
    7c14:	ed b7       	in	r30, 0x3d	; 61
    7c16:	fe b7       	in	r31, 0x3e	; 62
    7c18:	92 83       	std	Z+2, r25	; 0x02
    7c1a:	81 83       	std	Z+1, r24	; 0x01
    7c1c:	8a e8       	ldi	r24, 0x8A	; 138
    7c1e:	90 e1       	ldi	r25, 0x10	; 16
    7c20:	94 83       	std	Z+4, r25	; 0x04
    7c22:	83 83       	std	Z+3, r24	; 0x03
    7c24:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  //debugPrintHexTable(60, (unsigned char*)&packet);
  // print operation type
  fprintf_P(stream, PSTR("Operation   : "));
    7c28:	ed b7       	in	r30, 0x3d	; 61
    7c2a:	fe b7       	in	r31, 0x3e	; 62
    7c2c:	d2 83       	std	Z+2, r29	; 0x02
    7c2e:	c1 83       	std	Z+1, r28	; 0x01
    7c30:	8b e7       	ldi	r24, 0x7B	; 123
    7c32:	90 e1       	ldi	r25, 0x10	; 16
    7c34:	94 83       	std	Z+4, r25	; 0x04
    7c36:	83 83       	std	Z+3, r24	; 0x03
    7c38:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  if(packet->opcode == htons(ARP_OPCODE_REQUEST))
    7c3c:	f7 01       	movw	r30, r14
    7c3e:	06 81       	ldd	r16, Z+6	; 0x06
    7c40:	17 81       	ldd	r17, Z+7	; 0x07
    7c42:	0f 90       	pop	r0
    7c44:	0f 90       	pop	r0
    7c46:	0f 90       	pop	r0
    7c48:	0f 90       	pop	r0
    7c4a:	81 e0       	ldi	r24, 0x01	; 1
    7c4c:	90 e0       	ldi	r25, 0x00	; 0
    7c4e:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    7c52:	08 17       	cp	r16, r24
    7c54:	19 07       	cpc	r17, r25
    7c56:	49 f4       	brne	.+18     	; 0x7c6a <arpPrintHeader+0x6a>
    fprintf_P(stream, PSTR("REQUEST"));
    7c58:	00 d0       	rcall	.+0      	; 0x7c5a <arpPrintHeader+0x5a>
    7c5a:	00 d0       	rcall	.+0      	; 0x7c5c <arpPrintHeader+0x5c>
    7c5c:	ed b7       	in	r30, 0x3d	; 61
    7c5e:	fe b7       	in	r31, 0x3e	; 62
    7c60:	d2 83       	std	Z+2, r29	; 0x02
    7c62:	c1 83       	std	Z+1, r28	; 0x01
    7c64:	83 e7       	ldi	r24, 0x73	; 115
    7c66:	90 e1       	ldi	r25, 0x10	; 16
    7c68:	1b c0       	rjmp	.+54     	; 0x7ca0 <arpPrintHeader+0xa0>
  else if(packet->opcode == htons(ARP_OPCODE_REPLY))
    7c6a:	f7 01       	movw	r30, r14
    7c6c:	06 81       	ldd	r16, Z+6	; 0x06
    7c6e:	17 81       	ldd	r17, Z+7	; 0x07
    7c70:	82 e0       	ldi	r24, 0x02	; 2
    7c72:	90 e0       	ldi	r25, 0x00	; 0
    7c74:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    7c78:	08 17       	cp	r16, r24
    7c7a:	19 07       	cpc	r17, r25
    7c7c:	49 f4       	brne	.+18     	; 0x7c90 <arpPrintHeader+0x90>
    fprintf_P(stream, PSTR("REPLY"));
    7c7e:	00 d0       	rcall	.+0      	; 0x7c80 <arpPrintHeader+0x80>
    7c80:	00 d0       	rcall	.+0      	; 0x7c82 <arpPrintHeader+0x82>
    7c82:	ed b7       	in	r30, 0x3d	; 61
    7c84:	fe b7       	in	r31, 0x3e	; 62
    7c86:	d2 83       	std	Z+2, r29	; 0x02
    7c88:	c1 83       	std	Z+1, r28	; 0x01
    7c8a:	8d e6       	ldi	r24, 0x6D	; 109
    7c8c:	90 e1       	ldi	r25, 0x10	; 16
    7c8e:	08 c0       	rjmp	.+16     	; 0x7ca0 <arpPrintHeader+0xa0>
  else
    fprintf_P(stream, PSTR("UNKNOWN"));
    7c90:	00 d0       	rcall	.+0      	; 0x7c92 <arpPrintHeader+0x92>
    7c92:	00 d0       	rcall	.+0      	; 0x7c94 <arpPrintHeader+0x94>
    7c94:	ed b7       	in	r30, 0x3d	; 61
    7c96:	fe b7       	in	r31, 0x3e	; 62
    7c98:	d2 83       	std	Z+2, r29	; 0x02
    7c9a:	c1 83       	std	Z+1, r28	; 0x01
    7c9c:	85 e6       	ldi	r24, 0x65	; 101
    7c9e:	90 e1       	ldi	r25, 0x10	; 16
    7ca0:	94 83       	std	Z+4, r25	; 0x04
    7ca2:	83 83       	std	Z+3, r24	; 0x03
    7ca4:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("\r\n"));
    7ca8:	ed b7       	in	r30, 0x3d	; 61
    7caa:	fe b7       	in	r31, 0x3e	; 62
    7cac:	d2 83       	std	Z+2, r29	; 0x02
    7cae:	c1 83       	std	Z+1, r28	; 0x01
    7cb0:	82 e6       	ldi	r24, 0x62	; 98
    7cb2:	90 e1       	ldi	r25, 0x10	; 16
    7cb4:	94 83       	std	Z+4, r25	; 0x04
    7cb6:	83 83       	std	Z+3, r24	; 0x03
    7cb8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print source hardware address
  fprintf_P(stream, PSTR("SrcHwAddr   : "));  netPrintEthAddr(stream, &packet->shwaddr);   fprintf_P(stream, PSTR("\r\n"));
    7cbc:	ed b7       	in	r30, 0x3d	; 61
    7cbe:	fe b7       	in	r31, 0x3e	; 62
    7cc0:	d2 83       	std	Z+2, r29	; 0x02
    7cc2:	c1 83       	std	Z+1, r28	; 0x01
    7cc4:	83 e5       	ldi	r24, 0x53	; 83
    7cc6:	90 e1       	ldi	r25, 0x10	; 16
    7cc8:	94 83       	std	Z+4, r25	; 0x04
    7cca:	83 83       	std	Z+3, r24	; 0x03
    7ccc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7cd0:	0f 90       	pop	r0
    7cd2:	0f 90       	pop	r0
    7cd4:	0f 90       	pop	r0
    7cd6:	0f 90       	pop	r0
    7cd8:	b7 01       	movw	r22, r14
    7cda:	68 5f       	subi	r22, 0xF8	; 248
    7cdc:	7f 4f       	sbci	r23, 0xFF	; 255
    7cde:	ce 01       	movw	r24, r28
    7ce0:	0e 94 a2 36 	call	0x6d44	; 0x6d44 <netPrintEthAddr>
    7ce4:	00 d0       	rcall	.+0      	; 0x7ce6 <arpPrintHeader+0xe6>
    7ce6:	00 d0       	rcall	.+0      	; 0x7ce8 <arpPrintHeader+0xe8>
    7ce8:	ed b7       	in	r30, 0x3d	; 61
    7cea:	fe b7       	in	r31, 0x3e	; 62
    7cec:	d2 83       	std	Z+2, r29	; 0x02
    7cee:	c1 83       	std	Z+1, r28	; 0x01
    7cf0:	80 e5       	ldi	r24, 0x50	; 80
    7cf2:	90 e1       	ldi	r25, 0x10	; 16
    7cf4:	94 83       	std	Z+4, r25	; 0x04
    7cf6:	83 83       	std	Z+3, r24	; 0x03
    7cf8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print source protocol address
  fprintf_P(stream, PSTR("SrcProtoAddr: "));  netPrintIPAddr(stream, packet->sipaddr);     fprintf_P(stream, PSTR("\r\n"));
    7cfc:	ed b7       	in	r30, 0x3d	; 61
    7cfe:	fe b7       	in	r31, 0x3e	; 62
    7d00:	d2 83       	std	Z+2, r29	; 0x02
    7d02:	c1 83       	std	Z+1, r28	; 0x01
    7d04:	81 e4       	ldi	r24, 0x41	; 65
    7d06:	90 e1       	ldi	r25, 0x10	; 16
    7d08:	94 83       	std	Z+4, r25	; 0x04
    7d0a:	83 83       	std	Z+3, r24	; 0x03
    7d0c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7d10:	0f 90       	pop	r0
    7d12:	0f 90       	pop	r0
    7d14:	0f 90       	pop	r0
    7d16:	0f 90       	pop	r0
    7d18:	f7 01       	movw	r30, r14
    7d1a:	46 85       	ldd	r20, Z+14	; 0x0e
    7d1c:	57 85       	ldd	r21, Z+15	; 0x0f
    7d1e:	60 89       	ldd	r22, Z+16	; 0x10
    7d20:	71 89       	ldd	r23, Z+17	; 0x11
    7d22:	ce 01       	movw	r24, r28
    7d24:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    7d28:	00 d0       	rcall	.+0      	; 0x7d2a <arpPrintHeader+0x12a>
    7d2a:	00 d0       	rcall	.+0      	; 0x7d2c <arpPrintHeader+0x12c>
    7d2c:	ed b7       	in	r30, 0x3d	; 61
    7d2e:	fe b7       	in	r31, 0x3e	; 62
    7d30:	d2 83       	std	Z+2, r29	; 0x02
    7d32:	c1 83       	std	Z+1, r28	; 0x01
    7d34:	8e e3       	ldi	r24, 0x3E	; 62
    7d36:	90 e1       	ldi	r25, 0x10	; 16
    7d38:	94 83       	std	Z+4, r25	; 0x04
    7d3a:	83 83       	std	Z+3, r24	; 0x03
    7d3c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print target hardware address
  fprintf_P(stream, PSTR("DstHwAddr   : "));  netPrintEthAddr(stream, &packet->dhwaddr);   fprintf_P(stream, PSTR("\r\n"));
    7d40:	ed b7       	in	r30, 0x3d	; 61
    7d42:	fe b7       	in	r31, 0x3e	; 62
    7d44:	d2 83       	std	Z+2, r29	; 0x02
    7d46:	c1 83       	std	Z+1, r28	; 0x01
    7d48:	8f e2       	ldi	r24, 0x2F	; 47
    7d4a:	90 e1       	ldi	r25, 0x10	; 16
    7d4c:	94 83       	std	Z+4, r25	; 0x04
    7d4e:	83 83       	std	Z+3, r24	; 0x03
    7d50:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7d54:	0f 90       	pop	r0
    7d56:	0f 90       	pop	r0
    7d58:	0f 90       	pop	r0
    7d5a:	0f 90       	pop	r0
    7d5c:	b7 01       	movw	r22, r14
    7d5e:	6e 5e       	subi	r22, 0xEE	; 238
    7d60:	7f 4f       	sbci	r23, 0xFF	; 255
    7d62:	ce 01       	movw	r24, r28
    7d64:	0e 94 a2 36 	call	0x6d44	; 0x6d44 <netPrintEthAddr>
    7d68:	00 d0       	rcall	.+0      	; 0x7d6a <arpPrintHeader+0x16a>
    7d6a:	00 d0       	rcall	.+0      	; 0x7d6c <arpPrintHeader+0x16c>
    7d6c:	ed b7       	in	r30, 0x3d	; 61
    7d6e:	fe b7       	in	r31, 0x3e	; 62
    7d70:	d2 83       	std	Z+2, r29	; 0x02
    7d72:	c1 83       	std	Z+1, r28	; 0x01
    7d74:	8c e2       	ldi	r24, 0x2C	; 44
    7d76:	90 e1       	ldi	r25, 0x10	; 16
    7d78:	94 83       	std	Z+4, r25	; 0x04
    7d7a:	83 83       	std	Z+3, r24	; 0x03
    7d7c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
// print target protocol address
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
    7d80:	ed b7       	in	r30, 0x3d	; 61
    7d82:	fe b7       	in	r31, 0x3e	; 62
    7d84:	d2 83       	std	Z+2, r29	; 0x02
    7d86:	c1 83       	std	Z+1, r28	; 0x01
    7d88:	8d e1       	ldi	r24, 0x1D	; 29
    7d8a:	90 e1       	ldi	r25, 0x10	; 16
    7d8c:	94 83       	std	Z+4, r25	; 0x04
    7d8e:	83 83       	std	Z+3, r24	; 0x03
    7d90:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7d94:	0f 90       	pop	r0
    7d96:	0f 90       	pop	r0
    7d98:	0f 90       	pop	r0
    7d9a:	0f 90       	pop	r0
    7d9c:	f7 01       	movw	r30, r14
    7d9e:	40 8d       	ldd	r20, Z+24	; 0x18
    7da0:	51 8d       	ldd	r21, Z+25	; 0x19
    7da2:	62 8d       	ldd	r22, Z+26	; 0x1a
    7da4:	73 8d       	ldd	r23, Z+27	; 0x1b
    7da6:	ce 01       	movw	r24, r28
    7da8:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
    7dac:	00 d0       	rcall	.+0      	; 0x7dae <arpPrintHeader+0x1ae>
    7dae:	00 d0       	rcall	.+0      	; 0x7db0 <arpPrintHeader+0x1b0>
    7db0:	ed b7       	in	r30, 0x3d	; 61
    7db2:	fe b7       	in	r31, 0x3e	; 62
    7db4:	d2 83       	std	Z+2, r29	; 0x02
    7db6:	c1 83       	std	Z+1, r28	; 0x01
    7db8:	8a e1       	ldi	r24, 0x1A	; 26
    7dba:	90 e1       	ldi	r25, 0x10	; 16
    7dbc:	94 83       	std	Z+4, r25	; 0x04
    7dbe:	83 83       	std	Z+3, r24	; 0x03
    7dc0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7dc4:	0f 90       	pop	r0
    7dc6:	0f 90       	pop	r0
    7dc8:	0f 90       	pop	r0
    7dca:	0f 90       	pop	r0
}
    7dcc:	df 91       	pop	r29
    7dce:	cf 91       	pop	r28
    7dd0:	1f 91       	pop	r17
    7dd2:	0f 91       	pop	r16
    7dd4:	ff 90       	pop	r15
    7dd6:	ef 90       	pop	r14
    7dd8:	08 95       	ret

00007dda <arpIpOut>:
  }
// no space in table, we give up
}

void arpIpOut(uint32_t phyDstIp)
{
    7dda:	cf 93       	push	r28
    7ddc:	df 93       	push	r29
    7dde:	ab 01       	movw	r20, r22
    7de0:	bc 01       	movw	r22, r24
  int index;
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    7de2:	41 15       	cp	r20, r1
    7de4:	51 05       	cpc	r21, r1
    7de6:	61 05       	cpc	r22, r1
    7de8:	71 05       	cpc	r23, r1
    7dea:	a9 f0       	breq	.+42     	; 0x7e16 <arpIpOut+0x3c>
    7dec:	e7 e8       	ldi	r30, 0x87	; 135
    7dee:	ff e0       	ldi	r31, 0x0F	; 15
    7df0:	20 e0       	ldi	r18, 0x00	; 0
    7df2:	30 e0       	ldi	r19, 0x00	; 0
    7df4:	e9 01       	movw	r28, r18
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    7df6:	80 81       	ld	r24, Z
    7df8:	91 81       	ldd	r25, Z+1	; 0x01
    7dfa:	a2 81       	ldd	r26, Z+2	; 0x02
    7dfc:	b3 81       	ldd	r27, Z+3	; 0x03
    7dfe:	84 17       	cp	r24, r20
    7e00:	95 07       	cpc	r25, r21
    7e02:	a6 07       	cpc	r26, r22
    7e04:	b7 07       	cpc	r27, r23
    7e06:	d1 f1       	breq	.+116    	; 0x7e7c <arpIpOut+0xa2>
    7e08:	2f 5f       	subi	r18, 0xFF	; 255
    7e0a:	3f 4f       	sbci	r19, 0xFF	; 255
    7e0c:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    7e0e:	2a 30       	cpi	r18, 0x0A	; 10
    7e10:	31 05       	cpc	r19, r1
    7e12:	81 f7       	brne	.-32     	; 0x7df4 <arpIpOut+0x1a>
    7e14:	1c c0       	rjmp	.+56     	; 0x7e4e <arpIpOut+0x74>
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    index = arpMatchIp(phyDstIp);
  else
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
    7e16:	e0 91 9f 0e 	lds	r30, 0x0E9F
    7e1a:	f0 91 a0 0e 	lds	r31, 0x0EA0
    7e1e:	40 89       	ldd	r20, Z+16	; 0x10
    7e20:	51 89       	ldd	r21, Z+17	; 0x11
    7e22:	62 89       	ldd	r22, Z+18	; 0x12
    7e24:	73 89       	ldd	r23, Z+19	; 0x13
    7e26:	e7 e8       	ldi	r30, 0x87	; 135
    7e28:	ff e0       	ldi	r31, 0x0F	; 15
    7e2a:	20 e0       	ldi	r18, 0x00	; 0
    7e2c:	30 e0       	ldi	r19, 0x00	; 0
    7e2e:	e9 01       	movw	r28, r18
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    7e30:	80 81       	ld	r24, Z
    7e32:	91 81       	ldd	r25, Z+1	; 0x01
    7e34:	a2 81       	ldd	r26, Z+2	; 0x02
    7e36:	b3 81       	ldd	r27, Z+3	; 0x03
    7e38:	84 17       	cp	r24, r20
    7e3a:	95 07       	cpc	r25, r21
    7e3c:	a6 07       	cpc	r26, r22
    7e3e:	b7 07       	cpc	r27, r23
    7e40:	e9 f0       	breq	.+58     	; 0x7e7c <arpIpOut+0xa2>
    7e42:	2f 5f       	subi	r18, 0xFF	; 255
    7e44:	3f 4f       	sbci	r19, 0xFF	; 255
    7e46:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    7e48:	2a 30       	cpi	r18, 0x0A	; 10
    7e4a:	31 05       	cpc	r19, r1
    7e4c:	81 f7       	brne	.-32     	; 0x7e2e <arpIpOut+0x54>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
  }
  else
  {
// not in table, must send ARP request
    nicState.layer2.ethHeader->src      = nicState.mac;
    7e4e:	e0 91 9d 0e 	lds	r30, 0x0E9D
    7e52:	f0 91 9e 0e 	lds	r31, 0x0E9E
    7e56:	36 96       	adiw	r30, 0x06	; 6
    7e58:	a7 e9       	ldi	r26, 0x97	; 151
    7e5a:	be e0       	ldi	r27, 0x0E	; 14
    7e5c:	86 e0       	ldi	r24, 0x06	; 6
    7e5e:	0d 90       	ld	r0, X+
    7e60:	01 92       	st	Z+, r0
    7e62:	81 50       	subi	r24, 0x01	; 1
    7e64:	e1 f7       	brne	.-8      	; 0x7e5e <arpIpOut+0x84>
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    7e66:	80 91 9d 0e 	lds	r24, 0x0E9D
    7e6a:	90 91 9e 0e 	lds	r25, 0x0E9E
    7e6e:	6f ef       	ldi	r22, 0xFF	; 255
    7e70:	70 e0       	ldi	r23, 0x00	; 0
    7e72:	46 e0       	ldi	r20, 0x06	; 6
    7e74:	50 e0       	ldi	r21, 0x00	; 0
    7e76:	0e 94 63 74 	call	0xe8c6	; 0xe8c6 <memset>
    7e7a:	22 c0       	rjmp	.+68     	; 0x7ec0 <arpIpOut+0xe6>
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
// fill in ethernet info
  if(index != -1)
  {
// ARP entry present, fill eth address(es)
    nicState.layer2.ethHeader->src      = nicState.mac;
    7e7c:	e0 91 9d 0e 	lds	r30, 0x0E9D
    7e80:	f0 91 9e 0e 	lds	r31, 0x0E9E
    7e84:	36 96       	adiw	r30, 0x06	; 6
    7e86:	a7 e9       	ldi	r26, 0x97	; 151
    7e88:	be e0       	ldi	r27, 0x0E	; 14
    7e8a:	86 e0       	ldi	r24, 0x06	; 6
    7e8c:	0d 90       	ld	r0, X+
    7e8e:	01 92       	st	Z+, r0
    7e90:	81 50       	subi	r24, 0x01	; 1
    7e92:	e1 f7       	brne	.-8      	; 0x7e8c <arpIpOut+0xb2>
    nicState.layer2.ethHeader->dest     = ArpTable[index].ethaddr;
    7e94:	8b e0       	ldi	r24, 0x0B	; 11
    7e96:	90 e0       	ldi	r25, 0x00	; 0
    7e98:	c8 9f       	mul	r28, r24
    7e9a:	f0 01       	movw	r30, r0
    7e9c:	c9 9f       	mul	r28, r25
    7e9e:	f0 0d       	add	r31, r0
    7ea0:	d8 9f       	mul	r29, r24
    7ea2:	f0 0d       	add	r31, r0
    7ea4:	11 24       	eor	r1, r1
    7ea6:	20 91 9d 0e 	lds	r18, 0x0E9D
    7eaa:	30 91 9e 0e 	lds	r19, 0x0E9E
    7eae:	c9 01       	movw	r24, r18
    7eb0:	dc 01       	movw	r26, r24
    7eb2:	e5 57       	subi	r30, 0x75	; 117
    7eb4:	f0 4f       	sbci	r31, 0xF0	; 240
    7eb6:	86 e0       	ldi	r24, 0x06	; 6
    7eb8:	01 90       	ld	r0, Z+
    7eba:	0d 92       	st	X+, r0
    7ebc:	81 50       	subi	r24, 0x01	; 1
    7ebe:	e1 f7       	brne	.-8      	; 0x7eb8 <arpIpOut+0xde>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
    7ec0:	e0 91 9d 0e 	lds	r30, 0x0E9D
    7ec4:	f0 91 9e 0e 	lds	r31, 0x0E9E
    7ec8:	88 e0       	ldi	r24, 0x08	; 8
    7eca:	90 e0       	ldi	r25, 0x00	; 0
    7ecc:	95 87       	std	Z+13, r25	; 0x0d
    7ece:	84 87       	std	Z+12, r24	; 0x0c
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}
    7ed0:	df 91       	pop	r29
    7ed2:	cf 91       	pop	r28
    7ed4:	08 95       	ret

00007ed6 <arpInit>:
#endif /*ARP_DEBUG*/

void arpInit()
{

  memset(ArpTable, 0, sizeof(ArpTable));
    7ed6:	8e e6       	ldi	r24, 0x6E	; 110
    7ed8:	e7 e8       	ldi	r30, 0x87	; 135
    7eda:	ff e0       	ldi	r31, 0x0F	; 15
    7edc:	df 01       	movw	r26, r30
    7ede:	1d 92       	st	X+, r1
    7ee0:	8a 95       	dec	r24
    7ee2:	e9 f7       	brne	.-6      	; 0x7ede <arpInit+0x8>
  arpDebug = NULL;
    7ee4:	10 92 a4 0e 	sts	0x0EA4, r1
    7ee8:	10 92 a3 0e 	sts	0x0EA3, r1
}
    7eec:	08 95       	ret

00007eee <arpArpIn>:

void arpArpIn(void)
{
    7eee:	0f 93       	push	r16
    7ef0:	1f 93       	push	r17
    7ef2:	cf 93       	push	r28
    7ef4:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    7ef6:	20 91 a3 0e 	lds	r18, 0x0EA3
    7efa:	30 91 a4 0e 	lds	r19, 0x0EA4
    7efe:	21 15       	cp	r18, r1
    7f00:	31 05       	cpc	r19, r1
    7f02:	11 f1       	breq	.+68     	; 0x7f48 <arpArpIn+0x5a>
  {
    if (arpDebugLevel > 1)
    7f04:	80 91 7c 0f 	lds	r24, 0x0F7C
    7f08:	82 30       	cpi	r24, 0x02	; 2
    7f0a:	80 f0       	brcs	.+32     	; 0x7f2c <arpArpIn+0x3e>
      fprintf_P(arpDebug, PSTR("Received ARP Request\r\n"));
    7f0c:	00 d0       	rcall	.+0      	; 0x7f0e <arpArpIn+0x20>
    7f0e:	00 d0       	rcall	.+0      	; 0x7f10 <arpArpIn+0x22>
    7f10:	ed b7       	in	r30, 0x3d	; 61
    7f12:	fe b7       	in	r31, 0x3e	; 62
    7f14:	32 83       	std	Z+2, r19	; 0x02
    7f16:	21 83       	std	Z+1, r18	; 0x01
    7f18:	85 ec       	ldi	r24, 0xC5	; 197
    7f1a:	90 e1       	ldi	r25, 0x10	; 16
    7f1c:	94 83       	std	Z+4, r25	; 0x04
    7f1e:	83 83       	std	Z+3, r24	; 0x03
    7f20:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    7f24:	0f 90       	pop	r0
    7f26:	0f 90       	pop	r0
    7f28:	0f 90       	pop	r0
    7f2a:	0f 90       	pop	r0
    if (arpDebugLevel > 2)
    7f2c:	80 91 7c 0f 	lds	r24, 0x0F7C
    7f30:	83 30       	cpi	r24, 0x03	; 3
    7f32:	50 f0       	brcs	.+20     	; 0x7f48 <arpArpIn+0x5a>
      arpPrintHeader(arpDebug, nicState.layer3.arp);   
    7f34:	60 91 9f 0e 	lds	r22, 0x0E9F
    7f38:	70 91 a0 0e 	lds	r23, 0x0EA0
    7f3c:	80 91 a3 0e 	lds	r24, 0x0EA3
    7f40:	90 91 a4 0e 	lds	r25, 0x0EA4
    7f44:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <arpPrintHeader>
  }
#endif

// for now, we just reply to requests
// need to add ARP cache
  if((nicState.layer3.arp->dipaddr == IpMyConfig.ip) && (nicState.layer3.arp->opcode == htons(ARP_OPCODE_REQUEST)) )
    7f48:	e0 91 9f 0e 	lds	r30, 0x0E9F
    7f4c:	f0 91 a0 0e 	lds	r31, 0x0EA0
    7f50:	20 8d       	ldd	r18, Z+24	; 0x18
    7f52:	31 8d       	ldd	r19, Z+25	; 0x19
    7f54:	42 8d       	ldd	r20, Z+26	; 0x1a
    7f56:	53 8d       	ldd	r21, Z+27	; 0x1b
    7f58:	80 91 6a 0f 	lds	r24, 0x0F6A
    7f5c:	90 91 6b 0f 	lds	r25, 0x0F6B
    7f60:	a0 91 6c 0f 	lds	r26, 0x0F6C
    7f64:	b0 91 6d 0f 	lds	r27, 0x0F6D
    7f68:	28 17       	cp	r18, r24
    7f6a:	39 07       	cpc	r19, r25
    7f6c:	4a 07       	cpc	r20, r26
    7f6e:	5b 07       	cpc	r21, r27
    7f70:	09 f0       	breq	.+2      	; 0x7f74 <arpArpIn+0x86>
    7f72:	84 c0       	rjmp	.+264    	; 0x807c <arpArpIn+0x18e>
    7f74:	06 81       	ldd	r16, Z+6	; 0x06
    7f76:	17 81       	ldd	r17, Z+7	; 0x07
    7f78:	81 e0       	ldi	r24, 0x01	; 1
    7f7a:	90 e0       	ldi	r25, 0x00	; 0
    7f7c:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    7f80:	08 17       	cp	r16, r24
    7f82:	19 07       	cpc	r17, r25
    7f84:	09 f0       	breq	.+2      	; 0x7f88 <arpArpIn+0x9a>
    7f86:	7a c0       	rjmp	.+244    	; 0x807c <arpArpIn+0x18e>
  {
// in ARP header
// copy sender's address info to dest. fields
    nicState.layer3.arp->dhwaddr = nicState.layer3.arp->shwaddr;
    7f88:	e0 91 9f 0e 	lds	r30, 0x0E9F
    7f8c:	f0 91 a0 0e 	lds	r31, 0x0EA0
    7f90:	ef 01       	movw	r28, r30
    7f92:	62 96       	adiw	r28, 0x12	; 18
    7f94:	df 01       	movw	r26, r30
    7f96:	18 96       	adiw	r26, 0x08	; 8
    7f98:	86 e0       	ldi	r24, 0x06	; 6
    7f9a:	0d 90       	ld	r0, X+
    7f9c:	09 92       	st	Y+, r0
    7f9e:	81 50       	subi	r24, 0x01	; 1
    7fa0:	e1 f7       	brne	.-8      	; 0x7f9a <arpArpIn+0xac>
    nicState.layer3.arp->dipaddr = nicState.layer3.arp->sipaddr;
    7fa2:	86 85       	ldd	r24, Z+14	; 0x0e
    7fa4:	97 85       	ldd	r25, Z+15	; 0x0f
    7fa6:	a0 89       	ldd	r26, Z+16	; 0x10
    7fa8:	b1 89       	ldd	r27, Z+17	; 0x11
    7faa:	80 8f       	std	Z+24, r24	; 0x18
    7fac:	91 8f       	std	Z+25, r25	; 0x19
    7fae:	a2 8f       	std	Z+26, r26	; 0x1a
    7fb0:	b3 8f       	std	Z+27, r27	; 0x1b
// fill in our information
    nicState.layer3.arp->shwaddr =  nicState.mac;
    7fb2:	df 01       	movw	r26, r30
    7fb4:	18 96       	adiw	r26, 0x08	; 8
    7fb6:	e7 e9       	ldi	r30, 0x97	; 151
    7fb8:	fe e0       	ldi	r31, 0x0E	; 14
    7fba:	86 e0       	ldi	r24, 0x06	; 6
    7fbc:	01 90       	ld	r0, Z+
    7fbe:	0d 92       	st	X+, r0
    7fc0:	81 50       	subi	r24, 0x01	; 1
    7fc2:	e1 f7       	brne	.-8      	; 0x7fbc <arpArpIn+0xce>
    nicState.layer3.arp->sipaddr =  IpMyConfig.ip;
    7fc4:	00 91 9f 0e 	lds	r16, 0x0E9F
    7fc8:	10 91 a0 0e 	lds	r17, 0x0EA0
    7fcc:	80 91 6a 0f 	lds	r24, 0x0F6A
    7fd0:	90 91 6b 0f 	lds	r25, 0x0F6B
    7fd4:	a0 91 6c 0f 	lds	r26, 0x0F6C
    7fd8:	b0 91 6d 0f 	lds	r27, 0x0F6D
    7fdc:	f8 01       	movw	r30, r16
    7fde:	86 87       	std	Z+14, r24	; 0x0e
    7fe0:	97 87       	std	Z+15, r25	; 0x0f
    7fe2:	a0 8b       	std	Z+16, r26	; 0x10
    7fe4:	b1 8b       	std	Z+17, r27	; 0x11
// change op to reply
    nicState.layer3.arp->opcode = htons(ARP_OPCODE_REPLY);
    7fe6:	82 e0       	ldi	r24, 0x02	; 2
    7fe8:	90 e0       	ldi	r25, 0x00	; 0
    7fea:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    7fee:	f8 01       	movw	r30, r16
    7ff0:	97 83       	std	Z+7, r25	; 0x07
    7ff2:	86 83       	std	Z+6, r24	; 0x06

// in ethernet header
    nicState.layer2.ethHeader->dest = nicState.layer2.ethHeader->src;
    7ff4:	e0 91 9d 0e 	lds	r30, 0x0E9D
    7ff8:	f0 91 9e 0e 	lds	r31, 0x0E9E
    7ffc:	df 01       	movw	r26, r30
    7ffe:	16 96       	adiw	r26, 0x06	; 6
    8000:	86 e0       	ldi	r24, 0x06	; 6
    8002:	0d 90       	ld	r0, X+
    8004:	01 92       	st	Z+, r0
    8006:	81 50       	subi	r24, 0x01	; 1
    8008:	e1 f7       	brne	.-8      	; 0x8002 <arpArpIn+0x114>
    nicState.layer2.ethHeader->src  = nicState.mac;
    800a:	e0 91 9d 0e 	lds	r30, 0x0E9D
    800e:	f0 91 9e 0e 	lds	r31, 0x0E9E
    8012:	36 96       	adiw	r30, 0x06	; 6
    8014:	a7 e9       	ldi	r26, 0x97	; 151
    8016:	be e0       	ldi	r27, 0x0E	; 14
    8018:	86 e0       	ldi	r24, 0x06	; 6
    801a:	0d 90       	ld	r0, X+
    801c:	01 92       	st	Z+, r0
    801e:	81 50       	subi	r24, 0x01	; 1
    8020:	e1 f7       	brne	.-8      	; 0x801a <arpArpIn+0x12c>

#ifdef ARP_DEBUG
    if (arpDebug != NULL)
    8022:	20 91 a3 0e 	lds	r18, 0x0EA3
    8026:	30 91 a4 0e 	lds	r19, 0x0EA4
    802a:	21 15       	cp	r18, r1
    802c:	31 05       	cpc	r19, r1
    802e:	11 f1       	breq	.+68     	; 0x8074 <arpArpIn+0x186>
    {
      if (arpDebugLevel > 0)
    8030:	80 91 7c 0f 	lds	r24, 0x0F7C
    8034:	88 23       	and	r24, r24
    8036:	81 f0       	breq	.+32     	; 0x8058 <arpArpIn+0x16a>
        fprintf_P(arpDebug, PSTR("Sending ARP Reply\r\n"));
    8038:	00 d0       	rcall	.+0      	; 0x803a <arpArpIn+0x14c>
    803a:	00 d0       	rcall	.+0      	; 0x803c <arpArpIn+0x14e>
    803c:	ed b7       	in	r30, 0x3d	; 61
    803e:	fe b7       	in	r31, 0x3e	; 62
    8040:	32 83       	std	Z+2, r19	; 0x02
    8042:	21 83       	std	Z+1, r18	; 0x01
    8044:	81 eb       	ldi	r24, 0xB1	; 177
    8046:	90 e1       	ldi	r25, 0x10	; 16
    8048:	94 83       	std	Z+4, r25	; 0x04
    804a:	83 83       	std	Z+3, r24	; 0x03
    804c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8050:	0f 90       	pop	r0
    8052:	0f 90       	pop	r0
    8054:	0f 90       	pop	r0
    8056:	0f 90       	pop	r0
      if (arpDebugLevel > 2)
    8058:	80 91 7c 0f 	lds	r24, 0x0F7C
    805c:	83 30       	cpi	r24, 0x03	; 3
    805e:	50 f0       	brcs	.+20     	; 0x8074 <arpArpIn+0x186>
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    8060:	60 91 9f 0e 	lds	r22, 0x0E9F
    8064:	70 91 a0 0e 	lds	r23, 0x0EA0
    8068:	80 91 a3 0e 	lds	r24, 0x0EA3
    806c:	90 91 a4 0e 	lds	r25, 0x0EA4
    8070:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <arpPrintHeader>
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    8074:	8a e2       	ldi	r24, 0x2A	; 42
    8076:	90 e0       	ldi	r25, 0x00	; 0
    8078:	0e 94 de 31 	call	0x63bc	; 0x63bc <nicSend>
  }
}
    807c:	df 91       	pop	r29
    807e:	cf 91       	pop	r28
    8080:	1f 91       	pop	r17
    8082:	0f 91       	pop	r16
    8084:	08 95       	ret

00008086 <sendTcBuffer>:

uint8_t sendTcBuffer(uint8_t socketNo)
{
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    8086:	80 e0       	ldi	r24, 0x00	; 0
    8088:	08 95       	ret

0000808a <setTcpDebug>:
}

#if TCP_DEBUG
void setTcpDebug(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    808a:	90 93 68 0f 	sts	0x0F68, r25
    808e:	80 93 67 0f 	sts	0x0F67, r24
  tcpDebugLevel = level;
    8092:	60 93 bc 0e 	sts	0x0EBC, r22
}
    8096:	08 95       	ret

00008098 <flushTcpQueues>:
  for (sckNo = 0; sckNo < NUMBER_OF_SOCKETS; sckNo++)
  {
    
    sck++;
  }
}
    8098:	08 95       	ret

0000809a <httpProcess>:
          continue;  
        }
      }

#endif
    809a:	08 95       	ret

0000809c <calculateTcpChecksun>:
  
  return 0;
}

void calculateTcpChecksun(uint16_t tcpLen)
{
    809c:	0f 93       	push	r16
    809e:	1f 93       	push	r17
    80a0:	bc 01       	movw	r22, r24
  nicState.layer4.tcp->tcpchksum = 0;
    80a2:	00 91 a1 0e 	lds	r16, 0x0EA1
    80a6:	10 91 a2 0e 	lds	r17, 0x0EA2
    80aa:	f8 01       	movw	r30, r16
    80ac:	11 8a       	std	Z+17, r1	; 0x11
    80ae:	10 8a       	std	Z+16, r1	; 0x10
  nicState.layer4.tcp->tcpchksum = netChecksum(nicState.layer4.tcp, tcpLen); //TODO finish it
    80b0:	c8 01       	movw	r24, r16
    80b2:	0e 94 c8 33 	call	0x6790	; 0x6790 <netChecksum>
    80b6:	f8 01       	movw	r30, r16
    80b8:	91 8b       	std	Z+17, r25	; 0x11
    80ba:	80 8b       	std	Z+16, r24	; 0x10
}
    80bc:	1f 91       	pop	r17
    80be:	0f 91       	pop	r16
    80c0:	08 95       	ret

000080c2 <processTcpPacket>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket(void)
{
    80c2:	af 92       	push	r10
    80c4:	bf 92       	push	r11
    80c6:	cf 92       	push	r12
    80c8:	df 92       	push	r13
    80ca:	ef 92       	push	r14
    80cc:	ff 92       	push	r15
    80ce:	0f 93       	push	r16
    80d0:	1f 93       	push	r17
    80d2:	cf 93       	push	r28
    80d4:	df 93       	push	r29
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    80d6:	e0 91 d5 0e 	lds	r30, 0x0ED5
    80da:	f0 91 d6 0e 	lds	r31, 0x0ED6
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
    80de:	e0 90 9f 0e 	lds	r14, 0x0E9F
    80e2:	f0 90 a0 0e 	lds	r15, 0x0EA0
    80e6:	60 91 a1 0e 	lds	r22, 0x0EA1
    80ea:	70 91 a2 0e 	lds	r23, 0x0EA2
    80ee:	ef 01       	movw	r28, r30
    80f0:	00 e0       	ldi	r16, 0x00	; 0
    80f2:	18 81       	ld	r17, Y
    80f4:	12 30       	cpi	r17, 0x02	; 2
    80f6:	08 f4       	brcc	.+2      	; 0x80fa <processTcpPacket+0x38>
    80f8:	4b c0       	rjmp	.+150    	; 0x8190 <processTcpPacket+0xce>
    80fa:	29 81       	ldd	r18, Y+1	; 0x01
    80fc:	3a 81       	ldd	r19, Y+2	; 0x02
    80fe:	4b 81       	ldd	r20, Y+3	; 0x03
    8100:	5c 81       	ldd	r21, Y+4	; 0x04
    8102:	d7 01       	movw	r26, r14
    8104:	1c 96       	adiw	r26, 0x0c	; 12
    8106:	ad 90       	ld	r10, X+
    8108:	bd 90       	ld	r11, X+
    810a:	cd 90       	ld	r12, X+
    810c:	dc 90       	ld	r13, X
    810e:	1f 97       	sbiw	r26, 0x0f	; 15
    8110:	2a 15       	cp	r18, r10
    8112:	3b 05       	cpc	r19, r11
    8114:	4c 05       	cpc	r20, r12
    8116:	5d 05       	cpc	r21, r13
    8118:	d9 f5       	brne	.+118    	; 0x8190 <processTcpPacket+0xce>
    811a:	2d 81       	ldd	r18, Y+5	; 0x05
    811c:	3e 81       	ldd	r19, Y+6	; 0x06
    811e:	db 01       	movw	r26, r22
    8120:	12 96       	adiw	r26, 0x02	; 2
    8122:	8d 91       	ld	r24, X+
    8124:	9c 91       	ld	r25, X
    8126:	13 97       	sbiw	r26, 0x03	; 3
    8128:	28 17       	cp	r18, r24
    812a:	39 07       	cpc	r19, r25
    812c:	89 f5       	brne	.+98     	; 0x8190 <processTcpPacket+0xce>
    812e:	2f 81       	ldd	r18, Y+7	; 0x07
    8130:	38 85       	ldd	r19, Y+8	; 0x08
    8132:	8d 91       	ld	r24, X+
    8134:	9c 91       	ld	r25, X
    8136:	28 17       	cp	r18, r24
    8138:	39 07       	cpc	r19, r25
    813a:	51 f5       	brne	.+84     	; 0x8190 <processTcpPacket+0xce>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    813c:	20 91 67 0f 	lds	r18, 0x0F67
    8140:	30 91 68 0f 	lds	r19, 0x0F68
    8144:	21 15       	cp	r18, r1
    8146:	31 05       	cpc	r19, r1
    8148:	09 f4       	brne	.+2      	; 0x814c <processTcpPacket+0x8a>
    814a:	9d c0       	rjmp	.+314    	; 0x8286 <processTcpPacket+0x1c4>
        if (tcpDebugLevel > 2)
    814c:	80 91 bc 0e 	lds	r24, 0x0EBC
    8150:	83 30       	cpi	r24, 0x03	; 3
    8152:	08 f4       	brcc	.+2      	; 0x8156 <processTcpPacket+0x94>
    8154:	98 c0       	rjmp	.+304    	; 0x8286 <processTcpPacket+0x1c4>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    8156:	00 d0       	rcall	.+0      	; 0x8158 <processTcpPacket+0x96>
    8158:	00 d0       	rcall	.+0      	; 0x815a <processTcpPacket+0x98>
    815a:	00 d0       	rcall	.+0      	; 0x815c <processTcpPacket+0x9a>
    815c:	ed b7       	in	r30, 0x3d	; 61
    815e:	fe b7       	in	r31, 0x3e	; 62
    8160:	31 96       	adiw	r30, 0x01	; 1
    8162:	ad b7       	in	r26, 0x3d	; 61
    8164:	be b7       	in	r27, 0x3e	; 62
    8166:	12 96       	adiw	r26, 0x02	; 2
    8168:	3c 93       	st	X, r19
    816a:	2e 93       	st	-X, r18
    816c:	11 97       	sbiw	r26, 0x01	; 1
    816e:	85 e3       	ldi	r24, 0x35	; 53
    8170:	92 e1       	ldi	r25, 0x12	; 18
    8172:	93 83       	std	Z+3, r25	; 0x03
    8174:	82 83       	std	Z+2, r24	; 0x02
    8176:	14 83       	std	Z+4, r17	; 0x04
    8178:	15 82       	std	Z+5, r1	; 0x05
    817a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    817e:	ed b7       	in	r30, 0x3d	; 61
    8180:	fe b7       	in	r31, 0x3e	; 62
    8182:	36 96       	adiw	r30, 0x06	; 6
    8184:	0f b6       	in	r0, 0x3f	; 63
    8186:	f8 94       	cli
    8188:	fe bf       	out	0x3e, r31	; 62
    818a:	0f be       	out	0x3f, r0	; 63
    818c:	ed bf       	out	0x3d, r30	; 61
    818e:	7b c0       	rjmp	.+246    	; 0x8286 <processTcpPacket+0x1c4>

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    8190:	0f 5f       	subi	r16, 0xFF	; 255
    8192:	04 31       	cpi	r16, 0x14	; 20
    8194:	11 f0       	breq	.+4      	; 0x819a <processTcpPacket+0xd8>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
#endif      
      return result;
    }
    result++;
    8196:	6c 96       	adiw	r28, 0x1c	; 28
    8198:	ac cf       	rjmp	.-168    	; 0x80f2 <processTcpPacket+0x30>
    819a:	00 e0       	ldi	r16, 0x00	; 0
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    819c:	80 81       	ld	r24, Z
    819e:	81 30       	cpi	r24, 0x01	; 1
    81a0:	e1 f5       	brne	.+120    	; 0x821a <processTcpPacket+0x158>
    81a2:	25 81       	ldd	r18, Z+5	; 0x05
    81a4:	36 81       	ldd	r19, Z+6	; 0x06
    81a6:	db 01       	movw	r26, r22
    81a8:	12 96       	adiw	r26, 0x02	; 2
    81aa:	8d 91       	ld	r24, X+
    81ac:	9c 91       	ld	r25, X
    81ae:	13 97       	sbiw	r26, 0x03	; 3
    81b0:	28 17       	cp	r18, r24
    81b2:	39 07       	cpc	r19, r25
    81b4:	91 f5       	brne	.+100    	; 0x821a <processTcpPacket+0x158>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    81b6:	20 91 67 0f 	lds	r18, 0x0F67
    81ba:	30 91 68 0f 	lds	r19, 0x0F68
    81be:	21 15       	cp	r18, r1
    81c0:	31 05       	cpc	r19, r1
    81c2:	01 f1       	breq	.+64     	; 0x8204 <processTcpPacket+0x142>
        if (tcpDebugLevel > 2)
    81c4:	80 91 bc 0e 	lds	r24, 0x0EBC
    81c8:	83 30       	cpi	r24, 0x03	; 3
    81ca:	e0 f0       	brcs	.+56     	; 0x8204 <processTcpPacket+0x142>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    81cc:	00 d0       	rcall	.+0      	; 0x81ce <processTcpPacket+0x10c>
    81ce:	00 d0       	rcall	.+0      	; 0x81d0 <processTcpPacket+0x10e>
    81d0:	00 d0       	rcall	.+0      	; 0x81d2 <processTcpPacket+0x110>
    81d2:	ed b7       	in	r30, 0x3d	; 61
    81d4:	fe b7       	in	r31, 0x3e	; 62
    81d6:	31 96       	adiw	r30, 0x01	; 1
    81d8:	ad b7       	in	r26, 0x3d	; 61
    81da:	be b7       	in	r27, 0x3e	; 62
    81dc:	12 96       	adiw	r26, 0x02	; 2
    81de:	3c 93       	st	X, r19
    81e0:	2e 93       	st	-X, r18
    81e2:	11 97       	sbiw	r26, 0x01	; 1
    81e4:	8f e0       	ldi	r24, 0x0F	; 15
    81e6:	92 e1       	ldi	r25, 0x12	; 18
    81e8:	93 83       	std	Z+3, r25	; 0x03
    81ea:	82 83       	std	Z+2, r24	; 0x02
    81ec:	04 83       	std	Z+4, r16	; 0x04
    81ee:	15 82       	std	Z+5, r1	; 0x05
    81f0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    81f4:	ed b7       	in	r30, 0x3d	; 61
    81f6:	fe b7       	in	r31, 0x3e	; 62
    81f8:	36 96       	adiw	r30, 0x06	; 6
    81fa:	0f b6       	in	r0, 0x3f	; 63
    81fc:	f8 94       	cli
    81fe:	fe bf       	out	0x3e, r31	; 62
    8200:	0f be       	out	0x3f, r0	; 63
    8202:	ed bf       	out	0x3d, r30	; 61
#endif      
      return &sockets[i];
    8204:	8c e1       	ldi	r24, 0x1C	; 28
    8206:	08 9f       	mul	r16, r24
    8208:	c0 01       	movw	r24, r0
    820a:	11 24       	eor	r1, r1
    820c:	c0 91 d5 0e 	lds	r28, 0x0ED5
    8210:	d0 91 d6 0e 	lds	r29, 0x0ED6
    8214:	c8 0f       	add	r28, r24
    8216:	d9 1f       	adc	r29, r25
    8218:	36 c0       	rjmp	.+108    	; 0x8286 <processTcpPacket+0x1c4>
    }
    result++;
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    821a:	0f 5f       	subi	r16, 0xFF	; 255
    821c:	04 31       	cpi	r16, 0x14	; 20
    821e:	11 f0       	breq	.+4      	; 0x8224 <processTcpPacket+0x162>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
#endif      
      return &sockets[i];
    }
    result++;
    8220:	7c 96       	adiw	r30, 0x1c	; 28
    8222:	bc cf       	rjmp	.-136    	; 0x819c <processTcpPacket+0xda>
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    8224:	c0 91 67 0f 	lds	r28, 0x0F67
    8228:	d0 91 68 0f 	lds	r29, 0x0F68
    822c:	20 97       	sbiw	r28, 0x00	; 0
    822e:	09 f4       	brne	.+2      	; 0x8232 <processTcpPacket+0x170>
    8230:	64 c1       	rjmp	.+712    	; 0x84fa <processTcpPacket+0x438>
    if (tcpDebugLevel > 2)
    8232:	80 91 bc 0e 	lds	r24, 0x0EBC
    8236:	83 30       	cpi	r24, 0x03	; 3
    8238:	08 f4       	brcc	.+2      	; 0x823c <processTcpPacket+0x17a>
    823a:	5f c1       	rjmp	.+702    	; 0x84fa <processTcpPacket+0x438>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    823c:	db 01       	movw	r26, r22
    823e:	12 96       	adiw	r26, 0x02	; 2
    8240:	8d 91       	ld	r24, X+
    8242:	9c 91       	ld	r25, X
    8244:	13 97       	sbiw	r26, 0x03	; 3
    8246:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    824a:	00 d0       	rcall	.+0      	; 0x824c <processTcpPacket+0x18a>
    824c:	00 d0       	rcall	.+0      	; 0x824e <processTcpPacket+0x18c>
    824e:	00 d0       	rcall	.+0      	; 0x8250 <processTcpPacket+0x18e>
    8250:	ed b7       	in	r30, 0x3d	; 61
    8252:	fe b7       	in	r31, 0x3e	; 62
    8254:	31 96       	adiw	r30, 0x01	; 1
    8256:	ad b7       	in	r26, 0x3d	; 61
    8258:	be b7       	in	r27, 0x3e	; 62
    825a:	12 96       	adiw	r26, 0x02	; 2
    825c:	dc 93       	st	X, r29
    825e:	ce 93       	st	-X, r28
    8260:	11 97       	sbiw	r26, 0x01	; 1
    8262:	25 ee       	ldi	r18, 0xE5	; 229
    8264:	31 e1       	ldi	r19, 0x11	; 17
    8266:	33 83       	std	Z+3, r19	; 0x03
    8268:	22 83       	std	Z+2, r18	; 0x02
    826a:	95 83       	std	Z+5, r25	; 0x05
    826c:	84 83       	std	Z+4, r24	; 0x04
    826e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8272:	81 e0       	ldi	r24, 0x01	; 1
    8274:	ed b7       	in	r30, 0x3d	; 61
    8276:	fe b7       	in	r31, 0x3e	; 62
    8278:	36 96       	adiw	r30, 0x06	; 6
    827a:	0f b6       	in	r0, 0x3f	; 63
    827c:	f8 94       	cli
    827e:	fe bf       	out	0x3e, r31	; 62
    8280:	0f be       	out	0x3f, r0	; 63
    8282:	ed bf       	out	0x3d, r30	; 61
    8284:	3d c1       	rjmp	.+634    	; 0x8500 <processTcpPacket+0x43e>

inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();
  
  if (socket == NULL)
    8286:	20 97       	sbiw	r28, 0x00	; 0
    8288:	09 f4       	brne	.+2      	; 0x828c <processTcpPacket+0x1ca>
    828a:	37 c1       	rjmp	.+622    	; 0x84fa <processTcpPacket+0x438>
    return 1;
  
  
  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    828c:	e0 91 a1 0e 	lds	r30, 0x0EA1
    8290:	f0 91 a2 0e 	lds	r31, 0x0EA2
    8294:	64 81       	ldd	r22, Z+4	; 0x04
    8296:	75 81       	ldd	r23, Z+5	; 0x05
    8298:	86 81       	ldd	r24, Z+6	; 0x06
    829a:	97 81       	ldd	r25, Z+7	; 0x07
    829c:	0e 94 ab 33 	call	0x6756	; 0x6756 <htonl>
    82a0:	69 87       	std	Y+9, r22	; 0x09
    82a2:	7a 87       	std	Y+10, r23	; 0x0a
    82a4:	8b 87       	std	Y+11, r24	; 0x0b
    82a6:	9c 87       	std	Y+12, r25	; 0x0c
  
  if (socket->state == LISTEN)
    82a8:	88 81       	ld	r24, Y
    82aa:	81 30       	cpi	r24, 0x01	; 1
    82ac:	09 f0       	breq	.+2      	; 0x82b0 <processTcpPacket+0x1ee>
    82ae:	b5 c0       	rjmp	.+362    	; 0x841a <processTcpPacket+0x358>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    82b0:	e0 91 a1 0e 	lds	r30, 0x0EA1
    82b4:	f0 91 a2 0e 	lds	r31, 0x0EA2
    82b8:	85 85       	ldd	r24, Z+13	; 0x0d
    82ba:	20 91 67 0f 	lds	r18, 0x0F67
    82be:	30 91 68 0f 	lds	r19, 0x0F68
    82c2:	81 ff       	sbrs	r24, 1
    82c4:	96 c0       	rjmp	.+300    	; 0x83f2 <processTcpPacket+0x330>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    82c6:	21 15       	cp	r18, r1
    82c8:	31 05       	cpc	r19, r1
    82ca:	c1 f0       	breq	.+48     	; 0x82fc <processTcpPacket+0x23a>
        if (tcpDebugLevel > 2)
    82cc:	80 91 bc 0e 	lds	r24, 0x0EBC
    82d0:	83 30       	cpi	r24, 0x03	; 3
    82d2:	a0 f0       	brcs	.+40     	; 0x82fc <processTcpPacket+0x23a>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    82d4:	00 d0       	rcall	.+0      	; 0x82d6 <processTcpPacket+0x214>
    82d6:	00 d0       	rcall	.+0      	; 0x82d8 <processTcpPacket+0x216>
    82d8:	ad b7       	in	r26, 0x3d	; 61
    82da:	be b7       	in	r27, 0x3e	; 62
    82dc:	12 96       	adiw	r26, 0x02	; 2
    82de:	3c 93       	st	X, r19
    82e0:	2e 93       	st	-X, r18
    82e2:	11 97       	sbiw	r26, 0x01	; 1
    82e4:	83 ea       	ldi	r24, 0xA3	; 163
    82e6:	91 e1       	ldi	r25, 0x11	; 17
    82e8:	14 96       	adiw	r26, 0x04	; 4
    82ea:	9c 93       	st	X, r25
    82ec:	8e 93       	st	-X, r24
    82ee:	13 97       	sbiw	r26, 0x03	; 3
    82f0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    82f4:	0f 90       	pop	r0
    82f6:	0f 90       	pop	r0
    82f8:	0f 90       	pop	r0
    82fa:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    82fc:	82 e0       	ldi	r24, 0x02	; 2
    82fe:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    8300:	e0 91 a1 0e 	lds	r30, 0x0EA1
    8304:	f0 91 a2 0e 	lds	r31, 0x0EA2
    8308:	80 81       	ld	r24, Z
    830a:	91 81       	ldd	r25, Z+1	; 0x01
    830c:	98 87       	std	Y+8, r25	; 0x08
    830e:	8f 83       	std	Y+7, r24	; 0x07
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    8310:	e0 91 9f 0e 	lds	r30, 0x0E9F
    8314:	f0 91 a0 0e 	lds	r31, 0x0EA0
    8318:	84 85       	ldd	r24, Z+12	; 0x0c
    831a:	95 85       	ldd	r25, Z+13	; 0x0d
    831c:	a6 85       	ldd	r26, Z+14	; 0x0e
    831e:	b7 85       	ldd	r27, Z+15	; 0x0f
    8320:	89 83       	std	Y+1, r24	; 0x01
    8322:	9a 83       	std	Y+2, r25	; 0x02
    8324:	ab 83       	std	Y+3, r26	; 0x03
    8326:	bc 83       	std	Y+4, r27	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    8328:	e0 91 a1 0e 	lds	r30, 0x0EA1
    832c:	f0 91 a2 0e 	lds	r31, 0x0EA2
    8330:	8d 81       	ldd	r24, Y+5	; 0x05
    8332:	9e 81       	ldd	r25, Y+6	; 0x06
    8334:	91 83       	std	Z+1, r25	; 0x01
    8336:	80 83       	st	Z, r24
      nicState.layer4.tcp->destport  = socket->remotePort;
    8338:	00 91 a1 0e 	lds	r16, 0x0EA1
    833c:	10 91 a2 0e 	lds	r17, 0x0EA2
    8340:	8f 81       	ldd	r24, Y+7	; 0x07
    8342:	98 85       	ldd	r25, Y+8	; 0x08
    8344:	f8 01       	movw	r30, r16
    8346:	93 83       	std	Z+3, r25	; 0x03
    8348:	82 83       	std	Z+2, r24	; 0x02
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    834a:	6d 85       	ldd	r22, Y+13	; 0x0d
    834c:	7e 85       	ldd	r23, Y+14	; 0x0e
    834e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8350:	98 89       	ldd	r25, Y+16	; 0x10
    8352:	0e 94 ab 33 	call	0x6756	; 0x6756 <htonl>
    8356:	d8 01       	movw	r26, r16
    8358:	14 96       	adiw	r26, 0x04	; 4
    835a:	6d 93       	st	X+, r22
    835c:	7d 93       	st	X+, r23
    835e:	8d 93       	st	X+, r24
    8360:	9c 93       	st	X, r25
    8362:	17 97       	sbiw	r26, 0x07	; 7
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    8364:	00 91 a1 0e 	lds	r16, 0x0EA1
    8368:	10 91 a2 0e 	lds	r17, 0x0EA2
    836c:	69 85       	ldd	r22, Y+9	; 0x09
    836e:	7a 85       	ldd	r23, Y+10	; 0x0a
    8370:	8b 85       	ldd	r24, Y+11	; 0x0b
    8372:	9c 85       	ldd	r25, Y+12	; 0x0c
    8374:	6f 5f       	subi	r22, 0xFF	; 255
    8376:	7f 4f       	sbci	r23, 0xFF	; 255
    8378:	8f 4f       	sbci	r24, 0xFF	; 255
    837a:	9f 4f       	sbci	r25, 0xFF	; 255
    837c:	0e 94 ab 33 	call	0x6756	; 0x6756 <htonl>
    8380:	f8 01       	movw	r30, r16
    8382:	60 87       	std	Z+8, r22	; 0x08
    8384:	71 87       	std	Z+9, r23	; 0x09
    8386:	82 87       	std	Z+10, r24	; 0x0a
    8388:	93 87       	std	Z+11, r25	; 0x0b
      nicState.layer4.tcp->tcpoffset = 5<<4;
    838a:	00 91 a1 0e 	lds	r16, 0x0EA1
    838e:	10 91 a2 0e 	lds	r17, 0x0EA2
    8392:	80 e5       	ldi	r24, 0x50	; 80
    8394:	d8 01       	movw	r26, r16
    8396:	1c 96       	adiw	r26, 0x0c	; 12
    8398:	8c 93       	st	X, r24
    839a:	1c 97       	sbiw	r26, 0x0c	; 12
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    839c:	82 e1       	ldi	r24, 0x12	; 18
    839e:	1d 96       	adiw	r26, 0x0d	; 13
    83a0:	8c 93       	st	X, r24
      nicState.layer4.tcp->wnd       = htons(100);
    83a2:	84 e6       	ldi	r24, 0x64	; 100
    83a4:	90 e0       	ldi	r25, 0x00	; 0
    83a6:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    83aa:	f8 01       	movw	r30, r16
    83ac:	97 87       	std	Z+15, r25	; 0x0f
    83ae:	86 87       	std	Z+14, r24	; 0x0e
      nicState.layer4.tcp->tcpchksum = 0;
    83b0:	e0 91 a1 0e 	lds	r30, 0x0EA1
    83b4:	f0 91 a2 0e 	lds	r31, 0x0EA2
    83b8:	11 8a       	std	Z+17, r1	; 0x11
    83ba:	10 8a       	std	Z+16, r1	; 0x10
      nicState.layer4.tcp->urgp      = 0;
    83bc:	13 8a       	std	Z+19, r1	; 0x13
    83be:	12 8a       	std	Z+18, r1	; 0x12
      calculateTcpChecksun(TCP_HEADER_LEN);
    83c0:	84 e1       	ldi	r24, 0x14	; 20
    83c2:	90 e0       	ldi	r25, 0x00	; 0
    83c4:	0e 94 4e 40 	call	0x809c	; 0x809c <calculateTcpChecksun>

      socket->seqNoLastSent++;
    83c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    83ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    83cc:	af 85       	ldd	r26, Y+15	; 0x0f
    83ce:	b8 89       	ldd	r27, Y+16	; 0x10
    83d0:	01 96       	adiw	r24, 0x01	; 1
    83d2:	a1 1d       	adc	r26, r1
    83d4:	b1 1d       	adc	r27, r1
    83d6:	8d 87       	std	Y+13, r24	; 0x0d
    83d8:	9e 87       	std	Y+14, r25	; 0x0e
    83da:	af 87       	std	Y+15, r26	; 0x0f
    83dc:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    83de:	69 81       	ldd	r22, Y+1	; 0x01
    83e0:	7a 81       	ldd	r23, Y+2	; 0x02
    83e2:	8b 81       	ldd	r24, Y+3	; 0x03
    83e4:	9c 81       	ldd	r25, Y+4	; 0x04
    83e6:	46 e0       	ldi	r20, 0x06	; 6
    83e8:	24 e1       	ldi	r18, 0x14	; 20
    83ea:	30 e0       	ldi	r19, 0x00	; 0
    83ec:	0e 94 59 38 	call	0x70b2	; 0x70b2 <ipSend>
    83f0:	86 c0       	rjmp	.+268    	; 0x84fe <processTcpPacket+0x43c>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    83f2:	21 15       	cp	r18, r1
    83f4:	31 05       	cpc	r19, r1
    83f6:	09 f4       	brne	.+2      	; 0x83fa <processTcpPacket+0x338>
    83f8:	82 c0       	rjmp	.+260    	; 0x84fe <processTcpPacket+0x43c>
        if (tcpDebugLevel > 1)
    83fa:	80 91 bc 0e 	lds	r24, 0x0EBC
    83fe:	82 30       	cpi	r24, 0x02	; 2
    8400:	08 f4       	brcc	.+2      	; 0x8404 <processTcpPacket+0x342>
    8402:	7d c0       	rjmp	.+250    	; 0x84fe <processTcpPacket+0x43c>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    8404:	00 d0       	rcall	.+0      	; 0x8406 <processTcpPacket+0x344>
    8406:	00 d0       	rcall	.+0      	; 0x8408 <processTcpPacket+0x346>
    8408:	ad b7       	in	r26, 0x3d	; 61
    840a:	be b7       	in	r27, 0x3e	; 62
    840c:	12 96       	adiw	r26, 0x02	; 2
    840e:	3c 93       	st	X, r19
    8410:	2e 93       	st	-X, r18
    8412:	11 97       	sbiw	r26, 0x01	; 1
    8414:	8f e6       	ldi	r24, 0x6F	; 111
    8416:	91 e1       	ldi	r25, 0x11	; 17
    8418:	39 c0       	rjmp	.+114    	; 0x848c <processTcpPacket+0x3ca>
    }
#endif    
    return 0;
  }
  
  if (socket->state == SYN_RECEIVED)
    841a:	82 30       	cpi	r24, 0x02	; 2
    841c:	09 f0       	breq	.+2      	; 0x8420 <processTcpPacket+0x35e>
    841e:	42 c0       	rjmp	.+132    	; 0x84a4 <processTcpPacket+0x3e2>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    8420:	e0 91 a1 0e 	lds	r30, 0x0EA1
    8424:	f0 91 a2 0e 	lds	r31, 0x0EA2
    8428:	85 85       	ldd	r24, Z+13	; 0x0d
    842a:	20 91 67 0f 	lds	r18, 0x0F67
    842e:	30 91 68 0f 	lds	r19, 0x0F68
    8432:	84 ff       	sbrs	r24, 4
    8434:	16 c0       	rjmp	.+44     	; 0x8462 <processTcpPacket+0x3a0>
    {
      socket->state    = ESTABILISHED;
    8436:	83 e0       	ldi	r24, 0x03	; 3
    8438:	88 83       	st	Y, r24
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    843a:	21 15       	cp	r18, r1
    843c:	31 05       	cpc	r19, r1
    843e:	09 f4       	brne	.+2      	; 0x8442 <processTcpPacket+0x380>
    8440:	5e c0       	rjmp	.+188    	; 0x84fe <processTcpPacket+0x43c>
      if (tcpDebugLevel > 2)
    8442:	80 91 bc 0e 	lds	r24, 0x0EBC
    8446:	83 30       	cpi	r24, 0x03	; 3
    8448:	08 f4       	brcc	.+2      	; 0x844c <processTcpPacket+0x38a>
    844a:	59 c0       	rjmp	.+178    	; 0x84fe <processTcpPacket+0x43c>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    844c:	00 d0       	rcall	.+0      	; 0x844e <processTcpPacket+0x38c>
    844e:	00 d0       	rcall	.+0      	; 0x8450 <processTcpPacket+0x38e>
    8450:	ed b7       	in	r30, 0x3d	; 61
    8452:	fe b7       	in	r31, 0x3e	; 62
    8454:	32 83       	std	Z+2, r19	; 0x02
    8456:	21 83       	std	Z+1, r18	; 0x01
    8458:	87 e2       	ldi	r24, 0x27	; 39
    845a:	91 e1       	ldi	r25, 0x11	; 17
    845c:	94 83       	std	Z+4, r25	; 0x04
    845e:	83 83       	std	Z+3, r24	; 0x03
    8460:	19 c0       	rjmp	.+50     	; 0x8494 <processTcpPacket+0x3d2>
#endif        

    }
    else
    {
      socket->state = LISTEN;
    8462:	81 e0       	ldi	r24, 0x01	; 1
    8464:	88 83       	st	Y, r24
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    8466:	21 15       	cp	r18, r1
    8468:	31 05       	cpc	r19, r1
    846a:	09 f4       	brne	.+2      	; 0x846e <processTcpPacket+0x3ac>
    846c:	48 c0       	rjmp	.+144    	; 0x84fe <processTcpPacket+0x43c>
        if (tcpDebugLevel > 1)
    846e:	80 91 bc 0e 	lds	r24, 0x0EBC
    8472:	82 30       	cpi	r24, 0x02	; 2
    8474:	08 f4       	brcc	.+2      	; 0x8478 <processTcpPacket+0x3b6>
    8476:	43 c0       	rjmp	.+134    	; 0x84fe <processTcpPacket+0x43c>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    8478:	00 d0       	rcall	.+0      	; 0x847a <processTcpPacket+0x3b8>
    847a:	00 d0       	rcall	.+0      	; 0x847c <processTcpPacket+0x3ba>
    847c:	ad b7       	in	r26, 0x3d	; 61
    847e:	be b7       	in	r27, 0x3e	; 62
    8480:	12 96       	adiw	r26, 0x02	; 2
    8482:	3c 93       	st	X, r19
    8484:	2e 93       	st	-X, r18
    8486:	11 97       	sbiw	r26, 0x01	; 1
    8488:	83 ef       	ldi	r24, 0xF3	; 243
    848a:	90 e1       	ldi	r25, 0x10	; 16
    848c:	14 96       	adiw	r26, 0x04	; 4
    848e:	9c 93       	st	X, r25
    8490:	8e 93       	st	-X, r24
    8492:	13 97       	sbiw	r26, 0x03	; 3
    8494:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8498:	80 e0       	ldi	r24, 0x00	; 0
    849a:	0f 90       	pop	r0
    849c:	0f 90       	pop	r0
    849e:	0f 90       	pop	r0
    84a0:	0f 90       	pop	r0
    84a2:	2e c0       	rjmp	.+92     	; 0x8500 <processTcpPacket+0x43e>
    }
    return 0;
  }
  
  
  if (socket->state == ESTABILISHED)
    84a4:	83 30       	cpi	r24, 0x03	; 3
    84a6:	59 f5       	brne	.+86     	; 0x84fe <processTcpPacket+0x43c>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    84a8:	e0 91 a1 0e 	lds	r30, 0x0EA1
    84ac:	f0 91 a2 0e 	lds	r31, 0x0EA2
    84b0:	85 85       	ldd	r24, Z+13	; 0x0d
    84b2:	80 ff       	sbrs	r24, 0
    84b4:	24 c0       	rjmp	.+72     	; 0x84fe <processTcpPacket+0x43c>
    {
      socket->timer              = timer100Hz;
    84b6:	80 91 88 01 	lds	r24, 0x0188
    84ba:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    84bc:	80 e1       	ldi	r24, 0x10	; 16
    84be:	85 87       	std	Z+13, r24	; 0x0d
//      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
//      {
//        dataFromBufLen++;
//        dataPtr++;
//      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    84c0:	69 81       	ldd	r22, Y+1	; 0x01
    84c2:	7a 81       	ldd	r23, Y+2	; 0x02
    84c4:	8b 81       	ldd	r24, Y+3	; 0x03
    84c6:	9c 81       	ldd	r25, Y+4	; 0x04
    84c8:	46 e0       	ldi	r20, 0x06	; 6
    84ca:	24 e1       	ldi	r18, 0x14	; 20
    84cc:	30 e0       	ldi	r19, 0x00	; 0
    84ce:	0e 94 59 38 	call	0x70b2	; 0x70b2 <ipSend>
      socket->state    = CLOSE_WAIT;
    84d2:	84 e0       	ldi	r24, 0x04	; 4
    84d4:	88 83       	st	Y, r24
      
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    84d6:	e0 91 a1 0e 	lds	r30, 0x0EA1
    84da:	f0 91 a2 0e 	lds	r31, 0x0EA2
    84de:	81 e0       	ldi	r24, 0x01	; 1
    84e0:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    84e2:	69 81       	ldd	r22, Y+1	; 0x01
    84e4:	7a 81       	ldd	r23, Y+2	; 0x02
    84e6:	8b 81       	ldd	r24, Y+3	; 0x03
    84e8:	9c 81       	ldd	r25, Y+4	; 0x04
    84ea:	46 e0       	ldi	r20, 0x06	; 6
    84ec:	24 e1       	ldi	r18, 0x14	; 20
    84ee:	30 e0       	ldi	r19, 0x00	; 0
    84f0:	0e 94 59 38 	call	0x70b2	; 0x70b2 <ipSend>
      socket->state    = LAST_ACK;
    84f4:	85 e0       	ldi	r24, 0x05	; 5
    84f6:	88 83       	st	Y, r24
    84f8:	02 c0       	rjmp	.+4      	; 0x84fe <processTcpPacket+0x43c>
    84fa:	81 e0       	ldi	r24, 0x01	; 1
    84fc:	01 c0       	rjmp	.+2      	; 0x8500 <processTcpPacket+0x43e>
    84fe:	80 e0       	ldi	r24, 0x00	; 0
  }

  //Read data and put into the queue
  
  return 0;
}
    8500:	df 91       	pop	r29
    8502:	cf 91       	pop	r28
    8504:	1f 91       	pop	r17
    8506:	0f 91       	pop	r16
    8508:	ff 90       	pop	r15
    850a:	ef 90       	pop	r14
    850c:	df 90       	pop	r13
    850e:	cf 90       	pop	r12
    8510:	bf 90       	pop	r11
    8512:	af 90       	pop	r10
    8514:	08 95       	ret

00008516 <netstackTCPIPProcess>:
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}

void netstackTCPIPProcess(void)
{
    8516:	0f 93       	push	r16
    8518:	1f 93       	push	r17
  if (nicState.layer4.tcp->destport == htons(80))
    851a:	e0 91 a1 0e 	lds	r30, 0x0EA1
    851e:	f0 91 a2 0e 	lds	r31, 0x0EA2
    8522:	02 81       	ldd	r16, Z+2	; 0x02
    8524:	13 81       	ldd	r17, Z+3	; 0x03
    8526:	80 e5       	ldi	r24, 0x50	; 80
    8528:	90 e0       	ldi	r25, 0x00	; 0
    852a:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    852e:	08 17       	cp	r16, r24
    8530:	19 07       	cpc	r17, r25
    8532:	b9 f4       	brne	.+46     	; 0x8562 <netstackTCPIPProcess+0x4c>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    8534:	80 91 67 0f 	lds	r24, 0x0F67
    8538:	90 91 68 0f 	lds	r25, 0x0F68
    853c:	00 97       	sbiw	r24, 0x00	; 0
    853e:	99 f0       	breq	.+38     	; 0x8566 <netstackTCPIPProcess+0x50>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    8540:	00 d0       	rcall	.+0      	; 0x8542 <netstackTCPIPProcess+0x2c>
    8542:	00 d0       	rcall	.+0      	; 0x8544 <netstackTCPIPProcess+0x2e>
    8544:	ed b7       	in	r30, 0x3d	; 61
    8546:	fe b7       	in	r31, 0x3e	; 62
    8548:	92 83       	std	Z+2, r25	; 0x02
    854a:	81 83       	std	Z+1, r24	; 0x01
    854c:	8c ed       	ldi	r24, 0xDC	; 220
    854e:	90 e1       	ldi	r25, 0x10	; 16
    8550:	94 83       	std	Z+4, r25	; 0x04
    8552:	83 83       	std	Z+3, r24	; 0x03
    8554:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8558:	0f 90       	pop	r0
    855a:	0f 90       	pop	r0
    855c:	0f 90       	pop	r0
    855e:	0f 90       	pop	r0
    8560:	02 c0       	rjmp	.+4      	; 0x8566 <netstackTCPIPProcess+0x50>
#endif
    ;
  }
  else
  {
    processTcpPacket();
    8562:	0e 94 61 40 	call	0x80c2	; 0x80c2 <processTcpPacket>
  }
}
    8566:	1f 91       	pop	r17
    8568:	0f 91       	pop	r16
    856a:	08 95       	ret

0000856c <socketInit>:
 * @param *sck socket
 */
static inline void tcpAcceptConn(struct TcpIpSocket *sck);

inline void socketInit(void)
{
    856c:	bf 92       	push	r11
    856e:	cf 92       	push	r12
    8570:	df 92       	push	r13
    8572:	ef 92       	push	r14
    8574:	ff 92       	push	r15
    8576:	0f 93       	push	r16
    8578:	1f 93       	push	r17
    857a:	cf 93       	push	r28
    857c:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    857e:	80 e3       	ldi	r24, 0x30	; 48
    8580:	92 e0       	ldi	r25, 0x02	; 2
    8582:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    8586:	80 93 d5 0e 	sts	0x0ED5, r24
    858a:	90 93 d6 0e 	sts	0x0ED6, r25
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    858e:	fc 01       	movw	r30, r24
    8590:	80 e3       	ldi	r24, 0x30	; 48
    8592:	92 e0       	ldi	r25, 0x02	; 2
    8594:	df 01       	movw	r26, r30
    8596:	9c 01       	movw	r18, r24
    8598:	1d 92       	st	X+, r1
    859a:	21 50       	subi	r18, 0x01	; 1
    859c:	30 40       	sbci	r19, 0x00	; 0
    859e:	e1 f7       	brne	.-8      	; 0x8598 <socketInit+0x2c>
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    85a0:	00 91 d5 0e 	lds	r16, 0x0ED5
    85a4:	10 91 d6 0e 	lds	r17, 0x0ED6
    85a8:	c8 ea       	ldi	r28, 0xA8	; 168
    85aa:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    85ac:	8f ef       	ldi	r24, 0xFF	; 255
    85ae:	c8 2e       	mov	r12, r24
    85b0:	81 e1       	ldi	r24, 0x11	; 17
    85b2:	d8 2e       	mov	r13, r24
    85b4:	82 e2       	ldi	r24, 0x22	; 34
    85b6:	e8 2e       	mov	r14, r24
    85b8:	83 e3       	ldi	r24, 0x33	; 51
    85ba:	f8 2e       	mov	r15, r24
    sck->state         = LISTEN;   
    85bc:	bb 24       	eor	r11, r11
    85be:	b3 94       	inc	r11
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    85c0:	de 01       	movw	r26, r28
    85c2:	a8 5a       	subi	r26, 0xA8	; 168
    85c4:	a0 31       	cpi	r26, 0x10	; 16
    85c6:	18 f0       	brcs	.+6      	; 0x85ce <socketInit+0x62>
    85c8:	88 eb       	ldi	r24, 0xB8	; 184
    85ca:	91 e6       	ldi	r25, 0x61	; 97
    85cc:	03 c0       	rjmp	.+6      	; 0x85d4 <socketInit+0x68>
    85ce:	ce 01       	movw	r24, r28
    85d0:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    85d4:	f8 01       	movw	r30, r16
    85d6:	96 83       	std	Z+6, r25	; 0x06
    85d8:	85 83       	std	Z+5, r24	; 0x05
    sck->seqNoLastSent = HTONL(0xFF112233); 
    85da:	d8 01       	movw	r26, r16
    85dc:	1d 96       	adiw	r26, 0x0d	; 13
    85de:	cd 92       	st	X+, r12
    85e0:	dd 92       	st	X+, r13
    85e2:	ed 92       	st	X+, r14
    85e4:	fc 92       	st	X, r15
    85e6:	50 97       	sbiw	r26, 0x10	; 16
    sck->state         = LISTEN;   
    85e8:	bc 92       	st	X, r11
    85ea:	21 96       	adiw	r28, 0x01	; 1
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    85ec:	b1 e6       	ldi	r27, 0x61	; 97
    85ee:	cc 3b       	cpi	r28, 0xBC	; 188
    85f0:	db 07       	cpc	r29, r27
    85f2:	19 f0       	breq	.+6      	; 0x85fa <socketInit+0x8e>
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    sck->state         = LISTEN;   
    sck++;
    85f4:	04 5e       	subi	r16, 0xE4	; 228
    85f6:	1f 4f       	sbci	r17, 0xFF	; 255
    85f8:	e3 cf       	rjmp	.-58     	; 0x85c0 <socketInit+0x54>
  }
}
    85fa:	df 91       	pop	r29
    85fc:	cf 91       	pop	r28
    85fe:	1f 91       	pop	r17
    8600:	0f 91       	pop	r16
    8602:	ff 90       	pop	r15
    8604:	ef 90       	pop	r14
    8606:	df 90       	pop	r13
    8608:	cf 90       	pop	r12
    860a:	bf 90       	pop	r11
    860c:	08 95       	ret

0000860e <setUdpDebug>:
}

#if UDP_DEBUG
void setUdpDebug(FILE *stream, uint8_t level)
{
  udpDbgStream = stream;
    860e:	90 93 da 0e 	sts	0x0EDA, r25
    8612:	80 93 d9 0e 	sts	0x0ED9, r24
  udpDbgLevel = level;
    8616:	60 93 94 0e 	sts	0x0E94, r22
}
    861a:	08 95       	ret

0000861c <udpPrintStatus>:
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
}

void udpPrintStatus(FILE *stream)
{
    861c:	cf 93       	push	r28
    861e:	df 93       	push	r29
    8620:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR("UDP config:"));
    8622:	00 d0       	rcall	.+0      	; 0x8624 <udpPrintStatus+0x8>
    8624:	00 d0       	rcall	.+0      	; 0x8626 <udpPrintStatus+0xa>
    8626:	ad b7       	in	r26, 0x3d	; 61
    8628:	be b7       	in	r27, 0x3e	; 62
    862a:	12 96       	adiw	r26, 0x02	; 2
    862c:	9c 93       	st	X, r25
    862e:	8e 93       	st	-X, r24
    8630:	11 97       	sbiw	r26, 0x01	; 1
    8632:	86 e9       	ldi	r24, 0x96	; 150
    8634:	92 e1       	ldi	r25, 0x12	; 18
    8636:	14 96       	adiw	r26, 0x04	; 4
    8638:	9c 93       	st	X, r25
    863a:	8e 93       	st	-X, r24
    863c:	13 97       	sbiw	r26, 0x03	; 3
    863e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("\r\n  IP          : ")); netPrintIPAddr(stream, udpSocket->dstIp);
    8642:	ed b7       	in	r30, 0x3d	; 61
    8644:	fe b7       	in	r31, 0x3e	; 62
    8646:	d2 83       	std	Z+2, r29	; 0x02
    8648:	c1 83       	std	Z+1, r28	; 0x01
    864a:	83 e8       	ldi	r24, 0x83	; 131
    864c:	92 e1       	ldi	r25, 0x12	; 18
    864e:	94 83       	std	Z+4, r25	; 0x04
    8650:	83 83       	std	Z+3, r24	; 0x03
    8652:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8656:	0f 90       	pop	r0
    8658:	0f 90       	pop	r0
    865a:	0f 90       	pop	r0
    865c:	0f 90       	pop	r0
    865e:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8662:	f0 91 ba 0e 	lds	r31, 0x0EBA
    8666:	46 81       	ldd	r20, Z+6	; 0x06
    8668:	57 81       	ldd	r21, Z+7	; 0x07
    866a:	60 85       	ldd	r22, Z+8	; 0x08
    866c:	71 85       	ldd	r23, Z+9	; 0x09
    866e:	ce 01       	movw	r24, r28
    8670:	0e 94 40 35 	call	0x6a80	; 0x6a80 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n  src port    : %d\r\n  dst port    : "), htons(udpSocket->srcPort));
    8674:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8678:	f0 91 ba 0e 	lds	r31, 0x0EBA
    867c:	84 81       	ldd	r24, Z+4	; 0x04
    867e:	95 81       	ldd	r25, Z+5	; 0x05
    8680:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    8684:	00 d0       	rcall	.+0      	; 0x8686 <udpPrintStatus+0x6a>
    8686:	00 d0       	rcall	.+0      	; 0x8688 <udpPrintStatus+0x6c>
    8688:	00 d0       	rcall	.+0      	; 0x868a <udpPrintStatus+0x6e>
    868a:	ed b7       	in	r30, 0x3d	; 61
    868c:	fe b7       	in	r31, 0x3e	; 62
    868e:	31 96       	adiw	r30, 0x01	; 1
    8690:	ad b7       	in	r26, 0x3d	; 61
    8692:	be b7       	in	r27, 0x3e	; 62
    8694:	12 96       	adiw	r26, 0x02	; 2
    8696:	dc 93       	st	X, r29
    8698:	ce 93       	st	-X, r28
    869a:	11 97       	sbiw	r26, 0x01	; 1
    869c:	2c e5       	ldi	r18, 0x5C	; 92
    869e:	32 e1       	ldi	r19, 0x12	; 18
    86a0:	33 83       	std	Z+3, r19	; 0x03
    86a2:	22 83       	std	Z+2, r18	; 0x02
    86a4:	95 83       	std	Z+5, r25	; 0x05
    86a6:	84 83       	std	Z+4, r24	; 0x04
    86a8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  if (udpSocket->dstPortDef == HTONS(0))
    86ac:	e0 91 b9 0e 	lds	r30, 0x0EB9
    86b0:	f0 91 ba 0e 	lds	r31, 0x0EBA
    86b4:	80 81       	ld	r24, Z
    86b6:	91 81       	ldd	r25, Z+1	; 0x01
    86b8:	ed b7       	in	r30, 0x3d	; 61
    86ba:	fe b7       	in	r31, 0x3e	; 62
    86bc:	36 96       	adiw	r30, 0x06	; 6
    86be:	0f b6       	in	r0, 0x3f	; 63
    86c0:	f8 94       	cli
    86c2:	fe bf       	out	0x3e, r31	; 62
    86c4:	0f be       	out	0x3f, r0	; 63
    86c6:	ed bf       	out	0x3d, r30	; 61
    86c8:	00 97       	sbiw	r24, 0x00	; 0
    86ca:	a9 f4       	brne	.+42     	; 0x86f6 <udpPrintStatus+0xda>
    fprintf_P(stream, PSTR("ANY\r\n"));
    86cc:	00 d0       	rcall	.+0      	; 0x86ce <udpPrintStatus+0xb2>
    86ce:	00 d0       	rcall	.+0      	; 0x86d0 <udpPrintStatus+0xb4>
    86d0:	ad b7       	in	r26, 0x3d	; 61
    86d2:	be b7       	in	r27, 0x3e	; 62
    86d4:	12 96       	adiw	r26, 0x02	; 2
    86d6:	dc 93       	st	X, r29
    86d8:	ce 93       	st	-X, r28
    86da:	11 97       	sbiw	r26, 0x01	; 1
    86dc:	86 e5       	ldi	r24, 0x56	; 86
    86de:	92 e1       	ldi	r25, 0x12	; 18
    86e0:	14 96       	adiw	r26, 0x04	; 4
    86e2:	9c 93       	st	X, r25
    86e4:	8e 93       	st	-X, r24
    86e6:	13 97       	sbiw	r26, 0x03	; 3
    86e8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    86ec:	0f 90       	pop	r0
    86ee:	0f 90       	pop	r0
    86f0:	0f 90       	pop	r0
    86f2:	0f 90       	pop	r0
    86f4:	1e c0       	rjmp	.+60     	; 0x8732 <udpPrintStatus+0x116>
  else
    fprintf_P(stream, PSTR("%d\r\n"), htons(udpSocket->dstPortDef));    
    86f6:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    86fa:	00 d0       	rcall	.+0      	; 0x86fc <udpPrintStatus+0xe0>
    86fc:	00 d0       	rcall	.+0      	; 0x86fe <udpPrintStatus+0xe2>
    86fe:	00 d0       	rcall	.+0      	; 0x8700 <udpPrintStatus+0xe4>
    8700:	ed b7       	in	r30, 0x3d	; 61
    8702:	fe b7       	in	r31, 0x3e	; 62
    8704:	31 96       	adiw	r30, 0x01	; 1
    8706:	ad b7       	in	r26, 0x3d	; 61
    8708:	be b7       	in	r27, 0x3e	; 62
    870a:	12 96       	adiw	r26, 0x02	; 2
    870c:	dc 93       	st	X, r29
    870e:	ce 93       	st	-X, r28
    8710:	11 97       	sbiw	r26, 0x01	; 1
    8712:	21 e5       	ldi	r18, 0x51	; 81
    8714:	32 e1       	ldi	r19, 0x12	; 18
    8716:	33 83       	std	Z+3, r19	; 0x03
    8718:	22 83       	std	Z+2, r18	; 0x02
    871a:	95 83       	std	Z+5, r25	; 0x05
    871c:	84 83       	std	Z+4, r24	; 0x04
    871e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8722:	ed b7       	in	r30, 0x3d	; 61
    8724:	fe b7       	in	r31, 0x3e	; 62
    8726:	36 96       	adiw	r30, 0x06	; 6
    8728:	0f b6       	in	r0, 0x3f	; 63
    872a:	f8 94       	cli
    872c:	fe bf       	out	0x3e, r31	; 62
    872e:	0f be       	out	0x3f, r0	; 63
    8730:	ed bf       	out	0x3d, r30	; 61
}
    8732:	df 91       	pop	r29
    8734:	cf 91       	pop	r28
    8736:	08 95       	ret

00008738 <udpSaveConfig>:
  }
}

void udpSaveConfig(void)
{
  eeprom_update_dword(&udpIpDst_eep, udpSocket->dstIp);
    8738:	e0 91 b9 0e 	lds	r30, 0x0EB9
    873c:	f0 91 ba 0e 	lds	r31, 0x0EBA
    8740:	46 81       	ldd	r20, Z+6	; 0x06
    8742:	57 81       	ldd	r21, Z+7	; 0x07
    8744:	60 85       	ldd	r22, Z+8	; 0x08
    8746:	71 85       	ldd	r23, Z+9	; 0x09
    8748:	8a e2       	ldi	r24, 0x2A	; 42
    874a:	90 e0       	ldi	r25, 0x00	; 0
    874c:	0e 94 00 78 	call	0xf000	; 0xf000 <__eeupd_dword_m128>
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
    8750:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8754:	f0 91 ba 0e 	lds	r31, 0x0EBA
    8758:	60 81       	ld	r22, Z
    875a:	71 81       	ldd	r23, Z+1	; 0x01
    875c:	8e e2       	ldi	r24, 0x2E	; 46
    875e:	90 e0       	ldi	r25, 0x00	; 0
    8760:	0e 94 0c 78 	call	0xf018	; 0xf018 <__eeupd_word_m128>
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
    8764:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8768:	f0 91 ba 0e 	lds	r31, 0x0EBA
    876c:	64 81       	ldd	r22, Z+4	; 0x04
    876e:	75 81       	ldd	r23, Z+5	; 0x05
    8770:	80 e3       	ldi	r24, 0x30	; 48
    8772:	90 e0       	ldi	r25, 0x00	; 0
    8774:	0e 94 0c 78 	call	0xf018	; 0xf018 <__eeupd_word_m128>
}
    8778:	08 95       	ret

0000877a <netstackUDPIPProcess>:
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
}

inline void netstackUDPIPProcess(void)
{
    877a:	af 92       	push	r10
    877c:	bf 92       	push	r11
    877e:	cf 92       	push	r12
    8780:	df 92       	push	r13
    8782:	ff 92       	push	r15
    8784:	0f 93       	push	r16
    8786:	1f 93       	push	r17
    8788:	cf 93       	push	r28
    878a:	df 93       	push	r29
  uint16_t len = (uint16_t) htons(nicState.layer4.udp->udplen);
    878c:	e0 91 a1 0e 	lds	r30, 0x0EA1
    8790:	f0 91 a2 0e 	lds	r31, 0x0EA2
    8794:	84 81       	ldd	r24, Z+4	; 0x04
    8796:	95 81       	ldd	r25, Z+5	; 0x05
    8798:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    879c:	8c 01       	movw	r16, r24
  uint8_t i;

  #if UDP_DEBUG
  if(udpDbgStream != NULL)
    879e:	20 91 d9 0e 	lds	r18, 0x0ED9
    87a2:	30 91 da 0e 	lds	r19, 0x0EDA
    87a6:	21 15       	cp	r18, r1
    87a8:	31 05       	cpc	r19, r1
    87aa:	21 f1       	breq	.+72     	; 0x87f4 <netstackUDPIPProcess+0x7a>
    if (udpDbgLevel > 3)
    87ac:	80 91 94 0e 	lds	r24, 0x0E94
    87b0:	84 30       	cpi	r24, 0x04	; 4
    87b2:	00 f1       	brcs	.+64     	; 0x87f4 <netstackUDPIPProcess+0x7a>
      fprintf_P(udpDbgStream, PSTR("Proc. UDP packet (data length %d)\r\n"), len-UDP_HEADER_LEN);
    87b4:	00 d0       	rcall	.+0      	; 0x87b6 <netstackUDPIPProcess+0x3c>
    87b6:	00 d0       	rcall	.+0      	; 0x87b8 <netstackUDPIPProcess+0x3e>
    87b8:	00 d0       	rcall	.+0      	; 0x87ba <netstackUDPIPProcess+0x40>
    87ba:	ed b7       	in	r30, 0x3d	; 61
    87bc:	fe b7       	in	r31, 0x3e	; 62
    87be:	31 96       	adiw	r30, 0x01	; 1
    87c0:	ad b7       	in	r26, 0x3d	; 61
    87c2:	be b7       	in	r27, 0x3e	; 62
    87c4:	12 96       	adiw	r26, 0x02	; 2
    87c6:	3c 93       	st	X, r19
    87c8:	2e 93       	st	-X, r18
    87ca:	11 97       	sbiw	r26, 0x01	; 1
    87cc:	82 ed       	ldi	r24, 0xD2	; 210
    87ce:	92 e1       	ldi	r25, 0x12	; 18
    87d0:	93 83       	std	Z+3, r25	; 0x03
    87d2:	82 83       	std	Z+2, r24	; 0x02
    87d4:	08 50       	subi	r16, 0x08	; 8
    87d6:	10 40       	sbci	r17, 0x00	; 0
    87d8:	15 83       	std	Z+5, r17	; 0x05
    87da:	04 83       	std	Z+4, r16	; 0x04
    87dc:	08 5f       	subi	r16, 0xF8	; 248
    87de:	1f 4f       	sbci	r17, 0xFF	; 255
    87e0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    87e4:	ed b7       	in	r30, 0x3d	; 61
    87e6:	fe b7       	in	r31, 0x3e	; 62
    87e8:	36 96       	adiw	r30, 0x06	; 6
    87ea:	0f b6       	in	r0, 0x3f	; 63
    87ec:	f8 94       	cli
    87ee:	fe bf       	out	0x3e, r31	; 62
    87f0:	0f be       	out	0x3f, r0	; 63
    87f2:	ed bf       	out	0x3d, r30	; 61
#endif

  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    87f4:	c0 91 a1 0e 	lds	r28, 0x0EA1
    87f8:	d0 91 a2 0e 	lds	r29, 0x0EA2
    87fc:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8800:	f0 91 ba 0e 	lds	r31, 0x0EBA
    8804:	2a 81       	ldd	r18, Y+2	; 0x02
    8806:	3b 81       	ldd	r19, Y+3	; 0x03
    8808:	84 81       	ldd	r24, Z+4	; 0x04
    880a:	95 81       	ldd	r25, Z+5	; 0x05
    880c:	28 17       	cp	r18, r24
    880e:	39 07       	cpc	r19, r25
    8810:	09 f0       	breq	.+2      	; 0x8814 <netstackUDPIPProcess+0x9a>
    8812:	aa c0       	rjmp	.+340    	; 0x8968 <netstackUDPIPProcess+0x1ee>
    8814:	80 81       	ld	r24, Z
    8816:	91 81       	ldd	r25, Z+1	; 0x01
    8818:	28 81       	ld	r18, Y
    881a:	39 81       	ldd	r19, Y+1	; 0x01
    881c:	89 2b       	or	r24, r25
    881e:	39 f0       	breq	.+14     	; 0x882e <netstackUDPIPProcess+0xb4>
    8820:	82 81       	ldd	r24, Z+2	; 0x02
    8822:	93 81       	ldd	r25, Z+3	; 0x03
    8824:	82 17       	cp	r24, r18
    8826:	93 07       	cpc	r25, r19
    8828:	09 f0       	breq	.+2      	; 0x882c <netstackUDPIPProcess+0xb2>
    882a:	9e c0       	rjmp	.+316    	; 0x8968 <netstackUDPIPProcess+0x1ee>
    882c:	02 c0       	rjmp	.+4      	; 0x8832 <netstackUDPIPProcess+0xb8>
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    882e:	33 83       	std	Z+3, r19	; 0x03
    8830:	22 83       	std	Z+2, r18	; 0x02
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    8832:	20 91 d9 0e 	lds	r18, 0x0ED9
    8836:	30 91 da 0e 	lds	r19, 0x0EDA
    883a:	21 15       	cp	r18, r1
    883c:	31 05       	cpc	r19, r1
    883e:	c1 f0       	breq	.+48     	; 0x8870 <netstackUDPIPProcess+0xf6>
        if (udpDbgLevel > 4)
    8840:	80 91 94 0e 	lds	r24, 0x0E94
    8844:	85 30       	cpi	r24, 0x05	; 5
    8846:	a0 f0       	brcs	.+40     	; 0x8870 <netstackUDPIPProcess+0xf6>
          fprintf_P(udpDbgStream, PSTR("Received data: "));
    8848:	00 d0       	rcall	.+0      	; 0x884a <netstackUDPIPProcess+0xd0>
    884a:	00 d0       	rcall	.+0      	; 0x884c <netstackUDPIPProcess+0xd2>
    884c:	ad b7       	in	r26, 0x3d	; 61
    884e:	be b7       	in	r27, 0x3e	; 62
    8850:	12 96       	adiw	r26, 0x02	; 2
    8852:	3c 93       	st	X, r19
    8854:	2e 93       	st	-X, r18
    8856:	11 97       	sbiw	r26, 0x01	; 1
    8858:	82 ec       	ldi	r24, 0xC2	; 194
    885a:	92 e1       	ldi	r25, 0x12	; 18
    885c:	14 96       	adiw	r26, 0x04	; 4
    885e:	9c 93       	st	X, r25
    8860:	8e 93       	st	-X, r24
    8862:	13 97       	sbiw	r26, 0x03	; 3
    8864:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8868:	0f 90       	pop	r0
    886a:	0f 90       	pop	r0
    886c:	0f 90       	pop	r0
    886e:	0f 90       	pop	r0
  if ((nicState.layer4.udp->destport == udpSocket->srcPort) && ((udpSocket->dstPortDef == HTONS(0))
    || (udpSocket->dstPort == nicState.layer4.udp->srcport)))
  {
    if (udpSocket->dstPortDef == HTONS(0))
      udpSocket->dstPort = nicState.layer4.udp->srcport;
    uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    8870:	28 96       	adiw	r28, 0x08	; 8
    8872:	28 e0       	ldi	r18, 0x08	; 8
    8874:	f2 2e       	mov	r15, r18
    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    8876:	9a eb       	ldi	r25, 0xBA	; 186
    8878:	a9 2e       	mov	r10, r25
    887a:	92 e1       	ldi	r25, 0x12	; 18
    887c:	b9 2e       	mov	r11, r25
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
        if(udpDbgStream != NULL)
          if (udpDbgLevel > 0)
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    887e:	85 ea       	ldi	r24, 0xA5	; 165
    8880:	c8 2e       	mov	r12, r24
    8882:	82 e1       	ldi	r24, 0x12	; 18
    8884:	d8 2e       	mov	r13, r24
    8886:	4f c0       	rjmp	.+158    	; 0x8926 <netstackUDPIPProcess+0x1ac>
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    8888:	21 15       	cp	r18, r1
    888a:	31 05       	cpc	r19, r1
    888c:	f9 f0       	breq	.+62     	; 0x88cc <netstackUDPIPProcess+0x152>
        if (udpDbgLevel > 4)
    888e:	80 91 94 0e 	lds	r24, 0x0E94
    8892:	85 30       	cpi	r24, 0x05	; 5
    8894:	d8 f0       	brcs	.+54     	; 0x88cc <netstackUDPIPProcess+0x152>
          fprintf_P(udpDbgStream, PSTR("0x%2x\r\n"), *tmp);
    8896:	00 d0       	rcall	.+0      	; 0x8898 <netstackUDPIPProcess+0x11e>
    8898:	00 d0       	rcall	.+0      	; 0x889a <netstackUDPIPProcess+0x120>
    889a:	00 d0       	rcall	.+0      	; 0x889c <netstackUDPIPProcess+0x122>
    889c:	ed b7       	in	r30, 0x3d	; 61
    889e:	fe b7       	in	r31, 0x3e	; 62
    88a0:	31 96       	adiw	r30, 0x01	; 1
    88a2:	ad b7       	in	r26, 0x3d	; 61
    88a4:	be b7       	in	r27, 0x3e	; 62
    88a6:	12 96       	adiw	r26, 0x02	; 2
    88a8:	3c 93       	st	X, r19
    88aa:	2e 93       	st	-X, r18
    88ac:	11 97       	sbiw	r26, 0x01	; 1
    88ae:	b3 82       	std	Z+3, r11	; 0x03
    88b0:	a2 82       	std	Z+2, r10	; 0x02
    88b2:	88 81       	ld	r24, Y
    88b4:	84 83       	std	Z+4, r24	; 0x04
    88b6:	15 82       	std	Z+5, r1	; 0x05
    88b8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    88bc:	ed b7       	in	r30, 0x3d	; 61
    88be:	fe b7       	in	r31, 0x3e	; 62
    88c0:	36 96       	adiw	r30, 0x06	; 6
    88c2:	0f b6       	in	r0, 0x3f	; 63
    88c4:	f8 94       	cli
    88c6:	fe bf       	out	0x3e, r31	; 62
    88c8:	0f be       	out	0x3f, r0	; 63
    88ca:	ed bf       	out	0x3d, r30	; 61
#endif
#if UDB_DEBUG
      xQueueSend(udpSocket->Rx, tmp, 10) == 0);
#else
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
    88cc:	e0 91 b9 0e 	lds	r30, 0x0EB9
    88d0:	f0 91 ba 0e 	lds	r31, 0x0EBA
    88d4:	82 85       	ldd	r24, Z+10	; 0x0a
    88d6:	93 85       	ldd	r25, Z+11	; 0x0b
    88d8:	be 01       	movw	r22, r28
    88da:	4a e0       	ldi	r20, 0x0A	; 10
    88dc:	50 e0       	ldi	r21, 0x00	; 0
    88de:	20 e0       	ldi	r18, 0x00	; 0
    88e0:	0e 94 97 6c 	call	0xd92e	; 0xd92e <xQueueGenericSend>
    88e4:	88 23       	and	r24, r24
    88e6:	e9 f4       	brne	.+58     	; 0x8922 <netstackUDPIPProcess+0x1a8>
        if(udpDbgStream != NULL)
    88e8:	20 91 d9 0e 	lds	r18, 0x0ED9
    88ec:	30 91 da 0e 	lds	r19, 0x0EDA
    88f0:	21 15       	cp	r18, r1
    88f2:	31 05       	cpc	r19, r1
    88f4:	b1 f0       	breq	.+44     	; 0x8922 <netstackUDPIPProcess+0x1a8>
          if (udpDbgLevel > 0)
    88f6:	80 91 94 0e 	lds	r24, 0x0E94
    88fa:	88 23       	and	r24, r24
    88fc:	91 f0       	breq	.+36     	; 0x8922 <netstackUDPIPProcess+0x1a8>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    88fe:	00 d0       	rcall	.+0      	; 0x8900 <netstackUDPIPProcess+0x186>
    8900:	00 d0       	rcall	.+0      	; 0x8902 <netstackUDPIPProcess+0x188>
    8902:	ad b7       	in	r26, 0x3d	; 61
    8904:	be b7       	in	r27, 0x3e	; 62
    8906:	12 96       	adiw	r26, 0x02	; 2
    8908:	3c 93       	st	X, r19
    890a:	2e 93       	st	-X, r18
    890c:	11 97       	sbiw	r26, 0x01	; 1
    890e:	14 96       	adiw	r26, 0x04	; 4
    8910:	dc 92       	st	X, r13
    8912:	ce 92       	st	-X, r12
    8914:	13 97       	sbiw	r26, 0x03	; 3
    8916:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    891a:	0f 90       	pop	r0
    891c:	0f 90       	pop	r0
    891e:	0f 90       	pop	r0
    8920:	0f 90       	pop	r0
#endif
      tmp++;
    8922:	21 96       	adiw	r28, 0x01	; 1
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received data: "));
#endif

    for (i=UDP_HEADER_LEN; i<len; i++)
    8924:	f3 94       	inc	r15
    8926:	8f 2d       	mov	r24, r15
    8928:	90 e0       	ldi	r25, 0x00	; 0
    892a:	20 91 d9 0e 	lds	r18, 0x0ED9
    892e:	30 91 da 0e 	lds	r19, 0x0EDA
    8932:	80 17       	cp	r24, r16
    8934:	91 07       	cpc	r25, r17
    8936:	08 f4       	brcc	.+2      	; 0x893a <netstackUDPIPProcess+0x1c0>
    8938:	a7 cf       	rjmp	.-178    	; 0x8888 <netstackUDPIPProcess+0x10e>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
#endif
      tmp++;
    }
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    893a:	21 15       	cp	r18, r1
    893c:	31 05       	cpc	r19, r1
    893e:	a1 f0       	breq	.+40     	; 0x8968 <netstackUDPIPProcess+0x1ee>
      if (udpDbgLevel > 4)
    8940:	80 91 94 0e 	lds	r24, 0x0E94
    8944:	85 30       	cpi	r24, 0x05	; 5
    8946:	80 f0       	brcs	.+32     	; 0x8968 <netstackUDPIPProcess+0x1ee>
        fprintf_P(udpDbgStream, PSTR("\r\n"));
    8948:	00 d0       	rcall	.+0      	; 0x894a <netstackUDPIPProcess+0x1d0>
    894a:	00 d0       	rcall	.+0      	; 0x894c <netstackUDPIPProcess+0x1d2>
    894c:	ed b7       	in	r30, 0x3d	; 61
    894e:	fe b7       	in	r31, 0x3e	; 62
    8950:	32 83       	std	Z+2, r19	; 0x02
    8952:	21 83       	std	Z+1, r18	; 0x01
    8954:	82 ea       	ldi	r24, 0xA2	; 162
    8956:	92 e1       	ldi	r25, 0x12	; 18
    8958:	94 83       	std	Z+4, r25	; 0x04
    895a:	83 83       	std	Z+3, r24	; 0x03
    895c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8960:	0f 90       	pop	r0
    8962:	0f 90       	pop	r0
    8964:	0f 90       	pop	r0
    8966:	0f 90       	pop	r0
#endif

  }
}
    8968:	df 91       	pop	r29
    896a:	cf 91       	pop	r28
    896c:	1f 91       	pop	r17
    896e:	0f 91       	pop	r16
    8970:	ff 90       	pop	r15
    8972:	df 90       	pop	r13
    8974:	cf 90       	pop	r12
    8976:	bf 90       	pop	r11
    8978:	af 90       	pop	r10
    897a:	08 95       	ret

0000897c <udpSend>:
  udpDbgLevel = level;
}
#endif

inline void udpSend(uint16_t len)
{
    897c:	ef 92       	push	r14
    897e:	ff 92       	push	r15
    8980:	0f 93       	push	r16
    8982:	1f 93       	push	r17
    8984:	cf 93       	push	r28
    8986:	df 93       	push	r29
    8988:	7c 01       	movw	r14, r24
// make pointer to UDP header
  nicState.layer4.udp->srcport  = udpSocket->srcPort;
    898a:	c0 91 a1 0e 	lds	r28, 0x0EA1
    898e:	d0 91 a2 0e 	lds	r29, 0x0EA2
    8992:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8996:	f0 91 ba 0e 	lds	r31, 0x0EBA
    899a:	84 81       	ldd	r24, Z+4	; 0x04
    899c:	95 81       	ldd	r25, Z+5	; 0x05
    899e:	99 83       	std	Y+1, r25	; 0x01
    89a0:	88 83       	st	Y, r24
  nicState.layer4.udp->destport = (udpSocket->dstPortDef == 0)? udpSocket->dstPort : udpSocket->dstPortDef;          //data in udpSocket are stored in network order
    89a2:	80 81       	ld	r24, Z
    89a4:	91 81       	ldd	r25, Z+1	; 0x01
    89a6:	00 97       	sbiw	r24, 0x00	; 0
    89a8:	11 f4       	brne	.+4      	; 0x89ae <udpSend+0x32>
    89aa:	82 81       	ldd	r24, Z+2	; 0x02
    89ac:	93 81       	ldd	r25, Z+3	; 0x03
    89ae:	9b 83       	std	Y+3, r25	; 0x03
    89b0:	8a 83       	std	Y+2, r24	; 0x02
  
  nicState.layer4.udp->udplen = htons(len + UDP_HEADER_LEN);
    89b2:	87 01       	movw	r16, r14
    89b4:	08 5f       	subi	r16, 0xF8	; 248
    89b6:	1f 4f       	sbci	r17, 0xFF	; 255
    89b8:	c8 01       	movw	r24, r16
    89ba:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    89be:	9d 83       	std	Y+5, r25	; 0x05
    89c0:	8c 83       	std	Y+4, r24	; 0x04
  nicState.layer4.udp->udpchksum = 0;
    89c2:	e0 91 a1 0e 	lds	r30, 0x0EA1
    89c6:	f0 91 a2 0e 	lds	r31, 0x0EA2
    89ca:	17 82       	std	Z+7, r1	; 0x07
    89cc:	16 82       	std	Z+6, r1	; 0x06

#if UDP_DEBUG
  if (udpDbgStream != NULL)
    89ce:	20 91 d9 0e 	lds	r18, 0x0ED9
    89d2:	30 91 da 0e 	lds	r19, 0x0EDA
    89d6:	21 15       	cp	r18, r1
    89d8:	31 05       	cpc	r19, r1
    89da:	01 f1       	breq	.+64     	; 0x8a1c <udpSend+0xa0>
    if (udpDbgLevel > 1)
    89dc:	80 91 94 0e 	lds	r24, 0x0E94
    89e0:	82 30       	cpi	r24, 0x02	; 2
    89e2:	e0 f0       	brcs	.+56     	; 0x8a1c <udpSend+0xa0>
      fprintf_P(udpDbgStream, PSTR("Sending UDP packet (data length %d)\r\n"), len);
    89e4:	00 d0       	rcall	.+0      	; 0x89e6 <udpSend+0x6a>
    89e6:	00 d0       	rcall	.+0      	; 0x89e8 <udpSend+0x6c>
    89e8:	00 d0       	rcall	.+0      	; 0x89ea <udpSend+0x6e>
    89ea:	ed b7       	in	r30, 0x3d	; 61
    89ec:	fe b7       	in	r31, 0x3e	; 62
    89ee:	31 96       	adiw	r30, 0x01	; 1
    89f0:	ad b7       	in	r26, 0x3d	; 61
    89f2:	be b7       	in	r27, 0x3e	; 62
    89f4:	12 96       	adiw	r26, 0x02	; 2
    89f6:	3c 93       	st	X, r19
    89f8:	2e 93       	st	-X, r18
    89fa:	11 97       	sbiw	r26, 0x01	; 1
    89fc:	86 ef       	ldi	r24, 0xF6	; 246
    89fe:	92 e1       	ldi	r25, 0x12	; 18
    8a00:	93 83       	std	Z+3, r25	; 0x03
    8a02:	82 83       	std	Z+2, r24	; 0x02
    8a04:	f5 82       	std	Z+5, r15	; 0x05
    8a06:	e4 82       	std	Z+4, r14	; 0x04
    8a08:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8a0c:	8d b7       	in	r24, 0x3d	; 61
    8a0e:	9e b7       	in	r25, 0x3e	; 62
    8a10:	06 96       	adiw	r24, 0x06	; 6
    8a12:	0f b6       	in	r0, 0x3f	; 63
    8a14:	f8 94       	cli
    8a16:	9e bf       	out	0x3e, r25	; 62
    8a18:	0f be       	out	0x3f, r0	; 63
    8a1a:	8d bf       	out	0x3d, r24	; 61
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
    8a1c:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8a20:	f0 91 ba 0e 	lds	r31, 0x0EBA
    8a24:	66 81       	ldd	r22, Z+6	; 0x06
    8a26:	77 81       	ldd	r23, Z+7	; 0x07
    8a28:	80 85       	ldd	r24, Z+8	; 0x08
    8a2a:	91 85       	ldd	r25, Z+9	; 0x09
    8a2c:	41 e1       	ldi	r20, 0x11	; 17
    8a2e:	98 01       	movw	r18, r16
    8a30:	0e 94 59 38 	call	0x70b2	; 0x70b2 <ipSend>
}
    8a34:	df 91       	pop	r29
    8a36:	cf 91       	pop	r28
    8a38:	1f 91       	pop	r17
    8a3a:	0f 91       	pop	r16
    8a3c:	ff 90       	pop	r15
    8a3e:	ef 90       	pop	r14
    8a40:	08 95       	ret

00008a42 <flushUdpQueues>:

  }
}

inline void flushUdpQueues(void)
{
    8a42:	0f 93       	push	r16
    8a44:	1f 93       	push	r17
    8a46:	cf 93       	push	r28
    8a48:	df 93       	push	r29
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
    8a4a:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8a4e:	f0 91 ba 0e 	lds	r31, 0x0EBA
    8a52:	84 85       	ldd	r24, Z+12	; 0x0c
    8a54:	95 85       	ldd	r25, Z+13	; 0x0d
    8a56:	0e 94 b9 6a 	call	0xd572	; 0xd572 <uxQueueMessagesWaiting>
    8a5a:	88 23       	and	r24, r24
    8a5c:	e1 f0       	breq	.+56     	; 0x8a96 <flushUdpQueues+0x54>
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    8a5e:	c0 91 a1 0e 	lds	r28, 0x0EA1
    8a62:	d0 91 a2 0e 	lds	r29, 0x0EA2
    8a66:	28 96       	adiw	r28, 0x08	; 8
    8a68:	00 e0       	ldi	r16, 0x00	; 0
    8a6a:	10 e0       	ldi	r17, 0x00	; 0
    8a6c:	03 c0       	rjmp	.+6      	; 0x8a74 <flushUdpQueues+0x32>
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    {
      data++;
    8a6e:	21 96       	adiw	r28, 0x01	; 1
      len++;
    8a70:	0f 5f       	subi	r16, 0xFF	; 255
    8a72:	1f 4f       	sbci	r17, 0xFF	; 255
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    8a74:	e0 91 b9 0e 	lds	r30, 0x0EB9
    8a78:	f0 91 ba 0e 	lds	r31, 0x0EBA
    8a7c:	84 85       	ldd	r24, Z+12	; 0x0c
    8a7e:	95 85       	ldd	r25, Z+13	; 0x0d
    8a80:	be 01       	movw	r22, r28
    8a82:	40 e0       	ldi	r20, 0x00	; 0
    8a84:	50 e0       	ldi	r21, 0x00	; 0
    8a86:	20 e0       	ldi	r18, 0x00	; 0
    8a88:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    8a8c:	81 30       	cpi	r24, 0x01	; 1
    8a8e:	79 f3       	breq	.-34     	; 0x8a6e <flushUdpQueues+0x2c>
    {
      data++;
      len++;
    }
    udpSend(len);
    8a90:	c8 01       	movw	r24, r16
    8a92:	0e 94 be 44 	call	0x897c	; 0x897c <udpSend>
  }
}
    8a96:	df 91       	pop	r29
    8a98:	cf 91       	pop	r28
    8a9a:	1f 91       	pop	r17
    8a9c:	0f 91       	pop	r16
    8a9e:	08 95       	ret

00008aa0 <udpInit>:
static uint32_t udpIpDst_eep   __attribute__((section (".eeprom"))) = ((uint32_t)UDP_DST_IP4   << 24) + ((uint32_t)UDP_DST_IP3   <<16) + ((uint32_t)UDP_DST_IP2   <<8) + UDP_DST_IP1;
static uint16_t udpPortDstEep  __attribute__((section (".eeprom"))) = HTONS(UDP_DST_PORT);
static uint16_t udpPortSrcEep  __attribute__((section (".eeprom"))) = HTONS(UDP_SRC_PORT);

void udpInit(void)
{
    8aa0:	0f 93       	push	r16
    8aa2:	1f 93       	push	r17
#if UDP_DEBUG
  udpDbgStream         = NULL;
    8aa4:	10 92 da 0e 	sts	0x0EDA, r1
    8aa8:	10 92 d9 0e 	sts	0x0ED9, r1
  udpDbgLevel          = 0;
    8aac:	10 92 94 0e 	sts	0x0E94, r1
#endif
  udpSocket = xmalloc(sizeof(UdpSocket_t));
    8ab0:	8e e0       	ldi	r24, 0x0E	; 14
    8ab2:	90 e0       	ldi	r25, 0x00	; 0
    8ab4:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    8ab8:	8c 01       	movw	r16, r24
    8aba:	90 93 ba 0e 	sts	0x0EBA, r25
    8abe:	80 93 b9 0e 	sts	0x0EB9, r24

  udpSocket->dstIp      = eeprom_read_dword(&udpIpDst_eep);
    8ac2:	8a e2       	ldi	r24, 0x2A	; 42
    8ac4:	90 e0       	ldi	r25, 0x00	; 0
    8ac6:	0e 94 d3 77 	call	0xefa6	; 0xefa6 <__eerd_dword_m128>
    8aca:	f8 01       	movw	r30, r16
    8acc:	66 83       	std	Z+6, r22	; 0x06
    8ace:	77 83       	std	Z+7, r23	; 0x07
    8ad0:	80 87       	std	Z+8, r24	; 0x08
    8ad2:	91 87       	std	Z+9, r25	; 0x09
  udpSocket->dstPortDef = eeprom_read_word(&udpPortDstEep);;
    8ad4:	8e e2       	ldi	r24, 0x2E	; 46
    8ad6:	90 e0       	ldi	r25, 0x00	; 0
    8ad8:	0e 94 d9 77 	call	0xefb2	; 0xefb2 <__eerd_word_m128>
    8adc:	f8 01       	movw	r30, r16
    8ade:	91 83       	std	Z+1, r25	; 0x01
    8ae0:	80 83       	st	Z, r24
  udpSocket->srcPort    = eeprom_read_word(&udpPortSrcEep);
    8ae2:	80 e3       	ldi	r24, 0x30	; 48
    8ae4:	90 e0       	ldi	r25, 0x00	; 0
    8ae6:	0e 94 d9 77 	call	0xefb2	; 0xefb2 <__eerd_word_m128>
    8aea:	f8 01       	movw	r30, r16
    8aec:	95 83       	std	Z+5, r25	; 0x05
    8aee:	84 83       	std	Z+4, r24	; 0x04
  
  udpSocket->Rx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_RX_BUF_ADDR));
    8af0:	8f ef       	ldi	r24, 0xFF	; 255
    8af2:	61 e0       	ldi	r22, 0x01	; 1
    8af4:	40 e0       	ldi	r20, 0x00	; 0
    8af6:	59 e7       	ldi	r21, 0x79	; 121
    8af8:	0e 94 3b 6d 	call	0xda76	; 0xda76 <xQueueCreateExternal>
    8afc:	f8 01       	movw	r30, r16
    8afe:	93 87       	std	Z+11, r25	; 0x0b
    8b00:	82 87       	std	Z+10, r24	; 0x0a
  udpSocket->Tx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_TX_BUF_ADDR));
    8b02:	00 91 b9 0e 	lds	r16, 0x0EB9
    8b06:	10 91 ba 0e 	lds	r17, 0x0EBA
    8b0a:	8f ef       	ldi	r24, 0xFF	; 255
    8b0c:	61 e0       	ldi	r22, 0x01	; 1
    8b0e:	40 e0       	ldi	r20, 0x00	; 0
    8b10:	58 e7       	ldi	r21, 0x78	; 120
    8b12:	0e 94 3b 6d 	call	0xda76	; 0xda76 <xQueueCreateExternal>
    8b16:	f8 01       	movw	r30, r16
    8b18:	95 87       	std	Z+13, r25	; 0x0d
    8b1a:	84 87       	std	Z+12, r24	; 0x0c
}
    8b1c:	1f 91       	pop	r17
    8b1e:	0f 91       	pop	r16
    8b20:	08 95       	ret

00008b22 <ipv6Init>:
void ipv6Init(void)
{
  //Ipv6MyConfig.ip = xmalloc(sizeof(uip_ip6addr_t));
  //Ipv6MyConfig.prefix= 64;
  //Ipv6MyConfig.gateway = xmalloc(sizeof(uip_ip6addr_t));
}
    8b22:	08 95       	ret

00008b24 <ipv6DebugInit>:
    */
}

void ipv6DebugInit(FILE* inDebugStream)
{
  debugStream = inDebugStream;
    8b24:	90 93 65 0f 	sts	0x0F65, r25
    8b28:	80 93 64 0f 	sts	0x0F64, r24
}
    8b2c:	08 95       	ret

00008b2e <checkPacketLen>:

uint8_t checkPacketLen()
{
  // 1 - packet ok, 0 - wrong length
  if(plen <= (UIP_IP_BUF->len[0] << 8) + UIP_IP_BUF->len[1])
    8b2e:	e0 91 9d 0e 	lds	r30, 0x0E9D
    8b32:	f0 91 9e 0e 	lds	r31, 0x0E9E
    8b36:	3e 96       	adiw	r30, 0x0e	; 14
    8b38:	40 e0       	ldi	r20, 0x00	; 0
    8b3a:	94 81       	ldd	r25, Z+4	; 0x04
    8b3c:	80 e0       	ldi	r24, 0x00	; 0
    8b3e:	25 81       	ldd	r18, Z+5	; 0x05
    8b40:	82 0f       	add	r24, r18
    8b42:	91 1d       	adc	r25, r1
    8b44:	20 91 c8 0e 	lds	r18, 0x0EC8
    8b48:	30 91 c9 0e 	lds	r19, 0x0EC9
    8b4c:	82 17       	cp	r24, r18
    8b4e:	93 07       	cpc	r25, r19
    8b50:	08 f4       	brcc	.+2      	; 0x8b54 <checkPacketLen+0x26>
    8b52:	41 e0       	ldi	r20, 0x01	; 1
    return 0;
  else
    return 1;
  
}
    8b54:	84 2f       	mov	r24, r20
    8b56:	08 95       	ret

00008b58 <ipv6PrintConfig>:
  }
  fprintf_P(stream, PSTR("\r\n")); 
}

void ipv6PrintConfig(FILE *stream, struct uip_netif* config)
{
    8b58:	0f 93       	push	r16
    8b5a:	1f 93       	push	r17
    8b5c:	cf 93       	push	r28
    8b5e:	df 93       	push	r29
    8b60:	8c 01       	movw	r16, r24
    8b62:	eb 01       	movw	r28, r22
  //Currently not all settings are printed
  fprintf_P(stream, PSTR("*Interface IPv6 config:\n\r"));
    8b64:	00 d0       	rcall	.+0      	; 0x8b66 <ipv6PrintConfig+0xe>
    8b66:	00 d0       	rcall	.+0      	; 0x8b68 <ipv6PrintConfig+0x10>
    8b68:	ad b7       	in	r26, 0x3d	; 61
    8b6a:	be b7       	in	r27, 0x3e	; 62
    8b6c:	12 96       	adiw	r26, 0x02	; 2
    8b6e:	9c 93       	st	X, r25
    8b70:	8e 93       	st	-X, r24
    8b72:	11 97       	sbiw	r26, 0x01	; 1
    8b74:	86 e0       	ldi	r24, 0x06	; 6
    8b76:	94 e1       	ldi	r25, 0x14	; 20
    8b78:	14 96       	adiw	r26, 0x04	; 4
    8b7a:	9c 93       	st	X, r25
    8b7c:	8e 93       	st	-X, r24
    8b7e:	13 97       	sbiw	r26, 0x03	; 3
    8b80:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  uint8_t i;
  fprintf_P(stream, PSTR("\tAddresses:\n\r"));
    8b84:	ed b7       	in	r30, 0x3d	; 61
    8b86:	fe b7       	in	r31, 0x3e	; 62
    8b88:	12 83       	std	Z+2, r17	; 0x02
    8b8a:	01 83       	std	Z+1, r16	; 0x01
    8b8c:	88 ef       	ldi	r24, 0xF8	; 248
    8b8e:	93 e1       	ldi	r25, 0x13	; 19
    8b90:	94 83       	std	Z+4, r25	; 0x04
    8b92:	83 83       	std	Z+3, r24	; 0x03
    8b94:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  for(i = 0; i < UIP_CONF_NETIF_MAX_ADDRESSES; i ++)
    if(config->addresses[i].state != NOT_USED)
    8b98:	0f 90       	pop	r0
    8b9a:	0f 90       	pop	r0
    8b9c:	0f 90       	pop	r0
    8b9e:	0f 90       	pop	r0
    8ba0:	8a a1       	ldd	r24, Y+34	; 0x22
    8ba2:	8f 3f       	cpi	r24, 0xFF	; 255
    8ba4:	09 f4       	brne	.+2      	; 0x8ba8 <ipv6PrintConfig+0x50>
    8ba6:	61 c0       	rjmp	.+194    	; 0x8c6a <ipv6PrintConfig+0x112>
    {
      fprintf_P(stream, PSTR("\tAddress %d:\t\t"), i);
    8ba8:	00 d0       	rcall	.+0      	; 0x8baa <ipv6PrintConfig+0x52>
    8baa:	00 d0       	rcall	.+0      	; 0x8bac <ipv6PrintConfig+0x54>
    8bac:	00 d0       	rcall	.+0      	; 0x8bae <ipv6PrintConfig+0x56>
    8bae:	ed b7       	in	r30, 0x3d	; 61
    8bb0:	fe b7       	in	r31, 0x3e	; 62
    8bb2:	31 96       	adiw	r30, 0x01	; 1
    8bb4:	ad b7       	in	r26, 0x3d	; 61
    8bb6:	be b7       	in	r27, 0x3e	; 62
    8bb8:	12 96       	adiw	r26, 0x02	; 2
    8bba:	1c 93       	st	X, r17
    8bbc:	0e 93       	st	-X, r16
    8bbe:	11 97       	sbiw	r26, 0x01	; 1
    8bc0:	89 ee       	ldi	r24, 0xE9	; 233
    8bc2:	93 e1       	ldi	r25, 0x13	; 19
    8bc4:	93 83       	std	Z+3, r25	; 0x03
    8bc6:	82 83       	std	Z+2, r24	; 0x02
    8bc8:	15 82       	std	Z+5, r1	; 0x05
    8bca:	14 82       	std	Z+4, r1	; 0x04
    8bcc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      PRINT6ADDR(stream, &config->addresses[i].ipaddr);    
    8bd0:	ed b7       	in	r30, 0x3d	; 61
    8bd2:	fe b7       	in	r31, 0x3e	; 62
    8bd4:	7e 97       	sbiw	r30, 0x1e	; 30
    8bd6:	0f b6       	in	r0, 0x3f	; 63
    8bd8:	f8 94       	cli
    8bda:	fe bf       	out	0x3e, r31	; 62
    8bdc:	0f be       	out	0x3f, r0	; 63
    8bde:	ed bf       	out	0x3d, r30	; 61
    8be0:	31 96       	adiw	r30, 0x01	; 1
    8be2:	ad b7       	in	r26, 0x3d	; 61
    8be4:	be b7       	in	r27, 0x3e	; 62
    8be6:	12 96       	adiw	r26, 0x02	; 2
    8be8:	1c 93       	st	X, r17
    8bea:	0e 93       	st	-X, r16
    8bec:	11 97       	sbiw	r26, 0x01	; 1
    8bee:	82 e9       	ldi	r24, 0x92	; 146
    8bf0:	93 e1       	ldi	r25, 0x13	; 19
    8bf2:	93 83       	std	Z+3, r25	; 0x03
    8bf4:	82 83       	std	Z+2, r24	; 0x02
    8bf6:	8a 89       	ldd	r24, Y+18	; 0x12
    8bf8:	84 83       	std	Z+4, r24	; 0x04
    8bfa:	15 82       	std	Z+5, r1	; 0x05
    8bfc:	8b 89       	ldd	r24, Y+19	; 0x13
    8bfe:	86 83       	std	Z+6, r24	; 0x06
    8c00:	17 82       	std	Z+7, r1	; 0x07
    8c02:	8c 89       	ldd	r24, Y+20	; 0x14
    8c04:	80 87       	std	Z+8, r24	; 0x08
    8c06:	11 86       	std	Z+9, r1	; 0x09
    8c08:	8d 89       	ldd	r24, Y+21	; 0x15
    8c0a:	82 87       	std	Z+10, r24	; 0x0a
    8c0c:	13 86       	std	Z+11, r1	; 0x0b
    8c0e:	8e 89       	ldd	r24, Y+22	; 0x16
    8c10:	84 87       	std	Z+12, r24	; 0x0c
    8c12:	15 86       	std	Z+13, r1	; 0x0d
    8c14:	8f 89       	ldd	r24, Y+23	; 0x17
    8c16:	86 87       	std	Z+14, r24	; 0x0e
    8c18:	17 86       	std	Z+15, r1	; 0x0f
    8c1a:	88 8d       	ldd	r24, Y+24	; 0x18
    8c1c:	80 8b       	std	Z+16, r24	; 0x10
    8c1e:	11 8a       	std	Z+17, r1	; 0x11
    8c20:	89 8d       	ldd	r24, Y+25	; 0x19
    8c22:	82 8b       	std	Z+18, r24	; 0x12
    8c24:	13 8a       	std	Z+19, r1	; 0x13
    8c26:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8c28:	84 8b       	std	Z+20, r24	; 0x14
    8c2a:	15 8a       	std	Z+21, r1	; 0x15
    8c2c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8c2e:	86 8b       	std	Z+22, r24	; 0x16
    8c30:	17 8a       	std	Z+23, r1	; 0x17
    8c32:	8c 8d       	ldd	r24, Y+28	; 0x1c
    8c34:	80 8f       	std	Z+24, r24	; 0x18
    8c36:	11 8e       	std	Z+25, r1	; 0x19
    8c38:	8d 8d       	ldd	r24, Y+29	; 0x1d
    8c3a:	82 8f       	std	Z+26, r24	; 0x1a
    8c3c:	13 8e       	std	Z+27, r1	; 0x1b
    8c3e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    8c40:	84 8f       	std	Z+28, r24	; 0x1c
    8c42:	15 8e       	std	Z+29, r1	; 0x1d
    8c44:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8c46:	86 8f       	std	Z+30, r24	; 0x1e
    8c48:	17 8e       	std	Z+31, r1	; 0x1f
    8c4a:	88 a1       	ldd	r24, Y+32	; 0x20
    8c4c:	80 a3       	std	Z+32, r24	; 0x20
    8c4e:	11 a2       	std	Z+33, r1	; 0x21
    8c50:	89 a1       	ldd	r24, Y+33	; 0x21
    8c52:	82 a3       	std	Z+34, r24	; 0x22
    8c54:	13 a2       	std	Z+35, r1	; 0x23
    8c56:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8c5a:	ed b7       	in	r30, 0x3d	; 61
    8c5c:	fe b7       	in	r31, 0x3e	; 62
    8c5e:	b4 96       	adiw	r30, 0x24	; 36
    8c60:	0f b6       	in	r0, 0x3f	; 63
    8c62:	f8 94       	cli
    8c64:	fe bf       	out	0x3e, r31	; 62
    8c66:	0f be       	out	0x3f, r0	; 63
    8c68:	ed bf       	out	0x3d, r30	; 61
  //Currently not all settings are printed
  fprintf_P(stream, PSTR("*Interface IPv6 config:\n\r"));
  uint8_t i;
  fprintf_P(stream, PSTR("\tAddresses:\n\r"));
  for(i = 0; i < UIP_CONF_NETIF_MAX_ADDRESSES; i ++)
    if(config->addresses[i].state != NOT_USED)
    8c6a:	8d a9       	ldd	r24, Y+53	; 0x35
    8c6c:	8f 3f       	cpi	r24, 0xFF	; 255
    8c6e:	09 f4       	brne	.+2      	; 0x8c72 <ipv6PrintConfig+0x11a>
    8c70:	63 c0       	rjmp	.+198    	; 0x8d38 <ipv6PrintConfig+0x1e0>
    {
      fprintf_P(stream, PSTR("\tAddress %d:\t\t"), i);
    8c72:	00 d0       	rcall	.+0      	; 0x8c74 <ipv6PrintConfig+0x11c>
    8c74:	00 d0       	rcall	.+0      	; 0x8c76 <ipv6PrintConfig+0x11e>
    8c76:	00 d0       	rcall	.+0      	; 0x8c78 <ipv6PrintConfig+0x120>
    8c78:	ed b7       	in	r30, 0x3d	; 61
    8c7a:	fe b7       	in	r31, 0x3e	; 62
    8c7c:	31 96       	adiw	r30, 0x01	; 1
    8c7e:	ad b7       	in	r26, 0x3d	; 61
    8c80:	be b7       	in	r27, 0x3e	; 62
    8c82:	12 96       	adiw	r26, 0x02	; 2
    8c84:	1c 93       	st	X, r17
    8c86:	0e 93       	st	-X, r16
    8c88:	11 97       	sbiw	r26, 0x01	; 1
    8c8a:	89 ee       	ldi	r24, 0xE9	; 233
    8c8c:	93 e1       	ldi	r25, 0x13	; 19
    8c8e:	93 83       	std	Z+3, r25	; 0x03
    8c90:	82 83       	std	Z+2, r24	; 0x02
    8c92:	81 e0       	ldi	r24, 0x01	; 1
    8c94:	90 e0       	ldi	r25, 0x00	; 0
    8c96:	95 83       	std	Z+5, r25	; 0x05
    8c98:	84 83       	std	Z+4, r24	; 0x04
    8c9a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      PRINT6ADDR(stream, &config->addresses[i].ipaddr);    
    8c9e:	ed b7       	in	r30, 0x3d	; 61
    8ca0:	fe b7       	in	r31, 0x3e	; 62
    8ca2:	7e 97       	sbiw	r30, 0x1e	; 30
    8ca4:	0f b6       	in	r0, 0x3f	; 63
    8ca6:	f8 94       	cli
    8ca8:	fe bf       	out	0x3e, r31	; 62
    8caa:	0f be       	out	0x3f, r0	; 63
    8cac:	ed bf       	out	0x3d, r30	; 61
    8cae:	31 96       	adiw	r30, 0x01	; 1
    8cb0:	ad b7       	in	r26, 0x3d	; 61
    8cb2:	be b7       	in	r27, 0x3e	; 62
    8cb4:	12 96       	adiw	r26, 0x02	; 2
    8cb6:	1c 93       	st	X, r17
    8cb8:	0e 93       	st	-X, r16
    8cba:	11 97       	sbiw	r26, 0x01	; 1
    8cbc:	82 e9       	ldi	r24, 0x92	; 146
    8cbe:	93 e1       	ldi	r25, 0x13	; 19
    8cc0:	93 83       	std	Z+3, r25	; 0x03
    8cc2:	82 83       	std	Z+2, r24	; 0x02
    8cc4:	8d a1       	ldd	r24, Y+37	; 0x25
    8cc6:	84 83       	std	Z+4, r24	; 0x04
    8cc8:	15 82       	std	Z+5, r1	; 0x05
    8cca:	8e a1       	ldd	r24, Y+38	; 0x26
    8ccc:	86 83       	std	Z+6, r24	; 0x06
    8cce:	17 82       	std	Z+7, r1	; 0x07
    8cd0:	8f a1       	ldd	r24, Y+39	; 0x27
    8cd2:	80 87       	std	Z+8, r24	; 0x08
    8cd4:	11 86       	std	Z+9, r1	; 0x09
    8cd6:	88 a5       	ldd	r24, Y+40	; 0x28
    8cd8:	82 87       	std	Z+10, r24	; 0x0a
    8cda:	13 86       	std	Z+11, r1	; 0x0b
    8cdc:	89 a5       	ldd	r24, Y+41	; 0x29
    8cde:	84 87       	std	Z+12, r24	; 0x0c
    8ce0:	15 86       	std	Z+13, r1	; 0x0d
    8ce2:	8a a5       	ldd	r24, Y+42	; 0x2a
    8ce4:	86 87       	std	Z+14, r24	; 0x0e
    8ce6:	17 86       	std	Z+15, r1	; 0x0f
    8ce8:	8b a5       	ldd	r24, Y+43	; 0x2b
    8cea:	80 8b       	std	Z+16, r24	; 0x10
    8cec:	11 8a       	std	Z+17, r1	; 0x11
    8cee:	8c a5       	ldd	r24, Y+44	; 0x2c
    8cf0:	82 8b       	std	Z+18, r24	; 0x12
    8cf2:	13 8a       	std	Z+19, r1	; 0x13
    8cf4:	8d a5       	ldd	r24, Y+45	; 0x2d
    8cf6:	84 8b       	std	Z+20, r24	; 0x14
    8cf8:	15 8a       	std	Z+21, r1	; 0x15
    8cfa:	8e a5       	ldd	r24, Y+46	; 0x2e
    8cfc:	86 8b       	std	Z+22, r24	; 0x16
    8cfe:	17 8a       	std	Z+23, r1	; 0x17
    8d00:	8f a5       	ldd	r24, Y+47	; 0x2f
    8d02:	80 8f       	std	Z+24, r24	; 0x18
    8d04:	11 8e       	std	Z+25, r1	; 0x19
    8d06:	88 a9       	ldd	r24, Y+48	; 0x30
    8d08:	82 8f       	std	Z+26, r24	; 0x1a
    8d0a:	13 8e       	std	Z+27, r1	; 0x1b
    8d0c:	89 a9       	ldd	r24, Y+49	; 0x31
    8d0e:	84 8f       	std	Z+28, r24	; 0x1c
    8d10:	15 8e       	std	Z+29, r1	; 0x1d
    8d12:	8a a9       	ldd	r24, Y+50	; 0x32
    8d14:	86 8f       	std	Z+30, r24	; 0x1e
    8d16:	17 8e       	std	Z+31, r1	; 0x1f
    8d18:	8b a9       	ldd	r24, Y+51	; 0x33
    8d1a:	80 a3       	std	Z+32, r24	; 0x20
    8d1c:	11 a2       	std	Z+33, r1	; 0x21
    8d1e:	8c a9       	ldd	r24, Y+52	; 0x34
    8d20:	82 a3       	std	Z+34, r24	; 0x22
    8d22:	13 a2       	std	Z+35, r1	; 0x23
    8d24:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8d28:	ed b7       	in	r30, 0x3d	; 61
    8d2a:	fe b7       	in	r31, 0x3e	; 62
    8d2c:	b4 96       	adiw	r30, 0x24	; 36
    8d2e:	0f b6       	in	r0, 0x3f	; 63
    8d30:	f8 94       	cli
    8d32:	fe bf       	out	0x3e, r31	; 62
    8d34:	0f be       	out	0x3f, r0	; 63
    8d36:	ed bf       	out	0x3d, r30	; 61
    }
  fprintf_P(stream, PSTR("\tSolicited node mcast address:"));
    8d38:	00 d0       	rcall	.+0      	; 0x8d3a <ipv6PrintConfig+0x1e2>
    8d3a:	00 d0       	rcall	.+0      	; 0x8d3c <ipv6PrintConfig+0x1e4>
    8d3c:	ad b7       	in	r26, 0x3d	; 61
    8d3e:	be b7       	in	r27, 0x3e	; 62
    8d40:	12 96       	adiw	r26, 0x02	; 2
    8d42:	1c 93       	st	X, r17
    8d44:	0e 93       	st	-X, r16
    8d46:	11 97       	sbiw	r26, 0x01	; 1
    8d48:	83 e7       	ldi	r24, 0x73	; 115
    8d4a:	93 e1       	ldi	r25, 0x13	; 19
    8d4c:	14 96       	adiw	r26, 0x04	; 4
    8d4e:	9c 93       	st	X, r25
    8d50:	8e 93       	st	-X, r24
    8d52:	13 97       	sbiw	r26, 0x03	; 3
    8d54:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINT6ADDR(stream, &config->solicited_node_mcastaddr);    
    8d58:	ed b7       	in	r30, 0x3d	; 61
    8d5a:	fe b7       	in	r31, 0x3e	; 62
    8d5c:	b0 97       	sbiw	r30, 0x20	; 32
    8d5e:	0f b6       	in	r0, 0x3f	; 63
    8d60:	f8 94       	cli
    8d62:	fe bf       	out	0x3e, r31	; 62
    8d64:	0f be       	out	0x3f, r0	; 63
    8d66:	ed bf       	out	0x3d, r30	; 61
    8d68:	31 96       	adiw	r30, 0x01	; 1
    8d6a:	ad b7       	in	r26, 0x3d	; 61
    8d6c:	be b7       	in	r27, 0x3e	; 62
    8d6e:	12 96       	adiw	r26, 0x02	; 2
    8d70:	1c 93       	st	X, r17
    8d72:	0e 93       	st	-X, r16
    8d74:	11 97       	sbiw	r26, 0x01	; 1
    8d76:	8c e1       	ldi	r24, 0x1C	; 28
    8d78:	93 e1       	ldi	r25, 0x13	; 19
    8d7a:	93 83       	std	Z+3, r25	; 0x03
    8d7c:	82 83       	std	Z+2, r24	; 0x02
    8d7e:	88 ad       	ldd	r24, Y+56	; 0x38
    8d80:	84 83       	std	Z+4, r24	; 0x04
    8d82:	15 82       	std	Z+5, r1	; 0x05
    8d84:	89 ad       	ldd	r24, Y+57	; 0x39
    8d86:	86 83       	std	Z+6, r24	; 0x06
    8d88:	17 82       	std	Z+7, r1	; 0x07
    8d8a:	8a ad       	ldd	r24, Y+58	; 0x3a
    8d8c:	80 87       	std	Z+8, r24	; 0x08
    8d8e:	11 86       	std	Z+9, r1	; 0x09
    8d90:	8b ad       	ldd	r24, Y+59	; 0x3b
    8d92:	82 87       	std	Z+10, r24	; 0x0a
    8d94:	13 86       	std	Z+11, r1	; 0x0b
    8d96:	8c ad       	ldd	r24, Y+60	; 0x3c
    8d98:	84 87       	std	Z+12, r24	; 0x0c
    8d9a:	15 86       	std	Z+13, r1	; 0x0d
    8d9c:	8d ad       	ldd	r24, Y+61	; 0x3d
    8d9e:	86 87       	std	Z+14, r24	; 0x0e
    8da0:	17 86       	std	Z+15, r1	; 0x0f
    8da2:	8e ad       	ldd	r24, Y+62	; 0x3e
    8da4:	80 8b       	std	Z+16, r24	; 0x10
    8da6:	11 8a       	std	Z+17, r1	; 0x11
    8da8:	8f ad       	ldd	r24, Y+63	; 0x3f
    8daa:	82 8b       	std	Z+18, r24	; 0x12
    8dac:	13 8a       	std	Z+19, r1	; 0x13
    8dae:	c0 5c       	subi	r28, 0xC0	; 192
    8db0:	df 4f       	sbci	r29, 0xFF	; 255
    8db2:	89 91       	ld	r24, Y+
    8db4:	84 8b       	std	Z+20, r24	; 0x14
    8db6:	15 8a       	std	Z+21, r1	; 0x15
    8db8:	89 91       	ld	r24, Y+
    8dba:	86 8b       	std	Z+22, r24	; 0x16
    8dbc:	17 8a       	std	Z+23, r1	; 0x17
    8dbe:	89 91       	ld	r24, Y+
    8dc0:	80 8f       	std	Z+24, r24	; 0x18
    8dc2:	11 8e       	std	Z+25, r1	; 0x19
    8dc4:	89 91       	ld	r24, Y+
    8dc6:	82 8f       	std	Z+26, r24	; 0x1a
    8dc8:	13 8e       	std	Z+27, r1	; 0x1b
    8dca:	89 91       	ld	r24, Y+
    8dcc:	84 8f       	std	Z+28, r24	; 0x1c
    8dce:	15 8e       	std	Z+29, r1	; 0x1d
    8dd0:	89 91       	ld	r24, Y+
    8dd2:	86 8f       	std	Z+30, r24	; 0x1e
    8dd4:	17 8e       	std	Z+31, r1	; 0x1f
    8dd6:	89 91       	ld	r24, Y+
    8dd8:	80 a3       	std	Z+32, r24	; 0x20
    8dda:	11 a2       	std	Z+33, r1	; 0x21
    8ddc:	88 81       	ld	r24, Y
    8dde:	82 a3       	std	Z+34, r24	; 0x22
    8de0:	13 a2       	std	Z+35, r1	; 0x23
    8de2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8de6:	ed b7       	in	r30, 0x3d	; 61
    8de8:	fe b7       	in	r31, 0x3e	; 62
    8dea:	b4 96       	adiw	r30, 0x24	; 36
    8dec:	0f b6       	in	r0, 0x3f	; 63
    8dee:	f8 94       	cli
    8df0:	fe bf       	out	0x3e, r31	; 62
    8df2:	0f be       	out	0x3f, r0	; 63
    8df4:	ed bf       	out	0x3d, r30	; 61
}
    8df6:	df 91       	pop	r29
    8df8:	cf 91       	pop	r28
    8dfa:	1f 91       	pop	r17
    8dfc:	0f 91       	pop	r16
    8dfe:	08 95       	ret

00008e00 <netPrintIpv6PayloadRAW>:
    fprintf_P(stream, PSTR("\tDestination address: \t"));
    PRINT6ADDR(stream, &nicState.layer3.ipv6->destipaddr);
}

void netPrintIpv6PayloadRAW(FILE *stream)
{
    8e00:	6f 92       	push	r6
    8e02:	7f 92       	push	r7
    8e04:	8f 92       	push	r8
    8e06:	9f 92       	push	r9
    8e08:	af 92       	push	r10
    8e0a:	bf 92       	push	r11
    8e0c:	cf 92       	push	r12
    8e0e:	df 92       	push	r13
    8e10:	ff 92       	push	r15
    8e12:	0f 93       	push	r16
    8e14:	1f 93       	push	r17
    8e16:	cf 93       	push	r28
    8e18:	df 93       	push	r29
    8e1a:	8c 01       	movw	r16, r24
  uint16_t payloadLen=nicState.layer3.ipv6->len[1] + (nicState.layer3.ipv6->len[0] << 8);
    8e1c:	e0 91 9f 0e 	lds	r30, 0x0E9F
    8e20:	f0 91 a0 0e 	lds	r31, 0x0EA0
    8e24:	94 81       	ldd	r25, Z+4	; 0x04
    8e26:	80 e0       	ldi	r24, 0x00	; 0
    8e28:	25 81       	ldd	r18, Z+5	; 0x05
    8e2a:	6c 01       	movw	r12, r24
    8e2c:	c2 0e       	add	r12, r18
    8e2e:	d1 1c       	adc	r13, r1
  fprintf_P(stream, PSTR("*IPv6 Payload RAW:\r\n"));
    8e30:	00 d0       	rcall	.+0      	; 0x8e32 <netPrintIpv6PayloadRAW+0x32>
    8e32:	00 d0       	rcall	.+0      	; 0x8e34 <netPrintIpv6PayloadRAW+0x34>
    8e34:	ad b7       	in	r26, 0x3d	; 61
    8e36:	be b7       	in	r27, 0x3e	; 62
    8e38:	12 96       	adiw	r26, 0x02	; 2
    8e3a:	1c 93       	st	X, r17
    8e3c:	0e 93       	st	-X, r16
    8e3e:	11 97       	sbiw	r26, 0x01	; 1
    8e40:	80 e3       	ldi	r24, 0x30	; 48
    8e42:	94 e1       	ldi	r25, 0x14	; 20
    8e44:	14 96       	adiw	r26, 0x04	; 4
    8e46:	9c 93       	st	X, r25
    8e48:	8e 93       	st	-X, r24
    8e4a:	13 97       	sbiw	r26, 0x03	; 3
    8e4c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("\t"));    
    8e50:	ed b7       	in	r30, 0x3d	; 61
    8e52:	fe b7       	in	r31, 0x3e	; 62
    8e54:	12 83       	std	Z+2, r17	; 0x02
    8e56:	01 83       	std	Z+1, r16	; 0x01
    8e58:	8e e2       	ldi	r24, 0x2E	; 46
    8e5a:	94 e1       	ldi	r25, 0x14	; 20
    8e5c:	94 83       	std	Z+4, r25	; 0x04
    8e5e:	83 83       	std	Z+3, r24	; 0x03
    8e60:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8e64:	ff 24       	eor	r15, r15
    8e66:	0f 90       	pop	r0
    8e68:	0f 90       	pop	r0
    8e6a:	0f 90       	pop	r0
    8e6c:	0f 90       	pop	r0
  for (uint8_t i=0; i <  payloadLen; i++)
  {
    if (i!=0 && i%16==0) 
    {
      fprintf_P(stream, PSTR("\r\n"));
    8e6e:	2b e2       	ldi	r18, 0x2B	; 43
    8e70:	62 2e       	mov	r6, r18
    8e72:	24 e1       	ldi	r18, 0x14	; 20
    8e74:	72 2e       	mov	r7, r18
      fprintf_P(stream, PSTR("\t"));
    8e76:	99 e2       	ldi	r25, 0x29	; 41
    8e78:	89 2e       	mov	r8, r25
    8e7a:	94 e1       	ldi	r25, 0x14	; 20
    8e7c:	99 2e       	mov	r9, r25
    }
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i + UIP_IPv6H_LEN]);
    8e7e:	83 e2       	ldi	r24, 0x23	; 35
    8e80:	a8 2e       	mov	r10, r24
    8e82:	84 e1       	ldi	r24, 0x14	; 20
    8e84:	b8 2e       	mov	r11, r24
    8e86:	44 c0       	rjmp	.+136    	; 0x8f10 <netPrintIpv6PayloadRAW+0x110>
  uint16_t payloadLen=nicState.layer3.ipv6->len[1] + (nicState.layer3.ipv6->len[0] << 8);
  fprintf_P(stream, PSTR("*IPv6 Payload RAW:\r\n"));
  fprintf_P(stream, PSTR("\t"));    
  for (uint8_t i=0; i <  payloadLen; i++)
  {
    if (i!=0 && i%16==0) 
    8e88:	ff 20       	and	r15, r15
    8e8a:	f9 f0       	breq	.+62     	; 0x8eca <netPrintIpv6PayloadRAW+0xca>
    8e8c:	ce 01       	movw	r24, r28
    8e8e:	8f 70       	andi	r24, 0x0F	; 15
    8e90:	90 70       	andi	r25, 0x00	; 0
    8e92:	89 2b       	or	r24, r25
    8e94:	d1 f4       	brne	.+52     	; 0x8eca <netPrintIpv6PayloadRAW+0xca>
    {
      fprintf_P(stream, PSTR("\r\n"));
    8e96:	00 d0       	rcall	.+0      	; 0x8e98 <netPrintIpv6PayloadRAW+0x98>
    8e98:	00 d0       	rcall	.+0      	; 0x8e9a <netPrintIpv6PayloadRAW+0x9a>
    8e9a:	ad b7       	in	r26, 0x3d	; 61
    8e9c:	be b7       	in	r27, 0x3e	; 62
    8e9e:	12 96       	adiw	r26, 0x02	; 2
    8ea0:	1c 93       	st	X, r17
    8ea2:	0e 93       	st	-X, r16
    8ea4:	11 97       	sbiw	r26, 0x01	; 1
    8ea6:	14 96       	adiw	r26, 0x04	; 4
    8ea8:	7c 92       	st	X, r7
    8eaa:	6e 92       	st	-X, r6
    8eac:	13 97       	sbiw	r26, 0x03	; 3
    8eae:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      fprintf_P(stream, PSTR("\t"));
    8eb2:	ed b7       	in	r30, 0x3d	; 61
    8eb4:	fe b7       	in	r31, 0x3e	; 62
    8eb6:	12 83       	std	Z+2, r17	; 0x02
    8eb8:	01 83       	std	Z+1, r16	; 0x01
    8eba:	94 82       	std	Z+4, r9	; 0x04
    8ebc:	83 82       	std	Z+3, r8	; 0x03
    8ebe:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8ec2:	0f 90       	pop	r0
    8ec4:	0f 90       	pop	r0
    8ec6:	0f 90       	pop	r0
    8ec8:	0f 90       	pop	r0
    }
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i + UIP_IPv6H_LEN]);
    8eca:	00 d0       	rcall	.+0      	; 0x8ecc <netPrintIpv6PayloadRAW+0xcc>
    8ecc:	00 d0       	rcall	.+0      	; 0x8ece <netPrintIpv6PayloadRAW+0xce>
    8ece:	00 d0       	rcall	.+0      	; 0x8ed0 <netPrintIpv6PayloadRAW+0xd0>
    8ed0:	ed b7       	in	r30, 0x3d	; 61
    8ed2:	fe b7       	in	r31, 0x3e	; 62
    8ed4:	31 96       	adiw	r30, 0x01	; 1
    8ed6:	ad b7       	in	r26, 0x3d	; 61
    8ed8:	be b7       	in	r27, 0x3e	; 62
    8eda:	12 96       	adiw	r26, 0x02	; 2
    8edc:	1c 93       	st	X, r17
    8ede:	0e 93       	st	-X, r16
    8ee0:	11 97       	sbiw	r26, 0x01	; 1
    8ee2:	b3 82       	std	Z+3, r11	; 0x03
    8ee4:	a2 82       	std	Z+2, r10	; 0x02
    8ee6:	a0 91 9f 0e 	lds	r26, 0x0E9F
    8eea:	b0 91 a0 0e 	lds	r27, 0x0EA0
    8eee:	ac 0f       	add	r26, r28
    8ef0:	bd 1f       	adc	r27, r29
    8ef2:	98 96       	adiw	r26, 0x28	; 40
    8ef4:	8c 91       	ld	r24, X
    8ef6:	84 83       	std	Z+4, r24	; 0x04
    8ef8:	15 82       	std	Z+5, r1	; 0x05
    8efa:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
void netPrintIpv6PayloadRAW(FILE *stream)
{
  uint16_t payloadLen=nicState.layer3.ipv6->len[1] + (nicState.layer3.ipv6->len[0] << 8);
  fprintf_P(stream, PSTR("*IPv6 Payload RAW:\r\n"));
  fprintf_P(stream, PSTR("\t"));    
  for (uint8_t i=0; i <  payloadLen; i++)
    8efe:	f3 94       	inc	r15
    8f00:	ed b7       	in	r30, 0x3d	; 61
    8f02:	fe b7       	in	r31, 0x3e	; 62
    8f04:	36 96       	adiw	r30, 0x06	; 6
    8f06:	0f b6       	in	r0, 0x3f	; 63
    8f08:	f8 94       	cli
    8f0a:	fe bf       	out	0x3e, r31	; 62
    8f0c:	0f be       	out	0x3f, r0	; 63
    8f0e:	ed bf       	out	0x3d, r30	; 61
    8f10:	cf 2d       	mov	r28, r15
    8f12:	d0 e0       	ldi	r29, 0x00	; 0
    8f14:	cc 15       	cp	r28, r12
    8f16:	dd 05       	cpc	r29, r13
    8f18:	08 f4       	brcc	.+2      	; 0x8f1c <netPrintIpv6PayloadRAW+0x11c>
    8f1a:	b6 cf       	rjmp	.-148    	; 0x8e88 <netPrintIpv6PayloadRAW+0x88>
      fprintf_P(stream, PSTR("\r\n"));
      fprintf_P(stream, PSTR("\t"));
    }
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i + UIP_IPv6H_LEN]);
  }
  fprintf_P(stream, PSTR("\r\n")); 
    8f1c:	00 d0       	rcall	.+0      	; 0x8f1e <netPrintIpv6PayloadRAW+0x11e>
    8f1e:	00 d0       	rcall	.+0      	; 0x8f20 <netPrintIpv6PayloadRAW+0x120>
    8f20:	ad b7       	in	r26, 0x3d	; 61
    8f22:	be b7       	in	r27, 0x3e	; 62
    8f24:	12 96       	adiw	r26, 0x02	; 2
    8f26:	1c 93       	st	X, r17
    8f28:	0e 93       	st	-X, r16
    8f2a:	11 97       	sbiw	r26, 0x01	; 1
    8f2c:	80 e2       	ldi	r24, 0x20	; 32
    8f2e:	94 e1       	ldi	r25, 0x14	; 20
    8f30:	14 96       	adiw	r26, 0x04	; 4
    8f32:	9c 93       	st	X, r25
    8f34:	8e 93       	st	-X, r24
    8f36:	13 97       	sbiw	r26, 0x03	; 3
    8f38:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    8f3c:	0f 90       	pop	r0
    8f3e:	0f 90       	pop	r0
    8f40:	0f 90       	pop	r0
    8f42:	0f 90       	pop	r0
}
    8f44:	df 91       	pop	r29
    8f46:	cf 91       	pop	r28
    8f48:	1f 91       	pop	r17
    8f4a:	0f 91       	pop	r16
    8f4c:	ff 90       	pop	r15
    8f4e:	df 90       	pop	r13
    8f50:	cf 90       	pop	r12
    8f52:	bf 90       	pop	r11
    8f54:	af 90       	pop	r10
    8f56:	9f 90       	pop	r9
    8f58:	8f 90       	pop	r8
    8f5a:	7f 90       	pop	r7
    8f5c:	6f 90       	pop	r6
    8f5e:	08 95       	ret

00008f60 <netPrintIpv6Header>:
  }
  fprintf_P(stream, PSTR("\r\n")); 
}

void netPrintIpv6Header(FILE *stream)
{
    8f60:	0f 93       	push	r16
    8f62:	1f 93       	push	r17
    8f64:	cf 93       	push	r28
    8f66:	df 93       	push	r29
    8f68:	8c 01       	movw	r16, r24
    fprintf_P(stream, PSTR("*IPv6 Header:\r\n"));    
    8f6a:	00 d0       	rcall	.+0      	; 0x8f6c <netPrintIpv6Header+0xc>
    8f6c:	00 d0       	rcall	.+0      	; 0x8f6e <netPrintIpv6Header+0xe>
    8f6e:	cd b7       	in	r28, 0x3d	; 61
    8f70:	de b7       	in	r29, 0x3e	; 62
    8f72:	9a 83       	std	Y+2, r25	; 0x02
    8f74:	89 83       	std	Y+1, r24	; 0x01
    8f76:	8d e7       	ldi	r24, 0x7D	; 125
    8f78:	95 e1       	ldi	r25, 0x15	; 21
    8f7a:	9c 83       	std	Y+4, r25	; 0x04
    8f7c:	8b 83       	std	Y+3, r24	; 0x03
    8f7e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\tVersion: \t\t"));
    8f82:	ed b7       	in	r30, 0x3d	; 61
    8f84:	fe b7       	in	r31, 0x3e	; 62
    8f86:	12 83       	std	Z+2, r17	; 0x02
    8f88:	01 83       	std	Z+1, r16	; 0x01
    8f8a:	80 e7       	ldi	r24, 0x70	; 112
    8f8c:	95 e1       	ldi	r25, 0x15	; 21
    8f8e:	94 83       	std	Z+4, r25	; 0x04
    8f90:	83 83       	std	Z+3, r24	; 0x03
    8f92:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\t%d \n\r"), (nicState.layer3.ipv6->vtc >> 4));
    8f96:	00 d0       	rcall	.+0      	; 0x8f98 <netPrintIpv6Header+0x38>
    8f98:	ad b7       	in	r26, 0x3d	; 61
    8f9a:	be b7       	in	r27, 0x3e	; 62
    8f9c:	11 96       	adiw	r26, 0x01	; 1
    8f9e:	cd b7       	in	r28, 0x3d	; 61
    8fa0:	de b7       	in	r29, 0x3e	; 62
    8fa2:	1a 83       	std	Y+2, r17	; 0x02
    8fa4:	09 83       	std	Y+1, r16	; 0x01
    8fa6:	89 e6       	ldi	r24, 0x69	; 105
    8fa8:	95 e1       	ldi	r25, 0x15	; 21
    8faa:	13 96       	adiw	r26, 0x03	; 3
    8fac:	9c 93       	st	X, r25
    8fae:	8e 93       	st	-X, r24
    8fb0:	12 97       	sbiw	r26, 0x02	; 2
    8fb2:	e0 91 9f 0e 	lds	r30, 0x0E9F
    8fb6:	f0 91 a0 0e 	lds	r31, 0x0EA0
    8fba:	80 81       	ld	r24, Z
    8fbc:	82 95       	swap	r24
    8fbe:	8f 70       	andi	r24, 0x0F	; 15
    8fc0:	14 96       	adiw	r26, 0x04	; 4
    8fc2:	8c 93       	st	X, r24
    8fc4:	14 97       	sbiw	r26, 0x04	; 4
    8fc6:	15 96       	adiw	r26, 0x05	; 5
    8fc8:	1c 92       	st	X, r1
    8fca:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\tTraffic Class: \t\t"));
    8fce:	0f 90       	pop	r0
    8fd0:	0f 90       	pop	r0
    8fd2:	ed b7       	in	r30, 0x3d	; 61
    8fd4:	fe b7       	in	r31, 0x3e	; 62
    8fd6:	12 83       	std	Z+2, r17	; 0x02
    8fd8:	01 83       	std	Z+1, r16	; 0x01
    8fda:	86 e5       	ldi	r24, 0x56	; 86
    8fdc:	95 e1       	ldi	r25, 0x15	; 21
    8fde:	94 83       	std	Z+4, r25	; 0x04
    8fe0:	83 83       	std	Z+3, r24	; 0x03
    8fe2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\t%d \n\r"), nicState.layer3.ipv6->vtc & 0x0F + (nicState.layer3.ipv6->tcflow >> 4));
    8fe6:	e0 91 9f 0e 	lds	r30, 0x0E9F
    8fea:	f0 91 a0 0e 	lds	r31, 0x0EA0
    8fee:	00 d0       	rcall	.+0      	; 0x8ff0 <netPrintIpv6Header+0x90>
    8ff0:	ad b7       	in	r26, 0x3d	; 61
    8ff2:	be b7       	in	r27, 0x3e	; 62
    8ff4:	11 96       	adiw	r26, 0x01	; 1
    8ff6:	cd b7       	in	r28, 0x3d	; 61
    8ff8:	de b7       	in	r29, 0x3e	; 62
    8ffa:	1a 83       	std	Y+2, r17	; 0x02
    8ffc:	09 83       	std	Y+1, r16	; 0x01
    8ffe:	8f e4       	ldi	r24, 0x4F	; 79
    9000:	95 e1       	ldi	r25, 0x15	; 21
    9002:	13 96       	adiw	r26, 0x03	; 3
    9004:	9c 93       	st	X, r25
    9006:	8e 93       	st	-X, r24
    9008:	12 97       	sbiw	r26, 0x02	; 2
    900a:	81 81       	ldd	r24, Z+1	; 0x01
    900c:	82 95       	swap	r24
    900e:	8f 70       	andi	r24, 0x0F	; 15
    9010:	90 e0       	ldi	r25, 0x00	; 0
    9012:	0f 96       	adiw	r24, 0x0f	; 15
    9014:	20 81       	ld	r18, Z
    9016:	30 e0       	ldi	r19, 0x00	; 0
    9018:	82 23       	and	r24, r18
    901a:	93 23       	and	r25, r19
    901c:	15 96       	adiw	r26, 0x05	; 5
    901e:	9c 93       	st	X, r25
    9020:	8e 93       	st	-X, r24
    9022:	14 97       	sbiw	r26, 0x04	; 4
    9024:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\tFlow Label: \t\t"));
    9028:	0f 90       	pop	r0
    902a:	0f 90       	pop	r0
    902c:	ed b7       	in	r30, 0x3d	; 61
    902e:	fe b7       	in	r31, 0x3e	; 62
    9030:	12 83       	std	Z+2, r17	; 0x02
    9032:	01 83       	std	Z+1, r16	; 0x01
    9034:	8f e3       	ldi	r24, 0x3F	; 63
    9036:	95 e1       	ldi	r25, 0x15	; 21
    9038:	94 83       	std	Z+4, r25	; 0x04
    903a:	83 83       	std	Z+3, r24	; 0x03
    903c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\t%d \n\r"), nicState.layer3.ipv6->tcflow & 0x0F + (nicState.layer3.ipv6->flow << 4));
    9040:	e0 91 9f 0e 	lds	r30, 0x0E9F
    9044:	f0 91 a0 0e 	lds	r31, 0x0EA0
    9048:	00 d0       	rcall	.+0      	; 0x904a <netPrintIpv6Header+0xea>
    904a:	ad b7       	in	r26, 0x3d	; 61
    904c:	be b7       	in	r27, 0x3e	; 62
    904e:	11 96       	adiw	r26, 0x01	; 1
    9050:	cd b7       	in	r28, 0x3d	; 61
    9052:	de b7       	in	r29, 0x3e	; 62
    9054:	1a 83       	std	Y+2, r17	; 0x02
    9056:	09 83       	std	Y+1, r16	; 0x01
    9058:	88 e3       	ldi	r24, 0x38	; 56
    905a:	95 e1       	ldi	r25, 0x15	; 21
    905c:	13 96       	adiw	r26, 0x03	; 3
    905e:	9c 93       	st	X, r25
    9060:	8e 93       	st	-X, r24
    9062:	12 97       	sbiw	r26, 0x02	; 2
    9064:	82 81       	ldd	r24, Z+2	; 0x02
    9066:	93 81       	ldd	r25, Z+3	; 0x03
    9068:	34 e0       	ldi	r19, 0x04	; 4
    906a:	88 0f       	add	r24, r24
    906c:	99 1f       	adc	r25, r25
    906e:	3a 95       	dec	r19
    9070:	e1 f7       	brne	.-8      	; 0x906a <netPrintIpv6Header+0x10a>
    9072:	0f 96       	adiw	r24, 0x0f	; 15
    9074:	21 81       	ldd	r18, Z+1	; 0x01
    9076:	30 e0       	ldi	r19, 0x00	; 0
    9078:	82 23       	and	r24, r18
    907a:	93 23       	and	r25, r19
    907c:	15 96       	adiw	r26, 0x05	; 5
    907e:	9c 93       	st	X, r25
    9080:	8e 93       	st	-X, r24
    9082:	14 97       	sbiw	r26, 0x04	; 4
    9084:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\tPayload Length: \t"));
    9088:	0f 90       	pop	r0
    908a:	0f 90       	pop	r0
    908c:	ed b7       	in	r30, 0x3d	; 61
    908e:	fe b7       	in	r31, 0x3e	; 62
    9090:	12 83       	std	Z+2, r17	; 0x02
    9092:	01 83       	std	Z+1, r16	; 0x01
    9094:	85 e2       	ldi	r24, 0x25	; 37
    9096:	95 e1       	ldi	r25, 0x15	; 21
    9098:	94 83       	std	Z+4, r25	; 0x04
    909a:	83 83       	std	Z+3, r24	; 0x03
    909c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\t%d \n\r"), nicState.layer3.ipv6->len[1] + (nicState.layer3.ipv6->len[0] << 8));
    90a0:	e0 91 9f 0e 	lds	r30, 0x0E9F
    90a4:	f0 91 a0 0e 	lds	r31, 0x0EA0
    90a8:	00 d0       	rcall	.+0      	; 0x90aa <netPrintIpv6Header+0x14a>
    90aa:	ad b7       	in	r26, 0x3d	; 61
    90ac:	be b7       	in	r27, 0x3e	; 62
    90ae:	11 96       	adiw	r26, 0x01	; 1
    90b0:	cd b7       	in	r28, 0x3d	; 61
    90b2:	de b7       	in	r29, 0x3e	; 62
    90b4:	1a 83       	std	Y+2, r17	; 0x02
    90b6:	09 83       	std	Y+1, r16	; 0x01
    90b8:	8e e1       	ldi	r24, 0x1E	; 30
    90ba:	95 e1       	ldi	r25, 0x15	; 21
    90bc:	13 96       	adiw	r26, 0x03	; 3
    90be:	9c 93       	st	X, r25
    90c0:	8e 93       	st	-X, r24
    90c2:	12 97       	sbiw	r26, 0x02	; 2
    90c4:	94 81       	ldd	r25, Z+4	; 0x04
    90c6:	80 e0       	ldi	r24, 0x00	; 0
    90c8:	25 81       	ldd	r18, Z+5	; 0x05
    90ca:	82 0f       	add	r24, r18
    90cc:	91 1d       	adc	r25, r1
    90ce:	15 96       	adiw	r26, 0x05	; 5
    90d0:	9c 93       	st	X, r25
    90d2:	8e 93       	st	-X, r24
    90d4:	14 97       	sbiw	r26, 0x04	; 4
    90d6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\tSource address: \t"));
    90da:	0f 90       	pop	r0
    90dc:	0f 90       	pop	r0
    90de:	ed b7       	in	r30, 0x3d	; 61
    90e0:	fe b7       	in	r31, 0x3e	; 62
    90e2:	12 83       	std	Z+2, r17	; 0x02
    90e4:	01 83       	std	Z+1, r16	; 0x01
    90e6:	8b e0       	ldi	r24, 0x0B	; 11
    90e8:	95 e1       	ldi	r25, 0x15	; 21
    90ea:	94 83       	std	Z+4, r25	; 0x04
    90ec:	83 83       	std	Z+3, r24	; 0x03
    90ee:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    PRINT6ADDR(stream, &nicState.layer3.ipv6->srcipaddr);
    90f2:	a0 91 9f 0e 	lds	r26, 0x0E9F
    90f6:	b0 91 a0 0e 	lds	r27, 0x0EA0
    90fa:	8d b7       	in	r24, 0x3d	; 61
    90fc:	9e b7       	in	r25, 0x3e	; 62
    90fe:	80 97       	sbiw	r24, 0x20	; 32
    9100:	0f b6       	in	r0, 0x3f	; 63
    9102:	f8 94       	cli
    9104:	9e bf       	out	0x3e, r25	; 62
    9106:	0f be       	out	0x3f, r0	; 63
    9108:	8d bf       	out	0x3d, r24	; 61
    910a:	ed b7       	in	r30, 0x3d	; 61
    910c:	fe b7       	in	r31, 0x3e	; 62
    910e:	31 96       	adiw	r30, 0x01	; 1
    9110:	cd b7       	in	r28, 0x3d	; 61
    9112:	de b7       	in	r29, 0x3e	; 62
    9114:	1a 83       	std	Y+2, r17	; 0x02
    9116:	09 83       	std	Y+1, r16	; 0x01
    9118:	84 eb       	ldi	r24, 0xB4	; 180
    911a:	94 e1       	ldi	r25, 0x14	; 20
    911c:	93 83       	std	Z+3, r25	; 0x03
    911e:	82 83       	std	Z+2, r24	; 0x02
    9120:	18 96       	adiw	r26, 0x08	; 8
    9122:	8c 91       	ld	r24, X
    9124:	18 97       	sbiw	r26, 0x08	; 8
    9126:	84 83       	std	Z+4, r24	; 0x04
    9128:	15 82       	std	Z+5, r1	; 0x05
    912a:	19 96       	adiw	r26, 0x09	; 9
    912c:	8c 91       	ld	r24, X
    912e:	19 97       	sbiw	r26, 0x09	; 9
    9130:	86 83       	std	Z+6, r24	; 0x06
    9132:	17 82       	std	Z+7, r1	; 0x07
    9134:	1a 96       	adiw	r26, 0x0a	; 10
    9136:	8c 91       	ld	r24, X
    9138:	1a 97       	sbiw	r26, 0x0a	; 10
    913a:	80 87       	std	Z+8, r24	; 0x08
    913c:	11 86       	std	Z+9, r1	; 0x09
    913e:	1b 96       	adiw	r26, 0x0b	; 11
    9140:	8c 91       	ld	r24, X
    9142:	1b 97       	sbiw	r26, 0x0b	; 11
    9144:	82 87       	std	Z+10, r24	; 0x0a
    9146:	13 86       	std	Z+11, r1	; 0x0b
    9148:	1c 96       	adiw	r26, 0x0c	; 12
    914a:	8c 91       	ld	r24, X
    914c:	1c 97       	sbiw	r26, 0x0c	; 12
    914e:	84 87       	std	Z+12, r24	; 0x0c
    9150:	15 86       	std	Z+13, r1	; 0x0d
    9152:	1d 96       	adiw	r26, 0x0d	; 13
    9154:	8c 91       	ld	r24, X
    9156:	1d 97       	sbiw	r26, 0x0d	; 13
    9158:	86 87       	std	Z+14, r24	; 0x0e
    915a:	17 86       	std	Z+15, r1	; 0x0f
    915c:	1e 96       	adiw	r26, 0x0e	; 14
    915e:	8c 91       	ld	r24, X
    9160:	1e 97       	sbiw	r26, 0x0e	; 14
    9162:	80 8b       	std	Z+16, r24	; 0x10
    9164:	11 8a       	std	Z+17, r1	; 0x11
    9166:	1f 96       	adiw	r26, 0x0f	; 15
    9168:	8c 91       	ld	r24, X
    916a:	1f 97       	sbiw	r26, 0x0f	; 15
    916c:	82 8b       	std	Z+18, r24	; 0x12
    916e:	13 8a       	std	Z+19, r1	; 0x13
    9170:	50 96       	adiw	r26, 0x10	; 16
    9172:	8c 91       	ld	r24, X
    9174:	50 97       	sbiw	r26, 0x10	; 16
    9176:	84 8b       	std	Z+20, r24	; 0x14
    9178:	15 8a       	std	Z+21, r1	; 0x15
    917a:	51 96       	adiw	r26, 0x11	; 17
    917c:	8c 91       	ld	r24, X
    917e:	51 97       	sbiw	r26, 0x11	; 17
    9180:	86 8b       	std	Z+22, r24	; 0x16
    9182:	17 8a       	std	Z+23, r1	; 0x17
    9184:	52 96       	adiw	r26, 0x12	; 18
    9186:	8c 91       	ld	r24, X
    9188:	52 97       	sbiw	r26, 0x12	; 18
    918a:	80 8f       	std	Z+24, r24	; 0x18
    918c:	11 8e       	std	Z+25, r1	; 0x19
    918e:	53 96       	adiw	r26, 0x13	; 19
    9190:	8c 91       	ld	r24, X
    9192:	53 97       	sbiw	r26, 0x13	; 19
    9194:	82 8f       	std	Z+26, r24	; 0x1a
    9196:	13 8e       	std	Z+27, r1	; 0x1b
    9198:	54 96       	adiw	r26, 0x14	; 20
    919a:	8c 91       	ld	r24, X
    919c:	54 97       	sbiw	r26, 0x14	; 20
    919e:	84 8f       	std	Z+28, r24	; 0x1c
    91a0:	15 8e       	std	Z+29, r1	; 0x1d
    91a2:	55 96       	adiw	r26, 0x15	; 21
    91a4:	8c 91       	ld	r24, X
    91a6:	55 97       	sbiw	r26, 0x15	; 21
    91a8:	86 8f       	std	Z+30, r24	; 0x1e
    91aa:	17 8e       	std	Z+31, r1	; 0x1f
    91ac:	56 96       	adiw	r26, 0x16	; 22
    91ae:	8c 91       	ld	r24, X
    91b0:	56 97       	sbiw	r26, 0x16	; 22
    91b2:	80 a3       	std	Z+32, r24	; 0x20
    91b4:	11 a2       	std	Z+33, r1	; 0x21
    91b6:	57 96       	adiw	r26, 0x17	; 23
    91b8:	8c 91       	ld	r24, X
    91ba:	82 a3       	std	Z+34, r24	; 0x22
    91bc:	13 a2       	std	Z+35, r1	; 0x23
    91be:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    fprintf_P(stream, PSTR("\tDestination address: \t"));
    91c2:	ed b7       	in	r30, 0x3d	; 61
    91c4:	fe b7       	in	r31, 0x3e	; 62
    91c6:	b4 96       	adiw	r30, 0x24	; 36
    91c8:	0f b6       	in	r0, 0x3f	; 63
    91ca:	f8 94       	cli
    91cc:	fe bf       	out	0x3e, r31	; 62
    91ce:	0f be       	out	0x3f, r0	; 63
    91d0:	ed bf       	out	0x3d, r30	; 61
    91d2:	00 d0       	rcall	.+0      	; 0x91d4 <netPrintIpv6Header+0x274>
    91d4:	00 d0       	rcall	.+0      	; 0x91d6 <netPrintIpv6Header+0x276>
    91d6:	cd b7       	in	r28, 0x3d	; 61
    91d8:	de b7       	in	r29, 0x3e	; 62
    91da:	1a 83       	std	Y+2, r17	; 0x02
    91dc:	09 83       	std	Y+1, r16	; 0x01
    91de:	8c e9       	ldi	r24, 0x9C	; 156
    91e0:	94 e1       	ldi	r25, 0x14	; 20
    91e2:	9c 83       	std	Y+4, r25	; 0x04
    91e4:	8b 83       	std	Y+3, r24	; 0x03
    91e6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    PRINT6ADDR(stream, &nicState.layer3.ipv6->destipaddr);
    91ea:	a0 91 9f 0e 	lds	r26, 0x0E9F
    91ee:	b0 91 a0 0e 	lds	r27, 0x0EA0
    91f2:	ed b7       	in	r30, 0x3d	; 61
    91f4:	fe b7       	in	r31, 0x3e	; 62
    91f6:	b0 97       	sbiw	r30, 0x20	; 32
    91f8:	0f b6       	in	r0, 0x3f	; 63
    91fa:	f8 94       	cli
    91fc:	fe bf       	out	0x3e, r31	; 62
    91fe:	0f be       	out	0x3f, r0	; 63
    9200:	ed bf       	out	0x3d, r30	; 61
    9202:	31 96       	adiw	r30, 0x01	; 1
    9204:	cd b7       	in	r28, 0x3d	; 61
    9206:	de b7       	in	r29, 0x3e	; 62
    9208:	1a 83       	std	Y+2, r17	; 0x02
    920a:	09 83       	std	Y+1, r16	; 0x01
    920c:	85 e4       	ldi	r24, 0x45	; 69
    920e:	94 e1       	ldi	r25, 0x14	; 20
    9210:	93 83       	std	Z+3, r25	; 0x03
    9212:	82 83       	std	Z+2, r24	; 0x02
    9214:	58 96       	adiw	r26, 0x18	; 24
    9216:	8c 91       	ld	r24, X
    9218:	58 97       	sbiw	r26, 0x18	; 24
    921a:	84 83       	std	Z+4, r24	; 0x04
    921c:	15 82       	std	Z+5, r1	; 0x05
    921e:	59 96       	adiw	r26, 0x19	; 25
    9220:	8c 91       	ld	r24, X
    9222:	59 97       	sbiw	r26, 0x19	; 25
    9224:	86 83       	std	Z+6, r24	; 0x06
    9226:	17 82       	std	Z+7, r1	; 0x07
    9228:	5a 96       	adiw	r26, 0x1a	; 26
    922a:	8c 91       	ld	r24, X
    922c:	5a 97       	sbiw	r26, 0x1a	; 26
    922e:	80 87       	std	Z+8, r24	; 0x08
    9230:	11 86       	std	Z+9, r1	; 0x09
    9232:	5b 96       	adiw	r26, 0x1b	; 27
    9234:	8c 91       	ld	r24, X
    9236:	5b 97       	sbiw	r26, 0x1b	; 27
    9238:	82 87       	std	Z+10, r24	; 0x0a
    923a:	13 86       	std	Z+11, r1	; 0x0b
    923c:	5c 96       	adiw	r26, 0x1c	; 28
    923e:	8c 91       	ld	r24, X
    9240:	5c 97       	sbiw	r26, 0x1c	; 28
    9242:	84 87       	std	Z+12, r24	; 0x0c
    9244:	15 86       	std	Z+13, r1	; 0x0d
    9246:	5d 96       	adiw	r26, 0x1d	; 29
    9248:	8c 91       	ld	r24, X
    924a:	5d 97       	sbiw	r26, 0x1d	; 29
    924c:	86 87       	std	Z+14, r24	; 0x0e
    924e:	17 86       	std	Z+15, r1	; 0x0f
    9250:	5e 96       	adiw	r26, 0x1e	; 30
    9252:	8c 91       	ld	r24, X
    9254:	5e 97       	sbiw	r26, 0x1e	; 30
    9256:	80 8b       	std	Z+16, r24	; 0x10
    9258:	11 8a       	std	Z+17, r1	; 0x11
    925a:	5f 96       	adiw	r26, 0x1f	; 31
    925c:	8c 91       	ld	r24, X
    925e:	5f 97       	sbiw	r26, 0x1f	; 31
    9260:	82 8b       	std	Z+18, r24	; 0x12
    9262:	13 8a       	std	Z+19, r1	; 0x13
    9264:	90 96       	adiw	r26, 0x20	; 32
    9266:	8c 91       	ld	r24, X
    9268:	90 97       	sbiw	r26, 0x20	; 32
    926a:	84 8b       	std	Z+20, r24	; 0x14
    926c:	15 8a       	std	Z+21, r1	; 0x15
    926e:	91 96       	adiw	r26, 0x21	; 33
    9270:	8c 91       	ld	r24, X
    9272:	91 97       	sbiw	r26, 0x21	; 33
    9274:	86 8b       	std	Z+22, r24	; 0x16
    9276:	17 8a       	std	Z+23, r1	; 0x17
    9278:	92 96       	adiw	r26, 0x22	; 34
    927a:	8c 91       	ld	r24, X
    927c:	92 97       	sbiw	r26, 0x22	; 34
    927e:	80 8f       	std	Z+24, r24	; 0x18
    9280:	11 8e       	std	Z+25, r1	; 0x19
    9282:	93 96       	adiw	r26, 0x23	; 35
    9284:	8c 91       	ld	r24, X
    9286:	93 97       	sbiw	r26, 0x23	; 35
    9288:	82 8f       	std	Z+26, r24	; 0x1a
    928a:	13 8e       	std	Z+27, r1	; 0x1b
    928c:	94 96       	adiw	r26, 0x24	; 36
    928e:	8c 91       	ld	r24, X
    9290:	94 97       	sbiw	r26, 0x24	; 36
    9292:	84 8f       	std	Z+28, r24	; 0x1c
    9294:	15 8e       	std	Z+29, r1	; 0x1d
    9296:	95 96       	adiw	r26, 0x25	; 37
    9298:	8c 91       	ld	r24, X
    929a:	95 97       	sbiw	r26, 0x25	; 37
    929c:	86 8f       	std	Z+30, r24	; 0x1e
    929e:	17 8e       	std	Z+31, r1	; 0x1f
    92a0:	96 96       	adiw	r26, 0x26	; 38
    92a2:	8c 91       	ld	r24, X
    92a4:	96 97       	sbiw	r26, 0x26	; 38
    92a6:	80 a3       	std	Z+32, r24	; 0x20
    92a8:	11 a2       	std	Z+33, r1	; 0x21
    92aa:	97 96       	adiw	r26, 0x27	; 39
    92ac:	8c 91       	ld	r24, X
    92ae:	82 a3       	std	Z+34, r24	; 0x22
    92b0:	13 a2       	std	Z+35, r1	; 0x23
    92b2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    92b6:	ed b7       	in	r30, 0x3d	; 61
    92b8:	fe b7       	in	r31, 0x3e	; 62
    92ba:	b4 96       	adiw	r30, 0x24	; 36
    92bc:	0f b6       	in	r0, 0x3f	; 63
    92be:	f8 94       	cli
    92c0:	fe bf       	out	0x3e, r31	; 62
    92c2:	0f be       	out	0x3f, r0	; 63
    92c4:	ed bf       	out	0x3d, r30	; 61
}
    92c6:	df 91       	pop	r29
    92c8:	cf 91       	pop	r28
    92ca:	1f 91       	pop	r17
    92cc:	0f 91       	pop	r16
    92ce:	08 95       	ret

000092d0 <netPrintIpv6HeaderRAW>:
    return 1;
  
}

void netPrintIpv6HeaderRAW(FILE *stream)
{
    92d0:	af 92       	push	r10
    92d2:	bf 92       	push	r11
    92d4:	cf 92       	push	r12
    92d6:	df 92       	push	r13
    92d8:	ef 92       	push	r14
    92da:	ff 92       	push	r15
    92dc:	0f 93       	push	r16
    92de:	1f 93       	push	r17
    92e0:	cf 93       	push	r28
    92e2:	df 93       	push	r29
    92e4:	8c 01       	movw	r16, r24
  fprintf_P(stream, PSTR("*IPv6 Header RAW:\r\n"));    
    92e6:	00 d0       	rcall	.+0      	; 0x92e8 <netPrintIpv6HeaderRAW+0x18>
    92e8:	00 d0       	rcall	.+0      	; 0x92ea <netPrintIpv6HeaderRAW+0x1a>
    92ea:	ad b7       	in	r26, 0x3d	; 61
    92ec:	be b7       	in	r27, 0x3e	; 62
    92ee:	12 96       	adiw	r26, 0x02	; 2
    92f0:	9c 93       	st	X, r25
    92f2:	8e 93       	st	-X, r24
    92f4:	11 97       	sbiw	r26, 0x01	; 1
    92f6:	8d e9       	ldi	r24, 0x9D	; 157
    92f8:	95 e1       	ldi	r25, 0x15	; 21
    92fa:	14 96       	adiw	r26, 0x04	; 4
    92fc:	9c 93       	st	X, r25
    92fe:	8e 93       	st	-X, r24
    9300:	13 97       	sbiw	r26, 0x03	; 3
    9302:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(stream, PSTR("\t"));    
    9306:	ed b7       	in	r30, 0x3d	; 61
    9308:	fe b7       	in	r31, 0x3e	; 62
    930a:	12 83       	std	Z+2, r17	; 0x02
    930c:	01 83       	std	Z+1, r16	; 0x01
    930e:	8b e9       	ldi	r24, 0x9B	; 155
    9310:	95 e1       	ldi	r25, 0x15	; 21
    9312:	94 83       	std	Z+4, r25	; 0x04
    9314:	83 83       	std	Z+3, r24	; 0x03
    9316:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    931a:	c1 e0       	ldi	r28, 0x01	; 1
    931c:	d0 e0       	ldi	r29, 0x00	; 0
    931e:	0f 90       	pop	r0
    9320:	0f 90       	pop	r0
    9322:	0f 90       	pop	r0
    9324:	0f 90       	pop	r0
    if (i!=0 && i%16==0) 
    {
      fprintf_P(stream, PSTR("\r\n"));
      fprintf_P(stream, PSTR("\t"));
    }
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i]);
    9326:	60 e9       	ldi	r22, 0x90	; 144
    9328:	a6 2e       	mov	r10, r22
    932a:	65 e1       	ldi	r22, 0x15	; 21
    932c:	b6 2e       	mov	r11, r22
  fprintf_P(stream, PSTR("\t"));    
  for (uint8_t i=0; i < UIP_IPv6H_LEN; i++)
  {
    if (i!=0 && i%16==0) 
    {
      fprintf_P(stream, PSTR("\r\n"));
    932e:	58 e9       	ldi	r21, 0x98	; 152
    9330:	c5 2e       	mov	r12, r21
    9332:	55 e1       	ldi	r21, 0x15	; 21
    9334:	d5 2e       	mov	r13, r21
      fprintf_P(stream, PSTR("\t"));
    9336:	46 e9       	ldi	r20, 0x96	; 150
    9338:	e4 2e       	mov	r14, r20
    933a:	45 e1       	ldi	r20, 0x15	; 21
    933c:	f4 2e       	mov	r15, r20
    933e:	20 c0       	rjmp	.+64     	; 0x9380 <netPrintIpv6HeaderRAW+0xb0>
{
  fprintf_P(stream, PSTR("*IPv6 Header RAW:\r\n"));    
  fprintf_P(stream, PSTR("\t"));    
  for (uint8_t i=0; i < UIP_IPv6H_LEN; i++)
  {
    if (i!=0 && i%16==0) 
    9340:	ce 01       	movw	r24, r28
    9342:	8f 70       	andi	r24, 0x0F	; 15
    9344:	90 70       	andi	r25, 0x00	; 0
    9346:	89 2b       	or	r24, r25
    9348:	d1 f4       	brne	.+52     	; 0x937e <netPrintIpv6HeaderRAW+0xae>
    {
      fprintf_P(stream, PSTR("\r\n"));
    934a:	00 d0       	rcall	.+0      	; 0x934c <netPrintIpv6HeaderRAW+0x7c>
    934c:	00 d0       	rcall	.+0      	; 0x934e <netPrintIpv6HeaderRAW+0x7e>
    934e:	ad b7       	in	r26, 0x3d	; 61
    9350:	be b7       	in	r27, 0x3e	; 62
    9352:	12 96       	adiw	r26, 0x02	; 2
    9354:	1c 93       	st	X, r17
    9356:	0e 93       	st	-X, r16
    9358:	11 97       	sbiw	r26, 0x01	; 1
    935a:	14 96       	adiw	r26, 0x04	; 4
    935c:	dc 92       	st	X, r13
    935e:	ce 92       	st	-X, r12
    9360:	13 97       	sbiw	r26, 0x03	; 3
    9362:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      fprintf_P(stream, PSTR("\t"));
    9366:	ed b7       	in	r30, 0x3d	; 61
    9368:	fe b7       	in	r31, 0x3e	; 62
    936a:	12 83       	std	Z+2, r17	; 0x02
    936c:	01 83       	std	Z+1, r16	; 0x01
    936e:	f4 82       	std	Z+4, r15	; 0x04
    9370:	e3 82       	std	Z+3, r14	; 0x03
    9372:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    9376:	0f 90       	pop	r0
    9378:	0f 90       	pop	r0
    937a:	0f 90       	pop	r0
    937c:	0f 90       	pop	r0
    937e:	21 96       	adiw	r28, 0x01	; 1
    }
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i]);
    9380:	00 d0       	rcall	.+0      	; 0x9382 <netPrintIpv6HeaderRAW+0xb2>
    9382:	00 d0       	rcall	.+0      	; 0x9384 <netPrintIpv6HeaderRAW+0xb4>
    9384:	00 d0       	rcall	.+0      	; 0x9386 <netPrintIpv6HeaderRAW+0xb6>
    9386:	ed b7       	in	r30, 0x3d	; 61
    9388:	fe b7       	in	r31, 0x3e	; 62
    938a:	31 96       	adiw	r30, 0x01	; 1
    938c:	ad b7       	in	r26, 0x3d	; 61
    938e:	be b7       	in	r27, 0x3e	; 62
    9390:	12 96       	adiw	r26, 0x02	; 2
    9392:	1c 93       	st	X, r17
    9394:	0e 93       	st	-X, r16
    9396:	11 97       	sbiw	r26, 0x01	; 1
    9398:	b3 82       	std	Z+3, r11	; 0x03
    939a:	a2 82       	std	Z+2, r10	; 0x02
    939c:	a0 91 9f 0e 	lds	r26, 0x0E9F
    93a0:	b0 91 a0 0e 	lds	r27, 0x0EA0
    93a4:	ac 0f       	add	r26, r28
    93a6:	bd 1f       	adc	r27, r29
    93a8:	11 97       	sbiw	r26, 0x01	; 1
    93aa:	8c 91       	ld	r24, X
    93ac:	84 83       	std	Z+4, r24	; 0x04
    93ae:	15 82       	std	Z+5, r1	; 0x05
    93b0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>

void netPrintIpv6HeaderRAW(FILE *stream)
{
  fprintf_P(stream, PSTR("*IPv6 Header RAW:\r\n"));    
  fprintf_P(stream, PSTR("\t"));    
  for (uint8_t i=0; i < UIP_IPv6H_LEN; i++)
    93b4:	ed b7       	in	r30, 0x3d	; 61
    93b6:	fe b7       	in	r31, 0x3e	; 62
    93b8:	36 96       	adiw	r30, 0x06	; 6
    93ba:	0f b6       	in	r0, 0x3f	; 63
    93bc:	f8 94       	cli
    93be:	fe bf       	out	0x3e, r31	; 62
    93c0:	0f be       	out	0x3f, r0	; 63
    93c2:	ed bf       	out	0x3d, r30	; 61
    93c4:	c8 32       	cpi	r28, 0x28	; 40
    93c6:	d1 05       	cpc	r29, r1
    93c8:	09 f0       	breq	.+2      	; 0x93cc <netPrintIpv6HeaderRAW+0xfc>
    93ca:	ba cf       	rjmp	.-140    	; 0x9340 <netPrintIpv6HeaderRAW+0x70>
      fprintf_P(stream, PSTR("\r\n"));
      fprintf_P(stream, PSTR("\t"));
    }
    fprintf_P(stream, PSTR("%02x:"), nicState.layer3.buf[i]);
  }
  fprintf_P(stream, PSTR("\r\n")); 
    93cc:	00 d0       	rcall	.+0      	; 0x93ce <netPrintIpv6HeaderRAW+0xfe>
    93ce:	00 d0       	rcall	.+0      	; 0x93d0 <netPrintIpv6HeaderRAW+0x100>
    93d0:	ad b7       	in	r26, 0x3d	; 61
    93d2:	be b7       	in	r27, 0x3e	; 62
    93d4:	12 96       	adiw	r26, 0x02	; 2
    93d6:	1c 93       	st	X, r17
    93d8:	0e 93       	st	-X, r16
    93da:	11 97       	sbiw	r26, 0x01	; 1
    93dc:	8d e8       	ldi	r24, 0x8D	; 141
    93de:	95 e1       	ldi	r25, 0x15	; 21
    93e0:	14 96       	adiw	r26, 0x04	; 4
    93e2:	9c 93       	st	X, r25
    93e4:	8e 93       	st	-X, r24
    93e6:	13 97       	sbiw	r26, 0x03	; 3
    93e8:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    93ec:	0f 90       	pop	r0
    93ee:	0f 90       	pop	r0
    93f0:	0f 90       	pop	r0
    93f2:	0f 90       	pop	r0
}
    93f4:	df 91       	pop	r29
    93f6:	cf 91       	pop	r28
    93f8:	1f 91       	pop	r17
    93fa:	0f 91       	pop	r16
    93fc:	ff 90       	pop	r15
    93fe:	ef 90       	pop	r14
    9400:	df 90       	pop	r13
    9402:	cf 90       	pop	r12
    9404:	bf 90       	pop	r11
    9406:	af 90       	pop	r10
    9408:	08 95       	ret

0000940a <swithEthAddresses>:
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    }
    fprintf_P(debugStream, PSTR("\r\n"));
    */
    memcpy(&nicState.layer2.ethHeader->dest, &nicState.layer2.ethHeader->src, 6);
    940a:	80 91 9d 0e 	lds	r24, 0x0E9D
    940e:	90 91 9e 0e 	lds	r25, 0x0E9E
    9412:	9c 01       	movw	r18, r24
    9414:	f9 01       	movw	r30, r18
    9416:	d9 01       	movw	r26, r18
    9418:	16 96       	adiw	r26, 0x06	; 6
    941a:	86 e0       	ldi	r24, 0x06	; 6
    941c:	0d 90       	ld	r0, X+
    941e:	01 92       	st	Z+, r0
    9420:	81 50       	subi	r24, 0x01	; 1
    9422:	e1 f7       	brne	.-8      	; 0x941c <swithEthAddresses+0x12>
    memcpy(&nicState.layer2.ethHeader->src, &nicState.mac, 6);
    9424:	e0 91 9d 0e 	lds	r30, 0x0E9D
    9428:	f0 91 9e 0e 	lds	r31, 0x0E9E
    942c:	36 96       	adiw	r30, 0x06	; 6
    942e:	a7 e9       	ldi	r26, 0x97	; 151
    9430:	be e0       	ldi	r27, 0x0E	; 14
    9432:	86 e0       	ldi	r24, 0x06	; 6
    9434:	0d 90       	ld	r0, X+
    9436:	01 92       	st	Z+, r0
    9438:	81 50       	subi	r24, 0x01	; 1
    943a:	e1 f7       	brne	.-8      	; 0x9434 <swithEthAddresses+0x2a>
    nicState.layer2.ethHeader->type = 0xdd86;
    943c:	e0 91 9d 0e 	lds	r30, 0x0E9D
    9440:	f0 91 9e 0e 	lds	r31, 0x0E9E
    9444:	86 e8       	ldi	r24, 0x86	; 134
    9446:	9d ed       	ldi	r25, 0xDD	; 221
    9448:	95 87       	std	Z+13, r25	; 0x0d
    944a:	84 87       	std	Z+12, r24	; 0x0c
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    }
    fprintf_P(debugStream, PSTR("\r\n"));
    */
}
    944c:	08 95       	ret

0000944e <netstackIPv6Process>:
  //Ipv6MyConfig.prefix= 64;
  //Ipv6MyConfig.gateway = xmalloc(sizeof(uip_ip6addr_t));
}

void netstackIPv6Process(void)
{
    944e:	cf 92       	push	r12
    9450:	df 92       	push	r13
    9452:	ef 92       	push	r14
    9454:	ff 92       	push	r15
    9456:	1f 93       	push	r17
    9458:	cf 93       	push	r28
    945a:	df 93       	push	r29
  //uip_ip6addr_t *ipv6addr;
  #if IP_DEBUG
  fprintf_P(debugStream, PSTR("*IPv6 packet in. Length: %d\r\n"), plen);
    945c:	00 d0       	rcall	.+0      	; 0x945e <netstackIPv6Process+0x10>
    945e:	00 d0       	rcall	.+0      	; 0x9460 <netstackIPv6Process+0x12>
    9460:	00 d0       	rcall	.+0      	; 0x9462 <netstackIPv6Process+0x14>
    9462:	ed b7       	in	r30, 0x3d	; 61
    9464:	fe b7       	in	r31, 0x3e	; 62
    9466:	31 96       	adiw	r30, 0x01	; 1
    9468:	80 91 64 0f 	lds	r24, 0x0F64
    946c:	90 91 65 0f 	lds	r25, 0x0F65
    9470:	ad b7       	in	r26, 0x3d	; 61
    9472:	be b7       	in	r27, 0x3e	; 62
    9474:	12 96       	adiw	r26, 0x02	; 2
    9476:	9c 93       	st	X, r25
    9478:	8e 93       	st	-X, r24
    947a:	11 97       	sbiw	r26, 0x01	; 1
    947c:	86 e2       	ldi	r24, 0x26	; 38
    947e:	96 e1       	ldi	r25, 0x16	; 22
    9480:	93 83       	std	Z+3, r25	; 0x03
    9482:	82 83       	std	Z+2, r24	; 0x02
    9484:	80 91 c8 0e 	lds	r24, 0x0EC8
    9488:	90 91 c9 0e 	lds	r25, 0x0EC9
    948c:	95 83       	std	Z+5, r25	; 0x05
    948e:	84 83       	std	Z+4, r24	; 0x04
    9490:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  netPrintIpv6Header(debugStream);
    9494:	ed b7       	in	r30, 0x3d	; 61
    9496:	fe b7       	in	r31, 0x3e	; 62
    9498:	36 96       	adiw	r30, 0x06	; 6
    949a:	0f b6       	in	r0, 0x3f	; 63
    949c:	f8 94       	cli
    949e:	fe bf       	out	0x3e, r31	; 62
    94a0:	0f be       	out	0x3f, r0	; 63
    94a2:	ed bf       	out	0x3d, r30	; 61
    94a4:	80 91 64 0f 	lds	r24, 0x0F64
    94a8:	90 91 65 0f 	lds	r25, 0x0F65
    94ac:	0e 94 b0 47 	call	0x8f60	; 0x8f60 <netPrintIpv6Header>
  //netPrintIpv6HeaderRAW(debugStream);
  netPrintIpv6PayloadRAW(debugStream);
    94b0:	80 91 64 0f 	lds	r24, 0x0F64
    94b4:	90 91 65 0f 	lds	r25, 0x0F65
    94b8:	0e 94 00 47 	call	0x8e00	; 0x8e00 <netPrintIpv6PayloadRAW>
  ipv6PrintConfig(debugStream, uip_netif_physical_if);
    94bc:	60 91 8f 0e 	lds	r22, 0x0E8F
    94c0:	70 91 90 0e 	lds	r23, 0x0E90
    94c4:	80 91 64 0f 	lds	r24, 0x0F64
    94c8:	90 91 65 0f 	lds	r25, 0x0F65
    94cc:	0e 94 ac 45 	call	0x8b58	; 0x8b58 <ipv6PrintConfig>
  #endif /*IP_DEBUG*/  

  if(checkPacketLen() == 1)
    94d0:	0e 94 97 45 	call	0x8b2e	; 0x8b2e <checkPacketLen>
    94d4:	81 30       	cpi	r24, 0x01	; 1
    94d6:	09 f0       	breq	.+2      	; 0x94da <netstackIPv6Process+0x8c>
    94d8:	5a c1       	rjmp	.+692    	; 0x978e <netstackIPv6Process+0x340>
     // !uip_is_addr_linklocal_allnodes_mcast(&UIP_IP_BUF->destipaddr)){
     // UIP_STAT(++uip_stat.ip.drop);
     // goto drop;
  

      if(UIP_ICMP_BUF->type==ICMP6_ECHO_REQUEST)
    94da:	80 91 69 0f 	lds	r24, 0x0F69
    94de:	e0 91 9d 0e 	lds	r30, 0x0E9D
    94e2:	f0 91 9e 0e 	lds	r31, 0x0E9E
    94e6:	e8 0f       	add	r30, r24
    94e8:	f1 1d       	adc	r31, r1
    94ea:	86 a9       	ldd	r24, Z+54	; 0x36
    94ec:	80 38       	cpi	r24, 0x80	; 128
    94ee:	51 f4       	brne	.+20     	; 0x9504 <netstackIPv6Process+0xb6>
      {
	//reply
	uip_icmp6_echo_request_input();
    94f0:	0e 94 e8 4b 	call	0x97d0	; 0x97d0 <uip_icmp6_echo_request_input>
	swithEthAddresses();
    94f4:	0e 94 05 4a 	call	0x940a	; 0x940a <swithEthAddresses>
	nicSend(plen);
    94f8:	80 91 c8 0e 	lds	r24, 0x0EC8
    94fc:	90 91 c9 0e 	lds	r25, 0x0EC9
    9500:	0e 94 de 31 	call	0x63bc	; 0x63bc <nicSend>
      }
      if(UIP_ICMP_BUF->type==ICMP6_NS)
    9504:	80 91 69 0f 	lds	r24, 0x0F69
    9508:	e0 91 9d 0e 	lds	r30, 0x0E9D
    950c:	f0 91 9e 0e 	lds	r31, 0x0E9E
    9510:	e8 0f       	add	r30, r24
    9512:	f1 1d       	adc	r31, r1
    9514:	86 a9       	ldd	r24, Z+54	; 0x36
    9516:	87 38       	cpi	r24, 0x87	; 135
    9518:	09 f0       	breq	.+2      	; 0x951c <netstackIPv6Process+0xce>
    951a:	4d c1       	rjmp	.+666    	; 0x97b6 <netstackIPv6Process+0x368>
      {
	//reply ICMP6_NA
	fprintf_P(debugStream, PSTR("NS, length=%d, \r\n"), plen);    
    951c:	00 d0       	rcall	.+0      	; 0x951e <netstackIPv6Process+0xd0>
    951e:	00 d0       	rcall	.+0      	; 0x9520 <netstackIPv6Process+0xd2>
    9520:	00 d0       	rcall	.+0      	; 0x9522 <netstackIPv6Process+0xd4>
    9522:	ed b7       	in	r30, 0x3d	; 61
    9524:	fe b7       	in	r31, 0x3e	; 62
    9526:	31 96       	adiw	r30, 0x01	; 1
    9528:	80 91 64 0f 	lds	r24, 0x0F64
    952c:	90 91 65 0f 	lds	r25, 0x0F65
    9530:	ad b7       	in	r26, 0x3d	; 61
    9532:	be b7       	in	r27, 0x3e	; 62
    9534:	12 96       	adiw	r26, 0x02	; 2
    9536:	9c 93       	st	X, r25
    9538:	8e 93       	st	-X, r24
    953a:	11 97       	sbiw	r26, 0x01	; 1
    953c:	84 e1       	ldi	r24, 0x14	; 20
    953e:	96 e1       	ldi	r25, 0x16	; 22
    9540:	93 83       	std	Z+3, r25	; 0x03
    9542:	82 83       	std	Z+2, r24	; 0x02
    9544:	80 91 c8 0e 	lds	r24, 0x0EC8
    9548:	90 91 c9 0e 	lds	r25, 0x0EC9
    954c:	95 83       	std	Z+5, r25	; 0x05
    954e:	84 83       	std	Z+4, r24	; 0x04
    9550:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    9554:	10 e0       	ldi	r17, 0x00	; 0
    9556:	ed b7       	in	r30, 0x3d	; 61
    9558:	fe b7       	in	r31, 0x3e	; 62
    955a:	36 96       	adiw	r30, 0x06	; 6
    955c:	0f b6       	in	r0, 0x3f	; 63
    955e:	f8 94       	cli
    9560:	fe bf       	out	0x3e, r31	; 62
    9562:	0f be       	out	0x3f, r0	; 63
    9564:	ed bf       	out	0x3d, r30	; 61
	for (uint8_t i=0; i < plen; i++)
	{
	  if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
    9566:	a1 e1       	ldi	r26, 0x11	; 17
    9568:	ca 2e       	mov	r12, r26
    956a:	a6 e1       	ldi	r26, 0x16	; 22
    956c:	da 2e       	mov	r13, r26
	  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    956e:	fb e0       	ldi	r31, 0x0B	; 11
    9570:	ef 2e       	mov	r14, r31
    9572:	f6 e1       	ldi	r31, 0x16	; 22
    9574:	ff 2e       	mov	r15, r31
    9576:	46 c0       	rjmp	.+140    	; 0x9604 <netstackIPv6Process+0x1b6>
      {
	//reply ICMP6_NA
	fprintf_P(debugStream, PSTR("NS, length=%d, \r\n"), plen);    
	for (uint8_t i=0; i < plen; i++)
	{
	  if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
    9578:	11 23       	and	r17, r17
    957a:	d9 f0       	breq	.+54     	; 0x95b2 <netstackIPv6Process+0x164>
    957c:	ce 01       	movw	r24, r28
    957e:	8f 70       	andi	r24, 0x0F	; 15
    9580:	90 70       	andi	r25, 0x00	; 0
    9582:	89 2b       	or	r24, r25
    9584:	b1 f4       	brne	.+44     	; 0x95b2 <netstackIPv6Process+0x164>
    9586:	00 d0       	rcall	.+0      	; 0x9588 <netstackIPv6Process+0x13a>
    9588:	00 d0       	rcall	.+0      	; 0x958a <netstackIPv6Process+0x13c>
    958a:	80 91 64 0f 	lds	r24, 0x0F64
    958e:	90 91 65 0f 	lds	r25, 0x0F65
    9592:	ad b7       	in	r26, 0x3d	; 61
    9594:	be b7       	in	r27, 0x3e	; 62
    9596:	12 96       	adiw	r26, 0x02	; 2
    9598:	9c 93       	st	X, r25
    959a:	8e 93       	st	-X, r24
    959c:	11 97       	sbiw	r26, 0x01	; 1
    959e:	14 96       	adiw	r26, 0x04	; 4
    95a0:	dc 92       	st	X, r13
    95a2:	ce 92       	st	-X, r12
    95a4:	13 97       	sbiw	r26, 0x03	; 3
    95a6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    95aa:	0f 90       	pop	r0
    95ac:	0f 90       	pop	r0
    95ae:	0f 90       	pop	r0
    95b0:	0f 90       	pop	r0
	  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    95b2:	00 d0       	rcall	.+0      	; 0x95b4 <netstackIPv6Process+0x166>
    95b4:	00 d0       	rcall	.+0      	; 0x95b6 <netstackIPv6Process+0x168>
    95b6:	00 d0       	rcall	.+0      	; 0x95b8 <netstackIPv6Process+0x16a>
    95b8:	ad b7       	in	r26, 0x3d	; 61
    95ba:	be b7       	in	r27, 0x3e	; 62
    95bc:	11 96       	adiw	r26, 0x01	; 1
    95be:	80 91 64 0f 	lds	r24, 0x0F64
    95c2:	90 91 65 0f 	lds	r25, 0x0F65
    95c6:	ed b7       	in	r30, 0x3d	; 61
    95c8:	fe b7       	in	r31, 0x3e	; 62
    95ca:	92 83       	std	Z+2, r25	; 0x02
    95cc:	81 83       	std	Z+1, r24	; 0x01
    95ce:	13 96       	adiw	r26, 0x03	; 3
    95d0:	fc 92       	st	X, r15
    95d2:	ee 92       	st	-X, r14
    95d4:	12 97       	sbiw	r26, 0x02	; 2
    95d6:	e0 91 9d 0e 	lds	r30, 0x0E9D
    95da:	f0 91 9e 0e 	lds	r31, 0x0E9E
    95de:	ec 0f       	add	r30, r28
    95e0:	fd 1f       	adc	r31, r29
    95e2:	80 81       	ld	r24, Z
    95e4:	14 96       	adiw	r26, 0x04	; 4
    95e6:	8c 93       	st	X, r24
    95e8:	14 97       	sbiw	r26, 0x04	; 4
    95ea:	15 96       	adiw	r26, 0x05	; 5
    95ec:	1c 92       	st	X, r1
    95ee:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      }
      if(UIP_ICMP_BUF->type==ICMP6_NS)
      {
	//reply ICMP6_NA
	fprintf_P(debugStream, PSTR("NS, length=%d, \r\n"), plen);    
	for (uint8_t i=0; i < plen; i++)
    95f2:	1f 5f       	subi	r17, 0xFF	; 255
    95f4:	8d b7       	in	r24, 0x3d	; 61
    95f6:	9e b7       	in	r25, 0x3e	; 62
    95f8:	06 96       	adiw	r24, 0x06	; 6
    95fa:	0f b6       	in	r0, 0x3f	; 63
    95fc:	f8 94       	cli
    95fe:	9e bf       	out	0x3e, r25	; 62
    9600:	0f be       	out	0x3f, r0	; 63
    9602:	8d bf       	out	0x3d, r24	; 61
    9604:	c1 2f       	mov	r28, r17
    9606:	d0 e0       	ldi	r29, 0x00	; 0
    9608:	80 91 c8 0e 	lds	r24, 0x0EC8
    960c:	90 91 c9 0e 	lds	r25, 0x0EC9
    9610:	c8 17       	cp	r28, r24
    9612:	d9 07       	cpc	r29, r25
    9614:	08 f4       	brcc	.+2      	; 0x9618 <netstackIPv6Process+0x1ca>
    9616:	b0 cf       	rjmp	.-160    	; 0x9578 <netstackIPv6Process+0x12a>
	{
	  if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
	  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
	}
	fprintf_P(debugStream, PSTR("\r\n"));
    9618:	00 d0       	rcall	.+0      	; 0x961a <netstackIPv6Process+0x1cc>
    961a:	00 d0       	rcall	.+0      	; 0x961c <netstackIPv6Process+0x1ce>
    961c:	80 91 64 0f 	lds	r24, 0x0F64
    9620:	90 91 65 0f 	lds	r25, 0x0F65
    9624:	ad b7       	in	r26, 0x3d	; 61
    9626:	be b7       	in	r27, 0x3e	; 62
    9628:	12 96       	adiw	r26, 0x02	; 2
    962a:	9c 93       	st	X, r25
    962c:	8e 93       	st	-X, r24
    962e:	11 97       	sbiw	r26, 0x01	; 1
    9630:	88 e0       	ldi	r24, 0x08	; 8
    9632:	96 e1       	ldi	r25, 0x16	; 22
    9634:	14 96       	adiw	r26, 0x04	; 4
    9636:	9c 93       	st	X, r25
    9638:	8e 93       	st	-X, r24
    963a:	13 97       	sbiw	r26, 0x03	; 3
    963c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
	uip_nd6_io_ns_input(plen);
    9640:	0f 90       	pop	r0
    9642:	0f 90       	pop	r0
    9644:	0f 90       	pop	r0
    9646:	0f 90       	pop	r0
    9648:	80 91 c8 0e 	lds	r24, 0x0EC8
    964c:	90 91 c9 0e 	lds	r25, 0x0EC9
    9650:	0e 94 d0 4d 	call	0x9ba0	; 0x9ba0 <uip_nd6_io_ns_input>
	swithEthAddresses();
    9654:	0e 94 05 4a 	call	0x940a	; 0x940a <swithEthAddresses>
	fprintf_P(debugStream, PSTR("Packet out, length=%d, \r\n"), plen);    
    9658:	00 d0       	rcall	.+0      	; 0x965a <netstackIPv6Process+0x20c>
    965a:	00 d0       	rcall	.+0      	; 0x965c <netstackIPv6Process+0x20e>
    965c:	00 d0       	rcall	.+0      	; 0x965e <netstackIPv6Process+0x210>
    965e:	ed b7       	in	r30, 0x3d	; 61
    9660:	fe b7       	in	r31, 0x3e	; 62
    9662:	31 96       	adiw	r30, 0x01	; 1
    9664:	80 91 64 0f 	lds	r24, 0x0F64
    9668:	90 91 65 0f 	lds	r25, 0x0F65
    966c:	ad b7       	in	r26, 0x3d	; 61
    966e:	be b7       	in	r27, 0x3e	; 62
    9670:	12 96       	adiw	r26, 0x02	; 2
    9672:	9c 93       	st	X, r25
    9674:	8e 93       	st	-X, r24
    9676:	11 97       	sbiw	r26, 0x01	; 1
    9678:	8e ee       	ldi	r24, 0xEE	; 238
    967a:	95 e1       	ldi	r25, 0x15	; 21
    967c:	93 83       	std	Z+3, r25	; 0x03
    967e:	82 83       	std	Z+2, r24	; 0x02
    9680:	80 91 c8 0e 	lds	r24, 0x0EC8
    9684:	90 91 c9 0e 	lds	r25, 0x0EC9
    9688:	95 83       	std	Z+5, r25	; 0x05
    968a:	84 83       	std	Z+4, r24	; 0x04
    968c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    9690:	10 e0       	ldi	r17, 0x00	; 0
    9692:	ed b7       	in	r30, 0x3d	; 61
    9694:	fe b7       	in	r31, 0x3e	; 62
    9696:	36 96       	adiw	r30, 0x06	; 6
    9698:	0f b6       	in	r0, 0x3f	; 63
    969a:	f8 94       	cli
    969c:	fe bf       	out	0x3e, r31	; 62
    969e:	0f be       	out	0x3f, r0	; 63
    96a0:	ed bf       	out	0x3d, r30	; 61
	for (uint8_t i=0; i < plen; i++)
	{
	  if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
    96a2:	eb ee       	ldi	r30, 0xEB	; 235
    96a4:	ce 2e       	mov	r12, r30
    96a6:	e5 e1       	ldi	r30, 0x15	; 21
    96a8:	de 2e       	mov	r13, r30
	  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    96aa:	75 ee       	ldi	r23, 0xE5	; 229
    96ac:	e7 2e       	mov	r14, r23
    96ae:	75 e1       	ldi	r23, 0x15	; 21
    96b0:	f7 2e       	mov	r15, r23
    96b2:	46 c0       	rjmp	.+140    	; 0x9740 <netstackIPv6Process+0x2f2>
	uip_nd6_io_ns_input(plen);
	swithEthAddresses();
	fprintf_P(debugStream, PSTR("Packet out, length=%d, \r\n"), plen);    
	for (uint8_t i=0; i < plen; i++)
	{
	  if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
    96b4:	11 23       	and	r17, r17
    96b6:	d9 f0       	breq	.+54     	; 0x96ee <netstackIPv6Process+0x2a0>
    96b8:	ce 01       	movw	r24, r28
    96ba:	8f 70       	andi	r24, 0x0F	; 15
    96bc:	90 70       	andi	r25, 0x00	; 0
    96be:	89 2b       	or	r24, r25
    96c0:	b1 f4       	brne	.+44     	; 0x96ee <netstackIPv6Process+0x2a0>
    96c2:	00 d0       	rcall	.+0      	; 0x96c4 <netstackIPv6Process+0x276>
    96c4:	00 d0       	rcall	.+0      	; 0x96c6 <netstackIPv6Process+0x278>
    96c6:	80 91 64 0f 	lds	r24, 0x0F64
    96ca:	90 91 65 0f 	lds	r25, 0x0F65
    96ce:	ad b7       	in	r26, 0x3d	; 61
    96d0:	be b7       	in	r27, 0x3e	; 62
    96d2:	12 96       	adiw	r26, 0x02	; 2
    96d4:	9c 93       	st	X, r25
    96d6:	8e 93       	st	-X, r24
    96d8:	11 97       	sbiw	r26, 0x01	; 1
    96da:	14 96       	adiw	r26, 0x04	; 4
    96dc:	dc 92       	st	X, r13
    96de:	ce 92       	st	-X, r12
    96e0:	13 97       	sbiw	r26, 0x03	; 3
    96e2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    96e6:	0f 90       	pop	r0
    96e8:	0f 90       	pop	r0
    96ea:	0f 90       	pop	r0
    96ec:	0f 90       	pop	r0
	  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    96ee:	00 d0       	rcall	.+0      	; 0x96f0 <netstackIPv6Process+0x2a2>
    96f0:	00 d0       	rcall	.+0      	; 0x96f2 <netstackIPv6Process+0x2a4>
    96f2:	00 d0       	rcall	.+0      	; 0x96f4 <netstackIPv6Process+0x2a6>
    96f4:	ad b7       	in	r26, 0x3d	; 61
    96f6:	be b7       	in	r27, 0x3e	; 62
    96f8:	11 96       	adiw	r26, 0x01	; 1
    96fa:	80 91 64 0f 	lds	r24, 0x0F64
    96fe:	90 91 65 0f 	lds	r25, 0x0F65
    9702:	ed b7       	in	r30, 0x3d	; 61
    9704:	fe b7       	in	r31, 0x3e	; 62
    9706:	92 83       	std	Z+2, r25	; 0x02
    9708:	81 83       	std	Z+1, r24	; 0x01
    970a:	13 96       	adiw	r26, 0x03	; 3
    970c:	fc 92       	st	X, r15
    970e:	ee 92       	st	-X, r14
    9710:	12 97       	sbiw	r26, 0x02	; 2
    9712:	e0 91 9d 0e 	lds	r30, 0x0E9D
    9716:	f0 91 9e 0e 	lds	r31, 0x0E9E
    971a:	ec 0f       	add	r30, r28
    971c:	fd 1f       	adc	r31, r29
    971e:	80 81       	ld	r24, Z
    9720:	14 96       	adiw	r26, 0x04	; 4
    9722:	8c 93       	st	X, r24
    9724:	14 97       	sbiw	r26, 0x04	; 4
    9726:	15 96       	adiw	r26, 0x05	; 5
    9728:	1c 92       	st	X, r1
    972a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
	}
	fprintf_P(debugStream, PSTR("\r\n"));
	uip_nd6_io_ns_input(plen);
	swithEthAddresses();
	fprintf_P(debugStream, PSTR("Packet out, length=%d, \r\n"), plen);    
	for (uint8_t i=0; i < plen; i++)
    972e:	1f 5f       	subi	r17, 0xFF	; 255
    9730:	8d b7       	in	r24, 0x3d	; 61
    9732:	9e b7       	in	r25, 0x3e	; 62
    9734:	06 96       	adiw	r24, 0x06	; 6
    9736:	0f b6       	in	r0, 0x3f	; 63
    9738:	f8 94       	cli
    973a:	9e bf       	out	0x3e, r25	; 62
    973c:	0f be       	out	0x3f, r0	; 63
    973e:	8d bf       	out	0x3d, r24	; 61
    9740:	c1 2f       	mov	r28, r17
    9742:	d0 e0       	ldi	r29, 0x00	; 0
    9744:	80 91 c8 0e 	lds	r24, 0x0EC8
    9748:	90 91 c9 0e 	lds	r25, 0x0EC9
    974c:	c8 17       	cp	r28, r24
    974e:	d9 07       	cpc	r29, r25
    9750:	08 f4       	brcc	.+2      	; 0x9754 <netstackIPv6Process+0x306>
    9752:	b0 cf       	rjmp	.-160    	; 0x96b4 <netstackIPv6Process+0x266>
	{
	  if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
	  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
	}
	fprintf_P(debugStream, PSTR("\r\n"));
    9754:	00 d0       	rcall	.+0      	; 0x9756 <netstackIPv6Process+0x308>
    9756:	00 d0       	rcall	.+0      	; 0x9758 <netstackIPv6Process+0x30a>
    9758:	80 91 64 0f 	lds	r24, 0x0F64
    975c:	90 91 65 0f 	lds	r25, 0x0F65
    9760:	ad b7       	in	r26, 0x3d	; 61
    9762:	be b7       	in	r27, 0x3e	; 62
    9764:	12 96       	adiw	r26, 0x02	; 2
    9766:	9c 93       	st	X, r25
    9768:	8e 93       	st	-X, r24
    976a:	11 97       	sbiw	r26, 0x01	; 1
    976c:	82 ee       	ldi	r24, 0xE2	; 226
    976e:	95 e1       	ldi	r25, 0x15	; 21
    9770:	14 96       	adiw	r26, 0x04	; 4
    9772:	9c 93       	st	X, r25
    9774:	8e 93       	st	-X, r24
    9776:	13 97       	sbiw	r26, 0x03	; 3
    9778:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
	nicSend(86);
    977c:	0f 90       	pop	r0
    977e:	0f 90       	pop	r0
    9780:	0f 90       	pop	r0
    9782:	0f 90       	pop	r0
    9784:	86 e5       	ldi	r24, 0x56	; 86
    9786:	90 e0       	ldi	r25, 0x00	; 0
    9788:	0e 94 de 31 	call	0x63bc	; 0x63bc <nicSend>
    978c:	14 c0       	rjmp	.+40     	; 0x97b6 <netstackIPv6Process+0x368>
  
  }
  else 
  {
    #if IP_DEBUG
    fprintf_P(debugStream, PSTR("ip: packet shorter than reported in IP header.\n\r"));
    978e:	00 d0       	rcall	.+0      	; 0x9790 <netstackIPv6Process+0x342>
    9790:	00 d0       	rcall	.+0      	; 0x9792 <netstackIPv6Process+0x344>
    9792:	80 91 64 0f 	lds	r24, 0x0F64
    9796:	90 91 65 0f 	lds	r25, 0x0F65
    979a:	ed b7       	in	r30, 0x3d	; 61
    979c:	fe b7       	in	r31, 0x3e	; 62
    979e:	92 83       	std	Z+2, r25	; 0x02
    97a0:	81 83       	std	Z+1, r24	; 0x01
    97a2:	81 eb       	ldi	r24, 0xB1	; 177
    97a4:	95 e1       	ldi	r25, 0x15	; 21
    97a6:	94 83       	std	Z+4, r25	; 0x04
    97a8:	83 83       	std	Z+3, r24	; 0x03
    97aa:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    97ae:	0f 90       	pop	r0
    97b0:	0f 90       	pop	r0
    97b2:	0f 90       	pop	r0
    97b4:	0f 90       	pop	r0
    #endif /*IP_DEBUG*/  
  }
   
}
    97b6:	df 91       	pop	r29
    97b8:	cf 91       	pop	r28
    97ba:	1f 91       	pop	r17
    97bc:	ff 90       	pop	r15
    97be:	ef 90       	pop	r14
    97c0:	df 90       	pop	r13
    97c2:	cf 90       	pop	r12
    97c4:	08 95       	ret

000097c6 <vICMP6DebugInit>:
static uip_ipaddr_t tmp_ipaddr;


void vICMP6DebugInit(FILE *stream)
{
  debugStream = stream;
    97c6:	90 93 65 0f 	sts	0x0F65, r25
    97ca:	80 93 64 0f 	sts	0x0F64, r24
}
    97ce:	08 95       	ret

000097d0 <uip_icmp6_echo_request_input>:

void
uip_icmp6_echo_request_input(void)
{
    97d0:	0f 93       	push	r16
    97d2:	1f 93       	push	r17
   * we send an echo reply. It is trivial if there was no extension
   * headers in the request otherwise we need to remove the extension
   * headers and change a few fields
   */
  
  fprintf_P(debugStream, PSTR("Echo request\n\r"));
    97d4:	00 d0       	rcall	.+0      	; 0x97d6 <uip_icmp6_echo_request_input+0x6>
    97d6:	00 d0       	rcall	.+0      	; 0x97d8 <uip_icmp6_echo_request_input+0x8>
    97d8:	80 91 64 0f 	lds	r24, 0x0F64
    97dc:	90 91 65 0f 	lds	r25, 0x0F65
    97e0:	ed b7       	in	r30, 0x3d	; 61
    97e2:	fe b7       	in	r31, 0x3e	; 62
    97e4:	92 83       	std	Z+2, r25	; 0x02
    97e6:	81 83       	std	Z+1, r24	; 0x01
    97e8:	84 e4       	ldi	r24, 0x44	; 68
    97ea:	96 e1       	ldi	r25, 0x16	; 22
    97ec:	94 83       	std	Z+4, r25	; 0x04
    97ee:	83 83       	std	Z+3, r24	; 0x03
    97f0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  
  /* IP header */
  //UIP_IP_BUF->ttl = uip_netif_physical_if.cur_hop_limit;
  UIP_IP_BUF->ttl = 64;
    97f4:	e0 91 9d 0e 	lds	r30, 0x0E9D
    97f8:	f0 91 9e 0e 	lds	r31, 0x0E9E
    97fc:	80 e4       	ldi	r24, 0x40	; 64
    97fe:	85 8b       	std	Z+21, r24	; 0x15
    */
    //uip_ipaddr_copy(&tmp_ipaddr, &UIP_IP_BUF->srcipaddr);
    //uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
    //uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &tmp_ipaddr);
    
    memcpy(&tmp_ipaddr, &UIP_IP_BUF->srcipaddr, sizeof(uip_ip6addr_t));
    9800:	a3 e9       	ldi	r26, 0x93	; 147
    9802:	b1 e0       	ldi	r27, 0x01	; 1
    9804:	76 96       	adiw	r30, 0x16	; 22
    9806:	80 e1       	ldi	r24, 0x10	; 16
    9808:	01 90       	ld	r0, Z+
    980a:	0d 92       	st	X+, r0
    980c:	81 50       	subi	r24, 0x01	; 1
    980e:	e1 f7       	brne	.-8      	; 0x9808 <uip_icmp6_echo_request_input+0x38>
    memcpy(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr, sizeof(uip_ip6addr_t));
    9810:	80 91 9d 0e 	lds	r24, 0x0E9D
    9814:	90 91 9e 0e 	lds	r25, 0x0E9E
    9818:	dc 01       	movw	r26, r24
    981a:	56 96       	adiw	r26, 0x16	; 22
    981c:	fc 01       	movw	r30, r24
    981e:	b6 96       	adiw	r30, 0x26	; 38
    9820:	80 e1       	ldi	r24, 0x10	; 16
    9822:	01 90       	ld	r0, Z+
    9824:	0d 92       	st	X+, r0
    9826:	81 50       	subi	r24, 0x01	; 1
    9828:	e1 f7       	brne	.-8      	; 0x9822 <uip_icmp6_echo_request_input+0x52>
    memcpy(&UIP_IP_BUF->destipaddr, &tmp_ipaddr, sizeof(uip_ip6addr_t));
    982a:	e0 91 9d 0e 	lds	r30, 0x0E9D
    982e:	f0 91 9e 0e 	lds	r31, 0x0E9E
    9832:	b6 96       	adiw	r30, 0x26	; 38
    9834:	a3 e9       	ldi	r26, 0x93	; 147
    9836:	b1 e0       	ldi	r27, 0x01	; 1
    9838:	80 e1       	ldi	r24, 0x10	; 16
    983a:	0d 90       	ld	r0, X+
    983c:	01 92       	st	Z+, r0
    983e:	81 50       	subi	r24, 0x01	; 1
    9840:	e1 f7       	brne	.-8      	; 0x983a <uip_icmp6_echo_request_input+0x6a>
  /* Below is important for the correctness of UIP_ICMP_BUF and the
   * checksum
   *
  uip_ext_len = 0;
  /* Note: now UIP_ICMP_BUF points to the beginning of the echo reply */
  UIP_ICMP_BUF->type = ICMP6_ECHO_REPLY;
    9842:	80 91 69 0f 	lds	r24, 0x0F69
    9846:	90 e0       	ldi	r25, 0x00	; 0
    9848:	c6 96       	adiw	r24, 0x36	; 54
    984a:	e0 91 9d 0e 	lds	r30, 0x0E9D
    984e:	f0 91 9e 0e 	lds	r31, 0x0E9E
    9852:	e8 0f       	add	r30, r24
    9854:	f9 1f       	adc	r31, r25
    9856:	21 e8       	ldi	r18, 0x81	; 129
    9858:	20 83       	st	Z, r18
  UIP_ICMP_BUF->icode = 0;
    985a:	e0 91 9d 0e 	lds	r30, 0x0E9D
    985e:	f0 91 9e 0e 	lds	r31, 0x0E9E
    9862:	e8 0f       	add	r30, r24
    9864:	f9 1f       	adc	r31, r25
    9866:	11 82       	std	Z+1, r1	; 0x01
  UIP_ICMP_BUF->icmpchksum = 0;
    9868:	00 91 9d 0e 	lds	r16, 0x0E9D
    986c:	10 91 9e 0e 	lds	r17, 0x0E9E
    9870:	08 0f       	add	r16, r24
    9872:	19 1f       	adc	r17, r25
    9874:	f8 01       	movw	r30, r16
    9876:	13 82       	std	Z+3, r1	; 0x03
    9878:	12 82       	std	Z+2, r1	; 0x02
  UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();
    987a:	0f 90       	pop	r0
    987c:	0f 90       	pop	r0
    987e:	0f 90       	pop	r0
    9880:	0f 90       	pop	r0
    9882:	0e 94 71 4c 	call	0x98e2	; 0x98e2 <uip_icmp6chksum>
    9886:	80 95       	com	r24
    9888:	90 95       	com	r25
    988a:	f8 01       	movw	r30, r16
    988c:	93 83       	std	Z+3, r25	; 0x03
    988e:	82 83       	std	Z+2, r24	; 0x02
 
 
  return;
}
    9890:	1f 91       	pop	r17
    9892:	0f 91       	pop	r16
    9894:	08 95       	ret

00009896 <chksum>:
#define BUF ((struct uip_ipv6_hdr *)&nicState.layer2.buf[ETH_HEADER_LEN]) 

/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    9896:	9c 01       	movw	r18, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    9898:	41 50       	subi	r20, 0x01	; 1
    989a:	50 40       	sbci	r21, 0x00	; 0
    989c:	46 0f       	add	r20, r22
    989e:	57 1f       	adc	r21, r23
    98a0:	fb 01       	movw	r30, r22
    98a2:	0e c0       	rjmp	.+28     	; 0x98c0 <chksum+0x2a>
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    98a4:	70 81       	ld	r23, Z
    98a6:	60 e0       	ldi	r22, 0x00	; 0
    98a8:	81 81       	ldd	r24, Z+1	; 0x01
    98aa:	db 01       	movw	r26, r22
    98ac:	a8 0f       	add	r26, r24
    98ae:	b1 1d       	adc	r27, r1
    sum += t;
    98b0:	2a 0f       	add	r18, r26
    98b2:	3b 1f       	adc	r19, r27
    if(sum < t) {
    98b4:	2a 17       	cp	r18, r26
    98b6:	3b 07       	cpc	r19, r27
    98b8:	10 f4       	brcc	.+4      	; 0x98be <chksum+0x28>
      sum++;		/* carry */
    98ba:	2f 5f       	subi	r18, 0xFF	; 255
    98bc:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    98be:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    98c0:	e4 17       	cp	r30, r20
    98c2:	f5 07       	cpc	r31, r21
    98c4:	78 f3       	brcs	.-34     	; 0x98a4 <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    98c6:	e4 17       	cp	r30, r20
    98c8:	f5 07       	cpc	r31, r21
    98ca:	49 f4       	brne	.+18     	; 0x98de <chksum+0x48>
    t = (dataptr[0] << 8) + 0;
    98cc:	90 81       	ld	r25, Z
    98ce:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    98d0:	28 0f       	add	r18, r24
    98d2:	39 1f       	adc	r19, r25
    if(sum < t) {
    98d4:	28 17       	cp	r18, r24
    98d6:	39 07       	cpc	r19, r25
    98d8:	10 f4       	brcc	.+4      	; 0x98de <chksum+0x48>
      sum++;		/* carry */
    98da:	2f 5f       	subi	r18, 0xFF	; 255
    98dc:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    98de:	c9 01       	movw	r24, r18
    98e0:	08 95       	ret

000098e2 <uip_icmp6chksum>:
}
/*---------------------------------------------------------------------------*/
#if UIP_CONF_IPV6
u16_t
uip_icmp6chksum(void)
{
    98e2:	0f 93       	push	r16
    98e4:	1f 93       	push	r17
{
  u16_t upper_layer_len;
  u16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
    98e6:	60 91 9d 0e 	lds	r22, 0x0E9D
    98ea:	70 91 9e 0e 	lds	r23, 0x0E9E
    98ee:	fb 01       	movw	r30, r22
    98f0:	3e 96       	adiw	r30, 0x0e	; 14
    98f2:	14 81       	ldd	r17, Z+4	; 0x04
    98f4:	00 e0       	ldi	r16, 0x00	; 0
    98f6:	85 81       	ldd	r24, Z+5	; 0x05
    98f8:	08 0f       	add	r16, r24
    98fa:	11 1d       	adc	r17, r1
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    98fc:	6a 5e       	subi	r22, 0xEA	; 234
    98fe:	7f 4f       	sbci	r23, 0xFF	; 255
    9900:	c8 01       	movw	r24, r16
    9902:	ca 96       	adiw	r24, 0x3a	; 58
    9904:	40 e2       	ldi	r20, 0x20	; 32
    9906:	50 e0       	ldi	r21, 0x00	; 0
    9908:	0e 94 4b 4c 	call	0x9896	; 0x9896 <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &nicState.layer2.buf[UIP_IPH_LEN + ETH_HEADER_LEN],
    990c:	60 91 9d 0e 	lds	r22, 0x0E9D
    9910:	70 91 9e 0e 	lds	r23, 0x0E9E
    9914:	6a 5c       	subi	r22, 0xCA	; 202
    9916:	7f 4f       	sbci	r23, 0xFF	; 255
    9918:	a8 01       	movw	r20, r16
    991a:	0e 94 4b 4c 	call	0x9896	; 0x9896 <chksum>
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
    991e:	00 97       	sbiw	r24, 0x00	; 0
    9920:	19 f4       	brne	.+6      	; 0x9928 <uip_icmp6chksum+0x46>
    9922:	2f ef       	ldi	r18, 0xFF	; 255
    9924:	3f ef       	ldi	r19, 0xFF	; 255
    9926:	03 c0       	rjmp	.+6      	; 0x992e <uip_icmp6chksum+0x4c>
    9928:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    992c:	9c 01       	movw	r18, r24
u16_t
uip_icmp6chksum(void)
{
  return upper_layer_chksum(UIP_PROTO_ICMP6);
  
}
    992e:	c9 01       	movw	r24, r18
    9930:	1f 91       	pop	r17
    9932:	0f 91       	pop	r16
    9934:	08 95       	ret

00009936 <uip_ipchksum>:
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &nicState.layer2.buf[ETH_HEADER_LEN], UIP_IPH_LEN);
    9936:	60 91 9d 0e 	lds	r22, 0x0E9D
    993a:	70 91 9e 0e 	lds	r23, 0x0E9E
    993e:	62 5f       	subi	r22, 0xF2	; 242
    9940:	7f 4f       	sbci	r23, 0xFF	; 255
    9942:	80 e0       	ldi	r24, 0x00	; 0
    9944:	90 e0       	ldi	r25, 0x00	; 0
    9946:	48 e2       	ldi	r20, 0x28	; 40
    9948:	50 e0       	ldi	r21, 0x00	; 0
    994a:	0e 94 4b 4c 	call	0x9896	; 0x9896 <chksum>
  //DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    994e:	00 97       	sbiw	r24, 0x00	; 0
    9950:	19 f4       	brne	.+6      	; 0x9958 <uip_ipchksum+0x22>
    9952:	2f ef       	ldi	r18, 0xFF	; 255
    9954:	3f ef       	ldi	r19, 0xFF	; 255
    9956:	03 c0       	rjmp	.+6      	; 0x995e <uip_ipchksum+0x28>
    9958:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    995c:	9c 01       	movw	r18, r24
}
    995e:	c9 01       	movw	r24, r18
    9960:	08 95       	ret

00009962 <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
    9962:	9c 01       	movw	r18, r24
    9964:	ab 01       	movw	r20, r22
  return htons(chksum(0, (u8_t *)data, len));
    9966:	80 e0       	ldi	r24, 0x00	; 0
    9968:	90 e0       	ldi	r25, 0x00	; 0
    996a:	b9 01       	movw	r22, r18
    996c:	0e 94 4b 4c 	call	0x9896	; 0x9896 <chksum>
    9970:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
}
    9974:	08 95       	ret

00009976 <uip_netif_addr_lookup>:
#endif
}

/*---------------------------------------------------------------------------*/
struct uip_netif_addr *uip_netif_addr_lookup(uip_ipaddr_t *ipaddr, u8_t length, uip_netif_type type) 
{
    9976:	ef 92       	push	r14
    9978:	ff 92       	push	r15
    997a:	0f 93       	push	r16
    997c:	1f 93       	push	r17
    997e:	cf 93       	push	r28
    9980:	df 93       	push	r29
    9982:	7c 01       	movw	r14, r24
    9984:	06 2f       	mov	r16, r22
    9986:	14 2f       	mov	r17, r20
    uint8_t i;
    for(i = 0; i < UIP_CONF_NETIF_MAX_ADDRESSES; i ++) {
    if((uip_netif_physical_if->addresses[i].state != NOT_USED) &&
    9988:	c0 91 8f 0e 	lds	r28, 0x0E8F
    998c:	d0 91 90 0e 	lds	r29, 0x0E90
    9990:	06 95       	lsr	r16
    9992:	06 95       	lsr	r16
    9994:	06 95       	lsr	r16
    9996:	8a a1       	ldd	r24, Y+34	; 0x22
    9998:	8f 3f       	cpi	r24, 0xFF	; 255
    999a:	81 f0       	breq	.+32     	; 0x99bc <uip_netif_addr_lookup+0x46>
    999c:	8c a1       	ldd	r24, Y+36	; 0x24
    999e:	84 17       	cp	r24, r20
    99a0:	59 f4       	brne	.+22     	; 0x99b8 <uip_netif_addr_lookup+0x42>
    99a2:	ce 01       	movw	r24, r28
    99a4:	42 96       	adiw	r24, 0x12	; 18
    99a6:	b7 01       	movw	r22, r14
    99a8:	40 2f       	mov	r20, r16
    99aa:	50 e0       	ldi	r21, 0x00	; 0
    99ac:	0e 94 4d 74 	call	0xe89a	; 0xe89a <memcmp>
    99b0:	00 97       	sbiw	r24, 0x00	; 0
    99b2:	21 f4       	brne	.+8      	; 0x99bc <uip_netif_addr_lookup+0x46>
    99b4:	90 e0       	ldi	r25, 0x00	; 0
    99b6:	14 c0       	rjmp	.+40     	; 0x99e0 <uip_netif_addr_lookup+0x6a>
    99b8:	44 23       	and	r20, r20
    99ba:	99 f3       	breq	.-26     	; 0x99a2 <uip_netif_addr_lookup+0x2c>
    99bc:	8d a9       	ldd	r24, Y+53	; 0x35
    99be:	8f 3f       	cpi	r24, 0xFF	; 255
    99c0:	c1 f0       	breq	.+48     	; 0x99f2 <uip_netif_addr_lookup+0x7c>
    99c2:	8f a9       	ldd	r24, Y+55	; 0x37
    99c4:	81 17       	cp	r24, r17
    99c6:	11 f0       	breq	.+4      	; 0x99cc <uip_netif_addr_lookup+0x56>
    99c8:	11 23       	and	r17, r17
    99ca:	99 f4       	brne	.+38     	; 0x99f2 <uip_netif_addr_lookup+0x7c>
    99cc:	ce 01       	movw	r24, r28
    99ce:	85 96       	adiw	r24, 0x25	; 37
    99d0:	b7 01       	movw	r22, r14
    99d2:	40 2f       	mov	r20, r16
    99d4:	50 e0       	ldi	r21, 0x00	; 0
    99d6:	0e 94 4d 74 	call	0xe89a	; 0xe89a <memcmp>
    99da:	00 97       	sbiw	r24, 0x00	; 0
    99dc:	51 f4       	brne	.+20     	; 0x99f2 <uip_netif_addr_lookup+0x7c>
    99de:	91 e0       	ldi	r25, 0x01	; 1
       (uip_netif_physical_if->addresses[i].type == type || type == 0) &&
       (uip_ipaddr_prefixcmp(&(uip_netif_physical_if->addresses[i].ipaddr), ipaddr, length))) { 
      return &uip_netif_physical_if->addresses[i]; 
    99e0:	83 e1       	ldi	r24, 0x13	; 19
    99e2:	98 9f       	mul	r25, r24
    99e4:	90 01       	movw	r18, r0
    99e6:	11 24       	eor	r1, r1
    99e8:	2e 5e       	subi	r18, 0xEE	; 238
    99ea:	3f 4f       	sbci	r19, 0xFF	; 255
    99ec:	2c 0f       	add	r18, r28
    99ee:	3d 1f       	adc	r19, r29
    99f0:	03 c0       	rjmp	.+6      	; 0x99f8 <uip_netif_addr_lookup+0x82>
    }
  }
  //return NULL; 
  
  return &uip_netif_physical_if->addresses[0];
    99f2:	9e 01       	movw	r18, r28
    99f4:	2e 5e       	subi	r18, 0xEE	; 238
    99f6:	3f 4f       	sbci	r19, 0xFF	; 255
  
  return NULL; 
}
    99f8:	c9 01       	movw	r24, r18
    99fa:	df 91       	pop	r29
    99fc:	cf 91       	pop	r28
    99fe:	1f 91       	pop	r17
    9a00:	0f 91       	pop	r16
    9a02:	ff 90       	pop	r15
    9a04:	ef 90       	pop	r14
    9a06:	08 95       	ret

00009a08 <uip_netif_addr_autoconf_set>:
   /* Find router (send rs to all-routers multicast group)) */
  //uip_netif_sched_send_rs();   
}

void uip_netif_addr_autoconf_set(uip_ipaddr_t *ipaddr, struct netEthAddr *lladdr)
{
    9a08:	cf 93       	push	r28
    9a0a:	df 93       	push	r29
    9a0c:	fc 01       	movw	r30, r24
     IEEE 48-bit MAC addresses */
#if (UIP_LLADDR_LEN == 8)
  memcpy(ipaddr->u8 + 8, lladdr->addr, UIP_LLADDR_LEN);
  ipaddr->u8[8] ^= 0x02;  
#elif (UIP_LLADDR_LEN == 6)
  memcpy(ipaddr->u8 + 8, lladdr->addr, 3);
    9a0e:	ec 01       	movw	r28, r24
    9a10:	28 96       	adiw	r28, 0x08	; 8
    9a12:	db 01       	movw	r26, r22
    9a14:	83 e0       	ldi	r24, 0x03	; 3
    9a16:	0d 90       	ld	r0, X+
    9a18:	09 92       	st	Y+, r0
    9a1a:	81 50       	subi	r24, 0x01	; 1
    9a1c:	e1 f7       	brne	.-8      	; 0x9a16 <uip_netif_addr_autoconf_set+0xe>
  ipaddr->u8[11] = 0xff;
    9a1e:	8f ef       	ldi	r24, 0xFF	; 255
    9a20:	83 87       	std	Z+11, r24	; 0x0b
  ipaddr->u8[12] = 0xfe;
    9a22:	8e ef       	ldi	r24, 0xFE	; 254
    9a24:	84 87       	std	Z+12, r24	; 0x0c
  memcpy(ipaddr->u8 + 13, (u8_t*)lladdr->addr + 3, 3);
    9a26:	ef 01       	movw	r28, r30
    9a28:	2d 96       	adiw	r28, 0x0d	; 13
    9a2a:	db 01       	movw	r26, r22
    9a2c:	13 96       	adiw	r26, 0x03	; 3
    9a2e:	83 e0       	ldi	r24, 0x03	; 3
    9a30:	0d 90       	ld	r0, X+
    9a32:	09 92       	st	Y+, r0
    9a34:	81 50       	subi	r24, 0x01	; 1
    9a36:	e1 f7       	brne	.-8      	; 0x9a30 <uip_netif_addr_autoconf_set+0x28>
  ipaddr->u8[8] ^= 0x02;
    9a38:	80 85       	ldd	r24, Z+8	; 0x08
    9a3a:	92 e0       	ldi	r25, 0x02	; 2
    9a3c:	89 27       	eor	r24, r25
    9a3e:	80 87       	std	Z+8, r24	; 0x08
#else
  //UIP_LOG("CAN NOT BUIL INTERFACE IDENTIFIER");
#endif
}
    9a40:	df 91       	pop	r29
    9a42:	cf 91       	pop	r28
    9a44:	08 95       	ret

00009a46 <uip_netif_init>:
/*---------------------------------------------------------------------------*/


void uip_netif_init(void)
{    
  uip_netif_physical_if = xmalloc(sizeof(struct uip_netif));
    9a46:	88 e4       	ldi	r24, 0x48	; 72
    9a48:	90 e0       	ldi	r25, 0x00	; 0
    9a4a:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    9a4e:	fc 01       	movw	r30, r24
    9a50:	90 93 90 0e 	sts	0x0E90, r25
    9a54:	80 93 8f 0e 	sts	0x0E8F, r24
  /* INITIALIZE INTERFACE (default values for now) */
  uip_netif_physical_if->link_mtu = UIP_LINK_MTU;
    9a58:	80 e0       	ldi	r24, 0x00	; 0
    9a5a:	95 e0       	ldi	r25, 0x05	; 5
    9a5c:	a0 e0       	ldi	r26, 0x00	; 0
    9a5e:	b0 e0       	ldi	r27, 0x00	; 0
    9a60:	80 83       	st	Z, r24
    9a62:	91 83       	std	Z+1, r25	; 0x01
    9a64:	a2 83       	std	Z+2, r26	; 0x02
    9a66:	b3 83       	std	Z+3, r27	; 0x03
  uip_netif_physical_if->cur_hop_limit = UIP_TTL;
    9a68:	80 e8       	ldi	r24, 0x80	; 128
    9a6a:	84 83       	std	Z+4, r24	; 0x04
  uip_netif_physical_if->base_reachable_time = UIP_ND6_REACHABLE_TIME;
    9a6c:	80 e3       	ldi	r24, 0x30	; 48
    9a6e:	95 e7       	ldi	r25, 0x75	; 117
    9a70:	a0 e0       	ldi	r26, 0x00	; 0
    9a72:	b0 e0       	ldi	r27, 0x00	; 0
    9a74:	85 83       	std	Z+5, r24	; 0x05
    9a76:	96 83       	std	Z+6, r25	; 0x06
    9a78:	a7 83       	std	Z+7, r26	; 0x07
    9a7a:	b0 87       	std	Z+8, r27	; 0x08
  uip_netif_physical_if->reachable_time = 0;//uip_netif_compute_reachable_time(); //to trzeba zmieni w przypadku potrowania cago ND
    9a7c:	11 86       	std	Z+9, r1	; 0x09
    9a7e:	12 86       	std	Z+10, r1	; 0x0a
    9a80:	13 86       	std	Z+11, r1	; 0x0b
    9a82:	14 86       	std	Z+12, r1	; 0x0c
  uip_netif_physical_if->retrans_timer = UIP_ND6_RETRANS_TIMER;
    9a84:	88 ee       	ldi	r24, 0xE8	; 232
    9a86:	93 e0       	ldi	r25, 0x03	; 3
    9a88:	a0 e0       	ldi	r26, 0x00	; 0
    9a8a:	b0 e0       	ldi	r27, 0x00	; 0
    9a8c:	85 87       	std	Z+13, r24	; 0x0d
    9a8e:	96 87       	std	Z+14, r25	; 0x0e
    9a90:	a7 87       	std	Z+15, r26	; 0x0f
    9a92:	b0 8b       	std	Z+16, r27	; 0x10
  uip_netif_physical_if->dup_addr_detect_transmit = 0;
    9a94:	11 8a       	std	Z+17, r1	; 0x11

  /*
   * STATELESS AUTOCONFIGURATION of the link local address. We set it to 
   * infinite (this will become really true once DAD succeeds)
   */
  uip_ip6addr(&(uip_netif_physical_if->addresses[0].ipaddr),
    9a96:	8e ef       	ldi	r24, 0xFE	; 254
    9a98:	90 e8       	ldi	r25, 0x80	; 128
    9a9a:	93 8b       	std	Z+19, r25	; 0x13
    9a9c:	82 8b       	std	Z+18, r24	; 0x12
    9a9e:	15 8a       	std	Z+21, r1	; 0x15
    9aa0:	14 8a       	std	Z+20, r1	; 0x14
    9aa2:	17 8a       	std	Z+23, r1	; 0x17
    9aa4:	16 8a       	std	Z+22, r1	; 0x16
    9aa6:	11 8e       	std	Z+25, r1	; 0x19
    9aa8:	10 8e       	std	Z+24, r1	; 0x18
    9aaa:	13 8e       	std	Z+27, r1	; 0x1b
    9aac:	12 8e       	std	Z+26, r1	; 0x1a
    9aae:	15 8e       	std	Z+29, r1	; 0x1d
    9ab0:	14 8e       	std	Z+28, r1	; 0x1c
    9ab2:	17 8e       	std	Z+31, r1	; 0x1f
    9ab4:	16 8e       	std	Z+30, r1	; 0x1e
    9ab6:	11 a2       	std	Z+33, r1	; 0x21
    9ab8:	10 a2       	std	Z+32, r1	; 0x20
              0xfe80,0,0,0,0,0,0,0);
  uip_netif_addr_autoconf_set(&(uip_netif_physical_if->addresses[0].ipaddr), &nicState.mac.addr);
    9aba:	cf 01       	movw	r24, r30
    9abc:	42 96       	adiw	r24, 0x12	; 18
    9abe:	67 e9       	ldi	r22, 0x97	; 151
    9ac0:	7e e0       	ldi	r23, 0x0E	; 14
    9ac2:	0e 94 04 4d 	call	0x9a08	; 0x9a08 <uip_netif_addr_autoconf_set>
  uip_netif_physical_if->addresses[0].state = TENTATIVE; 
    9ac6:	e0 91 8f 0e 	lds	r30, 0x0E8F
    9aca:	f0 91 90 0e 	lds	r31, 0x0E90
    9ace:	12 a2       	std	Z+34, r1	; 0x22
  uip_netif_physical_if->addresses[0].type = MANUAL;
    9ad0:	83 e0       	ldi	r24, 0x03	; 3
    9ad2:	84 a3       	std	Z+36, r24	; 0x24
  uip_netif_physical_if->addresses[0].is_infinite = 1;
    9ad4:	21 e0       	ldi	r18, 0x01	; 1
    9ad6:	23 a3       	std	Z+35, r18	; 0x23
 
  /* set all other addresses to NOT_USED initialy */
  uint8_t i;
  for(i = 1; i < UIP_CONF_NETIF_MAX_ADDRESSES; i ++)
    uip_netif_physical_if->addresses[i].state = NOT_USED;  
    9ad8:	9f ef       	ldi	r25, 0xFF	; 255
    9ada:	95 ab       	std	Z+53, r25	; 0x35
 
  uip_ip6addr_u8(&(uip_netif_physical_if->solicited_node_mcastaddr),
    9adc:	90 af       	std	Z+56, r25	; 0x38
    9ade:	82 e0       	ldi	r24, 0x02	; 2
    9ae0:	81 af       	std	Z+57, r24	; 0x39
    9ae2:	12 ae       	std	Z+58, r1	; 0x3a
    9ae4:	13 ae       	std	Z+59, r1	; 0x3b
    9ae6:	14 ae       	std	Z+60, r1	; 0x3c
    9ae8:	15 ae       	std	Z+61, r1	; 0x3d
    9aea:	16 ae       	std	Z+62, r1	; 0x3e
    9aec:	17 ae       	std	Z+63, r1	; 0x3f
    9aee:	e0 5c       	subi	r30, 0xC0	; 192
    9af0:	ff 4f       	sbci	r31, 0xFF	; 255
    9af2:	11 92       	st	Z+, r1
    9af4:	11 92       	st	Z+, r1
    9af6:	11 92       	st	Z+, r1
    9af8:	21 93       	st	Z+, r18
    9afa:	91 93       	st	Z+, r25
    9afc:	80 91 9a 0e 	lds	r24, 0x0E9A
    9b00:	81 93       	st	Z+, r24
    9b02:	80 91 9b 0e 	lds	r24, 0x0E9B
    9b06:	81 93       	st	Z+, r24
    9b08:	80 91 9c 0e 	lds	r24, 0x0E9C
    9b0c:	80 83       	st	Z, r24
		 nicState.mac.addr[3],
		 nicState.mac.addr[4],
		 nicState.mac.addr[5]);
   /* Find router (send rs to all-routers multicast group)) */
  //uip_netif_sched_send_rs();   
}
    9b0e:	08 95       	ret

00009b10 <vNDDebugInit>:
}

#if IP_DEBUG
void vNDDebugInit(FILE *stream)
{
  debugStream = stream;
    9b10:	90 93 65 0f 	sts	0x0F65, r25
    9b14:	80 93 64 0f 	sts	0x0F64, r24
}
    9b18:	08 95       	ret

00009b1a <vNDinit>:
/** \brief Pointer to an interface address */
static struct uip_netif_addr *ifaddr;

void vNDinit(void)
{
  entries = xmalloc( ENTRIES * sizeof(neighbor_entry));
    9b1a:	80 ed       	ldi	r24, 0xD0	; 208
    9b1c:	90 e0       	ldi	r25, 0x00	; 0
    9b1e:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    9b22:	90 93 7b 0f 	sts	0x0F7B, r25
    9b26:	80 93 7a 0f 	sts	0x0F7A, r24
  #if IP_DEBUG
  fprintf_P(debugStream, PSTR("ENTRIES %d %d:"), ENTRIES, sizeof(neighbor_entry));
    9b2a:	2d b7       	in	r18, 0x3d	; 61
    9b2c:	3e b7       	in	r19, 0x3e	; 62
    9b2e:	28 50       	subi	r18, 0x08	; 8
    9b30:	30 40       	sbci	r19, 0x00	; 0
    9b32:	0f b6       	in	r0, 0x3f	; 63
    9b34:	f8 94       	cli
    9b36:	3e bf       	out	0x3e, r19	; 62
    9b38:	0f be       	out	0x3f, r0	; 63
    9b3a:	2d bf       	out	0x3d, r18	; 61
    9b3c:	ed b7       	in	r30, 0x3d	; 61
    9b3e:	fe b7       	in	r31, 0x3e	; 62
    9b40:	31 96       	adiw	r30, 0x01	; 1
    9b42:	80 91 64 0f 	lds	r24, 0x0F64
    9b46:	90 91 65 0f 	lds	r25, 0x0F65
    9b4a:	ad b7       	in	r26, 0x3d	; 61
    9b4c:	be b7       	in	r27, 0x3e	; 62
    9b4e:	12 96       	adiw	r26, 0x02	; 2
    9b50:	9c 93       	st	X, r25
    9b52:	8e 93       	st	-X, r24
    9b54:	11 97       	sbiw	r26, 0x01	; 1
    9b56:	8f ef       	ldi	r24, 0xFF	; 255
    9b58:	9c e1       	ldi	r25, 0x1C	; 28
    9b5a:	93 83       	std	Z+3, r25	; 0x03
    9b5c:	82 83       	std	Z+2, r24	; 0x02
    9b5e:	88 e0       	ldi	r24, 0x08	; 8
    9b60:	90 e0       	ldi	r25, 0x00	; 0
    9b62:	95 83       	std	Z+5, r25	; 0x05
    9b64:	84 83       	std	Z+4, r24	; 0x04
    9b66:	8a e1       	ldi	r24, 0x1A	; 26
    9b68:	90 e0       	ldi	r25, 0x00	; 0
    9b6a:	97 83       	std	Z+7, r25	; 0x07
    9b6c:	86 83       	std	Z+6, r24	; 0x06
    9b6e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    9b72:	e0 91 7a 0f 	lds	r30, 0x0F7A
    9b76:	f0 91 7b 0f 	lds	r31, 0x0F7B
    9b7a:	80 e0       	ldi	r24, 0x00	; 0
    9b7c:	2d b7       	in	r18, 0x3d	; 61
    9b7e:	3e b7       	in	r19, 0x3e	; 62
    9b80:	28 5f       	subi	r18, 0xF8	; 248
    9b82:	3f 4f       	sbci	r19, 0xFF	; 255
    9b84:	0f b6       	in	r0, 0x3f	; 63
    9b86:	f8 94       	cli
    9b88:	3e bf       	out	0x3e, r19	; 62
    9b8a:	0f be       	out	0x3f, r0	; 63
    9b8c:	2d bf       	out	0x3d, r18	; 61
  #endif/**IP_DEBUG*/
  
  for(uint8_t i = 0; i < ENTRIES; ++i) {
    entries[i].time = 0;
    9b8e:	16 8a       	std	Z+22, r1	; 0x16
    9b90:	17 8a       	std	Z+23, r1	; 0x17
    9b92:	10 8e       	std	Z+24, r1	; 0x18
    9b94:	11 8e       	std	Z+25, r1	; 0x19
  entries = xmalloc( ENTRIES * sizeof(neighbor_entry));
  #if IP_DEBUG
  fprintf_P(debugStream, PSTR("ENTRIES %d %d:"), ENTRIES, sizeof(neighbor_entry));
  #endif/**IP_DEBUG*/
  
  for(uint8_t i = 0; i < ENTRIES; ++i) {
    9b96:	8f 5f       	subi	r24, 0xFF	; 255
    9b98:	7a 96       	adiw	r30, 0x1a	; 26
    9b9a:	88 30       	cpi	r24, 0x08	; 8
    9b9c:	c1 f7       	brne	.-16     	; 0x9b8e <vNDinit+0x74>
    entries[i].time = 0;
  }
}
    9b9e:	08 95       	ret

00009ba0 <uip_nd6_io_ns_input>:
}
/*---------------------------------------------------------------------------*/
#endif /*JM*/

void uip_nd6_io_ns_input(uint16_t packetLenght)
{
    9ba0:	af 92       	push	r10
    9ba2:	bf 92       	push	r11
    9ba4:	cf 92       	push	r12
    9ba6:	df 92       	push	r13
    9ba8:	ef 92       	push	r14
    9baa:	ff 92       	push	r15
    9bac:	0f 93       	push	r16
    9bae:	1f 93       	push	r17
    9bb0:	cf 93       	push	r28
    9bb2:	df 93       	push	r29
    9bb4:	5c 01       	movw	r10, r24
  
  fprintf_P(debugStream, PSTR("Received NS from\n\r"));
    9bb6:	00 d0       	rcall	.+0      	; 0x9bb8 <uip_nd6_io_ns_input+0x18>
    9bb8:	00 d0       	rcall	.+0      	; 0x9bba <uip_nd6_io_ns_input+0x1a>
    9bba:	80 91 64 0f 	lds	r24, 0x0F64
    9bbe:	90 91 65 0f 	lds	r25, 0x0F65
    9bc2:	ad b7       	in	r26, 0x3d	; 61
    9bc4:	be b7       	in	r27, 0x3e	; 62
    9bc6:	12 96       	adiw	r26, 0x02	; 2
    9bc8:	9c 93       	st	X, r25
    9bca:	8e 93       	st	-X, r24
    9bcc:	11 97       	sbiw	r26, 0x01	; 1
    9bce:	8c ee       	ldi	r24, 0xEC	; 236
    9bd0:	9c e1       	ldi	r25, 0x1C	; 28
    9bd2:	14 96       	adiw	r26, 0x04	; 4
    9bd4:	9c 93       	st	X, r25
    9bd6:	8e 93       	st	-X, r24
    9bd8:	13 97       	sbiw	r26, 0x03	; 3
    9bda:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINT6ADDR(debugStream, &nicState.layer3.ipv6->srcipaddr);
    9bde:	a0 91 9f 0e 	lds	r26, 0x0E9F
    9be2:	b0 91 a0 0e 	lds	r27, 0x0EA0
    9be6:	cd b7       	in	r28, 0x3d	; 61
    9be8:	de b7       	in	r29, 0x3e	; 62
    9bea:	a0 97       	sbiw	r28, 0x20	; 32
    9bec:	0f b6       	in	r0, 0x3f	; 63
    9bee:	f8 94       	cli
    9bf0:	de bf       	out	0x3e, r29	; 62
    9bf2:	0f be       	out	0x3f, r0	; 63
    9bf4:	cd bf       	out	0x3d, r28	; 61
    9bf6:	ed b7       	in	r30, 0x3d	; 61
    9bf8:	fe b7       	in	r31, 0x3e	; 62
    9bfa:	31 96       	adiw	r30, 0x01	; 1
    9bfc:	80 91 64 0f 	lds	r24, 0x0F64
    9c00:	90 91 65 0f 	lds	r25, 0x0F65
    9c04:	9a 83       	std	Y+2, r25	; 0x02
    9c06:	89 83       	std	Y+1, r24	; 0x01
    9c08:	85 e9       	ldi	r24, 0x95	; 149
    9c0a:	9c e1       	ldi	r25, 0x1C	; 28
    9c0c:	93 83       	std	Z+3, r25	; 0x03
    9c0e:	82 83       	std	Z+2, r24	; 0x02
    9c10:	18 96       	adiw	r26, 0x08	; 8
    9c12:	8c 91       	ld	r24, X
    9c14:	18 97       	sbiw	r26, 0x08	; 8
    9c16:	84 83       	std	Z+4, r24	; 0x04
    9c18:	15 82       	std	Z+5, r1	; 0x05
    9c1a:	19 96       	adiw	r26, 0x09	; 9
    9c1c:	8c 91       	ld	r24, X
    9c1e:	19 97       	sbiw	r26, 0x09	; 9
    9c20:	86 83       	std	Z+6, r24	; 0x06
    9c22:	17 82       	std	Z+7, r1	; 0x07
    9c24:	1a 96       	adiw	r26, 0x0a	; 10
    9c26:	8c 91       	ld	r24, X
    9c28:	1a 97       	sbiw	r26, 0x0a	; 10
    9c2a:	80 87       	std	Z+8, r24	; 0x08
    9c2c:	11 86       	std	Z+9, r1	; 0x09
    9c2e:	1b 96       	adiw	r26, 0x0b	; 11
    9c30:	8c 91       	ld	r24, X
    9c32:	1b 97       	sbiw	r26, 0x0b	; 11
    9c34:	82 87       	std	Z+10, r24	; 0x0a
    9c36:	13 86       	std	Z+11, r1	; 0x0b
    9c38:	1c 96       	adiw	r26, 0x0c	; 12
    9c3a:	8c 91       	ld	r24, X
    9c3c:	1c 97       	sbiw	r26, 0x0c	; 12
    9c3e:	84 87       	std	Z+12, r24	; 0x0c
    9c40:	15 86       	std	Z+13, r1	; 0x0d
    9c42:	1d 96       	adiw	r26, 0x0d	; 13
    9c44:	8c 91       	ld	r24, X
    9c46:	1d 97       	sbiw	r26, 0x0d	; 13
    9c48:	86 87       	std	Z+14, r24	; 0x0e
    9c4a:	17 86       	std	Z+15, r1	; 0x0f
    9c4c:	1e 96       	adiw	r26, 0x0e	; 14
    9c4e:	8c 91       	ld	r24, X
    9c50:	1e 97       	sbiw	r26, 0x0e	; 14
    9c52:	80 8b       	std	Z+16, r24	; 0x10
    9c54:	11 8a       	std	Z+17, r1	; 0x11
    9c56:	1f 96       	adiw	r26, 0x0f	; 15
    9c58:	8c 91       	ld	r24, X
    9c5a:	1f 97       	sbiw	r26, 0x0f	; 15
    9c5c:	82 8b       	std	Z+18, r24	; 0x12
    9c5e:	13 8a       	std	Z+19, r1	; 0x13
    9c60:	50 96       	adiw	r26, 0x10	; 16
    9c62:	8c 91       	ld	r24, X
    9c64:	50 97       	sbiw	r26, 0x10	; 16
    9c66:	84 8b       	std	Z+20, r24	; 0x14
    9c68:	15 8a       	std	Z+21, r1	; 0x15
    9c6a:	51 96       	adiw	r26, 0x11	; 17
    9c6c:	8c 91       	ld	r24, X
    9c6e:	51 97       	sbiw	r26, 0x11	; 17
    9c70:	86 8b       	std	Z+22, r24	; 0x16
    9c72:	17 8a       	std	Z+23, r1	; 0x17
    9c74:	52 96       	adiw	r26, 0x12	; 18
    9c76:	8c 91       	ld	r24, X
    9c78:	52 97       	sbiw	r26, 0x12	; 18
    9c7a:	80 8f       	std	Z+24, r24	; 0x18
    9c7c:	11 8e       	std	Z+25, r1	; 0x19
    9c7e:	53 96       	adiw	r26, 0x13	; 19
    9c80:	8c 91       	ld	r24, X
    9c82:	53 97       	sbiw	r26, 0x13	; 19
    9c84:	82 8f       	std	Z+26, r24	; 0x1a
    9c86:	13 8e       	std	Z+27, r1	; 0x1b
    9c88:	54 96       	adiw	r26, 0x14	; 20
    9c8a:	8c 91       	ld	r24, X
    9c8c:	54 97       	sbiw	r26, 0x14	; 20
    9c8e:	84 8f       	std	Z+28, r24	; 0x1c
    9c90:	15 8e       	std	Z+29, r1	; 0x1d
    9c92:	55 96       	adiw	r26, 0x15	; 21
    9c94:	8c 91       	ld	r24, X
    9c96:	55 97       	sbiw	r26, 0x15	; 21
    9c98:	86 8f       	std	Z+30, r24	; 0x1e
    9c9a:	17 8e       	std	Z+31, r1	; 0x1f
    9c9c:	56 96       	adiw	r26, 0x16	; 22
    9c9e:	8c 91       	ld	r24, X
    9ca0:	56 97       	sbiw	r26, 0x16	; 22
    9ca2:	80 a3       	std	Z+32, r24	; 0x20
    9ca4:	11 a2       	std	Z+33, r1	; 0x21
    9ca6:	57 96       	adiw	r26, 0x17	; 23
    9ca8:	8c 91       	ld	r24, X
    9caa:	82 a3       	std	Z+34, r24	; 0x22
    9cac:	13 a2       	std	Z+35, r1	; 0x23
    9cae:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(debugStream, PSTR("to\n\r"));
    9cb2:	ed b7       	in	r30, 0x3d	; 61
    9cb4:	fe b7       	in	r31, 0x3e	; 62
    9cb6:	b4 96       	adiw	r30, 0x24	; 36
    9cb8:	0f b6       	in	r0, 0x3f	; 63
    9cba:	f8 94       	cli
    9cbc:	fe bf       	out	0x3e, r31	; 62
    9cbe:	0f be       	out	0x3f, r0	; 63
    9cc0:	ed bf       	out	0x3d, r30	; 61
    9cc2:	00 d0       	rcall	.+0      	; 0x9cc4 <uip_nd6_io_ns_input+0x124>
    9cc4:	00 d0       	rcall	.+0      	; 0x9cc6 <uip_nd6_io_ns_input+0x126>
    9cc6:	80 91 64 0f 	lds	r24, 0x0F64
    9cca:	90 91 65 0f 	lds	r25, 0x0F65
    9cce:	ad b7       	in	r26, 0x3d	; 61
    9cd0:	be b7       	in	r27, 0x3e	; 62
    9cd2:	12 96       	adiw	r26, 0x02	; 2
    9cd4:	9c 93       	st	X, r25
    9cd6:	8e 93       	st	-X, r24
    9cd8:	11 97       	sbiw	r26, 0x01	; 1
    9cda:	80 e9       	ldi	r24, 0x90	; 144
    9cdc:	9c e1       	ldi	r25, 0x1C	; 28
    9cde:	14 96       	adiw	r26, 0x04	; 4
    9ce0:	9c 93       	st	X, r25
    9ce2:	8e 93       	st	-X, r24
    9ce4:	13 97       	sbiw	r26, 0x03	; 3
    9ce6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINT6ADDR(debugStream, &nicState.layer3.ipv6->destipaddr);
    9cea:	a0 91 9f 0e 	lds	r26, 0x0E9F
    9cee:	b0 91 a0 0e 	lds	r27, 0x0EA0
    9cf2:	cd b7       	in	r28, 0x3d	; 61
    9cf4:	de b7       	in	r29, 0x3e	; 62
    9cf6:	a0 97       	sbiw	r28, 0x20	; 32
    9cf8:	0f b6       	in	r0, 0x3f	; 63
    9cfa:	f8 94       	cli
    9cfc:	de bf       	out	0x3e, r29	; 62
    9cfe:	0f be       	out	0x3f, r0	; 63
    9d00:	cd bf       	out	0x3d, r28	; 61
    9d02:	ed b7       	in	r30, 0x3d	; 61
    9d04:	fe b7       	in	r31, 0x3e	; 62
    9d06:	31 96       	adiw	r30, 0x01	; 1
    9d08:	80 91 64 0f 	lds	r24, 0x0F64
    9d0c:	90 91 65 0f 	lds	r25, 0x0F65
    9d10:	9a 83       	std	Y+2, r25	; 0x02
    9d12:	89 83       	std	Y+1, r24	; 0x01
    9d14:	89 e3       	ldi	r24, 0x39	; 57
    9d16:	9c e1       	ldi	r25, 0x1C	; 28
    9d18:	93 83       	std	Z+3, r25	; 0x03
    9d1a:	82 83       	std	Z+2, r24	; 0x02
    9d1c:	58 96       	adiw	r26, 0x18	; 24
    9d1e:	8c 91       	ld	r24, X
    9d20:	58 97       	sbiw	r26, 0x18	; 24
    9d22:	84 83       	std	Z+4, r24	; 0x04
    9d24:	15 82       	std	Z+5, r1	; 0x05
    9d26:	59 96       	adiw	r26, 0x19	; 25
    9d28:	8c 91       	ld	r24, X
    9d2a:	59 97       	sbiw	r26, 0x19	; 25
    9d2c:	86 83       	std	Z+6, r24	; 0x06
    9d2e:	17 82       	std	Z+7, r1	; 0x07
    9d30:	5a 96       	adiw	r26, 0x1a	; 26
    9d32:	8c 91       	ld	r24, X
    9d34:	5a 97       	sbiw	r26, 0x1a	; 26
    9d36:	80 87       	std	Z+8, r24	; 0x08
    9d38:	11 86       	std	Z+9, r1	; 0x09
    9d3a:	5b 96       	adiw	r26, 0x1b	; 27
    9d3c:	8c 91       	ld	r24, X
    9d3e:	5b 97       	sbiw	r26, 0x1b	; 27
    9d40:	82 87       	std	Z+10, r24	; 0x0a
    9d42:	13 86       	std	Z+11, r1	; 0x0b
    9d44:	5c 96       	adiw	r26, 0x1c	; 28
    9d46:	8c 91       	ld	r24, X
    9d48:	5c 97       	sbiw	r26, 0x1c	; 28
    9d4a:	84 87       	std	Z+12, r24	; 0x0c
    9d4c:	15 86       	std	Z+13, r1	; 0x0d
    9d4e:	5d 96       	adiw	r26, 0x1d	; 29
    9d50:	8c 91       	ld	r24, X
    9d52:	5d 97       	sbiw	r26, 0x1d	; 29
    9d54:	86 87       	std	Z+14, r24	; 0x0e
    9d56:	17 86       	std	Z+15, r1	; 0x0f
    9d58:	5e 96       	adiw	r26, 0x1e	; 30
    9d5a:	8c 91       	ld	r24, X
    9d5c:	5e 97       	sbiw	r26, 0x1e	; 30
    9d5e:	80 8b       	std	Z+16, r24	; 0x10
    9d60:	11 8a       	std	Z+17, r1	; 0x11
    9d62:	5f 96       	adiw	r26, 0x1f	; 31
    9d64:	8c 91       	ld	r24, X
    9d66:	5f 97       	sbiw	r26, 0x1f	; 31
    9d68:	82 8b       	std	Z+18, r24	; 0x12
    9d6a:	13 8a       	std	Z+19, r1	; 0x13
    9d6c:	90 96       	adiw	r26, 0x20	; 32
    9d6e:	8c 91       	ld	r24, X
    9d70:	90 97       	sbiw	r26, 0x20	; 32
    9d72:	84 8b       	std	Z+20, r24	; 0x14
    9d74:	15 8a       	std	Z+21, r1	; 0x15
    9d76:	91 96       	adiw	r26, 0x21	; 33
    9d78:	8c 91       	ld	r24, X
    9d7a:	91 97       	sbiw	r26, 0x21	; 33
    9d7c:	86 8b       	std	Z+22, r24	; 0x16
    9d7e:	17 8a       	std	Z+23, r1	; 0x17
    9d80:	92 96       	adiw	r26, 0x22	; 34
    9d82:	8c 91       	ld	r24, X
    9d84:	92 97       	sbiw	r26, 0x22	; 34
    9d86:	80 8f       	std	Z+24, r24	; 0x18
    9d88:	11 8e       	std	Z+25, r1	; 0x19
    9d8a:	93 96       	adiw	r26, 0x23	; 35
    9d8c:	8c 91       	ld	r24, X
    9d8e:	93 97       	sbiw	r26, 0x23	; 35
    9d90:	82 8f       	std	Z+26, r24	; 0x1a
    9d92:	13 8e       	std	Z+27, r1	; 0x1b
    9d94:	94 96       	adiw	r26, 0x24	; 36
    9d96:	8c 91       	ld	r24, X
    9d98:	94 97       	sbiw	r26, 0x24	; 36
    9d9a:	84 8f       	std	Z+28, r24	; 0x1c
    9d9c:	15 8e       	std	Z+29, r1	; 0x1d
    9d9e:	95 96       	adiw	r26, 0x25	; 37
    9da0:	8c 91       	ld	r24, X
    9da2:	95 97       	sbiw	r26, 0x25	; 37
    9da4:	86 8f       	std	Z+30, r24	; 0x1e
    9da6:	17 8e       	std	Z+31, r1	; 0x1f
    9da8:	96 96       	adiw	r26, 0x26	; 38
    9daa:	8c 91       	ld	r24, X
    9dac:	96 97       	sbiw	r26, 0x26	; 38
    9dae:	80 a3       	std	Z+32, r24	; 0x20
    9db0:	11 a2       	std	Z+33, r1	; 0x21
    9db2:	97 96       	adiw	r26, 0x27	; 39
    9db4:	8c 91       	ld	r24, X
    9db6:	82 a3       	std	Z+34, r24	; 0x22
    9db8:	13 a2       	std	Z+35, r1	; 0x23
    9dba:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  ///Adres z icmpv6 header'a    
  PRINTF2(debugStream,"with target address\n\r");
    9dbe:	ed b7       	in	r30, 0x3d	; 61
    9dc0:	fe b7       	in	r31, 0x3e	; 62
    9dc2:	b4 96       	adiw	r30, 0x24	; 36
    9dc4:	0f b6       	in	r0, 0x3f	; 63
    9dc6:	f8 94       	cli
    9dc8:	fe bf       	out	0x3e, r31	; 62
    9dca:	0f be       	out	0x3f, r0	; 63
    9dcc:	ed bf       	out	0x3d, r30	; 61
    9dce:	00 d0       	rcall	.+0      	; 0x9dd0 <uip_nd6_io_ns_input+0x230>
    9dd0:	00 d0       	rcall	.+0      	; 0x9dd2 <uip_nd6_io_ns_input+0x232>
    9dd2:	80 91 64 0f 	lds	r24, 0x0F64
    9dd6:	90 91 65 0f 	lds	r25, 0x0F65
    9dda:	ad b7       	in	r26, 0x3d	; 61
    9ddc:	be b7       	in	r27, 0x3e	; 62
    9dde:	12 96       	adiw	r26, 0x02	; 2
    9de0:	9c 93       	st	X, r25
    9de2:	8e 93       	st	-X, r24
    9de4:	11 97       	sbiw	r26, 0x01	; 1
    9de6:	83 e2       	ldi	r24, 0x23	; 35
    9de8:	9c e1       	ldi	r25, 0x1C	; 28
    9dea:	14 96       	adiw	r26, 0x04	; 4
    9dec:	9c 93       	st	X, r25
    9dee:	8e 93       	st	-X, r24
    9df0:	13 97       	sbiw	r26, 0x03	; 3
    9df2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINT6ADDR(debugStream, (&UIP_ND6_NS_BUF->tgtipaddr));
    9df6:	80 91 69 0f 	lds	r24, 0x0F69
    9dfa:	90 e0       	ldi	r25, 0x00	; 0
    9dfc:	ca 96       	adiw	r24, 0x3a	; 58
    9dfe:	a0 91 9d 0e 	lds	r26, 0x0E9D
    9e02:	b0 91 9e 0e 	lds	r27, 0x0E9E
    9e06:	a8 0f       	add	r26, r24
    9e08:	b9 1f       	adc	r27, r25
    9e0a:	cd b7       	in	r28, 0x3d	; 61
    9e0c:	de b7       	in	r29, 0x3e	; 62
    9e0e:	a0 97       	sbiw	r28, 0x20	; 32
    9e10:	0f b6       	in	r0, 0x3f	; 63
    9e12:	f8 94       	cli
    9e14:	de bf       	out	0x3e, r29	; 62
    9e16:	0f be       	out	0x3f, r0	; 63
    9e18:	cd bf       	out	0x3d, r28	; 61
    9e1a:	ed b7       	in	r30, 0x3d	; 61
    9e1c:	fe b7       	in	r31, 0x3e	; 62
    9e1e:	31 96       	adiw	r30, 0x01	; 1
    9e20:	80 91 64 0f 	lds	r24, 0x0F64
    9e24:	90 91 65 0f 	lds	r25, 0x0F65
    9e28:	9a 83       	std	Y+2, r25	; 0x02
    9e2a:	89 83       	std	Y+1, r24	; 0x01
    9e2c:	8c ec       	ldi	r24, 0xCC	; 204
    9e2e:	9b e1       	ldi	r25, 0x1B	; 27
    9e30:	93 83       	std	Z+3, r25	; 0x03
    9e32:	82 83       	std	Z+2, r24	; 0x02
    9e34:	14 96       	adiw	r26, 0x04	; 4
    9e36:	8c 91       	ld	r24, X
    9e38:	14 97       	sbiw	r26, 0x04	; 4
    9e3a:	84 83       	std	Z+4, r24	; 0x04
    9e3c:	15 82       	std	Z+5, r1	; 0x05
    9e3e:	15 96       	adiw	r26, 0x05	; 5
    9e40:	8c 91       	ld	r24, X
    9e42:	15 97       	sbiw	r26, 0x05	; 5
    9e44:	86 83       	std	Z+6, r24	; 0x06
    9e46:	17 82       	std	Z+7, r1	; 0x07
    9e48:	16 96       	adiw	r26, 0x06	; 6
    9e4a:	8c 91       	ld	r24, X
    9e4c:	16 97       	sbiw	r26, 0x06	; 6
    9e4e:	80 87       	std	Z+8, r24	; 0x08
    9e50:	11 86       	std	Z+9, r1	; 0x09
    9e52:	17 96       	adiw	r26, 0x07	; 7
    9e54:	8c 91       	ld	r24, X
    9e56:	17 97       	sbiw	r26, 0x07	; 7
    9e58:	82 87       	std	Z+10, r24	; 0x0a
    9e5a:	13 86       	std	Z+11, r1	; 0x0b
    9e5c:	18 96       	adiw	r26, 0x08	; 8
    9e5e:	8c 91       	ld	r24, X
    9e60:	18 97       	sbiw	r26, 0x08	; 8
    9e62:	84 87       	std	Z+12, r24	; 0x0c
    9e64:	15 86       	std	Z+13, r1	; 0x0d
    9e66:	19 96       	adiw	r26, 0x09	; 9
    9e68:	8c 91       	ld	r24, X
    9e6a:	19 97       	sbiw	r26, 0x09	; 9
    9e6c:	86 87       	std	Z+14, r24	; 0x0e
    9e6e:	17 86       	std	Z+15, r1	; 0x0f
    9e70:	1a 96       	adiw	r26, 0x0a	; 10
    9e72:	8c 91       	ld	r24, X
    9e74:	1a 97       	sbiw	r26, 0x0a	; 10
    9e76:	80 8b       	std	Z+16, r24	; 0x10
    9e78:	11 8a       	std	Z+17, r1	; 0x11
    9e7a:	1b 96       	adiw	r26, 0x0b	; 11
    9e7c:	8c 91       	ld	r24, X
    9e7e:	1b 97       	sbiw	r26, 0x0b	; 11
    9e80:	82 8b       	std	Z+18, r24	; 0x12
    9e82:	13 8a       	std	Z+19, r1	; 0x13
    9e84:	1c 96       	adiw	r26, 0x0c	; 12
    9e86:	8c 91       	ld	r24, X
    9e88:	1c 97       	sbiw	r26, 0x0c	; 12
    9e8a:	84 8b       	std	Z+20, r24	; 0x14
    9e8c:	15 8a       	std	Z+21, r1	; 0x15
    9e8e:	1d 96       	adiw	r26, 0x0d	; 13
    9e90:	8c 91       	ld	r24, X
    9e92:	1d 97       	sbiw	r26, 0x0d	; 13
    9e94:	86 8b       	std	Z+22, r24	; 0x16
    9e96:	17 8a       	std	Z+23, r1	; 0x17
    9e98:	1e 96       	adiw	r26, 0x0e	; 14
    9e9a:	8c 91       	ld	r24, X
    9e9c:	1e 97       	sbiw	r26, 0x0e	; 14
    9e9e:	80 8f       	std	Z+24, r24	; 0x18
    9ea0:	11 8e       	std	Z+25, r1	; 0x19
    9ea2:	1f 96       	adiw	r26, 0x0f	; 15
    9ea4:	8c 91       	ld	r24, X
    9ea6:	1f 97       	sbiw	r26, 0x0f	; 15
    9ea8:	82 8f       	std	Z+26, r24	; 0x1a
    9eaa:	13 8e       	std	Z+27, r1	; 0x1b
    9eac:	50 96       	adiw	r26, 0x10	; 16
    9eae:	8c 91       	ld	r24, X
    9eb0:	50 97       	sbiw	r26, 0x10	; 16
    9eb2:	84 8f       	std	Z+28, r24	; 0x1c
    9eb4:	15 8e       	std	Z+29, r1	; 0x1d
    9eb6:	51 96       	adiw	r26, 0x11	; 17
    9eb8:	8c 91       	ld	r24, X
    9eba:	51 97       	sbiw	r26, 0x11	; 17
    9ebc:	86 8f       	std	Z+30, r24	; 0x1e
    9ebe:	17 8e       	std	Z+31, r1	; 0x1f
    9ec0:	52 96       	adiw	r26, 0x12	; 18
    9ec2:	8c 91       	ld	r24, X
    9ec4:	52 97       	sbiw	r26, 0x12	; 18
    9ec6:	80 a3       	std	Z+32, r24	; 0x20
    9ec8:	11 a2       	std	Z+33, r1	; 0x21
    9eca:	53 96       	adiw	r26, 0x13	; 19
    9ecc:	8c 91       	ld	r24, X
    9ece:	82 a3       	std	Z+34, r24	; 0x22
    9ed0:	13 a2       	std	Z+35, r1	; 0x23
    9ed2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  
  u8_t flags;
 
  
  /* Options reading: we handle only SLLAO for now */
  nd6_opt_llao = NULL;
    9ed6:	10 92 a5 01 	sts	0x01A5, r1
    9eda:	10 92 a4 01 	sts	0x01A4, r1
  nd6_opt_offset = UIP_ND6_NS_LEN;
    9ede:	84 e1       	ldi	r24, 0x14	; 20
    9ee0:	80 93 a3 01 	sts	0x01A3, r24
  
  fprintf_P(debugStream, PSTR("uip_l2_l3_icmp_hdr_len %04x; packetLenght  %04x ; UIP_ND6_OPT_HDR_BUF %04x, nd6_opt_offset %04x\r\n"), 
    9ee4:	20 91 69 0f 	lds	r18, 0x0F69
    9ee8:	30 e0       	ldi	r19, 0x00	; 0
    9eea:	26 5c       	subi	r18, 0xC6	; 198
    9eec:	3f 4f       	sbci	r19, 0xFF	; 255
    9eee:	ed b7       	in	r30, 0x3d	; 61
    9ef0:	fe b7       	in	r31, 0x3e	; 62
    9ef2:	b4 96       	adiw	r30, 0x24	; 36
    9ef4:	0f b6       	in	r0, 0x3f	; 63
    9ef6:	f8 94       	cli
    9ef8:	fe bf       	out	0x3e, r31	; 62
    9efa:	0f be       	out	0x3f, r0	; 63
    9efc:	ed bf       	out	0x3d, r30	; 61
    9efe:	8d b7       	in	r24, 0x3d	; 61
    9f00:	9e b7       	in	r25, 0x3e	; 62
    9f02:	0c 97       	sbiw	r24, 0x0c	; 12
    9f04:	0f b6       	in	r0, 0x3f	; 63
    9f06:	f8 94       	cli
    9f08:	9e bf       	out	0x3e, r25	; 62
    9f0a:	0f be       	out	0x3f, r0	; 63
    9f0c:	8d bf       	out	0x3d, r24	; 61
    9f0e:	ed b7       	in	r30, 0x3d	; 61
    9f10:	fe b7       	in	r31, 0x3e	; 62
    9f12:	31 96       	adiw	r30, 0x01	; 1
    9f14:	80 91 64 0f 	lds	r24, 0x0F64
    9f18:	90 91 65 0f 	lds	r25, 0x0F65
    9f1c:	ad b7       	in	r26, 0x3d	; 61
    9f1e:	be b7       	in	r27, 0x3e	; 62
    9f20:	12 96       	adiw	r26, 0x02	; 2
    9f22:	9c 93       	st	X, r25
    9f24:	8e 93       	st	-X, r24
    9f26:	11 97       	sbiw	r26, 0x01	; 1
    9f28:	8a e6       	ldi	r24, 0x6A	; 106
    9f2a:	9b e1       	ldi	r25, 0x1B	; 27
    9f2c:	93 83       	std	Z+3, r25	; 0x03
    9f2e:	82 83       	std	Z+2, r24	; 0x02
    9f30:	35 83       	std	Z+5, r19	; 0x05
    9f32:	24 83       	std	Z+4, r18	; 0x04
    9f34:	b7 82       	std	Z+7, r11	; 0x07
    9f36:	a6 82       	std	Z+6, r10	; 0x06
    9f38:	2c 5e       	subi	r18, 0xEC	; 236
    9f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    9f3c:	80 91 9d 0e 	lds	r24, 0x0E9D
    9f40:	90 91 9e 0e 	lds	r25, 0x0E9E
    9f44:	82 0f       	add	r24, r18
    9f46:	93 1f       	adc	r25, r19
    9f48:	91 87       	std	Z+9, r25	; 0x09
    9f4a:	80 87       	std	Z+8, r24	; 0x08
    9f4c:	84 e1       	ldi	r24, 0x14	; 20
    9f4e:	90 e0       	ldi	r25, 0x00	; 0
    9f50:	93 87       	std	Z+11, r25	; 0x0b
    9f52:	82 87       	std	Z+10, r24	; 0x0a
    9f54:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
	                      uip_l2_l3_icmp_hdr_len, packetLenght, 
			      UIP_ND6_OPT_HDR_BUF, nd6_opt_offset );
  fprintf_P(debugStream, PSTR("ICMPv6 payload: \r\n"));
    9f58:	cd b7       	in	r28, 0x3d	; 61
    9f5a:	de b7       	in	r29, 0x3e	; 62
    9f5c:	28 96       	adiw	r28, 0x08	; 8
    9f5e:	0f b6       	in	r0, 0x3f	; 63
    9f60:	f8 94       	cli
    9f62:	de bf       	out	0x3e, r29	; 62
    9f64:	0f be       	out	0x3f, r0	; 63
    9f66:	cd bf       	out	0x3d, r28	; 61
    9f68:	80 91 64 0f 	lds	r24, 0x0F64
    9f6c:	90 91 65 0f 	lds	r25, 0x0F65
    9f70:	9a 83       	std	Y+2, r25	; 0x02
    9f72:	89 83       	std	Y+1, r24	; 0x01
    9f74:	87 e5       	ldi	r24, 0x57	; 87
    9f76:	9b e1       	ldi	r25, 0x1B	; 27
    9f78:	9c 83       	std	Y+4, r25	; 0x04
    9f7a:	8b 83       	std	Y+3, r24	; 0x03
    9f7c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    9f80:	c0 e4       	ldi	r28, 0x40	; 64
    9f82:	d0 e0       	ldi	r29, 0x00	; 0
    9f84:	0f 90       	pop	r0
    9f86:	0f 90       	pop	r0
    9f88:	0f 90       	pop	r0
    9f8a:	0f 90       	pop	r0
  for (uint8_t i=UIP_ND6_NS_LEN + UIP_ICMPH_LEN; i < 32; i++) ///Tu dlugosc ICMP
  {
  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer3.buf[i+UIP_IPH_LEN]);
    9f8c:	01 e5       	ldi	r16, 0x51	; 81
    9f8e:	1b e1       	ldi	r17, 0x1B	; 27
    9f90:	00 d0       	rcall	.+0      	; 0x9f92 <uip_nd6_io_ns_input+0x3f2>
    9f92:	00 d0       	rcall	.+0      	; 0x9f94 <uip_nd6_io_ns_input+0x3f4>
    9f94:	00 d0       	rcall	.+0      	; 0x9f96 <uip_nd6_io_ns_input+0x3f6>
    9f96:	ad b7       	in	r26, 0x3d	; 61
    9f98:	be b7       	in	r27, 0x3e	; 62
    9f9a:	11 96       	adiw	r26, 0x01	; 1
    9f9c:	80 91 64 0f 	lds	r24, 0x0F64
    9fa0:	90 91 65 0f 	lds	r25, 0x0F65
    9fa4:	ed b7       	in	r30, 0x3d	; 61
    9fa6:	fe b7       	in	r31, 0x3e	; 62
    9fa8:	92 83       	std	Z+2, r25	; 0x02
    9faa:	81 83       	std	Z+1, r24	; 0x01
    9fac:	13 96       	adiw	r26, 0x03	; 3
    9fae:	1c 93       	st	X, r17
    9fb0:	0e 93       	st	-X, r16
    9fb2:	12 97       	sbiw	r26, 0x02	; 2
    9fb4:	e0 91 9f 0e 	lds	r30, 0x0E9F
    9fb8:	f0 91 a0 0e 	lds	r31, 0x0EA0
    9fbc:	ec 0f       	add	r30, r28
    9fbe:	fd 1f       	adc	r31, r29
    9fc0:	80 81       	ld	r24, Z
    9fc2:	14 96       	adiw	r26, 0x04	; 4
    9fc4:	8c 93       	st	X, r24
    9fc6:	14 97       	sbiw	r26, 0x04	; 4
    9fc8:	15 96       	adiw	r26, 0x05	; 5
    9fca:	1c 92       	st	X, r1
    9fcc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    9fd0:	21 96       	adiw	r28, 0x01	; 1
  
  fprintf_P(debugStream, PSTR("uip_l2_l3_icmp_hdr_len %04x; packetLenght  %04x ; UIP_ND6_OPT_HDR_BUF %04x, nd6_opt_offset %04x\r\n"), 
	                      uip_l2_l3_icmp_hdr_len, packetLenght, 
			      UIP_ND6_OPT_HDR_BUF, nd6_opt_offset );
  fprintf_P(debugStream, PSTR("ICMPv6 payload: \r\n"));
  for (uint8_t i=UIP_ND6_NS_LEN + UIP_ICMPH_LEN; i < 32; i++) ///Tu dlugosc ICMP
    9fd2:	8d b7       	in	r24, 0x3d	; 61
    9fd4:	9e b7       	in	r25, 0x3e	; 62
    9fd6:	06 96       	adiw	r24, 0x06	; 6
    9fd8:	0f b6       	in	r0, 0x3f	; 63
    9fda:	f8 94       	cli
    9fdc:	9e bf       	out	0x3e, r25	; 62
    9fde:	0f be       	out	0x3f, r0	; 63
    9fe0:	8d bf       	out	0x3d, r24	; 61
    9fe2:	c8 34       	cpi	r28, 0x48	; 72
    9fe4:	d1 05       	cpc	r29, r1
    9fe6:	a1 f6       	brne	.-88     	; 0x9f90 <uip_nd6_io_ns_input+0x3f0>
  {
  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer3.buf[i+UIP_IPH_LEN]);
  }
  fprintf_P(debugStream, PSTR("\r\n"));
    9fe8:	00 d0       	rcall	.+0      	; 0x9fea <uip_nd6_io_ns_input+0x44a>
    9fea:	00 d0       	rcall	.+0      	; 0x9fec <uip_nd6_io_ns_input+0x44c>
    9fec:	80 91 64 0f 	lds	r24, 0x0F64
    9ff0:	90 91 65 0f 	lds	r25, 0x0F65
    9ff4:	ad b7       	in	r26, 0x3d	; 61
    9ff6:	be b7       	in	r27, 0x3e	; 62
    9ff8:	12 96       	adiw	r26, 0x02	; 2
    9ffa:	9c 93       	st	X, r25
    9ffc:	8e 93       	st	-X, r24
    9ffe:	11 97       	sbiw	r26, 0x01	; 1
    a000:	8e e4       	ldi	r24, 0x4E	; 78
    a002:	9b e1       	ldi	r25, 0x1B	; 27
    a004:	14 96       	adiw	r26, 0x04	; 4
    a006:	9c 93       	st	X, r25
    a008:	8e 93       	st	-X, r24
    a00a:	13 97       	sbiw	r26, 0x03	; 3
    a00c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    a010:	0f 90       	pop	r0
    a012:	0f 90       	pop	r0
    a014:	0f 90       	pop	r0
    a016:	0f 90       	pop	r0
    switch(UIP_ND6_OPT_HDR_BUF->type) {
      case UIP_ND6_OPT_SLLAO:
        nd6_opt_llao = (struct uip_nd6_opt_llao *)UIP_ND6_OPT_HDR_BUF;
        break;
      default:
        PRINTF2(debugStream,"ND option not supported in NS");
    a018:	c0 e3       	ldi	r28, 0x30	; 48
    a01a:	db e1       	ldi	r29, 0x1B	; 27
    a01c:	33 c0       	rjmp	.+102    	; 0xa084 <uip_nd6_io_ns_input+0x4e4>
#if UIP_CONF_IPV6_CHECKS
    if(UIP_ND6_OPT_HDR_BUF->len == 0) {
      goto badpkt;
    }
#endif /* UIP_CONF_IPV6_CHECKS */ 
    switch(UIP_ND6_OPT_HDR_BUF->type) {
    a01e:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a022:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a026:	e2 0f       	add	r30, r18
    a028:	f3 1f       	adc	r31, r19
    a02a:	80 81       	ld	r24, Z
    a02c:	81 30       	cpi	r24, 0x01	; 1
    a02e:	29 f4       	brne	.+10     	; 0xa03a <uip_nd6_io_ns_input+0x49a>
      case UIP_ND6_OPT_SLLAO:
        nd6_opt_llao = (struct uip_nd6_opt_llao *)UIP_ND6_OPT_HDR_BUF;
    a030:	f0 93 a5 01 	sts	0x01A5, r31
    a034:	e0 93 a4 01 	sts	0x01A4, r30
    a038:	12 c0       	rjmp	.+36     	; 0xa05e <uip_nd6_io_ns_input+0x4be>
        break;
      default:
        PRINTF2(debugStream,"ND option not supported in NS");
    a03a:	00 d0       	rcall	.+0      	; 0xa03c <uip_nd6_io_ns_input+0x49c>
    a03c:	00 d0       	rcall	.+0      	; 0xa03e <uip_nd6_io_ns_input+0x49e>
    a03e:	80 91 64 0f 	lds	r24, 0x0F64
    a042:	90 91 65 0f 	lds	r25, 0x0F65
    a046:	ed b7       	in	r30, 0x3d	; 61
    a048:	fe b7       	in	r31, 0x3e	; 62
    a04a:	92 83       	std	Z+2, r25	; 0x02
    a04c:	81 83       	std	Z+1, r24	; 0x01
    a04e:	d4 83       	std	Z+4, r29	; 0x04
    a050:	c3 83       	std	Z+3, r28	; 0x03
    a052:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    a056:	0f 90       	pop	r0
    a058:	0f 90       	pop	r0
    a05a:	0f 90       	pop	r0
    a05c:	0f 90       	pop	r0
        break;
    }
    nd6_opt_offset += (UIP_ND6_OPT_HDR_BUF->len << 3);
    a05e:	90 91 a3 01 	lds	r25, 0x01A3
    a062:	80 91 69 0f 	lds	r24, 0x0F69
    a066:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a06a:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a06e:	e8 0f       	add	r30, r24
    a070:	f1 1d       	adc	r31, r1
    a072:	e9 0f       	add	r30, r25
    a074:	f1 1d       	adc	r31, r1
    a076:	83 ad       	ldd	r24, Z+59	; 0x3b
    a078:	88 0f       	add	r24, r24
    a07a:	88 0f       	add	r24, r24
    a07c:	88 0f       	add	r24, r24
    a07e:	89 0f       	add	r24, r25
    a080:	80 93 a3 01 	sts	0x01A3, r24
  fprintf_P(debugStream, PSTR("%02x:"), nicState.layer3.buf[i+UIP_IPH_LEN]);
  }
  fprintf_P(debugStream, PSTR("\r\n"));
  
  
  while(uip_l2_l3_icmp_hdr_len + nd6_opt_offset < packetLenght) {
    a084:	90 91 69 0f 	lds	r25, 0x0F69
    a088:	80 91 a3 01 	lds	r24, 0x01A3
    a08c:	28 2f       	mov	r18, r24
    a08e:	30 e0       	ldi	r19, 0x00	; 0
    a090:	29 0f       	add	r18, r25
    a092:	31 1d       	adc	r19, r1
    a094:	26 5c       	subi	r18, 0xC6	; 198
    a096:	3f 4f       	sbci	r19, 0xFF	; 255
    a098:	2a 15       	cp	r18, r10
    a09a:	3b 05       	cpc	r19, r11
    a09c:	08 f4       	brcc	.+2      	; 0xa0a0 <uip_nd6_io_ns_input+0x500>
    a09e:	bf cf       	rjmp	.-130    	; 0xa01e <uip_nd6_io_ns_input+0x47e>

  /* 
   * Rest of NS processing: Depends on the purpose of the NS: NUD or DAD or
   * Address Resolution 
   */
  ifaddr = xmalloc(sizeof(struct uip_netif_addr));
    a0a0:	83 e1       	ldi	r24, 0x13	; 19
    a0a2:	90 e0       	ldi	r25, 0x00	; 0
    a0a4:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    a0a8:	80 93 a6 01 	sts	0x01A6, r24
    a0ac:	90 93 a7 01 	sts	0x01A7, r25
  /** \note we use ifaddr to remember the target address */
  memcpy(&ifaddr->ipaddr, &UIP_ND6_NS_BUF->tgtipaddr, sizeof(uip_ip6addr_t));
    a0b0:	20 91 69 0f 	lds	r18, 0x0F69
    a0b4:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a0b8:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a0bc:	e2 0f       	add	r30, r18
    a0be:	f1 1d       	adc	r31, r1
    a0c0:	dc 01       	movw	r26, r24
    a0c2:	fe 96       	adiw	r30, 0x3e	; 62
    a0c4:	80 e1       	ldi	r24, 0x10	; 16
    a0c6:	01 90       	ld	r0, Z+
    a0c8:	0d 92       	st	X+, r0
    a0ca:	81 50       	subi	r24, 0x01	; 1
    a0cc:	e1 f7       	brne	.-8      	; 0xa0c6 <uip_nd6_io_ns_input+0x526>
  
    fprintf_P(debugStream, PSTR("ifaddr: ** %04x \r\n"), &ifaddr->ipaddr);
    a0ce:	00 d0       	rcall	.+0      	; 0xa0d0 <uip_nd6_io_ns_input+0x530>
    a0d0:	00 d0       	rcall	.+0      	; 0xa0d2 <uip_nd6_io_ns_input+0x532>
    a0d2:	00 d0       	rcall	.+0      	; 0xa0d4 <uip_nd6_io_ns_input+0x534>
    a0d4:	ed b7       	in	r30, 0x3d	; 61
    a0d6:	fe b7       	in	r31, 0x3e	; 62
    a0d8:	31 96       	adiw	r30, 0x01	; 1
    a0da:	80 91 64 0f 	lds	r24, 0x0F64
    a0de:	90 91 65 0f 	lds	r25, 0x0F65
    a0e2:	ad b7       	in	r26, 0x3d	; 61
    a0e4:	be b7       	in	r27, 0x3e	; 62
    a0e6:	12 96       	adiw	r26, 0x02	; 2
    a0e8:	9c 93       	st	X, r25
    a0ea:	8e 93       	st	-X, r24
    a0ec:	11 97       	sbiw	r26, 0x01	; 1
    a0ee:	8d e1       	ldi	r24, 0x1D	; 29
    a0f0:	9b e1       	ldi	r25, 0x1B	; 27
    a0f2:	93 83       	std	Z+3, r25	; 0x03
    a0f4:	82 83       	std	Z+2, r24	; 0x02
    a0f6:	80 91 a6 01 	lds	r24, 0x01A6
    a0fa:	90 91 a7 01 	lds	r25, 0x01A7
    a0fe:	95 83       	std	Z+5, r25	; 0x05
    a100:	84 83       	std	Z+4, r24	; 0x04
    a102:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    PRINT6ADDR(debugStream, &ifaddr->ipaddr);
    a106:	a0 91 a6 01 	lds	r26, 0x01A6
    a10a:	b0 91 a7 01 	lds	r27, 0x01A7
    a10e:	cd b7       	in	r28, 0x3d	; 61
    a110:	de b7       	in	r29, 0x3e	; 62
    a112:	6e 97       	sbiw	r28, 0x1e	; 30
    a114:	0f b6       	in	r0, 0x3f	; 63
    a116:	f8 94       	cli
    a118:	de bf       	out	0x3e, r29	; 62
    a11a:	0f be       	out	0x3f, r0	; 63
    a11c:	cd bf       	out	0x3d, r28	; 61
    a11e:	ed b7       	in	r30, 0x3d	; 61
    a120:	fe b7       	in	r31, 0x3e	; 62
    a122:	31 96       	adiw	r30, 0x01	; 1
    a124:	80 91 64 0f 	lds	r24, 0x0F64
    a128:	90 91 65 0f 	lds	r25, 0x0F65
    a12c:	9a 83       	std	Y+2, r25	; 0x02
    a12e:	89 83       	std	Y+1, r24	; 0x01
    a130:	86 ec       	ldi	r24, 0xC6	; 198
    a132:	9a e1       	ldi	r25, 0x1A	; 26
    a134:	93 83       	std	Z+3, r25	; 0x03
    a136:	82 83       	std	Z+2, r24	; 0x02
    a138:	8c 91       	ld	r24, X
    a13a:	84 83       	std	Z+4, r24	; 0x04
    a13c:	15 82       	std	Z+5, r1	; 0x05
    a13e:	11 96       	adiw	r26, 0x01	; 1
    a140:	8c 91       	ld	r24, X
    a142:	11 97       	sbiw	r26, 0x01	; 1
    a144:	86 83       	std	Z+6, r24	; 0x06
    a146:	17 82       	std	Z+7, r1	; 0x07
    a148:	12 96       	adiw	r26, 0x02	; 2
    a14a:	8c 91       	ld	r24, X
    a14c:	12 97       	sbiw	r26, 0x02	; 2
    a14e:	80 87       	std	Z+8, r24	; 0x08
    a150:	11 86       	std	Z+9, r1	; 0x09
    a152:	13 96       	adiw	r26, 0x03	; 3
    a154:	8c 91       	ld	r24, X
    a156:	13 97       	sbiw	r26, 0x03	; 3
    a158:	82 87       	std	Z+10, r24	; 0x0a
    a15a:	13 86       	std	Z+11, r1	; 0x0b
    a15c:	14 96       	adiw	r26, 0x04	; 4
    a15e:	8c 91       	ld	r24, X
    a160:	14 97       	sbiw	r26, 0x04	; 4
    a162:	84 87       	std	Z+12, r24	; 0x0c
    a164:	15 86       	std	Z+13, r1	; 0x0d
    a166:	15 96       	adiw	r26, 0x05	; 5
    a168:	8c 91       	ld	r24, X
    a16a:	15 97       	sbiw	r26, 0x05	; 5
    a16c:	86 87       	std	Z+14, r24	; 0x0e
    a16e:	17 86       	std	Z+15, r1	; 0x0f
    a170:	16 96       	adiw	r26, 0x06	; 6
    a172:	8c 91       	ld	r24, X
    a174:	16 97       	sbiw	r26, 0x06	; 6
    a176:	80 8b       	std	Z+16, r24	; 0x10
    a178:	11 8a       	std	Z+17, r1	; 0x11
    a17a:	17 96       	adiw	r26, 0x07	; 7
    a17c:	8c 91       	ld	r24, X
    a17e:	17 97       	sbiw	r26, 0x07	; 7
    a180:	82 8b       	std	Z+18, r24	; 0x12
    a182:	13 8a       	std	Z+19, r1	; 0x13
    a184:	18 96       	adiw	r26, 0x08	; 8
    a186:	8c 91       	ld	r24, X
    a188:	18 97       	sbiw	r26, 0x08	; 8
    a18a:	84 8b       	std	Z+20, r24	; 0x14
    a18c:	15 8a       	std	Z+21, r1	; 0x15
    a18e:	19 96       	adiw	r26, 0x09	; 9
    a190:	8c 91       	ld	r24, X
    a192:	19 97       	sbiw	r26, 0x09	; 9
    a194:	86 8b       	std	Z+22, r24	; 0x16
    a196:	17 8a       	std	Z+23, r1	; 0x17
    a198:	1a 96       	adiw	r26, 0x0a	; 10
    a19a:	8c 91       	ld	r24, X
    a19c:	1a 97       	sbiw	r26, 0x0a	; 10
    a19e:	80 8f       	std	Z+24, r24	; 0x18
    a1a0:	11 8e       	std	Z+25, r1	; 0x19
    a1a2:	1b 96       	adiw	r26, 0x0b	; 11
    a1a4:	8c 91       	ld	r24, X
    a1a6:	1b 97       	sbiw	r26, 0x0b	; 11
    a1a8:	82 8f       	std	Z+26, r24	; 0x1a
    a1aa:	13 8e       	std	Z+27, r1	; 0x1b
    a1ac:	1c 96       	adiw	r26, 0x0c	; 12
    a1ae:	8c 91       	ld	r24, X
    a1b0:	1c 97       	sbiw	r26, 0x0c	; 12
    a1b2:	84 8f       	std	Z+28, r24	; 0x1c
    a1b4:	15 8e       	std	Z+29, r1	; 0x1d
    a1b6:	1d 96       	adiw	r26, 0x0d	; 13
    a1b8:	8c 91       	ld	r24, X
    a1ba:	1d 97       	sbiw	r26, 0x0d	; 13
    a1bc:	86 8f       	std	Z+30, r24	; 0x1e
    a1be:	17 8e       	std	Z+31, r1	; 0x1f
    a1c0:	1e 96       	adiw	r26, 0x0e	; 14
    a1c2:	8c 91       	ld	r24, X
    a1c4:	1e 97       	sbiw	r26, 0x0e	; 14
    a1c6:	80 a3       	std	Z+32, r24	; 0x20
    a1c8:	11 a2       	std	Z+33, r1	; 0x21
    a1ca:	1f 96       	adiw	r26, 0x0f	; 15
    a1cc:	8c 91       	ld	r24, X
    a1ce:	82 a3       	std	Z+34, r24	; 0x22
    a1d0:	13 a2       	std	Z+35, r1	; 0x23
    a1d2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    PRINT6ADDR(debugStream, &UIP_ND6_NS_BUF->tgtipaddr);
    a1d6:	80 91 69 0f 	lds	r24, 0x0F69
    a1da:	90 e0       	ldi	r25, 0x00	; 0
    a1dc:	ca 96       	adiw	r24, 0x3a	; 58
    a1de:	a0 91 9d 0e 	lds	r26, 0x0E9D
    a1e2:	b0 91 9e 0e 	lds	r27, 0x0E9E
    a1e6:	a8 0f       	add	r26, r24
    a1e8:	b9 1f       	adc	r27, r25
    a1ea:	ed b7       	in	r30, 0x3d	; 61
    a1ec:	fe b7       	in	r31, 0x3e	; 62
    a1ee:	b4 96       	adiw	r30, 0x24	; 36
    a1f0:	0f b6       	in	r0, 0x3f	; 63
    a1f2:	f8 94       	cli
    a1f4:	fe bf       	out	0x3e, r31	; 62
    a1f6:	0f be       	out	0x3f, r0	; 63
    a1f8:	ed bf       	out	0x3d, r30	; 61
    a1fa:	8d b7       	in	r24, 0x3d	; 61
    a1fc:	9e b7       	in	r25, 0x3e	; 62
    a1fe:	84 97       	sbiw	r24, 0x24	; 36
    a200:	0f b6       	in	r0, 0x3f	; 63
    a202:	f8 94       	cli
    a204:	9e bf       	out	0x3e, r25	; 62
    a206:	0f be       	out	0x3f, r0	; 63
    a208:	8d bf       	out	0x3d, r24	; 61
    a20a:	ed b7       	in	r30, 0x3d	; 61
    a20c:	fe b7       	in	r31, 0x3e	; 62
    a20e:	31 96       	adiw	r30, 0x01	; 1
    a210:	80 91 64 0f 	lds	r24, 0x0F64
    a214:	90 91 65 0f 	lds	r25, 0x0F65
    a218:	cd b7       	in	r28, 0x3d	; 61
    a21a:	de b7       	in	r29, 0x3e	; 62
    a21c:	9a 83       	std	Y+2, r25	; 0x02
    a21e:	89 83       	std	Y+1, r24	; 0x01
    a220:	8f e6       	ldi	r24, 0x6F	; 111
    a222:	9a e1       	ldi	r25, 0x1A	; 26
    a224:	93 83       	std	Z+3, r25	; 0x03
    a226:	82 83       	std	Z+2, r24	; 0x02
    a228:	14 96       	adiw	r26, 0x04	; 4
    a22a:	8c 91       	ld	r24, X
    a22c:	14 97       	sbiw	r26, 0x04	; 4
    a22e:	84 83       	std	Z+4, r24	; 0x04
    a230:	15 82       	std	Z+5, r1	; 0x05
    a232:	15 96       	adiw	r26, 0x05	; 5
    a234:	8c 91       	ld	r24, X
    a236:	15 97       	sbiw	r26, 0x05	; 5
    a238:	86 83       	std	Z+6, r24	; 0x06
    a23a:	17 82       	std	Z+7, r1	; 0x07
    a23c:	16 96       	adiw	r26, 0x06	; 6
    a23e:	8c 91       	ld	r24, X
    a240:	16 97       	sbiw	r26, 0x06	; 6
    a242:	80 87       	std	Z+8, r24	; 0x08
    a244:	11 86       	std	Z+9, r1	; 0x09
    a246:	17 96       	adiw	r26, 0x07	; 7
    a248:	8c 91       	ld	r24, X
    a24a:	17 97       	sbiw	r26, 0x07	; 7
    a24c:	82 87       	std	Z+10, r24	; 0x0a
    a24e:	13 86       	std	Z+11, r1	; 0x0b
    a250:	18 96       	adiw	r26, 0x08	; 8
    a252:	8c 91       	ld	r24, X
    a254:	18 97       	sbiw	r26, 0x08	; 8
    a256:	84 87       	std	Z+12, r24	; 0x0c
    a258:	15 86       	std	Z+13, r1	; 0x0d
    a25a:	19 96       	adiw	r26, 0x09	; 9
    a25c:	8c 91       	ld	r24, X
    a25e:	19 97       	sbiw	r26, 0x09	; 9
    a260:	86 87       	std	Z+14, r24	; 0x0e
    a262:	17 86       	std	Z+15, r1	; 0x0f
    a264:	1a 96       	adiw	r26, 0x0a	; 10
    a266:	8c 91       	ld	r24, X
    a268:	1a 97       	sbiw	r26, 0x0a	; 10
    a26a:	80 8b       	std	Z+16, r24	; 0x10
    a26c:	11 8a       	std	Z+17, r1	; 0x11
    a26e:	1b 96       	adiw	r26, 0x0b	; 11
    a270:	8c 91       	ld	r24, X
    a272:	1b 97       	sbiw	r26, 0x0b	; 11
    a274:	82 8b       	std	Z+18, r24	; 0x12
    a276:	13 8a       	std	Z+19, r1	; 0x13
    a278:	1c 96       	adiw	r26, 0x0c	; 12
    a27a:	8c 91       	ld	r24, X
    a27c:	1c 97       	sbiw	r26, 0x0c	; 12
    a27e:	84 8b       	std	Z+20, r24	; 0x14
    a280:	15 8a       	std	Z+21, r1	; 0x15
    a282:	1d 96       	adiw	r26, 0x0d	; 13
    a284:	8c 91       	ld	r24, X
    a286:	1d 97       	sbiw	r26, 0x0d	; 13
    a288:	86 8b       	std	Z+22, r24	; 0x16
    a28a:	17 8a       	std	Z+23, r1	; 0x17
    a28c:	1e 96       	adiw	r26, 0x0e	; 14
    a28e:	8c 91       	ld	r24, X
    a290:	1e 97       	sbiw	r26, 0x0e	; 14
    a292:	80 8f       	std	Z+24, r24	; 0x18
    a294:	11 8e       	std	Z+25, r1	; 0x19
    a296:	1f 96       	adiw	r26, 0x0f	; 15
    a298:	8c 91       	ld	r24, X
    a29a:	1f 97       	sbiw	r26, 0x0f	; 15
    a29c:	82 8f       	std	Z+26, r24	; 0x1a
    a29e:	13 8e       	std	Z+27, r1	; 0x1b
    a2a0:	50 96       	adiw	r26, 0x10	; 16
    a2a2:	8c 91       	ld	r24, X
    a2a4:	50 97       	sbiw	r26, 0x10	; 16
    a2a6:	84 8f       	std	Z+28, r24	; 0x1c
    a2a8:	15 8e       	std	Z+29, r1	; 0x1d
    a2aa:	51 96       	adiw	r26, 0x11	; 17
    a2ac:	8c 91       	ld	r24, X
    a2ae:	51 97       	sbiw	r26, 0x11	; 17
    a2b0:	86 8f       	std	Z+30, r24	; 0x1e
    a2b2:	17 8e       	std	Z+31, r1	; 0x1f
    a2b4:	52 96       	adiw	r26, 0x12	; 18
    a2b6:	8c 91       	ld	r24, X
    a2b8:	52 97       	sbiw	r26, 0x12	; 18
    a2ba:	80 a3       	std	Z+32, r24	; 0x20
    a2bc:	11 a2       	std	Z+33, r1	; 0x21
    a2be:	53 96       	adiw	r26, 0x13	; 19
    a2c0:	8c 91       	ld	r24, X
    a2c2:	82 a3       	std	Z+34, r24	; 0x22
    a2c4:	13 a2       	std	Z+35, r1	; 0x23
    a2c6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  //ifaddr = uip_netif_addr_lookup(&UIP_ND6_NS_BUF->tgtipaddr, 128, 0);  //Sprawdza czy to nasz adres, narazie wylaczone
  if(ifaddr != NULL) 
    a2ca:	ed b7       	in	r30, 0x3d	; 61
    a2cc:	fe b7       	in	r31, 0x3e	; 62
    a2ce:	b4 96       	adiw	r30, 0x24	; 36
    a2d0:	0f b6       	in	r0, 0x3f	; 63
    a2d2:	f8 94       	cli
    a2d4:	fe bf       	out	0x3e, r31	; 62
    a2d6:	0f be       	out	0x3f, r0	; 63
    a2d8:	ed bf       	out	0x3d, r30	; 61
    a2da:	80 91 a6 01 	lds	r24, 0x01A6
    a2de:	90 91 a7 01 	lds	r25, 0x01A7
    a2e2:	89 2b       	or	r24, r25
    a2e4:	09 f4       	brne	.+2      	; 0xa2e8 <uip_nd6_io_ns_input+0x748>
    a2e6:	90 c6       	rjmp	.+3360   	; 0xb008 <uip_nd6_io_ns_input+0x1468>
    {
      /*   
       * we need to send a NA, we set the src, dest, flags. The rest is set
       * at the "create_na" label.
       */
         fprintf_P(debugStream, PSTR("uip_netif_addr_lookup: \r\n"));
    a2e8:	00 d0       	rcall	.+0      	; 0xa2ea <uip_nd6_io_ns_input+0x74a>
    a2ea:	00 d0       	rcall	.+0      	; 0xa2ec <uip_nd6_io_ns_input+0x74c>
    a2ec:	80 91 64 0f 	lds	r24, 0x0F64
    a2f0:	90 91 65 0f 	lds	r25, 0x0F65
    a2f4:	ad b7       	in	r26, 0x3d	; 61
    a2f6:	be b7       	in	r27, 0x3e	; 62
    a2f8:	12 96       	adiw	r26, 0x02	; 2
    a2fa:	9c 93       	st	X, r25
    a2fc:	8e 93       	st	-X, r24
    a2fe:	11 97       	sbiw	r26, 0x01	; 1
    a300:	85 e5       	ldi	r24, 0x55	; 85
    a302:	9a e1       	ldi	r25, 0x1A	; 26
    a304:	14 96       	adiw	r26, 0x04	; 4
    a306:	9c 93       	st	X, r25
    a308:	8e 93       	st	-X, r24
    a30a:	13 97       	sbiw	r26, 0x03	; 3
    a30c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
	  
	  fprintf_P(debugStream, PSTR("ORG addr: \r\n"));
    a310:	80 91 64 0f 	lds	r24, 0x0F64
    a314:	90 91 65 0f 	lds	r25, 0x0F65
    a318:	cd b7       	in	r28, 0x3d	; 61
    a31a:	de b7       	in	r29, 0x3e	; 62
    a31c:	9a 83       	std	Y+2, r25	; 0x02
    a31e:	89 83       	std	Y+1, r24	; 0x01
    a320:	88 e4       	ldi	r24, 0x48	; 72
    a322:	9a e1       	ldi	r25, 0x1A	; 26
    a324:	9c 83       	std	Y+4, r25	; 0x04
    a326:	8b 83       	std	Y+3, r24	; 0x03
    a328:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
	 PRINT6ADDR(debugStream, &nicState.layer3.ipv6->destipaddr);
    a32c:	a0 91 9f 0e 	lds	r26, 0x0E9F
    a330:	b0 91 a0 0e 	lds	r27, 0x0EA0
    a334:	ed b7       	in	r30, 0x3d	; 61
    a336:	fe b7       	in	r31, 0x3e	; 62
    a338:	b0 97       	sbiw	r30, 0x20	; 32
    a33a:	0f b6       	in	r0, 0x3f	; 63
    a33c:	f8 94       	cli
    a33e:	fe bf       	out	0x3e, r31	; 62
    a340:	0f be       	out	0x3f, r0	; 63
    a342:	ed bf       	out	0x3d, r30	; 61
    a344:	31 96       	adiw	r30, 0x01	; 1
    a346:	80 91 64 0f 	lds	r24, 0x0F64
    a34a:	90 91 65 0f 	lds	r25, 0x0F65
    a34e:	cd b7       	in	r28, 0x3d	; 61
    a350:	de b7       	in	r29, 0x3e	; 62
    a352:	9a 83       	std	Y+2, r25	; 0x02
    a354:	89 83       	std	Y+1, r24	; 0x01
    a356:	81 ef       	ldi	r24, 0xF1	; 241
    a358:	99 e1       	ldi	r25, 0x19	; 25
    a35a:	93 83       	std	Z+3, r25	; 0x03
    a35c:	82 83       	std	Z+2, r24	; 0x02
    a35e:	58 96       	adiw	r26, 0x18	; 24
    a360:	8c 91       	ld	r24, X
    a362:	58 97       	sbiw	r26, 0x18	; 24
    a364:	84 83       	std	Z+4, r24	; 0x04
    a366:	15 82       	std	Z+5, r1	; 0x05
    a368:	59 96       	adiw	r26, 0x19	; 25
    a36a:	8c 91       	ld	r24, X
    a36c:	59 97       	sbiw	r26, 0x19	; 25
    a36e:	86 83       	std	Z+6, r24	; 0x06
    a370:	17 82       	std	Z+7, r1	; 0x07
    a372:	5a 96       	adiw	r26, 0x1a	; 26
    a374:	8c 91       	ld	r24, X
    a376:	5a 97       	sbiw	r26, 0x1a	; 26
    a378:	80 87       	std	Z+8, r24	; 0x08
    a37a:	11 86       	std	Z+9, r1	; 0x09
    a37c:	5b 96       	adiw	r26, 0x1b	; 27
    a37e:	8c 91       	ld	r24, X
    a380:	5b 97       	sbiw	r26, 0x1b	; 27
    a382:	82 87       	std	Z+10, r24	; 0x0a
    a384:	13 86       	std	Z+11, r1	; 0x0b
    a386:	5c 96       	adiw	r26, 0x1c	; 28
    a388:	8c 91       	ld	r24, X
    a38a:	5c 97       	sbiw	r26, 0x1c	; 28
    a38c:	84 87       	std	Z+12, r24	; 0x0c
    a38e:	15 86       	std	Z+13, r1	; 0x0d
    a390:	5d 96       	adiw	r26, 0x1d	; 29
    a392:	8c 91       	ld	r24, X
    a394:	5d 97       	sbiw	r26, 0x1d	; 29
    a396:	86 87       	std	Z+14, r24	; 0x0e
    a398:	17 86       	std	Z+15, r1	; 0x0f
    a39a:	5e 96       	adiw	r26, 0x1e	; 30
    a39c:	8c 91       	ld	r24, X
    a39e:	5e 97       	sbiw	r26, 0x1e	; 30
    a3a0:	80 8b       	std	Z+16, r24	; 0x10
    a3a2:	11 8a       	std	Z+17, r1	; 0x11
    a3a4:	5f 96       	adiw	r26, 0x1f	; 31
    a3a6:	8c 91       	ld	r24, X
    a3a8:	5f 97       	sbiw	r26, 0x1f	; 31
    a3aa:	82 8b       	std	Z+18, r24	; 0x12
    a3ac:	13 8a       	std	Z+19, r1	; 0x13
    a3ae:	90 96       	adiw	r26, 0x20	; 32
    a3b0:	8c 91       	ld	r24, X
    a3b2:	90 97       	sbiw	r26, 0x20	; 32
    a3b4:	84 8b       	std	Z+20, r24	; 0x14
    a3b6:	15 8a       	std	Z+21, r1	; 0x15
    a3b8:	91 96       	adiw	r26, 0x21	; 33
    a3ba:	8c 91       	ld	r24, X
    a3bc:	91 97       	sbiw	r26, 0x21	; 33
    a3be:	86 8b       	std	Z+22, r24	; 0x16
    a3c0:	17 8a       	std	Z+23, r1	; 0x17
    a3c2:	92 96       	adiw	r26, 0x22	; 34
    a3c4:	8c 91       	ld	r24, X
    a3c6:	92 97       	sbiw	r26, 0x22	; 34
    a3c8:	80 8f       	std	Z+24, r24	; 0x18
    a3ca:	11 8e       	std	Z+25, r1	; 0x19
    a3cc:	93 96       	adiw	r26, 0x23	; 35
    a3ce:	8c 91       	ld	r24, X
    a3d0:	93 97       	sbiw	r26, 0x23	; 35
    a3d2:	82 8f       	std	Z+26, r24	; 0x1a
    a3d4:	13 8e       	std	Z+27, r1	; 0x1b
    a3d6:	94 96       	adiw	r26, 0x24	; 36
    a3d8:	8c 91       	ld	r24, X
    a3da:	94 97       	sbiw	r26, 0x24	; 36
    a3dc:	84 8f       	std	Z+28, r24	; 0x1c
    a3de:	15 8e       	std	Z+29, r1	; 0x1d
    a3e0:	95 96       	adiw	r26, 0x25	; 37
    a3e2:	8c 91       	ld	r24, X
    a3e4:	95 97       	sbiw	r26, 0x25	; 37
    a3e6:	86 8f       	std	Z+30, r24	; 0x1e
    a3e8:	17 8e       	std	Z+31, r1	; 0x1f
    a3ea:	96 96       	adiw	r26, 0x26	; 38
    a3ec:	8c 91       	ld	r24, X
    a3ee:	96 97       	sbiw	r26, 0x26	; 38
    a3f0:	80 a3       	std	Z+32, r24	; 0x20
    a3f2:	11 a2       	std	Z+33, r1	; 0x21
    a3f4:	97 96       	adiw	r26, 0x27	; 39
    a3f6:	8c 91       	ld	r24, X
    a3f8:	82 a3       	std	Z+34, r24	; 0x22
    a3fa:	13 a2       	std	Z+35, r1	; 0x23
    a3fc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
         PRINT6ADDR(debugStream, &nicState.layer3.ipv6->srcipaddr);
    a400:	a0 91 9f 0e 	lds	r26, 0x0E9F
    a404:	b0 91 a0 0e 	lds	r27, 0x0EA0
    a408:	ed b7       	in	r30, 0x3d	; 61
    a40a:	fe b7       	in	r31, 0x3e	; 62
    a40c:	b4 96       	adiw	r30, 0x24	; 36
    a40e:	0f b6       	in	r0, 0x3f	; 63
    a410:	f8 94       	cli
    a412:	fe bf       	out	0x3e, r31	; 62
    a414:	0f be       	out	0x3f, r0	; 63
    a416:	ed bf       	out	0x3d, r30	; 61
    a418:	8d b7       	in	r24, 0x3d	; 61
    a41a:	9e b7       	in	r25, 0x3e	; 62
    a41c:	84 97       	sbiw	r24, 0x24	; 36
    a41e:	0f b6       	in	r0, 0x3f	; 63
    a420:	f8 94       	cli
    a422:	9e bf       	out	0x3e, r25	; 62
    a424:	0f be       	out	0x3f, r0	; 63
    a426:	8d bf       	out	0x3d, r24	; 61
    a428:	ed b7       	in	r30, 0x3d	; 61
    a42a:	fe b7       	in	r31, 0x3e	; 62
    a42c:	31 96       	adiw	r30, 0x01	; 1
    a42e:	80 91 64 0f 	lds	r24, 0x0F64
    a432:	90 91 65 0f 	lds	r25, 0x0F65
    a436:	cd b7       	in	r28, 0x3d	; 61
    a438:	de b7       	in	r29, 0x3e	; 62
    a43a:	9a 83       	std	Y+2, r25	; 0x02
    a43c:	89 83       	std	Y+1, r24	; 0x01
    a43e:	8a e9       	ldi	r24, 0x9A	; 154
    a440:	99 e1       	ldi	r25, 0x19	; 25
    a442:	93 83       	std	Z+3, r25	; 0x03
    a444:	82 83       	std	Z+2, r24	; 0x02
    a446:	18 96       	adiw	r26, 0x08	; 8
    a448:	8c 91       	ld	r24, X
    a44a:	18 97       	sbiw	r26, 0x08	; 8
    a44c:	84 83       	std	Z+4, r24	; 0x04
    a44e:	15 82       	std	Z+5, r1	; 0x05
    a450:	19 96       	adiw	r26, 0x09	; 9
    a452:	8c 91       	ld	r24, X
    a454:	19 97       	sbiw	r26, 0x09	; 9
    a456:	86 83       	std	Z+6, r24	; 0x06
    a458:	17 82       	std	Z+7, r1	; 0x07
    a45a:	1a 96       	adiw	r26, 0x0a	; 10
    a45c:	8c 91       	ld	r24, X
    a45e:	1a 97       	sbiw	r26, 0x0a	; 10
    a460:	80 87       	std	Z+8, r24	; 0x08
    a462:	11 86       	std	Z+9, r1	; 0x09
    a464:	1b 96       	adiw	r26, 0x0b	; 11
    a466:	8c 91       	ld	r24, X
    a468:	1b 97       	sbiw	r26, 0x0b	; 11
    a46a:	82 87       	std	Z+10, r24	; 0x0a
    a46c:	13 86       	std	Z+11, r1	; 0x0b
    a46e:	1c 96       	adiw	r26, 0x0c	; 12
    a470:	8c 91       	ld	r24, X
    a472:	1c 97       	sbiw	r26, 0x0c	; 12
    a474:	84 87       	std	Z+12, r24	; 0x0c
    a476:	15 86       	std	Z+13, r1	; 0x0d
    a478:	1d 96       	adiw	r26, 0x0d	; 13
    a47a:	8c 91       	ld	r24, X
    a47c:	1d 97       	sbiw	r26, 0x0d	; 13
    a47e:	86 87       	std	Z+14, r24	; 0x0e
    a480:	17 86       	std	Z+15, r1	; 0x0f
    a482:	1e 96       	adiw	r26, 0x0e	; 14
    a484:	8c 91       	ld	r24, X
    a486:	1e 97       	sbiw	r26, 0x0e	; 14
    a488:	80 8b       	std	Z+16, r24	; 0x10
    a48a:	11 8a       	std	Z+17, r1	; 0x11
    a48c:	1f 96       	adiw	r26, 0x0f	; 15
    a48e:	8c 91       	ld	r24, X
    a490:	1f 97       	sbiw	r26, 0x0f	; 15
    a492:	82 8b       	std	Z+18, r24	; 0x12
    a494:	13 8a       	std	Z+19, r1	; 0x13
    a496:	50 96       	adiw	r26, 0x10	; 16
    a498:	8c 91       	ld	r24, X
    a49a:	50 97       	sbiw	r26, 0x10	; 16
    a49c:	84 8b       	std	Z+20, r24	; 0x14
    a49e:	15 8a       	std	Z+21, r1	; 0x15
    a4a0:	51 96       	adiw	r26, 0x11	; 17
    a4a2:	8c 91       	ld	r24, X
    a4a4:	51 97       	sbiw	r26, 0x11	; 17
    a4a6:	86 8b       	std	Z+22, r24	; 0x16
    a4a8:	17 8a       	std	Z+23, r1	; 0x17
    a4aa:	52 96       	adiw	r26, 0x12	; 18
    a4ac:	8c 91       	ld	r24, X
    a4ae:	52 97       	sbiw	r26, 0x12	; 18
    a4b0:	80 8f       	std	Z+24, r24	; 0x18
    a4b2:	11 8e       	std	Z+25, r1	; 0x19
    a4b4:	53 96       	adiw	r26, 0x13	; 19
    a4b6:	8c 91       	ld	r24, X
    a4b8:	53 97       	sbiw	r26, 0x13	; 19
    a4ba:	82 8f       	std	Z+26, r24	; 0x1a
    a4bc:	13 8e       	std	Z+27, r1	; 0x1b
    a4be:	54 96       	adiw	r26, 0x14	; 20
    a4c0:	8c 91       	ld	r24, X
    a4c2:	54 97       	sbiw	r26, 0x14	; 20
    a4c4:	84 8f       	std	Z+28, r24	; 0x1c
    a4c6:	15 8e       	std	Z+29, r1	; 0x1d
    a4c8:	55 96       	adiw	r26, 0x15	; 21
    a4ca:	8c 91       	ld	r24, X
    a4cc:	55 97       	sbiw	r26, 0x15	; 21
    a4ce:	86 8f       	std	Z+30, r24	; 0x1e
    a4d0:	17 8e       	std	Z+31, r1	; 0x1f
    a4d2:	56 96       	adiw	r26, 0x16	; 22
    a4d4:	8c 91       	ld	r24, X
    a4d6:	56 97       	sbiw	r26, 0x16	; 22
    a4d8:	80 a3       	std	Z+32, r24	; 0x20
    a4da:	11 a2       	std	Z+33, r1	; 0x21
    a4dc:	57 96       	adiw	r26, 0x17	; 23
    a4de:	8c 91       	ld	r24, X
    a4e0:	82 a3       	std	Z+34, r24	; 0x22
    a4e2:	13 a2       	std	Z+35, r1	; 0x23
    a4e4:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    
         
	 memcpy(&nicState.layer3.ipv6->destipaddr, &nicState.layer3.ipv6->srcipaddr, sizeof(uip_ip6addr_t));
    a4e8:	80 91 9f 0e 	lds	r24, 0x0E9F
    a4ec:	90 91 a0 0e 	lds	r25, 0x0EA0
    a4f0:	dc 01       	movw	r26, r24
    a4f2:	58 96       	adiw	r26, 0x18	; 24
    a4f4:	fc 01       	movw	r30, r24
    a4f6:	38 96       	adiw	r30, 0x08	; 8
    a4f8:	80 e1       	ldi	r24, 0x10	; 16
    a4fa:	01 90       	ld	r0, Z+
    a4fc:	0d 92       	st	X+, r0
    a4fe:	81 50       	subi	r24, 0x01	; 1
    a500:	e1 f7       	brne	.-8      	; 0xa4fa <uip_nd6_io_ns_input+0x95a>
	 memcpy(&nicState.layer3.ipv6->srcipaddr, &UIP_ND6_NS_BUF->tgtipaddr, sizeof(uip_ip6addr_t));
    a502:	a0 91 9f 0e 	lds	r26, 0x0E9F
    a506:	b0 91 a0 0e 	lds	r27, 0x0EA0
    a50a:	80 91 69 0f 	lds	r24, 0x0F69
    a50e:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a512:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a516:	e8 0f       	add	r30, r24
    a518:	f1 1d       	adc	r31, r1
    a51a:	18 96       	adiw	r26, 0x08	; 8
    a51c:	fe 96       	adiw	r30, 0x3e	; 62
    a51e:	80 e1       	ldi	r24, 0x10	; 16
    a520:	01 90       	ld	r0, Z+
    a522:	0d 92       	st	X+, r0
    a524:	81 50       	subi	r24, 0x01	; 1
    a526:	e1 f7       	brne	.-8      	; 0xa520 <uip_nd6_io_ns_input+0x980>
	 
	 fprintf_P(debugStream, PSTR("MOD addr: \r\n"));
    a528:	ed b7       	in	r30, 0x3d	; 61
    a52a:	fe b7       	in	r31, 0x3e	; 62
    a52c:	b4 96       	adiw	r30, 0x24	; 36
    a52e:	0f b6       	in	r0, 0x3f	; 63
    a530:	f8 94       	cli
    a532:	fe bf       	out	0x3e, r31	; 62
    a534:	0f be       	out	0x3f, r0	; 63
    a536:	ed bf       	out	0x3d, r30	; 61
    a538:	00 d0       	rcall	.+0      	; 0xa53a <uip_nd6_io_ns_input+0x99a>
    a53a:	00 d0       	rcall	.+0      	; 0xa53c <uip_nd6_io_ns_input+0x99c>
    a53c:	80 91 64 0f 	lds	r24, 0x0F64
    a540:	90 91 65 0f 	lds	r25, 0x0F65
    a544:	ad b7       	in	r26, 0x3d	; 61
    a546:	be b7       	in	r27, 0x3e	; 62
    a548:	12 96       	adiw	r26, 0x02	; 2
    a54a:	9c 93       	st	X, r25
    a54c:	8e 93       	st	-X, r24
    a54e:	11 97       	sbiw	r26, 0x01	; 1
    a550:	8d e8       	ldi	r24, 0x8D	; 141
    a552:	99 e1       	ldi	r25, 0x19	; 25
    a554:	14 96       	adiw	r26, 0x04	; 4
    a556:	9c 93       	st	X, r25
    a558:	8e 93       	st	-X, r24
    a55a:	13 97       	sbiw	r26, 0x03	; 3
    a55c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
	 PRINT6ADDR(debugStream, &nicState.layer3.ipv6->destipaddr);
    a560:	a0 91 9f 0e 	lds	r26, 0x0E9F
    a564:	b0 91 a0 0e 	lds	r27, 0x0EA0
    a568:	cd b7       	in	r28, 0x3d	; 61
    a56a:	de b7       	in	r29, 0x3e	; 62
    a56c:	a0 97       	sbiw	r28, 0x20	; 32
    a56e:	0f b6       	in	r0, 0x3f	; 63
    a570:	f8 94       	cli
    a572:	de bf       	out	0x3e, r29	; 62
    a574:	0f be       	out	0x3f, r0	; 63
    a576:	cd bf       	out	0x3d, r28	; 61
    a578:	ed b7       	in	r30, 0x3d	; 61
    a57a:	fe b7       	in	r31, 0x3e	; 62
    a57c:	31 96       	adiw	r30, 0x01	; 1
    a57e:	80 91 64 0f 	lds	r24, 0x0F64
    a582:	90 91 65 0f 	lds	r25, 0x0F65
    a586:	9a 83       	std	Y+2, r25	; 0x02
    a588:	89 83       	std	Y+1, r24	; 0x01
    a58a:	86 e3       	ldi	r24, 0x36	; 54
    a58c:	99 e1       	ldi	r25, 0x19	; 25
    a58e:	93 83       	std	Z+3, r25	; 0x03
    a590:	82 83       	std	Z+2, r24	; 0x02
    a592:	58 96       	adiw	r26, 0x18	; 24
    a594:	8c 91       	ld	r24, X
    a596:	58 97       	sbiw	r26, 0x18	; 24
    a598:	84 83       	std	Z+4, r24	; 0x04
    a59a:	15 82       	std	Z+5, r1	; 0x05
    a59c:	59 96       	adiw	r26, 0x19	; 25
    a59e:	8c 91       	ld	r24, X
    a5a0:	59 97       	sbiw	r26, 0x19	; 25
    a5a2:	86 83       	std	Z+6, r24	; 0x06
    a5a4:	17 82       	std	Z+7, r1	; 0x07
    a5a6:	5a 96       	adiw	r26, 0x1a	; 26
    a5a8:	8c 91       	ld	r24, X
    a5aa:	5a 97       	sbiw	r26, 0x1a	; 26
    a5ac:	80 87       	std	Z+8, r24	; 0x08
    a5ae:	11 86       	std	Z+9, r1	; 0x09
    a5b0:	5b 96       	adiw	r26, 0x1b	; 27
    a5b2:	8c 91       	ld	r24, X
    a5b4:	5b 97       	sbiw	r26, 0x1b	; 27
    a5b6:	82 87       	std	Z+10, r24	; 0x0a
    a5b8:	13 86       	std	Z+11, r1	; 0x0b
    a5ba:	5c 96       	adiw	r26, 0x1c	; 28
    a5bc:	8c 91       	ld	r24, X
    a5be:	5c 97       	sbiw	r26, 0x1c	; 28
    a5c0:	84 87       	std	Z+12, r24	; 0x0c
    a5c2:	15 86       	std	Z+13, r1	; 0x0d
    a5c4:	5d 96       	adiw	r26, 0x1d	; 29
    a5c6:	8c 91       	ld	r24, X
    a5c8:	5d 97       	sbiw	r26, 0x1d	; 29
    a5ca:	86 87       	std	Z+14, r24	; 0x0e
    a5cc:	17 86       	std	Z+15, r1	; 0x0f
    a5ce:	5e 96       	adiw	r26, 0x1e	; 30
    a5d0:	8c 91       	ld	r24, X
    a5d2:	5e 97       	sbiw	r26, 0x1e	; 30
    a5d4:	80 8b       	std	Z+16, r24	; 0x10
    a5d6:	11 8a       	std	Z+17, r1	; 0x11
    a5d8:	5f 96       	adiw	r26, 0x1f	; 31
    a5da:	8c 91       	ld	r24, X
    a5dc:	5f 97       	sbiw	r26, 0x1f	; 31
    a5de:	82 8b       	std	Z+18, r24	; 0x12
    a5e0:	13 8a       	std	Z+19, r1	; 0x13
    a5e2:	90 96       	adiw	r26, 0x20	; 32
    a5e4:	8c 91       	ld	r24, X
    a5e6:	90 97       	sbiw	r26, 0x20	; 32
    a5e8:	84 8b       	std	Z+20, r24	; 0x14
    a5ea:	15 8a       	std	Z+21, r1	; 0x15
    a5ec:	91 96       	adiw	r26, 0x21	; 33
    a5ee:	8c 91       	ld	r24, X
    a5f0:	91 97       	sbiw	r26, 0x21	; 33
    a5f2:	86 8b       	std	Z+22, r24	; 0x16
    a5f4:	17 8a       	std	Z+23, r1	; 0x17
    a5f6:	92 96       	adiw	r26, 0x22	; 34
    a5f8:	8c 91       	ld	r24, X
    a5fa:	92 97       	sbiw	r26, 0x22	; 34
    a5fc:	80 8f       	std	Z+24, r24	; 0x18
    a5fe:	11 8e       	std	Z+25, r1	; 0x19
    a600:	93 96       	adiw	r26, 0x23	; 35
    a602:	8c 91       	ld	r24, X
    a604:	93 97       	sbiw	r26, 0x23	; 35
    a606:	82 8f       	std	Z+26, r24	; 0x1a
    a608:	13 8e       	std	Z+27, r1	; 0x1b
    a60a:	94 96       	adiw	r26, 0x24	; 36
    a60c:	8c 91       	ld	r24, X
    a60e:	94 97       	sbiw	r26, 0x24	; 36
    a610:	84 8f       	std	Z+28, r24	; 0x1c
    a612:	15 8e       	std	Z+29, r1	; 0x1d
    a614:	95 96       	adiw	r26, 0x25	; 37
    a616:	8c 91       	ld	r24, X
    a618:	95 97       	sbiw	r26, 0x25	; 37
    a61a:	86 8f       	std	Z+30, r24	; 0x1e
    a61c:	17 8e       	std	Z+31, r1	; 0x1f
    a61e:	96 96       	adiw	r26, 0x26	; 38
    a620:	8c 91       	ld	r24, X
    a622:	96 97       	sbiw	r26, 0x26	; 38
    a624:	80 a3       	std	Z+32, r24	; 0x20
    a626:	11 a2       	std	Z+33, r1	; 0x21
    a628:	97 96       	adiw	r26, 0x27	; 39
    a62a:	8c 91       	ld	r24, X
    a62c:	82 a3       	std	Z+34, r24	; 0x22
    a62e:	13 a2       	std	Z+35, r1	; 0x23
    a630:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
         PRINT6ADDR(debugStream, &nicState.layer3.ipv6->srcipaddr);
    a634:	a0 91 9f 0e 	lds	r26, 0x0E9F
    a638:	b0 91 a0 0e 	lds	r27, 0x0EA0
    a63c:	ed b7       	in	r30, 0x3d	; 61
    a63e:	fe b7       	in	r31, 0x3e	; 62
    a640:	b4 96       	adiw	r30, 0x24	; 36
    a642:	0f b6       	in	r0, 0x3f	; 63
    a644:	f8 94       	cli
    a646:	fe bf       	out	0x3e, r31	; 62
    a648:	0f be       	out	0x3f, r0	; 63
    a64a:	ed bf       	out	0x3d, r30	; 61
    a64c:	8d b7       	in	r24, 0x3d	; 61
    a64e:	9e b7       	in	r25, 0x3e	; 62
    a650:	84 97       	sbiw	r24, 0x24	; 36
    a652:	0f b6       	in	r0, 0x3f	; 63
    a654:	f8 94       	cli
    a656:	9e bf       	out	0x3e, r25	; 62
    a658:	0f be       	out	0x3f, r0	; 63
    a65a:	8d bf       	out	0x3d, r24	; 61
    a65c:	ed b7       	in	r30, 0x3d	; 61
    a65e:	fe b7       	in	r31, 0x3e	; 62
    a660:	31 96       	adiw	r30, 0x01	; 1
    a662:	80 91 64 0f 	lds	r24, 0x0F64
    a666:	90 91 65 0f 	lds	r25, 0x0F65
    a66a:	cd b7       	in	r28, 0x3d	; 61
    a66c:	de b7       	in	r29, 0x3e	; 62
    a66e:	9a 83       	std	Y+2, r25	; 0x02
    a670:	89 83       	std	Y+1, r24	; 0x01
    a672:	8f ed       	ldi	r24, 0xDF	; 223
    a674:	98 e1       	ldi	r25, 0x18	; 24
    a676:	93 83       	std	Z+3, r25	; 0x03
    a678:	82 83       	std	Z+2, r24	; 0x02
    a67a:	18 96       	adiw	r26, 0x08	; 8
    a67c:	8c 91       	ld	r24, X
    a67e:	18 97       	sbiw	r26, 0x08	; 8
    a680:	84 83       	std	Z+4, r24	; 0x04
    a682:	15 82       	std	Z+5, r1	; 0x05
    a684:	19 96       	adiw	r26, 0x09	; 9
    a686:	8c 91       	ld	r24, X
    a688:	19 97       	sbiw	r26, 0x09	; 9
    a68a:	86 83       	std	Z+6, r24	; 0x06
    a68c:	17 82       	std	Z+7, r1	; 0x07
    a68e:	1a 96       	adiw	r26, 0x0a	; 10
    a690:	8c 91       	ld	r24, X
    a692:	1a 97       	sbiw	r26, 0x0a	; 10
    a694:	80 87       	std	Z+8, r24	; 0x08
    a696:	11 86       	std	Z+9, r1	; 0x09
    a698:	1b 96       	adiw	r26, 0x0b	; 11
    a69a:	8c 91       	ld	r24, X
    a69c:	1b 97       	sbiw	r26, 0x0b	; 11
    a69e:	82 87       	std	Z+10, r24	; 0x0a
    a6a0:	13 86       	std	Z+11, r1	; 0x0b
    a6a2:	1c 96       	adiw	r26, 0x0c	; 12
    a6a4:	8c 91       	ld	r24, X
    a6a6:	1c 97       	sbiw	r26, 0x0c	; 12
    a6a8:	84 87       	std	Z+12, r24	; 0x0c
    a6aa:	15 86       	std	Z+13, r1	; 0x0d
    a6ac:	1d 96       	adiw	r26, 0x0d	; 13
    a6ae:	8c 91       	ld	r24, X
    a6b0:	1d 97       	sbiw	r26, 0x0d	; 13
    a6b2:	86 87       	std	Z+14, r24	; 0x0e
    a6b4:	17 86       	std	Z+15, r1	; 0x0f
    a6b6:	1e 96       	adiw	r26, 0x0e	; 14
    a6b8:	8c 91       	ld	r24, X
    a6ba:	1e 97       	sbiw	r26, 0x0e	; 14
    a6bc:	80 8b       	std	Z+16, r24	; 0x10
    a6be:	11 8a       	std	Z+17, r1	; 0x11
    a6c0:	1f 96       	adiw	r26, 0x0f	; 15
    a6c2:	8c 91       	ld	r24, X
    a6c4:	1f 97       	sbiw	r26, 0x0f	; 15
    a6c6:	82 8b       	std	Z+18, r24	; 0x12
    a6c8:	13 8a       	std	Z+19, r1	; 0x13
    a6ca:	50 96       	adiw	r26, 0x10	; 16
    a6cc:	8c 91       	ld	r24, X
    a6ce:	50 97       	sbiw	r26, 0x10	; 16
    a6d0:	84 8b       	std	Z+20, r24	; 0x14
    a6d2:	15 8a       	std	Z+21, r1	; 0x15
    a6d4:	51 96       	adiw	r26, 0x11	; 17
    a6d6:	8c 91       	ld	r24, X
    a6d8:	51 97       	sbiw	r26, 0x11	; 17
    a6da:	86 8b       	std	Z+22, r24	; 0x16
    a6dc:	17 8a       	std	Z+23, r1	; 0x17
    a6de:	52 96       	adiw	r26, 0x12	; 18
    a6e0:	8c 91       	ld	r24, X
    a6e2:	52 97       	sbiw	r26, 0x12	; 18
    a6e4:	80 8f       	std	Z+24, r24	; 0x18
    a6e6:	11 8e       	std	Z+25, r1	; 0x19
    a6e8:	53 96       	adiw	r26, 0x13	; 19
    a6ea:	8c 91       	ld	r24, X
    a6ec:	53 97       	sbiw	r26, 0x13	; 19
    a6ee:	82 8f       	std	Z+26, r24	; 0x1a
    a6f0:	13 8e       	std	Z+27, r1	; 0x1b
    a6f2:	54 96       	adiw	r26, 0x14	; 20
    a6f4:	8c 91       	ld	r24, X
    a6f6:	54 97       	sbiw	r26, 0x14	; 20
    a6f8:	84 8f       	std	Z+28, r24	; 0x1c
    a6fa:	15 8e       	std	Z+29, r1	; 0x1d
    a6fc:	55 96       	adiw	r26, 0x15	; 21
    a6fe:	8c 91       	ld	r24, X
    a700:	55 97       	sbiw	r26, 0x15	; 21
    a702:	86 8f       	std	Z+30, r24	; 0x1e
    a704:	17 8e       	std	Z+31, r1	; 0x1f
    a706:	56 96       	adiw	r26, 0x16	; 22
    a708:	8c 91       	ld	r24, X
    a70a:	56 97       	sbiw	r26, 0x16	; 22
    a70c:	80 a3       	std	Z+32, r24	; 0x20
    a70e:	11 a2       	std	Z+33, r1	; 0x21
    a710:	57 96       	adiw	r26, 0x17	; 23
    a712:	8c 91       	ld	r24, X
    a714:	82 a3       	std	Z+34, r24	; 0x22
    a716:	13 a2       	std	Z+35, r1	; 0x23
    a718:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    a71c:	ed b7       	in	r30, 0x3d	; 61
    a71e:	fe b7       	in	r31, 0x3e	; 62
    a720:	b4 96       	adiw	r30, 0x24	; 36
    a722:	0f b6       	in	r0, 0x3f	; 63
    a724:	f8 94       	cli
    a726:	fe bf       	out	0x3e, r31	; 62
    a728:	0f be       	out	0x3f, r0	; 63
    a72a:	ed bf       	out	0x3d, r30	; 61
 create_na:
  /* 
   * Fill the part of the NA which is common to all NAs. If the NS contained
   * extension headers, we must set the target address properly
   */
  uip_ext_len = 0; 
    a72c:	10 92 69 0f 	sts	0x0F69, r1
  
#ifdef DEBUG_PRINT_NET_PACKET
    fprintf_P(debugStream, PSTR("NS packet before:\r\n"));    
    a730:	00 d0       	rcall	.+0      	; 0xa732 <uip_nd6_io_ns_input+0xb92>
    a732:	00 d0       	rcall	.+0      	; 0xa734 <uip_nd6_io_ns_input+0xb94>
    a734:	80 91 64 0f 	lds	r24, 0x0F64
    a738:	90 91 65 0f 	lds	r25, 0x0F65
    a73c:	ad b7       	in	r26, 0x3d	; 61
    a73e:	be b7       	in	r27, 0x3e	; 62
    a740:	12 96       	adiw	r26, 0x02	; 2
    a742:	9c 93       	st	X, r25
    a744:	8e 93       	st	-X, r24
    a746:	11 97       	sbiw	r26, 0x01	; 1
    a748:	8b ec       	ldi	r24, 0xCB	; 203
    a74a:	98 e1       	ldi	r25, 0x18	; 24
    a74c:	14 96       	adiw	r26, 0x04	; 4
    a74e:	9c 93       	st	X, r25
    a750:	8e 93       	st	-X, r24
    a752:	13 97       	sbiw	r26, 0x03	; 3
    a754:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    a758:	00 e0       	ldi	r16, 0x00	; 0
    a75a:	0f 90       	pop	r0
    a75c:	0f 90       	pop	r0
    a75e:	0f 90       	pop	r0
    a760:	0f 90       	pop	r0
    for (uint8_t i=0; i < packetLenght; i++)
    {
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
    a762:	28 ec       	ldi	r18, 0xC8	; 200
    a764:	c2 2e       	mov	r12, r18
    a766:	28 e1       	ldi	r18, 0x18	; 24
    a768:	d2 2e       	mov	r13, r18
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    a76a:	92 ec       	ldi	r25, 0xC2	; 194
    a76c:	e9 2e       	mov	r14, r25
    a76e:	98 e1       	ldi	r25, 0x18	; 24
    a770:	f9 2e       	mov	r15, r25
    a772:	42 c0       	rjmp	.+132    	; 0xa7f8 <uip_nd6_io_ns_input+0xc58>
  
#ifdef DEBUG_PRINT_NET_PACKET
    fprintf_P(debugStream, PSTR("NS packet before:\r\n"));    
    for (uint8_t i=0; i < packetLenght; i++)
    {
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
    a774:	00 23       	and	r16, r16
    a776:	b9 f0       	breq	.+46     	; 0xa7a6 <uip_nd6_io_ns_input+0xc06>
    a778:	ce 01       	movw	r24, r28
    a77a:	8f 70       	andi	r24, 0x0F	; 15
    a77c:	90 70       	andi	r25, 0x00	; 0
    a77e:	89 2b       	or	r24, r25
    a780:	91 f4       	brne	.+36     	; 0xa7a6 <uip_nd6_io_ns_input+0xc06>
    a782:	00 d0       	rcall	.+0      	; 0xa784 <uip_nd6_io_ns_input+0xbe4>
    a784:	00 d0       	rcall	.+0      	; 0xa786 <uip_nd6_io_ns_input+0xbe6>
    a786:	80 91 64 0f 	lds	r24, 0x0F64
    a78a:	90 91 65 0f 	lds	r25, 0x0F65
    a78e:	ed b7       	in	r30, 0x3d	; 61
    a790:	fe b7       	in	r31, 0x3e	; 62
    a792:	92 83       	std	Z+2, r25	; 0x02
    a794:	81 83       	std	Z+1, r24	; 0x01
    a796:	d4 82       	std	Z+4, r13	; 0x04
    a798:	c3 82       	std	Z+3, r12	; 0x03
    a79a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    a79e:	0f 90       	pop	r0
    a7a0:	0f 90       	pop	r0
    a7a2:	0f 90       	pop	r0
    a7a4:	0f 90       	pop	r0
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    a7a6:	00 d0       	rcall	.+0      	; 0xa7a8 <uip_nd6_io_ns_input+0xc08>
    a7a8:	00 d0       	rcall	.+0      	; 0xa7aa <uip_nd6_io_ns_input+0xc0a>
    a7aa:	00 d0       	rcall	.+0      	; 0xa7ac <uip_nd6_io_ns_input+0xc0c>
    a7ac:	ad b7       	in	r26, 0x3d	; 61
    a7ae:	be b7       	in	r27, 0x3e	; 62
    a7b0:	11 96       	adiw	r26, 0x01	; 1
    a7b2:	80 91 64 0f 	lds	r24, 0x0F64
    a7b6:	90 91 65 0f 	lds	r25, 0x0F65
    a7ba:	ed b7       	in	r30, 0x3d	; 61
    a7bc:	fe b7       	in	r31, 0x3e	; 62
    a7be:	92 83       	std	Z+2, r25	; 0x02
    a7c0:	81 83       	std	Z+1, r24	; 0x01
    a7c2:	13 96       	adiw	r26, 0x03	; 3
    a7c4:	fc 92       	st	X, r15
    a7c6:	ee 92       	st	-X, r14
    a7c8:	12 97       	sbiw	r26, 0x02	; 2
    a7ca:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a7ce:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a7d2:	ec 0f       	add	r30, r28
    a7d4:	fd 1f       	adc	r31, r29
    a7d6:	80 81       	ld	r24, Z
    a7d8:	14 96       	adiw	r26, 0x04	; 4
    a7da:	8c 93       	st	X, r24
    a7dc:	14 97       	sbiw	r26, 0x04	; 4
    a7de:	15 96       	adiw	r26, 0x05	; 5
    a7e0:	1c 92       	st	X, r1
    a7e2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
   */
  uip_ext_len = 0; 
  
#ifdef DEBUG_PRINT_NET_PACKET
    fprintf_P(debugStream, PSTR("NS packet before:\r\n"));    
    for (uint8_t i=0; i < packetLenght; i++)
    a7e6:	0f 5f       	subi	r16, 0xFF	; 255
    a7e8:	8d b7       	in	r24, 0x3d	; 61
    a7ea:	9e b7       	in	r25, 0x3e	; 62
    a7ec:	06 96       	adiw	r24, 0x06	; 6
    a7ee:	0f b6       	in	r0, 0x3f	; 63
    a7f0:	f8 94       	cli
    a7f2:	9e bf       	out	0x3e, r25	; 62
    a7f4:	0f be       	out	0x3f, r0	; 63
    a7f6:	8d bf       	out	0x3d, r24	; 61
    a7f8:	c0 2f       	mov	r28, r16
    a7fa:	d0 e0       	ldi	r29, 0x00	; 0
    a7fc:	ca 15       	cp	r28, r10
    a7fe:	db 05       	cpc	r29, r11
    a800:	08 f4       	brcc	.+2      	; 0xa804 <uip_nd6_io_ns_input+0xc64>
    a802:	b8 cf       	rjmp	.-144    	; 0xa774 <uip_nd6_io_ns_input+0xbd4>
    {
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    }
    fprintf_P(debugStream, PSTR("\r\n"));
    a804:	00 d0       	rcall	.+0      	; 0xa806 <uip_nd6_io_ns_input+0xc66>
    a806:	00 d0       	rcall	.+0      	; 0xa808 <uip_nd6_io_ns_input+0xc68>
    a808:	80 91 64 0f 	lds	r24, 0x0F64
    a80c:	90 91 65 0f 	lds	r25, 0x0F65
    a810:	ad b7       	in	r26, 0x3d	; 61
    a812:	be b7       	in	r27, 0x3e	; 62
    a814:	12 96       	adiw	r26, 0x02	; 2
    a816:	9c 93       	st	X, r25
    a818:	8e 93       	st	-X, r24
    a81a:	11 97       	sbiw	r26, 0x01	; 1
    a81c:	8f eb       	ldi	r24, 0xBF	; 191
    a81e:	98 e1       	ldi	r25, 0x18	; 24
    a820:	14 96       	adiw	r26, 0x04	; 4
    a822:	9c 93       	st	X, r25
    a824:	8e 93       	st	-X, r24
    a826:	13 97       	sbiw	r26, 0x03	; 3
    a828:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
#endif
  
  
  /* IP header */
  //UIP_IP_BUF->vtc = 0x60;
  nicState.layer3.ipv6->vtc = 0x60;
    a82c:	e0 91 9f 0e 	lds	r30, 0x0E9F
    a830:	f0 91 a0 0e 	lds	r31, 0x0EA0
    a834:	90 e6       	ldi	r25, 0x60	; 96
    a836:	90 83       	st	Z, r25
  nicState.layer3.ipv6->tcflow = 0;
    a838:	e0 91 9f 0e 	lds	r30, 0x0E9F
    a83c:	f0 91 a0 0e 	lds	r31, 0x0EA0
    a840:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ipv6->flow = 0;
    a842:	e0 91 9f 0e 	lds	r30, 0x0E9F
    a846:	f0 91 a0 0e 	lds	r31, 0x0EA0
    a84a:	13 82       	std	Z+3, r1	; 0x03
    a84c:	12 82       	std	Z+2, r1	; 0x02
  nicState.layer3.ipv6->len[0] = 0; /* length will not be more than 255 */
    a84e:	e0 91 9f 0e 	lds	r30, 0x0E9F
    a852:	f0 91 a0 0e 	lds	r31, 0x0EA0
    a856:	14 82       	std	Z+4, r1	; 0x04
  nicState.layer3.ipv6->len[1] = UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN;
    a858:	e0 91 9f 0e 	lds	r30, 0x0E9F
    a85c:	f0 91 a0 0e 	lds	r31, 0x0EA0
    a860:	80 e2       	ldi	r24, 0x20	; 32
    a862:	85 83       	std	Z+5, r24	; 0x05
  nicState.layer3.ipv6->proto = UIP_PROTO_ICMP6;
    a864:	e0 91 9f 0e 	lds	r30, 0x0E9F
    a868:	f0 91 a0 0e 	lds	r31, 0x0EA0
    a86c:	8a e3       	ldi	r24, 0x3A	; 58
    a86e:	86 83       	std	Z+6, r24	; 0x06
  nicState.layer3.ipv6->ttl = UIP_ND6_HOP_LIMIT;
    a870:	e0 91 9f 0e 	lds	r30, 0x0E9F
    a874:	f0 91 a0 0e 	lds	r31, 0x0EA0
    a878:	8f ef       	ldi	r24, 0xFF	; 255
    a87a:	87 83       	std	Z+7, r24	; 0x07

  /* ICMP header */
  UIP_ICMP_BUF->type = ICMP6_NA;
    a87c:	80 91 69 0f 	lds	r24, 0x0F69
    a880:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a884:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a888:	e8 0f       	add	r30, r24
    a88a:	f1 1d       	adc	r31, r1
    a88c:	88 e8       	ldi	r24, 0x88	; 136
    a88e:	86 ab       	std	Z+54, r24	; 0x36
  UIP_ICMP_BUF->icode = 0;
    a890:	80 91 69 0f 	lds	r24, 0x0F69
    a894:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a898:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a89c:	e8 0f       	add	r30, r24
    a89e:	f1 1d       	adc	r31, r1
    a8a0:	17 aa       	std	Z+55, r1	; 0x37

  /* NA static part */
  UIP_ND6_NA_BUF->flagsreserved = flags;
    a8a2:	80 91 69 0f 	lds	r24, 0x0F69
    a8a6:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a8aa:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a8ae:	e8 0f       	add	r30, r24
    a8b0:	f1 1d       	adc	r31, r1
    a8b2:	92 af       	std	Z+58, r25	; 0x3a
  memcpy(&UIP_ND6_NA_BUF->tgtipaddr, &ifaddr->ipaddr, sizeof(uip_ipaddr_t)); /////////////////////
    a8b4:	80 91 69 0f 	lds	r24, 0x0F69
    a8b8:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a8bc:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a8c0:	e8 0f       	add	r30, r24
    a8c2:	f1 1d       	adc	r31, r1
    a8c4:	fe 96       	adiw	r30, 0x3e	; 62
    a8c6:	20 91 a6 01 	lds	r18, 0x01A6
    a8ca:	30 91 a7 01 	lds	r19, 0x01A7
    a8ce:	c9 01       	movw	r24, r18
    a8d0:	dc 01       	movw	r26, r24
    a8d2:	80 e1       	ldi	r24, 0x10	; 16
    a8d4:	0d 90       	ld	r0, X+
    a8d6:	01 92       	st	Z+, r0
    a8d8:	81 50       	subi	r24, 0x01	; 1
    a8da:	e1 f7       	brne	.-8      	; 0xa8d4 <uip_nd6_io_ns_input+0xd34>

  /* NA option: TLLAO. note that length field is in unit of 8 bytes */
  packetLenght = UIP_IPH_LEN + UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN + ETH_HEADER_LEN;
  nd6_opt_llao = (struct uip_nd6_opt_llao *)&nicState.layer2.buf[uip_l2_l3_icmp_hdr_len + UIP_ND6_NA_LEN];
    a8dc:	80 91 69 0f 	lds	r24, 0x0F69
    a8e0:	90 e0       	ldi	r25, 0x00	; 0
    a8e2:	82 5b       	subi	r24, 0xB2	; 178
    a8e4:	9f 4f       	sbci	r25, 0xFF	; 255
    a8e6:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a8ea:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a8ee:	e8 0f       	add	r30, r24
    a8f0:	f9 1f       	adc	r31, r25
    a8f2:	f0 93 a5 01 	sts	0x01A5, r31
    a8f6:	e0 93 a4 01 	sts	0x01A4, r30
  nd6_opt_llao->type = UIP_ND6_OPT_TLLAO;
    a8fa:	82 e0       	ldi	r24, 0x02	; 2
    a8fc:	80 83       	st	Z, r24
  nd6_opt_llao->len = UIP_ND6_OPT_LLAO_LEN >> 3;
    a8fe:	e0 91 a4 01 	lds	r30, 0x01A4
    a902:	f0 91 a5 01 	lds	r31, 0x01A5
    a906:	81 e0       	ldi	r24, 0x01	; 1
    a908:	81 83       	std	Z+1, r24	; 0x01
  
 fprintf_P(debugStream, PSTR("&nicState.mac.addr %02x \n\r"), &nicState.mac.addr);
    a90a:	00 d0       	rcall	.+0      	; 0xa90c <uip_nd6_io_ns_input+0xd6c>
    a90c:	ed b7       	in	r30, 0x3d	; 61
    a90e:	fe b7       	in	r31, 0x3e	; 62
    a910:	31 96       	adiw	r30, 0x01	; 1
    a912:	80 91 64 0f 	lds	r24, 0x0F64
    a916:	90 91 65 0f 	lds	r25, 0x0F65
    a91a:	cd b7       	in	r28, 0x3d	; 61
    a91c:	de b7       	in	r29, 0x3e	; 62
    a91e:	9a 83       	std	Y+2, r25	; 0x02
    a920:	89 83       	std	Y+1, r24	; 0x01
    a922:	84 ea       	ldi	r24, 0xA4	; 164
    a924:	98 e1       	ldi	r25, 0x18	; 24
    a926:	93 83       	std	Z+3, r25	; 0x03
    a928:	82 83       	std	Z+2, r24	; 0x02
    a92a:	07 e9       	ldi	r16, 0x97	; 151
    a92c:	1e e0       	ldi	r17, 0x0E	; 14
    a92e:	15 83       	std	Z+5, r17	; 0x05
    a930:	04 83       	std	Z+4, r16	; 0x04
    a932:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  
  memcpy(&(nd6_opt_llao->addr.addr), &nicState.mac.addr, ETH_HEADER_LEN);
    a936:	e0 91 a4 01 	lds	r30, 0x01A4
    a93a:	f0 91 a5 01 	lds	r31, 0x01A5
    a93e:	32 96       	adiw	r30, 0x02	; 2
    a940:	d8 01       	movw	r26, r16
    a942:	8e e0       	ldi	r24, 0x0E	; 14
    a944:	0d 90       	ld	r0, X+
    a946:	01 92       	st	Z+, r0
    a948:	81 50       	subi	r24, 0x01	; 1
    a94a:	e1 f7       	brne	.-8      	; 0xa944 <uip_nd6_io_ns_input+0xda4>
  /* padding if needed */
  memset((void *)(&nd6_opt_llao->addr.addr) + UIP_LLADDR_LEN, 0, UIP_ND6_OPT_LLAO_LEN - 2 - UIP_LLADDR_LEN);

  /*ICMP checksum*/
  fprintf_P(debugStream, PSTR("nicState.layer4.icmp->icmpchksum  %04x\n\r"), UIP_ICMP_BUF->icmpchksum );
    a94c:	ad b7       	in	r26, 0x3d	; 61
    a94e:	be b7       	in	r27, 0x3e	; 62
    a950:	11 96       	adiw	r26, 0x01	; 1
    a952:	80 91 64 0f 	lds	r24, 0x0F64
    a956:	90 91 65 0f 	lds	r25, 0x0F65
    a95a:	ed b7       	in	r30, 0x3d	; 61
    a95c:	fe b7       	in	r31, 0x3e	; 62
    a95e:	92 83       	std	Z+2, r25	; 0x02
    a960:	81 83       	std	Z+1, r24	; 0x01
    a962:	8b e7       	ldi	r24, 0x7B	; 123
    a964:	98 e1       	ldi	r25, 0x18	; 24
    a966:	13 96       	adiw	r26, 0x03	; 3
    a968:	9c 93       	st	X, r25
    a96a:	8e 93       	st	-X, r24
    a96c:	12 97       	sbiw	r26, 0x02	; 2
    a96e:	80 91 69 0f 	lds	r24, 0x0F69
    a972:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a976:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a97a:	e8 0f       	add	r30, r24
    a97c:	f1 1d       	adc	r31, r1
    a97e:	80 ad       	ldd	r24, Z+56	; 0x38
    a980:	91 ad       	ldd	r25, Z+57	; 0x39
    a982:	15 96       	adiw	r26, 0x05	; 5
    a984:	9c 93       	st	X, r25
    a986:	8e 93       	st	-X, r24
    a988:	14 97       	sbiw	r26, 0x04	; 4
    a98a:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  UIP_ICMP_BUF->icmpchksum = 0;
    a98e:	80 91 69 0f 	lds	r24, 0x0F69
    a992:	90 e0       	ldi	r25, 0x00	; 0
    a994:	e0 91 9d 0e 	lds	r30, 0x0E9D
    a998:	f0 91 9e 0e 	lds	r31, 0x0E9E
    a99c:	e8 0f       	add	r30, r24
    a99e:	f9 1f       	adc	r31, r25
    a9a0:	11 ae       	std	Z+57, r1	; 0x39
    a9a2:	10 ae       	std	Z+56, r1	; 0x38
  UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();   
    a9a4:	c6 96       	adiw	r24, 0x36	; 54
    a9a6:	00 91 9d 0e 	lds	r16, 0x0E9D
    a9aa:	10 91 9e 0e 	lds	r17, 0x0E9E
    a9ae:	08 0f       	add	r16, r24
    a9b0:	19 1f       	adc	r17, r25
    a9b2:	8d b7       	in	r24, 0x3d	; 61
    a9b4:	9e b7       	in	r25, 0x3e	; 62
    a9b6:	06 96       	adiw	r24, 0x06	; 6
    a9b8:	0f b6       	in	r0, 0x3f	; 63
    a9ba:	f8 94       	cli
    a9bc:	9e bf       	out	0x3e, r25	; 62
    a9be:	0f be       	out	0x3f, r0	; 63
    a9c0:	8d bf       	out	0x3d, r24	; 61
    a9c2:	0e 94 71 4c 	call	0x98e2	; 0x98e2 <uip_icmp6chksum>
    a9c6:	80 95       	com	r24
    a9c8:	90 95       	com	r25
    a9ca:	d8 01       	movw	r26, r16
    a9cc:	13 96       	adiw	r26, 0x03	; 3
    a9ce:	9c 93       	st	X, r25
    a9d0:	8e 93       	st	-X, r24
    a9d2:	12 97       	sbiw	r26, 0x02	; 2
  ///nicState.layer4.icmpv6->icmpchksum = 0;
  ///nicState.layer4.icmpv6->icmpchksum =  ~uip_icmp6chksum();
	      //netChecksum((uint8_t*)(&nicState.layer4.icmpv6 + 4), 28 );// htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
  fprintf_P(debugStream, PSTR("nicState.layer4.icmp->icmpchksum  %04x\n\r"), UIP_ICMP_BUF->icmpchksum );
    a9d4:	00 d0       	rcall	.+0      	; 0xa9d6 <uip_nd6_io_ns_input+0xe36>
    a9d6:	00 d0       	rcall	.+0      	; 0xa9d8 <uip_nd6_io_ns_input+0xe38>
    a9d8:	00 d0       	rcall	.+0      	; 0xa9da <uip_nd6_io_ns_input+0xe3a>
    a9da:	ad b7       	in	r26, 0x3d	; 61
    a9dc:	be b7       	in	r27, 0x3e	; 62
    a9de:	11 96       	adiw	r26, 0x01	; 1
    a9e0:	80 91 64 0f 	lds	r24, 0x0F64
    a9e4:	90 91 65 0f 	lds	r25, 0x0F65
    a9e8:	cd b7       	in	r28, 0x3d	; 61
    a9ea:	de b7       	in	r29, 0x3e	; 62
    a9ec:	9a 83       	std	Y+2, r25	; 0x02
    a9ee:	89 83       	std	Y+1, r24	; 0x01
    a9f0:	82 e5       	ldi	r24, 0x52	; 82
    a9f2:	98 e1       	ldi	r25, 0x18	; 24
    a9f4:	13 96       	adiw	r26, 0x03	; 3
    a9f6:	9c 93       	st	X, r25
    a9f8:	8e 93       	st	-X, r24
    a9fa:	12 97       	sbiw	r26, 0x02	; 2
    a9fc:	80 91 69 0f 	lds	r24, 0x0F69
    aa00:	e0 91 9d 0e 	lds	r30, 0x0E9D
    aa04:	f0 91 9e 0e 	lds	r31, 0x0E9E
    aa08:	e8 0f       	add	r30, r24
    aa0a:	f1 1d       	adc	r31, r1
    aa0c:	80 ad       	ldd	r24, Z+56	; 0x38
    aa0e:	91 ad       	ldd	r25, Z+57	; 0x39
    aa10:	15 96       	adiw	r26, 0x05	; 5
    aa12:	9c 93       	st	X, r25
    aa14:	8e 93       	st	-X, r24
    aa16:	14 97       	sbiw	r26, 0x04	; 4
    aa18:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  //nicState.layer4.icmpv6->icmpchksum = 0x923b;

  #ifdef DEBUG_PRINT_NET_PACKET
    fprintf_P(debugStream, PSTR("NS packet AFTER:\r\n"));    
    aa1c:	0f 90       	pop	r0
    aa1e:	0f 90       	pop	r0
    aa20:	80 91 64 0f 	lds	r24, 0x0F64
    aa24:	90 91 65 0f 	lds	r25, 0x0F65
    aa28:	ed b7       	in	r30, 0x3d	; 61
    aa2a:	fe b7       	in	r31, 0x3e	; 62
    aa2c:	92 83       	std	Z+2, r25	; 0x02
    aa2e:	81 83       	std	Z+1, r24	; 0x01
    aa30:	8f e3       	ldi	r24, 0x3F	; 63
    aa32:	98 e1       	ldi	r25, 0x18	; 24
    aa34:	94 83       	std	Z+4, r25	; 0x04
    aa36:	83 83       	std	Z+3, r24	; 0x03
    aa38:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    aa3c:	c1 e0       	ldi	r28, 0x01	; 1
    aa3e:	d0 e0       	ldi	r29, 0x00	; 0
    aa40:	0f 90       	pop	r0
    aa42:	0f 90       	pop	r0
    aa44:	0f 90       	pop	r0
    aa46:	0f 90       	pop	r0
    for (uint8_t i=0; i < packetLenght; i++)
    {
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    aa48:	86 e3       	ldi	r24, 0x36	; 54
    aa4a:	e8 2e       	mov	r14, r24
    aa4c:	88 e1       	ldi	r24, 0x18	; 24
    aa4e:	f8 2e       	mov	r15, r24

  #ifdef DEBUG_PRINT_NET_PACKET
    fprintf_P(debugStream, PSTR("NS packet AFTER:\r\n"));    
    for (uint8_t i=0; i < packetLenght; i++)
    {
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
    aa50:	0c e3       	ldi	r16, 0x3C	; 60
    aa52:	18 e1       	ldi	r17, 0x18	; 24
    aa54:	1c c0       	rjmp	.+56     	; 0xaa8e <uip_nd6_io_ns_input+0xeee>
    aa56:	ce 01       	movw	r24, r28
    aa58:	8f 70       	andi	r24, 0x0F	; 15
    aa5a:	90 70       	andi	r25, 0x00	; 0
    aa5c:	89 2b       	or	r24, r25
    aa5e:	b1 f4       	brne	.+44     	; 0xaa8c <uip_nd6_io_ns_input+0xeec>
    aa60:	00 d0       	rcall	.+0      	; 0xaa62 <uip_nd6_io_ns_input+0xec2>
    aa62:	00 d0       	rcall	.+0      	; 0xaa64 <uip_nd6_io_ns_input+0xec4>
    aa64:	80 91 64 0f 	lds	r24, 0x0F64
    aa68:	90 91 65 0f 	lds	r25, 0x0F65
    aa6c:	ad b7       	in	r26, 0x3d	; 61
    aa6e:	be b7       	in	r27, 0x3e	; 62
    aa70:	12 96       	adiw	r26, 0x02	; 2
    aa72:	9c 93       	st	X, r25
    aa74:	8e 93       	st	-X, r24
    aa76:	11 97       	sbiw	r26, 0x01	; 1
    aa78:	14 96       	adiw	r26, 0x04	; 4
    aa7a:	1c 93       	st	X, r17
    aa7c:	0e 93       	st	-X, r16
    aa7e:	13 97       	sbiw	r26, 0x03	; 3
    aa80:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    aa84:	0f 90       	pop	r0
    aa86:	0f 90       	pop	r0
    aa88:	0f 90       	pop	r0
    aa8a:	0f 90       	pop	r0
    aa8c:	21 96       	adiw	r28, 0x01	; 1
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    aa8e:	00 d0       	rcall	.+0      	; 0xaa90 <uip_nd6_io_ns_input+0xef0>
    aa90:	00 d0       	rcall	.+0      	; 0xaa92 <uip_nd6_io_ns_input+0xef2>
    aa92:	00 d0       	rcall	.+0      	; 0xaa94 <uip_nd6_io_ns_input+0xef4>
    aa94:	ad b7       	in	r26, 0x3d	; 61
    aa96:	be b7       	in	r27, 0x3e	; 62
    aa98:	11 96       	adiw	r26, 0x01	; 1
    aa9a:	80 91 64 0f 	lds	r24, 0x0F64
    aa9e:	90 91 65 0f 	lds	r25, 0x0F65
    aaa2:	ed b7       	in	r30, 0x3d	; 61
    aaa4:	fe b7       	in	r31, 0x3e	; 62
    aaa6:	92 83       	std	Z+2, r25	; 0x02
    aaa8:	81 83       	std	Z+1, r24	; 0x01
    aaaa:	13 96       	adiw	r26, 0x03	; 3
    aaac:	fc 92       	st	X, r15
    aaae:	ee 92       	st	-X, r14
    aab0:	12 97       	sbiw	r26, 0x02	; 2
    aab2:	e0 91 9d 0e 	lds	r30, 0x0E9D
    aab6:	f0 91 9e 0e 	lds	r31, 0x0E9E
    aaba:	ec 0f       	add	r30, r28
    aabc:	fd 1f       	adc	r31, r29
    aabe:	31 97       	sbiw	r30, 0x01	; 1
    aac0:	80 81       	ld	r24, Z
    aac2:	14 96       	adiw	r26, 0x04	; 4
    aac4:	8c 93       	st	X, r24
    aac6:	14 97       	sbiw	r26, 0x04	; 4
    aac8:	15 96       	adiw	r26, 0x05	; 5
    aaca:	1c 92       	st	X, r1
    aacc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  fprintf_P(debugStream, PSTR("nicState.layer4.icmp->icmpchksum  %04x\n\r"), UIP_ICMP_BUF->icmpchksum );
  //nicState.layer4.icmpv6->icmpchksum = 0x923b;

  #ifdef DEBUG_PRINT_NET_PACKET
    fprintf_P(debugStream, PSTR("NS packet AFTER:\r\n"));    
    for (uint8_t i=0; i < packetLenght; i++)
    aad0:	8d b7       	in	r24, 0x3d	; 61
    aad2:	9e b7       	in	r25, 0x3e	; 62
    aad4:	06 96       	adiw	r24, 0x06	; 6
    aad6:	0f b6       	in	r0, 0x3f	; 63
    aad8:	f8 94       	cli
    aada:	9e bf       	out	0x3e, r25	; 62
    aadc:	0f be       	out	0x3f, r0	; 63
    aade:	8d bf       	out	0x3d, r24	; 61
    aae0:	c6 35       	cpi	r28, 0x56	; 86
    aae2:	d1 05       	cpc	r29, r1
    aae4:	09 f0       	breq	.+2      	; 0xaae8 <uip_nd6_io_ns_input+0xf48>
    aae6:	b7 cf       	rjmp	.-146    	; 0xaa56 <uip_nd6_io_ns_input+0xeb6>
    {
      if (i!=0 && i%16==0) fprintf_P(debugStream, PSTR("\r\n"));
      fprintf_P(debugStream, PSTR("%02x:"), nicState.layer2.buf[i]);
    }
    fprintf_P(debugStream, PSTR("\r\n"));
    aae8:	00 d0       	rcall	.+0      	; 0xaaea <uip_nd6_io_ns_input+0xf4a>
    aaea:	00 d0       	rcall	.+0      	; 0xaaec <uip_nd6_io_ns_input+0xf4c>
    aaec:	80 91 64 0f 	lds	r24, 0x0F64
    aaf0:	90 91 65 0f 	lds	r25, 0x0F65
    aaf4:	ad b7       	in	r26, 0x3d	; 61
    aaf6:	be b7       	in	r27, 0x3e	; 62
    aaf8:	12 96       	adiw	r26, 0x02	; 2
    aafa:	9c 93       	st	X, r25
    aafc:	8e 93       	st	-X, r24
    aafe:	11 97       	sbiw	r26, 0x01	; 1
    ab00:	83 e3       	ldi	r24, 0x33	; 51
    ab02:	98 e1       	ldi	r25, 0x18	; 24
    ab04:	14 96       	adiw	r26, 0x04	; 4
    ab06:	9c 93       	st	X, r25
    ab08:	8e 93       	st	-X, r24
    ab0a:	13 97       	sbiw	r26, 0x03	; 3
    ab0c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
#endif
  
  PRINTF2(debugStream,"Sending NA to\n\r");
    ab10:	80 91 64 0f 	lds	r24, 0x0F64
    ab14:	90 91 65 0f 	lds	r25, 0x0F65
    ab18:	cd b7       	in	r28, 0x3d	; 61
    ab1a:	de b7       	in	r29, 0x3e	; 62
    ab1c:	9a 83       	std	Y+2, r25	; 0x02
    ab1e:	89 83       	std	Y+1, r24	; 0x01
    ab20:	83 e2       	ldi	r24, 0x23	; 35
    ab22:	98 e1       	ldi	r25, 0x18	; 24
    ab24:	9c 83       	std	Y+4, r25	; 0x04
    ab26:	8b 83       	std	Y+3, r24	; 0x03
    ab28:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINT6ADDR(debugStream,&UIP_IP_BUF->destipaddr);
    ab2c:	a0 91 9d 0e 	lds	r26, 0x0E9D
    ab30:	b0 91 9e 0e 	lds	r27, 0x0E9E
    ab34:	1e 96       	adiw	r26, 0x0e	; 14
    ab36:	ed b7       	in	r30, 0x3d	; 61
    ab38:	fe b7       	in	r31, 0x3e	; 62
    ab3a:	b0 97       	sbiw	r30, 0x20	; 32
    ab3c:	0f b6       	in	r0, 0x3f	; 63
    ab3e:	f8 94       	cli
    ab40:	fe bf       	out	0x3e, r31	; 62
    ab42:	0f be       	out	0x3f, r0	; 63
    ab44:	ed bf       	out	0x3d, r30	; 61
    ab46:	31 96       	adiw	r30, 0x01	; 1
    ab48:	80 91 64 0f 	lds	r24, 0x0F64
    ab4c:	90 91 65 0f 	lds	r25, 0x0F65
    ab50:	cd b7       	in	r28, 0x3d	; 61
    ab52:	de b7       	in	r29, 0x3e	; 62
    ab54:	9a 83       	std	Y+2, r25	; 0x02
    ab56:	89 83       	std	Y+1, r24	; 0x01
    ab58:	8c ec       	ldi	r24, 0xCC	; 204
    ab5a:	97 e1       	ldi	r25, 0x17	; 23
    ab5c:	93 83       	std	Z+3, r25	; 0x03
    ab5e:	82 83       	std	Z+2, r24	; 0x02
    ab60:	58 96       	adiw	r26, 0x18	; 24
    ab62:	8c 91       	ld	r24, X
    ab64:	58 97       	sbiw	r26, 0x18	; 24
    ab66:	84 83       	std	Z+4, r24	; 0x04
    ab68:	15 82       	std	Z+5, r1	; 0x05
    ab6a:	59 96       	adiw	r26, 0x19	; 25
    ab6c:	8c 91       	ld	r24, X
    ab6e:	59 97       	sbiw	r26, 0x19	; 25
    ab70:	86 83       	std	Z+6, r24	; 0x06
    ab72:	17 82       	std	Z+7, r1	; 0x07
    ab74:	5a 96       	adiw	r26, 0x1a	; 26
    ab76:	8c 91       	ld	r24, X
    ab78:	5a 97       	sbiw	r26, 0x1a	; 26
    ab7a:	80 87       	std	Z+8, r24	; 0x08
    ab7c:	11 86       	std	Z+9, r1	; 0x09
    ab7e:	5b 96       	adiw	r26, 0x1b	; 27
    ab80:	8c 91       	ld	r24, X
    ab82:	5b 97       	sbiw	r26, 0x1b	; 27
    ab84:	82 87       	std	Z+10, r24	; 0x0a
    ab86:	13 86       	std	Z+11, r1	; 0x0b
    ab88:	5c 96       	adiw	r26, 0x1c	; 28
    ab8a:	8c 91       	ld	r24, X
    ab8c:	5c 97       	sbiw	r26, 0x1c	; 28
    ab8e:	84 87       	std	Z+12, r24	; 0x0c
    ab90:	15 86       	std	Z+13, r1	; 0x0d
    ab92:	5d 96       	adiw	r26, 0x1d	; 29
    ab94:	8c 91       	ld	r24, X
    ab96:	5d 97       	sbiw	r26, 0x1d	; 29
    ab98:	86 87       	std	Z+14, r24	; 0x0e
    ab9a:	17 86       	std	Z+15, r1	; 0x0f
    ab9c:	5e 96       	adiw	r26, 0x1e	; 30
    ab9e:	8c 91       	ld	r24, X
    aba0:	5e 97       	sbiw	r26, 0x1e	; 30
    aba2:	80 8b       	std	Z+16, r24	; 0x10
    aba4:	11 8a       	std	Z+17, r1	; 0x11
    aba6:	5f 96       	adiw	r26, 0x1f	; 31
    aba8:	8c 91       	ld	r24, X
    abaa:	5f 97       	sbiw	r26, 0x1f	; 31
    abac:	82 8b       	std	Z+18, r24	; 0x12
    abae:	13 8a       	std	Z+19, r1	; 0x13
    abb0:	90 96       	adiw	r26, 0x20	; 32
    abb2:	8c 91       	ld	r24, X
    abb4:	90 97       	sbiw	r26, 0x20	; 32
    abb6:	84 8b       	std	Z+20, r24	; 0x14
    abb8:	15 8a       	std	Z+21, r1	; 0x15
    abba:	91 96       	adiw	r26, 0x21	; 33
    abbc:	8c 91       	ld	r24, X
    abbe:	91 97       	sbiw	r26, 0x21	; 33
    abc0:	86 8b       	std	Z+22, r24	; 0x16
    abc2:	17 8a       	std	Z+23, r1	; 0x17
    abc4:	92 96       	adiw	r26, 0x22	; 34
    abc6:	8c 91       	ld	r24, X
    abc8:	92 97       	sbiw	r26, 0x22	; 34
    abca:	80 8f       	std	Z+24, r24	; 0x18
    abcc:	11 8e       	std	Z+25, r1	; 0x19
    abce:	93 96       	adiw	r26, 0x23	; 35
    abd0:	8c 91       	ld	r24, X
    abd2:	93 97       	sbiw	r26, 0x23	; 35
    abd4:	82 8f       	std	Z+26, r24	; 0x1a
    abd6:	13 8e       	std	Z+27, r1	; 0x1b
    abd8:	94 96       	adiw	r26, 0x24	; 36
    abda:	8c 91       	ld	r24, X
    abdc:	94 97       	sbiw	r26, 0x24	; 36
    abde:	84 8f       	std	Z+28, r24	; 0x1c
    abe0:	15 8e       	std	Z+29, r1	; 0x1d
    abe2:	95 96       	adiw	r26, 0x25	; 37
    abe4:	8c 91       	ld	r24, X
    abe6:	95 97       	sbiw	r26, 0x25	; 37
    abe8:	86 8f       	std	Z+30, r24	; 0x1e
    abea:	17 8e       	std	Z+31, r1	; 0x1f
    abec:	96 96       	adiw	r26, 0x26	; 38
    abee:	8c 91       	ld	r24, X
    abf0:	96 97       	sbiw	r26, 0x26	; 38
    abf2:	80 a3       	std	Z+32, r24	; 0x20
    abf4:	11 a2       	std	Z+33, r1	; 0x21
    abf6:	97 96       	adiw	r26, 0x27	; 39
    abf8:	8c 91       	ld	r24, X
    abfa:	82 a3       	std	Z+34, r24	; 0x22
    abfc:	13 a2       	std	Z+35, r1	; 0x23
    abfe:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    PRINT6ADDR(debugStream, &nicState.layer3.ipv6->destipaddr);
    ac02:	a0 91 9f 0e 	lds	r26, 0x0E9F
    ac06:	b0 91 a0 0e 	lds	r27, 0x0EA0
    ac0a:	ed b7       	in	r30, 0x3d	; 61
    ac0c:	fe b7       	in	r31, 0x3e	; 62
    ac0e:	b4 96       	adiw	r30, 0x24	; 36
    ac10:	0f b6       	in	r0, 0x3f	; 63
    ac12:	f8 94       	cli
    ac14:	fe bf       	out	0x3e, r31	; 62
    ac16:	0f be       	out	0x3f, r0	; 63
    ac18:	ed bf       	out	0x3d, r30	; 61
    ac1a:	8d b7       	in	r24, 0x3d	; 61
    ac1c:	9e b7       	in	r25, 0x3e	; 62
    ac1e:	84 97       	sbiw	r24, 0x24	; 36
    ac20:	0f b6       	in	r0, 0x3f	; 63
    ac22:	f8 94       	cli
    ac24:	9e bf       	out	0x3e, r25	; 62
    ac26:	0f be       	out	0x3f, r0	; 63
    ac28:	8d bf       	out	0x3d, r24	; 61
    ac2a:	ed b7       	in	r30, 0x3d	; 61
    ac2c:	fe b7       	in	r31, 0x3e	; 62
    ac2e:	31 96       	adiw	r30, 0x01	; 1
    ac30:	80 91 64 0f 	lds	r24, 0x0F64
    ac34:	90 91 65 0f 	lds	r25, 0x0F65
    ac38:	cd b7       	in	r28, 0x3d	; 61
    ac3a:	de b7       	in	r29, 0x3e	; 62
    ac3c:	9a 83       	std	Y+2, r25	; 0x02
    ac3e:	89 83       	std	Y+1, r24	; 0x01
    ac40:	85 e7       	ldi	r24, 0x75	; 117
    ac42:	97 e1       	ldi	r25, 0x17	; 23
    ac44:	93 83       	std	Z+3, r25	; 0x03
    ac46:	82 83       	std	Z+2, r24	; 0x02
    ac48:	58 96       	adiw	r26, 0x18	; 24
    ac4a:	8c 91       	ld	r24, X
    ac4c:	58 97       	sbiw	r26, 0x18	; 24
    ac4e:	84 83       	std	Z+4, r24	; 0x04
    ac50:	15 82       	std	Z+5, r1	; 0x05
    ac52:	59 96       	adiw	r26, 0x19	; 25
    ac54:	8c 91       	ld	r24, X
    ac56:	59 97       	sbiw	r26, 0x19	; 25
    ac58:	86 83       	std	Z+6, r24	; 0x06
    ac5a:	17 82       	std	Z+7, r1	; 0x07
    ac5c:	5a 96       	adiw	r26, 0x1a	; 26
    ac5e:	8c 91       	ld	r24, X
    ac60:	5a 97       	sbiw	r26, 0x1a	; 26
    ac62:	80 87       	std	Z+8, r24	; 0x08
    ac64:	11 86       	std	Z+9, r1	; 0x09
    ac66:	5b 96       	adiw	r26, 0x1b	; 27
    ac68:	8c 91       	ld	r24, X
    ac6a:	5b 97       	sbiw	r26, 0x1b	; 27
    ac6c:	82 87       	std	Z+10, r24	; 0x0a
    ac6e:	13 86       	std	Z+11, r1	; 0x0b
    ac70:	5c 96       	adiw	r26, 0x1c	; 28
    ac72:	8c 91       	ld	r24, X
    ac74:	5c 97       	sbiw	r26, 0x1c	; 28
    ac76:	84 87       	std	Z+12, r24	; 0x0c
    ac78:	15 86       	std	Z+13, r1	; 0x0d
    ac7a:	5d 96       	adiw	r26, 0x1d	; 29
    ac7c:	8c 91       	ld	r24, X
    ac7e:	5d 97       	sbiw	r26, 0x1d	; 29
    ac80:	86 87       	std	Z+14, r24	; 0x0e
    ac82:	17 86       	std	Z+15, r1	; 0x0f
    ac84:	5e 96       	adiw	r26, 0x1e	; 30
    ac86:	8c 91       	ld	r24, X
    ac88:	5e 97       	sbiw	r26, 0x1e	; 30
    ac8a:	80 8b       	std	Z+16, r24	; 0x10
    ac8c:	11 8a       	std	Z+17, r1	; 0x11
    ac8e:	5f 96       	adiw	r26, 0x1f	; 31
    ac90:	8c 91       	ld	r24, X
    ac92:	5f 97       	sbiw	r26, 0x1f	; 31
    ac94:	82 8b       	std	Z+18, r24	; 0x12
    ac96:	13 8a       	std	Z+19, r1	; 0x13
    ac98:	90 96       	adiw	r26, 0x20	; 32
    ac9a:	8c 91       	ld	r24, X
    ac9c:	90 97       	sbiw	r26, 0x20	; 32
    ac9e:	84 8b       	std	Z+20, r24	; 0x14
    aca0:	15 8a       	std	Z+21, r1	; 0x15
    aca2:	91 96       	adiw	r26, 0x21	; 33
    aca4:	8c 91       	ld	r24, X
    aca6:	91 97       	sbiw	r26, 0x21	; 33
    aca8:	86 8b       	std	Z+22, r24	; 0x16
    acaa:	17 8a       	std	Z+23, r1	; 0x17
    acac:	92 96       	adiw	r26, 0x22	; 34
    acae:	8c 91       	ld	r24, X
    acb0:	92 97       	sbiw	r26, 0x22	; 34
    acb2:	80 8f       	std	Z+24, r24	; 0x18
    acb4:	11 8e       	std	Z+25, r1	; 0x19
    acb6:	93 96       	adiw	r26, 0x23	; 35
    acb8:	8c 91       	ld	r24, X
    acba:	93 97       	sbiw	r26, 0x23	; 35
    acbc:	82 8f       	std	Z+26, r24	; 0x1a
    acbe:	13 8e       	std	Z+27, r1	; 0x1b
    acc0:	94 96       	adiw	r26, 0x24	; 36
    acc2:	8c 91       	ld	r24, X
    acc4:	94 97       	sbiw	r26, 0x24	; 36
    acc6:	84 8f       	std	Z+28, r24	; 0x1c
    acc8:	15 8e       	std	Z+29, r1	; 0x1d
    acca:	95 96       	adiw	r26, 0x25	; 37
    accc:	8c 91       	ld	r24, X
    acce:	95 97       	sbiw	r26, 0x25	; 37
    acd0:	86 8f       	std	Z+30, r24	; 0x1e
    acd2:	17 8e       	std	Z+31, r1	; 0x1f
    acd4:	96 96       	adiw	r26, 0x26	; 38
    acd6:	8c 91       	ld	r24, X
    acd8:	96 97       	sbiw	r26, 0x26	; 38
    acda:	80 a3       	std	Z+32, r24	; 0x20
    acdc:	11 a2       	std	Z+33, r1	; 0x21
    acde:	97 96       	adiw	r26, 0x27	; 39
    ace0:	8c 91       	ld	r24, X
    ace2:	82 a3       	std	Z+34, r24	; 0x22
    ace4:	13 a2       	std	Z+35, r1	; 0x23
    ace6:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINTF2(debugStream,"from\n\r");
    acea:	ed b7       	in	r30, 0x3d	; 61
    acec:	fe b7       	in	r31, 0x3e	; 62
    acee:	b4 96       	adiw	r30, 0x24	; 36
    acf0:	0f b6       	in	r0, 0x3f	; 63
    acf2:	f8 94       	cli
    acf4:	fe bf       	out	0x3e, r31	; 62
    acf6:	0f be       	out	0x3f, r0	; 63
    acf8:	ed bf       	out	0x3d, r30	; 61
    acfa:	00 d0       	rcall	.+0      	; 0xacfc <uip_nd6_io_ns_input+0x115c>
    acfc:	00 d0       	rcall	.+0      	; 0xacfe <uip_nd6_io_ns_input+0x115e>
    acfe:	80 91 64 0f 	lds	r24, 0x0F64
    ad02:	90 91 65 0f 	lds	r25, 0x0F65
    ad06:	ad b7       	in	r26, 0x3d	; 61
    ad08:	be b7       	in	r27, 0x3e	; 62
    ad0a:	12 96       	adiw	r26, 0x02	; 2
    ad0c:	9c 93       	st	X, r25
    ad0e:	8e 93       	st	-X, r24
    ad10:	11 97       	sbiw	r26, 0x01	; 1
    ad12:	8e e6       	ldi	r24, 0x6E	; 110
    ad14:	97 e1       	ldi	r25, 0x17	; 23
    ad16:	14 96       	adiw	r26, 0x04	; 4
    ad18:	9c 93       	st	X, r25
    ad1a:	8e 93       	st	-X, r24
    ad1c:	13 97       	sbiw	r26, 0x03	; 3
    ad1e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINT6ADDR(debugStream,&UIP_IP_BUF->srcipaddr);
    ad22:	a0 91 9d 0e 	lds	r26, 0x0E9D
    ad26:	b0 91 9e 0e 	lds	r27, 0x0E9E
    ad2a:	1e 96       	adiw	r26, 0x0e	; 14
    ad2c:	cd b7       	in	r28, 0x3d	; 61
    ad2e:	de b7       	in	r29, 0x3e	; 62
    ad30:	a0 97       	sbiw	r28, 0x20	; 32
    ad32:	0f b6       	in	r0, 0x3f	; 63
    ad34:	f8 94       	cli
    ad36:	de bf       	out	0x3e, r29	; 62
    ad38:	0f be       	out	0x3f, r0	; 63
    ad3a:	cd bf       	out	0x3d, r28	; 61
    ad3c:	ed b7       	in	r30, 0x3d	; 61
    ad3e:	fe b7       	in	r31, 0x3e	; 62
    ad40:	31 96       	adiw	r30, 0x01	; 1
    ad42:	80 91 64 0f 	lds	r24, 0x0F64
    ad46:	90 91 65 0f 	lds	r25, 0x0F65
    ad4a:	9a 83       	std	Y+2, r25	; 0x02
    ad4c:	89 83       	std	Y+1, r24	; 0x01
    ad4e:	87 e1       	ldi	r24, 0x17	; 23
    ad50:	97 e1       	ldi	r25, 0x17	; 23
    ad52:	93 83       	std	Z+3, r25	; 0x03
    ad54:	82 83       	std	Z+2, r24	; 0x02
    ad56:	18 96       	adiw	r26, 0x08	; 8
    ad58:	8c 91       	ld	r24, X
    ad5a:	18 97       	sbiw	r26, 0x08	; 8
    ad5c:	84 83       	std	Z+4, r24	; 0x04
    ad5e:	15 82       	std	Z+5, r1	; 0x05
    ad60:	19 96       	adiw	r26, 0x09	; 9
    ad62:	8c 91       	ld	r24, X
    ad64:	19 97       	sbiw	r26, 0x09	; 9
    ad66:	86 83       	std	Z+6, r24	; 0x06
    ad68:	17 82       	std	Z+7, r1	; 0x07
    ad6a:	1a 96       	adiw	r26, 0x0a	; 10
    ad6c:	8c 91       	ld	r24, X
    ad6e:	1a 97       	sbiw	r26, 0x0a	; 10
    ad70:	80 87       	std	Z+8, r24	; 0x08
    ad72:	11 86       	std	Z+9, r1	; 0x09
    ad74:	1b 96       	adiw	r26, 0x0b	; 11
    ad76:	8c 91       	ld	r24, X
    ad78:	1b 97       	sbiw	r26, 0x0b	; 11
    ad7a:	82 87       	std	Z+10, r24	; 0x0a
    ad7c:	13 86       	std	Z+11, r1	; 0x0b
    ad7e:	1c 96       	adiw	r26, 0x0c	; 12
    ad80:	8c 91       	ld	r24, X
    ad82:	1c 97       	sbiw	r26, 0x0c	; 12
    ad84:	84 87       	std	Z+12, r24	; 0x0c
    ad86:	15 86       	std	Z+13, r1	; 0x0d
    ad88:	1d 96       	adiw	r26, 0x0d	; 13
    ad8a:	8c 91       	ld	r24, X
    ad8c:	1d 97       	sbiw	r26, 0x0d	; 13
    ad8e:	86 87       	std	Z+14, r24	; 0x0e
    ad90:	17 86       	std	Z+15, r1	; 0x0f
    ad92:	1e 96       	adiw	r26, 0x0e	; 14
    ad94:	8c 91       	ld	r24, X
    ad96:	1e 97       	sbiw	r26, 0x0e	; 14
    ad98:	80 8b       	std	Z+16, r24	; 0x10
    ad9a:	11 8a       	std	Z+17, r1	; 0x11
    ad9c:	1f 96       	adiw	r26, 0x0f	; 15
    ad9e:	8c 91       	ld	r24, X
    ada0:	1f 97       	sbiw	r26, 0x0f	; 15
    ada2:	82 8b       	std	Z+18, r24	; 0x12
    ada4:	13 8a       	std	Z+19, r1	; 0x13
    ada6:	50 96       	adiw	r26, 0x10	; 16
    ada8:	8c 91       	ld	r24, X
    adaa:	50 97       	sbiw	r26, 0x10	; 16
    adac:	84 8b       	std	Z+20, r24	; 0x14
    adae:	15 8a       	std	Z+21, r1	; 0x15
    adb0:	51 96       	adiw	r26, 0x11	; 17
    adb2:	8c 91       	ld	r24, X
    adb4:	51 97       	sbiw	r26, 0x11	; 17
    adb6:	86 8b       	std	Z+22, r24	; 0x16
    adb8:	17 8a       	std	Z+23, r1	; 0x17
    adba:	52 96       	adiw	r26, 0x12	; 18
    adbc:	8c 91       	ld	r24, X
    adbe:	52 97       	sbiw	r26, 0x12	; 18
    adc0:	80 8f       	std	Z+24, r24	; 0x18
    adc2:	11 8e       	std	Z+25, r1	; 0x19
    adc4:	53 96       	adiw	r26, 0x13	; 19
    adc6:	8c 91       	ld	r24, X
    adc8:	53 97       	sbiw	r26, 0x13	; 19
    adca:	82 8f       	std	Z+26, r24	; 0x1a
    adcc:	13 8e       	std	Z+27, r1	; 0x1b
    adce:	54 96       	adiw	r26, 0x14	; 20
    add0:	8c 91       	ld	r24, X
    add2:	54 97       	sbiw	r26, 0x14	; 20
    add4:	84 8f       	std	Z+28, r24	; 0x1c
    add6:	15 8e       	std	Z+29, r1	; 0x1d
    add8:	55 96       	adiw	r26, 0x15	; 21
    adda:	8c 91       	ld	r24, X
    addc:	55 97       	sbiw	r26, 0x15	; 21
    adde:	86 8f       	std	Z+30, r24	; 0x1e
    ade0:	17 8e       	std	Z+31, r1	; 0x1f
    ade2:	56 96       	adiw	r26, 0x16	; 22
    ade4:	8c 91       	ld	r24, X
    ade6:	56 97       	sbiw	r26, 0x16	; 22
    ade8:	80 a3       	std	Z+32, r24	; 0x20
    adea:	11 a2       	std	Z+33, r1	; 0x21
    adec:	57 96       	adiw	r26, 0x17	; 23
    adee:	8c 91       	ld	r24, X
    adf0:	82 a3       	std	Z+34, r24	; 0x22
    adf2:	13 a2       	std	Z+35, r1	; 0x23
    adf4:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    PRINT6ADDR(debugStream, &nicState.layer3.ipv6->srcipaddr);
    adf8:	a0 91 9f 0e 	lds	r26, 0x0E9F
    adfc:	b0 91 a0 0e 	lds	r27, 0x0EA0
    ae00:	ed b7       	in	r30, 0x3d	; 61
    ae02:	fe b7       	in	r31, 0x3e	; 62
    ae04:	b4 96       	adiw	r30, 0x24	; 36
    ae06:	0f b6       	in	r0, 0x3f	; 63
    ae08:	f8 94       	cli
    ae0a:	fe bf       	out	0x3e, r31	; 62
    ae0c:	0f be       	out	0x3f, r0	; 63
    ae0e:	ed bf       	out	0x3d, r30	; 61
    ae10:	8d b7       	in	r24, 0x3d	; 61
    ae12:	9e b7       	in	r25, 0x3e	; 62
    ae14:	84 97       	sbiw	r24, 0x24	; 36
    ae16:	0f b6       	in	r0, 0x3f	; 63
    ae18:	f8 94       	cli
    ae1a:	9e bf       	out	0x3e, r25	; 62
    ae1c:	0f be       	out	0x3f, r0	; 63
    ae1e:	8d bf       	out	0x3d, r24	; 61
    ae20:	ed b7       	in	r30, 0x3d	; 61
    ae22:	fe b7       	in	r31, 0x3e	; 62
    ae24:	31 96       	adiw	r30, 0x01	; 1
    ae26:	80 91 64 0f 	lds	r24, 0x0F64
    ae2a:	90 91 65 0f 	lds	r25, 0x0F65
    ae2e:	cd b7       	in	r28, 0x3d	; 61
    ae30:	de b7       	in	r29, 0x3e	; 62
    ae32:	9a 83       	std	Y+2, r25	; 0x02
    ae34:	89 83       	std	Y+1, r24	; 0x01
    ae36:	80 ec       	ldi	r24, 0xC0	; 192
    ae38:	96 e1       	ldi	r25, 0x16	; 22
    ae3a:	93 83       	std	Z+3, r25	; 0x03
    ae3c:	82 83       	std	Z+2, r24	; 0x02
    ae3e:	18 96       	adiw	r26, 0x08	; 8
    ae40:	8c 91       	ld	r24, X
    ae42:	18 97       	sbiw	r26, 0x08	; 8
    ae44:	84 83       	std	Z+4, r24	; 0x04
    ae46:	15 82       	std	Z+5, r1	; 0x05
    ae48:	19 96       	adiw	r26, 0x09	; 9
    ae4a:	8c 91       	ld	r24, X
    ae4c:	19 97       	sbiw	r26, 0x09	; 9
    ae4e:	86 83       	std	Z+6, r24	; 0x06
    ae50:	17 82       	std	Z+7, r1	; 0x07
    ae52:	1a 96       	adiw	r26, 0x0a	; 10
    ae54:	8c 91       	ld	r24, X
    ae56:	1a 97       	sbiw	r26, 0x0a	; 10
    ae58:	80 87       	std	Z+8, r24	; 0x08
    ae5a:	11 86       	std	Z+9, r1	; 0x09
    ae5c:	1b 96       	adiw	r26, 0x0b	; 11
    ae5e:	8c 91       	ld	r24, X
    ae60:	1b 97       	sbiw	r26, 0x0b	; 11
    ae62:	82 87       	std	Z+10, r24	; 0x0a
    ae64:	13 86       	std	Z+11, r1	; 0x0b
    ae66:	1c 96       	adiw	r26, 0x0c	; 12
    ae68:	8c 91       	ld	r24, X
    ae6a:	1c 97       	sbiw	r26, 0x0c	; 12
    ae6c:	84 87       	std	Z+12, r24	; 0x0c
    ae6e:	15 86       	std	Z+13, r1	; 0x0d
    ae70:	1d 96       	adiw	r26, 0x0d	; 13
    ae72:	8c 91       	ld	r24, X
    ae74:	1d 97       	sbiw	r26, 0x0d	; 13
    ae76:	86 87       	std	Z+14, r24	; 0x0e
    ae78:	17 86       	std	Z+15, r1	; 0x0f
    ae7a:	1e 96       	adiw	r26, 0x0e	; 14
    ae7c:	8c 91       	ld	r24, X
    ae7e:	1e 97       	sbiw	r26, 0x0e	; 14
    ae80:	80 8b       	std	Z+16, r24	; 0x10
    ae82:	11 8a       	std	Z+17, r1	; 0x11
    ae84:	1f 96       	adiw	r26, 0x0f	; 15
    ae86:	8c 91       	ld	r24, X
    ae88:	1f 97       	sbiw	r26, 0x0f	; 15
    ae8a:	82 8b       	std	Z+18, r24	; 0x12
    ae8c:	13 8a       	std	Z+19, r1	; 0x13
    ae8e:	50 96       	adiw	r26, 0x10	; 16
    ae90:	8c 91       	ld	r24, X
    ae92:	50 97       	sbiw	r26, 0x10	; 16
    ae94:	84 8b       	std	Z+20, r24	; 0x14
    ae96:	15 8a       	std	Z+21, r1	; 0x15
    ae98:	51 96       	adiw	r26, 0x11	; 17
    ae9a:	8c 91       	ld	r24, X
    ae9c:	51 97       	sbiw	r26, 0x11	; 17
    ae9e:	86 8b       	std	Z+22, r24	; 0x16
    aea0:	17 8a       	std	Z+23, r1	; 0x17
    aea2:	52 96       	adiw	r26, 0x12	; 18
    aea4:	8c 91       	ld	r24, X
    aea6:	52 97       	sbiw	r26, 0x12	; 18
    aea8:	80 8f       	std	Z+24, r24	; 0x18
    aeaa:	11 8e       	std	Z+25, r1	; 0x19
    aeac:	53 96       	adiw	r26, 0x13	; 19
    aeae:	8c 91       	ld	r24, X
    aeb0:	53 97       	sbiw	r26, 0x13	; 19
    aeb2:	82 8f       	std	Z+26, r24	; 0x1a
    aeb4:	13 8e       	std	Z+27, r1	; 0x1b
    aeb6:	54 96       	adiw	r26, 0x14	; 20
    aeb8:	8c 91       	ld	r24, X
    aeba:	54 97       	sbiw	r26, 0x14	; 20
    aebc:	84 8f       	std	Z+28, r24	; 0x1c
    aebe:	15 8e       	std	Z+29, r1	; 0x1d
    aec0:	55 96       	adiw	r26, 0x15	; 21
    aec2:	8c 91       	ld	r24, X
    aec4:	55 97       	sbiw	r26, 0x15	; 21
    aec6:	86 8f       	std	Z+30, r24	; 0x1e
    aec8:	17 8e       	std	Z+31, r1	; 0x1f
    aeca:	56 96       	adiw	r26, 0x16	; 22
    aecc:	8c 91       	ld	r24, X
    aece:	56 97       	sbiw	r26, 0x16	; 22
    aed0:	80 a3       	std	Z+32, r24	; 0x20
    aed2:	11 a2       	std	Z+33, r1	; 0x21
    aed4:	57 96       	adiw	r26, 0x17	; 23
    aed6:	8c 91       	ld	r24, X
    aed8:	82 a3       	std	Z+34, r24	; 0x22
    aeda:	13 a2       	std	Z+35, r1	; 0x23
    aedc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINTF2(debugStream,"with target address\n\r");
    aee0:	ed b7       	in	r30, 0x3d	; 61
    aee2:	fe b7       	in	r31, 0x3e	; 62
    aee4:	b4 96       	adiw	r30, 0x24	; 36
    aee6:	0f b6       	in	r0, 0x3f	; 63
    aee8:	f8 94       	cli
    aeea:	fe bf       	out	0x3e, r31	; 62
    aeec:	0f be       	out	0x3f, r0	; 63
    aeee:	ed bf       	out	0x3d, r30	; 61
    aef0:	00 d0       	rcall	.+0      	; 0xaef2 <uip_nd6_io_ns_input+0x1352>
    aef2:	00 d0       	rcall	.+0      	; 0xaef4 <uip_nd6_io_ns_input+0x1354>
    aef4:	80 91 64 0f 	lds	r24, 0x0F64
    aef8:	90 91 65 0f 	lds	r25, 0x0F65
    aefc:	ad b7       	in	r26, 0x3d	; 61
    aefe:	be b7       	in	r27, 0x3e	; 62
    af00:	12 96       	adiw	r26, 0x02	; 2
    af02:	9c 93       	st	X, r25
    af04:	8e 93       	st	-X, r24
    af06:	11 97       	sbiw	r26, 0x01	; 1
    af08:	8a ea       	ldi	r24, 0xAA	; 170
    af0a:	96 e1       	ldi	r25, 0x16	; 22
    af0c:	14 96       	adiw	r26, 0x04	; 4
    af0e:	9c 93       	st	X, r25
    af10:	8e 93       	st	-X, r24
    af12:	13 97       	sbiw	r26, 0x03	; 3
    af14:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
  PRINT6ADDR(debugStream,&UIP_ND6_NA_BUF->tgtipaddr);
    af18:	80 91 69 0f 	lds	r24, 0x0F69
    af1c:	90 e0       	ldi	r25, 0x00	; 0
    af1e:	ca 96       	adiw	r24, 0x3a	; 58
    af20:	a0 91 9d 0e 	lds	r26, 0x0E9D
    af24:	b0 91 9e 0e 	lds	r27, 0x0E9E
    af28:	a8 0f       	add	r26, r24
    af2a:	b9 1f       	adc	r27, r25
    af2c:	cd b7       	in	r28, 0x3d	; 61
    af2e:	de b7       	in	r29, 0x3e	; 62
    af30:	a0 97       	sbiw	r28, 0x20	; 32
    af32:	0f b6       	in	r0, 0x3f	; 63
    af34:	f8 94       	cli
    af36:	de bf       	out	0x3e, r29	; 62
    af38:	0f be       	out	0x3f, r0	; 63
    af3a:	cd bf       	out	0x3d, r28	; 61
    af3c:	ed b7       	in	r30, 0x3d	; 61
    af3e:	fe b7       	in	r31, 0x3e	; 62
    af40:	31 96       	adiw	r30, 0x01	; 1
    af42:	80 91 64 0f 	lds	r24, 0x0F64
    af46:	90 91 65 0f 	lds	r25, 0x0F65
    af4a:	9a 83       	std	Y+2, r25	; 0x02
    af4c:	89 83       	std	Y+1, r24	; 0x01
    af4e:	83 e5       	ldi	r24, 0x53	; 83
    af50:	96 e1       	ldi	r25, 0x16	; 22
    af52:	93 83       	std	Z+3, r25	; 0x03
    af54:	82 83       	std	Z+2, r24	; 0x02
    af56:	14 96       	adiw	r26, 0x04	; 4
    af58:	8c 91       	ld	r24, X
    af5a:	14 97       	sbiw	r26, 0x04	; 4
    af5c:	84 83       	std	Z+4, r24	; 0x04
    af5e:	15 82       	std	Z+5, r1	; 0x05
    af60:	15 96       	adiw	r26, 0x05	; 5
    af62:	8c 91       	ld	r24, X
    af64:	15 97       	sbiw	r26, 0x05	; 5
    af66:	86 83       	std	Z+6, r24	; 0x06
    af68:	17 82       	std	Z+7, r1	; 0x07
    af6a:	16 96       	adiw	r26, 0x06	; 6
    af6c:	8c 91       	ld	r24, X
    af6e:	16 97       	sbiw	r26, 0x06	; 6
    af70:	80 87       	std	Z+8, r24	; 0x08
    af72:	11 86       	std	Z+9, r1	; 0x09
    af74:	17 96       	adiw	r26, 0x07	; 7
    af76:	8c 91       	ld	r24, X
    af78:	17 97       	sbiw	r26, 0x07	; 7
    af7a:	82 87       	std	Z+10, r24	; 0x0a
    af7c:	13 86       	std	Z+11, r1	; 0x0b
    af7e:	18 96       	adiw	r26, 0x08	; 8
    af80:	8c 91       	ld	r24, X
    af82:	18 97       	sbiw	r26, 0x08	; 8
    af84:	84 87       	std	Z+12, r24	; 0x0c
    af86:	15 86       	std	Z+13, r1	; 0x0d
    af88:	19 96       	adiw	r26, 0x09	; 9
    af8a:	8c 91       	ld	r24, X
    af8c:	19 97       	sbiw	r26, 0x09	; 9
    af8e:	86 87       	std	Z+14, r24	; 0x0e
    af90:	17 86       	std	Z+15, r1	; 0x0f
    af92:	1a 96       	adiw	r26, 0x0a	; 10
    af94:	8c 91       	ld	r24, X
    af96:	1a 97       	sbiw	r26, 0x0a	; 10
    af98:	80 8b       	std	Z+16, r24	; 0x10
    af9a:	11 8a       	std	Z+17, r1	; 0x11
    af9c:	1b 96       	adiw	r26, 0x0b	; 11
    af9e:	8c 91       	ld	r24, X
    afa0:	1b 97       	sbiw	r26, 0x0b	; 11
    afa2:	82 8b       	std	Z+18, r24	; 0x12
    afa4:	13 8a       	std	Z+19, r1	; 0x13
    afa6:	1c 96       	adiw	r26, 0x0c	; 12
    afa8:	8c 91       	ld	r24, X
    afaa:	1c 97       	sbiw	r26, 0x0c	; 12
    afac:	84 8b       	std	Z+20, r24	; 0x14
    afae:	15 8a       	std	Z+21, r1	; 0x15
    afb0:	1d 96       	adiw	r26, 0x0d	; 13
    afb2:	8c 91       	ld	r24, X
    afb4:	1d 97       	sbiw	r26, 0x0d	; 13
    afb6:	86 8b       	std	Z+22, r24	; 0x16
    afb8:	17 8a       	std	Z+23, r1	; 0x17
    afba:	1e 96       	adiw	r26, 0x0e	; 14
    afbc:	8c 91       	ld	r24, X
    afbe:	1e 97       	sbiw	r26, 0x0e	; 14
    afc0:	80 8f       	std	Z+24, r24	; 0x18
    afc2:	11 8e       	std	Z+25, r1	; 0x19
    afc4:	1f 96       	adiw	r26, 0x0f	; 15
    afc6:	8c 91       	ld	r24, X
    afc8:	1f 97       	sbiw	r26, 0x0f	; 15
    afca:	82 8f       	std	Z+26, r24	; 0x1a
    afcc:	13 8e       	std	Z+27, r1	; 0x1b
    afce:	50 96       	adiw	r26, 0x10	; 16
    afd0:	8c 91       	ld	r24, X
    afd2:	50 97       	sbiw	r26, 0x10	; 16
    afd4:	84 8f       	std	Z+28, r24	; 0x1c
    afd6:	15 8e       	std	Z+29, r1	; 0x1d
    afd8:	51 96       	adiw	r26, 0x11	; 17
    afda:	8c 91       	ld	r24, X
    afdc:	51 97       	sbiw	r26, 0x11	; 17
    afde:	86 8f       	std	Z+30, r24	; 0x1e
    afe0:	17 8e       	std	Z+31, r1	; 0x1f
    afe2:	52 96       	adiw	r26, 0x12	; 18
    afe4:	8c 91       	ld	r24, X
    afe6:	52 97       	sbiw	r26, 0x12	; 18
    afe8:	80 a3       	std	Z+32, r24	; 0x20
    afea:	11 a2       	std	Z+33, r1	; 0x21
    afec:	53 96       	adiw	r26, 0x13	; 19
    afee:	8c 91       	ld	r24, X
    aff0:	82 a3       	std	Z+34, r24	; 0x22
    aff2:	13 a2       	std	Z+35, r1	; 0x23
    aff4:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    aff8:	ed b7       	in	r30, 0x3d	; 61
    affa:	fe b7       	in	r31, 0x3e	; 62
    affc:	b4 96       	adiw	r30, 0x24	; 36
    affe:	0f b6       	in	r0, 0x3f	; 63
    b000:	f8 94       	cli
    b002:	fe bf       	out	0x3e, r31	; 62
    b004:	0f be       	out	0x3f, r0	; 63
    b006:	ed bf       	out	0x3d, r30	; 61
  
 discard:
  packetLenght = 0;
  return;
  
}
    b008:	df 91       	pop	r29
    b00a:	cf 91       	pop	r28
    b00c:	1f 91       	pop	r17
    b00e:	0f 91       	pop	r16
    b010:	ff 90       	pop	r15
    b012:	ef 90       	pop	r14
    b014:	df 90       	pop	r13
    b016:	cf 90       	pop	r12
    b018:	bf 90       	pop	r11
    b01a:	af 90       	pop	r10
    b01c:	08 95       	ret

0000b01e <sendTcBuffer6>:

uint8_t sendTcBuffer6(uint8_t socketNo)
{
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    b01e:	80 e0       	ldi	r24, 0x00	; 0
    b020:	08 95       	ret

0000b022 <setTcpDebug6>:
}

#if TCP_DEBUG
void setTcpDebug6(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    b022:	90 93 68 0f 	sts	0x0F68, r25
    b026:	80 93 67 0f 	sts	0x0F67, r24
  tcpDebugLevel = level;
    b02a:	60 93 bc 0e 	sts	0x0EBC, r22
}
    b02e:	08 95       	ret

0000b030 <flushTcpQueues6>:
  for (sckNo = 0; sckNo < NUMBER_OF_SOCKETS; sckNo++)
  {
    
    sck++;
  }
}
    b030:	08 95       	ret

0000b032 <httpProcess6>:
          continue;  
        }
      }

#endif
    b032:	08 95       	ret

0000b034 <findConnectedSocket6>:
    sck++;
  }
}

struct TcpIpSocket* findConnectedSocket6(void)
{
    b034:	af 92       	push	r10
    b036:	bf 92       	push	r11
    b038:	cf 92       	push	r12
    b03a:	df 92       	push	r13
    b03c:	ef 92       	push	r14
    b03e:	ff 92       	push	r15
    b040:	0f 93       	push	r16
    b042:	1f 93       	push	r17
    b044:	cf 93       	push	r28
    b046:	df 93       	push	r29
  struct TcpIpSocket *result = sockets;
    b048:	e0 91 d5 0e 	lds	r30, 0x0ED5
    b04c:	f0 91 d6 0e 	lds	r31, 0x0ED6
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED)) 
    b050:	e0 90 9f 0e 	lds	r14, 0x0E9F
    b054:	f0 90 a0 0e 	lds	r15, 0x0EA0
    b058:	60 91 a1 0e 	lds	r22, 0x0EA1
    b05c:	70 91 a2 0e 	lds	r23, 0x0EA2
    b060:	ef 01       	movw	r28, r30
    b062:	10 e0       	ldi	r17, 0x00	; 0
    b064:	08 81       	ld	r16, Y
    b066:	02 30       	cpi	r16, 0x02	; 2
    b068:	08 f4       	brcc	.+2      	; 0xb06c <findConnectedSocket6+0x38>
    b06a:	43 c0       	rjmp	.+134    	; 0xb0f2 <findConnectedSocket6+0xbe>
    b06c:	29 81       	ldd	r18, Y+1	; 0x01
    b06e:	3a 81       	ldd	r19, Y+2	; 0x02
    b070:	4b 81       	ldd	r20, Y+3	; 0x03
    b072:	5c 81       	ldd	r21, Y+4	; 0x04
    b074:	d7 01       	movw	r26, r14
    b076:	1c 96       	adiw	r26, 0x0c	; 12
    b078:	ad 90       	ld	r10, X+
    b07a:	bd 90       	ld	r11, X+
    b07c:	cd 90       	ld	r12, X+
    b07e:	dc 90       	ld	r13, X
    b080:	1f 97       	sbiw	r26, 0x0f	; 15
    b082:	2a 15       	cp	r18, r10
    b084:	3b 05       	cpc	r19, r11
    b086:	4c 05       	cpc	r20, r12
    b088:	5d 05       	cpc	r21, r13
    b08a:	99 f5       	brne	.+102    	; 0xb0f2 <findConnectedSocket6+0xbe>
    b08c:	2d 81       	ldd	r18, Y+5	; 0x05
    b08e:	3e 81       	ldd	r19, Y+6	; 0x06
    b090:	db 01       	movw	r26, r22
    b092:	12 96       	adiw	r26, 0x02	; 2
    b094:	8d 91       	ld	r24, X+
    b096:	9c 91       	ld	r25, X
    b098:	13 97       	sbiw	r26, 0x03	; 3
    b09a:	28 17       	cp	r18, r24
    b09c:	39 07       	cpc	r19, r25
    b09e:	49 f5       	brne	.+82     	; 0xb0f2 <findConnectedSocket6+0xbe>
    b0a0:	2f 81       	ldd	r18, Y+7	; 0x07
    b0a2:	38 85       	ldd	r19, Y+8	; 0x08
    b0a4:	8d 91       	ld	r24, X+
    b0a6:	9c 91       	ld	r25, X
    b0a8:	28 17       	cp	r18, r24
    b0aa:	39 07       	cpc	r19, r25
    b0ac:	11 f5       	brne	.+68     	; 0xb0f2 <findConnectedSocket6+0xbe>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    b0ae:	20 91 67 0f 	lds	r18, 0x0F67
    b0b2:	30 91 68 0f 	lds	r19, 0x0F68
    b0b6:	21 15       	cp	r18, r1
    b0b8:	31 05       	cpc	r19, r1
    b0ba:	09 f4       	brne	.+2      	; 0xb0be <findConnectedSocket6+0x8a>
    b0bc:	96 c0       	rjmp	.+300    	; 0xb1ea <findConnectedSocket6+0x1b6>
        if (tcpDebugLevel > 2)
    b0be:	80 91 bc 0e 	lds	r24, 0x0EBC
    b0c2:	83 30       	cpi	r24, 0x03	; 3
    b0c4:	08 f4       	brcc	.+2      	; 0xb0c8 <findConnectedSocket6+0x94>
    b0c6:	91 c0       	rjmp	.+290    	; 0xb1ea <findConnectedSocket6+0x1b6>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    b0c8:	00 d0       	rcall	.+0      	; 0xb0ca <findConnectedSocket6+0x96>
    b0ca:	00 d0       	rcall	.+0      	; 0xb0cc <findConnectedSocket6+0x98>
    b0cc:	00 d0       	rcall	.+0      	; 0xb0ce <findConnectedSocket6+0x9a>
    b0ce:	ed b7       	in	r30, 0x3d	; 61
    b0d0:	fe b7       	in	r31, 0x3e	; 62
    b0d2:	31 96       	adiw	r30, 0x01	; 1
    b0d4:	ad b7       	in	r26, 0x3d	; 61
    b0d6:	be b7       	in	r27, 0x3e	; 62
    b0d8:	12 96       	adiw	r26, 0x02	; 2
    b0da:	3c 93       	st	X, r19
    b0dc:	2e 93       	st	-X, r18
    b0de:	11 97       	sbiw	r26, 0x01	; 1
    b0e0:	87 e6       	ldi	r24, 0x67	; 103
    b0e2:	9e e1       	ldi	r25, 0x1E	; 30
    b0e4:	93 83       	std	Z+3, r25	; 0x03
    b0e6:	82 83       	std	Z+2, r24	; 0x02
    b0e8:	04 83       	std	Z+4, r16	; 0x04
    b0ea:	15 82       	std	Z+5, r1	; 0x05
    b0ec:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    b0f0:	71 c0       	rjmp	.+226    	; 0xb1d4 <findConnectedSocket6+0x1a0>

struct TcpIpSocket* findConnectedSocket6(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    b0f2:	1f 5f       	subi	r17, 0xFF	; 255
    b0f4:	14 31       	cpi	r17, 0x14	; 20
    b0f6:	11 f0       	breq	.+4      	; 0xb0fc <findConnectedSocket6+0xc8>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
#endif      
      return result;
    }
    result++;
    b0f8:	6c 96       	adiw	r28, 0x1c	; 28
    b0fa:	b4 cf       	rjmp	.-152    	; 0xb064 <findConnectedSocket6+0x30>
    b0fc:	10 e0       	ldi	r17, 0x00	; 0
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    b0fe:	80 81       	ld	r24, Z
    b100:	81 30       	cpi	r24, 0x01	; 1
    b102:	e1 f5       	brne	.+120    	; 0xb17c <findConnectedSocket6+0x148>
    b104:	25 81       	ldd	r18, Z+5	; 0x05
    b106:	36 81       	ldd	r19, Z+6	; 0x06
    b108:	db 01       	movw	r26, r22
    b10a:	12 96       	adiw	r26, 0x02	; 2
    b10c:	8d 91       	ld	r24, X+
    b10e:	9c 91       	ld	r25, X
    b110:	13 97       	sbiw	r26, 0x03	; 3
    b112:	28 17       	cp	r18, r24
    b114:	39 07       	cpc	r19, r25
    b116:	91 f5       	brne	.+100    	; 0xb17c <findConnectedSocket6+0x148>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    b118:	20 91 67 0f 	lds	r18, 0x0F67
    b11c:	30 91 68 0f 	lds	r19, 0x0F68
    b120:	21 15       	cp	r18, r1
    b122:	31 05       	cpc	r19, r1
    b124:	01 f1       	breq	.+64     	; 0xb166 <findConnectedSocket6+0x132>
        if (tcpDebugLevel > 2)
    b126:	80 91 bc 0e 	lds	r24, 0x0EBC
    b12a:	83 30       	cpi	r24, 0x03	; 3
    b12c:	e0 f0       	brcs	.+56     	; 0xb166 <findConnectedSocket6+0x132>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    b12e:	00 d0       	rcall	.+0      	; 0xb130 <findConnectedSocket6+0xfc>
    b130:	00 d0       	rcall	.+0      	; 0xb132 <findConnectedSocket6+0xfe>
    b132:	00 d0       	rcall	.+0      	; 0xb134 <findConnectedSocket6+0x100>
    b134:	ed b7       	in	r30, 0x3d	; 61
    b136:	fe b7       	in	r31, 0x3e	; 62
    b138:	31 96       	adiw	r30, 0x01	; 1
    b13a:	ad b7       	in	r26, 0x3d	; 61
    b13c:	be b7       	in	r27, 0x3e	; 62
    b13e:	12 96       	adiw	r26, 0x02	; 2
    b140:	3c 93       	st	X, r19
    b142:	2e 93       	st	-X, r18
    b144:	11 97       	sbiw	r26, 0x01	; 1
    b146:	81 e4       	ldi	r24, 0x41	; 65
    b148:	9e e1       	ldi	r25, 0x1E	; 30
    b14a:	93 83       	std	Z+3, r25	; 0x03
    b14c:	82 83       	std	Z+2, r24	; 0x02
    b14e:	14 83       	std	Z+4, r17	; 0x04
    b150:	15 82       	std	Z+5, r1	; 0x05
    b152:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    b156:	ed b7       	in	r30, 0x3d	; 61
    b158:	fe b7       	in	r31, 0x3e	; 62
    b15a:	36 96       	adiw	r30, 0x06	; 6
    b15c:	0f b6       	in	r0, 0x3f	; 63
    b15e:	f8 94       	cli
    b160:	fe bf       	out	0x3e, r31	; 62
    b162:	0f be       	out	0x3f, r0	; 63
    b164:	ed bf       	out	0x3d, r30	; 61
#endif      
      return &sockets[i];
    b166:	8c e1       	ldi	r24, 0x1C	; 28
    b168:	18 9f       	mul	r17, r24
    b16a:	c0 01       	movw	r24, r0
    b16c:	11 24       	eor	r1, r1
    b16e:	c0 91 d5 0e 	lds	r28, 0x0ED5
    b172:	d0 91 d6 0e 	lds	r29, 0x0ED6
    b176:	c8 0f       	add	r28, r24
    b178:	d9 1f       	adc	r29, r25
    b17a:	37 c0       	rjmp	.+110    	; 0xb1ea <findConnectedSocket6+0x1b6>
    }
    result++;
  }
  
  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    b17c:	1f 5f       	subi	r17, 0xFF	; 255
    b17e:	14 31       	cpi	r17, 0x14	; 20
    b180:	11 f0       	breq	.+4      	; 0xb186 <findConnectedSocket6+0x152>
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
#endif      
      return &sockets[i];
    }
    result++;
    b182:	7c 96       	adiw	r30, 0x1c	; 28
    b184:	bc cf       	rjmp	.-136    	; 0xb0fe <findConnectedSocket6+0xca>
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    b186:	c0 91 67 0f 	lds	r28, 0x0F67
    b18a:	d0 91 68 0f 	lds	r29, 0x0F68
    b18e:	20 97       	sbiw	r28, 0x00	; 0
    b190:	51 f1       	breq	.+84     	; 0xb1e6 <findConnectedSocket6+0x1b2>
    if (tcpDebugLevel > 2)
    b192:	80 91 bc 0e 	lds	r24, 0x0EBC
    b196:	83 30       	cpi	r24, 0x03	; 3
    b198:	30 f1       	brcs	.+76     	; 0xb1e6 <findConnectedSocket6+0x1b2>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    b19a:	db 01       	movw	r26, r22
    b19c:	12 96       	adiw	r26, 0x02	; 2
    b19e:	8d 91       	ld	r24, X+
    b1a0:	9c 91       	ld	r25, X
    b1a2:	13 97       	sbiw	r26, 0x03	; 3
    b1a4:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    b1a8:	00 d0       	rcall	.+0      	; 0xb1aa <findConnectedSocket6+0x176>
    b1aa:	00 d0       	rcall	.+0      	; 0xb1ac <findConnectedSocket6+0x178>
    b1ac:	00 d0       	rcall	.+0      	; 0xb1ae <findConnectedSocket6+0x17a>
    b1ae:	ed b7       	in	r30, 0x3d	; 61
    b1b0:	fe b7       	in	r31, 0x3e	; 62
    b1b2:	31 96       	adiw	r30, 0x01	; 1
    b1b4:	ad b7       	in	r26, 0x3d	; 61
    b1b6:	be b7       	in	r27, 0x3e	; 62
    b1b8:	12 96       	adiw	r26, 0x02	; 2
    b1ba:	dc 93       	st	X, r29
    b1bc:	ce 93       	st	-X, r28
    b1be:	11 97       	sbiw	r26, 0x01	; 1
    b1c0:	27 e1       	ldi	r18, 0x17	; 23
    b1c2:	3e e1       	ldi	r19, 0x1E	; 30
    b1c4:	33 83       	std	Z+3, r19	; 0x03
    b1c6:	22 83       	std	Z+2, r18	; 0x02
    b1c8:	95 83       	std	Z+5, r25	; 0x05
    b1ca:	84 83       	std	Z+4, r24	; 0x04
    b1cc:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    b1d0:	c0 e0       	ldi	r28, 0x00	; 0
    b1d2:	d0 e0       	ldi	r29, 0x00	; 0
    b1d4:	ed b7       	in	r30, 0x3d	; 61
    b1d6:	fe b7       	in	r31, 0x3e	; 62
    b1d8:	36 96       	adiw	r30, 0x06	; 6
    b1da:	0f b6       	in	r0, 0x3f	; 63
    b1dc:	f8 94       	cli
    b1de:	fe bf       	out	0x3e, r31	; 62
    b1e0:	0f be       	out	0x3f, r0	; 63
    b1e2:	ed bf       	out	0x3d, r30	; 61
    b1e4:	02 c0       	rjmp	.+4      	; 0xb1ea <findConnectedSocket6+0x1b6>
    b1e6:	c0 e0       	ldi	r28, 0x00	; 0
    b1e8:	d0 e0       	ldi	r29, 0x00	; 0
#endif
  return NULL;
}
    b1ea:	ce 01       	movw	r24, r28
    b1ec:	df 91       	pop	r29
    b1ee:	cf 91       	pop	r28
    b1f0:	1f 91       	pop	r17
    b1f2:	0f 91       	pop	r16
    b1f4:	ff 90       	pop	r15
    b1f6:	ef 90       	pop	r14
    b1f8:	df 90       	pop	r13
    b1fa:	cf 90       	pop	r12
    b1fc:	bf 90       	pop	r11
    b1fe:	af 90       	pop	r10
    b200:	08 95       	ret

0000b202 <netstackTCPIPProcess6>:
  struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}

void netstackTCPIPProcess6(void)
{
    b202:	0f 93       	push	r16
    b204:	1f 93       	push	r17
  if (nicState.layer4.tcp->destport == htons(80))
    b206:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b20a:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b20e:	02 81       	ldd	r16, Z+2	; 0x02
    b210:	13 81       	ldd	r17, Z+3	; 0x03
    b212:	80 e5       	ldi	r24, 0x50	; 80
    b214:	90 e0       	ldi	r25, 0x00	; 0
    b216:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    b21a:	08 17       	cp	r16, r24
    b21c:	19 07       	cpc	r17, r25
    b21e:	b9 f4       	brne	.+46     	; 0xb24e <netstackTCPIPProcess6+0x4c>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    b220:	80 91 67 0f 	lds	r24, 0x0F67
    b224:	90 91 68 0f 	lds	r25, 0x0F68
    b228:	00 97       	sbiw	r24, 0x00	; 0
    b22a:	99 f0       	breq	.+38     	; 0xb252 <netstackTCPIPProcess6+0x50>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    b22c:	00 d0       	rcall	.+0      	; 0xb22e <netstackTCPIPProcess6+0x2c>
    b22e:	00 d0       	rcall	.+0      	; 0xb230 <netstackTCPIPProcess6+0x2e>
    b230:	ed b7       	in	r30, 0x3d	; 61
    b232:	fe b7       	in	r31, 0x3e	; 62
    b234:	92 83       	std	Z+2, r25	; 0x02
    b236:	81 83       	std	Z+1, r24	; 0x01
    b238:	8e e0       	ldi	r24, 0x0E	; 14
    b23a:	9d e1       	ldi	r25, 0x1D	; 29
    b23c:	94 83       	std	Z+4, r25	; 0x04
    b23e:	83 83       	std	Z+3, r24	; 0x03
    b240:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    b244:	0f 90       	pop	r0
    b246:	0f 90       	pop	r0
    b248:	0f 90       	pop	r0
    b24a:	0f 90       	pop	r0
    b24c:	02 c0       	rjmp	.+4      	; 0xb252 <netstackTCPIPProcess6+0x50>
#endif
    ;
  }
  else
  {
    processTcpPacket();
    b24e:	0e 94 61 40 	call	0x80c2	; 0x80c2 <processTcpPacket>
  }
}
    b252:	1f 91       	pop	r17
    b254:	0f 91       	pop	r16
    b256:	08 95       	ret

0000b258 <calculateTcpChecksum6>:
  
  return 0;
}

void calculateTcpChecksum6(uint16_t tcpLen)
{
    b258:	0f 93       	push	r16
    b25a:	1f 93       	push	r17
    b25c:	bc 01       	movw	r22, r24
  nicState.layer4.tcp->tcpchksum = 0;
    b25e:	00 91 a1 0e 	lds	r16, 0x0EA1
    b262:	10 91 a2 0e 	lds	r17, 0x0EA2
    b266:	f8 01       	movw	r30, r16
    b268:	11 8a       	std	Z+17, r1	; 0x11
    b26a:	10 8a       	std	Z+16, r1	; 0x10
  nicState.layer4.tcp->tcpchksum = netChecksum(nicState.layer4.tcp, tcpLen); //TODO finish it
    b26c:	c8 01       	movw	r24, r16
    b26e:	0e 94 c8 33 	call	0x6790	; 0x6790 <netChecksum>
    b272:	f8 01       	movw	r30, r16
    b274:	91 8b       	std	Z+17, r25	; 0x11
    b276:	80 8b       	std	Z+16, r24	; 0x10
}
    b278:	1f 91       	pop	r17
    b27a:	0f 91       	pop	r16
    b27c:	08 95       	ret

0000b27e <processTcpPacket6>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket6(void)
{
    b27e:	0f 93       	push	r16
    b280:	1f 93       	push	r17
    b282:	cf 93       	push	r28
    b284:	df 93       	push	r29
  struct TcpIpSocket *socket = findConnectedSocket6();
    b286:	0e 94 1a 58 	call	0xb034	; 0xb034 <findConnectedSocket6>
    b28a:	ec 01       	movw	r28, r24
  
  if (socket == NULL)
    b28c:	00 97       	sbiw	r24, 0x00	; 0
    b28e:	11 f4       	brne	.+4      	; 0xb294 <processTcpPacket6+0x16>
    b290:	81 e0       	ldi	r24, 0x01	; 1
    b292:	2b c1       	rjmp	.+598    	; 0xb4ea <processTcpPacket6+0x26c>
    return 1;
  
  
  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    b294:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b298:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b29c:	64 81       	ldd	r22, Z+4	; 0x04
    b29e:	75 81       	ldd	r23, Z+5	; 0x05
    b2a0:	86 81       	ldd	r24, Z+6	; 0x06
    b2a2:	97 81       	ldd	r25, Z+7	; 0x07
    b2a4:	0e 94 ab 33 	call	0x6756	; 0x6756 <htonl>
    b2a8:	69 87       	std	Y+9, r22	; 0x09
    b2aa:	7a 87       	std	Y+10, r23	; 0x0a
    b2ac:	8b 87       	std	Y+11, r24	; 0x0b
    b2ae:	9c 87       	std	Y+12, r25	; 0x0c
  
  if (socket->state == LISTEN)
    b2b0:	88 81       	ld	r24, Y
    b2b2:	81 30       	cpi	r24, 0x01	; 1
    b2b4:	09 f0       	breq	.+2      	; 0xb2b8 <processTcpPacket6+0x3a>
    b2b6:	b1 c0       	rjmp	.+354    	; 0xb41a <processTcpPacket6+0x19c>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    b2b8:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b2bc:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b2c0:	85 85       	ldd	r24, Z+13	; 0x0d
    b2c2:	20 91 67 0f 	lds	r18, 0x0F67
    b2c6:	30 91 68 0f 	lds	r19, 0x0F68
    b2ca:	81 ff       	sbrs	r24, 1
    b2cc:	94 c0       	rjmp	.+296    	; 0xb3f6 <processTcpPacket6+0x178>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    b2ce:	21 15       	cp	r18, r1
    b2d0:	31 05       	cpc	r19, r1
    b2d2:	a1 f0       	breq	.+40     	; 0xb2fc <processTcpPacket6+0x7e>
        if (tcpDebugLevel > 2)
    b2d4:	80 91 bc 0e 	lds	r24, 0x0EBC
    b2d8:	83 30       	cpi	r24, 0x03	; 3
    b2da:	80 f0       	brcs	.+32     	; 0xb2fc <processTcpPacket6+0x7e>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    b2dc:	00 d0       	rcall	.+0      	; 0xb2de <processTcpPacket6+0x60>
    b2de:	00 d0       	rcall	.+0      	; 0xb2e0 <processTcpPacket6+0x62>
    b2e0:	ed b7       	in	r30, 0x3d	; 61
    b2e2:	fe b7       	in	r31, 0x3e	; 62
    b2e4:	32 83       	std	Z+2, r19	; 0x02
    b2e6:	21 83       	std	Z+1, r18	; 0x01
    b2e8:	85 ed       	ldi	r24, 0xD5	; 213
    b2ea:	9d e1       	ldi	r25, 0x1D	; 29
    b2ec:	94 83       	std	Z+4, r25	; 0x04
    b2ee:	83 83       	std	Z+3, r24	; 0x03
    b2f0:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    b2f4:	0f 90       	pop	r0
    b2f6:	0f 90       	pop	r0
    b2f8:	0f 90       	pop	r0
    b2fa:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn6(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    b2fc:	82 e0       	ldi	r24, 0x02	; 2
    b2fe:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    b300:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b304:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b308:	80 81       	ld	r24, Z
    b30a:	91 81       	ldd	r25, Z+1	; 0x01
    b30c:	98 87       	std	Y+8, r25	; 0x08
    b30e:	8f 83       	std	Y+7, r24	; 0x07
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    b310:	e0 91 9f 0e 	lds	r30, 0x0E9F
    b314:	f0 91 a0 0e 	lds	r31, 0x0EA0
    b318:	84 85       	ldd	r24, Z+12	; 0x0c
    b31a:	95 85       	ldd	r25, Z+13	; 0x0d
    b31c:	a6 85       	ldd	r26, Z+14	; 0x0e
    b31e:	b7 85       	ldd	r27, Z+15	; 0x0f
    b320:	89 83       	std	Y+1, r24	; 0x01
    b322:	9a 83       	std	Y+2, r25	; 0x02
    b324:	ab 83       	std	Y+3, r26	; 0x03
    b326:	bc 83       	std	Y+4, r27	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn6(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    b328:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b32c:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b330:	8d 81       	ldd	r24, Y+5	; 0x05
    b332:	9e 81       	ldd	r25, Y+6	; 0x06
    b334:	91 83       	std	Z+1, r25	; 0x01
    b336:	80 83       	st	Z, r24
      nicState.layer4.tcp->destport  = socket->remotePort;
    b338:	00 91 a1 0e 	lds	r16, 0x0EA1
    b33c:	10 91 a2 0e 	lds	r17, 0x0EA2
    b340:	8f 81       	ldd	r24, Y+7	; 0x07
    b342:	98 85       	ldd	r25, Y+8	; 0x08
    b344:	f8 01       	movw	r30, r16
    b346:	93 83       	std	Z+3, r25	; 0x03
    b348:	82 83       	std	Z+2, r24	; 0x02
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    b34a:	6d 85       	ldd	r22, Y+13	; 0x0d
    b34c:	7e 85       	ldd	r23, Y+14	; 0x0e
    b34e:	8f 85       	ldd	r24, Y+15	; 0x0f
    b350:	98 89       	ldd	r25, Y+16	; 0x10
    b352:	0e 94 ab 33 	call	0x6756	; 0x6756 <htonl>
    b356:	f8 01       	movw	r30, r16
    b358:	64 83       	std	Z+4, r22	; 0x04
    b35a:	75 83       	std	Z+5, r23	; 0x05
    b35c:	86 83       	std	Z+6, r24	; 0x06
    b35e:	97 83       	std	Z+7, r25	; 0x07
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    b360:	00 91 a1 0e 	lds	r16, 0x0EA1
    b364:	10 91 a2 0e 	lds	r17, 0x0EA2
    b368:	69 85       	ldd	r22, Y+9	; 0x09
    b36a:	7a 85       	ldd	r23, Y+10	; 0x0a
    b36c:	8b 85       	ldd	r24, Y+11	; 0x0b
    b36e:	9c 85       	ldd	r25, Y+12	; 0x0c
    b370:	6f 5f       	subi	r22, 0xFF	; 255
    b372:	7f 4f       	sbci	r23, 0xFF	; 255
    b374:	8f 4f       	sbci	r24, 0xFF	; 255
    b376:	9f 4f       	sbci	r25, 0xFF	; 255
    b378:	0e 94 ab 33 	call	0x6756	; 0x6756 <htonl>
    b37c:	f8 01       	movw	r30, r16
    b37e:	60 87       	std	Z+8, r22	; 0x08
    b380:	71 87       	std	Z+9, r23	; 0x09
    b382:	82 87       	std	Z+10, r24	; 0x0a
    b384:	93 87       	std	Z+11, r25	; 0x0b
      nicState.layer4.tcp->tcpoffset = 5<<4;
    b386:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b38a:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b38e:	80 e5       	ldi	r24, 0x50	; 80
    b390:	84 87       	std	Z+12, r24	; 0x0c
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    b392:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b396:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b39a:	82 e1       	ldi	r24, 0x12	; 18
    b39c:	85 87       	std	Z+13, r24	; 0x0d
      nicState.layer4.tcp->wnd       = htons(100);
    b39e:	00 91 a1 0e 	lds	r16, 0x0EA1
    b3a2:	10 91 a2 0e 	lds	r17, 0x0EA2
    b3a6:	84 e6       	ldi	r24, 0x64	; 100
    b3a8:	90 e0       	ldi	r25, 0x00	; 0
    b3aa:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    b3ae:	f8 01       	movw	r30, r16
    b3b0:	97 87       	std	Z+15, r25	; 0x0f
    b3b2:	86 87       	std	Z+14, r24	; 0x0e
      nicState.layer4.tcp->tcpchksum = 0;
    b3b4:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b3b8:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b3bc:	11 8a       	std	Z+17, r1	; 0x11
    b3be:	10 8a       	std	Z+16, r1	; 0x10
      nicState.layer4.tcp->urgp      = 0;
    b3c0:	13 8a       	std	Z+19, r1	; 0x13
    b3c2:	12 8a       	std	Z+18, r1	; 0x12
      calculateTcpChecksun(TCP_HEADER_LEN);
    b3c4:	84 e1       	ldi	r24, 0x14	; 20
    b3c6:	90 e0       	ldi	r25, 0x00	; 0
    b3c8:	0e 94 4e 40 	call	0x809c	; 0x809c <calculateTcpChecksun>

      socket->seqNoLastSent++;
    b3cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    b3ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    b3d0:	af 85       	ldd	r26, Y+15	; 0x0f
    b3d2:	b8 89       	ldd	r27, Y+16	; 0x10
    b3d4:	01 96       	adiw	r24, 0x01	; 1
    b3d6:	a1 1d       	adc	r26, r1
    b3d8:	b1 1d       	adc	r27, r1
    b3da:	8d 87       	std	Y+13, r24	; 0x0d
    b3dc:	9e 87       	std	Y+14, r25	; 0x0e
    b3de:	af 87       	std	Y+15, r26	; 0x0f
    b3e0:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    b3e2:	69 81       	ldd	r22, Y+1	; 0x01
    b3e4:	7a 81       	ldd	r23, Y+2	; 0x02
    b3e6:	8b 81       	ldd	r24, Y+3	; 0x03
    b3e8:	9c 81       	ldd	r25, Y+4	; 0x04
    b3ea:	46 e0       	ldi	r20, 0x06	; 6
    b3ec:	24 e1       	ldi	r18, 0x14	; 20
    b3ee:	30 e0       	ldi	r19, 0x00	; 0
    b3f0:	0e 94 59 38 	call	0x70b2	; 0x70b2 <ipSend>
    b3f4:	79 c0       	rjmp	.+242    	; 0xb4e8 <processTcpPacket6+0x26a>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    b3f6:	21 15       	cp	r18, r1
    b3f8:	31 05       	cpc	r19, r1
    b3fa:	09 f4       	brne	.+2      	; 0xb3fe <processTcpPacket6+0x180>
    b3fc:	75 c0       	rjmp	.+234    	; 0xb4e8 <processTcpPacket6+0x26a>
        if (tcpDebugLevel > 1)
    b3fe:	80 91 bc 0e 	lds	r24, 0x0EBC
    b402:	82 30       	cpi	r24, 0x02	; 2
    b404:	08 f4       	brcc	.+2      	; 0xb408 <processTcpPacket6+0x18a>
    b406:	70 c0       	rjmp	.+224    	; 0xb4e8 <processTcpPacket6+0x26a>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    b408:	00 d0       	rcall	.+0      	; 0xb40a <processTcpPacket6+0x18c>
    b40a:	00 d0       	rcall	.+0      	; 0xb40c <processTcpPacket6+0x18e>
    b40c:	ed b7       	in	r30, 0x3d	; 61
    b40e:	fe b7       	in	r31, 0x3e	; 62
    b410:	32 83       	std	Z+2, r19	; 0x02
    b412:	21 83       	std	Z+1, r18	; 0x01
    b414:	81 ea       	ldi	r24, 0xA1	; 161
    b416:	9d e1       	ldi	r25, 0x1D	; 29
    b418:	33 c0       	rjmp	.+102    	; 0xb480 <processTcpPacket6+0x202>
    }
#endif    
    return 0;
  }
  
  if (socket->state == SYN_RECEIVED)
    b41a:	82 30       	cpi	r24, 0x02	; 2
    b41c:	d9 f5       	brne	.+118    	; 0xb494 <processTcpPacket6+0x216>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    b41e:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b422:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b426:	85 85       	ldd	r24, Z+13	; 0x0d
    b428:	20 91 67 0f 	lds	r18, 0x0F67
    b42c:	30 91 68 0f 	lds	r19, 0x0F68
    b430:	84 ff       	sbrs	r24, 4
    b432:	14 c0       	rjmp	.+40     	; 0xb45c <processTcpPacket6+0x1de>
    {
      socket->state    = ESTABILISHED;
    b434:	83 e0       	ldi	r24, 0x03	; 3
    b436:	88 83       	st	Y, r24
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    b438:	21 15       	cp	r18, r1
    b43a:	31 05       	cpc	r19, r1
    b43c:	09 f4       	brne	.+2      	; 0xb440 <processTcpPacket6+0x1c2>
    b43e:	54 c0       	rjmp	.+168    	; 0xb4e8 <processTcpPacket6+0x26a>
      if (tcpDebugLevel > 2)
    b440:	80 91 bc 0e 	lds	r24, 0x0EBC
    b444:	83 30       	cpi	r24, 0x03	; 3
    b446:	08 f4       	brcc	.+2      	; 0xb44a <processTcpPacket6+0x1cc>
    b448:	4f c0       	rjmp	.+158    	; 0xb4e8 <processTcpPacket6+0x26a>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    b44a:	00 d0       	rcall	.+0      	; 0xb44c <processTcpPacket6+0x1ce>
    b44c:	00 d0       	rcall	.+0      	; 0xb44e <processTcpPacket6+0x1d0>
    b44e:	ed b7       	in	r30, 0x3d	; 61
    b450:	fe b7       	in	r31, 0x3e	; 62
    b452:	32 83       	std	Z+2, r19	; 0x02
    b454:	21 83       	std	Z+1, r18	; 0x01
    b456:	89 e5       	ldi	r24, 0x59	; 89
    b458:	9d e1       	ldi	r25, 0x1D	; 29
    b45a:	12 c0       	rjmp	.+36     	; 0xb480 <processTcpPacket6+0x202>
#endif        

    }
    else
    {
      socket->state = LISTEN;
    b45c:	81 e0       	ldi	r24, 0x01	; 1
    b45e:	88 83       	st	Y, r24
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    b460:	21 15       	cp	r18, r1
    b462:	31 05       	cpc	r19, r1
    b464:	09 f4       	brne	.+2      	; 0xb468 <processTcpPacket6+0x1ea>
    b466:	40 c0       	rjmp	.+128    	; 0xb4e8 <processTcpPacket6+0x26a>
        if (tcpDebugLevel > 1)
    b468:	80 91 bc 0e 	lds	r24, 0x0EBC
    b46c:	82 30       	cpi	r24, 0x02	; 2
    b46e:	e0 f1       	brcs	.+120    	; 0xb4e8 <processTcpPacket6+0x26a>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    b470:	00 d0       	rcall	.+0      	; 0xb472 <processTcpPacket6+0x1f4>
    b472:	00 d0       	rcall	.+0      	; 0xb474 <processTcpPacket6+0x1f6>
    b474:	ed b7       	in	r30, 0x3d	; 61
    b476:	fe b7       	in	r31, 0x3e	; 62
    b478:	32 83       	std	Z+2, r19	; 0x02
    b47a:	21 83       	std	Z+1, r18	; 0x01
    b47c:	85 e2       	ldi	r24, 0x25	; 37
    b47e:	9d e1       	ldi	r25, 0x1D	; 29
    b480:	94 83       	std	Z+4, r25	; 0x04
    b482:	83 83       	std	Z+3, r24	; 0x03
    b484:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    b488:	80 e0       	ldi	r24, 0x00	; 0
    b48a:	0f 90       	pop	r0
    b48c:	0f 90       	pop	r0
    b48e:	0f 90       	pop	r0
    b490:	0f 90       	pop	r0
    b492:	2b c0       	rjmp	.+86     	; 0xb4ea <processTcpPacket6+0x26c>
    }
    return 0;
  }
  
  
  if (socket->state == ESTABILISHED)
    b494:	83 30       	cpi	r24, 0x03	; 3
    b496:	41 f5       	brne	.+80     	; 0xb4e8 <processTcpPacket6+0x26a>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    b498:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b49c:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b4a0:	85 85       	ldd	r24, Z+13	; 0x0d
    b4a2:	80 ff       	sbrs	r24, 0
    b4a4:	21 c0       	rjmp	.+66     	; 0xb4e8 <processTcpPacket6+0x26a>
    {
      socket->timer              = timer100Hz;
    b4a6:	80 91 88 01 	lds	r24, 0x0188
    b4aa:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    b4ac:	80 e1       	ldi	r24, 0x10	; 16
    b4ae:	85 87       	std	Z+13, r24	; 0x0d
//      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
//      {
//        dataFromBufLen++;
//        dataPtr++;
//      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    b4b0:	69 81       	ldd	r22, Y+1	; 0x01
    b4b2:	7a 81       	ldd	r23, Y+2	; 0x02
    b4b4:	8b 81       	ldd	r24, Y+3	; 0x03
    b4b6:	9c 81       	ldd	r25, Y+4	; 0x04
    b4b8:	46 e0       	ldi	r20, 0x06	; 6
    b4ba:	24 e1       	ldi	r18, 0x14	; 20
    b4bc:	30 e0       	ldi	r19, 0x00	; 0
    b4be:	0e 94 59 38 	call	0x70b2	; 0x70b2 <ipSend>
      socket->state    = CLOSE_WAIT;
    b4c2:	84 e0       	ldi	r24, 0x04	; 4
    b4c4:	88 83       	st	Y, r24
      
      
      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    b4c6:	e0 91 a1 0e 	lds	r30, 0x0EA1
    b4ca:	f0 91 a2 0e 	lds	r31, 0x0EA2
    b4ce:	81 e0       	ldi	r24, 0x01	; 1
    b4d0:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    b4d2:	69 81       	ldd	r22, Y+1	; 0x01
    b4d4:	7a 81       	ldd	r23, Y+2	; 0x02
    b4d6:	8b 81       	ldd	r24, Y+3	; 0x03
    b4d8:	9c 81       	ldd	r25, Y+4	; 0x04
    b4da:	46 e0       	ldi	r20, 0x06	; 6
    b4dc:	24 e1       	ldi	r18, 0x14	; 20
    b4de:	30 e0       	ldi	r19, 0x00	; 0
    b4e0:	0e 94 59 38 	call	0x70b2	; 0x70b2 <ipSend>
      socket->state    = LAST_ACK;
    b4e4:	85 e0       	ldi	r24, 0x05	; 5
    b4e6:	88 83       	st	Y, r24
    b4e8:	80 e0       	ldi	r24, 0x00	; 0
  }

  //Read data and put into the queue
  
  return 0;
}
    b4ea:	df 91       	pop	r29
    b4ec:	cf 91       	pop	r28
    b4ee:	1f 91       	pop	r17
    b4f0:	0f 91       	pop	r16
    b4f2:	08 95       	ret

0000b4f4 <socketInit6>:
 * @param *sck socket
 */
static inline void tcpAcceptConn6(struct TcpIpSocket *sck);

inline void socketInit6(void)
{
    b4f4:	bf 92       	push	r11
    b4f6:	cf 92       	push	r12
    b4f8:	df 92       	push	r13
    b4fa:	ef 92       	push	r14
    b4fc:	ff 92       	push	r15
    b4fe:	0f 93       	push	r16
    b500:	1f 93       	push	r17
    b502:	cf 93       	push	r28
    b504:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    b506:	80 e3       	ldi	r24, 0x30	; 48
    b508:	92 e0       	ldi	r25, 0x02	; 2
    b50a:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    b50e:	80 93 d5 0e 	sts	0x0ED5, r24
    b512:	90 93 d6 0e 	sts	0x0ED6, r25
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    b516:	fc 01       	movw	r30, r24
    b518:	80 e3       	ldi	r24, 0x30	; 48
    b51a:	92 e0       	ldi	r25, 0x02	; 2
    b51c:	df 01       	movw	r26, r30
    b51e:	9c 01       	movw	r18, r24
    b520:	1d 92       	st	X+, r1
    b522:	21 50       	subi	r18, 0x01	; 1
    b524:	30 40       	sbci	r19, 0x00	; 0
    b526:	e1 f7       	brne	.-8      	; 0xb520 <socketInit6+0x2c>
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    b528:	00 91 d5 0e 	lds	r16, 0x0ED5
    b52c:	10 91 d6 0e 	lds	r17, 0x0ED6
    b530:	c8 ea       	ldi	r28, 0xA8	; 168
    b532:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    b534:	8f ef       	ldi	r24, 0xFF	; 255
    b536:	c8 2e       	mov	r12, r24
    b538:	81 e1       	ldi	r24, 0x11	; 17
    b53a:	d8 2e       	mov	r13, r24
    b53c:	82 e2       	ldi	r24, 0x22	; 34
    b53e:	e8 2e       	mov	r14, r24
    b540:	83 e3       	ldi	r24, 0x33	; 51
    b542:	f8 2e       	mov	r15, r24
    sck->state         = LISTEN;   
    b544:	bb 24       	eor	r11, r11
    b546:	b3 94       	inc	r11
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    b548:	de 01       	movw	r26, r28
    b54a:	a8 5a       	subi	r26, 0xA8	; 168
    b54c:	a0 31       	cpi	r26, 0x10	; 16
    b54e:	18 f0       	brcs	.+6      	; 0xb556 <socketInit6+0x62>
    b550:	88 eb       	ldi	r24, 0xB8	; 184
    b552:	91 e6       	ldi	r25, 0x61	; 97
    b554:	03 c0       	rjmp	.+6      	; 0xb55c <socketInit6+0x68>
    b556:	ce 01       	movw	r24, r28
    b558:	0e 94 a7 33 	call	0x674e	; 0x674e <htons>
    b55c:	f8 01       	movw	r30, r16
    b55e:	96 83       	std	Z+6, r25	; 0x06
    b560:	85 83       	std	Z+5, r24	; 0x05
    sck->seqNoLastSent = HTONL(0xFF112233); 
    b562:	d8 01       	movw	r26, r16
    b564:	1d 96       	adiw	r26, 0x0d	; 13
    b566:	cd 92       	st	X+, r12
    b568:	dd 92       	st	X+, r13
    b56a:	ed 92       	st	X+, r14
    b56c:	fc 92       	st	X, r15
    b56e:	50 97       	sbiw	r26, 0x10	; 16
    sck->state         = LISTEN;   
    b570:	bc 92       	st	X, r11
    b572:	21 96       	adiw	r28, 0x01	; 1
  
  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    b574:	b1 e6       	ldi	r27, 0x61	; 97
    b576:	cc 3b       	cpi	r28, 0xBC	; 188
    b578:	db 07       	cpc	r29, r27
    b57a:	19 f0       	breq	.+6      	; 0xb582 <socketInit6+0x8e>
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233); 
    sck->state         = LISTEN;   
    sck++;
    b57c:	04 5e       	subi	r16, 0xE4	; 228
    b57e:	1f 4f       	sbci	r17, 0xFF	; 255
    b580:	e3 cf       	rjmp	.-58     	; 0xb548 <socketInit6+0x54>
  }
}
    b582:	df 91       	pop	r29
    b584:	cf 91       	pop	r28
    b586:	1f 91       	pop	r17
    b588:	0f 91       	pop	r16
    b58a:	ff 90       	pop	r15
    b58c:	ef 90       	pop	r14
    b58e:	df 90       	pop	r13
    b590:	cf 90       	pop	r12
    b592:	bf 90       	pop	r11
    b594:	08 95       	ret
    b596:	08 95       	ret
    b598:	08 95       	ret
    b59a:	08 95       	ret
    b59c:	81 e0       	ldi	r24, 0x01	; 1
    b59e:	08 95       	ret
    b5a0:	81 e0       	ldi	r24, 0x01	; 1
    b5a2:	08 95       	ret

0000b5a4 <rs485curtainUp>:
  releaseRs485();
  return 0;
}

uint8_t rs485curtainUp(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    b5a4:	ff 92       	push	r15
    b5a6:	0f 93       	push	r16
    b5a8:	1f 93       	push	r17
    b5aa:	cf 93       	push	r28
    b5ac:	df 93       	push	r29
    b5ae:	18 2f       	mov	r17, r24
    b5b0:	06 2f       	mov	r16, r22
    b5b2:	f4 2e       	mov	r15, r20
    b5b4:	c0 e0       	ldi	r28, 0x00	; 0
    b5b6:	d0 e0       	ldi	r29, 0x00	; 0
    b5b8:	8a e5       	ldi	r24, 0x5A	; 90
    b5ba:	d8 27       	eor	r29, r24
    b5bc:	0d 2e       	mov	r0, r29
    b5be:	02 94       	swap	r0
    b5c0:	80 2d       	mov	r24, r0
    b5c2:	8f 70       	andi	r24, 0x0F	; 15
    b5c4:	8d 27       	eor	r24, r29
    b5c6:	9d 2f       	mov	r25, r29
    b5c8:	90 25       	eor	r25, r0
    b5ca:	99 0f       	add	r25, r25
    b5cc:	90 7e       	andi	r25, 0xE0	; 224
    b5ce:	89 27       	eor	r24, r25
    b5d0:	90 2d       	mov	r25, r0
    b5d2:	9d 27       	eor	r25, r29
    b5d4:	90 7f       	andi	r25, 0xF0	; 240
    b5d6:	96 95       	lsr	r25
    b5d8:	0d 2e       	mov	r0, r29
    b5da:	00 0c       	add	r0, r0
    b5dc:	99 1f       	adc	r25, r25
    b5de:	d6 95       	lsr	r29
    b5e0:	d6 95       	lsr	r29
    b5e2:	d6 95       	lsr	r29
    b5e4:	df 71       	andi	r29, 0x1F	; 31
    b5e6:	d9 27       	eor	r29, r25
    b5e8:	dc 27       	eor	r29, r28
    b5ea:	c8 2f       	mov	r28, r24
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);
  uartRs485SendByte(SYNC);
    b5ec:	8a e5       	ldi	r24, 0x5A	; 90
    b5ee:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    b5f2:	d1 27       	eor	r29, r17
    b5f4:	0d 2e       	mov	r0, r29
    b5f6:	02 94       	swap	r0
    b5f8:	80 2d       	mov	r24, r0
    b5fa:	8f 70       	andi	r24, 0x0F	; 15
    b5fc:	8d 27       	eor	r24, r29
    b5fe:	9d 2f       	mov	r25, r29
    b600:	90 25       	eor	r25, r0
    b602:	99 0f       	add	r25, r25
    b604:	90 7e       	andi	r25, 0xE0	; 224
    b606:	89 27       	eor	r24, r25
    b608:	90 2d       	mov	r25, r0
    b60a:	9d 27       	eor	r25, r29
    b60c:	90 7f       	andi	r25, 0xF0	; 240
    b60e:	96 95       	lsr	r25
    b610:	0d 2e       	mov	r0, r29
    b612:	00 0c       	add	r0, r0
    b614:	99 1f       	adc	r25, r25
    b616:	d6 95       	lsr	r29
    b618:	d6 95       	lsr	r29
    b61a:	d6 95       	lsr	r29
    b61c:	df 71       	andi	r29, 0x1F	; 31
    b61e:	d9 27       	eor	r29, r25
    b620:	dc 27       	eor	r29, r28
    b622:	c8 2f       	mov	r28, r24

  crc = _crc_xmodem_update(crc, deviceAddr);
  uartRs485SendByte(deviceAddr);
    b624:	81 2f       	mov	r24, r17
    b626:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  if (curtainNo == 0)
    b62a:	00 23       	and	r16, r16
    b62c:	e1 f4       	brne	.+56     	; 0xb666 <rs485curtainUp+0xc2>
    b62e:	80 e2       	ldi	r24, 0x20	; 32
    b630:	d8 27       	eor	r29, r24
    b632:	0d 2e       	mov	r0, r29
    b634:	02 94       	swap	r0
    b636:	80 2d       	mov	r24, r0
    b638:	8f 70       	andi	r24, 0x0F	; 15
    b63a:	8d 27       	eor	r24, r29
    b63c:	9d 2f       	mov	r25, r29
    b63e:	90 25       	eor	r25, r0
    b640:	99 0f       	add	r25, r25
    b642:	90 7e       	andi	r25, 0xE0	; 224
    b644:	89 27       	eor	r24, r25
    b646:	90 2d       	mov	r25, r0
    b648:	9d 27       	eor	r25, r29
    b64a:	90 7f       	andi	r25, 0xF0	; 240
    b64c:	96 95       	lsr	r25
    b64e:	0d 2e       	mov	r0, r29
    b650:	00 0c       	add	r0, r0
    b652:	99 1f       	adc	r25, r25
    b654:	d6 95       	lsr	r29
    b656:	d6 95       	lsr	r29
    b658:	d6 95       	lsr	r29
    b65a:	df 71       	andi	r29, 0x1F	; 31
    b65c:	d9 27       	eor	r29, r25
    b65e:	dc 27       	eor	r29, r28
    b660:	c8 2f       	mov	r28, r24
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete1);
    uartRs485SendByte(rPodniesRolete1);
    b662:	80 e2       	ldi	r24, 0x20	; 32
    b664:	1b c0       	rjmp	.+54     	; 0xb69c <rs485curtainUp+0xf8>
    b666:	81 e2       	ldi	r24, 0x21	; 33
    b668:	d8 27       	eor	r29, r24
    b66a:	0d 2e       	mov	r0, r29
    b66c:	02 94       	swap	r0
    b66e:	80 2d       	mov	r24, r0
    b670:	8f 70       	andi	r24, 0x0F	; 15
    b672:	8d 27       	eor	r24, r29
    b674:	9d 2f       	mov	r25, r29
    b676:	90 25       	eor	r25, r0
    b678:	99 0f       	add	r25, r25
    b67a:	90 7e       	andi	r25, 0xE0	; 224
    b67c:	89 27       	eor	r24, r25
    b67e:	90 2d       	mov	r25, r0
    b680:	9d 27       	eor	r25, r29
    b682:	90 7f       	andi	r25, 0xF0	; 240
    b684:	96 95       	lsr	r25
    b686:	0d 2e       	mov	r0, r29
    b688:	00 0c       	add	r0, r0
    b68a:	99 1f       	adc	r25, r25
    b68c:	d6 95       	lsr	r29
    b68e:	d6 95       	lsr	r29
    b690:	d6 95       	lsr	r29
    b692:	df 71       	andi	r29, 0x1F	; 31
    b694:	d9 27       	eor	r29, r25
    b696:	dc 27       	eor	r29, r28
    b698:	c8 2f       	mov	r28, r24
  }
  else
  {
    crc = _crc_xmodem_update(crc, rPodniesRolete2);
    uartRs485SendByte(rPodniesRolete2); 
    b69a:	81 e2       	ldi	r24, 0x21	; 33
    b69c:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    b6a0:	81 e0       	ldi	r24, 0x01	; 1
    b6a2:	d8 27       	eor	r29, r24
    b6a4:	0d 2e       	mov	r0, r29
    b6a6:	02 94       	swap	r0
    b6a8:	80 2d       	mov	r24, r0
    b6aa:	8f 70       	andi	r24, 0x0F	; 15
    b6ac:	8d 27       	eor	r24, r29
    b6ae:	9d 2f       	mov	r25, r29
    b6b0:	90 25       	eor	r25, r0
    b6b2:	99 0f       	add	r25, r25
    b6b4:	90 7e       	andi	r25, 0xE0	; 224
    b6b6:	89 27       	eor	r24, r25
    b6b8:	90 2d       	mov	r25, r0
    b6ba:	9d 27       	eor	r25, r29
    b6bc:	90 7f       	andi	r25, 0xF0	; 240
    b6be:	96 95       	lsr	r25
    b6c0:	0d 2e       	mov	r0, r29
    b6c2:	00 0c       	add	r0, r0
    b6c4:	99 1f       	adc	r25, r25
    b6c6:	d6 95       	lsr	r29
    b6c8:	d6 95       	lsr	r29
    b6ca:	d6 95       	lsr	r29
    b6cc:	df 71       	andi	r29, 0x1F	; 31
    b6ce:	d9 27       	eor	r29, r25
    b6d0:	dc 27       	eor	r29, r28
    b6d2:	c8 2f       	mov	r28, r24
  }
  
  crc = _crc_xmodem_update(crc, 1);    uartRs485SendByte(1);
    b6d4:	81 e0       	ldi	r24, 0x01	; 1
    b6d6:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    b6da:	df 25       	eor	r29, r15
    b6dc:	0d 2e       	mov	r0, r29
    b6de:	02 94       	swap	r0
    b6e0:	80 2d       	mov	r24, r0
    b6e2:	8f 70       	andi	r24, 0x0F	; 15
    b6e4:	8d 27       	eor	r24, r29
    b6e6:	9d 2f       	mov	r25, r29
    b6e8:	90 25       	eor	r25, r0
    b6ea:	99 0f       	add	r25, r25
    b6ec:	90 7e       	andi	r25, 0xE0	; 224
    b6ee:	89 27       	eor	r24, r25
    b6f0:	90 2d       	mov	r25, r0
    b6f2:	9d 27       	eor	r25, r29
    b6f4:	90 7f       	andi	r25, 0xF0	; 240
    b6f6:	96 95       	lsr	r25
    b6f8:	0d 2e       	mov	r0, r29
    b6fa:	00 0c       	add	r0, r0
    b6fc:	99 1f       	adc	r25, r25
    b6fe:	d6 95       	lsr	r29
    b700:	d6 95       	lsr	r29
    b702:	d6 95       	lsr	r29
    b704:	df 71       	andi	r29, 0x1F	; 31
    b706:	d9 27       	eor	r29, r25
    b708:	dc 27       	eor	r29, r28
    b70a:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, pos);  uartRs485SendByte(pos);
    b70c:	8f 2d       	mov	r24, r15
    b70e:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    b712:	8d 2f       	mov	r24, r29
    b714:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    b718:	8c 2f       	mov	r24, r28
    b71a:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  
  return 0;
}
    b71e:	80 e0       	ldi	r24, 0x00	; 0
    b720:	df 91       	pop	r29
    b722:	cf 91       	pop	r28
    b724:	1f 91       	pop	r17
    b726:	0f 91       	pop	r16
    b728:	ff 90       	pop	r15
    b72a:	08 95       	ret

0000b72c <rs485curtainDown>:

uint8_t rs485curtainDown(uint8_t deviceAddr, uint8_t curtainNo, uint8_t pos)
{
    b72c:	ff 92       	push	r15
    b72e:	0f 93       	push	r16
    b730:	1f 93       	push	r17
    b732:	cf 93       	push	r28
    b734:	df 93       	push	r29
    b736:	18 2f       	mov	r17, r24
    b738:	06 2f       	mov	r16, r22
    b73a:	f4 2e       	mov	r15, r20
    b73c:	c0 e0       	ldi	r28, 0x00	; 0
    b73e:	d0 e0       	ldi	r29, 0x00	; 0
    b740:	8a e5       	ldi	r24, 0x5A	; 90
    b742:	d8 27       	eor	r29, r24
    b744:	0d 2e       	mov	r0, r29
    b746:	02 94       	swap	r0
    b748:	80 2d       	mov	r24, r0
    b74a:	8f 70       	andi	r24, 0x0F	; 15
    b74c:	8d 27       	eor	r24, r29
    b74e:	9d 2f       	mov	r25, r29
    b750:	90 25       	eor	r25, r0
    b752:	99 0f       	add	r25, r25
    b754:	90 7e       	andi	r25, 0xE0	; 224
    b756:	89 27       	eor	r24, r25
    b758:	90 2d       	mov	r25, r0
    b75a:	9d 27       	eor	r25, r29
    b75c:	90 7f       	andi	r25, 0xF0	; 240
    b75e:	96 95       	lsr	r25
    b760:	0d 2e       	mov	r0, r29
    b762:	00 0c       	add	r0, r0
    b764:	99 1f       	adc	r25, r25
    b766:	d6 95       	lsr	r29
    b768:	d6 95       	lsr	r29
    b76a:	d6 95       	lsr	r29
    b76c:	df 71       	andi	r29, 0x1F	; 31
    b76e:	d9 27       	eor	r29, r25
    b770:	dc 27       	eor	r29, r28
    b772:	c8 2f       	mov	r28, r24
  uint16_t crc = 0;
  
  crc = _crc_xmodem_update(crc, SYNC);            uartRs485SendByte(SYNC);
    b774:	8a e5       	ldi	r24, 0x5A	; 90
    b776:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    b77a:	d1 27       	eor	r29, r17
    b77c:	0d 2e       	mov	r0, r29
    b77e:	02 94       	swap	r0
    b780:	80 2d       	mov	r24, r0
    b782:	8f 70       	andi	r24, 0x0F	; 15
    b784:	8d 27       	eor	r24, r29
    b786:	9d 2f       	mov	r25, r29
    b788:	90 25       	eor	r25, r0
    b78a:	99 0f       	add	r25, r25
    b78c:	90 7e       	andi	r25, 0xE0	; 224
    b78e:	89 27       	eor	r24, r25
    b790:	90 2d       	mov	r25, r0
    b792:	9d 27       	eor	r25, r29
    b794:	90 7f       	andi	r25, 0xF0	; 240
    b796:	96 95       	lsr	r25
    b798:	0d 2e       	mov	r0, r29
    b79a:	00 0c       	add	r0, r0
    b79c:	99 1f       	adc	r25, r25
    b79e:	d6 95       	lsr	r29
    b7a0:	d6 95       	lsr	r29
    b7a2:	d6 95       	lsr	r29
    b7a4:	df 71       	andi	r29, 0x1F	; 31
    b7a6:	d9 27       	eor	r29, r25
    b7a8:	dc 27       	eor	r29, r28
    b7aa:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, deviceAddr);    uartRs485SendByte(deviceAddr);
    b7ac:	81 2f       	mov	r24, r17
    b7ae:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  if (curtainNo == 0)
    b7b2:	00 23       	and	r16, r16
    b7b4:	e1 f4       	brne	.+56     	; 0xb7ee <rs485curtainDown+0xc2>
    b7b6:	80 e1       	ldi	r24, 0x10	; 16
    b7b8:	d8 27       	eor	r29, r24
    b7ba:	0d 2e       	mov	r0, r29
    b7bc:	02 94       	swap	r0
    b7be:	80 2d       	mov	r24, r0
    b7c0:	8f 70       	andi	r24, 0x0F	; 15
    b7c2:	8d 27       	eor	r24, r29
    b7c4:	9d 2f       	mov	r25, r29
    b7c6:	90 25       	eor	r25, r0
    b7c8:	99 0f       	add	r25, r25
    b7ca:	90 7e       	andi	r25, 0xE0	; 224
    b7cc:	89 27       	eor	r24, r25
    b7ce:	90 2d       	mov	r25, r0
    b7d0:	9d 27       	eor	r25, r29
    b7d2:	90 7f       	andi	r25, 0xF0	; 240
    b7d4:	96 95       	lsr	r25
    b7d6:	0d 2e       	mov	r0, r29
    b7d8:	00 0c       	add	r0, r0
    b7da:	99 1f       	adc	r25, r25
    b7dc:	d6 95       	lsr	r29
    b7de:	d6 95       	lsr	r29
    b7e0:	d6 95       	lsr	r29
    b7e2:	df 71       	andi	r29, 0x1F	; 31
    b7e4:	d9 27       	eor	r29, r25
    b7e6:	dc 27       	eor	r29, r28
    b7e8:	c8 2f       	mov	r28, r24
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete1); uartRs485SendByte(rOpuscRolete1);
    b7ea:	80 e1       	ldi	r24, 0x10	; 16
    b7ec:	1b c0       	rjmp	.+54     	; 0xb824 <rs485curtainDown+0xf8>
    b7ee:	81 e1       	ldi	r24, 0x11	; 17
    b7f0:	d8 27       	eor	r29, r24
    b7f2:	0d 2e       	mov	r0, r29
    b7f4:	02 94       	swap	r0
    b7f6:	80 2d       	mov	r24, r0
    b7f8:	8f 70       	andi	r24, 0x0F	; 15
    b7fa:	8d 27       	eor	r24, r29
    b7fc:	9d 2f       	mov	r25, r29
    b7fe:	90 25       	eor	r25, r0
    b800:	99 0f       	add	r25, r25
    b802:	90 7e       	andi	r25, 0xE0	; 224
    b804:	89 27       	eor	r24, r25
    b806:	90 2d       	mov	r25, r0
    b808:	9d 27       	eor	r25, r29
    b80a:	90 7f       	andi	r25, 0xF0	; 240
    b80c:	96 95       	lsr	r25
    b80e:	0d 2e       	mov	r0, r29
    b810:	00 0c       	add	r0, r0
    b812:	99 1f       	adc	r25, r25
    b814:	d6 95       	lsr	r29
    b816:	d6 95       	lsr	r29
    b818:	d6 95       	lsr	r29
    b81a:	df 71       	andi	r29, 0x1F	; 31
    b81c:	d9 27       	eor	r29, r25
    b81e:	dc 27       	eor	r29, r28
    b820:	c8 2f       	mov	r28, r24
  }
  else
  {
    crc = _crc_xmodem_update(crc, rOpuscRolete2); uartRs485SendByte(rOpuscRolete2); 
    b822:	81 e1       	ldi	r24, 0x11	; 17
    b824:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    b828:	81 e0       	ldi	r24, 0x01	; 1
    b82a:	d8 27       	eor	r29, r24
    b82c:	0d 2e       	mov	r0, r29
    b82e:	02 94       	swap	r0
    b830:	80 2d       	mov	r24, r0
    b832:	8f 70       	andi	r24, 0x0F	; 15
    b834:	8d 27       	eor	r24, r29
    b836:	9d 2f       	mov	r25, r29
    b838:	90 25       	eor	r25, r0
    b83a:	99 0f       	add	r25, r25
    b83c:	90 7e       	andi	r25, 0xE0	; 224
    b83e:	89 27       	eor	r24, r25
    b840:	90 2d       	mov	r25, r0
    b842:	9d 27       	eor	r25, r29
    b844:	90 7f       	andi	r25, 0xF0	; 240
    b846:	96 95       	lsr	r25
    b848:	0d 2e       	mov	r0, r29
    b84a:	00 0c       	add	r0, r0
    b84c:	99 1f       	adc	r25, r25
    b84e:	d6 95       	lsr	r29
    b850:	d6 95       	lsr	r29
    b852:	d6 95       	lsr	r29
    b854:	df 71       	andi	r29, 0x1F	; 31
    b856:	d9 27       	eor	r29, r25
    b858:	dc 27       	eor	r29, r28
    b85a:	c8 2f       	mov	r28, r24
  }

  crc = _crc_xmodem_update(crc, 1);               uartRs485SendByte(1);
    b85c:	81 e0       	ldi	r24, 0x01	; 1
    b85e:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    b862:	df 25       	eor	r29, r15
    b864:	0d 2e       	mov	r0, r29
    b866:	02 94       	swap	r0
    b868:	80 2d       	mov	r24, r0
    b86a:	8f 70       	andi	r24, 0x0F	; 15
    b86c:	8d 27       	eor	r24, r29
    b86e:	9d 2f       	mov	r25, r29
    b870:	90 25       	eor	r25, r0
    b872:	99 0f       	add	r25, r25
    b874:	90 7e       	andi	r25, 0xE0	; 224
    b876:	89 27       	eor	r24, r25
    b878:	90 2d       	mov	r25, r0
    b87a:	9d 27       	eor	r25, r29
    b87c:	90 7f       	andi	r25, 0xF0	; 240
    b87e:	96 95       	lsr	r25
    b880:	0d 2e       	mov	r0, r29
    b882:	00 0c       	add	r0, r0
    b884:	99 1f       	adc	r25, r25
    b886:	d6 95       	lsr	r29
    b888:	d6 95       	lsr	r29
    b88a:	d6 95       	lsr	r29
    b88c:	df 71       	andi	r29, 0x1F	; 31
    b88e:	d9 27       	eor	r29, r25
    b890:	dc 27       	eor	r29, r28
    b892:	c8 2f       	mov	r28, r24
  crc = _crc_xmodem_update(crc, pos);         uartRs485SendByte(pos);
    b894:	8f 2d       	mov	r24, r15
    b896:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc>>8));
    b89a:	8d 2f       	mov	r24, r29
    b89c:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    b8a0:	8c 2f       	mov	r24, r28
    b8a2:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>

  return 0;
}
    b8a6:	80 e0       	ldi	r24, 0x00	; 0
    b8a8:	df 91       	pop	r29
    b8aa:	cf 91       	pop	r28
    b8ac:	1f 91       	pop	r17
    b8ae:	0f 91       	pop	r16
    b8b0:	ff 90       	pop	r15
    b8b2:	08 95       	ret

0000b8b4 <printRs485devices>:
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
}

#ifdef PRINT_RS485_DEVICE
uint8_t printRs485devices(FILE *stream)
{
    b8b4:	af 92       	push	r10
    b8b6:	bf 92       	push	r11
    b8b8:	cf 92       	push	r12
    b8ba:	df 92       	push	r13
    b8bc:	ef 92       	push	r14
    b8be:	ff 92       	push	r15
    b8c0:	0f 93       	push	r16
    b8c2:	1f 93       	push	r17
    b8c4:	cf 93       	push	r28
    b8c6:	df 93       	push	r29
    b8c8:	7c 01       	movw	r14, r24
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
    b8ca:	c0 91 bf 0e 	lds	r28, 0x0EBF
    b8ce:	d0 91 c0 0e 	lds	r29, 0x0EC0
    b8d2:	00 e0       	ldi	r16, 0x00	; 0
    b8d4:	10 e0       	ldi	r17, 0x00	; 0
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    b8d6:	93 e8       	ldi	r25, 0x83	; 131
    b8d8:	a9 2e       	mov	r10, r25
    b8da:	9e e1       	ldi	r25, 0x1E	; 30
    b8dc:	b9 2e       	mov	r11, r25
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    b8de:	81 ec       	ldi	r24, 0xC1	; 193
    b8e0:	c8 2e       	mov	r12, r24
    b8e2:	8e e1       	ldi	r24, 0x1E	; 30
    b8e4:	d8 2e       	mov	r13, r24
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
  {
    if (rolTmp->address != 0)
    b8e6:	89 81       	ldd	r24, Y+1	; 0x01
    b8e8:	88 23       	and	r24, r24
    b8ea:	09 f4       	brne	.+2      	; 0xb8ee <printRs485devices+0x3a>
    b8ec:	43 c0       	rjmp	.+134    	; 0xb974 <printRs485devices+0xc0>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
    b8ee:	2d b7       	in	r18, 0x3d	; 61
    b8f0:	3e b7       	in	r19, 0x3e	; 62
    b8f2:	2a 50       	subi	r18, 0x0A	; 10
    b8f4:	30 40       	sbci	r19, 0x00	; 0
    b8f6:	0f b6       	in	r0, 0x3f	; 63
    b8f8:	f8 94       	cli
    b8fa:	3e bf       	out	0x3e, r19	; 62
    b8fc:	0f be       	out	0x3f, r0	; 63
    b8fe:	2d bf       	out	0x3d, r18	; 61
    b900:	ed b7       	in	r30, 0x3d	; 61
    b902:	fe b7       	in	r31, 0x3e	; 62
    b904:	31 96       	adiw	r30, 0x01	; 1
    b906:	ad b7       	in	r26, 0x3d	; 61
    b908:	be b7       	in	r27, 0x3e	; 62
    b90a:	12 96       	adiw	r26, 0x02	; 2
    b90c:	fc 92       	st	X, r15
    b90e:	ee 92       	st	-X, r14
    b910:	11 97       	sbiw	r26, 0x01	; 1
    b912:	b3 82       	std	Z+3, r11	; 0x03
    b914:	a2 82       	std	Z+2, r10	; 0x02
    b916:	84 83       	std	Z+4, r24	; 0x04
    b918:	15 82       	std	Z+5, r1	; 0x05
    b91a:	8a 81       	ldd	r24, Y+2	; 0x02
    b91c:	90 e0       	ldi	r25, 0x00	; 0
    b91e:	8f 73       	andi	r24, 0x3F	; 63
    b920:	90 70       	andi	r25, 0x00	; 0
    b922:	97 83       	std	Z+7, r25	; 0x07
    b924:	86 83       	std	Z+6, r24	; 0x06
    b926:	8b 81       	ldd	r24, Y+3	; 0x03
    b928:	90 e0       	ldi	r25, 0x00	; 0
    b92a:	8f 73       	andi	r24, 0x3F	; 63
    b92c:	90 70       	andi	r25, 0x00	; 0
    b92e:	91 87       	std	Z+9, r25	; 0x09
    b930:	80 87       	std	Z+8, r24	; 0x08
    b932:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
    b936:	0f 90       	pop	r0
    b938:	0f 90       	pop	r0
    b93a:	0f 90       	pop	r0
    b93c:	0f 90       	pop	r0
    b93e:	ed b7       	in	r30, 0x3d	; 61
    b940:	fe b7       	in	r31, 0x3e	; 62
    b942:	31 96       	adiw	r30, 0x01	; 1
    b944:	ad b7       	in	r26, 0x3d	; 61
    b946:	be b7       	in	r27, 0x3e	; 62
    b948:	12 96       	adiw	r26, 0x02	; 2
    b94a:	fc 92       	st	X, r15
    b94c:	ee 92       	st	-X, r14
    b94e:	11 97       	sbiw	r26, 0x01	; 1
    b950:	d3 82       	std	Z+3, r13	; 0x03
    b952:	c2 82       	std	Z+2, r12	; 0x02
    b954:	24 96       	adiw	r28, 0x04	; 4
    b956:	d5 83       	std	Z+5, r29	; 0x05
    b958:	c4 83       	std	Z+4, r28	; 0x04
    b95a:	24 97       	sbiw	r28, 0x04	; 4
    b95c:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
      result++;
    b960:	0f 5f       	subi	r16, 0xFF	; 255
    b962:	2d b7       	in	r18, 0x3d	; 61
    b964:	3e b7       	in	r19, 0x3e	; 62
    b966:	2a 5f       	subi	r18, 0xFA	; 250
    b968:	3f 4f       	sbci	r19, 0xFF	; 255
    b96a:	0f b6       	in	r0, 0x3f	; 63
    b96c:	f8 94       	cli
    b96e:	3e bf       	out	0x3e, r19	; 62
    b970:	0f be       	out	0x3f, r0	; 63
    b972:	2d bf       	out	0x3d, r18	; 61
{
  uint8_t result = 0;
  struct sterRolet *rolTmp = rollers;
  
  //Print RollerDrivers
  for (uint8_t i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    b974:	1f 5f       	subi	r17, 0xFF	; 255
    b976:	1a 30       	cpi	r17, 0x0A	; 10
    b978:	11 f0       	breq	.+4      	; 0xb97e <printRs485devices+0xca>
    {
      fprintf_P(stream, statusRollerDescStr, rolTmp->address, rolTmp->response.parsed.stateRoller1 & 0x3F, rolTmp->response.parsed.stateRoller2 & 0x3F);
      fprintf_P(stream, statusRollerDescStr2, rolTmp->response.parsed.firmware);
      result++;
    }
    rolTmp++;
    b97a:	2a 96       	adiw	r28, 0x0a	; 10
    b97c:	b4 cf       	rjmp	.-152    	; 0xb8e6 <printRs485devices+0x32>
  }
  
  
  return result;
}
    b97e:	80 2f       	mov	r24, r16
    b980:	df 91       	pop	r29
    b982:	cf 91       	pop	r28
    b984:	1f 91       	pop	r17
    b986:	0f 91       	pop	r16
    b988:	ff 90       	pop	r15
    b98a:	ef 90       	pop	r14
    b98c:	df 90       	pop	r13
    b98e:	cf 90       	pop	r12
    b990:	bf 90       	pop	r11
    b992:	af 90       	pop	r10
    b994:	08 95       	ret

0000b996 <rs485xModemFlash>:
  return result;
}


uint8_t rs485xModemFlash(struct ramPlikFd *file, uint8_t devAddr, FILE *debugStr)
{
    b996:	6f 92       	push	r6
    b998:	7f 92       	push	r7
    b99a:	8f 92       	push	r8
    b99c:	9f 92       	push	r9
    b99e:	af 92       	push	r10
    b9a0:	bf 92       	push	r11
    b9a2:	cf 92       	push	r12
    b9a4:	df 92       	push	r13
    b9a6:	ef 92       	push	r14
    b9a8:	ff 92       	push	r15
    b9aa:	0f 93       	push	r16
    b9ac:	1f 93       	push	r17
    b9ae:	df 93       	push	r29
    b9b0:	cf 93       	push	r28
    b9b2:	00 d0       	rcall	.+0      	; 0xb9b4 <rs485xModemFlash+0x1e>
    b9b4:	cd b7       	in	r28, 0x3d	; 61
    b9b6:	de b7       	in	r29, 0x3e	; 62
    b9b8:	3c 01       	movw	r6, r24
    b9ba:	b6 2e       	mov	r11, r22
    b9bc:	6a 01       	movw	r12, r20
  uint8_t  blad = 0;
  uint8_t  data;
  uint8_t  nrBloku;
  uint8_t  lRetransmisji;
  
  takeRs485();                                  // Zajmowanie magistrali Rs485
    b9be:	0e 94 f5 11 	call	0x23ea	; 0x23ea <takeRs485>
    b9c2:	00 e0       	ldi	r16, 0x00	; 0
    b9c4:	10 e0       	ldi	r17, 0x00	; 0
    b9c6:	8a e5       	ldi	r24, 0x5A	; 90
    b9c8:	18 27       	eor	r17, r24
    b9ca:	01 2e       	mov	r0, r17
    b9cc:	02 94       	swap	r0
    b9ce:	80 2d       	mov	r24, r0
    b9d0:	8f 70       	andi	r24, 0x0F	; 15
    b9d2:	81 27       	eor	r24, r17
    b9d4:	91 2f       	mov	r25, r17
    b9d6:	90 25       	eor	r25, r0
    b9d8:	99 0f       	add	r25, r25
    b9da:	90 7e       	andi	r25, 0xE0	; 224
    b9dc:	89 27       	eor	r24, r25
    b9de:	90 2d       	mov	r25, r0
    b9e0:	91 27       	eor	r25, r17
    b9e2:	90 7f       	andi	r25, 0xF0	; 240
    b9e4:	96 95       	lsr	r25
    b9e6:	01 2e       	mov	r0, r17
    b9e8:	00 0c       	add	r0, r0
    b9ea:	99 1f       	adc	r25, r25
    b9ec:	16 95       	lsr	r17
    b9ee:	16 95       	lsr	r17
    b9f0:	16 95       	lsr	r17
    b9f2:	1f 71       	andi	r17, 0x1F	; 31
    b9f4:	19 27       	eor	r17, r25
    b9f6:	10 27       	eor	r17, r16
    b9f8:	08 2f       	mov	r16, r24

  // Wysyanie polecenia restartu
  crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    b9fa:	8a e5       	ldi	r24, 0x5A	; 90
    b9fc:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    ba00:	1b 25       	eor	r17, r11
    ba02:	01 2e       	mov	r0, r17
    ba04:	02 94       	swap	r0
    ba06:	80 2d       	mov	r24, r0
    ba08:	8f 70       	andi	r24, 0x0F	; 15
    ba0a:	81 27       	eor	r24, r17
    ba0c:	91 2f       	mov	r25, r17
    ba0e:	90 25       	eor	r25, r0
    ba10:	99 0f       	add	r25, r25
    ba12:	90 7e       	andi	r25, 0xE0	; 224
    ba14:	89 27       	eor	r24, r25
    ba16:	90 2d       	mov	r25, r0
    ba18:	91 27       	eor	r25, r17
    ba1a:	90 7f       	andi	r25, 0xF0	; 240
    ba1c:	96 95       	lsr	r25
    ba1e:	01 2e       	mov	r0, r17
    ba20:	00 0c       	add	r0, r0
    ba22:	99 1f       	adc	r25, r25
    ba24:	16 95       	lsr	r17
    ba26:	16 95       	lsr	r17
    ba28:	16 95       	lsr	r17
    ba2a:	1f 71       	andi	r17, 0x1F	; 31
    ba2c:	19 27       	eor	r17, r25
    ba2e:	10 27       	eor	r17, r16
    ba30:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    ba32:	8b 2d       	mov	r24, r11
    ba34:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    ba38:	81 e8       	ldi	r24, 0x81	; 129
    ba3a:	18 27       	eor	r17, r24
    ba3c:	01 2e       	mov	r0, r17
    ba3e:	02 94       	swap	r0
    ba40:	80 2d       	mov	r24, r0
    ba42:	8f 70       	andi	r24, 0x0F	; 15
    ba44:	81 27       	eor	r24, r17
    ba46:	91 2f       	mov	r25, r17
    ba48:	90 25       	eor	r25, r0
    ba4a:	99 0f       	add	r25, r25
    ba4c:	90 7e       	andi	r25, 0xE0	; 224
    ba4e:	89 27       	eor	r24, r25
    ba50:	90 2d       	mov	r25, r0
    ba52:	91 27       	eor	r25, r17
    ba54:	90 7f       	andi	r25, 0xF0	; 240
    ba56:	96 95       	lsr	r25
    ba58:	01 2e       	mov	r0, r17
    ba5a:	00 0c       	add	r0, r0
    ba5c:	99 1f       	adc	r25, r25
    ba5e:	16 95       	lsr	r17
    ba60:	16 95       	lsr	r17
    ba62:	16 95       	lsr	r17
    ba64:	1f 71       	andi	r17, 0x1F	; 31
    ba66:	19 27       	eor	r17, r25
    ba68:	10 27       	eor	r17, r16
    ba6a:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    ba6c:	81 e8       	ldi	r24, 0x81	; 129
    ba6e:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    ba72:	81 e0       	ldi	r24, 0x01	; 1
    ba74:	18 27       	eor	r17, r24
    ba76:	01 2e       	mov	r0, r17
    ba78:	02 94       	swap	r0
    ba7a:	80 2d       	mov	r24, r0
    ba7c:	8f 70       	andi	r24, 0x0F	; 15
    ba7e:	81 27       	eor	r24, r17
    ba80:	91 2f       	mov	r25, r17
    ba82:	90 25       	eor	r25, r0
    ba84:	99 0f       	add	r25, r25
    ba86:	90 7e       	andi	r25, 0xE0	; 224
    ba88:	89 27       	eor	r24, r25
    ba8a:	90 2d       	mov	r25, r0
    ba8c:	91 27       	eor	r25, r17
    ba8e:	90 7f       	andi	r25, 0xF0	; 240
    ba90:	96 95       	lsr	r25
    ba92:	01 2e       	mov	r0, r17
    ba94:	00 0c       	add	r0, r0
    ba96:	99 1f       	adc	r25, r25
    ba98:	16 95       	lsr	r17
    ba9a:	16 95       	lsr	r17
    ba9c:	16 95       	lsr	r17
    ba9e:	1f 71       	andi	r17, 0x1F	; 31
    baa0:	19 27       	eor	r17, r25
    baa2:	10 27       	eor	r17, r16
    baa4:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    baa6:	81 e0       	ldi	r24, 0x01	; 1
    baa8:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    baac:	1b 25       	eor	r17, r11
    baae:	01 2e       	mov	r0, r17
    bab0:	02 94       	swap	r0
    bab2:	80 2d       	mov	r24, r0
    bab4:	8f 70       	andi	r24, 0x0F	; 15
    bab6:	81 27       	eor	r24, r17
    bab8:	91 2f       	mov	r25, r17
    baba:	90 25       	eor	r25, r0
    babc:	99 0f       	add	r25, r25
    babe:	90 7e       	andi	r25, 0xE0	; 224
    bac0:	89 27       	eor	r24, r25
    bac2:	90 2d       	mov	r25, r0
    bac4:	91 27       	eor	r25, r17
    bac6:	90 7f       	andi	r25, 0xF0	; 240
    bac8:	96 95       	lsr	r25
    baca:	01 2e       	mov	r0, r17
    bacc:	00 0c       	add	r0, r0
    bace:	99 1f       	adc	r25, r25
    bad0:	16 95       	lsr	r17
    bad2:	16 95       	lsr	r17
    bad4:	16 95       	lsr	r17
    bad6:	1f 71       	andi	r17, 0x1F	; 31
    bad8:	19 27       	eor	r17, r25
    bada:	10 27       	eor	r17, r16
    badc:	08 2f       	mov	r16, r24
  crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    bade:	8b 2d       	mov	r24, r11
    bae0:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc>>8));
    bae4:	81 2f       	mov	r24, r17
    bae6:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    baea:	80 2f       	mov	r24, r16
    baec:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
 

  // Odbieranie odpowiedzi po wysaniu polecenia restartu
  //Odbieranie SYNC lub C
  if(rs485Receive(&data, 100) != pdTRUE)
    baf0:	ce 01       	movw	r24, r28
    baf2:	01 96       	adiw	r24, 0x01	; 1
    baf4:	64 e6       	ldi	r22, 0x64	; 100
    baf6:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bafa:	81 30       	cpi	r24, 0x01	; 1
    bafc:	11 f4       	brne	.+4      	; 0xbb02 <rs485xModemFlash+0x16c>
    bafe:	10 e0       	ldi	r17, 0x00	; 0
    bb00:	1a c0       	rjmp	.+52     	; 0xbb36 <rs485xModemFlash+0x1a0>
  {
    blad = 1;                                  // Timeout
    if (debugStr != NULL)
    bb02:	c1 14       	cp	r12, r1
    bb04:	d1 04       	cpc	r13, r1
    bb06:	11 f4       	brne	.+4      	; 0xbb0c <rs485xModemFlash+0x176>
    bb08:	11 e0       	ldi	r17, 0x01	; 1
    bb0a:	15 c0       	rjmp	.+42     	; 0xbb36 <rs485xModemFlash+0x1a0>
      fprintf_P(debugStr, PSTR("rFLASH timeout\r\n"));
    bb0c:	00 d0       	rcall	.+0      	; 0xbb0e <rs485xModemFlash+0x178>
    bb0e:	00 d0       	rcall	.+0      	; 0xbb10 <rs485xModemFlash+0x17a>
    bb10:	ad b7       	in	r26, 0x3d	; 61
    bb12:	be b7       	in	r27, 0x3e	; 62
    bb14:	12 96       	adiw	r26, 0x02	; 2
    bb16:	dc 92       	st	X, r13
    bb18:	ce 92       	st	-X, r12
    bb1a:	11 97       	sbiw	r26, 0x01	; 1
    bb1c:	8f e2       	ldi	r24, 0x2F	; 47
    bb1e:	9f e1       	ldi	r25, 0x1F	; 31
    bb20:	14 96       	adiw	r26, 0x04	; 4
    bb22:	9c 93       	st	X, r25
    bb24:	8e 93       	st	-X, r24
    bb26:	13 97       	sbiw	r26, 0x03	; 3
    bb28:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    bb2c:	11 e0       	ldi	r17, 0x01	; 1
    bb2e:	0f 90       	pop	r0
    bb30:	0f 90       	pop	r0
    bb32:	0f 90       	pop	r0
    bb34:	0f 90       	pop	r0
  }
  crc = _crc_xmodem_update(0, data);
    bb36:	89 81       	ldd	r24, Y+1	; 0x01
    bb38:	ee 24       	eor	r14, r14
    bb3a:	ff 24       	eor	r15, r15
    bb3c:	f7 01       	movw	r30, r14
    bb3e:	f8 27       	eor	r31, r24
    bb40:	0f 2e       	mov	r0, r31
    bb42:	02 94       	swap	r0
    bb44:	90 2d       	mov	r25, r0
    bb46:	9f 70       	andi	r25, 0x0F	; 15
    bb48:	9f 27       	eor	r25, r31
    bb4a:	2f 2f       	mov	r18, r31
    bb4c:	20 25       	eor	r18, r0
    bb4e:	22 0f       	add	r18, r18
    bb50:	20 7e       	andi	r18, 0xE0	; 224
    bb52:	92 27       	eor	r25, r18
    bb54:	20 2d       	mov	r18, r0
    bb56:	2f 27       	eor	r18, r31
    bb58:	20 7f       	andi	r18, 0xF0	; 240
    bb5a:	26 95       	lsr	r18
    bb5c:	0f 2e       	mov	r0, r31
    bb5e:	00 0c       	add	r0, r0
    bb60:	22 1f       	adc	r18, r18
    bb62:	f6 95       	lsr	r31
    bb64:	f6 95       	lsr	r31
    bb66:	f6 95       	lsr	r31
    bb68:	ff 71       	andi	r31, 0x1F	; 31
    bb6a:	f2 27       	eor	r31, r18
    bb6c:	fe 27       	eor	r31, r30
    bb6e:	e9 2f       	mov	r30, r25
    bb70:	7f 01       	movw	r14, r30
 
  if ((blad == 0) && (data == 'C'))
    bb72:	11 23       	and	r17, r17
    bb74:	d9 f4       	brne	.+54     	; 0xbbac <rs485xModemFlash+0x216>
    bb76:	83 34       	cpi	r24, 0x43	; 67
    bb78:	c9 f4       	brne	.+50     	; 0xbbac <rs485xModemFlash+0x216>
  {
    blad = 253;                                //Na urzdzeniu jest wgrany tylko bootloader
    if (debugStr != NULL)
    bb7a:	c1 14       	cp	r12, r1
    bb7c:	d1 04       	cpc	r13, r1
    bb7e:	09 f4       	brne	.+2      	; 0xbb82 <rs485xModemFlash+0x1ec>
    bb80:	87 c1       	rjmp	.+782    	; 0xbe90 <rs485xModemFlash+0x4fa>
      fprintf_P(debugStr, PSTR("na urzadzeniu wgrany jest tylko bootloader\r\n"));    
    bb82:	00 d0       	rcall	.+0      	; 0xbb84 <rs485xModemFlash+0x1ee>
    bb84:	00 d0       	rcall	.+0      	; 0xbb86 <rs485xModemFlash+0x1f0>
    bb86:	ad b7       	in	r26, 0x3d	; 61
    bb88:	be b7       	in	r27, 0x3e	; 62
    bb8a:	12 96       	adiw	r26, 0x02	; 2
    bb8c:	dc 92       	st	X, r13
    bb8e:	ce 92       	st	-X, r12
    bb90:	11 97       	sbiw	r26, 0x01	; 1
    bb92:	82 e0       	ldi	r24, 0x02	; 2
    bb94:	9f e1       	ldi	r25, 0x1F	; 31
    bb96:	14 96       	adiw	r26, 0x04	; 4
    bb98:	9c 93       	st	X, r25
    bb9a:	8e 93       	st	-X, r24
    bb9c:	13 97       	sbiw	r26, 0x03	; 3
    bb9e:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    bba2:	0f 90       	pop	r0
    bba4:	0f 90       	pop	r0
    bba6:	0f 90       	pop	r0
    bba8:	0f 90       	pop	r0
    bbaa:	72 c1       	rjmp	.+740    	; 0xbe90 <rs485xModemFlash+0x4fa>
  }
  else
  {
    if (data != SYNC)
    bbac:	8a 35       	cpi	r24, 0x5A	; 90
    bbae:	09 f0       	breq	.+2      	; 0xbbb2 <rs485xModemFlash+0x21c>
    bbb0:	c7 c0       	rjmp	.+398    	; 0xbd40 <rs485xModemFlash+0x3aa>
      blad = 2;
  }
 
  //Odbieranie odpowiedzi programu. Program zresetuje si by uruchomi bootloadera.
  //Odbieranie adresu
  if (blad == 0)  //Odbieranie adresu (powinno by 0)
    bbb2:	11 23       	and	r17, r17
    bbb4:	09 f0       	breq	.+2      	; 0xbbb8 <rs485xModemFlash+0x222>
    bbb6:	c4 c0       	rjmp	.+392    	; 0xbd40 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    bbb8:	ce 01       	movw	r24, r28
    bbba:	01 96       	adiw	r24, 0x01	; 1
    bbbc:	61 e0       	ldi	r22, 0x01	; 1
    bbbe:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bbc2:	81 30       	cpi	r24, 0x01	; 1
    bbc4:	11 f0       	breq	.+4      	; 0xbbca <rs485xModemFlash+0x234>
    bbc6:	13 e0       	ldi	r17, 0x03	; 3
    bbc8:	03 c0       	rjmp	.+6      	; 0xbbd0 <rs485xModemFlash+0x23a>
      blad = 3;
    else
    {
      if (data != 0)
    bbca:	89 81       	ldd	r24, Y+1	; 0x01
    bbcc:	81 11       	cpse	r24, r1
    bbce:	14 e0       	ldi	r17, 0x04	; 4
    bbd0:	89 81       	ldd	r24, Y+1	; 0x01
    bbd2:	f7 01       	movw	r30, r14
    bbd4:	f8 27       	eor	r31, r24
    bbd6:	0f 2e       	mov	r0, r31
    bbd8:	02 94       	swap	r0
    bbda:	80 2d       	mov	r24, r0
    bbdc:	8f 70       	andi	r24, 0x0F	; 15
    bbde:	8f 27       	eor	r24, r31
    bbe0:	9f 2f       	mov	r25, r31
    bbe2:	90 25       	eor	r25, r0
    bbe4:	99 0f       	add	r25, r25
    bbe6:	90 7e       	andi	r25, 0xE0	; 224
    bbe8:	89 27       	eor	r24, r25
    bbea:	90 2d       	mov	r25, r0
    bbec:	9f 27       	eor	r25, r31
    bbee:	90 7f       	andi	r25, 0xF0	; 240
    bbf0:	96 95       	lsr	r25
    bbf2:	0f 2e       	mov	r0, r31
    bbf4:	00 0c       	add	r0, r0
    bbf6:	99 1f       	adc	r25, r25
    bbf8:	f6 95       	lsr	r31
    bbfa:	f6 95       	lsr	r31
    bbfc:	f6 95       	lsr	r31
    bbfe:	ff 71       	andi	r31, 0x1F	; 31
    bc00:	f9 27       	eor	r31, r25
    bc02:	fe 27       	eor	r31, r30
    bc04:	e8 2f       	mov	r30, r24
    bc06:	7f 01       	movw	r14, r30
    }
    crc = _crc_xmodem_update(crc, data);
  }
   
  //Odbieranie kodu rozkazu
  if (blad == 0)
    bc08:	11 23       	and	r17, r17
    bc0a:	09 f0       	breq	.+2      	; 0xbc0e <rs485xModemFlash+0x278>
    bc0c:	99 c0       	rjmp	.+306    	; 0xbd40 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    bc0e:	ce 01       	movw	r24, r28
    bc10:	01 96       	adiw	r24, 0x01	; 1
    bc12:	61 e0       	ldi	r22, 0x01	; 1
    bc14:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bc18:	81 30       	cpi	r24, 0x01	; 1
    bc1a:	11 f0       	breq	.+4      	; 0xbc20 <rs485xModemFlash+0x28a>
    bc1c:	15 e0       	ldi	r17, 0x05	; 5
    bc1e:	04 c0       	rjmp	.+8      	; 0xbc28 <rs485xModemFlash+0x292>
      blad = 5;
    else
    {
      if (data != rFLASH)
    bc20:	89 81       	ldd	r24, Y+1	; 0x01
    bc22:	81 38       	cpi	r24, 0x81	; 129
    bc24:	09 f0       	breq	.+2      	; 0xbc28 <rs485xModemFlash+0x292>
    bc26:	16 e0       	ldi	r17, 0x06	; 6
    bc28:	89 81       	ldd	r24, Y+1	; 0x01
    bc2a:	97 01       	movw	r18, r14
    bc2c:	38 27       	eor	r19, r24
    bc2e:	03 2e       	mov	r0, r19
    bc30:	02 94       	swap	r0
    bc32:	80 2d       	mov	r24, r0
    bc34:	8f 70       	andi	r24, 0x0F	; 15
    bc36:	83 27       	eor	r24, r19
    bc38:	93 2f       	mov	r25, r19
    bc3a:	90 25       	eor	r25, r0
    bc3c:	99 0f       	add	r25, r25
    bc3e:	90 7e       	andi	r25, 0xE0	; 224
    bc40:	89 27       	eor	r24, r25
    bc42:	90 2d       	mov	r25, r0
    bc44:	93 27       	eor	r25, r19
    bc46:	90 7f       	andi	r25, 0xF0	; 240
    bc48:	96 95       	lsr	r25
    bc4a:	03 2e       	mov	r0, r19
    bc4c:	00 0c       	add	r0, r0
    bc4e:	99 1f       	adc	r25, r25
    bc50:	36 95       	lsr	r19
    bc52:	36 95       	lsr	r19
    bc54:	36 95       	lsr	r19
    bc56:	3f 71       	andi	r19, 0x1F	; 31
    bc58:	39 27       	eor	r19, r25
    bc5a:	32 27       	eor	r19, r18
    bc5c:	28 2f       	mov	r18, r24
    bc5e:	79 01       	movw	r14, r18
    }
    crc = _crc_xmodem_update(crc, data);
  }
 
  //Odbieranie dugoci danych w rozkazie
  if (blad == 0)
    bc60:	11 23       	and	r17, r17
    bc62:	09 f0       	breq	.+2      	; 0xbc66 <rs485xModemFlash+0x2d0>
    bc64:	6d c0       	rjmp	.+218    	; 0xbd40 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    bc66:	ce 01       	movw	r24, r28
    bc68:	01 96       	adiw	r24, 0x01	; 1
    bc6a:	61 e0       	ldi	r22, 0x01	; 1
    bc6c:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bc70:	81 30       	cpi	r24, 0x01	; 1
    bc72:	11 f0       	breq	.+4      	; 0xbc78 <rs485xModemFlash+0x2e2>
    bc74:	17 e0       	ldi	r17, 0x07	; 7
    bc76:	04 c0       	rjmp	.+8      	; 0xbc80 <rs485xModemFlash+0x2ea>
      blad = 7;
    else
    {
      if (data != 1)
    bc78:	89 81       	ldd	r24, Y+1	; 0x01
    bc7a:	81 30       	cpi	r24, 0x01	; 1
    bc7c:	09 f0       	breq	.+2      	; 0xbc80 <rs485xModemFlash+0x2ea>
    bc7e:	18 e0       	ldi	r17, 0x08	; 8
    bc80:	89 81       	ldd	r24, Y+1	; 0x01
    bc82:	a7 01       	movw	r20, r14
    bc84:	58 27       	eor	r21, r24
    bc86:	05 2e       	mov	r0, r21
    bc88:	02 94       	swap	r0
    bc8a:	80 2d       	mov	r24, r0
    bc8c:	8f 70       	andi	r24, 0x0F	; 15
    bc8e:	85 27       	eor	r24, r21
    bc90:	95 2f       	mov	r25, r21
    bc92:	90 25       	eor	r25, r0
    bc94:	99 0f       	add	r25, r25
    bc96:	90 7e       	andi	r25, 0xE0	; 224
    bc98:	89 27       	eor	r24, r25
    bc9a:	90 2d       	mov	r25, r0
    bc9c:	95 27       	eor	r25, r21
    bc9e:	90 7f       	andi	r25, 0xF0	; 240
    bca0:	96 95       	lsr	r25
    bca2:	05 2e       	mov	r0, r21
    bca4:	00 0c       	add	r0, r0
    bca6:	99 1f       	adc	r25, r25
    bca8:	56 95       	lsr	r21
    bcaa:	56 95       	lsr	r21
    bcac:	56 95       	lsr	r21
    bcae:	5f 71       	andi	r21, 0x1F	; 31
    bcb0:	59 27       	eor	r21, r25
    bcb2:	54 27       	eor	r21, r20
    bcb4:	48 2f       	mov	r20, r24
    bcb6:	7a 01       	movw	r14, r20
    }
    crc = _crc_xmodem_update(crc, data);
  }
 
  //Odbieranie danych w rozkazie
  if (blad == 0)
    bcb8:	11 23       	and	r17, r17
    bcba:	09 f0       	breq	.+2      	; 0xbcbe <rs485xModemFlash+0x328>
    bcbc:	41 c0       	rjmp	.+130    	; 0xbd40 <rs485xModemFlash+0x3aa>
  {
    if(rs485Receive(&data, 1) != pdTRUE)
    bcbe:	ce 01       	movw	r24, r28
    bcc0:	01 96       	adiw	r24, 0x01	; 1
    bcc2:	61 e0       	ldi	r22, 0x01	; 1
    bcc4:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bcc8:	81 30       	cpi	r24, 0x01	; 1
    bcca:	11 f0       	breq	.+4      	; 0xbcd0 <rs485xModemFlash+0x33a>
    bccc:	19 e0       	ldi	r17, 0x09	; 9
    bcce:	03 c0       	rjmp	.+6      	; 0xbcd6 <rs485xModemFlash+0x340>
      blad = 9;
    else
    {
      if (data != devAddr)
    bcd0:	89 81       	ldd	r24, Y+1	; 0x01
    bcd2:	8b 11       	cpse	r24, r11
    bcd4:	1a e0       	ldi	r17, 0x0A	; 10
    bcd6:	89 81       	ldd	r24, Y+1	; 0x01
    bcd8:	d7 01       	movw	r26, r14
    bcda:	b8 27       	eor	r27, r24
    bcdc:	0b 2e       	mov	r0, r27
    bcde:	02 94       	swap	r0
    bce0:	80 2d       	mov	r24, r0
    bce2:	8f 70       	andi	r24, 0x0F	; 15
    bce4:	8b 27       	eor	r24, r27
    bce6:	9b 2f       	mov	r25, r27
    bce8:	90 25       	eor	r25, r0
    bcea:	99 0f       	add	r25, r25
    bcec:	90 7e       	andi	r25, 0xE0	; 224
    bcee:	89 27       	eor	r24, r25
    bcf0:	90 2d       	mov	r25, r0
    bcf2:	9b 27       	eor	r25, r27
    bcf4:	90 7f       	andi	r25, 0xF0	; 240
    bcf6:	96 95       	lsr	r25
    bcf8:	0b 2e       	mov	r0, r27
    bcfa:	00 0c       	add	r0, r0
    bcfc:	99 1f       	adc	r25, r25
    bcfe:	b6 95       	lsr	r27
    bd00:	b6 95       	lsr	r27
    bd02:	b6 95       	lsr	r27
    bd04:	bf 71       	andi	r27, 0x1F	; 31
    bd06:	b9 27       	eor	r27, r25
    bd08:	ba 27       	eor	r27, r26
    bd0a:	a8 2f       	mov	r26, r24
    bd0c:	7d 01       	movw	r14, r26
    }
    crc = _crc_xmodem_update(crc, data);
  }
   
  //Odbieranie CRC Hi
  if (blad == 0)
    bd0e:	11 23       	and	r17, r17
    bd10:	b9 f4       	brne	.+46     	; 0xbd40 <rs485xModemFlash+0x3aa>
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    bd12:	8e 01       	movw	r16, r28
    bd14:	0e 5f       	subi	r16, 0xFE	; 254
    bd16:	1f 4f       	sbci	r17, 0xFF	; 255
    bd18:	c8 01       	movw	r24, r16
    bd1a:	61 e0       	ldi	r22, 0x01	; 1
    bd1c:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bd20:	81 30       	cpi	r24, 0x01	; 1
    bd22:	71 f4       	brne	.+28     	; 0xbd40 <rs485xModemFlash+0x3aa>
      blad = 11;
    else
    {
      if ((uint8_t)(crc>>8) != nrBloku)
    bd24:	8a 81       	ldd	r24, Y+2	; 0x02
    bd26:	8f 15       	cp	r24, r15
    bd28:	59 f4       	brne	.+22     	; 0xbd40 <rs485xModemFlash+0x3aa>
  }
   
  //Odbieranie CRC Lo
  if (blad == 0)
  {
    if (rs485Receive(&nrBloku, 1) != pdTRUE)
    bd2a:	c8 01       	movw	r24, r16
    bd2c:	61 e0       	ldi	r22, 0x01	; 1
    bd2e:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bd32:	a8 2e       	mov	r10, r24
    bd34:	b1 e0       	ldi	r27, 0x01	; 1
    bd36:	8b 17       	cp	r24, r27
    bd38:	19 f4       	brne	.+6      	; 0xbd40 <rs485xModemFlash+0x3aa>
      blad = 13;
    else
    {
      if ((uint8_t)(crc & 0xFF) != nrBloku)
    bd3a:	8a 81       	ldd	r24, Y+2	; 0x02
    bd3c:	8e 15       	cp	r24, r14
    bd3e:	29 f0       	breq	.+10     	; 0xbd4a <rs485xModemFlash+0x3b4>
    }    
  }
   
  if ((blad != 0) && (blad != 253))
  {
    releaseRs485();
    bd40:	0e 94 49 11 	call	0x2292	; 0x2292 <releaseRs485>
    flushRs485RecBuffer();  
    bd44:	0e 94 01 12 	call	0x2402	; 0x2402 <flushRs485RecBuffer>
    bd48:	78 c1       	rjmp	.+752    	; 0xc03a <rs485xModemFlash+0x6a4>
  }

// Wysyanie polecenia do bootloadera
  if (blad == 0)
  {
    vTaskDelay(100);
    bd4a:	84 e6       	ldi	r24, 0x64	; 100
    bd4c:	90 e0       	ldi	r25, 0x00	; 0
    bd4e:	0e 94 d6 68 	call	0xd1ac	; 0xd1ac <vTaskDelay>
    bd52:	00 e0       	ldi	r16, 0x00	; 0
    bd54:	10 e0       	ldi	r17, 0x00	; 0
    bd56:	8a e5       	ldi	r24, 0x5A	; 90
    bd58:	18 27       	eor	r17, r24
    bd5a:	01 2e       	mov	r0, r17
    bd5c:	02 94       	swap	r0
    bd5e:	80 2d       	mov	r24, r0
    bd60:	8f 70       	andi	r24, 0x0F	; 15
    bd62:	81 27       	eor	r24, r17
    bd64:	91 2f       	mov	r25, r17
    bd66:	90 25       	eor	r25, r0
    bd68:	99 0f       	add	r25, r25
    bd6a:	90 7e       	andi	r25, 0xE0	; 224
    bd6c:	89 27       	eor	r24, r25
    bd6e:	90 2d       	mov	r25, r0
    bd70:	91 27       	eor	r25, r17
    bd72:	90 7f       	andi	r25, 0xF0	; 240
    bd74:	96 95       	lsr	r25
    bd76:	01 2e       	mov	r0, r17
    bd78:	00 0c       	add	r0, r0
    bd7a:	99 1f       	adc	r25, r25
    bd7c:	16 95       	lsr	r17
    bd7e:	16 95       	lsr	r17
    bd80:	16 95       	lsr	r17
    bd82:	1f 71       	andi	r17, 0x1F	; 31
    bd84:	19 27       	eor	r17, r25
    bd86:	10 27       	eor	r17, r16
    bd88:	08 2f       	mov	r16, r24
     
    crc = _crc_xmodem_update(0, SYNC);            uartRs485SendByte(SYNC);
    bd8a:	8a e5       	ldi	r24, 0x5A	; 90
    bd8c:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    bd90:	1b 25       	eor	r17, r11
    bd92:	01 2e       	mov	r0, r17
    bd94:	02 94       	swap	r0
    bd96:	80 2d       	mov	r24, r0
    bd98:	8f 70       	andi	r24, 0x0F	; 15
    bd9a:	81 27       	eor	r24, r17
    bd9c:	91 2f       	mov	r25, r17
    bd9e:	90 25       	eor	r25, r0
    bda0:	99 0f       	add	r25, r25
    bda2:	90 7e       	andi	r25, 0xE0	; 224
    bda4:	89 27       	eor	r24, r25
    bda6:	90 2d       	mov	r25, r0
    bda8:	91 27       	eor	r25, r17
    bdaa:	90 7f       	andi	r25, 0xF0	; 240
    bdac:	96 95       	lsr	r25
    bdae:	01 2e       	mov	r0, r17
    bdb0:	00 0c       	add	r0, r0
    bdb2:	99 1f       	adc	r25, r25
    bdb4:	16 95       	lsr	r17
    bdb6:	16 95       	lsr	r17
    bdb8:	16 95       	lsr	r17
    bdba:	1f 71       	andi	r17, 0x1F	; 31
    bdbc:	19 27       	eor	r17, r25
    bdbe:	10 27       	eor	r17, r16
    bdc0:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    bdc2:	8b 2d       	mov	r24, r11
    bdc4:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    bdc8:	81 e8       	ldi	r24, 0x81	; 129
    bdca:	18 27       	eor	r17, r24
    bdcc:	01 2e       	mov	r0, r17
    bdce:	02 94       	swap	r0
    bdd0:	80 2d       	mov	r24, r0
    bdd2:	8f 70       	andi	r24, 0x0F	; 15
    bdd4:	81 27       	eor	r24, r17
    bdd6:	91 2f       	mov	r25, r17
    bdd8:	90 25       	eor	r25, r0
    bdda:	99 0f       	add	r25, r25
    bddc:	90 7e       	andi	r25, 0xE0	; 224
    bdde:	89 27       	eor	r24, r25
    bde0:	90 2d       	mov	r25, r0
    bde2:	91 27       	eor	r25, r17
    bde4:	90 7f       	andi	r25, 0xF0	; 240
    bde6:	96 95       	lsr	r25
    bde8:	01 2e       	mov	r0, r17
    bdea:	00 0c       	add	r0, r0
    bdec:	99 1f       	adc	r25, r25
    bdee:	16 95       	lsr	r17
    bdf0:	16 95       	lsr	r17
    bdf2:	16 95       	lsr	r17
    bdf4:	1f 71       	andi	r17, 0x1F	; 31
    bdf6:	19 27       	eor	r17, r25
    bdf8:	10 27       	eor	r17, r16
    bdfa:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, rFLASH);        uartRs485SendByte(rFLASH);
    bdfc:	81 e8       	ldi	r24, 0x81	; 129
    bdfe:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    be02:	1a 25       	eor	r17, r10
    be04:	01 2e       	mov	r0, r17
    be06:	02 94       	swap	r0
    be08:	80 2d       	mov	r24, r0
    be0a:	8f 70       	andi	r24, 0x0F	; 15
    be0c:	81 27       	eor	r24, r17
    be0e:	91 2f       	mov	r25, r17
    be10:	90 25       	eor	r25, r0
    be12:	99 0f       	add	r25, r25
    be14:	90 7e       	andi	r25, 0xE0	; 224
    be16:	89 27       	eor	r24, r25
    be18:	90 2d       	mov	r25, r0
    be1a:	91 27       	eor	r25, r17
    be1c:	90 7f       	andi	r25, 0xF0	; 240
    be1e:	96 95       	lsr	r25
    be20:	01 2e       	mov	r0, r17
    be22:	00 0c       	add	r0, r0
    be24:	99 1f       	adc	r25, r25
    be26:	16 95       	lsr	r17
    be28:	16 95       	lsr	r17
    be2a:	16 95       	lsr	r17
    be2c:	1f 71       	andi	r17, 0x1F	; 31
    be2e:	19 27       	eor	r17, r25
    be30:	10 27       	eor	r17, r16
    be32:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, 1);             uartRs485SendByte(1);
    be34:	81 e0       	ldi	r24, 0x01	; 1
    be36:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    be3a:	1b 25       	eor	r17, r11
    be3c:	01 2e       	mov	r0, r17
    be3e:	02 94       	swap	r0
    be40:	80 2d       	mov	r24, r0
    be42:	8f 70       	andi	r24, 0x0F	; 15
    be44:	81 27       	eor	r24, r17
    be46:	91 2f       	mov	r25, r17
    be48:	90 25       	eor	r25, r0
    be4a:	99 0f       	add	r25, r25
    be4c:	90 7e       	andi	r25, 0xE0	; 224
    be4e:	89 27       	eor	r24, r25
    be50:	90 2d       	mov	r25, r0
    be52:	91 27       	eor	r25, r17
    be54:	90 7f       	andi	r25, 0xF0	; 240
    be56:	96 95       	lsr	r25
    be58:	01 2e       	mov	r0, r17
    be5a:	00 0c       	add	r0, r0
    be5c:	99 1f       	adc	r25, r25
    be5e:	16 95       	lsr	r17
    be60:	16 95       	lsr	r17
    be62:	16 95       	lsr	r17
    be64:	1f 71       	andi	r17, 0x1F	; 31
    be66:	19 27       	eor	r17, r25
    be68:	10 27       	eor	r17, r16
    be6a:	08 2f       	mov	r16, r24
    crc = _crc_xmodem_update(crc, devAddr);       uartRs485SendByte(devAddr);
    be6c:	8b 2d       	mov	r24, r11
    be6e:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc>>8));
    be72:	81 2f       	mov	r24, r17
    be74:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    be78:	80 2f       	mov	r24, r16
    be7a:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
 
    //Odbieranie odpowiedzi od Bootloadera
    if(rs485Receive(&data, 150) != pdTRUE)
    be7e:	ce 01       	movw	r24, r28
    be80:	01 96       	adiw	r24, 0x01	; 1
    be82:	66 e9       	ldi	r22, 0x96	; 150
    be84:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
      blad = 15;

    if (data != 'C')
    be88:	89 81       	ldd	r24, Y+1	; 0x01
    be8a:	83 34       	cpi	r24, 0x43	; 67
    be8c:	09 f0       	breq	.+2      	; 0xbe90 <rs485xModemFlash+0x4fa>
    be8e:	cd c0       	rjmp	.+410    	; 0xc02a <rs485xModemFlash+0x694>
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
    be90:	d3 01       	movw	r26, r6
    be92:	14 96       	adiw	r26, 0x04	; 4
    be94:	ed 91       	ld	r30, X+
    be96:	fc 91       	ld	r31, X
    be98:	15 97       	sbiw	r26, 0x05	; 5
    be9a:	b2 80       	ldd	r11, Z+2	; 0x02
    be9c:	bb 0c       	add	r11, r11
  if (file->wpis->rozmiarLo == 128)
    be9e:	81 81       	ldd	r24, Z+1	; 0x01
    bea0:	80 38       	cpi	r24, 0x80	; 128
    bea2:	a1 f4       	brne	.+40     	; 0xbecc <rs485xModemFlash+0x536>
    bea4:	12 c0       	rjmp	.+36     	; 0xbeca <rs485xModemFlash+0x534>
  if (blad != 0)
  {
    releaseRs485();
    flushRs485RecBuffer();  
    if (debugStr != NULL)
      fprintf_P(debugStr, PSTR("bootloader nie rozpoczal odbioru danych\r\n"));     
    bea6:	00 d0       	rcall	.+0      	; 0xbea8 <rs485xModemFlash+0x512>
    bea8:	00 d0       	rcall	.+0      	; 0xbeaa <rs485xModemFlash+0x514>
    beaa:	ed b7       	in	r30, 0x3d	; 61
    beac:	fe b7       	in	r31, 0x3e	; 62
    beae:	d2 82       	std	Z+2, r13	; 0x02
    beb0:	c1 82       	std	Z+1, r12	; 0x01
    beb2:	88 ed       	ldi	r24, 0xD8	; 216
    beb4:	9e e1       	ldi	r25, 0x1E	; 30
    beb6:	94 83       	std	Z+4, r25	; 0x04
    beb8:	83 83       	std	Z+3, r24	; 0x03
    beba:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    bebe:	81 e0       	ldi	r24, 0x01	; 1
    bec0:	0f 90       	pop	r0
    bec2:	0f 90       	pop	r0
    bec4:	0f 90       	pop	r0
    bec6:	0f 90       	pop	r0
    bec8:	9f c0       	rjmp	.+318    	; 0xc008 <rs485xModemFlash+0x672>
    return 1;
  }
 
  uint8_t liczbaBlokow = file->wpis->rozmiarHi * 2;
  if (file->wpis->rozmiarLo == 128)
    liczbaBlokow++;
    beca:	b3 94       	inc	r11
   
  nrBloku = 1;
    becc:	81 e0       	ldi	r24, 0x01	; 1
    bece:	8a 83       	std	Y+2, r24	; 0x02
    bed0:	ee 24       	eor	r14, r14
    bed2:	ff 24       	eor	r15, r15
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    bed4:	4e 01       	movw	r8, r28
    bed6:	08 94       	sec
    bed8:	81 1c       	adc	r8, r1
    beda:	91 1c       	adc	r9, r1
    bedc:	5d c0       	rjmp	.+186    	; 0xbf98 <rs485xModemFlash+0x602>
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
  {
    if (debugStr != NULL)
    bede:	c1 14       	cp	r12, r1
    bee0:	d1 04       	cpc	r13, r1
    bee2:	29 f0       	breq	.+10     	; 0xbeee <rs485xModemFlash+0x558>
      fputc('#', debugStr);
    bee4:	83 e2       	ldi	r24, 0x23	; 35
    bee6:	90 e0       	ldi	r25, 0x00	; 0
    bee8:	b6 01       	movw	r22, r12
    beea:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    crc = 0;
    uartRs485SendByte(SOH);
    beee:	81 e0       	ldi	r24, 0x01	; 1
    bef0:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    uartRs485SendByte(nrBloku);
    bef4:	8a 81       	ldd	r24, Y+2	; 0x02
    bef6:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    data = (uint8_t)(~nrBloku);
    befa:	8a 81       	ldd	r24, Y+2	; 0x02
    befc:	80 95       	com	r24
    befe:	89 83       	std	Y+1, r24	; 0x01
    uartRs485SendByte(data);
    bf00:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    bf04:	00 e0       	ldi	r16, 0x00	; 0
    bf06:	10 e0       	ldi	r17, 0x00	; 0
    bf08:	ff 24       	eor	r15, r15
 
    for (blad = 0; blad < 128; blad++)           //wysyanie danych. Zmianna Blad jest tymczasowa
    {
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
    bf0a:	c3 01       	movw	r24, r6
    bf0c:	b4 01       	movw	r22, r8
    bf0e:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <ramDyskCzytajBajtZPliku>
    bf12:	81 11       	cpse	r24, r1
        data = 0;
    bf14:	19 82       	std	Y+1, r1	; 0x01
      crc = _crc_xmodem_update(crc, data);
    bf16:	89 81       	ldd	r24, Y+1	; 0x01
    bf18:	18 27       	eor	r17, r24
    bf1a:	01 2e       	mov	r0, r17
    bf1c:	02 94       	swap	r0
    bf1e:	90 2d       	mov	r25, r0
    bf20:	9f 70       	andi	r25, 0x0F	; 15
    bf22:	91 27       	eor	r25, r17
    bf24:	21 2f       	mov	r18, r17
    bf26:	20 25       	eor	r18, r0
    bf28:	22 0f       	add	r18, r18
    bf2a:	20 7e       	andi	r18, 0xE0	; 224
    bf2c:	92 27       	eor	r25, r18
    bf2e:	20 2d       	mov	r18, r0
    bf30:	21 27       	eor	r18, r17
    bf32:	20 7f       	andi	r18, 0xF0	; 240
    bf34:	26 95       	lsr	r18
    bf36:	01 2e       	mov	r0, r17
    bf38:	00 0c       	add	r0, r0
    bf3a:	22 1f       	adc	r18, r18
    bf3c:	16 95       	lsr	r17
    bf3e:	16 95       	lsr	r17
    bf40:	16 95       	lsr	r17
    bf42:	1f 71       	andi	r17, 0x1F	; 31
    bf44:	12 27       	eor	r17, r18
    bf46:	10 27       	eor	r17, r16
    bf48:	09 2f       	mov	r16, r25
      uartRs485SendByte(data);
    bf4a:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    uartRs485SendByte(SOH);
    uartRs485SendByte(nrBloku);
    data = (uint8_t)(~nrBloku);
    uartRs485SendByte(data);
 
    for (blad = 0; blad < 128; blad++)           //wysyanie danych. Zmianna Blad jest tymczasowa
    bf4e:	f3 94       	inc	r15
    bf50:	f0 e8       	ldi	r31, 0x80	; 128
    bf52:	ff 16       	cp	r15, r31
    bf54:	09 f0       	breq	.+2      	; 0xbf58 <rs485xModemFlash+0x5c2>
    bf56:	d9 cf       	rjmp	.-78     	; 0xbf0a <rs485xModemFlash+0x574>
      if (ramDyskCzytajBajtZPliku(file, &data) != 0)
        data = 0;
      crc = _crc_xmodem_update(crc, data);
      uartRs485SendByte(data);
    }
    uartRs485SendByte((uint8_t)(crc>>8));
    bf58:	81 2f       	mov	r24, r17
    bf5a:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    uartRs485SendByte((uint8_t)(crc & 0xFF));
    bf5e:	80 2f       	mov	r24, r16
    bf60:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
 
    if(rs485Receive(&data, 100) != pdTRUE)
    bf64:	c4 01       	movw	r24, r8
    bf66:	64 e6       	ldi	r22, 0x64	; 100
    bf68:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bf6c:	81 30       	cpi	r24, 0x01	; 1
    bf6e:	11 f0       	breq	.+4      	; 0xbf74 <rs485xModemFlash+0x5de>
    bf70:	3a ef       	ldi	r19, 0xFA	; 250
    bf72:	f3 2e       	mov	r15, r19
    {
      blad = 250;
    }
     
    flushRs485RecBuffer();
    bf74:	0e 94 01 12 	call	0x2402	; 0x2402 <flushRs485RecBuffer>

    if (data == ACK)
    bf78:	89 81       	ldd	r24, Y+1	; 0x01
    bf7a:	86 30       	cpi	r24, 0x06	; 6
    bf7c:	29 f4       	brne	.+10     	; 0xbf88 <rs485xModemFlash+0x5f2>
    {
      nrBloku ++;
    bf7e:	8a 81       	ldd	r24, Y+2	; 0x02
    bf80:	8f 5f       	subi	r24, 0xFF	; 255
    bf82:	8a 83       	std	Y+2, r24	; 0x02
    bf84:	ee 24       	eor	r14, r14
    bf86:	08 c0       	rjmp	.+16     	; 0xbf98 <rs485xModemFlash+0x602>
      lRetransmisji = 0;
      continue;
    }
 
    if (data == CAN)
    bf88:	88 31       	cpi	r24, 0x18	; 24
    bf8a:	11 f4       	brne	.+4      	; 0xbf90 <rs485xModemFlash+0x5fa>
    bf8c:	29 ef       	ldi	r18, 0xF9	; 249
    bf8e:	f2 2e       	mov	r15, r18
      blad = 249;
 
    lRetransmisji ++;
    bf90:	e3 94       	inc	r14
     
    if (lRetransmisji == 3)
    bf92:	23 e0       	ldi	r18, 0x03	; 3
    bf94:	e2 16       	cp	r14, r18
    bf96:	e1 f0       	breq	.+56     	; 0xbfd0 <rs485xModemFlash+0x63a>
    liczbaBlokow++;
   
  nrBloku = 1;
  lRetransmisji = 0;
   
  while (nrBloku <= liczbaBlokow)
    bf98:	8a 81       	ldd	r24, Y+2	; 0x02
    bf9a:	b8 16       	cp	r11, r24
    bf9c:	08 f0       	brcs	.+2      	; 0xbfa0 <rs485xModemFlash+0x60a>
    bf9e:	9f cf       	rjmp	.-194    	; 0xbede <rs485xModemFlash+0x548>
      blad = 249;
      break;
    }
  }
 
  if (blad == 0)
    bfa0:	ff 20       	and	r15, r15
    bfa2:	b1 f4       	brne	.+44     	; 0xbfd0 <rs485xModemFlash+0x63a>
  {
    uartRs485SendByte(EOT); 
    bfa4:	84 e0       	ldi	r24, 0x04	; 4
    bfa6:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    if(rs485Receive(&data, 25) == pdTRUE)
    bfaa:	8e 01       	movw	r16, r28
    bfac:	0f 5f       	subi	r16, 0xFF	; 255
    bfae:	1f 4f       	sbci	r17, 0xFF	; 255
    bfb0:	c8 01       	movw	r24, r16
    bfb2:	69 e1       	ldi	r22, 0x19	; 25
    bfb4:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    bfb8:	81 30       	cpi	r24, 0x01	; 1
    bfba:	51 f4       	brne	.+20     	; 0xbfd0 <rs485xModemFlash+0x63a>
    {
      if (data == ACK)
    bfbc:	89 81       	ldd	r24, Y+1	; 0x01
    bfbe:	86 30       	cpi	r24, 0x06	; 6
    bfc0:	39 f4       	brne	.+14     	; 0xbfd0 <rs485xModemFlash+0x63a>
      {
        uartRs485SendByte(EOT);
    bfc2:	84 e0       	ldi	r24, 0x04	; 4
    bfc4:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
        rs485Receive(&data, 25);
    bfc8:	c8 01       	movw	r24, r16
    bfca:	69 e1       	ldi	r22, 0x19	; 25
    bfcc:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
      }
    }
  }
  if (debugStr != NULL)
    bfd0:	c1 14       	cp	r12, r1
    bfd2:	d1 04       	cpc	r13, r1
    bfd4:	a1 f0       	breq	.+40     	; 0xbffe <rs485xModemFlash+0x668>
    fprintf_P(debugStr, PSTR("\r\nOK\r\n"));
    bfd6:	00 d0       	rcall	.+0      	; 0xbfd8 <rs485xModemFlash+0x642>
    bfd8:	00 d0       	rcall	.+0      	; 0xbfda <rs485xModemFlash+0x644>
    bfda:	ad b7       	in	r26, 0x3d	; 61
    bfdc:	be b7       	in	r27, 0x3e	; 62
    bfde:	12 96       	adiw	r26, 0x02	; 2
    bfe0:	dc 92       	st	X, r13
    bfe2:	ce 92       	st	-X, r12
    bfe4:	11 97       	sbiw	r26, 0x01	; 1
    bfe6:	81 ed       	ldi	r24, 0xD1	; 209
    bfe8:	9e e1       	ldi	r25, 0x1E	; 30
    bfea:	14 96       	adiw	r26, 0x04	; 4
    bfec:	9c 93       	st	X, r25
    bfee:	8e 93       	st	-X, r24
    bff0:	13 97       	sbiw	r26, 0x03	; 3
    bff2:	0e 94 17 75 	call	0xea2e	; 0xea2e <fprintf_P>
    bff6:	0f 90       	pop	r0
    bff8:	0f 90       	pop	r0
    bffa:	0f 90       	pop	r0
    bffc:	0f 90       	pop	r0

  flushRs485RecBuffer();  
    bffe:	0e 94 01 12 	call	0x2402	; 0x2402 <flushRs485RecBuffer>
  releaseRs485();
    c002:	0e 94 49 11 	call	0x2292	; 0x2292 <releaseRs485>
    c006:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    c008:	0f 90       	pop	r0
    c00a:	0f 90       	pop	r0
    c00c:	cf 91       	pop	r28
    c00e:	df 91       	pop	r29
    c010:	1f 91       	pop	r17
    c012:	0f 91       	pop	r16
    c014:	ff 90       	pop	r15
    c016:	ef 90       	pop	r14
    c018:	df 90       	pop	r13
    c01a:	cf 90       	pop	r12
    c01c:	bf 90       	pop	r11
    c01e:	af 90       	pop	r10
    c020:	9f 90       	pop	r9
    c022:	8f 90       	pop	r8
    c024:	7f 90       	pop	r7
    c026:	6f 90       	pop	r6
    c028:	08 95       	ret
    blad = 0;
  
   
  if (blad != 0)
  {
    releaseRs485();
    c02a:	0e 94 49 11 	call	0x2292	; 0x2292 <releaseRs485>
    flushRs485RecBuffer();  
    c02e:	0e 94 01 12 	call	0x2402	; 0x2402 <flushRs485RecBuffer>
    if (debugStr != NULL)
    c032:	c1 14       	cp	r12, r1
    c034:	d1 04       	cpc	r13, r1
    c036:	09 f0       	breq	.+2      	; 0xc03a <rs485xModemFlash+0x6a4>
    c038:	36 cf       	rjmp	.-404    	; 0xbea6 <rs485xModemFlash+0x510>
    c03a:	81 e0       	ldi	r24, 0x01	; 1
    c03c:	e5 cf       	rjmp	.-54     	; 0xc008 <rs485xModemFlash+0x672>

0000c03e <rs485ping>:
  return result;
}
#endif /*PRINT_RS485_DEVICE*/

uint8_t rs485ping(uint8_t devAddr)
{
    c03e:	bf 92       	push	r11
    c040:	cf 92       	push	r12
    c042:	df 92       	push	r13
    c044:	ef 92       	push	r14
    c046:	ff 92       	push	r15
    c048:	0f 93       	push	r16
    c04a:	1f 93       	push	r17
    c04c:	df 93       	push	r29
    c04e:	cf 93       	push	r28
    c050:	00 d0       	rcall	.+0      	; 0xc052 <rs485ping+0x14>
    c052:	0f 92       	push	r0
    c054:	cd b7       	in	r28, 0x3d	; 61
    c056:	de b7       	in	r29, 0x3e	; 62
    c058:	18 2f       	mov	r17, r24
  takeRs485();
    c05a:	0e 94 f5 11 	call	0x23ea	; 0x23ea <takeRs485>
    c05e:	ee 24       	eor	r14, r14
    c060:	ff 24       	eor	r15, r15
    c062:	8a e5       	ldi	r24, 0x5A	; 90
    c064:	97 01       	movw	r18, r14
    c066:	38 27       	eor	r19, r24
    c068:	03 2e       	mov	r0, r19
    c06a:	02 94       	swap	r0
    c06c:	90 2d       	mov	r25, r0
    c06e:	9f 70       	andi	r25, 0x0F	; 15
    c070:	93 27       	eor	r25, r19
    c072:	83 2f       	mov	r24, r19
    c074:	80 25       	eor	r24, r0
    c076:	88 0f       	add	r24, r24
    c078:	80 7e       	andi	r24, 0xE0	; 224
    c07a:	98 27       	eor	r25, r24
    c07c:	80 2d       	mov	r24, r0
    c07e:	83 27       	eor	r24, r19
    c080:	80 7f       	andi	r24, 0xF0	; 240
    c082:	86 95       	lsr	r24
    c084:	03 2e       	mov	r0, r19
    c086:	00 0c       	add	r0, r0
    c088:	88 1f       	adc	r24, r24
    c08a:	36 95       	lsr	r19
    c08c:	36 95       	lsr	r19
    c08e:	36 95       	lsr	r19
    c090:	3f 71       	andi	r19, 0x1F	; 31
    c092:	38 27       	eor	r19, r24
    c094:	32 27       	eor	r19, r18
    c096:	29 2f       	mov	r18, r25
    c098:	79 01       	movw	r14, r18

// ********************* Hiden Functions ***************************************************
void sendPing(uint8_t addr, uint8_t pingLen)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
  uartRs485SendByte(SYNC);
    c09a:	8a e5       	ldi	r24, 0x5A	; 90
    c09c:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    c0a0:	97 01       	movw	r18, r14
    c0a2:	31 27       	eor	r19, r17
    c0a4:	03 2e       	mov	r0, r19
    c0a6:	02 94       	swap	r0
    c0a8:	90 2d       	mov	r25, r0
    c0aa:	9f 70       	andi	r25, 0x0F	; 15
    c0ac:	93 27       	eor	r25, r19
    c0ae:	83 2f       	mov	r24, r19
    c0b0:	80 25       	eor	r24, r0
    c0b2:	88 0f       	add	r24, r24
    c0b4:	80 7e       	andi	r24, 0xE0	; 224
    c0b6:	98 27       	eor	r25, r24
    c0b8:	80 2d       	mov	r24, r0
    c0ba:	83 27       	eor	r24, r19
    c0bc:	80 7f       	andi	r24, 0xF0	; 240
    c0be:	86 95       	lsr	r24
    c0c0:	03 2e       	mov	r0, r19
    c0c2:	00 0c       	add	r0, r0
    c0c4:	88 1f       	adc	r24, r24
    c0c6:	36 95       	lsr	r19
    c0c8:	36 95       	lsr	r19
    c0ca:	36 95       	lsr	r19
    c0cc:	3f 71       	andi	r19, 0x1F	; 31
    c0ce:	38 27       	eor	r19, r24
    c0d0:	32 27       	eor	r19, r18
    c0d2:	29 2f       	mov	r18, r25
    c0d4:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, addr);
  uartRs485SendByte(addr);
    c0d6:	81 2f       	mov	r24, r17
    c0d8:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    c0dc:	80 e8       	ldi	r24, 0x80	; 128
    c0de:	97 01       	movw	r18, r14
    c0e0:	38 27       	eor	r19, r24
    c0e2:	03 2e       	mov	r0, r19
    c0e4:	02 94       	swap	r0
    c0e6:	90 2d       	mov	r25, r0
    c0e8:	9f 70       	andi	r25, 0x0F	; 15
    c0ea:	93 27       	eor	r25, r19
    c0ec:	83 2f       	mov	r24, r19
    c0ee:	80 25       	eor	r24, r0
    c0f0:	88 0f       	add	r24, r24
    c0f2:	80 7e       	andi	r24, 0xE0	; 224
    c0f4:	98 27       	eor	r25, r24
    c0f6:	80 2d       	mov	r24, r0
    c0f8:	83 27       	eor	r24, r19
    c0fa:	80 7f       	andi	r24, 0xF0	; 240
    c0fc:	86 95       	lsr	r24
    c0fe:	03 2e       	mov	r0, r19
    c100:	00 0c       	add	r0, r0
    c102:	88 1f       	adc	r24, r24
    c104:	36 95       	lsr	r19
    c106:	36 95       	lsr	r19
    c108:	36 95       	lsr	r19
    c10a:	3f 71       	andi	r19, 0x1F	; 31
    c10c:	38 27       	eor	r19, r24
    c10e:	32 27       	eor	r19, r18
    c110:	29 2f       	mov	r18, r25
    c112:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, rPING);
  uartRs485SendByte(rPING);
    c114:	80 e8       	ldi	r24, 0x80	; 128
    c116:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    c11a:	88 e0       	ldi	r24, 0x08	; 8
    c11c:	97 01       	movw	r18, r14
    c11e:	38 27       	eor	r19, r24
    c120:	03 2e       	mov	r0, r19
    c122:	02 94       	swap	r0
    c124:	90 2d       	mov	r25, r0
    c126:	9f 70       	andi	r25, 0x0F	; 15
    c128:	93 27       	eor	r25, r19
    c12a:	83 2f       	mov	r24, r19
    c12c:	80 25       	eor	r24, r0
    c12e:	88 0f       	add	r24, r24
    c130:	80 7e       	andi	r24, 0xE0	; 224
    c132:	98 27       	eor	r25, r24
    c134:	80 2d       	mov	r24, r0
    c136:	83 27       	eor	r24, r19
    c138:	80 7f       	andi	r24, 0xF0	; 240
    c13a:	86 95       	lsr	r24
    c13c:	03 2e       	mov	r0, r19
    c13e:	00 0c       	add	r0, r0
    c140:	88 1f       	adc	r24, r24
    c142:	36 95       	lsr	r19
    c144:	36 95       	lsr	r19
    c146:	36 95       	lsr	r19
    c148:	3f 71       	andi	r19, 0x1F	; 31
    c14a:	38 27       	eor	r19, r24
    c14c:	32 27       	eor	r19, r18
    c14e:	29 2f       	mov	r18, r25
    c150:	79 01       	movw	r14, r18

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
    c152:	88 e0       	ldi	r24, 0x08	; 8
    c154:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    c158:	bb 24       	eor	r11, r11
    c15a:	97 01       	movw	r18, r14
    c15c:	3b 25       	eor	r19, r11
    c15e:	03 2e       	mov	r0, r19
    c160:	02 94       	swap	r0
    c162:	90 2d       	mov	r25, r0
    c164:	9f 70       	andi	r25, 0x0F	; 15
    c166:	93 27       	eor	r25, r19
    c168:	83 2f       	mov	r24, r19
    c16a:	80 25       	eor	r24, r0
    c16c:	88 0f       	add	r24, r24
    c16e:	80 7e       	andi	r24, 0xE0	; 224
    c170:	98 27       	eor	r25, r24
    c172:	80 2d       	mov	r24, r0
    c174:	83 27       	eor	r24, r19
    c176:	80 7f       	andi	r24, 0xF0	; 240
    c178:	86 95       	lsr	r24
    c17a:	03 2e       	mov	r0, r19
    c17c:	00 0c       	add	r0, r0
    c17e:	88 1f       	adc	r24, r24
    c180:	36 95       	lsr	r19
    c182:	36 95       	lsr	r19
    c184:	36 95       	lsr	r19
    c186:	3f 71       	andi	r19, 0x1F	; 31
    c188:	38 27       	eor	r19, r24
    c18a:	32 27       	eor	r19, r18
    c18c:	29 2f       	mov	r18, r25
    c18e:	79 01       	movw	r14, r18
  
  for (uint8_t i=0; i < pingLen; i++)
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
    c190:	8b 2d       	mov	r24, r11
    c192:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  uartRs485SendByte(rPING);

  crc = _crc_xmodem_update(crc, pingLen);
  uartRs485SendByte(pingLen);
  
  for (uint8_t i=0; i < pingLen; i++)
    c196:	b3 94       	inc	r11
    c198:	38 e0       	ldi	r19, 0x08	; 8
    c19a:	b3 16       	cp	r11, r19
    c19c:	f1 f6       	brne	.-68     	; 0xc15a <rs485ping+0x11c>
  {
    crc = _crc_xmodem_update(crc, i);
    uartRs485SendByte(i);
  }
  uartRs485SendByte((uint8_t)(crc >> 8));
    c19e:	8f 2d       	mov	r24, r15
    c1a0:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    c1a4:	8e 2d       	mov	r24, r14
    c1a6:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  addr = 0;
  uint8_t data;
  uint16_t crc;
   
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    c1aa:	6e 01       	movw	r12, r28
    c1ac:	08 94       	sec
    c1ae:	c1 1c       	adc	r12, r1
    c1b0:	d1 1c       	adc	r13, r1
    c1b2:	c6 01       	movw	r24, r12
    c1b4:	64 e1       	ldi	r22, 0x14	; 20
    c1b6:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c1ba:	88 23       	and	r24, r24
    c1bc:	11 f4       	brne	.+4      	; 0xc1c2 <rs485ping+0x184>
    c1be:	11 e0       	ldi	r17, 0x01	; 1
    c1c0:	ee c0       	rjmp	.+476    	; 0xc39e <rs485ping+0x360>
    return 1;
  
  if (data != SYNC)
    c1c2:	89 81       	ldd	r24, Y+1	; 0x01
    c1c4:	8a 35       	cpi	r24, 0x5A	; 90
    c1c6:	11 f0       	breq	.+4      	; 0xc1cc <rs485ping+0x18e>
    c1c8:	12 e0       	ldi	r17, 0x02	; 2
    c1ca:	e9 c0       	rjmp	.+466    	; 0xc39e <rs485ping+0x360>
    c1cc:	00 e0       	ldi	r16, 0x00	; 0
    c1ce:	10 e0       	ldi	r17, 0x00	; 0
    c1d0:	18 27       	eor	r17, r24
    c1d2:	01 2e       	mov	r0, r17
    c1d4:	02 94       	swap	r0
    c1d6:	90 2d       	mov	r25, r0
    c1d8:	9f 70       	andi	r25, 0x0F	; 15
    c1da:	91 27       	eor	r25, r17
    c1dc:	81 2f       	mov	r24, r17
    c1de:	80 25       	eor	r24, r0
    c1e0:	88 0f       	add	r24, r24
    c1e2:	80 7e       	andi	r24, 0xE0	; 224
    c1e4:	98 27       	eor	r25, r24
    c1e6:	80 2d       	mov	r24, r0
    c1e8:	81 27       	eor	r24, r17
    c1ea:	80 7f       	andi	r24, 0xF0	; 240
    c1ec:	86 95       	lsr	r24
    c1ee:	01 2e       	mov	r0, r17
    c1f0:	00 0c       	add	r0, r0
    c1f2:	88 1f       	adc	r24, r24
    c1f4:	16 95       	lsr	r17
    c1f6:	16 95       	lsr	r17
    c1f8:	16 95       	lsr	r17
    c1fa:	1f 71       	andi	r17, 0x1F	; 31
    c1fc:	18 27       	eor	r17, r24
    c1fe:	10 27       	eor	r17, r16
    c200:	09 2f       	mov	r16, r25
    return 2;
  crc = _crc_xmodem_update(0, data);

  //Adres ma by warto 0
  if(rs485Receive(&data, 1) == 0)
    c202:	c6 01       	movw	r24, r12
    c204:	61 e0       	ldi	r22, 0x01	; 1
    c206:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c20a:	88 23       	and	r24, r24
    c20c:	11 f4       	brne	.+4      	; 0xc212 <rs485ping+0x1d4>
    c20e:	13 e0       	ldi	r17, 0x03	; 3
    c210:	c6 c0       	rjmp	.+396    	; 0xc39e <rs485ping+0x360>
    return 3;

  if (data != 0)
    c212:	89 81       	ldd	r24, Y+1	; 0x01
    c214:	88 23       	and	r24, r24
    c216:	11 f0       	breq	.+4      	; 0xc21c <rs485ping+0x1de>
    c218:	14 e0       	ldi	r17, 0x04	; 4
    c21a:	c1 c0       	rjmp	.+386    	; 0xc39e <rs485ping+0x360>
    c21c:	18 27       	eor	r17, r24
    c21e:	01 2e       	mov	r0, r17
    c220:	02 94       	swap	r0
    c222:	90 2d       	mov	r25, r0
    c224:	9f 70       	andi	r25, 0x0F	; 15
    c226:	91 27       	eor	r25, r17
    c228:	81 2f       	mov	r24, r17
    c22a:	80 25       	eor	r24, r0
    c22c:	88 0f       	add	r24, r24
    c22e:	80 7e       	andi	r24, 0xE0	; 224
    c230:	98 27       	eor	r25, r24
    c232:	80 2d       	mov	r24, r0
    c234:	81 27       	eor	r24, r17
    c236:	80 7f       	andi	r24, 0xF0	; 240
    c238:	86 95       	lsr	r24
    c23a:	01 2e       	mov	r0, r17
    c23c:	00 0c       	add	r0, r0
    c23e:	88 1f       	adc	r24, r24
    c240:	16 95       	lsr	r17
    c242:	16 95       	lsr	r17
    c244:	16 95       	lsr	r17
    c246:	1f 71       	andi	r17, 0x1F	; 31
    c248:	18 27       	eor	r17, r24
    c24a:	10 27       	eor	r17, r16
    c24c:	09 2f       	mov	r16, r25
    return 4;
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma by rPING
  if(rs485Receive(&data, 1) == pdFALSE)
    c24e:	c6 01       	movw	r24, r12
    c250:	61 e0       	ldi	r22, 0x01	; 1
    c252:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c256:	88 23       	and	r24, r24
    c258:	11 f4       	brne	.+4      	; 0xc25e <rs485ping+0x220>
    c25a:	15 e0       	ldi	r17, 0x05	; 5
    c25c:	a0 c0       	rjmp	.+320    	; 0xc39e <rs485ping+0x360>
    return 5;
  if (data != rPING)
    c25e:	89 81       	ldd	r24, Y+1	; 0x01
    c260:	80 38       	cpi	r24, 0x80	; 128
    c262:	11 f0       	breq	.+4      	; 0xc268 <rs485ping+0x22a>
    c264:	16 e0       	ldi	r17, 0x06	; 6
    c266:	9b c0       	rjmp	.+310    	; 0xc39e <rs485ping+0x360>
    c268:	18 27       	eor	r17, r24
    c26a:	01 2e       	mov	r0, r17
    c26c:	02 94       	swap	r0
    c26e:	90 2d       	mov	r25, r0
    c270:	9f 70       	andi	r25, 0x0F	; 15
    c272:	91 27       	eor	r25, r17
    c274:	81 2f       	mov	r24, r17
    c276:	80 25       	eor	r24, r0
    c278:	88 0f       	add	r24, r24
    c27a:	80 7e       	andi	r24, 0xE0	; 224
    c27c:	98 27       	eor	r25, r24
    c27e:	80 2d       	mov	r24, r0
    c280:	81 27       	eor	r24, r17
    c282:	80 7f       	andi	r24, 0xF0	; 240
    c284:	86 95       	lsr	r24
    c286:	01 2e       	mov	r0, r17
    c288:	00 0c       	add	r0, r0
    c28a:	88 1f       	adc	r24, r24
    c28c:	16 95       	lsr	r17
    c28e:	16 95       	lsr	r17
    c290:	16 95       	lsr	r17
    c292:	1f 71       	andi	r17, 0x1F	; 31
    c294:	18 27       	eor	r17, r24
    c296:	10 27       	eor	r17, r16
    c298:	09 2f       	mov	r16, r25
    return 6;
  crc = _crc_xmodem_update(crc, data);

  //Dugo odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    c29a:	c6 01       	movw	r24, r12
    c29c:	61 e0       	ldi	r22, 0x01	; 1
    c29e:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c2a2:	88 23       	and	r24, r24
    c2a4:	11 f4       	brne	.+4      	; 0xc2aa <rs485ping+0x26c>
    c2a6:	17 e0       	ldi	r17, 0x07	; 7
    c2a8:	7a c0       	rjmp	.+244    	; 0xc39e <rs485ping+0x360>
    return 7;
  if (data != dataLen)
    c2aa:	89 81       	ldd	r24, Y+1	; 0x01
    c2ac:	88 30       	cpi	r24, 0x08	; 8
    c2ae:	11 f0       	breq	.+4      	; 0xc2b4 <rs485ping+0x276>
    c2b0:	18 e0       	ldi	r17, 0x08	; 8
    c2b2:	75 c0       	rjmp	.+234    	; 0xc39e <rs485ping+0x360>
    c2b4:	1b 25       	eor	r17, r11
    c2b6:	01 2e       	mov	r0, r17
    c2b8:	02 94       	swap	r0
    c2ba:	90 2d       	mov	r25, r0
    c2bc:	9f 70       	andi	r25, 0x0F	; 15
    c2be:	91 27       	eor	r25, r17
    c2c0:	81 2f       	mov	r24, r17
    c2c2:	80 25       	eor	r24, r0
    c2c4:	88 0f       	add	r24, r24
    c2c6:	80 7e       	andi	r24, 0xE0	; 224
    c2c8:	98 27       	eor	r25, r24
    c2ca:	80 2d       	mov	r24, r0
    c2cc:	81 27       	eor	r24, r17
    c2ce:	80 7f       	andi	r24, 0xF0	; 240
    c2d0:	86 95       	lsr	r24
    c2d2:	01 2e       	mov	r0, r17
    c2d4:	00 0c       	add	r0, r0
    c2d6:	88 1f       	adc	r24, r24
    c2d8:	16 95       	lsr	r17
    c2da:	16 95       	lsr	r17
    c2dc:	16 95       	lsr	r17
    c2de:	1f 71       	andi	r17, 0x1F	; 31
    c2e0:	18 27       	eor	r17, r24
    c2e2:	10 27       	eor	r17, r16
    c2e4:	09 2f       	mov	r16, r25
    c2e6:	ff 24       	eor	r15, r15

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
  {
    if(rs485Receive(&data, 5) == pdFALSE)
    c2e8:	c6 01       	movw	r24, r12
    c2ea:	dc 2c       	mov	r13, r12
    c2ec:	e9 2e       	mov	r14, r25
    c2ee:	8d 2d       	mov	r24, r13
    c2f0:	9e 2d       	mov	r25, r14
    c2f2:	65 e0       	ldi	r22, 0x05	; 5
    c2f4:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c2f8:	88 23       	and	r24, r24
    c2fa:	21 f4       	brne	.+8      	; 0xc304 <rs485ping+0x2c6>
      return 2*temp+9;
    c2fc:	1f 2d       	mov	r17, r15
    c2fe:	11 0f       	add	r17, r17
    c300:	17 5f       	subi	r17, 0xF7	; 247
    c302:	4d c0       	rjmp	.+154    	; 0xc39e <rs485ping+0x360>
    crc = _crc_xmodem_update(crc, data);
    c304:	89 81       	ldd	r24, Y+1	; 0x01
    c306:	18 27       	eor	r17, r24
    c308:	01 2e       	mov	r0, r17
    c30a:	02 94       	swap	r0
    c30c:	20 2d       	mov	r18, r0
    c30e:	2f 70       	andi	r18, 0x0F	; 15
    c310:	21 27       	eor	r18, r17
    c312:	91 2f       	mov	r25, r17
    c314:	90 25       	eor	r25, r0
    c316:	99 0f       	add	r25, r25
    c318:	90 7e       	andi	r25, 0xE0	; 224
    c31a:	29 27       	eor	r18, r25
    c31c:	90 2d       	mov	r25, r0
    c31e:	91 27       	eor	r25, r17
    c320:	90 7f       	andi	r25, 0xF0	; 240
    c322:	96 95       	lsr	r25
    c324:	01 2e       	mov	r0, r17
    c326:	00 0c       	add	r0, r0
    c328:	99 1f       	adc	r25, r25
    c32a:	16 95       	lsr	r17
    c32c:	16 95       	lsr	r17
    c32e:	16 95       	lsr	r17
    c330:	1f 71       	andi	r17, 0x1F	; 31
    c332:	19 27       	eor	r17, r25
    c334:	10 27       	eor	r17, r16
    c336:	02 2f       	mov	r16, r18
    if (data != temp)
    c338:	8f 15       	cp	r24, r15
    c33a:	21 f0       	breq	.+8      	; 0xc344 <rs485ping+0x306>
      return 2*temp+10; 
    c33c:	1f 2d       	mov	r17, r15
    c33e:	11 0f       	add	r17, r17
    c340:	16 5f       	subi	r17, 0xF6	; 246
    c342:	2d c0       	rjmp	.+90     	; 0xc39e <rs485ping+0x360>
    return 8;
  crc = _crc_xmodem_update(crc, data);

  
  uint8_t temp;
  for (temp=0; temp < dataLen; temp++)
    c344:	f3 94       	inc	r15
    c346:	87 e0       	ldi	r24, 0x07	; 7
    c348:	8f 15       	cp	r24, r15
    c34a:	08 f0       	brcs	.+2      	; 0xc34e <rs485ping+0x310>
    c34c:	d0 cf       	rjmp	.-96     	; 0xc2ee <rs485ping+0x2b0>
      return 2*temp+10; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    c34e:	ce 01       	movw	r24, r28
    c350:	02 96       	adiw	r24, 0x02	; 2
    c352:	61 e0       	ldi	r22, 0x01	; 1
    c354:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c358:	81 30       	cpi	r24, 0x01	; 1
    c35a:	21 f0       	breq	.+8      	; 0xc364 <rs485ping+0x326>
    return 2*temp+11;
    c35c:	1f 2d       	mov	r17, r15
    c35e:	11 0f       	add	r17, r17
    c360:	15 5f       	subi	r17, 0xF5	; 245
    c362:	1d c0       	rjmp	.+58     	; 0xc39e <rs485ping+0x360>
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    c364:	80 91 b3 0e 	lds	r24, 0x0EB3
    c368:	90 91 b4 0e 	lds	r25, 0x0EB4
    c36c:	be 01       	movw	r22, r28
    c36e:	6d 5f       	subi	r22, 0xFD	; 253
    c370:	7f 4f       	sbci	r23, 0xFF	; 255
    c372:	41 e0       	ldi	r20, 0x01	; 1
    c374:	50 e0       	ldi	r21, 0x00	; 0
    c376:	20 e0       	ldi	r18, 0x00	; 0
    c378:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    c37c:	81 30       	cpi	r24, 0x01	; 1
    c37e:	21 f0       	breq	.+8      	; 0xc388 <rs485ping+0x34a>
    return 2*temp+12;
    c380:	1f 2d       	mov	r17, r15
    c382:	11 0f       	add	r17, r17
    c384:	14 5f       	subi	r17, 0xF4	; 244
    c386:	0b c0       	rjmp	.+22     	; 0xc39e <rs485ping+0x360>

  if (crcHi != (uint8_t)(crc>>8))
    c388:	8a 81       	ldd	r24, Y+2	; 0x02
    c38a:	81 17       	cp	r24, r17
    c38c:	11 f0       	breq	.+4      	; 0xc392 <rs485ping+0x354>
    c38e:	1e ef       	ldi	r17, 0xFE	; 254
    c390:	06 c0       	rjmp	.+12     	; 0xc39e <rs485ping+0x360>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    c392:	8b 81       	ldd	r24, Y+3	; 0x03
    c394:	80 17       	cp	r24, r16
    c396:	11 f4       	brne	.+4      	; 0xc39c <rs485ping+0x35e>
    c398:	10 e0       	ldi	r17, 0x00	; 0
    c39a:	01 c0       	rjmp	.+2      	; 0xc39e <rs485ping+0x360>
    c39c:	1f ef       	ldi	r17, 0xFF	; 255
{
  takeRs485();
  const int len = 8;    
  sendPing(devAddr, len);
  uint8_t result = receivePong(devAddr, len);
  flushRs485RecBuffer();
    c39e:	0e 94 01 12 	call	0x2402	; 0x2402 <flushRs485RecBuffer>

  releaseRs485();
    c3a2:	0e 94 49 11 	call	0x2292	; 0x2292 <releaseRs485>
  return result;
}
    c3a6:	81 2f       	mov	r24, r17
    c3a8:	0f 90       	pop	r0
    c3aa:	0f 90       	pop	r0
    c3ac:	0f 90       	pop	r0
    c3ae:	cf 91       	pop	r28
    c3b0:	df 91       	pop	r29
    c3b2:	1f 91       	pop	r17
    c3b4:	0f 91       	pop	r16
    c3b6:	ff 90       	pop	r15
    c3b8:	ef 90       	pop	r14
    c3ba:	df 90       	pop	r13
    c3bc:	cf 90       	pop	r12
    c3be:	bf 90       	pop	r11
    c3c0:	08 95       	ret

0000c3c2 <rs485rollerHello>:

uint8_t rs485rollerHello(uint8_t devAddr)
{
    c3c2:	af 92       	push	r10
    c3c4:	bf 92       	push	r11
    c3c6:	cf 92       	push	r12
    c3c8:	df 92       	push	r13
    c3ca:	ef 92       	push	r14
    c3cc:	ff 92       	push	r15
    c3ce:	0f 93       	push	r16
    c3d0:	1f 93       	push	r17
    c3d2:	df 93       	push	r29
    c3d4:	cf 93       	push	r28
    c3d6:	00 d0       	rcall	.+0      	; 0xc3d8 <rs485rollerHello+0x16>
    c3d8:	0f 92       	push	r0
    c3da:	cd b7       	in	r28, 0x3d	; 61
    c3dc:	de b7       	in	r29, 0x3e	; 62
    c3de:	d8 2e       	mov	r13, r24
    c3e0:	e0 91 bf 0e 	lds	r30, 0x0EBF
    c3e4:	f0 91 c0 0e 	lds	r31, 0x0EC0
    c3e8:	ee 24       	eor	r14, r14
    c3ea:	ff 24       	eor	r15, r15
    c3ec:	40 e0       	ldi	r20, 0x00	; 0
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    if (rollers[i].address == devAddr)
    c3ee:	81 81       	ldd	r24, Z+1	; 0x01
    c3f0:	8d 15       	cp	r24, r13
    c3f2:	09 f4       	brne	.+2      	; 0xc3f6 <rs485rollerHello+0x34>
    c3f4:	7f 01       	movw	r14, r30

uint8_t rs485rollerHello(uint8_t devAddr)
{
  struct sterRolet *tmp = NULL;
  uint8_t i;
  for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    c3f6:	4f 5f       	subi	r20, 0xFF	; 255
    c3f8:	3a 96       	adiw	r30, 0x0a	; 10
    c3fa:	4a 30       	cpi	r20, 0x0A	; 10
    c3fc:	c1 f7       	brne	.-16     	; 0xc3ee <rs485rollerHello+0x2c>
    if (rollers[i].address == devAddr)
      tmp = &rollers[i];
    
  if (rs485ping(devAddr)==0)
    c3fe:	8d 2d       	mov	r24, r13
    c400:	0e 94 1f 60 	call	0xc03e	; 0xc03e <rs485ping>
    c404:	88 23       	and	r24, r24
    c406:	e9 f4       	brne	.+58     	; 0xc442 <rs485rollerHello+0x80>
  {
    if (tmp == NULL)
    c408:	e1 14       	cp	r14, r1
    c40a:	f1 04       	cpc	r15, r1
    c40c:	81 f4       	brne	.+32     	; 0xc42e <rs485rollerHello+0x6c>
    c40e:	e0 91 bf 0e 	lds	r30, 0x0EBF
    c412:	f0 91 c0 0e 	lds	r31, 0x0EC0
    c416:	90 e0       	ldi	r25, 0x00	; 0
    c418:	7f 01       	movw	r14, r30
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
      {
        if (rollers[i].address == 0)
    c41a:	81 81       	ldd	r24, Z+1	; 0x01
    c41c:	88 23       	and	r24, r24
    c41e:	11 f4       	brne	.+4      	; 0xc424 <rs485rollerHello+0x62>
        {
          tmp = &rollers[i];
          tmp->address = devAddr;
    c420:	d1 82       	std	Z+1, r13	; 0x01
    c422:	05 c0       	rjmp	.+10     	; 0xc42e <rs485rollerHello+0x6c>
    
  if (rs485ping(devAddr)==0)
  {
    if (tmp == NULL)
    {
      for (i=0; i< MAX_NUMBER_OF_ROLLERS; i++)
    c424:	9f 5f       	subi	r25, 0xFF	; 255
    c426:	3a 96       	adiw	r30, 0x0a	; 10
    c428:	9a 30       	cpi	r25, 0x0A	; 10
    c42a:	b1 f7       	brne	.-20     	; 0xc418 <rs485rollerHello+0x56>
    c42c:	90 c1       	rjmp	.+800    	; 0xc74e <rs485rollerHello+0x38c>
          tmp->address = devAddr;
          break;
        }
      }
    }
    if (tmp != NULL)
    c42e:	e1 14       	cp	r14, r1
    c430:	f1 04       	cpc	r15, r1
    c432:	09 f4       	brne	.+2      	; 0xc436 <rs485rollerHello+0x74>
    c434:	8c c1       	rjmp	.+792    	; 0xc74e <rs485rollerHello+0x38c>
    {
      tmp->state &= (~NOT_DETECTED);
    c436:	f7 01       	movw	r30, r14
    c438:	80 81       	ld	r24, Z
    c43a:	8e 7f       	andi	r24, 0xFE	; 254
    c43c:	80 83       	st	Z, r24
      tmp->address = devAddr;
    c43e:	d1 82       	std	Z+1, r13	; 0x01
    c440:	0d c0       	rjmp	.+26     	; 0xc45c <rs485rollerHello+0x9a>
    else
      return 1;
  }
  else
  {
    if (tmp != NULL)
    c442:	e1 14       	cp	r14, r1
    c444:	f1 04       	cpc	r15, r1
    c446:	51 f0       	breq	.+20     	; 0xc45c <rs485rollerHello+0x9a>
    {
      if (tmp->state & NOT_DETECTED)
    c448:	f7 01       	movw	r30, r14
    c44a:	80 81       	ld	r24, Z
    c44c:	80 fd       	sbrc	r24, 0
      {
        tmp->address = 0;
    c44e:	11 82       	std	Z+1, r1	; 0x01
      }
      tmp->state |= NOT_DETECTED;
    c450:	f7 01       	movw	r30, r14
    c452:	80 81       	ld	r24, Z
    c454:	81 60       	ori	r24, 0x01	; 1
    c456:	80 83       	st	Z, r24
    c458:	02 e0       	ldi	r16, 0x02	; 2
    c45a:	7a c1       	rjmp	.+756    	; 0xc750 <rs485rollerHello+0x38e>
      return 2;
    }
  }
  
  takeRs485();
    c45c:	0e 94 f5 11 	call	0x23ea	; 0x23ea <takeRs485>
    c460:	aa 24       	eor	r10, r10
    c462:	bb 24       	eor	r11, r11
    c464:	85 01       	movw	r16, r10
    c466:	8a e5       	ldi	r24, 0x5A	; 90
    c468:	18 27       	eor	r17, r24
    c46a:	01 2e       	mov	r0, r17
    c46c:	02 94       	swap	r0
    c46e:	90 2d       	mov	r25, r0
    c470:	9f 70       	andi	r25, 0x0F	; 15
    c472:	91 27       	eor	r25, r17
    c474:	81 2f       	mov	r24, r17
    c476:	80 25       	eor	r24, r0
    c478:	88 0f       	add	r24, r24
    c47a:	80 7e       	andi	r24, 0xE0	; 224
    c47c:	98 27       	eor	r25, r24
    c47e:	80 2d       	mov	r24, r0
    c480:	81 27       	eor	r24, r17
    c482:	80 7f       	andi	r24, 0xF0	; 240
    c484:	86 95       	lsr	r24
    c486:	01 2e       	mov	r0, r17
    c488:	00 0c       	add	r0, r0
    c48a:	88 1f       	adc	r24, r24
    c48c:	16 95       	lsr	r17
    c48e:	16 95       	lsr	r17
    c490:	16 95       	lsr	r17
    c492:	1f 71       	andi	r17, 0x1F	; 31
    c494:	18 27       	eor	r17, r24
    c496:	10 27       	eor	r17, r16
    c498:	09 2f       	mov	r16, r25
}

static void    sendHello(uint8_t addr)
{
  uint16_t crc = _crc_xmodem_update(0, SYNC);
  uartRs485SendByte(SYNC);
    c49a:	8a e5       	ldi	r24, 0x5A	; 90
    c49c:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    c4a0:	1d 25       	eor	r17, r13
    c4a2:	01 2e       	mov	r0, r17
    c4a4:	02 94       	swap	r0
    c4a6:	90 2d       	mov	r25, r0
    c4a8:	9f 70       	andi	r25, 0x0F	; 15
    c4aa:	91 27       	eor	r25, r17
    c4ac:	81 2f       	mov	r24, r17
    c4ae:	80 25       	eor	r24, r0
    c4b0:	88 0f       	add	r24, r24
    c4b2:	80 7e       	andi	r24, 0xE0	; 224
    c4b4:	98 27       	eor	r25, r24
    c4b6:	80 2d       	mov	r24, r0
    c4b8:	81 27       	eor	r24, r17
    c4ba:	80 7f       	andi	r24, 0xF0	; 240
    c4bc:	86 95       	lsr	r24
    c4be:	01 2e       	mov	r0, r17
    c4c0:	00 0c       	add	r0, r0
    c4c2:	88 1f       	adc	r24, r24
    c4c4:	16 95       	lsr	r17
    c4c6:	16 95       	lsr	r17
    c4c8:	16 95       	lsr	r17
    c4ca:	1f 71       	andi	r17, 0x1F	; 31
    c4cc:	18 27       	eor	r17, r24
    c4ce:	10 27       	eor	r17, r16
    c4d0:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, addr);
  uartRs485SendByte(addr);
    c4d2:	8d 2d       	mov	r24, r13
    c4d4:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    c4d8:	82 e8       	ldi	r24, 0x82	; 130
    c4da:	18 27       	eor	r17, r24
    c4dc:	01 2e       	mov	r0, r17
    c4de:	02 94       	swap	r0
    c4e0:	90 2d       	mov	r25, r0
    c4e2:	9f 70       	andi	r25, 0x0F	; 15
    c4e4:	91 27       	eor	r25, r17
    c4e6:	81 2f       	mov	r24, r17
    c4e8:	80 25       	eor	r24, r0
    c4ea:	88 0f       	add	r24, r24
    c4ec:	80 7e       	andi	r24, 0xE0	; 224
    c4ee:	98 27       	eor	r25, r24
    c4f0:	80 2d       	mov	r24, r0
    c4f2:	81 27       	eor	r24, r17
    c4f4:	80 7f       	andi	r24, 0xF0	; 240
    c4f6:	86 95       	lsr	r24
    c4f8:	01 2e       	mov	r0, r17
    c4fa:	00 0c       	add	r0, r0
    c4fc:	88 1f       	adc	r24, r24
    c4fe:	16 95       	lsr	r17
    c500:	16 95       	lsr	r17
    c502:	16 95       	lsr	r17
    c504:	1f 71       	andi	r17, 0x1F	; 31
    c506:	18 27       	eor	r17, r24
    c508:	10 27       	eor	r17, r16
    c50a:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, rHELLO);
  uartRs485SendByte(rHELLO);
    c50c:	82 e8       	ldi	r24, 0x82	; 130
    c50e:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
    c512:	80 e0       	ldi	r24, 0x00	; 0
    c514:	18 27       	eor	r17, r24
    c516:	01 2e       	mov	r0, r17
    c518:	02 94       	swap	r0
    c51a:	90 2d       	mov	r25, r0
    c51c:	9f 70       	andi	r25, 0x0F	; 15
    c51e:	91 27       	eor	r25, r17
    c520:	81 2f       	mov	r24, r17
    c522:	80 25       	eor	r24, r0
    c524:	88 0f       	add	r24, r24
    c526:	80 7e       	andi	r24, 0xE0	; 224
    c528:	98 27       	eor	r25, r24
    c52a:	80 2d       	mov	r24, r0
    c52c:	81 27       	eor	r24, r17
    c52e:	80 7f       	andi	r24, 0xF0	; 240
    c530:	86 95       	lsr	r24
    c532:	01 2e       	mov	r0, r17
    c534:	00 0c       	add	r0, r0
    c536:	88 1f       	adc	r24, r24
    c538:	16 95       	lsr	r17
    c53a:	16 95       	lsr	r17
    c53c:	16 95       	lsr	r17
    c53e:	1f 71       	andi	r17, 0x1F	; 31
    c540:	18 27       	eor	r17, r24
    c542:	10 27       	eor	r17, r16
    c544:	09 2f       	mov	r16, r25

  crc = _crc_xmodem_update(crc, 0);
  uartRs485SendByte(0);
    c546:	80 e0       	ldi	r24, 0x00	; 0
    c548:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  
  uartRs485SendByte((uint8_t)(crc >> 8));
    c54c:	81 2f       	mov	r24, r17
    c54e:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
  uartRs485SendByte((uint8_t)(crc & 0xFF));
    c552:	80 2f       	mov	r24, r16
    c554:	0e 94 55 11 	call	0x22aa	; 0x22aa <uartRs485SendByte>
static uint8_t receiveHello(uint8_t* response, uint8_t maxSize)
{
  uint16_t crc;
  uint8_t data; 
  //SYNC
  if(rs485Receive(&data, 20) == pdFALSE)
    c558:	6e 01       	movw	r12, r28
    c55a:	08 94       	sec
    c55c:	c1 1c       	adc	r12, r1
    c55e:	d1 1c       	adc	r13, r1
    c560:	c6 01       	movw	r24, r12
    c562:	64 e1       	ldi	r22, 0x14	; 20
    c564:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c568:	88 23       	and	r24, r24
    c56a:	11 f4       	brne	.+4      	; 0xc570 <rs485rollerHello+0x1ae>
    c56c:	08 e0       	ldi	r16, 0x08	; 8
    c56e:	ec c0       	rjmp	.+472    	; 0xc748 <rs485rollerHello+0x386>
    return 8;
  
  if (data != SYNC)
    c570:	89 81       	ldd	r24, Y+1	; 0x01
    c572:	8a 35       	cpi	r24, 0x5A	; 90
    c574:	11 f0       	breq	.+4      	; 0xc57a <rs485rollerHello+0x1b8>
    c576:	02 e0       	ldi	r16, 0x02	; 2
    c578:	e7 c0       	rjmp	.+462    	; 0xc748 <rs485rollerHello+0x386>
    c57a:	85 01       	movw	r16, r10
    c57c:	18 27       	eor	r17, r24
    c57e:	01 2e       	mov	r0, r17
    c580:	02 94       	swap	r0
    c582:	90 2d       	mov	r25, r0
    c584:	9f 70       	andi	r25, 0x0F	; 15
    c586:	91 27       	eor	r25, r17
    c588:	81 2f       	mov	r24, r17
    c58a:	80 25       	eor	r24, r0
    c58c:	88 0f       	add	r24, r24
    c58e:	80 7e       	andi	r24, 0xE0	; 224
    c590:	98 27       	eor	r25, r24
    c592:	80 2d       	mov	r24, r0
    c594:	81 27       	eor	r24, r17
    c596:	80 7f       	andi	r24, 0xF0	; 240
    c598:	86 95       	lsr	r24
    c59a:	01 2e       	mov	r0, r17
    c59c:	00 0c       	add	r0, r0
    c59e:	88 1f       	adc	r24, r24
    c5a0:	16 95       	lsr	r17
    c5a2:	16 95       	lsr	r17
    c5a4:	16 95       	lsr	r17
    c5a6:	1f 71       	andi	r17, 0x1F	; 31
    c5a8:	18 27       	eor	r17, r24
    c5aa:	10 27       	eor	r17, r16
    c5ac:	09 2f       	mov	r16, r25
    return 2;
  crc = _crc_xmodem_update(0, data);

  //Adres ma by warto 0
  if(rs485Receive(&data, 1) == 0)
    c5ae:	c6 01       	movw	r24, r12
    c5b0:	61 e0       	ldi	r22, 0x01	; 1
    c5b2:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c5b6:	88 23       	and	r24, r24
    c5b8:	11 f4       	brne	.+4      	; 0xc5be <rs485rollerHello+0x1fc>
    c5ba:	03 e0       	ldi	r16, 0x03	; 3
    c5bc:	c5 c0       	rjmp	.+394    	; 0xc748 <rs485rollerHello+0x386>
    return 3;

  if (data != 0)
    c5be:	89 81       	ldd	r24, Y+1	; 0x01
    c5c0:	88 23       	and	r24, r24
    c5c2:	11 f0       	breq	.+4      	; 0xc5c8 <rs485rollerHello+0x206>
    c5c4:	04 e0       	ldi	r16, 0x04	; 4
    c5c6:	c0 c0       	rjmp	.+384    	; 0xc748 <rs485rollerHello+0x386>
    c5c8:	18 27       	eor	r17, r24
    c5ca:	01 2e       	mov	r0, r17
    c5cc:	02 94       	swap	r0
    c5ce:	90 2d       	mov	r25, r0
    c5d0:	9f 70       	andi	r25, 0x0F	; 15
    c5d2:	91 27       	eor	r25, r17
    c5d4:	81 2f       	mov	r24, r17
    c5d6:	80 25       	eor	r24, r0
    c5d8:	88 0f       	add	r24, r24
    c5da:	80 7e       	andi	r24, 0xE0	; 224
    c5dc:	98 27       	eor	r25, r24
    c5de:	80 2d       	mov	r24, r0
    c5e0:	81 27       	eor	r24, r17
    c5e2:	80 7f       	andi	r24, 0xF0	; 240
    c5e4:	86 95       	lsr	r24
    c5e6:	01 2e       	mov	r0, r17
    c5e8:	00 0c       	add	r0, r0
    c5ea:	88 1f       	adc	r24, r24
    c5ec:	16 95       	lsr	r17
    c5ee:	16 95       	lsr	r17
    c5f0:	16 95       	lsr	r17
    c5f2:	1f 71       	andi	r17, 0x1F	; 31
    c5f4:	18 27       	eor	r17, r24
    c5f6:	10 27       	eor	r17, r16
    c5f8:	09 2f       	mov	r16, r25
    return 4;
  
  crc = _crc_xmodem_update(crc, data);

  //Kod rozkazu. Ma by rHELLO
  if(rs485Receive(&data, 1) == pdFALSE)
    c5fa:	c6 01       	movw	r24, r12
    c5fc:	61 e0       	ldi	r22, 0x01	; 1
    c5fe:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c602:	88 23       	and	r24, r24
    c604:	11 f4       	brne	.+4      	; 0xc60a <rs485rollerHello+0x248>
    c606:	05 e0       	ldi	r16, 0x05	; 5
    c608:	9f c0       	rjmp	.+318    	; 0xc748 <rs485rollerHello+0x386>
    return 5;
  if (data != rHELLO)
    c60a:	89 81       	ldd	r24, Y+1	; 0x01
    c60c:	82 38       	cpi	r24, 0x82	; 130
    c60e:	11 f0       	breq	.+4      	; 0xc614 <rs485rollerHello+0x252>
    c610:	06 e0       	ldi	r16, 0x06	; 6
    c612:	9a c0       	rjmp	.+308    	; 0xc748 <rs485rollerHello+0x386>
    c614:	18 27       	eor	r17, r24
    c616:	01 2e       	mov	r0, r17
    c618:	02 94       	swap	r0
    c61a:	90 2d       	mov	r25, r0
    c61c:	9f 70       	andi	r25, 0x0F	; 15
    c61e:	91 27       	eor	r25, r17
    c620:	81 2f       	mov	r24, r17
    c622:	80 25       	eor	r24, r0
    c624:	88 0f       	add	r24, r24
    c626:	80 7e       	andi	r24, 0xE0	; 224
    c628:	98 27       	eor	r25, r24
    c62a:	80 2d       	mov	r24, r0
    c62c:	81 27       	eor	r24, r17
    c62e:	80 7f       	andi	r24, 0xF0	; 240
    c630:	86 95       	lsr	r24
    c632:	01 2e       	mov	r0, r17
    c634:	00 0c       	add	r0, r0
    c636:	88 1f       	adc	r24, r24
    c638:	16 95       	lsr	r17
    c63a:	16 95       	lsr	r17
    c63c:	16 95       	lsr	r17
    c63e:	1f 71       	andi	r17, 0x1F	; 31
    c640:	18 27       	eor	r17, r24
    c642:	10 27       	eor	r17, r16
    c644:	09 2f       	mov	r16, r25
    return 6;
  crc = _crc_xmodem_update(crc, data);

  //Dugo odpowiedzi
  if(rs485Receive(&data, 1) == pdFALSE)
    c646:	c6 01       	movw	r24, r12
    c648:	61 e0       	ldi	r22, 0x01	; 1
    c64a:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c64e:	88 23       	and	r24, r24
    c650:	11 f4       	brne	.+4      	; 0xc656 <rs485rollerHello+0x294>
    c652:	07 e0       	ldi	r16, 0x07	; 7
    c654:	79 c0       	rjmp	.+242    	; 0xc748 <rs485rollerHello+0x386>
    return 7;
  if (data > maxSize)
    c656:	89 81       	ldd	r24, Y+1	; 0x01
    c658:	88 30       	cpi	r24, 0x08	; 8
    c65a:	10 f0       	brcs	.+4      	; 0xc660 <rs485rollerHello+0x29e>
    c65c:	01 e0       	ldi	r16, 0x01	; 1
    c65e:	74 c0       	rjmp	.+232    	; 0xc748 <rs485rollerHello+0x386>
    }
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
    c660:	22 e0       	ldi	r18, 0x02	; 2
    c662:	30 e0       	ldi	r19, 0x00	; 0
    c664:	e2 0e       	add	r14, r18
    c666:	f3 1e       	adc	r15, r19
    c668:	18 27       	eor	r17, r24
    c66a:	01 2e       	mov	r0, r17
    c66c:	02 94       	swap	r0
    c66e:	90 2d       	mov	r25, r0
    c670:	9f 70       	andi	r25, 0x0F	; 15
    c672:	91 27       	eor	r25, r17
    c674:	81 2f       	mov	r24, r17
    c676:	80 25       	eor	r24, r0
    c678:	88 0f       	add	r24, r24
    c67a:	80 7e       	andi	r24, 0xE0	; 224
    c67c:	98 27       	eor	r25, r24
    c67e:	80 2d       	mov	r24, r0
    c680:	81 27       	eor	r24, r17
    c682:	80 7f       	andi	r24, 0xF0	; 240
    c684:	86 95       	lsr	r24
    c686:	01 2e       	mov	r0, r17
    c688:	00 0c       	add	r0, r0
    c68a:	88 1f       	adc	r24, r24
    c68c:	16 95       	lsr	r17
    c68e:	16 95       	lsr	r17
    c690:	16 95       	lsr	r17
    c692:	1f 71       	andi	r17, 0x1F	; 31
    c694:	18 27       	eor	r17, r24
    c696:	10 27       	eor	r17, r16
    c698:	09 2f       	mov	r16, r25
    return 7;
  if (data > maxSize)
    return 1;
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
    c69a:	87 e0       	ldi	r24, 0x07	; 7
    c69c:	f7 01       	movw	r30, r14
    c69e:	11 92       	st	Z+, r1
    c6a0:	8a 95       	dec	r24
    c6a2:	e9 f7       	brne	.-6      	; 0xc69e <rs485rollerHello+0x2dc>
  maxSize = data;
    c6a4:	d9 80       	ldd	r13, Y+1	; 0x01
  
  for (data=0; data < maxSize; data++)
    c6a6:	19 82       	std	Y+1, r1	; 0x01
    c6a8:	27 c0       	rjmp	.+78     	; 0xc6f8 <rs485rollerHello+0x336>
  {
    if(rs485Receive(response, 5) == pdFALSE)
    c6aa:	c7 01       	movw	r24, r14
    c6ac:	65 e0       	ldi	r22, 0x05	; 5
    c6ae:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c6b2:	88 23       	and	r24, r24
    c6b4:	11 f4       	brne	.+4      	; 0xc6ba <rs485rollerHello+0x2f8>
    c6b6:	04 e1       	ldi	r16, 0x14	; 20
    c6b8:	47 c0       	rjmp	.+142    	; 0xc748 <rs485rollerHello+0x386>
    c6ba:	f7 01       	movw	r30, r14
    c6bc:	81 91       	ld	r24, Z+
    c6be:	7f 01       	movw	r14, r30
    c6c0:	18 27       	eor	r17, r24
    c6c2:	01 2e       	mov	r0, r17
    c6c4:	02 94       	swap	r0
    c6c6:	90 2d       	mov	r25, r0
    c6c8:	9f 70       	andi	r25, 0x0F	; 15
    c6ca:	91 27       	eor	r25, r17
    c6cc:	81 2f       	mov	r24, r17
    c6ce:	80 25       	eor	r24, r0
    c6d0:	88 0f       	add	r24, r24
    c6d2:	80 7e       	andi	r24, 0xE0	; 224
    c6d4:	98 27       	eor	r25, r24
    c6d6:	80 2d       	mov	r24, r0
    c6d8:	81 27       	eor	r24, r17
    c6da:	80 7f       	andi	r24, 0xF0	; 240
    c6dc:	86 95       	lsr	r24
    c6de:	01 2e       	mov	r0, r17
    c6e0:	00 0c       	add	r0, r0
    c6e2:	88 1f       	adc	r24, r24
    c6e4:	16 95       	lsr	r17
    c6e6:	16 95       	lsr	r17
    c6e8:	16 95       	lsr	r17
    c6ea:	1f 71       	andi	r17, 0x1F	; 31
    c6ec:	18 27       	eor	r17, r24
    c6ee:	10 27       	eor	r17, r16
    c6f0:	09 2f       	mov	r16, r25
  
  crc = _crc_xmodem_update(crc, data);
  memset(response, 0, maxSize);
  maxSize = data;
  
  for (data=0; data < maxSize; data++)
    c6f2:	89 81       	ldd	r24, Y+1	; 0x01
    c6f4:	8f 5f       	subi	r24, 0xFF	; 255
    c6f6:	89 83       	std	Y+1, r24	; 0x01
    c6f8:	89 81       	ldd	r24, Y+1	; 0x01
    c6fa:	8d 15       	cp	r24, r13
    c6fc:	08 f4       	brcc	.+2      	; 0xc700 <rs485rollerHello+0x33e>
    c6fe:	d5 cf       	rjmp	.-86     	; 0xc6aa <rs485rollerHello+0x2e8>
    response++; 
  }

  uint8_t crcHi;
  uint8_t crcLo;
  if(rs485Receive(&crcHi, 1) != pdTRUE)
    c700:	ce 01       	movw	r24, r28
    c702:	02 96       	adiw	r24, 0x02	; 2
    c704:	61 e0       	ldi	r22, 0x01	; 1
    c706:	0e 94 24 12 	call	0x2448	; 0x2448 <rs485Receive>
    c70a:	81 30       	cpi	r24, 0x01	; 1
    c70c:	11 f0       	breq	.+4      	; 0xc712 <rs485rollerHello+0x350>
    c70e:	05 e1       	ldi	r16, 0x15	; 21
    c710:	1b c0       	rjmp	.+54     	; 0xc748 <rs485rollerHello+0x386>
    return 21;
  
  if(xQueueReceive(xRs485Rec, &crcLo, 1) != pdTRUE)
    c712:	80 91 b3 0e 	lds	r24, 0x0EB3
    c716:	90 91 b4 0e 	lds	r25, 0x0EB4
    c71a:	be 01       	movw	r22, r28
    c71c:	6d 5f       	subi	r22, 0xFD	; 253
    c71e:	7f 4f       	sbci	r23, 0xFF	; 255
    c720:	41 e0       	ldi	r20, 0x01	; 1
    c722:	50 e0       	ldi	r21, 0x00	; 0
    c724:	20 e0       	ldi	r18, 0x00	; 0
    c726:	0e 94 cb 6b 	call	0xd796	; 0xd796 <xQueueGenericReceive>
    c72a:	81 30       	cpi	r24, 0x01	; 1
    c72c:	11 f0       	breq	.+4      	; 0xc732 <rs485rollerHello+0x370>
    c72e:	06 e1       	ldi	r16, 0x16	; 22
    c730:	0b c0       	rjmp	.+22     	; 0xc748 <rs485rollerHello+0x386>
    return 22;

  if (crcHi != (uint8_t)(crc>>8))
    c732:	8a 81       	ldd	r24, Y+2	; 0x02
    c734:	81 17       	cp	r24, r17
    c736:	11 f0       	breq	.+4      	; 0xc73c <rs485rollerHello+0x37a>
    c738:	0e ef       	ldi	r16, 0xFE	; 254
    c73a:	06 c0       	rjmp	.+12     	; 0xc748 <rs485rollerHello+0x386>
    return 254;
  if (crcLo != (uint8_t)(crc & 0xFF))
    c73c:	8b 81       	ldd	r24, Y+3	; 0x03
    c73e:	80 17       	cp	r24, r16
    c740:	11 f4       	brne	.+4      	; 0xc746 <rs485rollerHello+0x384>
    c742:	00 e0       	ldi	r16, 0x00	; 0
    c744:	01 c0       	rjmp	.+2      	; 0xc748 <rs485rollerHello+0x386>
    c746:	0f ef       	ldi	r16, 0xFF	; 255
  }
  
  takeRs485();
  sendHello(devAddr);
  uint8_t result = receiveHello((tmp->response.data), HELLO_RESP_LEN); 
  releaseRs485();
    c748:	0e 94 49 11 	call	0x2292	; 0x2292 <releaseRs485>
    c74c:	01 c0       	rjmp	.+2      	; 0xc750 <rs485rollerHello+0x38e>
  return result;
    c74e:	01 e0       	ldi	r16, 0x01	; 1
}
    c750:	80 2f       	mov	r24, r16
    c752:	0f 90       	pop	r0
    c754:	0f 90       	pop	r0
    c756:	0f 90       	pop	r0
    c758:	cf 91       	pop	r28
    c75a:	df 91       	pop	r29
    c75c:	1f 91       	pop	r17
    c75e:	0f 91       	pop	r16
    c760:	ff 90       	pop	r15
    c762:	ef 90       	pop	r14
    c764:	df 90       	pop	r13
    c766:	cf 90       	pop	r12
    c768:	bf 90       	pop	r11
    c76a:	af 90       	pop	r10
    c76c:	08 95       	ret

0000c76e <rollersMemInit>:

// ************************ Rs485 API ************************************

void rollersMemInit(void)
{
  rollers = xmalloc(MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    c76e:	84 e6       	ldi	r24, 0x64	; 100
    c770:	90 e0       	ldi	r25, 0x00	; 0
    c772:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <xmalloc>
    c776:	80 93 bf 0e 	sts	0x0EBF, r24
    c77a:	90 93 c0 0e 	sts	0x0EC0, r25
  memset(rollers, 0, MAX_NUMBER_OF_ROLLERS * sizeof(struct sterRolet));
    c77e:	fc 01       	movw	r30, r24
    c780:	84 e6       	ldi	r24, 0x64	; 100
    c782:	df 01       	movw	r26, r30
    c784:	1d 92       	st	X+, r1
    c786:	8a 95       	dec	r24
    c788:	e9 f7       	brne	.-6      	; 0xc784 <rollersMemInit+0x16>
}
    c78a:	08 95       	ret

0000c78c <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		portENTER_CRITICAL();
    c78c:	0f b6       	in	r0, 0x3f	; 63
    c78e:	f8 94       	cli
    c790:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    c792:	00 97       	sbiw	r24, 0x00	; 0
    c794:	29 f4       	brne	.+10     	; 0xc7a0 <uxTaskPriorityGet+0x14>
    c796:	e0 91 a8 01 	lds	r30, 0x01A8
    c79a:	f0 91 a9 01 	lds	r31, 0x01A9
    c79e:	01 c0       	rjmp	.+2      	; 0xc7a2 <uxTaskPriorityGet+0x16>
    c7a0:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portEXIT_CRITICAL();
    c7a2:	0f 90       	pop	r0
    c7a4:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    c7a6:	86 89       	ldd	r24, Z+22	; 0x16
    c7a8:	08 95       	ret

0000c7aa <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    c7aa:	fc 01       	movw	r30, r24

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    c7ac:	82 85       	ldd	r24, Z+10	; 0x0a
    c7ae:	93 85       	ldd	r25, Z+11	; 0x0b
    c7b0:	80 5f       	subi	r24, 0xF0	; 240
    c7b2:	91 40       	sbci	r25, 0x01	; 1
    c7b4:	59 f4       	brne	.+22     	; 0xc7cc <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    c7b6:	84 89       	ldd	r24, Z+20	; 0x14
    c7b8:	95 89       	ldd	r25, Z+21	; 0x15
    c7ba:	21 e0       	ldi	r18, 0x01	; 1
    c7bc:	87 3e       	cpi	r24, 0xE7	; 231
    c7be:	92 07       	cpc	r25, r18
    c7c0:	29 f0       	breq	.+10     	; 0xc7cc <xTaskIsTaskSuspended+0x22>
    c7c2:	20 e0       	ldi	r18, 0x00	; 0
    c7c4:	89 2b       	or	r24, r25
    c7c6:	19 f4       	brne	.+6      	; 0xc7ce <xTaskIsTaskSuspended+0x24>
    c7c8:	21 e0       	ldi	r18, 0x01	; 1
    c7ca:	01 c0       	rjmp	.+2      	; 0xc7ce <xTaskIsTaskSuspended+0x24>
    c7cc:	20 e0       	ldi	r18, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    c7ce:	82 2f       	mov	r24, r18
    c7d0:	08 95       	ret

0000c7d2 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    c7d2:	80 91 ae 01 	lds	r24, 0x01AE
    c7d6:	8f 5f       	subi	r24, 0xFF	; 255
    c7d8:	80 93 ae 01 	sts	0x01AE, r24
}
    c7dc:	08 95       	ret

0000c7de <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    c7de:	0f b6       	in	r0, 0x3f	; 63
    c7e0:	f8 94       	cli
    c7e2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    c7e4:	20 91 ac 01 	lds	r18, 0x01AC
    c7e8:	30 91 ad 01 	lds	r19, 0x01AD
	}
	portEXIT_CRITICAL();
    c7ec:	0f 90       	pop	r0
    c7ee:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    c7f0:	c9 01       	movw	r24, r18
    c7f2:	08 95       	ret

0000c7f4 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    c7f4:	80 91 b3 01 	lds	r24, 0x01B3
}
    c7f8:	08 95       	ret

0000c7fa <vTaskStartTrace>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
	{
		portENTER_CRITICAL();
    c7fa:	0f b6       	in	r0, 0x3f	; 63
    c7fc:	f8 94       	cli
    c7fe:	0f 92       	push	r0
		{
			pcTraceBuffer = ( signed char * )pcBuffer;
    c800:	90 93 fa 01 	sts	0x01FA, r25
    c804:	80 93 f9 01 	sts	0x01F9, r24
			pcTraceBufferStart = pcBuffer;
    c808:	90 93 fc 01 	sts	0x01FC, r25
    c80c:	80 93 fb 01 	sts	0x01FB, r24
			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
    c810:	48 50       	subi	r20, 0x08	; 8
    c812:	50 40       	sbci	r21, 0x00	; 0
    c814:	48 0f       	add	r20, r24
    c816:	59 1f       	adc	r21, r25
    c818:	50 93 fe 01 	sts	0x01FE, r21
    c81c:	40 93 fd 01 	sts	0x01FD, r20
			xTracing = pdTRUE;
    c820:	81 e0       	ldi	r24, 0x01	; 1
    c822:	80 93 b0 01 	sts	0x01B0, r24
		}
		portEXIT_CRITICAL();
    c826:	0f 90       	pop	r0
    c828:	0f be       	out	0x3f, r0	; 63
	}
    c82a:	08 95       	ret

0000c82c <ulTaskEndTrace>:

	unsigned long ulTaskEndTrace( void )
	{
	unsigned long ulBufferLength;

		portENTER_CRITICAL();
    c82c:	0f b6       	in	r0, 0x3f	; 63
    c82e:	f8 94       	cli
    c830:	0f 92       	push	r0
			xTracing = pdFALSE;
    c832:	10 92 b0 01 	sts	0x01B0, r1
		portEXIT_CRITICAL();
    c836:	0f 90       	pop	r0
    c838:	0f be       	out	0x3f, r0	; 63

		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
    c83a:	20 91 f9 01 	lds	r18, 0x01F9
    c83e:	30 91 fa 01 	lds	r19, 0x01FA
    c842:	80 91 fb 01 	lds	r24, 0x01FB
    c846:	90 91 fc 01 	lds	r25, 0x01FC
    c84a:	28 1b       	sub	r18, r24
    c84c:	39 0b       	sbc	r19, r25
    c84e:	44 27       	eor	r20, r20
    c850:	37 fd       	sbrc	r19, 7
    c852:	40 95       	com	r20
    c854:	54 2f       	mov	r21, r20

		return ulBufferLength;
	}
    c856:	b9 01       	movw	r22, r18
    c858:	ca 01       	movw	r24, r20
    c85a:	08 95       	ret

0000c85c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    c85c:	80 91 ae 01 	lds	r24, 0x01AE
    c860:	88 23       	and	r24, r24
    c862:	51 f0       	breq	.+20     	; 0xc878 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    c864:	81 e0       	ldi	r24, 0x01	; 1
    c866:	80 93 aa 01 	sts	0x01AA, r24
    c86a:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    c86c:	80 91 af 01 	lds	r24, 0x01AF
    c870:	81 50       	subi	r24, 0x01	; 1
    c872:	80 93 af 01 	sts	0x01AF, r24
    c876:	01 c0       	rjmp	.+2      	; 0xc87a <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    c878:	99 e0       	ldi	r25, 0x09	; 9
    c87a:	e0 91 af 01 	lds	r30, 0x01AF
    c87e:	e9 9f       	mul	r30, r25
    c880:	f0 01       	movw	r30, r0
    c882:	11 24       	eor	r1, r1
    c884:	ea 54       	subi	r30, 0x4A	; 74
    c886:	fe 4f       	sbci	r31, 0xFE	; 254
    c888:	80 81       	ld	r24, Z
    c88a:	88 23       	and	r24, r24
    c88c:	79 f3       	breq	.-34     	; 0xc86c <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    c88e:	90 91 af 01 	lds	r25, 0x01AF
    c892:	89 e0       	ldi	r24, 0x09	; 9
    c894:	98 9f       	mul	r25, r24
    c896:	d0 01       	movw	r26, r0
    c898:	11 24       	eor	r1, r1
    c89a:	aa 54       	subi	r26, 0x4A	; 74
    c89c:	be 4f       	sbci	r27, 0xFE	; 254
    c89e:	11 96       	adiw	r26, 0x01	; 1
    c8a0:	ed 91       	ld	r30, X+
    c8a2:	fc 91       	ld	r31, X
    c8a4:	12 97       	sbiw	r26, 0x02	; 2
    c8a6:	02 80       	ldd	r0, Z+2	; 0x02
    c8a8:	f3 81       	ldd	r31, Z+3	; 0x03
    c8aa:	e0 2d       	mov	r30, r0
    c8ac:	12 96       	adiw	r26, 0x02	; 2
    c8ae:	fc 93       	st	X, r31
    c8b0:	ee 93       	st	-X, r30
    c8b2:	11 97       	sbiw	r26, 0x01	; 1
    c8b4:	cd 01       	movw	r24, r26
    c8b6:	03 96       	adiw	r24, 0x03	; 3
    c8b8:	e8 17       	cp	r30, r24
    c8ba:	f9 07       	cpc	r31, r25
    c8bc:	31 f4       	brne	.+12     	; 0xc8ca <vTaskSwitchContext+0x6e>
    c8be:	82 81       	ldd	r24, Z+2	; 0x02
    c8c0:	93 81       	ldd	r25, Z+3	; 0x03
    c8c2:	12 96       	adiw	r26, 0x02	; 2
    c8c4:	9c 93       	st	X, r25
    c8c6:	8e 93       	st	-X, r24
    c8c8:	11 97       	sbiw	r26, 0x01	; 1
    c8ca:	11 96       	adiw	r26, 0x01	; 1
    c8cc:	ed 91       	ld	r30, X+
    c8ce:	fc 91       	ld	r31, X
    c8d0:	12 97       	sbiw	r26, 0x02	; 2
    c8d2:	86 81       	ldd	r24, Z+6	; 0x06
    c8d4:	97 81       	ldd	r25, Z+7	; 0x07
    c8d6:	90 93 a9 01 	sts	0x01A9, r25
    c8da:	80 93 a8 01 	sts	0x01A8, r24

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
    c8de:	80 91 b0 01 	lds	r24, 0x01B0
    c8e2:	88 23       	and	r24, r24
    c8e4:	09 f4       	brne	.+2      	; 0xc8e8 <vTaskSwitchContext+0x8c>
    c8e6:	4b c0       	rjmp	.+150    	; 0xc97e <vTaskSwitchContext+0x122>
    c8e8:	e0 91 a8 01 	lds	r30, 0x01A8
    c8ec:	f0 91 a9 01 	lds	r31, 0x01A9
    c8f0:	90 91 81 01 	lds	r25, 0x0181
    c8f4:	83 a1       	ldd	r24, Z+35	; 0x23
    c8f6:	98 17       	cp	r25, r24
    c8f8:	09 f4       	brne	.+2      	; 0xc8fc <vTaskSwitchContext+0xa0>
    c8fa:	41 c0       	rjmp	.+130    	; 0xc97e <vTaskSwitchContext+0x122>
    c8fc:	80 91 f9 01 	lds	r24, 0x01F9
    c900:	90 91 fa 01 	lds	r25, 0x01FA
    c904:	08 96       	adiw	r24, 0x08	; 8
    c906:	20 91 fd 01 	lds	r18, 0x01FD
    c90a:	30 91 fe 01 	lds	r19, 0x01FE
    c90e:	82 17       	cp	r24, r18
    c910:	93 07       	cpc	r25, r19
    c912:	98 f5       	brcc	.+102    	; 0xc97a <vTaskSwitchContext+0x11e>
    c914:	e0 91 a8 01 	lds	r30, 0x01A8
    c918:	f0 91 a9 01 	lds	r31, 0x01A9
    c91c:	23 a1       	ldd	r18, Z+35	; 0x23
    c91e:	20 93 81 01 	sts	0x0181, r18
    c922:	e0 91 f9 01 	lds	r30, 0x01F9
    c926:	f0 91 fa 01 	lds	r31, 0x01FA
    c92a:	80 91 ac 01 	lds	r24, 0x01AC
    c92e:	90 91 ad 01 	lds	r25, 0x01AD
    c932:	a0 e0       	ldi	r26, 0x00	; 0
    c934:	b0 e0       	ldi	r27, 0x00	; 0
    c936:	80 83       	st	Z, r24
    c938:	91 83       	std	Z+1, r25	; 0x01
    c93a:	a2 83       	std	Z+2, r26	; 0x02
    c93c:	b3 83       	std	Z+3, r27	; 0x03
    c93e:	80 91 f9 01 	lds	r24, 0x01F9
    c942:	90 91 fa 01 	lds	r25, 0x01FA
    c946:	04 96       	adiw	r24, 0x04	; 4
    c948:	90 93 fa 01 	sts	0x01FA, r25
    c94c:	80 93 f9 01 	sts	0x01F9, r24
    c950:	e0 91 f9 01 	lds	r30, 0x01F9
    c954:	f0 91 fa 01 	lds	r31, 0x01FA
    c958:	30 e0       	ldi	r19, 0x00	; 0
    c95a:	40 e0       	ldi	r20, 0x00	; 0
    c95c:	50 e0       	ldi	r21, 0x00	; 0
    c95e:	20 83       	st	Z, r18
    c960:	31 83       	std	Z+1, r19	; 0x01
    c962:	42 83       	std	Z+2, r20	; 0x02
    c964:	53 83       	std	Z+3, r21	; 0x03
    c966:	80 91 f9 01 	lds	r24, 0x01F9
    c96a:	90 91 fa 01 	lds	r25, 0x01FA
    c96e:	04 96       	adiw	r24, 0x04	; 4
    c970:	90 93 fa 01 	sts	0x01FA, r25
    c974:	80 93 f9 01 	sts	0x01F9, r24
    c978:	08 95       	ret
    c97a:	10 92 b0 01 	sts	0x01B0, r1
    c97e:	08 95       	ret

0000c980 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    c980:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    c982:	80 91 ab 01 	lds	r24, 0x01AB
    c986:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    c988:	80 91 ac 01 	lds	r24, 0x01AC
    c98c:	90 91 ad 01 	lds	r25, 0x01AD
    c990:	92 83       	std	Z+2, r25	; 0x02
    c992:	81 83       	std	Z+1, r24	; 0x01
}
    c994:	08 95       	ret

0000c996 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    c996:	fc 01       	movw	r30, r24
    c998:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    c99a:	0f b6       	in	r0, 0x3f	; 63
    c99c:	f8 94       	cli
    c99e:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    c9a0:	4d 91       	ld	r20, X+
    c9a2:	5c 91       	ld	r21, X
    c9a4:	11 97       	sbiw	r26, 0x01	; 1
    c9a6:	8f ef       	ldi	r24, 0xFF	; 255
    c9a8:	4f 3f       	cpi	r20, 0xFF	; 255
    c9aa:	58 07       	cpc	r21, r24
    c9ac:	61 f1       	breq	.+88     	; 0xca06 <xTaskCheckForTimeOut+0x70>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    c9ae:	90 91 ab 01 	lds	r25, 0x01AB
    c9b2:	80 81       	ld	r24, Z
    c9b4:	98 17       	cp	r25, r24
    c9b6:	49 f0       	breq	.+18     	; 0xc9ca <xTaskCheckForTimeOut+0x34>
    c9b8:	20 91 ac 01 	lds	r18, 0x01AC
    c9bc:	30 91 ad 01 	lds	r19, 0x01AD
    c9c0:	81 81       	ldd	r24, Z+1	; 0x01
    c9c2:	92 81       	ldd	r25, Z+2	; 0x02
    c9c4:	28 17       	cp	r18, r24
    c9c6:	39 07       	cpc	r19, r25
    c9c8:	00 f5       	brcc	.+64     	; 0xca0a <xTaskCheckForTimeOut+0x74>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    c9ca:	80 91 ac 01 	lds	r24, 0x01AC
    c9ce:	90 91 ad 01 	lds	r25, 0x01AD
    c9d2:	21 81       	ldd	r18, Z+1	; 0x01
    c9d4:	32 81       	ldd	r19, Z+2	; 0x02
    c9d6:	82 1b       	sub	r24, r18
    c9d8:	93 0b       	sbc	r25, r19
    c9da:	84 17       	cp	r24, r20
    c9dc:	95 07       	cpc	r25, r21
    c9de:	a8 f4       	brcc	.+42     	; 0xca0a <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    c9e0:	80 91 ac 01 	lds	r24, 0x01AC
    c9e4:	90 91 ad 01 	lds	r25, 0x01AD
    c9e8:	28 1b       	sub	r18, r24
    c9ea:	39 0b       	sbc	r19, r25
    c9ec:	24 0f       	add	r18, r20
    c9ee:	35 1f       	adc	r19, r21
    c9f0:	2d 93       	st	X+, r18
    c9f2:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    c9f4:	80 91 ab 01 	lds	r24, 0x01AB
    c9f8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    c9fa:	80 91 ac 01 	lds	r24, 0x01AC
    c9fe:	90 91 ad 01 	lds	r25, 0x01AD
    ca02:	92 83       	std	Z+2, r25	; 0x02
    ca04:	81 83       	std	Z+1, r24	; 0x01
    ca06:	80 e0       	ldi	r24, 0x00	; 0
    ca08:	01 c0       	rjmp	.+2      	; 0xca0c <xTaskCheckForTimeOut+0x76>
    ca0a:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    ca0c:	0f 90       	pop	r0
    ca0e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    ca10:	08 95       	ret

0000ca12 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    ca12:	81 e0       	ldi	r24, 0x01	; 1
    ca14:	80 93 aa 01 	sts	0x01AA, r24
}
    ca18:	08 95       	ret

0000ca1a <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    ca1a:	0f 93       	push	r16
    ca1c:	1f 93       	push	r17
    ca1e:	cf 93       	push	r28
    ca20:	df 93       	push	r29
    ca22:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    ca24:	80 81       	ld	r24, Z
    ca26:	88 23       	and	r24, r24
    ca28:	19 f4       	brne	.+6      	; 0xca30 <xTaskRemoveFromEventList+0x16>
    ca2a:	c0 e0       	ldi	r28, 0x00	; 0
    ca2c:	d0 e0       	ldi	r29, 0x00	; 0
    ca2e:	05 c0       	rjmp	.+10     	; 0xca3a <xTaskRemoveFromEventList+0x20>
    ca30:	05 80       	ldd	r0, Z+5	; 0x05
    ca32:	f6 81       	ldd	r31, Z+6	; 0x06
    ca34:	e0 2d       	mov	r30, r0
    ca36:	c6 81       	ldd	r28, Z+6	; 0x06
    ca38:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    ca3a:	8e 01       	movw	r16, r28
    ca3c:	04 5f       	subi	r16, 0xF4	; 244
    ca3e:	1f 4f       	sbci	r17, 0xFF	; 255
    ca40:	c8 01       	movw	r24, r16
    ca42:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    ca46:	80 91 ae 01 	lds	r24, 0x01AE
    ca4a:	88 23       	and	r24, r24
    ca4c:	a1 f4       	brne	.+40     	; 0xca76 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    ca4e:	8e 01       	movw	r16, r28
    ca50:	0e 5f       	subi	r16, 0xFE	; 254
    ca52:	1f 4f       	sbci	r17, 0xFF	; 255
    ca54:	c8 01       	movw	r24, r16
    ca56:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    ca5a:	9e 89       	ldd	r25, Y+22	; 0x16
    ca5c:	80 91 af 01 	lds	r24, 0x01AF
    ca60:	89 17       	cp	r24, r25
    ca62:	10 f4       	brcc	.+4      	; 0xca68 <xTaskRemoveFromEventList+0x4e>
    ca64:	90 93 af 01 	sts	0x01AF, r25
    ca68:	89 e0       	ldi	r24, 0x09	; 9
    ca6a:	98 9f       	mul	r25, r24
    ca6c:	c0 01       	movw	r24, r0
    ca6e:	11 24       	eor	r1, r1
    ca70:	8a 54       	subi	r24, 0x4A	; 74
    ca72:	9e 4f       	sbci	r25, 0xFE	; 254
    ca74:	02 c0       	rjmp	.+4      	; 0xca7a <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    ca76:	87 ee       	ldi	r24, 0xE7	; 231
    ca78:	91 e0       	ldi	r25, 0x01	; 1
    ca7a:	b8 01       	movw	r22, r16
    ca7c:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    ca80:	e0 91 a8 01 	lds	r30, 0x01A8
    ca84:	f0 91 a9 01 	lds	r31, 0x01A9
    ca88:	20 e0       	ldi	r18, 0x00	; 0
    ca8a:	9e 89       	ldd	r25, Y+22	; 0x16
    ca8c:	86 89       	ldd	r24, Z+22	; 0x16
    ca8e:	98 17       	cp	r25, r24
    ca90:	08 f0       	brcs	.+2      	; 0xca94 <xTaskRemoveFromEventList+0x7a>
    ca92:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    ca94:	82 2f       	mov	r24, r18
    ca96:	df 91       	pop	r29
    ca98:	cf 91       	pop	r28
    ca9a:	1f 91       	pop	r17
    ca9c:	0f 91       	pop	r16
    ca9e:	08 95       	ret

0000caa0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    caa0:	df 92       	push	r13
    caa2:	ef 92       	push	r14
    caa4:	ff 92       	push	r15
    caa6:	0f 93       	push	r16
    caa8:	1f 93       	push	r17
    caaa:	cf 93       	push	r28
    caac:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
    caae:	ec 01       	movw	r28, r24
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    cab0:	8a 85       	ldd	r24, Y+10	; 0x0a
    cab2:	9b 85       	ldd	r25, Y+11	; 0x0b
    cab4:	80 5f       	subi	r24, 0xF0	; 240
    cab6:	91 40       	sbci	r25, 0x01	; 1
    cab8:	91 f5       	brne	.+100    	; 0xcb1e <xTaskResumeFromISR+0x7e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    caba:	8c 89       	ldd	r24, Y+20	; 0x14
    cabc:	9d 89       	ldd	r25, Y+21	; 0x15
    cabe:	21 e0       	ldi	r18, 0x01	; 1
    cac0:	87 3e       	cpi	r24, 0xE7	; 231
    cac2:	92 07       	cpc	r25, r18
    cac4:	61 f1       	breq	.+88     	; 0xcb1e <xTaskResumeFromISR+0x7e>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    cac6:	89 2b       	or	r24, r25
    cac8:	51 f5       	brne	.+84     	; 0xcb1e <xTaskResumeFromISR+0x7e>
    caca:	33 c0       	rjmp	.+102    	; 0xcb32 <xTaskResumeFromISR+0x92>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    cacc:	de 88       	ldd	r13, Y+22	; 0x16
    cace:	e0 91 a8 01 	lds	r30, 0x01A8
    cad2:	f0 91 a9 01 	lds	r31, 0x01A9
    cad6:	06 89       	ldd	r16, Z+22	; 0x16
				vListRemove(  &( pxTCB->xGenericListItem ) );
    cad8:	82 e0       	ldi	r24, 0x02	; 2
    cada:	e8 2e       	mov	r14, r24
    cadc:	f1 2c       	mov	r15, r1
    cade:	ec 0e       	add	r14, r28
    cae0:	fd 1e       	adc	r15, r29
    cae2:	c7 01       	movw	r24, r14
    cae4:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    cae8:	6e 89       	ldd	r22, Y+22	; 0x16
    caea:	80 91 af 01 	lds	r24, 0x01AF
    caee:	86 17       	cp	r24, r22
    caf0:	10 f4       	brcc	.+4      	; 0xcaf6 <xTaskResumeFromISR+0x56>
    caf2:	60 93 af 01 	sts	0x01AF, r22
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    caf6:	10 e0       	ldi	r17, 0x00	; 0
    caf8:	d0 16       	cp	r13, r16
    cafa:	08 f0       	brcs	.+2      	; 0xcafe <xTaskResumeFromISR+0x5e>
    cafc:	11 e0       	ldi	r17, 0x01	; 1
				vListRemove(  &( pxTCB->xGenericListItem ) );
				prvAddTaskToReadyQueue( pxTCB );
    cafe:	89 e0       	ldi	r24, 0x09	; 9
    cb00:	68 9f       	mul	r22, r24
    cb02:	c0 01       	movw	r24, r0
    cb04:	11 24       	eor	r1, r1
    cb06:	8a 54       	subi	r24, 0x4A	; 74
    cb08:	9e 4f       	sbci	r25, 0xFE	; 254
    cb0a:	b7 01       	movw	r22, r14
    cb0c:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
    cb10:	07 c0       	rjmp	.+14     	; 0xcb20 <xTaskResumeFromISR+0x80>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    cb12:	2c 96       	adiw	r28, 0x0c	; 12
    cb14:	87 ee       	ldi	r24, 0xE7	; 231
    cb16:	91 e0       	ldi	r25, 0x01	; 1
    cb18:	be 01       	movw	r22, r28
    cb1a:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
    cb1e:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		return xYieldRequired;
	}
    cb20:	81 2f       	mov	r24, r17
    cb22:	df 91       	pop	r29
    cb24:	cf 91       	pop	r28
    cb26:	1f 91       	pop	r17
    cb28:	0f 91       	pop	r16
    cb2a:	ff 90       	pop	r15
    cb2c:	ef 90       	pop	r14
    cb2e:	df 90       	pop	r13
    cb30:	08 95       	ret

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    cb32:	80 91 ae 01 	lds	r24, 0x01AE
    cb36:	88 23       	and	r24, r24
    cb38:	49 f2       	breq	.-110    	; 0xcacc <xTaskResumeFromISR+0x2c>
    cb3a:	eb cf       	rjmp	.-42     	; 0xcb12 <xTaskResumeFromISR+0x72>

0000cb3c <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    cb3c:	cf 93       	push	r28
    cb3e:	df 93       	push	r29
    cb40:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    cb42:	60 91 a8 01 	lds	r22, 0x01A8
    cb46:	70 91 a9 01 	lds	r23, 0x01A9
    cb4a:	64 5f       	subi	r22, 0xF4	; 244
    cb4c:	7f 4f       	sbci	r23, 0xFF	; 255
    cb4e:	0e 94 2f 6e 	call	0xdc5e	; 0xdc5e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    cb52:	80 91 a8 01 	lds	r24, 0x01A8
    cb56:	90 91 a9 01 	lds	r25, 0x01A9
    cb5a:	02 96       	adiw	r24, 0x02	; 2
    cb5c:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    cb60:	8f ef       	ldi	r24, 0xFF	; 255
    cb62:	cf 3f       	cpi	r28, 0xFF	; 255
    cb64:	d8 07       	cpc	r29, r24
    cb66:	59 f4       	brne	.+22     	; 0xcb7e <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    cb68:	60 91 a8 01 	lds	r22, 0x01A8
    cb6c:	70 91 a9 01 	lds	r23, 0x01A9
    cb70:	6e 5f       	subi	r22, 0xFE	; 254
    cb72:	7f 4f       	sbci	r23, 0xFF	; 255
    cb74:	80 ef       	ldi	r24, 0xF0	; 240
    cb76:	91 e0       	ldi	r25, 0x01	; 1
    cb78:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
    cb7c:	24 c0       	rjmp	.+72     	; 0xcbc6 <vTaskPlaceOnEventList+0x8a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    cb7e:	80 91 ac 01 	lds	r24, 0x01AC
    cb82:	90 91 ad 01 	lds	r25, 0x01AD
    cb86:	8c 0f       	add	r24, r28
    cb88:	9d 1f       	adc	r25, r29

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    cb8a:	e0 91 a8 01 	lds	r30, 0x01A8
    cb8e:	f0 91 a9 01 	lds	r31, 0x01A9
    cb92:	93 83       	std	Z+3, r25	; 0x03
    cb94:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    cb96:	20 91 ac 01 	lds	r18, 0x01AC
    cb9a:	30 91 ad 01 	lds	r19, 0x01AD
    cb9e:	82 17       	cp	r24, r18
    cba0:	93 07       	cpc	r25, r19
    cba2:	28 f4       	brcc	.+10     	; 0xcbae <vTaskPlaceOnEventList+0x72>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    cba4:	80 91 e5 01 	lds	r24, 0x01E5
    cba8:	90 91 e6 01 	lds	r25, 0x01E6
    cbac:	04 c0       	rjmp	.+8      	; 0xcbb6 <vTaskPlaceOnEventList+0x7a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    cbae:	80 91 e3 01 	lds	r24, 0x01E3
    cbb2:	90 91 e4 01 	lds	r25, 0x01E4
    cbb6:	60 91 a8 01 	lds	r22, 0x01A8
    cbba:	70 91 a9 01 	lds	r23, 0x01A9
    cbbe:	6e 5f       	subi	r22, 0xFE	; 254
    cbc0:	7f 4f       	sbci	r23, 0xFF	; 255
    cbc2:	0e 94 2f 6e 	call	0xdc5e	; 0xdc5e <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    cbc6:	df 91       	pop	r29
    cbc8:	cf 91       	pop	r28
    cbca:	08 95       	ret

0000cbcc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    cbcc:	ff 92       	push	r15
    cbce:	0f 93       	push	r16
    cbd0:	1f 93       	push	r17
    cbd2:	cf 93       	push	r28
    cbd4:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    cbd6:	80 91 ae 01 	lds	r24, 0x01AE
    cbda:	88 23       	and	r24, r24
    cbdc:	09 f0       	breq	.+2      	; 0xcbe0 <vTaskIncrementTick+0x14>
    cbde:	61 c0       	rjmp	.+194    	; 0xcca2 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    cbe0:	80 91 ac 01 	lds	r24, 0x01AC
    cbe4:	90 91 ad 01 	lds	r25, 0x01AD
    cbe8:	01 96       	adiw	r24, 0x01	; 1
    cbea:	90 93 ad 01 	sts	0x01AD, r25
    cbee:	80 93 ac 01 	sts	0x01AC, r24
		if( xTickCount == ( portTickType ) 0 )
    cbf2:	80 91 ac 01 	lds	r24, 0x01AC
    cbf6:	90 91 ad 01 	lds	r25, 0x01AD
    cbfa:	89 2b       	or	r24, r25
    cbfc:	e9 f5       	brne	.+122    	; 0xcc78 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    cbfe:	80 91 e3 01 	lds	r24, 0x01E3
    cc02:	90 91 e4 01 	lds	r25, 0x01E4
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    cc06:	20 91 e5 01 	lds	r18, 0x01E5
    cc0a:	30 91 e6 01 	lds	r19, 0x01E6
    cc0e:	30 93 e4 01 	sts	0x01E4, r19
    cc12:	20 93 e3 01 	sts	0x01E3, r18
			pxOverflowDelayedTaskList = pxTemp;
    cc16:	90 93 e6 01 	sts	0x01E6, r25
    cc1a:	80 93 e5 01 	sts	0x01E5, r24
			xNumOfOverflows++;
    cc1e:	80 91 ab 01 	lds	r24, 0x01AB
    cc22:	8f 5f       	subi	r24, 0xFF	; 255
    cc24:	80 93 ab 01 	sts	0x01AB, r24
    cc28:	27 c0       	rjmp	.+78     	; 0xcc78 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    cc2a:	20 91 ac 01 	lds	r18, 0x01AC
    cc2e:	30 91 ad 01 	lds	r19, 0x01AD
    cc32:	8a 81       	ldd	r24, Y+2	; 0x02
    cc34:	9b 81       	ldd	r25, Y+3	; 0x03
    cc36:	28 17       	cp	r18, r24
    cc38:	39 07       	cpc	r19, r25
    cc3a:	d0 f1       	brcs	.+116    	; 0xccb0 <vTaskIncrementTick+0xe4>
    cc3c:	8e 01       	movw	r16, r28
    cc3e:	0e 5f       	subi	r16, 0xFE	; 254
    cc40:	1f 4f       	sbci	r17, 0xFF	; 255
    cc42:	c8 01       	movw	r24, r16
    cc44:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
    cc48:	8c 89       	ldd	r24, Y+20	; 0x14
    cc4a:	9d 89       	ldd	r25, Y+21	; 0x15
    cc4c:	89 2b       	or	r24, r25
    cc4e:	21 f0       	breq	.+8      	; 0xcc58 <vTaskIncrementTick+0x8c>
    cc50:	ce 01       	movw	r24, r28
    cc52:	0c 96       	adiw	r24, 0x0c	; 12
    cc54:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
    cc58:	9e 89       	ldd	r25, Y+22	; 0x16
    cc5a:	80 91 af 01 	lds	r24, 0x01AF
    cc5e:	89 17       	cp	r24, r25
    cc60:	10 f4       	brcc	.+4      	; 0xcc66 <vTaskIncrementTick+0x9a>
    cc62:	90 93 af 01 	sts	0x01AF, r25
    cc66:	9f 9d       	mul	r25, r15
    cc68:	c0 01       	movw	r24, r0
    cc6a:	11 24       	eor	r1, r1
    cc6c:	8a 54       	subi	r24, 0x4A	; 74
    cc6e:	9e 4f       	sbci	r25, 0xFE	; 254
    cc70:	b8 01       	movw	r22, r16
    cc72:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
    cc76:	02 c0       	rjmp	.+4      	; 0xcc7c <vTaskIncrementTick+0xb0>
    cc78:	99 e0       	ldi	r25, 0x09	; 9
    cc7a:	f9 2e       	mov	r15, r25
    cc7c:	e0 91 e3 01 	lds	r30, 0x01E3
    cc80:	f0 91 e4 01 	lds	r31, 0x01E4
    cc84:	80 81       	ld	r24, Z
    cc86:	88 23       	and	r24, r24
    cc88:	99 f0       	breq	.+38     	; 0xccb0 <vTaskIncrementTick+0xe4>
    cc8a:	e0 91 e3 01 	lds	r30, 0x01E3
    cc8e:	f0 91 e4 01 	lds	r31, 0x01E4
    cc92:	05 80       	ldd	r0, Z+5	; 0x05
    cc94:	f6 81       	ldd	r31, Z+6	; 0x06
    cc96:	e0 2d       	mov	r30, r0
    cc98:	c6 81       	ldd	r28, Z+6	; 0x06
    cc9a:	d7 81       	ldd	r29, Z+7	; 0x07
    cc9c:	20 97       	sbiw	r28, 0x00	; 0
    cc9e:	29 f6       	brne	.-118    	; 0xcc2a <vTaskIncrementTick+0x5e>
    cca0:	07 c0       	rjmp	.+14     	; 0xccb0 <vTaskIncrementTick+0xe4>
	}
	else
	{
		++uxMissedTicks;
    cca2:	80 91 b1 01 	lds	r24, 0x01B1
    cca6:	8f 5f       	subi	r24, 0xFF	; 255
    cca8:	80 93 b1 01 	sts	0x01B1, r24
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
    ccac:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
    ccb0:	80 91 b1 01 	lds	r24, 0x01B1
    ccb4:	88 23       	and	r24, r24
    ccb6:	11 f4       	brne	.+4      	; 0xccbc <vTaskIncrementTick+0xf0>
		{
			vApplicationTickHook();
    ccb8:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    ccbc:	df 91       	pop	r29
    ccbe:	cf 91       	pop	r28
    ccc0:	1f 91       	pop	r17
    ccc2:	0f 91       	pop	r16
    ccc4:	ff 90       	pop	r15
    ccc6:	08 95       	ret

0000ccc8 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
    ccc8:	4f 92       	push	r4
    ccca:	5f 92       	push	r5
    cccc:	6f 92       	push	r6
    ccce:	7f 92       	push	r7
    ccd0:	8f 92       	push	r8
    ccd2:	9f 92       	push	r9
    ccd4:	af 92       	push	r10
    ccd6:	bf 92       	push	r11
    ccd8:	cf 92       	push	r12
    ccda:	df 92       	push	r13
    ccdc:	ef 92       	push	r14
    ccde:	ff 92       	push	r15
    cce0:	0f 93       	push	r16
    cce2:	1f 93       	push	r17
    cce4:	cf 93       	push	r28
    cce6:	df 93       	push	r29
    cce8:	4c 01       	movw	r8, r24
    ccea:	8b 01       	movw	r16, r22
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    ccec:	db 01       	movw	r26, r22
    ccee:	11 96       	adiw	r26, 0x01	; 1
    ccf0:	ed 91       	ld	r30, X+
    ccf2:	fc 91       	ld	r31, X
    ccf4:	12 97       	sbiw	r26, 0x02	; 2
    ccf6:	02 80       	ldd	r0, Z+2	; 0x02
    ccf8:	f3 81       	ldd	r31, Z+3	; 0x03
    ccfa:	e0 2d       	mov	r30, r0
    ccfc:	12 96       	adiw	r26, 0x02	; 2
    ccfe:	fc 93       	st	X, r31
    cd00:	ee 93       	st	-X, r30
    cd02:	11 97       	sbiw	r26, 0x01	; 1
    cd04:	cb 01       	movw	r24, r22
    cd06:	03 96       	adiw	r24, 0x03	; 3
    cd08:	e8 17       	cp	r30, r24
    cd0a:	f9 07       	cpc	r31, r25
    cd0c:	31 f4       	brne	.+12     	; 0xcd1a <prvListTaskWithinSingleList+0x52>
    cd0e:	82 81       	ldd	r24, Z+2	; 0x02
    cd10:	93 81       	ldd	r25, Z+3	; 0x03
    cd12:	12 96       	adiw	r26, 0x02	; 2
    cd14:	9c 93       	st	X, r25
    cd16:	8e 93       	st	-X, r24
    cd18:	11 97       	sbiw	r26, 0x01	; 1
    cd1a:	d8 01       	movw	r26, r16
    cd1c:	11 96       	adiw	r26, 0x01	; 1
    cd1e:	ed 91       	ld	r30, X+
    cd20:	fc 91       	ld	r31, X
    cd22:	12 97       	sbiw	r26, 0x02	; 2
    cd24:	a6 80       	ldd	r10, Z+6	; 0x06
    cd26:	b7 80       	ldd	r11, Z+7	; 0x07
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    cd28:	53 e0       	ldi	r21, 0x03	; 3
    cd2a:	e5 2e       	mov	r14, r21
    cd2c:	f1 2c       	mov	r15, r1
    cd2e:	e0 0e       	add	r14, r16
    cd30:	f1 1e       	adc	r15, r17
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    cd32:	3f ef       	ldi	r19, 0xFF	; 255
    cd34:	63 2e       	mov	r6, r19
    cd36:	31 e0       	ldi	r19, 0x01	; 1
    cd38:	73 2e       	mov	r7, r19
    cd3a:	27 e6       	ldi	r18, 0x67	; 103
    cd3c:	42 2e       	mov	r4, r18
    cd3e:	21 e0       	ldi	r18, 0x01	; 1
    cd40:	52 2e       	mov	r5, r18
    cd42:	c4 2e       	mov	r12, r20
    cd44:	dd 24       	eor	r13, r13
    cd46:	c7 fc       	sbrc	r12, 7
    cd48:	d0 94       	com	r13

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    cd4a:	d8 01       	movw	r26, r16
    cd4c:	11 96       	adiw	r26, 0x01	; 1
    cd4e:	ed 91       	ld	r30, X+
    cd50:	fc 91       	ld	r31, X
    cd52:	12 97       	sbiw	r26, 0x02	; 2
    cd54:	82 81       	ldd	r24, Z+2	; 0x02
    cd56:	93 81       	ldd	r25, Z+3	; 0x03
    cd58:	12 96       	adiw	r26, 0x02	; 2
    cd5a:	9c 93       	st	X, r25
    cd5c:	8e 93       	st	-X, r24
    cd5e:	11 97       	sbiw	r26, 0x01	; 1
    cd60:	8e 15       	cp	r24, r14
    cd62:	9f 05       	cpc	r25, r15
    cd64:	39 f4       	brne	.+14     	; 0xcd74 <prvListTaskWithinSingleList+0xac>
    cd66:	f7 01       	movw	r30, r14
    cd68:	82 81       	ldd	r24, Z+2	; 0x02
    cd6a:	93 81       	ldd	r25, Z+3	; 0x03
    cd6c:	12 96       	adiw	r26, 0x02	; 2
    cd6e:	9c 93       	st	X, r25
    cd70:	8e 93       	st	-X, r24
    cd72:	11 97       	sbiw	r26, 0x01	; 1
    cd74:	d8 01       	movw	r26, r16
    cd76:	11 96       	adiw	r26, 0x01	; 1
    cd78:	ed 91       	ld	r30, X+
    cd7a:	fc 91       	ld	r31, X
    cd7c:	12 97       	sbiw	r26, 0x02	; 2
    cd7e:	c6 81       	ldd	r28, Z+6	; 0x06
    cd80:	d7 81       	ldd	r29, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
    cd82:	ef 89       	ldd	r30, Y+23	; 0x17
    cd84:	f8 8d       	ldd	r31, Y+24	; 0x18
    cd86:	20 e0       	ldi	r18, 0x00	; 0
    cd88:	30 e0       	ldi	r19, 0x00	; 0
    cd8a:	03 c0       	rjmp	.+6      	; 0xcd92 <prvListTaskWithinSingleList+0xca>
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
    cd8c:	31 96       	adiw	r30, 0x01	; 1
			usCount++;
    cd8e:	2f 5f       	subi	r18, 0xFF	; 255
    cd90:	3f 4f       	sbci	r19, 0xFF	; 255

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    cd92:	80 81       	ld	r24, Z
    cd94:	85 3a       	cpi	r24, 0xA5	; 165
    cd96:	d1 f3       	breq	.-12     	; 0xcd8c <prvListTaskWithinSingleList+0xc4>
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    cd98:	8e 89       	ldd	r24, Y+22	; 0x16
    cd9a:	9b a1       	ldd	r25, Y+35	; 0x23
    cd9c:	ed b7       	in	r30, 0x3d	; 61
    cd9e:	fe b7       	in	r31, 0x3e	; 62
    cda0:	3e 97       	sbiw	r30, 0x0e	; 14
    cda2:	0f b6       	in	r0, 0x3f	; 63
    cda4:	f8 94       	cli
    cda6:	fe bf       	out	0x3e, r31	; 62
    cda8:	0f be       	out	0x3f, r0	; 63
    cdaa:	ed bf       	out	0x3d, r30	; 61
    cdac:	31 96       	adiw	r30, 0x01	; 1
    cdae:	ad b7       	in	r26, 0x3d	; 61
    cdb0:	be b7       	in	r27, 0x3e	; 62
    cdb2:	12 96       	adiw	r26, 0x02	; 2
    cdb4:	7c 92       	st	X, r7
    cdb6:	6e 92       	st	-X, r6
    cdb8:	11 97       	sbiw	r26, 0x01	; 1
    cdba:	53 82       	std	Z+3, r5	; 0x03
    cdbc:	42 82       	std	Z+2, r4	; 0x02
    cdbe:	69 96       	adiw	r28, 0x19	; 25
    cdc0:	d5 83       	std	Z+5, r29	; 0x05
    cdc2:	c4 83       	std	Z+4, r28	; 0x04
    cdc4:	69 97       	sbiw	r28, 0x19	; 25
    cdc6:	d7 82       	std	Z+7, r13	; 0x07
    cdc8:	c6 82       	std	Z+6, r12	; 0x06
    cdca:	80 87       	std	Z+8, r24	; 0x08
    cdcc:	11 86       	std	Z+9, r1	; 0x09
    cdce:	33 87       	std	Z+11, r19	; 0x0b
    cdd0:	22 87       	std	Z+10, r18	; 0x0a
    cdd2:	94 87       	std	Z+12, r25	; 0x0c
    cdd4:	15 86       	std	Z+13, r1	; 0x0d
    cdd6:	0e 94 8c 75 	call	0xeb18	; 0xeb18 <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
    cdda:	ed b7       	in	r30, 0x3d	; 61
    cddc:	fe b7       	in	r31, 0x3e	; 62
    cdde:	3e 96       	adiw	r30, 0x0e	; 14
    cde0:	0f b6       	in	r0, 0x3f	; 63
    cde2:	f8 94       	cli
    cde4:	fe bf       	out	0x3e, r31	; 62
    cde6:	0f be       	out	0x3f, r0	; 63
    cde8:	ed bf       	out	0x3d, r30	; 61
    cdea:	c4 01       	movw	r24, r8
    cdec:	b3 01       	movw	r22, r6
    cdee:	0e 94 6a 74 	call	0xe8d4	; 0xe8d4 <strcat>

		} while( pxNextTCB != pxFirstTCB );
    cdf2:	ca 15       	cp	r28, r10
    cdf4:	db 05       	cpc	r29, r11
    cdf6:	09 f0       	breq	.+2      	; 0xcdfa <prvListTaskWithinSingleList+0x132>
    cdf8:	a8 cf       	rjmp	.-176    	; 0xcd4a <prvListTaskWithinSingleList+0x82>
	}
    cdfa:	df 91       	pop	r29
    cdfc:	cf 91       	pop	r28
    cdfe:	1f 91       	pop	r17
    ce00:	0f 91       	pop	r16
    ce02:	ff 90       	pop	r15
    ce04:	ef 90       	pop	r14
    ce06:	df 90       	pop	r13
    ce08:	cf 90       	pop	r12
    ce0a:	bf 90       	pop	r11
    ce0c:	af 90       	pop	r10
    ce0e:	9f 90       	pop	r9
    ce10:	8f 90       	pop	r8
    ce12:	7f 90       	pop	r7
    ce14:	6f 90       	pop	r6
    ce16:	5f 90       	pop	r5
    ce18:	4f 90       	pop	r4
    ce1a:	08 95       	ret

0000ce1c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    ce1c:	cf 92       	push	r12
    ce1e:	df 92       	push	r13
    ce20:	ff 92       	push	r15
    ce22:	0f 93       	push	r16
    ce24:	1f 93       	push	r17
    ce26:	df 93       	push	r29
    ce28:	cf 93       	push	r28
    ce2a:	0f 92       	push	r0
    ce2c:	cd b7       	in	r28, 0x3d	; 61
    ce2e:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    ce30:	0f b6       	in	r0, 0x3f	; 63
    ce32:	f8 94       	cli
    ce34:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    ce36:	80 91 ae 01 	lds	r24, 0x01AE
    ce3a:	81 50       	subi	r24, 0x01	; 1
    ce3c:	80 93 ae 01 	sts	0x01AE, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    ce40:	80 91 ae 01 	lds	r24, 0x01AE
    ce44:	88 23       	and	r24, r24
    ce46:	09 f0       	breq	.+2      	; 0xce4a <xTaskResumeAll+0x2e>
    ce48:	5a c0       	rjmp	.+180    	; 0xcefe <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    ce4a:	80 91 b3 01 	lds	r24, 0x01B3
    ce4e:	88 23       	and	r24, r24
    ce50:	09 f4       	brne	.+2      	; 0xce54 <xTaskResumeAll+0x38>
    ce52:	55 c0       	rjmp	.+170    	; 0xcefe <xTaskResumeAll+0xe2>
    ce54:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    ce56:	69 e0       	ldi	r22, 0x09	; 9
    ce58:	f6 2e       	mov	r15, r22
    ce5a:	27 c0       	rjmp	.+78     	; 0xceaa <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    ce5c:	c6 01       	movw	r24, r12
    ce5e:	0c 96       	adiw	r24, 0x0c	; 12
    ce60:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    ce64:	86 01       	movw	r16, r12
    ce66:	0e 5f       	subi	r16, 0xFE	; 254
    ce68:	1f 4f       	sbci	r17, 0xFF	; 255
    ce6a:	c8 01       	movw	r24, r16
    ce6c:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    ce70:	d6 01       	movw	r26, r12
    ce72:	56 96       	adiw	r26, 0x16	; 22
    ce74:	9c 91       	ld	r25, X
    ce76:	80 91 af 01 	lds	r24, 0x01AF
    ce7a:	89 17       	cp	r24, r25
    ce7c:	10 f4       	brcc	.+4      	; 0xce82 <xTaskResumeAll+0x66>
    ce7e:	90 93 af 01 	sts	0x01AF, r25
    ce82:	9f 9d       	mul	r25, r15
    ce84:	c0 01       	movw	r24, r0
    ce86:	11 24       	eor	r1, r1
    ce88:	8a 54       	subi	r24, 0x4A	; 74
    ce8a:	9e 4f       	sbci	r25, 0xFE	; 254
    ce8c:	b8 01       	movw	r22, r16
    ce8e:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    ce92:	e0 91 a8 01 	lds	r30, 0x01A8
    ce96:	f0 91 a9 01 	lds	r31, 0x01A9
    ce9a:	d6 01       	movw	r26, r12
    ce9c:	56 96       	adiw	r26, 0x16	; 22
    ce9e:	9c 91       	ld	r25, X
    cea0:	86 89       	ldd	r24, Z+22	; 0x16
    cea2:	98 17       	cp	r25, r24
    cea4:	10 f0       	brcs	.+4      	; 0xceaa <xTaskResumeAll+0x8e>
    cea6:	b1 e0       	ldi	r27, 0x01	; 1
    cea8:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    ceaa:	80 91 e7 01 	lds	r24, 0x01E7
    ceae:	88 23       	and	r24, r24
    ceb0:	49 f0       	breq	.+18     	; 0xcec4 <xTaskResumeAll+0xa8>
    ceb2:	e0 91 ec 01 	lds	r30, 0x01EC
    ceb6:	f0 91 ed 01 	lds	r31, 0x01ED
    ceba:	c6 80       	ldd	r12, Z+6	; 0x06
    cebc:	d7 80       	ldd	r13, Z+7	; 0x07
    cebe:	c1 14       	cp	r12, r1
    cec0:	d1 04       	cpc	r13, r1
    cec2:	61 f6       	brne	.-104    	; 0xce5c <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    cec4:	80 91 b1 01 	lds	r24, 0x01B1
    cec8:	88 23       	and	r24, r24
    ceca:	41 f4       	brne	.+16     	; 0xcedc <xTaskResumeAll+0xc0>
    cecc:	0b c0       	rjmp	.+22     	; 0xcee4 <xTaskResumeAll+0xc8>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    cece:	0e 94 e6 65 	call	0xcbcc	; 0xcbcc <vTaskIncrementTick>
						--uxMissedTicks;
    ced2:	80 91 b1 01 	lds	r24, 0x01B1
    ced6:	81 50       	subi	r24, 0x01	; 1
    ced8:	80 93 b1 01 	sts	0x01B1, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    cedc:	80 91 b1 01 	lds	r24, 0x01B1
    cee0:	88 23       	and	r24, r24
    cee2:	a9 f7       	brne	.-22     	; 0xcece <xTaskResumeAll+0xb2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    cee4:	e9 81       	ldd	r30, Y+1	; 0x01
    cee6:	e1 30       	cpi	r30, 0x01	; 1
    cee8:	21 f0       	breq	.+8      	; 0xcef2 <xTaskResumeAll+0xd6>
    ceea:	80 91 aa 01 	lds	r24, 0x01AA
    ceee:	81 30       	cpi	r24, 0x01	; 1
    cef0:	31 f4       	brne	.+12     	; 0xcefe <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    cef2:	10 92 aa 01 	sts	0x01AA, r1
					portYIELD_WITHIN_API();
    cef6:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
    cefa:	81 e0       	ldi	r24, 0x01	; 1
    cefc:	01 c0       	rjmp	.+2      	; 0xcf00 <xTaskResumeAll+0xe4>
    cefe:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    cf00:	0f 90       	pop	r0
    cf02:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    cf04:	0f 90       	pop	r0
    cf06:	cf 91       	pop	r28
    cf08:	df 91       	pop	r29
    cf0a:	1f 91       	pop	r17
    cf0c:	0f 91       	pop	r16
    cf0e:	ff 90       	pop	r15
    cf10:	df 90       	pop	r13
    cf12:	cf 90       	pop	r12
    cf14:	08 95       	ret

0000cf16 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
    cf16:	0f 93       	push	r16
    cf18:	1f 93       	push	r17
    cf1a:	cf 93       	push	r28
    cf1c:	df 93       	push	r29
    cf1e:	ec 01       	movw	r28, r24

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    cf20:	80 91 ae 01 	lds	r24, 0x01AE
    cf24:	8f 5f       	subi	r24, 0xFF	; 255
    cf26:	80 93 ae 01 	sts	0x01AE, r24
		vTaskSuspendAll();
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
    cf2a:	18 82       	st	Y, r1
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
    cf2c:	ce 01       	movw	r24, r28
    cf2e:	69 e7       	ldi	r22, 0x79	; 121
    cf30:	71 e0       	ldi	r23, 0x01	; 1
    cf32:	0e 94 6a 74 	call	0xe8d4	; 0xe8d4 <strcat>

			uxQueue = uxTopUsedPriority + 1;
    cf36:	10 91 b2 01 	lds	r17, 0x01B2
    cf3a:	1f 5f       	subi	r17, 0xFF	; 255

			do
			{
				uxQueue--;

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    cf3c:	09 e0       	ldi	r16, 0x09	; 9

			uxQueue = uxTopUsedPriority + 1;

			do
			{
				uxQueue--;
    cf3e:	11 50       	subi	r17, 0x01	; 1

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    cf40:	10 9f       	mul	r17, r16
    cf42:	f0 01       	movw	r30, r0
    cf44:	11 24       	eor	r1, r1
    cf46:	ea 54       	subi	r30, 0x4A	; 74
    cf48:	fe 4f       	sbci	r31, 0xFE	; 254
    cf4a:	80 81       	ld	r24, Z
    cf4c:	88 23       	and	r24, r24
    cf4e:	29 f0       	breq	.+10     	; 0xcf5a <vTaskList+0x44>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
    cf50:	ce 01       	movw	r24, r28
    cf52:	bf 01       	movw	r22, r30
    cf54:	42 e5       	ldi	r20, 0x52	; 82
    cf56:	0e 94 64 66 	call	0xccc8	; 0xccc8 <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
    cf5a:	11 23       	and	r17, r17
    cf5c:	81 f7       	brne	.-32     	; 0xcf3e <vTaskList+0x28>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
    cf5e:	e0 91 e3 01 	lds	r30, 0x01E3
    cf62:	f0 91 e4 01 	lds	r31, 0x01E4
    cf66:	80 81       	ld	r24, Z
    cf68:	88 23       	and	r24, r24
    cf6a:	41 f0       	breq	.+16     	; 0xcf7c <vTaskList+0x66>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
    cf6c:	60 91 e3 01 	lds	r22, 0x01E3
    cf70:	70 91 e4 01 	lds	r23, 0x01E4
    cf74:	ce 01       	movw	r24, r28
    cf76:	42 e4       	ldi	r20, 0x42	; 66
    cf78:	0e 94 64 66 	call	0xccc8	; 0xccc8 <prvListTaskWithinSingleList>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
    cf7c:	e0 91 e5 01 	lds	r30, 0x01E5
    cf80:	f0 91 e6 01 	lds	r31, 0x01E6
    cf84:	80 81       	ld	r24, Z
    cf86:	88 23       	and	r24, r24
    cf88:	41 f0       	breq	.+16     	; 0xcf9a <vTaskList+0x84>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
    cf8a:	60 91 e5 01 	lds	r22, 0x01E5
    cf8e:	70 91 e6 01 	lds	r23, 0x01E6
    cf92:	ce 01       	movw	r24, r28
    cf94:	42 e4       	ldi	r20, 0x42	; 66
    cf96:	0e 94 64 66 	call	0xccc8	; 0xccc8 <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
    cf9a:	80 91 f0 01 	lds	r24, 0x01F0
    cf9e:	88 23       	and	r24, r24
    cfa0:	31 f0       	breq	.+12     	; 0xcfae <vTaskList+0x98>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
    cfa2:	ce 01       	movw	r24, r28
    cfa4:	60 ef       	ldi	r22, 0xF0	; 240
    cfa6:	71 e0       	ldi	r23, 0x01	; 1
    cfa8:	43 e5       	ldi	r20, 0x53	; 83
    cfaa:	0e 94 64 66 	call	0xccc8	; 0xccc8 <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
    cfae:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
	}
    cfb2:	df 91       	pop	r29
    cfb4:	cf 91       	pop	r28
    cfb6:	1f 91       	pop	r17
    cfb8:	0f 91       	pop	r16
    cfba:	08 95       	ret

0000cfbc <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    cfbc:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
    cfc0:	fd cf       	rjmp	.-6      	; 0xcfbc <prvIdleTask>

0000cfc2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    cfc2:	0f 93       	push	r16
    cfc4:	1f 93       	push	r17
    cfc6:	cf 93       	push	r28
    cfc8:	df 93       	push	r29
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    cfca:	ec 01       	movw	r28, r24

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    cfcc:	00 97       	sbiw	r24, 0x00	; 0
    cfce:	09 f4       	brne	.+2      	; 0xcfd2 <vTaskResume+0x10>
    cfd0:	3c c0       	rjmp	.+120    	; 0xd04a <vTaskResume+0x88>
    cfd2:	80 91 a8 01 	lds	r24, 0x01A8
    cfd6:	90 91 a9 01 	lds	r25, 0x01A9
    cfda:	c8 17       	cp	r28, r24
    cfdc:	d9 07       	cpc	r29, r25
    cfde:	a9 f1       	breq	.+106    	; 0xd04a <vTaskResume+0x88>
		{
			portENTER_CRITICAL();
    cfe0:	0f b6       	in	r0, 0x3f	; 63
    cfe2:	f8 94       	cli
    cfe4:	0f 92       	push	r0
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    cfe6:	8a 85       	ldd	r24, Y+10	; 0x0a
    cfe8:	9b 85       	ldd	r25, Y+11	; 0x0b
    cfea:	80 5f       	subi	r24, 0xF0	; 240
    cfec:	91 40       	sbci	r25, 0x01	; 1
    cfee:	f1 f4       	brne	.+60     	; 0xd02c <vTaskResume+0x6a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    cff0:	8c 89       	ldd	r24, Y+20	; 0x14
    cff2:	9d 89       	ldd	r25, Y+21	; 0x15
    cff4:	21 e0       	ldi	r18, 0x01	; 1
    cff6:	87 3e       	cpi	r24, 0xE7	; 231
    cff8:	92 07       	cpc	r25, r18
    cffa:	c1 f0       	breq	.+48     	; 0xd02c <vTaskResume+0x6a>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    cffc:	89 2b       	or	r24, r25
    cffe:	b1 f4       	brne	.+44     	; 0xd02c <vTaskResume+0x6a>
    d000:	18 c0       	rjmp	.+48     	; 0xd032 <vTaskResume+0x70>
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    d002:	90 93 af 01 	sts	0x01AF, r25
    d006:	89 e0       	ldi	r24, 0x09	; 9
    d008:	98 9f       	mul	r25, r24
    d00a:	c0 01       	movw	r24, r0
    d00c:	11 24       	eor	r1, r1
    d00e:	8a 54       	subi	r24, 0x4A	; 74
    d010:	9e 4f       	sbci	r25, 0xFE	; 254
    d012:	b8 01       	movw	r22, r16
    d014:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    d018:	e0 91 a8 01 	lds	r30, 0x01A8
    d01c:	f0 91 a9 01 	lds	r31, 0x01A9
    d020:	9e 89       	ldd	r25, Y+22	; 0x16
    d022:	86 89       	ldd	r24, Z+22	; 0x16
    d024:	98 17       	cp	r25, r24
    d026:	10 f0       	brcs	.+4      	; 0xd02c <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    d028:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    d02c:	0f 90       	pop	r0
    d02e:	0f be       	out	0x3f, r0	; 63
    d030:	0c c0       	rjmp	.+24     	; 0xd04a <vTaskResume+0x88>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    d032:	8e 01       	movw	r16, r28
    d034:	0e 5f       	subi	r16, 0xFE	; 254
    d036:	1f 4f       	sbci	r17, 0xFF	; 255
    d038:	c8 01       	movw	r24, r16
    d03a:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    d03e:	9e 89       	ldd	r25, Y+22	; 0x16
    d040:	80 91 af 01 	lds	r24, 0x01AF
    d044:	89 17       	cp	r24, r25
    d046:	e8 f2       	brcs	.-70     	; 0xd002 <vTaskResume+0x40>
    d048:	de cf       	rjmp	.-68     	; 0xd006 <vTaskResume+0x44>
					}
				}
			}
			portEXIT_CRITICAL();
		}
	}
    d04a:	df 91       	pop	r29
    d04c:	cf 91       	pop	r28
    d04e:	1f 91       	pop	r17
    d050:	0f 91       	pop	r16
    d052:	08 95       	ret

0000d054 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    d054:	ef 92       	push	r14
    d056:	ff 92       	push	r15
    d058:	0f 93       	push	r16
    d05a:	1f 93       	push	r17
    d05c:	cf 93       	push	r28
    d05e:	df 93       	push	r29
    d060:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    d062:	0f b6       	in	r0, 0x3f	; 63
    d064:	f8 94       	cli
    d066:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    d068:	80 91 a8 01 	lds	r24, 0x01A8
    d06c:	90 91 a9 01 	lds	r25, 0x01A9
    d070:	08 17       	cp	r16, r24
    d072:	19 07       	cpc	r17, r25
    d074:	19 f4       	brne	.+6      	; 0xd07c <vTaskSuspend+0x28>
    d076:	00 e0       	ldi	r16, 0x00	; 0
    d078:	10 e0       	ldi	r17, 0x00	; 0
    d07a:	03 c0       	rjmp	.+6      	; 0xd082 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    d07c:	01 15       	cp	r16, r1
    d07e:	11 05       	cpc	r17, r1
    d080:	29 f4       	brne	.+10     	; 0xd08c <vTaskSuspend+0x38>
    d082:	c0 91 a8 01 	lds	r28, 0x01A8
    d086:	d0 91 a9 01 	lds	r29, 0x01A9
    d08a:	01 c0       	rjmp	.+2      	; 0xd08e <vTaskSuspend+0x3a>
    d08c:	e8 01       	movw	r28, r16

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    d08e:	72 e0       	ldi	r23, 0x02	; 2
    d090:	e7 2e       	mov	r14, r23
    d092:	f1 2c       	mov	r15, r1
    d094:	ec 0e       	add	r14, r28
    d096:	fd 1e       	adc	r15, r29
    d098:	c7 01       	movw	r24, r14
    d09a:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    d09e:	8c 89       	ldd	r24, Y+20	; 0x14
    d0a0:	9d 89       	ldd	r25, Y+21	; 0x15
    d0a2:	89 2b       	or	r24, r25
    d0a4:	21 f0       	breq	.+8      	; 0xd0ae <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    d0a6:	ce 01       	movw	r24, r28
    d0a8:	0c 96       	adiw	r24, 0x0c	; 12
    d0aa:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    d0ae:	80 ef       	ldi	r24, 0xF0	; 240
    d0b0:	91 e0       	ldi	r25, 0x01	; 1
    d0b2:	b7 01       	movw	r22, r14
    d0b4:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    d0b8:	0f 90       	pop	r0
    d0ba:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    d0bc:	01 2b       	or	r16, r17
    d0be:	11 f4       	brne	.+4      	; 0xd0c4 <vTaskSuspend+0x70>
		{
			portYIELD_WITHIN_API();
    d0c0:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
		}
	}
    d0c4:	df 91       	pop	r29
    d0c6:	cf 91       	pop	r28
    d0c8:	1f 91       	pop	r17
    d0ca:	0f 91       	pop	r16
    d0cc:	ff 90       	pop	r15
    d0ce:	ef 90       	pop	r14
    d0d0:	08 95       	ret

0000d0d2 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    d0d2:	ef 92       	push	r14
    d0d4:	ff 92       	push	r15
    d0d6:	0f 93       	push	r16
    d0d8:	1f 93       	push	r17
    d0da:	df 93       	push	r29
    d0dc:	cf 93       	push	r28
    d0de:	0f 92       	push	r0
    d0e0:	cd b7       	in	r28, 0x3d	; 61
    d0e2:	de b7       	in	r29, 0x3e	; 62
    d0e4:	9c 01       	movw	r18, r24
    d0e6:	63 30       	cpi	r22, 0x03	; 3
    d0e8:	08 f0       	brcs	.+2      	; 0xd0ec <vTaskPrioritySet+0x1a>
    d0ea:	62 e0       	ldi	r22, 0x02	; 2
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		portENTER_CRITICAL();
    d0ec:	0f b6       	in	r0, 0x3f	; 63
    d0ee:	f8 94       	cli
    d0f0:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    d0f2:	80 91 a8 01 	lds	r24, 0x01A8
    d0f6:	90 91 a9 01 	lds	r25, 0x01A9
    d0fa:	28 17       	cp	r18, r24
    d0fc:	39 07       	cpc	r19, r25
    d0fe:	19 f4       	brne	.+6      	; 0xd106 <vTaskPrioritySet+0x34>
    d100:	20 e0       	ldi	r18, 0x00	; 0
    d102:	30 e0       	ldi	r19, 0x00	; 0
    d104:	03 c0       	rjmp	.+6      	; 0xd10c <vTaskPrioritySet+0x3a>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    d106:	21 15       	cp	r18, r1
    d108:	31 05       	cpc	r19, r1
    d10a:	29 f4       	brne	.+10     	; 0xd116 <vTaskPrioritySet+0x44>
    d10c:	e0 90 a8 01 	lds	r14, 0x01A8
    d110:	f0 90 a9 01 	lds	r15, 0x01A9
    d114:	01 c0       	rjmp	.+2      	; 0xd118 <vTaskPrioritySet+0x46>
    d116:	79 01       	movw	r14, r18
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    d118:	f7 01       	movw	r30, r14
    d11a:	46 89       	ldd	r20, Z+22	; 0x16
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    d11c:	46 17       	cp	r20, r22
    d11e:	e1 f1       	breq	.+120    	; 0xd198 <vTaskPrioritySet+0xc6>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    d120:	46 17       	cp	r20, r22
    d122:	30 f4       	brcc	.+12     	; 0xd130 <vTaskPrioritySet+0x5e>
    d124:	19 82       	std	Y+1, r1	; 0x01
    d126:	23 2b       	or	r18, r19
    d128:	41 f0       	breq	.+16     	; 0xd13a <vTaskPrioritySet+0x68>
    d12a:	f1 e0       	ldi	r31, 0x01	; 1
    d12c:	f9 83       	std	Y+1, r31	; 0x01
    d12e:	05 c0       	rjmp	.+10     	; 0xd13a <vTaskPrioritySet+0x68>
    d130:	19 82       	std	Y+1, r1	; 0x01
    d132:	23 2b       	or	r18, r19
    d134:	11 f4       	brne	.+4      	; 0xd13a <vTaskPrioritySet+0x68>
    d136:	81 e0       	ldi	r24, 0x01	; 1
    d138:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    d13a:	f7 01       	movw	r30, r14
    d13c:	66 8b       	std	Z+22, r22	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    d13e:	83 e0       	ldi	r24, 0x03	; 3
    d140:	90 e0       	ldi	r25, 0x00	; 0
    d142:	86 1b       	sub	r24, r22
    d144:	91 09       	sbc	r25, r1
    d146:	95 87       	std	Z+13, r25	; 0x0d
    d148:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    d14a:	89 e0       	ldi	r24, 0x09	; 9
    d14c:	48 9f       	mul	r20, r24
    d14e:	c0 01       	movw	r24, r0
    d150:	11 24       	eor	r1, r1
    d152:	8a 54       	subi	r24, 0x4A	; 74
    d154:	9e 4f       	sbci	r25, 0xFE	; 254
    d156:	22 85       	ldd	r18, Z+10	; 0x0a
    d158:	33 85       	ldd	r19, Z+11	; 0x0b
    d15a:	28 17       	cp	r18, r24
    d15c:	39 07       	cpc	r19, r25
    d15e:	b9 f4       	brne	.+46     	; 0xd18e <vTaskPrioritySet+0xbc>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    d160:	87 01       	movw	r16, r14
    d162:	0e 5f       	subi	r16, 0xFE	; 254
    d164:	1f 4f       	sbci	r17, 0xFF	; 255
    d166:	c8 01       	movw	r24, r16
    d168:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    d16c:	f7 01       	movw	r30, r14
    d16e:	96 89       	ldd	r25, Z+22	; 0x16
    d170:	80 91 af 01 	lds	r24, 0x01AF
    d174:	89 17       	cp	r24, r25
    d176:	10 f4       	brcc	.+4      	; 0xd17c <vTaskPrioritySet+0xaa>
    d178:	90 93 af 01 	sts	0x01AF, r25
    d17c:	89 e0       	ldi	r24, 0x09	; 9
    d17e:	98 9f       	mul	r25, r24
    d180:	c0 01       	movw	r24, r0
    d182:	11 24       	eor	r1, r1
    d184:	8a 54       	subi	r24, 0x4A	; 74
    d186:	9e 4f       	sbci	r25, 0xFE	; 254
    d188:	b8 01       	movw	r22, r16
    d18a:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    d18e:	f9 81       	ldd	r31, Y+1	; 0x01
    d190:	f1 30       	cpi	r31, 0x01	; 1
    d192:	11 f4       	brne	.+4      	; 0xd198 <vTaskPrioritySet+0xc6>
				{
					portYIELD_WITHIN_API();
    d194:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
				}
			}
		}
		portEXIT_CRITICAL();
    d198:	0f 90       	pop	r0
    d19a:	0f be       	out	0x3f, r0	; 63
	}
    d19c:	0f 90       	pop	r0
    d19e:	cf 91       	pop	r28
    d1a0:	df 91       	pop	r29
    d1a2:	1f 91       	pop	r17
    d1a4:	0f 91       	pop	r16
    d1a6:	ff 90       	pop	r15
    d1a8:	ef 90       	pop	r14
    d1aa:	08 95       	ret

0000d1ac <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    d1ac:	0f 93       	push	r16
    d1ae:	1f 93       	push	r17
    d1b0:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    d1b2:	00 97       	sbiw	r24, 0x00	; 0
    d1b4:	a1 f1       	breq	.+104    	; 0xd21e <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    d1b6:	80 91 ae 01 	lds	r24, 0x01AE
    d1ba:	8f 5f       	subi	r24, 0xFF	; 255
    d1bc:	80 93 ae 01 	sts	0x01AE, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    d1c0:	00 91 ac 01 	lds	r16, 0x01AC
    d1c4:	10 91 ad 01 	lds	r17, 0x01AD
    d1c8:	02 0f       	add	r16, r18
    d1ca:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    d1cc:	80 91 a8 01 	lds	r24, 0x01A8
    d1d0:	90 91 a9 01 	lds	r25, 0x01A9
    d1d4:	02 96       	adiw	r24, 0x02	; 2
    d1d6:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    d1da:	e0 91 a8 01 	lds	r30, 0x01A8
    d1de:	f0 91 a9 01 	lds	r31, 0x01A9
    d1e2:	13 83       	std	Z+3, r17	; 0x03
    d1e4:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    d1e6:	80 91 ac 01 	lds	r24, 0x01AC
    d1ea:	90 91 ad 01 	lds	r25, 0x01AD
    d1ee:	08 17       	cp	r16, r24
    d1f0:	19 07       	cpc	r17, r25
    d1f2:	28 f4       	brcc	.+10     	; 0xd1fe <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    d1f4:	80 91 e5 01 	lds	r24, 0x01E5
    d1f8:	90 91 e6 01 	lds	r25, 0x01E6
    d1fc:	04 c0       	rjmp	.+8      	; 0xd206 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    d1fe:	80 91 e3 01 	lds	r24, 0x01E3
    d202:	90 91 e4 01 	lds	r25, 0x01E4
    d206:	60 91 a8 01 	lds	r22, 0x01A8
    d20a:	70 91 a9 01 	lds	r23, 0x01A9
    d20e:	6e 5f       	subi	r22, 0xFE	; 254
    d210:	7f 4f       	sbci	r23, 0xFF	; 255
    d212:	0e 94 2f 6e 	call	0xdc5e	; 0xdc5e <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    d216:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    d21a:	88 23       	and	r24, r24
    d21c:	11 f4       	brne	.+4      	; 0xd222 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    d21e:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
		}
	}
    d222:	1f 91       	pop	r17
    d224:	0f 91       	pop	r16
    d226:	08 95       	ret

0000d228 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    d228:	cf 93       	push	r28
    d22a:	df 93       	push	r29
    d22c:	fc 01       	movw	r30, r24
    d22e:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    d230:	80 91 ae 01 	lds	r24, 0x01AE
    d234:	8f 5f       	subi	r24, 0xFF	; 255
    d236:	80 93 ae 01 	sts	0x01AE, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    d23a:	20 81       	ld	r18, Z
    d23c:	31 81       	ldd	r19, Z+1	; 0x01
    d23e:	c2 0f       	add	r28, r18
    d240:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    d242:	80 91 ac 01 	lds	r24, 0x01AC
    d246:	90 91 ad 01 	lds	r25, 0x01AD
    d24a:	82 17       	cp	r24, r18
    d24c:	93 07       	cpc	r25, r19
    d24e:	28 f4       	brcc	.+10     	; 0xd25a <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    d250:	c2 17       	cp	r28, r18
    d252:	d3 07       	cpc	r29, r19
    d254:	28 f0       	brcs	.+10     	; 0xd260 <vTaskDelayUntil+0x38>
    d256:	20 e0       	ldi	r18, 0x00	; 0
    d258:	0c c0       	rjmp	.+24     	; 0xd272 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    d25a:	c2 17       	cp	r28, r18
    d25c:	d3 07       	cpc	r29, r19
    d25e:	40 f0       	brcs	.+16     	; 0xd270 <vTaskDelayUntil+0x48>
    d260:	80 91 ac 01 	lds	r24, 0x01AC
    d264:	90 91 ad 01 	lds	r25, 0x01AD
    d268:	20 e0       	ldi	r18, 0x00	; 0
    d26a:	8c 17       	cp	r24, r28
    d26c:	9d 07       	cpc	r25, r29
    d26e:	08 f4       	brcc	.+2      	; 0xd272 <vTaskDelayUntil+0x4a>
    d270:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    d272:	d1 83       	std	Z+1, r29	; 0x01
    d274:	c0 83       	st	Z, r28

			if( xShouldDelay )
    d276:	22 23       	and	r18, r18
    d278:	29 f1       	breq	.+74     	; 0xd2c4 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    d27a:	80 91 a8 01 	lds	r24, 0x01A8
    d27e:	90 91 a9 01 	lds	r25, 0x01A9
    d282:	02 96       	adiw	r24, 0x02	; 2
    d284:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    d288:	e0 91 a8 01 	lds	r30, 0x01A8
    d28c:	f0 91 a9 01 	lds	r31, 0x01A9
    d290:	d3 83       	std	Z+3, r29	; 0x03
    d292:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    d294:	80 91 ac 01 	lds	r24, 0x01AC
    d298:	90 91 ad 01 	lds	r25, 0x01AD
    d29c:	c8 17       	cp	r28, r24
    d29e:	d9 07       	cpc	r29, r25
    d2a0:	28 f4       	brcc	.+10     	; 0xd2ac <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    d2a2:	80 91 e5 01 	lds	r24, 0x01E5
    d2a6:	90 91 e6 01 	lds	r25, 0x01E6
    d2aa:	04 c0       	rjmp	.+8      	; 0xd2b4 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    d2ac:	80 91 e3 01 	lds	r24, 0x01E3
    d2b0:	90 91 e4 01 	lds	r25, 0x01E4
    d2b4:	60 91 a8 01 	lds	r22, 0x01A8
    d2b8:	70 91 a9 01 	lds	r23, 0x01A9
    d2bc:	6e 5f       	subi	r22, 0xFE	; 254
    d2be:	7f 4f       	sbci	r23, 0xFF	; 255
    d2c0:	0e 94 2f 6e 	call	0xdc5e	; 0xdc5e <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    d2c4:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    d2c8:	88 23       	and	r24, r24
    d2ca:	11 f4       	brne	.+4      	; 0xd2d0 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    d2cc:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
		}
	}
    d2d0:	df 91       	pop	r29
    d2d2:	cf 91       	pop	r28
    d2d4:	08 95       	ret

0000d2d6 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    d2d6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    d2d8:	10 92 b4 01 	sts	0x01B4, r1
	vPortEndScheduler();
    d2dc:	0e 94 fd 70 	call	0xe1fa	; 0xe1fa <vPortEndScheduler>
}
    d2e0:	08 95       	ret

0000d2e2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    d2e2:	2f 92       	push	r2
    d2e4:	3f 92       	push	r3
    d2e6:	4f 92       	push	r4
    d2e8:	5f 92       	push	r5
    d2ea:	7f 92       	push	r7
    d2ec:	8f 92       	push	r8
    d2ee:	9f 92       	push	r9
    d2f0:	af 92       	push	r10
    d2f2:	bf 92       	push	r11
    d2f4:	cf 92       	push	r12
    d2f6:	df 92       	push	r13
    d2f8:	ef 92       	push	r14
    d2fa:	ff 92       	push	r15
    d2fc:	0f 93       	push	r16
    d2fe:	1f 93       	push	r17
    d300:	df 93       	push	r29
    d302:	cf 93       	push	r28
    d304:	00 d0       	rcall	.+0      	; 0xd306 <xTaskGenericCreate+0x24>
    d306:	00 d0       	rcall	.+0      	; 0xd308 <xTaskGenericCreate+0x26>
    d308:	cd b7       	in	r28, 0x3d	; 61
    d30a:	de b7       	in	r29, 0x3e	; 62
    d30c:	1c 01       	movw	r2, r24
    d30e:	4b 01       	movw	r8, r22
    d310:	5a 01       	movw	r10, r20
    d312:	29 01       	movw	r4, r18
    d314:	70 2e       	mov	r7, r16
    d316:	fa 82       	std	Y+2, r15	; 0x02
    d318:	e9 82       	std	Y+1, r14	; 0x01
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    d31a:	84 e2       	ldi	r24, 0x24	; 36
    d31c:	90 e0       	ldi	r25, 0x00	; 0
    d31e:	0e 94 58 70 	call	0xe0b0	; 0xe0b0 <pvPortMalloc>
    d322:	8b 83       	std	Y+3, r24	; 0x03
    d324:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    d326:	8b 81       	ldd	r24, Y+3	; 0x03
    d328:	9c 81       	ldd	r25, Y+4	; 0x04
    d32a:	89 2b       	or	r24, r25
    d32c:	89 f0       	breq	.+34     	; 0xd350 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    d32e:	c1 14       	cp	r12, r1
    d330:	d1 04       	cpc	r13, r1
    d332:	21 f4       	brne	.+8      	; 0xd33c <xTaskGenericCreate+0x5a>
    d334:	c5 01       	movw	r24, r10
    d336:	0e 94 58 70 	call	0xe0b0	; 0xe0b0 <pvPortMalloc>
    d33a:	6c 01       	movw	r12, r24
    d33c:	eb 81       	ldd	r30, Y+3	; 0x03
    d33e:	fc 81       	ldd	r31, Y+4	; 0x04
    d340:	d0 8e       	std	Z+24, r13	; 0x18
    d342:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    d344:	c1 14       	cp	r12, r1
    d346:	d1 04       	cpc	r13, r1
    d348:	29 f4       	brne	.+10     	; 0xd354 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    d34a:	cf 01       	movw	r24, r30
    d34c:	0e 94 48 70 	call	0xe090	; 0xe090 <vPortFree>
    d350:	8f ef       	ldi	r24, 0xFF	; 255
    d352:	ce c0       	rjmp	.+412    	; 0xd4f0 <xTaskGenericCreate+0x20e>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    d354:	c6 01       	movw	r24, r12
    d356:	65 ea       	ldi	r22, 0xA5	; 165
    d358:	70 e0       	ldi	r23, 0x00	; 0
    d35a:	a5 01       	movw	r20, r10
    d35c:	0e 94 63 74 	call	0xe8c6	; 0xe8c6 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    d360:	08 94       	sec
    d362:	a1 08       	sbc	r10, r1
    d364:	b1 08       	sbc	r11, r1
    d366:	eb 81       	ldd	r30, Y+3	; 0x03
    d368:	fc 81       	ldd	r31, Y+4	; 0x04
    d36a:	e7 88       	ldd	r14, Z+23	; 0x17
    d36c:	f0 8c       	ldd	r15, Z+24	; 0x18
    d36e:	ea 0c       	add	r14, r10
    d370:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    d372:	cf 01       	movw	r24, r30
    d374:	49 96       	adiw	r24, 0x19	; 25
    d376:	b4 01       	movw	r22, r8
    d378:	4a e0       	ldi	r20, 0x0A	; 10
    d37a:	50 e0       	ldi	r21, 0x00	; 0
    d37c:	0e 94 8a 74 	call	0xe914	; 0xe914 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    d380:	eb 81       	ldd	r30, Y+3	; 0x03
    d382:	fc 81       	ldd	r31, Y+4	; 0x04
    d384:	12 a2       	std	Z+34, r1	; 0x22
    d386:	07 2d       	mov	r16, r7
    d388:	f2 e0       	ldi	r31, 0x02	; 2
    d38a:	f7 15       	cp	r31, r7
    d38c:	08 f4       	brcc	.+2      	; 0xd390 <xTaskGenericCreate+0xae>
    d38e:	02 e0       	ldi	r16, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    d390:	eb 81       	ldd	r30, Y+3	; 0x03
    d392:	fc 81       	ldd	r31, Y+4	; 0x04
    d394:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    d396:	a2 e0       	ldi	r26, 0x02	; 2
    d398:	ca 2e       	mov	r12, r26
    d39a:	d1 2c       	mov	r13, r1
    d39c:	ce 0e       	add	r12, r30
    d39e:	df 1e       	adc	r13, r31
    d3a0:	c6 01       	movw	r24, r12
    d3a2:	0e 94 02 6e 	call	0xdc04	; 0xdc04 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    d3a6:	8b 81       	ldd	r24, Y+3	; 0x03
    d3a8:	9c 81       	ldd	r25, Y+4	; 0x04
    d3aa:	0c 96       	adiw	r24, 0x0c	; 12
    d3ac:	0e 94 02 6e 	call	0xdc04	; 0xdc04 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    d3b0:	8b 81       	ldd	r24, Y+3	; 0x03
    d3b2:	9c 81       	ldd	r25, Y+4	; 0x04
    d3b4:	fc 01       	movw	r30, r24
    d3b6:	91 87       	std	Z+9, r25	; 0x09
    d3b8:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    d3ba:	83 e0       	ldi	r24, 0x03	; 3
    d3bc:	90 e0       	ldi	r25, 0x00	; 0
    d3be:	80 1b       	sub	r24, r16
    d3c0:	91 09       	sbc	r25, r1
    d3c2:	95 87       	std	Z+13, r25	; 0x0d
    d3c4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    d3c6:	f3 8b       	std	Z+19, r31	; 0x13
    d3c8:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d3ca:	c7 01       	movw	r24, r14
    d3cc:	b1 01       	movw	r22, r2
    d3ce:	a2 01       	movw	r20, r4
    d3d0:	0e 94 7f 70 	call	0xe0fe	; 0xe0fe <pxPortInitialiseStack>
    d3d4:	eb 81       	ldd	r30, Y+3	; 0x03
    d3d6:	fc 81       	ldd	r31, Y+4	; 0x04
    d3d8:	91 83       	std	Z+1, r25	; 0x01
    d3da:	80 83       	st	Z, r24
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    d3dc:	0f b6       	in	r0, 0x3f	; 63
    d3de:	f8 94       	cli
    d3e0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    d3e2:	80 91 b3 01 	lds	r24, 0x01B3
    d3e6:	8f 5f       	subi	r24, 0xFF	; 255
    d3e8:	80 93 b3 01 	sts	0x01B3, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    d3ec:	80 91 b3 01 	lds	r24, 0x01B3
    d3f0:	81 30       	cpi	r24, 0x01	; 1
    d3f2:	69 f5       	brne	.+90     	; 0xd44e <xTaskGenericCreate+0x16c>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    d3f4:	f0 93 a9 01 	sts	0x01A9, r31
    d3f8:	e0 93 a8 01 	sts	0x01A8, r30
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    d3fc:	86 eb       	ldi	r24, 0xB6	; 182
    d3fe:	91 e0       	ldi	r25, 0x01	; 1
    d400:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
    d404:	8f eb       	ldi	r24, 0xBF	; 191
    d406:	91 e0       	ldi	r25, 0x01	; 1
    d408:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
    d40c:	88 ec       	ldi	r24, 0xC8	; 200
    d40e:	91 e0       	ldi	r25, 0x01	; 1
    d410:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    d414:	e1 ed       	ldi	r30, 0xD1	; 209
    d416:	ee 2e       	mov	r14, r30
    d418:	e1 e0       	ldi	r30, 0x01	; 1
    d41a:	fe 2e       	mov	r15, r30
    d41c:	c7 01       	movw	r24, r14
    d41e:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    d422:	0a ed       	ldi	r16, 0xDA	; 218
    d424:	11 e0       	ldi	r17, 0x01	; 1
    d426:	c8 01       	movw	r24, r16
    d428:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    d42c:	87 ee       	ldi	r24, 0xE7	; 231
    d42e:	91 e0       	ldi	r25, 0x01	; 1
    d430:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    d434:	80 ef       	ldi	r24, 0xF0	; 240
    d436:	91 e0       	ldi	r25, 0x01	; 1
    d438:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    d43c:	f0 92 e4 01 	sts	0x01E4, r15
    d440:	e0 92 e3 01 	sts	0x01E3, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    d444:	10 93 e6 01 	sts	0x01E6, r17
    d448:	00 93 e5 01 	sts	0x01E5, r16
    d44c:	11 c0       	rjmp	.+34     	; 0xd470 <xTaskGenericCreate+0x18e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    d44e:	80 91 b4 01 	lds	r24, 0x01B4
    d452:	88 23       	and	r24, r24
    d454:	69 f4       	brne	.+26     	; 0xd470 <xTaskGenericCreate+0x18e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    d456:	e0 91 a8 01 	lds	r30, 0x01A8
    d45a:	f0 91 a9 01 	lds	r31, 0x01A9
    d45e:	86 89       	ldd	r24, Z+22	; 0x16
    d460:	78 16       	cp	r7, r24
    d462:	30 f0       	brcs	.+12     	; 0xd470 <xTaskGenericCreate+0x18e>
					{
						pxCurrentTCB = pxNewTCB;
    d464:	8b 81       	ldd	r24, Y+3	; 0x03
    d466:	9c 81       	ldd	r25, Y+4	; 0x04
    d468:	90 93 a9 01 	sts	0x01A9, r25
    d46c:	80 93 a8 01 	sts	0x01A8, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    d470:	eb 81       	ldd	r30, Y+3	; 0x03
    d472:	fc 81       	ldd	r31, Y+4	; 0x04
    d474:	96 89       	ldd	r25, Z+22	; 0x16
    d476:	80 91 b2 01 	lds	r24, 0x01B2
    d47a:	89 17       	cp	r24, r25
    d47c:	10 f4       	brcc	.+4      	; 0xd482 <xTaskGenericCreate+0x1a0>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    d47e:	90 93 b2 01 	sts	0x01B2, r25
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    d482:	80 91 b5 01 	lds	r24, 0x01B5
    d486:	eb 81       	ldd	r30, Y+3	; 0x03
    d488:	fc 81       	ldd	r31, Y+4	; 0x04
    d48a:	83 a3       	std	Z+35, r24	; 0x23
			}
			#endif
			uxTaskNumber++;
    d48c:	80 91 b5 01 	lds	r24, 0x01B5
    d490:	8f 5f       	subi	r24, 0xFF	; 255
    d492:	80 93 b5 01 	sts	0x01B5, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    d496:	96 89       	ldd	r25, Z+22	; 0x16
    d498:	80 91 af 01 	lds	r24, 0x01AF
    d49c:	89 17       	cp	r24, r25
    d49e:	10 f4       	brcc	.+4      	; 0xd4a4 <xTaskGenericCreate+0x1c2>
    d4a0:	90 93 af 01 	sts	0x01AF, r25
    d4a4:	eb 81       	ldd	r30, Y+3	; 0x03
    d4a6:	fc 81       	ldd	r31, Y+4	; 0x04
    d4a8:	86 89       	ldd	r24, Z+22	; 0x16
    d4aa:	29 e0       	ldi	r18, 0x09	; 9
    d4ac:	82 9f       	mul	r24, r18
    d4ae:	c0 01       	movw	r24, r0
    d4b0:	11 24       	eor	r1, r1
    d4b2:	8a 54       	subi	r24, 0x4A	; 74
    d4b4:	9e 4f       	sbci	r25, 0xFE	; 254
    d4b6:	b6 01       	movw	r22, r12
    d4b8:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    d4bc:	0f 90       	pop	r0
    d4be:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    d4c0:	89 81       	ldd	r24, Y+1	; 0x01
    d4c2:	9a 81       	ldd	r25, Y+2	; 0x02
    d4c4:	89 2b       	or	r24, r25
    d4c6:	31 f0       	breq	.+12     	; 0xd4d4 <xTaskGenericCreate+0x1f2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    d4c8:	8b 81       	ldd	r24, Y+3	; 0x03
    d4ca:	9c 81       	ldd	r25, Y+4	; 0x04
    d4cc:	e9 81       	ldd	r30, Y+1	; 0x01
    d4ce:	fa 81       	ldd	r31, Y+2	; 0x02
    d4d0:	91 83       	std	Z+1, r25	; 0x01
    d4d2:	80 83       	st	Z, r24
		}

		if( xSchedulerRunning != pdFALSE )
    d4d4:	80 91 b4 01 	lds	r24, 0x01B4
    d4d8:	88 23       	and	r24, r24
    d4da:	49 f0       	breq	.+18     	; 0xd4ee <xTaskGenericCreate+0x20c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    d4dc:	e0 91 a8 01 	lds	r30, 0x01A8
    d4e0:	f0 91 a9 01 	lds	r31, 0x01A9
    d4e4:	86 89       	ldd	r24, Z+22	; 0x16
    d4e6:	87 15       	cp	r24, r7
    d4e8:	10 f4       	brcc	.+4      	; 0xd4ee <xTaskGenericCreate+0x20c>
			{
				portYIELD_WITHIN_API();
    d4ea:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
    d4ee:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    d4f0:	0f 90       	pop	r0
    d4f2:	0f 90       	pop	r0
    d4f4:	0f 90       	pop	r0
    d4f6:	0f 90       	pop	r0
    d4f8:	cf 91       	pop	r28
    d4fa:	df 91       	pop	r29
    d4fc:	1f 91       	pop	r17
    d4fe:	0f 91       	pop	r16
    d500:	ff 90       	pop	r15
    d502:	ef 90       	pop	r14
    d504:	df 90       	pop	r13
    d506:	cf 90       	pop	r12
    d508:	bf 90       	pop	r11
    d50a:	af 90       	pop	r10
    d50c:	9f 90       	pop	r9
    d50e:	8f 90       	pop	r8
    d510:	7f 90       	pop	r7
    d512:	5f 90       	pop	r5
    d514:	4f 90       	pop	r4
    d516:	3f 90       	pop	r3
    d518:	2f 90       	pop	r2
    d51a:	08 95       	ret

0000d51c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    d51c:	af 92       	push	r10
    d51e:	bf 92       	push	r11
    d520:	cf 92       	push	r12
    d522:	df 92       	push	r13
    d524:	ef 92       	push	r14
    d526:	ff 92       	push	r15
    d528:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    d52a:	8e ed       	ldi	r24, 0xDE	; 222
    d52c:	97 e6       	ldi	r25, 0x67	; 103
    d52e:	6c e7       	ldi	r22, 0x7C	; 124
    d530:	71 e0       	ldi	r23, 0x01	; 1
    d532:	44 e6       	ldi	r20, 0x64	; 100
    d534:	50 e0       	ldi	r21, 0x00	; 0
    d536:	20 e0       	ldi	r18, 0x00	; 0
    d538:	30 e0       	ldi	r19, 0x00	; 0
    d53a:	00 e0       	ldi	r16, 0x00	; 0
    d53c:	ee 24       	eor	r14, r14
    d53e:	ff 24       	eor	r15, r15
    d540:	cc 24       	eor	r12, r12
    d542:	dd 24       	eor	r13, r13
    d544:	aa 24       	eor	r10, r10
    d546:	bb 24       	eor	r11, r11
    d548:	0e 94 71 69 	call	0xd2e2	; 0xd2e2 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    d54c:	81 30       	cpi	r24, 0x01	; 1
    d54e:	49 f4       	brne	.+18     	; 0xd562 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    d550:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    d552:	80 93 b4 01 	sts	0x01B4, r24
		xTickCount = ( portTickType ) 0;
    d556:	10 92 ad 01 	sts	0x01AD, r1
    d55a:	10 92 ac 01 	sts	0x01AC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    d55e:	0e 94 c7 70 	call	0xe18e	; 0xe18e <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    d562:	0f 91       	pop	r16
    d564:	ff 90       	pop	r15
    d566:	ef 90       	pop	r14
    d568:	df 90       	pop	r13
    d56a:	cf 90       	pop	r12
    d56c:	bf 90       	pop	r11
    d56e:	af 90       	pop	r10
    d570:	08 95       	ret

0000d572 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    d572:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    d574:	0f b6       	in	r0, 0x3f	; 63
    d576:	f8 94       	cli
    d578:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    d57a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    d57c:	0f 90       	pop	r0
    d57e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    d580:	08 95       	ret

0000d582 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    d582:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    d584:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    d586:	08 95       	ret

0000d588 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    d588:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    d58a:	82 8d       	ldd	r24, Z+26	; 0x1a
    d58c:	90 e0       	ldi	r25, 0x00	; 0
    d58e:	88 23       	and	r24, r24
    d590:	09 f4       	brne	.+2      	; 0xd594 <xQueueIsQueueEmptyFromISR+0xc>
    d592:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    d594:	89 2f       	mov	r24, r25
    d596:	08 95       	ret

0000d598 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    d598:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    d59a:	92 8d       	ldd	r25, Z+26	; 0x1a
    d59c:	20 e0       	ldi	r18, 0x00	; 0
    d59e:	83 8d       	ldd	r24, Z+27	; 0x1b
    d5a0:	98 17       	cp	r25, r24
    d5a2:	09 f4       	brne	.+2      	; 0xd5a6 <xQueueIsQueueFullFromISR+0xe>
    d5a4:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    d5a6:	82 2f       	mov	r24, r18
    d5a8:	08 95       	ret

0000d5aa <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    d5aa:	0f 93       	push	r16
    d5ac:	1f 93       	push	r17
    d5ae:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    d5b0:	fc 01       	movw	r30, r24
    d5b2:	80 81       	ld	r24, Z
    d5b4:	91 81       	ldd	r25, Z+1	; 0x01
    d5b6:	0e 94 48 70 	call	0xe090	; 0xe090 <vPortFree>
	vPortFree( pxQueue );
    d5ba:	c8 01       	movw	r24, r16
    d5bc:	0e 94 48 70 	call	0xe090	; 0xe090 <vPortFree>
}
    d5c0:	1f 91       	pop	r17
    d5c2:	0f 91       	pop	r16
    d5c4:	08 95       	ret

0000d5c6 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    d5c6:	0f 93       	push	r16
    d5c8:	1f 93       	push	r17
    d5ca:	cf 93       	push	r28
    d5cc:	df 93       	push	r29
    d5ce:	ec 01       	movw	r28, r24
    d5d0:	fb 01       	movw	r30, r22
    d5d2:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    d5d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    d5d6:	88 23       	and	r24, r24
    d5d8:	81 f1       	breq	.+96     	; 0xd63a <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    d5da:	48 81       	ld	r20, Y
    d5dc:	59 81       	ldd	r21, Y+1	; 0x01
    d5de:	41 15       	cp	r20, r1
    d5e0:	51 05       	cpc	r21, r1
    d5e2:	a9 f0       	breq	.+42     	; 0xd60e <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    d5e4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    d5e6:	2e 81       	ldd	r18, Y+6	; 0x06
    d5e8:	3f 81       	ldd	r19, Y+7	; 0x07
    d5ea:	28 0f       	add	r18, r24
    d5ec:	31 1d       	adc	r19, r1
    d5ee:	3f 83       	std	Y+7, r19	; 0x07
    d5f0:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    d5f2:	8a 81       	ldd	r24, Y+2	; 0x02
    d5f4:	9b 81       	ldd	r25, Y+3	; 0x03
    d5f6:	28 17       	cp	r18, r24
    d5f8:	39 07       	cpc	r19, r25
    d5fa:	10 f0       	brcs	.+4      	; 0xd600 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    d5fc:	5f 83       	std	Y+7, r21	; 0x07
    d5fe:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    d600:	4c 8d       	ldd	r20, Y+28	; 0x1c
    d602:	6e 81       	ldd	r22, Y+6	; 0x06
    d604:	7f 81       	ldd	r23, Y+7	; 0x07
    d606:	cf 01       	movw	r24, r30
    d608:	50 e0       	ldi	r21, 0x00	; 0
    d60a:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    d60e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    d610:	81 50       	subi	r24, 0x01	; 1
    d612:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    d614:	8d 8d       	ldd	r24, Y+29	; 0x1d
    d616:	8f 3f       	cpi	r24, 0xFF	; 255
    d618:	69 f4       	brne	.+26     	; 0xd634 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    d61a:	88 85       	ldd	r24, Y+8	; 0x08
    d61c:	88 23       	and	r24, r24
    d61e:	61 f0       	breq	.+24     	; 0xd638 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d620:	ce 01       	movw	r24, r28
    d622:	08 96       	adiw	r24, 0x08	; 8
    d624:	0e 94 0d 65 	call	0xca1a	; 0xca1a <xTaskRemoveFromEventList>
    d628:	88 23       	and	r24, r24
    d62a:	31 f0       	breq	.+12     	; 0xd638 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    d62c:	81 e0       	ldi	r24, 0x01	; 1
    d62e:	f8 01       	movw	r30, r16
    d630:	80 83       	st	Z, r24
    d632:	03 c0       	rjmp	.+6      	; 0xd63a <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    d634:	8f 5f       	subi	r24, 0xFF	; 255
    d636:	8d 8f       	std	Y+29, r24	; 0x1d
    d638:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    d63a:	df 91       	pop	r29
    d63c:	cf 91       	pop	r28
    d63e:	1f 91       	pop	r17
    d640:	0f 91       	pop	r16
    d642:	08 95       	ret

0000d644 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    d644:	cf 93       	push	r28
    d646:	df 93       	push	r29
    d648:	ec 01       	movw	r28, r24
    d64a:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    d64c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    d64e:	44 23       	and	r20, r20
    d650:	a1 f1       	breq	.+104    	; 0xd6ba <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    d652:	88 23       	and	r24, r24
    d654:	b1 f4       	brne	.+44     	; 0xd682 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    d656:	8c 81       	ldd	r24, Y+4	; 0x04
    d658:	9d 81       	ldd	r25, Y+5	; 0x05
    d65a:	50 e0       	ldi	r21, 0x00	; 0
    d65c:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    d660:	8c 8d       	ldd	r24, Y+28	; 0x1c
    d662:	2c 81       	ldd	r18, Y+4	; 0x04
    d664:	3d 81       	ldd	r19, Y+5	; 0x05
    d666:	28 0f       	add	r18, r24
    d668:	31 1d       	adc	r19, r1
    d66a:	3d 83       	std	Y+5, r19	; 0x05
    d66c:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    d66e:	8a 81       	ldd	r24, Y+2	; 0x02
    d670:	9b 81       	ldd	r25, Y+3	; 0x03
    d672:	28 17       	cp	r18, r24
    d674:	39 07       	cpc	r19, r25
    d676:	08 f1       	brcs	.+66     	; 0xd6ba <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    d678:	88 81       	ld	r24, Y
    d67a:	99 81       	ldd	r25, Y+1	; 0x01
    d67c:	9d 83       	std	Y+5, r25	; 0x05
    d67e:	8c 83       	std	Y+4, r24	; 0x04
    d680:	1c c0       	rjmp	.+56     	; 0xd6ba <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    d682:	8e 81       	ldd	r24, Y+6	; 0x06
    d684:	9f 81       	ldd	r25, Y+7	; 0x07
    d686:	50 e0       	ldi	r21, 0x00	; 0
    d688:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    d68c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    d68e:	90 e0       	ldi	r25, 0x00	; 0
    d690:	44 27       	eor	r20, r20
    d692:	55 27       	eor	r21, r21
    d694:	48 1b       	sub	r20, r24
    d696:	59 0b       	sbc	r21, r25
    d698:	8e 81       	ldd	r24, Y+6	; 0x06
    d69a:	9f 81       	ldd	r25, Y+7	; 0x07
    d69c:	84 0f       	add	r24, r20
    d69e:	95 1f       	adc	r25, r21
    d6a0:	9f 83       	std	Y+7, r25	; 0x07
    d6a2:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    d6a4:	28 81       	ld	r18, Y
    d6a6:	39 81       	ldd	r19, Y+1	; 0x01
    d6a8:	82 17       	cp	r24, r18
    d6aa:	93 07       	cpc	r25, r19
    d6ac:	30 f4       	brcc	.+12     	; 0xd6ba <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    d6ae:	8a 81       	ldd	r24, Y+2	; 0x02
    d6b0:	9b 81       	ldd	r25, Y+3	; 0x03
    d6b2:	84 0f       	add	r24, r20
    d6b4:	95 1f       	adc	r25, r21
    d6b6:	9f 83       	std	Y+7, r25	; 0x07
    d6b8:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    d6ba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    d6bc:	8f 5f       	subi	r24, 0xFF	; 255
    d6be:	8a 8f       	std	Y+26, r24	; 0x1a
}
    d6c0:	df 91       	pop	r29
    d6c2:	cf 91       	pop	r28
    d6c4:	08 95       	ret

0000d6c6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    d6c6:	0f 93       	push	r16
    d6c8:	1f 93       	push	r17
    d6ca:	cf 93       	push	r28
    d6cc:	df 93       	push	r29
    d6ce:	ec 01       	movw	r28, r24
    d6d0:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    d6d2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    d6d4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    d6d6:	98 17       	cp	r25, r24
    d6d8:	10 f0       	brcs	.+4      	; 0xd6de <xQueueGenericSendFromISR+0x18>
    d6da:	80 e0       	ldi	r24, 0x00	; 0
    d6dc:	17 c0       	rjmp	.+46     	; 0xd70c <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    d6de:	ce 01       	movw	r24, r28
    d6e0:	42 2f       	mov	r20, r18
    d6e2:	0e 94 22 6b 	call	0xd644	; 0xd644 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    d6e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    d6e8:	8f 3f       	cpi	r24, 0xFF	; 255
    d6ea:	69 f4       	brne	.+26     	; 0xd706 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    d6ec:	89 89       	ldd	r24, Y+17	; 0x11
    d6ee:	88 23       	and	r24, r24
    d6f0:	61 f0       	breq	.+24     	; 0xd70a <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d6f2:	ce 01       	movw	r24, r28
    d6f4:	41 96       	adiw	r24, 0x11	; 17
    d6f6:	0e 94 0d 65 	call	0xca1a	; 0xca1a <xTaskRemoveFromEventList>
    d6fa:	88 23       	and	r24, r24
    d6fc:	31 f0       	breq	.+12     	; 0xd70a <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    d6fe:	81 e0       	ldi	r24, 0x01	; 1
    d700:	f8 01       	movw	r30, r16
    d702:	80 83       	st	Z, r24
    d704:	03 c0       	rjmp	.+6      	; 0xd70c <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    d706:	8f 5f       	subi	r24, 0xFF	; 255
    d708:	8e 8f       	std	Y+30, r24	; 0x1e
    d70a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    d70c:	df 91       	pop	r29
    d70e:	cf 91       	pop	r28
    d710:	1f 91       	pop	r17
    d712:	0f 91       	pop	r16
    d714:	08 95       	ret

0000d716 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    d716:	0f 93       	push	r16
    d718:	1f 93       	push	r17
    d71a:	cf 93       	push	r28
    d71c:	df 93       	push	r29
    d71e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    d720:	0f b6       	in	r0, 0x3f	; 63
    d722:	f8 94       	cli
    d724:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d726:	8c 01       	movw	r16, r24
    d728:	0f 5e       	subi	r16, 0xEF	; 239
    d72a:	1f 4f       	sbci	r17, 0xFF	; 255
    d72c:	0d c0       	rjmp	.+26     	; 0xd748 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    d72e:	89 89       	ldd	r24, Y+17	; 0x11
    d730:	88 23       	and	r24, r24
    d732:	69 f0       	breq	.+26     	; 0xd74e <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d734:	c8 01       	movw	r24, r16
    d736:	0e 94 0d 65 	call	0xca1a	; 0xca1a <xTaskRemoveFromEventList>
    d73a:	88 23       	and	r24, r24
    d73c:	11 f0       	breq	.+4      	; 0xd742 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    d73e:	0e 94 09 65 	call	0xca12	; 0xca12 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    d742:	8e 8d       	ldd	r24, Y+30	; 0x1e
    d744:	81 50       	subi	r24, 0x01	; 1
    d746:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    d748:	8e 8d       	ldd	r24, Y+30	; 0x1e
    d74a:	18 16       	cp	r1, r24
    d74c:	84 f3       	brlt	.-32     	; 0xd72e <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    d74e:	8f ef       	ldi	r24, 0xFF	; 255
    d750:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    d752:	0f 90       	pop	r0
    d754:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    d756:	0f b6       	in	r0, 0x3f	; 63
    d758:	f8 94       	cli
    d75a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d75c:	8e 01       	movw	r16, r28
    d75e:	08 5f       	subi	r16, 0xF8	; 248
    d760:	1f 4f       	sbci	r17, 0xFF	; 255
    d762:	0d c0       	rjmp	.+26     	; 0xd77e <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    d764:	88 85       	ldd	r24, Y+8	; 0x08
    d766:	88 23       	and	r24, r24
    d768:	69 f0       	breq	.+26     	; 0xd784 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d76a:	c8 01       	movw	r24, r16
    d76c:	0e 94 0d 65 	call	0xca1a	; 0xca1a <xTaskRemoveFromEventList>
    d770:	88 23       	and	r24, r24
    d772:	11 f0       	breq	.+4      	; 0xd778 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    d774:	0e 94 09 65 	call	0xca12	; 0xca12 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    d778:	8d 8d       	ldd	r24, Y+29	; 0x1d
    d77a:	81 50       	subi	r24, 0x01	; 1
    d77c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    d77e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    d780:	18 16       	cp	r1, r24
    d782:	84 f3       	brlt	.-32     	; 0xd764 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    d784:	8f ef       	ldi	r24, 0xFF	; 255
    d786:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    d788:	0f 90       	pop	r0
    d78a:	0f be       	out	0x3f, r0	; 63
}
    d78c:	df 91       	pop	r29
    d78e:	cf 91       	pop	r28
    d790:	1f 91       	pop	r17
    d792:	0f 91       	pop	r16
    d794:	08 95       	ret

0000d796 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    d796:	7f 92       	push	r7
    d798:	8f 92       	push	r8
    d79a:	9f 92       	push	r9
    d79c:	af 92       	push	r10
    d79e:	bf 92       	push	r11
    d7a0:	cf 92       	push	r12
    d7a2:	df 92       	push	r13
    d7a4:	ef 92       	push	r14
    d7a6:	ff 92       	push	r15
    d7a8:	0f 93       	push	r16
    d7aa:	1f 93       	push	r17
    d7ac:	df 93       	push	r29
    d7ae:	cf 93       	push	r28
    d7b0:	00 d0       	rcall	.+0      	; 0xd7b2 <xQueueGenericReceive+0x1c>
    d7b2:	00 d0       	rcall	.+0      	; 0xd7b4 <xQueueGenericReceive+0x1e>
    d7b4:	0f 92       	push	r0
    d7b6:	cd b7       	in	r28, 0x3d	; 61
    d7b8:	de b7       	in	r29, 0x3e	; 62
    d7ba:	8c 01       	movw	r16, r24
    d7bc:	96 2e       	mov	r9, r22
    d7be:	87 2e       	mov	r8, r23
    d7c0:	5d 83       	std	Y+5, r21	; 0x05
    d7c2:	4c 83       	std	Y+4, r20	; 0x04
    d7c4:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    d7c6:	91 e1       	ldi	r25, 0x11	; 17
    d7c8:	c9 2e       	mov	r12, r25
    d7ca:	d1 2c       	mov	r13, r1
    d7cc:	c0 0e       	add	r12, r16
    d7ce:	d1 1e       	adc	r13, r17
    d7d0:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    d7d2:	7e 01       	movw	r14, r28
    d7d4:	08 94       	sec
    d7d6:	e1 1c       	adc	r14, r1
    d7d8:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d7da:	84 e0       	ldi	r24, 0x04	; 4
    d7dc:	a8 2e       	mov	r10, r24
    d7de:	b1 2c       	mov	r11, r1
    d7e0:	ac 0e       	add	r10, r28
    d7e2:	bd 1e       	adc	r11, r29
    d7e4:	01 c0       	rjmp	.+2      	; 0xd7e8 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    d7e6:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    d7e8:	0f b6       	in	r0, 0x3f	; 63
    d7ea:	f8 94       	cli
    d7ec:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    d7ee:	f8 01       	movw	r30, r16
    d7f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    d7f2:	88 23       	and	r24, r24
    d7f4:	09 f4       	brne	.+2      	; 0xd7f8 <xQueueGenericReceive+0x62>
    d7f6:	3e c0       	rjmp	.+124    	; 0xd874 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    d7f8:	e6 80       	ldd	r14, Z+6	; 0x06
    d7fa:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    d7fc:	40 81       	ld	r20, Z
    d7fe:	51 81       	ldd	r21, Z+1	; 0x01
    d800:	41 15       	cp	r20, r1
    d802:	51 05       	cpc	r21, r1
    d804:	b1 f0       	breq	.+44     	; 0xd832 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    d806:	84 8d       	ldd	r24, Z+28	; 0x1c
    d808:	97 01       	movw	r18, r14
    d80a:	28 0f       	add	r18, r24
    d80c:	31 1d       	adc	r19, r1
    d80e:	37 83       	std	Z+7, r19	; 0x07
    d810:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    d812:	82 81       	ldd	r24, Z+2	; 0x02
    d814:	93 81       	ldd	r25, Z+3	; 0x03
    d816:	28 17       	cp	r18, r24
    d818:	39 07       	cpc	r19, r25
    d81a:	10 f0       	brcs	.+4      	; 0xd820 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    d81c:	57 83       	std	Z+7, r21	; 0x07
    d81e:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    d820:	f8 01       	movw	r30, r16
    d822:	44 8d       	ldd	r20, Z+28	; 0x1c
    d824:	66 81       	ldd	r22, Z+6	; 0x06
    d826:	77 81       	ldd	r23, Z+7	; 0x07
    d828:	89 2d       	mov	r24, r9
    d82a:	98 2d       	mov	r25, r8
    d82c:	50 e0       	ldi	r21, 0x00	; 0
    d82e:	0e 94 5a 74 	call	0xe8b4	; 0xe8b4 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    d832:	77 20       	and	r7, r7
    d834:	71 f4       	brne	.+28     	; 0xd852 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    d836:	f8 01       	movw	r30, r16
    d838:	82 8d       	ldd	r24, Z+26	; 0x1a
    d83a:	81 50       	subi	r24, 0x01	; 1
    d83c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d83e:	80 85       	ldd	r24, Z+8	; 0x08
    d840:	88 23       	and	r24, r24
    d842:	a1 f0       	breq	.+40     	; 0xd86c <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    d844:	c8 01       	movw	r24, r16
    d846:	08 96       	adiw	r24, 0x08	; 8
    d848:	0e 94 0d 65 	call	0xca1a	; 0xca1a <xTaskRemoveFromEventList>
    d84c:	81 30       	cpi	r24, 0x01	; 1
    d84e:	71 f4       	brne	.+28     	; 0xd86c <xQueueGenericReceive+0xd6>
    d850:	0b c0       	rjmp	.+22     	; 0xd868 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    d852:	f8 01       	movw	r30, r16
    d854:	f7 82       	std	Z+7, r15	; 0x07
    d856:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    d858:	81 89       	ldd	r24, Z+17	; 0x11
    d85a:	88 23       	and	r24, r24
    d85c:	39 f0       	breq	.+14     	; 0xd86c <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d85e:	c6 01       	movw	r24, r12
    d860:	0e 94 0d 65 	call	0xca1a	; 0xca1a <xTaskRemoveFromEventList>
    d864:	88 23       	and	r24, r24
    d866:	11 f0       	breq	.+4      	; 0xd86c <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    d868:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    d86c:	0f 90       	pop	r0
    d86e:	0f be       	out	0x3f, r0	; 63
    d870:	81 e0       	ldi	r24, 0x01	; 1
    d872:	4a c0       	rjmp	.+148    	; 0xd908 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    d874:	8c 81       	ldd	r24, Y+4	; 0x04
    d876:	9d 81       	ldd	r25, Y+5	; 0x05
    d878:	89 2b       	or	r24, r25
    d87a:	19 f4       	brne	.+6      	; 0xd882 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    d87c:	0f 90       	pop	r0
    d87e:	0f be       	out	0x3f, r0	; 63
    d880:	42 c0       	rjmp	.+132    	; 0xd906 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    d882:	22 23       	and	r18, r18
    d884:	19 f4       	brne	.+6      	; 0xd88c <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    d886:	c7 01       	movw	r24, r14
    d888:	0e 94 c0 64 	call	0xc980	; 0xc980 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    d88c:	0f 90       	pop	r0
    d88e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    d890:	0e 94 e9 63 	call	0xc7d2	; 0xc7d2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    d894:	0f b6       	in	r0, 0x3f	; 63
    d896:	f8 94       	cli
    d898:	0f 92       	push	r0
    d89a:	f8 01       	movw	r30, r16
    d89c:	85 8d       	ldd	r24, Z+29	; 0x1d
    d89e:	8f 3f       	cpi	r24, 0xFF	; 255
    d8a0:	09 f4       	brne	.+2      	; 0xd8a4 <xQueueGenericReceive+0x10e>
    d8a2:	15 8e       	std	Z+29, r1	; 0x1d
    d8a4:	f8 01       	movw	r30, r16
    d8a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    d8a8:	8f 3f       	cpi	r24, 0xFF	; 255
    d8aa:	09 f4       	brne	.+2      	; 0xd8ae <xQueueGenericReceive+0x118>
    d8ac:	16 8e       	std	Z+30, r1	; 0x1e
    d8ae:	0f 90       	pop	r0
    d8b0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d8b2:	c7 01       	movw	r24, r14
    d8b4:	b5 01       	movw	r22, r10
    d8b6:	0e 94 cb 64 	call	0xc996	; 0xc996 <xTaskCheckForTimeOut>
    d8ba:	88 23       	and	r24, r24
    d8bc:	f9 f4       	brne	.+62     	; 0xd8fc <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    d8be:	0f b6       	in	r0, 0x3f	; 63
    d8c0:	f8 94       	cli
    d8c2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    d8c4:	f8 01       	movw	r30, r16
    d8c6:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    d8c8:	0f 90       	pop	r0
    d8ca:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    d8cc:	88 23       	and	r24, r24
    d8ce:	81 f4       	brne	.+32     	; 0xd8f0 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    d8d0:	6c 81       	ldd	r22, Y+4	; 0x04
    d8d2:	7d 81       	ldd	r23, Y+5	; 0x05
    d8d4:	c6 01       	movw	r24, r12
    d8d6:	0e 94 9e 65 	call	0xcb3c	; 0xcb3c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    d8da:	c8 01       	movw	r24, r16
    d8dc:	0e 94 8b 6b 	call	0xd716	; 0xd716 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    d8e0:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
    d8e4:	88 23       	and	r24, r24
    d8e6:	09 f0       	breq	.+2      	; 0xd8ea <xQueueGenericReceive+0x154>
    d8e8:	7e cf       	rjmp	.-260    	; 0xd7e6 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    d8ea:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
    d8ee:	7b cf       	rjmp	.-266    	; 0xd7e6 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    d8f0:	c8 01       	movw	r24, r16
    d8f2:	0e 94 8b 6b 	call	0xd716	; 0xd716 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    d8f6:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
    d8fa:	75 cf       	rjmp	.-278    	; 0xd7e6 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    d8fc:	c8 01       	movw	r24, r16
    d8fe:	0e 94 8b 6b 	call	0xd716	; 0xd716 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    d902:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
    d906:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    d908:	0f 90       	pop	r0
    d90a:	0f 90       	pop	r0
    d90c:	0f 90       	pop	r0
    d90e:	0f 90       	pop	r0
    d910:	0f 90       	pop	r0
    d912:	cf 91       	pop	r28
    d914:	df 91       	pop	r29
    d916:	1f 91       	pop	r17
    d918:	0f 91       	pop	r16
    d91a:	ff 90       	pop	r15
    d91c:	ef 90       	pop	r14
    d91e:	df 90       	pop	r13
    d920:	cf 90       	pop	r12
    d922:	bf 90       	pop	r11
    d924:	af 90       	pop	r10
    d926:	9f 90       	pop	r9
    d928:	8f 90       	pop	r8
    d92a:	7f 90       	pop	r7
    d92c:	08 95       	ret

0000d92e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    d92e:	7f 92       	push	r7
    d930:	8f 92       	push	r8
    d932:	9f 92       	push	r9
    d934:	af 92       	push	r10
    d936:	bf 92       	push	r11
    d938:	cf 92       	push	r12
    d93a:	df 92       	push	r13
    d93c:	ef 92       	push	r14
    d93e:	ff 92       	push	r15
    d940:	0f 93       	push	r16
    d942:	1f 93       	push	r17
    d944:	df 93       	push	r29
    d946:	cf 93       	push	r28
    d948:	00 d0       	rcall	.+0      	; 0xd94a <xQueueGenericSend+0x1c>
    d94a:	00 d0       	rcall	.+0      	; 0xd94c <xQueueGenericSend+0x1e>
    d94c:	0f 92       	push	r0
    d94e:	cd b7       	in	r28, 0x3d	; 61
    d950:	de b7       	in	r29, 0x3e	; 62
    d952:	8c 01       	movw	r16, r24
    d954:	6b 01       	movw	r12, r22
    d956:	5d 83       	std	Y+5, r21	; 0x05
    d958:	4c 83       	std	Y+4, r20	; 0x04
    d95a:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    d95c:	48 e0       	ldi	r20, 0x08	; 8
    d95e:	e4 2e       	mov	r14, r20
    d960:	f1 2c       	mov	r15, r1
    d962:	e8 0e       	add	r14, r24
    d964:	f9 1e       	adc	r15, r25
    d966:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    d968:	5e 01       	movw	r10, r28
    d96a:	08 94       	sec
    d96c:	a1 1c       	adc	r10, r1
    d96e:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d970:	34 e0       	ldi	r19, 0x04	; 4
    d972:	83 2e       	mov	r8, r19
    d974:	91 2c       	mov	r9, r1
    d976:	8c 0e       	add	r8, r28
    d978:	9d 1e       	adc	r9, r29
    d97a:	01 c0       	rjmp	.+2      	; 0xd97e <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    d97c:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    d97e:	0f b6       	in	r0, 0x3f	; 63
    d980:	f8 94       	cli
    d982:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    d984:	f8 01       	movw	r30, r16
    d986:	92 8d       	ldd	r25, Z+26	; 0x1a
    d988:	83 8d       	ldd	r24, Z+27	; 0x1b
    d98a:	98 17       	cp	r25, r24
    d98c:	a8 f4       	brcc	.+42     	; 0xd9b8 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    d98e:	c8 01       	movw	r24, r16
    d990:	b6 01       	movw	r22, r12
    d992:	47 2d       	mov	r20, r7
    d994:	0e 94 22 6b 	call	0xd644	; 0xd644 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d998:	f8 01       	movw	r30, r16
    d99a:	81 89       	ldd	r24, Z+17	; 0x11
    d99c:	88 23       	and	r24, r24
    d99e:	41 f0       	breq	.+16     	; 0xd9b0 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    d9a0:	c8 01       	movw	r24, r16
    d9a2:	41 96       	adiw	r24, 0x11	; 17
    d9a4:	0e 94 0d 65 	call	0xca1a	; 0xca1a <xTaskRemoveFromEventList>
    d9a8:	81 30       	cpi	r24, 0x01	; 1
    d9aa:	11 f4       	brne	.+4      	; 0xd9b0 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    d9ac:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    d9b0:	0f 90       	pop	r0
    d9b2:	0f be       	out	0x3f, r0	; 63
    d9b4:	81 e0       	ldi	r24, 0x01	; 1
    d9b6:	4c c0       	rjmp	.+152    	; 0xda50 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    d9b8:	8c 81       	ldd	r24, Y+4	; 0x04
    d9ba:	9d 81       	ldd	r25, Y+5	; 0x05
    d9bc:	89 2b       	or	r24, r25
    d9be:	19 f4       	brne	.+6      	; 0xd9c6 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    d9c0:	0f 90       	pop	r0
    d9c2:	0f be       	out	0x3f, r0	; 63
    d9c4:	44 c0       	rjmp	.+136    	; 0xda4e <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    d9c6:	22 23       	and	r18, r18
    d9c8:	19 f4       	brne	.+6      	; 0xd9d0 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    d9ca:	c5 01       	movw	r24, r10
    d9cc:	0e 94 c0 64 	call	0xc980	; 0xc980 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    d9d0:	0f 90       	pop	r0
    d9d2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    d9d4:	0e 94 e9 63 	call	0xc7d2	; 0xc7d2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    d9d8:	0f b6       	in	r0, 0x3f	; 63
    d9da:	f8 94       	cli
    d9dc:	0f 92       	push	r0
    d9de:	f8 01       	movw	r30, r16
    d9e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    d9e2:	8f 3f       	cpi	r24, 0xFF	; 255
    d9e4:	09 f4       	brne	.+2      	; 0xd9e8 <xQueueGenericSend+0xba>
    d9e6:	15 8e       	std	Z+29, r1	; 0x1d
    d9e8:	f8 01       	movw	r30, r16
    d9ea:	86 8d       	ldd	r24, Z+30	; 0x1e
    d9ec:	8f 3f       	cpi	r24, 0xFF	; 255
    d9ee:	09 f4       	brne	.+2      	; 0xd9f2 <xQueueGenericSend+0xc4>
    d9f0:	16 8e       	std	Z+30, r1	; 0x1e
    d9f2:	0f 90       	pop	r0
    d9f4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d9f6:	c5 01       	movw	r24, r10
    d9f8:	b4 01       	movw	r22, r8
    d9fa:	0e 94 cb 64 	call	0xc996	; 0xc996 <xTaskCheckForTimeOut>
    d9fe:	88 23       	and	r24, r24
    da00:	09 f5       	brne	.+66     	; 0xda44 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    da02:	0f b6       	in	r0, 0x3f	; 63
    da04:	f8 94       	cli
    da06:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    da08:	f8 01       	movw	r30, r16
    da0a:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    da0c:	0f 90       	pop	r0
    da0e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    da10:	f8 01       	movw	r30, r16
    da12:	83 8d       	ldd	r24, Z+27	; 0x1b
    da14:	98 17       	cp	r25, r24
    da16:	81 f4       	brne	.+32     	; 0xda38 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    da18:	6c 81       	ldd	r22, Y+4	; 0x04
    da1a:	7d 81       	ldd	r23, Y+5	; 0x05
    da1c:	c7 01       	movw	r24, r14
    da1e:	0e 94 9e 65 	call	0xcb3c	; 0xcb3c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    da22:	c8 01       	movw	r24, r16
    da24:	0e 94 8b 6b 	call	0xd716	; 0xd716 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    da28:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
    da2c:	88 23       	and	r24, r24
    da2e:	09 f0       	breq	.+2      	; 0xda32 <xQueueGenericSend+0x104>
    da30:	a5 cf       	rjmp	.-182    	; 0xd97c <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    da32:	0e 94 81 71 	call	0xe302	; 0xe302 <vPortYield>
    da36:	a2 cf       	rjmp	.-188    	; 0xd97c <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    da38:	c8 01       	movw	r24, r16
    da3a:	0e 94 8b 6b 	call	0xd716	; 0xd716 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    da3e:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
    da42:	9c cf       	rjmp	.-200    	; 0xd97c <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    da44:	c8 01       	movw	r24, r16
    da46:	0e 94 8b 6b 	call	0xd716	; 0xd716 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    da4a:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
    da4e:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    da50:	0f 90       	pop	r0
    da52:	0f 90       	pop	r0
    da54:	0f 90       	pop	r0
    da56:	0f 90       	pop	r0
    da58:	0f 90       	pop	r0
    da5a:	cf 91       	pop	r28
    da5c:	df 91       	pop	r29
    da5e:	1f 91       	pop	r17
    da60:	0f 91       	pop	r16
    da62:	ff 90       	pop	r15
    da64:	ef 90       	pop	r14
    da66:	df 90       	pop	r13
    da68:	cf 90       	pop	r12
    da6a:	bf 90       	pop	r11
    da6c:	af 90       	pop	r10
    da6e:	9f 90       	pop	r9
    da70:	8f 90       	pop	r8
    da72:	7f 90       	pop	r7
    da74:	08 95       	ret

0000da76 <xQueueCreateExternal>:
	was required. */
	return NULL;
}

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    da76:	ef 92       	push	r14
    da78:	ff 92       	push	r15
    da7a:	0f 93       	push	r16
    da7c:	1f 93       	push	r17
    da7e:	cf 93       	push	r28
    da80:	df 93       	push	r29
    da82:	18 2f       	mov	r17, r24
    da84:	e6 2e       	mov	r14, r22
    da86:	04 2f       	mov	r16, r20
    da88:	f5 2e       	mov	r15, r21
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    da8a:	88 23       	and	r24, r24
    da8c:	f1 f1       	breq	.+124    	; 0xdb0a <xQueueCreateExternal+0x94>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    da8e:	8f e1       	ldi	r24, 0x1F	; 31
    da90:	90 e0       	ldi	r25, 0x00	; 0
    da92:	0e 94 58 70 	call	0xe0b0	; 0xe0b0 <pvPortMalloc>
    da96:	fc 01       	movw	r30, r24
    da98:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    da9a:	00 97       	sbiw	r24, 0x00	; 0
    da9c:	c1 f1       	breq	.+112    	; 0xdb0e <xQueueCreateExternal+0x98>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    da9e:	60 2f       	mov	r22, r16
    daa0:	7f 2d       	mov	r23, r15
    daa2:	71 83       	std	Z+1, r23	; 0x01
    daa4:	60 83       	st	Z, r22
			if( pxNewQueue->pcHead != NULL )
    daa6:	61 15       	cp	r22, r1
    daa8:	71 05       	cpc	r23, r1
    daaa:	69 f1       	breq	.+90     	; 0xdb06 <xQueueCreateExternal+0x90>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    daac:	21 2f       	mov	r18, r17
    daae:	30 e0       	ldi	r19, 0x00	; 0
    dab0:	4e 2d       	mov	r20, r14
    dab2:	50 e0       	ldi	r21, 0x00	; 0
    dab4:	42 9f       	mul	r20, r18
    dab6:	c0 01       	movw	r24, r0
    dab8:	43 9f       	mul	r20, r19
    daba:	90 0d       	add	r25, r0
    dabc:	52 9f       	mul	r21, r18
    dabe:	90 0d       	add	r25, r0
    dac0:	11 24       	eor	r1, r1
    dac2:	86 0f       	add	r24, r22
    dac4:	97 1f       	adc	r25, r23
    dac6:	93 83       	std	Z+3, r25	; 0x03
    dac8:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    daca:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    dacc:	75 83       	std	Z+5, r23	; 0x05
    dace:	64 83       	std	Z+4, r22	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    dad0:	21 50       	subi	r18, 0x01	; 1
    dad2:	30 40       	sbci	r19, 0x00	; 0
    dad4:	24 9f       	mul	r18, r20
    dad6:	c0 01       	movw	r24, r0
    dad8:	25 9f       	mul	r18, r21
    dada:	90 0d       	add	r25, r0
    dadc:	34 9f       	mul	r19, r20
    dade:	90 0d       	add	r25, r0
    dae0:	11 24       	eor	r1, r1
    dae2:	68 0f       	add	r22, r24
    dae4:	79 1f       	adc	r23, r25
    dae6:	77 83       	std	Z+7, r23	; 0x07
    dae8:	66 83       	std	Z+6, r22	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    daea:	13 8f       	std	Z+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    daec:	e4 8e       	std	Z+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    daee:	8f ef       	ldi	r24, 0xFF	; 255
    daf0:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    daf2:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    daf4:	cf 01       	movw	r24, r30
    daf6:	08 96       	adiw	r24, 0x08	; 8
    daf8:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    dafc:	ce 01       	movw	r24, r28
    dafe:	41 96       	adiw	r24, 0x11	; 17
    db00:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
    db04:	04 c0       	rjmp	.+8      	; 0xdb0e <xQueueCreateExternal+0x98>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    db06:	0e 94 48 70 	call	0xe090	; 0xe090 <vPortFree>
    db0a:	c0 e0       	ldi	r28, 0x00	; 0
    db0c:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    db0e:	ce 01       	movw	r24, r28
    db10:	df 91       	pop	r29
    db12:	cf 91       	pop	r28
    db14:	1f 91       	pop	r17
    db16:	0f 91       	pop	r16
    db18:	ff 90       	pop	r15
    db1a:	ef 90       	pop	r14
    db1c:	08 95       	ret

0000db1e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    db1e:	8f 92       	push	r8
    db20:	9f 92       	push	r9
    db22:	af 92       	push	r10
    db24:	bf 92       	push	r11
    db26:	cf 92       	push	r12
    db28:	df 92       	push	r13
    db2a:	ef 92       	push	r14
    db2c:	ff 92       	push	r15
    db2e:	0f 93       	push	r16
    db30:	1f 93       	push	r17
    db32:	cf 93       	push	r28
    db34:	df 93       	push	r29
    db36:	98 2e       	mov	r9, r24
    db38:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    db3a:	88 23       	and	r24, r24
    db3c:	09 f4       	brne	.+2      	; 0xdb40 <xQueueCreate+0x22>
    db3e:	42 c0       	rjmp	.+132    	; 0xdbc4 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    db40:	8f e1       	ldi	r24, 0x1F	; 31
    db42:	90 e0       	ldi	r25, 0x00	; 0
    db44:	0e 94 58 70 	call	0xe0b0	; 0xe0b0 <pvPortMalloc>
    db48:	8c 01       	movw	r16, r24
    db4a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    db4c:	00 97       	sbiw	r24, 0x00	; 0
    db4e:	e1 f1       	breq	.+120    	; 0xdbc8 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    db50:	c9 2c       	mov	r12, r9
    db52:	dd 24       	eor	r13, r13
    db54:	a8 2c       	mov	r10, r8
    db56:	bb 24       	eor	r11, r11
    db58:	ac 9c       	mul	r10, r12
    db5a:	70 01       	movw	r14, r0
    db5c:	ad 9c       	mul	r10, r13
    db5e:	f0 0c       	add	r15, r0
    db60:	bc 9c       	mul	r11, r12
    db62:	f0 0c       	add	r15, r0
    db64:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    db66:	c7 01       	movw	r24, r14
    db68:	01 96       	adiw	r24, 0x01	; 1
    db6a:	0e 94 58 70 	call	0xe0b0	; 0xe0b0 <pvPortMalloc>
    db6e:	9c 01       	movw	r18, r24
    db70:	99 83       	std	Y+1, r25	; 0x01
    db72:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    db74:	00 97       	sbiw	r24, 0x00	; 0
    db76:	19 f1       	breq	.+70     	; 0xdbbe <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    db78:	e8 0e       	add	r14, r24
    db7a:	f9 1e       	adc	r15, r25
    db7c:	fb 82       	std	Y+3, r15	; 0x03
    db7e:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    db80:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    db82:	9d 83       	std	Y+5, r25	; 0x05
    db84:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    db86:	08 94       	sec
    db88:	c1 08       	sbc	r12, r1
    db8a:	d1 08       	sbc	r13, r1
    db8c:	ca 9c       	mul	r12, r10
    db8e:	c0 01       	movw	r24, r0
    db90:	cb 9c       	mul	r12, r11
    db92:	90 0d       	add	r25, r0
    db94:	da 9c       	mul	r13, r10
    db96:	90 0d       	add	r25, r0
    db98:	11 24       	eor	r1, r1
    db9a:	28 0f       	add	r18, r24
    db9c:	39 1f       	adc	r19, r25
    db9e:	3f 83       	std	Y+7, r19	; 0x07
    dba0:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    dba2:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    dba4:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    dba6:	8f ef       	ldi	r24, 0xFF	; 255
    dba8:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    dbaa:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    dbac:	c8 01       	movw	r24, r16
    dbae:	08 96       	adiw	r24, 0x08	; 8
    dbb0:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    dbb4:	c8 01       	movw	r24, r16
    dbb6:	41 96       	adiw	r24, 0x11	; 17
    dbb8:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
    dbbc:	05 c0       	rjmp	.+10     	; 0xdbc8 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    dbbe:	c8 01       	movw	r24, r16
    dbc0:	0e 94 48 70 	call	0xe090	; 0xe090 <vPortFree>
    dbc4:	c0 e0       	ldi	r28, 0x00	; 0
    dbc6:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    dbc8:	ce 01       	movw	r24, r28
    dbca:	df 91       	pop	r29
    dbcc:	cf 91       	pop	r28
    dbce:	1f 91       	pop	r17
    dbd0:	0f 91       	pop	r16
    dbd2:	ff 90       	pop	r15
    dbd4:	ef 90       	pop	r14
    dbd6:	df 90       	pop	r13
    dbd8:	cf 90       	pop	r12
    dbda:	bf 90       	pop	r11
    dbdc:	af 90       	pop	r10
    dbde:	9f 90       	pop	r9
    dbe0:	8f 90       	pop	r8
    dbe2:	08 95       	ret

0000dbe4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    dbe4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    dbe6:	9c 01       	movw	r18, r24
    dbe8:	2d 5f       	subi	r18, 0xFD	; 253
    dbea:	3f 4f       	sbci	r19, 0xFF	; 255
    dbec:	32 83       	std	Z+2, r19	; 0x02
    dbee:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    dbf0:	8f ef       	ldi	r24, 0xFF	; 255
    dbf2:	9f ef       	ldi	r25, 0xFF	; 255
    dbf4:	94 83       	std	Z+4, r25	; 0x04
    dbf6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    dbf8:	36 83       	std	Z+6, r19	; 0x06
    dbfa:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    dbfc:	30 87       	std	Z+8, r19	; 0x08
    dbfe:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    dc00:	10 82       	st	Z, r1
}
    dc02:	08 95       	ret

0000dc04 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    dc04:	fc 01       	movw	r30, r24
    dc06:	11 86       	std	Z+9, r1	; 0x09
    dc08:	10 86       	std	Z+8, r1	; 0x08
}
    dc0a:	08 95       	ret

0000dc0c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    dc0c:	cf 93       	push	r28
    dc0e:	df 93       	push	r29
    dc10:	ac 01       	movw	r20, r24
    dc12:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    dc14:	ec 01       	movw	r28, r24
    dc16:	29 81       	ldd	r18, Y+1	; 0x01
    dc18:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    dc1a:	f9 01       	movw	r30, r18
    dc1c:	82 81       	ldd	r24, Z+2	; 0x02
    dc1e:	93 81       	ldd	r25, Z+3	; 0x03
    dc20:	13 96       	adiw	r26, 0x03	; 3
    dc22:	9c 93       	st	X, r25
    dc24:	8e 93       	st	-X, r24
    dc26:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    dc28:	89 81       	ldd	r24, Y+1	; 0x01
    dc2a:	9a 81       	ldd	r25, Y+2	; 0x02
    dc2c:	15 96       	adiw	r26, 0x05	; 5
    dc2e:	9c 93       	st	X, r25
    dc30:	8e 93       	st	-X, r24
    dc32:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    dc34:	02 80       	ldd	r0, Z+2	; 0x02
    dc36:	f3 81       	ldd	r31, Z+3	; 0x03
    dc38:	e0 2d       	mov	r30, r0
    dc3a:	75 83       	std	Z+5, r23	; 0x05
    dc3c:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    dc3e:	e9 01       	movw	r28, r18
    dc40:	7b 83       	std	Y+3, r23	; 0x03
    dc42:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    dc44:	fa 01       	movw	r30, r20
    dc46:	72 83       	std	Z+2, r23	; 0x02
    dc48:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    dc4a:	19 96       	adiw	r26, 0x09	; 9
    dc4c:	5c 93       	st	X, r21
    dc4e:	4e 93       	st	-X, r20
    dc50:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    dc52:	80 81       	ld	r24, Z
    dc54:	8f 5f       	subi	r24, 0xFF	; 255
    dc56:	80 83       	st	Z, r24
}
    dc58:	df 91       	pop	r29
    dc5a:	cf 91       	pop	r28
    dc5c:	08 95       	ret

0000dc5e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    dc5e:	cf 93       	push	r28
    dc60:	df 93       	push	r29
    dc62:	9c 01       	movw	r18, r24
    dc64:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    dc66:	48 81       	ld	r20, Y
    dc68:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    dc6a:	8f ef       	ldi	r24, 0xFF	; 255
    dc6c:	4f 3f       	cpi	r20, 0xFF	; 255
    dc6e:	58 07       	cpc	r21, r24
    dc70:	21 f4       	brne	.+8      	; 0xdc7a <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    dc72:	f9 01       	movw	r30, r18
    dc74:	a7 81       	ldd	r26, Z+7	; 0x07
    dc76:	b0 85       	ldd	r27, Z+8	; 0x08
    dc78:	10 c0       	rjmp	.+32     	; 0xdc9a <vListInsert+0x3c>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    dc7a:	d9 01       	movw	r26, r18
    dc7c:	13 96       	adiw	r26, 0x03	; 3
    dc7e:	04 c0       	rjmp	.+8      	; 0xdc88 <vListInsert+0x2a>
    dc80:	12 96       	adiw	r26, 0x02	; 2
    dc82:	0d 90       	ld	r0, X+
    dc84:	bc 91       	ld	r27, X
    dc86:	a0 2d       	mov	r26, r0
    dc88:	12 96       	adiw	r26, 0x02	; 2
    dc8a:	ed 91       	ld	r30, X+
    dc8c:	fc 91       	ld	r31, X
    dc8e:	13 97       	sbiw	r26, 0x03	; 3
    dc90:	80 81       	ld	r24, Z
    dc92:	91 81       	ldd	r25, Z+1	; 0x01
    dc94:	48 17       	cp	r20, r24
    dc96:	59 07       	cpc	r21, r25
    dc98:	98 f7       	brcc	.-26     	; 0xdc80 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    dc9a:	12 96       	adiw	r26, 0x02	; 2
    dc9c:	ed 91       	ld	r30, X+
    dc9e:	fc 91       	ld	r31, X
    dca0:	13 97       	sbiw	r26, 0x03	; 3
    dca2:	fb 83       	std	Y+3, r31	; 0x03
    dca4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    dca6:	d5 83       	std	Z+5, r29	; 0x05
    dca8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    dcaa:	bd 83       	std	Y+5, r27	; 0x05
    dcac:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    dcae:	13 96       	adiw	r26, 0x03	; 3
    dcb0:	dc 93       	st	X, r29
    dcb2:	ce 93       	st	-X, r28
    dcb4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    dcb6:	39 87       	std	Y+9, r19	; 0x09
    dcb8:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    dcba:	f9 01       	movw	r30, r18
    dcbc:	80 81       	ld	r24, Z
    dcbe:	8f 5f       	subi	r24, 0xFF	; 255
    dcc0:	80 83       	st	Z, r24
}
    dcc2:	df 91       	pop	r29
    dcc4:	cf 91       	pop	r28
    dcc6:	08 95       	ret

0000dcc8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    dcc8:	cf 93       	push	r28
    dcca:	df 93       	push	r29
    dccc:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    dcce:	12 96       	adiw	r26, 0x02	; 2
    dcd0:	ed 91       	ld	r30, X+
    dcd2:	fc 91       	ld	r31, X
    dcd4:	13 97       	sbiw	r26, 0x03	; 3
    dcd6:	14 96       	adiw	r26, 0x04	; 4
    dcd8:	8d 91       	ld	r24, X+
    dcda:	9c 91       	ld	r25, X
    dcdc:	15 97       	sbiw	r26, 0x05	; 5
    dcde:	95 83       	std	Z+5, r25	; 0x05
    dce0:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    dce2:	14 96       	adiw	r26, 0x04	; 4
    dce4:	cd 91       	ld	r28, X+
    dce6:	dc 91       	ld	r29, X
    dce8:	15 97       	sbiw	r26, 0x05	; 5
    dcea:	fb 83       	std	Y+3, r31	; 0x03
    dcec:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    dcee:	18 96       	adiw	r26, 0x08	; 8
    dcf0:	ed 91       	ld	r30, X+
    dcf2:	fc 91       	ld	r31, X
    dcf4:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    dcf6:	81 81       	ldd	r24, Z+1	; 0x01
    dcf8:	92 81       	ldd	r25, Z+2	; 0x02
    dcfa:	8a 17       	cp	r24, r26
    dcfc:	9b 07       	cpc	r25, r27
    dcfe:	11 f4       	brne	.+4      	; 0xdd04 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    dd00:	d2 83       	std	Z+2, r29	; 0x02
    dd02:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    dd04:	19 96       	adiw	r26, 0x09	; 9
    dd06:	1c 92       	st	X, r1
    dd08:	1e 92       	st	-X, r1
    dd0a:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    dd0c:	80 81       	ld	r24, Z
    dd0e:	81 50       	subi	r24, 0x01	; 1
    dd10:	80 83       	st	Z, r24
}
    dd12:	df 91       	pop	r29
    dd14:	cf 91       	pop	r28
    dd16:	08 95       	ret

0000dd18 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    dd18:	0f 93       	push	r16
    dd1a:	1f 93       	push	r17
    dd1c:	cf 93       	push	r28
    dd1e:	df 93       	push	r29
    dd20:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    dd22:	80 81       	ld	r24, Z
    dd24:	88 23       	and	r24, r24
    dd26:	19 f4       	brne	.+6      	; 0xdd2e <xCoRoutineRemoveFromEventList+0x16>
    dd28:	c0 e0       	ldi	r28, 0x00	; 0
    dd2a:	d0 e0       	ldi	r29, 0x00	; 0
    dd2c:	05 c0       	rjmp	.+10     	; 0xdd38 <xCoRoutineRemoveFromEventList+0x20>
    dd2e:	05 80       	ldd	r0, Z+5	; 0x05
    dd30:	f6 81       	ldd	r31, Z+6	; 0x06
    dd32:	e0 2d       	mov	r30, r0
    dd34:	c6 81       	ldd	r28, Z+6	; 0x06
    dd36:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    dd38:	8e 01       	movw	r16, r28
    dd3a:	04 5f       	subi	r16, 0xF4	; 244
    dd3c:	1f 4f       	sbci	r17, 0xFF	; 255
    dd3e:	c8 01       	movw	r24, r16
    dd40:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    dd44:	89 e5       	ldi	r24, 0x59	; 89
    dd46:	92 e0       	ldi	r25, 0x02	; 2
    dd48:	b8 01       	movw	r22, r16
    dd4a:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
    dd4e:	20 e0       	ldi	r18, 0x00	; 0
    dd50:	e0 91 31 02 	lds	r30, 0x0231
    dd54:	f0 91 32 02 	lds	r31, 0x0232
    dd58:	9e 89       	ldd	r25, Y+22	; 0x16
    dd5a:	86 89       	ldd	r24, Z+22	; 0x16
    dd5c:	98 17       	cp	r25, r24
    dd5e:	08 f0       	brcs	.+2      	; 0xdd62 <xCoRoutineRemoveFromEventList+0x4a>
    dd60:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    dd62:	82 2f       	mov	r24, r18
    dd64:	df 91       	pop	r29
    dd66:	cf 91       	pop	r28
    dd68:	1f 91       	pop	r17
    dd6a:	0f 91       	pop	r16
    dd6c:	08 95       	ret

0000dd6e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    dd6e:	ff 92       	push	r15
    dd70:	0f 93       	push	r16
    dd72:	1f 93       	push	r17
    dd74:	cf 93       	push	r28
    dd76:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    dd78:	99 e0       	ldi	r25, 0x09	; 9
    dd7a:	f9 2e       	mov	r15, r25
    dd7c:	28 c0       	rjmp	.+80     	; 0xddce <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    dd7e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    dd80:	80 91 59 02 	lds	r24, 0x0259
    dd84:	88 23       	and	r24, r24
    dd86:	19 f4       	brne	.+6      	; 0xdd8e <vCoRoutineSchedule+0x20>
    dd88:	c0 e0       	ldi	r28, 0x00	; 0
    dd8a:	d0 e0       	ldi	r29, 0x00	; 0
    dd8c:	06 c0       	rjmp	.+12     	; 0xdd9a <vCoRoutineSchedule+0x2c>
    dd8e:	e0 91 5e 02 	lds	r30, 0x025E
    dd92:	f0 91 5f 02 	lds	r31, 0x025F
    dd96:	c6 81       	ldd	r28, Z+6	; 0x06
    dd98:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    dd9a:	ce 01       	movw	r24, r28
    dd9c:	0c 96       	adiw	r24, 0x0c	; 12
    dd9e:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    dda2:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    dda4:	8e 01       	movw	r16, r28
    dda6:	0e 5f       	subi	r16, 0xFE	; 254
    dda8:	1f 4f       	sbci	r17, 0xFF	; 255
    ddaa:	c8 01       	movw	r24, r16
    ddac:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    ddb0:	9e 89       	ldd	r25, Y+22	; 0x16
    ddb2:	80 91 33 02 	lds	r24, 0x0233
    ddb6:	89 17       	cp	r24, r25
    ddb8:	10 f4       	brcc	.+4      	; 0xddbe <vCoRoutineSchedule+0x50>
    ddba:	90 93 33 02 	sts	0x0233, r25
    ddbe:	9f 9d       	mul	r25, r15
    ddc0:	c0 01       	movw	r24, r0
    ddc2:	11 24       	eor	r1, r1
    ddc4:	86 5c       	subi	r24, 0xC6	; 198
    ddc6:	9d 4f       	sbci	r25, 0xFD	; 253
    ddc8:	b8 01       	movw	r22, r16
    ddca:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    ddce:	80 91 59 02 	lds	r24, 0x0259
    ddd2:	88 23       	and	r24, r24
    ddd4:	a1 f6       	brne	.-88     	; 0xdd7e <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    ddd6:	0e 94 ef 63 	call	0xc7de	; 0xc7de <xTaskGetTickCount>
    ddda:	20 91 34 02 	lds	r18, 0x0234
    ddde:	30 91 35 02 	lds	r19, 0x0235
    dde2:	82 1b       	sub	r24, r18
    dde4:	93 0b       	sbc	r25, r19
    dde6:	90 93 37 02 	sts	0x0237, r25
    ddea:	80 93 36 02 	sts	0x0236, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    ddee:	89 e0       	ldi	r24, 0x09	; 9
    ddf0:	f8 2e       	mov	r15, r24
    ddf2:	54 c0       	rjmp	.+168    	; 0xde9c <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    ddf4:	01 96       	adiw	r24, 0x01	; 1
    ddf6:	90 93 39 02 	sts	0x0239, r25
    ddfa:	80 93 38 02 	sts	0x0238, r24
		xPassedTicks--;
    ddfe:	21 50       	subi	r18, 0x01	; 1
    de00:	30 40       	sbci	r19, 0x00	; 0
    de02:	30 93 37 02 	sts	0x0237, r19
    de06:	20 93 36 02 	sts	0x0236, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    de0a:	89 2b       	or	r24, r25
    de0c:	c9 f5       	brne	.+114    	; 0xde80 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    de0e:	20 91 55 02 	lds	r18, 0x0255
    de12:	30 91 56 02 	lds	r19, 0x0256
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    de16:	80 91 57 02 	lds	r24, 0x0257
    de1a:	90 91 58 02 	lds	r25, 0x0258
    de1e:	90 93 56 02 	sts	0x0256, r25
    de22:	80 93 55 02 	sts	0x0255, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    de26:	30 93 58 02 	sts	0x0258, r19
    de2a:	20 93 57 02 	sts	0x0257, r18
    de2e:	28 c0       	rjmp	.+80     	; 0xde80 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    de30:	20 91 38 02 	lds	r18, 0x0238
    de34:	30 91 39 02 	lds	r19, 0x0239
    de38:	8a 81       	ldd	r24, Y+2	; 0x02
    de3a:	9b 81       	ldd	r25, Y+3	; 0x03
    de3c:	28 17       	cp	r18, r24
    de3e:	39 07       	cpc	r19, r25
    de40:	68 f1       	brcs	.+90     	; 0xde9c <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    de42:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    de44:	8e 01       	movw	r16, r28
    de46:	0e 5f       	subi	r16, 0xFE	; 254
    de48:	1f 4f       	sbci	r17, 0xFF	; 255
    de4a:	c8 01       	movw	r24, r16
    de4c:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    de50:	8c 89       	ldd	r24, Y+20	; 0x14
    de52:	9d 89       	ldd	r25, Y+21	; 0x15
    de54:	89 2b       	or	r24, r25
    de56:	21 f0       	breq	.+8      	; 0xde60 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    de58:	ce 01       	movw	r24, r28
    de5a:	0c 96       	adiw	r24, 0x0c	; 12
    de5c:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    de60:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    de62:	9e 89       	ldd	r25, Y+22	; 0x16
    de64:	80 91 33 02 	lds	r24, 0x0233
    de68:	89 17       	cp	r24, r25
    de6a:	10 f4       	brcc	.+4      	; 0xde70 <vCoRoutineSchedule+0x102>
    de6c:	90 93 33 02 	sts	0x0233, r25
    de70:	9f 9d       	mul	r25, r15
    de72:	c0 01       	movw	r24, r0
    de74:	11 24       	eor	r1, r1
    de76:	86 5c       	subi	r24, 0xC6	; 198
    de78:	9d 4f       	sbci	r25, 0xFD	; 253
    de7a:	b8 01       	movw	r22, r16
    de7c:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    de80:	e0 91 55 02 	lds	r30, 0x0255
    de84:	f0 91 56 02 	lds	r31, 0x0256
    de88:	80 81       	ld	r24, Z
    de8a:	88 23       	and	r24, r24
    de8c:	39 f0       	breq	.+14     	; 0xde9c <vCoRoutineSchedule+0x12e>
    de8e:	05 80       	ldd	r0, Z+5	; 0x05
    de90:	f6 81       	ldd	r31, Z+6	; 0x06
    de92:	e0 2d       	mov	r30, r0
    de94:	c6 81       	ldd	r28, Z+6	; 0x06
    de96:	d7 81       	ldd	r29, Z+7	; 0x07
    de98:	20 97       	sbiw	r28, 0x00	; 0
    de9a:	51 f6       	brne	.-108    	; 0xde30 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    de9c:	20 91 36 02 	lds	r18, 0x0236
    dea0:	30 91 37 02 	lds	r19, 0x0237
    dea4:	80 91 38 02 	lds	r24, 0x0238
    dea8:	90 91 39 02 	lds	r25, 0x0239
    deac:	21 15       	cp	r18, r1
    deae:	31 05       	cpc	r19, r1
    deb0:	09 f0       	breq	.+2      	; 0xdeb4 <vCoRoutineSchedule+0x146>
    deb2:	a0 cf       	rjmp	.-192    	; 0xddf4 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    deb4:	90 93 35 02 	sts	0x0235, r25
    deb8:	80 93 34 02 	sts	0x0234, r24
    debc:	90 91 33 02 	lds	r25, 0x0233

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    dec0:	29 e0       	ldi	r18, 0x09	; 9
    dec2:	06 c0       	rjmp	.+12     	; 0xded0 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    dec4:	99 23       	and	r25, r25
    dec6:	19 f4       	brne	.+6      	; 0xdece <vCoRoutineSchedule+0x160>
    dec8:	10 92 33 02 	sts	0x0233, r1
    decc:	32 c0       	rjmp	.+100    	; 0xdf32 <vCoRoutineSchedule+0x1c4>
    dece:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    ded0:	92 9f       	mul	r25, r18
    ded2:	d0 01       	movw	r26, r0
    ded4:	11 24       	eor	r1, r1
    ded6:	a6 5c       	subi	r26, 0xC6	; 198
    ded8:	bd 4f       	sbci	r27, 0xFD	; 253
    deda:	8c 91       	ld	r24, X
    dedc:	88 23       	and	r24, r24
    dede:	91 f3       	breq	.-28     	; 0xdec4 <vCoRoutineSchedule+0x156>
    dee0:	90 93 33 02 	sts	0x0233, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    dee4:	11 96       	adiw	r26, 0x01	; 1
    dee6:	ed 91       	ld	r30, X+
    dee8:	fc 91       	ld	r31, X
    deea:	12 97       	sbiw	r26, 0x02	; 2
    deec:	02 80       	ldd	r0, Z+2	; 0x02
    deee:	f3 81       	ldd	r31, Z+3	; 0x03
    def0:	e0 2d       	mov	r30, r0
    def2:	12 96       	adiw	r26, 0x02	; 2
    def4:	fc 93       	st	X, r31
    def6:	ee 93       	st	-X, r30
    def8:	11 97       	sbiw	r26, 0x01	; 1
    defa:	cd 01       	movw	r24, r26
    defc:	03 96       	adiw	r24, 0x03	; 3
    defe:	e8 17       	cp	r30, r24
    df00:	f9 07       	cpc	r31, r25
    df02:	31 f4       	brne	.+12     	; 0xdf10 <vCoRoutineSchedule+0x1a2>
    df04:	82 81       	ldd	r24, Z+2	; 0x02
    df06:	93 81       	ldd	r25, Z+3	; 0x03
    df08:	12 96       	adiw	r26, 0x02	; 2
    df0a:	9c 93       	st	X, r25
    df0c:	8e 93       	st	-X, r24
    df0e:	11 97       	sbiw	r26, 0x01	; 1
    df10:	11 96       	adiw	r26, 0x01	; 1
    df12:	ed 91       	ld	r30, X+
    df14:	fc 91       	ld	r31, X
    df16:	12 97       	sbiw	r26, 0x02	; 2
    df18:	06 80       	ldd	r0, Z+6	; 0x06
    df1a:	f7 81       	ldd	r31, Z+7	; 0x07
    df1c:	e0 2d       	mov	r30, r0
    df1e:	f0 93 32 02 	sts	0x0232, r31
    df22:	e0 93 31 02 	sts	0x0231, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    df26:	20 81       	ld	r18, Z
    df28:	31 81       	ldd	r19, Z+1	; 0x01
    df2a:	cf 01       	movw	r24, r30
    df2c:	67 89       	ldd	r22, Z+23	; 0x17
    df2e:	f9 01       	movw	r30, r18
    df30:	09 95       	icall

	return;
}
    df32:	df 91       	pop	r29
    df34:	cf 91       	pop	r28
    df36:	1f 91       	pop	r17
    df38:	0f 91       	pop	r16
    df3a:	ff 90       	pop	r15
    df3c:	08 95       	ret

0000df3e <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    df3e:	0f 93       	push	r16
    df40:	1f 93       	push	r17
    df42:	cf 93       	push	r28
    df44:	df 93       	push	r29
    df46:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    df48:	00 91 38 02 	lds	r16, 0x0238
    df4c:	10 91 39 02 	lds	r17, 0x0239
    df50:	08 0f       	add	r16, r24
    df52:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    df54:	80 91 31 02 	lds	r24, 0x0231
    df58:	90 91 32 02 	lds	r25, 0x0232
    df5c:	02 96       	adiw	r24, 0x02	; 2
    df5e:	0e 94 64 6e 	call	0xdcc8	; 0xdcc8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    df62:	e0 91 31 02 	lds	r30, 0x0231
    df66:	f0 91 32 02 	lds	r31, 0x0232
    df6a:	13 83       	std	Z+3, r17	; 0x03
    df6c:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    df6e:	80 91 38 02 	lds	r24, 0x0238
    df72:	90 91 39 02 	lds	r25, 0x0239
    df76:	bf 01       	movw	r22, r30
    df78:	6e 5f       	subi	r22, 0xFE	; 254
    df7a:	7f 4f       	sbci	r23, 0xFF	; 255
    df7c:	08 17       	cp	r16, r24
    df7e:	19 07       	cpc	r17, r25
    df80:	28 f4       	brcc	.+10     	; 0xdf8c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    df82:	80 91 57 02 	lds	r24, 0x0257
    df86:	90 91 58 02 	lds	r25, 0x0258
    df8a:	04 c0       	rjmp	.+8      	; 0xdf94 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    df8c:	80 91 55 02 	lds	r24, 0x0255
    df90:	90 91 56 02 	lds	r25, 0x0256
    df94:	0e 94 2f 6e 	call	0xdc5e	; 0xdc5e <vListInsert>
	}

	if( pxEventList )
    df98:	20 97       	sbiw	r28, 0x00	; 0
    df9a:	49 f0       	breq	.+18     	; 0xdfae <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    df9c:	60 91 31 02 	lds	r22, 0x0231
    dfa0:	70 91 32 02 	lds	r23, 0x0232
    dfa4:	64 5f       	subi	r22, 0xF4	; 244
    dfa6:	7f 4f       	sbci	r23, 0xFF	; 255
    dfa8:	ce 01       	movw	r24, r28
    dfaa:	0e 94 2f 6e 	call	0xdc5e	; 0xdc5e <vListInsert>
	}
}
    dfae:	df 91       	pop	r29
    dfb0:	cf 91       	pop	r28
    dfb2:	1f 91       	pop	r17
    dfb4:	0f 91       	pop	r16
    dfb6:	08 95       	ret

0000dfb8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    dfb8:	bf 92       	push	r11
    dfba:	cf 92       	push	r12
    dfbc:	df 92       	push	r13
    dfbe:	ef 92       	push	r14
    dfc0:	ff 92       	push	r15
    dfc2:	0f 93       	push	r16
    dfc4:	1f 93       	push	r17
    dfc6:	cf 93       	push	r28
    dfc8:	df 93       	push	r29
    dfca:	6c 01       	movw	r12, r24
    dfcc:	b4 2e       	mov	r11, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    dfce:	8a e1       	ldi	r24, 0x1A	; 26
    dfd0:	90 e0       	ldi	r25, 0x00	; 0
    dfd2:	0e 94 58 70 	call	0xe0b0	; 0xe0b0 <pvPortMalloc>
    dfd6:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    dfd8:	00 97       	sbiw	r24, 0x00	; 0
    dfda:	11 f4       	brne	.+4      	; 0xdfe0 <xCoRoutineCreate+0x28>
    dfdc:	8f ef       	ldi	r24, 0xFF	; 255
    dfde:	4e c0       	rjmp	.+156    	; 0xe07c <xCoRoutineCreate+0xc4>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    dfe0:	80 91 31 02 	lds	r24, 0x0231
    dfe4:	90 91 32 02 	lds	r25, 0x0232
    dfe8:	89 2b       	or	r24, r25
    dfea:	01 f5       	brne	.+64     	; 0xe02c <xCoRoutineCreate+0x74>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    dfec:	d0 93 32 02 	sts	0x0232, r29
    dff0:	c0 93 31 02 	sts	0x0231, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    dff4:	8a e3       	ldi	r24, 0x3A	; 58
    dff6:	92 e0       	ldi	r25, 0x02	; 2
    dff8:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    dffc:	23 e4       	ldi	r18, 0x43	; 67
    dffe:	e2 2e       	mov	r14, r18
    e000:	22 e0       	ldi	r18, 0x02	; 2
    e002:	f2 2e       	mov	r15, r18
    e004:	c7 01       	movw	r24, r14
    e006:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    e00a:	0c e4       	ldi	r16, 0x4C	; 76
    e00c:	12 e0       	ldi	r17, 0x02	; 2
    e00e:	c8 01       	movw	r24, r16
    e010:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    e014:	89 e5       	ldi	r24, 0x59	; 89
    e016:	92 e0       	ldi	r25, 0x02	; 2
    e018:	0e 94 f2 6d 	call	0xdbe4	; 0xdbe4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    e01c:	f0 92 56 02 	sts	0x0256, r15
    e020:	e0 92 55 02 	sts	0x0255, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    e024:	10 93 58 02 	sts	0x0258, r17
    e028:	00 93 57 02 	sts	0x0257, r16
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    e02c:	19 8e       	std	Y+25, r1	; 0x19
    e02e:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    e030:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    e032:	bf 8a       	std	Y+23, r11	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    e034:	fe 01       	movw	r30, r28
    e036:	c1 92       	st	Z+, r12
    e038:	d1 92       	st	Z+, r13
    e03a:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    e03c:	cf 01       	movw	r24, r30
    e03e:	0e 94 02 6e 	call	0xdc04	; 0xdc04 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    e042:	ce 01       	movw	r24, r28
    e044:	0c 96       	adiw	r24, 0x0c	; 12
    e046:	0e 94 02 6e 	call	0xdc04	; 0xdc04 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    e04a:	d9 87       	std	Y+9, r29	; 0x09
    e04c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    e04e:	db 8b       	std	Y+19, r29	; 0x13
    e050:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    e052:	83 e0       	ldi	r24, 0x03	; 3
    e054:	90 e0       	ldi	r25, 0x00	; 0
    e056:	9d 87       	std	Y+13, r25	; 0x0d
    e058:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    e05a:	9e 89       	ldd	r25, Y+22	; 0x16
    e05c:	80 91 33 02 	lds	r24, 0x0233
    e060:	89 17       	cp	r24, r25
    e062:	10 f4       	brcc	.+4      	; 0xe068 <xCoRoutineCreate+0xb0>
    e064:	90 93 33 02 	sts	0x0233, r25
    e068:	89 e0       	ldi	r24, 0x09	; 9
    e06a:	98 9f       	mul	r25, r24
    e06c:	c0 01       	movw	r24, r0
    e06e:	11 24       	eor	r1, r1
    e070:	86 5c       	subi	r24, 0xC6	; 198
    e072:	9d 4f       	sbci	r25, 0xFD	; 253
    e074:	b8 01       	movw	r22, r16
    e076:	0e 94 06 6e 	call	0xdc0c	; 0xdc0c <vListInsertEnd>
    e07a:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    e07c:	df 91       	pop	r29
    e07e:	cf 91       	pop	r28
    e080:	1f 91       	pop	r17
    e082:	0f 91       	pop	r16
    e084:	ff 90       	pop	r15
    e086:	ef 90       	pop	r14
    e088:	df 90       	pop	r13
    e08a:	cf 90       	pop	r12
    e08c:	bf 90       	pop	r11
    e08e:	08 95       	ret

0000e090 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    e090:	08 95       	ret

0000e092 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    e092:	10 92 63 02 	sts	0x0263, r1
    e096:	10 92 62 02 	sts	0x0262, r1
}
    e09a:	08 95       	ret

0000e09c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    e09c:	2c e1       	ldi	r18, 0x1C	; 28
    e09e:	3c e0       	ldi	r19, 0x0C	; 12
    e0a0:	80 91 62 02 	lds	r24, 0x0262
    e0a4:	90 91 63 02 	lds	r25, 0x0263
    e0a8:	28 1b       	sub	r18, r24
    e0aa:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    e0ac:	c9 01       	movw	r24, r18
    e0ae:	08 95       	ret

0000e0b0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    e0b0:	0f 93       	push	r16
    e0b2:	1f 93       	push	r17
    e0b4:	cf 93       	push	r28
    e0b6:	df 93       	push	r29
    e0b8:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    e0ba:	0e 94 e9 63 	call	0xc7d2	; 0xc7d2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    e0be:	80 91 62 02 	lds	r24, 0x0262
    e0c2:	90 91 63 02 	lds	r25, 0x0263
    e0c6:	98 01       	movw	r18, r16
    e0c8:	28 0f       	add	r18, r24
    e0ca:	39 1f       	adc	r19, r25
    e0cc:	4c e0       	ldi	r20, 0x0C	; 12
    e0ce:	2c 31       	cpi	r18, 0x1C	; 28
    e0d0:	34 07       	cpc	r19, r20
    e0d2:	58 f4       	brcc	.+22     	; 0xe0ea <pvPortMalloc+0x3a>
    e0d4:	82 17       	cp	r24, r18
    e0d6:	93 07       	cpc	r25, r19
    e0d8:	40 f4       	brcc	.+16     	; 0xe0ea <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    e0da:	ec 01       	movw	r28, r24
    e0dc:	cc 59       	subi	r28, 0x9C	; 156
    e0de:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    e0e0:	30 93 63 02 	sts	0x0263, r19
    e0e4:	20 93 62 02 	sts	0x0262, r18
    e0e8:	02 c0       	rjmp	.+4      	; 0xe0ee <pvPortMalloc+0x3e>
    e0ea:	c0 e0       	ldi	r28, 0x00	; 0
    e0ec:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    e0ee:	0e 94 0e 67 	call	0xce1c	; 0xce1c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    e0f2:	ce 01       	movw	r24, r28
    e0f4:	df 91       	pop	r29
    e0f6:	cf 91       	pop	r28
    e0f8:	1f 91       	pop	r17
    e0fa:	0f 91       	pop	r16
    e0fc:	08 95       	ret

0000e0fe <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    e0fe:	fc 01       	movw	r30, r24
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    e100:	91 e1       	ldi	r25, 0x11	; 17
    e102:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    e104:	22 e2       	ldi	r18, 0x22	; 34
    e106:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    e108:	83 e3       	ldi	r24, 0x33	; 51
    e10a:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    e10c:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    e10e:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    e110:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    e112:	80 e8       	ldi	r24, 0x80	; 128
    e114:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    e116:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    e118:	82 e0       	ldi	r24, 0x02	; 2
    e11a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    e11c:	83 e0       	ldi	r24, 0x03	; 3
    e11e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    e120:	84 e0       	ldi	r24, 0x04	; 4
    e122:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    e124:	85 e0       	ldi	r24, 0x05	; 5
    e126:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    e128:	86 e0       	ldi	r24, 0x06	; 6
    e12a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    e12c:	87 e0       	ldi	r24, 0x07	; 7
    e12e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    e130:	88 e0       	ldi	r24, 0x08	; 8
    e132:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    e134:	89 e0       	ldi	r24, 0x09	; 9
    e136:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    e138:	80 e1       	ldi	r24, 0x10	; 16
    e13a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    e13c:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    e13e:	82 e1       	ldi	r24, 0x12	; 18
    e140:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    e142:	83 e1       	ldi	r24, 0x13	; 19
    e144:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    e146:	84 e1       	ldi	r24, 0x14	; 20
    e148:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    e14a:	85 e1       	ldi	r24, 0x15	; 21
    e14c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    e14e:	86 e1       	ldi	r24, 0x16	; 22
    e150:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    e152:	87 e1       	ldi	r24, 0x17	; 23
    e154:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    e156:	88 e1       	ldi	r24, 0x18	; 24
    e158:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    e15a:	89 e1       	ldi	r24, 0x19	; 25
    e15c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    e15e:	80 e2       	ldi	r24, 0x20	; 32
    e160:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    e162:	81 e2       	ldi	r24, 0x21	; 33
    e164:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    e166:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    e168:	83 e2       	ldi	r24, 0x23	; 35
    e16a:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    e16c:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    e16e:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    e170:	86 e2       	ldi	r24, 0x26	; 38
    e172:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    e174:	87 e2       	ldi	r24, 0x27	; 39
    e176:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    e178:	88 e2       	ldi	r24, 0x28	; 40
    e17a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    e17c:	89 e2       	ldi	r24, 0x29	; 41
    e17e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    e180:	80 e3       	ldi	r24, 0x30	; 48
    e182:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    e184:	81 e3       	ldi	r24, 0x31	; 49
    e186:	82 93       	st	-Z, r24
    e188:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    e18a:	cf 01       	movw	r24, r30
    e18c:	08 95       	ret

0000e18e <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	OCR1AH = ucHighByte;
    e18e:	88 e0       	ldi	r24, 0x08	; 8
    e190:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
    e192:	8f ef       	ldi	r24, 0xFF	; 255
    e194:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    e196:	8b e0       	ldi	r24, 0x0B	; 11
    e198:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    e19a:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    e19c:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    e19e:	87 bf       	out	0x37, r24	; 55
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    e1a0:	a0 91 a8 01 	lds	r26, 0x01A8
    e1a4:	b0 91 a9 01 	lds	r27, 0x01A9
    e1a8:	cd 91       	ld	r28, X+
    e1aa:	cd bf       	out	0x3d, r28	; 61
    e1ac:	dd 91       	ld	r29, X+
    e1ae:	de bf       	out	0x3e, r29	; 62
    e1b0:	ff 91       	pop	r31
    e1b2:	ef 91       	pop	r30
    e1b4:	df 91       	pop	r29
    e1b6:	cf 91       	pop	r28
    e1b8:	bf 91       	pop	r27
    e1ba:	af 91       	pop	r26
    e1bc:	9f 91       	pop	r25
    e1be:	8f 91       	pop	r24
    e1c0:	7f 91       	pop	r23
    e1c2:	6f 91       	pop	r22
    e1c4:	5f 91       	pop	r21
    e1c6:	4f 91       	pop	r20
    e1c8:	3f 91       	pop	r19
    e1ca:	2f 91       	pop	r18
    e1cc:	1f 91       	pop	r17
    e1ce:	0f 91       	pop	r16
    e1d0:	ff 90       	pop	r15
    e1d2:	ef 90       	pop	r14
    e1d4:	df 90       	pop	r13
    e1d6:	cf 90       	pop	r12
    e1d8:	bf 90       	pop	r11
    e1da:	af 90       	pop	r10
    e1dc:	9f 90       	pop	r9
    e1de:	8f 90       	pop	r8
    e1e0:	7f 90       	pop	r7
    e1e2:	6f 90       	pop	r6
    e1e4:	5f 90       	pop	r5
    e1e6:	4f 90       	pop	r4
    e1e8:	3f 90       	pop	r3
    e1ea:	2f 90       	pop	r2
    e1ec:	1f 90       	pop	r1
    e1ee:	0f 90       	pop	r0
    e1f0:	0f be       	out	0x3f, r0	; 63
    e1f2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    e1f4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    e1f6:	81 e0       	ldi	r24, 0x01	; 1
    e1f8:	08 95       	ret

0000e1fa <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    e1fa:	08 95       	ret

0000e1fc <__vector_12>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    e1fc:	1f 92       	push	r1
    e1fe:	0f 92       	push	r0
    e200:	0f b6       	in	r0, 0x3f	; 63
    e202:	0f 92       	push	r0
    e204:	0b b6       	in	r0, 0x3b	; 59
    e206:	0f 92       	push	r0
    e208:	11 24       	eor	r1, r1
    e20a:	2f 93       	push	r18
    e20c:	3f 93       	push	r19
    e20e:	4f 93       	push	r20
    e210:	5f 93       	push	r21
    e212:	6f 93       	push	r22
    e214:	7f 93       	push	r23
    e216:	8f 93       	push	r24
    e218:	9f 93       	push	r25
    e21a:	af 93       	push	r26
    e21c:	bf 93       	push	r27
    e21e:	ef 93       	push	r30
    e220:	ff 93       	push	r31
		vTaskIncrementTick();
    e222:	0e 94 e6 65 	call	0xcbcc	; 0xcbcc <vTaskIncrementTick>
	}
    e226:	ff 91       	pop	r31
    e228:	ef 91       	pop	r30
    e22a:	bf 91       	pop	r27
    e22c:	af 91       	pop	r26
    e22e:	9f 91       	pop	r25
    e230:	8f 91       	pop	r24
    e232:	7f 91       	pop	r23
    e234:	6f 91       	pop	r22
    e236:	5f 91       	pop	r21
    e238:	4f 91       	pop	r20
    e23a:	3f 91       	pop	r19
    e23c:	2f 91       	pop	r18
    e23e:	0f 90       	pop	r0
    e240:	0b be       	out	0x3b, r0	; 59
    e242:	0f 90       	pop	r0
    e244:	0f be       	out	0x3f, r0	; 63
    e246:	0f 90       	pop	r0
    e248:	1f 90       	pop	r1
    e24a:	18 95       	reti

0000e24c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    e24c:	0f 92       	push	r0
    e24e:	0f b6       	in	r0, 0x3f	; 63
    e250:	f8 94       	cli
    e252:	0f 92       	push	r0
    e254:	1f 92       	push	r1
    e256:	11 24       	eor	r1, r1
    e258:	2f 92       	push	r2
    e25a:	3f 92       	push	r3
    e25c:	4f 92       	push	r4
    e25e:	5f 92       	push	r5
    e260:	6f 92       	push	r6
    e262:	7f 92       	push	r7
    e264:	8f 92       	push	r8
    e266:	9f 92       	push	r9
    e268:	af 92       	push	r10
    e26a:	bf 92       	push	r11
    e26c:	cf 92       	push	r12
    e26e:	df 92       	push	r13
    e270:	ef 92       	push	r14
    e272:	ff 92       	push	r15
    e274:	0f 93       	push	r16
    e276:	1f 93       	push	r17
    e278:	2f 93       	push	r18
    e27a:	3f 93       	push	r19
    e27c:	4f 93       	push	r20
    e27e:	5f 93       	push	r21
    e280:	6f 93       	push	r22
    e282:	7f 93       	push	r23
    e284:	8f 93       	push	r24
    e286:	9f 93       	push	r25
    e288:	af 93       	push	r26
    e28a:	bf 93       	push	r27
    e28c:	cf 93       	push	r28
    e28e:	df 93       	push	r29
    e290:	ef 93       	push	r30
    e292:	ff 93       	push	r31
    e294:	a0 91 a8 01 	lds	r26, 0x01A8
    e298:	b0 91 a9 01 	lds	r27, 0x01A9
    e29c:	0d b6       	in	r0, 0x3d	; 61
    e29e:	0d 92       	st	X+, r0
    e2a0:	0e b6       	in	r0, 0x3e	; 62
    e2a2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    e2a4:	0e 94 e6 65 	call	0xcbcc	; 0xcbcc <vTaskIncrementTick>
	vTaskSwitchContext();
    e2a8:	0e 94 2e 64 	call	0xc85c	; 0xc85c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    e2ac:	a0 91 a8 01 	lds	r26, 0x01A8
    e2b0:	b0 91 a9 01 	lds	r27, 0x01A9
    e2b4:	cd 91       	ld	r28, X+
    e2b6:	cd bf       	out	0x3d, r28	; 61
    e2b8:	dd 91       	ld	r29, X+
    e2ba:	de bf       	out	0x3e, r29	; 62
    e2bc:	ff 91       	pop	r31
    e2be:	ef 91       	pop	r30
    e2c0:	df 91       	pop	r29
    e2c2:	cf 91       	pop	r28
    e2c4:	bf 91       	pop	r27
    e2c6:	af 91       	pop	r26
    e2c8:	9f 91       	pop	r25
    e2ca:	8f 91       	pop	r24
    e2cc:	7f 91       	pop	r23
    e2ce:	6f 91       	pop	r22
    e2d0:	5f 91       	pop	r21
    e2d2:	4f 91       	pop	r20
    e2d4:	3f 91       	pop	r19
    e2d6:	2f 91       	pop	r18
    e2d8:	1f 91       	pop	r17
    e2da:	0f 91       	pop	r16
    e2dc:	ff 90       	pop	r15
    e2de:	ef 90       	pop	r14
    e2e0:	df 90       	pop	r13
    e2e2:	cf 90       	pop	r12
    e2e4:	bf 90       	pop	r11
    e2e6:	af 90       	pop	r10
    e2e8:	9f 90       	pop	r9
    e2ea:	8f 90       	pop	r8
    e2ec:	7f 90       	pop	r7
    e2ee:	6f 90       	pop	r6
    e2f0:	5f 90       	pop	r5
    e2f2:	4f 90       	pop	r4
    e2f4:	3f 90       	pop	r3
    e2f6:	2f 90       	pop	r2
    e2f8:	1f 90       	pop	r1
    e2fa:	0f 90       	pop	r0
    e2fc:	0f be       	out	0x3f, r0	; 63
    e2fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    e300:	08 95       	ret

0000e302 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    e302:	0f 92       	push	r0
    e304:	0f b6       	in	r0, 0x3f	; 63
    e306:	f8 94       	cli
    e308:	0f 92       	push	r0
    e30a:	1f 92       	push	r1
    e30c:	11 24       	eor	r1, r1
    e30e:	2f 92       	push	r2
    e310:	3f 92       	push	r3
    e312:	4f 92       	push	r4
    e314:	5f 92       	push	r5
    e316:	6f 92       	push	r6
    e318:	7f 92       	push	r7
    e31a:	8f 92       	push	r8
    e31c:	9f 92       	push	r9
    e31e:	af 92       	push	r10
    e320:	bf 92       	push	r11
    e322:	cf 92       	push	r12
    e324:	df 92       	push	r13
    e326:	ef 92       	push	r14
    e328:	ff 92       	push	r15
    e32a:	0f 93       	push	r16
    e32c:	1f 93       	push	r17
    e32e:	2f 93       	push	r18
    e330:	3f 93       	push	r19
    e332:	4f 93       	push	r20
    e334:	5f 93       	push	r21
    e336:	6f 93       	push	r22
    e338:	7f 93       	push	r23
    e33a:	8f 93       	push	r24
    e33c:	9f 93       	push	r25
    e33e:	af 93       	push	r26
    e340:	bf 93       	push	r27
    e342:	cf 93       	push	r28
    e344:	df 93       	push	r29
    e346:	ef 93       	push	r30
    e348:	ff 93       	push	r31
    e34a:	a0 91 a8 01 	lds	r26, 0x01A8
    e34e:	b0 91 a9 01 	lds	r27, 0x01A9
    e352:	0d b6       	in	r0, 0x3d	; 61
    e354:	0d 92       	st	X+, r0
    e356:	0e b6       	in	r0, 0x3e	; 62
    e358:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    e35a:	0e 94 2e 64 	call	0xc85c	; 0xc85c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    e35e:	a0 91 a8 01 	lds	r26, 0x01A8
    e362:	b0 91 a9 01 	lds	r27, 0x01A9
    e366:	cd 91       	ld	r28, X+
    e368:	cd bf       	out	0x3d, r28	; 61
    e36a:	dd 91       	ld	r29, X+
    e36c:	de bf       	out	0x3e, r29	; 62
    e36e:	ff 91       	pop	r31
    e370:	ef 91       	pop	r30
    e372:	df 91       	pop	r29
    e374:	cf 91       	pop	r28
    e376:	bf 91       	pop	r27
    e378:	af 91       	pop	r26
    e37a:	9f 91       	pop	r25
    e37c:	8f 91       	pop	r24
    e37e:	7f 91       	pop	r23
    e380:	6f 91       	pop	r22
    e382:	5f 91       	pop	r21
    e384:	4f 91       	pop	r20
    e386:	3f 91       	pop	r19
    e388:	2f 91       	pop	r18
    e38a:	1f 91       	pop	r17
    e38c:	0f 91       	pop	r16
    e38e:	ff 90       	pop	r15
    e390:	ef 90       	pop	r14
    e392:	df 90       	pop	r13
    e394:	cf 90       	pop	r12
    e396:	bf 90       	pop	r11
    e398:	af 90       	pop	r10
    e39a:	9f 90       	pop	r9
    e39c:	8f 90       	pop	r8
    e39e:	7f 90       	pop	r7
    e3a0:	6f 90       	pop	r6
    e3a2:	5f 90       	pop	r5
    e3a4:	4f 90       	pop	r4
    e3a6:	3f 90       	pop	r3
    e3a8:	2f 90       	pop	r2
    e3aa:	1f 90       	pop	r1
    e3ac:	0f 90       	pop	r0
    e3ae:	0f be       	out	0x3f, r0	; 63
    e3b0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    e3b2:	08 95       	ret

0000e3b4 <__udivmodqi4>:
    e3b4:	99 1b       	sub	r25, r25
    e3b6:	79 e0       	ldi	r23, 0x09	; 9
    e3b8:	04 c0       	rjmp	.+8      	; 0xe3c2 <__udivmodqi4_ep>

0000e3ba <__udivmodqi4_loop>:
    e3ba:	99 1f       	adc	r25, r25
    e3bc:	96 17       	cp	r25, r22
    e3be:	08 f0       	brcs	.+2      	; 0xe3c2 <__udivmodqi4_ep>
    e3c0:	96 1b       	sub	r25, r22

0000e3c2 <__udivmodqi4_ep>:
    e3c2:	88 1f       	adc	r24, r24
    e3c4:	7a 95       	dec	r23
    e3c6:	c9 f7       	brne	.-14     	; 0xe3ba <__udivmodqi4_loop>
    e3c8:	80 95       	com	r24
    e3ca:	08 95       	ret

0000e3cc <__udivmodhi4>:
    e3cc:	aa 1b       	sub	r26, r26
    e3ce:	bb 1b       	sub	r27, r27
    e3d0:	51 e1       	ldi	r21, 0x11	; 17
    e3d2:	07 c0       	rjmp	.+14     	; 0xe3e2 <__udivmodhi4_ep>

0000e3d4 <__udivmodhi4_loop>:
    e3d4:	aa 1f       	adc	r26, r26
    e3d6:	bb 1f       	adc	r27, r27
    e3d8:	a6 17       	cp	r26, r22
    e3da:	b7 07       	cpc	r27, r23
    e3dc:	10 f0       	brcs	.+4      	; 0xe3e2 <__udivmodhi4_ep>
    e3de:	a6 1b       	sub	r26, r22
    e3e0:	b7 0b       	sbc	r27, r23

0000e3e2 <__udivmodhi4_ep>:
    e3e2:	88 1f       	adc	r24, r24
    e3e4:	99 1f       	adc	r25, r25
    e3e6:	5a 95       	dec	r21
    e3e8:	a9 f7       	brne	.-22     	; 0xe3d4 <__udivmodhi4_loop>
    e3ea:	80 95       	com	r24
    e3ec:	90 95       	com	r25
    e3ee:	bc 01       	movw	r22, r24
    e3f0:	cd 01       	movw	r24, r26
    e3f2:	08 95       	ret

0000e3f4 <malloc>:
    e3f4:	cf 93       	push	r28
    e3f6:	df 93       	push	r29
    e3f8:	bc 01       	movw	r22, r24
    e3fa:	82 30       	cpi	r24, 0x02	; 2
    e3fc:	91 05       	cpc	r25, r1
    e3fe:	10 f4       	brcc	.+4      	; 0xe404 <malloc+0x10>
    e400:	62 e0       	ldi	r22, 0x02	; 2
    e402:	70 e0       	ldi	r23, 0x00	; 0
    e404:	a0 91 f7 0f 	lds	r26, 0x0FF7
    e408:	b0 91 f8 0f 	lds	r27, 0x0FF8
    e40c:	ed 01       	movw	r28, r26
    e40e:	e0 e0       	ldi	r30, 0x00	; 0
    e410:	f0 e0       	ldi	r31, 0x00	; 0
    e412:	40 e0       	ldi	r20, 0x00	; 0
    e414:	50 e0       	ldi	r21, 0x00	; 0
    e416:	21 c0       	rjmp	.+66     	; 0xe45a <malloc+0x66>
    e418:	88 81       	ld	r24, Y
    e41a:	99 81       	ldd	r25, Y+1	; 0x01
    e41c:	86 17       	cp	r24, r22
    e41e:	97 07       	cpc	r25, r23
    e420:	69 f4       	brne	.+26     	; 0xe43c <malloc+0x48>
    e422:	8a 81       	ldd	r24, Y+2	; 0x02
    e424:	9b 81       	ldd	r25, Y+3	; 0x03
    e426:	30 97       	sbiw	r30, 0x00	; 0
    e428:	19 f0       	breq	.+6      	; 0xe430 <malloc+0x3c>
    e42a:	93 83       	std	Z+3, r25	; 0x03
    e42c:	82 83       	std	Z+2, r24	; 0x02
    e42e:	04 c0       	rjmp	.+8      	; 0xe438 <malloc+0x44>
    e430:	90 93 f8 0f 	sts	0x0FF8, r25
    e434:	80 93 f7 0f 	sts	0x0FF7, r24
    e438:	fe 01       	movw	r30, r28
    e43a:	34 c0       	rjmp	.+104    	; 0xe4a4 <malloc+0xb0>
    e43c:	68 17       	cp	r22, r24
    e43e:	79 07       	cpc	r23, r25
    e440:	38 f4       	brcc	.+14     	; 0xe450 <malloc+0x5c>
    e442:	41 15       	cp	r20, r1
    e444:	51 05       	cpc	r21, r1
    e446:	19 f0       	breq	.+6      	; 0xe44e <malloc+0x5a>
    e448:	84 17       	cp	r24, r20
    e44a:	95 07       	cpc	r25, r21
    e44c:	08 f4       	brcc	.+2      	; 0xe450 <malloc+0x5c>
    e44e:	ac 01       	movw	r20, r24
    e450:	fe 01       	movw	r30, r28
    e452:	8a 81       	ldd	r24, Y+2	; 0x02
    e454:	9b 81       	ldd	r25, Y+3	; 0x03
    e456:	9c 01       	movw	r18, r24
    e458:	e9 01       	movw	r28, r18
    e45a:	20 97       	sbiw	r28, 0x00	; 0
    e45c:	e9 f6       	brne	.-70     	; 0xe418 <malloc+0x24>
    e45e:	41 15       	cp	r20, r1
    e460:	51 05       	cpc	r21, r1
    e462:	a9 f1       	breq	.+106    	; 0xe4ce <malloc+0xda>
    e464:	ca 01       	movw	r24, r20
    e466:	86 1b       	sub	r24, r22
    e468:	97 0b       	sbc	r25, r23
    e46a:	04 97       	sbiw	r24, 0x04	; 4
    e46c:	08 f4       	brcc	.+2      	; 0xe470 <malloc+0x7c>
    e46e:	ba 01       	movw	r22, r20
    e470:	e0 e0       	ldi	r30, 0x00	; 0
    e472:	f0 e0       	ldi	r31, 0x00	; 0
    e474:	2a c0       	rjmp	.+84     	; 0xe4ca <malloc+0xd6>
    e476:	8d 91       	ld	r24, X+
    e478:	9c 91       	ld	r25, X
    e47a:	11 97       	sbiw	r26, 0x01	; 1
    e47c:	84 17       	cp	r24, r20
    e47e:	95 07       	cpc	r25, r21
    e480:	f9 f4       	brne	.+62     	; 0xe4c0 <malloc+0xcc>
    e482:	64 17       	cp	r22, r20
    e484:	75 07       	cpc	r23, r21
    e486:	81 f4       	brne	.+32     	; 0xe4a8 <malloc+0xb4>
    e488:	12 96       	adiw	r26, 0x02	; 2
    e48a:	8d 91       	ld	r24, X+
    e48c:	9c 91       	ld	r25, X
    e48e:	13 97       	sbiw	r26, 0x03	; 3
    e490:	30 97       	sbiw	r30, 0x00	; 0
    e492:	19 f0       	breq	.+6      	; 0xe49a <malloc+0xa6>
    e494:	93 83       	std	Z+3, r25	; 0x03
    e496:	82 83       	std	Z+2, r24	; 0x02
    e498:	04 c0       	rjmp	.+8      	; 0xe4a2 <malloc+0xae>
    e49a:	90 93 f8 0f 	sts	0x0FF8, r25
    e49e:	80 93 f7 0f 	sts	0x0FF7, r24
    e4a2:	fd 01       	movw	r30, r26
    e4a4:	32 96       	adiw	r30, 0x02	; 2
    e4a6:	4f c0       	rjmp	.+158    	; 0xe546 <malloc+0x152>
    e4a8:	ca 01       	movw	r24, r20
    e4aa:	86 1b       	sub	r24, r22
    e4ac:	97 0b       	sbc	r25, r23
    e4ae:	fd 01       	movw	r30, r26
    e4b0:	e8 0f       	add	r30, r24
    e4b2:	f9 1f       	adc	r31, r25
    e4b4:	61 93       	st	Z+, r22
    e4b6:	71 93       	st	Z+, r23
    e4b8:	02 97       	sbiw	r24, 0x02	; 2
    e4ba:	8d 93       	st	X+, r24
    e4bc:	9c 93       	st	X, r25
    e4be:	43 c0       	rjmp	.+134    	; 0xe546 <malloc+0x152>
    e4c0:	fd 01       	movw	r30, r26
    e4c2:	82 81       	ldd	r24, Z+2	; 0x02
    e4c4:	93 81       	ldd	r25, Z+3	; 0x03
    e4c6:	9c 01       	movw	r18, r24
    e4c8:	d9 01       	movw	r26, r18
    e4ca:	10 97       	sbiw	r26, 0x00	; 0
    e4cc:	a1 f6       	brne	.-88     	; 0xe476 <malloc+0x82>
    e4ce:	80 91 f5 0f 	lds	r24, 0x0FF5
    e4d2:	90 91 f6 0f 	lds	r25, 0x0FF6
    e4d6:	89 2b       	or	r24, r25
    e4d8:	41 f4       	brne	.+16     	; 0xe4ea <malloc+0xf6>
    e4da:	80 91 84 01 	lds	r24, 0x0184
    e4de:	90 91 85 01 	lds	r25, 0x0185
    e4e2:	90 93 f6 0f 	sts	0x0FF6, r25
    e4e6:	80 93 f5 0f 	sts	0x0FF5, r24
    e4ea:	40 91 86 01 	lds	r20, 0x0186
    e4ee:	50 91 87 01 	lds	r21, 0x0187
    e4f2:	41 15       	cp	r20, r1
    e4f4:	51 05       	cpc	r21, r1
    e4f6:	41 f4       	brne	.+16     	; 0xe508 <malloc+0x114>
    e4f8:	4d b7       	in	r20, 0x3d	; 61
    e4fa:	5e b7       	in	r21, 0x3e	; 62
    e4fc:	80 91 82 01 	lds	r24, 0x0182
    e500:	90 91 83 01 	lds	r25, 0x0183
    e504:	48 1b       	sub	r20, r24
    e506:	59 0b       	sbc	r21, r25
    e508:	20 91 f5 0f 	lds	r18, 0x0FF5
    e50c:	30 91 f6 0f 	lds	r19, 0x0FF6
    e510:	24 17       	cp	r18, r20
    e512:	35 07       	cpc	r19, r21
    e514:	b0 f4       	brcc	.+44     	; 0xe542 <malloc+0x14e>
    e516:	ca 01       	movw	r24, r20
    e518:	82 1b       	sub	r24, r18
    e51a:	93 0b       	sbc	r25, r19
    e51c:	86 17       	cp	r24, r22
    e51e:	97 07       	cpc	r25, r23
    e520:	80 f0       	brcs	.+32     	; 0xe542 <malloc+0x14e>
    e522:	ab 01       	movw	r20, r22
    e524:	4e 5f       	subi	r20, 0xFE	; 254
    e526:	5f 4f       	sbci	r21, 0xFF	; 255
    e528:	84 17       	cp	r24, r20
    e52a:	95 07       	cpc	r25, r21
    e52c:	50 f0       	brcs	.+20     	; 0xe542 <malloc+0x14e>
    e52e:	42 0f       	add	r20, r18
    e530:	53 1f       	adc	r21, r19
    e532:	50 93 f6 0f 	sts	0x0FF6, r21
    e536:	40 93 f5 0f 	sts	0x0FF5, r20
    e53a:	f9 01       	movw	r30, r18
    e53c:	61 93       	st	Z+, r22
    e53e:	71 93       	st	Z+, r23
    e540:	02 c0       	rjmp	.+4      	; 0xe546 <malloc+0x152>
    e542:	e0 e0       	ldi	r30, 0x00	; 0
    e544:	f0 e0       	ldi	r31, 0x00	; 0
    e546:	cf 01       	movw	r24, r30
    e548:	df 91       	pop	r29
    e54a:	cf 91       	pop	r28
    e54c:	08 95       	ret

0000e54e <free>:
    e54e:	cf 93       	push	r28
    e550:	df 93       	push	r29
    e552:	00 97       	sbiw	r24, 0x00	; 0
    e554:	09 f4       	brne	.+2      	; 0xe558 <free+0xa>
    e556:	50 c0       	rjmp	.+160    	; 0xe5f8 <free+0xaa>
    e558:	ec 01       	movw	r28, r24
    e55a:	22 97       	sbiw	r28, 0x02	; 2
    e55c:	1b 82       	std	Y+3, r1	; 0x03
    e55e:	1a 82       	std	Y+2, r1	; 0x02
    e560:	a0 91 f7 0f 	lds	r26, 0x0FF7
    e564:	b0 91 f8 0f 	lds	r27, 0x0FF8
    e568:	10 97       	sbiw	r26, 0x00	; 0
    e56a:	09 f1       	breq	.+66     	; 0xe5ae <free+0x60>
    e56c:	40 e0       	ldi	r20, 0x00	; 0
    e56e:	50 e0       	ldi	r21, 0x00	; 0
    e570:	ac 17       	cp	r26, r28
    e572:	bd 07       	cpc	r27, r29
    e574:	08 f1       	brcs	.+66     	; 0xe5b8 <free+0x6a>
    e576:	bb 83       	std	Y+3, r27	; 0x03
    e578:	aa 83       	std	Y+2, r26	; 0x02
    e57a:	fe 01       	movw	r30, r28
    e57c:	21 91       	ld	r18, Z+
    e57e:	31 91       	ld	r19, Z+
    e580:	e2 0f       	add	r30, r18
    e582:	f3 1f       	adc	r31, r19
    e584:	ae 17       	cp	r26, r30
    e586:	bf 07       	cpc	r27, r31
    e588:	79 f4       	brne	.+30     	; 0xe5a8 <free+0x5a>
    e58a:	8d 91       	ld	r24, X+
    e58c:	9c 91       	ld	r25, X
    e58e:	11 97       	sbiw	r26, 0x01	; 1
    e590:	28 0f       	add	r18, r24
    e592:	39 1f       	adc	r19, r25
    e594:	2e 5f       	subi	r18, 0xFE	; 254
    e596:	3f 4f       	sbci	r19, 0xFF	; 255
    e598:	39 83       	std	Y+1, r19	; 0x01
    e59a:	28 83       	st	Y, r18
    e59c:	12 96       	adiw	r26, 0x02	; 2
    e59e:	8d 91       	ld	r24, X+
    e5a0:	9c 91       	ld	r25, X
    e5a2:	13 97       	sbiw	r26, 0x03	; 3
    e5a4:	9b 83       	std	Y+3, r25	; 0x03
    e5a6:	8a 83       	std	Y+2, r24	; 0x02
    e5a8:	41 15       	cp	r20, r1
    e5aa:	51 05       	cpc	r21, r1
    e5ac:	71 f4       	brne	.+28     	; 0xe5ca <free+0x7c>
    e5ae:	d0 93 f8 0f 	sts	0x0FF8, r29
    e5b2:	c0 93 f7 0f 	sts	0x0FF7, r28
    e5b6:	20 c0       	rjmp	.+64     	; 0xe5f8 <free+0xaa>
    e5b8:	12 96       	adiw	r26, 0x02	; 2
    e5ba:	8d 91       	ld	r24, X+
    e5bc:	9c 91       	ld	r25, X
    e5be:	13 97       	sbiw	r26, 0x03	; 3
    e5c0:	ad 01       	movw	r20, r26
    e5c2:	00 97       	sbiw	r24, 0x00	; 0
    e5c4:	11 f0       	breq	.+4      	; 0xe5ca <free+0x7c>
    e5c6:	dc 01       	movw	r26, r24
    e5c8:	d3 cf       	rjmp	.-90     	; 0xe570 <free+0x22>
    e5ca:	fa 01       	movw	r30, r20
    e5cc:	d3 83       	std	Z+3, r29	; 0x03
    e5ce:	c2 83       	std	Z+2, r28	; 0x02
    e5d0:	21 91       	ld	r18, Z+
    e5d2:	31 91       	ld	r19, Z+
    e5d4:	e2 0f       	add	r30, r18
    e5d6:	f3 1f       	adc	r31, r19
    e5d8:	ce 17       	cp	r28, r30
    e5da:	df 07       	cpc	r29, r31
    e5dc:	69 f4       	brne	.+26     	; 0xe5f8 <free+0xaa>
    e5de:	88 81       	ld	r24, Y
    e5e0:	99 81       	ldd	r25, Y+1	; 0x01
    e5e2:	28 0f       	add	r18, r24
    e5e4:	39 1f       	adc	r19, r25
    e5e6:	2e 5f       	subi	r18, 0xFE	; 254
    e5e8:	3f 4f       	sbci	r19, 0xFF	; 255
    e5ea:	fa 01       	movw	r30, r20
    e5ec:	31 83       	std	Z+1, r19	; 0x01
    e5ee:	20 83       	st	Z, r18
    e5f0:	8a 81       	ldd	r24, Y+2	; 0x02
    e5f2:	9b 81       	ldd	r25, Y+3	; 0x03
    e5f4:	93 83       	std	Z+3, r25	; 0x03
    e5f6:	82 83       	std	Z+2, r24	; 0x02
    e5f8:	df 91       	pop	r29
    e5fa:	cf 91       	pop	r28
    e5fc:	08 95       	ret

0000e5fe <strtol>:
    e5fe:	2f 92       	push	r2
    e600:	3f 92       	push	r3
    e602:	5f 92       	push	r5
    e604:	6f 92       	push	r6
    e606:	7f 92       	push	r7
    e608:	8f 92       	push	r8
    e60a:	9f 92       	push	r9
    e60c:	af 92       	push	r10
    e60e:	bf 92       	push	r11
    e610:	cf 92       	push	r12
    e612:	df 92       	push	r13
    e614:	ef 92       	push	r14
    e616:	ff 92       	push	r15
    e618:	0f 93       	push	r16
    e61a:	1f 93       	push	r17
    e61c:	cf 93       	push	r28
    e61e:	df 93       	push	r29
    e620:	8c 01       	movw	r16, r24
    e622:	1b 01       	movw	r2, r22
    e624:	ea 01       	movw	r28, r20
    e626:	61 15       	cp	r22, r1
    e628:	71 05       	cpc	r23, r1
    e62a:	19 f0       	breq	.+6      	; 0xe632 <strtol+0x34>
    e62c:	fb 01       	movw	r30, r22
    e62e:	91 83       	std	Z+1, r25	; 0x01
    e630:	80 83       	st	Z, r24
    e632:	20 97       	sbiw	r28, 0x00	; 0
    e634:	49 f0       	breq	.+18     	; 0xe648 <strtol+0x4a>
    e636:	ce 01       	movw	r24, r28
    e638:	02 97       	sbiw	r24, 0x02	; 2
    e63a:	83 97       	sbiw	r24, 0x23	; 35
    e63c:	28 f0       	brcs	.+10     	; 0xe648 <strtol+0x4a>
    e63e:	20 e0       	ldi	r18, 0x00	; 0
    e640:	30 e0       	ldi	r19, 0x00	; 0
    e642:	40 e0       	ldi	r20, 0x00	; 0
    e644:	50 e0       	ldi	r21, 0x00	; 0
    e646:	f6 c0       	rjmp	.+492    	; 0xe834 <strtol+0x236>
    e648:	f8 01       	movw	r30, r16
    e64a:	a1 90       	ld	r10, Z+
    e64c:	8f 01       	movw	r16, r30
    e64e:	8a 2d       	mov	r24, r10
    e650:	90 e0       	ldi	r25, 0x00	; 0
    e652:	0e 94 2e 74 	call	0xe85c	; 0xe85c <isspace>
    e656:	89 2b       	or	r24, r25
    e658:	b9 f7       	brne	.-18     	; 0xe648 <strtol+0x4a>
    e65a:	fd e2       	ldi	r31, 0x2D	; 45
    e65c:	af 16       	cp	r10, r31
    e65e:	31 f4       	brne	.+12     	; 0xe66c <strtol+0x6e>
    e660:	f8 01       	movw	r30, r16
    e662:	a1 90       	ld	r10, Z+
    e664:	8f 01       	movw	r16, r30
    e666:	55 24       	eor	r5, r5
    e668:	53 94       	inc	r5
    e66a:	07 c0       	rjmp	.+14     	; 0xe67a <strtol+0x7c>
    e66c:	fb e2       	ldi	r31, 0x2B	; 43
    e66e:	af 16       	cp	r10, r31
    e670:	19 f4       	brne	.+6      	; 0xe678 <strtol+0x7a>
    e672:	f8 01       	movw	r30, r16
    e674:	a1 90       	ld	r10, Z+
    e676:	8f 01       	movw	r16, r30
    e678:	55 24       	eor	r5, r5
    e67a:	20 97       	sbiw	r28, 0x00	; 0
    e67c:	19 f0       	breq	.+6      	; 0xe684 <strtol+0x86>
    e67e:	c0 31       	cpi	r28, 0x10	; 16
    e680:	d1 05       	cpc	r29, r1
    e682:	c1 f4       	brne	.+48     	; 0xe6b4 <strtol+0xb6>
    e684:	f0 e3       	ldi	r31, 0x30	; 48
    e686:	af 16       	cp	r10, r31
    e688:	79 f4       	brne	.+30     	; 0xe6a8 <strtol+0xaa>
    e68a:	f8 01       	movw	r30, r16
    e68c:	80 81       	ld	r24, Z
    e68e:	88 37       	cpi	r24, 0x78	; 120
    e690:	11 f0       	breq	.+4      	; 0xe696 <strtol+0x98>
    e692:	88 35       	cpi	r24, 0x58	; 88
    e694:	49 f4       	brne	.+18     	; 0xe6a8 <strtol+0xaa>
    e696:	f8 01       	movw	r30, r16
    e698:	a1 80       	ldd	r10, Z+1	; 0x01
    e69a:	0e 5f       	subi	r16, 0xFE	; 254
    e69c:	1f 4f       	sbci	r17, 0xFF	; 255
    e69e:	f2 e0       	ldi	r31, 0x02	; 2
    e6a0:	5f 2a       	or	r5, r31
    e6a2:	c0 e1       	ldi	r28, 0x10	; 16
    e6a4:	d0 e0       	ldi	r29, 0x00	; 0
    e6a6:	06 c0       	rjmp	.+12     	; 0xe6b4 <strtol+0xb6>
    e6a8:	20 97       	sbiw	r28, 0x00	; 0
    e6aa:	21 f4       	brne	.+8      	; 0xe6b4 <strtol+0xb6>
    e6ac:	80 e3       	ldi	r24, 0x30	; 48
    e6ae:	a8 16       	cp	r10, r24
    e6b0:	e9 f4       	brne	.+58     	; 0xe6ec <strtol+0xee>
    e6b2:	27 c0       	rjmp	.+78     	; 0xe702 <strtol+0x104>
    e6b4:	c8 30       	cpi	r28, 0x08	; 8
    e6b6:	d1 05       	cpc	r29, r1
    e6b8:	31 f1       	breq	.+76     	; 0xe706 <strtol+0x108>
    e6ba:	c9 30       	cpi	r28, 0x09	; 9
    e6bc:	d1 05       	cpc	r29, r1
    e6be:	24 f4       	brge	.+8      	; 0xe6c8 <strtol+0xca>
    e6c0:	c2 30       	cpi	r28, 0x02	; 2
    e6c2:	d1 05       	cpc	r29, r1
    e6c4:	31 f5       	brne	.+76     	; 0xe712 <strtol+0x114>
    e6c6:	0c c0       	rjmp	.+24     	; 0xe6e0 <strtol+0xe2>
    e6c8:	ca 30       	cpi	r28, 0x0A	; 10
    e6ca:	d1 05       	cpc	r29, r1
    e6cc:	89 f0       	breq	.+34     	; 0xe6f0 <strtol+0xf2>
    e6ce:	c0 31       	cpi	r28, 0x10	; 16
    e6d0:	d1 05       	cpc	r29, r1
    e6d2:	f9 f4       	brne	.+62     	; 0xe712 <strtol+0x114>
    e6d4:	c1 2c       	mov	r12, r1
    e6d6:	d1 2c       	mov	r13, r1
    e6d8:	e1 2c       	mov	r14, r1
    e6da:	b8 e0       	ldi	r27, 0x08	; 8
    e6dc:	fb 2e       	mov	r15, r27
    e6de:	28 c0       	rjmp	.+80     	; 0xe730 <strtol+0x132>
    e6e0:	c1 2c       	mov	r12, r1
    e6e2:	d1 2c       	mov	r13, r1
    e6e4:	e1 2c       	mov	r14, r1
    e6e6:	a0 e4       	ldi	r26, 0x40	; 64
    e6e8:	fa 2e       	mov	r15, r26
    e6ea:	22 c0       	rjmp	.+68     	; 0xe730 <strtol+0x132>
    e6ec:	ca e0       	ldi	r28, 0x0A	; 10
    e6ee:	d0 e0       	ldi	r29, 0x00	; 0
    e6f0:	fc ec       	ldi	r31, 0xCC	; 204
    e6f2:	cf 2e       	mov	r12, r31
    e6f4:	fc ec       	ldi	r31, 0xCC	; 204
    e6f6:	df 2e       	mov	r13, r31
    e6f8:	fc ec       	ldi	r31, 0xCC	; 204
    e6fa:	ef 2e       	mov	r14, r31
    e6fc:	fc e0       	ldi	r31, 0x0C	; 12
    e6fe:	ff 2e       	mov	r15, r31
    e700:	17 c0       	rjmp	.+46     	; 0xe730 <strtol+0x132>
    e702:	c8 e0       	ldi	r28, 0x08	; 8
    e704:	d0 e0       	ldi	r29, 0x00	; 0
    e706:	c1 2c       	mov	r12, r1
    e708:	d1 2c       	mov	r13, r1
    e70a:	e1 2c       	mov	r14, r1
    e70c:	e0 e1       	ldi	r30, 0x10	; 16
    e70e:	fe 2e       	mov	r15, r30
    e710:	0f c0       	rjmp	.+30     	; 0xe730 <strtol+0x132>
    e712:	9e 01       	movw	r18, r28
    e714:	44 27       	eor	r20, r20
    e716:	37 fd       	sbrc	r19, 7
    e718:	40 95       	com	r20
    e71a:	54 2f       	mov	r21, r20
    e71c:	60 e0       	ldi	r22, 0x00	; 0
    e71e:	70 e0       	ldi	r23, 0x00	; 0
    e720:	80 e0       	ldi	r24, 0x00	; 0
    e722:	90 e8       	ldi	r25, 0x80	; 128
    e724:	0e 94 a8 78 	call	0xf150	; 0xf150 <__udivmodsi4>
    e728:	c9 01       	movw	r24, r18
    e72a:	da 01       	movw	r26, r20
    e72c:	6c 01       	movw	r12, r24
    e72e:	7d 01       	movw	r14, r26
    e730:	20 e0       	ldi	r18, 0x00	; 0
    e732:	30 e0       	ldi	r19, 0x00	; 0
    e734:	40 e0       	ldi	r20, 0x00	; 0
    e736:	50 e0       	ldi	r21, 0x00	; 0
    e738:	60 e0       	ldi	r22, 0x00	; 0
    e73a:	3e 01       	movw	r6, r28
    e73c:	88 24       	eor	r8, r8
    e73e:	77 fc       	sbrc	r7, 7
    e740:	80 94       	com	r8
    e742:	98 2c       	mov	r9, r8
    e744:	70 ed       	ldi	r23, 0xD0	; 208
    e746:	b7 2e       	mov	r11, r23
    e748:	ba 0c       	add	r11, r10
    e74a:	e9 e0       	ldi	r30, 0x09	; 9
    e74c:	eb 15       	cp	r30, r11
    e74e:	70 f4       	brcc	.+28     	; 0xe76c <strtol+0x16e>
    e750:	8a 2d       	mov	r24, r10
    e752:	81 54       	subi	r24, 0x41	; 65
    e754:	8a 31       	cpi	r24, 0x1A	; 26
    e756:	18 f4       	brcc	.+6      	; 0xe75e <strtol+0x160>
    e758:	99 ec       	ldi	r25, 0xC9	; 201
    e75a:	b9 2e       	mov	r11, r25
    e75c:	06 c0       	rjmp	.+12     	; 0xe76a <strtol+0x16c>
    e75e:	8a 2d       	mov	r24, r10
    e760:	81 56       	subi	r24, 0x61	; 97
    e762:	8a 31       	cpi	r24, 0x1A	; 26
    e764:	50 f5       	brcc	.+84     	; 0xe7ba <strtol+0x1bc>
    e766:	89 ea       	ldi	r24, 0xA9	; 169
    e768:	b8 2e       	mov	r11, r24
    e76a:	ba 0c       	add	r11, r10
    e76c:	8b 2d       	mov	r24, r11
    e76e:	90 e0       	ldi	r25, 0x00	; 0
    e770:	8c 17       	cp	r24, r28
    e772:	9d 07       	cpc	r25, r29
    e774:	14 f5       	brge	.+68     	; 0xe7ba <strtol+0x1bc>
    e776:	6f 3f       	cpi	r22, 0xFF	; 255
    e778:	e1 f0       	breq	.+56     	; 0xe7b2 <strtol+0x1b4>
    e77a:	c2 16       	cp	r12, r18
    e77c:	d3 06       	cpc	r13, r19
    e77e:	e4 06       	cpc	r14, r20
    e780:	f5 06       	cpc	r15, r21
    e782:	b0 f0       	brcs	.+44     	; 0xe7b0 <strtol+0x1b2>
    e784:	ca 01       	movw	r24, r20
    e786:	b9 01       	movw	r22, r18
    e788:	a4 01       	movw	r20, r8
    e78a:	93 01       	movw	r18, r6
    e78c:	0e 94 89 78 	call	0xf112	; 0xf112 <__mulsi3>
    e790:	9b 01       	movw	r18, r22
    e792:	ac 01       	movw	r20, r24
    e794:	2b 0d       	add	r18, r11
    e796:	31 1d       	adc	r19, r1
    e798:	41 1d       	adc	r20, r1
    e79a:	51 1d       	adc	r21, r1
    e79c:	21 30       	cpi	r18, 0x01	; 1
    e79e:	f0 e0       	ldi	r31, 0x00	; 0
    e7a0:	3f 07       	cpc	r19, r31
    e7a2:	f0 e0       	ldi	r31, 0x00	; 0
    e7a4:	4f 07       	cpc	r20, r31
    e7a6:	f0 e8       	ldi	r31, 0x80	; 128
    e7a8:	5f 07       	cpc	r21, r31
    e7aa:	10 f4       	brcc	.+4      	; 0xe7b0 <strtol+0x1b2>
    e7ac:	61 e0       	ldi	r22, 0x01	; 1
    e7ae:	01 c0       	rjmp	.+2      	; 0xe7b2 <strtol+0x1b4>
    e7b0:	6f ef       	ldi	r22, 0xFF	; 255
    e7b2:	f8 01       	movw	r30, r16
    e7b4:	a1 90       	ld	r10, Z+
    e7b6:	8f 01       	movw	r16, r30
    e7b8:	c5 cf       	rjmp	.-118    	; 0xe744 <strtol+0x146>
    e7ba:	21 14       	cp	r2, r1
    e7bc:	31 04       	cpc	r3, r1
    e7be:	81 f0       	breq	.+32     	; 0xe7e0 <strtol+0x1e2>
    e7c0:	66 23       	and	r22, r22
    e7c2:	31 f0       	breq	.+12     	; 0xe7d0 <strtol+0x1d2>
    e7c4:	01 50       	subi	r16, 0x01	; 1
    e7c6:	10 40       	sbci	r17, 0x00	; 0
    e7c8:	f1 01       	movw	r30, r2
    e7ca:	11 83       	std	Z+1, r17	; 0x01
    e7cc:	00 83       	st	Z, r16
    e7ce:	08 c0       	rjmp	.+16     	; 0xe7e0 <strtol+0x1e2>
    e7d0:	51 fe       	sbrs	r5, 1
    e7d2:	1a c0       	rjmp	.+52     	; 0xe808 <strtol+0x20a>
    e7d4:	02 50       	subi	r16, 0x02	; 2
    e7d6:	10 40       	sbci	r17, 0x00	; 0
    e7d8:	f1 01       	movw	r30, r2
    e7da:	11 83       	std	Z+1, r17	; 0x01
    e7dc:	00 83       	st	Z, r16
    e7de:	14 c0       	rjmp	.+40     	; 0xe808 <strtol+0x20a>
    e7e0:	67 ff       	sbrs	r22, 7
    e7e2:	12 c0       	rjmp	.+36     	; 0xe808 <strtol+0x20a>
    e7e4:	50 fc       	sbrc	r5, 0
    e7e6:	05 c0       	rjmp	.+10     	; 0xe7f2 <strtol+0x1f4>
    e7e8:	2f ef       	ldi	r18, 0xFF	; 255
    e7ea:	3f ef       	ldi	r19, 0xFF	; 255
    e7ec:	4f ef       	ldi	r20, 0xFF	; 255
    e7ee:	5f e7       	ldi	r21, 0x7F	; 127
    e7f0:	04 c0       	rjmp	.+8      	; 0xe7fa <strtol+0x1fc>
    e7f2:	20 e0       	ldi	r18, 0x00	; 0
    e7f4:	30 e0       	ldi	r19, 0x00	; 0
    e7f6:	40 e0       	ldi	r20, 0x00	; 0
    e7f8:	50 e8       	ldi	r21, 0x80	; 128
    e7fa:	82 e2       	ldi	r24, 0x22	; 34
    e7fc:	90 e0       	ldi	r25, 0x00	; 0
    e7fe:	90 93 00 10 	sts	0x1000, r25
    e802:	80 93 ff 0f 	sts	0x0FFF, r24
    e806:	16 c0       	rjmp	.+44     	; 0xe834 <strtol+0x236>
    e808:	50 fe       	sbrs	r5, 0
    e80a:	08 c0       	rjmp	.+16     	; 0xe81c <strtol+0x21e>
    e80c:	50 95       	com	r21
    e80e:	40 95       	com	r20
    e810:	30 95       	com	r19
    e812:	21 95       	neg	r18
    e814:	3f 4f       	sbci	r19, 0xFF	; 255
    e816:	4f 4f       	sbci	r20, 0xFF	; 255
    e818:	5f 4f       	sbci	r21, 0xFF	; 255
    e81a:	0c c0       	rjmp	.+24     	; 0xe834 <strtol+0x236>
    e81c:	57 ff       	sbrs	r21, 7
    e81e:	0a c0       	rjmp	.+20     	; 0xe834 <strtol+0x236>
    e820:	82 e2       	ldi	r24, 0x22	; 34
    e822:	90 e0       	ldi	r25, 0x00	; 0
    e824:	90 93 00 10 	sts	0x1000, r25
    e828:	80 93 ff 0f 	sts	0x0FFF, r24
    e82c:	2f ef       	ldi	r18, 0xFF	; 255
    e82e:	3f ef       	ldi	r19, 0xFF	; 255
    e830:	4f ef       	ldi	r20, 0xFF	; 255
    e832:	5f e7       	ldi	r21, 0x7F	; 127
    e834:	b9 01       	movw	r22, r18
    e836:	ca 01       	movw	r24, r20
    e838:	df 91       	pop	r29
    e83a:	cf 91       	pop	r28
    e83c:	1f 91       	pop	r17
    e83e:	0f 91       	pop	r16
    e840:	ff 90       	pop	r15
    e842:	ef 90       	pop	r14
    e844:	df 90       	pop	r13
    e846:	cf 90       	pop	r12
    e848:	bf 90       	pop	r11
    e84a:	af 90       	pop	r10
    e84c:	9f 90       	pop	r9
    e84e:	8f 90       	pop	r8
    e850:	7f 90       	pop	r7
    e852:	6f 90       	pop	r6
    e854:	5f 90       	pop	r5
    e856:	3f 90       	pop	r3
    e858:	2f 90       	pop	r2
    e85a:	08 95       	ret

0000e85c <isspace>:
    e85c:	91 11       	cpse	r25, r1
    e85e:	e2 c3       	rjmp	.+1988   	; 0xf024 <__ctype_isfalse>
    e860:	80 32       	cpi	r24, 0x20	; 32
    e862:	19 f0       	breq	.+6      	; 0xe86a <isspace+0xe>
    e864:	89 50       	subi	r24, 0x09	; 9
    e866:	85 50       	subi	r24, 0x05	; 5
    e868:	d0 f7       	brcc	.-12     	; 0xe85e <isspace+0x2>
    e86a:	08 95       	ret

0000e86c <memcpy_P>:
    e86c:	fb 01       	movw	r30, r22
    e86e:	dc 01       	movw	r26, r24
    e870:	02 c0       	rjmp	.+4      	; 0xe876 <memcpy_P+0xa>
    e872:	05 90       	lpm	r0, Z+
    e874:	0d 92       	st	X+, r0
    e876:	41 50       	subi	r20, 0x01	; 1
    e878:	50 40       	sbci	r21, 0x00	; 0
    e87a:	d8 f7       	brcc	.-10     	; 0xe872 <memcpy_P+0x6>
    e87c:	08 95       	ret

0000e87e <strncmp_P>:
    e87e:	fb 01       	movw	r30, r22
    e880:	dc 01       	movw	r26, r24
    e882:	41 50       	subi	r20, 0x01	; 1
    e884:	50 40       	sbci	r21, 0x00	; 0
    e886:	30 f0       	brcs	.+12     	; 0xe894 <strncmp_P+0x16>
    e888:	8d 91       	ld	r24, X+
    e88a:	05 90       	lpm	r0, Z+
    e88c:	80 19       	sub	r24, r0
    e88e:	19 f4       	brne	.+6      	; 0xe896 <strncmp_P+0x18>
    e890:	00 20       	and	r0, r0
    e892:	b9 f7       	brne	.-18     	; 0xe882 <strncmp_P+0x4>
    e894:	88 1b       	sub	r24, r24
    e896:	99 0b       	sbc	r25, r25
    e898:	08 95       	ret

0000e89a <memcmp>:
    e89a:	fb 01       	movw	r30, r22
    e89c:	dc 01       	movw	r26, r24
    e89e:	04 c0       	rjmp	.+8      	; 0xe8a8 <memcmp+0xe>
    e8a0:	8d 91       	ld	r24, X+
    e8a2:	01 90       	ld	r0, Z+
    e8a4:	80 19       	sub	r24, r0
    e8a6:	21 f4       	brne	.+8      	; 0xe8b0 <memcmp+0x16>
    e8a8:	41 50       	subi	r20, 0x01	; 1
    e8aa:	50 40       	sbci	r21, 0x00	; 0
    e8ac:	c8 f7       	brcc	.-14     	; 0xe8a0 <memcmp+0x6>
    e8ae:	88 1b       	sub	r24, r24
    e8b0:	99 0b       	sbc	r25, r25
    e8b2:	08 95       	ret

0000e8b4 <memcpy>:
    e8b4:	fb 01       	movw	r30, r22
    e8b6:	dc 01       	movw	r26, r24
    e8b8:	02 c0       	rjmp	.+4      	; 0xe8be <memcpy+0xa>
    e8ba:	01 90       	ld	r0, Z+
    e8bc:	0d 92       	st	X+, r0
    e8be:	41 50       	subi	r20, 0x01	; 1
    e8c0:	50 40       	sbci	r21, 0x00	; 0
    e8c2:	d8 f7       	brcc	.-10     	; 0xe8ba <memcpy+0x6>
    e8c4:	08 95       	ret

0000e8c6 <memset>:
    e8c6:	dc 01       	movw	r26, r24
    e8c8:	01 c0       	rjmp	.+2      	; 0xe8cc <memset+0x6>
    e8ca:	6d 93       	st	X+, r22
    e8cc:	41 50       	subi	r20, 0x01	; 1
    e8ce:	50 40       	sbci	r21, 0x00	; 0
    e8d0:	e0 f7       	brcc	.-8      	; 0xe8ca <memset+0x4>
    e8d2:	08 95       	ret

0000e8d4 <strcat>:
    e8d4:	fb 01       	movw	r30, r22
    e8d6:	dc 01       	movw	r26, r24
    e8d8:	0d 90       	ld	r0, X+
    e8da:	00 20       	and	r0, r0
    e8dc:	e9 f7       	brne	.-6      	; 0xe8d8 <strcat+0x4>
    e8de:	11 97       	sbiw	r26, 0x01	; 1
    e8e0:	01 90       	ld	r0, Z+
    e8e2:	0d 92       	st	X+, r0
    e8e4:	00 20       	and	r0, r0
    e8e6:	e1 f7       	brne	.-8      	; 0xe8e0 <strcat+0xc>
    e8e8:	08 95       	ret

0000e8ea <strcpy>:
    e8ea:	fb 01       	movw	r30, r22
    e8ec:	dc 01       	movw	r26, r24
    e8ee:	01 90       	ld	r0, Z+
    e8f0:	0d 92       	st	X+, r0
    e8f2:	00 20       	and	r0, r0
    e8f4:	e1 f7       	brne	.-8      	; 0xe8ee <strcpy+0x4>
    e8f6:	08 95       	ret

0000e8f8 <strncmp>:
    e8f8:	fb 01       	movw	r30, r22
    e8fa:	dc 01       	movw	r26, r24
    e8fc:	41 50       	subi	r20, 0x01	; 1
    e8fe:	50 40       	sbci	r21, 0x00	; 0
    e900:	30 f0       	brcs	.+12     	; 0xe90e <strncmp+0x16>
    e902:	8d 91       	ld	r24, X+
    e904:	01 90       	ld	r0, Z+
    e906:	80 19       	sub	r24, r0
    e908:	19 f4       	brne	.+6      	; 0xe910 <strncmp+0x18>
    e90a:	00 20       	and	r0, r0
    e90c:	b9 f7       	brne	.-18     	; 0xe8fc <strncmp+0x4>
    e90e:	88 1b       	sub	r24, r24
    e910:	99 0b       	sbc	r25, r25
    e912:	08 95       	ret

0000e914 <strncpy>:
    e914:	fb 01       	movw	r30, r22
    e916:	dc 01       	movw	r26, r24
    e918:	41 50       	subi	r20, 0x01	; 1
    e91a:	50 40       	sbci	r21, 0x00	; 0
    e91c:	48 f0       	brcs	.+18     	; 0xe930 <strncpy+0x1c>
    e91e:	01 90       	ld	r0, Z+
    e920:	0d 92       	st	X+, r0
    e922:	00 20       	and	r0, r0
    e924:	c9 f7       	brne	.-14     	; 0xe918 <strncpy+0x4>
    e926:	01 c0       	rjmp	.+2      	; 0xe92a <strncpy+0x16>
    e928:	1d 92       	st	X+, r1
    e92a:	41 50       	subi	r20, 0x01	; 1
    e92c:	50 40       	sbci	r21, 0x00	; 0
    e92e:	e0 f7       	brcc	.-8      	; 0xe928 <strncpy+0x14>
    e930:	08 95       	ret

0000e932 <fclose>:
    e932:	fc 01       	movw	r30, r24
    e934:	83 81       	ldd	r24, Z+3	; 0x03
    e936:	87 ff       	sbrs	r24, 7
    e938:	24 c0       	rjmp	.+72     	; 0xe982 <fclose+0x50>
    e93a:	80 91 f9 0f 	lds	r24, 0x0FF9
    e93e:	90 91 fa 0f 	lds	r25, 0x0FFA
    e942:	8e 17       	cp	r24, r30
    e944:	9f 07       	cpc	r25, r31
    e946:	21 f4       	brne	.+8      	; 0xe950 <fclose+0x1e>
    e948:	10 92 fa 0f 	sts	0x0FFA, r1
    e94c:	10 92 f9 0f 	sts	0x0FF9, r1
    e950:	80 91 fb 0f 	lds	r24, 0x0FFB
    e954:	90 91 fc 0f 	lds	r25, 0x0FFC
    e958:	8e 17       	cp	r24, r30
    e95a:	9f 07       	cpc	r25, r31
    e95c:	21 f4       	brne	.+8      	; 0xe966 <fclose+0x34>
    e95e:	10 92 fc 0f 	sts	0x0FFC, r1
    e962:	10 92 fb 0f 	sts	0x0FFB, r1
    e966:	80 91 fd 0f 	lds	r24, 0x0FFD
    e96a:	90 91 fe 0f 	lds	r25, 0x0FFE
    e96e:	8e 17       	cp	r24, r30
    e970:	9f 07       	cpc	r25, r31
    e972:	21 f4       	brne	.+8      	; 0xe97c <fclose+0x4a>
    e974:	10 92 fe 0f 	sts	0x0FFE, r1
    e978:	10 92 fd 0f 	sts	0x0FFD, r1
    e97c:	cf 01       	movw	r24, r30
    e97e:	0e 94 a7 72 	call	0xe54e	; 0xe54e <free>
    e982:	80 e0       	ldi	r24, 0x00	; 0
    e984:	90 e0       	ldi	r25, 0x00	; 0
    e986:	08 95       	ret

0000e988 <fgetc>:
    e988:	cf 93       	push	r28
    e98a:	df 93       	push	r29
    e98c:	ec 01       	movw	r28, r24
    e98e:	4b 81       	ldd	r20, Y+3	; 0x03
    e990:	40 ff       	sbrs	r20, 0
    e992:	1a c0       	rjmp	.+52     	; 0xe9c8 <fgetc+0x40>
    e994:	46 ff       	sbrs	r20, 6
    e996:	0a c0       	rjmp	.+20     	; 0xe9ac <fgetc+0x24>
    e998:	4f 7b       	andi	r20, 0xBF	; 191
    e99a:	4b 83       	std	Y+3, r20	; 0x03
    e99c:	8e 81       	ldd	r24, Y+6	; 0x06
    e99e:	9f 81       	ldd	r25, Y+7	; 0x07
    e9a0:	01 96       	adiw	r24, 0x01	; 1
    e9a2:	9f 83       	std	Y+7, r25	; 0x07
    e9a4:	8e 83       	std	Y+6, r24	; 0x06
    e9a6:	8a 81       	ldd	r24, Y+2	; 0x02
    e9a8:	28 2f       	mov	r18, r24
    e9aa:	2b c0       	rjmp	.+86     	; 0xea02 <fgetc+0x7a>
    e9ac:	42 ff       	sbrs	r20, 2
    e9ae:	13 c0       	rjmp	.+38     	; 0xe9d6 <fgetc+0x4e>
    e9b0:	e8 81       	ld	r30, Y
    e9b2:	f9 81       	ldd	r31, Y+1	; 0x01
    e9b4:	80 81       	ld	r24, Z
    e9b6:	28 2f       	mov	r18, r24
    e9b8:	33 27       	eor	r19, r19
    e9ba:	27 fd       	sbrc	r18, 7
    e9bc:	30 95       	com	r19
    e9be:	21 15       	cp	r18, r1
    e9c0:	31 05       	cpc	r19, r1
    e9c2:	29 f4       	brne	.+10     	; 0xe9ce <fgetc+0x46>
    e9c4:	40 62       	ori	r20, 0x20	; 32
    e9c6:	4b 83       	std	Y+3, r20	; 0x03
    e9c8:	2f ef       	ldi	r18, 0xFF	; 255
    e9ca:	3f ef       	ldi	r19, 0xFF	; 255
    e9cc:	1b c0       	rjmp	.+54     	; 0xea04 <fgetc+0x7c>
    e9ce:	31 96       	adiw	r30, 0x01	; 1
    e9d0:	f9 83       	std	Y+1, r31	; 0x01
    e9d2:	e8 83       	st	Y, r30
    e9d4:	11 c0       	rjmp	.+34     	; 0xe9f8 <fgetc+0x70>
    e9d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    e9d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    e9da:	ce 01       	movw	r24, r28
    e9dc:	09 95       	icall
    e9de:	9c 01       	movw	r18, r24
    e9e0:	97 ff       	sbrs	r25, 7
    e9e2:	0a c0       	rjmp	.+20     	; 0xe9f8 <fgetc+0x70>
    e9e4:	9b 81       	ldd	r25, Y+3	; 0x03
    e9e6:	2f 5f       	subi	r18, 0xFF	; 255
    e9e8:	3f 4f       	sbci	r19, 0xFF	; 255
    e9ea:	11 f0       	breq	.+4      	; 0xe9f0 <fgetc+0x68>
    e9ec:	80 e2       	ldi	r24, 0x20	; 32
    e9ee:	01 c0       	rjmp	.+2      	; 0xe9f2 <fgetc+0x6a>
    e9f0:	80 e1       	ldi	r24, 0x10	; 16
    e9f2:	89 2b       	or	r24, r25
    e9f4:	8b 83       	std	Y+3, r24	; 0x03
    e9f6:	e8 cf       	rjmp	.-48     	; 0xe9c8 <fgetc+0x40>
    e9f8:	8e 81       	ldd	r24, Y+6	; 0x06
    e9fa:	9f 81       	ldd	r25, Y+7	; 0x07
    e9fc:	01 96       	adiw	r24, 0x01	; 1
    e9fe:	9f 83       	std	Y+7, r25	; 0x07
    ea00:	8e 83       	std	Y+6, r24	; 0x06
    ea02:	30 e0       	ldi	r19, 0x00	; 0
    ea04:	c9 01       	movw	r24, r18
    ea06:	df 91       	pop	r29
    ea08:	cf 91       	pop	r28
    ea0a:	08 95       	ret

0000ea0c <fprintf>:
    ea0c:	df 93       	push	r29
    ea0e:	cf 93       	push	r28
    ea10:	cd b7       	in	r28, 0x3d	; 61
    ea12:	de b7       	in	r29, 0x3e	; 62
    ea14:	9e 01       	movw	r18, r28
    ea16:	27 5f       	subi	r18, 0xF7	; 247
    ea18:	3f 4f       	sbci	r19, 0xFF	; 255
    ea1a:	8d 81       	ldd	r24, Y+5	; 0x05
    ea1c:	9e 81       	ldd	r25, Y+6	; 0x06
    ea1e:	6f 81       	ldd	r22, Y+7	; 0x07
    ea20:	78 85       	ldd	r23, Y+8	; 0x08
    ea22:	a9 01       	movw	r20, r18
    ea24:	0e 94 bd 75 	call	0xeb7a	; 0xeb7a <vfprintf>
    ea28:	cf 91       	pop	r28
    ea2a:	df 91       	pop	r29
    ea2c:	08 95       	ret

0000ea2e <fprintf_P>:
    ea2e:	0f 93       	push	r16
    ea30:	1f 93       	push	r17
    ea32:	df 93       	push	r29
    ea34:	cf 93       	push	r28
    ea36:	cd b7       	in	r28, 0x3d	; 61
    ea38:	de b7       	in	r29, 0x3e	; 62
    ea3a:	0f 81       	ldd	r16, Y+7	; 0x07
    ea3c:	18 85       	ldd	r17, Y+8	; 0x08
    ea3e:	9e 01       	movw	r18, r28
    ea40:	25 5f       	subi	r18, 0xF5	; 245
    ea42:	3f 4f       	sbci	r19, 0xFF	; 255
    ea44:	f8 01       	movw	r30, r16
    ea46:	83 81       	ldd	r24, Z+3	; 0x03
    ea48:	88 60       	ori	r24, 0x08	; 8
    ea4a:	83 83       	std	Z+3, r24	; 0x03
    ea4c:	c8 01       	movw	r24, r16
    ea4e:	69 85       	ldd	r22, Y+9	; 0x09
    ea50:	7a 85       	ldd	r23, Y+10	; 0x0a
    ea52:	a9 01       	movw	r20, r18
    ea54:	0e 94 bd 75 	call	0xeb7a	; 0xeb7a <vfprintf>
    ea58:	f8 01       	movw	r30, r16
    ea5a:	23 81       	ldd	r18, Z+3	; 0x03
    ea5c:	27 7f       	andi	r18, 0xF7	; 247
    ea5e:	23 83       	std	Z+3, r18	; 0x03
    ea60:	cf 91       	pop	r28
    ea62:	df 91       	pop	r29
    ea64:	1f 91       	pop	r17
    ea66:	0f 91       	pop	r16
    ea68:	08 95       	ret

0000ea6a <fputc>:
    ea6a:	0f 93       	push	r16
    ea6c:	1f 93       	push	r17
    ea6e:	cf 93       	push	r28
    ea70:	df 93       	push	r29
    ea72:	8c 01       	movw	r16, r24
    ea74:	eb 01       	movw	r28, r22
    ea76:	8b 81       	ldd	r24, Y+3	; 0x03
    ea78:	81 ff       	sbrs	r24, 1
    ea7a:	1b c0       	rjmp	.+54     	; 0xeab2 <fputc+0x48>
    ea7c:	82 ff       	sbrs	r24, 2
    ea7e:	0d c0       	rjmp	.+26     	; 0xea9a <fputc+0x30>
    ea80:	2e 81       	ldd	r18, Y+6	; 0x06
    ea82:	3f 81       	ldd	r19, Y+7	; 0x07
    ea84:	8c 81       	ldd	r24, Y+4	; 0x04
    ea86:	9d 81       	ldd	r25, Y+5	; 0x05
    ea88:	28 17       	cp	r18, r24
    ea8a:	39 07       	cpc	r19, r25
    ea8c:	64 f4       	brge	.+24     	; 0xeaa6 <fputc+0x3c>
    ea8e:	e8 81       	ld	r30, Y
    ea90:	f9 81       	ldd	r31, Y+1	; 0x01
    ea92:	01 93       	st	Z+, r16
    ea94:	f9 83       	std	Y+1, r31	; 0x01
    ea96:	e8 83       	st	Y, r30
    ea98:	06 c0       	rjmp	.+12     	; 0xeaa6 <fputc+0x3c>
    ea9a:	e8 85       	ldd	r30, Y+8	; 0x08
    ea9c:	f9 85       	ldd	r31, Y+9	; 0x09
    ea9e:	80 2f       	mov	r24, r16
    eaa0:	09 95       	icall
    eaa2:	89 2b       	or	r24, r25
    eaa4:	31 f4       	brne	.+12     	; 0xeab2 <fputc+0x48>
    eaa6:	8e 81       	ldd	r24, Y+6	; 0x06
    eaa8:	9f 81       	ldd	r25, Y+7	; 0x07
    eaaa:	01 96       	adiw	r24, 0x01	; 1
    eaac:	9f 83       	std	Y+7, r25	; 0x07
    eaae:	8e 83       	std	Y+6, r24	; 0x06
    eab0:	02 c0       	rjmp	.+4      	; 0xeab6 <fputc+0x4c>
    eab2:	0f ef       	ldi	r16, 0xFF	; 255
    eab4:	1f ef       	ldi	r17, 0xFF	; 255
    eab6:	c8 01       	movw	r24, r16
    eab8:	df 91       	pop	r29
    eaba:	cf 91       	pop	r28
    eabc:	1f 91       	pop	r17
    eabe:	0f 91       	pop	r16
    eac0:	08 95       	ret

0000eac2 <fputs>:
    eac2:	ef 92       	push	r14
    eac4:	ff 92       	push	r15
    eac6:	0f 93       	push	r16
    eac8:	1f 93       	push	r17
    eaca:	cf 93       	push	r28
    eacc:	df 93       	push	r29
    eace:	7c 01       	movw	r14, r24
    ead0:	8b 01       	movw	r16, r22
    ead2:	db 01       	movw	r26, r22
    ead4:	13 96       	adiw	r26, 0x03	; 3
    ead6:	8c 91       	ld	r24, X
    ead8:	81 fd       	sbrc	r24, 1
    eada:	03 c0       	rjmp	.+6      	; 0xeae2 <fputs+0x20>
    eadc:	cf ef       	ldi	r28, 0xFF	; 255
    eade:	df ef       	ldi	r29, 0xFF	; 255
    eae0:	13 c0       	rjmp	.+38     	; 0xeb08 <fputs+0x46>
    eae2:	c0 e0       	ldi	r28, 0x00	; 0
    eae4:	d0 e0       	ldi	r29, 0x00	; 0
    eae6:	0b c0       	rjmp	.+22     	; 0xeafe <fputs+0x3c>
    eae8:	d8 01       	movw	r26, r16
    eaea:	18 96       	adiw	r26, 0x08	; 8
    eaec:	ed 91       	ld	r30, X+
    eaee:	fc 91       	ld	r31, X
    eaf0:	19 97       	sbiw	r26, 0x09	; 9
    eaf2:	b8 01       	movw	r22, r16
    eaf4:	09 95       	icall
    eaf6:	89 2b       	or	r24, r25
    eaf8:	11 f0       	breq	.+4      	; 0xeafe <fputs+0x3c>
    eafa:	cf ef       	ldi	r28, 0xFF	; 255
    eafc:	df ef       	ldi	r29, 0xFF	; 255
    eafe:	f7 01       	movw	r30, r14
    eb00:	81 91       	ld	r24, Z+
    eb02:	7f 01       	movw	r14, r30
    eb04:	88 23       	and	r24, r24
    eb06:	81 f7       	brne	.-32     	; 0xeae8 <fputs+0x26>
    eb08:	ce 01       	movw	r24, r28
    eb0a:	df 91       	pop	r29
    eb0c:	cf 91       	pop	r28
    eb0e:	1f 91       	pop	r17
    eb10:	0f 91       	pop	r16
    eb12:	ff 90       	pop	r15
    eb14:	ef 90       	pop	r14
    eb16:	08 95       	ret

0000eb18 <sprintf>:
    eb18:	0f 93       	push	r16
    eb1a:	1f 93       	push	r17
    eb1c:	df 93       	push	r29
    eb1e:	cf 93       	push	r28
    eb20:	cd b7       	in	r28, 0x3d	; 61
    eb22:	de b7       	in	r29, 0x3e	; 62
    eb24:	2e 97       	sbiw	r28, 0x0e	; 14
    eb26:	0f b6       	in	r0, 0x3f	; 63
    eb28:	f8 94       	cli
    eb2a:	de bf       	out	0x3e, r29	; 62
    eb2c:	0f be       	out	0x3f, r0	; 63
    eb2e:	cd bf       	out	0x3d, r28	; 61
    eb30:	0d 89       	ldd	r16, Y+21	; 0x15
    eb32:	1e 89       	ldd	r17, Y+22	; 0x16
    eb34:	86 e0       	ldi	r24, 0x06	; 6
    eb36:	8c 83       	std	Y+4, r24	; 0x04
    eb38:	1a 83       	std	Y+2, r17	; 0x02
    eb3a:	09 83       	std	Y+1, r16	; 0x01
    eb3c:	8f ef       	ldi	r24, 0xFF	; 255
    eb3e:	9f e7       	ldi	r25, 0x7F	; 127
    eb40:	9e 83       	std	Y+6, r25	; 0x06
    eb42:	8d 83       	std	Y+5, r24	; 0x05
    eb44:	9e 01       	movw	r18, r28
    eb46:	27 5e       	subi	r18, 0xE7	; 231
    eb48:	3f 4f       	sbci	r19, 0xFF	; 255
    eb4a:	ce 01       	movw	r24, r28
    eb4c:	01 96       	adiw	r24, 0x01	; 1
    eb4e:	6f 89       	ldd	r22, Y+23	; 0x17
    eb50:	78 8d       	ldd	r23, Y+24	; 0x18
    eb52:	a9 01       	movw	r20, r18
    eb54:	0e 94 bd 75 	call	0xeb7a	; 0xeb7a <vfprintf>
    eb58:	2f 81       	ldd	r18, Y+7	; 0x07
    eb5a:	38 85       	ldd	r19, Y+8	; 0x08
    eb5c:	02 0f       	add	r16, r18
    eb5e:	13 1f       	adc	r17, r19
    eb60:	f8 01       	movw	r30, r16
    eb62:	10 82       	st	Z, r1
    eb64:	2e 96       	adiw	r28, 0x0e	; 14
    eb66:	0f b6       	in	r0, 0x3f	; 63
    eb68:	f8 94       	cli
    eb6a:	de bf       	out	0x3e, r29	; 62
    eb6c:	0f be       	out	0x3f, r0	; 63
    eb6e:	cd bf       	out	0x3d, r28	; 61
    eb70:	cf 91       	pop	r28
    eb72:	df 91       	pop	r29
    eb74:	1f 91       	pop	r17
    eb76:	0f 91       	pop	r16
    eb78:	08 95       	ret

0000eb7a <vfprintf>:
    eb7a:	2f 92       	push	r2
    eb7c:	3f 92       	push	r3
    eb7e:	4f 92       	push	r4
    eb80:	5f 92       	push	r5
    eb82:	6f 92       	push	r6
    eb84:	7f 92       	push	r7
    eb86:	8f 92       	push	r8
    eb88:	9f 92       	push	r9
    eb8a:	af 92       	push	r10
    eb8c:	bf 92       	push	r11
    eb8e:	cf 92       	push	r12
    eb90:	df 92       	push	r13
    eb92:	ef 92       	push	r14
    eb94:	ff 92       	push	r15
    eb96:	0f 93       	push	r16
    eb98:	1f 93       	push	r17
    eb9a:	df 93       	push	r29
    eb9c:	cf 93       	push	r28
    eb9e:	cd b7       	in	r28, 0x3d	; 61
    eba0:	de b7       	in	r29, 0x3e	; 62
    eba2:	2b 97       	sbiw	r28, 0x0b	; 11
    eba4:	0f b6       	in	r0, 0x3f	; 63
    eba6:	f8 94       	cli
    eba8:	de bf       	out	0x3e, r29	; 62
    ebaa:	0f be       	out	0x3f, r0	; 63
    ebac:	cd bf       	out	0x3d, r28	; 61
    ebae:	3c 01       	movw	r6, r24
    ebb0:	2b 01       	movw	r4, r22
    ebb2:	5a 01       	movw	r10, r20
    ebb4:	fc 01       	movw	r30, r24
    ebb6:	17 82       	std	Z+7, r1	; 0x07
    ebb8:	16 82       	std	Z+6, r1	; 0x06
    ebba:	83 81       	ldd	r24, Z+3	; 0x03
    ebbc:	81 fd       	sbrc	r24, 1
    ebbe:	03 c0       	rjmp	.+6      	; 0xebc6 <vfprintf+0x4c>
    ebc0:	6f ef       	ldi	r22, 0xFF	; 255
    ebc2:	7f ef       	ldi	r23, 0xFF	; 255
    ebc4:	c6 c1       	rjmp	.+908    	; 0xef52 <vfprintf+0x3d8>
    ebc6:	9a e0       	ldi	r25, 0x0A	; 10
    ebc8:	89 2e       	mov	r8, r25
    ebca:	1e 01       	movw	r2, r28
    ebcc:	08 94       	sec
    ebce:	21 1c       	adc	r2, r1
    ebd0:	31 1c       	adc	r3, r1
    ebd2:	f3 01       	movw	r30, r6
    ebd4:	23 81       	ldd	r18, Z+3	; 0x03
    ebd6:	f2 01       	movw	r30, r4
    ebd8:	23 fd       	sbrc	r18, 3
    ebda:	85 91       	lpm	r24, Z+
    ebdc:	23 ff       	sbrs	r18, 3
    ebde:	81 91       	ld	r24, Z+
    ebe0:	2f 01       	movw	r4, r30
    ebe2:	88 23       	and	r24, r24
    ebe4:	09 f4       	brne	.+2      	; 0xebe8 <vfprintf+0x6e>
    ebe6:	b2 c1       	rjmp	.+868    	; 0xef4c <vfprintf+0x3d2>
    ebe8:	85 32       	cpi	r24, 0x25	; 37
    ebea:	39 f4       	brne	.+14     	; 0xebfa <vfprintf+0x80>
    ebec:	23 fd       	sbrc	r18, 3
    ebee:	85 91       	lpm	r24, Z+
    ebf0:	23 ff       	sbrs	r18, 3
    ebf2:	81 91       	ld	r24, Z+
    ebf4:	2f 01       	movw	r4, r30
    ebf6:	85 32       	cpi	r24, 0x25	; 37
    ebf8:	29 f4       	brne	.+10     	; 0xec04 <vfprintf+0x8a>
    ebfa:	90 e0       	ldi	r25, 0x00	; 0
    ebfc:	b3 01       	movw	r22, r6
    ebfe:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    ec02:	e7 cf       	rjmp	.-50     	; 0xebd2 <vfprintf+0x58>
    ec04:	98 2f       	mov	r25, r24
    ec06:	ff 24       	eor	r15, r15
    ec08:	ee 24       	eor	r14, r14
    ec0a:	99 24       	eor	r9, r9
    ec0c:	ff e1       	ldi	r31, 0x1F	; 31
    ec0e:	ff 15       	cp	r31, r15
    ec10:	d0 f0       	brcs	.+52     	; 0xec46 <vfprintf+0xcc>
    ec12:	9b 32       	cpi	r25, 0x2B	; 43
    ec14:	69 f0       	breq	.+26     	; 0xec30 <vfprintf+0xb6>
    ec16:	9c 32       	cpi	r25, 0x2C	; 44
    ec18:	28 f4       	brcc	.+10     	; 0xec24 <vfprintf+0xaa>
    ec1a:	90 32       	cpi	r25, 0x20	; 32
    ec1c:	59 f0       	breq	.+22     	; 0xec34 <vfprintf+0xba>
    ec1e:	93 32       	cpi	r25, 0x23	; 35
    ec20:	91 f4       	brne	.+36     	; 0xec46 <vfprintf+0xcc>
    ec22:	0e c0       	rjmp	.+28     	; 0xec40 <vfprintf+0xc6>
    ec24:	9d 32       	cpi	r25, 0x2D	; 45
    ec26:	49 f0       	breq	.+18     	; 0xec3a <vfprintf+0xc0>
    ec28:	90 33       	cpi	r25, 0x30	; 48
    ec2a:	69 f4       	brne	.+26     	; 0xec46 <vfprintf+0xcc>
    ec2c:	41 e0       	ldi	r20, 0x01	; 1
    ec2e:	24 c0       	rjmp	.+72     	; 0xec78 <vfprintf+0xfe>
    ec30:	52 e0       	ldi	r21, 0x02	; 2
    ec32:	f5 2a       	or	r15, r21
    ec34:	84 e0       	ldi	r24, 0x04	; 4
    ec36:	f8 2a       	or	r15, r24
    ec38:	28 c0       	rjmp	.+80     	; 0xec8a <vfprintf+0x110>
    ec3a:	98 e0       	ldi	r25, 0x08	; 8
    ec3c:	f9 2a       	or	r15, r25
    ec3e:	25 c0       	rjmp	.+74     	; 0xec8a <vfprintf+0x110>
    ec40:	e0 e1       	ldi	r30, 0x10	; 16
    ec42:	fe 2a       	or	r15, r30
    ec44:	22 c0       	rjmp	.+68     	; 0xec8a <vfprintf+0x110>
    ec46:	f7 fc       	sbrc	r15, 7
    ec48:	29 c0       	rjmp	.+82     	; 0xec9c <vfprintf+0x122>
    ec4a:	89 2f       	mov	r24, r25
    ec4c:	80 53       	subi	r24, 0x30	; 48
    ec4e:	8a 30       	cpi	r24, 0x0A	; 10
    ec50:	70 f4       	brcc	.+28     	; 0xec6e <vfprintf+0xf4>
    ec52:	f6 fe       	sbrs	r15, 6
    ec54:	05 c0       	rjmp	.+10     	; 0xec60 <vfprintf+0xe6>
    ec56:	98 9c       	mul	r9, r8
    ec58:	90 2c       	mov	r9, r0
    ec5a:	11 24       	eor	r1, r1
    ec5c:	98 0e       	add	r9, r24
    ec5e:	15 c0       	rjmp	.+42     	; 0xec8a <vfprintf+0x110>
    ec60:	e8 9c       	mul	r14, r8
    ec62:	e0 2c       	mov	r14, r0
    ec64:	11 24       	eor	r1, r1
    ec66:	e8 0e       	add	r14, r24
    ec68:	f0 e2       	ldi	r31, 0x20	; 32
    ec6a:	ff 2a       	or	r15, r31
    ec6c:	0e c0       	rjmp	.+28     	; 0xec8a <vfprintf+0x110>
    ec6e:	9e 32       	cpi	r25, 0x2E	; 46
    ec70:	29 f4       	brne	.+10     	; 0xec7c <vfprintf+0x102>
    ec72:	f6 fc       	sbrc	r15, 6
    ec74:	6b c1       	rjmp	.+726    	; 0xef4c <vfprintf+0x3d2>
    ec76:	40 e4       	ldi	r20, 0x40	; 64
    ec78:	f4 2a       	or	r15, r20
    ec7a:	07 c0       	rjmp	.+14     	; 0xec8a <vfprintf+0x110>
    ec7c:	9c 36       	cpi	r25, 0x6C	; 108
    ec7e:	19 f4       	brne	.+6      	; 0xec86 <vfprintf+0x10c>
    ec80:	50 e8       	ldi	r21, 0x80	; 128
    ec82:	f5 2a       	or	r15, r21
    ec84:	02 c0       	rjmp	.+4      	; 0xec8a <vfprintf+0x110>
    ec86:	98 36       	cpi	r25, 0x68	; 104
    ec88:	49 f4       	brne	.+18     	; 0xec9c <vfprintf+0x122>
    ec8a:	f2 01       	movw	r30, r4
    ec8c:	23 fd       	sbrc	r18, 3
    ec8e:	95 91       	lpm	r25, Z+
    ec90:	23 ff       	sbrs	r18, 3
    ec92:	91 91       	ld	r25, Z+
    ec94:	2f 01       	movw	r4, r30
    ec96:	99 23       	and	r25, r25
    ec98:	09 f0       	breq	.+2      	; 0xec9c <vfprintf+0x122>
    ec9a:	b8 cf       	rjmp	.-144    	; 0xec0c <vfprintf+0x92>
    ec9c:	89 2f       	mov	r24, r25
    ec9e:	85 54       	subi	r24, 0x45	; 69
    eca0:	83 30       	cpi	r24, 0x03	; 3
    eca2:	18 f0       	brcs	.+6      	; 0xecaa <vfprintf+0x130>
    eca4:	80 52       	subi	r24, 0x20	; 32
    eca6:	83 30       	cpi	r24, 0x03	; 3
    eca8:	38 f4       	brcc	.+14     	; 0xecb8 <vfprintf+0x13e>
    ecaa:	44 e0       	ldi	r20, 0x04	; 4
    ecac:	50 e0       	ldi	r21, 0x00	; 0
    ecae:	a4 0e       	add	r10, r20
    ecb0:	b5 1e       	adc	r11, r21
    ecb2:	5f e3       	ldi	r21, 0x3F	; 63
    ecb4:	59 83       	std	Y+1, r21	; 0x01
    ecb6:	0f c0       	rjmp	.+30     	; 0xecd6 <vfprintf+0x15c>
    ecb8:	93 36       	cpi	r25, 0x63	; 99
    ecba:	31 f0       	breq	.+12     	; 0xecc8 <vfprintf+0x14e>
    ecbc:	93 37       	cpi	r25, 0x73	; 115
    ecbe:	79 f0       	breq	.+30     	; 0xecde <vfprintf+0x164>
    ecc0:	93 35       	cpi	r25, 0x53	; 83
    ecc2:	09 f0       	breq	.+2      	; 0xecc6 <vfprintf+0x14c>
    ecc4:	56 c0       	rjmp	.+172    	; 0xed72 <vfprintf+0x1f8>
    ecc6:	20 c0       	rjmp	.+64     	; 0xed08 <vfprintf+0x18e>
    ecc8:	f5 01       	movw	r30, r10
    ecca:	80 81       	ld	r24, Z
    eccc:	89 83       	std	Y+1, r24	; 0x01
    ecce:	42 e0       	ldi	r20, 0x02	; 2
    ecd0:	50 e0       	ldi	r21, 0x00	; 0
    ecd2:	a4 0e       	add	r10, r20
    ecd4:	b5 1e       	adc	r11, r21
    ecd6:	61 01       	movw	r12, r2
    ecd8:	01 e0       	ldi	r16, 0x01	; 1
    ecda:	10 e0       	ldi	r17, 0x00	; 0
    ecdc:	12 c0       	rjmp	.+36     	; 0xed02 <vfprintf+0x188>
    ecde:	f5 01       	movw	r30, r10
    ece0:	c0 80       	ld	r12, Z
    ece2:	d1 80       	ldd	r13, Z+1	; 0x01
    ece4:	f6 fc       	sbrc	r15, 6
    ece6:	03 c0       	rjmp	.+6      	; 0xecee <vfprintf+0x174>
    ece8:	6f ef       	ldi	r22, 0xFF	; 255
    ecea:	7f ef       	ldi	r23, 0xFF	; 255
    ecec:	02 c0       	rjmp	.+4      	; 0xecf2 <vfprintf+0x178>
    ecee:	69 2d       	mov	r22, r9
    ecf0:	70 e0       	ldi	r23, 0x00	; 0
    ecf2:	42 e0       	ldi	r20, 0x02	; 2
    ecf4:	50 e0       	ldi	r21, 0x00	; 0
    ecf6:	a4 0e       	add	r10, r20
    ecf8:	b5 1e       	adc	r11, r21
    ecfa:	c6 01       	movw	r24, r12
    ecfc:	0e 94 20 78 	call	0xf040	; 0xf040 <strnlen>
    ed00:	8c 01       	movw	r16, r24
    ed02:	5f e7       	ldi	r21, 0x7F	; 127
    ed04:	f5 22       	and	r15, r21
    ed06:	14 c0       	rjmp	.+40     	; 0xed30 <vfprintf+0x1b6>
    ed08:	f5 01       	movw	r30, r10
    ed0a:	c0 80       	ld	r12, Z
    ed0c:	d1 80       	ldd	r13, Z+1	; 0x01
    ed0e:	f6 fc       	sbrc	r15, 6
    ed10:	03 c0       	rjmp	.+6      	; 0xed18 <vfprintf+0x19e>
    ed12:	6f ef       	ldi	r22, 0xFF	; 255
    ed14:	7f ef       	ldi	r23, 0xFF	; 255
    ed16:	02 c0       	rjmp	.+4      	; 0xed1c <vfprintf+0x1a2>
    ed18:	69 2d       	mov	r22, r9
    ed1a:	70 e0       	ldi	r23, 0x00	; 0
    ed1c:	42 e0       	ldi	r20, 0x02	; 2
    ed1e:	50 e0       	ldi	r21, 0x00	; 0
    ed20:	a4 0e       	add	r10, r20
    ed22:	b5 1e       	adc	r11, r21
    ed24:	c6 01       	movw	r24, r12
    ed26:	0e 94 15 78 	call	0xf02a	; 0xf02a <strnlen_P>
    ed2a:	8c 01       	movw	r16, r24
    ed2c:	50 e8       	ldi	r21, 0x80	; 128
    ed2e:	f5 2a       	or	r15, r21
    ed30:	f3 fe       	sbrs	r15, 3
    ed32:	07 c0       	rjmp	.+14     	; 0xed42 <vfprintf+0x1c8>
    ed34:	1a c0       	rjmp	.+52     	; 0xed6a <vfprintf+0x1f0>
    ed36:	80 e2       	ldi	r24, 0x20	; 32
    ed38:	90 e0       	ldi	r25, 0x00	; 0
    ed3a:	b3 01       	movw	r22, r6
    ed3c:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    ed40:	ea 94       	dec	r14
    ed42:	8e 2d       	mov	r24, r14
    ed44:	90 e0       	ldi	r25, 0x00	; 0
    ed46:	08 17       	cp	r16, r24
    ed48:	19 07       	cpc	r17, r25
    ed4a:	a8 f3       	brcs	.-22     	; 0xed36 <vfprintf+0x1bc>
    ed4c:	0e c0       	rjmp	.+28     	; 0xed6a <vfprintf+0x1f0>
    ed4e:	f6 01       	movw	r30, r12
    ed50:	f7 fc       	sbrc	r15, 7
    ed52:	85 91       	lpm	r24, Z+
    ed54:	f7 fe       	sbrs	r15, 7
    ed56:	81 91       	ld	r24, Z+
    ed58:	6f 01       	movw	r12, r30
    ed5a:	90 e0       	ldi	r25, 0x00	; 0
    ed5c:	b3 01       	movw	r22, r6
    ed5e:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    ed62:	e1 10       	cpse	r14, r1
    ed64:	ea 94       	dec	r14
    ed66:	01 50       	subi	r16, 0x01	; 1
    ed68:	10 40       	sbci	r17, 0x00	; 0
    ed6a:	01 15       	cp	r16, r1
    ed6c:	11 05       	cpc	r17, r1
    ed6e:	79 f7       	brne	.-34     	; 0xed4e <vfprintf+0x1d4>
    ed70:	ea c0       	rjmp	.+468    	; 0xef46 <vfprintf+0x3cc>
    ed72:	94 36       	cpi	r25, 0x64	; 100
    ed74:	11 f0       	breq	.+4      	; 0xed7a <vfprintf+0x200>
    ed76:	99 36       	cpi	r25, 0x69	; 105
    ed78:	69 f5       	brne	.+90     	; 0xedd4 <vfprintf+0x25a>
    ed7a:	f7 fe       	sbrs	r15, 7
    ed7c:	08 c0       	rjmp	.+16     	; 0xed8e <vfprintf+0x214>
    ed7e:	f5 01       	movw	r30, r10
    ed80:	20 81       	ld	r18, Z
    ed82:	31 81       	ldd	r19, Z+1	; 0x01
    ed84:	42 81       	ldd	r20, Z+2	; 0x02
    ed86:	53 81       	ldd	r21, Z+3	; 0x03
    ed88:	84 e0       	ldi	r24, 0x04	; 4
    ed8a:	90 e0       	ldi	r25, 0x00	; 0
    ed8c:	0a c0       	rjmp	.+20     	; 0xeda2 <vfprintf+0x228>
    ed8e:	f5 01       	movw	r30, r10
    ed90:	80 81       	ld	r24, Z
    ed92:	91 81       	ldd	r25, Z+1	; 0x01
    ed94:	9c 01       	movw	r18, r24
    ed96:	44 27       	eor	r20, r20
    ed98:	37 fd       	sbrc	r19, 7
    ed9a:	40 95       	com	r20
    ed9c:	54 2f       	mov	r21, r20
    ed9e:	82 e0       	ldi	r24, 0x02	; 2
    eda0:	90 e0       	ldi	r25, 0x00	; 0
    eda2:	a8 0e       	add	r10, r24
    eda4:	b9 1e       	adc	r11, r25
    eda6:	9f e6       	ldi	r25, 0x6F	; 111
    eda8:	f9 22       	and	r15, r25
    edaa:	57 ff       	sbrs	r21, 7
    edac:	09 c0       	rjmp	.+18     	; 0xedc0 <vfprintf+0x246>
    edae:	50 95       	com	r21
    edb0:	40 95       	com	r20
    edb2:	30 95       	com	r19
    edb4:	21 95       	neg	r18
    edb6:	3f 4f       	sbci	r19, 0xFF	; 255
    edb8:	4f 4f       	sbci	r20, 0xFF	; 255
    edba:	5f 4f       	sbci	r21, 0xFF	; 255
    edbc:	e0 e8       	ldi	r30, 0x80	; 128
    edbe:	fe 2a       	or	r15, r30
    edc0:	ca 01       	movw	r24, r20
    edc2:	b9 01       	movw	r22, r18
    edc4:	a1 01       	movw	r20, r2
    edc6:	2a e0       	ldi	r18, 0x0A	; 10
    edc8:	30 e0       	ldi	r19, 0x00	; 0
    edca:	0e 94 2b 78 	call	0xf056	; 0xf056 <__ultoa_invert>
    edce:	d8 2e       	mov	r13, r24
    edd0:	d2 18       	sub	r13, r2
    edd2:	40 c0       	rjmp	.+128    	; 0xee54 <vfprintf+0x2da>
    edd4:	95 37       	cpi	r25, 0x75	; 117
    edd6:	29 f4       	brne	.+10     	; 0xede2 <vfprintf+0x268>
    edd8:	1f 2d       	mov	r17, r15
    edda:	1f 7e       	andi	r17, 0xEF	; 239
    eddc:	2a e0       	ldi	r18, 0x0A	; 10
    edde:	30 e0       	ldi	r19, 0x00	; 0
    ede0:	1d c0       	rjmp	.+58     	; 0xee1c <vfprintf+0x2a2>
    ede2:	1f 2d       	mov	r17, r15
    ede4:	19 7f       	andi	r17, 0xF9	; 249
    ede6:	9f 36       	cpi	r25, 0x6F	; 111
    ede8:	61 f0       	breq	.+24     	; 0xee02 <vfprintf+0x288>
    edea:	90 37       	cpi	r25, 0x70	; 112
    edec:	20 f4       	brcc	.+8      	; 0xedf6 <vfprintf+0x27c>
    edee:	98 35       	cpi	r25, 0x58	; 88
    edf0:	09 f0       	breq	.+2      	; 0xedf4 <vfprintf+0x27a>
    edf2:	ac c0       	rjmp	.+344    	; 0xef4c <vfprintf+0x3d2>
    edf4:	0f c0       	rjmp	.+30     	; 0xee14 <vfprintf+0x29a>
    edf6:	90 37       	cpi	r25, 0x70	; 112
    edf8:	39 f0       	breq	.+14     	; 0xee08 <vfprintf+0x28e>
    edfa:	98 37       	cpi	r25, 0x78	; 120
    edfc:	09 f0       	breq	.+2      	; 0xee00 <vfprintf+0x286>
    edfe:	a6 c0       	rjmp	.+332    	; 0xef4c <vfprintf+0x3d2>
    ee00:	04 c0       	rjmp	.+8      	; 0xee0a <vfprintf+0x290>
    ee02:	28 e0       	ldi	r18, 0x08	; 8
    ee04:	30 e0       	ldi	r19, 0x00	; 0
    ee06:	0a c0       	rjmp	.+20     	; 0xee1c <vfprintf+0x2a2>
    ee08:	10 61       	ori	r17, 0x10	; 16
    ee0a:	14 fd       	sbrc	r17, 4
    ee0c:	14 60       	ori	r17, 0x04	; 4
    ee0e:	20 e1       	ldi	r18, 0x10	; 16
    ee10:	30 e0       	ldi	r19, 0x00	; 0
    ee12:	04 c0       	rjmp	.+8      	; 0xee1c <vfprintf+0x2a2>
    ee14:	14 fd       	sbrc	r17, 4
    ee16:	16 60       	ori	r17, 0x06	; 6
    ee18:	20 e1       	ldi	r18, 0x10	; 16
    ee1a:	32 e0       	ldi	r19, 0x02	; 2
    ee1c:	17 ff       	sbrs	r17, 7
    ee1e:	08 c0       	rjmp	.+16     	; 0xee30 <vfprintf+0x2b6>
    ee20:	f5 01       	movw	r30, r10
    ee22:	60 81       	ld	r22, Z
    ee24:	71 81       	ldd	r23, Z+1	; 0x01
    ee26:	82 81       	ldd	r24, Z+2	; 0x02
    ee28:	93 81       	ldd	r25, Z+3	; 0x03
    ee2a:	44 e0       	ldi	r20, 0x04	; 4
    ee2c:	50 e0       	ldi	r21, 0x00	; 0
    ee2e:	08 c0       	rjmp	.+16     	; 0xee40 <vfprintf+0x2c6>
    ee30:	f5 01       	movw	r30, r10
    ee32:	80 81       	ld	r24, Z
    ee34:	91 81       	ldd	r25, Z+1	; 0x01
    ee36:	bc 01       	movw	r22, r24
    ee38:	80 e0       	ldi	r24, 0x00	; 0
    ee3a:	90 e0       	ldi	r25, 0x00	; 0
    ee3c:	42 e0       	ldi	r20, 0x02	; 2
    ee3e:	50 e0       	ldi	r21, 0x00	; 0
    ee40:	a4 0e       	add	r10, r20
    ee42:	b5 1e       	adc	r11, r21
    ee44:	a1 01       	movw	r20, r2
    ee46:	0e 94 2b 78 	call	0xf056	; 0xf056 <__ultoa_invert>
    ee4a:	d8 2e       	mov	r13, r24
    ee4c:	d2 18       	sub	r13, r2
    ee4e:	8f e7       	ldi	r24, 0x7F	; 127
    ee50:	f8 2e       	mov	r15, r24
    ee52:	f1 22       	and	r15, r17
    ee54:	f6 fe       	sbrs	r15, 6
    ee56:	0b c0       	rjmp	.+22     	; 0xee6e <vfprintf+0x2f4>
    ee58:	5e ef       	ldi	r21, 0xFE	; 254
    ee5a:	f5 22       	and	r15, r21
    ee5c:	d9 14       	cp	r13, r9
    ee5e:	38 f4       	brcc	.+14     	; 0xee6e <vfprintf+0x2f4>
    ee60:	f4 fe       	sbrs	r15, 4
    ee62:	07 c0       	rjmp	.+14     	; 0xee72 <vfprintf+0x2f8>
    ee64:	f2 fc       	sbrc	r15, 2
    ee66:	05 c0       	rjmp	.+10     	; 0xee72 <vfprintf+0x2f8>
    ee68:	8f ee       	ldi	r24, 0xEF	; 239
    ee6a:	f8 22       	and	r15, r24
    ee6c:	02 c0       	rjmp	.+4      	; 0xee72 <vfprintf+0x2f8>
    ee6e:	1d 2d       	mov	r17, r13
    ee70:	01 c0       	rjmp	.+2      	; 0xee74 <vfprintf+0x2fa>
    ee72:	19 2d       	mov	r17, r9
    ee74:	f4 fe       	sbrs	r15, 4
    ee76:	0d c0       	rjmp	.+26     	; 0xee92 <vfprintf+0x318>
    ee78:	fe 01       	movw	r30, r28
    ee7a:	ed 0d       	add	r30, r13
    ee7c:	f1 1d       	adc	r31, r1
    ee7e:	80 81       	ld	r24, Z
    ee80:	80 33       	cpi	r24, 0x30	; 48
    ee82:	19 f4       	brne	.+6      	; 0xee8a <vfprintf+0x310>
    ee84:	99 ee       	ldi	r25, 0xE9	; 233
    ee86:	f9 22       	and	r15, r25
    ee88:	08 c0       	rjmp	.+16     	; 0xee9a <vfprintf+0x320>
    ee8a:	1f 5f       	subi	r17, 0xFF	; 255
    ee8c:	f2 fe       	sbrs	r15, 2
    ee8e:	05 c0       	rjmp	.+10     	; 0xee9a <vfprintf+0x320>
    ee90:	03 c0       	rjmp	.+6      	; 0xee98 <vfprintf+0x31e>
    ee92:	8f 2d       	mov	r24, r15
    ee94:	86 78       	andi	r24, 0x86	; 134
    ee96:	09 f0       	breq	.+2      	; 0xee9a <vfprintf+0x320>
    ee98:	1f 5f       	subi	r17, 0xFF	; 255
    ee9a:	0f 2d       	mov	r16, r15
    ee9c:	f3 fc       	sbrc	r15, 3
    ee9e:	14 c0       	rjmp	.+40     	; 0xeec8 <vfprintf+0x34e>
    eea0:	f0 fe       	sbrs	r15, 0
    eea2:	0f c0       	rjmp	.+30     	; 0xeec2 <vfprintf+0x348>
    eea4:	1e 15       	cp	r17, r14
    eea6:	10 f0       	brcs	.+4      	; 0xeeac <vfprintf+0x332>
    eea8:	9d 2c       	mov	r9, r13
    eeaa:	0b c0       	rjmp	.+22     	; 0xeec2 <vfprintf+0x348>
    eeac:	9d 2c       	mov	r9, r13
    eeae:	9e 0c       	add	r9, r14
    eeb0:	91 1a       	sub	r9, r17
    eeb2:	1e 2d       	mov	r17, r14
    eeb4:	06 c0       	rjmp	.+12     	; 0xeec2 <vfprintf+0x348>
    eeb6:	80 e2       	ldi	r24, 0x20	; 32
    eeb8:	90 e0       	ldi	r25, 0x00	; 0
    eeba:	b3 01       	movw	r22, r6
    eebc:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    eec0:	1f 5f       	subi	r17, 0xFF	; 255
    eec2:	1e 15       	cp	r17, r14
    eec4:	c0 f3       	brcs	.-16     	; 0xeeb6 <vfprintf+0x33c>
    eec6:	04 c0       	rjmp	.+8      	; 0xeed0 <vfprintf+0x356>
    eec8:	1e 15       	cp	r17, r14
    eeca:	10 f4       	brcc	.+4      	; 0xeed0 <vfprintf+0x356>
    eecc:	e1 1a       	sub	r14, r17
    eece:	01 c0       	rjmp	.+2      	; 0xeed2 <vfprintf+0x358>
    eed0:	ee 24       	eor	r14, r14
    eed2:	04 ff       	sbrs	r16, 4
    eed4:	0f c0       	rjmp	.+30     	; 0xeef4 <vfprintf+0x37a>
    eed6:	80 e3       	ldi	r24, 0x30	; 48
    eed8:	90 e0       	ldi	r25, 0x00	; 0
    eeda:	b3 01       	movw	r22, r6
    eedc:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    eee0:	02 ff       	sbrs	r16, 2
    eee2:	1d c0       	rjmp	.+58     	; 0xef1e <vfprintf+0x3a4>
    eee4:	01 fd       	sbrc	r16, 1
    eee6:	03 c0       	rjmp	.+6      	; 0xeeee <vfprintf+0x374>
    eee8:	88 e7       	ldi	r24, 0x78	; 120
    eeea:	90 e0       	ldi	r25, 0x00	; 0
    eeec:	0e c0       	rjmp	.+28     	; 0xef0a <vfprintf+0x390>
    eeee:	88 e5       	ldi	r24, 0x58	; 88
    eef0:	90 e0       	ldi	r25, 0x00	; 0
    eef2:	0b c0       	rjmp	.+22     	; 0xef0a <vfprintf+0x390>
    eef4:	80 2f       	mov	r24, r16
    eef6:	86 78       	andi	r24, 0x86	; 134
    eef8:	91 f0       	breq	.+36     	; 0xef1e <vfprintf+0x3a4>
    eefa:	01 ff       	sbrs	r16, 1
    eefc:	02 c0       	rjmp	.+4      	; 0xef02 <vfprintf+0x388>
    eefe:	8b e2       	ldi	r24, 0x2B	; 43
    ef00:	01 c0       	rjmp	.+2      	; 0xef04 <vfprintf+0x38a>
    ef02:	80 e2       	ldi	r24, 0x20	; 32
    ef04:	f7 fc       	sbrc	r15, 7
    ef06:	8d e2       	ldi	r24, 0x2D	; 45
    ef08:	90 e0       	ldi	r25, 0x00	; 0
    ef0a:	b3 01       	movw	r22, r6
    ef0c:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    ef10:	06 c0       	rjmp	.+12     	; 0xef1e <vfprintf+0x3a4>
    ef12:	80 e3       	ldi	r24, 0x30	; 48
    ef14:	90 e0       	ldi	r25, 0x00	; 0
    ef16:	b3 01       	movw	r22, r6
    ef18:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    ef1c:	9a 94       	dec	r9
    ef1e:	d9 14       	cp	r13, r9
    ef20:	c0 f3       	brcs	.-16     	; 0xef12 <vfprintf+0x398>
    ef22:	da 94       	dec	r13
    ef24:	f1 01       	movw	r30, r2
    ef26:	ed 0d       	add	r30, r13
    ef28:	f1 1d       	adc	r31, r1
    ef2a:	80 81       	ld	r24, Z
    ef2c:	90 e0       	ldi	r25, 0x00	; 0
    ef2e:	b3 01       	movw	r22, r6
    ef30:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    ef34:	dd 20       	and	r13, r13
    ef36:	a9 f7       	brne	.-22     	; 0xef22 <vfprintf+0x3a8>
    ef38:	06 c0       	rjmp	.+12     	; 0xef46 <vfprintf+0x3cc>
    ef3a:	80 e2       	ldi	r24, 0x20	; 32
    ef3c:	90 e0       	ldi	r25, 0x00	; 0
    ef3e:	b3 01       	movw	r22, r6
    ef40:	0e 94 35 75 	call	0xea6a	; 0xea6a <fputc>
    ef44:	ea 94       	dec	r14
    ef46:	ee 20       	and	r14, r14
    ef48:	c1 f7       	brne	.-16     	; 0xef3a <vfprintf+0x3c0>
    ef4a:	43 ce       	rjmp	.-890    	; 0xebd2 <vfprintf+0x58>
    ef4c:	f3 01       	movw	r30, r6
    ef4e:	66 81       	ldd	r22, Z+6	; 0x06
    ef50:	77 81       	ldd	r23, Z+7	; 0x07
    ef52:	cb 01       	movw	r24, r22
    ef54:	2b 96       	adiw	r28, 0x0b	; 11
    ef56:	0f b6       	in	r0, 0x3f	; 63
    ef58:	f8 94       	cli
    ef5a:	de bf       	out	0x3e, r29	; 62
    ef5c:	0f be       	out	0x3f, r0	; 63
    ef5e:	cd bf       	out	0x3d, r28	; 61
    ef60:	cf 91       	pop	r28
    ef62:	df 91       	pop	r29
    ef64:	1f 91       	pop	r17
    ef66:	0f 91       	pop	r16
    ef68:	ff 90       	pop	r15
    ef6a:	ef 90       	pop	r14
    ef6c:	df 90       	pop	r13
    ef6e:	cf 90       	pop	r12
    ef70:	bf 90       	pop	r11
    ef72:	af 90       	pop	r10
    ef74:	9f 90       	pop	r9
    ef76:	8f 90       	pop	r8
    ef78:	7f 90       	pop	r7
    ef7a:	6f 90       	pop	r6
    ef7c:	5f 90       	pop	r5
    ef7e:	4f 90       	pop	r4
    ef80:	3f 90       	pop	r3
    ef82:	2f 90       	pop	r2
    ef84:	08 95       	ret

0000ef86 <__eerd_block_m128>:
    ef86:	dc 01       	movw	r26, r24
    ef88:	cb 01       	movw	r24, r22

0000ef8a <__eerd_blraw_m128>:
    ef8a:	fc 01       	movw	r30, r24
    ef8c:	e1 99       	sbic	0x1c, 1	; 28
    ef8e:	fe cf       	rjmp	.-4      	; 0xef8c <__eerd_blraw_m128+0x2>
    ef90:	06 c0       	rjmp	.+12     	; 0xef9e <__eerd_blraw_m128+0x14>
    ef92:	ff bb       	out	0x1f, r31	; 31
    ef94:	ee bb       	out	0x1e, r30	; 30
    ef96:	e0 9a       	sbi	0x1c, 0	; 28
    ef98:	31 96       	adiw	r30, 0x01	; 1
    ef9a:	0d b2       	in	r0, 0x1d	; 29
    ef9c:	0d 92       	st	X+, r0
    ef9e:	41 50       	subi	r20, 0x01	; 1
    efa0:	50 40       	sbci	r21, 0x00	; 0
    efa2:	b8 f7       	brcc	.-18     	; 0xef92 <__eerd_blraw_m128+0x8>
    efa4:	08 95       	ret

0000efa6 <__eerd_dword_m128>:
    efa6:	a6 e1       	ldi	r26, 0x16	; 22
    efa8:	b0 e0       	ldi	r27, 0x00	; 0
    efaa:	44 e0       	ldi	r20, 0x04	; 4
    efac:	50 e0       	ldi	r21, 0x00	; 0
    efae:	0c 94 c5 77 	jmp	0xef8a	; 0xef8a <__eerd_blraw_m128>

0000efb2 <__eerd_word_m128>:
    efb2:	a8 e1       	ldi	r26, 0x18	; 24
    efb4:	b0 e0       	ldi	r27, 0x00	; 0
    efb6:	42 e0       	ldi	r20, 0x02	; 2
    efb8:	50 e0       	ldi	r21, 0x00	; 0
    efba:	0c 94 c5 77 	jmp	0xef8a	; 0xef8a <__eerd_blraw_m128>

0000efbe <__eeupd_block_m128>:
    efbe:	dc 01       	movw	r26, r24
    efc0:	a4 0f       	add	r26, r20
    efc2:	b5 1f       	adc	r27, r21
    efc4:	41 50       	subi	r20, 0x01	; 1
    efc6:	50 40       	sbci	r21, 0x00	; 0
    efc8:	48 f0       	brcs	.+18     	; 0xefdc <__eeupd_block_m128+0x1e>
    efca:	cb 01       	movw	r24, r22
    efcc:	84 0f       	add	r24, r20
    efce:	95 1f       	adc	r25, r21
    efd0:	2e 91       	ld	r18, -X
    efd2:	0e 94 f0 77 	call	0xefe0	; 0xefe0 <__eeupd_r18_m128>
    efd6:	41 50       	subi	r20, 0x01	; 1
    efd8:	50 40       	sbci	r21, 0x00	; 0
    efda:	d0 f7       	brcc	.-12     	; 0xefd0 <__eeupd_block_m128+0x12>
    efdc:	08 95       	ret

0000efde <__eeupd_byte_m128>:
    efde:	26 2f       	mov	r18, r22

0000efe0 <__eeupd_r18_m128>:
    efe0:	e1 99       	sbic	0x1c, 1	; 28
    efe2:	fe cf       	rjmp	.-4      	; 0xefe0 <__eeupd_r18_m128>
    efe4:	9f bb       	out	0x1f, r25	; 31
    efe6:	8e bb       	out	0x1e, r24	; 30
    efe8:	e0 9a       	sbi	0x1c, 0	; 28
    efea:	01 97       	sbiw	r24, 0x01	; 1
    efec:	0d b2       	in	r0, 0x1d	; 29
    efee:	02 16       	cp	r0, r18
    eff0:	31 f0       	breq	.+12     	; 0xeffe <__eeupd_r18_m128+0x1e>
    eff2:	2d bb       	out	0x1d, r18	; 29
    eff4:	0f b6       	in	r0, 0x3f	; 63
    eff6:	f8 94       	cli
    eff8:	e2 9a       	sbi	0x1c, 2	; 28
    effa:	e1 9a       	sbi	0x1c, 1	; 28
    effc:	0f be       	out	0x3f, r0	; 63
    effe:	08 95       	ret

0000f000 <__eeupd_dword_m128>:
    f000:	03 96       	adiw	r24, 0x03	; 3
    f002:	27 2f       	mov	r18, r23
    f004:	0e 94 f0 77 	call	0xefe0	; 0xefe0 <__eeupd_r18_m128>
    f008:	0e 94 ef 77 	call	0xefde	; 0xefde <__eeupd_byte_m128>
    f00c:	25 2f       	mov	r18, r21
    f00e:	0e 94 f0 77 	call	0xefe0	; 0xefe0 <__eeupd_r18_m128>
    f012:	24 2f       	mov	r18, r20
    f014:	0c 94 f0 77 	jmp	0xefe0	; 0xefe0 <__eeupd_r18_m128>

0000f018 <__eeupd_word_m128>:
    f018:	01 96       	adiw	r24, 0x01	; 1
    f01a:	27 2f       	mov	r18, r23
    f01c:	0e 94 f0 77 	call	0xefe0	; 0xefe0 <__eeupd_r18_m128>
    f020:	0c 94 ef 77 	jmp	0xefde	; 0xefde <__eeupd_byte_m128>

0000f024 <__ctype_isfalse>:
    f024:	99 27       	eor	r25, r25
    f026:	88 27       	eor	r24, r24

0000f028 <__ctype_istrue>:
    f028:	08 95       	ret

0000f02a <strnlen_P>:
    f02a:	fc 01       	movw	r30, r24
    f02c:	05 90       	lpm	r0, Z+
    f02e:	61 50       	subi	r22, 0x01	; 1
    f030:	70 40       	sbci	r23, 0x00	; 0
    f032:	01 10       	cpse	r0, r1
    f034:	d8 f7       	brcc	.-10     	; 0xf02c <strnlen_P+0x2>
    f036:	80 95       	com	r24
    f038:	90 95       	com	r25
    f03a:	8e 0f       	add	r24, r30
    f03c:	9f 1f       	adc	r25, r31
    f03e:	08 95       	ret

0000f040 <strnlen>:
    f040:	fc 01       	movw	r30, r24
    f042:	61 50       	subi	r22, 0x01	; 1
    f044:	70 40       	sbci	r23, 0x00	; 0
    f046:	01 90       	ld	r0, Z+
    f048:	01 10       	cpse	r0, r1
    f04a:	d8 f7       	brcc	.-10     	; 0xf042 <strnlen+0x2>
    f04c:	80 95       	com	r24
    f04e:	90 95       	com	r25
    f050:	8e 0f       	add	r24, r30
    f052:	9f 1f       	adc	r25, r31
    f054:	08 95       	ret

0000f056 <__ultoa_invert>:
    f056:	fa 01       	movw	r30, r20
    f058:	aa 27       	eor	r26, r26
    f05a:	28 30       	cpi	r18, 0x08	; 8
    f05c:	51 f1       	breq	.+84     	; 0xf0b2 <__ultoa_invert+0x5c>
    f05e:	20 31       	cpi	r18, 0x10	; 16
    f060:	81 f1       	breq	.+96     	; 0xf0c2 <__ultoa_invert+0x6c>
    f062:	e8 94       	clt
    f064:	6f 93       	push	r22
    f066:	6e 7f       	andi	r22, 0xFE	; 254
    f068:	6e 5f       	subi	r22, 0xFE	; 254
    f06a:	7f 4f       	sbci	r23, 0xFF	; 255
    f06c:	8f 4f       	sbci	r24, 0xFF	; 255
    f06e:	9f 4f       	sbci	r25, 0xFF	; 255
    f070:	af 4f       	sbci	r26, 0xFF	; 255
    f072:	b1 e0       	ldi	r27, 0x01	; 1
    f074:	3e d0       	rcall	.+124    	; 0xf0f2 <__ultoa_invert+0x9c>
    f076:	b4 e0       	ldi	r27, 0x04	; 4
    f078:	3c d0       	rcall	.+120    	; 0xf0f2 <__ultoa_invert+0x9c>
    f07a:	67 0f       	add	r22, r23
    f07c:	78 1f       	adc	r23, r24
    f07e:	89 1f       	adc	r24, r25
    f080:	9a 1f       	adc	r25, r26
    f082:	a1 1d       	adc	r26, r1
    f084:	68 0f       	add	r22, r24
    f086:	79 1f       	adc	r23, r25
    f088:	8a 1f       	adc	r24, r26
    f08a:	91 1d       	adc	r25, r1
    f08c:	a1 1d       	adc	r26, r1
    f08e:	6a 0f       	add	r22, r26
    f090:	71 1d       	adc	r23, r1
    f092:	81 1d       	adc	r24, r1
    f094:	91 1d       	adc	r25, r1
    f096:	a1 1d       	adc	r26, r1
    f098:	20 d0       	rcall	.+64     	; 0xf0da <__ultoa_invert+0x84>
    f09a:	09 f4       	brne	.+2      	; 0xf09e <__ultoa_invert+0x48>
    f09c:	68 94       	set
    f09e:	3f 91       	pop	r19
    f0a0:	2a e0       	ldi	r18, 0x0A	; 10
    f0a2:	26 9f       	mul	r18, r22
    f0a4:	11 24       	eor	r1, r1
    f0a6:	30 19       	sub	r19, r0
    f0a8:	30 5d       	subi	r19, 0xD0	; 208
    f0aa:	31 93       	st	Z+, r19
    f0ac:	de f6       	brtc	.-74     	; 0xf064 <__ultoa_invert+0xe>
    f0ae:	cf 01       	movw	r24, r30
    f0b0:	08 95       	ret
    f0b2:	46 2f       	mov	r20, r22
    f0b4:	47 70       	andi	r20, 0x07	; 7
    f0b6:	40 5d       	subi	r20, 0xD0	; 208
    f0b8:	41 93       	st	Z+, r20
    f0ba:	b3 e0       	ldi	r27, 0x03	; 3
    f0bc:	0f d0       	rcall	.+30     	; 0xf0dc <__ultoa_invert+0x86>
    f0be:	c9 f7       	brne	.-14     	; 0xf0b2 <__ultoa_invert+0x5c>
    f0c0:	f6 cf       	rjmp	.-20     	; 0xf0ae <__ultoa_invert+0x58>
    f0c2:	46 2f       	mov	r20, r22
    f0c4:	4f 70       	andi	r20, 0x0F	; 15
    f0c6:	40 5d       	subi	r20, 0xD0	; 208
    f0c8:	4a 33       	cpi	r20, 0x3A	; 58
    f0ca:	18 f0       	brcs	.+6      	; 0xf0d2 <__ultoa_invert+0x7c>
    f0cc:	49 5d       	subi	r20, 0xD9	; 217
    f0ce:	31 fd       	sbrc	r19, 1
    f0d0:	40 52       	subi	r20, 0x20	; 32
    f0d2:	41 93       	st	Z+, r20
    f0d4:	02 d0       	rcall	.+4      	; 0xf0da <__ultoa_invert+0x84>
    f0d6:	a9 f7       	brne	.-22     	; 0xf0c2 <__ultoa_invert+0x6c>
    f0d8:	ea cf       	rjmp	.-44     	; 0xf0ae <__ultoa_invert+0x58>
    f0da:	b4 e0       	ldi	r27, 0x04	; 4
    f0dc:	a6 95       	lsr	r26
    f0de:	97 95       	ror	r25
    f0e0:	87 95       	ror	r24
    f0e2:	77 95       	ror	r23
    f0e4:	67 95       	ror	r22
    f0e6:	ba 95       	dec	r27
    f0e8:	c9 f7       	brne	.-14     	; 0xf0dc <__ultoa_invert+0x86>
    f0ea:	00 97       	sbiw	r24, 0x00	; 0
    f0ec:	61 05       	cpc	r22, r1
    f0ee:	71 05       	cpc	r23, r1
    f0f0:	08 95       	ret
    f0f2:	9b 01       	movw	r18, r22
    f0f4:	ac 01       	movw	r20, r24
    f0f6:	0a 2e       	mov	r0, r26
    f0f8:	06 94       	lsr	r0
    f0fa:	57 95       	ror	r21
    f0fc:	47 95       	ror	r20
    f0fe:	37 95       	ror	r19
    f100:	27 95       	ror	r18
    f102:	ba 95       	dec	r27
    f104:	c9 f7       	brne	.-14     	; 0xf0f8 <__ultoa_invert+0xa2>
    f106:	62 0f       	add	r22, r18
    f108:	73 1f       	adc	r23, r19
    f10a:	84 1f       	adc	r24, r20
    f10c:	95 1f       	adc	r25, r21
    f10e:	a0 1d       	adc	r26, r0
    f110:	08 95       	ret

0000f112 <__mulsi3>:
    f112:	62 9f       	mul	r22, r18
    f114:	d0 01       	movw	r26, r0
    f116:	73 9f       	mul	r23, r19
    f118:	f0 01       	movw	r30, r0
    f11a:	82 9f       	mul	r24, r18
    f11c:	e0 0d       	add	r30, r0
    f11e:	f1 1d       	adc	r31, r1
    f120:	64 9f       	mul	r22, r20
    f122:	e0 0d       	add	r30, r0
    f124:	f1 1d       	adc	r31, r1
    f126:	92 9f       	mul	r25, r18
    f128:	f0 0d       	add	r31, r0
    f12a:	83 9f       	mul	r24, r19
    f12c:	f0 0d       	add	r31, r0
    f12e:	74 9f       	mul	r23, r20
    f130:	f0 0d       	add	r31, r0
    f132:	65 9f       	mul	r22, r21
    f134:	f0 0d       	add	r31, r0
    f136:	99 27       	eor	r25, r25
    f138:	72 9f       	mul	r23, r18
    f13a:	b0 0d       	add	r27, r0
    f13c:	e1 1d       	adc	r30, r1
    f13e:	f9 1f       	adc	r31, r25
    f140:	63 9f       	mul	r22, r19
    f142:	b0 0d       	add	r27, r0
    f144:	e1 1d       	adc	r30, r1
    f146:	f9 1f       	adc	r31, r25
    f148:	bd 01       	movw	r22, r26
    f14a:	cf 01       	movw	r24, r30
    f14c:	11 24       	eor	r1, r1
    f14e:	08 95       	ret

0000f150 <__udivmodsi4>:
    f150:	a1 e2       	ldi	r26, 0x21	; 33
    f152:	1a 2e       	mov	r1, r26
    f154:	aa 1b       	sub	r26, r26
    f156:	bb 1b       	sub	r27, r27
    f158:	fd 01       	movw	r30, r26
    f15a:	0d c0       	rjmp	.+26     	; 0xf176 <__udivmodsi4_ep>

0000f15c <__udivmodsi4_loop>:
    f15c:	aa 1f       	adc	r26, r26
    f15e:	bb 1f       	adc	r27, r27
    f160:	ee 1f       	adc	r30, r30
    f162:	ff 1f       	adc	r31, r31
    f164:	a2 17       	cp	r26, r18
    f166:	b3 07       	cpc	r27, r19
    f168:	e4 07       	cpc	r30, r20
    f16a:	f5 07       	cpc	r31, r21
    f16c:	20 f0       	brcs	.+8      	; 0xf176 <__udivmodsi4_ep>
    f16e:	a2 1b       	sub	r26, r18
    f170:	b3 0b       	sbc	r27, r19
    f172:	e4 0b       	sbc	r30, r20
    f174:	f5 0b       	sbc	r31, r21

0000f176 <__udivmodsi4_ep>:
    f176:	66 1f       	adc	r22, r22
    f178:	77 1f       	adc	r23, r23
    f17a:	88 1f       	adc	r24, r24
    f17c:	99 1f       	adc	r25, r25
    f17e:	1a 94       	dec	r1
    f180:	69 f7       	brne	.-38     	; 0xf15c <__udivmodsi4_loop>
    f182:	60 95       	com	r22
    f184:	70 95       	com	r23
    f186:	80 95       	com	r24
    f188:	90 95       	com	r25
    f18a:	9b 01       	movw	r18, r22
    f18c:	ac 01       	movw	r20, r24
    f18e:	bd 01       	movw	r22, r26
    f190:	cf 01       	movw	r24, r30
    f192:	08 95       	ret

0000f194 <_exit>:
    f194:	f8 94       	cli

0000f196 <__stop_program>:
    f196:	ff cf       	rjmp	.-2      	; 0xf196 <__stop_program>
