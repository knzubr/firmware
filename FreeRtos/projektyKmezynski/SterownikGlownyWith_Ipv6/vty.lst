   1               		.file	"vty.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 279               	enableFunction:
 280               		.stabd	46,0,0
   1:vty.c         **** #include "main.h"
   2:vty.c         **** #include "vty.h"
   3:vty.c         **** #include "ramdysk.h"
   4:vty.c         **** #include "protocol1.h"
   5:vty.c         **** #include "mpc23s17.h"
   6:vty.c         **** #include "mcp3008.h"
   7:vty.c         **** #include "ds1305.h"
   8:vty.c         **** #include "hardwareConfig.h"
   9:vty.c         **** #include "configuration.h"
  10:vty.c         **** #include "Rs485_prot.h"
  11:vty.c         **** #include "net.h"
  12:vty.c         **** #include "ip.h"
  13:vty.c         **** #include "arp.h"
  14:vty.c         **** #include "softwareConfig.h"
  15:vty.c         **** #include "mcp4150.h"
  16:vty.c         **** 
  17:vty.c         **** #if LANG_EN
  18:vty.c         **** #include "vty_en.h"
  19:vty.c         **** #endif
  20:vty.c         **** 
  21:vty.c         **** #if LANG_PL
  22:vty.c         **** #include "vty_pl.h"
  23:vty.c         **** #endif
  24:vty.c         **** 
  25:vty.c         **** #ifndef LANG_VTY
  26:vty.c         **** #error "Vty Language not defined"
  27:vty.c         **** #endif
  28:vty.c         **** 
  29:vty.c         **** 
  30:vty.c         **** static cliExRes_t helpFunction           (cmdState_t *state);
  31:vty.c         **** static cliExRes_t statusFunction         (cmdState_t *state);
  32:vty.c         **** static cliExRes_t statusEncFunction      (cmdState_t *state);
  33:vty.c         **** static cliExRes_t curtainDownFunction    (cmdState_t *state);
  34:vty.c         **** static cliExRes_t curtainUpFunction      (cmdState_t *state);
  35:vty.c         **** static cliExRes_t rpingFunction          (cmdState_t *state);
  36:vty.c         **** static cliExRes_t pingFunction           (cmdState_t *state);
  37:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state);
  38:vty.c         **** static cliExRes_t goXmodemWyslijFunction (cmdState_t *state);
  39:vty.c         **** static cliExRes_t dodajRamPlikFunction   (cmdState_t *state);
  40:vty.c         **** static cliExRes_t eraseRamFileFunction   (cmdState_t *state);
  41:vty.c         **** static cliExRes_t flashExModuleFunction  (cmdState_t *state);
  42:vty.c         **** static cliExRes_t writeRamFileFunction   (cmdState_t *state);
  43:vty.c         **** static cliExRes_t editRamFileFunction    (cmdState_t *state);
  44:vty.c         **** static cliExRes_t readRamFIleFunction    (cmdState_t *state);
  45:vty.c         **** 
  46:vty.c         **** static cliExRes_t ustawPortExtAFunction  (cmdState_t *state);
  47:vty.c         **** static cliExRes_t ustawPortExtBFunction  (cmdState_t *state);
  48:vty.c         **** static cliExRes_t ustawPortRezystor      (cmdState_t *state);
  49:vty.c         **** 
  50:vty.c         **** static cliExRes_t pokazCzasFunction      (cmdState_t *state);
  51:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state);
  52:vty.c         **** static cliExRes_t czytajAC_Function      (cmdState_t *state);
  53:vty.c         **** 
  54:vty.c         **** static cliExRes_t enableFunction         (cmdState_t *state);
  55:vty.c         **** static cliExRes_t disableFunction        (cmdState_t *state);
  56:vty.c         **** static cliExRes_t configureModeFunction  (cmdState_t *state);
  57:vty.c         **** 
  58:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state);
  59:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state);
  60:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state);
  61:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state);
  62:vty.c         **** 
  63:vty.c         **** static cliExRes_t setMacAddrFunction     (cmdState_t *state);
  64:vty.c         **** static cliExRes_t setTimeFunction        (cmdState_t *state);
  65:vty.c         **** 
  66:vty.c         **** static cliExRes_t saveConfigFunction     (cmdState_t *state);
  67:vty.c         **** 
  68:vty.c         **** #ifdef testZewPamiec
  69:vty.c         **** static cliExRes_t testPamZewFunction     (cmdState_t *state);
  70:vty.c         **** #endif
  71:vty.c         **** 
  72:vty.c         **** struct ramPlikFd    fdVty;  //TODO move it to CLI struct
  73:vty.c         **** 
  74:vty.c         **** prog_char okStr[] = "OK\r\n";
  75:vty.c         **** prog_char nlStr[] = "\r\n";
  76:vty.c         **** prog_char BladBuforaPozostaloBajtowStr[]           = "!!! W budorze Rs485 pozostalo %d bajtow\r\n";
  77:vty.c         **** 
  78:vty.c         **** 
  79:vty.c         **** prog_char __ATTR_PROGMEM__ *errorStrings[] = {
  80:vty.c         ****   errorOK,
  81:vty.c         ****   errorNoFile,
  82:vty.c         ****   errorxModemFrameStartTimeout,
  83:vty.c         ****   errorxModemByteSendTimeout,
  84:vty.c         ****   errorxModemWrongFrameNo,
  85:vty.c         ****   errorxModemFrameFrameNoCorrectionNotMatch,
  86:vty.c         ****   errorxModemFrameCrc,
  87:vty.c         ****   errorxModemRemoteSideCan,
  88:vty.c         ****   errorxModemUnknownResponse,
  89:vty.c         ****   errorNoRemoteDevice,
  90:vty.c         ****   errorBootloaderNotResponding,
  91:vty.c         ****   errorOpenFile
  92:vty.c         **** };
  93:vty.c         **** 
  94:vty.c         **** command_t __ATTR_PROGMEM__ cmdListNormal[] =
  95:vty.c         **** {
  96:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
  97:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
  98:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},  
  99:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 100:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 101:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 102:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 103:vty.c         ****   {cmd_enable,    cmd_help_enable,    enableFunction},
 104:vty.c         ****   {NULL, NULL, NULL}
 105:vty.c         **** };
 106:vty.c         **** 
 107:vty.c         **** command_t __ATTR_PROGMEM__ cmdListEnable[] =
 108:vty.c         **** {
 109:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
 110:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
 111:vty.c         ****   {cmd_enc_stat,  cmd_help_enc_stat,  statusEncFunction},
 112:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},
 113:vty.c         ****   {cmd_net_dbg,   cmd_help_net_dbg,   debugFunction},
 114:vty.c         ****   
 115:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 116:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 117:vty.c         ****   {cmd_xRec,      cmd_help_xRec,      goXmodemOdbierzFunction},
 118:vty.c         ****   {cmd_xSend,     cmd_help_xSend,     goXmodemWyslijFunction},
 119:vty.c         ****   {cmd_xflash,    cmd_help_xflash,    flashExModuleFunction},
 120:vty.c         **** #ifdef testZewPamiec
 121:vty.c         ****   {cmd_rtest,     cmd_help_rtest,     testPamZewFunction},
 122:vty.c         **** #endif
 123:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 124:vty.c         ****   {cmd_create_rf, cmd_help_create_rf, dodajRamPlikFunction},
 125:vty.c         ****   {cmd_erase_rf,  cmd_help_erase_rf,  eraseRamFileFunction},
 126:vty.c         ****   {cmd_edit_rf,   cmd_help_edit_rf,   editRamFileFunction},
 127:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 128:vty.c         **** 
 129:vty.c         ****   {cmd_up,        cmd_help_up,        curtainUpFunction},
 130:vty.c         ****   {cmd_down,      cmd_help_down,      curtainDownFunction},
 131:vty.c         **** 
 132:vty.c         ****   {cmd_spa,       cmd_help_spa,       ustawPortExtAFunction},
 133:vty.c         ****   {cmd_spb,       cmd_help_spb,       ustawPortExtBFunction},
 134:vty.c         ****   {cmd_ustawR,    cmd_help_ustawR,    ustawPortRezystor},
 135:vty.c         ****   {cmd_settime,   cmd_help_settime,   setTimeFunction},
 136:vty.c         ****   {cmd_ac,        cmd_help_ac,        czytajAC_Function},
 137:vty.c         ****   {cmd_disable,   cmd_help_disable,   disableFunction},
 138:vty.c         ****   {cmd_configure, cmd_help_configure, configureModeFunction},
 139:vty.c         ****   {NULL, NULL, NULL}
 140:vty.c         **** };
 141:vty.c         **** 
 142:vty.c         **** command_t __ATTR_PROGMEM__ cmdListConfigure[] =
 143:vty.c         **** {
 144:vty.c         ****   {cmd_help,         cmd_help_help,         helpFunction},
 145:vty.c         ****   {cmd_status,       cmd_help_status,       statusFunction},
 146:vty.c         ****   {cmd_time,         cmd_help_time,         pokazCzasFunction},
 147:vty.c         ****   {cmd_settime,      cmd_help_settime,      setTimeFunction},
 148:vty.c         ****   {cmd_conf_ip,      cmd_help_conf_ip,      setIpFunction},
 149:vty.c         ****   {cmd_conf_ip_mask, cmd_conf_ip_mask_help, setIpMaskFunction},
 150:vty.c         ****   {cmd_conf_ip_gw,   cmd_conf_ip_gw_help,   setIpGwFunction},
 151:vty.c         ****   {cmd_conf_udp,     cmd_help_conf_udp,     setUdpFunction},
 152:vty.c         ****   {cmd_conf_mac,     cmd_help_conf_mac,     setMacAddrFunction},
 153:vty.c         ****   {cmd_conf_save,    cmd_help_conf_save,    saveConfigFunction},
 154:vty.c         ****   {cmd_enable,       cmd_help_enable,       enableFunction},
 155:vty.c         ****   {cmd_disable,      cmd_help_disable,      disableFunction},
 156:vty.c         ****   {NULL, NULL, NULL}
 157:vty.c         **** };
 158:vty.c         **** 
 159:vty.c         **** void VtyInit(cmdState_t* state, FILE *stream)
 160:vty.c         **** {
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 162:vty.c         **** }
 163:vty.c         **** 
 164:vty.c         **** void printErrorInfo(cmdState_t *state)
 165:vty.c         **** {
 166:vty.c         ****   if (state->errno != 0)
 167:vty.c         ****   {
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 169:vty.c         ****   }
 170:vty.c         ****   state->errno = 0;
 171:vty.c         ****   state->err1 = 0;
 172:vty.c         ****   state->err2 = 0;
 173:vty.c         **** }
 174:vty.c         **** 
 175:vty.c         **** static cliExRes_t enableFunction(cmdState_t *state)
 176:vty.c         **** {
 282               	.LM0:
 283               	.LFBB1:
 284               	/* prologue: function */
 285               	/* frame size = 0 */
 286 0000 FC01      		movw r30,r24
 177:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 288               	.LM1:
 289 0002 80A1      		ldd r24,Z+32
 290 0004 8330      		cpi r24,lo8(3)
 291 0006 01F4      		brne .L2
 292 0008 25E0      		ldi r18,lo8(5)
 293 000a 30E0      		ldi r19,hi8(5)
 294 000c 00C0      		rjmp .L3
 295               	.L2:
 178:vty.c         ****   {
 179:vty.c         ****     state->cmdList = cmdListEnable;
 297               	.LM2:
 298 000e 80E0      		ldi r24,lo8(cmdListEnable)
 299 0010 90E0      		ldi r25,hi8(cmdListEnable)
 300 0012 92A3      		std Z+34,r25
 301 0014 81A3      		std Z+33,r24
 180:vty.c         ****     state->cliMode = NR_ENABLE;
 303               	.LM3:
 304 0016 81E0      		ldi r24,lo8(1)
 305 0018 80A3      		std Z+32,r24
 306 001a 20E0      		ldi r18,lo8(0)
 307 001c 30E0      		ldi r19,hi8(0)
 308               	.L3:
 181:vty.c         ****     return OK_SILENT;
 182:vty.c         ****   }
 183:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 184:vty.c         **** }
 310               	.LM4:
 311 001e C901      		movw r24,r18
 312               	/* epilogue start */
 313 0020 0895      		ret
 315               	.Lscope1:
 317               		.stabd	78,0,0
 321               	disableFunction:
 322               		.stabd	46,0,0
 185:vty.c         **** static cliExRes_t disableFunction(cmdState_t *state)
 186:vty.c         **** {
 324               	.LM5:
 325               	.LFBB2:
 326               	/* prologue: function */
 327               	/* frame size = 0 */
 328 0022 FC01      		movw r30,r24
 187:vty.c         ****   state->cmdList = cmdListNormal;
 330               	.LM6:
 331 0024 80E0      		ldi r24,lo8(cmdListNormal)
 332 0026 90E0      		ldi r25,hi8(cmdListNormal)
 333 0028 92A3      		std Z+34,r25
 334 002a 81A3      		std Z+33,r24
 188:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 336               	.LM7:
 337 002c 80A1      		ldd r24,Z+32
 338 002e 8330      		cpi r24,lo8(3)
 339 0030 01F0      		breq .L6
 189:vty.c         ****   {
 190:vty.c         ****     state->cliMode = NR_NORMAL;
 341               	.LM8:
 342 0032 10A2      		std Z+32,__zero_reg__
 343               	.L6:
 191:vty.c         ****   }
 192:vty.c         ****   return OK_SILENT;
 193:vty.c         **** }
 345               	.LM9:
 346 0034 80E0      		ldi r24,lo8(0)
 347 0036 90E0      		ldi r25,hi8(0)
 348               	/* epilogue start */
 349 0038 0895      		ret
 351               	.Lscope2:
 353               		.stabd	78,0,0
 357               	configureModeFunction:
 358               		.stabd	46,0,0
 194:vty.c         **** static cliExRes_t configureModeFunction(cmdState_t *state)
 195:vty.c         **** {
 360               	.LM10:
 361               	.LFBB3:
 362               	/* prologue: function */
 363               	/* frame size = 0 */
 364 003a FC01      		movw r30,r24
 196:vty.c         ****   if (state->cliMode == NR_ENABLE)
 366               	.LM11:
 367 003c 80A1      		ldd r24,Z+32
 368 003e 8130      		cpi r24,lo8(1)
 369 0040 01F0      		breq .L9
 370 0042 25E0      		ldi r18,lo8(5)
 371 0044 30E0      		ldi r19,hi8(5)
 372 0046 00C0      		rjmp .L10
 373               	.L9:
 197:vty.c         ****   {
 198:vty.c         ****     state->cmdList = cmdListConfigure;
 375               	.LM12:
 376 0048 80E0      		ldi r24,lo8(cmdListConfigure)
 377 004a 90E0      		ldi r25,hi8(cmdListConfigure)
 378 004c 92A3      		std Z+34,r25
 379 004e 81A3      		std Z+33,r24
 199:vty.c         ****     state->cliMode = NR_CONFIGURE;
 381               	.LM13:
 382 0050 82E0      		ldi r24,lo8(2)
 383 0052 80A3      		std Z+32,r24
 384 0054 20E0      		ldi r18,lo8(0)
 385 0056 30E0      		ldi r19,hi8(0)
 386               	.L10:
 200:vty.c         ****     return OK_SILENT;
 201:vty.c         ****   }
 202:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 203:vty.c         **** }
 388               	.LM14:
 389 0058 C901      		movw r24,r18
 390               	/* epilogue start */
 391 005a 0895      		ret
 393               	.Lscope3:
 395               		.stabd	78,0,0
 399               	saveConfigFunction:
 400               		.stabd	46,0,0
 204:vty.c         **** 
 205:vty.c         **** // ************************** VTY API *************************************************************
 206:vty.c         **** void printStatus(FILE *stream)
 207:vty.c         **** {
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 209:vty.c         ****   //Print system state
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 216:vty.c         **** 
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 219:vty.c         **** //  printErrorInfo(state); //TODO fix and uncomment
 220:vty.c         ****   
 221:vty.c         ****   //Print system configuration
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 223:vty.c         **** 
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 227:vty.c         ****   
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 231:vty.c         **** 
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 235:vty.c         ****   
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 239:vty.c         ****   
 240:vty.c         ****   //Print Rs485 Execitive modules
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 242:vty.c         ****   tmp = printRs485devices(stream);
 243:vty.c         ****   if (tmp == 0)
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 245:vty.c         ****   
 246:vty.c         ****   //Print locker sensors
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 248:vty.c         ****   tmp = printLockers(stream);
 249:vty.c         ****   if (tmp == 0)
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 251:vty.c         ****   
 252:vty.c         ****   //Print time FIXME deadlock problem
 253:vty.c         **** /*  readTimeDecoded((timeDecoded_t *)(&czasRtc));
 254:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 255:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 256:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 257:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/
 258:vty.c         **** 
 259:vty.c         ****   udpPrintStatus(stream);
 260:vty.c         **** //  arpPrintTable(stream);
 261:vty.c         **** }
 262:vty.c         **** 
 263:vty.c         **** 
 264:vty.c         **** // ************************** CLI Functions *******************************************************
 265:vty.c         **** 
 266:vty.c         **** static cliExRes_t statusFunction(cmdState_t *state)
 267:vty.c         **** {
 268:vty.c         ****   if (state->argc < 1)
 269:vty.c         ****   {
 270:vty.c         ****     printStatus(state->myStdInOut);
 271:vty.c         ****     return OK_SILENT; 
 272:vty.c         ****   }
 273:vty.c         ****   
 274:vty.c         ****   FILE stream;
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 276:vty.c         ****   {
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 278:vty.c         ****     return ERROR_INFORM;
 279:vty.c         ****   }
 280:vty.c         **** 
 281:vty.c         ****   printStatus(&stream);
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 283:vty.c         ****   return OK_SILENT; 
 284:vty.c         **** }
 285:vty.c         **** 
 286:vty.c         **** static cliExRes_t statusEncFunction(cmdState_t *state)
 287:vty.c         **** {
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 289:vty.c         ****   return OK_SILENT;
 290:vty.c         **** }
 291:vty.c         **** 
 292:vty.c         **** static cliExRes_t pokazCzasFunction(cmdState_t *state)
 293:vty.c         **** {
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 299:vty.c         ****   return OK_SILENT;
 300:vty.c         **** }
 301:vty.c         **** 
 302:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state)
 303:vty.c         **** {
 304:vty.c         ****   if (state->argc < 2)
 305:vty.c         ****     return SYNTAX_ERROR;
 306:vty.c         **** 
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 309:vty.c         ****   if (level == 0)
 310:vty.c         ****   {
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 312:vty.c         ****     {
 313:vty.c         ****       setArpDebug(NULL, 0);
 314:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 315:vty.c         ****       return OK_SILENT;  
 316:vty.c         ****     }    
 317:vty.c         **** 
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 319:vty.c         ****     {
 320:vty.c         ****       setIpDebug(NULL, 0);
 321:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 322:vty.c         ****       return OK_SILENT;  
 323:vty.c         ****     }    
 324:vty.c         **** 
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 326:vty.c         ****     {
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 328:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 329:vty.c         ****       return OK_SILENT;  
 330:vty.c         ****     }    
 331:vty.c         **** 
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 333:vty.c         ****     {
 334:vty.c         ****       setTcpDebug(NULL, 0);
 335:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 336:vty.c         ****       return OK_SILENT;  
 337:vty.c         ****     }    
 338:vty.c         **** 
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 340:vty.c         ****     {
 341:vty.c         ****       setUdpDebug(NULL, 0);
 342:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 343:vty.c         ****       return OK_SILENT;  
 344:vty.c         ****     }    
 345:vty.c         **** 
 346:vty.c         **** 
 347:vty.c         ****   }
 348:vty.c         ****   else                   //level > 0
 349:vty.c         ****   {
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 351:vty.c         ****     {
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 353:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 354:vty.c         ****       return OK_SILENT;  
 355:vty.c         ****     }   
 356:vty.c         ****     
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 358:vty.c         ****     {
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 360:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 361:vty.c         ****       return OK_SILENT;  
 362:vty.c         ****     }
 363:vty.c         **** 
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 365:vty.c         ****     {
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 367:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 368:vty.c         ****       return OK_SILENT;  
 369:vty.c         ****     }
 370:vty.c         **** 
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 372:vty.c         ****     {
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 374:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 375:vty.c         ****       return OK_SILENT;  
 376:vty.c         ****     }
 377:vty.c         ****     
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 379:vty.c         ****     {
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 381:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 382:vty.c         ****       return OK_SILENT;  
 383:vty.c         ****     }
 384:vty.c         ****   }
 385:vty.c         ****   
 386:vty.c         ****   return SYNTAX_ERROR;
 387:vty.c         **** }
 388:vty.c         **** 
 389:vty.c         **** 
 390:vty.c         **** static cliExRes_t setTimeFunction(cmdState_t *state)
 391:vty.c         **** {
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 395:vty.c         ****   
 396:vty.c         ****   ds1305start();
 397:vty.c         **** 
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 399:vty.c         ****   uint8_t cJedn = godzina - cDzies*10;
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 402:vty.c         ****   
 403:vty.c         ****   cDzies = minuta/10;
 404:vty.c         ****   cJedn = minuta - cDzies * 10;
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 407:vty.c         ****   
 408:vty.c         ****   cDzies = sekunda/10;
 409:vty.c         ****   cJedn  = sekunda - cDzies * 10;
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 412:vty.c         ****   
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 414:vty.c         ****   return OK_SILENT;
 415:vty.c         **** }
 416:vty.c         **** 
 417:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state)
 418:vty.c         **** {
 419:vty.c         ****   if (state->argc < 4)
 420:vty.c         ****     return SYNTAX_ERROR;
 421:vty.c         ****   
 422:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 423:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 424:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 426:vty.c         ****   
 427:vty.c         ****   ipSetConfigIp(ip);
 428:vty.c         ****   return OK_SILENT;
 429:vty.c         **** }
 430:vty.c         **** 
 431:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state)
 432:vty.c         **** {
 433:vty.c         ****   if (state->argc < 5)
 434:vty.c         ****     return SYNTAX_ERROR;
 435:vty.c         ****   
 436:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) + 
 437:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 438:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) + 
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 440:vty.c         ****   udpSocket->dstIp = ip;
 441:vty.c         ****   
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 444:vty.c         ****   
 445:vty.c         ****   if (state->argc > 5)
 446:vty.c         ****   {
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 449:vty.c         ****   }
 450:vty.c         ****   return OK_SILENT;
 451:vty.c         **** }
 452:vty.c         **** 
 453:vty.c         **** 
 454:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state)
 455:vty.c         **** {
 456:vty.c         ****   if (state->argc < 1)
 457:vty.c         ****     return SYNTAX_ERROR;
 458:vty.c         ****   
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 460:vty.c         ****   
 461:vty.c         ****   ipSetConfigMask(mask);
 462:vty.c         ****   return OK_SILENT;
 463:vty.c         **** }
 464:vty.c         **** 
 465:vty.c         **** 
 466:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state)
 467:vty.c         **** {
 468:vty.c         ****   if (state->argc < 4)
 469:vty.c         ****     return SYNTAX_ERROR;
 470:vty.c         ****   
 471:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) + 
 472:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) + 
 473:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 475:vty.c         ****   ipSetConfigGw(gw);
 476:vty.c         ****   return OK_SILENT;
 477:vty.c         **** }
 478:vty.c         **** 
 479:vty.c         **** static cliExRes_t setMacAddrFunction(cmdState_t *state)
 480:vty.c         **** {
 481:vty.c         ****   if (state->argc < 6)
 482:vty.c         ****     return SYNTAX_ERROR;  
 483:vty.c         ****   
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 491:vty.c         ****   return OK_SILENT;
 492:vty.c         **** }
 493:vty.c         **** 
 494:vty.c         **** static cliExRes_t czytajAC_Function(cmdState_t *state)
 495:vty.c         **** {
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 499:vty.c         ****   return OK_SILENT;
 500:vty.c         **** }
 501:vty.c         **** 
 502:vty.c         **** static cliExRes_t helpFunction(cmdState_t *state)
 503:vty.c         **** {
 504:vty.c         ****   cmdPrintHelp(state);
 505:vty.c         ****   return OK_SILENT;
 506:vty.c         **** }
 507:vty.c         **** 
 508:vty.c         **** static cliExRes_t curtainDownFunction(cmdState_t *state)
 509:vty.c         **** {
 510:vty.c         ****   uint8_t nrRolety;
 511:vty.c         ****   uint8_t nrSterownika;
 512:vty.c         ****   uint8_t wartosc;
 513:vty.c         ****   
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 516:vty.c         ****   nrRolety &= 0x01;
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 518:vty.c         **** 
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 520:vty.c         **** 
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 523:vty.c         **** 
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 525:vty.c         ****   
 526:vty.c         ****   if (result == 0)
 527:vty.c         ****     return OK_INFORM;
 528:vty.c         ****   
 529:vty.c         ****   return ERROR_SILENT;
 530:vty.c         **** }
 531:vty.c         **** 
 532:vty.c         **** static cliExRes_t curtainUpFunction(cmdState_t *state)
 533:vty.c         **** {
 534:vty.c         ****   if (state->argc < 2)
 535:vty.c         ****     return SYNTAX_ERROR;
 536:vty.c         ****   
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 539:vty.c         ****   uint8_t wartosc = 255;
 540:vty.c         ****   if (state->argc > 2)
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 542:vty.c         **** 
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 546:vty.c         **** 
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 548:vty.c         ****   
 549:vty.c         ****   if (result == 0)
 550:vty.c         ****     return OK_INFORM;
 551:vty.c         ****   
 552:vty.c         ****   return ERROR_SILENT;
 553:vty.c         **** }
 554:vty.c         **** 
 555:vty.c         **** static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
 556:vty.c         **** {
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 560:vty.c         ****   return OK_SILENT;
 561:vty.c         **** }
 562:vty.c         **** 
 563:vty.c         **** static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
 564:vty.c         **** {
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 568:vty.c         ****   return OK_SILENT;
 569:vty.c         **** }
 570:vty.c         **** 
 571:vty.c         **** static cliExRes_t ustawPortRezystor(cmdState_t *state)
 572:vty.c         **** {
 573:vty.c         ****   if (state->argc < 1)
 574:vty.c         ****     return SYNTAX_ERROR;
 575:vty.c         **** 
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 577:vty.c         ****   
 578:vty.c         ****   MCP4150_setValue(wartosc);
 579:vty.c         ****   
 580:vty.c         ****   return OK_SILENT;
 581:vty.c         **** }
 582:vty.c         **** 
 583:vty.c         **** static cliExRes_t rpingFunction(cmdState_t *state)
 584:vty.c         **** {
 585:vty.c         ****   if (state->argc < 1)
 586:vty.c         ****     return SYNTAX_ERROR;
 587:vty.c         ****   
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 590:vty.c         ****     return OK_INFORM;
 591:vty.c         **** 
 592:vty.c         ****   state->errno = noRemoteDevice;
 593:vty.c         ****   state->err1 = nrSterownika;
 594:vty.c         ****   printErrorInfo(state);
 595:vty.c         ****   return OK_SILENT;
 596:vty.c         **** }
 597:vty.c         **** 
 598:vty.c         **** static cliExRes_t pingFunction(cmdState_t *state)
 599:vty.c         **** {
 600:vty.c         ****   if (state->argc < 4)
 601:vty.c         ****     return SYNTAX_ERROR;
 602:vty.c         ****   
 603:vty.c         ****   uint8_t ip[4];
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 608:vty.c         **** 
 609:vty.c         **** //  Ipv4Ping(*((uint32_t *)(ip)));
 610:vty.c         ****   
 611:vty.c         ****   return OK_SILENT;
 612:vty.c         **** }
 613:vty.c         **** 
 614:vty.c         **** 
 615:vty.c         **** static cliExRes_t flashExModuleFunction(cmdState_t *state)
 616:vty.c         **** {
 617:vty.c         ****   if (state->argc != 2)
 618:vty.c         ****     return SYNTAX_ERROR;
 619:vty.c         ****   
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 622:vty.c         ****   uint8_t  blad;
 623:vty.c         ****   
 624:vty.c         ****   // Sprawdzanie, czy moduł wykonawczy odpowiada
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 626:vty.c         ****   {
 627:vty.c         ****     state->errno = noRemoteDevice;
 628:vty.c         ****     printErrorInfo(state);
 629:vty.c         ****     return ERROR_INFORM;
 630:vty.c         ****   }
 631:vty.c         ****   
 632:vty.c         ****   //Sprawdzanie, czy istnieje odpowiedni plik z firmware
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 634:vty.c         ****   {
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 636:vty.c         ****     return ERROR_INFORM;
 637:vty.c         ****   }
 638:vty.c         ****   
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 640:vty.c         **** 
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 642:vty.c         ****   
 643:vty.c         ****   if (blad != 0)
 644:vty.c         ****     return ERROR_INFORM;
 645:vty.c         **** 
 646:vty.c         ****   return OK_SILENT;
 647:vty.c         **** }
 648:vty.c         **** 
 649:vty.c         **** static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
 650:vty.c         **** {
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 653:vty.c         ****   {
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 655:vty.c         ****     return ERROR_INFORM;
 656:vty.c         ****   }
 657:vty.c         ****   return OK_SILENT;
 658:vty.c         **** }
 659:vty.c         **** 
 660:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
 661:vty.c         **** {
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 664:vty.c         ****   {
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 666:vty.c         ****     return ERROR_INFORM;
 667:vty.c         ****   }
 668:vty.c         ****    
 669:vty.c         ****   uint8_t  i = 25;
 670:vty.c         **** 
 671:vty.c         ****   uint8_t  temp1;
 672:vty.c         **** //  uint8_t  temp2;
 673:vty.c         **** 
 674:vty.c         ****   uint8_t  c;
 675:vty.c         ****   uint8_t  liczbaProb;
 676:vty.c         ****   uint8_t  *zapPtr;
 677:vty.c         ****   uint8_t  *zapPtrKopia;
 678:vty.c         ****  
 679:vty.c         ****   uint16_t crcLokalne;
 680:vty.c         ****   uint8_t nrBloku;
 681:vty.c         **** 
 682:vty.c         ****   uint8_t nrBlokuZdalny;
 683:vty.c         ****   uint8_t nrBlokuZdalnyNeg;
 684:vty.c         **** 
 685:vty.c         ****   uint8_t crcHi;
 686:vty.c         ****   uint8_t crcLo;
 687:vty.c         **** 
 688:vty.c         ****   state->err1=0;
 689:vty.c         ****   state->err2=0;
 690:vty.c         ****   liczbaProb = 20;
 691:vty.c         ****   for ( ; ; )
 692:vty.c         ****   {
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 694:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 695:vty.c         **** 
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 697:vty.c         ****       if (c == SOH)
 698:vty.c         ****         break;                                                   //Rozpoczynamy transmisje
 699:vty.c         **** 
 700:vty.c         ****     liczbaProb--;
 701:vty.c         ****     if (liczbaProb == 0)
 702:vty.c         ****     {
 703:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 704:vty.c         ****       state->errno = (uint8_t)(AllOK);
 705:vty.c         ****       return ERROR_INFORM;
 706:vty.c         ****     }
 707:vty.c         ****   }
 708:vty.c         ****   
 709:vty.c         ****   nrBloku = 1;
 710:vty.c         ****   liczbaProb = 10;
 711:vty.c         **** 
 712:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 713:vty.c         ****   zapPtrKopia     = zapPtr;
 714:vty.c         ****   for ( ; ; )
 715:vty.c         ****   {
 716:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 717:vty.c         ****     {
 718:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 719:vty.c         ****       break; 
 720:vty.c         ****     }
 721:vty.c         ****     
 722:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 723:vty.c         ****     {
 724:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 725:vty.c         ****       break; 
 726:vty.c         ****     }
 727:vty.c         ****   
 728:vty.c         ****     //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
 729:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 730:vty.c         ****     if (nrBlokuZdalny != c)
 731:vty.c         ****     {
 732:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 733:vty.c         ****       state->err1 = nrBlokuZdalny;
 734:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 735:vty.c         ****       break;
 736:vty.c         ****     }
 737:vty.c         ****     
 738:vty.c         ****     //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od b
 739:vty.c         ****     c = nrBloku-1;
 740:vty.c         ****     if (nrBlokuZdalny == c)
 741:vty.c         ****     {
 742:vty.c         ****       nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
 743:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 744:vty.c         ****       zapPtrKopia = zapPtr;
 745:vty.c         ****     }
 746:vty.c         ****     
 747:vty.c         ****     //2 Sprawdzanie, czy pasuje numer bloku
 748:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 749:vty.c         ****     {
 750:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 751:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 752:vty.c         ****       state->err2 = nrBloku;
 753:vty.c         ****       break;
 754:vty.c         ****     }
 755:vty.c         ****         
 756:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 757:vty.c         ****     {
 758:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 759:vty.c         ****         *(zapPtr++) = c;
 760:vty.c         ****       else
 761:vty.c         ****       {
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 763:vty.c         ****         break;
 764:vty.c         ****       }
 765:vty.c         ****     }
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 767:vty.c         ****     {
 768:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 769:vty.c         ****         state->err1 = 2;
 770:vty.c         ****         break;      
 771:vty.c         ****     }
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 773:vty.c         ****     {
 774:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 775:vty.c         ****         state->err1 = 1;
 776:vty.c         ****         break;      
 777:vty.c         ****     }
 778:vty.c         **** 
 779:vty.c         ****     //3 Zerowanie CRC
 780:vty.c         ****     crcLokalne=0; 
 781:vty.c         ****     
 782:vty.c         ****     //4 Obliczanie CRC
 783:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 784:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 785:vty.c         ****      
 786:vty.c         ****     //5 Srawdzanie CRC
 787:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 788:vty.c         ****     {
 789:vty.c         ****       liczbaProb = 10;
 790:vty.c         ****       uartVtySendByte(ACK);      
 791:vty.c         ****     }
 792:vty.c         ****     else
 793:vty.c         ****     {
 794:vty.c         ****       liczbaProb--;
 795:vty.c         ****       nrBloku--;
 796:vty.c         ****       uartVtySendByte(NAK);   
 797:vty.c         ****     }
 798:vty.c         ****     
 799:vty.c         ****     if (liczbaProb == 0)
 800:vty.c         ****     {
 801:vty.c         ****       state->err1 = nrBlokuZdalny;
 802:vty.c         ****       state->err2 = nrBloku;
 803:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 804:vty.c         ****       break; 
 805:vty.c         ****     }
 806:vty.c         **** 
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 808:vty.c         ****     {
 809:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 810:vty.c         ****       break;
 811:vty.c         ****     }
 812:vty.c         ****     
 813:vty.c         ****     if (temp1 == SOH)
 814:vty.c         ****     {
 815:vty.c         ****       nrBloku++;
 816:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 817:vty.c         ****       zapPtrKopia = zapPtr;
 818:vty.c         ****       state->errno = (uint8_t)(AllOK);
 819:vty.c         ****       continue;
 820:vty.c         ****     }
 821:vty.c         **** 
 822:vty.c         ****     if (temp1 == CAN)
 823:vty.c         ****     {
 824:vty.c         ****       state->err1 = nrBloku;
 825:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 826:vty.c         ****       break;
 827:vty.c         ****     }
 828:vty.c         ****     if (temp1 == EOT)
 829:vty.c         ****     {
 830:vty.c         ****       uartVtySendByte(NAK);
 831:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 832:vty.c         ****       {
 833:vty.c         ****         if (temp1 == EOT)
 834:vty.c         ****           uartVtySendByte(ACK);  
 835:vty.c         ****       }
 836:vty.c         ****       state->errno = (uint8_t)(AllOK);
 837:vty.c         ****       break;
 838:vty.c         ****     }
 839:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 840:vty.c         ****     state->err1 = temp1;
 841:vty.c         ****     break;
 842:vty.c         ****   }
 843:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 844:vty.c         ****   return OK_SILENT;
 845:vty.c         **** }
 846:vty.c         **** 
 847:vty.c         **** static cliExRes_t eraseRamFileFunction(cmdState_t *state)
 848:vty.c         **** {
 849:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 850:vty.c         ****     return OK_INFORM;
 851:vty.c         **** 
 852:vty.c         ****   printErrorInfo(state);
 853:vty.c         ****   return ERROR_INFORM;
 854:vty.c         **** }
 855:vty.c         **** 
 856:vty.c         **** static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
 857:vty.c         **** {
 858:vty.c         ****   if (state->argc != 1)
 859:vty.c         ****     return SYNTAX_ERROR;
 860:vty.c         **** 
 861:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 862:vty.c         ****   {
 863:vty.c         ****     return OK_INFORM;
 864:vty.c         ****   }
 865:vty.c         ****   printErrorInfo(state);
 866:vty.c         ****   return ERROR_INFORM;
 867:vty.c         **** }
 868:vty.c         **** 
 869:vty.c         **** static cliExRes_t writeRamFileFunction(cmdState_t *state)
 870:vty.c         **** {
 871:vty.c         ****   ramDyskDir(state->myStdInOut);
 872:vty.c         ****   return OK_SILENT;
 873:vty.c         **** }
 874:vty.c         **** 
 875:vty.c         **** static cliExRes_t editRamFileFunction(cmdState_t *state)
 876:vty.c         **** {
 877:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 878:vty.c         ****   {
 879:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 880:vty.c         ****     return ERROR_INFORM;
 881:vty.c         ****   }
 882:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 883:vty.c         ****   uint8_t znak = 0;
 884:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 885:vty.c         ****   while(1)
 886:vty.c         ****   {
 887:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 888:vty.c         ****       continue;
 889:vty.c         **** 
 890:vty.c         ****     if (znak == 0x03)                                       // ^C
 891:vty.c         ****       break;
 892:vty.c         **** 
 893:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 894:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 895:vty.c         ****   }
 896:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 897:vty.c         ****   return OK_SILENT;
 898:vty.c         **** }
 899:vty.c         **** 
 900:vty.c         **** static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
 901:vty.c         **** {
 902:vty.c         ****   uint8_t rezultat;
 903:vty.c         ****   uint8_t znak = ' ';
 904:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 905:vty.c         ****   {
 906:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 907:vty.c         ****     return ERROR_INFORM;
 908:vty.c         ****   }
 909:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 910:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 911:vty.c         ****   while (rezultat == 0)
 912:vty.c         ****   {
 913:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 914:vty.c         ****     
 915:vty.c         ****     uartVtySendByte(znak);
 916:vty.c         ****     if (znak == '\r')
 917:vty.c         ****       uartVtySendByte('\n');
 918:vty.c         ****   }
 919:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 920:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 921:vty.c         ****   return OK_SILENT;
 922:vty.c         **** }
 923:vty.c         **** 
 924:vty.c         **** static cliExRes_t saveConfigFunction(cmdState_t *state)
 925:vty.c         **** {
 402               	.LM15:
 403               	.LFBB4:
 404               	/* prologue: function */
 405               	/* frame size = 0 */
 926:vty.c         ****   state = NULL;
 927:vty.c         ****   saveConfiguration();
 407               	.LM16:
 408 005c 0E94 0000 		call saveConfiguration
 928:vty.c         ****   return OK_SILENT;
 929:vty.c         **** }
 410               	.LM17:
 411 0060 80E0      		ldi r24,lo8(0)
 412 0062 90E0      		ldi r25,hi8(0)
 413               	/* epilogue start */
 414 0064 0895      		ret
 416               	.Lscope4:
 418               		.stabd	78,0,0
 422               	setMacAddrFunction:
 423               		.stabd	46,0,0
 480:vty.c         **** {
 425               	.LM18:
 426               	.LFBB5:
 427 0066 CF93      		push r28
 428 0068 DF93      		push r29
 429               	/* prologue: function */
 430               	/* frame size = 0 */
 431 006a EC01      		movw r28,r24
 481:vty.c         ****   if (state->argc < 6)
 433               	.LM19:
 434 006c 898D      		ldd r24,Y+25
 435 006e 8630      		cpi r24,lo8(6)
 436 0070 00F4      		brsh .L15
 437 0072 22E0      		ldi r18,lo8(2)
 438 0074 30E0      		ldi r19,hi8(2)
 439 0076 00C0      		rjmp .L16
 440               	.L15:
 484:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 442               	.LM20:
 443 0078 81E0      		ldi r24,lo8(1)
 444 007a BE01      		movw r22,r28
 445 007c 0E94 0000 		call cmdlineGetArgHex
 446 0080 6093 0000 		sts nicState+2,r22
 485:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 448               	.LM21:
 449 0084 82E0      		ldi r24,lo8(2)
 450 0086 BE01      		movw r22,r28
 451 0088 0E94 0000 		call cmdlineGetArgHex
 452 008c 6093 0000 		sts nicState+3,r22
 486:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 454               	.LM22:
 455 0090 83E0      		ldi r24,lo8(3)
 456 0092 BE01      		movw r22,r28
 457 0094 0E94 0000 		call cmdlineGetArgHex
 458 0098 6093 0000 		sts nicState+4,r22
 487:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 460               	.LM23:
 461 009c 84E0      		ldi r24,lo8(4)
 462 009e BE01      		movw r22,r28
 463 00a0 0E94 0000 		call cmdlineGetArgHex
 464 00a4 6093 0000 		sts nicState+5,r22
 488:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 466               	.LM24:
 467 00a8 85E0      		ldi r24,lo8(5)
 468 00aa BE01      		movw r22,r28
 469 00ac 0E94 0000 		call cmdlineGetArgHex
 470 00b0 6093 0000 		sts nicState+6,r22
 489:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 472               	.LM25:
 473 00b4 86E0      		ldi r24,lo8(6)
 474 00b6 BE01      		movw r22,r28
 475 00b8 0E94 0000 		call cmdlineGetArgHex
 476 00bc 6093 0000 		sts nicState+7,r22
 490:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 478               	.LM26:
 479 00c0 80E0      		ldi r24,lo8(nicState+2)
 480 00c2 90E0      		ldi r25,hi8(nicState+2)
 481 00c4 0E94 0000 		call nicSetMacAddress
 482 00c8 20E0      		ldi r18,lo8(0)
 483 00ca 30E0      		ldi r19,hi8(0)
 484               	.L16:
 492:vty.c         **** }
 486               	.LM27:
 487 00cc C901      		movw r24,r18
 488               	/* epilogue start */
 489 00ce DF91      		pop r29
 490 00d0 CF91      		pop r28
 491 00d2 0895      		ret
 493               	.Lscope5:
 495               		.stabd	78,0,0
 499               	pingFunction:
 500               		.stabd	46,0,0
 599:vty.c         **** {
 502               	.LM28:
 503               	.LFBB6:
 504 00d4 CF93      		push r28
 505 00d6 DF93      		push r29
 506               	/* prologue: function */
 507               	/* frame size = 0 */
 508 00d8 EC01      		movw r28,r24
 600:vty.c         ****   if (state->argc < 4)
 510               	.LM29:
 511 00da 898D      		ldd r24,Y+25
 512 00dc 8430      		cpi r24,lo8(4)
 513 00de 00F4      		brsh .L19
 514 00e0 22E0      		ldi r18,lo8(2)
 515 00e2 30E0      		ldi r19,hi8(2)
 516 00e4 00C0      		rjmp .L20
 517               	.L19:
 604:vty.c         ****   ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 519               	.LM30:
 520 00e6 81E0      		ldi r24,lo8(1)
 521 00e8 BE01      		movw r22,r28
 522 00ea 0E94 0000 		call cmdlineGetArgInt
 605:vty.c         ****   ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 524               	.LM31:
 525 00ee 82E0      		ldi r24,lo8(2)
 526 00f0 BE01      		movw r22,r28
 527 00f2 0E94 0000 		call cmdlineGetArgInt
 606:vty.c         ****   ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 529               	.LM32:
 530 00f6 83E0      		ldi r24,lo8(3)
 531 00f8 BE01      		movw r22,r28
 532 00fa 0E94 0000 		call cmdlineGetArgInt
 607:vty.c         ****   ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 534               	.LM33:
 535 00fe 84E0      		ldi r24,lo8(4)
 536 0100 BE01      		movw r22,r28
 537 0102 0E94 0000 		call cmdlineGetArgInt
 538 0106 20E0      		ldi r18,lo8(0)
 539 0108 30E0      		ldi r19,hi8(0)
 540               	.L20:
 612:vty.c         **** }
 542               	.LM34:
 543 010a C901      		movw r24,r18
 544               	/* epilogue start */
 545 010c DF91      		pop r29
 546 010e CF91      		pop r28
 547 0110 0895      		ret
 549               	.Lscope6:
 551               		.stabd	78,0,0
 555               	setUdpFunction:
 556               		.stabd	46,0,0
 432:vty.c         **** {
 558               	.LM35:
 559               	.LFBB7:
 560 0112 6F92      		push r6
 561 0114 7F92      		push r7
 562 0116 8F92      		push r8
 563 0118 9F92      		push r9
 564 011a AF92      		push r10
 565 011c BF92      		push r11
 566 011e CF92      		push r12
 567 0120 DF92      		push r13
 568 0122 EF92      		push r14
 569 0124 FF92      		push r15
 570 0126 0F93      		push r16
 571 0128 1F93      		push r17
 572 012a CF93      		push r28
 573 012c DF93      		push r29
 574               	/* prologue: function */
 575               	/* frame size = 0 */
 576 012e EC01      		movw r28,r24
 433:vty.c         ****   if (state->argc < 5)
 578               	.LM36:
 579 0130 898D      		ldd r24,Y+25
 580 0132 8530      		cpi r24,lo8(5)
 581 0134 00F4      		brsh .L23
 582 0136 22E0      		ldi r18,lo8(2)
 583 0138 30E0      		ldi r19,hi8(2)
 584 013a 00C0      		rjmp .L24
 585               	.L23:
 439:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 587               	.LM37:
 588 013c 81E0      		ldi r24,lo8(1)
 589 013e BE01      		movw r22,r28
 590 0140 0E94 0000 		call cmdlineGetArgInt
 591 0144 3B01      		movw r6,r22
 592 0146 4C01      		movw r8,r24
 593 0148 82E0      		ldi r24,lo8(2)
 594 014a BE01      		movw r22,r28
 595 014c 0E94 0000 		call cmdlineGetArgInt
 596 0150 7B01      		movw r14,r22
 597 0152 8C01      		movw r16,r24
 598 0154 83E0      		ldi r24,lo8(3)
 599 0156 BE01      		movw r22,r28
 600 0158 0E94 0000 		call cmdlineGetArgInt
 601 015c 5B01      		movw r10,r22
 602 015e 6C01      		movw r12,r24
 603 0160 84E0      		ldi r24,lo8(4)
 604 0162 BE01      		movw r22,r28
 605 0164 0E94 0000 		call cmdlineGetArgInt
 440:vty.c         ****   udpSocket->dstIp = ip;
 607               	.LM38:
 608 0168 E091 0000 		lds r30,udpSocket
 609 016c F091 0000 		lds r31,(udpSocket)+1
 610 0170 102F      		mov r17,r16
 611 0172 0F2D      		mov r16,r15
 612 0174 FE2C      		mov r15,r14
 613 0176 EE24      		clr r14
 614 0178 6501      		movw r12,r10
 615 017a BB24      		clr r11
 616 017c AA24      		clr r10
 617 017e EA0C      		add r14,r10
 618 0180 FB1C      		adc r15,r11
 619 0182 0C1D      		adc r16,r12
 620 0184 1D1D      		adc r17,r13
 621 0186 E60C      		add r14,r6
 622 0188 F71C      		adc r15,r7
 623 018a 081D      		adc r16,r8
 624 018c 191D      		adc r17,r9
 625 018e 962F      		mov r25,r22
 626 0190 8827      		clr r24
 627 0192 7727      		clr r23
 628 0194 6627      		clr r22
 629 0196 E60E      		add r14,r22
 630 0198 F71E      		adc r15,r23
 631 019a 081F      		adc r16,r24
 632 019c 191F      		adc r17,r25
 633 019e E682      		std Z+6,r14
 634 01a0 F782      		std Z+7,r15
 635 01a2 0087      		std Z+8,r16
 636 01a4 1187      		std Z+9,r17
 442:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 638               	.LM39:
 639 01a6 85E0      		ldi r24,lo8(5)
 640 01a8 BE01      		movw r22,r28
 641 01aa 0E94 0000 		call cmdlineGetArgInt
 642 01ae DC01      		movw r26,r24
 643 01b0 CB01      		movw r24,r22
 443:vty.c         ****   udpSocket->srcPort = htons(port);
 645               	.LM40:
 646 01b2 0091 0000 		lds r16,udpSocket
 647 01b6 1091 0000 		lds r17,(udpSocket)+1
 648 01ba 0E94 0000 		call htons
 649 01be F801      		movw r30,r16
 650 01c0 9583      		std Z+5,r25
 651 01c2 8483      		std Z+4,r24
 445:vty.c         ****   if (state->argc > 5)
 653               	.LM41:
 654 01c4 898D      		ldd r24,Y+25
 655 01c6 8630      		cpi r24,lo8(6)
 656 01c8 00F0      		brlo .L27
 657               	.L25:
 447:vty.c         ****     port = cmdlineGetArgInt(6, state);
 659               	.LM42:
 660 01ca 86E0      		ldi r24,lo8(6)
 661 01cc BE01      		movw r22,r28
 662 01ce 0E94 0000 		call cmdlineGetArgInt
 663 01d2 DC01      		movw r26,r24
 664 01d4 CB01      		movw r24,r22
 448:vty.c         ****     udpSocket->dstPort = htons(port);    
 666               	.LM43:
 667 01d6 0091 0000 		lds r16,udpSocket
 668 01da 1091 0000 		lds r17,(udpSocket)+1
 669 01de 0E94 0000 		call htons
 670 01e2 F801      		movw r30,r16
 671 01e4 9383      		std Z+3,r25
 672 01e6 8283      		std Z+2,r24
 673               	.L27:
 674 01e8 20E0      		ldi r18,lo8(0)
 675 01ea 30E0      		ldi r19,hi8(0)
 676               	.L24:
 451:vty.c         **** }
 678               	.LM44:
 679 01ec C901      		movw r24,r18
 680               	/* epilogue start */
 681 01ee DF91      		pop r29
 682 01f0 CF91      		pop r28
 683 01f2 1F91      		pop r17
 684 01f4 0F91      		pop r16
 685 01f6 FF90      		pop r15
 686 01f8 EF90      		pop r14
 687 01fa DF90      		pop r13
 688 01fc CF90      		pop r12
 689 01fe BF90      		pop r11
 690 0200 AF90      		pop r10
 691 0202 9F90      		pop r9
 692 0204 8F90      		pop r8
 693 0206 7F90      		pop r7
 694 0208 6F90      		pop r6
 695 020a 0895      		ret
 697               	.Lscope7:
 699               		.stabd	78,0,0
 703               	setIpGwFunction:
 704               		.stabd	46,0,0
 467:vty.c         **** {
 706               	.LM45:
 707               	.LFBB8:
 708 020c 6F92      		push r6
 709 020e 7F92      		push r7
 710 0210 8F92      		push r8
 711 0212 9F92      		push r9
 712 0214 AF92      		push r10
 713 0216 BF92      		push r11
 714 0218 CF92      		push r12
 715 021a DF92      		push r13
 716 021c EF92      		push r14
 717 021e FF92      		push r15
 718 0220 0F93      		push r16
 719 0222 1F93      		push r17
 720 0224 CF93      		push r28
 721 0226 DF93      		push r29
 722               	/* prologue: function */
 723               	/* frame size = 0 */
 724 0228 EC01      		movw r28,r24
 468:vty.c         ****   if (state->argc < 4)
 726               	.LM46:
 727 022a 898D      		ldd r24,Y+25
 728 022c 8430      		cpi r24,lo8(4)
 729 022e 00F4      		brsh .L29
 730 0230 22E0      		ldi r18,lo8(2)
 731 0232 30E0      		ldi r19,hi8(2)
 732 0234 00C0      		rjmp .L30
 733               	.L29:
 474:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 735               	.LM47:
 736 0236 81E0      		ldi r24,lo8(1)
 737 0238 BE01      		movw r22,r28
 738 023a 0E94 0000 		call cmdlineGetArgInt
 739 023e 3B01      		movw r6,r22
 740 0240 4C01      		movw r8,r24
 741 0242 82E0      		ldi r24,lo8(2)
 742 0244 BE01      		movw r22,r28
 743 0246 0E94 0000 		call cmdlineGetArgInt
 744 024a 7B01      		movw r14,r22
 745 024c 8C01      		movw r16,r24
 746 024e 83E0      		ldi r24,lo8(3)
 747 0250 BE01      		movw r22,r28
 748 0252 0E94 0000 		call cmdlineGetArgInt
 749 0256 5B01      		movw r10,r22
 750 0258 6C01      		movw r12,r24
 751 025a 84E0      		ldi r24,lo8(4)
 752 025c BE01      		movw r22,r28
 753 025e 0E94 0000 		call cmdlineGetArgInt
 475:vty.c         ****   ipSetConfigGw(gw);
 755               	.LM48:
 756 0262 102F      		mov r17,r16
 757 0264 0F2D      		mov r16,r15
 758 0266 FE2C      		mov r15,r14
 759 0268 EE24      		clr r14
 760 026a 6501      		movw r12,r10
 761 026c BB24      		clr r11
 762 026e AA24      		clr r10
 763 0270 EA0C      		add r14,r10
 764 0272 FB1C      		adc r15,r11
 765 0274 0C1D      		adc r16,r12
 766 0276 1D1D      		adc r17,r13
 767 0278 E60C      		add r14,r6
 768 027a F71C      		adc r15,r7
 769 027c 081D      		adc r16,r8
 770 027e 191D      		adc r17,r9
 771 0280 962F      		mov r25,r22
 772 0282 8827      		clr r24
 773 0284 7727      		clr r23
 774 0286 6627      		clr r22
 775 0288 E60E      		add r14,r22
 776 028a F71E      		adc r15,r23
 777 028c 081F      		adc r16,r24
 778 028e 191F      		adc r17,r25
 779 0290 C801      		movw r24,r16
 780 0292 B701      		movw r22,r14
 781 0294 0E94 0000 		call ipSetConfigGw
 782 0298 20E0      		ldi r18,lo8(0)
 783 029a 30E0      		ldi r19,hi8(0)
 784               	.L30:
 477:vty.c         **** }
 786               	.LM49:
 787 029c C901      		movw r24,r18
 788               	/* epilogue start */
 789 029e DF91      		pop r29
 790 02a0 CF91      		pop r28
 791 02a2 1F91      		pop r17
 792 02a4 0F91      		pop r16
 793 02a6 FF90      		pop r15
 794 02a8 EF90      		pop r14
 795 02aa DF90      		pop r13
 796 02ac CF90      		pop r12
 797 02ae BF90      		pop r11
 798 02b0 AF90      		pop r10
 799 02b2 9F90      		pop r9
 800 02b4 8F90      		pop r8
 801 02b6 7F90      		pop r7
 802 02b8 6F90      		pop r6
 803 02ba 0895      		ret
 805               	.Lscope8:
 807               		.stabd	78,0,0
 811               	setIpMaskFunction:
 812               		.stabd	46,0,0
 455:vty.c         **** {
 814               	.LM50:
 815               	.LFBB9:
 816               	/* prologue: function */
 817               	/* frame size = 0 */
 818 02bc FC01      		movw r30,r24
 456:vty.c         ****   if (state->argc < 1)
 820               	.LM51:
 821 02be 818D      		ldd r24,Z+25
 822 02c0 8823      		tst r24
 823 02c2 01F4      		brne .L33
 824 02c4 22E0      		ldi r18,lo8(2)
 825 02c6 30E0      		ldi r19,hi8(2)
 826 02c8 00C0      		rjmp .L34
 827               	.L33:
 459:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 829               	.LM52:
 830 02ca 81E0      		ldi r24,lo8(1)
 831 02cc BF01      		movw r22,r30
 832 02ce 0E94 0000 		call cmdlineGetArgInt
 461:vty.c         ****   ipSetConfigMask(mask);
 834               	.LM53:
 835 02d2 20E2      		ldi r18,lo8(32)
 836 02d4 30E0      		ldi r19,hi8(32)
 837 02d6 261B      		sub r18,r22
 838 02d8 370B      		sbc r19,r23
 839 02da 6FEF      		ldi r22,lo8(-1)
 840 02dc 7FEF      		ldi r23,hi8(-1)
 841 02de 8FEF      		ldi r24,hlo8(-1)
 842 02e0 9FEF      		ldi r25,hhi8(-1)
 843 02e2 00C0      		rjmp 2f
 844 02e4 9695      	1:	lsr r25
 845 02e6 8795      		ror r24
 846 02e8 7795      		ror r23
 847 02ea 6795      		ror r22
 848 02ec 2A95      	2:	dec r18
 849 02ee 02F4      		brpl 1b
 850 02f0 0E94 0000 		call ipSetConfigMask
 851 02f4 20E0      		ldi r18,lo8(0)
 852 02f6 30E0      		ldi r19,hi8(0)
 853               	.L34:
 463:vty.c         **** }
 855               	.LM54:
 856 02f8 C901      		movw r24,r18
 857               	/* epilogue start */
 858 02fa 0895      		ret
 860               	.Lscope9:
 862               		.stabd	78,0,0
 866               	setIpFunction:
 867               		.stabd	46,0,0
 418:vty.c         **** {
 869               	.LM55:
 870               	.LFBB10:
 871 02fc 6F92      		push r6
 872 02fe 7F92      		push r7
 873 0300 8F92      		push r8
 874 0302 9F92      		push r9
 875 0304 AF92      		push r10
 876 0306 BF92      		push r11
 877 0308 CF92      		push r12
 878 030a DF92      		push r13
 879 030c EF92      		push r14
 880 030e FF92      		push r15
 881 0310 0F93      		push r16
 882 0312 1F93      		push r17
 883 0314 CF93      		push r28
 884 0316 DF93      		push r29
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887 0318 EC01      		movw r28,r24
 419:vty.c         ****   if (state->argc < 4)
 889               	.LM56:
 890 031a 898D      		ldd r24,Y+25
 891 031c 8430      		cpi r24,lo8(4)
 892 031e 00F4      		brsh .L37
 893 0320 22E0      		ldi r18,lo8(2)
 894 0322 30E0      		ldi r19,hi8(2)
 895 0324 00C0      		rjmp .L38
 896               	.L37:
 425:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24); 
 898               	.LM57:
 899 0326 81E0      		ldi r24,lo8(1)
 900 0328 BE01      		movw r22,r28
 901 032a 0E94 0000 		call cmdlineGetArgInt
 902 032e 3B01      		movw r6,r22
 903 0330 4C01      		movw r8,r24
 904 0332 82E0      		ldi r24,lo8(2)
 905 0334 BE01      		movw r22,r28
 906 0336 0E94 0000 		call cmdlineGetArgInt
 907 033a 7B01      		movw r14,r22
 908 033c 8C01      		movw r16,r24
 909 033e 83E0      		ldi r24,lo8(3)
 910 0340 BE01      		movw r22,r28
 911 0342 0E94 0000 		call cmdlineGetArgInt
 912 0346 5B01      		movw r10,r22
 913 0348 6C01      		movw r12,r24
 914 034a 84E0      		ldi r24,lo8(4)
 915 034c BE01      		movw r22,r28
 916 034e 0E94 0000 		call cmdlineGetArgInt
 427:vty.c         ****   ipSetConfigIp(ip);
 918               	.LM58:
 919 0352 102F      		mov r17,r16
 920 0354 0F2D      		mov r16,r15
 921 0356 FE2C      		mov r15,r14
 922 0358 EE24      		clr r14
 923 035a 6501      		movw r12,r10
 924 035c BB24      		clr r11
 925 035e AA24      		clr r10
 926 0360 EA0C      		add r14,r10
 927 0362 FB1C      		adc r15,r11
 928 0364 0C1D      		adc r16,r12
 929 0366 1D1D      		adc r17,r13
 930 0368 E60C      		add r14,r6
 931 036a F71C      		adc r15,r7
 932 036c 081D      		adc r16,r8
 933 036e 191D      		adc r17,r9
 934 0370 962F      		mov r25,r22
 935 0372 8827      		clr r24
 936 0374 7727      		clr r23
 937 0376 6627      		clr r22
 938 0378 E60E      		add r14,r22
 939 037a F71E      		adc r15,r23
 940 037c 081F      		adc r16,r24
 941 037e 191F      		adc r17,r25
 942 0380 C801      		movw r24,r16
 943 0382 B701      		movw r22,r14
 944 0384 0E94 0000 		call ipSetConfigIp
 945 0388 20E0      		ldi r18,lo8(0)
 946 038a 30E0      		ldi r19,hi8(0)
 947               	.L38:
 429:vty.c         **** }
 949               	.LM59:
 950 038c C901      		movw r24,r18
 951               	/* epilogue start */
 952 038e DF91      		pop r29
 953 0390 CF91      		pop r28
 954 0392 1F91      		pop r17
 955 0394 0F91      		pop r16
 956 0396 FF90      		pop r15
 957 0398 EF90      		pop r14
 958 039a DF90      		pop r13
 959 039c CF90      		pop r12
 960 039e BF90      		pop r11
 961 03a0 AF90      		pop r10
 962 03a2 9F90      		pop r9
 963 03a4 8F90      		pop r8
 964 03a6 7F90      		pop r7
 965 03a8 6F90      		pop r6
 966 03aa 0895      		ret
 968               	.Lscope10:
 970               		.stabd	78,0,0
 974               	czytajAC_Function:
 975               		.stabd	46,0,0
 495:vty.c         **** {
 977               	.LM60:
 978               	.LFBB11:
 979 03ac FF92      		push r15
 980 03ae 0F93      		push r16
 981 03b0 1F93      		push r17
 982               	/* prologue: function */
 983               	/* frame size = 0 */
 984 03b2 8C01      		movw r16,r24
 496:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 986               	.LM61:
 987 03b4 81E0      		ldi r24,lo8(1)
 988 03b6 B801      		movw r22,r16
 989 03b8 0E94 0000 		call cmdlineGetArgInt
 990 03bc F62E      		mov r15,r22
 497:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 992               	.LM62:
 993 03be 862F      		mov r24,r22
 994 03c0 0E94 0000 		call MCP3008_getSampleSingle
 498:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);  
 996               	.LM63:
 997 03c4 2DB7      		in r18,__SP_L__
 998 03c6 3EB7      		in r19,__SP_H__
 999 03c8 2850      		subi r18,lo8(-(-8))
 1000 03ca 3040      		sbci r19,hi8(-(-8))
 1001 03cc 0FB6      		in __tmp_reg__,__SREG__
 1002 03ce F894      		cli
 1003 03d0 3EBF      		out __SP_H__,r19
 1004 03d2 0FBE      		out __SREG__,__tmp_reg__
 1005 03d4 2DBF      		out __SP_L__,r18
 1006 03d6 EDB7      		in r30,__SP_L__
 1007 03d8 FEB7      		in r31,__SP_H__
 1008 03da 3196      		adiw r30,1
 1009 03dc D801      		movw r26,r16
 1010 03de 5A96      		adiw r26,26
 1011 03e0 2D91      		ld r18,X+
 1012 03e2 3C91      		ld r19,X
 1013 03e4 5B97      		sbiw r26,26+1
 1014 03e6 ADB7      		in r26,__SP_L__
 1015 03e8 BEB7      		in r27,__SP_H__
 1016 03ea 1296      		adiw r26,1+1
 1017 03ec 3C93      		st X,r19
 1018 03ee 2E93      		st -X,r18
 1019 03f0 1197      		sbiw r26,1
 1020 03f2 20E0      		ldi r18,lo8(__c.3542)
 1021 03f4 30E0      		ldi r19,hi8(__c.3542)
 1022 03f6 3383      		std Z+3,r19
 1023 03f8 2283      		std Z+2,r18
 1024 03fa F482      		std Z+4,r15
 1025 03fc 1582      		std Z+5,__zero_reg__
 1026 03fe 9783      		std Z+7,r25
 1027 0400 8683      		std Z+6,r24
 1028 0402 0E94 0000 		call fprintf_P
 1029 0406 2DB7      		in r18,__SP_L__
 1030 0408 3EB7      		in r19,__SP_H__
 1031 040a 285F      		subi r18,lo8(-(8))
 1032 040c 3F4F      		sbci r19,hi8(-(8))
 1033 040e 0FB6      		in __tmp_reg__,__SREG__
 1034 0410 F894      		cli
 1035 0412 3EBF      		out __SP_H__,r19
 1036 0414 0FBE      		out __SREG__,__tmp_reg__
 1037 0416 2DBF      		out __SP_L__,r18
 500:vty.c         **** }
 1039               	.LM64:
 1040 0418 80E0      		ldi r24,lo8(0)
 1041 041a 90E0      		ldi r25,hi8(0)
 1042               	/* epilogue start */
 1043 041c 1F91      		pop r17
 1044 041e 0F91      		pop r16
 1045 0420 FF90      		pop r15
 1046 0422 0895      		ret
 1048               	.Lscope11:
 1050               		.stabd	78,0,0
 1053               	.global	printErrorInfo
 1055               	printErrorInfo:
 1056               		.stabd	46,0,0
 165:vty.c         **** {
 1058               	.LM65:
 1059               	.LFBB12:
 1060 0424 CF93      		push r28
 1061 0426 DF93      		push r29
 1062               	/* prologue: function */
 1063               	/* frame size = 0 */
 1064 0428 EC01      		movw r28,r24
 166:vty.c         ****   if (state->errno != 0)
 1066               	.LM66:
 1067 042a 8C8D      		ldd r24,Y+28
 1068 042c 8823      		tst r24
 1069 042e 01F0      		breq .L43
 1070               	.LBB5:
 168:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 1072               	.LM67:
 1073 0430 E82F      		mov r30,r24
 1074 0432 F0E0      		ldi r31,lo8(0)
 1075 0434 EE0F      		lsl r30
 1076 0436 FF1F      		rol r31
 1077 0438 E050      		subi r30,lo8(-(errorStrings))
 1078 043a F040      		sbci r31,hi8(-(errorStrings))
 1079               	/* #APP */
 1080               	 ;  168 "vty.c" 1
 1081 043c 2591      		lpm r18, Z+
 1082 043e 3491      		lpm r19, Z
 1083               		
 1084               	 ;  0 "" 2
 1085               	/* #NOAPP */
 1086               	.LBE5:
 1087 0440 8DB7      		in r24,__SP_L__
 1088 0442 9EB7      		in r25,__SP_H__
 1089 0444 0897      		sbiw r24,8
 1090 0446 0FB6      		in __tmp_reg__,__SREG__
 1091 0448 F894      		cli
 1092 044a 9EBF      		out __SP_H__,r25
 1093 044c 0FBE      		out __SREG__,__tmp_reg__
 1094 044e 8DBF      		out __SP_L__,r24
 1095 0450 EDB7      		in r30,__SP_L__
 1096 0452 FEB7      		in r31,__SP_H__
 1097 0454 3196      		adiw r30,1
 1098 0456 8A8D      		ldd r24,Y+26
 1099 0458 9B8D      		ldd r25,Y+27
 1100 045a ADB7      		in r26,__SP_L__
 1101 045c BEB7      		in r27,__SP_H__
 1102 045e 1296      		adiw r26,1+1
 1103 0460 9C93      		st X,r25
 1104 0462 8E93      		st -X,r24
 1105 0464 1197      		sbiw r26,1
 1106 0466 3383      		std Z+3,r19
 1107 0468 2283      		std Z+2,r18
 1108 046a 8D8D      		ldd r24,Y+29
 1109 046c 9E8D      		ldd r25,Y+30
 1110 046e 9583      		std Z+5,r25
 1111 0470 8483      		std Z+4,r24
 1112 0472 8F8D      		ldd r24,Y+31
 1113 0474 8683      		std Z+6,r24
 1114 0476 1782      		std Z+7,__zero_reg__
 1115 0478 0E94 0000 		call fprintf_P
 1116 047c 8DB7      		in r24,__SP_L__
 1117 047e 9EB7      		in r25,__SP_H__
 1118 0480 0896      		adiw r24,8
 1119 0482 0FB6      		in __tmp_reg__,__SREG__
 1120 0484 F894      		cli
 1121 0486 9EBF      		out __SP_H__,r25
 1122 0488 0FBE      		out __SREG__,__tmp_reg__
 1123 048a 8DBF      		out __SP_L__,r24
 1124               	.L43:
 170:vty.c         ****   state->errno = 0;
 1126               	.LM68:
 1127 048c 1C8E      		std Y+28,__zero_reg__
 171:vty.c         ****   state->err1 = 0;
 1129               	.LM69:
 1130 048e 1E8E      		std Y+30,__zero_reg__
 1131 0490 1D8E      		std Y+29,__zero_reg__
 172:vty.c         ****   state->err2 = 0;
 1133               	.LM70:
 1134 0492 1F8E      		std Y+31,__zero_reg__
 1135               	/* epilogue start */
 173:vty.c         **** }
 1137               	.LM71:
 1138 0494 DF91      		pop r29
 1139 0496 CF91      		pop r28
 1140 0498 0895      		ret
 1146               	.Lscope12:
 1148               		.stabd	78,0,0
 1152               	setTimeFunction:
 1153               		.stabd	46,0,0
 391:vty.c         **** {
 1155               	.LM72:
 1156               	.LFBB13:
 1157 049a EF92      		push r14
 1158 049c FF92      		push r15
 1159 049e 0F93      		push r16
 1160 04a0 1F93      		push r17
 1161               	/* prologue: function */
 1162               	/* frame size = 0 */
 1163 04a2 8C01      		movw r16,r24
 392:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 1165               	.LM73:
 1166 04a4 81E0      		ldi r24,lo8(1)
 1167 04a6 B801      		movw r22,r16
 1168 04a8 0E94 0000 		call cmdlineGetArgInt
 1169 04ac F62E      		mov r15,r22
 393:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 1171               	.LM74:
 1172 04ae 82E0      		ldi r24,lo8(2)
 1173 04b0 B801      		movw r22,r16
 1174 04b2 0E94 0000 		call cmdlineGetArgInt
 1175 04b6 E62E      		mov r14,r22
 394:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 1177               	.LM75:
 1178 04b8 83E0      		ldi r24,lo8(3)
 1179 04ba B801      		movw r22,r16
 1180 04bc 0E94 0000 		call cmdlineGetArgInt
 1181 04c0 162F      		mov r17,r22
 396:vty.c         ****   ds1305start();
 1183               	.LM76:
 1184 04c2 0E94 0000 		call ds1305start
 398:vty.c         ****   uint8_t cDzies = godzina/10;
 1186               	.LM77:
 1187 04c6 8F2D      		mov r24,r15
 1188 04c8 6AE0      		ldi r22,lo8(10)
 1189 04ca 0E94 0000 		call __udivmodqi4
 400:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 1191               	.LM78:
 1192 04ce 282F      		mov r18,r24
 1193 04d0 2370      		andi r18,lo8(3)
 1194 04d2 A0E0      		ldi r26,lo8(czasRtc+2)
 1195 04d4 B0E0      		ldi r27,hi8(czasRtc+2)
 1196 04d6 2295      		swap r18
 1197 04d8 207F      		andi r18,lo8(-16)
 1198 04da 9091 0000 		lds r25,czasRtc+2
 1199 04de 9F7C      		andi r25,lo8(-49)
 1200 04e0 922B      		or r25,r18
 1201 04e2 9093 0000 		sts czasRtc+2,r25
 401:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 1203               	.LM79:
 1204 04e6 46EF      		ldi r20,lo8(-10)
 1205 04e8 5FEF      		ldi r21,hi8(-10)
 1206 04ea 849F      		mul r24,r20
 1207 04ec 802D      		mov r24,r0
 1208 04ee 1124      		clr r1
 1209 04f0 8F0D      		add r24,r15
 1210 04f2 8F70      		andi r24,lo8(15)
 1211 04f4 9091 0000 		lds r25,czasRtc+2
 1212 04f8 907F      		andi r25,lo8(-16)
 1213 04fa 982B      		or r25,r24
 1214 04fc 9093 0000 		sts czasRtc+2,r25
 403:vty.c         ****   cDzies = minuta/10;
 1216               	.LM80:
 1217 0500 8E2D      		mov r24,r14
 1218 0502 0E94 0000 		call __udivmodqi4
 405:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 1220               	.LM81:
 1221 0506 282F      		mov r18,r24
 1222 0508 2770      		andi r18,lo8(7)
 1223 050a FD01      		movw r30,r26
 1224 050c 2295      		swap r18
 1225 050e 207F      		andi r18,lo8(-16)
 1226 0510 9291      		ld r25,-Z
 1227 0512 9F78      		andi r25,lo8(-113)
 1228 0514 922B      		or r25,r18
 1229 0516 9083      		st Z,r25
 406:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 1231               	.LM82:
 1232 0518 849F      		mul r24,r20
 1233 051a 802D      		mov r24,r0
 1234 051c 1124      		clr r1
 1235 051e 8E0D      		add r24,r14
 1236 0520 8F70      		andi r24,lo8(15)
 1237 0522 9081      		ld r25,Z
 1238 0524 907F      		andi r25,lo8(-16)
 1239 0526 982B      		or r25,r24
 1240 0528 9083      		st Z,r25
 408:vty.c         ****   cDzies = sekunda/10;
 1242               	.LM83:
 1243 052a 812F      		mov r24,r17
 1244 052c 0E94 0000 		call __udivmodqi4
 410:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 1246               	.LM84:
 1247 0530 282F      		mov r18,r24
 1248 0532 2770      		andi r18,lo8(7)
 1249 0534 1297      		sbiw r26,2
 1250 0536 2295      		swap r18
 1251 0538 207F      		andi r18,lo8(-16)
 1252 053a 9C91      		ld r25,X
 1253 053c 9F78      		andi r25,lo8(-113)
 1254 053e 922B      		or r25,r18
 1255 0540 9C93      		st X,r25
 411:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 1257               	.LM85:
 1258 0542 849F      		mul r24,r20
 1259 0544 802D      		mov r24,r0
 1260 0546 1124      		clr r1
 1261 0548 810F      		add r24,r17
 1262 054a 8F70      		andi r24,lo8(15)
 1263 054c 9C91      		ld r25,X
 1264 054e 907F      		andi r25,lo8(-16)
 1265 0550 982B      		or r25,r24
 1266 0552 9C93      		st X,r25
 413:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 1268               	.LM86:
 1269 0554 CD01      		movw r24,r26
 1270 0556 0E94 0000 		call setTimeDecoded
 415:vty.c         **** }
 1272               	.LM87:
 1273 055a 80E0      		ldi r24,lo8(0)
 1274 055c 90E0      		ldi r25,hi8(0)
 1275               	/* epilogue start */
 1276 055e 1F91      		pop r17
 1277 0560 0F91      		pop r16
 1278 0562 FF90      		pop r15
 1279 0564 EF90      		pop r14
 1280 0566 0895      		ret
 1282               	.Lscope13:
 1284               		.stabd	78,0,0
 1288               	ustawPortRezystor:
 1289               		.stabd	46,0,0
 572:vty.c         **** {
 1291               	.LM88:
 1292               	.LFBB14:
 1293               	/* prologue: function */
 1294               	/* frame size = 0 */
 1295 0568 FC01      		movw r30,r24
 573:vty.c         ****   if (state->argc < 1)
 1297               	.LM89:
 1298 056a 818D      		ldd r24,Z+25
 1299 056c 8823      		tst r24
 1300 056e 01F4      		brne .L48
 1301 0570 22E0      		ldi r18,lo8(2)
 1302 0572 30E0      		ldi r19,hi8(2)
 1303 0574 00C0      		rjmp .L49
 1304               	.L48:
 576:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 1306               	.LM90:
 1307 0576 81E0      		ldi r24,lo8(1)
 1308 0578 BF01      		movw r22,r30
 1309 057a 0E94 0000 		call cmdlineGetArgInt
 1310 057e 862F      		mov r24,r22
 578:vty.c         ****   MCP4150_setValue(wartosc);
 1312               	.LM91:
 1313 0580 0E94 0000 		call MCP4150_setValue
 1314 0584 20E0      		ldi r18,lo8(0)
 1315 0586 30E0      		ldi r19,hi8(0)
 1316               	.L49:
 581:vty.c         **** }
 1318               	.LM92:
 1319 0588 C901      		movw r24,r18
 1320               	/* epilogue start */
 1321 058a 0895      		ret
 1323               	.Lscope14:
 1325               		.stabd	78,0,0
 1329               	ustawPortExtBFunction:
 1330               		.stabd	46,0,0
 564:vty.c         **** {
 1332               	.LM93:
 1333               	.LFBB15:
 1334 058c 1F93      		push r17
 1335               	/* prologue: function */
 1336               	/* frame size = 0 */
 1337 058e BC01      		movw r22,r24
 565:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1339               	.LM94:
 1340 0590 81E0      		ldi r24,lo8(1)
 1341 0592 0E94 0000 		call cmdlineGetArgInt
 1342 0596 162F      		mov r17,r22
 566:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 1344               	.LM95:
 1345 0598 80E0      		ldi r24,lo8(0)
 1346 059a 60E0      		ldi r22,lo8(0)
 1347 059c 0E94 0000 		call MPC23s17SetDirB
 567:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 1349               	.LM96:
 1350 05a0 812F      		mov r24,r17
 1351 05a2 60E0      		ldi r22,lo8(0)
 1352 05a4 0E94 0000 		call MPC23s17SetPortB
 569:vty.c         **** }
 1354               	.LM97:
 1355 05a8 80E0      		ldi r24,lo8(0)
 1356 05aa 90E0      		ldi r25,hi8(0)
 1357               	/* epilogue start */
 1358 05ac 1F91      		pop r17
 1359 05ae 0895      		ret
 1361               	.Lscope15:
 1363               		.stabd	78,0,0
 1367               	ustawPortExtAFunction:
 1368               		.stabd	46,0,0
 556:vty.c         **** {
 1370               	.LM98:
 1371               	.LFBB16:
 1372 05b0 1F93      		push r17
 1373               	/* prologue: function */
 1374               	/* frame size = 0 */
 1375 05b2 BC01      		movw r22,r24
 557:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1377               	.LM99:
 1378 05b4 81E0      		ldi r24,lo8(1)
 1379 05b6 0E94 0000 		call cmdlineGetArgInt
 1380 05ba 162F      		mov r17,r22
 558:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 1382               	.LM100:
 1383 05bc 80E0      		ldi r24,lo8(0)
 1384 05be 60E0      		ldi r22,lo8(0)
 1385 05c0 0E94 0000 		call MPC23s17SetDirA
 559:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 1387               	.LM101:
 1388 05c4 812F      		mov r24,r17
 1389 05c6 60E0      		ldi r22,lo8(0)
 1390 05c8 0E94 0000 		call MPC23s17SetPortA
 561:vty.c         **** }
 1392               	.LM102:
 1393 05cc 80E0      		ldi r24,lo8(0)
 1394 05ce 90E0      		ldi r25,hi8(0)
 1395               	/* epilogue start */
 1396 05d0 1F91      		pop r17
 1397 05d2 0895      		ret
 1399               	.Lscope16:
 1401               		.stabd	78,0,0
 1405               	curtainDownFunction:
 1406               		.stabd	46,0,0
 509:vty.c         **** {
 1408               	.LM103:
 1409               	.LFBB17:
 1410 05d4 FF92      		push r15
 1411 05d6 0F93      		push r16
 1412 05d8 1F93      		push r17
 1413 05da CF93      		push r28
 1414 05dc DF93      		push r29
 1415               	/* prologue: function */
 1416               	/* frame size = 0 */
 1417 05de EC01      		movw r28,r24
 514:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 1419               	.LM104:
 1420 05e0 81E0      		ldi r24,lo8(1)
 1421 05e2 BE01      		movw r22,r28
 1422 05e4 0E94 0000 		call cmdlineGetArgInt
 1423 05e8 F62E      		mov r15,r22
 515:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 1425               	.LM105:
 1426 05ea 82E0      		ldi r24,lo8(2)
 1427 05ec BE01      		movw r22,r28
 1428 05ee 0E94 0000 		call cmdlineGetArgInt
 1429 05f2 162F      		mov r17,r22
 516:vty.c         ****   nrRolety &= 0x01;
 1431               	.LM106:
 1432 05f4 1170      		andi r17,lo8(1)
 517:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 1434               	.LM107:
 1435 05f6 83E0      		ldi r24,lo8(3)
 1436 05f8 BE01      		movw r22,r28
 1437 05fa 0E94 0000 		call cmdlineGetArgInt
 1438 05fe 062F      		mov r16,r22
 519:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 1440               	.LM108:
 1441 0600 2DB7      		in r18,__SP_L__
 1442 0602 3EB7      		in r19,__SP_H__
 1443 0604 2850      		subi r18,lo8(-(-8))
 1444 0606 3040      		sbci r19,hi8(-(-8))
 1445 0608 0FB6      		in __tmp_reg__,__SREG__
 1446 060a F894      		cli
 1447 060c 3EBF      		out __SP_H__,r19
 1448 060e 0FBE      		out __SREG__,__tmp_reg__
 1449 0610 2DBF      		out __SP_L__,r18
 1450 0612 EDB7      		in r30,__SP_L__
 1451 0614 FEB7      		in r31,__SP_H__
 1452 0616 3196      		adiw r30,1
 1453 0618 8A8D      		ldd r24,Y+26
 1454 061a 9B8D      		ldd r25,Y+27
 1455 061c ADB7      		in r26,__SP_L__
 1456 061e BEB7      		in r27,__SP_H__
 1457 0620 1296      		adiw r26,1+1
 1458 0622 9C93      		st X,r25
 1459 0624 8E93      		st -X,r24
 1460 0626 1197      		sbiw r26,1
 1461 0628 80E0      		ldi r24,lo8(movingCurtainDownStr)
 1462 062a 90E0      		ldi r25,hi8(movingCurtainDownStr)
 1463 062c 9383      		std Z+3,r25
 1464 062e 8283      		std Z+2,r24
 1465 0630 F482      		std Z+4,r15
 1466 0632 1582      		std Z+5,__zero_reg__
 1467 0634 812F      		mov r24,r17
 1468 0636 90E0      		ldi r25,lo8(0)
 1469 0638 0196      		adiw r24,1
 1470 063a 9783      		std Z+7,r25
 1471 063c 8683      		std Z+6,r24
 1472 063e 0E94 0000 		call fprintf_P
 521:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1474               	.LM109:
 1475 0642 802F      		mov r24,r16
 1476 0644 8150      		subi r24,lo8(-(-1))
 1477 0646 2DB7      		in r18,__SP_L__
 1478 0648 3EB7      		in r19,__SP_H__
 1479 064a 285F      		subi r18,lo8(-(8))
 1480 064c 3F4F      		sbci r19,hi8(-(8))
 1481 064e 0FB6      		in __tmp_reg__,__SREG__
 1482 0650 F894      		cli
 1483 0652 3EBF      		out __SP_H__,r19
 1484 0654 0FBE      		out __SREG__,__tmp_reg__
 1485 0656 2DBF      		out __SP_L__,r18
 1486 0658 8436      		cpi r24,lo8(100)
 1487 065a 00F4      		brsh .L56
 522:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1489               	.LM110:
 1490 065c 00D0      		rcall .
 1491 065e 00D0      		rcall .
 1492 0660 00D0      		rcall .
 1493 0662 EDB7      		in r30,__SP_L__
 1494 0664 FEB7      		in r31,__SP_H__
 1495 0666 3196      		adiw r30,1
 1496 0668 8A8D      		ldd r24,Y+26
 1497 066a 9B8D      		ldd r25,Y+27
 1498 066c ADB7      		in r26,__SP_L__
 1499 066e BEB7      		in r27,__SP_H__
 1500 0670 1296      		adiw r26,1+1
 1501 0672 9C93      		st X,r25
 1502 0674 8E93      		st -X,r24
 1503 0676 1197      		sbiw r26,1
 1504 0678 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1505 067a 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1506 067c 9383      		std Z+3,r25
 1507 067e 8283      		std Z+2,r24
 1508 0680 0483      		std Z+4,r16
 1509 0682 1582      		std Z+5,__zero_reg__
 1510 0684 0E94 0000 		call fprintf_P
 1511 0688 2DB7      		in r18,__SP_L__
 1512 068a 3EB7      		in r19,__SP_H__
 1513 068c 2A5F      		subi r18,lo8(-(6))
 1514 068e 3F4F      		sbci r19,hi8(-(6))
 1515 0690 0FB6      		in __tmp_reg__,__SREG__
 1516 0692 F894      		cli
 1517 0694 3EBF      		out __SP_H__,r19
 1518 0696 0FBE      		out __SREG__,__tmp_reg__
 1519 0698 2DBF      		out __SP_L__,r18
 1520               	.L56:
 524:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 1522               	.LM111:
 1523 069a 8F2D      		mov r24,r15
 1524 069c 612F      		mov r22,r17
 1525 069e 402F      		mov r20,r16
 1526 06a0 0E94 0000 		call rs485curtainDown
 526:vty.c         ****   if (result == 0)
 1528               	.LM112:
 1529 06a4 8823      		tst r24
 1530 06a6 01F0      		breq .L57
 1531 06a8 23E0      		ldi r18,lo8(3)
 1532 06aa 30E0      		ldi r19,hi8(3)
 1533 06ac 00C0      		rjmp .L58
 1534               	.L57:
 1535 06ae 21E0      		ldi r18,lo8(1)
 1536 06b0 30E0      		ldi r19,hi8(1)
 1537               	.L58:
 530:vty.c         **** }
 1539               	.LM113:
 1540 06b2 C901      		movw r24,r18
 1541               	/* epilogue start */
 1542 06b4 DF91      		pop r29
 1543 06b6 CF91      		pop r28
 1544 06b8 1F91      		pop r17
 1545 06ba 0F91      		pop r16
 1546 06bc FF90      		pop r15
 1547 06be 0895      		ret
 1553               	.Lscope17:
 1555               		.stabd	78,0,0
 1559               	curtainUpFunction:
 1560               		.stabd	46,0,0
 533:vty.c         **** {
 1562               	.LM114:
 1563               	.LFBB18:
 1564 06c0 FF92      		push r15
 1565 06c2 0F93      		push r16
 1566 06c4 1F93      		push r17
 1567 06c6 CF93      		push r28
 1568 06c8 DF93      		push r29
 1569               	/* prologue: function */
 1570               	/* frame size = 0 */
 1571 06ca EC01      		movw r28,r24
 534:vty.c         ****   if (state->argc < 2)
 1573               	.LM115:
 1574 06cc 898D      		ldd r24,Y+25
 1575 06ce 8230      		cpi r24,lo8(2)
 1576 06d0 00F4      		brsh .L61
 1577 06d2 22E0      		ldi r18,lo8(2)
 1578 06d4 30E0      		ldi r19,hi8(2)
 1579 06d6 00C0      		rjmp .L62
 1580               	.L61:
 537:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 1582               	.LM116:
 1583 06d8 81E0      		ldi r24,lo8(1)
 1584 06da BE01      		movw r22,r28
 1585 06dc 0E94 0000 		call cmdlineGetArgInt
 1586 06e0 F62E      		mov r15,r22
 1587 06e2 2FE3      		ldi r18,lo8(63)
 1588 06e4 F222      		and r15,r18
 538:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 1590               	.LM117:
 1591 06e6 82E0      		ldi r24,lo8(2)
 1592 06e8 BE01      		movw r22,r28
 1593 06ea 0E94 0000 		call cmdlineGetArgInt
 1594 06ee 062F      		mov r16,r22
 1595 06f0 0170      		andi r16,lo8(1)
 540:vty.c         ****   if (state->argc > 2)
 1597               	.LM118:
 1598 06f2 898D      		ldd r24,Y+25
 1599 06f4 8330      		cpi r24,lo8(3)
 1600 06f6 00F4      		brsh .L63
 1601 06f8 1FEF      		ldi r17,lo8(-1)
 1602 06fa 00C0      		rjmp .L64
 1603               	.L63:
 541:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 1605               	.LM119:
 1606 06fc 83E0      		ldi r24,lo8(3)
 1607 06fe BE01      		movw r22,r28
 1608 0700 0E94 0000 		call cmdlineGetArgInt
 1609 0704 162F      		mov r17,r22
 1610               	.L64:
 543:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 1612               	.LM120:
 1613 0706 8DB7      		in r24,__SP_L__
 1614 0708 9EB7      		in r25,__SP_H__
 1615 070a 0897      		sbiw r24,8
 1616 070c 0FB6      		in __tmp_reg__,__SREG__
 1617 070e F894      		cli
 1618 0710 9EBF      		out __SP_H__,r25
 1619 0712 0FBE      		out __SREG__,__tmp_reg__
 1620 0714 8DBF      		out __SP_L__,r24
 1621 0716 EDB7      		in r30,__SP_L__
 1622 0718 FEB7      		in r31,__SP_H__
 1623 071a 3196      		adiw r30,1
 1624 071c 8A8D      		ldd r24,Y+26
 1625 071e 9B8D      		ldd r25,Y+27
 1626 0720 ADB7      		in r26,__SP_L__
 1627 0722 BEB7      		in r27,__SP_H__
 1628 0724 1296      		adiw r26,1+1
 1629 0726 9C93      		st X,r25
 1630 0728 8E93      		st -X,r24
 1631 072a 1197      		sbiw r26,1
 1632 072c 80E0      		ldi r24,lo8(movingCurtainUpStr)
 1633 072e 90E0      		ldi r25,hi8(movingCurtainUpStr)
 1634 0730 9383      		std Z+3,r25
 1635 0732 8283      		std Z+2,r24
 1636 0734 F482      		std Z+4,r15
 1637 0736 1582      		std Z+5,__zero_reg__
 1638 0738 802F      		mov r24,r16
 1639 073a 90E0      		ldi r25,lo8(0)
 1640 073c 0196      		adiw r24,1
 1641 073e 9783      		std Z+7,r25
 1642 0740 8683      		std Z+6,r24
 1643 0742 0E94 0000 		call fprintf_P
 544:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1645               	.LM121:
 1646 0746 812F      		mov r24,r17
 1647 0748 8150      		subi r24,lo8(-(-1))
 1648 074a 2DB7      		in r18,__SP_L__
 1649 074c 3EB7      		in r19,__SP_H__
 1650 074e 285F      		subi r18,lo8(-(8))
 1651 0750 3F4F      		sbci r19,hi8(-(8))
 1652 0752 0FB6      		in __tmp_reg__,__SREG__
 1653 0754 F894      		cli
 1654 0756 3EBF      		out __SP_H__,r19
 1655 0758 0FBE      		out __SREG__,__tmp_reg__
 1656 075a 2DBF      		out __SP_L__,r18
 1657 075c 8436      		cpi r24,lo8(100)
 1658 075e 00F4      		brsh .L65
 545:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1660               	.LM122:
 1661 0760 00D0      		rcall .
 1662 0762 00D0      		rcall .
 1663 0764 00D0      		rcall .
 1664 0766 EDB7      		in r30,__SP_L__
 1665 0768 FEB7      		in r31,__SP_H__
 1666 076a 3196      		adiw r30,1
 1667 076c 8A8D      		ldd r24,Y+26
 1668 076e 9B8D      		ldd r25,Y+27
 1669 0770 ADB7      		in r26,__SP_L__
 1670 0772 BEB7      		in r27,__SP_H__
 1671 0774 1296      		adiw r26,1+1
 1672 0776 9C93      		st X,r25
 1673 0778 8E93      		st -X,r24
 1674 077a 1197      		sbiw r26,1
 1675 077c 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1676 077e 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1677 0780 9383      		std Z+3,r25
 1678 0782 8283      		std Z+2,r24
 1679 0784 1483      		std Z+4,r17
 1680 0786 1582      		std Z+5,__zero_reg__
 1681 0788 0E94 0000 		call fprintf_P
 1682 078c 2DB7      		in r18,__SP_L__
 1683 078e 3EB7      		in r19,__SP_H__
 1684 0790 2A5F      		subi r18,lo8(-(6))
 1685 0792 3F4F      		sbci r19,hi8(-(6))
 1686 0794 0FB6      		in __tmp_reg__,__SREG__
 1687 0796 F894      		cli
 1688 0798 3EBF      		out __SP_H__,r19
 1689 079a 0FBE      		out __SREG__,__tmp_reg__
 1690 079c 2DBF      		out __SP_L__,r18
 1691               	.L65:
 547:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 1693               	.LM123:
 1694 079e 8F2D      		mov r24,r15
 1695 07a0 602F      		mov r22,r16
 1696 07a2 412F      		mov r20,r17
 1697 07a4 0E94 0000 		call rs485curtainUp
 549:vty.c         ****   if (result == 0)
 1699               	.LM124:
 1700 07a8 8823      		tst r24
 1701 07aa 01F0      		breq .L66
 1702 07ac 23E0      		ldi r18,lo8(3)
 1703 07ae 30E0      		ldi r19,hi8(3)
 1704 07b0 00C0      		rjmp .L62
 1705               	.L66:
 1706 07b2 21E0      		ldi r18,lo8(1)
 1707 07b4 30E0      		ldi r19,hi8(1)
 1708               	.L62:
 553:vty.c         **** }
 1710               	.LM125:
 1711 07b6 C901      		movw r24,r18
 1712               	/* epilogue start */
 1713 07b8 DF91      		pop r29
 1714 07ba CF91      		pop r28
 1715 07bc 1F91      		pop r17
 1716 07be 0F91      		pop r16
 1717 07c0 FF90      		pop r15
 1718 07c2 0895      		ret
 1725               	.Lscope18:
 1727               		.stabd	78,0,0
 1731               	goXmodemWyslijFunction:
 1732               		.stabd	46,0,0
 650:vty.c         **** {
 1734               	.LM126:
 1735               	.LFBB19:
 1736 07c4 0F93      		push r16
 1737 07c6 1F93      		push r17
 1738 07c8 CF93      		push r28
 1739 07ca DF93      		push r29
 1740               	/* prologue: function */
 1741               	/* frame size = 0 */
 1742 07cc EC01      		movw r28,r24
 651:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 1744               	.LM127:
 1745 07ce 00D0      		rcall .
 1746 07d0 00D0      		rcall .
 1747 07d2 8A8D      		ldd r24,Y+26
 1748 07d4 9B8D      		ldd r25,Y+27
 1749 07d6 ADB7      		in r26,__SP_L__
 1750 07d8 BEB7      		in r27,__SP_H__
 1751 07da 1296      		adiw r26,1+1
 1752 07dc 9C93      		st X,r25
 1753 07de 8E93      		st -X,r24
 1754 07e0 1197      		sbiw r26,1
 1755 07e2 80E0      		ldi r24,lo8(xwyslijStartStr)
 1756 07e4 90E0      		ldi r25,hi8(xwyslijStartStr)
 1757 07e6 1496      		adiw r26,3+1
 1758 07e8 9C93      		st X,r25
 1759 07ea 8E93      		st -X,r24
 1760 07ec 1397      		sbiw r26,3
 1761 07ee 0E94 0000 		call fprintf_P
 652:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1763               	.LM128:
 1764 07f2 0F90      		pop __tmp_reg__
 1765 07f4 0F90      		pop __tmp_reg__
 1766 07f6 0F90      		pop __tmp_reg__
 1767 07f8 0F90      		pop __tmp_reg__
 1768 07fa 81E0      		ldi r24,lo8(1)
 1769 07fc BE01      		movw r22,r28
 1770 07fe 0E94 0000 		call cmdlineGetArgStr
 1771 0802 60E0      		ldi r22,lo8(fdVty)
 1772 0804 70E0      		ldi r23,hi8(fdVty)
 1773 0806 0E94 0000 		call ramDyskOtworzPlik
 1774 080a 8823      		tst r24
 1775 080c 01F4      		brne .L69
 1776 080e 20E0      		ldi r18,lo8(0)
 1777 0810 30E0      		ldi r19,hi8(0)
 1778 0812 00C0      		rjmp .L70
 1779               	.L69:
 654:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 1781               	.LM129:
 1782 0814 0A8D      		ldd r16,Y+26
 1783 0816 1B8D      		ldd r17,Y+27
 1784 0818 81E0      		ldi r24,lo8(1)
 1785 081a BE01      		movw r22,r28
 1786 081c 0E94 0000 		call cmdlineGetArgStr
 1787 0820 00D0      		rcall .
 1788 0822 00D0      		rcall .
 1789 0824 00D0      		rcall .
 1790 0826 EDB7      		in r30,__SP_L__
 1791 0828 FEB7      		in r31,__SP_H__
 1792 082a 3196      		adiw r30,1
 1793 082c ADB7      		in r26,__SP_L__
 1794 082e BEB7      		in r27,__SP_H__
 1795 0830 1296      		adiw r26,1+1
 1796 0832 1C93      		st X,r17
 1797 0834 0E93      		st -X,r16
 1798 0836 1197      		sbiw r26,1
 1799 0838 20E0      		ldi r18,lo8(errorOpenFile)
 1800 083a 30E0      		ldi r19,hi8(errorOpenFile)
 1801 083c 3383      		std Z+3,r19
 1802 083e 2283      		std Z+2,r18
 1803 0840 9583      		std Z+5,r25
 1804 0842 8483      		std Z+4,r24
 1805 0844 0E94 0000 		call fprintf_P
 1806 0848 24E0      		ldi r18,lo8(4)
 1807 084a 30E0      		ldi r19,hi8(4)
 1808 084c EDB7      		in r30,__SP_L__
 1809 084e FEB7      		in r31,__SP_H__
 1810 0850 3696      		adiw r30,6
 1811 0852 0FB6      		in __tmp_reg__,__SREG__
 1812 0854 F894      		cli
 1813 0856 FEBF      		out __SP_H__,r31
 1814 0858 0FBE      		out __SREG__,__tmp_reg__
 1815 085a EDBF      		out __SP_L__,r30
 1816               	.L70:
 658:vty.c         **** }
 1818               	.LM130:
 1819 085c C901      		movw r24,r18
 1820               	/* epilogue start */
 1821 085e DF91      		pop r29
 1822 0860 CF91      		pop r28
 1823 0862 1F91      		pop r17
 1824 0864 0F91      		pop r16
 1825 0866 0895      		ret
 1827               	.Lscope19:
 1829               		.stabd	78,0,0
 1833               	editRamFileFunction:
 1834               		.stabd	46,0,0
 876:vty.c         **** {
 1836               	.LM131:
 1837               	.LFBB20:
 1838 0868 EF92      		push r14
 1839 086a FF92      		push r15
 1840 086c 0F93      		push r16
 1841 086e 1F93      		push r17
 1842 0870 DF93      		push r29
 1843 0872 CF93      		push r28
 1844 0874 0F92      		push __tmp_reg__
 1845 0876 CDB7      		in r28,__SP_L__
 1846 0878 DEB7      		in r29,__SP_H__
 1847               	/* prologue: function */
 1848               	/* frame size = 1 */
 1849 087a 7C01      		movw r14,r24
 877:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1851               	.LM132:
 1852 087c 81E0      		ldi r24,lo8(1)
 1853 087e B701      		movw r22,r14
 1854 0880 0E94 0000 		call cmdlineGetArgStr
 1855 0884 60E0      		ldi r22,lo8(fdVty)
 1856 0886 70E0      		ldi r23,hi8(fdVty)
 1857 0888 0E94 0000 		call ramDyskOtworzPlik
 1858 088c 8823      		tst r24
 1859 088e 01F0      		breq .L73
 879:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 1861               	.LM133:
 1862 0890 D701      		movw r26,r14
 1863 0892 5A96      		adiw r26,26
 1864 0894 0D91      		ld r16,X+
 1865 0896 1C91      		ld r17,X
 1866 0898 5B97      		sbiw r26,26+1
 1867 089a 81E0      		ldi r24,lo8(1)
 1868 089c B701      		movw r22,r14
 1869 089e 0E94 0000 		call cmdlineGetArgStr
 1870 08a2 00D0      		rcall .
 1871 08a4 00D0      		rcall .
 1872 08a6 00D0      		rcall .
 1873 08a8 EDB7      		in r30,__SP_L__
 1874 08aa FEB7      		in r31,__SP_H__
 1875 08ac 3196      		adiw r30,1
 1876 08ae ADB7      		in r26,__SP_L__
 1877 08b0 BEB7      		in r27,__SP_H__
 1878 08b2 1296      		adiw r26,1+1
 1879 08b4 1C93      		st X,r17
 1880 08b6 0E93      		st -X,r16
 1881 08b8 1197      		sbiw r26,1
 1882 08ba 20E0      		ldi r18,lo8(errorOpenFile)
 1883 08bc 30E0      		ldi r19,hi8(errorOpenFile)
 1884 08be 3383      		std Z+3,r19
 1885 08c0 2283      		std Z+2,r18
 1886 08c2 9583      		std Z+5,r25
 1887 08c4 8483      		std Z+4,r24
 1888 08c6 0E94 0000 		call fprintf_P
 1889 08ca 24E0      		ldi r18,lo8(4)
 1890 08cc 30E0      		ldi r19,hi8(4)
 1891 08ce EDB7      		in r30,__SP_L__
 1892 08d0 FEB7      		in r31,__SP_H__
 1893 08d2 3696      		adiw r30,6
 1894 08d4 0FB6      		in __tmp_reg__,__SREG__
 1895 08d6 F894      		cli
 1896 08d8 FEBF      		out __SP_H__,r31
 1897 08da 0FBE      		out __SREG__,__tmp_reg__
 1898 08dc EDBF      		out __SP_L__,r30
 1899 08de 00C0      		rjmp .L74
 1900               	.L73:
 882:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 1902               	.LM134:
 1903 08e0 80E0      		ldi r24,lo8(fdVty)
 1904 08e2 90E0      		ldi r25,hi8(fdVty)
 1905 08e4 0E94 0000 		call ramDyskUstawWskaznikNaKoniec
 883:vty.c         ****   uint8_t znak = 0;
 1907               	.LM135:
 1908 08e8 1982      		std Y+1,__zero_reg__
 884:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 1910               	.LM136:
 1911 08ea 00D0      		rcall .
 1912 08ec 00D0      		rcall .
 1913 08ee D701      		movw r26,r14
 1914 08f0 5A96      		adiw r26,26
 1915 08f2 8D91      		ld r24,X+
 1916 08f4 9C91      		ld r25,X
 1917 08f6 5B97      		sbiw r26,26+1
 1918 08f8 EDB7      		in r30,__SP_L__
 1919 08fa FEB7      		in r31,__SP_H__
 1920 08fc 9283      		std Z+2,r25
 1921 08fe 8183      		std Z+1,r24
 1922 0900 80E0      		ldi r24,lo8(editRamFileIntroStr)
 1923 0902 90E0      		ldi r25,hi8(editRamFileIntroStr)
 1924 0904 9483      		std Z+4,r25
 1925 0906 8383      		std Z+3,r24
 1926 0908 0E94 0000 		call fprintf_P
 1927 090c 0F90      		pop __tmp_reg__
 1928 090e 0F90      		pop __tmp_reg__
 1929 0910 0F90      		pop __tmp_reg__
 1930 0912 0F90      		pop __tmp_reg__
 887:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 1932               	.LM137:
 1933 0914 7E01      		movw r14,r28
 1934 0916 0894      		sec
 1935 0918 E11C      		adc r14,__zero_reg__
 1936 091a F11C      		adc r15,__zero_reg__
 1937               	.L80:
 1938 091c 8091 0000 		lds r24,xVtyRec
 1939 0920 9091 0000 		lds r25,(xVtyRec)+1
 1940 0924 B701      		movw r22,r14
 1941 0926 4FEF      		ldi r20,lo8(-1)
 1942 0928 5FEF      		ldi r21,hi8(-1)
 1943 092a 20E0      		ldi r18,lo8(0)
 1944 092c 0E94 0000 		call xQueueGenericReceive
 1945 0930 8823      		tst r24
 1946 0932 01F0      		breq .L80
 890:vty.c         ****     if (znak == 0x03)                                       // ^C
 1948               	.LM138:
 1949 0934 8981      		ldd r24,Y+1
 1950 0936 8330      		cpi r24,lo8(3)
 1951 0938 01F0      		breq .L76
 893:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 1953               	.LM139:
 1954 093a 0E94 0000 		call uartVtySendByte
 894:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 1956               	.LM140:
 1957 093e 80E0      		ldi r24,lo8(fdVty)
 1958 0940 90E0      		ldi r25,hi8(fdVty)
 1959 0942 6981      		ldd r22,Y+1
 1960 0944 0E94 0000 		call ramDyskZapiszBajtDoPliku
 1961 0948 00C0      		rjmp .L80
 1962               	.L76:
 896:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 1964               	.LM141:
 1965 094a 80E0      		ldi r24,lo8(fdVty)
 1966 094c 90E0      		ldi r25,hi8(fdVty)
 1967 094e 0E94 0000 		call ramDyskZamknijPlik
 1968 0952 20E0      		ldi r18,lo8(0)
 1969 0954 30E0      		ldi r19,hi8(0)
 1970               	.L74:
 898:vty.c         **** }
 1972               	.LM142:
 1973 0956 C901      		movw r24,r18
 1974               	/* epilogue start */
 1975 0958 0F90      		pop __tmp_reg__
 1976 095a CF91      		pop r28
 1977 095c DF91      		pop r29
 1978 095e 1F91      		pop r17
 1979 0960 0F91      		pop r16
 1980 0962 FF90      		pop r15
 1981 0964 EF90      		pop r14
 1982 0966 0895      		ret
 1987               	.Lscope20:
 1989               		.stabd	78,0,0
 1993               	eraseRamFileFunction:
 1994               		.stabd	46,0,0
 848:vty.c         **** {
 1996               	.LM143:
 1997               	.LFBB21:
 1998 0968 CF93      		push r28
 1999 096a DF93      		push r29
 2000               	/* prologue: function */
 2001               	/* frame size = 0 */
 2002 096c EC01      		movw r28,r24
 849:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 2004               	.LM144:
 2005 096e 81E0      		ldi r24,lo8(1)
 2006 0970 BE01      		movw r22,r28
 2007 0972 0E94 0000 		call cmdlineGetArgStr
 2008 0976 0E94 0000 		call ramDyskUsunPlik
 2009 097a 8823      		tst r24
 2010 097c 01F4      		brne .L82
 2011 097e 21E0      		ldi r18,lo8(1)
 2012 0980 30E0      		ldi r19,hi8(1)
 2013 0982 00C0      		rjmp .L83
 2014               	.L82:
 852:vty.c         ****   printErrorInfo(state);
 2016               	.LM145:
 2017 0984 CE01      		movw r24,r28
 2018 0986 0E94 0000 		call printErrorInfo
 2019 098a 24E0      		ldi r18,lo8(4)
 2020 098c 30E0      		ldi r19,hi8(4)
 2021               	.L83:
 854:vty.c         **** }
 2023               	.LM146:
 2024 098e C901      		movw r24,r18
 2025               	/* epilogue start */
 2026 0990 DF91      		pop r29
 2027 0992 CF91      		pop r28
 2028 0994 0895      		ret
 2030               	.Lscope21:
 2032               		.stabd	78,0,0
 2036               	dodajRamPlikFunction:
 2037               		.stabd	46,0,0
 857:vty.c         **** {
 2039               	.LM147:
 2040               	.LFBB22:
 2041 0996 CF93      		push r28
 2042 0998 DF93      		push r29
 2043               	/* prologue: function */
 2044               	/* frame size = 0 */
 2045 099a EC01      		movw r28,r24
 858:vty.c         ****   if (state->argc != 1)
 2047               	.LM148:
 2048 099c 898D      		ldd r24,Y+25
 2049 099e 8130      		cpi r24,lo8(1)
 2050 09a0 01F0      		breq .L86
 2051 09a2 22E0      		ldi r18,lo8(2)
 2052 09a4 30E0      		ldi r19,hi8(2)
 2053 09a6 00C0      		rjmp .L87
 2054               	.L86:
 861:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 2056               	.LM149:
 2057 09a8 81E0      		ldi r24,lo8(1)
 2058 09aa BE01      		movw r22,r28
 2059 09ac 0E94 0000 		call cmdlineGetArgStr
 2060 09b0 0E94 0000 		call ramDyskUtworzPlik
 2061 09b4 8823      		tst r24
 2062 09b6 01F4      		brne .L88
 2063 09b8 21E0      		ldi r18,lo8(1)
 2064 09ba 30E0      		ldi r19,hi8(1)
 2065 09bc 00C0      		rjmp .L87
 2066               	.L88:
 865:vty.c         ****   printErrorInfo(state);
 2068               	.LM150:
 2069 09be CE01      		movw r24,r28
 2070 09c0 0E94 0000 		call printErrorInfo
 2071 09c4 24E0      		ldi r18,lo8(4)
 2072 09c6 30E0      		ldi r19,hi8(4)
 2073               	.L87:
 867:vty.c         **** }
 2075               	.LM151:
 2076 09c8 C901      		movw r24,r18
 2077               	/* epilogue start */
 2078 09ca DF91      		pop r29
 2079 09cc CF91      		pop r28
 2080 09ce 0895      		ret
 2082               	.Lscope22:
 2084               		.stabd	78,0,0
 2088               	rpingFunction:
 2089               		.stabd	46,0,0
 584:vty.c         **** {
 2091               	.LM152:
 2092               	.LFBB23:
 2093 09d0 1F93      		push r17
 2094 09d2 CF93      		push r28
 2095 09d4 DF93      		push r29
 2096               	/* prologue: function */
 2097               	/* frame size = 0 */
 2098 09d6 EC01      		movw r28,r24
 585:vty.c         ****   if (state->argc < 1)
 2100               	.LM153:
 2101 09d8 898D      		ldd r24,Y+25
 2102 09da 8823      		tst r24
 2103 09dc 01F4      		brne .L91
 2104 09de 22E0      		ldi r18,lo8(2)
 2105 09e0 30E0      		ldi r19,hi8(2)
 2106 09e2 00C0      		rjmp .L92
 2107               	.L91:
 588:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 2109               	.LM154:
 2110 09e4 81E0      		ldi r24,lo8(1)
 2111 09e6 BE01      		movw r22,r28
 2112 09e8 0E94 0000 		call cmdlineGetArgInt
 2113 09ec 162F      		mov r17,r22
 589:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 2115               	.LM155:
 2116 09ee 862F      		mov r24,r22
 2117 09f0 0E94 0000 		call rs485ping
 2118 09f4 8F8F      		std Y+31,r24
 2119 09f6 8823      		tst r24
 2120 09f8 01F4      		brne .L93
 2121 09fa 21E0      		ldi r18,lo8(1)
 2122 09fc 30E0      		ldi r19,hi8(1)
 2123 09fe 00C0      		rjmp .L92
 2124               	.L93:
 592:vty.c         ****   state->errno = noRemoteDevice;
 2126               	.LM156:
 2127 0a00 89E0      		ldi r24,lo8(9)
 2128 0a02 8C8F      		std Y+28,r24
 593:vty.c         ****   state->err1 = nrSterownika;
 2130               	.LM157:
 2131 0a04 1D8F      		std Y+29,r17
 2132 0a06 1E8E      		std Y+30,__zero_reg__
 594:vty.c         ****   printErrorInfo(state);
 2134               	.LM158:
 2135 0a08 CE01      		movw r24,r28
 2136 0a0a 0E94 0000 		call printErrorInfo
 2137 0a0e 20E0      		ldi r18,lo8(0)
 2138 0a10 30E0      		ldi r19,hi8(0)
 2139               	.L92:
 596:vty.c         **** }
 2141               	.LM159:
 2142 0a12 C901      		movw r24,r18
 2143               	/* epilogue start */
 2144 0a14 DF91      		pop r29
 2145 0a16 CF91      		pop r28
 2146 0a18 1F91      		pop r17
 2147 0a1a 0895      		ret
 2149               	.Lscope23:
 2151               		.stabd	78,0,0
 2155               	flashExModuleFunction:
 2156               		.stabd	46,0,0
 616:vty.c         **** {
 2158               	.LM160:
 2159               	.LFBB24:
 2160 0a1c FF92      		push r15
 2161 0a1e 0F93      		push r16
 2162 0a20 1F93      		push r17
 2163 0a22 CF93      		push r28
 2164 0a24 DF93      		push r29
 2165               	/* prologue: function */
 2166               	/* frame size = 0 */
 2167 0a26 EC01      		movw r28,r24
 617:vty.c         ****   if (state->argc != 2)
 2169               	.LM161:
 2170 0a28 898D      		ldd r24,Y+25
 2171 0a2a 8230      		cpi r24,lo8(2)
 2172 0a2c 01F0      		breq .L96
 2173 0a2e 22E0      		ldi r18,lo8(2)
 2174 0a30 30E0      		ldi r19,hi8(2)
 2175 0a32 00C0      		rjmp .L97
 2176               	.L96:
 620:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 2178               	.LM162:
 2179 0a34 81E0      		ldi r24,lo8(1)
 2180 0a36 BE01      		movw r22,r28
 2181 0a38 0E94 0000 		call cmdlineGetArgInt
 2182 0a3c F62E      		mov r15,r22
 621:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 2184               	.LM163:
 2185 0a3e 82E0      		ldi r24,lo8(2)
 2186 0a40 BE01      		movw r22,r28
 2187 0a42 0E94 0000 		call cmdlineGetArgStr
 2188 0a46 8C01      		movw r16,r24
 625:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 2190               	.LM164:
 2191 0a48 8F2D      		mov r24,r15
 2192 0a4a 0E94 0000 		call rs485ping
 2193 0a4e 8823      		tst r24
 2194 0a50 01F0      		breq .L98
 627:vty.c         ****     state->errno = noRemoteDevice;
 2196               	.LM165:
 2197 0a52 89E0      		ldi r24,lo8(9)
 2198 0a54 8C8F      		std Y+28,r24
 628:vty.c         ****     printErrorInfo(state);
 2200               	.LM166:
 2201 0a56 CE01      		movw r24,r28
 2202 0a58 0E94 0000 		call printErrorInfo
 2203 0a5c 00C0      		rjmp .L100
 2204               	.L98:
 633:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 2206               	.LM167:
 2207 0a5e C801      		movw r24,r16
 2208 0a60 60E0      		ldi r22,lo8(fdVty)
 2209 0a62 70E0      		ldi r23,hi8(fdVty)
 2210 0a64 0E94 0000 		call ramDyskOtworzPlik
 2211 0a68 4A8D      		ldd r20,Y+26
 2212 0a6a 5B8D      		ldd r21,Y+27
 2213 0a6c 8823      		tst r24
 2214 0a6e 01F0      		breq .L99
 635:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 2216               	.LM168:
 2217 0a70 00D0      		rcall .
 2218 0a72 00D0      		rcall .
 2219 0a74 00D0      		rcall .
 2220 0a76 EDB7      		in r30,__SP_L__
 2221 0a78 FEB7      		in r31,__SP_H__
 2222 0a7a 3196      		adiw r30,1
 2223 0a7c ADB7      		in r26,__SP_L__
 2224 0a7e BEB7      		in r27,__SP_H__
 2225 0a80 1296      		adiw r26,1+1
 2226 0a82 5C93      		st X,r21
 2227 0a84 4E93      		st -X,r20
 2228 0a86 1197      		sbiw r26,1
 2229 0a88 80E0      		ldi r24,lo8(errorOpenFile)
 2230 0a8a 90E0      		ldi r25,hi8(errorOpenFile)
 2231 0a8c 9383      		std Z+3,r25
 2232 0a8e 8283      		std Z+2,r24
 2233 0a90 1583      		std Z+5,r17
 2234 0a92 0483      		std Z+4,r16
 2235 0a94 0E94 0000 		call fprintf_P
 2236 0a98 24E0      		ldi r18,lo8(4)
 2237 0a9a 30E0      		ldi r19,hi8(4)
 2238 0a9c 8DB7      		in r24,__SP_L__
 2239 0a9e 9EB7      		in r25,__SP_H__
 2240 0aa0 0696      		adiw r24,6
 2241 0aa2 0FB6      		in __tmp_reg__,__SREG__
 2242 0aa4 F894      		cli
 2243 0aa6 9EBF      		out __SP_H__,r25
 2244 0aa8 0FBE      		out __SREG__,__tmp_reg__
 2245 0aaa 8DBF      		out __SP_L__,r24
 2246 0aac 00C0      		rjmp .L97
 2247               	.L99:
 639:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 2249               	.LM169:
 2250 0aae 80E0      		ldi r24,lo8(fdVty)
 2251 0ab0 90E0      		ldi r25,hi8(fdVty)
 2252 0ab2 6F2D      		mov r22,r15
 2253 0ab4 0E94 0000 		call rs485xModemFlash
 2254 0ab8 182F      		mov r17,r24
 641:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2256               	.LM170:
 2257 0aba 80E0      		ldi r24,lo8(fdVty)
 2258 0abc 90E0      		ldi r25,hi8(fdVty)
 2259 0abe 0E94 0000 		call ramDyskZamknijPlik
 643:vty.c         ****   if (blad != 0)
 2261               	.LM171:
 2262 0ac2 1123      		tst r17
 2263 0ac4 01F4      		brne .L100
 2264 0ac6 20E0      		ldi r18,lo8(0)
 2265 0ac8 30E0      		ldi r19,hi8(0)
 2266 0aca 00C0      		rjmp .L97
 2267               	.L100:
 2268 0acc 24E0      		ldi r18,lo8(4)
 2269 0ace 30E0      		ldi r19,hi8(4)
 2270               	.L97:
 647:vty.c         **** }
 2272               	.LM172:
 2273 0ad0 C901      		movw r24,r18
 2274               	/* epilogue start */
 2275 0ad2 DF91      		pop r29
 2276 0ad4 CF91      		pop r28
 2277 0ad6 1F91      		pop r17
 2278 0ad8 0F91      		pop r16
 2279 0ada FF90      		pop r15
 2280 0adc 0895      		ret
 2286               	.Lscope24:
 2288               		.stabd	78,0,0
 2292               	goXmodemOdbierzFunction:
 2293               		.stabd	46,0,0
 661:vty.c         **** {
 2295               	.LM173:
 2296               	.LFBB25:
 2297 0ade 2F92      		push r2
 2298 0ae0 3F92      		push r3
 2299 0ae2 4F92      		push r4
 2300 0ae4 5F92      		push r5
 2301 0ae6 6F92      		push r6
 2302 0ae8 7F92      		push r7
 2303 0aea 8F92      		push r8
 2304 0aec 9F92      		push r9
 2305 0aee AF92      		push r10
 2306 0af0 BF92      		push r11
 2307 0af2 CF92      		push r12
 2308 0af4 DF92      		push r13
 2309 0af6 EF92      		push r14
 2310 0af8 FF92      		push r15
 2311 0afa 0F93      		push r16
 2312 0afc 1F93      		push r17
 2313 0afe DF93      		push r29
 2314 0b00 CF93      		push r28
 2315 0b02 00D0      		rcall .
 2316 0b04 00D0      		rcall .
 2317 0b06 00D0      		rcall .
 2318 0b08 CDB7      		in r28,__SP_L__
 2319 0b0a DEB7      		in r29,__SP_H__
 2320               	/* prologue: function */
 2321               	/* frame size = 6 */
 2322 0b0c 7C01      		movw r14,r24
 662:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 2324               	.LM174:
 2325 0b0e 00D0      		rcall .
 2326 0b10 00D0      		rcall .
 2327 0b12 DC01      		movw r26,r24
 2328 0b14 5A96      		adiw r26,26
 2329 0b16 8D91      		ld r24,X+
 2330 0b18 9C91      		ld r25,X
 2331 0b1a 5B97      		sbiw r26,26+1
 2332 0b1c EDB7      		in r30,__SP_L__
 2333 0b1e FEB7      		in r31,__SP_H__
 2334 0b20 9283      		std Z+2,r25
 2335 0b22 8183      		std Z+1,r24
 2336 0b24 80E0      		ldi r24,lo8(__c.3660)
 2337 0b26 90E0      		ldi r25,hi8(__c.3660)
 2338 0b28 9483      		std Z+4,r25
 2339 0b2a 8383      		std Z+3,r24
 2340 0b2c 0E94 0000 		call fprintf_P
 663:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 2342               	.LM175:
 2343 0b30 0F90      		pop __tmp_reg__
 2344 0b32 0F90      		pop __tmp_reg__
 2345 0b34 0F90      		pop __tmp_reg__
 2346 0b36 0F90      		pop __tmp_reg__
 2347 0b38 81E0      		ldi r24,lo8(1)
 2348 0b3a B701      		movw r22,r14
 2349 0b3c 0E94 0000 		call cmdlineGetArgStr
 2350 0b40 60E0      		ldi r22,lo8(fdVty)
 2351 0b42 70E0      		ldi r23,hi8(fdVty)
 2352 0b44 0E94 0000 		call ramDyskOtworzPlik
 2353 0b48 8823      		tst r24
 2354 0b4a 01F0      		breq .L103
 665:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 2356               	.LM176:
 2357 0b4c D701      		movw r26,r14
 2358 0b4e 5A96      		adiw r26,26
 2359 0b50 0D91      		ld r16,X+
 2360 0b52 1C91      		ld r17,X
 2361 0b54 5B97      		sbiw r26,26+1
 2362 0b56 81E0      		ldi r24,lo8(1)
 2363 0b58 B701      		movw r22,r14
 2364 0b5a 0E94 0000 		call cmdlineGetArgStr
 2365 0b5e 00D0      		rcall .
 2366 0b60 00D0      		rcall .
 2367 0b62 00D0      		rcall .
 2368 0b64 EDB7      		in r30,__SP_L__
 2369 0b66 FEB7      		in r31,__SP_H__
 2370 0b68 3196      		adiw r30,1
 2371 0b6a ADB7      		in r26,__SP_L__
 2372 0b6c BEB7      		in r27,__SP_H__
 2373 0b6e 1296      		adiw r26,1+1
 2374 0b70 1C93      		st X,r17
 2375 0b72 0E93      		st -X,r16
 2376 0b74 1197      		sbiw r26,1
 2377 0b76 20E0      		ldi r18,lo8(errorOpenFile)
 2378 0b78 30E0      		ldi r19,hi8(errorOpenFile)
 2379 0b7a 3383      		std Z+3,r19
 2380 0b7c 2283      		std Z+2,r18
 2381 0b7e 9583      		std Z+5,r25
 2382 0b80 8483      		std Z+4,r24
 2383 0b82 0E94 0000 		call fprintf_P
 2384 0b86 24E0      		ldi r18,lo8(4)
 2385 0b88 30E0      		ldi r19,hi8(4)
 2386 0b8a EDB7      		in r30,__SP_L__
 2387 0b8c FEB7      		in r31,__SP_H__
 2388 0b8e 3696      		adiw r30,6
 2389 0b90 0FB6      		in __tmp_reg__,__SREG__
 2390 0b92 F894      		cli
 2391 0b94 FEBF      		out __SP_H__,r31
 2392 0b96 0FBE      		out __SREG__,__tmp_reg__
 2393 0b98 EDBF      		out __SP_L__,r30
 2394 0b9a 00C0      		rjmp .L104
 2395               	.L103:
 688:vty.c         ****   state->err1=0;
 2397               	.LM177:
 2398 0b9c D701      		movw r26,r14
 2399 0b9e 5E96      		adiw r26,29+1
 2400 0ba0 1C92      		st X,__zero_reg__
 2401 0ba2 1E92      		st -X,__zero_reg__
 2402 0ba4 5D97      		sbiw r26,29
 689:vty.c         ****   state->err2=0;
 2404               	.LM178:
 2405 0ba6 5F96      		adiw r26,31
 2406 0ba8 1C92      		st X,__zero_reg__
 2407 0baa 04E1      		ldi r16,lo8(20)
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2409               	.LM179:
 2410 0bac B2E0      		ldi r27,lo8(2)
 2411 0bae CB2E      		mov r12,r27
 2412 0bb0 D12C      		mov r13,__zero_reg__
 2413 0bb2 CC0E      		add r12,r28
 2414 0bb4 DD1E      		adc r13,r29
 2415               	.L108:
 693:vty.c         ****     fputc('C'              , state->myStdInOut);
 2417               	.LM180:
 2418 0bb6 F701      		movw r30,r14
 2419 0bb8 628D      		ldd r22,Z+26
 2420 0bba 738D      		ldd r23,Z+27
 2421 0bbc 83E4      		ldi r24,lo8(67)
 2422 0bbe 90E0      		ldi r25,hi8(67)
 2423 0bc0 0E94 0000 		call fputc
 2424               	.L105:
 694:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 2426               	.LM181:
 2427 0bc4 8091 9B00 		lds r24,155
 2428 0bc8 86FF      		sbrs r24,6
 2429 0bca 00C0      		rjmp .L105
 696:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 2431               	.LM182:
 2432 0bcc 8091 0000 		lds r24,xVtyRec
 2433 0bd0 9091 0000 		lds r25,(xVtyRec)+1
 2434 0bd4 B601      		movw r22,r12
 2435 0bd6 44E6      		ldi r20,lo8(100)
 2436 0bd8 50E0      		ldi r21,hi8(100)
 2437 0bda 20E0      		ldi r18,lo8(0)
 2438 0bdc 0E94 0000 		call xQueueGenericReceive
 2439 0be0 8823      		tst r24
 2440 0be2 01F0      		breq .L106
 697:vty.c         ****       if (c == SOH)
 2442               	.LM183:
 2443 0be4 8A81      		ldd r24,Y+2
 2444 0be6 8130      		cpi r24,lo8(1)
 2445 0be8 01F0      		breq .L107
 2446               	.L106:
 700:vty.c         ****     liczbaProb--;
 2448               	.LM184:
 2449 0bea 0150      		subi r16,lo8(-(-1))
 701:vty.c         ****     if (liczbaProb == 0)
 2451               	.LM185:
 2452 0bec 01F4      		brne .L108
 703:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 2454               	.LM186:
 2455 0bee 80E0      		ldi r24,lo8(fdVty)
 2456 0bf0 90E0      		ldi r25,hi8(fdVty)
 2457 0bf2 0E94 0000 		call ramDyskZamknijPlik
 704:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2459               	.LM187:
 2460 0bf6 D701      		movw r26,r14
 2461 0bf8 5C96      		adiw r26,28
 2462 0bfa 1C92      		st X,__zero_reg__
 2463 0bfc 24E0      		ldi r18,lo8(4)
 2464 0bfe 30E0      		ldi r19,hi8(4)
 2465 0c00 00C0      		rjmp .L104
 2466               	.L107:
 712:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2468               	.LM188:
 2469 0c02 80E0      		ldi r24,lo8(fdVty)
 2470 0c04 90E0      		ldi r25,hi8(fdVty)
 2471 0c06 61E0      		ldi r22,lo8(1)
 2472 0c08 70E0      		ldi r23,hi8(1)
 2473 0c0a 0E94 0000 		call ramDyskDodajBlokXmodem
 2474 0c0e 6C01      		movw r12,r24
 2475 0c10 5C01      		movw r10,r24
 2476 0c12 AAE0      		ldi r26,lo8(10)
 2477 0c14 9A2E      		mov r9,r26
 2478 0c16 11E0      		ldi r17,lo8(1)
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2480               	.LM189:
 2481 0c18 F3E0      		ldi r31,lo8(3)
 2482 0c1a 8F2E      		mov r8,r31
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 2484               	.LM190:
 2485 0c1c E5E0      		ldi r30,lo8(5)
 2486 0c1e 2E2E      		mov r2,r30
 2487 0c20 312C      		mov r3,__zero_reg__
 2488 0c22 2C0E      		add r2,r28
 2489 0c24 3D1E      		adc r3,r29
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2491               	.LM191:
 2492 0c26 76E0      		ldi r23,lo8(6)
 2493 0c28 472E      		mov r4,r23
 2494 0c2a 512C      		mov r5,__zero_reg__
 2495 0c2c 4C0E      		add r4,r28
 2496 0c2e 5D1E      		adc r5,r29
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2498               	.LM192:
 2499 0c30 3E01      		movw r6,r28
 2500 0c32 0894      		sec
 2501 0c34 611C      		adc r6,__zero_reg__
 2502 0c36 711C      		adc r7,__zero_reg__
 2503               	.L126:
 716:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 2505               	.LM193:
 2506 0c38 8091 0000 		lds r24,xVtyRec
 2507 0c3c 9091 0000 		lds r25,(xVtyRec)+1
 2508 0c40 BE01      		movw r22,r28
 2509 0c42 6D5F      		subi r22,lo8(-(3))
 2510 0c44 7F4F      		sbci r23,hi8(-(3))
 2511 0c46 44E6      		ldi r20,lo8(100)
 2512 0c48 50E0      		ldi r21,hi8(100)
 2513 0c4a 20E0      		ldi r18,lo8(0)
 2514 0c4c 0E94 0000 		call xQueueGenericReceive
 2515 0c50 8823      		tst r24
 2516 0c52 01F4      		brne .+2
 2517 0c54 00C0      		rjmp .L135
 2518               	.L109:
 722:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 2520               	.LM194:
 2521 0c56 8091 0000 		lds r24,xVtyRec
 2522 0c5a 9091 0000 		lds r25,(xVtyRec)+1
 2523 0c5e BE01      		movw r22,r28
 2524 0c60 6C5F      		subi r22,lo8(-(4))
 2525 0c62 7F4F      		sbci r23,hi8(-(4))
 2526 0c64 41E0      		ldi r20,lo8(1)
 2527 0c66 50E0      		ldi r21,hi8(1)
 2528 0c68 20E0      		ldi r18,lo8(0)
 2529 0c6a 0E94 0000 		call xQueueGenericReceive
 2530 0c6e 8823      		tst r24
 2531 0c70 01F4      		brne .L111
 724:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 2533               	.LM195:
 2534 0c72 83E0      		ldi r24,lo8(3)
 2535 0c74 D701      		movw r26,r14
 2536 0c76 00C0      		rjmp .L136
 2537               	.L111:
 729:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 2539               	.LM196:
 2540 0c78 9C81      		ldd r25,Y+4
 2541 0c7a 892F      		mov r24,r25
 2542 0c7c 8095      		com r24
 2543 0c7e 8A83      		std Y+2,r24
 730:vty.c         ****     if (nrBlokuZdalny != c)
 2545               	.LM197:
 2546 0c80 0B81      		ldd r16,Y+3
 2547 0c82 0817      		cp r16,r24
 2548 0c84 01F0      		breq .L112
 732:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 2550               	.LM198:
 2551 0c86 85E0      		ldi r24,lo8(5)
 2552 0c88 F701      		movw r30,r14
 2553 0c8a 848F      		std Z+28,r24
 733:vty.c         ****       state->err1 = nrBlokuZdalny;
 2555               	.LM199:
 2556 0c8c 058F      		std Z+29,r16
 2557 0c8e 168E      		std Z+30,__zero_reg__
 734:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 2559               	.LM200:
 2560 0c90 978F      		std Z+31,r25
 2561 0c92 00C0      		rjmp .L110
 2562               	.L112:
 739:vty.c         ****     c = nrBloku-1;
 2564               	.LM201:
 2565 0c94 812F      		mov r24,r17
 2566 0c96 8150      		subi r24,lo8(-(-1))
 2567 0c98 8A83      		std Y+2,r24
 740:vty.c         ****     if (nrBlokuZdalny == c)
 2569               	.LM202:
 2570 0c9a 0817      		cp r16,r24
 2571 0c9c 01F0      		breq .L113
 2572 0c9e 012F      		mov r16,r17
 2573 0ca0 00C0      		rjmp .L114
 2574               	.L113:
 743:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2576               	.LM203:
 2577 0ca2 80E0      		ldi r24,lo8(fdVty)
 2578 0ca4 90E0      		ldi r25,hi8(fdVty)
 2579 0ca6 602F      		mov r22,r16
 2580 0ca8 70E0      		ldi r23,lo8(0)
 2581 0caa 0E94 0000 		call ramDyskDodajBlokXmodem
 2582 0cae 6C01      		movw r12,r24
 2583 0cb0 5C01      		movw r10,r24
 2584               	.L114:
 748:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 2586               	.LM204:
 2587 0cb2 1B81      		ldd r17,Y+3
 2588 0cb4 1017      		cp r17,r16
 2589 0cb6 01F0      		breq .L115
 750:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2591               	.LM205:
 2592 0cb8 84E0      		ldi r24,lo8(4)
 2593 0cba D701      		movw r26,r14
 2594 0cbc 5C96      		adiw r26,28
 2595 0cbe 8C93      		st X,r24
 2596 0cc0 5C97      		sbiw r26,28
 751:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 2598               	.LM206:
 2599 0cc2 8C81      		ldd r24,Y+4
 2600 0cc4 5D96      		adiw r26,29
 2601 0cc6 8C93      		st X,r24
 2602 0cc8 5D97      		sbiw r26,29
 2603 0cca 5E96      		adiw r26,30
 2604 0ccc 1C92      		st X,__zero_reg__
 2605 0cce 5E97      		sbiw r26,30
 752:vty.c         ****       state->err2 = nrBloku;
 2607               	.LM207:
 2608 0cd0 5F96      		adiw r26,31
 2609 0cd2 0C93      		st X,r16
 2610 0cd4 00C0      		rjmp .L110
 2611               	.L115:
 753:vty.c         ****       break;
 2613               	.LM208:
 2614 0cd6 00E0      		ldi r16,lo8(0)
 2615               	.L117:
 758:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 2617               	.LM209:
 2618 0cd8 8091 0000 		lds r24,xVtyRec
 2619 0cdc 9091 0000 		lds r25,(xVtyRec)+1
 2620 0ce0 BE01      		movw r22,r28
 2621 0ce2 6E5F      		subi r22,lo8(-(2))
 2622 0ce4 7F4F      		sbci r23,hi8(-(2))
 2623 0ce6 4AE0      		ldi r20,lo8(10)
 2624 0ce8 50E0      		ldi r21,hi8(10)
 2625 0cea 20E0      		ldi r18,lo8(0)
 2626 0cec 0E94 0000 		call xQueueGenericReceive
 2627 0cf0 8823      		tst r24
 2628 0cf2 01F0      		breq .L116
 759:vty.c         ****         *(zapPtr++) = c;
 2630               	.LM210:
 2631 0cf4 8A81      		ldd r24,Y+2
 2632 0cf6 F601      		movw r30,r12
 2633 0cf8 8193      		st Z+,r24
 2634 0cfa 6F01      		movw r12,r30
 756:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2636               	.LM211:
 2637 0cfc 0F5F      		subi r16,lo8(-(1))
 2638 0cfe 0038      		cpi r16,lo8(-128)
 2639 0d00 01F4      		brne .L117
 2640 0d02 00C0      		rjmp .L118
 2641               	.L116:
 762:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 2643               	.LM212:
 2644 0d04 D701      		movw r26,r14
 2645 0d06 5C96      		adiw r26,28
 2646 0d08 8C92      		st X,r8
 2647               	.L118:
 766:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 2649               	.LM213:
 2650 0d0a 8091 0000 		lds r24,xVtyRec
 2651 0d0e 9091 0000 		lds r25,(xVtyRec)+1
 2652 0d12 B101      		movw r22,r2
 2653 0d14 4AE0      		ldi r20,lo8(10)
 2654 0d16 50E0      		ldi r21,hi8(10)
 2655 0d18 20E0      		ldi r18,lo8(0)
 2656 0d1a 0E94 0000 		call xQueueGenericReceive
 2657 0d1e 8823      		tst r24
 2658 0d20 01F4      		brne .L119
 768:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2660               	.LM214:
 2661 0d22 86E0      		ldi r24,lo8(6)
 2662 0d24 F701      		movw r30,r14
 2663 0d26 848F      		std Z+28,r24
 769:vty.c         ****         state->err1 = 2;
 2665               	.LM215:
 2666 0d28 82E0      		ldi r24,lo8(2)
 2667 0d2a 90E0      		ldi r25,hi8(2)
 2668 0d2c 968F      		std Z+30,r25
 2669 0d2e 858F      		std Z+29,r24
 2670 0d30 00C0      		rjmp .L110
 2671               	.L119:
 772:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 2673               	.LM216:
 2674 0d32 8091 0000 		lds r24,xVtyRec
 2675 0d36 9091 0000 		lds r25,(xVtyRec)+1
 2676 0d3a B201      		movw r22,r4
 2677 0d3c 4AE0      		ldi r20,lo8(10)
 2678 0d3e 50E0      		ldi r21,hi8(10)
 2679 0d40 20E0      		ldi r18,lo8(0)
 2680 0d42 0E94 0000 		call xQueueGenericReceive
 2681 0d46 8823      		tst r24
 2682 0d48 01F4      		brne .L120
 774:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 2684               	.LM217:
 2685 0d4a 86E0      		ldi r24,lo8(6)
 2686 0d4c D701      		movw r26,r14
 2687 0d4e 5C96      		adiw r26,28
 2688 0d50 8C93      		st X,r24
 2689 0d52 5C97      		sbiw r26,28
 775:vty.c         ****         state->err1 = 1;
 2691               	.LM218:
 2692 0d54 81E0      		ldi r24,lo8(1)
 2693 0d56 90E0      		ldi r25,hi8(1)
 2694 0d58 5E96      		adiw r26,29+1
 2695 0d5a 9C93      		st X,r25
 2696 0d5c 8E93      		st -X,r24
 2697 0d5e 5D97      		sbiw r26,29
 2698 0d60 00C0      		rjmp .L110
 2699               	.L120:
 776:vty.c         ****         break;      
 2701               	.LM219:
 2702 0d62 90E0      		ldi r25,lo8(0)
 2703 0d64 40E0      		ldi r20,lo8(0)
 2704 0d66 50E0      		ldi r21,hi8(0)
 2705               	.L121:
 784:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 2707               	.LM220:
 2708 0d68 F501      		movw r30,r10
 2709 0d6a 8191      		ld r24,Z+
 2710 0d6c 5F01      		movw r10,r30
 2711               	.LBB6:
 2712               	.LBB7:
 2714               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
   5:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
   8:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  11:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  16:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  20:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  32:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /* $Id: crc16.h,v 1.4 2007/01/23 15:32:48 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  34:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  35:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  36:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  37:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** #include <stdint.h>
  38:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  39:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \file */
  40:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  41:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  42:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  43:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  44:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  45:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  46:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par References:
  47:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  48:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par
  49:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  50:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  51:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  52:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  53:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  54:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \par
  55:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  56:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  57:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  58:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  59:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     obtain a copy.
  60:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  61:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     A typical application would look like:
  62:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  63:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
  64:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     // Dallas iButton test vector.
  65:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  66:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  67:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     int
  68:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     checkcrc(void)
  69:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
  70:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  71:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  72:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  73:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  74:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  75:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return crc; // must be 0
  76:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
  77:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode
  78:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** */
  79:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  80:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
  81:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  82:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  83:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  84:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Initial value: 0xffff
  85:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  86:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  87:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  88:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  89:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  90:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
  91:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t
  92:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  93:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
  94:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	int i;
  95:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
  96:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	crc ^= a;
  97:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
  98:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	{
  99:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    if (crc & 1)
 100:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 101:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	    else
 102:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		crc = (crc >> 1);
 103:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	}
 104:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 105:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return crc;
 106:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
 107:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 108:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode */
 109:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 110:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 111:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 112:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** {
 113:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint8_t __tmp;
 114:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	uint16_t __ret;
 115:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 116:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 117:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 118:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 119:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 120:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 121:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 122:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 123:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 124:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 125:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 126:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 127:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 128:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 129:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 130:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 131:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 132:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 133:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 134:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 135:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 136:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 137:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 138:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 139:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		"eor %A0,%1"
 140:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 141:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 142:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 		: "r0"
 143:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	);
 144:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 	return __ret;
 145:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** }
 146:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 147:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** /** \ingroup util_crc
 148:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 149:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 150:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 151:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     Initial value: 0x0
 152:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 153:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 154:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 155:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 156:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 157:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \code
 158:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t
 159:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 160:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     {
 161:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         int i;
 162:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 163:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 164:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 165:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         {
 166:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****             if (crc & 0x8000)
 167:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 168:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****             else
 169:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                 crc <<= 1;
 170:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         }
 171:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 172:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****         return crc;
 173:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     }
 174:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     \endcode */
 175:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 176:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** static __inline__ uint16_t
 177:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 178:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** {
 179:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 180:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 181:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 182:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****                                 /* %3  __data */
 183:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h **** 
 184:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h ****     __asm__ __volatile__ (
 2716               	.LM221:
 2717               	/* #APP */
 2718               	 ;  184 "/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/crc16.h" 1
 2719 0d6e 5827      		eor    r21,r24
 2720 0d70 052E      		mov    __tmp_reg__,r21
 2721 0d72 0294      		swap   __tmp_reg__
 2722 0d74 802D      		mov    r24,__tmp_reg__
 2723 0d76 8F70      		andi   r24,0x0f
 2724 0d78 8527      		eor    r24,r21
 2725 0d7a 252F      		mov    r18,r21
 2726 0d7c 2025      		eor    r18,__tmp_reg__
 2727 0d7e 220F      		lsl    r18
 2728 0d80 207E      		andi   r18,0xe0
 2729 0d82 8227      		eor    r24,r18
 2730 0d84 202D      		mov    r18,__tmp_reg__
 2731 0d86 2527      		eor    r18,r21
 2732 0d88 207F      		andi   r18,0xf0
 2733 0d8a 2695      		lsr    r18
 2734 0d8c 052E      		mov    __tmp_reg__,r21
 2735 0d8e 000C      		lsl    __tmp_reg__
 2736 0d90 221F      		rol    r18
 2737 0d92 5695      		lsr    r21
 2738 0d94 5695      		lsr    r21
 2739 0d96 5695      		lsr    r21
 2740 0d98 5F71      		andi   r21,0x1f
 2741 0d9a 5227      		eor    r21,r18
 2742 0d9c 5427      		eor    r21,r20
 2743 0d9e 482F      		mov    r20,r24
 2744               		
 2745               	 ;  0 "" 2
 2746               	/* #NOAPP */
 2747               	.LBE7:
 2748               	.LBE6:
 2750               	.Ltext2:
 783:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 2752               	.LM222:
 2753 0da0 9F5F      		subi r25,lo8(-(1))
 2754 0da2 9038      		cpi r25,lo8(-128)
 2755 0da4 01F4      		brne .L121
 787:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 2757               	.LM223:
 2758 0da6 8D81      		ldd r24,Y+5
 2759 0da8 90E0      		ldi r25,lo8(0)
 2760 0daa 252F      		mov r18,r21
 2761 0dac 3327      		clr r19
 2762 0dae 8217      		cp r24,r18
 2763 0db0 9307      		cpc r25,r19
 2764 0db2 01F4      		brne .L122
 2765 0db4 8E81      		ldd r24,Y+6
 2766 0db6 90E0      		ldi r25,lo8(0)
 2767 0db8 5070      		andi r21,hi8(255)
 2768 0dba 8417      		cp r24,r20
 2769 0dbc 9507      		cpc r25,r21
 2770 0dbe 01F4      		brne .L122
 790:vty.c         ****       uartVtySendByte(ACK);      
 2772               	.LM224:
 2773 0dc0 86E0      		ldi r24,lo8(6)
 2774 0dc2 0E94 0000 		call uartVtySendByte
 2775 0dc6 4AE0      		ldi r20,lo8(10)
 2776 0dc8 942E      		mov r9,r20
 2777 0dca 00C0      		rjmp .L123
 2778               	.L122:
 794:vty.c         ****       liczbaProb--;
 2780               	.LM225:
 2781 0dcc 9A94      		dec r9
 795:vty.c         ****       nrBloku--;
 2783               	.LM226:
 2784 0dce 1150      		subi r17,lo8(-(-1))
 796:vty.c         ****       uartVtySendByte(NAK);   
 2786               	.LM227:
 2787 0dd0 85E1      		ldi r24,lo8(21)
 2788 0dd2 0E94 0000 		call uartVtySendByte
 799:vty.c         ****     if (liczbaProb == 0)
 2790               	.LM228:
 2791 0dd6 9920      		tst r9
 2792 0dd8 01F4      		brne .L123
 801:vty.c         ****       state->err1 = nrBlokuZdalny;
 2794               	.LM229:
 2795 0dda 8B81      		ldd r24,Y+3
 2796 0ddc D701      		movw r26,r14
 2797 0dde 5D96      		adiw r26,29
 2798 0de0 8C93      		st X,r24
 2799 0de2 5D97      		sbiw r26,29
 2800 0de4 5E96      		adiw r26,30
 2801 0de6 1C92      		st X,__zero_reg__
 2802 0de8 5E97      		sbiw r26,30
 802:vty.c         ****       state->err2 = nrBloku;
 2804               	.LM230:
 2805 0dea 5F96      		adiw r26,31
 2806 0dec 1C93      		st X,r17
 2807 0dee 5F97      		sbiw r26,31
 803:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2809               	.LM231:
 2810 0df0 84E0      		ldi r24,lo8(4)
 2811               	.L136:
 2812 0df2 5C96      		adiw r26,28
 2813 0df4 8C93      		st X,r24
 2814 0df6 00C0      		rjmp .L110
 2815               	.L123:
 807:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 2817               	.LM232:
 2818 0df8 8091 0000 		lds r24,xVtyRec
 2819 0dfc 9091 0000 		lds r25,(xVtyRec)+1
 2820 0e00 B301      		movw r22,r6
 2821 0e02 44E6      		ldi r20,lo8(100)
 2822 0e04 50E0      		ldi r21,hi8(100)
 2823 0e06 20E0      		ldi r18,lo8(0)
 2824 0e08 0E94 0000 		call xQueueGenericReceive
 2825 0e0c 8823      		tst r24
 2826 0e0e 01F4      		brne .L124
 2827               	.L135:
 809:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 2829               	.LM233:
 2830 0e10 82E0      		ldi r24,lo8(2)
 2831 0e12 F701      		movw r30,r14
 2832 0e14 00C0      		rjmp .L137
 2833               	.L124:
 813:vty.c         ****     if (temp1 == SOH)
 2835               	.LM234:
 2836 0e16 9981      		ldd r25,Y+1
 2837 0e18 9130      		cpi r25,lo8(1)
 2838 0e1a 01F4      		brne .L125
 815:vty.c         ****       nrBloku++;
 2840               	.LM235:
 2841 0e1c 1F5F      		subi r17,lo8(-(1))
 816:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2843               	.LM236:
 2844 0e1e 80E0      		ldi r24,lo8(fdVty)
 2845 0e20 90E0      		ldi r25,hi8(fdVty)
 2846 0e22 612F      		mov r22,r17
 2847 0e24 70E0      		ldi r23,lo8(0)
 2848 0e26 0E94 0000 		call ramDyskDodajBlokXmodem
 2849 0e2a 6C01      		movw r12,r24
 818:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2851               	.LM237:
 2852 0e2c D701      		movw r26,r14
 2853 0e2e 5C96      		adiw r26,28
 2854 0e30 1C92      		st X,__zero_reg__
 2855 0e32 5C01      		movw r10,r24
 2856 0e34 00C0      		rjmp .L126
 2857               	.L125:
 822:vty.c         ****     if (temp1 == CAN)
 2859               	.LM238:
 2860 0e36 9831      		cpi r25,lo8(24)
 2861 0e38 01F4      		brne .L127
 824:vty.c         ****       state->err1 = nrBloku;
 2863               	.LM239:
 2864 0e3a F701      		movw r30,r14
 2865 0e3c 158F      		std Z+29,r17
 2866 0e3e 168E      		std Z+30,__zero_reg__
 825:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 2868               	.LM240:
 2869 0e40 87E0      		ldi r24,lo8(7)
 2870               	.L137:
 2871 0e42 848F      		std Z+28,r24
 2872 0e44 00C0      		rjmp .L110
 2873               	.L127:
 828:vty.c         ****     if (temp1 == EOT)
 2875               	.LM241:
 2876 0e46 9430      		cpi r25,lo8(4)
 2877 0e48 01F4      		brne .L128
 830:vty.c         ****       uartVtySendByte(NAK);
 2879               	.LM242:
 2880 0e4a 85E1      		ldi r24,lo8(21)
 2881 0e4c 0E94 0000 		call uartVtySendByte
 831:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 2883               	.LM243:
 2884 0e50 8091 0000 		lds r24,xVtyRec
 2885 0e54 9091 0000 		lds r25,(xVtyRec)+1
 2886 0e58 B301      		movw r22,r6
 2887 0e5a 4AE0      		ldi r20,lo8(10)
 2888 0e5c 50E0      		ldi r21,hi8(10)
 2889 0e5e 20E0      		ldi r18,lo8(0)
 2890 0e60 0E94 0000 		call xQueueGenericReceive
 2891 0e64 8823      		tst r24
 2892 0e66 01F0      		breq .L129
 833:vty.c         ****         if (temp1 == EOT)
 2894               	.LM244:
 2895 0e68 8981      		ldd r24,Y+1
 2896 0e6a 8430      		cpi r24,lo8(4)
 2897 0e6c 01F4      		brne .L129
 834:vty.c         ****           uartVtySendByte(ACK);  
 2899               	.LM245:
 2900 0e6e 86E0      		ldi r24,lo8(6)
 2901 0e70 0E94 0000 		call uartVtySendByte
 2902               	.L129:
 836:vty.c         ****       state->errno = (uint8_t)(AllOK);
 2904               	.LM246:
 2905 0e74 D701      		movw r26,r14
 2906 0e76 5C96      		adiw r26,28
 2907 0e78 1C92      		st X,__zero_reg__
 2908 0e7a 00C0      		rjmp .L110
 2909               	.L128:
 839:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 2911               	.LM247:
 2912 0e7c 88E0      		ldi r24,lo8(8)
 2913 0e7e F701      		movw r30,r14
 2914 0e80 848F      		std Z+28,r24
 840:vty.c         ****     state->err1 = temp1;
 2916               	.LM248:
 2917 0e82 958F      		std Z+29,r25
 2918 0e84 168E      		std Z+30,__zero_reg__
 2919               	.L110:
 843:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 2921               	.LM249:
 2922 0e86 80E0      		ldi r24,lo8(fdVty)
 2923 0e88 90E0      		ldi r25,hi8(fdVty)
 2924 0e8a 0E94 0000 		call ramDyskZamknijPlik
 2925 0e8e 20E0      		ldi r18,lo8(0)
 2926 0e90 30E0      		ldi r19,hi8(0)
 2927               	.L104:
 845:vty.c         **** }
 2929               	.LM250:
 2930 0e92 C901      		movw r24,r18
 2931               	/* epilogue start */
 2932 0e94 2696      		adiw r28,6
 2933 0e96 0FB6      		in __tmp_reg__,__SREG__
 2934 0e98 F894      		cli
 2935 0e9a DEBF      		out __SP_H__,r29
 2936 0e9c 0FBE      		out __SREG__,__tmp_reg__
 2937 0e9e CDBF      		out __SP_L__,r28
 2938 0ea0 CF91      		pop r28
 2939 0ea2 DF91      		pop r29
 2940 0ea4 1F91      		pop r17
 2941 0ea6 0F91      		pop r16
 2942 0ea8 FF90      		pop r15
 2943 0eaa EF90      		pop r14
 2944 0eac DF90      		pop r13
 2945 0eae CF90      		pop r12
 2946 0eb0 BF90      		pop r11
 2947 0eb2 AF90      		pop r10
 2948 0eb4 9F90      		pop r9
 2949 0eb6 8F90      		pop r8
 2950 0eb8 7F90      		pop r7
 2951 0eba 6F90      		pop r6
 2952 0ebc 5F90      		pop r5
 2953 0ebe 4F90      		pop r4
 2954 0ec0 3F90      		pop r3
 2955 0ec2 2F90      		pop r2
 2956 0ec4 0895      		ret
 2972               	.Lscope25:
 2974               		.stabd	78,0,0
 2978               	debugFunction:
 2979               		.stabd	46,0,0
 303:vty.c         **** {
 2981               	.LM251:
 2982               	.LFBB26:
 2983 0ec6 FF92      		push r15
 2984 0ec8 0F93      		push r16
 2985 0eca 1F93      		push r17
 2986 0ecc CF93      		push r28
 2987 0ece DF93      		push r29
 2988               	/* prologue: function */
 2989               	/* frame size = 0 */
 2990 0ed0 EC01      		movw r28,r24
 304:vty.c         ****   if (state->argc < 2)
 2992               	.LM252:
 2993 0ed2 898D      		ldd r24,Y+25
 2994 0ed4 8230      		cpi r24,lo8(2)
 2995 0ed6 00F4      		brsh .+2
 2996 0ed8 00C0      		rjmp .L139
 307:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 2998               	.LM253:
 2999 0eda 82E0      		ldi r24,lo8(2)
 3000 0edc BE01      		movw r22,r28
 3001 0ede 0E94 0000 		call cmdlineGetArgInt
 3002 0ee2 F62E      		mov r15,r22
 308:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 3004               	.LM254:
 3005 0ee4 81E0      		ldi r24,lo8(1)
 3006 0ee6 BE01      		movw r22,r28
 3007 0ee8 0E94 0000 		call cmdlineGetArgStr
 3008 0eec 8C01      		movw r16,r24
 309:vty.c         ****   if (level == 0)
 3010               	.LM255:
 3011 0eee FF20      		tst r15
 3012 0ef0 01F0      		breq .+2
 3013 0ef2 00C0      		rjmp .L140
 311:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 3015               	.LM256:
 3016 0ef4 60E0      		ldi r22,lo8(__c.3394)
 3017 0ef6 70E0      		ldi r23,hi8(__c.3394)
 3018 0ef8 43E0      		ldi r20,lo8(3)
 3019 0efa 50E0      		ldi r21,hi8(3)
 3020 0efc 0E94 0000 		call strncmp_P
 3021 0f00 892B      		or r24,r25
 3022 0f02 01F4      		brne .L141
 313:vty.c         ****       setArpDebug(NULL, 0);
 3024               	.LM257:
 3025 0f04 80E0      		ldi r24,lo8(0)
 3026 0f06 90E0      		ldi r25,hi8(0)
 3027 0f08 60E0      		ldi r22,lo8(0)
 3028 0f0a 0E94 0000 		call setArpDebug
 3029 0f0e 00C0      		rjmp .L152
 3030               	.L141:
 318:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3032               	.LM258:
 3033 0f10 C801      		movw r24,r16
 3034 0f12 60E0      		ldi r22,lo8(__c.3396)
 3035 0f14 70E0      		ldi r23,hi8(__c.3396)
 3036 0f16 42E0      		ldi r20,lo8(2)
 3037 0f18 50E0      		ldi r21,hi8(2)
 3038 0f1a 0E94 0000 		call strncmp_P
 3039 0f1e 892B      		or r24,r25
 3040 0f20 01F4      		brne .L143
 320:vty.c         ****       setIpDebug(NULL, 0);
 3042               	.LM259:
 3043 0f22 80E0      		ldi r24,lo8(0)
 3044 0f24 90E0      		ldi r25,hi8(0)
 3045 0f26 60E0      		ldi r22,lo8(0)
 3046 0f28 0E94 0000 		call setIpDebug
 3047 0f2c 00C0      		rjmp .L152
 3048               	.L143:
 325:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3050               	.LM260:
 3051 0f2e C801      		movw r24,r16
 3052 0f30 60E0      		ldi r22,lo8(__c.3398)
 3053 0f32 70E0      		ldi r23,hi8(__c.3398)
 3054 0f34 42E0      		ldi r20,lo8(2)
 3055 0f36 50E0      		ldi r21,hi8(2)
 3056 0f38 0E94 0000 		call strncmp_P
 3057 0f3c 892B      		or r24,r25
 3058 0f3e 01F4      		brne .L144
 327:vty.c         ****       setIcmpDebug(NULL, 0);
 3060               	.LM261:
 3061 0f40 80E0      		ldi r24,lo8(0)
 3062 0f42 90E0      		ldi r25,hi8(0)
 3063 0f44 60E0      		ldi r22,lo8(0)
 3064 0f46 0E94 0000 		call setIcmpDebug
 3065 0f4a 00C0      		rjmp .L152
 3066               	.L144:
 332:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3068               	.LM262:
 3069 0f4c C801      		movw r24,r16
 3070 0f4e 60E0      		ldi r22,lo8(__c.3400)
 3071 0f50 70E0      		ldi r23,hi8(__c.3400)
 3072 0f52 42E0      		ldi r20,lo8(2)
 3073 0f54 50E0      		ldi r21,hi8(2)
 3074 0f56 0E94 0000 		call strncmp_P
 3075 0f5a 892B      		or r24,r25
 3076 0f5c 01F4      		brne .L145
 334:vty.c         ****       setTcpDebug(NULL, 0);
 3078               	.LM263:
 3079 0f5e 80E0      		ldi r24,lo8(0)
 3080 0f60 90E0      		ldi r25,hi8(0)
 3081 0f62 60E0      		ldi r22,lo8(0)
 3082 0f64 0E94 0000 		call setTcpDebug
 3083               	.L152:
 335:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 3085               	.LM264:
 3086 0f68 00D0      		rcall .
 3087 0f6a 00D0      		rcall .
 3088 0f6c 00D0      		rcall .
 3089 0f6e EDB7      		in r30,__SP_L__
 3090 0f70 FEB7      		in r31,__SP_H__
 3091 0f72 3196      		adiw r30,1
 3092 0f74 8A8D      		ldd r24,Y+26
 3093 0f76 9B8D      		ldd r25,Y+27
 3094 0f78 ADB7      		in r26,__SP_L__
 3095 0f7a BEB7      		in r27,__SP_H__
 3096 0f7c 1296      		adiw r26,1+1
 3097 0f7e 9C93      		st X,r25
 3098 0f80 8E93      		st -X,r24
 3099 0f82 1197      		sbiw r26,1
 3100 0f84 80E0      		ldi r24,lo8(debugDisabledInfoStr)
 3101 0f86 90E0      		ldi r25,hi8(debugDisabledInfoStr)
 3102 0f88 00C0      		rjmp .L151
 3103               	.L145:
 339:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3105               	.LM265:
 3106 0f8a C801      		movw r24,r16
 3107 0f8c 60E0      		ldi r22,lo8(__c.3402)
 3108 0f8e 70E0      		ldi r23,hi8(__c.3402)
 3109 0f90 42E0      		ldi r20,lo8(2)
 3110 0f92 50E0      		ldi r21,hi8(2)
 3111 0f94 0E94 0000 		call strncmp_P
 3112 0f98 892B      		or r24,r25
 3113 0f9a 01F0      		breq .+2
 3114 0f9c 00C0      		rjmp .L139
 341:vty.c         ****       setUdpDebug(NULL, 0);
 3116               	.LM266:
 3117 0f9e 80E0      		ldi r24,lo8(0)
 3118 0fa0 90E0      		ldi r25,hi8(0)
 3119 0fa2 60E0      		ldi r22,lo8(0)
 3120 0fa4 0E94 0000 		call setUdpDebug
 3121 0fa8 00C0      		rjmp .L152
 3122               	.L140:
 350:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 3124               	.LM267:
 3125 0faa 60E0      		ldi r22,lo8(__c.3404)
 3126 0fac 70E0      		ldi r23,hi8(__c.3404)
 3127 0fae 43E0      		ldi r20,lo8(3)
 3128 0fb0 50E0      		ldi r21,hi8(3)
 3129 0fb2 0E94 0000 		call strncmp_P
 3130 0fb6 892B      		or r24,r25
 3131 0fb8 01F4      		brne .L146
 352:vty.c         ****       setArpDebug(state->myStdInOut, level);
 3133               	.LM268:
 3134 0fba 8A8D      		ldd r24,Y+26
 3135 0fbc 9B8D      		ldd r25,Y+27
 3136 0fbe 6F2D      		mov r22,r15
 3137 0fc0 0E94 0000 		call setArpDebug
 3138 0fc4 00C0      		rjmp .L153
 3139               	.L146:
 357:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 3141               	.LM269:
 3142 0fc6 C801      		movw r24,r16
 3143 0fc8 60E0      		ldi r22,lo8(__c.3406)
 3144 0fca 70E0      		ldi r23,hi8(__c.3406)
 3145 0fcc 42E0      		ldi r20,lo8(2)
 3146 0fce 50E0      		ldi r21,hi8(2)
 3147 0fd0 0E94 0000 		call strncmp_P
 3148 0fd4 892B      		or r24,r25
 3149 0fd6 01F4      		brne .L147
 359:vty.c         ****       setIpDebug(state->myStdInOut, level);
 3151               	.LM270:
 3152 0fd8 8A8D      		ldd r24,Y+26
 3153 0fda 9B8D      		ldd r25,Y+27
 3154 0fdc 6F2D      		mov r22,r15
 3155 0fde 0E94 0000 		call setIpDebug
 3156 0fe2 00C0      		rjmp .L153
 3157               	.L147:
 364:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 3159               	.LM271:
 3160 0fe4 C801      		movw r24,r16
 3161 0fe6 60E0      		ldi r22,lo8(__c.3408)
 3162 0fe8 70E0      		ldi r23,hi8(__c.3408)
 3163 0fea 42E0      		ldi r20,lo8(2)
 3164 0fec 50E0      		ldi r21,hi8(2)
 3165 0fee 0E94 0000 		call strncmp_P
 3166 0ff2 892B      		or r24,r25
 3167 0ff4 01F4      		brne .L148
 366:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 3169               	.LM272:
 3170 0ff6 8A8D      		ldd r24,Y+26
 3171 0ff8 9B8D      		ldd r25,Y+27
 3172 0ffa 6F2D      		mov r22,r15
 3173 0ffc 0E94 0000 		call setIcmpDebug
 3174 1000 00C0      		rjmp .L153
 3175               	.L148:
 371:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 3177               	.LM273:
 3178 1002 C801      		movw r24,r16
 3179 1004 60E0      		ldi r22,lo8(__c.3410)
 3180 1006 70E0      		ldi r23,hi8(__c.3410)
 3181 1008 42E0      		ldi r20,lo8(2)
 3182 100a 50E0      		ldi r21,hi8(2)
 3183 100c 0E94 0000 		call strncmp_P
 3184 1010 892B      		or r24,r25
 3185 1012 01F4      		brne .L149
 373:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 3187               	.LM274:
 3188 1014 8A8D      		ldd r24,Y+26
 3189 1016 9B8D      		ldd r25,Y+27
 3190 1018 6F2D      		mov r22,r15
 3191 101a 0E94 0000 		call setTcpDebug
 3192               	.L153:
 374:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 3194               	.LM275:
 3195 101e 00D0      		rcall .
 3196 1020 00D0      		rcall .
 3197 1022 00D0      		rcall .
 3198 1024 EDB7      		in r30,__SP_L__
 3199 1026 FEB7      		in r31,__SP_H__
 3200 1028 3196      		adiw r30,1
 3201 102a 8A8D      		ldd r24,Y+26
 3202 102c 9B8D      		ldd r25,Y+27
 3203 102e ADB7      		in r26,__SP_L__
 3204 1030 BEB7      		in r27,__SP_H__
 3205 1032 1296      		adiw r26,1+1
 3206 1034 9C93      		st X,r25
 3207 1036 8E93      		st -X,r24
 3208 1038 1197      		sbiw r26,1
 3209 103a 80E0      		ldi r24,lo8(debugEnabledInfoStr)
 3210 103c 90E0      		ldi r25,hi8(debugEnabledInfoStr)
 3211               	.L151:
 3212 103e 9383      		std Z+3,r25
 3213 1040 8283      		std Z+2,r24
 3214 1042 1583      		std Z+5,r17
 3215 1044 0483      		std Z+4,r16
 3216 1046 0E94 0000 		call fprintf_P
 3217 104a 20E0      		ldi r18,lo8(0)
 3218 104c 30E0      		ldi r19,hi8(0)
 3219 104e 8DB7      		in r24,__SP_L__
 3220 1050 9EB7      		in r25,__SP_H__
 3221 1052 0696      		adiw r24,6
 3222 1054 0FB6      		in __tmp_reg__,__SREG__
 3223 1056 F894      		cli
 3224 1058 9EBF      		out __SP_H__,r25
 3225 105a 0FBE      		out __SREG__,__tmp_reg__
 3226 105c 8DBF      		out __SP_L__,r24
 3227 105e 00C0      		rjmp .L142
 3228               	.L149:
 378:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 3230               	.LM276:
 3231 1060 C801      		movw r24,r16
 3232 1062 60E0      		ldi r22,lo8(__c.3412)
 3233 1064 70E0      		ldi r23,hi8(__c.3412)
 3234 1066 42E0      		ldi r20,lo8(2)
 3235 1068 50E0      		ldi r21,hi8(2)
 3236 106a 0E94 0000 		call strncmp_P
 3237 106e 892B      		or r24,r25
 3238 1070 01F4      		brne .L139
 380:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 3240               	.LM277:
 3241 1072 8A8D      		ldd r24,Y+26
 3242 1074 9B8D      		ldd r25,Y+27
 3243 1076 6F2D      		mov r22,r15
 3244 1078 0E94 0000 		call setUdpDebug
 3245 107c 00C0      		rjmp .L153
 3246               	.L139:
 382:vty.c         ****       return OK_SILENT;  
 3248               	.LM278:
 3249 107e 22E0      		ldi r18,lo8(2)
 3250 1080 30E0      		ldi r19,hi8(2)
 3251               	.L142:
 387:vty.c         **** }
 3253               	.LM279:
 3254 1082 C901      		movw r24,r18
 3255               	/* epilogue start */
 3256 1084 DF91      		pop r29
 3257 1086 CF91      		pop r28
 3258 1088 1F91      		pop r17
 3259 108a 0F91      		pop r16
 3260 108c FF90      		pop r15
 3261 108e 0895      		ret
 3263               	.Lscope26:
 3265               		.stabd	78,0,0
 3269               	statusEncFunction:
 3270               		.stabd	46,0,0
 287:vty.c         **** {
 3272               	.LM280:
 3273               	.LFBB27:
 3274               	/* prologue: function */
 3275               	/* frame size = 0 */
 288:vty.c         ****   nicRegDump(state->myStdInOut);
 3277               	.LM281:
 3278 1090 FC01      		movw r30,r24
 3279 1092 828D      		ldd r24,Z+26
 3280 1094 938D      		ldd r25,Z+27
 3281 1096 0E94 0000 		call nicRegDump
 290:vty.c         **** }
 3283               	.LM282:
 3284 109a 80E0      		ldi r24,lo8(0)
 3285 109c 90E0      		ldi r25,hi8(0)
 3286               	/* epilogue start */
 3287 109e 0895      		ret
 3289               	.Lscope27:
 3291               		.stabd	78,0,0
 3295               	readRamFIleFunction:
 3296               		.stabd	46,0,0
 901:vty.c         **** {
 3298               	.LM283:
 3299               	.LFBB28:
 3300 10a0 CF92      		push r12
 3301 10a2 DF92      		push r13
 3302 10a4 EF92      		push r14
 3303 10a6 FF92      		push r15
 3304 10a8 0F93      		push r16
 3305 10aa 1F93      		push r17
 3306 10ac DF93      		push r29
 3307 10ae CF93      		push r28
 3308 10b0 0F92      		push __tmp_reg__
 3309 10b2 CDB7      		in r28,__SP_L__
 3310 10b4 DEB7      		in r29,__SP_H__
 3311               	/* prologue: function */
 3312               	/* frame size = 1 */
 3313 10b6 8C01      		movw r16,r24
 903:vty.c         ****   uint8_t znak = ' ';
 3315               	.LM284:
 3316 10b8 80E2      		ldi r24,lo8(32)
 3317 10ba 8983      		std Y+1,r24
 904:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 3319               	.LM285:
 3320 10bc 81E0      		ldi r24,lo8(1)
 3321 10be B801      		movw r22,r16
 3322 10c0 0E94 0000 		call cmdlineGetArgStr
 3323 10c4 60E0      		ldi r22,lo8(fdVty)
 3324 10c6 70E0      		ldi r23,hi8(fdVty)
 3325 10c8 0E94 0000 		call ramDyskOtworzPlik
 3326 10cc D801      		movw r26,r16
 3327 10ce 5A96      		adiw r26,26
 3328 10d0 ED90      		ld r14,X+
 3329 10d2 FC90      		ld r15,X
 3330 10d4 5B97      		sbiw r26,26+1
 3331 10d6 8823      		tst r24
 3332 10d8 01F0      		breq .L157
 906:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 3334               	.LM286:
 3335 10da 81E0      		ldi r24,lo8(1)
 3336 10dc B801      		movw r22,r16
 3337 10de 0E94 0000 		call cmdlineGetArgStr
 3338 10e2 00D0      		rcall .
 3339 10e4 00D0      		rcall .
 3340 10e6 00D0      		rcall .
 3341 10e8 EDB7      		in r30,__SP_L__
 3342 10ea FEB7      		in r31,__SP_H__
 3343 10ec 3196      		adiw r30,1
 3344 10ee ADB7      		in r26,__SP_L__
 3345 10f0 BEB7      		in r27,__SP_H__
 3346 10f2 1296      		adiw r26,1+1
 3347 10f4 FC92      		st X,r15
 3348 10f6 EE92      		st -X,r14
 3349 10f8 1197      		sbiw r26,1
 3350 10fa 20E0      		ldi r18,lo8(errorOpenFile)
 3351 10fc 30E0      		ldi r19,hi8(errorOpenFile)
 3352 10fe 3383      		std Z+3,r19
 3353 1100 2283      		std Z+2,r18
 3354 1102 9583      		std Z+5,r25
 3355 1104 8483      		std Z+4,r24
 3356 1106 0E94 0000 		call fprintf_P
 3357 110a 24E0      		ldi r18,lo8(4)
 3358 110c 30E0      		ldi r19,hi8(4)
 3359 110e EDB7      		in r30,__SP_L__
 3360 1110 FEB7      		in r31,__SP_H__
 3361 1112 3696      		adiw r30,6
 3362 1114 0FB6      		in __tmp_reg__,__SREG__
 3363 1116 F894      		cli
 3364 1118 FEBF      		out __SP_H__,r31
 3365 111a 0FBE      		out __SREG__,__tmp_reg__
 3366 111c EDBF      		out __SP_L__,r30
 3367 111e 00C0      		rjmp .L158
 3368               	.L157:
 909:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 3370               	.LM287:
 3371 1120 2091 0000 		lds r18,fdVty+4
 3372 1124 3091 0000 		lds r19,(fdVty+4)+1
 910:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 3374               	.LM288:
 3375 1128 00D0      		rcall .
 3376 112a 00D0      		rcall .
 3377 112c 00D0      		rcall .
 3378 112e ADB7      		in r26,__SP_L__
 3379 1130 BEB7      		in r27,__SP_H__
 3380 1132 1196      		adiw r26,1
 3381 1134 EDB7      		in r30,__SP_L__
 3382 1136 FEB7      		in r31,__SP_H__
 3383 1138 F282      		std Z+2,r15
 3384 113a E182      		std Z+1,r14
 3385 113c 80E0      		ldi r24,lo8(readRamFIleLenStr)
 3386 113e 90E0      		ldi r25,hi8(readRamFIleLenStr)
 3387 1140 1396      		adiw r26,2+1
 3388 1142 9C93      		st X,r25
 3389 1144 8E93      		st -X,r24
 3390 1146 1297      		sbiw r26,2
 3391 1148 F901      		movw r30,r18
 3392 114a 9281      		ldd r25,Z+2
 3393 114c 80E0      		ldi r24,lo8(0)
 3394 114e 2181      		ldd r18,Z+1
 3395 1150 820F      		add r24,r18
 3396 1152 911D      		adc r25,__zero_reg__
 3397 1154 1596      		adiw r26,4+1
 3398 1156 9C93      		st X,r25
 3399 1158 8E93      		st -X,r24
 3400 115a 1497      		sbiw r26,4
 3401 115c 0E94 0000 		call fprintf_P
 3402 1160 8DB7      		in r24,__SP_L__
 3403 1162 9EB7      		in r25,__SP_H__
 3404 1164 0696      		adiw r24,6
 3405 1166 0FB6      		in __tmp_reg__,__SREG__
 3406 1168 F894      		cli
 3407 116a 9EBF      		out __SP_H__,r25
 3408 116c 0FBE      		out __SREG__,__tmp_reg__
 3409 116e 8DBF      		out __SP_L__,r24
 913:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 3411               	.LM289:
 3412 1170 6E01      		movw r12,r28
 3413 1172 0894      		sec
 3414 1174 C11C      		adc r12,__zero_reg__
 3415 1176 D11C      		adc r13,__zero_reg__
 3416               	.L160:
 3417 1178 80E0      		ldi r24,lo8(fdVty)
 3418 117a 90E0      		ldi r25,hi8(fdVty)
 3419 117c B601      		movw r22,r12
 3420 117e 0E94 0000 		call ramDyskCzytajBajtZPliku
 3421 1182 F82E      		mov r15,r24
 915:vty.c         ****     uartVtySendByte(znak);
 3423               	.LM290:
 3424 1184 8981      		ldd r24,Y+1
 3425 1186 0E94 0000 		call uartVtySendByte
 916:vty.c         ****     if (znak == '\r')
 3427               	.LM291:
 3428 118a 8981      		ldd r24,Y+1
 3429 118c 8D30      		cpi r24,lo8(13)
 3430 118e 01F4      		brne .L159
 917:vty.c         ****       uartVtySendByte('\n');
 3432               	.LM292:
 3433 1190 8AE0      		ldi r24,lo8(10)
 3434 1192 0E94 0000 		call uartVtySendByte
 3435               	.L159:
 911:vty.c         ****   while (rezultat == 0)
 3437               	.LM293:
 3438 1196 FF20      		tst r15
 3439 1198 01F0      		breq .L160
 919:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 3441               	.LM294:
 3442 119a 00D0      		rcall .
 3443 119c 00D0      		rcall .
 3444 119e D801      		movw r26,r16
 3445 11a0 5A96      		adiw r26,26
 3446 11a2 8D91      		ld r24,X+
 3447 11a4 9C91      		ld r25,X
 3448 11a6 5B97      		sbiw r26,26+1
 3449 11a8 EDB7      		in r30,__SP_L__
 3450 11aa FEB7      		in r31,__SP_H__
 3451 11ac 9283      		std Z+2,r25
 3452 11ae 8183      		std Z+1,r24
 3453 11b0 80E0      		ldi r24,lo8(nlStr)
 3454 11b2 90E0      		ldi r25,hi8(nlStr)
 3455 11b4 9483      		std Z+4,r25
 3456 11b6 8383      		std Z+3,r24
 3457 11b8 0E94 0000 		call fprintf_P
 920:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 3459               	.LM295:
 3460 11bc 0F90      		pop __tmp_reg__
 3461 11be 0F90      		pop __tmp_reg__
 3462 11c0 0F90      		pop __tmp_reg__
 3463 11c2 0F90      		pop __tmp_reg__
 3464 11c4 80E0      		ldi r24,lo8(fdVty)
 3465 11c6 90E0      		ldi r25,hi8(fdVty)
 3466 11c8 0E94 0000 		call ramDyskZamknijPlik
 3467 11cc 20E0      		ldi r18,lo8(0)
 3468 11ce 30E0      		ldi r19,hi8(0)
 3469               	.L158:
 922:vty.c         **** }
 3471               	.LM296:
 3472 11d0 C901      		movw r24,r18
 3473               	/* epilogue start */
 3474 11d2 0F90      		pop __tmp_reg__
 3475 11d4 CF91      		pop r28
 3476 11d6 DF91      		pop r29
 3477 11d8 1F91      		pop r17
 3478 11da 0F91      		pop r16
 3479 11dc FF90      		pop r15
 3480 11de EF90      		pop r14
 3481 11e0 DF90      		pop r13
 3482 11e2 CF90      		pop r12
 3483 11e4 0895      		ret
 3488               	.Lscope28:
 3490               		.stabd	78,0,0
 3494               	writeRamFileFunction:
 3495               		.stabd	46,0,0
 870:vty.c         **** {
 3497               	.LM297:
 3498               	.LFBB29:
 3499               	/* prologue: function */
 3500               	/* frame size = 0 */
 871:vty.c         ****   ramDyskDir(state->myStdInOut);
 3502               	.LM298:
 3503 11e6 FC01      		movw r30,r24
 3504 11e8 828D      		ldd r24,Z+26
 3505 11ea 938D      		ldd r25,Z+27
 3506 11ec 0E94 0000 		call ramDyskDir
 873:vty.c         **** }
 3508               	.LM299:
 3509 11f0 80E0      		ldi r24,lo8(0)
 3510 11f2 90E0      		ldi r25,hi8(0)
 3511               	/* epilogue start */
 3512 11f4 0895      		ret
 3514               	.Lscope29:
 3516               		.stabd	78,0,0
 3520               	pokazCzasFunction:
 3521               		.stabd	46,0,0
 293:vty.c         **** {
 3523               	.LM300:
 3524               	.LFBB30:
 3525 11f6 0F93      		push r16
 3526 11f8 1F93      		push r17
 3527 11fa CF93      		push r28
 3528 11fc DF93      		push r29
 3529               	/* prologue: function */
 3530               	/* frame size = 0 */
 3531 11fe 8C01      		movw r16,r24
 294:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 3533               	.LM301:
 3534 1200 80E0      		ldi r24,lo8(czasRtc)
 3535 1202 90E0      		ldi r25,hi8(czasRtc)
 3536 1204 0E94 0000 		call readTimeDecoded
 295:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;  
 3538               	.LM302:
 3539 1208 2091 0000 		lds r18,czasRtc+2
 3540 120c 2295      		swap r18
 3541 120e 2F70      		andi r18,lo8(15)
 3542 1210 4091 0000 		lds r20,czasRtc+2
 3543 1214 4F70      		andi r20,lo8(15)
 296:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 3545               	.LM303:
 3546 1216 7091 0000 		lds r23,czasRtc+1
 3547 121a 7295      		swap r23
 3548 121c 7F70      		andi r23,lo8(15)
 3549 121e 5091 0000 		lds r21,czasRtc+1
 3550 1222 5F70      		andi r21,lo8(15)
 297:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;  
 3552               	.LM304:
 3553 1224 A091 0000 		lds r26,czasRtc
 3554 1228 A295      		swap r26
 3555 122a AF70      		andi r26,lo8(15)
 3556 122c 6091 0000 		lds r22,czasRtc
 3557 1230 6F70      		andi r22,lo8(15)
 298:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 3559               	.LM305:
 3560 1232 8DB7      		in r24,__SP_L__
 3561 1234 9EB7      		in r25,__SP_H__
 3562 1236 0A97      		sbiw r24,10
 3563 1238 0FB6      		in __tmp_reg__,__SREG__
 3564 123a F894      		cli
 3565 123c 9EBF      		out __SP_H__,r25
 3566 123e 0FBE      		out __SREG__,__tmp_reg__
 3567 1240 8DBF      		out __SP_L__,r24
 3568 1242 EDB7      		in r30,__SP_L__
 3569 1244 FEB7      		in r31,__SP_H__
 3570 1246 3196      		adiw r30,1
 3571 1248 E801      		movw r28,r16
 3572 124a 8A8D      		ldd r24,Y+26
 3573 124c 9B8D      		ldd r25,Y+27
 3574 124e CDB7      		in r28,__SP_L__
 3575 1250 DEB7      		in r29,__SP_H__
 3576 1252 9A83      		std Y+2,r25
 3577 1254 8983      		std Y+1,r24
 3578 1256 80E0      		ldi r24,lo8(__c.3364)
 3579 1258 90E0      		ldi r25,hi8(__c.3364)
 3580 125a 9383      		std Z+3,r25
 3581 125c 8283      		std Z+2,r24
 3582 125e 822F      		mov r24,r18
 3583 1260 8370      		andi r24,lo8(3)
 3584 1262 90E0      		ldi r25,lo8(0)
 3585 1264 9C01      		movw r18,r24
 3586 1266 13E0      		ldi r17,3
 3587 1268 220F      	1:	lsl r18
 3588 126a 331F      		rol r19
 3589 126c 1A95      		dec r17
 3590 126e 01F4      		brne 1b
 3591 1270 880F      		lsl r24
 3592 1272 991F      		rol r25
 3593 1274 280F      		add r18,r24
 3594 1276 391F      		adc r19,r25
 3595 1278 420F      		add r20,r18
 3596 127a 4483      		std Z+4,r20
 3597 127c 1582      		std Z+5,__zero_reg__
 3598 127e 872F      		mov r24,r23
 3599 1280 8770      		andi r24,lo8(7)
 3600 1282 90E0      		ldi r25,lo8(0)
 3601 1284 9C01      		movw r18,r24
 3602 1286 73E0      		ldi r23,3
 3603 1288 220F      	1:	lsl r18
 3604 128a 331F      		rol r19
 3605 128c 7A95      		dec r23
 3606 128e 01F4      		brne 1b
 3607 1290 880F      		lsl r24
 3608 1292 991F      		rol r25
 3609 1294 280F      		add r18,r24
 3610 1296 391F      		adc r19,r25
 3611 1298 520F      		add r21,r18
 3612 129a 5683      		std Z+6,r21
 3613 129c 1782      		std Z+7,__zero_reg__
 3614 129e 8A2F      		mov r24,r26
 3615 12a0 8770      		andi r24,lo8(7)
 3616 12a2 90E0      		ldi r25,lo8(0)
 3617 12a4 9C01      		movw r18,r24
 3618 12a6 03E0      		ldi r16,3
 3619 12a8 220F      	1:	lsl r18
 3620 12aa 331F      		rol r19
 3621 12ac 0A95      		dec r16
 3622 12ae 01F4      		brne 1b
 3623 12b0 880F      		lsl r24
 3624 12b2 991F      		rol r25
 3625 12b4 280F      		add r18,r24
 3626 12b6 391F      		adc r19,r25
 3627 12b8 620F      		add r22,r18
 3628 12ba 6087      		std Z+8,r22
 3629 12bc 1186      		std Z+9,__zero_reg__
 3630 12be 0E94 0000 		call fprintf_P
 3631 12c2 8DB7      		in r24,__SP_L__
 3632 12c4 9EB7      		in r25,__SP_H__
 3633 12c6 0A96      		adiw r24,10
 3634 12c8 0FB6      		in __tmp_reg__,__SREG__
 3635 12ca F894      		cli
 3636 12cc 9EBF      		out __SP_H__,r25
 3637 12ce 0FBE      		out __SREG__,__tmp_reg__
 3638 12d0 8DBF      		out __SP_L__,r24
 300:vty.c         **** }
 3640               	.LM306:
 3641 12d2 80E0      		ldi r24,lo8(0)
 3642 12d4 90E0      		ldi r25,hi8(0)
 3643               	/* epilogue start */
 3644 12d6 DF91      		pop r29
 3645 12d8 CF91      		pop r28
 3646 12da 1F91      		pop r17
 3647 12dc 0F91      		pop r16
 3648 12de 0895      		ret
 3650               	.Lscope30:
 3652               		.stabd	78,0,0
 3656               	helpFunction:
 3657               		.stabd	46,0,0
 503:vty.c         **** {
 3659               	.LM307:
 3660               	.LFBB31:
 3661               	/* prologue: function */
 3662               	/* frame size = 0 */
 504:vty.c         ****   cmdPrintHelp(state);
 3664               	.LM308:
 3665 12e0 0E94 0000 		call cmdPrintHelp
 506:vty.c         **** }
 3667               	.LM309:
 3668 12e4 80E0      		ldi r24,lo8(0)
 3669 12e6 90E0      		ldi r25,hi8(0)
 3670               	/* epilogue start */
 3671 12e8 0895      		ret
 3673               	.Lscope31:
 3675               		.stabd	78,0,0
 3678               	.global	printStatus
 3680               	printStatus:
 3681               		.stabd	46,0,0
 207:vty.c         **** {
 3683               	.LM310:
 3684               	.LFBB32:
 3685 12ea CF93      		push r28
 3686 12ec DF93      		push r29
 3687               	/* prologue: function */
 3688               	/* frame size = 0 */
 3689 12ee EC01      		movw r28,r24
 208:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n")); 
 3691               	.LM311:
 3692 12f0 00D0      		rcall .
 3693 12f2 00D0      		rcall .
 3694 12f4 ADB7      		in r26,__SP_L__
 3695 12f6 BEB7      		in r27,__SP_H__
 3696 12f8 1296      		adiw r26,1+1
 3697 12fa 9C93      		st X,r25
 3698 12fc 8E93      		st -X,r24
 3699 12fe 1197      		sbiw r26,1
 3700 1300 80E0      		ldi r24,lo8(__c.3314)
 3701 1302 90E0      		ldi r25,hi8(__c.3314)
 3702 1304 1496      		adiw r26,3+1
 3703 1306 9C93      		st X,r25
 3704 1308 8E93      		st -X,r24
 3705 130a 1397      		sbiw r26,3
 3706 130c 0E94 0000 		call fprintf_P
 210:vty.c         ****   fprintf_P(stream, systemStateStr);
 3708               	.LM312:
 3709 1310 EDB7      		in r30,__SP_L__
 3710 1312 FEB7      		in r31,__SP_H__
 3711 1314 D283      		std Z+2,r29
 3712 1316 C183      		std Z+1,r28
 3713 1318 80E0      		ldi r24,lo8(systemStateStr)
 3714 131a 90E0      		ldi r25,hi8(systemStateStr)
 3715 131c 9483      		std Z+4,r25
 3716 131e 8383      		std Z+3,r24
 3717 1320 0E94 0000 		call fprintf_P
 211:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 3719               	.LM313:
 3720 1324 0F90      		pop __tmp_reg__
 3721 1326 0F90      		pop __tmp_reg__
 3722 1328 0F90      		pop __tmp_reg__
 3723 132a 0F90      		pop __tmp_reg__
 3724 132c 0E94 0000 		call uxTaskGetNumberOfTasks
 3725 1330 00D0      		rcall .
 3726 1332 00D0      		rcall .
 3727 1334 00D0      		rcall .
 3728 1336 EDB7      		in r30,__SP_L__
 3729 1338 FEB7      		in r31,__SP_H__
 3730 133a 3196      		adiw r30,1
 3731 133c ADB7      		in r26,__SP_L__
 3732 133e BEB7      		in r27,__SP_H__
 3733 1340 1296      		adiw r26,1+1
 3734 1342 DC93      		st X,r29
 3735 1344 CE93      		st -X,r28
 3736 1346 1197      		sbiw r26,1
 3737 1348 20E0      		ldi r18,lo8(statusNumberOfTasksStr)
 3738 134a 30E0      		ldi r19,hi8(statusNumberOfTasksStr)
 3739 134c 3383      		std Z+3,r19
 3740 134e 2283      		std Z+2,r18
 3741 1350 8483      		std Z+4,r24
 3742 1352 1582      		std Z+5,__zero_reg__
 3743 1354 0E94 0000 		call fprintf_P
 212:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 3745               	.LM314:
 3746 1358 EDB7      		in r30,__SP_L__
 3747 135a FEB7      		in r31,__SP_H__
 3748 135c 3696      		adiw r30,6
 3749 135e 0FB6      		in __tmp_reg__,__SREG__
 3750 1360 F894      		cli
 3751 1362 FEBF      		out __SP_H__,r31
 3752 1364 0FBE      		out __SREG__,__tmp_reg__
 3753 1366 EDBF      		out __SP_L__,r30
 3754 1368 0E94 0000 		call xPortGetFreeHeapSize
 3755 136c 2DB7      		in r18,__SP_L__
 3756 136e 3EB7      		in r19,__SP_H__
 3757 1370 2850      		subi r18,lo8(-(-8))
 3758 1372 3040      		sbci r19,hi8(-(-8))
 3759 1374 0FB6      		in __tmp_reg__,__SREG__
 3760 1376 F894      		cli
 3761 1378 3EBF      		out __SP_H__,r19
 3762 137a 0FBE      		out __SREG__,__tmp_reg__
 3763 137c 2DBF      		out __SP_L__,r18
 3764 137e EDB7      		in r30,__SP_L__
 3765 1380 FEB7      		in r31,__SP_H__
 3766 1382 3196      		adiw r30,1
 3767 1384 ADB7      		in r26,__SP_L__
 3768 1386 BEB7      		in r27,__SP_H__
 3769 1388 1296      		adiw r26,1+1
 3770 138a DC93      		st X,r29
 3771 138c CE93      		st -X,r28
 3772 138e 1197      		sbiw r26,1
 3773 1390 20E0      		ldi r18,lo8(statusStaticHeapStateStr)
 3774 1392 30E0      		ldi r19,hi8(statusStaticHeapStateStr)
 3775 1394 3383      		std Z+3,r19
 3776 1396 2283      		std Z+2,r18
 3777 1398 9583      		std Z+5,r25
 3778 139a 8483      		std Z+4,r24
 3779 139c 8CE1      		ldi r24,lo8(3100)
 3780 139e 9CE0      		ldi r25,hi8(3100)
 3781 13a0 9783      		std Z+7,r25
 3782 13a2 8683      		std Z+6,r24
 3783 13a4 0E94 0000 		call fprintf_P
 213:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 3785               	.LM315:
 3786 13a8 EDB7      		in r30,__SP_L__
 3787 13aa FEB7      		in r31,__SP_H__
 3788 13ac 3896      		adiw r30,8
 3789 13ae 0FB6      		in __tmp_reg__,__SREG__
 3790 13b0 F894      		cli
 3791 13b2 FEBF      		out __SP_H__,r31
 3792 13b4 0FBE      		out __SREG__,__tmp_reg__
 3793 13b6 EDBF      		out __SP_L__,r30
 3794 13b8 0E94 0000 		call xmallocAvailable
 3795 13bc 2DB7      		in r18,__SP_L__
 3796 13be 3EB7      		in r19,__SP_H__
 3797 13c0 2850      		subi r18,lo8(-(-8))
 3798 13c2 3040      		sbci r19,hi8(-(-8))
 3799 13c4 0FB6      		in __tmp_reg__,__SREG__
 3800 13c6 F894      		cli
 3801 13c8 3EBF      		out __SP_H__,r19
 3802 13ca 0FBE      		out __SREG__,__tmp_reg__
 3803 13cc 2DBF      		out __SP_L__,r18
 3804 13ce EDB7      		in r30,__SP_L__
 3805 13d0 FEB7      		in r31,__SP_H__
 3806 13d2 3196      		adiw r30,1
 3807 13d4 ADB7      		in r26,__SP_L__
 3808 13d6 BEB7      		in r27,__SP_H__
 3809 13d8 1296      		adiw r26,1+1
 3810 13da DC93      		st X,r29
 3811 13dc CE93      		st -X,r28
 3812 13de 1197      		sbiw r26,1
 3813 13e0 20E0      		ldi r18,lo8(statusDynamicHeapStateStr)
 3814 13e2 30E0      		ldi r19,hi8(statusDynamicHeapStateStr)
 3815 13e4 3383      		std Z+3,r19
 3816 13e6 2283      		std Z+2,r18
 3817 13e8 9583      		std Z+5,r25
 3818 13ea 8483      		std Z+4,r24
 3819 13ec 80E0      		ldi r24,lo8(5888)
 3820 13ee 97E1      		ldi r25,hi8(5888)
 3821 13f0 9783      		std Z+7,r25
 3822 13f2 8683      		std Z+6,r24
 3823 13f4 0E94 0000 		call fprintf_P
 214:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature); 
 3825               	.LM316:
 3826 13f8 2091 0000 		lds r18,temperature
 3827 13fc 0F90      		pop __tmp_reg__
 3828 13fe 0F90      		pop __tmp_reg__
 3829 1400 EDB7      		in r30,__SP_L__
 3830 1402 FEB7      		in r31,__SP_H__
 3831 1404 3196      		adiw r30,1
 3832 1406 ADB7      		in r26,__SP_L__
 3833 1408 BEB7      		in r27,__SP_H__
 3834 140a 1296      		adiw r26,1+1
 3835 140c DC93      		st X,r29
 3836 140e CE93      		st -X,r28
 3837 1410 1197      		sbiw r26,1
 3838 1412 80E0      		ldi r24,lo8(statusTemperatureStr)
 3839 1414 90E0      		ldi r25,hi8(statusTemperatureStr)
 3840 1416 9383      		std Z+3,r25
 3841 1418 8283      		std Z+2,r24
 3842 141a 2483      		std Z+4,r18
 3843 141c 1582      		std Z+5,__zero_reg__
 3844 141e 0E94 0000 		call fprintf_P
 215:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage); 
 3846               	.LM317:
 3847 1422 2091 0000 		lds r18,voltage
 3848 1426 EDB7      		in r30,__SP_L__
 3849 1428 FEB7      		in r31,__SP_H__
 3850 142a 3196      		adiw r30,1
 3851 142c ADB7      		in r26,__SP_L__
 3852 142e BEB7      		in r27,__SP_H__
 3853 1430 1296      		adiw r26,1+1
 3854 1432 DC93      		st X,r29
 3855 1434 CE93      		st -X,r28
 3856 1436 1197      		sbiw r26,1
 3857 1438 80E0      		ldi r24,lo8(statusVoltageStr)
 3858 143a 90E0      		ldi r25,hi8(statusVoltageStr)
 3859 143c 9383      		std Z+3,r25
 3860 143e 8283      		std Z+2,r24
 3861 1440 2483      		std Z+4,r18
 3862 1442 1582      		std Z+5,__zero_reg__
 3863 1444 0E94 0000 		call fprintf_P
 217:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 3865               	.LM318:
 3866 1448 EDB7      		in r30,__SP_L__
 3867 144a FEB7      		in r31,__SP_H__
 3868 144c 3696      		adiw r30,6
 3869 144e 0FB6      		in __tmp_reg__,__SREG__
 3870 1450 F894      		cli
 3871 1452 FEBF      		out __SP_H__,r31
 3872 1454 0FBE      		out __SREG__,__tmp_reg__
 3873 1456 EDBF      		out __SP_L__,r30
 3874 1458 0E94 0000 		call ramDyskLiczbaWolnychKlastrow
 218:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 3876               	.LM319:
 3877 145c 2DB7      		in r18,__SP_L__
 3878 145e 3EB7      		in r19,__SP_H__
 3879 1460 2850      		subi r18,lo8(-(-8))
 3880 1462 3040      		sbci r19,hi8(-(-8))
 3881 1464 0FB6      		in __tmp_reg__,__SREG__
 3882 1466 F894      		cli
 3883 1468 3EBF      		out __SP_H__,r19
 3884 146a 0FBE      		out __SREG__,__tmp_reg__
 3885 146c 2DBF      		out __SP_L__,r18
 3886 146e EDB7      		in r30,__SP_L__
 3887 1470 FEB7      		in r31,__SP_H__
 3888 1472 3196      		adiw r30,1
 3889 1474 ADB7      		in r26,__SP_L__
 3890 1476 BEB7      		in r27,__SP_H__
 3891 1478 1296      		adiw r26,1+1
 3892 147a DC93      		st X,r29
 3893 147c CE93      		st -X,r28
 3894 147e 1197      		sbiw r26,1
 3895 1480 20E0      		ldi r18,lo8(statusRamDiskStateStr)
 3896 1482 30E0      		ldi r19,hi8(statusRamDiskStateStr)
 3897 1484 3383      		std Z+3,r19
 3898 1486 2283      		std Z+2,r18
 3899 1488 8483      		std Z+4,r24
 3900 148a 1582      		std Z+5,__zero_reg__
 3901 148c 80E8      		ldi r24,lo8(128)
 3902 148e 90E0      		ldi r25,hi8(128)
 3903 1490 9783      		std Z+7,r25
 3904 1492 8683      		std Z+6,r24
 3905 1494 0E94 0000 		call fprintf_P
 222:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 3907               	.LM320:
 3908 1498 0F90      		pop __tmp_reg__
 3909 149a 0F90      		pop __tmp_reg__
 3910 149c 0F90      		pop __tmp_reg__
 3911 149e 0F90      		pop __tmp_reg__
 3912 14a0 EDB7      		in r30,__SP_L__
 3913 14a2 FEB7      		in r31,__SP_H__
 3914 14a4 D283      		std Z+2,r29
 3915 14a6 C183      		std Z+1,r28
 3916 14a8 80E0      		ldi r24,lo8(systemRamConfigStr)
 3917 14aa 90E0      		ldi r25,hi8(systemRamConfigStr)
 3918 14ac 9483      		std Z+4,r25
 3919 14ae 8383      		std Z+3,r24
 3920 14b0 0E94 0000 		call fprintf_P
 224:vty.c         ****   fprintf_P(stream, statusMacStr);
 3922               	.LM321:
 3923 14b4 ADB7      		in r26,__SP_L__
 3924 14b6 BEB7      		in r27,__SP_H__
 3925 14b8 1296      		adiw r26,1+1
 3926 14ba DC93      		st X,r29
 3927 14bc CE93      		st -X,r28
 3928 14be 1197      		sbiw r26,1
 3929 14c0 80E0      		ldi r24,lo8(statusMacStr)
 3930 14c2 90E0      		ldi r25,hi8(statusMacStr)
 3931 14c4 1496      		adiw r26,3+1
 3932 14c6 9C93      		st X,r25
 3933 14c8 8E93      		st -X,r24
 3934 14ca 1397      		sbiw r26,3
 3935 14cc 0E94 0000 		call fprintf_P
 225:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 3937               	.LM322:
 3938 14d0 0F90      		pop __tmp_reg__
 3939 14d2 0F90      		pop __tmp_reg__
 3940 14d4 0F90      		pop __tmp_reg__
 3941 14d6 0F90      		pop __tmp_reg__
 3942 14d8 CE01      		movw r24,r28
 3943 14da 60E0      		ldi r22,lo8(nicState+2)
 3944 14dc 70E0      		ldi r23,hi8(nicState+2)
 3945 14de 0E94 0000 		call netPrintEthAddr
 226:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3947               	.LM323:
 3948 14e2 00D0      		rcall .
 3949 14e4 00D0      		rcall .
 3950 14e6 EDB7      		in r30,__SP_L__
 3951 14e8 FEB7      		in r31,__SP_H__
 3952 14ea D283      		std Z+2,r29
 3953 14ec C183      		std Z+1,r28
 3954 14ee 80E0      		ldi r24,lo8(__c.3317)
 3955 14f0 90E0      		ldi r25,hi8(__c.3317)
 3956 14f2 9483      		std Z+4,r25
 3957 14f4 8383      		std Z+3,r24
 3958 14f6 0E94 0000 		call fprintf_P
 228:vty.c         ****   fprintf_P(stream, statusIpStr);
 3960               	.LM324:
 3961 14fa ADB7      		in r26,__SP_L__
 3962 14fc BEB7      		in r27,__SP_H__
 3963 14fe 1296      		adiw r26,1+1
 3964 1500 DC93      		st X,r29
 3965 1502 CE93      		st -X,r28
 3966 1504 1197      		sbiw r26,1
 3967 1506 80E0      		ldi r24,lo8(statusIpStr)
 3968 1508 90E0      		ldi r25,hi8(statusIpStr)
 3969 150a 1496      		adiw r26,3+1
 3970 150c 9C93      		st X,r25
 3971 150e 8E93      		st -X,r24
 3972 1510 1397      		sbiw r26,3
 3973 1512 0E94 0000 		call fprintf_P
 229:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 3975               	.LM325:
 3976 1516 0F90      		pop __tmp_reg__
 3977 1518 0F90      		pop __tmp_reg__
 3978 151a 0F90      		pop __tmp_reg__
 3979 151c 0F90      		pop __tmp_reg__
 3980 151e 0E94 0000 		call ipGetConfig
 3981 1522 FC01      		movw r30,r24
 3982 1524 4081      		ld r20,Z
 3983 1526 5181      		ldd r21,Z+1
 3984 1528 6281      		ldd r22,Z+2
 3985 152a 7381      		ldd r23,Z+3
 3986 152c CE01      		movw r24,r28
 3987 152e 0E94 0000 		call netPrintIPAddr
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3989               	.LM326:
 3990 1532 00D0      		rcall .
 3991 1534 00D0      		rcall .
 3992 1536 EDB7      		in r30,__SP_L__
 3993 1538 FEB7      		in r31,__SP_H__
 3994 153a D283      		std Z+2,r29
 3995 153c C183      		std Z+1,r28
 3996 153e 80E0      		ldi r24,lo8(__c.3319)
 3997 1540 90E0      		ldi r25,hi8(__c.3319)
 3998 1542 9483      		std Z+4,r25
 3999 1544 8383      		std Z+3,r24
 4000 1546 0E94 0000 		call fprintf_P
 232:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 4002               	.LM327:
 4003 154a ADB7      		in r26,__SP_L__
 4004 154c BEB7      		in r27,__SP_H__
 4005 154e 1296      		adiw r26,1+1
 4006 1550 DC93      		st X,r29
 4007 1552 CE93      		st -X,r28
 4008 1554 1197      		sbiw r26,1
 4009 1556 80E0      		ldi r24,lo8(statusIpMaskStr)
 4010 1558 90E0      		ldi r25,hi8(statusIpMaskStr)
 4011 155a 1496      		adiw r26,3+1
 4012 155c 9C93      		st X,r25
 4013 155e 8E93      		st -X,r24
 4014 1560 1397      		sbiw r26,3
 4015 1562 0E94 0000 		call fprintf_P
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 4017               	.LM328:
 4018 1566 0F90      		pop __tmp_reg__
 4019 1568 0F90      		pop __tmp_reg__
 4020 156a 0F90      		pop __tmp_reg__
 4021 156c 0F90      		pop __tmp_reg__
 4022 156e 0E94 0000 		call ipGetConfig
 4023 1572 FC01      		movw r30,r24
 4024 1574 4481      		ldd r20,Z+4
 4025 1576 5581      		ldd r21,Z+5
 4026 1578 6681      		ldd r22,Z+6
 4027 157a 7781      		ldd r23,Z+7
 4028 157c CE01      		movw r24,r28
 4029 157e 0E94 0000 		call netPrintIPAddr
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4031               	.LM329:
 4032 1582 00D0      		rcall .
 4033 1584 00D0      		rcall .
 4034 1586 ADB7      		in r26,__SP_L__
 4035 1588 BEB7      		in r27,__SP_H__
 4036 158a 1296      		adiw r26,1+1
 4037 158c DC93      		st X,r29
 4038 158e CE93      		st -X,r28
 4039 1590 1197      		sbiw r26,1
 4040 1592 80E0      		ldi r24,lo8(__c.3321)
 4041 1594 90E0      		ldi r25,hi8(__c.3321)
 4042 1596 1496      		adiw r26,3+1
 4043 1598 9C93      		st X,r25
 4044 159a 8E93      		st -X,r24
 4045 159c 1397      		sbiw r26,3
 4046 159e 0E94 0000 		call fprintf_P
 236:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 4048               	.LM330:
 4049 15a2 EDB7      		in r30,__SP_L__
 4050 15a4 FEB7      		in r31,__SP_H__
 4051 15a6 D283      		std Z+2,r29
 4052 15a8 C183      		std Z+1,r28
 4053 15aa 80E0      		ldi r24,lo8(statusIpGwStr)
 4054 15ac 90E0      		ldi r25,hi8(statusIpGwStr)
 4055 15ae 9483      		std Z+4,r25
 4056 15b0 8383      		std Z+3,r24
 4057 15b2 0E94 0000 		call fprintf_P
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 4059               	.LM331:
 4060 15b6 0F90      		pop __tmp_reg__
 4061 15b8 0F90      		pop __tmp_reg__
 4062 15ba 0F90      		pop __tmp_reg__
 4063 15bc 0F90      		pop __tmp_reg__
 4064 15be 0E94 0000 		call ipGetConfig
 4065 15c2 DC01      		movw r26,r24
 4066 15c4 1896      		adiw r26,8
 4067 15c6 4D91      		ld r20,X+
 4068 15c8 5D91      		ld r21,X+
 4069 15ca 6D91      		ld r22,X+
 4070 15cc 7C91      		ld r23,X
 4071 15ce 1B97      		sbiw r26,8+3
 4072 15d0 CE01      		movw r24,r28
 4073 15d2 0E94 0000 		call netPrintIPAddr
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 4075               	.LM332:
 4076 15d6 00D0      		rcall .
 4077 15d8 00D0      		rcall .
 4078 15da EDB7      		in r30,__SP_L__
 4079 15dc FEB7      		in r31,__SP_H__
 4080 15de D283      		std Z+2,r29
 4081 15e0 C183      		std Z+1,r28
 4082 15e2 80E0      		ldi r24,lo8(__c.3323)
 4083 15e4 90E0      		ldi r25,hi8(__c.3323)
 4084 15e6 9483      		std Z+4,r25
 4085 15e8 8383      		std Z+3,r24
 4086 15ea 0E94 0000 		call fprintf_P
 241:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 4088               	.LM333:
 4089 15ee ADB7      		in r26,__SP_L__
 4090 15f0 BEB7      		in r27,__SP_H__
 4091 15f2 1296      		adiw r26,1+1
 4092 15f4 DC93      		st X,r29
 4093 15f6 CE93      		st -X,r28
 4094 15f8 1197      		sbiw r26,1
 4095 15fa 80E0      		ldi r24,lo8(statusRs485listStr)
 4096 15fc 90E0      		ldi r25,hi8(statusRs485listStr)
 4097 15fe 1496      		adiw r26,3+1
 4098 1600 9C93      		st X,r25
 4099 1602 8E93      		st -X,r24
 4100 1604 1397      		sbiw r26,3
 4101 1606 0E94 0000 		call fprintf_P
 242:vty.c         ****   tmp = printRs485devices(stream);
 4103               	.LM334:
 4104 160a 0F90      		pop __tmp_reg__
 4105 160c 0F90      		pop __tmp_reg__
 4106 160e 0F90      		pop __tmp_reg__
 4107 1610 0F90      		pop __tmp_reg__
 4108 1612 CE01      		movw r24,r28
 4109 1614 0E94 0000 		call printRs485devices
 243:vty.c         ****   if (tmp == 0)
 4111               	.LM335:
 4112 1618 8823      		tst r24
 4113 161a 01F4      		brne .L170
 244:vty.c         ****     fprintf_P(stream, statusNoRs485Dev);  
 4115               	.LM336:
 4116 161c 00D0      		rcall .
 4117 161e 00D0      		rcall .
 4118 1620 EDB7      		in r30,__SP_L__
 4119 1622 FEB7      		in r31,__SP_H__
 4120 1624 D283      		std Z+2,r29
 4121 1626 C183      		std Z+1,r28
 4122 1628 80E0      		ldi r24,lo8(statusNoRs485Dev)
 4123 162a 90E0      		ldi r25,hi8(statusNoRs485Dev)
 4124 162c 9483      		std Z+4,r25
 4125 162e 8383      		std Z+3,r24
 4126 1630 0E94 0000 		call fprintf_P
 4127 1634 0F90      		pop __tmp_reg__
 4128 1636 0F90      		pop __tmp_reg__
 4129 1638 0F90      		pop __tmp_reg__
 4130 163a 0F90      		pop __tmp_reg__
 4131               	.L170:
 247:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 4133               	.LM337:
 4134 163c 00D0      		rcall .
 4135 163e 00D0      		rcall .
 4136 1640 ADB7      		in r26,__SP_L__
 4137 1642 BEB7      		in r27,__SP_H__
 4138 1644 1296      		adiw r26,1+1
 4139 1646 DC93      		st X,r29
 4140 1648 CE93      		st -X,r28
 4141 164a 1197      		sbiw r26,1
 4142 164c 80E0      		ldi r24,lo8(statusLockerSensorsStr)
 4143 164e 90E0      		ldi r25,hi8(statusLockerSensorsStr)
 4144 1650 1496      		adiw r26,3+1
 4145 1652 9C93      		st X,r25
 4146 1654 8E93      		st -X,r24
 4147 1656 1397      		sbiw r26,3
 4148 1658 0E94 0000 		call fprintf_P
 248:vty.c         ****   tmp = printLockers(stream);
 4150               	.LM338:
 4151 165c 0F90      		pop __tmp_reg__
 4152 165e 0F90      		pop __tmp_reg__
 4153 1660 0F90      		pop __tmp_reg__
 4154 1662 0F90      		pop __tmp_reg__
 4155 1664 CE01      		movw r24,r28
 4156 1666 0E94 0000 		call printLockers
 249:vty.c         ****   if (tmp == 0)
 4158               	.LM339:
 4159 166a 8823      		tst r24
 4160 166c 01F4      		brne .L171
 250:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 4162               	.LM340:
 4163 166e 00D0      		rcall .
 4164 1670 00D0      		rcall .
 4165 1672 EDB7      		in r30,__SP_L__
 4166 1674 FEB7      		in r31,__SP_H__
 4167 1676 D283      		std Z+2,r29
 4168 1678 C183      		std Z+1,r28
 4169 167a 80E0      		ldi r24,lo8(statusLockerSensorsDisStr)
 4170 167c 90E0      		ldi r25,hi8(statusLockerSensorsDisStr)
 4171 167e 9483      		std Z+4,r25
 4172 1680 8383      		std Z+3,r24
 4173 1682 0E94 0000 		call fprintf_P
 4174 1686 0F90      		pop __tmp_reg__
 4175 1688 0F90      		pop __tmp_reg__
 4176 168a 0F90      		pop __tmp_reg__
 4177 168c 0F90      		pop __tmp_reg__
 4178               	.L171:
 259:vty.c         ****   udpPrintStatus(stream);
 4180               	.LM341:
 4181 168e CE01      		movw r24,r28
 4182 1690 0E94 0000 		call udpPrintStatus
 4183               	/* epilogue start */
 261:vty.c         **** }
 4185               	.LM342:
 4186 1694 DF91      		pop r29
 4187 1696 CF91      		pop r28
 4188 1698 0895      		ret
 4190               	.Lscope32:
 4192               		.stabd	78,0,0
 4196               	statusFunction:
 4197               		.stabd	46,0,0
 267:vty.c         **** {
 4199               	.LM343:
 4200               	.LFBB33:
 4201 169a EF92      		push r14
 4202 169c FF92      		push r15
 4203 169e 0F93      		push r16
 4204 16a0 1F93      		push r17
 4205 16a2 DF93      		push r29
 4206 16a4 CF93      		push r28
 4207 16a6 CDB7      		in r28,__SP_L__
 4208 16a8 DEB7      		in r29,__SP_H__
 4209 16aa 2E97      		sbiw r28,14
 4210 16ac 0FB6      		in __tmp_reg__,__SREG__
 4211 16ae F894      		cli
 4212 16b0 DEBF      		out __SP_H__,r29
 4213 16b2 0FBE      		out __SREG__,__tmp_reg__
 4214 16b4 CDBF      		out __SP_L__,r28
 4215               	/* prologue: function */
 4216               	/* frame size = 14 */
 4217 16b6 7C01      		movw r14,r24
 268:vty.c         ****   if (state->argc < 1)
 4219               	.LM344:
 4220 16b8 DC01      		movw r26,r24
 4221 16ba 5996      		adiw r26,25
 4222 16bc 8C91      		ld r24,X
 4223 16be 5997      		sbiw r26,25
 4224 16c0 8823      		tst r24
 4225 16c2 01F4      		brne .L174
 270:vty.c         ****     printStatus(state->myStdInOut);
 4227               	.LM345:
 4228 16c4 5A96      		adiw r26,26
 4229 16c6 8D91      		ld r24,X+
 4230 16c8 9C91      		ld r25,X
 4231 16ca 5B97      		sbiw r26,26+1
 4232 16cc 0E94 0000 		call printStatus
 4233 16d0 00C0      		rjmp .L178
 4234               	.L174:
 275:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 4236               	.LM346:
 4237 16d2 81E0      		ldi r24,lo8(1)
 4238 16d4 B701      		movw r22,r14
 4239 16d6 0E94 0000 		call cmdlineGetArgStr
 4240 16da 60E0      		ldi r22,lo8(fdVty)
 4241 16dc 70E0      		ldi r23,hi8(fdVty)
 4242 16de 8E01      		movw r16,r28
 4243 16e0 0F5F      		subi r16,lo8(-(1))
 4244 16e2 1F4F      		sbci r17,hi8(-(1))
 4245 16e4 A801      		movw r20,r16
 4246 16e6 23E0      		ldi r18,lo8(3)
 4247 16e8 0E94 0000 		call ramDyskOtworzPlikStdIo
 4248 16ec 8823      		tst r24
 4249 16ee 01F0      		breq .L176
 277:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 4251               	.LM347:
 4252 16f0 F701      		movw r30,r14
 4253 16f2 028D      		ldd r16,Z+26
 4254 16f4 138D      		ldd r17,Z+27
 4255 16f6 81E0      		ldi r24,lo8(1)
 4256 16f8 B701      		movw r22,r14
 4257 16fa 0E94 0000 		call cmdlineGetArgStr
 4258 16fe 00D0      		rcall .
 4259 1700 00D0      		rcall .
 4260 1702 00D0      		rcall .
 4261 1704 EDB7      		in r30,__SP_L__
 4262 1706 FEB7      		in r31,__SP_H__
 4263 1708 3196      		adiw r30,1
 4264 170a ADB7      		in r26,__SP_L__
 4265 170c BEB7      		in r27,__SP_H__
 4266 170e 1296      		adiw r26,1+1
 4267 1710 1C93      		st X,r17
 4268 1712 0E93      		st -X,r16
 4269 1714 1197      		sbiw r26,1
 4270 1716 20E0      		ldi r18,lo8(errorOpenFile)
 4271 1718 30E0      		ldi r19,hi8(errorOpenFile)
 4272 171a 3383      		std Z+3,r19
 4273 171c 2283      		std Z+2,r18
 4274 171e 9583      		std Z+5,r25
 4275 1720 8483      		std Z+4,r24
 4276 1722 0E94 0000 		call fprintf_P
 4277 1726 24E0      		ldi r18,lo8(4)
 4278 1728 30E0      		ldi r19,hi8(4)
 4279 172a EDB7      		in r30,__SP_L__
 4280 172c FEB7      		in r31,__SP_H__
 4281 172e 3696      		adiw r30,6
 4282 1730 0FB6      		in __tmp_reg__,__SREG__
 4283 1732 F894      		cli
 4284 1734 FEBF      		out __SP_H__,r31
 4285 1736 0FBE      		out __SREG__,__tmp_reg__
 4286 1738 EDBF      		out __SP_L__,r30
 4287 173a 00C0      		rjmp .L175
 4288               	.L176:
 281:vty.c         ****   printStatus(&stream);
 4290               	.LM348:
 4291 173c C801      		movw r24,r16
 4292 173e 0E94 0000 		call printStatus
 282:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 4294               	.LM349:
 4295 1742 C801      		movw r24,r16
 4296 1744 0E94 0000 		call ramDyskZamknijPlikStdIo
 4297               	.L178:
 4298 1748 20E0      		ldi r18,lo8(0)
 4299 174a 30E0      		ldi r19,hi8(0)
 4300               	.L175:
 284:vty.c         **** }
 4302               	.LM350:
 4303 174c C901      		movw r24,r18
 4304               	/* epilogue start */
 4305 174e 2E96      		adiw r28,14
 4306 1750 0FB6      		in __tmp_reg__,__SREG__
 4307 1752 F894      		cli
 4308 1754 DEBF      		out __SP_H__,r29
 4309 1756 0FBE      		out __SREG__,__tmp_reg__
 4310 1758 CDBF      		out __SP_L__,r28
 4311 175a CF91      		pop r28
 4312 175c DF91      		pop r29
 4313 175e 1F91      		pop r17
 4314 1760 0F91      		pop r16
 4315 1762 FF90      		pop r15
 4316 1764 EF90      		pop r14
 4317 1766 0895      		ret
 4322               	.Lscope33:
 4324               		.stabd	78,0,0
 4328               	.global	VtyInit
 4330               	VtyInit:
 4331               		.stabd	46,0,0
 160:vty.c         **** {
 4333               	.LM351:
 4334               	.LFBB34:
 4335 1768 EF92      		push r14
 4336 176a 0F93      		push r16
 4337 176c 1F93      		push r17
 4338               	/* prologue: function */
 4339               	/* frame size = 0 */
 4340 176e 9B01      		movw r18,r22
 161:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 4342               	.LM352:
 4343 1770 60E0      		ldi r22,lo8(10240)
 4344 1772 78E2      		ldi r23,hi8(10240)
 4345 1774 40E0      		ldi r20,lo8(256)
 4346 1776 51E0      		ldi r21,hi8(256)
 4347 1778 00E0      		ldi r16,lo8(cmdListNormal)
 4348 177a 10E0      		ldi r17,hi8(cmdListNormal)
 4349 177c EE24      		clr r14
 4350 177e 0E94 0000 		call cmdStateConfigure
 4351               	/* epilogue start */
 162:vty.c         **** }
 4353               	.LM353:
 4354 1782 1F91      		pop r17
 4355 1784 0F91      		pop r16
 4356 1786 EF90      		pop r14
 4357 1788 0895      		ret
 4359               	.Lscope34:
 4361               		.stabd	78,0,0
 4362               	.global	errorOK
 4363               		.section	.progmem.data,"a",@progbits
 4366               	errorOK:
 4367 0000 416C 6C20 		.string	"All OK\r\n"
 4367      4F4B 0D0A 
 4367      00
 4368               	.global	errorNoFile
 4371               	errorNoFile:
 4372 0009 4E6F 2046 		.string	"No File\r\n"
 4372      696C 650D 
 4372      0A00 
 4373               	.global	errorxModemFrameStartTimeout
 4376               	errorxModemFrameStartTimeout:
 4377 0013 0D0A 00   		.string	"\r\n"
 4378               	.global	errorxModemByteSendTimeout
 4381               	errorxModemByteSendTimeout:
 4382 0016 0D0A 00   		.string	"\r\n"
 4383               	.global	errorxModemWrongFrameNo
 4386               	errorxModemWrongFrameNo:
 4387 0019 0D0A 00   		.string	"\r\n"
 4388               	.global	errorxModemFrameFrameNoCorrectionNotMatch
 4391               	errorxModemFrameFrameNoCorrectionNotMatch:
 4392 001c 0D0A 00   		.string	"\r\n"
 4393               	.global	errorxModemFrameCrc
 4396               	errorxModemFrameCrc:
 4397 001f 784D 6F64 		.string	"xModem CRC error\r\n"
 4397      656D 2043 
 4397      5243 2065 
 4397      7272 6F72 
 4397      0D0A 00
 4398               	.global	errorxModemRemoteSideCan
 4401               	errorxModemRemoteSideCan:
 4402 0032 5265 6D6F 		.string	"Remote side cancelled at frame no %d\r\n"
 4402      7465 2073 
 4402      6964 6520 
 4402      6361 6E63 
 4402      656C 6C65 
 4403               	.global	errorxModemUnknownResponse
 4406               	errorxModemUnknownResponse:
 4407 0059 784D 6F64 		.string	"xModem unknown response 0x%x\r\n"
 4407      656D 2075 
 4407      6E6B 6E6F 
 4407      776E 2072 
 4407      6573 706F 
 4408               	.global	errorNoRemoteDevice
 4411               	errorNoRemoteDevice:
 4412 0078 4465 7669 		.string	"Device %d is not responding (%d)\r\n"
 4412      6365 2025 
 4412      6420 6973 
 4412      206E 6F74 
 4412      2072 6573 
 4413               	.global	errorBootloaderNotResponding
 4416               	errorBootloaderNotResponding:
 4417 009b 426F 6F74 		.string	"Bootloader is not responding\r\n"
 4417      6C6F 6164 
 4417      6572 2069 
 4417      7320 6E6F 
 4417      7420 7265 
 4418               	.global	errorOpenFile
 4421               	errorOpenFile:
 4422 00ba 4361 6E27 		.string	"Can't open file %s\r\n"
 4422      7420 6F70 
 4422      656E 2066 
 4422      696C 6520 
 4422      2573 0D0A 
 4423               	.global	systemStateStr
 4426               	systemStateStr:
 4427 00cf 5379 7374 		.string	"System state:\r\n"
 4427      656D 2073 
 4427      7461 7465 
 4427      3A0D 0A00 
 4428               	.global	statusNumberOfTasksStr
 4431               	statusNumberOfTasksStr:
 4432 00df 2020 4E75 		.string	"  Number of tasks : %d\r\n"
 4432      6D62 6572 
 4432      206F 6620 
 4432      7461 736B 
 4432      7320 3A20 
 4433               	.global	statusStaticHeapStateStr
 4436               	statusStaticHeapStateStr:
 4437 00f8 2020 4672 		.string	"  FreeRtos heap   : %d free of %d bytes\r\n"
 4437      6565 5274 
 4437      6F73 2068 
 4437      6561 7020 
 4437      2020 3A20 
 4438               	.global	statusDynamicHeapStateStr
 4441               	statusDynamicHeapStateStr:
 4442 0122 2020 4D61 		.string	"  Malloc heap     : %d free of %d bytes\r\n"
 4442      6C6C 6F63 
 4442      2068 6561 
 4442      7020 2020 
 4442      2020 3A20 
 4443               	.global	statusRamDiskStateStr
 4446               	statusRamDiskStateStr:
 4447 014c 2020 5261 		.string	"  Ram disc space  : %d free of %d clusters\r\n"
 4447      6D20 6469 
 4447      7363 2073 
 4447      7061 6365 
 4447      2020 3A20 
 4448               	.global	statusTemperatureStr
 4451               	statusTemperatureStr:
 4452 0179 2020 5465 		.string	"  Temperature     : %d C\r\n"
 4452      6D70 6572 
 4452      6174 7572 
 4452      6520 2020 
 4452      2020 3A20 
 4453               	.global	statusVoltageStr
 4456               	statusVoltageStr:
 4457 0194 2020 566F 		.string	"  Voltage         : %d V\r\n"
 4457      6C74 6167 
 4457      6520 2020 
 4457      2020 2020 
 4457      2020 3A20 
 4458               	.global	systemRamConfigStr
 4461               	systemRamConfigStr:
 4462 01af 5379 7374 		.string	"System settings:\r\n"
 4462      656D 2073 
 4462      6574 7469 
 4462      6E67 733A 
 4462      0D0A 00
 4463               	.global	statusMacStr
 4466               	statusMacStr:
 4467 01c2 2020 4D61 		.string	"  Mac address     : "
 4467      6320 6164 
 4467      6472 6573 
 4467      7320 2020 
 4467      2020 3A20 
 4468               	.global	statusIpStr
 4471               	statusIpStr:
 4472 01d7 2020 4950 		.string	"  IP address      : "
 4472      2061 6464 
 4472      7265 7373 
 4472      2020 2020 
 4472      2020 3A20 
 4473               	.global	statusIpMaskStr
 4476               	statusIpMaskStr:
 4477 01ec 2020 6D61 		.string	"  mask            : "
 4477      736B 2020 
 4477      2020 2020 
 4477      2020 2020 
 4477      2020 3A20 
 4478               	.global	statusIpGwStr
 4481               	statusIpGwStr:
 4482 0201 2020 6761 		.string	"  gateway         : "
 4482      7465 7761 
 4482      7920 2020 
 4482      2020 2020 
 4482      2020 3A20 
 4483               	.global	statusRs485listStr
 4486               	statusRs485listStr:
 4487 0216 4465 7465 		.string	"Detected RS 485 devices:\r\n"
 4487      6374 6564 
 4487      2052 5320 
 4487      3438 3520 
 4487      6465 7669 
 4488               	.global	statusNoRs485Dev
 4491               	statusNoRs485Dev:
 4492 0231 2020 4361 		.string	"  Can't find any device\r\n"
 4492      6E27 7420 
 4492      6669 6E64 
 4492      2061 6E79 
 4492      2064 6576 
 4493               	.global	statusLockerSensorsStr
 4496               	statusLockerSensorsStr:
 4497 024b 4C6F 636B 		.string	"Locker sensors states:\r\n"
 4497      6572 2073 
 4497      656E 736F 
 4497      7273 2073 
 4497      7461 7465 
 4498               	.global	statusLockerSensorsDisStr
 4501               	statusLockerSensorsDisStr:
 4502 0264 2020 4C6F 		.string	"  Locker sensors disabled\r\n"
 4502      636B 6572 
 4502      2073 656E 
 4502      736F 7273 
 4502      2064 6973 
 4503               	.global	editRamFileIntroStr
 4506               	editRamFileIntroStr:
 4507 0280 5772 6974 		.string	"Writing to file. Press CTRL+C to quit\r\n"
 4507      696E 6720 
 4507      746F 2066 
 4507      696C 652E 
 4507      2050 7265 
 4508               	.global	readRamFIleLenStr
 4511               	readRamFIleLenStr:
 4512 02a8 4669 6C65 		.string	"File length: %d\r\n"
 4512      206C 656E 
 4512      6774 683A 
 4512      2025 640D 
 4512      0A00 
 4513               	.global	xwyslijStartStr
 4516               	xwyslijStartStr:
 4517 02ba 586D 6F64 		.string	"Xmodem: Transmission start\r\n"
 4517      656D 3A20 
 4517      5472 616E 
 4517      736D 6973 
 4517      7369 6F6E 
 4518               	.global	movingCurtainUpStr
 4521               	movingCurtainUpStr:
 4522 02d7 506F 646E 		.string	"Podnoszenie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4522      6F73 7A65 
 4522      6E69 6520 
 4522      726F 6C65 
 4522      7479 0D0A 
 4523               	.global	movingCurtainDownStr
 4526               	movingCurtainDownStr:
 4527 030a 4F70 7573 		.string	"Opuszczanie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4527      7A63 7A61 
 4527      6E69 6520 
 4527      726F 6C65 
 4527      7479 0D0A 
 4528               	.global	movingCurtainPosStr
 4531               	movingCurtainPosStr:
 4532 033d 0970 6F7A 		.string	"\tpozycja   %d\r\n"
 4532      7963 6A61 
 4532      2020 2025 
 4532      640D 0A00 
 4533               	.global	debugEnabledInfoStr
 4536               	debugEnabledInfoStr:
 4537 034d 456E 6162 		.string	"Enabled %s debug\r\n"
 4537      6C65 6420 
 4537      2573 2064 
 4537      6562 7567 
 4537      0D0A 00
 4538               	.global	debugDisabledInfoStr
 4541               	debugDisabledInfoStr:
 4542 0360 4469 7361 		.string	"Disabled %s debug\r\n"
 4542      626C 6564 
 4542      2025 7320 
 4542      6465 6275 
 4542      670D 0A00 
 4543               	.global	cmd_help
 4546               	cmd_help:
 4547 0374 6865 6C70 		.string	"help"
 4547      00
 4548               	.global	cmd_help_help
 4551               	cmd_help_help:
 4552 0379 5072 696E 		.string	"Print help string"
 4552      7420 6865 
 4552      6C70 2073 
 4552      7472 696E 
 4552      6700 
 4553               	.global	cmd_status
 4556               	cmd_status:
 4557 038b 7374 6174 		.string	"status"
 4557      7573 00
 4558               	.global	cmd_help_status
 4561               	cmd_help_status:
 4562 0392 7B66 696C 		.string	"{filename} Print device status on VTY or write to file"
 4562      656E 616D 
 4562      657D 2050 
 4562      7269 6E74 
 4562      2064 6576 
 4563               	.global	cmd_enc_stat
 4566               	cmd_enc_stat:
 4567 03c9 656E 6373 		.string	"encstat"
 4567      7461 7400 
 4568               	.global	cmd_help_enc_stat
 4571               	cmd_help_enc_stat:
 4572 03d1 5072 696E 		.string	"Print Enc 28j60 registers"
 4572      7420 456E 
 4572      6320 3238 
 4572      6A36 3020 
 4572      7265 6769 
 4573               	.global	cmd_time
 4576               	cmd_time:
 4577 03eb 7469 6D65 		.string	"time"
 4577      00
 4578               	.global	cmd_help_time
 4581               	cmd_help_time:
 4582 03f0 5072 696E 		.string	"Print time"
 4582      7420 7469 
 4582      6D65 00
 4583               	.global	cmd_net_dbg
 4586               	cmd_net_dbg:
 4587 03fb 6465 6275 		.string	"debug"
 4587      6700 
 4588               	.global	cmd_help_net_dbg
 4591               	cmd_help_net_dbg:
 4592 0401 5B61 7270 		.ascii	"[arp|icm"
 4592      7C69 636D 
 4593 0409 707C 6970 		.string	"p|ip|tcp|udp] [level] write debug info. Level 0 disable debuging"
 4593      7C74 6370 
 4593      7C75 6470 
 4593      5D20 5B6C 
 4593      6576 656C 
 4594               	.global	cmd_rping
 4597               	cmd_rping:
 4598 044a 7270 696E 		.string	"rping"
 4598      6700 
 4599               	.global	cmd_help_rping
 4602               	cmd_help_rping:
 4603 0450 5B44 6576 		.string	"[Device no] Send ping to Rs485 device"
 4603      6963 6520 
 4603      6E6F 5D20 
 4603      5365 6E64 
 4603      2070 696E 
 4604               	.global	cmd_ping
 4607               	cmd_ping:
 4608 0476 7069 6E67 		.string	"ping"
 4608      00
 4609               	.global	cmd_help_ping
 4612               	cmd_help_ping:
 4613 047b 5B41 315D 		.string	"[A1] [A2] [A3] [A4] Sends ping throught ethernet"
 4613      205B 4132 
 4613      5D20 5B41 
 4613      335D 205B 
 4613      4134 5D20 
 4614               	.global	cmd_xRec
 4617               	cmd_xRec:
 4618 04ac 7872 6563 		.string	"xrec"
 4618      00
 4619               	.global	cmd_help_xRec
 4622               	cmd_help_xRec:
 4623 04b1 5B66 696C 		.string	"[file name] receive file using xModem"
 4623      6520 6E61 
 4623      6D65 5D20 
 4623      7265 6365 
 4623      6976 6520 
 4624               	.global	cmd_xSend
 4627               	cmd_xSend:
 4628 04d7 7873 656E 		.string	"xsend"
 4628      6400 
 4629               	.global	cmd_help_xSend
 4632               	cmd_help_xSend:
 4633 04dd 5B66 696C 		.string	"[file name] send file using xModem"
 4633      6520 6E61 
 4633      6D65 5D20 
 4633      7365 6E64 
 4633      2066 696C 
 4634               	.global	cmd_xflash
 4637               	cmd_xflash:
 4638 0500 7866 6C61 		.string	"xflash"
 4638      7368 00
 4639               	.global	cmd_help_xflash
 4642               	cmd_help_xflash:
 4643 0507 5B64 6576 		.string	"[device no] [file name] flash device connected to Rs485"
 4643      6963 6520 
 4643      6E6F 5D20 
 4643      5B66 696C 
 4643      6520 6E61 
 4644               	.global	cmd_dir_rf
 4647               	cmd_dir_rf:
 4648 053f 6469 7272 		.string	"dirrf"
 4648      6600 
 4649               	.global	cmd_help_dir_rf
 4652               	cmd_help_dir_rf:
 4653 0545 5072 696E 		.string	"Print ramdisk files"
 4653      7420 7261 
 4653      6D64 6973 
 4653      6B20 6669 
 4653      6C65 7300 
 4654               	.global	cmd_create_rf
 4657               	cmd_create_rf:
 4658 0559 6372 6600 		.string	"crf"
 4659               	.global	cmd_help_create_rf
 4662               	cmd_help_create_rf:
 4663 055d 5B66 696C 		.string	"[file name] create ram file"
 4663      6520 6E61 
 4663      6D65 5D20 
 4663      6372 6561 
 4663      7465 2072 
 4664               	.global	cmd_erase_rf
 4667               	cmd_erase_rf:
 4668 0579 6572 6173 		.string	"eraserf"
 4668      6572 6600 
 4669               	.global	cmd_help_erase_rf
 4672               	cmd_help_erase_rf:
 4673 0581 5B66 696C 		.string	"[file name] erase file from ram disk"
 4673      6520 6E61 
 4673      6D65 5D20 
 4673      6572 6173 
 4673      6520 6669 
 4674               	.global	cmd_edit_rf
 4677               	cmd_edit_rf:
 4678 05a6 6564 6974 		.string	"editrf"
 4678      7266 00
 4679               	.global	cmd_help_edit_rf
 4682               	cmd_help_edit_rf:
 4683 05ad 5B66 696C 		.string	"[file name] edit file located on ram disk"
 4683      6520 6E61 
 4683      6D65 5D20 
 4683      6564 6974 
 4683      2066 696C 
 4684               	.global	cmd_read_rf
 4687               	cmd_read_rf:
 4688 05d7 7265 6164 		.string	"readrf"
 4688      7266 00
 4689               	.global	cmd_help_read_rf
 4692               	cmd_help_read_rf:
 4693 05de 5B66 696C 		.string	"[file name] read file located on ram disk"
 4693      6520 6E61 
 4693      6D65 5D20 
 4693      7265 6164 
 4693      2066 696C 
 4694               	.global	cmd_up
 4697               	cmd_up:
 4698 0608 7570 00   		.string	"up"
 4699               	.global	cmd_help_up
 4702               	cmd_help_up:
 4703 060b 5B64 7269 		.string	"[driver no] [channel] {value} move up"
 4703      7665 7220 
 4703      6E6F 5D20 
 4703      5B63 6861 
 4703      6E6E 656C 
 4704               	.global	cmd_down
 4707               	cmd_down:
 4708 0631 646F 776E 		.string	"down"
 4708      00
 4709               	.global	cmd_help_down
 4712               	cmd_help_down:
 4713 0636 5B64 7269 		.string	"[driver no] [channel] {value} move down"
 4713      7665 7220 
 4713      6E6F 5D20 
 4713      5B63 6861 
 4713      6E6E 656C 
 4714               	.global	cmd_spa
 4717               	cmd_spa:
 4718 065e 7370 6100 		.string	"spa"
 4719               	.global	cmd_help_spa
 4722               	cmd_help_spa:
 4723 0662 5B76 616C 		.string	"[value] set port A"
 4723      7565 5D20 
 4723      7365 7420 
 4723      706F 7274 
 4723      2041 00
 4724               	.global	cmd_spb
 4727               	cmd_spb:
 4728 0675 7370 6200 		.string	"spb"
 4729               	.global	cmd_help_spb
 4732               	cmd_help_spb:
 4733 0679 5B76 616C 		.string	"[value] set port B"
 4733      7565 5D20 
 4733      7365 7420 
 4733      706F 7274 
 4733      2042 00
 4734               	.global	cmd_settime
 4737               	cmd_settime:
 4738 068c 7365 7474 		.string	"settime"
 4738      696D 6500 
 4739               	.global	cmd_help_settime
 4742               	cmd_help_settime:
 4743 0694 5B68 5D20 		.string	"[h] [m] [s] set time (24h format)"
 4743      5B6D 5D20 
 4743      5B73 5D20 
 4743      7365 7420 
 4743      7469 6D65 
 4744               	.global	cmd_ac
 4747               	cmd_ac:
 4748 06b6 6163 00   		.string	"ac"
 4749               	.global	cmd_help_ac
 4752               	cmd_help_ac:
 4753 06b9 5B63 6861 		.string	"[channel 0-7] read analog value"
 4753      6E6E 656C 
 4753      2030 2D37 
 4753      5D20 7265 
 4753      6164 2061 
 4754               	.global	cmd_enable
 4757               	cmd_enable:
 4758 06d9 656E 6162 		.string	"enable"
 4758      6C65 00
 4759               	.global	cmd_help_enable
 4762               	cmd_help_enable:
 4763 06e0 456E 6162 		.string	"Enable mode"
 4763      6C65 206D 
 4763      6F64 6500 
 4764               	.global	cmd_disable
 4767               	cmd_disable:
 4768 06ec 6469 7361 		.string	"disable"
 4768      626C 6500 
 4769               	.global	cmd_help_disable
 4772               	cmd_help_disable:
 4773 06f4 5669 6577 		.string	"View mode"
 4773      206D 6F64 
 4773      6500 
 4774               	.global	cmd_configure
 4777               	cmd_configure:
 4778 06fe 636F 6E66 		.string	"config"
 4778      6967 00
 4779               	.global	cmd_help_configure
 4782               	cmd_help_configure:
 4783 0705 436F 6E66 		.string	"Configure mode"
 4783      6967 7572 
 4783      6520 6D6F 
 4783      6465 00
 4784               	.global	cmd_conf_ip
 4787               	cmd_conf_ip:
 4788 0714 6970 00   		.string	"ip"
 4789               	.global	cmd_help_conf_ip
 4792               	cmd_help_conf_ip:
 4793 0717 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set IP address"
 4793      205B 4132 
 4793      5D20 5B41 
 4793      335D 205B 
 4793      4134 5D20 
 4794               	.global	cmd_conf_udp
 4797               	cmd_conf_udp:
 4798 073a 7564 7000 		.string	"udp"
 4799               	.global	cmd_help_conf_udp
 4802               	cmd_help_conf_udp:
 4803 073e 5B41 315D 		.ascii	"[A1] [A2] [A3"
 4803      205B 4132 
 4803      5D20 5B41 
 4803      33
 4804 074b 5D20 5B41 		.string	"] [A4] [src port] {dst port} set udp client IP address and ports"
 4804      345D 205B 
 4804      7372 6320 
 4804      706F 7274 
 4804      5D20 7B64 
 4805               	.global	cmd_conf_ip_mask
 4808               	cmd_conf_ip_mask:
 4809 078c 6D61 736B 		.string	"mask"
 4809      00
 4810               	.global	cmd_conf_ip_mask_help
 4813               	cmd_conf_ip_mask_help:
 4814 0791 5B6D 6173 		.string	"[mask] set mask"
 4814      6B5D 2073 
 4814      6574 206D 
 4814      6173 6B00 
 4815               	.global	cmd_conf_ip_gw
 4818               	cmd_conf_ip_gw:
 4819 07a1 6777 00   		.string	"gw"
 4820               	.global	cmd_conf_ip_gw_help
 4823               	cmd_conf_ip_gw_help:
 4824 07a4 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set default gateway"
 4824      205B 4132 
 4824      5D20 5B41 
 4824      335D 205B 
 4824      4134 5D20 
 4825               	.global	cmd_conf_mac
 4828               	cmd_conf_mac:
 4829 07cc 6D61 6300 		.string	"mac"
 4830               	.global	cmd_help_conf_mac
 4833               	cmd_help_conf_mac:
 4834 07d0 5B41 315D 		.string	"[A1] [A2] [A3] [A4] [A5] [A6] set MAC address"
 4834      205B 4132 
 4834      5D20 5B41 
 4834      335D 205B 
 4834      4134 5D20 
 4835               	.global	cmd_conf_save
 4838               	cmd_conf_save:
 4839 07fe 7361 7665 		.string	"save"
 4839      00
 4840               	.global	cmd_help_conf_save
 4843               	cmd_help_conf_save:
 4844 0803 5361 7665 		.string	"Save configuration"
 4844      2063 6F6E 
 4844      6669 6775 
 4844      7261 7469 
 4844      6F6E 00
 4845               	.global	cmd_ustawR
 4848               	cmd_ustawR:
 4849 0816 7365 7472 		.string	"setr"
 4849      00
 4850               	.global	cmd_help_ustawR
 4853               	cmd_help_ustawR:
 4854 081b 5B76 616C 		.string	"[value] set resistance value"
 4854      7565 5D20 
 4854      7365 7420 
 4854      7265 7369 
 4854      7374 616E 
 4855               	.global	okStr
 4858               	okStr:
 4859 0838 4F4B 0D0A 		.string	"OK\r\n"
 4859      00
 4860               	.global	nlStr
 4863               	nlStr:
 4864 083d 0D0A 00   		.string	"\r\n"
 4865               	.global	BladBuforaPozostaloBajtowStr
 4868               	BladBuforaPozostaloBajtowStr:
 4869 0840 2121 2120 		.string	"!!! W budorze Rs485 pozostalo %d bajtow\r\n"
 4869      5720 6275 
 4869      646F 727A 
 4869      6520 5273 
 4869      3438 3520 
 4870               	.global	errorStrings
 4873               	errorStrings:
 4874 086a 0000      		.word	errorOK
 4875 086c 0000      		.word	errorNoFile
 4876 086e 0000      		.word	errorxModemFrameStartTimeout
 4877 0870 0000      		.word	errorxModemByteSendTimeout
 4878 0872 0000      		.word	errorxModemWrongFrameNo
 4879 0874 0000      		.word	errorxModemFrameFrameNoCorrectionNotMatch
 4880 0876 0000      		.word	errorxModemFrameCrc
 4881 0878 0000      		.word	errorxModemRemoteSideCan
 4882 087a 0000      		.word	errorxModemUnknownResponse
 4883 087c 0000      		.word	errorNoRemoteDevice
 4884 087e 0000      		.word	errorBootloaderNotResponding
 4885 0880 0000      		.word	errorOpenFile
 4886               	.global	cmdListNormal
 4889               	cmdListNormal:
 4890 0882 0000      		.word	cmd_help
 4891 0884 0000      		.word	cmd_help_help
 4892 0886 0000      		.word	gs(helpFunction)
 4893 0888 0000      		.word	cmd_status
 4894 088a 0000      		.word	cmd_help_status
 4895 088c 0000      		.word	gs(statusFunction)
 4896 088e 0000      		.word	cmd_time
 4897 0890 0000      		.word	cmd_help_time
 4898 0892 0000      		.word	gs(pokazCzasFunction)
 4899 0894 0000      		.word	cmd_rping
 4900 0896 0000      		.word	cmd_help_rping
 4901 0898 0000      		.word	gs(rpingFunction)
 4902 089a 0000      		.word	cmd_ping
 4903 089c 0000      		.word	cmd_help_ping
 4904 089e 0000      		.word	gs(pingFunction)
 4905 08a0 0000      		.word	cmd_dir_rf
 4906 08a2 0000      		.word	cmd_help_dir_rf
 4907 08a4 0000      		.word	gs(writeRamFileFunction)
 4908 08a6 0000      		.word	cmd_read_rf
 4909 08a8 0000      		.word	cmd_help_read_rf
 4910 08aa 0000      		.word	gs(readRamFIleFunction)
 4911 08ac 0000      		.word	cmd_enable
 4912 08ae 0000      		.word	cmd_help_enable
 4913 08b0 0000      		.word	gs(enableFunction)
 4914 08b2 0000      		.word	0
 4915 08b4 0000      		.word	0
 4916 08b6 0000      		.word	0
 4917               	.global	cmdListEnable
 4920               	cmdListEnable:
 4921 08b8 0000      		.word	cmd_help
 4922 08ba 0000      		.word	cmd_help_help
 4923 08bc 0000      		.word	gs(helpFunction)
 4924 08be 0000      		.word	cmd_status
 4925 08c0 0000      		.word	cmd_help_status
 4926 08c2 0000      		.word	gs(statusFunction)
 4927 08c4 0000      		.word	cmd_enc_stat
 4928 08c6 0000      		.word	cmd_help_enc_stat
 4929 08c8 0000      		.word	gs(statusEncFunction)
 4930 08ca 0000      		.word	cmd_time
 4931 08cc 0000      		.word	cmd_help_time
 4932 08ce 0000      		.word	gs(pokazCzasFunction)
 4933 08d0 0000      		.word	cmd_net_dbg
 4934 08d2 0000      		.word	cmd_help_net_dbg
 4935 08d4 0000      		.word	gs(debugFunction)
 4936 08d6 0000      		.word	cmd_rping
 4937 08d8 0000      		.word	cmd_help_rping
 4938 08da 0000      		.word	gs(rpingFunction)
 4939 08dc 0000      		.word	cmd_ping
 4940 08de 0000      		.word	cmd_help_ping
 4941 08e0 0000      		.word	gs(pingFunction)
 4942 08e2 0000      		.word	cmd_xRec
 4943 08e4 0000      		.word	cmd_help_xRec
 4944 08e6 0000      		.word	gs(goXmodemOdbierzFunction)
 4945 08e8 0000      		.word	cmd_xSend
 4946 08ea 0000      		.word	cmd_help_xSend
 4947 08ec 0000      		.word	gs(goXmodemWyslijFunction)
 4948 08ee 0000      		.word	cmd_xflash
 4949 08f0 0000      		.word	cmd_help_xflash
 4950 08f2 0000      		.word	gs(flashExModuleFunction)
 4951 08f4 0000      		.word	cmd_dir_rf
 4952 08f6 0000      		.word	cmd_help_dir_rf
 4953 08f8 0000      		.word	gs(writeRamFileFunction)
 4954 08fa 0000      		.word	cmd_create_rf
 4955 08fc 0000      		.word	cmd_help_create_rf
 4956 08fe 0000      		.word	gs(dodajRamPlikFunction)
 4957 0900 0000      		.word	cmd_erase_rf
 4958 0902 0000      		.word	cmd_help_erase_rf
 4959 0904 0000      		.word	gs(eraseRamFileFunction)
 4960 0906 0000      		.word	cmd_edit_rf
 4961 0908 0000      		.word	cmd_help_edit_rf
 4962 090a 0000      		.word	gs(editRamFileFunction)
 4963 090c 0000      		.word	cmd_read_rf
 4964 090e 0000      		.word	cmd_help_read_rf
 4965 0910 0000      		.word	gs(readRamFIleFunction)
 4966 0912 0000      		.word	cmd_up
 4967 0914 0000      		.word	cmd_help_up
 4968 0916 0000      		.word	gs(curtainUpFunction)
 4969 0918 0000      		.word	cmd_down
 4970 091a 0000      		.word	cmd_help_down
 4971 091c 0000      		.word	gs(curtainDownFunction)
 4972 091e 0000      		.word	cmd_spa
 4973 0920 0000      		.word	cmd_help_spa
 4974 0922 0000      		.word	gs(ustawPortExtAFunction)
 4975 0924 0000      		.word	cmd_spb
 4976 0926 0000      		.word	cmd_help_spb
 4977 0928 0000      		.word	gs(ustawPortExtBFunction)
 4978 092a 0000      		.word	cmd_ustawR
 4979 092c 0000      		.word	cmd_help_ustawR
 4980 092e 0000      		.word	gs(ustawPortRezystor)
 4981 0930 0000      		.word	cmd_settime
 4982 0932 0000      		.word	cmd_help_settime
 4983 0934 0000      		.word	gs(setTimeFunction)
 4984 0936 0000      		.word	cmd_ac
 4985 0938 0000      		.word	cmd_help_ac
 4986 093a 0000      		.word	gs(czytajAC_Function)
 4987 093c 0000      		.word	cmd_disable
 4988 093e 0000      		.word	cmd_help_disable
 4989 0940 0000      		.word	gs(disableFunction)
 4990 0942 0000      		.word	cmd_configure
 4991 0944 0000      		.word	cmd_help_configure
 4992 0946 0000      		.word	gs(configureModeFunction)
 4993 0948 0000      		.word	0
 4994 094a 0000      		.word	0
 4995 094c 0000      		.word	0
 4996               	.global	cmdListConfigure
 4999               	cmdListConfigure:
 5000 094e 0000      		.word	cmd_help
 5001 0950 0000      		.word	cmd_help_help
 5002 0952 0000      		.word	gs(helpFunction)
 5003 0954 0000      		.word	cmd_status
 5004 0956 0000      		.word	cmd_help_status
 5005 0958 0000      		.word	gs(statusFunction)
 5006 095a 0000      		.word	cmd_time
 5007 095c 0000      		.word	cmd_help_time
 5008 095e 0000      		.word	gs(pokazCzasFunction)
 5009 0960 0000      		.word	cmd_settime
 5010 0962 0000      		.word	cmd_help_settime
 5011 0964 0000      		.word	gs(setTimeFunction)
 5012 0966 0000      		.word	cmd_conf_ip
 5013 0968 0000      		.word	cmd_help_conf_ip
 5014 096a 0000      		.word	gs(setIpFunction)
 5015 096c 0000      		.word	cmd_conf_ip_mask
 5016 096e 0000      		.word	cmd_conf_ip_mask_help
 5017 0970 0000      		.word	gs(setIpMaskFunction)
 5018 0972 0000      		.word	cmd_conf_ip_gw
 5019 0974 0000      		.word	cmd_conf_ip_gw_help
 5020 0976 0000      		.word	gs(setIpGwFunction)
 5021 0978 0000      		.word	cmd_conf_udp
 5022 097a 0000      		.word	cmd_help_conf_udp
 5023 097c 0000      		.word	gs(setUdpFunction)
 5024 097e 0000      		.word	cmd_conf_mac
 5025 0980 0000      		.word	cmd_help_conf_mac
 5026 0982 0000      		.word	gs(setMacAddrFunction)
 5027 0984 0000      		.word	cmd_conf_save
 5028 0986 0000      		.word	cmd_help_conf_save
 5029 0988 0000      		.word	gs(saveConfigFunction)
 5030 098a 0000      		.word	cmd_enable
 5031 098c 0000      		.word	cmd_help_enable
 5032 098e 0000      		.word	gs(enableFunction)
 5033 0990 0000      		.word	cmd_disable
 5034 0992 0000      		.word	cmd_help_disable
 5035 0994 0000      		.word	gs(disableFunction)
 5036 0996 0000      		.word	0
 5037 0998 0000      		.word	0
 5038 099a 0000      		.word	0
 5041               	__c.3542:
 5042 099c 5761 7274 		.string	"Wartosc probki na wejsciu %d: %d\r\n"
 5042      6F73 6320 
 5042      7072 6F62 
 5042      6B69 206E 
 5042      6120 7765 
 5045               	__c.3660:
 5046 09bf 586D 6F64 		.string	"Xmodem: rozpoczynanie odbioru\r\n"
 5046      656D 3A20 
 5046      726F 7A70 
 5046      6F63 7A79 
 5046      6E61 6E69 
 5049               	__c.3412:
 5050 09df 7564 7000 		.string	"udp"
 5053               	__c.3410:
 5054 09e3 7463 7000 		.string	"tcp"
 5057               	__c.3408:
 5058 09e7 6963 6D70 		.string	"icmp"
 5058      00
 5061               	__c.3406:
 5062 09ec 6970 00   		.string	"ip"
 5065               	__c.3404:
 5066 09ef 6172 7000 		.string	"arp"
 5069               	__c.3402:
 5070 09f3 7564 7000 		.string	"udp"
 5073               	__c.3400:
 5074 09f7 7463 7000 		.string	"tcp"
 5077               	__c.3398:
 5078 09fb 6963 6D70 		.string	"icmp"
 5078      00
 5081               	__c.3396:
 5082 0a00 6970 00   		.string	"ip"
 5085               	__c.3394:
 5086 0a03 6172 7000 		.string	"arp"
 5089               	__c.3364:
 5090 0a07 416B 7475 		.string	"Aktualny czas %d:%d:%d\r\n"
 5090      616C 6E79 
 5090      2063 7A61 
 5090      7320 2564 
 5090      3A25 643A 
 5093               	__c.3323:
 5094 0a20 0D0A 00   		.string	"\r\n"
 5097               	__c.3321:
 5098 0a23 0D0A 00   		.string	"\r\n"
 5101               	__c.3319:
 5102 0a26 0D0A 00   		.string	"\r\n"
 5105               	__c.3317:
 5106 0a29 0D0A 00   		.string	"\r\n"
 5109               	__c.3314:
 5110 0a2c 4672 6565 		.string	"FreeRtos+ ver 0.31 build: Aug 21 2011, 16:30:31\r\n"
 5110      5274 6F73 
 5110      2B20 7665 
 5110      7220 302E 
 5110      3331 2062 
 5111               		.comm klastry,128,1
 5112               		.comm wwwport,1,1
 5113               		.comm rollers,2,1
 5114               		.comm xSemaphoreSpiSS,2,1
 5115               		.comm portA,1,1
 5116               		.comm portB,1,1
 5117               		.comm lockSensors,2,1
 5118               		.comm xSemaphoreRs485,2,1
 5119               		.comm nicState,14,1
 5120               		.comm plen,2,1
 5121               		.comm IpMyConfig,15,1
 5122               		.comm arpDebug,2,1
 5123               		.comm arpDebugLevel,1,1
 5124               		.comm icmpDebug,2,1
 5125               		.comm icmpDebugLevel,1,1
 5126               		.comm udpSocket,2,1
 5127               		.comm udpDbgStream,2,1
 5128               		.comm udpDbgLevel,1,1
 5129               		.comm tcpDebugStream,2,1
 5130               		.comm tcpDebugLevel,1,1
 5131               		.comm sockets,2,1
 5132               		.comm entries,2,1
 5133               		.comm debugStream,2,1
 5134               		.comm uip_netif_physical_if,2,1
 5135               		.comm uip_ext_len,1,1
 5136               		.comm uip_ext_opt_offset,1,1
 5137               		.comm czasRtc,7,1
 5138               		.comm fdVty,6,1
 5290               		.weak	nicRegDump
 5291               		.weak	nicSetMacAddress
 5292               		.text
 5294               	.Letext0:
 5295               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 vty.c
     /tmp/ccQATRFc.s:2      *ABS*:0000003f __SREG__
     /tmp/ccQATRFc.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccQATRFc.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccQATRFc.s:5      *ABS*:00000034 __CCP__
     /tmp/ccQATRFc.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccQATRFc.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccQATRFc.s:279    .text:00000000 enableFunction
     /tmp/ccQATRFc.s:4920   .progmem.data:000008b8 cmdListEnable
     /tmp/ccQATRFc.s:321    .text:00000022 disableFunction
     /tmp/ccQATRFc.s:4889   .progmem.data:00000882 cmdListNormal
     /tmp/ccQATRFc.s:357    .text:0000003a configureModeFunction
     /tmp/ccQATRFc.s:4999   .progmem.data:0000094e cmdListConfigure
     /tmp/ccQATRFc.s:399    .text:0000005c saveConfigFunction
     /tmp/ccQATRFc.s:422    .text:00000066 setMacAddrFunction
                            *COM*:0000000e nicState
     /tmp/ccQATRFc.s:499    .text:000000d4 pingFunction
     /tmp/ccQATRFc.s:555    .text:00000112 setUdpFunction
                            *COM*:00000002 udpSocket
     /tmp/ccQATRFc.s:703    .text:0000020c setIpGwFunction
     /tmp/ccQATRFc.s:811    .text:000002bc setIpMaskFunction
     /tmp/ccQATRFc.s:866    .text:000002fc setIpFunction
     /tmp/ccQATRFc.s:974    .text:000003ac czytajAC_Function
     /tmp/ccQATRFc.s:5041   .progmem.data:0000099c __c.3542
     /tmp/ccQATRFc.s:1055   .text:00000424 printErrorInfo
     /tmp/ccQATRFc.s:4873   .progmem.data:0000086a errorStrings
     /tmp/ccQATRFc.s:1152   .text:0000049a setTimeFunction
                            *COM*:00000007 czasRtc
     /tmp/ccQATRFc.s:1288   .text:00000568 ustawPortRezystor
     /tmp/ccQATRFc.s:1329   .text:0000058c ustawPortExtBFunction
     /tmp/ccQATRFc.s:1367   .text:000005b0 ustawPortExtAFunction
     /tmp/ccQATRFc.s:1405   .text:000005d4 curtainDownFunction
     /tmp/ccQATRFc.s:4526   .progmem.data:0000030a movingCurtainDownStr
     /tmp/ccQATRFc.s:4531   .progmem.data:0000033d movingCurtainPosStr
     /tmp/ccQATRFc.s:1559   .text:000006c0 curtainUpFunction
     /tmp/ccQATRFc.s:4521   .progmem.data:000002d7 movingCurtainUpStr
     /tmp/ccQATRFc.s:1731   .text:000007c4 goXmodemWyslijFunction
     /tmp/ccQATRFc.s:4516   .progmem.data:000002ba xwyslijStartStr
                            *COM*:00000006 fdVty
     /tmp/ccQATRFc.s:4421   .progmem.data:000000ba errorOpenFile
     /tmp/ccQATRFc.s:1833   .text:00000868 editRamFileFunction
     /tmp/ccQATRFc.s:4506   .progmem.data:00000280 editRamFileIntroStr
     /tmp/ccQATRFc.s:1993   .text:00000968 eraseRamFileFunction
     /tmp/ccQATRFc.s:2036   .text:00000996 dodajRamPlikFunction
     /tmp/ccQATRFc.s:2088   .text:000009d0 rpingFunction
     /tmp/ccQATRFc.s:2155   .text:00000a1c flashExModuleFunction
     /tmp/ccQATRFc.s:2292   .text:00000ade goXmodemOdbierzFunction
     /tmp/ccQATRFc.s:5045   .progmem.data:000009bf __c.3660
     /tmp/ccQATRFc.s:2978   .text:00000ec6 debugFunction
     /tmp/ccQATRFc.s:5085   .progmem.data:00000a03 __c.3394
     /tmp/ccQATRFc.s:5081   .progmem.data:00000a00 __c.3396
     /tmp/ccQATRFc.s:5077   .progmem.data:000009fb __c.3398
     /tmp/ccQATRFc.s:5073   .progmem.data:000009f7 __c.3400
     /tmp/ccQATRFc.s:4541   .progmem.data:00000360 debugDisabledInfoStr
     /tmp/ccQATRFc.s:5069   .progmem.data:000009f3 __c.3402
     /tmp/ccQATRFc.s:5065   .progmem.data:000009ef __c.3404
     /tmp/ccQATRFc.s:5061   .progmem.data:000009ec __c.3406
     /tmp/ccQATRFc.s:5057   .progmem.data:000009e7 __c.3408
     /tmp/ccQATRFc.s:5053   .progmem.data:000009e3 __c.3410
     /tmp/ccQATRFc.s:4536   .progmem.data:0000034d debugEnabledInfoStr
     /tmp/ccQATRFc.s:5049   .progmem.data:000009df __c.3412
     /tmp/ccQATRFc.s:3269   .text:00001090 statusEncFunction
     /tmp/ccQATRFc.s:3295   .text:000010a0 readRamFIleFunction
     /tmp/ccQATRFc.s:4511   .progmem.data:000002a8 readRamFIleLenStr
     /tmp/ccQATRFc.s:4863   .progmem.data:0000083d nlStr
     /tmp/ccQATRFc.s:3494   .text:000011e6 writeRamFileFunction
     /tmp/ccQATRFc.s:3520   .text:000011f6 pokazCzasFunction
     /tmp/ccQATRFc.s:5089   .progmem.data:00000a07 __c.3364
     /tmp/ccQATRFc.s:3656   .text:000012e0 helpFunction
     /tmp/ccQATRFc.s:3680   .text:000012ea printStatus
     /tmp/ccQATRFc.s:5109   .progmem.data:00000a2c __c.3314
     /tmp/ccQATRFc.s:4426   .progmem.data:000000cf systemStateStr
     /tmp/ccQATRFc.s:4431   .progmem.data:000000df statusNumberOfTasksStr
     /tmp/ccQATRFc.s:4436   .progmem.data:000000f8 statusStaticHeapStateStr
     /tmp/ccQATRFc.s:4441   .progmem.data:00000122 statusDynamicHeapStateStr
     /tmp/ccQATRFc.s:4451   .progmem.data:00000179 statusTemperatureStr
     /tmp/ccQATRFc.s:4456   .progmem.data:00000194 statusVoltageStr
     /tmp/ccQATRFc.s:4446   .progmem.data:0000014c statusRamDiskStateStr
     /tmp/ccQATRFc.s:4461   .progmem.data:000001af systemRamConfigStr
     /tmp/ccQATRFc.s:4466   .progmem.data:000001c2 statusMacStr
     /tmp/ccQATRFc.s:5105   .progmem.data:00000a29 __c.3317
     /tmp/ccQATRFc.s:4471   .progmem.data:000001d7 statusIpStr
     /tmp/ccQATRFc.s:5101   .progmem.data:00000a26 __c.3319
     /tmp/ccQATRFc.s:4476   .progmem.data:000001ec statusIpMaskStr
     /tmp/ccQATRFc.s:5097   .progmem.data:00000a23 __c.3321
     /tmp/ccQATRFc.s:4481   .progmem.data:00000201 statusIpGwStr
     /tmp/ccQATRFc.s:5093   .progmem.data:00000a20 __c.3323
     /tmp/ccQATRFc.s:4486   .progmem.data:00000216 statusRs485listStr
     /tmp/ccQATRFc.s:4491   .progmem.data:00000231 statusNoRs485Dev
     /tmp/ccQATRFc.s:4496   .progmem.data:0000024b statusLockerSensorsStr
     /tmp/ccQATRFc.s:4501   .progmem.data:00000264 statusLockerSensorsDisStr
     /tmp/ccQATRFc.s:4196   .text:0000169a statusFunction
     /tmp/ccQATRFc.s:4330   .text:00001768 VtyInit
     /tmp/ccQATRFc.s:4366   .progmem.data:00000000 errorOK
     /tmp/ccQATRFc.s:4371   .progmem.data:00000009 errorNoFile
     /tmp/ccQATRFc.s:4376   .progmem.data:00000013 errorxModemFrameStartTimeout
     /tmp/ccQATRFc.s:4381   .progmem.data:00000016 errorxModemByteSendTimeout
     /tmp/ccQATRFc.s:4386   .progmem.data:00000019 errorxModemWrongFrameNo
     /tmp/ccQATRFc.s:4391   .progmem.data:0000001c errorxModemFrameFrameNoCorrectionNotMatch
     /tmp/ccQATRFc.s:4396   .progmem.data:0000001f errorxModemFrameCrc
     /tmp/ccQATRFc.s:4401   .progmem.data:00000032 errorxModemRemoteSideCan
     /tmp/ccQATRFc.s:4406   .progmem.data:00000059 errorxModemUnknownResponse
     /tmp/ccQATRFc.s:4411   .progmem.data:00000078 errorNoRemoteDevice
     /tmp/ccQATRFc.s:4416   .progmem.data:0000009b errorBootloaderNotResponding
     /tmp/ccQATRFc.s:4546   .progmem.data:00000374 cmd_help
     /tmp/ccQATRFc.s:4551   .progmem.data:00000379 cmd_help_help
     /tmp/ccQATRFc.s:4556   .progmem.data:0000038b cmd_status
     /tmp/ccQATRFc.s:4561   .progmem.data:00000392 cmd_help_status
     /tmp/ccQATRFc.s:4566   .progmem.data:000003c9 cmd_enc_stat
     /tmp/ccQATRFc.s:4571   .progmem.data:000003d1 cmd_help_enc_stat
     /tmp/ccQATRFc.s:4576   .progmem.data:000003eb cmd_time
     /tmp/ccQATRFc.s:4581   .progmem.data:000003f0 cmd_help_time
     /tmp/ccQATRFc.s:4586   .progmem.data:000003fb cmd_net_dbg
     /tmp/ccQATRFc.s:4591   .progmem.data:00000401 cmd_help_net_dbg
     /tmp/ccQATRFc.s:4597   .progmem.data:0000044a cmd_rping
     /tmp/ccQATRFc.s:4602   .progmem.data:00000450 cmd_help_rping
     /tmp/ccQATRFc.s:4607   .progmem.data:00000476 cmd_ping
     /tmp/ccQATRFc.s:4612   .progmem.data:0000047b cmd_help_ping
     /tmp/ccQATRFc.s:4617   .progmem.data:000004ac cmd_xRec
     /tmp/ccQATRFc.s:4622   .progmem.data:000004b1 cmd_help_xRec
     /tmp/ccQATRFc.s:4627   .progmem.data:000004d7 cmd_xSend
     /tmp/ccQATRFc.s:4632   .progmem.data:000004dd cmd_help_xSend
     /tmp/ccQATRFc.s:4637   .progmem.data:00000500 cmd_xflash
     /tmp/ccQATRFc.s:4642   .progmem.data:00000507 cmd_help_xflash
     /tmp/ccQATRFc.s:4647   .progmem.data:0000053f cmd_dir_rf
     /tmp/ccQATRFc.s:4652   .progmem.data:00000545 cmd_help_dir_rf
     /tmp/ccQATRFc.s:4657   .progmem.data:00000559 cmd_create_rf
     /tmp/ccQATRFc.s:4662   .progmem.data:0000055d cmd_help_create_rf
     /tmp/ccQATRFc.s:4667   .progmem.data:00000579 cmd_erase_rf
     /tmp/ccQATRFc.s:4672   .progmem.data:00000581 cmd_help_erase_rf
     /tmp/ccQATRFc.s:4677   .progmem.data:000005a6 cmd_edit_rf
     /tmp/ccQATRFc.s:4682   .progmem.data:000005ad cmd_help_edit_rf
     /tmp/ccQATRFc.s:4687   .progmem.data:000005d7 cmd_read_rf
     /tmp/ccQATRFc.s:4692   .progmem.data:000005de cmd_help_read_rf
     /tmp/ccQATRFc.s:4697   .progmem.data:00000608 cmd_up
     /tmp/ccQATRFc.s:4702   .progmem.data:0000060b cmd_help_up
     /tmp/ccQATRFc.s:4707   .progmem.data:00000631 cmd_down
     /tmp/ccQATRFc.s:4712   .progmem.data:00000636 cmd_help_down
     /tmp/ccQATRFc.s:4717   .progmem.data:0000065e cmd_spa
     /tmp/ccQATRFc.s:4722   .progmem.data:00000662 cmd_help_spa
     /tmp/ccQATRFc.s:4727   .progmem.data:00000675 cmd_spb
     /tmp/ccQATRFc.s:4732   .progmem.data:00000679 cmd_help_spb
     /tmp/ccQATRFc.s:4737   .progmem.data:0000068c cmd_settime
     /tmp/ccQATRFc.s:4742   .progmem.data:00000694 cmd_help_settime
     /tmp/ccQATRFc.s:4747   .progmem.data:000006b6 cmd_ac
     /tmp/ccQATRFc.s:4752   .progmem.data:000006b9 cmd_help_ac
     /tmp/ccQATRFc.s:4757   .progmem.data:000006d9 cmd_enable
     /tmp/ccQATRFc.s:4762   .progmem.data:000006e0 cmd_help_enable
     /tmp/ccQATRFc.s:4767   .progmem.data:000006ec cmd_disable
     /tmp/ccQATRFc.s:4772   .progmem.data:000006f4 cmd_help_disable
     /tmp/ccQATRFc.s:4777   .progmem.data:000006fe cmd_configure
     /tmp/ccQATRFc.s:4782   .progmem.data:00000705 cmd_help_configure
     /tmp/ccQATRFc.s:4787   .progmem.data:00000714 cmd_conf_ip
     /tmp/ccQATRFc.s:4792   .progmem.data:00000717 cmd_help_conf_ip
     /tmp/ccQATRFc.s:4797   .progmem.data:0000073a cmd_conf_udp
     /tmp/ccQATRFc.s:4802   .progmem.data:0000073e cmd_help_conf_udp
     /tmp/ccQATRFc.s:4808   .progmem.data:0000078c cmd_conf_ip_mask
     /tmp/ccQATRFc.s:4813   .progmem.data:00000791 cmd_conf_ip_mask_help
     /tmp/ccQATRFc.s:4818   .progmem.data:000007a1 cmd_conf_ip_gw
     /tmp/ccQATRFc.s:4823   .progmem.data:000007a4 cmd_conf_ip_gw_help
     /tmp/ccQATRFc.s:4828   .progmem.data:000007cc cmd_conf_mac
     /tmp/ccQATRFc.s:4833   .progmem.data:000007d0 cmd_help_conf_mac
     /tmp/ccQATRFc.s:4838   .progmem.data:000007fe cmd_conf_save
     /tmp/ccQATRFc.s:4843   .progmem.data:00000803 cmd_help_conf_save
     /tmp/ccQATRFc.s:4848   .progmem.data:00000816 cmd_ustawR
     /tmp/ccQATRFc.s:4853   .progmem.data:0000081b cmd_help_ustawR
     /tmp/ccQATRFc.s:4858   .progmem.data:00000838 okStr
     /tmp/ccQATRFc.s:4868   .progmem.data:00000840 BladBuforaPozostaloBajtowStr
                            *COM*:00000080 klastry
                            *COM*:00000001 wwwport
                            *COM*:00000002 rollers
                            *COM*:00000002 xSemaphoreSpiSS
                            *COM*:00000001 portA
                            *COM*:00000001 portB
                            *COM*:00000002 lockSensors
                            *COM*:00000002 xSemaphoreRs485
                            *COM*:00000002 plen
                            *COM*:0000000f IpMyConfig
                            *COM*:00000002 arpDebug
                            *COM*:00000001 arpDebugLevel
                            *COM*:00000002 icmpDebug
                            *COM*:00000001 icmpDebugLevel
                            *COM*:00000002 udpDbgStream
                            *COM*:00000001 udpDbgLevel
                            *COM*:00000002 tcpDebugStream
                            *COM*:00000001 tcpDebugLevel
                            *COM*:00000002 sockets
                            *COM*:00000002 entries
                            *COM*:00000002 debugStream
                            *COM*:00000002 uip_netif_physical_if
                            *COM*:00000001 uip_ext_len
                            *COM*:00000001 uip_ext_opt_offset

UNDEFINED SYMBOLS
saveConfiguration
cmdlineGetArgHex
nicSetMacAddress
cmdlineGetArgInt
htons
ipSetConfigGw
ipSetConfigMask
ipSetConfigIp
MCP3008_getSampleSingle
fprintf_P
ds1305start
__udivmodqi4
setTimeDecoded
MCP4150_setValue
MPC23s17SetDirB
MPC23s17SetPortB
MPC23s17SetDirA
MPC23s17SetPortA
rs485curtainDown
rs485curtainUp
cmdlineGetArgStr
ramDyskOtworzPlik
ramDyskUstawWskaznikNaKoniec
xVtyRec
xQueueGenericReceive
uartVtySendByte
ramDyskZapiszBajtDoPliku
ramDyskZamknijPlik
ramDyskUsunPlik
ramDyskUtworzPlik
rs485ping
rs485xModemFlash
fputc
ramDyskDodajBlokXmodem
strncmp_P
setArpDebug
setIpDebug
setIcmpDebug
setTcpDebug
setUdpDebug
nicRegDump
ramDyskCzytajBajtZPliku
ramDyskDir
readTimeDecoded
cmdPrintHelp
uxTaskGetNumberOfTasks
xPortGetFreeHeapSize
xmallocAvailable
temperature
voltage
ramDyskLiczbaWolnychKlastrow
netPrintEthAddr
ipGetConfig
netPrintIPAddr
printRs485devices
printLockers
udpPrintStatus
ramDyskOtworzPlikStdIo
ramDyskZamknijPlikStdIo
cmdStateConfigure
__do_clear_bss
