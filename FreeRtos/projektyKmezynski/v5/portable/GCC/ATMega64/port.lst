   1               		.file	"port.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 114               	.global	pxPortInitialiseStack
 116               	pxPortInitialiseStack:
 117               		.stabd	46,0,0
   1:portable/GCC/ATMega64/port.c **** /*
   2:portable/GCC/ATMega64/port.c **** 	FreeRTOS.org V5.2.0 - Copyright (C) 2003-2009 Richard Barry.
   3:portable/GCC/ATMega64/port.c **** 
   4:portable/GCC/ATMega64/port.c **** 	This file is part of the FreeRTOS.org distribution.
   5:portable/GCC/ATMega64/port.c **** 
   6:portable/GCC/ATMega64/port.c **** 	FreeRTOS.org is free software; you can redistribute it and/or modify it 
   7:portable/GCC/ATMega64/port.c **** 	under the terms of the GNU General Public License (version 2) as published
   8:portable/GCC/ATMega64/port.c **** 	by the Free Software Foundation and modified by the FreeRTOS exception.
   9:portable/GCC/ATMega64/port.c **** 
  10:portable/GCC/ATMega64/port.c **** 	FreeRTOS.org is distributed in the hope that it will be useful,	but WITHOUT
  11:portable/GCC/ATMega64/port.c **** 	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
  12:portable/GCC/ATMega64/port.c **** 	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
  13:portable/GCC/ATMega64/port.c **** 	more details.
  14:portable/GCC/ATMega64/port.c **** 
  15:portable/GCC/ATMega64/port.c **** 	You should have received a copy of the GNU General Public License along 
  16:portable/GCC/ATMega64/port.c **** 	with FreeRTOS.org; if not, write to the Free Software Foundation, Inc., 59 
  17:portable/GCC/ATMega64/port.c **** 	Temple Place, Suite 330, Boston, MA  02111-1307  USA.
  18:portable/GCC/ATMega64/port.c **** 
  19:portable/GCC/ATMega64/port.c **** 	A special exception to the GPL is included to allow you to distribute a 
  20:portable/GCC/ATMega64/port.c **** 	combined work that includes FreeRTOS.org without being obliged to provide
  21:portable/GCC/ATMega64/port.c **** 	the source code for any proprietary components.  See the licensing section
  22:portable/GCC/ATMega64/port.c **** 	of http://www.FreeRTOS.org for full details.
  23:portable/GCC/ATMega64/port.c **** 
  24:portable/GCC/ATMega64/port.c **** 
  25:portable/GCC/ATMega64/port.c **** 	***************************************************************************
  26:portable/GCC/ATMega64/port.c **** 	*                                                                         *
  27:portable/GCC/ATMega64/port.c **** 	* Get the FreeRTOS eBook!  See http://www.FreeRTOS.org/Documentation      *
  28:portable/GCC/ATMega64/port.c **** 	*                                                                         *
  29:portable/GCC/ATMega64/port.c **** 	* This is a concise, step by step, 'hands on' guide that describes both   *
  30:portable/GCC/ATMega64/port.c **** 	* general multitasking concepts and FreeRTOS specifics. It presents and   *
  31:portable/GCC/ATMega64/port.c **** 	* explains numerous examples that are written using the FreeRTOS API.     *
  32:portable/GCC/ATMega64/port.c **** 	* Full source code for all the examples is provided in an accompanying    *
  33:portable/GCC/ATMega64/port.c **** 	* .zip file.                                                              *
  34:portable/GCC/ATMega64/port.c **** 	*                                                                         *
  35:portable/GCC/ATMega64/port.c **** 	***************************************************************************
  36:portable/GCC/ATMega64/port.c **** 
  37:portable/GCC/ATMega64/port.c **** 	1 tab == 4 spaces!
  38:portable/GCC/ATMega64/port.c **** 
  39:portable/GCC/ATMega64/port.c **** 	Please ensure to read the configuration and relevant port sections of the
  40:portable/GCC/ATMega64/port.c **** 	online documentation.
  41:portable/GCC/ATMega64/port.c **** 
  42:portable/GCC/ATMega64/port.c **** 	http://www.FreeRTOS.org - Documentation, latest information, license and
  43:portable/GCC/ATMega64/port.c **** 	contact details.
  44:portable/GCC/ATMega64/port.c **** 
  45:portable/GCC/ATMega64/port.c **** 	http://www.SafeRTOS.com - A version that is certified for use in safety
  46:portable/GCC/ATMega64/port.c **** 	critical systems.
  47:portable/GCC/ATMega64/port.c **** 
  48:portable/GCC/ATMega64/port.c **** 	http://www.OpenRTOS.com - Commercial support, development, porting,
  49:portable/GCC/ATMega64/port.c **** 	licensing and training services.
  50:portable/GCC/ATMega64/port.c **** */
  51:portable/GCC/ATMega64/port.c **** 
  52:portable/GCC/ATMega64/port.c **** /* 
  53:portable/GCC/ATMega64/port.c **** 
  54:portable/GCC/ATMega64/port.c **** Changes from V2.6.0
  55:portable/GCC/ATMega64/port.c **** 
  56:portable/GCC/ATMega64/port.c **** 	+ AVR port - Replaced the inb() and outb() functions with direct memory
  57:portable/GCC/ATMega64/port.c **** 	  access.  This allows the port to be built with the 20050414 build of
  58:portable/GCC/ATMega64/port.c **** 	  WinAVR.
  59:portable/GCC/ATMega64/port.c **** */
  60:portable/GCC/ATMega64/port.c **** 
  61:portable/GCC/ATMega64/port.c **** #include <stdlib.h>
  62:portable/GCC/ATMega64/port.c **** #include <avr/interrupt.h>
  63:portable/GCC/ATMega64/port.c **** 
  64:portable/GCC/ATMega64/port.c **** #include "FreeRTOS.h"
  65:portable/GCC/ATMega64/port.c **** #include "task.h"
  66:portable/GCC/ATMega64/port.c **** 
  67:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------
  68:portable/GCC/ATMega64/port.c ****  * Implementation of functions defined in portable.h for the AVR port.
  69:portable/GCC/ATMega64/port.c ****  *----------------------------------------------------------*/
  70:portable/GCC/ATMega64/port.c **** 
  71:portable/GCC/ATMega64/port.c **** /* Start tasks with interrupts enables. */
  72:portable/GCC/ATMega64/port.c **** #define portFLAGS_INT_ENABLED					( ( portSTACK_TYPE ) 0x80 )
  73:portable/GCC/ATMega64/port.c **** 
  74:portable/GCC/ATMega64/port.c **** /* Hardware constants for timer 1. */
  75:portable/GCC/ATMega64/port.c **** #define portCLEAR_COUNTER_ON_MATCH				( ( unsigned portCHAR ) 0x08 )
  76:portable/GCC/ATMega64/port.c **** #define portPRESCALE_64							( ( unsigned portCHAR ) 0x03 )
  77:portable/GCC/ATMega64/port.c **** #define portCLOCK_PRESCALER						( ( unsigned portLONG ) 64 )
  78:portable/GCC/ATMega64/port.c **** #define portCOMPARE_MATCH_A_INTERRUPT_ENABLE	( ( unsigned portCHAR ) 0x10 )
  79:portable/GCC/ATMega64/port.c **** 
  80:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
  81:portable/GCC/ATMega64/port.c **** 
  82:portable/GCC/ATMega64/port.c **** /* We require the address of the pxCurrentTCB variable, but don't want to know
  83:portable/GCC/ATMega64/port.c **** any details of its type. */
  84:portable/GCC/ATMega64/port.c **** typedef void tskTCB;
  85:portable/GCC/ATMega64/port.c **** extern volatile tskTCB * volatile pxCurrentTCB;
  86:portable/GCC/ATMega64/port.c **** 
  87:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
  88:portable/GCC/ATMega64/port.c **** 
  89:portable/GCC/ATMega64/port.c **** /* 
  90:portable/GCC/ATMega64/port.c ****  * Macro to save all the general purpose registers, the save the stack pointer
  91:portable/GCC/ATMega64/port.c ****  * into the TCB.  
  92:portable/GCC/ATMega64/port.c ****  * 
  93:portable/GCC/ATMega64/port.c ****  * The first thing we do is save the flags then disable interrupts.  This is to 
  94:portable/GCC/ATMega64/port.c ****  * guard our stack against having a context switch interrupt after we have already 
  95:portable/GCC/ATMega64/port.c ****  * pushed the registers onto the stack - causing the 32 registers to be on the 
  96:portable/GCC/ATMega64/port.c ****  * stack twice. 
  97:portable/GCC/ATMega64/port.c ****  * 
  98:portable/GCC/ATMega64/port.c ****  * r1 is set to zero as the compiler expects it to be thus, however some
  99:portable/GCC/ATMega64/port.c ****  * of the math routines make use of R1. 
 100:portable/GCC/ATMega64/port.c ****  * 
 101:portable/GCC/ATMega64/port.c ****  * The interrupts will have been disabled during the call to portSAVE_CONTEXT()
 102:portable/GCC/ATMega64/port.c ****  * so we need not worry about reading/writing to the stack pointer. 
 103:portable/GCC/ATMega64/port.c ****  */
 104:portable/GCC/ATMega64/port.c **** 
 105:portable/GCC/ATMega64/port.c **** #define portSAVE_CONTEXT()									\
 106:portable/GCC/ATMega64/port.c **** 	asm volatile (	"push	r0						\n\t"	\
 107:portable/GCC/ATMega64/port.c **** 					"in		r0, __SREG__			\n\t"	\
 108:portable/GCC/ATMega64/port.c **** 					"cli							\n\t"	\
 109:portable/GCC/ATMega64/port.c **** 					"push	r0						\n\t"	\
 110:portable/GCC/ATMega64/port.c **** 					"push	r1						\n\t"	\
 111:portable/GCC/ATMega64/port.c **** 					"clr	r1						\n\t"	\
 112:portable/GCC/ATMega64/port.c **** 					"push	r2						\n\t"	\
 113:portable/GCC/ATMega64/port.c **** 					"push	r3						\n\t"	\
 114:portable/GCC/ATMega64/port.c **** 					"push	r4						\n\t"	\
 115:portable/GCC/ATMega64/port.c **** 					"push	r5						\n\t"	\
 116:portable/GCC/ATMega64/port.c **** 					"push	r6						\n\t"	\
 117:portable/GCC/ATMega64/port.c **** 					"push	r7						\n\t"	\
 118:portable/GCC/ATMega64/port.c **** 					"push	r8						\n\t"	\
 119:portable/GCC/ATMega64/port.c **** 					"push	r9						\n\t"	\
 120:portable/GCC/ATMega64/port.c **** 					"push	r10						\n\t"	\
 121:portable/GCC/ATMega64/port.c **** 					"push	r11						\n\t"	\
 122:portable/GCC/ATMega64/port.c **** 					"push	r12						\n\t"	\
 123:portable/GCC/ATMega64/port.c **** 					"push	r13						\n\t"	\
 124:portable/GCC/ATMega64/port.c **** 					"push	r14						\n\t"	\
 125:portable/GCC/ATMega64/port.c **** 					"push	r15						\n\t"	\
 126:portable/GCC/ATMega64/port.c **** 					"push	r16						\n\t"	\
 127:portable/GCC/ATMega64/port.c **** 					"push	r17						\n\t"	\
 128:portable/GCC/ATMega64/port.c **** 					"push	r18						\n\t"	\
 129:portable/GCC/ATMega64/port.c **** 					"push	r19						\n\t"	\
 130:portable/GCC/ATMega64/port.c **** 					"push	r20						\n\t"	\
 131:portable/GCC/ATMega64/port.c **** 					"push	r21						\n\t"	\
 132:portable/GCC/ATMega64/port.c **** 					"push	r22						\n\t"	\
 133:portable/GCC/ATMega64/port.c **** 					"push	r23						\n\t"	\
 134:portable/GCC/ATMega64/port.c **** 					"push	r24						\n\t"	\
 135:portable/GCC/ATMega64/port.c **** 					"push	r25						\n\t"	\
 136:portable/GCC/ATMega64/port.c **** 					"push	r26						\n\t"	\
 137:portable/GCC/ATMega64/port.c **** 					"push	r27						\n\t"	\
 138:portable/GCC/ATMega64/port.c **** 					"push	r28						\n\t"	\
 139:portable/GCC/ATMega64/port.c **** 					"push	r29						\n\t"	\
 140:portable/GCC/ATMega64/port.c **** 					"push	r30						\n\t"	\
 141:portable/GCC/ATMega64/port.c **** 					"push	r31						\n\t"	\
 142:portable/GCC/ATMega64/port.c **** 					"lds	r26, pxCurrentTCB		\n\t"	\
 143:portable/GCC/ATMega64/port.c **** 					"lds	r27, pxCurrentTCB + 1	\n\t"	\
 144:portable/GCC/ATMega64/port.c **** 					"in		r0, 0x3d				\n\t"	\
 145:portable/GCC/ATMega64/port.c **** 					"st		x+, r0					\n\t"	\
 146:portable/GCC/ATMega64/port.c **** 					"in		r0, 0x3e				\n\t"	\
 147:portable/GCC/ATMega64/port.c **** 					"st		x+, r0					\n\t"	\
 148:portable/GCC/ATMega64/port.c **** 				);
 149:portable/GCC/ATMega64/port.c **** 
 150:portable/GCC/ATMega64/port.c **** /* 
 151:portable/GCC/ATMega64/port.c ****  * Opposite to portSAVE_CONTEXT().  Interrupts will have been disabled during
 152:portable/GCC/ATMega64/port.c ****  * the context save so we can write to the stack pointer. 
 153:portable/GCC/ATMega64/port.c ****  */
 154:portable/GCC/ATMega64/port.c **** 
 155:portable/GCC/ATMega64/port.c **** #define portRESTORE_CONTEXT()								\
 156:portable/GCC/ATMega64/port.c **** 	asm volatile (	"lds	r26, pxCurrentTCB		\n\t"	\
 157:portable/GCC/ATMega64/port.c **** 					"lds	r27, pxCurrentTCB + 1	\n\t"	\
 158:portable/GCC/ATMega64/port.c **** 					"ld		r28, x+					\n\t"	\
 159:portable/GCC/ATMega64/port.c **** 					"out	__SP_L__, r28			\n\t"	\
 160:portable/GCC/ATMega64/port.c **** 					"ld		r29, x+					\n\t"	\
 161:portable/GCC/ATMega64/port.c **** 					"out	__SP_H__, r29			\n\t"	\
 162:portable/GCC/ATMega64/port.c **** 					"pop	r31						\n\t"	\
 163:portable/GCC/ATMega64/port.c **** 					"pop	r30						\n\t"	\
 164:portable/GCC/ATMega64/port.c **** 					"pop	r29						\n\t"	\
 165:portable/GCC/ATMega64/port.c **** 					"pop	r28						\n\t"	\
 166:portable/GCC/ATMega64/port.c **** 					"pop	r27						\n\t"	\
 167:portable/GCC/ATMega64/port.c **** 					"pop	r26						\n\t"	\
 168:portable/GCC/ATMega64/port.c **** 					"pop	r25						\n\t"	\
 169:portable/GCC/ATMega64/port.c **** 					"pop	r24						\n\t"	\
 170:portable/GCC/ATMega64/port.c **** 					"pop	r23						\n\t"	\
 171:portable/GCC/ATMega64/port.c **** 					"pop	r22						\n\t"	\
 172:portable/GCC/ATMega64/port.c **** 					"pop	r21						\n\t"	\
 173:portable/GCC/ATMega64/port.c **** 					"pop	r20						\n\t"	\
 174:portable/GCC/ATMega64/port.c **** 					"pop	r19						\n\t"	\
 175:portable/GCC/ATMega64/port.c **** 					"pop	r18						\n\t"	\
 176:portable/GCC/ATMega64/port.c **** 					"pop	r17						\n\t"	\
 177:portable/GCC/ATMega64/port.c **** 					"pop	r16						\n\t"	\
 178:portable/GCC/ATMega64/port.c **** 					"pop	r15						\n\t"	\
 179:portable/GCC/ATMega64/port.c **** 					"pop	r14						\n\t"	\
 180:portable/GCC/ATMega64/port.c **** 					"pop	r13						\n\t"	\
 181:portable/GCC/ATMega64/port.c **** 					"pop	r12						\n\t"	\
 182:portable/GCC/ATMega64/port.c **** 					"pop	r11						\n\t"	\
 183:portable/GCC/ATMega64/port.c **** 					"pop	r10						\n\t"	\
 184:portable/GCC/ATMega64/port.c **** 					"pop	r9						\n\t"	\
 185:portable/GCC/ATMega64/port.c **** 					"pop	r8						\n\t"	\
 186:portable/GCC/ATMega64/port.c **** 					"pop	r7						\n\t"	\
 187:portable/GCC/ATMega64/port.c **** 					"pop	r6						\n\t"	\
 188:portable/GCC/ATMega64/port.c **** 					"pop	r5						\n\t"	\
 189:portable/GCC/ATMega64/port.c **** 					"pop	r4						\n\t"	\
 190:portable/GCC/ATMega64/port.c **** 					"pop	r3						\n\t"	\
 191:portable/GCC/ATMega64/port.c **** 					"pop	r2						\n\t"	\
 192:portable/GCC/ATMega64/port.c **** 					"pop	r1						\n\t"	\
 193:portable/GCC/ATMega64/port.c **** 					"pop	r0						\n\t"	\
 194:portable/GCC/ATMega64/port.c **** 					"out	__SREG__, r0			\n\t"	\
 195:portable/GCC/ATMega64/port.c **** 					"pop	r0						\n\t"	\
 196:portable/GCC/ATMega64/port.c **** 				);
 197:portable/GCC/ATMega64/port.c **** 
 198:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 199:portable/GCC/ATMega64/port.c **** 
 200:portable/GCC/ATMega64/port.c **** /*
 201:portable/GCC/ATMega64/port.c ****  * Perform hardware setup to enable ticks from timer 1, compare match A.
 202:portable/GCC/ATMega64/port.c ****  */
 203:portable/GCC/ATMega64/port.c **** static void prvSetupTimerInterrupt( void );
 204:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 205:portable/GCC/ATMega64/port.c **** 
 206:portable/GCC/ATMega64/port.c **** /* 
 207:portable/GCC/ATMega64/port.c ****  * See header file for description. 
 208:portable/GCC/ATMega64/port.c ****  */
 209:portable/GCC/ATMega64/port.c **** portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvPa
 210:portable/GCC/ATMega64/port.c **** {
 119               	.LM0:
 120               	.LFBB1:
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123 0000 FC01      		movw r30,r24
 211:portable/GCC/ATMega64/port.c **** unsigned portSHORT usAddress;
 212:portable/GCC/ATMega64/port.c **** 
 213:portable/GCC/ATMega64/port.c **** 	/* Place a few bytes of known values on the bottom of the stack. 
 214:portable/GCC/ATMega64/port.c **** 	This is just useful for debugging. */
 215:portable/GCC/ATMega64/port.c **** 
 216:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = 0x11;
 125               	.LM1:
 126 0002 91E1      		ldi r25,lo8(17)
 127 0004 9083      		st Z,r25
 217:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 218:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = 0x22;
 129               	.LM2:
 130 0006 22E2      		ldi r18,lo8(34)
 131 0008 2293      		st -Z,r18
 219:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 220:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = 0x33;
 133               	.LM3:
 134 000a 83E3      		ldi r24,lo8(51)
 135 000c 8293      		st -Z,r24
 221:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 222:portable/GCC/ATMega64/port.c **** 
 223:portable/GCC/ATMega64/port.c **** 	/* Simulate how the stack would look after a call to vPortYield() generated by 
 224:portable/GCC/ATMega64/port.c **** 	the compiler. */
 225:portable/GCC/ATMega64/port.c **** 
 226:portable/GCC/ATMega64/port.c **** 	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */
 227:portable/GCC/ATMega64/port.c **** 
 228:portable/GCC/ATMega64/port.c **** 	/* The start of the task code will be popped off the stack last, so place
 229:portable/GCC/ATMega64/port.c **** 	it on first. */
 230:portable/GCC/ATMega64/port.c **** 	usAddress = ( unsigned portSHORT ) pxCode;
 231:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
 137               	.LM4:
 138 000e 6293      		st -Z,r22
 232:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 233:portable/GCC/ATMega64/port.c **** 
 234:portable/GCC/ATMega64/port.c **** 	usAddress >>= 8;
 235:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
 140               	.LM5:
 141 0010 7293      		st -Z,r23
 236:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 237:portable/GCC/ATMega64/port.c **** 
 238:portable/GCC/ATMega64/port.c **** 	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
 239:portable/GCC/ATMega64/port.c **** 	portSAVE_CONTEXT places the flags on the stack immediately after r0
 240:portable/GCC/ATMega64/port.c **** 	to ensure the interrupts get disabled as soon as possible, and so ensuring
 241:portable/GCC/ATMega64/port.c **** 	the stack use is minimal should a context switch interrupt occur. */
 242:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
 143               	.LM6:
 144 0012 1292      		st -Z,__zero_reg__
 243:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 244:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = portFLAGS_INT_ENABLED;
 146               	.LM7:
 147 0014 80E8      		ldi r24,lo8(-128)
 148 0016 8293      		st -Z,r24
 245:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 246:portable/GCC/ATMega64/port.c **** 
 247:portable/GCC/ATMega64/port.c **** 
 248:portable/GCC/ATMega64/port.c **** 	/* Now the remaining registers.   The compiler expects R1 to be 0. */
 249:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
 150               	.LM8:
 151 0018 1292      		st -Z,__zero_reg__
 250:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 251:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
 153               	.LM9:
 154 001a 82E0      		ldi r24,lo8(2)
 155 001c 8293      		st -Z,r24
 252:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 253:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
 157               	.LM10:
 158 001e 83E0      		ldi r24,lo8(3)
 159 0020 8293      		st -Z,r24
 254:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 255:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
 161               	.LM11:
 162 0022 84E0      		ldi r24,lo8(4)
 163 0024 8293      		st -Z,r24
 256:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 257:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
 165               	.LM12:
 166 0026 85E0      		ldi r24,lo8(5)
 167 0028 8293      		st -Z,r24
 258:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 259:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
 169               	.LM13:
 170 002a 86E0      		ldi r24,lo8(6)
 171 002c 8293      		st -Z,r24
 260:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 261:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
 173               	.LM14:
 174 002e 87E0      		ldi r24,lo8(7)
 175 0030 8293      		st -Z,r24
 262:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 263:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
 177               	.LM15:
 178 0032 88E0      		ldi r24,lo8(8)
 179 0034 8293      		st -Z,r24
 264:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 265:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
 181               	.LM16:
 182 0036 89E0      		ldi r24,lo8(9)
 183 0038 8293      		st -Z,r24
 266:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 267:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
 185               	.LM17:
 186 003a 80E1      		ldi r24,lo8(16)
 187 003c 8293      		st -Z,r24
 268:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 269:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
 189               	.LM18:
 190 003e 9293      		st -Z,r25
 270:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 271:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
 192               	.LM19:
 193 0040 82E1      		ldi r24,lo8(18)
 194 0042 8293      		st -Z,r24
 272:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 273:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
 196               	.LM20:
 197 0044 83E1      		ldi r24,lo8(19)
 198 0046 8293      		st -Z,r24
 274:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 275:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
 200               	.LM21:
 201 0048 84E1      		ldi r24,lo8(20)
 202 004a 8293      		st -Z,r24
 276:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 277:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
 204               	.LM22:
 205 004c 85E1      		ldi r24,lo8(21)
 206 004e 8293      		st -Z,r24
 278:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 279:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
 208               	.LM23:
 209 0050 86E1      		ldi r24,lo8(22)
 210 0052 8293      		st -Z,r24
 280:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 281:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
 212               	.LM24:
 213 0054 87E1      		ldi r24,lo8(23)
 214 0056 8293      		st -Z,r24
 282:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 283:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
 216               	.LM25:
 217 0058 88E1      		ldi r24,lo8(24)
 218 005a 8293      		st -Z,r24
 284:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 285:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
 220               	.LM26:
 221 005c 89E1      		ldi r24,lo8(25)
 222 005e 8293      		st -Z,r24
 286:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 287:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
 224               	.LM27:
 225 0060 80E2      		ldi r24,lo8(32)
 226 0062 8293      		st -Z,r24
 288:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 289:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
 228               	.LM28:
 229 0064 81E2      		ldi r24,lo8(33)
 230 0066 8293      		st -Z,r24
 290:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 291:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
 232               	.LM29:
 233 0068 2293      		st -Z,r18
 292:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 293:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
 235               	.LM30:
 236 006a 83E2      		ldi r24,lo8(35)
 237 006c 8293      		st -Z,r24
 294:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 295:portable/GCC/ATMega64/port.c **** 
 296:portable/GCC/ATMega64/port.c **** 	/* Place the parameter on the stack in the expected location. */
 297:portable/GCC/ATMega64/port.c **** 	usAddress = ( unsigned portSHORT ) pvParameters;
 298:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
 239               	.LM31:
 240 006e 4293      		st -Z,r20
 299:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 300:portable/GCC/ATMega64/port.c **** 
 301:portable/GCC/ATMega64/port.c **** 	usAddress >>= 8;
 302:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
 242               	.LM32:
 243 0070 5293      		st -Z,r21
 303:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 304:portable/GCC/ATMega64/port.c **** 
 305:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
 245               	.LM33:
 246 0072 86E2      		ldi r24,lo8(38)
 247 0074 8293      		st -Z,r24
 306:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 307:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
 249               	.LM34:
 250 0076 87E2      		ldi r24,lo8(39)
 251 0078 8293      		st -Z,r24
 308:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 309:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
 253               	.LM35:
 254 007a 88E2      		ldi r24,lo8(40)
 255 007c 8293      		st -Z,r24
 310:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 311:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
 257               	.LM36:
 258 007e 89E2      		ldi r24,lo8(41)
 259 0080 8293      		st -Z,r24
 312:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 313:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
 261               	.LM37:
 262 0082 80E3      		ldi r24,lo8(48)
 263 0084 8293      		st -Z,r24
 314:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 315:portable/GCC/ATMega64/port.c **** 	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
 265               	.LM38:
 266 0086 81E3      		ldi r24,lo8(49)
 267 0088 8293      		st -Z,r24
 268 008a 3197      		sbiw r30,1
 316:portable/GCC/ATMega64/port.c **** 	pxTopOfStack--;
 317:portable/GCC/ATMega64/port.c **** 
 318:portable/GCC/ATMega64/port.c **** 	/*lint +e950 +e611 +e923 */
 319:portable/GCC/ATMega64/port.c **** 
 320:portable/GCC/ATMega64/port.c **** 	return pxTopOfStack;
 321:portable/GCC/ATMega64/port.c **** }
 270               	.LM39:
 271 008c CF01      		movw r24,r30
 272               	/* epilogue start */
 273 008e 0895      		ret
 275               	.Lscope1:
 277               		.stabd	78,0,0
 279               	.global	xPortStartScheduler
 281               	xPortStartScheduler:
 282               		.stabd	46,0,0
 322:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 323:portable/GCC/ATMega64/port.c **** 
 324:portable/GCC/ATMega64/port.c **** portBASE_TYPE xPortStartScheduler( void )
 325:portable/GCC/ATMega64/port.c **** {
 284               	.LM40:
 285               	.LFBB2:
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	.LBB4:
 289               	.LBB5:
 326:portable/GCC/ATMega64/port.c **** 	/* Setup the hardware to generate the tick. */
 327:portable/GCC/ATMega64/port.c **** 	prvSetupTimerInterrupt();
 328:portable/GCC/ATMega64/port.c **** 
 329:portable/GCC/ATMega64/port.c **** 	/* Restore the context of the first task that is going to run. */
 330:portable/GCC/ATMega64/port.c **** 	portRESTORE_CONTEXT();
 331:portable/GCC/ATMega64/port.c **** 
 332:portable/GCC/ATMega64/port.c **** 	/* Simulate a function call end as generated by the compiler.  We will now
 333:portable/GCC/ATMega64/port.c **** 	jump to the start of the task the context of which we have just restored. */
 334:portable/GCC/ATMega64/port.c **** 	asm volatile ( "ret" );
 335:portable/GCC/ATMega64/port.c **** 
 336:portable/GCC/ATMega64/port.c **** 	/* Should not get here. */
 337:portable/GCC/ATMega64/port.c **** 	return pdTRUE;
 338:portable/GCC/ATMega64/port.c **** }
 339:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 340:portable/GCC/ATMega64/port.c **** 
 341:portable/GCC/ATMega64/port.c **** void vPortEndScheduler( void )
 342:portable/GCC/ATMega64/port.c **** {
 343:portable/GCC/ATMega64/port.c **** 	/* It is unlikely that the AVR port will get stopped.  If required simply
 344:portable/GCC/ATMega64/port.c **** 	disable the tick interrupt here. */
 345:portable/GCC/ATMega64/port.c **** }
 346:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 347:portable/GCC/ATMega64/port.c **** 
 348:portable/GCC/ATMega64/port.c **** /*
 349:portable/GCC/ATMega64/port.c ****  * Manual context switch.  The first thing we do is save the registers so we
 350:portable/GCC/ATMega64/port.c ****  * can use a naked attribute.
 351:portable/GCC/ATMega64/port.c ****  */
 352:portable/GCC/ATMega64/port.c **** void vPortYield( void ) __attribute__ ( ( naked ) );
 353:portable/GCC/ATMega64/port.c **** void vPortYield( void )
 354:portable/GCC/ATMega64/port.c **** {
 355:portable/GCC/ATMega64/port.c **** 	portSAVE_CONTEXT();
 356:portable/GCC/ATMega64/port.c **** 	vTaskSwitchContext();
 357:portable/GCC/ATMega64/port.c **** 	portRESTORE_CONTEXT();
 358:portable/GCC/ATMega64/port.c **** 
 359:portable/GCC/ATMega64/port.c **** 	asm volatile ( "ret" );
 360:portable/GCC/ATMega64/port.c **** }
 361:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 362:portable/GCC/ATMega64/port.c **** 
 363:portable/GCC/ATMega64/port.c **** /*
 364:portable/GCC/ATMega64/port.c ****  * Context switch function used by the tick.  This must be identical to 
 365:portable/GCC/ATMega64/port.c ****  * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
 366:portable/GCC/ATMega64/port.c ****  * difference from vPortYield() is the tick count is incremented as the
 367:portable/GCC/ATMega64/port.c ****  * call comes from the tick ISR.
 368:portable/GCC/ATMega64/port.c ****  */
 369:portable/GCC/ATMega64/port.c **** void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
 370:portable/GCC/ATMega64/port.c **** void vPortYieldFromTick( void )
 371:portable/GCC/ATMega64/port.c **** {
 372:portable/GCC/ATMega64/port.c **** 	portSAVE_CONTEXT();
 373:portable/GCC/ATMega64/port.c **** 	vTaskIncrementTick();
 374:portable/GCC/ATMega64/port.c **** 	vTaskSwitchContext();
 375:portable/GCC/ATMega64/port.c **** 	portRESTORE_CONTEXT();
 376:portable/GCC/ATMega64/port.c **** 
 377:portable/GCC/ATMega64/port.c **** 	asm volatile ( "ret" );
 378:portable/GCC/ATMega64/port.c **** }
 379:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 380:portable/GCC/ATMega64/port.c **** 
 381:portable/GCC/ATMega64/port.c **** /*
 382:portable/GCC/ATMega64/port.c ****  * Setup timer 1 compare match A to generate a tick interrupt.
 383:portable/GCC/ATMega64/port.c ****  */
 384:portable/GCC/ATMega64/port.c **** static void prvSetupTimerInterrupt( void )
 385:portable/GCC/ATMega64/port.c **** {
 386:portable/GCC/ATMega64/port.c **** unsigned portLONG ulCompareMatch;
 387:portable/GCC/ATMega64/port.c **** unsigned portCHAR ucHighByte, ucLowByte;
 388:portable/GCC/ATMega64/port.c **** 
 389:portable/GCC/ATMega64/port.c **** 	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
 390:portable/GCC/ATMega64/port.c **** 	selected for the configCPU_CLOCK_HZ clock. */
 391:portable/GCC/ATMega64/port.c **** 
 392:portable/GCC/ATMega64/port.c **** 	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
 393:portable/GCC/ATMega64/port.c **** 
 394:portable/GCC/ATMega64/port.c **** 	/* We only have 16 bits so have to scale to get our required tick rate. */
 395:portable/GCC/ATMega64/port.c **** 	ulCompareMatch /= portCLOCK_PRESCALER;
 396:portable/GCC/ATMega64/port.c **** 
 397:portable/GCC/ATMega64/port.c **** 	/* Adjust for correct value. */
 398:portable/GCC/ATMega64/port.c **** 	ulCompareMatch -= ( unsigned portLONG ) 1;
 399:portable/GCC/ATMega64/port.c **** 
 400:portable/GCC/ATMega64/port.c **** 	/* Setup compare match value for compare match A.  Interrupts are disabled 
 401:portable/GCC/ATMega64/port.c **** 	before this is called so we need not worry here. */
 402:portable/GCC/ATMega64/port.c **** 	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
 403:portable/GCC/ATMega64/port.c **** 	ulCompareMatch >>= 8;
 404:portable/GCC/ATMega64/port.c **** 	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
 405:portable/GCC/ATMega64/port.c **** 	OCR1AH = ucHighByte;
 291               	.LM41:
 292 0090 88E0      		ldi r24,lo8(8)
 293 0092 8BBD      		out 75-32,r24
 406:portable/GCC/ATMega64/port.c **** 	OCR1AL = ucLowByte;
 295               	.LM42:
 296 0094 8FEF      		ldi r24,lo8(-1)
 297 0096 8ABD      		out 74-32,r24
 407:portable/GCC/ATMega64/port.c **** 
 408:portable/GCC/ATMega64/port.c **** 	/* Setup clock source and compare match behaviour. */
 409:portable/GCC/ATMega64/port.c **** 	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
 410:portable/GCC/ATMega64/port.c **** 	TCCR1B = ucLowByte;
 299               	.LM43:
 300 0098 8BE0      		ldi r24,lo8(11)
 301 009a 8EBD      		out 78-32,r24
 411:portable/GCC/ATMega64/port.c **** 
 412:portable/GCC/ATMega64/port.c **** 	/* Enable the interrupt - this is okay as interrupt are currently globally
 413:portable/GCC/ATMega64/port.c **** 	disabled. */
 414:portable/GCC/ATMega64/port.c **** 	ucLowByte = TIMSK;
 303               	.LM44:
 304 009c 87B7      		in r24,87-32
 415:portable/GCC/ATMega64/port.c **** 	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 306               	.LM45:
 307 009e 8061      		ori r24,lo8(16)
 416:portable/GCC/ATMega64/port.c **** 	TIMSK = ucLowByte;
 309               	.LM46:
 310 00a0 87BF      		out 87-32,r24
 311               	.LBE5:
 312               	.LBE4:
 330:portable/GCC/ATMega64/port.c **** 	portRESTORE_CONTEXT();
 314               	.LM47:
 315               	/* #APP */
 316               	 ;  330 "portable/GCC/ATMega64/port.c" 1
 317 00a2 A091 0000 		lds	r26, pxCurrentTCB		
 318 00a6 B091 0000 		lds	r27, pxCurrentTCB + 1	
 319 00aa CD91      		ld		r28, x+					
 320 00ac CDBF      		out	__SP_L__, r28			
 321 00ae DD91      		ld		r29, x+					
 322 00b0 DEBF      		out	__SP_H__, r29			
 323 00b2 FF91      		pop	r31						
 324 00b4 EF91      		pop	r30						
 325 00b6 DF91      		pop	r29						
 326 00b8 CF91      		pop	r28						
 327 00ba BF91      		pop	r27						
 328 00bc AF91      		pop	r26						
 329 00be 9F91      		pop	r25						
 330 00c0 8F91      		pop	r24						
 331 00c2 7F91      		pop	r23						
 332 00c4 6F91      		pop	r22						
 333 00c6 5F91      		pop	r21						
 334 00c8 4F91      		pop	r20						
 335 00ca 3F91      		pop	r19						
 336 00cc 2F91      		pop	r18						
 337 00ce 1F91      		pop	r17						
 338 00d0 0F91      		pop	r16						
 339 00d2 FF90      		pop	r15						
 340 00d4 EF90      		pop	r14						
 341 00d6 DF90      		pop	r13						
 342 00d8 CF90      		pop	r12						
 343 00da BF90      		pop	r11						
 344 00dc AF90      		pop	r10						
 345 00de 9F90      		pop	r9						
 346 00e0 8F90      		pop	r8						
 347 00e2 7F90      		pop	r7						
 348 00e4 6F90      		pop	r6						
 349 00e6 5F90      		pop	r5						
 350 00e8 4F90      		pop	r4						
 351 00ea 3F90      		pop	r3						
 352 00ec 2F90      		pop	r2						
 353 00ee 1F90      		pop	r1						
 354 00f0 0F90      		pop	r0						
 355 00f2 0FBE      		out	__SREG__, r0			
 356 00f4 0F90      		pop	r0						
 357               		
 358               	 ;  0 "" 2
 334:portable/GCC/ATMega64/port.c **** 	asm volatile ( "ret" );
 360               	.LM48:
 361               	 ;  334 "portable/GCC/ATMega64/port.c" 1
 362 00f6 0895      		ret
 363               	 ;  0 "" 2
 338:portable/GCC/ATMega64/port.c **** }
 365               	.LM49:
 366               	/* #NOAPP */
 367 00f8 81E0      		ldi r24,lo8(1)
 368               	/* epilogue start */
 369 00fa 0895      		ret
 374               	.Lscope2:
 376               		.stabd	78,0,0
 378               	.global	vPortEndScheduler
 380               	vPortEndScheduler:
 381               		.stabd	46,0,0
 342:portable/GCC/ATMega64/port.c **** {
 383               	.LM50:
 384               	.LFBB3:
 385               	/* prologue: function */
 386               	/* frame size = 0 */
 387               	/* epilogue start */
 345:portable/GCC/ATMega64/port.c **** }
 389               	.LM51:
 390 00fc 0895      		ret
 392               	.Lscope3:
 394               		.stabd	78,0,0
 396               	.global	__vector_12
 398               	__vector_12:
 399               		.stabd	46,0,0
 417:portable/GCC/ATMega64/port.c **** }
 418:portable/GCC/ATMega64/port.c **** /*-----------------------------------------------------------*/
 419:portable/GCC/ATMega64/port.c **** 
 420:portable/GCC/ATMega64/port.c **** #if configUSE_PREEMPTION == 1
 421:portable/GCC/ATMega64/port.c **** 
 422:portable/GCC/ATMega64/port.c **** 	/*
 423:portable/GCC/ATMega64/port.c **** 	 * Tick ISR for preemptive scheduler.  We can use a naked attribute as
 424:portable/GCC/ATMega64/port.c **** 	 * the context is saved at the start of vPortYieldFromTick().  The tick
 425:portable/GCC/ATMega64/port.c **** 	 * count is incremented after the context is saved.
 426:portable/GCC/ATMega64/port.c **** 	 */
 427:portable/GCC/ATMega64/port.c **** 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
 428:portable/GCC/ATMega64/port.c **** 	void SIG_OUTPUT_COMPARE1A( void )
 429:portable/GCC/ATMega64/port.c **** 	{
 430:portable/GCC/ATMega64/port.c **** 		vPortYieldFromTick();
 431:portable/GCC/ATMega64/port.c **** 		asm volatile ( "reti" );
 432:portable/GCC/ATMega64/port.c **** 	}
 433:portable/GCC/ATMega64/port.c **** #else
 434:portable/GCC/ATMega64/port.c **** 
 435:portable/GCC/ATMega64/port.c **** 	/*
 436:portable/GCC/ATMega64/port.c **** 	 * Tick ISR for the cooperative scheduler.  All this does is increment the
 437:portable/GCC/ATMega64/port.c **** 	 * tick count.  We don't need to switch context, this can only be done by
 438:portable/GCC/ATMega64/port.c **** 	 * manual calls to taskYIELD();
 439:portable/GCC/ATMega64/port.c **** 	 */
 440:portable/GCC/ATMega64/port.c **** 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
 441:portable/GCC/ATMega64/port.c **** 	void SIG_OUTPUT_COMPARE1A( void )
 442:portable/GCC/ATMega64/port.c **** 	{
 401               	.LM52:
 402               	.LFBB4:
 403 00fe 1F92      		push __zero_reg__
 404 0100 0F92      		push r0
 405 0102 0FB6      		in r0,__SREG__
 406 0104 0F92      		push r0
 407 0106 0BB6      		in r0,91-32
 408 0108 0F92      		push r0
 409 010a 1124      		clr __zero_reg__
 410 010c 2F93      		push r18
 411 010e 3F93      		push r19
 412 0110 4F93      		push r20
 413 0112 5F93      		push r21
 414 0114 6F93      		push r22
 415 0116 7F93      		push r23
 416 0118 8F93      		push r24
 417 011a 9F93      		push r25
 418 011c AF93      		push r26
 419 011e BF93      		push r27
 420 0120 EF93      		push r30
 421 0122 FF93      		push r31
 422               	/* prologue: Signal */
 423               	/* frame size = 0 */
 443:portable/GCC/ATMega64/port.c **** 		vTaskIncrementTick();
 425               	.LM53:
 426 0124 0E94 0000 		call vTaskIncrementTick
 427               	/* epilogue start */
 444:portable/GCC/ATMega64/port.c **** 	}
 429               	.LM54:
 430 0128 FF91      		pop r31
 431 012a EF91      		pop r30
 432 012c BF91      		pop r27
 433 012e AF91      		pop r26
 434 0130 9F91      		pop r25
 435 0132 8F91      		pop r24
 436 0134 7F91      		pop r23
 437 0136 6F91      		pop r22
 438 0138 5F91      		pop r21
 439 013a 4F91      		pop r20
 440 013c 3F91      		pop r19
 441 013e 2F91      		pop r18
 442 0140 0F90      		pop r0
 443 0142 0BBE      		out 91-32,r0
 444 0144 0F90      		pop r0
 445 0146 0FBE      		out __SREG__,r0
 446 0148 0F90      		pop r0
 447 014a 1F90      		pop __zero_reg__
 448 014c 1895      		reti
 450               	.Lscope4:
 452               		.stabd	78,0,0
 454               	.global	vPortYieldFromTick
 456               	vPortYieldFromTick:
 457               		.stabd	46,0,0
 371:portable/GCC/ATMega64/port.c **** {
 459               	.LM55:
 460               	.LFBB5:
 461               	/* prologue: naked */
 462               	/* frame size = 0 */
 372:portable/GCC/ATMega64/port.c **** 	portSAVE_CONTEXT();
 464               	.LM56:
 465               	/* #APP */
 466               	 ;  372 "portable/GCC/ATMega64/port.c" 1
 467 014e 0F92      		push	r0						
 468 0150 0FB6      		in		r0, __SREG__			
 469 0152 F894      		cli							
 470 0154 0F92      		push	r0						
 471 0156 1F92      		push	r1						
 472 0158 1124      		clr	r1						
 473 015a 2F92      		push	r2						
 474 015c 3F92      		push	r3						
 475 015e 4F92      		push	r4						
 476 0160 5F92      		push	r5						
 477 0162 6F92      		push	r6						
 478 0164 7F92      		push	r7						
 479 0166 8F92      		push	r8						
 480 0168 9F92      		push	r9						
 481 016a AF92      		push	r10						
 482 016c BF92      		push	r11						
 483 016e CF92      		push	r12						
 484 0170 DF92      		push	r13						
 485 0172 EF92      		push	r14						
 486 0174 FF92      		push	r15						
 487 0176 0F93      		push	r16						
 488 0178 1F93      		push	r17						
 489 017a 2F93      		push	r18						
 490 017c 3F93      		push	r19						
 491 017e 4F93      		push	r20						
 492 0180 5F93      		push	r21						
 493 0182 6F93      		push	r22						
 494 0184 7F93      		push	r23						
 495 0186 8F93      		push	r24						
 496 0188 9F93      		push	r25						
 497 018a AF93      		push	r26						
 498 018c BF93      		push	r27						
 499 018e CF93      		push	r28						
 500 0190 DF93      		push	r29						
 501 0192 EF93      		push	r30						
 502 0194 FF93      		push	r31						
 503 0196 A091 0000 		lds	r26, pxCurrentTCB		
 504 019a B091 0000 		lds	r27, pxCurrentTCB + 1	
 505 019e 0DB6      		in		r0, 0x3d				
 506 01a0 0D92      		st		x+, r0					
 507 01a2 0EB6      		in		r0, 0x3e				
 508 01a4 0D92      		st		x+, r0					
 509               		
 510               	 ;  0 "" 2
 373:portable/GCC/ATMega64/port.c **** 	vTaskIncrementTick();
 512               	.LM57:
 513               	/* #NOAPP */
 514 01a6 0E94 0000 		call vTaskIncrementTick
 374:portable/GCC/ATMega64/port.c **** 	vTaskSwitchContext();
 516               	.LM58:
 517 01aa 0E94 0000 		call vTaskSwitchContext
 375:portable/GCC/ATMega64/port.c **** 	portRESTORE_CONTEXT();
 519               	.LM59:
 520               	/* #APP */
 521               	 ;  375 "portable/GCC/ATMega64/port.c" 1
 522 01ae A091 0000 		lds	r26, pxCurrentTCB		
 523 01b2 B091 0000 		lds	r27, pxCurrentTCB + 1	
 524 01b6 CD91      		ld		r28, x+					
 525 01b8 CDBF      		out	__SP_L__, r28			
 526 01ba DD91      		ld		r29, x+					
 527 01bc DEBF      		out	__SP_H__, r29			
 528 01be FF91      		pop	r31						
 529 01c0 EF91      		pop	r30						
 530 01c2 DF91      		pop	r29						
 531 01c4 CF91      		pop	r28						
 532 01c6 BF91      		pop	r27						
 533 01c8 AF91      		pop	r26						
 534 01ca 9F91      		pop	r25						
 535 01cc 8F91      		pop	r24						
 536 01ce 7F91      		pop	r23						
 537 01d0 6F91      		pop	r22						
 538 01d2 5F91      		pop	r21						
 539 01d4 4F91      		pop	r20						
 540 01d6 3F91      		pop	r19						
 541 01d8 2F91      		pop	r18						
 542 01da 1F91      		pop	r17						
 543 01dc 0F91      		pop	r16						
 544 01de FF90      		pop	r15						
 545 01e0 EF90      		pop	r14						
 546 01e2 DF90      		pop	r13						
 547 01e4 CF90      		pop	r12						
 548 01e6 BF90      		pop	r11						
 549 01e8 AF90      		pop	r10						
 550 01ea 9F90      		pop	r9						
 551 01ec 8F90      		pop	r8						
 552 01ee 7F90      		pop	r7						
 553 01f0 6F90      		pop	r6						
 554 01f2 5F90      		pop	r5						
 555 01f4 4F90      		pop	r4						
 556 01f6 3F90      		pop	r3						
 557 01f8 2F90      		pop	r2						
 558 01fa 1F90      		pop	r1						
 559 01fc 0F90      		pop	r0						
 560 01fe 0FBE      		out	__SREG__, r0			
 561 0200 0F90      		pop	r0						
 562               		
 563               	 ;  0 "" 2
 377:portable/GCC/ATMega64/port.c **** 	asm volatile ( "ret" );
 565               	.LM60:
 566               	 ;  377 "portable/GCC/ATMega64/port.c" 1
 567 0202 0895      		ret
 568               	 ;  0 "" 2
 569               	/* epilogue start */
 378:portable/GCC/ATMega64/port.c **** }
 571               	.LM61:
 572               	/* #NOAPP */
 574               	.Lscope5:
 576               		.stabd	78,0,0
 578               	.global	vPortYield
 580               	vPortYield:
 581               		.stabd	46,0,0
 354:portable/GCC/ATMega64/port.c **** {
 583               	.LM62:
 584               	.LFBB6:
 585               	/* prologue: naked */
 586               	/* frame size = 0 */
 355:portable/GCC/ATMega64/port.c **** 	portSAVE_CONTEXT();
 588               	.LM63:
 589               	/* #APP */
 590               	 ;  355 "portable/GCC/ATMega64/port.c" 1
 591 0204 0F92      		push	r0						
 592 0206 0FB6      		in		r0, __SREG__			
 593 0208 F894      		cli							
 594 020a 0F92      		push	r0						
 595 020c 1F92      		push	r1						
 596 020e 1124      		clr	r1						
 597 0210 2F92      		push	r2						
 598 0212 3F92      		push	r3						
 599 0214 4F92      		push	r4						
 600 0216 5F92      		push	r5						
 601 0218 6F92      		push	r6						
 602 021a 7F92      		push	r7						
 603 021c 8F92      		push	r8						
 604 021e 9F92      		push	r9						
 605 0220 AF92      		push	r10						
 606 0222 BF92      		push	r11						
 607 0224 CF92      		push	r12						
 608 0226 DF92      		push	r13						
 609 0228 EF92      		push	r14						
 610 022a FF92      		push	r15						
 611 022c 0F93      		push	r16						
 612 022e 1F93      		push	r17						
 613 0230 2F93      		push	r18						
 614 0232 3F93      		push	r19						
 615 0234 4F93      		push	r20						
 616 0236 5F93      		push	r21						
 617 0238 6F93      		push	r22						
 618 023a 7F93      		push	r23						
 619 023c 8F93      		push	r24						
 620 023e 9F93      		push	r25						
 621 0240 AF93      		push	r26						
 622 0242 BF93      		push	r27						
 623 0244 CF93      		push	r28						
 624 0246 DF93      		push	r29						
 625 0248 EF93      		push	r30						
 626 024a FF93      		push	r31						
 627 024c A091 0000 		lds	r26, pxCurrentTCB		
 628 0250 B091 0000 		lds	r27, pxCurrentTCB + 1	
 629 0254 0DB6      		in		r0, 0x3d				
 630 0256 0D92      		st		x+, r0					
 631 0258 0EB6      		in		r0, 0x3e				
 632 025a 0D92      		st		x+, r0					
 633               		
 634               	 ;  0 "" 2
 356:portable/GCC/ATMega64/port.c **** 	vTaskSwitchContext();
 636               	.LM64:
 637               	/* #NOAPP */
 638 025c 0E94 0000 		call vTaskSwitchContext
 357:portable/GCC/ATMega64/port.c **** 	portRESTORE_CONTEXT();
 640               	.LM65:
 641               	/* #APP */
 642               	 ;  357 "portable/GCC/ATMega64/port.c" 1
 643 0260 A091 0000 		lds	r26, pxCurrentTCB		
 644 0264 B091 0000 		lds	r27, pxCurrentTCB + 1	
 645 0268 CD91      		ld		r28, x+					
 646 026a CDBF      		out	__SP_L__, r28			
 647 026c DD91      		ld		r29, x+					
 648 026e DEBF      		out	__SP_H__, r29			
 649 0270 FF91      		pop	r31						
 650 0272 EF91      		pop	r30						
 651 0274 DF91      		pop	r29						
 652 0276 CF91      		pop	r28						
 653 0278 BF91      		pop	r27						
 654 027a AF91      		pop	r26						
 655 027c 9F91      		pop	r25						
 656 027e 8F91      		pop	r24						
 657 0280 7F91      		pop	r23						
 658 0282 6F91      		pop	r22						
 659 0284 5F91      		pop	r21						
 660 0286 4F91      		pop	r20						
 661 0288 3F91      		pop	r19						
 662 028a 2F91      		pop	r18						
 663 028c 1F91      		pop	r17						
 664 028e 0F91      		pop	r16						
 665 0290 FF90      		pop	r15						
 666 0292 EF90      		pop	r14						
 667 0294 DF90      		pop	r13						
 668 0296 CF90      		pop	r12						
 669 0298 BF90      		pop	r11						
 670 029a AF90      		pop	r10						
 671 029c 9F90      		pop	r9						
 672 029e 8F90      		pop	r8						
 673 02a0 7F90      		pop	r7						
 674 02a2 6F90      		pop	r6						
 675 02a4 5F90      		pop	r5						
 676 02a6 4F90      		pop	r4						
 677 02a8 3F90      		pop	r3						
 678 02aa 2F90      		pop	r2						
 679 02ac 1F90      		pop	r1						
 680 02ae 0F90      		pop	r0						
 681 02b0 0FBE      		out	__SREG__, r0			
 682 02b2 0F90      		pop	r0						
 683               		
 684               	 ;  0 "" 2
 359:portable/GCC/ATMega64/port.c **** 	asm volatile ( "ret" );
 686               	.LM66:
 687               	 ;  359 "portable/GCC/ATMega64/port.c" 1
 688 02b4 0895      		ret
 689               	 ;  0 "" 2
 690               	/* epilogue start */
 360:portable/GCC/ATMega64/port.c **** }
 692               	.LM67:
 693               	/* #NOAPP */
 695               	.Lscope6:
 697               		.stabd	78,0,0
 699               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 port.c
     /tmp/ccL7CQzA.s:2      *ABS*:0000003f __SREG__
     /tmp/ccL7CQzA.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccL7CQzA.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccL7CQzA.s:5      *ABS*:00000034 __CCP__
     /tmp/ccL7CQzA.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccL7CQzA.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccL7CQzA.s:116    .text:00000000 pxPortInitialiseStack
     /tmp/ccL7CQzA.s:281    .text:00000090 xPortStartScheduler
     /tmp/ccL7CQzA.s:380    .text:000000fc vPortEndScheduler
     /tmp/ccL7CQzA.s:398    .text:000000fe __vector_12
     /tmp/ccL7CQzA.s:456    .text:0000014e vPortYieldFromTick
     /tmp/ccL7CQzA.s:580    .text:00000204 vPortYield

UNDEFINED SYMBOLS
pxCurrentTCB
vTaskIncrementTick
vTaskSwitchContext
