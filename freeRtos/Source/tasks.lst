   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__RAMPY__ = 0x3a
   7               	__RAMPX__ = 0x39
   8               	__RAMPD__ = 0x38
   9               	__CCP__ = 0x34
  10               	__tmp_reg__ = 0
  11               	__zero_reg__ = 1
  14               		.text
  15               	.Ltext0:
 484               	prvIdleTask:
 485               		.stabd	46,0,0
   1:../../freeRtos/Source/tasks.c **** /*
   2:../../freeRtos/Source/tasks.c ****     FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:../../freeRtos/Source/tasks.c **** 
   4:../../freeRtos/Source/tasks.c ****     ***************************************************************************
   5:../../freeRtos/Source/tasks.c ****     *                                                                         *
   6:../../freeRtos/Source/tasks.c ****     * If you are:                                                             *
   7:../../freeRtos/Source/tasks.c ****     *                                                                         *
   8:../../freeRtos/Source/tasks.c ****     *    + New to FreeRTOS,                                                   *
   9:../../freeRtos/Source/tasks.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:../../freeRtos/Source/tasks.c ****     *    + Looking for basic training,                                        *
  11:../../freeRtos/Source/tasks.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:../../freeRtos/Source/tasks.c ****     *                                                                         *
  13:../../freeRtos/Source/tasks.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:../../freeRtos/Source/tasks.c ****     *                                                                         *
  15:../../freeRtos/Source/tasks.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:../../freeRtos/Source/tasks.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:../../freeRtos/Source/tasks.c ****     *                                                                         *
  18:../../freeRtos/Source/tasks.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:../../freeRtos/Source/tasks.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:../../freeRtos/Source/tasks.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:../../freeRtos/Source/tasks.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:../../freeRtos/Source/tasks.c ****     *                                                                         *
  23:../../freeRtos/Source/tasks.c ****     ***************************************************************************
  24:../../freeRtos/Source/tasks.c **** 
  25:../../freeRtos/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../../freeRtos/Source/tasks.c **** 
  27:../../freeRtos/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../../freeRtos/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../../freeRtos/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../../freeRtos/Source/tasks.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:../../freeRtos/Source/tasks.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:../../freeRtos/Source/tasks.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:../../freeRtos/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:../../freeRtos/Source/tasks.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:../../freeRtos/Source/tasks.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../../freeRtos/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public 
  37:../../freeRtos/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:../../freeRtos/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:../../freeRtos/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../../freeRtos/Source/tasks.c ****     FreeRTOS WEB site.
  41:../../freeRtos/Source/tasks.c **** 
  42:../../freeRtos/Source/tasks.c ****     1 tab == 4 spaces!
  43:../../freeRtos/Source/tasks.c **** 
  44:../../freeRtos/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../../freeRtos/Source/tasks.c ****     contact details.
  46:../../freeRtos/Source/tasks.c **** 
  47:../../freeRtos/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../../freeRtos/Source/tasks.c ****     critical systems.
  49:../../freeRtos/Source/tasks.c **** 
  50:../../freeRtos/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../../freeRtos/Source/tasks.c ****     licensing and training services.
  52:../../freeRtos/Source/tasks.c **** */
  53:../../freeRtos/Source/tasks.c **** 
  54:../../freeRtos/Source/tasks.c **** 
  55:../../freeRtos/Source/tasks.c **** #include <stdio.h>
  56:../../freeRtos/Source/tasks.c **** #include <stdlib.h>
  57:../../freeRtos/Source/tasks.c **** #include <string.h>
  58:../../freeRtos/Source/tasks.c **** 
  59:../../freeRtos/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../../freeRtos/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../../freeRtos/Source/tasks.c **** task.h is included from an application file. */
  62:../../freeRtos/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../../freeRtos/Source/tasks.c **** 
  64:../../freeRtos/Source/tasks.c **** #include "FreeRTOS.h"
  65:../../freeRtos/Source/tasks.c **** #include "task.h"
  66:../../freeRtos/Source/tasks.c **** #include "StackMacros.h"
  67:../../freeRtos/Source/tasks.c **** 
  68:../../freeRtos/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  69:../../freeRtos/Source/tasks.c **** 
  70:../../freeRtos/Source/tasks.c **** /*
  71:../../freeRtos/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  72:../../freeRtos/Source/tasks.c ****  */
  73:../../freeRtos/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  74:../../freeRtos/Source/tasks.c **** 
  75:../../freeRtos/Source/tasks.c **** /*
  76:../../freeRtos/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  77:../../freeRtos/Source/tasks.c ****  * and stores the context of the task.
  78:../../freeRtos/Source/tasks.c ****  */
  79:../../freeRtos/Source/tasks.c **** typedef struct tskTaskControlBlock
  80:../../freeRtos/Source/tasks.c **** {
  81:../../freeRtos/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  82:../../freeRtos/Source/tasks.c **** 
  83:../../freeRtos/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  84:../../freeRtos/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  85:../../freeRtos/Source/tasks.c **** 	#endif	
  86:../../freeRtos/Source/tasks.c **** 	
  87:../../freeRtos/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  88:../../freeRtos/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  89:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  90:../../freeRtos/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  91:../../freeRtos/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  92:../../freeRtos/Source/tasks.c **** 
  93:../../freeRtos/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  94:../../freeRtos/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  95:../../freeRtos/Source/tasks.c **** 	#endif
  96:../../freeRtos/Source/tasks.c **** 
  97:../../freeRtos/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  98:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
  99:../../freeRtos/Source/tasks.c **** 	#endif
 100:../../freeRtos/Source/tasks.c **** 
 101:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 102:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 103:../../freeRtos/Source/tasks.c **** 	#endif
 104:../../freeRtos/Source/tasks.c **** 
 105:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 106:../../freeRtos/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 107:../../freeRtos/Source/tasks.c **** 	#endif
 108:../../freeRtos/Source/tasks.c **** 
 109:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 110:../../freeRtos/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 111:../../freeRtos/Source/tasks.c **** 	#endif
 112:../../freeRtos/Source/tasks.c **** 
 113:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 114:../../freeRtos/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 115:../../freeRtos/Source/tasks.c **** 	#endif
 116:../../freeRtos/Source/tasks.c **** 
 117:../../freeRtos/Source/tasks.c **** } tskTCB;
 118:../../freeRtos/Source/tasks.c **** 
 119:../../freeRtos/Source/tasks.c **** 
 120:../../freeRtos/Source/tasks.c **** /*
 121:../../freeRtos/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 122:../../freeRtos/Source/tasks.c ****  * than file scope.
 123:../../freeRtos/Source/tasks.c ****  */
 124:../../freeRtos/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 125:../../freeRtos/Source/tasks.c **** 	#define static
 126:../../freeRtos/Source/tasks.c **** #endif
 127:../../freeRtos/Source/tasks.c **** 
 128:../../freeRtos/Source/tasks.c **** /*lint -e956 */
 129:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 130:../../freeRtos/Source/tasks.c **** 
 131:../../freeRtos/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 132:../../freeRtos/Source/tasks.c **** 
 133:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 134:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 135:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 136:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 137:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 138:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 139:../../freeRtos/Source/tasks.c **** 
 140:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 141:../../freeRtos/Source/tasks.c **** 
 142:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted 
 143:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 144:../../freeRtos/Source/tasks.c **** 
 145:../../freeRtos/Source/tasks.c **** #endif
 146:../../freeRtos/Source/tasks.c **** 
 147:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 148:../../freeRtos/Source/tasks.c **** 
 149:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 150:../../freeRtos/Source/tasks.c **** 
 151:../../freeRtos/Source/tasks.c **** #endif
 152:../../freeRtos/Source/tasks.c **** 
 153:../../freeRtos/Source/tasks.c **** /* File private variables. --------------------------------*/
 154:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 155:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
 156:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 157:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 158:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 159:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 160:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 161:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 162:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 163:../../freeRtos/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
 164:../../freeRtos/Source/tasks.c **** 
 165:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 166:../../freeRtos/Source/tasks.c **** 
 167:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 168:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 169:../../freeRtos/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 170:../../freeRtos/Source/tasks.c **** 
 171:../../freeRtos/Source/tasks.c **** #endif
 172:../../freeRtos/Source/tasks.c **** 
 173:../../freeRtos/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 174:../../freeRtos/Source/tasks.c **** 
 175:../../freeRtos/Source/tasks.c **** /*
 176:../../freeRtos/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 177:../../freeRtos/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 178:../../freeRtos/Source/tasks.c ****  */
 179:../../freeRtos/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5 )
 180:../../freeRtos/Source/tasks.c **** 
 181:../../freeRtos/Source/tasks.c **** /*
 182:../../freeRtos/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 183:../../freeRtos/Source/tasks.c ****  */
 184:../../freeRtos/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 185:../../freeRtos/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 186:../../freeRtos/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 187:../../freeRtos/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 188:../../freeRtos/Source/tasks.c **** 
 189:../../freeRtos/Source/tasks.c **** /*
 190:../../freeRtos/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 191:../../freeRtos/Source/tasks.c ****  */
 192:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 193:../../freeRtos/Source/tasks.c **** 
 194:../../freeRtos/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 195:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 196:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 197:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 198:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 199:../../freeRtos/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255;
 200:../../freeRtos/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 201:../../freeRtos/Source/tasks.c **** 
 202:../../freeRtos/Source/tasks.c **** #endif
 203:../../freeRtos/Source/tasks.c **** 
 204:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 205:../../freeRtos/Source/tasks.c **** 
 206:../../freeRtos/Source/tasks.c **** /*
 207:../../freeRtos/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 208:../../freeRtos/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 209:../../freeRtos/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 210:../../freeRtos/Source/tasks.c ****  * it if not using the facility.
 211:../../freeRtos/Source/tasks.c ****  */
 212:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 213:../../freeRtos/Source/tasks.c **** 
 214:../../freeRtos/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 215:../../freeRtos/Source/tasks.c **** 	{																								\
 216:../../freeRtos/Source/tasks.c **** 		if( xTracing )																				\
 217:../../freeRtos/Source/tasks.c **** 		{																							\
 218:../../freeRtos/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 219:../../freeRtos/Source/tasks.c **** 			{																						\
 220:../../freeRtos/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 221:../../freeRtos/Source/tasks.c **** 				{																					\
 222:../../freeRtos/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 223:../../freeRtos/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;		\
 224:../../freeRtos/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 225:../../freeRtos/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;	\
 226:../../freeRtos/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 227:../../freeRtos/Source/tasks.c **** 				}																					\
 228:../../freeRtos/Source/tasks.c **** 				else																				\
 229:../../freeRtos/Source/tasks.c **** 				{																					\
 230:../../freeRtos/Source/tasks.c **** 					xTracing = pdFALSE;																\
 231:../../freeRtos/Source/tasks.c **** 				}																					\
 232:../../freeRtos/Source/tasks.c **** 			}																						\
 233:../../freeRtos/Source/tasks.c **** 		}																							\
 234:../../freeRtos/Source/tasks.c **** 	}
 235:../../freeRtos/Source/tasks.c **** 
 236:../../freeRtos/Source/tasks.c **** #else
 237:../../freeRtos/Source/tasks.c **** 
 238:../../freeRtos/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 239:../../freeRtos/Source/tasks.c **** 
 240:../../freeRtos/Source/tasks.c **** #endif
 241:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 242:../../freeRtos/Source/tasks.c **** 
 243:../../freeRtos/Source/tasks.c **** /*
 244:../../freeRtos/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 245:../../freeRtos/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 246:../../freeRtos/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 247:../../freeRtos/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 248:../../freeRtos/Source/tasks.c ****  * executing task has been rescheduled.
 249:../../freeRtos/Source/tasks.c ****  */
 250:../../freeRtos/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																			\
 251:../../freeRtos/Source/tasks.c **** {																												\
 252:../../freeRtos/Source/tasks.c **** 	if( pxTCB->uxPriority > uxTopReadyPriority )																\
 253:../../freeRtos/Source/tasks.c **** 	{																											\
 254:../../freeRtos/Source/tasks.c **** 		uxTopReadyPriority = pxTCB->uxPriority;																	\
 255:../../freeRtos/Source/tasks.c **** 	}																											\
 256:../../freeRtos/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListIte
 257:../../freeRtos/Source/tasks.c **** }
 258:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 259:../../freeRtos/Source/tasks.c **** 
 260:../../freeRtos/Source/tasks.c **** /*
 261:../../freeRtos/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 262:../../freeRtos/Source/tasks.c ****  * any require waking.
 263:../../freeRtos/Source/tasks.c ****  *
 264:../../freeRtos/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 265:../../freeRtos/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 266:../../freeRtos/Source/tasks.c ****  * any further down the list.
 267:../../freeRtos/Source/tasks.c ****  */
 268:../../freeRtos/Source/tasks.c **** #define prvCheckDelayedTasks()																						\
 269:../../freeRtos/Source/tasks.c **** {																													\
 270:../../freeRtos/Source/tasks.c **** register tskTCB *pxTCB;																								\
 271:../../freeRtos/Source/tasks.c **** 																													\
 272:../../freeRtos/Source/tasks.c **** 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
 273:../../freeRtos/Source/tasks.c **** 	{																												\
 274:../../freeRtos/Source/tasks.c **** 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
 275:../../freeRtos/Source/tasks.c **** 		{																											\
 276:../../freeRtos/Source/tasks.c **** 			break;																									\
 277:../../freeRtos/Source/tasks.c **** 		}																											\
 278:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxTCB->xGenericListItem ) );																\
 279:../../freeRtos/Source/tasks.c **** 		/* Is the task waiting on an event also? */																	\
 280:../../freeRtos/Source/tasks.c **** 		if( pxTCB->xEventListItem.pvContainer )																		\
 281:../../freeRtos/Source/tasks.c **** 		{																											\
 282:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xEventListItem ) );																\
 283:../../freeRtos/Source/tasks.c **** 		}																											\
 284:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxTCB );																			\
 285:../../freeRtos/Source/tasks.c **** 	}																												\
 286:../../freeRtos/Source/tasks.c **** }
 287:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 288:../../freeRtos/Source/tasks.c **** 
 289:../../freeRtos/Source/tasks.c **** /*
 290:../../freeRtos/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 291:../../freeRtos/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 292:../../freeRtos/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 293:../../freeRtos/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 294:../../freeRtos/Source/tasks.c ****  */
 295:../../freeRtos/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskT
 296:../../freeRtos/Source/tasks.c **** 
 297:../../freeRtos/Source/tasks.c **** 
 298:../../freeRtos/Source/tasks.c **** /* File private functions. --------------------------------*/
 299:../../freeRtos/Source/tasks.c **** 
 300:../../freeRtos/Source/tasks.c **** /*
 301:../../freeRtos/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 302:../../freeRtos/Source/tasks.c ****  * into the TCB structure.
 303:../../freeRtos/Source/tasks.c ****  */
 304:../../freeRtos/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 305:../../freeRtos/Source/tasks.c **** 
 306:../../freeRtos/Source/tasks.c **** /*
 307:../../freeRtos/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 308:../../freeRtos/Source/tasks.c ****  * automatically upon the creation of the first task.
 309:../../freeRtos/Source/tasks.c ****  */
 310:../../freeRtos/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 311:../../freeRtos/Source/tasks.c **** 
 312:../../freeRtos/Source/tasks.c **** /*
 313:../../freeRtos/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 314:../../freeRtos/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 315:../../freeRtos/Source/tasks.c ****  * creation of the first user task.
 316:../../freeRtos/Source/tasks.c ****  *
 317:../../freeRtos/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 318:../../freeRtos/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 319:../../freeRtos/Source/tasks.c ****  *
 320:../../freeRtos/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 321:../../freeRtos/Source/tasks.c ****  *
 322:../../freeRtos/Source/tasks.c ****  */
 323:../../freeRtos/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 324:../../freeRtos/Source/tasks.c **** 
 325:../../freeRtos/Source/tasks.c **** /*
 326:../../freeRtos/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 327:../../freeRtos/Source/tasks.c ****  * including the stack pointed to by the TCB.
 328:../../freeRtos/Source/tasks.c ****  *
 329:../../freeRtos/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 330:../../freeRtos/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 331:../../freeRtos/Source/tasks.c ****  */
 332:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
 333:../../freeRtos/Source/tasks.c **** 
 334:../../freeRtos/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 335:../../freeRtos/Source/tasks.c **** 
 336:../../freeRtos/Source/tasks.c **** #endif
 337:../../freeRtos/Source/tasks.c **** 
 338:../../freeRtos/Source/tasks.c **** /*
 339:../../freeRtos/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 340:../../freeRtos/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 341:../../freeRtos/Source/tasks.c ****  * and its TCB deleted.
 342:../../freeRtos/Source/tasks.c ****  */
 343:../../freeRtos/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 344:../../freeRtos/Source/tasks.c **** 
 345:../../freeRtos/Source/tasks.c **** /*
 346:../../freeRtos/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 347:../../freeRtos/Source/tasks.c ****  * allocation was successful.
 348:../../freeRtos/Source/tasks.c ****  */
 349:../../freeRtos/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 350:../../freeRtos/Source/tasks.c **** 
 351:../../freeRtos/Source/tasks.c **** /*
 352:../../freeRtos/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 353:../../freeRtos/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 354:../../freeRtos/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 355:../../freeRtos/Source/tasks.c ****  * within just that list.
 356:../../freeRtos/Source/tasks.c ****  *
 357:../../freeRtos/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 358:../../freeRtos/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 359:../../freeRtos/Source/tasks.c ****  */
 360:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 361:../../freeRtos/Source/tasks.c **** 
 362:../../freeRtos/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 363:../../freeRtos/Source/tasks.c **** 
 364:../../freeRtos/Source/tasks.c **** #endif
 365:../../freeRtos/Source/tasks.c **** 
 366:../../freeRtos/Source/tasks.c **** /*
 367:../../freeRtos/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 368:../../freeRtos/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 369:../../freeRtos/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 370:../../freeRtos/Source/tasks.c ****  */
 371:../../freeRtos/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 372:../../freeRtos/Source/tasks.c **** 
 373:../../freeRtos/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 374:../../freeRtos/Source/tasks.c **** 
 375:../../freeRtos/Source/tasks.c **** #endif
 376:../../freeRtos/Source/tasks.c **** 
 377:../../freeRtos/Source/tasks.c **** 
 378:../../freeRtos/Source/tasks.c **** /*lint +e956 */
 379:../../freeRtos/Source/tasks.c **** 
 380:../../freeRtos/Source/tasks.c **** 
 381:../../freeRtos/Source/tasks.c **** 
 382:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
 383:../../freeRtos/Source/tasks.c ****  * TASK CREATION API documented in task.h
 384:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
 385:../../freeRtos/Source/tasks.c **** 
 386:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 387:../../freeRtos/Source/tasks.c **** {
 388:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xReturn;
 389:../../freeRtos/Source/tasks.c **** tskTCB * pxNewTCB;
 390:../../freeRtos/Source/tasks.c **** 
 391:../../freeRtos/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 392:../../freeRtos/Source/tasks.c **** 	checking that the allocation was successful. */
 393:../../freeRtos/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 394:../../freeRtos/Source/tasks.c **** 
 395:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
 396:../../freeRtos/Source/tasks.c **** 	{
 397:../../freeRtos/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 398:../../freeRtos/Source/tasks.c **** 
 399:../../freeRtos/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 400:../../freeRtos/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 401:../../freeRtos/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 402:../../freeRtos/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
 403:../../freeRtos/Source/tasks.c **** 			{
 404:../../freeRtos/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 405:../../freeRtos/Source/tasks.c **** 			}
 406:../../freeRtos/Source/tasks.c **** 			else
 407:../../freeRtos/Source/tasks.c **** 			{
 408:../../freeRtos/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 409:../../freeRtos/Source/tasks.c **** 			}
 410:../../freeRtos/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 411:../../freeRtos/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 412:../../freeRtos/Source/tasks.c **** 
 413:../../freeRtos/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 414:../../freeRtos/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 415:../../freeRtos/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 416:../../freeRtos/Source/tasks.c **** 		required by the port. */
 417:../../freeRtos/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 418:../../freeRtos/Source/tasks.c **** 		{
 419:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 420:../../freeRtos/Source/tasks.c **** //			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long )
 421:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( uint16_t ) pxTopOfStack ) & ( ( uint16_t ) ~portBYTE_A
 422:../../freeRtos/Source/tasks.c **** 		}
 423:../../freeRtos/Source/tasks.c **** 		#else
 424:../../freeRtos/Source/tasks.c **** 		{
 425:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 426:../../freeRtos/Source/tasks.c **** 
 427:../../freeRtos/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 428:../../freeRtos/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 429:../../freeRtos/Source/tasks.c **** 			other extreme of the stack space. */
 430:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 431:../../freeRtos/Source/tasks.c **** 		}
 432:../../freeRtos/Source/tasks.c **** 		#endif
 433:../../freeRtos/Source/tasks.c **** 
 434:../../freeRtos/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 435:../../freeRtos/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 436:../../freeRtos/Source/tasks.c **** 
 437:../../freeRtos/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 438:../../freeRtos/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 439:../../freeRtos/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 440:../../freeRtos/Source/tasks.c **** 		the	top of stack variable is updated. */
 441:../../freeRtos/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 442:../../freeRtos/Source/tasks.c **** 		{
 443:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 444:../../freeRtos/Source/tasks.c **** 		}
 445:../../freeRtos/Source/tasks.c **** 		#else
 446:../../freeRtos/Source/tasks.c **** 		{
 447:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 448:../../freeRtos/Source/tasks.c **** 		}
 449:../../freeRtos/Source/tasks.c **** 		#endif
 450:../../freeRtos/Source/tasks.c **** 
 451:../../freeRtos/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 452:../../freeRtos/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 453:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 454:../../freeRtos/Source/tasks.c **** 		{
 455:../../freeRtos/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 456:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 457:../../freeRtos/Source/tasks.c **** 			{
 458:../../freeRtos/Source/tasks.c **** 				/* As this is the first task it must also be the current task. */
 459:../../freeRtos/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 460:../../freeRtos/Source/tasks.c **** 
 461:../../freeRtos/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
 462:../../freeRtos/Source/tasks.c **** 				initialisation required.  We will not recover if this call
 463:../../freeRtos/Source/tasks.c **** 				fails, but we will report the failure. */
 464:../../freeRtos/Source/tasks.c **** 				prvInitialiseTaskLists();
 465:../../freeRtos/Source/tasks.c **** 			}
 466:../../freeRtos/Source/tasks.c **** 			else
 467:../../freeRtos/Source/tasks.c **** 			{
 468:../../freeRtos/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 469:../../freeRtos/Source/tasks.c **** 				current task if it is the highest priority task to be created
 470:../../freeRtos/Source/tasks.c **** 				so far. */
 471:../../freeRtos/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 472:../../freeRtos/Source/tasks.c **** 				{
 473:../../freeRtos/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 474:../../freeRtos/Source/tasks.c **** 					{
 475:../../freeRtos/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 476:../../freeRtos/Source/tasks.c **** 					}
 477:../../freeRtos/Source/tasks.c **** 				}
 478:../../freeRtos/Source/tasks.c **** 			}
 479:../../freeRtos/Source/tasks.c **** 
 480:../../freeRtos/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 481:../../freeRtos/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 482:../../freeRtos/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 483:../../freeRtos/Source/tasks.c **** 			{
 484:../../freeRtos/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 485:../../freeRtos/Source/tasks.c **** 			}
 486:../../freeRtos/Source/tasks.c **** 
 487:../../freeRtos/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 488:../../freeRtos/Source/tasks.c **** 			{
 489:../../freeRtos/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 490:../../freeRtos/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 491:../../freeRtos/Source/tasks.c **** 			}
 492:../../freeRtos/Source/tasks.c **** 			#endif
 493:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 494:../../freeRtos/Source/tasks.c **** 
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 496:../../freeRtos/Source/tasks.c **** 
 497:../../freeRtos/Source/tasks.c **** 			xReturn = pdPASS;
 498:../../freeRtos/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 499:../../freeRtos/Source/tasks.c **** 		}
 500:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 501:../../freeRtos/Source/tasks.c **** 	}
 502:../../freeRtos/Source/tasks.c **** 	else
 503:../../freeRtos/Source/tasks.c **** 	{
 504:../../freeRtos/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 505:../../freeRtos/Source/tasks.c **** 		traceTASK_CREATE_FAILED( pxNewTCB );
 506:../../freeRtos/Source/tasks.c **** 	}
 507:../../freeRtos/Source/tasks.c **** 
 508:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
 509:../../freeRtos/Source/tasks.c **** 	{
 510:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 511:../../freeRtos/Source/tasks.c **** 		{
 512:../../freeRtos/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 513:../../freeRtos/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 514:../../freeRtos/Source/tasks.c **** 			required.*/
 515:../../freeRtos/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 516:../../freeRtos/Source/tasks.c **** 		}
 517:../../freeRtos/Source/tasks.c **** 
 518:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 519:../../freeRtos/Source/tasks.c **** 		{
 520:../../freeRtos/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 521:../../freeRtos/Source/tasks.c **** 			then it should run now. */
 522:../../freeRtos/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 523:../../freeRtos/Source/tasks.c **** 			{
 524:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 525:../../freeRtos/Source/tasks.c **** 			}
 526:../../freeRtos/Source/tasks.c **** 		}
 527:../../freeRtos/Source/tasks.c **** 	}
 528:../../freeRtos/Source/tasks.c **** 
 529:../../freeRtos/Source/tasks.c **** 	return xReturn;
 530:../../freeRtos/Source/tasks.c **** }
 531:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 532:../../freeRtos/Source/tasks.c **** 
 533:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 534:../../freeRtos/Source/tasks.c **** 
 535:../../freeRtos/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 536:../../freeRtos/Source/tasks.c **** 	{
 537:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 538:../../freeRtos/Source/tasks.c **** 
 539:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 540:../../freeRtos/Source/tasks.c **** 		{
 541:../../freeRtos/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 542:../../freeRtos/Source/tasks.c **** 			deleted. */
 543:../../freeRtos/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 544:../../freeRtos/Source/tasks.c **** 			{
 545:../../freeRtos/Source/tasks.c **** 				pxTaskToDelete = NULL;
 546:../../freeRtos/Source/tasks.c **** 			}
 547:../../freeRtos/Source/tasks.c **** 
 548:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 549:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 550:../../freeRtos/Source/tasks.c **** 
 551:../../freeRtos/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 552:../../freeRtos/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 553:../../freeRtos/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 554:../../freeRtos/Source/tasks.c **** 			scheduler for the TCB and stack. */
 555:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 556:../../freeRtos/Source/tasks.c **** 
 557:../../freeRtos/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 558:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 559:../../freeRtos/Source/tasks.c **** 			{
 560:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 561:../../freeRtos/Source/tasks.c **** 			}
 562:../../freeRtos/Source/tasks.c **** 
 563:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 564:../../freeRtos/Source/tasks.c **** 
 565:../../freeRtos/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 566:../../freeRtos/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 567:../../freeRtos/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 568:../../freeRtos/Source/tasks.c **** 			++uxTasksDeleted;
 569:../../freeRtos/Source/tasks.c **** 
 570:../../freeRtos/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 571:../../freeRtos/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 572:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 573:../../freeRtos/Source/tasks.c **** 
 574:../../freeRtos/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 575:../../freeRtos/Source/tasks.c **** 		}
 576:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 577:../../freeRtos/Source/tasks.c **** 
 578:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 579:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 580:../../freeRtos/Source/tasks.c **** 		{
 581:../../freeRtos/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 582:../../freeRtos/Source/tasks.c **** 			{
 583:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 584:../../freeRtos/Source/tasks.c **** 			}
 585:../../freeRtos/Source/tasks.c **** 		}
 586:../../freeRtos/Source/tasks.c **** 	}
 587:../../freeRtos/Source/tasks.c **** 
 588:../../freeRtos/Source/tasks.c **** #endif
 589:../../freeRtos/Source/tasks.c **** 
 590:../../freeRtos/Source/tasks.c **** 
 591:../../freeRtos/Source/tasks.c **** 
 592:../../freeRtos/Source/tasks.c **** 
 593:../../freeRtos/Source/tasks.c **** 
 594:../../freeRtos/Source/tasks.c **** 
 595:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
 596:../../freeRtos/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 597:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
 598:../../freeRtos/Source/tasks.c **** 
 599:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 600:../../freeRtos/Source/tasks.c **** 
 601:../../freeRtos/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 602:../../freeRtos/Source/tasks.c **** 	{
 603:../../freeRtos/Source/tasks.c **** 	portTickType xTimeToWake;
 604:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 605:../../freeRtos/Source/tasks.c **** 
 606:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 607:../../freeRtos/Source/tasks.c **** 		{
 608:../../freeRtos/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 609:../../freeRtos/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 610:../../freeRtos/Source/tasks.c **** 
 611:../../freeRtos/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 612:../../freeRtos/Source/tasks.c **** 			{
 613:../../freeRtos/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 614:../../freeRtos/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 615:../../freeRtos/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 616:../../freeRtos/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 617:../../freeRtos/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 618:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 619:../../freeRtos/Source/tasks.c **** 				{
 620:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 621:../../freeRtos/Source/tasks.c **** 				}
 622:../../freeRtos/Source/tasks.c **** 			}
 623:../../freeRtos/Source/tasks.c **** 			else
 624:../../freeRtos/Source/tasks.c **** 			{
 625:../../freeRtos/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 626:../../freeRtos/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 627:../../freeRtos/Source/tasks.c **** 				tick time is less than the wake time. */
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 629:../../freeRtos/Source/tasks.c **** 				{
 630:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 631:../../freeRtos/Source/tasks.c **** 				}
 632:../../freeRtos/Source/tasks.c **** 			}
 633:../../freeRtos/Source/tasks.c **** 
 634:../../freeRtos/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 635:../../freeRtos/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 636:../../freeRtos/Source/tasks.c **** 
 637:../../freeRtos/Source/tasks.c **** 			if( xShouldDelay )
 638:../../freeRtos/Source/tasks.c **** 			{
 639:../../freeRtos/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 640:../../freeRtos/Source/tasks.c **** 
 641:../../freeRtos/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 642:../../freeRtos/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 643:../../freeRtos/Source/tasks.c **** 				both lists. */
 644:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 645:../../freeRtos/Source/tasks.c **** 
 646:../../freeRtos/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 647:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 648:../../freeRtos/Source/tasks.c **** 
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 650:../../freeRtos/Source/tasks.c **** 				{
 651:../../freeRtos/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 652:../../freeRtos/Source/tasks.c **** 					overflow list. */
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 654:../../freeRtos/Source/tasks.c **** 				}
 655:../../freeRtos/Source/tasks.c **** 				else
 656:../../freeRtos/Source/tasks.c **** 				{
 657:../../freeRtos/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 658:../../freeRtos/Source/tasks.c **** 					current block list. */
 659:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 660:../../freeRtos/Source/tasks.c **** 				}
 661:../../freeRtos/Source/tasks.c **** 			}
 662:../../freeRtos/Source/tasks.c **** 		}
 663:../../freeRtos/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 664:../../freeRtos/Source/tasks.c **** 
 665:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 666:../../freeRtos/Source/tasks.c **** 		have put ourselves to sleep. */
 667:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 668:../../freeRtos/Source/tasks.c **** 		{
 669:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 670:../../freeRtos/Source/tasks.c **** 		}
 671:../../freeRtos/Source/tasks.c **** 	}
 672:../../freeRtos/Source/tasks.c **** 
 673:../../freeRtos/Source/tasks.c **** #endif
 674:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 675:../../freeRtos/Source/tasks.c **** 
 676:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 677:../../freeRtos/Source/tasks.c **** 
 678:../../freeRtos/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 679:../../freeRtos/Source/tasks.c **** 	{
 680:../../freeRtos/Source/tasks.c **** 	portTickType xTimeToWake;
 681:../../freeRtos/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 682:../../freeRtos/Source/tasks.c **** 
 683:../../freeRtos/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 684:../../freeRtos/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 685:../../freeRtos/Source/tasks.c **** 		{
 686:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
 687:../../freeRtos/Source/tasks.c **** 			{
 688:../../freeRtos/Source/tasks.c **** 				traceTASK_DELAY();
 689:../../freeRtos/Source/tasks.c **** 
 690:../../freeRtos/Source/tasks.c **** 				/* A task that is removed from the event list while the
 691:../../freeRtos/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 692:../../freeRtos/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 693:../../freeRtos/Source/tasks.c **** 				is resumed.
 694:../../freeRtos/Source/tasks.c **** 
 695:../../freeRtos/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 696:../../freeRtos/Source/tasks.c **** 				executing task. */
 697:../../freeRtos/Source/tasks.c **** 
 698:../../freeRtos/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 699:../../freeRtos/Source/tasks.c **** 				not a problem. */
 700:../../freeRtos/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 701:../../freeRtos/Source/tasks.c **** 
 702:../../freeRtos/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 703:../../freeRtos/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 704:../../freeRtos/Source/tasks.c **** 				both lists. */
 705:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 706:../../freeRtos/Source/tasks.c **** 
 707:../../freeRtos/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 708:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 709:../../freeRtos/Source/tasks.c **** 
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 711:../../freeRtos/Source/tasks.c **** 				{
 712:../../freeRtos/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 713:../../freeRtos/Source/tasks.c **** 					overflow list. */
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 715:../../freeRtos/Source/tasks.c **** 				}
 716:../../freeRtos/Source/tasks.c **** 				else
 717:../../freeRtos/Source/tasks.c **** 				{
 718:../../freeRtos/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 719:../../freeRtos/Source/tasks.c **** 					current block list. */
 720:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 721:../../freeRtos/Source/tasks.c **** 				}
 722:../../freeRtos/Source/tasks.c **** 			}
 723:../../freeRtos/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 724:../../freeRtos/Source/tasks.c **** 		}
 725:../../freeRtos/Source/tasks.c **** 
 726:../../freeRtos/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 727:../../freeRtos/Source/tasks.c **** 		have put ourselves to sleep. */
 728:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 729:../../freeRtos/Source/tasks.c **** 		{
 730:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 731:../../freeRtos/Source/tasks.c **** 		}
 732:../../freeRtos/Source/tasks.c **** 	}
 733:../../freeRtos/Source/tasks.c **** 
 734:../../freeRtos/Source/tasks.c **** #endif
 735:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 736:../../freeRtos/Source/tasks.c **** 
 737:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 738:../../freeRtos/Source/tasks.c **** 
 739:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 740:../../freeRtos/Source/tasks.c **** 	{
 741:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 742:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 743:../../freeRtos/Source/tasks.c **** 
 744:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 745:../../freeRtos/Source/tasks.c **** 		{
 746:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 747:../../freeRtos/Source/tasks.c **** 			priority of the calling function. */
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 749:../../freeRtos/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 750:../../freeRtos/Source/tasks.c **** 		}
 751:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 752:../../freeRtos/Source/tasks.c **** 
 753:../../freeRtos/Source/tasks.c **** 		return uxReturn;
 754:../../freeRtos/Source/tasks.c **** 	}
 755:../../freeRtos/Source/tasks.c **** 
 756:../../freeRtos/Source/tasks.c **** #endif
 757:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 758:../../freeRtos/Source/tasks.c **** 
 759:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 760:../../freeRtos/Source/tasks.c **** 
 761:../../freeRtos/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 762:../../freeRtos/Source/tasks.c **** 	{
 763:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 764:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
 765:../../freeRtos/Source/tasks.c **** 
 766:../../freeRtos/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 767:../../freeRtos/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 768:../../freeRtos/Source/tasks.c **** 		{
 769:../../freeRtos/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - 1;
 770:../../freeRtos/Source/tasks.c **** 		}
 771:../../freeRtos/Source/tasks.c **** 
 772:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 773:../../freeRtos/Source/tasks.c **** 		{
 774:../../freeRtos/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 775:../../freeRtos/Source/tasks.c **** 			{
 776:../../freeRtos/Source/tasks.c **** 				pxTask = NULL;
 777:../../freeRtos/Source/tasks.c **** 			}
 778:../../freeRtos/Source/tasks.c **** 
 779:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 780:../../freeRtos/Source/tasks.c **** 			priority of the calling function. */
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 782:../../freeRtos/Source/tasks.c **** 
 783:../../freeRtos/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 784:../../freeRtos/Source/tasks.c **** 
 785:../../freeRtos/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 786:../../freeRtos/Source/tasks.c **** 			{
 787:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 788:../../freeRtos/Source/tasks.c **** 			}
 789:../../freeRtos/Source/tasks.c **** 			#else
 790:../../freeRtos/Source/tasks.c **** 			{
 791:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 792:../../freeRtos/Source/tasks.c **** 			}
 793:../../freeRtos/Source/tasks.c **** 			#endif
 794:../../freeRtos/Source/tasks.c **** 
 795:../../freeRtos/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 796:../../freeRtos/Source/tasks.c **** 			{
 797:../../freeRtos/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 798:../../freeRtos/Source/tasks.c **** 				priority than the calling task. */
 799:../../freeRtos/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 800:../../freeRtos/Source/tasks.c **** 				{
 801:../../freeRtos/Source/tasks.c **** 					if( pxTask != NULL )
 802:../../freeRtos/Source/tasks.c **** 					{
 803:../../freeRtos/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 804:../../freeRtos/Source/tasks.c **** 						were raising the priority of the currently running task
 805:../../freeRtos/Source/tasks.c **** 						there would be no need to switch as it must have already
 806:../../freeRtos/Source/tasks.c **** 						been the highest priority task. */
 807:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 808:../../freeRtos/Source/tasks.c **** 					}
 809:../../freeRtos/Source/tasks.c **** 				}
 810:../../freeRtos/Source/tasks.c **** 				else if( pxTask == NULL )
 811:../../freeRtos/Source/tasks.c **** 				{
 812:../../freeRtos/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 813:../../freeRtos/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 814:../../freeRtos/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 815:../../freeRtos/Source/tasks.c **** 				}
 816:../../freeRtos/Source/tasks.c **** 
 817:../../freeRtos/Source/tasks.c **** 
 818:../../freeRtos/Source/tasks.c **** 
 819:../../freeRtos/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 820:../../freeRtos/Source/tasks.c **** 				{
 821:../../freeRtos/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 822:../../freeRtos/Source/tasks.c **** 					currently using an inherited priority. */
 823:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 824:../../freeRtos/Source/tasks.c **** 					{
 825:../../freeRtos/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 826:../../freeRtos/Source/tasks.c **** 					}
 827:../../freeRtos/Source/tasks.c **** 
 828:../../freeRtos/Source/tasks.c **** 					/* The base priority gets set whatever. */
 829:../../freeRtos/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 830:../../freeRtos/Source/tasks.c **** 				}
 831:../../freeRtos/Source/tasks.c **** 				#else
 832:../../freeRtos/Source/tasks.c **** 				{
 833:../../freeRtos/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 834:../../freeRtos/Source/tasks.c **** 				}
 835:../../freeRtos/Source/tasks.c **** 				#endif
 836:../../freeRtos/Source/tasks.c **** 
 837:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 838:../../freeRtos/Source/tasks.c **** 
 839:../../freeRtos/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 840:../../freeRtos/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 841:../../freeRtos/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 842:../../freeRtos/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 843:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 844:../../freeRtos/Source/tasks.c **** 				{
 845:../../freeRtos/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 846:../../freeRtos/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 847:../../freeRtos/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 848:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 850:../../freeRtos/Source/tasks.c **** 				}
 851:../../freeRtos/Source/tasks.c **** 
 852:../../freeRtos/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 853:../../freeRtos/Source/tasks.c **** 				{
 854:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 855:../../freeRtos/Source/tasks.c **** 				}
 856:../../freeRtos/Source/tasks.c **** 			}
 857:../../freeRtos/Source/tasks.c **** 		}
 858:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 859:../../freeRtos/Source/tasks.c **** 	}
 860:../../freeRtos/Source/tasks.c **** 
 861:../../freeRtos/Source/tasks.c **** #endif
 862:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 863:../../freeRtos/Source/tasks.c **** 
 864:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 865:../../freeRtos/Source/tasks.c **** 
 866:../../freeRtos/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 867:../../freeRtos/Source/tasks.c **** 	{
 868:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 869:../../freeRtos/Source/tasks.c **** 
 870:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 871:../../freeRtos/Source/tasks.c **** 		{
 872:../../freeRtos/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 873:../../freeRtos/Source/tasks.c **** 			suspended. */
 874:../../freeRtos/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 875:../../freeRtos/Source/tasks.c **** 			{
 876:../../freeRtos/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 877:../../freeRtos/Source/tasks.c **** 			}
 878:../../freeRtos/Source/tasks.c **** 
 879:../../freeRtos/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 881:../../freeRtos/Source/tasks.c **** 
 882:../../freeRtos/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 883:../../freeRtos/Source/tasks.c **** 
 884:../../freeRtos/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 885:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 886:../../freeRtos/Source/tasks.c **** 
 887:../../freeRtos/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 888:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 889:../../freeRtos/Source/tasks.c **** 			{
 890:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 891:../../freeRtos/Source/tasks.c **** 			}
 892:../../freeRtos/Source/tasks.c **** 
 893:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 894:../../freeRtos/Source/tasks.c **** 		}
 895:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 896:../../freeRtos/Source/tasks.c **** 
 897:../../freeRtos/Source/tasks.c **** 		/* We may have just suspended the current task. */
 898:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 899:../../freeRtos/Source/tasks.c **** 		{
 900:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 901:../../freeRtos/Source/tasks.c **** 		}
 902:../../freeRtos/Source/tasks.c **** 	}
 903:../../freeRtos/Source/tasks.c **** 
 904:../../freeRtos/Source/tasks.c **** #endif
 905:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 906:../../freeRtos/Source/tasks.c **** 
 907:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 908:../../freeRtos/Source/tasks.c **** 
 909:../../freeRtos/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 910:../../freeRtos/Source/tasks.c **** 	{
 911:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 912:../../freeRtos/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 913:../../freeRtos/Source/tasks.c **** 
 914:../../freeRtos/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 915:../../freeRtos/Source/tasks.c **** 		suspended list? */
 916:../../freeRtos/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 917:../../freeRtos/Source/tasks.c **** 		{
 918:../../freeRtos/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 919:../../freeRtos/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 920:../../freeRtos/Source/tasks.c **** 			{
 921:../../freeRtos/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 922:../../freeRtos/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 923:../../freeRtos/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 924:../../freeRtos/Source/tasks.c **** 				specified. */
 925:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 926:../../freeRtos/Source/tasks.c **** 				{
 927:../../freeRtos/Source/tasks.c **** 					xReturn = pdTRUE;
 928:../../freeRtos/Source/tasks.c **** 				}
 929:../../freeRtos/Source/tasks.c **** 			}
 930:../../freeRtos/Source/tasks.c **** 		}
 931:../../freeRtos/Source/tasks.c **** 
 932:../../freeRtos/Source/tasks.c **** 		return xReturn;
 933:../../freeRtos/Source/tasks.c **** 	}
 934:../../freeRtos/Source/tasks.c **** 
 935:../../freeRtos/Source/tasks.c **** #endif
 936:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 937:../../freeRtos/Source/tasks.c **** 
 938:../../freeRtos/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 939:../../freeRtos/Source/tasks.c **** 
 940:../../freeRtos/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 941:../../freeRtos/Source/tasks.c **** 	{
 942:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 943:../../freeRtos/Source/tasks.c **** 
 944:../../freeRtos/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 945:../../freeRtos/Source/tasks.c **** 		it in the ready list. */
 946:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 947:../../freeRtos/Source/tasks.c **** 
 948:../../freeRtos/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 949:../../freeRtos/Source/tasks.c **** 		currently executing task. */
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 951:../../freeRtos/Source/tasks.c **** 		{
 952:../../freeRtos/Source/tasks.c **** 			portENTER_CRITICAL();
 953:../../freeRtos/Source/tasks.c **** 			{
 954:../../freeRtos/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 955:../../freeRtos/Source/tasks.c **** 				{
 956:../../freeRtos/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
 957:../../freeRtos/Source/tasks.c **** 
 958:../../freeRtos/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
 959:../../freeRtos/Source/tasks.c **** 					lists even if the scheduler is suspended. */
 960:../../freeRtos/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 962:../../freeRtos/Source/tasks.c **** 
 963:../../freeRtos/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
 964:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 965:../../freeRtos/Source/tasks.c **** 					{
 966:../../freeRtos/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 967:../../freeRtos/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 968:../../freeRtos/Source/tasks.c **** 						portYIELD_WITHIN_API();
 969:../../freeRtos/Source/tasks.c **** 					}
 970:../../freeRtos/Source/tasks.c **** 				}
 971:../../freeRtos/Source/tasks.c **** 			}
 972:../../freeRtos/Source/tasks.c **** 			portEXIT_CRITICAL();
 973:../../freeRtos/Source/tasks.c **** 		}
 974:../../freeRtos/Source/tasks.c **** 	}
 975:../../freeRtos/Source/tasks.c **** 
 976:../../freeRtos/Source/tasks.c **** #endif
 977:../../freeRtos/Source/tasks.c **** 
 978:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
 979:../../freeRtos/Source/tasks.c **** 
 980:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 981:../../freeRtos/Source/tasks.c **** 
 982:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 983:../../freeRtos/Source/tasks.c **** 	{
 984:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 985:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
 986:../../freeRtos/Source/tasks.c **** 
 987:../../freeRtos/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 988:../../freeRtos/Source/tasks.c **** 
 989:../../freeRtos/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 990:../../freeRtos/Source/tasks.c **** 		{
 991:../../freeRtos/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
 992:../../freeRtos/Source/tasks.c **** 
 993:../../freeRtos/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 994:../../freeRtos/Source/tasks.c **** 			{
 995:../../freeRtos/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 996:../../freeRtos/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 998:../../freeRtos/Source/tasks.c **** 			}
 999:../../freeRtos/Source/tasks.c **** 			else
1000:../../freeRtos/Source/tasks.c **** 			{
1001:../../freeRtos/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1002:../../freeRtos/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1003:../../freeRtos/Source/tasks.c **** 				yield will be performed if necessary. */
1004:../../freeRtos/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1005:../../freeRtos/Source/tasks.c **** 			}
1006:../../freeRtos/Source/tasks.c **** 		}
1007:../../freeRtos/Source/tasks.c **** 
1008:../../freeRtos/Source/tasks.c **** 		return xYieldRequired;
1009:../../freeRtos/Source/tasks.c **** 	}
1010:../../freeRtos/Source/tasks.c **** 
1011:../../freeRtos/Source/tasks.c **** #endif
1012:../../freeRtos/Source/tasks.c **** 
1013:../../freeRtos/Source/tasks.c **** 
1014:../../freeRtos/Source/tasks.c **** 
1015:../../freeRtos/Source/tasks.c **** 
1016:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1017:../../freeRtos/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1018:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1019:../../freeRtos/Source/tasks.c **** 
1020:../../freeRtos/Source/tasks.c **** 
1021:../../freeRtos/Source/tasks.c **** void vTaskStartScheduler( void )
1022:../../freeRtos/Source/tasks.c **** {
1023:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1024:../../freeRtos/Source/tasks.c **** 
1025:../../freeRtos/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1026:../../freeRtos/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
1027:../../freeRtos/Source/tasks.c **** 
1028:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
1029:../../freeRtos/Source/tasks.c **** 	{
1030:../../freeRtos/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1031:../../freeRtos/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1032:../../freeRtos/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1033:../../freeRtos/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1034:../../freeRtos/Source/tasks.c **** 		starts to run.
1035:../../freeRtos/Source/tasks.c **** 
1036:../../freeRtos/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1037:../../freeRtos/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1038:../../freeRtos/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1039:../../freeRtos/Source/tasks.c **** 
1040:../../freeRtos/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1041:../../freeRtos/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
1042:../../freeRtos/Source/tasks.c **** 
1043:../../freeRtos/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1044:../../freeRtos/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1045:../../freeRtos/Source/tasks.c **** 		the run time counter time base. */
1046:../../freeRtos/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1047:../../freeRtos/Source/tasks.c **** 
1048:../../freeRtos/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1049:../../freeRtos/Source/tasks.c **** 		portable interface. */
1050:../../freeRtos/Source/tasks.c **** 		if( xPortStartScheduler() )
1051:../../freeRtos/Source/tasks.c **** 		{
1052:../../freeRtos/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1053:../../freeRtos/Source/tasks.c **** 			function will not return. */
1054:../../freeRtos/Source/tasks.c **** 		}
1055:../../freeRtos/Source/tasks.c **** 		else
1056:../../freeRtos/Source/tasks.c **** 		{
1057:../../freeRtos/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1058:../../freeRtos/Source/tasks.c **** 		}
1059:../../freeRtos/Source/tasks.c **** 	}
1060:../../freeRtos/Source/tasks.c **** }
1061:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1062:../../freeRtos/Source/tasks.c **** 
1063:../../freeRtos/Source/tasks.c **** void vTaskEndScheduler( void )
1064:../../freeRtos/Source/tasks.c **** {
1065:../../freeRtos/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1066:../../freeRtos/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1067:../../freeRtos/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1068:../../freeRtos/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1069:../../freeRtos/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1070:../../freeRtos/Source/tasks.c **** 	vPortEndScheduler();
1071:../../freeRtos/Source/tasks.c **** }
1072:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1073:../../freeRtos/Source/tasks.c **** 
1074:../../freeRtos/Source/tasks.c **** void vTaskSuspendAll( void )
1075:../../freeRtos/Source/tasks.c **** {
1076:../../freeRtos/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1077:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE. */
1078:../../freeRtos/Source/tasks.c **** 	++uxSchedulerSuspended;
1079:../../freeRtos/Source/tasks.c **** }
1080:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1081:../../freeRtos/Source/tasks.c **** 
1082:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1083:../../freeRtos/Source/tasks.c **** {
1084:../../freeRtos/Source/tasks.c **** register tskTCB *pxTCB;
1085:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1086:../../freeRtos/Source/tasks.c **** 
1087:../../freeRtos/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1088:../../freeRtos/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1089:../../freeRtos/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1090:../../freeRtos/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1091:../../freeRtos/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1092:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1093:../../freeRtos/Source/tasks.c **** 	{
1094:../../freeRtos/Source/tasks.c **** 		--uxSchedulerSuspended;
1095:../../freeRtos/Source/tasks.c **** 
1096:../../freeRtos/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1097:../../freeRtos/Source/tasks.c **** 		{
1098:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
1099:../../freeRtos/Source/tasks.c **** 			{
1100:../../freeRtos/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1101:../../freeRtos/Source/tasks.c **** 
1102:../../freeRtos/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1103:../../freeRtos/Source/tasks.c **** 				appropriate ready list. */
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
1105:../../freeRtos/Source/tasks.c **** 				{
1106:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1107:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1109:../../freeRtos/Source/tasks.c **** 
1110:../../freeRtos/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1111:../../freeRtos/Source/tasks.c **** 					the current task then we should yield. */
1112:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1113:../../freeRtos/Source/tasks.c **** 					{
1114:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1115:../../freeRtos/Source/tasks.c **** 					}
1116:../../freeRtos/Source/tasks.c **** 				}
1117:../../freeRtos/Source/tasks.c **** 
1118:../../freeRtos/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1119:../../freeRtos/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1120:../../freeRtos/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1121:../../freeRtos/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1122:../../freeRtos/Source/tasks.c **** 				{
1123:../../freeRtos/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1124:../../freeRtos/Source/tasks.c **** 					{
1125:../../freeRtos/Source/tasks.c **** 						vTaskIncrementTick();
1126:../../freeRtos/Source/tasks.c **** 						--uxMissedTicks;
1127:../../freeRtos/Source/tasks.c **** 					}
1128:../../freeRtos/Source/tasks.c **** 
1129:../../freeRtos/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1130:../../freeRtos/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1131:../../freeRtos/Source/tasks.c **** 					the task actually running. */
1132:../../freeRtos/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1133:../../freeRtos/Source/tasks.c **** 					{
1134:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1135:../../freeRtos/Source/tasks.c **** 					}
1136:../../freeRtos/Source/tasks.c **** 					#endif
1137:../../freeRtos/Source/tasks.c **** 				}
1138:../../freeRtos/Source/tasks.c **** 
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1140:../../freeRtos/Source/tasks.c **** 				{
1141:../../freeRtos/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1142:../../freeRtos/Source/tasks.c **** 					xMissedYield = pdFALSE;
1143:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
1144:../../freeRtos/Source/tasks.c **** 				}
1145:../../freeRtos/Source/tasks.c **** 			}
1146:../../freeRtos/Source/tasks.c **** 		}
1147:../../freeRtos/Source/tasks.c **** 	}
1148:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1149:../../freeRtos/Source/tasks.c **** 
1150:../../freeRtos/Source/tasks.c **** 	return xAlreadyYielded;
1151:../../freeRtos/Source/tasks.c **** }
1152:../../freeRtos/Source/tasks.c **** 
1153:../../freeRtos/Source/tasks.c **** 
1154:../../freeRtos/Source/tasks.c **** 
1155:../../freeRtos/Source/tasks.c **** 
1156:../../freeRtos/Source/tasks.c **** 
1157:../../freeRtos/Source/tasks.c **** 
1158:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1159:../../freeRtos/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1160:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1161:../../freeRtos/Source/tasks.c **** 
1162:../../freeRtos/Source/tasks.c **** 
1163:../../freeRtos/Source/tasks.c **** 
1164:../../freeRtos/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1165:../../freeRtos/Source/tasks.c **** {
1166:../../freeRtos/Source/tasks.c **** portTickType xTicks;
1167:../../freeRtos/Source/tasks.c **** 
1168:../../freeRtos/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1169:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1170:../../freeRtos/Source/tasks.c **** 	{
1171:../../freeRtos/Source/tasks.c **** 		xTicks = xTickCount;
1172:../../freeRtos/Source/tasks.c **** 	}
1173:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1174:../../freeRtos/Source/tasks.c **** 
1175:../../freeRtos/Source/tasks.c **** 	return xTicks;
1176:../../freeRtos/Source/tasks.c **** }
1177:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1178:../../freeRtos/Source/tasks.c **** 
1179:../../freeRtos/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1180:../../freeRtos/Source/tasks.c **** {
1181:../../freeRtos/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1182:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE. */
1183:../../freeRtos/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1184:../../freeRtos/Source/tasks.c **** }
1185:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1186:../../freeRtos/Source/tasks.c **** 
1187:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1188:../../freeRtos/Source/tasks.c **** 
1189:../../freeRtos/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1190:../../freeRtos/Source/tasks.c **** 	{
1191:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1192:../../freeRtos/Source/tasks.c **** 
1193:../../freeRtos/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1194:../../freeRtos/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1195:../../freeRtos/Source/tasks.c **** 
1196:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
1197:../../freeRtos/Source/tasks.c **** 		{
1198:../../freeRtos/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1199:../../freeRtos/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1200:../../freeRtos/Source/tasks.c **** 
1201:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1202:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1203:../../freeRtos/Source/tasks.c **** 
1204:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1205:../../freeRtos/Source/tasks.c **** 
1206:../../freeRtos/Source/tasks.c **** 			do
1207:../../freeRtos/Source/tasks.c **** 			{
1208:../../freeRtos/Source/tasks.c **** 				uxQueue--;
1209:../../freeRtos/Source/tasks.c **** 
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1211:../../freeRtos/Source/tasks.c **** 				{
1212:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1213:../../freeRtos/Source/tasks.c **** 				}
1214:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1215:../../freeRtos/Source/tasks.c **** 
1216:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1217:../../freeRtos/Source/tasks.c **** 			{
1218:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1219:../../freeRtos/Source/tasks.c **** 			}
1220:../../freeRtos/Source/tasks.c **** 
1221:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1222:../../freeRtos/Source/tasks.c **** 			{
1223:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1224:../../freeRtos/Source/tasks.c **** 			}
1225:../../freeRtos/Source/tasks.c **** 
1226:../../freeRtos/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1227:../../freeRtos/Source/tasks.c **** 			{
1228:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1229:../../freeRtos/Source/tasks.c **** 				{
1230:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
1231:../../freeRtos/Source/tasks.c **** 				}
1232:../../freeRtos/Source/tasks.c **** 			}
1233:../../freeRtos/Source/tasks.c **** 			#endif
1234:../../freeRtos/Source/tasks.c **** 
1235:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1236:../../freeRtos/Source/tasks.c **** 			{
1237:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1238:../../freeRtos/Source/tasks.c **** 				{
1239:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
1240:../../freeRtos/Source/tasks.c **** 				}
1241:../../freeRtos/Source/tasks.c **** 			}
1242:../../freeRtos/Source/tasks.c **** 			#endif
1243:../../freeRtos/Source/tasks.c **** 		}
1244:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
1245:../../freeRtos/Source/tasks.c **** 	}
1246:../../freeRtos/Source/tasks.c **** 
1247:../../freeRtos/Source/tasks.c **** #endif
1248:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1249:../../freeRtos/Source/tasks.c **** 
1250:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1251:../../freeRtos/Source/tasks.c **** 
1252:../../freeRtos/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1253:../../freeRtos/Source/tasks.c **** 	{
1254:../../freeRtos/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1255:../../freeRtos/Source/tasks.c **** 	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1256:../../freeRtos/Source/tasks.c **** 
1257:../../freeRtos/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1258:../../freeRtos/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1259:../../freeRtos/Source/tasks.c **** 
1260:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
1261:../../freeRtos/Source/tasks.c **** 		{
1262:../../freeRtos/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1263:../../freeRtos/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1264:../../freeRtos/Source/tasks.c **** 			buffer. */
1265:../../freeRtos/Source/tasks.c **** 
1266:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1267:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1268:../../freeRtos/Source/tasks.c **** 
1269:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1270:../../freeRtos/Source/tasks.c **** 
1271:../../freeRtos/Source/tasks.c **** 			do
1272:../../freeRtos/Source/tasks.c **** 			{
1273:../../freeRtos/Source/tasks.c **** 				uxQueue--;
1274:../../freeRtos/Source/tasks.c **** 
1275:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1276:../../freeRtos/Source/tasks.c **** 				{
1277:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1278:../../freeRtos/Source/tasks.c **** 				}
1279:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1280:../../freeRtos/Source/tasks.c **** 
1281:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1282:../../freeRtos/Source/tasks.c **** 			{
1283:../../freeRtos/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1284:../../freeRtos/Source/tasks.c **** 			}
1285:../../freeRtos/Source/tasks.c **** 
1286:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1287:../../freeRtos/Source/tasks.c **** 			{
1288:../../freeRtos/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1289:../../freeRtos/Source/tasks.c **** 			}
1290:../../freeRtos/Source/tasks.c **** 
1291:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1292:../../freeRtos/Source/tasks.c **** 			{
1293:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1294:../../freeRtos/Source/tasks.c **** 				{
1295:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, u
1296:../../freeRtos/Source/tasks.c **** 				}
1297:../../freeRtos/Source/tasks.c **** 			}
1298:../../freeRtos/Source/tasks.c **** 			#endif
1299:../../freeRtos/Source/tasks.c **** 
1300:../../freeRtos/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1301:../../freeRtos/Source/tasks.c **** 			{
1302:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1303:../../freeRtos/Source/tasks.c **** 				{
1304:../../freeRtos/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotal
1305:../../freeRtos/Source/tasks.c **** 				}
1306:../../freeRtos/Source/tasks.c **** 			}
1307:../../freeRtos/Source/tasks.c **** 			#endif
1308:../../freeRtos/Source/tasks.c **** 		}
1309:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
1310:../../freeRtos/Source/tasks.c **** 	}
1311:../../freeRtos/Source/tasks.c **** 
1312:../../freeRtos/Source/tasks.c **** #endif
1313:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1314:../../freeRtos/Source/tasks.c **** 
1315:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1316:../../freeRtos/Source/tasks.c **** 
1317:../../freeRtos/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1318:../../freeRtos/Source/tasks.c **** 	{
1319:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1320:../../freeRtos/Source/tasks.c **** 		{
1321:../../freeRtos/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1322:../../freeRtos/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1323:../../freeRtos/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1324:../../freeRtos/Source/tasks.c **** 			xTracing = pdTRUE;
1325:../../freeRtos/Source/tasks.c **** 		}
1326:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1327:../../freeRtos/Source/tasks.c **** 	}
1328:../../freeRtos/Source/tasks.c **** 
1329:../../freeRtos/Source/tasks.c **** #endif
1330:../../freeRtos/Source/tasks.c **** /*----------------------------------------------------------*/
1331:../../freeRtos/Source/tasks.c **** 
1332:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1333:../../freeRtos/Source/tasks.c **** 
1334:../../freeRtos/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1335:../../freeRtos/Source/tasks.c **** 	{
1336:../../freeRtos/Source/tasks.c **** 	unsigned long ulBufferLength;
1337:../../freeRtos/Source/tasks.c **** 
1338:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1339:../../freeRtos/Source/tasks.c **** 			xTracing = pdFALSE;
1340:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1341:../../freeRtos/Source/tasks.c **** 
1342:../../freeRtos/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1343:../../freeRtos/Source/tasks.c **** 
1344:../../freeRtos/Source/tasks.c **** 		return ulBufferLength;
1345:../../freeRtos/Source/tasks.c **** 	}
1346:../../freeRtos/Source/tasks.c **** 
1347:../../freeRtos/Source/tasks.c **** #endif
1348:../../freeRtos/Source/tasks.c **** 
1349:../../freeRtos/Source/tasks.c **** 
1350:../../freeRtos/Source/tasks.c **** 
1351:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1352:../../freeRtos/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1353:../../freeRtos/Source/tasks.c ****  * documented in task.h
1354:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1355:../../freeRtos/Source/tasks.c **** 
1356:../../freeRtos/Source/tasks.c **** 
1357:../../freeRtos/Source/tasks.c **** void vTaskIncrementTick( void )
1358:../../freeRtos/Source/tasks.c **** {
1359:../../freeRtos/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1360:../../freeRtos/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1361:../../freeRtos/Source/tasks.c **** 	tasks to be unblocked. */
1362:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1363:../../freeRtos/Source/tasks.c **** 	{
1364:../../freeRtos/Source/tasks.c **** 		++xTickCount;
1365:../../freeRtos/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
1366:../../freeRtos/Source/tasks.c **** 		{
1367:../../freeRtos/Source/tasks.c **** 			xList *pxTemp;
1368:../../freeRtos/Source/tasks.c **** 
1369:../../freeRtos/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1370:../../freeRtos/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1371:../../freeRtos/Source/tasks.c **** 			an error! */
1372:../../freeRtos/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1373:../../freeRtos/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1374:../../freeRtos/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1375:../../freeRtos/Source/tasks.c **** 			xNumOfOverflows++;
1376:../../freeRtos/Source/tasks.c **** 		}
1377:../../freeRtos/Source/tasks.c **** 
1378:../../freeRtos/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
1380:../../freeRtos/Source/tasks.c **** 	}
1381:../../freeRtos/Source/tasks.c **** 	else
1382:../../freeRtos/Source/tasks.c **** 	{
1383:../../freeRtos/Source/tasks.c **** 		++uxMissedTicks;
1384:../../freeRtos/Source/tasks.c **** 
1385:../../freeRtos/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1386:../../freeRtos/Source/tasks.c **** 		scheduler is locked. */
1387:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1388:../../freeRtos/Source/tasks.c **** 		{
1389:../../freeRtos/Source/tasks.c **** 			extern void vApplicationTickHook( void );
1390:../../freeRtos/Source/tasks.c **** 
1391:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
1392:../../freeRtos/Source/tasks.c **** 		}
1393:../../freeRtos/Source/tasks.c **** 		#endif
1394:../../freeRtos/Source/tasks.c **** 	}
1395:../../freeRtos/Source/tasks.c **** 
1396:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1397:../../freeRtos/Source/tasks.c **** 	{
1398:../../freeRtos/Source/tasks.c **** 		extern void vApplicationTickHook( void );
1399:../../freeRtos/Source/tasks.c **** 
1400:../../freeRtos/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1401:../../freeRtos/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1402:../../freeRtos/Source/tasks.c **** 		if( uxMissedTicks == 0 )
1403:../../freeRtos/Source/tasks.c **** 		{
1404:../../freeRtos/Source/tasks.c **** 			vApplicationTickHook();
1405:../../freeRtos/Source/tasks.c **** 		}
1406:../../freeRtos/Source/tasks.c **** 	}
1407:../../freeRtos/Source/tasks.c **** 	#endif
1408:../../freeRtos/Source/tasks.c **** 
1409:../../freeRtos/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1410:../../freeRtos/Source/tasks.c **** }
1411:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1412:../../freeRtos/Source/tasks.c **** 
1413:../../freeRtos/Source/tasks.c **** #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1414:../../freeRtos/Source/tasks.c **** 
1415:../../freeRtos/Source/tasks.c **** 	void vTaskCleanUpResources( void )
1416:../../freeRtos/Source/tasks.c **** 	{
1417:../../freeRtos/Source/tasks.c **** 	unsigned short usQueue;
1418:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxTCB;
1419:../../freeRtos/Source/tasks.c **** 
1420:../../freeRtos/Source/tasks.c **** 		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
1421:../../freeRtos/Source/tasks.c **** 
1422:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the ready queues. */
1423:../../freeRtos/Source/tasks.c **** 		do
1424:../../freeRtos/Source/tasks.c **** 		{
1425:../../freeRtos/Source/tasks.c **** 			usQueue--;
1426:../../freeRtos/Source/tasks.c **** 
1427:../../freeRtos/Source/tasks.c **** 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
1428:../../freeRtos/Source/tasks.c **** 			{
1429:../../freeRtos/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
1430:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1431:../../freeRtos/Source/tasks.c **** 
1432:../../freeRtos/Source/tasks.c **** 				prvDeleteTCB( ( tskTCB * ) pxTCB );
1433:../../freeRtos/Source/tasks.c **** 			}
1434:../../freeRtos/Source/tasks.c **** 		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
1435:../../freeRtos/Source/tasks.c **** 
1436:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the delayed queue. */
1437:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
1438:../../freeRtos/Source/tasks.c **** 		{
1439:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
1440:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1441:../../freeRtos/Source/tasks.c **** 
1442:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1443:../../freeRtos/Source/tasks.c **** 		}
1444:../../freeRtos/Source/tasks.c **** 
1445:../../freeRtos/Source/tasks.c **** 		/* Remove any TCB's from the overflow delayed queue. */
1446:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
1447:../../freeRtos/Source/tasks.c **** 		{
1448:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
1449:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1450:../../freeRtos/Source/tasks.c **** 
1451:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1452:../../freeRtos/Source/tasks.c **** 		}
1453:../../freeRtos/Source/tasks.c **** 
1454:../../freeRtos/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1455:../../freeRtos/Source/tasks.c **** 		{
1456:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
1457:../../freeRtos/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1458:../../freeRtos/Source/tasks.c **** 
1459:../../freeRtos/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1460:../../freeRtos/Source/tasks.c **** 		}
1461:../../freeRtos/Source/tasks.c **** 	}
1462:../../freeRtos/Source/tasks.c **** 
1463:../../freeRtos/Source/tasks.c **** #endif
1464:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1465:../../freeRtos/Source/tasks.c **** 
1466:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1467:../../freeRtos/Source/tasks.c **** 
1468:../../freeRtos/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
1469:../../freeRtos/Source/tasks.c **** 	{
1470:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1471:../../freeRtos/Source/tasks.c **** 
1472:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1473:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1474:../../freeRtos/Source/tasks.c **** 		{
1475:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1476:../../freeRtos/Source/tasks.c **** 		}
1477:../../freeRtos/Source/tasks.c **** 		else
1478:../../freeRtos/Source/tasks.c **** 		{
1479:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1480:../../freeRtos/Source/tasks.c **** 		}
1481:../../freeRtos/Source/tasks.c **** 
1482:../../freeRtos/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1483:../../freeRtos/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1484:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1485:../../freeRtos/Source/tasks.c **** 			xTCB->pxTaskTag = pxTagValue;
1486:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1487:../../freeRtos/Source/tasks.c **** 	}
1488:../../freeRtos/Source/tasks.c **** 
1489:../../freeRtos/Source/tasks.c **** #endif
1490:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1491:../../freeRtos/Source/tasks.c **** 
1492:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1493:../../freeRtos/Source/tasks.c **** 
1494:../../freeRtos/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1495:../../freeRtos/Source/tasks.c **** 	{
1496:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1497:../../freeRtos/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1498:../../freeRtos/Source/tasks.c **** 
1499:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1500:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1501:../../freeRtos/Source/tasks.c **** 		{
1502:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1503:../../freeRtos/Source/tasks.c **** 		}
1504:../../freeRtos/Source/tasks.c **** 		else
1505:../../freeRtos/Source/tasks.c **** 		{
1506:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1507:../../freeRtos/Source/tasks.c **** 		}
1508:../../freeRtos/Source/tasks.c **** 
1509:../../freeRtos/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1510:../../freeRtos/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1511:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
1512:../../freeRtos/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1513:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
1514:../../freeRtos/Source/tasks.c **** 
1515:../../freeRtos/Source/tasks.c **** 		return xReturn;
1516:../../freeRtos/Source/tasks.c **** 	}
1517:../../freeRtos/Source/tasks.c **** 
1518:../../freeRtos/Source/tasks.c **** #endif
1519:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1520:../../freeRtos/Source/tasks.c **** 
1521:../../freeRtos/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1522:../../freeRtos/Source/tasks.c **** 
1523:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1524:../../freeRtos/Source/tasks.c **** 	{
1525:../../freeRtos/Source/tasks.c **** 	tskTCB *xTCB;
1526:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn;
1527:../../freeRtos/Source/tasks.c **** 
1528:../../freeRtos/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1529:../../freeRtos/Source/tasks.c **** 		if( xTask == NULL )
1530:../../freeRtos/Source/tasks.c **** 		{
1531:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1532:../../freeRtos/Source/tasks.c **** 		}
1533:../../freeRtos/Source/tasks.c **** 		else
1534:../../freeRtos/Source/tasks.c **** 		{
1535:../../freeRtos/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1536:../../freeRtos/Source/tasks.c **** 		}
1537:../../freeRtos/Source/tasks.c **** 
1538:../../freeRtos/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1539:../../freeRtos/Source/tasks.c **** 		{
1540:../../freeRtos/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1541:../../freeRtos/Source/tasks.c **** 		}
1542:../../freeRtos/Source/tasks.c **** 		else
1543:../../freeRtos/Source/tasks.c **** 		{
1544:../../freeRtos/Source/tasks.c **** 			xReturn = pdFAIL;
1545:../../freeRtos/Source/tasks.c **** 		}
1546:../../freeRtos/Source/tasks.c **** 
1547:../../freeRtos/Source/tasks.c **** 		return xReturn;
1548:../../freeRtos/Source/tasks.c **** 	}
1549:../../freeRtos/Source/tasks.c **** 
1550:../../freeRtos/Source/tasks.c **** #endif
1551:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1552:../../freeRtos/Source/tasks.c **** 
1553:../../freeRtos/Source/tasks.c **** void vTaskSwitchContext( void )
1554:../../freeRtos/Source/tasks.c **** {
1555:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1556:../../freeRtos/Source/tasks.c **** 	{
1557:../../freeRtos/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1558:../../freeRtos/Source/tasks.c **** 		switch. */
1559:../../freeRtos/Source/tasks.c **** 		xMissedYield = pdTRUE;
1560:../../freeRtos/Source/tasks.c **** 		return;
1561:../../freeRtos/Source/tasks.c **** 	}
1562:../../freeRtos/Source/tasks.c **** 
1563:../../freeRtos/Source/tasks.c **** 	traceTASK_SWITCHED_OUT();
1564:../../freeRtos/Source/tasks.c **** 
1565:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1566:../../freeRtos/Source/tasks.c **** 	{
1567:../../freeRtos/Source/tasks.c **** 		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1568:../../freeRtos/Source/tasks.c **** 
1569:../../freeRtos/Source/tasks.c **** 			/* Add the amount of time the task has been running to the accumulated
1570:../../freeRtos/Source/tasks.c **** 			time so far.  The time the task started running was stored in
1571:../../freeRtos/Source/tasks.c **** 			ulTaskSwitchedInTime.  Note that there is no overflow protection here
1572:../../freeRtos/Source/tasks.c **** 			so count values are only valid until the timer overflows.  Generally
1573:../../freeRtos/Source/tasks.c **** 			this will be about 1 hour assuming a 1uS timer increment. */
1574:../../freeRtos/Source/tasks.c **** 			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1575:../../freeRtos/Source/tasks.c **** 			ulTaskSwitchedInTime = ulTempCounter;
1576:../../freeRtos/Source/tasks.c **** 	}
1577:../../freeRtos/Source/tasks.c **** 	#endif
1578:../../freeRtos/Source/tasks.c **** 
1579:../../freeRtos/Source/tasks.c **** 	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1580:../../freeRtos/Source/tasks.c **** 	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1581:../../freeRtos/Source/tasks.c **** 
1582:../../freeRtos/Source/tasks.c **** 	/* Find the highest priority queue that contains ready tasks. */
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1584:../../freeRtos/Source/tasks.c **** 	{
1585:../../freeRtos/Source/tasks.c **** 		--uxTopReadyPriority;
1586:../../freeRtos/Source/tasks.c **** 	}
1587:../../freeRtos/Source/tasks.c **** 
1588:../../freeRtos/Source/tasks.c **** 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1589:../../freeRtos/Source/tasks.c **** 	same priority get an equal share of the processor time. */
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1591:../../freeRtos/Source/tasks.c **** 
1592:../../freeRtos/Source/tasks.c **** 	traceTASK_SWITCHED_IN();
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
1594:../../freeRtos/Source/tasks.c **** }
1595:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1596:../../freeRtos/Source/tasks.c **** 
1597:../../freeRtos/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1598:../../freeRtos/Source/tasks.c **** {
1599:../../freeRtos/Source/tasks.c **** portTickType xTimeToWake;
1600:../../freeRtos/Source/tasks.c **** 
1601:../../freeRtos/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1602:../../freeRtos/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1603:../../freeRtos/Source/tasks.c **** 
1604:../../freeRtos/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1605:../../freeRtos/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1606:../../freeRtos/Source/tasks.c **** 	is the first to be woken by the event. */
1607:../../freeRtos/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1608:../../freeRtos/Source/tasks.c **** 
1609:../../freeRtos/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1610:../../freeRtos/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1611:../../freeRtos/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1612:../../freeRtos/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1613:../../freeRtos/Source/tasks.c **** 
1614:../../freeRtos/Source/tasks.c **** 
1615:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1616:../../freeRtos/Source/tasks.c **** 	{
1617:../../freeRtos/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1618:../../freeRtos/Source/tasks.c **** 		{
1619:../../freeRtos/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1620:../../freeRtos/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1621:../../freeRtos/Source/tasks.c **** 			indefinitely. */
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1623:../../freeRtos/Source/tasks.c **** 		}
1624:../../freeRtos/Source/tasks.c **** 		else
1625:../../freeRtos/Source/tasks.c **** 		{
1626:../../freeRtos/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1627:../../freeRtos/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1628:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1629:../../freeRtos/Source/tasks.c **** 
1630:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1631:../../freeRtos/Source/tasks.c **** 
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1633:../../freeRtos/Source/tasks.c **** 			{
1634:../../freeRtos/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1636:../../freeRtos/Source/tasks.c **** 			}
1637:../../freeRtos/Source/tasks.c **** 			else
1638:../../freeRtos/Source/tasks.c **** 			{
1639:../../freeRtos/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1641:../../freeRtos/Source/tasks.c **** 			}
1642:../../freeRtos/Source/tasks.c **** 		}
1643:../../freeRtos/Source/tasks.c **** 	}
1644:../../freeRtos/Source/tasks.c **** 	#else
1645:../../freeRtos/Source/tasks.c **** 	{
1646:../../freeRtos/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1647:../../freeRtos/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1648:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1649:../../freeRtos/Source/tasks.c **** 
1650:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1651:../../freeRtos/Source/tasks.c **** 
1652:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1653:../../freeRtos/Source/tasks.c **** 			{
1654:../../freeRtos/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1655:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1656:../../freeRtos/Source/tasks.c **** 			}
1657:../../freeRtos/Source/tasks.c **** 			else
1658:../../freeRtos/Source/tasks.c **** 			{
1659:../../freeRtos/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1660:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1661:../../freeRtos/Source/tasks.c **** 			}
1662:../../freeRtos/Source/tasks.c **** 	}
1663:../../freeRtos/Source/tasks.c **** 	#endif
1664:../../freeRtos/Source/tasks.c **** }
1665:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1666:../../freeRtos/Source/tasks.c **** 
1667:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1668:../../freeRtos/Source/tasks.c **** {
1669:../../freeRtos/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1670:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1671:../../freeRtos/Source/tasks.c **** 
1672:../../freeRtos/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1673:../../freeRtos/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1674:../../freeRtos/Source/tasks.c **** 
1675:../../freeRtos/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1676:../../freeRtos/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1677:../../freeRtos/Source/tasks.c **** 	it to the ready list.
1678:../../freeRtos/Source/tasks.c **** 
1679:../../freeRtos/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1680:../../freeRtos/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1681:../../freeRtos/Source/tasks.c **** 	means we can always expect exclusive access to the event list here. */
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1683:../../freeRtos/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1684:../../freeRtos/Source/tasks.c **** 
1685:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1686:../../freeRtos/Source/tasks.c **** 	{
1687:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1689:../../freeRtos/Source/tasks.c **** 	}
1690:../../freeRtos/Source/tasks.c **** 	else
1691:../../freeRtos/Source/tasks.c **** 	{
1692:../../freeRtos/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1693:../../freeRtos/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1694:../../freeRtos/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1695:../../freeRtos/Source/tasks.c **** 	}
1696:../../freeRtos/Source/tasks.c **** 
1697:../../freeRtos/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1698:../../freeRtos/Source/tasks.c **** 	{
1699:../../freeRtos/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1700:../../freeRtos/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1701:../../freeRtos/Source/tasks.c **** 		the calling task to know if it should force a context
1702:../../freeRtos/Source/tasks.c **** 		switch now. */
1703:../../freeRtos/Source/tasks.c **** 		xReturn = pdTRUE;
1704:../../freeRtos/Source/tasks.c **** 	}
1705:../../freeRtos/Source/tasks.c **** 	else
1706:../../freeRtos/Source/tasks.c **** 	{
1707:../../freeRtos/Source/tasks.c **** 		xReturn = pdFALSE;
1708:../../freeRtos/Source/tasks.c **** 	}
1709:../../freeRtos/Source/tasks.c **** 
1710:../../freeRtos/Source/tasks.c **** 	return xReturn;
1711:../../freeRtos/Source/tasks.c **** }
1712:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1713:../../freeRtos/Source/tasks.c **** 
1714:../../freeRtos/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1715:../../freeRtos/Source/tasks.c **** {
1716:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1717:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1718:../../freeRtos/Source/tasks.c **** }
1719:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1720:../../freeRtos/Source/tasks.c **** 
1721:../../freeRtos/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1722:../../freeRtos/Source/tasks.c **** {
1723:../../freeRtos/Source/tasks.c **** portBASE_TYPE xReturn;
1724:../../freeRtos/Source/tasks.c **** 
1725:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
1726:../../freeRtos/Source/tasks.c **** 	{
1727:../../freeRtos/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1728:../../freeRtos/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1729:../../freeRtos/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1730:../../freeRtos/Source/tasks.c **** 			therefore never time out. */
1731:../../freeRtos/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
1732:../../freeRtos/Source/tasks.c **** 			{
1733:../../freeRtos/Source/tasks.c **** 				xReturn = pdFALSE;
1734:../../freeRtos/Source/tasks.c **** 			}
1735:../../freeRtos/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1736:../../freeRtos/Source/tasks.c **** 		#endif
1737:../../freeRtos/Source/tasks.c **** 
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1739:../../freeRtos/Source/tasks.c **** 		{
1740:../../freeRtos/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1741:../../freeRtos/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1742:../../freeRtos/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1743:../../freeRtos/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1744:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
1745:../../freeRtos/Source/tasks.c **** 		}
1746:../../freeRtos/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1747:../../freeRtos/Source/tasks.c **** 		{
1748:../../freeRtos/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1749:../../freeRtos/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1750:../../freeRtos/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1751:../../freeRtos/Source/tasks.c **** 			xReturn = pdFALSE;
1752:../../freeRtos/Source/tasks.c **** 		}
1753:../../freeRtos/Source/tasks.c **** 		else
1754:../../freeRtos/Source/tasks.c **** 		{
1755:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
1756:../../freeRtos/Source/tasks.c **** 		}
1757:../../freeRtos/Source/tasks.c **** 	}
1758:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
1759:../../freeRtos/Source/tasks.c **** 
1760:../../freeRtos/Source/tasks.c **** 	return xReturn;
1761:../../freeRtos/Source/tasks.c **** }
1762:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1763:../../freeRtos/Source/tasks.c **** 
1764:../../freeRtos/Source/tasks.c **** void vTaskMissedYield( void )
1765:../../freeRtos/Source/tasks.c **** {
1766:../../freeRtos/Source/tasks.c **** 	xMissedYield = pdTRUE;
1767:../../freeRtos/Source/tasks.c **** }
1768:../../freeRtos/Source/tasks.c **** 
1769:../../freeRtos/Source/tasks.c **** /*
1770:../../freeRtos/Source/tasks.c ****  * -----------------------------------------------------------
1771:../../freeRtos/Source/tasks.c ****  * The Idle task.
1772:../../freeRtos/Source/tasks.c ****  * ----------------------------------------------------------
1773:../../freeRtos/Source/tasks.c ****  *
1774:../../freeRtos/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1775:../../freeRtos/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1776:../../freeRtos/Source/tasks.c ****  *
1777:../../freeRtos/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1778:../../freeRtos/Source/tasks.c ****  *
1779:../../freeRtos/Source/tasks.c ****  */
1780:../../freeRtos/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1781:../../freeRtos/Source/tasks.c **** {
 487               	.LM0:
 488               	.LFBB1:
 489               	/* prologue: function */
 490               	/* frame size = 0 */
 491               	/* stack size = 0 */
 492               	.L__stack_usage = 0
 493               	.L2:
1782:../../freeRtos/Source/tasks.c **** 	/* Stop warnings. */
1783:../../freeRtos/Source/tasks.c **** 	( void ) pvParameters;
1784:../../freeRtos/Source/tasks.c **** 
1785:../../freeRtos/Source/tasks.c **** 	for( ;; )
1786:../../freeRtos/Source/tasks.c **** 	{
1787:../../freeRtos/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1788:../../freeRtos/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1789:../../freeRtos/Source/tasks.c **** 
1790:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1791:../../freeRtos/Source/tasks.c **** 		{
1792:../../freeRtos/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1793:../../freeRtos/Source/tasks.c **** 			see if any other task has become available.  If we are using
1794:../../freeRtos/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1795:../../freeRtos/Source/tasks.c **** 			will automatically get the processor anyway. */
1796:../../freeRtos/Source/tasks.c **** 			taskYIELD();
 495               	.LM1:
 496 0000 0E94 0000 		call vPortYield
 497 0004 00C0      		rjmp .L2
 499               	.Lscope1:
 501               		.stabd	78,0,0
 502               		.section	.rodata.str1.1,"aMS",@progbits,1
 503               	.LC0:
 504 0000 2573 0909 		.string	"%s\t\t%c\t%u\t%u\t%u\r\n"
 504      2563 0925 
 504      7509 2575 
 504      0925 750D 
 504      0A00 
 505               		.text
 511               	prvListTaskWithinSingleList:
 512               		.stabd	46,0,0
1797:../../freeRtos/Source/tasks.c **** 		}
1798:../../freeRtos/Source/tasks.c **** 		#endif
1799:../../freeRtos/Source/tasks.c **** 
1800:../../freeRtos/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1801:../../freeRtos/Source/tasks.c **** 		{
1802:../../freeRtos/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1803:../../freeRtos/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1804:../../freeRtos/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1805:../../freeRtos/Source/tasks.c **** 			timeslice.
1806:../../freeRtos/Source/tasks.c **** 
1807:../../freeRtos/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1808:../../freeRtos/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1809:../../freeRtos/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1810:../../freeRtos/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1811:../../freeRtos/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1812:../../freeRtos/Source/tasks.c **** 			{
1813:../../freeRtos/Source/tasks.c **** 				taskYIELD();
1814:../../freeRtos/Source/tasks.c **** 			}
1815:../../freeRtos/Source/tasks.c **** 		}
1816:../../freeRtos/Source/tasks.c **** 		#endif
1817:../../freeRtos/Source/tasks.c **** 
1818:../../freeRtos/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1819:../../freeRtos/Source/tasks.c **** 		{
1820:../../freeRtos/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1821:../../freeRtos/Source/tasks.c **** 
1822:../../freeRtos/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1823:../../freeRtos/Source/tasks.c **** 			allows the application designer to add background functionality
1824:../../freeRtos/Source/tasks.c **** 			without the overhead of a separate task.
1825:../../freeRtos/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1826:../../freeRtos/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1827:../../freeRtos/Source/tasks.c **** 			vApplicationIdleHook();
1828:../../freeRtos/Source/tasks.c **** 		}
1829:../../freeRtos/Source/tasks.c **** 		#endif
1830:../../freeRtos/Source/tasks.c **** 	}
1831:../../freeRtos/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1832:../../freeRtos/Source/tasks.c **** 
1833:../../freeRtos/Source/tasks.c **** 
1834:../../freeRtos/Source/tasks.c **** 
1835:../../freeRtos/Source/tasks.c **** 
1836:../../freeRtos/Source/tasks.c **** 
1837:../../freeRtos/Source/tasks.c **** 
1838:../../freeRtos/Source/tasks.c **** 
1839:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------
1840:../../freeRtos/Source/tasks.c ****  * File private functions documented at the top of the file.
1841:../../freeRtos/Source/tasks.c ****  *----------------------------------------------------------*/
1842:../../freeRtos/Source/tasks.c **** 
1843:../../freeRtos/Source/tasks.c **** 
1844:../../freeRtos/Source/tasks.c **** 
1845:../../freeRtos/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1846:../../freeRtos/Source/tasks.c **** {
1847:../../freeRtos/Source/tasks.c **** 	/* Store the function name in the TCB. */
1848:../../freeRtos/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1849:../../freeRtos/Source/tasks.c **** 	{
1850:../../freeRtos/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1851:../../freeRtos/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1852:../../freeRtos/Source/tasks.c **** 	}
1853:../../freeRtos/Source/tasks.c **** 	#endif
1854:../../freeRtos/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
1855:../../freeRtos/Source/tasks.c **** 
1856:../../freeRtos/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1857:../../freeRtos/Source/tasks.c **** 	remove the privilege bit if one is present. */
1858:../../freeRtos/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1859:../../freeRtos/Source/tasks.c **** 	{
1860:../../freeRtos/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - 1;
1861:../../freeRtos/Source/tasks.c **** 	}
1862:../../freeRtos/Source/tasks.c **** 
1863:../../freeRtos/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
1864:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1865:../../freeRtos/Source/tasks.c **** 	{
1866:../../freeRtos/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
1867:../../freeRtos/Source/tasks.c **** 	}
1868:../../freeRtos/Source/tasks.c **** 	#endif
1869:../../freeRtos/Source/tasks.c **** 
1870:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
1871:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
1872:../../freeRtos/Source/tasks.c **** 
1873:../../freeRtos/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1874:../../freeRtos/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1875:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
1876:../../freeRtos/Source/tasks.c **** 
1877:../../freeRtos/Source/tasks.c **** 	/* Event lists are always in priority order. */
1878:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
1879:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
1880:../../freeRtos/Source/tasks.c **** 
1881:../../freeRtos/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1882:../../freeRtos/Source/tasks.c **** 	{
1883:../../freeRtos/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
1884:../../freeRtos/Source/tasks.c **** 	}
1885:../../freeRtos/Source/tasks.c **** 	#endif
1886:../../freeRtos/Source/tasks.c **** 
1887:../../freeRtos/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1888:../../freeRtos/Source/tasks.c **** 	{
1889:../../freeRtos/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1890:../../freeRtos/Source/tasks.c **** 	}
1891:../../freeRtos/Source/tasks.c **** 	#endif
1892:../../freeRtos/Source/tasks.c **** 
1893:../../freeRtos/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1894:../../freeRtos/Source/tasks.c **** 	{
1895:../../freeRtos/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1896:../../freeRtos/Source/tasks.c **** 	}
1897:../../freeRtos/Source/tasks.c **** 	#endif
1898:../../freeRtos/Source/tasks.c **** 
1899:../../freeRtos/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1900:../../freeRtos/Source/tasks.c **** 	{
1901:../../freeRtos/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1902:../../freeRtos/Source/tasks.c **** 	}
1903:../../freeRtos/Source/tasks.c **** 	#else
1904:../../freeRtos/Source/tasks.c **** 	{
1905:../../freeRtos/Source/tasks.c **** 		( void ) xRegions;
1906:../../freeRtos/Source/tasks.c **** 		( void ) usStackDepth;
1907:../../freeRtos/Source/tasks.c **** 	}
1908:../../freeRtos/Source/tasks.c **** 	#endif
1909:../../freeRtos/Source/tasks.c **** }
1910:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1911:../../freeRtos/Source/tasks.c **** 
1912:../../freeRtos/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
1913:../../freeRtos/Source/tasks.c **** 
1914:../../freeRtos/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
1915:../../freeRtos/Source/tasks.c **** 	{
1916:../../freeRtos/Source/tasks.c **** 	tskTCB *pxTCB;
1917:../../freeRtos/Source/tasks.c **** 	
1918:../../freeRtos/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
1919:../../freeRtos/Source/tasks.c **** 		{
1920:../../freeRtos/Source/tasks.c **** 			xTaskToModify = NULL;
1921:../../freeRtos/Source/tasks.c **** 		}
1922:../../freeRtos/Source/tasks.c **** 
1923:../../freeRtos/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
1924:../../freeRtos/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
1925:../../freeRtos/Source/tasks.c **** 
1926:../../freeRtos/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
1927:../../freeRtos/Source/tasks.c **** 	}
1928:../../freeRtos/Source/tasks.c **** 	/*-----------------------------------------------------------*/
1929:../../freeRtos/Source/tasks.c **** #endif
1930:../../freeRtos/Source/tasks.c **** 
1931:../../freeRtos/Source/tasks.c **** static void prvInitialiseTaskLists( void )
1932:../../freeRtos/Source/tasks.c **** {
1933:../../freeRtos/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
1934:../../freeRtos/Source/tasks.c **** 
1935:../../freeRtos/Source/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
1936:../../freeRtos/Source/tasks.c **** 	{
1937:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
1938:../../freeRtos/Source/tasks.c **** 	}
1939:../../freeRtos/Source/tasks.c **** 
1940:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
1941:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
1942:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
1943:../../freeRtos/Source/tasks.c **** 
1944:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1945:../../freeRtos/Source/tasks.c **** 	{
1946:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
1947:../../freeRtos/Source/tasks.c **** 	}
1948:../../freeRtos/Source/tasks.c **** 	#endif
1949:../../freeRtos/Source/tasks.c **** 
1950:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1951:../../freeRtos/Source/tasks.c **** 	{
1952:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
1953:../../freeRtos/Source/tasks.c **** 	}
1954:../../freeRtos/Source/tasks.c **** 	#endif
1955:../../freeRtos/Source/tasks.c **** 
1956:../../freeRtos/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
1957:../../freeRtos/Source/tasks.c **** 	using list2. */
1958:../../freeRtos/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
1959:../../freeRtos/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
1960:../../freeRtos/Source/tasks.c **** }
1961:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1962:../../freeRtos/Source/tasks.c **** 
1963:../../freeRtos/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
1964:../../freeRtos/Source/tasks.c **** {
1965:../../freeRtos/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1966:../../freeRtos/Source/tasks.c **** 	{
1967:../../freeRtos/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
1968:../../freeRtos/Source/tasks.c **** 
1969:../../freeRtos/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
1970:../../freeRtos/Source/tasks.c **** 		too often in the idle task. */
1971:../../freeRtos/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
1972:../../freeRtos/Source/tasks.c **** 		{
1973:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
1974:../../freeRtos/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
1975:../../freeRtos/Source/tasks.c **** 			xTaskResumeAll();
1976:../../freeRtos/Source/tasks.c **** 
1977:../../freeRtos/Source/tasks.c **** 			if( !xListIsEmpty )
1978:../../freeRtos/Source/tasks.c **** 			{
1979:../../freeRtos/Source/tasks.c **** 				tskTCB *pxTCB;
1980:../../freeRtos/Source/tasks.c **** 
1981:../../freeRtos/Source/tasks.c **** 				portENTER_CRITICAL();
1982:../../freeRtos/Source/tasks.c **** 				{
1983:../../freeRtos/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
1984:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1985:../../freeRtos/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
1986:../../freeRtos/Source/tasks.c **** 					--uxTasksDeleted;
1987:../../freeRtos/Source/tasks.c **** 				}
1988:../../freeRtos/Source/tasks.c **** 				portEXIT_CRITICAL();
1989:../../freeRtos/Source/tasks.c **** 
1990:../../freeRtos/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1991:../../freeRtos/Source/tasks.c **** 			}
1992:../../freeRtos/Source/tasks.c **** 		}
1993:../../freeRtos/Source/tasks.c **** 	}
1994:../../freeRtos/Source/tasks.c **** 	#endif
1995:../../freeRtos/Source/tasks.c **** }
1996:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
1997:../../freeRtos/Source/tasks.c **** 
1998:../../freeRtos/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
1999:../../freeRtos/Source/tasks.c **** {
2000:../../freeRtos/Source/tasks.c **** tskTCB *pxNewTCB;
2001:../../freeRtos/Source/tasks.c **** 
2002:../../freeRtos/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2003:../../freeRtos/Source/tasks.c **** 	the implementation of the port malloc function. */
2004:../../freeRtos/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2005:../../freeRtos/Source/tasks.c **** 
2006:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
2007:../../freeRtos/Source/tasks.c **** 	{
2008:../../freeRtos/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2009:../../freeRtos/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2010:../../freeRtos/Source/tasks.c **** 		be deleted later if required. */
2011:../../freeRtos/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2012:../../freeRtos/Source/tasks.c **** 
2013:../../freeRtos/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
2014:../../freeRtos/Source/tasks.c **** 		{
2015:../../freeRtos/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2016:../../freeRtos/Source/tasks.c **** 			vPortFree( pxNewTCB );
2017:../../freeRtos/Source/tasks.c **** 			pxNewTCB = NULL;
2018:../../freeRtos/Source/tasks.c **** 		}
2019:../../freeRtos/Source/tasks.c **** 		else
2020:../../freeRtos/Source/tasks.c **** 		{
2021:../../freeRtos/Source/tasks.c **** 			/* Just to help debugging. */
2022:../../freeRtos/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
2023:../../freeRtos/Source/tasks.c **** 		}
2024:../../freeRtos/Source/tasks.c **** 	}
2025:../../freeRtos/Source/tasks.c **** 
2026:../../freeRtos/Source/tasks.c **** 	return pxNewTCB;
2027:../../freeRtos/Source/tasks.c **** }
2028:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2029:../../freeRtos/Source/tasks.c **** 
2030:../../freeRtos/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2031:../../freeRtos/Source/tasks.c **** 
2032:../../freeRtos/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2033:../../freeRtos/Source/tasks.c **** 	{
 514               	.LM2:
 515               	.LFBB2:
 516 0006 2F92      		push r2
 517 0008 3F92      		push r3
 518 000a 4F92      		push r4
 519 000c 5F92      		push r5
 520 000e 6F92      		push r6
 521 0010 7F92      		push r7
 522 0012 8F92      		push r8
 523 0014 9F92      		push r9
 524 0016 AF92      		push r10
 525 0018 BF92      		push r11
 526 001a CF92      		push r12
 527 001c DF92      		push r13
 528 001e EF92      		push r14
 529 0020 FF92      		push r15
 530 0022 0F93      		push r16
 531 0024 1F93      		push r17
 532 0026 CF93      		push r28
 533 0028 DF93      		push r29
 534 002a 1F92      		push __zero_reg__
 535 002c CDB7      		in r28,__SP_L__
 536 002e DEB7      		in r29,__SP_H__
 537               	/* prologue: function */
 538               	/* frame size = 1 */
 539               	/* stack size = 19 */
 540               	.L__stack_usage = 19
 541 0030 5C01      		movw r10,r24
 542 0032 1B01      		movw r2,r22
 543               	.LBB8:
2034:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2035:../../freeRtos/Source/tasks.c **** 	unsigned short usStackRemaining;
2036:../../freeRtos/Source/tasks.c **** 
2037:../../freeRtos/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2038:../../freeRtos/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 545               	.LM3:
 546 0034 DB01      		movw r26,r22
 547 0036 1196      		adiw r26,1
 548 0038 ED91      		ld r30,X+
 549 003a FC91      		ld r31,X
 550 003c 1297      		sbiw r26,1+1
 551 003e 8281      		ldd r24,Z+2
 552 0040 9381      		ldd r25,Z+3
 553 0042 1196      		adiw r26,1
 554 0044 8D93      		st X+,r24
 555 0046 9C93      		st X,r25
 556 0048 1297      		sbiw r26,1+1
 557 004a 3B01      		movw r6,r22
 558 004c B3E0      		ldi r27,3
 559 004e 6B0E      		add r6,r27
 560 0050 711C      		adc r7,__zero_reg__
 561 0052 8615      		cp r24,r6
 562 0054 9705      		cpc r25,r7
 563 0056 01F4      		brne .L4
 565               	.LM4:
 566 0058 F301      		movw r30,r6
 567 005a 8281      		ldd r24,Z+2
 568 005c 9381      		ldd r25,Z+3
 569 005e DB01      		movw r26,r22
 570 0060 1196      		adiw r26,1
 571 0062 8D93      		st X+,r24
 572 0064 9C93      		st X,r25
 573 0066 1297      		sbiw r26,1+1
 574               	.L4:
 576               	.LM5:
 577 0068 D101      		movw r26,r2
 578 006a 1196      		adiw r26,1
 579 006c ED91      		ld r30,X+
 580 006e FC91      		ld r31,X
 581 0070 1297      		sbiw r26,1+1
 582 0072 8680      		ldd r8,Z+6
 583 0074 9780      		ldd r9,Z+7
 584               	.LBE8:
2039:../../freeRtos/Source/tasks.c **** 		do
2040:../../freeRtos/Source/tasks.c **** 		{
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2042:../../freeRtos/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2043:../../freeRtos/Source/tasks.c **** 			{
2044:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2045:../../freeRtos/Source/tasks.c **** 			}
2046:../../freeRtos/Source/tasks.c **** 			#else
2047:../../freeRtos/Source/tasks.c **** 			{
2048:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2049:../../freeRtos/Source/tasks.c **** 			}
2050:../../freeRtos/Source/tasks.c **** 			#endif			
2051:../../freeRtos/Source/tasks.c **** 			
2052:../../freeRtos/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 586               	.LM6:
 587 0076 442E      		mov r4,r20
 588 0078 5524      		clr r5
 589 007a 47FC      		sbrc r4,7
 590 007c 5094      		com r5
 591 007e 80E0      		ldi r24,lo8(.LC0)
 592 0080 C82E      		mov r12,r24
 593 0082 80E0      		ldi r24,hi8(.LC0)
 594 0084 D82E      		mov r13,r24
 595 0086 90E0      		ldi r25,lo8(pcStatusString)
 596 0088 E92E      		mov r14,r25
 597 008a 90E0      		ldi r25,hi8(pcStatusString)
 598 008c F92E      		mov r15,r25
 599               	.L9:
 600               	.LBB9:
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 602               	.LM7:
 603 008e D101      		movw r26,r2
 604 0090 1196      		adiw r26,1
 605 0092 ED91      		ld r30,X+
 606 0094 FC91      		ld r31,X
 607 0096 1297      		sbiw r26,1+1
 608 0098 8281      		ldd r24,Z+2
 609 009a 9381      		ldd r25,Z+3
 610 009c 1196      		adiw r26,1
 611 009e 8D93      		st X+,r24
 612 00a0 9C93      		st X,r25
 613 00a2 1297      		sbiw r26,1+1
 614 00a4 8615      		cp r24,r6
 615 00a6 9705      		cpc r25,r7
 616 00a8 01F4      		brne .L5
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 618               	.LM8:
 619 00aa F301      		movw r30,r6
 620 00ac 8281      		ldd r24,Z+2
 621 00ae 9381      		ldd r25,Z+3
 622 00b0 1196      		adiw r26,1
 623 00b2 8D93      		st X+,r24
 624 00b4 9C93      		st X,r25
 625 00b6 1297      		sbiw r26,1+1
 626               	.L5:
2041:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 628               	.LM9:
 629 00b8 D101      		movw r26,r2
 630 00ba 1196      		adiw r26,1
 631 00bc ED91      		ld r30,X+
 632 00be FC91      		ld r31,X
 633 00c0 1297      		sbiw r26,1+1
 634 00c2 0681      		ldd r16,Z+6
 635 00c4 1781      		ldd r17,Z+7
 636               	.LBE9:
2048:../../freeRtos/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 638               	.LM10:
 639 00c6 F801      		movw r30,r16
 640 00c8 2789      		ldd r18,Z+23
 641 00ca 308D      		ldd r19,Z+24
 642 00cc F901      		movw r30,r18
 643               	.L6:
 644 00ce CF01      		movw r24,r30
 645 00d0 821B      		sub r24,r18
 646 00d2 930B      		sbc r25,r19
 647               	.LBB10:
 648               	.LBB11:
2053:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2054:../../freeRtos/Source/tasks.c **** 
2055:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2056:../../freeRtos/Source/tasks.c **** 	}
2057:../../freeRtos/Source/tasks.c **** 
2058:../../freeRtos/Source/tasks.c **** #endif
2059:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2060:../../freeRtos/Source/tasks.c **** 
2061:../../freeRtos/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2062:../../freeRtos/Source/tasks.c **** 
2063:../../freeRtos/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2064:../../freeRtos/Source/tasks.c **** 	{
2065:../../freeRtos/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2066:../../freeRtos/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2067:../../freeRtos/Source/tasks.c **** 
2068:../../freeRtos/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2069:../../freeRtos/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2070:../../freeRtos/Source/tasks.c **** 		do
2071:../../freeRtos/Source/tasks.c **** 		{
2072:../../freeRtos/Source/tasks.c **** 			/* Get next TCB in from the list. */
2073:../../freeRtos/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2074:../../freeRtos/Source/tasks.c **** 
2075:../../freeRtos/Source/tasks.c **** 			/* Divide by zero check. */
2076:../../freeRtos/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2077:../../freeRtos/Source/tasks.c **** 			{
2078:../../freeRtos/Source/tasks.c **** 				/* Has the task run at all? */
2079:../../freeRtos/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0 )
2080:../../freeRtos/Source/tasks.c **** 				{
2081:../../freeRtos/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2082:../../freeRtos/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2083:../../freeRtos/Source/tasks.c **** 				}
2084:../../freeRtos/Source/tasks.c **** 				else
2085:../../freeRtos/Source/tasks.c **** 				{
2086:../../freeRtos/Source/tasks.c **** 					/* What percentage of the total run time as the task used?
2087:../../freeRtos/Source/tasks.c **** 					This will always be rounded down to the nearest integer. */
2088:../../freeRtos/Source/tasks.c **** 					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
2089:../../freeRtos/Source/tasks.c **** 
2090:../../freeRtos/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2091:../../freeRtos/Source/tasks.c **** 					{
2092:../../freeRtos/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2093:../../freeRtos/Source/tasks.c **** 					}
2094:../../freeRtos/Source/tasks.c **** 					else
2095:../../freeRtos/Source/tasks.c **** 					{
2096:../../freeRtos/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2097:../../freeRtos/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2098:../../freeRtos/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2099:../../freeRtos/Source/tasks.c **** 					}
2100:../../freeRtos/Source/tasks.c **** 				}
2101:../../freeRtos/Source/tasks.c **** 
2102:../../freeRtos/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2103:../../freeRtos/Source/tasks.c **** 			}
2104:../../freeRtos/Source/tasks.c **** 
2105:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2106:../../freeRtos/Source/tasks.c **** 	}
2107:../../freeRtos/Source/tasks.c **** 
2108:../../freeRtos/Source/tasks.c **** #endif
2109:../../freeRtos/Source/tasks.c **** /*-----------------------------------------------------------*/
2110:../../freeRtos/Source/tasks.c **** 
2111:../../freeRtos/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2112:../../freeRtos/Source/tasks.c **** 
2113:../../freeRtos/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2114:../../freeRtos/Source/tasks.c **** 	{
2115:../../freeRtos/Source/tasks.c **** 	register unsigned short usCount = 0;
2116:../../freeRtos/Source/tasks.c **** 
2117:../../freeRtos/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 650               	.LM11:
 651 00d4 5191      		ld r21,Z+
 652 00d6 553A      		cpi r21,lo8(-91)
 653 00d8 01F0      		breq .L6
 654               	.LBE11:
 655               	.LBE10:
2052:../../freeRtos/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 657               	.LM12:
 658 00da D801      		movw r26,r16
 659 00dc 9396      		adiw r26,35
 660 00de 3C91      		ld r19,X
 661 00e0 9397      		sbiw r26,35
 662 00e2 5696      		adiw r26,22
 663 00e4 2C91      		ld r18,X
 664 00e6 1F92      		push __zero_reg__
 665 00e8 3F93      		push r19
 666 00ea 9F93      		push r25
 667 00ec 8F93      		push r24
 668 00ee 1F92      		push __zero_reg__
 669 00f0 2F93      		push r18
 670 00f2 5F92      		push r5
 671 00f4 4F93      		push r20
 672 00f6 C801      		movw r24,r16
 673 00f8 4996      		adiw r24,25
 674 00fa 9F93      		push r25
 675 00fc 8F93      		push r24
 676 00fe DF92      		push r13
 677 0100 CF92      		push r12
 678 0102 FF92      		push r15
 679 0104 EF92      		push r14
 680 0106 4983      		std Y+1,r20
 681 0108 0E94 0000 		call sprintf
2053:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 683               	.LM13:
 684 010c 60E0      		ldi r22,lo8(pcStatusString)
 685 010e 70E0      		ldi r23,hi8(pcStatusString)
 686 0110 C501      		movw r24,r10
 687 0112 0E94 0000 		call strcat
2055:../../freeRtos/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 689               	.LM14:
 690 0116 CDBF      		out __SP_L__,r28
 691 0118 DEBF      		out __SP_H__,r29
 692 011a 4981      		ldd r20,Y+1
 693 011c 0815      		cp r16,r8
 694 011e 1905      		cpc r17,r9
 695 0120 01F0      		breq .+2
 696 0122 00C0      		rjmp .L9
 697               	/* epilogue start */
2056:../../freeRtos/Source/tasks.c **** 	}
 699               	.LM15:
 700 0124 0F90      		pop __tmp_reg__
 701 0126 DF91      		pop r29
 702 0128 CF91      		pop r28
 703 012a 1F91      		pop r17
 704 012c 0F91      		pop r16
 705 012e FF90      		pop r15
 706 0130 EF90      		pop r14
 707 0132 DF90      		pop r13
 708 0134 CF90      		pop r12
 709 0136 BF90      		pop r11
 710 0138 AF90      		pop r10
 711 013a 9F90      		pop r9
 712 013c 8F90      		pop r8
 713 013e 7F90      		pop r7
 714 0140 6F90      		pop r6
 715 0142 5F90      		pop r5
 716 0144 4F90      		pop r4
 717 0146 3F90      		pop r3
 718 0148 2F90      		pop r2
 719 014a 0895      		ret
 726               	.Lscope2:
 728               		.stabd	78,0,0
 738               	.global	xTaskGenericCreate
 740               	xTaskGenericCreate:
 741               		.stabd	46,0,0
 387:../../freeRtos/Source/tasks.c **** {
 743               	.LM16:
 744               	.LFBB3:
 745 014c 4F92      		push r4
 746 014e 5F92      		push r5
 747 0150 6F92      		push r6
 748 0152 7F92      		push r7
 749 0154 8F92      		push r8
 750 0156 9F92      		push r9
 751 0158 AF92      		push r10
 752 015a BF92      		push r11
 753 015c CF92      		push r12
 754 015e DF92      		push r13
 755 0160 EF92      		push r14
 756 0162 FF92      		push r15
 757 0164 0F93      		push r16
 758 0166 1F93      		push r17
 759 0168 CF93      		push r28
 760 016a DF93      		push r29
 761               	/* prologue: function */
 762               	/* frame size = 0 */
 763               	/* stack size = 16 */
 764               	.L__stack_usage = 16
 765 016c 2C01      		movw r4,r24
 766 016e 3B01      		movw r6,r22
 767 0170 5A01      		movw r10,r20
 768 0172 4901      		movw r8,r18
 769               	.LBB19:
 770               	.LBB20:
2004:../../freeRtos/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 772               	.LM17:
 773 0174 84E2      		ldi r24,lo8(36)
 774 0176 90E0      		ldi r25,0
 775 0178 0E94 0000 		call pvPortMalloc
 776 017c EC01      		movw r28,r24
2006:../../freeRtos/Source/tasks.c **** 	if( pxNewTCB != NULL )
 778               	.LM18:
 779 017e 0097      		sbiw r24,0
 780 0180 01F4      		brne .+2
 781 0182 00C0      		rjmp .L13
2011:../../freeRtos/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 783               	.LM19:
 784 0184 C114      		cp r12,__zero_reg__
 785 0186 D104      		cpc r13,__zero_reg__
 786 0188 01F4      		brne .L23
 787 018a C501      		movw r24,r10
 788 018c 0E94 0000 		call pvPortMalloc
 789 0190 00C0      		rjmp .L14
 790               	.L23:
 791 0192 C601      		movw r24,r12
 792               	.L14:
 793 0194 8F8B      		std Y+23,r24
 794 0196 988F      		std Y+24,r25
2013:../../freeRtos/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 796               	.LM20:
 797 0198 0097      		sbiw r24,0
 798 019a 01F4      		brne .L15
2016:../../freeRtos/Source/tasks.c **** 			vPortFree( pxNewTCB );
 800               	.LM21:
 801 019c CE01      		movw r24,r28
 802 019e 0E94 0000 		call vPortFree
 803 01a2 00C0      		rjmp .L13
 804               	.L15:
2022:../../freeRtos/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 806               	.LM22:
 807 01a4 A501      		movw r20,r10
 808 01a6 65EA      		ldi r22,lo8(-91)
 809 01a8 70E0      		ldi r23,0
 810 01aa 0E94 0000 		call memset
 811               	.LBE20:
 812               	.LBE19:
 813               	.LBB21:
 419:../../freeRtos/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 815               	.LM23:
 816 01ae 21E0      		ldi r18,1
 817 01b0 A21A      		sub r10,r18
 818 01b2 B108      		sbc r11,__zero_reg__
 819 01b4 CF88      		ldd r12,Y+23
 820 01b6 D88C      		ldd r13,Y+24
 821 01b8 CA0C      		add r12,r10
 822 01ba DB1C      		adc r13,r11
 823               	.LBB22:
 824               	.LBB23:
1851:../../freeRtos/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 826               	.LM24:
 827 01bc 4AE0      		ldi r20,lo8(10)
 828 01be 50E0      		ldi r21,0
 829 01c0 B301      		movw r22,r6
 830 01c2 CE01      		movw r24,r28
 831 01c4 4996      		adiw r24,25
 832 01c6 0E94 0000 		call strncpy
1854:../../freeRtos/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 834               	.LM25:
 835 01ca 1AA2      		std Y+34,__zero_reg__
 836 01cc 102F      		mov r17,r16
 837 01ce 0330      		cpi r16,lo8(3)
 838 01d0 00F0      		brlo .L16
 839 01d2 12E0      		ldi r17,lo8(2)
 840               	.L16:
1863:../../freeRtos/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 842               	.LM26:
 843 01d4 1E8B      		std Y+22,r17
1870:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 845               	.LM27:
 846 01d6 5E01      		movw r10,r28
 847 01d8 82E0      		ldi r24,2
 848 01da A80E      		add r10,r24
 849 01dc B11C      		adc r11,__zero_reg__
 850 01de C501      		movw r24,r10
 851 01e0 0E94 0000 		call vListInitialiseItem
1871:../../freeRtos/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 853               	.LM28:
 854 01e4 CE01      		movw r24,r28
 855 01e6 0C96      		adiw r24,12
 856 01e8 0E94 0000 		call vListInitialiseItem
1875:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 858               	.LM29:
 859 01ec C887      		std Y+8,r28
 860 01ee D987      		std Y+9,r29
1878:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 862               	.LM30:
 863 01f0 83E0      		ldi r24,lo8(3)
 864 01f2 90E0      		ldi r25,0
 865 01f4 811B      		sub r24,r17
 866 01f6 9109      		sbc r25,__zero_reg__
 867 01f8 8C87      		std Y+12,r24
 868 01fa 9D87      		std Y+13,r25
1879:../../freeRtos/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 870               	.LM31:
 871 01fc CA8B      		std Y+18,r28
 872 01fe DB8B      		std Y+19,r29
 873               	.LBE23:
 874               	.LBE22:
 447:../../freeRtos/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 876               	.LM32:
 877 0200 A401      		movw r20,r8
 878 0202 B201      		movw r22,r4
 879 0204 C601      		movw r24,r12
 880 0206 0E94 0000 		call pxPortInitialiseStack
 881 020a 8883      		st Y,r24
 882 020c 9983      		std Y+1,r25
 453:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 884               	.LM33:
 885               	/* #APP */
 886               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 887 020e 0FB6      		in		__tmp_reg__, __SREG__
 888               	 ;  0 "" 2
 889               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 890 0210 F894      		cli
 891               	 ;  0 "" 2
 892               	 ;  453 "../../freeRtos/Source/tasks.c" 1
 893 0212 0F92      		push	__tmp_reg__
 894               	 ;  0 "" 2
 455:../../freeRtos/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 896               	.LM34:
 897               	/* #NOAPP */
 898 0214 8091 0000 		lds r24,uxCurrentNumberOfTasks
 899 0218 8F5F      		subi r24,lo8(-(1))
 900 021a 8093 0000 		sts uxCurrentNumberOfTasks,r24
 456:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 902               	.LM35:
 903 021e 8091 0000 		lds r24,uxCurrentNumberOfTasks
 904 0222 8130      		cpi r24,lo8(1)
 905 0224 01F4      		brne .L17
 459:../../freeRtos/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 907               	.LM36:
 908 0226 C093 0000 		sts pxCurrentTCB,r28
 909 022a D093 0000 		sts pxCurrentTCB+1,r29
 910               	.LBB24:
 911               	.LBB25:
1937:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 913               	.LM37:
 914 022e 80E0      		ldi r24,lo8(pxReadyTasksLists)
 915 0230 90E0      		ldi r25,hi8(pxReadyTasksLists)
 916 0232 0E94 0000 		call vListInitialise
 917 0236 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 918 0238 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 919 023a 0E94 0000 		call vListInitialise
 920 023e 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 921 0240 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 922 0242 0E94 0000 		call vListInitialise
1940:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 924               	.LM38:
 925 0246 80E0      		ldi r24,lo8(xDelayedTaskList1)
 926 0248 90E0      		ldi r25,hi8(xDelayedTaskList1)
 927 024a 0E94 0000 		call vListInitialise
1941:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 929               	.LM39:
 930 024e 80E0      		ldi r24,lo8(xDelayedTaskList2)
 931 0250 90E0      		ldi r25,hi8(xDelayedTaskList2)
 932 0252 0E94 0000 		call vListInitialise
1942:../../freeRtos/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 934               	.LM40:
 935 0256 80E0      		ldi r24,lo8(xPendingReadyList)
 936 0258 90E0      		ldi r25,hi8(xPendingReadyList)
 937 025a 0E94 0000 		call vListInitialise
1952:../../freeRtos/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 939               	.LM41:
 940 025e 80E0      		ldi r24,lo8(xSuspendedTaskList)
 941 0260 90E0      		ldi r25,hi8(xSuspendedTaskList)
 942 0262 0E94 0000 		call vListInitialise
1958:../../freeRtos/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 944               	.LM42:
 945 0266 80E0      		ldi r24,lo8(xDelayedTaskList1)
 946 0268 90E0      		ldi r25,hi8(xDelayedTaskList1)
 947 026a 8093 0000 		sts pxDelayedTaskList,r24
 948 026e 9093 0000 		sts pxDelayedTaskList+1,r25
1959:../../freeRtos/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 950               	.LM43:
 951 0272 80E0      		ldi r24,lo8(xDelayedTaskList2)
 952 0274 90E0      		ldi r25,hi8(xDelayedTaskList2)
 953 0276 8093 0000 		sts pxOverflowDelayedTaskList,r24
 954 027a 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 955 027e 00C0      		rjmp .L18
 956               	.L17:
 957               	.LBE25:
 958               	.LBE24:
 471:../../freeRtos/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 960               	.LM44:
 961 0280 8091 0000 		lds r24,xSchedulerRunning
 962 0284 8111      		cpse r24,__zero_reg__
 963 0286 00C0      		rjmp .L18
 473:../../freeRtos/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 965               	.LM45:
 966 0288 E091 0000 		lds r30,pxCurrentTCB
 967 028c F091 0000 		lds r31,pxCurrentTCB+1
 968 0290 8689      		ldd r24,Z+22
 969 0292 0817      		cp r16,r24
 970 0294 00F0      		brlo .L18
 475:../../freeRtos/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 972               	.LM46:
 973 0296 C093 0000 		sts pxCurrentTCB,r28
 974 029a D093 0000 		sts pxCurrentTCB+1,r29
 975               	.L18:
 482:../../freeRtos/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 977               	.LM47:
 978 029e 8E89      		ldd r24,Y+22
 979 02a0 9091 0000 		lds r25,uxTopUsedPriority
 980 02a4 9817      		cp r25,r24
 981 02a6 00F4      		brsh .L19
 484:../../freeRtos/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 983               	.LM48:
 984 02a8 8093 0000 		sts uxTopUsedPriority,r24
 985               	.L19:
 490:../../freeRtos/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 987               	.LM49:
 988 02ac 9091 0000 		lds r25,uxTaskNumber
 989 02b0 9BA3      		std Y+35,r25
 493:../../freeRtos/Source/tasks.c **** 			uxTaskNumber++;
 991               	.LM50:
 992 02b2 9F5F      		subi r25,lo8(-(1))
 993 02b4 9093 0000 		sts uxTaskNumber,r25
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 995               	.LM51:
 996 02b8 9091 0000 		lds r25,uxTopReadyPriority
 997 02bc 9817      		cp r25,r24
 998 02be 00F4      		brsh .L20
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 1000               	.LM52:
 1001 02c0 8093 0000 		sts uxTopReadyPriority,r24
 1002               	.L20:
 495:../../freeRtos/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 1004               	.LM53:
 1005 02c4 E9E0      		ldi r30,lo8(9)
 1006 02c6 8E9F      		mul r24,r30
 1007 02c8 C001      		movw r24,r0
 1008 02ca 1124      		clr __zero_reg__
 1009 02cc B501      		movw r22,r10
 1010 02ce 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1011 02d0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1012 02d2 0E94 0000 		call vListInsertEnd
 500:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1014               	.LM54:
 1015               	/* #APP */
 1016               	 ;  500 "../../freeRtos/Source/tasks.c" 1
 1017 02d6 0F90      		pop		__tmp_reg__
 1018               	 ;  0 "" 2
 1019               	 ;  500 "../../freeRtos/Source/tasks.c" 1
 1020 02d8 0FBE      		out		__SREG__, __tmp_reg__
 1021               	 ;  0 "" 2
 1022               	/* #NOAPP */
 1023               	.LBE21:
 510:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 1025               	.LM55:
 1026 02da E114      		cp r14,__zero_reg__
 1027 02dc F104      		cpc r15,__zero_reg__
 1028 02de 01F0      		breq .L21
 515:../../freeRtos/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 1030               	.LM56:
 1031 02e0 F701      		movw r30,r14
 1032 02e2 C083      		st Z,r28
 1033 02e4 D183      		std Z+1,r29
 1034               	.L21:
 518:../../freeRtos/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 1036               	.LM57:
 1037 02e6 8091 0000 		lds r24,xSchedulerRunning
 1038 02ea 8823      		tst r24
 1039 02ec 01F0      		breq .L25
 522:../../freeRtos/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 1041               	.LM58:
 1042 02ee E091 0000 		lds r30,pxCurrentTCB
 1043 02f2 F091 0000 		lds r31,pxCurrentTCB+1
 1044 02f6 8689      		ldd r24,Z+22
 1045 02f8 8017      		cp r24,r16
 1046 02fa 00F4      		brsh .L25
 524:../../freeRtos/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1048               	.LM59:
 1049 02fc 0E94 0000 		call vPortYield
 1050               	.L25:
 1051               	.LBB26:
 497:../../freeRtos/Source/tasks.c **** 			xReturn = pdPASS;
 1053               	.LM60:
 1054 0300 81E0      		ldi r24,lo8(1)
 1055 0302 00C0      		rjmp .L32
 1056               	.L13:
 1057               	.LBE26:
 504:../../freeRtos/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 1059               	.LM61:
 1060 0304 8FEF      		ldi r24,lo8(-1)
 1061               	.L32:
 1062               	/* epilogue start */
 530:../../freeRtos/Source/tasks.c **** }
 1064               	.LM62:
 1065 0306 DF91      		pop r29
 1066 0308 CF91      		pop r28
 1067 030a 1F91      		pop r17
 1068 030c 0F91      		pop r16
 1069 030e FF90      		pop r15
 1070 0310 EF90      		pop r14
 1071 0312 DF90      		pop r13
 1072 0314 CF90      		pop r12
 1073 0316 BF90      		pop r11
 1074 0318 AF90      		pop r10
 1075 031a 9F90      		pop r9
 1076 031c 8F90      		pop r8
 1077 031e 7F90      		pop r7
 1078 0320 6F90      		pop r6
 1079 0322 5F90      		pop r5
 1080 0324 4F90      		pop r4
 1081 0326 0895      		ret
 1093               	.Lscope3:
 1095               		.stabd	78,0,0
 1098               	.global	uxTaskPriorityGet
 1100               	uxTaskPriorityGet:
 1101               		.stabd	46,0,0
 740:../../freeRtos/Source/tasks.c **** 	{
 1103               	.LM63:
 1104               	.LFBB4:
 1105               	/* prologue: function */
 1106               	/* frame size = 0 */
 1107               	/* stack size = 0 */
 1108               	.L__stack_usage = 0
 744:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1110               	.LM64:
 1111               	/* #APP */
 1112               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 1113 0328 0FB6      		in		__tmp_reg__, __SREG__
 1114               	 ;  0 "" 2
 1115               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 1116 032a F894      		cli
 1117               	 ;  0 "" 2
 1118               	 ;  744 "../../freeRtos/Source/tasks.c" 1
 1119 032c 0F92      		push	__tmp_reg__
 1120               	 ;  0 "" 2
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1122               	.LM65:
 1123               	/* #NOAPP */
 1124 032e 0097      		sbiw r24,0
 1125 0330 01F4      		brne .L34
 748:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1127               	.LM66:
 1128 0332 8091 0000 		lds r24,pxCurrentTCB
 1129 0336 9091 0000 		lds r25,pxCurrentTCB+1
 1130               	.L34:
 751:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1132               	.LM67:
 1133               	/* #APP */
 1134               	 ;  751 "../../freeRtos/Source/tasks.c" 1
 1135 033a 0F90      		pop		__tmp_reg__
 1136               	 ;  0 "" 2
 1137               	 ;  751 "../../freeRtos/Source/tasks.c" 1
 1138 033c 0FBE      		out		__SREG__, __tmp_reg__
 1139               	 ;  0 "" 2
 754:../../freeRtos/Source/tasks.c **** 	}
 1141               	.LM68:
 1142               	/* #NOAPP */
 1143 033e FC01      		movw r30,r24
 1144 0340 8689      		ldd r24,Z+22
 1145 0342 0895      		ret
 1147               	.Lscope4:
 1149               		.stabd	78,0,0
 1153               	.global	vTaskPrioritySet
 1155               	vTaskPrioritySet:
 1156               		.stabd	46,0,0
 762:../../freeRtos/Source/tasks.c **** 	{
 1158               	.LM69:
 1159               	.LFBB5:
 1160 0344 FF92      		push r15
 1161 0346 0F93      		push r16
 1162 0348 1F93      		push r17
 1163 034a CF93      		push r28
 1164 034c DF93      		push r29
 1165               	/* prologue: function */
 1166               	/* frame size = 0 */
 1167               	/* stack size = 5 */
 1168               	.L__stack_usage = 5
 1169 034e EC01      		movw r28,r24
 1170 0350 6330      		cpi r22,lo8(3)
 1171 0352 00F0      		brlo .L36
 1172 0354 62E0      		ldi r22,lo8(2)
 1173               	.L36:
 772:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1175               	.LM70:
 1176               	/* #APP */
 1177               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 1178 0356 0FB6      		in		__tmp_reg__, __SREG__
 1179               	 ;  0 "" 2
 1180               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 1181 0358 F894      		cli
 1182               	 ;  0 "" 2
 1183               	 ;  772 "../../freeRtos/Source/tasks.c" 1
 1184 035a 0F92      		push	__tmp_reg__
 1185               	 ;  0 "" 2
 774:../../freeRtos/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 1187               	.LM71:
 1188               	/* #NOAPP */
 1189 035c 8091 0000 		lds r24,pxCurrentTCB
 1190 0360 9091 0000 		lds r25,pxCurrentTCB+1
 1191 0364 C817      		cp r28,r24
 1192 0366 D907      		cpc r29,r25
 1193 0368 01F0      		breq .L37
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1195               	.LM72:
 1196 036a 2097      		sbiw r28,0
 1197 036c 01F4      		brne .L48
 1198               	.L37:
 781:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 1200               	.LM73:
 1201 036e C091 0000 		lds r28,pxCurrentTCB
 1202 0372 D091 0000 		lds r29,pxCurrentTCB+1
 1203 0376 20E0      		ldi r18,0
 1204 0378 30E0      		ldi r19,0
 1205 037a 00C0      		rjmp .L38
 1206               	.L48:
 1207 037c 9E01      		movw r18,r28
 1208               	.L38:
 791:../../freeRtos/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 1210               	.LM74:
 1211 037e 8E89      		ldd r24,Y+22
 795:../../freeRtos/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 1213               	.LM75:
 1214 0380 8617      		cp r24,r22
 1215 0382 01F0      		breq .L40
 801:../../freeRtos/Source/tasks.c **** 					if( pxTask != NULL )
 1217               	.LM76:
 1218 0384 FF24      		clr r15
 1219 0386 F394      		inc r15
 799:../../freeRtos/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 1221               	.LM77:
 1222 0388 8617      		cp r24,r22
 1223 038a 00F4      		brsh .L41
 801:../../freeRtos/Source/tasks.c **** 					if( pxTask != NULL )
 1225               	.LM78:
 1226 038c 232B      		or r18,r19
 1227 038e 01F4      		brne .L43
 1228 0390 00C0      		rjmp .L52
 1229               	.L41:
 810:../../freeRtos/Source/tasks.c **** 				else if( pxTask == NULL )
 1231               	.LM79:
 1232 0392 232B      		or r18,r19
 1233 0394 01F0      		breq .L43
 1234               	.L52:
 1235 0396 F12C      		mov r15,__zero_reg__
 1236               	.L43:
 833:../../freeRtos/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 1238               	.LM80:
 1239 0398 6E8B      		std Y+22,r22
 837:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 1241               	.LM81:
 1242 039a 23E0      		ldi r18,lo8(3)
 1243 039c 30E0      		ldi r19,0
 1244 039e 261B      		sub r18,r22
 1245 03a0 3109      		sbc r19,__zero_reg__
 1246 03a2 2C87      		std Y+12,r18
 1247 03a4 3D87      		std Y+13,r19
 843:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 1249               	.LM82:
 1250 03a6 29E0      		ldi r18,lo8(9)
 1251 03a8 829F      		mul r24,r18
 1252 03aa C001      		movw r24,r0
 1253 03ac 1124      		clr __zero_reg__
 1254 03ae 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1255 03b0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1256 03b2 2A85      		ldd r18,Y+10
 1257 03b4 3B85      		ldd r19,Y+11
 1258 03b6 2817      		cp r18,r24
 1259 03b8 3907      		cpc r19,r25
 1260 03ba 01F4      		brne .L45
 848:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1262               	.LM83:
 1263 03bc 8E01      		movw r16,r28
 1264 03be 0E5F      		subi r16,-2
 1265 03c0 1F4F      		sbci r17,-1
 1266 03c2 C801      		movw r24,r16
 1267 03c4 0E94 0000 		call vListRemove
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1269               	.LM84:
 1270 03c8 8E89      		ldd r24,Y+22
 1271 03ca 9091 0000 		lds r25,uxTopReadyPriority
 1272 03ce 9817      		cp r25,r24
 1273 03d0 00F4      		brsh .L46
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1275               	.LM85:
 1276 03d2 8093 0000 		sts uxTopReadyPriority,r24
 1277               	.L46:
 849:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1279               	.LM86:
 1280 03d6 29E0      		ldi r18,lo8(9)
 1281 03d8 829F      		mul r24,r18
 1282 03da C001      		movw r24,r0
 1283 03dc 1124      		clr __zero_reg__
 1284 03de B801      		movw r22,r16
 1285 03e0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1286 03e2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1287 03e4 0E94 0000 		call vListInsertEnd
 1288               	.L45:
 852:../../freeRtos/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 1290               	.LM87:
 1291 03e8 81E0      		ldi r24,lo8(1)
 1292 03ea F812      		cpse r15,r24
 1293 03ec 00C0      		rjmp .L40
 854:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1295               	.LM88:
 1296 03ee 0E94 0000 		call vPortYield
 1297               	.L40:
 858:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1299               	.LM89:
 1300               	/* #APP */
 1301               	 ;  858 "../../freeRtos/Source/tasks.c" 1
 1302 03f2 0F90      		pop		__tmp_reg__
 1303               	 ;  0 "" 2
 1304               	 ;  858 "../../freeRtos/Source/tasks.c" 1
 1305 03f4 0FBE      		out		__SREG__, __tmp_reg__
 1306               	 ;  0 "" 2
 1307               	/* epilogue start */
 859:../../freeRtos/Source/tasks.c **** 	}
 1309               	.LM90:
 1310               	/* #NOAPP */
 1311 03f6 DF91      		pop r29
 1312 03f8 CF91      		pop r28
 1313 03fa 1F91      		pop r17
 1314 03fc 0F91      		pop r16
 1315 03fe FF90      		pop r15
 1316 0400 0895      		ret
 1322               	.Lscope5:
 1324               		.stabd	78,0,0
 1327               	.global	vTaskSuspend
 1329               	vTaskSuspend:
 1330               		.stabd	46,0,0
 867:../../freeRtos/Source/tasks.c **** 	{
 1332               	.LM91:
 1333               	.LFBB6:
 1334 0402 EF92      		push r14
 1335 0404 FF92      		push r15
 1336 0406 0F93      		push r16
 1337 0408 1F93      		push r17
 1338 040a CF93      		push r28
 1339 040c DF93      		push r29
 1340               	/* prologue: function */
 1341               	/* frame size = 0 */
 1342               	/* stack size = 6 */
 1343               	.L__stack_usage = 6
 1344 040e EC01      		movw r28,r24
 870:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1346               	.LM92:
 1347               	/* #APP */
 1348               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1349 0410 0FB6      		in		__tmp_reg__, __SREG__
 1350               	 ;  0 "" 2
 1351               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1352 0412 F894      		cli
 1353               	 ;  0 "" 2
 1354               	 ;  870 "../../freeRtos/Source/tasks.c" 1
 1355 0414 0F92      		push	__tmp_reg__
 1356               	 ;  0 "" 2
 874:../../freeRtos/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1358               	.LM93:
 1359               	/* #NOAPP */
 1360 0416 8091 0000 		lds r24,pxCurrentTCB
 1361 041a 9091 0000 		lds r25,pxCurrentTCB+1
 1362 041e C817      		cp r28,r24
 1363 0420 D907      		cpc r29,r25
 1364 0422 01F0      		breq .L54
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1366               	.LM94:
 1367 0424 2097      		sbiw r28,0
 1368 0426 01F4      		brne .L58
 1369               	.L54:
 880:../../freeRtos/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1371               	.LM95:
 1372 0428 0091 0000 		lds r16,pxCurrentTCB
 1373 042c 1091 0000 		lds r17,pxCurrentTCB+1
 1374 0430 C0E0      		ldi r28,0
 1375 0432 D0E0      		ldi r29,0
 1376 0434 00C0      		rjmp .L55
 1377               	.L58:
 1378 0436 8E01      		movw r16,r28
 1379               	.L55:
 885:../../freeRtos/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1381               	.LM96:
 1382 0438 7801      		movw r14,r16
 1383 043a 82E0      		ldi r24,2
 1384 043c E80E      		add r14,r24
 1385 043e F11C      		adc r15,__zero_reg__
 1386 0440 C701      		movw r24,r14
 1387 0442 0E94 0000 		call vListRemove
 888:../../freeRtos/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 1389               	.LM97:
 1390 0446 F801      		movw r30,r16
 1391 0448 8489      		ldd r24,Z+20
 1392 044a 9589      		ldd r25,Z+21
 1393 044c 892B      		or r24,r25
 1394 044e 01F0      		breq .L56
 890:../../freeRtos/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1396               	.LM98:
 1397 0450 C801      		movw r24,r16
 1398 0452 0C96      		adiw r24,12
 1399 0454 0E94 0000 		call vListRemove
 1400               	.L56:
 893:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1402               	.LM99:
 1403 0458 B701      		movw r22,r14
 1404 045a 80E0      		ldi r24,lo8(xSuspendedTaskList)
 1405 045c 90E0      		ldi r25,hi8(xSuspendedTaskList)
 1406 045e 0E94 0000 		call vListInsertEnd
 895:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1408               	.LM100:
 1409               	/* #APP */
 1410               	 ;  895 "../../freeRtos/Source/tasks.c" 1
 1411 0462 0F90      		pop		__tmp_reg__
 1412               	 ;  0 "" 2
 1413               	 ;  895 "../../freeRtos/Source/tasks.c" 1
 1414 0464 0FBE      		out		__SREG__, __tmp_reg__
 1415               	 ;  0 "" 2
 898:../../freeRtos/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1417               	.LM101:
 1418               	/* #NOAPP */
 1419 0466 CD2B      		or r28,r29
 1420 0468 01F4      		brne .L53
 900:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1422               	.LM102:
 1423 046a 0E94 0000 		call vPortYield
 1424               	.L53:
 1425               	/* epilogue start */
 902:../../freeRtos/Source/tasks.c **** 	}
 1427               	.LM103:
 1428 046e DF91      		pop r29
 1429 0470 CF91      		pop r28
 1430 0472 1F91      		pop r17
 1431 0474 0F91      		pop r16
 1432 0476 FF90      		pop r15
 1433 0478 EF90      		pop r14
 1434 047a 0895      		ret
 1436               	.Lscope6:
 1438               		.stabd	78,0,0
 1441               	.global	xTaskIsTaskSuspended
 1443               	xTaskIsTaskSuspended:
 1444               		.stabd	46,0,0
 910:../../freeRtos/Source/tasks.c **** 	{
 1446               	.LM104:
 1447               	.LFBB7:
 1448               	/* prologue: function */
 1449               	/* frame size = 0 */
 1450               	/* stack size = 0 */
 1451               	.L__stack_usage = 0
 916:../../freeRtos/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1453               	.LM105:
 1454 047c FC01      		movw r30,r24
 1455 047e 2285      		ldd r18,Z+10
 1456 0480 3385      		ldd r19,Z+11
 1457 0482 2050      		subi r18,lo8(xSuspendedTaskList)
 1458 0484 3040      		sbci r19,hi8(xSuspendedTaskList)
 1459 0486 01F4      		brne .L66
 1460               	.LBB29:
 1461               	.LBB30:
 919:../../freeRtos/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1463               	.LM106:
 1464 0488 FC01      		movw r30,r24
 1465 048a 2489      		ldd r18,Z+20
 1466 048c 3589      		ldd r19,Z+21
 1467 048e F0E0      		ldi r31,hi8(xPendingReadyList)
 1468 0490 2030      		cpi r18,lo8(xPendingReadyList)
 1469 0492 3F07      		cpc r19,r31
 1470 0494 01F0      		breq .L66
 925:../../freeRtos/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1472               	.LM107:
 1473 0496 81E0      		ldi r24,lo8(1)
 1474 0498 232B      		or r18,r19
 1475 049a 01F0      		breq .L63
 1476               	.L66:
 1477               	.LBE30:
 1478               	.LBE29:
 911:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1480               	.LM108:
 1481 049c 80E0      		ldi r24,0
 1482               	.L63:
 933:../../freeRtos/Source/tasks.c **** 	}
 1484               	.LM109:
 1485 049e 0895      		ret
 1490               	.Lscope7:
 1492               		.stabd	78,0,0
 1495               	.global	vTaskResume
 1497               	vTaskResume:
 1498               		.stabd	46,0,0
 941:../../freeRtos/Source/tasks.c **** 	{
 1500               	.LM110:
 1501               	.LFBB8:
 1502 04a0 0F93      		push r16
 1503 04a2 1F93      		push r17
 1504 04a4 CF93      		push r28
 1505 04a6 DF93      		push r29
 1506               	/* prologue: function */
 1507               	/* frame size = 0 */
 1508               	/* stack size = 4 */
 1509               	.L__stack_usage = 4
 1510 04a8 EC01      		movw r28,r24
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1512               	.LM111:
 1513 04aa 0097      		sbiw r24,0
 1514 04ac 01F0      		breq .L71
 950:../../freeRtos/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1516               	.LM112:
 1517 04ae 8091 0000 		lds r24,pxCurrentTCB
 1518 04b2 9091 0000 		lds r25,pxCurrentTCB+1
 1519 04b6 C817      		cp r28,r24
 1520 04b8 D907      		cpc r29,r25
 1521 04ba 01F0      		breq .L71
 952:../../freeRtos/Source/tasks.c **** 			portENTER_CRITICAL();
 1523               	.LM113:
 1524               	/* #APP */
 1525               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1526 04bc 0FB6      		in		__tmp_reg__, __SREG__
 1527               	 ;  0 "" 2
 1528               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1529 04be F894      		cli
 1530               	 ;  0 "" 2
 1531               	 ;  952 "../../freeRtos/Source/tasks.c" 1
 1532 04c0 0F92      		push	__tmp_reg__
 1533               	 ;  0 "" 2
 954:../../freeRtos/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1535               	.LM114:
 1536               	/* #NOAPP */
 1537 04c2 CE01      		movw r24,r28
 1538 04c4 0E94 0000 		call xTaskIsTaskSuspended
 1539 04c8 8130      		cpi r24,lo8(1)
 1540 04ca 01F4      		brne .L74
 960:../../freeRtos/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1542               	.LM115:
 1543 04cc 8E01      		movw r16,r28
 1544 04ce 0E5F      		subi r16,-2
 1545 04d0 1F4F      		sbci r17,-1
 1546 04d2 C801      		movw r24,r16
 1547 04d4 0E94 0000 		call vListRemove
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1549               	.LM116:
 1550 04d8 8E89      		ldd r24,Y+22
 1551 04da 9091 0000 		lds r25,uxTopReadyPriority
 1552 04de 9817      		cp r25,r24
 1553 04e0 00F4      		brsh .L75
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1555               	.LM117:
 1556 04e2 8093 0000 		sts uxTopReadyPriority,r24
 1557               	.L75:
 961:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1559               	.LM118:
 1560 04e6 29E0      		ldi r18,lo8(9)
 1561 04e8 829F      		mul r24,r18
 1562 04ea C001      		movw r24,r0
 1563 04ec 1124      		clr __zero_reg__
 1564 04ee B801      		movw r22,r16
 1565 04f0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1566 04f2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1567 04f4 0E94 0000 		call vListInsertEnd
 964:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1569               	.LM119:
 1570 04f8 E091 0000 		lds r30,pxCurrentTCB
 1571 04fc F091 0000 		lds r31,pxCurrentTCB+1
 1572 0500 9E89      		ldd r25,Y+22
 1573 0502 8689      		ldd r24,Z+22
 1574 0504 9817      		cp r25,r24
 1575 0506 00F0      		brlo .L74
 968:../../freeRtos/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1577               	.LM120:
 1578 0508 0E94 0000 		call vPortYield
 1579               	.L74:
 972:../../freeRtos/Source/tasks.c **** 			portEXIT_CRITICAL();
 1581               	.LM121:
 1582               	/* #APP */
 1583               	 ;  972 "../../freeRtos/Source/tasks.c" 1
 1584 050c 0F90      		pop		__tmp_reg__
 1585               	 ;  0 "" 2
 1586               	 ;  972 "../../freeRtos/Source/tasks.c" 1
 1587 050e 0FBE      		out		__SREG__, __tmp_reg__
 1588               	 ;  0 "" 2
 1589               	/* #NOAPP */
 1590               	.L71:
 1591               	/* epilogue start */
 974:../../freeRtos/Source/tasks.c **** 	}
 1593               	.LM122:
 1594 0510 DF91      		pop r29
 1595 0512 CF91      		pop r28
 1596 0514 1F91      		pop r17
 1597 0516 0F91      		pop r16
 1598 0518 0895      		ret
 1600               	.Lscope8:
 1602               		.stabd	78,0,0
 1605               	.global	xTaskResumeFromISR
 1607               	xTaskResumeFromISR:
 1608               		.stabd	46,0,0
 983:../../freeRtos/Source/tasks.c **** 	{
 1610               	.LM123:
 1611               	.LFBB9:
 1612 051a FF92      		push r15
 1613 051c 0F93      		push r16
 1614 051e 1F93      		push r17
 1615 0520 CF93      		push r28
 1616 0522 DF93      		push r29
 1617               	/* prologue: function */
 1618               	/* frame size = 0 */
 1619               	/* stack size = 5 */
 1620               	.L__stack_usage = 5
 1621 0524 EC01      		movw r28,r24
 989:../../freeRtos/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1623               	.LM124:
 1624 0526 0E94 0000 		call xTaskIsTaskSuspended
 1625 052a 8130      		cpi r24,lo8(1)
 1626 052c 01F4      		brne .L85
 993:../../freeRtos/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1628               	.LM125:
 1629 052e 8091 0000 		lds r24,uxSchedulerSuspended
 1630 0532 8111      		cpse r24,__zero_reg__
 1631 0534 00C0      		rjmp .L82
 995:../../freeRtos/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1633               	.LM126:
 1634 0536 E091 0000 		lds r30,pxCurrentTCB
 1635 053a F091 0000 		lds r31,pxCurrentTCB+1
 1636 053e FF24      		clr r15
 1637 0540 F394      		inc r15
 1638 0542 9E89      		ldd r25,Y+22
 1639 0544 8689      		ldd r24,Z+22
 1640 0546 9817      		cp r25,r24
 1641 0548 00F4      		brsh .L83
 1642 054a F12C      		mov r15,__zero_reg__
 1643               	.L83:
 996:../../freeRtos/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1645               	.LM127:
 1646 054c 8E01      		movw r16,r28
 1647 054e 0E5F      		subi r16,-2
 1648 0550 1F4F      		sbci r17,-1
 1649 0552 C801      		movw r24,r16
 1650 0554 0E94 0000 		call vListRemove
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1652               	.LM128:
 1653 0558 2E89      		ldd r18,Y+22
 1654 055a 8091 0000 		lds r24,uxTopReadyPriority
 1655 055e 8217      		cp r24,r18
 1656 0560 00F4      		brsh .L84
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1658               	.LM129:
 1659 0562 2093 0000 		sts uxTopReadyPriority,r18
 1660               	.L84:
 997:../../freeRtos/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1662               	.LM130:
 1663 0566 39E0      		ldi r19,lo8(9)
 1664 0568 239F      		mul r18,r19
 1665 056a C001      		movw r24,r0
 1666 056c 1124      		clr __zero_reg__
 1667 056e B801      		movw r22,r16
 1668 0570 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1669 0572 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1670 0574 0E94 0000 		call vListInsertEnd
 1671 0578 00C0      		rjmp .L81
 1672               	.L82:
1004:../../freeRtos/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1674               	.LM131:
 1675 057a BE01      		movw r22,r28
 1676 057c 645F      		subi r22,-12
 1677 057e 7F4F      		sbci r23,-1
 1678 0580 80E0      		ldi r24,lo8(xPendingReadyList)
 1679 0582 90E0      		ldi r25,hi8(xPendingReadyList)
 1680 0584 0E94 0000 		call vListInsertEnd
 1681               	.L85:
 984:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1683               	.LM132:
 1684 0588 F12C      		mov r15,__zero_reg__
 1685               	.L81:
1009:../../freeRtos/Source/tasks.c **** 	}
 1687               	.LM133:
 1688 058a 8F2D      		mov r24,r15
 1689               	/* epilogue start */
 1690 058c DF91      		pop r29
 1691 058e CF91      		pop r28
 1692 0590 1F91      		pop r17
 1693 0592 0F91      		pop r16
 1694 0594 FF90      		pop r15
 1695 0596 0895      		ret
 1700               	.Lscope9:
 1702               		.stabd	78,0,0
 1703               		.section	.rodata.str1.1
 1704               	.LC1:
 1705 0012 4944 4C45 		.string	"IDLE"
 1705      00
 1706               		.text
 1708               	.global	vTaskStartScheduler
 1710               	vTaskStartScheduler:
 1711               		.stabd	46,0,0
1022:../../freeRtos/Source/tasks.c **** {
 1713               	.LM134:
 1714               	.LFBB10:
 1715 0598 AF92      		push r10
 1716 059a BF92      		push r11
 1717 059c CF92      		push r12
 1718 059e DF92      		push r13
 1719 05a0 EF92      		push r14
 1720 05a2 FF92      		push r15
 1721 05a4 0F93      		push r16
 1722               	/* prologue: function */
 1723               	/* frame size = 0 */
 1724               	/* stack size = 7 */
 1725               	.L__stack_usage = 7
1026:../../freeRtos/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 1727               	.LM135:
 1728 05a6 A12C      		mov r10,__zero_reg__
 1729 05a8 B12C      		mov r11,__zero_reg__
 1730 05aa C12C      		mov r12,__zero_reg__
 1731 05ac D12C      		mov r13,__zero_reg__
 1732 05ae E12C      		mov r14,__zero_reg__
 1733 05b0 F12C      		mov r15,__zero_reg__
 1734 05b2 00E0      		ldi r16,0
 1735 05b4 20E0      		ldi r18,0
 1736 05b6 30E0      		ldi r19,0
 1737 05b8 46E9      		ldi r20,lo8(-106)
 1738 05ba 50E0      		ldi r21,0
 1739 05bc 60E0      		ldi r22,lo8(.LC1)
 1740 05be 70E0      		ldi r23,hi8(.LC1)
 1741 05c0 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1742 05c2 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1743 05c4 0E94 0000 		call xTaskGenericCreate
1028:../../freeRtos/Source/tasks.c **** 	if( xReturn == pdPASS )
 1745               	.LM136:
 1746 05c8 8130      		cpi r24,lo8(1)
 1747 05ca 01F4      		brne .L86
1038:../../freeRtos/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1749               	.LM137:
 1750               	/* #APP */
 1751               	 ;  1038 "../../freeRtos/Source/tasks.c" 1
 1752 05cc F894      		cli
 1753               	 ;  0 "" 2
1040:../../freeRtos/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1755               	.LM138:
 1756               	/* #NOAPP */
 1757 05ce 8093 0000 		sts xSchedulerRunning,r24
1041:../../freeRtos/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
 1759               	.LM139:
 1760 05d2 1092 0000 		sts xTickCount,__zero_reg__
 1761 05d6 1092 0000 		sts xTickCount+1,__zero_reg__
 1762               	/* epilogue start */
1060:../../freeRtos/Source/tasks.c **** }
 1764               	.LM140:
 1765 05da 0F91      		pop r16
 1766 05dc FF90      		pop r15
 1767 05de EF90      		pop r14
 1768 05e0 DF90      		pop r13
 1769 05e2 CF90      		pop r12
 1770 05e4 BF90      		pop r11
 1771 05e6 AF90      		pop r10
1050:../../freeRtos/Source/tasks.c **** 		if( xPortStartScheduler() )
 1773               	.LM141:
 1774 05e8 0C94 0000 		jmp xPortStartScheduler
 1775               	.L86:
 1776               	/* epilogue start */
1060:../../freeRtos/Source/tasks.c **** }
 1778               	.LM142:
 1779 05ec 0F91      		pop r16
 1780 05ee FF90      		pop r15
 1781 05f0 EF90      		pop r14
 1782 05f2 DF90      		pop r13
 1783 05f4 CF90      		pop r12
 1784 05f6 BF90      		pop r11
 1785 05f8 AF90      		pop r10
 1786 05fa 0895      		ret
 1788               	.Lscope10:
 1790               		.stabd	78,0,0
 1792               	.global	vTaskEndScheduler
 1794               	vTaskEndScheduler:
 1795               		.stabd	46,0,0
1064:../../freeRtos/Source/tasks.c **** {
 1797               	.LM143:
 1798               	.LFBB11:
 1799               	/* prologue: function */
 1800               	/* frame size = 0 */
 1801               	/* stack size = 0 */
 1802               	.L__stack_usage = 0
1068:../../freeRtos/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1804               	.LM144:
 1805               	/* #APP */
 1806               	 ;  1068 "../../freeRtos/Source/tasks.c" 1
 1807 05fc F894      		cli
 1808               	 ;  0 "" 2
1069:../../freeRtos/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1810               	.LM145:
 1811               	/* #NOAPP */
 1812 05fe 1092 0000 		sts xSchedulerRunning,__zero_reg__
1070:../../freeRtos/Source/tasks.c **** 	vPortEndScheduler();
 1814               	.LM146:
 1815 0602 0C94 0000 		jmp vPortEndScheduler
 1817               	.Lscope11:
 1819               		.stabd	78,0,0
 1821               	.global	vTaskSuspendAll
 1823               	vTaskSuspendAll:
 1824               		.stabd	46,0,0
1075:../../freeRtos/Source/tasks.c **** {
 1826               	.LM147:
 1827               	.LFBB12:
 1828               	/* prologue: function */
 1829               	/* frame size = 0 */
 1830               	/* stack size = 0 */
 1831               	.L__stack_usage = 0
1078:../../freeRtos/Source/tasks.c **** 	++uxSchedulerSuspended;
 1833               	.LM148:
 1834 0606 8091 0000 		lds r24,uxSchedulerSuspended
 1835 060a 8F5F      		subi r24,lo8(-(1))
 1836 060c 8093 0000 		sts uxSchedulerSuspended,r24
 1837 0610 0895      		ret
 1839               	.Lscope12:
 1841               		.stabd	78,0,0
 1843               	.global	xTaskGetTickCount
 1845               	xTaskGetTickCount:
 1846               		.stabd	46,0,0
1165:../../freeRtos/Source/tasks.c **** {
 1848               	.LM149:
 1849               	.LFBB13:
 1850               	/* prologue: function */
 1851               	/* frame size = 0 */
 1852               	/* stack size = 0 */
 1853               	.L__stack_usage = 0
1169:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 1855               	.LM150:
 1856               	/* #APP */
 1857               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1858 0612 0FB6      		in		__tmp_reg__, __SREG__
 1859               	 ;  0 "" 2
 1860               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1861 0614 F894      		cli
 1862               	 ;  0 "" 2
 1863               	 ;  1169 "../../freeRtos/Source/tasks.c" 1
 1864 0616 0F92      		push	__tmp_reg__
 1865               	 ;  0 "" 2
1171:../../freeRtos/Source/tasks.c **** 		xTicks = xTickCount;
 1867               	.LM151:
 1868               	/* #NOAPP */
 1869 0618 8091 0000 		lds r24,xTickCount
 1870 061c 9091 0000 		lds r25,xTickCount+1
1173:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 1872               	.LM152:
 1873               	/* #APP */
 1874               	 ;  1173 "../../freeRtos/Source/tasks.c" 1
 1875 0620 0F90      		pop		__tmp_reg__
 1876               	 ;  0 "" 2
 1877               	 ;  1173 "../../freeRtos/Source/tasks.c" 1
 1878 0622 0FBE      		out		__SREG__, __tmp_reg__
 1879               	 ;  0 "" 2
1176:../../freeRtos/Source/tasks.c **** }
 1881               	.LM153:
 1882               	/* #NOAPP */
 1883 0624 0895      		ret
 1888               	.Lscope13:
 1890               		.stabd	78,0,0
 1892               	.global	uxTaskGetNumberOfTasks
 1894               	uxTaskGetNumberOfTasks:
 1895               		.stabd	46,0,0
1180:../../freeRtos/Source/tasks.c **** {
 1897               	.LM154:
 1898               	.LFBB14:
 1899               	/* prologue: function */
 1900               	/* frame size = 0 */
 1901               	/* stack size = 0 */
 1902               	.L__stack_usage = 0
1183:../../freeRtos/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1904               	.LM155:
 1905 0626 8091 0000 		lds r24,uxCurrentNumberOfTasks
1184:../../freeRtos/Source/tasks.c **** }
 1907               	.LM156:
 1908 062a 0895      		ret
 1910               	.Lscope14:
 1912               		.stabd	78,0,0
 1916               	.global	vTaskStartTrace
 1918               	vTaskStartTrace:
 1919               		.stabd	46,0,0
1318:../../freeRtos/Source/tasks.c **** 	{
 1921               	.LM157:
 1922               	.LFBB15:
 1923               	/* prologue: function */
 1924               	/* frame size = 0 */
 1925               	/* stack size = 0 */
 1926               	.L__stack_usage = 0
1319:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1928               	.LM158:
 1929               	/* #APP */
 1930               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1931 062c 0FB6      		in		__tmp_reg__, __SREG__
 1932               	 ;  0 "" 2
 1933               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1934 062e F894      		cli
 1935               	 ;  0 "" 2
 1936               	 ;  1319 "../../freeRtos/Source/tasks.c" 1
 1937 0630 0F92      		push	__tmp_reg__
 1938               	 ;  0 "" 2
1321:../../freeRtos/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
 1940               	.LM159:
 1941               	/* #NOAPP */
 1942 0632 8093 0000 		sts pcTraceBuffer,r24
 1943 0636 9093 0000 		sts pcTraceBuffer+1,r25
1322:../../freeRtos/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
 1945               	.LM160:
 1946 063a 8093 0000 		sts pcTraceBufferStart,r24
 1947 063e 9093 0000 		sts pcTraceBufferStart+1,r25
1323:../../freeRtos/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
 1949               	.LM161:
 1950 0642 4850      		subi r20,8
 1951 0644 5109      		sbc r21,__zero_reg__
 1952 0646 480F      		add r20,r24
 1953 0648 591F      		adc r21,r25
 1954 064a 4093 0000 		sts pcTraceBufferEnd,r20
 1955 064e 5093 0000 		sts pcTraceBufferEnd+1,r21
1324:../../freeRtos/Source/tasks.c **** 			xTracing = pdTRUE;
 1957               	.LM162:
 1958 0652 81E0      		ldi r24,lo8(1)
 1959 0654 8093 0000 		sts xTracing,r24
1326:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 1961               	.LM163:
 1962               	/* #APP */
 1963               	 ;  1326 "../../freeRtos/Source/tasks.c" 1
 1964 0658 0F90      		pop		__tmp_reg__
 1965               	 ;  0 "" 2
 1966               	 ;  1326 "../../freeRtos/Source/tasks.c" 1
 1967 065a 0FBE      		out		__SREG__, __tmp_reg__
 1968               	 ;  0 "" 2
 1969               	/* #NOAPP */
 1970 065c 0895      		ret
 1972               	.Lscope15:
 1974               		.stabd	78,0,0
 1976               	.global	ulTaskEndTrace
 1978               	ulTaskEndTrace:
 1979               		.stabd	46,0,0
1335:../../freeRtos/Source/tasks.c **** 	{
 1981               	.LM164:
 1982               	.LFBB16:
 1983               	/* prologue: function */
 1984               	/* frame size = 0 */
 1985               	/* stack size = 0 */
 1986               	.L__stack_usage = 0
1338:../../freeRtos/Source/tasks.c **** 		portENTER_CRITICAL();
 1988               	.LM165:
 1989               	/* #APP */
 1990               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 1991 065e 0FB6      		in		__tmp_reg__, __SREG__
 1992               	 ;  0 "" 2
 1993               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 1994 0660 F894      		cli
 1995               	 ;  0 "" 2
 1996               	 ;  1338 "../../freeRtos/Source/tasks.c" 1
 1997 0662 0F92      		push	__tmp_reg__
 1998               	 ;  0 "" 2
1339:../../freeRtos/Source/tasks.c **** 			xTracing = pdFALSE;
 2000               	.LM166:
 2001               	/* #NOAPP */
 2002 0664 1092 0000 		sts xTracing,__zero_reg__
1340:../../freeRtos/Source/tasks.c **** 		portEXIT_CRITICAL();
 2004               	.LM167:
 2005               	/* #APP */
 2006               	 ;  1340 "../../freeRtos/Source/tasks.c" 1
 2007 0668 0F90      		pop		__tmp_reg__
 2008               	 ;  0 "" 2
 2009               	 ;  1340 "../../freeRtos/Source/tasks.c" 1
 2010 066a 0FBE      		out		__SREG__, __tmp_reg__
 2011               	 ;  0 "" 2
1342:../../freeRtos/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
 2013               	.LM168:
 2014               	/* #NOAPP */
 2015 066c 6091 0000 		lds r22,pcTraceBuffer
 2016 0670 7091 0000 		lds r23,pcTraceBuffer+1
 2017 0674 8091 0000 		lds r24,pcTraceBufferStart
 2018 0678 9091 0000 		lds r25,pcTraceBufferStart+1
 2019 067c 681B      		sub r22,r24
 2020 067e 790B      		sbc r23,r25
 2021 0680 8827      		clr r24
 2022 0682 77FD      		sbrc r23,7
 2023 0684 8095      		com r24
 2024 0686 982F      		mov r25,r24
1345:../../freeRtos/Source/tasks.c **** 	}
 2026               	.LM169:
 2027 0688 0895      		ret
 2029               	.Lscope16:
 2031               		.stabd	78,0,0
 2033               	.global	vTaskIncrementTick
 2035               	vTaskIncrementTick:
 2036               		.stabd	46,0,0
1358:../../freeRtos/Source/tasks.c **** {
 2038               	.LM170:
 2039               	.LFBB17:
 2040 068a FF92      		push r15
 2041 068c 0F93      		push r16
 2042 068e 1F93      		push r17
 2043 0690 CF93      		push r28
 2044 0692 DF93      		push r29
 2045               	/* prologue: function */
 2046               	/* frame size = 0 */
 2047               	/* stack size = 5 */
 2048               	.L__stack_usage = 5
1362:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2050               	.LM171:
 2051 0694 8091 0000 		lds r24,uxSchedulerSuspended
 2052 0698 8111      		cpse r24,__zero_reg__
 2053 069a 00C0      		rjmp .L95
1364:../../freeRtos/Source/tasks.c **** 		++xTickCount;
 2055               	.LM172:
 2056 069c 8091 0000 		lds r24,xTickCount
 2057 06a0 9091 0000 		lds r25,xTickCount+1
 2058 06a4 0196      		adiw r24,1
 2059 06a6 8093 0000 		sts xTickCount,r24
 2060 06aa 9093 0000 		sts xTickCount+1,r25
1365:../../freeRtos/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
 2062               	.LM173:
 2063 06ae 8091 0000 		lds r24,xTickCount
 2064 06b2 9091 0000 		lds r25,xTickCount+1
 2065 06b6 892B      		or r24,r25
 2066 06b8 01F4      		brne .L96
 2067               	.LBB31:
1372:../../freeRtos/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2069               	.LM174:
 2070 06ba 8091 0000 		lds r24,pxDelayedTaskList
 2071 06be 9091 0000 		lds r25,pxDelayedTaskList+1
1373:../../freeRtos/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2073               	.LM175:
 2074 06c2 2091 0000 		lds r18,pxOverflowDelayedTaskList
 2075 06c6 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 2076 06ca 2093 0000 		sts pxDelayedTaskList,r18
 2077 06ce 3093 0000 		sts pxDelayedTaskList+1,r19
1374:../../freeRtos/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2079               	.LM176:
 2080 06d2 8093 0000 		sts pxOverflowDelayedTaskList,r24
 2081 06d6 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
1375:../../freeRtos/Source/tasks.c **** 			xNumOfOverflows++;
 2083               	.LM177:
 2084 06da 8091 0000 		lds r24,xNumOfOverflows
 2085 06de 8F5F      		subi r24,lo8(-(1))
 2086 06e0 8093 0000 		sts xNumOfOverflows,r24
 2087               	.L96:
 2088               	.LBE31:
 2089               	.LBB32:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2091               	.LM178:
 2092 06e4 29E0      		ldi r18,lo8(9)
 2093 06e6 F22E      		mov r15,r18
 2094               	.L97:
 2095 06e8 E091 0000 		lds r30,pxDelayedTaskList
 2096 06ec F091 0000 		lds r31,pxDelayedTaskList+1
 2097 06f0 8081      		ld r24,Z
 2098 06f2 8823      		tst r24
 2099 06f4 01F0      		breq .L94
 2100 06f6 E091 0000 		lds r30,pxDelayedTaskList
 2101 06fa F091 0000 		lds r31,pxDelayedTaskList+1
 2102 06fe 0580      		ldd __tmp_reg__,Z+5
 2103 0700 F681      		ldd r31,Z+6
 2104 0702 E02D      		mov r30,__tmp_reg__
 2105 0704 C681      		ldd r28,Z+6
 2106 0706 D781      		ldd r29,Z+7
 2107 0708 2097      		sbiw r28,0
 2108 070a 01F0      		breq .L94
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2110               	.LM179:
 2111 070c 2091 0000 		lds r18,xTickCount
 2112 0710 3091 0000 		lds r19,xTickCount+1
 2113 0714 8A81      		ldd r24,Y+2
 2114 0716 9B81      		ldd r25,Y+3
 2115 0718 2817      		cp r18,r24
 2116 071a 3907      		cpc r19,r25
 2117 071c 00F0      		brlo .L94
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2119               	.LM180:
 2120 071e 8E01      		movw r16,r28
 2121 0720 0E5F      		subi r16,-2
 2122 0722 1F4F      		sbci r17,-1
 2123 0724 C801      		movw r24,r16
 2124 0726 0E94 0000 		call vListRemove
 2125 072a 8C89      		ldd r24,Y+20
 2126 072c 9D89      		ldd r25,Y+21
 2127 072e 892B      		or r24,r25
 2128 0730 01F0      		breq .L99
 2129 0732 CE01      		movw r24,r28
 2130 0734 0C96      		adiw r24,12
 2131 0736 0E94 0000 		call vListRemove
 2132               	.L99:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2134               	.LM181:
 2135 073a 8E89      		ldd r24,Y+22
 2136 073c 9091 0000 		lds r25,uxTopReadyPriority
 2137 0740 9817      		cp r25,r24
 2138 0742 00F4      		brsh .L100
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2140               	.LM182:
 2141 0744 8093 0000 		sts uxTopReadyPriority,r24
 2142               	.L100:
1379:../../freeRtos/Source/tasks.c **** 		prvCheckDelayedTasks();
 2144               	.LM183:
 2145 0748 F89E      		mul r15,r24
 2146 074a C001      		movw r24,r0
 2147 074c 1124      		clr __zero_reg__
 2148 074e B801      		movw r22,r16
 2149 0750 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2150 0752 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2151 0754 0E94 0000 		call vListInsertEnd
 2152 0758 00C0      		rjmp .L97
 2153               	.L95:
 2154               	.LBE32:
1383:../../freeRtos/Source/tasks.c **** 		++uxMissedTicks;
 2156               	.LM184:
 2157 075a 8091 0000 		lds r24,uxMissedTicks
 2158 075e 8F5F      		subi r24,lo8(-(1))
 2159 0760 8093 0000 		sts uxMissedTicks,r24
 2160               	.L94:
 2161               	/* epilogue start */
1410:../../freeRtos/Source/tasks.c **** }
 2163               	.LM185:
 2164 0764 DF91      		pop r29
 2165 0766 CF91      		pop r28
 2166 0768 1F91      		pop r17
 2167 076a 0F91      		pop r16
 2168 076c FF90      		pop r15
 2169 076e 0895      		ret
 2177               	.Lscope17:
 2179               		.stabd	78,0,0
 2181               	.global	xTaskResumeAll
 2183               	xTaskResumeAll:
 2184               		.stabd	46,0,0
1083:../../freeRtos/Source/tasks.c **** {
 2186               	.LM186:
 2187               	.LFBB18:
 2188 0770 EF92      		push r14
 2189 0772 FF92      		push r15
 2190 0774 0F93      		push r16
 2191 0776 1F93      		push r17
 2192 0778 CF93      		push r28
 2193 077a DF93      		push r29
 2194               	/* prologue: function */
 2195               	/* frame size = 0 */
 2196               	/* stack size = 6 */
 2197               	.L__stack_usage = 6
1092:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 2199               	.LM187:
 2200               	/* #APP */
 2201               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 2202 077c 0FB6      		in		__tmp_reg__, __SREG__
 2203               	 ;  0 "" 2
 2204               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 2205 077e F894      		cli
 2206               	 ;  0 "" 2
 2207               	 ;  1092 "../../freeRtos/Source/tasks.c" 1
 2208 0780 0F92      		push	__tmp_reg__
 2209               	 ;  0 "" 2
1094:../../freeRtos/Source/tasks.c **** 		--uxSchedulerSuspended;
 2211               	.LM188:
 2212               	/* #NOAPP */
 2213 0782 8091 0000 		lds r24,uxSchedulerSuspended
 2214 0786 8150      		subi r24,lo8(-(-1))
 2215 0788 8093 0000 		sts uxSchedulerSuspended,r24
1096:../../freeRtos/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2217               	.LM189:
 2218 078c 8091 0000 		lds r24,uxSchedulerSuspended
 2219 0790 8823      		tst r24
 2220 0792 01F0      		breq .L109
 2221               	.L111:
1085:../../freeRtos/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 2223               	.LM190:
 2224 0794 80E0      		ldi r24,0
 2225 0796 00C0      		rjmp .L110
 2226               	.L109:
1098:../../freeRtos/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 2228               	.LM191:
 2229 0798 8091 0000 		lds r24,uxCurrentNumberOfTasks
 2230 079c 8823      		tst r24
 2231 079e 01F0      		breq .L111
 2232 07a0 F12C      		mov r15,__zero_reg__
 2233               	.LBB33:
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2235               	.LM192:
 2236 07a2 39E0      		ldi r19,lo8(9)
 2237 07a4 E32E      		mov r14,r19
 2238               	.L112:
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 2240               	.LM193:
 2241 07a6 8091 0000 		lds r24,xPendingReadyList
 2242 07aa 8111      		cpse r24,__zero_reg__
 2243 07ac 00C0      		rjmp .L115
 2244               	.L119:
1121:../../freeRtos/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 2246               	.LM194:
 2247 07ae 8091 0000 		lds r24,uxMissedTicks
 2248 07b2 8111      		cpse r24,__zero_reg__
 2249 07b4 00C0      		rjmp .L122
 2250 07b6 00C0      		rjmp .L117
 2251               	.L115:
1104:../../freeRtos/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 2253               	.LM195:
 2254 07b8 E091 0000 		lds r30,xPendingReadyList+5
 2255 07bc F091 0000 		lds r31,xPendingReadyList+5+1
 2256 07c0 C681      		ldd r28,Z+6
 2257 07c2 D781      		ldd r29,Z+7
 2258 07c4 2097      		sbiw r28,0
 2259 07c6 01F0      		breq .L119
1106:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 2261               	.LM196:
 2262 07c8 CE01      		movw r24,r28
 2263 07ca 0C96      		adiw r24,12
 2264 07cc 0E94 0000 		call vListRemove
1107:../../freeRtos/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 2266               	.LM197:
 2267 07d0 8E01      		movw r16,r28
 2268 07d2 0E5F      		subi r16,-2
 2269 07d4 1F4F      		sbci r17,-1
 2270 07d6 C801      		movw r24,r16
 2271 07d8 0E94 0000 		call vListRemove
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2273               	.LM198:
 2274 07dc 8E89      		ldd r24,Y+22
 2275 07de 9091 0000 		lds r25,uxTopReadyPriority
 2276 07e2 9817      		cp r25,r24
 2277 07e4 00F4      		brsh .L113
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2279               	.LM199:
 2280 07e6 8093 0000 		sts uxTopReadyPriority,r24
 2281               	.L113:
1108:../../freeRtos/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 2283               	.LM200:
 2284 07ea E89E      		mul r14,r24
 2285 07ec C001      		movw r24,r0
 2286 07ee 1124      		clr __zero_reg__
 2287 07f0 B801      		movw r22,r16
 2288 07f2 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2289 07f4 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2290 07f6 0E94 0000 		call vListInsertEnd
1112:../../freeRtos/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2292               	.LM201:
 2293 07fa E091 0000 		lds r30,pxCurrentTCB
 2294 07fe F091 0000 		lds r31,pxCurrentTCB+1
 2295 0802 9E89      		ldd r25,Y+22
 2296 0804 8689      		ldd r24,Z+22
 2297 0806 9817      		cp r25,r24
 2298 0808 00F0      		brlo .L112
1114:../../freeRtos/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 2300               	.LM202:
 2301 080a FF24      		clr r15
 2302 080c F394      		inc r15
 2303 080e 00C0      		rjmp .L112
 2304               	.L117:
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 2306               	.LM203:
 2307 0810 81E0      		ldi r24,lo8(1)
 2308 0812 F812      		cpse r15,r24
 2309 0814 00C0      		rjmp .L131
 2310 0816 00C0      		rjmp .L120
 2311               	.L122:
1123:../../freeRtos/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 2313               	.LM204:
 2314 0818 8091 0000 		lds r24,uxMissedTicks
 2315 081c 8823      		tst r24
 2316 081e 01F0      		breq .L117
1125:../../freeRtos/Source/tasks.c **** 						vTaskIncrementTick();
 2318               	.LM205:
 2319 0820 0E94 0000 		call vTaskIncrementTick
1126:../../freeRtos/Source/tasks.c **** 						--uxMissedTicks;
 2321               	.LM206:
 2322 0824 8091 0000 		lds r24,uxMissedTicks
 2323 0828 8150      		subi r24,lo8(-(-1))
 2324 082a 8093 0000 		sts uxMissedTicks,r24
 2325 082e 00C0      		rjmp .L122
 2326               	.L131:
1139:../../freeRtos/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 2328               	.LM207:
 2329 0830 8091 0000 		lds r24,xMissedYield
 2330 0834 8130      		cpi r24,lo8(1)
 2331 0836 01F0      		breq .+2
 2332 0838 00C0      		rjmp .L111
 2333               	.L120:
1142:../../freeRtos/Source/tasks.c **** 					xMissedYield = pdFALSE;
 2335               	.LM208:
 2336 083a 1092 0000 		sts xMissedYield,__zero_reg__
1143:../../freeRtos/Source/tasks.c **** 					portYIELD_WITHIN_API();
 2338               	.LM209:
 2339 083e 0E94 0000 		call vPortYield
1141:../../freeRtos/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 2341               	.LM210:
 2342 0842 81E0      		ldi r24,lo8(1)
 2343               	.L110:
 2344               	.LBE33:
1148:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 2346               	.LM211:
 2347               	/* #APP */
 2348               	 ;  1148 "../../freeRtos/Source/tasks.c" 1
 2349 0844 0F90      		pop		__tmp_reg__
 2350               	 ;  0 "" 2
 2351               	 ;  1148 "../../freeRtos/Source/tasks.c" 1
 2352 0846 0FBE      		out		__SREG__, __tmp_reg__
 2353               	 ;  0 "" 2
 2354               	/* epilogue start */
1151:../../freeRtos/Source/tasks.c **** }
 2356               	.LM212:
 2357               	/* #NOAPP */
 2358 0848 DF91      		pop r29
 2359 084a CF91      		pop r28
 2360 084c 1F91      		pop r17
 2361 084e 0F91      		pop r16
 2362 0850 FF90      		pop r15
 2363 0852 EF90      		pop r14
 2364 0854 0895      		ret
 2373               	.Lscope18:
 2375               		.stabd	78,0,0
 2379               	.global	vTaskDelayUntil
 2381               	vTaskDelayUntil:
 2382               		.stabd	46,0,0
 602:../../freeRtos/Source/tasks.c **** 	{
 2384               	.LM213:
 2385               	.LFBB19:
 2386 0856 0F93      		push r16
 2387 0858 1F93      		push r17
 2388 085a CF93      		push r28
 2389 085c DF93      		push r29
 2390               	/* prologue: function */
 2391               	/* frame size = 0 */
 2392               	/* stack size = 4 */
 2393               	.L__stack_usage = 4
 2394 085e 8C01      		movw r16,r24
 2395 0860 EB01      		movw r28,r22
 606:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 2397               	.LM214:
 2398 0862 0E94 0000 		call vTaskSuspendAll
 609:../../freeRtos/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 2400               	.LM215:
 2401 0866 F801      		movw r30,r16
 2402 0868 2081      		ld r18,Z
 2403 086a 3181      		ldd r19,Z+1
 2404 086c C20F      		add r28,r18
 2405 086e D31F      		adc r29,r19
 611:../../freeRtos/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 2407               	.LM216:
 2408 0870 8091 0000 		lds r24,xTickCount
 2409 0874 9091 0000 		lds r25,xTickCount+1
 2410 0878 8217      		cp r24,r18
 2411 087a 9307      		cpc r25,r19
 2412 087c 00F4      		brsh .L133
 618:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 2414               	.LM217:
 2415 087e C217      		cp r28,r18
 2416 0880 D307      		cpc r29,r19
 2417 0882 00F4      		brsh .L140
 2418 0884 00C0      		rjmp .L148
 2419               	.L133:
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 2421               	.LM218:
 2422 0886 C217      		cp r28,r18
 2423 0888 D307      		cpc r29,r19
 2424 088a 00F0      		brlo .L141
 2425               	.L148:
 628:../../freeRtos/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 2427               	.LM219:
 2428 088c 8091 0000 		lds r24,xTickCount
 2429 0890 9091 0000 		lds r25,xTickCount+1
 2430 0894 21E0      		ldi r18,lo8(1)
 2431 0896 8C17      		cp r24,r28
 2432 0898 9D07      		cpc r25,r29
 2433 089a 00F0      		brlo .L134
 2434               	.L140:
 604:../../freeRtos/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 2436               	.LM220:
 2437 089c 20E0      		ldi r18,0
 2438 089e 00C0      		rjmp .L134
 2439               	.L141:
 630:../../freeRtos/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 2441               	.LM221:
 2442 08a0 21E0      		ldi r18,lo8(1)
 2443               	.L134:
 635:../../freeRtos/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 2445               	.LM222:
 2446 08a2 F801      		movw r30,r16
 2447 08a4 C083      		st Z,r28
 2448 08a6 D183      		std Z+1,r29
 637:../../freeRtos/Source/tasks.c **** 			if( xShouldDelay )
 2450               	.LM223:
 2451 08a8 2223      		tst r18
 2452 08aa 01F0      		breq .L137
 644:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2454               	.LM224:
 2455 08ac 8091 0000 		lds r24,pxCurrentTCB
 2456 08b0 9091 0000 		lds r25,pxCurrentTCB+1
 2457 08b4 0296      		adiw r24,2
 2458 08b6 0E94 0000 		call vListRemove
 647:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2460               	.LM225:
 2461 08ba E091 0000 		lds r30,pxCurrentTCB
 2462 08be F091 0000 		lds r31,pxCurrentTCB+1
 2463 08c2 C283      		std Z+2,r28
 2464 08c4 D383      		std Z+3,r29
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2466               	.LM226:
 2467 08c6 8091 0000 		lds r24,xTickCount
 2468 08ca 9091 0000 		lds r25,xTickCount+1
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2470               	.LM227:
 2471 08ce 6091 0000 		lds r22,pxCurrentTCB
 2472 08d2 7091 0000 		lds r23,pxCurrentTCB+1
 649:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2474               	.LM228:
 2475 08d6 C817      		cp r28,r24
 2476 08d8 D907      		cpc r29,r25
 2477 08da 00F4      		brsh .L138
 653:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2479               	.LM229:
 2480 08dc 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2481 08e0 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2482 08e4 00C0      		rjmp .L146
 2483               	.L138:
 659:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2485               	.LM230:
 2486 08e6 8091 0000 		lds r24,pxDelayedTaskList
 2487 08ea 9091 0000 		lds r25,pxDelayedTaskList+1
 2488               	.L146:
 2489 08ee 6E5F      		subi r22,-2
 2490 08f0 7F4F      		sbci r23,-1
 2491 08f2 0E94 0000 		call vListInsert
 2492               	.L137:
 663:../../freeRtos/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 2494               	.LM231:
 2495 08f6 0E94 0000 		call xTaskResumeAll
 667:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 2497               	.LM232:
 2498 08fa 8111      		cpse r24,__zero_reg__
 2499 08fc 00C0      		rjmp .L132
 669:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 2501               	.LM233:
 2502 08fe 0E94 0000 		call vPortYield
 2503               	.L132:
 2504               	/* epilogue start */
 671:../../freeRtos/Source/tasks.c **** 	}
 2506               	.LM234:
 2507 0902 DF91      		pop r29
 2508 0904 CF91      		pop r28
 2509 0906 1F91      		pop r17
 2510 0908 0F91      		pop r16
 2511 090a 0895      		ret
 2517               	.Lscope19:
 2519               		.stabd	78,0,0
 2522               	.global	vTaskDelay
 2524               	vTaskDelay:
 2525               		.stabd	46,0,0
 679:../../freeRtos/Source/tasks.c **** 	{
 2527               	.LM235:
 2528               	.LFBB20:
 2529 090c 0F93      		push r16
 2530 090e 1F93      		push r17
 2531 0910 CF93      		push r28
 2532 0912 DF93      		push r29
 2533               	/* prologue: function */
 2534               	/* frame size = 0 */
 2535               	/* stack size = 4 */
 2536               	.L__stack_usage = 4
 2537 0914 8C01      		movw r16,r24
 684:../../freeRtos/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 2539               	.LM236:
 2540 0916 0097      		sbiw r24,0
 2541 0918 01F4      		brne .L150
 2542               	.L154:
 730:../../freeRtos/Source/tasks.c **** 			portYIELD_WITHIN_API();
 2544               	.LM237:
 2545 091a 0E94 0000 		call vPortYield
 2546 091e 00C0      		rjmp .L149
 2547               	.L150:
 686:../../freeRtos/Source/tasks.c **** 			vTaskSuspendAll();
 2549               	.LM238:
 2550 0920 0E94 0000 		call vTaskSuspendAll
 700:../../freeRtos/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 2552               	.LM239:
 2553 0924 C091 0000 		lds r28,xTickCount
 2554 0928 D091 0000 		lds r29,xTickCount+1
 2555 092c C00F      		add r28,r16
 2556 092e D11F      		adc r29,r17
 705:../../freeRtos/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2558               	.LM240:
 2559 0930 8091 0000 		lds r24,pxCurrentTCB
 2560 0934 9091 0000 		lds r25,pxCurrentTCB+1
 2561 0938 0296      		adiw r24,2
 2562 093a 0E94 0000 		call vListRemove
 708:../../freeRtos/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2564               	.LM241:
 2565 093e E091 0000 		lds r30,pxCurrentTCB
 2566 0942 F091 0000 		lds r31,pxCurrentTCB+1
 2567 0946 C283      		std Z+2,r28
 2568 0948 D383      		std Z+3,r29
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2570               	.LM242:
 2571 094a 8091 0000 		lds r24,xTickCount
 2572 094e 9091 0000 		lds r25,xTickCount+1
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2574               	.LM243:
 2575 0952 6091 0000 		lds r22,pxCurrentTCB
 2576 0956 7091 0000 		lds r23,pxCurrentTCB+1
 710:../../freeRtos/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 2578               	.LM244:
 2579 095a C817      		cp r28,r24
 2580 095c D907      		cpc r29,r25
 2581 095e 00F4      		brsh .L152
 714:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 2583               	.LM245:
 2584 0960 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2585 0964 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2586 0968 00C0      		rjmp .L158
 2587               	.L152:
 720:../../freeRtos/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 2589               	.LM246:
 2590 096a 8091 0000 		lds r24,pxDelayedTaskList
 2591 096e 9091 0000 		lds r25,pxDelayedTaskList+1
 2592               	.L158:
 2593 0972 6E5F      		subi r22,-2
 2594 0974 7F4F      		sbci r23,-1
 2595 0976 0E94 0000 		call vListInsert
 723:../../freeRtos/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 2597               	.LM247:
 2598 097a 0E94 0000 		call xTaskResumeAll
 728:../../freeRtos/Source/tasks.c **** 		if( !xAlreadyYielded )
 2600               	.LM248:
 2601 097e 8823      		tst r24
 2602 0980 01F0      		breq .L154
 2603               	.L149:
 2604               	/* epilogue start */
 732:../../freeRtos/Source/tasks.c **** 	}
 2606               	.LM249:
 2607 0982 DF91      		pop r29
 2608 0984 CF91      		pop r28
 2609 0986 1F91      		pop r17
 2610 0988 0F91      		pop r16
 2611 098a 0895      		ret
 2616               	.Lscope20:
 2618               		.stabd	78,0,0
 2619               		.section	.rodata.str1.1
 2620               	.LC2:
 2621 0017 0D0A 00   		.string	"\r\n"
 2622               		.text
 2625               	.global	vTaskList
 2627               	vTaskList:
 2628               		.stabd	46,0,0
1190:../../freeRtos/Source/tasks.c **** 	{
 2630               	.LM250:
 2631               	.LFBB21:
 2632 098c 0F93      		push r16
 2633 098e 1F93      		push r17
 2634 0990 CF93      		push r28
 2635 0992 DF93      		push r29
 2636               	/* prologue: function */
 2637               	/* frame size = 0 */
 2638               	/* stack size = 4 */
 2639               	.L__stack_usage = 4
 2640 0994 EC01      		movw r28,r24
1196:../../freeRtos/Source/tasks.c **** 		vTaskSuspendAll();
 2642               	.LM251:
 2643 0996 0E94 0000 		call vTaskSuspendAll
1201:../../freeRtos/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
 2645               	.LM252:
 2646 099a 1882      		st Y,__zero_reg__
1202:../../freeRtos/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 2648               	.LM253:
 2649 099c 60E0      		ldi r22,lo8(.LC2)
 2650 099e 70E0      		ldi r23,hi8(.LC2)
 2651 09a0 CE01      		movw r24,r28
 2652 09a2 0E94 0000 		call strcat
1204:../../freeRtos/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
 2654               	.LM254:
 2655 09a6 1091 0000 		lds r17,uxTopUsedPriority
 2656 09aa 1F5F      		subi r17,lo8(-(1))
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 2658               	.LM255:
 2659 09ac 09E0      		ldi r16,lo8(9)
 2660               	.L162:
1208:../../freeRtos/Source/tasks.c **** 				uxQueue--;
 2662               	.LM256:
 2663 09ae 1150      		subi r17,lo8(-(-1))
1210:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 2665               	.LM257:
 2666 09b0 019F      		mul r16,r17
 2667 09b2 B001      		movw r22,r0
 2668 09b4 1124      		clr __zero_reg__
 2669 09b6 6050      		subi r22,lo8(-(pxReadyTasksLists))
 2670 09b8 7040      		sbci r23,hi8(-(pxReadyTasksLists))
 2671 09ba FB01      		movw r30,r22
 2672 09bc 8081      		ld r24,Z
 2673 09be 8823      		tst r24
 2674 09c0 01F0      		breq .L160
1212:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 2676               	.LM258:
 2677 09c2 42E5      		ldi r20,lo8(82)
 2678 09c4 CE01      		movw r24,r28
 2679 09c6 0E94 0000 		call prvListTaskWithinSingleList
 2680               	.L160:
1214:../../freeRtos/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 2682               	.LM259:
 2683 09ca 1111      		cpse r17,__zero_reg__
 2684 09cc 00C0      		rjmp .L162
1216:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
 2686               	.LM260:
 2687 09ce E091 0000 		lds r30,pxDelayedTaskList
 2688 09d2 F091 0000 		lds r31,pxDelayedTaskList+1
 2689 09d6 8081      		ld r24,Z
 2690 09d8 8823      		tst r24
 2691 09da 01F0      		breq .L163
1218:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 2693               	.LM261:
 2694 09dc 6091 0000 		lds r22,pxDelayedTaskList
 2695 09e0 7091 0000 		lds r23,pxDelayedTaskList+1
 2696 09e4 42E4      		ldi r20,lo8(66)
 2697 09e6 CE01      		movw r24,r28
 2698 09e8 0E94 0000 		call prvListTaskWithinSingleList
 2699               	.L163:
1221:../../freeRtos/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
 2701               	.LM262:
 2702 09ec E091 0000 		lds r30,pxOverflowDelayedTaskList
 2703 09f0 F091 0000 		lds r31,pxOverflowDelayedTaskList+1
 2704 09f4 8081      		ld r24,Z
 2705 09f6 8823      		tst r24
 2706 09f8 01F0      		breq .L164
1223:../../freeRtos/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 2708               	.LM263:
 2709 09fa 6091 0000 		lds r22,pxOverflowDelayedTaskList
 2710 09fe 7091 0000 		lds r23,pxOverflowDelayedTaskList+1
 2711 0a02 42E4      		ldi r20,lo8(66)
 2712 0a04 CE01      		movw r24,r28
 2713 0a06 0E94 0000 		call prvListTaskWithinSingleList
 2714               	.L164:
1237:../../freeRtos/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
 2716               	.LM264:
 2717 0a0a 8091 0000 		lds r24,xSuspendedTaskList
 2718 0a0e 8823      		tst r24
 2719 0a10 01F0      		breq .L165
1239:../../freeRtos/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
 2721               	.LM265:
 2722 0a12 43E5      		ldi r20,lo8(83)
 2723 0a14 60E0      		ldi r22,lo8(xSuspendedTaskList)
 2724 0a16 70E0      		ldi r23,hi8(xSuspendedTaskList)
 2725 0a18 CE01      		movw r24,r28
 2726 0a1a 0E94 0000 		call prvListTaskWithinSingleList
 2727               	.L165:
 2728               	/* epilogue start */
1245:../../freeRtos/Source/tasks.c **** 	}
 2730               	.LM266:
 2731 0a1e DF91      		pop r29
 2732 0a20 CF91      		pop r28
 2733 0a22 1F91      		pop r17
 2734 0a24 0F91      		pop r16
1244:../../freeRtos/Source/tasks.c **** 		xTaskResumeAll();
 2736               	.LM267:
 2737 0a26 0C94 0000 		jmp xTaskResumeAll
 2742               	.Lscope21:
 2744               		.stabd	78,0,0
 2746               	.global	vTaskSwitchContext
 2748               	vTaskSwitchContext:
 2749               		.stabd	46,0,0
1554:../../freeRtos/Source/tasks.c **** {
 2751               	.LM268:
 2752               	.LFBB22:
 2753               	/* prologue: function */
 2754               	/* frame size = 0 */
 2755               	/* stack size = 0 */
 2756               	.L__stack_usage = 0
1555:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2758               	.LM269:
 2759 0a2a 8091 0000 		lds r24,uxSchedulerSuspended
 2760 0a2e 8111      		cpse r24,__zero_reg__
 2761 0a30 00C0      		rjmp .L179
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2763               	.LM270:
 2764 0a32 99E0      		ldi r25,lo8(9)
 2765 0a34 00C0      		rjmp .L180
 2766               	.L179:
1559:../../freeRtos/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2768               	.LM271:
 2769 0a36 81E0      		ldi r24,lo8(1)
 2770 0a38 8093 0000 		sts xMissedYield,r24
1560:../../freeRtos/Source/tasks.c **** 		return;
 2772               	.LM272:
 2773 0a3c 0895      		ret
 2774               	.L180:
1583:../../freeRtos/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2776               	.LM273:
 2777 0a3e E091 0000 		lds r30,uxTopReadyPriority
 2778 0a42 9E9F      		mul r25,r30
 2779 0a44 F001      		movw r30,r0
 2780 0a46 1124      		clr __zero_reg__
 2781 0a48 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2782 0a4a F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2783 0a4c 8081      		ld r24,Z
 2784 0a4e 8111      		cpse r24,__zero_reg__
 2785 0a50 00C0      		rjmp .L188
1585:../../freeRtos/Source/tasks.c **** 		--uxTopReadyPriority;
 2787               	.LM274:
 2788 0a52 8091 0000 		lds r24,uxTopReadyPriority
 2789 0a56 8150      		subi r24,lo8(-(-1))
 2790 0a58 8093 0000 		sts uxTopReadyPriority,r24
 2791 0a5c 00C0      		rjmp .L180
 2792               	.L188:
 2793               	.LBB34:
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2795               	.LM275:
 2796 0a5e E091 0000 		lds r30,uxTopReadyPriority
 2797 0a62 89E0      		ldi r24,lo8(9)
 2798 0a64 E89F      		mul r30,r24
 2799 0a66 F001      		movw r30,r0
 2800 0a68 1124      		clr __zero_reg__
 2801 0a6a E050      		subi r30,lo8(-(pxReadyTasksLists))
 2802 0a6c F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2803 0a6e A181      		ldd r26,Z+1
 2804 0a70 B281      		ldd r27,Z+2
 2805 0a72 1296      		adiw r26,2
 2806 0a74 0D90      		ld __tmp_reg__,X+
 2807 0a76 BC91      		ld r27,X
 2808 0a78 A02D      		mov r26,__tmp_reg__
 2809 0a7a A183      		std Z+1,r26
 2810 0a7c B283      		std Z+2,r27
 2811 0a7e CF01      		movw r24,r30
 2812 0a80 0396      		adiw r24,3
 2813 0a82 A817      		cp r26,r24
 2814 0a84 B907      		cpc r27,r25
 2815 0a86 01F4      		brne .L183
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2817               	.LM276:
 2818 0a88 1296      		adiw r26,2
 2819 0a8a 8D91      		ld r24,X+
 2820 0a8c 9C91      		ld r25,X
 2821 0a8e 1397      		sbiw r26,2+1
 2822 0a90 8183      		std Z+1,r24
 2823 0a92 9283      		std Z+2,r25
 2824               	.L183:
1590:../../freeRtos/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2826               	.LM277:
 2827 0a94 0180      		ldd __tmp_reg__,Z+1
 2828 0a96 F281      		ldd r31,Z+2
 2829 0a98 E02D      		mov r30,__tmp_reg__
 2830 0a9a 8681      		ldd r24,Z+6
 2831 0a9c 9781      		ldd r25,Z+7
 2832 0a9e 8093 0000 		sts pxCurrentTCB,r24
 2833 0aa2 9093 0000 		sts pxCurrentTCB+1,r25
 2834               	.LBE34:
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2836               	.LM278:
 2837 0aa6 8091 0000 		lds r24,xTracing
 2838 0aaa 8823      		tst r24
 2839 0aac 01F4      		brne .+2
 2840 0aae 00C0      		rjmp .L178
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2842               	.LM279:
 2843 0ab0 E091 0000 		lds r30,pxCurrentTCB
 2844 0ab4 F091 0000 		lds r31,pxCurrentTCB+1
 2845 0ab8 9091 0000 		lds r25,uxPreviousTask
 2846 0abc 83A1      		ldd r24,Z+35
 2847 0abe 9817      		cp r25,r24
 2848 0ac0 01F4      		brne .+2
 2849 0ac2 00C0      		rjmp .L178
 2850 0ac4 8091 0000 		lds r24,pcTraceBuffer
 2851 0ac8 9091 0000 		lds r25,pcTraceBuffer+1
 2852 0acc 0896      		adiw r24,8
 2853 0ace 2091 0000 		lds r18,pcTraceBufferEnd
 2854 0ad2 3091 0000 		lds r19,pcTraceBufferEnd+1
 2855 0ad6 8217      		cp r24,r18
 2856 0ad8 9307      		cpc r25,r19
 2857 0ada 00F4      		brsh .L184
 2858 0adc E091 0000 		lds r30,pxCurrentTCB
 2859 0ae0 F091 0000 		lds r31,pxCurrentTCB+1
 2860 0ae4 83A1      		ldd r24,Z+35
 2861 0ae6 8093 0000 		sts uxPreviousTask,r24
 2862 0aea E091 0000 		lds r30,pcTraceBuffer
 2863 0aee F091 0000 		lds r31,pcTraceBuffer+1
 2864 0af2 4091 0000 		lds r20,xTickCount
 2865 0af6 5091 0000 		lds r21,xTickCount+1
 2866 0afa 60E0      		ldi r22,0
 2867 0afc 70E0      		ldi r23,0
 2868 0afe 4083      		st Z,r20
 2869 0b00 5183      		std Z+1,r21
 2870 0b02 6283      		std Z+2,r22
 2871 0b04 7383      		std Z+3,r23
 2872 0b06 2091 0000 		lds r18,pcTraceBuffer
 2873 0b0a 3091 0000 		lds r19,pcTraceBuffer+1
 2874 0b0e 2C5F      		subi r18,-4
 2875 0b10 3F4F      		sbci r19,-1
 2876 0b12 2093 0000 		sts pcTraceBuffer,r18
 2877 0b16 3093 0000 		sts pcTraceBuffer+1,r19
 2878 0b1a E091 0000 		lds r30,pcTraceBuffer
 2879 0b1e F091 0000 		lds r31,pcTraceBuffer+1
 2880 0b22 90E0      		ldi r25,0
 2881 0b24 A0E0      		ldi r26,0
 2882 0b26 B0E0      		ldi r27,0
 2883 0b28 8083      		st Z,r24
 2884 0b2a 9183      		std Z+1,r25
 2885 0b2c A283      		std Z+2,r26
 2886 0b2e B383      		std Z+3,r27
 2887 0b30 8091 0000 		lds r24,pcTraceBuffer
 2888 0b34 9091 0000 		lds r25,pcTraceBuffer+1
 2889 0b38 0496      		adiw r24,4
 2890 0b3a 8093 0000 		sts pcTraceBuffer,r24
 2891 0b3e 9093 0000 		sts pcTraceBuffer+1,r25
 2892 0b42 0895      		ret
 2893               	.L184:
1593:../../freeRtos/Source/tasks.c **** 	vWriteTraceToBuffer();
 2895               	.LM280:
 2896 0b44 1092 0000 		sts xTracing,__zero_reg__
 2897               	.L178:
 2898 0b48 0895      		ret
 2903               	.Lscope22:
 2905               		.stabd	78,0,0
 2909               	.global	vTaskPlaceOnEventList
 2911               	vTaskPlaceOnEventList:
 2912               		.stabd	46,0,0
1598:../../freeRtos/Source/tasks.c **** {
 2914               	.LM281:
 2915               	.LFBB23:
 2916 0b4a CF93      		push r28
 2917 0b4c DF93      		push r29
 2918               	/* prologue: function */
 2919               	/* frame size = 0 */
 2920               	/* stack size = 2 */
 2921               	.L__stack_usage = 2
 2922 0b4e EB01      		movw r28,r22
1607:../../freeRtos/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2924               	.LM282:
 2925 0b50 6091 0000 		lds r22,pxCurrentTCB
 2926 0b54 7091 0000 		lds r23,pxCurrentTCB+1
 2927 0b58 645F      		subi r22,-12
 2928 0b5a 7F4F      		sbci r23,-1
 2929 0b5c 0E94 0000 		call vListInsert
1612:../../freeRtos/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2931               	.LM283:
 2932 0b60 8091 0000 		lds r24,pxCurrentTCB
 2933 0b64 9091 0000 		lds r25,pxCurrentTCB+1
 2934 0b68 0296      		adiw r24,2
 2935 0b6a 0E94 0000 		call vListRemove
1617:../../freeRtos/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2937               	.LM284:
 2938 0b6e CF3F      		cpi r28,-1
 2939 0b70 8FEF      		ldi r24,-1
 2940 0b72 D807      		cpc r29,r24
 2941 0b74 01F4      		brne .L190
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2943               	.LM285:
 2944 0b76 6091 0000 		lds r22,pxCurrentTCB
 2945 0b7a 7091 0000 		lds r23,pxCurrentTCB+1
 2946 0b7e 6E5F      		subi r22,-2
 2947 0b80 7F4F      		sbci r23,-1
 2948 0b82 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2949 0b84 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2950               	/* epilogue start */
1664:../../freeRtos/Source/tasks.c **** }
 2952               	.LM286:
 2953 0b86 DF91      		pop r29
 2954 0b88 CF91      		pop r28
1622:../../freeRtos/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2956               	.LM287:
 2957 0b8a 0C94 0000 		jmp vListInsertEnd
 2958               	.L190:
1628:../../freeRtos/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2960               	.LM288:
 2961 0b8e 8091 0000 		lds r24,xTickCount
 2962 0b92 9091 0000 		lds r25,xTickCount+1
 2963 0b96 8C0F      		add r24,r28
 2964 0b98 9D1F      		adc r25,r29
1630:../../freeRtos/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2966               	.LM289:
 2967 0b9a E091 0000 		lds r30,pxCurrentTCB
 2968 0b9e F091 0000 		lds r31,pxCurrentTCB+1
 2969 0ba2 8283      		std Z+2,r24
 2970 0ba4 9383      		std Z+3,r25
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 2972               	.LM290:
 2973 0ba6 2091 0000 		lds r18,xTickCount
 2974 0baa 3091 0000 		lds r19,xTickCount+1
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 2976               	.LM291:
 2977 0bae 6091 0000 		lds r22,pxCurrentTCB
 2978 0bb2 7091 0000 		lds r23,pxCurrentTCB+1
1632:../../freeRtos/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 2980               	.LM292:
 2981 0bb6 8217      		cp r24,r18
 2982 0bb8 9307      		cpc r25,r19
 2983 0bba 00F4      		brsh .L191
1635:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 2985               	.LM293:
 2986 0bbc 8091 0000 		lds r24,pxOverflowDelayedTaskList
 2987 0bc0 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 2988 0bc4 00C0      		rjmp .L192
 2989               	.L191:
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 2991               	.LM294:
 2992 0bc6 8091 0000 		lds r24,pxDelayedTaskList
 2993 0bca 9091 0000 		lds r25,pxDelayedTaskList+1
 2994               	.L192:
 2995 0bce 6E5F      		subi r22,-2
 2996 0bd0 7F4F      		sbci r23,-1
 2997               	/* epilogue start */
1664:../../freeRtos/Source/tasks.c **** }
 2999               	.LM295:
 3000 0bd2 DF91      		pop r29
 3001 0bd4 CF91      		pop r28
1640:../../freeRtos/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 3003               	.LM296:
 3004 0bd6 0C94 0000 		jmp vListInsert
 3009               	.Lscope23:
 3011               		.stabd	78,0,0
 3014               	.global	xTaskRemoveFromEventList
 3016               	xTaskRemoveFromEventList:
 3017               		.stabd	46,0,0
1668:../../freeRtos/Source/tasks.c **** {
 3019               	.LM297:
 3020               	.LFBB24:
 3021 0bda 0F93      		push r16
 3022 0bdc 1F93      		push r17
 3023 0bde CF93      		push r28
 3024 0be0 DF93      		push r29
 3025               	/* prologue: function */
 3026               	/* frame size = 0 */
 3027               	/* stack size = 4 */
 3028               	.L__stack_usage = 4
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3030               	.LM298:
 3031 0be2 DC01      		movw r26,r24
 3032 0be4 2C91      		ld r18,X
 3033 0be6 2223      		tst r18
 3034 0be8 01F0      		breq .L199
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3036               	.LM299:
 3037 0bea 1596      		adiw r26,5
 3038 0bec ED91      		ld r30,X+
 3039 0bee FC91      		ld r31,X
 3040 0bf0 1697      		sbiw r26,5+1
 3041 0bf2 C681      		ldd r28,Z+6
 3042 0bf4 D781      		ldd r29,Z+7
 3043 0bf6 00C0      		rjmp .L194
 3044               	.L199:
1682:../../freeRtos/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3046               	.LM300:
 3047 0bf8 C0E0      		ldi r28,0
 3048 0bfa D0E0      		ldi r29,0
 3049               	.L194:
1683:../../freeRtos/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3051               	.LM301:
 3052 0bfc 8E01      		movw r16,r28
 3053 0bfe 045F      		subi r16,-12
 3054 0c00 1F4F      		sbci r17,-1
 3055 0c02 C801      		movw r24,r16
 3056 0c04 0E94 0000 		call vListRemove
1685:../../freeRtos/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3058               	.LM302:
 3059 0c08 8091 0000 		lds r24,uxSchedulerSuspended
 3060 0c0c 8111      		cpse r24,__zero_reg__
 3061 0c0e 00C0      		rjmp .L195
1687:../../freeRtos/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 3063               	.LM303:
 3064 0c10 8E01      		movw r16,r28
 3065 0c12 0E5F      		subi r16,-2
 3066 0c14 1F4F      		sbci r17,-1
 3067 0c16 C801      		movw r24,r16
 3068 0c18 0E94 0000 		call vListRemove
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 3070               	.LM304:
 3071 0c1c 8E89      		ldd r24,Y+22
 3072 0c1e 9091 0000 		lds r25,uxTopReadyPriority
 3073 0c22 9817      		cp r25,r24
 3074 0c24 00F4      		brsh .L196
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 3076               	.LM305:
 3077 0c26 8093 0000 		sts uxTopReadyPriority,r24
 3078               	.L196:
1688:../../freeRtos/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 3080               	.LM306:
 3081 0c2a B9E0      		ldi r27,lo8(9)
 3082 0c2c 8B9F      		mul r24,r27
 3083 0c2e C001      		movw r24,r0
 3084 0c30 1124      		clr __zero_reg__
 3085 0c32 B801      		movw r22,r16
 3086 0c34 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3087 0c36 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3088 0c38 00C0      		rjmp .L200
 3089               	.L195:
1694:../../freeRtos/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 3091               	.LM307:
 3092 0c3a B801      		movw r22,r16
 3093 0c3c 80E0      		ldi r24,lo8(xPendingReadyList)
 3094 0c3e 90E0      		ldi r25,hi8(xPendingReadyList)
 3095               	.L200:
 3096 0c40 0E94 0000 		call vListInsertEnd
1697:../../freeRtos/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 3098               	.LM308:
 3099 0c44 E091 0000 		lds r30,pxCurrentTCB
 3100 0c48 F091 0000 		lds r31,pxCurrentTCB+1
 3101 0c4c 81E0      		ldi r24,lo8(1)
 3102 0c4e 2E89      		ldd r18,Y+22
 3103 0c50 9689      		ldd r25,Z+22
 3104 0c52 2917      		cp r18,r25
 3105 0c54 00F4      		brsh .L198
 3106 0c56 80E0      		ldi r24,0
 3107               	.L198:
 3108               	/* epilogue start */
1711:../../freeRtos/Source/tasks.c **** }
 3110               	.LM309:
 3111 0c58 DF91      		pop r29
 3112 0c5a CF91      		pop r28
 3113 0c5c 1F91      		pop r17
 3114 0c5e 0F91      		pop r16
 3115 0c60 0895      		ret
 3120               	.Lscope24:
 3122               		.stabd	78,0,0
 3125               	.global	vTaskSetTimeOutState
 3127               	vTaskSetTimeOutState:
 3128               		.stabd	46,0,0
1715:../../freeRtos/Source/tasks.c **** {
 3130               	.LM310:
 3131               	.LFBB25:
 3132               	/* prologue: function */
 3133               	/* frame size = 0 */
 3134               	/* stack size = 0 */
 3135               	.L__stack_usage = 0
1716:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3137               	.LM311:
 3138 0c62 2091 0000 		lds r18,xNumOfOverflows
 3139 0c66 FC01      		movw r30,r24
 3140 0c68 2083      		st Z,r18
1717:../../freeRtos/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3142               	.LM312:
 3143 0c6a 2091 0000 		lds r18,xTickCount
 3144 0c6e 3091 0000 		lds r19,xTickCount+1
 3145 0c72 2183      		std Z+1,r18
 3146 0c74 3283      		std Z+2,r19
 3147 0c76 0895      		ret
 3149               	.Lscope25:
 3151               		.stabd	78,0,0
 3155               	.global	xTaskCheckForTimeOut
 3157               	xTaskCheckForTimeOut:
 3158               		.stabd	46,0,0
1722:../../freeRtos/Source/tasks.c **** {
 3160               	.LM313:
 3161               	.LFBB26:
 3162               	/* prologue: function */
 3163               	/* frame size = 0 */
 3164               	/* stack size = 0 */
 3165               	.L__stack_usage = 0
1725:../../freeRtos/Source/tasks.c **** 	portENTER_CRITICAL();
 3167               	.LM314:
 3168               	/* #APP */
 3169               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 3170 0c78 0FB6      		in		__tmp_reg__, __SREG__
 3171               	 ;  0 "" 2
 3172               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 3173 0c7a F894      		cli
 3174               	 ;  0 "" 2
 3175               	 ;  1725 "../../freeRtos/Source/tasks.c" 1
 3176 0c7c 0F92      		push	__tmp_reg__
 3177               	 ;  0 "" 2
1731:../../freeRtos/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3179               	.LM315:
 3180               	/* #NOAPP */
 3181 0c7e DB01      		movw r26,r22
 3182 0c80 4D91      		ld r20,X+
 3183 0c82 5C91      		ld r21,X
 3184 0c84 4F3F      		cpi r20,-1
 3185 0c86 BFEF      		ldi r27,-1
 3186 0c88 5B07      		cpc r21,r27
 3187 0c8a 01F0      		breq .L205
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 3189               	.LM316:
 3190 0c8c F091 0000 		lds r31,xNumOfOverflows
 3191 0c90 DC01      		movw r26,r24
 3192 0c92 EC91      		ld r30,X
 3193 0c94 1196      		adiw r26,1
 3194 0c96 2D91      		ld r18,X+
 3195 0c98 3C91      		ld r19,X
 3196 0c9a 1297      		sbiw r26,1+1
 3197 0c9c FE17      		cp r31,r30
 3198 0c9e 01F0      		breq .L204
1738:../../freeRtos/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 3200               	.LM317:
 3201 0ca0 E091 0000 		lds r30,xTickCount
 3202 0ca4 F091 0000 		lds r31,xTickCount+1
 3203 0ca8 E217      		cp r30,r18
 3204 0caa F307      		cpc r31,r19
 3205 0cac 00F4      		brsh .L207
 3206               	.L204:
1746:../../freeRtos/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 3208               	.LM318:
 3209 0cae E091 0000 		lds r30,xTickCount
 3210 0cb2 F091 0000 		lds r31,xTickCount+1
 3211 0cb6 E21B      		sub r30,r18
 3212 0cb8 F30B      		sbc r31,r19
 3213 0cba E417      		cp r30,r20
 3214 0cbc F507      		cpc r31,r21
 3215 0cbe 00F4      		brsh .L207
1749:../../freeRtos/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 3217               	.LM319:
 3218 0cc0 E091 0000 		lds r30,xTickCount
 3219 0cc4 F091 0000 		lds r31,xTickCount+1
 3220 0cc8 2E1B      		sub r18,r30
 3221 0cca 3F0B      		sbc r19,r31
 3222 0ccc 240F      		add r18,r20
 3223 0cce 351F      		adc r19,r21
 3224 0cd0 FB01      		movw r30,r22
 3225 0cd2 2083      		st Z,r18
 3226 0cd4 3183      		std Z+1,r19
1750:../../freeRtos/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3228               	.LM320:
 3229 0cd6 0E94 0000 		call vTaskSetTimeOutState
 3230               	.L205:
1733:../../freeRtos/Source/tasks.c **** 				xReturn = pdFALSE;
 3232               	.LM321:
 3233 0cda 80E0      		ldi r24,0
 3234 0cdc 00C0      		rjmp .L203
 3235               	.L207:
1744:../../freeRtos/Source/tasks.c **** 			xReturn = pdTRUE;
 3237               	.LM322:
 3238 0cde 81E0      		ldi r24,lo8(1)
 3239               	.L203:
1758:../../freeRtos/Source/tasks.c **** 	portEXIT_CRITICAL();
 3241               	.LM323:
 3242               	/* #APP */
 3243               	 ;  1758 "../../freeRtos/Source/tasks.c" 1
 3244 0ce0 0F90      		pop		__tmp_reg__
 3245               	 ;  0 "" 2
 3246               	 ;  1758 "../../freeRtos/Source/tasks.c" 1
 3247 0ce2 0FBE      		out		__SREG__, __tmp_reg__
 3248               	 ;  0 "" 2
1761:../../freeRtos/Source/tasks.c **** }
 3250               	.LM324:
 3251               	/* #NOAPP */
 3252 0ce4 0895      		ret
 3257               	.Lscope26:
 3259               		.stabd	78,0,0
 3261               	.global	vTaskMissedYield
 3263               	vTaskMissedYield:
 3264               		.stabd	46,0,0
1765:../../freeRtos/Source/tasks.c **** {
 3266               	.LM325:
 3267               	.LFBB27:
 3268               	/* prologue: function */
 3269               	/* frame size = 0 */
 3270               	/* stack size = 0 */
 3271               	.L__stack_usage = 0
1766:../../freeRtos/Source/tasks.c **** 	xMissedYield = pdTRUE;
 3273               	.LM326:
 3274 0ce6 81E0      		ldi r24,lo8(1)
 3275 0ce8 8093 0000 		sts xMissedYield,r24
 3276 0cec 0895      		ret
 3278               	.Lscope27:
 3280               		.stabd	78,0,0
 3281               		.local	pcStatusString
 3282               		.comm	pcStatusString,50,1
 3283               		.data
 3286               	uxPreviousTask:
 3287 0000 FF        		.byte	-1
 3288               		.local	xTracing
 3289               		.comm	xTracing,1,1
 3290               		.local	pcTraceBufferEnd
 3291               		.comm	pcTraceBufferEnd,2,1
 3292               		.local	pcTraceBufferStart
 3293               		.comm	pcTraceBufferStart,2,1
 3294               		.local	pcTraceBuffer
 3295               		.comm	pcTraceBuffer,2,1
 3296               		.local	uxTaskNumber
 3297               		.comm	uxTaskNumber,1,1
 3298               		.local	xNumOfOverflows
 3299               		.comm	xNumOfOverflows,1,1
 3300               		.local	xMissedYield
 3301               		.comm	xMissedYield,1,1
 3302               		.local	uxMissedTicks
 3303               		.comm	uxMissedTicks,1,1
 3304               		.local	uxSchedulerSuspended
 3305               		.comm	uxSchedulerSuspended,1,1
 3306               		.local	xSchedulerRunning
 3307               		.comm	xSchedulerRunning,1,1
 3308               		.local	uxTopReadyPriority
 3309               		.comm	uxTopReadyPriority,1,1
 3310               		.local	uxTopUsedPriority
 3311               		.comm	uxTopUsedPriority,1,1
 3312               		.local	xTickCount
 3313               		.comm	xTickCount,2,1
 3314               		.local	uxCurrentNumberOfTasks
 3315               		.comm	uxCurrentNumberOfTasks,1,1
 3316               		.local	xSuspendedTaskList
 3317               		.comm	xSuspendedTaskList,9,1
 3318               		.local	xPendingReadyList
 3319               		.comm	xPendingReadyList,9,1
 3320               		.local	pxOverflowDelayedTaskList
 3321               		.comm	pxOverflowDelayedTaskList,2,1
 3322               		.local	pxDelayedTaskList
 3323               		.comm	pxDelayedTaskList,2,1
 3324               		.local	xDelayedTaskList2
 3325               		.comm	xDelayedTaskList2,9,1
 3326               		.local	xDelayedTaskList1
 3327               		.comm	xDelayedTaskList1,9,1
 3328               		.local	pxReadyTasksLists
 3329               		.comm	pxReadyTasksLists,27,1
 3330               	.global	pxCurrentTCB
 3331               		.section .bss
 3334               	pxCurrentTCB:
 3335 0000 0000      		.zero	2
 3360               		.text
 3362               	.Letext0:
 3363               		.ident	"GCC: (GNU) 4.8.2"
 3364               	.global __do_copy_data
 3365               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccPyGBGR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPyGBGR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPyGBGR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPyGBGR.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccPyGBGR.s:6      *ABS*:000000000000003a __RAMPY__
     /tmp/ccPyGBGR.s:7      *ABS*:0000000000000039 __RAMPX__
     /tmp/ccPyGBGR.s:8      *ABS*:0000000000000038 __RAMPD__
     /tmp/ccPyGBGR.s:9      *ABS*:0000000000000034 __CCP__
     /tmp/ccPyGBGR.s:10     *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPyGBGR.s:11     *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPyGBGR.s:484    .text:0000000000000000 prvIdleTask
     /tmp/ccPyGBGR.s:511    .text:0000000000000006 prvListTaskWithinSingleList
                             .bss:0000000000000002 pcStatusString
     /tmp/ccPyGBGR.s:740    .text:000000000000014c xTaskGenericCreate
     /tmp/ccPyGBGR.s:3313   .bss:0000000000000045 uxCurrentNumberOfTasks
     /tmp/ccPyGBGR.s:3334   .bss:0000000000000000 pxCurrentTCB
     /tmp/ccPyGBGR.s:3327   .bss:000000000000006e pxReadyTasksLists
     /tmp/ccPyGBGR.s:3325   .bss:0000000000000065 xDelayedTaskList1
     /tmp/ccPyGBGR.s:3323   .bss:000000000000005c xDelayedTaskList2
     /tmp/ccPyGBGR.s:3317   .bss:000000000000004f xPendingReadyList
     /tmp/ccPyGBGR.s:3315   .bss:0000000000000046 xSuspendedTaskList
     /tmp/ccPyGBGR.s:3321   .bss:000000000000005a pxDelayedTaskList
     /tmp/ccPyGBGR.s:3319   .bss:0000000000000058 pxOverflowDelayedTaskList
     /tmp/ccPyGBGR.s:3305   .bss:0000000000000040 xSchedulerRunning
     /tmp/ccPyGBGR.s:3309   .bss:0000000000000042 uxTopUsedPriority
     /tmp/ccPyGBGR.s:3295   .bss:000000000000003b uxTaskNumber
     /tmp/ccPyGBGR.s:3307   .bss:0000000000000041 uxTopReadyPriority
     /tmp/ccPyGBGR.s:1100   .text:0000000000000328 uxTaskPriorityGet
     /tmp/ccPyGBGR.s:1155   .text:0000000000000344 vTaskPrioritySet
     /tmp/ccPyGBGR.s:1329   .text:0000000000000402 vTaskSuspend
     /tmp/ccPyGBGR.s:1443   .text:000000000000047c xTaskIsTaskSuspended
     /tmp/ccPyGBGR.s:1497   .text:00000000000004a0 vTaskResume
     /tmp/ccPyGBGR.s:1607   .text:000000000000051a xTaskResumeFromISR
     /tmp/ccPyGBGR.s:3303   .bss:000000000000003f uxSchedulerSuspended
     /tmp/ccPyGBGR.s:1710   .text:0000000000000598 vTaskStartScheduler
     /tmp/ccPyGBGR.s:3311   .bss:0000000000000043 xTickCount
     /tmp/ccPyGBGR.s:1794   .text:00000000000005fc vTaskEndScheduler
     /tmp/ccPyGBGR.s:1823   .text:0000000000000606 vTaskSuspendAll
     /tmp/ccPyGBGR.s:1845   .text:0000000000000612 xTaskGetTickCount
     /tmp/ccPyGBGR.s:1894   .text:0000000000000626 uxTaskGetNumberOfTasks
     /tmp/ccPyGBGR.s:1918   .text:000000000000062c vTaskStartTrace
     /tmp/ccPyGBGR.s:3293   .bss:0000000000000039 pcTraceBuffer
     /tmp/ccPyGBGR.s:3291   .bss:0000000000000037 pcTraceBufferStart
     /tmp/ccPyGBGR.s:3289   .bss:0000000000000035 pcTraceBufferEnd
     /tmp/ccPyGBGR.s:3282   .bss:0000000000000034 xTracing
     /tmp/ccPyGBGR.s:1978   .text:000000000000065e ulTaskEndTrace
     /tmp/ccPyGBGR.s:2035   .text:000000000000068a vTaskIncrementTick
     /tmp/ccPyGBGR.s:3297   .bss:000000000000003c xNumOfOverflows
     /tmp/ccPyGBGR.s:3301   .bss:000000000000003e uxMissedTicks
     /tmp/ccPyGBGR.s:2183   .text:0000000000000770 xTaskResumeAll
     /tmp/ccPyGBGR.s:3299   .bss:000000000000003d xMissedYield
     /tmp/ccPyGBGR.s:2381   .text:0000000000000856 vTaskDelayUntil
     /tmp/ccPyGBGR.s:2524   .text:000000000000090c vTaskDelay
     /tmp/ccPyGBGR.s:2627   .text:000000000000098c vTaskList
     /tmp/ccPyGBGR.s:2748   .text:0000000000000a2a vTaskSwitchContext
     /tmp/ccPyGBGR.s:3286   .data:0000000000000000 uxPreviousTask
     /tmp/ccPyGBGR.s:2911   .text:0000000000000b4a vTaskPlaceOnEventList
     /tmp/ccPyGBGR.s:3016   .text:0000000000000bda xTaskRemoveFromEventList
     /tmp/ccPyGBGR.s:3127   .text:0000000000000c62 vTaskSetTimeOutState
     /tmp/ccPyGBGR.s:3157   .text:0000000000000c78 xTaskCheckForTimeOut
     /tmp/ccPyGBGR.s:3263   .text:0000000000000ce6 vTaskMissedYield

UNDEFINED SYMBOLS
vPortYield
sprintf
strcat
pvPortMalloc
vPortFree
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
vListRemove
xPortStartScheduler
vPortEndScheduler
vListInsert
__do_copy_data
__do_clear_bss
